{"buggy_code": ["/* vim: ts=8:sw=4:expandtab\n *\n * $Id$\n *\n * Copyright (c) 1994-2012  Tim Bunce  Ireland.\n *\n * See COPYRIGHT section in DBI.pm for usage and distribution rights.\n */\n\n#define IN_DBI_XS 1     /* see DBIXS.h */\n#define PERL_NO_GET_CONTEXT\n\n#include \"DBIXS.h\"      /* DBI public interface for DBD's written in C  */\n\n# if (defined(_WIN32) && (! defined(HAS_GETTIMEOFDAY)))\n#include <sys/timeb.h>\n# endif\n\n/* The XS dispatcher code can optimize calls to XS driver methods,\n * bypassing the usual call_sv() and argument handling overheads.\n * Just-in-case it causes problems there's an (undocumented) way\n * to disable it by setting an env var.\n */\nstatic int use_xsbypass = 1; /* set in dbi_bootinit() */\n\n#ifndef CvISXSUB\n#define CvISXSUB(sv) CvXSUB(sv)\n#endif\n\n#define DBI_MAGIC '~'\n\n/* HvMROMETA introduced in 5.9.5, but mro_meta_init not exported in 5.10.0 */\n#if (PERL_VERSION < 10)\n#  define MY_cache_gen(stash) 0\n#else\n#  if ((PERL_VERSION == 10) && (PERL_SUBVERSION == 0))\n#    define MY_cache_gen(stash) \\\n        (HvAUX(stash)->xhv_mro_meta \\\n        ? HvAUX(stash)->xhv_mro_meta->cache_gen \\\n        : 0)\n#  else\n#    define MY_cache_gen(stash) HvMROMETA(stash)->cache_gen\n#  endif\n#endif\n\n/* If the tests fail with errors about 'setlinebuf' then try    */\n/* deleting the lines in the block below except the setvbuf one */\n#ifndef PerlIO_setlinebuf\n#ifdef HAS_SETLINEBUF\n#define PerlIO_setlinebuf(f)        setlinebuf(f)\n#else\n#ifndef USE_PERLIO\n#define PerlIO_setlinebuf(f)        setvbuf(f, Nullch, _IOLBF, 0)\n#endif\n#endif\n#endif\n\n#if (PERL_VERSION < 8) || ((PERL_VERSION == 8) && (PERL_SUBVERSION == 0))\n#define DBI_save_hv_fetch_ent\n#endif\n\n/* prior to 5.8.9: when a CV is duped, the mg dup method is called,\n * then *afterwards*, any_ptr is copied from the old CV to the new CV.\n * This wipes out anything which the dup method did to any_ptr.\n * This needs working around */\n#if defined(USE_ITHREADS) && (PERL_VERSION == 8) && (PERL_SUBVERSION < 9)\n#  define BROKEN_DUP_ANY_PTR\n#endif\n\n/* types of method name */\n\ntypedef enum {\n    methtype_ordinary, /* nothing special about this method name */\n    methtype_DESTROY,\n    methtype_FETCH,\n    methtype_can,\n    methtype_fetch_star, /* fetch*, i.e. fetch() or fetch_...() */\n    methtype_set_err\n} meth_types;\n\n\nstatic imp_xxh_t *dbih_getcom      _((SV *h));\nstatic imp_xxh_t *dbih_getcom2     _((pTHX_ SV *h, MAGIC **mgp));\nstatic void       dbih_clearcom    _((imp_xxh_t *imp_xxh));\nstatic int        dbih_logmsg      _((imp_xxh_t *imp_xxh, const char *fmt, ...));\nstatic SV        *dbih_make_com    _((SV *parent_h, imp_xxh_t *p_imp_xxh, const char *imp_class, STRLEN imp_size, STRLEN extra, SV *copy));\nstatic SV        *dbih_make_fdsv   _((SV *sth, const char *imp_class, STRLEN imp_size, const char *col_name));\nstatic AV        *dbih_get_fbav    _((imp_sth_t *imp_sth));\nstatic SV        *dbih_event       _((SV *h, const char *name, SV*, SV*));\nstatic int        dbih_set_attr_k  _((SV *h, SV *keysv, int dbikey, SV *valuesv));\nstatic SV        *dbih_get_attr_k  _((SV *h, SV *keysv, int dbikey));\nstatic int       dbih_sth_bind_col _((SV *sth, SV *col, SV *ref, SV *attribs));\n\nstatic int      set_err_char _((SV *h, imp_xxh_t *imp_xxh, const char *err_c, IV err_i, const char *errstr, const char *state, const char *method));\nstatic int      set_err_sv   _((SV *h, imp_xxh_t *imp_xxh, SV *err, SV *errstr, SV *state, SV *method));\nstatic int      quote_type _((int sql_type, int p, int s, int *base_type, void *v));\nstatic int      sql_type_cast_svpv _((pTHX_ SV *sv, int sql_type, U32 flags, void *v));\nstatic I32      dbi_hash _((const char *string, long i));\nstatic void     dbih_dumphandle _((pTHX_ SV *h, const char *msg, int level));\nstatic int      dbih_dumpcom _((pTHX_ imp_xxh_t *imp_xxh, const char *msg, int level));\nstatic int      dbi_ima_free(pTHX_ SV* sv, MAGIC* mg);\n#if defined(USE_ITHREADS) && !defined(BROKEN_DUP_ANY_PTR)\nstatic int      dbi_ima_dup(pTHX_ MAGIC* mg, CLONE_PARAMS *param);\n#endif\nchar *neatsvpv _((SV *sv, STRLEN maxlen));\nSV * preparse(SV *dbh, const char *statement, IV ps_return, IV ps_accept, void *foo);\nstatic meth_types get_meth_type(const char * const name);\n\nstruct imp_drh_st { dbih_drc_t com; };\nstruct imp_dbh_st { dbih_dbc_t com; };\nstruct imp_sth_st { dbih_stc_t com; };\nstruct imp_fdh_st { dbih_fdc_t com; };\n\n/* identify the type of a method name for dispatch behaviour */\n/* (should probably be folded into the IMA flags mechanism)  */\n\nstatic meth_types\nget_meth_type(const char * const name)\n{\n    switch (name[0]) {\n    case 'D':\n        if strEQ(name,\"DESTROY\")\n            return methtype_DESTROY;\n        break;\n    case 'F':\n        if strEQ(name,\"FETCH\")\n            return methtype_FETCH;\n        break;\n    case 'c':\n        if strEQ(name,\"can\")\n            return methtype_can;\n        break;\n    case 'f':\n        if strnEQ(name,\"fetch\", 5) /* fetch* */\n            return methtype_fetch_star;\n        break;\n    case 's':\n        if strEQ(name,\"set_err\")\n            return methtype_set_err;\n        break;\n    }\n    return methtype_ordinary;\n}\n\n\n/* Internal Method Attributes (attached to dispatch methods when installed) */\n/* NOTE: when adding SVs to dbi_ima_t, update dbi_ima_dup() dbi_ima_free()\n * to ensure that they are duped and correctly ref-counted */\n\ntypedef struct dbi_ima_st {\n    U8 minargs;\n    U8 maxargs;\n    IV hidearg;\n    /* method_trace controls tracing of method calls in the dispatcher:\n    - if the current trace flags include a trace flag in method_trace\n    then set trace_level to min(2,trace_level) for duration of the call.\n    - else, if trace_level < (method_trace & DBIc_TRACE_LEVEL_MASK)\n    then don't trace the call\n    */\n    U32 method_trace;\n    const char *usage_msg;\n    U32 flags;\n    meth_types meth_type;\n\n    /* cached outer to inner method mapping */\n    HV *stash;          /* the stash we found the GV in */\n    GV *gv;             /* the GV containing the inner sub */\n    U32 generation;     /* cache invalidation */\n#ifdef BROKEN_DUP_ANY_PTR\n    PerlInterpreter *my_perl; /* who owns this struct */\n#endif\n\n} dbi_ima_t;\n\n/* These values are embedded in the data passed to install_method       */\n#define IMA_HAS_USAGE             0x00000001  /* check parameter usage        */\n#define IMA_FUNC_REDIRECT         0x00000002  /* is $h->func(..., \"method\")   */\n#define IMA_KEEP_ERR              0x00000004  /* don't reset err & errstr     */\n#define IMA_KEEP_ERR_SUB          0x00000008  /*  '' if in a nested call      */\n#define IMA_NO_TAINT_IN           0x00000010  /* don't check for PL_tainted args */\n#define IMA_NO_TAINT_OUT          0x00000020  /* don't taint results          */\n#define IMA_COPY_UP_STMT          0x00000040  /* copy sth Statement to dbh    */\n#define IMA_END_WORK              0x00000080  /* method is commit or rollback */\n#define IMA_STUB                  0x00000100  /* donothing eg $dbh->connected */\n#define IMA_CLEAR_STMT            0x00000200  /* clear Statement before call  */\n#define IMA_UNRELATED_TO_STMT     0x00000400  /* profile as empty Statement   */\n#define IMA_NOT_FOUND_OKAY        0x00000800  /* no error if not found        */\n#define IMA_EXECUTE               0x00001000  /* do/execute: DBIcf_Executed   */\n#define IMA_SHOW_ERR_STMT         0x00002000  /* dbh meth relates to Statement*/\n#define IMA_HIDE_ERR_PARAMVALUES  0x00004000  /* ParamValues are not relevant */\n#define IMA_IS_FACTORY            0x00008000  /* new h ie connect and prepare */\n#define IMA_CLEAR_CACHED_KIDS     0x00010000  /* clear CachedKids before call */\n\n#define DBIc_STATE_adjust(imp_xxh, state)                                \\\n    (SvOK(state)        /* SQLSTATE is implemented by driver   */        \\\n        ? (strEQ(SvPV_nolen(state),\"00000\") ? &PL_sv_no : sv_mortalcopy(state))\\\n        : (SvTRUE(DBIc_ERR(imp_xxh))                                     \\\n            ? sv_2mortal(newSVpv(\"S1000\",5)) /* General error   */       \\\n            : &PL_sv_no)                /* Success (\"00000\")    */       \\\n    )\n\n#define DBI_LAST_HANDLE         g_dbi_last_h /* special fake inner handle */\n#define DBI_IS_LAST_HANDLE(h)   ((DBI_LAST_HANDLE) == SvRV(h))\n#define DBI_SET_LAST_HANDLE(h)  ((DBI_LAST_HANDLE) =  SvRV(h))\n#define DBI_UNSET_LAST_HANDLE   ((DBI_LAST_HANDLE) =  &PL_sv_undef)\n#define DBI_LAST_HANDLE_OK      ((DBI_LAST_HANDLE) != &PL_sv_undef)\n\n#define DBIS_TRACE_LEVEL        (DBIS->debug & DBIc_TRACE_LEVEL_MASK)\n#define DBIS_TRACE_FLAGS        (DBIS->debug)   /* includes level */\n\n#ifdef PERL_LONG_MAX\n#define MAX_LongReadLen PERL_LONG_MAX\n#else\n#define MAX_LongReadLen 2147483647L\n#endif\n\n#ifdef DBI_USE_THREADS\nstatic char *dbi_build_opt = \"-ithread\";\n#else\nstatic char *dbi_build_opt = \"-nothread\";\n#endif\n\n/* 32 bit magic FNV-0 and FNV-1 prime */\n#define FNV_32_PRIME ((UV)0x01000193)\n\n\n/* perl doesn't know anything about the dbi_ima_t struct attached to the\n * CvXSUBANY(cv).any_ptr slot, so add some magic to the CV to handle\n * duping and freeing.\n */\n\nstatic MGVTBL dbi_ima_vtbl = { 0, 0, 0, 0, dbi_ima_free,\n                                    0,\n#if defined(USE_ITHREADS) && !defined(BROKEN_DUP_ANY_PTR)\n                                    dbi_ima_dup\n#else\n                                    0\n#endif\n#if (PERL_VERSION > 8) || ((PERL_VERSION == 8) && (PERL_SUBVERSION >= 9))\n                                    , 0\n#endif\n                                    };\n\nstatic int dbi_ima_free(pTHX_ SV* sv, MAGIC* mg)\n{\n    dbi_ima_t *ima = (dbi_ima_t *)(CvXSUBANY((CV*)sv).any_ptr);\n#ifdef BROKEN_DUP_ANY_PTR\n    if (ima->my_perl != my_perl)\n        return 0;\n#endif\n    SvREFCNT_dec(ima->stash);\n    SvREFCNT_dec(ima->gv);\n    Safefree(ima);\n    return 0;\n}\n\n#if defined(USE_ITHREADS) && !defined(BROKEN_DUP_ANY_PTR)\nstatic int dbi_ima_dup(pTHX_ MAGIC* mg, CLONE_PARAMS *param)\n{\n    dbi_ima_t *ima, *nima;\n    CV *cv  = (CV*) mg->mg_ptr;\n    CV *ncv = (CV*)ptr_table_fetch(PL_ptr_table, (cv));\n\n    PERL_UNUSED_VAR(param);\n    mg->mg_ptr = (char *)ncv;\n    ima = (dbi_ima_t*) CvXSUBANY(cv).any_ptr;\n    Newx(nima, 1, dbi_ima_t);\n    *nima = *ima; /* structure copy */\n    CvXSUBANY(ncv).any_ptr = nima;\n    nima->stash = NULL;\n    nima->gv    = NULL;\n    return 0;\n}\n#endif\n\n\n\n/* --- make DBI safe for multiple perl interpreters --- */\n/*     Originally contributed by Murray Nesbitt of ActiveState, */\n/*     but later updated to use MY_CTX */\n\n#define MY_CXT_KEY \"DBI::_guts\" XS_VERSION\n\ntypedef struct {\n    SV   *dbi_last_h;  /* maybe better moved into dbistate_t? */\n    dbistate_t* dbi_state;\n} my_cxt_t;\n\nSTART_MY_CXT\n\n#undef DBIS\n#define DBIS                   (MY_CXT.dbi_state)\n\n#define g_dbi_last_h            (MY_CXT.dbi_last_h)\n\n/* allow the 'static' dbi_state struct to be accessed from other files */\ndbistate_t**\n_dbi_state_lval(pTHX)\n{\n    dMY_CXT;\n    return &(MY_CXT.dbi_state);\n}\n\n\n/* --- */\n\nstatic void *\nmalloc_using_sv(STRLEN len)\n{\n    dTHX;\n    SV *sv = newSV(len ? len : 1);\n    void *p = SvPVX(sv);\n    memzero(p, len);\n    return p;\n}\n\nstatic char *\nsavepv_using_sv(char *str)\n{\n    char *buf = malloc_using_sv(strlen(str));\n    strcpy(buf, str);\n    return buf;\n}\n\n\n/* --- support functions for concat_hash_sorted --- */\n\ntypedef struct str_uv_sort_pair_st {\n    char *key;\n    UV numeric;\n} str_uv_sort_pair_t;\n\nstatic int\n_cmp_number(const void *val1, const void *val2)\n{\n    UV first  = ((str_uv_sort_pair_t *)val1)->numeric;\n    UV second = ((str_uv_sort_pair_t *)val2)->numeric;\n\n    if (first > second)\n        return 1;\n    if (first < second)\n        return -1;\n    /* only likely to reach here if numeric sort forced for non-numeric keys */\n    /* fallback to comparing the key strings */\n    return strcmp(\n        ((str_uv_sort_pair_t *)val1)->key,\n        ((str_uv_sort_pair_t *)val2)->key\n    );\n}\n\nstatic int \n_cmp_str (const void *val1, const void *val2)\n{\n    return strcmp( *(char **)val1, *(char **)val2);\n}\n\nstatic char **\n_sort_hash_keys (HV *hash, int num_sort, STRLEN *total_length)\n{\n    dTHX;\n    I32 hv_len, key_len;\n    HE *entry;\n    char **keys;\n    unsigned int idx = 0;\n    STRLEN tot_len = 0;\n    bool has_non_numerics = 0;\n    str_uv_sort_pair_t *numbers;\n\n    hv_len = hv_iterinit(hash);\n    if (!hv_len)\n        return 0;\n\n    Newz(0, keys,    hv_len, char *);\n    Newz(0, numbers, hv_len, str_uv_sort_pair_t);\n\n    while ((entry = hv_iternext(hash))) {\n        *(keys+idx) = hv_iterkey(entry, &key_len);\n        tot_len += key_len;\n        \n        if (grok_number(*(keys+idx), key_len, &(numbers+idx)->numeric) != IS_NUMBER_IN_UV) {\n            has_non_numerics = 1;\n            (numbers+idx)->numeric = 0;\n        }\n\n        (numbers+idx)->key = *(keys+idx);\n        ++idx;\n    }\n\n    if (total_length)\n        *total_length = tot_len;\n\n    if (num_sort < 0)\n        num_sort = (has_non_numerics) ? 0 : 1;\n\n    if (!num_sort) {\n        qsort(keys, hv_len, sizeof(char*), _cmp_str);\n    }\n    else {\n        qsort(numbers, hv_len, sizeof(str_uv_sort_pair_t), _cmp_number);\n        for (idx = 0; idx < hv_len; ++idx)\n            *(keys+idx) = (numbers+idx)->key;\n    }\n\n    Safefree(numbers);\n    return keys;\n}\n\n\nstatic SV *\n_join_hash_sorted(HV *hash, char *kv_sep, STRLEN kv_sep_len, char *pair_sep, STRLEN pair_sep_len, int use_neat, int num_sort)\n{\n        dTHX;\n        I32 hv_len;\n        STRLEN total_len = 0;\n        char **keys;\n        unsigned int i = 0;\n        SV *return_sv;\n\n        keys = _sort_hash_keys(hash, num_sort, &total_len);\n        if (!keys)\n            return newSVpv(\"\", 0);\n\n        if (!kv_sep_len)\n            kv_sep_len = strlen(kv_sep);\n        if (!pair_sep_len)\n            pair_sep_len = strlen(pair_sep);\n\n        hv_len = hv_iterinit(hash);\n        /* total_len += Separators + quotes + term null */\n        total_len += kv_sep_len*hv_len + pair_sep_len*hv_len+2*hv_len+1;\n        return_sv = newSV(total_len);\n        sv_setpv(return_sv, \"\"); /* quell undef warnings */\n\n        for (i=0; i<hv_len; ++i) {\n            SV **hash_svp = hv_fetch(hash, keys[i], strlen(keys[i]), 0);\n\n            sv_catpv(return_sv, keys[i]); /* XXX keys can't contain nul chars */\n            sv_catpvn(return_sv, kv_sep, kv_sep_len);\n\n            if (!hash_svp) {    /* should never happen */\n                warn(\"No hash entry with key '%s'\", keys[i]);\n                sv_catpvn(return_sv, \"???\", 3);\n                continue;\n            }\n\n            if (use_neat) {\n                sv_catpv(return_sv, neatsvpv(*hash_svp,0));\n            }\n            else {\n                if (SvOK(*hash_svp)) {\n                     STRLEN hv_val_len;\n                     char *hv_val = SvPV(*hash_svp, hv_val_len);\n                     sv_catpvn(return_sv, \"'\", 1);\n                     sv_catpvn(return_sv, hv_val, hv_val_len);\n                     sv_catpvn(return_sv, \"'\", 1);\n                }\n                else sv_catpvn(return_sv, \"undef\", 5);\n            }\n\n            if (i < hv_len-1)\n                sv_catpvn(return_sv, pair_sep, pair_sep_len);\n        }\n\n        Safefree(keys);\n\n        return return_sv;\n}\n\n\n\n/* handy for embedding into condition expression for debugging */\n/*\nstatic int warn1(char *s) { warn(\"%s\", s); return 1; }\nstatic int dump1(SV *sv)  { dTHX; sv_dump(sv); return 1; }\n*/\n\n\n/* --- */\n\nstatic void\ncheck_version(const char *name, int dbis_cv, int dbis_cs, int need_dbixs_cv, int drc_s,\n        int dbc_s, int stc_s, int fdc_s)\n{\n    dTHX;\n    dMY_CXT;\n    static const char msg[] = \"you probably need to rebuild the DBD driver (or possibly the DBI)\";\n    (void)need_dbixs_cv;\n    if (dbis_cv != DBISTATE_VERSION || dbis_cs != sizeof(*DBIS))\n        croak(\"DBI/DBD internal version mismatch (DBI is v%d/s%lu, DBD %s expected v%d/s%d) %s.\\n\",\n            DBISTATE_VERSION, (long unsigned int)sizeof(*DBIS), name, dbis_cv, dbis_cs, msg);\n    /* Catch structure size changes - We should probably force a recompile if the DBI   */\n    /* runtime version is different from the build time. That would be harsh but safe.  */\n    if (drc_s != sizeof(dbih_drc_t) || dbc_s != sizeof(dbih_dbc_t) ||\n        stc_s != sizeof(dbih_stc_t) || fdc_s != sizeof(dbih_fdc_t) )\n            croak(\"%s (dr:%d/%ld, db:%d/%ld, st:%d/%ld, fd:%d/%ld), %s.\\n\",\n                \"DBI/DBD internal structure mismatch\",\n                drc_s, (long)sizeof(dbih_drc_t), dbc_s, (long)sizeof(dbih_dbc_t),\n                stc_s, (long)sizeof(dbih_stc_t), fdc_s, (long)sizeof(dbih_fdc_t), msg);\n}\n\nstatic void\ndbi_bootinit(dbistate_t * parent_dbis)\n{\n    dTHX;\n    dMY_CXT;\n    dbistate_t* DBISx;\n\n    DBISx = (struct dbistate_st*)malloc_using_sv(sizeof(struct dbistate_st));\n    DBIS = DBISx;\n\n    /* make DBIS available to DBD modules the \"old\" (<= 1.618) way,\n     * so that unrecompiled DBD's will still work against a newer DBI */\n    sv_setiv(get_sv(\"DBI::_dbistate\", GV_ADDMULTI),\n            PTR2IV(MY_CXT.dbi_state));\n\n    /* store version and size so we can spot DBI/DBD version mismatch   */\n    DBIS->check_version = check_version;\n    DBIS->version = DBISTATE_VERSION;\n    DBIS->size    = sizeof(*DBIS);\n    DBIS->xs_version = DBIXS_VERSION;\n\n    DBIS->logmsg      = dbih_logmsg;\n    DBIS->logfp       = PerlIO_stderr();\n    DBIS->debug       = (parent_dbis) ? parent_dbis->debug\n                            : SvIV(get_sv(\"DBI::dbi_debug\",0x5));\n    DBIS->neatsvpvlen = (parent_dbis) ? parent_dbis->neatsvpvlen\n                                      : get_sv(\"DBI::neat_maxlen\", GV_ADDMULTI);\n#ifdef DBI_USE_THREADS\n    DBIS->thr_owner   = PERL_GET_THX;\n#endif\n\n    /* store some function pointers so DBD's can call our functions     */\n    DBIS->getcom      = dbih_getcom;\n    DBIS->clearcom    = dbih_clearcom;\n    DBIS->event       = dbih_event;\n    DBIS->set_attr_k  = dbih_set_attr_k;\n    DBIS->get_attr_k  = dbih_get_attr_k;\n    DBIS->get_fbav    = dbih_get_fbav;\n    DBIS->make_fdsv   = dbih_make_fdsv;\n    DBIS->neat_svpv   = neatsvpv;\n    DBIS->bind_as_num = quote_type; /* XXX deprecated */\n    DBIS->hash        = dbi_hash;\n    DBIS->set_err_sv  = set_err_sv;\n    DBIS->set_err_char= set_err_char;\n    DBIS->bind_col    = dbih_sth_bind_col;\n    DBIS->sql_type_cast_svpv = sql_type_cast_svpv;\n\n\n    /* Remember the last handle used. BEWARE! Sneaky stuff here!        */\n    /* We want a handle reference but we don't want to increment        */\n    /* the handle's reference count and we don't want perl to try       */\n    /* to destroy it during global destruction. Take care!              */\n    DBI_UNSET_LAST_HANDLE;      /* ensure setup the correct way         */\n\n    /* trick to avoid 'possible typo' warnings  */\n    gv_fetchpv(\"DBI::state\",  GV_ADDMULTI, SVt_PV);\n    gv_fetchpv(\"DBI::err\",    GV_ADDMULTI, SVt_PV);\n    gv_fetchpv(\"DBI::errstr\", GV_ADDMULTI, SVt_PV);\n    gv_fetchpv(\"DBI::lasth\",  GV_ADDMULTI, SVt_PV);\n    gv_fetchpv(\"DBI::rows\",   GV_ADDMULTI, SVt_PV);\n\n    /* we only need to check the env var on the initial boot\n     * which is handy because it can core dump during CLONE on windows\n     */\n    if (!parent_dbis && getenv(\"PERL_DBI_XSBYPASS\"))\n        use_xsbypass = atoi(getenv(\"PERL_DBI_XSBYPASS\"));\n}\n\n\n/* ----------------------------------------------------------------- */\n/* Utility functions                                                 */\n\n\nstatic char *\ndbih_htype_name(int htype)\n{\n    switch(htype) {\n    case DBIt_DR: return \"dr\";\n    case DBIt_DB: return \"db\";\n    case DBIt_ST: return \"st\";\n    case DBIt_FD: return \"fd\";\n    default:      return \"??\";\n    }\n}\n\n\nchar *\nneatsvpv(SV *sv, STRLEN maxlen) /* return a tidy ascii value, for debugging only */\n{\n    dTHX;\n    dMY_CXT;\n    STRLEN len;\n    SV *nsv = Nullsv;\n    SV *infosv = Nullsv;\n    char *v, *quote;\n\n    /* We take care not to alter the supplied sv in any way at all.      */\n    /* (but if it is SvGMAGICAL we have to call mg_get and that can      */\n    /* have side effects, especially as it may be called twice overall.) */\n\n    if (!sv)\n        return \"Null!\";                         /* should never happen  */\n\n    /* try to do the right thing with magical values                    */\n    if (SvMAGICAL(sv)) {\n        if (DBIS_TRACE_LEVEL >= 5) {    /* add magic details to help debugging  */\n            MAGIC* mg;\n            infosv = sv_2mortal(newSVpv(\" (magic-\",0));\n            if (SvSMAGICAL(sv)) sv_catpvn(infosv,\"s\",1);\n            if (SvGMAGICAL(sv)) sv_catpvn(infosv,\"g\",1);\n            if (SvRMAGICAL(sv)) sv_catpvn(infosv,\"r\",1);\n            sv_catpvn(infosv,\":\",1);\n            for (mg = SvMAGIC(sv); mg; mg = mg->mg_moremagic)\n                sv_catpvn(infosv, &mg->mg_type, 1);\n            sv_catpvn(infosv, \")\", 1);\n        }\n        if (SvGMAGICAL(sv) && !PL_dirty)\n            mg_get(sv);         /* trigger magic to FETCH the value     */\n    }\n\n    if (!SvOK(sv)) {\n        if (SvTYPE(sv) >= SVt_PVAV)\n            return (char *)sv_reftype(sv,0);    /* raw AV/HV etc, not via a ref */\n        if (!infosv)\n            return \"undef\";\n        sv_insert(infosv, 0,0, \"undef\",5);\n        return SvPVX(infosv);\n    }\n\n    if (SvNIOK(sv)) {     /* is a numeric value - so no surrounding quotes      */\n        if (SvPOK(sv)) {  /* already has string version of the value, so use it */\n            v = SvPV(sv,len);\n            if (len == 0) { v=\"''\"; len=2; } /* catch &sv_no style special case */\n            if (!infosv)\n                return v;\n            sv_insert(infosv, 0,0, v, len);\n            return SvPVX(infosv);\n        }\n        /* we don't use SvPV here since we don't want to alter sv in _any_ way  */\n        if (SvUOK(sv))\n             nsv = newSVpvf(\"%\"UVuf, SvUVX(sv));\n        else if (SvIOK(sv))\n             nsv = newSVpvf(\"%\"IVdf, SvIVX(sv));\n        else nsv = newSVpvf(\"%\"NVgf, SvNVX(sv));\n        if (infosv)\n            sv_catsv(nsv, infosv);\n        return SvPVX(sv_2mortal(nsv));\n    }\n\n    nsv = sv_newmortal();\n    sv_upgrade(nsv, SVt_PV);\n\n    if (SvROK(sv)) {\n        if (!SvAMAGIC(sv))      /* (un-amagic'd) refs get no special treatment  */\n            v = SvPV(sv,len);\n        else {\n            /* handle Overload magic refs */\n            (void)SvAMAGIC_off(sv);   /* should really be done via local scoping */\n            v = SvPV(sv,len);   /* XXX how does this relate to SvGMAGIC?   */\n            SvAMAGIC_on(sv);\n        }\n        sv_setpvn(nsv, v, len);\n        if (infosv)\n            sv_catsv(nsv, infosv);\n        return SvPV(nsv, len);\n    }\n\n    if (SvPOK(sv))              /* usual simple string case                */\n        v = SvPV(sv,len);\n    else                        /* handles all else via sv_2pv()           */\n        v = SvPV(sv,len);       /* XXX how does this relate to SvGMAGIC?   */\n\n    /* for strings we limit the length and translate codes      */\n    if (maxlen == 0)\n        maxlen = SvIV(DBIS->neatsvpvlen);\n    if (maxlen < 6)                     /* handle daft values   */\n        maxlen = 6;\n    maxlen -= 2;                        /* account for quotes   */\n\n    quote = (SvUTF8(sv)) ? \"\\\"\" : \"'\";\n    if (len > maxlen) {\n        SvGROW(nsv, (1+maxlen+1+1));\n        sv_setpvn(nsv, quote, 1);\n        sv_catpvn(nsv, v, maxlen-3);    /* account for three dots */\n        sv_catpvn(nsv, \"...\", 3);\n    } else {\n        SvGROW(nsv, (1+len+1+1));\n        sv_setpvn(nsv, quote, 1);\n        sv_catpvn(nsv, v, len);\n    }\n    sv_catpvn(nsv, quote, 1);\n    if (infosv)\n        sv_catsv(nsv, infosv);\n    v = SvPV(nsv, len);\n    if (!SvUTF8(sv)) {\n        while(len-- > 0) { /* cleanup string (map control chars to ascii etc) */\n            const char c = v[len] & 0x7F;       /* ignore top bit for multinational chars */\n            if (!isPRINT(c) && !isSPACE(c))\n                v[len] = '.';\n        }\n    }\n    return v;\n}\n\n\nstatic void\ncopy_statement_to_parent(pTHX_ SV *h, imp_xxh_t *imp_xxh)\n{\n    SV *parent;\n    if (PL_dirty)\n        return;\n    parent = DBIc_PARENT_H(imp_xxh);\n    if (parent && SvROK(parent)) {\n        SV *tmp_sv = *hv_fetch((HV*)SvRV(h), \"Statement\", 9, 1);\n        if (SvOK(tmp_sv))\n            (void)hv_store((HV*)SvRV(parent), \"Statement\", 9, SvREFCNT_inc(tmp_sv), 0);\n    }\n}\n\n\nstatic int\nset_err_char(SV *h, imp_xxh_t *imp_xxh, const char *err_c, IV err_i, const char *errstr, const char *state, const char *method)\n{\n    dTHX;\n    char err_buf[28];\n    SV *err_sv, *errstr_sv, *state_sv, *method_sv;\n    if (!err_c) {\n        sprintf(err_buf, \"%ld\", (long)err_i);\n        err_c = &err_buf[0];\n    }\n    err_sv    = (strEQ(err_c,\"1\")) ? &PL_sv_yes : sv_2mortal(newSVpvn(err_c, strlen(err_c)));\n    errstr_sv = sv_2mortal(newSVpvn(errstr, strlen(errstr)));\n    state_sv  = (state  && *state)  ? sv_2mortal(newSVpvn(state,  strlen(state)))  : &PL_sv_undef;\n    method_sv = (method && *method) ? sv_2mortal(newSVpvn(method, strlen(method))) : &PL_sv_undef;\n    return set_err_sv(h, imp_xxh, err_sv, errstr_sv, state_sv, method_sv);\n}\n\n\nstatic int\nset_err_sv(SV *h, imp_xxh_t *imp_xxh, SV *err, SV *errstr, SV *state, SV *method)\n{\n    dTHX;\n    SV *h_err;\n    SV *h_errstr;\n    SV *h_state;\n    SV **hook_svp;\n    int err_changed = 0;\n\n    if (    DBIc_has(imp_xxh, DBIcf_HandleSetErr)\n        && (hook_svp = hv_fetch((HV*)SvRV(h),\"HandleSetErr\",12,0))\n        &&  hook_svp\n        &&  ((void)(SvGMAGICAL(*hook_svp) && mg_get(*hook_svp)), SvOK(*hook_svp))\n    ) {\n        dSP;\n        IV items;\n        SV *response_sv;\n        if (SvREADONLY(err))    err    = sv_mortalcopy(err);\n        if (SvREADONLY(errstr)) errstr = sv_mortalcopy(errstr);\n        if (SvREADONLY(state))  state  = sv_mortalcopy(state);\n        if (SvREADONLY(method)) method = sv_mortalcopy(method);\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"    -> HandleSetErr(%s, err=%s, errstr=%s, state=%s, %s)\\n\",\n                neatsvpv(h,0), neatsvpv(err,0), neatsvpv(errstr,0), neatsvpv(state,0),\n                neatsvpv(method,0)\n            );\n        PUSHMARK(SP);\n        XPUSHs(sv_2mortal(newRV_inc((SV*)DBIc_MY_H(imp_xxh))));\n        XPUSHs(err);\n        XPUSHs(errstr);\n        XPUSHs(state);\n        XPUSHs(method);\n        PUTBACK;\n        items = call_sv(*hook_svp, G_SCALAR);\n        SPAGAIN;\n        response_sv = (items) ? POPs : &PL_sv_undef;\n        PUTBACK;\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 1)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"    <- HandleSetErr= %s (err=%s, errstr=%s, state=%s, %s)\\n\",\n                neatsvpv(response_sv,0), neatsvpv(err,0), neatsvpv(errstr,0), neatsvpv(state,0),\n                neatsvpv(method,0)\n            );\n        if (SvTRUE(response_sv))        /* handler says it has handled it, so... */\n            return 0;\n    }\n    else {\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"    -- HandleSetErr err=%s, errstr=%s, state=%s, %s\\n\",\n                neatsvpv(err,0), neatsvpv(errstr,0), neatsvpv(state,0), neatsvpv(method,0)\n            );\n    }\n\n    if (!SvOK(err)) {   /* clear err / errstr / state */\n        DBIh_CLEAR_ERROR(imp_xxh);\n        return 1;\n    }\n\n    /* fetch these after calling HandleSetErr */\n    h_err    = DBIc_ERR(imp_xxh);\n    h_errstr = DBIc_ERRSTR(imp_xxh);\n    h_state  = DBIc_STATE(imp_xxh);\n\n    if (SvTRUE(h_errstr)) {\n        /* append current err, if any, to errstr if it's going to change */\n        if (SvTRUE(h_err) && SvTRUE(err) && strNE(SvPV_nolen(h_err), SvPV_nolen(err)))\n            sv_catpvf(h_errstr, \" [err was %s now %s]\", SvPV_nolen(h_err), SvPV_nolen(err));\n        if (SvTRUE(h_state) && SvTRUE(state) && strNE(SvPV_nolen(h_state), SvPV_nolen(state)))\n            sv_catpvf(h_errstr, \" [state was %s now %s]\", SvPV_nolen(h_state), SvPV_nolen(state));\n        if (strNE(SvPV_nolen(h_errstr), SvPV_nolen(errstr))) {\n            sv_catpvn(h_errstr, \"\\n\", 1);\n            sv_catsv(h_errstr, errstr);\n        }\n    }\n    else\n        sv_setsv(h_errstr, errstr);\n\n    /* SvTRUE(err) > \"0\" > \"\" > undef */\n    if (SvTRUE(err)             /* new error: so assign                 */\n        || !SvOK(h_err) /* no existing warn/info: so assign     */\n           /* new warn (\"0\" len 1) > info (\"\" len 0): so assign         */\n        || (SvOK(err) && strlen(SvPV_nolen(err)) > strlen(SvPV_nolen(h_err)))\n    ) {\n        sv_setsv(h_err, err);\n        err_changed = 1;\n        if (SvTRUE(h_err))      /* new error */\n            ++DBIc_ErrCount(imp_xxh);\n    }\n\n    if (err_changed) {\n        if (SvTRUE(state)) {\n            if (strlen(SvPV_nolen(state)) != 5) {\n                warn(\"set_err: state (%s) is not a 5 character string, using 'S1000' instead\", neatsvpv(state,0));\n                sv_setpv(h_state, \"S1000\");\n            }\n            else\n                sv_setsv(h_state, state);\n        }\n        else\n            (void)SvOK_off(h_state);    /* see DBIc_STATE_adjust */\n\n        /* ensure that the parent's Statement attribute reflects the latest error */\n        /* so that ShowErrorStatement is reliable */\n        copy_statement_to_parent(aTHX_ h, imp_xxh);\n    }\n\n    return 1;\n}\n\n\n/* err_hash returns a U32 'hash' value representing the current err 'level'\n * (err/warn/info) and errstr. It's used by the dispatcher as a way to detect\n * a new or changed warning during a 'keep err' method like STORE. Always returns >0.\n * The value is 1 for no err/warn/info and guarantees that err > warn > info.\n * (It's a bit of a hack but the original approach in 70fe6bd76 using a new\n * ErrChangeCount attribute would break binary compatibility with drivers.)\n * The chance that two realistic errstr values would hash the same, even with\n * only 30 bits, is deemed to small to even bother documenting.\n */\nstatic U32\nerr_hash(pTHX_ imp_xxh_t *imp_xxh)\n{\n    SV *err_sv = DBIc_ERR(imp_xxh);\n    SV *errstr_sv;\n    I32 hash = 1;\n    if (SvOK(err_sv)) {\n        errstr_sv = DBIc_ERRSTR(imp_xxh);\n        if (SvOK(errstr_sv))\n             hash = -dbi_hash(SvPV_nolen(errstr_sv), 0); /* make positive */\n        else hash = 0;\n        hash >>= 1; /* free up extra bit (top bit is already free) */\n        hash |= (SvTRUE(err_sv))                  ? 0x80000000 /* err */\n              : (SvPOK(err_sv) && !SvCUR(err_sv)) ? 0x20000000 /* '' = info */\n                                                  : 0x40000000;/* 0 or '0' = warn */\n    }\n    return hash;\n}\n\n\nstatic char *\nmkvname(pTHX_ HV *stash, const char *item, int uplevel) /* construct a variable name    */\n{\n    SV *sv = sv_newmortal();\n    sv_setpv(sv, HvNAME(stash));\n    if(uplevel) {\n        while(SvCUR(sv) && *SvEND(sv)!=':')\n            --SvCUR(sv);\n        if (SvCUR(sv))\n            --SvCUR(sv);\n    }\n    sv_catpv(sv, \"::\");\n    sv_catpv(sv, item);\n    return SvPV_nolen(sv);\n}\n\n/* 32 bit magic FNV-0 and FNV-1 prime */\n#define FNV_32_PRIME ((UV)0x01000193)\n\nstatic I32\ndbi_hash(const char *key, long type)\n{\n    if (type == 0) {\n        STRLEN klen = strlen(key);\n        U32 hash = 0;\n        while (klen--)\n            hash = hash * 33 + *key++;\n        hash &= 0x7FFFFFFF;     /* limit to 31 bits             */\n        hash |= 0x40000000;     /* set bit 31                   */\n        return -(I32)hash;      /* return negative int  */\n    }\n    else if (type == 1) {       /* Fowler/Noll/Vo hash  */\n        /* see http://www.isthe.com/chongo/tech/comp/fnv/ */\n        U32 hash = 0x811c9dc5;\n        const unsigned char *s = (unsigned char *)key;    /* unsigned string */\n        while (*s) {\n            /* multiply by the 32 bit FNV magic prime mod 2^32 */\n            hash *= FNV_32_PRIME;\n            /* xor the bottom with the current octet */\n            hash ^= (U32)*s++;\n        }\n        return hash;\n    }\n    croak(\"DBI::hash(%ld): invalid type\", type);\n    return 0; /* NOT REACHED */\n}\n\n\nstatic int\ndbih_logmsg(imp_xxh_t *imp_xxh, const char *fmt, ...)\n{\n    dTHX;\n    va_list args;\n#ifdef I_STDARG\n    va_start(args, fmt);\n#else\n    va_start(args);\n#endif\n    (void) PerlIO_vprintf(DBIc_DBISTATE(imp_xxh)->logfp, fmt, args);\n    va_end(args);\n    (void)imp_xxh;\n    return 1;\n}\n\nstatic void\nclose_trace_file(pTHX)\n{\n    dMY_CXT;\n    if (DBILOGFP == PerlIO_stderr() || DBILOGFP == PerlIO_stdout())\n        return;\n\n    if (DBIS->logfp_ref == NULL)\n        PerlIO_close(DBILOGFP);\n    else {\n    /* DAA dec refcount and discard */\n        SvREFCNT_dec(DBIS->logfp_ref);\n        DBIS->logfp_ref = NULL;\n    }\n}\n\nstatic int\nset_trace_file(SV *file)\n{\n    dTHX;\n    dMY_CXT;\n    const char *filename;\n    PerlIO *fp = Nullfp;\n    IO *io;\n\n    if (!file)          /* no arg == no change */\n        return 0;\n\n    /* DAA check for a filehandle */\n    if (SvROK(file)) {\n        io = sv_2io(file);\n        if (!io || !(fp = IoOFP(io))) {\n            warn(\"DBI trace filehandle is not valid\");\n            return 0;\n        }\n        close_trace_file(aTHX);\n        (void)SvREFCNT_inc(io);\n        DBIS->logfp_ref = io;\n    }\n    else if (isGV_with_GP(file)) {\n        io = GvIO(file);\n        if (!io || !(fp = IoOFP(io))) {\n            warn(\"DBI trace filehandle from GLOB is not valid\");\n            return 0;\n        }\n        close_trace_file(aTHX);\n        (void)SvREFCNT_inc(io);\n        DBIS->logfp_ref = io;\n    }\n    else {\n        filename = (SvOK(file)) ? SvPV_nolen(file) : Nullch;\n        /* undef arg == reset back to stderr */\n        if (!filename || strEQ(filename,\"STDERR\")\n                      || strEQ(filename,\"*main::STDERR\")) {\n            close_trace_file(aTHX);\n            DBILOGFP = PerlIO_stderr();\n            return 1;\n        }\n        if (strEQ(filename,\"STDOUT\")) {\n            close_trace_file(aTHX);\n            DBILOGFP = PerlIO_stdout();\n            return 1;\n        }\n        fp = PerlIO_open(filename, \"a+\");\n        if (fp == Nullfp) {\n            warn(\"Can't open trace file %s: %s\", filename, Strerror(errno));\n            return 0;\n        }\n        close_trace_file(aTHX);\n    }\n    DBILOGFP = fp;\n    /* if this line causes your compiler or linker to choke     */\n    /* then just comment it out, it's not essential.    */\n    PerlIO_setlinebuf(fp);      /* force line buffered output */\n    return 1;\n}\n\nstatic IV\nparse_trace_flags(SV *h, SV *level_sv, IV old_level)\n{\n    dTHX;\n    IV level;\n    if (!level_sv || !SvOK(level_sv))\n        level = old_level;              /* undef: no change     */\n    else\n    if (SvTRUE(level_sv)) {\n        if (looks_like_number(level_sv))\n            level = SvIV(level_sv);     /* number: number       */\n        else {                          /* string: parse it     */\n            dSP;\n            PUSHMARK(sp);\n            XPUSHs(h);\n            XPUSHs(level_sv);\n            PUTBACK;\n            if (call_method(\"parse_trace_flags\", G_SCALAR) != 1)\n                croak(\"panic: parse_trace_flags\");/* should never happen */\n            SPAGAIN;\n            level = POPi;\n            PUTBACK;\n        }\n    }\n    else                                /* defined but false: 0 */\n        level = 0;\n    return level;\n}\n\n\nstatic int\nset_trace(SV *h, SV *level_sv, SV *file)\n{\n    dTHX;\n    D_imp_xxh(h);\n    int RETVAL = DBIc_DBISTATE(imp_xxh)->debug; /* Return trace level in effect now */\n    IV level = parse_trace_flags(h, level_sv, RETVAL);\n    set_trace_file(file);\n    if (level != RETVAL) { /* set value */\n        if ((level & DBIc_TRACE_LEVEL_MASK) > 0) {\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                \"    %s trace level set to 0x%lx/%ld (DBI @ 0x%lx/%ld) in DBI %s%s (pid %d)\\n\",\n                neatsvpv(h,0),\n                (long)(level & DBIc_TRACE_FLAGS_MASK),\n                (long)(level & DBIc_TRACE_LEVEL_MASK),\n                (long)DBIc_TRACE_FLAGS(imp_xxh), (long)DBIc_TRACE_LEVEL(imp_xxh),\n                XS_VERSION, dbi_build_opt, (int)PerlProc_getpid());\n            if (!PL_dowarn)\n                PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"    Note: perl is running without the recommended perl -w option\\n\");\n            PerlIO_flush(DBIc_LOGPIO(imp_xxh));\n        }\n        sv_setiv(DBIc_DEBUG(imp_xxh), level);\n    }\n    return RETVAL;\n}\n\n\nstatic SV *\ndbih_inner(pTHX_ SV *orv, const char *what)\n{   /* convert outer to inner handle else croak(what) if what is not NULL */\n    /* if what is NULL then return NULL for invalid handles */\n    MAGIC *mg;\n    SV *ohv;            /* outer HV after derefing the RV       */\n    SV *hrv;            /* dbi inner handle RV-to-HV            */\n\n    /* enable a raw HV (not ref-to-HV) to be passed in, eg DBIc_MY_H */\n    ohv = SvROK(orv) ? SvRV(orv) : orv;\n\n    if (!ohv || SvTYPE(ohv) != SVt_PVHV) {\n        if (!what)\n            return NULL;\n        if (1) {\n            dMY_CXT;\n            if (DBIS_TRACE_LEVEL)\n                sv_dump(orv);\n        }\n        if (!SvOK(orv))\n            croak(\"%s given an undefined handle %s\",\n                what, \"(perhaps returned from a previous call which failed)\");\n        croak(\"%s handle %s is not a DBI handle\", what, neatsvpv(orv,0));\n    }\n    if (!SvMAGICAL(ohv)) {\n        if (!what)\n            return NULL;\n        sv_dump(orv);\n        croak(\"%s handle %s is not a DBI handle (has no magic)\",\n                what, neatsvpv(orv,0));\n    }\n\n    if ( (mg=mg_find(ohv,'P')) == NULL) {       /* hash tie magic       */\n        /* not tied, maybe it's already an inner handle... */\n        if (mg_find(ohv, DBI_MAGIC) == NULL) {\n            if (!what)\n                return NULL;\n            sv_dump(orv);\n            croak(\"%s handle %s is not a valid DBI handle\",\n                what, neatsvpv(orv,0));\n        }\n        hrv = orv; /* was already a DBI handle inner hash */\n    }\n    else {\n        hrv = mg->mg_obj;  /* inner hash of tie */\n    }\n\n    return hrv;\n}\n\n\n\n/* -------------------------------------------------------------------- */\n/* Functions to manage a DBI handle (magic and attributes etc).         */\n\nstatic imp_xxh_t *\ndbih_getcom(SV *hrv) /* used by drivers via DBIS func ptr */\n{\n    MAGIC *mg;\n    SV *sv;\n\n    /* short-cut common case */\n    if (   SvROK(hrv)\n        && (sv = SvRV(hrv))\n        && SvRMAGICAL(sv)\n        && (mg = SvMAGIC(sv))\n        && mg->mg_type == DBI_MAGIC\n        && mg->mg_ptr\n    )\n        return (imp_xxh_t *) mg->mg_ptr;\n\n    {\n        dTHX;\n        imp_xxh_t *imp_xxh = dbih_getcom2(aTHX_ hrv, 0);\n        if (!imp_xxh)       /* eg after take_imp_data */\n            croak(\"Invalid DBI handle %s, has no dbi_imp_data\", neatsvpv(hrv,0));\n        return imp_xxh;\n    }\n}\n\nstatic imp_xxh_t *\ndbih_getcom2(pTHX_ SV *hrv, MAGIC **mgp) /* Get com struct for handle. Must be fast.    */\n{\n    MAGIC *mg;\n    SV *sv;\n\n    /* important and quick sanity check (esp non-'safe' Oraperl)        */\n    if (SvROK(hrv))                     /* must at least be a ref */\n        sv = SvRV(hrv);\n    else {\n        dMY_CXT;\n        if (hrv == DBI_LAST_HANDLE)    /* special for var::FETCH */\n            sv = DBI_LAST_HANDLE;\n        else if (sv_derived_from(hrv, \"DBI::common\")) {\n            /* probably a class name, if ref($h)->foo() */\n            return 0;\n        }\n        else {\n            sv_dump(hrv);\n            croak(\"Invalid DBI handle %s\", neatsvpv(hrv,0));\n            sv = &PL_sv_undef; /* avoid \"might be used uninitialized\" warning       */\n        }\n    }\n\n    /* Short cut for common case. We assume that a magic var always     */\n    /* has magic and that DBI_MAGIC, if present, will be the first.     */\n    if (SvRMAGICAL(sv) && (mg=SvMAGIC(sv))->mg_type == DBI_MAGIC) {\n        /* nothing to do here */\n    }\n    else {\n        /* Validate handle (convert outer to inner if required) */\n        hrv = dbih_inner(aTHX_ hrv, \"dbih_getcom\");\n        mg  = mg_find(SvRV(hrv), DBI_MAGIC);\n    }\n    if (mgp)    /* let caller pickup magic struct for this handle */\n        *mgp = mg;\n\n    if (!mg)    /* may happen during global destruction */\n        return (imp_xxh_t *) 0;\n\n    return (imp_xxh_t *) mg->mg_ptr;\n}\n\n\nstatic SV *\ndbih_setup_attrib(pTHX_ SV *h, imp_xxh_t *imp_xxh, char *attrib, SV *parent, int read_only, int optional)\n{\n    STRLEN len = strlen(attrib);\n    SV **asvp;\n\n    asvp = hv_fetch((HV*)SvRV(h), attrib, len, !optional);\n    /* we assume that we won't have any existing 'undef' attributes here */\n    /* (or, alternately, we take undef to mean 'copy from parent')       */\n    if (!(asvp && SvOK(*asvp))) { /* attribute doesn't already exists (the common case) */\n        SV **psvp;\n        if ((!parent || !SvROK(parent)) && !optional) {\n            croak(\"dbih_setup_attrib(%s): %s not set and no parent supplied\",\n                    neatsvpv(h,0), attrib);\n        }\n        psvp = hv_fetch((HV*)SvRV(parent), attrib, len, 0);\n        if (psvp) {\n            if (!asvp)\n                asvp = hv_fetch((HV*)SvRV(h), attrib, len, 1);\n            sv_setsv(*asvp, *psvp); /* copy attribute from parent to handle */\n        }\n        else {\n            if (!optional)\n                croak(\"dbih_setup_attrib(%s): %s not set and not in parent\",\n                    neatsvpv(h,0), attrib);\n        }\n    }\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 5) {\n        PerlIO *logfp = DBIc_LOGPIO(imp_xxh);\n        PerlIO_printf(logfp,\"    dbih_setup_attrib(%s, %s, %s)\",\n            neatsvpv(h,0), attrib, neatsvpv(parent,0));\n        if (!asvp)\n             PerlIO_printf(logfp,\" undef (not defined)\\n\");\n        else\n        if (SvOK(*asvp))\n             PerlIO_printf(logfp,\" %s (already defined)\\n\", neatsvpv(*asvp,0));\n        else PerlIO_printf(logfp,\" %s (copied from parent)\\n\", neatsvpv(*asvp,0));\n    }\n    if (read_only && asvp)\n        SvREADONLY_on(*asvp);\n    return asvp ? *asvp : &PL_sv_undef;\n}\n\n\nstatic SV *\ndbih_make_fdsv(SV *sth, const char *imp_class, STRLEN imp_size, const char *col_name)\n{\n    dTHX;\n    D_imp_sth(sth);\n    const STRLEN cn_len = strlen(col_name);\n    imp_fdh_t *imp_fdh;\n    SV *fdsv;\n    if (imp_size < sizeof(imp_fdh_t) || cn_len<10 || strNE(\"::fd\",&col_name[cn_len-4]))\n        croak(\"panic: dbih_makefdsv %s '%s' imp_size %ld invalid\",\n                imp_class, col_name, (long)imp_size);\n    if (DBIc_TRACE_LEVEL(imp_sth) >= 5)\n        PerlIO_printf(DBIc_LOGPIO(imp_sth),\"    dbih_make_fdsv(%s, %s, %ld, '%s')\\n\",\n                neatsvpv(sth,0), imp_class, (long)imp_size, col_name);\n    fdsv = dbih_make_com(sth, (imp_xxh_t*)imp_sth, imp_class, imp_size, cn_len+2, 0);\n    imp_fdh = (imp_fdh_t*)(void*)SvPVX(fdsv);\n    imp_fdh->com.col_name = ((char*)imp_fdh) + imp_size;\n    strcpy(imp_fdh->com.col_name, col_name);\n    return fdsv;\n}\n\n\nstatic SV *\ndbih_make_com(SV *p_h, imp_xxh_t *p_imp_xxh, const char *imp_class, STRLEN imp_size, STRLEN extra, SV* imp_templ)\n{\n    dTHX;\n    static const char *errmsg = \"Can't make DBI com handle for %s: %s\";\n    HV *imp_stash;\n    SV *dbih_imp_sv;\n    imp_xxh_t *imp;\n    int trace_level;\n    PERL_UNUSED_VAR(extra);\n\n    if ( (imp_stash = gv_stashpv(imp_class, FALSE)) == NULL)\n        croak(errmsg, imp_class, \"unknown package\");\n\n    if (imp_size == 0) {\n        /* get size of structure to allocate for common and imp specific data   */\n        const char *imp_size_name = mkvname(aTHX_ imp_stash, \"imp_data_size\", 0);\n        imp_size = SvIV(get_sv(imp_size_name, 0x05));\n        if (imp_size == 0) {\n            imp_size = sizeof(imp_sth_t);\n            if (sizeof(imp_dbh_t) > imp_size)\n                imp_size = sizeof(imp_dbh_t);\n            if (sizeof(imp_drh_t) > imp_size)\n                imp_size = sizeof(imp_drh_t);\n            imp_size += 4;\n        }\n    }\n\n    if (p_imp_xxh) {\n        trace_level = DBIc_TRACE_LEVEL(p_imp_xxh);\n    }\n    else {\n        dMY_CXT;\n        trace_level = DBIS_TRACE_LEVEL;\n    }\n    if (trace_level >= 5) {\n        dMY_CXT;\n        PerlIO_printf(DBILOGFP,\"    dbih_make_com(%s, %p, %s, %ld, %p) thr#%p\\n\",\n            neatsvpv(p_h,0), (void*)p_imp_xxh, imp_class, (long)imp_size, (void*)imp_templ, (void*)PERL_GET_THX);\n    }\n\n    if (imp_templ && SvOK(imp_templ)) {\n        U32  imp_templ_flags;\n        /* validate the supplied dbi_imp_data looks reasonable, */\n        if (SvCUR(imp_templ) != imp_size)\n            croak(\"Can't use dbi_imp_data of wrong size (%ld not %ld)\",\n                (long)SvCUR(imp_templ), (long)imp_size);\n\n        /* copy the whole template */\n        dbih_imp_sv = newSVsv(imp_templ);\n        imp = (imp_xxh_t*)(void*)SvPVX(dbih_imp_sv);\n\n        /* sanity checks on the supplied imp_data */\n        if (DBIc_TYPE(imp) != ((p_imp_xxh) ? DBIc_TYPE(p_imp_xxh)+1 :1) )\n            croak(\"Can't use dbi_imp_data from different type of handle\");\n        if (!DBIc_has(imp, DBIcf_IMPSET))\n            croak(\"Can't use dbi_imp_data that not from a setup handle\");\n\n        /* copy flags, zero out our imp_xxh struct, restore some flags */\n        imp_templ_flags = DBIc_FLAGS(imp);\n        switch ( (p_imp_xxh) ? DBIc_TYPE(p_imp_xxh)+1 : DBIt_DR ) {\n        case DBIt_DR: memzero((char*)imp, sizeof(imp_drh_t)); break;\n        case DBIt_DB: memzero((char*)imp, sizeof(imp_dbh_t)); break;\n        case DBIt_ST: memzero((char*)imp, sizeof(imp_sth_t)); break;\n        default:      croak(\"dbih_make_com dbi_imp_data bad h type\");\n        }\n        /* Only pass on DBIcf_IMPSET to indicate to driver that the imp */\n        /* structure has been copied and it doesn't need to reconnect.  */\n        /* Similarly DBIcf_ACTIVE is also passed along but isn't key.   */\n        DBIc_FLAGS(imp) = imp_templ_flags & (DBIcf_IMPSET|DBIcf_ACTIVE);\n    }\n    else {\n        dbih_imp_sv = newSV(imp_size); /* is grown to at least imp_size+1 */\n        imp = (imp_xxh_t*)(void*)SvPVX(dbih_imp_sv);\n        memzero((char*)imp, imp_size);\n        /* set up SV with SvCUR set ready for take_imp_data */\n        SvCUR_set(dbih_imp_sv, imp_size);\n        *SvEND(dbih_imp_sv) = '\\0';\n    }\n\n    if (p_imp_xxh) {\n        DBIc_DBISTATE(imp)  = DBIc_DBISTATE(p_imp_xxh);\n    }\n    else {\n        dMY_CXT;\n        DBIc_DBISTATE(imp)  = DBIS;\n    }\n    DBIc_IMP_STASH(imp) = imp_stash;\n\n    if (!p_h) {         /* only a driver (drh) has no parent    */\n        DBIc_PARENT_H(imp)    = &PL_sv_undef;\n        DBIc_PARENT_COM(imp)  = NULL;\n        DBIc_TYPE(imp)        = DBIt_DR;\n        DBIc_on(imp,DBIcf_WARN          /* set only here, children inherit      */\n                   |DBIcf_ACTIVE        /* drivers are 'Active' by default      */\n                   |DBIcf_AutoCommit    /* advisory, driver must manage this    */\n        );\n        DBIc_set(imp, DBIcf_PrintWarn, 1);\n    }\n    else {\n        DBIc_PARENT_H(imp)    = (SV*)SvREFCNT_inc(p_h); /* ensure it lives      */\n        DBIc_PARENT_COM(imp)  = p_imp_xxh;              /* shortcut for speed   */\n        DBIc_TYPE(imp)        = DBIc_TYPE(p_imp_xxh) + 1;\n        /* inherit some flags from parent and carry forward some from template  */\n        DBIc_FLAGS(imp)       = (DBIc_FLAGS(p_imp_xxh) & ~DBIcf_INHERITMASK)\n                              | (DBIc_FLAGS(imp) & (DBIcf_IMPSET|DBIcf_ACTIVE));\n        ++DBIc_KIDS(p_imp_xxh);\n    }\n#ifdef DBI_USE_THREADS\n    DBIc_THR_USER(imp) = PERL_GET_THX ;\n#endif\n\n    if (DBIc_TYPE(imp) == DBIt_ST) {\n        imp_sth_t *imp_sth = (imp_sth_t*)imp;\n        DBIc_ROW_COUNT(imp_sth) = -1;\n    }\n\n    DBIc_COMSET_on(imp);        /* common data now set up               */\n\n    /* The implementor should DBIc_IMPSET_on(imp) when setting up       */\n    /* any private data which will need clearing/freeing later.         */\n\n    return dbih_imp_sv;\n}\n\n\nstatic void\ndbih_setup_handle(pTHX_ SV *orv, char *imp_class, SV *parent, SV *imp_datasv)\n{\n    SV *h;\n    char *errmsg = \"Can't setup DBI handle of %s to %s: %s\";\n    SV *dbih_imp_sv;\n    SV *dbih_imp_rv;\n    SV *dbi_imp_data = Nullsv;\n    SV **svp;\n    char imp_mem_name[300];\n    HV  *imp_mem_stash;\n    imp_xxh_t *imp;\n    imp_xxh_t *parent_imp;\n    int trace_level;\n\n    h      = dbih_inner(aTHX_ orv, \"dbih_setup_handle\");\n    parent = dbih_inner(aTHX_ parent, NULL);    /* check parent valid (& inner) */\n    if (parent) {\n        parent_imp = DBIh_COM(parent);\n        trace_level = DBIc_TRACE_LEVEL(parent_imp);\n    }\n    else {\n        dMY_CXT;\n        parent_imp = NULL;\n        trace_level = DBIS_TRACE_LEVEL;\n    }\n\n    if (trace_level >= 5) {\n        dMY_CXT;\n        PerlIO_printf(DBILOGFP,\"    dbih_setup_handle(%s=>%s, %s, %lx, %s)\\n\",\n            neatsvpv(orv,0), neatsvpv(h,0), imp_class, (long)parent, neatsvpv(imp_datasv,0));\n    }\n\n    if (mg_find(SvRV(h), DBI_MAGIC) != NULL)\n        croak(errmsg, neatsvpv(orv,0), imp_class, \"already a DBI (or ~magic) handle\");\n\n    strcpy(imp_mem_name, imp_class);\n    strcat(imp_mem_name, \"_mem\");\n    if ( (imp_mem_stash = gv_stashpv(imp_mem_name, FALSE)) == NULL)\n        croak(errmsg, neatsvpv(orv,0), imp_mem_name, \"unknown _mem package\");\n\n    if ((svp = hv_fetch((HV*)SvRV(h), \"dbi_imp_data\", 12, 0))) {\n        dbi_imp_data = *svp;\n        if (SvGMAGICAL(dbi_imp_data))  /* call FETCH via magic */\n            mg_get(dbi_imp_data);\n    }\n\n    DBI_LOCK;\n\n    dbih_imp_sv = dbih_make_com(parent, parent_imp, imp_class, 0, 0, dbi_imp_data);\n    imp = (imp_xxh_t*)(void*)SvPVX(dbih_imp_sv);\n\n    dbih_imp_rv = newRV_inc(dbih_imp_sv);       /* just needed for sv_bless */\n    sv_bless(dbih_imp_rv, imp_mem_stash);\n    sv_free(dbih_imp_rv);\n\n    DBIc_MY_H(imp) = (HV*)SvRV(orv);    /* take _copy_ of pointer, not new ref  */\n    DBIc_IMP_DATA(imp) = (imp_datasv) ? newSVsv(imp_datasv) : &PL_sv_undef;\n    _imp2com(imp, std.pid) = (U32)PerlProc_getpid();\n\n    if (DBIc_TYPE(imp) <= DBIt_ST) {\n        SV **tmp_svp;\n        /* Copy some attributes from parent if not defined locally and  */\n        /* also take address of attributes for speed of direct access.  */\n        /* parent is null for drh, in which case h must hold the values */\n#define COPY_PARENT(name,ro,opt) SvREFCNT_inc(dbih_setup_attrib(aTHX_ h,imp,(name),parent,ro,opt))\n#define DBIc_ATTR(imp, f) _imp2com(imp, attr.f)\n        /* XXX we should validate that these are the right type (refs etc)      */\n        DBIc_ATTR(imp, Err)      = COPY_PARENT(\"Err\",1,0);      /* scalar ref   */\n        DBIc_ATTR(imp, State)    = COPY_PARENT(\"State\",1,0);    /* scalar ref   */\n        DBIc_ATTR(imp, Errstr)   = COPY_PARENT(\"Errstr\",1,0);   /* scalar ref   */\n        DBIc_ATTR(imp, TraceLevel)=COPY_PARENT(\"TraceLevel\",0,0);/* scalar (int)*/\n        DBIc_ATTR(imp, FetchHashKeyName) = COPY_PARENT(\"FetchHashKeyName\",0,0); /* scalar ref */\n\n        if (parent) {\n            dbih_setup_attrib(aTHX_ h,imp,\"HandleSetErr\",parent,0,1);\n            dbih_setup_attrib(aTHX_ h,imp,\"HandleError\",parent,0,1);\n            dbih_setup_attrib(aTHX_ h,imp,\"ReadOnly\",parent,0,1);\n            dbih_setup_attrib(aTHX_ h,imp,\"Profile\",parent,0,1);\n\n            /* setup Callbacks from parents' ChildCallbacks */\n            if (DBIc_has(parent_imp, DBIcf_Callbacks)\n            && (tmp_svp = hv_fetch((HV*)SvRV(parent), \"Callbacks\", 9, 0))\n            && SvROK(*tmp_svp) && SvTYPE(SvRV(*tmp_svp)) == SVt_PVHV\n            && (tmp_svp = hv_fetch((HV*)SvRV(*tmp_svp), \"ChildCallbacks\", 14, 0))\n            && SvROK(*tmp_svp) && SvTYPE(SvRV(*tmp_svp)) == SVt_PVHV\n            ) {\n                /* XXX mirrors behaviour of dbih_set_attr_k() of Callbacks */\n                (void)hv_store((HV*)SvRV(h), \"Callbacks\", 9, newRV_inc(SvRV(*tmp_svp)), 0);\n                DBIc_set(imp, DBIcf_Callbacks, 1);\n            }\n\n            DBIc_LongReadLen(imp) = DBIc_LongReadLen(parent_imp);\n#ifdef sv_rvweaken\n            if (1) {\n                AV *av;\n                /* add weakref to new (outer) handle into parents ChildHandles array */\n                tmp_svp = hv_fetch((HV*)SvRV(parent), \"ChildHandles\", 12, 1);\n                if (!SvROK(*tmp_svp)) {\n                    SV *ChildHandles_rvav = newRV_noinc((SV*)newAV());\n                    sv_setsv(*tmp_svp, ChildHandles_rvav);\n                    sv_free(ChildHandles_rvav);\n                }\n                av = (AV*)SvRV(*tmp_svp);\n                av_push(av, (SV*)sv_rvweaken(newRV_inc((SV*)SvRV(orv))));\n                if (av_len(av) % 120 == 0) {\n                    /* time to do some housekeeping to remove dead handles */\n                    I32 i = av_len(av); /* 0 = 1 element */\n                    while (i-- >= 0) {\n                        SV *sv = av_shift(av);\n                        if (SvOK(sv))\n                            av_push(av, sv);\n                        else\n                           sv_free(sv);         /* keep it leak-free by Doru Petrescu pdoru.dbi@from.ro */\n                    }\n                }\n            }\n#endif\n        }\n        else {\n            DBIc_LongReadLen(imp) = DBIc_LongReadLen_init;\n        }\n\n        switch (DBIc_TYPE(imp)) {\n        case DBIt_DB:\n            /* cache _inner_ handle, but also see quick_FETCH */\n            (void)hv_store((HV*)SvRV(h), \"Driver\", 6, newRV_inc(SvRV(parent)), 0);\n            (void)hv_fetch((HV*)SvRV(h), \"Statement\", 9, 1); /* store writable undef */\n            break;\n        case DBIt_ST:\n            DBIc_NUM_FIELDS((imp_sth_t*)imp) = -1;\n            /* cache _inner_ handle, but also see quick_FETCH */\n            (void)hv_store((HV*)SvRV(h), \"Database\", 8, newRV_inc(SvRV(parent)), 0);\n            /* copy (alias) Statement from the sth up into the dbh      */\n            tmp_svp = hv_fetch((HV*)SvRV(h), \"Statement\", 9, 1);\n            (void)hv_store((HV*)SvRV(parent), \"Statement\", 9, SvREFCNT_inc(*tmp_svp), 0);\n            break;\n        }\n    }\n    else \n        die(\"panic: invalid DBIc_TYPE\");\n\n    /* Use DBI magic on inner handle to carry handle attributes         */\n    /* Note that we store the imp_sv in mg_obj, but as a shortcut,      */\n    /* also store a direct pointer to imp, aka PVX(dbih_imp_sv),        */\n    /* in mg_ptr (with mg_len set to null, so it wont be freed)         */\n    sv_magic(SvRV(h), dbih_imp_sv, DBI_MAGIC, (char*)imp, 0);\n    SvREFCNT_dec(dbih_imp_sv);  /* since sv_magic() incremented it      */\n    SvRMAGICAL_on(SvRV(h));     /* so DBI magic gets sv_clear'd ok      */\n\n    {\n    dMY_CXT; /* XXX would be nice to get rid of this */\n    DBI_SET_LAST_HANDLE(h);\n    }\n\n    if (1) {\n        /* This is a hack to work-around the fast but poor way old versions of\n         * DBD::Oracle (and possibly other drivers) check for a valid handle\n         * using (SvMAGIC(SvRV(h)))->mg_type == 'P'). That doesn't work now\n         * because the weakref magic is inserted ahead of the tie magic.\n         * So here we swap the tie and weakref magic so the tie comes first.\n         */\n        MAGIC *tie_mg = mg_find(SvRV(orv),'P');\n        MAGIC *first  = SvMAGIC(SvRV(orv));\n        if (tie_mg && first->mg_moremagic == tie_mg && !tie_mg->mg_moremagic) {\n            MAGIC *next = tie_mg->mg_moremagic;\n            SvMAGIC(SvRV(orv)) = tie_mg;\n            tie_mg->mg_moremagic = first;\n            first->mg_moremagic = next;\n        }\n    }\n\n    DBI_UNLOCK;\n}\n\n\nstatic void\ndbih_dumphandle(pTHX_ SV *h, const char *msg, int level)\n{\n    D_imp_xxh(h);\n    if (level >= 9) {\n        sv_dump(h);\n    }\n    dbih_dumpcom(aTHX_ imp_xxh, msg, level);\n}\n\nstatic int\ndbih_dumpcom(pTHX_ imp_xxh_t *imp_xxh, const char *msg, int level)\n{\n    dMY_CXT;\n    SV *flags = sv_2mortal(newSVpv(\"\",0));\n    SV *inner;\n    static const char pad[] = \"      \";\n    if (!msg)\n        msg = \"dbih_dumpcom\";\n    PerlIO_printf(DBILOGFP,\"    %s (%sh 0x%lx, com 0x%lx, imp %s):\\n\",\n        msg, dbih_htype_name(DBIc_TYPE(imp_xxh)),\n        (long)DBIc_MY_H(imp_xxh), (long)imp_xxh,\n        (PL_dirty) ? \"global destruction\" : HvNAME(DBIc_IMP_STASH(imp_xxh)));\n    if (DBIc_COMSET(imp_xxh))                   sv_catpv(flags,\"COMSET \");\n    if (DBIc_IMPSET(imp_xxh))                   sv_catpv(flags,\"IMPSET \");\n    if (DBIc_ACTIVE(imp_xxh))                   sv_catpv(flags,\"Active \");\n    if (DBIc_WARN(imp_xxh))                     sv_catpv(flags,\"Warn \");\n    if (DBIc_COMPAT(imp_xxh))                   sv_catpv(flags,\"CompatMode \");\n    if (DBIc_is(imp_xxh, DBIcf_ChopBlanks))     sv_catpv(flags,\"ChopBlanks \");\n    if (DBIc_is(imp_xxh, DBIcf_HandleSetErr))   sv_catpv(flags,\"HandleSetErr \");\n    if (DBIc_is(imp_xxh, DBIcf_HandleError))    sv_catpv(flags,\"HandleError \");\n    if (DBIc_is(imp_xxh, DBIcf_RaiseError))     sv_catpv(flags,\"RaiseError \");\n    if (DBIc_is(imp_xxh, DBIcf_PrintError))     sv_catpv(flags,\"PrintError \");\n    if (DBIc_is(imp_xxh, DBIcf_RaiseWarn))      sv_catpv(flags,\"RaiseWarn \");\n    if (DBIc_is(imp_xxh, DBIcf_PrintWarn))      sv_catpv(flags,\"PrintWarn \");\n    if (DBIc_is(imp_xxh, DBIcf_ShowErrorStatement))     sv_catpv(flags,\"ShowErrorStatement \");\n    if (DBIc_is(imp_xxh, DBIcf_AutoCommit))     sv_catpv(flags,\"AutoCommit \");\n    if (DBIc_is(imp_xxh, DBIcf_BegunWork))      sv_catpv(flags,\"BegunWork \");\n    if (DBIc_is(imp_xxh, DBIcf_LongTruncOk))    sv_catpv(flags,\"LongTruncOk \");\n    if (DBIc_is(imp_xxh, DBIcf_MultiThread))    sv_catpv(flags,\"MultiThread \");\n    if (DBIc_is(imp_xxh, DBIcf_TaintIn))        sv_catpv(flags,\"TaintIn \");\n    if (DBIc_is(imp_xxh, DBIcf_TaintOut))       sv_catpv(flags,\"TaintOut \");\n    if (DBIc_is(imp_xxh, DBIcf_Profile))        sv_catpv(flags,\"Profile \");\n    if (DBIc_is(imp_xxh, DBIcf_Callbacks))      sv_catpv(flags,\"Callbacks \");\n    PerlIO_printf(DBILOGFP,\"%s FLAGS 0x%lx: %s\\n\", pad, (long)DBIc_FLAGS(imp_xxh), SvPV_nolen(flags));\n    if (SvOK(DBIc_ERR(imp_xxh)))\n        PerlIO_printf(DBILOGFP,\"%s ERR %s\\n\",   pad, neatsvpv((SV*)DBIc_ERR(imp_xxh),0));\n    if (SvOK(DBIc_ERR(imp_xxh)))\n        PerlIO_printf(DBILOGFP,\"%s ERRSTR %s\\n\",        pad, neatsvpv((SV*)DBIc_ERRSTR(imp_xxh),0));\n    PerlIO_printf(DBILOGFP,\"%s PARENT %s\\n\",    pad, neatsvpv((SV*)DBIc_PARENT_H(imp_xxh),0));\n    PerlIO_printf(DBILOGFP,\"%s KIDS %ld (%ld Active)\\n\", pad,\n                    (long)DBIc_KIDS(imp_xxh), (long)DBIc_ACTIVE_KIDS(imp_xxh));\n    if (DBIc_IMP_DATA(imp_xxh) && SvOK(DBIc_IMP_DATA(imp_xxh)))\n        PerlIO_printf(DBILOGFP,\"%s IMP_DATA %s\\n\", pad, neatsvpv(DBIc_IMP_DATA(imp_xxh),0));\n    if (DBIc_LongReadLen(imp_xxh) != DBIc_LongReadLen_init)\n        PerlIO_printf(DBILOGFP,\"%s LongReadLen %ld\\n\", pad, (long)DBIc_LongReadLen(imp_xxh));\n\n    if (DBIc_TYPE(imp_xxh) == DBIt_ST) {\n        const imp_sth_t *imp_sth = (imp_sth_t*)imp_xxh;\n        PerlIO_printf(DBILOGFP,\"%s NUM_OF_FIELDS %d\\n\", pad, DBIc_NUM_FIELDS(imp_sth));\n        PerlIO_printf(DBILOGFP,\"%s NUM_OF_PARAMS %d\\n\", pad, DBIc_NUM_PARAMS(imp_sth));\n    }\n    inner = dbih_inner(aTHX_ (SV*)DBIc_MY_H(imp_xxh), msg);\n    if (!inner || !SvROK(inner))\n        return 1;\n    if (DBIc_TYPE(imp_xxh) <= DBIt_DB) {\n        SV **svp = hv_fetch((HV*)SvRV(inner), \"CachedKids\", 10, 0);\n        if (svp && SvROK(*svp) && SvTYPE(SvRV(*svp)) == SVt_PVHV) {\n            HV *hv = (HV*)SvRV(*svp);\n            PerlIO_printf(DBILOGFP,\"%s CachedKids %d\\n\", pad, (int)HvKEYS(hv));\n        }\n    }\n    if (level > 0) {\n        SV* value;\n        char *key;\n        I32   keylen;\n        PerlIO_printf(DBILOGFP,\"%s cached attributes:\\n\", pad);\n        while ( (value = hv_iternextsv((HV*)SvRV(inner), &key, &keylen)) ) {\n            PerlIO_printf(DBILOGFP,\"%s   '%s' => %s\\n\", pad, key, neatsvpv(value,0));\n        }\n    }\n    else if (DBIc_TYPE(imp_xxh) == DBIt_DB) {\n        SV **svp = hv_fetch((HV*)SvRV(inner), \"Name\", 4, 0);\n        if (svp && SvOK(*svp))\n            PerlIO_printf(DBILOGFP,\"%s Name %s\\n\", pad, neatsvpv(*svp,0));\n    }\n    else if (DBIc_TYPE(imp_xxh) == DBIt_ST) {\n        SV **svp = hv_fetch((HV*)SvRV(inner), \"Statement\", 9, 0);\n        if (svp && SvOK(*svp))\n            PerlIO_printf(DBILOGFP,\"%s Statement %s\\n\", pad, neatsvpv(*svp,0));\n    }\n    return 1;\n}\n\n\nstatic void\ndbih_clearcom(imp_xxh_t *imp_xxh)\n{\n    dTHX;\n    dTHR;\n    int dump = FALSE;\n    int debug = DBIc_TRACE_LEVEL(imp_xxh);\n    int auto_dump = (debug >= 6);\n    imp_xxh_t * const parent_xxh = DBIc_PARENT_COM(imp_xxh);\n    /* Note that we're very much on our own here. DBIc_MY_H(imp_xxh) almost     */\n    /* certainly points to memory which has been freed. Don't use it!           */\n\n    /* --- pre-clearing sanity checks --- */\n\n#ifdef DBI_USE_THREADS\n    if (DBIc_THR_USER(imp_xxh) != my_perl) { /* don't clear handle that belongs to another thread */\n        if (debug >= 3) {\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"    skipped dbih_clearcom: DBI handle (type=%d, %s) is owned by thread %p not current thread %p\\n\",\n                  DBIc_TYPE(imp_xxh), HvNAME(DBIc_IMP_STASH(imp_xxh)), (void*)DBIc_THR_USER(imp_xxh), (void*)my_perl) ;\n            PerlIO_flush(DBIc_LOGPIO(imp_xxh));\n        }\n        return;\n    }\n#endif\n\n    if (!DBIc_COMSET(imp_xxh)) {        /* should never happen  */\n        dbih_dumpcom(aTHX_ imp_xxh, \"dbih_clearcom: DBI handle already cleared\", 0);\n        return;\n    }\n\n    if (auto_dump)\n        dbih_dumpcom(aTHX_ imp_xxh,\"DESTROY (dbih_clearcom)\", 0);\n\n    if (!PL_dirty) {\n\n        if (DBIc_ACTIVE(imp_xxh)) {     /* bad news, potentially        */\n            /* warn for sth, warn for dbh only if it has active sth or isn't AutoCommit */\n            if (DBIc_TYPE(imp_xxh) >= DBIt_ST\n            || (DBIc_ACTIVE_KIDS(imp_xxh) || !DBIc_has(imp_xxh, DBIcf_AutoCommit))\n            ) {\n                warn(\"DBI %s handle 0x%lx cleared whilst still active\",\n                        dbih_htype_name(DBIc_TYPE(imp_xxh)), (unsigned long)DBIc_MY_H(imp_xxh));\n                dump = TRUE;\n            }\n        }\n\n        /* check that the implementor has done its own housekeeping     */\n        if (DBIc_IMPSET(imp_xxh)) {\n            warn(\"DBI %s handle 0x%lx has uncleared implementors data\",\n                    dbih_htype_name(DBIc_TYPE(imp_xxh)), (unsigned long)DBIc_MY_H(imp_xxh));\n            dump = TRUE;\n        }\n\n        if (DBIc_KIDS(imp_xxh)) {\n            warn(\"DBI %s handle 0x%lx has %d uncleared child handles\",\n                    dbih_htype_name(DBIc_TYPE(imp_xxh)),\n                    (unsigned long)DBIc_MY_H(imp_xxh), (int)DBIc_KIDS(imp_xxh));\n            dump = TRUE;\n        }\n    }\n\n    if (dump && !auto_dump) /* else was already dumped above */\n        dbih_dumpcom(aTHX_ imp_xxh, \"dbih_clearcom\", 0);\n\n    /* --- pre-clearing adjustments --- */\n\n    if (!PL_dirty) {\n        if (parent_xxh) {\n            if (DBIc_ACTIVE(imp_xxh)) /* see also DBIc_ACTIVE_off */\n                --DBIc_ACTIVE_KIDS(parent_xxh);\n            --DBIc_KIDS(parent_xxh);\n        }\n    }\n\n    /* --- clear fields (may invoke object destructors) ---     */\n\n    if (DBIc_TYPE(imp_xxh) == DBIt_ST) {\n        imp_sth_t *imp_sth = (imp_sth_t*)imp_xxh;\n        sv_free((SV*)DBIc_FIELDS_AV(imp_sth));\n    }\n\n    sv_free(DBIc_IMP_DATA(imp_xxh));            /* do this first        */\n    if (DBIc_TYPE(imp_xxh) <= DBIt_ST) {        /* DBIt_FD doesn't have attr */\n        sv_free(_imp2com(imp_xxh, attr.TraceLevel));\n        sv_free(_imp2com(imp_xxh, attr.State));\n        sv_free(_imp2com(imp_xxh, attr.Err));\n        sv_free(_imp2com(imp_xxh, attr.Errstr));\n        sv_free(_imp2com(imp_xxh, attr.FetchHashKeyName));\n    }\n\n\n    sv_free((SV*)DBIc_PARENT_H(imp_xxh));       /* do this last         */\n\n    DBIc_COMSET_off(imp_xxh);\n\n    if (debug >= 4)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"    dbih_clearcom 0x%lx (com 0x%lx, type %d) done.\\n\\n\",\n                (long)DBIc_MY_H(imp_xxh), (long)imp_xxh, DBIc_TYPE(imp_xxh));\n}\n\n\n/* --- Functions for handling field buffer arrays ---           */\n\nstatic AV *\ndbih_setup_fbav(imp_sth_t *imp_sth)\n{\n    /*  Usually called to setup the row buffer for new sth.\n     *  Also called if the value of NUM_OF_FIELDS is altered,\n     *  in which case it adjusts the row buffer to match NUM_OF_FIELDS.\n     */\n    dTHX;\n    I32 i = DBIc_NUM_FIELDS(imp_sth);\n    AV *av = DBIc_FIELDS_AV(imp_sth);\n\n    if (i < 0)\n        i = 0;\n\n    if (av) {\n        if (av_len(av)+1 == i)  /* is existing array the right size? */\n            return av;\n        /* we need to adjust the size of the array */\n        if (DBIc_TRACE_LEVEL(imp_sth) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_sth),\"    dbih_setup_fbav realloc from %ld to %ld fields\\n\", (long)(av_len(av)+1), (long)i);\n        SvREADONLY_off(av);\n        if (i < av_len(av)+1) /* trim to size if too big */\n            av_fill(av, i-1);\n    }\n    else {\n        if (DBIc_TRACE_LEVEL(imp_sth) >= 5)\n            PerlIO_printf(DBIc_LOGPIO(imp_sth),\"    dbih_setup_fbav alloc for %ld fields\\n\", (long)i);\n        av = newAV();\n        DBIc_FIELDS_AV(imp_sth) = av;\n\n        /* row_count will need to be manually reset by the driver if the        */\n        /* sth is re-executed (since this code won't get rerun)         */\n        DBIc_ROW_COUNT(imp_sth) = 0;\n    }\n\n    /* load array with writeable SV's. Do this backwards so     */\n    /* the array only gets extended once.                       */\n    while(i--)                  /* field 1 stored at index 0    */\n        av_store(av, i, newSV(0));\n    if (DBIc_TRACE_LEVEL(imp_sth) >= 6)\n        PerlIO_printf(DBIc_LOGPIO(imp_sth),\"    dbih_setup_fbav now %ld fields\\n\", (long)(av_len(av)+1));\n    SvREADONLY_on(av);          /* protect against shift @$row etc */\n    return av;\n}\n\n\nstatic AV *\ndbih_get_fbav(imp_sth_t *imp_sth)\n{\n    AV *av;\n\n    if ( (av = DBIc_FIELDS_AV(imp_sth)) == Nullav) {\n        av = dbih_setup_fbav(imp_sth);\n    }\n    else {\n        dTHX;\n        int i = av_len(av) + 1;\n        if (i != DBIc_NUM_FIELDS(imp_sth)) {\n            /*SV *sth = dbih_inner(aTHX_ (SV*)DBIc_MY_H(imp_sth), \"_get_fbav\");*/\n            /* warn via PrintWarn */\n            set_err_char(SvRV(DBIc_MY_H(imp_sth)), (imp_xxh_t*)imp_sth,\n                    \"0\", 0, \"Number of row fields inconsistent with NUM_OF_FIELDS (driver bug)\", \"\", \"_get_fbav\");\n            /*\n            DBIc_NUM_FIELDS(imp_sth) = i;\n            hv_delete((HV*)SvRV(sth), \"NUM_OF_FIELDS\", 13, G_DISCARD);\n            */\n        }\n        /* don't let SvUTF8 flag persist from one row to the next   */\n        /* (only affects drivers that use sv_setpv, but most XS do) */\n        /* XXX turn into option later (force on/force off/ignore) */\n        while(i--)                  /* field 1 stored at index 0    */\n            SvUTF8_off(AvARRAY(av)[i]);\n    }\n\n    if (DBIc_is(imp_sth, DBIcf_TaintOut)) {\n        dTHX;\n        dTHR;\n        TAINT;  /* affects sv_setsv()'s called within same perl statement */\n    }\n\n    /* XXX fancy stuff to happen here later (re scrolling etc)  */\n    ++DBIc_ROW_COUNT(imp_sth);\n    return av;\n}\n\n\nstatic int\ndbih_sth_bind_col(SV *sth, SV *col, SV *ref, SV *attribs)\n{\n    dTHX;\n    D_imp_sth(sth);\n    AV *av;\n    int idx = SvIV(col);\n    int fields = DBIc_NUM_FIELDS(imp_sth);\n\n    if (fields <= 0) {\n        PERL_UNUSED_VAR(attribs);\n        croak(\"Statement has no result columns to bind%s\",\n            DBIc_ACTIVE(imp_sth)\n                ? \"\" : \" (perhaps you need to successfully call execute first, or again)\");\n    }\n\n    if ( (av = DBIc_FIELDS_AV(imp_sth)) == Nullav)\n        av = dbih_setup_fbav(imp_sth);\n\n    if (DBIc_TRACE_LEVEL(imp_sth) >= 5)\n        PerlIO_printf(DBIc_LOGPIO(imp_sth),\"    dbih_sth_bind_col %s => %s %s\\n\",\n                neatsvpv(col,0), neatsvpv(ref,0), neatsvpv(attribs,0));\n\n    if (idx < 1 || idx > fields)\n        croak(\"bind_col: column %d is not a valid column (1..%d)\",\n                        idx, fields);\n\n    if (!SvOK(ref) && SvREADONLY(ref)) {   /* binding to literal undef */\n        /* presumably the call is just setting the TYPE or other atribs */\n        /* but this default method ignores attribs, so we just return   */\n        return 1;\n    }\n\n    /* Write this as > SVt_PVMG because in 5.8.x the next type */\n    /* is SVt_PVBM, whereas in 5.9.x it's SVt_PVGV.            */\n    if (!SvROK(ref) || SvTYPE(SvRV(ref)) > SVt_PVMG) /* XXX LV */\n        croak(\"Can't %s->bind_col(%s, %s,...), need a reference to a scalar\",\n                neatsvpv(sth,0), neatsvpv(col,0), neatsvpv(ref,0));\n\n    /* use supplied scalar as storage for this column */\n    SvREADONLY_off(av);\n    av_store(av, idx-1, SvREFCNT_inc(SvRV(ref)) );\n    SvREADONLY_on(av);\n    return 1;\n}\n\n\nstatic int\nquote_type(int sql_type, int p, int s, int *t, void *v)\n{\n    /* Returns true if type should be bound as a number else    */\n    /* false implying that binding as a string should be okay.  */\n    /* The true value is either SQL_INTEGER or SQL_DOUBLE which */\n    /* can be used as a hint if desired.                        */\n    (void)p;\n    (void)s;\n    (void)t;\n    (void)v;\n    /* looks like it's never been used, and doesn't make much sense anyway */\n    warn(\"Use of DBI internal bind_as_num/quote_type function is deprecated\");\n    switch(sql_type) {\n    case SQL_INTEGER:\n    case SQL_SMALLINT:\n    case SQL_TINYINT:\n    case SQL_BIGINT:\n        return 0;\n    case SQL_FLOAT:\n    case SQL_REAL:\n    case SQL_DOUBLE:\n        return 0;\n    case SQL_NUMERIC:\n    case SQL_DECIMAL:\n        return 0;       /* bind as string to attempt to retain precision */\n    }\n    return 1;\n}\n\n\n/* Convert a simple string representation of a value into a more specific\n * perl type based on an sql_type value.\n * The semantics of SQL standard TYPE values are interpreted _very_ loosely\n * on the basis of \"be liberal in what you accept and let's throw in some\n * extra semantics while we're here\" :)\n * Returns:\n *  -2: sql_type isn't handled, value unchanged\n *  -1: sv is undef, value unchanged\n *   0: sv couldn't be cast cleanly and DBIstcf_STRICT was used\n *   1: sv couldn't be cast cleanly and DBIstcf_STRICT was not used\n *   2: sv was cast ok\n */\n\nint\nsql_type_cast_svpv(pTHX_ SV *sv, int sql_type, U32 flags, void *v)\n{\n    int cast_ok = 0;\n    int grok_flags;\n    UV uv;\n\n    /* do nothing for undef (NULL) or non-string values */\n    if (!sv || !SvOK(sv))\n        return -1;\n\n    switch(sql_type) {\n\n    default:\n        return -2;   /* not a recognised SQL TYPE, value unchanged */\n\n    case SQL_INTEGER:\n        /* sv_2iv is liberal, may return SvIV, SvUV, or SvNV */\n        sv_2iv(sv);\n        /* SvNOK will be set if value is out of range for IV/UV.\n         * SvIOK should be set but won't if sv is not numeric (in which\n         * case perl would have warn'd already if -w or warnings are in effect)\n         */\n        cast_ok = (SvIOK(sv) && !SvNOK(sv));\n        break;\n\n    case SQL_DOUBLE:\n        sv_2nv(sv);\n        /* SvNOK should be set but won't if sv is not numeric (in which\n         * case perl would have warn'd already if -w or warnings are in effect)\n         */\n        cast_ok = SvNOK(sv);\n        break;\n\n    /* caller would like IV else UV else NV */\n    /* else no error and sv is untouched */\n    case SQL_NUMERIC:\n        /* based on the code in perl's toke.c */\n        uv = 0;\n        grok_flags = grok_number(SvPVX(sv), SvCUR(sv), &uv);\n        cast_ok = 1;\n        if (grok_flags == IS_NUMBER_IN_UV) { /* +ve int */\n            if (uv <= IV_MAX)   /* prefer IV over UV */\n                 sv_2iv(sv);\n            else sv_2uv(sv);\n        }\n        else if (grok_flags == (IS_NUMBER_IN_UV | IS_NUMBER_NEG)\n            && uv <= IV_MAX\n        ) {\n            sv_2iv(sv);\n        }\n        else if (grok_flags) { /* is numeric */\n            sv_2nv(sv);\n        }\n        else\n            cast_ok = 0;\n        break;\n\n#if 0 /* XXX future possibilities */\n    case SQL_BIGINT:    /* use Math::BigInt if too large for IV/UV */\n#endif\n    }\n\n    if (cast_ok) {\n\n        if (flags & DBIstcf_DISCARD_STRING\n        && SvNIOK(sv)  /* we set a numeric value */\n        && SvPVX(sv)   /* we have a buffer to discard */\n        ) {\n            SvOOK_off(sv);\n            sv_force_normal(sv);\n            if (SvLEN(sv))\n                Safefree(SvPVX(sv));\n            SvPOK_off(sv);\n            SvPV_set(sv, NULL);\n            SvLEN_set(sv, 0);\n            SvCUR_set(sv, 0);\n        }\n    }\n\n    if (cast_ok)\n        return 2;\n    else if (flags & DBIstcf_STRICT)\n        return 0;\n    else return 1;\n}\n\n\n\n/* --- Generic Handle Attributes (for all handle types) ---     */\n\nstatic int\ndbih_set_attr_k(SV *h, SV *keysv, int dbikey, SV *valuesv)\n{\n    dTHX;\n    dTHR;\n    D_imp_xxh(h);\n    STRLEN keylen;\n    const char  *key = SvPV(keysv, keylen);\n    const int    htype = DBIc_TYPE(imp_xxh);\n    int    on = (SvTRUE(valuesv));\n    int    internal = 1; /* DBIh_IN_PERL_DBD(imp_xxh); -- for DBD's in perl */\n    int    cacheit = 0;\n    int    weakenit = 0; /* eg for CachedKids ref */\n    (void)dbikey;\n\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 3)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"    STORE %s %s => %s\\n\",\n                neatsvpv(h,0), neatsvpv(keysv,0), neatsvpv(valuesv,0));\n\n    if (internal && strEQ(key, \"Active\")) {\n        if (on) {\n            D_imp_sth(h);\n            DBIc_ACTIVE_on(imp_xxh);\n            /* for pure-perl drivers on second and subsequent   */\n            /* execute()'s, else row count keeps rising.        */\n            if (htype==DBIt_ST && DBIc_FIELDS_AV(imp_sth))\n                DBIc_ROW_COUNT(imp_sth) = 0;\n        }\n        else {\n            DBIc_ACTIVE_off(imp_xxh);\n        }\n    }\n    else if (strEQ(key, \"FetchHashKeyName\")) {\n        if (htype >= DBIt_ST)\n            croak(\"Can't set FetchHashKeyName for a statement handle, set in parent before prepare()\");\n        cacheit = 1;    /* just save it */\n    }\n    else if (strEQ(key, \"CompatMode\")) {\n        (on) ? DBIc_COMPAT_on(imp_xxh) : DBIc_COMPAT_off(imp_xxh);\n    }\n    else if (strEQ(key, \"Warn\")) {\n        (on) ? DBIc_WARN_on(imp_xxh) : DBIc_WARN_off(imp_xxh);\n    }\n    else if (strEQ(key, \"AutoInactiveDestroy\")) {\n        (on) ? DBIc_AIADESTROY_on(imp_xxh) : DBIc_AIADESTROY_off(imp_xxh);\n    }\n    else if (strEQ(key, \"InactiveDestroy\")) {\n        (on) ? DBIc_IADESTROY_on(imp_xxh) : DBIc_IADESTROY_off(imp_xxh);\n    }\n    else if (strEQ(key, \"RootClass\")) {\n        cacheit = 1;    /* just save it */\n    }\n    else if (strEQ(key, \"RowCacheSize\")) {\n        cacheit = 0;    /* ignore it */\n    }\n    else if (strEQ(key, \"Executed\")) {\n        DBIc_set(imp_xxh, DBIcf_Executed, on);\n    }\n    else if (strEQ(key, \"ChopBlanks\")) {\n        DBIc_set(imp_xxh, DBIcf_ChopBlanks, on);\n    }\n    else if (strEQ(key, \"ErrCount\")) {\n        DBIc_ErrCount(imp_xxh) = SvUV(valuesv);\n    }\n    else if (strEQ(key, \"LongReadLen\")) {\n        if (SvNV(valuesv) < 0 || SvNV(valuesv) > MAX_LongReadLen)\n            croak(\"Can't set LongReadLen < 0 or > %ld\",MAX_LongReadLen);\n        DBIc_LongReadLen(imp_xxh) = SvIV(valuesv);\n        cacheit = 1;    /* save it for clone */\n    }\n    else if (strEQ(key, \"LongTruncOk\")) {\n        DBIc_set(imp_xxh,DBIcf_LongTruncOk, on);\n    }\n    else if (strEQ(key, \"RaiseError\")) {\n        DBIc_set(imp_xxh,DBIcf_RaiseError, on);\n    }\n    else if (strEQ(key, \"PrintError\")) {\n        DBIc_set(imp_xxh,DBIcf_PrintError, on);\n    }\n    else if (strEQ(key, \"RaiseWarn\")) {\n        DBIc_set(imp_xxh,DBIcf_RaiseWarn, on);\n    }\n    else if (strEQ(key, \"PrintWarn\")) {\n        DBIc_set(imp_xxh,DBIcf_PrintWarn, on);\n    }\n    else if (strEQ(key, \"HandleError\")) {\n        if ( on && (!SvROK(valuesv) || (SvTYPE(SvRV(valuesv)) != SVt_PVCV)) ) {\n            croak(\"Can't set %s to '%s'\", \"HandleError\", neatsvpv(valuesv,0));\n        }\n        DBIc_set(imp_xxh,DBIcf_HandleError, on);\n        cacheit = 1; /* child copy setup by dbih_setup_handle() */\n    }\n    else if (strEQ(key, \"HandleSetErr\")) {\n        if ( on && (!SvROK(valuesv) || (SvTYPE(SvRV(valuesv)) != SVt_PVCV)) ) {\n            croak(\"Can't set %s to '%s'\",\"HandleSetErr\",neatsvpv(valuesv,0));\n        }\n        DBIc_set(imp_xxh,DBIcf_HandleSetErr, on);\n        cacheit = 1; /* child copy setup by dbih_setup_handle() */\n    }\n    else if (strEQ(key, \"ChildHandles\")) {\n        if ( on && (!SvROK(valuesv) || (SvTYPE(SvRV(valuesv)) != SVt_PVAV)) ) {\n            croak(\"Can't set %s to '%s'\", \"ChildHandles\", neatsvpv(valuesv,0));\n        }\n        cacheit = 1; /* just save it in the hash */\n    }\n    else if (strEQ(key, \"Profile\")) {\n        static const char profile_class[] = \"DBI::Profile\";\n        if (on && (!SvROK(valuesv) || (SvTYPE(SvRV(valuesv)) != SVt_PVHV)) ) {\n            /* not a hash ref so use DBI::Profile to work out what to do */\n            dTHR;\n            dSP;\n            I32 returns;\n            TAINT_NOT; /* the require is presumed innocent till proven guilty */\n            perl_require_pv(\"DBI/Profile.pm\");\n            if (SvTRUE(ERRSV)) {\n                warn(\"Can't load %s: %s\", profile_class, SvPV_nolen(ERRSV));\n                valuesv = &PL_sv_undef;\n            }\n            else {\n                PUSHMARK(SP);\n                XPUSHs(sv_2mortal(newSVpv(profile_class,0)));\n                XPUSHs(valuesv);\n                PUTBACK;\n                returns = call_method(\"_auto_new\", G_SCALAR);\n                if (returns != 1)\n                    croak(\"%s _auto_new\", profile_class);\n                SPAGAIN;\n                valuesv = POPs;\n                PUTBACK;\n            }\n            on = SvTRUE(valuesv); /* in case it returns undef */\n        }\n        if (on && !sv_isobject(valuesv)) {\n            /* not blessed already - so default to DBI::Profile */\n            HV *stash;\n            perl_require_pv(profile_class);\n            stash = gv_stashpv(profile_class, GV_ADDWARN);\n            sv_bless(valuesv, stash);\n        }\n        DBIc_set(imp_xxh,DBIcf_Profile, on);\n        cacheit = 1; /* child copy setup by dbih_setup_handle() */\n    }\n    else if (strEQ(key, \"ShowErrorStatement\")) {\n        DBIc_set(imp_xxh,DBIcf_ShowErrorStatement, on);\n    }\n    else if (strEQ(key, \"MultiThread\") && internal) {\n        /* here to allow pure-perl drivers to set MultiThread */\n        DBIc_set(imp_xxh,DBIcf_MultiThread, on);\n        if (on && DBIc_WARN(imp_xxh)) {\n            warn(\"MultiThread support not yet implemented in DBI\");\n        }\n    }\n    else if (strEQ(key, \"Taint\")) {\n        /* 'Taint' is a shortcut for both in and out mode */\n        DBIc_set(imp_xxh,DBIcf_TaintIn|DBIcf_TaintOut, on);\n    }\n    else if (strEQ(key, \"TaintIn\")) {\n        DBIc_set(imp_xxh,DBIcf_TaintIn, on);\n    }\n    else if (strEQ(key, \"TaintOut\")) {\n        DBIc_set(imp_xxh,DBIcf_TaintOut, on);\n    }\n    else if (htype<=DBIt_DB && keylen==10 && strEQ(key, \"CachedKids\")\n        /* only allow hash refs */\n        && SvROK(valuesv) && SvTYPE(SvRV(valuesv))==SVt_PVHV\n    ) {\n        cacheit = 1;\n        weakenit = 1;\n    }\n    else if (keylen==9 && strEQ(key, \"Callbacks\")) {\n        if ( on && (!SvROK(valuesv) || (SvTYPE(SvRV(valuesv)) != SVt_PVHV)) )\n            croak(\"Can't set Callbacks to '%s'\",neatsvpv(valuesv,0));\n        /* see also dbih_setup_handle for ChildCallbacks handling */\n        DBIc_set(imp_xxh, DBIcf_Callbacks, on);\n        cacheit = 1;\n    }\n    else if (htype<=DBIt_DB && keylen==10 && strEQ(key, \"AutoCommit\")) {\n        /* driver should have intercepted this and either handled it    */\n        /* or set valuesv to either the 'magic' on or off value.        */\n        if (SvIV(valuesv) != -900 && SvIV(valuesv) != -901)\n            croak(\"DBD driver has not implemented the AutoCommit attribute\");\n        DBIc_set(imp_xxh,DBIcf_AutoCommit, (SvIV(valuesv)==-901));\n    }\n    else if (htype==DBIt_DB && keylen==9 && strEQ(key, \"BegunWork\")) {\n        DBIc_set(imp_xxh,DBIcf_BegunWork, on);\n    }\n    else if (keylen==10  && strEQ(key, \"TraceLevel\")) {\n        set_trace(h, valuesv, Nullsv);\n    }\n    else if (keylen==9  && strEQ(key, \"TraceFile\")) { /* XXX undocumented and readonly */\n        set_trace_file(valuesv);\n    }\n    else if (htype==DBIt_ST && strEQ(key, \"NUM_OF_FIELDS\")) {\n        D_imp_sth(h);\n        int new_num_fields = (SvOK(valuesv)) ? SvIV(valuesv) : -1;\n        DBIc_NUM_FIELDS(imp_sth) = new_num_fields;\n        if (DBIc_FIELDS_AV(imp_sth)) { /* modify existing fbav */\n            dbih_setup_fbav(imp_sth);\n        }\n        cacheit = 1;\n    }\n    else if (htype==DBIt_ST && strEQ(key, \"NUM_OF_PARAMS\")) {\n        D_imp_sth(h);\n        DBIc_NUM_PARAMS(imp_sth) = SvIV(valuesv);\n        cacheit = 1;\n    }\n    /* these are here due to clone() needing to set attribs through a public api */\n    else if (htype<=DBIt_DB && (strEQ(key, \"Name\")\n                            || strEQ(key,\"ImplementorClass\")\n                            || strEQ(key,\"ReadOnly\")\n                            || strEQ(key,\"Statement\")\n                            || strEQ(key,\"Username\")\n        /* these are here for backwards histerical raisons */\n        || strEQ(key,\"USER\") || strEQ(key,\"CURRENT_USER\")\n    ) ) {\n        cacheit = 1;\n    }\n    /* deal with: NAME_(uc|lc), NAME_hash, NAME_(uc|lc)_hash */\n    else if ((keylen==7 || keylen==9 || keylen==12)\n        && strnEQ(key, \"NAME_\", 5)\n        && (    (keylen==9 && strEQ(key, \"NAME_hash\"))\n           ||   ((key[5]=='u' || key[5]=='l') && key[6] == 'c'\n                && (!key[7] || strnEQ(&key[7], \"_hash\", 5)))\n           )\n        ) {\n        cacheit = 1;\n    }\n    else {      /* XXX should really be an event ? */\n        if (isUPPER(*key)) {\n            char *msg = \"Can't set %s->{%s}: unrecognised attribute name or invalid value%s\";\n            char *hint = \"\";\n            if (strEQ(key, \"NUM_FIELDS\"))\n                hint = \", perhaps you meant NUM_OF_FIELDS\";\n            warn(msg, neatsvpv(h,0), key, hint);\n            return FALSE;       /* don't store it */\n        }\n        /* Allow private_* attributes to be stored in the cache.        */\n        /* This is designed to make life easier for people subclassing  */\n        /* the DBI classes and may be of use to simple perl DBD's.      */\n        if (strnNE(key,\"private_\",8) && strnNE(key,\"dbd_\",4) && strnNE(key,\"dbi_\",4)) {\n            if (DBIc_TRACE_LEVEL(imp_xxh)) { /* change to DBIc_WARN(imp_xxh) once we can validate prefix against registry */\n                PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"$h->{%s}=%s ignored for invalid driver-specific attribute\\n\",\n                        neatsvpv(keysv,0), neatsvpv(valuesv,0));\n            }\n            return FALSE;\n        }\n        cacheit = 1;\n    }\n    if (cacheit) {\n        SV *sv_for_cache = newSVsv(valuesv);\n        (void)hv_store((HV*)SvRV(h), key, keylen, sv_for_cache, 0);\n        if (weakenit) {\n#ifdef sv_rvweaken\n            sv_rvweaken(sv_for_cache);\n#endif\n        }\n    }\n    return TRUE;\n}\n\n\nstatic SV *\ndbih_get_attr_k(SV *h, SV *keysv, int dbikey)\n{\n    dTHX;\n    dTHR;\n    D_imp_xxh(h);\n    STRLEN keylen;\n    char  *key = SvPV(keysv, keylen);\n    int    htype = DBIc_TYPE(imp_xxh);\n    SV  *valuesv = Nullsv;\n    int    cacheit = FALSE;\n    char *p;\n    int i;\n    SV  *sv;\n    SV  **svp;\n    (void)dbikey;\n\n    /* DBI quick_FETCH will service some requests (e.g., cached values) */\n\n    if (htype == DBIt_ST) {\n        switch (*key) {\n\n          case 'D':\n            if (keylen==8 && strEQ(key, \"Database\")) {\n                D_imp_from_child(imp_dbh, imp_dbh_t, imp_xxh);\n                valuesv = newRV_inc((SV*)DBIc_MY_H(imp_dbh));\n                cacheit = FALSE;  /* else creates ref loop */\n            }\n            break;\n\n          case 'N':\n            if (keylen==8 && strEQ(key, \"NULLABLE\")) {\n                valuesv = &PL_sv_undef;\n                break;\n            }\n\n            if (keylen==4 && strEQ(key, \"NAME\")) {\n                valuesv = &PL_sv_undef;\n                break;\n            }\n\n            /* deal with: NAME_(uc|lc), NAME_hash, NAME_(uc|lc)_hash */\n            if ((keylen==7 || keylen==9 || keylen==12)\n                && strnEQ(key, \"NAME_\", 5)\n                && (    (keylen==9 && strEQ(key, \"NAME_hash\"))\n                      ||        ((key[5]=='u' || key[5]=='l') && key[6] == 'c'\n                               && (!key[7] || strnEQ(&key[7], \"_hash\", 5)))\n                    )\n                ) {\n                D_imp_sth(h);\n                valuesv = &PL_sv_undef;\n\n                /* fetch from tied outer handle to trigger FETCH magic */\n                svp = hv_fetch((HV*)DBIc_MY_H(imp_sth), \"NAME\",4, FALSE);\n                sv = (svp) ? *svp : &PL_sv_undef;\n                if (SvGMAGICAL(sv))     /* call FETCH via magic */\n                    mg_get(sv);\n\n                if (SvROK(sv)) {\n                    AV *name_av = (AV*)SvRV(sv);\n                    char *name;\n                    int upcase = (key[5] == 'u');\n                    AV *av = Nullav;\n                    HV *hv = Nullhv;\n                    int num_fields_mismatch = 0;\n\n                    if (strEQ(&key[strlen(key)-5], \"_hash\"))\n                        hv = newHV();\n                    else av = newAV();\n                    i = DBIc_NUM_FIELDS(imp_sth);\n\n                    /* catch invalid NUM_FIELDS */\n                    if (i != AvFILL(name_av)+1) {\n                        /* flag as mismatch, except for \"-1 and empty\" case */\n                        if ( ! (i == -1 && 0 == AvFILL(name_av)+1) )\n                            num_fields_mismatch = 1;\n                        i = AvFILL(name_av)+1; /* limit for safe iteration over array */\n                    }\n\n\t\t    if (DBIc_TRACE_LEVEL(imp_sth) >= 10 || (num_fields_mismatch && DBIc_WARN(imp_xxh))) {\n\t\t\tPerlIO_printf(DBIc_LOGPIO(imp_sth),\"       FETCH $h->{%s} from $h->{NAME} with $h->{NUM_OF_FIELDS} = %d\"\n\t\t\t                       \" and %ld entries in $h->{NAME}%s\\n\",\n\t\t\t\tneatsvpv(keysv,0), DBIc_NUM_FIELDS(imp_sth), AvFILL(name_av)+1,\n                                (num_fields_mismatch) ? \" (possible bug in driver)\" : \"\");\n                    }\n\n                    while (--i >= 0) {\n                        sv = newSVsv(AvARRAY(name_av)[i]);\n                        name = SvPV_nolen(sv);\n                        if (key[5] != 'h') {    /* \"NAME_hash\" */\n                            for (p = name; p && *p; ++p) {\n#ifdef toUPPER_LC\n                                *p = (upcase) ? toUPPER_LC(*p) : toLOWER_LC(*p);\n#else\n                                *p = (upcase) ? toUPPER(*p) : toLOWER(*p);\n#endif\n                            }\n                        }\n                        if (av)\n                            av_store(av, i, sv);\n                        else {\n                            (void)hv_store(hv, name, SvCUR(sv), newSViv(i), 0);\n                            sv_free(sv);\n                        }\n                    }\n                    valuesv = newRV_noinc( (av ? (SV*)av : (SV*)hv) );\n                    cacheit = TRUE;     /* can't change */\n                }\n            }\n            else if (keylen==13 && strEQ(key, \"NUM_OF_FIELDS\")) {\n                D_imp_sth(h);\n                IV num_fields = DBIc_NUM_FIELDS(imp_sth);\n                valuesv = (num_fields < 0) ? &PL_sv_undef : newSViv(num_fields);\n                if (num_fields > 0)\n                    cacheit = TRUE;     /* can't change once set (XXX except for multiple result sets) */\n            }\n            else if (keylen==13 && strEQ(key, \"NUM_OF_PARAMS\")) {\n                D_imp_sth(h);\n                valuesv = newSViv(DBIc_NUM_PARAMS(imp_sth));\n                cacheit = TRUE; /* can't change */\n            }\n            break;\n\n          case 'P':\n            if (strEQ(key, \"PRECISION\"))\n                valuesv = &PL_sv_undef;\n            else if (strEQ(key, \"ParamValues\"))\n                valuesv = &PL_sv_undef;\n            else if (strEQ(key, \"ParamTypes\"))\n                valuesv = &PL_sv_undef;\n            break;\n\n          case 'R':\n            if (strEQ(key, \"RowsInCache\"))\n                valuesv = &PL_sv_undef;\n            break;\n\n          case 'S':\n            if (strEQ(key, \"SCALE\"))\n                valuesv = &PL_sv_undef;\n            break;\n\n          case 'T':\n            if (strEQ(key, \"TYPE\"))\n                valuesv = &PL_sv_undef;\n            break;\n        }\n\n    }\n    else\n    if (htype == DBIt_DB) {\n        /* this is here but is, sadly, not called because\n         * not-preloading them into the handle attrib cache caused\n         * wierdness in t/proxy.t that I never got to the bottom\n         * of. One day maybe.  */\n        if (keylen==6 && strEQ(key, \"Driver\")) {\n            D_imp_from_child(imp_dbh, imp_dbh_t, imp_xxh);\n            valuesv = newRV_inc((SV*)DBIc_MY_H(imp_dbh));\n            cacheit = FALSE;  /* else creates ref loop */\n        }\n    }\n\n    if (valuesv == Nullsv && htype <= DBIt_DB) {\n        if (keylen==10 && strEQ(key, \"AutoCommit\")) {\n            valuesv = boolSV(DBIc_has(imp_xxh,DBIcf_AutoCommit));\n        }\n    }\n\n    if (valuesv == Nullsv) {\n        switch (*key) {\n          case 'A':\n            if (keylen==6 && strEQ(key, \"Active\")) {\n                valuesv = boolSV(DBIc_ACTIVE(imp_xxh));\n            }\n            else if (keylen==10 && strEQ(key, \"ActiveKids\")) {\n                valuesv = newSViv(DBIc_ACTIVE_KIDS(imp_xxh));\n            }\n            else if (strEQ(key, \"AutoInactiveDestroy\")) {\n                valuesv = boolSV(DBIc_AIADESTROY(imp_xxh));\n            }\n            break;\n\n          case 'B':\n            if (keylen==9 && strEQ(key, \"BegunWork\")) {\n                valuesv = boolSV(DBIc_has(imp_xxh,DBIcf_BegunWork));\n            }\n            break;\n\n          case 'C':\n            if (strEQ(key, \"ChildHandles\")) {\n                svp = hv_fetch((HV*)SvRV(h), key, keylen, FALSE);\n                /* if something has been stored then return it.\n                 * otherwise return a dummy empty array if weakrefs are\n                 * available, else an undef to indicate that they're not */\n                if (svp) {\n                    valuesv = newSVsv(*svp);\n                } else {\n#ifdef sv_rvweaken\n                    valuesv = newRV_noinc((SV*)newAV());\n#else\n                    valuesv = &PL_sv_undef;\n#endif\n                }\n            }\n            else if (strEQ(key, \"ChopBlanks\")) {\n                valuesv = boolSV(DBIc_has(imp_xxh,DBIcf_ChopBlanks));\n            }\n            else if (strEQ(key, \"CachedKids\")) {\n                valuesv = &PL_sv_undef;\n            }\n            else if (strEQ(key, \"CompatMode\")) {\n                valuesv = boolSV(DBIc_COMPAT(imp_xxh));\n            }\n            break;\n\n          case 'E':\n            if (strEQ(key, \"Executed\")) {\n                valuesv = boolSV(DBIc_is(imp_xxh, DBIcf_Executed));\n            }\n            else if (strEQ(key, \"ErrCount\")) {\n                valuesv = newSVuv(DBIc_ErrCount(imp_xxh));\n            }\n            break;\n\n          case 'I':\n            if (strEQ(key, \"InactiveDestroy\")) {\n                valuesv = boolSV(DBIc_IADESTROY(imp_xxh));\n            }\n            break;\n\n          case 'K':\n            if (keylen==4 && strEQ(key, \"Kids\")) {\n                valuesv = newSViv(DBIc_KIDS(imp_xxh));\n            }\n            break;\n\n          case 'L':\n            if (keylen==11 && strEQ(key, \"LongReadLen\")) {\n                valuesv = newSVnv((NV)DBIc_LongReadLen(imp_xxh));\n            }\n            else if (keylen==11 && strEQ(key, \"LongTruncOk\")) {\n                valuesv = boolSV(DBIc_has(imp_xxh,DBIcf_LongTruncOk));\n            }\n            break;\n\n          case 'M':\n            if (keylen==10 && strEQ(key, \"MultiThread\")) {\n                valuesv = boolSV(DBIc_has(imp_xxh,DBIcf_MultiThread));\n            }\n            break;\n\n          case 'P':\n            if (keylen==10 && strEQ(key, \"PrintError\")) {\n                valuesv = boolSV(DBIc_has(imp_xxh,DBIcf_PrintError));\n            }\n            else if (keylen==9 && strEQ(key, \"PrintWarn\")) {\n                valuesv = boolSV(DBIc_has(imp_xxh,DBIcf_PrintWarn));\n            }\n            break;\n\n          case 'R':\n            if (keylen==10 && strEQ(key, \"RaiseError\")) {\n                valuesv = boolSV(DBIc_has(imp_xxh,DBIcf_RaiseError));\n            }\n            else if (keylen==9 && strEQ(key, \"RaiseWarn\")) {\n                valuesv = boolSV(DBIc_has(imp_xxh,DBIcf_RaiseWarn));\n            }\n            else if (keylen==12 && strEQ(key, \"RowCacheSize\")) {\n                valuesv = &PL_sv_undef;\n            }\n            break;\n\n          case 'S':\n            if (keylen==18 && strEQ(key, \"ShowErrorStatement\")) {\n                valuesv = boolSV(DBIc_has(imp_xxh,DBIcf_ShowErrorStatement));\n            }\n            break;\n\n          case 'T':\n            if (keylen==4 && strEQ(key, \"Type\")) {\n                char *type = dbih_htype_name(htype);\n                valuesv = newSVpv(type,0);\n                cacheit = TRUE; /* can't change */\n            }\n            else if (keylen==10  && strEQ(key, \"TraceLevel\")) {\n                valuesv = newSViv( DBIc_DEBUGIV(imp_xxh) );\n            }\n            else if (keylen==5  && strEQ(key, \"Taint\")) {\n                valuesv = boolSV(DBIc_has(imp_xxh,DBIcf_TaintIn) &&\n                                 DBIc_has(imp_xxh,DBIcf_TaintOut));\n            }\n            else if (keylen==7  && strEQ(key, \"TaintIn\")) {\n                valuesv = boolSV(DBIc_has(imp_xxh,DBIcf_TaintIn));\n            }\n            else if (keylen==8  && strEQ(key, \"TaintOut\")) {\n                valuesv = boolSV(DBIc_has(imp_xxh,DBIcf_TaintOut));\n            }\n            break;\n\n          case 'W':\n            if (keylen==4 && strEQ(key, \"Warn\")) {\n                valuesv = boolSV(DBIc_WARN(imp_xxh));\n            }\n            break;\n        }\n    }\n\n    /* finally check the actual hash */\n    if (valuesv == Nullsv) {\n        valuesv = &PL_sv_undef;\n        cacheit = 0;\n        svp = hv_fetch((HV*)SvRV(h), key, keylen, FALSE);\n        if (svp)\n            valuesv = newSVsv(*svp);    /* take copy to mortalize */\n        else /* warn unless it's known attribute name */\n        if ( !(         (*key=='H' && strEQ(key, \"HandleError\"))\n                ||      (*key=='H' && strEQ(key, \"HandleSetErr\"))\n                ||      (*key=='S' && strEQ(key, \"Statement\"))\n                ||      (*key=='P' && strEQ(key, \"ParamArrays\"))\n                ||      (*key=='P' && strEQ(key, \"ParamValues\"))\n                ||      (*key=='P' && strEQ(key, \"Profile\"))\n                ||      (*key=='R' && strEQ(key, \"ReadOnly\"))\n                ||      (*key=='C' && strEQ(key, \"CursorName\"))\n                ||      (*key=='C' && strEQ(key, \"Callbacks\"))\n                ||      (*key=='U' && strEQ(key, \"Username\"))\n                ||      !isUPPER(*key)  /* dbd_*, private_* etc */\n        ))\n            warn(\"Can't get %s->{%s}: unrecognised attribute name\",neatsvpv(h,0),key);\n    }\n\n    if (cacheit) {\n        (void)hv_store((HV*)SvRV(h), key, keylen, newSVsv(valuesv), 0);\n    }\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 3)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"    .. FETCH %s %s = %s%s\\n\", neatsvpv(h,0),\n            neatsvpv(keysv,0), neatsvpv(valuesv,0), cacheit?\" (cached)\":\"\");\n    if (valuesv == &PL_sv_yes || valuesv == &PL_sv_no || valuesv == &PL_sv_undef)\n        return valuesv; /* no need to mortalize yes or no */\n    return sv_2mortal(valuesv);\n}\n\n\n\n/* -------------------------------------------------------------------- */\n/* Functions implementing Error and Event Handling.                     */\n\n\nstatic SV *\ndbih_event(SV *hrv, const char *evtype, SV *a1, SV *a2)\n{\n    dTHX;\n    /* We arrive here via DBIh_EVENT* macros (see DBIXS.h) called from  */\n    /* DBD driver C code OR $h->event() method (in DBD::_::common)      */\n    /* XXX VERY OLD INTERFACE/CONCEPT MAY GO SOON */\n    /* OR MAY EVOLVE INTO A WAY TO HANDLE 'SUCCESS_WITH_INFO'/'WARNINGS' from db */\n    (void)hrv;\n    (void)evtype;\n    (void)a1;\n    (void)a2;\n    return &PL_sv_undef;\n}\n\n\n/* ----------------------------------------------------------------- */\n\n\nSTATIC I32\ndbi_dopoptosub_at(PERL_CONTEXT *cxstk, I32 startingblock)\n{\n    dTHX;\n    I32 i;\n    register PERL_CONTEXT *cx;\n    for (i = startingblock; i >= 0; i--) {\n        cx = &cxstk[i];\n        switch (CxTYPE(cx)) {\n        default:\n            continue;\n        case CXt_EVAL:\n        case CXt_SUB:\n#ifdef CXt_FORMAT\n        case CXt_FORMAT:\n#endif\n            DEBUG_l( Perl_deb(aTHX_ \"(Found sub #%ld)\\n\", (long)i));\n            return i;\n        }\n    }\n    return i;\n}\n\n\nstatic COP *\ndbi_caller_cop()\n{\n    dTHX;\n    register I32 cxix;\n    register PERL_CONTEXT *cx;\n    register PERL_CONTEXT *ccstack = cxstack;\n    PERL_SI *top_si = PL_curstackinfo;\n    char *stashname;\n\n    for ( cxix = dbi_dopoptosub_at(ccstack, cxstack_ix) ;; cxix = dbi_dopoptosub_at(ccstack, cxix - 1)) {\n        /* we may be in a higher stacklevel, so dig down deeper */\n        while (cxix < 0 && top_si->si_type != PERLSI_MAIN) {\n            top_si = top_si->si_prev;\n            ccstack = top_si->si_cxstack;\n            cxix = dbi_dopoptosub_at(ccstack, top_si->si_cxix);\n        }\n        if (cxix < 0) {\n            break;\n        }\n        if (PL_DBsub && cxix >= 0 && ccstack[cxix].blk_sub.cv == GvCV(PL_DBsub))\n            continue;\n        cx = &ccstack[cxix];\n        stashname = CopSTASHPV(cx->blk_oldcop);\n        if (!stashname)\n            continue;\n        if (!(stashname[0] == 'D' && stashname[1] == 'B'\n                && strchr(\"DI\", stashname[2])\n                    && (!stashname[3] || (stashname[3] == ':' && stashname[4] == ':'))))\n        {\n            return cx->blk_oldcop;\n        }\n        cxix = dbi_dopoptosub_at(ccstack, cxix - 1);\n    }\n    return NULL;\n}\n\nstatic void\ndbi_caller_string(SV *buf, COP *cop, char *prefix, int show_line, int show_path)\n{\n    dTHX;\n    STRLEN len;\n    long  line = CopLINE(cop);\n    char *file = SvPV(GvSV(CopFILEGV(cop)), len);\n    if (!show_path) {\n        char *sep;\n        if ( (sep=strrchr(file,'/')) || (sep=strrchr(file,'\\\\')))\n            file = sep+1;\n    }\n    if (show_line) {\n        sv_catpvf(buf, \"%s%s line %ld\", (prefix) ? prefix : \"\", file, line);\n    }\n    else {\n        sv_catpvf(buf, \"%s%s\",          (prefix) ? prefix : \"\", file);\n    }\n}\n\nstatic char *\nlog_where(SV *buf, int append, char *prefix, char *suffix, int show_line, int show_caller, int show_path)\n{\n    dTHX;\n    dTHR;\n    if (!buf)\n        buf = sv_2mortal(newSVpv(\"\",0));\n    else if (!append)\n        sv_setpv(buf,\"\");\n    if (CopLINE(PL_curcop)) {\n        COP *cop;\n        dbi_caller_string(buf, PL_curcop, prefix, show_line, show_path);\n        if (show_caller && (cop = dbi_caller_cop())) {\n            SV *via = sv_2mortal(newSVpv(\"\",0));\n            dbi_caller_string(via, cop, prefix, show_line, show_path);\n            sv_catpvf(buf, \" via %s\", SvPV_nolen(via));\n        }\n    }\n    if (PL_dirty)\n        sv_catpvf(buf, \" during global destruction\");\n    if (suffix)\n        sv_catpv(buf, suffix);\n    return SvPVX(buf);\n}\n\n\nstatic void\nclear_cached_kids(pTHX_ SV *h, imp_xxh_t *imp_xxh, const char *meth_name, int trace_level)\n{\n    if (DBIc_TYPE(imp_xxh) <= DBIt_DB) {\n        SV **svp = hv_fetch((HV*)SvRV(h), \"CachedKids\", 10, 0);\n        if (svp && SvROK(*svp) && SvTYPE(SvRV(*svp)) == SVt_PVHV) {\n            HV *hv = (HV*)SvRV(*svp);\n            if (HvKEYS(hv)) {\n                if (DBIc_TRACE_LEVEL(imp_xxh) > trace_level)\n                    trace_level = DBIc_TRACE_LEVEL(imp_xxh);\n                if (trace_level >= 2) {\n                    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"    >> %s %s clearing %d CachedKids\\n\",\n                        meth_name, neatsvpv(h,0), (int)HvKEYS(hv));\n                    PerlIO_flush(DBIc_LOGPIO(imp_xxh));\n                }\n                /* This will probably recurse through dispatch to DESTROY the kids */\n                /* For drh we should probably explicitly do dbh disconnects */\n                hv_clear(hv);\n            }\n        }\n    }\n}\n\n\nstatic NV\ndbi_time() {\n# ifdef HAS_GETTIMEOFDAY\n#   ifdef PERL_IMPLICIT_SYS\n    dTHX;\n#   endif\n    struct timeval when;\n    gettimeofday(&when, (struct timezone *) 0);\n    return when.tv_sec + (when.tv_usec / 1000000.0);\n# else  /* per-second is almost useless */\n# ifdef _WIN32 /* use _ftime() on Win32 (MS Visual C++ 6.0) */\n#  if defined(__BORLANDC__)\n#   define _timeb timeb\n#   define _ftime ftime\n#  endif\n    struct _timeb when;\n    _ftime( &when );\n    return when.time + (when.millitm / 1000.0);\n# else\n    return time(NULL);\n# endif\n# endif\n}\n\n\nstatic SV *\n_profile_next_node(SV *node, const char *name)\n{\n    /* step one level down profile Data tree and auto-vivify if required */\n    dTHX;\n    SV *orig_node = node;\n    if (SvROK(node))\n        node = SvRV(node);\n    if (SvTYPE(node) != SVt_PVHV) {\n        HV *hv = newHV();\n        if (SvOK(node)) {\n            char *key = \"(demoted)\";\n            warn(\"Profile data element %s replaced with new hash ref (for %s) and original value stored with key '%s'\",\n                neatsvpv(orig_node,0), name, key);\n            (void)hv_store(hv, key, strlen(key), SvREFCNT_inc(orig_node), 0);\n        }\n        sv_setsv(node, newRV_noinc((SV*)hv));\n        node = (SV*)hv;\n    }\n    node = *hv_fetch((HV*)node, name, strlen(name), 1);\n    return node;\n}\n\n\nstatic SV*\ndbi_profile(SV *h, imp_xxh_t *imp_xxh, SV *statement_sv, SV *method, NV t1, NV t2)\n{\n#define DBIprof_MAX_PATH_ELEM   100\n#define DBIprof_COUNT           0\n#define DBIprof_TOTAL_TIME      1\n#define DBIprof_FIRST_TIME      2\n#define DBIprof_MIN_TIME        3\n#define DBIprof_MAX_TIME        4\n#define DBIprof_FIRST_CALLED    5\n#define DBIprof_LAST_CALLED     6\n#define DBIprof_max_index       6\n    dTHX;\n    NV ti = t2 - t1;\n    int src_idx = 0;\n    HV *dbh_outer_hv = NULL;\n    HV *dbh_inner_hv = NULL;\n    char *statement_pv;\n    char *method_pv;\n    SV *profile;\n    SV *tmp;\n    SV *dest_node;\n    AV *av;\n    HV *h_hv;\n\n    const int call_depth = DBIc_CALL_DEPTH(imp_xxh);\n    const int parent_call_depth = DBIc_PARENT_COM(imp_xxh) ? DBIc_CALL_DEPTH(DBIc_PARENT_COM(imp_xxh)) : 0;\n    /* Only count calls originating from the application code   */\n    if (call_depth > 1 || parent_call_depth > 0)\n        return &PL_sv_undef;\n\n    if (!DBIc_has(imp_xxh, DBIcf_Profile))\n        return &PL_sv_undef;\n\n    method_pv = (SvTYPE(method)==SVt_PVCV) ? GvNAME(CvGV(method))\n                : isGV(method) ? GvNAME(method)\n                : SvOK(method) ? SvPV_nolen(method)\n                : \"\";\n\n    /* we don't profile DESTROY during global destruction */\n    if (PL_dirty && instr(method_pv, \"DESTROY\"))\n        return &PL_sv_undef;\n\n    h_hv = (HV*)SvRV(dbih_inner(aTHX_ h, \"dbi_profile\"));\n\n    profile = *hv_fetch(h_hv, \"Profile\", 7, 1);\n    if (profile && SvMAGICAL(profile))\n        mg_get(profile); /* FETCH */\n    if (!profile || !SvROK(profile)) {\n        DBIc_set(imp_xxh, DBIcf_Profile, 0); /* disable */\n        if (SvOK(profile) && !PL_dirty)\n            warn(\"Profile attribute isn't a hash ref (%s,%ld)\", neatsvpv(profile,0), (long)SvTYPE(profile));\n        return &PL_sv_undef;\n    }\n\n    /* statement_sv: undef = use $h->{Statement}, \"\" (&sv_no) = use empty string */\n\n    if (!SvOK(statement_sv)) {\n        SV **psv = hv_fetch(h_hv, \"Statement\", 9, 0);\n        statement_sv = (psv && SvOK(*psv)) ? *psv : &PL_sv_no;\n    }\n    statement_pv = SvPV_nolen(statement_sv);\n\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 4)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"       dbi_profile +%\" NVff \"s %s %s\\n\",\n            ti, method_pv, neatsvpv(statement_sv,0));\n\n    dest_node = _profile_next_node(profile, \"Data\");\n\n    tmp = *hv_fetch((HV*)SvRV(profile), \"Path\", 4, 1);\n    if (SvROK(tmp) && SvTYPE(SvRV(tmp))==SVt_PVAV) {\n        int len;\n        av = (AV*)SvRV(tmp);\n        len = av_len(av); /* -1=empty, 0=one element */\n\n        while ( src_idx <= len ) {\n            SV *pathsv = AvARRAY(av)[src_idx++];\n\n            if (SvROK(pathsv) && SvTYPE(SvRV(pathsv))==SVt_PVCV) {\n                /* call sub, use returned list of values as path */\n                /* returning a ref to undef vetos this profile data */\n                dSP;\n                I32 ax;\n                SV *code_sv = SvRV(pathsv);\n                I32 items;\n                I32 item_idx;\n                EXTEND(SP, 4);\n                PUSHMARK(SP);\n                PUSHs(h);   /* push inner handle, then others params */\n                PUSHs( sv_2mortal(newSVpv(method_pv,0)));\n                PUTBACK;\n                SAVE_DEFSV; /* local($_) = $statement */\n                DEFSV_set(statement_sv);\n                items = call_sv(code_sv, G_ARRAY);\n                SPAGAIN;\n                SP -= items ;\n                ax = (SP - PL_stack_base) + 1 ;\n                for (item_idx=0; item_idx < items; ++item_idx) {\n                    SV *item_sv = ST(item_idx);\n                    if (SvROK(item_sv)) {\n                        if (!SvOK(SvRV(item_sv)))\n                            items = -2; /* flag that we're rejecting this profile data */\n                        else /* other refs reserved */\n                            warn(\"Ignored ref returned by code ref in Profile Path\");\n                        break;\n                    }\n                    dest_node = _profile_next_node(dest_node, (SvOK(item_sv) ? SvPV_nolen(item_sv) : \"undef\"));\n                }\n                PUTBACK;\n                if (items == -2) /* this profile data was vetoed */\n                    return &PL_sv_undef;\n            }\n            else if (SvROK(pathsv)) {\n                /* only meant for refs to scalars currently */\n                const char *p = SvPV_nolen(SvRV(pathsv));\n                dest_node = _profile_next_node(dest_node, p);\n            }\n            else if (SvOK(pathsv)) {\n                STRLEN len;\n                const char *p = SvPV(pathsv,len);\n                if (p[0] == '!') { /* special cases */\n                    if (p[1] == 'S' && strEQ(p, \"!Statement\")) {\n                        dest_node = _profile_next_node(dest_node, statement_pv);\n                    }\n                    else if (p[1] == 'M' && strEQ(p, \"!MethodName\")) {\n                        dest_node = _profile_next_node(dest_node, method_pv);\n                    }\n                    else if (p[1] == 'M' && strEQ(p, \"!MethodClass\")) {\n                        if (SvTYPE(method) == SVt_PVCV) {\n                            p = SvPV_nolen((SV*)CvGV(method));\n                        }\n                        else if (isGV(method)) {\n                            /* just using SvPV_nolen(method) sometimes causes an error: */\n                            /* \"Can't coerce GLOB to string\" so we use gv_efullname()   */\n                            SV *tmpsv = sv_2mortal(newSVpv(\"\",0));\n#if (PERL_VERSION < 6)\n                            gv_efullname(tmpsv, (GV*)method);\n#else\n                            gv_efullname4(tmpsv, (GV*)method, \"\", TRUE);\n#endif\n                            p = SvPV_nolen(tmpsv);\n                            if (*p == '*') ++p; /* skip past leading '*' glob sigil */\n                        }\n                        else {\n                            p = method_pv;\n                        }\n                        dest_node = _profile_next_node(dest_node, p);\n                    }\n                    else if (p[1] == 'F' && strEQ(p, \"!File\")) {\n                        dest_node = _profile_next_node(dest_node, log_where(0, 0, \"\", \"\", 0, 0, 0));\n                    }\n                    else if (p[1] == 'F' && strEQ(p, \"!File2\")) {\n                        dest_node = _profile_next_node(dest_node, log_where(0, 0, \"\", \"\", 0, 1, 0));\n                    }\n                    else if (p[1] == 'C' && strEQ(p, \"!Caller\")) {\n                        dest_node = _profile_next_node(dest_node, log_where(0, 0, \"\", \"\", 1, 0, 0));\n                    }\n                    else if (p[1] == 'C' && strEQ(p, \"!Caller2\")) {\n                        dest_node = _profile_next_node(dest_node, log_where(0, 0, \"\", \"\", 1, 1, 0));\n                    }\n                    else if (p[1] == 'T' && (strEQ(p, \"!Time\") || strnEQ(p, \"!Time~\", 6))) {\n                        char timebuf[20];\n                        int factor = 1;\n                        if (p[5] == '~') {\n                            factor = atoi(&p[6]);\n                            if (factor == 0) /* sanity check to avoid div by zero error */\n                                factor = 3600;\n                        }\n                        sprintf(timebuf, \"%ld\", ((long)(dbi_time()/factor))*factor);\n                        dest_node = _profile_next_node(dest_node, timebuf);\n                    }\n                    else {\n                        warn(\"Unknown ! element in DBI::Profile Path: %s\", p);\n                        dest_node = _profile_next_node(dest_node, p);\n                    }\n                }\n                else if (p[0] == '{' && p[len-1] == '}') { /* treat as name of dbh attribute to use */\n                    SV **attr_svp;\n                    if (!dbh_inner_hv) {        /* cache dbh handles the first time we need them */\n                        imp_dbh_t *imp_dbh = (DBIc_TYPE(imp_xxh) <= DBIt_DB) ? (imp_dbh_t*)imp_xxh : (imp_dbh_t*)DBIc_PARENT_COM(imp_xxh);\n                        dbh_outer_hv = DBIc_MY_H(imp_dbh);\n                        if (SvTYPE(dbh_outer_hv) != SVt_PVHV)\n                            return &PL_sv_undef;        /* presumably global destruction - bail */\n                        dbh_inner_hv = (HV*)SvRV(dbih_inner(aTHX_ (SV*)dbh_outer_hv, \"profile\"));\n                        if (SvTYPE(dbh_inner_hv) != SVt_PVHV)\n                            return &PL_sv_undef;        /* presumably global destruction - bail */\n                    }\n                    /* fetch from inner first, then outer if key doesn't exist */\n                    /* (yes, this is an evil premature optimization) */\n                    p += 1; len -= 2; /* ignore the braces */\n                    if ((attr_svp = hv_fetch(dbh_inner_hv, p, len, 0)) == NULL) {\n                        /* try outer (tied) hash - for things like AutoCommit   */\n                        /* (will always return something even for unknowns)     */\n                        if ((attr_svp = hv_fetch(dbh_outer_hv, p, len, 0))) {\n                            if (SvGMAGICAL(*attr_svp))\n                                mg_get(*attr_svp); /* FETCH */\n                        }\n                    }\n                    if (!attr_svp)\n                        p -= 1; /* unignore the braces */\n                    else if (!SvOK(*attr_svp))\n                        p = \"\";\n                    else if (!SvTRUE(*attr_svp) && SvPOK(*attr_svp) && SvNIOK(*attr_svp))\n                        p = \"0\"; /* catch &sv_no style special case */\n                    else\n                        p = SvPV_nolen(*attr_svp);\n                    dest_node = _profile_next_node(dest_node, p);\n                }\n                else {\n                    dest_node = _profile_next_node(dest_node, p);\n                }\n            }\n            /* else undef, so ignore */\n        }\n    }\n    else { /* a bad Path value is treated as a Path of just Statement */\n        dest_node = _profile_next_node(dest_node, statement_pv);\n    }\n\n\n    if (!SvOK(dest_node)) {\n        av = newAV();\n        sv_setsv(dest_node, newRV_noinc((SV*)av));\n        av_store(av, DBIprof_COUNT,             newSViv(1));\n        av_store(av, DBIprof_TOTAL_TIME,        newSVnv(ti));\n        av_store(av, DBIprof_FIRST_TIME,        newSVnv(ti));\n        av_store(av, DBIprof_MIN_TIME,          newSVnv(ti));\n        av_store(av, DBIprof_MAX_TIME,          newSVnv(ti));\n        av_store(av, DBIprof_FIRST_CALLED,      newSVnv(t1));\n        av_store(av, DBIprof_LAST_CALLED,       newSVnv(t1));\n    }\n    else {\n        tmp = dest_node;\n        if (SvROK(tmp))\n            tmp = SvRV(tmp);\n        if (SvTYPE(tmp) != SVt_PVAV)\n            croak(\"Invalid Profile data leaf element: %s (type %ld)\",\n                    neatsvpv(tmp,0), (long)SvTYPE(tmp));\n        av = (AV*)tmp;\n        sv_inc( *av_fetch(av, DBIprof_COUNT, 1));\n        tmp = *av_fetch(av, DBIprof_TOTAL_TIME, 1);\n        sv_setnv(tmp, SvNV(tmp) + ti);\n        tmp = *av_fetch(av, DBIprof_MIN_TIME, 1);\n        if (ti < SvNV(tmp)) sv_setnv(tmp, ti);\n        tmp = *av_fetch(av, DBIprof_MAX_TIME, 1);\n        if (ti > SvNV(tmp)) sv_setnv(tmp, ti);\n        sv_setnv( *av_fetch(av, DBIprof_LAST_CALLED, 1), t1);\n    }\n    return dest_node; /* use with caution - copy first, ie sv_mortalcopy() */\n}\n\n\nstatic void\ndbi_profile_merge_nodes(SV *dest, SV *increment)\n{\n    dTHX;\n    AV *d_av, *i_av;\n    SV *tmp;\n    SV *tmp2;\n    NV i_nv;\n    int i_is_earlier;\n\n    if (!SvROK(dest) || SvTYPE(SvRV(dest)) != SVt_PVAV)\n        croak(\"dbi_profile_merge_nodes(%s, ...) requires array ref\", neatsvpv(dest,0));\n    d_av = (AV*)SvRV(dest);\n\n    if (av_len(d_av) < DBIprof_max_index) {\n        int idx;\n        av_extend(d_av, DBIprof_max_index);\n        for(idx=0; idx<=DBIprof_max_index; ++idx) {\n            tmp = *av_fetch(d_av, idx, 1);\n            if (!SvOK(tmp) && idx != DBIprof_MIN_TIME && idx != DBIprof_FIRST_CALLED)\n                sv_setnv(tmp, 0.0); /* leave 'min' values as undef */\n        }\n    }\n\n    if (!SvOK(increment))\n        return;\n\n    if (SvROK(increment) && SvTYPE(SvRV(increment)) == SVt_PVHV) {\n        HV *hv = (HV*)SvRV(increment);\n        char *key;\n        I32 keylen = 0;\n        hv_iterinit(hv);\n        while ( (tmp = hv_iternextsv(hv, &key, &keylen)) != NULL ) {\n            dbi_profile_merge_nodes(dest, tmp);\n        };\n        return;\n    }\n\n    if (!SvROK(increment) || SvTYPE(SvRV(increment)) != SVt_PVAV)\n        croak(\"dbi_profile_merge_nodes: increment %s not an array or hash ref\", neatsvpv(increment,0));\n    i_av = (AV*)SvRV(increment);\n\n    tmp  = *av_fetch(d_av, DBIprof_COUNT, 1);\n    tmp2 = *av_fetch(i_av, DBIprof_COUNT, 1);\n    if (SvIOK(tmp) && SvIOK(tmp2))\n        sv_setiv( tmp, SvIV(tmp) + SvIV(tmp2) );\n    else\n        sv_setnv( tmp, SvNV(tmp) + SvNV(tmp2) );\n\n    tmp = *av_fetch(d_av, DBIprof_TOTAL_TIME, 1);\n    sv_setnv( tmp, SvNV(tmp) + SvNV( *av_fetch(i_av, DBIprof_TOTAL_TIME, 1)) );\n\n    i_nv = SvNV(*av_fetch(i_av, DBIprof_MIN_TIME, 1));\n    tmp  =      *av_fetch(d_av, DBIprof_MIN_TIME, 1);\n    if (!SvOK(tmp) || i_nv < SvNV(tmp)) sv_setnv(tmp, i_nv);\n\n    i_nv = SvNV(*av_fetch(i_av, DBIprof_MAX_TIME, 1));\n    tmp  =      *av_fetch(d_av, DBIprof_MAX_TIME, 1);\n    if (i_nv > SvNV(tmp)) sv_setnv(tmp, i_nv);\n\n    i_nv = SvNV(*av_fetch(i_av, DBIprof_FIRST_CALLED, 1));\n    tmp  =      *av_fetch(d_av, DBIprof_FIRST_CALLED, 1);\n    i_is_earlier = (!SvOK(tmp) || i_nv < SvNV(tmp));\n    if (i_is_earlier)\n        sv_setnv(tmp, i_nv);\n\n    i_nv = SvNV(*av_fetch(i_av, DBIprof_FIRST_TIME, 1));\n    tmp  =      *av_fetch(d_av, DBIprof_FIRST_TIME, 1);\n    if (i_is_earlier || !SvOK(tmp)) {\n        /* If the increment has an earlier DBIprof_FIRST_CALLED\n        then we set the DBIprof_FIRST_TIME from the increment */\n        sv_setnv(tmp, i_nv);\n    }\n\n    i_nv = SvNV(*av_fetch(i_av, DBIprof_LAST_CALLED, 1));\n    tmp  =      *av_fetch(d_av, DBIprof_LAST_CALLED, 1);\n    if (i_nv > SvNV(tmp)) sv_setnv(tmp, i_nv);\n}\n\n\n/* ----------------------------------------------------------------- */\n/* ---   The DBI dispatcher. The heart of the perl DBI.          --- */\n\nXS(XS_DBI_dispatch);            /* prototype to pass -Wmissing-prototypes */\nXS(XS_DBI_dispatch)\n{\n    dXSARGS;\n    dORIGMARK;\n    dMY_CXT;\n\n    SV *h   = ST(0);            /* the DBI handle we are working with   */\n    SV *st1 = ST(1);            /* used in debugging */\n    SV *st2 = ST(2);            /* used in debugging */\n    SV *orig_h = h;\n    SV *err_sv;\n    SV **tmp_svp;\n    SV **hook_svp = 0;\n    MAGIC *mg;\n    int gimme = GIMME;\n    I32 trace_flags = DBIS->debug;      /* local copy may change during dispatch */\n    I32 trace_level = (trace_flags & DBIc_TRACE_LEVEL_MASK);\n    int is_DESTROY;\n    meth_types meth_type;\n    int is_unrelated_to_Statement = 0;\n    U32 keep_error = FALSE;\n    UV  ErrCount = UV_MAX;\n    int i, outitems;\n    int call_depth;\n    int is_nested_call;\n    NV profile_t1 = 0.0;\n    int is_orig_method_name = 1;\n\n    const char  *meth_name = GvNAME(CvGV(cv));\n    dbi_ima_t *ima = (dbi_ima_t*)CvXSUBANY(cv).any_ptr;\n    U32   ima_flags;\n    imp_xxh_t   *imp_xxh   = NULL;\n    SV          *imp_msv   = Nullsv;\n    SV          *qsv       = Nullsv; /* quick result from a shortcut method   */\n\n\n#ifdef BROKEN_DUP_ANY_PTR\n    if (ima->my_perl != my_perl) {\n        /* we couldn't dup the ima struct at clone time, so do it now */\n        dbi_ima_t *nima;\n        Newx(nima, 1, dbi_ima_t);\n        *nima = *ima; /* structure copy */\n        CvXSUBANY(cv).any_ptr = nima;\n        nima->stash = NULL;\n        nima->gv    = NULL;\n        nima->my_perl = my_perl;\n        ima = nima;\n    }\n#endif\n\n    ima_flags  = ima->flags;\n    meth_type = ima->meth_type;\n    if (trace_level >= 9) {\n        PerlIO *logfp = DBILOGFP;\n        PerlIO_printf(logfp,\"%c   >> %-11s DISPATCH (%s rc%ld/%ld @%ld g%x ima%lx pid#%ld)\",\n            (PL_dirty?'!':' '), meth_name, neatsvpv(h,0),\n            (long)SvREFCNT(h), (SvROK(h) ? (long)SvREFCNT(SvRV(h)) : (long)-1),\n            (long)items, (int)gimme, (long)ima_flags, (long)PerlProc_getpid());\n        PerlIO_puts(logfp, log_where(0, 0, \" at \",\"\\n\", 1, (trace_level >= 3), (trace_level >= 4)));\n        PerlIO_flush(logfp);\n    }\n\n    if ( ( (is_DESTROY=(meth_type == methtype_DESTROY))) ) {\n        /* note that croak()'s won't propagate, only append to $@ */\n        keep_error = TRUE;\n    }\n\n    /* If h is a tied hash ref, switch to the inner ref 'behind' the tie.\n       This means *all* DBI methods work with the inner (non-tied) ref.\n       This makes it much easier for methods to access the real hash\n       data (without having to go through FETCH and STORE methods) and\n       for tie and non-tie methods to call each other.\n    */\n    if (SvROK(h)\n        && SvRMAGICAL(SvRV(h))\n        && (\n               ((mg=SvMAGIC(SvRV(h)))->mg_type == 'P')\n            || ((mg=mg_find(SvRV(h),'P')) != NULL)\n           )\n    ) {\n        if (mg->mg_obj==NULL || !SvOK(mg->mg_obj) || SvRV(mg->mg_obj)==NULL) {  /* maybe global destruction */\n            if (trace_level >= 3)\n                PerlIO_printf(DBILOGFP,\n                    \"%c   <> %s for %s ignored (inner handle gone)\\n\",\n                    (PL_dirty?'!':' '), meth_name, neatsvpv(h,0));\n            XSRETURN(0);\n        }\n        /* Distinguish DESTROY of tie (outer) from DESTROY of inner ref */\n        /* This may one day be used to manually destroy extra internal  */\n        /* refs if the application ceases to use the handle.            */\n        if (is_DESTROY) {\n            imp_xxh = DBIh_COM(mg->mg_obj);\n#ifdef DBI_USE_THREADS\n            if (imp_xxh && DBIc_THR_USER(imp_xxh) != my_perl) {\n                goto is_DESTROY_wrong_thread;\n            }\n#endif\n            if (imp_xxh && DBIc_TYPE(imp_xxh) <= DBIt_DB)\n                clear_cached_kids(aTHX_ mg->mg_obj, imp_xxh, meth_name, trace_level);\n            /* XXX might be better to move this down to after call_depth has been\n             * incremented and then also SvREFCNT_dec(mg->mg_obj) to force an immediate\n             * DESTROY of the inner handle if there are no other refs to it.\n             * That way the inner DESTROY is properly flagged as a nested call,\n             * and the outer DESTROY gets profiled more accurately, and callbacks work.\n             */\n            if (trace_level >= 3) {\n                PerlIO_printf(DBILOGFP,\n                    \"%c   <> DESTROY(%s) ignored for outer handle (inner %s has ref cnt %ld)\\n\",\n                    (PL_dirty?'!':' '), neatsvpv(h,0), neatsvpv(mg->mg_obj,0),\n                    (long)SvREFCNT(SvRV(mg->mg_obj))\n                );\n            }\n            /* for now we ignore it since it'll be followed soon by     */\n            /* a destroy of the inner hash and that'll do the real work */\n\n            /* However, we must at least modify DBIc_MY_H() as that is  */\n            /* pointing (without a refcnt inc) to the scalar that is    */\n            /* being destroyed, so it'll contain random values later.   */\n            if (imp_xxh)\n                DBIc_MY_H(imp_xxh) = (HV*)SvRV(mg->mg_obj); /* inner (untied) HV */\n\n            XSRETURN(0);\n        }\n        h = mg->mg_obj; /* switch h to inner ref                        */\n        ST(0) = h;      /* switch handle on stack to inner ref          */\n    }\n\n    imp_xxh = dbih_getcom2(aTHX_ h, 0); /* get common Internal Handle Attributes        */\n    if (!imp_xxh) {\n        if (meth_type == methtype_can) {  /* ref($h)->can(\"foo\")        */\n            const char *can_meth = SvPV_nolen(st1);\n            SV *rv = &PL_sv_undef;\n            GV *gv = gv_fetchmethod_autoload(gv_stashsv(orig_h,FALSE), can_meth, FALSE);\n            if (gv && isGV(gv))\n                rv = sv_2mortal(newRV_inc((SV*)GvCV(gv)));\n            if (trace_level >= 1) {\n                PerlIO_printf(DBILOGFP,\"    <- %s(%s) = %p\\n\", meth_name, can_meth, neatsvpv(rv,0));\n            }\n            ST(0) = rv;\n            XSRETURN(1);\n        }\n        if (trace_level)\n            PerlIO_printf(DBILOGFP, \"%c   <> %s for %s ignored (no imp_data)\\n\",\n                (PL_dirty?'!':' '), meth_name, neatsvpv(h,0));\n        if (!is_DESTROY)\n            warn(\"Can't call %s method on handle %s%s\", meth_name, neatsvpv(h,0),\n                SvROK(h) ? \" after take_imp_data()\" : \" (not a reference)\");\n        XSRETURN(0);\n    }\n\n    if (DBIc_has(imp_xxh,DBIcf_Profile)) {\n        profile_t1 = dbi_time(); /* just get start time here */\n    }\n\n#ifdef DBI_USE_THREADS\n{\n    PerlInterpreter * h_perl;\n    is_DESTROY_wrong_thread:\n    h_perl = DBIc_THR_USER(imp_xxh) ;\n    if (h_perl != my_perl) {\n        /* XXX could call a 'handle clone' method here?, for dbh's at least */\n        if (is_DESTROY) {\n            if (trace_level >= 3) {\n                PerlIO_printf(DBILOGFP,\"    DESTROY ignored because DBI %sh handle (%s) is owned by thread %p not current thread %p\\n\",\n                      dbih_htype_name(DBIc_TYPE(imp_xxh)), HvNAME(DBIc_IMP_STASH(imp_xxh)),\n                      (void*)DBIc_THR_USER(imp_xxh), (void*)my_perl) ;\n                PerlIO_flush(DBILOGFP);\n            }\n            XSRETURN(0); /* don't DESTROY handle, if it is not our's !*/\n        }\n        croak(\"%s %s failed: handle %d is owned by thread %lx not current thread %lx (%s)\",\n            HvNAME(DBIc_IMP_STASH(imp_xxh)), meth_name, DBIc_TYPE(imp_xxh),\n            (unsigned long)h_perl, (unsigned long)my_perl,\n            \"handles can't be shared between threads and your driver may need a CLONE method added\");\n    }\n}\n#endif\n\n    if ((i = DBIc_DEBUGIV(imp_xxh))) { /* merge handle into global */\n        I32 h_trace_level = (i & DBIc_TRACE_LEVEL_MASK);\n        if ( h_trace_level > trace_level )\n            trace_level = h_trace_level;\n        trace_flags = (trace_flags & ~DBIc_TRACE_LEVEL_MASK)\n                    | (          i & ~DBIc_TRACE_LEVEL_MASK)\n                    | trace_level;\n    }\n\n    /* Check method call against Internal Method Attributes */\n    if (ima_flags) {\n\n        if (ima_flags & (IMA_STUB|IMA_FUNC_REDIRECT|IMA_KEEP_ERR|IMA_KEEP_ERR_SUB|IMA_CLEAR_STMT)) {\n\n            if (ima_flags & IMA_STUB) {\n                if (meth_type == methtype_can) {\n                    const char *can_meth = SvPV_nolen(st1);\n                    SV *dbi_msv = Nullsv;\n                    /* find handle implementors method (GV or CV) */\n                    if ( (imp_msv = (SV*)gv_fetchmethod_autoload(DBIc_IMP_STASH(imp_xxh), can_meth, FALSE)) ) {\n                        /* return DBI's CV, not the implementors CV (else we'd bypass dispatch) */\n                        /* and anyway, we may have hit a private method not part of the DBI     */\n                        GV *gv = gv_fetchmethod_autoload(SvSTASH(SvRV(orig_h)), can_meth, FALSE);\n                        if (gv && isGV(gv))\n                            dbi_msv = (SV*)GvCV(gv);\n                    }\n                    if (trace_level >= 1) {\n                        PerlIO *logfp = DBILOGFP;\n                        PerlIO_printf(logfp,\"    <- %s(%s) = %p (%s %p)\\n\", meth_name, can_meth, (void*)dbi_msv,\n                                (imp_msv && isGV(imp_msv)) ? HvNAME(GvSTASH(imp_msv)) : \"?\", (void*)imp_msv);\n                    }\n                    ST(0) = (dbi_msv) ? sv_2mortal(newRV_inc(dbi_msv)) : &PL_sv_undef;\n                    XSRETURN(1);\n                }\n                XSRETURN(0);\n            }\n            if (ima_flags & IMA_FUNC_REDIRECT) {\n                /* XXX this doesn't redispatch, nor consider the IMA of the new method */\n                SV *meth_name_sv = POPs;\n                PUTBACK;\n                --items;\n                if (!SvPOK(meth_name_sv) || SvNIOK(meth_name_sv))\n                    croak(\"%s->%s() invalid redirect method name %s\",\n                            neatsvpv(h,0), meth_name, neatsvpv(meth_name_sv,0));\n                meth_name = SvPV_nolen(meth_name_sv);\n                meth_type = get_meth_type(meth_name);\n                is_orig_method_name = 0;\n            }\n            if (ima_flags & IMA_KEEP_ERR)\n                keep_error = TRUE;\n            if ((ima_flags & IMA_KEEP_ERR_SUB)\n                && !PL_dirty\n                && DBIc_PARENT_COM(imp_xxh) && DBIc_CALL_DEPTH(DBIc_PARENT_COM(imp_xxh)) > 0)\n                keep_error = TRUE;\n            if (ima_flags & IMA_CLEAR_STMT) {\n                /* don't use SvOK_off: dbh's Statement may be ref to sth's */\n                (void)hv_store((HV*)SvRV(h), \"Statement\", 9, &PL_sv_undef, 0);\n            }\n            if (ima_flags & IMA_CLEAR_CACHED_KIDS)\n                clear_cached_kids(aTHX_ h, imp_xxh, meth_name, trace_flags);\n\n        }\n\n        if (ima_flags & IMA_HAS_USAGE) {\n            const char *err = NULL;\n            char msg[200];\n\n            if (ima->minargs && (items < ima->minargs\n                                || (ima->maxargs>0 && items > ima->maxargs))) {\n                sprintf(msg,\n                    \"DBI %s: invalid number of arguments: got handle + %ld, expected handle + between %d and %d\\n\",\n                    meth_name, (long)items-1, (int)ima->minargs-1, (int)ima->maxargs-1);\n                err = msg;\n            }\n            /* arg type checking could be added here later */\n            if (err) {\n                croak(\"%sUsage: %s->%s(%s)\", err, \"$h\", meth_name,\n                    (ima->usage_msg) ? ima->usage_msg : \"...?\");\n            }\n        }\n    }\n\n    is_unrelated_to_Statement = ( (DBIc_TYPE(imp_xxh) == DBIt_ST) ? 0\n                                : (DBIc_TYPE(imp_xxh) == DBIt_DR) ? 1\n                                : (ima_flags & IMA_UNRELATED_TO_STMT) );\n\n    if (PL_tainting && items > 1              /* method call has args   */\n        && DBIc_is(imp_xxh, DBIcf_TaintIn)    /* taint checks requested */\n        && !(ima_flags & IMA_NO_TAINT_IN)\n    ) {\n        for(i=1; i < items; ++i) {\n            if (SvTAINTED(ST(i))) {\n                char buf[100];\n                sprintf(buf,\"parameter %d of %s->%s method call\",\n                        i, SvPV_nolen(h), meth_name);\n                PL_tainted = 1; /* needed for TAINT_PROPER to work      */\n                TAINT_PROPER(buf);      /* die's */\n            }\n        }\n    }\n\n    /* record this inner handle for use by DBI::var::FETCH      */\n    if (is_DESTROY) {\n\n        /* force destruction of any outstanding children */\n        if ((tmp_svp = hv_fetch((HV*)SvRV(h), \"ChildHandles\", 12, FALSE)) && SvROK(*tmp_svp)) {\n            AV *av = (AV*)SvRV(*tmp_svp);\n            I32 kidslots;\n            PerlIO *logfp = DBILOGFP;\n\n            for (kidslots = AvFILL(av); kidslots >= 0; --kidslots) {\n                SV **hp = av_fetch(av, kidslots, FALSE);\n                if (!hp || !SvROK(*hp) || SvTYPE(SvRV(*hp))!=SVt_PVHV)\n                    break;\n\n                if (trace_level >= 1) {\n                    PerlIO_printf(logfp, \"on DESTROY handle %s still has child %s (refcnt %ld, obj %d, dirty=%d)\\n\",\n                        neatsvpv(h,0), neatsvpv(*hp, 0), (long)SvREFCNT(*hp), !!sv_isobject(*hp), PL_dirty);\n                    if (trace_level >= 9)\n                        sv_dump(SvRV(*hp));\n                }\n                if (sv_isobject(*hp)) { /* call DESTROY on the handle */\n                    PUSHMARK(SP);\n                    XPUSHs(*hp);\n                    PUTBACK;\n                    call_method(\"DESTROY\", G_VOID|G_EVAL|G_KEEPERR);\n                    MSPAGAIN;\n                }\n                else {\n                    imp_xxh_t *imp_xxh = dbih_getcom2(aTHX_ *hp, 0);\n                    if (imp_xxh && DBIc_COMSET(imp_xxh)) {\n                        dbih_clearcom(imp_xxh);\n                        sv_setsv(*hp, &PL_sv_undef);\n                    }\n                }\n            }\n        }\n\n        if (DBIc_TYPE(imp_xxh) <= DBIt_DB ) {   /* is dbh or drh */\n            imp_xxh_t *parent_imp;\n\n            if (SvOK(DBIc_ERR(imp_xxh)) && (parent_imp = DBIc_PARENT_COM(imp_xxh))\n                && !PL_dirty /* XXX - remove? */\n            ) {\n                /* copy err/errstr/state values to $DBI::err etc still work */\n                sv_setsv(DBIc_ERR(parent_imp),    DBIc_ERR(imp_xxh));\n                sv_setsv(DBIc_ERRSTR(parent_imp), DBIc_ERRSTR(imp_xxh));\n                sv_setsv(DBIc_STATE(parent_imp),  DBIc_STATE(imp_xxh));\n            }\n        }\n\n        if (DBIc_AIADESTROY(imp_xxh)) { /* wants ineffective destroy after fork */\n            if ((U32)PerlProc_getpid() != _imp2com(imp_xxh, std.pid))\n                DBIc_set(imp_xxh, DBIcf_IADESTROY, 1);\n        }\n        if (DBIc_IADESTROY(imp_xxh)) {  /* wants ineffective destroy    */\n            DBIc_ACTIVE_off(imp_xxh);\n        }\n        call_depth = 0;\n        is_nested_call = 0;\n    }\n    else {\n        DBI_SET_LAST_HANDLE(h);\n        SAVEINT(DBIc_CALL_DEPTH(imp_xxh));\n        call_depth = ++DBIc_CALL_DEPTH(imp_xxh);\n\n        if (ima_flags & IMA_COPY_UP_STMT) { /* execute() */\n            copy_statement_to_parent(aTHX_ h, imp_xxh);\n        }\n        is_nested_call =\n            (call_depth > 1\n                || (!PL_dirty /* not in global destruction [CPAN #75614] */\n                    && DBIc_PARENT_COM(imp_xxh)\n                    && DBIc_CALL_DEPTH(DBIc_PARENT_COM(imp_xxh))) >= 1);\n\n    }\n\n\n    /* --- dispatch --- */\n\n    if (!keep_error && meth_type != methtype_set_err) {\n        SV *err_sv;\n        if (trace_level && SvOK(err_sv=DBIc_ERR(imp_xxh))) {\n            PerlIO *logfp = DBILOGFP;\n            PerlIO_printf(logfp, \"    !! The %s '%s' was CLEARED by call to %s method\\n\",\n                SvTRUE(err_sv) ? \"ERROR\" : strlen(SvPV_nolen(err_sv)) ? \"warn\" : \"info\",\n                neatsvpv(DBIc_ERR(imp_xxh),0), meth_name);\n        }\n        DBIh_CLEAR_ERROR(imp_xxh);\n    }\n    else {      /* we check for change in ErrCount/err_hash during call */\n        ErrCount = DBIc_ErrCount(imp_xxh);\n        if (keep_error)\n            keep_error = err_hash(aTHX_ imp_xxh);\n    }\n\n    if (DBIc_has(imp_xxh,DBIcf_Callbacks)\n        && (tmp_svp = hv_fetch((HV*)SvRV(h), \"Callbacks\", 9, 0))\n        && (   (hook_svp = hv_fetch((HV*)SvRV(*tmp_svp), meth_name, strlen(meth_name), 0))\n              /* the \"*\" fallback callback only applies to non-nested calls\n               * and also doesn't apply to the 'set_err' or DESTROY methods.\n               * Nor during global destruction.\n               * Other restrictions may be added over time.\n               * It's an undocumented hack.\n               */\n          || (!is_nested_call && !PL_dirty && meth_type != methtype_set_err &&\n               meth_type != methtype_DESTROY &&\n               (hook_svp = hv_fetch((HV*)SvRV(*tmp_svp), \"*\", 1, 0))\n             )\n        )\n        && SvROK(*hook_svp)\n    ) {\n        SV *orig_defsv;\n        SV *temp_defsv;\n        SV *code = SvRV(*hook_svp);\n        I32 skip_dispatch = 0;\n        if (trace_level)\n            PerlIO_printf(DBILOGFP, \"%c   {{ %s callback %s being invoked with %ld args\\n\",\n                (PL_dirty?'!':' '), meth_name, neatsvpv(*hook_svp,0), (long)items);\n\n        /* we don't use ENTER,SAVETMPS & FREETMPS,LEAVE because we may need mortal\n         * results to live long enough to be returned to our caller\n         */\n        /* we want to localize $_ for the callback but can't just do that alone\n         * because we're not using SAVETMPS & FREETMPS, so we have to get sneaky.\n         * We still localize, so we're safe from the callback die-ing,\n         * but after the callback we manually restore the original $_.\n         */\n        orig_defsv = DEFSV; /* remember the current $_ */\n        SAVE_DEFSV;         /* local($_) = $method_name */\n        temp_defsv = sv_2mortal(newSVpv(meth_name,0));\n# ifdef SvTEMP_off\n        SvTEMP_off(temp_defsv);\n# endif\n        DEFSV_set(temp_defsv);\n\n        EXTEND(SP, items+1);\n        PUSHMARK(SP);\n        PUSHs(orig_h);                  /* push outer handle, then others params */\n        for (i=1; i < items; ++i) {     /* start at 1 to skip handle */\n            PUSHs( ST(i) );\n        }\n        PUTBACK;\n        outitems = call_sv(code, G_ARRAY); /* call the callback code */\n        MSPAGAIN;\n\n        /* The callback code can undef $_ to indicate to skip dispatch */\n        skip_dispatch = !SvOK(DEFSV);\n        /* put $_ back now, but with an incremented ref count to compensate\n         * for the ref count decrement that will happen when we exit the scope.\n         */\n        DEFSV_set(SvREFCNT_inc(orig_defsv));\n\n        if (trace_level)\n            PerlIO_printf(DBILOGFP, \"%c   }} %s callback %s returned%s\\n\",\n                (PL_dirty?'!':' '), meth_name, neatsvpv(*hook_svp,0),\n                skip_dispatch ? \", actual method will not be called\" : \"\"\n            );\n        if (skip_dispatch) {    /* XXX experimental */\n            int ix = outitems;\n            /* copy the new items down to the destination list */\n            while (ix-- > 0) {\n                if(0)warn(\"\\tcopy down %d: %s overwriting %s\\n\", ix, SvPV_nolen(TOPs), SvPV_nolen(ST(ix)) );\n                ST(ix) = POPs;\n            }\n            imp_msv = *hook_svp; /* for trace and profile */\n            goto post_dispatch;\n        }\n        else {\n            if (outitems != 0)\n                die(\"Callback for %s returned %d values but must not return any (temporary restriction in current version)\",\n                        meth_name, (int)outitems);\n            /* POP's and PUTBACK? to clear stack */\n        }\n    }\n\n    /* set Executed after Callbacks so it's not set if callback elects to skip the method */\n    if (ima_flags & IMA_EXECUTE) {\n        imp_xxh_t *parent = DBIc_PARENT_COM(imp_xxh);\n        DBIc_on(imp_xxh, DBIcf_Executed);\n        if (parent)\n            DBIc_on(parent, DBIcf_Executed);\n    }\n\n    /* The \"quick_FETCH\" logic...                                       */\n    /* Shortcut for fetching attributes to bypass method call overheads */\n    if (meth_type == methtype_FETCH && !DBIc_COMPAT(imp_xxh)) {\n        STRLEN kl;\n        const char *key = SvPV(st1, kl);\n        SV **attr_svp;\n        if (*key != '_' && (attr_svp=hv_fetch((HV*)SvRV(h), key, kl, 0))) {\n            qsv = *attr_svp;\n            /* disable FETCH from cache for special attributes */\n            if (SvROK(qsv) && SvTYPE(SvRV(qsv))==SVt_PVHV && *key=='D' &&\n                (  (kl==6 && DBIc_TYPE(imp_xxh)==DBIt_DB && strEQ(key,\"Driver\"))\n                || (kl==8 && DBIc_TYPE(imp_xxh)==DBIt_ST && strEQ(key,\"Database\")) )\n            ) {\n                qsv = Nullsv;\n            }\n            /* disable profiling of FETCH of Profile data */\n            if (*key == 'P' && strEQ(key, \"Profile\"))\n                profile_t1 = 0.0;\n        }\n        if (qsv) { /* skip real method call if we already have a 'quick' value */\n            ST(0) = sv_mortalcopy(qsv);\n            outitems = 1;\n            goto post_dispatch;\n        }\n    }\n\n    {\n        CV *meth_cv;\n#ifdef DBI_save_hv_fetch_ent\n        HE save_mh;\n        if (meth_type == methtype_FETCH)\n            save_mh = PL_hv_fetch_ent_mh; /* XXX nested tied FETCH bug17575 workaround */\n#endif\n\n        if (trace_flags) {\n            SAVEI32(DBIS->debug);       /* fall back to orig value later */\n            DBIS->debug = trace_flags;  /* make new value global (for now) */\n            if (ima) {\n                /* enabling trace via flags takes precedence over disabling due to min level */\n                if ((trace_flags & DBIc_TRACE_FLAGS_MASK) & (ima->method_trace & DBIc_TRACE_FLAGS_MASK))\n                    trace_level = (trace_level < 2) ? 2 : trace_level; /* min */\n                else\n                if (trace_level < (DBIc_TRACE_LEVEL_MASK & ima->method_trace))\n                    trace_level = 0;        /* silence dispatch log for this method */\n            }\n        }\n\n        if (is_orig_method_name\n            && ima->stash == DBIc_IMP_STASH(imp_xxh)\n            && ima->generation == PL_sub_generation +\n                                        MY_cache_gen(DBIc_IMP_STASH(imp_xxh))\n        )\n            imp_msv = (SV*)ima->gv;\n        else {\n            imp_msv = (SV*)gv_fetchmethod_autoload(DBIc_IMP_STASH(imp_xxh),\n                                            meth_name, FALSE);\n            if (is_orig_method_name) {\n                /* clear stale entry, if any */\n                SvREFCNT_dec(ima->stash);\n                SvREFCNT_dec(ima->gv);\n                if (!imp_msv) {\n                    ima->stash = NULL;\n                    ima->gv    = NULL;\n                }\n                else {\n                    ima->stash = (HV*)SvREFCNT_inc(DBIc_IMP_STASH(imp_xxh));\n                    ima->gv    = (GV*)SvREFCNT_inc(imp_msv);\n                    ima->generation = PL_sub_generation +\n                                        MY_cache_gen(DBIc_IMP_STASH(imp_xxh));\n                }\n            }\n        }\n\n        /* if method was a 'func' then try falling back to real 'func' method */\n        if (!imp_msv && (ima_flags & IMA_FUNC_REDIRECT)) {\n            imp_msv = (SV*)gv_fetchmethod_autoload(DBIc_IMP_STASH(imp_xxh), \"func\", FALSE);\n            if (imp_msv) {\n                /* driver does have func method so undo the earlier 'func' stack changes */\n                PUSHs(sv_2mortal(newSVpv(meth_name,0)));\n                PUTBACK;\n                ++items;\n                meth_name = \"func\";\n                meth_type = methtype_ordinary;\n            }\n        }\n\n        if (trace_level >= (is_nested_call ? 4 : 2)) {\n            PerlIO *logfp = DBILOGFP;\n            /* Full pkg method name (or just meth_name for ANON CODE)   */\n            const char *imp_meth_name = (imp_msv && isGV(imp_msv)) ? GvNAME(imp_msv) : meth_name;\n            HV *imp_stash = DBIc_IMP_STASH(imp_xxh);\n            PerlIO_printf(logfp, \"%c   -> %s \",\n                    call_depth>1 ? '0'+call_depth-1 : (PL_dirty?'!':' '), imp_meth_name);\n            if (imp_meth_name[0] == 'A' && strEQ(imp_meth_name,\"AUTOLOAD\"))\n                    PerlIO_printf(logfp, \"\\\"%s\\\" \", meth_name);\n            if (imp_msv && isGV(imp_msv) && GvSTASH(imp_msv) != imp_stash)\n                PerlIO_printf(logfp, \"in %s \", HvNAME(GvSTASH(imp_msv)));\n            PerlIO_printf(logfp, \"for %s (%s\", HvNAME(imp_stash),\n                        SvPV_nolen(orig_h));\n            if (h != orig_h)    /* show inner handle to aid tracing */\n                 PerlIO_printf(logfp, \"~0x%lx\", (long)SvRV(h));\n            else PerlIO_printf(logfp, \"~INNER\");\n            for(i=1; i<items; ++i) {\n                PerlIO_printf(logfp,\" %s\",\n                    (ima && i==ima->hidearg) ? \"****\" : neatsvpv(ST(i),0));\n            }\n#ifdef DBI_USE_THREADS\n            PerlIO_printf(logfp, \") thr#%p\\n\", (void*)DBIc_THR_USER(imp_xxh));\n#else\n            PerlIO_printf(logfp, \")\\n\");\n#endif\n            PerlIO_flush(logfp);\n        }\n\n        if (!imp_msv || ! ((meth_cv = GvCV(imp_msv))) ) {\n            if (PL_dirty || is_DESTROY) {\n                outitems = 0;\n                goto post_dispatch;\n            }\n            if (ima_flags & IMA_NOT_FOUND_OKAY) {\n                outitems = 0;\n                goto post_dispatch;\n            }\n            croak(\"Can't locate DBI object method \\\"%s\\\" via package \\\"%s\\\"\",\n                meth_name, HvNAME(DBIc_IMP_STASH(imp_xxh)));\n        }\n\n        PUSHMARK(mark);  /* mark arguments again so we can pass them on */\n\n        /* Note: the handle on the stack is still an object blessed into a\n         * DBI::* class and not the DBD::*::* class whose method is being\n         * invoked. This is correct and should be largely transparent.\n         */\n\n        /* SHORT-CUT ALERT! */\n        if (use_xsbypass && CvISXSUB(meth_cv) && CvXSUB(meth_cv)) {\n\n            /* If we are calling an XSUB we jump directly to its C code and\n             * bypass perl_call_sv(), pp_entersub() etc. This is fast.\n             * This code is based on a small section of pp_entersub().\n             */\n            (void)(*CvXSUB(meth_cv))(aTHXo_ meth_cv); /* Call the C code directly */\n\n            if (gimme == G_SCALAR) {    /* Enforce sanity in scalar context */\n                if (ax != PL_stack_sp - PL_stack_base ) { /* outitems != 1 */\n                    ST(0) =\n                        (ax > PL_stack_sp - PL_stack_base)\n                            ? &PL_sv_undef  /* outitems == 0 */\n                            : *PL_stack_sp; /* outitems > 1 */\n                    PL_stack_sp = PL_stack_base + ax;\n                }\n                outitems = 1;\n            }\n            else {\n                outitems = PL_stack_sp - (PL_stack_base + ax - 1);\n            }\n\n        }\n        else {\n            /* sv_dump(imp_msv); */\n            outitems = call_sv((SV*)meth_cv,\n                (is_DESTROY ? gimme | G_EVAL | G_KEEPERR : gimme) );\n        }\n\n        XSprePUSH; /* reset SP to base of stack frame */\n\n#ifdef DBI_save_hv_fetch_ent\n        if (meth_type == methtype_FETCH)\n            PL_hv_fetch_ent_mh = save_mh;       /* see start of block */\n#endif\n    }\n\n    post_dispatch:\n\n    if (is_DESTROY && DBI_IS_LAST_HANDLE(h)) { /* if destroying _this_ handle */\n        SV *lhp = DBIc_PARENT_H(imp_xxh);\n        if (lhp && SvROK(lhp)) {\n            DBI_SET_LAST_HANDLE(lhp);\n        }\n        else {\n            DBI_UNSET_LAST_HANDLE;\n        }\n    }\n\n    if (keep_error) {\n        /* if we didn't clear err before the call, check to see if a new error\n         * or warning has been recorded. If so, turn off keep_error so it gets acted on\n         */\n        if (DBIc_ErrCount(imp_xxh) > ErrCount || err_hash(aTHX_ imp_xxh) != keep_error) {\n            keep_error = 0;\n        }\n    }\n\n    err_sv = DBIc_ERR(imp_xxh);\n\n    if (trace_level >= (is_nested_call ? 3 : 1)) {\n        PerlIO *logfp = DBILOGFP;\n        const int is_fetch  = (meth_type == methtype_fetch_star && DBIc_TYPE(imp_xxh)==DBIt_ST);\n        const IV row_count = (is_fetch) ? DBIc_ROW_COUNT((imp_sth_t*)imp_xxh) : 0;\n        if (is_fetch && row_count>=2 && trace_level<=4 && SvOK(ST(0))) {\n            /* skip the 'middle' rows to reduce output */\n            goto skip_meth_return_trace;\n        }\n        if (SvOK(err_sv)) {\n            PerlIO_printf(logfp, \"    %s %s %s %s (err#%ld)\\n\", (keep_error) ? \"  \" : \"!!\",\n                SvTRUE(err_sv) ? \"ERROR:\" : strlen(SvPV_nolen(err_sv)) ? \"warn:\" : \"info:\",\n                neatsvpv(err_sv,0), neatsvpv(DBIc_ERRSTR(imp_xxh),0), (long)DBIc_ErrCount(imp_xxh));\n        }\n        PerlIO_printf(logfp,\"%c%c  <%c %s\",\n                    (call_depth > 1)  ? '0'+call_depth-1 : (PL_dirty?'!':' '),\n                    (DBIc_is(imp_xxh, DBIcf_TaintIn|DBIcf_TaintOut)) ? 'T' : ' ',\n                    (qsv) ? '>' : '-',\n                    meth_name);\n        if (trace_level==1 && (items>=2||is_DESTROY)) { /* make level 1 more useful */\n            /* we only have the first two parameters available here */\n            if (is_DESTROY) /* show handle as first arg to DESTROY */\n                /* want to show outer handle so trace makes sense       */\n                /* but outer handle has been destroyed so we fake it    */\n                PerlIO_printf(logfp,\"(%s=HASH(0x%p)\", HvNAME(SvSTASH(SvRV(orig_h))), (void*)DBIc_MY_H(imp_xxh));\n            else\n                PerlIO_printf(logfp,\"(%s\", neatsvpv(st1,0));\n            if (items >= 3)\n                PerlIO_printf(logfp,\", %s\", neatsvpv(st2,0));\n            PerlIO_printf(logfp,\"%s)\", (items > 3) ? \", ...\" : \"\");\n        }\n\n        if (gimme & G_ARRAY)\n             PerlIO_printf(logfp,\"= (\");\n        else PerlIO_printf(logfp,\"=\");\n        for(i=0; i < outitems; ++i) {\n            SV *s = ST(i);\n            if ( SvROK(s) && SvTYPE(SvRV(s))==SVt_PVAV) {\n                AV *av = (AV*)SvRV(s);\n                int avi;\n                int avi_last = SvIV(DBIS->neatsvpvlen) / 10;\n                if (avi_last < 39)\n                    avi_last = 39;\n                PerlIO_printf(logfp, \" [\");\n                for (avi=0; avi <= AvFILL(av); ++avi) {\n                    PerlIO_printf(logfp, \" %s\",  neatsvpv(AvARRAY(av)[avi],0));\n                    if (avi >= avi_last && AvFILL(av) - avi > 1) {\n                        PerlIO_printf(logfp, \" ... %ld others skipped\", AvFILL(av) - avi);\n                        break;\n                    }\n                }\n                PerlIO_printf(logfp, \" ]\");\n            }\n            else {\n                PerlIO_printf(logfp, \" %s\",  neatsvpv(s,0));\n                if ( SvROK(s) && SvTYPE(SvRV(s))==SVt_PVHV && !SvOBJECT(SvRV(s)) )\n                    PerlIO_printf(logfp, \"%ldkeys\", (long)HvKEYS(SvRV(s)));\n            }\n        }\n        if (gimme & G_ARRAY) {\n            PerlIO_printf(logfp,\" ) [%d items]\", outitems);\n        }\n        if (is_fetch && row_count) {\n            PerlIO_printf(logfp,\" row%\"IVdf, row_count);\n        }\n        if (qsv) /* flag as quick and peek at the first arg (still on the stack) */\n            PerlIO_printf(logfp,\" (%s from cache)\", neatsvpv(st1,0));\n        else if (!imp_msv)\n            PerlIO_printf(logfp,\" (not implemented)\");\n        /* XXX add flag to show pid here? */\n        /* add file and line number information */\n        PerlIO_puts(logfp, log_where(0, 0, \" at \", \"\\n\", 1, (trace_level >= 3), (trace_level >= 4)));\n    skip_meth_return_trace:\n        PerlIO_flush(logfp);\n    }\n\n    if (ima_flags & IMA_END_WORK) { /* commit() or rollback() */\n        /* XXX does not consider if the method call actually worked or not */\n        DBIc_off(imp_xxh, DBIcf_Executed);\n\n        if (DBIc_has(imp_xxh, DBIcf_BegunWork)) {\n            DBIc_off(imp_xxh, DBIcf_BegunWork);\n            if (!DBIc_has(imp_xxh, DBIcf_AutoCommit)) {\n                /* We only get here if the driver hasn't implemented their own code     */\n                /* for begin_work, or has but hasn't correctly turned AutoCommit        */\n                /* back on in their commit or rollback code. So we have to do it.       */\n                /* This is bad because it'll probably trigger a spurious commit()       */\n                /* and may mess up the error handling below for the commit/rollback     */\n                PUSHMARK(SP);\n                XPUSHs(h);\n                XPUSHs(sv_2mortal(newSVpv(\"AutoCommit\",0)));\n                XPUSHs(&PL_sv_yes);\n                PUTBACK;\n                call_method(\"STORE\", G_VOID);\n                MSPAGAIN;\n            }\n        }\n    }\n\n    if (PL_tainting\n        && DBIc_is(imp_xxh, DBIcf_TaintOut)   /* taint checks requested */\n        /* XXX this would taint *everything* being returned from *any*  */\n        /* method that doesn't have IMA_NO_TAINT_OUT set.               */\n        /* DISABLED: just tainting fetched data in get_fbav seems ok    */\n        && 0/* XXX disabled*/ /* !(ima_flags & IMA_NO_TAINT_OUT) */\n    ) {\n        dTHR;\n        TAINT; /* affects sv_setsv()'s within same perl statement */\n        for(i=0; i < outitems; ++i) {\n            I32 avi;\n            char *p;\n            SV *s;\n            SV *agg = ST(i);\n            if ( !SvROK(agg) )\n                continue;\n            agg = SvRV(agg);\n#define DBI_OUT_TAINTABLE(s) (!SvREADONLY(s) && !SvTAINTED(s))\n            switch (SvTYPE(agg)) {\n            case SVt_PVAV:\n                for(avi=0; avi <= AvFILL((AV*)agg); ++avi) {\n                    s = AvARRAY((AV*)agg)[avi];\n                    if (DBI_OUT_TAINTABLE(s))\n                        SvTAINTED_on(s);\n                }\n                break;\n            case SVt_PVHV:\n                hv_iterinit((HV*)agg);\n                while( (s = hv_iternextsv((HV*)agg, &p, &avi)) ) {\n                    if (DBI_OUT_TAINTABLE(s))\n                        SvTAINTED_on(s);\n                }\n                break;\n            default:\n                if (DBIc_WARN(imp_xxh)) {\n                    PerlIO_printf(DBILOGFP,\"Don't know how to taint contents of returned %s (type %d)\\n\",\n                        neatsvpv(agg,0), (int)SvTYPE(agg));\n                }\n            }\n        }\n    }\n\n    /* if method returned a new handle, and that handle has an error on it\n     * then copy the error up into the parent handle\n     */\n    if (ima_flags & IMA_IS_FACTORY && SvROK(ST(0))) {\n        SV *h_new = ST(0);\n        D_impdata(imp_xxh_new, imp_xxh_t, h_new);\n        if (SvOK(DBIc_ERR(imp_xxh_new))) {\n            set_err_sv(h, imp_xxh, DBIc_ERR(imp_xxh_new), DBIc_ERRSTR(imp_xxh_new), DBIc_STATE(imp_xxh_new), &PL_sv_no);\n        }\n    }\n\n    if (   !keep_error                  /* is a new err/warn/info               */\n        && !is_nested_call              /* skip nested (internal) calls         */\n        && (\n               /* is an error and has RaiseError|PrintError|HandleError set     */\n           (SvTRUE(err_sv) && DBIc_has(imp_xxh, DBIcf_RaiseError|DBIcf_PrintError|DBIcf_HandleError))\n               /* is a warn (not info) and has RaiseWarn|PrintWarn set          */\n        || (  SvOK(err_sv) && strlen(SvPV_nolen(err_sv)) && DBIc_has(imp_xxh, DBIcf_RaiseWarn|DBIcf_PrintWarn))\n        )\n    ) {\n        SV *msg;\n        SV **statement_svp = NULL;\n        const int is_warning = (!SvTRUE(err_sv) && strlen(SvPV_nolen(err_sv))==1);\n        const char *err_meth_name = meth_name;\n        char intro[200];\n\n        if (meth_type == methtype_set_err) {\n            SV **sem_svp = hv_fetch((HV*)SvRV(h), \"dbi_set_err_method\", 18, GV_ADDWARN);\n            if (SvOK(*sem_svp))\n                err_meth_name = SvPV_nolen(*sem_svp);\n        }\n\n        /* XXX change to vsprintf into sv directly */\n        sprintf(intro,\"%s %s %s: \", HvNAME(DBIc_IMP_STASH(imp_xxh)), err_meth_name,\n            SvTRUE(err_sv) ? \"failed\" : is_warning ? \"warning\" : \"information\");\n        msg = sv_2mortal(newSVpv(intro,0));\n        if (SvOK(DBIc_ERRSTR(imp_xxh)))\n            sv_catsv(msg, DBIc_ERRSTR(imp_xxh));\n        else\n            sv_catpvf(msg, \"(err=%s, errstr=undef, state=%s)\",\n                neatsvpv(DBIc_ERR(imp_xxh),0), neatsvpv(DBIc_STATE(imp_xxh),0) );\n\n        if (    DBIc_has(imp_xxh, DBIcf_ShowErrorStatement)\n            && !is_unrelated_to_Statement\n            && (DBIc_TYPE(imp_xxh) == DBIt_ST || ima_flags & IMA_SHOW_ERR_STMT)\n            && (statement_svp = hv_fetch((HV*)SvRV(h), \"Statement\", 9, 0))\n            &&  statement_svp && SvOK(*statement_svp)\n        ) {\n            SV **svp = 0;\n            sv_catpv(msg, \" [for Statement \\\"\");\n            sv_catsv(msg, *statement_svp);\n\n            /* fetch from tied outer handle to trigger FETCH magic  */\n            /* could add DBIcf_ShowErrorParams (default to on?)         */\n            if (!(ima_flags & IMA_HIDE_ERR_PARAMVALUES)) {\n                svp = hv_fetch((HV*)DBIc_MY_H(imp_xxh),\"ParamValues\",11,FALSE);\n                if (svp && SvMAGICAL(*svp))\n                    mg_get(*svp); /* XXX may recurse, may croak. could use eval */\n            }\n            if (svp && SvRV(*svp) && SvTYPE(SvRV(*svp)) == SVt_PVHV && HvKEYS(SvRV(*svp))>0 ) {\n                SV *param_values_sv = sv_2mortal(_join_hash_sorted((HV*)SvRV(*svp), \"=\",1, \", \",2, 1, -1));\n                sv_catpv(msg, \"\\\" with ParamValues: \");\n                sv_catsv(msg, param_values_sv);\n                sv_catpvn(msg, \"]\", 1);\n            }\n            else {\n                sv_catpv(msg, \"\\\"]\");\n            }\n        }\n\n        if (0) {\n            COP *cop = dbi_caller_cop();\n            if (cop && (CopLINE(cop) != CopLINE(PL_curcop) || CopFILEGV(cop) != CopFILEGV(PL_curcop))) {\n                dbi_caller_string(msg, cop, \" called via \", 1, 0);\n            }\n        }\n\n        hook_svp = NULL;\n        if (   (SvTRUE(err_sv) || (is_warning && DBIc_has(imp_xxh, DBIcf_RaiseWarn)))\n            &&  DBIc_has(imp_xxh, DBIcf_HandleError)\n            && (hook_svp = hv_fetch((HV*)SvRV(h),\"HandleError\",11,0))\n            &&  hook_svp && SvOK(*hook_svp)\n        ) {\n            dSP;\n            PerlIO *logfp = DBILOGFP;\n            IV items;\n            SV *status;\n            SV *result; /* point to result SV that's pointed to by the stack */\n            if (outitems) {\n                result = *(sp-outitems+1);\n                if (SvREADONLY(result)) {\n                    *(sp-outitems+1) = result = sv_2mortal(newSVsv(result));\n                }\n            }\n            else {\n                result = sv_newmortal();\n            }\n            if (trace_level)\n                PerlIO_printf(logfp,\"    -> HandleError on %s via %s%s%s%s\\n\",\n                    neatsvpv(h,0), neatsvpv(*hook_svp,0),\n                    (!outitems ? \"\" : \" (\"),\n                    (!outitems ? \"\" : neatsvpv(result ,0)),\n                    (!outitems ? \"\" : \")\")\n                );\n            PUSHMARK(SP);\n            XPUSHs(msg);\n            XPUSHs(sv_2mortal(newRV_inc((SV*)DBIc_MY_H(imp_xxh))));\n            XPUSHs( result );\n            PUTBACK;\n            items = call_sv(*hook_svp, G_SCALAR);\n            MSPAGAIN;\n            status = (items) ? POPs : &PL_sv_undef;\n            PUTBACK;\n            if (trace_level)\n                PerlIO_printf(logfp,\"    <- HandleError= %s%s%s%s\\n\",\n                    neatsvpv(status,0),\n                    (!outitems ? \"\" : \" (\"),\n                    (!outitems ? \"\" : neatsvpv(result,0)),\n                    (!outitems ? \"\" : \")\")\n                );\n            if (!SvTRUE(status)) /* handler says it didn't handle it, so... */\n                hook_svp = 0;  /* pretend we didn't have a handler...     */\n        }\n\n        if (profile_t1) { /* see also dbi_profile() call a few lines below */\n            SV *statement_sv = (is_unrelated_to_Statement) ? &PL_sv_no : &PL_sv_undef;\n            dbi_profile(h, imp_xxh, statement_sv, imp_msv ? imp_msv : (SV*)cv,\n                profile_t1, dbi_time());\n        }\n        if (!hook_svp && is_warning) {\n            if (DBIc_has(imp_xxh, DBIcf_PrintWarn))\n                warn_sv(msg);\n            if (DBIc_has(imp_xxh, DBIcf_RaiseWarn))\n                croak_sv(msg);\n        }\n        else if (!hook_svp && SvTRUE(err_sv)) {\n            if (DBIc_has(imp_xxh, DBIcf_PrintError))\n                warn_sv(msg);\n            if (DBIc_has(imp_xxh, DBIcf_RaiseError))\n                croak_sv(msg);\n        }\n    }\n    else if (profile_t1) { /* see also dbi_profile() call a few lines above */\n        SV *statement_sv = (is_unrelated_to_Statement) ? &PL_sv_no : &PL_sv_undef;\n        dbi_profile(h, imp_xxh, statement_sv, imp_msv ? imp_msv : (SV*)cv,\n                profile_t1, dbi_time());\n    }\n    XSRETURN(outitems);\n}\n\n\n\n/* -------------------------------------------------------------------- */\n\n/* comment and placeholder styles to accept and return */\n\n#define DBIpp_cm_cs 0x000001   /* C style */\n#define DBIpp_cm_hs 0x000002   /* #       */\n#define DBIpp_cm_dd 0x000004   /* --      */\n#define DBIpp_cm_br 0x000008   /* {}      */\n#define DBIpp_cm_dw 0x000010   /* '-- ' dash dash whitespace */\n#define DBIpp_cm_XX 0x00001F   /* any of the above */\n\n#define DBIpp_ph_qm 0x000100   /* ?       */\n#define DBIpp_ph_cn 0x000200   /* :1      */\n#define DBIpp_ph_cs 0x000400   /* :name   */\n#define DBIpp_ph_sp 0x000800   /* %s (as return only, not accept)    */\n#define DBIpp_ph_XX 0x000F00   /* any of the above */\n\n#define DBIpp_st_qq 0x010000   /* '' char escape */\n#define DBIpp_st_bs 0x020000   /* \\  char escape */\n#define DBIpp_st_XX 0x030000   /* any of the above */\n\n#define DBIpp_L_BRACE '{'\n#define DBIpp_R_BRACE '}'\n#define PS_accept(flag)  DBIbf_has(ps_accept,(flag))\n#define PS_return(flag)  DBIbf_has(ps_return,(flag))\n\nSV *\npreparse(SV *dbh, const char *statement, IV ps_return, IV ps_accept, void *foo)\n{\n    dTHX;\n    D_imp_xxh(dbh);\n/*\n        The idea here is that ps_accept defines which constructs to\n        recognize (accept) as valid in the source string (other\n        constructs are ignored), and ps_return defines which\n        constructs are valid to return in the result string.\n\n        If a construct that is valid in the input is also valid in the\n        output then it's simply copied. If it's not valid in the output\n        then it's editied into one of the valid forms (ideally the most\n        'standard' and/or information preserving one).\n\n        For example, if ps_accept includes '--' style comments but\n        ps_return doesn't, but ps_return does include '#' style\n        comments then any '--' style comments would be rewritten as '#'\n        style comments.\n\n        Similarly for placeholders. DBD::Oracle, for example, would say\n        '?', ':1' and ':name' are all acceptable input, but only\n        ':name' should be returned.\n\n        (There's a tricky issue with the '--' comment style because it can\n        clash with valid syntax, i.e., \"... set foo=foo--1 ...\" so it\n        would be *bad* to misinterpret that as the start of a comment.\n        Perhaps we need a DBIpp_cm_dw (for dash-dash-whitespace) style\n        to allow for that.)\n\n        Also, we'll only support DBIpp_cm_br as an input style. And\n        even then, only with reluctance. We may (need to) drop it when\n        we add support for odbc escape sequences.\n*/\n    int idx = 1;\n\n    char in_quote = '\\0';\n    char in_comment = '\\0';\n    char rt_comment = '\\0';\n    char *dest, *start;\n    const char *src;\n    const char *style = \"\", *laststyle = NULL;\n    SV *new_stmt_sv;\n\n    (void)foo;\n\n    if (!(ps_return | DBIpp_ph_XX)) { /* no return ph type specified */\n        ps_return |= ps_accept | DBIpp_ph_XX;   /* so copy from ps_accept */\n    }\n\n    /* XXX this allocation strategy won't work when we get to more advanced stuff */\n    new_stmt_sv = newSV(strlen(statement) * 3);\n    sv_setpv(new_stmt_sv,\"\");\n    src  = statement;\n    dest = SvPVX(new_stmt_sv);\n\n    while( *src )\n    {\n        if (*src == '%' && PS_return(DBIpp_ph_sp))\n            *dest++ = '%';\n\n        if (in_comment)\n        {\n             if (       (in_comment == '-' && (*src == '\\n' || *(src+1) == '\\0'))\n                ||      (in_comment == '#' && (*src == '\\n' || *(src+1) == '\\0'))\n                ||      (in_comment == DBIpp_L_BRACE && *src == DBIpp_R_BRACE) /* XXX nesting? */\n                ||      (in_comment == '/' && *src == '*' && *(src+1) == '/')\n             ) {\n                switch (rt_comment) {\n                case '/':       *dest++ = '*'; *dest++ = '/';   break;\n                case '-':       *dest++ = '\\n';                 break;\n                case '#':       *dest++ = '\\n';                 break;\n                case DBIpp_L_BRACE: *dest++ = DBIpp_R_BRACE;    break;\n                case '\\0':      /* ensure deleting a comment doesn't join two tokens */\n                        if (in_comment=='/' || in_comment==DBIpp_L_BRACE)\n                            *dest++ = ' '; /* ('-' and '#' styles use the newline) */\n                        break;\n                }\n                if (in_comment == '/')\n                    src++;\n                src += (*src != '\\n' || *(dest-1)=='\\n') ? 1 : 0;\n                in_comment = '\\0';\n                rt_comment = '\\0';\n             }\n             else\n             if (rt_comment)\n                *dest++ = *src++;\n             else\n                src++;  /* delete (don't copy) the comment */\n             continue;\n        }\n\n        if (in_quote)\n        {\n            if (*src == in_quote) {\n                in_quote = 0;\n            }\n            *dest++ = *src++;\n            continue;\n        }\n\n        /* Look for comments */\n        if (*src == '-' && *(src+1) == '-' &&\n                (PS_accept(DBIpp_cm_dd) || (*(src+2) == ' ' && PS_accept(DBIpp_cm_dw)))\n        )\n        {\n            in_comment = *src;\n            src += 2;   /* skip past 2nd char of double char delimiters */\n            if (PS_return(DBIpp_cm_dd) || PS_return(DBIpp_cm_dw)) {\n                *dest++ = rt_comment = '-';\n                *dest++ = '-';\n                if (PS_return(DBIpp_cm_dw) && *src!=' ')\n                    *dest++ = ' '; /* insert needed white space */\n            }\n            else if (PS_return(DBIpp_cm_cs)) {\n                *dest++ = rt_comment = '/';\n                *dest++ = '*';\n            }\n            else if (PS_return(DBIpp_cm_hs)) {\n                *dest++ = rt_comment = '#';\n            }\n            else if (PS_return(DBIpp_cm_br)) {\n                *dest++ = rt_comment = DBIpp_L_BRACE;\n            }\n            continue;\n        }\n        else if (*src == '/' && *(src+1) == '*' && PS_accept(DBIpp_cm_cs))\n        {\n            in_comment = *src;\n            src += 2;   /* skip past 2nd char of double char delimiters */\n            if (PS_return(DBIpp_cm_cs)) {\n                *dest++ = rt_comment = '/';\n                *dest++ = '*';\n            }\n            else if (PS_return(DBIpp_cm_dd) || PS_return(DBIpp_cm_dw)) {\n                *dest++ = rt_comment = '-';\n                *dest++ = '-';\n                if (PS_return(DBIpp_cm_dw)) *dest++ = ' ';\n            }\n            else if (PS_return(DBIpp_cm_hs)) {\n                *dest++ = rt_comment = '#';\n            }\n            else if (PS_return(DBIpp_cm_br)) {\n                *dest++ = rt_comment = DBIpp_L_BRACE;\n            }\n            continue;\n        }\n        else if (*src == '#' && PS_accept(DBIpp_cm_hs))\n        {\n            in_comment = *src;\n            src++;\n            if (PS_return(DBIpp_cm_hs)) {\n                *dest++ = rt_comment = '#';\n            }\n            else if (PS_return(DBIpp_cm_dd) || PS_return(DBIpp_cm_dw)) {\n                *dest++ = rt_comment = '-';\n                *dest++ = '-';\n                if (PS_return(DBIpp_cm_dw)) *dest++ = ' ';\n            }\n            else if (PS_return(DBIpp_cm_cs)) {\n                *dest++ = rt_comment = '/';\n                *dest++ = '*';\n            }\n            else if (PS_return(DBIpp_cm_br)) {\n                *dest++ = rt_comment = DBIpp_L_BRACE;\n            }\n            continue;\n        }\n        else if (*src == DBIpp_L_BRACE && PS_accept(DBIpp_cm_br))\n        {\n            in_comment = *src;\n            src++;\n            if (PS_return(DBIpp_cm_br)) {\n                *dest++ = rt_comment = DBIpp_L_BRACE;\n            }\n            else if (PS_return(DBIpp_cm_dd) || PS_return(DBIpp_cm_dw)) {\n                *dest++ = rt_comment = '-';\n                *dest++ = '-';\n                if (PS_return(DBIpp_cm_dw)) *dest++ = ' ';\n            }\n            else if (PS_return(DBIpp_cm_cs)) {\n                *dest++ = rt_comment = '/';\n                *dest++ = '*';\n            }\n            else if (PS_return(DBIpp_cm_hs)) {\n                *dest++ = rt_comment = '#';\n            }\n            continue;\n        }\n\n       if (    !(*src==':' && (PS_accept(DBIpp_ph_cn) || PS_accept(DBIpp_ph_cs)))\n           &&  !(*src=='?' &&  PS_accept(DBIpp_ph_qm))\n       ){\n            if (*src == '\\'' || *src == '\"')\n                in_quote = *src;\n            *dest++ = *src++;\n            continue;\n        }\n\n        /* only here for : or ? outside of a comment or literal */\n\n        start = dest;                   /* save name inc colon  */\n        *dest++ = *src++;               /* copy and move past first char */\n\n        if (*start == '?')              /* X/Open Standard */\n        {\n            style = \"?\";\n\n            if (PS_return(DBIpp_ph_qm))\n                ;\n            else if (PS_return(DBIpp_ph_cn)) { /* '?' -> ':p1' (etc) */\n                sprintf(start,\":p%d\", idx++);\n                dest = start+strlen(start);\n            }\n            else if (PS_return(DBIpp_ph_sp)) { /* '?' -> '%s' */\n                   *start  = '%';\n                   *dest++ = 's';\n            }\n        }\n        else if (isDIGIT(*src)) {   /* :1 */\n            const int pln = atoi(src);\n            style = \":1\";\n\n            if (PS_return(DBIpp_ph_cn)) { /* ':1'->':p1'  */\n                   idx = pln;\n                   *dest++ = 'p';\n                   while(isDIGIT(*src))\n                       *dest++ = *src++;\n            }\n            else if (PS_return(DBIpp_ph_qm) /* ':1' -> '?'  */\n                 ||  PS_return(DBIpp_ph_sp) /* ':1' -> '%s' */\n            ) {\n                   PS_return(DBIpp_ph_qm) ? sprintf(start,\"?\") : sprintf(start,\"%%s\");\n                   dest = start + strlen(start);\n                   if (pln != idx) {\n                        char buf[99];\n                        sprintf(buf, \"preparse found placeholder :%d out of sequence, expected :%d\", pln, idx);\n                        set_err_char(dbh, imp_xxh, \"1\", 1, buf, 0, \"preparse\");\n                        return &PL_sv_undef;\n                   }\n                   while(isDIGIT(*src)) src++;\n                   idx++;\n            }\n        }\n        else if (isALNUM(*src))         /* :name */\n        {\n            style = \":name\";\n\n            if (PS_return(DBIpp_ph_cs)) {\n                ;\n            }\n            else if (PS_return(DBIpp_ph_qm) /* ':name' -> '?'  */\n                 ||  PS_return(DBIpp_ph_sp) /* ':name' -> '%s' */\n            ) {\n                PS_return(DBIpp_ph_qm) ? sprintf(start,\"?\") : sprintf(start,\"%%s\");\n                dest = start + strlen(start);\n                while (isALNUM(*src))   /* consume name, includes '_'   */\n                    src++;\n            }\n        }\n        /* perhaps ':=' PL/SQL construct */\n        else { continue; }\n\n        *dest = '\\0';                   /* handy for debugging  */\n\n        if (laststyle && style != laststyle) {\n            char buf[99];\n            sprintf(buf, \"preparse found mixed placeholder styles (%s / %s)\", style, laststyle);\n            set_err_char(dbh, imp_xxh, \"1\", 1, buf, 0, \"preparse\");\n            return &PL_sv_undef;\n        }\n        laststyle = style;\n    }\n    *dest = '\\0';\n\n    /* warn about probable parsing errors, but continue anyway (returning processed string) */\n    switch (in_quote)\n    {\n    case '\\'':\n            set_err_char(dbh, imp_xxh, \"1\", 1, \"preparse found unterminated single-quoted string\", 0, \"preparse\");\n            break;\n    case '\\\"':\n            set_err_char(dbh, imp_xxh, \"1\", 1, \"preparse found unterminated double-quoted string\", 0, \"preparse\");\n            break;\n    }\n    switch (in_comment)\n    {\n    case DBIpp_L_BRACE:\n            set_err_char(dbh, imp_xxh, \"1\", 1, \"preparse found unterminated bracketed {...} comment\", 0, \"preparse\");\n            break;\n    case '/':\n            set_err_char(dbh, imp_xxh, \"1\", 1, \"preparse found unterminated bracketed C-style comment\", 0, \"preparse\");\n            break;\n    }\n\n    SvCUR_set(new_stmt_sv, strlen(SvPVX(new_stmt_sv)));\n    *SvEND(new_stmt_sv) = '\\0';\n    return new_stmt_sv;\n}\n\n\n/* -------------------------------------------------------------------- */\n/* The DBI Perl interface (via XS) starts here. Currently these are     */\n/* all internal support functions. Note install_method and see DBI.pm   */\n\nMODULE = DBI   PACKAGE = DBI\n\nREQUIRE:    1.929\nPROTOTYPES: DISABLE\n\n\nBOOT:\n    {\n        MY_CXT_INIT;\n        PERL_UNUSED_VAR(MY_CXT);\n    }\n    PERL_UNUSED_VAR(cv);\n    PERL_UNUSED_VAR(items);\n    dbi_bootinit(NULL);\n    /* make this sub into a fake XS so it can bee seen by DBD::* modules;\n     * never actually call it as an XS sub, or it will crash and burn! */\n    (void) newXS(\"DBI::_dbi_state_lval\", (XSUBADDR_t)_dbi_state_lval, __FILE__);\n\n\nI32\nconstant()\n        PROTOTYPE:\n    ALIAS:\n        SQL_ALL_TYPES                    = SQL_ALL_TYPES\n        SQL_ARRAY                        = SQL_ARRAY\n        SQL_ARRAY_LOCATOR                = SQL_ARRAY_LOCATOR\n        SQL_BIGINT                       = SQL_BIGINT\n        SQL_BINARY                       = SQL_BINARY\n        SQL_BIT                          = SQL_BIT\n        SQL_BLOB                         = SQL_BLOB\n        SQL_BLOB_LOCATOR                 = SQL_BLOB_LOCATOR\n        SQL_BOOLEAN                      = SQL_BOOLEAN\n        SQL_CHAR                         = SQL_CHAR\n        SQL_CLOB                         = SQL_CLOB\n        SQL_CLOB_LOCATOR                 = SQL_CLOB_LOCATOR\n        SQL_DATE                         = SQL_DATE\n        SQL_DATETIME                     = SQL_DATETIME\n        SQL_DECIMAL                      = SQL_DECIMAL\n        SQL_DOUBLE                       = SQL_DOUBLE\n        SQL_FLOAT                        = SQL_FLOAT\n        SQL_GUID                         = SQL_GUID\n        SQL_INTEGER                      = SQL_INTEGER\n        SQL_INTERVAL                     = SQL_INTERVAL\n        SQL_INTERVAL_DAY                 = SQL_INTERVAL_DAY\n        SQL_INTERVAL_DAY_TO_HOUR         = SQL_INTERVAL_DAY_TO_HOUR\n        SQL_INTERVAL_DAY_TO_MINUTE       = SQL_INTERVAL_DAY_TO_MINUTE\n        SQL_INTERVAL_DAY_TO_SECOND       = SQL_INTERVAL_DAY_TO_SECOND\n        SQL_INTERVAL_HOUR                = SQL_INTERVAL_HOUR\n        SQL_INTERVAL_HOUR_TO_MINUTE      = SQL_INTERVAL_HOUR_TO_MINUTE\n        SQL_INTERVAL_HOUR_TO_SECOND      = SQL_INTERVAL_HOUR_TO_SECOND\n        SQL_INTERVAL_MINUTE              = SQL_INTERVAL_MINUTE\n        SQL_INTERVAL_MINUTE_TO_SECOND    = SQL_INTERVAL_MINUTE_TO_SECOND\n        SQL_INTERVAL_MONTH               = SQL_INTERVAL_MONTH\n        SQL_INTERVAL_SECOND              = SQL_INTERVAL_SECOND\n        SQL_INTERVAL_YEAR                = SQL_INTERVAL_YEAR\n        SQL_INTERVAL_YEAR_TO_MONTH       = SQL_INTERVAL_YEAR_TO_MONTH\n        SQL_LONGVARBINARY                = SQL_LONGVARBINARY\n        SQL_LONGVARCHAR                  = SQL_LONGVARCHAR\n        SQL_MULTISET                     = SQL_MULTISET\n        SQL_MULTISET_LOCATOR             = SQL_MULTISET_LOCATOR\n        SQL_NUMERIC                      = SQL_NUMERIC\n        SQL_REAL                         = SQL_REAL\n        SQL_REF                          = SQL_REF\n        SQL_ROW                          = SQL_ROW\n        SQL_SMALLINT                     = SQL_SMALLINT\n        SQL_TIME                         = SQL_TIME\n        SQL_TIMESTAMP                    = SQL_TIMESTAMP\n        SQL_TINYINT                      = SQL_TINYINT\n        SQL_TYPE_DATE                    = SQL_TYPE_DATE\n        SQL_TYPE_TIME                    = SQL_TYPE_TIME\n        SQL_TYPE_TIMESTAMP               = SQL_TYPE_TIMESTAMP\n        SQL_TYPE_TIMESTAMP_WITH_TIMEZONE = SQL_TYPE_TIMESTAMP_WITH_TIMEZONE\n        SQL_TYPE_TIME_WITH_TIMEZONE      = SQL_TYPE_TIME_WITH_TIMEZONE\n        SQL_UDT                          = SQL_UDT\n        SQL_UDT_LOCATOR                  = SQL_UDT_LOCATOR\n        SQL_UNKNOWN_TYPE                 = SQL_UNKNOWN_TYPE\n        SQL_VARBINARY                    = SQL_VARBINARY\n        SQL_VARCHAR                      = SQL_VARCHAR\n        SQL_WCHAR                        = SQL_WCHAR\n        SQL_WLONGVARCHAR                 = SQL_WLONGVARCHAR\n        SQL_WVARCHAR                     = SQL_WVARCHAR\n        SQL_CURSOR_FORWARD_ONLY          = SQL_CURSOR_FORWARD_ONLY\n        SQL_CURSOR_KEYSET_DRIVEN         = SQL_CURSOR_KEYSET_DRIVEN\n        SQL_CURSOR_DYNAMIC               = SQL_CURSOR_DYNAMIC\n        SQL_CURSOR_STATIC                = SQL_CURSOR_STATIC\n        SQL_CURSOR_TYPE_DEFAULT          = SQL_CURSOR_TYPE_DEFAULT\n        DBIpp_cm_cs     = DBIpp_cm_cs\n        DBIpp_cm_hs     = DBIpp_cm_hs\n        DBIpp_cm_dd     = DBIpp_cm_dd\n        DBIpp_cm_dw     = DBIpp_cm_dw\n        DBIpp_cm_br     = DBIpp_cm_br\n        DBIpp_cm_XX     = DBIpp_cm_XX\n        DBIpp_ph_qm     = DBIpp_ph_qm\n        DBIpp_ph_cn     = DBIpp_ph_cn\n        DBIpp_ph_cs     = DBIpp_ph_cs\n        DBIpp_ph_sp     = DBIpp_ph_sp\n        DBIpp_ph_XX     = DBIpp_ph_XX\n        DBIpp_st_qq     = DBIpp_st_qq\n        DBIpp_st_bs     = DBIpp_st_bs\n        DBIpp_st_XX     = DBIpp_st_XX\n        DBIstcf_DISCARD_STRING  = DBIstcf_DISCARD_STRING\n        DBIstcf_STRICT          = DBIstcf_STRICT\n        DBIf_TRACE_SQL  = DBIf_TRACE_SQL\n        DBIf_TRACE_CON  = DBIf_TRACE_CON\n        DBIf_TRACE_ENC  = DBIf_TRACE_ENC\n        DBIf_TRACE_DBD  = DBIf_TRACE_DBD\n        DBIf_TRACE_TXN  = DBIf_TRACE_TXN\n    CODE:\n    RETVAL = ix;\n    OUTPUT:\n    RETVAL\n\n\nvoid\n_clone_dbis()\n    CODE:\n    dMY_CXT;\n    dbistate_t * parent_dbis = DBIS;\n\n    (void)cv;\n    {\n        MY_CXT_CLONE;\n    }\n    dbi_bootinit(parent_dbis);\n\n\nvoid\n_new_handle(class, parent, attr_ref, imp_datasv, imp_class)\n    SV *        class\n    SV *        parent\n    SV *        attr_ref\n    SV *        imp_datasv\n    SV *        imp_class\n    PPCODE:\n    dMY_CXT;\n    HV *outer;\n    SV *outer_ref;\n    HV *class_stash = gv_stashsv(class, GV_ADDWARN);\n\n    if (DBIS_TRACE_LEVEL >= 5) {\n        PerlIO_printf(DBILOGFP, \"    New %s (for %s, parent=%s, id=%s)\\n\",\n            neatsvpv(class,0), SvPV_nolen(imp_class), neatsvpv(parent,0), neatsvpv(imp_datasv,0));\n        PERL_UNUSED_VAR(cv);\n    }\n\n    (void)hv_store((HV*)SvRV(attr_ref), \"ImplementorClass\", 16, SvREFCNT_inc(imp_class), 0);\n\n    /* make attr into inner handle by blessing it into class */\n    sv_bless(attr_ref, class_stash);\n    /* tie new outer hash to inner handle */\n    outer = newHV(); /* create new hash to be outer handle */\n    outer_ref = newRV_noinc((SV*)outer);\n    /* make outer hash into a handle by blessing it into class */\n    sv_bless(outer_ref, class_stash);\n    /* tie outer handle to inner handle */\n    sv_magic((SV*)outer, attr_ref, PERL_MAGIC_tied, Nullch, 0);\n\n    dbih_setup_handle(aTHX_ outer_ref, SvPV_nolen(imp_class), parent, SvOK(imp_datasv) ? imp_datasv : Nullsv);\n\n    /* return outer handle, plus inner handle if not in scalar context */\n    sv_2mortal(outer_ref);\n    EXTEND(SP, 2);\n    PUSHs(outer_ref);\n    if (GIMME != G_SCALAR) {\n        PUSHs(attr_ref);\n    }\n\n\nvoid\n_setup_handle(sv, imp_class, parent, imp_datasv)\n    SV *        sv\n    char *      imp_class\n    SV *        parent\n    SV *        imp_datasv\n    CODE:\n    (void)cv;\n    dbih_setup_handle(aTHX_ sv, imp_class, parent, SvOK(imp_datasv) ? imp_datasv : Nullsv);\n    ST(0) = &PL_sv_undef;\n\n\nvoid\n_get_imp_data(sv)\n    SV *        sv\n    CODE:\n    D_imp_xxh(sv);\n    (void)cv;\n    ST(0) = sv_mortalcopy(DBIc_IMP_DATA(imp_xxh)); /* okay if NULL      */\n\n\nvoid\n_handles(sv)\n    SV *        sv\n    PPCODE:\n    /* return the outer and inner handle for any given handle */\n    D_imp_xxh(sv);\n    SV *ih = sv_mortalcopy( dbih_inner(aTHX_ sv, \"_handles\") );\n    SV *oh = sv_2mortal(newRV_inc((SV*)DBIc_MY_H(imp_xxh))); /* XXX dangerous */\n    (void)cv;\n    EXTEND(SP, 2);\n    PUSHs(oh);  /* returns outer handle then inner */\n    if (GIMME != G_SCALAR) {\n        PUSHs(ih);\n    }\n\n\nvoid\nneat(sv, maxlen=0)\n    SV *        sv\n    U32 maxlen\n    CODE:\n    ST(0) = sv_2mortal(newSVpv(neatsvpv(sv, maxlen), 0));\n    (void)cv;\n\n\nI32\nhash(key, type=0)\n    const char *key\n    long type\n    CODE:\n    (void)cv;\n    RETVAL = dbi_hash(key, type);\n    OUTPUT:\n    RETVAL\n\nvoid\nlooks_like_number(...)\n    PPCODE:\n    int i;\n    EXTEND(SP, items);\n    (void)cv;\n    for(i=0; i < items ; ++i) {\n        SV *sv = ST(i);\n        if (!SvOK(sv) || (SvPOK(sv) && SvCUR(sv)==0))\n            PUSHs(&PL_sv_undef);\n        else if ( looks_like_number(sv) )\n            PUSHs(&PL_sv_yes);\n        else\n            PUSHs(&PL_sv_no);\n    }\n\n\nvoid\n_install_method(dbi_class, meth_name, file, attribs=Nullsv)\n    const char *        dbi_class\n    char *      meth_name\n    char *      file\n    SV *        attribs\n    CODE:\n    {\n    dMY_CXT;\n    /* install another method name/interface for the DBI dispatcher     */\n    SV *trace_msg = (DBIS_TRACE_LEVEL >= 10) ? sv_2mortal(newSVpv(\"\",0)) : Nullsv;\n    CV *cv;\n    SV **svp;\n    dbi_ima_t *ima;\n    MAGIC *mg;\n    (void)dbi_class;\n\n    if (strnNE(meth_name, \"DBI::\", 5))  /* XXX m/^DBI::\\w+::\\w+$/       */\n        croak(\"install_method %s: invalid class\", meth_name);\n\n    if (trace_msg)\n        sv_catpvf(trace_msg, \"install_method %-21s\", meth_name);\n\n    Newxz(ima, 1, dbi_ima_t);\n\n    if (attribs && SvOK(attribs)) {\n        /* convert and store method attributes in a fast access form    */\n        if (SvTYPE(SvRV(attribs)) != SVt_PVHV)\n            croak(\"install_method %s: bad attribs\", meth_name);\n\n        DBD_ATTRIB_GET_IV(attribs, \"O\",1, svp, ima->flags);\n        DBD_ATTRIB_GET_UV(attribs, \"T\",1, svp, ima->method_trace);\n        DBD_ATTRIB_GET_IV(attribs, \"H\",1, svp, ima->hidearg);\n\n        if (trace_msg) {\n            if (ima->flags)       sv_catpvf(trace_msg, \", flags 0x%04x\", (unsigned)ima->flags);\n            if (ima->method_trace)sv_catpvf(trace_msg, \", T 0x%08lx\", (unsigned long)ima->method_trace);\n            if (ima->hidearg)     sv_catpvf(trace_msg, \", H %u\", (unsigned)ima->hidearg);\n        }\n        if ( (svp=DBD_ATTRIB_GET_SVP(attribs, \"U\",1)) != NULL) {\n            AV *av = (AV*)SvRV(*svp);\n            ima->minargs = (U8)SvIV(*av_fetch(av, 0, 1));\n            ima->maxargs = (U8)SvIV(*av_fetch(av, 1, 1));\n            svp = av_fetch(av, 2, 0);\n            ima->usage_msg = (svp) ? savepv_using_sv(SvPV_nolen(*svp)) : \"\";\n            ima->flags |= IMA_HAS_USAGE;\n            if (trace_msg && DBIS_TRACE_LEVEL >= 11)\n                sv_catpvf(trace_msg, \",\\n    usage: min %d, max %d, '%s'\",\n                        ima->minargs, ima->maxargs, ima->usage_msg);\n        }\n    }\n    if (trace_msg)\n        PerlIO_printf(DBILOGFP,\"%s\\n\", SvPV_nolen(trace_msg));\n    file = savepv(file);\n    cv = newXS(meth_name, XS_DBI_dispatch, file);\n    SvPVX((SV *)cv) = file;\n    SvLEN((SV *)cv) = 1;\n    CvXSUBANY(cv).any_ptr = ima;\n    ima->meth_type = get_meth_type(GvNAME(CvGV(cv)));\n\n    /* Attach magic to handle duping and freeing of the dbi_ima_t struct.\n     * Due to the poor interface of the mg dup function, sneak a pointer\n     * to the original CV in the mg_ptr field (we get called with a\n     * pointer to the mg, but not the SV) */\n    mg = sv_magicext((SV*)cv, NULL, DBI_MAGIC, &dbi_ima_vtbl,\n                        (char *)cv, 0);\n#ifdef BROKEN_DUP_ANY_PTR\n    ima->my_perl = my_perl; /* who owns this struct */\n#else\n    mg->mg_flags |= MGf_DUP;\n#endif\n    ST(0) = &PL_sv_yes;\n    }\n\n\nint\ntrace(class, level_sv=&PL_sv_undef, file=Nullsv)\n    SV *        class\n    SV *        level_sv\n    SV *        file\n    ALIAS:\n    _debug_dispatch = 1\n    CODE:\n    {\n    dMY_CXT;\n    IV level;\n    if (!DBIS) {\n        PERL_UNUSED_VAR(ix);\n        croak(\"DBI not initialised\");\n    }\n    /* Return old/current value. No change if new value not given.      */\n    RETVAL = (DBIS) ? DBIS->debug : 0;\n    level = parse_trace_flags(class, level_sv, RETVAL);\n    if (level)          /* call before or after altering DBI trace level */\n        set_trace_file(file);\n    if (level != RETVAL) {\n        if ((level & DBIc_TRACE_LEVEL_MASK) > 0) {\n            PerlIO_printf(DBILOGFP,\"    DBI %s%s default trace level set to 0x%lx/%ld (pid %d pi %p) at %s\\n\",\n                XS_VERSION, dbi_build_opt,\n                (long)(level & DBIc_TRACE_FLAGS_MASK),\n                (long)(level & DBIc_TRACE_LEVEL_MASK),\n                (int)PerlProc_getpid(),\n#ifdef MULTIPLICITY\n                (void *)my_perl,\n#else\n                (void*)NULL,\n#endif\n                log_where(Nullsv, 0, \"\", \"\", 1, 1, 0)\n            );\n            if (!PL_dowarn)\n                PerlIO_printf(DBILOGFP,\"    Note: perl is running without the recommended perl -w option\\n\");\n            PerlIO_flush(DBILOGFP);\n        }\n        DBIS->debug = level;\n        sv_setiv(get_sv(\"DBI::dbi_debug\",0x5), level);\n    }\n    if (!level)         /* call before or after altering DBI trace level */\n        set_trace_file(file);\n    }\n    OUTPUT:\n    RETVAL\n\n\n\nvoid\ndump_handle(sv, msg=\"DBI::dump_handle\", level=0)\n    SV *        sv\n    const char *msg\n    int         level\n    CODE:\n    (void)cv;\n    dbih_dumphandle(aTHX_ sv, msg, level);\n\n\n\nvoid\n_svdump(sv)\n    SV *        sv\n    CODE:\n    {\n    dMY_CXT;\n    (void)cv;\n    PerlIO_printf(DBILOGFP, \"DBI::_svdump(%s)\", neatsvpv(sv,0));\n#ifdef DEBUGGING\n    sv_dump(sv);\n#endif\n    }\n\n\nNV\ndbi_time()\n\n\nvoid\ndbi_profile(h, statement, method, t1, t2)\n    SV *h\n    SV *statement\n    SV *method\n    NV t1\n    NV t2\n    CODE:\n    SV *leaf = &PL_sv_undef;\n    PERL_UNUSED_VAR(cv);\n    if (SvROK(method))\n        method = SvRV(method);\n    if (dbih_inner(aTHX_ h, NULL)) {    /* is a DBI handle */\n        D_imp_xxh(h);\n        leaf = dbi_profile(h, imp_xxh, statement, method, t1, t2);\n    }\n    else if (SvROK(h) && SvTYPE(SvRV(h)) == SVt_PVHV) {\n        /* iterate over values %$h */\n        HV *hv = (HV*)SvRV(h);\n        SV *tmp;\n        char *key;\n        I32 keylen = 0;\n        hv_iterinit(hv);\n        while ( (tmp = hv_iternextsv(hv, &key, &keylen)) != NULL ) {\n            if (SvOK(tmp)) {\n                D_imp_xxh(tmp);\n                leaf = dbi_profile(tmp, imp_xxh, statement, method, t1, t2);\n            }\n        };\n    }\n    else {\n        croak(\"dbi_profile(%s,...) invalid handle argument\", neatsvpv(h,0));\n    }\n    if (GIMME_V == G_VOID)\n        ST(0) = &PL_sv_undef;  /* skip sv_mortalcopy if not needed */\n    else\n        ST(0) = sv_mortalcopy(leaf);\n\n\n\nSV *\ndbi_profile_merge_nodes(dest, ...)\n    SV * dest\n    ALIAS:\n    dbi_profile_merge = 1\n    CODE:\n    {\n        if (!SvROK(dest) || SvTYPE(SvRV(dest)) != SVt_PVAV)\n            croak(\"dbi_profile_merge_nodes(%s,...) destination is not an array reference\", neatsvpv(dest,0));\n        if (items <= 1) {\n            PERL_UNUSED_VAR(cv);\n            PERL_UNUSED_VAR(ix);\n            RETVAL = 0;\n        }\n        else {\n            /* items==2 for dest + 1 arg, ST(0) is dest, ST(1) is first arg */\n            while (--items >= 1) {\n                SV *thingy = ST(items);\n                dbi_profile_merge_nodes(dest, thingy);\n            }\n            RETVAL = newSVsv(*av_fetch((AV*)SvRV(dest), DBIprof_TOTAL_TIME, 1));\n        }\n    }\n    OUTPUT:\n    RETVAL\n\n\nSV *\n_concat_hash_sorted(hash_sv, kv_sep_sv, pair_sep_sv, use_neat_sv, num_sort_sv)\n    SV *hash_sv\n    SV *kv_sep_sv\n    SV *pair_sep_sv\n    SV *use_neat_sv\n    SV *num_sort_sv\n    PREINIT:\n    char *kv_sep, *pair_sep;\n    STRLEN kv_sep_len, pair_sep_len;\n    CODE:\n        if (!SvOK(hash_sv))\n            XSRETURN_UNDEF;\n        if (!SvROK(hash_sv) || SvTYPE(SvRV(hash_sv))!=SVt_PVHV)\n            croak(\"hash is not a hash reference\");\n\n        kv_sep   = SvPV(kv_sep_sv,   kv_sep_len);\n        pair_sep = SvPV(pair_sep_sv, pair_sep_len);\n\n        RETVAL = _join_hash_sorted( (HV*)SvRV(hash_sv),\n            kv_sep,   kv_sep_len,\n            pair_sep, pair_sep_len,\n            /* use_neat should be undef, 0 or 1, may allow sprintf format strings later */\n            (SvOK(use_neat_sv)) ? SvIV(use_neat_sv) :  0,\n            (SvOK(num_sort_sv)) ? SvIV(num_sort_sv) : -1\n        );\n    OUTPUT:\n        RETVAL\n\n\nint\nsql_type_cast(sv, sql_type, flags=0)\n    SV *        sv\n    int         sql_type\n    U32         flags\n    CODE:\n    RETVAL = sql_type_cast_svpv(aTHX_ sv, sql_type, flags, 0);\n    OUTPUT:\n        RETVAL\n\n\n\nMODULE = DBI   PACKAGE = DBI::var\n\nvoid\nFETCH(sv)\n    SV *        sv\n    CODE:\n    dMY_CXT;\n    /* Note that we do not come through the dispatcher to get here.     */\n    char *meth = SvPV_nolen(SvRV(sv));  /* what should this tie do ?    */\n    char type = *meth++;                /* is this a $ or & style       */\n    imp_xxh_t *imp_xxh = (DBI_LAST_HANDLE_OK) ? DBIh_COM(DBI_LAST_HANDLE) : NULL;\n    int trace_level = (imp_xxh ? DBIc_TRACE_LEVEL(imp_xxh) : DBIS_TRACE_LEVEL);\n    NV profile_t1 = 0.0;\n\n    if (imp_xxh && DBIc_has(imp_xxh,DBIcf_Profile))\n        profile_t1 = dbi_time();\n\n    if (trace_level >= 2) {\n        PerlIO_printf(DBILOGFP,\"    -> $DBI::%s (%c) FETCH from lasth=%s\\n\", meth, type,\n                (imp_xxh) ? neatsvpv(DBI_LAST_HANDLE,0): \"none\");\n    }\n\n    if (type == '!') {  /* special case for $DBI::lasth */\n        /* Currently we can only return the INNER handle.       */\n        /* This handle should only be used for true/false tests */\n        ST(0) = (imp_xxh) ? sv_2mortal(newRV_inc(DBI_LAST_HANDLE)) : &PL_sv_undef;\n    }\n    else if ( !imp_xxh ) {\n        if (trace_level)\n            warn(\"Can't read $DBI::%s, last handle unknown or destroyed\", meth);\n        ST(0) = &PL_sv_undef;\n    }\n    else if (type == '*') {     /* special case for $DBI::err, see also err method      */\n        SV *errsv = DBIc_ERR(imp_xxh);\n        ST(0) = sv_mortalcopy(errsv);\n    }\n    else if (type == '\"') {     /* special case for $DBI::state */\n        SV *state = DBIc_STATE(imp_xxh);\n        ST(0) = DBIc_STATE_adjust(imp_xxh, state);\n    }\n    else if (type == '$') { /* lookup scalar variable in implementors stash */\n        const char *vname = mkvname(aTHX_ DBIc_IMP_STASH(imp_xxh), meth, 0);\n        SV *vsv = get_sv(vname, 1);\n        ST(0) = sv_mortalcopy(vsv);\n    }\n    else {\n        /* default to method call via stash of implementor of DBI_LAST_HANDLE */\n        GV *imp_gv;\n        HV *imp_stash = DBIc_IMP_STASH(imp_xxh);\n#ifdef DBI_save_hv_fetch_ent\n        HE save_mh = PL_hv_fetch_ent_mh; /* XXX nested tied FETCH bug17575 workaround */\n#endif\n        profile_t1 = 0.0; /* profile this via dispatch only (else we'll double count) */\n        if (trace_level >= 3)\n            PerlIO_printf(DBILOGFP,\"    >> %s::%s\\n\", HvNAME(imp_stash), meth);\n        ST(0) = sv_2mortal(newRV_inc(DBI_LAST_HANDLE));\n        if ((imp_gv = gv_fetchmethod(imp_stash,meth)) == NULL) {\n            croak(\"Can't locate $DBI::%s object method \\\"%s\\\" via package \\\"%s\\\"\",\n                meth, meth, HvNAME(imp_stash));\n        }\n        PUSHMARK(mark);  /* reset mark (implies one arg as we were called with one arg?) */\n        call_sv((SV*)GvCV(imp_gv), GIMME);\n        SPAGAIN;\n#ifdef DBI_save_hv_fetch_ent\n        PL_hv_fetch_ent_mh = save_mh;\n#endif\n    }\n    if (trace_level)\n        PerlIO_printf(DBILOGFP,\"    <- $DBI::%s= %s\\n\", meth, neatsvpv(ST(0),0));\n    if (profile_t1) {\n        SV *h = sv_2mortal(newRV_inc(DBI_LAST_HANDLE));\n        dbi_profile(h, imp_xxh, &PL_sv_undef, (SV*)cv, profile_t1, dbi_time());\n    }\n\n\nMODULE = DBI   PACKAGE = DBD::_::dr\n\nvoid\ndbixs_revision(h)\n    SV *    h\n    CODE:\n    PERL_UNUSED_VAR(h);\n    ST(0) = sv_2mortal(newSViv(DBIXS_REVISION));\n\n\nMODULE = DBI   PACKAGE = DBD::_::db\n\nvoid\nconnected(...)\n    CODE:\n    /* defined here just to avoid AUTOLOAD */\n    (void)cv;\n    (void)items;\n    ST(0) = &PL_sv_undef;\n\n\nSV *\npreparse(dbh, statement, ps_return, ps_accept, foo=Nullch)\n    SV *        dbh\n    char *      statement\n    IV          ps_return\n    IV          ps_accept\n    void        *foo\n\n\nvoid\ntake_imp_data(h)\n    SV *        h\n    PREINIT:\n    /* take_imp_data currently in DBD::_::db not DBD::_::common, so for dbh's only */\n    D_imp_xxh(h);\n    MAGIC *mg;\n    SV *imp_xxh_sv;\n    SV **tmp_svp;\n    CODE:\n    PERL_UNUSED_VAR(cv);\n    /*\n     * Remove and return the imp_xxh_t structure that's attached to the inner\n     * hash of the handle. Effectively this removes the 'brain' of the handle\n     * leaving it as an empty shell - brain dead. All method calls on it fail.\n     *\n     * The imp_xxh_t structure that's removed and returned is a plain scalar\n     * (containing binary data). It can be passed to a new DBI->connect call\n     * in order to have the new $dbh use the same 'connection' as the original\n     * handle. In this way a multi-threaded connection pool can be implemented.\n     *\n     * If the drivers imp_xxh_t structure contains SV*'s, or other interpreter\n     * specific items, they should be freed by the drivers own take_imp_data()\n     * method before it then calls SUPER::take_imp_data() to finalize removal\n     * of the imp_xxh_t structure.\n     *\n     * The driver needs to view the take_imp_data method as being nearly the\n     * same as disconnect+DESTROY only not actually calling the database API to\n     * disconnect.  All that needs to remain valid in the imp_xxh_t structure\n     * is the underlying database API connection data.  Everything else should\n     * in a 'clean' state such that if the drivers own DESTROY method was\n     * called it would be able to properly handle the contents of the\n     * structure. This is important in case a new handle created using this\n     * imp_data, possibly in a new thread, might end up being DESTROY'd before\n     * the driver has had a chance to 're-setup' the data. See dbih_setup_handle()\n     *\n     * All the above relates to the 'typical use case' for a compiled driver.\n     * For a pure-perl driver using a socket pair, for example, the drivers\n     * take_imp_data method might just return a string containing the fileno()\n     * values of the sockets (without calling this SUPER::take_imp_data() code).\n     * The key point is that the take_imp_data() method returns an opaque buffer\n     * containing whatever the driver would need to reuse the same underlying\n     * 'connection to the database' in a new handle.\n     *\n     * In all cases, care should be taken that driver attributes (such as\n     * AutoCommit) match the state of the underlying connection.\n     */\n\n    if (!DBIc_ACTIVE(imp_xxh)) {/* sanity check, may be relaxed later */\n        set_err_char(h, imp_xxh, \"1\", 1, \"Can't take_imp_data from handle that's not Active\", 0, \"take_imp_data\");\n        XSRETURN(0);\n    }\n\n    /* Ideally there should be no child statement handles existing when\n     * take_imp_data is called because when those statement handles are\n     * destroyed they may need to interact with the 'zombie' parent dbh.\n     * So we do our best to neautralize them (finish & rebless)\n     */\n    if ((tmp_svp = hv_fetch((HV*)SvRV(h), \"ChildHandles\", 12, FALSE)) && SvROK(*tmp_svp)) {\n        AV *av = (AV*)SvRV(*tmp_svp);\n        HV *zombie_stash = gv_stashpv(\"DBI::zombie\", GV_ADDWARN);\n        I32 kidslots;\n        for (kidslots = AvFILL(av); kidslots >= 0; --kidslots) {\n            SV **hp = av_fetch(av, kidslots, FALSE);\n            if (hp && SvROK(*hp) && SvMAGICAL(SvRV(*hp))) {\n                PUSHMARK(sp);\n                XPUSHs(*hp);\n                PUTBACK;\n                call_method(\"finish\", G_VOID);\n                SPAGAIN;\n                PUTBACK;\n                sv_unmagic(SvRV(*hp), 'P'); /* untie */\n                sv_bless(*hp, zombie_stash); /* neutralise */\n            }\n        }\n    }\n    /* The above measures may not be sufficient if weakrefs aren't available\n     * or something has a reference to the inner-handle of an sth.\n     * We'll require no Active kids, but just warn about others.\n     */\n    if (DBIc_ACTIVE_KIDS(imp_xxh)) {\n        set_err_char(h, imp_xxh, \"1\", 1, \"Can't take_imp_data from handle while it still has Active kids\", 0, \"take_imp_data\");\n        XSRETURN(0);\n    }\n    if (DBIc_KIDS(imp_xxh))\n        warn(\"take_imp_data from handle while it still has kids\");\n\n    /* it may be better here to return a copy and poison the original\n     * rather than detatching and returning the original\n     */\n\n    /* --- perform the surgery */\n    dbih_getcom2(aTHX_ h, &mg); /* get the MAGIC so we can change it    */\n    imp_xxh_sv = mg->mg_obj;    /* take local copy of the imp_data pointer */\n    mg->mg_obj = Nullsv;        /* sever the link from handle to imp_xxh */\n    mg->mg_ptr = NULL;          /* and sever the shortcut too */\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 9)\n        sv_dump(imp_xxh_sv);\n    /* --- housekeeping */\n    DBIc_ACTIVE_off(imp_xxh);   /* silence warning from dbih_clearcom */\n    DBIc_IMPSET_off(imp_xxh);   /* silence warning from dbih_clearcom */\n    dbih_clearcom(imp_xxh);     /* free SVs like DBD::_mem::common::DESTROY */\n    SvOBJECT_off(imp_xxh_sv);   /* no longer needs DESTROY via dbih_clearcom */\n    /* restore flags to mark fact imp data holds active connection      */\n    /* (don't use magical DBIc_ACTIVE_on here)                          */\n    DBIc_FLAGS(imp_xxh) |=  DBIcf_IMPSET | DBIcf_ACTIVE;\n    /* --- tidy up the raw PV for life as a more normal string */\n    SvPOK_on(imp_xxh_sv);       /* SvCUR & SvEND were set at creation   */\n    /* --- return the actual imp_xxh_sv on the stack */\n    ST(0) = imp_xxh_sv;\n\n\n\nMODULE = DBI   PACKAGE = DBD::_::st\n\nvoid\n_get_fbav(sth)\n    SV *        sth\n    CODE:\n    D_imp_sth(sth);\n    AV *av = dbih_get_fbav(imp_sth);\n    (void)cv;\n    ST(0) = sv_2mortal(newRV_inc((SV*)av));\n\nvoid\n_set_fbav(sth, src_rv)\n    SV *        sth\n    SV *        src_rv\n    CODE:\n    D_imp_sth(sth);\n    int i;\n    AV *src_av;\n    AV *dst_av = dbih_get_fbav(imp_sth);\n    int dst_fields = AvFILL(dst_av)+1;\n    int src_fields;\n    (void)cv;\n\n    if (!SvROK(src_rv) || SvTYPE(SvRV(src_rv)) != SVt_PVAV)\n        croak(\"_set_fbav(%s): not an array ref\", neatsvpv(src_rv,0));\n    src_av = (AV*)SvRV(src_rv);\n    src_fields = AvFILL(src_av)+1;\n    if (src_fields != dst_fields) {\n        warn(\"_set_fbav(%s): array has %d elements, the statement handle row buffer has %d (and NUM_OF_FIELDS is %d)\",\n                neatsvpv(src_rv,0), src_fields, dst_fields, DBIc_NUM_FIELDS(imp_sth));\n        SvREADONLY_off(dst_av);\n        if (src_fields < dst_fields) {\n            /* shrink the array - sadly this looses column bindings for the lost columns */\n            av_fill(dst_av, src_fields-1);\n            dst_fields = src_fields;\n        }\n        else {\n            av_fill(dst_av, src_fields-1);\n            /* av_fill pads with immutable undefs which we need to change */\n            for(i=dst_fields-1; i < src_fields; ++i) {\n                sv_setsv(AvARRAY(dst_av)[i], newSV(0));\n            }\n        }\n        SvREADONLY_on(dst_av);\n    }\n    for(i=0; i < dst_fields; ++i) {     /* copy over the row    */\n        /* If we're given the values, then taint them if required */\n        if (DBIc_is(imp_sth, DBIcf_TaintOut))\n            SvTAINT(AvARRAY(src_av)[i]);\n        sv_setsv(AvARRAY(dst_av)[i], AvARRAY(src_av)[i]);\n    }\n    ST(0) = sv_2mortal(newRV_inc((SV*)dst_av));\n\n\nvoid\nbind_col(sth, col, ref, attribs=Nullsv)\n    SV *        sth\n    SV *        col\n    SV *        ref\n    SV *        attribs\n    CODE:\n    DBD_ATTRIBS_CHECK(\"bind_col\", sth, attribs);\n    ST(0) = boolSV(dbih_sth_bind_col(sth, col, ref, attribs));\n    (void)cv;\n\n\nvoid\nfetchrow_array(sth)\n    SV *        sth\n    ALIAS:\n    fetchrow = 1\n    PPCODE:\n    SV *retsv;\n    if (CvDEPTH(cv) == 99) {\n        PERL_UNUSED_VAR(ix);\n        croak(\"Deep recursion, probably fetchrow-fetch-fetchrow loop\");\n    }\n    PUSHMARK(sp);\n    XPUSHs(sth);\n    PUTBACK;\n    if (call_method(\"fetch\", G_SCALAR) != 1)\n        croak(\"panic: DBI fetch\");      /* should never happen */\n    SPAGAIN;\n    retsv = POPs;\n    PUTBACK;\n    if (SvROK(retsv) && SvTYPE(SvRV(retsv)) == SVt_PVAV) {\n        D_imp_sth(sth);\n        int num_fields, i;\n        AV *bound_av;\n        AV *av = (AV*)SvRV(retsv);\n        num_fields = AvFILL(av)+1;\n        EXTEND(sp, num_fields+1);\n\n        /* We now check for bind_col() having been called but fetch     */\n        /* not returning the fields_svav array. Probably because the    */\n        /* driver is implemented in perl. XXX This logic may change later.      */\n        bound_av = DBIc_FIELDS_AV(imp_sth); /* bind_col() called ?      */\n        if (bound_av && av != bound_av) {\n            /* let dbih_get_fbav know what's going on   */\n            bound_av = dbih_get_fbav(imp_sth);\n            if (DBIc_TRACE_LEVEL(imp_sth) >= 3) {\n                PerlIO_printf(DBIc_LOGPIO(imp_sth),\n                    \"fetchrow: updating fbav 0x%lx from 0x%lx\\n\",\n                    (long)bound_av, (long)av);\n            }\n            for(i=0; i < num_fields; ++i) {     /* copy over the row    */\n                sv_setsv(AvARRAY(bound_av)[i], AvARRAY(av)[i]);\n            }\n        }\n        for(i=0; i < num_fields; ++i) {\n            PUSHs(AvARRAY(av)[i]);\n        }\n    }\n\n\nSV *\nfetchrow_hashref(sth, keyattrib=Nullch)\n    SV *        sth\n    const char *keyattrib\n    PREINIT:\n    SV *rowavr;\n    SV *ka_rv;\n    D_imp_sth(sth);\n    CODE:\n    (void)cv;\n    PUSHMARK(sp);\n    XPUSHs(sth);\n    PUTBACK;\n    if (!keyattrib || !*keyattrib) {\n        SV *kn = DBIc_FetchHashKeyName(imp_sth);\n        if (kn && SvOK(kn))\n            keyattrib = SvPVX(kn);\n        else\n            keyattrib = \"NAME\";\n    }\n    ka_rv = *hv_fetch((HV*)DBIc_MY_H(imp_sth), keyattrib,strlen(keyattrib), TRUE);\n    /* we copy to invoke FETCH magic, and we do that before fetch() so if tainting */\n    /* then the taint triggered by the fetch won't then apply to the fetched name */\n    ka_rv = newSVsv(ka_rv);\n    if (call_method(\"fetch\", G_SCALAR) != 1)\n        croak(\"panic: DBI fetch\");      /* should never happen */\n    SPAGAIN;\n    rowavr = POPs;\n    PUTBACK;\n    /* have we got an array ref in rowavr */\n    if (SvROK(rowavr) && SvTYPE(SvRV(rowavr)) == SVt_PVAV) {\n        int i;\n        AV *rowav = (AV*)SvRV(rowavr);\n        const int num_fields = AvFILL(rowav)+1;\n        HV *hv;\n        AV *ka_av;\n        if (!(SvROK(ka_rv) && SvTYPE(SvRV(ka_rv))==SVt_PVAV)) {\n            sv_setiv(DBIc_ERR(imp_sth), 1);\n            sv_setpvf(DBIc_ERRSTR(imp_sth),\n                \"Can't use attribute '%s' because it doesn't contain a reference to an array (%s)\",\n                keyattrib, neatsvpv(ka_rv,0));\n            XSRETURN_UNDEF;\n        }\n        ka_av = (AV*)SvRV(ka_rv);\n        hv    = newHV();\n        for (i=0; i < num_fields; ++i) {        /* honor the original order as sent by the database */\n            SV  **field_name_svp = av_fetch(ka_av, i, 1);\n            (void)hv_store_ent(hv, *field_name_svp, newSVsv((SV*)(AvARRAY(rowav)[i])), 0);\n        }\n        RETVAL = newRV_inc((SV*)hv);\n        SvREFCNT_dec(hv);       /* since newRV incremented it   */\n    }\n    else {\n        RETVAL = &PL_sv_undef;\n#if (PERL_VERSION < 4) || ((PERL_VERSION == 4) && (PERL_SUBVERSION <= 4))\n        RETVAL = newSV(0); /* mutable undef for 5.004_04 */\n#endif\n    }\n    SvREFCNT_dec(ka_rv);        /* since we created it          */\n    OUTPUT:\n    RETVAL\n\n\nvoid\nfetch(sth)\n    SV *        sth\n    ALIAS:\n    fetchrow_arrayref = 1\n    CODE:\n    int num_fields;\n    if (CvDEPTH(cv) == 99) {\n        PERL_UNUSED_VAR(ix);\n        croak(\"Deep recursion. Probably fetch-fetchrow-fetch loop.\");\n    }\n    PUSHMARK(sp);\n    XPUSHs(sth);\n    PUTBACK;\n    num_fields = call_method(\"fetchrow\", G_ARRAY);      /* XXX change the name later */\n    SPAGAIN;\n    if (num_fields == 0) {\n        ST(0) = &PL_sv_undef;\n    } else {\n        D_imp_sth(sth);\n        AV *av = dbih_get_fbav(imp_sth);\n        if (num_fields != AvFILL(av)+1)\n            croak(\"fetchrow returned %d fields, expected %d\",\n                    num_fields, (int)AvFILL(av)+1);\n        SPAGAIN;\n        while(--num_fields >= 0)\n            sv_setsv(AvARRAY(av)[num_fields], POPs);\n        PUTBACK;\n        ST(0) = sv_2mortal(newRV_inc((SV*)av));\n    }\n\n\nvoid\nrows(sth)\n    SV *        sth\n    CODE:\n    D_imp_sth(sth);\n    const IV rows = DBIc_ROW_COUNT(imp_sth);\n    ST(0) = sv_2mortal(newSViv(rows));\n    (void)cv;\n\n\nvoid\nfinish(sth)\n    SV *        sth\n    CODE:\n    D_imp_sth(sth);\n    DBIc_ACTIVE_off(imp_sth);\n    ST(0) = &PL_sv_yes;\n    (void)cv;\n\n\nvoid\nDESTROY(sth)\n    SV *        sth\n    PPCODE:\n    /* keep in sync with DESTROY in Driver.xst */\n    D_imp_sth(sth);\n    ST(0) = &PL_sv_yes;\n    /* we don't test IMPSET here because this code applies to pure-perl drivers */\n    if (DBIc_IADESTROY(imp_sth)) { /* want's ineffective destroy    */\n        DBIc_ACTIVE_off(imp_sth);\n        if (DBIc_TRACE_LEVEL(imp_sth))\n                PerlIO_printf(DBIc_LOGPIO(imp_sth), \"         DESTROY %s skipped due to InactiveDestroy\\n\", SvPV_nolen(sth));\n    }\n    if (DBIc_ACTIVE(imp_sth)) {\n        D_imp_dbh_from_sth;\n        if (!PL_dirty && DBIc_ACTIVE(imp_dbh)) {\n            dSP;\n            PUSHMARK(sp);\n            XPUSHs(sth);\n            PUTBACK;\n            call_method(\"finish\", G_SCALAR);\n            SPAGAIN;\n            PUTBACK;\n        }\n        else {\n            DBIc_ACTIVE_off(imp_sth);\n        }\n    }\n\n\nMODULE = DBI   PACKAGE = DBI::st\n\nvoid\nTIEHASH(class, inner_ref)\n    SV * class\n    SV * inner_ref\n    CODE:\n    HV *stash = gv_stashsv(class, GV_ADDWARN); /* a new hash is supplied to us, we just need to bless and apply tie magic */\n    sv_bless(inner_ref, stash);\n    ST(0) = inner_ref;\n\nMODULE = DBI   PACKAGE = DBD::_::common\n\n\nvoid\nDESTROY(h)\n    SV * h\n    CODE:\n    /* DESTROY defined here just to avoid AUTOLOAD */\n    (void)cv;\n    (void)h;\n    ST(0) = &PL_sv_undef;\n\n\nvoid\nSTORE(h, keysv, valuesv)\n    SV *        h\n    SV *        keysv\n    SV *        valuesv\n    CODE:\n    ST(0) = &PL_sv_yes;\n    if (!dbih_set_attr_k(h, keysv, 0, valuesv))\n            ST(0) = &PL_sv_no;\n    (void)cv;\n\n\nvoid\nFETCH(h, keysv)\n    SV *        h\n    SV *        keysv\n    CODE:\n    ST(0) = dbih_get_attr_k(h, keysv, 0);\n    (void)cv;\n\nvoid\nDELETE(h, keysv)\n    SV *        h\n    SV *        keysv\n    CODE:\n    /* only private_* keys can be deleted, for others DELETE acts like FETCH */\n    /* because the DBI internals rely on certain handle attributes existing  */\n    if (strnEQ(SvPV_nolen(keysv),\"private_\",8))\n        ST(0) = hv_delete_ent((HV*)SvRV(h), keysv, 0, 0);\n    else\n        ST(0) = dbih_get_attr_k(h, keysv, 0);\n    (void)cv;\n\n\nvoid\nprivate_data(h)\n    SV *        h\n    CODE:\n    D_imp_xxh(h);\n    (void)cv;\n    ST(0) = sv_mortalcopy(DBIc_IMP_DATA(imp_xxh));\n\n\nvoid\nerr(h)\n    SV * h\n    CODE:\n    D_imp_xxh(h);\n    SV *errsv = DBIc_ERR(imp_xxh);\n    (void)cv;\n    ST(0) = sv_mortalcopy(errsv);\n\nvoid\nstate(h)\n    SV * h\n    CODE:\n    D_imp_xxh(h);\n    SV *state = DBIc_STATE(imp_xxh);\n    (void)cv;\n    ST(0) = DBIc_STATE_adjust(imp_xxh, state);\n\nvoid\nerrstr(h)\n    SV *    h\n    CODE:\n    D_imp_xxh(h);\n    SV *errstr = DBIc_ERRSTR(imp_xxh);\n    SV *err;\n    /* If there's no errstr but there is an err then use err */\n    (void)cv;\n    if (!SvTRUE(errstr) && (err=DBIc_ERR(imp_xxh)) && SvTRUE(err))\n            errstr = err;\n    ST(0) = sv_mortalcopy(errstr);\n\n\nvoid\nset_err(h, err, errstr=&PL_sv_no, state=&PL_sv_undef, method=&PL_sv_undef, result=Nullsv)\n    SV *        h\n    SV *        err\n    SV *        errstr\n    SV *        state\n    SV *        method\n    SV *        result\n    PPCODE:\n    {\n    D_imp_xxh(h);\n    SV **sem_svp;\n    (void)cv;\n\n    if (DBIc_has(imp_xxh, DBIcf_HandleSetErr) && SvREADONLY(method))\n        method = sv_mortalcopy(method); /* HandleSetErr may want to change it */\n\n    if (!set_err_sv(h, imp_xxh, err, errstr, state, method)) {\n        /* set_err was canceled by HandleSetErr,                */\n        /* don't set \"dbi_set_err_method\", return an empty list */\n    }\n    else {\n        /* store provided method name so handler code can find it */\n        sem_svp = hv_fetch((HV*)SvRV(h), \"dbi_set_err_method\", 18, 1);\n        if (SvOK(method)) {\n            sv_setpv(*sem_svp, SvPV_nolen(method));\n        }\n        else\n            (void)SvOK_off(*sem_svp);\n        EXTEND(SP, 1);\n        PUSHs( result ? result : &PL_sv_undef );\n    }\n    /* We don't check RaiseError and call die here because that must be */\n    /* done by returning through dispatch and letting the DBI handle it */\n    }\n\n\nint\ntrace(h, level=&PL_sv_undef, file=Nullsv)\n    SV *h\n    SV *level\n    SV *file\n    ALIAS:\n    debug = 1\n    CODE:\n    RETVAL = set_trace(h, level, file);\n    (void)cv; /* Unused variables */\n    (void)ix;\n    OUTPUT:\n    RETVAL\n\n\nvoid\ntrace_msg(sv, msg, this_trace=1)\n    SV *sv\n    const char *msg\n    int this_trace\n    PREINIT:\n    int current_trace;\n    PerlIO *pio;\n    CODE:\n    {\n    dMY_CXT;\n    (void)cv;\n    if (SvROK(sv)) {\n        D_imp_xxh(sv);\n        current_trace = DBIc_TRACE_LEVEL(imp_xxh);\n        pio = DBIc_LOGPIO(imp_xxh);\n    }\n    else {      /* called as a static method */\n        current_trace = DBIS_TRACE_FLAGS;\n        pio = DBILOGFP;\n    }\n    if (DBIc_TRACE_MATCHES(this_trace, current_trace)) {\n        PerlIO_puts(pio, msg);\n        ST(0) = &PL_sv_yes;\n    }\n    else {\n        ST(0) = &PL_sv_no;\n    }\n    }\n\n\nvoid\nrows(h)\n    SV *        h\n    CODE:\n    /* fallback esp for $DBI::rows after $drh was last used */\n    ST(0) = sv_2mortal(newSViv(-1));\n    (void)h;\n    (void)cv;\n\n\nvoid\nswap_inner_handle(rh1, rh2, allow_reparent=0)\n    SV *        rh1\n    SV *        rh2\n    IV  allow_reparent\n    CODE:\n    {\n    D_impdata(imp_xxh1, imp_xxh_t, rh1);\n    D_impdata(imp_xxh2, imp_xxh_t, rh2);\n    SV *h1i = dbih_inner(aTHX_ rh1, \"swap_inner_handle\");\n    SV *h2i = dbih_inner(aTHX_ rh2, \"swap_inner_handle\");\n    SV *h1  = (rh1 == h1i) ? (SV*)DBIc_MY_H(imp_xxh1) : SvRV(rh1);\n    SV *h2  = (rh2 == h2i) ? (SV*)DBIc_MY_H(imp_xxh2) : SvRV(rh2);\n    (void)cv;\n\n    if (DBIc_TYPE(imp_xxh1) != DBIc_TYPE(imp_xxh2)) {\n        char buf[99];\n        sprintf(buf, \"Can't swap_inner_handle between %sh and %sh\",\n            dbih_htype_name(DBIc_TYPE(imp_xxh1)), dbih_htype_name(DBIc_TYPE(imp_xxh2)));\n        DBIh_SET_ERR_CHAR(rh1, imp_xxh1, \"1\", 1, buf, Nullch, Nullch);\n        XSRETURN_NO;\n    }\n    if (!allow_reparent && DBIc_PARENT_COM(imp_xxh1) != DBIc_PARENT_COM(imp_xxh2)) {\n        DBIh_SET_ERR_CHAR(rh1, imp_xxh1, \"1\", 1,\n            \"Can't swap_inner_handle with handle from different parent\",\n            Nullch, Nullch);\n        XSRETURN_NO;\n    }\n\n    (void)SvREFCNT_inc(h1i);\n    (void)SvREFCNT_inc(h2i);\n\n    sv_unmagic(h1, 'P');                /* untie(%$h1)          */\n    sv_unmagic(h2, 'P');                /* untie(%$h2)          */\n\n    sv_magic(h1, h2i, 'P', Nullch, 0);  /* tie %$h1, $h2i       */\n    DBIc_MY_H(imp_xxh2) = (HV*)h1;\n\n    sv_magic(h2, h1i, 'P', Nullch, 0);  /* tie %$h2, $h1i       */\n    DBIc_MY_H(imp_xxh1) = (HV*)h2;\n\n    SvREFCNT_dec(h1i);\n    SvREFCNT_dec(h2i);\n\n    ST(0) = &PL_sv_yes;\n    }\n\n\nMODULE = DBI   PACKAGE = DBD::_mem::common\n\nvoid\nDESTROY(imp_xxh_rv)\n    SV *        imp_xxh_rv\n    CODE:\n    /* ignore 'cast increases required alignment' warning       */\n    imp_xxh_t *imp_xxh = (imp_xxh_t*)SvPVX(SvRV(imp_xxh_rv));\n    DBIc_DBISTATE(imp_xxh)->clearcom(imp_xxh);\n    (void)cv;\n\n# end\n"], "fixing_code": ["/* vim: ts=8:sw=4:expandtab\n *\n * $Id$\n *\n * Copyright (c) 1994-2012  Tim Bunce  Ireland.\n *\n * See COPYRIGHT section in DBI.pm for usage and distribution rights.\n */\n\n#define IN_DBI_XS 1     /* see DBIXS.h */\n#define PERL_NO_GET_CONTEXT\n\n#include \"DBIXS.h\"      /* DBI public interface for DBD's written in C  */\n\n# if (defined(_WIN32) && (! defined(HAS_GETTIMEOFDAY)))\n#include <sys/timeb.h>\n# endif\n\n/* The XS dispatcher code can optimize calls to XS driver methods,\n * bypassing the usual call_sv() and argument handling overheads.\n * Just-in-case it causes problems there's an (undocumented) way\n * to disable it by setting an env var.\n */\nstatic int use_xsbypass = 1; /* set in dbi_bootinit() */\n\n#ifndef CvISXSUB\n#define CvISXSUB(sv) CvXSUB(sv)\n#endif\n\n#define DBI_MAGIC '~'\n\n/* HvMROMETA introduced in 5.9.5, but mro_meta_init not exported in 5.10.0 */\n#if (PERL_VERSION < 10)\n#  define MY_cache_gen(stash) 0\n#else\n#  if ((PERL_VERSION == 10) && (PERL_SUBVERSION == 0))\n#    define MY_cache_gen(stash) \\\n        (HvAUX(stash)->xhv_mro_meta \\\n        ? HvAUX(stash)->xhv_mro_meta->cache_gen \\\n        : 0)\n#  else\n#    define MY_cache_gen(stash) HvMROMETA(stash)->cache_gen\n#  endif\n#endif\n\n/* If the tests fail with errors about 'setlinebuf' then try    */\n/* deleting the lines in the block below except the setvbuf one */\n#ifndef PerlIO_setlinebuf\n#ifdef HAS_SETLINEBUF\n#define PerlIO_setlinebuf(f)        setlinebuf(f)\n#else\n#ifndef USE_PERLIO\n#define PerlIO_setlinebuf(f)        setvbuf(f, Nullch, _IOLBF, 0)\n#endif\n#endif\n#endif\n\n#if (PERL_VERSION < 8) || ((PERL_VERSION == 8) && (PERL_SUBVERSION == 0))\n#define DBI_save_hv_fetch_ent\n#endif\n\n/* prior to 5.8.9: when a CV is duped, the mg dup method is called,\n * then *afterwards*, any_ptr is copied from the old CV to the new CV.\n * This wipes out anything which the dup method did to any_ptr.\n * This needs working around */\n#if defined(USE_ITHREADS) && (PERL_VERSION == 8) && (PERL_SUBVERSION < 9)\n#  define BROKEN_DUP_ANY_PTR\n#endif\n\n/* types of method name */\n\ntypedef enum {\n    methtype_ordinary, /* nothing special about this method name */\n    methtype_DESTROY,\n    methtype_FETCH,\n    methtype_can,\n    methtype_fetch_star, /* fetch*, i.e. fetch() or fetch_...() */\n    methtype_set_err\n} meth_types;\n\n\nstatic imp_xxh_t *dbih_getcom      _((SV *h));\nstatic imp_xxh_t *dbih_getcom2     _((pTHX_ SV *h, MAGIC **mgp));\nstatic void       dbih_clearcom    _((imp_xxh_t *imp_xxh));\nstatic int        dbih_logmsg      _((imp_xxh_t *imp_xxh, const char *fmt, ...));\nstatic SV        *dbih_make_com    _((SV *parent_h, imp_xxh_t *p_imp_xxh, const char *imp_class, STRLEN imp_size, STRLEN extra, SV *copy));\nstatic SV        *dbih_make_fdsv   _((SV *sth, const char *imp_class, STRLEN imp_size, const char *col_name));\nstatic AV        *dbih_get_fbav    _((imp_sth_t *imp_sth));\nstatic SV        *dbih_event       _((SV *h, const char *name, SV*, SV*));\nstatic int        dbih_set_attr_k  _((SV *h, SV *keysv, int dbikey, SV *valuesv));\nstatic SV        *dbih_get_attr_k  _((SV *h, SV *keysv, int dbikey));\nstatic int       dbih_sth_bind_col _((SV *sth, SV *col, SV *ref, SV *attribs));\n\nstatic int      set_err_char _((SV *h, imp_xxh_t *imp_xxh, const char *err_c, IV err_i, const char *errstr, const char *state, const char *method));\nstatic int      set_err_sv   _((SV *h, imp_xxh_t *imp_xxh, SV *err, SV *errstr, SV *state, SV *method));\nstatic int      quote_type _((int sql_type, int p, int s, int *base_type, void *v));\nstatic int      sql_type_cast_svpv _((pTHX_ SV *sv, int sql_type, U32 flags, void *v));\nstatic I32      dbi_hash _((const char *string, long i));\nstatic void     dbih_dumphandle _((pTHX_ SV *h, const char *msg, int level));\nstatic int      dbih_dumpcom _((pTHX_ imp_xxh_t *imp_xxh, const char *msg, int level));\nstatic int      dbi_ima_free(pTHX_ SV* sv, MAGIC* mg);\n#if defined(USE_ITHREADS) && !defined(BROKEN_DUP_ANY_PTR)\nstatic int      dbi_ima_dup(pTHX_ MAGIC* mg, CLONE_PARAMS *param);\n#endif\nchar *neatsvpv _((SV *sv, STRLEN maxlen));\nSV * preparse(SV *dbh, const char *statement, IV ps_return, IV ps_accept, void *foo);\nstatic meth_types get_meth_type(const char * const name);\n\nstruct imp_drh_st { dbih_drc_t com; };\nstruct imp_dbh_st { dbih_dbc_t com; };\nstruct imp_sth_st { dbih_stc_t com; };\nstruct imp_fdh_st { dbih_fdc_t com; };\n\n/* identify the type of a method name for dispatch behaviour */\n/* (should probably be folded into the IMA flags mechanism)  */\n\nstatic meth_types\nget_meth_type(const char * const name)\n{\n    switch (name[0]) {\n    case 'D':\n        if strEQ(name,\"DESTROY\")\n            return methtype_DESTROY;\n        break;\n    case 'F':\n        if strEQ(name,\"FETCH\")\n            return methtype_FETCH;\n        break;\n    case 'c':\n        if strEQ(name,\"can\")\n            return methtype_can;\n        break;\n    case 'f':\n        if strnEQ(name,\"fetch\", 5) /* fetch* */\n            return methtype_fetch_star;\n        break;\n    case 's':\n        if strEQ(name,\"set_err\")\n            return methtype_set_err;\n        break;\n    }\n    return methtype_ordinary;\n}\n\n\n/* Internal Method Attributes (attached to dispatch methods when installed) */\n/* NOTE: when adding SVs to dbi_ima_t, update dbi_ima_dup() dbi_ima_free()\n * to ensure that they are duped and correctly ref-counted */\n\ntypedef struct dbi_ima_st {\n    U8 minargs;\n    U8 maxargs;\n    IV hidearg;\n    /* method_trace controls tracing of method calls in the dispatcher:\n    - if the current trace flags include a trace flag in method_trace\n    then set trace_level to min(2,trace_level) for duration of the call.\n    - else, if trace_level < (method_trace & DBIc_TRACE_LEVEL_MASK)\n    then don't trace the call\n    */\n    U32 method_trace;\n    const char *usage_msg;\n    U32 flags;\n    meth_types meth_type;\n\n    /* cached outer to inner method mapping */\n    HV *stash;          /* the stash we found the GV in */\n    GV *gv;             /* the GV containing the inner sub */\n    U32 generation;     /* cache invalidation */\n#ifdef BROKEN_DUP_ANY_PTR\n    PerlInterpreter *my_perl; /* who owns this struct */\n#endif\n\n} dbi_ima_t;\n\n/* These values are embedded in the data passed to install_method       */\n#define IMA_HAS_USAGE             0x00000001  /* check parameter usage        */\n#define IMA_FUNC_REDIRECT         0x00000002  /* is $h->func(..., \"method\")   */\n#define IMA_KEEP_ERR              0x00000004  /* don't reset err & errstr     */\n#define IMA_KEEP_ERR_SUB          0x00000008  /*  '' if in a nested call      */\n#define IMA_NO_TAINT_IN           0x00000010  /* don't check for PL_tainted args */\n#define IMA_NO_TAINT_OUT          0x00000020  /* don't taint results          */\n#define IMA_COPY_UP_STMT          0x00000040  /* copy sth Statement to dbh    */\n#define IMA_END_WORK              0x00000080  /* method is commit or rollback */\n#define IMA_STUB                  0x00000100  /* donothing eg $dbh->connected */\n#define IMA_CLEAR_STMT            0x00000200  /* clear Statement before call  */\n#define IMA_UNRELATED_TO_STMT     0x00000400  /* profile as empty Statement   */\n#define IMA_NOT_FOUND_OKAY        0x00000800  /* no error if not found        */\n#define IMA_EXECUTE               0x00001000  /* do/execute: DBIcf_Executed   */\n#define IMA_SHOW_ERR_STMT         0x00002000  /* dbh meth relates to Statement*/\n#define IMA_HIDE_ERR_PARAMVALUES  0x00004000  /* ParamValues are not relevant */\n#define IMA_IS_FACTORY            0x00008000  /* new h ie connect and prepare */\n#define IMA_CLEAR_CACHED_KIDS     0x00010000  /* clear CachedKids before call */\n\n#define DBIc_STATE_adjust(imp_xxh, state)                                \\\n    (SvOK(state)        /* SQLSTATE is implemented by driver   */        \\\n        ? (strEQ(SvPV_nolen(state),\"00000\") ? &PL_sv_no : sv_mortalcopy(state))\\\n        : (SvTRUE(DBIc_ERR(imp_xxh))                                     \\\n            ? sv_2mortal(newSVpv(\"S1000\",5)) /* General error   */       \\\n            : &PL_sv_no)                /* Success (\"00000\")    */       \\\n    )\n\n#define DBI_LAST_HANDLE         g_dbi_last_h /* special fake inner handle */\n#define DBI_IS_LAST_HANDLE(h)   ((DBI_LAST_HANDLE) == SvRV(h))\n#define DBI_SET_LAST_HANDLE(h)  ((DBI_LAST_HANDLE) =  SvRV(h))\n#define DBI_UNSET_LAST_HANDLE   ((DBI_LAST_HANDLE) =  &PL_sv_undef)\n#define DBI_LAST_HANDLE_OK      ((DBI_LAST_HANDLE) != &PL_sv_undef)\n\n#define DBIS_TRACE_LEVEL        (DBIS->debug & DBIc_TRACE_LEVEL_MASK)\n#define DBIS_TRACE_FLAGS        (DBIS->debug)   /* includes level */\n\n#ifdef PERL_LONG_MAX\n#define MAX_LongReadLen PERL_LONG_MAX\n#else\n#define MAX_LongReadLen 2147483647L\n#endif\n\n#ifdef DBI_USE_THREADS\nstatic char *dbi_build_opt = \"-ithread\";\n#else\nstatic char *dbi_build_opt = \"-nothread\";\n#endif\n\n/* 32 bit magic FNV-0 and FNV-1 prime */\n#define FNV_32_PRIME ((UV)0x01000193)\n\n\n/* perl doesn't know anything about the dbi_ima_t struct attached to the\n * CvXSUBANY(cv).any_ptr slot, so add some magic to the CV to handle\n * duping and freeing.\n */\n\nstatic MGVTBL dbi_ima_vtbl = { 0, 0, 0, 0, dbi_ima_free,\n                                    0,\n#if defined(USE_ITHREADS) && !defined(BROKEN_DUP_ANY_PTR)\n                                    dbi_ima_dup\n#else\n                                    0\n#endif\n#if (PERL_VERSION > 8) || ((PERL_VERSION == 8) && (PERL_SUBVERSION >= 9))\n                                    , 0\n#endif\n                                    };\n\nstatic int dbi_ima_free(pTHX_ SV* sv, MAGIC* mg)\n{\n    dbi_ima_t *ima = (dbi_ima_t *)(CvXSUBANY((CV*)sv).any_ptr);\n#ifdef BROKEN_DUP_ANY_PTR\n    if (ima->my_perl != my_perl)\n        return 0;\n#endif\n    SvREFCNT_dec(ima->stash);\n    SvREFCNT_dec(ima->gv);\n    Safefree(ima);\n    return 0;\n}\n\n#if defined(USE_ITHREADS) && !defined(BROKEN_DUP_ANY_PTR)\nstatic int dbi_ima_dup(pTHX_ MAGIC* mg, CLONE_PARAMS *param)\n{\n    dbi_ima_t *ima, *nima;\n    CV *cv  = (CV*) mg->mg_ptr;\n    CV *ncv = (CV*)ptr_table_fetch(PL_ptr_table, (cv));\n\n    PERL_UNUSED_VAR(param);\n    mg->mg_ptr = (char *)ncv;\n    ima = (dbi_ima_t*) CvXSUBANY(cv).any_ptr;\n    Newx(nima, 1, dbi_ima_t);\n    *nima = *ima; /* structure copy */\n    CvXSUBANY(ncv).any_ptr = nima;\n    nima->stash = NULL;\n    nima->gv    = NULL;\n    return 0;\n}\n#endif\n\n\n\n/* --- make DBI safe for multiple perl interpreters --- */\n/*     Originally contributed by Murray Nesbitt of ActiveState, */\n/*     but later updated to use MY_CTX */\n\n#define MY_CXT_KEY \"DBI::_guts\" XS_VERSION\n\ntypedef struct {\n    SV   *dbi_last_h;  /* maybe better moved into dbistate_t? */\n    dbistate_t* dbi_state;\n} my_cxt_t;\n\nSTART_MY_CXT\n\n#undef DBIS\n#define DBIS                   (MY_CXT.dbi_state)\n\n#define g_dbi_last_h            (MY_CXT.dbi_last_h)\n\n/* allow the 'static' dbi_state struct to be accessed from other files */\ndbistate_t**\n_dbi_state_lval(pTHX)\n{\n    dMY_CXT;\n    return &(MY_CXT.dbi_state);\n}\n\n\n/* --- */\n\nstatic void *\nmalloc_using_sv(STRLEN len)\n{\n    dTHX;\n    SV *sv = newSV(len ? len : 1);\n    void *p = SvPVX(sv);\n    memzero(p, len);\n    return p;\n}\n\nstatic char *\nsavepv_using_sv(char *str)\n{\n    char *buf = malloc_using_sv(strlen(str));\n    strcpy(buf, str);\n    return buf;\n}\n\n\n/* --- support functions for concat_hash_sorted --- */\n\ntypedef struct str_uv_sort_pair_st {\n    char *key;\n    UV numeric;\n} str_uv_sort_pair_t;\n\nstatic int\n_cmp_number(const void *val1, const void *val2)\n{\n    UV first  = ((str_uv_sort_pair_t *)val1)->numeric;\n    UV second = ((str_uv_sort_pair_t *)val2)->numeric;\n\n    if (first > second)\n        return 1;\n    if (first < second)\n        return -1;\n    /* only likely to reach here if numeric sort forced for non-numeric keys */\n    /* fallback to comparing the key strings */\n    return strcmp(\n        ((str_uv_sort_pair_t *)val1)->key,\n        ((str_uv_sort_pair_t *)val2)->key\n    );\n}\n\nstatic int \n_cmp_str (const void *val1, const void *val2)\n{\n    return strcmp( *(char **)val1, *(char **)val2);\n}\n\nstatic char **\n_sort_hash_keys (HV *hash, int num_sort, STRLEN *total_length)\n{\n    dTHX;\n    I32 hv_len, key_len;\n    HE *entry;\n    char **keys;\n    unsigned int idx = 0;\n    STRLEN tot_len = 0;\n    bool has_non_numerics = 0;\n    str_uv_sort_pair_t *numbers;\n\n    hv_len = hv_iterinit(hash);\n    if (!hv_len)\n        return 0;\n\n    Newz(0, keys,    hv_len, char *);\n    Newz(0, numbers, hv_len, str_uv_sort_pair_t);\n\n    while ((entry = hv_iternext(hash))) {\n        *(keys+idx) = hv_iterkey(entry, &key_len);\n        tot_len += key_len;\n        \n        if (grok_number(*(keys+idx), key_len, &(numbers+idx)->numeric) != IS_NUMBER_IN_UV) {\n            has_non_numerics = 1;\n            (numbers+idx)->numeric = 0;\n        }\n\n        (numbers+idx)->key = *(keys+idx);\n        ++idx;\n    }\n\n    if (total_length)\n        *total_length = tot_len;\n\n    if (num_sort < 0)\n        num_sort = (has_non_numerics) ? 0 : 1;\n\n    if (!num_sort) {\n        qsort(keys, hv_len, sizeof(char*), _cmp_str);\n    }\n    else {\n        qsort(numbers, hv_len, sizeof(str_uv_sort_pair_t), _cmp_number);\n        for (idx = 0; idx < hv_len; ++idx)\n            *(keys+idx) = (numbers+idx)->key;\n    }\n\n    Safefree(numbers);\n    return keys;\n}\n\n\nstatic SV *\n_join_hash_sorted(HV *hash, char *kv_sep, STRLEN kv_sep_len, char *pair_sep, STRLEN pair_sep_len, int use_neat, int num_sort)\n{\n        dTHX;\n        I32 hv_len;\n        STRLEN total_len = 0;\n        char **keys;\n        unsigned int i = 0;\n        SV *return_sv;\n\n        keys = _sort_hash_keys(hash, num_sort, &total_len);\n        if (!keys)\n            return newSVpv(\"\", 0);\n\n        if (!kv_sep_len)\n            kv_sep_len = strlen(kv_sep);\n        if (!pair_sep_len)\n            pair_sep_len = strlen(pair_sep);\n\n        hv_len = hv_iterinit(hash);\n        /* total_len += Separators + quotes + term null */\n        total_len += kv_sep_len*hv_len + pair_sep_len*hv_len+2*hv_len+1;\n        return_sv = newSV(total_len);\n        sv_setpv(return_sv, \"\"); /* quell undef warnings */\n\n        for (i=0; i<hv_len; ++i) {\n            SV **hash_svp = hv_fetch(hash, keys[i], strlen(keys[i]), 0);\n\n            sv_catpv(return_sv, keys[i]); /* XXX keys can't contain nul chars */\n            sv_catpvn(return_sv, kv_sep, kv_sep_len);\n\n            if (!hash_svp) {    /* should never happen */\n                warn(\"No hash entry with key '%s'\", keys[i]);\n                sv_catpvn(return_sv, \"???\", 3);\n                continue;\n            }\n\n            if (use_neat) {\n                sv_catpv(return_sv, neatsvpv(*hash_svp,0));\n            }\n            else {\n                if (SvOK(*hash_svp)) {\n                     STRLEN hv_val_len;\n                     char *hv_val = SvPV(*hash_svp, hv_val_len);\n                     sv_catpvn(return_sv, \"'\", 1);\n                     sv_catpvn(return_sv, hv_val, hv_val_len);\n                     sv_catpvn(return_sv, \"'\", 1);\n                }\n                else sv_catpvn(return_sv, \"undef\", 5);\n            }\n\n            if (i < hv_len-1)\n                sv_catpvn(return_sv, pair_sep, pair_sep_len);\n        }\n\n        Safefree(keys);\n\n        return return_sv;\n}\n\n\n\n/* handy for embedding into condition expression for debugging */\n/*\nstatic int warn1(char *s) { warn(\"%s\", s); return 1; }\nstatic int dump1(SV *sv)  { dTHX; sv_dump(sv); return 1; }\n*/\n\n\n/* --- */\n\nstatic void\ncheck_version(const char *name, int dbis_cv, int dbis_cs, int need_dbixs_cv, int drc_s,\n        int dbc_s, int stc_s, int fdc_s)\n{\n    dTHX;\n    dMY_CXT;\n    static const char msg[] = \"you probably need to rebuild the DBD driver (or possibly the DBI)\";\n    (void)need_dbixs_cv;\n    if (dbis_cv != DBISTATE_VERSION || dbis_cs != sizeof(*DBIS))\n        croak(\"DBI/DBD internal version mismatch (DBI is v%d/s%lu, DBD %s expected v%d/s%d) %s.\\n\",\n            DBISTATE_VERSION, (long unsigned int)sizeof(*DBIS), name, dbis_cv, dbis_cs, msg);\n    /* Catch structure size changes - We should probably force a recompile if the DBI   */\n    /* runtime version is different from the build time. That would be harsh but safe.  */\n    if (drc_s != sizeof(dbih_drc_t) || dbc_s != sizeof(dbih_dbc_t) ||\n        stc_s != sizeof(dbih_stc_t) || fdc_s != sizeof(dbih_fdc_t) )\n            croak(\"%s (dr:%d/%ld, db:%d/%ld, st:%d/%ld, fd:%d/%ld), %s.\\n\",\n                \"DBI/DBD internal structure mismatch\",\n                drc_s, (long)sizeof(dbih_drc_t), dbc_s, (long)sizeof(dbih_dbc_t),\n                stc_s, (long)sizeof(dbih_stc_t), fdc_s, (long)sizeof(dbih_fdc_t), msg);\n}\n\nstatic void\ndbi_bootinit(dbistate_t * parent_dbis)\n{\n    dTHX;\n    dMY_CXT;\n    dbistate_t* DBISx;\n\n    DBISx = (struct dbistate_st*)malloc_using_sv(sizeof(struct dbistate_st));\n    DBIS = DBISx;\n\n    /* make DBIS available to DBD modules the \"old\" (<= 1.618) way,\n     * so that unrecompiled DBD's will still work against a newer DBI */\n    sv_setiv(get_sv(\"DBI::_dbistate\", GV_ADDMULTI),\n            PTR2IV(MY_CXT.dbi_state));\n\n    /* store version and size so we can spot DBI/DBD version mismatch   */\n    DBIS->check_version = check_version;\n    DBIS->version = DBISTATE_VERSION;\n    DBIS->size    = sizeof(*DBIS);\n    DBIS->xs_version = DBIXS_VERSION;\n\n    DBIS->logmsg      = dbih_logmsg;\n    DBIS->logfp       = PerlIO_stderr();\n    DBIS->debug       = (parent_dbis) ? parent_dbis->debug\n                            : SvIV(get_sv(\"DBI::dbi_debug\",0x5));\n    DBIS->neatsvpvlen = (parent_dbis) ? parent_dbis->neatsvpvlen\n                                      : get_sv(\"DBI::neat_maxlen\", GV_ADDMULTI);\n#ifdef DBI_USE_THREADS\n    DBIS->thr_owner   = PERL_GET_THX;\n#endif\n\n    /* store some function pointers so DBD's can call our functions     */\n    DBIS->getcom      = dbih_getcom;\n    DBIS->clearcom    = dbih_clearcom;\n    DBIS->event       = dbih_event;\n    DBIS->set_attr_k  = dbih_set_attr_k;\n    DBIS->get_attr_k  = dbih_get_attr_k;\n    DBIS->get_fbav    = dbih_get_fbav;\n    DBIS->make_fdsv   = dbih_make_fdsv;\n    DBIS->neat_svpv   = neatsvpv;\n    DBIS->bind_as_num = quote_type; /* XXX deprecated */\n    DBIS->hash        = dbi_hash;\n    DBIS->set_err_sv  = set_err_sv;\n    DBIS->set_err_char= set_err_char;\n    DBIS->bind_col    = dbih_sth_bind_col;\n    DBIS->sql_type_cast_svpv = sql_type_cast_svpv;\n\n\n    /* Remember the last handle used. BEWARE! Sneaky stuff here!        */\n    /* We want a handle reference but we don't want to increment        */\n    /* the handle's reference count and we don't want perl to try       */\n    /* to destroy it during global destruction. Take care!              */\n    DBI_UNSET_LAST_HANDLE;      /* ensure setup the correct way         */\n\n    /* trick to avoid 'possible typo' warnings  */\n    gv_fetchpv(\"DBI::state\",  GV_ADDMULTI, SVt_PV);\n    gv_fetchpv(\"DBI::err\",    GV_ADDMULTI, SVt_PV);\n    gv_fetchpv(\"DBI::errstr\", GV_ADDMULTI, SVt_PV);\n    gv_fetchpv(\"DBI::lasth\",  GV_ADDMULTI, SVt_PV);\n    gv_fetchpv(\"DBI::rows\",   GV_ADDMULTI, SVt_PV);\n\n    /* we only need to check the env var on the initial boot\n     * which is handy because it can core dump during CLONE on windows\n     */\n    if (!parent_dbis && getenv(\"PERL_DBI_XSBYPASS\"))\n        use_xsbypass = atoi(getenv(\"PERL_DBI_XSBYPASS\"));\n}\n\n\n/* ----------------------------------------------------------------- */\n/* Utility functions                                                 */\n\n\nstatic char *\ndbih_htype_name(int htype)\n{\n    switch(htype) {\n    case DBIt_DR: return \"dr\";\n    case DBIt_DB: return \"db\";\n    case DBIt_ST: return \"st\";\n    case DBIt_FD: return \"fd\";\n    default:      return \"??\";\n    }\n}\n\n\nchar *\nneatsvpv(SV *sv, STRLEN maxlen) /* return a tidy ascii value, for debugging only */\n{\n    dTHX;\n    dMY_CXT;\n    STRLEN len;\n    SV *nsv = Nullsv;\n    SV *infosv = Nullsv;\n    char *v, *quote;\n\n    /* We take care not to alter the supplied sv in any way at all.      */\n    /* (but if it is SvGMAGICAL we have to call mg_get and that can      */\n    /* have side effects, especially as it may be called twice overall.) */\n\n    if (!sv)\n        return \"Null!\";                         /* should never happen  */\n\n    /* try to do the right thing with magical values                    */\n    if (SvMAGICAL(sv)) {\n        if (DBIS_TRACE_LEVEL >= 5) {    /* add magic details to help debugging  */\n            MAGIC* mg;\n            infosv = sv_2mortal(newSVpv(\" (magic-\",0));\n            if (SvSMAGICAL(sv)) sv_catpvn(infosv,\"s\",1);\n            if (SvGMAGICAL(sv)) sv_catpvn(infosv,\"g\",1);\n            if (SvRMAGICAL(sv)) sv_catpvn(infosv,\"r\",1);\n            sv_catpvn(infosv,\":\",1);\n            for (mg = SvMAGIC(sv); mg; mg = mg->mg_moremagic)\n                sv_catpvn(infosv, &mg->mg_type, 1);\n            sv_catpvn(infosv, \")\", 1);\n        }\n        if (SvGMAGICAL(sv) && !PL_dirty)\n            mg_get(sv);         /* trigger magic to FETCH the value     */\n    }\n\n    if (!SvOK(sv)) {\n        if (SvTYPE(sv) >= SVt_PVAV)\n            return (char *)sv_reftype(sv,0);    /* raw AV/HV etc, not via a ref */\n        if (!infosv)\n            return \"undef\";\n        sv_insert(infosv, 0,0, \"undef\",5);\n        return SvPVX(infosv);\n    }\n\n    if (SvNIOK(sv)) {     /* is a numeric value - so no surrounding quotes      */\n        if (SvPOK(sv)) {  /* already has string version of the value, so use it */\n            v = SvPV(sv,len);\n            if (len == 0) { v=\"''\"; len=2; } /* catch &sv_no style special case */\n            if (!infosv)\n                return v;\n            sv_insert(infosv, 0,0, v, len);\n            return SvPVX(infosv);\n        }\n        /* we don't use SvPV here since we don't want to alter sv in _any_ way  */\n        if (SvUOK(sv))\n             nsv = newSVpvf(\"%\"UVuf, SvUVX(sv));\n        else if (SvIOK(sv))\n             nsv = newSVpvf(\"%\"IVdf, SvIVX(sv));\n        else nsv = newSVpvf(\"%\"NVgf, SvNVX(sv));\n        if (infosv)\n            sv_catsv(nsv, infosv);\n        return SvPVX(sv_2mortal(nsv));\n    }\n\n    nsv = sv_newmortal();\n    sv_upgrade(nsv, SVt_PV);\n\n    if (SvROK(sv)) {\n        if (!SvAMAGIC(sv))      /* (un-amagic'd) refs get no special treatment  */\n            v = SvPV(sv,len);\n        else {\n            /* handle Overload magic refs */\n            (void)SvAMAGIC_off(sv);   /* should really be done via local scoping */\n            v = SvPV(sv,len);   /* XXX how does this relate to SvGMAGIC?   */\n            SvAMAGIC_on(sv);\n        }\n        sv_setpvn(nsv, v, len);\n        if (infosv)\n            sv_catsv(nsv, infosv);\n        return SvPV(nsv, len);\n    }\n\n    if (SvPOK(sv))              /* usual simple string case                */\n        v = SvPV(sv,len);\n    else                        /* handles all else via sv_2pv()           */\n        v = SvPV(sv,len);       /* XXX how does this relate to SvGMAGIC?   */\n\n    /* for strings we limit the length and translate codes      */\n    if (maxlen == 0)\n        maxlen = SvIV(DBIS->neatsvpvlen);\n    if (maxlen < 6)                     /* handle daft values   */\n        maxlen = 6;\n    maxlen -= 2;                        /* account for quotes   */\n\n    quote = (SvUTF8(sv)) ? \"\\\"\" : \"'\";\n    if (len > maxlen) {\n        SvGROW(nsv, (1+maxlen+1+1));\n        sv_setpvn(nsv, quote, 1);\n        sv_catpvn(nsv, v, maxlen-3);    /* account for three dots */\n        sv_catpvn(nsv, \"...\", 3);\n    } else {\n        SvGROW(nsv, (1+len+1+1));\n        sv_setpvn(nsv, quote, 1);\n        sv_catpvn(nsv, v, len);\n    }\n    sv_catpvn(nsv, quote, 1);\n    if (infosv)\n        sv_catsv(nsv, infosv);\n    v = SvPV(nsv, len);\n    if (!SvUTF8(sv)) {\n        while(len-- > 0) { /* cleanup string (map control chars to ascii etc) */\n            const char c = v[len] & 0x7F;       /* ignore top bit for multinational chars */\n            if (!isPRINT(c) && !isSPACE(c))\n                v[len] = '.';\n        }\n    }\n    return v;\n}\n\n\nstatic void\ncopy_statement_to_parent(pTHX_ SV *h, imp_xxh_t *imp_xxh)\n{\n    SV *parent;\n    if (PL_dirty)\n        return;\n    parent = DBIc_PARENT_H(imp_xxh);\n    if (parent && SvROK(parent)) {\n        SV *tmp_sv = *hv_fetch((HV*)SvRV(h), \"Statement\", 9, 1);\n        if (SvOK(tmp_sv))\n            (void)hv_store((HV*)SvRV(parent), \"Statement\", 9, SvREFCNT_inc(tmp_sv), 0);\n    }\n}\n\n\nstatic int\nset_err_char(SV *h, imp_xxh_t *imp_xxh, const char *err_c, IV err_i, const char *errstr, const char *state, const char *method)\n{\n    dTHX;\n    char err_buf[28];\n    SV *err_sv, *errstr_sv, *state_sv, *method_sv;\n    if (!err_c) {\n        sprintf(err_buf, \"%ld\", (long)err_i);\n        err_c = &err_buf[0];\n    }\n    err_sv    = (strEQ(err_c,\"1\")) ? &PL_sv_yes : sv_2mortal(newSVpvn(err_c, strlen(err_c)));\n    errstr_sv = sv_2mortal(newSVpvn(errstr, strlen(errstr)));\n    state_sv  = (state  && *state)  ? sv_2mortal(newSVpvn(state,  strlen(state)))  : &PL_sv_undef;\n    method_sv = (method && *method) ? sv_2mortal(newSVpvn(method, strlen(method))) : &PL_sv_undef;\n    return set_err_sv(h, imp_xxh, err_sv, errstr_sv, state_sv, method_sv);\n}\n\n\nstatic int\nset_err_sv(SV *h, imp_xxh_t *imp_xxh, SV *err, SV *errstr, SV *state, SV *method)\n{\n    dTHX;\n    SV *h_err;\n    SV *h_errstr;\n    SV *h_state;\n    SV **hook_svp;\n    int err_changed = 0;\n\n    if (    DBIc_has(imp_xxh, DBIcf_HandleSetErr)\n        && (hook_svp = hv_fetch((HV*)SvRV(h),\"HandleSetErr\",12,0))\n        &&  hook_svp\n        &&  ((void)(SvGMAGICAL(*hook_svp) && mg_get(*hook_svp)), SvOK(*hook_svp))\n    ) {\n        dSP;\n        IV items;\n        SV *response_sv;\n        if (SvREADONLY(err))    err    = sv_mortalcopy(err);\n        if (SvREADONLY(errstr)) errstr = sv_mortalcopy(errstr);\n        if (SvREADONLY(state))  state  = sv_mortalcopy(state);\n        if (SvREADONLY(method)) method = sv_mortalcopy(method);\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"    -> HandleSetErr(%s, err=%s, errstr=%s, state=%s, %s)\\n\",\n                neatsvpv(h,0), neatsvpv(err,0), neatsvpv(errstr,0), neatsvpv(state,0),\n                neatsvpv(method,0)\n            );\n        PUSHMARK(SP);\n        XPUSHs(sv_2mortal(newRV_inc((SV*)DBIc_MY_H(imp_xxh))));\n        XPUSHs(err);\n        XPUSHs(errstr);\n        XPUSHs(state);\n        XPUSHs(method);\n        PUTBACK;\n        items = call_sv(*hook_svp, G_SCALAR);\n        SPAGAIN;\n        response_sv = (items) ? POPs : &PL_sv_undef;\n        PUTBACK;\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 1)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"    <- HandleSetErr= %s (err=%s, errstr=%s, state=%s, %s)\\n\",\n                neatsvpv(response_sv,0), neatsvpv(err,0), neatsvpv(errstr,0), neatsvpv(state,0),\n                neatsvpv(method,0)\n            );\n        if (SvTRUE(response_sv))        /* handler says it has handled it, so... */\n            return 0;\n    }\n    else {\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"    -- HandleSetErr err=%s, errstr=%s, state=%s, %s\\n\",\n                neatsvpv(err,0), neatsvpv(errstr,0), neatsvpv(state,0), neatsvpv(method,0)\n            );\n    }\n\n    if (!SvOK(err)) {   /* clear err / errstr / state */\n        DBIh_CLEAR_ERROR(imp_xxh);\n        return 1;\n    }\n\n    /* fetch these after calling HandleSetErr */\n    h_err    = DBIc_ERR(imp_xxh);\n    h_errstr = DBIc_ERRSTR(imp_xxh);\n    h_state  = DBIc_STATE(imp_xxh);\n\n    if (SvTRUE(h_errstr)) {\n        /* append current err, if any, to errstr if it's going to change */\n        if (SvTRUE(h_err) && SvTRUE(err) && strNE(SvPV_nolen(h_err), SvPV_nolen(err)))\n            sv_catpvf(h_errstr, \" [err was %s now %s]\", SvPV_nolen(h_err), SvPV_nolen(err));\n        if (SvTRUE(h_state) && SvTRUE(state) && strNE(SvPV_nolen(h_state), SvPV_nolen(state)))\n            sv_catpvf(h_errstr, \" [state was %s now %s]\", SvPV_nolen(h_state), SvPV_nolen(state));\n        if (strNE(SvPV_nolen(h_errstr), SvPV_nolen(errstr))) {\n            sv_catpvn(h_errstr, \"\\n\", 1);\n            sv_catsv(h_errstr, errstr);\n        }\n    }\n    else\n        sv_setsv(h_errstr, errstr);\n\n    /* SvTRUE(err) > \"0\" > \"\" > undef */\n    if (SvTRUE(err)             /* new error: so assign                 */\n        || !SvOK(h_err) /* no existing warn/info: so assign     */\n           /* new warn (\"0\" len 1) > info (\"\" len 0): so assign         */\n        || (SvOK(err) && strlen(SvPV_nolen(err)) > strlen(SvPV_nolen(h_err)))\n    ) {\n        sv_setsv(h_err, err);\n        err_changed = 1;\n        if (SvTRUE(h_err))      /* new error */\n            ++DBIc_ErrCount(imp_xxh);\n    }\n\n    if (err_changed) {\n        if (SvTRUE(state)) {\n            if (strlen(SvPV_nolen(state)) != 5) {\n                warn(\"set_err: state (%s) is not a 5 character string, using 'S1000' instead\", neatsvpv(state,0));\n                sv_setpv(h_state, \"S1000\");\n            }\n            else\n                sv_setsv(h_state, state);\n        }\n        else\n            (void)SvOK_off(h_state);    /* see DBIc_STATE_adjust */\n\n        /* ensure that the parent's Statement attribute reflects the latest error */\n        /* so that ShowErrorStatement is reliable */\n        copy_statement_to_parent(aTHX_ h, imp_xxh);\n    }\n\n    return 1;\n}\n\n\n/* err_hash returns a U32 'hash' value representing the current err 'level'\n * (err/warn/info) and errstr. It's used by the dispatcher as a way to detect\n * a new or changed warning during a 'keep err' method like STORE. Always returns >0.\n * The value is 1 for no err/warn/info and guarantees that err > warn > info.\n * (It's a bit of a hack but the original approach in 70fe6bd76 using a new\n * ErrChangeCount attribute would break binary compatibility with drivers.)\n * The chance that two realistic errstr values would hash the same, even with\n * only 30 bits, is deemed to small to even bother documenting.\n */\nstatic U32\nerr_hash(pTHX_ imp_xxh_t *imp_xxh)\n{\n    SV *err_sv = DBIc_ERR(imp_xxh);\n    SV *errstr_sv;\n    I32 hash = 1;\n    if (SvOK(err_sv)) {\n        errstr_sv = DBIc_ERRSTR(imp_xxh);\n        if (SvOK(errstr_sv))\n             hash = -dbi_hash(SvPV_nolen(errstr_sv), 0); /* make positive */\n        else hash = 0;\n        hash >>= 1; /* free up extra bit (top bit is already free) */\n        hash |= (SvTRUE(err_sv))                  ? 0x80000000 /* err */\n              : (SvPOK(err_sv) && !SvCUR(err_sv)) ? 0x20000000 /* '' = info */\n                                                  : 0x40000000;/* 0 or '0' = warn */\n    }\n    return hash;\n}\n\n\nstatic char *\nmkvname(pTHX_ HV *stash, const char *item, int uplevel) /* construct a variable name    */\n{\n    SV *sv = sv_newmortal();\n    sv_setpv(sv, HvNAME(stash));\n    if(uplevel) {\n        while(SvCUR(sv) && *SvEND(sv)!=':')\n            --SvCUR(sv);\n        if (SvCUR(sv))\n            --SvCUR(sv);\n    }\n    sv_catpv(sv, \"::\");\n    sv_catpv(sv, item);\n    return SvPV_nolen(sv);\n}\n\n/* 32 bit magic FNV-0 and FNV-1 prime */\n#define FNV_32_PRIME ((UV)0x01000193)\n\nstatic I32\ndbi_hash(const char *key, long type)\n{\n    if (type == 0) {\n        STRLEN klen = strlen(key);\n        U32 hash = 0;\n        while (klen--)\n            hash = hash * 33 + *key++;\n        hash &= 0x7FFFFFFF;     /* limit to 31 bits             */\n        hash |= 0x40000000;     /* set bit 31                   */\n        return -(I32)hash;      /* return negative int  */\n    }\n    else if (type == 1) {       /* Fowler/Noll/Vo hash  */\n        /* see http://www.isthe.com/chongo/tech/comp/fnv/ */\n        U32 hash = 0x811c9dc5;\n        const unsigned char *s = (unsigned char *)key;    /* unsigned string */\n        while (*s) {\n            /* multiply by the 32 bit FNV magic prime mod 2^32 */\n            hash *= FNV_32_PRIME;\n            /* xor the bottom with the current octet */\n            hash ^= (U32)*s++;\n        }\n        return hash;\n    }\n    croak(\"DBI::hash(%ld): invalid type\", type);\n    return 0; /* NOT REACHED */\n}\n\n\nstatic int\ndbih_logmsg(imp_xxh_t *imp_xxh, const char *fmt, ...)\n{\n    dTHX;\n    va_list args;\n#ifdef I_STDARG\n    va_start(args, fmt);\n#else\n    va_start(args);\n#endif\n    (void) PerlIO_vprintf(DBIc_DBISTATE(imp_xxh)->logfp, fmt, args);\n    va_end(args);\n    (void)imp_xxh;\n    return 1;\n}\n\nstatic void\nclose_trace_file(pTHX)\n{\n    dMY_CXT;\n    if (DBILOGFP == PerlIO_stderr() || DBILOGFP == PerlIO_stdout())\n        return;\n\n    if (DBIS->logfp_ref == NULL)\n        PerlIO_close(DBILOGFP);\n    else {\n    /* DAA dec refcount and discard */\n        SvREFCNT_dec(DBIS->logfp_ref);\n        DBIS->logfp_ref = NULL;\n    }\n}\n\nstatic int\nset_trace_file(SV *file)\n{\n    dTHX;\n    dMY_CXT;\n    const char *filename;\n    PerlIO *fp = Nullfp;\n    IO *io;\n\n    if (!file)          /* no arg == no change */\n        return 0;\n\n    /* DAA check for a filehandle */\n    if (SvROK(file)) {\n        io = sv_2io(file);\n        if (!io || !(fp = IoOFP(io))) {\n            warn(\"DBI trace filehandle is not valid\");\n            return 0;\n        }\n        close_trace_file(aTHX);\n        (void)SvREFCNT_inc(io);\n        DBIS->logfp_ref = io;\n    }\n    else if (isGV_with_GP(file)) {\n        io = GvIO(file);\n        if (!io || !(fp = IoOFP(io))) {\n            warn(\"DBI trace filehandle from GLOB is not valid\");\n            return 0;\n        }\n        close_trace_file(aTHX);\n        (void)SvREFCNT_inc(io);\n        DBIS->logfp_ref = io;\n    }\n    else {\n        filename = (SvOK(file)) ? SvPV_nolen(file) : Nullch;\n        /* undef arg == reset back to stderr */\n        if (!filename || strEQ(filename,\"STDERR\")\n                      || strEQ(filename,\"*main::STDERR\")) {\n            close_trace_file(aTHX);\n            DBILOGFP = PerlIO_stderr();\n            return 1;\n        }\n        if (strEQ(filename,\"STDOUT\")) {\n            close_trace_file(aTHX);\n            DBILOGFP = PerlIO_stdout();\n            return 1;\n        }\n        fp = PerlIO_open(filename, \"a+\");\n        if (fp == Nullfp) {\n            warn(\"Can't open trace file %s: %s\", filename, Strerror(errno));\n            return 0;\n        }\n        close_trace_file(aTHX);\n    }\n    DBILOGFP = fp;\n    /* if this line causes your compiler or linker to choke     */\n    /* then just comment it out, it's not essential.    */\n    PerlIO_setlinebuf(fp);      /* force line buffered output */\n    return 1;\n}\n\nstatic IV\nparse_trace_flags(SV *h, SV *level_sv, IV old_level)\n{\n    dTHX;\n    IV level;\n    if (!level_sv || !SvOK(level_sv))\n        level = old_level;              /* undef: no change     */\n    else\n    if (SvTRUE(level_sv)) {\n        if (looks_like_number(level_sv))\n            level = SvIV(level_sv);     /* number: number       */\n        else {                          /* string: parse it     */\n            dSP;\n            PUSHMARK(sp);\n            XPUSHs(h);\n            XPUSHs(level_sv);\n            PUTBACK;\n            if (call_method(\"parse_trace_flags\", G_SCALAR) != 1)\n                croak(\"panic: parse_trace_flags\");/* should never happen */\n            SPAGAIN;\n            level = POPi;\n            PUTBACK;\n        }\n    }\n    else                                /* defined but false: 0 */\n        level = 0;\n    return level;\n}\n\n\nstatic int\nset_trace(SV *h, SV *level_sv, SV *file)\n{\n    dTHX;\n    D_imp_xxh(h);\n    int RETVAL = DBIc_DBISTATE(imp_xxh)->debug; /* Return trace level in effect now */\n    IV level = parse_trace_flags(h, level_sv, RETVAL);\n    set_trace_file(file);\n    if (level != RETVAL) { /* set value */\n        if ((level & DBIc_TRACE_LEVEL_MASK) > 0) {\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                \"    %s trace level set to 0x%lx/%ld (DBI @ 0x%lx/%ld) in DBI %s%s (pid %d)\\n\",\n                neatsvpv(h,0),\n                (long)(level & DBIc_TRACE_FLAGS_MASK),\n                (long)(level & DBIc_TRACE_LEVEL_MASK),\n                (long)DBIc_TRACE_FLAGS(imp_xxh), (long)DBIc_TRACE_LEVEL(imp_xxh),\n                XS_VERSION, dbi_build_opt, (int)PerlProc_getpid());\n            if (!PL_dowarn)\n                PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"    Note: perl is running without the recommended perl -w option\\n\");\n            PerlIO_flush(DBIc_LOGPIO(imp_xxh));\n        }\n        sv_setiv(DBIc_DEBUG(imp_xxh), level);\n    }\n    return RETVAL;\n}\n\n\nstatic SV *\ndbih_inner(pTHX_ SV *orv, const char *what)\n{   /* convert outer to inner handle else croak(what) if what is not NULL */\n    /* if what is NULL then return NULL for invalid handles */\n    MAGIC *mg;\n    SV *ohv;            /* outer HV after derefing the RV       */\n    SV *hrv;            /* dbi inner handle RV-to-HV            */\n\n    /* enable a raw HV (not ref-to-HV) to be passed in, eg DBIc_MY_H */\n    ohv = SvROK(orv) ? SvRV(orv) : orv;\n\n    if (!ohv || SvTYPE(ohv) != SVt_PVHV) {\n        if (!what)\n            return NULL;\n        if (1) {\n            dMY_CXT;\n            if (DBIS_TRACE_LEVEL)\n                sv_dump(orv);\n        }\n        if (!SvOK(orv))\n            croak(\"%s given an undefined handle %s\",\n                what, \"(perhaps returned from a previous call which failed)\");\n        croak(\"%s handle %s is not a DBI handle\", what, neatsvpv(orv,0));\n    }\n    if (!SvMAGICAL(ohv)) {\n        if (!what)\n            return NULL;\n        sv_dump(orv);\n        croak(\"%s handle %s is not a DBI handle (has no magic)\",\n                what, neatsvpv(orv,0));\n    }\n\n    if ( (mg=mg_find(ohv,'P')) == NULL) {       /* hash tie magic       */\n        /* not tied, maybe it's already an inner handle... */\n        if (mg_find(ohv, DBI_MAGIC) == NULL) {\n            if (!what)\n                return NULL;\n            sv_dump(orv);\n            croak(\"%s handle %s is not a valid DBI handle\",\n                what, neatsvpv(orv,0));\n        }\n        hrv = orv; /* was already a DBI handle inner hash */\n    }\n    else {\n        hrv = mg->mg_obj;  /* inner hash of tie */\n    }\n\n    return hrv;\n}\n\n\n\n/* -------------------------------------------------------------------- */\n/* Functions to manage a DBI handle (magic and attributes etc).         */\n\nstatic imp_xxh_t *\ndbih_getcom(SV *hrv) /* used by drivers via DBIS func ptr */\n{\n    MAGIC *mg;\n    SV *sv;\n\n    /* short-cut common case */\n    if (   SvROK(hrv)\n        && (sv = SvRV(hrv))\n        && SvRMAGICAL(sv)\n        && (mg = SvMAGIC(sv))\n        && mg->mg_type == DBI_MAGIC\n        && mg->mg_ptr\n    )\n        return (imp_xxh_t *) mg->mg_ptr;\n\n    {\n        dTHX;\n        imp_xxh_t *imp_xxh = dbih_getcom2(aTHX_ hrv, 0);\n        if (!imp_xxh)       /* eg after take_imp_data */\n            croak(\"Invalid DBI handle %s, has no dbi_imp_data\", neatsvpv(hrv,0));\n        return imp_xxh;\n    }\n}\n\nstatic imp_xxh_t *\ndbih_getcom2(pTHX_ SV *hrv, MAGIC **mgp) /* Get com struct for handle. Must be fast.    */\n{\n    MAGIC *mg;\n    SV *sv;\n\n    /* important and quick sanity check (esp non-'safe' Oraperl)        */\n    if (SvROK(hrv))                     /* must at least be a ref */\n        sv = SvRV(hrv);\n    else {\n        dMY_CXT;\n        if (hrv == DBI_LAST_HANDLE)    /* special for var::FETCH */\n            sv = DBI_LAST_HANDLE;\n        else if (sv_derived_from(hrv, \"DBI::common\")) {\n            /* probably a class name, if ref($h)->foo() */\n            return 0;\n        }\n        else {\n            sv_dump(hrv);\n            croak(\"Invalid DBI handle %s\", neatsvpv(hrv,0));\n            sv = &PL_sv_undef; /* avoid \"might be used uninitialized\" warning       */\n        }\n    }\n\n    /* Short cut for common case. We assume that a magic var always     */\n    /* has magic and that DBI_MAGIC, if present, will be the first.     */\n    if (SvRMAGICAL(sv) && (mg=SvMAGIC(sv))->mg_type == DBI_MAGIC) {\n        /* nothing to do here */\n    }\n    else {\n        /* Validate handle (convert outer to inner if required) */\n        hrv = dbih_inner(aTHX_ hrv, \"dbih_getcom\");\n        mg  = mg_find(SvRV(hrv), DBI_MAGIC);\n    }\n    if (mgp)    /* let caller pickup magic struct for this handle */\n        *mgp = mg;\n\n    if (!mg)    /* may happen during global destruction */\n        return (imp_xxh_t *) 0;\n\n    return (imp_xxh_t *) mg->mg_ptr;\n}\n\n\nstatic SV *\ndbih_setup_attrib(pTHX_ SV *h, imp_xxh_t *imp_xxh, char *attrib, SV *parent, int read_only, int optional)\n{\n    STRLEN len = strlen(attrib);\n    SV **asvp;\n\n    asvp = hv_fetch((HV*)SvRV(h), attrib, len, !optional);\n    /* we assume that we won't have any existing 'undef' attributes here */\n    /* (or, alternately, we take undef to mean 'copy from parent')       */\n    if (!(asvp && SvOK(*asvp))) { /* attribute doesn't already exists (the common case) */\n        SV **psvp;\n        if ((!parent || !SvROK(parent)) && !optional) {\n            croak(\"dbih_setup_attrib(%s): %s not set and no parent supplied\",\n                    neatsvpv(h,0), attrib);\n        }\n        psvp = hv_fetch((HV*)SvRV(parent), attrib, len, 0);\n        if (psvp) {\n            if (!asvp)\n                asvp = hv_fetch((HV*)SvRV(h), attrib, len, 1);\n            sv_setsv(*asvp, *psvp); /* copy attribute from parent to handle */\n        }\n        else {\n            if (!optional)\n                croak(\"dbih_setup_attrib(%s): %s not set and not in parent\",\n                    neatsvpv(h,0), attrib);\n        }\n    }\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 5) {\n        PerlIO *logfp = DBIc_LOGPIO(imp_xxh);\n        PerlIO_printf(logfp,\"    dbih_setup_attrib(%s, %s, %s)\",\n            neatsvpv(h,0), attrib, neatsvpv(parent,0));\n        if (!asvp)\n             PerlIO_printf(logfp,\" undef (not defined)\\n\");\n        else\n        if (SvOK(*asvp))\n             PerlIO_printf(logfp,\" %s (already defined)\\n\", neatsvpv(*asvp,0));\n        else PerlIO_printf(logfp,\" %s (copied from parent)\\n\", neatsvpv(*asvp,0));\n    }\n    if (read_only && asvp)\n        SvREADONLY_on(*asvp);\n    return asvp ? *asvp : &PL_sv_undef;\n}\n\n\nstatic SV *\ndbih_make_fdsv(SV *sth, const char *imp_class, STRLEN imp_size, const char *col_name)\n{\n    dTHX;\n    D_imp_sth(sth);\n    const STRLEN cn_len = strlen(col_name);\n    imp_fdh_t *imp_fdh;\n    SV *fdsv;\n    if (imp_size < sizeof(imp_fdh_t) || cn_len<10 || strNE(\"::fd\",&col_name[cn_len-4]))\n        croak(\"panic: dbih_makefdsv %s '%s' imp_size %ld invalid\",\n                imp_class, col_name, (long)imp_size);\n    if (DBIc_TRACE_LEVEL(imp_sth) >= 5)\n        PerlIO_printf(DBIc_LOGPIO(imp_sth),\"    dbih_make_fdsv(%s, %s, %ld, '%s')\\n\",\n                neatsvpv(sth,0), imp_class, (long)imp_size, col_name);\n    fdsv = dbih_make_com(sth, (imp_xxh_t*)imp_sth, imp_class, imp_size, cn_len+2, 0);\n    imp_fdh = (imp_fdh_t*)(void*)SvPVX(fdsv);\n    imp_fdh->com.col_name = ((char*)imp_fdh) + imp_size;\n    strcpy(imp_fdh->com.col_name, col_name);\n    return fdsv;\n}\n\n\nstatic SV *\ndbih_make_com(SV *p_h, imp_xxh_t *p_imp_xxh, const char *imp_class, STRLEN imp_size, STRLEN extra, SV* imp_templ)\n{\n    dTHX;\n    static const char *errmsg = \"Can't make DBI com handle for %s: %s\";\n    HV *imp_stash;\n    SV *dbih_imp_sv;\n    imp_xxh_t *imp;\n    int trace_level;\n    PERL_UNUSED_VAR(extra);\n\n    if ( (imp_stash = gv_stashpv(imp_class, FALSE)) == NULL)\n        croak(errmsg, imp_class, \"unknown package\");\n\n    if (imp_size == 0) {\n        /* get size of structure to allocate for common and imp specific data   */\n        const char *imp_size_name = mkvname(aTHX_ imp_stash, \"imp_data_size\", 0);\n        imp_size = SvIV(get_sv(imp_size_name, 0x05));\n        if (imp_size == 0) {\n            imp_size = sizeof(imp_sth_t);\n            if (sizeof(imp_dbh_t) > imp_size)\n                imp_size = sizeof(imp_dbh_t);\n            if (sizeof(imp_drh_t) > imp_size)\n                imp_size = sizeof(imp_drh_t);\n            imp_size += 4;\n        }\n    }\n\n    if (p_imp_xxh) {\n        trace_level = DBIc_TRACE_LEVEL(p_imp_xxh);\n    }\n    else {\n        dMY_CXT;\n        trace_level = DBIS_TRACE_LEVEL;\n    }\n    if (trace_level >= 5) {\n        dMY_CXT;\n        PerlIO_printf(DBILOGFP,\"    dbih_make_com(%s, %p, %s, %ld, %p) thr#%p\\n\",\n            neatsvpv(p_h,0), (void*)p_imp_xxh, imp_class, (long)imp_size, (void*)imp_templ, (void*)PERL_GET_THX);\n    }\n\n    if (imp_templ && SvOK(imp_templ)) {\n        U32  imp_templ_flags;\n        /* validate the supplied dbi_imp_data looks reasonable, */\n        if (SvCUR(imp_templ) != imp_size)\n            croak(\"Can't use dbi_imp_data of wrong size (%ld not %ld)\",\n                (long)SvCUR(imp_templ), (long)imp_size);\n\n        /* copy the whole template */\n        dbih_imp_sv = newSVsv(imp_templ);\n        imp = (imp_xxh_t*)(void*)SvPVX(dbih_imp_sv);\n\n        /* sanity checks on the supplied imp_data */\n        if (DBIc_TYPE(imp) != ((p_imp_xxh) ? DBIc_TYPE(p_imp_xxh)+1 :1) )\n            croak(\"Can't use dbi_imp_data from different type of handle\");\n        if (!DBIc_has(imp, DBIcf_IMPSET))\n            croak(\"Can't use dbi_imp_data that not from a setup handle\");\n\n        /* copy flags, zero out our imp_xxh struct, restore some flags */\n        imp_templ_flags = DBIc_FLAGS(imp);\n        switch ( (p_imp_xxh) ? DBIc_TYPE(p_imp_xxh)+1 : DBIt_DR ) {\n        case DBIt_DR: memzero((char*)imp, sizeof(imp_drh_t)); break;\n        case DBIt_DB: memzero((char*)imp, sizeof(imp_dbh_t)); break;\n        case DBIt_ST: memzero((char*)imp, sizeof(imp_sth_t)); break;\n        default:      croak(\"dbih_make_com dbi_imp_data bad h type\");\n        }\n        /* Only pass on DBIcf_IMPSET to indicate to driver that the imp */\n        /* structure has been copied and it doesn't need to reconnect.  */\n        /* Similarly DBIcf_ACTIVE is also passed along but isn't key.   */\n        DBIc_FLAGS(imp) = imp_templ_flags & (DBIcf_IMPSET|DBIcf_ACTIVE);\n    }\n    else {\n        dbih_imp_sv = newSV(imp_size); /* is grown to at least imp_size+1 */\n        imp = (imp_xxh_t*)(void*)SvPVX(dbih_imp_sv);\n        memzero((char*)imp, imp_size);\n        /* set up SV with SvCUR set ready for take_imp_data */\n        SvCUR_set(dbih_imp_sv, imp_size);\n        *SvEND(dbih_imp_sv) = '\\0';\n    }\n\n    if (p_imp_xxh) {\n        DBIc_DBISTATE(imp)  = DBIc_DBISTATE(p_imp_xxh);\n    }\n    else {\n        dMY_CXT;\n        DBIc_DBISTATE(imp)  = DBIS;\n    }\n    DBIc_IMP_STASH(imp) = imp_stash;\n\n    if (!p_h) {         /* only a driver (drh) has no parent    */\n        DBIc_PARENT_H(imp)    = &PL_sv_undef;\n        DBIc_PARENT_COM(imp)  = NULL;\n        DBIc_TYPE(imp)        = DBIt_DR;\n        DBIc_on(imp,DBIcf_WARN          /* set only here, children inherit      */\n                   |DBIcf_ACTIVE        /* drivers are 'Active' by default      */\n                   |DBIcf_AutoCommit    /* advisory, driver must manage this    */\n        );\n        DBIc_set(imp, DBIcf_PrintWarn, 1);\n    }\n    else {\n        DBIc_PARENT_H(imp)    = (SV*)SvREFCNT_inc(p_h); /* ensure it lives      */\n        DBIc_PARENT_COM(imp)  = p_imp_xxh;              /* shortcut for speed   */\n        DBIc_TYPE(imp)        = DBIc_TYPE(p_imp_xxh) + 1;\n        /* inherit some flags from parent and carry forward some from template  */\n        DBIc_FLAGS(imp)       = (DBIc_FLAGS(p_imp_xxh) & ~DBIcf_INHERITMASK)\n                              | (DBIc_FLAGS(imp) & (DBIcf_IMPSET|DBIcf_ACTIVE));\n        ++DBIc_KIDS(p_imp_xxh);\n    }\n#ifdef DBI_USE_THREADS\n    DBIc_THR_USER(imp) = PERL_GET_THX ;\n#endif\n\n    if (DBIc_TYPE(imp) == DBIt_ST) {\n        imp_sth_t *imp_sth = (imp_sth_t*)imp;\n        DBIc_ROW_COUNT(imp_sth) = -1;\n    }\n\n    DBIc_COMSET_on(imp);        /* common data now set up               */\n\n    /* The implementor should DBIc_IMPSET_on(imp) when setting up       */\n    /* any private data which will need clearing/freeing later.         */\n\n    return dbih_imp_sv;\n}\n\n\nstatic void\ndbih_setup_handle(pTHX_ SV *orv, char *imp_class, SV *parent, SV *imp_datasv)\n{\n    SV *h;\n    char *errmsg = \"Can't setup DBI handle of %s to %s: %s\";\n    SV *dbih_imp_sv;\n    SV *dbih_imp_rv;\n    SV *dbi_imp_data = Nullsv;\n    SV **svp;\n    char imp_mem_name[300];\n    HV  *imp_mem_stash;\n    imp_xxh_t *imp;\n    imp_xxh_t *parent_imp;\n    int trace_level;\n\n    h      = dbih_inner(aTHX_ orv, \"dbih_setup_handle\");\n    parent = dbih_inner(aTHX_ parent, NULL);    /* check parent valid (& inner) */\n    if (parent) {\n        parent_imp = DBIh_COM(parent);\n        trace_level = DBIc_TRACE_LEVEL(parent_imp);\n    }\n    else {\n        dMY_CXT;\n        parent_imp = NULL;\n        trace_level = DBIS_TRACE_LEVEL;\n    }\n\n    if (trace_level >= 5) {\n        dMY_CXT;\n        PerlIO_printf(DBILOGFP,\"    dbih_setup_handle(%s=>%s, %s, %lx, %s)\\n\",\n            neatsvpv(orv,0), neatsvpv(h,0), imp_class, (long)parent, neatsvpv(imp_datasv,0));\n    }\n\n    if (mg_find(SvRV(h), DBI_MAGIC) != NULL)\n        croak(errmsg, neatsvpv(orv,0), imp_class, \"already a DBI (or ~magic) handle\");\n\n    strcpy(imp_mem_name, imp_class);\n    strcat(imp_mem_name, \"_mem\");\n    if ( (imp_mem_stash = gv_stashpv(imp_mem_name, FALSE)) == NULL)\n        croak(errmsg, neatsvpv(orv,0), imp_mem_name, \"unknown _mem package\");\n\n    if ((svp = hv_fetch((HV*)SvRV(h), \"dbi_imp_data\", 12, 0))) {\n        dbi_imp_data = *svp;\n        if (SvGMAGICAL(dbi_imp_data))  /* call FETCH via magic */\n            mg_get(dbi_imp_data);\n    }\n\n    DBI_LOCK;\n\n    dbih_imp_sv = dbih_make_com(parent, parent_imp, imp_class, 0, 0, dbi_imp_data);\n    imp = (imp_xxh_t*)(void*)SvPVX(dbih_imp_sv);\n\n    dbih_imp_rv = newRV_inc(dbih_imp_sv);       /* just needed for sv_bless */\n    sv_bless(dbih_imp_rv, imp_mem_stash);\n    sv_free(dbih_imp_rv);\n\n    DBIc_MY_H(imp) = (HV*)SvRV(orv);    /* take _copy_ of pointer, not new ref  */\n    DBIc_IMP_DATA(imp) = (imp_datasv) ? newSVsv(imp_datasv) : &PL_sv_undef;\n    _imp2com(imp, std.pid) = (U32)PerlProc_getpid();\n\n    if (DBIc_TYPE(imp) <= DBIt_ST) {\n        SV **tmp_svp;\n        /* Copy some attributes from parent if not defined locally and  */\n        /* also take address of attributes for speed of direct access.  */\n        /* parent is null for drh, in which case h must hold the values */\n#define COPY_PARENT(name,ro,opt) SvREFCNT_inc(dbih_setup_attrib(aTHX_ h,imp,(name),parent,ro,opt))\n#define DBIc_ATTR(imp, f) _imp2com(imp, attr.f)\n        /* XXX we should validate that these are the right type (refs etc)      */\n        DBIc_ATTR(imp, Err)      = COPY_PARENT(\"Err\",1,0);      /* scalar ref   */\n        DBIc_ATTR(imp, State)    = COPY_PARENT(\"State\",1,0);    /* scalar ref   */\n        DBIc_ATTR(imp, Errstr)   = COPY_PARENT(\"Errstr\",1,0);   /* scalar ref   */\n        DBIc_ATTR(imp, TraceLevel)=COPY_PARENT(\"TraceLevel\",0,0);/* scalar (int)*/\n        DBIc_ATTR(imp, FetchHashKeyName) = COPY_PARENT(\"FetchHashKeyName\",0,0); /* scalar ref */\n\n        if (parent) {\n            dbih_setup_attrib(aTHX_ h,imp,\"HandleSetErr\",parent,0,1);\n            dbih_setup_attrib(aTHX_ h,imp,\"HandleError\",parent,0,1);\n            dbih_setup_attrib(aTHX_ h,imp,\"ReadOnly\",parent,0,1);\n            dbih_setup_attrib(aTHX_ h,imp,\"Profile\",parent,0,1);\n\n            /* setup Callbacks from parents' ChildCallbacks */\n            if (DBIc_has(parent_imp, DBIcf_Callbacks)\n            && (tmp_svp = hv_fetch((HV*)SvRV(parent), \"Callbacks\", 9, 0))\n            && SvROK(*tmp_svp) && SvTYPE(SvRV(*tmp_svp)) == SVt_PVHV\n            && (tmp_svp = hv_fetch((HV*)SvRV(*tmp_svp), \"ChildCallbacks\", 14, 0))\n            && SvROK(*tmp_svp) && SvTYPE(SvRV(*tmp_svp)) == SVt_PVHV\n            ) {\n                /* XXX mirrors behaviour of dbih_set_attr_k() of Callbacks */\n                (void)hv_store((HV*)SvRV(h), \"Callbacks\", 9, newRV_inc(SvRV(*tmp_svp)), 0);\n                DBIc_set(imp, DBIcf_Callbacks, 1);\n            }\n\n            DBIc_LongReadLen(imp) = DBIc_LongReadLen(parent_imp);\n#ifdef sv_rvweaken\n            if (1) {\n                AV *av;\n                /* add weakref to new (outer) handle into parents ChildHandles array */\n                tmp_svp = hv_fetch((HV*)SvRV(parent), \"ChildHandles\", 12, 1);\n                if (!SvROK(*tmp_svp)) {\n                    SV *ChildHandles_rvav = newRV_noinc((SV*)newAV());\n                    sv_setsv(*tmp_svp, ChildHandles_rvav);\n                    sv_free(ChildHandles_rvav);\n                }\n                av = (AV*)SvRV(*tmp_svp);\n                av_push(av, (SV*)sv_rvweaken(newRV_inc((SV*)SvRV(orv))));\n                if (av_len(av) % 120 == 0) {\n                    /* time to do some housekeeping to remove dead handles */\n                    I32 i = av_len(av); /* 0 = 1 element */\n                    while (i-- >= 0) {\n                        SV *sv = av_shift(av);\n                        if (SvOK(sv))\n                            av_push(av, sv);\n                        else\n                           sv_free(sv);         /* keep it leak-free by Doru Petrescu pdoru.dbi@from.ro */\n                    }\n                }\n            }\n#endif\n        }\n        else {\n            DBIc_LongReadLen(imp) = DBIc_LongReadLen_init;\n        }\n\n        switch (DBIc_TYPE(imp)) {\n        case DBIt_DB:\n            /* cache _inner_ handle, but also see quick_FETCH */\n            (void)hv_store((HV*)SvRV(h), \"Driver\", 6, newRV_inc(SvRV(parent)), 0);\n            (void)hv_fetch((HV*)SvRV(h), \"Statement\", 9, 1); /* store writable undef */\n            break;\n        case DBIt_ST:\n            DBIc_NUM_FIELDS((imp_sth_t*)imp) = -1;\n            /* cache _inner_ handle, but also see quick_FETCH */\n            (void)hv_store((HV*)SvRV(h), \"Database\", 8, newRV_inc(SvRV(parent)), 0);\n            /* copy (alias) Statement from the sth up into the dbh      */\n            tmp_svp = hv_fetch((HV*)SvRV(h), \"Statement\", 9, 1);\n            (void)hv_store((HV*)SvRV(parent), \"Statement\", 9, SvREFCNT_inc(*tmp_svp), 0);\n            break;\n        }\n    }\n    else \n        die(\"panic: invalid DBIc_TYPE\");\n\n    /* Use DBI magic on inner handle to carry handle attributes         */\n    /* Note that we store the imp_sv in mg_obj, but as a shortcut,      */\n    /* also store a direct pointer to imp, aka PVX(dbih_imp_sv),        */\n    /* in mg_ptr (with mg_len set to null, so it wont be freed)         */\n    sv_magic(SvRV(h), dbih_imp_sv, DBI_MAGIC, (char*)imp, 0);\n    SvREFCNT_dec(dbih_imp_sv);  /* since sv_magic() incremented it      */\n    SvRMAGICAL_on(SvRV(h));     /* so DBI magic gets sv_clear'd ok      */\n\n    {\n    dMY_CXT; /* XXX would be nice to get rid of this */\n    DBI_SET_LAST_HANDLE(h);\n    }\n\n    if (1) {\n        /* This is a hack to work-around the fast but poor way old versions of\n         * DBD::Oracle (and possibly other drivers) check for a valid handle\n         * using (SvMAGIC(SvRV(h)))->mg_type == 'P'). That doesn't work now\n         * because the weakref magic is inserted ahead of the tie magic.\n         * So here we swap the tie and weakref magic so the tie comes first.\n         */\n        MAGIC *tie_mg = mg_find(SvRV(orv),'P');\n        MAGIC *first  = SvMAGIC(SvRV(orv));\n        if (tie_mg && first->mg_moremagic == tie_mg && !tie_mg->mg_moremagic) {\n            MAGIC *next = tie_mg->mg_moremagic;\n            SvMAGIC(SvRV(orv)) = tie_mg;\n            tie_mg->mg_moremagic = first;\n            first->mg_moremagic = next;\n        }\n    }\n\n    DBI_UNLOCK;\n}\n\n\nstatic void\ndbih_dumphandle(pTHX_ SV *h, const char *msg, int level)\n{\n    D_imp_xxh(h);\n    if (level >= 9) {\n        sv_dump(h);\n    }\n    dbih_dumpcom(aTHX_ imp_xxh, msg, level);\n}\n\nstatic int\ndbih_dumpcom(pTHX_ imp_xxh_t *imp_xxh, const char *msg, int level)\n{\n    dMY_CXT;\n    SV *flags = sv_2mortal(newSVpv(\"\",0));\n    SV *inner;\n    static const char pad[] = \"      \";\n    if (!msg)\n        msg = \"dbih_dumpcom\";\n    PerlIO_printf(DBILOGFP,\"    %s (%sh 0x%lx, com 0x%lx, imp %s):\\n\",\n        msg, dbih_htype_name(DBIc_TYPE(imp_xxh)),\n        (long)DBIc_MY_H(imp_xxh), (long)imp_xxh,\n        (PL_dirty) ? \"global destruction\" : HvNAME(DBIc_IMP_STASH(imp_xxh)));\n    if (DBIc_COMSET(imp_xxh))                   sv_catpv(flags,\"COMSET \");\n    if (DBIc_IMPSET(imp_xxh))                   sv_catpv(flags,\"IMPSET \");\n    if (DBIc_ACTIVE(imp_xxh))                   sv_catpv(flags,\"Active \");\n    if (DBIc_WARN(imp_xxh))                     sv_catpv(flags,\"Warn \");\n    if (DBIc_COMPAT(imp_xxh))                   sv_catpv(flags,\"CompatMode \");\n    if (DBIc_is(imp_xxh, DBIcf_ChopBlanks))     sv_catpv(flags,\"ChopBlanks \");\n    if (DBIc_is(imp_xxh, DBIcf_HandleSetErr))   sv_catpv(flags,\"HandleSetErr \");\n    if (DBIc_is(imp_xxh, DBIcf_HandleError))    sv_catpv(flags,\"HandleError \");\n    if (DBIc_is(imp_xxh, DBIcf_RaiseError))     sv_catpv(flags,\"RaiseError \");\n    if (DBIc_is(imp_xxh, DBIcf_PrintError))     sv_catpv(flags,\"PrintError \");\n    if (DBIc_is(imp_xxh, DBIcf_RaiseWarn))      sv_catpv(flags,\"RaiseWarn \");\n    if (DBIc_is(imp_xxh, DBIcf_PrintWarn))      sv_catpv(flags,\"PrintWarn \");\n    if (DBIc_is(imp_xxh, DBIcf_ShowErrorStatement))     sv_catpv(flags,\"ShowErrorStatement \");\n    if (DBIc_is(imp_xxh, DBIcf_AutoCommit))     sv_catpv(flags,\"AutoCommit \");\n    if (DBIc_is(imp_xxh, DBIcf_BegunWork))      sv_catpv(flags,\"BegunWork \");\n    if (DBIc_is(imp_xxh, DBIcf_LongTruncOk))    sv_catpv(flags,\"LongTruncOk \");\n    if (DBIc_is(imp_xxh, DBIcf_MultiThread))    sv_catpv(flags,\"MultiThread \");\n    if (DBIc_is(imp_xxh, DBIcf_TaintIn))        sv_catpv(flags,\"TaintIn \");\n    if (DBIc_is(imp_xxh, DBIcf_TaintOut))       sv_catpv(flags,\"TaintOut \");\n    if (DBIc_is(imp_xxh, DBIcf_Profile))        sv_catpv(flags,\"Profile \");\n    if (DBIc_is(imp_xxh, DBIcf_Callbacks))      sv_catpv(flags,\"Callbacks \");\n    PerlIO_printf(DBILOGFP,\"%s FLAGS 0x%lx: %s\\n\", pad, (long)DBIc_FLAGS(imp_xxh), SvPV_nolen(flags));\n    if (SvOK(DBIc_ERR(imp_xxh)))\n        PerlIO_printf(DBILOGFP,\"%s ERR %s\\n\",   pad, neatsvpv((SV*)DBIc_ERR(imp_xxh),0));\n    if (SvOK(DBIc_ERR(imp_xxh)))\n        PerlIO_printf(DBILOGFP,\"%s ERRSTR %s\\n\",        pad, neatsvpv((SV*)DBIc_ERRSTR(imp_xxh),0));\n    PerlIO_printf(DBILOGFP,\"%s PARENT %s\\n\",    pad, neatsvpv((SV*)DBIc_PARENT_H(imp_xxh),0));\n    PerlIO_printf(DBILOGFP,\"%s KIDS %ld (%ld Active)\\n\", pad,\n                    (long)DBIc_KIDS(imp_xxh), (long)DBIc_ACTIVE_KIDS(imp_xxh));\n    if (DBIc_IMP_DATA(imp_xxh) && SvOK(DBIc_IMP_DATA(imp_xxh)))\n        PerlIO_printf(DBILOGFP,\"%s IMP_DATA %s\\n\", pad, neatsvpv(DBIc_IMP_DATA(imp_xxh),0));\n    if (DBIc_LongReadLen(imp_xxh) != DBIc_LongReadLen_init)\n        PerlIO_printf(DBILOGFP,\"%s LongReadLen %ld\\n\", pad, (long)DBIc_LongReadLen(imp_xxh));\n\n    if (DBIc_TYPE(imp_xxh) == DBIt_ST) {\n        const imp_sth_t *imp_sth = (imp_sth_t*)imp_xxh;\n        PerlIO_printf(DBILOGFP,\"%s NUM_OF_FIELDS %d\\n\", pad, DBIc_NUM_FIELDS(imp_sth));\n        PerlIO_printf(DBILOGFP,\"%s NUM_OF_PARAMS %d\\n\", pad, DBIc_NUM_PARAMS(imp_sth));\n    }\n    inner = dbih_inner(aTHX_ (SV*)DBIc_MY_H(imp_xxh), msg);\n    if (!inner || !SvROK(inner))\n        return 1;\n    if (DBIc_TYPE(imp_xxh) <= DBIt_DB) {\n        SV **svp = hv_fetch((HV*)SvRV(inner), \"CachedKids\", 10, 0);\n        if (svp && SvROK(*svp) && SvTYPE(SvRV(*svp)) == SVt_PVHV) {\n            HV *hv = (HV*)SvRV(*svp);\n            PerlIO_printf(DBILOGFP,\"%s CachedKids %d\\n\", pad, (int)HvKEYS(hv));\n        }\n    }\n    if (level > 0) {\n        SV* value;\n        char *key;\n        I32   keylen;\n        PerlIO_printf(DBILOGFP,\"%s cached attributes:\\n\", pad);\n        while ( (value = hv_iternextsv((HV*)SvRV(inner), &key, &keylen)) ) {\n            PerlIO_printf(DBILOGFP,\"%s   '%s' => %s\\n\", pad, key, neatsvpv(value,0));\n        }\n    }\n    else if (DBIc_TYPE(imp_xxh) == DBIt_DB) {\n        SV **svp = hv_fetch((HV*)SvRV(inner), \"Name\", 4, 0);\n        if (svp && SvOK(*svp))\n            PerlIO_printf(DBILOGFP,\"%s Name %s\\n\", pad, neatsvpv(*svp,0));\n    }\n    else if (DBIc_TYPE(imp_xxh) == DBIt_ST) {\n        SV **svp = hv_fetch((HV*)SvRV(inner), \"Statement\", 9, 0);\n        if (svp && SvOK(*svp))\n            PerlIO_printf(DBILOGFP,\"%s Statement %s\\n\", pad, neatsvpv(*svp,0));\n    }\n    return 1;\n}\n\n\nstatic void\ndbih_clearcom(imp_xxh_t *imp_xxh)\n{\n    dTHX;\n    dTHR;\n    int dump = FALSE;\n    int debug = DBIc_TRACE_LEVEL(imp_xxh);\n    int auto_dump = (debug >= 6);\n    imp_xxh_t * const parent_xxh = DBIc_PARENT_COM(imp_xxh);\n    /* Note that we're very much on our own here. DBIc_MY_H(imp_xxh) almost     */\n    /* certainly points to memory which has been freed. Don't use it!           */\n\n    /* --- pre-clearing sanity checks --- */\n\n#ifdef DBI_USE_THREADS\n    if (DBIc_THR_USER(imp_xxh) != my_perl) { /* don't clear handle that belongs to another thread */\n        if (debug >= 3) {\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"    skipped dbih_clearcom: DBI handle (type=%d, %s) is owned by thread %p not current thread %p\\n\",\n                  DBIc_TYPE(imp_xxh), HvNAME(DBIc_IMP_STASH(imp_xxh)), (void*)DBIc_THR_USER(imp_xxh), (void*)my_perl) ;\n            PerlIO_flush(DBIc_LOGPIO(imp_xxh));\n        }\n        return;\n    }\n#endif\n\n    if (!DBIc_COMSET(imp_xxh)) {        /* should never happen  */\n        dbih_dumpcom(aTHX_ imp_xxh, \"dbih_clearcom: DBI handle already cleared\", 0);\n        return;\n    }\n\n    if (auto_dump)\n        dbih_dumpcom(aTHX_ imp_xxh,\"DESTROY (dbih_clearcom)\", 0);\n\n    if (!PL_dirty) {\n\n        if (DBIc_ACTIVE(imp_xxh)) {     /* bad news, potentially        */\n            /* warn for sth, warn for dbh only if it has active sth or isn't AutoCommit */\n            if (DBIc_TYPE(imp_xxh) >= DBIt_ST\n            || (DBIc_ACTIVE_KIDS(imp_xxh) || !DBIc_has(imp_xxh, DBIcf_AutoCommit))\n            ) {\n                warn(\"DBI %s handle 0x%lx cleared whilst still active\",\n                        dbih_htype_name(DBIc_TYPE(imp_xxh)), (unsigned long)DBIc_MY_H(imp_xxh));\n                dump = TRUE;\n            }\n        }\n\n        /* check that the implementor has done its own housekeeping     */\n        if (DBIc_IMPSET(imp_xxh)) {\n            warn(\"DBI %s handle 0x%lx has uncleared implementors data\",\n                    dbih_htype_name(DBIc_TYPE(imp_xxh)), (unsigned long)DBIc_MY_H(imp_xxh));\n            dump = TRUE;\n        }\n\n        if (DBIc_KIDS(imp_xxh)) {\n            warn(\"DBI %s handle 0x%lx has %d uncleared child handles\",\n                    dbih_htype_name(DBIc_TYPE(imp_xxh)),\n                    (unsigned long)DBIc_MY_H(imp_xxh), (int)DBIc_KIDS(imp_xxh));\n            dump = TRUE;\n        }\n    }\n\n    if (dump && !auto_dump) /* else was already dumped above */\n        dbih_dumpcom(aTHX_ imp_xxh, \"dbih_clearcom\", 0);\n\n    /* --- pre-clearing adjustments --- */\n\n    if (!PL_dirty) {\n        if (parent_xxh) {\n            if (DBIc_ACTIVE(imp_xxh)) /* see also DBIc_ACTIVE_off */\n                --DBIc_ACTIVE_KIDS(parent_xxh);\n            --DBIc_KIDS(parent_xxh);\n        }\n    }\n\n    /* --- clear fields (may invoke object destructors) ---     */\n\n    if (DBIc_TYPE(imp_xxh) == DBIt_ST) {\n        imp_sth_t *imp_sth = (imp_sth_t*)imp_xxh;\n        sv_free((SV*)DBIc_FIELDS_AV(imp_sth));\n    }\n\n    sv_free(DBIc_IMP_DATA(imp_xxh));            /* do this first        */\n    if (DBIc_TYPE(imp_xxh) <= DBIt_ST) {        /* DBIt_FD doesn't have attr */\n        sv_free(_imp2com(imp_xxh, attr.TraceLevel));\n        sv_free(_imp2com(imp_xxh, attr.State));\n        sv_free(_imp2com(imp_xxh, attr.Err));\n        sv_free(_imp2com(imp_xxh, attr.Errstr));\n        sv_free(_imp2com(imp_xxh, attr.FetchHashKeyName));\n    }\n\n\n    sv_free((SV*)DBIc_PARENT_H(imp_xxh));       /* do this last         */\n\n    DBIc_COMSET_off(imp_xxh);\n\n    if (debug >= 4)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"    dbih_clearcom 0x%lx (com 0x%lx, type %d) done.\\n\\n\",\n                (long)DBIc_MY_H(imp_xxh), (long)imp_xxh, DBIc_TYPE(imp_xxh));\n}\n\n\n/* --- Functions for handling field buffer arrays ---           */\n\nstatic AV *\ndbih_setup_fbav(imp_sth_t *imp_sth)\n{\n    /*  Usually called to setup the row buffer for new sth.\n     *  Also called if the value of NUM_OF_FIELDS is altered,\n     *  in which case it adjusts the row buffer to match NUM_OF_FIELDS.\n     */\n    dTHX;\n    I32 i = DBIc_NUM_FIELDS(imp_sth);\n    AV *av = DBIc_FIELDS_AV(imp_sth);\n\n    if (i < 0)\n        i = 0;\n\n    if (av) {\n        if (av_len(av)+1 == i)  /* is existing array the right size? */\n            return av;\n        /* we need to adjust the size of the array */\n        if (DBIc_TRACE_LEVEL(imp_sth) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_sth),\"    dbih_setup_fbav realloc from %ld to %ld fields\\n\", (long)(av_len(av)+1), (long)i);\n        SvREADONLY_off(av);\n        if (i < av_len(av)+1) /* trim to size if too big */\n            av_fill(av, i-1);\n    }\n    else {\n        if (DBIc_TRACE_LEVEL(imp_sth) >= 5)\n            PerlIO_printf(DBIc_LOGPIO(imp_sth),\"    dbih_setup_fbav alloc for %ld fields\\n\", (long)i);\n        av = newAV();\n        DBIc_FIELDS_AV(imp_sth) = av;\n\n        /* row_count will need to be manually reset by the driver if the        */\n        /* sth is re-executed (since this code won't get rerun)         */\n        DBIc_ROW_COUNT(imp_sth) = 0;\n    }\n\n    /* load array with writeable SV's. Do this backwards so     */\n    /* the array only gets extended once.                       */\n    while(i--)                  /* field 1 stored at index 0    */\n        av_store(av, i, newSV(0));\n    if (DBIc_TRACE_LEVEL(imp_sth) >= 6)\n        PerlIO_printf(DBIc_LOGPIO(imp_sth),\"    dbih_setup_fbav now %ld fields\\n\", (long)(av_len(av)+1));\n    SvREADONLY_on(av);          /* protect against shift @$row etc */\n    return av;\n}\n\n\nstatic AV *\ndbih_get_fbav(imp_sth_t *imp_sth)\n{\n    AV *av;\n\n    if ( (av = DBIc_FIELDS_AV(imp_sth)) == Nullav) {\n        av = dbih_setup_fbav(imp_sth);\n    }\n    else {\n        dTHX;\n        int i = av_len(av) + 1;\n        if (i != DBIc_NUM_FIELDS(imp_sth)) {\n            /*SV *sth = dbih_inner(aTHX_ (SV*)DBIc_MY_H(imp_sth), \"_get_fbav\");*/\n            /* warn via PrintWarn */\n            set_err_char(SvRV(DBIc_MY_H(imp_sth)), (imp_xxh_t*)imp_sth,\n                    \"0\", 0, \"Number of row fields inconsistent with NUM_OF_FIELDS (driver bug)\", \"\", \"_get_fbav\");\n            /*\n            DBIc_NUM_FIELDS(imp_sth) = i;\n            hv_delete((HV*)SvRV(sth), \"NUM_OF_FIELDS\", 13, G_DISCARD);\n            */\n        }\n        /* don't let SvUTF8 flag persist from one row to the next   */\n        /* (only affects drivers that use sv_setpv, but most XS do) */\n        /* XXX turn into option later (force on/force off/ignore) */\n        while(i--)                  /* field 1 stored at index 0    */\n            SvUTF8_off(AvARRAY(av)[i]);\n    }\n\n    if (DBIc_is(imp_sth, DBIcf_TaintOut)) {\n        dTHX;\n        dTHR;\n        TAINT;  /* affects sv_setsv()'s called within same perl statement */\n    }\n\n    /* XXX fancy stuff to happen here later (re scrolling etc)  */\n    ++DBIc_ROW_COUNT(imp_sth);\n    return av;\n}\n\n\nstatic int\ndbih_sth_bind_col(SV *sth, SV *col, SV *ref, SV *attribs)\n{\n    dTHX;\n    D_imp_sth(sth);\n    AV *av;\n    int idx = SvIV(col);\n    int fields = DBIc_NUM_FIELDS(imp_sth);\n\n    if (fields <= 0) {\n        PERL_UNUSED_VAR(attribs);\n        croak(\"Statement has no result columns to bind%s\",\n            DBIc_ACTIVE(imp_sth)\n                ? \"\" : \" (perhaps you need to successfully call execute first, or again)\");\n    }\n\n    if ( (av = DBIc_FIELDS_AV(imp_sth)) == Nullav)\n        av = dbih_setup_fbav(imp_sth);\n\n    if (DBIc_TRACE_LEVEL(imp_sth) >= 5)\n        PerlIO_printf(DBIc_LOGPIO(imp_sth),\"    dbih_sth_bind_col %s => %s %s\\n\",\n                neatsvpv(col,0), neatsvpv(ref,0), neatsvpv(attribs,0));\n\n    if (idx < 1 || idx > fields)\n        croak(\"bind_col: column %d is not a valid column (1..%d)\",\n                        idx, fields);\n\n    if (!SvOK(ref) && SvREADONLY(ref)) {   /* binding to literal undef */\n        /* presumably the call is just setting the TYPE or other atribs */\n        /* but this default method ignores attribs, so we just return   */\n        return 1;\n    }\n\n    /* Write this as > SVt_PVMG because in 5.8.x the next type */\n    /* is SVt_PVBM, whereas in 5.9.x it's SVt_PVGV.            */\n    if (!SvROK(ref) || SvTYPE(SvRV(ref)) > SVt_PVMG) /* XXX LV */\n        croak(\"Can't %s->bind_col(%s, %s,...), need a reference to a scalar\",\n                neatsvpv(sth,0), neatsvpv(col,0), neatsvpv(ref,0));\n\n    /* use supplied scalar as storage for this column */\n    SvREADONLY_off(av);\n    av_store(av, idx-1, SvREFCNT_inc(SvRV(ref)) );\n    SvREADONLY_on(av);\n    return 1;\n}\n\n\nstatic int\nquote_type(int sql_type, int p, int s, int *t, void *v)\n{\n    /* Returns true if type should be bound as a number else    */\n    /* false implying that binding as a string should be okay.  */\n    /* The true value is either SQL_INTEGER or SQL_DOUBLE which */\n    /* can be used as a hint if desired.                        */\n    (void)p;\n    (void)s;\n    (void)t;\n    (void)v;\n    /* looks like it's never been used, and doesn't make much sense anyway */\n    warn(\"Use of DBI internal bind_as_num/quote_type function is deprecated\");\n    switch(sql_type) {\n    case SQL_INTEGER:\n    case SQL_SMALLINT:\n    case SQL_TINYINT:\n    case SQL_BIGINT:\n        return 0;\n    case SQL_FLOAT:\n    case SQL_REAL:\n    case SQL_DOUBLE:\n        return 0;\n    case SQL_NUMERIC:\n    case SQL_DECIMAL:\n        return 0;       /* bind as string to attempt to retain precision */\n    }\n    return 1;\n}\n\n\n/* Convert a simple string representation of a value into a more specific\n * perl type based on an sql_type value.\n * The semantics of SQL standard TYPE values are interpreted _very_ loosely\n * on the basis of \"be liberal in what you accept and let's throw in some\n * extra semantics while we're here\" :)\n * Returns:\n *  -2: sql_type isn't handled, value unchanged\n *  -1: sv is undef, value unchanged\n *   0: sv couldn't be cast cleanly and DBIstcf_STRICT was used\n *   1: sv couldn't be cast cleanly and DBIstcf_STRICT was not used\n *   2: sv was cast ok\n */\n\nint\nsql_type_cast_svpv(pTHX_ SV *sv, int sql_type, U32 flags, void *v)\n{\n    int cast_ok = 0;\n    int grok_flags;\n    UV uv;\n\n    /* do nothing for undef (NULL) or non-string values */\n    if (!sv || !SvOK(sv))\n        return -1;\n\n    switch(sql_type) {\n\n    default:\n        return -2;   /* not a recognised SQL TYPE, value unchanged */\n\n    case SQL_INTEGER:\n        /* sv_2iv is liberal, may return SvIV, SvUV, or SvNV */\n        sv_2iv(sv);\n        /* SvNOK will be set if value is out of range for IV/UV.\n         * SvIOK should be set but won't if sv is not numeric (in which\n         * case perl would have warn'd already if -w or warnings are in effect)\n         */\n        cast_ok = (SvIOK(sv) && !SvNOK(sv));\n        break;\n\n    case SQL_DOUBLE:\n        sv_2nv(sv);\n        /* SvNOK should be set but won't if sv is not numeric (in which\n         * case perl would have warn'd already if -w or warnings are in effect)\n         */\n        cast_ok = SvNOK(sv);\n        break;\n\n    /* caller would like IV else UV else NV */\n    /* else no error and sv is untouched */\n    case SQL_NUMERIC:\n        /* based on the code in perl's toke.c */\n        uv = 0;\n        grok_flags = grok_number(SvPVX(sv), SvCUR(sv), &uv);\n        cast_ok = 1;\n        if (grok_flags == IS_NUMBER_IN_UV) { /* +ve int */\n            if (uv <= IV_MAX)   /* prefer IV over UV */\n                 sv_2iv(sv);\n            else sv_2uv(sv);\n        }\n        else if (grok_flags == (IS_NUMBER_IN_UV | IS_NUMBER_NEG)\n            && uv <= IV_MAX\n        ) {\n            sv_2iv(sv);\n        }\n        else if (grok_flags) { /* is numeric */\n            sv_2nv(sv);\n        }\n        else\n            cast_ok = 0;\n        break;\n\n#if 0 /* XXX future possibilities */\n    case SQL_BIGINT:    /* use Math::BigInt if too large for IV/UV */\n#endif\n    }\n\n    if (cast_ok) {\n\n        if (flags & DBIstcf_DISCARD_STRING\n        && SvNIOK(sv)  /* we set a numeric value */\n        && SvPVX(sv)   /* we have a buffer to discard */\n        ) {\n            SvOOK_off(sv);\n            sv_force_normal(sv);\n            if (SvLEN(sv))\n                Safefree(SvPVX(sv));\n            SvPOK_off(sv);\n            SvPV_set(sv, NULL);\n            SvLEN_set(sv, 0);\n            SvCUR_set(sv, 0);\n        }\n    }\n\n    if (cast_ok)\n        return 2;\n    else if (flags & DBIstcf_STRICT)\n        return 0;\n    else return 1;\n}\n\n\n\n/* --- Generic Handle Attributes (for all handle types) ---     */\n\nstatic int\ndbih_set_attr_k(SV *h, SV *keysv, int dbikey, SV *valuesv)\n{\n    dTHX;\n    dTHR;\n    D_imp_xxh(h);\n    STRLEN keylen;\n    const char  *key = SvPV(keysv, keylen);\n    const int    htype = DBIc_TYPE(imp_xxh);\n    int    on = (SvTRUE(valuesv));\n    int    internal = 1; /* DBIh_IN_PERL_DBD(imp_xxh); -- for DBD's in perl */\n    int    cacheit = 0;\n    int    weakenit = 0; /* eg for CachedKids ref */\n    (void)dbikey;\n\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 3)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"    STORE %s %s => %s\\n\",\n                neatsvpv(h,0), neatsvpv(keysv,0), neatsvpv(valuesv,0));\n\n    if (internal && strEQ(key, \"Active\")) {\n        if (on) {\n            D_imp_sth(h);\n            DBIc_ACTIVE_on(imp_xxh);\n            /* for pure-perl drivers on second and subsequent   */\n            /* execute()'s, else row count keeps rising.        */\n            if (htype==DBIt_ST && DBIc_FIELDS_AV(imp_sth))\n                DBIc_ROW_COUNT(imp_sth) = 0;\n        }\n        else {\n            DBIc_ACTIVE_off(imp_xxh);\n        }\n    }\n    else if (strEQ(key, \"FetchHashKeyName\")) {\n        if (htype >= DBIt_ST)\n            croak(\"Can't set FetchHashKeyName for a statement handle, set in parent before prepare()\");\n        cacheit = 1;    /* just save it */\n    }\n    else if (strEQ(key, \"CompatMode\")) {\n        (on) ? DBIc_COMPAT_on(imp_xxh) : DBIc_COMPAT_off(imp_xxh);\n    }\n    else if (strEQ(key, \"Warn\")) {\n        (on) ? DBIc_WARN_on(imp_xxh) : DBIc_WARN_off(imp_xxh);\n    }\n    else if (strEQ(key, \"AutoInactiveDestroy\")) {\n        (on) ? DBIc_AIADESTROY_on(imp_xxh) : DBIc_AIADESTROY_off(imp_xxh);\n    }\n    else if (strEQ(key, \"InactiveDestroy\")) {\n        (on) ? DBIc_IADESTROY_on(imp_xxh) : DBIc_IADESTROY_off(imp_xxh);\n    }\n    else if (strEQ(key, \"RootClass\")) {\n        cacheit = 1;    /* just save it */\n    }\n    else if (strEQ(key, \"RowCacheSize\")) {\n        cacheit = 0;    /* ignore it */\n    }\n    else if (strEQ(key, \"Executed\")) {\n        DBIc_set(imp_xxh, DBIcf_Executed, on);\n    }\n    else if (strEQ(key, \"ChopBlanks\")) {\n        DBIc_set(imp_xxh, DBIcf_ChopBlanks, on);\n    }\n    else if (strEQ(key, \"ErrCount\")) {\n        DBIc_ErrCount(imp_xxh) = SvUV(valuesv);\n    }\n    else if (strEQ(key, \"LongReadLen\")) {\n        if (SvNV(valuesv) < 0 || SvNV(valuesv) > MAX_LongReadLen)\n            croak(\"Can't set LongReadLen < 0 or > %ld\",MAX_LongReadLen);\n        DBIc_LongReadLen(imp_xxh) = SvIV(valuesv);\n        cacheit = 1;    /* save it for clone */\n    }\n    else if (strEQ(key, \"LongTruncOk\")) {\n        DBIc_set(imp_xxh,DBIcf_LongTruncOk, on);\n    }\n    else if (strEQ(key, \"RaiseError\")) {\n        DBIc_set(imp_xxh,DBIcf_RaiseError, on);\n    }\n    else if (strEQ(key, \"PrintError\")) {\n        DBIc_set(imp_xxh,DBIcf_PrintError, on);\n    }\n    else if (strEQ(key, \"RaiseWarn\")) {\n        DBIc_set(imp_xxh,DBIcf_RaiseWarn, on);\n    }\n    else if (strEQ(key, \"PrintWarn\")) {\n        DBIc_set(imp_xxh,DBIcf_PrintWarn, on);\n    }\n    else if (strEQ(key, \"HandleError\")) {\n        if ( on && (!SvROK(valuesv) || (SvTYPE(SvRV(valuesv)) != SVt_PVCV)) ) {\n            croak(\"Can't set %s to '%s'\", \"HandleError\", neatsvpv(valuesv,0));\n        }\n        DBIc_set(imp_xxh,DBIcf_HandleError, on);\n        cacheit = 1; /* child copy setup by dbih_setup_handle() */\n    }\n    else if (strEQ(key, \"HandleSetErr\")) {\n        if ( on && (!SvROK(valuesv) || (SvTYPE(SvRV(valuesv)) != SVt_PVCV)) ) {\n            croak(\"Can't set %s to '%s'\",\"HandleSetErr\",neatsvpv(valuesv,0));\n        }\n        DBIc_set(imp_xxh,DBIcf_HandleSetErr, on);\n        cacheit = 1; /* child copy setup by dbih_setup_handle() */\n    }\n    else if (strEQ(key, \"ChildHandles\")) {\n        if ( on && (!SvROK(valuesv) || (SvTYPE(SvRV(valuesv)) != SVt_PVAV)) ) {\n            croak(\"Can't set %s to '%s'\", \"ChildHandles\", neatsvpv(valuesv,0));\n        }\n        cacheit = 1; /* just save it in the hash */\n    }\n    else if (strEQ(key, \"Profile\")) {\n        static const char profile_class[] = \"DBI::Profile\";\n        if (on && (!SvROK(valuesv) || (SvTYPE(SvRV(valuesv)) != SVt_PVHV)) ) {\n            /* not a hash ref so use DBI::Profile to work out what to do */\n            dTHR;\n            dSP;\n            I32 returns;\n            TAINT_NOT; /* the require is presumed innocent till proven guilty */\n            perl_require_pv(\"DBI/Profile.pm\");\n            if (SvTRUE(ERRSV)) {\n                warn(\"Can't load %s: %s\", profile_class, SvPV_nolen(ERRSV));\n                valuesv = &PL_sv_undef;\n            }\n            else {\n                PUSHMARK(SP);\n                XPUSHs(sv_2mortal(newSVpv(profile_class,0)));\n                XPUSHs(valuesv);\n                PUTBACK;\n                returns = call_method(\"_auto_new\", G_SCALAR);\n                if (returns != 1)\n                    croak(\"%s _auto_new\", profile_class);\n                SPAGAIN;\n                valuesv = POPs;\n                PUTBACK;\n            }\n            on = SvTRUE(valuesv); /* in case it returns undef */\n        }\n        if (on && !sv_isobject(valuesv)) {\n            /* not blessed already - so default to DBI::Profile */\n            HV *stash;\n            perl_require_pv(profile_class);\n            stash = gv_stashpv(profile_class, GV_ADDWARN);\n            sv_bless(valuesv, stash);\n        }\n        DBIc_set(imp_xxh,DBIcf_Profile, on);\n        cacheit = 1; /* child copy setup by dbih_setup_handle() */\n    }\n    else if (strEQ(key, \"ShowErrorStatement\")) {\n        DBIc_set(imp_xxh,DBIcf_ShowErrorStatement, on);\n    }\n    else if (strEQ(key, \"MultiThread\") && internal) {\n        /* here to allow pure-perl drivers to set MultiThread */\n        DBIc_set(imp_xxh,DBIcf_MultiThread, on);\n        if (on && DBIc_WARN(imp_xxh)) {\n            warn(\"MultiThread support not yet implemented in DBI\");\n        }\n    }\n    else if (strEQ(key, \"Taint\")) {\n        /* 'Taint' is a shortcut for both in and out mode */\n        DBIc_set(imp_xxh,DBIcf_TaintIn|DBIcf_TaintOut, on);\n    }\n    else if (strEQ(key, \"TaintIn\")) {\n        DBIc_set(imp_xxh,DBIcf_TaintIn, on);\n    }\n    else if (strEQ(key, \"TaintOut\")) {\n        DBIc_set(imp_xxh,DBIcf_TaintOut, on);\n    }\n    else if (htype<=DBIt_DB && keylen==10 && strEQ(key, \"CachedKids\")\n        /* only allow hash refs */\n        && SvROK(valuesv) && SvTYPE(SvRV(valuesv))==SVt_PVHV\n    ) {\n        cacheit = 1;\n        weakenit = 1;\n    }\n    else if (keylen==9 && strEQ(key, \"Callbacks\")) {\n        if ( on && (!SvROK(valuesv) || (SvTYPE(SvRV(valuesv)) != SVt_PVHV)) )\n            croak(\"Can't set Callbacks to '%s'\",neatsvpv(valuesv,0));\n        /* see also dbih_setup_handle for ChildCallbacks handling */\n        DBIc_set(imp_xxh, DBIcf_Callbacks, on);\n        cacheit = 1;\n    }\n    else if (htype<=DBIt_DB && keylen==10 && strEQ(key, \"AutoCommit\")) {\n        /* driver should have intercepted this and either handled it    */\n        /* or set valuesv to either the 'magic' on or off value.        */\n        if (SvIV(valuesv) != -900 && SvIV(valuesv) != -901)\n            croak(\"DBD driver has not implemented the AutoCommit attribute\");\n        DBIc_set(imp_xxh,DBIcf_AutoCommit, (SvIV(valuesv)==-901));\n    }\n    else if (htype==DBIt_DB && keylen==9 && strEQ(key, \"BegunWork\")) {\n        DBIc_set(imp_xxh,DBIcf_BegunWork, on);\n    }\n    else if (keylen==10  && strEQ(key, \"TraceLevel\")) {\n        set_trace(h, valuesv, Nullsv);\n    }\n    else if (keylen==9  && strEQ(key, \"TraceFile\")) { /* XXX undocumented and readonly */\n        set_trace_file(valuesv);\n    }\n    else if (htype==DBIt_ST && strEQ(key, \"NUM_OF_FIELDS\")) {\n        D_imp_sth(h);\n        int new_num_fields = (SvOK(valuesv)) ? SvIV(valuesv) : -1;\n        DBIc_NUM_FIELDS(imp_sth) = new_num_fields;\n        if (DBIc_FIELDS_AV(imp_sth)) { /* modify existing fbav */\n            dbih_setup_fbav(imp_sth);\n        }\n        cacheit = 1;\n    }\n    else if (htype==DBIt_ST && strEQ(key, \"NUM_OF_PARAMS\")) {\n        D_imp_sth(h);\n        DBIc_NUM_PARAMS(imp_sth) = SvIV(valuesv);\n        cacheit = 1;\n    }\n    /* these are here due to clone() needing to set attribs through a public api */\n    else if (htype<=DBIt_DB && (strEQ(key, \"Name\")\n                            || strEQ(key,\"ImplementorClass\")\n                            || strEQ(key,\"ReadOnly\")\n                            || strEQ(key,\"Statement\")\n                            || strEQ(key,\"Username\")\n        /* these are here for backwards histerical raisons */\n        || strEQ(key,\"USER\") || strEQ(key,\"CURRENT_USER\")\n    ) ) {\n        cacheit = 1;\n    }\n    /* deal with: NAME_(uc|lc), NAME_hash, NAME_(uc|lc)_hash */\n    else if ((keylen==7 || keylen==9 || keylen==12)\n        && strnEQ(key, \"NAME_\", 5)\n        && (    (keylen==9 && strEQ(key, \"NAME_hash\"))\n           ||   ((key[5]=='u' || key[5]=='l') && key[6] == 'c'\n                && (!key[7] || strnEQ(&key[7], \"_hash\", 5)))\n           )\n        ) {\n        cacheit = 1;\n    }\n    else {      /* XXX should really be an event ? */\n        if (isUPPER(*key)) {\n            char *msg = \"Can't set %s->{%s}: unrecognised attribute name or invalid value%s\";\n            char *hint = \"\";\n            if (strEQ(key, \"NUM_FIELDS\"))\n                hint = \", perhaps you meant NUM_OF_FIELDS\";\n            warn(msg, neatsvpv(h,0), key, hint);\n            return FALSE;       /* don't store it */\n        }\n        /* Allow private_* attributes to be stored in the cache.        */\n        /* This is designed to make life easier for people subclassing  */\n        /* the DBI classes and may be of use to simple perl DBD's.      */\n        if (strnNE(key,\"private_\",8) && strnNE(key,\"dbd_\",4) && strnNE(key,\"dbi_\",4)) {\n            if (DBIc_TRACE_LEVEL(imp_xxh)) { /* change to DBIc_WARN(imp_xxh) once we can validate prefix against registry */\n                PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"$h->{%s}=%s ignored for invalid driver-specific attribute\\n\",\n                        neatsvpv(keysv,0), neatsvpv(valuesv,0));\n            }\n            return FALSE;\n        }\n        cacheit = 1;\n    }\n    if (cacheit) {\n        SV *sv_for_cache = newSVsv(valuesv);\n        (void)hv_store((HV*)SvRV(h), key, keylen, sv_for_cache, 0);\n        if (weakenit) {\n#ifdef sv_rvweaken\n            sv_rvweaken(sv_for_cache);\n#endif\n        }\n    }\n    return TRUE;\n}\n\n\nstatic SV *\ndbih_get_attr_k(SV *h, SV *keysv, int dbikey)\n{\n    dTHX;\n    dTHR;\n    D_imp_xxh(h);\n    STRLEN keylen;\n    char  *key = SvPV(keysv, keylen);\n    int    htype = DBIc_TYPE(imp_xxh);\n    SV  *valuesv = Nullsv;\n    int    cacheit = FALSE;\n    char *p;\n    int i;\n    SV  *sv;\n    SV  **svp;\n    (void)dbikey;\n\n    /* DBI quick_FETCH will service some requests (e.g., cached values) */\n\n    if (htype == DBIt_ST) {\n        switch (*key) {\n\n          case 'D':\n            if (keylen==8 && strEQ(key, \"Database\")) {\n                D_imp_from_child(imp_dbh, imp_dbh_t, imp_xxh);\n                valuesv = newRV_inc((SV*)DBIc_MY_H(imp_dbh));\n                cacheit = FALSE;  /* else creates ref loop */\n            }\n            break;\n\n          case 'N':\n            if (keylen==8 && strEQ(key, \"NULLABLE\")) {\n                valuesv = &PL_sv_undef;\n                break;\n            }\n\n            if (keylen==4 && strEQ(key, \"NAME\")) {\n                valuesv = &PL_sv_undef;\n                break;\n            }\n\n            /* deal with: NAME_(uc|lc), NAME_hash, NAME_(uc|lc)_hash */\n            if ((keylen==7 || keylen==9 || keylen==12)\n                && strnEQ(key, \"NAME_\", 5)\n                && (    (keylen==9 && strEQ(key, \"NAME_hash\"))\n                      ||        ((key[5]=='u' || key[5]=='l') && key[6] == 'c'\n                               && (!key[7] || strnEQ(&key[7], \"_hash\", 5)))\n                    )\n                ) {\n                D_imp_sth(h);\n                valuesv = &PL_sv_undef;\n\n                /* fetch from tied outer handle to trigger FETCH magic */\n                svp = hv_fetch((HV*)DBIc_MY_H(imp_sth), \"NAME\",4, FALSE);\n                sv = (svp) ? *svp : &PL_sv_undef;\n                if (SvGMAGICAL(sv))     /* call FETCH via magic */\n                    mg_get(sv);\n\n                if (SvROK(sv)) {\n                    AV *name_av = (AV*)SvRV(sv);\n                    char *name;\n                    int upcase = (key[5] == 'u');\n                    AV *av = Nullav;\n                    HV *hv = Nullhv;\n                    int num_fields_mismatch = 0;\n\n                    if (strEQ(&key[strlen(key)-5], \"_hash\"))\n                        hv = newHV();\n                    else av = newAV();\n                    i = DBIc_NUM_FIELDS(imp_sth);\n\n                    /* catch invalid NUM_FIELDS */\n                    if (i != AvFILL(name_av)+1) {\n                        /* flag as mismatch, except for \"-1 and empty\" case */\n                        if ( ! (i == -1 && 0 == AvFILL(name_av)+1) )\n                            num_fields_mismatch = 1;\n                        i = AvFILL(name_av)+1; /* limit for safe iteration over array */\n                    }\n\n\t\t    if (DBIc_TRACE_LEVEL(imp_sth) >= 10 || (num_fields_mismatch && DBIc_WARN(imp_xxh))) {\n\t\t\tPerlIO_printf(DBIc_LOGPIO(imp_sth),\"       FETCH $h->{%s} from $h->{NAME} with $h->{NUM_OF_FIELDS} = %d\"\n\t\t\t                       \" and %ld entries in $h->{NAME}%s\\n\",\n\t\t\t\tneatsvpv(keysv,0), DBIc_NUM_FIELDS(imp_sth), AvFILL(name_av)+1,\n                                (num_fields_mismatch) ? \" (possible bug in driver)\" : \"\");\n                    }\n\n                    while (--i >= 0) {\n                        sv = newSVsv(AvARRAY(name_av)[i]);\n                        name = SvPV_nolen(sv);\n                        if (key[5] != 'h') {    /* \"NAME_hash\" */\n                            for (p = name; p && *p; ++p) {\n#ifdef toUPPER_LC\n                                *p = (upcase) ? toUPPER_LC(*p) : toLOWER_LC(*p);\n#else\n                                *p = (upcase) ? toUPPER(*p) : toLOWER(*p);\n#endif\n                            }\n                        }\n                        if (av)\n                            av_store(av, i, sv);\n                        else {\n                            (void)hv_store(hv, name, SvCUR(sv), newSViv(i), 0);\n                            sv_free(sv);\n                        }\n                    }\n                    valuesv = newRV_noinc( (av ? (SV*)av : (SV*)hv) );\n                    cacheit = TRUE;     /* can't change */\n                }\n            }\n            else if (keylen==13 && strEQ(key, \"NUM_OF_FIELDS\")) {\n                D_imp_sth(h);\n                IV num_fields = DBIc_NUM_FIELDS(imp_sth);\n                valuesv = (num_fields < 0) ? &PL_sv_undef : newSViv(num_fields);\n                if (num_fields > 0)\n                    cacheit = TRUE;     /* can't change once set (XXX except for multiple result sets) */\n            }\n            else if (keylen==13 && strEQ(key, \"NUM_OF_PARAMS\")) {\n                D_imp_sth(h);\n                valuesv = newSViv(DBIc_NUM_PARAMS(imp_sth));\n                cacheit = TRUE; /* can't change */\n            }\n            break;\n\n          case 'P':\n            if (strEQ(key, \"PRECISION\"))\n                valuesv = &PL_sv_undef;\n            else if (strEQ(key, \"ParamValues\"))\n                valuesv = &PL_sv_undef;\n            else if (strEQ(key, \"ParamTypes\"))\n                valuesv = &PL_sv_undef;\n            break;\n\n          case 'R':\n            if (strEQ(key, \"RowsInCache\"))\n                valuesv = &PL_sv_undef;\n            break;\n\n          case 'S':\n            if (strEQ(key, \"SCALE\"))\n                valuesv = &PL_sv_undef;\n            break;\n\n          case 'T':\n            if (strEQ(key, \"TYPE\"))\n                valuesv = &PL_sv_undef;\n            break;\n        }\n\n    }\n    else\n    if (htype == DBIt_DB) {\n        /* this is here but is, sadly, not called because\n         * not-preloading them into the handle attrib cache caused\n         * wierdness in t/proxy.t that I never got to the bottom\n         * of. One day maybe.  */\n        if (keylen==6 && strEQ(key, \"Driver\")) {\n            D_imp_from_child(imp_dbh, imp_dbh_t, imp_xxh);\n            valuesv = newRV_inc((SV*)DBIc_MY_H(imp_dbh));\n            cacheit = FALSE;  /* else creates ref loop */\n        }\n    }\n\n    if (valuesv == Nullsv && htype <= DBIt_DB) {\n        if (keylen==10 && strEQ(key, \"AutoCommit\")) {\n            valuesv = boolSV(DBIc_has(imp_xxh,DBIcf_AutoCommit));\n        }\n    }\n\n    if (valuesv == Nullsv) {\n        switch (*key) {\n          case 'A':\n            if (keylen==6 && strEQ(key, \"Active\")) {\n                valuesv = boolSV(DBIc_ACTIVE(imp_xxh));\n            }\n            else if (keylen==10 && strEQ(key, \"ActiveKids\")) {\n                valuesv = newSViv(DBIc_ACTIVE_KIDS(imp_xxh));\n            }\n            else if (strEQ(key, \"AutoInactiveDestroy\")) {\n                valuesv = boolSV(DBIc_AIADESTROY(imp_xxh));\n            }\n            break;\n\n          case 'B':\n            if (keylen==9 && strEQ(key, \"BegunWork\")) {\n                valuesv = boolSV(DBIc_has(imp_xxh,DBIcf_BegunWork));\n            }\n            break;\n\n          case 'C':\n            if (strEQ(key, \"ChildHandles\")) {\n                svp = hv_fetch((HV*)SvRV(h), key, keylen, FALSE);\n                /* if something has been stored then return it.\n                 * otherwise return a dummy empty array if weakrefs are\n                 * available, else an undef to indicate that they're not */\n                if (svp) {\n                    valuesv = newSVsv(*svp);\n                } else {\n#ifdef sv_rvweaken\n                    valuesv = newRV_noinc((SV*)newAV());\n#else\n                    valuesv = &PL_sv_undef;\n#endif\n                }\n            }\n            else if (strEQ(key, \"ChopBlanks\")) {\n                valuesv = boolSV(DBIc_has(imp_xxh,DBIcf_ChopBlanks));\n            }\n            else if (strEQ(key, \"CachedKids\")) {\n                valuesv = &PL_sv_undef;\n            }\n            else if (strEQ(key, \"CompatMode\")) {\n                valuesv = boolSV(DBIc_COMPAT(imp_xxh));\n            }\n            break;\n\n          case 'E':\n            if (strEQ(key, \"Executed\")) {\n                valuesv = boolSV(DBIc_is(imp_xxh, DBIcf_Executed));\n            }\n            else if (strEQ(key, \"ErrCount\")) {\n                valuesv = newSVuv(DBIc_ErrCount(imp_xxh));\n            }\n            break;\n\n          case 'I':\n            if (strEQ(key, \"InactiveDestroy\")) {\n                valuesv = boolSV(DBIc_IADESTROY(imp_xxh));\n            }\n            break;\n\n          case 'K':\n            if (keylen==4 && strEQ(key, \"Kids\")) {\n                valuesv = newSViv(DBIc_KIDS(imp_xxh));\n            }\n            break;\n\n          case 'L':\n            if (keylen==11 && strEQ(key, \"LongReadLen\")) {\n                valuesv = newSVnv((NV)DBIc_LongReadLen(imp_xxh));\n            }\n            else if (keylen==11 && strEQ(key, \"LongTruncOk\")) {\n                valuesv = boolSV(DBIc_has(imp_xxh,DBIcf_LongTruncOk));\n            }\n            break;\n\n          case 'M':\n            if (keylen==10 && strEQ(key, \"MultiThread\")) {\n                valuesv = boolSV(DBIc_has(imp_xxh,DBIcf_MultiThread));\n            }\n            break;\n\n          case 'P':\n            if (keylen==10 && strEQ(key, \"PrintError\")) {\n                valuesv = boolSV(DBIc_has(imp_xxh,DBIcf_PrintError));\n            }\n            else if (keylen==9 && strEQ(key, \"PrintWarn\")) {\n                valuesv = boolSV(DBIc_has(imp_xxh,DBIcf_PrintWarn));\n            }\n            break;\n\n          case 'R':\n            if (keylen==10 && strEQ(key, \"RaiseError\")) {\n                valuesv = boolSV(DBIc_has(imp_xxh,DBIcf_RaiseError));\n            }\n            else if (keylen==9 && strEQ(key, \"RaiseWarn\")) {\n                valuesv = boolSV(DBIc_has(imp_xxh,DBIcf_RaiseWarn));\n            }\n            else if (keylen==12 && strEQ(key, \"RowCacheSize\")) {\n                valuesv = &PL_sv_undef;\n            }\n            break;\n\n          case 'S':\n            if (keylen==18 && strEQ(key, \"ShowErrorStatement\")) {\n                valuesv = boolSV(DBIc_has(imp_xxh,DBIcf_ShowErrorStatement));\n            }\n            break;\n\n          case 'T':\n            if (keylen==4 && strEQ(key, \"Type\")) {\n                char *type = dbih_htype_name(htype);\n                valuesv = newSVpv(type,0);\n                cacheit = TRUE; /* can't change */\n            }\n            else if (keylen==10  && strEQ(key, \"TraceLevel\")) {\n                valuesv = newSViv( DBIc_DEBUGIV(imp_xxh) );\n            }\n            else if (keylen==5  && strEQ(key, \"Taint\")) {\n                valuesv = boolSV(DBIc_has(imp_xxh,DBIcf_TaintIn) &&\n                                 DBIc_has(imp_xxh,DBIcf_TaintOut));\n            }\n            else if (keylen==7  && strEQ(key, \"TaintIn\")) {\n                valuesv = boolSV(DBIc_has(imp_xxh,DBIcf_TaintIn));\n            }\n            else if (keylen==8  && strEQ(key, \"TaintOut\")) {\n                valuesv = boolSV(DBIc_has(imp_xxh,DBIcf_TaintOut));\n            }\n            break;\n\n          case 'W':\n            if (keylen==4 && strEQ(key, \"Warn\")) {\n                valuesv = boolSV(DBIc_WARN(imp_xxh));\n            }\n            break;\n        }\n    }\n\n    /* finally check the actual hash */\n    if (valuesv == Nullsv) {\n        valuesv = &PL_sv_undef;\n        cacheit = 0;\n        svp = hv_fetch((HV*)SvRV(h), key, keylen, FALSE);\n        if (svp)\n            valuesv = newSVsv(*svp);    /* take copy to mortalize */\n        else /* warn unless it's known attribute name */\n        if ( !(         (*key=='H' && strEQ(key, \"HandleError\"))\n                ||      (*key=='H' && strEQ(key, \"HandleSetErr\"))\n                ||      (*key=='S' && strEQ(key, \"Statement\"))\n                ||      (*key=='P' && strEQ(key, \"ParamArrays\"))\n                ||      (*key=='P' && strEQ(key, \"ParamValues\"))\n                ||      (*key=='P' && strEQ(key, \"Profile\"))\n                ||      (*key=='R' && strEQ(key, \"ReadOnly\"))\n                ||      (*key=='C' && strEQ(key, \"CursorName\"))\n                ||      (*key=='C' && strEQ(key, \"Callbacks\"))\n                ||      (*key=='U' && strEQ(key, \"Username\"))\n                ||      !isUPPER(*key)  /* dbd_*, private_* etc */\n        ))\n            warn(\"Can't get %s->{%s}: unrecognised attribute name\",neatsvpv(h,0),key);\n    }\n\n    if (cacheit) {\n        (void)hv_store((HV*)SvRV(h), key, keylen, newSVsv(valuesv), 0);\n    }\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 3)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"    .. FETCH %s %s = %s%s\\n\", neatsvpv(h,0),\n            neatsvpv(keysv,0), neatsvpv(valuesv,0), cacheit?\" (cached)\":\"\");\n    if (valuesv == &PL_sv_yes || valuesv == &PL_sv_no || valuesv == &PL_sv_undef)\n        return valuesv; /* no need to mortalize yes or no */\n    return sv_2mortal(valuesv);\n}\n\n\n\n/* -------------------------------------------------------------------- */\n/* Functions implementing Error and Event Handling.                     */\n\n\nstatic SV *\ndbih_event(SV *hrv, const char *evtype, SV *a1, SV *a2)\n{\n    dTHX;\n    /* We arrive here via DBIh_EVENT* macros (see DBIXS.h) called from  */\n    /* DBD driver C code OR $h->event() method (in DBD::_::common)      */\n    /* XXX VERY OLD INTERFACE/CONCEPT MAY GO SOON */\n    /* OR MAY EVOLVE INTO A WAY TO HANDLE 'SUCCESS_WITH_INFO'/'WARNINGS' from db */\n    (void)hrv;\n    (void)evtype;\n    (void)a1;\n    (void)a2;\n    return &PL_sv_undef;\n}\n\n\n/* ----------------------------------------------------------------- */\n\n\nSTATIC I32\ndbi_dopoptosub_at(PERL_CONTEXT *cxstk, I32 startingblock)\n{\n    dTHX;\n    I32 i;\n    register PERL_CONTEXT *cx;\n    for (i = startingblock; i >= 0; i--) {\n        cx = &cxstk[i];\n        switch (CxTYPE(cx)) {\n        default:\n            continue;\n        case CXt_EVAL:\n        case CXt_SUB:\n#ifdef CXt_FORMAT\n        case CXt_FORMAT:\n#endif\n            DEBUG_l( Perl_deb(aTHX_ \"(Found sub #%ld)\\n\", (long)i));\n            return i;\n        }\n    }\n    return i;\n}\n\n\nstatic COP *\ndbi_caller_cop()\n{\n    dTHX;\n    register I32 cxix;\n    register PERL_CONTEXT *cx;\n    register PERL_CONTEXT *ccstack = cxstack;\n    PERL_SI *top_si = PL_curstackinfo;\n    char *stashname;\n\n    for ( cxix = dbi_dopoptosub_at(ccstack, cxstack_ix) ;; cxix = dbi_dopoptosub_at(ccstack, cxix - 1)) {\n        /* we may be in a higher stacklevel, so dig down deeper */\n        while (cxix < 0 && top_si->si_type != PERLSI_MAIN) {\n            top_si = top_si->si_prev;\n            ccstack = top_si->si_cxstack;\n            cxix = dbi_dopoptosub_at(ccstack, top_si->si_cxix);\n        }\n        if (cxix < 0) {\n            break;\n        }\n        if (PL_DBsub && cxix >= 0 && ccstack[cxix].blk_sub.cv == GvCV(PL_DBsub))\n            continue;\n        cx = &ccstack[cxix];\n        stashname = CopSTASHPV(cx->blk_oldcop);\n        if (!stashname)\n            continue;\n        if (!(stashname[0] == 'D' && stashname[1] == 'B'\n                && strchr(\"DI\", stashname[2])\n                    && (!stashname[3] || (stashname[3] == ':' && stashname[4] == ':'))))\n        {\n            return cx->blk_oldcop;\n        }\n        cxix = dbi_dopoptosub_at(ccstack, cxix - 1);\n    }\n    return NULL;\n}\n\nstatic void\ndbi_caller_string(SV *buf, COP *cop, char *prefix, int show_line, int show_path)\n{\n    dTHX;\n    STRLEN len;\n    long  line = CopLINE(cop);\n    char *file = SvPV(GvSV(CopFILEGV(cop)), len);\n    if (!show_path) {\n        char *sep;\n        if ( (sep=strrchr(file,'/')) || (sep=strrchr(file,'\\\\')))\n            file = sep+1;\n    }\n    if (show_line) {\n        sv_catpvf(buf, \"%s%s line %ld\", (prefix) ? prefix : \"\", file, line);\n    }\n    else {\n        sv_catpvf(buf, \"%s%s\",          (prefix) ? prefix : \"\", file);\n    }\n}\n\nstatic char *\nlog_where(SV *buf, int append, char *prefix, char *suffix, int show_line, int show_caller, int show_path)\n{\n    dTHX;\n    dTHR;\n    if (!buf)\n        buf = sv_2mortal(newSVpv(\"\",0));\n    else if (!append)\n        sv_setpv(buf,\"\");\n    if (CopLINE(PL_curcop)) {\n        COP *cop;\n        dbi_caller_string(buf, PL_curcop, prefix, show_line, show_path);\n        if (show_caller && (cop = dbi_caller_cop())) {\n            SV *via = sv_2mortal(newSVpv(\"\",0));\n            dbi_caller_string(via, cop, prefix, show_line, show_path);\n            sv_catpvf(buf, \" via %s\", SvPV_nolen(via));\n        }\n    }\n    if (PL_dirty)\n        sv_catpvf(buf, \" during global destruction\");\n    if (suffix)\n        sv_catpv(buf, suffix);\n    return SvPVX(buf);\n}\n\n\nstatic void\nclear_cached_kids(pTHX_ SV *h, imp_xxh_t *imp_xxh, const char *meth_name, int trace_level)\n{\n    if (DBIc_TYPE(imp_xxh) <= DBIt_DB) {\n        SV **svp = hv_fetch((HV*)SvRV(h), \"CachedKids\", 10, 0);\n        if (svp && SvROK(*svp) && SvTYPE(SvRV(*svp)) == SVt_PVHV) {\n            HV *hv = (HV*)SvRV(*svp);\n            if (HvKEYS(hv)) {\n                if (DBIc_TRACE_LEVEL(imp_xxh) > trace_level)\n                    trace_level = DBIc_TRACE_LEVEL(imp_xxh);\n                if (trace_level >= 2) {\n                    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"    >> %s %s clearing %d CachedKids\\n\",\n                        meth_name, neatsvpv(h,0), (int)HvKEYS(hv));\n                    PerlIO_flush(DBIc_LOGPIO(imp_xxh));\n                }\n                /* This will probably recurse through dispatch to DESTROY the kids */\n                /* For drh we should probably explicitly do dbh disconnects */\n                hv_clear(hv);\n            }\n        }\n    }\n}\n\n\nstatic NV\ndbi_time() {\n# ifdef HAS_GETTIMEOFDAY\n#   ifdef PERL_IMPLICIT_SYS\n    dTHX;\n#   endif\n    struct timeval when;\n    gettimeofday(&when, (struct timezone *) 0);\n    return when.tv_sec + (when.tv_usec / 1000000.0);\n# else  /* per-second is almost useless */\n# ifdef _WIN32 /* use _ftime() on Win32 (MS Visual C++ 6.0) */\n#  if defined(__BORLANDC__)\n#   define _timeb timeb\n#   define _ftime ftime\n#  endif\n    struct _timeb when;\n    _ftime( &when );\n    return when.time + (when.millitm / 1000.0);\n# else\n    return time(NULL);\n# endif\n# endif\n}\n\n\nstatic SV *\n_profile_next_node(SV *node, const char *name)\n{\n    /* step one level down profile Data tree and auto-vivify if required */\n    dTHX;\n    SV *orig_node = node;\n    if (SvROK(node))\n        node = SvRV(node);\n    if (SvTYPE(node) != SVt_PVHV) {\n        HV *hv = newHV();\n        if (SvOK(node)) {\n            char *key = \"(demoted)\";\n            warn(\"Profile data element %s replaced with new hash ref (for %s) and original value stored with key '%s'\",\n                neatsvpv(orig_node,0), name, key);\n            (void)hv_store(hv, key, strlen(key), SvREFCNT_inc(orig_node), 0);\n        }\n        sv_setsv(node, newRV_noinc((SV*)hv));\n        node = (SV*)hv;\n    }\n    node = *hv_fetch((HV*)node, name, strlen(name), 1);\n    return node;\n}\n\n\nstatic SV*\ndbi_profile(SV *h, imp_xxh_t *imp_xxh, SV *statement_sv, SV *method, NV t1, NV t2)\n{\n#define DBIprof_MAX_PATH_ELEM   100\n#define DBIprof_COUNT           0\n#define DBIprof_TOTAL_TIME      1\n#define DBIprof_FIRST_TIME      2\n#define DBIprof_MIN_TIME        3\n#define DBIprof_MAX_TIME        4\n#define DBIprof_FIRST_CALLED    5\n#define DBIprof_LAST_CALLED     6\n#define DBIprof_max_index       6\n    dTHX;\n    NV ti = t2 - t1;\n    int src_idx = 0;\n    HV *dbh_outer_hv = NULL;\n    HV *dbh_inner_hv = NULL;\n    char *statement_pv;\n    char *method_pv;\n    SV *profile;\n    SV *tmp;\n    SV *dest_node;\n    AV *av;\n    HV *h_hv;\n\n    const int call_depth = DBIc_CALL_DEPTH(imp_xxh);\n    const int parent_call_depth = DBIc_PARENT_COM(imp_xxh) ? DBIc_CALL_DEPTH(DBIc_PARENT_COM(imp_xxh)) : 0;\n    /* Only count calls originating from the application code   */\n    if (call_depth > 1 || parent_call_depth > 0)\n        return &PL_sv_undef;\n\n    if (!DBIc_has(imp_xxh, DBIcf_Profile))\n        return &PL_sv_undef;\n\n    method_pv = (SvTYPE(method)==SVt_PVCV) ? GvNAME(CvGV(method))\n                : isGV(method) ? GvNAME(method)\n                : SvOK(method) ? SvPV_nolen(method)\n                : \"\";\n\n    /* we don't profile DESTROY during global destruction */\n    if (PL_dirty && instr(method_pv, \"DESTROY\"))\n        return &PL_sv_undef;\n\n    h_hv = (HV*)SvRV(dbih_inner(aTHX_ h, \"dbi_profile\"));\n\n    profile = *hv_fetch(h_hv, \"Profile\", 7, 1);\n    if (profile && SvMAGICAL(profile))\n        mg_get(profile); /* FETCH */\n    if (!profile || !SvROK(profile)) {\n        DBIc_set(imp_xxh, DBIcf_Profile, 0); /* disable */\n        if (!PL_dirty) {\n            if (!profile)\n                warn(\"Profile attribute does not exist\");\n            else if (SvOK(profile))\n                warn(\"Profile attribute isn't a hash ref (%s,%ld)\", neatsvpv(profile,0), (long)SvTYPE(profile));\n        }\n        return &PL_sv_undef;\n    }\n\n    /* statement_sv: undef = use $h->{Statement}, \"\" (&sv_no) = use empty string */\n\n    if (!SvOK(statement_sv)) {\n        SV **psv = hv_fetch(h_hv, \"Statement\", 9, 0);\n        statement_sv = (psv && SvOK(*psv)) ? *psv : &PL_sv_no;\n    }\n    statement_pv = SvPV_nolen(statement_sv);\n\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 4)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"       dbi_profile +%\" NVff \"s %s %s\\n\",\n            ti, method_pv, neatsvpv(statement_sv,0));\n\n    dest_node = _profile_next_node(profile, \"Data\");\n\n    tmp = *hv_fetch((HV*)SvRV(profile), \"Path\", 4, 1);\n    if (SvROK(tmp) && SvTYPE(SvRV(tmp))==SVt_PVAV) {\n        int len;\n        av = (AV*)SvRV(tmp);\n        len = av_len(av); /* -1=empty, 0=one element */\n\n        while ( src_idx <= len ) {\n            SV *pathsv = AvARRAY(av)[src_idx++];\n\n            if (SvROK(pathsv) && SvTYPE(SvRV(pathsv))==SVt_PVCV) {\n                /* call sub, use returned list of values as path */\n                /* returning a ref to undef vetos this profile data */\n                dSP;\n                I32 ax;\n                SV *code_sv = SvRV(pathsv);\n                I32 items;\n                I32 item_idx;\n                EXTEND(SP, 4);\n                PUSHMARK(SP);\n                PUSHs(h);   /* push inner handle, then others params */\n                PUSHs( sv_2mortal(newSVpv(method_pv,0)));\n                PUTBACK;\n                SAVE_DEFSV; /* local($_) = $statement */\n                DEFSV_set(statement_sv);\n                items = call_sv(code_sv, G_ARRAY);\n                SPAGAIN;\n                SP -= items ;\n                ax = (SP - PL_stack_base) + 1 ;\n                for (item_idx=0; item_idx < items; ++item_idx) {\n                    SV *item_sv = ST(item_idx);\n                    if (SvROK(item_sv)) {\n                        if (!SvOK(SvRV(item_sv)))\n                            items = -2; /* flag that we're rejecting this profile data */\n                        else /* other refs reserved */\n                            warn(\"Ignored ref returned by code ref in Profile Path\");\n                        break;\n                    }\n                    dest_node = _profile_next_node(dest_node, (SvOK(item_sv) ? SvPV_nolen(item_sv) : \"undef\"));\n                }\n                PUTBACK;\n                if (items == -2) /* this profile data was vetoed */\n                    return &PL_sv_undef;\n            }\n            else if (SvROK(pathsv)) {\n                /* only meant for refs to scalars currently */\n                const char *p = SvPV_nolen(SvRV(pathsv));\n                dest_node = _profile_next_node(dest_node, p);\n            }\n            else if (SvOK(pathsv)) {\n                STRLEN len;\n                const char *p = SvPV(pathsv,len);\n                if (p[0] == '!') { /* special cases */\n                    if (p[1] == 'S' && strEQ(p, \"!Statement\")) {\n                        dest_node = _profile_next_node(dest_node, statement_pv);\n                    }\n                    else if (p[1] == 'M' && strEQ(p, \"!MethodName\")) {\n                        dest_node = _profile_next_node(dest_node, method_pv);\n                    }\n                    else if (p[1] == 'M' && strEQ(p, \"!MethodClass\")) {\n                        if (SvTYPE(method) == SVt_PVCV) {\n                            p = SvPV_nolen((SV*)CvGV(method));\n                        }\n                        else if (isGV(method)) {\n                            /* just using SvPV_nolen(method) sometimes causes an error: */\n                            /* \"Can't coerce GLOB to string\" so we use gv_efullname()   */\n                            SV *tmpsv = sv_2mortal(newSVpv(\"\",0));\n#if (PERL_VERSION < 6)\n                            gv_efullname(tmpsv, (GV*)method);\n#else\n                            gv_efullname4(tmpsv, (GV*)method, \"\", TRUE);\n#endif\n                            p = SvPV_nolen(tmpsv);\n                            if (*p == '*') ++p; /* skip past leading '*' glob sigil */\n                        }\n                        else {\n                            p = method_pv;\n                        }\n                        dest_node = _profile_next_node(dest_node, p);\n                    }\n                    else if (p[1] == 'F' && strEQ(p, \"!File\")) {\n                        dest_node = _profile_next_node(dest_node, log_where(0, 0, \"\", \"\", 0, 0, 0));\n                    }\n                    else if (p[1] == 'F' && strEQ(p, \"!File2\")) {\n                        dest_node = _profile_next_node(dest_node, log_where(0, 0, \"\", \"\", 0, 1, 0));\n                    }\n                    else if (p[1] == 'C' && strEQ(p, \"!Caller\")) {\n                        dest_node = _profile_next_node(dest_node, log_where(0, 0, \"\", \"\", 1, 0, 0));\n                    }\n                    else if (p[1] == 'C' && strEQ(p, \"!Caller2\")) {\n                        dest_node = _profile_next_node(dest_node, log_where(0, 0, \"\", \"\", 1, 1, 0));\n                    }\n                    else if (p[1] == 'T' && (strEQ(p, \"!Time\") || strnEQ(p, \"!Time~\", 6))) {\n                        char timebuf[20];\n                        int factor = 1;\n                        if (p[5] == '~') {\n                            factor = atoi(&p[6]);\n                            if (factor == 0) /* sanity check to avoid div by zero error */\n                                factor = 3600;\n                        }\n                        sprintf(timebuf, \"%ld\", ((long)(dbi_time()/factor))*factor);\n                        dest_node = _profile_next_node(dest_node, timebuf);\n                    }\n                    else {\n                        warn(\"Unknown ! element in DBI::Profile Path: %s\", p);\n                        dest_node = _profile_next_node(dest_node, p);\n                    }\n                }\n                else if (p[0] == '{' && p[len-1] == '}') { /* treat as name of dbh attribute to use */\n                    SV **attr_svp;\n                    if (!dbh_inner_hv) {        /* cache dbh handles the first time we need them */\n                        imp_dbh_t *imp_dbh = (DBIc_TYPE(imp_xxh) <= DBIt_DB) ? (imp_dbh_t*)imp_xxh : (imp_dbh_t*)DBIc_PARENT_COM(imp_xxh);\n                        dbh_outer_hv = DBIc_MY_H(imp_dbh);\n                        if (SvTYPE(dbh_outer_hv) != SVt_PVHV)\n                            return &PL_sv_undef;        /* presumably global destruction - bail */\n                        dbh_inner_hv = (HV*)SvRV(dbih_inner(aTHX_ (SV*)dbh_outer_hv, \"profile\"));\n                        if (SvTYPE(dbh_inner_hv) != SVt_PVHV)\n                            return &PL_sv_undef;        /* presumably global destruction - bail */\n                    }\n                    /* fetch from inner first, then outer if key doesn't exist */\n                    /* (yes, this is an evil premature optimization) */\n                    p += 1; len -= 2; /* ignore the braces */\n                    if ((attr_svp = hv_fetch(dbh_inner_hv, p, len, 0)) == NULL) {\n                        /* try outer (tied) hash - for things like AutoCommit   */\n                        /* (will always return something even for unknowns)     */\n                        if ((attr_svp = hv_fetch(dbh_outer_hv, p, len, 0))) {\n                            if (SvGMAGICAL(*attr_svp))\n                                mg_get(*attr_svp); /* FETCH */\n                        }\n                    }\n                    if (!attr_svp)\n                        p -= 1; /* unignore the braces */\n                    else if (!SvOK(*attr_svp))\n                        p = \"\";\n                    else if (!SvTRUE(*attr_svp) && SvPOK(*attr_svp) && SvNIOK(*attr_svp))\n                        p = \"0\"; /* catch &sv_no style special case */\n                    else\n                        p = SvPV_nolen(*attr_svp);\n                    dest_node = _profile_next_node(dest_node, p);\n                }\n                else {\n                    dest_node = _profile_next_node(dest_node, p);\n                }\n            }\n            /* else undef, so ignore */\n        }\n    }\n    else { /* a bad Path value is treated as a Path of just Statement */\n        dest_node = _profile_next_node(dest_node, statement_pv);\n    }\n\n\n    if (!SvOK(dest_node)) {\n        av = newAV();\n        sv_setsv(dest_node, newRV_noinc((SV*)av));\n        av_store(av, DBIprof_COUNT,             newSViv(1));\n        av_store(av, DBIprof_TOTAL_TIME,        newSVnv(ti));\n        av_store(av, DBIprof_FIRST_TIME,        newSVnv(ti));\n        av_store(av, DBIprof_MIN_TIME,          newSVnv(ti));\n        av_store(av, DBIprof_MAX_TIME,          newSVnv(ti));\n        av_store(av, DBIprof_FIRST_CALLED,      newSVnv(t1));\n        av_store(av, DBIprof_LAST_CALLED,       newSVnv(t1));\n    }\n    else {\n        tmp = dest_node;\n        if (SvROK(tmp))\n            tmp = SvRV(tmp);\n        if (SvTYPE(tmp) != SVt_PVAV)\n            croak(\"Invalid Profile data leaf element: %s (type %ld)\",\n                    neatsvpv(tmp,0), (long)SvTYPE(tmp));\n        av = (AV*)tmp;\n        sv_inc( *av_fetch(av, DBIprof_COUNT, 1));\n        tmp = *av_fetch(av, DBIprof_TOTAL_TIME, 1);\n        sv_setnv(tmp, SvNV(tmp) + ti);\n        tmp = *av_fetch(av, DBIprof_MIN_TIME, 1);\n        if (ti < SvNV(tmp)) sv_setnv(tmp, ti);\n        tmp = *av_fetch(av, DBIprof_MAX_TIME, 1);\n        if (ti > SvNV(tmp)) sv_setnv(tmp, ti);\n        sv_setnv( *av_fetch(av, DBIprof_LAST_CALLED, 1), t1);\n    }\n    return dest_node; /* use with caution - copy first, ie sv_mortalcopy() */\n}\n\n\nstatic void\ndbi_profile_merge_nodes(SV *dest, SV *increment)\n{\n    dTHX;\n    AV *d_av, *i_av;\n    SV *tmp;\n    SV *tmp2;\n    NV i_nv;\n    int i_is_earlier;\n\n    if (!SvROK(dest) || SvTYPE(SvRV(dest)) != SVt_PVAV)\n        croak(\"dbi_profile_merge_nodes(%s, ...) requires array ref\", neatsvpv(dest,0));\n    d_av = (AV*)SvRV(dest);\n\n    if (av_len(d_av) < DBIprof_max_index) {\n        int idx;\n        av_extend(d_av, DBIprof_max_index);\n        for(idx=0; idx<=DBIprof_max_index; ++idx) {\n            tmp = *av_fetch(d_av, idx, 1);\n            if (!SvOK(tmp) && idx != DBIprof_MIN_TIME && idx != DBIprof_FIRST_CALLED)\n                sv_setnv(tmp, 0.0); /* leave 'min' values as undef */\n        }\n    }\n\n    if (!SvOK(increment))\n        return;\n\n    if (SvROK(increment) && SvTYPE(SvRV(increment)) == SVt_PVHV) {\n        HV *hv = (HV*)SvRV(increment);\n        char *key;\n        I32 keylen = 0;\n        hv_iterinit(hv);\n        while ( (tmp = hv_iternextsv(hv, &key, &keylen)) != NULL ) {\n            dbi_profile_merge_nodes(dest, tmp);\n        };\n        return;\n    }\n\n    if (!SvROK(increment) || SvTYPE(SvRV(increment)) != SVt_PVAV)\n        croak(\"dbi_profile_merge_nodes: increment %s not an array or hash ref\", neatsvpv(increment,0));\n    i_av = (AV*)SvRV(increment);\n\n    tmp  = *av_fetch(d_av, DBIprof_COUNT, 1);\n    tmp2 = *av_fetch(i_av, DBIprof_COUNT, 1);\n    if (SvIOK(tmp) && SvIOK(tmp2))\n        sv_setiv( tmp, SvIV(tmp) + SvIV(tmp2) );\n    else\n        sv_setnv( tmp, SvNV(tmp) + SvNV(tmp2) );\n\n    tmp = *av_fetch(d_av, DBIprof_TOTAL_TIME, 1);\n    sv_setnv( tmp, SvNV(tmp) + SvNV( *av_fetch(i_av, DBIprof_TOTAL_TIME, 1)) );\n\n    i_nv = SvNV(*av_fetch(i_av, DBIprof_MIN_TIME, 1));\n    tmp  =      *av_fetch(d_av, DBIprof_MIN_TIME, 1);\n    if (!SvOK(tmp) || i_nv < SvNV(tmp)) sv_setnv(tmp, i_nv);\n\n    i_nv = SvNV(*av_fetch(i_av, DBIprof_MAX_TIME, 1));\n    tmp  =      *av_fetch(d_av, DBIprof_MAX_TIME, 1);\n    if (i_nv > SvNV(tmp)) sv_setnv(tmp, i_nv);\n\n    i_nv = SvNV(*av_fetch(i_av, DBIprof_FIRST_CALLED, 1));\n    tmp  =      *av_fetch(d_av, DBIprof_FIRST_CALLED, 1);\n    i_is_earlier = (!SvOK(tmp) || i_nv < SvNV(tmp));\n    if (i_is_earlier)\n        sv_setnv(tmp, i_nv);\n\n    i_nv = SvNV(*av_fetch(i_av, DBIprof_FIRST_TIME, 1));\n    tmp  =      *av_fetch(d_av, DBIprof_FIRST_TIME, 1);\n    if (i_is_earlier || !SvOK(tmp)) {\n        /* If the increment has an earlier DBIprof_FIRST_CALLED\n        then we set the DBIprof_FIRST_TIME from the increment */\n        sv_setnv(tmp, i_nv);\n    }\n\n    i_nv = SvNV(*av_fetch(i_av, DBIprof_LAST_CALLED, 1));\n    tmp  =      *av_fetch(d_av, DBIprof_LAST_CALLED, 1);\n    if (i_nv > SvNV(tmp)) sv_setnv(tmp, i_nv);\n}\n\n\n/* ----------------------------------------------------------------- */\n/* ---   The DBI dispatcher. The heart of the perl DBI.          --- */\n\nXS(XS_DBI_dispatch);            /* prototype to pass -Wmissing-prototypes */\nXS(XS_DBI_dispatch)\n{\n    dXSARGS;\n    dORIGMARK;\n    dMY_CXT;\n\n    SV *h   = ST(0);            /* the DBI handle we are working with   */\n    SV *st1 = ST(1);            /* used in debugging */\n    SV *st2 = ST(2);            /* used in debugging */\n    SV *orig_h = h;\n    SV *err_sv;\n    SV **tmp_svp;\n    SV **hook_svp = 0;\n    MAGIC *mg;\n    int gimme = GIMME;\n    I32 trace_flags = DBIS->debug;      /* local copy may change during dispatch */\n    I32 trace_level = (trace_flags & DBIc_TRACE_LEVEL_MASK);\n    int is_DESTROY;\n    meth_types meth_type;\n    int is_unrelated_to_Statement = 0;\n    U32 keep_error = FALSE;\n    UV  ErrCount = UV_MAX;\n    int i, outitems;\n    int call_depth;\n    int is_nested_call;\n    NV profile_t1 = 0.0;\n    int is_orig_method_name = 1;\n\n    const char  *meth_name = GvNAME(CvGV(cv));\n    dbi_ima_t *ima = (dbi_ima_t*)CvXSUBANY(cv).any_ptr;\n    U32   ima_flags;\n    imp_xxh_t   *imp_xxh   = NULL;\n    SV          *imp_msv   = Nullsv;\n    SV          *qsv       = Nullsv; /* quick result from a shortcut method   */\n\n\n#ifdef BROKEN_DUP_ANY_PTR\n    if (ima->my_perl != my_perl) {\n        /* we couldn't dup the ima struct at clone time, so do it now */\n        dbi_ima_t *nima;\n        Newx(nima, 1, dbi_ima_t);\n        *nima = *ima; /* structure copy */\n        CvXSUBANY(cv).any_ptr = nima;\n        nima->stash = NULL;\n        nima->gv    = NULL;\n        nima->my_perl = my_perl;\n        ima = nima;\n    }\n#endif\n\n    ima_flags  = ima->flags;\n    meth_type = ima->meth_type;\n    if (trace_level >= 9) {\n        PerlIO *logfp = DBILOGFP;\n        PerlIO_printf(logfp,\"%c   >> %-11s DISPATCH (%s rc%ld/%ld @%ld g%x ima%lx pid#%ld)\",\n            (PL_dirty?'!':' '), meth_name, neatsvpv(h,0),\n            (long)SvREFCNT(h), (SvROK(h) ? (long)SvREFCNT(SvRV(h)) : (long)-1),\n            (long)items, (int)gimme, (long)ima_flags, (long)PerlProc_getpid());\n        PerlIO_puts(logfp, log_where(0, 0, \" at \",\"\\n\", 1, (trace_level >= 3), (trace_level >= 4)));\n        PerlIO_flush(logfp);\n    }\n\n    if ( ( (is_DESTROY=(meth_type == methtype_DESTROY))) ) {\n        /* note that croak()'s won't propagate, only append to $@ */\n        keep_error = TRUE;\n    }\n\n    /* If h is a tied hash ref, switch to the inner ref 'behind' the tie.\n       This means *all* DBI methods work with the inner (non-tied) ref.\n       This makes it much easier for methods to access the real hash\n       data (without having to go through FETCH and STORE methods) and\n       for tie and non-tie methods to call each other.\n    */\n    if (SvROK(h)\n        && SvRMAGICAL(SvRV(h))\n        && (\n               ((mg=SvMAGIC(SvRV(h)))->mg_type == 'P')\n            || ((mg=mg_find(SvRV(h),'P')) != NULL)\n           )\n    ) {\n        if (mg->mg_obj==NULL || !SvOK(mg->mg_obj) || SvRV(mg->mg_obj)==NULL) {  /* maybe global destruction */\n            if (trace_level >= 3)\n                PerlIO_printf(DBILOGFP,\n                    \"%c   <> %s for %s ignored (inner handle gone)\\n\",\n                    (PL_dirty?'!':' '), meth_name, neatsvpv(h,0));\n            XSRETURN(0);\n        }\n        /* Distinguish DESTROY of tie (outer) from DESTROY of inner ref */\n        /* This may one day be used to manually destroy extra internal  */\n        /* refs if the application ceases to use the handle.            */\n        if (is_DESTROY) {\n            imp_xxh = DBIh_COM(mg->mg_obj);\n#ifdef DBI_USE_THREADS\n            if (imp_xxh && DBIc_THR_USER(imp_xxh) != my_perl) {\n                goto is_DESTROY_wrong_thread;\n            }\n#endif\n            if (imp_xxh && DBIc_TYPE(imp_xxh) <= DBIt_DB)\n                clear_cached_kids(aTHX_ mg->mg_obj, imp_xxh, meth_name, trace_level);\n            /* XXX might be better to move this down to after call_depth has been\n             * incremented and then also SvREFCNT_dec(mg->mg_obj) to force an immediate\n             * DESTROY of the inner handle if there are no other refs to it.\n             * That way the inner DESTROY is properly flagged as a nested call,\n             * and the outer DESTROY gets profiled more accurately, and callbacks work.\n             */\n            if (trace_level >= 3) {\n                PerlIO_printf(DBILOGFP,\n                    \"%c   <> DESTROY(%s) ignored for outer handle (inner %s has ref cnt %ld)\\n\",\n                    (PL_dirty?'!':' '), neatsvpv(h,0), neatsvpv(mg->mg_obj,0),\n                    (long)SvREFCNT(SvRV(mg->mg_obj))\n                );\n            }\n            /* for now we ignore it since it'll be followed soon by     */\n            /* a destroy of the inner hash and that'll do the real work */\n\n            /* However, we must at least modify DBIc_MY_H() as that is  */\n            /* pointing (without a refcnt inc) to the scalar that is    */\n            /* being destroyed, so it'll contain random values later.   */\n            if (imp_xxh)\n                DBIc_MY_H(imp_xxh) = (HV*)SvRV(mg->mg_obj); /* inner (untied) HV */\n\n            XSRETURN(0);\n        }\n        h = mg->mg_obj; /* switch h to inner ref                        */\n        ST(0) = h;      /* switch handle on stack to inner ref          */\n    }\n\n    imp_xxh = dbih_getcom2(aTHX_ h, 0); /* get common Internal Handle Attributes        */\n    if (!imp_xxh) {\n        if (meth_type == methtype_can) {  /* ref($h)->can(\"foo\")        */\n            const char *can_meth = SvPV_nolen(st1);\n            SV *rv = &PL_sv_undef;\n            GV *gv = gv_fetchmethod_autoload(gv_stashsv(orig_h,FALSE), can_meth, FALSE);\n            if (gv && isGV(gv))\n                rv = sv_2mortal(newRV_inc((SV*)GvCV(gv)));\n            if (trace_level >= 1) {\n                PerlIO_printf(DBILOGFP,\"    <- %s(%s) = %p\\n\", meth_name, can_meth, neatsvpv(rv,0));\n            }\n            ST(0) = rv;\n            XSRETURN(1);\n        }\n        if (trace_level)\n            PerlIO_printf(DBILOGFP, \"%c   <> %s for %s ignored (no imp_data)\\n\",\n                (PL_dirty?'!':' '), meth_name, neatsvpv(h,0));\n        if (!is_DESTROY)\n            warn(\"Can't call %s method on handle %s%s\", meth_name, neatsvpv(h,0),\n                SvROK(h) ? \" after take_imp_data()\" : \" (not a reference)\");\n        XSRETURN(0);\n    }\n\n    if (DBIc_has(imp_xxh,DBIcf_Profile)) {\n        profile_t1 = dbi_time(); /* just get start time here */\n    }\n\n#ifdef DBI_USE_THREADS\n{\n    PerlInterpreter * h_perl;\n    is_DESTROY_wrong_thread:\n    h_perl = DBIc_THR_USER(imp_xxh) ;\n    if (h_perl != my_perl) {\n        /* XXX could call a 'handle clone' method here?, for dbh's at least */\n        if (is_DESTROY) {\n            if (trace_level >= 3) {\n                PerlIO_printf(DBILOGFP,\"    DESTROY ignored because DBI %sh handle (%s) is owned by thread %p not current thread %p\\n\",\n                      dbih_htype_name(DBIc_TYPE(imp_xxh)), HvNAME(DBIc_IMP_STASH(imp_xxh)),\n                      (void*)DBIc_THR_USER(imp_xxh), (void*)my_perl) ;\n                PerlIO_flush(DBILOGFP);\n            }\n            XSRETURN(0); /* don't DESTROY handle, if it is not our's !*/\n        }\n        croak(\"%s %s failed: handle %d is owned by thread %lx not current thread %lx (%s)\",\n            HvNAME(DBIc_IMP_STASH(imp_xxh)), meth_name, DBIc_TYPE(imp_xxh),\n            (unsigned long)h_perl, (unsigned long)my_perl,\n            \"handles can't be shared between threads and your driver may need a CLONE method added\");\n    }\n}\n#endif\n\n    if ((i = DBIc_DEBUGIV(imp_xxh))) { /* merge handle into global */\n        I32 h_trace_level = (i & DBIc_TRACE_LEVEL_MASK);\n        if ( h_trace_level > trace_level )\n            trace_level = h_trace_level;\n        trace_flags = (trace_flags & ~DBIc_TRACE_LEVEL_MASK)\n                    | (          i & ~DBIc_TRACE_LEVEL_MASK)\n                    | trace_level;\n    }\n\n    /* Check method call against Internal Method Attributes */\n    if (ima_flags) {\n\n        if (ima_flags & (IMA_STUB|IMA_FUNC_REDIRECT|IMA_KEEP_ERR|IMA_KEEP_ERR_SUB|IMA_CLEAR_STMT)) {\n\n            if (ima_flags & IMA_STUB) {\n                if (meth_type == methtype_can) {\n                    const char *can_meth = SvPV_nolen(st1);\n                    SV *dbi_msv = Nullsv;\n                    /* find handle implementors method (GV or CV) */\n                    if ( (imp_msv = (SV*)gv_fetchmethod_autoload(DBIc_IMP_STASH(imp_xxh), can_meth, FALSE)) ) {\n                        /* return DBI's CV, not the implementors CV (else we'd bypass dispatch) */\n                        /* and anyway, we may have hit a private method not part of the DBI     */\n                        GV *gv = gv_fetchmethod_autoload(SvSTASH(SvRV(orig_h)), can_meth, FALSE);\n                        if (gv && isGV(gv))\n                            dbi_msv = (SV*)GvCV(gv);\n                    }\n                    if (trace_level >= 1) {\n                        PerlIO *logfp = DBILOGFP;\n                        PerlIO_printf(logfp,\"    <- %s(%s) = %p (%s %p)\\n\", meth_name, can_meth, (void*)dbi_msv,\n                                (imp_msv && isGV(imp_msv)) ? HvNAME(GvSTASH(imp_msv)) : \"?\", (void*)imp_msv);\n                    }\n                    ST(0) = (dbi_msv) ? sv_2mortal(newRV_inc(dbi_msv)) : &PL_sv_undef;\n                    XSRETURN(1);\n                }\n                XSRETURN(0);\n            }\n            if (ima_flags & IMA_FUNC_REDIRECT) {\n                /* XXX this doesn't redispatch, nor consider the IMA of the new method */\n                SV *meth_name_sv = POPs;\n                PUTBACK;\n                --items;\n                if (!SvPOK(meth_name_sv) || SvNIOK(meth_name_sv))\n                    croak(\"%s->%s() invalid redirect method name %s\",\n                            neatsvpv(h,0), meth_name, neatsvpv(meth_name_sv,0));\n                meth_name = SvPV_nolen(meth_name_sv);\n                meth_type = get_meth_type(meth_name);\n                is_orig_method_name = 0;\n            }\n            if (ima_flags & IMA_KEEP_ERR)\n                keep_error = TRUE;\n            if ((ima_flags & IMA_KEEP_ERR_SUB)\n                && !PL_dirty\n                && DBIc_PARENT_COM(imp_xxh) && DBIc_CALL_DEPTH(DBIc_PARENT_COM(imp_xxh)) > 0)\n                keep_error = TRUE;\n            if (ima_flags & IMA_CLEAR_STMT) {\n                /* don't use SvOK_off: dbh's Statement may be ref to sth's */\n                (void)hv_store((HV*)SvRV(h), \"Statement\", 9, &PL_sv_undef, 0);\n            }\n            if (ima_flags & IMA_CLEAR_CACHED_KIDS)\n                clear_cached_kids(aTHX_ h, imp_xxh, meth_name, trace_flags);\n\n        }\n\n        if (ima_flags & IMA_HAS_USAGE) {\n            const char *err = NULL;\n            char msg[200];\n\n            if (ima->minargs && (items < ima->minargs\n                                || (ima->maxargs>0 && items > ima->maxargs))) {\n                sprintf(msg,\n                    \"DBI %s: invalid number of arguments: got handle + %ld, expected handle + between %d and %d\\n\",\n                    meth_name, (long)items-1, (int)ima->minargs-1, (int)ima->maxargs-1);\n                err = msg;\n            }\n            /* arg type checking could be added here later */\n            if (err) {\n                croak(\"%sUsage: %s->%s(%s)\", err, \"$h\", meth_name,\n                    (ima->usage_msg) ? ima->usage_msg : \"...?\");\n            }\n        }\n    }\n\n    is_unrelated_to_Statement = ( (DBIc_TYPE(imp_xxh) == DBIt_ST) ? 0\n                                : (DBIc_TYPE(imp_xxh) == DBIt_DR) ? 1\n                                : (ima_flags & IMA_UNRELATED_TO_STMT) );\n\n    if (PL_tainting && items > 1              /* method call has args   */\n        && DBIc_is(imp_xxh, DBIcf_TaintIn)    /* taint checks requested */\n        && !(ima_flags & IMA_NO_TAINT_IN)\n    ) {\n        for(i=1; i < items; ++i) {\n            if (SvTAINTED(ST(i))) {\n                char buf[100];\n                sprintf(buf,\"parameter %d of %s->%s method call\",\n                        i, SvPV_nolen(h), meth_name);\n                PL_tainted = 1; /* needed for TAINT_PROPER to work      */\n                TAINT_PROPER(buf);      /* die's */\n            }\n        }\n    }\n\n    /* record this inner handle for use by DBI::var::FETCH      */\n    if (is_DESTROY) {\n\n        /* force destruction of any outstanding children */\n        if ((tmp_svp = hv_fetch((HV*)SvRV(h), \"ChildHandles\", 12, FALSE)) && SvROK(*tmp_svp)) {\n            AV *av = (AV*)SvRV(*tmp_svp);\n            I32 kidslots;\n            PerlIO *logfp = DBILOGFP;\n\n            for (kidslots = AvFILL(av); kidslots >= 0; --kidslots) {\n                SV **hp = av_fetch(av, kidslots, FALSE);\n                if (!hp || !SvROK(*hp) || SvTYPE(SvRV(*hp))!=SVt_PVHV)\n                    break;\n\n                if (trace_level >= 1) {\n                    PerlIO_printf(logfp, \"on DESTROY handle %s still has child %s (refcnt %ld, obj %d, dirty=%d)\\n\",\n                        neatsvpv(h,0), neatsvpv(*hp, 0), (long)SvREFCNT(*hp), !!sv_isobject(*hp), PL_dirty);\n                    if (trace_level >= 9)\n                        sv_dump(SvRV(*hp));\n                }\n                if (sv_isobject(*hp)) { /* call DESTROY on the handle */\n                    PUSHMARK(SP);\n                    XPUSHs(*hp);\n                    PUTBACK;\n                    call_method(\"DESTROY\", G_VOID|G_EVAL|G_KEEPERR);\n                    MSPAGAIN;\n                }\n                else {\n                    imp_xxh_t *imp_xxh = dbih_getcom2(aTHX_ *hp, 0);\n                    if (imp_xxh && DBIc_COMSET(imp_xxh)) {\n                        dbih_clearcom(imp_xxh);\n                        sv_setsv(*hp, &PL_sv_undef);\n                    }\n                }\n            }\n        }\n\n        if (DBIc_TYPE(imp_xxh) <= DBIt_DB ) {   /* is dbh or drh */\n            imp_xxh_t *parent_imp;\n\n            if (SvOK(DBIc_ERR(imp_xxh)) && (parent_imp = DBIc_PARENT_COM(imp_xxh))\n                && !PL_dirty /* XXX - remove? */\n            ) {\n                /* copy err/errstr/state values to $DBI::err etc still work */\n                sv_setsv(DBIc_ERR(parent_imp),    DBIc_ERR(imp_xxh));\n                sv_setsv(DBIc_ERRSTR(parent_imp), DBIc_ERRSTR(imp_xxh));\n                sv_setsv(DBIc_STATE(parent_imp),  DBIc_STATE(imp_xxh));\n            }\n        }\n\n        if (DBIc_AIADESTROY(imp_xxh)) { /* wants ineffective destroy after fork */\n            if ((U32)PerlProc_getpid() != _imp2com(imp_xxh, std.pid))\n                DBIc_set(imp_xxh, DBIcf_IADESTROY, 1);\n        }\n        if (DBIc_IADESTROY(imp_xxh)) {  /* wants ineffective destroy    */\n            DBIc_ACTIVE_off(imp_xxh);\n        }\n        call_depth = 0;\n        is_nested_call = 0;\n    }\n    else {\n        DBI_SET_LAST_HANDLE(h);\n        SAVEINT(DBIc_CALL_DEPTH(imp_xxh));\n        call_depth = ++DBIc_CALL_DEPTH(imp_xxh);\n\n        if (ima_flags & IMA_COPY_UP_STMT) { /* execute() */\n            copy_statement_to_parent(aTHX_ h, imp_xxh);\n        }\n        is_nested_call =\n            (call_depth > 1\n                || (!PL_dirty /* not in global destruction [CPAN #75614] */\n                    && DBIc_PARENT_COM(imp_xxh)\n                    && DBIc_CALL_DEPTH(DBIc_PARENT_COM(imp_xxh))) >= 1);\n\n    }\n\n\n    /* --- dispatch --- */\n\n    if (!keep_error && meth_type != methtype_set_err) {\n        SV *err_sv;\n        if (trace_level && SvOK(err_sv=DBIc_ERR(imp_xxh))) {\n            PerlIO *logfp = DBILOGFP;\n            PerlIO_printf(logfp, \"    !! The %s '%s' was CLEARED by call to %s method\\n\",\n                SvTRUE(err_sv) ? \"ERROR\" : strlen(SvPV_nolen(err_sv)) ? \"warn\" : \"info\",\n                neatsvpv(DBIc_ERR(imp_xxh),0), meth_name);\n        }\n        DBIh_CLEAR_ERROR(imp_xxh);\n    }\n    else {      /* we check for change in ErrCount/err_hash during call */\n        ErrCount = DBIc_ErrCount(imp_xxh);\n        if (keep_error)\n            keep_error = err_hash(aTHX_ imp_xxh);\n    }\n\n    if (DBIc_has(imp_xxh,DBIcf_Callbacks)\n        && (tmp_svp = hv_fetch((HV*)SvRV(h), \"Callbacks\", 9, 0))\n        && (   (hook_svp = hv_fetch((HV*)SvRV(*tmp_svp), meth_name, strlen(meth_name), 0))\n              /* the \"*\" fallback callback only applies to non-nested calls\n               * and also doesn't apply to the 'set_err' or DESTROY methods.\n               * Nor during global destruction.\n               * Other restrictions may be added over time.\n               * It's an undocumented hack.\n               */\n          || (!is_nested_call && !PL_dirty && meth_type != methtype_set_err &&\n               meth_type != methtype_DESTROY &&\n               (hook_svp = hv_fetch((HV*)SvRV(*tmp_svp), \"*\", 1, 0))\n             )\n        )\n        && SvROK(*hook_svp)\n    ) {\n        SV *orig_defsv;\n        SV *temp_defsv;\n        SV *code = SvRV(*hook_svp);\n        I32 skip_dispatch = 0;\n        if (trace_level)\n            PerlIO_printf(DBILOGFP, \"%c   {{ %s callback %s being invoked with %ld args\\n\",\n                (PL_dirty?'!':' '), meth_name, neatsvpv(*hook_svp,0), (long)items);\n\n        /* we don't use ENTER,SAVETMPS & FREETMPS,LEAVE because we may need mortal\n         * results to live long enough to be returned to our caller\n         */\n        /* we want to localize $_ for the callback but can't just do that alone\n         * because we're not using SAVETMPS & FREETMPS, so we have to get sneaky.\n         * We still localize, so we're safe from the callback die-ing,\n         * but after the callback we manually restore the original $_.\n         */\n        orig_defsv = DEFSV; /* remember the current $_ */\n        SAVE_DEFSV;         /* local($_) = $method_name */\n        temp_defsv = sv_2mortal(newSVpv(meth_name,0));\n# ifdef SvTEMP_off\n        SvTEMP_off(temp_defsv);\n# endif\n        DEFSV_set(temp_defsv);\n\n        EXTEND(SP, items+1);\n        PUSHMARK(SP);\n        PUSHs(orig_h);                  /* push outer handle, then others params */\n        for (i=1; i < items; ++i) {     /* start at 1 to skip handle */\n            PUSHs( ST(i) );\n        }\n        PUTBACK;\n        outitems = call_sv(code, G_ARRAY); /* call the callback code */\n        MSPAGAIN;\n\n        /* The callback code can undef $_ to indicate to skip dispatch */\n        skip_dispatch = !SvOK(DEFSV);\n        /* put $_ back now, but with an incremented ref count to compensate\n         * for the ref count decrement that will happen when we exit the scope.\n         */\n        DEFSV_set(SvREFCNT_inc(orig_defsv));\n\n        if (trace_level)\n            PerlIO_printf(DBILOGFP, \"%c   }} %s callback %s returned%s\\n\",\n                (PL_dirty?'!':' '), meth_name, neatsvpv(*hook_svp,0),\n                skip_dispatch ? \", actual method will not be called\" : \"\"\n            );\n        if (skip_dispatch) {    /* XXX experimental */\n            int ix = outitems;\n            /* copy the new items down to the destination list */\n            while (ix-- > 0) {\n                if(0)warn(\"\\tcopy down %d: %s overwriting %s\\n\", ix, SvPV_nolen(TOPs), SvPV_nolen(ST(ix)) );\n                ST(ix) = POPs;\n            }\n            imp_msv = *hook_svp; /* for trace and profile */\n            goto post_dispatch;\n        }\n        else {\n            if (outitems != 0)\n                die(\"Callback for %s returned %d values but must not return any (temporary restriction in current version)\",\n                        meth_name, (int)outitems);\n            /* POP's and PUTBACK? to clear stack */\n        }\n    }\n\n    /* set Executed after Callbacks so it's not set if callback elects to skip the method */\n    if (ima_flags & IMA_EXECUTE) {\n        imp_xxh_t *parent = DBIc_PARENT_COM(imp_xxh);\n        DBIc_on(imp_xxh, DBIcf_Executed);\n        if (parent)\n            DBIc_on(parent, DBIcf_Executed);\n    }\n\n    /* The \"quick_FETCH\" logic...                                       */\n    /* Shortcut for fetching attributes to bypass method call overheads */\n    if (meth_type == methtype_FETCH && !DBIc_COMPAT(imp_xxh)) {\n        STRLEN kl;\n        const char *key = SvPV(st1, kl);\n        SV **attr_svp;\n        if (*key != '_' && (attr_svp=hv_fetch((HV*)SvRV(h), key, kl, 0))) {\n            qsv = *attr_svp;\n            /* disable FETCH from cache for special attributes */\n            if (SvROK(qsv) && SvTYPE(SvRV(qsv))==SVt_PVHV && *key=='D' &&\n                (  (kl==6 && DBIc_TYPE(imp_xxh)==DBIt_DB && strEQ(key,\"Driver\"))\n                || (kl==8 && DBIc_TYPE(imp_xxh)==DBIt_ST && strEQ(key,\"Database\")) )\n            ) {\n                qsv = Nullsv;\n            }\n            /* disable profiling of FETCH of Profile data */\n            if (*key == 'P' && strEQ(key, \"Profile\"))\n                profile_t1 = 0.0;\n        }\n        if (qsv) { /* skip real method call if we already have a 'quick' value */\n            ST(0) = sv_mortalcopy(qsv);\n            outitems = 1;\n            goto post_dispatch;\n        }\n    }\n\n    {\n        CV *meth_cv;\n#ifdef DBI_save_hv_fetch_ent\n        HE save_mh;\n        if (meth_type == methtype_FETCH)\n            save_mh = PL_hv_fetch_ent_mh; /* XXX nested tied FETCH bug17575 workaround */\n#endif\n\n        if (trace_flags) {\n            SAVEI32(DBIS->debug);       /* fall back to orig value later */\n            DBIS->debug = trace_flags;  /* make new value global (for now) */\n            if (ima) {\n                /* enabling trace via flags takes precedence over disabling due to min level */\n                if ((trace_flags & DBIc_TRACE_FLAGS_MASK) & (ima->method_trace & DBIc_TRACE_FLAGS_MASK))\n                    trace_level = (trace_level < 2) ? 2 : trace_level; /* min */\n                else\n                if (trace_level < (DBIc_TRACE_LEVEL_MASK & ima->method_trace))\n                    trace_level = 0;        /* silence dispatch log for this method */\n            }\n        }\n\n        if (is_orig_method_name\n            && ima->stash == DBIc_IMP_STASH(imp_xxh)\n            && ima->generation == PL_sub_generation +\n                                        MY_cache_gen(DBIc_IMP_STASH(imp_xxh))\n        )\n            imp_msv = (SV*)ima->gv;\n        else {\n            imp_msv = (SV*)gv_fetchmethod_autoload(DBIc_IMP_STASH(imp_xxh),\n                                            meth_name, FALSE);\n            if (is_orig_method_name) {\n                /* clear stale entry, if any */\n                SvREFCNT_dec(ima->stash);\n                SvREFCNT_dec(ima->gv);\n                if (!imp_msv) {\n                    ima->stash = NULL;\n                    ima->gv    = NULL;\n                }\n                else {\n                    ima->stash = (HV*)SvREFCNT_inc(DBIc_IMP_STASH(imp_xxh));\n                    ima->gv    = (GV*)SvREFCNT_inc(imp_msv);\n                    ima->generation = PL_sub_generation +\n                                        MY_cache_gen(DBIc_IMP_STASH(imp_xxh));\n                }\n            }\n        }\n\n        /* if method was a 'func' then try falling back to real 'func' method */\n        if (!imp_msv && (ima_flags & IMA_FUNC_REDIRECT)) {\n            imp_msv = (SV*)gv_fetchmethod_autoload(DBIc_IMP_STASH(imp_xxh), \"func\", FALSE);\n            if (imp_msv) {\n                /* driver does have func method so undo the earlier 'func' stack changes */\n                PUSHs(sv_2mortal(newSVpv(meth_name,0)));\n                PUTBACK;\n                ++items;\n                meth_name = \"func\";\n                meth_type = methtype_ordinary;\n            }\n        }\n\n        if (trace_level >= (is_nested_call ? 4 : 2)) {\n            PerlIO *logfp = DBILOGFP;\n            /* Full pkg method name (or just meth_name for ANON CODE)   */\n            const char *imp_meth_name = (imp_msv && isGV(imp_msv)) ? GvNAME(imp_msv) : meth_name;\n            HV *imp_stash = DBIc_IMP_STASH(imp_xxh);\n            PerlIO_printf(logfp, \"%c   -> %s \",\n                    call_depth>1 ? '0'+call_depth-1 : (PL_dirty?'!':' '), imp_meth_name);\n            if (imp_meth_name[0] == 'A' && strEQ(imp_meth_name,\"AUTOLOAD\"))\n                    PerlIO_printf(logfp, \"\\\"%s\\\" \", meth_name);\n            if (imp_msv && isGV(imp_msv) && GvSTASH(imp_msv) != imp_stash)\n                PerlIO_printf(logfp, \"in %s \", HvNAME(GvSTASH(imp_msv)));\n            PerlIO_printf(logfp, \"for %s (%s\", HvNAME(imp_stash),\n                        SvPV_nolen(orig_h));\n            if (h != orig_h)    /* show inner handle to aid tracing */\n                 PerlIO_printf(logfp, \"~0x%lx\", (long)SvRV(h));\n            else PerlIO_printf(logfp, \"~INNER\");\n            for(i=1; i<items; ++i) {\n                PerlIO_printf(logfp,\" %s\",\n                    (ima && i==ima->hidearg) ? \"****\" : neatsvpv(ST(i),0));\n            }\n#ifdef DBI_USE_THREADS\n            PerlIO_printf(logfp, \") thr#%p\\n\", (void*)DBIc_THR_USER(imp_xxh));\n#else\n            PerlIO_printf(logfp, \")\\n\");\n#endif\n            PerlIO_flush(logfp);\n        }\n\n        if (!imp_msv || ! ((meth_cv = GvCV(imp_msv))) ) {\n            if (PL_dirty || is_DESTROY) {\n                outitems = 0;\n                goto post_dispatch;\n            }\n            if (ima_flags & IMA_NOT_FOUND_OKAY) {\n                outitems = 0;\n                goto post_dispatch;\n            }\n            croak(\"Can't locate DBI object method \\\"%s\\\" via package \\\"%s\\\"\",\n                meth_name, HvNAME(DBIc_IMP_STASH(imp_xxh)));\n        }\n\n        PUSHMARK(mark);  /* mark arguments again so we can pass them on */\n\n        /* Note: the handle on the stack is still an object blessed into a\n         * DBI::* class and not the DBD::*::* class whose method is being\n         * invoked. This is correct and should be largely transparent.\n         */\n\n        /* SHORT-CUT ALERT! */\n        if (use_xsbypass && CvISXSUB(meth_cv) && CvXSUB(meth_cv)) {\n\n            /* If we are calling an XSUB we jump directly to its C code and\n             * bypass perl_call_sv(), pp_entersub() etc. This is fast.\n             * This code is based on a small section of pp_entersub().\n             */\n            (void)(*CvXSUB(meth_cv))(aTHXo_ meth_cv); /* Call the C code directly */\n\n            if (gimme == G_SCALAR) {    /* Enforce sanity in scalar context */\n                if (ax != PL_stack_sp - PL_stack_base ) { /* outitems != 1 */\n                    ST(0) =\n                        (ax > PL_stack_sp - PL_stack_base)\n                            ? &PL_sv_undef  /* outitems == 0 */\n                            : *PL_stack_sp; /* outitems > 1 */\n                    PL_stack_sp = PL_stack_base + ax;\n                }\n                outitems = 1;\n            }\n            else {\n                outitems = PL_stack_sp - (PL_stack_base + ax - 1);\n            }\n\n        }\n        else {\n            /* sv_dump(imp_msv); */\n            outitems = call_sv((SV*)meth_cv,\n                (is_DESTROY ? gimme | G_EVAL | G_KEEPERR : gimme) );\n        }\n\n        XSprePUSH; /* reset SP to base of stack frame */\n\n#ifdef DBI_save_hv_fetch_ent\n        if (meth_type == methtype_FETCH)\n            PL_hv_fetch_ent_mh = save_mh;       /* see start of block */\n#endif\n    }\n\n    post_dispatch:\n\n    if (is_DESTROY && DBI_IS_LAST_HANDLE(h)) { /* if destroying _this_ handle */\n        SV *lhp = DBIc_PARENT_H(imp_xxh);\n        if (lhp && SvROK(lhp)) {\n            DBI_SET_LAST_HANDLE(lhp);\n        }\n        else {\n            DBI_UNSET_LAST_HANDLE;\n        }\n    }\n\n    if (keep_error) {\n        /* if we didn't clear err before the call, check to see if a new error\n         * or warning has been recorded. If so, turn off keep_error so it gets acted on\n         */\n        if (DBIc_ErrCount(imp_xxh) > ErrCount || err_hash(aTHX_ imp_xxh) != keep_error) {\n            keep_error = 0;\n        }\n    }\n\n    err_sv = DBIc_ERR(imp_xxh);\n\n    if (trace_level >= (is_nested_call ? 3 : 1)) {\n        PerlIO *logfp = DBILOGFP;\n        const int is_fetch  = (meth_type == methtype_fetch_star && DBIc_TYPE(imp_xxh)==DBIt_ST);\n        const IV row_count = (is_fetch) ? DBIc_ROW_COUNT((imp_sth_t*)imp_xxh) : 0;\n        if (is_fetch && row_count>=2 && trace_level<=4 && SvOK(ST(0))) {\n            /* skip the 'middle' rows to reduce output */\n            goto skip_meth_return_trace;\n        }\n        if (SvOK(err_sv)) {\n            PerlIO_printf(logfp, \"    %s %s %s %s (err#%ld)\\n\", (keep_error) ? \"  \" : \"!!\",\n                SvTRUE(err_sv) ? \"ERROR:\" : strlen(SvPV_nolen(err_sv)) ? \"warn:\" : \"info:\",\n                neatsvpv(err_sv,0), neatsvpv(DBIc_ERRSTR(imp_xxh),0), (long)DBIc_ErrCount(imp_xxh));\n        }\n        PerlIO_printf(logfp,\"%c%c  <%c %s\",\n                    (call_depth > 1)  ? '0'+call_depth-1 : (PL_dirty?'!':' '),\n                    (DBIc_is(imp_xxh, DBIcf_TaintIn|DBIcf_TaintOut)) ? 'T' : ' ',\n                    (qsv) ? '>' : '-',\n                    meth_name);\n        if (trace_level==1 && (items>=2||is_DESTROY)) { /* make level 1 more useful */\n            /* we only have the first two parameters available here */\n            if (is_DESTROY) /* show handle as first arg to DESTROY */\n                /* want to show outer handle so trace makes sense       */\n                /* but outer handle has been destroyed so we fake it    */\n                PerlIO_printf(logfp,\"(%s=HASH(0x%p)\", HvNAME(SvSTASH(SvRV(orig_h))), (void*)DBIc_MY_H(imp_xxh));\n            else\n                PerlIO_printf(logfp,\"(%s\", neatsvpv(st1,0));\n            if (items >= 3)\n                PerlIO_printf(logfp,\", %s\", neatsvpv(st2,0));\n            PerlIO_printf(logfp,\"%s)\", (items > 3) ? \", ...\" : \"\");\n        }\n\n        if (gimme & G_ARRAY)\n             PerlIO_printf(logfp,\"= (\");\n        else PerlIO_printf(logfp,\"=\");\n        for(i=0; i < outitems; ++i) {\n            SV *s = ST(i);\n            if ( SvROK(s) && SvTYPE(SvRV(s))==SVt_PVAV) {\n                AV *av = (AV*)SvRV(s);\n                int avi;\n                int avi_last = SvIV(DBIS->neatsvpvlen) / 10;\n                if (avi_last < 39)\n                    avi_last = 39;\n                PerlIO_printf(logfp, \" [\");\n                for (avi=0; avi <= AvFILL(av); ++avi) {\n                    PerlIO_printf(logfp, \" %s\",  neatsvpv(AvARRAY(av)[avi],0));\n                    if (avi >= avi_last && AvFILL(av) - avi > 1) {\n                        PerlIO_printf(logfp, \" ... %ld others skipped\", AvFILL(av) - avi);\n                        break;\n                    }\n                }\n                PerlIO_printf(logfp, \" ]\");\n            }\n            else {\n                PerlIO_printf(logfp, \" %s\",  neatsvpv(s,0));\n                if ( SvROK(s) && SvTYPE(SvRV(s))==SVt_PVHV && !SvOBJECT(SvRV(s)) )\n                    PerlIO_printf(logfp, \"%ldkeys\", (long)HvKEYS(SvRV(s)));\n            }\n        }\n        if (gimme & G_ARRAY) {\n            PerlIO_printf(logfp,\" ) [%d items]\", outitems);\n        }\n        if (is_fetch && row_count) {\n            PerlIO_printf(logfp,\" row%\"IVdf, row_count);\n        }\n        if (qsv) /* flag as quick and peek at the first arg (still on the stack) */\n            PerlIO_printf(logfp,\" (%s from cache)\", neatsvpv(st1,0));\n        else if (!imp_msv)\n            PerlIO_printf(logfp,\" (not implemented)\");\n        /* XXX add flag to show pid here? */\n        /* add file and line number information */\n        PerlIO_puts(logfp, log_where(0, 0, \" at \", \"\\n\", 1, (trace_level >= 3), (trace_level >= 4)));\n    skip_meth_return_trace:\n        PerlIO_flush(logfp);\n    }\n\n    if (ima_flags & IMA_END_WORK) { /* commit() or rollback() */\n        /* XXX does not consider if the method call actually worked or not */\n        DBIc_off(imp_xxh, DBIcf_Executed);\n\n        if (DBIc_has(imp_xxh, DBIcf_BegunWork)) {\n            DBIc_off(imp_xxh, DBIcf_BegunWork);\n            if (!DBIc_has(imp_xxh, DBIcf_AutoCommit)) {\n                /* We only get here if the driver hasn't implemented their own code     */\n                /* for begin_work, or has but hasn't correctly turned AutoCommit        */\n                /* back on in their commit or rollback code. So we have to do it.       */\n                /* This is bad because it'll probably trigger a spurious commit()       */\n                /* and may mess up the error handling below for the commit/rollback     */\n                PUSHMARK(SP);\n                XPUSHs(h);\n                XPUSHs(sv_2mortal(newSVpv(\"AutoCommit\",0)));\n                XPUSHs(&PL_sv_yes);\n                PUTBACK;\n                call_method(\"STORE\", G_VOID);\n                MSPAGAIN;\n            }\n        }\n    }\n\n    if (PL_tainting\n        && DBIc_is(imp_xxh, DBIcf_TaintOut)   /* taint checks requested */\n        /* XXX this would taint *everything* being returned from *any*  */\n        /* method that doesn't have IMA_NO_TAINT_OUT set.               */\n        /* DISABLED: just tainting fetched data in get_fbav seems ok    */\n        && 0/* XXX disabled*/ /* !(ima_flags & IMA_NO_TAINT_OUT) */\n    ) {\n        dTHR;\n        TAINT; /* affects sv_setsv()'s within same perl statement */\n        for(i=0; i < outitems; ++i) {\n            I32 avi;\n            char *p;\n            SV *s;\n            SV *agg = ST(i);\n            if ( !SvROK(agg) )\n                continue;\n            agg = SvRV(agg);\n#define DBI_OUT_TAINTABLE(s) (!SvREADONLY(s) && !SvTAINTED(s))\n            switch (SvTYPE(agg)) {\n            case SVt_PVAV:\n                for(avi=0; avi <= AvFILL((AV*)agg); ++avi) {\n                    s = AvARRAY((AV*)agg)[avi];\n                    if (DBI_OUT_TAINTABLE(s))\n                        SvTAINTED_on(s);\n                }\n                break;\n            case SVt_PVHV:\n                hv_iterinit((HV*)agg);\n                while( (s = hv_iternextsv((HV*)agg, &p, &avi)) ) {\n                    if (DBI_OUT_TAINTABLE(s))\n                        SvTAINTED_on(s);\n                }\n                break;\n            default:\n                if (DBIc_WARN(imp_xxh)) {\n                    PerlIO_printf(DBILOGFP,\"Don't know how to taint contents of returned %s (type %d)\\n\",\n                        neatsvpv(agg,0), (int)SvTYPE(agg));\n                }\n            }\n        }\n    }\n\n    /* if method returned a new handle, and that handle has an error on it\n     * then copy the error up into the parent handle\n     */\n    if (ima_flags & IMA_IS_FACTORY && SvROK(ST(0))) {\n        SV *h_new = ST(0);\n        D_impdata(imp_xxh_new, imp_xxh_t, h_new);\n        if (SvOK(DBIc_ERR(imp_xxh_new))) {\n            set_err_sv(h, imp_xxh, DBIc_ERR(imp_xxh_new), DBIc_ERRSTR(imp_xxh_new), DBIc_STATE(imp_xxh_new), &PL_sv_no);\n        }\n    }\n\n    if (   !keep_error                  /* is a new err/warn/info               */\n        && !is_nested_call              /* skip nested (internal) calls         */\n        && (\n               /* is an error and has RaiseError|PrintError|HandleError set     */\n           (SvTRUE(err_sv) && DBIc_has(imp_xxh, DBIcf_RaiseError|DBIcf_PrintError|DBIcf_HandleError))\n               /* is a warn (not info) and has RaiseWarn|PrintWarn set          */\n        || (  SvOK(err_sv) && strlen(SvPV_nolen(err_sv)) && DBIc_has(imp_xxh, DBIcf_RaiseWarn|DBIcf_PrintWarn))\n        )\n    ) {\n        SV *msg;\n        SV **statement_svp = NULL;\n        const int is_warning = (!SvTRUE(err_sv) && strlen(SvPV_nolen(err_sv))==1);\n        const char *err_meth_name = meth_name;\n        char intro[200];\n\n        if (meth_type == methtype_set_err) {\n            SV **sem_svp = hv_fetch((HV*)SvRV(h), \"dbi_set_err_method\", 18, GV_ADDWARN);\n            if (SvOK(*sem_svp))\n                err_meth_name = SvPV_nolen(*sem_svp);\n        }\n\n        /* XXX change to vsprintf into sv directly */\n        sprintf(intro,\"%s %s %s: \", HvNAME(DBIc_IMP_STASH(imp_xxh)), err_meth_name,\n            SvTRUE(err_sv) ? \"failed\" : is_warning ? \"warning\" : \"information\");\n        msg = sv_2mortal(newSVpv(intro,0));\n        if (SvOK(DBIc_ERRSTR(imp_xxh)))\n            sv_catsv(msg, DBIc_ERRSTR(imp_xxh));\n        else\n            sv_catpvf(msg, \"(err=%s, errstr=undef, state=%s)\",\n                neatsvpv(DBIc_ERR(imp_xxh),0), neatsvpv(DBIc_STATE(imp_xxh),0) );\n\n        if (    DBIc_has(imp_xxh, DBIcf_ShowErrorStatement)\n            && !is_unrelated_to_Statement\n            && (DBIc_TYPE(imp_xxh) == DBIt_ST || ima_flags & IMA_SHOW_ERR_STMT)\n            && (statement_svp = hv_fetch((HV*)SvRV(h), \"Statement\", 9, 0))\n            &&  statement_svp && SvOK(*statement_svp)\n        ) {\n            SV **svp = 0;\n            sv_catpv(msg, \" [for Statement \\\"\");\n            sv_catsv(msg, *statement_svp);\n\n            /* fetch from tied outer handle to trigger FETCH magic  */\n            /* could add DBIcf_ShowErrorParams (default to on?)         */\n            if (!(ima_flags & IMA_HIDE_ERR_PARAMVALUES)) {\n                svp = hv_fetch((HV*)DBIc_MY_H(imp_xxh),\"ParamValues\",11,FALSE);\n                if (svp && SvMAGICAL(*svp))\n                    mg_get(*svp); /* XXX may recurse, may croak. could use eval */\n            }\n            if (svp && SvRV(*svp) && SvTYPE(SvRV(*svp)) == SVt_PVHV && HvKEYS(SvRV(*svp))>0 ) {\n                SV *param_values_sv = sv_2mortal(_join_hash_sorted((HV*)SvRV(*svp), \"=\",1, \", \",2, 1, -1));\n                sv_catpv(msg, \"\\\" with ParamValues: \");\n                sv_catsv(msg, param_values_sv);\n                sv_catpvn(msg, \"]\", 1);\n            }\n            else {\n                sv_catpv(msg, \"\\\"]\");\n            }\n        }\n\n        if (0) {\n            COP *cop = dbi_caller_cop();\n            if (cop && (CopLINE(cop) != CopLINE(PL_curcop) || CopFILEGV(cop) != CopFILEGV(PL_curcop))) {\n                dbi_caller_string(msg, cop, \" called via \", 1, 0);\n            }\n        }\n\n        hook_svp = NULL;\n        if (   (SvTRUE(err_sv) || (is_warning && DBIc_has(imp_xxh, DBIcf_RaiseWarn)))\n            &&  DBIc_has(imp_xxh, DBIcf_HandleError)\n            && (hook_svp = hv_fetch((HV*)SvRV(h),\"HandleError\",11,0))\n            &&  hook_svp && SvOK(*hook_svp)\n        ) {\n            dSP;\n            PerlIO *logfp = DBILOGFP;\n            IV items;\n            SV *status;\n            SV *result; /* point to result SV that's pointed to by the stack */\n            if (outitems) {\n                result = *(sp-outitems+1);\n                if (SvREADONLY(result)) {\n                    *(sp-outitems+1) = result = sv_2mortal(newSVsv(result));\n                }\n            }\n            else {\n                result = sv_newmortal();\n            }\n            if (trace_level)\n                PerlIO_printf(logfp,\"    -> HandleError on %s via %s%s%s%s\\n\",\n                    neatsvpv(h,0), neatsvpv(*hook_svp,0),\n                    (!outitems ? \"\" : \" (\"),\n                    (!outitems ? \"\" : neatsvpv(result ,0)),\n                    (!outitems ? \"\" : \")\")\n                );\n            PUSHMARK(SP);\n            XPUSHs(msg);\n            XPUSHs(sv_2mortal(newRV_inc((SV*)DBIc_MY_H(imp_xxh))));\n            XPUSHs( result );\n            PUTBACK;\n            items = call_sv(*hook_svp, G_SCALAR);\n            MSPAGAIN;\n            status = (items) ? POPs : &PL_sv_undef;\n            PUTBACK;\n            if (trace_level)\n                PerlIO_printf(logfp,\"    <- HandleError= %s%s%s%s\\n\",\n                    neatsvpv(status,0),\n                    (!outitems ? \"\" : \" (\"),\n                    (!outitems ? \"\" : neatsvpv(result,0)),\n                    (!outitems ? \"\" : \")\")\n                );\n            if (!SvTRUE(status)) /* handler says it didn't handle it, so... */\n                hook_svp = 0;  /* pretend we didn't have a handler...     */\n        }\n\n        if (profile_t1) { /* see also dbi_profile() call a few lines below */\n            SV *statement_sv = (is_unrelated_to_Statement) ? &PL_sv_no : &PL_sv_undef;\n            dbi_profile(h, imp_xxh, statement_sv, imp_msv ? imp_msv : (SV*)cv,\n                profile_t1, dbi_time());\n        }\n        if (!hook_svp && is_warning) {\n            if (DBIc_has(imp_xxh, DBIcf_PrintWarn))\n                warn_sv(msg);\n            if (DBIc_has(imp_xxh, DBIcf_RaiseWarn))\n                croak_sv(msg);\n        }\n        else if (!hook_svp && SvTRUE(err_sv)) {\n            if (DBIc_has(imp_xxh, DBIcf_PrintError))\n                warn_sv(msg);\n            if (DBIc_has(imp_xxh, DBIcf_RaiseError))\n                croak_sv(msg);\n        }\n    }\n    else if (profile_t1) { /* see also dbi_profile() call a few lines above */\n        SV *statement_sv = (is_unrelated_to_Statement) ? &PL_sv_no : &PL_sv_undef;\n        dbi_profile(h, imp_xxh, statement_sv, imp_msv ? imp_msv : (SV*)cv,\n                profile_t1, dbi_time());\n    }\n    XSRETURN(outitems);\n}\n\n\n\n/* -------------------------------------------------------------------- */\n\n/* comment and placeholder styles to accept and return */\n\n#define DBIpp_cm_cs 0x000001   /* C style */\n#define DBIpp_cm_hs 0x000002   /* #       */\n#define DBIpp_cm_dd 0x000004   /* --      */\n#define DBIpp_cm_br 0x000008   /* {}      */\n#define DBIpp_cm_dw 0x000010   /* '-- ' dash dash whitespace */\n#define DBIpp_cm_XX 0x00001F   /* any of the above */\n\n#define DBIpp_ph_qm 0x000100   /* ?       */\n#define DBIpp_ph_cn 0x000200   /* :1      */\n#define DBIpp_ph_cs 0x000400   /* :name   */\n#define DBIpp_ph_sp 0x000800   /* %s (as return only, not accept)    */\n#define DBIpp_ph_XX 0x000F00   /* any of the above */\n\n#define DBIpp_st_qq 0x010000   /* '' char escape */\n#define DBIpp_st_bs 0x020000   /* \\  char escape */\n#define DBIpp_st_XX 0x030000   /* any of the above */\n\n#define DBIpp_L_BRACE '{'\n#define DBIpp_R_BRACE '}'\n#define PS_accept(flag)  DBIbf_has(ps_accept,(flag))\n#define PS_return(flag)  DBIbf_has(ps_return,(flag))\n\nSV *\npreparse(SV *dbh, const char *statement, IV ps_return, IV ps_accept, void *foo)\n{\n    dTHX;\n    D_imp_xxh(dbh);\n/*\n        The idea here is that ps_accept defines which constructs to\n        recognize (accept) as valid in the source string (other\n        constructs are ignored), and ps_return defines which\n        constructs are valid to return in the result string.\n\n        If a construct that is valid in the input is also valid in the\n        output then it's simply copied. If it's not valid in the output\n        then it's editied into one of the valid forms (ideally the most\n        'standard' and/or information preserving one).\n\n        For example, if ps_accept includes '--' style comments but\n        ps_return doesn't, but ps_return does include '#' style\n        comments then any '--' style comments would be rewritten as '#'\n        style comments.\n\n        Similarly for placeholders. DBD::Oracle, for example, would say\n        '?', ':1' and ':name' are all acceptable input, but only\n        ':name' should be returned.\n\n        (There's a tricky issue with the '--' comment style because it can\n        clash with valid syntax, i.e., \"... set foo=foo--1 ...\" so it\n        would be *bad* to misinterpret that as the start of a comment.\n        Perhaps we need a DBIpp_cm_dw (for dash-dash-whitespace) style\n        to allow for that.)\n\n        Also, we'll only support DBIpp_cm_br as an input style. And\n        even then, only with reluctance. We may (need to) drop it when\n        we add support for odbc escape sequences.\n*/\n    int idx = 1;\n\n    char in_quote = '\\0';\n    char in_comment = '\\0';\n    char rt_comment = '\\0';\n    char *dest, *start;\n    const char *src;\n    const char *style = \"\", *laststyle = NULL;\n    SV *new_stmt_sv;\n\n    (void)foo;\n\n    if (!(ps_return | DBIpp_ph_XX)) { /* no return ph type specified */\n        ps_return |= ps_accept | DBIpp_ph_XX;   /* so copy from ps_accept */\n    }\n\n    /* XXX this allocation strategy won't work when we get to more advanced stuff */\n    new_stmt_sv = newSV(strlen(statement) * 3);\n    sv_setpv(new_stmt_sv,\"\");\n    src  = statement;\n    dest = SvPVX(new_stmt_sv);\n\n    while( *src )\n    {\n        if (*src == '%' && PS_return(DBIpp_ph_sp))\n            *dest++ = '%';\n\n        if (in_comment)\n        {\n             if (       (in_comment == '-' && (*src == '\\n' || *(src+1) == '\\0'))\n                ||      (in_comment == '#' && (*src == '\\n' || *(src+1) == '\\0'))\n                ||      (in_comment == DBIpp_L_BRACE && *src == DBIpp_R_BRACE) /* XXX nesting? */\n                ||      (in_comment == '/' && *src == '*' && *(src+1) == '/')\n             ) {\n                switch (rt_comment) {\n                case '/':       *dest++ = '*'; *dest++ = '/';   break;\n                case '-':       *dest++ = '\\n';                 break;\n                case '#':       *dest++ = '\\n';                 break;\n                case DBIpp_L_BRACE: *dest++ = DBIpp_R_BRACE;    break;\n                case '\\0':      /* ensure deleting a comment doesn't join two tokens */\n                        if (in_comment=='/' || in_comment==DBIpp_L_BRACE)\n                            *dest++ = ' '; /* ('-' and '#' styles use the newline) */\n                        break;\n                }\n                if (in_comment == '/')\n                    src++;\n                src += (*src != '\\n' || *(dest-1)=='\\n') ? 1 : 0;\n                in_comment = '\\0';\n                rt_comment = '\\0';\n             }\n             else\n             if (rt_comment)\n                *dest++ = *src++;\n             else\n                src++;  /* delete (don't copy) the comment */\n             continue;\n        }\n\n        if (in_quote)\n        {\n            if (*src == in_quote) {\n                in_quote = 0;\n            }\n            *dest++ = *src++;\n            continue;\n        }\n\n        /* Look for comments */\n        if (*src == '-' && *(src+1) == '-' &&\n                (PS_accept(DBIpp_cm_dd) || (*(src+2) == ' ' && PS_accept(DBIpp_cm_dw)))\n        )\n        {\n            in_comment = *src;\n            src += 2;   /* skip past 2nd char of double char delimiters */\n            if (PS_return(DBIpp_cm_dd) || PS_return(DBIpp_cm_dw)) {\n                *dest++ = rt_comment = '-';\n                *dest++ = '-';\n                if (PS_return(DBIpp_cm_dw) && *src!=' ')\n                    *dest++ = ' '; /* insert needed white space */\n            }\n            else if (PS_return(DBIpp_cm_cs)) {\n                *dest++ = rt_comment = '/';\n                *dest++ = '*';\n            }\n            else if (PS_return(DBIpp_cm_hs)) {\n                *dest++ = rt_comment = '#';\n            }\n            else if (PS_return(DBIpp_cm_br)) {\n                *dest++ = rt_comment = DBIpp_L_BRACE;\n            }\n            continue;\n        }\n        else if (*src == '/' && *(src+1) == '*' && PS_accept(DBIpp_cm_cs))\n        {\n            in_comment = *src;\n            src += 2;   /* skip past 2nd char of double char delimiters */\n            if (PS_return(DBIpp_cm_cs)) {\n                *dest++ = rt_comment = '/';\n                *dest++ = '*';\n            }\n            else if (PS_return(DBIpp_cm_dd) || PS_return(DBIpp_cm_dw)) {\n                *dest++ = rt_comment = '-';\n                *dest++ = '-';\n                if (PS_return(DBIpp_cm_dw)) *dest++ = ' ';\n            }\n            else if (PS_return(DBIpp_cm_hs)) {\n                *dest++ = rt_comment = '#';\n            }\n            else if (PS_return(DBIpp_cm_br)) {\n                *dest++ = rt_comment = DBIpp_L_BRACE;\n            }\n            continue;\n        }\n        else if (*src == '#' && PS_accept(DBIpp_cm_hs))\n        {\n            in_comment = *src;\n            src++;\n            if (PS_return(DBIpp_cm_hs)) {\n                *dest++ = rt_comment = '#';\n            }\n            else if (PS_return(DBIpp_cm_dd) || PS_return(DBIpp_cm_dw)) {\n                *dest++ = rt_comment = '-';\n                *dest++ = '-';\n                if (PS_return(DBIpp_cm_dw)) *dest++ = ' ';\n            }\n            else if (PS_return(DBIpp_cm_cs)) {\n                *dest++ = rt_comment = '/';\n                *dest++ = '*';\n            }\n            else if (PS_return(DBIpp_cm_br)) {\n                *dest++ = rt_comment = DBIpp_L_BRACE;\n            }\n            continue;\n        }\n        else if (*src == DBIpp_L_BRACE && PS_accept(DBIpp_cm_br))\n        {\n            in_comment = *src;\n            src++;\n            if (PS_return(DBIpp_cm_br)) {\n                *dest++ = rt_comment = DBIpp_L_BRACE;\n            }\n            else if (PS_return(DBIpp_cm_dd) || PS_return(DBIpp_cm_dw)) {\n                *dest++ = rt_comment = '-';\n                *dest++ = '-';\n                if (PS_return(DBIpp_cm_dw)) *dest++ = ' ';\n            }\n            else if (PS_return(DBIpp_cm_cs)) {\n                *dest++ = rt_comment = '/';\n                *dest++ = '*';\n            }\n            else if (PS_return(DBIpp_cm_hs)) {\n                *dest++ = rt_comment = '#';\n            }\n            continue;\n        }\n\n       if (    !(*src==':' && (PS_accept(DBIpp_ph_cn) || PS_accept(DBIpp_ph_cs)))\n           &&  !(*src=='?' &&  PS_accept(DBIpp_ph_qm))\n       ){\n            if (*src == '\\'' || *src == '\"')\n                in_quote = *src;\n            *dest++ = *src++;\n            continue;\n        }\n\n        /* only here for : or ? outside of a comment or literal */\n\n        start = dest;                   /* save name inc colon  */\n        *dest++ = *src++;               /* copy and move past first char */\n\n        if (*start == '?')              /* X/Open Standard */\n        {\n            style = \"?\";\n\n            if (PS_return(DBIpp_ph_qm))\n                ;\n            else if (PS_return(DBIpp_ph_cn)) { /* '?' -> ':p1' (etc) */\n                sprintf(start,\":p%d\", idx++);\n                dest = start+strlen(start);\n            }\n            else if (PS_return(DBIpp_ph_sp)) { /* '?' -> '%s' */\n                   *start  = '%';\n                   *dest++ = 's';\n            }\n        }\n        else if (isDIGIT(*src)) {   /* :1 */\n            const int pln = atoi(src);\n            style = \":1\";\n\n            if (PS_return(DBIpp_ph_cn)) { /* ':1'->':p1'  */\n                   idx = pln;\n                   *dest++ = 'p';\n                   while(isDIGIT(*src))\n                       *dest++ = *src++;\n            }\n            else if (PS_return(DBIpp_ph_qm) /* ':1' -> '?'  */\n                 ||  PS_return(DBIpp_ph_sp) /* ':1' -> '%s' */\n            ) {\n                   PS_return(DBIpp_ph_qm) ? sprintf(start,\"?\") : sprintf(start,\"%%s\");\n                   dest = start + strlen(start);\n                   if (pln != idx) {\n                        char buf[99];\n                        sprintf(buf, \"preparse found placeholder :%d out of sequence, expected :%d\", pln, idx);\n                        set_err_char(dbh, imp_xxh, \"1\", 1, buf, 0, \"preparse\");\n                        return &PL_sv_undef;\n                   }\n                   while(isDIGIT(*src)) src++;\n                   idx++;\n            }\n        }\n        else if (isALNUM(*src))         /* :name */\n        {\n            style = \":name\";\n\n            if (PS_return(DBIpp_ph_cs)) {\n                ;\n            }\n            else if (PS_return(DBIpp_ph_qm) /* ':name' -> '?'  */\n                 ||  PS_return(DBIpp_ph_sp) /* ':name' -> '%s' */\n            ) {\n                PS_return(DBIpp_ph_qm) ? sprintf(start,\"?\") : sprintf(start,\"%%s\");\n                dest = start + strlen(start);\n                while (isALNUM(*src))   /* consume name, includes '_'   */\n                    src++;\n            }\n        }\n        /* perhaps ':=' PL/SQL construct */\n        else { continue; }\n\n        *dest = '\\0';                   /* handy for debugging  */\n\n        if (laststyle && style != laststyle) {\n            char buf[99];\n            sprintf(buf, \"preparse found mixed placeholder styles (%s / %s)\", style, laststyle);\n            set_err_char(dbh, imp_xxh, \"1\", 1, buf, 0, \"preparse\");\n            return &PL_sv_undef;\n        }\n        laststyle = style;\n    }\n    *dest = '\\0';\n\n    /* warn about probable parsing errors, but continue anyway (returning processed string) */\n    switch (in_quote)\n    {\n    case '\\'':\n            set_err_char(dbh, imp_xxh, \"1\", 1, \"preparse found unterminated single-quoted string\", 0, \"preparse\");\n            break;\n    case '\\\"':\n            set_err_char(dbh, imp_xxh, \"1\", 1, \"preparse found unterminated double-quoted string\", 0, \"preparse\");\n            break;\n    }\n    switch (in_comment)\n    {\n    case DBIpp_L_BRACE:\n            set_err_char(dbh, imp_xxh, \"1\", 1, \"preparse found unterminated bracketed {...} comment\", 0, \"preparse\");\n            break;\n    case '/':\n            set_err_char(dbh, imp_xxh, \"1\", 1, \"preparse found unterminated bracketed C-style comment\", 0, \"preparse\");\n            break;\n    }\n\n    SvCUR_set(new_stmt_sv, strlen(SvPVX(new_stmt_sv)));\n    *SvEND(new_stmt_sv) = '\\0';\n    return new_stmt_sv;\n}\n\n\n/* -------------------------------------------------------------------- */\n/* The DBI Perl interface (via XS) starts here. Currently these are     */\n/* all internal support functions. Note install_method and see DBI.pm   */\n\nMODULE = DBI   PACKAGE = DBI\n\nREQUIRE:    1.929\nPROTOTYPES: DISABLE\n\n\nBOOT:\n    {\n        MY_CXT_INIT;\n        PERL_UNUSED_VAR(MY_CXT);\n    }\n    PERL_UNUSED_VAR(cv);\n    PERL_UNUSED_VAR(items);\n    dbi_bootinit(NULL);\n    /* make this sub into a fake XS so it can bee seen by DBD::* modules;\n     * never actually call it as an XS sub, or it will crash and burn! */\n    (void) newXS(\"DBI::_dbi_state_lval\", (XSUBADDR_t)_dbi_state_lval, __FILE__);\n\n\nI32\nconstant()\n        PROTOTYPE:\n    ALIAS:\n        SQL_ALL_TYPES                    = SQL_ALL_TYPES\n        SQL_ARRAY                        = SQL_ARRAY\n        SQL_ARRAY_LOCATOR                = SQL_ARRAY_LOCATOR\n        SQL_BIGINT                       = SQL_BIGINT\n        SQL_BINARY                       = SQL_BINARY\n        SQL_BIT                          = SQL_BIT\n        SQL_BLOB                         = SQL_BLOB\n        SQL_BLOB_LOCATOR                 = SQL_BLOB_LOCATOR\n        SQL_BOOLEAN                      = SQL_BOOLEAN\n        SQL_CHAR                         = SQL_CHAR\n        SQL_CLOB                         = SQL_CLOB\n        SQL_CLOB_LOCATOR                 = SQL_CLOB_LOCATOR\n        SQL_DATE                         = SQL_DATE\n        SQL_DATETIME                     = SQL_DATETIME\n        SQL_DECIMAL                      = SQL_DECIMAL\n        SQL_DOUBLE                       = SQL_DOUBLE\n        SQL_FLOAT                        = SQL_FLOAT\n        SQL_GUID                         = SQL_GUID\n        SQL_INTEGER                      = SQL_INTEGER\n        SQL_INTERVAL                     = SQL_INTERVAL\n        SQL_INTERVAL_DAY                 = SQL_INTERVAL_DAY\n        SQL_INTERVAL_DAY_TO_HOUR         = SQL_INTERVAL_DAY_TO_HOUR\n        SQL_INTERVAL_DAY_TO_MINUTE       = SQL_INTERVAL_DAY_TO_MINUTE\n        SQL_INTERVAL_DAY_TO_SECOND       = SQL_INTERVAL_DAY_TO_SECOND\n        SQL_INTERVAL_HOUR                = SQL_INTERVAL_HOUR\n        SQL_INTERVAL_HOUR_TO_MINUTE      = SQL_INTERVAL_HOUR_TO_MINUTE\n        SQL_INTERVAL_HOUR_TO_SECOND      = SQL_INTERVAL_HOUR_TO_SECOND\n        SQL_INTERVAL_MINUTE              = SQL_INTERVAL_MINUTE\n        SQL_INTERVAL_MINUTE_TO_SECOND    = SQL_INTERVAL_MINUTE_TO_SECOND\n        SQL_INTERVAL_MONTH               = SQL_INTERVAL_MONTH\n        SQL_INTERVAL_SECOND              = SQL_INTERVAL_SECOND\n        SQL_INTERVAL_YEAR                = SQL_INTERVAL_YEAR\n        SQL_INTERVAL_YEAR_TO_MONTH       = SQL_INTERVAL_YEAR_TO_MONTH\n        SQL_LONGVARBINARY                = SQL_LONGVARBINARY\n        SQL_LONGVARCHAR                  = SQL_LONGVARCHAR\n        SQL_MULTISET                     = SQL_MULTISET\n        SQL_MULTISET_LOCATOR             = SQL_MULTISET_LOCATOR\n        SQL_NUMERIC                      = SQL_NUMERIC\n        SQL_REAL                         = SQL_REAL\n        SQL_REF                          = SQL_REF\n        SQL_ROW                          = SQL_ROW\n        SQL_SMALLINT                     = SQL_SMALLINT\n        SQL_TIME                         = SQL_TIME\n        SQL_TIMESTAMP                    = SQL_TIMESTAMP\n        SQL_TINYINT                      = SQL_TINYINT\n        SQL_TYPE_DATE                    = SQL_TYPE_DATE\n        SQL_TYPE_TIME                    = SQL_TYPE_TIME\n        SQL_TYPE_TIMESTAMP               = SQL_TYPE_TIMESTAMP\n        SQL_TYPE_TIMESTAMP_WITH_TIMEZONE = SQL_TYPE_TIMESTAMP_WITH_TIMEZONE\n        SQL_TYPE_TIME_WITH_TIMEZONE      = SQL_TYPE_TIME_WITH_TIMEZONE\n        SQL_UDT                          = SQL_UDT\n        SQL_UDT_LOCATOR                  = SQL_UDT_LOCATOR\n        SQL_UNKNOWN_TYPE                 = SQL_UNKNOWN_TYPE\n        SQL_VARBINARY                    = SQL_VARBINARY\n        SQL_VARCHAR                      = SQL_VARCHAR\n        SQL_WCHAR                        = SQL_WCHAR\n        SQL_WLONGVARCHAR                 = SQL_WLONGVARCHAR\n        SQL_WVARCHAR                     = SQL_WVARCHAR\n        SQL_CURSOR_FORWARD_ONLY          = SQL_CURSOR_FORWARD_ONLY\n        SQL_CURSOR_KEYSET_DRIVEN         = SQL_CURSOR_KEYSET_DRIVEN\n        SQL_CURSOR_DYNAMIC               = SQL_CURSOR_DYNAMIC\n        SQL_CURSOR_STATIC                = SQL_CURSOR_STATIC\n        SQL_CURSOR_TYPE_DEFAULT          = SQL_CURSOR_TYPE_DEFAULT\n        DBIpp_cm_cs     = DBIpp_cm_cs\n        DBIpp_cm_hs     = DBIpp_cm_hs\n        DBIpp_cm_dd     = DBIpp_cm_dd\n        DBIpp_cm_dw     = DBIpp_cm_dw\n        DBIpp_cm_br     = DBIpp_cm_br\n        DBIpp_cm_XX     = DBIpp_cm_XX\n        DBIpp_ph_qm     = DBIpp_ph_qm\n        DBIpp_ph_cn     = DBIpp_ph_cn\n        DBIpp_ph_cs     = DBIpp_ph_cs\n        DBIpp_ph_sp     = DBIpp_ph_sp\n        DBIpp_ph_XX     = DBIpp_ph_XX\n        DBIpp_st_qq     = DBIpp_st_qq\n        DBIpp_st_bs     = DBIpp_st_bs\n        DBIpp_st_XX     = DBIpp_st_XX\n        DBIstcf_DISCARD_STRING  = DBIstcf_DISCARD_STRING\n        DBIstcf_STRICT          = DBIstcf_STRICT\n        DBIf_TRACE_SQL  = DBIf_TRACE_SQL\n        DBIf_TRACE_CON  = DBIf_TRACE_CON\n        DBIf_TRACE_ENC  = DBIf_TRACE_ENC\n        DBIf_TRACE_DBD  = DBIf_TRACE_DBD\n        DBIf_TRACE_TXN  = DBIf_TRACE_TXN\n    CODE:\n    RETVAL = ix;\n    OUTPUT:\n    RETVAL\n\n\nvoid\n_clone_dbis()\n    CODE:\n    dMY_CXT;\n    dbistate_t * parent_dbis = DBIS;\n\n    (void)cv;\n    {\n        MY_CXT_CLONE;\n    }\n    dbi_bootinit(parent_dbis);\n\n\nvoid\n_new_handle(class, parent, attr_ref, imp_datasv, imp_class)\n    SV *        class\n    SV *        parent\n    SV *        attr_ref\n    SV *        imp_datasv\n    SV *        imp_class\n    PPCODE:\n    dMY_CXT;\n    HV *outer;\n    SV *outer_ref;\n    HV *class_stash = gv_stashsv(class, GV_ADDWARN);\n\n    if (DBIS_TRACE_LEVEL >= 5) {\n        PerlIO_printf(DBILOGFP, \"    New %s (for %s, parent=%s, id=%s)\\n\",\n            neatsvpv(class,0), SvPV_nolen(imp_class), neatsvpv(parent,0), neatsvpv(imp_datasv,0));\n        PERL_UNUSED_VAR(cv);\n    }\n\n    (void)hv_store((HV*)SvRV(attr_ref), \"ImplementorClass\", 16, SvREFCNT_inc(imp_class), 0);\n\n    /* make attr into inner handle by blessing it into class */\n    sv_bless(attr_ref, class_stash);\n    /* tie new outer hash to inner handle */\n    outer = newHV(); /* create new hash to be outer handle */\n    outer_ref = newRV_noinc((SV*)outer);\n    /* make outer hash into a handle by blessing it into class */\n    sv_bless(outer_ref, class_stash);\n    /* tie outer handle to inner handle */\n    sv_magic((SV*)outer, attr_ref, PERL_MAGIC_tied, Nullch, 0);\n\n    dbih_setup_handle(aTHX_ outer_ref, SvPV_nolen(imp_class), parent, SvOK(imp_datasv) ? imp_datasv : Nullsv);\n\n    /* return outer handle, plus inner handle if not in scalar context */\n    sv_2mortal(outer_ref);\n    EXTEND(SP, 2);\n    PUSHs(outer_ref);\n    if (GIMME != G_SCALAR) {\n        PUSHs(attr_ref);\n    }\n\n\nvoid\n_setup_handle(sv, imp_class, parent, imp_datasv)\n    SV *        sv\n    char *      imp_class\n    SV *        parent\n    SV *        imp_datasv\n    CODE:\n    (void)cv;\n    dbih_setup_handle(aTHX_ sv, imp_class, parent, SvOK(imp_datasv) ? imp_datasv : Nullsv);\n    ST(0) = &PL_sv_undef;\n\n\nvoid\n_get_imp_data(sv)\n    SV *        sv\n    CODE:\n    D_imp_xxh(sv);\n    (void)cv;\n    ST(0) = sv_mortalcopy(DBIc_IMP_DATA(imp_xxh)); /* okay if NULL      */\n\n\nvoid\n_handles(sv)\n    SV *        sv\n    PPCODE:\n    /* return the outer and inner handle for any given handle */\n    D_imp_xxh(sv);\n    SV *ih = sv_mortalcopy( dbih_inner(aTHX_ sv, \"_handles\") );\n    SV *oh = sv_2mortal(newRV_inc((SV*)DBIc_MY_H(imp_xxh))); /* XXX dangerous */\n    (void)cv;\n    EXTEND(SP, 2);\n    PUSHs(oh);  /* returns outer handle then inner */\n    if (GIMME != G_SCALAR) {\n        PUSHs(ih);\n    }\n\n\nvoid\nneat(sv, maxlen=0)\n    SV *        sv\n    U32 maxlen\n    CODE:\n    ST(0) = sv_2mortal(newSVpv(neatsvpv(sv, maxlen), 0));\n    (void)cv;\n\n\nI32\nhash(key, type=0)\n    const char *key\n    long type\n    CODE:\n    (void)cv;\n    RETVAL = dbi_hash(key, type);\n    OUTPUT:\n    RETVAL\n\nvoid\nlooks_like_number(...)\n    PPCODE:\n    int i;\n    EXTEND(SP, items);\n    (void)cv;\n    for(i=0; i < items ; ++i) {\n        SV *sv = ST(i);\n        if (!SvOK(sv) || (SvPOK(sv) && SvCUR(sv)==0))\n            PUSHs(&PL_sv_undef);\n        else if ( looks_like_number(sv) )\n            PUSHs(&PL_sv_yes);\n        else\n            PUSHs(&PL_sv_no);\n    }\n\n\nvoid\n_install_method(dbi_class, meth_name, file, attribs=Nullsv)\n    const char *        dbi_class\n    char *      meth_name\n    char *      file\n    SV *        attribs\n    CODE:\n    {\n    dMY_CXT;\n    /* install another method name/interface for the DBI dispatcher     */\n    SV *trace_msg = (DBIS_TRACE_LEVEL >= 10) ? sv_2mortal(newSVpv(\"\",0)) : Nullsv;\n    CV *cv;\n    SV **svp;\n    dbi_ima_t *ima;\n    MAGIC *mg;\n    (void)dbi_class;\n\n    if (strnNE(meth_name, \"DBI::\", 5))  /* XXX m/^DBI::\\w+::\\w+$/       */\n        croak(\"install_method %s: invalid class\", meth_name);\n\n    if (trace_msg)\n        sv_catpvf(trace_msg, \"install_method %-21s\", meth_name);\n\n    Newxz(ima, 1, dbi_ima_t);\n\n    if (attribs && SvOK(attribs)) {\n        /* convert and store method attributes in a fast access form    */\n        if (SvTYPE(SvRV(attribs)) != SVt_PVHV)\n            croak(\"install_method %s: bad attribs\", meth_name);\n\n        DBD_ATTRIB_GET_IV(attribs, \"O\",1, svp, ima->flags);\n        DBD_ATTRIB_GET_UV(attribs, \"T\",1, svp, ima->method_trace);\n        DBD_ATTRIB_GET_IV(attribs, \"H\",1, svp, ima->hidearg);\n\n        if (trace_msg) {\n            if (ima->flags)       sv_catpvf(trace_msg, \", flags 0x%04x\", (unsigned)ima->flags);\n            if (ima->method_trace)sv_catpvf(trace_msg, \", T 0x%08lx\", (unsigned long)ima->method_trace);\n            if (ima->hidearg)     sv_catpvf(trace_msg, \", H %u\", (unsigned)ima->hidearg);\n        }\n        if ( (svp=DBD_ATTRIB_GET_SVP(attribs, \"U\",1)) != NULL) {\n            AV *av = (AV*)SvRV(*svp);\n            ima->minargs = (U8)SvIV(*av_fetch(av, 0, 1));\n            ima->maxargs = (U8)SvIV(*av_fetch(av, 1, 1));\n            svp = av_fetch(av, 2, 0);\n            ima->usage_msg = (svp) ? savepv_using_sv(SvPV_nolen(*svp)) : \"\";\n            ima->flags |= IMA_HAS_USAGE;\n            if (trace_msg && DBIS_TRACE_LEVEL >= 11)\n                sv_catpvf(trace_msg, \",\\n    usage: min %d, max %d, '%s'\",\n                        ima->minargs, ima->maxargs, ima->usage_msg);\n        }\n    }\n    if (trace_msg)\n        PerlIO_printf(DBILOGFP,\"%s\\n\", SvPV_nolen(trace_msg));\n    file = savepv(file);\n    cv = newXS(meth_name, XS_DBI_dispatch, file);\n    SvPVX((SV *)cv) = file;\n    SvLEN((SV *)cv) = 1;\n    CvXSUBANY(cv).any_ptr = ima;\n    ima->meth_type = get_meth_type(GvNAME(CvGV(cv)));\n\n    /* Attach magic to handle duping and freeing of the dbi_ima_t struct.\n     * Due to the poor interface of the mg dup function, sneak a pointer\n     * to the original CV in the mg_ptr field (we get called with a\n     * pointer to the mg, but not the SV) */\n    mg = sv_magicext((SV*)cv, NULL, DBI_MAGIC, &dbi_ima_vtbl,\n                        (char *)cv, 0);\n#ifdef BROKEN_DUP_ANY_PTR\n    ima->my_perl = my_perl; /* who owns this struct */\n#else\n    mg->mg_flags |= MGf_DUP;\n#endif\n    ST(0) = &PL_sv_yes;\n    }\n\n\nint\ntrace(class, level_sv=&PL_sv_undef, file=Nullsv)\n    SV *        class\n    SV *        level_sv\n    SV *        file\n    ALIAS:\n    _debug_dispatch = 1\n    CODE:\n    {\n    dMY_CXT;\n    IV level;\n    if (!DBIS) {\n        PERL_UNUSED_VAR(ix);\n        croak(\"DBI not initialised\");\n    }\n    /* Return old/current value. No change if new value not given.      */\n    RETVAL = (DBIS) ? DBIS->debug : 0;\n    level = parse_trace_flags(class, level_sv, RETVAL);\n    if (level)          /* call before or after altering DBI trace level */\n        set_trace_file(file);\n    if (level != RETVAL) {\n        if ((level & DBIc_TRACE_LEVEL_MASK) > 0) {\n            PerlIO_printf(DBILOGFP,\"    DBI %s%s default trace level set to 0x%lx/%ld (pid %d pi %p) at %s\\n\",\n                XS_VERSION, dbi_build_opt,\n                (long)(level & DBIc_TRACE_FLAGS_MASK),\n                (long)(level & DBIc_TRACE_LEVEL_MASK),\n                (int)PerlProc_getpid(),\n#ifdef MULTIPLICITY\n                (void *)my_perl,\n#else\n                (void*)NULL,\n#endif\n                log_where(Nullsv, 0, \"\", \"\", 1, 1, 0)\n            );\n            if (!PL_dowarn)\n                PerlIO_printf(DBILOGFP,\"    Note: perl is running without the recommended perl -w option\\n\");\n            PerlIO_flush(DBILOGFP);\n        }\n        DBIS->debug = level;\n        sv_setiv(get_sv(\"DBI::dbi_debug\",0x5), level);\n    }\n    if (!level)         /* call before or after altering DBI trace level */\n        set_trace_file(file);\n    }\n    OUTPUT:\n    RETVAL\n\n\n\nvoid\ndump_handle(sv, msg=\"DBI::dump_handle\", level=0)\n    SV *        sv\n    const char *msg\n    int         level\n    CODE:\n    (void)cv;\n    dbih_dumphandle(aTHX_ sv, msg, level);\n\n\n\nvoid\n_svdump(sv)\n    SV *        sv\n    CODE:\n    {\n    dMY_CXT;\n    (void)cv;\n    PerlIO_printf(DBILOGFP, \"DBI::_svdump(%s)\", neatsvpv(sv,0));\n#ifdef DEBUGGING\n    sv_dump(sv);\n#endif\n    }\n\n\nNV\ndbi_time()\n\n\nvoid\ndbi_profile(h, statement, method, t1, t2)\n    SV *h\n    SV *statement\n    SV *method\n    NV t1\n    NV t2\n    CODE:\n    SV *leaf = &PL_sv_undef;\n    PERL_UNUSED_VAR(cv);\n    if (SvROK(method))\n        method = SvRV(method);\n    if (dbih_inner(aTHX_ h, NULL)) {    /* is a DBI handle */\n        D_imp_xxh(h);\n        leaf = dbi_profile(h, imp_xxh, statement, method, t1, t2);\n    }\n    else if (SvROK(h) && SvTYPE(SvRV(h)) == SVt_PVHV) {\n        /* iterate over values %$h */\n        HV *hv = (HV*)SvRV(h);\n        SV *tmp;\n        char *key;\n        I32 keylen = 0;\n        hv_iterinit(hv);\n        while ( (tmp = hv_iternextsv(hv, &key, &keylen)) != NULL ) {\n            if (SvOK(tmp)) {\n                D_imp_xxh(tmp);\n                leaf = dbi_profile(tmp, imp_xxh, statement, method, t1, t2);\n            }\n        };\n    }\n    else {\n        croak(\"dbi_profile(%s,...) invalid handle argument\", neatsvpv(h,0));\n    }\n    if (GIMME_V == G_VOID)\n        ST(0) = &PL_sv_undef;  /* skip sv_mortalcopy if not needed */\n    else\n        ST(0) = sv_mortalcopy(leaf);\n\n\n\nSV *\ndbi_profile_merge_nodes(dest, ...)\n    SV * dest\n    ALIAS:\n    dbi_profile_merge = 1\n    CODE:\n    {\n        if (!SvROK(dest) || SvTYPE(SvRV(dest)) != SVt_PVAV)\n            croak(\"dbi_profile_merge_nodes(%s,...) destination is not an array reference\", neatsvpv(dest,0));\n        if (items <= 1) {\n            PERL_UNUSED_VAR(cv);\n            PERL_UNUSED_VAR(ix);\n            RETVAL = 0;\n        }\n        else {\n            /* items==2 for dest + 1 arg, ST(0) is dest, ST(1) is first arg */\n            while (--items >= 1) {\n                SV *thingy = ST(items);\n                dbi_profile_merge_nodes(dest, thingy);\n            }\n            RETVAL = newSVsv(*av_fetch((AV*)SvRV(dest), DBIprof_TOTAL_TIME, 1));\n        }\n    }\n    OUTPUT:\n    RETVAL\n\n\nSV *\n_concat_hash_sorted(hash_sv, kv_sep_sv, pair_sep_sv, use_neat_sv, num_sort_sv)\n    SV *hash_sv\n    SV *kv_sep_sv\n    SV *pair_sep_sv\n    SV *use_neat_sv\n    SV *num_sort_sv\n    PREINIT:\n    char *kv_sep, *pair_sep;\n    STRLEN kv_sep_len, pair_sep_len;\n    CODE:\n        if (!SvOK(hash_sv))\n            XSRETURN_UNDEF;\n        if (!SvROK(hash_sv) || SvTYPE(SvRV(hash_sv))!=SVt_PVHV)\n            croak(\"hash is not a hash reference\");\n\n        kv_sep   = SvPV(kv_sep_sv,   kv_sep_len);\n        pair_sep = SvPV(pair_sep_sv, pair_sep_len);\n\n        RETVAL = _join_hash_sorted( (HV*)SvRV(hash_sv),\n            kv_sep,   kv_sep_len,\n            pair_sep, pair_sep_len,\n            /* use_neat should be undef, 0 or 1, may allow sprintf format strings later */\n            (SvOK(use_neat_sv)) ? SvIV(use_neat_sv) :  0,\n            (SvOK(num_sort_sv)) ? SvIV(num_sort_sv) : -1\n        );\n    OUTPUT:\n        RETVAL\n\n\nint\nsql_type_cast(sv, sql_type, flags=0)\n    SV *        sv\n    int         sql_type\n    U32         flags\n    CODE:\n    RETVAL = sql_type_cast_svpv(aTHX_ sv, sql_type, flags, 0);\n    OUTPUT:\n        RETVAL\n\n\n\nMODULE = DBI   PACKAGE = DBI::var\n\nvoid\nFETCH(sv)\n    SV *        sv\n    CODE:\n    dMY_CXT;\n    /* Note that we do not come through the dispatcher to get here.     */\n    char *meth = SvPV_nolen(SvRV(sv));  /* what should this tie do ?    */\n    char type = *meth++;                /* is this a $ or & style       */\n    imp_xxh_t *imp_xxh = (DBI_LAST_HANDLE_OK) ? DBIh_COM(DBI_LAST_HANDLE) : NULL;\n    int trace_level = (imp_xxh ? DBIc_TRACE_LEVEL(imp_xxh) : DBIS_TRACE_LEVEL);\n    NV profile_t1 = 0.0;\n\n    if (imp_xxh && DBIc_has(imp_xxh,DBIcf_Profile))\n        profile_t1 = dbi_time();\n\n    if (trace_level >= 2) {\n        PerlIO_printf(DBILOGFP,\"    -> $DBI::%s (%c) FETCH from lasth=%s\\n\", meth, type,\n                (imp_xxh) ? neatsvpv(DBI_LAST_HANDLE,0): \"none\");\n    }\n\n    if (type == '!') {  /* special case for $DBI::lasth */\n        /* Currently we can only return the INNER handle.       */\n        /* This handle should only be used for true/false tests */\n        ST(0) = (imp_xxh) ? sv_2mortal(newRV_inc(DBI_LAST_HANDLE)) : &PL_sv_undef;\n    }\n    else if ( !imp_xxh ) {\n        if (trace_level)\n            warn(\"Can't read $DBI::%s, last handle unknown or destroyed\", meth);\n        ST(0) = &PL_sv_undef;\n    }\n    else if (type == '*') {     /* special case for $DBI::err, see also err method      */\n        SV *errsv = DBIc_ERR(imp_xxh);\n        ST(0) = sv_mortalcopy(errsv);\n    }\n    else if (type == '\"') {     /* special case for $DBI::state */\n        SV *state = DBIc_STATE(imp_xxh);\n        ST(0) = DBIc_STATE_adjust(imp_xxh, state);\n    }\n    else if (type == '$') { /* lookup scalar variable in implementors stash */\n        const char *vname = mkvname(aTHX_ DBIc_IMP_STASH(imp_xxh), meth, 0);\n        SV *vsv = get_sv(vname, 1);\n        ST(0) = sv_mortalcopy(vsv);\n    }\n    else {\n        /* default to method call via stash of implementor of DBI_LAST_HANDLE */\n        GV *imp_gv;\n        HV *imp_stash = DBIc_IMP_STASH(imp_xxh);\n#ifdef DBI_save_hv_fetch_ent\n        HE save_mh = PL_hv_fetch_ent_mh; /* XXX nested tied FETCH bug17575 workaround */\n#endif\n        profile_t1 = 0.0; /* profile this via dispatch only (else we'll double count) */\n        if (trace_level >= 3)\n            PerlIO_printf(DBILOGFP,\"    >> %s::%s\\n\", HvNAME(imp_stash), meth);\n        ST(0) = sv_2mortal(newRV_inc(DBI_LAST_HANDLE));\n        if ((imp_gv = gv_fetchmethod(imp_stash,meth)) == NULL) {\n            croak(\"Can't locate $DBI::%s object method \\\"%s\\\" via package \\\"%s\\\"\",\n                meth, meth, HvNAME(imp_stash));\n        }\n        PUSHMARK(mark);  /* reset mark (implies one arg as we were called with one arg?) */\n        call_sv((SV*)GvCV(imp_gv), GIMME);\n        SPAGAIN;\n#ifdef DBI_save_hv_fetch_ent\n        PL_hv_fetch_ent_mh = save_mh;\n#endif\n    }\n    if (trace_level)\n        PerlIO_printf(DBILOGFP,\"    <- $DBI::%s= %s\\n\", meth, neatsvpv(ST(0),0));\n    if (profile_t1) {\n        SV *h = sv_2mortal(newRV_inc(DBI_LAST_HANDLE));\n        dbi_profile(h, imp_xxh, &PL_sv_undef, (SV*)cv, profile_t1, dbi_time());\n    }\n\n\nMODULE = DBI   PACKAGE = DBD::_::dr\n\nvoid\ndbixs_revision(h)\n    SV *    h\n    CODE:\n    PERL_UNUSED_VAR(h);\n    ST(0) = sv_2mortal(newSViv(DBIXS_REVISION));\n\n\nMODULE = DBI   PACKAGE = DBD::_::db\n\nvoid\nconnected(...)\n    CODE:\n    /* defined here just to avoid AUTOLOAD */\n    (void)cv;\n    (void)items;\n    ST(0) = &PL_sv_undef;\n\n\nSV *\npreparse(dbh, statement, ps_return, ps_accept, foo=Nullch)\n    SV *        dbh\n    char *      statement\n    IV          ps_return\n    IV          ps_accept\n    void        *foo\n\n\nvoid\ntake_imp_data(h)\n    SV *        h\n    PREINIT:\n    /* take_imp_data currently in DBD::_::db not DBD::_::common, so for dbh's only */\n    D_imp_xxh(h);\n    MAGIC *mg;\n    SV *imp_xxh_sv;\n    SV **tmp_svp;\n    CODE:\n    PERL_UNUSED_VAR(cv);\n    /*\n     * Remove and return the imp_xxh_t structure that's attached to the inner\n     * hash of the handle. Effectively this removes the 'brain' of the handle\n     * leaving it as an empty shell - brain dead. All method calls on it fail.\n     *\n     * The imp_xxh_t structure that's removed and returned is a plain scalar\n     * (containing binary data). It can be passed to a new DBI->connect call\n     * in order to have the new $dbh use the same 'connection' as the original\n     * handle. In this way a multi-threaded connection pool can be implemented.\n     *\n     * If the drivers imp_xxh_t structure contains SV*'s, or other interpreter\n     * specific items, they should be freed by the drivers own take_imp_data()\n     * method before it then calls SUPER::take_imp_data() to finalize removal\n     * of the imp_xxh_t structure.\n     *\n     * The driver needs to view the take_imp_data method as being nearly the\n     * same as disconnect+DESTROY only not actually calling the database API to\n     * disconnect.  All that needs to remain valid in the imp_xxh_t structure\n     * is the underlying database API connection data.  Everything else should\n     * in a 'clean' state such that if the drivers own DESTROY method was\n     * called it would be able to properly handle the contents of the\n     * structure. This is important in case a new handle created using this\n     * imp_data, possibly in a new thread, might end up being DESTROY'd before\n     * the driver has had a chance to 're-setup' the data. See dbih_setup_handle()\n     *\n     * All the above relates to the 'typical use case' for a compiled driver.\n     * For a pure-perl driver using a socket pair, for example, the drivers\n     * take_imp_data method might just return a string containing the fileno()\n     * values of the sockets (without calling this SUPER::take_imp_data() code).\n     * The key point is that the take_imp_data() method returns an opaque buffer\n     * containing whatever the driver would need to reuse the same underlying\n     * 'connection to the database' in a new handle.\n     *\n     * In all cases, care should be taken that driver attributes (such as\n     * AutoCommit) match the state of the underlying connection.\n     */\n\n    if (!DBIc_ACTIVE(imp_xxh)) {/* sanity check, may be relaxed later */\n        set_err_char(h, imp_xxh, \"1\", 1, \"Can't take_imp_data from handle that's not Active\", 0, \"take_imp_data\");\n        XSRETURN(0);\n    }\n\n    /* Ideally there should be no child statement handles existing when\n     * take_imp_data is called because when those statement handles are\n     * destroyed they may need to interact with the 'zombie' parent dbh.\n     * So we do our best to neautralize them (finish & rebless)\n     */\n    if ((tmp_svp = hv_fetch((HV*)SvRV(h), \"ChildHandles\", 12, FALSE)) && SvROK(*tmp_svp)) {\n        AV *av = (AV*)SvRV(*tmp_svp);\n        HV *zombie_stash = gv_stashpv(\"DBI::zombie\", GV_ADDWARN);\n        I32 kidslots;\n        for (kidslots = AvFILL(av); kidslots >= 0; --kidslots) {\n            SV **hp = av_fetch(av, kidslots, FALSE);\n            if (hp && SvROK(*hp) && SvMAGICAL(SvRV(*hp))) {\n                PUSHMARK(sp);\n                XPUSHs(*hp);\n                PUTBACK;\n                call_method(\"finish\", G_VOID);\n                SPAGAIN;\n                PUTBACK;\n                sv_unmagic(SvRV(*hp), 'P'); /* untie */\n                sv_bless(*hp, zombie_stash); /* neutralise */\n            }\n        }\n    }\n    /* The above measures may not be sufficient if weakrefs aren't available\n     * or something has a reference to the inner-handle of an sth.\n     * We'll require no Active kids, but just warn about others.\n     */\n    if (DBIc_ACTIVE_KIDS(imp_xxh)) {\n        set_err_char(h, imp_xxh, \"1\", 1, \"Can't take_imp_data from handle while it still has Active kids\", 0, \"take_imp_data\");\n        XSRETURN(0);\n    }\n    if (DBIc_KIDS(imp_xxh))\n        warn(\"take_imp_data from handle while it still has kids\");\n\n    /* it may be better here to return a copy and poison the original\n     * rather than detatching and returning the original\n     */\n\n    /* --- perform the surgery */\n    dbih_getcom2(aTHX_ h, &mg); /* get the MAGIC so we can change it    */\n    imp_xxh_sv = mg->mg_obj;    /* take local copy of the imp_data pointer */\n    mg->mg_obj = Nullsv;        /* sever the link from handle to imp_xxh */\n    mg->mg_ptr = NULL;          /* and sever the shortcut too */\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 9)\n        sv_dump(imp_xxh_sv);\n    /* --- housekeeping */\n    DBIc_ACTIVE_off(imp_xxh);   /* silence warning from dbih_clearcom */\n    DBIc_IMPSET_off(imp_xxh);   /* silence warning from dbih_clearcom */\n    dbih_clearcom(imp_xxh);     /* free SVs like DBD::_mem::common::DESTROY */\n    SvOBJECT_off(imp_xxh_sv);   /* no longer needs DESTROY via dbih_clearcom */\n    /* restore flags to mark fact imp data holds active connection      */\n    /* (don't use magical DBIc_ACTIVE_on here)                          */\n    DBIc_FLAGS(imp_xxh) |=  DBIcf_IMPSET | DBIcf_ACTIVE;\n    /* --- tidy up the raw PV for life as a more normal string */\n    SvPOK_on(imp_xxh_sv);       /* SvCUR & SvEND were set at creation   */\n    /* --- return the actual imp_xxh_sv on the stack */\n    ST(0) = imp_xxh_sv;\n\n\n\nMODULE = DBI   PACKAGE = DBD::_::st\n\nvoid\n_get_fbav(sth)\n    SV *        sth\n    CODE:\n    D_imp_sth(sth);\n    AV *av = dbih_get_fbav(imp_sth);\n    (void)cv;\n    ST(0) = sv_2mortal(newRV_inc((SV*)av));\n\nvoid\n_set_fbav(sth, src_rv)\n    SV *        sth\n    SV *        src_rv\n    CODE:\n    D_imp_sth(sth);\n    int i;\n    AV *src_av;\n    AV *dst_av = dbih_get_fbav(imp_sth);\n    int dst_fields = AvFILL(dst_av)+1;\n    int src_fields;\n    (void)cv;\n\n    if (!SvROK(src_rv) || SvTYPE(SvRV(src_rv)) != SVt_PVAV)\n        croak(\"_set_fbav(%s): not an array ref\", neatsvpv(src_rv,0));\n    src_av = (AV*)SvRV(src_rv);\n    src_fields = AvFILL(src_av)+1;\n    if (src_fields != dst_fields) {\n        warn(\"_set_fbav(%s): array has %d elements, the statement handle row buffer has %d (and NUM_OF_FIELDS is %d)\",\n                neatsvpv(src_rv,0), src_fields, dst_fields, DBIc_NUM_FIELDS(imp_sth));\n        SvREADONLY_off(dst_av);\n        if (src_fields < dst_fields) {\n            /* shrink the array - sadly this looses column bindings for the lost columns */\n            av_fill(dst_av, src_fields-1);\n            dst_fields = src_fields;\n        }\n        else {\n            av_fill(dst_av, src_fields-1);\n            /* av_fill pads with immutable undefs which we need to change */\n            for(i=dst_fields-1; i < src_fields; ++i) {\n                sv_setsv(AvARRAY(dst_av)[i], newSV(0));\n            }\n        }\n        SvREADONLY_on(dst_av);\n    }\n    for(i=0; i < dst_fields; ++i) {     /* copy over the row    */\n        /* If we're given the values, then taint them if required */\n        if (DBIc_is(imp_sth, DBIcf_TaintOut))\n            SvTAINT(AvARRAY(src_av)[i]);\n        sv_setsv(AvARRAY(dst_av)[i], AvARRAY(src_av)[i]);\n    }\n    ST(0) = sv_2mortal(newRV_inc((SV*)dst_av));\n\n\nvoid\nbind_col(sth, col, ref, attribs=Nullsv)\n    SV *        sth\n    SV *        col\n    SV *        ref\n    SV *        attribs\n    CODE:\n    DBD_ATTRIBS_CHECK(\"bind_col\", sth, attribs);\n    ST(0) = boolSV(dbih_sth_bind_col(sth, col, ref, attribs));\n    (void)cv;\n\n\nvoid\nfetchrow_array(sth)\n    SV *        sth\n    ALIAS:\n    fetchrow = 1\n    PPCODE:\n    SV *retsv;\n    if (CvDEPTH(cv) == 99) {\n        PERL_UNUSED_VAR(ix);\n        croak(\"Deep recursion, probably fetchrow-fetch-fetchrow loop\");\n    }\n    PUSHMARK(sp);\n    XPUSHs(sth);\n    PUTBACK;\n    if (call_method(\"fetch\", G_SCALAR) != 1)\n        croak(\"panic: DBI fetch\");      /* should never happen */\n    SPAGAIN;\n    retsv = POPs;\n    PUTBACK;\n    if (SvROK(retsv) && SvTYPE(SvRV(retsv)) == SVt_PVAV) {\n        D_imp_sth(sth);\n        int num_fields, i;\n        AV *bound_av;\n        AV *av = (AV*)SvRV(retsv);\n        num_fields = AvFILL(av)+1;\n        EXTEND(sp, num_fields+1);\n\n        /* We now check for bind_col() having been called but fetch     */\n        /* not returning the fields_svav array. Probably because the    */\n        /* driver is implemented in perl. XXX This logic may change later.      */\n        bound_av = DBIc_FIELDS_AV(imp_sth); /* bind_col() called ?      */\n        if (bound_av && av != bound_av) {\n            /* let dbih_get_fbav know what's going on   */\n            bound_av = dbih_get_fbav(imp_sth);\n            if (DBIc_TRACE_LEVEL(imp_sth) >= 3) {\n                PerlIO_printf(DBIc_LOGPIO(imp_sth),\n                    \"fetchrow: updating fbav 0x%lx from 0x%lx\\n\",\n                    (long)bound_av, (long)av);\n            }\n            for(i=0; i < num_fields; ++i) {     /* copy over the row    */\n                sv_setsv(AvARRAY(bound_av)[i], AvARRAY(av)[i]);\n            }\n        }\n        for(i=0; i < num_fields; ++i) {\n            PUSHs(AvARRAY(av)[i]);\n        }\n    }\n\n\nSV *\nfetchrow_hashref(sth, keyattrib=Nullch)\n    SV *        sth\n    const char *keyattrib\n    PREINIT:\n    SV *rowavr;\n    SV *ka_rv;\n    D_imp_sth(sth);\n    CODE:\n    (void)cv;\n    PUSHMARK(sp);\n    XPUSHs(sth);\n    PUTBACK;\n    if (!keyattrib || !*keyattrib) {\n        SV *kn = DBIc_FetchHashKeyName(imp_sth);\n        if (kn && SvOK(kn))\n            keyattrib = SvPVX(kn);\n        else\n            keyattrib = \"NAME\";\n    }\n    ka_rv = *hv_fetch((HV*)DBIc_MY_H(imp_sth), keyattrib,strlen(keyattrib), TRUE);\n    /* we copy to invoke FETCH magic, and we do that before fetch() so if tainting */\n    /* then the taint triggered by the fetch won't then apply to the fetched name */\n    ka_rv = newSVsv(ka_rv);\n    if (call_method(\"fetch\", G_SCALAR) != 1)\n        croak(\"panic: DBI fetch\");      /* should never happen */\n    SPAGAIN;\n    rowavr = POPs;\n    PUTBACK;\n    /* have we got an array ref in rowavr */\n    if (SvROK(rowavr) && SvTYPE(SvRV(rowavr)) == SVt_PVAV) {\n        int i;\n        AV *rowav = (AV*)SvRV(rowavr);\n        const int num_fields = AvFILL(rowav)+1;\n        HV *hv;\n        AV *ka_av;\n        if (!(SvROK(ka_rv) && SvTYPE(SvRV(ka_rv))==SVt_PVAV)) {\n            sv_setiv(DBIc_ERR(imp_sth), 1);\n            sv_setpvf(DBIc_ERRSTR(imp_sth),\n                \"Can't use attribute '%s' because it doesn't contain a reference to an array (%s)\",\n                keyattrib, neatsvpv(ka_rv,0));\n            XSRETURN_UNDEF;\n        }\n        ka_av = (AV*)SvRV(ka_rv);\n        hv    = newHV();\n        for (i=0; i < num_fields; ++i) {        /* honor the original order as sent by the database */\n            SV  **field_name_svp = av_fetch(ka_av, i, 1);\n            (void)hv_store_ent(hv, *field_name_svp, newSVsv((SV*)(AvARRAY(rowav)[i])), 0);\n        }\n        RETVAL = newRV_inc((SV*)hv);\n        SvREFCNT_dec(hv);       /* since newRV incremented it   */\n    }\n    else {\n        RETVAL = &PL_sv_undef;\n#if (PERL_VERSION < 4) || ((PERL_VERSION == 4) && (PERL_SUBVERSION <= 4))\n        RETVAL = newSV(0); /* mutable undef for 5.004_04 */\n#endif\n    }\n    SvREFCNT_dec(ka_rv);        /* since we created it          */\n    OUTPUT:\n    RETVAL\n\n\nvoid\nfetch(sth)\n    SV *        sth\n    ALIAS:\n    fetchrow_arrayref = 1\n    CODE:\n    int num_fields;\n    if (CvDEPTH(cv) == 99) {\n        PERL_UNUSED_VAR(ix);\n        croak(\"Deep recursion. Probably fetch-fetchrow-fetch loop.\");\n    }\n    PUSHMARK(sp);\n    XPUSHs(sth);\n    PUTBACK;\n    num_fields = call_method(\"fetchrow\", G_ARRAY);      /* XXX change the name later */\n    SPAGAIN;\n    if (num_fields == 0) {\n        ST(0) = &PL_sv_undef;\n    } else {\n        D_imp_sth(sth);\n        AV *av = dbih_get_fbav(imp_sth);\n        if (num_fields != AvFILL(av)+1)\n            croak(\"fetchrow returned %d fields, expected %d\",\n                    num_fields, (int)AvFILL(av)+1);\n        SPAGAIN;\n        while(--num_fields >= 0)\n            sv_setsv(AvARRAY(av)[num_fields], POPs);\n        PUTBACK;\n        ST(0) = sv_2mortal(newRV_inc((SV*)av));\n    }\n\n\nvoid\nrows(sth)\n    SV *        sth\n    CODE:\n    D_imp_sth(sth);\n    const IV rows = DBIc_ROW_COUNT(imp_sth);\n    ST(0) = sv_2mortal(newSViv(rows));\n    (void)cv;\n\n\nvoid\nfinish(sth)\n    SV *        sth\n    CODE:\n    D_imp_sth(sth);\n    DBIc_ACTIVE_off(imp_sth);\n    ST(0) = &PL_sv_yes;\n    (void)cv;\n\n\nvoid\nDESTROY(sth)\n    SV *        sth\n    PPCODE:\n    /* keep in sync with DESTROY in Driver.xst */\n    D_imp_sth(sth);\n    ST(0) = &PL_sv_yes;\n    /* we don't test IMPSET here because this code applies to pure-perl drivers */\n    if (DBIc_IADESTROY(imp_sth)) { /* want's ineffective destroy    */\n        DBIc_ACTIVE_off(imp_sth);\n        if (DBIc_TRACE_LEVEL(imp_sth))\n                PerlIO_printf(DBIc_LOGPIO(imp_sth), \"         DESTROY %s skipped due to InactiveDestroy\\n\", SvPV_nolen(sth));\n    }\n    if (DBIc_ACTIVE(imp_sth)) {\n        D_imp_dbh_from_sth;\n        if (!PL_dirty && DBIc_ACTIVE(imp_dbh)) {\n            dSP;\n            PUSHMARK(sp);\n            XPUSHs(sth);\n            PUTBACK;\n            call_method(\"finish\", G_SCALAR);\n            SPAGAIN;\n            PUTBACK;\n        }\n        else {\n            DBIc_ACTIVE_off(imp_sth);\n        }\n    }\n\n\nMODULE = DBI   PACKAGE = DBI::st\n\nvoid\nTIEHASH(class, inner_ref)\n    SV * class\n    SV * inner_ref\n    CODE:\n    HV *stash = gv_stashsv(class, GV_ADDWARN); /* a new hash is supplied to us, we just need to bless and apply tie magic */\n    sv_bless(inner_ref, stash);\n    ST(0) = inner_ref;\n\nMODULE = DBI   PACKAGE = DBD::_::common\n\n\nvoid\nDESTROY(h)\n    SV * h\n    CODE:\n    /* DESTROY defined here just to avoid AUTOLOAD */\n    (void)cv;\n    (void)h;\n    ST(0) = &PL_sv_undef;\n\n\nvoid\nSTORE(h, keysv, valuesv)\n    SV *        h\n    SV *        keysv\n    SV *        valuesv\n    CODE:\n    ST(0) = &PL_sv_yes;\n    if (!dbih_set_attr_k(h, keysv, 0, valuesv))\n            ST(0) = &PL_sv_no;\n    (void)cv;\n\n\nvoid\nFETCH(h, keysv)\n    SV *        h\n    SV *        keysv\n    CODE:\n    ST(0) = dbih_get_attr_k(h, keysv, 0);\n    (void)cv;\n\nvoid\nDELETE(h, keysv)\n    SV *        h\n    SV *        keysv\n    CODE:\n    /* only private_* keys can be deleted, for others DELETE acts like FETCH */\n    /* because the DBI internals rely on certain handle attributes existing  */\n    if (strnEQ(SvPV_nolen(keysv),\"private_\",8))\n        ST(0) = hv_delete_ent((HV*)SvRV(h), keysv, 0, 0);\n    else\n        ST(0) = dbih_get_attr_k(h, keysv, 0);\n    (void)cv;\n\n\nvoid\nprivate_data(h)\n    SV *        h\n    CODE:\n    D_imp_xxh(h);\n    (void)cv;\n    ST(0) = sv_mortalcopy(DBIc_IMP_DATA(imp_xxh));\n\n\nvoid\nerr(h)\n    SV * h\n    CODE:\n    D_imp_xxh(h);\n    SV *errsv = DBIc_ERR(imp_xxh);\n    (void)cv;\n    ST(0) = sv_mortalcopy(errsv);\n\nvoid\nstate(h)\n    SV * h\n    CODE:\n    D_imp_xxh(h);\n    SV *state = DBIc_STATE(imp_xxh);\n    (void)cv;\n    ST(0) = DBIc_STATE_adjust(imp_xxh, state);\n\nvoid\nerrstr(h)\n    SV *    h\n    CODE:\n    D_imp_xxh(h);\n    SV *errstr = DBIc_ERRSTR(imp_xxh);\n    SV *err;\n    /* If there's no errstr but there is an err then use err */\n    (void)cv;\n    if (!SvTRUE(errstr) && (err=DBIc_ERR(imp_xxh)) && SvTRUE(err))\n            errstr = err;\n    ST(0) = sv_mortalcopy(errstr);\n\n\nvoid\nset_err(h, err, errstr=&PL_sv_no, state=&PL_sv_undef, method=&PL_sv_undef, result=Nullsv)\n    SV *        h\n    SV *        err\n    SV *        errstr\n    SV *        state\n    SV *        method\n    SV *        result\n    PPCODE:\n    {\n    D_imp_xxh(h);\n    SV **sem_svp;\n    (void)cv;\n\n    if (DBIc_has(imp_xxh, DBIcf_HandleSetErr) && SvREADONLY(method))\n        method = sv_mortalcopy(method); /* HandleSetErr may want to change it */\n\n    if (!set_err_sv(h, imp_xxh, err, errstr, state, method)) {\n        /* set_err was canceled by HandleSetErr,                */\n        /* don't set \"dbi_set_err_method\", return an empty list */\n    }\n    else {\n        /* store provided method name so handler code can find it */\n        sem_svp = hv_fetch((HV*)SvRV(h), \"dbi_set_err_method\", 18, 1);\n        if (SvOK(method)) {\n            sv_setpv(*sem_svp, SvPV_nolen(method));\n        }\n        else\n            (void)SvOK_off(*sem_svp);\n        EXTEND(SP, 1);\n        PUSHs( result ? result : &PL_sv_undef );\n    }\n    /* We don't check RaiseError and call die here because that must be */\n    /* done by returning through dispatch and letting the DBI handle it */\n    }\n\n\nint\ntrace(h, level=&PL_sv_undef, file=Nullsv)\n    SV *h\n    SV *level\n    SV *file\n    ALIAS:\n    debug = 1\n    CODE:\n    RETVAL = set_trace(h, level, file);\n    (void)cv; /* Unused variables */\n    (void)ix;\n    OUTPUT:\n    RETVAL\n\n\nvoid\ntrace_msg(sv, msg, this_trace=1)\n    SV *sv\n    const char *msg\n    int this_trace\n    PREINIT:\n    int current_trace;\n    PerlIO *pio;\n    CODE:\n    {\n    dMY_CXT;\n    (void)cv;\n    if (SvROK(sv)) {\n        D_imp_xxh(sv);\n        current_trace = DBIc_TRACE_LEVEL(imp_xxh);\n        pio = DBIc_LOGPIO(imp_xxh);\n    }\n    else {      /* called as a static method */\n        current_trace = DBIS_TRACE_FLAGS;\n        pio = DBILOGFP;\n    }\n    if (DBIc_TRACE_MATCHES(this_trace, current_trace)) {\n        PerlIO_puts(pio, msg);\n        ST(0) = &PL_sv_yes;\n    }\n    else {\n        ST(0) = &PL_sv_no;\n    }\n    }\n\n\nvoid\nrows(h)\n    SV *        h\n    CODE:\n    /* fallback esp for $DBI::rows after $drh was last used */\n    ST(0) = sv_2mortal(newSViv(-1));\n    (void)h;\n    (void)cv;\n\n\nvoid\nswap_inner_handle(rh1, rh2, allow_reparent=0)\n    SV *        rh1\n    SV *        rh2\n    IV  allow_reparent\n    CODE:\n    {\n    D_impdata(imp_xxh1, imp_xxh_t, rh1);\n    D_impdata(imp_xxh2, imp_xxh_t, rh2);\n    SV *h1i = dbih_inner(aTHX_ rh1, \"swap_inner_handle\");\n    SV *h2i = dbih_inner(aTHX_ rh2, \"swap_inner_handle\");\n    SV *h1  = (rh1 == h1i) ? (SV*)DBIc_MY_H(imp_xxh1) : SvRV(rh1);\n    SV *h2  = (rh2 == h2i) ? (SV*)DBIc_MY_H(imp_xxh2) : SvRV(rh2);\n    (void)cv;\n\n    if (DBIc_TYPE(imp_xxh1) != DBIc_TYPE(imp_xxh2)) {\n        char buf[99];\n        sprintf(buf, \"Can't swap_inner_handle between %sh and %sh\",\n            dbih_htype_name(DBIc_TYPE(imp_xxh1)), dbih_htype_name(DBIc_TYPE(imp_xxh2)));\n        DBIh_SET_ERR_CHAR(rh1, imp_xxh1, \"1\", 1, buf, Nullch, Nullch);\n        XSRETURN_NO;\n    }\n    if (!allow_reparent && DBIc_PARENT_COM(imp_xxh1) != DBIc_PARENT_COM(imp_xxh2)) {\n        DBIh_SET_ERR_CHAR(rh1, imp_xxh1, \"1\", 1,\n            \"Can't swap_inner_handle with handle from different parent\",\n            Nullch, Nullch);\n        XSRETURN_NO;\n    }\n\n    (void)SvREFCNT_inc(h1i);\n    (void)SvREFCNT_inc(h2i);\n\n    sv_unmagic(h1, 'P');                /* untie(%$h1)          */\n    sv_unmagic(h2, 'P');                /* untie(%$h2)          */\n\n    sv_magic(h1, h2i, 'P', Nullch, 0);  /* tie %$h1, $h2i       */\n    DBIc_MY_H(imp_xxh2) = (HV*)h1;\n\n    sv_magic(h2, h1i, 'P', Nullch, 0);  /* tie %$h2, $h1i       */\n    DBIc_MY_H(imp_xxh1) = (HV*)h2;\n\n    SvREFCNT_dec(h1i);\n    SvREFCNT_dec(h2i);\n\n    ST(0) = &PL_sv_yes;\n    }\n\n\nMODULE = DBI   PACKAGE = DBD::_mem::common\n\nvoid\nDESTROY(imp_xxh_rv)\n    SV *        imp_xxh_rv\n    CODE:\n    /* ignore 'cast increases required alignment' warning       */\n    imp_xxh_t *imp_xxh = (imp_xxh_t*)SvPVX(SvRV(imp_xxh_rv));\n    DBIc_DBISTATE(imp_xxh)->clearcom(imp_xxh);\n    (void)cv;\n\n# end\n"], "filenames": ["DBI.xs"], "buggy_code_start_loc": [2891], "buggy_code_end_loc": [2893], "fixing_code_start_loc": [2891], "fixing_code_end_loc": [2897], "type": "CWE-476", "message": "An issue was discovered in the DBI module before 1.643 for Perl. The hv_fetch() documentation requires checking for NULL and the code does that. But, shortly thereafter, it calls SvOK(profile), causing a NULL pointer dereference.", "other": {"cve": {"id": "CVE-2019-20919", "sourceIdentifier": "cve@mitre.org", "published": "2020-09-17T18:15:12.147", "lastModified": "2022-04-28T18:33:15.863", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in the DBI module before 1.643 for Perl. The hv_fetch() documentation requires checking for NULL and the code does that. But, shortly thereafter, it calls SvOK(profile), causing a NULL pointer dereference."}, {"lang": "es", "value": "Se detect\u00f3 un problema en el m\u00f3dulo DBI versiones anteriores a 1.643 para Perl.&#xa0;La documentaci\u00f3n de la funci\u00f3n hv_fetch() requiere comprobaci\u00f3n para NULL y el c\u00f3digo lo hace.&#xa0;Pero, poco despu\u00e9s, llama a SvOK(profile), causando una desreferencia del puntero NULL"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 4.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.0, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 1.9}, "baseSeverity": "LOW", "exploitabilityScore": 3.4, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:perl:dbi:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.643", "matchCriteriaId": "E19FB9B3-EBC0-408F-A11E-8FC538337A1D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:-:*:*:*", "matchCriteriaId": "CB66DB75-2B16-4EBF-9B93-CE49D8086E41"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.2:*:*:*:*:*:*:*", "matchCriteriaId": "B009C22E-30A4-4288-BCF6-C3E81DEAF45A"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-10/msg00012.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2020-10/msg00013.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/perl5-dbi/dbi/commit/eca7d7c8f43d96f6277e86d1000e842eb4cc67ff", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/09/msg00026.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/JXLKODJ7B57GITDEZZXNSHPK4VBYXYHR/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://metacpan.org/pod/distribution/DBI/Changes#Changes-in-DBI-1.643-...", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4534-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/perl5-dbi/dbi/commit/eca7d7c8f43d96f6277e86d1000e842eb4cc67ff"}}