{"buggy_code": ["WildMIDI is a simple software midi player which has a core softsynth\nlibrary that can be use with other applications.\n\nThe WildMIDI library uses Gravis Ultrasound patch files to convert MIDI\nfiles into audio which is then passed back to the calling application.\nThe library API is designed so that it is easy to include WildMIDI into\napplications that wish to include MIDI file playback.\n\nVersion: 0.4.2\nLicenses: GPLv3+ and LGPLv3\nWebsite: http://www.mindwerks.net/projects/wildmidi\n\nPLATFORMS:\n\n* Linux: Arch, Debian, Fedora, Ubuntu (player: ALSA, OSS, OpenAL output)\n* Windows: x86 and x64\n* OSX: x86, x64 and powerpc (in Xterm. player: OpenAL output)\n* BSD: Debian, FreeBSD, NetBSD, OpenBSD. (player: OSS output)\n* kFreeBSD: Debian (player: OSS output)\n* Hurd: Debian\n* DOS (player: sound blaster or compatibles output.)\n* OS/2 (player: Dart output.)\n* AmigaOS & variants like MorphOS, AROS. (player: AHI output)\n\nBUILD FROM SOURCE:\n\nRequirements:\n* git\n* cmake\n* GCC or clang / Xcode / VisualStudio / MinGW or MinGW-w64\n* DOS port: DJGPP / GNU make\n* OS/2 port: OpenWatcom (tested with version 1.9)\n* Nintendo 3DS port: devkitARM\n* Nintendo Wii port: devkitPPC\n\nCHANGELOG\n\n0.4.2\n* Fixed CVE-2017-11661, CVE-2017-11662, CVE-2017-11663, CVE-2017-11664\n  (Bug #175).\n* GUS patch processing changes to meet users expectations (Bug #132).\n* Worked around a build failure with newer FreeBSD versions failing to\n  retrieve the ONLCR constant (Bug #171).\n* Fixed a minor Windows unicode issue (PR #170).\n* A few other fixes / clean-ups.\n\n0.4.1\n* Fixed bug in handling of the \"source\" directive in config files.\n* Fixed a nasty bug in dBm_pan_volume. Other fixes and clean-ups.\n* Build system updates. Install a pkg-config file on supported platforms\n  such as Linux. New android ndk makefile.\n* File i/o updates.\n* Support for OS/2.\n* Support for Nintendo 3DS\n* Support for Nintendo Wii\n* Support for AmigaOS and its variants like MorphOS and AROS.\n\n0.4.0\n* API change: The library now returns audio data in host-endian format,\n  not little-endian.\n* API change: WildMidi_GetVersion() added to the api, along with new\n  numeric version macros in the wildmidi_lib.h header. the dso version\n  is changed from 1 to 2.\n* API change: All long or unsigned long type _WM_Info fields changed\n  into strictly 32bit fields (int32_t or uint32_t.)\n* API change: WildMidi_OpenBuffer() and WildMidi_GetOutput() changed\n  to accept strictly 32bit size parameters, i.e. uint32_t, instead of\n  unsigned long.\n* API change: WildMidi_ConvertToMidi() and WildMidi_ConvertBufferToMidi() \n  added for MIDI-like files to be converted to MIDI.\n* API change: WildMidi_SetCvtOption() added to support conversion options.\n* API change: WildMidi_SongSeek() added to support Type 2 MIDI files.\n* API change: WildMidi_GetLyric() added to support embedded text, \n  such as KAR files.\n* API change: WildMidi_GetError() and WildMidi_ClearError() added to\n  cleanly check for, retrieve and clear error messages. They no longer\n  go to stderr.\n* Support for loading XMI (XMIDI format) and XFM files, such as from Arena.\n  Thanks Ryan Nunn for releasing his code under the LGPL.\n* Support for loading MUS (MUS Id format) files, such as from Doom.\n* Support for loading HMP/HMI files, such as from Daggerfall.\n* Support for loading KAR (MIDI with Lyrics) and Type 2 MIDI files.\n* Build requires cmake-2.8.11 or newer now.\n\n0.3.9\n* Library: Fixed a segmentation fault with bad midi files.\n\n0.3.8\n* Library: Fixed a seek-to-0 bug in order to cure an issue of truncated\n  start (bug #100, gnome/gstreamer bug #694811.)\n* Player, OpenAL: reduced buffers from 8 to 4 so as to cure some output\n  delay issues (bug #85.)\n\n0.3.7\n* Plug a memory leak in case of broken midis.\n* Properly reset global state upon library shutdown.\n* Support for type-2 midi files.\n* Fix a possible crash in WildMidi_SetOption.\n* DOS port: Support for Sound Blaster output in player.\n* Uglify the library's private global variable and function names.\n* Build: Add option for a statically linked player.\n* Build: Add headers to project files. Use -fno-common flag.\n* Other small fixes/clean-ups.\n\n0.3.6\n* Fix some portability issues.\n* Fix a double-free issue during library shutdown when several midis\n  were alive.\n* Fix the invalid option checking in WildMidi_Init().\n* Fix the roundtempo option which had been broken since its invention\n  in 0.2.3.5 (WM_MO_ROUNDTEMPO: was 0xA000 instead of 0x2000.)\n* Fix cfg files without a newline at the end weren't parsed correctly.\n* Handle cfg files with mac line-endings.\n* Refuse loading suspiciously long files.\n\n0.3.5\n* Greatly reduced the heap usage (was a regression introduced in 0.2.3)\n* OpenAL support: Fixed audio output on big-endian systems. Fixed audio\n  skips at song start.\n* OSS support: No longer uses mmap mode for better compatibility. This\n  gains us NetBSD and OpenBSD support.\n* Worked around an invalid memory read found by valgrind when playing\n  Beethoven's Fur Elise.rmi at 44100 Hz using the old MIDIA patch-set\n  from 1994.\n* Build fixes for MSVC. Revised visibility attributes usage.\n\n0.3.4\n* OpenAL support: This gains us OSX and other platforms that OpenAL\n  supports for sound output!\n* DOS (DJGPP) support: This goes a long way to helping other DOS\n  based applications.\n* MinGW support: This gains us win32 and win64 support using this\n  toolchain.\n* OSS fixes.\n* Add missing parts of the absolute paths fix in config parsing.\n* New portable file and path-name system to handle cross-platform\n  support.\n* Support for Debian/kFreeBSD, Debian/Hurd and other Debian archs.\n* Many bug fixes, code clean-ups and cosmetic fixes.\n\n0.3.3\n* default to hidden visibility and only export our API functions\n* windows lean and mean to help compile times on Windows\n* cli and xcode work now on OSX\n* better FreeBSD support\n* Supported platforms are Debian, FreeBSD, Windows and OSX (but only\n  for WAV output)\n\n0.3.1 - 0.3.2\n* Cmake updates/fixes/cleanups.\n\n0.3.0\n* initial CMake support.\n* process non-registered params. fix issue of notes ending before\n  attack envelope completed. (sf.net svn r149/r151.)\n", "/*\n * wildmidi_lib.c -- Midi Wavetable Processing library\n *\n * Copyright (C) WildMIDI Developers 2001-2016\n *\n * This file is part of WildMIDI.\n *\n * WildMIDI is free software: you can redistribute and/or modify the player\n * under the terms of the GNU General Public License and you can redistribute\n * and/or modify the library under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation, either version 3 of\n * the licenses, or(at your option) any later version.\n *\n * WildMIDI is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License and\n * the GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License and the\n * GNU Lesser General Public License along with WildMIDI.  If not,  see\n * <http://www.gnu.org/licenses/>.\n */\n\n#define _WILDMIDI_LIB_C\n\n#include \"config.h\"\n\n#include <stdint.h>\n#include <errno.h>\n#include <math.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"wm_error.h\"\n#include \"file_io.h\"\n#include \"lock.h\"\n#include \"reverb.h\"\n#include \"gus_pat.h\"\n#include \"common.h\"\n#include \"wildmidi_lib.h\"\n#include \"filenames.h\"\n#include \"internal_midi.h\"\n#include \"f_hmi.h\"\n#include \"f_hmp.h\"\n#include \"f_midi.h\"\n#include \"f_mus.h\"\n#include \"f_xmidi.h\"\n#include \"patches.h\"\n#include \"sample.h\"\n#include \"mus2mid.h\"\n#include \"xmi2mid.h\"\n\n/*\n * =========================\n * Global Data and Data Structs\n * =========================\n */\n\nstatic int WM_Initialized = 0;\nuint16_t _WM_MixerOptions = 0;\n\nuint16_t _WM_SampleRate;\nint16_t _WM_MasterVolume;\n\n/* when converting files to midi */\ntypedef struct _cvt_options {\n    int lock;\n    uint16_t xmi_convert_type;\n    uint16_t frequency;\n} _cvt_options;\n\nstatic _cvt_options WM_ConvertOptions = {0, 0, 0};\n\n\nfloat _WM_reverb_room_width = 16.875f;\nfloat _WM_reverb_room_length = 22.5f;\n\nfloat _WM_reverb_listen_posx = 8.4375f;\nfloat _WM_reverb_listen_posy = 16.875f;\n\nint _WM_fix_release = 0;\nint _WM_auto_amp = 0;\nint _WM_auto_amp_with_amp = 0;\n\nstruct _miditrack {\n    uint32_t length;\n    uint32_t ptr;\n    uint32_t delta;\n    uint8_t running_event;\n    uint8_t EOT;\n};\n\nstruct _mdi_patches {\n    struct _patch *patch;\n    struct _mdi_patch *next;\n};\n\n#define FPBITS 10\n#define FPMASK ((1L<<FPBITS)-1L)\n\n\n/* Gauss Interpolation code adapted from code supplied by Eric. A. Welsh */\nstatic double newt_coeffs[58][58];  /* for start/end of samples */\n#define MAX_GAUSS_ORDER 34          /* 34 is as high as we can go before errors crop up */\nstatic double *gauss_table = NULL;  /* *gauss_table[1<<FPBITS] */\nstatic int gauss_n = MAX_GAUSS_ORDER;\nstatic int gauss_lock;\n\nstatic void init_gauss(void) {\n    /* init gauss table */\n    int n = gauss_n;\n    int m, i, k, n_half = (n >> 1);\n    int j;\n    int sign;\n    double ck;\n    double x, x_inc, xz;\n    double z[35];\n    double *gptr, *t;\n\n    _WM_Lock(&gauss_lock);\n    if (gauss_table) {\n        _WM_Unlock(&gauss_lock);\n        return;\n    }\n\n    newt_coeffs[0][0] = 1;\n    for (i = 0; i <= n; i++) {\n        newt_coeffs[i][0] = 1;\n        newt_coeffs[i][i] = 1;\n\n        if (i > 1) {\n            newt_coeffs[i][0] = newt_coeffs[i - 1][0] / i;\n            newt_coeffs[i][i] = newt_coeffs[i - 1][0] / i;\n        }\n\n        for (j = 1; j < i; j++) {\n            newt_coeffs[i][j] = newt_coeffs[i - 1][j - 1]\n                    + newt_coeffs[i - 1][j];\n            if (i > 1)\n                newt_coeffs[i][j] /= i;\n        }\n        z[i] = i / (4 * M_PI);\n    }\n\n    for (i = 0; i <= n; i++)\n        for (j = 0, sign = (int) pow(-1, i); j <= i; j++, sign *= -1)\n            newt_coeffs[i][j] *= sign;\n\n    t = malloc((1<<FPBITS) * (n + 1) * sizeof(double));\n    x_inc = 1.0 / (1<<FPBITS);\n    for (m = 0, x = 0.0; m < (1<<FPBITS); m++, x += x_inc) {\n        xz = (x + n_half) / (4 * M_PI);\n        gptr = &t[m * (n + 1)];\n\n        for (k = 0; k <= n; k++) {\n            ck = 1.0;\n\n            for (i = 0; i <= n; i++) {\n                if (i == k)\n                    continue;\n\n                ck *= (sin(xz - z[i])) / (sin(z[k] - z[i]));\n            }\n            *gptr++ = ck;\n        }\n    }\n\n    gauss_table = t;\n    _WM_Unlock(&gauss_lock);\n}\n\nstatic void free_gauss(void) {\n    _WM_Lock(&gauss_lock);\n    free(gauss_table);\n    gauss_table = NULL;\n    _WM_Unlock(&gauss_lock);\n}\n\nstruct _hndl {\n    void * handle;\n    struct _hndl *next;\n    struct _hndl *prev;\n};\n\nstatic struct _hndl * first_handle = NULL;\n\n#define MAX_AUTO_AMP 2.0\n\n/*\n * =========================\n * Internal Functions\n * =========================\n */\n\nvoid _cvt_reset_options (void) {\n    _WM_Lock(&WM_ConvertOptions.lock);\n    WM_ConvertOptions.xmi_convert_type = 0;\n    WM_ConvertOptions.frequency = 0;\n    _WM_Unlock(&WM_ConvertOptions.lock);\n}\n\nuint16_t _cvt_get_option (uint16_t tag) {\n    uint16_t r = 0;\n    _WM_Lock(&WM_ConvertOptions.lock);\n    switch (tag) {\n    case WM_CO_XMI_TYPE: r = WM_ConvertOptions.xmi_convert_type; break;\n    case WM_CO_FREQUENCY: r = WM_ConvertOptions.frequency; break;\n    }\n    _WM_Unlock(&WM_ConvertOptions.lock);\n    return r;\n}\n\nstatic void WM_InitPatches(void) {\n    int i;\n    for (i = 0; i < 128; i++) {\n        _WM_patch[i] = NULL;\n    }\n}\n\nstatic void WM_FreePatches(void) {\n    int i;\n    struct _patch * tmp_patch;\n    struct _sample * tmp_sample;\n\n    _WM_Lock(&_WM_patch_lock);\n    for (i = 0; i < 128; i++) {\n        while (_WM_patch[i]) {\n            while (_WM_patch[i]->first_sample) {\n                tmp_sample = _WM_patch[i]->first_sample->next;\n                free(_WM_patch[i]->first_sample->data);\n                free(_WM_patch[i]->first_sample);\n                _WM_patch[i]->first_sample = tmp_sample;\n            }\n            free(_WM_patch[i]->filename);\n            tmp_patch = _WM_patch[i]->next;\n            free(_WM_patch[i]);\n            _WM_patch[i] = tmp_patch;\n        }\n    }\n    _WM_Unlock(&_WM_patch_lock);\n}\n\n/* wm_strdup -- adds extra space for appending up to 4 chars */\nstatic char *wm_strdup (const char *str) {\n    size_t l = strlen(str) + 5;\n    char *d = (char *) malloc(l * sizeof(char));\n    if (d) {\n        strcpy(d, str);\n        return (d);\n    }\n    return (NULL);\n}\n\nstatic inline int wm_isdigit(int c) {\n    return (c >= '0' && c <= '9');\n}\nstatic inline int wm_isupper(int c) {\n    return (c >= 'A' && c <= 'Z');\n}\nstatic inline int wm_tolower(int c) {\n    return ((wm_isupper(c)) ? (c | ('a' - 'A')) : c);\n}\n#if 0 /* clang whines that these aren't used. */\nstatic inline int wm_islower(int c) {\n    return (c >= 'a' && c <= 'z');\n}\nstatic inline int wm_toupper(int c) {\n    return ((wm_islower(c)) ? (c & ~('a' - 'A')) : c);\n}\n#endif\n\nstatic int wm_strcasecmp(const char *s1, const char * s2) {\n    const char * p1 = s1;\n    const char * p2 = s2;\n    char c1, c2;\n\n    if (p1 == p2) return 0;\n    do {\n        c1 = wm_tolower (*p1++);\n        c2 = wm_tolower (*p2++);\n        if (c1 == '\\0') break;\n    } while (c1 == c2);\n    return (int)(c1 - c2);\n}\n\nstatic int wm_strncasecmp(const char *s1, const char *s2, size_t n) {\n    const char * p1 = s1;\n    const char * p2 = s2;\n    char c1, c2;\n\n    if (p1 == p2 || n == 0) return 0;\n    do {\n        c1 = wm_tolower (*p1++);\n        c2 = wm_tolower (*p2++);\n        if (c1 == '\\0' || c1 != c2) break;\n    } while (--n > 0);\n    return (int)(c1 - c2);\n}\n\n#define TOKEN_CNT_INC 8\nstatic char** WM_LC_Tokenize_Line(char *line_data) {\n    int line_length = (int) strlen(line_data);\n    int token_data_length = 0;\n    int line_ofs = 0;\n    int token_start = 0;\n    char **token_data = NULL;\n    int token_count = 0;\n\n    if (!line_length) return (NULL);\n\n    do {\n        /* ignore everything after #  */\n        if (line_data[line_ofs] == '#') {\n            break;\n        }\n\n        if ((line_data[line_ofs] == ' ') || (line_data[line_ofs] == '\\t')) {\n            /* whitespace means we aren't in a token */\n            if (token_start) {\n                token_start = 0;\n                line_data[line_ofs] = '\\0';\n            }\n        } else {\n            if (!token_start) {\n                /* the start of a token in the line */\n                token_start = 1;\n                if (token_count >= token_data_length) {\n                    token_data_length += TOKEN_CNT_INC;\n                    token_data = realloc(token_data, token_data_length * sizeof(char *));\n                    if (token_data == NULL) {\n                        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_MEM,\"to parse config\", errno);\n                        return (NULL);\n                    }\n                }\n\n                token_data[token_count] = &line_data[line_ofs];\n                token_count++;\n            }\n        }\n        line_ofs++;\n    } while (line_ofs != line_length);\n\n    /* if we have found some tokens then add a null token to the end */\n    if (token_count) {\n        if (token_count >= token_data_length) {\n            token_data = realloc(token_data,\n                ((token_count + 1) * sizeof(char *)));\n        }\n        token_data[token_count] = NULL;\n    }\n\n    return (token_data);\n}\n\nstatic int load_config(const char *config_file, const char *conf_dir) {\n    uint32_t config_size = 0;\n    char *config_buffer = NULL;\n    const char *dir_end = NULL;\n    char *config_dir = NULL;\n    uint32_t config_ptr = 0;\n    uint32_t line_start_ptr = 0;\n    uint16_t patchid = 0;\n    struct _patch * tmp_patch;\n    char **line_tokens = NULL;\n    int token_count = 0;\n\n    config_buffer = (char *) _WM_BufferFile(config_file, &config_size);\n    if (!config_buffer) {\n        WM_FreePatches();\n        return (-1);\n    }\n\n    if (conf_dir) {\n        if (!(config_dir = wm_strdup(conf_dir))) {\n            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_MEM, config_file, errno);\n            WM_FreePatches();\n            free(config_buffer);\n            return (-1);\n        }\n    } else {\n        dir_end = FIND_LAST_DIRSEP(config_file);\n        if (dir_end) {\n            config_dir = malloc((dir_end - config_file + 2));\n            if (config_dir == NULL) {\n                _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_MEM, config_file, errno);\n                WM_FreePatches();\n                free(config_buffer);\n                return (-1);\n            }\n            strncpy(config_dir, config_file, (dir_end - config_file + 1));\n            config_dir[dir_end - config_file + 1] = '\\0';\n        }\n    }\n\n    config_ptr = 0;\n    line_start_ptr = 0;\n\n    /* handle files without a newline at the end: this relies on\n     * _WM_BufferFile() allocating the buffer with one extra byte */\n    config_buffer[config_size] = '\\n';\n\n    while (config_ptr <= config_size) {\n        if (config_buffer[config_ptr] == '\\r' ||\n            config_buffer[config_ptr] == '\\n')\n        {\n            config_buffer[config_ptr] = '\\0';\n\n            if (config_ptr != line_start_ptr) {\n                _WM_Global_ErrorI = 0; /* because WM_LC_Tokenize_Line() can legitimately return NULL */\n                line_tokens = WM_LC_Tokenize_Line(&config_buffer[line_start_ptr]);\n                if (line_tokens) {\n                    if (wm_strcasecmp(line_tokens[0], \"dir\") == 0) {\n                        free(config_dir);\n                        if (!line_tokens[1]) {\n                            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(missing name in dir line)\", 0);\n                            WM_FreePatches();\n                            free(line_tokens);\n                            free(config_buffer);\n                            return (-1);\n                        } else if (!(config_dir = wm_strdup(line_tokens[1]))) {\n                            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_MEM, config_file, errno);\n                            WM_FreePatches();\n                            free(line_tokens);\n                            free(config_buffer);\n                            return (-1);\n                        }\n                        if (!IS_DIR_SEPARATOR(config_dir[strlen(config_dir) - 1])) {\n                            config_dir[strlen(config_dir) + 1] = '\\0';\n                            config_dir[strlen(config_dir)] = DIR_SEPARATOR_CHAR;\n                        }\n                    } else if (wm_strcasecmp(line_tokens[0], \"source\") == 0) {\n                        char *new_config = NULL;\n                        if (!line_tokens[1]) {\n                            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(missing name in source line)\", 0);\n                            WM_FreePatches();\n                            free(line_tokens);\n                            free(config_buffer);\n                            return (-1);\n                        } else if (!IS_ABSOLUTE_PATH(line_tokens[1]) && config_dir) {\n                            new_config = malloc(strlen(config_dir) + strlen(line_tokens[1]) + 1);\n                            if (new_config == NULL) {\n                                _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_MEM, config_file, errno);\n                                WM_FreePatches();\n                                free(config_dir);\n                                free(line_tokens);\n                                free(config_buffer);\n                                return (-1);\n                            }\n                            strcpy(new_config, config_dir);\n                            strcpy(&new_config[strlen(config_dir)], line_tokens[1]);\n                        } else {\n                            if (!(new_config = wm_strdup(line_tokens[1]))) {\n                                _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_MEM, config_file, errno);\n                                WM_FreePatches();\n                                free(line_tokens);\n                                free(config_buffer);\n                                return (-1);\n                            }\n                        }\n                        if (load_config(new_config, config_dir) == -1) {\n                            free(new_config);\n                            free(line_tokens);\n                            free(config_buffer);\n                            free(config_dir);\n                            return (-1);\n                        }\n                        free(new_config);\n                    } else if (wm_strcasecmp(line_tokens[0], \"bank\") == 0) {\n                        if (!line_tokens[1] || !wm_isdigit(line_tokens[1][0])) {\n                            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(syntax error in bank line)\", 0);\n                            WM_FreePatches();\n                            free(config_dir);\n                            free(line_tokens);\n                            free(config_buffer);\n                            return (-1);\n                        }\n                        patchid = (atoi(line_tokens[1]) & 0xFF) << 8;\n                    } else if (wm_strcasecmp(line_tokens[0], \"drumset\") == 0) {\n                        if (!line_tokens[1] || !wm_isdigit(line_tokens[1][0])) {\n                            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(syntax error in drumset line)\", 0);\n                            WM_FreePatches();\n                            free(config_dir);\n                            free(line_tokens);\n                            free(config_buffer);\n                            return (-1);\n                        }\n                        patchid = ((atoi(line_tokens[1]) & 0xFF) << 8) | 0x80;\n                    } else if (wm_strcasecmp(line_tokens[0], \"reverb_room_width\") == 0) {\n                        if (!line_tokens[1] || !wm_isdigit(line_tokens[1][0])) {\n                            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(syntax error in reverb_room_width line)\", 0);\n                            WM_FreePatches();\n                            free(config_dir);\n                            free(line_tokens);\n                            free(config_buffer);\n                            return (-1);\n                        }\n                        _WM_reverb_room_width = (float) atof(line_tokens[1]);\n                        if (_WM_reverb_room_width < 1.0f) {\n                            _WM_DEBUG_MSG(\"%s: reverb_room_width < 1 meter, setting to minimum of 1 meter\", config_file);\n                            _WM_reverb_room_width = 1.0f;\n                        } else if (_WM_reverb_room_width > 100.0f) {\n                            _WM_DEBUG_MSG(\"%s: reverb_room_width > 100 meters, setting to maximum of 100 meters\", config_file);\n                            _WM_reverb_room_width = 100.0f;\n                        }\n                    } else if (wm_strcasecmp(line_tokens[0], \"reverb_room_length\") == 0) {\n                        if (!line_tokens[1] || !wm_isdigit(line_tokens[1][0])) {\n                            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(syntax error in reverb_room_length line)\", 0);\n                            WM_FreePatches();\n                            free(config_dir);\n                            free(line_tokens);\n                            free(config_buffer);\n                            return (-1);\n                        }\n                        _WM_reverb_room_length = (float) atof(line_tokens[1]);\n                        if (_WM_reverb_room_length < 1.0f) {\n                            _WM_DEBUG_MSG(\"%s: reverb_room_length < 1 meter, setting to minimum of 1 meter\", config_file);\n                            _WM_reverb_room_length = 1.0f;\n                        } else if (_WM_reverb_room_length > 100.0f) {\n                            _WM_DEBUG_MSG(\"%s: reverb_room_length > 100 meters, setting to maximum of 100 meters\", config_file);\n                            _WM_reverb_room_length = 100.0f;\n                        }\n                    } else if (wm_strcasecmp(line_tokens[0], \"reverb_listener_posx\") == 0) {\n                        if (!line_tokens[1] || !wm_isdigit(line_tokens[1][0])) {\n                            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(syntax error in reverb_listen_posx line)\", 0);\n                            WM_FreePatches();\n                            free(config_dir);\n                            free(line_tokens);\n                            free(config_buffer);\n                            return (-1);\n                        }\n                        _WM_reverb_listen_posx = (float) atof(line_tokens[1]);\n                        if ((_WM_reverb_listen_posx > _WM_reverb_room_width)\n                                || (_WM_reverb_listen_posx < 0.0f)) {\n                            _WM_DEBUG_MSG(\"%s: reverb_listen_posx set outside of room\", config_file);\n                            _WM_reverb_listen_posx = _WM_reverb_room_width / 2.0f;\n                        }\n                    } else if (wm_strcasecmp(line_tokens[0],\n                            \"reverb_listener_posy\") == 0) {\n                        if (!line_tokens[1] || !wm_isdigit(line_tokens[1][0])) {\n                            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(syntax error in reverb_listen_posy line)\", 0);\n                            WM_FreePatches();\n                            free(config_dir);\n                            free(line_tokens);\n                            free(config_buffer);\n                            return (-1);\n                        }\n                        _WM_reverb_listen_posy = (float) atof(line_tokens[1]);\n                        if ((_WM_reverb_listen_posy > _WM_reverb_room_width)\n                                || (_WM_reverb_listen_posy < 0.0f)) {\n                            _WM_DEBUG_MSG(\"%s: reverb_listen_posy set outside of room\", config_file);\n                            _WM_reverb_listen_posy = _WM_reverb_room_length * 0.75f;\n                        }\n                    } else if (wm_strcasecmp(line_tokens[0], \"guspat_editor_author_cant_read_so_fix_release_time_for_me\") == 0) {\n                        _WM_fix_release = 1;\n                    } else if (wm_strcasecmp(line_tokens[0], \"auto_amp\") == 0) {\n                        _WM_auto_amp = 1;\n                    } else if (wm_strcasecmp(line_tokens[0], \"auto_amp_with_amp\") == 0) {\n                        _WM_auto_amp = 1;\n                        _WM_auto_amp_with_amp = 1;\n                    } else if (wm_isdigit(line_tokens[0][0])) {\n                        patchid = (patchid & 0xFF80)\n                                | (atoi(line_tokens[0]) & 0x7F);\n                        if (_WM_patch[(patchid & 0x7F)] == NULL) {\n                            _WM_patch[(patchid & 0x7F)] = malloc(sizeof(struct _patch));\n                            if (_WM_patch[(patchid & 0x7F)] == NULL) {\n                                _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_MEM, config_file, errno);\n                                WM_FreePatches();\n                                free(config_dir);\n                                free(line_tokens);\n                                free(config_buffer);\n                                return (-1);\n                            }\n                            tmp_patch = _WM_patch[(patchid & 0x7F)];\n                            tmp_patch->patchid = patchid;\n                            tmp_patch->filename = NULL;\n                            tmp_patch->amp = 1024;\n                            tmp_patch->note = 0;\n                            tmp_patch->next = NULL;\n                            tmp_patch->first_sample = NULL;\n                            tmp_patch->loaded = 0;\n                            tmp_patch->inuse_count = 0;\n                        } else {\n                            tmp_patch = _WM_patch[(patchid & 0x7F)];\n                            if (tmp_patch->patchid == patchid) {\n                                free(tmp_patch->filename);\n                                tmp_patch->filename = NULL;\n                                tmp_patch->amp = 1024;\n                                tmp_patch->note = 0;\n                            } else {\n                                if (tmp_patch->next) {\n                                    while (tmp_patch->next) {\n                                        if (tmp_patch->next->patchid == patchid)\n                                            break;\n                                        tmp_patch = tmp_patch->next;\n                                    }\n                                    if (tmp_patch->next == NULL) {\n                                        if ((tmp_patch->next = malloc(sizeof(struct _patch))) == NULL) {\n                                            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_MEM, config_file, 0);\n                                            WM_FreePatches();\n                                            free(config_dir);\n                                            free(line_tokens);\n                                            free(config_buffer);\n                                            return (-1);\n                                        }\n                                        tmp_patch = tmp_patch->next;\n                                        tmp_patch->patchid = patchid;\n                                        tmp_patch->filename = NULL;\n                                        tmp_patch->amp = 1024;\n                                        tmp_patch->note = 0;\n                                        tmp_patch->next = NULL;\n                                        tmp_patch->first_sample = NULL;\n                                        tmp_patch->loaded = 0;\n                                        tmp_patch->inuse_count = 0;\n                                    } else {\n                                        tmp_patch = tmp_patch->next;\n                                        free(tmp_patch->filename);\n                                        tmp_patch->filename = NULL;\n                                        tmp_patch->amp = 1024;\n                                        tmp_patch->note = 0;\n                                    }\n                                } else {\n                                    tmp_patch->next = malloc(\n                                            sizeof(struct _patch));\n                                    if (tmp_patch->next == NULL) {\n                                        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_MEM, config_file, errno);\n                                        WM_FreePatches();\n                                        free(config_dir);\n                                        free(line_tokens);\n                                        free(config_buffer);\n                                        return (-1);\n                                    }\n                                    tmp_patch = tmp_patch->next;\n                                    tmp_patch->patchid = patchid;\n                                    tmp_patch->filename = NULL;\n                                    tmp_patch->amp = 1024;\n                                    tmp_patch->note = 0;\n                                    tmp_patch->next = NULL;\n                                    tmp_patch->first_sample = NULL;\n                                    tmp_patch->loaded = 0;\n                                    tmp_patch->inuse_count = 0;\n                                }\n                            }\n                        }\n                        if (!line_tokens[1]) {\n                            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(missing name in patch line)\", 0);\n                            WM_FreePatches();\n                            free(config_dir);\n                            free(line_tokens);\n                            free(config_buffer);\n                            return (-1);\n                        } else if (!IS_ABSOLUTE_PATH(line_tokens[1]) && config_dir) {\n                            tmp_patch->filename = malloc(strlen(config_dir) + strlen(line_tokens[1]) + 5);\n                            if (tmp_patch->filename == NULL) {\n                                _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_MEM, config_file, 0);\n                                WM_FreePatches();\n                                free(config_dir);\n                                free(line_tokens);\n                                free(config_buffer);\n                                return (-1);\n                            }\n                            strcpy(tmp_patch->filename, config_dir);\n                            strcat(tmp_patch->filename, line_tokens[1]);\n                        } else {\n                            if (!(tmp_patch->filename = wm_strdup(line_tokens[1]))) {\n                                _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_MEM, config_file, 0);\n                                WM_FreePatches();\n                                free(config_dir);\n                                free(line_tokens);\n                                free(config_buffer);\n                                return (-1);\n                            }\n                        }\n                        if (wm_strncasecmp(&tmp_patch->filename[strlen(tmp_patch->filename) - 4], \".pat\", 4) != 0) {\n                            strcat(tmp_patch->filename, \".pat\");\n                        }\n                        tmp_patch->env[0].set = 0x00;\n                        tmp_patch->env[1].set = 0x00;\n                        tmp_patch->env[2].set = 0x00;\n                        tmp_patch->env[3].set = 0x00;\n                        tmp_patch->env[4].set = 0x00;\n                        tmp_patch->env[5].set = 0x00;\n                        tmp_patch->keep = 0;\n                        tmp_patch->remove = 0;\n\n                        token_count = 0;\n                        while (line_tokens[token_count]) {\n                            if (wm_strncasecmp(line_tokens[token_count], \"amp=\", 4) == 0) {\n                                if (!wm_isdigit(line_tokens[token_count][4])) {\n                                    _WM_DEBUG_MSG(\"%s: syntax error in patch line for %s\", config_file, \"amp=\");\n                                } else {\n                                    tmp_patch->amp = (atoi(&line_tokens[token_count][4]) << 10) / 100;\n                                }\n                            } else if (wm_strncasecmp(line_tokens[token_count], \"note=\", 5) == 0) {\n                                if (!wm_isdigit(line_tokens[token_count][5])) {\n                                    _WM_DEBUG_MSG(\"%s: syntax error in patch line for %s\", config_file, \"note=\");\n                                } else {\n                                    tmp_patch->note = atoi(&line_tokens[token_count][5]);\n                                }\n                            } else if (wm_strncasecmp(line_tokens[token_count], \"env_time\", 8) == 0) {\n                                if ((!wm_isdigit(line_tokens[token_count][8])) ||\n                                    (!wm_isdigit(line_tokens[token_count][10])) ||\n                                    (line_tokens[token_count][9] != '=')) {\n                                    _WM_DEBUG_MSG(\"%s: syntax error in patch line for %s\", config_file, \"env_time\");\n                                } else {\n                                    uint32_t env_no = atoi(&line_tokens[token_count][8]);\n                                    if (env_no > 5) {\n                                        _WM_DEBUG_MSG(\"%s: syntax error in patch line for %s\", config_file, \"env_time\");\n                                    } else {\n                                        tmp_patch->env[env_no].time = (float) atof(&line_tokens[token_count][10]);\n                                        if ((tmp_patch->env[env_no].time > 45000.0f) ||\n                                            (tmp_patch->env[env_no].time < 1.47f)) {\n                                            _WM_DEBUG_MSG(\"%s: range error in patch line %s\", config_file, \"env_time\");\n                                            tmp_patch->env[env_no].set &= 0xFE;\n                                        } else {\n                                            tmp_patch->env[env_no].set |= 0x01;\n                                        }\n                                    }\n                                }\n                            } else if (wm_strncasecmp(line_tokens[token_count], \"env_level\", 9) == 0) {\n                                if ((!wm_isdigit(line_tokens[token_count][9])) ||\n                                    (!wm_isdigit(line_tokens[token_count][11])) ||\n                                    (line_tokens[token_count][10] != '=')) {\n                                    _WM_DEBUG_MSG(\"%s: syntax error in patch line for %s\", config_file, \"env_level\");\n                                } else {\n                                    uint32_t env_no = atoi(&line_tokens[token_count][9]);\n                                    if (env_no > 5) {\n                                        _WM_DEBUG_MSG(\"%s: syntax error in patch line for %s\", config_file, \"env_level\");\n                                    } else {\n                                        tmp_patch->env[env_no].level = (float) atof(&line_tokens[token_count][11]);\n                                        if ((tmp_patch->env[env_no].level > 1.0f) ||\n                                            (tmp_patch->env[env_no].level < 0.0f)) {\n                                            _WM_DEBUG_MSG(\"%s: range error in patch line for %s\", config_file, \"env_level\");\n                                            tmp_patch->env[env_no].set &= 0xFD;\n                                        } else {\n                                            tmp_patch->env[env_no].set |= 0x02;\n                                        }\n                                    }\n                                }\n                            } else if (wm_strcasecmp(line_tokens[token_count], \"keep=loop\") == 0) {\n                                tmp_patch->keep |= SAMPLE_LOOP;\n                            } else if (wm_strcasecmp(line_tokens[token_count], \"keep=env\") == 0) {\n                                tmp_patch->keep |= SAMPLE_ENVELOPE;\n                            } else if (wm_strcasecmp(line_tokens[token_count], \"remove=sustain\") == 0) {\n                                tmp_patch->remove |= SAMPLE_SUSTAIN;\n                            } else if (wm_strcasecmp(line_tokens[token_count], \"remove=clamped\") == 0) {\n                                tmp_patch->remove |= SAMPLE_CLAMPED;\n                            }\n                            token_count++;\n                        }\n                    }\n                }\n                else if (_WM_Global_ErrorI) { /* malloc() failure in WM_LC_Tokenize_Line() */\n                    WM_FreePatches();\n                    free(line_tokens);\n                    free(config_buffer);\n                    return (-1);\n                }\n                /* free up tokens */\n                free(line_tokens);\n            }\n            line_start_ptr = config_ptr + 1;\n        }\n        config_ptr++;\n    }\n\n    free(config_buffer);\n    free(config_dir);\n\n    return (0);\n}\n\nstatic int WM_LoadConfig(const char *config_file) {\n    return load_config(config_file, NULL);\n}\n\nstatic int add_handle(void * handle) {\n    struct _hndl *tmp_handle = NULL;\n\n    if (first_handle == NULL) {\n        first_handle = malloc(sizeof(struct _hndl));\n        if (first_handle == NULL) {\n            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_MEM, \" to get ram\", errno);\n            return (-1);\n        }\n        first_handle->handle = handle;\n        first_handle->prev = NULL;\n        first_handle->next = NULL;\n    } else {\n        tmp_handle = first_handle;\n        if (tmp_handle->next) {\n            while (tmp_handle->next)\n                tmp_handle = tmp_handle->next;\n        }\n        tmp_handle->next = malloc(sizeof(struct _hndl));\n        if (tmp_handle->next == NULL) {\n            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_MEM, \" to get ram\", errno);\n            return (-1);\n        }\n        tmp_handle->next->prev = tmp_handle;\n        tmp_handle = tmp_handle->next;\n        tmp_handle->next = NULL;\n        tmp_handle->handle = handle;\n    }\n    return (0);\n}\n\n//#define DEBUG_RESAMPLE\n\n#ifdef DEBUG_RESAMPLE\n#define RESAMPLE_DEBUGI(dx,dy) fprintf(stderr,\"\\r%s, %i\\n\",dx,dy)\n#define RESAMPLE_DEBUGS(dx) fprintf(stderr,\"\\r%s\\n\",dx)\n\n#else\n#define RESAMPLE_DEBUGI(dx,dy)\n#define RESAMPLE_DEBUGS(dx)\n\n#endif\n\n\nstatic int WM_GetOutput_Linear(midi * handle, int8_t *buffer, uint32_t size) {\n    uint32_t buffer_used = 0;\n    uint32_t i;\n    struct _mdi *mdi = (struct _mdi *) handle;\n    uint32_t real_samples_to_mix = 0;\n    uint32_t data_pos;\n    int32_t premix, left_mix, right_mix;\n//  int32_t vol_mul;\n    struct _note *note_data = NULL;\n    uint32_t count;\n    struct _event *event = mdi->current_event;\n    int32_t *tmp_buffer;\n    int32_t *out_buffer;\n\n    _WM_Lock(&mdi->lock);\n\n    buffer_used = 0;\n    memset(buffer, 0, size);\n\n    if ( (size / 2) > mdi->mix_buffer_size) {\n        if ( (size / 2) <= ( mdi->mix_buffer_size * 2 )) {\n            mdi->mix_buffer_size += MEM_CHUNK;\n        } else {\n            mdi->mix_buffer_size = size / 2;\n        }\n        mdi->mix_buffer = realloc(mdi->mix_buffer, mdi->mix_buffer_size * sizeof(int32_t));\n    }\n\n    tmp_buffer = mdi->mix_buffer;\n\n    memset(tmp_buffer, 0, ((size / 2) * sizeof(int32_t)));\n    out_buffer = tmp_buffer;\n\n    do {\n        if (__builtin_expect((!mdi->samples_to_mix), 0)) {\n            while ((!mdi->samples_to_mix) && (event->do_event)) {\n                event->do_event(mdi, &event->event_data);\n                if ((mdi->extra_info.mixer_options & WM_MO_LOOP) && (event[0].do_event == *_WM_do_meta_endoftrack)) {\n                    _WM_ResetToStart(mdi);\n                    event = mdi->current_event;\n                } else {\n                    mdi->samples_to_mix = event->samples_to_next;\n                    event++;\n                    mdi->current_event = event;\n                }\n            }\n\n            if (__builtin_expect((!mdi->samples_to_mix), 0)) {\n                if (mdi->extra_info.current_sample >= mdi->extra_info.approx_total_samples) {\n                    break;\n                } else if ((mdi->extra_info.approx_total_samples\n                             - mdi->extra_info.current_sample) > (size >> 2)) {\n                    mdi->samples_to_mix = size >> 2;\n                } else {\n                    mdi->samples_to_mix = mdi->extra_info.approx_total_samples\n                                           - mdi->extra_info.current_sample;\n                }\n            }\n        }\n        if (__builtin_expect((mdi->samples_to_mix > (size >> 2)), 1)) {\n            real_samples_to_mix = size >> 2;\n        } else {\n            real_samples_to_mix = mdi->samples_to_mix;\n            if (real_samples_to_mix == 0) {\n                continue;\n            }\n        }\n\n        /* do mixing here */\n        count = real_samples_to_mix;\n\n        do {\n            note_data = mdi->note;\n            left_mix = right_mix = 0;\n            RESAMPLE_DEBUGI(\"SAMPLES_TO_MIX\",count);\n            if (__builtin_expect((note_data != NULL), 1)) {\n                RESAMPLE_DEBUGS(\"Processing Notes\");\n                while (note_data) {\n                    /*\n                     * ===================\n                     * resample the sample\n                     * ===================\n                     */\n                    data_pos = note_data->sample_pos >> FPBITS;\n                    premix = ((note_data->sample->data[data_pos] + (((note_data->sample->data[data_pos + 1] - note_data->sample->data[data_pos]) * (int32_t)(note_data->sample_pos & FPMASK)) / 1024)) * (note_data->env_level >> 12)) / 1024;\n\n                    left_mix += (premix * (int32_t)note_data->left_mix_volume) / 1024;\n                    right_mix += (premix * (int32_t)note_data->right_mix_volume) / 1024;\n\n                    /*\n                     * ========================\n                     * sample position checking\n                     * ========================\n                     */\n#ifdef DEBUG_RESAMPLE\n                    fprintf(stderr,\"\\r\\n%d -> INC %i, ENV %i, LEVEL %i, TARGET %d, RATE %i, SAMPLE POS %i, SAMPLE LENGTH %i, PREMIX %i (%i:%i)\",\n                            (uint32_t)note_data,\n                            note_data->env_inc,\n                            note_data->env, note_data->env_level,\n                            note_data->sample->env_target[note_data->env],\n                            note_data->sample->env_rate[note_data->env],\n                            note_data->sample_pos,\n                            note_data->sample->data_length,\n                            premix, left_mix, right_mix);\n                    if (note_data->modes & SAMPLE_LOOP)\n                        fprintf(stderr,\", LOOP %i + %i\",\n                                note_data->sample->loop_start,\n                                note_data->sample->loop_size);\n                    fprintf(stderr,\"\\r\\n\");\n#endif\n\n                    note_data->sample_pos += note_data->sample_inc;\n\n                    if (__builtin_expect((note_data->modes & SAMPLE_LOOP), 1)) {\n                        if (__builtin_expect(\n                                             (note_data->sample_pos > note_data->sample->loop_end),\n                                             0)) {\n                            note_data->sample_pos = note_data->sample->loop_start\n                                + ((note_data->sample_pos\n                                    - note_data->sample->loop_start)\n                                % note_data->sample->loop_size);\n                        }\n\n                    } else if (__builtin_expect(\n                                                  (note_data->sample_pos\n                                                   >= note_data->sample->data_length),\n                                                  0)) {\n                        goto _END_THIS_NOTE;\n                    }\n\n                    if (__builtin_expect((note_data->env_inc == 0), 0)) {\n                        note_data = note_data->next;\n                        RESAMPLE_DEBUGS(\"Next Note: 0 env_inc\");\n                        continue;\n                    }\n\n                    note_data->env_level += note_data->env_inc;\n\n                    if (note_data->env_inc < 0) {\n                        if (__builtin_expect((note_data->env_level\n                            > note_data->sample->env_target[note_data->env]), 0)) {\n                            note_data = note_data->next;\n                            RESAMPLE_DEBUGS(\"Next Note: env_lvl > env_target\");\n                            continue;\n                        }\n                    } else if (note_data->env_inc > 0) {\n                        if (__builtin_expect((note_data->env_level\n                            < note_data->sample->env_target[note_data->env]), 0)) {\n                            note_data = note_data->next;\n                            RESAMPLE_DEBUGS(\"Next Note: env_lvl < env_target\");\n                            continue;\n                        }\n                    }\n\n                    // Yes could have a condition here but\n                    // it would crete another bottleneck\n                    note_data->env_level =\n                            note_data->sample->env_target[note_data->env];\n                    switch (note_data->env) {\n                    case 0:\n                        if (!(note_data->modes & SAMPLE_ENVELOPE)) {\n                            note_data->env_inc = 0;\n                            note_data = note_data->next;\n                            RESAMPLE_DEBUGS(\"Next Note: No Envelope\");\n                            continue;\n                        }\n                        break;\n                    case 2:\n                        if (note_data->modes & SAMPLE_SUSTAIN /*|| note_data->hold*/) {\n                            note_data->env_inc = 0;\n                            note_data = note_data->next;\n                            RESAMPLE_DEBUGS(\"Next Note: SAMPLE_SUSTAIN\");\n                            continue;\n                        } else if (note_data->modes & SAMPLE_CLAMPED) {\n                            note_data->env = 5;\n                            if (note_data->env_level\n                                    > note_data->sample->env_target[5]) {\n                                note_data->env_inc =\n                                        -note_data->sample->env_rate[5];\n                            } else {\n                                note_data->env_inc =\n                                        note_data->sample->env_rate[5];\n                            }\n                            continue;\n                        }\n                        break;\n                    case 5:\n                        if (__builtin_expect((note_data->env_level == 0), 1)) {\n                            goto _END_THIS_NOTE;\n                        }\n                        /* sample release */\n                        if (note_data->modes & SAMPLE_LOOP)\n                            note_data->modes ^= SAMPLE_LOOP;\n                        note_data->env_inc = 0;\n                        note_data = note_data->next;\n                        RESAMPLE_DEBUGS(\"Next Note: Sample Release\");\n\n                        continue;\n                    case 6:\n                        _END_THIS_NOTE:\n                        if (__builtin_expect((note_data->replay != NULL), 1)) {\n                            note_data->active = 0;\n                            {\n                                struct _note *prev_note = NULL;\n                                struct _note *nte_array = mdi->note;\n\n                                if (nte_array != note_data) {\n                                    do {\n                                        prev_note = nte_array;\n                                        nte_array = nte_array->next;\n                                    } while (nte_array != note_data);\n                                }\n                                if (prev_note) {\n                                    prev_note->next = note_data->replay;\n                                } else {\n                                    mdi->note = note_data->replay;\n                                }\n                                note_data->replay->next = note_data->next;\n                                note_data = note_data->replay;\n                                note_data->active = 1;\n                            }\n                        } else {\n                            note_data->active = 0;\n                            {\n                                struct _note *prev_note = NULL;\n                                struct _note *nte_array = mdi->note;\n\n                                if (nte_array != note_data) {\n                                    do {\n                                        prev_note = nte_array;\n                                        nte_array = nte_array->next;\n                                    } while ((nte_array != note_data)\n                                            && (nte_array));\n                                }\n                                if (prev_note) {\n                                    prev_note->next = note_data->next;\n                                } else {\n                                    mdi->note = note_data->next;\n                                }\n                                note_data = note_data->next;\n                            }\n                        }\n                        RESAMPLE_DEBUGS(\"Next Note: Killed Off Note\");\n                        continue;\n                    }\n                    note_data->env++;\n\n                    if (note_data->is_off == 1) {\n                        _WM_do_note_off_extra(note_data);\n                    } else {\n\n                        if (note_data->env_level\n                            >= note_data->sample->env_target[note_data->env]) {\n                            note_data->env_inc =\n                                -note_data->sample->env_rate[note_data->env];\n                        } else {\n                            note_data->env_inc =\n                                note_data->sample->env_rate[note_data->env];\n                        }\n                    }\n                    note_data = note_data->next;\n#ifdef DEBUG_RESAMPLE\n                    if (note_data != NULL)\n                        RESAMPLE_DEBUGI(\"Next Note: Next ENV \", note_data->env);\n                    else\n                        RESAMPLE_DEBUGS(\"Next Note: Next ENV\");\n#endif\n                    continue;\n                }\n            }\n            *tmp_buffer++ = left_mix;\n            *tmp_buffer++ = right_mix;\n        } while (--count);\n\n        buffer_used += real_samples_to_mix * 4;\n        size -= (real_samples_to_mix << 2);\n        mdi->extra_info.current_sample += real_samples_to_mix;\n        mdi->samples_to_mix -= real_samples_to_mix;\n    } while (size);\n\n    tmp_buffer = out_buffer;\n\n    if (mdi->extra_info.mixer_options & WM_MO_REVERB) {\n        _WM_do_reverb(mdi->reverb, tmp_buffer, (buffer_used / 2));\n    }\n\n    //_WM_DynamicVolumeAdjust(mdi, tmp_buffer, (buffer_used/2));\n\n    for (i = 0; i < buffer_used; i += 4) {\n        left_mix = *tmp_buffer++;\n        right_mix = *tmp_buffer++;\n\n        /*\n         * ===================\n         * Write to the buffer\n         * ===================\n         */\n#ifdef WORDS_BIGENDIAN\n        (*buffer++) = ((left_mix >> 8) & 0x7f) | ((left_mix >> 24) & 0x80);\n        (*buffer++) = left_mix & 0xff;\n        (*buffer++) = ((right_mix >> 8) & 0x7f) | ((right_mix >> 24) & 0x80);\n        (*buffer++) = right_mix & 0xff;\n#else\n        (*buffer++) = left_mix & 0xff;\n        (*buffer++) = ((left_mix >> 8) & 0x7f) | ((left_mix >> 24) & 0x80);\n        (*buffer++) = right_mix & 0xff;\n        (*buffer++) = ((right_mix >> 8) & 0x7f) | ((right_mix >> 24) & 0x80);\n#endif\n    }\n\n    _WM_Unlock(&mdi->lock);\n    return (buffer_used);\n}\n\nstatic int WM_GetOutput_Gauss(midi * handle, int8_t *buffer, uint32_t size) {\n    uint32_t buffer_used = 0;\n    uint32_t i;\n    struct _mdi *mdi = (struct _mdi *) handle;\n    uint32_t real_samples_to_mix = 0;\n    uint32_t data_pos;\n    int32_t premix, left_mix, right_mix;\n    struct _note *note_data = NULL;\n    uint32_t count;\n    int16_t *sptr;\n    double y, xd;\n    double *gptr, *gend;\n    int left, right, temp_n;\n    int ii, jj;\n    struct _event *event = mdi->current_event;\n    int32_t *tmp_buffer;\n    int32_t *out_buffer;\n\n    _WM_Lock(&mdi->lock);\n\n    buffer_used = 0;\n    memset(buffer, 0, size);\n\n    if ( (size / 2) > mdi->mix_buffer_size) {\n        if ( (size / 2) <= ( mdi->mix_buffer_size * 2 )) {\n            mdi->mix_buffer_size += MEM_CHUNK;\n        } else {\n            mdi->mix_buffer_size = size / 2;\n        }\n        mdi->mix_buffer = realloc(mdi->mix_buffer, mdi->mix_buffer_size * sizeof(int32_t));\n    }\n\n    tmp_buffer = mdi->mix_buffer;\n\n    memset(tmp_buffer, 0, ((size / 2) * sizeof(int32_t)));\n    out_buffer = tmp_buffer;\n\n    do {\n        if (__builtin_expect((!mdi->samples_to_mix), 0)) {\n            while ((!mdi->samples_to_mix) && (event->do_event)) {\n                event->do_event(mdi, &event->event_data);\n                if ((mdi->extra_info.mixer_options & WM_MO_LOOP) && (event[0].do_event == *_WM_do_meta_endoftrack)) {\n                    _WM_ResetToStart(mdi);\n                    event = mdi->current_event;\n                } else {\n                    mdi->samples_to_mix = event->samples_to_next;\n                    event++;\n                    mdi->current_event = event;\n                }\n            }\n\n            if (!mdi->samples_to_mix) {\n                if (mdi->extra_info.current_sample\n                    >= mdi->extra_info.approx_total_samples) {\n                    break;\n                } else if ((mdi->extra_info.approx_total_samples\n                            - mdi->extra_info.current_sample) > (size >> 2)) {\n                    mdi->samples_to_mix = size >> 2;\n                } else {\n                    mdi->samples_to_mix = mdi->extra_info.approx_total_samples\n                    - mdi->extra_info.current_sample;\n                }\n            }\n        }\n        if (__builtin_expect((mdi->samples_to_mix > (size >> 2)), 1)) {\n            real_samples_to_mix = size >> 2;\n        } else {\n            real_samples_to_mix = mdi->samples_to_mix;\n            if (real_samples_to_mix == 0) {\n                continue;\n            }\n        }\n\n        /* do mixing here */\n        count = real_samples_to_mix;\n        do {\n            note_data = mdi->note;\n            left_mix = right_mix = 0;\n            if (__builtin_expect((note_data != NULL), 1)) {\n                while (note_data) {\n                    /*\n                     * ===================\n                     * resample the sample\n                     * ===================\n                     */\n                    data_pos = note_data->sample_pos >> FPBITS;\n\n                    /* check to see if we're near one of the ends */\n                    left = data_pos;\n                    right = (note_data->sample->data_length >> FPBITS) - left\n                            - 1;\n                    temp_n = (right << 1) - 1;\n                    if (temp_n <= 0)\n                        temp_n = 1;\n                    if (temp_n > (left << 1) + 1)\n                        temp_n = (left << 1) + 1;\n\n                    /* use Newton if we can't fill the window */\n                    if (temp_n < gauss_n) {\n                        xd = note_data->sample_pos & FPMASK;\n                        xd /= (1L << FPBITS);\n                        xd += temp_n >> 1;\n                        y = 0;\n                        sptr = note_data->sample->data\n                                + (note_data->sample_pos >> FPBITS)\n                                - (temp_n >> 1);\n                        for (ii = temp_n; ii;) {\n                            for (jj = 0; jj <= ii; jj++)\n                                y += sptr[jj] * newt_coeffs[ii][jj];\n                            y *= xd - --ii;\n                        }\n                        y += *sptr;\n                    } else { /* otherwise, use Gauss as usual */\n                        y = 0;\n                        gptr = &gauss_table[(note_data->sample_pos & FPMASK) *\n                                     (gauss_n + 1)];\n                        gend = gptr + gauss_n;\n                        sptr = note_data->sample->data\n                                + (note_data->sample_pos >> FPBITS)\n                                - (gauss_n >> 1);\n                        do {\n                            y += *(sptr++) * *(gptr++);\n                        } while (gptr <= gend);\n                    }\n\n                    premix = (int32_t)((y * (note_data->env_level >> 12)) / 1024);\n\n                    left_mix += (premix * (int32_t)note_data->left_mix_volume) / 1024;\n                    right_mix += (premix * (int32_t)note_data->right_mix_volume) / 1024;\n\n                    /*\n                     * ========================\n                     * sample position checking\n                     * ========================\n                     */\n                    note_data->sample_pos += note_data->sample_inc;\n                    if (__builtin_expect(\n                                         (note_data->sample_pos > note_data->sample->loop_end),\n                                         0)) {\n                        if (note_data->modes & SAMPLE_LOOP) {\n                            note_data->sample_pos =\n                            note_data->sample->loop_start\n                            + ((note_data->sample_pos\n                                - note_data->sample->loop_start)\n                               % note_data->sample->loop_size);\n                        } else if (__builtin_expect(\n                                                    (note_data->sample_pos\n                                                     >= note_data->sample->data_length),\n                                                    0)) {\n                            goto _END_THIS_NOTE;\n                        }\n                    }\n\n                    if (__builtin_expect((note_data->env_inc == 0), 0)) {\n                        /*\n                         fprintf(stderr,\"\\r\\nINC = 0, ENV %i, LEVEL %i, TARGET %d, RATE %i\\r\\n\",\n                                 note_data->env, note_data->env_level,\n                                 note_data->sample->env_target[note_data->env],\n                                 note_data->sample->env_rate[note_data->env]);\n                         */\n                        note_data = note_data->next;\n                        continue;\n                    }\n\n                    note_data->env_level += note_data->env_inc;\n                    /*\n                     fprintf(stderr,\"\\r\\nENV %i, LEVEL %i, TARGET %d, RATE %i, INC %i\\r\\n\",\n                             note_data->env, note_data->env_level,\n                             note_data->sample->env_target[note_data->env],\n                             note_data->sample->env_rate[note_data->env],\n                             note_data->env_inc);\n                     */\n                    if (note_data->env_inc < 0) {\n                        if (note_data->env_level\n                            > note_data->sample->env_target[note_data->env]) {\n                            note_data = note_data->next;\n                            continue;\n                        }\n                    } else if (note_data->env_inc > 0) {\n                        if (note_data->env_level\n                            < note_data->sample->env_target[note_data->env]) {\n                            note_data = note_data->next;\n                            continue;\n                        }\n                    }\n\n                    // Yes could have a condition here but\n                    // it would crete another bottleneck\n\n                    note_data->env_level =\n                    note_data->sample->env_target[note_data->env];\n                    switch (note_data->env) {\n                        case 0:\n                            if (!(note_data->modes & SAMPLE_ENVELOPE)) {\n                                note_data->env_inc = 0;\n                                note_data = note_data->next;\n                                continue;\n                            }\n                            break;\n                        case 2:\n                            if (note_data->modes & SAMPLE_SUSTAIN /*|| note_data->hold*/) {\n                                note_data->env_inc = 0;\n                                note_data = note_data->next;\n                                continue;\n                            } else if (note_data->modes & SAMPLE_CLAMPED) {\n                                note_data->env = 5;\n                                if (note_data->env_level\n                                    > note_data->sample->env_target[5]) {\n                                    note_data->env_inc =\n                                    -note_data->sample->env_rate[5];\n                                } else {\n                                    note_data->env_inc =\n                                    note_data->sample->env_rate[5];\n                                }\n                                continue;\n                            }\n                            break;\n                        case 5:\n                            if (__builtin_expect((note_data->env_level == 0), 1)) {\n                                goto _END_THIS_NOTE;\n                            }\n                            /* sample release */\n                            if (note_data->modes & SAMPLE_LOOP)\n                                note_data->modes ^= SAMPLE_LOOP;\n                            note_data->env_inc = 0;\n                            note_data = note_data->next;\n                            continue;\n                        case 6:\n                        _END_THIS_NOTE:\n                            if (__builtin_expect((note_data->replay != NULL), 1)) {\n                                note_data->active = 0;\n                                {\n                                    struct _note *prev_note = NULL;\n                                    struct _note *nte_array = mdi->note;\n\n                                    if (nte_array != note_data) {\n                                        do {\n                                            prev_note = nte_array;\n                                            nte_array = nte_array->next;\n                                        } while (nte_array != note_data);\n                                    }\n                                    if (prev_note) {\n                                        prev_note->next = note_data->replay;\n                                    } else {\n                                        mdi->note = note_data->replay;\n                                    }\n                                    note_data->replay->next = note_data->next;\n                                    note_data = note_data->replay;\n                                    note_data->active = 1;\n                                }\n                            } else {\n                                note_data->active = 0;\n                                {\n                                    struct _note *prev_note = NULL;\n                                    struct _note *nte_array = mdi->note;\n\n                                    if (nte_array != note_data) {\n                                        do {\n                                            prev_note = nte_array;\n                                            nte_array = nte_array->next;\n                                        } while ((nte_array != note_data)\n                                                 && (nte_array));\n                                    }\n                                    if (prev_note) {\n                                        prev_note->next = note_data->next;\n                                    } else {\n                                        mdi->note = note_data->next;\n                                    }\n                                    note_data = note_data->next;\n                                }\n                            }\n                            continue;\n                    }\n                    note_data->env++;\n\n                    if (note_data->is_off == 1) {\n                        _WM_do_note_off_extra(note_data);\n                    } else {\n\n                        if (note_data->env_level\n                            >= note_data->sample->env_target[note_data->env]) {\n                            note_data->env_inc =\n                            -note_data->sample->env_rate[note_data->env];\n                        } else {\n                            note_data->env_inc =\n                            note_data->sample->env_rate[note_data->env];\n                        }\n                    }\n                    note_data = note_data->next;\n                    continue;\n                }\n            }\n            *tmp_buffer++ = left_mix;\n            *tmp_buffer++ = right_mix;\n        } while (--count);\n\n        buffer_used += real_samples_to_mix * 4;\n        size -= (real_samples_to_mix << 2);\n        mdi->extra_info.current_sample += real_samples_to_mix;\n        mdi->samples_to_mix -= real_samples_to_mix;\n    } while (size);\n\n    tmp_buffer = out_buffer;\n\n    if (mdi->extra_info.mixer_options & WM_MO_REVERB) {\n        _WM_do_reverb(mdi->reverb, tmp_buffer, (buffer_used / 2));\n    }\n\n    // _WM_DynamicVolumeAdjust(mdi, tmp_buffer, (buffer_used/2));\n\n    for (i = 0; i < buffer_used; i += 4) {\n        left_mix = *tmp_buffer++;\n        right_mix = *tmp_buffer++;\n\n        /*\n         * ===================\n         * Write to the buffer\n         * ===================\n         */\n#ifdef WORDS_BIGENDIAN\n        (*buffer++) = ((left_mix >> 8) & 0x7f) | ((left_mix >> 24) & 0x80);\n        (*buffer++) = left_mix & 0xff;\n        (*buffer++) = ((right_mix >> 8) & 0x7f) | ((right_mix >> 24) & 0x80);\n        (*buffer++) = right_mix & 0xff;\n#else\n        (*buffer++) = left_mix & 0xff;\n        (*buffer++) = ((left_mix >> 8) & 0x7f) | ((left_mix >> 24) & 0x80);\n        (*buffer++) = right_mix & 0xff;\n        (*buffer++) = ((right_mix >> 8) & 0x7f) | ((right_mix >> 24) & 0x80);\n#endif\n    }\n    _WM_Unlock(&mdi->lock);\n    return (buffer_used);\n}\n\n/*\n * =========================\n * External Functions\n * =========================\n */\n\nWM_SYMBOL int WildMidi_ConvertToMidi (const char *file, uint8_t **out, uint32_t *size) {\n    uint8_t *buf;\n    int ret;\n\n    if (!file) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(NULL filename)\", 0);\n        return (-1);\n    }\n    if ((buf = (uint8_t *) _WM_BufferFile(file, size)) == NULL) {\n        return (-1);\n    }\n\n    ret = WildMidi_ConvertBufferToMidi(buf, *size, out, size);\n    free(buf);\n    return ret;\n}\n\nWM_SYMBOL int WildMidi_ConvertBufferToMidi (uint8_t *in, uint32_t insize,\n                                            uint8_t **out, uint32_t *outsize) {\n    if (!in || !out || !outsize) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(NULL params)\", 0);\n        return (-1);\n    }\n\n    if (!memcmp(in, \"FORM\", 4)) {\n        if (_WM_xmi2midi(in, insize, out, outsize,\n                _cvt_get_option(WM_CO_XMI_TYPE)) < 0) {\n            return (-1);\n        }\n    }\n    else if (!memcmp(in, \"MUS\", 3)) {\n        if (_WM_mus2midi(in, insize, out, outsize,\n                _cvt_get_option(WM_CO_FREQUENCY)) < 0) {\n            return (-1);\n        }\n    }\n    else if (!memcmp(in, \"MThd\", 4)) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, 0, \"Already a midi file\", 0);\n        return (-1);\n    }\n    else {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID, NULL, 0);\n        return (-1);\n    }\n\n    return (0);\n}\n\nWM_SYMBOL const char *WildMidi_GetString(uint16_t info) {\n    static char WM_Version[] = \"WildMidi Processing Library \" PACKAGE_VERSION;\n    switch (info) {\n    case WM_GS_VERSION:\n        return WM_Version;\n    }\n    return NULL;\n}\n\nWM_SYMBOL long WildMidi_GetVersion (void) {\n    return (LIBWILDMIDI_VERSION);\n}\n\nWM_SYMBOL int WildMidi_Init(const char *config_file, uint16_t rate, uint16_t mixer_options) {\n    if (WM_Initialized) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_ALR_INIT, NULL, 0);\n        return (-1);\n    }\n\n    if (config_file == NULL) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG,\n                \"(NULL config file pointer)\", 0);\n        return (-1);\n    }\n    WM_InitPatches();\n    if (WM_LoadConfig(config_file) == -1) {\n        return (-1);\n    }\n\n    if (mixer_options & 0x0FF0) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(invalid option)\",\n                0);\n        WM_FreePatches();\n        return (-1);\n    }\n    _WM_MixerOptions = mixer_options;\n\n    if (rate < 11025) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG,\n                \"(rate out of bounds, range is 11025 - 65535)\", 0);\n        WM_FreePatches();\n        return (-1);\n    }\n    _WM_SampleRate = rate;\n\n    gauss_lock = 0;\n    _WM_patch_lock = 0;\n    _WM_MasterVolume = 948;\n    WM_Initialized = 1;\n\n    return (0);\n}\n\nWM_SYMBOL int WildMidi_MasterVolume(uint8_t master_volume) {\n    if (!WM_Initialized) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_INIT, NULL, 0);\n        return (-1);\n    }\n    if (master_volume > 127) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG,\n                \"(master volume out of range, range is 0-127)\", 0);\n        return (-1);\n    }\n\n    _WM_MasterVolume = _WM_lin_volume[master_volume];\n\n    return (0);\n}\n\nWM_SYMBOL int WildMidi_Close(midi * handle) {\n    struct _mdi *mdi = (struct _mdi *) handle;\n    struct _hndl * tmp_handle;\n\n    if (!WM_Initialized) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_INIT, NULL, 0);\n        return (-1);\n    }\n    if (handle == NULL) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(NULL handle)\", 0);\n        return (-1);\n    }\n    if (first_handle == NULL) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(no midi's open)\", 0);\n        return (-1);\n    }\n    _WM_Lock(&mdi->lock);\n    if (first_handle->handle == handle) {\n        tmp_handle = first_handle->next;\n        free(first_handle);\n        first_handle = tmp_handle;\n        if (first_handle)\n            first_handle->prev = NULL;\n    } else {\n        tmp_handle = first_handle;\n        while (tmp_handle->handle != handle) {\n            tmp_handle = tmp_handle->next;\n            if (tmp_handle == NULL) {\n                break;\n            }\n        }\n        if (tmp_handle) {\n            tmp_handle->prev->next = tmp_handle->next;\n            if (tmp_handle->next) {\n                tmp_handle->next->prev = tmp_handle->prev;\n            }\n            free(tmp_handle);\n        }\n    }\n\n    _WM_freeMDI(mdi);\n\n    return (0);\n}\n\nWM_SYMBOL midi *WildMidi_Open(const char *midifile) {\n    uint8_t *mididata = NULL;\n    uint32_t midisize = 0;\n    uint8_t mus_hdr[] = { 'M', 'U', 'S', 0x1A };\n    uint8_t xmi_hdr[] = { 'F', 'O', 'R', 'M' };\n    midi * ret = NULL;\n\n    if (!WM_Initialized) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_INIT, NULL, 0);\n        return (NULL);\n    }\n    if (midifile == NULL) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(NULL filename)\", 0);\n        return (NULL);\n    }\n\n    if ((mididata = (uint8_t *) _WM_BufferFile(midifile, &midisize)) == NULL) {\n        return (NULL);\n    }\n    if (memcmp(mididata,\"HMIMIDIP\", 8) == 0) {\n        ret = (void *) _WM_ParseNewHmp(mididata, midisize);\n    } else if (memcmp(mididata, \"HMI-MIDISONG061595\", 18) == 0) {\n        ret = (void *) _WM_ParseNewHmi(mididata, midisize);\n    } else if (memcmp(mididata, mus_hdr, 4) == 0) {\n        ret = (void *) _WM_ParseNewMus(mididata, midisize);\n    } else if (memcmp(mididata, xmi_hdr, 4) == 0) {\n        ret = (void *) _WM_ParseNewXmi(mididata, midisize);\n    } else {\n        ret = (void *) _WM_ParseNewMidi(mididata, midisize);\n    }\n    free(mididata);\n\n    if (ret) {\n        if (add_handle(ret) != 0) {\n            WildMidi_Close(ret);\n            ret = NULL;\n        }\n    }\n\n    return (ret);\n}\n\nWM_SYMBOL midi *WildMidi_OpenBuffer(uint8_t *midibuffer, uint32_t size) {\n    uint8_t mus_hdr[] = { 'M', 'U', 'S', 0x1A };\n    uint8_t xmi_hdr[] = { 'F', 'O', 'R', 'M' };\n    midi * ret = NULL;\n\n    if (!WM_Initialized) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_INIT, NULL, 0);\n        return (NULL);\n    }\n    if (midibuffer == NULL) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(NULL midi data buffer)\", 0);\n        return (NULL);\n    }\n    if (size > WM_MAXFILESIZE) {\n        /* don't bother loading suspiciously long files */\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_LONGFIL, NULL, 0);\n        return (NULL);\n    }\n    if (memcmp(midibuffer,\"HMIMIDIP\", 8) == 0) {\n        ret = (void *) _WM_ParseNewHmp(midibuffer, size);\n    } else if (memcmp(midibuffer, \"HMI-MIDISONG061595\", 18) == 0) {\n        ret = (void *) _WM_ParseNewHmi(midibuffer, size);\n    } else if (memcmp(midibuffer, mus_hdr, 4) == 0) {\n        ret = (void *) _WM_ParseNewMus(midibuffer, size);\n    } else if (memcmp(midibuffer, xmi_hdr, 4) == 0) {\n        ret = (void *) _WM_ParseNewXmi(midibuffer, size);\n    } else {\n        ret = (void *) _WM_ParseNewMidi(midibuffer, size);\n    }\n\n    if (ret) {\n        if (add_handle(ret) != 0) {\n            WildMidi_Close(ret);\n            ret = NULL;\n        }\n    }\n\n    return (ret);\n}\n\nWM_SYMBOL int WildMidi_FastSeek(midi * handle, unsigned long int *sample_pos) {\n    struct _mdi *mdi;\n    struct _event *event;\n    struct _note *note_data;\n\n    if (!WM_Initialized) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_INIT, NULL, 0);\n        return (-1);\n    }\n    if (handle == NULL) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(NULL handle)\", 0);\n        return (-1);\n    }\n    if (sample_pos == NULL) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(NULL seek position pointer)\", 0);\n        return (-1);\n    }\n\n    mdi = (struct _mdi *) handle;\n    _WM_Lock(&mdi->lock);\n    event = mdi->current_event;\n\n    /* make sure we havent asked for a positions beyond the end of the song. */\n    if (*sample_pos > mdi->extra_info.approx_total_samples) {\n        /* if so set the position to the end of the song */\n        *sample_pos = mdi->extra_info.approx_total_samples;\n    }\n\n    /* was end of song requested and are we are there? */\n    if (*sample_pos == mdi->extra_info.approx_total_samples) {\n        /* yes */\n        _WM_Unlock(&mdi->lock);\n        return (0);\n    }\n\n    /* did we want to fast forward? */\n    if (mdi->extra_info.current_sample > *sample_pos) {\n        /* no - reset some stuff */\n        event = mdi->events;\n        _WM_ResetToStart(handle);\n        mdi->extra_info.current_sample = 0;\n        mdi->samples_to_mix = 0;\n    }\n\n    if ((mdi->extra_info.current_sample + mdi->samples_to_mix) > *sample_pos) {\n        mdi->samples_to_mix = (mdi->extra_info.current_sample + mdi->samples_to_mix) - *sample_pos;\n        mdi->extra_info.current_sample = *sample_pos;\n    } else {\n        mdi->extra_info.current_sample += mdi->samples_to_mix;\n        mdi->samples_to_mix = 0;\n        while ((!mdi->samples_to_mix) && (event->do_event)) {\n            event->do_event(mdi, &event->event_data);\n            mdi->samples_to_mix = event->samples_to_next;\n                \n            if ((mdi->extra_info.current_sample + mdi->samples_to_mix) > *sample_pos) {\n                mdi->samples_to_mix = (mdi->extra_info.current_sample + mdi->samples_to_mix) - *sample_pos;\n                mdi->extra_info.current_sample = *sample_pos;\n            } else {\n                mdi->extra_info.current_sample += mdi->samples_to_mix;\n                mdi->samples_to_mix = 0;\n            }\n            event++;\n        }\n        mdi->current_event = event;\n    }\n\n    /*\n     * Clear notes as this is a fast seek so we only care\n     * about new notes.\n     *\n     * NOTE: This function is for performance only.\n     * Might need a WildMidi_SlowSeek if we need better accuracy.\n     */\n    note_data = mdi->note;\n    if (note_data) {\n        do {\n            note_data->active = 0;\n            if (note_data->replay) {\n                note_data->replay = NULL;\n            }\n            note_data = note_data->next;\n        } while (note_data);\n    }\n    mdi->note = NULL;\n\n    /* clear the reverb buffers since we not gonna be using them here */\n    _WM_reset_reverb(mdi->reverb);\n\n    _WM_Unlock(&mdi->lock);\n    return (0);\n}\n\nWM_SYMBOL int WildMidi_SongSeek (midi * handle, int8_t nextsong) {\n    struct _mdi *mdi;\n    struct _event *event;\n    struct _event *event_new;\n    struct _note *note_data;\n\n    if (!WM_Initialized) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_INIT, NULL, 0);\n        return (-1);\n    }\n    if (handle == NULL) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(NULL handle)\", 0);\n        return (-1);\n    }\n    mdi = (struct _mdi *) handle;\n    _WM_Lock(&mdi->lock);\n\n    if ((!mdi->is_type2) && (nextsong != 0)) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(Illegal use. Only usable with files detected to be type 2 compatible.\", 0);\n        _WM_Unlock(&mdi->lock);\n        return (-1);\n    }\n    if ((nextsong > 1) || (nextsong < -1)) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(Invalid nextsong setting. -1 is previous song, 0 start of current song, 1 is next song)\", 0);\n        _WM_Unlock(&mdi->lock);\n        return (-1);\n    }\n\n    event = mdi->current_event;\n\n    if (nextsong == -1) {\n        /* goto start of previous song */\n        /*\n         * So with this one we have to go back 2 eof's\n         * then forward 1 event to get to the start of\n         * the previous song.\n         * NOTE: We will automatically stop at the start \n         * of the data.\n         */\n        uint8_t eof_cnt = 1;\n        while (event != mdi->events) {\n            if (event[-1].do_event == _WM_do_meta_endoftrack) {\n                if (eof_cnt == 0) {\n                    break;\n                }\n                eof_cnt = 0;\n            }\n            event--;\n        }\n        event_new = event;\n        event = mdi->events;\n        _WM_ResetToStart(handle);\n\n    } else if (nextsong == 1) {\n        /* goto start of next song */\n        while (event->do_event != NULL) {\n            if (event->do_event == _WM_do_meta_endoftrack) {\n                event++;\n                if (event->do_event == NULL) {\n                    event--;\n                    goto START_THIS_SONG;\n                } else {\n                    break;\n                }\n            }\n            event++;\n        }\n        event_new = event;\n        event = mdi->current_event;\n\n    } else {\n    START_THIS_SONG:\n        /* goto start of this song */\n        /* first find the offset */\n        while (event != mdi->events) {\n            if (event[-1].do_event == _WM_do_meta_endoftrack) {\n                break;\n            }\n            event--;\n        }\n        event_new = event;\n        event = mdi->events;\n        _WM_ResetToStart(handle);\n    }\n\n    while (event != event_new) {\n        event->do_event(mdi, &event->event_data);\n        mdi->extra_info.current_sample += event->samples_to_next;\n        event++;\n    }\n\n    mdi->current_event = event;\n\n    note_data = mdi->note;\n    if (note_data) {\n        do {\n            note_data->active = 0;\n            if (note_data->replay) {\n                note_data->replay = NULL;\n            }\n            note_data = note_data->next;\n        } while (note_data);\n    }\n    mdi->note = NULL;\n\n    _WM_Unlock(&mdi->lock);\n    return (0);\n}\n\nWM_SYMBOL int WildMidi_GetOutput(midi * handle, int8_t *buffer, uint32_t size) {\n    if (__builtin_expect((!WM_Initialized), 0)) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_INIT, NULL, 0);\n        return (-1);\n    }\n    if (__builtin_expect((handle == NULL), 0)) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(NULL handle)\", 0);\n        return (-1);\n    }\n    if (__builtin_expect((buffer == NULL), 0)) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(NULL buffer pointer)\", 0);\n        return (-1);\n    }\n    if (__builtin_expect((size == 0), 0)) {\n        return (0);\n    }\n    if (__builtin_expect((!!(size % 4)), 0)) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(size not a multiple of 4)\", 0);\n        return (-1);\n    }\n\n    if (((struct _mdi *) handle)->extra_info.mixer_options & WM_MO_ENHANCED_RESAMPLING) {\n        if (!gauss_table) init_gauss();\n        return (WM_GetOutput_Gauss(handle, buffer, size));\n    }\n    return (WM_GetOutput_Linear(handle, buffer, size));\n}\n\nWM_SYMBOL int WildMidi_GetMidiOutput(midi * handle, int8_t **buffer, uint32_t *size) {\n    if (__builtin_expect((!WM_Initialized), 0)) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_INIT, NULL, 0);\n        return (-1);\n    }\n    if (__builtin_expect((handle == NULL), 0)) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(NULL handle)\", 0);\n        return (-1);\n    }\n    if (__builtin_expect((buffer == NULL), 0)) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(NULL buffer pointer)\", 0);\n        return (-1);\n    }\n    return _WM_Event2Midi(handle, (uint8_t **)buffer, size);\n}\n\n\nWM_SYMBOL int WildMidi_SetOption(midi * handle, uint16_t options, uint16_t setting) {\n    struct _mdi *mdi;\n\n    if (!WM_Initialized) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_INIT, NULL, 0);\n        return (-1);\n    }\n    if (handle == NULL) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(NULL handle)\", 0);\n        return (-1);\n    }\n\n    mdi = (struct _mdi *) handle;\n    _WM_Lock(&mdi->lock);\n    if ((!(options & 0x800F)) || (options & 0x7FF0)) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(invalid option)\", 0);\n        _WM_Unlock(&mdi->lock);\n        return (-1);\n    }\n    if (setting & 0x7FF0) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(invalid setting)\", 0);\n        _WM_Unlock(&mdi->lock);\n        return (-1);\n    }\n\n    mdi->extra_info.mixer_options = ((mdi->extra_info.mixer_options & (0x80FF ^ options))\n                                    | (options & setting));\n\n    if (options & WM_MO_LOG_VOLUME) {\n            _WM_AdjustChannelVolumes(mdi, 16);  // Settings greater than 15\n                                                // adjusts all channels\n    } else if (options & WM_MO_REVERB) {\n        _WM_reset_reverb(mdi->reverb);\n    }\n\n    _WM_Unlock(&mdi->lock);\n    return (0);\n}\n\nWM_SYMBOL int WildMidi_SetCvtOption(uint16_t tag, uint16_t setting) {\n    _WM_Lock(&WM_ConvertOptions.lock);\n    switch (tag) {\n    case WM_CO_XMI_TYPE: /* validation happens in xmidi.c */\n        WM_ConvertOptions.xmi_convert_type = setting;\n        break;\n    case WM_CO_FREQUENCY: /* validation happens in format */\n        WM_ConvertOptions.frequency = setting;\n        break;\n    default:\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(invalid setting)\", 0);\n        _WM_Unlock(&WM_ConvertOptions.lock);\n        return (-1);\n    }\n    _WM_Unlock(&WM_ConvertOptions.lock);\n    return (0);\n}\n\nWM_SYMBOL struct _WM_Info *\nWildMidi_GetInfo(midi * handle) {\n    struct _mdi *mdi = (struct _mdi *) handle;\n    if (!WM_Initialized) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_INIT, NULL, 0);\n        return (NULL);\n    }\n    if (handle == NULL) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(NULL handle)\", 0);\n        return (NULL);\n    }\n    _WM_Lock(&mdi->lock);\n    if (mdi->tmp_info == NULL) {\n        mdi->tmp_info = malloc(sizeof(struct _WM_Info));\n        if (mdi->tmp_info == NULL) {\n            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_MEM, \"to set info\", 0);\n            _WM_Unlock(&mdi->lock);\n            return (NULL);\n        }\n        mdi->tmp_info->copyright = NULL;\n    }\n    mdi->tmp_info->current_sample = mdi->extra_info.current_sample;\n    mdi->tmp_info->approx_total_samples = mdi->extra_info.approx_total_samples;\n    mdi->tmp_info->mixer_options = mdi->extra_info.mixer_options;\n    mdi->tmp_info->total_midi_time = (mdi->tmp_info->approx_total_samples * 1000) / _WM_SampleRate;\n    if (mdi->extra_info.copyright) {\n        free(mdi->tmp_info->copyright);\n        mdi->tmp_info->copyright = malloc(strlen(mdi->extra_info.copyright) + 1);\n        if (mdi->tmp_info->copyright == NULL) {\n            free(mdi->tmp_info);\n            mdi->tmp_info = NULL;\n            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_MEM, \"to set copyright\", 0);\n            _WM_Unlock(&mdi->lock);\n            return (NULL);\n        } else {\n            strcpy(mdi->tmp_info->copyright, mdi->extra_info.copyright);\n        }\n    } else {\n        mdi->tmp_info->copyright = NULL;\n    }\n    _WM_Unlock(&mdi->lock);\n    return ((struct _WM_Info *)mdi->tmp_info);\n}\n\nWM_SYMBOL int WildMidi_Shutdown(void) {\n    if (!WM_Initialized) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_INIT, NULL, 0);\n        return (-1);\n    }\n    while (first_handle) {\n        /* closes open handle and rotates the handles list. */\n        WildMidi_Close((struct _mdi *) first_handle->handle);\n    }\n    WM_FreePatches();\n    free_gauss();\n\n    /* reset the globals */\n    _cvt_reset_options ();\n    _WM_MasterVolume = 948;\n    _WM_MixerOptions = 0;\n    _WM_fix_release = 0;\n    _WM_auto_amp = 0;\n    _WM_auto_amp_with_amp = 0;\n    _WM_reverb_room_width = 16.875f;\n    _WM_reverb_room_length = 22.5f;\n    _WM_reverb_listen_posx = 8.4375f;\n    _WM_reverb_listen_posy = 16.875f;\n\n    WM_Initialized = 0;\n\n    if (_WM_Global_ErrorS != NULL) free(_WM_Global_ErrorS);\n\n    return (0);\n}\n\n/*\n    char * WildMidi_GetLyric(midi * handle)\n\n    Returns points to a \\0 terminated string that contains the\n    data contained in the last read lyric or text meta event.\n    Or returns NULL if no lyric is waiting to be read.\n\n    Force read from text meta event by including WM_MO_TEXTASLYRIC\n    in the options in WildMidi_Init.\n\n    Programs calling this only need to read the pointer.\n    Cleanup is done by the lib.\n\n    Once WildMidi_GetLyric is called it will return NULL\n    on subsiquent calls until the next lyric event is processed\n    during a WildMidi_GetOutput call.\n */\nWM_SYMBOL char * WildMidi_GetLyric (midi * handle) {\n    struct _mdi *mdi = (struct _mdi *) handle;\n    char * lyric = NULL;\n\n    if (!WM_Initialized) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_INIT, NULL, 0);\n        return (NULL);\n    }\n    if (handle == NULL) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(NULL handle)\", 0);\n        return (NULL);\n    }\n    _WM_Lock(&mdi->lock);\n    lyric = mdi->lyric;\n    mdi->lyric = NULL;\n    _WM_Unlock(&mdi->lock);\n    return (lyric);\n}\n\n/*\n * Return Last Error Message\n */\nWM_SYMBOL char * WildMidi_GetError (void) {\n    return (_WM_Global_ErrorS);\n}\n\n/*\n * Clear any error message\n */\nWM_SYMBOL void WildMidi_ClearError (void) {\n    _WM_Global_ErrorI = 0;\n    if (_WM_Global_ErrorS != NULL) {\n        free(_WM_Global_ErrorS);\n        _WM_Global_ErrorS = NULL;\n    }\n    return;\n}\n\n"], "fixing_code": ["WildMIDI is a simple software midi player which has a core softsynth\nlibrary that can be use with other applications.\n\nThe WildMIDI library uses Gravis Ultrasound patch files to convert MIDI\nfiles into audio which is then passed back to the calling application.\nThe library API is designed so that it is easy to include WildMIDI into\napplications that wish to include MIDI file playback.\n\nVersion: 0.4.2\nLicenses: GPLv3+ and LGPLv3\nWebsite: http://www.mindwerks.net/projects/wildmidi\n\nPLATFORMS:\n\n* Linux: Arch, Debian, Fedora, Ubuntu (player: ALSA, OSS, OpenAL output)\n* Windows: x86 and x64\n* OSX: x86, x64 and powerpc (in Xterm. player: OpenAL output)\n* BSD: Debian, FreeBSD, NetBSD, OpenBSD. (player: OSS output)\n* kFreeBSD: Debian (player: OSS output)\n* Hurd: Debian\n* DOS (player: sound blaster or compatibles output.)\n* OS/2 (player: Dart output.)\n* AmigaOS & variants like MorphOS, AROS. (player: AHI output)\n\nBUILD FROM SOURCE:\n\nRequirements:\n* git\n* cmake\n* GCC or clang / Xcode / VisualStudio / MinGW or MinGW-w64\n* DOS port: DJGPP / GNU make\n* OS/2 port: OpenWatcom (tested with version 1.9)\n* Nintendo 3DS port: devkitARM\n* Nintendo Wii port: devkitPPC\n\nCHANGELOG\n\n0.4.2\n* Fixed CVE-2017-11661, CVE-2017-11662, CVE-2017-11663, CVE-2017-11664\n  (Bug #175).\n* Fixed WildMidi_Open() might read beyond buffer with too short inputs\n  (Bug #178).\n* GUS patch processing changes to meet users expectations (Bug #132).\n* Worked around a build failure with newer FreeBSD versions failing to\n  retrieve the ONLCR constant (Bug #171).\n* Fixed a minor Windows unicode issue (PR #170).\n* A few other fixes / clean-ups.\n\n0.4.1\n* Fixed bug in handling of the \"source\" directive in config files.\n* Fixed a nasty bug in dBm_pan_volume. Other fixes and clean-ups.\n* Build system updates. Install a pkg-config file on supported platforms\n  such as Linux. New android ndk makefile.\n* File i/o updates.\n* Support for OS/2.\n* Support for Nintendo 3DS\n* Support for Nintendo Wii\n* Support for AmigaOS and its variants like MorphOS and AROS.\n\n0.4.0\n* API change: The library now returns audio data in host-endian format,\n  not little-endian.\n* API change: WildMidi_GetVersion() added to the api, along with new\n  numeric version macros in the wildmidi_lib.h header. the dso version\n  is changed from 1 to 2.\n* API change: All long or unsigned long type _WM_Info fields changed\n  into strictly 32bit fields (int32_t or uint32_t.)\n* API change: WildMidi_OpenBuffer() and WildMidi_GetOutput() changed\n  to accept strictly 32bit size parameters, i.e. uint32_t, instead of\n  unsigned long.\n* API change: WildMidi_ConvertToMidi() and WildMidi_ConvertBufferToMidi() \n  added for MIDI-like files to be converted to MIDI.\n* API change: WildMidi_SetCvtOption() added to support conversion options.\n* API change: WildMidi_SongSeek() added to support Type 2 MIDI files.\n* API change: WildMidi_GetLyric() added to support embedded text, \n  such as KAR files.\n* API change: WildMidi_GetError() and WildMidi_ClearError() added to\n  cleanly check for, retrieve and clear error messages. They no longer\n  go to stderr.\n* Support for loading XMI (XMIDI format) and XFM files, such as from Arena.\n  Thanks Ryan Nunn for releasing his code under the LGPL.\n* Support for loading MUS (MUS Id format) files, such as from Doom.\n* Support for loading HMP/HMI files, such as from Daggerfall.\n* Support for loading KAR (MIDI with Lyrics) and Type 2 MIDI files.\n* Build requires cmake-2.8.11 or newer now.\n\n0.3.9\n* Library: Fixed a segmentation fault with bad midi files.\n\n0.3.8\n* Library: Fixed a seek-to-0 bug in order to cure an issue of truncated\n  start (bug #100, gnome/gstreamer bug #694811.)\n* Player, OpenAL: reduced buffers from 8 to 4 so as to cure some output\n  delay issues (bug #85.)\n\n0.3.7\n* Plug a memory leak in case of broken midis.\n* Properly reset global state upon library shutdown.\n* Support for type-2 midi files.\n* Fix a possible crash in WildMidi_SetOption.\n* DOS port: Support for Sound Blaster output in player.\n* Uglify the library's private global variable and function names.\n* Build: Add option for a statically linked player.\n* Build: Add headers to project files. Use -fno-common flag.\n* Other small fixes/clean-ups.\n\n0.3.6\n* Fix some portability issues.\n* Fix a double-free issue during library shutdown when several midis\n  were alive.\n* Fix the invalid option checking in WildMidi_Init().\n* Fix the roundtempo option which had been broken since its invention\n  in 0.2.3.5 (WM_MO_ROUNDTEMPO: was 0xA000 instead of 0x2000.)\n* Fix cfg files without a newline at the end weren't parsed correctly.\n* Handle cfg files with mac line-endings.\n* Refuse loading suspiciously long files.\n\n0.3.5\n* Greatly reduced the heap usage (was a regression introduced in 0.2.3)\n* OpenAL support: Fixed audio output on big-endian systems. Fixed audio\n  skips at song start.\n* OSS support: No longer uses mmap mode for better compatibility. This\n  gains us NetBSD and OpenBSD support.\n* Worked around an invalid memory read found by valgrind when playing\n  Beethoven's Fur Elise.rmi at 44100 Hz using the old MIDIA patch-set\n  from 1994.\n* Build fixes for MSVC. Revised visibility attributes usage.\n\n0.3.4\n* OpenAL support: This gains us OSX and other platforms that OpenAL\n  supports for sound output!\n* DOS (DJGPP) support: This goes a long way to helping other DOS\n  based applications.\n* MinGW support: This gains us win32 and win64 support using this\n  toolchain.\n* OSS fixes.\n* Add missing parts of the absolute paths fix in config parsing.\n* New portable file and path-name system to handle cross-platform\n  support.\n* Support for Debian/kFreeBSD, Debian/Hurd and other Debian archs.\n* Many bug fixes, code clean-ups and cosmetic fixes.\n\n0.3.3\n* default to hidden visibility and only export our API functions\n* windows lean and mean to help compile times on Windows\n* cli and xcode work now on OSX\n* better FreeBSD support\n* Supported platforms are Debian, FreeBSD, Windows and OSX (but only\n  for WAV output)\n\n0.3.1 - 0.3.2\n* Cmake updates/fixes/cleanups.\n\n0.3.0\n* initial CMake support.\n* process non-registered params. fix issue of notes ending before\n  attack envelope completed. (sf.net svn r149/r151.)\n", "/*\n * wildmidi_lib.c -- Midi Wavetable Processing library\n *\n * Copyright (C) WildMIDI Developers 2001-2016\n *\n * This file is part of WildMIDI.\n *\n * WildMIDI is free software: you can redistribute and/or modify the player\n * under the terms of the GNU General Public License and you can redistribute\n * and/or modify the library under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation, either version 3 of\n * the licenses, or(at your option) any later version.\n *\n * WildMIDI is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License and\n * the GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License and the\n * GNU Lesser General Public License along with WildMIDI.  If not,  see\n * <http://www.gnu.org/licenses/>.\n */\n\n#define _WILDMIDI_LIB_C\n\n#include \"config.h\"\n\n#include <stdint.h>\n#include <errno.h>\n#include <math.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"wm_error.h\"\n#include \"file_io.h\"\n#include \"lock.h\"\n#include \"reverb.h\"\n#include \"gus_pat.h\"\n#include \"common.h\"\n#include \"wildmidi_lib.h\"\n#include \"filenames.h\"\n#include \"internal_midi.h\"\n#include \"f_hmi.h\"\n#include \"f_hmp.h\"\n#include \"f_midi.h\"\n#include \"f_mus.h\"\n#include \"f_xmidi.h\"\n#include \"patches.h\"\n#include \"sample.h\"\n#include \"mus2mid.h\"\n#include \"xmi2mid.h\"\n\n/*\n * =========================\n * Global Data and Data Structs\n * =========================\n */\n\nstatic int WM_Initialized = 0;\nuint16_t _WM_MixerOptions = 0;\n\nuint16_t _WM_SampleRate;\nint16_t _WM_MasterVolume;\n\n/* when converting files to midi */\ntypedef struct _cvt_options {\n    int lock;\n    uint16_t xmi_convert_type;\n    uint16_t frequency;\n} _cvt_options;\n\nstatic _cvt_options WM_ConvertOptions = {0, 0, 0};\n\n\nfloat _WM_reverb_room_width = 16.875f;\nfloat _WM_reverb_room_length = 22.5f;\n\nfloat _WM_reverb_listen_posx = 8.4375f;\nfloat _WM_reverb_listen_posy = 16.875f;\n\nint _WM_fix_release = 0;\nint _WM_auto_amp = 0;\nint _WM_auto_amp_with_amp = 0;\n\nstruct _miditrack {\n    uint32_t length;\n    uint32_t ptr;\n    uint32_t delta;\n    uint8_t running_event;\n    uint8_t EOT;\n};\n\nstruct _mdi_patches {\n    struct _patch *patch;\n    struct _mdi_patch *next;\n};\n\n#define FPBITS 10\n#define FPMASK ((1L<<FPBITS)-1L)\n\n\n/* Gauss Interpolation code adapted from code supplied by Eric. A. Welsh */\nstatic double newt_coeffs[58][58];  /* for start/end of samples */\n#define MAX_GAUSS_ORDER 34          /* 34 is as high as we can go before errors crop up */\nstatic double *gauss_table = NULL;  /* *gauss_table[1<<FPBITS] */\nstatic int gauss_n = MAX_GAUSS_ORDER;\nstatic int gauss_lock;\n\nstatic void init_gauss(void) {\n    /* init gauss table */\n    int n = gauss_n;\n    int m, i, k, n_half = (n >> 1);\n    int j;\n    int sign;\n    double ck;\n    double x, x_inc, xz;\n    double z[35];\n    double *gptr, *t;\n\n    _WM_Lock(&gauss_lock);\n    if (gauss_table) {\n        _WM_Unlock(&gauss_lock);\n        return;\n    }\n\n    newt_coeffs[0][0] = 1;\n    for (i = 0; i <= n; i++) {\n        newt_coeffs[i][0] = 1;\n        newt_coeffs[i][i] = 1;\n\n        if (i > 1) {\n            newt_coeffs[i][0] = newt_coeffs[i - 1][0] / i;\n            newt_coeffs[i][i] = newt_coeffs[i - 1][0] / i;\n        }\n\n        for (j = 1; j < i; j++) {\n            newt_coeffs[i][j] = newt_coeffs[i - 1][j - 1]\n                    + newt_coeffs[i - 1][j];\n            if (i > 1)\n                newt_coeffs[i][j] /= i;\n        }\n        z[i] = i / (4 * M_PI);\n    }\n\n    for (i = 0; i <= n; i++)\n        for (j = 0, sign = (int) pow(-1, i); j <= i; j++, sign *= -1)\n            newt_coeffs[i][j] *= sign;\n\n    t = malloc((1<<FPBITS) * (n + 1) * sizeof(double));\n    x_inc = 1.0 / (1<<FPBITS);\n    for (m = 0, x = 0.0; m < (1<<FPBITS); m++, x += x_inc) {\n        xz = (x + n_half) / (4 * M_PI);\n        gptr = &t[m * (n + 1)];\n\n        for (k = 0; k <= n; k++) {\n            ck = 1.0;\n\n            for (i = 0; i <= n; i++) {\n                if (i == k)\n                    continue;\n\n                ck *= (sin(xz - z[i])) / (sin(z[k] - z[i]));\n            }\n            *gptr++ = ck;\n        }\n    }\n\n    gauss_table = t;\n    _WM_Unlock(&gauss_lock);\n}\n\nstatic void free_gauss(void) {\n    _WM_Lock(&gauss_lock);\n    free(gauss_table);\n    gauss_table = NULL;\n    _WM_Unlock(&gauss_lock);\n}\n\nstruct _hndl {\n    void * handle;\n    struct _hndl *next;\n    struct _hndl *prev;\n};\n\nstatic struct _hndl * first_handle = NULL;\n\n#define MAX_AUTO_AMP 2.0\n\n/*\n * =========================\n * Internal Functions\n * =========================\n */\n\nvoid _cvt_reset_options (void) {\n    _WM_Lock(&WM_ConvertOptions.lock);\n    WM_ConvertOptions.xmi_convert_type = 0;\n    WM_ConvertOptions.frequency = 0;\n    _WM_Unlock(&WM_ConvertOptions.lock);\n}\n\nuint16_t _cvt_get_option (uint16_t tag) {\n    uint16_t r = 0;\n    _WM_Lock(&WM_ConvertOptions.lock);\n    switch (tag) {\n    case WM_CO_XMI_TYPE: r = WM_ConvertOptions.xmi_convert_type; break;\n    case WM_CO_FREQUENCY: r = WM_ConvertOptions.frequency; break;\n    }\n    _WM_Unlock(&WM_ConvertOptions.lock);\n    return r;\n}\n\nstatic void WM_InitPatches(void) {\n    int i;\n    for (i = 0; i < 128; i++) {\n        _WM_patch[i] = NULL;\n    }\n}\n\nstatic void WM_FreePatches(void) {\n    int i;\n    struct _patch * tmp_patch;\n    struct _sample * tmp_sample;\n\n    _WM_Lock(&_WM_patch_lock);\n    for (i = 0; i < 128; i++) {\n        while (_WM_patch[i]) {\n            while (_WM_patch[i]->first_sample) {\n                tmp_sample = _WM_patch[i]->first_sample->next;\n                free(_WM_patch[i]->first_sample->data);\n                free(_WM_patch[i]->first_sample);\n                _WM_patch[i]->first_sample = tmp_sample;\n            }\n            free(_WM_patch[i]->filename);\n            tmp_patch = _WM_patch[i]->next;\n            free(_WM_patch[i]);\n            _WM_patch[i] = tmp_patch;\n        }\n    }\n    _WM_Unlock(&_WM_patch_lock);\n}\n\n/* wm_strdup -- adds extra space for appending up to 4 chars */\nstatic char *wm_strdup (const char *str) {\n    size_t l = strlen(str) + 5;\n    char *d = (char *) malloc(l * sizeof(char));\n    if (d) {\n        strcpy(d, str);\n        return (d);\n    }\n    return (NULL);\n}\n\nstatic inline int wm_isdigit(int c) {\n    return (c >= '0' && c <= '9');\n}\nstatic inline int wm_isupper(int c) {\n    return (c >= 'A' && c <= 'Z');\n}\nstatic inline int wm_tolower(int c) {\n    return ((wm_isupper(c)) ? (c | ('a' - 'A')) : c);\n}\n#if 0 /* clang whines that these aren't used. */\nstatic inline int wm_islower(int c) {\n    return (c >= 'a' && c <= 'z');\n}\nstatic inline int wm_toupper(int c) {\n    return ((wm_islower(c)) ? (c & ~('a' - 'A')) : c);\n}\n#endif\n\nstatic int wm_strcasecmp(const char *s1, const char * s2) {\n    const char * p1 = s1;\n    const char * p2 = s2;\n    char c1, c2;\n\n    if (p1 == p2) return 0;\n    do {\n        c1 = wm_tolower (*p1++);\n        c2 = wm_tolower (*p2++);\n        if (c1 == '\\0') break;\n    } while (c1 == c2);\n    return (int)(c1 - c2);\n}\n\nstatic int wm_strncasecmp(const char *s1, const char *s2, size_t n) {\n    const char * p1 = s1;\n    const char * p2 = s2;\n    char c1, c2;\n\n    if (p1 == p2 || n == 0) return 0;\n    do {\n        c1 = wm_tolower (*p1++);\n        c2 = wm_tolower (*p2++);\n        if (c1 == '\\0' || c1 != c2) break;\n    } while (--n > 0);\n    return (int)(c1 - c2);\n}\n\n#define TOKEN_CNT_INC 8\nstatic char** WM_LC_Tokenize_Line(char *line_data) {\n    int line_length = (int) strlen(line_data);\n    int token_data_length = 0;\n    int line_ofs = 0;\n    int token_start = 0;\n    char **token_data = NULL;\n    int token_count = 0;\n\n    if (!line_length) return (NULL);\n\n    do {\n        /* ignore everything after #  */\n        if (line_data[line_ofs] == '#') {\n            break;\n        }\n\n        if ((line_data[line_ofs] == ' ') || (line_data[line_ofs] == '\\t')) {\n            /* whitespace means we aren't in a token */\n            if (token_start) {\n                token_start = 0;\n                line_data[line_ofs] = '\\0';\n            }\n        } else {\n            if (!token_start) {\n                /* the start of a token in the line */\n                token_start = 1;\n                if (token_count >= token_data_length) {\n                    token_data_length += TOKEN_CNT_INC;\n                    token_data = realloc(token_data, token_data_length * sizeof(char *));\n                    if (token_data == NULL) {\n                        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_MEM,\"to parse config\", errno);\n                        return (NULL);\n                    }\n                }\n\n                token_data[token_count] = &line_data[line_ofs];\n                token_count++;\n            }\n        }\n        line_ofs++;\n    } while (line_ofs != line_length);\n\n    /* if we have found some tokens then add a null token to the end */\n    if (token_count) {\n        if (token_count >= token_data_length) {\n            token_data = realloc(token_data,\n                ((token_count + 1) * sizeof(char *)));\n        }\n        token_data[token_count] = NULL;\n    }\n\n    return (token_data);\n}\n\nstatic int load_config(const char *config_file, const char *conf_dir) {\n    uint32_t config_size = 0;\n    char *config_buffer = NULL;\n    const char *dir_end = NULL;\n    char *config_dir = NULL;\n    uint32_t config_ptr = 0;\n    uint32_t line_start_ptr = 0;\n    uint16_t patchid = 0;\n    struct _patch * tmp_patch;\n    char **line_tokens = NULL;\n    int token_count = 0;\n\n    config_buffer = (char *) _WM_BufferFile(config_file, &config_size);\n    if (!config_buffer) {\n        WM_FreePatches();\n        return (-1);\n    }\n\n    if (conf_dir) {\n        if (!(config_dir = wm_strdup(conf_dir))) {\n            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_MEM, config_file, errno);\n            WM_FreePatches();\n            free(config_buffer);\n            return (-1);\n        }\n    } else {\n        dir_end = FIND_LAST_DIRSEP(config_file);\n        if (dir_end) {\n            config_dir = malloc((dir_end - config_file + 2));\n            if (config_dir == NULL) {\n                _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_MEM, config_file, errno);\n                WM_FreePatches();\n                free(config_buffer);\n                return (-1);\n            }\n            strncpy(config_dir, config_file, (dir_end - config_file + 1));\n            config_dir[dir_end - config_file + 1] = '\\0';\n        }\n    }\n\n    config_ptr = 0;\n    line_start_ptr = 0;\n\n    /* handle files without a newline at the end: this relies on\n     * _WM_BufferFile() allocating the buffer with one extra byte */\n    config_buffer[config_size] = '\\n';\n\n    while (config_ptr <= config_size) {\n        if (config_buffer[config_ptr] == '\\r' ||\n            config_buffer[config_ptr] == '\\n')\n        {\n            config_buffer[config_ptr] = '\\0';\n\n            if (config_ptr != line_start_ptr) {\n                _WM_Global_ErrorI = 0; /* because WM_LC_Tokenize_Line() can legitimately return NULL */\n                line_tokens = WM_LC_Tokenize_Line(&config_buffer[line_start_ptr]);\n                if (line_tokens) {\n                    if (wm_strcasecmp(line_tokens[0], \"dir\") == 0) {\n                        free(config_dir);\n                        if (!line_tokens[1]) {\n                            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(missing name in dir line)\", 0);\n                            WM_FreePatches();\n                            free(line_tokens);\n                            free(config_buffer);\n                            return (-1);\n                        } else if (!(config_dir = wm_strdup(line_tokens[1]))) {\n                            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_MEM, config_file, errno);\n                            WM_FreePatches();\n                            free(line_tokens);\n                            free(config_buffer);\n                            return (-1);\n                        }\n                        if (!IS_DIR_SEPARATOR(config_dir[strlen(config_dir) - 1])) {\n                            config_dir[strlen(config_dir) + 1] = '\\0';\n                            config_dir[strlen(config_dir)] = DIR_SEPARATOR_CHAR;\n                        }\n                    } else if (wm_strcasecmp(line_tokens[0], \"source\") == 0) {\n                        char *new_config = NULL;\n                        if (!line_tokens[1]) {\n                            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(missing name in source line)\", 0);\n                            WM_FreePatches();\n                            free(line_tokens);\n                            free(config_buffer);\n                            return (-1);\n                        } else if (!IS_ABSOLUTE_PATH(line_tokens[1]) && config_dir) {\n                            new_config = malloc(strlen(config_dir) + strlen(line_tokens[1]) + 1);\n                            if (new_config == NULL) {\n                                _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_MEM, config_file, errno);\n                                WM_FreePatches();\n                                free(config_dir);\n                                free(line_tokens);\n                                free(config_buffer);\n                                return (-1);\n                            }\n                            strcpy(new_config, config_dir);\n                            strcpy(&new_config[strlen(config_dir)], line_tokens[1]);\n                        } else {\n                            if (!(new_config = wm_strdup(line_tokens[1]))) {\n                                _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_MEM, config_file, errno);\n                                WM_FreePatches();\n                                free(line_tokens);\n                                free(config_buffer);\n                                return (-1);\n                            }\n                        }\n                        if (load_config(new_config, config_dir) == -1) {\n                            free(new_config);\n                            free(line_tokens);\n                            free(config_buffer);\n                            free(config_dir);\n                            return (-1);\n                        }\n                        free(new_config);\n                    } else if (wm_strcasecmp(line_tokens[0], \"bank\") == 0) {\n                        if (!line_tokens[1] || !wm_isdigit(line_tokens[1][0])) {\n                            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(syntax error in bank line)\", 0);\n                            WM_FreePatches();\n                            free(config_dir);\n                            free(line_tokens);\n                            free(config_buffer);\n                            return (-1);\n                        }\n                        patchid = (atoi(line_tokens[1]) & 0xFF) << 8;\n                    } else if (wm_strcasecmp(line_tokens[0], \"drumset\") == 0) {\n                        if (!line_tokens[1] || !wm_isdigit(line_tokens[1][0])) {\n                            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(syntax error in drumset line)\", 0);\n                            WM_FreePatches();\n                            free(config_dir);\n                            free(line_tokens);\n                            free(config_buffer);\n                            return (-1);\n                        }\n                        patchid = ((atoi(line_tokens[1]) & 0xFF) << 8) | 0x80;\n                    } else if (wm_strcasecmp(line_tokens[0], \"reverb_room_width\") == 0) {\n                        if (!line_tokens[1] || !wm_isdigit(line_tokens[1][0])) {\n                            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(syntax error in reverb_room_width line)\", 0);\n                            WM_FreePatches();\n                            free(config_dir);\n                            free(line_tokens);\n                            free(config_buffer);\n                            return (-1);\n                        }\n                        _WM_reverb_room_width = (float) atof(line_tokens[1]);\n                        if (_WM_reverb_room_width < 1.0f) {\n                            _WM_DEBUG_MSG(\"%s: reverb_room_width < 1 meter, setting to minimum of 1 meter\", config_file);\n                            _WM_reverb_room_width = 1.0f;\n                        } else if (_WM_reverb_room_width > 100.0f) {\n                            _WM_DEBUG_MSG(\"%s: reverb_room_width > 100 meters, setting to maximum of 100 meters\", config_file);\n                            _WM_reverb_room_width = 100.0f;\n                        }\n                    } else if (wm_strcasecmp(line_tokens[0], \"reverb_room_length\") == 0) {\n                        if (!line_tokens[1] || !wm_isdigit(line_tokens[1][0])) {\n                            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(syntax error in reverb_room_length line)\", 0);\n                            WM_FreePatches();\n                            free(config_dir);\n                            free(line_tokens);\n                            free(config_buffer);\n                            return (-1);\n                        }\n                        _WM_reverb_room_length = (float) atof(line_tokens[1]);\n                        if (_WM_reverb_room_length < 1.0f) {\n                            _WM_DEBUG_MSG(\"%s: reverb_room_length < 1 meter, setting to minimum of 1 meter\", config_file);\n                            _WM_reverb_room_length = 1.0f;\n                        } else if (_WM_reverb_room_length > 100.0f) {\n                            _WM_DEBUG_MSG(\"%s: reverb_room_length > 100 meters, setting to maximum of 100 meters\", config_file);\n                            _WM_reverb_room_length = 100.0f;\n                        }\n                    } else if (wm_strcasecmp(line_tokens[0], \"reverb_listener_posx\") == 0) {\n                        if (!line_tokens[1] || !wm_isdigit(line_tokens[1][0])) {\n                            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(syntax error in reverb_listen_posx line)\", 0);\n                            WM_FreePatches();\n                            free(config_dir);\n                            free(line_tokens);\n                            free(config_buffer);\n                            return (-1);\n                        }\n                        _WM_reverb_listen_posx = (float) atof(line_tokens[1]);\n                        if ((_WM_reverb_listen_posx > _WM_reverb_room_width)\n                                || (_WM_reverb_listen_posx < 0.0f)) {\n                            _WM_DEBUG_MSG(\"%s: reverb_listen_posx set outside of room\", config_file);\n                            _WM_reverb_listen_posx = _WM_reverb_room_width / 2.0f;\n                        }\n                    } else if (wm_strcasecmp(line_tokens[0],\n                            \"reverb_listener_posy\") == 0) {\n                        if (!line_tokens[1] || !wm_isdigit(line_tokens[1][0])) {\n                            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(syntax error in reverb_listen_posy line)\", 0);\n                            WM_FreePatches();\n                            free(config_dir);\n                            free(line_tokens);\n                            free(config_buffer);\n                            return (-1);\n                        }\n                        _WM_reverb_listen_posy = (float) atof(line_tokens[1]);\n                        if ((_WM_reverb_listen_posy > _WM_reverb_room_width)\n                                || (_WM_reverb_listen_posy < 0.0f)) {\n                            _WM_DEBUG_MSG(\"%s: reverb_listen_posy set outside of room\", config_file);\n                            _WM_reverb_listen_posy = _WM_reverb_room_length * 0.75f;\n                        }\n                    } else if (wm_strcasecmp(line_tokens[0], \"guspat_editor_author_cant_read_so_fix_release_time_for_me\") == 0) {\n                        _WM_fix_release = 1;\n                    } else if (wm_strcasecmp(line_tokens[0], \"auto_amp\") == 0) {\n                        _WM_auto_amp = 1;\n                    } else if (wm_strcasecmp(line_tokens[0], \"auto_amp_with_amp\") == 0) {\n                        _WM_auto_amp = 1;\n                        _WM_auto_amp_with_amp = 1;\n                    } else if (wm_isdigit(line_tokens[0][0])) {\n                        patchid = (patchid & 0xFF80)\n                                | (atoi(line_tokens[0]) & 0x7F);\n                        if (_WM_patch[(patchid & 0x7F)] == NULL) {\n                            _WM_patch[(patchid & 0x7F)] = malloc(sizeof(struct _patch));\n                            if (_WM_patch[(patchid & 0x7F)] == NULL) {\n                                _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_MEM, config_file, errno);\n                                WM_FreePatches();\n                                free(config_dir);\n                                free(line_tokens);\n                                free(config_buffer);\n                                return (-1);\n                            }\n                            tmp_patch = _WM_patch[(patchid & 0x7F)];\n                            tmp_patch->patchid = patchid;\n                            tmp_patch->filename = NULL;\n                            tmp_patch->amp = 1024;\n                            tmp_patch->note = 0;\n                            tmp_patch->next = NULL;\n                            tmp_patch->first_sample = NULL;\n                            tmp_patch->loaded = 0;\n                            tmp_patch->inuse_count = 0;\n                        } else {\n                            tmp_patch = _WM_patch[(patchid & 0x7F)];\n                            if (tmp_patch->patchid == patchid) {\n                                free(tmp_patch->filename);\n                                tmp_patch->filename = NULL;\n                                tmp_patch->amp = 1024;\n                                tmp_patch->note = 0;\n                            } else {\n                                if (tmp_patch->next) {\n                                    while (tmp_patch->next) {\n                                        if (tmp_patch->next->patchid == patchid)\n                                            break;\n                                        tmp_patch = tmp_patch->next;\n                                    }\n                                    if (tmp_patch->next == NULL) {\n                                        if ((tmp_patch->next = malloc(sizeof(struct _patch))) == NULL) {\n                                            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_MEM, config_file, 0);\n                                            WM_FreePatches();\n                                            free(config_dir);\n                                            free(line_tokens);\n                                            free(config_buffer);\n                                            return (-1);\n                                        }\n                                        tmp_patch = tmp_patch->next;\n                                        tmp_patch->patchid = patchid;\n                                        tmp_patch->filename = NULL;\n                                        tmp_patch->amp = 1024;\n                                        tmp_patch->note = 0;\n                                        tmp_patch->next = NULL;\n                                        tmp_patch->first_sample = NULL;\n                                        tmp_patch->loaded = 0;\n                                        tmp_patch->inuse_count = 0;\n                                    } else {\n                                        tmp_patch = tmp_patch->next;\n                                        free(tmp_patch->filename);\n                                        tmp_patch->filename = NULL;\n                                        tmp_patch->amp = 1024;\n                                        tmp_patch->note = 0;\n                                    }\n                                } else {\n                                    tmp_patch->next = malloc(\n                                            sizeof(struct _patch));\n                                    if (tmp_patch->next == NULL) {\n                                        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_MEM, config_file, errno);\n                                        WM_FreePatches();\n                                        free(config_dir);\n                                        free(line_tokens);\n                                        free(config_buffer);\n                                        return (-1);\n                                    }\n                                    tmp_patch = tmp_patch->next;\n                                    tmp_patch->patchid = patchid;\n                                    tmp_patch->filename = NULL;\n                                    tmp_patch->amp = 1024;\n                                    tmp_patch->note = 0;\n                                    tmp_patch->next = NULL;\n                                    tmp_patch->first_sample = NULL;\n                                    tmp_patch->loaded = 0;\n                                    tmp_patch->inuse_count = 0;\n                                }\n                            }\n                        }\n                        if (!line_tokens[1]) {\n                            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(missing name in patch line)\", 0);\n                            WM_FreePatches();\n                            free(config_dir);\n                            free(line_tokens);\n                            free(config_buffer);\n                            return (-1);\n                        } else if (!IS_ABSOLUTE_PATH(line_tokens[1]) && config_dir) {\n                            tmp_patch->filename = malloc(strlen(config_dir) + strlen(line_tokens[1]) + 5);\n                            if (tmp_patch->filename == NULL) {\n                                _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_MEM, config_file, 0);\n                                WM_FreePatches();\n                                free(config_dir);\n                                free(line_tokens);\n                                free(config_buffer);\n                                return (-1);\n                            }\n                            strcpy(tmp_patch->filename, config_dir);\n                            strcat(tmp_patch->filename, line_tokens[1]);\n                        } else {\n                            if (!(tmp_patch->filename = wm_strdup(line_tokens[1]))) {\n                                _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_MEM, config_file, 0);\n                                WM_FreePatches();\n                                free(config_dir);\n                                free(line_tokens);\n                                free(config_buffer);\n                                return (-1);\n                            }\n                        }\n                        if (wm_strncasecmp(&tmp_patch->filename[strlen(tmp_patch->filename) - 4], \".pat\", 4) != 0) {\n                            strcat(tmp_patch->filename, \".pat\");\n                        }\n                        tmp_patch->env[0].set = 0x00;\n                        tmp_patch->env[1].set = 0x00;\n                        tmp_patch->env[2].set = 0x00;\n                        tmp_patch->env[3].set = 0x00;\n                        tmp_patch->env[4].set = 0x00;\n                        tmp_patch->env[5].set = 0x00;\n                        tmp_patch->keep = 0;\n                        tmp_patch->remove = 0;\n\n                        token_count = 0;\n                        while (line_tokens[token_count]) {\n                            if (wm_strncasecmp(line_tokens[token_count], \"amp=\", 4) == 0) {\n                                if (!wm_isdigit(line_tokens[token_count][4])) {\n                                    _WM_DEBUG_MSG(\"%s: syntax error in patch line for %s\", config_file, \"amp=\");\n                                } else {\n                                    tmp_patch->amp = (atoi(&line_tokens[token_count][4]) << 10) / 100;\n                                }\n                            } else if (wm_strncasecmp(line_tokens[token_count], \"note=\", 5) == 0) {\n                                if (!wm_isdigit(line_tokens[token_count][5])) {\n                                    _WM_DEBUG_MSG(\"%s: syntax error in patch line for %s\", config_file, \"note=\");\n                                } else {\n                                    tmp_patch->note = atoi(&line_tokens[token_count][5]);\n                                }\n                            } else if (wm_strncasecmp(line_tokens[token_count], \"env_time\", 8) == 0) {\n                                if ((!wm_isdigit(line_tokens[token_count][8])) ||\n                                    (!wm_isdigit(line_tokens[token_count][10])) ||\n                                    (line_tokens[token_count][9] != '=')) {\n                                    _WM_DEBUG_MSG(\"%s: syntax error in patch line for %s\", config_file, \"env_time\");\n                                } else {\n                                    uint32_t env_no = atoi(&line_tokens[token_count][8]);\n                                    if (env_no > 5) {\n                                        _WM_DEBUG_MSG(\"%s: syntax error in patch line for %s\", config_file, \"env_time\");\n                                    } else {\n                                        tmp_patch->env[env_no].time = (float) atof(&line_tokens[token_count][10]);\n                                        if ((tmp_patch->env[env_no].time > 45000.0f) ||\n                                            (tmp_patch->env[env_no].time < 1.47f)) {\n                                            _WM_DEBUG_MSG(\"%s: range error in patch line %s\", config_file, \"env_time\");\n                                            tmp_patch->env[env_no].set &= 0xFE;\n                                        } else {\n                                            tmp_patch->env[env_no].set |= 0x01;\n                                        }\n                                    }\n                                }\n                            } else if (wm_strncasecmp(line_tokens[token_count], \"env_level\", 9) == 0) {\n                                if ((!wm_isdigit(line_tokens[token_count][9])) ||\n                                    (!wm_isdigit(line_tokens[token_count][11])) ||\n                                    (line_tokens[token_count][10] != '=')) {\n                                    _WM_DEBUG_MSG(\"%s: syntax error in patch line for %s\", config_file, \"env_level\");\n                                } else {\n                                    uint32_t env_no = atoi(&line_tokens[token_count][9]);\n                                    if (env_no > 5) {\n                                        _WM_DEBUG_MSG(\"%s: syntax error in patch line for %s\", config_file, \"env_level\");\n                                    } else {\n                                        tmp_patch->env[env_no].level = (float) atof(&line_tokens[token_count][11]);\n                                        if ((tmp_patch->env[env_no].level > 1.0f) ||\n                                            (tmp_patch->env[env_no].level < 0.0f)) {\n                                            _WM_DEBUG_MSG(\"%s: range error in patch line for %s\", config_file, \"env_level\");\n                                            tmp_patch->env[env_no].set &= 0xFD;\n                                        } else {\n                                            tmp_patch->env[env_no].set |= 0x02;\n                                        }\n                                    }\n                                }\n                            } else if (wm_strcasecmp(line_tokens[token_count], \"keep=loop\") == 0) {\n                                tmp_patch->keep |= SAMPLE_LOOP;\n                            } else if (wm_strcasecmp(line_tokens[token_count], \"keep=env\") == 0) {\n                                tmp_patch->keep |= SAMPLE_ENVELOPE;\n                            } else if (wm_strcasecmp(line_tokens[token_count], \"remove=sustain\") == 0) {\n                                tmp_patch->remove |= SAMPLE_SUSTAIN;\n                            } else if (wm_strcasecmp(line_tokens[token_count], \"remove=clamped\") == 0) {\n                                tmp_patch->remove |= SAMPLE_CLAMPED;\n                            }\n                            token_count++;\n                        }\n                    }\n                }\n                else if (_WM_Global_ErrorI) { /* malloc() failure in WM_LC_Tokenize_Line() */\n                    WM_FreePatches();\n                    free(line_tokens);\n                    free(config_buffer);\n                    return (-1);\n                }\n                /* free up tokens */\n                free(line_tokens);\n            }\n            line_start_ptr = config_ptr + 1;\n        }\n        config_ptr++;\n    }\n\n    free(config_buffer);\n    free(config_dir);\n\n    return (0);\n}\n\nstatic int WM_LoadConfig(const char *config_file) {\n    return load_config(config_file, NULL);\n}\n\nstatic int add_handle(void * handle) {\n    struct _hndl *tmp_handle = NULL;\n\n    if (first_handle == NULL) {\n        first_handle = malloc(sizeof(struct _hndl));\n        if (first_handle == NULL) {\n            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_MEM, \" to get ram\", errno);\n            return (-1);\n        }\n        first_handle->handle = handle;\n        first_handle->prev = NULL;\n        first_handle->next = NULL;\n    } else {\n        tmp_handle = first_handle;\n        if (tmp_handle->next) {\n            while (tmp_handle->next)\n                tmp_handle = tmp_handle->next;\n        }\n        tmp_handle->next = malloc(sizeof(struct _hndl));\n        if (tmp_handle->next == NULL) {\n            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_MEM, \" to get ram\", errno);\n            return (-1);\n        }\n        tmp_handle->next->prev = tmp_handle;\n        tmp_handle = tmp_handle->next;\n        tmp_handle->next = NULL;\n        tmp_handle->handle = handle;\n    }\n    return (0);\n}\n\n//#define DEBUG_RESAMPLE\n\n#ifdef DEBUG_RESAMPLE\n#define RESAMPLE_DEBUGI(dx,dy) fprintf(stderr,\"\\r%s, %i\\n\",dx,dy)\n#define RESAMPLE_DEBUGS(dx) fprintf(stderr,\"\\r%s\\n\",dx)\n\n#else\n#define RESAMPLE_DEBUGI(dx,dy)\n#define RESAMPLE_DEBUGS(dx)\n\n#endif\n\n\nstatic int WM_GetOutput_Linear(midi * handle, int8_t *buffer, uint32_t size) {\n    uint32_t buffer_used = 0;\n    uint32_t i;\n    struct _mdi *mdi = (struct _mdi *) handle;\n    uint32_t real_samples_to_mix = 0;\n    uint32_t data_pos;\n    int32_t premix, left_mix, right_mix;\n//  int32_t vol_mul;\n    struct _note *note_data = NULL;\n    uint32_t count;\n    struct _event *event = mdi->current_event;\n    int32_t *tmp_buffer;\n    int32_t *out_buffer;\n\n    _WM_Lock(&mdi->lock);\n\n    buffer_used = 0;\n    memset(buffer, 0, size);\n\n    if ( (size / 2) > mdi->mix_buffer_size) {\n        if ( (size / 2) <= ( mdi->mix_buffer_size * 2 )) {\n            mdi->mix_buffer_size += MEM_CHUNK;\n        } else {\n            mdi->mix_buffer_size = size / 2;\n        }\n        mdi->mix_buffer = realloc(mdi->mix_buffer, mdi->mix_buffer_size * sizeof(int32_t));\n    }\n\n    tmp_buffer = mdi->mix_buffer;\n\n    memset(tmp_buffer, 0, ((size / 2) * sizeof(int32_t)));\n    out_buffer = tmp_buffer;\n\n    do {\n        if (__builtin_expect((!mdi->samples_to_mix), 0)) {\n            while ((!mdi->samples_to_mix) && (event->do_event)) {\n                event->do_event(mdi, &event->event_data);\n                if ((mdi->extra_info.mixer_options & WM_MO_LOOP) && (event[0].do_event == *_WM_do_meta_endoftrack)) {\n                    _WM_ResetToStart(mdi);\n                    event = mdi->current_event;\n                } else {\n                    mdi->samples_to_mix = event->samples_to_next;\n                    event++;\n                    mdi->current_event = event;\n                }\n            }\n\n            if (__builtin_expect((!mdi->samples_to_mix), 0)) {\n                if (mdi->extra_info.current_sample >= mdi->extra_info.approx_total_samples) {\n                    break;\n                } else if ((mdi->extra_info.approx_total_samples\n                             - mdi->extra_info.current_sample) > (size >> 2)) {\n                    mdi->samples_to_mix = size >> 2;\n                } else {\n                    mdi->samples_to_mix = mdi->extra_info.approx_total_samples\n                                           - mdi->extra_info.current_sample;\n                }\n            }\n        }\n        if (__builtin_expect((mdi->samples_to_mix > (size >> 2)), 1)) {\n            real_samples_to_mix = size >> 2;\n        } else {\n            real_samples_to_mix = mdi->samples_to_mix;\n            if (real_samples_to_mix == 0) {\n                continue;\n            }\n        }\n\n        /* do mixing here */\n        count = real_samples_to_mix;\n\n        do {\n            note_data = mdi->note;\n            left_mix = right_mix = 0;\n            RESAMPLE_DEBUGI(\"SAMPLES_TO_MIX\",count);\n            if (__builtin_expect((note_data != NULL), 1)) {\n                RESAMPLE_DEBUGS(\"Processing Notes\");\n                while (note_data) {\n                    /*\n                     * ===================\n                     * resample the sample\n                     * ===================\n                     */\n                    data_pos = note_data->sample_pos >> FPBITS;\n                    premix = ((note_data->sample->data[data_pos] + (((note_data->sample->data[data_pos + 1] - note_data->sample->data[data_pos]) * (int32_t)(note_data->sample_pos & FPMASK)) / 1024)) * (note_data->env_level >> 12)) / 1024;\n\n                    left_mix += (premix * (int32_t)note_data->left_mix_volume) / 1024;\n                    right_mix += (premix * (int32_t)note_data->right_mix_volume) / 1024;\n\n                    /*\n                     * ========================\n                     * sample position checking\n                     * ========================\n                     */\n#ifdef DEBUG_RESAMPLE\n                    fprintf(stderr,\"\\r\\n%d -> INC %i, ENV %i, LEVEL %i, TARGET %d, RATE %i, SAMPLE POS %i, SAMPLE LENGTH %i, PREMIX %i (%i:%i)\",\n                            (uint32_t)note_data,\n                            note_data->env_inc,\n                            note_data->env, note_data->env_level,\n                            note_data->sample->env_target[note_data->env],\n                            note_data->sample->env_rate[note_data->env],\n                            note_data->sample_pos,\n                            note_data->sample->data_length,\n                            premix, left_mix, right_mix);\n                    if (note_data->modes & SAMPLE_LOOP)\n                        fprintf(stderr,\", LOOP %i + %i\",\n                                note_data->sample->loop_start,\n                                note_data->sample->loop_size);\n                    fprintf(stderr,\"\\r\\n\");\n#endif\n\n                    note_data->sample_pos += note_data->sample_inc;\n\n                    if (__builtin_expect((note_data->modes & SAMPLE_LOOP), 1)) {\n                        if (__builtin_expect(\n                                             (note_data->sample_pos > note_data->sample->loop_end),\n                                             0)) {\n                            note_data->sample_pos = note_data->sample->loop_start\n                                + ((note_data->sample_pos\n                                    - note_data->sample->loop_start)\n                                % note_data->sample->loop_size);\n                        }\n\n                    } else if (__builtin_expect(\n                                                  (note_data->sample_pos\n                                                   >= note_data->sample->data_length),\n                                                  0)) {\n                        goto _END_THIS_NOTE;\n                    }\n\n                    if (__builtin_expect((note_data->env_inc == 0), 0)) {\n                        note_data = note_data->next;\n                        RESAMPLE_DEBUGS(\"Next Note: 0 env_inc\");\n                        continue;\n                    }\n\n                    note_data->env_level += note_data->env_inc;\n\n                    if (note_data->env_inc < 0) {\n                        if (__builtin_expect((note_data->env_level\n                            > note_data->sample->env_target[note_data->env]), 0)) {\n                            note_data = note_data->next;\n                            RESAMPLE_DEBUGS(\"Next Note: env_lvl > env_target\");\n                            continue;\n                        }\n                    } else if (note_data->env_inc > 0) {\n                        if (__builtin_expect((note_data->env_level\n                            < note_data->sample->env_target[note_data->env]), 0)) {\n                            note_data = note_data->next;\n                            RESAMPLE_DEBUGS(\"Next Note: env_lvl < env_target\");\n                            continue;\n                        }\n                    }\n\n                    // Yes could have a condition here but\n                    // it would crete another bottleneck\n                    note_data->env_level =\n                            note_data->sample->env_target[note_data->env];\n                    switch (note_data->env) {\n                    case 0:\n                        if (!(note_data->modes & SAMPLE_ENVELOPE)) {\n                            note_data->env_inc = 0;\n                            note_data = note_data->next;\n                            RESAMPLE_DEBUGS(\"Next Note: No Envelope\");\n                            continue;\n                        }\n                        break;\n                    case 2:\n                        if (note_data->modes & SAMPLE_SUSTAIN /*|| note_data->hold*/) {\n                            note_data->env_inc = 0;\n                            note_data = note_data->next;\n                            RESAMPLE_DEBUGS(\"Next Note: SAMPLE_SUSTAIN\");\n                            continue;\n                        } else if (note_data->modes & SAMPLE_CLAMPED) {\n                            note_data->env = 5;\n                            if (note_data->env_level\n                                    > note_data->sample->env_target[5]) {\n                                note_data->env_inc =\n                                        -note_data->sample->env_rate[5];\n                            } else {\n                                note_data->env_inc =\n                                        note_data->sample->env_rate[5];\n                            }\n                            continue;\n                        }\n                        break;\n                    case 5:\n                        if (__builtin_expect((note_data->env_level == 0), 1)) {\n                            goto _END_THIS_NOTE;\n                        }\n                        /* sample release */\n                        if (note_data->modes & SAMPLE_LOOP)\n                            note_data->modes ^= SAMPLE_LOOP;\n                        note_data->env_inc = 0;\n                        note_data = note_data->next;\n                        RESAMPLE_DEBUGS(\"Next Note: Sample Release\");\n\n                        continue;\n                    case 6:\n                        _END_THIS_NOTE:\n                        if (__builtin_expect((note_data->replay != NULL), 1)) {\n                            note_data->active = 0;\n                            {\n                                struct _note *prev_note = NULL;\n                                struct _note *nte_array = mdi->note;\n\n                                if (nte_array != note_data) {\n                                    do {\n                                        prev_note = nte_array;\n                                        nte_array = nte_array->next;\n                                    } while (nte_array != note_data);\n                                }\n                                if (prev_note) {\n                                    prev_note->next = note_data->replay;\n                                } else {\n                                    mdi->note = note_data->replay;\n                                }\n                                note_data->replay->next = note_data->next;\n                                note_data = note_data->replay;\n                                note_data->active = 1;\n                            }\n                        } else {\n                            note_data->active = 0;\n                            {\n                                struct _note *prev_note = NULL;\n                                struct _note *nte_array = mdi->note;\n\n                                if (nte_array != note_data) {\n                                    do {\n                                        prev_note = nte_array;\n                                        nte_array = nte_array->next;\n                                    } while ((nte_array != note_data)\n                                            && (nte_array));\n                                }\n                                if (prev_note) {\n                                    prev_note->next = note_data->next;\n                                } else {\n                                    mdi->note = note_data->next;\n                                }\n                                note_data = note_data->next;\n                            }\n                        }\n                        RESAMPLE_DEBUGS(\"Next Note: Killed Off Note\");\n                        continue;\n                    }\n                    note_data->env++;\n\n                    if (note_data->is_off == 1) {\n                        _WM_do_note_off_extra(note_data);\n                    } else {\n\n                        if (note_data->env_level\n                            >= note_data->sample->env_target[note_data->env]) {\n                            note_data->env_inc =\n                                -note_data->sample->env_rate[note_data->env];\n                        } else {\n                            note_data->env_inc =\n                                note_data->sample->env_rate[note_data->env];\n                        }\n                    }\n                    note_data = note_data->next;\n#ifdef DEBUG_RESAMPLE\n                    if (note_data != NULL)\n                        RESAMPLE_DEBUGI(\"Next Note: Next ENV \", note_data->env);\n                    else\n                        RESAMPLE_DEBUGS(\"Next Note: Next ENV\");\n#endif\n                    continue;\n                }\n            }\n            *tmp_buffer++ = left_mix;\n            *tmp_buffer++ = right_mix;\n        } while (--count);\n\n        buffer_used += real_samples_to_mix * 4;\n        size -= (real_samples_to_mix << 2);\n        mdi->extra_info.current_sample += real_samples_to_mix;\n        mdi->samples_to_mix -= real_samples_to_mix;\n    } while (size);\n\n    tmp_buffer = out_buffer;\n\n    if (mdi->extra_info.mixer_options & WM_MO_REVERB) {\n        _WM_do_reverb(mdi->reverb, tmp_buffer, (buffer_used / 2));\n    }\n\n    //_WM_DynamicVolumeAdjust(mdi, tmp_buffer, (buffer_used/2));\n\n    for (i = 0; i < buffer_used; i += 4) {\n        left_mix = *tmp_buffer++;\n        right_mix = *tmp_buffer++;\n\n        /*\n         * ===================\n         * Write to the buffer\n         * ===================\n         */\n#ifdef WORDS_BIGENDIAN\n        (*buffer++) = ((left_mix >> 8) & 0x7f) | ((left_mix >> 24) & 0x80);\n        (*buffer++) = left_mix & 0xff;\n        (*buffer++) = ((right_mix >> 8) & 0x7f) | ((right_mix >> 24) & 0x80);\n        (*buffer++) = right_mix & 0xff;\n#else\n        (*buffer++) = left_mix & 0xff;\n        (*buffer++) = ((left_mix >> 8) & 0x7f) | ((left_mix >> 24) & 0x80);\n        (*buffer++) = right_mix & 0xff;\n        (*buffer++) = ((right_mix >> 8) & 0x7f) | ((right_mix >> 24) & 0x80);\n#endif\n    }\n\n    _WM_Unlock(&mdi->lock);\n    return (buffer_used);\n}\n\nstatic int WM_GetOutput_Gauss(midi * handle, int8_t *buffer, uint32_t size) {\n    uint32_t buffer_used = 0;\n    uint32_t i;\n    struct _mdi *mdi = (struct _mdi *) handle;\n    uint32_t real_samples_to_mix = 0;\n    uint32_t data_pos;\n    int32_t premix, left_mix, right_mix;\n    struct _note *note_data = NULL;\n    uint32_t count;\n    int16_t *sptr;\n    double y, xd;\n    double *gptr, *gend;\n    int left, right, temp_n;\n    int ii, jj;\n    struct _event *event = mdi->current_event;\n    int32_t *tmp_buffer;\n    int32_t *out_buffer;\n\n    _WM_Lock(&mdi->lock);\n\n    buffer_used = 0;\n    memset(buffer, 0, size);\n\n    if ( (size / 2) > mdi->mix_buffer_size) {\n        if ( (size / 2) <= ( mdi->mix_buffer_size * 2 )) {\n            mdi->mix_buffer_size += MEM_CHUNK;\n        } else {\n            mdi->mix_buffer_size = size / 2;\n        }\n        mdi->mix_buffer = realloc(mdi->mix_buffer, mdi->mix_buffer_size * sizeof(int32_t));\n    }\n\n    tmp_buffer = mdi->mix_buffer;\n\n    memset(tmp_buffer, 0, ((size / 2) * sizeof(int32_t)));\n    out_buffer = tmp_buffer;\n\n    do {\n        if (__builtin_expect((!mdi->samples_to_mix), 0)) {\n            while ((!mdi->samples_to_mix) && (event->do_event)) {\n                event->do_event(mdi, &event->event_data);\n                if ((mdi->extra_info.mixer_options & WM_MO_LOOP) && (event[0].do_event == *_WM_do_meta_endoftrack)) {\n                    _WM_ResetToStart(mdi);\n                    event = mdi->current_event;\n                } else {\n                    mdi->samples_to_mix = event->samples_to_next;\n                    event++;\n                    mdi->current_event = event;\n                }\n            }\n\n            if (!mdi->samples_to_mix) {\n                if (mdi->extra_info.current_sample\n                    >= mdi->extra_info.approx_total_samples) {\n                    break;\n                } else if ((mdi->extra_info.approx_total_samples\n                            - mdi->extra_info.current_sample) > (size >> 2)) {\n                    mdi->samples_to_mix = size >> 2;\n                } else {\n                    mdi->samples_to_mix = mdi->extra_info.approx_total_samples\n                    - mdi->extra_info.current_sample;\n                }\n            }\n        }\n        if (__builtin_expect((mdi->samples_to_mix > (size >> 2)), 1)) {\n            real_samples_to_mix = size >> 2;\n        } else {\n            real_samples_to_mix = mdi->samples_to_mix;\n            if (real_samples_to_mix == 0) {\n                continue;\n            }\n        }\n\n        /* do mixing here */\n        count = real_samples_to_mix;\n        do {\n            note_data = mdi->note;\n            left_mix = right_mix = 0;\n            if (__builtin_expect((note_data != NULL), 1)) {\n                while (note_data) {\n                    /*\n                     * ===================\n                     * resample the sample\n                     * ===================\n                     */\n                    data_pos = note_data->sample_pos >> FPBITS;\n\n                    /* check to see if we're near one of the ends */\n                    left = data_pos;\n                    right = (note_data->sample->data_length >> FPBITS) - left\n                            - 1;\n                    temp_n = (right << 1) - 1;\n                    if (temp_n <= 0)\n                        temp_n = 1;\n                    if (temp_n > (left << 1) + 1)\n                        temp_n = (left << 1) + 1;\n\n                    /* use Newton if we can't fill the window */\n                    if (temp_n < gauss_n) {\n                        xd = note_data->sample_pos & FPMASK;\n                        xd /= (1L << FPBITS);\n                        xd += temp_n >> 1;\n                        y = 0;\n                        sptr = note_data->sample->data\n                                + (note_data->sample_pos >> FPBITS)\n                                - (temp_n >> 1);\n                        for (ii = temp_n; ii;) {\n                            for (jj = 0; jj <= ii; jj++)\n                                y += sptr[jj] * newt_coeffs[ii][jj];\n                            y *= xd - --ii;\n                        }\n                        y += *sptr;\n                    } else { /* otherwise, use Gauss as usual */\n                        y = 0;\n                        gptr = &gauss_table[(note_data->sample_pos & FPMASK) *\n                                     (gauss_n + 1)];\n                        gend = gptr + gauss_n;\n                        sptr = note_data->sample->data\n                                + (note_data->sample_pos >> FPBITS)\n                                - (gauss_n >> 1);\n                        do {\n                            y += *(sptr++) * *(gptr++);\n                        } while (gptr <= gend);\n                    }\n\n                    premix = (int32_t)((y * (note_data->env_level >> 12)) / 1024);\n\n                    left_mix += (premix * (int32_t)note_data->left_mix_volume) / 1024;\n                    right_mix += (premix * (int32_t)note_data->right_mix_volume) / 1024;\n\n                    /*\n                     * ========================\n                     * sample position checking\n                     * ========================\n                     */\n                    note_data->sample_pos += note_data->sample_inc;\n                    if (__builtin_expect(\n                                         (note_data->sample_pos > note_data->sample->loop_end),\n                                         0)) {\n                        if (note_data->modes & SAMPLE_LOOP) {\n                            note_data->sample_pos =\n                            note_data->sample->loop_start\n                            + ((note_data->sample_pos\n                                - note_data->sample->loop_start)\n                               % note_data->sample->loop_size);\n                        } else if (__builtin_expect(\n                                                    (note_data->sample_pos\n                                                     >= note_data->sample->data_length),\n                                                    0)) {\n                            goto _END_THIS_NOTE;\n                        }\n                    }\n\n                    if (__builtin_expect((note_data->env_inc == 0), 0)) {\n                        /*\n                         fprintf(stderr,\"\\r\\nINC = 0, ENV %i, LEVEL %i, TARGET %d, RATE %i\\r\\n\",\n                                 note_data->env, note_data->env_level,\n                                 note_data->sample->env_target[note_data->env],\n                                 note_data->sample->env_rate[note_data->env]);\n                         */\n                        note_data = note_data->next;\n                        continue;\n                    }\n\n                    note_data->env_level += note_data->env_inc;\n                    /*\n                     fprintf(stderr,\"\\r\\nENV %i, LEVEL %i, TARGET %d, RATE %i, INC %i\\r\\n\",\n                             note_data->env, note_data->env_level,\n                             note_data->sample->env_target[note_data->env],\n                             note_data->sample->env_rate[note_data->env],\n                             note_data->env_inc);\n                     */\n                    if (note_data->env_inc < 0) {\n                        if (note_data->env_level\n                            > note_data->sample->env_target[note_data->env]) {\n                            note_data = note_data->next;\n                            continue;\n                        }\n                    } else if (note_data->env_inc > 0) {\n                        if (note_data->env_level\n                            < note_data->sample->env_target[note_data->env]) {\n                            note_data = note_data->next;\n                            continue;\n                        }\n                    }\n\n                    // Yes could have a condition here but\n                    // it would crete another bottleneck\n\n                    note_data->env_level =\n                    note_data->sample->env_target[note_data->env];\n                    switch (note_data->env) {\n                        case 0:\n                            if (!(note_data->modes & SAMPLE_ENVELOPE)) {\n                                note_data->env_inc = 0;\n                                note_data = note_data->next;\n                                continue;\n                            }\n                            break;\n                        case 2:\n                            if (note_data->modes & SAMPLE_SUSTAIN /*|| note_data->hold*/) {\n                                note_data->env_inc = 0;\n                                note_data = note_data->next;\n                                continue;\n                            } else if (note_data->modes & SAMPLE_CLAMPED) {\n                                note_data->env = 5;\n                                if (note_data->env_level\n                                    > note_data->sample->env_target[5]) {\n                                    note_data->env_inc =\n                                    -note_data->sample->env_rate[5];\n                                } else {\n                                    note_data->env_inc =\n                                    note_data->sample->env_rate[5];\n                                }\n                                continue;\n                            }\n                            break;\n                        case 5:\n                            if (__builtin_expect((note_data->env_level == 0), 1)) {\n                                goto _END_THIS_NOTE;\n                            }\n                            /* sample release */\n                            if (note_data->modes & SAMPLE_LOOP)\n                                note_data->modes ^= SAMPLE_LOOP;\n                            note_data->env_inc = 0;\n                            note_data = note_data->next;\n                            continue;\n                        case 6:\n                        _END_THIS_NOTE:\n                            if (__builtin_expect((note_data->replay != NULL), 1)) {\n                                note_data->active = 0;\n                                {\n                                    struct _note *prev_note = NULL;\n                                    struct _note *nte_array = mdi->note;\n\n                                    if (nte_array != note_data) {\n                                        do {\n                                            prev_note = nte_array;\n                                            nte_array = nte_array->next;\n                                        } while (nte_array != note_data);\n                                    }\n                                    if (prev_note) {\n                                        prev_note->next = note_data->replay;\n                                    } else {\n                                        mdi->note = note_data->replay;\n                                    }\n                                    note_data->replay->next = note_data->next;\n                                    note_data = note_data->replay;\n                                    note_data->active = 1;\n                                }\n                            } else {\n                                note_data->active = 0;\n                                {\n                                    struct _note *prev_note = NULL;\n                                    struct _note *nte_array = mdi->note;\n\n                                    if (nte_array != note_data) {\n                                        do {\n                                            prev_note = nte_array;\n                                            nte_array = nte_array->next;\n                                        } while ((nte_array != note_data)\n                                                 && (nte_array));\n                                    }\n                                    if (prev_note) {\n                                        prev_note->next = note_data->next;\n                                    } else {\n                                        mdi->note = note_data->next;\n                                    }\n                                    note_data = note_data->next;\n                                }\n                            }\n                            continue;\n                    }\n                    note_data->env++;\n\n                    if (note_data->is_off == 1) {\n                        _WM_do_note_off_extra(note_data);\n                    } else {\n\n                        if (note_data->env_level\n                            >= note_data->sample->env_target[note_data->env]) {\n                            note_data->env_inc =\n                            -note_data->sample->env_rate[note_data->env];\n                        } else {\n                            note_data->env_inc =\n                            note_data->sample->env_rate[note_data->env];\n                        }\n                    }\n                    note_data = note_data->next;\n                    continue;\n                }\n            }\n            *tmp_buffer++ = left_mix;\n            *tmp_buffer++ = right_mix;\n        } while (--count);\n\n        buffer_used += real_samples_to_mix * 4;\n        size -= (real_samples_to_mix << 2);\n        mdi->extra_info.current_sample += real_samples_to_mix;\n        mdi->samples_to_mix -= real_samples_to_mix;\n    } while (size);\n\n    tmp_buffer = out_buffer;\n\n    if (mdi->extra_info.mixer_options & WM_MO_REVERB) {\n        _WM_do_reverb(mdi->reverb, tmp_buffer, (buffer_used / 2));\n    }\n\n    // _WM_DynamicVolumeAdjust(mdi, tmp_buffer, (buffer_used/2));\n\n    for (i = 0; i < buffer_used; i += 4) {\n        left_mix = *tmp_buffer++;\n        right_mix = *tmp_buffer++;\n\n        /*\n         * ===================\n         * Write to the buffer\n         * ===================\n         */\n#ifdef WORDS_BIGENDIAN\n        (*buffer++) = ((left_mix >> 8) & 0x7f) | ((left_mix >> 24) & 0x80);\n        (*buffer++) = left_mix & 0xff;\n        (*buffer++) = ((right_mix >> 8) & 0x7f) | ((right_mix >> 24) & 0x80);\n        (*buffer++) = right_mix & 0xff;\n#else\n        (*buffer++) = left_mix & 0xff;\n        (*buffer++) = ((left_mix >> 8) & 0x7f) | ((left_mix >> 24) & 0x80);\n        (*buffer++) = right_mix & 0xff;\n        (*buffer++) = ((right_mix >> 8) & 0x7f) | ((right_mix >> 24) & 0x80);\n#endif\n    }\n    _WM_Unlock(&mdi->lock);\n    return (buffer_used);\n}\n\n/*\n * =========================\n * External Functions\n * =========================\n */\n\nWM_SYMBOL int WildMidi_ConvertToMidi (const char *file, uint8_t **out, uint32_t *size) {\n    uint8_t *buf;\n    int ret;\n\n    if (!file) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(NULL filename)\", 0);\n        return (-1);\n    }\n    if ((buf = (uint8_t *) _WM_BufferFile(file, size)) == NULL) {\n        return (-1);\n    }\n\n    ret = WildMidi_ConvertBufferToMidi(buf, *size, out, size);\n    free(buf);\n    return ret;\n}\n\nWM_SYMBOL int WildMidi_ConvertBufferToMidi (uint8_t *in, uint32_t insize,\n                                            uint8_t **out, uint32_t *outsize) {\n    if (!in || !out || !outsize) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(NULL params)\", 0);\n        return (-1);\n    }\n\n    if (!memcmp(in, \"FORM\", 4)) {\n        if (_WM_xmi2midi(in, insize, out, outsize,\n                _cvt_get_option(WM_CO_XMI_TYPE)) < 0) {\n            return (-1);\n        }\n    }\n    else if (!memcmp(in, \"MUS\", 3)) {\n        if (_WM_mus2midi(in, insize, out, outsize,\n                _cvt_get_option(WM_CO_FREQUENCY)) < 0) {\n            return (-1);\n        }\n    }\n    else if (!memcmp(in, \"MThd\", 4)) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, 0, \"Already a midi file\", 0);\n        return (-1);\n    }\n    else {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID, NULL, 0);\n        return (-1);\n    }\n\n    return (0);\n}\n\nWM_SYMBOL const char *WildMidi_GetString(uint16_t info) {\n    static char WM_Version[] = \"WildMidi Processing Library \" PACKAGE_VERSION;\n    switch (info) {\n    case WM_GS_VERSION:\n        return WM_Version;\n    }\n    return NULL;\n}\n\nWM_SYMBOL long WildMidi_GetVersion (void) {\n    return (LIBWILDMIDI_VERSION);\n}\n\nWM_SYMBOL int WildMidi_Init(const char *config_file, uint16_t rate, uint16_t mixer_options) {\n    if (WM_Initialized) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_ALR_INIT, NULL, 0);\n        return (-1);\n    }\n\n    if (config_file == NULL) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG,\n                \"(NULL config file pointer)\", 0);\n        return (-1);\n    }\n    WM_InitPatches();\n    if (WM_LoadConfig(config_file) == -1) {\n        return (-1);\n    }\n\n    if (mixer_options & 0x0FF0) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(invalid option)\",\n                0);\n        WM_FreePatches();\n        return (-1);\n    }\n    _WM_MixerOptions = mixer_options;\n\n    if (rate < 11025) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG,\n                \"(rate out of bounds, range is 11025 - 65535)\", 0);\n        WM_FreePatches();\n        return (-1);\n    }\n    _WM_SampleRate = rate;\n\n    gauss_lock = 0;\n    _WM_patch_lock = 0;\n    _WM_MasterVolume = 948;\n    WM_Initialized = 1;\n\n    return (0);\n}\n\nWM_SYMBOL int WildMidi_MasterVolume(uint8_t master_volume) {\n    if (!WM_Initialized) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_INIT, NULL, 0);\n        return (-1);\n    }\n    if (master_volume > 127) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG,\n                \"(master volume out of range, range is 0-127)\", 0);\n        return (-1);\n    }\n\n    _WM_MasterVolume = _WM_lin_volume[master_volume];\n\n    return (0);\n}\n\nWM_SYMBOL int WildMidi_Close(midi * handle) {\n    struct _mdi *mdi = (struct _mdi *) handle;\n    struct _hndl * tmp_handle;\n\n    if (!WM_Initialized) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_INIT, NULL, 0);\n        return (-1);\n    }\n    if (handle == NULL) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(NULL handle)\", 0);\n        return (-1);\n    }\n    if (first_handle == NULL) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(no midi's open)\", 0);\n        return (-1);\n    }\n    _WM_Lock(&mdi->lock);\n    if (first_handle->handle == handle) {\n        tmp_handle = first_handle->next;\n        free(first_handle);\n        first_handle = tmp_handle;\n        if (first_handle)\n            first_handle->prev = NULL;\n    } else {\n        tmp_handle = first_handle;\n        while (tmp_handle->handle != handle) {\n            tmp_handle = tmp_handle->next;\n            if (tmp_handle == NULL) {\n                break;\n            }\n        }\n        if (tmp_handle) {\n            tmp_handle->prev->next = tmp_handle->next;\n            if (tmp_handle->next) {\n                tmp_handle->next->prev = tmp_handle->prev;\n            }\n            free(tmp_handle);\n        }\n    }\n\n    _WM_freeMDI(mdi);\n\n    return (0);\n}\n\nWM_SYMBOL midi *WildMidi_Open(const char *midifile) {\n    uint8_t *mididata = NULL;\n    uint32_t midisize = 0;\n    uint8_t mus_hdr[] = { 'M', 'U', 'S', 0x1A };\n    uint8_t xmi_hdr[] = { 'F', 'O', 'R', 'M' };\n    midi * ret = NULL;\n\n    if (!WM_Initialized) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_INIT, NULL, 0);\n        return (NULL);\n    }\n    if (midifile == NULL) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(NULL filename)\", 0);\n        return (NULL);\n    }\n\n    if ((mididata = (uint8_t *) _WM_BufferFile(midifile, &midisize)) == NULL) {\n        return (NULL);\n    }\n    if (midisize < 18) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(too short)\", 0);\n        return (NULL);\n    }\n    if (memcmp(mididata,\"HMIMIDIP\", 8) == 0) {\n        ret = (void *) _WM_ParseNewHmp(mididata, midisize);\n    } else if (memcmp(mididata, \"HMI-MIDISONG061595\", 18) == 0) {\n        ret = (void *) _WM_ParseNewHmi(mididata, midisize);\n    } else if (memcmp(mididata, mus_hdr, 4) == 0) {\n        ret = (void *) _WM_ParseNewMus(mididata, midisize);\n    } else if (memcmp(mididata, xmi_hdr, 4) == 0) {\n        ret = (void *) _WM_ParseNewXmi(mididata, midisize);\n    } else {\n        ret = (void *) _WM_ParseNewMidi(mididata, midisize);\n    }\n    free(mididata);\n\n    if (ret) {\n        if (add_handle(ret) != 0) {\n            WildMidi_Close(ret);\n            ret = NULL;\n        }\n    }\n\n    return (ret);\n}\n\nWM_SYMBOL midi *WildMidi_OpenBuffer(uint8_t *midibuffer, uint32_t size) {\n    uint8_t mus_hdr[] = { 'M', 'U', 'S', 0x1A };\n    uint8_t xmi_hdr[] = { 'F', 'O', 'R', 'M' };\n    midi * ret = NULL;\n\n    if (!WM_Initialized) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_INIT, NULL, 0);\n        return (NULL);\n    }\n    if (midibuffer == NULL) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(NULL midi data buffer)\", 0);\n        return (NULL);\n    }\n    if (size > WM_MAXFILESIZE) {\n        /* don't bother loading suspiciously long files */\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_LONGFIL, NULL, 0);\n        return (NULL);\n    }\n    if (size < 18) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(too short)\", 0);\n        return (NULL);\n    }\n    if (memcmp(midibuffer,\"HMIMIDIP\", 8) == 0) {\n        ret = (void *) _WM_ParseNewHmp(midibuffer, size);\n    } else if (memcmp(midibuffer, \"HMI-MIDISONG061595\", 18) == 0) {\n        ret = (void *) _WM_ParseNewHmi(midibuffer, size);\n    } else if (memcmp(midibuffer, mus_hdr, 4) == 0) {\n        ret = (void *) _WM_ParseNewMus(midibuffer, size);\n    } else if (memcmp(midibuffer, xmi_hdr, 4) == 0) {\n        ret = (void *) _WM_ParseNewXmi(midibuffer, size);\n    } else {\n        ret = (void *) _WM_ParseNewMidi(midibuffer, size);\n    }\n\n    if (ret) {\n        if (add_handle(ret) != 0) {\n            WildMidi_Close(ret);\n            ret = NULL;\n        }\n    }\n\n    return (ret);\n}\n\nWM_SYMBOL int WildMidi_FastSeek(midi * handle, unsigned long int *sample_pos) {\n    struct _mdi *mdi;\n    struct _event *event;\n    struct _note *note_data;\n\n    if (!WM_Initialized) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_INIT, NULL, 0);\n        return (-1);\n    }\n    if (handle == NULL) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(NULL handle)\", 0);\n        return (-1);\n    }\n    if (sample_pos == NULL) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(NULL seek position pointer)\", 0);\n        return (-1);\n    }\n\n    mdi = (struct _mdi *) handle;\n    _WM_Lock(&mdi->lock);\n    event = mdi->current_event;\n\n    /* make sure we havent asked for a positions beyond the end of the song. */\n    if (*sample_pos > mdi->extra_info.approx_total_samples) {\n        /* if so set the position to the end of the song */\n        *sample_pos = mdi->extra_info.approx_total_samples;\n    }\n\n    /* was end of song requested and are we are there? */\n    if (*sample_pos == mdi->extra_info.approx_total_samples) {\n        /* yes */\n        _WM_Unlock(&mdi->lock);\n        return (0);\n    }\n\n    /* did we want to fast forward? */\n    if (mdi->extra_info.current_sample > *sample_pos) {\n        /* no - reset some stuff */\n        event = mdi->events;\n        _WM_ResetToStart(handle);\n        mdi->extra_info.current_sample = 0;\n        mdi->samples_to_mix = 0;\n    }\n\n    if ((mdi->extra_info.current_sample + mdi->samples_to_mix) > *sample_pos) {\n        mdi->samples_to_mix = (mdi->extra_info.current_sample + mdi->samples_to_mix) - *sample_pos;\n        mdi->extra_info.current_sample = *sample_pos;\n    } else {\n        mdi->extra_info.current_sample += mdi->samples_to_mix;\n        mdi->samples_to_mix = 0;\n        while ((!mdi->samples_to_mix) && (event->do_event)) {\n            event->do_event(mdi, &event->event_data);\n            mdi->samples_to_mix = event->samples_to_next;\n                \n            if ((mdi->extra_info.current_sample + mdi->samples_to_mix) > *sample_pos) {\n                mdi->samples_to_mix = (mdi->extra_info.current_sample + mdi->samples_to_mix) - *sample_pos;\n                mdi->extra_info.current_sample = *sample_pos;\n            } else {\n                mdi->extra_info.current_sample += mdi->samples_to_mix;\n                mdi->samples_to_mix = 0;\n            }\n            event++;\n        }\n        mdi->current_event = event;\n    }\n\n    /*\n     * Clear notes as this is a fast seek so we only care\n     * about new notes.\n     *\n     * NOTE: This function is for performance only.\n     * Might need a WildMidi_SlowSeek if we need better accuracy.\n     */\n    note_data = mdi->note;\n    if (note_data) {\n        do {\n            note_data->active = 0;\n            if (note_data->replay) {\n                note_data->replay = NULL;\n            }\n            note_data = note_data->next;\n        } while (note_data);\n    }\n    mdi->note = NULL;\n\n    /* clear the reverb buffers since we not gonna be using them here */\n    _WM_reset_reverb(mdi->reverb);\n\n    _WM_Unlock(&mdi->lock);\n    return (0);\n}\n\nWM_SYMBOL int WildMidi_SongSeek (midi * handle, int8_t nextsong) {\n    struct _mdi *mdi;\n    struct _event *event;\n    struct _event *event_new;\n    struct _note *note_data;\n\n    if (!WM_Initialized) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_INIT, NULL, 0);\n        return (-1);\n    }\n    if (handle == NULL) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(NULL handle)\", 0);\n        return (-1);\n    }\n    mdi = (struct _mdi *) handle;\n    _WM_Lock(&mdi->lock);\n\n    if ((!mdi->is_type2) && (nextsong != 0)) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(Illegal use. Only usable with files detected to be type 2 compatible.\", 0);\n        _WM_Unlock(&mdi->lock);\n        return (-1);\n    }\n    if ((nextsong > 1) || (nextsong < -1)) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(Invalid nextsong setting. -1 is previous song, 0 start of current song, 1 is next song)\", 0);\n        _WM_Unlock(&mdi->lock);\n        return (-1);\n    }\n\n    event = mdi->current_event;\n\n    if (nextsong == -1) {\n        /* goto start of previous song */\n        /*\n         * So with this one we have to go back 2 eof's\n         * then forward 1 event to get to the start of\n         * the previous song.\n         * NOTE: We will automatically stop at the start \n         * of the data.\n         */\n        uint8_t eof_cnt = 1;\n        while (event != mdi->events) {\n            if (event[-1].do_event == _WM_do_meta_endoftrack) {\n                if (eof_cnt == 0) {\n                    break;\n                }\n                eof_cnt = 0;\n            }\n            event--;\n        }\n        event_new = event;\n        event = mdi->events;\n        _WM_ResetToStart(handle);\n\n    } else if (nextsong == 1) {\n        /* goto start of next song */\n        while (event->do_event != NULL) {\n            if (event->do_event == _WM_do_meta_endoftrack) {\n                event++;\n                if (event->do_event == NULL) {\n                    event--;\n                    goto START_THIS_SONG;\n                } else {\n                    break;\n                }\n            }\n            event++;\n        }\n        event_new = event;\n        event = mdi->current_event;\n\n    } else {\n    START_THIS_SONG:\n        /* goto start of this song */\n        /* first find the offset */\n        while (event != mdi->events) {\n            if (event[-1].do_event == _WM_do_meta_endoftrack) {\n                break;\n            }\n            event--;\n        }\n        event_new = event;\n        event = mdi->events;\n        _WM_ResetToStart(handle);\n    }\n\n    while (event != event_new) {\n        event->do_event(mdi, &event->event_data);\n        mdi->extra_info.current_sample += event->samples_to_next;\n        event++;\n    }\n\n    mdi->current_event = event;\n\n    note_data = mdi->note;\n    if (note_data) {\n        do {\n            note_data->active = 0;\n            if (note_data->replay) {\n                note_data->replay = NULL;\n            }\n            note_data = note_data->next;\n        } while (note_data);\n    }\n    mdi->note = NULL;\n\n    _WM_Unlock(&mdi->lock);\n    return (0);\n}\n\nWM_SYMBOL int WildMidi_GetOutput(midi * handle, int8_t *buffer, uint32_t size) {\n    if (__builtin_expect((!WM_Initialized), 0)) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_INIT, NULL, 0);\n        return (-1);\n    }\n    if (__builtin_expect((handle == NULL), 0)) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(NULL handle)\", 0);\n        return (-1);\n    }\n    if (__builtin_expect((buffer == NULL), 0)) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(NULL buffer pointer)\", 0);\n        return (-1);\n    }\n    if (__builtin_expect((size == 0), 0)) {\n        return (0);\n    }\n    if (__builtin_expect((!!(size % 4)), 0)) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(size not a multiple of 4)\", 0);\n        return (-1);\n    }\n\n    if (((struct _mdi *) handle)->extra_info.mixer_options & WM_MO_ENHANCED_RESAMPLING) {\n        if (!gauss_table) init_gauss();\n        return (WM_GetOutput_Gauss(handle, buffer, size));\n    }\n    return (WM_GetOutput_Linear(handle, buffer, size));\n}\n\nWM_SYMBOL int WildMidi_GetMidiOutput(midi * handle, int8_t **buffer, uint32_t *size) {\n    if (__builtin_expect((!WM_Initialized), 0)) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_INIT, NULL, 0);\n        return (-1);\n    }\n    if (__builtin_expect((handle == NULL), 0)) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(NULL handle)\", 0);\n        return (-1);\n    }\n    if (__builtin_expect((buffer == NULL), 0)) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(NULL buffer pointer)\", 0);\n        return (-1);\n    }\n    return _WM_Event2Midi(handle, (uint8_t **)buffer, size);\n}\n\n\nWM_SYMBOL int WildMidi_SetOption(midi * handle, uint16_t options, uint16_t setting) {\n    struct _mdi *mdi;\n\n    if (!WM_Initialized) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_INIT, NULL, 0);\n        return (-1);\n    }\n    if (handle == NULL) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(NULL handle)\", 0);\n        return (-1);\n    }\n\n    mdi = (struct _mdi *) handle;\n    _WM_Lock(&mdi->lock);\n    if ((!(options & 0x800F)) || (options & 0x7FF0)) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(invalid option)\", 0);\n        _WM_Unlock(&mdi->lock);\n        return (-1);\n    }\n    if (setting & 0x7FF0) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(invalid setting)\", 0);\n        _WM_Unlock(&mdi->lock);\n        return (-1);\n    }\n\n    mdi->extra_info.mixer_options = ((mdi->extra_info.mixer_options & (0x80FF ^ options))\n                                    | (options & setting));\n\n    if (options & WM_MO_LOG_VOLUME) {\n            _WM_AdjustChannelVolumes(mdi, 16);  // Settings greater than 15\n                                                // adjusts all channels\n    } else if (options & WM_MO_REVERB) {\n        _WM_reset_reverb(mdi->reverb);\n    }\n\n    _WM_Unlock(&mdi->lock);\n    return (0);\n}\n\nWM_SYMBOL int WildMidi_SetCvtOption(uint16_t tag, uint16_t setting) {\n    _WM_Lock(&WM_ConvertOptions.lock);\n    switch (tag) {\n    case WM_CO_XMI_TYPE: /* validation happens in xmidi.c */\n        WM_ConvertOptions.xmi_convert_type = setting;\n        break;\n    case WM_CO_FREQUENCY: /* validation happens in format */\n        WM_ConvertOptions.frequency = setting;\n        break;\n    default:\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(invalid setting)\", 0);\n        _WM_Unlock(&WM_ConvertOptions.lock);\n        return (-1);\n    }\n    _WM_Unlock(&WM_ConvertOptions.lock);\n    return (0);\n}\n\nWM_SYMBOL struct _WM_Info *\nWildMidi_GetInfo(midi * handle) {\n    struct _mdi *mdi = (struct _mdi *) handle;\n    if (!WM_Initialized) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_INIT, NULL, 0);\n        return (NULL);\n    }\n    if (handle == NULL) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(NULL handle)\", 0);\n        return (NULL);\n    }\n    _WM_Lock(&mdi->lock);\n    if (mdi->tmp_info == NULL) {\n        mdi->tmp_info = malloc(sizeof(struct _WM_Info));\n        if (mdi->tmp_info == NULL) {\n            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_MEM, \"to set info\", 0);\n            _WM_Unlock(&mdi->lock);\n            return (NULL);\n        }\n        mdi->tmp_info->copyright = NULL;\n    }\n    mdi->tmp_info->current_sample = mdi->extra_info.current_sample;\n    mdi->tmp_info->approx_total_samples = mdi->extra_info.approx_total_samples;\n    mdi->tmp_info->mixer_options = mdi->extra_info.mixer_options;\n    mdi->tmp_info->total_midi_time = (mdi->tmp_info->approx_total_samples * 1000) / _WM_SampleRate;\n    if (mdi->extra_info.copyright) {\n        free(mdi->tmp_info->copyright);\n        mdi->tmp_info->copyright = malloc(strlen(mdi->extra_info.copyright) + 1);\n        if (mdi->tmp_info->copyright == NULL) {\n            free(mdi->tmp_info);\n            mdi->tmp_info = NULL;\n            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_MEM, \"to set copyright\", 0);\n            _WM_Unlock(&mdi->lock);\n            return (NULL);\n        } else {\n            strcpy(mdi->tmp_info->copyright, mdi->extra_info.copyright);\n        }\n    } else {\n        mdi->tmp_info->copyright = NULL;\n    }\n    _WM_Unlock(&mdi->lock);\n    return ((struct _WM_Info *)mdi->tmp_info);\n}\n\nWM_SYMBOL int WildMidi_Shutdown(void) {\n    if (!WM_Initialized) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_INIT, NULL, 0);\n        return (-1);\n    }\n    while (first_handle) {\n        /* closes open handle and rotates the handles list. */\n        WildMidi_Close((struct _mdi *) first_handle->handle);\n    }\n    WM_FreePatches();\n    free_gauss();\n\n    /* reset the globals */\n    _cvt_reset_options ();\n    _WM_MasterVolume = 948;\n    _WM_MixerOptions = 0;\n    _WM_fix_release = 0;\n    _WM_auto_amp = 0;\n    _WM_auto_amp_with_amp = 0;\n    _WM_reverb_room_width = 16.875f;\n    _WM_reverb_room_length = 22.5f;\n    _WM_reverb_listen_posx = 8.4375f;\n    _WM_reverb_listen_posy = 16.875f;\n\n    WM_Initialized = 0;\n\n    if (_WM_Global_ErrorS != NULL) free(_WM_Global_ErrorS);\n\n    return (0);\n}\n\n/*\n    char * WildMidi_GetLyric(midi * handle)\n\n    Returns points to a \\0 terminated string that contains the\n    data contained in the last read lyric or text meta event.\n    Or returns NULL if no lyric is waiting to be read.\n\n    Force read from text meta event by including WM_MO_TEXTASLYRIC\n    in the options in WildMidi_Init.\n\n    Programs calling this only need to read the pointer.\n    Cleanup is done by the lib.\n\n    Once WildMidi_GetLyric is called it will return NULL\n    on subsiquent calls until the next lyric event is processed\n    during a WildMidi_GetOutput call.\n */\nWM_SYMBOL char * WildMidi_GetLyric (midi * handle) {\n    struct _mdi *mdi = (struct _mdi *) handle;\n    char * lyric = NULL;\n\n    if (!WM_Initialized) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_INIT, NULL, 0);\n        return (NULL);\n    }\n    if (handle == NULL) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(NULL handle)\", 0);\n        return (NULL);\n    }\n    _WM_Lock(&mdi->lock);\n    lyric = mdi->lyric;\n    mdi->lyric = NULL;\n    _WM_Unlock(&mdi->lock);\n    return (lyric);\n}\n\n/*\n * Return Last Error Message\n */\nWM_SYMBOL char * WildMidi_GetError (void) {\n    return (_WM_Global_ErrorS);\n}\n\n/*\n * Clear any error message\n */\nWM_SYMBOL void WildMidi_ClearError (void) {\n    _WM_Global_ErrorI = 0;\n    if (_WM_Global_ErrorS != NULL) {\n        free(_WM_Global_ErrorS);\n        _WM_Global_ErrorS = NULL;\n    }\n    return;\n}\n\n"], "filenames": ["README.md", "src/wildmidi_lib.c"], "buggy_code_start_loc": [40, 1657], "buggy_code_end_loc": [40, 1696], "fixing_code_start_loc": [41, 1658], "fixing_code_end_loc": [43, 1705], "type": "CWE-119", "message": "The WildMidi_Open function in WildMIDI since commit d8a466829c67cacbb1700beded25c448d99514e5 allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted file.", "other": {"cve": {"id": "CVE-2017-1000418", "sourceIdentifier": "cve@mitre.org", "published": "2018-01-02T18:29:00.200", "lastModified": "2018-01-18T22:32:45.083", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The WildMidi_Open function in WildMIDI since commit d8a466829c67cacbb1700beded25c448d99514e5 allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted file."}, {"lang": "es", "value": "La funci\u00f3n WildMidi_Open en WildMIDI desde el commit con ID d8a466829c67cacbb1700beded25c448d99514e5 permite que atacantes remotos provoquen una denegaci\u00f3n de servicio (desbordamiento de b\u00fafer basado en memoria din\u00e1mica o heap y cierre inesperado de la aplicaci\u00f3n) o, probablemente, provocar cualquier otro tipo de problema mediante un archivo manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mindwerks:wildmidi:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.4.1", "matchCriteriaId": "67A12CD0-A1B6-4A62-A727-EC0EEB829F15"}]}]}], "references": [{"url": "https://github.com/Mindwerks/wildmidi/commit/814f31d8eceda8401eb812fc2e94ed143fdad0ab", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Mindwerks/wildmidi/issues/178", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Mindwerks/wildmidi/commit/814f31d8eceda8401eb812fc2e94ed143fdad0ab"}}