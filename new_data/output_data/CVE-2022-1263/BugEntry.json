{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * Kernel-based Virtual Machine driver for Linux\n *\n * This module enables machines with Intel VT-x extensions to run virtual\n * machines without emulation or binary translation.\n *\n * Copyright (C) 2006 Qumranet, Inc.\n * Copyright 2010 Red Hat, Inc. and/or its affiliates.\n *\n * Authors:\n *   Avi Kivity   <avi@qumranet.com>\n *   Yaniv Kamay  <yaniv@qumranet.com>\n */\n\n#include <kvm/iodev.h>\n\n#include <linux/kvm_host.h>\n#include <linux/kvm.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/miscdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/reboot.h>\n#include <linux/debugfs.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/syscore_ops.h>\n#include <linux/cpu.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/stat.h>\n#include <linux/cpumask.h>\n#include <linux/smp.h>\n#include <linux/anon_inodes.h>\n#include <linux/profile.h>\n#include <linux/kvm_para.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/bitops.h>\n#include <linux/spinlock.h>\n#include <linux/compat.h>\n#include <linux/srcu.h>\n#include <linux/hugetlb.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/io.h>\n#include <linux/lockdep.h>\n#include <linux/kthread.h>\n#include <linux/suspend.h>\n\n#include <asm/processor.h>\n#include <asm/ioctl.h>\n#include <linux/uaccess.h>\n\n#include \"coalesced_mmio.h\"\n#include \"async_pf.h\"\n#include \"kvm_mm.h\"\n#include \"vfio.h\"\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/kvm.h>\n\n#include <linux/kvm_dirty_ring.h>\n\n/* Worst case buffer size needed for holding an integer. */\n#define ITOA_MAX_LEN 12\n\nMODULE_AUTHOR(\"Qumranet\");\nMODULE_LICENSE(\"GPL\");\n\n/* Architectures should define their poll value according to the halt latency */\nunsigned int halt_poll_ns = KVM_HALT_POLL_NS_DEFAULT;\nmodule_param(halt_poll_ns, uint, 0644);\nEXPORT_SYMBOL_GPL(halt_poll_ns);\n\n/* Default doubles per-vcpu halt_poll_ns. */\nunsigned int halt_poll_ns_grow = 2;\nmodule_param(halt_poll_ns_grow, uint, 0644);\nEXPORT_SYMBOL_GPL(halt_poll_ns_grow);\n\n/* The start value to grow halt_poll_ns from */\nunsigned int halt_poll_ns_grow_start = 10000; /* 10us */\nmodule_param(halt_poll_ns_grow_start, uint, 0644);\nEXPORT_SYMBOL_GPL(halt_poll_ns_grow_start);\n\n/* Default resets per-vcpu halt_poll_ns . */\nunsigned int halt_poll_ns_shrink;\nmodule_param(halt_poll_ns_shrink, uint, 0644);\nEXPORT_SYMBOL_GPL(halt_poll_ns_shrink);\n\n/*\n * Ordering of locks:\n *\n *\tkvm->lock --> kvm->slots_lock --> kvm->irq_lock\n */\n\nDEFINE_MUTEX(kvm_lock);\nstatic DEFINE_RAW_SPINLOCK(kvm_count_lock);\nLIST_HEAD(vm_list);\n\nstatic cpumask_var_t cpus_hardware_enabled;\nstatic int kvm_usage_count;\nstatic atomic_t hardware_enable_failed;\n\nstatic struct kmem_cache *kvm_vcpu_cache;\n\nstatic __read_mostly struct preempt_ops kvm_preempt_ops;\nstatic DEFINE_PER_CPU(struct kvm_vcpu *, kvm_running_vcpu);\n\nstruct dentry *kvm_debugfs_dir;\nEXPORT_SYMBOL_GPL(kvm_debugfs_dir);\n\nstatic const struct file_operations stat_fops_per_vm;\n\nstatic struct file_operations kvm_chardev_ops;\n\nstatic long kvm_vcpu_ioctl(struct file *file, unsigned int ioctl,\n\t\t\t   unsigned long arg);\n#ifdef CONFIG_KVM_COMPAT\nstatic long kvm_vcpu_compat_ioctl(struct file *file, unsigned int ioctl,\n\t\t\t\t  unsigned long arg);\n#define KVM_COMPAT(c)\t.compat_ioctl\t= (c)\n#else\n/*\n * For architectures that don't implement a compat infrastructure,\n * adopt a double line of defense:\n * - Prevent a compat task from opening /dev/kvm\n * - If the open has been done by a 64bit task, and the KVM fd\n *   passed to a compat task, let the ioctls fail.\n */\nstatic long kvm_no_compat_ioctl(struct file *file, unsigned int ioctl,\n\t\t\t\tunsigned long arg) { return -EINVAL; }\n\nstatic int kvm_no_compat_open(struct inode *inode, struct file *file)\n{\n\treturn is_compat_task() ? -ENODEV : 0;\n}\n#define KVM_COMPAT(c)\t.compat_ioctl\t= kvm_no_compat_ioctl,\t\\\n\t\t\t.open\t\t= kvm_no_compat_open\n#endif\nstatic int hardware_enable_all(void);\nstatic void hardware_disable_all(void);\n\nstatic void kvm_io_bus_destroy(struct kvm_io_bus *bus);\n\n__visible bool kvm_rebooting;\nEXPORT_SYMBOL_GPL(kvm_rebooting);\n\n#define KVM_EVENT_CREATE_VM 0\n#define KVM_EVENT_DESTROY_VM 1\nstatic void kvm_uevent_notify_change(unsigned int type, struct kvm *kvm);\nstatic unsigned long long kvm_createvm_count;\nstatic unsigned long long kvm_active_vms;\n\nstatic DEFINE_PER_CPU(cpumask_var_t, cpu_kick_mask);\n\n__weak void kvm_arch_mmu_notifier_invalidate_range(struct kvm *kvm,\n\t\t\t\t\t\t   unsigned long start, unsigned long end)\n{\n}\n\nbool kvm_is_zone_device_pfn(kvm_pfn_t pfn)\n{\n\t/*\n\t * The metadata used by is_zone_device_page() to determine whether or\n\t * not a page is ZONE_DEVICE is guaranteed to be valid if and only if\n\t * the device has been pinned, e.g. by get_user_pages().  WARN if the\n\t * page_count() is zero to help detect bad usage of this helper.\n\t */\n\tif (!pfn_valid(pfn) || WARN_ON_ONCE(!page_count(pfn_to_page(pfn))))\n\t\treturn false;\n\n\treturn is_zone_device_page(pfn_to_page(pfn));\n}\n\nbool kvm_is_reserved_pfn(kvm_pfn_t pfn)\n{\n\t/*\n\t * ZONE_DEVICE pages currently set PG_reserved, but from a refcounting\n\t * perspective they are \"normal\" pages, albeit with slightly different\n\t * usage rules.\n\t */\n\tif (pfn_valid(pfn))\n\t\treturn PageReserved(pfn_to_page(pfn)) &&\n\t\t       !is_zero_pfn(pfn) &&\n\t\t       !kvm_is_zone_device_pfn(pfn);\n\n\treturn true;\n}\n\n/*\n * Switches to specified vcpu, until a matching vcpu_put()\n */\nvoid vcpu_load(struct kvm_vcpu *vcpu)\n{\n\tint cpu = get_cpu();\n\n\t__this_cpu_write(kvm_running_vcpu, vcpu);\n\tpreempt_notifier_register(&vcpu->preempt_notifier);\n\tkvm_arch_vcpu_load(vcpu, cpu);\n\tput_cpu();\n}\nEXPORT_SYMBOL_GPL(vcpu_load);\n\nvoid vcpu_put(struct kvm_vcpu *vcpu)\n{\n\tpreempt_disable();\n\tkvm_arch_vcpu_put(vcpu);\n\tpreempt_notifier_unregister(&vcpu->preempt_notifier);\n\t__this_cpu_write(kvm_running_vcpu, NULL);\n\tpreempt_enable();\n}\nEXPORT_SYMBOL_GPL(vcpu_put);\n\n/* TODO: merge with kvm_arch_vcpu_should_kick */\nstatic bool kvm_request_needs_ipi(struct kvm_vcpu *vcpu, unsigned req)\n{\n\tint mode = kvm_vcpu_exiting_guest_mode(vcpu);\n\n\t/*\n\t * We need to wait for the VCPU to reenable interrupts and get out of\n\t * READING_SHADOW_PAGE_TABLES mode.\n\t */\n\tif (req & KVM_REQUEST_WAIT)\n\t\treturn mode != OUTSIDE_GUEST_MODE;\n\n\t/*\n\t * Need to kick a running VCPU, but otherwise there is nothing to do.\n\t */\n\treturn mode == IN_GUEST_MODE;\n}\n\nstatic void ack_flush(void *_completed)\n{\n}\n\nstatic inline bool kvm_kick_many_cpus(struct cpumask *cpus, bool wait)\n{\n\tif (cpumask_empty(cpus))\n\t\treturn false;\n\n\tsmp_call_function_many(cpus, ack_flush, NULL, wait);\n\treturn true;\n}\n\nstatic void kvm_make_vcpu_request(struct kvm_vcpu *vcpu, unsigned int req,\n\t\t\t\t  struct cpumask *tmp, int current_cpu)\n{\n\tint cpu;\n\n\tif (likely(!(req & KVM_REQUEST_NO_ACTION)))\n\t\t__kvm_make_request(req, vcpu);\n\n\tif (!(req & KVM_REQUEST_NO_WAKEUP) && kvm_vcpu_wake_up(vcpu))\n\t\treturn;\n\n\t/*\n\t * Note, the vCPU could get migrated to a different pCPU at any point\n\t * after kvm_request_needs_ipi(), which could result in sending an IPI\n\t * to the previous pCPU.  But, that's OK because the purpose of the IPI\n\t * is to ensure the vCPU returns to OUTSIDE_GUEST_MODE, which is\n\t * satisfied if the vCPU migrates. Entering READING_SHADOW_PAGE_TABLES\n\t * after this point is also OK, as the requirement is only that KVM wait\n\t * for vCPUs that were reading SPTEs _before_ any changes were\n\t * finalized. See kvm_vcpu_kick() for more details on handling requests.\n\t */\n\tif (kvm_request_needs_ipi(vcpu, req)) {\n\t\tcpu = READ_ONCE(vcpu->cpu);\n\t\tif (cpu != -1 && cpu != current_cpu)\n\t\t\t__cpumask_set_cpu(cpu, tmp);\n\t}\n}\n\nbool kvm_make_vcpus_request_mask(struct kvm *kvm, unsigned int req,\n\t\t\t\t unsigned long *vcpu_bitmap)\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct cpumask *cpus;\n\tint i, me;\n\tbool called;\n\n\tme = get_cpu();\n\n\tcpus = this_cpu_cpumask_var_ptr(cpu_kick_mask);\n\tcpumask_clear(cpus);\n\n\tfor_each_set_bit(i, vcpu_bitmap, KVM_MAX_VCPUS) {\n\t\tvcpu = kvm_get_vcpu(kvm, i);\n\t\tif (!vcpu)\n\t\t\tcontinue;\n\t\tkvm_make_vcpu_request(vcpu, req, cpus, me);\n\t}\n\n\tcalled = kvm_kick_many_cpus(cpus, !!(req & KVM_REQUEST_WAIT));\n\tput_cpu();\n\n\treturn called;\n}\n\nbool kvm_make_all_cpus_request_except(struct kvm *kvm, unsigned int req,\n\t\t\t\t      struct kvm_vcpu *except)\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct cpumask *cpus;\n\tunsigned long i;\n\tbool called;\n\tint me;\n\n\tme = get_cpu();\n\n\tcpus = this_cpu_cpumask_var_ptr(cpu_kick_mask);\n\tcpumask_clear(cpus);\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (vcpu == except)\n\t\t\tcontinue;\n\t\tkvm_make_vcpu_request(vcpu, req, cpus, me);\n\t}\n\n\tcalled = kvm_kick_many_cpus(cpus, !!(req & KVM_REQUEST_WAIT));\n\tput_cpu();\n\n\treturn called;\n}\n\nbool kvm_make_all_cpus_request(struct kvm *kvm, unsigned int req)\n{\n\treturn kvm_make_all_cpus_request_except(kvm, req, NULL);\n}\nEXPORT_SYMBOL_GPL(kvm_make_all_cpus_request);\n\n#ifndef CONFIG_HAVE_KVM_ARCH_TLB_FLUSH_ALL\nvoid kvm_flush_remote_tlbs(struct kvm *kvm)\n{\n\t++kvm->stat.generic.remote_tlb_flush_requests;\n\n\t/*\n\t * We want to publish modifications to the page tables before reading\n\t * mode. Pairs with a memory barrier in arch-specific code.\n\t * - x86: smp_mb__after_srcu_read_unlock in vcpu_enter_guest\n\t * and smp_mb in walk_shadow_page_lockless_begin/end.\n\t * - powerpc: smp_mb in kvmppc_prepare_to_enter.\n\t *\n\t * There is already an smp_mb__after_atomic() before\n\t * kvm_make_all_cpus_request() reads vcpu->mode. We reuse that\n\t * barrier here.\n\t */\n\tif (!kvm_arch_flush_remote_tlb(kvm)\n\t    || kvm_make_all_cpus_request(kvm, KVM_REQ_TLB_FLUSH))\n\t\t++kvm->stat.generic.remote_tlb_flush;\n}\nEXPORT_SYMBOL_GPL(kvm_flush_remote_tlbs);\n#endif\n\n#ifdef KVM_ARCH_NR_OBJS_PER_MEMORY_CACHE\nstatic inline void *mmu_memory_cache_alloc_obj(struct kvm_mmu_memory_cache *mc,\n\t\t\t\t\t       gfp_t gfp_flags)\n{\n\tgfp_flags |= mc->gfp_zero;\n\n\tif (mc->kmem_cache)\n\t\treturn kmem_cache_alloc(mc->kmem_cache, gfp_flags);\n\telse\n\t\treturn (void *)__get_free_page(gfp_flags);\n}\n\nint kvm_mmu_topup_memory_cache(struct kvm_mmu_memory_cache *mc, int min)\n{\n\tvoid *obj;\n\n\tif (mc->nobjs >= min)\n\t\treturn 0;\n\twhile (mc->nobjs < ARRAY_SIZE(mc->objects)) {\n\t\tobj = mmu_memory_cache_alloc_obj(mc, GFP_KERNEL_ACCOUNT);\n\t\tif (!obj)\n\t\t\treturn mc->nobjs >= min ? 0 : -ENOMEM;\n\t\tmc->objects[mc->nobjs++] = obj;\n\t}\n\treturn 0;\n}\n\nint kvm_mmu_memory_cache_nr_free_objects(struct kvm_mmu_memory_cache *mc)\n{\n\treturn mc->nobjs;\n}\n\nvoid kvm_mmu_free_memory_cache(struct kvm_mmu_memory_cache *mc)\n{\n\twhile (mc->nobjs) {\n\t\tif (mc->kmem_cache)\n\t\t\tkmem_cache_free(mc->kmem_cache, mc->objects[--mc->nobjs]);\n\t\telse\n\t\t\tfree_page((unsigned long)mc->objects[--mc->nobjs]);\n\t}\n}\n\nvoid *kvm_mmu_memory_cache_alloc(struct kvm_mmu_memory_cache *mc)\n{\n\tvoid *p;\n\n\tif (WARN_ON(!mc->nobjs))\n\t\tp = mmu_memory_cache_alloc_obj(mc, GFP_ATOMIC | __GFP_ACCOUNT);\n\telse\n\t\tp = mc->objects[--mc->nobjs];\n\tBUG_ON(!p);\n\treturn p;\n}\n#endif\n\nstatic void kvm_vcpu_init(struct kvm_vcpu *vcpu, struct kvm *kvm, unsigned id)\n{\n\tmutex_init(&vcpu->mutex);\n\tvcpu->cpu = -1;\n\tvcpu->kvm = kvm;\n\tvcpu->vcpu_id = id;\n\tvcpu->pid = NULL;\n#ifndef __KVM_HAVE_ARCH_WQP\n\trcuwait_init(&vcpu->wait);\n#endif\n\tkvm_async_pf_vcpu_init(vcpu);\n\n\tkvm_vcpu_set_in_spin_loop(vcpu, false);\n\tkvm_vcpu_set_dy_eligible(vcpu, false);\n\tvcpu->preempted = false;\n\tvcpu->ready = false;\n\tpreempt_notifier_init(&vcpu->preempt_notifier, &kvm_preempt_ops);\n\tvcpu->last_used_slot = NULL;\n}\n\nstatic void kvm_vcpu_destroy(struct kvm_vcpu *vcpu)\n{\n\tkvm_dirty_ring_free(&vcpu->dirty_ring);\n\tkvm_arch_vcpu_destroy(vcpu);\n\n\t/*\n\t * No need for rcu_read_lock as VCPU_RUN is the only place that changes\n\t * the vcpu->pid pointer, and at destruction time all file descriptors\n\t * are already gone.\n\t */\n\tput_pid(rcu_dereference_protected(vcpu->pid, 1));\n\n\tfree_page((unsigned long)vcpu->run);\n\tkmem_cache_free(kvm_vcpu_cache, vcpu);\n}\n\nvoid kvm_destroy_vcpus(struct kvm *kvm)\n{\n\tunsigned long i;\n\tstruct kvm_vcpu *vcpu;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tkvm_vcpu_destroy(vcpu);\n\t\txa_erase(&kvm->vcpu_array, i);\n\t}\n\n\tatomic_set(&kvm->online_vcpus, 0);\n}\nEXPORT_SYMBOL_GPL(kvm_destroy_vcpus);\n\n#if defined(CONFIG_MMU_NOTIFIER) && defined(KVM_ARCH_WANT_MMU_NOTIFIER)\nstatic inline struct kvm *mmu_notifier_to_kvm(struct mmu_notifier *mn)\n{\n\treturn container_of(mn, struct kvm, mmu_notifier);\n}\n\nstatic void kvm_mmu_notifier_invalidate_range(struct mmu_notifier *mn,\n\t\t\t\t\t      struct mm_struct *mm,\n\t\t\t\t\t      unsigned long start, unsigned long end)\n{\n\tstruct kvm *kvm = mmu_notifier_to_kvm(mn);\n\tint idx;\n\n\tidx = srcu_read_lock(&kvm->srcu);\n\tkvm_arch_mmu_notifier_invalidate_range(kvm, start, end);\n\tsrcu_read_unlock(&kvm->srcu, idx);\n}\n\ntypedef bool (*hva_handler_t)(struct kvm *kvm, struct kvm_gfn_range *range);\n\ntypedef void (*on_lock_fn_t)(struct kvm *kvm, unsigned long start,\n\t\t\t     unsigned long end);\n\nstruct kvm_hva_range {\n\tunsigned long start;\n\tunsigned long end;\n\tpte_t pte;\n\thva_handler_t handler;\n\ton_lock_fn_t on_lock;\n\tbool flush_on_ret;\n\tbool may_block;\n};\n\n/*\n * Use a dedicated stub instead of NULL to indicate that there is no callback\n * function/handler.  The compiler technically can't guarantee that a real\n * function will have a non-zero address, and so it will generate code to\n * check for !NULL, whereas comparing against a stub will be elided at compile\n * time (unless the compiler is getting long in the tooth, e.g. gcc 4.9).\n */\nstatic void kvm_null_fn(void)\n{\n\n}\n#define IS_KVM_NULL_FN(fn) ((fn) == (void *)kvm_null_fn)\n\n/* Iterate over each memslot intersecting [start, last] (inclusive) range */\n#define kvm_for_each_memslot_in_hva_range(node, slots, start, last)\t     \\\n\tfor (node = interval_tree_iter_first(&slots->hva_tree, start, last); \\\n\t     node;\t\t\t\t\t\t\t     \\\n\t     node = interval_tree_iter_next(node, start, last))\t     \\\n\nstatic __always_inline int __kvm_handle_hva_range(struct kvm *kvm,\n\t\t\t\t\t\t  const struct kvm_hva_range *range)\n{\n\tbool ret = false, locked = false;\n\tstruct kvm_gfn_range gfn_range;\n\tstruct kvm_memory_slot *slot;\n\tstruct kvm_memslots *slots;\n\tint i, idx;\n\n\tif (WARN_ON_ONCE(range->end <= range->start))\n\t\treturn 0;\n\n\t/* A null handler is allowed if and only if on_lock() is provided. */\n\tif (WARN_ON_ONCE(IS_KVM_NULL_FN(range->on_lock) &&\n\t\t\t IS_KVM_NULL_FN(range->handler)))\n\t\treturn 0;\n\n\tidx = srcu_read_lock(&kvm->srcu);\n\n\tfor (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {\n\t\tstruct interval_tree_node *node;\n\n\t\tslots = __kvm_memslots(kvm, i);\n\t\tkvm_for_each_memslot_in_hva_range(node, slots,\n\t\t\t\t\t\t  range->start, range->end - 1) {\n\t\t\tunsigned long hva_start, hva_end;\n\n\t\t\tslot = container_of(node, struct kvm_memory_slot, hva_node[slots->node_idx]);\n\t\t\thva_start = max(range->start, slot->userspace_addr);\n\t\t\thva_end = min(range->end, slot->userspace_addr +\n\t\t\t\t\t\t  (slot->npages << PAGE_SHIFT));\n\n\t\t\t/*\n\t\t\t * To optimize for the likely case where the address\n\t\t\t * range is covered by zero or one memslots, don't\n\t\t\t * bother making these conditional (to avoid writes on\n\t\t\t * the second or later invocation of the handler).\n\t\t\t */\n\t\t\tgfn_range.pte = range->pte;\n\t\t\tgfn_range.may_block = range->may_block;\n\n\t\t\t/*\n\t\t\t * {gfn(page) | page intersects with [hva_start, hva_end)} =\n\t\t\t * {gfn_start, gfn_start+1, ..., gfn_end-1}.\n\t\t\t */\n\t\t\tgfn_range.start = hva_to_gfn_memslot(hva_start, slot);\n\t\t\tgfn_range.end = hva_to_gfn_memslot(hva_end + PAGE_SIZE - 1, slot);\n\t\t\tgfn_range.slot = slot;\n\n\t\t\tif (!locked) {\n\t\t\t\tlocked = true;\n\t\t\t\tKVM_MMU_LOCK(kvm);\n\t\t\t\tif (!IS_KVM_NULL_FN(range->on_lock))\n\t\t\t\t\trange->on_lock(kvm, range->start, range->end);\n\t\t\t\tif (IS_KVM_NULL_FN(range->handler))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret |= range->handler(kvm, &gfn_range);\n\t\t}\n\t}\n\n\tif (range->flush_on_ret && ret)\n\t\tkvm_flush_remote_tlbs(kvm);\n\n\tif (locked)\n\t\tKVM_MMU_UNLOCK(kvm);\n\n\tsrcu_read_unlock(&kvm->srcu, idx);\n\n\t/* The notifiers are averse to booleans. :-( */\n\treturn (int)ret;\n}\n\nstatic __always_inline int kvm_handle_hva_range(struct mmu_notifier *mn,\n\t\t\t\t\t\tunsigned long start,\n\t\t\t\t\t\tunsigned long end,\n\t\t\t\t\t\tpte_t pte,\n\t\t\t\t\t\thva_handler_t handler)\n{\n\tstruct kvm *kvm = mmu_notifier_to_kvm(mn);\n\tconst struct kvm_hva_range range = {\n\t\t.start\t\t= start,\n\t\t.end\t\t= end,\n\t\t.pte\t\t= pte,\n\t\t.handler\t= handler,\n\t\t.on_lock\t= (void *)kvm_null_fn,\n\t\t.flush_on_ret\t= true,\n\t\t.may_block\t= false,\n\t};\n\n\treturn __kvm_handle_hva_range(kvm, &range);\n}\n\nstatic __always_inline int kvm_handle_hva_range_no_flush(struct mmu_notifier *mn,\n\t\t\t\t\t\t\t unsigned long start,\n\t\t\t\t\t\t\t unsigned long end,\n\t\t\t\t\t\t\t hva_handler_t handler)\n{\n\tstruct kvm *kvm = mmu_notifier_to_kvm(mn);\n\tconst struct kvm_hva_range range = {\n\t\t.start\t\t= start,\n\t\t.end\t\t= end,\n\t\t.pte\t\t= __pte(0),\n\t\t.handler\t= handler,\n\t\t.on_lock\t= (void *)kvm_null_fn,\n\t\t.flush_on_ret\t= false,\n\t\t.may_block\t= false,\n\t};\n\n\treturn __kvm_handle_hva_range(kvm, &range);\n}\nstatic void kvm_mmu_notifier_change_pte(struct mmu_notifier *mn,\n\t\t\t\t\tstruct mm_struct *mm,\n\t\t\t\t\tunsigned long address,\n\t\t\t\t\tpte_t pte)\n{\n\tstruct kvm *kvm = mmu_notifier_to_kvm(mn);\n\n\ttrace_kvm_set_spte_hva(address);\n\n\t/*\n\t * .change_pte() must be surrounded by .invalidate_range_{start,end}().\n\t * If mmu_notifier_count is zero, then no in-progress invalidations,\n\t * including this one, found a relevant memslot at start(); rechecking\n\t * memslots here is unnecessary.  Note, a false positive (count elevated\n\t * by a different invalidation) is sub-optimal but functionally ok.\n\t */\n\tWARN_ON_ONCE(!READ_ONCE(kvm->mn_active_invalidate_count));\n\tif (!READ_ONCE(kvm->mmu_notifier_count))\n\t\treturn;\n\n\tkvm_handle_hva_range(mn, address, address + 1, pte, kvm_set_spte_gfn);\n}\n\nvoid kvm_inc_notifier_count(struct kvm *kvm, unsigned long start,\n\t\t\t\t   unsigned long end)\n{\n\t/*\n\t * The count increase must become visible at unlock time as no\n\t * spte can be established without taking the mmu_lock and\n\t * count is also read inside the mmu_lock critical section.\n\t */\n\tkvm->mmu_notifier_count++;\n\tif (likely(kvm->mmu_notifier_count == 1)) {\n\t\tkvm->mmu_notifier_range_start = start;\n\t\tkvm->mmu_notifier_range_end = end;\n\t} else {\n\t\t/*\n\t\t * Fully tracking multiple concurrent ranges has dimishing\n\t\t * returns. Keep things simple and just find the minimal range\n\t\t * which includes the current and new ranges. As there won't be\n\t\t * enough information to subtract a range after its invalidate\n\t\t * completes, any ranges invalidated concurrently will\n\t\t * accumulate and persist until all outstanding invalidates\n\t\t * complete.\n\t\t */\n\t\tkvm->mmu_notifier_range_start =\n\t\t\tmin(kvm->mmu_notifier_range_start, start);\n\t\tkvm->mmu_notifier_range_end =\n\t\t\tmax(kvm->mmu_notifier_range_end, end);\n\t}\n}\n\nstatic int kvm_mmu_notifier_invalidate_range_start(struct mmu_notifier *mn,\n\t\t\t\t\tconst struct mmu_notifier_range *range)\n{\n\tstruct kvm *kvm = mmu_notifier_to_kvm(mn);\n\tconst struct kvm_hva_range hva_range = {\n\t\t.start\t\t= range->start,\n\t\t.end\t\t= range->end,\n\t\t.pte\t\t= __pte(0),\n\t\t.handler\t= kvm_unmap_gfn_range,\n\t\t.on_lock\t= kvm_inc_notifier_count,\n\t\t.flush_on_ret\t= true,\n\t\t.may_block\t= mmu_notifier_range_blockable(range),\n\t};\n\n\ttrace_kvm_unmap_hva_range(range->start, range->end);\n\n\t/*\n\t * Prevent memslot modification between range_start() and range_end()\n\t * so that conditionally locking provides the same result in both\n\t * functions.  Without that guarantee, the mmu_notifier_count\n\t * adjustments will be imbalanced.\n\t *\n\t * Pairs with the decrement in range_end().\n\t */\n\tspin_lock(&kvm->mn_invalidate_lock);\n\tkvm->mn_active_invalidate_count++;\n\tspin_unlock(&kvm->mn_invalidate_lock);\n\n\tgfn_to_pfn_cache_invalidate_start(kvm, range->start, range->end,\n\t\t\t\t\t  hva_range.may_block);\n\n\t__kvm_handle_hva_range(kvm, &hva_range);\n\n\treturn 0;\n}\n\nvoid kvm_dec_notifier_count(struct kvm *kvm, unsigned long start,\n\t\t\t\t   unsigned long end)\n{\n\t/*\n\t * This sequence increase will notify the kvm page fault that\n\t * the page that is going to be mapped in the spte could have\n\t * been freed.\n\t */\n\tkvm->mmu_notifier_seq++;\n\tsmp_wmb();\n\t/*\n\t * The above sequence increase must be visible before the\n\t * below count decrease, which is ensured by the smp_wmb above\n\t * in conjunction with the smp_rmb in mmu_notifier_retry().\n\t */\n\tkvm->mmu_notifier_count--;\n}\n\nstatic void kvm_mmu_notifier_invalidate_range_end(struct mmu_notifier *mn,\n\t\t\t\t\tconst struct mmu_notifier_range *range)\n{\n\tstruct kvm *kvm = mmu_notifier_to_kvm(mn);\n\tconst struct kvm_hva_range hva_range = {\n\t\t.start\t\t= range->start,\n\t\t.end\t\t= range->end,\n\t\t.pte\t\t= __pte(0),\n\t\t.handler\t= (void *)kvm_null_fn,\n\t\t.on_lock\t= kvm_dec_notifier_count,\n\t\t.flush_on_ret\t= false,\n\t\t.may_block\t= mmu_notifier_range_blockable(range),\n\t};\n\tbool wake;\n\n\t__kvm_handle_hva_range(kvm, &hva_range);\n\n\t/* Pairs with the increment in range_start(). */\n\tspin_lock(&kvm->mn_invalidate_lock);\n\twake = (--kvm->mn_active_invalidate_count == 0);\n\tspin_unlock(&kvm->mn_invalidate_lock);\n\n\t/*\n\t * There can only be one waiter, since the wait happens under\n\t * slots_lock.\n\t */\n\tif (wake)\n\t\trcuwait_wake_up(&kvm->mn_memslots_update_rcuwait);\n\n\tBUG_ON(kvm->mmu_notifier_count < 0);\n}\n\nstatic int kvm_mmu_notifier_clear_flush_young(struct mmu_notifier *mn,\n\t\t\t\t\t      struct mm_struct *mm,\n\t\t\t\t\t      unsigned long start,\n\t\t\t\t\t      unsigned long end)\n{\n\ttrace_kvm_age_hva(start, end);\n\n\treturn kvm_handle_hva_range(mn, start, end, __pte(0), kvm_age_gfn);\n}\n\nstatic int kvm_mmu_notifier_clear_young(struct mmu_notifier *mn,\n\t\t\t\t\tstruct mm_struct *mm,\n\t\t\t\t\tunsigned long start,\n\t\t\t\t\tunsigned long end)\n{\n\ttrace_kvm_age_hva(start, end);\n\n\t/*\n\t * Even though we do not flush TLB, this will still adversely\n\t * affect performance on pre-Haswell Intel EPT, where there is\n\t * no EPT Access Bit to clear so that we have to tear down EPT\n\t * tables instead. If we find this unacceptable, we can always\n\t * add a parameter to kvm_age_hva so that it effectively doesn't\n\t * do anything on clear_young.\n\t *\n\t * Also note that currently we never issue secondary TLB flushes\n\t * from clear_young, leaving this job up to the regular system\n\t * cadence. If we find this inaccurate, we might come up with a\n\t * more sophisticated heuristic later.\n\t */\n\treturn kvm_handle_hva_range_no_flush(mn, start, end, kvm_age_gfn);\n}\n\nstatic int kvm_mmu_notifier_test_young(struct mmu_notifier *mn,\n\t\t\t\t       struct mm_struct *mm,\n\t\t\t\t       unsigned long address)\n{\n\ttrace_kvm_test_age_hva(address);\n\n\treturn kvm_handle_hva_range_no_flush(mn, address, address + 1,\n\t\t\t\t\t     kvm_test_age_gfn);\n}\n\nstatic void kvm_mmu_notifier_release(struct mmu_notifier *mn,\n\t\t\t\t     struct mm_struct *mm)\n{\n\tstruct kvm *kvm = mmu_notifier_to_kvm(mn);\n\tint idx;\n\n\tidx = srcu_read_lock(&kvm->srcu);\n\tkvm_arch_flush_shadow_all(kvm);\n\tsrcu_read_unlock(&kvm->srcu, idx);\n}\n\nstatic const struct mmu_notifier_ops kvm_mmu_notifier_ops = {\n\t.invalidate_range\t= kvm_mmu_notifier_invalidate_range,\n\t.invalidate_range_start\t= kvm_mmu_notifier_invalidate_range_start,\n\t.invalidate_range_end\t= kvm_mmu_notifier_invalidate_range_end,\n\t.clear_flush_young\t= kvm_mmu_notifier_clear_flush_young,\n\t.clear_young\t\t= kvm_mmu_notifier_clear_young,\n\t.test_young\t\t= kvm_mmu_notifier_test_young,\n\t.change_pte\t\t= kvm_mmu_notifier_change_pte,\n\t.release\t\t= kvm_mmu_notifier_release,\n};\n\nstatic int kvm_init_mmu_notifier(struct kvm *kvm)\n{\n\tkvm->mmu_notifier.ops = &kvm_mmu_notifier_ops;\n\treturn mmu_notifier_register(&kvm->mmu_notifier, current->mm);\n}\n\n#else  /* !(CONFIG_MMU_NOTIFIER && KVM_ARCH_WANT_MMU_NOTIFIER) */\n\nstatic int kvm_init_mmu_notifier(struct kvm *kvm)\n{\n\treturn 0;\n}\n\n#endif /* CONFIG_MMU_NOTIFIER && KVM_ARCH_WANT_MMU_NOTIFIER */\n\n#ifdef CONFIG_HAVE_KVM_PM_NOTIFIER\nstatic int kvm_pm_notifier_call(struct notifier_block *bl,\n\t\t\t\tunsigned long state,\n\t\t\t\tvoid *unused)\n{\n\tstruct kvm *kvm = container_of(bl, struct kvm, pm_notifier);\n\n\treturn kvm_arch_pm_notifier(kvm, state);\n}\n\nstatic void kvm_init_pm_notifier(struct kvm *kvm)\n{\n\tkvm->pm_notifier.notifier_call = kvm_pm_notifier_call;\n\t/* Suspend KVM before we suspend ftrace, RCU, etc. */\n\tkvm->pm_notifier.priority = INT_MAX;\n\tregister_pm_notifier(&kvm->pm_notifier);\n}\n\nstatic void kvm_destroy_pm_notifier(struct kvm *kvm)\n{\n\tunregister_pm_notifier(&kvm->pm_notifier);\n}\n#else /* !CONFIG_HAVE_KVM_PM_NOTIFIER */\nstatic void kvm_init_pm_notifier(struct kvm *kvm)\n{\n}\n\nstatic void kvm_destroy_pm_notifier(struct kvm *kvm)\n{\n}\n#endif /* CONFIG_HAVE_KVM_PM_NOTIFIER */\n\nstatic void kvm_destroy_dirty_bitmap(struct kvm_memory_slot *memslot)\n{\n\tif (!memslot->dirty_bitmap)\n\t\treturn;\n\n\tkvfree(memslot->dirty_bitmap);\n\tmemslot->dirty_bitmap = NULL;\n}\n\n/* This does not remove the slot from struct kvm_memslots data structures */\nstatic void kvm_free_memslot(struct kvm *kvm, struct kvm_memory_slot *slot)\n{\n\tkvm_destroy_dirty_bitmap(slot);\n\n\tkvm_arch_free_memslot(kvm, slot);\n\n\tkfree(slot);\n}\n\nstatic void kvm_free_memslots(struct kvm *kvm, struct kvm_memslots *slots)\n{\n\tstruct hlist_node *idnode;\n\tstruct kvm_memory_slot *memslot;\n\tint bkt;\n\n\t/*\n\t * The same memslot objects live in both active and inactive sets,\n\t * arbitrarily free using index '1' so the second invocation of this\n\t * function isn't operating over a structure with dangling pointers\n\t * (even though this function isn't actually touching them).\n\t */\n\tif (!slots->node_idx)\n\t\treturn;\n\n\thash_for_each_safe(slots->id_hash, bkt, idnode, memslot, id_node[1])\n\t\tkvm_free_memslot(kvm, memslot);\n}\n\nstatic umode_t kvm_stats_debugfs_mode(const struct _kvm_stats_desc *pdesc)\n{\n\tswitch (pdesc->desc.flags & KVM_STATS_TYPE_MASK) {\n\tcase KVM_STATS_TYPE_INSTANT:\n\t\treturn 0444;\n\tcase KVM_STATS_TYPE_CUMULATIVE:\n\tcase KVM_STATS_TYPE_PEAK:\n\tdefault:\n\t\treturn 0644;\n\t}\n}\n\n\nstatic void kvm_destroy_vm_debugfs(struct kvm *kvm)\n{\n\tint i;\n\tint kvm_debugfs_num_entries = kvm_vm_stats_header.num_desc +\n\t\t\t\t      kvm_vcpu_stats_header.num_desc;\n\n\tif (!kvm->debugfs_dentry)\n\t\treturn;\n\n\tdebugfs_remove_recursive(kvm->debugfs_dentry);\n\n\tif (kvm->debugfs_stat_data) {\n\t\tfor (i = 0; i < kvm_debugfs_num_entries; i++)\n\t\t\tkfree(kvm->debugfs_stat_data[i]);\n\t\tkfree(kvm->debugfs_stat_data);\n\t}\n}\n\nstatic int kvm_create_vm_debugfs(struct kvm *kvm, int fd)\n{\n\tstatic DEFINE_MUTEX(kvm_debugfs_lock);\n\tstruct dentry *dent;\n\tchar dir_name[ITOA_MAX_LEN * 2];\n\tstruct kvm_stat_data *stat_data;\n\tconst struct _kvm_stats_desc *pdesc;\n\tint i, ret;\n\tint kvm_debugfs_num_entries = kvm_vm_stats_header.num_desc +\n\t\t\t\t      kvm_vcpu_stats_header.num_desc;\n\n\tif (!debugfs_initialized())\n\t\treturn 0;\n\n\tsnprintf(dir_name, sizeof(dir_name), \"%d-%d\", task_pid_nr(current), fd);\n\tmutex_lock(&kvm_debugfs_lock);\n\tdent = debugfs_lookup(dir_name, kvm_debugfs_dir);\n\tif (dent) {\n\t\tpr_warn_ratelimited(\"KVM: debugfs: duplicate directory %s\\n\", dir_name);\n\t\tdput(dent);\n\t\tmutex_unlock(&kvm_debugfs_lock);\n\t\treturn 0;\n\t}\n\tdent = debugfs_create_dir(dir_name, kvm_debugfs_dir);\n\tmutex_unlock(&kvm_debugfs_lock);\n\tif (IS_ERR(dent))\n\t\treturn 0;\n\n\tkvm->debugfs_dentry = dent;\n\tkvm->debugfs_stat_data = kcalloc(kvm_debugfs_num_entries,\n\t\t\t\t\t sizeof(*kvm->debugfs_stat_data),\n\t\t\t\t\t GFP_KERNEL_ACCOUNT);\n\tif (!kvm->debugfs_stat_data)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < kvm_vm_stats_header.num_desc; ++i) {\n\t\tpdesc = &kvm_vm_stats_desc[i];\n\t\tstat_data = kzalloc(sizeof(*stat_data), GFP_KERNEL_ACCOUNT);\n\t\tif (!stat_data)\n\t\t\treturn -ENOMEM;\n\n\t\tstat_data->kvm = kvm;\n\t\tstat_data->desc = pdesc;\n\t\tstat_data->kind = KVM_STAT_VM;\n\t\tkvm->debugfs_stat_data[i] = stat_data;\n\t\tdebugfs_create_file(pdesc->name, kvm_stats_debugfs_mode(pdesc),\n\t\t\t\t    kvm->debugfs_dentry, stat_data,\n\t\t\t\t    &stat_fops_per_vm);\n\t}\n\n\tfor (i = 0; i < kvm_vcpu_stats_header.num_desc; ++i) {\n\t\tpdesc = &kvm_vcpu_stats_desc[i];\n\t\tstat_data = kzalloc(sizeof(*stat_data), GFP_KERNEL_ACCOUNT);\n\t\tif (!stat_data)\n\t\t\treturn -ENOMEM;\n\n\t\tstat_data->kvm = kvm;\n\t\tstat_data->desc = pdesc;\n\t\tstat_data->kind = KVM_STAT_VCPU;\n\t\tkvm->debugfs_stat_data[i + kvm_vm_stats_header.num_desc] = stat_data;\n\t\tdebugfs_create_file(pdesc->name, kvm_stats_debugfs_mode(pdesc),\n\t\t\t\t    kvm->debugfs_dentry, stat_data,\n\t\t\t\t    &stat_fops_per_vm);\n\t}\n\n\tret = kvm_arch_create_vm_debugfs(kvm);\n\tif (ret) {\n\t\tkvm_destroy_vm_debugfs(kvm);\n\t\treturn i;\n\t}\n\n\treturn 0;\n}\n\n/*\n * Called after the VM is otherwise initialized, but just before adding it to\n * the vm_list.\n */\nint __weak kvm_arch_post_init_vm(struct kvm *kvm)\n{\n\treturn 0;\n}\n\n/*\n * Called just after removing the VM from the vm_list, but before doing any\n * other destruction.\n */\nvoid __weak kvm_arch_pre_destroy_vm(struct kvm *kvm)\n{\n}\n\n/*\n * Called after per-vm debugfs created.  When called kvm->debugfs_dentry should\n * be setup already, so we can create arch-specific debugfs entries under it.\n * Cleanup should be automatic done in kvm_destroy_vm_debugfs() recursively, so\n * a per-arch destroy interface is not needed.\n */\nint __weak kvm_arch_create_vm_debugfs(struct kvm *kvm)\n{\n\treturn 0;\n}\n\nstatic struct kvm *kvm_create_vm(unsigned long type)\n{\n\tstruct kvm *kvm = kvm_arch_alloc_vm();\n\tstruct kvm_memslots *slots;\n\tint r = -ENOMEM;\n\tint i, j;\n\n\tif (!kvm)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tKVM_MMU_LOCK_INIT(kvm);\n\tmmgrab(current->mm);\n\tkvm->mm = current->mm;\n\tkvm_eventfd_init(kvm);\n\tmutex_init(&kvm->lock);\n\tmutex_init(&kvm->irq_lock);\n\tmutex_init(&kvm->slots_lock);\n\tmutex_init(&kvm->slots_arch_lock);\n\tspin_lock_init(&kvm->mn_invalidate_lock);\n\trcuwait_init(&kvm->mn_memslots_update_rcuwait);\n\txa_init(&kvm->vcpu_array);\n\n\tINIT_LIST_HEAD(&kvm->gpc_list);\n\tspin_lock_init(&kvm->gpc_lock);\n\n\tINIT_LIST_HEAD(&kvm->devices);\n\n\tBUILD_BUG_ON(KVM_MEM_SLOTS_NUM > SHRT_MAX);\n\n\tif (init_srcu_struct(&kvm->srcu))\n\t\tgoto out_err_no_srcu;\n\tif (init_srcu_struct(&kvm->irq_srcu))\n\t\tgoto out_err_no_irq_srcu;\n\n\trefcount_set(&kvm->users_count, 1);\n\tfor (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {\n\t\tfor (j = 0; j < 2; j++) {\n\t\t\tslots = &kvm->__memslots[i][j];\n\n\t\t\tatomic_long_set(&slots->last_used_slot, (unsigned long)NULL);\n\t\t\tslots->hva_tree = RB_ROOT_CACHED;\n\t\t\tslots->gfn_tree = RB_ROOT;\n\t\t\thash_init(slots->id_hash);\n\t\t\tslots->node_idx = j;\n\n\t\t\t/* Generations must be different for each address space. */\n\t\t\tslots->generation = i;\n\t\t}\n\n\t\trcu_assign_pointer(kvm->memslots[i], &kvm->__memslots[i][0]);\n\t}\n\n\tfor (i = 0; i < KVM_NR_BUSES; i++) {\n\t\trcu_assign_pointer(kvm->buses[i],\n\t\t\tkzalloc(sizeof(struct kvm_io_bus), GFP_KERNEL_ACCOUNT));\n\t\tif (!kvm->buses[i])\n\t\t\tgoto out_err_no_arch_destroy_vm;\n\t}\n\n\tkvm->max_halt_poll_ns = halt_poll_ns;\n\n\tr = kvm_arch_init_vm(kvm, type);\n\tif (r)\n\t\tgoto out_err_no_arch_destroy_vm;\n\n\tr = hardware_enable_all();\n\tif (r)\n\t\tgoto out_err_no_disable;\n\n#ifdef CONFIG_HAVE_KVM_IRQFD\n\tINIT_HLIST_HEAD(&kvm->irq_ack_notifier_list);\n#endif\n\n\tr = kvm_init_mmu_notifier(kvm);\n\tif (r)\n\t\tgoto out_err_no_mmu_notifier;\n\n\tr = kvm_arch_post_init_vm(kvm);\n\tif (r)\n\t\tgoto out_err;\n\n\tmutex_lock(&kvm_lock);\n\tlist_add(&kvm->vm_list, &vm_list);\n\tmutex_unlock(&kvm_lock);\n\n\tpreempt_notifier_inc();\n\tkvm_init_pm_notifier(kvm);\n\n\t/*\n\t * When the fd passed to this ioctl() is opened it pins the module,\n\t * but try_module_get() also prevents getting a reference if the module\n\t * is in MODULE_STATE_GOING (e.g. if someone ran \"rmmod --wait\").\n\t */\n\tif (!try_module_get(kvm_chardev_ops.owner)) {\n\t\tr = -ENODEV;\n\t\tgoto out_err;\n\t}\n\n\treturn kvm;\n\nout_err:\n#if defined(CONFIG_MMU_NOTIFIER) && defined(KVM_ARCH_WANT_MMU_NOTIFIER)\n\tif (kvm->mmu_notifier.ops)\n\t\tmmu_notifier_unregister(&kvm->mmu_notifier, current->mm);\n#endif\nout_err_no_mmu_notifier:\n\thardware_disable_all();\nout_err_no_disable:\n\tkvm_arch_destroy_vm(kvm);\nout_err_no_arch_destroy_vm:\n\tWARN_ON_ONCE(!refcount_dec_and_test(&kvm->users_count));\n\tfor (i = 0; i < KVM_NR_BUSES; i++)\n\t\tkfree(kvm_get_bus(kvm, i));\n\tcleanup_srcu_struct(&kvm->irq_srcu);\nout_err_no_irq_srcu:\n\tcleanup_srcu_struct(&kvm->srcu);\nout_err_no_srcu:\n\tkvm_arch_free_vm(kvm);\n\tmmdrop(current->mm);\n\treturn ERR_PTR(r);\n}\n\nstatic void kvm_destroy_devices(struct kvm *kvm)\n{\n\tstruct kvm_device *dev, *tmp;\n\n\t/*\n\t * We do not need to take the kvm->lock here, because nobody else\n\t * has a reference to the struct kvm at this point and therefore\n\t * cannot access the devices list anyhow.\n\t */\n\tlist_for_each_entry_safe(dev, tmp, &kvm->devices, vm_node) {\n\t\tlist_del(&dev->vm_node);\n\t\tdev->ops->destroy(dev);\n\t}\n}\n\nstatic void kvm_destroy_vm(struct kvm *kvm)\n{\n\tint i;\n\tstruct mm_struct *mm = kvm->mm;\n\n\tkvm_destroy_pm_notifier(kvm);\n\tkvm_uevent_notify_change(KVM_EVENT_DESTROY_VM, kvm);\n\tkvm_destroy_vm_debugfs(kvm);\n\tkvm_arch_sync_events(kvm);\n\tmutex_lock(&kvm_lock);\n\tlist_del(&kvm->vm_list);\n\tmutex_unlock(&kvm_lock);\n\tkvm_arch_pre_destroy_vm(kvm);\n\n\tkvm_free_irq_routing(kvm);\n\tfor (i = 0; i < KVM_NR_BUSES; i++) {\n\t\tstruct kvm_io_bus *bus = kvm_get_bus(kvm, i);\n\n\t\tif (bus)\n\t\t\tkvm_io_bus_destroy(bus);\n\t\tkvm->buses[i] = NULL;\n\t}\n\tkvm_coalesced_mmio_free(kvm);\n#if defined(CONFIG_MMU_NOTIFIER) && defined(KVM_ARCH_WANT_MMU_NOTIFIER)\n\tmmu_notifier_unregister(&kvm->mmu_notifier, kvm->mm);\n\t/*\n\t * At this point, pending calls to invalidate_range_start()\n\t * have completed but no more MMU notifiers will run, so\n\t * mn_active_invalidate_count may remain unbalanced.\n\t * No threads can be waiting in install_new_memslots as the\n\t * last reference on KVM has been dropped, but freeing\n\t * memslots would deadlock without this manual intervention.\n\t */\n\tWARN_ON(rcuwait_active(&kvm->mn_memslots_update_rcuwait));\n\tkvm->mn_active_invalidate_count = 0;\n#else\n\tkvm_arch_flush_shadow_all(kvm);\n#endif\n\tkvm_arch_destroy_vm(kvm);\n\tkvm_destroy_devices(kvm);\n\tfor (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {\n\t\tkvm_free_memslots(kvm, &kvm->__memslots[i][0]);\n\t\tkvm_free_memslots(kvm, &kvm->__memslots[i][1]);\n\t}\n\tcleanup_srcu_struct(&kvm->irq_srcu);\n\tcleanup_srcu_struct(&kvm->srcu);\n\tkvm_arch_free_vm(kvm);\n\tpreempt_notifier_dec();\n\thardware_disable_all();\n\tmmdrop(mm);\n\tmodule_put(kvm_chardev_ops.owner);\n}\n\nvoid kvm_get_kvm(struct kvm *kvm)\n{\n\trefcount_inc(&kvm->users_count);\n}\nEXPORT_SYMBOL_GPL(kvm_get_kvm);\n\n/*\n * Make sure the vm is not during destruction, which is a safe version of\n * kvm_get_kvm().  Return true if kvm referenced successfully, false otherwise.\n */\nbool kvm_get_kvm_safe(struct kvm *kvm)\n{\n\treturn refcount_inc_not_zero(&kvm->users_count);\n}\nEXPORT_SYMBOL_GPL(kvm_get_kvm_safe);\n\nvoid kvm_put_kvm(struct kvm *kvm)\n{\n\tif (refcount_dec_and_test(&kvm->users_count))\n\t\tkvm_destroy_vm(kvm);\n}\nEXPORT_SYMBOL_GPL(kvm_put_kvm);\n\n/*\n * Used to put a reference that was taken on behalf of an object associated\n * with a user-visible file descriptor, e.g. a vcpu or device, if installation\n * of the new file descriptor fails and the reference cannot be transferred to\n * its final owner.  In such cases, the caller is still actively using @kvm and\n * will fail miserably if the refcount unexpectedly hits zero.\n */\nvoid kvm_put_kvm_no_destroy(struct kvm *kvm)\n{\n\tWARN_ON(refcount_dec_and_test(&kvm->users_count));\n}\nEXPORT_SYMBOL_GPL(kvm_put_kvm_no_destroy);\n\nstatic int kvm_vm_release(struct inode *inode, struct file *filp)\n{\n\tstruct kvm *kvm = filp->private_data;\n\n\tkvm_irqfd_release(kvm);\n\n\tkvm_put_kvm(kvm);\n\treturn 0;\n}\n\n/*\n * Allocation size is twice as large as the actual dirty bitmap size.\n * See kvm_vm_ioctl_get_dirty_log() why this is needed.\n */\nstatic int kvm_alloc_dirty_bitmap(struct kvm_memory_slot *memslot)\n{\n\tunsigned long dirty_bytes = kvm_dirty_bitmap_bytes(memslot);\n\n\tmemslot->dirty_bitmap = __vcalloc(2, dirty_bytes, GFP_KERNEL_ACCOUNT);\n\tif (!memslot->dirty_bitmap)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic struct kvm_memslots *kvm_get_inactive_memslots(struct kvm *kvm, int as_id)\n{\n\tstruct kvm_memslots *active = __kvm_memslots(kvm, as_id);\n\tint node_idx_inactive = active->node_idx ^ 1;\n\n\treturn &kvm->__memslots[as_id][node_idx_inactive];\n}\n\n/*\n * Helper to get the address space ID when one of memslot pointers may be NULL.\n * This also serves as a sanity that at least one of the pointers is non-NULL,\n * and that their address space IDs don't diverge.\n */\nstatic int kvm_memslots_get_as_id(struct kvm_memory_slot *a,\n\t\t\t\t  struct kvm_memory_slot *b)\n{\n\tif (WARN_ON_ONCE(!a && !b))\n\t\treturn 0;\n\n\tif (!a)\n\t\treturn b->as_id;\n\tif (!b)\n\t\treturn a->as_id;\n\n\tWARN_ON_ONCE(a->as_id != b->as_id);\n\treturn a->as_id;\n}\n\nstatic void kvm_insert_gfn_node(struct kvm_memslots *slots,\n\t\t\t\tstruct kvm_memory_slot *slot)\n{\n\tstruct rb_root *gfn_tree = &slots->gfn_tree;\n\tstruct rb_node **node, *parent;\n\tint idx = slots->node_idx;\n\n\tparent = NULL;\n\tfor (node = &gfn_tree->rb_node; *node; ) {\n\t\tstruct kvm_memory_slot *tmp;\n\n\t\ttmp = container_of(*node, struct kvm_memory_slot, gfn_node[idx]);\n\t\tparent = *node;\n\t\tif (slot->base_gfn < tmp->base_gfn)\n\t\t\tnode = &(*node)->rb_left;\n\t\telse if (slot->base_gfn > tmp->base_gfn)\n\t\t\tnode = &(*node)->rb_right;\n\t\telse\n\t\t\tBUG();\n\t}\n\n\trb_link_node(&slot->gfn_node[idx], parent, node);\n\trb_insert_color(&slot->gfn_node[idx], gfn_tree);\n}\n\nstatic void kvm_erase_gfn_node(struct kvm_memslots *slots,\n\t\t\t       struct kvm_memory_slot *slot)\n{\n\trb_erase(&slot->gfn_node[slots->node_idx], &slots->gfn_tree);\n}\n\nstatic void kvm_replace_gfn_node(struct kvm_memslots *slots,\n\t\t\t\t struct kvm_memory_slot *old,\n\t\t\t\t struct kvm_memory_slot *new)\n{\n\tint idx = slots->node_idx;\n\n\tWARN_ON_ONCE(old->base_gfn != new->base_gfn);\n\n\trb_replace_node(&old->gfn_node[idx], &new->gfn_node[idx],\n\t\t\t&slots->gfn_tree);\n}\n\n/*\n * Replace @old with @new in the inactive memslots.\n *\n * With NULL @old this simply adds @new.\n * With NULL @new this simply removes @old.\n *\n * If @new is non-NULL its hva_node[slots_idx] range has to be set\n * appropriately.\n */\nstatic void kvm_replace_memslot(struct kvm *kvm,\n\t\t\t\tstruct kvm_memory_slot *old,\n\t\t\t\tstruct kvm_memory_slot *new)\n{\n\tint as_id = kvm_memslots_get_as_id(old, new);\n\tstruct kvm_memslots *slots = kvm_get_inactive_memslots(kvm, as_id);\n\tint idx = slots->node_idx;\n\n\tif (old) {\n\t\thash_del(&old->id_node[idx]);\n\t\tinterval_tree_remove(&old->hva_node[idx], &slots->hva_tree);\n\n\t\tif ((long)old == atomic_long_read(&slots->last_used_slot))\n\t\t\tatomic_long_set(&slots->last_used_slot, (long)new);\n\n\t\tif (!new) {\n\t\t\tkvm_erase_gfn_node(slots, old);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Initialize @new's hva range.  Do this even when replacing an @old\n\t * slot, kvm_copy_memslot() deliberately does not touch node data.\n\t */\n\tnew->hva_node[idx].start = new->userspace_addr;\n\tnew->hva_node[idx].last = new->userspace_addr +\n\t\t\t\t  (new->npages << PAGE_SHIFT) - 1;\n\n\t/*\n\t * (Re)Add the new memslot.  There is no O(1) interval_tree_replace(),\n\t * hva_node needs to be swapped with remove+insert even though hva can't\n\t * change when replacing an existing slot.\n\t */\n\thash_add(slots->id_hash, &new->id_node[idx], new->id);\n\tinterval_tree_insert(&new->hva_node[idx], &slots->hva_tree);\n\n\t/*\n\t * If the memslot gfn is unchanged, rb_replace_node() can be used to\n\t * switch the node in the gfn tree instead of removing the old and\n\t * inserting the new as two separate operations. Replacement is a\n\t * single O(1) operation versus two O(log(n)) operations for\n\t * remove+insert.\n\t */\n\tif (old && old->base_gfn == new->base_gfn) {\n\t\tkvm_replace_gfn_node(slots, old, new);\n\t} else {\n\t\tif (old)\n\t\t\tkvm_erase_gfn_node(slots, old);\n\t\tkvm_insert_gfn_node(slots, new);\n\t}\n}\n\nstatic int check_memory_region_flags(const struct kvm_userspace_memory_region *mem)\n{\n\tu32 valid_flags = KVM_MEM_LOG_DIRTY_PAGES;\n\n#ifdef __KVM_HAVE_READONLY_MEM\n\tvalid_flags |= KVM_MEM_READONLY;\n#endif\n\n\tif (mem->flags & ~valid_flags)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void kvm_swap_active_memslots(struct kvm *kvm, int as_id)\n{\n\tstruct kvm_memslots *slots = kvm_get_inactive_memslots(kvm, as_id);\n\n\t/* Grab the generation from the activate memslots. */\n\tu64 gen = __kvm_memslots(kvm, as_id)->generation;\n\n\tWARN_ON(gen & KVM_MEMSLOT_GEN_UPDATE_IN_PROGRESS);\n\tslots->generation = gen | KVM_MEMSLOT_GEN_UPDATE_IN_PROGRESS;\n\n\t/*\n\t * Do not store the new memslots while there are invalidations in\n\t * progress, otherwise the locking in invalidate_range_start and\n\t * invalidate_range_end will be unbalanced.\n\t */\n\tspin_lock(&kvm->mn_invalidate_lock);\n\tprepare_to_rcuwait(&kvm->mn_memslots_update_rcuwait);\n\twhile (kvm->mn_active_invalidate_count) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tspin_unlock(&kvm->mn_invalidate_lock);\n\t\tschedule();\n\t\tspin_lock(&kvm->mn_invalidate_lock);\n\t}\n\tfinish_rcuwait(&kvm->mn_memslots_update_rcuwait);\n\trcu_assign_pointer(kvm->memslots[as_id], slots);\n\tspin_unlock(&kvm->mn_invalidate_lock);\n\n\t/*\n\t * Acquired in kvm_set_memslot. Must be released before synchronize\n\t * SRCU below in order to avoid deadlock with another thread\n\t * acquiring the slots_arch_lock in an srcu critical section.\n\t */\n\tmutex_unlock(&kvm->slots_arch_lock);\n\n\tsynchronize_srcu_expedited(&kvm->srcu);\n\n\t/*\n\t * Increment the new memslot generation a second time, dropping the\n\t * update in-progress flag and incrementing the generation based on\n\t * the number of address spaces.  This provides a unique and easily\n\t * identifiable generation number while the memslots are in flux.\n\t */\n\tgen = slots->generation & ~KVM_MEMSLOT_GEN_UPDATE_IN_PROGRESS;\n\n\t/*\n\t * Generations must be unique even across address spaces.  We do not need\n\t * a global counter for that, instead the generation space is evenly split\n\t * across address spaces.  For example, with two address spaces, address\n\t * space 0 will use generations 0, 2, 4, ... while address space 1 will\n\t * use generations 1, 3, 5, ...\n\t */\n\tgen += KVM_ADDRESS_SPACE_NUM;\n\n\tkvm_arch_memslots_updated(kvm, gen);\n\n\tslots->generation = gen;\n}\n\nstatic int kvm_prepare_memory_region(struct kvm *kvm,\n\t\t\t\t     const struct kvm_memory_slot *old,\n\t\t\t\t     struct kvm_memory_slot *new,\n\t\t\t\t     enum kvm_mr_change change)\n{\n\tint r;\n\n\t/*\n\t * If dirty logging is disabled, nullify the bitmap; the old bitmap\n\t * will be freed on \"commit\".  If logging is enabled in both old and\n\t * new, reuse the existing bitmap.  If logging is enabled only in the\n\t * new and KVM isn't using a ring buffer, allocate and initialize a\n\t * new bitmap.\n\t */\n\tif (change != KVM_MR_DELETE) {\n\t\tif (!(new->flags & KVM_MEM_LOG_DIRTY_PAGES))\n\t\t\tnew->dirty_bitmap = NULL;\n\t\telse if (old && old->dirty_bitmap)\n\t\t\tnew->dirty_bitmap = old->dirty_bitmap;\n\t\telse if (!kvm->dirty_ring_size) {\n\t\t\tr = kvm_alloc_dirty_bitmap(new);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\n\t\t\tif (kvm_dirty_log_manual_protect_and_init_set(kvm))\n\t\t\t\tbitmap_set(new->dirty_bitmap, 0, new->npages);\n\t\t}\n\t}\n\n\tr = kvm_arch_prepare_memory_region(kvm, old, new, change);\n\n\t/* Free the bitmap on failure if it was allocated above. */\n\tif (r && new && new->dirty_bitmap && old && !old->dirty_bitmap)\n\t\tkvm_destroy_dirty_bitmap(new);\n\n\treturn r;\n}\n\nstatic void kvm_commit_memory_region(struct kvm *kvm,\n\t\t\t\t     struct kvm_memory_slot *old,\n\t\t\t\t     const struct kvm_memory_slot *new,\n\t\t\t\t     enum kvm_mr_change change)\n{\n\t/*\n\t * Update the total number of memslot pages before calling the arch\n\t * hook so that architectures can consume the result directly.\n\t */\n\tif (change == KVM_MR_DELETE)\n\t\tkvm->nr_memslot_pages -= old->npages;\n\telse if (change == KVM_MR_CREATE)\n\t\tkvm->nr_memslot_pages += new->npages;\n\n\tkvm_arch_commit_memory_region(kvm, old, new, change);\n\n\tswitch (change) {\n\tcase KVM_MR_CREATE:\n\t\t/* Nothing more to do. */\n\t\tbreak;\n\tcase KVM_MR_DELETE:\n\t\t/* Free the old memslot and all its metadata. */\n\t\tkvm_free_memslot(kvm, old);\n\t\tbreak;\n\tcase KVM_MR_MOVE:\n\tcase KVM_MR_FLAGS_ONLY:\n\t\t/*\n\t\t * Free the dirty bitmap as needed; the below check encompasses\n\t\t * both the flags and whether a ring buffer is being used)\n\t\t */\n\t\tif (old->dirty_bitmap && !new->dirty_bitmap)\n\t\t\tkvm_destroy_dirty_bitmap(old);\n\n\t\t/*\n\t\t * The final quirk.  Free the detached, old slot, but only its\n\t\t * memory, not any metadata.  Metadata, including arch specific\n\t\t * data, may be reused by @new.\n\t\t */\n\t\tkfree(old);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\n/*\n * Activate @new, which must be installed in the inactive slots by the caller,\n * by swapping the active slots and then propagating @new to @old once @old is\n * unreachable and can be safely modified.\n *\n * With NULL @old this simply adds @new to @active (while swapping the sets).\n * With NULL @new this simply removes @old from @active and frees it\n * (while also swapping the sets).\n */\nstatic void kvm_activate_memslot(struct kvm *kvm,\n\t\t\t\t struct kvm_memory_slot *old,\n\t\t\t\t struct kvm_memory_slot *new)\n{\n\tint as_id = kvm_memslots_get_as_id(old, new);\n\n\tkvm_swap_active_memslots(kvm, as_id);\n\n\t/* Propagate the new memslot to the now inactive memslots. */\n\tkvm_replace_memslot(kvm, old, new);\n}\n\nstatic void kvm_copy_memslot(struct kvm_memory_slot *dest,\n\t\t\t     const struct kvm_memory_slot *src)\n{\n\tdest->base_gfn = src->base_gfn;\n\tdest->npages = src->npages;\n\tdest->dirty_bitmap = src->dirty_bitmap;\n\tdest->arch = src->arch;\n\tdest->userspace_addr = src->userspace_addr;\n\tdest->flags = src->flags;\n\tdest->id = src->id;\n\tdest->as_id = src->as_id;\n}\n\nstatic void kvm_invalidate_memslot(struct kvm *kvm,\n\t\t\t\t   struct kvm_memory_slot *old,\n\t\t\t\t   struct kvm_memory_slot *invalid_slot)\n{\n\t/*\n\t * Mark the current slot INVALID.  As with all memslot modifications,\n\t * this must be done on an unreachable slot to avoid modifying the\n\t * current slot in the active tree.\n\t */\n\tkvm_copy_memslot(invalid_slot, old);\n\tinvalid_slot->flags |= KVM_MEMSLOT_INVALID;\n\tkvm_replace_memslot(kvm, old, invalid_slot);\n\n\t/*\n\t * Activate the slot that is now marked INVALID, but don't propagate\n\t * the slot to the now inactive slots. The slot is either going to be\n\t * deleted or recreated as a new slot.\n\t */\n\tkvm_swap_active_memslots(kvm, old->as_id);\n\n\t/*\n\t * From this point no new shadow pages pointing to a deleted, or moved,\n\t * memslot will be created.  Validation of sp->gfn happens in:\n\t *\t- gfn_to_hva (kvm_read_guest, gfn_to_pfn)\n\t *\t- kvm_is_visible_gfn (mmu_check_root)\n\t */\n\tkvm_arch_flush_shadow_memslot(kvm, old);\n\n\t/* Was released by kvm_swap_active_memslots, reacquire. */\n\tmutex_lock(&kvm->slots_arch_lock);\n\n\t/*\n\t * Copy the arch-specific field of the newly-installed slot back to the\n\t * old slot as the arch data could have changed between releasing\n\t * slots_arch_lock in install_new_memslots() and re-acquiring the lock\n\t * above.  Writers are required to retrieve memslots *after* acquiring\n\t * slots_arch_lock, thus the active slot's data is guaranteed to be fresh.\n\t */\n\told->arch = invalid_slot->arch;\n}\n\nstatic void kvm_create_memslot(struct kvm *kvm,\n\t\t\t       struct kvm_memory_slot *new)\n{\n\t/* Add the new memslot to the inactive set and activate. */\n\tkvm_replace_memslot(kvm, NULL, new);\n\tkvm_activate_memslot(kvm, NULL, new);\n}\n\nstatic void kvm_delete_memslot(struct kvm *kvm,\n\t\t\t       struct kvm_memory_slot *old,\n\t\t\t       struct kvm_memory_slot *invalid_slot)\n{\n\t/*\n\t * Remove the old memslot (in the inactive memslots) by passing NULL as\n\t * the \"new\" slot, and for the invalid version in the active slots.\n\t */\n\tkvm_replace_memslot(kvm, old, NULL);\n\tkvm_activate_memslot(kvm, invalid_slot, NULL);\n}\n\nstatic void kvm_move_memslot(struct kvm *kvm,\n\t\t\t     struct kvm_memory_slot *old,\n\t\t\t     struct kvm_memory_slot *new,\n\t\t\t     struct kvm_memory_slot *invalid_slot)\n{\n\t/*\n\t * Replace the old memslot in the inactive slots, and then swap slots\n\t * and replace the current INVALID with the new as well.\n\t */\n\tkvm_replace_memslot(kvm, old, new);\n\tkvm_activate_memslot(kvm, invalid_slot, new);\n}\n\nstatic void kvm_update_flags_memslot(struct kvm *kvm,\n\t\t\t\t     struct kvm_memory_slot *old,\n\t\t\t\t     struct kvm_memory_slot *new)\n{\n\t/*\n\t * Similar to the MOVE case, but the slot doesn't need to be zapped as\n\t * an intermediate step. Instead, the old memslot is simply replaced\n\t * with a new, updated copy in both memslot sets.\n\t */\n\tkvm_replace_memslot(kvm, old, new);\n\tkvm_activate_memslot(kvm, old, new);\n}\n\nstatic int kvm_set_memslot(struct kvm *kvm,\n\t\t\t   struct kvm_memory_slot *old,\n\t\t\t   struct kvm_memory_slot *new,\n\t\t\t   enum kvm_mr_change change)\n{\n\tstruct kvm_memory_slot *invalid_slot;\n\tint r;\n\n\t/*\n\t * Released in kvm_swap_active_memslots.\n\t *\n\t * Must be held from before the current memslots are copied until\n\t * after the new memslots are installed with rcu_assign_pointer,\n\t * then released before the synchronize srcu in kvm_swap_active_memslots.\n\t *\n\t * When modifying memslots outside of the slots_lock, must be held\n\t * before reading the pointer to the current memslots until after all\n\t * changes to those memslots are complete.\n\t *\n\t * These rules ensure that installing new memslots does not lose\n\t * changes made to the previous memslots.\n\t */\n\tmutex_lock(&kvm->slots_arch_lock);\n\n\t/*\n\t * Invalidate the old slot if it's being deleted or moved.  This is\n\t * done prior to actually deleting/moving the memslot to allow vCPUs to\n\t * continue running by ensuring there are no mappings or shadow pages\n\t * for the memslot when it is deleted/moved.  Without pre-invalidation\n\t * (and without a lock), a window would exist between effecting the\n\t * delete/move and committing the changes in arch code where KVM or a\n\t * guest could access a non-existent memslot.\n\t *\n\t * Modifications are done on a temporary, unreachable slot.  The old\n\t * slot needs to be preserved in case a later step fails and the\n\t * invalidation needs to be reverted.\n\t */\n\tif (change == KVM_MR_DELETE || change == KVM_MR_MOVE) {\n\t\tinvalid_slot = kzalloc(sizeof(*invalid_slot), GFP_KERNEL_ACCOUNT);\n\t\tif (!invalid_slot) {\n\t\t\tmutex_unlock(&kvm->slots_arch_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tkvm_invalidate_memslot(kvm, old, invalid_slot);\n\t}\n\n\tr = kvm_prepare_memory_region(kvm, old, new, change);\n\tif (r) {\n\t\t/*\n\t\t * For DELETE/MOVE, revert the above INVALID change.  No\n\t\t * modifications required since the original slot was preserved\n\t\t * in the inactive slots.  Changing the active memslots also\n\t\t * release slots_arch_lock.\n\t\t */\n\t\tif (change == KVM_MR_DELETE || change == KVM_MR_MOVE) {\n\t\t\tkvm_activate_memslot(kvm, invalid_slot, old);\n\t\t\tkfree(invalid_slot);\n\t\t} else {\n\t\t\tmutex_unlock(&kvm->slots_arch_lock);\n\t\t}\n\t\treturn r;\n\t}\n\n\t/*\n\t * For DELETE and MOVE, the working slot is now active as the INVALID\n\t * version of the old slot.  MOVE is particularly special as it reuses\n\t * the old slot and returns a copy of the old slot (in working_slot).\n\t * For CREATE, there is no old slot.  For DELETE and FLAGS_ONLY, the\n\t * old slot is detached but otherwise preserved.\n\t */\n\tif (change == KVM_MR_CREATE)\n\t\tkvm_create_memslot(kvm, new);\n\telse if (change == KVM_MR_DELETE)\n\t\tkvm_delete_memslot(kvm, old, invalid_slot);\n\telse if (change == KVM_MR_MOVE)\n\t\tkvm_move_memslot(kvm, old, new, invalid_slot);\n\telse if (change == KVM_MR_FLAGS_ONLY)\n\t\tkvm_update_flags_memslot(kvm, old, new);\n\telse\n\t\tBUG();\n\n\t/* Free the temporary INVALID slot used for DELETE and MOVE. */\n\tif (change == KVM_MR_DELETE || change == KVM_MR_MOVE)\n\t\tkfree(invalid_slot);\n\n\t/*\n\t * No need to refresh new->arch, changes after dropping slots_arch_lock\n\t * will directly hit the final, active memsot.  Architectures are\n\t * responsible for knowing that new->arch may be stale.\n\t */\n\tkvm_commit_memory_region(kvm, old, new, change);\n\n\treturn 0;\n}\n\nstatic bool kvm_check_memslot_overlap(struct kvm_memslots *slots, int id,\n\t\t\t\t      gfn_t start, gfn_t end)\n{\n\tstruct kvm_memslot_iter iter;\n\n\tkvm_for_each_memslot_in_gfn_range(&iter, slots, start, end) {\n\t\tif (iter.slot->id != id)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/*\n * Allocate some memory and give it an address in the guest physical address\n * space.\n *\n * Discontiguous memory is allowed, mostly for framebuffers.\n *\n * Must be called holding kvm->slots_lock for write.\n */\nint __kvm_set_memory_region(struct kvm *kvm,\n\t\t\t    const struct kvm_userspace_memory_region *mem)\n{\n\tstruct kvm_memory_slot *old, *new;\n\tstruct kvm_memslots *slots;\n\tenum kvm_mr_change change;\n\tunsigned long npages;\n\tgfn_t base_gfn;\n\tint as_id, id;\n\tint r;\n\n\tr = check_memory_region_flags(mem);\n\tif (r)\n\t\treturn r;\n\n\tas_id = mem->slot >> 16;\n\tid = (u16)mem->slot;\n\n\t/* General sanity checks */\n\tif ((mem->memory_size & (PAGE_SIZE - 1)) ||\n\t    (mem->memory_size != (unsigned long)mem->memory_size))\n\t\treturn -EINVAL;\n\tif (mem->guest_phys_addr & (PAGE_SIZE - 1))\n\t\treturn -EINVAL;\n\t/* We can read the guest memory with __xxx_user() later on. */\n\tif ((mem->userspace_addr & (PAGE_SIZE - 1)) ||\n\t    (mem->userspace_addr != untagged_addr(mem->userspace_addr)) ||\n\t     !access_ok((void __user *)(unsigned long)mem->userspace_addr,\n\t\t\tmem->memory_size))\n\t\treturn -EINVAL;\n\tif (as_id >= KVM_ADDRESS_SPACE_NUM || id >= KVM_MEM_SLOTS_NUM)\n\t\treturn -EINVAL;\n\tif (mem->guest_phys_addr + mem->memory_size < mem->guest_phys_addr)\n\t\treturn -EINVAL;\n\tif ((mem->memory_size >> PAGE_SHIFT) > KVM_MEM_MAX_NR_PAGES)\n\t\treturn -EINVAL;\n\n\tslots = __kvm_memslots(kvm, as_id);\n\n\t/*\n\t * Note, the old memslot (and the pointer itself!) may be invalidated\n\t * and/or destroyed by kvm_set_memslot().\n\t */\n\told = id_to_memslot(slots, id);\n\n\tif (!mem->memory_size) {\n\t\tif (!old || !old->npages)\n\t\t\treturn -EINVAL;\n\n\t\tif (WARN_ON_ONCE(kvm->nr_memslot_pages < old->npages))\n\t\t\treturn -EIO;\n\n\t\treturn kvm_set_memslot(kvm, old, NULL, KVM_MR_DELETE);\n\t}\n\n\tbase_gfn = (mem->guest_phys_addr >> PAGE_SHIFT);\n\tnpages = (mem->memory_size >> PAGE_SHIFT);\n\n\tif (!old || !old->npages) {\n\t\tchange = KVM_MR_CREATE;\n\n\t\t/*\n\t\t * To simplify KVM internals, the total number of pages across\n\t\t * all memslots must fit in an unsigned long.\n\t\t */\n\t\tif ((kvm->nr_memslot_pages + npages) < kvm->nr_memslot_pages)\n\t\t\treturn -EINVAL;\n\t} else { /* Modify an existing slot. */\n\t\tif ((mem->userspace_addr != old->userspace_addr) ||\n\t\t    (npages != old->npages) ||\n\t\t    ((mem->flags ^ old->flags) & KVM_MEM_READONLY))\n\t\t\treturn -EINVAL;\n\n\t\tif (base_gfn != old->base_gfn)\n\t\t\tchange = KVM_MR_MOVE;\n\t\telse if (mem->flags != old->flags)\n\t\t\tchange = KVM_MR_FLAGS_ONLY;\n\t\telse /* Nothing to change. */\n\t\t\treturn 0;\n\t}\n\n\tif ((change == KVM_MR_CREATE || change == KVM_MR_MOVE) &&\n\t    kvm_check_memslot_overlap(slots, id, base_gfn, base_gfn + npages))\n\t\treturn -EEXIST;\n\n\t/* Allocate a slot that will persist in the memslot. */\n\tnew = kzalloc(sizeof(*new), GFP_KERNEL_ACCOUNT);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tnew->as_id = as_id;\n\tnew->id = id;\n\tnew->base_gfn = base_gfn;\n\tnew->npages = npages;\n\tnew->flags = mem->flags;\n\tnew->userspace_addr = mem->userspace_addr;\n\n\tr = kvm_set_memslot(kvm, old, new, change);\n\tif (r)\n\t\tkfree(new);\n\treturn r;\n}\nEXPORT_SYMBOL_GPL(__kvm_set_memory_region);\n\nint kvm_set_memory_region(struct kvm *kvm,\n\t\t\t  const struct kvm_userspace_memory_region *mem)\n{\n\tint r;\n\n\tmutex_lock(&kvm->slots_lock);\n\tr = __kvm_set_memory_region(kvm, mem);\n\tmutex_unlock(&kvm->slots_lock);\n\treturn r;\n}\nEXPORT_SYMBOL_GPL(kvm_set_memory_region);\n\nstatic int kvm_vm_ioctl_set_memory_region(struct kvm *kvm,\n\t\t\t\t\t  struct kvm_userspace_memory_region *mem)\n{\n\tif ((u16)mem->slot >= KVM_USER_MEM_SLOTS)\n\t\treturn -EINVAL;\n\n\treturn kvm_set_memory_region(kvm, mem);\n}\n\n#ifndef CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT\n/**\n * kvm_get_dirty_log - get a snapshot of dirty pages\n * @kvm:\tpointer to kvm instance\n * @log:\tslot id and address to which we copy the log\n * @is_dirty:\tset to '1' if any dirty pages were found\n * @memslot:\tset to the associated memslot, always valid on success\n */\nint kvm_get_dirty_log(struct kvm *kvm, struct kvm_dirty_log *log,\n\t\t      int *is_dirty, struct kvm_memory_slot **memslot)\n{\n\tstruct kvm_memslots *slots;\n\tint i, as_id, id;\n\tunsigned long n;\n\tunsigned long any = 0;\n\n\t/* Dirty ring tracking is exclusive to dirty log tracking */\n\tif (kvm->dirty_ring_size)\n\t\treturn -ENXIO;\n\n\t*memslot = NULL;\n\t*is_dirty = 0;\n\n\tas_id = log->slot >> 16;\n\tid = (u16)log->slot;\n\tif (as_id >= KVM_ADDRESS_SPACE_NUM || id >= KVM_USER_MEM_SLOTS)\n\t\treturn -EINVAL;\n\n\tslots = __kvm_memslots(kvm, as_id);\n\t*memslot = id_to_memslot(slots, id);\n\tif (!(*memslot) || !(*memslot)->dirty_bitmap)\n\t\treturn -ENOENT;\n\n\tkvm_arch_sync_dirty_log(kvm, *memslot);\n\n\tn = kvm_dirty_bitmap_bytes(*memslot);\n\n\tfor (i = 0; !any && i < n/sizeof(long); ++i)\n\t\tany = (*memslot)->dirty_bitmap[i];\n\n\tif (copy_to_user(log->dirty_bitmap, (*memslot)->dirty_bitmap, n))\n\t\treturn -EFAULT;\n\n\tif (any)\n\t\t*is_dirty = 1;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_get_dirty_log);\n\n#else /* CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT */\n/**\n * kvm_get_dirty_log_protect - get a snapshot of dirty pages\n *\tand reenable dirty page tracking for the corresponding pages.\n * @kvm:\tpointer to kvm instance\n * @log:\tslot id and address to which we copy the log\n *\n * We need to keep it in mind that VCPU threads can write to the bitmap\n * concurrently. So, to avoid losing track of dirty pages we keep the\n * following order:\n *\n *    1. Take a snapshot of the bit and clear it if needed.\n *    2. Write protect the corresponding page.\n *    3. Copy the snapshot to the userspace.\n *    4. Upon return caller flushes TLB's if needed.\n *\n * Between 2 and 4, the guest may write to the page using the remaining TLB\n * entry.  This is not a problem because the page is reported dirty using\n * the snapshot taken before and step 4 ensures that writes done after\n * exiting to userspace will be logged for the next call.\n *\n */\nstatic int kvm_get_dirty_log_protect(struct kvm *kvm, struct kvm_dirty_log *log)\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\tint i, as_id, id;\n\tunsigned long n;\n\tunsigned long *dirty_bitmap;\n\tunsigned long *dirty_bitmap_buffer;\n\tbool flush;\n\n\t/* Dirty ring tracking is exclusive to dirty log tracking */\n\tif (kvm->dirty_ring_size)\n\t\treturn -ENXIO;\n\n\tas_id = log->slot >> 16;\n\tid = (u16)log->slot;\n\tif (as_id >= KVM_ADDRESS_SPACE_NUM || id >= KVM_USER_MEM_SLOTS)\n\t\treturn -EINVAL;\n\n\tslots = __kvm_memslots(kvm, as_id);\n\tmemslot = id_to_memslot(slots, id);\n\tif (!memslot || !memslot->dirty_bitmap)\n\t\treturn -ENOENT;\n\n\tdirty_bitmap = memslot->dirty_bitmap;\n\n\tkvm_arch_sync_dirty_log(kvm, memslot);\n\n\tn = kvm_dirty_bitmap_bytes(memslot);\n\tflush = false;\n\tif (kvm->manual_dirty_log_protect) {\n\t\t/*\n\t\t * Unlike kvm_get_dirty_log, we always return false in *flush,\n\t\t * because no flush is needed until KVM_CLEAR_DIRTY_LOG.  There\n\t\t * is some code duplication between this function and\n\t\t * kvm_get_dirty_log, but hopefully all architecture\n\t\t * transition to kvm_get_dirty_log_protect and kvm_get_dirty_log\n\t\t * can be eliminated.\n\t\t */\n\t\tdirty_bitmap_buffer = dirty_bitmap;\n\t} else {\n\t\tdirty_bitmap_buffer = kvm_second_dirty_bitmap(memslot);\n\t\tmemset(dirty_bitmap_buffer, 0, n);\n\n\t\tKVM_MMU_LOCK(kvm);\n\t\tfor (i = 0; i < n / sizeof(long); i++) {\n\t\t\tunsigned long mask;\n\t\t\tgfn_t offset;\n\n\t\t\tif (!dirty_bitmap[i])\n\t\t\t\tcontinue;\n\n\t\t\tflush = true;\n\t\t\tmask = xchg(&dirty_bitmap[i], 0);\n\t\t\tdirty_bitmap_buffer[i] = mask;\n\n\t\t\toffset = i * BITS_PER_LONG;\n\t\t\tkvm_arch_mmu_enable_log_dirty_pt_masked(kvm, memslot,\n\t\t\t\t\t\t\t\toffset, mask);\n\t\t}\n\t\tKVM_MMU_UNLOCK(kvm);\n\t}\n\n\tif (flush)\n\t\tkvm_arch_flush_remote_tlbs_memslot(kvm, memslot);\n\n\tif (copy_to_user(log->dirty_bitmap, dirty_bitmap_buffer, n))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n\n/**\n * kvm_vm_ioctl_get_dirty_log - get and clear the log of dirty pages in a slot\n * @kvm: kvm instance\n * @log: slot id and address to which we copy the log\n *\n * Steps 1-4 below provide general overview of dirty page logging. See\n * kvm_get_dirty_log_protect() function description for additional details.\n *\n * We call kvm_get_dirty_log_protect() to handle steps 1-3, upon return we\n * always flush the TLB (step 4) even if previous step failed  and the dirty\n * bitmap may be corrupt. Regardless of previous outcome the KVM logging API\n * does not preclude user space subsequent dirty log read. Flushing TLB ensures\n * writes will be marked dirty for next log read.\n *\n *   1. Take a snapshot of the bit and clear it if needed.\n *   2. Write protect the corresponding page.\n *   3. Copy the snapshot to the userspace.\n *   4. Flush TLB's if needed.\n */\nstatic int kvm_vm_ioctl_get_dirty_log(struct kvm *kvm,\n\t\t\t\t      struct kvm_dirty_log *log)\n{\n\tint r;\n\n\tmutex_lock(&kvm->slots_lock);\n\n\tr = kvm_get_dirty_log_protect(kvm, log);\n\n\tmutex_unlock(&kvm->slots_lock);\n\treturn r;\n}\n\n/**\n * kvm_clear_dirty_log_protect - clear dirty bits in the bitmap\n *\tand reenable dirty page tracking for the corresponding pages.\n * @kvm:\tpointer to kvm instance\n * @log:\tslot id and address from which to fetch the bitmap of dirty pages\n */\nstatic int kvm_clear_dirty_log_protect(struct kvm *kvm,\n\t\t\t\t       struct kvm_clear_dirty_log *log)\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\tint as_id, id;\n\tgfn_t offset;\n\tunsigned long i, n;\n\tunsigned long *dirty_bitmap;\n\tunsigned long *dirty_bitmap_buffer;\n\tbool flush;\n\n\t/* Dirty ring tracking is exclusive to dirty log tracking */\n\tif (kvm->dirty_ring_size)\n\t\treturn -ENXIO;\n\n\tas_id = log->slot >> 16;\n\tid = (u16)log->slot;\n\tif (as_id >= KVM_ADDRESS_SPACE_NUM || id >= KVM_USER_MEM_SLOTS)\n\t\treturn -EINVAL;\n\n\tif (log->first_page & 63)\n\t\treturn -EINVAL;\n\n\tslots = __kvm_memslots(kvm, as_id);\n\tmemslot = id_to_memslot(slots, id);\n\tif (!memslot || !memslot->dirty_bitmap)\n\t\treturn -ENOENT;\n\n\tdirty_bitmap = memslot->dirty_bitmap;\n\n\tn = ALIGN(log->num_pages, BITS_PER_LONG) / 8;\n\n\tif (log->first_page > memslot->npages ||\n\t    log->num_pages > memslot->npages - log->first_page ||\n\t    (log->num_pages < memslot->npages - log->first_page && (log->num_pages & 63)))\n\t    return -EINVAL;\n\n\tkvm_arch_sync_dirty_log(kvm, memslot);\n\n\tflush = false;\n\tdirty_bitmap_buffer = kvm_second_dirty_bitmap(memslot);\n\tif (copy_from_user(dirty_bitmap_buffer, log->dirty_bitmap, n))\n\t\treturn -EFAULT;\n\n\tKVM_MMU_LOCK(kvm);\n\tfor (offset = log->first_page, i = offset / BITS_PER_LONG,\n\t\t n = DIV_ROUND_UP(log->num_pages, BITS_PER_LONG); n--;\n\t     i++, offset += BITS_PER_LONG) {\n\t\tunsigned long mask = *dirty_bitmap_buffer++;\n\t\tatomic_long_t *p = (atomic_long_t *) &dirty_bitmap[i];\n\t\tif (!mask)\n\t\t\tcontinue;\n\n\t\tmask &= atomic_long_fetch_andnot(mask, p);\n\n\t\t/*\n\t\t * mask contains the bits that really have been cleared.  This\n\t\t * never includes any bits beyond the length of the memslot (if\n\t\t * the length is not aligned to 64 pages), therefore it is not\n\t\t * a problem if userspace sets them in log->dirty_bitmap.\n\t\t*/\n\t\tif (mask) {\n\t\t\tflush = true;\n\t\t\tkvm_arch_mmu_enable_log_dirty_pt_masked(kvm, memslot,\n\t\t\t\t\t\t\t\toffset, mask);\n\t\t}\n\t}\n\tKVM_MMU_UNLOCK(kvm);\n\n\tif (flush)\n\t\tkvm_arch_flush_remote_tlbs_memslot(kvm, memslot);\n\n\treturn 0;\n}\n\nstatic int kvm_vm_ioctl_clear_dirty_log(struct kvm *kvm,\n\t\t\t\t\tstruct kvm_clear_dirty_log *log)\n{\n\tint r;\n\n\tmutex_lock(&kvm->slots_lock);\n\n\tr = kvm_clear_dirty_log_protect(kvm, log);\n\n\tmutex_unlock(&kvm->slots_lock);\n\treturn r;\n}\n#endif /* CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT */\n\nstruct kvm_memory_slot *gfn_to_memslot(struct kvm *kvm, gfn_t gfn)\n{\n\treturn __gfn_to_memslot(kvm_memslots(kvm), gfn);\n}\nEXPORT_SYMBOL_GPL(gfn_to_memslot);\n\nstruct kvm_memory_slot *kvm_vcpu_gfn_to_memslot(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\tstruct kvm_memslots *slots = kvm_vcpu_memslots(vcpu);\n\tu64 gen = slots->generation;\n\tstruct kvm_memory_slot *slot;\n\n\t/*\n\t * This also protects against using a memslot from a different address space,\n\t * since different address spaces have different generation numbers.\n\t */\n\tif (unlikely(gen != vcpu->last_used_slot_gen)) {\n\t\tvcpu->last_used_slot = NULL;\n\t\tvcpu->last_used_slot_gen = gen;\n\t}\n\n\tslot = try_get_memslot(vcpu->last_used_slot, gfn);\n\tif (slot)\n\t\treturn slot;\n\n\t/*\n\t * Fall back to searching all memslots. We purposely use\n\t * search_memslots() instead of __gfn_to_memslot() to avoid\n\t * thrashing the VM-wide last_used_slot in kvm_memslots.\n\t */\n\tslot = search_memslots(slots, gfn, false);\n\tif (slot) {\n\t\tvcpu->last_used_slot = slot;\n\t\treturn slot;\n\t}\n\n\treturn NULL;\n}\n\nbool kvm_is_visible_gfn(struct kvm *kvm, gfn_t gfn)\n{\n\tstruct kvm_memory_slot *memslot = gfn_to_memslot(kvm, gfn);\n\n\treturn kvm_is_visible_memslot(memslot);\n}\nEXPORT_SYMBOL_GPL(kvm_is_visible_gfn);\n\nbool kvm_vcpu_is_visible_gfn(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\tstruct kvm_memory_slot *memslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\n\treturn kvm_is_visible_memslot(memslot);\n}\nEXPORT_SYMBOL_GPL(kvm_vcpu_is_visible_gfn);\n\nunsigned long kvm_host_page_size(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\tstruct vm_area_struct *vma;\n\tunsigned long addr, size;\n\n\tsize = PAGE_SIZE;\n\n\taddr = kvm_vcpu_gfn_to_hva_prot(vcpu, gfn, NULL);\n\tif (kvm_is_error_hva(addr))\n\t\treturn PAGE_SIZE;\n\n\tmmap_read_lock(current->mm);\n\tvma = find_vma(current->mm, addr);\n\tif (!vma)\n\t\tgoto out;\n\n\tsize = vma_kernel_pagesize(vma);\n\nout:\n\tmmap_read_unlock(current->mm);\n\n\treturn size;\n}\n\nstatic bool memslot_is_readonly(const struct kvm_memory_slot *slot)\n{\n\treturn slot->flags & KVM_MEM_READONLY;\n}\n\nstatic unsigned long __gfn_to_hva_many(const struct kvm_memory_slot *slot, gfn_t gfn,\n\t\t\t\t       gfn_t *nr_pages, bool write)\n{\n\tif (!slot || slot->flags & KVM_MEMSLOT_INVALID)\n\t\treturn KVM_HVA_ERR_BAD;\n\n\tif (memslot_is_readonly(slot) && write)\n\t\treturn KVM_HVA_ERR_RO_BAD;\n\n\tif (nr_pages)\n\t\t*nr_pages = slot->npages - (gfn - slot->base_gfn);\n\n\treturn __gfn_to_hva_memslot(slot, gfn);\n}\n\nstatic unsigned long gfn_to_hva_many(struct kvm_memory_slot *slot, gfn_t gfn,\n\t\t\t\t     gfn_t *nr_pages)\n{\n\treturn __gfn_to_hva_many(slot, gfn, nr_pages, true);\n}\n\nunsigned long gfn_to_hva_memslot(struct kvm_memory_slot *slot,\n\t\t\t\t\tgfn_t gfn)\n{\n\treturn gfn_to_hva_many(slot, gfn, NULL);\n}\nEXPORT_SYMBOL_GPL(gfn_to_hva_memslot);\n\nunsigned long gfn_to_hva(struct kvm *kvm, gfn_t gfn)\n{\n\treturn gfn_to_hva_many(gfn_to_memslot(kvm, gfn), gfn, NULL);\n}\nEXPORT_SYMBOL_GPL(gfn_to_hva);\n\nunsigned long kvm_vcpu_gfn_to_hva(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\treturn gfn_to_hva_many(kvm_vcpu_gfn_to_memslot(vcpu, gfn), gfn, NULL);\n}\nEXPORT_SYMBOL_GPL(kvm_vcpu_gfn_to_hva);\n\n/*\n * Return the hva of a @gfn and the R/W attribute if possible.\n *\n * @slot: the kvm_memory_slot which contains @gfn\n * @gfn: the gfn to be translated\n * @writable: used to return the read/write attribute of the @slot if the hva\n * is valid and @writable is not NULL\n */\nunsigned long gfn_to_hva_memslot_prot(struct kvm_memory_slot *slot,\n\t\t\t\t      gfn_t gfn, bool *writable)\n{\n\tunsigned long hva = __gfn_to_hva_many(slot, gfn, NULL, false);\n\n\tif (!kvm_is_error_hva(hva) && writable)\n\t\t*writable = !memslot_is_readonly(slot);\n\n\treturn hva;\n}\n\nunsigned long gfn_to_hva_prot(struct kvm *kvm, gfn_t gfn, bool *writable)\n{\n\tstruct kvm_memory_slot *slot = gfn_to_memslot(kvm, gfn);\n\n\treturn gfn_to_hva_memslot_prot(slot, gfn, writable);\n}\n\nunsigned long kvm_vcpu_gfn_to_hva_prot(struct kvm_vcpu *vcpu, gfn_t gfn, bool *writable)\n{\n\tstruct kvm_memory_slot *slot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\n\treturn gfn_to_hva_memslot_prot(slot, gfn, writable);\n}\n\nstatic inline int check_user_page_hwpoison(unsigned long addr)\n{\n\tint rc, flags = FOLL_HWPOISON | FOLL_WRITE;\n\n\trc = get_user_pages(addr, 1, flags, NULL, NULL);\n\treturn rc == -EHWPOISON;\n}\n\n/*\n * The fast path to get the writable pfn which will be stored in @pfn,\n * true indicates success, otherwise false is returned.  It's also the\n * only part that runs if we can in atomic context.\n */\nstatic bool hva_to_pfn_fast(unsigned long addr, bool write_fault,\n\t\t\t    bool *writable, kvm_pfn_t *pfn)\n{\n\tstruct page *page[1];\n\n\t/*\n\t * Fast pin a writable pfn only if it is a write fault request\n\t * or the caller allows to map a writable pfn for a read fault\n\t * request.\n\t */\n\tif (!(write_fault || writable))\n\t\treturn false;\n\n\tif (get_user_page_fast_only(addr, FOLL_WRITE, page)) {\n\t\t*pfn = page_to_pfn(page[0]);\n\n\t\tif (writable)\n\t\t\t*writable = true;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/*\n * The slow path to get the pfn of the specified host virtual address,\n * 1 indicates success, -errno is returned if error is detected.\n */\nstatic int hva_to_pfn_slow(unsigned long addr, bool *async, bool write_fault,\n\t\t\t   bool *writable, kvm_pfn_t *pfn)\n{\n\tunsigned int flags = FOLL_HWPOISON;\n\tstruct page *page;\n\tint npages = 0;\n\n\tmight_sleep();\n\n\tif (writable)\n\t\t*writable = write_fault;\n\n\tif (write_fault)\n\t\tflags |= FOLL_WRITE;\n\tif (async)\n\t\tflags |= FOLL_NOWAIT;\n\n\tnpages = get_user_pages_unlocked(addr, 1, &page, flags);\n\tif (npages != 1)\n\t\treturn npages;\n\n\t/* map read fault as writable if possible */\n\tif (unlikely(!write_fault) && writable) {\n\t\tstruct page *wpage;\n\n\t\tif (get_user_page_fast_only(addr, FOLL_WRITE, &wpage)) {\n\t\t\t*writable = true;\n\t\t\tput_page(page);\n\t\t\tpage = wpage;\n\t\t}\n\t}\n\t*pfn = page_to_pfn(page);\n\treturn npages;\n}\n\nstatic bool vma_is_valid(struct vm_area_struct *vma, bool write_fault)\n{\n\tif (unlikely(!(vma->vm_flags & VM_READ)))\n\t\treturn false;\n\n\tif (write_fault && (unlikely(!(vma->vm_flags & VM_WRITE))))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int kvm_try_get_pfn(kvm_pfn_t pfn)\n{\n\tif (kvm_is_reserved_pfn(pfn))\n\t\treturn 1;\n\treturn get_page_unless_zero(pfn_to_page(pfn));\n}\n\nstatic int hva_to_pfn_remapped(struct vm_area_struct *vma,\n\t\t\t       unsigned long addr, bool write_fault,\n\t\t\t       bool *writable, kvm_pfn_t *p_pfn)\n{\n\tkvm_pfn_t pfn;\n\tpte_t *ptep;\n\tspinlock_t *ptl;\n\tint r;\n\n\tr = follow_pte(vma->vm_mm, addr, &ptep, &ptl);\n\tif (r) {\n\t\t/*\n\t\t * get_user_pages fails for VM_IO and VM_PFNMAP vmas and does\n\t\t * not call the fault handler, so do it here.\n\t\t */\n\t\tbool unlocked = false;\n\t\tr = fixup_user_fault(current->mm, addr,\n\t\t\t\t     (write_fault ? FAULT_FLAG_WRITE : 0),\n\t\t\t\t     &unlocked);\n\t\tif (unlocked)\n\t\t\treturn -EAGAIN;\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tr = follow_pte(vma->vm_mm, addr, &ptep, &ptl);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tif (write_fault && !pte_write(*ptep)) {\n\t\tpfn = KVM_PFN_ERR_RO_FAULT;\n\t\tgoto out;\n\t}\n\n\tif (writable)\n\t\t*writable = pte_write(*ptep);\n\tpfn = pte_pfn(*ptep);\n\n\t/*\n\t * Get a reference here because callers of *hva_to_pfn* and\n\t * *gfn_to_pfn* ultimately call kvm_release_pfn_clean on the\n\t * returned pfn.  This is only needed if the VMA has VM_MIXEDMAP\n\t * set, but the kvm_try_get_pfn/kvm_release_pfn_clean pair will\n\t * simply do nothing for reserved pfns.\n\t *\n\t * Whoever called remap_pfn_range is also going to call e.g.\n\t * unmap_mapping_range before the underlying pages are freed,\n\t * causing a call to our MMU notifier.\n\t *\n\t * Certain IO or PFNMAP mappings can be backed with valid\n\t * struct pages, but be allocated without refcounting e.g.,\n\t * tail pages of non-compound higher order allocations, which\n\t * would then underflow the refcount when the caller does the\n\t * required put_page. Don't allow those pages here.\n\t */ \n\tif (!kvm_try_get_pfn(pfn))\n\t\tr = -EFAULT;\n\nout:\n\tpte_unmap_unlock(ptep, ptl);\n\t*p_pfn = pfn;\n\n\treturn r;\n}\n\n/*\n * Pin guest page in memory and return its pfn.\n * @addr: host virtual address which maps memory to the guest\n * @atomic: whether this function can sleep\n * @async: whether this function need to wait IO complete if the\n *         host page is not in the memory\n * @write_fault: whether we should get a writable host page\n * @writable: whether it allows to map a writable host page for !@write_fault\n *\n * The function will map a writable host page for these two cases:\n * 1): @write_fault = true\n * 2): @write_fault = false && @writable, @writable will tell the caller\n *     whether the mapping is writable.\n */\nkvm_pfn_t hva_to_pfn(unsigned long addr, bool atomic, bool *async,\n\t\t     bool write_fault, bool *writable)\n{\n\tstruct vm_area_struct *vma;\n\tkvm_pfn_t pfn = 0;\n\tint npages, r;\n\n\t/* we can do it either atomically or asynchronously, not both */\n\tBUG_ON(atomic && async);\n\n\tif (hva_to_pfn_fast(addr, write_fault, writable, &pfn))\n\t\treturn pfn;\n\n\tif (atomic)\n\t\treturn KVM_PFN_ERR_FAULT;\n\n\tnpages = hva_to_pfn_slow(addr, async, write_fault, writable, &pfn);\n\tif (npages == 1)\n\t\treturn pfn;\n\n\tmmap_read_lock(current->mm);\n\tif (npages == -EHWPOISON ||\n\t      (!async && check_user_page_hwpoison(addr))) {\n\t\tpfn = KVM_PFN_ERR_HWPOISON;\n\t\tgoto exit;\n\t}\n\nretry:\n\tvma = vma_lookup(current->mm, addr);\n\n\tif (vma == NULL)\n\t\tpfn = KVM_PFN_ERR_FAULT;\n\telse if (vma->vm_flags & (VM_IO | VM_PFNMAP)) {\n\t\tr = hva_to_pfn_remapped(vma, addr, write_fault, writable, &pfn);\n\t\tif (r == -EAGAIN)\n\t\t\tgoto retry;\n\t\tif (r < 0)\n\t\t\tpfn = KVM_PFN_ERR_FAULT;\n\t} else {\n\t\tif (async && vma_is_valid(vma, write_fault))\n\t\t\t*async = true;\n\t\tpfn = KVM_PFN_ERR_FAULT;\n\t}\nexit:\n\tmmap_read_unlock(current->mm);\n\treturn pfn;\n}\n\nkvm_pfn_t __gfn_to_pfn_memslot(const struct kvm_memory_slot *slot, gfn_t gfn,\n\t\t\t       bool atomic, bool *async, bool write_fault,\n\t\t\t       bool *writable, hva_t *hva)\n{\n\tunsigned long addr = __gfn_to_hva_many(slot, gfn, NULL, write_fault);\n\n\tif (hva)\n\t\t*hva = addr;\n\n\tif (addr == KVM_HVA_ERR_RO_BAD) {\n\t\tif (writable)\n\t\t\t*writable = false;\n\t\treturn KVM_PFN_ERR_RO_FAULT;\n\t}\n\n\tif (kvm_is_error_hva(addr)) {\n\t\tif (writable)\n\t\t\t*writable = false;\n\t\treturn KVM_PFN_NOSLOT;\n\t}\n\n\t/* Do not map writable pfn in the readonly memslot. */\n\tif (writable && memslot_is_readonly(slot)) {\n\t\t*writable = false;\n\t\twritable = NULL;\n\t}\n\n\treturn hva_to_pfn(addr, atomic, async, write_fault,\n\t\t\t  writable);\n}\nEXPORT_SYMBOL_GPL(__gfn_to_pfn_memslot);\n\nkvm_pfn_t gfn_to_pfn_prot(struct kvm *kvm, gfn_t gfn, bool write_fault,\n\t\t      bool *writable)\n{\n\treturn __gfn_to_pfn_memslot(gfn_to_memslot(kvm, gfn), gfn, false, NULL,\n\t\t\t\t    write_fault, writable, NULL);\n}\nEXPORT_SYMBOL_GPL(gfn_to_pfn_prot);\n\nkvm_pfn_t gfn_to_pfn_memslot(const struct kvm_memory_slot *slot, gfn_t gfn)\n{\n\treturn __gfn_to_pfn_memslot(slot, gfn, false, NULL, true, NULL, NULL);\n}\nEXPORT_SYMBOL_GPL(gfn_to_pfn_memslot);\n\nkvm_pfn_t gfn_to_pfn_memslot_atomic(const struct kvm_memory_slot *slot, gfn_t gfn)\n{\n\treturn __gfn_to_pfn_memslot(slot, gfn, true, NULL, true, NULL, NULL);\n}\nEXPORT_SYMBOL_GPL(gfn_to_pfn_memslot_atomic);\n\nkvm_pfn_t kvm_vcpu_gfn_to_pfn_atomic(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\treturn gfn_to_pfn_memslot_atomic(kvm_vcpu_gfn_to_memslot(vcpu, gfn), gfn);\n}\nEXPORT_SYMBOL_GPL(kvm_vcpu_gfn_to_pfn_atomic);\n\nkvm_pfn_t gfn_to_pfn(struct kvm *kvm, gfn_t gfn)\n{\n\treturn gfn_to_pfn_memslot(gfn_to_memslot(kvm, gfn), gfn);\n}\nEXPORT_SYMBOL_GPL(gfn_to_pfn);\n\nkvm_pfn_t kvm_vcpu_gfn_to_pfn(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\treturn gfn_to_pfn_memslot(kvm_vcpu_gfn_to_memslot(vcpu, gfn), gfn);\n}\nEXPORT_SYMBOL_GPL(kvm_vcpu_gfn_to_pfn);\n\nint gfn_to_page_many_atomic(struct kvm_memory_slot *slot, gfn_t gfn,\n\t\t\t    struct page **pages, int nr_pages)\n{\n\tunsigned long addr;\n\tgfn_t entry = 0;\n\n\taddr = gfn_to_hva_many(slot, gfn, &entry);\n\tif (kvm_is_error_hva(addr))\n\t\treturn -1;\n\n\tif (entry < nr_pages)\n\t\treturn 0;\n\n\treturn get_user_pages_fast_only(addr, nr_pages, FOLL_WRITE, pages);\n}\nEXPORT_SYMBOL_GPL(gfn_to_page_many_atomic);\n\nstatic struct page *kvm_pfn_to_page(kvm_pfn_t pfn)\n{\n\tif (is_error_noslot_pfn(pfn))\n\t\treturn KVM_ERR_PTR_BAD_PAGE;\n\n\tif (kvm_is_reserved_pfn(pfn)) {\n\t\tWARN_ON(1);\n\t\treturn KVM_ERR_PTR_BAD_PAGE;\n\t}\n\n\treturn pfn_to_page(pfn);\n}\n\nstruct page *gfn_to_page(struct kvm *kvm, gfn_t gfn)\n{\n\tkvm_pfn_t pfn;\n\n\tpfn = gfn_to_pfn(kvm, gfn);\n\n\treturn kvm_pfn_to_page(pfn);\n}\nEXPORT_SYMBOL_GPL(gfn_to_page);\n\nvoid kvm_release_pfn(kvm_pfn_t pfn, bool dirty)\n{\n\tif (pfn == 0)\n\t\treturn;\n\n\tif (dirty)\n\t\tkvm_release_pfn_dirty(pfn);\n\telse\n\t\tkvm_release_pfn_clean(pfn);\n}\n\nint kvm_vcpu_map(struct kvm_vcpu *vcpu, gfn_t gfn, struct kvm_host_map *map)\n{\n\tkvm_pfn_t pfn;\n\tvoid *hva = NULL;\n\tstruct page *page = KVM_UNMAPPED_PAGE;\n\n\tif (!map)\n\t\treturn -EINVAL;\n\n\tpfn = gfn_to_pfn(vcpu->kvm, gfn);\n\tif (is_error_noslot_pfn(pfn))\n\t\treturn -EINVAL;\n\n\tif (pfn_valid(pfn)) {\n\t\tpage = pfn_to_page(pfn);\n\t\thva = kmap(page);\n#ifdef CONFIG_HAS_IOMEM\n\t} else {\n\t\thva = memremap(pfn_to_hpa(pfn), PAGE_SIZE, MEMREMAP_WB);\n#endif\n\t}\n\n\tif (!hva)\n\t\treturn -EFAULT;\n\n\tmap->page = page;\n\tmap->hva = hva;\n\tmap->pfn = pfn;\n\tmap->gfn = gfn;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_vcpu_map);\n\nvoid kvm_vcpu_unmap(struct kvm_vcpu *vcpu, struct kvm_host_map *map, bool dirty)\n{\n\tif (!map)\n\t\treturn;\n\n\tif (!map->hva)\n\t\treturn;\n\n\tif (map->page != KVM_UNMAPPED_PAGE)\n\t\tkunmap(map->page);\n#ifdef CONFIG_HAS_IOMEM\n\telse\n\t\tmemunmap(map->hva);\n#endif\n\n\tif (dirty)\n\t\tkvm_vcpu_mark_page_dirty(vcpu, map->gfn);\n\n\tkvm_release_pfn(map->pfn, dirty);\n\n\tmap->hva = NULL;\n\tmap->page = NULL;\n}\nEXPORT_SYMBOL_GPL(kvm_vcpu_unmap);\n\nstruct page *kvm_vcpu_gfn_to_page(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\tkvm_pfn_t pfn;\n\n\tpfn = kvm_vcpu_gfn_to_pfn(vcpu, gfn);\n\n\treturn kvm_pfn_to_page(pfn);\n}\nEXPORT_SYMBOL_GPL(kvm_vcpu_gfn_to_page);\n\nvoid kvm_release_page_clean(struct page *page)\n{\n\tWARN_ON(is_error_page(page));\n\n\tkvm_release_pfn_clean(page_to_pfn(page));\n}\nEXPORT_SYMBOL_GPL(kvm_release_page_clean);\n\nvoid kvm_release_pfn_clean(kvm_pfn_t pfn)\n{\n\tif (!is_error_noslot_pfn(pfn) && !kvm_is_reserved_pfn(pfn))\n\t\tput_page(pfn_to_page(pfn));\n}\nEXPORT_SYMBOL_GPL(kvm_release_pfn_clean);\n\nvoid kvm_release_page_dirty(struct page *page)\n{\n\tWARN_ON(is_error_page(page));\n\n\tkvm_release_pfn_dirty(page_to_pfn(page));\n}\nEXPORT_SYMBOL_GPL(kvm_release_page_dirty);\n\nvoid kvm_release_pfn_dirty(kvm_pfn_t pfn)\n{\n\tkvm_set_pfn_dirty(pfn);\n\tkvm_release_pfn_clean(pfn);\n}\nEXPORT_SYMBOL_GPL(kvm_release_pfn_dirty);\n\nvoid kvm_set_pfn_dirty(kvm_pfn_t pfn)\n{\n\tif (!kvm_is_reserved_pfn(pfn) && !kvm_is_zone_device_pfn(pfn))\n\t\tSetPageDirty(pfn_to_page(pfn));\n}\nEXPORT_SYMBOL_GPL(kvm_set_pfn_dirty);\n\nvoid kvm_set_pfn_accessed(kvm_pfn_t pfn)\n{\n\tif (!kvm_is_reserved_pfn(pfn) && !kvm_is_zone_device_pfn(pfn))\n\t\tmark_page_accessed(pfn_to_page(pfn));\n}\nEXPORT_SYMBOL_GPL(kvm_set_pfn_accessed);\n\nstatic int next_segment(unsigned long len, int offset)\n{\n\tif (len > PAGE_SIZE - offset)\n\t\treturn PAGE_SIZE - offset;\n\telse\n\t\treturn len;\n}\n\nstatic int __kvm_read_guest_page(struct kvm_memory_slot *slot, gfn_t gfn,\n\t\t\t\t void *data, int offset, int len)\n{\n\tint r;\n\tunsigned long addr;\n\n\taddr = gfn_to_hva_memslot_prot(slot, gfn, NULL);\n\tif (kvm_is_error_hva(addr))\n\t\treturn -EFAULT;\n\tr = __copy_from_user(data, (void __user *)addr + offset, len);\n\tif (r)\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nint kvm_read_guest_page(struct kvm *kvm, gfn_t gfn, void *data, int offset,\n\t\t\tint len)\n{\n\tstruct kvm_memory_slot *slot = gfn_to_memslot(kvm, gfn);\n\n\treturn __kvm_read_guest_page(slot, gfn, data, offset, len);\n}\nEXPORT_SYMBOL_GPL(kvm_read_guest_page);\n\nint kvm_vcpu_read_guest_page(struct kvm_vcpu *vcpu, gfn_t gfn, void *data,\n\t\t\t     int offset, int len)\n{\n\tstruct kvm_memory_slot *slot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\n\treturn __kvm_read_guest_page(slot, gfn, data, offset, len);\n}\nEXPORT_SYMBOL_GPL(kvm_vcpu_read_guest_page);\n\nint kvm_read_guest(struct kvm *kvm, gpa_t gpa, void *data, unsigned long len)\n{\n\tgfn_t gfn = gpa >> PAGE_SHIFT;\n\tint seg;\n\tint offset = offset_in_page(gpa);\n\tint ret;\n\n\twhile ((seg = next_segment(len, offset)) != 0) {\n\t\tret = kvm_read_guest_page(kvm, gfn, data, offset, seg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\toffset = 0;\n\t\tlen -= seg;\n\t\tdata += seg;\n\t\t++gfn;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_read_guest);\n\nint kvm_vcpu_read_guest(struct kvm_vcpu *vcpu, gpa_t gpa, void *data, unsigned long len)\n{\n\tgfn_t gfn = gpa >> PAGE_SHIFT;\n\tint seg;\n\tint offset = offset_in_page(gpa);\n\tint ret;\n\n\twhile ((seg = next_segment(len, offset)) != 0) {\n\t\tret = kvm_vcpu_read_guest_page(vcpu, gfn, data, offset, seg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\toffset = 0;\n\t\tlen -= seg;\n\t\tdata += seg;\n\t\t++gfn;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_vcpu_read_guest);\n\nstatic int __kvm_read_guest_atomic(struct kvm_memory_slot *slot, gfn_t gfn,\n\t\t\t           void *data, int offset, unsigned long len)\n{\n\tint r;\n\tunsigned long addr;\n\n\taddr = gfn_to_hva_memslot_prot(slot, gfn, NULL);\n\tif (kvm_is_error_hva(addr))\n\t\treturn -EFAULT;\n\tpagefault_disable();\n\tr = __copy_from_user_inatomic(data, (void __user *)addr + offset, len);\n\tpagefault_enable();\n\tif (r)\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nint kvm_vcpu_read_guest_atomic(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t       void *data, unsigned long len)\n{\n\tgfn_t gfn = gpa >> PAGE_SHIFT;\n\tstruct kvm_memory_slot *slot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\tint offset = offset_in_page(gpa);\n\n\treturn __kvm_read_guest_atomic(slot, gfn, data, offset, len);\n}\nEXPORT_SYMBOL_GPL(kvm_vcpu_read_guest_atomic);\n\nstatic int __kvm_write_guest_page(struct kvm *kvm,\n\t\t\t\t  struct kvm_memory_slot *memslot, gfn_t gfn,\n\t\t\t          const void *data, int offset, int len)\n{\n\tint r;\n\tunsigned long addr;\n\n\taddr = gfn_to_hva_memslot(memslot, gfn);\n\tif (kvm_is_error_hva(addr))\n\t\treturn -EFAULT;\n\tr = __copy_to_user((void __user *)addr + offset, data, len);\n\tif (r)\n\t\treturn -EFAULT;\n\tmark_page_dirty_in_slot(kvm, memslot, gfn);\n\treturn 0;\n}\n\nint kvm_write_guest_page(struct kvm *kvm, gfn_t gfn,\n\t\t\t const void *data, int offset, int len)\n{\n\tstruct kvm_memory_slot *slot = gfn_to_memslot(kvm, gfn);\n\n\treturn __kvm_write_guest_page(kvm, slot, gfn, data, offset, len);\n}\nEXPORT_SYMBOL_GPL(kvm_write_guest_page);\n\nint kvm_vcpu_write_guest_page(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t      const void *data, int offset, int len)\n{\n\tstruct kvm_memory_slot *slot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\n\treturn __kvm_write_guest_page(vcpu->kvm, slot, gfn, data, offset, len);\n}\nEXPORT_SYMBOL_GPL(kvm_vcpu_write_guest_page);\n\nint kvm_write_guest(struct kvm *kvm, gpa_t gpa, const void *data,\n\t\t    unsigned long len)\n{\n\tgfn_t gfn = gpa >> PAGE_SHIFT;\n\tint seg;\n\tint offset = offset_in_page(gpa);\n\tint ret;\n\n\twhile ((seg = next_segment(len, offset)) != 0) {\n\t\tret = kvm_write_guest_page(kvm, gfn, data, offset, seg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\toffset = 0;\n\t\tlen -= seg;\n\t\tdata += seg;\n\t\t++gfn;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_write_guest);\n\nint kvm_vcpu_write_guest(struct kvm_vcpu *vcpu, gpa_t gpa, const void *data,\n\t\t         unsigned long len)\n{\n\tgfn_t gfn = gpa >> PAGE_SHIFT;\n\tint seg;\n\tint offset = offset_in_page(gpa);\n\tint ret;\n\n\twhile ((seg = next_segment(len, offset)) != 0) {\n\t\tret = kvm_vcpu_write_guest_page(vcpu, gfn, data, offset, seg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\toffset = 0;\n\t\tlen -= seg;\n\t\tdata += seg;\n\t\t++gfn;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_vcpu_write_guest);\n\nstatic int __kvm_gfn_to_hva_cache_init(struct kvm_memslots *slots,\n\t\t\t\t       struct gfn_to_hva_cache *ghc,\n\t\t\t\t       gpa_t gpa, unsigned long len)\n{\n\tint offset = offset_in_page(gpa);\n\tgfn_t start_gfn = gpa >> PAGE_SHIFT;\n\tgfn_t end_gfn = (gpa + len - 1) >> PAGE_SHIFT;\n\tgfn_t nr_pages_needed = end_gfn - start_gfn + 1;\n\tgfn_t nr_pages_avail;\n\n\t/* Update ghc->generation before performing any error checks. */\n\tghc->generation = slots->generation;\n\n\tif (start_gfn > end_gfn) {\n\t\tghc->hva = KVM_HVA_ERR_BAD;\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * If the requested region crosses two memslots, we still\n\t * verify that the entire region is valid here.\n\t */\n\tfor ( ; start_gfn <= end_gfn; start_gfn += nr_pages_avail) {\n\t\tghc->memslot = __gfn_to_memslot(slots, start_gfn);\n\t\tghc->hva = gfn_to_hva_many(ghc->memslot, start_gfn,\n\t\t\t\t\t   &nr_pages_avail);\n\t\tif (kvm_is_error_hva(ghc->hva))\n\t\t\treturn -EFAULT;\n\t}\n\n\t/* Use the slow path for cross page reads and writes. */\n\tif (nr_pages_needed == 1)\n\t\tghc->hva += offset;\n\telse\n\t\tghc->memslot = NULL;\n\n\tghc->gpa = gpa;\n\tghc->len = len;\n\treturn 0;\n}\n\nint kvm_gfn_to_hva_cache_init(struct kvm *kvm, struct gfn_to_hva_cache *ghc,\n\t\t\t      gpa_t gpa, unsigned long len)\n{\n\tstruct kvm_memslots *slots = kvm_memslots(kvm);\n\treturn __kvm_gfn_to_hva_cache_init(slots, ghc, gpa, len);\n}\nEXPORT_SYMBOL_GPL(kvm_gfn_to_hva_cache_init);\n\nint kvm_write_guest_offset_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc,\n\t\t\t\t  void *data, unsigned int offset,\n\t\t\t\t  unsigned long len)\n{\n\tstruct kvm_memslots *slots = kvm_memslots(kvm);\n\tint r;\n\tgpa_t gpa = ghc->gpa + offset;\n\n\tif (WARN_ON_ONCE(len + offset > ghc->len))\n\t\treturn -EINVAL;\n\n\tif (slots->generation != ghc->generation) {\n\t\tif (__kvm_gfn_to_hva_cache_init(slots, ghc, ghc->gpa, ghc->len))\n\t\t\treturn -EFAULT;\n\t}\n\n\tif (kvm_is_error_hva(ghc->hva))\n\t\treturn -EFAULT;\n\n\tif (unlikely(!ghc->memslot))\n\t\treturn kvm_write_guest(kvm, gpa, data, len);\n\n\tr = __copy_to_user((void __user *)ghc->hva + offset, data, len);\n\tif (r)\n\t\treturn -EFAULT;\n\tmark_page_dirty_in_slot(kvm, ghc->memslot, gpa >> PAGE_SHIFT);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_write_guest_offset_cached);\n\nint kvm_write_guest_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc,\n\t\t\t   void *data, unsigned long len)\n{\n\treturn kvm_write_guest_offset_cached(kvm, ghc, data, 0, len);\n}\nEXPORT_SYMBOL_GPL(kvm_write_guest_cached);\n\nint kvm_read_guest_offset_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc,\n\t\t\t\t void *data, unsigned int offset,\n\t\t\t\t unsigned long len)\n{\n\tstruct kvm_memslots *slots = kvm_memslots(kvm);\n\tint r;\n\tgpa_t gpa = ghc->gpa + offset;\n\n\tif (WARN_ON_ONCE(len + offset > ghc->len))\n\t\treturn -EINVAL;\n\n\tif (slots->generation != ghc->generation) {\n\t\tif (__kvm_gfn_to_hva_cache_init(slots, ghc, ghc->gpa, ghc->len))\n\t\t\treturn -EFAULT;\n\t}\n\n\tif (kvm_is_error_hva(ghc->hva))\n\t\treturn -EFAULT;\n\n\tif (unlikely(!ghc->memslot))\n\t\treturn kvm_read_guest(kvm, gpa, data, len);\n\n\tr = __copy_from_user(data, (void __user *)ghc->hva + offset, len);\n\tif (r)\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_read_guest_offset_cached);\n\nint kvm_read_guest_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc,\n\t\t\t  void *data, unsigned long len)\n{\n\treturn kvm_read_guest_offset_cached(kvm, ghc, data, 0, len);\n}\nEXPORT_SYMBOL_GPL(kvm_read_guest_cached);\n\nint kvm_clear_guest(struct kvm *kvm, gpa_t gpa, unsigned long len)\n{\n\tconst void *zero_page = (const void *) __va(page_to_phys(ZERO_PAGE(0)));\n\tgfn_t gfn = gpa >> PAGE_SHIFT;\n\tint seg;\n\tint offset = offset_in_page(gpa);\n\tint ret;\n\n\twhile ((seg = next_segment(len, offset)) != 0) {\n\t\tret = kvm_write_guest_page(kvm, gfn, zero_page, offset, len);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\toffset = 0;\n\t\tlen -= seg;\n\t\t++gfn;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_clear_guest);\n\nvoid mark_page_dirty_in_slot(struct kvm *kvm,\n\t\t\t     const struct kvm_memory_slot *memslot,\n\t\t \t     gfn_t gfn)\n{\n\tstruct kvm_vcpu *vcpu = kvm_get_running_vcpu();\n\n#ifdef CONFIG_HAVE_KVM_DIRTY_RING\n\tif (WARN_ON_ONCE(!vcpu) || WARN_ON_ONCE(vcpu->kvm != kvm))\n\t\treturn;\n#endif\n\n\tif (memslot && kvm_slot_dirty_track_enabled(memslot)) {\n\t\tunsigned long rel_gfn = gfn - memslot->base_gfn;\n\t\tu32 slot = (memslot->as_id << 16) | memslot->id;\n\n\t\tif (kvm->dirty_ring_size)\n\t\t\tkvm_dirty_ring_push(&vcpu->dirty_ring,\n\t\t\t\t\t    slot, rel_gfn);\n\t\telse\n\t\t\tset_bit_le(rel_gfn, memslot->dirty_bitmap);\n\t}\n}\nEXPORT_SYMBOL_GPL(mark_page_dirty_in_slot);\n\nvoid mark_page_dirty(struct kvm *kvm, gfn_t gfn)\n{\n\tstruct kvm_memory_slot *memslot;\n\n\tmemslot = gfn_to_memslot(kvm, gfn);\n\tmark_page_dirty_in_slot(kvm, memslot, gfn);\n}\nEXPORT_SYMBOL_GPL(mark_page_dirty);\n\nvoid kvm_vcpu_mark_page_dirty(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\tstruct kvm_memory_slot *memslot;\n\n\tmemslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\tmark_page_dirty_in_slot(vcpu->kvm, memslot, gfn);\n}\nEXPORT_SYMBOL_GPL(kvm_vcpu_mark_page_dirty);\n\nvoid kvm_sigset_activate(struct kvm_vcpu *vcpu)\n{\n\tif (!vcpu->sigset_active)\n\t\treturn;\n\n\t/*\n\t * This does a lockless modification of ->real_blocked, which is fine\n\t * because, only current can change ->real_blocked and all readers of\n\t * ->real_blocked don't care as long ->real_blocked is always a subset\n\t * of ->blocked.\n\t */\n\tsigprocmask(SIG_SETMASK, &vcpu->sigset, &current->real_blocked);\n}\n\nvoid kvm_sigset_deactivate(struct kvm_vcpu *vcpu)\n{\n\tif (!vcpu->sigset_active)\n\t\treturn;\n\n\tsigprocmask(SIG_SETMASK, &current->real_blocked, NULL);\n\tsigemptyset(&current->real_blocked);\n}\n\nstatic void grow_halt_poll_ns(struct kvm_vcpu *vcpu)\n{\n\tunsigned int old, val, grow, grow_start;\n\n\told = val = vcpu->halt_poll_ns;\n\tgrow_start = READ_ONCE(halt_poll_ns_grow_start);\n\tgrow = READ_ONCE(halt_poll_ns_grow);\n\tif (!grow)\n\t\tgoto out;\n\n\tval *= grow;\n\tif (val < grow_start)\n\t\tval = grow_start;\n\n\tif (val > vcpu->kvm->max_halt_poll_ns)\n\t\tval = vcpu->kvm->max_halt_poll_ns;\n\n\tvcpu->halt_poll_ns = val;\nout:\n\ttrace_kvm_halt_poll_ns_grow(vcpu->vcpu_id, val, old);\n}\n\nstatic void shrink_halt_poll_ns(struct kvm_vcpu *vcpu)\n{\n\tunsigned int old, val, shrink, grow_start;\n\n\told = val = vcpu->halt_poll_ns;\n\tshrink = READ_ONCE(halt_poll_ns_shrink);\n\tgrow_start = READ_ONCE(halt_poll_ns_grow_start);\n\tif (shrink == 0)\n\t\tval = 0;\n\telse\n\t\tval /= shrink;\n\n\tif (val < grow_start)\n\t\tval = 0;\n\n\tvcpu->halt_poll_ns = val;\n\ttrace_kvm_halt_poll_ns_shrink(vcpu->vcpu_id, val, old);\n}\n\nstatic int kvm_vcpu_check_block(struct kvm_vcpu *vcpu)\n{\n\tint ret = -EINTR;\n\tint idx = srcu_read_lock(&vcpu->kvm->srcu);\n\n\tif (kvm_arch_vcpu_runnable(vcpu)) {\n\t\tkvm_make_request(KVM_REQ_UNHALT, vcpu);\n\t\tgoto out;\n\t}\n\tif (kvm_cpu_has_pending_timer(vcpu))\n\t\tgoto out;\n\tif (signal_pending(current))\n\t\tgoto out;\n\tif (kvm_check_request(KVM_REQ_UNBLOCK, vcpu))\n\t\tgoto out;\n\n\tret = 0;\nout:\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\treturn ret;\n}\n\n/*\n * Block the vCPU until the vCPU is runnable, an event arrives, or a signal is\n * pending.  This is mostly used when halting a vCPU, but may also be used\n * directly for other vCPU non-runnable states, e.g. x86's Wait-For-SIPI.\n */\nbool kvm_vcpu_block(struct kvm_vcpu *vcpu)\n{\n\tstruct rcuwait *wait = kvm_arch_vcpu_get_wait(vcpu);\n\tbool waited = false;\n\n\tvcpu->stat.generic.blocking = 1;\n\n\tkvm_arch_vcpu_blocking(vcpu);\n\n\tprepare_to_rcuwait(wait);\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\tif (kvm_vcpu_check_block(vcpu) < 0)\n\t\t\tbreak;\n\n\t\twaited = true;\n\t\tschedule();\n\t}\n\tfinish_rcuwait(wait);\n\n\tkvm_arch_vcpu_unblocking(vcpu);\n\n\tvcpu->stat.generic.blocking = 0;\n\n\treturn waited;\n}\n\nstatic inline void update_halt_poll_stats(struct kvm_vcpu *vcpu, ktime_t start,\n\t\t\t\t\t  ktime_t end, bool success)\n{\n\tstruct kvm_vcpu_stat_generic *stats = &vcpu->stat.generic;\n\tu64 poll_ns = ktime_to_ns(ktime_sub(end, start));\n\n\t++vcpu->stat.generic.halt_attempted_poll;\n\n\tif (success) {\n\t\t++vcpu->stat.generic.halt_successful_poll;\n\n\t\tif (!vcpu_valid_wakeup(vcpu))\n\t\t\t++vcpu->stat.generic.halt_poll_invalid;\n\n\t\tstats->halt_poll_success_ns += poll_ns;\n\t\tKVM_STATS_LOG_HIST_UPDATE(stats->halt_poll_success_hist, poll_ns);\n\t} else {\n\t\tstats->halt_poll_fail_ns += poll_ns;\n\t\tKVM_STATS_LOG_HIST_UPDATE(stats->halt_poll_fail_hist, poll_ns);\n\t}\n}\n\n/*\n * Emulate a vCPU halt condition, e.g. HLT on x86, WFI on arm, etc...  If halt\n * polling is enabled, busy wait for a short time before blocking to avoid the\n * expensive block+unblock sequence if a wake event arrives soon after the vCPU\n * is halted.\n */\nvoid kvm_vcpu_halt(struct kvm_vcpu *vcpu)\n{\n\tbool halt_poll_allowed = !kvm_arch_no_poll(vcpu);\n\tbool do_halt_poll = halt_poll_allowed && vcpu->halt_poll_ns;\n\tktime_t start, cur, poll_end;\n\tbool waited = false;\n\tu64 halt_ns;\n\n\tstart = cur = poll_end = ktime_get();\n\tif (do_halt_poll) {\n\t\tktime_t stop = ktime_add_ns(start, vcpu->halt_poll_ns);\n\n\t\tdo {\n\t\t\t/*\n\t\t\t * This sets KVM_REQ_UNHALT if an interrupt\n\t\t\t * arrives.\n\t\t\t */\n\t\t\tif (kvm_vcpu_check_block(vcpu) < 0)\n\t\t\t\tgoto out;\n\t\t\tcpu_relax();\n\t\t\tpoll_end = cur = ktime_get();\n\t\t} while (kvm_vcpu_can_poll(cur, stop));\n\t}\n\n\twaited = kvm_vcpu_block(vcpu);\n\n\tcur = ktime_get();\n\tif (waited) {\n\t\tvcpu->stat.generic.halt_wait_ns +=\n\t\t\tktime_to_ns(cur) - ktime_to_ns(poll_end);\n\t\tKVM_STATS_LOG_HIST_UPDATE(vcpu->stat.generic.halt_wait_hist,\n\t\t\t\tktime_to_ns(cur) - ktime_to_ns(poll_end));\n\t}\nout:\n\t/* The total time the vCPU was \"halted\", including polling time. */\n\thalt_ns = ktime_to_ns(cur) - ktime_to_ns(start);\n\n\t/*\n\t * Note, halt-polling is considered successful so long as the vCPU was\n\t * never actually scheduled out, i.e. even if the wake event arrived\n\t * after of the halt-polling loop itself, but before the full wait.\n\t */\n\tif (do_halt_poll)\n\t\tupdate_halt_poll_stats(vcpu, start, poll_end, !waited);\n\n\tif (halt_poll_allowed) {\n\t\tif (!vcpu_valid_wakeup(vcpu)) {\n\t\t\tshrink_halt_poll_ns(vcpu);\n\t\t} else if (vcpu->kvm->max_halt_poll_ns) {\n\t\t\tif (halt_ns <= vcpu->halt_poll_ns)\n\t\t\t\t;\n\t\t\t/* we had a long block, shrink polling */\n\t\t\telse if (vcpu->halt_poll_ns &&\n\t\t\t\t halt_ns > vcpu->kvm->max_halt_poll_ns)\n\t\t\t\tshrink_halt_poll_ns(vcpu);\n\t\t\t/* we had a short halt and our poll time is too small */\n\t\t\telse if (vcpu->halt_poll_ns < vcpu->kvm->max_halt_poll_ns &&\n\t\t\t\t halt_ns < vcpu->kvm->max_halt_poll_ns)\n\t\t\t\tgrow_halt_poll_ns(vcpu);\n\t\t} else {\n\t\t\tvcpu->halt_poll_ns = 0;\n\t\t}\n\t}\n\n\ttrace_kvm_vcpu_wakeup(halt_ns, waited, vcpu_valid_wakeup(vcpu));\n}\nEXPORT_SYMBOL_GPL(kvm_vcpu_halt);\n\nbool kvm_vcpu_wake_up(struct kvm_vcpu *vcpu)\n{\n\tif (__kvm_vcpu_wake_up(vcpu)) {\n\t\tWRITE_ONCE(vcpu->ready, true);\n\t\t++vcpu->stat.generic.halt_wakeup;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(kvm_vcpu_wake_up);\n\n#ifndef CONFIG_S390\n/*\n * Kick a sleeping VCPU, or a guest VCPU in guest mode, into host kernel mode.\n */\nvoid kvm_vcpu_kick(struct kvm_vcpu *vcpu)\n{\n\tint me, cpu;\n\n\tif (kvm_vcpu_wake_up(vcpu))\n\t\treturn;\n\n\tme = get_cpu();\n\t/*\n\t * The only state change done outside the vcpu mutex is IN_GUEST_MODE\n\t * to EXITING_GUEST_MODE.  Therefore the moderately expensive \"should\n\t * kick\" check does not need atomic operations if kvm_vcpu_kick is used\n\t * within the vCPU thread itself.\n\t */\n\tif (vcpu == __this_cpu_read(kvm_running_vcpu)) {\n\t\tif (vcpu->mode == IN_GUEST_MODE)\n\t\t\tWRITE_ONCE(vcpu->mode, EXITING_GUEST_MODE);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Note, the vCPU could get migrated to a different pCPU at any point\n\t * after kvm_arch_vcpu_should_kick(), which could result in sending an\n\t * IPI to the previous pCPU.  But, that's ok because the purpose of the\n\t * IPI is to force the vCPU to leave IN_GUEST_MODE, and migrating the\n\t * vCPU also requires it to leave IN_GUEST_MODE.\n\t */\n\tif (kvm_arch_vcpu_should_kick(vcpu)) {\n\t\tcpu = READ_ONCE(vcpu->cpu);\n\t\tif (cpu != me && (unsigned)cpu < nr_cpu_ids && cpu_online(cpu))\n\t\t\tsmp_send_reschedule(cpu);\n\t}\nout:\n\tput_cpu();\n}\nEXPORT_SYMBOL_GPL(kvm_vcpu_kick);\n#endif /* !CONFIG_S390 */\n\nint kvm_vcpu_yield_to(struct kvm_vcpu *target)\n{\n\tstruct pid *pid;\n\tstruct task_struct *task = NULL;\n\tint ret = 0;\n\n\trcu_read_lock();\n\tpid = rcu_dereference(target->pid);\n\tif (pid)\n\t\ttask = get_pid_task(pid, PIDTYPE_PID);\n\trcu_read_unlock();\n\tif (!task)\n\t\treturn ret;\n\tret = yield_to(task, 1);\n\tput_task_struct(task);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(kvm_vcpu_yield_to);\n\n/*\n * Helper that checks whether a VCPU is eligible for directed yield.\n * Most eligible candidate to yield is decided by following heuristics:\n *\n *  (a) VCPU which has not done pl-exit or cpu relax intercepted recently\n *  (preempted lock holder), indicated by @in_spin_loop.\n *  Set at the beginning and cleared at the end of interception/PLE handler.\n *\n *  (b) VCPU which has done pl-exit/ cpu relax intercepted but did not get\n *  chance last time (mostly it has become eligible now since we have probably\n *  yielded to lockholder in last iteration. This is done by toggling\n *  @dy_eligible each time a VCPU checked for eligibility.)\n *\n *  Yielding to a recently pl-exited/cpu relax intercepted VCPU before yielding\n *  to preempted lock-holder could result in wrong VCPU selection and CPU\n *  burning. Giving priority for a potential lock-holder increases lock\n *  progress.\n *\n *  Since algorithm is based on heuristics, accessing another VCPU data without\n *  locking does not harm. It may result in trying to yield to  same VCPU, fail\n *  and continue with next VCPU and so on.\n */\nstatic bool kvm_vcpu_eligible_for_directed_yield(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_HAVE_KVM_CPU_RELAX_INTERCEPT\n\tbool eligible;\n\n\teligible = !vcpu->spin_loop.in_spin_loop ||\n\t\t    vcpu->spin_loop.dy_eligible;\n\n\tif (vcpu->spin_loop.in_spin_loop)\n\t\tkvm_vcpu_set_dy_eligible(vcpu, !vcpu->spin_loop.dy_eligible);\n\n\treturn eligible;\n#else\n\treturn true;\n#endif\n}\n\n/*\n * Unlike kvm_arch_vcpu_runnable, this function is called outside\n * a vcpu_load/vcpu_put pair.  However, for most architectures\n * kvm_arch_vcpu_runnable does not require vcpu_load.\n */\nbool __weak kvm_arch_dy_runnable(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_arch_vcpu_runnable(vcpu);\n}\n\nstatic bool vcpu_dy_runnable(struct kvm_vcpu *vcpu)\n{\n\tif (kvm_arch_dy_runnable(vcpu))\n\t\treturn true;\n\n#ifdef CONFIG_KVM_ASYNC_PF\n\tif (!list_empty_careful(&vcpu->async_pf.done))\n\t\treturn true;\n#endif\n\n\treturn false;\n}\n\nbool __weak kvm_arch_dy_has_pending_interrupt(struct kvm_vcpu *vcpu)\n{\n\treturn false;\n}\n\nvoid kvm_vcpu_on_spin(struct kvm_vcpu *me, bool yield_to_kernel_mode)\n{\n\tstruct kvm *kvm = me->kvm;\n\tstruct kvm_vcpu *vcpu;\n\tint last_boosted_vcpu = me->kvm->last_boosted_vcpu;\n\tunsigned long i;\n\tint yielded = 0;\n\tint try = 3;\n\tint pass;\n\n\tkvm_vcpu_set_in_spin_loop(me, true);\n\t/*\n\t * We boost the priority of a VCPU that is runnable but not\n\t * currently running, because it got preempted by something\n\t * else and called schedule in __vcpu_run.  Hopefully that\n\t * VCPU is holding the lock that we need and will release it.\n\t * We approximate round-robin by starting at the last boosted VCPU.\n\t */\n\tfor (pass = 0; pass < 2 && !yielded && try; pass++) {\n\t\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\t\tif (!pass && i <= last_boosted_vcpu) {\n\t\t\t\ti = last_boosted_vcpu;\n\t\t\t\tcontinue;\n\t\t\t} else if (pass && i > last_boosted_vcpu)\n\t\t\t\tbreak;\n\t\t\tif (!READ_ONCE(vcpu->ready))\n\t\t\t\tcontinue;\n\t\t\tif (vcpu == me)\n\t\t\t\tcontinue;\n\t\t\tif (kvm_vcpu_is_blocking(vcpu) && !vcpu_dy_runnable(vcpu))\n\t\t\t\tcontinue;\n\t\t\tif (READ_ONCE(vcpu->preempted) && yield_to_kernel_mode &&\n\t\t\t    !kvm_arch_dy_has_pending_interrupt(vcpu) &&\n\t\t\t    !kvm_arch_vcpu_in_kernel(vcpu))\n\t\t\t\tcontinue;\n\t\t\tif (!kvm_vcpu_eligible_for_directed_yield(vcpu))\n\t\t\t\tcontinue;\n\n\t\t\tyielded = kvm_vcpu_yield_to(vcpu);\n\t\t\tif (yielded > 0) {\n\t\t\t\tkvm->last_boosted_vcpu = i;\n\t\t\t\tbreak;\n\t\t\t} else if (yielded < 0) {\n\t\t\t\ttry--;\n\t\t\t\tif (!try)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tkvm_vcpu_set_in_spin_loop(me, false);\n\n\t/* Ensure vcpu is not eligible during next spinloop */\n\tkvm_vcpu_set_dy_eligible(me, false);\n}\nEXPORT_SYMBOL_GPL(kvm_vcpu_on_spin);\n\nstatic bool kvm_page_in_dirty_ring(struct kvm *kvm, unsigned long pgoff)\n{\n#ifdef CONFIG_HAVE_KVM_DIRTY_RING\n\treturn (pgoff >= KVM_DIRTY_LOG_PAGE_OFFSET) &&\n\t    (pgoff < KVM_DIRTY_LOG_PAGE_OFFSET +\n\t     kvm->dirty_ring_size / PAGE_SIZE);\n#else\n\treturn false;\n#endif\n}\n\nstatic vm_fault_t kvm_vcpu_fault(struct vm_fault *vmf)\n{\n\tstruct kvm_vcpu *vcpu = vmf->vma->vm_file->private_data;\n\tstruct page *page;\n\n\tif (vmf->pgoff == 0)\n\t\tpage = virt_to_page(vcpu->run);\n#ifdef CONFIG_X86\n\telse if (vmf->pgoff == KVM_PIO_PAGE_OFFSET)\n\t\tpage = virt_to_page(vcpu->arch.pio_data);\n#endif\n#ifdef CONFIG_KVM_MMIO\n\telse if (vmf->pgoff == KVM_COALESCED_MMIO_PAGE_OFFSET)\n\t\tpage = virt_to_page(vcpu->kvm->coalesced_mmio_ring);\n#endif\n\telse if (kvm_page_in_dirty_ring(vcpu->kvm, vmf->pgoff))\n\t\tpage = kvm_dirty_ring_get_page(\n\t\t    &vcpu->dirty_ring,\n\t\t    vmf->pgoff - KVM_DIRTY_LOG_PAGE_OFFSET);\n\telse\n\t\treturn kvm_arch_vcpu_fault(vcpu, vmf);\n\tget_page(page);\n\tvmf->page = page;\n\treturn 0;\n}\n\nstatic const struct vm_operations_struct kvm_vcpu_vm_ops = {\n\t.fault = kvm_vcpu_fault,\n};\n\nstatic int kvm_vcpu_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct kvm_vcpu *vcpu = file->private_data;\n\tunsigned long pages = vma_pages(vma);\n\n\tif ((kvm_page_in_dirty_ring(vcpu->kvm, vma->vm_pgoff) ||\n\t     kvm_page_in_dirty_ring(vcpu->kvm, vma->vm_pgoff + pages - 1)) &&\n\t    ((vma->vm_flags & VM_EXEC) || !(vma->vm_flags & VM_SHARED)))\n\t\treturn -EINVAL;\n\n\tvma->vm_ops = &kvm_vcpu_vm_ops;\n\treturn 0;\n}\n\nstatic int kvm_vcpu_release(struct inode *inode, struct file *filp)\n{\n\tstruct kvm_vcpu *vcpu = filp->private_data;\n\n\tkvm_put_kvm(vcpu->kvm);\n\treturn 0;\n}\n\nstatic const struct file_operations kvm_vcpu_fops = {\n\t.release        = kvm_vcpu_release,\n\t.unlocked_ioctl = kvm_vcpu_ioctl,\n\t.mmap           = kvm_vcpu_mmap,\n\t.llseek\t\t= noop_llseek,\n\tKVM_COMPAT(kvm_vcpu_compat_ioctl),\n};\n\n/*\n * Allocates an inode for the vcpu.\n */\nstatic int create_vcpu_fd(struct kvm_vcpu *vcpu)\n{\n\tchar name[8 + 1 + ITOA_MAX_LEN + 1];\n\n\tsnprintf(name, sizeof(name), \"kvm-vcpu:%d\", vcpu->vcpu_id);\n\treturn anon_inode_getfd(name, &kvm_vcpu_fops, vcpu, O_RDWR | O_CLOEXEC);\n}\n\nstatic void kvm_create_vcpu_debugfs(struct kvm_vcpu *vcpu)\n{\n#ifdef __KVM_HAVE_ARCH_VCPU_DEBUGFS\n\tstruct dentry *debugfs_dentry;\n\tchar dir_name[ITOA_MAX_LEN * 2];\n\n\tif (!debugfs_initialized())\n\t\treturn;\n\n\tsnprintf(dir_name, sizeof(dir_name), \"vcpu%d\", vcpu->vcpu_id);\n\tdebugfs_dentry = debugfs_create_dir(dir_name,\n\t\t\t\t\t    vcpu->kvm->debugfs_dentry);\n\n\tkvm_arch_create_vcpu_debugfs(vcpu, debugfs_dentry);\n#endif\n}\n\n/*\n * Creates some virtual cpus.  Good luck creating more than one.\n */\nstatic int kvm_vm_ioctl_create_vcpu(struct kvm *kvm, u32 id)\n{\n\tint r;\n\tstruct kvm_vcpu *vcpu;\n\tstruct page *page;\n\n\tif (id >= KVM_MAX_VCPU_IDS)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&kvm->lock);\n\tif (kvm->created_vcpus == KVM_MAX_VCPUS) {\n\t\tmutex_unlock(&kvm->lock);\n\t\treturn -EINVAL;\n\t}\n\n\tkvm->created_vcpus++;\n\tmutex_unlock(&kvm->lock);\n\n\tr = kvm_arch_vcpu_precreate(kvm, id);\n\tif (r)\n\t\tgoto vcpu_decrement;\n\n\tvcpu = kmem_cache_zalloc(kvm_vcpu_cache, GFP_KERNEL_ACCOUNT);\n\tif (!vcpu) {\n\t\tr = -ENOMEM;\n\t\tgoto vcpu_decrement;\n\t}\n\n\tBUILD_BUG_ON(sizeof(struct kvm_run) > PAGE_SIZE);\n\tpage = alloc_page(GFP_KERNEL_ACCOUNT | __GFP_ZERO);\n\tif (!page) {\n\t\tr = -ENOMEM;\n\t\tgoto vcpu_free;\n\t}\n\tvcpu->run = page_address(page);\n\n\tkvm_vcpu_init(vcpu, kvm, id);\n\n\tr = kvm_arch_vcpu_create(vcpu);\n\tif (r)\n\t\tgoto vcpu_free_run_page;\n\n\tif (kvm->dirty_ring_size) {\n\t\tr = kvm_dirty_ring_alloc(&vcpu->dirty_ring,\n\t\t\t\t\t id, kvm->dirty_ring_size);\n\t\tif (r)\n\t\t\tgoto arch_vcpu_destroy;\n\t}\n\n\tmutex_lock(&kvm->lock);\n\tif (kvm_get_vcpu_by_id(kvm, id)) {\n\t\tr = -EEXIST;\n\t\tgoto unlock_vcpu_destroy;\n\t}\n\n\tvcpu->vcpu_idx = atomic_read(&kvm->online_vcpus);\n\tr = xa_insert(&kvm->vcpu_array, vcpu->vcpu_idx, vcpu, GFP_KERNEL_ACCOUNT);\n\tBUG_ON(r == -EBUSY);\n\tif (r)\n\t\tgoto unlock_vcpu_destroy;\n\n\t/* Fill the stats id string for the vcpu */\n\tsnprintf(vcpu->stats_id, sizeof(vcpu->stats_id), \"kvm-%d/vcpu-%d\",\n\t\t task_pid_nr(current), id);\n\n\t/* Now it's all set up, let userspace reach it */\n\tkvm_get_kvm(kvm);\n\tr = create_vcpu_fd(vcpu);\n\tif (r < 0) {\n\t\txa_erase(&kvm->vcpu_array, vcpu->vcpu_idx);\n\t\tkvm_put_kvm_no_destroy(kvm);\n\t\tgoto unlock_vcpu_destroy;\n\t}\n\n\t/*\n\t * Pairs with smp_rmb() in kvm_get_vcpu.  Store the vcpu\n\t * pointer before kvm->online_vcpu's incremented value.\n\t */\n\tsmp_wmb();\n\tatomic_inc(&kvm->online_vcpus);\n\n\tmutex_unlock(&kvm->lock);\n\tkvm_arch_vcpu_postcreate(vcpu);\n\tkvm_create_vcpu_debugfs(vcpu);\n\treturn r;\n\nunlock_vcpu_destroy:\n\tmutex_unlock(&kvm->lock);\n\tkvm_dirty_ring_free(&vcpu->dirty_ring);\narch_vcpu_destroy:\n\tkvm_arch_vcpu_destroy(vcpu);\nvcpu_free_run_page:\n\tfree_page((unsigned long)vcpu->run);\nvcpu_free:\n\tkmem_cache_free(kvm_vcpu_cache, vcpu);\nvcpu_decrement:\n\tmutex_lock(&kvm->lock);\n\tkvm->created_vcpus--;\n\tmutex_unlock(&kvm->lock);\n\treturn r;\n}\n\nstatic int kvm_vcpu_ioctl_set_sigmask(struct kvm_vcpu *vcpu, sigset_t *sigset)\n{\n\tif (sigset) {\n\t\tsigdelsetmask(sigset, sigmask(SIGKILL)|sigmask(SIGSTOP));\n\t\tvcpu->sigset_active = 1;\n\t\tvcpu->sigset = *sigset;\n\t} else\n\t\tvcpu->sigset_active = 0;\n\treturn 0;\n}\n\nstatic ssize_t kvm_vcpu_stats_read(struct file *file, char __user *user_buffer,\n\t\t\t      size_t size, loff_t *offset)\n{\n\tstruct kvm_vcpu *vcpu = file->private_data;\n\n\treturn kvm_stats_read(vcpu->stats_id, &kvm_vcpu_stats_header,\n\t\t\t&kvm_vcpu_stats_desc[0], &vcpu->stat,\n\t\t\tsizeof(vcpu->stat), user_buffer, size, offset);\n}\n\nstatic const struct file_operations kvm_vcpu_stats_fops = {\n\t.read = kvm_vcpu_stats_read,\n\t.llseek = noop_llseek,\n};\n\nstatic int kvm_vcpu_ioctl_get_stats_fd(struct kvm_vcpu *vcpu)\n{\n\tint fd;\n\tstruct file *file;\n\tchar name[15 + ITOA_MAX_LEN + 1];\n\n\tsnprintf(name, sizeof(name), \"kvm-vcpu-stats:%d\", vcpu->vcpu_id);\n\n\tfd = get_unused_fd_flags(O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn fd;\n\n\tfile = anon_inode_getfile(name, &kvm_vcpu_stats_fops, vcpu, O_RDONLY);\n\tif (IS_ERR(file)) {\n\t\tput_unused_fd(fd);\n\t\treturn PTR_ERR(file);\n\t}\n\tfile->f_mode |= FMODE_PREAD;\n\tfd_install(fd, file);\n\n\treturn fd;\n}\n\nstatic long kvm_vcpu_ioctl(struct file *filp,\n\t\t\t   unsigned int ioctl, unsigned long arg)\n{\n\tstruct kvm_vcpu *vcpu = filp->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tint r;\n\tstruct kvm_fpu *fpu = NULL;\n\tstruct kvm_sregs *kvm_sregs = NULL;\n\n\tif (vcpu->kvm->mm != current->mm || vcpu->kvm->vm_dead)\n\t\treturn -EIO;\n\n\tif (unlikely(_IOC_TYPE(ioctl) != KVMIO))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Some architectures have vcpu ioctls that are asynchronous to vcpu\n\t * execution; mutex_lock() would break them.\n\t */\n\tr = kvm_arch_vcpu_async_ioctl(filp, ioctl, arg);\n\tif (r != -ENOIOCTLCMD)\n\t\treturn r;\n\n\tif (mutex_lock_killable(&vcpu->mutex))\n\t\treturn -EINTR;\n\tswitch (ioctl) {\n\tcase KVM_RUN: {\n\t\tstruct pid *oldpid;\n\t\tr = -EINVAL;\n\t\tif (arg)\n\t\t\tgoto out;\n\t\toldpid = rcu_access_pointer(vcpu->pid);\n\t\tif (unlikely(oldpid != task_pid(current))) {\n\t\t\t/* The thread running this VCPU changed. */\n\t\t\tstruct pid *newpid;\n\n\t\t\tr = kvm_arch_vcpu_run_pid_change(vcpu);\n\t\t\tif (r)\n\t\t\t\tbreak;\n\n\t\t\tnewpid = get_task_pid(current, PIDTYPE_PID);\n\t\t\trcu_assign_pointer(vcpu->pid, newpid);\n\t\t\tif (oldpid)\n\t\t\t\tsynchronize_rcu();\n\t\t\tput_pid(oldpid);\n\t\t}\n\t\tr = kvm_arch_vcpu_ioctl_run(vcpu);\n\t\ttrace_kvm_userspace_exit(vcpu->run->exit_reason, r);\n\t\tbreak;\n\t}\n\tcase KVM_GET_REGS: {\n\t\tstruct kvm_regs *kvm_regs;\n\n\t\tr = -ENOMEM;\n\t\tkvm_regs = kzalloc(sizeof(struct kvm_regs), GFP_KERNEL_ACCOUNT);\n\t\tif (!kvm_regs)\n\t\t\tgoto out;\n\t\tr = kvm_arch_vcpu_ioctl_get_regs(vcpu, kvm_regs);\n\t\tif (r)\n\t\t\tgoto out_free1;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, kvm_regs, sizeof(struct kvm_regs)))\n\t\t\tgoto out_free1;\n\t\tr = 0;\nout_free1:\n\t\tkfree(kvm_regs);\n\t\tbreak;\n\t}\n\tcase KVM_SET_REGS: {\n\t\tstruct kvm_regs *kvm_regs;\n\n\t\tkvm_regs = memdup_user(argp, sizeof(*kvm_regs));\n\t\tif (IS_ERR(kvm_regs)) {\n\t\t\tr = PTR_ERR(kvm_regs);\n\t\t\tgoto out;\n\t\t}\n\t\tr = kvm_arch_vcpu_ioctl_set_regs(vcpu, kvm_regs);\n\t\tkfree(kvm_regs);\n\t\tbreak;\n\t}\n\tcase KVM_GET_SREGS: {\n\t\tkvm_sregs = kzalloc(sizeof(struct kvm_sregs),\n\t\t\t\t    GFP_KERNEL_ACCOUNT);\n\t\tr = -ENOMEM;\n\t\tif (!kvm_sregs)\n\t\t\tgoto out;\n\t\tr = kvm_arch_vcpu_ioctl_get_sregs(vcpu, kvm_sregs);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, kvm_sregs, sizeof(struct kvm_sregs)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_SREGS: {\n\t\tkvm_sregs = memdup_user(argp, sizeof(*kvm_sregs));\n\t\tif (IS_ERR(kvm_sregs)) {\n\t\t\tr = PTR_ERR(kvm_sregs);\n\t\t\tkvm_sregs = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tr = kvm_arch_vcpu_ioctl_set_sregs(vcpu, kvm_sregs);\n\t\tbreak;\n\t}\n\tcase KVM_GET_MP_STATE: {\n\t\tstruct kvm_mp_state mp_state;\n\n\t\tr = kvm_arch_vcpu_ioctl_get_mpstate(vcpu, &mp_state);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &mp_state, sizeof(mp_state)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_MP_STATE: {\n\t\tstruct kvm_mp_state mp_state;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&mp_state, argp, sizeof(mp_state)))\n\t\t\tgoto out;\n\t\tr = kvm_arch_vcpu_ioctl_set_mpstate(vcpu, &mp_state);\n\t\tbreak;\n\t}\n\tcase KVM_TRANSLATE: {\n\t\tstruct kvm_translation tr;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&tr, argp, sizeof(tr)))\n\t\t\tgoto out;\n\t\tr = kvm_arch_vcpu_ioctl_translate(vcpu, &tr);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &tr, sizeof(tr)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_GUEST_DEBUG: {\n\t\tstruct kvm_guest_debug dbg;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&dbg, argp, sizeof(dbg)))\n\t\t\tgoto out;\n\t\tr = kvm_arch_vcpu_ioctl_set_guest_debug(vcpu, &dbg);\n\t\tbreak;\n\t}\n\tcase KVM_SET_SIGNAL_MASK: {\n\t\tstruct kvm_signal_mask __user *sigmask_arg = argp;\n\t\tstruct kvm_signal_mask kvm_sigmask;\n\t\tsigset_t sigset, *p;\n\n\t\tp = NULL;\n\t\tif (argp) {\n\t\t\tr = -EFAULT;\n\t\t\tif (copy_from_user(&kvm_sigmask, argp,\n\t\t\t\t\t   sizeof(kvm_sigmask)))\n\t\t\t\tgoto out;\n\t\t\tr = -EINVAL;\n\t\t\tif (kvm_sigmask.len != sizeof(sigset))\n\t\t\t\tgoto out;\n\t\t\tr = -EFAULT;\n\t\t\tif (copy_from_user(&sigset, sigmask_arg->sigset,\n\t\t\t\t\t   sizeof(sigset)))\n\t\t\t\tgoto out;\n\t\t\tp = &sigset;\n\t\t}\n\t\tr = kvm_vcpu_ioctl_set_sigmask(vcpu, p);\n\t\tbreak;\n\t}\n\tcase KVM_GET_FPU: {\n\t\tfpu = kzalloc(sizeof(struct kvm_fpu), GFP_KERNEL_ACCOUNT);\n\t\tr = -ENOMEM;\n\t\tif (!fpu)\n\t\t\tgoto out;\n\t\tr = kvm_arch_vcpu_ioctl_get_fpu(vcpu, fpu);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, fpu, sizeof(struct kvm_fpu)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_FPU: {\n\t\tfpu = memdup_user(argp, sizeof(*fpu));\n\t\tif (IS_ERR(fpu)) {\n\t\t\tr = PTR_ERR(fpu);\n\t\t\tfpu = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tr = kvm_arch_vcpu_ioctl_set_fpu(vcpu, fpu);\n\t\tbreak;\n\t}\n\tcase KVM_GET_STATS_FD: {\n\t\tr = kvm_vcpu_ioctl_get_stats_fd(vcpu);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tr = kvm_arch_vcpu_ioctl(filp, ioctl, arg);\n\t}\nout:\n\tmutex_unlock(&vcpu->mutex);\n\tkfree(fpu);\n\tkfree(kvm_sregs);\n\treturn r;\n}\n\n#ifdef CONFIG_KVM_COMPAT\nstatic long kvm_vcpu_compat_ioctl(struct file *filp,\n\t\t\t\t  unsigned int ioctl, unsigned long arg)\n{\n\tstruct kvm_vcpu *vcpu = filp->private_data;\n\tvoid __user *argp = compat_ptr(arg);\n\tint r;\n\n\tif (vcpu->kvm->mm != current->mm || vcpu->kvm->vm_dead)\n\t\treturn -EIO;\n\n\tswitch (ioctl) {\n\tcase KVM_SET_SIGNAL_MASK: {\n\t\tstruct kvm_signal_mask __user *sigmask_arg = argp;\n\t\tstruct kvm_signal_mask kvm_sigmask;\n\t\tsigset_t sigset;\n\n\t\tif (argp) {\n\t\t\tr = -EFAULT;\n\t\t\tif (copy_from_user(&kvm_sigmask, argp,\n\t\t\t\t\t   sizeof(kvm_sigmask)))\n\t\t\t\tgoto out;\n\t\t\tr = -EINVAL;\n\t\t\tif (kvm_sigmask.len != sizeof(compat_sigset_t))\n\t\t\t\tgoto out;\n\t\t\tr = -EFAULT;\n\t\t\tif (get_compat_sigset(&sigset,\n\t\t\t\t\t      (compat_sigset_t __user *)sigmask_arg->sigset))\n\t\t\t\tgoto out;\n\t\t\tr = kvm_vcpu_ioctl_set_sigmask(vcpu, &sigset);\n\t\t} else\n\t\t\tr = kvm_vcpu_ioctl_set_sigmask(vcpu, NULL);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tr = kvm_vcpu_ioctl(filp, ioctl, arg);\n\t}\n\nout:\n\treturn r;\n}\n#endif\n\nstatic int kvm_device_mmap(struct file *filp, struct vm_area_struct *vma)\n{\n\tstruct kvm_device *dev = filp->private_data;\n\n\tif (dev->ops->mmap)\n\t\treturn dev->ops->mmap(dev, vma);\n\n\treturn -ENODEV;\n}\n\nstatic int kvm_device_ioctl_attr(struct kvm_device *dev,\n\t\t\t\t int (*accessor)(struct kvm_device *dev,\n\t\t\t\t\t\t struct kvm_device_attr *attr),\n\t\t\t\t unsigned long arg)\n{\n\tstruct kvm_device_attr attr;\n\n\tif (!accessor)\n\t\treturn -EPERM;\n\n\tif (copy_from_user(&attr, (void __user *)arg, sizeof(attr)))\n\t\treturn -EFAULT;\n\n\treturn accessor(dev, &attr);\n}\n\nstatic long kvm_device_ioctl(struct file *filp, unsigned int ioctl,\n\t\t\t     unsigned long arg)\n{\n\tstruct kvm_device *dev = filp->private_data;\n\n\tif (dev->kvm->mm != current->mm || dev->kvm->vm_dead)\n\t\treturn -EIO;\n\n\tswitch (ioctl) {\n\tcase KVM_SET_DEVICE_ATTR:\n\t\treturn kvm_device_ioctl_attr(dev, dev->ops->set_attr, arg);\n\tcase KVM_GET_DEVICE_ATTR:\n\t\treturn kvm_device_ioctl_attr(dev, dev->ops->get_attr, arg);\n\tcase KVM_HAS_DEVICE_ATTR:\n\t\treturn kvm_device_ioctl_attr(dev, dev->ops->has_attr, arg);\n\tdefault:\n\t\tif (dev->ops->ioctl)\n\t\t\treturn dev->ops->ioctl(dev, ioctl, arg);\n\n\t\treturn -ENOTTY;\n\t}\n}\n\nstatic int kvm_device_release(struct inode *inode, struct file *filp)\n{\n\tstruct kvm_device *dev = filp->private_data;\n\tstruct kvm *kvm = dev->kvm;\n\n\tif (dev->ops->release) {\n\t\tmutex_lock(&kvm->lock);\n\t\tlist_del(&dev->vm_node);\n\t\tdev->ops->release(dev);\n\t\tmutex_unlock(&kvm->lock);\n\t}\n\n\tkvm_put_kvm(kvm);\n\treturn 0;\n}\n\nstatic const struct file_operations kvm_device_fops = {\n\t.unlocked_ioctl = kvm_device_ioctl,\n\t.release = kvm_device_release,\n\tKVM_COMPAT(kvm_device_ioctl),\n\t.mmap = kvm_device_mmap,\n};\n\nstruct kvm_device *kvm_device_from_filp(struct file *filp)\n{\n\tif (filp->f_op != &kvm_device_fops)\n\t\treturn NULL;\n\n\treturn filp->private_data;\n}\n\nstatic const struct kvm_device_ops *kvm_device_ops_table[KVM_DEV_TYPE_MAX] = {\n#ifdef CONFIG_KVM_MPIC\n\t[KVM_DEV_TYPE_FSL_MPIC_20]\t= &kvm_mpic_ops,\n\t[KVM_DEV_TYPE_FSL_MPIC_42]\t= &kvm_mpic_ops,\n#endif\n};\n\nint kvm_register_device_ops(const struct kvm_device_ops *ops, u32 type)\n{\n\tif (type >= ARRAY_SIZE(kvm_device_ops_table))\n\t\treturn -ENOSPC;\n\n\tif (kvm_device_ops_table[type] != NULL)\n\t\treturn -EEXIST;\n\n\tkvm_device_ops_table[type] = ops;\n\treturn 0;\n}\n\nvoid kvm_unregister_device_ops(u32 type)\n{\n\tif (kvm_device_ops_table[type] != NULL)\n\t\tkvm_device_ops_table[type] = NULL;\n}\n\nstatic int kvm_ioctl_create_device(struct kvm *kvm,\n\t\t\t\t   struct kvm_create_device *cd)\n{\n\tconst struct kvm_device_ops *ops = NULL;\n\tstruct kvm_device *dev;\n\tbool test = cd->flags & KVM_CREATE_DEVICE_TEST;\n\tint type;\n\tint ret;\n\n\tif (cd->type >= ARRAY_SIZE(kvm_device_ops_table))\n\t\treturn -ENODEV;\n\n\ttype = array_index_nospec(cd->type, ARRAY_SIZE(kvm_device_ops_table));\n\tops = kvm_device_ops_table[type];\n\tif (ops == NULL)\n\t\treturn -ENODEV;\n\n\tif (test)\n\t\treturn 0;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL_ACCOUNT);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdev->ops = ops;\n\tdev->kvm = kvm;\n\n\tmutex_lock(&kvm->lock);\n\tret = ops->create(dev, type);\n\tif (ret < 0) {\n\t\tmutex_unlock(&kvm->lock);\n\t\tkfree(dev);\n\t\treturn ret;\n\t}\n\tlist_add(&dev->vm_node, &kvm->devices);\n\tmutex_unlock(&kvm->lock);\n\n\tif (ops->init)\n\t\tops->init(dev);\n\n\tkvm_get_kvm(kvm);\n\tret = anon_inode_getfd(ops->name, &kvm_device_fops, dev, O_RDWR | O_CLOEXEC);\n\tif (ret < 0) {\n\t\tkvm_put_kvm_no_destroy(kvm);\n\t\tmutex_lock(&kvm->lock);\n\t\tlist_del(&dev->vm_node);\n\t\tmutex_unlock(&kvm->lock);\n\t\tops->destroy(dev);\n\t\treturn ret;\n\t}\n\n\tcd->fd = ret;\n\treturn 0;\n}\n\nstatic long kvm_vm_ioctl_check_extension_generic(struct kvm *kvm, long arg)\n{\n\tswitch (arg) {\n\tcase KVM_CAP_USER_MEMORY:\n\tcase KVM_CAP_DESTROY_MEMORY_REGION_WORKS:\n\tcase KVM_CAP_JOIN_MEMORY_REGIONS_WORKS:\n\tcase KVM_CAP_INTERNAL_ERROR_DATA:\n#ifdef CONFIG_HAVE_KVM_MSI\n\tcase KVM_CAP_SIGNAL_MSI:\n#endif\n#ifdef CONFIG_HAVE_KVM_IRQFD\n\tcase KVM_CAP_IRQFD:\n\tcase KVM_CAP_IRQFD_RESAMPLE:\n#endif\n\tcase KVM_CAP_IOEVENTFD_ANY_LENGTH:\n\tcase KVM_CAP_CHECK_EXTENSION_VM:\n\tcase KVM_CAP_ENABLE_CAP_VM:\n\tcase KVM_CAP_HALT_POLL:\n\t\treturn 1;\n#ifdef CONFIG_KVM_MMIO\n\tcase KVM_CAP_COALESCED_MMIO:\n\t\treturn KVM_COALESCED_MMIO_PAGE_OFFSET;\n\tcase KVM_CAP_COALESCED_PIO:\n\t\treturn 1;\n#endif\n#ifdef CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT\n\tcase KVM_CAP_MANUAL_DIRTY_LOG_PROTECT2:\n\t\treturn KVM_DIRTY_LOG_MANUAL_CAPS;\n#endif\n#ifdef CONFIG_HAVE_KVM_IRQ_ROUTING\n\tcase KVM_CAP_IRQ_ROUTING:\n\t\treturn KVM_MAX_IRQ_ROUTES;\n#endif\n#if KVM_ADDRESS_SPACE_NUM > 1\n\tcase KVM_CAP_MULTI_ADDRESS_SPACE:\n\t\treturn KVM_ADDRESS_SPACE_NUM;\n#endif\n\tcase KVM_CAP_NR_MEMSLOTS:\n\t\treturn KVM_USER_MEM_SLOTS;\n\tcase KVM_CAP_DIRTY_LOG_RING:\n#ifdef CONFIG_HAVE_KVM_DIRTY_RING\n\t\treturn KVM_DIRTY_RING_MAX_ENTRIES * sizeof(struct kvm_dirty_gfn);\n#else\n\t\treturn 0;\n#endif\n\tcase KVM_CAP_BINARY_STATS_FD:\n\t\treturn 1;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn kvm_vm_ioctl_check_extension(kvm, arg);\n}\n\nstatic int kvm_vm_ioctl_enable_dirty_log_ring(struct kvm *kvm, u32 size)\n{\n\tint r;\n\n\tif (!KVM_DIRTY_LOG_PAGE_OFFSET)\n\t\treturn -EINVAL;\n\n\t/* the size should be power of 2 */\n\tif (!size || (size & (size - 1)))\n\t\treturn -EINVAL;\n\n\t/* Should be bigger to keep the reserved entries, or a page */\n\tif (size < kvm_dirty_ring_get_rsvd_entries() *\n\t    sizeof(struct kvm_dirty_gfn) || size < PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tif (size > KVM_DIRTY_RING_MAX_ENTRIES *\n\t    sizeof(struct kvm_dirty_gfn))\n\t\treturn -E2BIG;\n\n\t/* We only allow it to set once */\n\tif (kvm->dirty_ring_size)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&kvm->lock);\n\n\tif (kvm->created_vcpus) {\n\t\t/* We don't allow to change this value after vcpu created */\n\t\tr = -EINVAL;\n\t} else {\n\t\tkvm->dirty_ring_size = size;\n\t\tr = 0;\n\t}\n\n\tmutex_unlock(&kvm->lock);\n\treturn r;\n}\n\nstatic int kvm_vm_ioctl_reset_dirty_pages(struct kvm *kvm)\n{\n\tunsigned long i;\n\tstruct kvm_vcpu *vcpu;\n\tint cleared = 0;\n\n\tif (!kvm->dirty_ring_size)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&kvm->slots_lock);\n\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tcleared += kvm_dirty_ring_reset(vcpu->kvm, &vcpu->dirty_ring);\n\n\tmutex_unlock(&kvm->slots_lock);\n\n\tif (cleared)\n\t\tkvm_flush_remote_tlbs(kvm);\n\n\treturn cleared;\n}\n\nint __attribute__((weak)) kvm_vm_ioctl_enable_cap(struct kvm *kvm,\n\t\t\t\t\t\t  struct kvm_enable_cap *cap)\n{\n\treturn -EINVAL;\n}\n\nstatic int kvm_vm_ioctl_enable_cap_generic(struct kvm *kvm,\n\t\t\t\t\t   struct kvm_enable_cap *cap)\n{\n\tswitch (cap->cap) {\n#ifdef CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT\n\tcase KVM_CAP_MANUAL_DIRTY_LOG_PROTECT2: {\n\t\tu64 allowed_options = KVM_DIRTY_LOG_MANUAL_PROTECT_ENABLE;\n\n\t\tif (cap->args[0] & KVM_DIRTY_LOG_MANUAL_PROTECT_ENABLE)\n\t\t\tallowed_options = KVM_DIRTY_LOG_MANUAL_CAPS;\n\n\t\tif (cap->flags || (cap->args[0] & ~allowed_options))\n\t\t\treturn -EINVAL;\n\t\tkvm->manual_dirty_log_protect = cap->args[0];\n\t\treturn 0;\n\t}\n#endif\n\tcase KVM_CAP_HALT_POLL: {\n\t\tif (cap->flags || cap->args[0] != (unsigned int)cap->args[0])\n\t\t\treturn -EINVAL;\n\n\t\tkvm->max_halt_poll_ns = cap->args[0];\n\t\treturn 0;\n\t}\n\tcase KVM_CAP_DIRTY_LOG_RING:\n\t\treturn kvm_vm_ioctl_enable_dirty_log_ring(kvm, cap->args[0]);\n\tdefault:\n\t\treturn kvm_vm_ioctl_enable_cap(kvm, cap);\n\t}\n}\n\nstatic ssize_t kvm_vm_stats_read(struct file *file, char __user *user_buffer,\n\t\t\t      size_t size, loff_t *offset)\n{\n\tstruct kvm *kvm = file->private_data;\n\n\treturn kvm_stats_read(kvm->stats_id, &kvm_vm_stats_header,\n\t\t\t\t&kvm_vm_stats_desc[0], &kvm->stat,\n\t\t\t\tsizeof(kvm->stat), user_buffer, size, offset);\n}\n\nstatic const struct file_operations kvm_vm_stats_fops = {\n\t.read = kvm_vm_stats_read,\n\t.llseek = noop_llseek,\n};\n\nstatic int kvm_vm_ioctl_get_stats_fd(struct kvm *kvm)\n{\n\tint fd;\n\tstruct file *file;\n\n\tfd = get_unused_fd_flags(O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn fd;\n\n\tfile = anon_inode_getfile(\"kvm-vm-stats\",\n\t\t\t&kvm_vm_stats_fops, kvm, O_RDONLY);\n\tif (IS_ERR(file)) {\n\t\tput_unused_fd(fd);\n\t\treturn PTR_ERR(file);\n\t}\n\tfile->f_mode |= FMODE_PREAD;\n\tfd_install(fd, file);\n\n\treturn fd;\n}\n\nstatic long kvm_vm_ioctl(struct file *filp,\n\t\t\t   unsigned int ioctl, unsigned long arg)\n{\n\tstruct kvm *kvm = filp->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tint r;\n\n\tif (kvm->mm != current->mm || kvm->vm_dead)\n\t\treturn -EIO;\n\tswitch (ioctl) {\n\tcase KVM_CREATE_VCPU:\n\t\tr = kvm_vm_ioctl_create_vcpu(kvm, arg);\n\t\tbreak;\n\tcase KVM_ENABLE_CAP: {\n\t\tstruct kvm_enable_cap cap;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&cap, argp, sizeof(cap)))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_enable_cap_generic(kvm, &cap);\n\t\tbreak;\n\t}\n\tcase KVM_SET_USER_MEMORY_REGION: {\n\t\tstruct kvm_userspace_memory_region kvm_userspace_mem;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&kvm_userspace_mem, argp,\n\t\t\t\t\t\tsizeof(kvm_userspace_mem)))\n\t\t\tgoto out;\n\n\t\tr = kvm_vm_ioctl_set_memory_region(kvm, &kvm_userspace_mem);\n\t\tbreak;\n\t}\n\tcase KVM_GET_DIRTY_LOG: {\n\t\tstruct kvm_dirty_log log;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&log, argp, sizeof(log)))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_get_dirty_log(kvm, &log);\n\t\tbreak;\n\t}\n#ifdef CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT\n\tcase KVM_CLEAR_DIRTY_LOG: {\n\t\tstruct kvm_clear_dirty_log log;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&log, argp, sizeof(log)))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_clear_dirty_log(kvm, &log);\n\t\tbreak;\n\t}\n#endif\n#ifdef CONFIG_KVM_MMIO\n\tcase KVM_REGISTER_COALESCED_MMIO: {\n\t\tstruct kvm_coalesced_mmio_zone zone;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&zone, argp, sizeof(zone)))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_register_coalesced_mmio(kvm, &zone);\n\t\tbreak;\n\t}\n\tcase KVM_UNREGISTER_COALESCED_MMIO: {\n\t\tstruct kvm_coalesced_mmio_zone zone;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&zone, argp, sizeof(zone)))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_unregister_coalesced_mmio(kvm, &zone);\n\t\tbreak;\n\t}\n#endif\n\tcase KVM_IRQFD: {\n\t\tstruct kvm_irqfd data;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&data, argp, sizeof(data)))\n\t\t\tgoto out;\n\t\tr = kvm_irqfd(kvm, &data);\n\t\tbreak;\n\t}\n\tcase KVM_IOEVENTFD: {\n\t\tstruct kvm_ioeventfd data;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&data, argp, sizeof(data)))\n\t\t\tgoto out;\n\t\tr = kvm_ioeventfd(kvm, &data);\n\t\tbreak;\n\t}\n#ifdef CONFIG_HAVE_KVM_MSI\n\tcase KVM_SIGNAL_MSI: {\n\t\tstruct kvm_msi msi;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&msi, argp, sizeof(msi)))\n\t\t\tgoto out;\n\t\tr = kvm_send_userspace_msi(kvm, &msi);\n\t\tbreak;\n\t}\n#endif\n#ifdef __KVM_HAVE_IRQ_LINE\n\tcase KVM_IRQ_LINE_STATUS:\n\tcase KVM_IRQ_LINE: {\n\t\tstruct kvm_irq_level irq_event;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&irq_event, argp, sizeof(irq_event)))\n\t\t\tgoto out;\n\n\t\tr = kvm_vm_ioctl_irq_line(kvm, &irq_event,\n\t\t\t\t\tioctl == KVM_IRQ_LINE_STATUS);\n\t\tif (r)\n\t\t\tgoto out;\n\n\t\tr = -EFAULT;\n\t\tif (ioctl == KVM_IRQ_LINE_STATUS) {\n\t\t\tif (copy_to_user(argp, &irq_event, sizeof(irq_event)))\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tr = 0;\n\t\tbreak;\n\t}\n#endif\n#ifdef CONFIG_HAVE_KVM_IRQ_ROUTING\n\tcase KVM_SET_GSI_ROUTING: {\n\t\tstruct kvm_irq_routing routing;\n\t\tstruct kvm_irq_routing __user *urouting;\n\t\tstruct kvm_irq_routing_entry *entries = NULL;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&routing, argp, sizeof(routing)))\n\t\t\tgoto out;\n\t\tr = -EINVAL;\n\t\tif (!kvm_arch_can_set_irq_routing(kvm))\n\t\t\tgoto out;\n\t\tif (routing.nr > KVM_MAX_IRQ_ROUTES)\n\t\t\tgoto out;\n\t\tif (routing.flags)\n\t\t\tgoto out;\n\t\tif (routing.nr) {\n\t\t\turouting = argp;\n\t\t\tentries = vmemdup_user(urouting->entries,\n\t\t\t\t\t       array_size(sizeof(*entries),\n\t\t\t\t\t\t\t  routing.nr));\n\t\t\tif (IS_ERR(entries)) {\n\t\t\t\tr = PTR_ERR(entries);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tr = kvm_set_irq_routing(kvm, entries, routing.nr,\n\t\t\t\t\trouting.flags);\n\t\tkvfree(entries);\n\t\tbreak;\n\t}\n#endif /* CONFIG_HAVE_KVM_IRQ_ROUTING */\n\tcase KVM_CREATE_DEVICE: {\n\t\tstruct kvm_create_device cd;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&cd, argp, sizeof(cd)))\n\t\t\tgoto out;\n\n\t\tr = kvm_ioctl_create_device(kvm, &cd);\n\t\tif (r)\n\t\t\tgoto out;\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &cd, sizeof(cd)))\n\t\t\tgoto out;\n\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_CHECK_EXTENSION:\n\t\tr = kvm_vm_ioctl_check_extension_generic(kvm, arg);\n\t\tbreak;\n\tcase KVM_RESET_DIRTY_RINGS:\n\t\tr = kvm_vm_ioctl_reset_dirty_pages(kvm);\n\t\tbreak;\n\tcase KVM_GET_STATS_FD:\n\t\tr = kvm_vm_ioctl_get_stats_fd(kvm);\n\t\tbreak;\n\tdefault:\n\t\tr = kvm_arch_vm_ioctl(filp, ioctl, arg);\n\t}\nout:\n\treturn r;\n}\n\n#ifdef CONFIG_KVM_COMPAT\nstruct compat_kvm_dirty_log {\n\t__u32 slot;\n\t__u32 padding1;\n\tunion {\n\t\tcompat_uptr_t dirty_bitmap; /* one bit per page */\n\t\t__u64 padding2;\n\t};\n};\n\nstruct compat_kvm_clear_dirty_log {\n\t__u32 slot;\n\t__u32 num_pages;\n\t__u64 first_page;\n\tunion {\n\t\tcompat_uptr_t dirty_bitmap; /* one bit per page */\n\t\t__u64 padding2;\n\t};\n};\n\nstatic long kvm_vm_compat_ioctl(struct file *filp,\n\t\t\t   unsigned int ioctl, unsigned long arg)\n{\n\tstruct kvm *kvm = filp->private_data;\n\tint r;\n\n\tif (kvm->mm != current->mm || kvm->vm_dead)\n\t\treturn -EIO;\n\tswitch (ioctl) {\n#ifdef CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT\n\tcase KVM_CLEAR_DIRTY_LOG: {\n\t\tstruct compat_kvm_clear_dirty_log compat_log;\n\t\tstruct kvm_clear_dirty_log log;\n\n\t\tif (copy_from_user(&compat_log, (void __user *)arg,\n\t\t\t\t   sizeof(compat_log)))\n\t\t\treturn -EFAULT;\n\t\tlog.slot\t = compat_log.slot;\n\t\tlog.num_pages\t = compat_log.num_pages;\n\t\tlog.first_page\t = compat_log.first_page;\n\t\tlog.padding2\t = compat_log.padding2;\n\t\tlog.dirty_bitmap = compat_ptr(compat_log.dirty_bitmap);\n\n\t\tr = kvm_vm_ioctl_clear_dirty_log(kvm, &log);\n\t\tbreak;\n\t}\n#endif\n\tcase KVM_GET_DIRTY_LOG: {\n\t\tstruct compat_kvm_dirty_log compat_log;\n\t\tstruct kvm_dirty_log log;\n\n\t\tif (copy_from_user(&compat_log, (void __user *)arg,\n\t\t\t\t   sizeof(compat_log)))\n\t\t\treturn -EFAULT;\n\t\tlog.slot\t = compat_log.slot;\n\t\tlog.padding1\t = compat_log.padding1;\n\t\tlog.padding2\t = compat_log.padding2;\n\t\tlog.dirty_bitmap = compat_ptr(compat_log.dirty_bitmap);\n\n\t\tr = kvm_vm_ioctl_get_dirty_log(kvm, &log);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tr = kvm_vm_ioctl(filp, ioctl, arg);\n\t}\n\treturn r;\n}\n#endif\n\nstatic const struct file_operations kvm_vm_fops = {\n\t.release        = kvm_vm_release,\n\t.unlocked_ioctl = kvm_vm_ioctl,\n\t.llseek\t\t= noop_llseek,\n\tKVM_COMPAT(kvm_vm_compat_ioctl),\n};\n\nbool file_is_kvm(struct file *file)\n{\n\treturn file && file->f_op == &kvm_vm_fops;\n}\nEXPORT_SYMBOL_GPL(file_is_kvm);\n\nstatic int kvm_dev_ioctl_create_vm(unsigned long type)\n{\n\tint r;\n\tstruct kvm *kvm;\n\tstruct file *file;\n\n\tkvm = kvm_create_vm(type);\n\tif (IS_ERR(kvm))\n\t\treturn PTR_ERR(kvm);\n#ifdef CONFIG_KVM_MMIO\n\tr = kvm_coalesced_mmio_init(kvm);\n\tif (r < 0)\n\t\tgoto put_kvm;\n#endif\n\tr = get_unused_fd_flags(O_CLOEXEC);\n\tif (r < 0)\n\t\tgoto put_kvm;\n\n\tsnprintf(kvm->stats_id, sizeof(kvm->stats_id),\n\t\t\t\"kvm-%d\", task_pid_nr(current));\n\n\tfile = anon_inode_getfile(\"kvm-vm\", &kvm_vm_fops, kvm, O_RDWR);\n\tif (IS_ERR(file)) {\n\t\tput_unused_fd(r);\n\t\tr = PTR_ERR(file);\n\t\tgoto put_kvm;\n\t}\n\n\t/*\n\t * Don't call kvm_put_kvm anymore at this point; file->f_op is\n\t * already set, with ->release() being kvm_vm_release().  In error\n\t * cases it will be called by the final fput(file) and will take\n\t * care of doing kvm_put_kvm(kvm).\n\t */\n\tif (kvm_create_vm_debugfs(kvm, r) < 0) {\n\t\tput_unused_fd(r);\n\t\tfput(file);\n\t\treturn -ENOMEM;\n\t}\n\tkvm_uevent_notify_change(KVM_EVENT_CREATE_VM, kvm);\n\n\tfd_install(r, file);\n\treturn r;\n\nput_kvm:\n\tkvm_put_kvm(kvm);\n\treturn r;\n}\n\nstatic long kvm_dev_ioctl(struct file *filp,\n\t\t\t  unsigned int ioctl, unsigned long arg)\n{\n\tlong r = -EINVAL;\n\n\tswitch (ioctl) {\n\tcase KVM_GET_API_VERSION:\n\t\tif (arg)\n\t\t\tgoto out;\n\t\tr = KVM_API_VERSION;\n\t\tbreak;\n\tcase KVM_CREATE_VM:\n\t\tr = kvm_dev_ioctl_create_vm(arg);\n\t\tbreak;\n\tcase KVM_CHECK_EXTENSION:\n\t\tr = kvm_vm_ioctl_check_extension_generic(NULL, arg);\n\t\tbreak;\n\tcase KVM_GET_VCPU_MMAP_SIZE:\n\t\tif (arg)\n\t\t\tgoto out;\n\t\tr = PAGE_SIZE;     /* struct kvm_run */\n#ifdef CONFIG_X86\n\t\tr += PAGE_SIZE;    /* pio data page */\n#endif\n#ifdef CONFIG_KVM_MMIO\n\t\tr += PAGE_SIZE;    /* coalesced mmio ring page */\n#endif\n\t\tbreak;\n\tcase KVM_TRACE_ENABLE:\n\tcase KVM_TRACE_PAUSE:\n\tcase KVM_TRACE_DISABLE:\n\t\tr = -EOPNOTSUPP;\n\t\tbreak;\n\tdefault:\n\t\treturn kvm_arch_dev_ioctl(filp, ioctl, arg);\n\t}\nout:\n\treturn r;\n}\n\nstatic struct file_operations kvm_chardev_ops = {\n\t.unlocked_ioctl = kvm_dev_ioctl,\n\t.llseek\t\t= noop_llseek,\n\tKVM_COMPAT(kvm_dev_ioctl),\n};\n\nstatic struct miscdevice kvm_dev = {\n\tKVM_MINOR,\n\t\"kvm\",\n\t&kvm_chardev_ops,\n};\n\nstatic void hardware_enable_nolock(void *junk)\n{\n\tint cpu = raw_smp_processor_id();\n\tint r;\n\n\tif (cpumask_test_cpu(cpu, cpus_hardware_enabled))\n\t\treturn;\n\n\tcpumask_set_cpu(cpu, cpus_hardware_enabled);\n\n\tr = kvm_arch_hardware_enable();\n\n\tif (r) {\n\t\tcpumask_clear_cpu(cpu, cpus_hardware_enabled);\n\t\tatomic_inc(&hardware_enable_failed);\n\t\tpr_info(\"kvm: enabling virtualization on CPU%d failed\\n\", cpu);\n\t}\n}\n\nstatic int kvm_starting_cpu(unsigned int cpu)\n{\n\traw_spin_lock(&kvm_count_lock);\n\tif (kvm_usage_count)\n\t\thardware_enable_nolock(NULL);\n\traw_spin_unlock(&kvm_count_lock);\n\treturn 0;\n}\n\nstatic void hardware_disable_nolock(void *junk)\n{\n\tint cpu = raw_smp_processor_id();\n\n\tif (!cpumask_test_cpu(cpu, cpus_hardware_enabled))\n\t\treturn;\n\tcpumask_clear_cpu(cpu, cpus_hardware_enabled);\n\tkvm_arch_hardware_disable();\n}\n\nstatic int kvm_dying_cpu(unsigned int cpu)\n{\n\traw_spin_lock(&kvm_count_lock);\n\tif (kvm_usage_count)\n\t\thardware_disable_nolock(NULL);\n\traw_spin_unlock(&kvm_count_lock);\n\treturn 0;\n}\n\nstatic void hardware_disable_all_nolock(void)\n{\n\tBUG_ON(!kvm_usage_count);\n\n\tkvm_usage_count--;\n\tif (!kvm_usage_count)\n\t\ton_each_cpu(hardware_disable_nolock, NULL, 1);\n}\n\nstatic void hardware_disable_all(void)\n{\n\traw_spin_lock(&kvm_count_lock);\n\thardware_disable_all_nolock();\n\traw_spin_unlock(&kvm_count_lock);\n}\n\nstatic int hardware_enable_all(void)\n{\n\tint r = 0;\n\n\traw_spin_lock(&kvm_count_lock);\n\n\tkvm_usage_count++;\n\tif (kvm_usage_count == 1) {\n\t\tatomic_set(&hardware_enable_failed, 0);\n\t\ton_each_cpu(hardware_enable_nolock, NULL, 1);\n\n\t\tif (atomic_read(&hardware_enable_failed)) {\n\t\t\thardware_disable_all_nolock();\n\t\t\tr = -EBUSY;\n\t\t}\n\t}\n\n\traw_spin_unlock(&kvm_count_lock);\n\n\treturn r;\n}\n\nstatic int kvm_reboot(struct notifier_block *notifier, unsigned long val,\n\t\t      void *v)\n{\n\t/*\n\t * Some (well, at least mine) BIOSes hang on reboot if\n\t * in vmx root mode.\n\t *\n\t * And Intel TXT required VMX off for all cpu when system shutdown.\n\t */\n\tpr_info(\"kvm: exiting hardware virtualization\\n\");\n\tkvm_rebooting = true;\n\ton_each_cpu(hardware_disable_nolock, NULL, 1);\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block kvm_reboot_notifier = {\n\t.notifier_call = kvm_reboot,\n\t.priority = 0,\n};\n\nstatic void kvm_io_bus_destroy(struct kvm_io_bus *bus)\n{\n\tint i;\n\n\tfor (i = 0; i < bus->dev_count; i++) {\n\t\tstruct kvm_io_device *pos = bus->range[i].dev;\n\n\t\tkvm_iodevice_destructor(pos);\n\t}\n\tkfree(bus);\n}\n\nstatic inline int kvm_io_bus_cmp(const struct kvm_io_range *r1,\n\t\t\t\t const struct kvm_io_range *r2)\n{\n\tgpa_t addr1 = r1->addr;\n\tgpa_t addr2 = r2->addr;\n\n\tif (addr1 < addr2)\n\t\treturn -1;\n\n\t/* If r2->len == 0, match the exact address.  If r2->len != 0,\n\t * accept any overlapping write.  Any order is acceptable for\n\t * overlapping ranges, because kvm_io_bus_get_first_dev ensures\n\t * we process all of them.\n\t */\n\tif (r2->len) {\n\t\taddr1 += r1->len;\n\t\taddr2 += r2->len;\n\t}\n\n\tif (addr1 > addr2)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int kvm_io_bus_sort_cmp(const void *p1, const void *p2)\n{\n\treturn kvm_io_bus_cmp(p1, p2);\n}\n\nstatic int kvm_io_bus_get_first_dev(struct kvm_io_bus *bus,\n\t\t\t     gpa_t addr, int len)\n{\n\tstruct kvm_io_range *range, key;\n\tint off;\n\n\tkey = (struct kvm_io_range) {\n\t\t.addr = addr,\n\t\t.len = len,\n\t};\n\n\trange = bsearch(&key, bus->range, bus->dev_count,\n\t\t\tsizeof(struct kvm_io_range), kvm_io_bus_sort_cmp);\n\tif (range == NULL)\n\t\treturn -ENOENT;\n\n\toff = range - bus->range;\n\n\twhile (off > 0 && kvm_io_bus_cmp(&key, &bus->range[off-1]) == 0)\n\t\toff--;\n\n\treturn off;\n}\n\nstatic int __kvm_io_bus_write(struct kvm_vcpu *vcpu, struct kvm_io_bus *bus,\n\t\t\t      struct kvm_io_range *range, const void *val)\n{\n\tint idx;\n\n\tidx = kvm_io_bus_get_first_dev(bus, range->addr, range->len);\n\tif (idx < 0)\n\t\treturn -EOPNOTSUPP;\n\n\twhile (idx < bus->dev_count &&\n\t\tkvm_io_bus_cmp(range, &bus->range[idx]) == 0) {\n\t\tif (!kvm_iodevice_write(vcpu, bus->range[idx].dev, range->addr,\n\t\t\t\t\trange->len, val))\n\t\t\treturn idx;\n\t\tidx++;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\n/* kvm_io_bus_write - called under kvm->slots_lock */\nint kvm_io_bus_write(struct kvm_vcpu *vcpu, enum kvm_bus bus_idx, gpa_t addr,\n\t\t     int len, const void *val)\n{\n\tstruct kvm_io_bus *bus;\n\tstruct kvm_io_range range;\n\tint r;\n\n\trange = (struct kvm_io_range) {\n\t\t.addr = addr,\n\t\t.len = len,\n\t};\n\n\tbus = srcu_dereference(vcpu->kvm->buses[bus_idx], &vcpu->kvm->srcu);\n\tif (!bus)\n\t\treturn -ENOMEM;\n\tr = __kvm_io_bus_write(vcpu, bus, &range, val);\n\treturn r < 0 ? r : 0;\n}\nEXPORT_SYMBOL_GPL(kvm_io_bus_write);\n\n/* kvm_io_bus_write_cookie - called under kvm->slots_lock */\nint kvm_io_bus_write_cookie(struct kvm_vcpu *vcpu, enum kvm_bus bus_idx,\n\t\t\t    gpa_t addr, int len, const void *val, long cookie)\n{\n\tstruct kvm_io_bus *bus;\n\tstruct kvm_io_range range;\n\n\trange = (struct kvm_io_range) {\n\t\t.addr = addr,\n\t\t.len = len,\n\t};\n\n\tbus = srcu_dereference(vcpu->kvm->buses[bus_idx], &vcpu->kvm->srcu);\n\tif (!bus)\n\t\treturn -ENOMEM;\n\n\t/* First try the device referenced by cookie. */\n\tif ((cookie >= 0) && (cookie < bus->dev_count) &&\n\t    (kvm_io_bus_cmp(&range, &bus->range[cookie]) == 0))\n\t\tif (!kvm_iodevice_write(vcpu, bus->range[cookie].dev, addr, len,\n\t\t\t\t\tval))\n\t\t\treturn cookie;\n\n\t/*\n\t * cookie contained garbage; fall back to search and return the\n\t * correct cookie value.\n\t */\n\treturn __kvm_io_bus_write(vcpu, bus, &range, val);\n}\n\nstatic int __kvm_io_bus_read(struct kvm_vcpu *vcpu, struct kvm_io_bus *bus,\n\t\t\t     struct kvm_io_range *range, void *val)\n{\n\tint idx;\n\n\tidx = kvm_io_bus_get_first_dev(bus, range->addr, range->len);\n\tif (idx < 0)\n\t\treturn -EOPNOTSUPP;\n\n\twhile (idx < bus->dev_count &&\n\t\tkvm_io_bus_cmp(range, &bus->range[idx]) == 0) {\n\t\tif (!kvm_iodevice_read(vcpu, bus->range[idx].dev, range->addr,\n\t\t\t\t       range->len, val))\n\t\t\treturn idx;\n\t\tidx++;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\n/* kvm_io_bus_read - called under kvm->slots_lock */\nint kvm_io_bus_read(struct kvm_vcpu *vcpu, enum kvm_bus bus_idx, gpa_t addr,\n\t\t    int len, void *val)\n{\n\tstruct kvm_io_bus *bus;\n\tstruct kvm_io_range range;\n\tint r;\n\n\trange = (struct kvm_io_range) {\n\t\t.addr = addr,\n\t\t.len = len,\n\t};\n\n\tbus = srcu_dereference(vcpu->kvm->buses[bus_idx], &vcpu->kvm->srcu);\n\tif (!bus)\n\t\treturn -ENOMEM;\n\tr = __kvm_io_bus_read(vcpu, bus, &range, val);\n\treturn r < 0 ? r : 0;\n}\n\n/* Caller must hold slots_lock. */\nint kvm_io_bus_register_dev(struct kvm *kvm, enum kvm_bus bus_idx, gpa_t addr,\n\t\t\t    int len, struct kvm_io_device *dev)\n{\n\tint i;\n\tstruct kvm_io_bus *new_bus, *bus;\n\tstruct kvm_io_range range;\n\n\tbus = kvm_get_bus(kvm, bus_idx);\n\tif (!bus)\n\t\treturn -ENOMEM;\n\n\t/* exclude ioeventfd which is limited by maximum fd */\n\tif (bus->dev_count - bus->ioeventfd_count > NR_IOBUS_DEVS - 1)\n\t\treturn -ENOSPC;\n\n\tnew_bus = kmalloc(struct_size(bus, range, bus->dev_count + 1),\n\t\t\t  GFP_KERNEL_ACCOUNT);\n\tif (!new_bus)\n\t\treturn -ENOMEM;\n\n\trange = (struct kvm_io_range) {\n\t\t.addr = addr,\n\t\t.len = len,\n\t\t.dev = dev,\n\t};\n\n\tfor (i = 0; i < bus->dev_count; i++)\n\t\tif (kvm_io_bus_cmp(&bus->range[i], &range) > 0)\n\t\t\tbreak;\n\n\tmemcpy(new_bus, bus, sizeof(*bus) + i * sizeof(struct kvm_io_range));\n\tnew_bus->dev_count++;\n\tnew_bus->range[i] = range;\n\tmemcpy(new_bus->range + i + 1, bus->range + i,\n\t\t(bus->dev_count - i) * sizeof(struct kvm_io_range));\n\trcu_assign_pointer(kvm->buses[bus_idx], new_bus);\n\tsynchronize_srcu_expedited(&kvm->srcu);\n\tkfree(bus);\n\n\treturn 0;\n}\n\nint kvm_io_bus_unregister_dev(struct kvm *kvm, enum kvm_bus bus_idx,\n\t\t\t      struct kvm_io_device *dev)\n{\n\tint i, j;\n\tstruct kvm_io_bus *new_bus, *bus;\n\n\tlockdep_assert_held(&kvm->slots_lock);\n\n\tbus = kvm_get_bus(kvm, bus_idx);\n\tif (!bus)\n\t\treturn 0;\n\n\tfor (i = 0; i < bus->dev_count; i++) {\n\t\tif (bus->range[i].dev == dev) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == bus->dev_count)\n\t\treturn 0;\n\n\tnew_bus = kmalloc(struct_size(bus, range, bus->dev_count - 1),\n\t\t\t  GFP_KERNEL_ACCOUNT);\n\tif (new_bus) {\n\t\tmemcpy(new_bus, bus, struct_size(bus, range, i));\n\t\tnew_bus->dev_count--;\n\t\tmemcpy(new_bus->range + i, bus->range + i + 1,\n\t\t\t\tflex_array_size(new_bus, range, new_bus->dev_count - i));\n\t}\n\n\trcu_assign_pointer(kvm->buses[bus_idx], new_bus);\n\tsynchronize_srcu_expedited(&kvm->srcu);\n\n\t/* Destroy the old bus _after_ installing the (null) bus. */\n\tif (!new_bus) {\n\t\tpr_err(\"kvm: failed to shrink bus, removing it completely\\n\");\n\t\tfor (j = 0; j < bus->dev_count; j++) {\n\t\t\tif (j == i)\n\t\t\t\tcontinue;\n\t\t\tkvm_iodevice_destructor(bus->range[j].dev);\n\t\t}\n\t}\n\n\tkfree(bus);\n\treturn new_bus ? 0 : -ENOMEM;\n}\n\nstruct kvm_io_device *kvm_io_bus_get_dev(struct kvm *kvm, enum kvm_bus bus_idx,\n\t\t\t\t\t gpa_t addr)\n{\n\tstruct kvm_io_bus *bus;\n\tint dev_idx, srcu_idx;\n\tstruct kvm_io_device *iodev = NULL;\n\n\tsrcu_idx = srcu_read_lock(&kvm->srcu);\n\n\tbus = srcu_dereference(kvm->buses[bus_idx], &kvm->srcu);\n\tif (!bus)\n\t\tgoto out_unlock;\n\n\tdev_idx = kvm_io_bus_get_first_dev(bus, addr, 1);\n\tif (dev_idx < 0)\n\t\tgoto out_unlock;\n\n\tiodev = bus->range[dev_idx].dev;\n\nout_unlock:\n\tsrcu_read_unlock(&kvm->srcu, srcu_idx);\n\n\treturn iodev;\n}\nEXPORT_SYMBOL_GPL(kvm_io_bus_get_dev);\n\nstatic int kvm_debugfs_open(struct inode *inode, struct file *file,\n\t\t\t   int (*get)(void *, u64 *), int (*set)(void *, u64),\n\t\t\t   const char *fmt)\n{\n\tstruct kvm_stat_data *stat_data = (struct kvm_stat_data *)\n\t\t\t\t\t  inode->i_private;\n\n\t/*\n\t * The debugfs files are a reference to the kvm struct which\n        * is still valid when kvm_destroy_vm is called.  kvm_get_kvm_safe\n        * avoids the race between open and the removal of the debugfs directory.\n\t */\n\tif (!kvm_get_kvm_safe(stat_data->kvm))\n\t\treturn -ENOENT;\n\n\tif (simple_attr_open(inode, file, get,\n\t\t    kvm_stats_debugfs_mode(stat_data->desc) & 0222\n\t\t    ? set : NULL,\n\t\t    fmt)) {\n\t\tkvm_put_kvm(stat_data->kvm);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int kvm_debugfs_release(struct inode *inode, struct file *file)\n{\n\tstruct kvm_stat_data *stat_data = (struct kvm_stat_data *)\n\t\t\t\t\t  inode->i_private;\n\n\tsimple_attr_release(inode, file);\n\tkvm_put_kvm(stat_data->kvm);\n\n\treturn 0;\n}\n\nstatic int kvm_get_stat_per_vm(struct kvm *kvm, size_t offset, u64 *val)\n{\n\t*val = *(u64 *)((void *)(&kvm->stat) + offset);\n\n\treturn 0;\n}\n\nstatic int kvm_clear_stat_per_vm(struct kvm *kvm, size_t offset)\n{\n\t*(u64 *)((void *)(&kvm->stat) + offset) = 0;\n\n\treturn 0;\n}\n\nstatic int kvm_get_stat_per_vcpu(struct kvm *kvm, size_t offset, u64 *val)\n{\n\tunsigned long i;\n\tstruct kvm_vcpu *vcpu;\n\n\t*val = 0;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\t*val += *(u64 *)((void *)(&vcpu->stat) + offset);\n\n\treturn 0;\n}\n\nstatic int kvm_clear_stat_per_vcpu(struct kvm *kvm, size_t offset)\n{\n\tunsigned long i;\n\tstruct kvm_vcpu *vcpu;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\t*(u64 *)((void *)(&vcpu->stat) + offset) = 0;\n\n\treturn 0;\n}\n\nstatic int kvm_stat_data_get(void *data, u64 *val)\n{\n\tint r = -EFAULT;\n\tstruct kvm_stat_data *stat_data = (struct kvm_stat_data *)data;\n\n\tswitch (stat_data->kind) {\n\tcase KVM_STAT_VM:\n\t\tr = kvm_get_stat_per_vm(stat_data->kvm,\n\t\t\t\t\tstat_data->desc->desc.offset, val);\n\t\tbreak;\n\tcase KVM_STAT_VCPU:\n\t\tr = kvm_get_stat_per_vcpu(stat_data->kvm,\n\t\t\t\t\t  stat_data->desc->desc.offset, val);\n\t\tbreak;\n\t}\n\n\treturn r;\n}\n\nstatic int kvm_stat_data_clear(void *data, u64 val)\n{\n\tint r = -EFAULT;\n\tstruct kvm_stat_data *stat_data = (struct kvm_stat_data *)data;\n\n\tif (val)\n\t\treturn -EINVAL;\n\n\tswitch (stat_data->kind) {\n\tcase KVM_STAT_VM:\n\t\tr = kvm_clear_stat_per_vm(stat_data->kvm,\n\t\t\t\t\t  stat_data->desc->desc.offset);\n\t\tbreak;\n\tcase KVM_STAT_VCPU:\n\t\tr = kvm_clear_stat_per_vcpu(stat_data->kvm,\n\t\t\t\t\t    stat_data->desc->desc.offset);\n\t\tbreak;\n\t}\n\n\treturn r;\n}\n\nstatic int kvm_stat_data_open(struct inode *inode, struct file *file)\n{\n\t__simple_attr_check_format(\"%llu\\n\", 0ull);\n\treturn kvm_debugfs_open(inode, file, kvm_stat_data_get,\n\t\t\t\tkvm_stat_data_clear, \"%llu\\n\");\n}\n\nstatic const struct file_operations stat_fops_per_vm = {\n\t.owner = THIS_MODULE,\n\t.open = kvm_stat_data_open,\n\t.release = kvm_debugfs_release,\n\t.read = simple_attr_read,\n\t.write = simple_attr_write,\n\t.llseek = no_llseek,\n};\n\nstatic int vm_stat_get(void *_offset, u64 *val)\n{\n\tunsigned offset = (long)_offset;\n\tstruct kvm *kvm;\n\tu64 tmp_val;\n\n\t*val = 0;\n\tmutex_lock(&kvm_lock);\n\tlist_for_each_entry(kvm, &vm_list, vm_list) {\n\t\tkvm_get_stat_per_vm(kvm, offset, &tmp_val);\n\t\t*val += tmp_val;\n\t}\n\tmutex_unlock(&kvm_lock);\n\treturn 0;\n}\n\nstatic int vm_stat_clear(void *_offset, u64 val)\n{\n\tunsigned offset = (long)_offset;\n\tstruct kvm *kvm;\n\n\tif (val)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&kvm_lock);\n\tlist_for_each_entry(kvm, &vm_list, vm_list) {\n\t\tkvm_clear_stat_per_vm(kvm, offset);\n\t}\n\tmutex_unlock(&kvm_lock);\n\n\treturn 0;\n}\n\nDEFINE_SIMPLE_ATTRIBUTE(vm_stat_fops, vm_stat_get, vm_stat_clear, \"%llu\\n\");\nDEFINE_SIMPLE_ATTRIBUTE(vm_stat_readonly_fops, vm_stat_get, NULL, \"%llu\\n\");\n\nstatic int vcpu_stat_get(void *_offset, u64 *val)\n{\n\tunsigned offset = (long)_offset;\n\tstruct kvm *kvm;\n\tu64 tmp_val;\n\n\t*val = 0;\n\tmutex_lock(&kvm_lock);\n\tlist_for_each_entry(kvm, &vm_list, vm_list) {\n\t\tkvm_get_stat_per_vcpu(kvm, offset, &tmp_val);\n\t\t*val += tmp_val;\n\t}\n\tmutex_unlock(&kvm_lock);\n\treturn 0;\n}\n\nstatic int vcpu_stat_clear(void *_offset, u64 val)\n{\n\tunsigned offset = (long)_offset;\n\tstruct kvm *kvm;\n\n\tif (val)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&kvm_lock);\n\tlist_for_each_entry(kvm, &vm_list, vm_list) {\n\t\tkvm_clear_stat_per_vcpu(kvm, offset);\n\t}\n\tmutex_unlock(&kvm_lock);\n\n\treturn 0;\n}\n\nDEFINE_SIMPLE_ATTRIBUTE(vcpu_stat_fops, vcpu_stat_get, vcpu_stat_clear,\n\t\t\t\"%llu\\n\");\nDEFINE_SIMPLE_ATTRIBUTE(vcpu_stat_readonly_fops, vcpu_stat_get, NULL, \"%llu\\n\");\n\nstatic void kvm_uevent_notify_change(unsigned int type, struct kvm *kvm)\n{\n\tstruct kobj_uevent_env *env;\n\tunsigned long long created, active;\n\n\tif (!kvm_dev.this_device || !kvm)\n\t\treturn;\n\n\tmutex_lock(&kvm_lock);\n\tif (type == KVM_EVENT_CREATE_VM) {\n\t\tkvm_createvm_count++;\n\t\tkvm_active_vms++;\n\t} else if (type == KVM_EVENT_DESTROY_VM) {\n\t\tkvm_active_vms--;\n\t}\n\tcreated = kvm_createvm_count;\n\tactive = kvm_active_vms;\n\tmutex_unlock(&kvm_lock);\n\n\tenv = kzalloc(sizeof(*env), GFP_KERNEL_ACCOUNT);\n\tif (!env)\n\t\treturn;\n\n\tadd_uevent_var(env, \"CREATED=%llu\", created);\n\tadd_uevent_var(env, \"COUNT=%llu\", active);\n\n\tif (type == KVM_EVENT_CREATE_VM) {\n\t\tadd_uevent_var(env, \"EVENT=create\");\n\t\tkvm->userspace_pid = task_pid_nr(current);\n\t} else if (type == KVM_EVENT_DESTROY_VM) {\n\t\tadd_uevent_var(env, \"EVENT=destroy\");\n\t}\n\tadd_uevent_var(env, \"PID=%d\", kvm->userspace_pid);\n\n\tif (kvm->debugfs_dentry) {\n\t\tchar *tmp, *p = kmalloc(PATH_MAX, GFP_KERNEL_ACCOUNT);\n\n\t\tif (p) {\n\t\t\ttmp = dentry_path_raw(kvm->debugfs_dentry, p, PATH_MAX);\n\t\t\tif (!IS_ERR(tmp))\n\t\t\t\tadd_uevent_var(env, \"STATS_PATH=%s\", tmp);\n\t\t\tkfree(p);\n\t\t}\n\t}\n\t/* no need for checks, since we are adding at most only 5 keys */\n\tenv->envp[env->envp_idx++] = NULL;\n\tkobject_uevent_env(&kvm_dev.this_device->kobj, KOBJ_CHANGE, env->envp);\n\tkfree(env);\n}\n\nstatic void kvm_init_debug(void)\n{\n\tconst struct file_operations *fops;\n\tconst struct _kvm_stats_desc *pdesc;\n\tint i;\n\n\tkvm_debugfs_dir = debugfs_create_dir(\"kvm\", NULL);\n\n\tfor (i = 0; i < kvm_vm_stats_header.num_desc; ++i) {\n\t\tpdesc = &kvm_vm_stats_desc[i];\n\t\tif (kvm_stats_debugfs_mode(pdesc) & 0222)\n\t\t\tfops = &vm_stat_fops;\n\t\telse\n\t\t\tfops = &vm_stat_readonly_fops;\n\t\tdebugfs_create_file(pdesc->name, kvm_stats_debugfs_mode(pdesc),\n\t\t\t\tkvm_debugfs_dir,\n\t\t\t\t(void *)(long)pdesc->desc.offset, fops);\n\t}\n\n\tfor (i = 0; i < kvm_vcpu_stats_header.num_desc; ++i) {\n\t\tpdesc = &kvm_vcpu_stats_desc[i];\n\t\tif (kvm_stats_debugfs_mode(pdesc) & 0222)\n\t\t\tfops = &vcpu_stat_fops;\n\t\telse\n\t\t\tfops = &vcpu_stat_readonly_fops;\n\t\tdebugfs_create_file(pdesc->name, kvm_stats_debugfs_mode(pdesc),\n\t\t\t\tkvm_debugfs_dir,\n\t\t\t\t(void *)(long)pdesc->desc.offset, fops);\n\t}\n}\n\nstatic int kvm_suspend(void)\n{\n\tif (kvm_usage_count)\n\t\thardware_disable_nolock(NULL);\n\treturn 0;\n}\n\nstatic void kvm_resume(void)\n{\n\tif (kvm_usage_count) {\n\t\tlockdep_assert_not_held(&kvm_count_lock);\n\t\thardware_enable_nolock(NULL);\n\t}\n}\n\nstatic struct syscore_ops kvm_syscore_ops = {\n\t.suspend = kvm_suspend,\n\t.resume = kvm_resume,\n};\n\nstatic inline\nstruct kvm_vcpu *preempt_notifier_to_vcpu(struct preempt_notifier *pn)\n{\n\treturn container_of(pn, struct kvm_vcpu, preempt_notifier);\n}\n\nstatic void kvm_sched_in(struct preempt_notifier *pn, int cpu)\n{\n\tstruct kvm_vcpu *vcpu = preempt_notifier_to_vcpu(pn);\n\n\tWRITE_ONCE(vcpu->preempted, false);\n\tWRITE_ONCE(vcpu->ready, false);\n\n\t__this_cpu_write(kvm_running_vcpu, vcpu);\n\tkvm_arch_sched_in(vcpu, cpu);\n\tkvm_arch_vcpu_load(vcpu, cpu);\n}\n\nstatic void kvm_sched_out(struct preempt_notifier *pn,\n\t\t\t  struct task_struct *next)\n{\n\tstruct kvm_vcpu *vcpu = preempt_notifier_to_vcpu(pn);\n\n\tif (current->on_rq) {\n\t\tWRITE_ONCE(vcpu->preempted, true);\n\t\tWRITE_ONCE(vcpu->ready, true);\n\t}\n\tkvm_arch_vcpu_put(vcpu);\n\t__this_cpu_write(kvm_running_vcpu, NULL);\n}\n\n/**\n * kvm_get_running_vcpu - get the vcpu running on the current CPU.\n *\n * We can disable preemption locally around accessing the per-CPU variable,\n * and use the resolved vcpu pointer after enabling preemption again,\n * because even if the current thread is migrated to another CPU, reading\n * the per-CPU value later will give us the same value as we update the\n * per-CPU variable in the preempt notifier handlers.\n */\nstruct kvm_vcpu *kvm_get_running_vcpu(void)\n{\n\tstruct kvm_vcpu *vcpu;\n\n\tpreempt_disable();\n\tvcpu = __this_cpu_read(kvm_running_vcpu);\n\tpreempt_enable();\n\n\treturn vcpu;\n}\nEXPORT_SYMBOL_GPL(kvm_get_running_vcpu);\n\n/**\n * kvm_get_running_vcpus - get the per-CPU array of currently running vcpus.\n */\nstruct kvm_vcpu * __percpu *kvm_get_running_vcpus(void)\n{\n        return &kvm_running_vcpu;\n}\n\n#ifdef CONFIG_GUEST_PERF_EVENTS\nstatic unsigned int kvm_guest_state(void)\n{\n\tstruct kvm_vcpu *vcpu = kvm_get_running_vcpu();\n\tunsigned int state;\n\n\tif (!kvm_arch_pmi_in_guest(vcpu))\n\t\treturn 0;\n\n\tstate = PERF_GUEST_ACTIVE;\n\tif (!kvm_arch_vcpu_in_kernel(vcpu))\n\t\tstate |= PERF_GUEST_USER;\n\n\treturn state;\n}\n\nstatic unsigned long kvm_guest_get_ip(void)\n{\n\tstruct kvm_vcpu *vcpu = kvm_get_running_vcpu();\n\n\t/* Retrieving the IP must be guarded by a call to kvm_guest_state(). */\n\tif (WARN_ON_ONCE(!kvm_arch_pmi_in_guest(vcpu)))\n\t\treturn 0;\n\n\treturn kvm_arch_vcpu_get_ip(vcpu);\n}\n\nstatic struct perf_guest_info_callbacks kvm_guest_cbs = {\n\t.state\t\t\t= kvm_guest_state,\n\t.get_ip\t\t\t= kvm_guest_get_ip,\n\t.handle_intel_pt_intr\t= NULL,\n};\n\nvoid kvm_register_perf_callbacks(unsigned int (*pt_intr_handler)(void))\n{\n\tkvm_guest_cbs.handle_intel_pt_intr = pt_intr_handler;\n\tperf_register_guest_info_callbacks(&kvm_guest_cbs);\n}\nvoid kvm_unregister_perf_callbacks(void)\n{\n\tperf_unregister_guest_info_callbacks(&kvm_guest_cbs);\n}\n#endif\n\nstruct kvm_cpu_compat_check {\n\tvoid *opaque;\n\tint *ret;\n};\n\nstatic void check_processor_compat(void *data)\n{\n\tstruct kvm_cpu_compat_check *c = data;\n\n\t*c->ret = kvm_arch_check_processor_compat(c->opaque);\n}\n\nint kvm_init(void *opaque, unsigned vcpu_size, unsigned vcpu_align,\n\t\t  struct module *module)\n{\n\tstruct kvm_cpu_compat_check c;\n\tint r;\n\tint cpu;\n\n\tr = kvm_arch_init(opaque);\n\tif (r)\n\t\tgoto out_fail;\n\n\t/*\n\t * kvm_arch_init makes sure there's at most one caller\n\t * for architectures that support multiple implementations,\n\t * like intel and amd on x86.\n\t * kvm_arch_init must be called before kvm_irqfd_init to avoid creating\n\t * conflicts in case kvm is already setup for another implementation.\n\t */\n\tr = kvm_irqfd_init();\n\tif (r)\n\t\tgoto out_irqfd;\n\n\tif (!zalloc_cpumask_var(&cpus_hardware_enabled, GFP_KERNEL)) {\n\t\tr = -ENOMEM;\n\t\tgoto out_free_0;\n\t}\n\n\tr = kvm_arch_hardware_setup(opaque);\n\tif (r < 0)\n\t\tgoto out_free_1;\n\n\tc.ret = &r;\n\tc.opaque = opaque;\n\tfor_each_online_cpu(cpu) {\n\t\tsmp_call_function_single(cpu, check_processor_compat, &c, 1);\n\t\tif (r < 0)\n\t\t\tgoto out_free_2;\n\t}\n\n\tr = cpuhp_setup_state_nocalls(CPUHP_AP_KVM_STARTING, \"kvm/cpu:starting\",\n\t\t\t\t      kvm_starting_cpu, kvm_dying_cpu);\n\tif (r)\n\t\tgoto out_free_2;\n\tregister_reboot_notifier(&kvm_reboot_notifier);\n\n\t/* A kmem cache lets us meet the alignment requirements of fx_save. */\n\tif (!vcpu_align)\n\t\tvcpu_align = __alignof__(struct kvm_vcpu);\n\tkvm_vcpu_cache =\n\t\tkmem_cache_create_usercopy(\"kvm_vcpu\", vcpu_size, vcpu_align,\n\t\t\t\t\t   SLAB_ACCOUNT,\n\t\t\t\t\t   offsetof(struct kvm_vcpu, arch),\n\t\t\t\t\t   offsetofend(struct kvm_vcpu, stats_id)\n\t\t\t\t\t   - offsetof(struct kvm_vcpu, arch),\n\t\t\t\t\t   NULL);\n\tif (!kvm_vcpu_cache) {\n\t\tr = -ENOMEM;\n\t\tgoto out_free_3;\n\t}\n\n\tfor_each_possible_cpu(cpu) {\n\t\tif (!alloc_cpumask_var_node(&per_cpu(cpu_kick_mask, cpu),\n\t\t\t\t\t    GFP_KERNEL, cpu_to_node(cpu))) {\n\t\t\tr = -ENOMEM;\n\t\t\tgoto out_free_4;\n\t\t}\n\t}\n\n\tr = kvm_async_pf_init();\n\tif (r)\n\t\tgoto out_free_5;\n\n\tkvm_chardev_ops.owner = module;\n\n\tr = misc_register(&kvm_dev);\n\tif (r) {\n\t\tpr_err(\"kvm: misc device register failed\\n\");\n\t\tgoto out_unreg;\n\t}\n\n\tregister_syscore_ops(&kvm_syscore_ops);\n\n\tkvm_preempt_ops.sched_in = kvm_sched_in;\n\tkvm_preempt_ops.sched_out = kvm_sched_out;\n\n\tkvm_init_debug();\n\n\tr = kvm_vfio_ops_init();\n\tWARN_ON(r);\n\n\treturn 0;\n\nout_unreg:\n\tkvm_async_pf_deinit();\nout_free_5:\n\tfor_each_possible_cpu(cpu)\n\t\tfree_cpumask_var(per_cpu(cpu_kick_mask, cpu));\nout_free_4:\n\tkmem_cache_destroy(kvm_vcpu_cache);\nout_free_3:\n\tunregister_reboot_notifier(&kvm_reboot_notifier);\n\tcpuhp_remove_state_nocalls(CPUHP_AP_KVM_STARTING);\nout_free_2:\n\tkvm_arch_hardware_unsetup();\nout_free_1:\n\tfree_cpumask_var(cpus_hardware_enabled);\nout_free_0:\n\tkvm_irqfd_exit();\nout_irqfd:\n\tkvm_arch_exit();\nout_fail:\n\treturn r;\n}\nEXPORT_SYMBOL_GPL(kvm_init);\n\nvoid kvm_exit(void)\n{\n\tint cpu;\n\n\tdebugfs_remove_recursive(kvm_debugfs_dir);\n\tmisc_deregister(&kvm_dev);\n\tfor_each_possible_cpu(cpu)\n\t\tfree_cpumask_var(per_cpu(cpu_kick_mask, cpu));\n\tkmem_cache_destroy(kvm_vcpu_cache);\n\tkvm_async_pf_deinit();\n\tunregister_syscore_ops(&kvm_syscore_ops);\n\tunregister_reboot_notifier(&kvm_reboot_notifier);\n\tcpuhp_remove_state_nocalls(CPUHP_AP_KVM_STARTING);\n\ton_each_cpu(hardware_disable_nolock, NULL, 1);\n\tkvm_arch_hardware_unsetup();\n\tkvm_arch_exit();\n\tkvm_irqfd_exit();\n\tfree_cpumask_var(cpus_hardware_enabled);\n\tkvm_vfio_ops_exit();\n}\nEXPORT_SYMBOL_GPL(kvm_exit);\n\nstruct kvm_vm_worker_thread_context {\n\tstruct kvm *kvm;\n\tstruct task_struct *parent;\n\tstruct completion init_done;\n\tkvm_vm_thread_fn_t thread_fn;\n\tuintptr_t data;\n\tint err;\n};\n\nstatic int kvm_vm_worker_thread(void *context)\n{\n\t/*\n\t * The init_context is allocated on the stack of the parent thread, so\n\t * we have to locally copy anything that is needed beyond initialization\n\t */\n\tstruct kvm_vm_worker_thread_context *init_context = context;\n\tstruct task_struct *parent;\n\tstruct kvm *kvm = init_context->kvm;\n\tkvm_vm_thread_fn_t thread_fn = init_context->thread_fn;\n\tuintptr_t data = init_context->data;\n\tint err;\n\n\terr = kthread_park(current);\n\t/* kthread_park(current) is never supposed to return an error */\n\tWARN_ON(err != 0);\n\tif (err)\n\t\tgoto init_complete;\n\n\terr = cgroup_attach_task_all(init_context->parent, current);\n\tif (err) {\n\t\tkvm_err(\"%s: cgroup_attach_task_all failed with err %d\\n\",\n\t\t\t__func__, err);\n\t\tgoto init_complete;\n\t}\n\n\tset_user_nice(current, task_nice(init_context->parent));\n\ninit_complete:\n\tinit_context->err = err;\n\tcomplete(&init_context->init_done);\n\tinit_context = NULL;\n\n\tif (err)\n\t\tgoto out;\n\n\t/* Wait to be woken up by the spawner before proceeding. */\n\tkthread_parkme();\n\n\tif (!kthread_should_stop())\n\t\terr = thread_fn(kvm, data);\n\nout:\n\t/*\n\t * Move kthread back to its original cgroup to prevent it lingering in\n\t * the cgroup of the VM process, after the latter finishes its\n\t * execution.\n\t *\n\t * kthread_stop() waits on the 'exited' completion condition which is\n\t * set in exit_mm(), via mm_release(), in do_exit(). However, the\n\t * kthread is removed from the cgroup in the cgroup_exit() which is\n\t * called after the exit_mm(). This causes the kthread_stop() to return\n\t * before the kthread actually quits the cgroup.\n\t */\n\trcu_read_lock();\n\tparent = rcu_dereference(current->real_parent);\n\tget_task_struct(parent);\n\trcu_read_unlock();\n\tcgroup_attach_task_all(parent, current);\n\tput_task_struct(parent);\n\n\treturn err;\n}\n\nint kvm_vm_create_worker_thread(struct kvm *kvm, kvm_vm_thread_fn_t thread_fn,\n\t\t\t\tuintptr_t data, const char *name,\n\t\t\t\tstruct task_struct **thread_ptr)\n{\n\tstruct kvm_vm_worker_thread_context init_context = {};\n\tstruct task_struct *thread;\n\n\t*thread_ptr = NULL;\n\tinit_context.kvm = kvm;\n\tinit_context.parent = current;\n\tinit_context.thread_fn = thread_fn;\n\tinit_context.data = data;\n\tinit_completion(&init_context.init_done);\n\n\tthread = kthread_run(kvm_vm_worker_thread, &init_context,\n\t\t\t     \"%s-%d\", name, task_pid_nr(current));\n\tif (IS_ERR(thread))\n\t\treturn PTR_ERR(thread);\n\n\t/* kthread_run is never supposed to return NULL */\n\tWARN_ON(thread == NULL);\n\n\twait_for_completion(&init_context.init_done);\n\n\tif (!init_context.err)\n\t\t*thread_ptr = thread;\n\n\treturn init_context.err;\n}\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * Kernel-based Virtual Machine driver for Linux\n *\n * This module enables machines with Intel VT-x extensions to run virtual\n * machines without emulation or binary translation.\n *\n * Copyright (C) 2006 Qumranet, Inc.\n * Copyright 2010 Red Hat, Inc. and/or its affiliates.\n *\n * Authors:\n *   Avi Kivity   <avi@qumranet.com>\n *   Yaniv Kamay  <yaniv@qumranet.com>\n */\n\n#include <kvm/iodev.h>\n\n#include <linux/kvm_host.h>\n#include <linux/kvm.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/miscdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/reboot.h>\n#include <linux/debugfs.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/syscore_ops.h>\n#include <linux/cpu.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/stat.h>\n#include <linux/cpumask.h>\n#include <linux/smp.h>\n#include <linux/anon_inodes.h>\n#include <linux/profile.h>\n#include <linux/kvm_para.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/bitops.h>\n#include <linux/spinlock.h>\n#include <linux/compat.h>\n#include <linux/srcu.h>\n#include <linux/hugetlb.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/io.h>\n#include <linux/lockdep.h>\n#include <linux/kthread.h>\n#include <linux/suspend.h>\n\n#include <asm/processor.h>\n#include <asm/ioctl.h>\n#include <linux/uaccess.h>\n\n#include \"coalesced_mmio.h\"\n#include \"async_pf.h\"\n#include \"kvm_mm.h\"\n#include \"vfio.h\"\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/kvm.h>\n\n#include <linux/kvm_dirty_ring.h>\n\n/* Worst case buffer size needed for holding an integer. */\n#define ITOA_MAX_LEN 12\n\nMODULE_AUTHOR(\"Qumranet\");\nMODULE_LICENSE(\"GPL\");\n\n/* Architectures should define their poll value according to the halt latency */\nunsigned int halt_poll_ns = KVM_HALT_POLL_NS_DEFAULT;\nmodule_param(halt_poll_ns, uint, 0644);\nEXPORT_SYMBOL_GPL(halt_poll_ns);\n\n/* Default doubles per-vcpu halt_poll_ns. */\nunsigned int halt_poll_ns_grow = 2;\nmodule_param(halt_poll_ns_grow, uint, 0644);\nEXPORT_SYMBOL_GPL(halt_poll_ns_grow);\n\n/* The start value to grow halt_poll_ns from */\nunsigned int halt_poll_ns_grow_start = 10000; /* 10us */\nmodule_param(halt_poll_ns_grow_start, uint, 0644);\nEXPORT_SYMBOL_GPL(halt_poll_ns_grow_start);\n\n/* Default resets per-vcpu halt_poll_ns . */\nunsigned int halt_poll_ns_shrink;\nmodule_param(halt_poll_ns_shrink, uint, 0644);\nEXPORT_SYMBOL_GPL(halt_poll_ns_shrink);\n\n/*\n * Ordering of locks:\n *\n *\tkvm->lock --> kvm->slots_lock --> kvm->irq_lock\n */\n\nDEFINE_MUTEX(kvm_lock);\nstatic DEFINE_RAW_SPINLOCK(kvm_count_lock);\nLIST_HEAD(vm_list);\n\nstatic cpumask_var_t cpus_hardware_enabled;\nstatic int kvm_usage_count;\nstatic atomic_t hardware_enable_failed;\n\nstatic struct kmem_cache *kvm_vcpu_cache;\n\nstatic __read_mostly struct preempt_ops kvm_preempt_ops;\nstatic DEFINE_PER_CPU(struct kvm_vcpu *, kvm_running_vcpu);\n\nstruct dentry *kvm_debugfs_dir;\nEXPORT_SYMBOL_GPL(kvm_debugfs_dir);\n\nstatic const struct file_operations stat_fops_per_vm;\n\nstatic struct file_operations kvm_chardev_ops;\n\nstatic long kvm_vcpu_ioctl(struct file *file, unsigned int ioctl,\n\t\t\t   unsigned long arg);\n#ifdef CONFIG_KVM_COMPAT\nstatic long kvm_vcpu_compat_ioctl(struct file *file, unsigned int ioctl,\n\t\t\t\t  unsigned long arg);\n#define KVM_COMPAT(c)\t.compat_ioctl\t= (c)\n#else\n/*\n * For architectures that don't implement a compat infrastructure,\n * adopt a double line of defense:\n * - Prevent a compat task from opening /dev/kvm\n * - If the open has been done by a 64bit task, and the KVM fd\n *   passed to a compat task, let the ioctls fail.\n */\nstatic long kvm_no_compat_ioctl(struct file *file, unsigned int ioctl,\n\t\t\t\tunsigned long arg) { return -EINVAL; }\n\nstatic int kvm_no_compat_open(struct inode *inode, struct file *file)\n{\n\treturn is_compat_task() ? -ENODEV : 0;\n}\n#define KVM_COMPAT(c)\t.compat_ioctl\t= kvm_no_compat_ioctl,\t\\\n\t\t\t.open\t\t= kvm_no_compat_open\n#endif\nstatic int hardware_enable_all(void);\nstatic void hardware_disable_all(void);\n\nstatic void kvm_io_bus_destroy(struct kvm_io_bus *bus);\n\n__visible bool kvm_rebooting;\nEXPORT_SYMBOL_GPL(kvm_rebooting);\n\n#define KVM_EVENT_CREATE_VM 0\n#define KVM_EVENT_DESTROY_VM 1\nstatic void kvm_uevent_notify_change(unsigned int type, struct kvm *kvm);\nstatic unsigned long long kvm_createvm_count;\nstatic unsigned long long kvm_active_vms;\n\nstatic DEFINE_PER_CPU(cpumask_var_t, cpu_kick_mask);\n\n__weak void kvm_arch_mmu_notifier_invalidate_range(struct kvm *kvm,\n\t\t\t\t\t\t   unsigned long start, unsigned long end)\n{\n}\n\nbool kvm_is_zone_device_pfn(kvm_pfn_t pfn)\n{\n\t/*\n\t * The metadata used by is_zone_device_page() to determine whether or\n\t * not a page is ZONE_DEVICE is guaranteed to be valid if and only if\n\t * the device has been pinned, e.g. by get_user_pages().  WARN if the\n\t * page_count() is zero to help detect bad usage of this helper.\n\t */\n\tif (!pfn_valid(pfn) || WARN_ON_ONCE(!page_count(pfn_to_page(pfn))))\n\t\treturn false;\n\n\treturn is_zone_device_page(pfn_to_page(pfn));\n}\n\nbool kvm_is_reserved_pfn(kvm_pfn_t pfn)\n{\n\t/*\n\t * ZONE_DEVICE pages currently set PG_reserved, but from a refcounting\n\t * perspective they are \"normal\" pages, albeit with slightly different\n\t * usage rules.\n\t */\n\tif (pfn_valid(pfn))\n\t\treturn PageReserved(pfn_to_page(pfn)) &&\n\t\t       !is_zero_pfn(pfn) &&\n\t\t       !kvm_is_zone_device_pfn(pfn);\n\n\treturn true;\n}\n\n/*\n * Switches to specified vcpu, until a matching vcpu_put()\n */\nvoid vcpu_load(struct kvm_vcpu *vcpu)\n{\n\tint cpu = get_cpu();\n\n\t__this_cpu_write(kvm_running_vcpu, vcpu);\n\tpreempt_notifier_register(&vcpu->preempt_notifier);\n\tkvm_arch_vcpu_load(vcpu, cpu);\n\tput_cpu();\n}\nEXPORT_SYMBOL_GPL(vcpu_load);\n\nvoid vcpu_put(struct kvm_vcpu *vcpu)\n{\n\tpreempt_disable();\n\tkvm_arch_vcpu_put(vcpu);\n\tpreempt_notifier_unregister(&vcpu->preempt_notifier);\n\t__this_cpu_write(kvm_running_vcpu, NULL);\n\tpreempt_enable();\n}\nEXPORT_SYMBOL_GPL(vcpu_put);\n\n/* TODO: merge with kvm_arch_vcpu_should_kick */\nstatic bool kvm_request_needs_ipi(struct kvm_vcpu *vcpu, unsigned req)\n{\n\tint mode = kvm_vcpu_exiting_guest_mode(vcpu);\n\n\t/*\n\t * We need to wait for the VCPU to reenable interrupts and get out of\n\t * READING_SHADOW_PAGE_TABLES mode.\n\t */\n\tif (req & KVM_REQUEST_WAIT)\n\t\treturn mode != OUTSIDE_GUEST_MODE;\n\n\t/*\n\t * Need to kick a running VCPU, but otherwise there is nothing to do.\n\t */\n\treturn mode == IN_GUEST_MODE;\n}\n\nstatic void ack_flush(void *_completed)\n{\n}\n\nstatic inline bool kvm_kick_many_cpus(struct cpumask *cpus, bool wait)\n{\n\tif (cpumask_empty(cpus))\n\t\treturn false;\n\n\tsmp_call_function_many(cpus, ack_flush, NULL, wait);\n\treturn true;\n}\n\nstatic void kvm_make_vcpu_request(struct kvm_vcpu *vcpu, unsigned int req,\n\t\t\t\t  struct cpumask *tmp, int current_cpu)\n{\n\tint cpu;\n\n\tif (likely(!(req & KVM_REQUEST_NO_ACTION)))\n\t\t__kvm_make_request(req, vcpu);\n\n\tif (!(req & KVM_REQUEST_NO_WAKEUP) && kvm_vcpu_wake_up(vcpu))\n\t\treturn;\n\n\t/*\n\t * Note, the vCPU could get migrated to a different pCPU at any point\n\t * after kvm_request_needs_ipi(), which could result in sending an IPI\n\t * to the previous pCPU.  But, that's OK because the purpose of the IPI\n\t * is to ensure the vCPU returns to OUTSIDE_GUEST_MODE, which is\n\t * satisfied if the vCPU migrates. Entering READING_SHADOW_PAGE_TABLES\n\t * after this point is also OK, as the requirement is only that KVM wait\n\t * for vCPUs that were reading SPTEs _before_ any changes were\n\t * finalized. See kvm_vcpu_kick() for more details on handling requests.\n\t */\n\tif (kvm_request_needs_ipi(vcpu, req)) {\n\t\tcpu = READ_ONCE(vcpu->cpu);\n\t\tif (cpu != -1 && cpu != current_cpu)\n\t\t\t__cpumask_set_cpu(cpu, tmp);\n\t}\n}\n\nbool kvm_make_vcpus_request_mask(struct kvm *kvm, unsigned int req,\n\t\t\t\t unsigned long *vcpu_bitmap)\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct cpumask *cpus;\n\tint i, me;\n\tbool called;\n\n\tme = get_cpu();\n\n\tcpus = this_cpu_cpumask_var_ptr(cpu_kick_mask);\n\tcpumask_clear(cpus);\n\n\tfor_each_set_bit(i, vcpu_bitmap, KVM_MAX_VCPUS) {\n\t\tvcpu = kvm_get_vcpu(kvm, i);\n\t\tif (!vcpu)\n\t\t\tcontinue;\n\t\tkvm_make_vcpu_request(vcpu, req, cpus, me);\n\t}\n\n\tcalled = kvm_kick_many_cpus(cpus, !!(req & KVM_REQUEST_WAIT));\n\tput_cpu();\n\n\treturn called;\n}\n\nbool kvm_make_all_cpus_request_except(struct kvm *kvm, unsigned int req,\n\t\t\t\t      struct kvm_vcpu *except)\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct cpumask *cpus;\n\tunsigned long i;\n\tbool called;\n\tint me;\n\n\tme = get_cpu();\n\n\tcpus = this_cpu_cpumask_var_ptr(cpu_kick_mask);\n\tcpumask_clear(cpus);\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (vcpu == except)\n\t\t\tcontinue;\n\t\tkvm_make_vcpu_request(vcpu, req, cpus, me);\n\t}\n\n\tcalled = kvm_kick_many_cpus(cpus, !!(req & KVM_REQUEST_WAIT));\n\tput_cpu();\n\n\treturn called;\n}\n\nbool kvm_make_all_cpus_request(struct kvm *kvm, unsigned int req)\n{\n\treturn kvm_make_all_cpus_request_except(kvm, req, NULL);\n}\nEXPORT_SYMBOL_GPL(kvm_make_all_cpus_request);\n\n#ifndef CONFIG_HAVE_KVM_ARCH_TLB_FLUSH_ALL\nvoid kvm_flush_remote_tlbs(struct kvm *kvm)\n{\n\t++kvm->stat.generic.remote_tlb_flush_requests;\n\n\t/*\n\t * We want to publish modifications to the page tables before reading\n\t * mode. Pairs with a memory barrier in arch-specific code.\n\t * - x86: smp_mb__after_srcu_read_unlock in vcpu_enter_guest\n\t * and smp_mb in walk_shadow_page_lockless_begin/end.\n\t * - powerpc: smp_mb in kvmppc_prepare_to_enter.\n\t *\n\t * There is already an smp_mb__after_atomic() before\n\t * kvm_make_all_cpus_request() reads vcpu->mode. We reuse that\n\t * barrier here.\n\t */\n\tif (!kvm_arch_flush_remote_tlb(kvm)\n\t    || kvm_make_all_cpus_request(kvm, KVM_REQ_TLB_FLUSH))\n\t\t++kvm->stat.generic.remote_tlb_flush;\n}\nEXPORT_SYMBOL_GPL(kvm_flush_remote_tlbs);\n#endif\n\n#ifdef KVM_ARCH_NR_OBJS_PER_MEMORY_CACHE\nstatic inline void *mmu_memory_cache_alloc_obj(struct kvm_mmu_memory_cache *mc,\n\t\t\t\t\t       gfp_t gfp_flags)\n{\n\tgfp_flags |= mc->gfp_zero;\n\n\tif (mc->kmem_cache)\n\t\treturn kmem_cache_alloc(mc->kmem_cache, gfp_flags);\n\telse\n\t\treturn (void *)__get_free_page(gfp_flags);\n}\n\nint kvm_mmu_topup_memory_cache(struct kvm_mmu_memory_cache *mc, int min)\n{\n\tvoid *obj;\n\n\tif (mc->nobjs >= min)\n\t\treturn 0;\n\twhile (mc->nobjs < ARRAY_SIZE(mc->objects)) {\n\t\tobj = mmu_memory_cache_alloc_obj(mc, GFP_KERNEL_ACCOUNT);\n\t\tif (!obj)\n\t\t\treturn mc->nobjs >= min ? 0 : -ENOMEM;\n\t\tmc->objects[mc->nobjs++] = obj;\n\t}\n\treturn 0;\n}\n\nint kvm_mmu_memory_cache_nr_free_objects(struct kvm_mmu_memory_cache *mc)\n{\n\treturn mc->nobjs;\n}\n\nvoid kvm_mmu_free_memory_cache(struct kvm_mmu_memory_cache *mc)\n{\n\twhile (mc->nobjs) {\n\t\tif (mc->kmem_cache)\n\t\t\tkmem_cache_free(mc->kmem_cache, mc->objects[--mc->nobjs]);\n\t\telse\n\t\t\tfree_page((unsigned long)mc->objects[--mc->nobjs]);\n\t}\n}\n\nvoid *kvm_mmu_memory_cache_alloc(struct kvm_mmu_memory_cache *mc)\n{\n\tvoid *p;\n\n\tif (WARN_ON(!mc->nobjs))\n\t\tp = mmu_memory_cache_alloc_obj(mc, GFP_ATOMIC | __GFP_ACCOUNT);\n\telse\n\t\tp = mc->objects[--mc->nobjs];\n\tBUG_ON(!p);\n\treturn p;\n}\n#endif\n\nstatic void kvm_vcpu_init(struct kvm_vcpu *vcpu, struct kvm *kvm, unsigned id)\n{\n\tmutex_init(&vcpu->mutex);\n\tvcpu->cpu = -1;\n\tvcpu->kvm = kvm;\n\tvcpu->vcpu_id = id;\n\tvcpu->pid = NULL;\n#ifndef __KVM_HAVE_ARCH_WQP\n\trcuwait_init(&vcpu->wait);\n#endif\n\tkvm_async_pf_vcpu_init(vcpu);\n\n\tkvm_vcpu_set_in_spin_loop(vcpu, false);\n\tkvm_vcpu_set_dy_eligible(vcpu, false);\n\tvcpu->preempted = false;\n\tvcpu->ready = false;\n\tpreempt_notifier_init(&vcpu->preempt_notifier, &kvm_preempt_ops);\n\tvcpu->last_used_slot = NULL;\n}\n\nstatic void kvm_vcpu_destroy(struct kvm_vcpu *vcpu)\n{\n\tkvm_arch_vcpu_destroy(vcpu);\n\tkvm_dirty_ring_free(&vcpu->dirty_ring);\n\n\t/*\n\t * No need for rcu_read_lock as VCPU_RUN is the only place that changes\n\t * the vcpu->pid pointer, and at destruction time all file descriptors\n\t * are already gone.\n\t */\n\tput_pid(rcu_dereference_protected(vcpu->pid, 1));\n\n\tfree_page((unsigned long)vcpu->run);\n\tkmem_cache_free(kvm_vcpu_cache, vcpu);\n}\n\nvoid kvm_destroy_vcpus(struct kvm *kvm)\n{\n\tunsigned long i;\n\tstruct kvm_vcpu *vcpu;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tkvm_vcpu_destroy(vcpu);\n\t\txa_erase(&kvm->vcpu_array, i);\n\t}\n\n\tatomic_set(&kvm->online_vcpus, 0);\n}\nEXPORT_SYMBOL_GPL(kvm_destroy_vcpus);\n\n#if defined(CONFIG_MMU_NOTIFIER) && defined(KVM_ARCH_WANT_MMU_NOTIFIER)\nstatic inline struct kvm *mmu_notifier_to_kvm(struct mmu_notifier *mn)\n{\n\treturn container_of(mn, struct kvm, mmu_notifier);\n}\n\nstatic void kvm_mmu_notifier_invalidate_range(struct mmu_notifier *mn,\n\t\t\t\t\t      struct mm_struct *mm,\n\t\t\t\t\t      unsigned long start, unsigned long end)\n{\n\tstruct kvm *kvm = mmu_notifier_to_kvm(mn);\n\tint idx;\n\n\tidx = srcu_read_lock(&kvm->srcu);\n\tkvm_arch_mmu_notifier_invalidate_range(kvm, start, end);\n\tsrcu_read_unlock(&kvm->srcu, idx);\n}\n\ntypedef bool (*hva_handler_t)(struct kvm *kvm, struct kvm_gfn_range *range);\n\ntypedef void (*on_lock_fn_t)(struct kvm *kvm, unsigned long start,\n\t\t\t     unsigned long end);\n\nstruct kvm_hva_range {\n\tunsigned long start;\n\tunsigned long end;\n\tpte_t pte;\n\thva_handler_t handler;\n\ton_lock_fn_t on_lock;\n\tbool flush_on_ret;\n\tbool may_block;\n};\n\n/*\n * Use a dedicated stub instead of NULL to indicate that there is no callback\n * function/handler.  The compiler technically can't guarantee that a real\n * function will have a non-zero address, and so it will generate code to\n * check for !NULL, whereas comparing against a stub will be elided at compile\n * time (unless the compiler is getting long in the tooth, e.g. gcc 4.9).\n */\nstatic void kvm_null_fn(void)\n{\n\n}\n#define IS_KVM_NULL_FN(fn) ((fn) == (void *)kvm_null_fn)\n\n/* Iterate over each memslot intersecting [start, last] (inclusive) range */\n#define kvm_for_each_memslot_in_hva_range(node, slots, start, last)\t     \\\n\tfor (node = interval_tree_iter_first(&slots->hva_tree, start, last); \\\n\t     node;\t\t\t\t\t\t\t     \\\n\t     node = interval_tree_iter_next(node, start, last))\t     \\\n\nstatic __always_inline int __kvm_handle_hva_range(struct kvm *kvm,\n\t\t\t\t\t\t  const struct kvm_hva_range *range)\n{\n\tbool ret = false, locked = false;\n\tstruct kvm_gfn_range gfn_range;\n\tstruct kvm_memory_slot *slot;\n\tstruct kvm_memslots *slots;\n\tint i, idx;\n\n\tif (WARN_ON_ONCE(range->end <= range->start))\n\t\treturn 0;\n\n\t/* A null handler is allowed if and only if on_lock() is provided. */\n\tif (WARN_ON_ONCE(IS_KVM_NULL_FN(range->on_lock) &&\n\t\t\t IS_KVM_NULL_FN(range->handler)))\n\t\treturn 0;\n\n\tidx = srcu_read_lock(&kvm->srcu);\n\n\tfor (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {\n\t\tstruct interval_tree_node *node;\n\n\t\tslots = __kvm_memslots(kvm, i);\n\t\tkvm_for_each_memslot_in_hva_range(node, slots,\n\t\t\t\t\t\t  range->start, range->end - 1) {\n\t\t\tunsigned long hva_start, hva_end;\n\n\t\t\tslot = container_of(node, struct kvm_memory_slot, hva_node[slots->node_idx]);\n\t\t\thva_start = max(range->start, slot->userspace_addr);\n\t\t\thva_end = min(range->end, slot->userspace_addr +\n\t\t\t\t\t\t  (slot->npages << PAGE_SHIFT));\n\n\t\t\t/*\n\t\t\t * To optimize for the likely case where the address\n\t\t\t * range is covered by zero or one memslots, don't\n\t\t\t * bother making these conditional (to avoid writes on\n\t\t\t * the second or later invocation of the handler).\n\t\t\t */\n\t\t\tgfn_range.pte = range->pte;\n\t\t\tgfn_range.may_block = range->may_block;\n\n\t\t\t/*\n\t\t\t * {gfn(page) | page intersects with [hva_start, hva_end)} =\n\t\t\t * {gfn_start, gfn_start+1, ..., gfn_end-1}.\n\t\t\t */\n\t\t\tgfn_range.start = hva_to_gfn_memslot(hva_start, slot);\n\t\t\tgfn_range.end = hva_to_gfn_memslot(hva_end + PAGE_SIZE - 1, slot);\n\t\t\tgfn_range.slot = slot;\n\n\t\t\tif (!locked) {\n\t\t\t\tlocked = true;\n\t\t\t\tKVM_MMU_LOCK(kvm);\n\t\t\t\tif (!IS_KVM_NULL_FN(range->on_lock))\n\t\t\t\t\trange->on_lock(kvm, range->start, range->end);\n\t\t\t\tif (IS_KVM_NULL_FN(range->handler))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret |= range->handler(kvm, &gfn_range);\n\t\t}\n\t}\n\n\tif (range->flush_on_ret && ret)\n\t\tkvm_flush_remote_tlbs(kvm);\n\n\tif (locked)\n\t\tKVM_MMU_UNLOCK(kvm);\n\n\tsrcu_read_unlock(&kvm->srcu, idx);\n\n\t/* The notifiers are averse to booleans. :-( */\n\treturn (int)ret;\n}\n\nstatic __always_inline int kvm_handle_hva_range(struct mmu_notifier *mn,\n\t\t\t\t\t\tunsigned long start,\n\t\t\t\t\t\tunsigned long end,\n\t\t\t\t\t\tpte_t pte,\n\t\t\t\t\t\thva_handler_t handler)\n{\n\tstruct kvm *kvm = mmu_notifier_to_kvm(mn);\n\tconst struct kvm_hva_range range = {\n\t\t.start\t\t= start,\n\t\t.end\t\t= end,\n\t\t.pte\t\t= pte,\n\t\t.handler\t= handler,\n\t\t.on_lock\t= (void *)kvm_null_fn,\n\t\t.flush_on_ret\t= true,\n\t\t.may_block\t= false,\n\t};\n\n\treturn __kvm_handle_hva_range(kvm, &range);\n}\n\nstatic __always_inline int kvm_handle_hva_range_no_flush(struct mmu_notifier *mn,\n\t\t\t\t\t\t\t unsigned long start,\n\t\t\t\t\t\t\t unsigned long end,\n\t\t\t\t\t\t\t hva_handler_t handler)\n{\n\tstruct kvm *kvm = mmu_notifier_to_kvm(mn);\n\tconst struct kvm_hva_range range = {\n\t\t.start\t\t= start,\n\t\t.end\t\t= end,\n\t\t.pte\t\t= __pte(0),\n\t\t.handler\t= handler,\n\t\t.on_lock\t= (void *)kvm_null_fn,\n\t\t.flush_on_ret\t= false,\n\t\t.may_block\t= false,\n\t};\n\n\treturn __kvm_handle_hva_range(kvm, &range);\n}\nstatic void kvm_mmu_notifier_change_pte(struct mmu_notifier *mn,\n\t\t\t\t\tstruct mm_struct *mm,\n\t\t\t\t\tunsigned long address,\n\t\t\t\t\tpte_t pte)\n{\n\tstruct kvm *kvm = mmu_notifier_to_kvm(mn);\n\n\ttrace_kvm_set_spte_hva(address);\n\n\t/*\n\t * .change_pte() must be surrounded by .invalidate_range_{start,end}().\n\t * If mmu_notifier_count is zero, then no in-progress invalidations,\n\t * including this one, found a relevant memslot at start(); rechecking\n\t * memslots here is unnecessary.  Note, a false positive (count elevated\n\t * by a different invalidation) is sub-optimal but functionally ok.\n\t */\n\tWARN_ON_ONCE(!READ_ONCE(kvm->mn_active_invalidate_count));\n\tif (!READ_ONCE(kvm->mmu_notifier_count))\n\t\treturn;\n\n\tkvm_handle_hva_range(mn, address, address + 1, pte, kvm_set_spte_gfn);\n}\n\nvoid kvm_inc_notifier_count(struct kvm *kvm, unsigned long start,\n\t\t\t\t   unsigned long end)\n{\n\t/*\n\t * The count increase must become visible at unlock time as no\n\t * spte can be established without taking the mmu_lock and\n\t * count is also read inside the mmu_lock critical section.\n\t */\n\tkvm->mmu_notifier_count++;\n\tif (likely(kvm->mmu_notifier_count == 1)) {\n\t\tkvm->mmu_notifier_range_start = start;\n\t\tkvm->mmu_notifier_range_end = end;\n\t} else {\n\t\t/*\n\t\t * Fully tracking multiple concurrent ranges has dimishing\n\t\t * returns. Keep things simple and just find the minimal range\n\t\t * which includes the current and new ranges. As there won't be\n\t\t * enough information to subtract a range after its invalidate\n\t\t * completes, any ranges invalidated concurrently will\n\t\t * accumulate and persist until all outstanding invalidates\n\t\t * complete.\n\t\t */\n\t\tkvm->mmu_notifier_range_start =\n\t\t\tmin(kvm->mmu_notifier_range_start, start);\n\t\tkvm->mmu_notifier_range_end =\n\t\t\tmax(kvm->mmu_notifier_range_end, end);\n\t}\n}\n\nstatic int kvm_mmu_notifier_invalidate_range_start(struct mmu_notifier *mn,\n\t\t\t\t\tconst struct mmu_notifier_range *range)\n{\n\tstruct kvm *kvm = mmu_notifier_to_kvm(mn);\n\tconst struct kvm_hva_range hva_range = {\n\t\t.start\t\t= range->start,\n\t\t.end\t\t= range->end,\n\t\t.pte\t\t= __pte(0),\n\t\t.handler\t= kvm_unmap_gfn_range,\n\t\t.on_lock\t= kvm_inc_notifier_count,\n\t\t.flush_on_ret\t= true,\n\t\t.may_block\t= mmu_notifier_range_blockable(range),\n\t};\n\n\ttrace_kvm_unmap_hva_range(range->start, range->end);\n\n\t/*\n\t * Prevent memslot modification between range_start() and range_end()\n\t * so that conditionally locking provides the same result in both\n\t * functions.  Without that guarantee, the mmu_notifier_count\n\t * adjustments will be imbalanced.\n\t *\n\t * Pairs with the decrement in range_end().\n\t */\n\tspin_lock(&kvm->mn_invalidate_lock);\n\tkvm->mn_active_invalidate_count++;\n\tspin_unlock(&kvm->mn_invalidate_lock);\n\n\tgfn_to_pfn_cache_invalidate_start(kvm, range->start, range->end,\n\t\t\t\t\t  hva_range.may_block);\n\n\t__kvm_handle_hva_range(kvm, &hva_range);\n\n\treturn 0;\n}\n\nvoid kvm_dec_notifier_count(struct kvm *kvm, unsigned long start,\n\t\t\t\t   unsigned long end)\n{\n\t/*\n\t * This sequence increase will notify the kvm page fault that\n\t * the page that is going to be mapped in the spte could have\n\t * been freed.\n\t */\n\tkvm->mmu_notifier_seq++;\n\tsmp_wmb();\n\t/*\n\t * The above sequence increase must be visible before the\n\t * below count decrease, which is ensured by the smp_wmb above\n\t * in conjunction with the smp_rmb in mmu_notifier_retry().\n\t */\n\tkvm->mmu_notifier_count--;\n}\n\nstatic void kvm_mmu_notifier_invalidate_range_end(struct mmu_notifier *mn,\n\t\t\t\t\tconst struct mmu_notifier_range *range)\n{\n\tstruct kvm *kvm = mmu_notifier_to_kvm(mn);\n\tconst struct kvm_hva_range hva_range = {\n\t\t.start\t\t= range->start,\n\t\t.end\t\t= range->end,\n\t\t.pte\t\t= __pte(0),\n\t\t.handler\t= (void *)kvm_null_fn,\n\t\t.on_lock\t= kvm_dec_notifier_count,\n\t\t.flush_on_ret\t= false,\n\t\t.may_block\t= mmu_notifier_range_blockable(range),\n\t};\n\tbool wake;\n\n\t__kvm_handle_hva_range(kvm, &hva_range);\n\n\t/* Pairs with the increment in range_start(). */\n\tspin_lock(&kvm->mn_invalidate_lock);\n\twake = (--kvm->mn_active_invalidate_count == 0);\n\tspin_unlock(&kvm->mn_invalidate_lock);\n\n\t/*\n\t * There can only be one waiter, since the wait happens under\n\t * slots_lock.\n\t */\n\tif (wake)\n\t\trcuwait_wake_up(&kvm->mn_memslots_update_rcuwait);\n\n\tBUG_ON(kvm->mmu_notifier_count < 0);\n}\n\nstatic int kvm_mmu_notifier_clear_flush_young(struct mmu_notifier *mn,\n\t\t\t\t\t      struct mm_struct *mm,\n\t\t\t\t\t      unsigned long start,\n\t\t\t\t\t      unsigned long end)\n{\n\ttrace_kvm_age_hva(start, end);\n\n\treturn kvm_handle_hva_range(mn, start, end, __pte(0), kvm_age_gfn);\n}\n\nstatic int kvm_mmu_notifier_clear_young(struct mmu_notifier *mn,\n\t\t\t\t\tstruct mm_struct *mm,\n\t\t\t\t\tunsigned long start,\n\t\t\t\t\tunsigned long end)\n{\n\ttrace_kvm_age_hva(start, end);\n\n\t/*\n\t * Even though we do not flush TLB, this will still adversely\n\t * affect performance on pre-Haswell Intel EPT, where there is\n\t * no EPT Access Bit to clear so that we have to tear down EPT\n\t * tables instead. If we find this unacceptable, we can always\n\t * add a parameter to kvm_age_hva so that it effectively doesn't\n\t * do anything on clear_young.\n\t *\n\t * Also note that currently we never issue secondary TLB flushes\n\t * from clear_young, leaving this job up to the regular system\n\t * cadence. If we find this inaccurate, we might come up with a\n\t * more sophisticated heuristic later.\n\t */\n\treturn kvm_handle_hva_range_no_flush(mn, start, end, kvm_age_gfn);\n}\n\nstatic int kvm_mmu_notifier_test_young(struct mmu_notifier *mn,\n\t\t\t\t       struct mm_struct *mm,\n\t\t\t\t       unsigned long address)\n{\n\ttrace_kvm_test_age_hva(address);\n\n\treturn kvm_handle_hva_range_no_flush(mn, address, address + 1,\n\t\t\t\t\t     kvm_test_age_gfn);\n}\n\nstatic void kvm_mmu_notifier_release(struct mmu_notifier *mn,\n\t\t\t\t     struct mm_struct *mm)\n{\n\tstruct kvm *kvm = mmu_notifier_to_kvm(mn);\n\tint idx;\n\n\tidx = srcu_read_lock(&kvm->srcu);\n\tkvm_arch_flush_shadow_all(kvm);\n\tsrcu_read_unlock(&kvm->srcu, idx);\n}\n\nstatic const struct mmu_notifier_ops kvm_mmu_notifier_ops = {\n\t.invalidate_range\t= kvm_mmu_notifier_invalidate_range,\n\t.invalidate_range_start\t= kvm_mmu_notifier_invalidate_range_start,\n\t.invalidate_range_end\t= kvm_mmu_notifier_invalidate_range_end,\n\t.clear_flush_young\t= kvm_mmu_notifier_clear_flush_young,\n\t.clear_young\t\t= kvm_mmu_notifier_clear_young,\n\t.test_young\t\t= kvm_mmu_notifier_test_young,\n\t.change_pte\t\t= kvm_mmu_notifier_change_pte,\n\t.release\t\t= kvm_mmu_notifier_release,\n};\n\nstatic int kvm_init_mmu_notifier(struct kvm *kvm)\n{\n\tkvm->mmu_notifier.ops = &kvm_mmu_notifier_ops;\n\treturn mmu_notifier_register(&kvm->mmu_notifier, current->mm);\n}\n\n#else  /* !(CONFIG_MMU_NOTIFIER && KVM_ARCH_WANT_MMU_NOTIFIER) */\n\nstatic int kvm_init_mmu_notifier(struct kvm *kvm)\n{\n\treturn 0;\n}\n\n#endif /* CONFIG_MMU_NOTIFIER && KVM_ARCH_WANT_MMU_NOTIFIER */\n\n#ifdef CONFIG_HAVE_KVM_PM_NOTIFIER\nstatic int kvm_pm_notifier_call(struct notifier_block *bl,\n\t\t\t\tunsigned long state,\n\t\t\t\tvoid *unused)\n{\n\tstruct kvm *kvm = container_of(bl, struct kvm, pm_notifier);\n\n\treturn kvm_arch_pm_notifier(kvm, state);\n}\n\nstatic void kvm_init_pm_notifier(struct kvm *kvm)\n{\n\tkvm->pm_notifier.notifier_call = kvm_pm_notifier_call;\n\t/* Suspend KVM before we suspend ftrace, RCU, etc. */\n\tkvm->pm_notifier.priority = INT_MAX;\n\tregister_pm_notifier(&kvm->pm_notifier);\n}\n\nstatic void kvm_destroy_pm_notifier(struct kvm *kvm)\n{\n\tunregister_pm_notifier(&kvm->pm_notifier);\n}\n#else /* !CONFIG_HAVE_KVM_PM_NOTIFIER */\nstatic void kvm_init_pm_notifier(struct kvm *kvm)\n{\n}\n\nstatic void kvm_destroy_pm_notifier(struct kvm *kvm)\n{\n}\n#endif /* CONFIG_HAVE_KVM_PM_NOTIFIER */\n\nstatic void kvm_destroy_dirty_bitmap(struct kvm_memory_slot *memslot)\n{\n\tif (!memslot->dirty_bitmap)\n\t\treturn;\n\n\tkvfree(memslot->dirty_bitmap);\n\tmemslot->dirty_bitmap = NULL;\n}\n\n/* This does not remove the slot from struct kvm_memslots data structures */\nstatic void kvm_free_memslot(struct kvm *kvm, struct kvm_memory_slot *slot)\n{\n\tkvm_destroy_dirty_bitmap(slot);\n\n\tkvm_arch_free_memslot(kvm, slot);\n\n\tkfree(slot);\n}\n\nstatic void kvm_free_memslots(struct kvm *kvm, struct kvm_memslots *slots)\n{\n\tstruct hlist_node *idnode;\n\tstruct kvm_memory_slot *memslot;\n\tint bkt;\n\n\t/*\n\t * The same memslot objects live in both active and inactive sets,\n\t * arbitrarily free using index '1' so the second invocation of this\n\t * function isn't operating over a structure with dangling pointers\n\t * (even though this function isn't actually touching them).\n\t */\n\tif (!slots->node_idx)\n\t\treturn;\n\n\thash_for_each_safe(slots->id_hash, bkt, idnode, memslot, id_node[1])\n\t\tkvm_free_memslot(kvm, memslot);\n}\n\nstatic umode_t kvm_stats_debugfs_mode(const struct _kvm_stats_desc *pdesc)\n{\n\tswitch (pdesc->desc.flags & KVM_STATS_TYPE_MASK) {\n\tcase KVM_STATS_TYPE_INSTANT:\n\t\treturn 0444;\n\tcase KVM_STATS_TYPE_CUMULATIVE:\n\tcase KVM_STATS_TYPE_PEAK:\n\tdefault:\n\t\treturn 0644;\n\t}\n}\n\n\nstatic void kvm_destroy_vm_debugfs(struct kvm *kvm)\n{\n\tint i;\n\tint kvm_debugfs_num_entries = kvm_vm_stats_header.num_desc +\n\t\t\t\t      kvm_vcpu_stats_header.num_desc;\n\n\tif (!kvm->debugfs_dentry)\n\t\treturn;\n\n\tdebugfs_remove_recursive(kvm->debugfs_dentry);\n\n\tif (kvm->debugfs_stat_data) {\n\t\tfor (i = 0; i < kvm_debugfs_num_entries; i++)\n\t\t\tkfree(kvm->debugfs_stat_data[i]);\n\t\tkfree(kvm->debugfs_stat_data);\n\t}\n}\n\nstatic int kvm_create_vm_debugfs(struct kvm *kvm, int fd)\n{\n\tstatic DEFINE_MUTEX(kvm_debugfs_lock);\n\tstruct dentry *dent;\n\tchar dir_name[ITOA_MAX_LEN * 2];\n\tstruct kvm_stat_data *stat_data;\n\tconst struct _kvm_stats_desc *pdesc;\n\tint i, ret;\n\tint kvm_debugfs_num_entries = kvm_vm_stats_header.num_desc +\n\t\t\t\t      kvm_vcpu_stats_header.num_desc;\n\n\tif (!debugfs_initialized())\n\t\treturn 0;\n\n\tsnprintf(dir_name, sizeof(dir_name), \"%d-%d\", task_pid_nr(current), fd);\n\tmutex_lock(&kvm_debugfs_lock);\n\tdent = debugfs_lookup(dir_name, kvm_debugfs_dir);\n\tif (dent) {\n\t\tpr_warn_ratelimited(\"KVM: debugfs: duplicate directory %s\\n\", dir_name);\n\t\tdput(dent);\n\t\tmutex_unlock(&kvm_debugfs_lock);\n\t\treturn 0;\n\t}\n\tdent = debugfs_create_dir(dir_name, kvm_debugfs_dir);\n\tmutex_unlock(&kvm_debugfs_lock);\n\tif (IS_ERR(dent))\n\t\treturn 0;\n\n\tkvm->debugfs_dentry = dent;\n\tkvm->debugfs_stat_data = kcalloc(kvm_debugfs_num_entries,\n\t\t\t\t\t sizeof(*kvm->debugfs_stat_data),\n\t\t\t\t\t GFP_KERNEL_ACCOUNT);\n\tif (!kvm->debugfs_stat_data)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < kvm_vm_stats_header.num_desc; ++i) {\n\t\tpdesc = &kvm_vm_stats_desc[i];\n\t\tstat_data = kzalloc(sizeof(*stat_data), GFP_KERNEL_ACCOUNT);\n\t\tif (!stat_data)\n\t\t\treturn -ENOMEM;\n\n\t\tstat_data->kvm = kvm;\n\t\tstat_data->desc = pdesc;\n\t\tstat_data->kind = KVM_STAT_VM;\n\t\tkvm->debugfs_stat_data[i] = stat_data;\n\t\tdebugfs_create_file(pdesc->name, kvm_stats_debugfs_mode(pdesc),\n\t\t\t\t    kvm->debugfs_dentry, stat_data,\n\t\t\t\t    &stat_fops_per_vm);\n\t}\n\n\tfor (i = 0; i < kvm_vcpu_stats_header.num_desc; ++i) {\n\t\tpdesc = &kvm_vcpu_stats_desc[i];\n\t\tstat_data = kzalloc(sizeof(*stat_data), GFP_KERNEL_ACCOUNT);\n\t\tif (!stat_data)\n\t\t\treturn -ENOMEM;\n\n\t\tstat_data->kvm = kvm;\n\t\tstat_data->desc = pdesc;\n\t\tstat_data->kind = KVM_STAT_VCPU;\n\t\tkvm->debugfs_stat_data[i + kvm_vm_stats_header.num_desc] = stat_data;\n\t\tdebugfs_create_file(pdesc->name, kvm_stats_debugfs_mode(pdesc),\n\t\t\t\t    kvm->debugfs_dentry, stat_data,\n\t\t\t\t    &stat_fops_per_vm);\n\t}\n\n\tret = kvm_arch_create_vm_debugfs(kvm);\n\tif (ret) {\n\t\tkvm_destroy_vm_debugfs(kvm);\n\t\treturn i;\n\t}\n\n\treturn 0;\n}\n\n/*\n * Called after the VM is otherwise initialized, but just before adding it to\n * the vm_list.\n */\nint __weak kvm_arch_post_init_vm(struct kvm *kvm)\n{\n\treturn 0;\n}\n\n/*\n * Called just after removing the VM from the vm_list, but before doing any\n * other destruction.\n */\nvoid __weak kvm_arch_pre_destroy_vm(struct kvm *kvm)\n{\n}\n\n/*\n * Called after per-vm debugfs created.  When called kvm->debugfs_dentry should\n * be setup already, so we can create arch-specific debugfs entries under it.\n * Cleanup should be automatic done in kvm_destroy_vm_debugfs() recursively, so\n * a per-arch destroy interface is not needed.\n */\nint __weak kvm_arch_create_vm_debugfs(struct kvm *kvm)\n{\n\treturn 0;\n}\n\nstatic struct kvm *kvm_create_vm(unsigned long type)\n{\n\tstruct kvm *kvm = kvm_arch_alloc_vm();\n\tstruct kvm_memslots *slots;\n\tint r = -ENOMEM;\n\tint i, j;\n\n\tif (!kvm)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tKVM_MMU_LOCK_INIT(kvm);\n\tmmgrab(current->mm);\n\tkvm->mm = current->mm;\n\tkvm_eventfd_init(kvm);\n\tmutex_init(&kvm->lock);\n\tmutex_init(&kvm->irq_lock);\n\tmutex_init(&kvm->slots_lock);\n\tmutex_init(&kvm->slots_arch_lock);\n\tspin_lock_init(&kvm->mn_invalidate_lock);\n\trcuwait_init(&kvm->mn_memslots_update_rcuwait);\n\txa_init(&kvm->vcpu_array);\n\n\tINIT_LIST_HEAD(&kvm->gpc_list);\n\tspin_lock_init(&kvm->gpc_lock);\n\n\tINIT_LIST_HEAD(&kvm->devices);\n\n\tBUILD_BUG_ON(KVM_MEM_SLOTS_NUM > SHRT_MAX);\n\n\tif (init_srcu_struct(&kvm->srcu))\n\t\tgoto out_err_no_srcu;\n\tif (init_srcu_struct(&kvm->irq_srcu))\n\t\tgoto out_err_no_irq_srcu;\n\n\trefcount_set(&kvm->users_count, 1);\n\tfor (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {\n\t\tfor (j = 0; j < 2; j++) {\n\t\t\tslots = &kvm->__memslots[i][j];\n\n\t\t\tatomic_long_set(&slots->last_used_slot, (unsigned long)NULL);\n\t\t\tslots->hva_tree = RB_ROOT_CACHED;\n\t\t\tslots->gfn_tree = RB_ROOT;\n\t\t\thash_init(slots->id_hash);\n\t\t\tslots->node_idx = j;\n\n\t\t\t/* Generations must be different for each address space. */\n\t\t\tslots->generation = i;\n\t\t}\n\n\t\trcu_assign_pointer(kvm->memslots[i], &kvm->__memslots[i][0]);\n\t}\n\n\tfor (i = 0; i < KVM_NR_BUSES; i++) {\n\t\trcu_assign_pointer(kvm->buses[i],\n\t\t\tkzalloc(sizeof(struct kvm_io_bus), GFP_KERNEL_ACCOUNT));\n\t\tif (!kvm->buses[i])\n\t\t\tgoto out_err_no_arch_destroy_vm;\n\t}\n\n\tkvm->max_halt_poll_ns = halt_poll_ns;\n\n\tr = kvm_arch_init_vm(kvm, type);\n\tif (r)\n\t\tgoto out_err_no_arch_destroy_vm;\n\n\tr = hardware_enable_all();\n\tif (r)\n\t\tgoto out_err_no_disable;\n\n#ifdef CONFIG_HAVE_KVM_IRQFD\n\tINIT_HLIST_HEAD(&kvm->irq_ack_notifier_list);\n#endif\n\n\tr = kvm_init_mmu_notifier(kvm);\n\tif (r)\n\t\tgoto out_err_no_mmu_notifier;\n\n\tr = kvm_arch_post_init_vm(kvm);\n\tif (r)\n\t\tgoto out_err;\n\n\tmutex_lock(&kvm_lock);\n\tlist_add(&kvm->vm_list, &vm_list);\n\tmutex_unlock(&kvm_lock);\n\n\tpreempt_notifier_inc();\n\tkvm_init_pm_notifier(kvm);\n\n\t/*\n\t * When the fd passed to this ioctl() is opened it pins the module,\n\t * but try_module_get() also prevents getting a reference if the module\n\t * is in MODULE_STATE_GOING (e.g. if someone ran \"rmmod --wait\").\n\t */\n\tif (!try_module_get(kvm_chardev_ops.owner)) {\n\t\tr = -ENODEV;\n\t\tgoto out_err;\n\t}\n\n\treturn kvm;\n\nout_err:\n#if defined(CONFIG_MMU_NOTIFIER) && defined(KVM_ARCH_WANT_MMU_NOTIFIER)\n\tif (kvm->mmu_notifier.ops)\n\t\tmmu_notifier_unregister(&kvm->mmu_notifier, current->mm);\n#endif\nout_err_no_mmu_notifier:\n\thardware_disable_all();\nout_err_no_disable:\n\tkvm_arch_destroy_vm(kvm);\nout_err_no_arch_destroy_vm:\n\tWARN_ON_ONCE(!refcount_dec_and_test(&kvm->users_count));\n\tfor (i = 0; i < KVM_NR_BUSES; i++)\n\t\tkfree(kvm_get_bus(kvm, i));\n\tcleanup_srcu_struct(&kvm->irq_srcu);\nout_err_no_irq_srcu:\n\tcleanup_srcu_struct(&kvm->srcu);\nout_err_no_srcu:\n\tkvm_arch_free_vm(kvm);\n\tmmdrop(current->mm);\n\treturn ERR_PTR(r);\n}\n\nstatic void kvm_destroy_devices(struct kvm *kvm)\n{\n\tstruct kvm_device *dev, *tmp;\n\n\t/*\n\t * We do not need to take the kvm->lock here, because nobody else\n\t * has a reference to the struct kvm at this point and therefore\n\t * cannot access the devices list anyhow.\n\t */\n\tlist_for_each_entry_safe(dev, tmp, &kvm->devices, vm_node) {\n\t\tlist_del(&dev->vm_node);\n\t\tdev->ops->destroy(dev);\n\t}\n}\n\nstatic void kvm_destroy_vm(struct kvm *kvm)\n{\n\tint i;\n\tstruct mm_struct *mm = kvm->mm;\n\n\tkvm_destroy_pm_notifier(kvm);\n\tkvm_uevent_notify_change(KVM_EVENT_DESTROY_VM, kvm);\n\tkvm_destroy_vm_debugfs(kvm);\n\tkvm_arch_sync_events(kvm);\n\tmutex_lock(&kvm_lock);\n\tlist_del(&kvm->vm_list);\n\tmutex_unlock(&kvm_lock);\n\tkvm_arch_pre_destroy_vm(kvm);\n\n\tkvm_free_irq_routing(kvm);\n\tfor (i = 0; i < KVM_NR_BUSES; i++) {\n\t\tstruct kvm_io_bus *bus = kvm_get_bus(kvm, i);\n\n\t\tif (bus)\n\t\t\tkvm_io_bus_destroy(bus);\n\t\tkvm->buses[i] = NULL;\n\t}\n\tkvm_coalesced_mmio_free(kvm);\n#if defined(CONFIG_MMU_NOTIFIER) && defined(KVM_ARCH_WANT_MMU_NOTIFIER)\n\tmmu_notifier_unregister(&kvm->mmu_notifier, kvm->mm);\n\t/*\n\t * At this point, pending calls to invalidate_range_start()\n\t * have completed but no more MMU notifiers will run, so\n\t * mn_active_invalidate_count may remain unbalanced.\n\t * No threads can be waiting in install_new_memslots as the\n\t * last reference on KVM has been dropped, but freeing\n\t * memslots would deadlock without this manual intervention.\n\t */\n\tWARN_ON(rcuwait_active(&kvm->mn_memslots_update_rcuwait));\n\tkvm->mn_active_invalidate_count = 0;\n#else\n\tkvm_arch_flush_shadow_all(kvm);\n#endif\n\tkvm_arch_destroy_vm(kvm);\n\tkvm_destroy_devices(kvm);\n\tfor (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {\n\t\tkvm_free_memslots(kvm, &kvm->__memslots[i][0]);\n\t\tkvm_free_memslots(kvm, &kvm->__memslots[i][1]);\n\t}\n\tcleanup_srcu_struct(&kvm->irq_srcu);\n\tcleanup_srcu_struct(&kvm->srcu);\n\tkvm_arch_free_vm(kvm);\n\tpreempt_notifier_dec();\n\thardware_disable_all();\n\tmmdrop(mm);\n\tmodule_put(kvm_chardev_ops.owner);\n}\n\nvoid kvm_get_kvm(struct kvm *kvm)\n{\n\trefcount_inc(&kvm->users_count);\n}\nEXPORT_SYMBOL_GPL(kvm_get_kvm);\n\n/*\n * Make sure the vm is not during destruction, which is a safe version of\n * kvm_get_kvm().  Return true if kvm referenced successfully, false otherwise.\n */\nbool kvm_get_kvm_safe(struct kvm *kvm)\n{\n\treturn refcount_inc_not_zero(&kvm->users_count);\n}\nEXPORT_SYMBOL_GPL(kvm_get_kvm_safe);\n\nvoid kvm_put_kvm(struct kvm *kvm)\n{\n\tif (refcount_dec_and_test(&kvm->users_count))\n\t\tkvm_destroy_vm(kvm);\n}\nEXPORT_SYMBOL_GPL(kvm_put_kvm);\n\n/*\n * Used to put a reference that was taken on behalf of an object associated\n * with a user-visible file descriptor, e.g. a vcpu or device, if installation\n * of the new file descriptor fails and the reference cannot be transferred to\n * its final owner.  In such cases, the caller is still actively using @kvm and\n * will fail miserably if the refcount unexpectedly hits zero.\n */\nvoid kvm_put_kvm_no_destroy(struct kvm *kvm)\n{\n\tWARN_ON(refcount_dec_and_test(&kvm->users_count));\n}\nEXPORT_SYMBOL_GPL(kvm_put_kvm_no_destroy);\n\nstatic int kvm_vm_release(struct inode *inode, struct file *filp)\n{\n\tstruct kvm *kvm = filp->private_data;\n\n\tkvm_irqfd_release(kvm);\n\n\tkvm_put_kvm(kvm);\n\treturn 0;\n}\n\n/*\n * Allocation size is twice as large as the actual dirty bitmap size.\n * See kvm_vm_ioctl_get_dirty_log() why this is needed.\n */\nstatic int kvm_alloc_dirty_bitmap(struct kvm_memory_slot *memslot)\n{\n\tunsigned long dirty_bytes = kvm_dirty_bitmap_bytes(memslot);\n\n\tmemslot->dirty_bitmap = __vcalloc(2, dirty_bytes, GFP_KERNEL_ACCOUNT);\n\tif (!memslot->dirty_bitmap)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic struct kvm_memslots *kvm_get_inactive_memslots(struct kvm *kvm, int as_id)\n{\n\tstruct kvm_memslots *active = __kvm_memslots(kvm, as_id);\n\tint node_idx_inactive = active->node_idx ^ 1;\n\n\treturn &kvm->__memslots[as_id][node_idx_inactive];\n}\n\n/*\n * Helper to get the address space ID when one of memslot pointers may be NULL.\n * This also serves as a sanity that at least one of the pointers is non-NULL,\n * and that their address space IDs don't diverge.\n */\nstatic int kvm_memslots_get_as_id(struct kvm_memory_slot *a,\n\t\t\t\t  struct kvm_memory_slot *b)\n{\n\tif (WARN_ON_ONCE(!a && !b))\n\t\treturn 0;\n\n\tif (!a)\n\t\treturn b->as_id;\n\tif (!b)\n\t\treturn a->as_id;\n\n\tWARN_ON_ONCE(a->as_id != b->as_id);\n\treturn a->as_id;\n}\n\nstatic void kvm_insert_gfn_node(struct kvm_memslots *slots,\n\t\t\t\tstruct kvm_memory_slot *slot)\n{\n\tstruct rb_root *gfn_tree = &slots->gfn_tree;\n\tstruct rb_node **node, *parent;\n\tint idx = slots->node_idx;\n\n\tparent = NULL;\n\tfor (node = &gfn_tree->rb_node; *node; ) {\n\t\tstruct kvm_memory_slot *tmp;\n\n\t\ttmp = container_of(*node, struct kvm_memory_slot, gfn_node[idx]);\n\t\tparent = *node;\n\t\tif (slot->base_gfn < tmp->base_gfn)\n\t\t\tnode = &(*node)->rb_left;\n\t\telse if (slot->base_gfn > tmp->base_gfn)\n\t\t\tnode = &(*node)->rb_right;\n\t\telse\n\t\t\tBUG();\n\t}\n\n\trb_link_node(&slot->gfn_node[idx], parent, node);\n\trb_insert_color(&slot->gfn_node[idx], gfn_tree);\n}\n\nstatic void kvm_erase_gfn_node(struct kvm_memslots *slots,\n\t\t\t       struct kvm_memory_slot *slot)\n{\n\trb_erase(&slot->gfn_node[slots->node_idx], &slots->gfn_tree);\n}\n\nstatic void kvm_replace_gfn_node(struct kvm_memslots *slots,\n\t\t\t\t struct kvm_memory_slot *old,\n\t\t\t\t struct kvm_memory_slot *new)\n{\n\tint idx = slots->node_idx;\n\n\tWARN_ON_ONCE(old->base_gfn != new->base_gfn);\n\n\trb_replace_node(&old->gfn_node[idx], &new->gfn_node[idx],\n\t\t\t&slots->gfn_tree);\n}\n\n/*\n * Replace @old with @new in the inactive memslots.\n *\n * With NULL @old this simply adds @new.\n * With NULL @new this simply removes @old.\n *\n * If @new is non-NULL its hva_node[slots_idx] range has to be set\n * appropriately.\n */\nstatic void kvm_replace_memslot(struct kvm *kvm,\n\t\t\t\tstruct kvm_memory_slot *old,\n\t\t\t\tstruct kvm_memory_slot *new)\n{\n\tint as_id = kvm_memslots_get_as_id(old, new);\n\tstruct kvm_memslots *slots = kvm_get_inactive_memslots(kvm, as_id);\n\tint idx = slots->node_idx;\n\n\tif (old) {\n\t\thash_del(&old->id_node[idx]);\n\t\tinterval_tree_remove(&old->hva_node[idx], &slots->hva_tree);\n\n\t\tif ((long)old == atomic_long_read(&slots->last_used_slot))\n\t\t\tatomic_long_set(&slots->last_used_slot, (long)new);\n\n\t\tif (!new) {\n\t\t\tkvm_erase_gfn_node(slots, old);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Initialize @new's hva range.  Do this even when replacing an @old\n\t * slot, kvm_copy_memslot() deliberately does not touch node data.\n\t */\n\tnew->hva_node[idx].start = new->userspace_addr;\n\tnew->hva_node[idx].last = new->userspace_addr +\n\t\t\t\t  (new->npages << PAGE_SHIFT) - 1;\n\n\t/*\n\t * (Re)Add the new memslot.  There is no O(1) interval_tree_replace(),\n\t * hva_node needs to be swapped with remove+insert even though hva can't\n\t * change when replacing an existing slot.\n\t */\n\thash_add(slots->id_hash, &new->id_node[idx], new->id);\n\tinterval_tree_insert(&new->hva_node[idx], &slots->hva_tree);\n\n\t/*\n\t * If the memslot gfn is unchanged, rb_replace_node() can be used to\n\t * switch the node in the gfn tree instead of removing the old and\n\t * inserting the new as two separate operations. Replacement is a\n\t * single O(1) operation versus two O(log(n)) operations for\n\t * remove+insert.\n\t */\n\tif (old && old->base_gfn == new->base_gfn) {\n\t\tkvm_replace_gfn_node(slots, old, new);\n\t} else {\n\t\tif (old)\n\t\t\tkvm_erase_gfn_node(slots, old);\n\t\tkvm_insert_gfn_node(slots, new);\n\t}\n}\n\nstatic int check_memory_region_flags(const struct kvm_userspace_memory_region *mem)\n{\n\tu32 valid_flags = KVM_MEM_LOG_DIRTY_PAGES;\n\n#ifdef __KVM_HAVE_READONLY_MEM\n\tvalid_flags |= KVM_MEM_READONLY;\n#endif\n\n\tif (mem->flags & ~valid_flags)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void kvm_swap_active_memslots(struct kvm *kvm, int as_id)\n{\n\tstruct kvm_memslots *slots = kvm_get_inactive_memslots(kvm, as_id);\n\n\t/* Grab the generation from the activate memslots. */\n\tu64 gen = __kvm_memslots(kvm, as_id)->generation;\n\n\tWARN_ON(gen & KVM_MEMSLOT_GEN_UPDATE_IN_PROGRESS);\n\tslots->generation = gen | KVM_MEMSLOT_GEN_UPDATE_IN_PROGRESS;\n\n\t/*\n\t * Do not store the new memslots while there are invalidations in\n\t * progress, otherwise the locking in invalidate_range_start and\n\t * invalidate_range_end will be unbalanced.\n\t */\n\tspin_lock(&kvm->mn_invalidate_lock);\n\tprepare_to_rcuwait(&kvm->mn_memslots_update_rcuwait);\n\twhile (kvm->mn_active_invalidate_count) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tspin_unlock(&kvm->mn_invalidate_lock);\n\t\tschedule();\n\t\tspin_lock(&kvm->mn_invalidate_lock);\n\t}\n\tfinish_rcuwait(&kvm->mn_memslots_update_rcuwait);\n\trcu_assign_pointer(kvm->memslots[as_id], slots);\n\tspin_unlock(&kvm->mn_invalidate_lock);\n\n\t/*\n\t * Acquired in kvm_set_memslot. Must be released before synchronize\n\t * SRCU below in order to avoid deadlock with another thread\n\t * acquiring the slots_arch_lock in an srcu critical section.\n\t */\n\tmutex_unlock(&kvm->slots_arch_lock);\n\n\tsynchronize_srcu_expedited(&kvm->srcu);\n\n\t/*\n\t * Increment the new memslot generation a second time, dropping the\n\t * update in-progress flag and incrementing the generation based on\n\t * the number of address spaces.  This provides a unique and easily\n\t * identifiable generation number while the memslots are in flux.\n\t */\n\tgen = slots->generation & ~KVM_MEMSLOT_GEN_UPDATE_IN_PROGRESS;\n\n\t/*\n\t * Generations must be unique even across address spaces.  We do not need\n\t * a global counter for that, instead the generation space is evenly split\n\t * across address spaces.  For example, with two address spaces, address\n\t * space 0 will use generations 0, 2, 4, ... while address space 1 will\n\t * use generations 1, 3, 5, ...\n\t */\n\tgen += KVM_ADDRESS_SPACE_NUM;\n\n\tkvm_arch_memslots_updated(kvm, gen);\n\n\tslots->generation = gen;\n}\n\nstatic int kvm_prepare_memory_region(struct kvm *kvm,\n\t\t\t\t     const struct kvm_memory_slot *old,\n\t\t\t\t     struct kvm_memory_slot *new,\n\t\t\t\t     enum kvm_mr_change change)\n{\n\tint r;\n\n\t/*\n\t * If dirty logging is disabled, nullify the bitmap; the old bitmap\n\t * will be freed on \"commit\".  If logging is enabled in both old and\n\t * new, reuse the existing bitmap.  If logging is enabled only in the\n\t * new and KVM isn't using a ring buffer, allocate and initialize a\n\t * new bitmap.\n\t */\n\tif (change != KVM_MR_DELETE) {\n\t\tif (!(new->flags & KVM_MEM_LOG_DIRTY_PAGES))\n\t\t\tnew->dirty_bitmap = NULL;\n\t\telse if (old && old->dirty_bitmap)\n\t\t\tnew->dirty_bitmap = old->dirty_bitmap;\n\t\telse if (!kvm->dirty_ring_size) {\n\t\t\tr = kvm_alloc_dirty_bitmap(new);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\n\t\t\tif (kvm_dirty_log_manual_protect_and_init_set(kvm))\n\t\t\t\tbitmap_set(new->dirty_bitmap, 0, new->npages);\n\t\t}\n\t}\n\n\tr = kvm_arch_prepare_memory_region(kvm, old, new, change);\n\n\t/* Free the bitmap on failure if it was allocated above. */\n\tif (r && new && new->dirty_bitmap && old && !old->dirty_bitmap)\n\t\tkvm_destroy_dirty_bitmap(new);\n\n\treturn r;\n}\n\nstatic void kvm_commit_memory_region(struct kvm *kvm,\n\t\t\t\t     struct kvm_memory_slot *old,\n\t\t\t\t     const struct kvm_memory_slot *new,\n\t\t\t\t     enum kvm_mr_change change)\n{\n\t/*\n\t * Update the total number of memslot pages before calling the arch\n\t * hook so that architectures can consume the result directly.\n\t */\n\tif (change == KVM_MR_DELETE)\n\t\tkvm->nr_memslot_pages -= old->npages;\n\telse if (change == KVM_MR_CREATE)\n\t\tkvm->nr_memslot_pages += new->npages;\n\n\tkvm_arch_commit_memory_region(kvm, old, new, change);\n\n\tswitch (change) {\n\tcase KVM_MR_CREATE:\n\t\t/* Nothing more to do. */\n\t\tbreak;\n\tcase KVM_MR_DELETE:\n\t\t/* Free the old memslot and all its metadata. */\n\t\tkvm_free_memslot(kvm, old);\n\t\tbreak;\n\tcase KVM_MR_MOVE:\n\tcase KVM_MR_FLAGS_ONLY:\n\t\t/*\n\t\t * Free the dirty bitmap as needed; the below check encompasses\n\t\t * both the flags and whether a ring buffer is being used)\n\t\t */\n\t\tif (old->dirty_bitmap && !new->dirty_bitmap)\n\t\t\tkvm_destroy_dirty_bitmap(old);\n\n\t\t/*\n\t\t * The final quirk.  Free the detached, old slot, but only its\n\t\t * memory, not any metadata.  Metadata, including arch specific\n\t\t * data, may be reused by @new.\n\t\t */\n\t\tkfree(old);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\n/*\n * Activate @new, which must be installed in the inactive slots by the caller,\n * by swapping the active slots and then propagating @new to @old once @old is\n * unreachable and can be safely modified.\n *\n * With NULL @old this simply adds @new to @active (while swapping the sets).\n * With NULL @new this simply removes @old from @active and frees it\n * (while also swapping the sets).\n */\nstatic void kvm_activate_memslot(struct kvm *kvm,\n\t\t\t\t struct kvm_memory_slot *old,\n\t\t\t\t struct kvm_memory_slot *new)\n{\n\tint as_id = kvm_memslots_get_as_id(old, new);\n\n\tkvm_swap_active_memslots(kvm, as_id);\n\n\t/* Propagate the new memslot to the now inactive memslots. */\n\tkvm_replace_memslot(kvm, old, new);\n}\n\nstatic void kvm_copy_memslot(struct kvm_memory_slot *dest,\n\t\t\t     const struct kvm_memory_slot *src)\n{\n\tdest->base_gfn = src->base_gfn;\n\tdest->npages = src->npages;\n\tdest->dirty_bitmap = src->dirty_bitmap;\n\tdest->arch = src->arch;\n\tdest->userspace_addr = src->userspace_addr;\n\tdest->flags = src->flags;\n\tdest->id = src->id;\n\tdest->as_id = src->as_id;\n}\n\nstatic void kvm_invalidate_memslot(struct kvm *kvm,\n\t\t\t\t   struct kvm_memory_slot *old,\n\t\t\t\t   struct kvm_memory_slot *invalid_slot)\n{\n\t/*\n\t * Mark the current slot INVALID.  As with all memslot modifications,\n\t * this must be done on an unreachable slot to avoid modifying the\n\t * current slot in the active tree.\n\t */\n\tkvm_copy_memslot(invalid_slot, old);\n\tinvalid_slot->flags |= KVM_MEMSLOT_INVALID;\n\tkvm_replace_memslot(kvm, old, invalid_slot);\n\n\t/*\n\t * Activate the slot that is now marked INVALID, but don't propagate\n\t * the slot to the now inactive slots. The slot is either going to be\n\t * deleted or recreated as a new slot.\n\t */\n\tkvm_swap_active_memslots(kvm, old->as_id);\n\n\t/*\n\t * From this point no new shadow pages pointing to a deleted, or moved,\n\t * memslot will be created.  Validation of sp->gfn happens in:\n\t *\t- gfn_to_hva (kvm_read_guest, gfn_to_pfn)\n\t *\t- kvm_is_visible_gfn (mmu_check_root)\n\t */\n\tkvm_arch_flush_shadow_memslot(kvm, old);\n\n\t/* Was released by kvm_swap_active_memslots, reacquire. */\n\tmutex_lock(&kvm->slots_arch_lock);\n\n\t/*\n\t * Copy the arch-specific field of the newly-installed slot back to the\n\t * old slot as the arch data could have changed between releasing\n\t * slots_arch_lock in install_new_memslots() and re-acquiring the lock\n\t * above.  Writers are required to retrieve memslots *after* acquiring\n\t * slots_arch_lock, thus the active slot's data is guaranteed to be fresh.\n\t */\n\told->arch = invalid_slot->arch;\n}\n\nstatic void kvm_create_memslot(struct kvm *kvm,\n\t\t\t       struct kvm_memory_slot *new)\n{\n\t/* Add the new memslot to the inactive set and activate. */\n\tkvm_replace_memslot(kvm, NULL, new);\n\tkvm_activate_memslot(kvm, NULL, new);\n}\n\nstatic void kvm_delete_memslot(struct kvm *kvm,\n\t\t\t       struct kvm_memory_slot *old,\n\t\t\t       struct kvm_memory_slot *invalid_slot)\n{\n\t/*\n\t * Remove the old memslot (in the inactive memslots) by passing NULL as\n\t * the \"new\" slot, and for the invalid version in the active slots.\n\t */\n\tkvm_replace_memslot(kvm, old, NULL);\n\tkvm_activate_memslot(kvm, invalid_slot, NULL);\n}\n\nstatic void kvm_move_memslot(struct kvm *kvm,\n\t\t\t     struct kvm_memory_slot *old,\n\t\t\t     struct kvm_memory_slot *new,\n\t\t\t     struct kvm_memory_slot *invalid_slot)\n{\n\t/*\n\t * Replace the old memslot in the inactive slots, and then swap slots\n\t * and replace the current INVALID with the new as well.\n\t */\n\tkvm_replace_memslot(kvm, old, new);\n\tkvm_activate_memslot(kvm, invalid_slot, new);\n}\n\nstatic void kvm_update_flags_memslot(struct kvm *kvm,\n\t\t\t\t     struct kvm_memory_slot *old,\n\t\t\t\t     struct kvm_memory_slot *new)\n{\n\t/*\n\t * Similar to the MOVE case, but the slot doesn't need to be zapped as\n\t * an intermediate step. Instead, the old memslot is simply replaced\n\t * with a new, updated copy in both memslot sets.\n\t */\n\tkvm_replace_memslot(kvm, old, new);\n\tkvm_activate_memslot(kvm, old, new);\n}\n\nstatic int kvm_set_memslot(struct kvm *kvm,\n\t\t\t   struct kvm_memory_slot *old,\n\t\t\t   struct kvm_memory_slot *new,\n\t\t\t   enum kvm_mr_change change)\n{\n\tstruct kvm_memory_slot *invalid_slot;\n\tint r;\n\n\t/*\n\t * Released in kvm_swap_active_memslots.\n\t *\n\t * Must be held from before the current memslots are copied until\n\t * after the new memslots are installed with rcu_assign_pointer,\n\t * then released before the synchronize srcu in kvm_swap_active_memslots.\n\t *\n\t * When modifying memslots outside of the slots_lock, must be held\n\t * before reading the pointer to the current memslots until after all\n\t * changes to those memslots are complete.\n\t *\n\t * These rules ensure that installing new memslots does not lose\n\t * changes made to the previous memslots.\n\t */\n\tmutex_lock(&kvm->slots_arch_lock);\n\n\t/*\n\t * Invalidate the old slot if it's being deleted or moved.  This is\n\t * done prior to actually deleting/moving the memslot to allow vCPUs to\n\t * continue running by ensuring there are no mappings or shadow pages\n\t * for the memslot when it is deleted/moved.  Without pre-invalidation\n\t * (and without a lock), a window would exist between effecting the\n\t * delete/move and committing the changes in arch code where KVM or a\n\t * guest could access a non-existent memslot.\n\t *\n\t * Modifications are done on a temporary, unreachable slot.  The old\n\t * slot needs to be preserved in case a later step fails and the\n\t * invalidation needs to be reverted.\n\t */\n\tif (change == KVM_MR_DELETE || change == KVM_MR_MOVE) {\n\t\tinvalid_slot = kzalloc(sizeof(*invalid_slot), GFP_KERNEL_ACCOUNT);\n\t\tif (!invalid_slot) {\n\t\t\tmutex_unlock(&kvm->slots_arch_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tkvm_invalidate_memslot(kvm, old, invalid_slot);\n\t}\n\n\tr = kvm_prepare_memory_region(kvm, old, new, change);\n\tif (r) {\n\t\t/*\n\t\t * For DELETE/MOVE, revert the above INVALID change.  No\n\t\t * modifications required since the original slot was preserved\n\t\t * in the inactive slots.  Changing the active memslots also\n\t\t * release slots_arch_lock.\n\t\t */\n\t\tif (change == KVM_MR_DELETE || change == KVM_MR_MOVE) {\n\t\t\tkvm_activate_memslot(kvm, invalid_slot, old);\n\t\t\tkfree(invalid_slot);\n\t\t} else {\n\t\t\tmutex_unlock(&kvm->slots_arch_lock);\n\t\t}\n\t\treturn r;\n\t}\n\n\t/*\n\t * For DELETE and MOVE, the working slot is now active as the INVALID\n\t * version of the old slot.  MOVE is particularly special as it reuses\n\t * the old slot and returns a copy of the old slot (in working_slot).\n\t * For CREATE, there is no old slot.  For DELETE and FLAGS_ONLY, the\n\t * old slot is detached but otherwise preserved.\n\t */\n\tif (change == KVM_MR_CREATE)\n\t\tkvm_create_memslot(kvm, new);\n\telse if (change == KVM_MR_DELETE)\n\t\tkvm_delete_memslot(kvm, old, invalid_slot);\n\telse if (change == KVM_MR_MOVE)\n\t\tkvm_move_memslot(kvm, old, new, invalid_slot);\n\telse if (change == KVM_MR_FLAGS_ONLY)\n\t\tkvm_update_flags_memslot(kvm, old, new);\n\telse\n\t\tBUG();\n\n\t/* Free the temporary INVALID slot used for DELETE and MOVE. */\n\tif (change == KVM_MR_DELETE || change == KVM_MR_MOVE)\n\t\tkfree(invalid_slot);\n\n\t/*\n\t * No need to refresh new->arch, changes after dropping slots_arch_lock\n\t * will directly hit the final, active memsot.  Architectures are\n\t * responsible for knowing that new->arch may be stale.\n\t */\n\tkvm_commit_memory_region(kvm, old, new, change);\n\n\treturn 0;\n}\n\nstatic bool kvm_check_memslot_overlap(struct kvm_memslots *slots, int id,\n\t\t\t\t      gfn_t start, gfn_t end)\n{\n\tstruct kvm_memslot_iter iter;\n\n\tkvm_for_each_memslot_in_gfn_range(&iter, slots, start, end) {\n\t\tif (iter.slot->id != id)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/*\n * Allocate some memory and give it an address in the guest physical address\n * space.\n *\n * Discontiguous memory is allowed, mostly for framebuffers.\n *\n * Must be called holding kvm->slots_lock for write.\n */\nint __kvm_set_memory_region(struct kvm *kvm,\n\t\t\t    const struct kvm_userspace_memory_region *mem)\n{\n\tstruct kvm_memory_slot *old, *new;\n\tstruct kvm_memslots *slots;\n\tenum kvm_mr_change change;\n\tunsigned long npages;\n\tgfn_t base_gfn;\n\tint as_id, id;\n\tint r;\n\n\tr = check_memory_region_flags(mem);\n\tif (r)\n\t\treturn r;\n\n\tas_id = mem->slot >> 16;\n\tid = (u16)mem->slot;\n\n\t/* General sanity checks */\n\tif ((mem->memory_size & (PAGE_SIZE - 1)) ||\n\t    (mem->memory_size != (unsigned long)mem->memory_size))\n\t\treturn -EINVAL;\n\tif (mem->guest_phys_addr & (PAGE_SIZE - 1))\n\t\treturn -EINVAL;\n\t/* We can read the guest memory with __xxx_user() later on. */\n\tif ((mem->userspace_addr & (PAGE_SIZE - 1)) ||\n\t    (mem->userspace_addr != untagged_addr(mem->userspace_addr)) ||\n\t     !access_ok((void __user *)(unsigned long)mem->userspace_addr,\n\t\t\tmem->memory_size))\n\t\treturn -EINVAL;\n\tif (as_id >= KVM_ADDRESS_SPACE_NUM || id >= KVM_MEM_SLOTS_NUM)\n\t\treturn -EINVAL;\n\tif (mem->guest_phys_addr + mem->memory_size < mem->guest_phys_addr)\n\t\treturn -EINVAL;\n\tif ((mem->memory_size >> PAGE_SHIFT) > KVM_MEM_MAX_NR_PAGES)\n\t\treturn -EINVAL;\n\n\tslots = __kvm_memslots(kvm, as_id);\n\n\t/*\n\t * Note, the old memslot (and the pointer itself!) may be invalidated\n\t * and/or destroyed by kvm_set_memslot().\n\t */\n\told = id_to_memslot(slots, id);\n\n\tif (!mem->memory_size) {\n\t\tif (!old || !old->npages)\n\t\t\treturn -EINVAL;\n\n\t\tif (WARN_ON_ONCE(kvm->nr_memslot_pages < old->npages))\n\t\t\treturn -EIO;\n\n\t\treturn kvm_set_memslot(kvm, old, NULL, KVM_MR_DELETE);\n\t}\n\n\tbase_gfn = (mem->guest_phys_addr >> PAGE_SHIFT);\n\tnpages = (mem->memory_size >> PAGE_SHIFT);\n\n\tif (!old || !old->npages) {\n\t\tchange = KVM_MR_CREATE;\n\n\t\t/*\n\t\t * To simplify KVM internals, the total number of pages across\n\t\t * all memslots must fit in an unsigned long.\n\t\t */\n\t\tif ((kvm->nr_memslot_pages + npages) < kvm->nr_memslot_pages)\n\t\t\treturn -EINVAL;\n\t} else { /* Modify an existing slot. */\n\t\tif ((mem->userspace_addr != old->userspace_addr) ||\n\t\t    (npages != old->npages) ||\n\t\t    ((mem->flags ^ old->flags) & KVM_MEM_READONLY))\n\t\t\treturn -EINVAL;\n\n\t\tif (base_gfn != old->base_gfn)\n\t\t\tchange = KVM_MR_MOVE;\n\t\telse if (mem->flags != old->flags)\n\t\t\tchange = KVM_MR_FLAGS_ONLY;\n\t\telse /* Nothing to change. */\n\t\t\treturn 0;\n\t}\n\n\tif ((change == KVM_MR_CREATE || change == KVM_MR_MOVE) &&\n\t    kvm_check_memslot_overlap(slots, id, base_gfn, base_gfn + npages))\n\t\treturn -EEXIST;\n\n\t/* Allocate a slot that will persist in the memslot. */\n\tnew = kzalloc(sizeof(*new), GFP_KERNEL_ACCOUNT);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tnew->as_id = as_id;\n\tnew->id = id;\n\tnew->base_gfn = base_gfn;\n\tnew->npages = npages;\n\tnew->flags = mem->flags;\n\tnew->userspace_addr = mem->userspace_addr;\n\n\tr = kvm_set_memslot(kvm, old, new, change);\n\tif (r)\n\t\tkfree(new);\n\treturn r;\n}\nEXPORT_SYMBOL_GPL(__kvm_set_memory_region);\n\nint kvm_set_memory_region(struct kvm *kvm,\n\t\t\t  const struct kvm_userspace_memory_region *mem)\n{\n\tint r;\n\n\tmutex_lock(&kvm->slots_lock);\n\tr = __kvm_set_memory_region(kvm, mem);\n\tmutex_unlock(&kvm->slots_lock);\n\treturn r;\n}\nEXPORT_SYMBOL_GPL(kvm_set_memory_region);\n\nstatic int kvm_vm_ioctl_set_memory_region(struct kvm *kvm,\n\t\t\t\t\t  struct kvm_userspace_memory_region *mem)\n{\n\tif ((u16)mem->slot >= KVM_USER_MEM_SLOTS)\n\t\treturn -EINVAL;\n\n\treturn kvm_set_memory_region(kvm, mem);\n}\n\n#ifndef CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT\n/**\n * kvm_get_dirty_log - get a snapshot of dirty pages\n * @kvm:\tpointer to kvm instance\n * @log:\tslot id and address to which we copy the log\n * @is_dirty:\tset to '1' if any dirty pages were found\n * @memslot:\tset to the associated memslot, always valid on success\n */\nint kvm_get_dirty_log(struct kvm *kvm, struct kvm_dirty_log *log,\n\t\t      int *is_dirty, struct kvm_memory_slot **memslot)\n{\n\tstruct kvm_memslots *slots;\n\tint i, as_id, id;\n\tunsigned long n;\n\tunsigned long any = 0;\n\n\t/* Dirty ring tracking is exclusive to dirty log tracking */\n\tif (kvm->dirty_ring_size)\n\t\treturn -ENXIO;\n\n\t*memslot = NULL;\n\t*is_dirty = 0;\n\n\tas_id = log->slot >> 16;\n\tid = (u16)log->slot;\n\tif (as_id >= KVM_ADDRESS_SPACE_NUM || id >= KVM_USER_MEM_SLOTS)\n\t\treturn -EINVAL;\n\n\tslots = __kvm_memslots(kvm, as_id);\n\t*memslot = id_to_memslot(slots, id);\n\tif (!(*memslot) || !(*memslot)->dirty_bitmap)\n\t\treturn -ENOENT;\n\n\tkvm_arch_sync_dirty_log(kvm, *memslot);\n\n\tn = kvm_dirty_bitmap_bytes(*memslot);\n\n\tfor (i = 0; !any && i < n/sizeof(long); ++i)\n\t\tany = (*memslot)->dirty_bitmap[i];\n\n\tif (copy_to_user(log->dirty_bitmap, (*memslot)->dirty_bitmap, n))\n\t\treturn -EFAULT;\n\n\tif (any)\n\t\t*is_dirty = 1;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_get_dirty_log);\n\n#else /* CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT */\n/**\n * kvm_get_dirty_log_protect - get a snapshot of dirty pages\n *\tand reenable dirty page tracking for the corresponding pages.\n * @kvm:\tpointer to kvm instance\n * @log:\tslot id and address to which we copy the log\n *\n * We need to keep it in mind that VCPU threads can write to the bitmap\n * concurrently. So, to avoid losing track of dirty pages we keep the\n * following order:\n *\n *    1. Take a snapshot of the bit and clear it if needed.\n *    2. Write protect the corresponding page.\n *    3. Copy the snapshot to the userspace.\n *    4. Upon return caller flushes TLB's if needed.\n *\n * Between 2 and 4, the guest may write to the page using the remaining TLB\n * entry.  This is not a problem because the page is reported dirty using\n * the snapshot taken before and step 4 ensures that writes done after\n * exiting to userspace will be logged for the next call.\n *\n */\nstatic int kvm_get_dirty_log_protect(struct kvm *kvm, struct kvm_dirty_log *log)\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\tint i, as_id, id;\n\tunsigned long n;\n\tunsigned long *dirty_bitmap;\n\tunsigned long *dirty_bitmap_buffer;\n\tbool flush;\n\n\t/* Dirty ring tracking is exclusive to dirty log tracking */\n\tif (kvm->dirty_ring_size)\n\t\treturn -ENXIO;\n\n\tas_id = log->slot >> 16;\n\tid = (u16)log->slot;\n\tif (as_id >= KVM_ADDRESS_SPACE_NUM || id >= KVM_USER_MEM_SLOTS)\n\t\treturn -EINVAL;\n\n\tslots = __kvm_memslots(kvm, as_id);\n\tmemslot = id_to_memslot(slots, id);\n\tif (!memslot || !memslot->dirty_bitmap)\n\t\treturn -ENOENT;\n\n\tdirty_bitmap = memslot->dirty_bitmap;\n\n\tkvm_arch_sync_dirty_log(kvm, memslot);\n\n\tn = kvm_dirty_bitmap_bytes(memslot);\n\tflush = false;\n\tif (kvm->manual_dirty_log_protect) {\n\t\t/*\n\t\t * Unlike kvm_get_dirty_log, we always return false in *flush,\n\t\t * because no flush is needed until KVM_CLEAR_DIRTY_LOG.  There\n\t\t * is some code duplication between this function and\n\t\t * kvm_get_dirty_log, but hopefully all architecture\n\t\t * transition to kvm_get_dirty_log_protect and kvm_get_dirty_log\n\t\t * can be eliminated.\n\t\t */\n\t\tdirty_bitmap_buffer = dirty_bitmap;\n\t} else {\n\t\tdirty_bitmap_buffer = kvm_second_dirty_bitmap(memslot);\n\t\tmemset(dirty_bitmap_buffer, 0, n);\n\n\t\tKVM_MMU_LOCK(kvm);\n\t\tfor (i = 0; i < n / sizeof(long); i++) {\n\t\t\tunsigned long mask;\n\t\t\tgfn_t offset;\n\n\t\t\tif (!dirty_bitmap[i])\n\t\t\t\tcontinue;\n\n\t\t\tflush = true;\n\t\t\tmask = xchg(&dirty_bitmap[i], 0);\n\t\t\tdirty_bitmap_buffer[i] = mask;\n\n\t\t\toffset = i * BITS_PER_LONG;\n\t\t\tkvm_arch_mmu_enable_log_dirty_pt_masked(kvm, memslot,\n\t\t\t\t\t\t\t\toffset, mask);\n\t\t}\n\t\tKVM_MMU_UNLOCK(kvm);\n\t}\n\n\tif (flush)\n\t\tkvm_arch_flush_remote_tlbs_memslot(kvm, memslot);\n\n\tif (copy_to_user(log->dirty_bitmap, dirty_bitmap_buffer, n))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n\n/**\n * kvm_vm_ioctl_get_dirty_log - get and clear the log of dirty pages in a slot\n * @kvm: kvm instance\n * @log: slot id and address to which we copy the log\n *\n * Steps 1-4 below provide general overview of dirty page logging. See\n * kvm_get_dirty_log_protect() function description for additional details.\n *\n * We call kvm_get_dirty_log_protect() to handle steps 1-3, upon return we\n * always flush the TLB (step 4) even if previous step failed  and the dirty\n * bitmap may be corrupt. Regardless of previous outcome the KVM logging API\n * does not preclude user space subsequent dirty log read. Flushing TLB ensures\n * writes will be marked dirty for next log read.\n *\n *   1. Take a snapshot of the bit and clear it if needed.\n *   2. Write protect the corresponding page.\n *   3. Copy the snapshot to the userspace.\n *   4. Flush TLB's if needed.\n */\nstatic int kvm_vm_ioctl_get_dirty_log(struct kvm *kvm,\n\t\t\t\t      struct kvm_dirty_log *log)\n{\n\tint r;\n\n\tmutex_lock(&kvm->slots_lock);\n\n\tr = kvm_get_dirty_log_protect(kvm, log);\n\n\tmutex_unlock(&kvm->slots_lock);\n\treturn r;\n}\n\n/**\n * kvm_clear_dirty_log_protect - clear dirty bits in the bitmap\n *\tand reenable dirty page tracking for the corresponding pages.\n * @kvm:\tpointer to kvm instance\n * @log:\tslot id and address from which to fetch the bitmap of dirty pages\n */\nstatic int kvm_clear_dirty_log_protect(struct kvm *kvm,\n\t\t\t\t       struct kvm_clear_dirty_log *log)\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\tint as_id, id;\n\tgfn_t offset;\n\tunsigned long i, n;\n\tunsigned long *dirty_bitmap;\n\tunsigned long *dirty_bitmap_buffer;\n\tbool flush;\n\n\t/* Dirty ring tracking is exclusive to dirty log tracking */\n\tif (kvm->dirty_ring_size)\n\t\treturn -ENXIO;\n\n\tas_id = log->slot >> 16;\n\tid = (u16)log->slot;\n\tif (as_id >= KVM_ADDRESS_SPACE_NUM || id >= KVM_USER_MEM_SLOTS)\n\t\treturn -EINVAL;\n\n\tif (log->first_page & 63)\n\t\treturn -EINVAL;\n\n\tslots = __kvm_memslots(kvm, as_id);\n\tmemslot = id_to_memslot(slots, id);\n\tif (!memslot || !memslot->dirty_bitmap)\n\t\treturn -ENOENT;\n\n\tdirty_bitmap = memslot->dirty_bitmap;\n\n\tn = ALIGN(log->num_pages, BITS_PER_LONG) / 8;\n\n\tif (log->first_page > memslot->npages ||\n\t    log->num_pages > memslot->npages - log->first_page ||\n\t    (log->num_pages < memslot->npages - log->first_page && (log->num_pages & 63)))\n\t    return -EINVAL;\n\n\tkvm_arch_sync_dirty_log(kvm, memslot);\n\n\tflush = false;\n\tdirty_bitmap_buffer = kvm_second_dirty_bitmap(memslot);\n\tif (copy_from_user(dirty_bitmap_buffer, log->dirty_bitmap, n))\n\t\treturn -EFAULT;\n\n\tKVM_MMU_LOCK(kvm);\n\tfor (offset = log->first_page, i = offset / BITS_PER_LONG,\n\t\t n = DIV_ROUND_UP(log->num_pages, BITS_PER_LONG); n--;\n\t     i++, offset += BITS_PER_LONG) {\n\t\tunsigned long mask = *dirty_bitmap_buffer++;\n\t\tatomic_long_t *p = (atomic_long_t *) &dirty_bitmap[i];\n\t\tif (!mask)\n\t\t\tcontinue;\n\n\t\tmask &= atomic_long_fetch_andnot(mask, p);\n\n\t\t/*\n\t\t * mask contains the bits that really have been cleared.  This\n\t\t * never includes any bits beyond the length of the memslot (if\n\t\t * the length is not aligned to 64 pages), therefore it is not\n\t\t * a problem if userspace sets them in log->dirty_bitmap.\n\t\t*/\n\t\tif (mask) {\n\t\t\tflush = true;\n\t\t\tkvm_arch_mmu_enable_log_dirty_pt_masked(kvm, memslot,\n\t\t\t\t\t\t\t\toffset, mask);\n\t\t}\n\t}\n\tKVM_MMU_UNLOCK(kvm);\n\n\tif (flush)\n\t\tkvm_arch_flush_remote_tlbs_memslot(kvm, memslot);\n\n\treturn 0;\n}\n\nstatic int kvm_vm_ioctl_clear_dirty_log(struct kvm *kvm,\n\t\t\t\t\tstruct kvm_clear_dirty_log *log)\n{\n\tint r;\n\n\tmutex_lock(&kvm->slots_lock);\n\n\tr = kvm_clear_dirty_log_protect(kvm, log);\n\n\tmutex_unlock(&kvm->slots_lock);\n\treturn r;\n}\n#endif /* CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT */\n\nstruct kvm_memory_slot *gfn_to_memslot(struct kvm *kvm, gfn_t gfn)\n{\n\treturn __gfn_to_memslot(kvm_memslots(kvm), gfn);\n}\nEXPORT_SYMBOL_GPL(gfn_to_memslot);\n\nstruct kvm_memory_slot *kvm_vcpu_gfn_to_memslot(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\tstruct kvm_memslots *slots = kvm_vcpu_memslots(vcpu);\n\tu64 gen = slots->generation;\n\tstruct kvm_memory_slot *slot;\n\n\t/*\n\t * This also protects against using a memslot from a different address space,\n\t * since different address spaces have different generation numbers.\n\t */\n\tif (unlikely(gen != vcpu->last_used_slot_gen)) {\n\t\tvcpu->last_used_slot = NULL;\n\t\tvcpu->last_used_slot_gen = gen;\n\t}\n\n\tslot = try_get_memslot(vcpu->last_used_slot, gfn);\n\tif (slot)\n\t\treturn slot;\n\n\t/*\n\t * Fall back to searching all memslots. We purposely use\n\t * search_memslots() instead of __gfn_to_memslot() to avoid\n\t * thrashing the VM-wide last_used_slot in kvm_memslots.\n\t */\n\tslot = search_memslots(slots, gfn, false);\n\tif (slot) {\n\t\tvcpu->last_used_slot = slot;\n\t\treturn slot;\n\t}\n\n\treturn NULL;\n}\n\nbool kvm_is_visible_gfn(struct kvm *kvm, gfn_t gfn)\n{\n\tstruct kvm_memory_slot *memslot = gfn_to_memslot(kvm, gfn);\n\n\treturn kvm_is_visible_memslot(memslot);\n}\nEXPORT_SYMBOL_GPL(kvm_is_visible_gfn);\n\nbool kvm_vcpu_is_visible_gfn(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\tstruct kvm_memory_slot *memslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\n\treturn kvm_is_visible_memslot(memslot);\n}\nEXPORT_SYMBOL_GPL(kvm_vcpu_is_visible_gfn);\n\nunsigned long kvm_host_page_size(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\tstruct vm_area_struct *vma;\n\tunsigned long addr, size;\n\n\tsize = PAGE_SIZE;\n\n\taddr = kvm_vcpu_gfn_to_hva_prot(vcpu, gfn, NULL);\n\tif (kvm_is_error_hva(addr))\n\t\treturn PAGE_SIZE;\n\n\tmmap_read_lock(current->mm);\n\tvma = find_vma(current->mm, addr);\n\tif (!vma)\n\t\tgoto out;\n\n\tsize = vma_kernel_pagesize(vma);\n\nout:\n\tmmap_read_unlock(current->mm);\n\n\treturn size;\n}\n\nstatic bool memslot_is_readonly(const struct kvm_memory_slot *slot)\n{\n\treturn slot->flags & KVM_MEM_READONLY;\n}\n\nstatic unsigned long __gfn_to_hva_many(const struct kvm_memory_slot *slot, gfn_t gfn,\n\t\t\t\t       gfn_t *nr_pages, bool write)\n{\n\tif (!slot || slot->flags & KVM_MEMSLOT_INVALID)\n\t\treturn KVM_HVA_ERR_BAD;\n\n\tif (memslot_is_readonly(slot) && write)\n\t\treturn KVM_HVA_ERR_RO_BAD;\n\n\tif (nr_pages)\n\t\t*nr_pages = slot->npages - (gfn - slot->base_gfn);\n\n\treturn __gfn_to_hva_memslot(slot, gfn);\n}\n\nstatic unsigned long gfn_to_hva_many(struct kvm_memory_slot *slot, gfn_t gfn,\n\t\t\t\t     gfn_t *nr_pages)\n{\n\treturn __gfn_to_hva_many(slot, gfn, nr_pages, true);\n}\n\nunsigned long gfn_to_hva_memslot(struct kvm_memory_slot *slot,\n\t\t\t\t\tgfn_t gfn)\n{\n\treturn gfn_to_hva_many(slot, gfn, NULL);\n}\nEXPORT_SYMBOL_GPL(gfn_to_hva_memslot);\n\nunsigned long gfn_to_hva(struct kvm *kvm, gfn_t gfn)\n{\n\treturn gfn_to_hva_many(gfn_to_memslot(kvm, gfn), gfn, NULL);\n}\nEXPORT_SYMBOL_GPL(gfn_to_hva);\n\nunsigned long kvm_vcpu_gfn_to_hva(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\treturn gfn_to_hva_many(kvm_vcpu_gfn_to_memslot(vcpu, gfn), gfn, NULL);\n}\nEXPORT_SYMBOL_GPL(kvm_vcpu_gfn_to_hva);\n\n/*\n * Return the hva of a @gfn and the R/W attribute if possible.\n *\n * @slot: the kvm_memory_slot which contains @gfn\n * @gfn: the gfn to be translated\n * @writable: used to return the read/write attribute of the @slot if the hva\n * is valid and @writable is not NULL\n */\nunsigned long gfn_to_hva_memslot_prot(struct kvm_memory_slot *slot,\n\t\t\t\t      gfn_t gfn, bool *writable)\n{\n\tunsigned long hva = __gfn_to_hva_many(slot, gfn, NULL, false);\n\n\tif (!kvm_is_error_hva(hva) && writable)\n\t\t*writable = !memslot_is_readonly(slot);\n\n\treturn hva;\n}\n\nunsigned long gfn_to_hva_prot(struct kvm *kvm, gfn_t gfn, bool *writable)\n{\n\tstruct kvm_memory_slot *slot = gfn_to_memslot(kvm, gfn);\n\n\treturn gfn_to_hva_memslot_prot(slot, gfn, writable);\n}\n\nunsigned long kvm_vcpu_gfn_to_hva_prot(struct kvm_vcpu *vcpu, gfn_t gfn, bool *writable)\n{\n\tstruct kvm_memory_slot *slot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\n\treturn gfn_to_hva_memslot_prot(slot, gfn, writable);\n}\n\nstatic inline int check_user_page_hwpoison(unsigned long addr)\n{\n\tint rc, flags = FOLL_HWPOISON | FOLL_WRITE;\n\n\trc = get_user_pages(addr, 1, flags, NULL, NULL);\n\treturn rc == -EHWPOISON;\n}\n\n/*\n * The fast path to get the writable pfn which will be stored in @pfn,\n * true indicates success, otherwise false is returned.  It's also the\n * only part that runs if we can in atomic context.\n */\nstatic bool hva_to_pfn_fast(unsigned long addr, bool write_fault,\n\t\t\t    bool *writable, kvm_pfn_t *pfn)\n{\n\tstruct page *page[1];\n\n\t/*\n\t * Fast pin a writable pfn only if it is a write fault request\n\t * or the caller allows to map a writable pfn for a read fault\n\t * request.\n\t */\n\tif (!(write_fault || writable))\n\t\treturn false;\n\n\tif (get_user_page_fast_only(addr, FOLL_WRITE, page)) {\n\t\t*pfn = page_to_pfn(page[0]);\n\n\t\tif (writable)\n\t\t\t*writable = true;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/*\n * The slow path to get the pfn of the specified host virtual address,\n * 1 indicates success, -errno is returned if error is detected.\n */\nstatic int hva_to_pfn_slow(unsigned long addr, bool *async, bool write_fault,\n\t\t\t   bool *writable, kvm_pfn_t *pfn)\n{\n\tunsigned int flags = FOLL_HWPOISON;\n\tstruct page *page;\n\tint npages = 0;\n\n\tmight_sleep();\n\n\tif (writable)\n\t\t*writable = write_fault;\n\n\tif (write_fault)\n\t\tflags |= FOLL_WRITE;\n\tif (async)\n\t\tflags |= FOLL_NOWAIT;\n\n\tnpages = get_user_pages_unlocked(addr, 1, &page, flags);\n\tif (npages != 1)\n\t\treturn npages;\n\n\t/* map read fault as writable if possible */\n\tif (unlikely(!write_fault) && writable) {\n\t\tstruct page *wpage;\n\n\t\tif (get_user_page_fast_only(addr, FOLL_WRITE, &wpage)) {\n\t\t\t*writable = true;\n\t\t\tput_page(page);\n\t\t\tpage = wpage;\n\t\t}\n\t}\n\t*pfn = page_to_pfn(page);\n\treturn npages;\n}\n\nstatic bool vma_is_valid(struct vm_area_struct *vma, bool write_fault)\n{\n\tif (unlikely(!(vma->vm_flags & VM_READ)))\n\t\treturn false;\n\n\tif (write_fault && (unlikely(!(vma->vm_flags & VM_WRITE))))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int kvm_try_get_pfn(kvm_pfn_t pfn)\n{\n\tif (kvm_is_reserved_pfn(pfn))\n\t\treturn 1;\n\treturn get_page_unless_zero(pfn_to_page(pfn));\n}\n\nstatic int hva_to_pfn_remapped(struct vm_area_struct *vma,\n\t\t\t       unsigned long addr, bool write_fault,\n\t\t\t       bool *writable, kvm_pfn_t *p_pfn)\n{\n\tkvm_pfn_t pfn;\n\tpte_t *ptep;\n\tspinlock_t *ptl;\n\tint r;\n\n\tr = follow_pte(vma->vm_mm, addr, &ptep, &ptl);\n\tif (r) {\n\t\t/*\n\t\t * get_user_pages fails for VM_IO and VM_PFNMAP vmas and does\n\t\t * not call the fault handler, so do it here.\n\t\t */\n\t\tbool unlocked = false;\n\t\tr = fixup_user_fault(current->mm, addr,\n\t\t\t\t     (write_fault ? FAULT_FLAG_WRITE : 0),\n\t\t\t\t     &unlocked);\n\t\tif (unlocked)\n\t\t\treturn -EAGAIN;\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tr = follow_pte(vma->vm_mm, addr, &ptep, &ptl);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tif (write_fault && !pte_write(*ptep)) {\n\t\tpfn = KVM_PFN_ERR_RO_FAULT;\n\t\tgoto out;\n\t}\n\n\tif (writable)\n\t\t*writable = pte_write(*ptep);\n\tpfn = pte_pfn(*ptep);\n\n\t/*\n\t * Get a reference here because callers of *hva_to_pfn* and\n\t * *gfn_to_pfn* ultimately call kvm_release_pfn_clean on the\n\t * returned pfn.  This is only needed if the VMA has VM_MIXEDMAP\n\t * set, but the kvm_try_get_pfn/kvm_release_pfn_clean pair will\n\t * simply do nothing for reserved pfns.\n\t *\n\t * Whoever called remap_pfn_range is also going to call e.g.\n\t * unmap_mapping_range before the underlying pages are freed,\n\t * causing a call to our MMU notifier.\n\t *\n\t * Certain IO or PFNMAP mappings can be backed with valid\n\t * struct pages, but be allocated without refcounting e.g.,\n\t * tail pages of non-compound higher order allocations, which\n\t * would then underflow the refcount when the caller does the\n\t * required put_page. Don't allow those pages here.\n\t */ \n\tif (!kvm_try_get_pfn(pfn))\n\t\tr = -EFAULT;\n\nout:\n\tpte_unmap_unlock(ptep, ptl);\n\t*p_pfn = pfn;\n\n\treturn r;\n}\n\n/*\n * Pin guest page in memory and return its pfn.\n * @addr: host virtual address which maps memory to the guest\n * @atomic: whether this function can sleep\n * @async: whether this function need to wait IO complete if the\n *         host page is not in the memory\n * @write_fault: whether we should get a writable host page\n * @writable: whether it allows to map a writable host page for !@write_fault\n *\n * The function will map a writable host page for these two cases:\n * 1): @write_fault = true\n * 2): @write_fault = false && @writable, @writable will tell the caller\n *     whether the mapping is writable.\n */\nkvm_pfn_t hva_to_pfn(unsigned long addr, bool atomic, bool *async,\n\t\t     bool write_fault, bool *writable)\n{\n\tstruct vm_area_struct *vma;\n\tkvm_pfn_t pfn = 0;\n\tint npages, r;\n\n\t/* we can do it either atomically or asynchronously, not both */\n\tBUG_ON(atomic && async);\n\n\tif (hva_to_pfn_fast(addr, write_fault, writable, &pfn))\n\t\treturn pfn;\n\n\tif (atomic)\n\t\treturn KVM_PFN_ERR_FAULT;\n\n\tnpages = hva_to_pfn_slow(addr, async, write_fault, writable, &pfn);\n\tif (npages == 1)\n\t\treturn pfn;\n\n\tmmap_read_lock(current->mm);\n\tif (npages == -EHWPOISON ||\n\t      (!async && check_user_page_hwpoison(addr))) {\n\t\tpfn = KVM_PFN_ERR_HWPOISON;\n\t\tgoto exit;\n\t}\n\nretry:\n\tvma = vma_lookup(current->mm, addr);\n\n\tif (vma == NULL)\n\t\tpfn = KVM_PFN_ERR_FAULT;\n\telse if (vma->vm_flags & (VM_IO | VM_PFNMAP)) {\n\t\tr = hva_to_pfn_remapped(vma, addr, write_fault, writable, &pfn);\n\t\tif (r == -EAGAIN)\n\t\t\tgoto retry;\n\t\tif (r < 0)\n\t\t\tpfn = KVM_PFN_ERR_FAULT;\n\t} else {\n\t\tif (async && vma_is_valid(vma, write_fault))\n\t\t\t*async = true;\n\t\tpfn = KVM_PFN_ERR_FAULT;\n\t}\nexit:\n\tmmap_read_unlock(current->mm);\n\treturn pfn;\n}\n\nkvm_pfn_t __gfn_to_pfn_memslot(const struct kvm_memory_slot *slot, gfn_t gfn,\n\t\t\t       bool atomic, bool *async, bool write_fault,\n\t\t\t       bool *writable, hva_t *hva)\n{\n\tunsigned long addr = __gfn_to_hva_many(slot, gfn, NULL, write_fault);\n\n\tif (hva)\n\t\t*hva = addr;\n\n\tif (addr == KVM_HVA_ERR_RO_BAD) {\n\t\tif (writable)\n\t\t\t*writable = false;\n\t\treturn KVM_PFN_ERR_RO_FAULT;\n\t}\n\n\tif (kvm_is_error_hva(addr)) {\n\t\tif (writable)\n\t\t\t*writable = false;\n\t\treturn KVM_PFN_NOSLOT;\n\t}\n\n\t/* Do not map writable pfn in the readonly memslot. */\n\tif (writable && memslot_is_readonly(slot)) {\n\t\t*writable = false;\n\t\twritable = NULL;\n\t}\n\n\treturn hva_to_pfn(addr, atomic, async, write_fault,\n\t\t\t  writable);\n}\nEXPORT_SYMBOL_GPL(__gfn_to_pfn_memslot);\n\nkvm_pfn_t gfn_to_pfn_prot(struct kvm *kvm, gfn_t gfn, bool write_fault,\n\t\t      bool *writable)\n{\n\treturn __gfn_to_pfn_memslot(gfn_to_memslot(kvm, gfn), gfn, false, NULL,\n\t\t\t\t    write_fault, writable, NULL);\n}\nEXPORT_SYMBOL_GPL(gfn_to_pfn_prot);\n\nkvm_pfn_t gfn_to_pfn_memslot(const struct kvm_memory_slot *slot, gfn_t gfn)\n{\n\treturn __gfn_to_pfn_memslot(slot, gfn, false, NULL, true, NULL, NULL);\n}\nEXPORT_SYMBOL_GPL(gfn_to_pfn_memslot);\n\nkvm_pfn_t gfn_to_pfn_memslot_atomic(const struct kvm_memory_slot *slot, gfn_t gfn)\n{\n\treturn __gfn_to_pfn_memslot(slot, gfn, true, NULL, true, NULL, NULL);\n}\nEXPORT_SYMBOL_GPL(gfn_to_pfn_memslot_atomic);\n\nkvm_pfn_t kvm_vcpu_gfn_to_pfn_atomic(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\treturn gfn_to_pfn_memslot_atomic(kvm_vcpu_gfn_to_memslot(vcpu, gfn), gfn);\n}\nEXPORT_SYMBOL_GPL(kvm_vcpu_gfn_to_pfn_atomic);\n\nkvm_pfn_t gfn_to_pfn(struct kvm *kvm, gfn_t gfn)\n{\n\treturn gfn_to_pfn_memslot(gfn_to_memslot(kvm, gfn), gfn);\n}\nEXPORT_SYMBOL_GPL(gfn_to_pfn);\n\nkvm_pfn_t kvm_vcpu_gfn_to_pfn(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\treturn gfn_to_pfn_memslot(kvm_vcpu_gfn_to_memslot(vcpu, gfn), gfn);\n}\nEXPORT_SYMBOL_GPL(kvm_vcpu_gfn_to_pfn);\n\nint gfn_to_page_many_atomic(struct kvm_memory_slot *slot, gfn_t gfn,\n\t\t\t    struct page **pages, int nr_pages)\n{\n\tunsigned long addr;\n\tgfn_t entry = 0;\n\n\taddr = gfn_to_hva_many(slot, gfn, &entry);\n\tif (kvm_is_error_hva(addr))\n\t\treturn -1;\n\n\tif (entry < nr_pages)\n\t\treturn 0;\n\n\treturn get_user_pages_fast_only(addr, nr_pages, FOLL_WRITE, pages);\n}\nEXPORT_SYMBOL_GPL(gfn_to_page_many_atomic);\n\nstatic struct page *kvm_pfn_to_page(kvm_pfn_t pfn)\n{\n\tif (is_error_noslot_pfn(pfn))\n\t\treturn KVM_ERR_PTR_BAD_PAGE;\n\n\tif (kvm_is_reserved_pfn(pfn)) {\n\t\tWARN_ON(1);\n\t\treturn KVM_ERR_PTR_BAD_PAGE;\n\t}\n\n\treturn pfn_to_page(pfn);\n}\n\nstruct page *gfn_to_page(struct kvm *kvm, gfn_t gfn)\n{\n\tkvm_pfn_t pfn;\n\n\tpfn = gfn_to_pfn(kvm, gfn);\n\n\treturn kvm_pfn_to_page(pfn);\n}\nEXPORT_SYMBOL_GPL(gfn_to_page);\n\nvoid kvm_release_pfn(kvm_pfn_t pfn, bool dirty)\n{\n\tif (pfn == 0)\n\t\treturn;\n\n\tif (dirty)\n\t\tkvm_release_pfn_dirty(pfn);\n\telse\n\t\tkvm_release_pfn_clean(pfn);\n}\n\nint kvm_vcpu_map(struct kvm_vcpu *vcpu, gfn_t gfn, struct kvm_host_map *map)\n{\n\tkvm_pfn_t pfn;\n\tvoid *hva = NULL;\n\tstruct page *page = KVM_UNMAPPED_PAGE;\n\n\tif (!map)\n\t\treturn -EINVAL;\n\n\tpfn = gfn_to_pfn(vcpu->kvm, gfn);\n\tif (is_error_noslot_pfn(pfn))\n\t\treturn -EINVAL;\n\n\tif (pfn_valid(pfn)) {\n\t\tpage = pfn_to_page(pfn);\n\t\thva = kmap(page);\n#ifdef CONFIG_HAS_IOMEM\n\t} else {\n\t\thva = memremap(pfn_to_hpa(pfn), PAGE_SIZE, MEMREMAP_WB);\n#endif\n\t}\n\n\tif (!hva)\n\t\treturn -EFAULT;\n\n\tmap->page = page;\n\tmap->hva = hva;\n\tmap->pfn = pfn;\n\tmap->gfn = gfn;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_vcpu_map);\n\nvoid kvm_vcpu_unmap(struct kvm_vcpu *vcpu, struct kvm_host_map *map, bool dirty)\n{\n\tif (!map)\n\t\treturn;\n\n\tif (!map->hva)\n\t\treturn;\n\n\tif (map->page != KVM_UNMAPPED_PAGE)\n\t\tkunmap(map->page);\n#ifdef CONFIG_HAS_IOMEM\n\telse\n\t\tmemunmap(map->hva);\n#endif\n\n\tif (dirty)\n\t\tkvm_vcpu_mark_page_dirty(vcpu, map->gfn);\n\n\tkvm_release_pfn(map->pfn, dirty);\n\n\tmap->hva = NULL;\n\tmap->page = NULL;\n}\nEXPORT_SYMBOL_GPL(kvm_vcpu_unmap);\n\nstruct page *kvm_vcpu_gfn_to_page(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\tkvm_pfn_t pfn;\n\n\tpfn = kvm_vcpu_gfn_to_pfn(vcpu, gfn);\n\n\treturn kvm_pfn_to_page(pfn);\n}\nEXPORT_SYMBOL_GPL(kvm_vcpu_gfn_to_page);\n\nvoid kvm_release_page_clean(struct page *page)\n{\n\tWARN_ON(is_error_page(page));\n\n\tkvm_release_pfn_clean(page_to_pfn(page));\n}\nEXPORT_SYMBOL_GPL(kvm_release_page_clean);\n\nvoid kvm_release_pfn_clean(kvm_pfn_t pfn)\n{\n\tif (!is_error_noslot_pfn(pfn) && !kvm_is_reserved_pfn(pfn))\n\t\tput_page(pfn_to_page(pfn));\n}\nEXPORT_SYMBOL_GPL(kvm_release_pfn_clean);\n\nvoid kvm_release_page_dirty(struct page *page)\n{\n\tWARN_ON(is_error_page(page));\n\n\tkvm_release_pfn_dirty(page_to_pfn(page));\n}\nEXPORT_SYMBOL_GPL(kvm_release_page_dirty);\n\nvoid kvm_release_pfn_dirty(kvm_pfn_t pfn)\n{\n\tkvm_set_pfn_dirty(pfn);\n\tkvm_release_pfn_clean(pfn);\n}\nEXPORT_SYMBOL_GPL(kvm_release_pfn_dirty);\n\nvoid kvm_set_pfn_dirty(kvm_pfn_t pfn)\n{\n\tif (!kvm_is_reserved_pfn(pfn) && !kvm_is_zone_device_pfn(pfn))\n\t\tSetPageDirty(pfn_to_page(pfn));\n}\nEXPORT_SYMBOL_GPL(kvm_set_pfn_dirty);\n\nvoid kvm_set_pfn_accessed(kvm_pfn_t pfn)\n{\n\tif (!kvm_is_reserved_pfn(pfn) && !kvm_is_zone_device_pfn(pfn))\n\t\tmark_page_accessed(pfn_to_page(pfn));\n}\nEXPORT_SYMBOL_GPL(kvm_set_pfn_accessed);\n\nstatic int next_segment(unsigned long len, int offset)\n{\n\tif (len > PAGE_SIZE - offset)\n\t\treturn PAGE_SIZE - offset;\n\telse\n\t\treturn len;\n}\n\nstatic int __kvm_read_guest_page(struct kvm_memory_slot *slot, gfn_t gfn,\n\t\t\t\t void *data, int offset, int len)\n{\n\tint r;\n\tunsigned long addr;\n\n\taddr = gfn_to_hva_memslot_prot(slot, gfn, NULL);\n\tif (kvm_is_error_hva(addr))\n\t\treturn -EFAULT;\n\tr = __copy_from_user(data, (void __user *)addr + offset, len);\n\tif (r)\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nint kvm_read_guest_page(struct kvm *kvm, gfn_t gfn, void *data, int offset,\n\t\t\tint len)\n{\n\tstruct kvm_memory_slot *slot = gfn_to_memslot(kvm, gfn);\n\n\treturn __kvm_read_guest_page(slot, gfn, data, offset, len);\n}\nEXPORT_SYMBOL_GPL(kvm_read_guest_page);\n\nint kvm_vcpu_read_guest_page(struct kvm_vcpu *vcpu, gfn_t gfn, void *data,\n\t\t\t     int offset, int len)\n{\n\tstruct kvm_memory_slot *slot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\n\treturn __kvm_read_guest_page(slot, gfn, data, offset, len);\n}\nEXPORT_SYMBOL_GPL(kvm_vcpu_read_guest_page);\n\nint kvm_read_guest(struct kvm *kvm, gpa_t gpa, void *data, unsigned long len)\n{\n\tgfn_t gfn = gpa >> PAGE_SHIFT;\n\tint seg;\n\tint offset = offset_in_page(gpa);\n\tint ret;\n\n\twhile ((seg = next_segment(len, offset)) != 0) {\n\t\tret = kvm_read_guest_page(kvm, gfn, data, offset, seg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\toffset = 0;\n\t\tlen -= seg;\n\t\tdata += seg;\n\t\t++gfn;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_read_guest);\n\nint kvm_vcpu_read_guest(struct kvm_vcpu *vcpu, gpa_t gpa, void *data, unsigned long len)\n{\n\tgfn_t gfn = gpa >> PAGE_SHIFT;\n\tint seg;\n\tint offset = offset_in_page(gpa);\n\tint ret;\n\n\twhile ((seg = next_segment(len, offset)) != 0) {\n\t\tret = kvm_vcpu_read_guest_page(vcpu, gfn, data, offset, seg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\toffset = 0;\n\t\tlen -= seg;\n\t\tdata += seg;\n\t\t++gfn;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_vcpu_read_guest);\n\nstatic int __kvm_read_guest_atomic(struct kvm_memory_slot *slot, gfn_t gfn,\n\t\t\t           void *data, int offset, unsigned long len)\n{\n\tint r;\n\tunsigned long addr;\n\n\taddr = gfn_to_hva_memslot_prot(slot, gfn, NULL);\n\tif (kvm_is_error_hva(addr))\n\t\treturn -EFAULT;\n\tpagefault_disable();\n\tr = __copy_from_user_inatomic(data, (void __user *)addr + offset, len);\n\tpagefault_enable();\n\tif (r)\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nint kvm_vcpu_read_guest_atomic(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t       void *data, unsigned long len)\n{\n\tgfn_t gfn = gpa >> PAGE_SHIFT;\n\tstruct kvm_memory_slot *slot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\tint offset = offset_in_page(gpa);\n\n\treturn __kvm_read_guest_atomic(slot, gfn, data, offset, len);\n}\nEXPORT_SYMBOL_GPL(kvm_vcpu_read_guest_atomic);\n\nstatic int __kvm_write_guest_page(struct kvm *kvm,\n\t\t\t\t  struct kvm_memory_slot *memslot, gfn_t gfn,\n\t\t\t          const void *data, int offset, int len)\n{\n\tint r;\n\tunsigned long addr;\n\n\taddr = gfn_to_hva_memslot(memslot, gfn);\n\tif (kvm_is_error_hva(addr))\n\t\treturn -EFAULT;\n\tr = __copy_to_user((void __user *)addr + offset, data, len);\n\tif (r)\n\t\treturn -EFAULT;\n\tmark_page_dirty_in_slot(kvm, memslot, gfn);\n\treturn 0;\n}\n\nint kvm_write_guest_page(struct kvm *kvm, gfn_t gfn,\n\t\t\t const void *data, int offset, int len)\n{\n\tstruct kvm_memory_slot *slot = gfn_to_memslot(kvm, gfn);\n\n\treturn __kvm_write_guest_page(kvm, slot, gfn, data, offset, len);\n}\nEXPORT_SYMBOL_GPL(kvm_write_guest_page);\n\nint kvm_vcpu_write_guest_page(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t      const void *data, int offset, int len)\n{\n\tstruct kvm_memory_slot *slot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\n\treturn __kvm_write_guest_page(vcpu->kvm, slot, gfn, data, offset, len);\n}\nEXPORT_SYMBOL_GPL(kvm_vcpu_write_guest_page);\n\nint kvm_write_guest(struct kvm *kvm, gpa_t gpa, const void *data,\n\t\t    unsigned long len)\n{\n\tgfn_t gfn = gpa >> PAGE_SHIFT;\n\tint seg;\n\tint offset = offset_in_page(gpa);\n\tint ret;\n\n\twhile ((seg = next_segment(len, offset)) != 0) {\n\t\tret = kvm_write_guest_page(kvm, gfn, data, offset, seg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\toffset = 0;\n\t\tlen -= seg;\n\t\tdata += seg;\n\t\t++gfn;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_write_guest);\n\nint kvm_vcpu_write_guest(struct kvm_vcpu *vcpu, gpa_t gpa, const void *data,\n\t\t         unsigned long len)\n{\n\tgfn_t gfn = gpa >> PAGE_SHIFT;\n\tint seg;\n\tint offset = offset_in_page(gpa);\n\tint ret;\n\n\twhile ((seg = next_segment(len, offset)) != 0) {\n\t\tret = kvm_vcpu_write_guest_page(vcpu, gfn, data, offset, seg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\toffset = 0;\n\t\tlen -= seg;\n\t\tdata += seg;\n\t\t++gfn;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_vcpu_write_guest);\n\nstatic int __kvm_gfn_to_hva_cache_init(struct kvm_memslots *slots,\n\t\t\t\t       struct gfn_to_hva_cache *ghc,\n\t\t\t\t       gpa_t gpa, unsigned long len)\n{\n\tint offset = offset_in_page(gpa);\n\tgfn_t start_gfn = gpa >> PAGE_SHIFT;\n\tgfn_t end_gfn = (gpa + len - 1) >> PAGE_SHIFT;\n\tgfn_t nr_pages_needed = end_gfn - start_gfn + 1;\n\tgfn_t nr_pages_avail;\n\n\t/* Update ghc->generation before performing any error checks. */\n\tghc->generation = slots->generation;\n\n\tif (start_gfn > end_gfn) {\n\t\tghc->hva = KVM_HVA_ERR_BAD;\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * If the requested region crosses two memslots, we still\n\t * verify that the entire region is valid here.\n\t */\n\tfor ( ; start_gfn <= end_gfn; start_gfn += nr_pages_avail) {\n\t\tghc->memslot = __gfn_to_memslot(slots, start_gfn);\n\t\tghc->hva = gfn_to_hva_many(ghc->memslot, start_gfn,\n\t\t\t\t\t   &nr_pages_avail);\n\t\tif (kvm_is_error_hva(ghc->hva))\n\t\t\treturn -EFAULT;\n\t}\n\n\t/* Use the slow path for cross page reads and writes. */\n\tif (nr_pages_needed == 1)\n\t\tghc->hva += offset;\n\telse\n\t\tghc->memslot = NULL;\n\n\tghc->gpa = gpa;\n\tghc->len = len;\n\treturn 0;\n}\n\nint kvm_gfn_to_hva_cache_init(struct kvm *kvm, struct gfn_to_hva_cache *ghc,\n\t\t\t      gpa_t gpa, unsigned long len)\n{\n\tstruct kvm_memslots *slots = kvm_memslots(kvm);\n\treturn __kvm_gfn_to_hva_cache_init(slots, ghc, gpa, len);\n}\nEXPORT_SYMBOL_GPL(kvm_gfn_to_hva_cache_init);\n\nint kvm_write_guest_offset_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc,\n\t\t\t\t  void *data, unsigned int offset,\n\t\t\t\t  unsigned long len)\n{\n\tstruct kvm_memslots *slots = kvm_memslots(kvm);\n\tint r;\n\tgpa_t gpa = ghc->gpa + offset;\n\n\tif (WARN_ON_ONCE(len + offset > ghc->len))\n\t\treturn -EINVAL;\n\n\tif (slots->generation != ghc->generation) {\n\t\tif (__kvm_gfn_to_hva_cache_init(slots, ghc, ghc->gpa, ghc->len))\n\t\t\treturn -EFAULT;\n\t}\n\n\tif (kvm_is_error_hva(ghc->hva))\n\t\treturn -EFAULT;\n\n\tif (unlikely(!ghc->memslot))\n\t\treturn kvm_write_guest(kvm, gpa, data, len);\n\n\tr = __copy_to_user((void __user *)ghc->hva + offset, data, len);\n\tif (r)\n\t\treturn -EFAULT;\n\tmark_page_dirty_in_slot(kvm, ghc->memslot, gpa >> PAGE_SHIFT);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_write_guest_offset_cached);\n\nint kvm_write_guest_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc,\n\t\t\t   void *data, unsigned long len)\n{\n\treturn kvm_write_guest_offset_cached(kvm, ghc, data, 0, len);\n}\nEXPORT_SYMBOL_GPL(kvm_write_guest_cached);\n\nint kvm_read_guest_offset_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc,\n\t\t\t\t void *data, unsigned int offset,\n\t\t\t\t unsigned long len)\n{\n\tstruct kvm_memslots *slots = kvm_memslots(kvm);\n\tint r;\n\tgpa_t gpa = ghc->gpa + offset;\n\n\tif (WARN_ON_ONCE(len + offset > ghc->len))\n\t\treturn -EINVAL;\n\n\tif (slots->generation != ghc->generation) {\n\t\tif (__kvm_gfn_to_hva_cache_init(slots, ghc, ghc->gpa, ghc->len))\n\t\t\treturn -EFAULT;\n\t}\n\n\tif (kvm_is_error_hva(ghc->hva))\n\t\treturn -EFAULT;\n\n\tif (unlikely(!ghc->memslot))\n\t\treturn kvm_read_guest(kvm, gpa, data, len);\n\n\tr = __copy_from_user(data, (void __user *)ghc->hva + offset, len);\n\tif (r)\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_read_guest_offset_cached);\n\nint kvm_read_guest_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc,\n\t\t\t  void *data, unsigned long len)\n{\n\treturn kvm_read_guest_offset_cached(kvm, ghc, data, 0, len);\n}\nEXPORT_SYMBOL_GPL(kvm_read_guest_cached);\n\nint kvm_clear_guest(struct kvm *kvm, gpa_t gpa, unsigned long len)\n{\n\tconst void *zero_page = (const void *) __va(page_to_phys(ZERO_PAGE(0)));\n\tgfn_t gfn = gpa >> PAGE_SHIFT;\n\tint seg;\n\tint offset = offset_in_page(gpa);\n\tint ret;\n\n\twhile ((seg = next_segment(len, offset)) != 0) {\n\t\tret = kvm_write_guest_page(kvm, gfn, zero_page, offset, len);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\toffset = 0;\n\t\tlen -= seg;\n\t\t++gfn;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_clear_guest);\n\nvoid mark_page_dirty_in_slot(struct kvm *kvm,\n\t\t\t     const struct kvm_memory_slot *memslot,\n\t\t \t     gfn_t gfn)\n{\n\tstruct kvm_vcpu *vcpu = kvm_get_running_vcpu();\n\n#ifdef CONFIG_HAVE_KVM_DIRTY_RING\n\tif (WARN_ON_ONCE(!vcpu) || WARN_ON_ONCE(vcpu->kvm != kvm))\n\t\treturn;\n#endif\n\n\tif (memslot && kvm_slot_dirty_track_enabled(memslot)) {\n\t\tunsigned long rel_gfn = gfn - memslot->base_gfn;\n\t\tu32 slot = (memslot->as_id << 16) | memslot->id;\n\n\t\tif (kvm->dirty_ring_size)\n\t\t\tkvm_dirty_ring_push(&vcpu->dirty_ring,\n\t\t\t\t\t    slot, rel_gfn);\n\t\telse\n\t\t\tset_bit_le(rel_gfn, memslot->dirty_bitmap);\n\t}\n}\nEXPORT_SYMBOL_GPL(mark_page_dirty_in_slot);\n\nvoid mark_page_dirty(struct kvm *kvm, gfn_t gfn)\n{\n\tstruct kvm_memory_slot *memslot;\n\n\tmemslot = gfn_to_memslot(kvm, gfn);\n\tmark_page_dirty_in_slot(kvm, memslot, gfn);\n}\nEXPORT_SYMBOL_GPL(mark_page_dirty);\n\nvoid kvm_vcpu_mark_page_dirty(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\tstruct kvm_memory_slot *memslot;\n\n\tmemslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\tmark_page_dirty_in_slot(vcpu->kvm, memslot, gfn);\n}\nEXPORT_SYMBOL_GPL(kvm_vcpu_mark_page_dirty);\n\nvoid kvm_sigset_activate(struct kvm_vcpu *vcpu)\n{\n\tif (!vcpu->sigset_active)\n\t\treturn;\n\n\t/*\n\t * This does a lockless modification of ->real_blocked, which is fine\n\t * because, only current can change ->real_blocked and all readers of\n\t * ->real_blocked don't care as long ->real_blocked is always a subset\n\t * of ->blocked.\n\t */\n\tsigprocmask(SIG_SETMASK, &vcpu->sigset, &current->real_blocked);\n}\n\nvoid kvm_sigset_deactivate(struct kvm_vcpu *vcpu)\n{\n\tif (!vcpu->sigset_active)\n\t\treturn;\n\n\tsigprocmask(SIG_SETMASK, &current->real_blocked, NULL);\n\tsigemptyset(&current->real_blocked);\n}\n\nstatic void grow_halt_poll_ns(struct kvm_vcpu *vcpu)\n{\n\tunsigned int old, val, grow, grow_start;\n\n\told = val = vcpu->halt_poll_ns;\n\tgrow_start = READ_ONCE(halt_poll_ns_grow_start);\n\tgrow = READ_ONCE(halt_poll_ns_grow);\n\tif (!grow)\n\t\tgoto out;\n\n\tval *= grow;\n\tif (val < grow_start)\n\t\tval = grow_start;\n\n\tif (val > vcpu->kvm->max_halt_poll_ns)\n\t\tval = vcpu->kvm->max_halt_poll_ns;\n\n\tvcpu->halt_poll_ns = val;\nout:\n\ttrace_kvm_halt_poll_ns_grow(vcpu->vcpu_id, val, old);\n}\n\nstatic void shrink_halt_poll_ns(struct kvm_vcpu *vcpu)\n{\n\tunsigned int old, val, shrink, grow_start;\n\n\told = val = vcpu->halt_poll_ns;\n\tshrink = READ_ONCE(halt_poll_ns_shrink);\n\tgrow_start = READ_ONCE(halt_poll_ns_grow_start);\n\tif (shrink == 0)\n\t\tval = 0;\n\telse\n\t\tval /= shrink;\n\n\tif (val < grow_start)\n\t\tval = 0;\n\n\tvcpu->halt_poll_ns = val;\n\ttrace_kvm_halt_poll_ns_shrink(vcpu->vcpu_id, val, old);\n}\n\nstatic int kvm_vcpu_check_block(struct kvm_vcpu *vcpu)\n{\n\tint ret = -EINTR;\n\tint idx = srcu_read_lock(&vcpu->kvm->srcu);\n\n\tif (kvm_arch_vcpu_runnable(vcpu)) {\n\t\tkvm_make_request(KVM_REQ_UNHALT, vcpu);\n\t\tgoto out;\n\t}\n\tif (kvm_cpu_has_pending_timer(vcpu))\n\t\tgoto out;\n\tif (signal_pending(current))\n\t\tgoto out;\n\tif (kvm_check_request(KVM_REQ_UNBLOCK, vcpu))\n\t\tgoto out;\n\n\tret = 0;\nout:\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\treturn ret;\n}\n\n/*\n * Block the vCPU until the vCPU is runnable, an event arrives, or a signal is\n * pending.  This is mostly used when halting a vCPU, but may also be used\n * directly for other vCPU non-runnable states, e.g. x86's Wait-For-SIPI.\n */\nbool kvm_vcpu_block(struct kvm_vcpu *vcpu)\n{\n\tstruct rcuwait *wait = kvm_arch_vcpu_get_wait(vcpu);\n\tbool waited = false;\n\n\tvcpu->stat.generic.blocking = 1;\n\n\tkvm_arch_vcpu_blocking(vcpu);\n\n\tprepare_to_rcuwait(wait);\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\tif (kvm_vcpu_check_block(vcpu) < 0)\n\t\t\tbreak;\n\n\t\twaited = true;\n\t\tschedule();\n\t}\n\tfinish_rcuwait(wait);\n\n\tkvm_arch_vcpu_unblocking(vcpu);\n\n\tvcpu->stat.generic.blocking = 0;\n\n\treturn waited;\n}\n\nstatic inline void update_halt_poll_stats(struct kvm_vcpu *vcpu, ktime_t start,\n\t\t\t\t\t  ktime_t end, bool success)\n{\n\tstruct kvm_vcpu_stat_generic *stats = &vcpu->stat.generic;\n\tu64 poll_ns = ktime_to_ns(ktime_sub(end, start));\n\n\t++vcpu->stat.generic.halt_attempted_poll;\n\n\tif (success) {\n\t\t++vcpu->stat.generic.halt_successful_poll;\n\n\t\tif (!vcpu_valid_wakeup(vcpu))\n\t\t\t++vcpu->stat.generic.halt_poll_invalid;\n\n\t\tstats->halt_poll_success_ns += poll_ns;\n\t\tKVM_STATS_LOG_HIST_UPDATE(stats->halt_poll_success_hist, poll_ns);\n\t} else {\n\t\tstats->halt_poll_fail_ns += poll_ns;\n\t\tKVM_STATS_LOG_HIST_UPDATE(stats->halt_poll_fail_hist, poll_ns);\n\t}\n}\n\n/*\n * Emulate a vCPU halt condition, e.g. HLT on x86, WFI on arm, etc...  If halt\n * polling is enabled, busy wait for a short time before blocking to avoid the\n * expensive block+unblock sequence if a wake event arrives soon after the vCPU\n * is halted.\n */\nvoid kvm_vcpu_halt(struct kvm_vcpu *vcpu)\n{\n\tbool halt_poll_allowed = !kvm_arch_no_poll(vcpu);\n\tbool do_halt_poll = halt_poll_allowed && vcpu->halt_poll_ns;\n\tktime_t start, cur, poll_end;\n\tbool waited = false;\n\tu64 halt_ns;\n\n\tstart = cur = poll_end = ktime_get();\n\tif (do_halt_poll) {\n\t\tktime_t stop = ktime_add_ns(start, vcpu->halt_poll_ns);\n\n\t\tdo {\n\t\t\t/*\n\t\t\t * This sets KVM_REQ_UNHALT if an interrupt\n\t\t\t * arrives.\n\t\t\t */\n\t\t\tif (kvm_vcpu_check_block(vcpu) < 0)\n\t\t\t\tgoto out;\n\t\t\tcpu_relax();\n\t\t\tpoll_end = cur = ktime_get();\n\t\t} while (kvm_vcpu_can_poll(cur, stop));\n\t}\n\n\twaited = kvm_vcpu_block(vcpu);\n\n\tcur = ktime_get();\n\tif (waited) {\n\t\tvcpu->stat.generic.halt_wait_ns +=\n\t\t\tktime_to_ns(cur) - ktime_to_ns(poll_end);\n\t\tKVM_STATS_LOG_HIST_UPDATE(vcpu->stat.generic.halt_wait_hist,\n\t\t\t\tktime_to_ns(cur) - ktime_to_ns(poll_end));\n\t}\nout:\n\t/* The total time the vCPU was \"halted\", including polling time. */\n\thalt_ns = ktime_to_ns(cur) - ktime_to_ns(start);\n\n\t/*\n\t * Note, halt-polling is considered successful so long as the vCPU was\n\t * never actually scheduled out, i.e. even if the wake event arrived\n\t * after of the halt-polling loop itself, but before the full wait.\n\t */\n\tif (do_halt_poll)\n\t\tupdate_halt_poll_stats(vcpu, start, poll_end, !waited);\n\n\tif (halt_poll_allowed) {\n\t\tif (!vcpu_valid_wakeup(vcpu)) {\n\t\t\tshrink_halt_poll_ns(vcpu);\n\t\t} else if (vcpu->kvm->max_halt_poll_ns) {\n\t\t\tif (halt_ns <= vcpu->halt_poll_ns)\n\t\t\t\t;\n\t\t\t/* we had a long block, shrink polling */\n\t\t\telse if (vcpu->halt_poll_ns &&\n\t\t\t\t halt_ns > vcpu->kvm->max_halt_poll_ns)\n\t\t\t\tshrink_halt_poll_ns(vcpu);\n\t\t\t/* we had a short halt and our poll time is too small */\n\t\t\telse if (vcpu->halt_poll_ns < vcpu->kvm->max_halt_poll_ns &&\n\t\t\t\t halt_ns < vcpu->kvm->max_halt_poll_ns)\n\t\t\t\tgrow_halt_poll_ns(vcpu);\n\t\t} else {\n\t\t\tvcpu->halt_poll_ns = 0;\n\t\t}\n\t}\n\n\ttrace_kvm_vcpu_wakeup(halt_ns, waited, vcpu_valid_wakeup(vcpu));\n}\nEXPORT_SYMBOL_GPL(kvm_vcpu_halt);\n\nbool kvm_vcpu_wake_up(struct kvm_vcpu *vcpu)\n{\n\tif (__kvm_vcpu_wake_up(vcpu)) {\n\t\tWRITE_ONCE(vcpu->ready, true);\n\t\t++vcpu->stat.generic.halt_wakeup;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(kvm_vcpu_wake_up);\n\n#ifndef CONFIG_S390\n/*\n * Kick a sleeping VCPU, or a guest VCPU in guest mode, into host kernel mode.\n */\nvoid kvm_vcpu_kick(struct kvm_vcpu *vcpu)\n{\n\tint me, cpu;\n\n\tif (kvm_vcpu_wake_up(vcpu))\n\t\treturn;\n\n\tme = get_cpu();\n\t/*\n\t * The only state change done outside the vcpu mutex is IN_GUEST_MODE\n\t * to EXITING_GUEST_MODE.  Therefore the moderately expensive \"should\n\t * kick\" check does not need atomic operations if kvm_vcpu_kick is used\n\t * within the vCPU thread itself.\n\t */\n\tif (vcpu == __this_cpu_read(kvm_running_vcpu)) {\n\t\tif (vcpu->mode == IN_GUEST_MODE)\n\t\t\tWRITE_ONCE(vcpu->mode, EXITING_GUEST_MODE);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Note, the vCPU could get migrated to a different pCPU at any point\n\t * after kvm_arch_vcpu_should_kick(), which could result in sending an\n\t * IPI to the previous pCPU.  But, that's ok because the purpose of the\n\t * IPI is to force the vCPU to leave IN_GUEST_MODE, and migrating the\n\t * vCPU also requires it to leave IN_GUEST_MODE.\n\t */\n\tif (kvm_arch_vcpu_should_kick(vcpu)) {\n\t\tcpu = READ_ONCE(vcpu->cpu);\n\t\tif (cpu != me && (unsigned)cpu < nr_cpu_ids && cpu_online(cpu))\n\t\t\tsmp_send_reschedule(cpu);\n\t}\nout:\n\tput_cpu();\n}\nEXPORT_SYMBOL_GPL(kvm_vcpu_kick);\n#endif /* !CONFIG_S390 */\n\nint kvm_vcpu_yield_to(struct kvm_vcpu *target)\n{\n\tstruct pid *pid;\n\tstruct task_struct *task = NULL;\n\tint ret = 0;\n\n\trcu_read_lock();\n\tpid = rcu_dereference(target->pid);\n\tif (pid)\n\t\ttask = get_pid_task(pid, PIDTYPE_PID);\n\trcu_read_unlock();\n\tif (!task)\n\t\treturn ret;\n\tret = yield_to(task, 1);\n\tput_task_struct(task);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(kvm_vcpu_yield_to);\n\n/*\n * Helper that checks whether a VCPU is eligible for directed yield.\n * Most eligible candidate to yield is decided by following heuristics:\n *\n *  (a) VCPU which has not done pl-exit or cpu relax intercepted recently\n *  (preempted lock holder), indicated by @in_spin_loop.\n *  Set at the beginning and cleared at the end of interception/PLE handler.\n *\n *  (b) VCPU which has done pl-exit/ cpu relax intercepted but did not get\n *  chance last time (mostly it has become eligible now since we have probably\n *  yielded to lockholder in last iteration. This is done by toggling\n *  @dy_eligible each time a VCPU checked for eligibility.)\n *\n *  Yielding to a recently pl-exited/cpu relax intercepted VCPU before yielding\n *  to preempted lock-holder could result in wrong VCPU selection and CPU\n *  burning. Giving priority for a potential lock-holder increases lock\n *  progress.\n *\n *  Since algorithm is based on heuristics, accessing another VCPU data without\n *  locking does not harm. It may result in trying to yield to  same VCPU, fail\n *  and continue with next VCPU and so on.\n */\nstatic bool kvm_vcpu_eligible_for_directed_yield(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_HAVE_KVM_CPU_RELAX_INTERCEPT\n\tbool eligible;\n\n\teligible = !vcpu->spin_loop.in_spin_loop ||\n\t\t    vcpu->spin_loop.dy_eligible;\n\n\tif (vcpu->spin_loop.in_spin_loop)\n\t\tkvm_vcpu_set_dy_eligible(vcpu, !vcpu->spin_loop.dy_eligible);\n\n\treturn eligible;\n#else\n\treturn true;\n#endif\n}\n\n/*\n * Unlike kvm_arch_vcpu_runnable, this function is called outside\n * a vcpu_load/vcpu_put pair.  However, for most architectures\n * kvm_arch_vcpu_runnable does not require vcpu_load.\n */\nbool __weak kvm_arch_dy_runnable(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_arch_vcpu_runnable(vcpu);\n}\n\nstatic bool vcpu_dy_runnable(struct kvm_vcpu *vcpu)\n{\n\tif (kvm_arch_dy_runnable(vcpu))\n\t\treturn true;\n\n#ifdef CONFIG_KVM_ASYNC_PF\n\tif (!list_empty_careful(&vcpu->async_pf.done))\n\t\treturn true;\n#endif\n\n\treturn false;\n}\n\nbool __weak kvm_arch_dy_has_pending_interrupt(struct kvm_vcpu *vcpu)\n{\n\treturn false;\n}\n\nvoid kvm_vcpu_on_spin(struct kvm_vcpu *me, bool yield_to_kernel_mode)\n{\n\tstruct kvm *kvm = me->kvm;\n\tstruct kvm_vcpu *vcpu;\n\tint last_boosted_vcpu = me->kvm->last_boosted_vcpu;\n\tunsigned long i;\n\tint yielded = 0;\n\tint try = 3;\n\tint pass;\n\n\tkvm_vcpu_set_in_spin_loop(me, true);\n\t/*\n\t * We boost the priority of a VCPU that is runnable but not\n\t * currently running, because it got preempted by something\n\t * else and called schedule in __vcpu_run.  Hopefully that\n\t * VCPU is holding the lock that we need and will release it.\n\t * We approximate round-robin by starting at the last boosted VCPU.\n\t */\n\tfor (pass = 0; pass < 2 && !yielded && try; pass++) {\n\t\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\t\tif (!pass && i <= last_boosted_vcpu) {\n\t\t\t\ti = last_boosted_vcpu;\n\t\t\t\tcontinue;\n\t\t\t} else if (pass && i > last_boosted_vcpu)\n\t\t\t\tbreak;\n\t\t\tif (!READ_ONCE(vcpu->ready))\n\t\t\t\tcontinue;\n\t\t\tif (vcpu == me)\n\t\t\t\tcontinue;\n\t\t\tif (kvm_vcpu_is_blocking(vcpu) && !vcpu_dy_runnable(vcpu))\n\t\t\t\tcontinue;\n\t\t\tif (READ_ONCE(vcpu->preempted) && yield_to_kernel_mode &&\n\t\t\t    !kvm_arch_dy_has_pending_interrupt(vcpu) &&\n\t\t\t    !kvm_arch_vcpu_in_kernel(vcpu))\n\t\t\t\tcontinue;\n\t\t\tif (!kvm_vcpu_eligible_for_directed_yield(vcpu))\n\t\t\t\tcontinue;\n\n\t\t\tyielded = kvm_vcpu_yield_to(vcpu);\n\t\t\tif (yielded > 0) {\n\t\t\t\tkvm->last_boosted_vcpu = i;\n\t\t\t\tbreak;\n\t\t\t} else if (yielded < 0) {\n\t\t\t\ttry--;\n\t\t\t\tif (!try)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tkvm_vcpu_set_in_spin_loop(me, false);\n\n\t/* Ensure vcpu is not eligible during next spinloop */\n\tkvm_vcpu_set_dy_eligible(me, false);\n}\nEXPORT_SYMBOL_GPL(kvm_vcpu_on_spin);\n\nstatic bool kvm_page_in_dirty_ring(struct kvm *kvm, unsigned long pgoff)\n{\n#ifdef CONFIG_HAVE_KVM_DIRTY_RING\n\treturn (pgoff >= KVM_DIRTY_LOG_PAGE_OFFSET) &&\n\t    (pgoff < KVM_DIRTY_LOG_PAGE_OFFSET +\n\t     kvm->dirty_ring_size / PAGE_SIZE);\n#else\n\treturn false;\n#endif\n}\n\nstatic vm_fault_t kvm_vcpu_fault(struct vm_fault *vmf)\n{\n\tstruct kvm_vcpu *vcpu = vmf->vma->vm_file->private_data;\n\tstruct page *page;\n\n\tif (vmf->pgoff == 0)\n\t\tpage = virt_to_page(vcpu->run);\n#ifdef CONFIG_X86\n\telse if (vmf->pgoff == KVM_PIO_PAGE_OFFSET)\n\t\tpage = virt_to_page(vcpu->arch.pio_data);\n#endif\n#ifdef CONFIG_KVM_MMIO\n\telse if (vmf->pgoff == KVM_COALESCED_MMIO_PAGE_OFFSET)\n\t\tpage = virt_to_page(vcpu->kvm->coalesced_mmio_ring);\n#endif\n\telse if (kvm_page_in_dirty_ring(vcpu->kvm, vmf->pgoff))\n\t\tpage = kvm_dirty_ring_get_page(\n\t\t    &vcpu->dirty_ring,\n\t\t    vmf->pgoff - KVM_DIRTY_LOG_PAGE_OFFSET);\n\telse\n\t\treturn kvm_arch_vcpu_fault(vcpu, vmf);\n\tget_page(page);\n\tvmf->page = page;\n\treturn 0;\n}\n\nstatic const struct vm_operations_struct kvm_vcpu_vm_ops = {\n\t.fault = kvm_vcpu_fault,\n};\n\nstatic int kvm_vcpu_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct kvm_vcpu *vcpu = file->private_data;\n\tunsigned long pages = vma_pages(vma);\n\n\tif ((kvm_page_in_dirty_ring(vcpu->kvm, vma->vm_pgoff) ||\n\t     kvm_page_in_dirty_ring(vcpu->kvm, vma->vm_pgoff + pages - 1)) &&\n\t    ((vma->vm_flags & VM_EXEC) || !(vma->vm_flags & VM_SHARED)))\n\t\treturn -EINVAL;\n\n\tvma->vm_ops = &kvm_vcpu_vm_ops;\n\treturn 0;\n}\n\nstatic int kvm_vcpu_release(struct inode *inode, struct file *filp)\n{\n\tstruct kvm_vcpu *vcpu = filp->private_data;\n\n\tkvm_put_kvm(vcpu->kvm);\n\treturn 0;\n}\n\nstatic const struct file_operations kvm_vcpu_fops = {\n\t.release        = kvm_vcpu_release,\n\t.unlocked_ioctl = kvm_vcpu_ioctl,\n\t.mmap           = kvm_vcpu_mmap,\n\t.llseek\t\t= noop_llseek,\n\tKVM_COMPAT(kvm_vcpu_compat_ioctl),\n};\n\n/*\n * Allocates an inode for the vcpu.\n */\nstatic int create_vcpu_fd(struct kvm_vcpu *vcpu)\n{\n\tchar name[8 + 1 + ITOA_MAX_LEN + 1];\n\n\tsnprintf(name, sizeof(name), \"kvm-vcpu:%d\", vcpu->vcpu_id);\n\treturn anon_inode_getfd(name, &kvm_vcpu_fops, vcpu, O_RDWR | O_CLOEXEC);\n}\n\nstatic void kvm_create_vcpu_debugfs(struct kvm_vcpu *vcpu)\n{\n#ifdef __KVM_HAVE_ARCH_VCPU_DEBUGFS\n\tstruct dentry *debugfs_dentry;\n\tchar dir_name[ITOA_MAX_LEN * 2];\n\n\tif (!debugfs_initialized())\n\t\treturn;\n\n\tsnprintf(dir_name, sizeof(dir_name), \"vcpu%d\", vcpu->vcpu_id);\n\tdebugfs_dentry = debugfs_create_dir(dir_name,\n\t\t\t\t\t    vcpu->kvm->debugfs_dentry);\n\n\tkvm_arch_create_vcpu_debugfs(vcpu, debugfs_dentry);\n#endif\n}\n\n/*\n * Creates some virtual cpus.  Good luck creating more than one.\n */\nstatic int kvm_vm_ioctl_create_vcpu(struct kvm *kvm, u32 id)\n{\n\tint r;\n\tstruct kvm_vcpu *vcpu;\n\tstruct page *page;\n\n\tif (id >= KVM_MAX_VCPU_IDS)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&kvm->lock);\n\tif (kvm->created_vcpus == KVM_MAX_VCPUS) {\n\t\tmutex_unlock(&kvm->lock);\n\t\treturn -EINVAL;\n\t}\n\n\tkvm->created_vcpus++;\n\tmutex_unlock(&kvm->lock);\n\n\tr = kvm_arch_vcpu_precreate(kvm, id);\n\tif (r)\n\t\tgoto vcpu_decrement;\n\n\tvcpu = kmem_cache_zalloc(kvm_vcpu_cache, GFP_KERNEL_ACCOUNT);\n\tif (!vcpu) {\n\t\tr = -ENOMEM;\n\t\tgoto vcpu_decrement;\n\t}\n\n\tBUILD_BUG_ON(sizeof(struct kvm_run) > PAGE_SIZE);\n\tpage = alloc_page(GFP_KERNEL_ACCOUNT | __GFP_ZERO);\n\tif (!page) {\n\t\tr = -ENOMEM;\n\t\tgoto vcpu_free;\n\t}\n\tvcpu->run = page_address(page);\n\n\tkvm_vcpu_init(vcpu, kvm, id);\n\n\tr = kvm_arch_vcpu_create(vcpu);\n\tif (r)\n\t\tgoto vcpu_free_run_page;\n\n\tif (kvm->dirty_ring_size) {\n\t\tr = kvm_dirty_ring_alloc(&vcpu->dirty_ring,\n\t\t\t\t\t id, kvm->dirty_ring_size);\n\t\tif (r)\n\t\t\tgoto arch_vcpu_destroy;\n\t}\n\n\tmutex_lock(&kvm->lock);\n\tif (kvm_get_vcpu_by_id(kvm, id)) {\n\t\tr = -EEXIST;\n\t\tgoto unlock_vcpu_destroy;\n\t}\n\n\tvcpu->vcpu_idx = atomic_read(&kvm->online_vcpus);\n\tr = xa_insert(&kvm->vcpu_array, vcpu->vcpu_idx, vcpu, GFP_KERNEL_ACCOUNT);\n\tBUG_ON(r == -EBUSY);\n\tif (r)\n\t\tgoto unlock_vcpu_destroy;\n\n\t/* Fill the stats id string for the vcpu */\n\tsnprintf(vcpu->stats_id, sizeof(vcpu->stats_id), \"kvm-%d/vcpu-%d\",\n\t\t task_pid_nr(current), id);\n\n\t/* Now it's all set up, let userspace reach it */\n\tkvm_get_kvm(kvm);\n\tr = create_vcpu_fd(vcpu);\n\tif (r < 0) {\n\t\txa_erase(&kvm->vcpu_array, vcpu->vcpu_idx);\n\t\tkvm_put_kvm_no_destroy(kvm);\n\t\tgoto unlock_vcpu_destroy;\n\t}\n\n\t/*\n\t * Pairs with smp_rmb() in kvm_get_vcpu.  Store the vcpu\n\t * pointer before kvm->online_vcpu's incremented value.\n\t */\n\tsmp_wmb();\n\tatomic_inc(&kvm->online_vcpus);\n\n\tmutex_unlock(&kvm->lock);\n\tkvm_arch_vcpu_postcreate(vcpu);\n\tkvm_create_vcpu_debugfs(vcpu);\n\treturn r;\n\nunlock_vcpu_destroy:\n\tmutex_unlock(&kvm->lock);\n\tkvm_dirty_ring_free(&vcpu->dirty_ring);\narch_vcpu_destroy:\n\tkvm_arch_vcpu_destroy(vcpu);\nvcpu_free_run_page:\n\tfree_page((unsigned long)vcpu->run);\nvcpu_free:\n\tkmem_cache_free(kvm_vcpu_cache, vcpu);\nvcpu_decrement:\n\tmutex_lock(&kvm->lock);\n\tkvm->created_vcpus--;\n\tmutex_unlock(&kvm->lock);\n\treturn r;\n}\n\nstatic int kvm_vcpu_ioctl_set_sigmask(struct kvm_vcpu *vcpu, sigset_t *sigset)\n{\n\tif (sigset) {\n\t\tsigdelsetmask(sigset, sigmask(SIGKILL)|sigmask(SIGSTOP));\n\t\tvcpu->sigset_active = 1;\n\t\tvcpu->sigset = *sigset;\n\t} else\n\t\tvcpu->sigset_active = 0;\n\treturn 0;\n}\n\nstatic ssize_t kvm_vcpu_stats_read(struct file *file, char __user *user_buffer,\n\t\t\t      size_t size, loff_t *offset)\n{\n\tstruct kvm_vcpu *vcpu = file->private_data;\n\n\treturn kvm_stats_read(vcpu->stats_id, &kvm_vcpu_stats_header,\n\t\t\t&kvm_vcpu_stats_desc[0], &vcpu->stat,\n\t\t\tsizeof(vcpu->stat), user_buffer, size, offset);\n}\n\nstatic const struct file_operations kvm_vcpu_stats_fops = {\n\t.read = kvm_vcpu_stats_read,\n\t.llseek = noop_llseek,\n};\n\nstatic int kvm_vcpu_ioctl_get_stats_fd(struct kvm_vcpu *vcpu)\n{\n\tint fd;\n\tstruct file *file;\n\tchar name[15 + ITOA_MAX_LEN + 1];\n\n\tsnprintf(name, sizeof(name), \"kvm-vcpu-stats:%d\", vcpu->vcpu_id);\n\n\tfd = get_unused_fd_flags(O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn fd;\n\n\tfile = anon_inode_getfile(name, &kvm_vcpu_stats_fops, vcpu, O_RDONLY);\n\tif (IS_ERR(file)) {\n\t\tput_unused_fd(fd);\n\t\treturn PTR_ERR(file);\n\t}\n\tfile->f_mode |= FMODE_PREAD;\n\tfd_install(fd, file);\n\n\treturn fd;\n}\n\nstatic long kvm_vcpu_ioctl(struct file *filp,\n\t\t\t   unsigned int ioctl, unsigned long arg)\n{\n\tstruct kvm_vcpu *vcpu = filp->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tint r;\n\tstruct kvm_fpu *fpu = NULL;\n\tstruct kvm_sregs *kvm_sregs = NULL;\n\n\tif (vcpu->kvm->mm != current->mm || vcpu->kvm->vm_dead)\n\t\treturn -EIO;\n\n\tif (unlikely(_IOC_TYPE(ioctl) != KVMIO))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Some architectures have vcpu ioctls that are asynchronous to vcpu\n\t * execution; mutex_lock() would break them.\n\t */\n\tr = kvm_arch_vcpu_async_ioctl(filp, ioctl, arg);\n\tif (r != -ENOIOCTLCMD)\n\t\treturn r;\n\n\tif (mutex_lock_killable(&vcpu->mutex))\n\t\treturn -EINTR;\n\tswitch (ioctl) {\n\tcase KVM_RUN: {\n\t\tstruct pid *oldpid;\n\t\tr = -EINVAL;\n\t\tif (arg)\n\t\t\tgoto out;\n\t\toldpid = rcu_access_pointer(vcpu->pid);\n\t\tif (unlikely(oldpid != task_pid(current))) {\n\t\t\t/* The thread running this VCPU changed. */\n\t\t\tstruct pid *newpid;\n\n\t\t\tr = kvm_arch_vcpu_run_pid_change(vcpu);\n\t\t\tif (r)\n\t\t\t\tbreak;\n\n\t\t\tnewpid = get_task_pid(current, PIDTYPE_PID);\n\t\t\trcu_assign_pointer(vcpu->pid, newpid);\n\t\t\tif (oldpid)\n\t\t\t\tsynchronize_rcu();\n\t\t\tput_pid(oldpid);\n\t\t}\n\t\tr = kvm_arch_vcpu_ioctl_run(vcpu);\n\t\ttrace_kvm_userspace_exit(vcpu->run->exit_reason, r);\n\t\tbreak;\n\t}\n\tcase KVM_GET_REGS: {\n\t\tstruct kvm_regs *kvm_regs;\n\n\t\tr = -ENOMEM;\n\t\tkvm_regs = kzalloc(sizeof(struct kvm_regs), GFP_KERNEL_ACCOUNT);\n\t\tif (!kvm_regs)\n\t\t\tgoto out;\n\t\tr = kvm_arch_vcpu_ioctl_get_regs(vcpu, kvm_regs);\n\t\tif (r)\n\t\t\tgoto out_free1;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, kvm_regs, sizeof(struct kvm_regs)))\n\t\t\tgoto out_free1;\n\t\tr = 0;\nout_free1:\n\t\tkfree(kvm_regs);\n\t\tbreak;\n\t}\n\tcase KVM_SET_REGS: {\n\t\tstruct kvm_regs *kvm_regs;\n\n\t\tkvm_regs = memdup_user(argp, sizeof(*kvm_regs));\n\t\tif (IS_ERR(kvm_regs)) {\n\t\t\tr = PTR_ERR(kvm_regs);\n\t\t\tgoto out;\n\t\t}\n\t\tr = kvm_arch_vcpu_ioctl_set_regs(vcpu, kvm_regs);\n\t\tkfree(kvm_regs);\n\t\tbreak;\n\t}\n\tcase KVM_GET_SREGS: {\n\t\tkvm_sregs = kzalloc(sizeof(struct kvm_sregs),\n\t\t\t\t    GFP_KERNEL_ACCOUNT);\n\t\tr = -ENOMEM;\n\t\tif (!kvm_sregs)\n\t\t\tgoto out;\n\t\tr = kvm_arch_vcpu_ioctl_get_sregs(vcpu, kvm_sregs);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, kvm_sregs, sizeof(struct kvm_sregs)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_SREGS: {\n\t\tkvm_sregs = memdup_user(argp, sizeof(*kvm_sregs));\n\t\tif (IS_ERR(kvm_sregs)) {\n\t\t\tr = PTR_ERR(kvm_sregs);\n\t\t\tkvm_sregs = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tr = kvm_arch_vcpu_ioctl_set_sregs(vcpu, kvm_sregs);\n\t\tbreak;\n\t}\n\tcase KVM_GET_MP_STATE: {\n\t\tstruct kvm_mp_state mp_state;\n\n\t\tr = kvm_arch_vcpu_ioctl_get_mpstate(vcpu, &mp_state);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &mp_state, sizeof(mp_state)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_MP_STATE: {\n\t\tstruct kvm_mp_state mp_state;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&mp_state, argp, sizeof(mp_state)))\n\t\t\tgoto out;\n\t\tr = kvm_arch_vcpu_ioctl_set_mpstate(vcpu, &mp_state);\n\t\tbreak;\n\t}\n\tcase KVM_TRANSLATE: {\n\t\tstruct kvm_translation tr;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&tr, argp, sizeof(tr)))\n\t\t\tgoto out;\n\t\tr = kvm_arch_vcpu_ioctl_translate(vcpu, &tr);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &tr, sizeof(tr)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_GUEST_DEBUG: {\n\t\tstruct kvm_guest_debug dbg;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&dbg, argp, sizeof(dbg)))\n\t\t\tgoto out;\n\t\tr = kvm_arch_vcpu_ioctl_set_guest_debug(vcpu, &dbg);\n\t\tbreak;\n\t}\n\tcase KVM_SET_SIGNAL_MASK: {\n\t\tstruct kvm_signal_mask __user *sigmask_arg = argp;\n\t\tstruct kvm_signal_mask kvm_sigmask;\n\t\tsigset_t sigset, *p;\n\n\t\tp = NULL;\n\t\tif (argp) {\n\t\t\tr = -EFAULT;\n\t\t\tif (copy_from_user(&kvm_sigmask, argp,\n\t\t\t\t\t   sizeof(kvm_sigmask)))\n\t\t\t\tgoto out;\n\t\t\tr = -EINVAL;\n\t\t\tif (kvm_sigmask.len != sizeof(sigset))\n\t\t\t\tgoto out;\n\t\t\tr = -EFAULT;\n\t\t\tif (copy_from_user(&sigset, sigmask_arg->sigset,\n\t\t\t\t\t   sizeof(sigset)))\n\t\t\t\tgoto out;\n\t\t\tp = &sigset;\n\t\t}\n\t\tr = kvm_vcpu_ioctl_set_sigmask(vcpu, p);\n\t\tbreak;\n\t}\n\tcase KVM_GET_FPU: {\n\t\tfpu = kzalloc(sizeof(struct kvm_fpu), GFP_KERNEL_ACCOUNT);\n\t\tr = -ENOMEM;\n\t\tif (!fpu)\n\t\t\tgoto out;\n\t\tr = kvm_arch_vcpu_ioctl_get_fpu(vcpu, fpu);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, fpu, sizeof(struct kvm_fpu)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_FPU: {\n\t\tfpu = memdup_user(argp, sizeof(*fpu));\n\t\tif (IS_ERR(fpu)) {\n\t\t\tr = PTR_ERR(fpu);\n\t\t\tfpu = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tr = kvm_arch_vcpu_ioctl_set_fpu(vcpu, fpu);\n\t\tbreak;\n\t}\n\tcase KVM_GET_STATS_FD: {\n\t\tr = kvm_vcpu_ioctl_get_stats_fd(vcpu);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tr = kvm_arch_vcpu_ioctl(filp, ioctl, arg);\n\t}\nout:\n\tmutex_unlock(&vcpu->mutex);\n\tkfree(fpu);\n\tkfree(kvm_sregs);\n\treturn r;\n}\n\n#ifdef CONFIG_KVM_COMPAT\nstatic long kvm_vcpu_compat_ioctl(struct file *filp,\n\t\t\t\t  unsigned int ioctl, unsigned long arg)\n{\n\tstruct kvm_vcpu *vcpu = filp->private_data;\n\tvoid __user *argp = compat_ptr(arg);\n\tint r;\n\n\tif (vcpu->kvm->mm != current->mm || vcpu->kvm->vm_dead)\n\t\treturn -EIO;\n\n\tswitch (ioctl) {\n\tcase KVM_SET_SIGNAL_MASK: {\n\t\tstruct kvm_signal_mask __user *sigmask_arg = argp;\n\t\tstruct kvm_signal_mask kvm_sigmask;\n\t\tsigset_t sigset;\n\n\t\tif (argp) {\n\t\t\tr = -EFAULT;\n\t\t\tif (copy_from_user(&kvm_sigmask, argp,\n\t\t\t\t\t   sizeof(kvm_sigmask)))\n\t\t\t\tgoto out;\n\t\t\tr = -EINVAL;\n\t\t\tif (kvm_sigmask.len != sizeof(compat_sigset_t))\n\t\t\t\tgoto out;\n\t\t\tr = -EFAULT;\n\t\t\tif (get_compat_sigset(&sigset,\n\t\t\t\t\t      (compat_sigset_t __user *)sigmask_arg->sigset))\n\t\t\t\tgoto out;\n\t\t\tr = kvm_vcpu_ioctl_set_sigmask(vcpu, &sigset);\n\t\t} else\n\t\t\tr = kvm_vcpu_ioctl_set_sigmask(vcpu, NULL);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tr = kvm_vcpu_ioctl(filp, ioctl, arg);\n\t}\n\nout:\n\treturn r;\n}\n#endif\n\nstatic int kvm_device_mmap(struct file *filp, struct vm_area_struct *vma)\n{\n\tstruct kvm_device *dev = filp->private_data;\n\n\tif (dev->ops->mmap)\n\t\treturn dev->ops->mmap(dev, vma);\n\n\treturn -ENODEV;\n}\n\nstatic int kvm_device_ioctl_attr(struct kvm_device *dev,\n\t\t\t\t int (*accessor)(struct kvm_device *dev,\n\t\t\t\t\t\t struct kvm_device_attr *attr),\n\t\t\t\t unsigned long arg)\n{\n\tstruct kvm_device_attr attr;\n\n\tif (!accessor)\n\t\treturn -EPERM;\n\n\tif (copy_from_user(&attr, (void __user *)arg, sizeof(attr)))\n\t\treturn -EFAULT;\n\n\treturn accessor(dev, &attr);\n}\n\nstatic long kvm_device_ioctl(struct file *filp, unsigned int ioctl,\n\t\t\t     unsigned long arg)\n{\n\tstruct kvm_device *dev = filp->private_data;\n\n\tif (dev->kvm->mm != current->mm || dev->kvm->vm_dead)\n\t\treturn -EIO;\n\n\tswitch (ioctl) {\n\tcase KVM_SET_DEVICE_ATTR:\n\t\treturn kvm_device_ioctl_attr(dev, dev->ops->set_attr, arg);\n\tcase KVM_GET_DEVICE_ATTR:\n\t\treturn kvm_device_ioctl_attr(dev, dev->ops->get_attr, arg);\n\tcase KVM_HAS_DEVICE_ATTR:\n\t\treturn kvm_device_ioctl_attr(dev, dev->ops->has_attr, arg);\n\tdefault:\n\t\tif (dev->ops->ioctl)\n\t\t\treturn dev->ops->ioctl(dev, ioctl, arg);\n\n\t\treturn -ENOTTY;\n\t}\n}\n\nstatic int kvm_device_release(struct inode *inode, struct file *filp)\n{\n\tstruct kvm_device *dev = filp->private_data;\n\tstruct kvm *kvm = dev->kvm;\n\n\tif (dev->ops->release) {\n\t\tmutex_lock(&kvm->lock);\n\t\tlist_del(&dev->vm_node);\n\t\tdev->ops->release(dev);\n\t\tmutex_unlock(&kvm->lock);\n\t}\n\n\tkvm_put_kvm(kvm);\n\treturn 0;\n}\n\nstatic const struct file_operations kvm_device_fops = {\n\t.unlocked_ioctl = kvm_device_ioctl,\n\t.release = kvm_device_release,\n\tKVM_COMPAT(kvm_device_ioctl),\n\t.mmap = kvm_device_mmap,\n};\n\nstruct kvm_device *kvm_device_from_filp(struct file *filp)\n{\n\tif (filp->f_op != &kvm_device_fops)\n\t\treturn NULL;\n\n\treturn filp->private_data;\n}\n\nstatic const struct kvm_device_ops *kvm_device_ops_table[KVM_DEV_TYPE_MAX] = {\n#ifdef CONFIG_KVM_MPIC\n\t[KVM_DEV_TYPE_FSL_MPIC_20]\t= &kvm_mpic_ops,\n\t[KVM_DEV_TYPE_FSL_MPIC_42]\t= &kvm_mpic_ops,\n#endif\n};\n\nint kvm_register_device_ops(const struct kvm_device_ops *ops, u32 type)\n{\n\tif (type >= ARRAY_SIZE(kvm_device_ops_table))\n\t\treturn -ENOSPC;\n\n\tif (kvm_device_ops_table[type] != NULL)\n\t\treturn -EEXIST;\n\n\tkvm_device_ops_table[type] = ops;\n\treturn 0;\n}\n\nvoid kvm_unregister_device_ops(u32 type)\n{\n\tif (kvm_device_ops_table[type] != NULL)\n\t\tkvm_device_ops_table[type] = NULL;\n}\n\nstatic int kvm_ioctl_create_device(struct kvm *kvm,\n\t\t\t\t   struct kvm_create_device *cd)\n{\n\tconst struct kvm_device_ops *ops = NULL;\n\tstruct kvm_device *dev;\n\tbool test = cd->flags & KVM_CREATE_DEVICE_TEST;\n\tint type;\n\tint ret;\n\n\tif (cd->type >= ARRAY_SIZE(kvm_device_ops_table))\n\t\treturn -ENODEV;\n\n\ttype = array_index_nospec(cd->type, ARRAY_SIZE(kvm_device_ops_table));\n\tops = kvm_device_ops_table[type];\n\tif (ops == NULL)\n\t\treturn -ENODEV;\n\n\tif (test)\n\t\treturn 0;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL_ACCOUNT);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdev->ops = ops;\n\tdev->kvm = kvm;\n\n\tmutex_lock(&kvm->lock);\n\tret = ops->create(dev, type);\n\tif (ret < 0) {\n\t\tmutex_unlock(&kvm->lock);\n\t\tkfree(dev);\n\t\treturn ret;\n\t}\n\tlist_add(&dev->vm_node, &kvm->devices);\n\tmutex_unlock(&kvm->lock);\n\n\tif (ops->init)\n\t\tops->init(dev);\n\n\tkvm_get_kvm(kvm);\n\tret = anon_inode_getfd(ops->name, &kvm_device_fops, dev, O_RDWR | O_CLOEXEC);\n\tif (ret < 0) {\n\t\tkvm_put_kvm_no_destroy(kvm);\n\t\tmutex_lock(&kvm->lock);\n\t\tlist_del(&dev->vm_node);\n\t\tmutex_unlock(&kvm->lock);\n\t\tops->destroy(dev);\n\t\treturn ret;\n\t}\n\n\tcd->fd = ret;\n\treturn 0;\n}\n\nstatic long kvm_vm_ioctl_check_extension_generic(struct kvm *kvm, long arg)\n{\n\tswitch (arg) {\n\tcase KVM_CAP_USER_MEMORY:\n\tcase KVM_CAP_DESTROY_MEMORY_REGION_WORKS:\n\tcase KVM_CAP_JOIN_MEMORY_REGIONS_WORKS:\n\tcase KVM_CAP_INTERNAL_ERROR_DATA:\n#ifdef CONFIG_HAVE_KVM_MSI\n\tcase KVM_CAP_SIGNAL_MSI:\n#endif\n#ifdef CONFIG_HAVE_KVM_IRQFD\n\tcase KVM_CAP_IRQFD:\n\tcase KVM_CAP_IRQFD_RESAMPLE:\n#endif\n\tcase KVM_CAP_IOEVENTFD_ANY_LENGTH:\n\tcase KVM_CAP_CHECK_EXTENSION_VM:\n\tcase KVM_CAP_ENABLE_CAP_VM:\n\tcase KVM_CAP_HALT_POLL:\n\t\treturn 1;\n#ifdef CONFIG_KVM_MMIO\n\tcase KVM_CAP_COALESCED_MMIO:\n\t\treturn KVM_COALESCED_MMIO_PAGE_OFFSET;\n\tcase KVM_CAP_COALESCED_PIO:\n\t\treturn 1;\n#endif\n#ifdef CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT\n\tcase KVM_CAP_MANUAL_DIRTY_LOG_PROTECT2:\n\t\treturn KVM_DIRTY_LOG_MANUAL_CAPS;\n#endif\n#ifdef CONFIG_HAVE_KVM_IRQ_ROUTING\n\tcase KVM_CAP_IRQ_ROUTING:\n\t\treturn KVM_MAX_IRQ_ROUTES;\n#endif\n#if KVM_ADDRESS_SPACE_NUM > 1\n\tcase KVM_CAP_MULTI_ADDRESS_SPACE:\n\t\treturn KVM_ADDRESS_SPACE_NUM;\n#endif\n\tcase KVM_CAP_NR_MEMSLOTS:\n\t\treturn KVM_USER_MEM_SLOTS;\n\tcase KVM_CAP_DIRTY_LOG_RING:\n#ifdef CONFIG_HAVE_KVM_DIRTY_RING\n\t\treturn KVM_DIRTY_RING_MAX_ENTRIES * sizeof(struct kvm_dirty_gfn);\n#else\n\t\treturn 0;\n#endif\n\tcase KVM_CAP_BINARY_STATS_FD:\n\t\treturn 1;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn kvm_vm_ioctl_check_extension(kvm, arg);\n}\n\nstatic int kvm_vm_ioctl_enable_dirty_log_ring(struct kvm *kvm, u32 size)\n{\n\tint r;\n\n\tif (!KVM_DIRTY_LOG_PAGE_OFFSET)\n\t\treturn -EINVAL;\n\n\t/* the size should be power of 2 */\n\tif (!size || (size & (size - 1)))\n\t\treturn -EINVAL;\n\n\t/* Should be bigger to keep the reserved entries, or a page */\n\tif (size < kvm_dirty_ring_get_rsvd_entries() *\n\t    sizeof(struct kvm_dirty_gfn) || size < PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tif (size > KVM_DIRTY_RING_MAX_ENTRIES *\n\t    sizeof(struct kvm_dirty_gfn))\n\t\treturn -E2BIG;\n\n\t/* We only allow it to set once */\n\tif (kvm->dirty_ring_size)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&kvm->lock);\n\n\tif (kvm->created_vcpus) {\n\t\t/* We don't allow to change this value after vcpu created */\n\t\tr = -EINVAL;\n\t} else {\n\t\tkvm->dirty_ring_size = size;\n\t\tr = 0;\n\t}\n\n\tmutex_unlock(&kvm->lock);\n\treturn r;\n}\n\nstatic int kvm_vm_ioctl_reset_dirty_pages(struct kvm *kvm)\n{\n\tunsigned long i;\n\tstruct kvm_vcpu *vcpu;\n\tint cleared = 0;\n\n\tif (!kvm->dirty_ring_size)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&kvm->slots_lock);\n\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tcleared += kvm_dirty_ring_reset(vcpu->kvm, &vcpu->dirty_ring);\n\n\tmutex_unlock(&kvm->slots_lock);\n\n\tif (cleared)\n\t\tkvm_flush_remote_tlbs(kvm);\n\n\treturn cleared;\n}\n\nint __attribute__((weak)) kvm_vm_ioctl_enable_cap(struct kvm *kvm,\n\t\t\t\t\t\t  struct kvm_enable_cap *cap)\n{\n\treturn -EINVAL;\n}\n\nstatic int kvm_vm_ioctl_enable_cap_generic(struct kvm *kvm,\n\t\t\t\t\t   struct kvm_enable_cap *cap)\n{\n\tswitch (cap->cap) {\n#ifdef CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT\n\tcase KVM_CAP_MANUAL_DIRTY_LOG_PROTECT2: {\n\t\tu64 allowed_options = KVM_DIRTY_LOG_MANUAL_PROTECT_ENABLE;\n\n\t\tif (cap->args[0] & KVM_DIRTY_LOG_MANUAL_PROTECT_ENABLE)\n\t\t\tallowed_options = KVM_DIRTY_LOG_MANUAL_CAPS;\n\n\t\tif (cap->flags || (cap->args[0] & ~allowed_options))\n\t\t\treturn -EINVAL;\n\t\tkvm->manual_dirty_log_protect = cap->args[0];\n\t\treturn 0;\n\t}\n#endif\n\tcase KVM_CAP_HALT_POLL: {\n\t\tif (cap->flags || cap->args[0] != (unsigned int)cap->args[0])\n\t\t\treturn -EINVAL;\n\n\t\tkvm->max_halt_poll_ns = cap->args[0];\n\t\treturn 0;\n\t}\n\tcase KVM_CAP_DIRTY_LOG_RING:\n\t\treturn kvm_vm_ioctl_enable_dirty_log_ring(kvm, cap->args[0]);\n\tdefault:\n\t\treturn kvm_vm_ioctl_enable_cap(kvm, cap);\n\t}\n}\n\nstatic ssize_t kvm_vm_stats_read(struct file *file, char __user *user_buffer,\n\t\t\t      size_t size, loff_t *offset)\n{\n\tstruct kvm *kvm = file->private_data;\n\n\treturn kvm_stats_read(kvm->stats_id, &kvm_vm_stats_header,\n\t\t\t\t&kvm_vm_stats_desc[0], &kvm->stat,\n\t\t\t\tsizeof(kvm->stat), user_buffer, size, offset);\n}\n\nstatic const struct file_operations kvm_vm_stats_fops = {\n\t.read = kvm_vm_stats_read,\n\t.llseek = noop_llseek,\n};\n\nstatic int kvm_vm_ioctl_get_stats_fd(struct kvm *kvm)\n{\n\tint fd;\n\tstruct file *file;\n\n\tfd = get_unused_fd_flags(O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn fd;\n\n\tfile = anon_inode_getfile(\"kvm-vm-stats\",\n\t\t\t&kvm_vm_stats_fops, kvm, O_RDONLY);\n\tif (IS_ERR(file)) {\n\t\tput_unused_fd(fd);\n\t\treturn PTR_ERR(file);\n\t}\n\tfile->f_mode |= FMODE_PREAD;\n\tfd_install(fd, file);\n\n\treturn fd;\n}\n\nstatic long kvm_vm_ioctl(struct file *filp,\n\t\t\t   unsigned int ioctl, unsigned long arg)\n{\n\tstruct kvm *kvm = filp->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tint r;\n\n\tif (kvm->mm != current->mm || kvm->vm_dead)\n\t\treturn -EIO;\n\tswitch (ioctl) {\n\tcase KVM_CREATE_VCPU:\n\t\tr = kvm_vm_ioctl_create_vcpu(kvm, arg);\n\t\tbreak;\n\tcase KVM_ENABLE_CAP: {\n\t\tstruct kvm_enable_cap cap;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&cap, argp, sizeof(cap)))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_enable_cap_generic(kvm, &cap);\n\t\tbreak;\n\t}\n\tcase KVM_SET_USER_MEMORY_REGION: {\n\t\tstruct kvm_userspace_memory_region kvm_userspace_mem;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&kvm_userspace_mem, argp,\n\t\t\t\t\t\tsizeof(kvm_userspace_mem)))\n\t\t\tgoto out;\n\n\t\tr = kvm_vm_ioctl_set_memory_region(kvm, &kvm_userspace_mem);\n\t\tbreak;\n\t}\n\tcase KVM_GET_DIRTY_LOG: {\n\t\tstruct kvm_dirty_log log;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&log, argp, sizeof(log)))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_get_dirty_log(kvm, &log);\n\t\tbreak;\n\t}\n#ifdef CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT\n\tcase KVM_CLEAR_DIRTY_LOG: {\n\t\tstruct kvm_clear_dirty_log log;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&log, argp, sizeof(log)))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_clear_dirty_log(kvm, &log);\n\t\tbreak;\n\t}\n#endif\n#ifdef CONFIG_KVM_MMIO\n\tcase KVM_REGISTER_COALESCED_MMIO: {\n\t\tstruct kvm_coalesced_mmio_zone zone;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&zone, argp, sizeof(zone)))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_register_coalesced_mmio(kvm, &zone);\n\t\tbreak;\n\t}\n\tcase KVM_UNREGISTER_COALESCED_MMIO: {\n\t\tstruct kvm_coalesced_mmio_zone zone;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&zone, argp, sizeof(zone)))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_unregister_coalesced_mmio(kvm, &zone);\n\t\tbreak;\n\t}\n#endif\n\tcase KVM_IRQFD: {\n\t\tstruct kvm_irqfd data;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&data, argp, sizeof(data)))\n\t\t\tgoto out;\n\t\tr = kvm_irqfd(kvm, &data);\n\t\tbreak;\n\t}\n\tcase KVM_IOEVENTFD: {\n\t\tstruct kvm_ioeventfd data;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&data, argp, sizeof(data)))\n\t\t\tgoto out;\n\t\tr = kvm_ioeventfd(kvm, &data);\n\t\tbreak;\n\t}\n#ifdef CONFIG_HAVE_KVM_MSI\n\tcase KVM_SIGNAL_MSI: {\n\t\tstruct kvm_msi msi;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&msi, argp, sizeof(msi)))\n\t\t\tgoto out;\n\t\tr = kvm_send_userspace_msi(kvm, &msi);\n\t\tbreak;\n\t}\n#endif\n#ifdef __KVM_HAVE_IRQ_LINE\n\tcase KVM_IRQ_LINE_STATUS:\n\tcase KVM_IRQ_LINE: {\n\t\tstruct kvm_irq_level irq_event;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&irq_event, argp, sizeof(irq_event)))\n\t\t\tgoto out;\n\n\t\tr = kvm_vm_ioctl_irq_line(kvm, &irq_event,\n\t\t\t\t\tioctl == KVM_IRQ_LINE_STATUS);\n\t\tif (r)\n\t\t\tgoto out;\n\n\t\tr = -EFAULT;\n\t\tif (ioctl == KVM_IRQ_LINE_STATUS) {\n\t\t\tif (copy_to_user(argp, &irq_event, sizeof(irq_event)))\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tr = 0;\n\t\tbreak;\n\t}\n#endif\n#ifdef CONFIG_HAVE_KVM_IRQ_ROUTING\n\tcase KVM_SET_GSI_ROUTING: {\n\t\tstruct kvm_irq_routing routing;\n\t\tstruct kvm_irq_routing __user *urouting;\n\t\tstruct kvm_irq_routing_entry *entries = NULL;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&routing, argp, sizeof(routing)))\n\t\t\tgoto out;\n\t\tr = -EINVAL;\n\t\tif (!kvm_arch_can_set_irq_routing(kvm))\n\t\t\tgoto out;\n\t\tif (routing.nr > KVM_MAX_IRQ_ROUTES)\n\t\t\tgoto out;\n\t\tif (routing.flags)\n\t\t\tgoto out;\n\t\tif (routing.nr) {\n\t\t\turouting = argp;\n\t\t\tentries = vmemdup_user(urouting->entries,\n\t\t\t\t\t       array_size(sizeof(*entries),\n\t\t\t\t\t\t\t  routing.nr));\n\t\t\tif (IS_ERR(entries)) {\n\t\t\t\tr = PTR_ERR(entries);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tr = kvm_set_irq_routing(kvm, entries, routing.nr,\n\t\t\t\t\trouting.flags);\n\t\tkvfree(entries);\n\t\tbreak;\n\t}\n#endif /* CONFIG_HAVE_KVM_IRQ_ROUTING */\n\tcase KVM_CREATE_DEVICE: {\n\t\tstruct kvm_create_device cd;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&cd, argp, sizeof(cd)))\n\t\t\tgoto out;\n\n\t\tr = kvm_ioctl_create_device(kvm, &cd);\n\t\tif (r)\n\t\t\tgoto out;\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &cd, sizeof(cd)))\n\t\t\tgoto out;\n\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_CHECK_EXTENSION:\n\t\tr = kvm_vm_ioctl_check_extension_generic(kvm, arg);\n\t\tbreak;\n\tcase KVM_RESET_DIRTY_RINGS:\n\t\tr = kvm_vm_ioctl_reset_dirty_pages(kvm);\n\t\tbreak;\n\tcase KVM_GET_STATS_FD:\n\t\tr = kvm_vm_ioctl_get_stats_fd(kvm);\n\t\tbreak;\n\tdefault:\n\t\tr = kvm_arch_vm_ioctl(filp, ioctl, arg);\n\t}\nout:\n\treturn r;\n}\n\n#ifdef CONFIG_KVM_COMPAT\nstruct compat_kvm_dirty_log {\n\t__u32 slot;\n\t__u32 padding1;\n\tunion {\n\t\tcompat_uptr_t dirty_bitmap; /* one bit per page */\n\t\t__u64 padding2;\n\t};\n};\n\nstruct compat_kvm_clear_dirty_log {\n\t__u32 slot;\n\t__u32 num_pages;\n\t__u64 first_page;\n\tunion {\n\t\tcompat_uptr_t dirty_bitmap; /* one bit per page */\n\t\t__u64 padding2;\n\t};\n};\n\nstatic long kvm_vm_compat_ioctl(struct file *filp,\n\t\t\t   unsigned int ioctl, unsigned long arg)\n{\n\tstruct kvm *kvm = filp->private_data;\n\tint r;\n\n\tif (kvm->mm != current->mm || kvm->vm_dead)\n\t\treturn -EIO;\n\tswitch (ioctl) {\n#ifdef CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT\n\tcase KVM_CLEAR_DIRTY_LOG: {\n\t\tstruct compat_kvm_clear_dirty_log compat_log;\n\t\tstruct kvm_clear_dirty_log log;\n\n\t\tif (copy_from_user(&compat_log, (void __user *)arg,\n\t\t\t\t   sizeof(compat_log)))\n\t\t\treturn -EFAULT;\n\t\tlog.slot\t = compat_log.slot;\n\t\tlog.num_pages\t = compat_log.num_pages;\n\t\tlog.first_page\t = compat_log.first_page;\n\t\tlog.padding2\t = compat_log.padding2;\n\t\tlog.dirty_bitmap = compat_ptr(compat_log.dirty_bitmap);\n\n\t\tr = kvm_vm_ioctl_clear_dirty_log(kvm, &log);\n\t\tbreak;\n\t}\n#endif\n\tcase KVM_GET_DIRTY_LOG: {\n\t\tstruct compat_kvm_dirty_log compat_log;\n\t\tstruct kvm_dirty_log log;\n\n\t\tif (copy_from_user(&compat_log, (void __user *)arg,\n\t\t\t\t   sizeof(compat_log)))\n\t\t\treturn -EFAULT;\n\t\tlog.slot\t = compat_log.slot;\n\t\tlog.padding1\t = compat_log.padding1;\n\t\tlog.padding2\t = compat_log.padding2;\n\t\tlog.dirty_bitmap = compat_ptr(compat_log.dirty_bitmap);\n\n\t\tr = kvm_vm_ioctl_get_dirty_log(kvm, &log);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tr = kvm_vm_ioctl(filp, ioctl, arg);\n\t}\n\treturn r;\n}\n#endif\n\nstatic const struct file_operations kvm_vm_fops = {\n\t.release        = kvm_vm_release,\n\t.unlocked_ioctl = kvm_vm_ioctl,\n\t.llseek\t\t= noop_llseek,\n\tKVM_COMPAT(kvm_vm_compat_ioctl),\n};\n\nbool file_is_kvm(struct file *file)\n{\n\treturn file && file->f_op == &kvm_vm_fops;\n}\nEXPORT_SYMBOL_GPL(file_is_kvm);\n\nstatic int kvm_dev_ioctl_create_vm(unsigned long type)\n{\n\tint r;\n\tstruct kvm *kvm;\n\tstruct file *file;\n\n\tkvm = kvm_create_vm(type);\n\tif (IS_ERR(kvm))\n\t\treturn PTR_ERR(kvm);\n#ifdef CONFIG_KVM_MMIO\n\tr = kvm_coalesced_mmio_init(kvm);\n\tif (r < 0)\n\t\tgoto put_kvm;\n#endif\n\tr = get_unused_fd_flags(O_CLOEXEC);\n\tif (r < 0)\n\t\tgoto put_kvm;\n\n\tsnprintf(kvm->stats_id, sizeof(kvm->stats_id),\n\t\t\t\"kvm-%d\", task_pid_nr(current));\n\n\tfile = anon_inode_getfile(\"kvm-vm\", &kvm_vm_fops, kvm, O_RDWR);\n\tif (IS_ERR(file)) {\n\t\tput_unused_fd(r);\n\t\tr = PTR_ERR(file);\n\t\tgoto put_kvm;\n\t}\n\n\t/*\n\t * Don't call kvm_put_kvm anymore at this point; file->f_op is\n\t * already set, with ->release() being kvm_vm_release().  In error\n\t * cases it will be called by the final fput(file) and will take\n\t * care of doing kvm_put_kvm(kvm).\n\t */\n\tif (kvm_create_vm_debugfs(kvm, r) < 0) {\n\t\tput_unused_fd(r);\n\t\tfput(file);\n\t\treturn -ENOMEM;\n\t}\n\tkvm_uevent_notify_change(KVM_EVENT_CREATE_VM, kvm);\n\n\tfd_install(r, file);\n\treturn r;\n\nput_kvm:\n\tkvm_put_kvm(kvm);\n\treturn r;\n}\n\nstatic long kvm_dev_ioctl(struct file *filp,\n\t\t\t  unsigned int ioctl, unsigned long arg)\n{\n\tlong r = -EINVAL;\n\n\tswitch (ioctl) {\n\tcase KVM_GET_API_VERSION:\n\t\tif (arg)\n\t\t\tgoto out;\n\t\tr = KVM_API_VERSION;\n\t\tbreak;\n\tcase KVM_CREATE_VM:\n\t\tr = kvm_dev_ioctl_create_vm(arg);\n\t\tbreak;\n\tcase KVM_CHECK_EXTENSION:\n\t\tr = kvm_vm_ioctl_check_extension_generic(NULL, arg);\n\t\tbreak;\n\tcase KVM_GET_VCPU_MMAP_SIZE:\n\t\tif (arg)\n\t\t\tgoto out;\n\t\tr = PAGE_SIZE;     /* struct kvm_run */\n#ifdef CONFIG_X86\n\t\tr += PAGE_SIZE;    /* pio data page */\n#endif\n#ifdef CONFIG_KVM_MMIO\n\t\tr += PAGE_SIZE;    /* coalesced mmio ring page */\n#endif\n\t\tbreak;\n\tcase KVM_TRACE_ENABLE:\n\tcase KVM_TRACE_PAUSE:\n\tcase KVM_TRACE_DISABLE:\n\t\tr = -EOPNOTSUPP;\n\t\tbreak;\n\tdefault:\n\t\treturn kvm_arch_dev_ioctl(filp, ioctl, arg);\n\t}\nout:\n\treturn r;\n}\n\nstatic struct file_operations kvm_chardev_ops = {\n\t.unlocked_ioctl = kvm_dev_ioctl,\n\t.llseek\t\t= noop_llseek,\n\tKVM_COMPAT(kvm_dev_ioctl),\n};\n\nstatic struct miscdevice kvm_dev = {\n\tKVM_MINOR,\n\t\"kvm\",\n\t&kvm_chardev_ops,\n};\n\nstatic void hardware_enable_nolock(void *junk)\n{\n\tint cpu = raw_smp_processor_id();\n\tint r;\n\n\tif (cpumask_test_cpu(cpu, cpus_hardware_enabled))\n\t\treturn;\n\n\tcpumask_set_cpu(cpu, cpus_hardware_enabled);\n\n\tr = kvm_arch_hardware_enable();\n\n\tif (r) {\n\t\tcpumask_clear_cpu(cpu, cpus_hardware_enabled);\n\t\tatomic_inc(&hardware_enable_failed);\n\t\tpr_info(\"kvm: enabling virtualization on CPU%d failed\\n\", cpu);\n\t}\n}\n\nstatic int kvm_starting_cpu(unsigned int cpu)\n{\n\traw_spin_lock(&kvm_count_lock);\n\tif (kvm_usage_count)\n\t\thardware_enable_nolock(NULL);\n\traw_spin_unlock(&kvm_count_lock);\n\treturn 0;\n}\n\nstatic void hardware_disable_nolock(void *junk)\n{\n\tint cpu = raw_smp_processor_id();\n\n\tif (!cpumask_test_cpu(cpu, cpus_hardware_enabled))\n\t\treturn;\n\tcpumask_clear_cpu(cpu, cpus_hardware_enabled);\n\tkvm_arch_hardware_disable();\n}\n\nstatic int kvm_dying_cpu(unsigned int cpu)\n{\n\traw_spin_lock(&kvm_count_lock);\n\tif (kvm_usage_count)\n\t\thardware_disable_nolock(NULL);\n\traw_spin_unlock(&kvm_count_lock);\n\treturn 0;\n}\n\nstatic void hardware_disable_all_nolock(void)\n{\n\tBUG_ON(!kvm_usage_count);\n\n\tkvm_usage_count--;\n\tif (!kvm_usage_count)\n\t\ton_each_cpu(hardware_disable_nolock, NULL, 1);\n}\n\nstatic void hardware_disable_all(void)\n{\n\traw_spin_lock(&kvm_count_lock);\n\thardware_disable_all_nolock();\n\traw_spin_unlock(&kvm_count_lock);\n}\n\nstatic int hardware_enable_all(void)\n{\n\tint r = 0;\n\n\traw_spin_lock(&kvm_count_lock);\n\n\tkvm_usage_count++;\n\tif (kvm_usage_count == 1) {\n\t\tatomic_set(&hardware_enable_failed, 0);\n\t\ton_each_cpu(hardware_enable_nolock, NULL, 1);\n\n\t\tif (atomic_read(&hardware_enable_failed)) {\n\t\t\thardware_disable_all_nolock();\n\t\t\tr = -EBUSY;\n\t\t}\n\t}\n\n\traw_spin_unlock(&kvm_count_lock);\n\n\treturn r;\n}\n\nstatic int kvm_reboot(struct notifier_block *notifier, unsigned long val,\n\t\t      void *v)\n{\n\t/*\n\t * Some (well, at least mine) BIOSes hang on reboot if\n\t * in vmx root mode.\n\t *\n\t * And Intel TXT required VMX off for all cpu when system shutdown.\n\t */\n\tpr_info(\"kvm: exiting hardware virtualization\\n\");\n\tkvm_rebooting = true;\n\ton_each_cpu(hardware_disable_nolock, NULL, 1);\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block kvm_reboot_notifier = {\n\t.notifier_call = kvm_reboot,\n\t.priority = 0,\n};\n\nstatic void kvm_io_bus_destroy(struct kvm_io_bus *bus)\n{\n\tint i;\n\n\tfor (i = 0; i < bus->dev_count; i++) {\n\t\tstruct kvm_io_device *pos = bus->range[i].dev;\n\n\t\tkvm_iodevice_destructor(pos);\n\t}\n\tkfree(bus);\n}\n\nstatic inline int kvm_io_bus_cmp(const struct kvm_io_range *r1,\n\t\t\t\t const struct kvm_io_range *r2)\n{\n\tgpa_t addr1 = r1->addr;\n\tgpa_t addr2 = r2->addr;\n\n\tif (addr1 < addr2)\n\t\treturn -1;\n\n\t/* If r2->len == 0, match the exact address.  If r2->len != 0,\n\t * accept any overlapping write.  Any order is acceptable for\n\t * overlapping ranges, because kvm_io_bus_get_first_dev ensures\n\t * we process all of them.\n\t */\n\tif (r2->len) {\n\t\taddr1 += r1->len;\n\t\taddr2 += r2->len;\n\t}\n\n\tif (addr1 > addr2)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int kvm_io_bus_sort_cmp(const void *p1, const void *p2)\n{\n\treturn kvm_io_bus_cmp(p1, p2);\n}\n\nstatic int kvm_io_bus_get_first_dev(struct kvm_io_bus *bus,\n\t\t\t     gpa_t addr, int len)\n{\n\tstruct kvm_io_range *range, key;\n\tint off;\n\n\tkey = (struct kvm_io_range) {\n\t\t.addr = addr,\n\t\t.len = len,\n\t};\n\n\trange = bsearch(&key, bus->range, bus->dev_count,\n\t\t\tsizeof(struct kvm_io_range), kvm_io_bus_sort_cmp);\n\tif (range == NULL)\n\t\treturn -ENOENT;\n\n\toff = range - bus->range;\n\n\twhile (off > 0 && kvm_io_bus_cmp(&key, &bus->range[off-1]) == 0)\n\t\toff--;\n\n\treturn off;\n}\n\nstatic int __kvm_io_bus_write(struct kvm_vcpu *vcpu, struct kvm_io_bus *bus,\n\t\t\t      struct kvm_io_range *range, const void *val)\n{\n\tint idx;\n\n\tidx = kvm_io_bus_get_first_dev(bus, range->addr, range->len);\n\tif (idx < 0)\n\t\treturn -EOPNOTSUPP;\n\n\twhile (idx < bus->dev_count &&\n\t\tkvm_io_bus_cmp(range, &bus->range[idx]) == 0) {\n\t\tif (!kvm_iodevice_write(vcpu, bus->range[idx].dev, range->addr,\n\t\t\t\t\trange->len, val))\n\t\t\treturn idx;\n\t\tidx++;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\n/* kvm_io_bus_write - called under kvm->slots_lock */\nint kvm_io_bus_write(struct kvm_vcpu *vcpu, enum kvm_bus bus_idx, gpa_t addr,\n\t\t     int len, const void *val)\n{\n\tstruct kvm_io_bus *bus;\n\tstruct kvm_io_range range;\n\tint r;\n\n\trange = (struct kvm_io_range) {\n\t\t.addr = addr,\n\t\t.len = len,\n\t};\n\n\tbus = srcu_dereference(vcpu->kvm->buses[bus_idx], &vcpu->kvm->srcu);\n\tif (!bus)\n\t\treturn -ENOMEM;\n\tr = __kvm_io_bus_write(vcpu, bus, &range, val);\n\treturn r < 0 ? r : 0;\n}\nEXPORT_SYMBOL_GPL(kvm_io_bus_write);\n\n/* kvm_io_bus_write_cookie - called under kvm->slots_lock */\nint kvm_io_bus_write_cookie(struct kvm_vcpu *vcpu, enum kvm_bus bus_idx,\n\t\t\t    gpa_t addr, int len, const void *val, long cookie)\n{\n\tstruct kvm_io_bus *bus;\n\tstruct kvm_io_range range;\n\n\trange = (struct kvm_io_range) {\n\t\t.addr = addr,\n\t\t.len = len,\n\t};\n\n\tbus = srcu_dereference(vcpu->kvm->buses[bus_idx], &vcpu->kvm->srcu);\n\tif (!bus)\n\t\treturn -ENOMEM;\n\n\t/* First try the device referenced by cookie. */\n\tif ((cookie >= 0) && (cookie < bus->dev_count) &&\n\t    (kvm_io_bus_cmp(&range, &bus->range[cookie]) == 0))\n\t\tif (!kvm_iodevice_write(vcpu, bus->range[cookie].dev, addr, len,\n\t\t\t\t\tval))\n\t\t\treturn cookie;\n\n\t/*\n\t * cookie contained garbage; fall back to search and return the\n\t * correct cookie value.\n\t */\n\treturn __kvm_io_bus_write(vcpu, bus, &range, val);\n}\n\nstatic int __kvm_io_bus_read(struct kvm_vcpu *vcpu, struct kvm_io_bus *bus,\n\t\t\t     struct kvm_io_range *range, void *val)\n{\n\tint idx;\n\n\tidx = kvm_io_bus_get_first_dev(bus, range->addr, range->len);\n\tif (idx < 0)\n\t\treturn -EOPNOTSUPP;\n\n\twhile (idx < bus->dev_count &&\n\t\tkvm_io_bus_cmp(range, &bus->range[idx]) == 0) {\n\t\tif (!kvm_iodevice_read(vcpu, bus->range[idx].dev, range->addr,\n\t\t\t\t       range->len, val))\n\t\t\treturn idx;\n\t\tidx++;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\n/* kvm_io_bus_read - called under kvm->slots_lock */\nint kvm_io_bus_read(struct kvm_vcpu *vcpu, enum kvm_bus bus_idx, gpa_t addr,\n\t\t    int len, void *val)\n{\n\tstruct kvm_io_bus *bus;\n\tstruct kvm_io_range range;\n\tint r;\n\n\trange = (struct kvm_io_range) {\n\t\t.addr = addr,\n\t\t.len = len,\n\t};\n\n\tbus = srcu_dereference(vcpu->kvm->buses[bus_idx], &vcpu->kvm->srcu);\n\tif (!bus)\n\t\treturn -ENOMEM;\n\tr = __kvm_io_bus_read(vcpu, bus, &range, val);\n\treturn r < 0 ? r : 0;\n}\n\n/* Caller must hold slots_lock. */\nint kvm_io_bus_register_dev(struct kvm *kvm, enum kvm_bus bus_idx, gpa_t addr,\n\t\t\t    int len, struct kvm_io_device *dev)\n{\n\tint i;\n\tstruct kvm_io_bus *new_bus, *bus;\n\tstruct kvm_io_range range;\n\n\tbus = kvm_get_bus(kvm, bus_idx);\n\tif (!bus)\n\t\treturn -ENOMEM;\n\n\t/* exclude ioeventfd which is limited by maximum fd */\n\tif (bus->dev_count - bus->ioeventfd_count > NR_IOBUS_DEVS - 1)\n\t\treturn -ENOSPC;\n\n\tnew_bus = kmalloc(struct_size(bus, range, bus->dev_count + 1),\n\t\t\t  GFP_KERNEL_ACCOUNT);\n\tif (!new_bus)\n\t\treturn -ENOMEM;\n\n\trange = (struct kvm_io_range) {\n\t\t.addr = addr,\n\t\t.len = len,\n\t\t.dev = dev,\n\t};\n\n\tfor (i = 0; i < bus->dev_count; i++)\n\t\tif (kvm_io_bus_cmp(&bus->range[i], &range) > 0)\n\t\t\tbreak;\n\n\tmemcpy(new_bus, bus, sizeof(*bus) + i * sizeof(struct kvm_io_range));\n\tnew_bus->dev_count++;\n\tnew_bus->range[i] = range;\n\tmemcpy(new_bus->range + i + 1, bus->range + i,\n\t\t(bus->dev_count - i) * sizeof(struct kvm_io_range));\n\trcu_assign_pointer(kvm->buses[bus_idx], new_bus);\n\tsynchronize_srcu_expedited(&kvm->srcu);\n\tkfree(bus);\n\n\treturn 0;\n}\n\nint kvm_io_bus_unregister_dev(struct kvm *kvm, enum kvm_bus bus_idx,\n\t\t\t      struct kvm_io_device *dev)\n{\n\tint i, j;\n\tstruct kvm_io_bus *new_bus, *bus;\n\n\tlockdep_assert_held(&kvm->slots_lock);\n\n\tbus = kvm_get_bus(kvm, bus_idx);\n\tif (!bus)\n\t\treturn 0;\n\n\tfor (i = 0; i < bus->dev_count; i++) {\n\t\tif (bus->range[i].dev == dev) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == bus->dev_count)\n\t\treturn 0;\n\n\tnew_bus = kmalloc(struct_size(bus, range, bus->dev_count - 1),\n\t\t\t  GFP_KERNEL_ACCOUNT);\n\tif (new_bus) {\n\t\tmemcpy(new_bus, bus, struct_size(bus, range, i));\n\t\tnew_bus->dev_count--;\n\t\tmemcpy(new_bus->range + i, bus->range + i + 1,\n\t\t\t\tflex_array_size(new_bus, range, new_bus->dev_count - i));\n\t}\n\n\trcu_assign_pointer(kvm->buses[bus_idx], new_bus);\n\tsynchronize_srcu_expedited(&kvm->srcu);\n\n\t/* Destroy the old bus _after_ installing the (null) bus. */\n\tif (!new_bus) {\n\t\tpr_err(\"kvm: failed to shrink bus, removing it completely\\n\");\n\t\tfor (j = 0; j < bus->dev_count; j++) {\n\t\t\tif (j == i)\n\t\t\t\tcontinue;\n\t\t\tkvm_iodevice_destructor(bus->range[j].dev);\n\t\t}\n\t}\n\n\tkfree(bus);\n\treturn new_bus ? 0 : -ENOMEM;\n}\n\nstruct kvm_io_device *kvm_io_bus_get_dev(struct kvm *kvm, enum kvm_bus bus_idx,\n\t\t\t\t\t gpa_t addr)\n{\n\tstruct kvm_io_bus *bus;\n\tint dev_idx, srcu_idx;\n\tstruct kvm_io_device *iodev = NULL;\n\n\tsrcu_idx = srcu_read_lock(&kvm->srcu);\n\n\tbus = srcu_dereference(kvm->buses[bus_idx], &kvm->srcu);\n\tif (!bus)\n\t\tgoto out_unlock;\n\n\tdev_idx = kvm_io_bus_get_first_dev(bus, addr, 1);\n\tif (dev_idx < 0)\n\t\tgoto out_unlock;\n\n\tiodev = bus->range[dev_idx].dev;\n\nout_unlock:\n\tsrcu_read_unlock(&kvm->srcu, srcu_idx);\n\n\treturn iodev;\n}\nEXPORT_SYMBOL_GPL(kvm_io_bus_get_dev);\n\nstatic int kvm_debugfs_open(struct inode *inode, struct file *file,\n\t\t\t   int (*get)(void *, u64 *), int (*set)(void *, u64),\n\t\t\t   const char *fmt)\n{\n\tstruct kvm_stat_data *stat_data = (struct kvm_stat_data *)\n\t\t\t\t\t  inode->i_private;\n\n\t/*\n\t * The debugfs files are a reference to the kvm struct which\n        * is still valid when kvm_destroy_vm is called.  kvm_get_kvm_safe\n        * avoids the race between open and the removal of the debugfs directory.\n\t */\n\tif (!kvm_get_kvm_safe(stat_data->kvm))\n\t\treturn -ENOENT;\n\n\tif (simple_attr_open(inode, file, get,\n\t\t    kvm_stats_debugfs_mode(stat_data->desc) & 0222\n\t\t    ? set : NULL,\n\t\t    fmt)) {\n\t\tkvm_put_kvm(stat_data->kvm);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int kvm_debugfs_release(struct inode *inode, struct file *file)\n{\n\tstruct kvm_stat_data *stat_data = (struct kvm_stat_data *)\n\t\t\t\t\t  inode->i_private;\n\n\tsimple_attr_release(inode, file);\n\tkvm_put_kvm(stat_data->kvm);\n\n\treturn 0;\n}\n\nstatic int kvm_get_stat_per_vm(struct kvm *kvm, size_t offset, u64 *val)\n{\n\t*val = *(u64 *)((void *)(&kvm->stat) + offset);\n\n\treturn 0;\n}\n\nstatic int kvm_clear_stat_per_vm(struct kvm *kvm, size_t offset)\n{\n\t*(u64 *)((void *)(&kvm->stat) + offset) = 0;\n\n\treturn 0;\n}\n\nstatic int kvm_get_stat_per_vcpu(struct kvm *kvm, size_t offset, u64 *val)\n{\n\tunsigned long i;\n\tstruct kvm_vcpu *vcpu;\n\n\t*val = 0;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\t*val += *(u64 *)((void *)(&vcpu->stat) + offset);\n\n\treturn 0;\n}\n\nstatic int kvm_clear_stat_per_vcpu(struct kvm *kvm, size_t offset)\n{\n\tunsigned long i;\n\tstruct kvm_vcpu *vcpu;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\t*(u64 *)((void *)(&vcpu->stat) + offset) = 0;\n\n\treturn 0;\n}\n\nstatic int kvm_stat_data_get(void *data, u64 *val)\n{\n\tint r = -EFAULT;\n\tstruct kvm_stat_data *stat_data = (struct kvm_stat_data *)data;\n\n\tswitch (stat_data->kind) {\n\tcase KVM_STAT_VM:\n\t\tr = kvm_get_stat_per_vm(stat_data->kvm,\n\t\t\t\t\tstat_data->desc->desc.offset, val);\n\t\tbreak;\n\tcase KVM_STAT_VCPU:\n\t\tr = kvm_get_stat_per_vcpu(stat_data->kvm,\n\t\t\t\t\t  stat_data->desc->desc.offset, val);\n\t\tbreak;\n\t}\n\n\treturn r;\n}\n\nstatic int kvm_stat_data_clear(void *data, u64 val)\n{\n\tint r = -EFAULT;\n\tstruct kvm_stat_data *stat_data = (struct kvm_stat_data *)data;\n\n\tif (val)\n\t\treturn -EINVAL;\n\n\tswitch (stat_data->kind) {\n\tcase KVM_STAT_VM:\n\t\tr = kvm_clear_stat_per_vm(stat_data->kvm,\n\t\t\t\t\t  stat_data->desc->desc.offset);\n\t\tbreak;\n\tcase KVM_STAT_VCPU:\n\t\tr = kvm_clear_stat_per_vcpu(stat_data->kvm,\n\t\t\t\t\t    stat_data->desc->desc.offset);\n\t\tbreak;\n\t}\n\n\treturn r;\n}\n\nstatic int kvm_stat_data_open(struct inode *inode, struct file *file)\n{\n\t__simple_attr_check_format(\"%llu\\n\", 0ull);\n\treturn kvm_debugfs_open(inode, file, kvm_stat_data_get,\n\t\t\t\tkvm_stat_data_clear, \"%llu\\n\");\n}\n\nstatic const struct file_operations stat_fops_per_vm = {\n\t.owner = THIS_MODULE,\n\t.open = kvm_stat_data_open,\n\t.release = kvm_debugfs_release,\n\t.read = simple_attr_read,\n\t.write = simple_attr_write,\n\t.llseek = no_llseek,\n};\n\nstatic int vm_stat_get(void *_offset, u64 *val)\n{\n\tunsigned offset = (long)_offset;\n\tstruct kvm *kvm;\n\tu64 tmp_val;\n\n\t*val = 0;\n\tmutex_lock(&kvm_lock);\n\tlist_for_each_entry(kvm, &vm_list, vm_list) {\n\t\tkvm_get_stat_per_vm(kvm, offset, &tmp_val);\n\t\t*val += tmp_val;\n\t}\n\tmutex_unlock(&kvm_lock);\n\treturn 0;\n}\n\nstatic int vm_stat_clear(void *_offset, u64 val)\n{\n\tunsigned offset = (long)_offset;\n\tstruct kvm *kvm;\n\n\tif (val)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&kvm_lock);\n\tlist_for_each_entry(kvm, &vm_list, vm_list) {\n\t\tkvm_clear_stat_per_vm(kvm, offset);\n\t}\n\tmutex_unlock(&kvm_lock);\n\n\treturn 0;\n}\n\nDEFINE_SIMPLE_ATTRIBUTE(vm_stat_fops, vm_stat_get, vm_stat_clear, \"%llu\\n\");\nDEFINE_SIMPLE_ATTRIBUTE(vm_stat_readonly_fops, vm_stat_get, NULL, \"%llu\\n\");\n\nstatic int vcpu_stat_get(void *_offset, u64 *val)\n{\n\tunsigned offset = (long)_offset;\n\tstruct kvm *kvm;\n\tu64 tmp_val;\n\n\t*val = 0;\n\tmutex_lock(&kvm_lock);\n\tlist_for_each_entry(kvm, &vm_list, vm_list) {\n\t\tkvm_get_stat_per_vcpu(kvm, offset, &tmp_val);\n\t\t*val += tmp_val;\n\t}\n\tmutex_unlock(&kvm_lock);\n\treturn 0;\n}\n\nstatic int vcpu_stat_clear(void *_offset, u64 val)\n{\n\tunsigned offset = (long)_offset;\n\tstruct kvm *kvm;\n\n\tif (val)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&kvm_lock);\n\tlist_for_each_entry(kvm, &vm_list, vm_list) {\n\t\tkvm_clear_stat_per_vcpu(kvm, offset);\n\t}\n\tmutex_unlock(&kvm_lock);\n\n\treturn 0;\n}\n\nDEFINE_SIMPLE_ATTRIBUTE(vcpu_stat_fops, vcpu_stat_get, vcpu_stat_clear,\n\t\t\t\"%llu\\n\");\nDEFINE_SIMPLE_ATTRIBUTE(vcpu_stat_readonly_fops, vcpu_stat_get, NULL, \"%llu\\n\");\n\nstatic void kvm_uevent_notify_change(unsigned int type, struct kvm *kvm)\n{\n\tstruct kobj_uevent_env *env;\n\tunsigned long long created, active;\n\n\tif (!kvm_dev.this_device || !kvm)\n\t\treturn;\n\n\tmutex_lock(&kvm_lock);\n\tif (type == KVM_EVENT_CREATE_VM) {\n\t\tkvm_createvm_count++;\n\t\tkvm_active_vms++;\n\t} else if (type == KVM_EVENT_DESTROY_VM) {\n\t\tkvm_active_vms--;\n\t}\n\tcreated = kvm_createvm_count;\n\tactive = kvm_active_vms;\n\tmutex_unlock(&kvm_lock);\n\n\tenv = kzalloc(sizeof(*env), GFP_KERNEL_ACCOUNT);\n\tif (!env)\n\t\treturn;\n\n\tadd_uevent_var(env, \"CREATED=%llu\", created);\n\tadd_uevent_var(env, \"COUNT=%llu\", active);\n\n\tif (type == KVM_EVENT_CREATE_VM) {\n\t\tadd_uevent_var(env, \"EVENT=create\");\n\t\tkvm->userspace_pid = task_pid_nr(current);\n\t} else if (type == KVM_EVENT_DESTROY_VM) {\n\t\tadd_uevent_var(env, \"EVENT=destroy\");\n\t}\n\tadd_uevent_var(env, \"PID=%d\", kvm->userspace_pid);\n\n\tif (kvm->debugfs_dentry) {\n\t\tchar *tmp, *p = kmalloc(PATH_MAX, GFP_KERNEL_ACCOUNT);\n\n\t\tif (p) {\n\t\t\ttmp = dentry_path_raw(kvm->debugfs_dentry, p, PATH_MAX);\n\t\t\tif (!IS_ERR(tmp))\n\t\t\t\tadd_uevent_var(env, \"STATS_PATH=%s\", tmp);\n\t\t\tkfree(p);\n\t\t}\n\t}\n\t/* no need for checks, since we are adding at most only 5 keys */\n\tenv->envp[env->envp_idx++] = NULL;\n\tkobject_uevent_env(&kvm_dev.this_device->kobj, KOBJ_CHANGE, env->envp);\n\tkfree(env);\n}\n\nstatic void kvm_init_debug(void)\n{\n\tconst struct file_operations *fops;\n\tconst struct _kvm_stats_desc *pdesc;\n\tint i;\n\n\tkvm_debugfs_dir = debugfs_create_dir(\"kvm\", NULL);\n\n\tfor (i = 0; i < kvm_vm_stats_header.num_desc; ++i) {\n\t\tpdesc = &kvm_vm_stats_desc[i];\n\t\tif (kvm_stats_debugfs_mode(pdesc) & 0222)\n\t\t\tfops = &vm_stat_fops;\n\t\telse\n\t\t\tfops = &vm_stat_readonly_fops;\n\t\tdebugfs_create_file(pdesc->name, kvm_stats_debugfs_mode(pdesc),\n\t\t\t\tkvm_debugfs_dir,\n\t\t\t\t(void *)(long)pdesc->desc.offset, fops);\n\t}\n\n\tfor (i = 0; i < kvm_vcpu_stats_header.num_desc; ++i) {\n\t\tpdesc = &kvm_vcpu_stats_desc[i];\n\t\tif (kvm_stats_debugfs_mode(pdesc) & 0222)\n\t\t\tfops = &vcpu_stat_fops;\n\t\telse\n\t\t\tfops = &vcpu_stat_readonly_fops;\n\t\tdebugfs_create_file(pdesc->name, kvm_stats_debugfs_mode(pdesc),\n\t\t\t\tkvm_debugfs_dir,\n\t\t\t\t(void *)(long)pdesc->desc.offset, fops);\n\t}\n}\n\nstatic int kvm_suspend(void)\n{\n\tif (kvm_usage_count)\n\t\thardware_disable_nolock(NULL);\n\treturn 0;\n}\n\nstatic void kvm_resume(void)\n{\n\tif (kvm_usage_count) {\n\t\tlockdep_assert_not_held(&kvm_count_lock);\n\t\thardware_enable_nolock(NULL);\n\t}\n}\n\nstatic struct syscore_ops kvm_syscore_ops = {\n\t.suspend = kvm_suspend,\n\t.resume = kvm_resume,\n};\n\nstatic inline\nstruct kvm_vcpu *preempt_notifier_to_vcpu(struct preempt_notifier *pn)\n{\n\treturn container_of(pn, struct kvm_vcpu, preempt_notifier);\n}\n\nstatic void kvm_sched_in(struct preempt_notifier *pn, int cpu)\n{\n\tstruct kvm_vcpu *vcpu = preempt_notifier_to_vcpu(pn);\n\n\tWRITE_ONCE(vcpu->preempted, false);\n\tWRITE_ONCE(vcpu->ready, false);\n\n\t__this_cpu_write(kvm_running_vcpu, vcpu);\n\tkvm_arch_sched_in(vcpu, cpu);\n\tkvm_arch_vcpu_load(vcpu, cpu);\n}\n\nstatic void kvm_sched_out(struct preempt_notifier *pn,\n\t\t\t  struct task_struct *next)\n{\n\tstruct kvm_vcpu *vcpu = preempt_notifier_to_vcpu(pn);\n\n\tif (current->on_rq) {\n\t\tWRITE_ONCE(vcpu->preempted, true);\n\t\tWRITE_ONCE(vcpu->ready, true);\n\t}\n\tkvm_arch_vcpu_put(vcpu);\n\t__this_cpu_write(kvm_running_vcpu, NULL);\n}\n\n/**\n * kvm_get_running_vcpu - get the vcpu running on the current CPU.\n *\n * We can disable preemption locally around accessing the per-CPU variable,\n * and use the resolved vcpu pointer after enabling preemption again,\n * because even if the current thread is migrated to another CPU, reading\n * the per-CPU value later will give us the same value as we update the\n * per-CPU variable in the preempt notifier handlers.\n */\nstruct kvm_vcpu *kvm_get_running_vcpu(void)\n{\n\tstruct kvm_vcpu *vcpu;\n\n\tpreempt_disable();\n\tvcpu = __this_cpu_read(kvm_running_vcpu);\n\tpreempt_enable();\n\n\treturn vcpu;\n}\nEXPORT_SYMBOL_GPL(kvm_get_running_vcpu);\n\n/**\n * kvm_get_running_vcpus - get the per-CPU array of currently running vcpus.\n */\nstruct kvm_vcpu * __percpu *kvm_get_running_vcpus(void)\n{\n        return &kvm_running_vcpu;\n}\n\n#ifdef CONFIG_GUEST_PERF_EVENTS\nstatic unsigned int kvm_guest_state(void)\n{\n\tstruct kvm_vcpu *vcpu = kvm_get_running_vcpu();\n\tunsigned int state;\n\n\tif (!kvm_arch_pmi_in_guest(vcpu))\n\t\treturn 0;\n\n\tstate = PERF_GUEST_ACTIVE;\n\tif (!kvm_arch_vcpu_in_kernel(vcpu))\n\t\tstate |= PERF_GUEST_USER;\n\n\treturn state;\n}\n\nstatic unsigned long kvm_guest_get_ip(void)\n{\n\tstruct kvm_vcpu *vcpu = kvm_get_running_vcpu();\n\n\t/* Retrieving the IP must be guarded by a call to kvm_guest_state(). */\n\tif (WARN_ON_ONCE(!kvm_arch_pmi_in_guest(vcpu)))\n\t\treturn 0;\n\n\treturn kvm_arch_vcpu_get_ip(vcpu);\n}\n\nstatic struct perf_guest_info_callbacks kvm_guest_cbs = {\n\t.state\t\t\t= kvm_guest_state,\n\t.get_ip\t\t\t= kvm_guest_get_ip,\n\t.handle_intel_pt_intr\t= NULL,\n};\n\nvoid kvm_register_perf_callbacks(unsigned int (*pt_intr_handler)(void))\n{\n\tkvm_guest_cbs.handle_intel_pt_intr = pt_intr_handler;\n\tperf_register_guest_info_callbacks(&kvm_guest_cbs);\n}\nvoid kvm_unregister_perf_callbacks(void)\n{\n\tperf_unregister_guest_info_callbacks(&kvm_guest_cbs);\n}\n#endif\n\nstruct kvm_cpu_compat_check {\n\tvoid *opaque;\n\tint *ret;\n};\n\nstatic void check_processor_compat(void *data)\n{\n\tstruct kvm_cpu_compat_check *c = data;\n\n\t*c->ret = kvm_arch_check_processor_compat(c->opaque);\n}\n\nint kvm_init(void *opaque, unsigned vcpu_size, unsigned vcpu_align,\n\t\t  struct module *module)\n{\n\tstruct kvm_cpu_compat_check c;\n\tint r;\n\tint cpu;\n\n\tr = kvm_arch_init(opaque);\n\tif (r)\n\t\tgoto out_fail;\n\n\t/*\n\t * kvm_arch_init makes sure there's at most one caller\n\t * for architectures that support multiple implementations,\n\t * like intel and amd on x86.\n\t * kvm_arch_init must be called before kvm_irqfd_init to avoid creating\n\t * conflicts in case kvm is already setup for another implementation.\n\t */\n\tr = kvm_irqfd_init();\n\tif (r)\n\t\tgoto out_irqfd;\n\n\tif (!zalloc_cpumask_var(&cpus_hardware_enabled, GFP_KERNEL)) {\n\t\tr = -ENOMEM;\n\t\tgoto out_free_0;\n\t}\n\n\tr = kvm_arch_hardware_setup(opaque);\n\tif (r < 0)\n\t\tgoto out_free_1;\n\n\tc.ret = &r;\n\tc.opaque = opaque;\n\tfor_each_online_cpu(cpu) {\n\t\tsmp_call_function_single(cpu, check_processor_compat, &c, 1);\n\t\tif (r < 0)\n\t\t\tgoto out_free_2;\n\t}\n\n\tr = cpuhp_setup_state_nocalls(CPUHP_AP_KVM_STARTING, \"kvm/cpu:starting\",\n\t\t\t\t      kvm_starting_cpu, kvm_dying_cpu);\n\tif (r)\n\t\tgoto out_free_2;\n\tregister_reboot_notifier(&kvm_reboot_notifier);\n\n\t/* A kmem cache lets us meet the alignment requirements of fx_save. */\n\tif (!vcpu_align)\n\t\tvcpu_align = __alignof__(struct kvm_vcpu);\n\tkvm_vcpu_cache =\n\t\tkmem_cache_create_usercopy(\"kvm_vcpu\", vcpu_size, vcpu_align,\n\t\t\t\t\t   SLAB_ACCOUNT,\n\t\t\t\t\t   offsetof(struct kvm_vcpu, arch),\n\t\t\t\t\t   offsetofend(struct kvm_vcpu, stats_id)\n\t\t\t\t\t   - offsetof(struct kvm_vcpu, arch),\n\t\t\t\t\t   NULL);\n\tif (!kvm_vcpu_cache) {\n\t\tr = -ENOMEM;\n\t\tgoto out_free_3;\n\t}\n\n\tfor_each_possible_cpu(cpu) {\n\t\tif (!alloc_cpumask_var_node(&per_cpu(cpu_kick_mask, cpu),\n\t\t\t\t\t    GFP_KERNEL, cpu_to_node(cpu))) {\n\t\t\tr = -ENOMEM;\n\t\t\tgoto out_free_4;\n\t\t}\n\t}\n\n\tr = kvm_async_pf_init();\n\tif (r)\n\t\tgoto out_free_5;\n\n\tkvm_chardev_ops.owner = module;\n\n\tr = misc_register(&kvm_dev);\n\tif (r) {\n\t\tpr_err(\"kvm: misc device register failed\\n\");\n\t\tgoto out_unreg;\n\t}\n\n\tregister_syscore_ops(&kvm_syscore_ops);\n\n\tkvm_preempt_ops.sched_in = kvm_sched_in;\n\tkvm_preempt_ops.sched_out = kvm_sched_out;\n\n\tkvm_init_debug();\n\n\tr = kvm_vfio_ops_init();\n\tWARN_ON(r);\n\n\treturn 0;\n\nout_unreg:\n\tkvm_async_pf_deinit();\nout_free_5:\n\tfor_each_possible_cpu(cpu)\n\t\tfree_cpumask_var(per_cpu(cpu_kick_mask, cpu));\nout_free_4:\n\tkmem_cache_destroy(kvm_vcpu_cache);\nout_free_3:\n\tunregister_reboot_notifier(&kvm_reboot_notifier);\n\tcpuhp_remove_state_nocalls(CPUHP_AP_KVM_STARTING);\nout_free_2:\n\tkvm_arch_hardware_unsetup();\nout_free_1:\n\tfree_cpumask_var(cpus_hardware_enabled);\nout_free_0:\n\tkvm_irqfd_exit();\nout_irqfd:\n\tkvm_arch_exit();\nout_fail:\n\treturn r;\n}\nEXPORT_SYMBOL_GPL(kvm_init);\n\nvoid kvm_exit(void)\n{\n\tint cpu;\n\n\tdebugfs_remove_recursive(kvm_debugfs_dir);\n\tmisc_deregister(&kvm_dev);\n\tfor_each_possible_cpu(cpu)\n\t\tfree_cpumask_var(per_cpu(cpu_kick_mask, cpu));\n\tkmem_cache_destroy(kvm_vcpu_cache);\n\tkvm_async_pf_deinit();\n\tunregister_syscore_ops(&kvm_syscore_ops);\n\tunregister_reboot_notifier(&kvm_reboot_notifier);\n\tcpuhp_remove_state_nocalls(CPUHP_AP_KVM_STARTING);\n\ton_each_cpu(hardware_disable_nolock, NULL, 1);\n\tkvm_arch_hardware_unsetup();\n\tkvm_arch_exit();\n\tkvm_irqfd_exit();\n\tfree_cpumask_var(cpus_hardware_enabled);\n\tkvm_vfio_ops_exit();\n}\nEXPORT_SYMBOL_GPL(kvm_exit);\n\nstruct kvm_vm_worker_thread_context {\n\tstruct kvm *kvm;\n\tstruct task_struct *parent;\n\tstruct completion init_done;\n\tkvm_vm_thread_fn_t thread_fn;\n\tuintptr_t data;\n\tint err;\n};\n\nstatic int kvm_vm_worker_thread(void *context)\n{\n\t/*\n\t * The init_context is allocated on the stack of the parent thread, so\n\t * we have to locally copy anything that is needed beyond initialization\n\t */\n\tstruct kvm_vm_worker_thread_context *init_context = context;\n\tstruct task_struct *parent;\n\tstruct kvm *kvm = init_context->kvm;\n\tkvm_vm_thread_fn_t thread_fn = init_context->thread_fn;\n\tuintptr_t data = init_context->data;\n\tint err;\n\n\terr = kthread_park(current);\n\t/* kthread_park(current) is never supposed to return an error */\n\tWARN_ON(err != 0);\n\tif (err)\n\t\tgoto init_complete;\n\n\terr = cgroup_attach_task_all(init_context->parent, current);\n\tif (err) {\n\t\tkvm_err(\"%s: cgroup_attach_task_all failed with err %d\\n\",\n\t\t\t__func__, err);\n\t\tgoto init_complete;\n\t}\n\n\tset_user_nice(current, task_nice(init_context->parent));\n\ninit_complete:\n\tinit_context->err = err;\n\tcomplete(&init_context->init_done);\n\tinit_context = NULL;\n\n\tif (err)\n\t\tgoto out;\n\n\t/* Wait to be woken up by the spawner before proceeding. */\n\tkthread_parkme();\n\n\tif (!kthread_should_stop())\n\t\terr = thread_fn(kvm, data);\n\nout:\n\t/*\n\t * Move kthread back to its original cgroup to prevent it lingering in\n\t * the cgroup of the VM process, after the latter finishes its\n\t * execution.\n\t *\n\t * kthread_stop() waits on the 'exited' completion condition which is\n\t * set in exit_mm(), via mm_release(), in do_exit(). However, the\n\t * kthread is removed from the cgroup in the cgroup_exit() which is\n\t * called after the exit_mm(). This causes the kthread_stop() to return\n\t * before the kthread actually quits the cgroup.\n\t */\n\trcu_read_lock();\n\tparent = rcu_dereference(current->real_parent);\n\tget_task_struct(parent);\n\trcu_read_unlock();\n\tcgroup_attach_task_all(parent, current);\n\tput_task_struct(parent);\n\n\treturn err;\n}\n\nint kvm_vm_create_worker_thread(struct kvm *kvm, kvm_vm_thread_fn_t thread_fn,\n\t\t\t\tuintptr_t data, const char *name,\n\t\t\t\tstruct task_struct **thread_ptr)\n{\n\tstruct kvm_vm_worker_thread_context init_context = {};\n\tstruct task_struct *thread;\n\n\t*thread_ptr = NULL;\n\tinit_context.kvm = kvm;\n\tinit_context.parent = current;\n\tinit_context.thread_fn = thread_fn;\n\tinit_context.data = data;\n\tinit_completion(&init_context.init_done);\n\n\tthread = kthread_run(kvm_vm_worker_thread, &init_context,\n\t\t\t     \"%s-%d\", name, task_pid_nr(current));\n\tif (IS_ERR(thread))\n\t\treturn PTR_ERR(thread);\n\n\t/* kthread_run is never supposed to return NULL */\n\tWARN_ON(thread == NULL);\n\n\twait_for_completion(&init_context.init_done);\n\n\tif (!init_context.err)\n\t\t*thread_ptr = thread;\n\n\treturn init_context.err;\n}\n"], "filenames": ["virt/kvm/kvm_main.c"], "buggy_code_start_loc": [436], "buggy_code_end_loc": [439], "fixing_code_start_loc": [437], "fixing_code_end_loc": [438], "type": "CWE-476", "message": "A NULL pointer dereference issue was found in KVM when releasing a vCPU with dirty ring support enabled. This flaw allows an unprivileged local attacker on the host to issue specific ioctl calls, causing a kernel oops condition that results in a denial of service.", "other": {"cve": {"id": "CVE-2022-1263", "sourceIdentifier": "secalert@redhat.com", "published": "2022-08-31T16:15:09.290", "lastModified": "2022-09-07T13:11:19.967", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A NULL pointer dereference issue was found in KVM when releasing a vCPU with dirty ring support enabled. This flaw allows an unprivileged local attacker on the host to issue specific ioctl calls, causing a kernel oops condition that results in a denial of service."}, {"lang": "es", "value": "Se encontr\u00f3 un problema de desreferencia de puntero NULL en KVM cuando es liberada una vCPU con el soporte de anillo sucio habilitado. Este fallo permite a un atacante local no privilegiado en el host emitir llamadas ioctl espec\u00edficas, causando una condici\u00f3n de oops en el kernel que resulta en una denegaci\u00f3n de servicio"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.18", "matchCriteriaId": "FE93544F-B946-47CF-9697-FBF3484FCB92"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.18:rc1:*:*:*:*:*:*", "matchCriteriaId": "6AD94161-84BB-42E6-9882-4FC0C42E9FC1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.18:rc2:*:*:*:*:*:*", "matchCriteriaId": "7AB06DDF-3C2B-416D-B448-E990D8FF67A9"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "7F6FB57C-2BC7-487C-96DD-132683AEB35D"}]}]}], "references": [{"url": "https://access.redhat.com/security/cve/CVE-2022-1263", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2072698", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/5593473a1e6c743764b08e3b6071cb43b5cfa6c4", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.openwall.com/lists/oss-security/2022/04/07/1", "source": "secalert@redhat.com", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/5593473a1e6c743764b08e3b6071cb43b5cfa6c4"}}