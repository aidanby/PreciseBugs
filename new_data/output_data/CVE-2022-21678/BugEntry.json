{"buggy_code": ["# frozen_string_literal: true\n\n# mixin for all Guardian methods dealing with user permissions\nmodule UserGuardian\n\n  def can_claim_reviewable_topic?(topic)\n    SiteSetting.reviewable_claiming != 'disabled' && can_review_topic?(topic)\n  end\n\n  def can_pick_avatar?(user_avatar, upload)\n    return false unless self.user\n    return true if is_admin?\n    # can always pick blank avatar\n    return true if !upload\n    return true if user_avatar.contains_upload?(upload.id)\n    return true if upload.user_id == user_avatar.user_id || upload.user_id == user.id\n\n    UserUpload.exists?(upload_id: upload.id, user_id: user.id)\n  end\n\n  def can_edit_user?(user)\n    is_me?(user) || is_staff?\n  end\n\n  def can_edit_username?(user)\n    return false if SiteSetting.auth_overrides_username?\n    return true if is_staff?\n    return false if SiteSetting.username_change_period <= 0\n    return false if is_anonymous?\n    is_me?(user) && ((user.post_count + user.topic_count) == 0 || user.created_at > SiteSetting.username_change_period.days.ago)\n  end\n\n  def can_edit_email?(user)\n    return false if SiteSetting.auth_overrides_email?\n    return false unless SiteSetting.email_editable?\n    return true if is_staff?\n    return false if is_anonymous?\n    can_edit?(user)\n  end\n\n  def can_edit_name?(user)\n    return false unless SiteSetting.enable_names?\n    return false if SiteSetting.auth_overrides_name?\n    return true if is_staff?\n    return false if is_anonymous?\n    can_edit?(user)\n  end\n\n  def can_see_notifications?(user)\n    is_me?(user) || is_admin?\n  end\n\n  def can_silence_user?(user)\n    user && is_staff? && not(user.staff?)\n  end\n\n  def can_unsilence_user?(user)\n    user && is_staff?\n  end\n\n  def can_delete_user?(user)\n    return false if user.nil? || user.admin?\n    if is_me?(user)\n      !SiteSetting.enable_discourse_connect &&\n      !user.has_more_posts_than?(SiteSetting.delete_user_self_max_post_count)\n    else\n      is_staff? && (\n        user.first_post_created_at.nil? ||\n          !user.has_more_posts_than?(User::MAX_STAFF_DELETE_POST_COUNT) ||\n          user.first_post_created_at > SiteSetting.delete_user_max_post_age.to_i.days.ago\n      )\n    end\n  end\n\n  def can_anonymize_user?(user)\n    is_staff? && !user.nil? && !user.staff?\n  end\n\n  def can_merge_user?(user)\n    is_admin? && !user.nil? && !user.staff?\n  end\n\n  def can_merge_users?(source_user, target_user)\n    can_merge_user?(source_user) && !target_user.nil?\n  end\n\n  def can_see_warnings?(user)\n    user && (is_me?(user) || is_staff?)\n  end\n\n  def can_reset_bounce_score?(user)\n    user && is_staff?\n  end\n\n  def can_check_emails?(user)\n    is_admin? || (is_staff? && SiteSetting.moderators_view_emails)\n  end\n\n  def can_check_sso_details?(user)\n    user && is_admin?\n  end\n\n  def restrict_user_fields?(user)\n    user.trust_level == TrustLevel[0] && anonymous?\n  end\n\n  def can_see_staff_info?(user)\n    user && is_staff?\n  end\n\n  def can_see_suspension_reason?(user)\n    return true unless SiteSetting.hide_suspension_reasons?\n    user == @user || is_staff?\n  end\n\n  def can_disable_second_factor?(user)\n    user && can_administer_user?(user)\n  end\n\n  def can_see_profile?(user)\n    return false if user.blank?\n    return true if !SiteSetting.allow_users_to_hide_profile?\n\n    # If a user has hidden their profile, restrict it to them and staff\n    if user.user_option.try(:hide_profile_and_presence?)\n      return is_me?(user) || is_staff?\n    end\n\n    true\n  end\n\n  def can_see_user_actions?(user, action_types)\n    return true if !@user.anonymous? && (@user.id == user.id || is_admin?)\n    (action_types & UserAction.private_types).empty?\n  end\n\n  def allowed_user_field_ids(user)\n    @allowed_user_field_ids ||= {}\n\n    is_staff_or_is_me = is_staff? || is_me?(user)\n    cache_key = is_staff_or_is_me ? :staff_or_me : :other\n\n    @allowed_user_field_ids[cache_key] ||=\n      begin\n        if is_staff_or_is_me\n          UserField.pluck(:id)\n        else\n          UserField.where(\"show_on_profile OR show_on_user_card\").pluck(:id)\n        end\n      end\n  end\n\n  def can_feature_topic?(user, topic)\n    return false if topic.nil?\n    return false if !SiteSetting.allow_featured_topic_on_user_profiles?\n    return false if !is_me?(user) && !is_staff?\n    return false if !topic.visible\n    return false if topic.read_restricted_category? || topic.private_message?\n    true\n  end\n\n  def can_see_review_queue?\n    is_staff? || (\n      SiteSetting.enable_category_group_moderation &&\n      Reviewable\n        .where(reviewable_by_group_id: @user.group_users.pluck(:group_id))\n        .where('category_id IS NULL or category_id IN (?)', allowed_category_ids)\n        .exists?\n    )\n  end\n\n  def can_see_summary_stats?(target_user)\n    true\n  end\n\n  def can_upload_profile_header?(user)\n    (is_me?(user) && user.has_trust_level?(SiteSetting.min_trust_level_to_allow_profile_background.to_i)) || is_staff?\n  end\n\n  def can_upload_user_card_background?(user)\n    (is_me?(user) && user.has_trust_level?(SiteSetting.min_trust_level_to_allow_user_card_background.to_i)) || is_staff?\n  end\n\n  def can_upload_external?\n    !ExternalUploadManager.user_banned?(user)\n  end\n\n  def can_delete_sso_record?(user)\n    SiteSetting.enable_discourse_connect && user && is_admin?\n  end\n\n  def can_change_tracking_preferences?(user)\n    (SiteSetting.allow_changing_staged_user_tracking || !user.staged) && can_edit_user?(user)\n  end\nend\n", "# frozen_string_literal: true\n\nrequire 'rails_helper'\nrequire 'rotp'\n\ndescribe UsersController do\n  fab!(:user) { Fabricate(:user) }\n  fab!(:user1) { Fabricate(:user) }\n  fab!(:another_user) { Fabricate(:user) }\n  fab!(:invitee) { Fabricate(:user) }\n  fab!(:inviter) { Fabricate(:user) }\n\n  fab!(:admin) { Fabricate(:admin) }\n  fab!(:moderator) { Fabricate(:moderator) }\n  fab!(:inactive_user) { Fabricate(:inactive_user) }\n\n  # Unfortunately, there are tests that depend on the user being created too\n  # late for fab! to work.\n  let(:user_deferred) { Fabricate(:user) }\n\n  describe \"#full account registration flow\" do\n    it \"will correctly handle honeypot and challenge\" do\n\n      get '/session/hp.json'\n      expect(response.status).to eq(200)\n\n      json = response.parsed_body\n\n      params = {\n        email: 'jane@jane.com',\n        name: 'jane',\n        username: 'jane',\n        password_confirmation: json['value'],\n        challenge: json['challenge'].reverse,\n        password: SecureRandom.hex\n      }\n\n      secure_session = SecureSession.new(session[\"secure_session_id\"])\n\n      expect(secure_session[UsersController::HONEYPOT_KEY]).to eq(json[\"value\"])\n      expect(secure_session[UsersController::CHALLENGE_KEY]).to eq(json[\"challenge\"])\n\n      post '/u.json', params: params\n\n      expect(response.status).to eq(200)\n\n      jane = User.find_by(username: 'jane')\n\n      expect(jane.email).to eq('jane@jane.com')\n\n      expect(secure_session[UsersController::HONEYPOT_KEY]).to eq(nil)\n      expect(secure_session[UsersController::CHALLENGE_KEY]).to eq(nil)\n    end\n  end\n\n  describe '#perform_account_activation' do\n    let(:email_token) { Fabricate(:email_token, user: user_deferred) }\n\n    before do\n      UsersController.any_instance.stubs(:honeypot_or_challenge_fails?).returns(false)\n    end\n\n    context 'invalid token' do\n      it 'return success' do\n        put \"/u/activate-account/invalid-tooken\"\n        expect(response.status).to eq(200)\n        expect(flash[:error]).to be_present\n      end\n    end\n\n    context 'valid token' do\n      context 'welcome message' do\n        it 'enqueues a welcome message if the user object indicates so' do\n          SiteSetting.send_welcome_message = true\n          user_deferred.update(active: false)\n          put \"/u/activate-account/#{email_token.token}\"\n          expect(response.status).to eq(200)\n          expect(Jobs::SendSystemMessage.jobs.size).to eq(1)\n          expect(Jobs::SendSystemMessage.jobs.first[\"args\"].first[\"message_type\"]).to eq(\"welcome_user\")\n        end\n\n        it \"doesn't enqueue the welcome message if the object returns false\" do\n          user_deferred.update(active: true)\n          put \"/u/activate-account/#{email_token.token}\"\n          expect(response.status).to eq(200)\n          expect(Jobs::SendSystemMessage.jobs.size).to eq(0)\n        end\n      end\n\n      context \"honeypot\" do\n        it \"raises an error if the honeypot is invalid\" do\n          UsersController.any_instance.stubs(:honeypot_or_challenge_fails?).returns(true)\n          put \"/u/activate-account/#{email_token.token}\"\n          expect(response.status).to eq(403)\n        end\n      end\n\n      context 'response' do\n        it 'correctly logs on user' do\n          email_token\n\n          events = DiscourseEvent.track_events do\n            put \"/u/activate-account/#{email_token.token}\"\n          end\n\n          expect(events.map { |event| event[:event_name] }).to contain_exactly(\n            :user_confirmed_email, :user_first_logged_in, :user_logged_in\n          )\n\n          expect(response.status).to eq(200)\n          expect(flash[:error]).to be_blank\n          expect(session[:current_user_id]).to be_present\n\n          expect(CGI.unescapeHTML(response.body))\n            .to_not include(I18n.t('activation.approval_required'))\n        end\n      end\n\n      context 'user is not approved' do\n        before do\n          SiteSetting.must_approve_users = true\n        end\n\n        it 'should return the right response' do\n          put \"/u/activate-account/#{email_token.token}\"\n          expect(response.status).to eq(200)\n\n          expect(CGI.unescapeHTML(response.body))\n            .to include(I18n.t('activation.approval_required'))\n\n          expect(response.body).to_not have_tag(:script, with: {\n            src: '/assets/application.js'\n          })\n\n          expect(flash[:error]).to be_blank\n          expect(session[:current_user_id]).to be_blank\n        end\n      end\n    end\n\n    context 'when cookies contains a destination URL' do\n      it 'should redirect to the URL' do\n        destination_url = 'http://thisisasite.com/somepath'\n        cookies[:destination_url] = destination_url\n\n        put \"/u/activate-account/#{email_token.token}\"\n\n        expect(response).to redirect_to(destination_url)\n      end\n    end\n  end\n\n  describe '#password_reset' do\n    let(:token) { SecureRandom.hex }\n\n    context \"you can view it even if login is required\" do\n      it \"returns success\" do\n        SiteSetting.login_required = true\n        get \"/u/password-reset/#{token}\"\n        expect(response.status).to eq(200)\n        expect(CGI.unescapeHTML(response.body)).to include(I18n.t('password_reset.no_token'))\n      end\n    end\n\n    context 'missing token' do\n      it 'disallows login' do\n        get \"/u/password-reset/#{token}\"\n\n        expect(response.status).to eq(200)\n\n        expect(CGI.unescapeHTML(response.body))\n          .to include(I18n.t('password_reset.no_token'))\n\n        expect(response.body).to_not have_tag(:script, with: {\n          src: '/assets/application.js'\n        })\n\n        expect(session[:current_user_id]).to be_blank\n      end\n\n      it \"responds with proper error message\" do\n        get \"/u/password-reset/#{token}.json\"\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"message\"]).to eq(I18n.t('password_reset.no_token'))\n        expect(session[:current_user_id]).to be_blank\n      end\n    end\n\n    context 'invalid token' do\n      it 'disallows login' do\n        get \"/u/password-reset/ev!l_trout@!\"\n\n        expect(response.status).to eq(200)\n\n        expect(CGI.unescapeHTML(response.body))\n          .to include(I18n.t('password_reset.no_token'))\n\n        expect(response.body).to_not have_tag(:script, with: {\n          src: '/assets/application.js'\n        })\n\n        expect(session[:current_user_id]).to be_blank\n      end\n\n      it \"responds with proper error message\" do\n        put \"/u/password-reset/evil_trout!.json\", params: { password: \"awesomeSecretPassword\" }\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"message\"]).to eq(I18n.t('password_reset.no_token'))\n        expect(session[:current_user_id]).to be_blank\n      end\n    end\n\n    context 'valid token' do\n      let!(:user_auth_token) { UserAuthToken.generate!(user_id: user1.id) }\n      let!(:email_token) { Fabricate(:email_token, user: user1, scope: EmailToken.scopes[:password_reset]) }\n\n      context 'when rendered' do\n        it 'renders referrer never on get requests' do\n          get \"/u/password-reset/#{email_token.token}\"\n          expect(response.status).to eq(200)\n          expect(response.body).to include('<meta name=\"referrer\" content=\"never\">')\n        end\n      end\n\n      it 'returns success' do\n        events = DiscourseEvent.track_events do\n          put \"/u/password-reset/#{email_token.token}\", params: { password: 'hg9ow8yhg98o' }\n        end\n\n        expect(events.map { |event| event[:event_name] }).to contain_exactly(\n          :user_logged_in, :user_first_logged_in, :user_confirmed_email\n        )\n\n        expect(response.status).to eq(200)\n        expect(response.body).to have_tag(\"div#data-preloaded\") do |element|\n          json = JSON.parse(element.current_scope.attribute('data-preloaded').value)\n          expect(json['password_reset']).to include('{\"is_developer\":false,\"admin\":false,\"second_factor_required\":false,\"security_key_required\":false,\"backup_enabled\":false,\"multiple_second_factor_methods\":false}')\n        end\n\n        expect(session[\"password-#{email_token.token}\"]).to be_blank\n        expect(UserAuthToken.where(id: user_auth_token.id).count).to eq(0)\n      end\n\n      it 'disallows double password reset' do\n        put \"/u/password-reset/#{email_token.token}\", params: { password: 'hg9ow8yHG32O' }\n        put \"/u/password-reset/#{email_token.token}\", params: { password: 'test123987AsdfXYZ' }\n        expect(user1.reload.confirm_password?('hg9ow8yHG32O')).to eq(true)\n        expect(user1.user_auth_tokens.count).to eq(1)\n      end\n\n      it \"doesn't redirect to wizard on get\" do\n        user1.update!(admin: true)\n\n        get \"/u/password-reset/#{email_token.token}.json\"\n        expect(response).not_to redirect_to(wizard_path)\n      end\n\n      it \"redirects to the wizard if you're the first admin\" do\n        user1.update!(admin: true)\n\n        get \"/u/password-reset/#{email_token.token}\"\n        put \"/u/password-reset/#{email_token.token}\", params: { password: 'hg9ow8yhg98oadminlonger' }\n        expect(response).to redirect_to(wizard_path)\n      end\n\n      it \"sets the users timezone if the param is present\" do\n        get \"/u/password-reset/#{email_token.token}\"\n        expect(user1.user_option.timezone).to eq(nil)\n\n        put \"/u/password-reset/#{email_token.token}\", params: { password: 'hg9ow8yhg98oadminlonger', timezone: \"America/Chicago\" }\n        expect(user1.user_option.reload.timezone).to eq(\"America/Chicago\")\n      end\n\n      it \"logs the password change\" do\n        get \"/u/password-reset/#{email_token.token}\"\n\n        expect do\n          put \"/u/password-reset/#{email_token.token}\", params: { password: 'hg9ow8yhg98oadminlonger' }\n        end.to change { UserHistory.count }.by (1)\n\n        user_history = UserHistory.last\n        expect(user_history.target_user_id).to eq(user1.id)\n        expect(user_history.action).to eq(UserHistory.actions[:change_password])\n      end\n\n      it \"doesn't invalidate the token when loading the page\" do\n        get \"/u/password-reset/#{email_token.token}.json\"\n        expect(response.status).to eq(200)\n        expect(email_token.reload.confirmed).to eq(false)\n        expect(UserAuthToken.where(id: user_auth_token.id).count).to eq(1)\n      end\n\n      context \"rate limiting\" do\n        before { RateLimiter.clear_all!; RateLimiter.enable }\n\n        it \"rate limits reset passwords\" do\n          freeze_time\n\n          6.times do\n            put \"/u/password-reset/#{email_token.token}\", params: {\n              second_factor_token: 123456,\n              second_factor_method: 1\n            }\n\n            expect(response.status).to eq(200)\n          end\n\n          put \"/u/password-reset/#{email_token.token}\", params: {\n            second_factor_token: 123456,\n            second_factor_method: 1\n          }\n\n          expect(response.status).to eq(429)\n        end\n\n        it \"rate limits reset passwords by username\" do\n          freeze_time\n\n          6.times do |x|\n            put \"/u/password-reset/#{email_token.token}\", params: {\n              second_factor_token: 123456,\n              second_factor_method: 1\n            }, env: { \"REMOTE_ADDR\": \"1.2.3.#{x}\" }\n\n            expect(response.status).to eq(200)\n          end\n\n          put \"/u/password-reset/#{email_token.token}\", params: {\n            second_factor_token: 123456,\n            second_factor_method: 1\n          }, env: { \"REMOTE_ADDR\": \"1.2.3.4\" }\n\n          expect(response.status).to eq(429)\n        end\n      end\n\n      context '2 factor authentication required' do\n        fab!(:second_factor) { Fabricate(:user_second_factor_totp, user: user1) }\n\n        it 'does not change with an invalid token' do\n          user1.user_auth_tokens.destroy_all\n\n          get \"/u/password-reset/#{email_token.token}\"\n\n          expect(response.body).to have_tag(\"div#data-preloaded\") do |element|\n            json = JSON.parse(element.current_scope.attribute('data-preloaded').value)\n            expect(json['password_reset']).to include('{\"is_developer\":false,\"admin\":false,\"second_factor_required\":true,\"security_key_required\":false,\"backup_enabled\":false,\"multiple_second_factor_methods\":false}')\n          end\n\n          put \"/u/password-reset/#{email_token.token}\", params: {\n            password: 'hg9ow8yHG32O',\n            second_factor_token: '000000',\n            second_factor_method: UserSecondFactor.methods[:totp]\n          }\n\n          expect(response.body).to include(I18n.t(\"login.invalid_second_factor_code\"))\n\n          user1.reload\n          expect(user1.confirm_password?('hg9ow8yHG32O')).not_to eq(true)\n          expect(user1.user_auth_tokens.count).not_to eq(1)\n        end\n\n        it 'changes password with valid 2-factor tokens' do\n          get \"/u/password-reset/#{email_token.token}\"\n\n          put \"/u/password-reset/#{email_token.token}\", params: {\n            password: 'hg9ow8yHG32O',\n            second_factor_token: ROTP::TOTP.new(second_factor.data).now,\n            second_factor_method: UserSecondFactor.methods[:totp]\n          }\n\n          user1.reload\n          expect(response.status).to eq(200)\n          expect(user1.confirm_password?('hg9ow8yHG32O')).to eq(true)\n          expect(user1.user_auth_tokens.count).to eq(1)\n        end\n      end\n\n      context 'security key authentication required' do\n        let!(:user_security_key) do\n          Fabricate(\n            :user_security_key,\n            user: user1,\n            credential_id: valid_security_key_data[:credential_id],\n            public_key: valid_security_key_data[:public_key]\n          )\n        end\n\n        before do\n          simulate_localhost_webauthn_challenge\n\n          # store challenge in secure session by visiting the email login page\n          get \"/u/password-reset/#{email_token.token}\"\n        end\n\n        it 'preloads with a security key challenge and allowed credential ids' do\n          expect(response.body).to have_tag(\"div#data-preloaded\") do |element|\n            json = JSON.parse(element.current_scope.attribute('data-preloaded').value)\n            password_reset = JSON.parse(json['password_reset'])\n            expect(password_reset['challenge']).not_to eq(nil)\n            expect(password_reset['allowed_credential_ids']).to eq([user_security_key.credential_id])\n            expect(password_reset['security_key_required']).to eq(true)\n          end\n        end\n\n        it 'stages a webauthn challenge and rp-id for the user' do\n          secure_session = SecureSession.new(session[\"secure_session_id\"])\n          expect(Webauthn.challenge(user1, secure_session)).not_to eq(nil)\n          expect(Webauthn.rp_id(user1, secure_session)).to eq(Discourse.current_hostname)\n        end\n\n        it 'changes password with valid security key challenge and authentication' do\n          put \"/u/password-reset/#{email_token.token}.json\", params: {\n            password: 'hg9ow8yHG32O',\n            second_factor_token: valid_security_key_auth_post_data,\n            second_factor_method: UserSecondFactor.methods[:security_key]\n          }\n\n          expect(response.status).to eq(200)\n          user1.reload\n          expect(user1.confirm_password?('hg9ow8yHG32O')).to eq(true)\n          expect(user1.user_auth_tokens.count).to eq(1)\n        end\n\n        it \"does not change a password if a fake TOTP token is provided\" do\n          put \"/u/password-reset/#{email_token.token}.json\", params: {\n            password: 'hg9ow8yHG32O',\n            second_factor_token: 'blah',\n            second_factor_method: UserSecondFactor.methods[:security_key]\n          }\n\n          expect(response.status).to eq(200)\n          expect(user1.reload.confirm_password?('hg9ow8yHG32O')).to eq(false)\n        end\n\n        context \"when security key authentication fails\" do\n          it 'shows an error message and does not change password' do\n            put \"/u/password-reset/#{email_token.token}\", params: {\n              password: 'hg9ow8yHG32O',\n              second_factor_token: {\n                signature: 'bad',\n                clientData: 'bad',\n                authenticatorData: 'bad',\n                credentialId: 'bad'\n              },\n              second_factor_method: UserSecondFactor.methods[:security_key]\n            }\n\n            expect(response.status).to eq(200)\n            expect(response.body).to include(I18n.t(\"webauthn.validation.not_found_error\"))\n            expect(user1.reload.confirm_password?('hg9ow8yHG32O')).to eq(false)\n          end\n        end\n      end\n    end\n\n    context 'submit change' do\n      let(:email_token) { Fabricate(:email_token, user: user1, scope: EmailToken.scopes[:password_reset]) }\n\n      it \"fails when the password is blank\" do\n        put \"/u/password-reset/#{email_token.token}.json\", params: { password: '' }\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"errors\"]).to be_present\n        expect(session[:current_user_id]).to be_blank\n      end\n\n      it \"fails when the password is too long\" do\n        put \"/u/password-reset/#{email_token.token}.json\", params: { password: ('x' * (User.max_password_length + 1)) }\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"errors\"]).to be_present\n        expect(session[:current_user_id]).to be_blank\n      end\n\n      it \"logs in the user\" do\n        put \"/u/password-reset/#{email_token.token}.json\", params: { password: 'ksjafh928r' }\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"errors\"]).to be_blank\n        expect(session[:current_user_id]).to be_present\n      end\n\n      it \"doesn't log in the user when not approved\" do\n        SiteSetting.must_approve_users = true\n        user1.update!(approved: false)\n\n        put \"/u/password-reset/#{email_token.token}.json\", params: { password: 'ksjafh928r' }\n        expect(response.parsed_body[\"errors\"]).to be_blank\n        expect(session[:current_user_id]).to be_blank\n      end\n    end\n  end\n\n  describe '#confirm_email_token' do\n    let!(:email_token) { Fabricate(:email_token, user: user1) }\n\n    it \"token doesn't match any records\" do\n      get \"/u/confirm-email-token/#{SecureRandom.hex}.json\"\n      expect(response.status).to eq(200)\n      expect(email_token.reload.confirmed).to eq(false)\n    end\n\n    it \"token matches\" do\n      get \"/u/confirm-email-token/#{email_token.token}.json\"\n      expect(response.status).to eq(200)\n      expect(email_token.reload.confirmed).to eq(true)\n    end\n  end\n\n  describe '#admin_login' do\n    context 'enqueues mail' do\n      it 'enqueues mail with admin email and sso enabled' do\n        put \"/u/admin-login\", params: { email: admin.email }\n        expect(response.status).to eq(200)\n        expect(Jobs::CriticalUserEmail.jobs.size).to eq(1)\n        args = Jobs::CriticalUserEmail.jobs.first[\"args\"].first\n        expect(args[\"user_id\"]).to eq(admin.id)\n      end\n    end\n\n    context 'when email is incorrect' do\n      it 'should return the right response' do\n        put \"/u/admin-login\", params: { email: 'random' }\n\n        expect(response.status).to eq(200)\n\n        response_body = response.body\n\n        expect(response_body).to match(I18n.t(\"admin_login.errors.unknown_email_address\"))\n        expect(response_body).to_not match(I18n.t(\"login.second_factor_description\"))\n      end\n    end\n  end\n\n  describe '#toggle_anon' do\n    it 'allows you to toggle anon if enabled' do\n      SiteSetting.allow_anonymous_posting = true\n\n      user = sign_in(Fabricate(:user))\n      user.trust_level = 1\n      user.save!\n\n      post \"/u/toggle-anon.json\"\n      expect(response.status).to eq(200)\n      expect(session[:current_user_id]).to eq(AnonymousShadowCreator.get(user).id)\n\n      post \"/u/toggle-anon.json\"\n      expect(response.status).to eq(200)\n      expect(session[:current_user_id]).to eq(user.id)\n    end\n  end\n\n  describe '#create' do\n    def honeypot_magic(params)\n      get '/session/hp.json'\n      json = response.parsed_body\n      params[:password_confirmation] = json[\"value\"]\n      params[:challenge] = json[\"challenge\"].reverse\n      params\n    end\n\n    before do\n      UsersController.any_instance.stubs(:honeypot_value).returns(nil)\n      UsersController.any_instance.stubs(:challenge_value).returns(nil)\n      SiteSetting.allow_new_registrations = true\n      @user = Fabricate.build(:user, email: \"foobar@example.com\", password: \"strongpassword\")\n    end\n\n    let(:post_user_params) do\n      { name: @user.name,\n        username: @user.username,\n        password: \"strongpassword\",\n        email: @user.email }\n    end\n\n    def post_user(extra_params = {})\n      post \"/u.json\", params: post_user_params.merge(extra_params)\n    end\n\n    context 'when email params is missing' do\n      it 'should raise the right error' do\n        post \"/u.json\", params: {\n          name: @user.name,\n          username: @user.username,\n          password: 'testing12352343'\n        }\n        expect(response.status).to eq(400)\n      end\n    end\n\n    context 'when creating a user' do\n      it 'sets the user locale to I18n.locale' do\n        SiteSetting.default_locale = 'en'\n        I18n.stubs(:locale).returns(:fr)\n        post_user\n        expect(User.find_by(username: @user.username).locale).to eq('fr')\n      end\n\n      it 'requires invite code when specified' do\n        expect(SiteSetting.require_invite_code).to eq(false)\n        SiteSetting.invite_code = \"abc def\"\n        expect(SiteSetting.require_invite_code).to eq(true)\n\n        post_user(invite_code: \"abcd\")\n        expect(response.status).to eq(200)\n        json = response.parsed_body\n        expect(json[\"success\"]).to eq(false)\n\n        # case insensitive and stripped of leading/ending spaces\n        post_user(invite_code: \" AbC deF \")\n        expect(response.status).to eq(200)\n        json = response.parsed_body\n        expect(json[\"success\"]).to eq(true)\n\n      end\n\n      context \"when timezone is provided as a guess on signup\" do\n\n        it \"sets the timezone\" do\n          post_user(timezone: \"Australia/Brisbane\")\n          expect(response.status).to eq(200)\n          expect(User.find_by(username: @user.username).user_option.timezone).to eq(\"Australia/Brisbane\")\n        end\n      end\n\n      context \"with local logins disabled\" do\n        before do\n          SiteSetting.enable_local_logins = false\n          SiteSetting.enable_google_oauth2_logins = true\n        end\n\n        it \"blocks registration without authenticator information\" do\n          post_user\n          expect(response.status).to eq(403)\n        end\n\n        it \"blocks with a regular api key\" do\n          api_key = Fabricate(:api_key, user: user1)\n          post \"/u.json\", params: post_user_params, headers: { HTTP_API_KEY: api_key.key }\n          expect(response.status).to eq(403)\n        end\n\n        it \"works with an admin api key\" do\n          api_key = Fabricate(:api_key, user: admin)\n          post \"/u.json\", params: post_user_params, headers: { HTTP_API_KEY: api_key.key }\n          expect(response.status).to eq(200)\n        end\n      end\n    end\n\n    context 'when creating a non active user (unconfirmed email)' do\n      it 'returns 403 forbidden when local logins are disabled' do\n        SiteSetting.enable_local_logins = false\n        post_user\n\n        expect(response.status).to eq(403)\n      end\n\n      it 'returns an error when new registrations are disabled' do\n        SiteSetting.allow_new_registrations = false\n\n        post_user\n        expect(response.status).to eq(200)\n\n        json = response.parsed_body\n        expect(json['success']).to eq(false)\n        expect(json['message']).to be_present\n      end\n\n      it 'creates a user correctly' do\n        post_user\n        expect(response.status).to eq(200)\n        expect(response.parsed_body['active']).to be_falsey\n\n        # should save user_created_message in session\n        expect(session[\"user_created_message\"]).to be_present\n        expect(session[SessionController::ACTIVATE_USER_KEY]).to be_present\n\n        expect(Jobs::SendSystemMessage.jobs.size).to eq(0)\n\n        expect(Jobs::CriticalUserEmail.jobs.size).to eq(1)\n        args = Jobs::CriticalUserEmail.jobs.first[\"args\"].first\n        expect(args[\"type\"]).to eq(\"signup\")\n      end\n\n      context \"`must approve users` site setting is enabled\" do\n        before { SiteSetting.must_approve_users = true }\n\n        it 'creates a user correctly' do\n          post_user\n          expect(response.status).to eq(200)\n\n          expect(response.parsed_body['active']).to be_falsey\n\n          # should save user_created_message in session\n          expect(session[\"user_created_message\"]).to be_present\n          expect(session[SessionController::ACTIVATE_USER_KEY]).to be_present\n\n          expect(Jobs::SendSystemMessage.jobs.size).to eq(0)\n\n          expect(Jobs::CriticalUserEmail.jobs.size).to eq(1)\n          args = Jobs::CriticalUserEmail.jobs.first[\"args\"].first\n          expect(args[\"type\"]).to eq(\"signup\")\n        end\n      end\n\n      context 'users already exists with given email' do\n        let!(:existing) { Fabricate(:user, email: post_user_params[:email]) }\n\n        it 'returns an error if hide_email_address_taken is disabled' do\n          SiteSetting.hide_email_address_taken = false\n\n          post_user\n          expect(response.status).to eq(200)\n\n          json = response.parsed_body\n          expect(json['success']).to eq(false)\n          expect(json['message']).to be_present\n        end\n\n        it 'returns success if hide_email_address_taken is enabled' do\n          SiteSetting.hide_email_address_taken = true\n          expect {\n            post_user\n          }.to_not change { User.count }\n\n          expect(response.status).to eq(200)\n          expect(session[\"user_created_message\"]).to be_present\n\n          json = response.parsed_body\n          expect(json['active']).to be_falsey\n          expect(json['message']).to eq(I18n.t(\"login.activate_email\", email: post_user_params[:email]))\n          expect(json['user_id']).not_to be_present\n\n          existing.destroy!\n          expect {\n            post_user\n          }.to change { User.count }\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n\n          expect(json['active']).to be_falsey\n          expect(json['message']).to eq(I18n.t(\"login.activate_email\", email: post_user_params[:email]))\n          expect(json['user_id']).not_to be_present\n        end\n      end\n    end\n\n    context \"creating as active\" do\n      it \"won't create the user as active\" do\n        post \"/u.json\", params: post_user_params.merge(active: true)\n        expect(response.status).to eq(200)\n        expect(response.parsed_body['active']).to be_falsey\n      end\n\n      context \"with a regular api key\" do\n        fab!(:api_key, refind: false) { Fabricate(:api_key, user: user1) }\n\n        it \"won't create the user as active with a regular key\" do\n          post \"/u.json\",\n            params: post_user_params.merge(active: true), headers: { HTTP_API_KEY: api_key.key }\n\n          expect(response.status).to eq(200)\n          expect(response.parsed_body['active']).to be_falsey\n        end\n      end\n\n      context \"with an admin api key\" do\n        fab!(:api_key, refind: false) { Fabricate(:api_key, user: admin) }\n\n        it \"creates the user as active with a an admin key\" do\n          SiteSetting.send_welcome_message = true\n          SiteSetting.must_approve_users = true\n\n          #Sidekiq::Client.expects(:enqueue).never\n          post \"/u.json\", params: post_user_params.merge(approved: true, active: true), headers: { HTTP_API_KEY: api_key.key }\n\n          expect(Jobs::CriticalUserEmail.jobs.size).to eq(0)\n          expect(Jobs::SendSystemMessage.jobs.size).to eq(0)\n\n          expect(response.status).to eq(200)\n          expect(response.parsed_body['active']).to be_truthy\n          new_user = User.find(response.parsed_body[\"user_id\"])\n          expect(new_user.active).to eq(true)\n          expect(new_user.approved).to eq(true)\n          expect(new_user.approved_by_id).to eq(admin.id)\n          expect(new_user.approved_at).to_not eq(nil)\n          expect(new_user.email_tokens.where(confirmed: true, email: new_user.email)).to exist\n        end\n\n        it \"will create a reviewable when a user is created as active but not approved\" do\n          Jobs.run_immediately!\n          SiteSetting.must_approve_users = true\n\n          post \"/u.json\", params: post_user_params.merge(active: true), headers: { HTTP_API_KEY: api_key.key }\n\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n\n          new_user = User.find(json[\"user_id\"])\n          expect(json['active']).to be_truthy\n          expect(new_user.approved).to eq(false)\n          expect(ReviewableUser.pending.find_by(target: new_user)).to be_present\n        end\n\n        it \"won't create a reviewable when a user is not active\" do\n          Jobs.run_immediately!\n          SiteSetting.must_approve_users = true\n\n          post \"/u.json\", params: post_user_params, headers: { HTTP_API_KEY: api_key.key }\n\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n\n          new_user = User.find(json[\"user_id\"])\n          expect(json['active']).to eq(false)\n          expect(new_user.approved).to eq(false)\n          expect(ReviewableUser.pending.find_by(target: new_user)).to be_blank\n        end\n\n        it \"won't create the developer as active\" do\n          UsernameCheckerService.expects(:is_developer?).returns(true)\n\n          post \"/u.json\", params: post_user_params.merge(active: true), headers: { HTTP_API_KEY: api_key.key }\n          expect(response.status).to eq(200)\n          expect(response.parsed_body['active']).to be_falsy\n        end\n\n        it \"won't set the new user's locale to the admin's locale\" do\n          SiteSetting.allow_user_locale = true\n          admin.update!(locale: :fr)\n\n          post \"/u.json\", params: post_user_params.merge(active: true), headers: { HTTP_API_KEY: api_key.key }\n          expect(response.status).to eq(200)\n\n          json = response.parsed_body\n          new_user = User.find(json[\"user_id\"])\n          expect(new_user.locale).not_to eq(\"fr\")\n        end\n\n        it \"will auto approve user if the user email domain matches auto_approve_email_domains setting\" do\n          Jobs.run_immediately!\n          SiteSetting.must_approve_users = true\n          SiteSetting.auto_approve_email_domains = \"example.com\"\n\n          post \"/u.json\", params: post_user_params.merge(active: true), headers: { HTTP_API_KEY: api_key.key }\n\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n\n          new_user = User.find(json[\"user_id\"])\n          expect(json['active']).to be_truthy\n          expect(new_user.approved).to be_truthy\n          expect(ReviewableUser.pending.find_by(target: new_user)).to be_blank\n        end\n      end\n    end\n\n    context \"creating as staged\" do\n      it \"won't create the user as staged\" do\n        post \"/u.json\", params: post_user_params.merge(staged: true)\n        expect(response.status).to eq(200)\n        new_user = User.where(username: post_user_params[:username]).first\n        expect(new_user.staged?).to eq(false)\n      end\n\n      context \"with a regular api key\" do\n        fab!(:api_key, refind: false) { Fabricate(:api_key, user: user1) }\n\n        it \"won't create the user as staged with a regular key\" do\n          post \"/u.json\", params: post_user_params.merge(staged: true), headers: { HTTP_API_KEY: api_key.key }\n          expect(response.status).to eq(200)\n\n          new_user = User.where(username: post_user_params[:username]).first\n          expect(new_user.staged?).to eq(false)\n        end\n      end\n\n      context \"with an admin api key\" do\n        fab!(:user) { admin }\n        fab!(:api_key, refind: false) { Fabricate(:api_key, user: user) }\n\n        it \"creates the user as staged with a regular key\" do\n          post \"/u.json\", params: post_user_params.merge(staged: true), headers: { HTTP_API_KEY: api_key.key }\n          expect(response.status).to eq(200)\n\n          new_user = User.where(username: post_user_params[:username]).first\n          expect(new_user.staged?).to eq(true)\n        end\n\n        it \"won't create the developer as staged\" do\n          UsernameCheckerService.expects(:is_developer?).returns(true)\n          post \"/u.json\", params: post_user_params.merge(staged: true), headers: { HTTP_API_KEY: api_key.key }\n          expect(response.status).to eq(200)\n\n          new_user = User.where(username: post_user_params[:username]).first\n          expect(new_user.staged?).to eq(false)\n        end\n      end\n    end\n\n    context 'when creating an active user (confirmed email)' do\n      before { User.any_instance.stubs(:active?).returns(true) }\n\n      it 'enqueues a welcome email' do\n        User.any_instance.expects(:enqueue_welcome_message).with('welcome_user')\n\n        post_user\n        expect(response.status).to eq(200)\n\n        # should save user_created_message in session\n        expect(session[\"user_created_message\"]).to be_present\n        expect(session[SessionController::ACTIVATE_USER_KEY]).to be_present\n      end\n\n      it \"shows the 'active' message\" do\n        User.any_instance.expects(:enqueue_welcome_message)\n        post_user\n        expect(response.status).to eq(200)\n        expect(response.parsed_body['message']).to eq(\n          I18n.t 'login.active'\n        )\n      end\n\n      it \"should be logged in\" do\n        User.any_instance.expects(:enqueue_welcome_message)\n        post_user\n        expect(response.status).to eq(200)\n        expect(session[:current_user_id]).to be_present\n      end\n\n      it 'indicates the user is active in the response' do\n        User.any_instance.expects(:enqueue_welcome_message)\n        post_user\n        expect(response.status).to eq(200)\n        expect(response.parsed_body['active']).to be_truthy\n      end\n\n      it 'doesn\\'t succeed when new registrations are disabled' do\n        SiteSetting.allow_new_registrations = false\n\n        post_user\n        expect(response.status).to eq(200)\n\n        json = response.parsed_body\n        expect(json['success']).to eq(false)\n        expect(json['message']).to be_present\n      end\n\n      context 'authentication records for' do\n        before do\n          OmniAuth.config.test_mode = true\n\n          OmniAuth.config.mock_auth[:twitter] = OmniAuth::AuthHash.new(\n            provider: 'twitter',\n            uid: '123545',\n            info: OmniAuth::AuthHash::InfoHash.new(\n              email: \"osama@mail.com\",\n              nickname: \"testosama\",\n              name: \"Osama Test\"\n            )\n          )\n\n          Rails.application.env_config[\"omniauth.auth\"] = OmniAuth.config.mock_auth[:twitter]\n          SiteSetting.enable_twitter_logins = true\n          get \"/auth/twitter/callback.json\"\n        end\n\n        after do\n          Rails.application.env_config[\"omniauth.auth\"] = OmniAuth.config.mock_auth[:twitter] = nil\n          OmniAuth.config.test_mode = false\n        end\n\n        it 'should create twitter user info if required' do\n          post \"/u.json\", params: {\n            name: \"Test Osama\",\n            username: \"testosama\",\n            password: \"strongpassword\",\n            email: \"osama@mail.com\"\n          }\n\n          expect(response.status).to eq(200)\n          expect(UserAssociatedAccount.where(provider_name: \"twitter\").count).to eq(1)\n        end\n\n        it \"returns an error when email has been changed from the validated email address\" do\n          post \"/u.json\", params: {\n            name: \"Test Osama\",\n            username: \"testosama\",\n            password: \"strongpassword\",\n            email: \"unvalidatedemail@mail.com\"\n          }\n\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n          expect(json['success']).to eq(false)\n          expect(json['message']).to be_present\n        end\n\n        it \"will create the user successfully if email validation is required\" do\n          post \"/u.json\", params: {\n            name: \"Test Osama\",\n            username: \"testosama\",\n            password: \"strongpassword\",\n            email: \"osama@mail.com\"\n          }\n\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n          expect(json['success']).to eq(true)\n        end\n\n        it \"doesn't use provided username/name if sso_overrides is enabled\" do\n          SiteSetting.auth_overrides_username = true\n          SiteSetting.auth_overrides_name = true\n          post \"/u.json\", params: {\n            username: \"attemptednewname\",\n            name: \"Attempt At New Name\",\n            password: \"strongpassword\",\n            email: \"osama@mail.com\"\n          }\n\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n          expect(json['success']).to eq(true)\n\n          user = User.last\n\n          expect(user.username).to eq('testosama')\n          expect(user.name).to eq('Osama Test')\n        end\n\n      end\n\n      context \"with no email in the auth payload\" do\n        before do\n          OmniAuth.config.test_mode = true\n          OmniAuth.config.mock_auth[:twitter] = OmniAuth::AuthHash.new(\n            provider: 'twitter',\n            uid: '123545',\n            info: OmniAuth::AuthHash::InfoHash.new(\n              nickname: \"testosama\",\n              name: \"Osama Test\"\n            )\n          )\n          Rails.application.env_config[\"omniauth.auth\"] = OmniAuth.config.mock_auth[:twitter]\n          SiteSetting.enable_twitter_logins = true\n          get \"/auth/twitter/callback.json\"\n        end\n\n        after do\n          Rails.application.env_config[\"omniauth.auth\"] = OmniAuth.config.mock_auth[:twitter] = nil\n          OmniAuth.config.test_mode = false\n        end\n\n        it \"will create the user successfully\" do\n          Rails.application.env_config[\"omniauth.auth\"].info.email = nil\n\n          post \"/u.json\", params: {\n            name: \"Test Osama\",\n            username: \"testosama\",\n            password: \"strongpassword\",\n            email: \"osama@mail.com\"\n          }\n\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n          expect(json['success']).to eq(true)\n        end\n      end\n    end\n\n    it \"creates user successfully but doesn't activate the account\" do\n      post_user\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"success\"]).to eq(true)\n      expect(User.find_by(username: @user.username).active).to eq(false)\n    end\n\n    shared_examples 'honeypot fails' do\n      it 'should not create a new user' do\n        User.any_instance.expects(:enqueue_welcome_message).never\n\n        expect {\n          post \"/u.json\", params: create_params\n        }.to_not change { User.count }\n\n        expect(response.status).to eq(200)\n\n        json = response.parsed_body\n        expect(json[\"success\"]).to eq(true)\n\n        # should not change the session\n        expect(session[\"user_created_message\"]).to be_blank\n        expect(session[SessionController::ACTIVATE_USER_KEY]).to be_blank\n      end\n    end\n\n    context 'when honeypot value is wrong' do\n      before do\n        UsersController.any_instance.stubs(:honeypot_value).returns('abc')\n      end\n      let(:create_params) { { name: @user.name, username: @user.username, password: \"strongpassword\", email: @user.email, password_confirmation: 'wrong' } }\n      include_examples 'honeypot fails'\n    end\n\n    context 'when challenge answer is wrong' do\n      before do\n        UsersController.any_instance.stubs(:challenge_value).returns('abc')\n      end\n      let(:create_params) { { name: @user.name, username: @user.username, password: \"strongpassword\", email: @user.email, challenge: 'abc' } }\n      include_examples 'honeypot fails'\n    end\n\n    context \"when 'invite only' setting is enabled\" do\n      before { SiteSetting.invite_only = true }\n\n      let(:create_params) { {\n        name: @user.name,\n        username: @user.username,\n        password: 'strongpassword',\n        email: @user.email\n      }}\n\n      include_examples 'honeypot fails'\n    end\n\n    shared_examples 'failed signup' do\n      it 'should not create a new User' do\n        expect { post \"/u.json\", params: create_params }.to_not change { User.count }\n        expect(response.status).to eq(200)\n      end\n\n      it 'should report failed' do\n        post \"/u.json\", params: create_params\n        json = response.parsed_body\n        expect(json[\"success\"]).not_to eq(true)\n\n        # should not change the session\n        expect(session[\"user_created_message\"]).to be_blank\n        expect(session[SessionController::ACTIVATE_USER_KEY]).to be_blank\n      end\n    end\n\n    context 'when password is blank' do\n      let(:create_params) { { name: @user.name, username: @user.username, password: \"\", email: @user.email } }\n      include_examples 'failed signup'\n    end\n\n    context 'when password is too long' do\n      let(:create_params) { { name: @user.name, username: @user.username, password: \"x\" * (User.max_password_length + 1), email: @user.email } }\n      include_examples 'failed signup'\n    end\n\n    context 'when password param is missing' do\n      let(:create_params) { { name: @user.name, username: @user.username, email: @user.email } }\n      include_examples 'failed signup'\n    end\n\n    context 'with a reserved username' do\n      let(:create_params) { { name: @user.name, username: 'Reserved', email: @user.email, password: 'strongpassword' } }\n      before { SiteSetting.reserved_usernames = 'a|reserved|b' }\n      include_examples 'failed signup'\n    end\n\n    context 'with a username that matches a user route' do\n      let(:create_params) { { name: @user.name, username: 'account-created', email: @user.email, password: 'strongpassword' } }\n      include_examples 'failed signup'\n    end\n\n    context 'with a missing username' do\n      let(:create_params) { { name: @user.name, email: @user.email, password: \"x\" * 20 } }\n\n      it 'should not create a new User' do\n        expect { post \"/u.json\", params: create_params }.to_not change { User.count }\n        expect(response.status).to eq(400)\n      end\n    end\n\n    context 'when an Exception is raised' do\n      before { User.any_instance.stubs(:save).raises(ActiveRecord::StatementInvalid.new('Oh no')) }\n\n      let(:create_params) {\n        { name: @user.name, username: @user.username,\n          password: \"strongpassword\", email: @user.email }\n      }\n\n      include_examples 'failed signup'\n    end\n\n    context \"with custom fields\" do\n      fab!(:user_field) { Fabricate(:user_field) }\n      fab!(:another_field) { Fabricate(:user_field) }\n      fab!(:optional_field) { Fabricate(:user_field, required: false) }\n\n      context \"without a value for the fields\" do\n        let(:create_params) { { name: @user.name, password: 'watwatwat', username: @user.username, email: @user.email } }\n        include_examples 'failed signup'\n      end\n\n      context \"with values for the fields\" do\n        let(:update_user_url) { \"/u/#{user1.username}.json\" }\n        let(:field_id) { user_field.id.to_s }\n\n        before { sign_in(user1) }\n\n        context \"with multple select fields\" do\n          let(:valid_options) { %w[Axe Sword] }\n\n          fab!(:user_field) do\n            Fabricate(:user_field, field_type: 'multiselect') do\n              user_field_options do\n                [\n                  Fabricate(:user_field_option, value: 'Axe'),\n                  Fabricate(:user_field_option, value: 'Sword')\n                ]\n              end\n            end\n          end\n\n          it \"should allow single values and not just arrays\" do\n            expect do\n              put update_user_url, params: { user_fields: { field_id => 'Axe' } }\n            end.to change { user1.reload.user_fields[field_id] }.from(nil).to('Axe')\n\n            expect do\n              put update_user_url, params: { user_fields: { field_id => %w[Axe Juice Sword] } }\n            end.to change { user1.reload.user_fields[field_id] }.from('Axe').to(%w[Axe Sword])\n          end\n\n          it \"shouldn't allow unregistered field values\" do\n            expect do\n              put update_user_url, params: { user_fields: { field_id => %w[Juice] } }\n            end.not_to change { user1.reload.user_fields[field_id] }\n          end\n\n          it \"should filter valid values\" do\n            expect do\n              put update_user_url, params: { user_fields: { field_id => %w[Axe Juice Sword] } }\n            end.to change { user1.reload.user_fields[field_id] }.from(nil).to(valid_options)\n          end\n\n          it \"allows registered field values\" do\n            expect do\n              put update_user_url, params: { user_fields: { field_id => valid_options } }\n            end.to change { user1.reload.user_fields[field_id] }.from(nil).to(valid_options)\n          end\n\n          it \"value can't be nil or empty if the field is required\" do\n            put update_user_url, params: { user_fields: { field_id => valid_options } }\n\n            user_field.update!(required: true)\n\n            expect do\n              put update_user_url, params: { user_fields: { field_id => nil } }\n            end.not_to change { user1.reload.user_fields[field_id] }\n\n            expect do\n              put update_user_url, params: { user_fields: { field_id => \"\" } }\n            end.not_to change { user1.reload.user_fields[field_id] }\n          end\n\n          it 'value can nil or empty if the field is not required' do\n            put update_user_url, params: { user_fields: { field_id => valid_options } }\n\n            user_field.update!(required: false)\n\n            expect do\n              put update_user_url, params: { user_fields: { field_id => nil } }\n            end.to change { user1.reload.user_fields[field_id] }.from(valid_options).to(nil)\n\n            expect do\n              put update_user_url, params: { user_fields: { field_id => \"\" } }\n            end.to change { user1.reload.user_fields[field_id] }.from(nil).to(\"\")\n          end\n\n        end\n\n        context \"with dropdown fields\" do\n          let(:valid_options) { ['Black Mesa', 'Fox Hound'] }\n\n          fab!(:user_field) do\n            Fabricate(:user_field, field_type: 'dropdown') do\n              user_field_options do\n                [\n                  Fabricate(:user_field_option, value: 'Black Mesa'),\n                  Fabricate(:user_field_option, value: 'Fox Hound')\n                ]\n              end\n            end\n          end\n\n          it \"shouldn't allow unregistered field values\" do\n            expect do\n              put update_user_url, params: { user_fields: { field_id => 'Umbrella Corporation' } }\n            end.not_to change { user1.reload.user_fields[field_id] }\n          end\n\n          it \"allows registered field values\" do\n            expect do\n              put update_user_url, params: { user_fields: { field_id => valid_options.first } }\n            end.to change { user1.reload.user_fields[field_id] }.from(nil).to(valid_options.first)\n          end\n\n          it \"value can't be nil if the field is required\" do\n            put update_user_url, params: { user_fields: { field_id => valid_options.first } }\n\n            user_field.update!(required: true)\n\n            expect do\n              put update_user_url, params: { user_fields: { field_id => nil } }\n            end.not_to change { user1.reload.user_fields[field_id] }\n          end\n\n          it 'value can be set to nil if the field is not required' do\n            put update_user_url, params: { user_fields: { field_id => valid_options.last } }\n\n            user_field.update!(required: false)\n\n            expect do\n              put update_user_url, params: { user_fields: { field_id => nil } }\n            end.to change { user1.reload.user_fields[field_id] }.from(valid_options.last).to(nil)\n          end\n        end\n\n        let(:create_params) { {\n          name: @user.name,\n          password: 'suChS3cuRi7y',\n          username: @user.username,\n          email: @user.email,\n          user_fields: {\n            user_field.id.to_s => 'value1',\n            another_field.id.to_s => 'value2',\n          }\n        } }\n\n        it \"should succeed without the optional field\" do\n          post \"/u.json\", params: create_params\n          expect(response.status).to eq(200)\n          inserted = User.find_by_email(@user.email)\n          expect(inserted).to be_present\n          expect(inserted.custom_fields).to be_present\n          expect(inserted.custom_fields[\"user_field_#{user_field.id}\"]).to eq('value1')\n          expect(inserted.custom_fields[\"user_field_#{another_field.id}\"]).to eq('value2')\n          expect(inserted.custom_fields[\"user_field_#{optional_field.id}\"]).to be_blank\n        end\n\n        it \"should succeed with the optional field\" do\n          create_params[:user_fields][optional_field.id.to_s] = 'value3'\n          post \"/u.json\", params: create_params.merge(create_params)\n          expect(response.status).to eq(200)\n          inserted = User.find_by_email(@user.email)\n          expect(inserted).to be_present\n          expect(inserted.custom_fields).to be_present\n          expect(inserted.custom_fields[\"user_field_#{user_field.id}\"]).to eq('value1')\n          expect(inserted.custom_fields[\"user_field_#{another_field.id}\"]).to eq('value2')\n          expect(inserted.custom_fields[\"user_field_#{optional_field.id}\"]).to eq('value3')\n        end\n\n        it \"trims excessively long fields\" do\n          create_params[:user_fields][optional_field.id.to_s] = ('x' * 3000)\n          post \"/u.json\", params: create_params.merge(create_params)\n          expect(response.status).to eq(200)\n          inserted = User.find_by_email(@user.email)\n\n          val = inserted.custom_fields[\"user_field_#{optional_field.id}\"]\n          expect(val.length).to eq(UserField.max_length)\n        end\n      end\n    end\n\n    context \"with only optional custom fields\" do\n      fab!(:user_field) { Fabricate(:user_field, required: false) }\n\n      context \"without values for the fields\" do\n        let(:create_params) { {\n          name: @user.name,\n          password: 'suChS3cuRi7y',\n          username: @user.username,\n          email: @user.email,\n        } }\n\n        it \"should succeed\" do\n          post \"/u.json\", params: create_params\n          expect(response.status).to eq(200)\n          inserted = User.find_by_email(@user.email)\n          expect(inserted).to be_present\n          expect(inserted.custom_fields).not_to be_present\n          expect(inserted.custom_fields[\"user_field_#{user_field.id}\"]).to be_blank\n        end\n      end\n    end\n\n    context \"when taking over a staged account\" do\n      before do\n        UsersController.any_instance.stubs(:honeypot_value).returns(\"abc\")\n        UsersController.any_instance.stubs(:challenge_value).returns(\"efg\")\n        SessionController.any_instance.stubs(:honeypot_value).returns(\"abc\")\n        SessionController.any_instance.stubs(:challenge_value).returns(\"efg\")\n      end\n\n      fab!(:staged) { Fabricate(:staged, email: \"staged@account.com\", active: true) }\n\n      it \"succeeds\" do\n        post '/u.json', params: honeypot_magic(\n          email: staged.email,\n          username: \"zogstrip\",\n          password: \"P4ssw0rd$$\"\n        )\n\n        expect(response.status).to eq(200)\n        result = response.parsed_body\n        expect(result[\"success\"]).to eq(true)\n\n        created_user = User.find_by_email(staged.email)\n        expect(created_user.staged).to eq(false)\n        expect(created_user.active).to eq(false)\n        expect(created_user.registration_ip_address).to be_present\n        expect(!!created_user.custom_fields[\"from_staged\"]).to eq(true)\n\n        # do not allow emails changes please\n\n        put \"/u/update-activation-email.json\", params: { email: 'bob@bob.com' }\n\n        created_user.reload\n        expect(created_user.email).to eq(\"staged@account.com\")\n        expect(response.status).to eq(403)\n      end\n    end\n  end\n\n  describe '#username' do\n    it 'raises an error when not logged in' do\n      put \"/u/somename/preferences/username.json\"\n      expect(response.status).to eq(403)\n    end\n\n    context 'while logged in' do\n      let(:old_username) { \"OrigUsername\" }\n      let(:new_username) { \"#{old_username}1234\" }\n      fab!(:user) { Fabricate(:user, username: \"OrigUsername\") }\n\n      before do\n        user.username = old_username\n        sign_in(user)\n      end\n\n      it 'raises an error without a new_username param' do\n        put \"/u/#{user.username}/preferences/username.json\", params: { username: user.username }\n        expect(response.status).to eq(400)\n        expect(user.reload.username).to eq(old_username)\n      end\n\n      it 'raises an error when you don\\'t have permission to change the username' do\n        Guardian.any_instance.expects(:can_edit_username?).with(user).returns(false)\n\n        put \"/u/#{user.username}/preferences/username.json\", params: { new_username: new_username }\n\n        expect(response).to be_forbidden\n        expect(user.reload.username).to eq(old_username)\n      end\n\n      it 'raises an error when change_username fails' do\n        put \"/u/#{user.username}/preferences/username.json\", params: { new_username: '@' }\n\n        expect(response.status).to eq(422)\n\n        body = response.parsed_body\n\n        expect(body['errors'].first).to include(I18n.t(\n          'user.username.short', min: User.username_length.begin\n        ))\n\n        expect(user.reload.username).to eq(old_username)\n      end\n\n      it 'should succeed in normal circumstances' do\n        put \"/u/#{user.username}/preferences/username.json\", params: { new_username: new_username }\n\n        expect(response.status).to eq(200)\n        expect(user.reload.username).to eq(new_username)\n      end\n\n      it 'raises an error when the username clashes with an existing user route' do\n        put \"/u/#{user.username}/preferences/username.json\", params: { new_username: 'account-created' }\n\n        body = response.parsed_body\n\n        expect(body['errors'].first).to include(I18n.t('login.reserved_username'))\n      end\n\n      it 'raises an error when the username is in the reserved list' do\n        SiteSetting.reserved_usernames = 'reserved'\n\n        put \"/u/#{user.username}/preferences/username.json\", params: { new_username: 'reserved' }\n        body = response.parsed_body\n\n        expect(body['errors'].first).to include(I18n.t('login.reserved_username'))\n      end\n\n      it 'should fail if the user is old' do\n        # Older than the change period and >1 post\n        user.created_at = Time.now - (SiteSetting.username_change_period + 1).days\n        PostCreator.new(user,\n          title: 'This is a test topic',\n          raw: 'This is a test this is a test'\n        ).create\n\n        put \"/u/#{user.username}/preferences/username.json\", params: { new_username: new_username }\n\n        expect(response).to be_forbidden\n        expect(user.reload.username).to eq(old_username)\n      end\n\n      it 'should create a staff action log when a staff member changes the username' do\n        acting_user = admin\n        sign_in(acting_user)\n\n        put \"/u/#{user.username}/preferences/username.json\", params: { new_username: new_username }\n\n        expect(response.status).to eq(200)\n        expect(UserHistory.where(action: UserHistory.actions[:change_username], target_user_id: user.id, acting_user_id: acting_user.id)).to be_present\n        expect(user.reload.username).to eq(new_username)\n      end\n\n      it 'should return a JSON response with the updated username' do\n        put \"/u/#{user.username}/preferences/username.json\", params: { new_username: new_username }\n\n        expect(response.parsed_body['username']).to eq(new_username)\n      end\n\n      it 'should respond with proper error message if auth_overrides_username is enabled' do\n        SiteSetting.discourse_connect_url = 'http://someurl.com'\n        SiteSetting.enable_discourse_connect = true\n        SiteSetting.auth_overrides_username = true\n        acting_user = admin\n        sign_in(acting_user)\n\n        put \"/u/#{user.username}/preferences/username.json\", params: { new_username: new_username }\n\n        expect(response.status).to eq(422)\n        expect(response.parsed_body['errors'].first).to include(I18n.t('errors.messages.auth_overrides_username'))\n      end\n    end\n  end\n\n  describe '#check_username' do\n    it 'raises an error without any parameters' do\n      get \"/u/check_username.json\"\n      expect(response.status).to eq(400)\n    end\n\n    shared_examples 'when username is unavailable' do\n      it 'should return available as false in the JSON and return a suggested username' do\n        expect(response.status).to eq(200)\n        expect(response.parsed_body['available']).to eq(false)\n        expect(response.parsed_body['suggestion']).to be_present\n      end\n    end\n\n    shared_examples 'when username is available' do\n      it 'should return available in the JSON' do\n        expect(response.status).to eq(200)\n        expect(response.parsed_body['available']).to eq(true)\n      end\n    end\n\n    it 'returns nothing when given an email param but no username' do\n      get \"/u/check_username.json\", params: { email: 'dood@example.com' }\n      expect(response.status).to eq(200)\n    end\n\n    context 'username is available' do\n      before do\n        get \"/u/check_username.json\", params: { username: 'BruceWayne' }\n      end\n      include_examples 'when username is available'\n    end\n\n    context 'username is unavailable' do\n      before do\n        get \"/u/check_username.json\", params: { username: user1.username }\n      end\n      include_examples 'when username is unavailable'\n    end\n\n    shared_examples 'checking an invalid username' do\n      it 'should not return an available key but should return an error message' do\n        expect(response.status).to eq(200)\n        expect(response.parsed_body['available']).to eq(nil)\n        expect(response.parsed_body['errors']).to be_present\n      end\n    end\n\n    context 'has invalid characters' do\n      before do\n        get \"/u/check_username.json\", params: { username: 'bad username' }\n      end\n      include_examples 'checking an invalid username'\n\n      it 'should return the invalid characters message' do\n        expect(response.status).to eq(200)\n        expect(response.parsed_body['errors']).to include(I18n.t(:'user.username.characters'))\n      end\n    end\n\n    context 'is too long' do\n      before do\n        get \"/u/check_username.json\", params: { username: generate_username(User.username_length.last + 1) }\n      end\n      include_examples 'checking an invalid username'\n\n      it 'should return the \"too long\" message' do\n        expect(response.status).to eq(200)\n        expect(response.parsed_body['errors']).to include(I18n.t(:'user.username.long', max: User.username_length.end))\n      end\n    end\n\n    describe 'different case of existing username' do\n      context \"it's my username\" do\n        fab!(:user) { Fabricate(:user, username: 'hansolo') }\n        before do\n          sign_in(user)\n\n          get \"/u/check_username.json\", params: { username: 'HanSolo' }\n        end\n        include_examples 'when username is available'\n      end\n\n      context \"it's someone else's username\" do\n        fab!(:user) { Fabricate(:user, username: 'hansolo') }\n        fab!(:someone_else) { Fabricate(:user) }\n        before do\n          sign_in(someone_else)\n\n          get \"/u/check_username.json\", params: { username: 'HanSolo' }\n        end\n        include_examples 'when username is unavailable'\n      end\n\n      context \"an admin changing it for someone else\" do\n        fab!(:user) { Fabricate(:user, username: 'hansolo') }\n        before do\n          sign_in(admin)\n\n          get \"/u/check_username.json\", params: { username: 'HanSolo', for_user_id: user.id }\n        end\n        include_examples 'when username is available'\n      end\n    end\n  end\n\n  describe '#check_email' do\n    it 'returns success if hide_email_address_taken is true' do\n      SiteSetting.hide_email_address_taken = true\n\n      get \"/u/check_email.json\", params: { email: user1.email }\n      expect(response.parsed_body[\"success\"]).to be_present\n    end\n\n    it 'returns success if email is empty' do\n      get \"/u/check_email.json\"\n      expect(response.parsed_body[\"success\"]).to be_present\n    end\n\n    it 'returns failure if email is not valid' do\n      get \"/u/check_email.json\", params: { email: \"invalid\" }\n      expect(response.parsed_body[\"failed\"]).to be_present\n    end\n\n    it 'returns failure if email exists' do\n      get \"/u/check_email.json\", params: { email: user1.email }\n      expect(response.parsed_body[\"failed\"]).to be_present\n\n      get \"/u/check_email.json\", params: { email: user1.email.upcase }\n      expect(response.parsed_body[\"failed\"]).to be_present\n    end\n\n    it 'returns success if email does not exists' do\n      get \"/u/check_email.json\", params: { email: \"available@example.com\" }\n      expect(response.parsed_body[\"success\"]).to be_present\n    end\n\n    it 'return success if user email is taken by staged user' do\n      get \"/u/check_email.json\", params: { email: Fabricate(:staged).email }\n      expect(response.parsed_body[\"success\"]).to be_present\n    end\n  end\n\n  describe '#invited' do\n    it 'fails for anonymous users' do\n      get \"/u/#{user1.username}/invited.json\", params: { username: user1.username }\n\n      expect(response.status).to eq(403)\n    end\n\n    it 'returns success' do\n      user = Fabricate(:user, trust_level: 2)\n      Fabricate(:invite, invited_by: user)\n\n      sign_in(user)\n      get \"/u/#{user.username}/invited.json\", params: { username: user.username }\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"counts\"][\"pending\"]).to eq(1)\n      expect(response.parsed_body[\"counts\"][\"total\"]).to eq(1)\n    end\n\n    it 'filters by all if viewing self' do\n      inviter = Fabricate(:user, trust_level: 2)\n      sign_in(inviter)\n\n      Fabricate(:invite, email: 'billybob@example.com', invited_by: inviter)\n      redeemed_invite = Fabricate(:invite, email: 'jimtom@example.com', invited_by: inviter)\n      Fabricate(:invited_user, invite: redeemed_invite, user: invitee)\n\n      get \"/u/#{inviter.username}/invited.json\", params: { filter: 'pending', search: 'billybob' }\n      expect(response.status).to eq(200)\n\n      invites = response.parsed_body['invites']\n      expect(invites.size).to eq(1)\n      expect(invites.first).to include('email' => 'billybob@example.com')\n\n      get \"/u/#{inviter.username}/invited.json\", params: { filter: 'redeemed', search: invitee.username }\n      expect(response.status).to eq(200)\n\n      invites = response.parsed_body['invites']\n      expect(invites.size).to eq(1)\n      expect(invites[0]['user']).to be_present\n    end\n\n    it \"doesn't filter by email if another regular user\" do\n      inviter = Fabricate(:user, trust_level: 2)\n      sign_in(Fabricate(:user, trust_level: 2))\n\n      Fabricate(:invite, email: 'billybob@example.com', invited_by: inviter)\n      redeemed_invite = Fabricate(:invite, email: 'jimtom@example.com', invited_by: inviter)\n      Fabricate(:invited_user, invite: redeemed_invite, user: invitee)\n\n      get \"/u/#{inviter.username}/invited.json\", params: { filter: 'pending', search: 'billybob' }\n      expect(response.status).to eq(200)\n\n      invites = response.parsed_body['invites']\n      expect(invites.size).to eq(0)\n\n      get \"/u/#{inviter.username}/invited.json\", params: { filter: 'redeemed', search: invitee.username }\n      expect(response.status).to eq(200)\n\n      invites = response.parsed_body['invites']\n      expect(invites.size).to eq(1)\n      expect(invites[0]['user']).to be_present\n    end\n\n    it \"filters by email if staff\" do\n      inviter = Fabricate(:user, trust_level: 2)\n      sign_in(moderator)\n\n      invite_1 = Fabricate(:invite, email: 'billybob@example.com', invited_by: inviter)\n      invitee_1 = Fabricate(:user)\n      Fabricate(:invited_user, invite: invite_1, user: invitee_1)\n      invite_2 = Fabricate(:invite, email: 'jimtom@example.com', invited_by: inviter)\n      invitee_2 = Fabricate(:user)\n      Fabricate(:invited_user, invite: invite_2, user: invitee_2)\n\n      get \"/u/#{inviter.username}/invited.json\", params: { search: 'billybob' }\n      expect(response.status).to eq(200)\n\n      invites = response.parsed_body['invites']\n      expect(invites.size).to eq(1)\n      expect(invites[0]['user']).to include('id' => invitee_1.id)\n    end\n\n    context 'with guest' do\n      context 'with pending invites' do\n        it 'does not return invites' do\n          Fabricate(:invite, invited_by: inviter)\n\n          get \"/u/#{user1.username}/invited/pending.json\"\n          expect(response.status).to eq(403)\n        end\n      end\n\n      context 'with redeemed invites' do\n        it 'returns invited_users' do\n          inviter = Fabricate(:user, trust_level: 2)\n          sign_in(inviter)\n          invite = Fabricate(:invite, invited_by: inviter)\n          invited_user = Fabricate(:invited_user, invite: invite, user: invitee)\n\n          get \"/u/#{inviter.username}/invited.json\"\n          expect(response.status).to eq(200)\n\n          invites = response.parsed_body['invites']\n          expect(invites.size).to eq(1)\n          expect(invites[0]).to include('id' => invite.id)\n        end\n      end\n    end\n\n    context 'with authenticated user' do\n      context 'with pending invites' do\n        context 'with permission to see pending invites' do\n          it 'returns invites' do\n            inviter = Fabricate(:user, trust_level: 2)\n            invite = Fabricate(:invite, invited_by: inviter)\n            sign_in(inviter)\n\n            get \"/u/#{inviter.username}/invited/pending.json\"\n            expect(response.status).to eq(200)\n\n            invites = response.parsed_body['invites']\n            expect(invites.size).to eq(1)\n            expect(invites.first).to include(\"email\" => invite.email)\n            expect(response.parsed_body['can_see_invite_details']).to eq(true)\n          end\n        end\n\n        context 'without permission to see pending invites' do\n          it 'does not return invites' do\n            user = sign_in(Fabricate(:user))\n            Fabricate(:invite, invited_by: inviter)\n            stub_guardian(user) do |guardian|\n              guardian.stubs(:can_see_invite_details?).\n                with(inviter).returns(false)\n            end\n\n            get \"/u/#{inviter.username}/invited/pending.json\"\n            expect(response.status).to eq(422)\n          end\n        end\n\n        context 'with permission to see invite links' do\n          it 'returns own invites' do\n            inviter = sign_in(Fabricate(:user, trust_level: 2))\n            invite = Fabricate(:invite, invited_by: inviter,  email: nil, max_redemptions_allowed: 5, expires_at: 1.month.from_now, emailed_status: Invite.emailed_status_types[:not_required])\n\n            get \"/u/#{inviter.username}/invited/pending.json\"\n            expect(response.status).to eq(200)\n\n            invites = response.parsed_body['invites']\n            expect(invites.size).to eq(1)\n            expect(invites.first).to include(\"id\" => invite.id)\n            expect(response.parsed_body['can_see_invite_details']).to eq(true)\n          end\n\n          it 'allows admin to see invites' do\n            inviter = Fabricate(:user, trust_level: 2)\n            admin = sign_in(Fabricate(:admin))\n            invite = Fabricate(:invite, invited_by: inviter,  email: nil, max_redemptions_allowed: 5, expires_at: 1.month.from_now, emailed_status: Invite.emailed_status_types[:not_required])\n\n            get \"/u/#{inviter.username}/invited/pending.json\"\n            expect(response.status).to eq(200)\n\n            invites = response.parsed_body['invites']\n            expect(invites.size).to eq(1)\n            expect(invites.first).to include(\"id\" => invite.id)\n            expect(response.parsed_body['can_see_invite_details']).to eq(true)\n          end\n        end\n\n        context 'without permission to see invite links' do\n          it 'does not return invites' do\n            user = Fabricate(:user, trust_level: 2)\n            inviter = admin\n            Fabricate(:invite, invited_by: inviter,  email: nil, max_redemptions_allowed: 5, expires_at: 1.month.from_now, emailed_status: Invite.emailed_status_types[:not_required])\n\n            get \"/u/#{inviter.username}/invited/pending.json\"\n            expect(response.status).to eq(403)\n          end\n        end\n      end\n\n      context 'with redeemed invites' do\n        it 'returns invites' do\n          sign_in(moderator)\n          invite = Fabricate(:invite, invited_by: inviter)\n          Fabricate(:invited_user, invite: invite, user: invitee)\n\n          get \"/u/#{inviter.username}/invited.json\"\n          expect(response.status).to eq(200)\n\n          invites = response.parsed_body['invites']\n          expect(invites.size).to eq(1)\n          expect(invites[0]).to include('id' => invite.id)\n        end\n      end\n    end\n  end\n\n  describe '#update' do\n    context 'with guest' do\n      it 'raises an error' do\n        put \"/u/guest.json\"\n        expect(response.status).to eq(403)\n      end\n    end\n\n    it \"does not allow name to be updated if auth auth_overrides_name is enabled\" do\n      SiteSetting.auth_overrides_name = true\n\n      sign_in(user1)\n\n      put \"/u/#{user1.username}\", params: { name: 'test.test' }\n\n      expect(response.status).to eq(200)\n      expect(user1.reload.name).to_not eq('test.test')\n    end\n\n    context \"when username contains a period\" do\n      before do\n        sign_in(user)\n      end\n\n      fab!(:user) { Fabricate(:user, username: 'test.test', name: \"Test User\") }\n\n      it \"should be able to update a user\" do\n        put \"/u/#{user.username}\", params: { name: 'test.test' }\n\n        expect(response.status).to eq(200)\n        expect(user.reload.name).to eq('test.test')\n      end\n    end\n\n    context \"as a staff user\" do\n      context \"uneditable field\" do\n        fab!(:user_field) { Fabricate(:user_field, editable: false) }\n\n        it \"allows staff to edit the field\" do\n          sign_in(admin)\n          put \"/u/#{user.username}.json\", params: {\n            name: 'Jim Tom',\n            title: \"foobar\",\n            user_fields: { user_field.id.to_s => 'happy' }\n          }\n\n          expect(response.status).to eq(200)\n\n          user.reload\n\n          expect(user.user_fields[user_field.id.to_s]).to eq('happy')\n          expect(user.title).to eq(\"foobar\")\n        end\n      end\n    end\n\n    context 'with authenticated user' do\n      context 'with permission to update' do\n        fab!(:upload) { Fabricate(:upload) }\n        fab!(:user) { Fabricate(:user) }\n\n        before do\n          sign_in(user)\n        end\n\n        it 'allows the update' do\n          SiteSetting.tagging_enabled = true\n          user2 = Fabricate(:user)\n          user3 = Fabricate(:user)\n          tags = [Fabricate(:tag), Fabricate(:tag)]\n          tag_synonym = Fabricate(:tag, target_tag: tags[1])\n\n          put \"/u/#{user.username}.json\", params: {\n            name: 'Jim Tom',\n            muted_usernames: \"#{user2.username},#{user3.username}\",\n            watched_tags: \"#{tags[0].name},#{tag_synonym.name}\",\n            card_background_upload_url: upload.url,\n            profile_background_upload_url: upload.url\n          }\n\n          expect(response.status).to eq(200)\n\n          user.reload\n\n          expect(user.name).to eq 'Jim Tom'\n          expect(user.muted_users.pluck(:username).sort).to eq [user2.username, user3.username].sort\n\n          expect(TagUser.where(\n            user: user,\n            notification_level: TagUser.notification_levels[:watching]\n          ).pluck(:tag_id)).to contain_exactly(tags[0].id, tags[1].id)\n\n          theme = Fabricate(:theme, user_selectable: true)\n\n          put \"/u/#{user.username}.json\", params: {\n            muted_usernames: \"\",\n            theme_ids: [theme.id],\n            email_level: UserOption.email_level_types[:always]\n          }\n\n          user.reload\n\n          expect(user.muted_users.pluck(:username).sort).to be_empty\n          expect(user.user_option.theme_ids).to eq([theme.id])\n          expect(user.user_option.email_level).to eq(UserOption.email_level_types[:always])\n          expect(user.profile_background_upload).to eq(upload)\n          expect(user.card_background_upload).to eq(upload)\n        end\n\n        context 'a locale is chosen that differs from I18n.locale' do\n          before do\n            SiteSetting.allow_user_locale = true\n          end\n\n          it \"updates the user's locale\" do\n            I18n.locale = :fr\n            put \"/u/#{user.username}.json\", params: { locale: :fa_IR }\n            expect(user.reload.locale).to eq('fa_IR')\n          end\n\n          it \"updates the title\" do\n            BadgeGranter.enable_queue\n            user.update!(locale: :fr)\n            user.change_trust_level!(TrustLevel[4])\n            BadgeGranter.process_queue!\n\n            leader_title = I18n.t(\"badges.leader.name\", locale: :fr)\n            put \"/u/#{user.username}.json\", params: { title: leader_title }\n            expect(user.reload.title).to eq(leader_title)\n          ensure\n            BadgeGranter.disable_queue\n            BadgeGranter.clear_queue!\n          end\n        end\n\n        context \"with user fields\" do\n          context \"an editable field\" do\n            fab!(:user_field) { Fabricate(:user_field) }\n            fab!(:optional_field) { Fabricate(:user_field, required: false) }\n\n            it \"should update the user field\" do\n              put \"/u/#{user.username}.json\", params: { name: 'Jim Tom', user_fields: { user_field.id.to_s => 'happy' } }\n\n              expect(response.status).to eq(200)\n              expect(user.user_fields[user_field.id.to_s]).to eq 'happy'\n            end\n\n            it \"cannot be updated to blank\" do\n              put \"/u/#{user.username}.json\", params: { name: 'Jim Tom', user_fields: { user_field.id.to_s => '' } }\n\n              expect(response.status).to eq(422)\n              expect(user.user_fields[user_field.id.to_s]).not_to eq('happy')\n            end\n\n            it \"trims excessively large fields\" do\n              put \"/u/#{user.username}.json\", params: { name: 'Jim Tom', user_fields: { user_field.id.to_s => ('x' * 3000) } }\n\n              expect(user.user_fields[user_field.id.to_s].size).to eq(UserField.max_length)\n            end\n\n            it \"should retain existing user fields\" do\n              put \"/u/#{user.username}.json\", params: { name: 'Jim Tom', user_fields: { user_field.id.to_s => 'happy', optional_field.id.to_s => 'feet' } }\n\n              expect(response.status).to eq(200)\n              expect(user.user_fields[user_field.id.to_s]).to eq('happy')\n              expect(user.user_fields[optional_field.id.to_s]).to eq('feet')\n\n              put \"/u/#{user.username}.json\", params: { name: 'Jim Tom', user_fields: { user_field.id.to_s => 'sad' } }\n\n              expect(response.status).to eq(200)\n\n              user.reload\n\n              expect(user.user_fields[user_field.id.to_s]).to eq('sad')\n              expect(user.user_fields[optional_field.id.to_s]).to eq('feet')\n            end\n          end\n\n          context \"with user_notification_schedule attributes\" do\n            it \"updates the user's notification schedule\" do\n              params = {\n                user_notification_schedule: {\n                  enabled: true,\n                  day_0_start_time: 30,\n                  day_0_end_time: 60,\n                  day_1_start_time: 30,\n                  day_1_end_time: 60,\n                  day_2_start_time: 30,\n                  day_2_end_time: 60,\n                  day_3_start_time: 30,\n                  day_3_end_time: 60,\n                  day_4_start_time: 30,\n                  day_4_end_time: 60,\n                  day_5_start_time: 30,\n                  day_5_end_time: 60,\n                  day_6_start_time: 30,\n                  day_6_end_time: 60,\n                }\n              }\n              put \"/u/#{user.username}.json\", params: params\n\n              user.reload\n              expect(user.user_notification_schedule.enabled).to eq(true)\n              expect(user.user_notification_schedule.day_0_start_time).to eq(30)\n              expect(user.user_notification_schedule.day_0_end_time).to eq(60)\n              expect(user.user_notification_schedule.day_6_start_time).to eq(30)\n              expect(user.user_notification_schedule.day_6_end_time).to eq(60)\n            end\n          end\n\n          context \"uneditable field\" do\n            fab!(:user_field) { Fabricate(:user_field, editable: false) }\n\n            it \"does not update the user field\" do\n              put \"/u/#{user.username}.json\", params: { name: 'Jim Tom', user_fields: { user_field.id.to_s => 'happy' } }\n\n              expect(response.status).to eq(200)\n              expect(user.user_fields[user_field.id.to_s]).to be_blank\n            end\n          end\n\n          context \"custom_field\" do\n            before do\n              plugin = Plugin::Instance.new\n              plugin.register_editable_user_custom_field :test2\n              plugin.register_editable_user_custom_field :test3, staff_only: true\n            end\n\n            after do\n              DiscoursePluginRegistry.reset!\n            end\n\n            it \"only updates allowed user fields\" do\n              put \"/u/#{user.username}.json\", params: { custom_fields: { test1: :hello1, test2: :hello2, test3: :hello3 } }\n\n              expect(response.status).to eq(200)\n              expect(user.custom_fields[\"test1\"]).to be_blank\n              expect(user.custom_fields[\"test2\"]).to eq(\"hello2\")\n              expect(user.custom_fields[\"test3\"]).to be_blank\n            end\n\n            it \"works alongside a user field\" do\n              user_field = Fabricate(:user_field, editable: true)\n              put \"/u/#{user.username}.json\", params: { custom_fields: { test1: :hello1, test2: :hello2, test3: :hello3 }, user_fields: { user_field.id.to_s => 'happy' } }\n              expect(response.status).to eq(200)\n              expect(user.custom_fields[\"test1\"]).to be_blank\n              expect(user.custom_fields[\"test2\"]).to eq(\"hello2\")\n              expect(user.custom_fields[\"test3\"]).to eq(nil)\n              expect(user.user_fields[user_field.id.to_s]).to eq('happy')\n            end\n\n            it \"works alongside a user field during creation\" do\n              api_key = Fabricate(:api_key, user: admin)\n              user_field = Fabricate(:user_field, editable: true)\n              post \"/u.json\", params: {\n                name: \"Test User\",\n                username: \"testuser\",\n                email: \"user@mail.com\",\n                password: 'supersecure',\n                active: true,\n                custom_fields: {\n                  test2: 'custom field value'\n                },\n                user_fields: {\n                  user_field.id.to_s => 'user field value'\n                }\n              }, headers: {\n                HTTP_API_KEY: api_key.key\n              }\n              expect(response.status).to eq(200)\n              u = User.find_by_email('user@mail.com')\n\n              val = u.custom_fields[\"user_field_#{user_field.id}\"]\n              expect(val).to eq('user field value')\n\n              val = u.custom_fields[\"test2\"]\n              expect(val).to eq('custom field value')\n            end\n\n            it \"is secure when there are no registered editable fields\" do\n              DiscoursePluginRegistry.reset!\n              put \"/u/#{user.username}.json\", params: { custom_fields: { test1: :hello1, test2: :hello2, test3: :hello3 } }\n              expect(response.status).to eq(200)\n              expect(user.custom_fields[\"test1\"]).to be_blank\n              expect(user.custom_fields[\"test2\"]).to be_blank\n              expect(user.custom_fields[\"test3\"]).to be_blank\n\n              put \"/u/#{user.username}.json\", params: { custom_fields: [\"arrayitem1\", \"arrayitem2\"] }\n              expect(response.status).to eq(200)\n            end\n\n            it \"allows staff to edit staff-editable fields\" do\n              sign_in(admin)\n              put \"/u/#{user.username}.json\", params: { custom_fields: { test1: :hello1, test2: :hello2, test3: :hello3 } }\n\n              expect(response.status).to eq(200)\n              expect(user.custom_fields[\"test1\"]).to be_blank\n              expect(user.custom_fields[\"test2\"]).to eq(\"hello2\")\n              expect(user.custom_fields[\"test3\"]).to eq(\"hello3\")\n            end\n\n          end\n        end\n\n        it 'returns user JSON' do\n          put \"/u/#{user.username}.json\"\n\n          json = response.parsed_body\n          expect(json['user']['id']).to eq user.id\n        end\n      end\n\n      context 'without permission to update' do\n        it 'does not allow the update' do\n          user = Fabricate(:user, name: 'Billy Bob')\n          sign_in(Fabricate(:user))\n\n          put \"/u/#{user.username}.json\", params: { name: 'Jim Tom' }\n\n          expect(response).to be_forbidden\n          expect(user.reload.name).not_to eq 'Jim Tom'\n        end\n      end\n    end\n  end\n\n  describe '#badge_title' do\n    fab!(:badge) { Fabricate(:badge) }\n    let(:user_badge) { BadgeGranter.grant(badge, user1) }\n\n    it \"sets the user's title to the badge name if it is titleable\" do\n      sign_in(user1)\n\n      put \"/u/#{user1.username}/preferences/badge_title.json\", params: { user_badge_id: user_badge.id }\n\n      expect(user1.reload.title).not_to eq(badge.display_name)\n      badge.update allow_title: true\n\n      put \"/u/#{user1.username}/preferences/badge_title.json\", params: { user_badge_id: user_badge.id }\n\n      expect(user1.reload.title).to eq(badge.display_name)\n      expect(user1.user_profile.badge_granted_title).to eq(true)\n      expect(user1.user_profile.granted_title_badge_id).to eq(badge.id)\n\n      badge.update allow_title: false\n\n      put \"/u/#{user1.username}/preferences/badge_title.json\", params: { user_badge_id: user_badge.id }\n\n      user1.reload\n      user1.user_profile.reload\n      expect(user1.title).to eq('')\n      expect(user1.user_profile.badge_granted_title).to eq(false)\n      expect(user1.user_profile.granted_title_badge_id).to eq(nil)\n    end\n\n    it \"is not raising an erroring when user revokes title\" do\n      sign_in(user1)\n      badge.update allow_title: true\n      put \"/u/#{user1.username}/preferences/badge_title.json\", params: { user_badge_id: user_badge.id }\n      put \"/u/#{user1.username}/preferences/badge_title.json\", params: { user_badge_id: 0 }\n      expect(response.status).to eq(200)\n    end\n\n    context \"with overridden name\" do\n      fab!(:badge) { Fabricate(:badge, name: 'Demogorgon', allow_title: true) }\n      let(:user_badge) { BadgeGranter.grant(badge, user1) }\n\n      before do\n        TranslationOverride.upsert!('en', 'badges.demogorgon.name', 'Boss')\n      end\n\n      after do\n        TranslationOverride.revert!('en', ['badges.demogorgon.name'])\n      end\n\n      it \"uses the badge display name as user title\" do\n        sign_in(user1)\n\n        put \"/u/#{user1.username}/preferences/badge_title.json\", params: { user_badge_id: user_badge.id }\n        expect(user1.reload.title).to eq(badge.display_name)\n      end\n    end\n  end\n\n  describe '#send_activation_email' do\n    before do\n      UsersController.any_instance.stubs(:honeypot_value).returns(nil)\n      UsersController.any_instance.stubs(:challenge_value).returns(nil)\n    end\n\n    let(:post_user) do\n      post \"/u.json\", params: {\n        username: \"osamatest\",\n        password: \"strongpassword\",\n        email: \"dsdsds@sasa.com\"\n      }\n\n      User.find_by(username: \"osamatest\")\n    end\n\n    context 'for an existing user' do\n      context 'for an activated account with email confirmed' do\n        it 'fails' do\n          user = post_user\n          email_token = Fabricate(:email_token, user: user).token\n          EmailToken.confirm(email_token)\n\n          post \"/u/action/send_activation_email.json\", params: { username: user.username }\n\n          expect(response.status).to eq(409)\n          expect(response.parsed_body['errors']).to include(I18n.t(\n            'activation.activated'\n          ))\n          expect(session[SessionController::ACTIVATE_USER_KEY]).to eq(nil)\n        end\n      end\n\n      context 'for an activated account with unconfirmed email' do\n        it 'should send an email' do\n          user = post_user\n          user.update!(active: true)\n          Fabricate(:email_token, user: user)\n\n          expect_enqueued_with(job: :critical_user_email, args: { type: :signup, to_address: user.email }) do\n            post \"/u/action/send_activation_email.json\", params: {\n              username: user.username\n            }\n          end\n\n          expect(response.status).to eq(200)\n\n          expect(session[SessionController::ACTIVATE_USER_KEY]).to eq(nil)\n        end\n      end\n\n      context \"approval is enabled\" do\n        before do\n          SiteSetting.must_approve_users = true\n        end\n\n        it \"should raise an error\" do\n          user = post_user\n          user.update(active: true)\n          user.save!\n          Fabricate(:email_token, user: user1)\n          post \"/u/action/send_activation_email.json\", params: {\n            username: user.username\n          }\n\n          expect(response.status).to eq(403)\n        end\n      end\n\n      describe 'when user does not have a valid session' do\n        it 'should not be valid' do\n          post \"/u/action/send_activation_email.json\", params: {\n            username: user.username\n          }\n          expect(response.status).to eq(403)\n        end\n\n        it 'should allow staff regardless' do\n          sign_in(admin)\n          user = Fabricate(:user, active: false)\n          post \"/u/action/send_activation_email.json\", params: {\n            username: user.username\n          }\n          expect(response.status).to eq(200)\n        end\n      end\n\n      context 'with a valid email_token' do\n        it 'should send the activation email' do\n          user = post_user\n\n          expect_enqueued_with(job: :critical_user_email, args: { type: :signup }) do\n            post \"/u/action/send_activation_email.json\", params: {\n              username: user.username\n            }\n          end\n\n          expect(response.status).to eq(200)\n          expect(session[SessionController::ACTIVATE_USER_KEY]).to eq(nil)\n        end\n      end\n\n      context 'without an existing email_token' do\n        let(:user) { post_user }\n        before do\n          user.email_tokens.each { |t| t.destroy }\n          user.reload\n        end\n\n        it 'should generate a new token' do\n          expect {\n            post \"/u/action/send_activation_email.json\", params: { username: user.username }\n          }.to change { user.reload.email_tokens.count }.by(1)\n        end\n\n        it 'should send an email' do\n          expect do\n            post \"/u/action/send_activation_email.json\", params: {\n              username: user.username\n            }\n          end.to change { Jobs::CriticalUserEmail.jobs.size }.by(1)\n\n          expect(session[SessionController::ACTIVATE_USER_KEY]).to eq(nil)\n        end\n      end\n    end\n\n    context 'when username does not exist' do\n      it 'should not send an email' do\n        post \"/u/action/send_activation_email.json\", params: { username: 'nopenopenopenope' }\n        expect(response.status).to eq(404)\n        expect(Jobs::CriticalUserEmail.jobs.size).to eq(0)\n      end\n    end\n  end\n\n  describe '#pick_avatar' do\n    it 'raises an error when not logged in' do\n      put \"/u/asdf/preferences/avatar/pick.json\", params: { avatar_id: 1, type: \"custom\" }\n      expect(response.status).to eq(403)\n    end\n\n    context 'while logged in' do\n      before do\n        sign_in(user1)\n      end\n\n      fab!(:upload) do\n        Fabricate(:upload, user: user1)\n      end\n\n      it \"raises an error when you don't have permission to toggle the avatar\" do\n        put \"/u/#{another_user.username}/preferences/avatar/pick.json\", params: {\n          upload_id: upload.id, type: \"custom\"\n        }\n\n        expect(response).to be_forbidden\n      end\n\n      it \"raises an error when discourse_connect_overrides_avatar is disabled\" do\n        SiteSetting.discourse_connect_overrides_avatar = true\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\", params: {\n          upload_id: upload.id, type: \"custom\"\n        }\n\n        expect(response.status).to eq(422)\n      end\n\n      it \"raises an error when selecting the custom/uploaded avatar and allow_uploaded_avatars is disabled\" do\n        SiteSetting.allow_uploaded_avatars = 'disabled'\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\", params: {\n          upload_id: upload.id, type: \"custom\"\n        }\n\n        expect(response.status).to eq(422)\n      end\n\n      it \"raises an error when selecting the custom/uploaded avatar and allow_uploaded_avatars is admin\" do\n        SiteSetting.allow_uploaded_avatars = 'admin'\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\", params: {\n          upload_id: upload.id, type: \"custom\"\n        }\n        expect(response.status).to eq(422)\n\n        user1.update!(admin: true)\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\", params: {\n          upload_id: upload.id, type: \"custom\"\n        }\n        expect(response.status).to eq(200)\n      end\n\n      it \"raises an error when selecting the custom/uploaded avatar and allow_uploaded_avatars is staff\" do\n        SiteSetting.allow_uploaded_avatars = 'staff'\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\", params: {\n          upload_id: upload.id, type: \"custom\"\n        }\n        expect(response.status).to eq(422)\n\n        user1.update!(moderator: true)\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\", params: {\n          upload_id: upload.id, type: \"custom\"\n        }\n        expect(response.status).to eq(200)\n      end\n\n      it \"raises an error when selecting the custom/uploaded avatar and allow_uploaded_avatars is a trust level\" do\n        SiteSetting.allow_uploaded_avatars = '3'\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\", params: {\n          upload_id: upload.id, type: \"custom\"\n        }\n        expect(response.status).to eq(422)\n\n        user1.update!(trust_level: 3)\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\", params: {\n          upload_id: upload.id, type: \"custom\"\n        }\n        expect(response.status).to eq(200)\n      end\n\n      it 'ignores the upload if picking a system avatar' do\n        SiteSetting.allow_uploaded_avatars = 'disabled'\n        another_upload = Fabricate(:upload)\n\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\", params: {\n          upload_id: another_upload.id, type: \"system\"\n        }\n\n        expect(response.status).to eq(200)\n        expect(user1.reload.uploaded_avatar_id).to eq(nil)\n      end\n\n      it 'raises an error if the type is invalid' do\n        SiteSetting.allow_uploaded_avatars = 'disabled'\n        another_upload = Fabricate(:upload)\n\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\", params: {\n          upload_id: another_upload.id, type: \"x\"\n        }\n\n        expect(response.status).to eq(422)\n      end\n\n      it 'can successfully pick the system avatar' do\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\"\n\n        expect(response.status).to eq(200)\n        expect(user1.reload.uploaded_avatar_id).to eq(nil)\n      end\n\n      it 'disables the use_site_small_logo_as_system_avatar setting when picking an avatar for the system user' do\n        system_user = Discourse.system_user\n        SiteSetting.use_site_small_logo_as_system_avatar = true\n        another_upload = Fabricate(:upload, user: system_user)\n        sign_in(system_user)\n\n        put \"/u/#{system_user.username}/preferences/avatar/pick.json\", params: {\n          upload_id: another_upload.id, type: \"uploaded\"\n        }\n\n        expect(response.status).to eq(200)\n        expect(SiteSetting.use_site_small_logo_as_system_avatar).to eq(false)\n      end\n\n      it 'can successfully pick a gravatar' do\n\n        user1.user_avatar.update_columns(gravatar_upload_id: upload.id)\n\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\", params: {\n          upload_id: upload.id, type: \"gravatar\"\n        }\n\n        expect(response.status).to eq(200)\n        expect(user1.reload.uploaded_avatar_id).to eq(upload.id)\n        expect(user1.user_avatar.reload.gravatar_upload_id).to eq(upload.id)\n      end\n\n      it 'can not pick uploads that were not created by user' do\n        upload2 = Fabricate(:upload)\n\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\", params: {\n          upload_id: upload2.id, type: \"custom\"\n        }\n\n        expect(response.status).to eq(403)\n      end\n\n      it 'can successfully pick a custom avatar' do\n        events = DiscourseEvent.track_events do\n          put \"/u/#{user1.username}/preferences/avatar/pick.json\", params: {\n            upload_id: upload.id, type: \"custom\"\n          }\n        end\n\n        expect(events.map { |event| event[:event_name] }).to include(:user_updated)\n        expect(response.status).to eq(200)\n        expect(user1.reload.uploaded_avatar_id).to eq(upload.id)\n        expect(user1.user_avatar.reload.custom_upload_id).to eq(upload.id)\n      end\n    end\n  end\n\n  describe '#select_avatar' do\n    it 'raises an error when not logged in' do\n      put \"/u/asdf/preferences/avatar/select.json\", params: { url: \"https://meta.discourse.org\" }\n      expect(response.status).to eq(403)\n    end\n\n    context 'while logged in' do\n      before do\n        sign_in(user1)\n      end\n\n      fab!(:avatar1) { Fabricate(:upload) }\n      fab!(:avatar2) { Fabricate(:upload) }\n      let(:url) { \"https://www.discourse.org\" }\n\n      it 'raises an error when url is blank' do\n        put \"/u/#{user1.username}/preferences/avatar/select.json\", params: { url: \"\" }\n        expect(response.status).to eq(422)\n      end\n\n      it 'raises an error when selectable avatars is disabled' do\n        put \"/u/#{user1.username}/preferences/avatar/select.json\", params: { url: url }\n        expect(response.status).to eq(422)\n      end\n\n      context 'selectable avatars is enabled' do\n\n        before do\n          SiteSetting.selectable_avatars = [avatar1, avatar2]\n          SiteSetting.selectable_avatars_enabled = true\n        end\n\n        it 'raises an error when selectable avatars is empty' do\n          SiteSetting.selectable_avatars = \"\"\n          put \"/u/#{user1.username}/preferences/avatar/select.json\", params: { url: url }\n          expect(response.status).to eq(422)\n        end\n\n        context 'selectable avatars is properly setup' do\n          it 'raises an error when url is not in selectable avatars list' do\n            put \"/u/#{user1.username}/preferences/avatar/select.json\", params: { url: url }\n            expect(response.status).to eq(422)\n          end\n\n          it 'can successfully select an avatar' do\n            events = DiscourseEvent.track_events do\n              put \"/u/#{user1.username}/preferences/avatar/select.json\", params: { url: avatar1.url }\n            end\n\n            expect(events.map { |event| event[:event_name] }).to include(:user_updated)\n            expect(response.status).to eq(200)\n            expect(user1.reload.uploaded_avatar_id).to eq(avatar1.id)\n            expect(user1.user_avatar.reload.custom_upload_id).to eq(avatar1.id)\n          end\n\n          it 'can successfully select an avatar using a cooked URL' do\n            events = DiscourseEvent.track_events do\n              put \"/u/#{user1.username}/preferences/avatar/select.json\", params: { url: UrlHelper.cook_url(avatar1.url) }\n            end\n\n            expect(events.map { |event| event[:event_name] }).to include(:user_updated)\n            expect(response.status).to eq(200)\n            expect(user1.reload.uploaded_avatar_id).to eq(avatar1.id)\n            expect(user1.user_avatar.reload.custom_upload_id).to eq(avatar1.id)\n          end\n\n          it 'disables the use_site_small_logo_as_system_avatar setting when picking an avatar for the system user' do\n            system_user = Discourse.system_user\n            SiteSetting.use_site_small_logo_as_system_avatar = true\n            sign_in(system_user)\n\n            put \"/u/#{system_user.username}/preferences/avatar/select.json\", params: {\n              url: UrlHelper.cook_url(avatar1.url)\n            }\n\n            expect(response.status).to eq(200)\n            expect(SiteSetting.use_site_small_logo_as_system_avatar).to eq(false)\n          end\n        end\n      end\n    end\n  end\n\n  describe '#destroy_user_image' do\n\n    it 'raises an error when not logged in' do\n      delete \"/u/asdf/preferences/user_image.json\", params: { type: 'profile_background' }\n      expect(response.status).to eq(403)\n    end\n\n    context 'while logged in' do\n      before do\n        sign_in(user1)\n      end\n\n      it 'raises an error when you don\\'t have permission to clear the profile background' do\n        delete \"/u/#{another_user.username}/preferences/user_image.json\", params: { type: 'profile_background' }\n        expect(response).to be_forbidden\n      end\n\n      it \"requires the `type` param\" do\n        delete \"/u/#{user1.username}/preferences/user_image.json\"\n        expect(response.status).to eq(400)\n      end\n\n      it \"only allows certain `types`\" do\n        delete \"/u/#{user1.username}/preferences/user_image.json\", params: { type: 'wat' }\n        expect(response.status).to eq(400)\n      end\n\n      it 'can clear the profile background' do\n        delete \"/u/#{user1.username}/preferences/user_image.json\", params: { type: 'profile_background' }\n\n        expect(user1.reload.profile_background_upload).to eq(nil)\n        expect(response.status).to eq(200)\n      end\n    end\n  end\n\n  describe '#destroy' do\n    it 'raises an error when not logged in' do\n      delete \"/u/nobody.json\"\n      expect(response.status).to eq(403)\n    end\n\n    context 'while logged in' do\n      before do\n        sign_in(user1)\n      end\n\n      it 'raises an error when you cannot delete your account' do\n        UserDestroyer.any_instance.expects(:destroy).never\n        stat = user1.user_stat\n        stat.post_count = 3\n        stat.save!\n        delete \"/u/#{user1.username}.json\"\n        expect(response).to be_forbidden\n      end\n\n      it \"raises an error when you try to delete someone else's account\" do\n        UserDestroyer.any_instance.expects(:destroy).never\n        delete \"/u/#{another_user.username}.json\"\n        expect(response).to be_forbidden\n      end\n\n      it \"deletes your account when you're allowed to\" do\n        UserDestroyer.any_instance.expects(:destroy).with(user1, anything).returns(user1)\n        delete \"/u/#{user1.username}.json\"\n        expect(response.status).to eq(200)\n      end\n    end\n  end\n\n  describe '#ignore' do\n    it 'raises an error when not logged in' do\n      put \"/u/#{user1.username}/notification_level.json\", params: { notification_level: \"\" }\n      expect(response.status).to eq(403)\n    end\n\n    context 'while logged in' do\n      fab!(:user) { Fabricate(:user, trust_level: 2) }\n      before do\n        sign_in(user)\n      end\n\n      fab!(:ignored_user) { Fabricate(:ignored_user, user: user, ignored_user: another_user) }\n      fab!(:muted_user) { Fabricate(:muted_user, user: user, muted_user: another_user) }\n\n      context \"when you can't change the notification\" do\n        fab!(:staff_user) { admin }\n\n        it \"ignoring includes a helpful error message\" do\n          put \"/u/#{staff_user.username}/notification_level.json\", params: { notification_level: 'ignore' }\n          expect(response.status).to eq(422)\n          expect(response.parsed_body['errors'][0]).to eq(I18n.t(\"notification_level.ignore_error\"))\n        end\n\n        it \"muting includes a helpful error message\" do\n          put \"/u/#{staff_user.username}/notification_level.json\", params: { notification_level: 'mute' }\n          expect(response.status).to eq(422)\n          expect(response.parsed_body['errors'][0]).to eq(I18n.t(\"notification_level.mute_error\"))\n        end\n      end\n\n      context 'when changing notification level to normal' do\n        it 'changes notification level to normal' do\n          put \"/u/#{another_user.username}/notification_level.json\", params: { notification_level: \"normal\" }\n          expect(IgnoredUser.count).to eq(0)\n          expect(MutedUser.count).to eq(0)\n        end\n      end\n\n      context 'when changing notification level to mute' do\n        it 'changes notification level to mute' do\n          put \"/u/#{another_user.username}/notification_level.json\", params: { notification_level: \"mute\" }\n          expect(IgnoredUser.count).to eq(0)\n          expect(MutedUser.find_by(user_id: user.id, muted_user_id: another_user.id)).to be_present\n        end\n      end\n\n      context 'when changing notification level to ignore' do\n        it 'changes notification level to ignore' do\n          put \"/u/#{another_user.username}/notification_level.json\", params: { notification_level: \"ignore\" }\n          expect(MutedUser.count).to eq(0)\n          expect(IgnoredUser.find_by(user_id: user.id, ignored_user_id: another_user.id)).to be_present\n        end\n\n        context 'when expiring_at param is set' do\n          it 'changes notification level to ignore' do\n            freeze_time(Time.now) do\n              expiring_at = 3.days.from_now\n              put \"/u/#{another_user.username}/notification_level.json\", params: { notification_level: \"ignore\", expiring_at: expiring_at }\n\n              ignored_user = IgnoredUser.find_by(user_id: user.id, ignored_user_id: another_user.id)\n              expect(ignored_user).to be_present\n              expect(ignored_user.expiring_at.to_i).to eq(expiring_at.to_i)\n              expect(MutedUser.count).to eq(0)\n            end\n          end\n        end\n      end\n    end\n  end\n\n  describe \"for user with period in username\" do\n    fab!(:user_with_period) { Fabricate(:user, username: \"myname.test\") }\n\n    it \"still works\" do\n      sign_in(user_with_period)\n      UserDestroyer.any_instance.expects(:destroy).with(user_with_period, anything).returns(user_with_period)\n      delete \"/u/#{user_with_period.username}\", xhr: true\n      expect(response.status).to eq(200)\n    end\n  end\n\n  describe '#my_redirect' do\n    it \"redirects if the user is not logged in\" do\n      get \"/my/wat\"\n      expect(response).to redirect_to(\"/login-preferences\")\n      expect(response.cookies).to have_key(\"destination_url\")\n      expect(response.cookies[\"destination_url\"]).to eq(\"/my/wat\")\n      expect(response.headers['X-Robots-Tag']).to eq('noindex')\n    end\n\n    context \"when the user is logged in\" do\n      before do\n        sign_in(user1)\n      end\n\n      it \"will not redirect to an invalid path\" do\n        get \"/my/wat/..password.txt\"\n        expect(response).not_to be_redirect\n      end\n\n      it \"will redirect to an valid path\" do\n        get \"/my/preferences\"\n        expect(response).to redirect_to(\"/u/#{user1.username}/preferences\")\n      end\n\n      it \"permits forward slashes\" do\n        get \"/my/activity/posts\"\n        expect(response).to redirect_to(\"/u/#{user1.username}/activity/posts\")\n      end\n\n      it \"correctly redirects for Unicode usernames\" do\n        SiteSetting.unicode_usernames = true\n        user = sign_in(Fabricate(:unicode_user))\n\n        get \"/my/preferences\"\n        expect(response).to redirect_to(\"/u/#{user.encoded_username}/preferences\")\n      end\n    end\n  end\n\n  describe '#check_emails' do\n    it 'raises an error when not logged in' do\n      get \"/u/zogstrip/emails.json\"\n      expect(response.status).to eq(403)\n    end\n\n    context 'while logged in' do\n      let(:sign_in_admin) { sign_in(admin) }\n\n      it \"raises an error when you aren't allowed to check emails\" do\n        sign_in(Fabricate(:user))\n        get \"/u/#{Fabricate(:user).username}/emails.json\"\n        expect(response).to be_forbidden\n      end\n\n      it \"returns emails and associated_accounts for self\" do\n        Fabricate(:email_change_request, user: user1)\n        sign_in(user)\n\n        get \"/u/#{user.username}/emails.json\"\n\n        expect(response.status).to eq(200)\n        json = response.parsed_body\n        expect(json[\"email\"]).to eq(user.email)\n        expect(json[\"secondary_emails\"]).to eq(user.secondary_emails)\n        expect(json[\"unconfirmed_emails\"]).to eq(user.unconfirmed_emails)\n        expect(json[\"associated_accounts\"]).to eq([])\n      end\n\n      it \"returns emails and associated_accounts when you're allowed to see them\" do\n        Fabricate(:email_change_request, user: user1)\n        sign_in_admin\n\n        get \"/u/#{user.username}/emails.json\"\n\n        expect(response.status).to eq(200)\n        json = response.parsed_body\n        expect(json[\"email\"]).to eq(user.email)\n        expect(json[\"secondary_emails\"]).to eq(user.secondary_emails)\n        expect(json[\"unconfirmed_emails\"]).to eq(user.unconfirmed_emails)\n        expect(json[\"associated_accounts\"]).to eq([])\n      end\n\n      it \"works on inactive users\" do\n        inactive_user = Fabricate(:user, active: false)\n        Fabricate(:email_change_request, user: inactive_user)\n        sign_in_admin\n\n        get \"/u/#{inactive_user.username}/emails.json\"\n\n        expect(response.status).to eq(200)\n        json = response.parsed_body\n        expect(json[\"email\"]).to eq(inactive_user.email)\n        expect(json[\"secondary_emails\"]).to eq(inactive_user.secondary_emails)\n        expect(json[\"unconfirmed_emails\"]).to eq(inactive_user.unconfirmed_emails)\n        expect(json[\"associated_accounts\"]).to eq([])\n      end\n    end\n  end\n\n  describe '#check_sso_email' do\n    it 'raises an error when not logged in' do\n      get \"/u/zogstrip/sso-email.json\"\n      expect(response.status).to eq(403)\n    end\n\n    context 'while logged in' do\n      let(:sign_in_admin) { sign_in(admin) }\n\n      it \"raises an error when you aren't allowed to check sso email\" do\n        sign_in(Fabricate(:user))\n        get \"/u/#{user1.username}/sso-email.json\"\n        expect(response).to be_forbidden\n      end\n\n      it \"returns emails and associated_accounts when you're allowed to see them\" do\n        user1.single_sign_on_record = SingleSignOnRecord.create(user_id: user1.id, external_email: \"foobar@example.com\", external_id: \"example\", last_payload: \"looks good\")\n        sign_in_admin\n\n        get \"/u/#{user1.username}/sso-email.json\"\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"email\"]).to eq(\"foobar@example.com\")\n      end\n    end\n  end\n\n  describe '#check_sso_payload' do\n    it 'raises an error when not logged in' do\n      get \"/u/zogstrip/sso-payload.json\"\n      expect(response.status).to eq(403)\n    end\n\n    context 'while logged in' do\n      let(:sign_in_admin) { sign_in(admin) }\n\n      it \"raises an error when you aren't allowed to check sso payload\" do\n        sign_in(Fabricate(:user))\n        get \"/u/#{user1.username}/sso-payload.json\"\n        expect(response).to be_forbidden\n      end\n\n      it \"returns SSO payload when you're allowed to see\" do\n        user1.single_sign_on_record = SingleSignOnRecord.create(user_id: user1.id, external_email: \"foobar@example.com\", external_id: \"example\", last_payload: \"foobar\")\n        sign_in_admin\n\n        get \"/u/#{user1.username}/sso-payload.json\"\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"payload\"]).to eq(\"foobar\")\n      end\n    end\n  end\n\n  describe '#update_primary_email' do\n    let(:user_email) { user1.primary_email }\n    fab!(:other_email) { Fabricate(:secondary_email, user: user1) }\n\n    before do\n      SiteSetting.email_editable = true\n\n      sign_in(user1)\n    end\n\n    it \"changes user's primary email\" do\n      put \"/u/#{user1.username}/preferences/primary-email.json\", params: { email: user_email.email }\n      expect(response.status).to eq(200)\n      expect(user_email.reload.primary).to eq(true)\n      expect(other_email.reload.primary).to eq(false)\n\n      event = DiscourseEvent.track_events {\n        expect { put \"/u/#{user1.username}/preferences/primary-email.json\", params: { email: other_email.email } }\n          .to change { UserHistory.where(action: UserHistory.actions[:update_email], acting_user_id: user1.id).count }.by(1)\n      }.last\n\n      expect(response.status).to eq(200)\n      expect(user_email.reload.primary).to eq(false)\n      expect(other_email.reload.primary).to eq(true)\n\n      expect(event[:event_name]).to eq(:user_updated)\n      expect(event[:params].first).to eq(user1)\n    end\n  end\n\n  describe '#destroy_email' do\n    fab!(:user_email) { user1.primary_email }\n    fab!(:other_email) { Fabricate(:secondary_email, user: user1) }\n\n    before do\n      SiteSetting.email_editable = true\n\n      sign_in(user1)\n    end\n\n    it \"can destroy secondary emails\" do\n      delete \"/u/#{user1.username}/preferences/email.json\", params: { email: user_email.email }\n      expect(response.status).to eq(428)\n      expect(user1.reload.user_emails.pluck(:email)).to contain_exactly(user_email.email, other_email.email)\n\n      event = DiscourseEvent.track_events {\n        expect { delete \"/u/#{user1.username}/preferences/email.json\", params: { email: other_email.email } }\n          .to change { UserHistory.where(action: UserHistory.actions[:destroy_email], acting_user_id: user1.id).count }.by(1)\n      }.last\n\n      expect(response.status).to eq(200)\n      expect(user1.reload.user_emails.pluck(:email)).to contain_exactly(user_email.email)\n\n      expect(event[:event_name]).to eq(:user_updated)\n      expect(event[:params].first).to eq(user1)\n    end\n\n    it \"can destroy unconfirmed emails\" do\n      request_1 = EmailChangeRequest.create!(\n        user: user1,\n        new_email: user_email.email,\n        change_state: EmailChangeRequest.states[:authorizing_new]\n      )\n\n      EmailChangeRequest.create!(\n        user: user1,\n        new_email: other_email.email,\n        change_state: EmailChangeRequest.states[:authorizing_new]\n      )\n\n      EmailChangeRequest.create!(\n        user: user1,\n        new_email: other_email.email,\n        change_state: EmailChangeRequest.states[:authorizing_new]\n      )\n\n      delete \"/u/#{user1.username}/preferences/email.json\", params: { email: other_email.email }\n\n      expect(user1.user_emails.pluck(:email)).to contain_exactly(user_email.email, other_email.email)\n      expect(user1.email_change_requests).to contain_exactly(request_1)\n    end\n\n    it \"can destroy associated email tokens\" do\n      new_email = 'new.n.cool@example.com'\n      updater = EmailUpdater.new(guardian: user1.guardian, user: user1)\n\n      expect { updater.change_to(new_email) }\n        .to change { user1.email_tokens.count }.by(1)\n\n      expect { delete \"/u/#{user1.username}/preferences/email.json\", params: { email: new_email } }\n        .to change { user1.email_tokens.count }.by(-1)\n\n      expect(user1.email_tokens.first.email).to eq(user1.email)\n    end\n  end\n\n  describe '#is_local_username' do\n    fab!(:group) { Fabricate(:group, name: \"Discourse\", mentionable_level: Group::ALIAS_LEVELS[:everyone]) }\n    let(:unmentionable) {\n      Fabricate(:group, name: \"Unmentionable\", mentionable_level: Group::ALIAS_LEVELS[:nobody])\n    }\n    fab!(:topic) { Fabricate(:topic) }\n    fab!(:allowed_user) { Fabricate(:user) }\n    fab!(:private_topic) { Fabricate(:private_message_topic, user: allowed_user) }\n\n    it \"finds the user\" do\n      get \"/u/is_local_username.json\", params: { username: user1.username }\n\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"valid\"][0]).to eq(user1.username)\n    end\n\n    it \"finds the group\" do\n      sign_in(user1)\n      get \"/u/is_local_username.json\", params: { username: group.name }\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"valid_groups\"]).to include(group.name)\n      expect(json[\"mentionable_groups\"].find { |g| g['name'] == group.name }).to be_present\n    end\n\n    it \"finds unmentionable groups\" do\n      sign_in(user1)\n      get \"/u/is_local_username.json\", params: { username: unmentionable.name }\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"valid_groups\"]).to include(unmentionable.name)\n      expect(json[\"mentionable_groups\"]).to be_blank\n    end\n\n    it \"supports multiples usernames\" do\n      get \"/u/is_local_username.json\", params: { usernames: [user1.username, \"system\"] }\n\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"valid\"].size).to eq(2)\n    end\n\n    it \"never includes staged accounts\" do\n      staged = Fabricate(:user, staged: true)\n\n      get \"/u/is_local_username.json\", params: { usernames: [staged.username] }\n\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"valid\"].size).to eq(0)\n    end\n\n    it \"returns user who cannot see topic\" do\n      Guardian.any_instance.expects(:can_see?).with(topic).returns(false)\n\n      get \"/u/is_local_username.json\", params: {\n        usernames: [user1.username], topic_id: topic.id\n      }\n\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"cannot_see\"].size).to eq(1)\n    end\n\n    it \"never returns a user who can see the topic\" do\n      Guardian.any_instance.expects(:can_see?).with(topic).returns(true)\n\n      get \"/u/is_local_username.json\", params: {\n        usernames: [user1.username], topic_id: topic.id\n      }\n\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"cannot_see\"].size).to eq(0)\n    end\n\n    it \"returns user who cannot see a private topic\" do\n      Guardian.any_instance.expects(:can_see?).with(private_topic).returns(false)\n\n      get \"/u/is_local_username.json\", params: {\n        usernames: [user1.username], topic_id: private_topic.id\n      }\n\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"cannot_see\"].size).to eq(1)\n    end\n\n    it \"never returns a user who can see the topic\" do\n      Guardian.any_instance.expects(:can_see?).with(private_topic).returns(true)\n\n      get \"/u/is_local_username.json\", params: {\n        usernames: [allowed_user.username], topic_id: private_topic.id\n      }\n\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"cannot_see\"].size).to eq(0)\n    end\n  end\n\n  describe '#topic_tracking_state' do\n    context 'anon' do\n      it \"raises an error on anon for topic_tracking_state\" do\n        get \"/u/#{user1.username}/topic-tracking-state.json\"\n        expect(response.status).to eq(403)\n      end\n    end\n\n    context 'logged on' do\n      it \"detects new topic\" do\n        sign_in(user1)\n\n        topic = Fabricate(:topic)\n        get \"/u/#{user1.username}/topic-tracking-state.json\"\n\n        expect(response.status).to eq(200)\n        states = response.parsed_body\n        expect(states[0][\"topic_id\"]).to eq(topic.id)\n      end\n    end\n  end\n\n  describe '#summary' do\n    it \"generates summary info\" do\n      create_post(user: user)\n\n      get \"/u/#{user.username_lower}/summary.json\"\n      expect(response.headers['X-Robots-Tag']).to eq('noindex')\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n\n      expect(json[\"user_summary\"][\"topic_count\"]).to eq(1)\n      expect(json[\"user_summary\"][\"post_count\"]).to eq(0)\n    end\n\n    context '`hide_profile_and_presence` user option is checked' do\n      before_all do\n        user1.user_option.update_columns(hide_profile_and_presence: true)\n      end\n\n      it \"returns 404\" do\n        get \"/u/#{user1.username_lower}/summary.json\"\n        expect(response.status).to eq(404)\n      end\n\n      it \"returns summary info if `allow_users_to_hide_profile` is false\" do\n        SiteSetting.allow_users_to_hide_profile = false\n\n        get \"/u/#{user1.username_lower}/summary.json\"\n        expect(response.status).to eq(200)\n      end\n    end\n\n    context 'avatar flair in Most... sections' do\n      it \"returns data for automatic groups flair\" do\n        liker = Fabricate(:user, admin: true, moderator: true, trust_level: 1)\n        create_and_like_post(user_deferred, liker)\n\n        get \"/u/#{user_deferred.username_lower}/summary.json\"\n        json = response.parsed_body\n\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"admin\"]).to eq(true)\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"moderator\"]).to eq(true)\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"trust_level\"]).to eq(1)\n      end\n\n      it \"returns data for flair when an icon is used\" do\n        group = Fabricate(:group, name: \"Groupie\", flair_bg_color: \"#111111\", flair_color: \"#999999\", flair_icon: \"icon\")\n        liker = Fabricate(:user, flair_group: group)\n        create_and_like_post(user_deferred, liker)\n\n        get \"/u/#{user_deferred.username_lower}/summary.json\"\n        json = response.parsed_body\n\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"flair_name\"]).to eq(\"Groupie\")\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"flair_url\"]).to eq(\"icon\")\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"flair_bg_color\"]).to eq(\"#111111\")\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"flair_color\"]).to eq(\"#999999\")\n      end\n\n      it \"returns data for flair when an image is used\" do\n        upload = Fabricate(:upload)\n        group = Fabricate(:group, name: \"Groupie\", flair_bg_color: \"#111111\", flair_upload: upload)\n        liker = Fabricate(:user, flair_group: group)\n        create_and_like_post(user_deferred, liker)\n\n        get \"/u/#{user_deferred.username_lower}/summary.json\"\n        json = response.parsed_body\n\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"flair_name\"]).to eq(\"Groupie\")\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"flair_url\"]).to eq(upload.url)\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"flair_bg_color\"]).to eq(\"#111111\")\n      end\n\n      def create_and_like_post(likee, liker)\n        UserActionManager.enable\n        post = create_post(user: likee)\n        PostActionCreator.like(liker, post)\n      end\n    end\n  end\n\n  describe '#confirm_admin' do\n    it \"fails without a valid token\" do\n      get \"/u/confirm-admin/invalid-token.json\"\n      expect(response).not_to be_successful\n    end\n\n    it \"fails with a missing token\" do\n      get \"/u/confirm-admin/a0a0a0a0a0.json\"\n      expect(response).to_not be_successful\n    end\n\n    it \"succeeds with a valid code as anonymous\" do\n      ac = AdminConfirmation.new(user1, admin)\n      ac.create_confirmation\n      get \"/u/confirm-admin/#{ac.token}.json\"\n      expect(response.status).to eq(200)\n\n      user1.reload\n      expect(user1.admin?).to eq(false)\n    end\n\n    it \"succeeds with a valid code when logged in as that user\" do\n      sign_in(admin)\n\n      ac = AdminConfirmation.new(user1, admin)\n      ac.create_confirmation\n      get \"/u/confirm-admin/#{ac.token}.json\", params: { token: ac.token }\n      expect(response.status).to eq(200)\n\n      user1.reload\n      expect(user1.admin?).to eq(false)\n    end\n\n    it \"fails if you're logged in as a different account\" do\n      sign_in(admin)\n\n      ac = AdminConfirmation.new(user1, Fabricate(:admin))\n      ac.create_confirmation\n      get \"/u/confirm-admin/#{ac.token}.json\"\n      expect(response).to_not be_successful\n\n      user1.reload\n      expect(user1.admin?).to eq(false)\n    end\n\n    describe \"post\" do\n      it \"gives the user admin access when POSTed\" do\n        ac = AdminConfirmation.new(user1, admin)\n        ac.create_confirmation\n        post \"/u/confirm-admin/#{ac.token}.json\"\n        expect(response.status).to eq(200)\n\n        user1.reload\n        expect(user1.admin?).to eq(true)\n      end\n    end\n  end\n\n  describe '#update_activation_email' do\n    before do\n      UsersController.any_instance.stubs(:honeypot_value).returns(nil)\n      UsersController.any_instance.stubs(:challenge_value).returns(nil)\n    end\n\n    let(:post_user) do\n      post \"/u.json\", params: {\n        username: \"osamatest\",\n        password: \"strongpassword\",\n        email: \"osama@example.com\"\n      }\n      user = User.where(username: \"osamatest\").first\n      user.active = false\n      user.save!\n      user\n    end\n\n    context \"with a session variable\" do\n      it \"raises an error with an invalid session value\" do\n        post_user\n\n        post \"/u.json\", params: {\n          username: \"osamatest2\",\n          password: \"strongpassword2\",\n          email: \"osama22@example.com\"\n        }\n        user = User.where(username: \"osamatest2\").first\n        user.destroy\n\n        put \"/u/update-activation-email.json\", params: {\n          email: 'osamaupdated@example.com'\n        }\n\n        expect(response.status).to eq(403)\n      end\n\n      it \"raises an error for an active user\" do\n        user = post_user\n        user.update(active: true)\n        user.save!\n\n        put \"/u/update-activation-email.json\", params: {\n          email: 'osama@example.com'\n        }\n\n        expect(response.status).to eq(403)\n      end\n\n      it \"raises an error when logged in\" do\n        sign_in(moderator)\n        post_user\n\n        put \"/u/update-activation-email.json\", params: {\n          email: 'updatedemail@example.com'\n        }\n\n        expect(response.status).to eq(403)\n      end\n\n      it \"raises an error when the new email is taken\" do\n        active_user = Fabricate(:user)\n        post_user\n\n        put \"/u/update-activation-email.json\", params: {\n          email: active_user.email\n        }\n\n        expect(response.status).to eq(422)\n      end\n\n      it \"raises an error when the email is blocklisted\" do\n        post_user\n        SiteSetting.blocked_email_domains = 'example.com'\n        put \"/u/update-activation-email.json\", params: { email: 'test@example.com' }\n        expect(response.status).to eq(422)\n      end\n\n      it \"can be updated\" do\n        user = post_user\n        token = user.email_tokens.first\n\n        put \"/u/update-activation-email.json\", params: {\n          email: 'updatedemail@example.com'\n        }\n\n        expect(response.status).to eq(200)\n\n        user.reload\n        expect(user.email).to eq('updatedemail@example.com')\n        expect(user.email_tokens.where(email: 'updatedemail@example.com', expired: false)).to be_present\n\n        token.reload\n        expect(token.expired?).to eq(true)\n      end\n    end\n\n    context \"with a username and password\" do\n      it \"raises an error with an invalid username\" do\n        put \"/u/update-activation-email.json\", params: {\n          username: 'eviltrout',\n          password: 'invalid-password',\n          email: 'updatedemail@example.com'\n        }\n\n        expect(response.status).to eq(403)\n      end\n\n      it \"raises an error with an invalid password\" do\n        put \"/u/update-activation-email.json\", params: {\n          username: inactive_user.username,\n          password: 'invalid-password',\n          email: 'updatedemail@example.com'\n        }\n\n        expect(response.status).to eq(403)\n      end\n\n      it \"raises an error for an active user\" do\n        put \"/u/update-activation-email.json\", params: {\n          username: Fabricate(:walter_white).username,\n          password: 'letscook',\n          email: 'updatedemail@example.com'\n        }\n\n        expect(response.status).to eq(403)\n      end\n\n      it \"raises an error when logged in\" do\n        sign_in(moderator)\n\n        put \"/u/update-activation-email.json\", params: {\n          username: inactive_user.username,\n          password: 'qwerqwer123',\n          email: 'updatedemail@example.com'\n        }\n\n        expect(response.status).to eq(403)\n      end\n\n      it \"raises an error when the new email is taken\" do\n        put \"/u/update-activation-email.json\", params: {\n          username: inactive_user.username,\n          password: 'qwerqwer123',\n          email: user.email\n        }\n\n        expect(response.status).to eq(422)\n      end\n\n      it \"can be updated\" do\n        user = inactive_user\n        token = user.email_tokens.first\n\n        put \"/u/update-activation-email.json\", params: {\n          username: user.username,\n          password: 'qwerqwer123',\n          email: 'updatedemail@example.com'\n        }\n\n        expect(response.status).to eq(200)\n\n        user.reload\n        expect(user.email).to eq('updatedemail@example.com')\n        expect(user.email_tokens.where(email: 'updatedemail@example.com', expired: false)).to be_present\n\n        token.reload\n        expect(token.expired?).to eq(true)\n      end\n    end\n  end\n\n  describe '#show' do\n    context \"anon\" do\n      let(:user) { Discourse.system_user }\n\n      it \"returns success\" do\n        get \"/u/#{user.username}.json\"\n        expect(response.status).to eq(200)\n        parsed = response.parsed_body[\"user\"]\n\n        expect(parsed['username']).to eq(user.username)\n        expect(parsed[\"profile_hidden\"]).to be_blank\n        expect(parsed[\"trust_level\"]).to be_present\n      end\n\n      it \"returns a hidden profile\" do\n        user.user_option.update_column(:hide_profile_and_presence, true)\n\n        get \"/u/#{user.username}.json\"\n        expect(response.status).to eq(200)\n        parsed = response.parsed_body[\"user\"]\n\n        expect(parsed[\"username\"]).to eq(user.username)\n        expect(parsed[\"profile_hidden\"]).to eq(true)\n        expect(parsed[\"trust_level\"]).to be_blank\n      end\n\n      it \"should redirect to login page for anonymous user when profiles are hidden\" do\n        SiteSetting.hide_user_profiles_from_public = true\n        get \"/u/#{user.username}.json\"\n        expect(response).to redirect_to '/login'\n      end\n\n      describe \"user profile views\" do\n        it \"should track a user profile view for an anon user\" do\n          get \"/\"\n          UserProfileView.expects(:add).with(another_user.user_profile.id, request.remote_ip, nil)\n          get \"/u/#{another_user.username}.json\"\n        end\n\n        it \"skips tracking\" do\n          UserProfileView.expects(:add).never\n          get \"/u/#{user.username}.json\", params: { skip_track_visit: true }\n        end\n      end\n    end\n\n    context \"logged in\" do\n      before do\n        sign_in(user1)\n      end\n\n      it 'returns success' do\n        get \"/u/#{user1.username}.json\"\n        expect(response.status).to eq(200)\n        expect(response.headers['X-Robots-Tag']).to eq('noindex')\n\n        json = response.parsed_body\n\n        expect(json[\"user\"][\"has_title_badges\"]).to eq(false)\n      end\n\n      it \"returns not found when the username doesn't exist\" do\n        get \"/u/madeuppity.json\"\n        expect(response).not_to be_successful\n      end\n\n      it 'returns not found when the user is inactive' do\n        inactive = Fabricate(:user, active: false)\n        get \"/u/#{inactive.username}.json\"\n        expect(response).not_to be_successful\n      end\n\n      it 'returns success when show_inactive_accounts is true and user is logged in' do\n        SiteSetting.show_inactive_accounts = true\n        inactive = Fabricate(:user, active: false)\n        get \"/u/#{inactive.username}.json\"\n        expect(response.status).to eq(200)\n      end\n\n      it \"raises an error on invalid access\" do\n        Guardian.any_instance.expects(:can_see?).with(user1).returns(false)\n        get \"/u/#{user1.username}.json\"\n        expect(response).to be_forbidden\n      end\n\n      describe \"user profile views\" do\n        it \"should track a user profile view for a signed in user\" do\n          UserProfileView.expects(:add).with(another_user.user_profile.id, request.remote_ip, user1.id)\n          get \"/u/#{another_user.username}.json\"\n        end\n\n        it \"should not track a user profile view for a user viewing his own profile\" do\n          UserProfileView.expects(:add).never\n          get \"/u/#{user1.username}.json\"\n        end\n\n        it \"skips tracking\" do\n          UserProfileView.expects(:add).never\n          get \"/u/#{user1.username}.json\", params: { skip_track_visit: true }\n        end\n      end\n\n      context \"fetching a user by external_id\" do\n        before { user1.create_single_sign_on_record(external_id: '997', last_payload: '') }\n\n        it \"returns fetch for a matching external_id\" do\n          get \"/u/by-external/997.json\"\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"user\"][\"username\"]).to eq(user1.username)\n        end\n\n        it \"returns not found when external_id doesn't match\" do\n          get \"/u/by-external/99.json\"\n          expect(response).not_to be_successful\n        end\n\n        context \"for an external provider\" do\n          before do\n            sign_in(admin)\n            SiteSetting.enable_google_oauth2_logins = true\n            UserAssociatedAccount.create!(user: user1, provider_uid: 'myuid', provider_name: 'google_oauth2')\n          end\n\n          it \"doesn't work for non-admin\" do\n            sign_in(user1)\n            get \"/u/by-external/google_oauth2/myuid.json\"\n            expect(response.status).to eq(403)\n          end\n\n          it \"can fetch the user\" do\n            get \"/u/by-external/google_oauth2/myuid.json\"\n            expect(response.status).to eq(200)\n            expect(response.parsed_body[\"user\"][\"username\"]).to eq(user1.username)\n          end\n\n          it \"fails for disabled provider\" do\n            SiteSetting.enable_google_oauth2_logins = false\n            get \"/u/by-external/google_oauth2/myuid.json\"\n            expect(response.status).to eq(404)\n          end\n\n          it \"returns 404 for missing user\" do\n            get \"/u/by-external/google_oauth2/myotheruid.json\"\n            expect(response.status).to eq(404)\n          end\n        end\n      end\n\n      describe \"include_post_count_for\" do\n        fab!(:topic) { Fabricate(:topic) }\n\n        before_all do\n          Fabricate(:post, user: user1, topic: topic)\n          Fabricate(:post, user: admin, topic: topic)\n          Fabricate(:post, user: admin, topic: topic, post_type: Post.types[:whisper])\n        end\n\n        it \"includes only visible posts\" do\n          get \"/u/#{admin.username}.json\", params: { include_post_count_for: topic.id }\n          topic_post_count = response.parsed_body.dig(\"user\", \"topic_post_count\")\n          expect(topic_post_count[topic.id.to_s]).to eq(1)\n        end\n\n        it \"includes all post types for staff members\" do\n          sign_in(admin)\n\n          get \"/u/#{admin.username}.json\", params: { include_post_count_for: topic.id }\n          topic_post_count = response.parsed_body.dig(\"user\", \"topic_post_count\")\n          expect(topic_post_count[topic.id.to_s]).to eq(2)\n        end\n      end\n    end\n\n    it \"should be able to view a user\" do\n      get \"/u/#{user1.username}\"\n\n      expect(response.status).to eq(200)\n      expect(response.body).to include(user1.username)\n    end\n\n    describe 'when username contains a period' do\n      before_all do\n        user1.update!(username: 'test.test')\n      end\n\n      it \"should be able to view a user\" do\n        get \"/u/#{user1.username}\"\n\n        expect(response.status).to eq(200)\n        expect(response.body).to include(user1.username)\n      end\n    end\n  end\n\n  describe \"#show_card\" do\n    context \"anon\" do\n      let(:user) { Discourse.system_user }\n\n      it \"returns success\" do\n        get \"/u/#{user.username}/card.json\"\n        expect(response.status).to eq(200)\n        parsed = response.parsed_body[\"user\"]\n\n        expect(parsed[\"username\"]).to eq(user.username)\n        expect(parsed[\"profile_hidden\"]).to be_blank\n        expect(parsed[\"trust_level\"]).to be_present\n      end\n\n      it \"should redirect to login page for anonymous user when profiles are hidden\" do\n        SiteSetting.hide_user_profiles_from_public = true\n        get \"/u/#{user.username}/card.json\"\n        expect(response).to redirect_to '/login'\n      end\n    end\n\n    context \"logged in\" do\n      before do\n        sign_in(user1)\n      end\n\n      it 'works correctly' do\n        get \"/u/#{user1.username}/card.json\"\n        expect(response.status).to eq(200)\n\n        json = response.parsed_body\n\n        expect(json[\"user\"][\"associated_accounts\"]).to eq(nil) # Not serialized in card\n        expect(json[\"user\"][\"username\"]).to eq(user1.username)\n      end\n\n      it \"returns not found when the username doesn't exist\" do\n        get \"/u/madeuppity/card.json\"\n        expect(response).not_to be_successful\n      end\n\n      it \"raises an error on invalid access\" do\n        Guardian.any_instance.expects(:can_see?).with(user1).returns(false)\n        get \"/u/#{user1.username}/card.json\"\n        expect(response).to be_forbidden\n      end\n    end\n  end\n\n  describe \"#cards\" do\n    fab!(:user) { Discourse.system_user }\n    fab!(:user2) { Fabricate(:user) }\n\n    it \"returns success\" do\n      get \"/user-cards.json?user_ids=#{user.id},#{user2.id}\"\n      expect(response.status).to eq(200)\n      parsed = response.parsed_body[\"users\"]\n\n      expect(parsed.map { |u| u[\"username\"] }).to contain_exactly(user.username, user2.username)\n    end\n\n    it \"should redirect to login page for anonymous user when profiles are hidden\" do\n      SiteSetting.hide_user_profiles_from_public = true\n      get \"/user-cards.json?user_ids=#{user.id},#{user2.id}\"\n      expect(response).to redirect_to '/login'\n    end\n\n    context '`hide_profile_and_presence` user option is checked' do\n      before do\n        user2.user_option.update_columns(hide_profile_and_presence: true)\n      end\n\n      it \"does not include hidden profiles\" do\n        get \"/user-cards.json?user_ids=#{user.id},#{user2.id}\"\n        expect(response.status).to eq(200)\n        parsed = response.parsed_body[\"users\"]\n\n        expect(parsed.map { |u| u[\"username\"] }).to contain_exactly(user.username)\n      end\n\n      it \"does include hidden profiles when `allow_users_to_hide_profile` is false\" do\n        SiteSetting.allow_users_to_hide_profile = false\n\n        get \"/user-cards.json?user_ids=#{user.id},#{user2.id}\"\n        expect(response.status).to eq(200)\n        parsed = response.parsed_body[\"users\"]\n\n        expect(parsed.map { |u| u[\"username\"] }).to contain_exactly(user.username, user2.username)\n      end\n    end\n  end\n\n  describe '#badges' do\n    it \"renders fine by default\" do\n      get \"/u/#{user1.username}/badges\"\n      expect(response.status).to eq(200)\n    end\n\n    it \"fails if badges are disabled\" do\n      SiteSetting.enable_badges = false\n      get \"/u/#{user1.username}/badges\"\n      expect(response.status).to eq(404)\n    end\n  end\n\n  describe \"#account_created\" do\n    it \"returns a message when no session is present\" do\n      get \"/u/account-created\"\n\n      expect(response.status).to eq(200)\n\n      body = response.body\n\n      expect(body).to match(I18n.t('activation.missing_session'))\n    end\n\n    it \"redirects when the user is logged in\" do\n      sign_in(user1)\n\n      get \"/u/account-created\"\n\n      expect(response).to redirect_to(\"/\")\n    end\n\n    context 'when cookies contains a destination URL' do\n      it 'should redirect to the URL' do\n        sign_in(user1)\n\n        destination_url = 'http://thisisasite.com/somepath'\n        cookies[:destination_url] = destination_url\n\n        get \"/u/account-created\"\n\n        expect(response).to redirect_to(destination_url)\n      end\n    end\n\n    context \"when the user account is created\" do\n      include ApplicationHelper\n\n      it \"returns the message when set in the session\" do\n        user1 = create_user\n        get \"/u/account-created\"\n\n        expect(response.status).to eq(200)\n\n        expect(response.body).to have_tag(\"div#data-preloaded\") do |element|\n          json = JSON.parse(element.current_scope.attribute('data-preloaded').value)\n          expect(json['accountCreated']).to include(\n            \"{\\\"message\\\":\\\"#{I18n.t(\"login.activate_email\", email: user1.email).gsub!(\"</\", \"<\\\\/\")}\\\",\\\"show_controls\\\":true,\\\"username\\\":\\\"#{user1.username}\\\",\\\"email\\\":\\\"#{user1.email}\\\"}\"\n          )\n        end\n      end\n    end\n  end\n\n  describe '#search_users' do\n    fab!(:topic) { Fabricate :topic }\n    let(:user)  { Fabricate :user, username: \"joecabot\", name: \"Lawrence Tierney\" }\n    let(:post1) { Fabricate(:post, user: user, topic: topic) }\n    let(:staged_user) { Fabricate(:user, staged: true) }\n\n    before do\n      SearchIndexer.enable\n      post1\n    end\n\n    it \"searches when provided the term only\" do\n      get \"/u/search/users.json\", params: { term: user.name.split(\" \").last }\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"users\"].map { |u| u[\"username\"] }).to include(user.username)\n    end\n\n    it \"searches when provided the topic only\" do\n      get \"/u/search/users.json\", params: { topic_id: topic.id }\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"users\"].map { |u| u[\"username\"] }).to include(user.username)\n    end\n\n    it \"searches when provided the term and topic\" do\n      get \"/u/search/users.json\", params: {\n        term: user.name.split(\" \").last, topic_id: topic.id\n      }\n\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"users\"].map { |u| u[\"username\"] }).to include(user.username)\n    end\n\n    it \"searches only for users who have access to private topic\" do\n      searching_user = Fabricate(:user)\n      privileged_user = Fabricate(:user, trust_level: 4, username: \"joecabit\", name: \"Lawrence Tierney\")\n      privileged_group = Fabricate(:group)\n      privileged_group.add(searching_user)\n      privileged_group.add(privileged_user)\n      privileged_group.save\n\n      category = Fabricate(:category)\n      category.set_permissions(privileged_group => :readonly)\n      category.save\n\n      private_topic = Fabricate(:topic, category: category)\n\n      sign_in(searching_user)\n      get \"/u/search/users.json\", params: {\n        term: user.name.split(\" \").last, topic_id: private_topic.id, topic_allowed_users: \"true\"\n      }\n\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"users\"].map { |u| u[\"username\"] }).to_not include(user.username)\n      expect(json[\"users\"].map { |u| u[\"username\"] }).to include(privileged_user.username)\n    end\n\n    it \"interprets blank category id correctly\" do\n      pm_topic = Fabricate(:private_message_post).topic\n      sign_in(pm_topic.user)\n      get \"/u/search/users.json\", params: {\n        term: \"\", topic_id: pm_topic.id, category_id: \"\"\n      }\n      expect(response.status).to eq(200)\n    end\n\n    context 'limit' do\n      it \"returns an error if value is invalid\" do\n        get \"/u/search/users.json\", params: { limit: '-1' }\n        expect(response.status).to eq(400)\n      end\n    end\n\n    context \"when `enable_names` is true\" do\n      before do\n        SiteSetting.enable_names = true\n      end\n\n      it \"returns names\" do\n        get \"/u/search/users.json\", params: { term: user.name }\n        json = response.parsed_body\n        expect(json[\"users\"].map { |u| u[\"name\"] }).to include(user.name)\n      end\n    end\n\n    context \"when `enable_names` is false\" do\n      before do\n        SiteSetting.enable_names = false\n      end\n\n      it \"returns names\" do\n        get \"/u/search/users.json\", params: { term: user.name }\n        json = response.parsed_body\n        expect(json[\"users\"].map { |u| u[\"name\"] }).not_to include(user.name)\n      end\n    end\n\n    context 'groups' do\n      fab!(:mentionable_group) do\n        Fabricate(:group,\n          mentionable_level: Group::ALIAS_LEVELS[:everyone],\n          messageable_level: Group::ALIAS_LEVELS[:nobody],\n          visibility_level: Group.visibility_levels[:public],\n          name: 'aaa1'\n        )\n      end\n\n      fab!(:mentionable_group_2) do\n        Fabricate(:group,\n          mentionable_level: Group::ALIAS_LEVELS[:everyone],\n          messageable_level: Group::ALIAS_LEVELS[:nobody],\n          visibility_level: Group.visibility_levels[:logged_on_users],\n          name: 'aaa2'\n        )\n      end\n\n      fab!(:messageable_group) do\n        Fabricate(:group,\n          mentionable_level: Group::ALIAS_LEVELS[:nobody],\n          messageable_level: Group::ALIAS_LEVELS[:everyone],\n          visibility_level: Group.visibility_levels[:logged_on_users],\n          name: 'aaa3'\n        )\n      end\n\n      fab!(:private_group) do\n        Fabricate(:group,\n          mentionable_level: Group::ALIAS_LEVELS[:members_mods_and_admins],\n          messageable_level: Group::ALIAS_LEVELS[:members_mods_and_admins],\n          visibility_level: Group.visibility_levels[:members],\n          name: 'aaa4'\n        )\n      end\n\n      describe 'when signed in' do\n        before do\n          sign_in(user)\n        end\n\n        it \"does not search for groups if there is no term\" do\n          get \"/u/search/users.json\", params: { include_groups: \"true\" }\n\n          expect(response.status).to eq(200)\n\n          groups = response.parsed_body[\"groups\"]\n          expect(groups).to eq(nil)\n        end\n\n        it \"only returns visible groups\" do\n          get \"/u/search/users.json\", params: { include_groups: \"true\", term: 'a' }\n\n          expect(response.status).to eq(200)\n\n          groups = response.parsed_body[\"groups\"]\n\n          expect(groups.map { |group| group['name'] })\n            .to_not include(private_group.name)\n        end\n\n        it 'allows plugins to register custom groups filter' do\n          get \"/u/search/users.json\", params: { include_groups: \"true\", term: \"a\" }\n\n          expect(response.status).to eq(200)\n          groups = response.parsed_body[\"groups\"]\n          expect(groups.count).to eq(6)\n\n          plugin = Plugin::Instance.new\n          plugin.register_groups_callback_for_users_search_controller_action(:admins_filter) do |original_groups, user|\n            original_groups.where(name: \"admins\")\n          end\n          get \"/u/search/users.json\", params: { include_groups: \"true\", admins_filter: \"true\", term: \"a\" }\n          expect(response.status).to eq(200)\n          groups = response.parsed_body[\"groups\"]\n          expect(groups).to eq([{ \"name\" => \"admins\", \"full_name\" => nil }])\n\n          DiscoursePluginRegistry.reset!\n        end\n\n        it \"doesn't search for groups\" do\n          get \"/u/search/users.json\", params: {\n            include_mentionable_groups: 'false',\n            include_messageable_groups: 'false',\n            term: 'a'\n          }\n\n          expect(response.status).to eq(200)\n          expect(response.parsed_body).not_to have_key(:groups)\n        end\n\n        it \"searches for messageable groups\" do\n          get \"/u/search/users.json\", params: {\n            include_mentionable_groups: 'false',\n            include_messageable_groups: 'true',\n            term: 'a'\n          }\n\n          expect(response.status).to eq(200)\n\n          expect(response.parsed_body[\"groups\"].map { |group| group['name'] })\n            .to contain_exactly(messageable_group.name, Group.find(Group::AUTO_GROUPS[:moderators]).name)\n        end\n\n        it 'searches for mentionable groups' do\n          get \"/u/search/users.json\", params: {\n            include_messageable_groups: 'false',\n            include_mentionable_groups: 'true',\n            term: 'a'\n          }\n\n          expect(response.status).to eq(200)\n\n          groups = response.parsed_body[\"groups\"]\n\n          expect(groups.map { |group| group['name'] })\n            .to contain_exactly(mentionable_group.name, mentionable_group_2.name)\n        end\n      end\n\n      describe 'when not signed in' do\n        it 'should not include mentionable/messageable groups' do\n          get \"/u/search/users.json\", params: {\n            include_mentionable_groups: 'false',\n            include_messageable_groups: 'false',\n            term: 'a'\n          }\n\n          expect(response.status).to eq(200)\n          expect(response.parsed_body).not_to have_key(:groups)\n\n          get \"/u/search/users.json\", params: {\n            include_mentionable_groups: 'false',\n            include_messageable_groups: 'true',\n            term: 'a'\n          }\n\n          expect(response.status).to eq(200)\n          expect(response.parsed_body).not_to have_key(:groups)\n\n          get \"/u/search/users.json\", params: {\n            include_messageable_groups: 'false',\n            include_mentionable_groups: 'true',\n            term: 'a'\n          }\n\n          expect(response.status).to eq(200)\n          expect(response.parsed_body).not_to have_key(:groups)\n        end\n      end\n\n      describe 'when searching by group name' do\n        fab!(:exclusive_group) { Fabricate(:group) }\n\n        it 'return results if the user is a group member' do\n          exclusive_group.add(user)\n\n          get \"/u/search/users.json\", params: {\n            group: exclusive_group.name,\n            term: user.username\n          }\n\n          expect(users_found).to contain_exactly(user.username)\n        end\n\n        it 'does not return results if the user is not a group member' do\n          get \"/u/search/users.json\", params: {\n            group: exclusive_group.name,\n            term: user.username\n          }\n\n          expect(users_found).to be_empty\n        end\n\n        it 'returns results if the user is member of one of the groups' do\n          exclusive_group.add(user)\n\n          get \"/u/search/users.json\", params: {\n            groups: [exclusive_group.name],\n            term: user.username\n          }\n\n          expect(users_found).to contain_exactly(user.username)\n        end\n\n        it 'does not return results if the user is not a member of the groups' do\n          get \"/u/search/users.json\", params: {\n            groups: [exclusive_group.name],\n            term: user.username\n          }\n\n          expect(users_found).to be_empty\n        end\n\n        def users_found\n          response.parsed_body['users'].map { |u| u['username'] }\n        end\n      end\n    end\n\n    context '`include_staged_users`' do\n      it \"includes staged users when the param is true\" do\n        get \"/u/search/users.json\", params: { term: staged_user.name, include_staged_users: true }\n        json = response.parsed_body\n        expect(json[\"users\"].map { |u| u[\"name\"] }).to include(staged_user.name)\n      end\n\n      it \"doesn't include staged users when the param is not passed\" do\n        get \"/u/search/users.json\", params: { term: staged_user.name }\n        json = response.parsed_body\n        expect(json[\"users\"].map { |u| u[\"name\"] }).not_to include(staged_user.name)\n      end\n\n      it \"doesn't include staged users when the param explicitly set to false\" do\n        get \"/u/search/users.json\", params: { term: staged_user.name, include_staged_users: false }\n        json = response.parsed_body\n        expect(json[\"users\"].map { |u| u[\"name\"] }).not_to include(staged_user.name)\n      end\n    end\n\n    context '`last_seen_users`' do\n      it \"returns results when the param is true\" do\n        get \"/u/search/users.json\", params: { last_seen_users: true }\n\n        json = response.parsed_body\n        expect(json[\"users\"]).not_to be_empty\n      end\n\n      it \"respects limit parameter at the same time\" do\n        limit = 3\n        get \"/u/search/users.json\", params: { last_seen_users: true, limit: limit }\n\n        json = response.parsed_body\n        expect(json[\"users\"]).not_to be_empty\n        expect(json[\"users\"].size).to eq(limit)\n      end\n    end\n  end\n\n  describe '#email_login' do\n    before do\n      SiteSetting.enable_local_logins_via_email = true\n    end\n\n    it \"enqueues the right email\" do\n      post \"/u/email-login.json\", params: { login: user1.email }\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body['user_found']).to eq(true)\n\n      job_args = Jobs::CriticalUserEmail.jobs.last[\"args\"].first\n      expect(job_args[\"user_id\"]).to eq(user1.id)\n      expect(job_args[\"type\"]).to eq(\"email_login\")\n      expect(EmailToken.hash_token(job_args[\"email_token\"])).to eq(user1.email_tokens.last.token_hash)\n    end\n\n    describe 'when enable_local_logins_via_email is disabled' do\n      before do\n        SiteSetting.enable_local_logins_via_email = false\n      end\n\n      it 'should return the right response' do\n        post \"/u/email-login.json\", params: { login: user1.email }\n        expect(response.status).to eq(404)\n      end\n    end\n\n    describe 'when username or email is not valid' do\n      it 'should not enqueue the email to login' do\n        post \"/u/email-login.json\", params: { login: '@random' }\n\n        expect(response.status).to eq(200)\n        json = response.parsed_body\n        expect(json['user_found']).to eq(false)\n        expect(json['hide_taken']).to eq(false)\n        expect(Jobs::CriticalUserEmail.jobs).to eq([])\n      end\n    end\n\n    describe 'when hide_email_address_taken is true' do\n      it 'should return the right response' do\n        SiteSetting.hide_email_address_taken = true\n        post \"/u/email-login.json\", params: { login: user1.email }\n\n        expect(response.status).to eq(200)\n        json = response.parsed_body\n        expect(json.has_key?('user_found')).to eq(false)\n        expect(json['hide_taken']).to eq(true)\n      end\n    end\n\n    describe \"when user is already logged in\" do\n      it 'should redirect to the root path' do\n        sign_in(user1)\n        post \"/u/email-login.json\", params: { login: user1.email }\n\n        expect(response).to redirect_to(\"/\")\n      end\n    end\n  end\n\n  describe '#create_second_factor_totp' do\n    context 'when not logged in' do\n      it 'should return the right response' do\n        post \"/users/second_factors.json\", params: {\n          password: 'wrongpassword'\n        }\n\n        expect(response.status).to eq(403)\n      end\n    end\n\n    context 'when logged in' do\n      before do\n        sign_in(user1)\n      end\n\n      describe 'create 2fa request' do\n        it 'fails on incorrect password' do\n          ApplicationController.any_instance.expects(:secure_session).returns(\"confirmed-password-#{user1.id}\" => \"false\")\n          post \"/users/create_second_factor_totp.json\"\n\n          expect(response.status).to eq(403)\n        end\n\n        describe 'when local logins are disabled' do\n          it 'should return the right response' do\n            SiteSetting.enable_local_logins = false\n\n            post \"/users/create_second_factor_totp.json\"\n\n            expect(response.status).to eq(404)\n          end\n        end\n\n        describe 'when SSO is enabled' do\n          it 'should return the right response' do\n            SiteSetting.discourse_connect_url = 'http://someurl.com'\n            SiteSetting.enable_discourse_connect = true\n\n            post \"/users/create_second_factor_totp.json\"\n\n            expect(response.status).to eq(404)\n          end\n        end\n\n        it 'succeeds on correct password' do\n          ApplicationController.any_instance.stubs(:secure_session).returns(\"confirmed-password-#{user1.id}\" => \"true\")\n          post \"/users/create_second_factor_totp.json\"\n\n          expect(response.status).to eq(200)\n\n          response_body = response.parsed_body\n\n          expect(response_body['key']).to be_present\n          expect(response_body['qr']).to be_present\n        end\n      end\n    end\n  end\n\n  describe \"#enable_second_factor_totp\" do\n    before do\n      sign_in(user1)\n    end\n\n    def create_totp\n      stub_secure_session_confirmed\n      post \"/users/create_second_factor_totp.json\"\n    end\n\n    it \"creates a totp for the user successfully\" do\n      create_totp\n      staged_totp_key = read_secure_session[\"staged-totp-#{user1.id}\"]\n      token = ROTP::TOTP.new(staged_totp_key).now\n\n      post \"/users/enable_second_factor_totp.json\", params: { name: \"test\", second_factor_token: token }\n\n      expect(response.status).to eq(200)\n      expect(user1.user_second_factors.count).to eq(1)\n    end\n\n    it \"rate limits by IP address\" do\n      RateLimiter.enable\n      RateLimiter.clear_all!\n\n      create_totp\n      staged_totp_key = read_secure_session[\"staged-totp-#{user1.id}\"]\n      token = ROTP::TOTP.new(staged_totp_key).now\n\n      7.times do |x|\n        post \"/users/enable_second_factor_totp.json\", params: { name: \"test\", second_factor_token: token  }\n      end\n\n      expect(response.status).to eq(429)\n    end\n\n    it \"rate limits by username\" do\n      RateLimiter.enable\n      RateLimiter.clear_all!\n\n      create_totp\n      staged_totp_key = read_secure_session[\"staged-totp-#{user1.id}\"]\n      token = ROTP::TOTP.new(staged_totp_key).now\n\n      7.times do |x|\n        post \"/users/enable_second_factor_totp.json\", params: { name: \"test\", second_factor_token: token  }, env: { \"REMOTE_ADDR\": \"1.2.3.#{x}\"  }\n      end\n\n      expect(response.status).to eq(429)\n    end\n\n    context \"when an incorrect token is provided\" do\n      before do\n        create_totp\n        post \"/users/enable_second_factor_totp.json\", params: { name: \"test\", second_factor_token: \"123456\" }\n      end\n      it \"shows a helpful error message to the user\" do\n        expect(response.parsed_body['error']).to eq(I18n.t(\"login.invalid_second_factor_code\"))\n      end\n    end\n\n    context \"when a name is not provided\" do\n      before do\n        create_totp\n        post \"/users/enable_second_factor_totp.json\", params: { second_factor_token: \"123456\" }\n      end\n      it \"shows a helpful error message to the user\" do\n        expect(response.parsed_body['error']).to eq(I18n.t(\"login.missing_second_factor_name\"))\n      end\n    end\n\n    context \"when a token is not provided\" do\n      before do\n        create_totp\n        post \"/users/enable_second_factor_totp.json\", params: { name: \"test\" }\n      end\n      it \"shows a helpful error message to the user\" do\n        expect(response.parsed_body['error']).to eq(I18n.t(\"login.missing_second_factor_code\"))\n      end\n    end\n  end\n\n  describe '#update_second_factor' do\n    fab!(:user_second_factor) { Fabricate(:user_second_factor_totp, user: user1) }\n\n    context 'when not logged in' do\n      it 'should return the right response' do\n        put \"/users/second_factor.json\"\n\n        expect(response.status).to eq(403)\n      end\n    end\n\n    context 'when logged in' do\n      before do\n        sign_in(user1)\n      end\n\n      context 'when user has totp setup' do\n        context 'when token is missing' do\n          it 'returns the right response' do\n            put \"/users/second_factor.json\", params: {\n              disable: 'true',\n              second_factor_target: UserSecondFactor.methods[:totp],\n              id: user_second_factor.id\n            }\n\n            expect(response.status).to eq(403)\n          end\n        end\n\n        context 'when token is valid' do\n          before do\n            stub_secure_session_confirmed\n          end\n          it 'should allow second factor for the user to be renamed' do\n            put \"/users/second_factor.json\", params: {\n                  name: 'renamed',\n                  second_factor_target: UserSecondFactor.methods[:totp],\n                  id: user_second_factor.id\n                }\n\n            expect(response.status).to eq(200)\n            expect(user1.reload.user_second_factors.totps.first.name).to eq(\"renamed\")\n          end\n\n          it 'should allow second factor for the user to be disabled' do\n            put \"/users/second_factor.json\", params: {\n                  disable: 'true',\n                  second_factor_target: UserSecondFactor.methods[:totp],\n                  id: user_second_factor.id\n            }\n\n            expect(response.status).to eq(200)\n            expect(user1.reload.user_second_factors.totps.first).to eq(nil)\n          end\n        end\n      end\n\n      context \"when user is updating backup codes\" do\n        context 'when token is missing' do\n          it 'returns the right response' do\n            put \"/users/second_factor.json\", params: {\n              second_factor_target: UserSecondFactor.methods[:backup_codes]\n            }\n\n            expect(response.status).to eq(403)\n          end\n        end\n\n        context 'when token is valid' do\n          before do\n            ApplicationController.any_instance.stubs(:secure_session).returns(\"confirmed-password-#{user1.id}\" => \"true\")\n          end\n          it 'should allow second factor backup for the user to be disabled' do\n            put \"/users/second_factor.json\", params: {\n                  second_factor_target: UserSecondFactor.methods[:backup_codes],\n                  disable: 'true'\n            }\n\n            expect(response.status).to eq(200)\n            expect(user1.reload.user_second_factors.backup_codes).to be_empty\n          end\n        end\n      end\n    end\n  end\n\n  describe '#create_second_factor_backup' do\n    fab!(:user_second_factor) { Fabricate(:user_second_factor_totp, user: user1) }\n\n    context 'when not logged in' do\n      it 'should return the right response' do\n        put \"/users/second_factors_backup.json\", params: {\n          second_factor_token: 'wrongtoken',\n          second_factor_method: UserSecondFactor.methods[:totp]\n        }\n\n        expect(response.status).to eq(403)\n      end\n    end\n\n    context 'when logged in' do\n      before do\n        sign_in(user1)\n      end\n\n      describe 'create 2fa request' do\n        it 'fails on incorrect password' do\n          ApplicationController.any_instance.expects(:secure_session).returns(\"confirmed-password-#{user1.id}\" => \"false\")\n          put \"/users/second_factors_backup.json\"\n\n          expect(response.status).to eq(403)\n        end\n\n        describe 'when local logins are disabled' do\n          it 'should return the right response' do\n            SiteSetting.enable_local_logins = false\n\n            put \"/users/second_factors_backup.json\"\n\n            expect(response.status).to eq(404)\n          end\n        end\n\n        describe 'when SSO is enabled' do\n          it 'should return the right response' do\n            SiteSetting.discourse_connect_url = 'http://someurl.com'\n            SiteSetting.enable_discourse_connect = true\n\n            put \"/users/second_factors_backup.json\"\n\n            expect(response.status).to eq(404)\n          end\n        end\n\n        it 'succeeds on correct password' do\n          ApplicationController.any_instance.expects(:secure_session).returns(\"confirmed-password-#{user1.id}\" => \"true\")\n\n          put \"/users/second_factors_backup.json\"\n\n          expect(response.status).to eq(200)\n\n          response_body = response.parsed_body\n\n          # we use SecureRandom.hex(16) for backup codes, ensure this continues to be the case\n          expect(response_body['backup_codes'].map(&:length)).to eq([32] * 10)\n        end\n      end\n    end\n  end\n\n  describe \"#create_second_factor_security_key\" do\n    it \"stores the challenge in the session and returns challenge data, user id, and supported algorithms\" do\n      create_second_factor_security_key\n      secure_session = read_secure_session\n      response_parsed = response.parsed_body\n      expect(response_parsed[\"challenge\"]).to eq(\n        Webauthn.challenge(user1, secure_session)\n      )\n      expect(response_parsed[\"rp_id\"]).to eq(\n        Webauthn.rp_id(user1, secure_session)\n      )\n      expect(response_parsed[\"rp_name\"]).to eq(\n        Webauthn.rp_name(user1, secure_session)\n      )\n      expect(response_parsed[\"user_secure_id\"]).to eq(\n        user1.reload.create_or_fetch_secure_identifier\n      )\n      expect(response_parsed[\"supported_algorithms\"]).to eq(\n        ::Webauthn::SUPPORTED_ALGORITHMS\n      )\n    end\n\n    context \"if the user has security key credentials already\" do\n      fab!(:user_security_key) { Fabricate(:user_security_key_with_random_credential, user: user1) }\n\n      it \"returns those existing active credentials\" do\n        create_second_factor_security_key\n        response_parsed = response.parsed_body\n        expect(response_parsed[\"existing_active_credential_ids\"]).to eq(\n          [user_security_key.credential_id]\n        )\n      end\n    end\n  end\n\n  describe \"#register_second_factor_security_key\" do\n    context \"when creation parameters are valid\" do\n      it \"creates a security key for the user\" do\n        simulate_localhost_webauthn_challenge\n        create_second_factor_security_key\n        response_parsed = response.parsed_body\n\n        post \"/u/register_second_factor_security_key.json\", params: valid_security_key_create_post_data\n\n        expect(user1.security_keys.count).to eq(1)\n        expect(user1.security_keys.last.credential_id).to eq(valid_security_key_create_post_data[:rawId])\n        expect(user1.security_keys.last.name).to eq(valid_security_key_create_post_data[:name])\n      end\n    end\n\n    context \"when the creation parameters are invalid\" do\n      it \"shows a security key error and does not create a key\" do\n        stub_as_dev_localhost\n        create_second_factor_security_key\n        response_parsed = response.parsed_body\n\n        post \"/u/register_second_factor_security_key.json\", params: {\n          id: \"bad id\",\n          rawId: \"bad rawId\",\n          type: \"public-key\",\n          attestation: \"bad attestation\",\n          clientData: Base64.encode64('{\"bad\": \"json\"}'),\n          name: \"My Bad Key\"\n        }\n\n        expect(user1.security_keys.count).to eq(0)\n        expect(response.parsed_body[\"error\"]).to eq(I18n.t(\"webauthn.validation.invalid_type_error\"))\n      end\n    end\n  end\n\n  describe '#disable_second_factor' do\n    context 'when logged in with secure session' do\n      before do\n        sign_in(user1)\n        stub_secure_session_confirmed\n      end\n      context 'when user has a registered totp and security key' do\n        before do\n          totp_second_factor = Fabricate(:user_second_factor_totp, user: user1)\n          security_key_second_factor = Fabricate(:user_security_key, user: user1, factor_type: UserSecurityKey.factor_types[:second_factor])\n        end\n\n        it 'should disable all totp and security keys' do\n          expect_enqueued_with(job: :critical_user_email, args: { type: :account_second_factor_disabled, user_id: user1.id }) do\n            put \"/u/disable_second_factor.json\"\n\n            expect(response.status).to eq(200)\n\n            expect(user1.reload.user_second_factors).to be_empty\n            expect(user1.security_keys).to be_empty\n          end\n        end\n      end\n    end\n  end\n\n  describe '#revoke_account' do\n    it 'errors for unauthorised users' do\n      post \"/u/#{user1.username}/preferences/revoke-account.json\", params: {\n        provider_name: 'facebook'\n      }\n      expect(response.status).to eq(403)\n\n      sign_in(another_user)\n\n      post \"/u/#{user1.username}/preferences/revoke-account.json\", params: {\n        provider_name: 'facebook'\n      }\n      expect(response.status).to eq(403)\n    end\n\n    context 'while logged in' do\n      before do\n        sign_in(user1)\n      end\n\n      it 'returns an error when there is no matching account' do\n        post \"/u/#{user1.username}/preferences/revoke-account.json\", params: {\n          provider_name: 'facebook'\n        }\n        expect(response.status).to eq(404)\n      end\n\n      context \"with fake provider\" do\n        let(:authenticator) do\n          Class.new(Auth::Authenticator) do\n            attr_accessor :can_revoke\n            def name\n              \"testprovider\"\n            end\n\n            def enabled?\n              true\n            end\n\n            def description_for_user(user)\n              \"an account\"\n            end\n\n            def can_revoke?\n              can_revoke\n            end\n\n            def revoke(user, skip_remote: false)\n              true\n            end\n          end.new\n        end\n\n        before do\n          DiscoursePluginRegistry.register_auth_provider(Auth::AuthProvider.new(authenticator: authenticator))\n        end\n\n        after do\n          DiscoursePluginRegistry.reset!\n        end\n\n        it 'returns an error when revoking is not allowed' do\n          authenticator.can_revoke = false\n\n          post \"/u/#{user1.username}/preferences/revoke-account.json\", params: {\n            provider_name: 'testprovider'\n          }\n          expect(response.status).to eq(404)\n\n          authenticator.can_revoke = true\n          post \"/u/#{user1.username}/preferences/revoke-account.json\", params: {\n            provider_name: 'testprovider'\n          }\n          expect(response.status).to eq(200)\n        end\n\n        it 'works' do\n          authenticator.can_revoke = true\n\n          post \"/u/#{user1.username}/preferences/revoke-account.json\", params: {\n            provider_name: 'testprovider'\n          }\n          expect(response.status).to eq(200)\n        end\n      end\n\n    end\n\n  end\n\n  describe '#revoke_auth_token' do\n\n    context 'while logged in' do\n      before do\n        2.times { sign_in(user1) }\n      end\n\n      it 'logs user out' do\n        ids = user1.user_auth_tokens.order(:created_at).pluck(:id)\n\n        post \"/u/#{user1.username}/preferences/revoke-auth-token.json\",\n          params: { token_id: ids[0] }\n\n        expect(response.status).to eq(200)\n\n        user1.user_auth_tokens.reload\n        expect(user1.user_auth_tokens.count).to eq(1)\n        expect(user1.user_auth_tokens.first.id).to eq(ids[1])\n      end\n\n      it 'checks if token exists' do\n        ids = user1.user_auth_tokens.order(:created_at).pluck(:id)\n\n        post \"/u/#{user1.username}/preferences/revoke-auth-token.json\",\n          params: { token_id: ids[0] }\n\n        expect(response.status).to eq(200)\n\n        post \"/u/#{user1.username}/preferences/revoke-auth-token.json\",\n          params: { token_id: ids[0] }\n\n        expect(response.status).to eq(400)\n      end\n\n      it 'does not let user log out of current session' do\n        token = UserAuthToken.generate!(user_id: user1.id)\n        cookie = create_auth_cookie(\n          token: token.unhashed_auth_token,\n          user_id: user1.id,\n          trust_level: user1.trust_level,\n          issued_at: 5.minutes.ago,\n        )\n\n        post \"/u/#{user1.username}/preferences/revoke-auth-token.json\",\n          params: { token_id: token.id },\n          headers: { \"HTTP_COOKIE\" => \"_t=#{cookie}\" }\n\n        expect(token.reload.id).to be_present\n        expect(response.status).to eq(400)\n      end\n\n      it 'logs user out from everywhere if token_id is not present' do\n        post \"/u/#{user1.username}/preferences/revoke-auth-token.json\"\n\n        expect(response.status).to eq(200)\n        expect(user1.user_auth_tokens.count).to eq(0)\n      end\n\n    end\n\n  end\n\n  describe '#list_second_factors' do\n    let(:user) { user1 }\n\n    before do\n      sign_in(user)\n    end\n\n    context 'when SSO is enabled' do\n      before do\n        SiteSetting.discourse_connect_url = 'https://discourse.test/sso'\n        SiteSetting.enable_discourse_connect = true\n      end\n\n      it 'does not allow access' do\n        post \"/u/second_factors.json\"\n        expect(response.status).to eq(404)\n      end\n    end\n\n    context 'when local logins are not enabled' do\n      before do\n        SiteSetting.enable_local_logins = false\n      end\n\n      it 'does not allow access' do\n        post \"/u/second_factors.json\"\n        expect(response.status).to eq(404)\n      end\n    end\n\n    context 'when the site settings allow second factors' do\n      before do\n        SiteSetting.enable_local_logins = true\n        SiteSetting.enable_discourse_connect = false\n      end\n\n      context 'when the password parameter is not provided' do\n        let(:password) { '' }\n\n        before do\n          post \"/u/second_factors.json\", params: { password: password }\n        end\n\n        it 'returns password required response' do\n          expect(response.status).to eq(200)\n          response_body = response.parsed_body\n          expect(response_body['password_required']).to eq(true)\n        end\n      end\n\n      context 'when the password is provided' do\n        fab!(:user) { Fabricate(:user, password: '8555039dd212cc66ec68') }\n\n        context 'when the password is correct' do\n          let(:password) { '8555039dd212cc66ec68' }\n\n          it 'returns a list of enabled totps and security_key second factors' do\n            totp_second_factor = Fabricate(:user_second_factor_totp, user: user)\n            security_key_second_factor = Fabricate(:user_security_key, user: user, factor_type: UserSecurityKey.factor_types[:second_factor])\n\n            post \"/u/second_factors.json\", params: { password: password }\n\n            expect(response.status).to eq(200)\n            response_body = response.parsed_body\n            expect(response_body['totps'].map { |second_factor| second_factor['id'] }).to include(totp_second_factor.id)\n            expect(response_body['security_keys'].map { |second_factor| second_factor['id'] }).to include(security_key_second_factor.id)\n          end\n        end\n\n        context 'when the password is not correct' do\n          let(:password) { 'wrongpassword' }\n\n          it 'returns the incorrect password response' do\n\n            post \"/u/second_factors.json\", params: { password: password }\n\n            response_body = response.parsed_body\n            expect(response_body['error']).to eq(\n              I18n.t(\"login.incorrect_password\")\n            )\n          end\n        end\n      end\n    end\n  end\n\n  describe '#feature_topic' do\n    fab!(:topic) { Fabricate(:topic) }\n    fab!(:other_topic) { Fabricate(:topic) }\n    fab!(:private_message) { Fabricate(:private_message_topic, user: another_user) }\n    fab!(:category) { Fabricate(:category_with_definition) }\n\n    describe \"site setting enabled\" do\n      before do\n        SiteSetting.allow_featured_topic_on_user_profiles = true\n      end\n\n      it 'requires the user to be logged in' do\n        put \"/u/#{user1.username}/feature-topic.json\", params: { topic_id: topic.id }\n        expect(response.status).to eq(403)\n      end\n\n      it 'returns an error if the user tries to set for another user' do\n        sign_in(user1)\n        topic.update(user_id: another_user.id)\n        put \"/u/#{another_user.username}/feature-topic.json\", params: { topic_id: topic.id }\n        expect(response.status).to eq(403)\n      end\n\n      it 'returns an error if the topic is a PM' do\n        sign_in(another_user)\n        put \"/u/#{another_user.username}/feature-topic.json\", params: { topic_id: private_message.id }\n        expect(response.status).to eq(403)\n      end\n\n      it \"returns an error if the topic is not visible\" do\n        sign_in(user1)\n        topic.update_status('visible', false, user1)\n        put \"/u/#{user1.username}/feature-topic.json\", params: { topic_id: topic.id }\n        expect(response.status).to eq(403)\n      end\n\n      it \"returns an error if the topic's category is read_restricted\" do\n        sign_in(user1)\n        category.set_permissions({})\n        topic.update(category_id: category.id)\n        put \"/u/#{another_user.username}/feature-topic.json\", params: { topic_id: topic.id }\n        expect(response.status).to eq(403)\n      end\n\n      it 'sets featured_topic correctly for user created topic' do\n        sign_in(user1)\n        topic.update(user_id: user1.id)\n        put \"/u/#{user1.username}/feature-topic.json\", params: { topic_id: topic.id }\n        expect(response.status).to eq(200)\n        expect(user1.user_profile.featured_topic).to eq topic\n      end\n\n      it 'sets featured_topic correctly for non-user-created topic' do\n        sign_in(user1)\n        put \"/u/#{user1.username}/feature-topic.json\", params: { topic_id: other_topic.id }\n        expect(response.status).to eq(200)\n        expect(user1.user_profile.featured_topic).to eq other_topic\n      end\n\n      describe \"site setting disabled\" do\n        before do\n          SiteSetting.allow_featured_topic_on_user_profiles = false\n        end\n\n        it \"does not allow setting featured_topic for user_profiles\" do\n          sign_in(user1)\n          topic.update(user_id: user1.id)\n          put \"/u/#{user1.username}/feature-topic.json\", params: { topic_id: topic.id }\n          expect(response.status).to eq(403)\n        end\n      end\n    end\n  end\n\n  describe '#clear_featured_topic' do\n    fab!(:topic) { Fabricate(:topic) }\n\n    it 'requires the user to be logged in' do\n      put \"/u/#{user1.username}/clear-featured-topic.json\"\n      expect(response.status).to eq(403)\n    end\n\n    it 'returns an error if the the current user does not have access' do\n      sign_in(user1)\n      topic.update(user_id: another_user.id)\n      put \"/u/#{another_user.username}/clear-featured-topic.json\"\n      expect(response.status).to eq(403)\n    end\n\n    it 'clears the user_profiles featured_topic correctly' do\n      sign_in(user1)\n      topic.update(user: user1)\n      put \"/u/#{user1.username}/clear-featured-topic.json\"\n      expect(response.status).to eq(200)\n      expect(user1.user_profile.featured_topic).to eq nil\n    end\n  end\n\n  describe \"#bookmarks\" do\n    fab!(:bookmark1) { Fabricate(:bookmark, user: user1) }\n    fab!(:bookmark2) { Fabricate(:bookmark, user: user1) }\n    fab!(:bookmark3) { Fabricate(:bookmark) }\n\n    before do\n      TopicUser.change(user1.id, bookmark1.topic_id, total_msecs_viewed: 1)\n      TopicUser.change(user1.id, bookmark2.topic_id, total_msecs_viewed: 1)\n    end\n\n    it \"returns a list of serialized bookmarks for the user\" do\n      sign_in(user1)\n      get \"/u/#{user1.username}/bookmarks.json\"\n      expect(response.status).to eq(200)\n      expect(response.parsed_body['user_bookmark_list']['bookmarks'].map { |b| b['id'] }).to match_array([bookmark1.id, bookmark2.id])\n    end\n\n    it \"returns an .ics file of bookmark reminders for the user in date order\" do\n      bookmark1.update!(name: nil, reminder_at: 1.day.from_now)\n      bookmark2.update!(name: \"Some bookmark note\", reminder_at: 1.week.from_now)\n\n      sign_in(user1)\n      get \"/u/#{user1.username}/bookmarks.ics\"\n      expect(response.status).to eq(200)\n      expect(response.body).to eq(<<~ICS)\n        BEGIN:VCALENDAR\n        VERSION:2.0\n        PRODID:-//Discourse//#{Discourse.current_hostname}//#{Discourse.full_version}//EN\n        BEGIN:VEVENT\n        UID:bookmark_reminder_##{bookmark1.id}@#{Discourse.current_hostname}\n        DTSTAMP:#{bookmark1.updated_at.strftime(I18n.t(\"datetime_formats.formats.calendar_ics\"))}\n        DTSTART:#{bookmark1.reminder_at_ics}\n        DTEND:#{bookmark1.reminder_at_ics(offset: 1.hour)}\n        SUMMARY:#{bookmark1.topic.title}\n        DESCRIPTION:#{Discourse.base_url}/t/-/#{bookmark1.topic_id}\n        URL:#{Discourse.base_url}/t/-/#{bookmark1.topic_id}\n        END:VEVENT\n        BEGIN:VEVENT\n        UID:bookmark_reminder_##{bookmark2.id}@#{Discourse.current_hostname}\n        DTSTAMP:#{bookmark2.updated_at.strftime(I18n.t(\"datetime_formats.formats.calendar_ics\"))}\n        DTSTART:#{bookmark2.reminder_at_ics}\n        DTEND:#{bookmark2.reminder_at_ics(offset: 1.hour)}\n        SUMMARY:Some bookmark note\n        DESCRIPTION:#{Discourse.base_url}/t/-/#{bookmark2.topic_id}\n        URL:#{Discourse.base_url}/t/-/#{bookmark2.topic_id}\n        END:VEVENT\n        END:VCALENDAR\n      ICS\n    end\n\n    it \"does not show another user's bookmarks\" do\n      sign_in(user1)\n      get \"/u/#{bookmark3.user.username}/bookmarks.json\"\n      expect(response.status).to eq(403)\n    end\n\n    it \"shows a helpful message if no bookmarks are found\" do\n      bookmark1.destroy\n      bookmark2.destroy\n      bookmark3.destroy\n      sign_in(user1)\n      get \"/u/#{user1.username}/bookmarks.json\"\n      expect(response.status).to eq(200)\n      expect(response.parsed_body['bookmarks']).to eq([])\n    end\n\n    it \"shows a helpful message if no bookmarks are found for the search\" do\n      sign_in(user1)\n      get \"/u/#{user1.username}/bookmarks.json\", params: {\n        q: 'badsearch'\n      }\n      expect(response.status).to eq(200)\n      expect(response.parsed_body['bookmarks']).to eq([])\n    end\n  end\n\n  describe \"#private_message_topic_tracking_state\" do\n    fab!(:user_2) { Fabricate(:user) }\n\n    fab!(:private_message) do\n      create_post(\n        user: user1,\n        target_usernames: [user_2.username],\n        archetype: Archetype.private_message\n      ).topic\n    end\n\n    before do\n      sign_in(user_2)\n    end\n\n    it 'does not allow an unauthorized user to access the state of another user' do\n      get \"/u/#{user1.username}/private-message-topic-tracking-state.json\"\n\n      expect(response.status).to eq(403)\n    end\n\n    it 'returns the right response' do\n      get \"/u/#{user_2.username}/private-message-topic-tracking-state.json\"\n\n      expect(response.status).to eq(200)\n\n      topic_state = response.parsed_body.first\n\n      expect(topic_state[\"topic_id\"]).to eq(private_message.id)\n      expect(topic_state[\"highest_post_number\"]).to eq(1)\n      expect(topic_state[\"last_read_post_number\"]).to eq(nil)\n      expect(topic_state[\"notification_level\"]).to eq(NotificationLevels.all[:watching])\n      expect(topic_state[\"group_ids\"]).to eq([])\n    end\n  end\n\n  describe \"#reset_recent_searches\" do\n    it 'does nothing for anon' do\n      delete \"/u/recent-searches.json\"\n      expect(response.status).to eq(403)\n    end\n\n    it 'works for logged in user' do\n      sign_in(user1)\n      delete \"/u/recent-searches.json\"\n\n      expect(response.status).to eq(200)\n      user1.reload\n      expect(user1.user_option.oldest_search_log_date).to be_within(5.seconds).of(1.second.ago)\n    end\n  end\n\n  describe \"#recent_searches\" do\n    it 'does nothing for anon' do\n      get \"/u/recent-searches.json\"\n      expect(response.status).to eq(403)\n    end\n\n    it 'works for logged in user' do\n      sign_in(user1)\n      SiteSetting.log_search_queries = true\n      user1.user_option.update!(oldest_search_log_date: nil)\n\n      get \"/u/recent-searches.json\"\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"recent_searches\"]).to eq([])\n\n      SearchLog.create!(\n        term: \"old one\",\n        user_id: user1.id,\n        search_type: 1,\n        ip_address: '192.168.0.1',\n        created_at: 5.minutes.ago\n      )\n      SearchLog.create!(\n        term: \"also old\",\n        user_id: user1.id,\n        search_type: 1,\n        ip_address: '192.168.0.1',\n        created_at: 15.minutes.ago\n      )\n\n      get \"/u/recent-searches.json\"\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"recent_searches\"]).to eq([\"old one\", \"also old\"])\n\n      user1.user_option.update!(oldest_search_log_date: 20.minutes.ago)\n\n      get \"/u/recent-searches.json\"\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"recent_searches\"]).to eq([\"old one\", \"also old\"])\n\n      user1.user_option.update!(oldest_search_log_date: 10.seconds.ago)\n\n      get \"/u/recent-searches.json\"\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"recent_searches\"]).to eq([])\n\n      SearchLog.create!(\n        term: \"new search\",\n        user_id: user1.id,\n        search_type: 1,\n        ip_address: '192.168.0.1',\n        created_at: 2.seconds.ago\n      )\n\n      get \"/u/recent-searches.json\"\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"recent_searches\"]).to eq([\"new search\"])\n    end\n\n    it 'shows an error message when log_search_queries are off' do\n      sign_in(user1)\n      SiteSetting.log_search_queries = false\n\n      get \"/u/recent-searches.json\"\n\n      expect(response.status).to eq(403)\n      expect(response.parsed_body[\"error\"]).to eq(I18n.t(\"user_activity.no_log_search_queries\"))\n    end\n  end\n\n  def create_second_factor_security_key\n    sign_in(user1)\n    stub_secure_session_confirmed\n    post \"/u/create_second_factor_security_key.json\"\n  end\n\n  def stub_secure_session_confirmed\n    UsersController.any_instance.stubs(:secure_session_confirmed?).returns(true)\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\n# mixin for all Guardian methods dealing with user permissions\nmodule UserGuardian\n\n  def can_claim_reviewable_topic?(topic)\n    SiteSetting.reviewable_claiming != 'disabled' && can_review_topic?(topic)\n  end\n\n  def can_pick_avatar?(user_avatar, upload)\n    return false unless self.user\n    return true if is_admin?\n    # can always pick blank avatar\n    return true if !upload\n    return true if user_avatar.contains_upload?(upload.id)\n    return true if upload.user_id == user_avatar.user_id || upload.user_id == user.id\n\n    UserUpload.exists?(upload_id: upload.id, user_id: user.id)\n  end\n\n  def can_edit_user?(user)\n    is_me?(user) || is_staff?\n  end\n\n  def can_edit_username?(user)\n    return false if SiteSetting.auth_overrides_username?\n    return true if is_staff?\n    return false if SiteSetting.username_change_period <= 0\n    return false if is_anonymous?\n    is_me?(user) && ((user.post_count + user.topic_count) == 0 || user.created_at > SiteSetting.username_change_period.days.ago)\n  end\n\n  def can_edit_email?(user)\n    return false if SiteSetting.auth_overrides_email?\n    return false unless SiteSetting.email_editable?\n    return true if is_staff?\n    return false if is_anonymous?\n    can_edit?(user)\n  end\n\n  def can_edit_name?(user)\n    return false unless SiteSetting.enable_names?\n    return false if SiteSetting.auth_overrides_name?\n    return true if is_staff?\n    return false if is_anonymous?\n    can_edit?(user)\n  end\n\n  def can_see_notifications?(user)\n    is_me?(user) || is_admin?\n  end\n\n  def can_silence_user?(user)\n    user && is_staff? && not(user.staff?)\n  end\n\n  def can_unsilence_user?(user)\n    user && is_staff?\n  end\n\n  def can_delete_user?(user)\n    return false if user.nil? || user.admin?\n    if is_me?(user)\n      !SiteSetting.enable_discourse_connect &&\n      !user.has_more_posts_than?(SiteSetting.delete_user_self_max_post_count)\n    else\n      is_staff? && (\n        user.first_post_created_at.nil? ||\n          !user.has_more_posts_than?(User::MAX_STAFF_DELETE_POST_COUNT) ||\n          user.first_post_created_at > SiteSetting.delete_user_max_post_age.to_i.days.ago\n      )\n    end\n  end\n\n  def can_anonymize_user?(user)\n    is_staff? && !user.nil? && !user.staff?\n  end\n\n  def can_merge_user?(user)\n    is_admin? && !user.nil? && !user.staff?\n  end\n\n  def can_merge_users?(source_user, target_user)\n    can_merge_user?(source_user) && !target_user.nil?\n  end\n\n  def can_see_warnings?(user)\n    user && (is_me?(user) || is_staff?)\n  end\n\n  def can_reset_bounce_score?(user)\n    user && is_staff?\n  end\n\n  def can_check_emails?(user)\n    is_admin? || (is_staff? && SiteSetting.moderators_view_emails)\n  end\n\n  def can_check_sso_details?(user)\n    user && is_admin?\n  end\n\n  def restrict_user_fields?(user)\n    (user.trust_level == TrustLevel[0] && anonymous?) || !can_see_profile?(user)\n  end\n\n  def can_see_staff_info?(user)\n    user && is_staff?\n  end\n\n  def can_see_suspension_reason?(user)\n    return true unless SiteSetting.hide_suspension_reasons?\n    user == @user || is_staff?\n  end\n\n  def can_disable_second_factor?(user)\n    user && can_administer_user?(user)\n  end\n\n  def can_see_profile?(user)\n    return false if user.blank?\n    return true if !SiteSetting.allow_users_to_hide_profile?\n\n    # If a user has hidden their profile, restrict it to them and staff\n    if user.user_option.try(:hide_profile_and_presence?)\n      return is_me?(user) || is_staff?\n    end\n\n    true\n  end\n\n  def can_see_user_actions?(user, action_types)\n    return true if !@user.anonymous? && (@user.id == user.id || is_admin?)\n    (action_types & UserAction.private_types).empty?\n  end\n\n  def allowed_user_field_ids(user)\n    @allowed_user_field_ids ||= {}\n\n    is_staff_or_is_me = is_staff? || is_me?(user)\n    cache_key = is_staff_or_is_me ? :staff_or_me : :other\n\n    @allowed_user_field_ids[cache_key] ||=\n      begin\n        if is_staff_or_is_me\n          UserField.pluck(:id)\n        else\n          UserField.where(\"show_on_profile OR show_on_user_card\").pluck(:id)\n        end\n      end\n  end\n\n  def can_feature_topic?(user, topic)\n    return false if topic.nil?\n    return false if !SiteSetting.allow_featured_topic_on_user_profiles?\n    return false if !is_me?(user) && !is_staff?\n    return false if !topic.visible\n    return false if topic.read_restricted_category? || topic.private_message?\n    true\n  end\n\n  def can_see_review_queue?\n    is_staff? || (\n      SiteSetting.enable_category_group_moderation &&\n      Reviewable\n        .where(reviewable_by_group_id: @user.group_users.pluck(:group_id))\n        .where('category_id IS NULL or category_id IN (?)', allowed_category_ids)\n        .exists?\n    )\n  end\n\n  def can_see_summary_stats?(target_user)\n    true\n  end\n\n  def can_upload_profile_header?(user)\n    (is_me?(user) && user.has_trust_level?(SiteSetting.min_trust_level_to_allow_profile_background.to_i)) || is_staff?\n  end\n\n  def can_upload_user_card_background?(user)\n    (is_me?(user) && user.has_trust_level?(SiteSetting.min_trust_level_to_allow_user_card_background.to_i)) || is_staff?\n  end\n\n  def can_upload_external?\n    !ExternalUploadManager.user_banned?(user)\n  end\n\n  def can_delete_sso_record?(user)\n    SiteSetting.enable_discourse_connect && user && is_admin?\n  end\n\n  def can_change_tracking_preferences?(user)\n    (SiteSetting.allow_changing_staged_user_tracking || !user.staged) && can_edit_user?(user)\n  end\nend\n", "# frozen_string_literal: true\n\nrequire 'rails_helper'\nrequire 'rotp'\n\ndescribe UsersController do\n  fab!(:user) { Fabricate(:user) }\n  fab!(:user1) { Fabricate(:user) }\n  fab!(:another_user) { Fabricate(:user) }\n  fab!(:invitee) { Fabricate(:user) }\n  fab!(:inviter) { Fabricate(:user) }\n\n  fab!(:admin) { Fabricate(:admin) }\n  fab!(:moderator) { Fabricate(:moderator) }\n  fab!(:inactive_user) { Fabricate(:inactive_user) }\n\n  # Unfortunately, there are tests that depend on the user being created too\n  # late for fab! to work.\n  let(:user_deferred) { Fabricate(:user) }\n\n  describe \"#full account registration flow\" do\n    it \"will correctly handle honeypot and challenge\" do\n\n      get '/session/hp.json'\n      expect(response.status).to eq(200)\n\n      json = response.parsed_body\n\n      params = {\n        email: 'jane@jane.com',\n        name: 'jane',\n        username: 'jane',\n        password_confirmation: json['value'],\n        challenge: json['challenge'].reverse,\n        password: SecureRandom.hex\n      }\n\n      secure_session = SecureSession.new(session[\"secure_session_id\"])\n\n      expect(secure_session[UsersController::HONEYPOT_KEY]).to eq(json[\"value\"])\n      expect(secure_session[UsersController::CHALLENGE_KEY]).to eq(json[\"challenge\"])\n\n      post '/u.json', params: params\n\n      expect(response.status).to eq(200)\n\n      jane = User.find_by(username: 'jane')\n\n      expect(jane.email).to eq('jane@jane.com')\n\n      expect(secure_session[UsersController::HONEYPOT_KEY]).to eq(nil)\n      expect(secure_session[UsersController::CHALLENGE_KEY]).to eq(nil)\n    end\n  end\n\n  describe '#perform_account_activation' do\n    let(:email_token) { Fabricate(:email_token, user: user_deferred) }\n\n    before do\n      UsersController.any_instance.stubs(:honeypot_or_challenge_fails?).returns(false)\n    end\n\n    context 'invalid token' do\n      it 'return success' do\n        put \"/u/activate-account/invalid-tooken\"\n        expect(response.status).to eq(200)\n        expect(flash[:error]).to be_present\n      end\n    end\n\n    context 'valid token' do\n      context 'welcome message' do\n        it 'enqueues a welcome message if the user object indicates so' do\n          SiteSetting.send_welcome_message = true\n          user_deferred.update(active: false)\n          put \"/u/activate-account/#{email_token.token}\"\n          expect(response.status).to eq(200)\n          expect(Jobs::SendSystemMessage.jobs.size).to eq(1)\n          expect(Jobs::SendSystemMessage.jobs.first[\"args\"].first[\"message_type\"]).to eq(\"welcome_user\")\n        end\n\n        it \"doesn't enqueue the welcome message if the object returns false\" do\n          user_deferred.update(active: true)\n          put \"/u/activate-account/#{email_token.token}\"\n          expect(response.status).to eq(200)\n          expect(Jobs::SendSystemMessage.jobs.size).to eq(0)\n        end\n      end\n\n      context \"honeypot\" do\n        it \"raises an error if the honeypot is invalid\" do\n          UsersController.any_instance.stubs(:honeypot_or_challenge_fails?).returns(true)\n          put \"/u/activate-account/#{email_token.token}\"\n          expect(response.status).to eq(403)\n        end\n      end\n\n      context 'response' do\n        it 'correctly logs on user' do\n          email_token\n\n          events = DiscourseEvent.track_events do\n            put \"/u/activate-account/#{email_token.token}\"\n          end\n\n          expect(events.map { |event| event[:event_name] }).to contain_exactly(\n            :user_confirmed_email, :user_first_logged_in, :user_logged_in\n          )\n\n          expect(response.status).to eq(200)\n          expect(flash[:error]).to be_blank\n          expect(session[:current_user_id]).to be_present\n\n          expect(CGI.unescapeHTML(response.body))\n            .to_not include(I18n.t('activation.approval_required'))\n        end\n      end\n\n      context 'user is not approved' do\n        before do\n          SiteSetting.must_approve_users = true\n        end\n\n        it 'should return the right response' do\n          put \"/u/activate-account/#{email_token.token}\"\n          expect(response.status).to eq(200)\n\n          expect(CGI.unescapeHTML(response.body))\n            .to include(I18n.t('activation.approval_required'))\n\n          expect(response.body).to_not have_tag(:script, with: {\n            src: '/assets/application.js'\n          })\n\n          expect(flash[:error]).to be_blank\n          expect(session[:current_user_id]).to be_blank\n        end\n      end\n    end\n\n    context 'when cookies contains a destination URL' do\n      it 'should redirect to the URL' do\n        destination_url = 'http://thisisasite.com/somepath'\n        cookies[:destination_url] = destination_url\n\n        put \"/u/activate-account/#{email_token.token}\"\n\n        expect(response).to redirect_to(destination_url)\n      end\n    end\n  end\n\n  describe '#password_reset' do\n    let(:token) { SecureRandom.hex }\n\n    context \"you can view it even if login is required\" do\n      it \"returns success\" do\n        SiteSetting.login_required = true\n        get \"/u/password-reset/#{token}\"\n        expect(response.status).to eq(200)\n        expect(CGI.unescapeHTML(response.body)).to include(I18n.t('password_reset.no_token'))\n      end\n    end\n\n    context 'missing token' do\n      it 'disallows login' do\n        get \"/u/password-reset/#{token}\"\n\n        expect(response.status).to eq(200)\n\n        expect(CGI.unescapeHTML(response.body))\n          .to include(I18n.t('password_reset.no_token'))\n\n        expect(response.body).to_not have_tag(:script, with: {\n          src: '/assets/application.js'\n        })\n\n        expect(session[:current_user_id]).to be_blank\n      end\n\n      it \"responds with proper error message\" do\n        get \"/u/password-reset/#{token}.json\"\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"message\"]).to eq(I18n.t('password_reset.no_token'))\n        expect(session[:current_user_id]).to be_blank\n      end\n    end\n\n    context 'invalid token' do\n      it 'disallows login' do\n        get \"/u/password-reset/ev!l_trout@!\"\n\n        expect(response.status).to eq(200)\n\n        expect(CGI.unescapeHTML(response.body))\n          .to include(I18n.t('password_reset.no_token'))\n\n        expect(response.body).to_not have_tag(:script, with: {\n          src: '/assets/application.js'\n        })\n\n        expect(session[:current_user_id]).to be_blank\n      end\n\n      it \"responds with proper error message\" do\n        put \"/u/password-reset/evil_trout!.json\", params: { password: \"awesomeSecretPassword\" }\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"message\"]).to eq(I18n.t('password_reset.no_token'))\n        expect(session[:current_user_id]).to be_blank\n      end\n    end\n\n    context 'valid token' do\n      let!(:user_auth_token) { UserAuthToken.generate!(user_id: user1.id) }\n      let!(:email_token) { Fabricate(:email_token, user: user1, scope: EmailToken.scopes[:password_reset]) }\n\n      context 'when rendered' do\n        it 'renders referrer never on get requests' do\n          get \"/u/password-reset/#{email_token.token}\"\n          expect(response.status).to eq(200)\n          expect(response.body).to include('<meta name=\"referrer\" content=\"never\">')\n        end\n      end\n\n      it 'returns success' do\n        events = DiscourseEvent.track_events do\n          put \"/u/password-reset/#{email_token.token}\", params: { password: 'hg9ow8yhg98o' }\n        end\n\n        expect(events.map { |event| event[:event_name] }).to contain_exactly(\n          :user_logged_in, :user_first_logged_in, :user_confirmed_email\n        )\n\n        expect(response.status).to eq(200)\n        expect(response.body).to have_tag(\"div#data-preloaded\") do |element|\n          json = JSON.parse(element.current_scope.attribute('data-preloaded').value)\n          expect(json['password_reset']).to include('{\"is_developer\":false,\"admin\":false,\"second_factor_required\":false,\"security_key_required\":false,\"backup_enabled\":false,\"multiple_second_factor_methods\":false}')\n        end\n\n        expect(session[\"password-#{email_token.token}\"]).to be_blank\n        expect(UserAuthToken.where(id: user_auth_token.id).count).to eq(0)\n      end\n\n      it 'disallows double password reset' do\n        put \"/u/password-reset/#{email_token.token}\", params: { password: 'hg9ow8yHG32O' }\n        put \"/u/password-reset/#{email_token.token}\", params: { password: 'test123987AsdfXYZ' }\n        expect(user1.reload.confirm_password?('hg9ow8yHG32O')).to eq(true)\n        expect(user1.user_auth_tokens.count).to eq(1)\n      end\n\n      it \"doesn't redirect to wizard on get\" do\n        user1.update!(admin: true)\n\n        get \"/u/password-reset/#{email_token.token}.json\"\n        expect(response).not_to redirect_to(wizard_path)\n      end\n\n      it \"redirects to the wizard if you're the first admin\" do\n        user1.update!(admin: true)\n\n        get \"/u/password-reset/#{email_token.token}\"\n        put \"/u/password-reset/#{email_token.token}\", params: { password: 'hg9ow8yhg98oadminlonger' }\n        expect(response).to redirect_to(wizard_path)\n      end\n\n      it \"sets the users timezone if the param is present\" do\n        get \"/u/password-reset/#{email_token.token}\"\n        expect(user1.user_option.timezone).to eq(nil)\n\n        put \"/u/password-reset/#{email_token.token}\", params: { password: 'hg9ow8yhg98oadminlonger', timezone: \"America/Chicago\" }\n        expect(user1.user_option.reload.timezone).to eq(\"America/Chicago\")\n      end\n\n      it \"logs the password change\" do\n        get \"/u/password-reset/#{email_token.token}\"\n\n        expect do\n          put \"/u/password-reset/#{email_token.token}\", params: { password: 'hg9ow8yhg98oadminlonger' }\n        end.to change { UserHistory.count }.by (1)\n\n        user_history = UserHistory.last\n        expect(user_history.target_user_id).to eq(user1.id)\n        expect(user_history.action).to eq(UserHistory.actions[:change_password])\n      end\n\n      it \"doesn't invalidate the token when loading the page\" do\n        get \"/u/password-reset/#{email_token.token}.json\"\n        expect(response.status).to eq(200)\n        expect(email_token.reload.confirmed).to eq(false)\n        expect(UserAuthToken.where(id: user_auth_token.id).count).to eq(1)\n      end\n\n      context \"rate limiting\" do\n        before { RateLimiter.clear_all!; RateLimiter.enable }\n\n        it \"rate limits reset passwords\" do\n          freeze_time\n\n          6.times do\n            put \"/u/password-reset/#{email_token.token}\", params: {\n              second_factor_token: 123456,\n              second_factor_method: 1\n            }\n\n            expect(response.status).to eq(200)\n          end\n\n          put \"/u/password-reset/#{email_token.token}\", params: {\n            second_factor_token: 123456,\n            second_factor_method: 1\n          }\n\n          expect(response.status).to eq(429)\n        end\n\n        it \"rate limits reset passwords by username\" do\n          freeze_time\n\n          6.times do |x|\n            put \"/u/password-reset/#{email_token.token}\", params: {\n              second_factor_token: 123456,\n              second_factor_method: 1\n            }, env: { \"REMOTE_ADDR\": \"1.2.3.#{x}\" }\n\n            expect(response.status).to eq(200)\n          end\n\n          put \"/u/password-reset/#{email_token.token}\", params: {\n            second_factor_token: 123456,\n            second_factor_method: 1\n          }, env: { \"REMOTE_ADDR\": \"1.2.3.4\" }\n\n          expect(response.status).to eq(429)\n        end\n      end\n\n      context '2 factor authentication required' do\n        fab!(:second_factor) { Fabricate(:user_second_factor_totp, user: user1) }\n\n        it 'does not change with an invalid token' do\n          user1.user_auth_tokens.destroy_all\n\n          get \"/u/password-reset/#{email_token.token}\"\n\n          expect(response.body).to have_tag(\"div#data-preloaded\") do |element|\n            json = JSON.parse(element.current_scope.attribute('data-preloaded').value)\n            expect(json['password_reset']).to include('{\"is_developer\":false,\"admin\":false,\"second_factor_required\":true,\"security_key_required\":false,\"backup_enabled\":false,\"multiple_second_factor_methods\":false}')\n          end\n\n          put \"/u/password-reset/#{email_token.token}\", params: {\n            password: 'hg9ow8yHG32O',\n            second_factor_token: '000000',\n            second_factor_method: UserSecondFactor.methods[:totp]\n          }\n\n          expect(response.body).to include(I18n.t(\"login.invalid_second_factor_code\"))\n\n          user1.reload\n          expect(user1.confirm_password?('hg9ow8yHG32O')).not_to eq(true)\n          expect(user1.user_auth_tokens.count).not_to eq(1)\n        end\n\n        it 'changes password with valid 2-factor tokens' do\n          get \"/u/password-reset/#{email_token.token}\"\n\n          put \"/u/password-reset/#{email_token.token}\", params: {\n            password: 'hg9ow8yHG32O',\n            second_factor_token: ROTP::TOTP.new(second_factor.data).now,\n            second_factor_method: UserSecondFactor.methods[:totp]\n          }\n\n          user1.reload\n          expect(response.status).to eq(200)\n          expect(user1.confirm_password?('hg9ow8yHG32O')).to eq(true)\n          expect(user1.user_auth_tokens.count).to eq(1)\n        end\n      end\n\n      context 'security key authentication required' do\n        let!(:user_security_key) do\n          Fabricate(\n            :user_security_key,\n            user: user1,\n            credential_id: valid_security_key_data[:credential_id],\n            public_key: valid_security_key_data[:public_key]\n          )\n        end\n\n        before do\n          simulate_localhost_webauthn_challenge\n\n          # store challenge in secure session by visiting the email login page\n          get \"/u/password-reset/#{email_token.token}\"\n        end\n\n        it 'preloads with a security key challenge and allowed credential ids' do\n          expect(response.body).to have_tag(\"div#data-preloaded\") do |element|\n            json = JSON.parse(element.current_scope.attribute('data-preloaded').value)\n            password_reset = JSON.parse(json['password_reset'])\n            expect(password_reset['challenge']).not_to eq(nil)\n            expect(password_reset['allowed_credential_ids']).to eq([user_security_key.credential_id])\n            expect(password_reset['security_key_required']).to eq(true)\n          end\n        end\n\n        it 'stages a webauthn challenge and rp-id for the user' do\n          secure_session = SecureSession.new(session[\"secure_session_id\"])\n          expect(Webauthn.challenge(user1, secure_session)).not_to eq(nil)\n          expect(Webauthn.rp_id(user1, secure_session)).to eq(Discourse.current_hostname)\n        end\n\n        it 'changes password with valid security key challenge and authentication' do\n          put \"/u/password-reset/#{email_token.token}.json\", params: {\n            password: 'hg9ow8yHG32O',\n            second_factor_token: valid_security_key_auth_post_data,\n            second_factor_method: UserSecondFactor.methods[:security_key]\n          }\n\n          expect(response.status).to eq(200)\n          user1.reload\n          expect(user1.confirm_password?('hg9ow8yHG32O')).to eq(true)\n          expect(user1.user_auth_tokens.count).to eq(1)\n        end\n\n        it \"does not change a password if a fake TOTP token is provided\" do\n          put \"/u/password-reset/#{email_token.token}.json\", params: {\n            password: 'hg9ow8yHG32O',\n            second_factor_token: 'blah',\n            second_factor_method: UserSecondFactor.methods[:security_key]\n          }\n\n          expect(response.status).to eq(200)\n          expect(user1.reload.confirm_password?('hg9ow8yHG32O')).to eq(false)\n        end\n\n        context \"when security key authentication fails\" do\n          it 'shows an error message and does not change password' do\n            put \"/u/password-reset/#{email_token.token}\", params: {\n              password: 'hg9ow8yHG32O',\n              second_factor_token: {\n                signature: 'bad',\n                clientData: 'bad',\n                authenticatorData: 'bad',\n                credentialId: 'bad'\n              },\n              second_factor_method: UserSecondFactor.methods[:security_key]\n            }\n\n            expect(response.status).to eq(200)\n            expect(response.body).to include(I18n.t(\"webauthn.validation.not_found_error\"))\n            expect(user1.reload.confirm_password?('hg9ow8yHG32O')).to eq(false)\n          end\n        end\n      end\n    end\n\n    context 'submit change' do\n      let(:email_token) { Fabricate(:email_token, user: user1, scope: EmailToken.scopes[:password_reset]) }\n\n      it \"fails when the password is blank\" do\n        put \"/u/password-reset/#{email_token.token}.json\", params: { password: '' }\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"errors\"]).to be_present\n        expect(session[:current_user_id]).to be_blank\n      end\n\n      it \"fails when the password is too long\" do\n        put \"/u/password-reset/#{email_token.token}.json\", params: { password: ('x' * (User.max_password_length + 1)) }\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"errors\"]).to be_present\n        expect(session[:current_user_id]).to be_blank\n      end\n\n      it \"logs in the user\" do\n        put \"/u/password-reset/#{email_token.token}.json\", params: { password: 'ksjafh928r' }\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"errors\"]).to be_blank\n        expect(session[:current_user_id]).to be_present\n      end\n\n      it \"doesn't log in the user when not approved\" do\n        SiteSetting.must_approve_users = true\n        user1.update!(approved: false)\n\n        put \"/u/password-reset/#{email_token.token}.json\", params: { password: 'ksjafh928r' }\n        expect(response.parsed_body[\"errors\"]).to be_blank\n        expect(session[:current_user_id]).to be_blank\n      end\n    end\n  end\n\n  describe '#confirm_email_token' do\n    let!(:email_token) { Fabricate(:email_token, user: user1) }\n\n    it \"token doesn't match any records\" do\n      get \"/u/confirm-email-token/#{SecureRandom.hex}.json\"\n      expect(response.status).to eq(200)\n      expect(email_token.reload.confirmed).to eq(false)\n    end\n\n    it \"token matches\" do\n      get \"/u/confirm-email-token/#{email_token.token}.json\"\n      expect(response.status).to eq(200)\n      expect(email_token.reload.confirmed).to eq(true)\n    end\n  end\n\n  describe '#admin_login' do\n    context 'enqueues mail' do\n      it 'enqueues mail with admin email and sso enabled' do\n        put \"/u/admin-login\", params: { email: admin.email }\n        expect(response.status).to eq(200)\n        expect(Jobs::CriticalUserEmail.jobs.size).to eq(1)\n        args = Jobs::CriticalUserEmail.jobs.first[\"args\"].first\n        expect(args[\"user_id\"]).to eq(admin.id)\n      end\n    end\n\n    context 'when email is incorrect' do\n      it 'should return the right response' do\n        put \"/u/admin-login\", params: { email: 'random' }\n\n        expect(response.status).to eq(200)\n\n        response_body = response.body\n\n        expect(response_body).to match(I18n.t(\"admin_login.errors.unknown_email_address\"))\n        expect(response_body).to_not match(I18n.t(\"login.second_factor_description\"))\n      end\n    end\n  end\n\n  describe '#toggle_anon' do\n    it 'allows you to toggle anon if enabled' do\n      SiteSetting.allow_anonymous_posting = true\n\n      user = sign_in(Fabricate(:user))\n      user.trust_level = 1\n      user.save!\n\n      post \"/u/toggle-anon.json\"\n      expect(response.status).to eq(200)\n      expect(session[:current_user_id]).to eq(AnonymousShadowCreator.get(user).id)\n\n      post \"/u/toggle-anon.json\"\n      expect(response.status).to eq(200)\n      expect(session[:current_user_id]).to eq(user.id)\n    end\n  end\n\n  describe '#create' do\n    def honeypot_magic(params)\n      get '/session/hp.json'\n      json = response.parsed_body\n      params[:password_confirmation] = json[\"value\"]\n      params[:challenge] = json[\"challenge\"].reverse\n      params\n    end\n\n    before do\n      UsersController.any_instance.stubs(:honeypot_value).returns(nil)\n      UsersController.any_instance.stubs(:challenge_value).returns(nil)\n      SiteSetting.allow_new_registrations = true\n      @user = Fabricate.build(:user, email: \"foobar@example.com\", password: \"strongpassword\")\n    end\n\n    let(:post_user_params) do\n      { name: @user.name,\n        username: @user.username,\n        password: \"strongpassword\",\n        email: @user.email }\n    end\n\n    def post_user(extra_params = {})\n      post \"/u.json\", params: post_user_params.merge(extra_params)\n    end\n\n    context 'when email params is missing' do\n      it 'should raise the right error' do\n        post \"/u.json\", params: {\n          name: @user.name,\n          username: @user.username,\n          password: 'testing12352343'\n        }\n        expect(response.status).to eq(400)\n      end\n    end\n\n    context 'when creating a user' do\n      it 'sets the user locale to I18n.locale' do\n        SiteSetting.default_locale = 'en'\n        I18n.stubs(:locale).returns(:fr)\n        post_user\n        expect(User.find_by(username: @user.username).locale).to eq('fr')\n      end\n\n      it 'requires invite code when specified' do\n        expect(SiteSetting.require_invite_code).to eq(false)\n        SiteSetting.invite_code = \"abc def\"\n        expect(SiteSetting.require_invite_code).to eq(true)\n\n        post_user(invite_code: \"abcd\")\n        expect(response.status).to eq(200)\n        json = response.parsed_body\n        expect(json[\"success\"]).to eq(false)\n\n        # case insensitive and stripped of leading/ending spaces\n        post_user(invite_code: \" AbC deF \")\n        expect(response.status).to eq(200)\n        json = response.parsed_body\n        expect(json[\"success\"]).to eq(true)\n\n      end\n\n      context \"when timezone is provided as a guess on signup\" do\n\n        it \"sets the timezone\" do\n          post_user(timezone: \"Australia/Brisbane\")\n          expect(response.status).to eq(200)\n          expect(User.find_by(username: @user.username).user_option.timezone).to eq(\"Australia/Brisbane\")\n        end\n      end\n\n      context \"with local logins disabled\" do\n        before do\n          SiteSetting.enable_local_logins = false\n          SiteSetting.enable_google_oauth2_logins = true\n        end\n\n        it \"blocks registration without authenticator information\" do\n          post_user\n          expect(response.status).to eq(403)\n        end\n\n        it \"blocks with a regular api key\" do\n          api_key = Fabricate(:api_key, user: user1)\n          post \"/u.json\", params: post_user_params, headers: { HTTP_API_KEY: api_key.key }\n          expect(response.status).to eq(403)\n        end\n\n        it \"works with an admin api key\" do\n          api_key = Fabricate(:api_key, user: admin)\n          post \"/u.json\", params: post_user_params, headers: { HTTP_API_KEY: api_key.key }\n          expect(response.status).to eq(200)\n        end\n      end\n    end\n\n    context 'when creating a non active user (unconfirmed email)' do\n      it 'returns 403 forbidden when local logins are disabled' do\n        SiteSetting.enable_local_logins = false\n        post_user\n\n        expect(response.status).to eq(403)\n      end\n\n      it 'returns an error when new registrations are disabled' do\n        SiteSetting.allow_new_registrations = false\n\n        post_user\n        expect(response.status).to eq(200)\n\n        json = response.parsed_body\n        expect(json['success']).to eq(false)\n        expect(json['message']).to be_present\n      end\n\n      it 'creates a user correctly' do\n        post_user\n        expect(response.status).to eq(200)\n        expect(response.parsed_body['active']).to be_falsey\n\n        # should save user_created_message in session\n        expect(session[\"user_created_message\"]).to be_present\n        expect(session[SessionController::ACTIVATE_USER_KEY]).to be_present\n\n        expect(Jobs::SendSystemMessage.jobs.size).to eq(0)\n\n        expect(Jobs::CriticalUserEmail.jobs.size).to eq(1)\n        args = Jobs::CriticalUserEmail.jobs.first[\"args\"].first\n        expect(args[\"type\"]).to eq(\"signup\")\n      end\n\n      context \"`must approve users` site setting is enabled\" do\n        before { SiteSetting.must_approve_users = true }\n\n        it 'creates a user correctly' do\n          post_user\n          expect(response.status).to eq(200)\n\n          expect(response.parsed_body['active']).to be_falsey\n\n          # should save user_created_message in session\n          expect(session[\"user_created_message\"]).to be_present\n          expect(session[SessionController::ACTIVATE_USER_KEY]).to be_present\n\n          expect(Jobs::SendSystemMessage.jobs.size).to eq(0)\n\n          expect(Jobs::CriticalUserEmail.jobs.size).to eq(1)\n          args = Jobs::CriticalUserEmail.jobs.first[\"args\"].first\n          expect(args[\"type\"]).to eq(\"signup\")\n        end\n      end\n\n      context 'users already exists with given email' do\n        let!(:existing) { Fabricate(:user, email: post_user_params[:email]) }\n\n        it 'returns an error if hide_email_address_taken is disabled' do\n          SiteSetting.hide_email_address_taken = false\n\n          post_user\n          expect(response.status).to eq(200)\n\n          json = response.parsed_body\n          expect(json['success']).to eq(false)\n          expect(json['message']).to be_present\n        end\n\n        it 'returns success if hide_email_address_taken is enabled' do\n          SiteSetting.hide_email_address_taken = true\n          expect {\n            post_user\n          }.to_not change { User.count }\n\n          expect(response.status).to eq(200)\n          expect(session[\"user_created_message\"]).to be_present\n\n          json = response.parsed_body\n          expect(json['active']).to be_falsey\n          expect(json['message']).to eq(I18n.t(\"login.activate_email\", email: post_user_params[:email]))\n          expect(json['user_id']).not_to be_present\n\n          existing.destroy!\n          expect {\n            post_user\n          }.to change { User.count }\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n\n          expect(json['active']).to be_falsey\n          expect(json['message']).to eq(I18n.t(\"login.activate_email\", email: post_user_params[:email]))\n          expect(json['user_id']).not_to be_present\n        end\n      end\n    end\n\n    context \"creating as active\" do\n      it \"won't create the user as active\" do\n        post \"/u.json\", params: post_user_params.merge(active: true)\n        expect(response.status).to eq(200)\n        expect(response.parsed_body['active']).to be_falsey\n      end\n\n      context \"with a regular api key\" do\n        fab!(:api_key, refind: false) { Fabricate(:api_key, user: user1) }\n\n        it \"won't create the user as active with a regular key\" do\n          post \"/u.json\",\n            params: post_user_params.merge(active: true), headers: { HTTP_API_KEY: api_key.key }\n\n          expect(response.status).to eq(200)\n          expect(response.parsed_body['active']).to be_falsey\n        end\n      end\n\n      context \"with an admin api key\" do\n        fab!(:api_key, refind: false) { Fabricate(:api_key, user: admin) }\n\n        it \"creates the user as active with a an admin key\" do\n          SiteSetting.send_welcome_message = true\n          SiteSetting.must_approve_users = true\n\n          #Sidekiq::Client.expects(:enqueue).never\n          post \"/u.json\", params: post_user_params.merge(approved: true, active: true), headers: { HTTP_API_KEY: api_key.key }\n\n          expect(Jobs::CriticalUserEmail.jobs.size).to eq(0)\n          expect(Jobs::SendSystemMessage.jobs.size).to eq(0)\n\n          expect(response.status).to eq(200)\n          expect(response.parsed_body['active']).to be_truthy\n          new_user = User.find(response.parsed_body[\"user_id\"])\n          expect(new_user.active).to eq(true)\n          expect(new_user.approved).to eq(true)\n          expect(new_user.approved_by_id).to eq(admin.id)\n          expect(new_user.approved_at).to_not eq(nil)\n          expect(new_user.email_tokens.where(confirmed: true, email: new_user.email)).to exist\n        end\n\n        it \"will create a reviewable when a user is created as active but not approved\" do\n          Jobs.run_immediately!\n          SiteSetting.must_approve_users = true\n\n          post \"/u.json\", params: post_user_params.merge(active: true), headers: { HTTP_API_KEY: api_key.key }\n\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n\n          new_user = User.find(json[\"user_id\"])\n          expect(json['active']).to be_truthy\n          expect(new_user.approved).to eq(false)\n          expect(ReviewableUser.pending.find_by(target: new_user)).to be_present\n        end\n\n        it \"won't create a reviewable when a user is not active\" do\n          Jobs.run_immediately!\n          SiteSetting.must_approve_users = true\n\n          post \"/u.json\", params: post_user_params, headers: { HTTP_API_KEY: api_key.key }\n\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n\n          new_user = User.find(json[\"user_id\"])\n          expect(json['active']).to eq(false)\n          expect(new_user.approved).to eq(false)\n          expect(ReviewableUser.pending.find_by(target: new_user)).to be_blank\n        end\n\n        it \"won't create the developer as active\" do\n          UsernameCheckerService.expects(:is_developer?).returns(true)\n\n          post \"/u.json\", params: post_user_params.merge(active: true), headers: { HTTP_API_KEY: api_key.key }\n          expect(response.status).to eq(200)\n          expect(response.parsed_body['active']).to be_falsy\n        end\n\n        it \"won't set the new user's locale to the admin's locale\" do\n          SiteSetting.allow_user_locale = true\n          admin.update!(locale: :fr)\n\n          post \"/u.json\", params: post_user_params.merge(active: true), headers: { HTTP_API_KEY: api_key.key }\n          expect(response.status).to eq(200)\n\n          json = response.parsed_body\n          new_user = User.find(json[\"user_id\"])\n          expect(new_user.locale).not_to eq(\"fr\")\n        end\n\n        it \"will auto approve user if the user email domain matches auto_approve_email_domains setting\" do\n          Jobs.run_immediately!\n          SiteSetting.must_approve_users = true\n          SiteSetting.auto_approve_email_domains = \"example.com\"\n\n          post \"/u.json\", params: post_user_params.merge(active: true), headers: { HTTP_API_KEY: api_key.key }\n\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n\n          new_user = User.find(json[\"user_id\"])\n          expect(json['active']).to be_truthy\n          expect(new_user.approved).to be_truthy\n          expect(ReviewableUser.pending.find_by(target: new_user)).to be_blank\n        end\n      end\n    end\n\n    context \"creating as staged\" do\n      it \"won't create the user as staged\" do\n        post \"/u.json\", params: post_user_params.merge(staged: true)\n        expect(response.status).to eq(200)\n        new_user = User.where(username: post_user_params[:username]).first\n        expect(new_user.staged?).to eq(false)\n      end\n\n      context \"with a regular api key\" do\n        fab!(:api_key, refind: false) { Fabricate(:api_key, user: user1) }\n\n        it \"won't create the user as staged with a regular key\" do\n          post \"/u.json\", params: post_user_params.merge(staged: true), headers: { HTTP_API_KEY: api_key.key }\n          expect(response.status).to eq(200)\n\n          new_user = User.where(username: post_user_params[:username]).first\n          expect(new_user.staged?).to eq(false)\n        end\n      end\n\n      context \"with an admin api key\" do\n        fab!(:user) { admin }\n        fab!(:api_key, refind: false) { Fabricate(:api_key, user: user) }\n\n        it \"creates the user as staged with a regular key\" do\n          post \"/u.json\", params: post_user_params.merge(staged: true), headers: { HTTP_API_KEY: api_key.key }\n          expect(response.status).to eq(200)\n\n          new_user = User.where(username: post_user_params[:username]).first\n          expect(new_user.staged?).to eq(true)\n        end\n\n        it \"won't create the developer as staged\" do\n          UsernameCheckerService.expects(:is_developer?).returns(true)\n          post \"/u.json\", params: post_user_params.merge(staged: true), headers: { HTTP_API_KEY: api_key.key }\n          expect(response.status).to eq(200)\n\n          new_user = User.where(username: post_user_params[:username]).first\n          expect(new_user.staged?).to eq(false)\n        end\n      end\n    end\n\n    context 'when creating an active user (confirmed email)' do\n      before { User.any_instance.stubs(:active?).returns(true) }\n\n      it 'enqueues a welcome email' do\n        User.any_instance.expects(:enqueue_welcome_message).with('welcome_user')\n\n        post_user\n        expect(response.status).to eq(200)\n\n        # should save user_created_message in session\n        expect(session[\"user_created_message\"]).to be_present\n        expect(session[SessionController::ACTIVATE_USER_KEY]).to be_present\n      end\n\n      it \"shows the 'active' message\" do\n        User.any_instance.expects(:enqueue_welcome_message)\n        post_user\n        expect(response.status).to eq(200)\n        expect(response.parsed_body['message']).to eq(\n          I18n.t 'login.active'\n        )\n      end\n\n      it \"should be logged in\" do\n        User.any_instance.expects(:enqueue_welcome_message)\n        post_user\n        expect(response.status).to eq(200)\n        expect(session[:current_user_id]).to be_present\n      end\n\n      it 'indicates the user is active in the response' do\n        User.any_instance.expects(:enqueue_welcome_message)\n        post_user\n        expect(response.status).to eq(200)\n        expect(response.parsed_body['active']).to be_truthy\n      end\n\n      it 'doesn\\'t succeed when new registrations are disabled' do\n        SiteSetting.allow_new_registrations = false\n\n        post_user\n        expect(response.status).to eq(200)\n\n        json = response.parsed_body\n        expect(json['success']).to eq(false)\n        expect(json['message']).to be_present\n      end\n\n      context 'authentication records for' do\n        before do\n          OmniAuth.config.test_mode = true\n\n          OmniAuth.config.mock_auth[:twitter] = OmniAuth::AuthHash.new(\n            provider: 'twitter',\n            uid: '123545',\n            info: OmniAuth::AuthHash::InfoHash.new(\n              email: \"osama@mail.com\",\n              nickname: \"testosama\",\n              name: \"Osama Test\"\n            )\n          )\n\n          Rails.application.env_config[\"omniauth.auth\"] = OmniAuth.config.mock_auth[:twitter]\n          SiteSetting.enable_twitter_logins = true\n          get \"/auth/twitter/callback.json\"\n        end\n\n        after do\n          Rails.application.env_config[\"omniauth.auth\"] = OmniAuth.config.mock_auth[:twitter] = nil\n          OmniAuth.config.test_mode = false\n        end\n\n        it 'should create twitter user info if required' do\n          post \"/u.json\", params: {\n            name: \"Test Osama\",\n            username: \"testosama\",\n            password: \"strongpassword\",\n            email: \"osama@mail.com\"\n          }\n\n          expect(response.status).to eq(200)\n          expect(UserAssociatedAccount.where(provider_name: \"twitter\").count).to eq(1)\n        end\n\n        it \"returns an error when email has been changed from the validated email address\" do\n          post \"/u.json\", params: {\n            name: \"Test Osama\",\n            username: \"testosama\",\n            password: \"strongpassword\",\n            email: \"unvalidatedemail@mail.com\"\n          }\n\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n          expect(json['success']).to eq(false)\n          expect(json['message']).to be_present\n        end\n\n        it \"will create the user successfully if email validation is required\" do\n          post \"/u.json\", params: {\n            name: \"Test Osama\",\n            username: \"testosama\",\n            password: \"strongpassword\",\n            email: \"osama@mail.com\"\n          }\n\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n          expect(json['success']).to eq(true)\n        end\n\n        it \"doesn't use provided username/name if sso_overrides is enabled\" do\n          SiteSetting.auth_overrides_username = true\n          SiteSetting.auth_overrides_name = true\n          post \"/u.json\", params: {\n            username: \"attemptednewname\",\n            name: \"Attempt At New Name\",\n            password: \"strongpassword\",\n            email: \"osama@mail.com\"\n          }\n\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n          expect(json['success']).to eq(true)\n\n          user = User.last\n\n          expect(user.username).to eq('testosama')\n          expect(user.name).to eq('Osama Test')\n        end\n\n      end\n\n      context \"with no email in the auth payload\" do\n        before do\n          OmniAuth.config.test_mode = true\n          OmniAuth.config.mock_auth[:twitter] = OmniAuth::AuthHash.new(\n            provider: 'twitter',\n            uid: '123545',\n            info: OmniAuth::AuthHash::InfoHash.new(\n              nickname: \"testosama\",\n              name: \"Osama Test\"\n            )\n          )\n          Rails.application.env_config[\"omniauth.auth\"] = OmniAuth.config.mock_auth[:twitter]\n          SiteSetting.enable_twitter_logins = true\n          get \"/auth/twitter/callback.json\"\n        end\n\n        after do\n          Rails.application.env_config[\"omniauth.auth\"] = OmniAuth.config.mock_auth[:twitter] = nil\n          OmniAuth.config.test_mode = false\n        end\n\n        it \"will create the user successfully\" do\n          Rails.application.env_config[\"omniauth.auth\"].info.email = nil\n\n          post \"/u.json\", params: {\n            name: \"Test Osama\",\n            username: \"testosama\",\n            password: \"strongpassword\",\n            email: \"osama@mail.com\"\n          }\n\n          expect(response.status).to eq(200)\n          json = response.parsed_body\n          expect(json['success']).to eq(true)\n        end\n      end\n    end\n\n    it \"creates user successfully but doesn't activate the account\" do\n      post_user\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"success\"]).to eq(true)\n      expect(User.find_by(username: @user.username).active).to eq(false)\n    end\n\n    shared_examples 'honeypot fails' do\n      it 'should not create a new user' do\n        User.any_instance.expects(:enqueue_welcome_message).never\n\n        expect {\n          post \"/u.json\", params: create_params\n        }.to_not change { User.count }\n\n        expect(response.status).to eq(200)\n\n        json = response.parsed_body\n        expect(json[\"success\"]).to eq(true)\n\n        # should not change the session\n        expect(session[\"user_created_message\"]).to be_blank\n        expect(session[SessionController::ACTIVATE_USER_KEY]).to be_blank\n      end\n    end\n\n    context 'when honeypot value is wrong' do\n      before do\n        UsersController.any_instance.stubs(:honeypot_value).returns('abc')\n      end\n      let(:create_params) { { name: @user.name, username: @user.username, password: \"strongpassword\", email: @user.email, password_confirmation: 'wrong' } }\n      include_examples 'honeypot fails'\n    end\n\n    context 'when challenge answer is wrong' do\n      before do\n        UsersController.any_instance.stubs(:challenge_value).returns('abc')\n      end\n      let(:create_params) { { name: @user.name, username: @user.username, password: \"strongpassword\", email: @user.email, challenge: 'abc' } }\n      include_examples 'honeypot fails'\n    end\n\n    context \"when 'invite only' setting is enabled\" do\n      before { SiteSetting.invite_only = true }\n\n      let(:create_params) { {\n        name: @user.name,\n        username: @user.username,\n        password: 'strongpassword',\n        email: @user.email\n      }}\n\n      include_examples 'honeypot fails'\n    end\n\n    shared_examples 'failed signup' do\n      it 'should not create a new User' do\n        expect { post \"/u.json\", params: create_params }.to_not change { User.count }\n        expect(response.status).to eq(200)\n      end\n\n      it 'should report failed' do\n        post \"/u.json\", params: create_params\n        json = response.parsed_body\n        expect(json[\"success\"]).not_to eq(true)\n\n        # should not change the session\n        expect(session[\"user_created_message\"]).to be_blank\n        expect(session[SessionController::ACTIVATE_USER_KEY]).to be_blank\n      end\n    end\n\n    context 'when password is blank' do\n      let(:create_params) { { name: @user.name, username: @user.username, password: \"\", email: @user.email } }\n      include_examples 'failed signup'\n    end\n\n    context 'when password is too long' do\n      let(:create_params) { { name: @user.name, username: @user.username, password: \"x\" * (User.max_password_length + 1), email: @user.email } }\n      include_examples 'failed signup'\n    end\n\n    context 'when password param is missing' do\n      let(:create_params) { { name: @user.name, username: @user.username, email: @user.email } }\n      include_examples 'failed signup'\n    end\n\n    context 'with a reserved username' do\n      let(:create_params) { { name: @user.name, username: 'Reserved', email: @user.email, password: 'strongpassword' } }\n      before { SiteSetting.reserved_usernames = 'a|reserved|b' }\n      include_examples 'failed signup'\n    end\n\n    context 'with a username that matches a user route' do\n      let(:create_params) { { name: @user.name, username: 'account-created', email: @user.email, password: 'strongpassword' } }\n      include_examples 'failed signup'\n    end\n\n    context 'with a missing username' do\n      let(:create_params) { { name: @user.name, email: @user.email, password: \"x\" * 20 } }\n\n      it 'should not create a new User' do\n        expect { post \"/u.json\", params: create_params }.to_not change { User.count }\n        expect(response.status).to eq(400)\n      end\n    end\n\n    context 'when an Exception is raised' do\n      before { User.any_instance.stubs(:save).raises(ActiveRecord::StatementInvalid.new('Oh no')) }\n\n      let(:create_params) {\n        { name: @user.name, username: @user.username,\n          password: \"strongpassword\", email: @user.email }\n      }\n\n      include_examples 'failed signup'\n    end\n\n    context \"with custom fields\" do\n      fab!(:user_field) { Fabricate(:user_field) }\n      fab!(:another_field) { Fabricate(:user_field) }\n      fab!(:optional_field) { Fabricate(:user_field, required: false) }\n\n      context \"without a value for the fields\" do\n        let(:create_params) { { name: @user.name, password: 'watwatwat', username: @user.username, email: @user.email } }\n        include_examples 'failed signup'\n      end\n\n      context \"with values for the fields\" do\n        let(:update_user_url) { \"/u/#{user1.username}.json\" }\n        let(:field_id) { user_field.id.to_s }\n\n        before { sign_in(user1) }\n\n        context \"with multple select fields\" do\n          let(:valid_options) { %w[Axe Sword] }\n\n          fab!(:user_field) do\n            Fabricate(:user_field, field_type: 'multiselect') do\n              user_field_options do\n                [\n                  Fabricate(:user_field_option, value: 'Axe'),\n                  Fabricate(:user_field_option, value: 'Sword')\n                ]\n              end\n            end\n          end\n\n          it \"should allow single values and not just arrays\" do\n            expect do\n              put update_user_url, params: { user_fields: { field_id => 'Axe' } }\n            end.to change { user1.reload.user_fields[field_id] }.from(nil).to('Axe')\n\n            expect do\n              put update_user_url, params: { user_fields: { field_id => %w[Axe Juice Sword] } }\n            end.to change { user1.reload.user_fields[field_id] }.from('Axe').to(%w[Axe Sword])\n          end\n\n          it \"shouldn't allow unregistered field values\" do\n            expect do\n              put update_user_url, params: { user_fields: { field_id => %w[Juice] } }\n            end.not_to change { user1.reload.user_fields[field_id] }\n          end\n\n          it \"should filter valid values\" do\n            expect do\n              put update_user_url, params: { user_fields: { field_id => %w[Axe Juice Sword] } }\n            end.to change { user1.reload.user_fields[field_id] }.from(nil).to(valid_options)\n          end\n\n          it \"allows registered field values\" do\n            expect do\n              put update_user_url, params: { user_fields: { field_id => valid_options } }\n            end.to change { user1.reload.user_fields[field_id] }.from(nil).to(valid_options)\n          end\n\n          it \"value can't be nil or empty if the field is required\" do\n            put update_user_url, params: { user_fields: { field_id => valid_options } }\n\n            user_field.update!(required: true)\n\n            expect do\n              put update_user_url, params: { user_fields: { field_id => nil } }\n            end.not_to change { user1.reload.user_fields[field_id] }\n\n            expect do\n              put update_user_url, params: { user_fields: { field_id => \"\" } }\n            end.not_to change { user1.reload.user_fields[field_id] }\n          end\n\n          it 'value can nil or empty if the field is not required' do\n            put update_user_url, params: { user_fields: { field_id => valid_options } }\n\n            user_field.update!(required: false)\n\n            expect do\n              put update_user_url, params: { user_fields: { field_id => nil } }\n            end.to change { user1.reload.user_fields[field_id] }.from(valid_options).to(nil)\n\n            expect do\n              put update_user_url, params: { user_fields: { field_id => \"\" } }\n            end.to change { user1.reload.user_fields[field_id] }.from(nil).to(\"\")\n          end\n\n        end\n\n        context \"with dropdown fields\" do\n          let(:valid_options) { ['Black Mesa', 'Fox Hound'] }\n\n          fab!(:user_field) do\n            Fabricate(:user_field, field_type: 'dropdown') do\n              user_field_options do\n                [\n                  Fabricate(:user_field_option, value: 'Black Mesa'),\n                  Fabricate(:user_field_option, value: 'Fox Hound')\n                ]\n              end\n            end\n          end\n\n          it \"shouldn't allow unregistered field values\" do\n            expect do\n              put update_user_url, params: { user_fields: { field_id => 'Umbrella Corporation' } }\n            end.not_to change { user1.reload.user_fields[field_id] }\n          end\n\n          it \"allows registered field values\" do\n            expect do\n              put update_user_url, params: { user_fields: { field_id => valid_options.first } }\n            end.to change { user1.reload.user_fields[field_id] }.from(nil).to(valid_options.first)\n          end\n\n          it \"value can't be nil if the field is required\" do\n            put update_user_url, params: { user_fields: { field_id => valid_options.first } }\n\n            user_field.update!(required: true)\n\n            expect do\n              put update_user_url, params: { user_fields: { field_id => nil } }\n            end.not_to change { user1.reload.user_fields[field_id] }\n          end\n\n          it 'value can be set to nil if the field is not required' do\n            put update_user_url, params: { user_fields: { field_id => valid_options.last } }\n\n            user_field.update!(required: false)\n\n            expect do\n              put update_user_url, params: { user_fields: { field_id => nil } }\n            end.to change { user1.reload.user_fields[field_id] }.from(valid_options.last).to(nil)\n          end\n        end\n\n        let(:create_params) { {\n          name: @user.name,\n          password: 'suChS3cuRi7y',\n          username: @user.username,\n          email: @user.email,\n          user_fields: {\n            user_field.id.to_s => 'value1',\n            another_field.id.to_s => 'value2',\n          }\n        } }\n\n        it \"should succeed without the optional field\" do\n          post \"/u.json\", params: create_params\n          expect(response.status).to eq(200)\n          inserted = User.find_by_email(@user.email)\n          expect(inserted).to be_present\n          expect(inserted.custom_fields).to be_present\n          expect(inserted.custom_fields[\"user_field_#{user_field.id}\"]).to eq('value1')\n          expect(inserted.custom_fields[\"user_field_#{another_field.id}\"]).to eq('value2')\n          expect(inserted.custom_fields[\"user_field_#{optional_field.id}\"]).to be_blank\n        end\n\n        it \"should succeed with the optional field\" do\n          create_params[:user_fields][optional_field.id.to_s] = 'value3'\n          post \"/u.json\", params: create_params.merge(create_params)\n          expect(response.status).to eq(200)\n          inserted = User.find_by_email(@user.email)\n          expect(inserted).to be_present\n          expect(inserted.custom_fields).to be_present\n          expect(inserted.custom_fields[\"user_field_#{user_field.id}\"]).to eq('value1')\n          expect(inserted.custom_fields[\"user_field_#{another_field.id}\"]).to eq('value2')\n          expect(inserted.custom_fields[\"user_field_#{optional_field.id}\"]).to eq('value3')\n        end\n\n        it \"trims excessively long fields\" do\n          create_params[:user_fields][optional_field.id.to_s] = ('x' * 3000)\n          post \"/u.json\", params: create_params.merge(create_params)\n          expect(response.status).to eq(200)\n          inserted = User.find_by_email(@user.email)\n\n          val = inserted.custom_fields[\"user_field_#{optional_field.id}\"]\n          expect(val.length).to eq(UserField.max_length)\n        end\n      end\n    end\n\n    context \"with only optional custom fields\" do\n      fab!(:user_field) { Fabricate(:user_field, required: false) }\n\n      context \"without values for the fields\" do\n        let(:create_params) { {\n          name: @user.name,\n          password: 'suChS3cuRi7y',\n          username: @user.username,\n          email: @user.email,\n        } }\n\n        it \"should succeed\" do\n          post \"/u.json\", params: create_params\n          expect(response.status).to eq(200)\n          inserted = User.find_by_email(@user.email)\n          expect(inserted).to be_present\n          expect(inserted.custom_fields).not_to be_present\n          expect(inserted.custom_fields[\"user_field_#{user_field.id}\"]).to be_blank\n        end\n      end\n    end\n\n    context \"when taking over a staged account\" do\n      before do\n        UsersController.any_instance.stubs(:honeypot_value).returns(\"abc\")\n        UsersController.any_instance.stubs(:challenge_value).returns(\"efg\")\n        SessionController.any_instance.stubs(:honeypot_value).returns(\"abc\")\n        SessionController.any_instance.stubs(:challenge_value).returns(\"efg\")\n      end\n\n      fab!(:staged) { Fabricate(:staged, email: \"staged@account.com\", active: true) }\n\n      it \"succeeds\" do\n        post '/u.json', params: honeypot_magic(\n          email: staged.email,\n          username: \"zogstrip\",\n          password: \"P4ssw0rd$$\"\n        )\n\n        expect(response.status).to eq(200)\n        result = response.parsed_body\n        expect(result[\"success\"]).to eq(true)\n\n        created_user = User.find_by_email(staged.email)\n        expect(created_user.staged).to eq(false)\n        expect(created_user.active).to eq(false)\n        expect(created_user.registration_ip_address).to be_present\n        expect(!!created_user.custom_fields[\"from_staged\"]).to eq(true)\n\n        # do not allow emails changes please\n\n        put \"/u/update-activation-email.json\", params: { email: 'bob@bob.com' }\n\n        created_user.reload\n        expect(created_user.email).to eq(\"staged@account.com\")\n        expect(response.status).to eq(403)\n      end\n    end\n  end\n\n  describe '#username' do\n    it 'raises an error when not logged in' do\n      put \"/u/somename/preferences/username.json\"\n      expect(response.status).to eq(403)\n    end\n\n    context 'while logged in' do\n      let(:old_username) { \"OrigUsername\" }\n      let(:new_username) { \"#{old_username}1234\" }\n      fab!(:user) { Fabricate(:user, username: \"OrigUsername\") }\n\n      before do\n        user.username = old_username\n        sign_in(user)\n      end\n\n      it 'raises an error without a new_username param' do\n        put \"/u/#{user.username}/preferences/username.json\", params: { username: user.username }\n        expect(response.status).to eq(400)\n        expect(user.reload.username).to eq(old_username)\n      end\n\n      it 'raises an error when you don\\'t have permission to change the username' do\n        Guardian.any_instance.expects(:can_edit_username?).with(user).returns(false)\n\n        put \"/u/#{user.username}/preferences/username.json\", params: { new_username: new_username }\n\n        expect(response).to be_forbidden\n        expect(user.reload.username).to eq(old_username)\n      end\n\n      it 'raises an error when change_username fails' do\n        put \"/u/#{user.username}/preferences/username.json\", params: { new_username: '@' }\n\n        expect(response.status).to eq(422)\n\n        body = response.parsed_body\n\n        expect(body['errors'].first).to include(I18n.t(\n          'user.username.short', min: User.username_length.begin\n        ))\n\n        expect(user.reload.username).to eq(old_username)\n      end\n\n      it 'should succeed in normal circumstances' do\n        put \"/u/#{user.username}/preferences/username.json\", params: { new_username: new_username }\n\n        expect(response.status).to eq(200)\n        expect(user.reload.username).to eq(new_username)\n      end\n\n      it 'raises an error when the username clashes with an existing user route' do\n        put \"/u/#{user.username}/preferences/username.json\", params: { new_username: 'account-created' }\n\n        body = response.parsed_body\n\n        expect(body['errors'].first).to include(I18n.t('login.reserved_username'))\n      end\n\n      it 'raises an error when the username is in the reserved list' do\n        SiteSetting.reserved_usernames = 'reserved'\n\n        put \"/u/#{user.username}/preferences/username.json\", params: { new_username: 'reserved' }\n        body = response.parsed_body\n\n        expect(body['errors'].first).to include(I18n.t('login.reserved_username'))\n      end\n\n      it 'should fail if the user is old' do\n        # Older than the change period and >1 post\n        user.created_at = Time.now - (SiteSetting.username_change_period + 1).days\n        PostCreator.new(user,\n          title: 'This is a test topic',\n          raw: 'This is a test this is a test'\n        ).create\n\n        put \"/u/#{user.username}/preferences/username.json\", params: { new_username: new_username }\n\n        expect(response).to be_forbidden\n        expect(user.reload.username).to eq(old_username)\n      end\n\n      it 'should create a staff action log when a staff member changes the username' do\n        acting_user = admin\n        sign_in(acting_user)\n\n        put \"/u/#{user.username}/preferences/username.json\", params: { new_username: new_username }\n\n        expect(response.status).to eq(200)\n        expect(UserHistory.where(action: UserHistory.actions[:change_username], target_user_id: user.id, acting_user_id: acting_user.id)).to be_present\n        expect(user.reload.username).to eq(new_username)\n      end\n\n      it 'should return a JSON response with the updated username' do\n        put \"/u/#{user.username}/preferences/username.json\", params: { new_username: new_username }\n\n        expect(response.parsed_body['username']).to eq(new_username)\n      end\n\n      it 'should respond with proper error message if auth_overrides_username is enabled' do\n        SiteSetting.discourse_connect_url = 'http://someurl.com'\n        SiteSetting.enable_discourse_connect = true\n        SiteSetting.auth_overrides_username = true\n        acting_user = admin\n        sign_in(acting_user)\n\n        put \"/u/#{user.username}/preferences/username.json\", params: { new_username: new_username }\n\n        expect(response.status).to eq(422)\n        expect(response.parsed_body['errors'].first).to include(I18n.t('errors.messages.auth_overrides_username'))\n      end\n    end\n  end\n\n  describe '#check_username' do\n    it 'raises an error without any parameters' do\n      get \"/u/check_username.json\"\n      expect(response.status).to eq(400)\n    end\n\n    shared_examples 'when username is unavailable' do\n      it 'should return available as false in the JSON and return a suggested username' do\n        expect(response.status).to eq(200)\n        expect(response.parsed_body['available']).to eq(false)\n        expect(response.parsed_body['suggestion']).to be_present\n      end\n    end\n\n    shared_examples 'when username is available' do\n      it 'should return available in the JSON' do\n        expect(response.status).to eq(200)\n        expect(response.parsed_body['available']).to eq(true)\n      end\n    end\n\n    it 'returns nothing when given an email param but no username' do\n      get \"/u/check_username.json\", params: { email: 'dood@example.com' }\n      expect(response.status).to eq(200)\n    end\n\n    context 'username is available' do\n      before do\n        get \"/u/check_username.json\", params: { username: 'BruceWayne' }\n      end\n      include_examples 'when username is available'\n    end\n\n    context 'username is unavailable' do\n      before do\n        get \"/u/check_username.json\", params: { username: user1.username }\n      end\n      include_examples 'when username is unavailable'\n    end\n\n    shared_examples 'checking an invalid username' do\n      it 'should not return an available key but should return an error message' do\n        expect(response.status).to eq(200)\n        expect(response.parsed_body['available']).to eq(nil)\n        expect(response.parsed_body['errors']).to be_present\n      end\n    end\n\n    context 'has invalid characters' do\n      before do\n        get \"/u/check_username.json\", params: { username: 'bad username' }\n      end\n      include_examples 'checking an invalid username'\n\n      it 'should return the invalid characters message' do\n        expect(response.status).to eq(200)\n        expect(response.parsed_body['errors']).to include(I18n.t(:'user.username.characters'))\n      end\n    end\n\n    context 'is too long' do\n      before do\n        get \"/u/check_username.json\", params: { username: generate_username(User.username_length.last + 1) }\n      end\n      include_examples 'checking an invalid username'\n\n      it 'should return the \"too long\" message' do\n        expect(response.status).to eq(200)\n        expect(response.parsed_body['errors']).to include(I18n.t(:'user.username.long', max: User.username_length.end))\n      end\n    end\n\n    describe 'different case of existing username' do\n      context \"it's my username\" do\n        fab!(:user) { Fabricate(:user, username: 'hansolo') }\n        before do\n          sign_in(user)\n\n          get \"/u/check_username.json\", params: { username: 'HanSolo' }\n        end\n        include_examples 'when username is available'\n      end\n\n      context \"it's someone else's username\" do\n        fab!(:user) { Fabricate(:user, username: 'hansolo') }\n        fab!(:someone_else) { Fabricate(:user) }\n        before do\n          sign_in(someone_else)\n\n          get \"/u/check_username.json\", params: { username: 'HanSolo' }\n        end\n        include_examples 'when username is unavailable'\n      end\n\n      context \"an admin changing it for someone else\" do\n        fab!(:user) { Fabricate(:user, username: 'hansolo') }\n        before do\n          sign_in(admin)\n\n          get \"/u/check_username.json\", params: { username: 'HanSolo', for_user_id: user.id }\n        end\n        include_examples 'when username is available'\n      end\n    end\n  end\n\n  describe '#check_email' do\n    it 'returns success if hide_email_address_taken is true' do\n      SiteSetting.hide_email_address_taken = true\n\n      get \"/u/check_email.json\", params: { email: user1.email }\n      expect(response.parsed_body[\"success\"]).to be_present\n    end\n\n    it 'returns success if email is empty' do\n      get \"/u/check_email.json\"\n      expect(response.parsed_body[\"success\"]).to be_present\n    end\n\n    it 'returns failure if email is not valid' do\n      get \"/u/check_email.json\", params: { email: \"invalid\" }\n      expect(response.parsed_body[\"failed\"]).to be_present\n    end\n\n    it 'returns failure if email exists' do\n      get \"/u/check_email.json\", params: { email: user1.email }\n      expect(response.parsed_body[\"failed\"]).to be_present\n\n      get \"/u/check_email.json\", params: { email: user1.email.upcase }\n      expect(response.parsed_body[\"failed\"]).to be_present\n    end\n\n    it 'returns success if email does not exists' do\n      get \"/u/check_email.json\", params: { email: \"available@example.com\" }\n      expect(response.parsed_body[\"success\"]).to be_present\n    end\n\n    it 'return success if user email is taken by staged user' do\n      get \"/u/check_email.json\", params: { email: Fabricate(:staged).email }\n      expect(response.parsed_body[\"success\"]).to be_present\n    end\n  end\n\n  describe '#invited' do\n    it 'fails for anonymous users' do\n      get \"/u/#{user1.username}/invited.json\", params: { username: user1.username }\n\n      expect(response.status).to eq(403)\n    end\n\n    it 'returns success' do\n      user = Fabricate(:user, trust_level: 2)\n      Fabricate(:invite, invited_by: user)\n\n      sign_in(user)\n      get \"/u/#{user.username}/invited.json\", params: { username: user.username }\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"counts\"][\"pending\"]).to eq(1)\n      expect(response.parsed_body[\"counts\"][\"total\"]).to eq(1)\n    end\n\n    it 'filters by all if viewing self' do\n      inviter = Fabricate(:user, trust_level: 2)\n      sign_in(inviter)\n\n      Fabricate(:invite, email: 'billybob@example.com', invited_by: inviter)\n      redeemed_invite = Fabricate(:invite, email: 'jimtom@example.com', invited_by: inviter)\n      Fabricate(:invited_user, invite: redeemed_invite, user: invitee)\n\n      get \"/u/#{inviter.username}/invited.json\", params: { filter: 'pending', search: 'billybob' }\n      expect(response.status).to eq(200)\n\n      invites = response.parsed_body['invites']\n      expect(invites.size).to eq(1)\n      expect(invites.first).to include('email' => 'billybob@example.com')\n\n      get \"/u/#{inviter.username}/invited.json\", params: { filter: 'redeemed', search: invitee.username }\n      expect(response.status).to eq(200)\n\n      invites = response.parsed_body['invites']\n      expect(invites.size).to eq(1)\n      expect(invites[0]['user']).to be_present\n    end\n\n    it \"doesn't filter by email if another regular user\" do\n      inviter = Fabricate(:user, trust_level: 2)\n      sign_in(Fabricate(:user, trust_level: 2))\n\n      Fabricate(:invite, email: 'billybob@example.com', invited_by: inviter)\n      redeemed_invite = Fabricate(:invite, email: 'jimtom@example.com', invited_by: inviter)\n      Fabricate(:invited_user, invite: redeemed_invite, user: invitee)\n\n      get \"/u/#{inviter.username}/invited.json\", params: { filter: 'pending', search: 'billybob' }\n      expect(response.status).to eq(200)\n\n      invites = response.parsed_body['invites']\n      expect(invites.size).to eq(0)\n\n      get \"/u/#{inviter.username}/invited.json\", params: { filter: 'redeemed', search: invitee.username }\n      expect(response.status).to eq(200)\n\n      invites = response.parsed_body['invites']\n      expect(invites.size).to eq(1)\n      expect(invites[0]['user']).to be_present\n    end\n\n    it \"filters by email if staff\" do\n      inviter = Fabricate(:user, trust_level: 2)\n      sign_in(moderator)\n\n      invite_1 = Fabricate(:invite, email: 'billybob@example.com', invited_by: inviter)\n      invitee_1 = Fabricate(:user)\n      Fabricate(:invited_user, invite: invite_1, user: invitee_1)\n      invite_2 = Fabricate(:invite, email: 'jimtom@example.com', invited_by: inviter)\n      invitee_2 = Fabricate(:user)\n      Fabricate(:invited_user, invite: invite_2, user: invitee_2)\n\n      get \"/u/#{inviter.username}/invited.json\", params: { search: 'billybob' }\n      expect(response.status).to eq(200)\n\n      invites = response.parsed_body['invites']\n      expect(invites.size).to eq(1)\n      expect(invites[0]['user']).to include('id' => invitee_1.id)\n    end\n\n    context 'with guest' do\n      context 'with pending invites' do\n        it 'does not return invites' do\n          Fabricate(:invite, invited_by: inviter)\n\n          get \"/u/#{user1.username}/invited/pending.json\"\n          expect(response.status).to eq(403)\n        end\n      end\n\n      context 'with redeemed invites' do\n        it 'returns invited_users' do\n          inviter = Fabricate(:user, trust_level: 2)\n          sign_in(inviter)\n          invite = Fabricate(:invite, invited_by: inviter)\n          invited_user = Fabricate(:invited_user, invite: invite, user: invitee)\n\n          get \"/u/#{inviter.username}/invited.json\"\n          expect(response.status).to eq(200)\n\n          invites = response.parsed_body['invites']\n          expect(invites.size).to eq(1)\n          expect(invites[0]).to include('id' => invite.id)\n        end\n      end\n    end\n\n    context 'with authenticated user' do\n      context 'with pending invites' do\n        context 'with permission to see pending invites' do\n          it 'returns invites' do\n            inviter = Fabricate(:user, trust_level: 2)\n            invite = Fabricate(:invite, invited_by: inviter)\n            sign_in(inviter)\n\n            get \"/u/#{inviter.username}/invited/pending.json\"\n            expect(response.status).to eq(200)\n\n            invites = response.parsed_body['invites']\n            expect(invites.size).to eq(1)\n            expect(invites.first).to include(\"email\" => invite.email)\n            expect(response.parsed_body['can_see_invite_details']).to eq(true)\n          end\n        end\n\n        context 'without permission to see pending invites' do\n          it 'does not return invites' do\n            user = sign_in(Fabricate(:user))\n            Fabricate(:invite, invited_by: inviter)\n            stub_guardian(user) do |guardian|\n              guardian.stubs(:can_see_invite_details?).\n                with(inviter).returns(false)\n            end\n\n            get \"/u/#{inviter.username}/invited/pending.json\"\n            expect(response.status).to eq(422)\n          end\n        end\n\n        context 'with permission to see invite links' do\n          it 'returns own invites' do\n            inviter = sign_in(Fabricate(:user, trust_level: 2))\n            invite = Fabricate(:invite, invited_by: inviter,  email: nil, max_redemptions_allowed: 5, expires_at: 1.month.from_now, emailed_status: Invite.emailed_status_types[:not_required])\n\n            get \"/u/#{inviter.username}/invited/pending.json\"\n            expect(response.status).to eq(200)\n\n            invites = response.parsed_body['invites']\n            expect(invites.size).to eq(1)\n            expect(invites.first).to include(\"id\" => invite.id)\n            expect(response.parsed_body['can_see_invite_details']).to eq(true)\n          end\n\n          it 'allows admin to see invites' do\n            inviter = Fabricate(:user, trust_level: 2)\n            admin = sign_in(Fabricate(:admin))\n            invite = Fabricate(:invite, invited_by: inviter,  email: nil, max_redemptions_allowed: 5, expires_at: 1.month.from_now, emailed_status: Invite.emailed_status_types[:not_required])\n\n            get \"/u/#{inviter.username}/invited/pending.json\"\n            expect(response.status).to eq(200)\n\n            invites = response.parsed_body['invites']\n            expect(invites.size).to eq(1)\n            expect(invites.first).to include(\"id\" => invite.id)\n            expect(response.parsed_body['can_see_invite_details']).to eq(true)\n          end\n        end\n\n        context 'without permission to see invite links' do\n          it 'does not return invites' do\n            user = Fabricate(:user, trust_level: 2)\n            inviter = admin\n            Fabricate(:invite, invited_by: inviter,  email: nil, max_redemptions_allowed: 5, expires_at: 1.month.from_now, emailed_status: Invite.emailed_status_types[:not_required])\n\n            get \"/u/#{inviter.username}/invited/pending.json\"\n            expect(response.status).to eq(403)\n          end\n        end\n      end\n\n      context 'with redeemed invites' do\n        it 'returns invites' do\n          sign_in(moderator)\n          invite = Fabricate(:invite, invited_by: inviter)\n          Fabricate(:invited_user, invite: invite, user: invitee)\n\n          get \"/u/#{inviter.username}/invited.json\"\n          expect(response.status).to eq(200)\n\n          invites = response.parsed_body['invites']\n          expect(invites.size).to eq(1)\n          expect(invites[0]).to include('id' => invite.id)\n        end\n      end\n    end\n  end\n\n  describe '#update' do\n    context 'with guest' do\n      it 'raises an error' do\n        put \"/u/guest.json\"\n        expect(response.status).to eq(403)\n      end\n    end\n\n    it \"does not allow name to be updated if auth auth_overrides_name is enabled\" do\n      SiteSetting.auth_overrides_name = true\n\n      sign_in(user1)\n\n      put \"/u/#{user1.username}\", params: { name: 'test.test' }\n\n      expect(response.status).to eq(200)\n      expect(user1.reload.name).to_not eq('test.test')\n    end\n\n    context \"when username contains a period\" do\n      before do\n        sign_in(user)\n      end\n\n      fab!(:user) { Fabricate(:user, username: 'test.test', name: \"Test User\") }\n\n      it \"should be able to update a user\" do\n        put \"/u/#{user.username}\", params: { name: 'test.test' }\n\n        expect(response.status).to eq(200)\n        expect(user.reload.name).to eq('test.test')\n      end\n    end\n\n    context \"as a staff user\" do\n      context \"uneditable field\" do\n        fab!(:user_field) { Fabricate(:user_field, editable: false) }\n\n        it \"allows staff to edit the field\" do\n          sign_in(admin)\n          put \"/u/#{user.username}.json\", params: {\n            name: 'Jim Tom',\n            title: \"foobar\",\n            user_fields: { user_field.id.to_s => 'happy' }\n          }\n\n          expect(response.status).to eq(200)\n\n          user.reload\n\n          expect(user.user_fields[user_field.id.to_s]).to eq('happy')\n          expect(user.title).to eq(\"foobar\")\n        end\n      end\n    end\n\n    context 'with authenticated user' do\n      context 'with permission to update' do\n        fab!(:upload) { Fabricate(:upload) }\n        fab!(:user) { Fabricate(:user) }\n\n        before do\n          sign_in(user)\n        end\n\n        it 'allows the update' do\n          SiteSetting.tagging_enabled = true\n          user2 = Fabricate(:user)\n          user3 = Fabricate(:user)\n          tags = [Fabricate(:tag), Fabricate(:tag)]\n          tag_synonym = Fabricate(:tag, target_tag: tags[1])\n\n          put \"/u/#{user.username}.json\", params: {\n            name: 'Jim Tom',\n            muted_usernames: \"#{user2.username},#{user3.username}\",\n            watched_tags: \"#{tags[0].name},#{tag_synonym.name}\",\n            card_background_upload_url: upload.url,\n            profile_background_upload_url: upload.url\n          }\n\n          expect(response.status).to eq(200)\n\n          user.reload\n\n          expect(user.name).to eq 'Jim Tom'\n          expect(user.muted_users.pluck(:username).sort).to eq [user2.username, user3.username].sort\n\n          expect(TagUser.where(\n            user: user,\n            notification_level: TagUser.notification_levels[:watching]\n          ).pluck(:tag_id)).to contain_exactly(tags[0].id, tags[1].id)\n\n          theme = Fabricate(:theme, user_selectable: true)\n\n          put \"/u/#{user.username}.json\", params: {\n            muted_usernames: \"\",\n            theme_ids: [theme.id],\n            email_level: UserOption.email_level_types[:always]\n          }\n\n          user.reload\n\n          expect(user.muted_users.pluck(:username).sort).to be_empty\n          expect(user.user_option.theme_ids).to eq([theme.id])\n          expect(user.user_option.email_level).to eq(UserOption.email_level_types[:always])\n          expect(user.profile_background_upload).to eq(upload)\n          expect(user.card_background_upload).to eq(upload)\n        end\n\n        context 'a locale is chosen that differs from I18n.locale' do\n          before do\n            SiteSetting.allow_user_locale = true\n          end\n\n          it \"updates the user's locale\" do\n            I18n.locale = :fr\n            put \"/u/#{user.username}.json\", params: { locale: :fa_IR }\n            expect(user.reload.locale).to eq('fa_IR')\n          end\n\n          it \"updates the title\" do\n            BadgeGranter.enable_queue\n            user.update!(locale: :fr)\n            user.change_trust_level!(TrustLevel[4])\n            BadgeGranter.process_queue!\n\n            leader_title = I18n.t(\"badges.leader.name\", locale: :fr)\n            put \"/u/#{user.username}.json\", params: { title: leader_title }\n            expect(user.reload.title).to eq(leader_title)\n          ensure\n            BadgeGranter.disable_queue\n            BadgeGranter.clear_queue!\n          end\n        end\n\n        context \"with user fields\" do\n          context \"an editable field\" do\n            fab!(:user_field) { Fabricate(:user_field) }\n            fab!(:optional_field) { Fabricate(:user_field, required: false) }\n\n            it \"should update the user field\" do\n              put \"/u/#{user.username}.json\", params: { name: 'Jim Tom', user_fields: { user_field.id.to_s => 'happy' } }\n\n              expect(response.status).to eq(200)\n              expect(user.user_fields[user_field.id.to_s]).to eq 'happy'\n            end\n\n            it \"cannot be updated to blank\" do\n              put \"/u/#{user.username}.json\", params: { name: 'Jim Tom', user_fields: { user_field.id.to_s => '' } }\n\n              expect(response.status).to eq(422)\n              expect(user.user_fields[user_field.id.to_s]).not_to eq('happy')\n            end\n\n            it \"trims excessively large fields\" do\n              put \"/u/#{user.username}.json\", params: { name: 'Jim Tom', user_fields: { user_field.id.to_s => ('x' * 3000) } }\n\n              expect(user.user_fields[user_field.id.to_s].size).to eq(UserField.max_length)\n            end\n\n            it \"should retain existing user fields\" do\n              put \"/u/#{user.username}.json\", params: { name: 'Jim Tom', user_fields: { user_field.id.to_s => 'happy', optional_field.id.to_s => 'feet' } }\n\n              expect(response.status).to eq(200)\n              expect(user.user_fields[user_field.id.to_s]).to eq('happy')\n              expect(user.user_fields[optional_field.id.to_s]).to eq('feet')\n\n              put \"/u/#{user.username}.json\", params: { name: 'Jim Tom', user_fields: { user_field.id.to_s => 'sad' } }\n\n              expect(response.status).to eq(200)\n\n              user.reload\n\n              expect(user.user_fields[user_field.id.to_s]).to eq('sad')\n              expect(user.user_fields[optional_field.id.to_s]).to eq('feet')\n            end\n          end\n\n          context \"with user_notification_schedule attributes\" do\n            it \"updates the user's notification schedule\" do\n              params = {\n                user_notification_schedule: {\n                  enabled: true,\n                  day_0_start_time: 30,\n                  day_0_end_time: 60,\n                  day_1_start_time: 30,\n                  day_1_end_time: 60,\n                  day_2_start_time: 30,\n                  day_2_end_time: 60,\n                  day_3_start_time: 30,\n                  day_3_end_time: 60,\n                  day_4_start_time: 30,\n                  day_4_end_time: 60,\n                  day_5_start_time: 30,\n                  day_5_end_time: 60,\n                  day_6_start_time: 30,\n                  day_6_end_time: 60,\n                }\n              }\n              put \"/u/#{user.username}.json\", params: params\n\n              user.reload\n              expect(user.user_notification_schedule.enabled).to eq(true)\n              expect(user.user_notification_schedule.day_0_start_time).to eq(30)\n              expect(user.user_notification_schedule.day_0_end_time).to eq(60)\n              expect(user.user_notification_schedule.day_6_start_time).to eq(30)\n              expect(user.user_notification_schedule.day_6_end_time).to eq(60)\n            end\n          end\n\n          context \"uneditable field\" do\n            fab!(:user_field) { Fabricate(:user_field, editable: false) }\n\n            it \"does not update the user field\" do\n              put \"/u/#{user.username}.json\", params: { name: 'Jim Tom', user_fields: { user_field.id.to_s => 'happy' } }\n\n              expect(response.status).to eq(200)\n              expect(user.user_fields[user_field.id.to_s]).to be_blank\n            end\n          end\n\n          context \"custom_field\" do\n            before do\n              plugin = Plugin::Instance.new\n              plugin.register_editable_user_custom_field :test2\n              plugin.register_editable_user_custom_field :test3, staff_only: true\n            end\n\n            after do\n              DiscoursePluginRegistry.reset!\n            end\n\n            it \"only updates allowed user fields\" do\n              put \"/u/#{user.username}.json\", params: { custom_fields: { test1: :hello1, test2: :hello2, test3: :hello3 } }\n\n              expect(response.status).to eq(200)\n              expect(user.custom_fields[\"test1\"]).to be_blank\n              expect(user.custom_fields[\"test2\"]).to eq(\"hello2\")\n              expect(user.custom_fields[\"test3\"]).to be_blank\n            end\n\n            it \"works alongside a user field\" do\n              user_field = Fabricate(:user_field, editable: true)\n              put \"/u/#{user.username}.json\", params: { custom_fields: { test1: :hello1, test2: :hello2, test3: :hello3 }, user_fields: { user_field.id.to_s => 'happy' } }\n              expect(response.status).to eq(200)\n              expect(user.custom_fields[\"test1\"]).to be_blank\n              expect(user.custom_fields[\"test2\"]).to eq(\"hello2\")\n              expect(user.custom_fields[\"test3\"]).to eq(nil)\n              expect(user.user_fields[user_field.id.to_s]).to eq('happy')\n            end\n\n            it \"works alongside a user field during creation\" do\n              api_key = Fabricate(:api_key, user: admin)\n              user_field = Fabricate(:user_field, editable: true)\n              post \"/u.json\", params: {\n                name: \"Test User\",\n                username: \"testuser\",\n                email: \"user@mail.com\",\n                password: 'supersecure',\n                active: true,\n                custom_fields: {\n                  test2: 'custom field value'\n                },\n                user_fields: {\n                  user_field.id.to_s => 'user field value'\n                }\n              }, headers: {\n                HTTP_API_KEY: api_key.key\n              }\n              expect(response.status).to eq(200)\n              u = User.find_by_email('user@mail.com')\n\n              val = u.custom_fields[\"user_field_#{user_field.id}\"]\n              expect(val).to eq('user field value')\n\n              val = u.custom_fields[\"test2\"]\n              expect(val).to eq('custom field value')\n            end\n\n            it \"is secure when there are no registered editable fields\" do\n              DiscoursePluginRegistry.reset!\n              put \"/u/#{user.username}.json\", params: { custom_fields: { test1: :hello1, test2: :hello2, test3: :hello3 } }\n              expect(response.status).to eq(200)\n              expect(user.custom_fields[\"test1\"]).to be_blank\n              expect(user.custom_fields[\"test2\"]).to be_blank\n              expect(user.custom_fields[\"test3\"]).to be_blank\n\n              put \"/u/#{user.username}.json\", params: { custom_fields: [\"arrayitem1\", \"arrayitem2\"] }\n              expect(response.status).to eq(200)\n            end\n\n            it \"allows staff to edit staff-editable fields\" do\n              sign_in(admin)\n              put \"/u/#{user.username}.json\", params: { custom_fields: { test1: :hello1, test2: :hello2, test3: :hello3 } }\n\n              expect(response.status).to eq(200)\n              expect(user.custom_fields[\"test1\"]).to be_blank\n              expect(user.custom_fields[\"test2\"]).to eq(\"hello2\")\n              expect(user.custom_fields[\"test3\"]).to eq(\"hello3\")\n            end\n\n          end\n        end\n\n        it 'returns user JSON' do\n          put \"/u/#{user.username}.json\"\n\n          json = response.parsed_body\n          expect(json['user']['id']).to eq user.id\n        end\n      end\n\n      context 'without permission to update' do\n        it 'does not allow the update' do\n          user = Fabricate(:user, name: 'Billy Bob')\n          sign_in(Fabricate(:user))\n\n          put \"/u/#{user.username}.json\", params: { name: 'Jim Tom' }\n\n          expect(response).to be_forbidden\n          expect(user.reload.name).not_to eq 'Jim Tom'\n        end\n      end\n    end\n  end\n\n  describe '#badge_title' do\n    fab!(:badge) { Fabricate(:badge) }\n    let(:user_badge) { BadgeGranter.grant(badge, user1) }\n\n    it \"sets the user's title to the badge name if it is titleable\" do\n      sign_in(user1)\n\n      put \"/u/#{user1.username}/preferences/badge_title.json\", params: { user_badge_id: user_badge.id }\n\n      expect(user1.reload.title).not_to eq(badge.display_name)\n      badge.update allow_title: true\n\n      put \"/u/#{user1.username}/preferences/badge_title.json\", params: { user_badge_id: user_badge.id }\n\n      expect(user1.reload.title).to eq(badge.display_name)\n      expect(user1.user_profile.badge_granted_title).to eq(true)\n      expect(user1.user_profile.granted_title_badge_id).to eq(badge.id)\n\n      badge.update allow_title: false\n\n      put \"/u/#{user1.username}/preferences/badge_title.json\", params: { user_badge_id: user_badge.id }\n\n      user1.reload\n      user1.user_profile.reload\n      expect(user1.title).to eq('')\n      expect(user1.user_profile.badge_granted_title).to eq(false)\n      expect(user1.user_profile.granted_title_badge_id).to eq(nil)\n    end\n\n    it \"is not raising an erroring when user revokes title\" do\n      sign_in(user1)\n      badge.update allow_title: true\n      put \"/u/#{user1.username}/preferences/badge_title.json\", params: { user_badge_id: user_badge.id }\n      put \"/u/#{user1.username}/preferences/badge_title.json\", params: { user_badge_id: 0 }\n      expect(response.status).to eq(200)\n    end\n\n    context \"with overridden name\" do\n      fab!(:badge) { Fabricate(:badge, name: 'Demogorgon', allow_title: true) }\n      let(:user_badge) { BadgeGranter.grant(badge, user1) }\n\n      before do\n        TranslationOverride.upsert!('en', 'badges.demogorgon.name', 'Boss')\n      end\n\n      after do\n        TranslationOverride.revert!('en', ['badges.demogorgon.name'])\n      end\n\n      it \"uses the badge display name as user title\" do\n        sign_in(user1)\n\n        put \"/u/#{user1.username}/preferences/badge_title.json\", params: { user_badge_id: user_badge.id }\n        expect(user1.reload.title).to eq(badge.display_name)\n      end\n    end\n  end\n\n  describe '#send_activation_email' do\n    before do\n      UsersController.any_instance.stubs(:honeypot_value).returns(nil)\n      UsersController.any_instance.stubs(:challenge_value).returns(nil)\n    end\n\n    let(:post_user) do\n      post \"/u.json\", params: {\n        username: \"osamatest\",\n        password: \"strongpassword\",\n        email: \"dsdsds@sasa.com\"\n      }\n\n      User.find_by(username: \"osamatest\")\n    end\n\n    context 'for an existing user' do\n      context 'for an activated account with email confirmed' do\n        it 'fails' do\n          user = post_user\n          email_token = Fabricate(:email_token, user: user).token\n          EmailToken.confirm(email_token)\n\n          post \"/u/action/send_activation_email.json\", params: { username: user.username }\n\n          expect(response.status).to eq(409)\n          expect(response.parsed_body['errors']).to include(I18n.t(\n            'activation.activated'\n          ))\n          expect(session[SessionController::ACTIVATE_USER_KEY]).to eq(nil)\n        end\n      end\n\n      context 'for an activated account with unconfirmed email' do\n        it 'should send an email' do\n          user = post_user\n          user.update!(active: true)\n          Fabricate(:email_token, user: user)\n\n          expect_enqueued_with(job: :critical_user_email, args: { type: :signup, to_address: user.email }) do\n            post \"/u/action/send_activation_email.json\", params: {\n              username: user.username\n            }\n          end\n\n          expect(response.status).to eq(200)\n\n          expect(session[SessionController::ACTIVATE_USER_KEY]).to eq(nil)\n        end\n      end\n\n      context \"approval is enabled\" do\n        before do\n          SiteSetting.must_approve_users = true\n        end\n\n        it \"should raise an error\" do\n          user = post_user\n          user.update(active: true)\n          user.save!\n          Fabricate(:email_token, user: user1)\n          post \"/u/action/send_activation_email.json\", params: {\n            username: user.username\n          }\n\n          expect(response.status).to eq(403)\n        end\n      end\n\n      describe 'when user does not have a valid session' do\n        it 'should not be valid' do\n          post \"/u/action/send_activation_email.json\", params: {\n            username: user.username\n          }\n          expect(response.status).to eq(403)\n        end\n\n        it 'should allow staff regardless' do\n          sign_in(admin)\n          user = Fabricate(:user, active: false)\n          post \"/u/action/send_activation_email.json\", params: {\n            username: user.username\n          }\n          expect(response.status).to eq(200)\n        end\n      end\n\n      context 'with a valid email_token' do\n        it 'should send the activation email' do\n          user = post_user\n\n          expect_enqueued_with(job: :critical_user_email, args: { type: :signup }) do\n            post \"/u/action/send_activation_email.json\", params: {\n              username: user.username\n            }\n          end\n\n          expect(response.status).to eq(200)\n          expect(session[SessionController::ACTIVATE_USER_KEY]).to eq(nil)\n        end\n      end\n\n      context 'without an existing email_token' do\n        let(:user) { post_user }\n        before do\n          user.email_tokens.each { |t| t.destroy }\n          user.reload\n        end\n\n        it 'should generate a new token' do\n          expect {\n            post \"/u/action/send_activation_email.json\", params: { username: user.username }\n          }.to change { user.reload.email_tokens.count }.by(1)\n        end\n\n        it 'should send an email' do\n          expect do\n            post \"/u/action/send_activation_email.json\", params: {\n              username: user.username\n            }\n          end.to change { Jobs::CriticalUserEmail.jobs.size }.by(1)\n\n          expect(session[SessionController::ACTIVATE_USER_KEY]).to eq(nil)\n        end\n      end\n    end\n\n    context 'when username does not exist' do\n      it 'should not send an email' do\n        post \"/u/action/send_activation_email.json\", params: { username: 'nopenopenopenope' }\n        expect(response.status).to eq(404)\n        expect(Jobs::CriticalUserEmail.jobs.size).to eq(0)\n      end\n    end\n  end\n\n  describe '#pick_avatar' do\n    it 'raises an error when not logged in' do\n      put \"/u/asdf/preferences/avatar/pick.json\", params: { avatar_id: 1, type: \"custom\" }\n      expect(response.status).to eq(403)\n    end\n\n    context 'while logged in' do\n      before do\n        sign_in(user1)\n      end\n\n      fab!(:upload) do\n        Fabricate(:upload, user: user1)\n      end\n\n      it \"raises an error when you don't have permission to toggle the avatar\" do\n        put \"/u/#{another_user.username}/preferences/avatar/pick.json\", params: {\n          upload_id: upload.id, type: \"custom\"\n        }\n\n        expect(response).to be_forbidden\n      end\n\n      it \"raises an error when discourse_connect_overrides_avatar is disabled\" do\n        SiteSetting.discourse_connect_overrides_avatar = true\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\", params: {\n          upload_id: upload.id, type: \"custom\"\n        }\n\n        expect(response.status).to eq(422)\n      end\n\n      it \"raises an error when selecting the custom/uploaded avatar and allow_uploaded_avatars is disabled\" do\n        SiteSetting.allow_uploaded_avatars = 'disabled'\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\", params: {\n          upload_id: upload.id, type: \"custom\"\n        }\n\n        expect(response.status).to eq(422)\n      end\n\n      it \"raises an error when selecting the custom/uploaded avatar and allow_uploaded_avatars is admin\" do\n        SiteSetting.allow_uploaded_avatars = 'admin'\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\", params: {\n          upload_id: upload.id, type: \"custom\"\n        }\n        expect(response.status).to eq(422)\n\n        user1.update!(admin: true)\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\", params: {\n          upload_id: upload.id, type: \"custom\"\n        }\n        expect(response.status).to eq(200)\n      end\n\n      it \"raises an error when selecting the custom/uploaded avatar and allow_uploaded_avatars is staff\" do\n        SiteSetting.allow_uploaded_avatars = 'staff'\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\", params: {\n          upload_id: upload.id, type: \"custom\"\n        }\n        expect(response.status).to eq(422)\n\n        user1.update!(moderator: true)\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\", params: {\n          upload_id: upload.id, type: \"custom\"\n        }\n        expect(response.status).to eq(200)\n      end\n\n      it \"raises an error when selecting the custom/uploaded avatar and allow_uploaded_avatars is a trust level\" do\n        SiteSetting.allow_uploaded_avatars = '3'\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\", params: {\n          upload_id: upload.id, type: \"custom\"\n        }\n        expect(response.status).to eq(422)\n\n        user1.update!(trust_level: 3)\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\", params: {\n          upload_id: upload.id, type: \"custom\"\n        }\n        expect(response.status).to eq(200)\n      end\n\n      it 'ignores the upload if picking a system avatar' do\n        SiteSetting.allow_uploaded_avatars = 'disabled'\n        another_upload = Fabricate(:upload)\n\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\", params: {\n          upload_id: another_upload.id, type: \"system\"\n        }\n\n        expect(response.status).to eq(200)\n        expect(user1.reload.uploaded_avatar_id).to eq(nil)\n      end\n\n      it 'raises an error if the type is invalid' do\n        SiteSetting.allow_uploaded_avatars = 'disabled'\n        another_upload = Fabricate(:upload)\n\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\", params: {\n          upload_id: another_upload.id, type: \"x\"\n        }\n\n        expect(response.status).to eq(422)\n      end\n\n      it 'can successfully pick the system avatar' do\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\"\n\n        expect(response.status).to eq(200)\n        expect(user1.reload.uploaded_avatar_id).to eq(nil)\n      end\n\n      it 'disables the use_site_small_logo_as_system_avatar setting when picking an avatar for the system user' do\n        system_user = Discourse.system_user\n        SiteSetting.use_site_small_logo_as_system_avatar = true\n        another_upload = Fabricate(:upload, user: system_user)\n        sign_in(system_user)\n\n        put \"/u/#{system_user.username}/preferences/avatar/pick.json\", params: {\n          upload_id: another_upload.id, type: \"uploaded\"\n        }\n\n        expect(response.status).to eq(200)\n        expect(SiteSetting.use_site_small_logo_as_system_avatar).to eq(false)\n      end\n\n      it 'can successfully pick a gravatar' do\n\n        user1.user_avatar.update_columns(gravatar_upload_id: upload.id)\n\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\", params: {\n          upload_id: upload.id, type: \"gravatar\"\n        }\n\n        expect(response.status).to eq(200)\n        expect(user1.reload.uploaded_avatar_id).to eq(upload.id)\n        expect(user1.user_avatar.reload.gravatar_upload_id).to eq(upload.id)\n      end\n\n      it 'can not pick uploads that were not created by user' do\n        upload2 = Fabricate(:upload)\n\n        put \"/u/#{user1.username}/preferences/avatar/pick.json\", params: {\n          upload_id: upload2.id, type: \"custom\"\n        }\n\n        expect(response.status).to eq(403)\n      end\n\n      it 'can successfully pick a custom avatar' do\n        events = DiscourseEvent.track_events do\n          put \"/u/#{user1.username}/preferences/avatar/pick.json\", params: {\n            upload_id: upload.id, type: \"custom\"\n          }\n        end\n\n        expect(events.map { |event| event[:event_name] }).to include(:user_updated)\n        expect(response.status).to eq(200)\n        expect(user1.reload.uploaded_avatar_id).to eq(upload.id)\n        expect(user1.user_avatar.reload.custom_upload_id).to eq(upload.id)\n      end\n    end\n  end\n\n  describe '#select_avatar' do\n    it 'raises an error when not logged in' do\n      put \"/u/asdf/preferences/avatar/select.json\", params: { url: \"https://meta.discourse.org\" }\n      expect(response.status).to eq(403)\n    end\n\n    context 'while logged in' do\n      before do\n        sign_in(user1)\n      end\n\n      fab!(:avatar1) { Fabricate(:upload) }\n      fab!(:avatar2) { Fabricate(:upload) }\n      let(:url) { \"https://www.discourse.org\" }\n\n      it 'raises an error when url is blank' do\n        put \"/u/#{user1.username}/preferences/avatar/select.json\", params: { url: \"\" }\n        expect(response.status).to eq(422)\n      end\n\n      it 'raises an error when selectable avatars is disabled' do\n        put \"/u/#{user1.username}/preferences/avatar/select.json\", params: { url: url }\n        expect(response.status).to eq(422)\n      end\n\n      context 'selectable avatars is enabled' do\n\n        before do\n          SiteSetting.selectable_avatars = [avatar1, avatar2]\n          SiteSetting.selectable_avatars_enabled = true\n        end\n\n        it 'raises an error when selectable avatars is empty' do\n          SiteSetting.selectable_avatars = \"\"\n          put \"/u/#{user1.username}/preferences/avatar/select.json\", params: { url: url }\n          expect(response.status).to eq(422)\n        end\n\n        context 'selectable avatars is properly setup' do\n          it 'raises an error when url is not in selectable avatars list' do\n            put \"/u/#{user1.username}/preferences/avatar/select.json\", params: { url: url }\n            expect(response.status).to eq(422)\n          end\n\n          it 'can successfully select an avatar' do\n            events = DiscourseEvent.track_events do\n              put \"/u/#{user1.username}/preferences/avatar/select.json\", params: { url: avatar1.url }\n            end\n\n            expect(events.map { |event| event[:event_name] }).to include(:user_updated)\n            expect(response.status).to eq(200)\n            expect(user1.reload.uploaded_avatar_id).to eq(avatar1.id)\n            expect(user1.user_avatar.reload.custom_upload_id).to eq(avatar1.id)\n          end\n\n          it 'can successfully select an avatar using a cooked URL' do\n            events = DiscourseEvent.track_events do\n              put \"/u/#{user1.username}/preferences/avatar/select.json\", params: { url: UrlHelper.cook_url(avatar1.url) }\n            end\n\n            expect(events.map { |event| event[:event_name] }).to include(:user_updated)\n            expect(response.status).to eq(200)\n            expect(user1.reload.uploaded_avatar_id).to eq(avatar1.id)\n            expect(user1.user_avatar.reload.custom_upload_id).to eq(avatar1.id)\n          end\n\n          it 'disables the use_site_small_logo_as_system_avatar setting when picking an avatar for the system user' do\n            system_user = Discourse.system_user\n            SiteSetting.use_site_small_logo_as_system_avatar = true\n            sign_in(system_user)\n\n            put \"/u/#{system_user.username}/preferences/avatar/select.json\", params: {\n              url: UrlHelper.cook_url(avatar1.url)\n            }\n\n            expect(response.status).to eq(200)\n            expect(SiteSetting.use_site_small_logo_as_system_avatar).to eq(false)\n          end\n        end\n      end\n    end\n  end\n\n  describe '#destroy_user_image' do\n\n    it 'raises an error when not logged in' do\n      delete \"/u/asdf/preferences/user_image.json\", params: { type: 'profile_background' }\n      expect(response.status).to eq(403)\n    end\n\n    context 'while logged in' do\n      before do\n        sign_in(user1)\n      end\n\n      it 'raises an error when you don\\'t have permission to clear the profile background' do\n        delete \"/u/#{another_user.username}/preferences/user_image.json\", params: { type: 'profile_background' }\n        expect(response).to be_forbidden\n      end\n\n      it \"requires the `type` param\" do\n        delete \"/u/#{user1.username}/preferences/user_image.json\"\n        expect(response.status).to eq(400)\n      end\n\n      it \"only allows certain `types`\" do\n        delete \"/u/#{user1.username}/preferences/user_image.json\", params: { type: 'wat' }\n        expect(response.status).to eq(400)\n      end\n\n      it 'can clear the profile background' do\n        delete \"/u/#{user1.username}/preferences/user_image.json\", params: { type: 'profile_background' }\n\n        expect(user1.reload.profile_background_upload).to eq(nil)\n        expect(response.status).to eq(200)\n      end\n    end\n  end\n\n  describe '#destroy' do\n    it 'raises an error when not logged in' do\n      delete \"/u/nobody.json\"\n      expect(response.status).to eq(403)\n    end\n\n    context 'while logged in' do\n      before do\n        sign_in(user1)\n      end\n\n      it 'raises an error when you cannot delete your account' do\n        UserDestroyer.any_instance.expects(:destroy).never\n        stat = user1.user_stat\n        stat.post_count = 3\n        stat.save!\n        delete \"/u/#{user1.username}.json\"\n        expect(response).to be_forbidden\n      end\n\n      it \"raises an error when you try to delete someone else's account\" do\n        UserDestroyer.any_instance.expects(:destroy).never\n        delete \"/u/#{another_user.username}.json\"\n        expect(response).to be_forbidden\n      end\n\n      it \"deletes your account when you're allowed to\" do\n        UserDestroyer.any_instance.expects(:destroy).with(user1, anything).returns(user1)\n        delete \"/u/#{user1.username}.json\"\n        expect(response.status).to eq(200)\n      end\n    end\n  end\n\n  describe '#ignore' do\n    it 'raises an error when not logged in' do\n      put \"/u/#{user1.username}/notification_level.json\", params: { notification_level: \"\" }\n      expect(response.status).to eq(403)\n    end\n\n    context 'while logged in' do\n      fab!(:user) { Fabricate(:user, trust_level: 2) }\n      before do\n        sign_in(user)\n      end\n\n      fab!(:ignored_user) { Fabricate(:ignored_user, user: user, ignored_user: another_user) }\n      fab!(:muted_user) { Fabricate(:muted_user, user: user, muted_user: another_user) }\n\n      context \"when you can't change the notification\" do\n        fab!(:staff_user) { admin }\n\n        it \"ignoring includes a helpful error message\" do\n          put \"/u/#{staff_user.username}/notification_level.json\", params: { notification_level: 'ignore' }\n          expect(response.status).to eq(422)\n          expect(response.parsed_body['errors'][0]).to eq(I18n.t(\"notification_level.ignore_error\"))\n        end\n\n        it \"muting includes a helpful error message\" do\n          put \"/u/#{staff_user.username}/notification_level.json\", params: { notification_level: 'mute' }\n          expect(response.status).to eq(422)\n          expect(response.parsed_body['errors'][0]).to eq(I18n.t(\"notification_level.mute_error\"))\n        end\n      end\n\n      context 'when changing notification level to normal' do\n        it 'changes notification level to normal' do\n          put \"/u/#{another_user.username}/notification_level.json\", params: { notification_level: \"normal\" }\n          expect(IgnoredUser.count).to eq(0)\n          expect(MutedUser.count).to eq(0)\n        end\n      end\n\n      context 'when changing notification level to mute' do\n        it 'changes notification level to mute' do\n          put \"/u/#{another_user.username}/notification_level.json\", params: { notification_level: \"mute\" }\n          expect(IgnoredUser.count).to eq(0)\n          expect(MutedUser.find_by(user_id: user.id, muted_user_id: another_user.id)).to be_present\n        end\n      end\n\n      context 'when changing notification level to ignore' do\n        it 'changes notification level to ignore' do\n          put \"/u/#{another_user.username}/notification_level.json\", params: { notification_level: \"ignore\" }\n          expect(MutedUser.count).to eq(0)\n          expect(IgnoredUser.find_by(user_id: user.id, ignored_user_id: another_user.id)).to be_present\n        end\n\n        context 'when expiring_at param is set' do\n          it 'changes notification level to ignore' do\n            freeze_time(Time.now) do\n              expiring_at = 3.days.from_now\n              put \"/u/#{another_user.username}/notification_level.json\", params: { notification_level: \"ignore\", expiring_at: expiring_at }\n\n              ignored_user = IgnoredUser.find_by(user_id: user.id, ignored_user_id: another_user.id)\n              expect(ignored_user).to be_present\n              expect(ignored_user.expiring_at.to_i).to eq(expiring_at.to_i)\n              expect(MutedUser.count).to eq(0)\n            end\n          end\n        end\n      end\n    end\n  end\n\n  describe \"for user with period in username\" do\n    fab!(:user_with_period) { Fabricate(:user, username: \"myname.test\") }\n\n    it \"still works\" do\n      sign_in(user_with_period)\n      UserDestroyer.any_instance.expects(:destroy).with(user_with_period, anything).returns(user_with_period)\n      delete \"/u/#{user_with_period.username}\", xhr: true\n      expect(response.status).to eq(200)\n    end\n  end\n\n  describe '#my_redirect' do\n    it \"redirects if the user is not logged in\" do\n      get \"/my/wat\"\n      expect(response).to redirect_to(\"/login-preferences\")\n      expect(response.cookies).to have_key(\"destination_url\")\n      expect(response.cookies[\"destination_url\"]).to eq(\"/my/wat\")\n      expect(response.headers['X-Robots-Tag']).to eq('noindex')\n    end\n\n    context \"when the user is logged in\" do\n      before do\n        sign_in(user1)\n      end\n\n      it \"will not redirect to an invalid path\" do\n        get \"/my/wat/..password.txt\"\n        expect(response).not_to be_redirect\n      end\n\n      it \"will redirect to an valid path\" do\n        get \"/my/preferences\"\n        expect(response).to redirect_to(\"/u/#{user1.username}/preferences\")\n      end\n\n      it \"permits forward slashes\" do\n        get \"/my/activity/posts\"\n        expect(response).to redirect_to(\"/u/#{user1.username}/activity/posts\")\n      end\n\n      it \"correctly redirects for Unicode usernames\" do\n        SiteSetting.unicode_usernames = true\n        user = sign_in(Fabricate(:unicode_user))\n\n        get \"/my/preferences\"\n        expect(response).to redirect_to(\"/u/#{user.encoded_username}/preferences\")\n      end\n    end\n  end\n\n  describe '#check_emails' do\n    it 'raises an error when not logged in' do\n      get \"/u/zogstrip/emails.json\"\n      expect(response.status).to eq(403)\n    end\n\n    context 'while logged in' do\n      let(:sign_in_admin) { sign_in(admin) }\n\n      it \"raises an error when you aren't allowed to check emails\" do\n        sign_in(Fabricate(:user))\n        get \"/u/#{Fabricate(:user).username}/emails.json\"\n        expect(response).to be_forbidden\n      end\n\n      it \"returns emails and associated_accounts for self\" do\n        Fabricate(:email_change_request, user: user1)\n        sign_in(user)\n\n        get \"/u/#{user.username}/emails.json\"\n\n        expect(response.status).to eq(200)\n        json = response.parsed_body\n        expect(json[\"email\"]).to eq(user.email)\n        expect(json[\"secondary_emails\"]).to eq(user.secondary_emails)\n        expect(json[\"unconfirmed_emails\"]).to eq(user.unconfirmed_emails)\n        expect(json[\"associated_accounts\"]).to eq([])\n      end\n\n      it \"returns emails and associated_accounts when you're allowed to see them\" do\n        Fabricate(:email_change_request, user: user1)\n        sign_in_admin\n\n        get \"/u/#{user.username}/emails.json\"\n\n        expect(response.status).to eq(200)\n        json = response.parsed_body\n        expect(json[\"email\"]).to eq(user.email)\n        expect(json[\"secondary_emails\"]).to eq(user.secondary_emails)\n        expect(json[\"unconfirmed_emails\"]).to eq(user.unconfirmed_emails)\n        expect(json[\"associated_accounts\"]).to eq([])\n      end\n\n      it \"works on inactive users\" do\n        inactive_user = Fabricate(:user, active: false)\n        Fabricate(:email_change_request, user: inactive_user)\n        sign_in_admin\n\n        get \"/u/#{inactive_user.username}/emails.json\"\n\n        expect(response.status).to eq(200)\n        json = response.parsed_body\n        expect(json[\"email\"]).to eq(inactive_user.email)\n        expect(json[\"secondary_emails\"]).to eq(inactive_user.secondary_emails)\n        expect(json[\"unconfirmed_emails\"]).to eq(inactive_user.unconfirmed_emails)\n        expect(json[\"associated_accounts\"]).to eq([])\n      end\n    end\n  end\n\n  describe '#check_sso_email' do\n    it 'raises an error when not logged in' do\n      get \"/u/zogstrip/sso-email.json\"\n      expect(response.status).to eq(403)\n    end\n\n    context 'while logged in' do\n      let(:sign_in_admin) { sign_in(admin) }\n\n      it \"raises an error when you aren't allowed to check sso email\" do\n        sign_in(Fabricate(:user))\n        get \"/u/#{user1.username}/sso-email.json\"\n        expect(response).to be_forbidden\n      end\n\n      it \"returns emails and associated_accounts when you're allowed to see them\" do\n        user1.single_sign_on_record = SingleSignOnRecord.create(user_id: user1.id, external_email: \"foobar@example.com\", external_id: \"example\", last_payload: \"looks good\")\n        sign_in_admin\n\n        get \"/u/#{user1.username}/sso-email.json\"\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"email\"]).to eq(\"foobar@example.com\")\n      end\n    end\n  end\n\n  describe '#check_sso_payload' do\n    it 'raises an error when not logged in' do\n      get \"/u/zogstrip/sso-payload.json\"\n      expect(response.status).to eq(403)\n    end\n\n    context 'while logged in' do\n      let(:sign_in_admin) { sign_in(admin) }\n\n      it \"raises an error when you aren't allowed to check sso payload\" do\n        sign_in(Fabricate(:user))\n        get \"/u/#{user1.username}/sso-payload.json\"\n        expect(response).to be_forbidden\n      end\n\n      it \"returns SSO payload when you're allowed to see\" do\n        user1.single_sign_on_record = SingleSignOnRecord.create(user_id: user1.id, external_email: \"foobar@example.com\", external_id: \"example\", last_payload: \"foobar\")\n        sign_in_admin\n\n        get \"/u/#{user1.username}/sso-payload.json\"\n\n        expect(response.status).to eq(200)\n        expect(response.parsed_body[\"payload\"]).to eq(\"foobar\")\n      end\n    end\n  end\n\n  describe '#update_primary_email' do\n    let(:user_email) { user1.primary_email }\n    fab!(:other_email) { Fabricate(:secondary_email, user: user1) }\n\n    before do\n      SiteSetting.email_editable = true\n\n      sign_in(user1)\n    end\n\n    it \"changes user's primary email\" do\n      put \"/u/#{user1.username}/preferences/primary-email.json\", params: { email: user_email.email }\n      expect(response.status).to eq(200)\n      expect(user_email.reload.primary).to eq(true)\n      expect(other_email.reload.primary).to eq(false)\n\n      event = DiscourseEvent.track_events {\n        expect { put \"/u/#{user1.username}/preferences/primary-email.json\", params: { email: other_email.email } }\n          .to change { UserHistory.where(action: UserHistory.actions[:update_email], acting_user_id: user1.id).count }.by(1)\n      }.last\n\n      expect(response.status).to eq(200)\n      expect(user_email.reload.primary).to eq(false)\n      expect(other_email.reload.primary).to eq(true)\n\n      expect(event[:event_name]).to eq(:user_updated)\n      expect(event[:params].first).to eq(user1)\n    end\n  end\n\n  describe '#destroy_email' do\n    fab!(:user_email) { user1.primary_email }\n    fab!(:other_email) { Fabricate(:secondary_email, user: user1) }\n\n    before do\n      SiteSetting.email_editable = true\n\n      sign_in(user1)\n    end\n\n    it \"can destroy secondary emails\" do\n      delete \"/u/#{user1.username}/preferences/email.json\", params: { email: user_email.email }\n      expect(response.status).to eq(428)\n      expect(user1.reload.user_emails.pluck(:email)).to contain_exactly(user_email.email, other_email.email)\n\n      event = DiscourseEvent.track_events {\n        expect { delete \"/u/#{user1.username}/preferences/email.json\", params: { email: other_email.email } }\n          .to change { UserHistory.where(action: UserHistory.actions[:destroy_email], acting_user_id: user1.id).count }.by(1)\n      }.last\n\n      expect(response.status).to eq(200)\n      expect(user1.reload.user_emails.pluck(:email)).to contain_exactly(user_email.email)\n\n      expect(event[:event_name]).to eq(:user_updated)\n      expect(event[:params].first).to eq(user1)\n    end\n\n    it \"can destroy unconfirmed emails\" do\n      request_1 = EmailChangeRequest.create!(\n        user: user1,\n        new_email: user_email.email,\n        change_state: EmailChangeRequest.states[:authorizing_new]\n      )\n\n      EmailChangeRequest.create!(\n        user: user1,\n        new_email: other_email.email,\n        change_state: EmailChangeRequest.states[:authorizing_new]\n      )\n\n      EmailChangeRequest.create!(\n        user: user1,\n        new_email: other_email.email,\n        change_state: EmailChangeRequest.states[:authorizing_new]\n      )\n\n      delete \"/u/#{user1.username}/preferences/email.json\", params: { email: other_email.email }\n\n      expect(user1.user_emails.pluck(:email)).to contain_exactly(user_email.email, other_email.email)\n      expect(user1.email_change_requests).to contain_exactly(request_1)\n    end\n\n    it \"can destroy associated email tokens\" do\n      new_email = 'new.n.cool@example.com'\n      updater = EmailUpdater.new(guardian: user1.guardian, user: user1)\n\n      expect { updater.change_to(new_email) }\n        .to change { user1.email_tokens.count }.by(1)\n\n      expect { delete \"/u/#{user1.username}/preferences/email.json\", params: { email: new_email } }\n        .to change { user1.email_tokens.count }.by(-1)\n\n      expect(user1.email_tokens.first.email).to eq(user1.email)\n    end\n  end\n\n  describe '#is_local_username' do\n    fab!(:group) { Fabricate(:group, name: \"Discourse\", mentionable_level: Group::ALIAS_LEVELS[:everyone]) }\n    let(:unmentionable) {\n      Fabricate(:group, name: \"Unmentionable\", mentionable_level: Group::ALIAS_LEVELS[:nobody])\n    }\n    fab!(:topic) { Fabricate(:topic) }\n    fab!(:allowed_user) { Fabricate(:user) }\n    fab!(:private_topic) { Fabricate(:private_message_topic, user: allowed_user) }\n\n    it \"finds the user\" do\n      get \"/u/is_local_username.json\", params: { username: user1.username }\n\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"valid\"][0]).to eq(user1.username)\n    end\n\n    it \"finds the group\" do\n      sign_in(user1)\n      get \"/u/is_local_username.json\", params: { username: group.name }\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"valid_groups\"]).to include(group.name)\n      expect(json[\"mentionable_groups\"].find { |g| g['name'] == group.name }).to be_present\n    end\n\n    it \"finds unmentionable groups\" do\n      sign_in(user1)\n      get \"/u/is_local_username.json\", params: { username: unmentionable.name }\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"valid_groups\"]).to include(unmentionable.name)\n      expect(json[\"mentionable_groups\"]).to be_blank\n    end\n\n    it \"supports multiples usernames\" do\n      get \"/u/is_local_username.json\", params: { usernames: [user1.username, \"system\"] }\n\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"valid\"].size).to eq(2)\n    end\n\n    it \"never includes staged accounts\" do\n      staged = Fabricate(:user, staged: true)\n\n      get \"/u/is_local_username.json\", params: { usernames: [staged.username] }\n\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"valid\"].size).to eq(0)\n    end\n\n    it \"returns user who cannot see topic\" do\n      Guardian.any_instance.expects(:can_see?).with(topic).returns(false)\n\n      get \"/u/is_local_username.json\", params: {\n        usernames: [user1.username], topic_id: topic.id\n      }\n\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"cannot_see\"].size).to eq(1)\n    end\n\n    it \"never returns a user who can see the topic\" do\n      Guardian.any_instance.expects(:can_see?).with(topic).returns(true)\n\n      get \"/u/is_local_username.json\", params: {\n        usernames: [user1.username], topic_id: topic.id\n      }\n\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"cannot_see\"].size).to eq(0)\n    end\n\n    it \"returns user who cannot see a private topic\" do\n      Guardian.any_instance.expects(:can_see?).with(private_topic).returns(false)\n\n      get \"/u/is_local_username.json\", params: {\n        usernames: [user1.username], topic_id: private_topic.id\n      }\n\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"cannot_see\"].size).to eq(1)\n    end\n\n    it \"never returns a user who can see the topic\" do\n      Guardian.any_instance.expects(:can_see?).with(private_topic).returns(true)\n\n      get \"/u/is_local_username.json\", params: {\n        usernames: [allowed_user.username], topic_id: private_topic.id\n      }\n\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"cannot_see\"].size).to eq(0)\n    end\n  end\n\n  describe '#topic_tracking_state' do\n    context 'anon' do\n      it \"raises an error on anon for topic_tracking_state\" do\n        get \"/u/#{user1.username}/topic-tracking-state.json\"\n        expect(response.status).to eq(403)\n      end\n    end\n\n    context 'logged on' do\n      it \"detects new topic\" do\n        sign_in(user1)\n\n        topic = Fabricate(:topic)\n        get \"/u/#{user1.username}/topic-tracking-state.json\"\n\n        expect(response.status).to eq(200)\n        states = response.parsed_body\n        expect(states[0][\"topic_id\"]).to eq(topic.id)\n      end\n    end\n  end\n\n  describe '#summary' do\n    it \"generates summary info\" do\n      create_post(user: user)\n\n      get \"/u/#{user.username_lower}/summary.json\"\n      expect(response.headers['X-Robots-Tag']).to eq('noindex')\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n\n      expect(json[\"user_summary\"][\"topic_count\"]).to eq(1)\n      expect(json[\"user_summary\"][\"post_count\"]).to eq(0)\n    end\n\n    context '`hide_profile_and_presence` user option is checked' do\n      before_all do\n        user1.user_option.update_columns(hide_profile_and_presence: true)\n      end\n\n      it \"returns 404\" do\n        get \"/u/#{user1.username_lower}/summary.json\"\n        expect(response.status).to eq(404)\n      end\n\n      it \"returns summary info if `allow_users_to_hide_profile` is false\" do\n        SiteSetting.allow_users_to_hide_profile = false\n\n        get \"/u/#{user1.username_lower}/summary.json\"\n        expect(response.status).to eq(200)\n      end\n    end\n\n    context 'avatar flair in Most... sections' do\n      it \"returns data for automatic groups flair\" do\n        liker = Fabricate(:user, admin: true, moderator: true, trust_level: 1)\n        create_and_like_post(user_deferred, liker)\n\n        get \"/u/#{user_deferred.username_lower}/summary.json\"\n        json = response.parsed_body\n\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"admin\"]).to eq(true)\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"moderator\"]).to eq(true)\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"trust_level\"]).to eq(1)\n      end\n\n      it \"returns data for flair when an icon is used\" do\n        group = Fabricate(:group, name: \"Groupie\", flair_bg_color: \"#111111\", flair_color: \"#999999\", flair_icon: \"icon\")\n        liker = Fabricate(:user, flair_group: group)\n        create_and_like_post(user_deferred, liker)\n\n        get \"/u/#{user_deferred.username_lower}/summary.json\"\n        json = response.parsed_body\n\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"flair_name\"]).to eq(\"Groupie\")\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"flair_url\"]).to eq(\"icon\")\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"flair_bg_color\"]).to eq(\"#111111\")\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"flair_color\"]).to eq(\"#999999\")\n      end\n\n      it \"returns data for flair when an image is used\" do\n        upload = Fabricate(:upload)\n        group = Fabricate(:group, name: \"Groupie\", flair_bg_color: \"#111111\", flair_upload: upload)\n        liker = Fabricate(:user, flair_group: group)\n        create_and_like_post(user_deferred, liker)\n\n        get \"/u/#{user_deferred.username_lower}/summary.json\"\n        json = response.parsed_body\n\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"flair_name\"]).to eq(\"Groupie\")\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"flair_url\"]).to eq(upload.url)\n        expect(json[\"user_summary\"][\"most_liked_by_users\"][0][\"flair_bg_color\"]).to eq(\"#111111\")\n      end\n\n      def create_and_like_post(likee, liker)\n        UserActionManager.enable\n        post = create_post(user: likee)\n        PostActionCreator.like(liker, post)\n      end\n    end\n  end\n\n  describe '#confirm_admin' do\n    it \"fails without a valid token\" do\n      get \"/u/confirm-admin/invalid-token.json\"\n      expect(response).not_to be_successful\n    end\n\n    it \"fails with a missing token\" do\n      get \"/u/confirm-admin/a0a0a0a0a0.json\"\n      expect(response).to_not be_successful\n    end\n\n    it \"succeeds with a valid code as anonymous\" do\n      ac = AdminConfirmation.new(user1, admin)\n      ac.create_confirmation\n      get \"/u/confirm-admin/#{ac.token}.json\"\n      expect(response.status).to eq(200)\n\n      user1.reload\n      expect(user1.admin?).to eq(false)\n    end\n\n    it \"succeeds with a valid code when logged in as that user\" do\n      sign_in(admin)\n\n      ac = AdminConfirmation.new(user1, admin)\n      ac.create_confirmation\n      get \"/u/confirm-admin/#{ac.token}.json\", params: { token: ac.token }\n      expect(response.status).to eq(200)\n\n      user1.reload\n      expect(user1.admin?).to eq(false)\n    end\n\n    it \"fails if you're logged in as a different account\" do\n      sign_in(admin)\n\n      ac = AdminConfirmation.new(user1, Fabricate(:admin))\n      ac.create_confirmation\n      get \"/u/confirm-admin/#{ac.token}.json\"\n      expect(response).to_not be_successful\n\n      user1.reload\n      expect(user1.admin?).to eq(false)\n    end\n\n    describe \"post\" do\n      it \"gives the user admin access when POSTed\" do\n        ac = AdminConfirmation.new(user1, admin)\n        ac.create_confirmation\n        post \"/u/confirm-admin/#{ac.token}.json\"\n        expect(response.status).to eq(200)\n\n        user1.reload\n        expect(user1.admin?).to eq(true)\n      end\n    end\n  end\n\n  describe '#update_activation_email' do\n    before do\n      UsersController.any_instance.stubs(:honeypot_value).returns(nil)\n      UsersController.any_instance.stubs(:challenge_value).returns(nil)\n    end\n\n    let(:post_user) do\n      post \"/u.json\", params: {\n        username: \"osamatest\",\n        password: \"strongpassword\",\n        email: \"osama@example.com\"\n      }\n      user = User.where(username: \"osamatest\").first\n      user.active = false\n      user.save!\n      user\n    end\n\n    context \"with a session variable\" do\n      it \"raises an error with an invalid session value\" do\n        post_user\n\n        post \"/u.json\", params: {\n          username: \"osamatest2\",\n          password: \"strongpassword2\",\n          email: \"osama22@example.com\"\n        }\n        user = User.where(username: \"osamatest2\").first\n        user.destroy\n\n        put \"/u/update-activation-email.json\", params: {\n          email: 'osamaupdated@example.com'\n        }\n\n        expect(response.status).to eq(403)\n      end\n\n      it \"raises an error for an active user\" do\n        user = post_user\n        user.update(active: true)\n        user.save!\n\n        put \"/u/update-activation-email.json\", params: {\n          email: 'osama@example.com'\n        }\n\n        expect(response.status).to eq(403)\n      end\n\n      it \"raises an error when logged in\" do\n        sign_in(moderator)\n        post_user\n\n        put \"/u/update-activation-email.json\", params: {\n          email: 'updatedemail@example.com'\n        }\n\n        expect(response.status).to eq(403)\n      end\n\n      it \"raises an error when the new email is taken\" do\n        active_user = Fabricate(:user)\n        post_user\n\n        put \"/u/update-activation-email.json\", params: {\n          email: active_user.email\n        }\n\n        expect(response.status).to eq(422)\n      end\n\n      it \"raises an error when the email is blocklisted\" do\n        post_user\n        SiteSetting.blocked_email_domains = 'example.com'\n        put \"/u/update-activation-email.json\", params: { email: 'test@example.com' }\n        expect(response.status).to eq(422)\n      end\n\n      it \"can be updated\" do\n        user = post_user\n        token = user.email_tokens.first\n\n        put \"/u/update-activation-email.json\", params: {\n          email: 'updatedemail@example.com'\n        }\n\n        expect(response.status).to eq(200)\n\n        user.reload\n        expect(user.email).to eq('updatedemail@example.com')\n        expect(user.email_tokens.where(email: 'updatedemail@example.com', expired: false)).to be_present\n\n        token.reload\n        expect(token.expired?).to eq(true)\n      end\n    end\n\n    context \"with a username and password\" do\n      it \"raises an error with an invalid username\" do\n        put \"/u/update-activation-email.json\", params: {\n          username: 'eviltrout',\n          password: 'invalid-password',\n          email: 'updatedemail@example.com'\n        }\n\n        expect(response.status).to eq(403)\n      end\n\n      it \"raises an error with an invalid password\" do\n        put \"/u/update-activation-email.json\", params: {\n          username: inactive_user.username,\n          password: 'invalid-password',\n          email: 'updatedemail@example.com'\n        }\n\n        expect(response.status).to eq(403)\n      end\n\n      it \"raises an error for an active user\" do\n        put \"/u/update-activation-email.json\", params: {\n          username: Fabricate(:walter_white).username,\n          password: 'letscook',\n          email: 'updatedemail@example.com'\n        }\n\n        expect(response.status).to eq(403)\n      end\n\n      it \"raises an error when logged in\" do\n        sign_in(moderator)\n\n        put \"/u/update-activation-email.json\", params: {\n          username: inactive_user.username,\n          password: 'qwerqwer123',\n          email: 'updatedemail@example.com'\n        }\n\n        expect(response.status).to eq(403)\n      end\n\n      it \"raises an error when the new email is taken\" do\n        put \"/u/update-activation-email.json\", params: {\n          username: inactive_user.username,\n          password: 'qwerqwer123',\n          email: user.email\n        }\n\n        expect(response.status).to eq(422)\n      end\n\n      it \"can be updated\" do\n        user = inactive_user\n        token = user.email_tokens.first\n\n        put \"/u/update-activation-email.json\", params: {\n          username: user.username,\n          password: 'qwerqwer123',\n          email: 'updatedemail@example.com'\n        }\n\n        expect(response.status).to eq(200)\n\n        user.reload\n        expect(user.email).to eq('updatedemail@example.com')\n        expect(user.email_tokens.where(email: 'updatedemail@example.com', expired: false)).to be_present\n\n        token.reload\n        expect(token.expired?).to eq(true)\n      end\n    end\n  end\n\n  describe '#show' do\n    context \"anon\" do\n      let(:user) { Discourse.system_user }\n\n      it \"returns success\" do\n        get \"/u/#{user.username}.json\"\n        expect(response.status).to eq(200)\n        parsed = response.parsed_body[\"user\"]\n\n        expect(parsed['username']).to eq(user.username)\n        expect(parsed[\"profile_hidden\"]).to be_blank\n        expect(parsed[\"trust_level\"]).to be_present\n      end\n\n      it \"returns a hidden profile\" do\n        user.user_option.update_column(:hide_profile_and_presence, true)\n\n        get \"/u/#{user.username}.json\"\n        expect(response.status).to eq(200)\n        parsed = response.parsed_body[\"user\"]\n\n        expect(parsed[\"username\"]).to eq(user.username)\n        expect(parsed[\"profile_hidden\"]).to eq(true)\n        expect(parsed[\"trust_level\"]).to be_blank\n      end\n\n      it \"should redirect to login page for anonymous user when profiles are hidden\" do\n        SiteSetting.hide_user_profiles_from_public = true\n        get \"/u/#{user.username}.json\"\n        expect(response).to redirect_to '/login'\n      end\n\n      describe \"user profile views\" do\n        it \"should track a user profile view for an anon user\" do\n          get \"/\"\n          UserProfileView.expects(:add).with(another_user.user_profile.id, request.remote_ip, nil)\n          get \"/u/#{another_user.username}.json\"\n        end\n\n        it \"skips tracking\" do\n          UserProfileView.expects(:add).never\n          get \"/u/#{user.username}.json\", params: { skip_track_visit: true }\n        end\n      end\n    end\n\n    context \"logged in\" do\n      before do\n        sign_in(user1)\n      end\n\n      it 'returns success' do\n        get \"/u/#{user1.username}.json\"\n        expect(response.status).to eq(200)\n        expect(response.headers['X-Robots-Tag']).to eq('noindex')\n\n        json = response.parsed_body\n\n        expect(json[\"user\"][\"has_title_badges\"]).to eq(false)\n      end\n\n      it \"returns not found when the username doesn't exist\" do\n        get \"/u/madeuppity.json\"\n        expect(response).not_to be_successful\n      end\n\n      it 'returns not found when the user is inactive' do\n        inactive = Fabricate(:user, active: false)\n        get \"/u/#{inactive.username}.json\"\n        expect(response).not_to be_successful\n      end\n\n      it 'returns success when show_inactive_accounts is true and user is logged in' do\n        SiteSetting.show_inactive_accounts = true\n        inactive = Fabricate(:user, active: false)\n        get \"/u/#{inactive.username}.json\"\n        expect(response.status).to eq(200)\n      end\n\n      it \"raises an error on invalid access\" do\n        Guardian.any_instance.expects(:can_see?).with(user1).returns(false)\n        get \"/u/#{user1.username}.json\"\n        expect(response).to be_forbidden\n      end\n\n      describe \"user profile views\" do\n        it \"should track a user profile view for a signed in user\" do\n          UserProfileView.expects(:add).with(another_user.user_profile.id, request.remote_ip, user1.id)\n          get \"/u/#{another_user.username}.json\"\n        end\n\n        it \"should not track a user profile view for a user viewing his own profile\" do\n          UserProfileView.expects(:add).never\n          get \"/u/#{user1.username}.json\"\n        end\n\n        it \"skips tracking\" do\n          UserProfileView.expects(:add).never\n          get \"/u/#{user1.username}.json\", params: { skip_track_visit: true }\n        end\n      end\n\n      context \"fetching a user by external_id\" do\n        before { user1.create_single_sign_on_record(external_id: '997', last_payload: '') }\n\n        it \"returns fetch for a matching external_id\" do\n          get \"/u/by-external/997.json\"\n          expect(response.status).to eq(200)\n          expect(response.parsed_body[\"user\"][\"username\"]).to eq(user1.username)\n        end\n\n        it \"returns not found when external_id doesn't match\" do\n          get \"/u/by-external/99.json\"\n          expect(response).not_to be_successful\n        end\n\n        context \"for an external provider\" do\n          before do\n            sign_in(admin)\n            SiteSetting.enable_google_oauth2_logins = true\n            UserAssociatedAccount.create!(user: user1, provider_uid: 'myuid', provider_name: 'google_oauth2')\n          end\n\n          it \"doesn't work for non-admin\" do\n            sign_in(user1)\n            get \"/u/by-external/google_oauth2/myuid.json\"\n            expect(response.status).to eq(403)\n          end\n\n          it \"can fetch the user\" do\n            get \"/u/by-external/google_oauth2/myuid.json\"\n            expect(response.status).to eq(200)\n            expect(response.parsed_body[\"user\"][\"username\"]).to eq(user1.username)\n          end\n\n          it \"fails for disabled provider\" do\n            SiteSetting.enable_google_oauth2_logins = false\n            get \"/u/by-external/google_oauth2/myuid.json\"\n            expect(response.status).to eq(404)\n          end\n\n          it \"returns 404 for missing user\" do\n            get \"/u/by-external/google_oauth2/myotheruid.json\"\n            expect(response.status).to eq(404)\n          end\n        end\n      end\n\n      describe \"include_post_count_for\" do\n        fab!(:topic) { Fabricate(:topic) }\n\n        before_all do\n          Fabricate(:post, user: user1, topic: topic)\n          Fabricate(:post, user: admin, topic: topic)\n          Fabricate(:post, user: admin, topic: topic, post_type: Post.types[:whisper])\n        end\n\n        it \"includes only visible posts\" do\n          get \"/u/#{admin.username}.json\", params: { include_post_count_for: topic.id }\n          topic_post_count = response.parsed_body.dig(\"user\", \"topic_post_count\")\n          expect(topic_post_count[topic.id.to_s]).to eq(1)\n        end\n\n        it \"includes all post types for staff members\" do\n          sign_in(admin)\n\n          get \"/u/#{admin.username}.json\", params: { include_post_count_for: topic.id }\n          topic_post_count = response.parsed_body.dig(\"user\", \"topic_post_count\")\n          expect(topic_post_count[topic.id.to_s]).to eq(2)\n        end\n      end\n    end\n\n    it \"should be able to view a user\" do\n      get \"/u/#{user1.username}\"\n\n      expect(response.status).to eq(200)\n      expect(response.body).to include(user1.username)\n    end\n\n    it \"should not be able to view a private user profile\" do\n      user1.user_profile.update!(bio_raw: \"Hello world!\")\n      user1.user_option.update!(hide_profile_and_presence: true)\n\n      get \"/u/#{user1.username}\"\n\n      expect(response.status).to eq(200)\n      expect(response.body).not_to include(\"Hello world!\")\n    end\n\n    describe 'when username contains a period' do\n      before_all do\n        user1.update!(username: 'test.test')\n      end\n\n      it \"should be able to view a user\" do\n        get \"/u/#{user1.username}\"\n\n        expect(response.status).to eq(200)\n        expect(response.body).to include(user1.username)\n      end\n    end\n  end\n\n  describe \"#show_card\" do\n    context \"anon\" do\n      let(:user) { Discourse.system_user }\n\n      it \"returns success\" do\n        get \"/u/#{user.username}/card.json\"\n        expect(response.status).to eq(200)\n        parsed = response.parsed_body[\"user\"]\n\n        expect(parsed[\"username\"]).to eq(user.username)\n        expect(parsed[\"profile_hidden\"]).to be_blank\n        expect(parsed[\"trust_level\"]).to be_present\n      end\n\n      it \"should redirect to login page for anonymous user when profiles are hidden\" do\n        SiteSetting.hide_user_profiles_from_public = true\n        get \"/u/#{user.username}/card.json\"\n        expect(response).to redirect_to '/login'\n      end\n    end\n\n    context \"logged in\" do\n      before do\n        sign_in(user1)\n      end\n\n      it 'works correctly' do\n        get \"/u/#{user1.username}/card.json\"\n        expect(response.status).to eq(200)\n\n        json = response.parsed_body\n\n        expect(json[\"user\"][\"associated_accounts\"]).to eq(nil) # Not serialized in card\n        expect(json[\"user\"][\"username\"]).to eq(user1.username)\n      end\n\n      it \"returns not found when the username doesn't exist\" do\n        get \"/u/madeuppity/card.json\"\n        expect(response).not_to be_successful\n      end\n\n      it \"raises an error on invalid access\" do\n        Guardian.any_instance.expects(:can_see?).with(user1).returns(false)\n        get \"/u/#{user1.username}/card.json\"\n        expect(response).to be_forbidden\n      end\n    end\n  end\n\n  describe \"#cards\" do\n    fab!(:user) { Discourse.system_user }\n    fab!(:user2) { Fabricate(:user) }\n\n    it \"returns success\" do\n      get \"/user-cards.json?user_ids=#{user.id},#{user2.id}\"\n      expect(response.status).to eq(200)\n      parsed = response.parsed_body[\"users\"]\n\n      expect(parsed.map { |u| u[\"username\"] }).to contain_exactly(user.username, user2.username)\n    end\n\n    it \"should redirect to login page for anonymous user when profiles are hidden\" do\n      SiteSetting.hide_user_profiles_from_public = true\n      get \"/user-cards.json?user_ids=#{user.id},#{user2.id}\"\n      expect(response).to redirect_to '/login'\n    end\n\n    context '`hide_profile_and_presence` user option is checked' do\n      before do\n        user2.user_option.update_columns(hide_profile_and_presence: true)\n      end\n\n      it \"does not include hidden profiles\" do\n        get \"/user-cards.json?user_ids=#{user.id},#{user2.id}\"\n        expect(response.status).to eq(200)\n        parsed = response.parsed_body[\"users\"]\n\n        expect(parsed.map { |u| u[\"username\"] }).to contain_exactly(user.username)\n      end\n\n      it \"does include hidden profiles when `allow_users_to_hide_profile` is false\" do\n        SiteSetting.allow_users_to_hide_profile = false\n\n        get \"/user-cards.json?user_ids=#{user.id},#{user2.id}\"\n        expect(response.status).to eq(200)\n        parsed = response.parsed_body[\"users\"]\n\n        expect(parsed.map { |u| u[\"username\"] }).to contain_exactly(user.username, user2.username)\n      end\n    end\n  end\n\n  describe '#badges' do\n    it \"renders fine by default\" do\n      get \"/u/#{user1.username}/badges\"\n      expect(response.status).to eq(200)\n    end\n\n    it \"fails if badges are disabled\" do\n      SiteSetting.enable_badges = false\n      get \"/u/#{user1.username}/badges\"\n      expect(response.status).to eq(404)\n    end\n  end\n\n  describe \"#account_created\" do\n    it \"returns a message when no session is present\" do\n      get \"/u/account-created\"\n\n      expect(response.status).to eq(200)\n\n      body = response.body\n\n      expect(body).to match(I18n.t('activation.missing_session'))\n    end\n\n    it \"redirects when the user is logged in\" do\n      sign_in(user1)\n\n      get \"/u/account-created\"\n\n      expect(response).to redirect_to(\"/\")\n    end\n\n    context 'when cookies contains a destination URL' do\n      it 'should redirect to the URL' do\n        sign_in(user1)\n\n        destination_url = 'http://thisisasite.com/somepath'\n        cookies[:destination_url] = destination_url\n\n        get \"/u/account-created\"\n\n        expect(response).to redirect_to(destination_url)\n      end\n    end\n\n    context \"when the user account is created\" do\n      include ApplicationHelper\n\n      it \"returns the message when set in the session\" do\n        user1 = create_user\n        get \"/u/account-created\"\n\n        expect(response.status).to eq(200)\n\n        expect(response.body).to have_tag(\"div#data-preloaded\") do |element|\n          json = JSON.parse(element.current_scope.attribute('data-preloaded').value)\n          expect(json['accountCreated']).to include(\n            \"{\\\"message\\\":\\\"#{I18n.t(\"login.activate_email\", email: user1.email).gsub!(\"</\", \"<\\\\/\")}\\\",\\\"show_controls\\\":true,\\\"username\\\":\\\"#{user1.username}\\\",\\\"email\\\":\\\"#{user1.email}\\\"}\"\n          )\n        end\n      end\n    end\n  end\n\n  describe '#search_users' do\n    fab!(:topic) { Fabricate :topic }\n    let(:user)  { Fabricate :user, username: \"joecabot\", name: \"Lawrence Tierney\" }\n    let(:post1) { Fabricate(:post, user: user, topic: topic) }\n    let(:staged_user) { Fabricate(:user, staged: true) }\n\n    before do\n      SearchIndexer.enable\n      post1\n    end\n\n    it \"searches when provided the term only\" do\n      get \"/u/search/users.json\", params: { term: user.name.split(\" \").last }\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"users\"].map { |u| u[\"username\"] }).to include(user.username)\n    end\n\n    it \"searches when provided the topic only\" do\n      get \"/u/search/users.json\", params: { topic_id: topic.id }\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"users\"].map { |u| u[\"username\"] }).to include(user.username)\n    end\n\n    it \"searches when provided the term and topic\" do\n      get \"/u/search/users.json\", params: {\n        term: user.name.split(\" \").last, topic_id: topic.id\n      }\n\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"users\"].map { |u| u[\"username\"] }).to include(user.username)\n    end\n\n    it \"searches only for users who have access to private topic\" do\n      searching_user = Fabricate(:user)\n      privileged_user = Fabricate(:user, trust_level: 4, username: \"joecabit\", name: \"Lawrence Tierney\")\n      privileged_group = Fabricate(:group)\n      privileged_group.add(searching_user)\n      privileged_group.add(privileged_user)\n      privileged_group.save\n\n      category = Fabricate(:category)\n      category.set_permissions(privileged_group => :readonly)\n      category.save\n\n      private_topic = Fabricate(:topic, category: category)\n\n      sign_in(searching_user)\n      get \"/u/search/users.json\", params: {\n        term: user.name.split(\" \").last, topic_id: private_topic.id, topic_allowed_users: \"true\"\n      }\n\n      expect(response.status).to eq(200)\n      json = response.parsed_body\n      expect(json[\"users\"].map { |u| u[\"username\"] }).to_not include(user.username)\n      expect(json[\"users\"].map { |u| u[\"username\"] }).to include(privileged_user.username)\n    end\n\n    it \"interprets blank category id correctly\" do\n      pm_topic = Fabricate(:private_message_post).topic\n      sign_in(pm_topic.user)\n      get \"/u/search/users.json\", params: {\n        term: \"\", topic_id: pm_topic.id, category_id: \"\"\n      }\n      expect(response.status).to eq(200)\n    end\n\n    context 'limit' do\n      it \"returns an error if value is invalid\" do\n        get \"/u/search/users.json\", params: { limit: '-1' }\n        expect(response.status).to eq(400)\n      end\n    end\n\n    context \"when `enable_names` is true\" do\n      before do\n        SiteSetting.enable_names = true\n      end\n\n      it \"returns names\" do\n        get \"/u/search/users.json\", params: { term: user.name }\n        json = response.parsed_body\n        expect(json[\"users\"].map { |u| u[\"name\"] }).to include(user.name)\n      end\n    end\n\n    context \"when `enable_names` is false\" do\n      before do\n        SiteSetting.enable_names = false\n      end\n\n      it \"returns names\" do\n        get \"/u/search/users.json\", params: { term: user.name }\n        json = response.parsed_body\n        expect(json[\"users\"].map { |u| u[\"name\"] }).not_to include(user.name)\n      end\n    end\n\n    context 'groups' do\n      fab!(:mentionable_group) do\n        Fabricate(:group,\n          mentionable_level: Group::ALIAS_LEVELS[:everyone],\n          messageable_level: Group::ALIAS_LEVELS[:nobody],\n          visibility_level: Group.visibility_levels[:public],\n          name: 'aaa1'\n        )\n      end\n\n      fab!(:mentionable_group_2) do\n        Fabricate(:group,\n          mentionable_level: Group::ALIAS_LEVELS[:everyone],\n          messageable_level: Group::ALIAS_LEVELS[:nobody],\n          visibility_level: Group.visibility_levels[:logged_on_users],\n          name: 'aaa2'\n        )\n      end\n\n      fab!(:messageable_group) do\n        Fabricate(:group,\n          mentionable_level: Group::ALIAS_LEVELS[:nobody],\n          messageable_level: Group::ALIAS_LEVELS[:everyone],\n          visibility_level: Group.visibility_levels[:logged_on_users],\n          name: 'aaa3'\n        )\n      end\n\n      fab!(:private_group) do\n        Fabricate(:group,\n          mentionable_level: Group::ALIAS_LEVELS[:members_mods_and_admins],\n          messageable_level: Group::ALIAS_LEVELS[:members_mods_and_admins],\n          visibility_level: Group.visibility_levels[:members],\n          name: 'aaa4'\n        )\n      end\n\n      describe 'when signed in' do\n        before do\n          sign_in(user)\n        end\n\n        it \"does not search for groups if there is no term\" do\n          get \"/u/search/users.json\", params: { include_groups: \"true\" }\n\n          expect(response.status).to eq(200)\n\n          groups = response.parsed_body[\"groups\"]\n          expect(groups).to eq(nil)\n        end\n\n        it \"only returns visible groups\" do\n          get \"/u/search/users.json\", params: { include_groups: \"true\", term: 'a' }\n\n          expect(response.status).to eq(200)\n\n          groups = response.parsed_body[\"groups\"]\n\n          expect(groups.map { |group| group['name'] })\n            .to_not include(private_group.name)\n        end\n\n        it 'allows plugins to register custom groups filter' do\n          get \"/u/search/users.json\", params: { include_groups: \"true\", term: \"a\" }\n\n          expect(response.status).to eq(200)\n          groups = response.parsed_body[\"groups\"]\n          expect(groups.count).to eq(6)\n\n          plugin = Plugin::Instance.new\n          plugin.register_groups_callback_for_users_search_controller_action(:admins_filter) do |original_groups, user|\n            original_groups.where(name: \"admins\")\n          end\n          get \"/u/search/users.json\", params: { include_groups: \"true\", admins_filter: \"true\", term: \"a\" }\n          expect(response.status).to eq(200)\n          groups = response.parsed_body[\"groups\"]\n          expect(groups).to eq([{ \"name\" => \"admins\", \"full_name\" => nil }])\n\n          DiscoursePluginRegistry.reset!\n        end\n\n        it \"doesn't search for groups\" do\n          get \"/u/search/users.json\", params: {\n            include_mentionable_groups: 'false',\n            include_messageable_groups: 'false',\n            term: 'a'\n          }\n\n          expect(response.status).to eq(200)\n          expect(response.parsed_body).not_to have_key(:groups)\n        end\n\n        it \"searches for messageable groups\" do\n          get \"/u/search/users.json\", params: {\n            include_mentionable_groups: 'false',\n            include_messageable_groups: 'true',\n            term: 'a'\n          }\n\n          expect(response.status).to eq(200)\n\n          expect(response.parsed_body[\"groups\"].map { |group| group['name'] })\n            .to contain_exactly(messageable_group.name, Group.find(Group::AUTO_GROUPS[:moderators]).name)\n        end\n\n        it 'searches for mentionable groups' do\n          get \"/u/search/users.json\", params: {\n            include_messageable_groups: 'false',\n            include_mentionable_groups: 'true',\n            term: 'a'\n          }\n\n          expect(response.status).to eq(200)\n\n          groups = response.parsed_body[\"groups\"]\n\n          expect(groups.map { |group| group['name'] })\n            .to contain_exactly(mentionable_group.name, mentionable_group_2.name)\n        end\n      end\n\n      describe 'when not signed in' do\n        it 'should not include mentionable/messageable groups' do\n          get \"/u/search/users.json\", params: {\n            include_mentionable_groups: 'false',\n            include_messageable_groups: 'false',\n            term: 'a'\n          }\n\n          expect(response.status).to eq(200)\n          expect(response.parsed_body).not_to have_key(:groups)\n\n          get \"/u/search/users.json\", params: {\n            include_mentionable_groups: 'false',\n            include_messageable_groups: 'true',\n            term: 'a'\n          }\n\n          expect(response.status).to eq(200)\n          expect(response.parsed_body).not_to have_key(:groups)\n\n          get \"/u/search/users.json\", params: {\n            include_messageable_groups: 'false',\n            include_mentionable_groups: 'true',\n            term: 'a'\n          }\n\n          expect(response.status).to eq(200)\n          expect(response.parsed_body).not_to have_key(:groups)\n        end\n      end\n\n      describe 'when searching by group name' do\n        fab!(:exclusive_group) { Fabricate(:group) }\n\n        it 'return results if the user is a group member' do\n          exclusive_group.add(user)\n\n          get \"/u/search/users.json\", params: {\n            group: exclusive_group.name,\n            term: user.username\n          }\n\n          expect(users_found).to contain_exactly(user.username)\n        end\n\n        it 'does not return results if the user is not a group member' do\n          get \"/u/search/users.json\", params: {\n            group: exclusive_group.name,\n            term: user.username\n          }\n\n          expect(users_found).to be_empty\n        end\n\n        it 'returns results if the user is member of one of the groups' do\n          exclusive_group.add(user)\n\n          get \"/u/search/users.json\", params: {\n            groups: [exclusive_group.name],\n            term: user.username\n          }\n\n          expect(users_found).to contain_exactly(user.username)\n        end\n\n        it 'does not return results if the user is not a member of the groups' do\n          get \"/u/search/users.json\", params: {\n            groups: [exclusive_group.name],\n            term: user.username\n          }\n\n          expect(users_found).to be_empty\n        end\n\n        def users_found\n          response.parsed_body['users'].map { |u| u['username'] }\n        end\n      end\n    end\n\n    context '`include_staged_users`' do\n      it \"includes staged users when the param is true\" do\n        get \"/u/search/users.json\", params: { term: staged_user.name, include_staged_users: true }\n        json = response.parsed_body\n        expect(json[\"users\"].map { |u| u[\"name\"] }).to include(staged_user.name)\n      end\n\n      it \"doesn't include staged users when the param is not passed\" do\n        get \"/u/search/users.json\", params: { term: staged_user.name }\n        json = response.parsed_body\n        expect(json[\"users\"].map { |u| u[\"name\"] }).not_to include(staged_user.name)\n      end\n\n      it \"doesn't include staged users when the param explicitly set to false\" do\n        get \"/u/search/users.json\", params: { term: staged_user.name, include_staged_users: false }\n        json = response.parsed_body\n        expect(json[\"users\"].map { |u| u[\"name\"] }).not_to include(staged_user.name)\n      end\n    end\n\n    context '`last_seen_users`' do\n      it \"returns results when the param is true\" do\n        get \"/u/search/users.json\", params: { last_seen_users: true }\n\n        json = response.parsed_body\n        expect(json[\"users\"]).not_to be_empty\n      end\n\n      it \"respects limit parameter at the same time\" do\n        limit = 3\n        get \"/u/search/users.json\", params: { last_seen_users: true, limit: limit }\n\n        json = response.parsed_body\n        expect(json[\"users\"]).not_to be_empty\n        expect(json[\"users\"].size).to eq(limit)\n      end\n    end\n  end\n\n  describe '#email_login' do\n    before do\n      SiteSetting.enable_local_logins_via_email = true\n    end\n\n    it \"enqueues the right email\" do\n      post \"/u/email-login.json\", params: { login: user1.email }\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body['user_found']).to eq(true)\n\n      job_args = Jobs::CriticalUserEmail.jobs.last[\"args\"].first\n      expect(job_args[\"user_id\"]).to eq(user1.id)\n      expect(job_args[\"type\"]).to eq(\"email_login\")\n      expect(EmailToken.hash_token(job_args[\"email_token\"])).to eq(user1.email_tokens.last.token_hash)\n    end\n\n    describe 'when enable_local_logins_via_email is disabled' do\n      before do\n        SiteSetting.enable_local_logins_via_email = false\n      end\n\n      it 'should return the right response' do\n        post \"/u/email-login.json\", params: { login: user1.email }\n        expect(response.status).to eq(404)\n      end\n    end\n\n    describe 'when username or email is not valid' do\n      it 'should not enqueue the email to login' do\n        post \"/u/email-login.json\", params: { login: '@random' }\n\n        expect(response.status).to eq(200)\n        json = response.parsed_body\n        expect(json['user_found']).to eq(false)\n        expect(json['hide_taken']).to eq(false)\n        expect(Jobs::CriticalUserEmail.jobs).to eq([])\n      end\n    end\n\n    describe 'when hide_email_address_taken is true' do\n      it 'should return the right response' do\n        SiteSetting.hide_email_address_taken = true\n        post \"/u/email-login.json\", params: { login: user1.email }\n\n        expect(response.status).to eq(200)\n        json = response.parsed_body\n        expect(json.has_key?('user_found')).to eq(false)\n        expect(json['hide_taken']).to eq(true)\n      end\n    end\n\n    describe \"when user is already logged in\" do\n      it 'should redirect to the root path' do\n        sign_in(user1)\n        post \"/u/email-login.json\", params: { login: user1.email }\n\n        expect(response).to redirect_to(\"/\")\n      end\n    end\n  end\n\n  describe '#create_second_factor_totp' do\n    context 'when not logged in' do\n      it 'should return the right response' do\n        post \"/users/second_factors.json\", params: {\n          password: 'wrongpassword'\n        }\n\n        expect(response.status).to eq(403)\n      end\n    end\n\n    context 'when logged in' do\n      before do\n        sign_in(user1)\n      end\n\n      describe 'create 2fa request' do\n        it 'fails on incorrect password' do\n          ApplicationController.any_instance.expects(:secure_session).returns(\"confirmed-password-#{user1.id}\" => \"false\")\n          post \"/users/create_second_factor_totp.json\"\n\n          expect(response.status).to eq(403)\n        end\n\n        describe 'when local logins are disabled' do\n          it 'should return the right response' do\n            SiteSetting.enable_local_logins = false\n\n            post \"/users/create_second_factor_totp.json\"\n\n            expect(response.status).to eq(404)\n          end\n        end\n\n        describe 'when SSO is enabled' do\n          it 'should return the right response' do\n            SiteSetting.discourse_connect_url = 'http://someurl.com'\n            SiteSetting.enable_discourse_connect = true\n\n            post \"/users/create_second_factor_totp.json\"\n\n            expect(response.status).to eq(404)\n          end\n        end\n\n        it 'succeeds on correct password' do\n          ApplicationController.any_instance.stubs(:secure_session).returns(\"confirmed-password-#{user1.id}\" => \"true\")\n          post \"/users/create_second_factor_totp.json\"\n\n          expect(response.status).to eq(200)\n\n          response_body = response.parsed_body\n\n          expect(response_body['key']).to be_present\n          expect(response_body['qr']).to be_present\n        end\n      end\n    end\n  end\n\n  describe \"#enable_second_factor_totp\" do\n    before do\n      sign_in(user1)\n    end\n\n    def create_totp\n      stub_secure_session_confirmed\n      post \"/users/create_second_factor_totp.json\"\n    end\n\n    it \"creates a totp for the user successfully\" do\n      create_totp\n      staged_totp_key = read_secure_session[\"staged-totp-#{user1.id}\"]\n      token = ROTP::TOTP.new(staged_totp_key).now\n\n      post \"/users/enable_second_factor_totp.json\", params: { name: \"test\", second_factor_token: token }\n\n      expect(response.status).to eq(200)\n      expect(user1.user_second_factors.count).to eq(1)\n    end\n\n    it \"rate limits by IP address\" do\n      RateLimiter.enable\n      RateLimiter.clear_all!\n\n      create_totp\n      staged_totp_key = read_secure_session[\"staged-totp-#{user1.id}\"]\n      token = ROTP::TOTP.new(staged_totp_key).now\n\n      7.times do |x|\n        post \"/users/enable_second_factor_totp.json\", params: { name: \"test\", second_factor_token: token  }\n      end\n\n      expect(response.status).to eq(429)\n    end\n\n    it \"rate limits by username\" do\n      RateLimiter.enable\n      RateLimiter.clear_all!\n\n      create_totp\n      staged_totp_key = read_secure_session[\"staged-totp-#{user1.id}\"]\n      token = ROTP::TOTP.new(staged_totp_key).now\n\n      7.times do |x|\n        post \"/users/enable_second_factor_totp.json\", params: { name: \"test\", second_factor_token: token  }, env: { \"REMOTE_ADDR\": \"1.2.3.#{x}\"  }\n      end\n\n      expect(response.status).to eq(429)\n    end\n\n    context \"when an incorrect token is provided\" do\n      before do\n        create_totp\n        post \"/users/enable_second_factor_totp.json\", params: { name: \"test\", second_factor_token: \"123456\" }\n      end\n      it \"shows a helpful error message to the user\" do\n        expect(response.parsed_body['error']).to eq(I18n.t(\"login.invalid_second_factor_code\"))\n      end\n    end\n\n    context \"when a name is not provided\" do\n      before do\n        create_totp\n        post \"/users/enable_second_factor_totp.json\", params: { second_factor_token: \"123456\" }\n      end\n      it \"shows a helpful error message to the user\" do\n        expect(response.parsed_body['error']).to eq(I18n.t(\"login.missing_second_factor_name\"))\n      end\n    end\n\n    context \"when a token is not provided\" do\n      before do\n        create_totp\n        post \"/users/enable_second_factor_totp.json\", params: { name: \"test\" }\n      end\n      it \"shows a helpful error message to the user\" do\n        expect(response.parsed_body['error']).to eq(I18n.t(\"login.missing_second_factor_code\"))\n      end\n    end\n  end\n\n  describe '#update_second_factor' do\n    fab!(:user_second_factor) { Fabricate(:user_second_factor_totp, user: user1) }\n\n    context 'when not logged in' do\n      it 'should return the right response' do\n        put \"/users/second_factor.json\"\n\n        expect(response.status).to eq(403)\n      end\n    end\n\n    context 'when logged in' do\n      before do\n        sign_in(user1)\n      end\n\n      context 'when user has totp setup' do\n        context 'when token is missing' do\n          it 'returns the right response' do\n            put \"/users/second_factor.json\", params: {\n              disable: 'true',\n              second_factor_target: UserSecondFactor.methods[:totp],\n              id: user_second_factor.id\n            }\n\n            expect(response.status).to eq(403)\n          end\n        end\n\n        context 'when token is valid' do\n          before do\n            stub_secure_session_confirmed\n          end\n          it 'should allow second factor for the user to be renamed' do\n            put \"/users/second_factor.json\", params: {\n                  name: 'renamed',\n                  second_factor_target: UserSecondFactor.methods[:totp],\n                  id: user_second_factor.id\n                }\n\n            expect(response.status).to eq(200)\n            expect(user1.reload.user_second_factors.totps.first.name).to eq(\"renamed\")\n          end\n\n          it 'should allow second factor for the user to be disabled' do\n            put \"/users/second_factor.json\", params: {\n                  disable: 'true',\n                  second_factor_target: UserSecondFactor.methods[:totp],\n                  id: user_second_factor.id\n            }\n\n            expect(response.status).to eq(200)\n            expect(user1.reload.user_second_factors.totps.first).to eq(nil)\n          end\n        end\n      end\n\n      context \"when user is updating backup codes\" do\n        context 'when token is missing' do\n          it 'returns the right response' do\n            put \"/users/second_factor.json\", params: {\n              second_factor_target: UserSecondFactor.methods[:backup_codes]\n            }\n\n            expect(response.status).to eq(403)\n          end\n        end\n\n        context 'when token is valid' do\n          before do\n            ApplicationController.any_instance.stubs(:secure_session).returns(\"confirmed-password-#{user1.id}\" => \"true\")\n          end\n          it 'should allow second factor backup for the user to be disabled' do\n            put \"/users/second_factor.json\", params: {\n                  second_factor_target: UserSecondFactor.methods[:backup_codes],\n                  disable: 'true'\n            }\n\n            expect(response.status).to eq(200)\n            expect(user1.reload.user_second_factors.backup_codes).to be_empty\n          end\n        end\n      end\n    end\n  end\n\n  describe '#create_second_factor_backup' do\n    fab!(:user_second_factor) { Fabricate(:user_second_factor_totp, user: user1) }\n\n    context 'when not logged in' do\n      it 'should return the right response' do\n        put \"/users/second_factors_backup.json\", params: {\n          second_factor_token: 'wrongtoken',\n          second_factor_method: UserSecondFactor.methods[:totp]\n        }\n\n        expect(response.status).to eq(403)\n      end\n    end\n\n    context 'when logged in' do\n      before do\n        sign_in(user1)\n      end\n\n      describe 'create 2fa request' do\n        it 'fails on incorrect password' do\n          ApplicationController.any_instance.expects(:secure_session).returns(\"confirmed-password-#{user1.id}\" => \"false\")\n          put \"/users/second_factors_backup.json\"\n\n          expect(response.status).to eq(403)\n        end\n\n        describe 'when local logins are disabled' do\n          it 'should return the right response' do\n            SiteSetting.enable_local_logins = false\n\n            put \"/users/second_factors_backup.json\"\n\n            expect(response.status).to eq(404)\n          end\n        end\n\n        describe 'when SSO is enabled' do\n          it 'should return the right response' do\n            SiteSetting.discourse_connect_url = 'http://someurl.com'\n            SiteSetting.enable_discourse_connect = true\n\n            put \"/users/second_factors_backup.json\"\n\n            expect(response.status).to eq(404)\n          end\n        end\n\n        it 'succeeds on correct password' do\n          ApplicationController.any_instance.expects(:secure_session).returns(\"confirmed-password-#{user1.id}\" => \"true\")\n\n          put \"/users/second_factors_backup.json\"\n\n          expect(response.status).to eq(200)\n\n          response_body = response.parsed_body\n\n          # we use SecureRandom.hex(16) for backup codes, ensure this continues to be the case\n          expect(response_body['backup_codes'].map(&:length)).to eq([32] * 10)\n        end\n      end\n    end\n  end\n\n  describe \"#create_second_factor_security_key\" do\n    it \"stores the challenge in the session and returns challenge data, user id, and supported algorithms\" do\n      create_second_factor_security_key\n      secure_session = read_secure_session\n      response_parsed = response.parsed_body\n      expect(response_parsed[\"challenge\"]).to eq(\n        Webauthn.challenge(user1, secure_session)\n      )\n      expect(response_parsed[\"rp_id\"]).to eq(\n        Webauthn.rp_id(user1, secure_session)\n      )\n      expect(response_parsed[\"rp_name\"]).to eq(\n        Webauthn.rp_name(user1, secure_session)\n      )\n      expect(response_parsed[\"user_secure_id\"]).to eq(\n        user1.reload.create_or_fetch_secure_identifier\n      )\n      expect(response_parsed[\"supported_algorithms\"]).to eq(\n        ::Webauthn::SUPPORTED_ALGORITHMS\n      )\n    end\n\n    context \"if the user has security key credentials already\" do\n      fab!(:user_security_key) { Fabricate(:user_security_key_with_random_credential, user: user1) }\n\n      it \"returns those existing active credentials\" do\n        create_second_factor_security_key\n        response_parsed = response.parsed_body\n        expect(response_parsed[\"existing_active_credential_ids\"]).to eq(\n          [user_security_key.credential_id]\n        )\n      end\n    end\n  end\n\n  describe \"#register_second_factor_security_key\" do\n    context \"when creation parameters are valid\" do\n      it \"creates a security key for the user\" do\n        simulate_localhost_webauthn_challenge\n        create_second_factor_security_key\n        response_parsed = response.parsed_body\n\n        post \"/u/register_second_factor_security_key.json\", params: valid_security_key_create_post_data\n\n        expect(user1.security_keys.count).to eq(1)\n        expect(user1.security_keys.last.credential_id).to eq(valid_security_key_create_post_data[:rawId])\n        expect(user1.security_keys.last.name).to eq(valid_security_key_create_post_data[:name])\n      end\n    end\n\n    context \"when the creation parameters are invalid\" do\n      it \"shows a security key error and does not create a key\" do\n        stub_as_dev_localhost\n        create_second_factor_security_key\n        response_parsed = response.parsed_body\n\n        post \"/u/register_second_factor_security_key.json\", params: {\n          id: \"bad id\",\n          rawId: \"bad rawId\",\n          type: \"public-key\",\n          attestation: \"bad attestation\",\n          clientData: Base64.encode64('{\"bad\": \"json\"}'),\n          name: \"My Bad Key\"\n        }\n\n        expect(user1.security_keys.count).to eq(0)\n        expect(response.parsed_body[\"error\"]).to eq(I18n.t(\"webauthn.validation.invalid_type_error\"))\n      end\n    end\n  end\n\n  describe '#disable_second_factor' do\n    context 'when logged in with secure session' do\n      before do\n        sign_in(user1)\n        stub_secure_session_confirmed\n      end\n      context 'when user has a registered totp and security key' do\n        before do\n          totp_second_factor = Fabricate(:user_second_factor_totp, user: user1)\n          security_key_second_factor = Fabricate(:user_security_key, user: user1, factor_type: UserSecurityKey.factor_types[:second_factor])\n        end\n\n        it 'should disable all totp and security keys' do\n          expect_enqueued_with(job: :critical_user_email, args: { type: :account_second_factor_disabled, user_id: user1.id }) do\n            put \"/u/disable_second_factor.json\"\n\n            expect(response.status).to eq(200)\n\n            expect(user1.reload.user_second_factors).to be_empty\n            expect(user1.security_keys).to be_empty\n          end\n        end\n      end\n    end\n  end\n\n  describe '#revoke_account' do\n    it 'errors for unauthorised users' do\n      post \"/u/#{user1.username}/preferences/revoke-account.json\", params: {\n        provider_name: 'facebook'\n      }\n      expect(response.status).to eq(403)\n\n      sign_in(another_user)\n\n      post \"/u/#{user1.username}/preferences/revoke-account.json\", params: {\n        provider_name: 'facebook'\n      }\n      expect(response.status).to eq(403)\n    end\n\n    context 'while logged in' do\n      before do\n        sign_in(user1)\n      end\n\n      it 'returns an error when there is no matching account' do\n        post \"/u/#{user1.username}/preferences/revoke-account.json\", params: {\n          provider_name: 'facebook'\n        }\n        expect(response.status).to eq(404)\n      end\n\n      context \"with fake provider\" do\n        let(:authenticator) do\n          Class.new(Auth::Authenticator) do\n            attr_accessor :can_revoke\n            def name\n              \"testprovider\"\n            end\n\n            def enabled?\n              true\n            end\n\n            def description_for_user(user)\n              \"an account\"\n            end\n\n            def can_revoke?\n              can_revoke\n            end\n\n            def revoke(user, skip_remote: false)\n              true\n            end\n          end.new\n        end\n\n        before do\n          DiscoursePluginRegistry.register_auth_provider(Auth::AuthProvider.new(authenticator: authenticator))\n        end\n\n        after do\n          DiscoursePluginRegistry.reset!\n        end\n\n        it 'returns an error when revoking is not allowed' do\n          authenticator.can_revoke = false\n\n          post \"/u/#{user1.username}/preferences/revoke-account.json\", params: {\n            provider_name: 'testprovider'\n          }\n          expect(response.status).to eq(404)\n\n          authenticator.can_revoke = true\n          post \"/u/#{user1.username}/preferences/revoke-account.json\", params: {\n            provider_name: 'testprovider'\n          }\n          expect(response.status).to eq(200)\n        end\n\n        it 'works' do\n          authenticator.can_revoke = true\n\n          post \"/u/#{user1.username}/preferences/revoke-account.json\", params: {\n            provider_name: 'testprovider'\n          }\n          expect(response.status).to eq(200)\n        end\n      end\n\n    end\n\n  end\n\n  describe '#revoke_auth_token' do\n\n    context 'while logged in' do\n      before do\n        2.times { sign_in(user1) }\n      end\n\n      it 'logs user out' do\n        ids = user1.user_auth_tokens.order(:created_at).pluck(:id)\n\n        post \"/u/#{user1.username}/preferences/revoke-auth-token.json\",\n          params: { token_id: ids[0] }\n\n        expect(response.status).to eq(200)\n\n        user1.user_auth_tokens.reload\n        expect(user1.user_auth_tokens.count).to eq(1)\n        expect(user1.user_auth_tokens.first.id).to eq(ids[1])\n      end\n\n      it 'checks if token exists' do\n        ids = user1.user_auth_tokens.order(:created_at).pluck(:id)\n\n        post \"/u/#{user1.username}/preferences/revoke-auth-token.json\",\n          params: { token_id: ids[0] }\n\n        expect(response.status).to eq(200)\n\n        post \"/u/#{user1.username}/preferences/revoke-auth-token.json\",\n          params: { token_id: ids[0] }\n\n        expect(response.status).to eq(400)\n      end\n\n      it 'does not let user log out of current session' do\n        token = UserAuthToken.generate!(user_id: user1.id)\n        cookie = create_auth_cookie(\n          token: token.unhashed_auth_token,\n          user_id: user1.id,\n          trust_level: user1.trust_level,\n          issued_at: 5.minutes.ago,\n        )\n\n        post \"/u/#{user1.username}/preferences/revoke-auth-token.json\",\n          params: { token_id: token.id },\n          headers: { \"HTTP_COOKIE\" => \"_t=#{cookie}\" }\n\n        expect(token.reload.id).to be_present\n        expect(response.status).to eq(400)\n      end\n\n      it 'logs user out from everywhere if token_id is not present' do\n        post \"/u/#{user1.username}/preferences/revoke-auth-token.json\"\n\n        expect(response.status).to eq(200)\n        expect(user1.user_auth_tokens.count).to eq(0)\n      end\n\n    end\n\n  end\n\n  describe '#list_second_factors' do\n    let(:user) { user1 }\n\n    before do\n      sign_in(user)\n    end\n\n    context 'when SSO is enabled' do\n      before do\n        SiteSetting.discourse_connect_url = 'https://discourse.test/sso'\n        SiteSetting.enable_discourse_connect = true\n      end\n\n      it 'does not allow access' do\n        post \"/u/second_factors.json\"\n        expect(response.status).to eq(404)\n      end\n    end\n\n    context 'when local logins are not enabled' do\n      before do\n        SiteSetting.enable_local_logins = false\n      end\n\n      it 'does not allow access' do\n        post \"/u/second_factors.json\"\n        expect(response.status).to eq(404)\n      end\n    end\n\n    context 'when the site settings allow second factors' do\n      before do\n        SiteSetting.enable_local_logins = true\n        SiteSetting.enable_discourse_connect = false\n      end\n\n      context 'when the password parameter is not provided' do\n        let(:password) { '' }\n\n        before do\n          post \"/u/second_factors.json\", params: { password: password }\n        end\n\n        it 'returns password required response' do\n          expect(response.status).to eq(200)\n          response_body = response.parsed_body\n          expect(response_body['password_required']).to eq(true)\n        end\n      end\n\n      context 'when the password is provided' do\n        fab!(:user) { Fabricate(:user, password: '8555039dd212cc66ec68') }\n\n        context 'when the password is correct' do\n          let(:password) { '8555039dd212cc66ec68' }\n\n          it 'returns a list of enabled totps and security_key second factors' do\n            totp_second_factor = Fabricate(:user_second_factor_totp, user: user)\n            security_key_second_factor = Fabricate(:user_security_key, user: user, factor_type: UserSecurityKey.factor_types[:second_factor])\n\n            post \"/u/second_factors.json\", params: { password: password }\n\n            expect(response.status).to eq(200)\n            response_body = response.parsed_body\n            expect(response_body['totps'].map { |second_factor| second_factor['id'] }).to include(totp_second_factor.id)\n            expect(response_body['security_keys'].map { |second_factor| second_factor['id'] }).to include(security_key_second_factor.id)\n          end\n        end\n\n        context 'when the password is not correct' do\n          let(:password) { 'wrongpassword' }\n\n          it 'returns the incorrect password response' do\n\n            post \"/u/second_factors.json\", params: { password: password }\n\n            response_body = response.parsed_body\n            expect(response_body['error']).to eq(\n              I18n.t(\"login.incorrect_password\")\n            )\n          end\n        end\n      end\n    end\n  end\n\n  describe '#feature_topic' do\n    fab!(:topic) { Fabricate(:topic) }\n    fab!(:other_topic) { Fabricate(:topic) }\n    fab!(:private_message) { Fabricate(:private_message_topic, user: another_user) }\n    fab!(:category) { Fabricate(:category_with_definition) }\n\n    describe \"site setting enabled\" do\n      before do\n        SiteSetting.allow_featured_topic_on_user_profiles = true\n      end\n\n      it 'requires the user to be logged in' do\n        put \"/u/#{user1.username}/feature-topic.json\", params: { topic_id: topic.id }\n        expect(response.status).to eq(403)\n      end\n\n      it 'returns an error if the user tries to set for another user' do\n        sign_in(user1)\n        topic.update(user_id: another_user.id)\n        put \"/u/#{another_user.username}/feature-topic.json\", params: { topic_id: topic.id }\n        expect(response.status).to eq(403)\n      end\n\n      it 'returns an error if the topic is a PM' do\n        sign_in(another_user)\n        put \"/u/#{another_user.username}/feature-topic.json\", params: { topic_id: private_message.id }\n        expect(response.status).to eq(403)\n      end\n\n      it \"returns an error if the topic is not visible\" do\n        sign_in(user1)\n        topic.update_status('visible', false, user1)\n        put \"/u/#{user1.username}/feature-topic.json\", params: { topic_id: topic.id }\n        expect(response.status).to eq(403)\n      end\n\n      it \"returns an error if the topic's category is read_restricted\" do\n        sign_in(user1)\n        category.set_permissions({})\n        topic.update(category_id: category.id)\n        put \"/u/#{another_user.username}/feature-topic.json\", params: { topic_id: topic.id }\n        expect(response.status).to eq(403)\n      end\n\n      it 'sets featured_topic correctly for user created topic' do\n        sign_in(user1)\n        topic.update(user_id: user1.id)\n        put \"/u/#{user1.username}/feature-topic.json\", params: { topic_id: topic.id }\n        expect(response.status).to eq(200)\n        expect(user1.user_profile.featured_topic).to eq topic\n      end\n\n      it 'sets featured_topic correctly for non-user-created topic' do\n        sign_in(user1)\n        put \"/u/#{user1.username}/feature-topic.json\", params: { topic_id: other_topic.id }\n        expect(response.status).to eq(200)\n        expect(user1.user_profile.featured_topic).to eq other_topic\n      end\n\n      describe \"site setting disabled\" do\n        before do\n          SiteSetting.allow_featured_topic_on_user_profiles = false\n        end\n\n        it \"does not allow setting featured_topic for user_profiles\" do\n          sign_in(user1)\n          topic.update(user_id: user1.id)\n          put \"/u/#{user1.username}/feature-topic.json\", params: { topic_id: topic.id }\n          expect(response.status).to eq(403)\n        end\n      end\n    end\n  end\n\n  describe '#clear_featured_topic' do\n    fab!(:topic) { Fabricate(:topic) }\n\n    it 'requires the user to be logged in' do\n      put \"/u/#{user1.username}/clear-featured-topic.json\"\n      expect(response.status).to eq(403)\n    end\n\n    it 'returns an error if the the current user does not have access' do\n      sign_in(user1)\n      topic.update(user_id: another_user.id)\n      put \"/u/#{another_user.username}/clear-featured-topic.json\"\n      expect(response.status).to eq(403)\n    end\n\n    it 'clears the user_profiles featured_topic correctly' do\n      sign_in(user1)\n      topic.update(user: user1)\n      put \"/u/#{user1.username}/clear-featured-topic.json\"\n      expect(response.status).to eq(200)\n      expect(user1.user_profile.featured_topic).to eq nil\n    end\n  end\n\n  describe \"#bookmarks\" do\n    fab!(:bookmark1) { Fabricate(:bookmark, user: user1) }\n    fab!(:bookmark2) { Fabricate(:bookmark, user: user1) }\n    fab!(:bookmark3) { Fabricate(:bookmark) }\n\n    before do\n      TopicUser.change(user1.id, bookmark1.topic_id, total_msecs_viewed: 1)\n      TopicUser.change(user1.id, bookmark2.topic_id, total_msecs_viewed: 1)\n    end\n\n    it \"returns a list of serialized bookmarks for the user\" do\n      sign_in(user1)\n      get \"/u/#{user1.username}/bookmarks.json\"\n      expect(response.status).to eq(200)\n      expect(response.parsed_body['user_bookmark_list']['bookmarks'].map { |b| b['id'] }).to match_array([bookmark1.id, bookmark2.id])\n    end\n\n    it \"returns an .ics file of bookmark reminders for the user in date order\" do\n      bookmark1.update!(name: nil, reminder_at: 1.day.from_now)\n      bookmark2.update!(name: \"Some bookmark note\", reminder_at: 1.week.from_now)\n\n      sign_in(user1)\n      get \"/u/#{user1.username}/bookmarks.ics\"\n      expect(response.status).to eq(200)\n      expect(response.body).to eq(<<~ICS)\n        BEGIN:VCALENDAR\n        VERSION:2.0\n        PRODID:-//Discourse//#{Discourse.current_hostname}//#{Discourse.full_version}//EN\n        BEGIN:VEVENT\n        UID:bookmark_reminder_##{bookmark1.id}@#{Discourse.current_hostname}\n        DTSTAMP:#{bookmark1.updated_at.strftime(I18n.t(\"datetime_formats.formats.calendar_ics\"))}\n        DTSTART:#{bookmark1.reminder_at_ics}\n        DTEND:#{bookmark1.reminder_at_ics(offset: 1.hour)}\n        SUMMARY:#{bookmark1.topic.title}\n        DESCRIPTION:#{Discourse.base_url}/t/-/#{bookmark1.topic_id}\n        URL:#{Discourse.base_url}/t/-/#{bookmark1.topic_id}\n        END:VEVENT\n        BEGIN:VEVENT\n        UID:bookmark_reminder_##{bookmark2.id}@#{Discourse.current_hostname}\n        DTSTAMP:#{bookmark2.updated_at.strftime(I18n.t(\"datetime_formats.formats.calendar_ics\"))}\n        DTSTART:#{bookmark2.reminder_at_ics}\n        DTEND:#{bookmark2.reminder_at_ics(offset: 1.hour)}\n        SUMMARY:Some bookmark note\n        DESCRIPTION:#{Discourse.base_url}/t/-/#{bookmark2.topic_id}\n        URL:#{Discourse.base_url}/t/-/#{bookmark2.topic_id}\n        END:VEVENT\n        END:VCALENDAR\n      ICS\n    end\n\n    it \"does not show another user's bookmarks\" do\n      sign_in(user1)\n      get \"/u/#{bookmark3.user.username}/bookmarks.json\"\n      expect(response.status).to eq(403)\n    end\n\n    it \"shows a helpful message if no bookmarks are found\" do\n      bookmark1.destroy\n      bookmark2.destroy\n      bookmark3.destroy\n      sign_in(user1)\n      get \"/u/#{user1.username}/bookmarks.json\"\n      expect(response.status).to eq(200)\n      expect(response.parsed_body['bookmarks']).to eq([])\n    end\n\n    it \"shows a helpful message if no bookmarks are found for the search\" do\n      sign_in(user1)\n      get \"/u/#{user1.username}/bookmarks.json\", params: {\n        q: 'badsearch'\n      }\n      expect(response.status).to eq(200)\n      expect(response.parsed_body['bookmarks']).to eq([])\n    end\n  end\n\n  describe \"#private_message_topic_tracking_state\" do\n    fab!(:user_2) { Fabricate(:user) }\n\n    fab!(:private_message) do\n      create_post(\n        user: user1,\n        target_usernames: [user_2.username],\n        archetype: Archetype.private_message\n      ).topic\n    end\n\n    before do\n      sign_in(user_2)\n    end\n\n    it 'does not allow an unauthorized user to access the state of another user' do\n      get \"/u/#{user1.username}/private-message-topic-tracking-state.json\"\n\n      expect(response.status).to eq(403)\n    end\n\n    it 'returns the right response' do\n      get \"/u/#{user_2.username}/private-message-topic-tracking-state.json\"\n\n      expect(response.status).to eq(200)\n\n      topic_state = response.parsed_body.first\n\n      expect(topic_state[\"topic_id\"]).to eq(private_message.id)\n      expect(topic_state[\"highest_post_number\"]).to eq(1)\n      expect(topic_state[\"last_read_post_number\"]).to eq(nil)\n      expect(topic_state[\"notification_level\"]).to eq(NotificationLevels.all[:watching])\n      expect(topic_state[\"group_ids\"]).to eq([])\n    end\n  end\n\n  describe \"#reset_recent_searches\" do\n    it 'does nothing for anon' do\n      delete \"/u/recent-searches.json\"\n      expect(response.status).to eq(403)\n    end\n\n    it 'works for logged in user' do\n      sign_in(user1)\n      delete \"/u/recent-searches.json\"\n\n      expect(response.status).to eq(200)\n      user1.reload\n      expect(user1.user_option.oldest_search_log_date).to be_within(5.seconds).of(1.second.ago)\n    end\n  end\n\n  describe \"#recent_searches\" do\n    it 'does nothing for anon' do\n      get \"/u/recent-searches.json\"\n      expect(response.status).to eq(403)\n    end\n\n    it 'works for logged in user' do\n      sign_in(user1)\n      SiteSetting.log_search_queries = true\n      user1.user_option.update!(oldest_search_log_date: nil)\n\n      get \"/u/recent-searches.json\"\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"recent_searches\"]).to eq([])\n\n      SearchLog.create!(\n        term: \"old one\",\n        user_id: user1.id,\n        search_type: 1,\n        ip_address: '192.168.0.1',\n        created_at: 5.minutes.ago\n      )\n      SearchLog.create!(\n        term: \"also old\",\n        user_id: user1.id,\n        search_type: 1,\n        ip_address: '192.168.0.1',\n        created_at: 15.minutes.ago\n      )\n\n      get \"/u/recent-searches.json\"\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"recent_searches\"]).to eq([\"old one\", \"also old\"])\n\n      user1.user_option.update!(oldest_search_log_date: 20.minutes.ago)\n\n      get \"/u/recent-searches.json\"\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"recent_searches\"]).to eq([\"old one\", \"also old\"])\n\n      user1.user_option.update!(oldest_search_log_date: 10.seconds.ago)\n\n      get \"/u/recent-searches.json\"\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"recent_searches\"]).to eq([])\n\n      SearchLog.create!(\n        term: \"new search\",\n        user_id: user1.id,\n        search_type: 1,\n        ip_address: '192.168.0.1',\n        created_at: 2.seconds.ago\n      )\n\n      get \"/u/recent-searches.json\"\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"recent_searches\"]).to eq([\"new search\"])\n    end\n\n    it 'shows an error message when log_search_queries are off' do\n      sign_in(user1)\n      SiteSetting.log_search_queries = false\n\n      get \"/u/recent-searches.json\"\n\n      expect(response.status).to eq(403)\n      expect(response.parsed_body[\"error\"]).to eq(I18n.t(\"user_activity.no_log_search_queries\"))\n    end\n  end\n\n  def create_second_factor_security_key\n    sign_in(user1)\n    stub_secure_session_confirmed\n    post \"/u/create_second_factor_security_key.json\"\n  end\n\n  def stub_secure_session_confirmed\n    UsersController.any_instance.stubs(:secure_session_confirmed?).returns(true)\n  end\nend\n"], "filenames": ["lib/guardian/user_guardian.rb", "spec/requests/users_controller_spec.rb"], "buggy_code_start_loc": [104, 3674], "buggy_code_end_loc": [105, 3674], "fixing_code_start_loc": [104, 3675], "fixing_code_end_loc": [105, 3685], "type": "CWE-200", "message": "Discourse is an open source discussion platform. Prior to version 2.8.0.beta11 in the `tests-passed` branch, version 2.8.0.beta11 in the `beta` branch, and version 2.7.13 in the `stable` branch, the bios of users who made their profiles private were still visible in the `<meta>` tags on their users' pages. The problem is patched in `tests-passed` version 2.8.0.beta11, `beta` version 2.8.0.beta11, and `stable` version 2.7.13 of Discourse.", "other": {"cve": {"id": "CVE-2022-21678", "sourceIdentifier": "security-advisories@github.com", "published": "2022-01-13T18:15:08.233", "lastModified": "2022-01-21T02:51:20.240", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Discourse is an open source discussion platform. Prior to version 2.8.0.beta11 in the `tests-passed` branch, version 2.8.0.beta11 in the `beta` branch, and version 2.7.13 in the `stable` branch, the bios of users who made their profiles private were still visible in the `<meta>` tags on their users' pages. The problem is patched in `tests-passed` version 2.8.0.beta11, `beta` version 2.8.0.beta11, and `stable` version 2.7.13 of Discourse."}, {"lang": "es", "value": "Discourse es una plataforma de debate de c\u00f3digo abierto. En versiones anteriores a 2.8.0.beta11 en la rama \"tests-passed\", la versi\u00f3n 2.8.0.beta11 en la rama \"beta\", y la versi\u00f3n 2.7.13 en la rama \"stable\", las biograf\u00edas de los usuarios que hac\u00edan sus perfiles privados segu\u00edan siendo visibles en las etiquetas \"(meta)\" de sus p\u00e1ginas de usuario. El problema est\u00e1 parcheado en la versi\u00f3n 2.8.0.beta11 de \"tests-passed\", la versi\u00f3n 2.8.0.beta11 de \"beta\" y la versi\u00f3n 2.7.13 de \"stable\" de Discourse"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.7.13", "matchCriteriaId": "131D6FC3-2C60-4524-9B4E-F8316312A606"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "9E7F8AC4-35D1-45E5-8A3A-B0205000A5D3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta10:*:*:*:*:*:*", "matchCriteriaId": "7A24507D-6D4B-4992-BCFE-232AF3BFCC30"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "B9AE12FE-0396-4843-8D30-D8C44FAE01DA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta3:*:*:*:*:*:*", "matchCriteriaId": "F101AEAB-4FB7-4BE3-931B-595702D616C7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta4:*:*:*:*:*:*", "matchCriteriaId": "F6878B7F-2691-4D3F-8116-CB282FDAAAC7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta5:*:*:*:*:*:*", "matchCriteriaId": "76EABAB9-BEA4-48D4-ADBA-D00746B29C52"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta6:*:*:*:*:*:*", "matchCriteriaId": "82A255A2-4658-41AD-A4DE-A7F8D018028D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta7:*:*:*:*:*:*", "matchCriteriaId": "E5804585-2EA4-4677-8EC1-5F561D5C7D7A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta8:*:*:*:*:*:*", "matchCriteriaId": "082A6871-080A-4AA7-AF4A-D664EA46488A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta9:*:*:*:*:*:*", "matchCriteriaId": "8A280205-A2DC-4E30-937B-5564C779FD5A"}]}]}], "references": [{"url": "https://github.com/discourse/discourse/commit/5e2e178fcfb490c37b9f8bb9f737185441b1d6de", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/discourse/discourse/commit/c0bb775f3f35b1b0d04a5b2a984f57c3e39f9e6c", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/discourse/discourse/security/advisories/GHSA-jwww-46gv-564m", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/discourse/discourse/commit/5e2e178fcfb490c37b9f8bb9f737185441b1d6de"}}