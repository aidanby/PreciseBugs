{"buggy_code": ["/*\n * Ultra Wide Band\n * Neighborhood Management Daemon\n *\n * Copyright (C) 2005-2006 Intel Corporation\n * Inaky Perez-Gonzalez <inaky.perez-gonzalez@intel.com>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License version\n * 2 as published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n * 02110-1301, USA.\n *\n *\n * This daemon takes care of maintaing information that describes the\n * UWB neighborhood that the radios in this machine can see. It also\n * keeps a tab of which devices are visible, makes sure each HC sits\n * on a different channel to avoid interfering, etc.\n *\n * Different drivers (radio controller, device, any API in general)\n * communicate with this daemon through an event queue. Daemon wakes\n * up, takes a list of events and handles them one by one; handling\n * function is extracted from a table based on the event's type and\n * subtype. Events are freed only if the handling function says so.\n *\n *   . Lock protecting the event list has to be an spinlock and locked\n *     with IRQSAVE because it might be called from an interrupt\n *     context (ie: when events arrive and the notification drops\n *     down from the ISR).\n *\n *   . UWB radio controller drivers queue events to the daemon using\n *     uwbd_event_queue(). They just get the event, chew it to make it\n *     look like UWBD likes it and pass it in a buffer allocated with\n *     uwb_event_alloc().\n *\n * EVENTS\n *\n * Events have a type, a subtype, a length, some other stuff and the\n * data blob, which depends on the event. The header is 'struct\n * uwb_event'; for payloads, see 'struct uwbd_evt_*'.\n *\n * EVENT HANDLER TABLES\n *\n * To find a handling function for an event, the type is used to index\n * a subtype-table in the type-table. The subtype-table is indexed\n * with the subtype to get the function that handles the event. Start\n * with the main type-table 'uwbd_evt_type_handler'.\n *\n * DEVICES\n *\n * Devices are created when a bunch of beacons have been received and\n * it is stablished that the device has stable radio presence. CREATED\n * only, not configured. Devices are ONLY configured when an\n * Application-Specific IE Probe is receieved, in which the device\n * declares which Protocol ID it groks. Then the device is CONFIGURED\n * (and the driver->probe() stuff of the device model is invoked).\n *\n * Devices are considered disconnected when a certain number of\n * beacons are not received in an amount of time.\n *\n * Handler functions are called normally uwbd_evt_handle_*().\n */\n#include <linux/kthread.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n\n#include \"uwb-internal.h\"\n\n/*\n * UWBD Event handler function signature\n *\n * Return !0 if the event needs not to be freed (ie the handler\n * takes/took care of it). 0 means the daemon code will free the\n * event.\n *\n * @evt->rc is already referenced and guaranteed to exist. See\n * uwb_evt_handle().\n */\ntypedef int (*uwbd_evt_handler_f)(struct uwb_event *);\n\n/**\n * Properties of a UWBD event\n *\n * @handler:    the function that will handle this event\n * @name:       text name of event\n */\nstruct uwbd_event {\n\tuwbd_evt_handler_f handler;\n\tconst char *name;\n};\n\n/* Table of handlers for and properties of the UWBD Radio Control Events */\nstatic struct uwbd_event uwbd_urc_events[] = {\n\t[UWB_RC_EVT_IE_RCV] = {\n\t\t.handler = uwbd_evt_handle_rc_ie_rcv,\n\t\t.name = \"IE_RECEIVED\"\n\t},\n\t[UWB_RC_EVT_BEACON] = {\n\t\t.handler = uwbd_evt_handle_rc_beacon,\n\t\t.name = \"BEACON_RECEIVED\"\n\t},\n\t[UWB_RC_EVT_BEACON_SIZE] = {\n\t\t.handler = uwbd_evt_handle_rc_beacon_size,\n\t\t.name = \"BEACON_SIZE_CHANGE\"\n\t},\n\t[UWB_RC_EVT_BPOIE_CHANGE] = {\n\t\t.handler = uwbd_evt_handle_rc_bpoie_change,\n\t\t.name = \"BPOIE_CHANGE\"\n\t},\n\t[UWB_RC_EVT_BP_SLOT_CHANGE] = {\n\t\t.handler = uwbd_evt_handle_rc_bp_slot_change,\n\t\t.name = \"BP_SLOT_CHANGE\"\n\t},\n\t[UWB_RC_EVT_DRP_AVAIL] = {\n\t\t.handler = uwbd_evt_handle_rc_drp_avail,\n\t\t.name = \"DRP_AVAILABILITY_CHANGE\"\n\t},\n\t[UWB_RC_EVT_DRP] = {\n\t\t.handler = uwbd_evt_handle_rc_drp,\n\t\t.name = \"DRP\"\n\t},\n\t[UWB_RC_EVT_DEV_ADDR_CONFLICT] = {\n\t\t.handler = uwbd_evt_handle_rc_dev_addr_conflict,\n\t\t.name = \"DEV_ADDR_CONFLICT\",\n\t},\n};\n\n\n\nstruct uwbd_evt_type_handler {\n\tconst char *name;\n\tstruct uwbd_event *uwbd_events;\n\tsize_t size;\n};\n\n/* Table of handlers for each UWBD Event type. */\nstatic struct uwbd_evt_type_handler uwbd_urc_evt_type_handlers[] = {\n\t[UWB_RC_CET_GENERAL] = {\n\t\t.name        = \"URC\",\n\t\t.uwbd_events = uwbd_urc_events,\n\t\t.size        = ARRAY_SIZE(uwbd_urc_events),\n\t},\n};\n\nstatic const struct uwbd_event uwbd_message_handlers[] = {\n\t[UWB_EVT_MSG_RESET] = {\n\t\t.handler = uwbd_msg_handle_reset,\n\t\t.name = \"reset\",\n\t},\n};\n\n/*\n * Handle an URC event passed to the UWB Daemon\n *\n * @evt: the event to handle\n * @returns: 0 if the event can be kfreed, !0 on the contrary\n *           (somebody else took ownership) [coincidentally, returning\n *           a <0 errno code will free it :)].\n *\n * Looks up the two indirection tables (one for the type, one for the\n * subtype) to decide which function handles it and then calls the\n * handler.\n *\n * The event structure passed to the event handler has the radio\n * controller in @evt->rc referenced. The reference will be dropped\n * once the handler returns, so if it needs it for longer (async),\n * it'll need to take another one.\n */\nstatic\nint uwbd_event_handle_urc(struct uwb_event *evt)\n{\n\tint result = -EINVAL;\n\tstruct uwbd_evt_type_handler *type_table;\n\tuwbd_evt_handler_f handler;\n\tu8 type, context;\n\tu16 event;\n\n\ttype = evt->notif.rceb->bEventType;\n\tevent = le16_to_cpu(evt->notif.rceb->wEvent);\n\tcontext = evt->notif.rceb->bEventContext;\n\n\tif (type >= ARRAY_SIZE(uwbd_urc_evt_type_handlers))\n\t\tgoto out;\n\ttype_table = &uwbd_urc_evt_type_handlers[type];\n\tif (type_table->uwbd_events == NULL)\n\t\tgoto out;\n\tif (event >= type_table->size)\n\t\tgoto out;\n\thandler = type_table->uwbd_events[event].handler;\n\tif (handler == NULL)\n\t\tgoto out;\n\n\tresult = (*handler)(evt);\nout:\n\tif (result < 0)\n\t\tdev_err(&evt->rc->uwb_dev.dev,\n\t\t\t\"UWBD: event 0x%02x/%04x/%02x, handling failed: %d\\n\",\n\t\t\ttype, event, context, result);\n\treturn result;\n}\n\nstatic void uwbd_event_handle_message(struct uwb_event *evt)\n{\n\tstruct uwb_rc *rc;\n\tint result;\n\n\trc = evt->rc;\n\n\tif (evt->message < 0 || evt->message >= ARRAY_SIZE(uwbd_message_handlers)) {\n\t\tdev_err(&rc->uwb_dev.dev, \"UWBD: invalid message type %d\\n\", evt->message);\n\t\treturn;\n\t}\n\n\tresult = uwbd_message_handlers[evt->message].handler(evt);\n\tif (result < 0)\n\t\tdev_err(&rc->uwb_dev.dev, \"UWBD: '%s' message failed: %d\\n\",\n\t\t\tuwbd_message_handlers[evt->message].name, result);\n}\n\nstatic void uwbd_event_handle(struct uwb_event *evt)\n{\n\tstruct uwb_rc *rc;\n\tint should_keep;\n\n\trc = evt->rc;\n\n\tif (rc->ready) {\n\t\tswitch (evt->type) {\n\t\tcase UWB_EVT_TYPE_NOTIF:\n\t\t\tshould_keep = uwbd_event_handle_urc(evt);\n\t\t\tif (should_keep <= 0)\n\t\t\t\tkfree(evt->notif.rceb);\n\t\t\tbreak;\n\t\tcase UWB_EVT_TYPE_MSG:\n\t\t\tuwbd_event_handle_message(evt);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&rc->uwb_dev.dev, \"UWBD: invalid event type %d\\n\", evt->type);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t__uwb_rc_put(rc);\t/* for the __uwb_rc_get() in uwb_rc_notif_cb() */\n}\n\n/**\n * UWB Daemon\n *\n * Listens to all UWB notifications and takes care to track the state\n * of the UWB neighbourhood for the kernel. When we do a run, we\n * spinlock, move the list to a private copy and release the\n * lock. Hold it as little as possible. Not a conflict: it is\n * guaranteed we own the events in the private list.\n *\n * FIXME: should change so we don't have a 1HZ timer all the time, but\n *        only if there are devices.\n */\nstatic int uwbd(void *param)\n{\n\tstruct uwb_rc *rc = param;\n\tunsigned long flags;\n\tstruct uwb_event *evt;\n\tint should_stop = 0;\n\n\twhile (1) {\n\t\twait_event_interruptible_timeout(\n\t\t\trc->uwbd.wq,\n\t\t\t!list_empty(&rc->uwbd.event_list)\n\t\t\t  || (should_stop = kthread_should_stop()),\n\t\t\tHZ);\n\t\tif (should_stop)\n\t\t\tbreak;\n\n\t\tspin_lock_irqsave(&rc->uwbd.event_list_lock, flags);\n\t\tif (!list_empty(&rc->uwbd.event_list)) {\n\t\t\tevt = list_first_entry(&rc->uwbd.event_list, struct uwb_event, list_node);\n\t\t\tlist_del(&evt->list_node);\n\t\t} else\n\t\t\tevt = NULL;\n\t\tspin_unlock_irqrestore(&rc->uwbd.event_list_lock, flags);\n\n\t\tif (evt) {\n\t\t\tuwbd_event_handle(evt);\n\t\t\tkfree(evt);\n\t\t}\n\n\t\tuwb_beca_purge(rc);\t/* Purge devices that left */\n\t}\n\treturn 0;\n}\n\n\n/** Start the UWB daemon */\nvoid uwbd_start(struct uwb_rc *rc)\n{\n\trc->uwbd.task = kthread_run(uwbd, rc, \"uwbd\");\n\tif (rc->uwbd.task == NULL)\n\t\tprintk(KERN_ERR \"UWB: Cannot start management daemon; \"\n\t\t       \"UWB won't work\\n\");\n\telse\n\t\trc->uwbd.pid = rc->uwbd.task->pid;\n}\n\n/* Stop the UWB daemon and free any unprocessed events */\nvoid uwbd_stop(struct uwb_rc *rc)\n{\n\tkthread_stop(rc->uwbd.task);\n\tuwbd_flush(rc);\n}\n\n/*\n * Queue an event for the management daemon\n *\n * When some lower layer receives an event, it uses this function to\n * push it forward to the UWB daemon.\n *\n * Once you pass the event, you don't own it any more, but the daemon\n * does. It will uwb_event_free() it when done, so make sure you\n * uwb_event_alloc()ed it or bad things will happen.\n *\n * If the daemon is not running, we just free the event.\n */\nvoid uwbd_event_queue(struct uwb_event *evt)\n{\n\tstruct uwb_rc *rc = evt->rc;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rc->uwbd.event_list_lock, flags);\n\tif (rc->uwbd.pid != 0) {\n\t\tlist_add(&evt->list_node, &rc->uwbd.event_list);\n\t\twake_up_all(&rc->uwbd.wq);\n\t} else {\n\t\t__uwb_rc_put(evt->rc);\n\t\tif (evt->type == UWB_EVT_TYPE_NOTIF)\n\t\t\tkfree(evt->notif.rceb);\n\t\tkfree(evt);\n\t}\n\tspin_unlock_irqrestore(&rc->uwbd.event_list_lock, flags);\n\treturn;\n}\n\nvoid uwbd_flush(struct uwb_rc *rc)\n{\n\tstruct uwb_event *evt, *nxt;\n\n\tspin_lock_irq(&rc->uwbd.event_list_lock);\n\tlist_for_each_entry_safe(evt, nxt, &rc->uwbd.event_list, list_node) {\n\t\tif (evt->rc == rc) {\n\t\t\t__uwb_rc_put(rc);\n\t\t\tlist_del(&evt->list_node);\n\t\t\tif (evt->type == UWB_EVT_TYPE_NOTIF)\n\t\t\t\tkfree(evt->notif.rceb);\n\t\t\tkfree(evt);\n\t\t}\n\t}\n\tspin_unlock_irq(&rc->uwbd.event_list_lock);\n}\n"], "fixing_code": ["/*\n * Ultra Wide Band\n * Neighborhood Management Daemon\n *\n * Copyright (C) 2005-2006 Intel Corporation\n * Inaky Perez-Gonzalez <inaky.perez-gonzalez@intel.com>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License version\n * 2 as published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n * 02110-1301, USA.\n *\n *\n * This daemon takes care of maintaing information that describes the\n * UWB neighborhood that the radios in this machine can see. It also\n * keeps a tab of which devices are visible, makes sure each HC sits\n * on a different channel to avoid interfering, etc.\n *\n * Different drivers (radio controller, device, any API in general)\n * communicate with this daemon through an event queue. Daemon wakes\n * up, takes a list of events and handles them one by one; handling\n * function is extracted from a table based on the event's type and\n * subtype. Events are freed only if the handling function says so.\n *\n *   . Lock protecting the event list has to be an spinlock and locked\n *     with IRQSAVE because it might be called from an interrupt\n *     context (ie: when events arrive and the notification drops\n *     down from the ISR).\n *\n *   . UWB radio controller drivers queue events to the daemon using\n *     uwbd_event_queue(). They just get the event, chew it to make it\n *     look like UWBD likes it and pass it in a buffer allocated with\n *     uwb_event_alloc().\n *\n * EVENTS\n *\n * Events have a type, a subtype, a length, some other stuff and the\n * data blob, which depends on the event. The header is 'struct\n * uwb_event'; for payloads, see 'struct uwbd_evt_*'.\n *\n * EVENT HANDLER TABLES\n *\n * To find a handling function for an event, the type is used to index\n * a subtype-table in the type-table. The subtype-table is indexed\n * with the subtype to get the function that handles the event. Start\n * with the main type-table 'uwbd_evt_type_handler'.\n *\n * DEVICES\n *\n * Devices are created when a bunch of beacons have been received and\n * it is stablished that the device has stable radio presence. CREATED\n * only, not configured. Devices are ONLY configured when an\n * Application-Specific IE Probe is receieved, in which the device\n * declares which Protocol ID it groks. Then the device is CONFIGURED\n * (and the driver->probe() stuff of the device model is invoked).\n *\n * Devices are considered disconnected when a certain number of\n * beacons are not received in an amount of time.\n *\n * Handler functions are called normally uwbd_evt_handle_*().\n */\n#include <linux/kthread.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n\n#include \"uwb-internal.h\"\n\n/*\n * UWBD Event handler function signature\n *\n * Return !0 if the event needs not to be freed (ie the handler\n * takes/took care of it). 0 means the daemon code will free the\n * event.\n *\n * @evt->rc is already referenced and guaranteed to exist. See\n * uwb_evt_handle().\n */\ntypedef int (*uwbd_evt_handler_f)(struct uwb_event *);\n\n/**\n * Properties of a UWBD event\n *\n * @handler:    the function that will handle this event\n * @name:       text name of event\n */\nstruct uwbd_event {\n\tuwbd_evt_handler_f handler;\n\tconst char *name;\n};\n\n/* Table of handlers for and properties of the UWBD Radio Control Events */\nstatic struct uwbd_event uwbd_urc_events[] = {\n\t[UWB_RC_EVT_IE_RCV] = {\n\t\t.handler = uwbd_evt_handle_rc_ie_rcv,\n\t\t.name = \"IE_RECEIVED\"\n\t},\n\t[UWB_RC_EVT_BEACON] = {\n\t\t.handler = uwbd_evt_handle_rc_beacon,\n\t\t.name = \"BEACON_RECEIVED\"\n\t},\n\t[UWB_RC_EVT_BEACON_SIZE] = {\n\t\t.handler = uwbd_evt_handle_rc_beacon_size,\n\t\t.name = \"BEACON_SIZE_CHANGE\"\n\t},\n\t[UWB_RC_EVT_BPOIE_CHANGE] = {\n\t\t.handler = uwbd_evt_handle_rc_bpoie_change,\n\t\t.name = \"BPOIE_CHANGE\"\n\t},\n\t[UWB_RC_EVT_BP_SLOT_CHANGE] = {\n\t\t.handler = uwbd_evt_handle_rc_bp_slot_change,\n\t\t.name = \"BP_SLOT_CHANGE\"\n\t},\n\t[UWB_RC_EVT_DRP_AVAIL] = {\n\t\t.handler = uwbd_evt_handle_rc_drp_avail,\n\t\t.name = \"DRP_AVAILABILITY_CHANGE\"\n\t},\n\t[UWB_RC_EVT_DRP] = {\n\t\t.handler = uwbd_evt_handle_rc_drp,\n\t\t.name = \"DRP\"\n\t},\n\t[UWB_RC_EVT_DEV_ADDR_CONFLICT] = {\n\t\t.handler = uwbd_evt_handle_rc_dev_addr_conflict,\n\t\t.name = \"DEV_ADDR_CONFLICT\",\n\t},\n};\n\n\n\nstruct uwbd_evt_type_handler {\n\tconst char *name;\n\tstruct uwbd_event *uwbd_events;\n\tsize_t size;\n};\n\n/* Table of handlers for each UWBD Event type. */\nstatic struct uwbd_evt_type_handler uwbd_urc_evt_type_handlers[] = {\n\t[UWB_RC_CET_GENERAL] = {\n\t\t.name        = \"URC\",\n\t\t.uwbd_events = uwbd_urc_events,\n\t\t.size        = ARRAY_SIZE(uwbd_urc_events),\n\t},\n};\n\nstatic const struct uwbd_event uwbd_message_handlers[] = {\n\t[UWB_EVT_MSG_RESET] = {\n\t\t.handler = uwbd_msg_handle_reset,\n\t\t.name = \"reset\",\n\t},\n};\n\n/*\n * Handle an URC event passed to the UWB Daemon\n *\n * @evt: the event to handle\n * @returns: 0 if the event can be kfreed, !0 on the contrary\n *           (somebody else took ownership) [coincidentally, returning\n *           a <0 errno code will free it :)].\n *\n * Looks up the two indirection tables (one for the type, one for the\n * subtype) to decide which function handles it and then calls the\n * handler.\n *\n * The event structure passed to the event handler has the radio\n * controller in @evt->rc referenced. The reference will be dropped\n * once the handler returns, so if it needs it for longer (async),\n * it'll need to take another one.\n */\nstatic\nint uwbd_event_handle_urc(struct uwb_event *evt)\n{\n\tint result = -EINVAL;\n\tstruct uwbd_evt_type_handler *type_table;\n\tuwbd_evt_handler_f handler;\n\tu8 type, context;\n\tu16 event;\n\n\ttype = evt->notif.rceb->bEventType;\n\tevent = le16_to_cpu(evt->notif.rceb->wEvent);\n\tcontext = evt->notif.rceb->bEventContext;\n\n\tif (type >= ARRAY_SIZE(uwbd_urc_evt_type_handlers))\n\t\tgoto out;\n\ttype_table = &uwbd_urc_evt_type_handlers[type];\n\tif (type_table->uwbd_events == NULL)\n\t\tgoto out;\n\tif (event >= type_table->size)\n\t\tgoto out;\n\thandler = type_table->uwbd_events[event].handler;\n\tif (handler == NULL)\n\t\tgoto out;\n\n\tresult = (*handler)(evt);\nout:\n\tif (result < 0)\n\t\tdev_err(&evt->rc->uwb_dev.dev,\n\t\t\t\"UWBD: event 0x%02x/%04x/%02x, handling failed: %d\\n\",\n\t\t\ttype, event, context, result);\n\treturn result;\n}\n\nstatic void uwbd_event_handle_message(struct uwb_event *evt)\n{\n\tstruct uwb_rc *rc;\n\tint result;\n\n\trc = evt->rc;\n\n\tif (evt->message < 0 || evt->message >= ARRAY_SIZE(uwbd_message_handlers)) {\n\t\tdev_err(&rc->uwb_dev.dev, \"UWBD: invalid message type %d\\n\", evt->message);\n\t\treturn;\n\t}\n\n\tresult = uwbd_message_handlers[evt->message].handler(evt);\n\tif (result < 0)\n\t\tdev_err(&rc->uwb_dev.dev, \"UWBD: '%s' message failed: %d\\n\",\n\t\t\tuwbd_message_handlers[evt->message].name, result);\n}\n\nstatic void uwbd_event_handle(struct uwb_event *evt)\n{\n\tstruct uwb_rc *rc;\n\tint should_keep;\n\n\trc = evt->rc;\n\n\tif (rc->ready) {\n\t\tswitch (evt->type) {\n\t\tcase UWB_EVT_TYPE_NOTIF:\n\t\t\tshould_keep = uwbd_event_handle_urc(evt);\n\t\t\tif (should_keep <= 0)\n\t\t\t\tkfree(evt->notif.rceb);\n\t\t\tbreak;\n\t\tcase UWB_EVT_TYPE_MSG:\n\t\t\tuwbd_event_handle_message(evt);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&rc->uwb_dev.dev, \"UWBD: invalid event type %d\\n\", evt->type);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t__uwb_rc_put(rc);\t/* for the __uwb_rc_get() in uwb_rc_notif_cb() */\n}\n\n/**\n * UWB Daemon\n *\n * Listens to all UWB notifications and takes care to track the state\n * of the UWB neighbourhood for the kernel. When we do a run, we\n * spinlock, move the list to a private copy and release the\n * lock. Hold it as little as possible. Not a conflict: it is\n * guaranteed we own the events in the private list.\n *\n * FIXME: should change so we don't have a 1HZ timer all the time, but\n *        only if there are devices.\n */\nstatic int uwbd(void *param)\n{\n\tstruct uwb_rc *rc = param;\n\tunsigned long flags;\n\tstruct uwb_event *evt;\n\tint should_stop = 0;\n\n\twhile (1) {\n\t\twait_event_interruptible_timeout(\n\t\t\trc->uwbd.wq,\n\t\t\t!list_empty(&rc->uwbd.event_list)\n\t\t\t  || (should_stop = kthread_should_stop()),\n\t\t\tHZ);\n\t\tif (should_stop)\n\t\t\tbreak;\n\n\t\tspin_lock_irqsave(&rc->uwbd.event_list_lock, flags);\n\t\tif (!list_empty(&rc->uwbd.event_list)) {\n\t\t\tevt = list_first_entry(&rc->uwbd.event_list, struct uwb_event, list_node);\n\t\t\tlist_del(&evt->list_node);\n\t\t} else\n\t\t\tevt = NULL;\n\t\tspin_unlock_irqrestore(&rc->uwbd.event_list_lock, flags);\n\n\t\tif (evt) {\n\t\t\tuwbd_event_handle(evt);\n\t\t\tkfree(evt);\n\t\t}\n\n\t\tuwb_beca_purge(rc);\t/* Purge devices that left */\n\t}\n\treturn 0;\n}\n\n\n/** Start the UWB daemon */\nvoid uwbd_start(struct uwb_rc *rc)\n{\n\tstruct task_struct *task = kthread_run(uwbd, rc, \"uwbd\");\n\tif (IS_ERR(task)) {\n\t\trc->uwbd.task = NULL;\n\t\tprintk(KERN_ERR \"UWB: Cannot start management daemon; \"\n\t\t       \"UWB won't work\\n\");\n\t} else {\n\t\trc->uwbd.task = task;\n\t\trc->uwbd.pid = rc->uwbd.task->pid;\n\t}\n}\n\n/* Stop the UWB daemon and free any unprocessed events */\nvoid uwbd_stop(struct uwb_rc *rc)\n{\n\tif (rc->uwbd.task)\n\t\tkthread_stop(rc->uwbd.task);\n\tuwbd_flush(rc);\n}\n\n/*\n * Queue an event for the management daemon\n *\n * When some lower layer receives an event, it uses this function to\n * push it forward to the UWB daemon.\n *\n * Once you pass the event, you don't own it any more, but the daemon\n * does. It will uwb_event_free() it when done, so make sure you\n * uwb_event_alloc()ed it or bad things will happen.\n *\n * If the daemon is not running, we just free the event.\n */\nvoid uwbd_event_queue(struct uwb_event *evt)\n{\n\tstruct uwb_rc *rc = evt->rc;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rc->uwbd.event_list_lock, flags);\n\tif (rc->uwbd.pid != 0) {\n\t\tlist_add(&evt->list_node, &rc->uwbd.event_list);\n\t\twake_up_all(&rc->uwbd.wq);\n\t} else {\n\t\t__uwb_rc_put(evt->rc);\n\t\tif (evt->type == UWB_EVT_TYPE_NOTIF)\n\t\t\tkfree(evt->notif.rceb);\n\t\tkfree(evt);\n\t}\n\tspin_unlock_irqrestore(&rc->uwbd.event_list_lock, flags);\n\treturn;\n}\n\nvoid uwbd_flush(struct uwb_rc *rc)\n{\n\tstruct uwb_event *evt, *nxt;\n\n\tspin_lock_irq(&rc->uwbd.event_list_lock);\n\tlist_for_each_entry_safe(evt, nxt, &rc->uwbd.event_list, list_node) {\n\t\tif (evt->rc == rc) {\n\t\t\t__uwb_rc_put(rc);\n\t\t\tlist_del(&evt->list_node);\n\t\t\tif (evt->type == UWB_EVT_TYPE_NOTIF)\n\t\t\t\tkfree(evt->notif.rceb);\n\t\t\tkfree(evt);\n\t\t}\n\t}\n\tspin_unlock_irq(&rc->uwbd.event_list_lock);\n}\n"], "filenames": ["drivers/uwb/uwbd.c"], "buggy_code_start_loc": [305], "buggy_code_end_loc": [317], "fixing_code_start_loc": [305], "fixing_code_end_loc": [321], "type": "CWE-119", "message": "drivers/uwb/uwbd.c in the Linux kernel before 4.13.6 allows local users to cause a denial of service (general protection fault and system crash) or possibly have unspecified other impact via a crafted USB device.", "other": {"cve": {"id": "CVE-2017-16526", "sourceIdentifier": "cve@mitre.org", "published": "2017-11-04T01:29:36.773", "lastModified": "2023-01-19T15:46:23.587", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "drivers/uwb/uwbd.c in the Linux kernel before 4.13.6 allows local users to cause a denial of service (general protection fault and system crash) or possibly have unspecified other impact via a crafted USB device."}, {"lang": "es", "value": "drivers/uwb/uwbd.c en el kernel de Linux, en versiones anteriores a la 4.13.6, permite que los usuarios locales provoquen una denegaci\u00f3n de servicio (fallo de protecci\u00f3n general y cierre inesperado del sistema) o, posiblemente, causen otros impactos no especificados mediante llamadas del sistema manipuladas."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.2.97", "matchCriteriaId": "3B86887F-D4E3-4F47-98BC-697EE11A74CE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.3", "versionEndExcluding": "3.16.52", "matchCriteriaId": "B97C01AC-F470-4190-AC38-30DE3DFDCCAC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.17", "versionEndExcluding": "3.18.75", "matchCriteriaId": "E04E29B0-31A7-4409-B175-5BA76E2D139A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.19", "versionEndExcluding": "4.1.46", "matchCriteriaId": "8E07836D-67CD-47C8-9E8C-7AA3DBCAEFF2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.2", "versionEndExcluding": "4.4.92", "matchCriteriaId": "2E3DFF40-9172-40DC-B4F3-ED473E3EF79D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.5", "versionEndExcluding": "4.9.55", "matchCriteriaId": "6D4234C0-2CB9-42EA-A1B2-9A2FB26B8ABA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.10", "versionEndExcluding": "4.13.6", "matchCriteriaId": "5B059C9D-19AF-467F-AA41-2433849FDCA8"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}], "references": [{"url": "https://github.com/torvalds/linux/commit/bbf26183b7a6236ba602f4d6a2f7cade35bba043", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://groups.google.com/d/msg/syzkaller/zROBxKXzHDk/5I6aZ3O2AgAJ", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/05/msg00000.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3754-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4187", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/bbf26183b7a6236ba602f4d6a2f7cade35bba043"}}