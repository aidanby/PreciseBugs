{"buggy_code": ["package chat\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/owncast/owncast/core/chat/events\"\n\t\"github.com/owncast/owncast/core/data\"\n\t\"github.com/owncast/owncast/core/user\"\n\t\"github.com/owncast/owncast/models\"\n\tlog \"github.com/sirupsen/logrus\"\n)\n\nvar _datastore *data.Datastore\n\nconst (\n\tmaxBacklogHours  = 2  // Keep backlog max hours worth of messages\n\tmaxBacklogNumber = 50 // Return max number of messages in history request\n)\n\nfunc setupPersistence() {\n\t_datastore = data.GetDatastore()\n\tdata.CreateMessagesTable(_datastore.DB)\n\tdata.CreateBanIPTable(_datastore.DB)\n\n\tchatDataPruner := time.NewTicker(5 * time.Minute)\n\tgo func() {\n\t\trunPruner()\n\t\tfor range chatDataPruner.C {\n\t\t\trunPruner()\n\t\t}\n\t}()\n}\n\n// SaveUserMessage will save a single chat event to the messages database.\nfunc SaveUserMessage(event events.UserMessageEvent) {\n\tsaveEvent(event.ID, &event.User.ID, event.Body, event.Type, event.HiddenAt, event.Timestamp, nil, nil, nil, nil)\n}\n\nfunc saveFederatedAction(event events.FediverseEngagementEvent) {\n\tsaveEvent(event.ID, nil, event.Body, event.Type, nil, event.Timestamp, event.Image, &event.Link, &event.UserAccountName, nil)\n}\n\n// nolint: unparam\nfunc saveEvent(id string, userID *string, body string, eventType string, hidden *time.Time, timestamp time.Time, image *string, link *string, title *string, subtitle *string) {\n\tdefer func() {\n\t\t_historyCache = nil\n\t}()\n\n\ttx, err := _datastore.DB.Begin()\n\tif err != nil {\n\t\tlog.Errorln(\"error saving\", eventType, err)\n\t\treturn\n\t}\n\n\tdefer tx.Rollback() // nolint\n\n\tstmt, err := tx.Prepare(\"INSERT INTO messages(id, user_id, body, eventType, hidden_at, timestamp, image, link, title, subtitle) values(?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\")\n\tif err != nil {\n\t\tlog.Errorln(\"error saving\", eventType, err)\n\t\treturn\n\t}\n\n\tdefer stmt.Close()\n\n\tif _, err = stmt.Exec(id, userID, body, eventType, hidden, timestamp, image, link, title, subtitle); err != nil {\n\t\tlog.Errorln(\"error saving\", eventType, err)\n\t\treturn\n\t}\n\tif err = tx.Commit(); err != nil {\n\t\tlog.Errorln(\"error saving\", eventType, err)\n\t\treturn\n\t}\n}\n\nfunc makeUserMessageEventFromRowData(row rowData) events.UserMessageEvent {\n\tscopes := \"\"\n\tif row.userScopes != nil {\n\t\tscopes = *row.userScopes\n\t}\n\n\tpreviousUsernames := []string{}\n\tif row.previousUsernames != nil {\n\t\tpreviousUsernames = strings.Split(*row.previousUsernames, \",\")\n\t}\n\n\tdisplayName := \"\"\n\tif row.userDisplayName != nil {\n\t\tdisplayName = *row.userDisplayName\n\t}\n\n\tdisplayColor := 0\n\tif row.userDisplayColor != nil {\n\t\tdisplayColor = *row.userDisplayColor\n\t}\n\n\tcreatedAt := time.Time{}\n\tif row.userCreatedAt != nil {\n\t\tcreatedAt = *row.userCreatedAt\n\t}\n\n\tisBot := (row.userType != nil && *row.userType == \"API\")\n\tscopeSlice := strings.Split(scopes, \",\")\n\n\tu := user.User{\n\t\tID:              *row.userID,\n\t\tDisplayName:     displayName,\n\t\tDisplayColor:    displayColor,\n\t\tCreatedAt:       createdAt,\n\t\tDisabledAt:      row.userDisabledAt,\n\t\tNameChangedAt:   row.userNameChangedAt,\n\t\tPreviousNames:   previousUsernames,\n\t\tAuthenticatedAt: row.userAuthenticatedAt,\n\t\tAuthenticated:   row.userAuthenticatedAt != nil,\n\t\tScopes:          scopeSlice,\n\t\tIsBot:           isBot,\n\t}\n\n\tmessage := events.UserMessageEvent{\n\t\tEvent: events.Event{\n\t\t\tType:      row.eventType,\n\t\t\tID:        row.id,\n\t\t\tTimestamp: row.timestamp,\n\t\t},\n\t\tUserEvent: events.UserEvent{\n\t\t\tUser:     &u,\n\t\t\tHiddenAt: row.hiddenAt,\n\t\t},\n\t\tMessageEvent: events.MessageEvent{\n\t\t\tBody:    row.body,\n\t\t\tRawBody: row.body,\n\t\t},\n\t}\n\n\treturn message\n}\n\nfunc makeSystemMessageChatEventFromRowData(row rowData) events.SystemMessageEvent {\n\tmessage := events.SystemMessageEvent{\n\t\tEvent: events.Event{\n\t\t\tType:      row.eventType,\n\t\t\tID:        row.id,\n\t\t\tTimestamp: row.timestamp,\n\t\t},\n\t\tMessageEvent: events.MessageEvent{\n\t\t\tBody:    row.body,\n\t\t\tRawBody: row.body,\n\t\t},\n\t}\n\treturn message\n}\n\nfunc makeActionMessageChatEventFromRowData(row rowData) events.ActionEvent {\n\tmessage := events.ActionEvent{\n\t\tEvent: events.Event{\n\t\t\tType:      row.eventType,\n\t\t\tID:        row.id,\n\t\t\tTimestamp: row.timestamp,\n\t\t},\n\t\tMessageEvent: events.MessageEvent{\n\t\t\tBody:    row.body,\n\t\t\tRawBody: row.body,\n\t\t},\n\t}\n\treturn message\n}\n\nfunc makeFederatedActionChatEventFromRowData(row rowData) events.FediverseEngagementEvent {\n\tmessage := events.FediverseEngagementEvent{\n\t\tEvent: events.Event{\n\t\t\tType:      row.eventType,\n\t\t\tID:        row.id,\n\t\t\tTimestamp: row.timestamp,\n\t\t},\n\t\tMessageEvent: events.MessageEvent{\n\t\t\tBody:    row.body,\n\t\t\tRawBody: row.body,\n\t\t},\n\t\tImage:           row.image,\n\t\tLink:            *row.link,\n\t\tUserAccountName: *row.title,\n\t}\n\treturn message\n}\n\ntype rowData struct {\n\tid        string\n\tuserID    *string\n\tbody      string\n\teventType models.EventType\n\thiddenAt  *time.Time\n\ttimestamp time.Time\n\ttitle     *string\n\tsubtitle  *string\n\timage     *string\n\tlink      *string\n\n\tuserDisplayName     *string\n\tuserDisplayColor    *int\n\tuserCreatedAt       *time.Time\n\tuserDisabledAt      *time.Time\n\tpreviousUsernames   *string\n\tuserNameChangedAt   *time.Time\n\tuserAuthenticatedAt *time.Time\n\tuserScopes          *string\n\tuserType            *string\n}\n\nfunc getChat(query string) []interface{} {\n\thistory := make([]interface{}, 0)\n\trows, err := _datastore.DB.Query(query)\n\tif err != nil || rows.Err() != nil {\n\t\tlog.Errorln(\"error fetching chat history\", err)\n\t\treturn history\n\t}\n\tdefer rows.Close()\n\n\tfor rows.Next() {\n\t\trow := rowData{}\n\n\t\t// Convert a database row into a chat event\n\t\tif err = rows.Scan(\n\t\t\t&row.id,\n\t\t\t&row.userID,\n\t\t\t&row.body,\n\t\t\t&row.title,\n\t\t\t&row.subtitle,\n\t\t\t&row.image,\n\t\t\t&row.link,\n\t\t\t&row.eventType,\n\t\t\t&row.hiddenAt,\n\t\t\t&row.timestamp,\n\t\t\t&row.userDisplayName,\n\t\t\t&row.userDisplayColor,\n\t\t\t&row.userCreatedAt,\n\t\t\t&row.userDisabledAt,\n\t\t\t&row.previousUsernames,\n\t\t\t&row.userNameChangedAt,\n\t\t\t&row.userAuthenticatedAt,\n\t\t\t&row.userScopes,\n\t\t\t&row.userType,\n\t\t); err != nil {\n\t\t\tlog.Errorln(err)\n\t\t\tlog.Errorln(\"There is a problem converting query to chat objects. Please report this:\", query)\n\t\t\tbreak\n\t\t}\n\n\t\tvar message interface{}\n\n\t\tswitch row.eventType {\n\t\tcase events.MessageSent:\n\t\t\tmessage = makeUserMessageEventFromRowData(row)\n\t\tcase events.SystemMessageSent:\n\t\t\tmessage = makeSystemMessageChatEventFromRowData(row)\n\t\tcase events.ChatActionSent:\n\t\t\tmessage = makeActionMessageChatEventFromRowData(row)\n\t\tcase events.FediverseEngagementFollow:\n\t\t\tmessage = makeFederatedActionChatEventFromRowData(row)\n\t\tcase events.FediverseEngagementLike:\n\t\t\tmessage = makeFederatedActionChatEventFromRowData(row)\n\t\tcase events.FediverseEngagementRepost:\n\t\t\tmessage = makeFederatedActionChatEventFromRowData(row)\n\t\t}\n\n\t\thistory = append(history, message)\n\t}\n\n\treturn history\n}\n\nvar _historyCache *[]interface{}\n\n// GetChatModerationHistory will return all the chat messages suitable for moderation purposes.\nfunc GetChatModerationHistory() []interface{} {\n\tif _historyCache != nil {\n\t\treturn *_historyCache\n\t}\n\n\t// Get all messages regardless of visibility\n\tquery := \"SELECT messages.id, user_id, body, title, subtitle, image, link, eventType, hidden_at, timestamp, display_name, display_color, created_at, disabled_at, previous_names, namechanged_at, authenticated_at, scopes, type FROM messages INNER JOIN users ON messages.user_id = users.id ORDER BY timestamp DESC\"\n\tresult := getChat(query)\n\n\t_historyCache = &result\n\n\treturn result\n}\n\n// GetChatHistory will return all the chat messages suitable for returning as user-facing chat history.\nfunc GetChatHistory() []interface{} {\n\t// Get all visible messages\n\tquery := fmt.Sprintf(\"SELECT messages.id, messages.user_id, messages.body, messages.title, messages.subtitle, messages.image, messages.link, messages.eventType, messages.hidden_at, messages.timestamp, users.display_name, users.display_color, users.created_at, users.disabled_at, users.previous_names, users.namechanged_at, users.authenticated_at, users.scopes, users.type FROM users JOIN messages ON users.id = messages.user_id WHERE hidden_at IS NULL AND disabled_at IS NULL ORDER BY timestamp DESC LIMIT %d\", maxBacklogNumber)\n\tm := getChat(query)\n\n\t// Invert order of messages\n\tfor i, j := 0, len(m)-1; i < j; i, j = i+1, j-1 {\n\t\tm[i], m[j] = m[j], m[i]\n\t}\n\n\treturn m\n}\n\n// SetMessageVisibilityForUserID will bulk change the visibility of messages for a user\n// and then send out visibility changed events to chat clients.\nfunc SetMessageVisibilityForUserID(userID string, visible bool) error {\n\tdefer func() {\n\t\t_historyCache = nil\n\t}()\n\n\t// Get a list of IDs to send to the connected clients to hide\n\tids := make([]string, 0)\n\tquery := fmt.Sprintf(\"SELECT messages.id, user_id, body, title, subtitle, image, link, eventType, hidden_at, timestamp, display_name, display_color, created_at, disabled_at,  previous_names, namechanged_at, authenticated_at, scopes, type FROM messages INNER JOIN users ON messages.user_id = users.id WHERE user_id IS '%s'\", userID)\n\tmessages := getChat(query)\n\n\tif len(messages) == 0 {\n\t\treturn nil\n\t}\n\n\tfor _, message := range messages {\n\t\tids = append(ids, message.(events.UserMessageEvent).ID)\n\t}\n\n\t// Tell the clients to hide/show these messages.\n\treturn SetMessagesVisibility(ids, visible)\n}\n\nfunc saveMessageVisibility(messageIDs []string, visible bool) error {\n\tdefer func() {\n\t\t_historyCache = nil\n\t}()\n\n\t_datastore.DbLock.Lock()\n\tdefer _datastore.DbLock.Unlock()\n\n\ttx, err := _datastore.DB.Begin()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// nolint:gosec\n\tstmt, err := tx.Prepare(\"UPDATE messages SET hidden_at=? WHERE id IN (?\" + strings.Repeat(\",?\", len(messageIDs)-1) + \")\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer stmt.Close()\n\n\tvar hiddenAt *time.Time\n\tif !visible {\n\t\tnow := time.Now()\n\t\thiddenAt = &now\n\t} else {\n\t\thiddenAt = nil\n\t}\n\n\targs := make([]interface{}, len(messageIDs)+1)\n\targs[0] = hiddenAt\n\tfor i, id := range messageIDs {\n\t\targs[i+1] = id\n\t}\n\n\tif _, err = stmt.Exec(args...); err != nil {\n\t\treturn err\n\t}\n\n\tif err = tx.Commit(); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n"], "fixing_code": ["package chat\n\nimport (\n\t\"database/sql\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/owncast/owncast/core/chat/events\"\n\t\"github.com/owncast/owncast/core/data\"\n\t\"github.com/owncast/owncast/core/user\"\n\t\"github.com/owncast/owncast/models\"\n\tlog \"github.com/sirupsen/logrus\"\n)\n\nvar _datastore *data.Datastore\n\nconst (\n\tmaxBacklogHours  = 2  // Keep backlog max hours worth of messages\n\tmaxBacklogNumber = 50 // Return max number of messages in history request\n)\n\nfunc setupPersistence() {\n\t_datastore = data.GetDatastore()\n\tdata.CreateMessagesTable(_datastore.DB)\n\tdata.CreateBanIPTable(_datastore.DB)\n\n\tchatDataPruner := time.NewTicker(5 * time.Minute)\n\tgo func() {\n\t\trunPruner()\n\t\tfor range chatDataPruner.C {\n\t\t\trunPruner()\n\t\t}\n\t}()\n}\n\n// SaveUserMessage will save a single chat event to the messages database.\nfunc SaveUserMessage(event events.UserMessageEvent) {\n\tsaveEvent(event.ID, &event.User.ID, event.Body, event.Type, event.HiddenAt, event.Timestamp, nil, nil, nil, nil)\n}\n\nfunc saveFederatedAction(event events.FediverseEngagementEvent) {\n\tsaveEvent(event.ID, nil, event.Body, event.Type, nil, event.Timestamp, event.Image, &event.Link, &event.UserAccountName, nil)\n}\n\n// nolint: unparam\nfunc saveEvent(id string, userID *string, body string, eventType string, hidden *time.Time, timestamp time.Time, image *string, link *string, title *string, subtitle *string) {\n\tdefer func() {\n\t\t_historyCache = nil\n\t}()\n\n\ttx, err := _datastore.DB.Begin()\n\tif err != nil {\n\t\tlog.Errorln(\"error saving\", eventType, err)\n\t\treturn\n\t}\n\n\tdefer tx.Rollback() // nolint\n\n\tstmt, err := tx.Prepare(\"INSERT INTO messages(id, user_id, body, eventType, hidden_at, timestamp, image, link, title, subtitle) values(?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\")\n\tif err != nil {\n\t\tlog.Errorln(\"error saving\", eventType, err)\n\t\treturn\n\t}\n\n\tdefer stmt.Close()\n\n\tif _, err = stmt.Exec(id, userID, body, eventType, hidden, timestamp, image, link, title, subtitle); err != nil {\n\t\tlog.Errorln(\"error saving\", eventType, err)\n\t\treturn\n\t}\n\tif err = tx.Commit(); err != nil {\n\t\tlog.Errorln(\"error saving\", eventType, err)\n\t\treturn\n\t}\n}\n\nfunc makeUserMessageEventFromRowData(row rowData) events.UserMessageEvent {\n\tscopes := \"\"\n\tif row.userScopes != nil {\n\t\tscopes = *row.userScopes\n\t}\n\n\tpreviousUsernames := []string{}\n\tif row.previousUsernames != nil {\n\t\tpreviousUsernames = strings.Split(*row.previousUsernames, \",\")\n\t}\n\n\tdisplayName := \"\"\n\tif row.userDisplayName != nil {\n\t\tdisplayName = *row.userDisplayName\n\t}\n\n\tdisplayColor := 0\n\tif row.userDisplayColor != nil {\n\t\tdisplayColor = *row.userDisplayColor\n\t}\n\n\tcreatedAt := time.Time{}\n\tif row.userCreatedAt != nil {\n\t\tcreatedAt = *row.userCreatedAt\n\t}\n\n\tisBot := (row.userType != nil && *row.userType == \"API\")\n\tscopeSlice := strings.Split(scopes, \",\")\n\n\tu := user.User{\n\t\tID:              *row.userID,\n\t\tDisplayName:     displayName,\n\t\tDisplayColor:    displayColor,\n\t\tCreatedAt:       createdAt,\n\t\tDisabledAt:      row.userDisabledAt,\n\t\tNameChangedAt:   row.userNameChangedAt,\n\t\tPreviousNames:   previousUsernames,\n\t\tAuthenticatedAt: row.userAuthenticatedAt,\n\t\tAuthenticated:   row.userAuthenticatedAt != nil,\n\t\tScopes:          scopeSlice,\n\t\tIsBot:           isBot,\n\t}\n\n\tmessage := events.UserMessageEvent{\n\t\tEvent: events.Event{\n\t\t\tType:      row.eventType,\n\t\t\tID:        row.id,\n\t\t\tTimestamp: row.timestamp,\n\t\t},\n\t\tUserEvent: events.UserEvent{\n\t\t\tUser:     &u,\n\t\t\tHiddenAt: row.hiddenAt,\n\t\t},\n\t\tMessageEvent: events.MessageEvent{\n\t\t\tBody:    row.body,\n\t\t\tRawBody: row.body,\n\t\t},\n\t}\n\n\treturn message\n}\n\nfunc makeSystemMessageChatEventFromRowData(row rowData) events.SystemMessageEvent {\n\tmessage := events.SystemMessageEvent{\n\t\tEvent: events.Event{\n\t\t\tType:      row.eventType,\n\t\t\tID:        row.id,\n\t\t\tTimestamp: row.timestamp,\n\t\t},\n\t\tMessageEvent: events.MessageEvent{\n\t\t\tBody:    row.body,\n\t\t\tRawBody: row.body,\n\t\t},\n\t}\n\treturn message\n}\n\nfunc makeActionMessageChatEventFromRowData(row rowData) events.ActionEvent {\n\tmessage := events.ActionEvent{\n\t\tEvent: events.Event{\n\t\t\tType:      row.eventType,\n\t\t\tID:        row.id,\n\t\t\tTimestamp: row.timestamp,\n\t\t},\n\t\tMessageEvent: events.MessageEvent{\n\t\t\tBody:    row.body,\n\t\t\tRawBody: row.body,\n\t\t},\n\t}\n\treturn message\n}\n\nfunc makeFederatedActionChatEventFromRowData(row rowData) events.FediverseEngagementEvent {\n\tmessage := events.FediverseEngagementEvent{\n\t\tEvent: events.Event{\n\t\t\tType:      row.eventType,\n\t\t\tID:        row.id,\n\t\t\tTimestamp: row.timestamp,\n\t\t},\n\t\tMessageEvent: events.MessageEvent{\n\t\t\tBody:    row.body,\n\t\t\tRawBody: row.body,\n\t\t},\n\t\tImage:           row.image,\n\t\tLink:            *row.link,\n\t\tUserAccountName: *row.title,\n\t}\n\treturn message\n}\n\ntype rowData struct {\n\tid        string\n\tuserID    *string\n\tbody      string\n\teventType models.EventType\n\thiddenAt  *time.Time\n\ttimestamp time.Time\n\ttitle     *string\n\tsubtitle  *string\n\timage     *string\n\tlink      *string\n\n\tuserDisplayName     *string\n\tuserDisplayColor    *int\n\tuserCreatedAt       *time.Time\n\tuserDisabledAt      *time.Time\n\tpreviousUsernames   *string\n\tuserNameChangedAt   *time.Time\n\tuserAuthenticatedAt *time.Time\n\tuserScopes          *string\n\tuserType            *string\n}\n\nfunc getChat(rows *sql.Rows) ([]interface{}, error) {\n\thistory := make([]interface{}, 0)\n\n\tfor rows.Next() {\n\t\trow := rowData{}\n\n\t\t// Convert a database row into a chat event\n\t\tif err := rows.Scan(\n\t\t\t&row.id,\n\t\t\t&row.userID,\n\t\t\t&row.body,\n\t\t\t&row.title,\n\t\t\t&row.subtitle,\n\t\t\t&row.image,\n\t\t\t&row.link,\n\t\t\t&row.eventType,\n\t\t\t&row.hiddenAt,\n\t\t\t&row.timestamp,\n\t\t\t&row.userDisplayName,\n\t\t\t&row.userDisplayColor,\n\t\t\t&row.userCreatedAt,\n\t\t\t&row.userDisabledAt,\n\t\t\t&row.previousUsernames,\n\t\t\t&row.userNameChangedAt,\n\t\t\t&row.userAuthenticatedAt,\n\t\t\t&row.userScopes,\n\t\t\t&row.userType,\n\t\t); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tvar message interface{}\n\n\t\tswitch row.eventType {\n\t\tcase events.MessageSent:\n\t\t\tmessage = makeUserMessageEventFromRowData(row)\n\t\tcase events.SystemMessageSent:\n\t\t\tmessage = makeSystemMessageChatEventFromRowData(row)\n\t\tcase events.ChatActionSent:\n\t\t\tmessage = makeActionMessageChatEventFromRowData(row)\n\t\tcase events.FediverseEngagementFollow:\n\t\t\tmessage = makeFederatedActionChatEventFromRowData(row)\n\t\tcase events.FediverseEngagementLike:\n\t\t\tmessage = makeFederatedActionChatEventFromRowData(row)\n\t\tcase events.FediverseEngagementRepost:\n\t\t\tmessage = makeFederatedActionChatEventFromRowData(row)\n\t\t}\n\n\t\thistory = append(history, message)\n\t}\n\n\treturn history, nil\n}\n\nvar _historyCache *[]interface{}\n\n// GetChatModerationHistory will return all the chat messages suitable for moderation purposes.\nfunc GetChatModerationHistory() []interface{} {\n\tif _historyCache != nil {\n\t\treturn *_historyCache\n\t}\n\n\ttx, err := _datastore.DB.Begin()\n\tif err != nil {\n\t\tlog.Errorln(\"error fetching chat moderation history\", err)\n\t\treturn nil\n\t}\n\n\tdefer tx.Rollback() // nolint\n\n\t// Get all messages regardless of visibility\n\tquery := \"SELECT messages.id, user_id, body, title, subtitle, image, link, eventType, hidden_at, timestamp, display_name, display_color, created_at, disabled_at, previous_names, namechanged_at, authenticated_at, scopes, type FROM messages INNER JOIN users ON messages.user_id = users.id ORDER BY timestamp DESC\"\n\tstmt, err := tx.Prepare(query)\n\tif err != nil {\n\t\tlog.Errorln(\"error fetching chat moderation history\", err)\n\t\treturn nil\n\t}\n\n\trows, err := stmt.Query()\n\tif err != nil {\n\t\tlog.Errorln(\"error fetching chat moderation history\", err)\n\t\treturn nil\n\t}\n\n\tdefer stmt.Close()\n\tdefer rows.Close()\n\n\tresult, err := getChat(rows)\n\n\tif err != nil {\n\t\tlog.Errorln(err)\n\t\tlog.Errorln(\"There is a problem enumerating chat message rows. Please report this:\", query)\n\t\treturn nil\n\t}\n\n\t_historyCache = &result\n\n\tif err = tx.Commit(); err != nil {\n\t\tlog.Errorln(\"error fetching chat moderation history\", err)\n\t\treturn nil\n\t}\n\n\treturn result\n}\n\n// GetChatHistory will return all the chat messages suitable for returning as user-facing chat history.\nfunc GetChatHistory() []interface{} {\n\ttx, err := _datastore.DB.Begin()\n\tif err != nil {\n\t\tlog.Errorln(\"error fetching chat history\", err)\n\t\treturn nil\n\t}\n\n\tdefer tx.Rollback() // nolint\n\n\t// Get all visible messages\n\tquery := \"SELECT messages.id, messages.user_id, messages.body, messages.title, messages.subtitle, messages.image, messages.link, messages.eventType, messages.hidden_at, messages.timestamp, users.display_name, users.display_color, users.created_at, users.disabled_at, users.previous_names, users.namechanged_at, users.authenticated_at, users.scopes, users.type FROM users JOIN messages ON users.id = messages.user_id WHERE hidden_at IS NULL AND disabled_at IS NULL ORDER BY timestamp DESC LIMIT ?\"\n\n\tstmt, err := tx.Prepare(query)\n\tif err != nil {\n\t\tlog.Errorln(\"error fetching chat history\", err)\n\t\treturn nil\n\t}\n\n\trows, err := stmt.Query(maxBacklogNumber)\n\tif err != nil {\n\t\tlog.Errorln(\"error fetching chat history\", err)\n\t\treturn nil\n\t}\n\n\tdefer stmt.Close()\n\tdefer rows.Close()\n\n\tm, err := getChat(rows)\n\n\tif err != nil {\n\t\tlog.Errorln(err)\n\t\tlog.Errorln(\"There is a problem enumerating chat message rows. Please report this:\", query)\n\t\treturn nil\n\t}\n\n\tif err = tx.Commit(); err != nil {\n\t\tlog.Errorln(\"error fetching chat history\", err)\n\t\treturn nil\n\t}\n\n\t// Invert order of messages\n\tfor i, j := 0, len(m)-1; i < j; i, j = i+1, j-1 {\n\t\tm[i], m[j] = m[j], m[i]\n\t}\n\n\treturn m\n}\n\n// SetMessageVisibilityForUserID will bulk change the visibility of messages for a user\n// and then send out visibility changed events to chat clients.\nfunc SetMessageVisibilityForUserID(userID string, visible bool) error {\n\tdefer func() {\n\t\t_historyCache = nil\n\t}()\n\n\ttx, err := _datastore.DB.Begin()\n\tif err != nil {\n\t\tlog.Errorln(\"error while setting message visibility\", err)\n\t\treturn nil\n\t}\n\n\tdefer tx.Rollback() // nolint\n\tquery := \"SELECT messages.id, user_id, body, title, subtitle, image, link, eventType, hidden_at, timestamp, display_name, display_color, created_at, disabled_at,  previous_names, namechanged_at, authenticated_at, scopes, type FROM messages INNER JOIN users ON messages.user_id = users.id WHERE user_id IS ?\"\n\n\tstmt, err := tx.Prepare(query)\n\tif err != nil {\n\t\tlog.Errorln(\"error while setting message visibility\", err)\n\t\treturn nil\n\t}\n\n\trows, err := stmt.Query(userID)\n\tif err != nil {\n\t\tlog.Errorln(\"error while setting message visibility\", err)\n\t\treturn nil\n\t}\n\n\tdefer stmt.Close()\n\tdefer rows.Close()\n\n\t// Get a list of IDs to send to the connected clients to hide\n\tids := make([]string, 0)\n\n\tmessages, err := getChat(rows)\n\n\tif err != nil {\n\t\tlog.Errorln(err)\n\t\tlog.Errorln(\"There is a problem enumerating chat message rows. Please report this:\", query)\n\t\treturn nil\n\t}\n\n\tif len(messages) == 0 {\n\t\treturn nil\n\t}\n\n\tfor _, message := range messages {\n\t\tids = append(ids, message.(events.UserMessageEvent).ID)\n\t}\n\n\tif err = tx.Commit(); err != nil {\n\t\tlog.Errorln(\"error while setting message visibility \", err)\n\t\treturn nil\n\t}\n\n\t// Tell the clients to hide/show these messages.\n\treturn SetMessagesVisibility(ids, visible)\n}\n\nfunc saveMessageVisibility(messageIDs []string, visible bool) error {\n\tdefer func() {\n\t\t_historyCache = nil\n\t}()\n\n\t_datastore.DbLock.Lock()\n\tdefer _datastore.DbLock.Unlock()\n\n\ttx, err := _datastore.DB.Begin()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// nolint:gosec\n\tstmt, err := tx.Prepare(\"UPDATE messages SET hidden_at=? WHERE id IN (?\" + strings.Repeat(\",?\", len(messageIDs)-1) + \")\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer stmt.Close()\n\n\tvar hiddenAt *time.Time\n\tif !visible {\n\t\tnow := time.Now()\n\t\thiddenAt = &now\n\t} else {\n\t\thiddenAt = nil\n\t}\n\n\targs := make([]interface{}, len(messageIDs)+1)\n\targs[0] = hiddenAt\n\tfor i, id := range messageIDs {\n\t\targs[i+1] = id\n\t}\n\n\tif _, err = stmt.Exec(args...); err != nil {\n\t\treturn err\n\t}\n\n\tif err = tx.Commit(); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n"], "filenames": ["core/chat/persistence.go"], "buggy_code_start_loc": [4], "buggy_code_end_loc": [320], "fixing_code_start_loc": [4], "fixing_code_end_loc": [417], "type": "CWE-89", "message": "SQL Injection in GitHub repository owncast/owncast prior to 0.0.13.", "other": {"cve": {"id": "CVE-2022-3751", "sourceIdentifier": "security@huntr.dev", "published": "2022-11-29T21:15:11.217", "lastModified": "2022-12-01T20:48:15.087", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "SQL Injection in GitHub repository owncast/owncast prior to 0.0.13."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:owncast_project:owncast:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.0.13", "matchCriteriaId": "684DD047-F3B9-4A01-88EE-29B6AF281651"}]}]}], "references": [{"url": "https://github.com/owncast/owncast/commit/23b6e5868d5501726c27a3fabbecf49000968591", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/a04cff99-5d53-45e5-a882-771b0fad62c9", "source": "security@huntr.dev", "tags": ["Permissions Required", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/owncast/owncast/commit/23b6e5868d5501726c27a3fabbecf49000968591"}}