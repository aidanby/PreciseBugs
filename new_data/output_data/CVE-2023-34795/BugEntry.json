{"buggy_code": ["0.2.34\r\n\r\n2022-11-02  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * PR from captaingroove tp add minizip-ng support (#115)\r\n\r\n0.2.33\r\n\r\n2022-07-05  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * PR from JackBoosY to export CMake targets automaticly (to cmake folder under install path) (#105)\r\n\r\n0.2.32\r\n\r\n2022-04-15  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * fixed crash issue when sheet name is NULL (#109)\r\n\r\n0.2.31\r\n\r\n2022-02-16  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * changed free() to xlsxioread_free() in example_xlsxio_read.c (issue #73)\r\n\r\n0.2.30\r\n\r\n2021-09-01  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * added .pc and .cmake file generation and installation to CMakeLists.txt\r\n\r\n2021-03-12  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * remove <AppVersion> tag from xlsxio_write.c and put version information in <Application> (issue #91)\r\n\r\n2021-03-11  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * fix CMakeLists.txt to generate and install pkg-config .pc files\r\n\r\n2020-12-29  Viest  https://github.com/viest\r\n\r\n  * added XLSXIOREAD_SKIP_HIDDEN_ROWS to xlsxio_read.h, skipping hidden rows is no longer the default setting\r\n  \r\n2020-12-29  akuhtr  https://github.com/akuhtr\r\n\r\n  * fixed example in README.md to use xlsxioread_free() instead of free()\r\n  \r\n2020-07-12  Remi Collet  https://github.com/remicollet\r\n\r\n  * added XLSXIO_VERSION_ID to xlsxio_version.h\r\n  \r\n0.2.29\r\n\r\n2020-07-10  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * only treat sheet as a table (with header rows) when XLSXIOREAD_SKIP_EXTRA_CELLS flag is used (issue #75)\r\n  * added xlsxioread_free() to fix crashes when calling library build with different compiler (issue #73)\r\n\r\n0.2.28\r\n\r\n2020-07-06  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * fixed issues with XLSXIOREAD_SKIP_EMPTY_CELLS/XLSXIOREAD_SKIP_EMPTY_ROWS/XLSXIOREAD_SKIP_ALL_EMPTY/XLSXIOREAD_SKIP_EXTRA_CELLS (issue #75)\r\n\r\n0.2.27\r\n\r\n2020-07-05  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * fixed issues with XLSXIOREAD_SKIP_EMPTY_CELLS/XLSXIOREAD_SKIP_EMPTY_ROWS/XLSXIOREAD_SKIP_ALL_EMPTY (issue #74)\r\n\r\n2020-05-08  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * changed Makefile to also generate .def files to be included in Windows packages\r\n\r\n2020-03-20  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * accepted patch (#63) to add xlsxioread_sheet_last_column_index() and xlsxioread_sheet_flags()\r\n  * when Doxygen is available HTML documentation is installed in {PREFIX}/share/xlsxio/html\r\n\r\n0.2.26\r\n\r\n2020-03-20  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * accepted patch (#63) to add xlsxioread_sheet_last_column_index() and xlsxioread_sheet_flags()\r\n  * added xlsxioread_sheet_last_row_index()\r\n\r\n0.2.25\r\n\r\n2020-03-20  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * fixed memory leaks in xlsxioread_sheet_next_cell_int/xlsxioread_sheet_next_cell_float/xlsxioread_sheet_next_cell_datetime (issue #54)\r\n  * added xml:space=\"preserve\" to text cells to preserve spacing (issue #57)\r\n  * ran valgrind tests on xlsxio_xlsx2csv and xlsxio_csv2xlsx\r\n  * fixed memory leak in write_cell_data() in xlsxio_write.c (result of get_A1col was not freed)\r\n  * rewrote get_A1col() in in xlsxio_write.c to avoid issues on platforms where multiple calls to va_start()/va_end() don't work\r\n\r\n0.2.24\r\n\r\n2020-03-19  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * fixed memory leak (missing free(data->basepath) in main_sheet_get_sheetfile_callback when sheet filename not found)\r\n  * added support for .xlsm, .xltx and .xltm files (thanks to coproc for suggesting this in issue #61)\r\n\r\n0.2.23\r\n\r\n2020-03-09  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * fixed missing #include <stdio.h> in xlsxio_read.c, needed for sscanf()\r\n  * fixed clang warning \"format string is not a string literal\" in xlsxio_write.c\r\n\r\n0.2.22\r\n\r\n2020-03-09  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * fixed CMakeLists.txt issue where BUILD_XLSXIO_DLL was also defined for static libraries\r\n  * added .travis.yml to allow building with Travis CI (on Linux)\r\n  * changes to xlsxio_write.c to support minizip2\r\n\r\n0.2.21\r\n\r\n2018-12-14  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * changes to xlsxio_read.c for better Microsoft Visual C++ support\r\n  * added generation and installation of .def files when building with MinGW (can be used to generate Microsoft Visual C++ .lib files)\r\n  * added information README.md about creating .lib files when using Microsoft Visual C++\r\n\r\n0.2.20\r\n\r\n2018-06-23  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * fixed join_basepath_filename in xlsx_read.c to also support absolute paths (issue reported by Matthew James Briggs)\r\n  * added CMake options to specify custom dependancy paths: ZLIB_DIR/MINIZIP_DIR/LIBZIP_DIR/EXPAT_DIR (requested by Yann Ducruy)\r\n\r\n0.2.19\r\n\r\n2018-06-18  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * fixed crash in xlsx_read.c when XML_Char_openzip is called with empty filename (crash reported by Matthew James Briggs)\r\n  \r\n2018-05-17  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * fixed memory allocation issue when using minizip version of xlsx_read\r\n\r\n0.2.18\r\n\r\n2018-04-27  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * fixed formatting issue with cell coordinates\r\n  \r\n0.2.17\r\n\r\n2018-03-22  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * fixed crash when trying to write to an existing .xlsx that is locked (e.g. opened in Excel)\r\n\r\n0.2.16\r\n\r\n2018-03-18  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * fixed formatting issue with cell coordinates\r\n  \r\n0.2.15\r\n\r\n2018-03-18  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * removed \"OPTIONAL_LINE_BREAK\" from sheet1.xml in libxlsxio_write\r\n  * fixed error when opening generated .xlsx files with Gnumeric (added row and cell coordinate references in sheet1.xml and cellStyleXfs in styles.xml)\r\n\r\n0.2.14\r\n\r\n2018-03-16  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * fixed Makefile issues, now properly builds with WIDE=1\r\n  * added build instructions to README.md\r\n  * added example code to README.md\r\n\r\n0.2.13\r\n\r\n2018-03-16  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * fixed hang on Windows when building release version with MinGW-64 (fixed by using stricmp instead of strcasecmp)\r\n  * added CMake option WITH_WIDE to build UTF-16 library (libxlsxio_readw) - experimental, only tested on Windows\r\n\r\n0.2.12\r\n\r\n2018-03-15  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * added support for minizip and made this the default instead of libzip\r\n  * xlsxioread_open_memory() parameter data is no longer const void* but void* to allow free()\r\n  * fixed Doxygen warnings\r\n  * fixed CMake issues with Windows static libraries\r\n\r\n2018-02-03  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * modified Makefile to support WIDE=1 parameter to build UTF-16 library (libxlsxio_readw)\r\n\r\n0.2.11\r\n\r\n2017-12-31  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * fixed CMakeLists.txt for proper DLL builds on Windows\r\n\r\n2017-11-28  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * fixed bug in XML_Char_poscpy when compiled for UTF-16 (thanks to https://github.com/dsmccall)\r\n\r\n2017-11-16  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * fixed minor memory leak whean cleaning up shared string list\r\n\r\n2017-11-11  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * added wchar_t support, requires building with -DXML_UNICODE and expat also built with -DXML_UNICODE\r\n  * fixed memory issue in xlsxioread_process()\r\n\r\n2017-11-09  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * added xlsxioread_open_filehandle() to read file using file descriptor\r\n\r\n0.2.10\r\n\r\n2017-10-31  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * added xlsxioread_open_memory() to read file from memory buffer\r\n  * fixed xlsxio_read_sharedstrings.c not being compiled in Makefile\r\n\r\n0.2.9\r\n\r\n2017-07-12  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * use strcasecmp instead of stricmp\r\n  * move shared strings functionality from xlsxio_read.c to seperate file\r\n\r\n0.2.8\r\n\r\n2016-10-24  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * skip issue where \"(null)\" is written if cell data is NULL\r\n  * limit sheet name to 31 characters\r\n\r\n0.2.7\r\n\r\n2016-09-03  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * skip phonetic data in <rPh> tag also in shared strings\r\n\r\n0.2.6\r\n\r\n2016-08-31  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * skip phonetic data in <rPh> tag (often used in Asian spreadsheets)\r\n\r\n0.2.5\r\n\r\n2016-06-28  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * fix reading data from cells with mixed formatting (thanks to bcTekGuy)\r\n\r\n2016-06-16  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * use correct formula for calculating column widths\r\n  * add -d parameter to xlsxio_csv2xlsx\r\n\r\n0.2.4\r\n\r\n2016-05-12  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * fixed crash in xlsxioread_sheetlist_close() when parameter is NULL\r\n\r\n0.2.3\r\n\r\n2016-05-11  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * fixed CMake build to use proper static/shared defines\r\n  * reintroduce DLL_EXPORT_XLSXIO in .c files except for Visual C\r\n\r\n0.2.2\r\n\r\n2016-05-07  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * fixed some compiler warnings\r\n  * only use DLL_EXPORT_XLSXIO in .h files (removed from .c files)\r\n\r\n0.2.1\r\n\r\n2016-05-05  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * added CMake BUILD_DOCUMENTATION option (defaults to ON if Doxygen is detected)\r\n  * workaround for missing stdint.h/unistd.h on Visual C \r\n  * removed -pthread when building for Apple\r\n  * released Windows binaries (32-bit and 64-bit)\r\n\r\n0.2.0\r\n\r\n2016-04-28  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * added CMake support and tested on multiple platforms:\r\n      + Windows 10 with MinGW compiler using MSYS shell\r\n      + Debian Linux 8.4\r\n      + OS X 10.11.3\r\n\r\n2016-04-25  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * added lastModifiedBy property (set to \"libxlsxio_write <version>\")\r\n\r\n2016-04-16  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * example C++ classes: XLSXIOWriter, XLSXIOReader, XLSXIOReaderSheet\r\n\r\n2016-04-11  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * added more comments in example files\r\n  * renamed the following for better naming consistency:\r\n      + XLSXIO_READ_NAME to XLSXIOREAD_NAME\r\n      + XLSXIO_READ_FULLNAME to XLSXIOREAD_FULLNAME\r\n      + XLSXIO_WRITE_NAME to XLSXIOWRITE_NAME\r\n      + XLSXIO_WRITE_FULLNAME to XLSXIOWRITE_FULLNAME\r\n  * added support to xlsxio_csv2xlsx to use - as standard input\r\n\r\n0.1.9\r\n\r\n2016-04-10  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * added xlsxio_csv2xlsx command line utility\r\n  * fixed warning in xlsxio_xlsx2csv when compiling with clang\r\n\r\n0.1.8\r\n\r\n2016-04-07  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * fixed issue with callback data pointer in row callback function\r\n  * added xlsxio_xlsx2csv command line utility\r\n\r\n0.1.7\r\n\r\n2016-03-28  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * changed integer type to int64_t in xlsxiowrite_add_cell_int() and xlsxioread_sheet_next_cell_int()\r\n\r\n0.1.6\r\n\r\n2016-03-24  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * delete destination file before writing to it\r\n  * fixed corruption issue when closing if no rows were written\r\n\r\n0.1.5\r\n\r\n2016-03-20  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * fixed issue with detecting witdh of columns with NULL data\r\n  * changed witdh detection to only count first line of multiline data\r\n  * fixed issue with inserting empty rows\r\n  * only freezes top row when columns were specified\r\n\r\n0.1.4\r\n\r\n2016-03-19  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * optimized code for writing cell data\r\n  * added witdh parameter to xlsxiowrite_add_column()\r\n  * added column witdh detection and xlsxiowrite_set_detection_rows()\r\n  * added xlsxiowrite_set_row_height()\r\n\r\n0.1.3\r\n\r\n2016-03-17  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * now reading ignores hidden rows\r\n  * added support for writing column names: xlsxiowrite_add_column()\r\n  * simplified xlsxio_write.c by using FILE* handles\r\n  * added sheetname parameter to xlsxiowrite_open()\r\n\r\n0.1.2\r\n\r\n2016-03-15  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n\t* added xlsxioread_sheetlist_ functions for getting worksheet names\r\n\t* fixed Excel error: \"That command cannot be used on multiple selections\"\r\n\t* use simpler folder structure inside .xlsx file\r\n\r\n0.1.1\r\n\r\n2016-03-13  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n\t* added header file with version information\r\n\t* additional functions for reading cells (integer, floating point, date/time)\r\n\r\n2016-03-12  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n\t* add support multiline text fields\r\n\t* set date/time value to proper display format\r\n\r\n2016-03-09  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n\t* add support for reading next row without having read all columns\r\n\t* additional functions for writing cells (integer, floating point, date/time)\r\n\t* added encoding of special XML characters in string data\r\n\r\n0.1.0\r\n\r\n2016-03-08  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n\t* initial release of working version\r\n", "/*****************************************************************************\r\nCopyright (C)  2016  Brecht Sanders  All Rights Reserved\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\nTHE SOFTWARE.\r\n*****************************************************************************/\r\n\r\n/**\r\n * @file xlsxio_version.h\r\n * @brief XLSX I/O header file with version information.\r\n * @author Brecht Sanders\r\n *\r\n * Only use this header file when version information is needed at compile\r\n * time. Otherwise the version functions in the libraries should be used.\r\n * \\sa     XLSXIO_VERSION_*\r\n * \\sa     XLSXIO_VERSION_STRING\r\n * \\sa     xlsxioread_get_version()\r\n * \\sa     xlsxioread_get_version_string()\r\n * \\sa     xlsxiowrite_get_version()\r\n * \\sa     xlsxiowrite_get_version_string()\r\n */\r\n\r\n#ifndef INCLUDED_XLSXIO_VERSION_H\r\n#define INCLUDED_XLSXIO_VERSION_H\r\n\r\n/*! \\brief version number constants\r\n * \\sa     xlsxioread_get_version()\r\n * \\sa     xlsxiowrite_get_version()\r\n * \\name   XLSXIO_VERSION_*\r\n * \\{\r\n */\r\n/*! \\brief major version number */\r\n#define XLSXIO_VERSION_MAJOR 0\r\n/*! \\brief minor version number */\r\n#define XLSXIO_VERSION_MINOR 2\r\n/*! \\brief micro version number */\r\n#define XLSXIO_VERSION_MICRO 34\r\n/*! @} */\r\n\r\n/*! \\cond PRIVATE */\r\n#ifndef XML_UNICODE_WCHAR_T\r\n#define XLSXIO_VERSION_STRINGIZE_(major, minor, micro) #major\".\"#minor\".\"#micro\r\n#else\r\n#define XLSXIO_VERSION_STRINGIZE_(major, minor, micro) L ## #major\".\"#minor\".\"#micro\r\n#endif\r\n#define XLSXIO_VERSION_STRINGIZE(major, minor, micro) XLSXIO_VERSION_STRINGIZE_(major, minor, micro)\r\n/*! \\endcond */\r\n\r\n/*! \\brief string with dotted version number \\hideinitializer */\r\n#define XLSXIO_VERSION_STRING XLSXIO_VERSION_STRINGIZE(XLSXIO_VERSION_MAJOR, XLSXIO_VERSION_MINOR, XLSXIO_VERSION_MICRO)\r\n\r\n/*! \\brief integer version of the library \\hideinitializer */\r\n#define XLSXIO_VERSION_ID (XLSXIO_VERSION_MAJOR * 10000 + XLSXIO_VERSION_MINOR * 100 + XLSXIO_VERSION_MICRO)\r\n\r\n/*! \\brief string with name of XLSX I/O reading library */\r\n#define XLSXIOREAD_NAME \"libxlsxio_read\"\r\n/*! \\brief string with name of XLSX I/O writing library */\r\n#define XLSXIOWRITE_NAME \"libxlsxio_write\"\r\n\r\n/*! \\brief string with name and version of XLSX I/O reading library \\hideinitializer */\r\n#define XLSXIOREAD_FULLNAME XLSXIOREAD_NAME \" \" XLSXIO_VERSION_STRING\r\n/*! \\brief string with name and version of XLSX I/O writing library \\hideinitializer */\r\n#define XLSXIOWRITE_FULLNAME XLSXIOWRITE_NAME \" \" XLSXIO_VERSION_STRING\r\n\r\n#endif\r\n", "#include \"xlsxio_private.h\"\r\n#include \"xlsxio_read_sharedstrings.h\"\r\n#include \"xlsxio_read.h\"\r\n#include \"xlsxio_version.h\"\r\n#include <stdlib.h>\r\n#include <stdio.h>\r\n#include <inttypes.h>\r\n#include <string.h>\r\n#include <expat.h>\r\n\r\n#if defined(USE_MINIZIP) || defined(USE_MINIZIP_NG)\r\n#  ifdef USE_MINIZIP_NG\r\n#    include <mz_compat.h>\r\n#  else\r\n#    include <minizip/unzip.h>\r\n#  endif\r\n#  define ZIPFILETYPE unzFile\r\n#  define ZIPFILEENTRYTYPE unzFile\r\n#  if defined(_MSC_VER)\r\n#    include <io.h>\r\n#    define IOSIZETYPE int\r\n#    define IOFN(fn) _##fn\r\n#  else\r\n#    include <unistd.h>\r\n#    define IOSIZETYPE ssize_t\r\n#    define IOFN(fn) fn\r\n#  endif\r\n\r\n#  if defined(MZ_COMPRESS_METHOD_DEFLATE) // support minizip2 which defines MZ_COMPRESS_METHOD_DEFLATE instead of Z_DEFLATED\r\n#    ifndef ZCALLBACK\r\n#      define ZCALLBACK\r\n#    endif\r\n#    define voidpf void*\r\n#    define uLong  unsigned long\r\n#  endif\r\n\r\n#else\r\n#  if (defined(STATIC) || defined(BUILD_XLSXIO_STATIC) || defined(BUILD_XLSXIO_STATIC_DLL) || (defined(BUILD_XLSXIO) && !defined(BUILD_XLSXIO_DLL) && !defined(BUILD_XLSXIO_SHARED))) && !defined(ZIP_STATIC)\r\n#    define ZIP_STATIC\r\n#  endif\r\n#  include <zip.h>\r\n#  define ZIPFILETYPE zip_t\r\n#  define ZIPFILEENTRYTYPE zip_file_t\r\n#  ifndef USE_LIBZIP\r\n#    define USE_LIBZIP\r\n#  endif\r\n#endif\r\n\r\n#if defined(_MSC_VER)\r\n#  undef DLL_EXPORT_XLSXIO\r\n#  define DLL_EXPORT_XLSXIO\r\n#endif\r\n\r\n#define PARSE_BUFFER_SIZE 256\r\n//#define PARSE_BUFFER_SIZE 4\r\n\r\nstatic const XLSXIOCHAR* xlsx_content_type = X(\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml\");\r\nstatic const XLSXIOCHAR* xlsm_content_type = X(\"application/vnd.ms-excel.sheet.macroEnabled.main+xml\");\r\nstatic const XLSXIOCHAR* xltx_content_type = X(\"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml\");\r\nstatic const XLSXIOCHAR* xltm_content_type = X(\"application/vnd.ms-excel.template.macroEnabled.main+xml\");\r\n\r\n#if !defined(XML_UNICODE_WCHAR_T) && !defined(XML_UNICODE)\r\n\r\n//UTF-8 version\r\n#define XML_Char_dupchar strdup\r\n\r\nstatic ZIPFILEENTRYTYPE* XML_Char_openzip (ZIPFILETYPE* archive, const XML_Char* filename, int flags)\r\n{\r\n  if (!filename || !*filename)\r\n    return NULL;\r\n#ifdef USE_MINIZIP\r\n  if (unzLocateFile(archive, filename, 0) != UNZ_OK)\r\n    return NULL;\r\n  if (unzOpenCurrentFile(archive) != UNZ_OK)\r\n    return NULL;\r\n  return archive;\r\n#else\r\n  return zip_fopen(archive, filename, flags);\r\n#endif\r\n}\r\n\r\n#else\r\n\r\n//UTF-16 version\r\nstatic XML_Char* XML_Char_dupchar(const char* s)\r\n{\r\n  size_t len;\r\n  XML_Char* result;\r\n  if (!s || (len = mbstowcs(NULL, s, 0)) < 0)\r\n    return NULL;\r\n  if ((result = XML_Char_malloc(len + 1)) != NULL) {\r\n    if ((mbstowcs(result, s, len + 1) != len)) {\r\n      free(result);\r\n      return NULL;\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\nstatic char* chardupXML_Char(const XML_Char* s)\r\n{\r\n  size_t len;\r\n  char* result;\r\n  if (!s || (len = wcstombs(NULL, s, 0)) == -1)\r\n    return NULL;\r\n  if ((result = (char*)malloc(len + 1)) != NULL) {\r\n    if ((wcstombs(result, s, len + 1) != len)) {\r\n      free(result);\r\n      return NULL;\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\nstatic ZIPFILEENTRYTYPE* XML_Char_openzip (ZIPFILETYPE* archive, const XML_Char* filename, int flags)\r\n{\r\n  ZIPFILEENTRYTYPE* result;\r\n  char* s;\r\n  if (!filename || !*filename)\r\n    return NULL;\r\n  if ((s = chardupXML_Char(filename)) == NULL)\r\n    return NULL;\r\n#ifdef USE_MINIZIP\r\n  if (unzLocateFile(archive, s, 0) != UNZ_OK)\r\n    result = NULL;\r\n  else if (unzOpenCurrentFile(archive) != UNZ_OK)\r\n    result = NULL;\r\n  else\r\n    result = archive;\r\n#else\r\n  result = zip_fopen(archive, s, flags);\r\n#endif\r\n  free(s);\r\n  return result;\r\n}\r\n\r\n#endif\r\n\r\n\r\nDLL_EXPORT_XLSXIO void xlsxioread_get_version (int* pmajor, int* pminor, int* pmicro)\r\n{\r\n  if (pmajor)\r\n    *pmajor = XLSXIO_VERSION_MAJOR;\r\n  if (pminor)\r\n    *pminor = XLSXIO_VERSION_MINOR;\r\n  if (pmicro)\r\n    *pmicro = XLSXIO_VERSION_MICRO;\r\n}\r\n\r\nDLL_EXPORT_XLSXIO const XLSXIOCHAR* xlsxioread_get_version_string ()\r\n{\r\n  return (const XLSXIOCHAR*)XLSXIO_VERSION_STRING;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////\r\n\r\n//process XML file contents\r\nint expat_process_zip_file (ZIPFILETYPE* zip, const XML_Char* filename, XML_StartElementHandler start_handler, XML_EndElementHandler end_handler, XML_CharacterDataHandler data_handler, void* callbackdata, XML_Parser* xmlparser)\r\n{\r\n  ZIPFILEENTRYTYPE* zipfile;\r\n  XML_Parser parser;\r\n  void* buf;\r\n#ifdef USE_MINIZIP\r\n  int buflen;\r\n#else\r\n  zip_int64_t buflen;\r\n#endif\r\n  int done;\r\n  enum XML_Status status = XML_STATUS_ERROR;\r\n  if ((zipfile = XML_Char_openzip(zip, filename, 0)) == NULL) {\r\n    return -1;\r\n  }\r\n  parser = XML_ParserCreate(NULL);\r\n  XML_SetUserData(parser, callbackdata);\r\n  XML_SetElementHandler(parser, start_handler, end_handler);\r\n  XML_SetCharacterDataHandler(parser, data_handler);\r\n  if (xmlparser)\r\n    *xmlparser = parser;\r\n  buf = XML_GetBuffer(parser, PARSE_BUFFER_SIZE);\r\n#ifdef USE_MINIZIP\r\n    while (buf && (buflen = unzReadCurrentFile(zip, buf, PARSE_BUFFER_SIZE)) >= 0) {\r\n#else\r\n    while (buf && (buflen = zip_fread(zipfile, buf, PARSE_BUFFER_SIZE)) >= 0) {\r\n#endif\r\n      done = buflen < PARSE_BUFFER_SIZE;\r\n      if ((status = XML_ParseBuffer(parser, (int)buflen, (done ? 1 : 0))) == XML_STATUS_ERROR) {\r\n        break;\r\n      }\r\n      if (xmlparser && status == XML_STATUS_SUSPENDED)\r\n        return 0;\r\n      if (done)\r\n        break;\r\n      buf = XML_GetBuffer(parser, PARSE_BUFFER_SIZE);\r\n    }\r\n  XML_ParserFree(parser);\r\n#ifdef USE_MINIZIP\r\n  unzCloseCurrentFile(zip);\r\n#else\r\n  zip_fclose(zipfile);\r\n#endif\r\n  //return (status == XML_STATUS_ERROR != XML_ERROR_FINISHED ? 1 : 0);\r\n  return 0;\r\n}\r\n\r\nXML_Parser expat_process_zip_file_suspendable (ZIPFILEENTRYTYPE* zipfile, XML_StartElementHandler start_handler, XML_EndElementHandler end_handler, XML_CharacterDataHandler data_handler, void* callbackdata)\r\n{\r\n  XML_Parser result;\r\n  if ((result = XML_ParserCreate(NULL)) != NULL) {\r\n    XML_SetUserData(result, callbackdata);\r\n    XML_SetElementHandler(result, start_handler, end_handler);\r\n    XML_SetCharacterDataHandler(result, data_handler);\r\n  }\r\n  return result;\r\n}\r\n\r\nenum XML_Status expat_process_zip_file_resume (ZIPFILEENTRYTYPE* zipfile, XML_Parser xmlparser)\r\n{\r\n  enum XML_Status status;\r\n  status = XML_ResumeParser(xmlparser);\r\n  if (status == XML_STATUS_SUSPENDED)\r\n    return status;\r\n  if (status == XML_STATUS_ERROR && XML_GetErrorCode(xmlparser) != XML_ERROR_NOT_SUSPENDED)\r\n    return status;\r\n  void* buf;\r\n#ifdef USE_MINIZIP\r\n  int buflen;\r\n#else\r\n  zip_int64_t buflen;\r\n#endif\r\n  int done;\r\n  buf = XML_GetBuffer(xmlparser, PARSE_BUFFER_SIZE);\r\n#ifdef USE_MINIZIP\r\n  while (buf && (buflen = unzReadCurrentFile(zipfile, buf, PARSE_BUFFER_SIZE)) >= 0) {\r\n#else\r\n  while (buf && (buflen = zip_fread(zipfile, buf, PARSE_BUFFER_SIZE)) >= 0) {\r\n#endif\r\n    done = buflen < PARSE_BUFFER_SIZE;\r\n    if ((status = XML_ParseBuffer(xmlparser, (int)buflen, (done ? 1 : 0))) == XML_STATUS_ERROR)\r\n      return status;\r\n    if (status == XML_STATUS_SUSPENDED)\r\n      return status;\r\n    if (done)\r\n      break;\r\n    buf = XML_GetBuffer(xmlparser, PARSE_BUFFER_SIZE);\r\n  }\r\n  //XML_ParserFree(xmlparser);\r\n  return status;\r\n}\r\n\r\n//compare XML name ignoring case and ignoring namespace (returns 0 on match)\r\n#ifdef ASSUME_NO_NAMESPACE\r\n#define XML_Char_icmp_ins XML_Char_icmp\r\n#else\r\nint XML_Char_icmp_ins (const XML_Char* value, const XML_Char* name)\r\n{\r\n  size_t valuelen;\r\n  size_t namelen;\r\n  if (!value)\r\n    return (!name ? 0 : -1);\r\n  if (!name)\r\n    return -1;\r\n  valuelen = XML_Char_len(value);\r\n  namelen = XML_Char_len(name);\r\n  if (valuelen == namelen)\r\n    return XML_Char_icmp(value, name);\r\n  if (valuelen > namelen) {\r\n    if (value[valuelen - namelen - 1] != ':')\r\n      return 1;\r\n    return XML_Char_icmp(value + (valuelen - namelen), name);\r\n  }\r\n  return -1;\r\n}\r\n#endif\r\n\r\n//get expat attribute by name, returns NULL if not found\r\nconst XML_Char* get_expat_attr_by_name (const XML_Char** atts, const XML_Char* name)\r\n{\r\n  const XML_Char** p = atts;\r\n  if (p) {\r\n    while (*p) {\r\n      //if (XML_Char_icmp(*p++, name) == 0)\r\n      if (XML_Char_icmp_ins(*p++, name) == 0)\r\n        return *p;\r\n      p++;\r\n    }\r\n  }\r\n  return NULL;\r\n}\r\n\r\n//generate .rels filename, returns NULL on error, caller must free result\r\nXML_Char* get_relationship_filename (const XML_Char* filename)\r\n{\r\n  XML_Char* result;\r\n  size_t filenamelen = XML_Char_len(filename);\r\n  if ((result = XML_Char_malloc(filenamelen + 12)) != NULL) {\r\n    size_t i = filenamelen;\r\n    while (i > 0) {\r\n      if (filename[i - 1] == '/')\r\n        break;\r\n      i--;\r\n    }\r\n    XML_Char_poscpy(result, 0, filename, i);\r\n    XML_Char_poscpy(result, i, X(\"_rels/\"), 6);\r\n    XML_Char_poscpy(result, i + 6, filename + i, filenamelen - i);\r\n    XML_Char_poscpy(result, filenamelen + 6, X(\".rels\"), 6);\r\n  }\r\n  return result;\r\n}\r\n\r\n//join basepath and filename (caller must free result)\r\nXML_Char* join_basepath_filename (const XML_Char* basepath, const XML_Char* filename)\r\n{\r\n  XML_Char* result = NULL;\r\n  if (filename && *filename) {\r\n    if (filename[0] == '/' && filename[1]) {\r\n      //file is absolute: remove leading slash\r\n      result = XML_Char_dup(filename + 1);\r\n    } else {\r\n      //file is relative: prepend base path\r\n      size_t basepathlen = (basepath ? XML_Char_len(basepath) : 0);\r\n      size_t filenamelen = XML_Char_len(filename);\r\n      if ((result = XML_Char_malloc(basepathlen + filenamelen + 1)) != NULL) {\r\n        if (basepathlen > 0)\r\n          XML_Char_poscpy(result, 0, basepath, basepathlen);\r\n        XML_Char_poscpy(result, basepathlen, filename, filenamelen);\r\n        result[basepathlen + filenamelen] = 0;\r\n      }\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\n//determine column number based on cell coordinate (e.g. \"A1\"), returns 1-based column number or 0 on error\r\nsize_t get_col_nr (const XML_Char* A1col)\r\n{\r\n  const XML_Char* p = A1col;\r\n  size_t result = 0;\r\n  if (p) {\r\n    while (*p) {\r\n      if (*p >= 'A' && *p <= 'Z')\r\n        result = result * 26 + (*p - 'A') + 1;\r\n      else if (*p >= 'a' && *p <= 'z')\r\n        result = result * 26 + (*p - 'a') + 1;\r\n      else if (*p >= '0' && *p <= '9' && p != A1col)\r\n        return result;\r\n      else\r\n        break;\r\n      p++;\r\n    }\r\n  }\r\n  return 0;\r\n}\r\n\r\n//determine row number based on cell coordinate (e.g. \"A1\"), returns 1-based row number or 0 on error\r\nsize_t get_row_nr (const XML_Char* A1col)\r\n{\r\n  const XML_Char* p = A1col;\r\n  size_t result = 0;\r\n  if (p) {\r\n    while (*p) {\r\n      if ((*p >= 'A' && *p <= 'Z') || (*p >= 'a' && *p <= 'z'))\r\n        ;\r\n      else if (*p >= '0' && *p <= '9' && p != A1col)\r\n        result = result * 10 + (*p - '0');\r\n      else\r\n        return 0;\r\n      p++;\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////\r\n\r\nstruct xlsxio_read_struct {\r\n  ZIPFILETYPE* zip;\r\n};\r\n\r\nDLL_EXPORT_XLSXIO xlsxioreader xlsxioread_open (const char* filename)\r\n{\r\n  xlsxioreader result;\r\n  if ((result = (xlsxioreader)malloc(sizeof(struct xlsxio_read_struct))) != NULL) {\r\n#ifdef USE_MINIZIP\r\n    if ((result->zip = unzOpen(filename)) == NULL) {\r\n#else\r\n    if ((result->zip = zip_open(filename, ZIP_RDONLY, NULL)) == NULL) {\r\n#endif\r\n      free(result);\r\n      return NULL;\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\n#ifdef USE_MINIZIP\r\nstruct minizip_io_filehandle_data {\r\n  int filehandle;\r\n};\r\n\r\nvoidpf ZCALLBACK minizip_io_filehandle_open_file_fn (voidpf opaque, const char* filename, int mode)\r\n{\r\n  if (!opaque || ((struct minizip_io_filehandle_data*)opaque)->filehandle < 0)\r\n    return NULL;\r\n  return &((struct minizip_io_filehandle_data*)opaque)->filehandle;\r\n}\r\n\r\nuLong ZCALLBACK minizip_io_filehandle_read_file_fn (voidpf opaque, voidpf stream, void* buf, uLong size)\r\n{\r\n  IOSIZETYPE len;\r\n  if (!opaque || !stream || !buf || size == 0)\r\n    return 0;\r\n  if ((len = IOFN(read)(*(int*)stream, buf, size)) < 0)\r\n    return 0;\r\n  return len;\r\n}\r\n\r\n/*\r\nuLong ZCALLBACK minizip_io_filehandle_write_file_fn (voidpf opaque, voidpf stream, const void* buf, uLong size)\r\n{\r\n  return 0;\r\n}\r\n*/\r\n\r\nint ZCALLBACK minizip_io_filehandle_close_file_fn (voidpf opaque, voidpf stream)\r\n{\r\n  if (stream)\r\n    close(*(int*)stream);\r\n  free(opaque);\r\n  return 0;\r\n}\r\n\r\nint ZCALLBACK minizip_io_filehandle_testerror_file_fn (voidpf opaque, voidpf stream)\r\n{\r\n  return 0;\r\n}\r\n\r\nlong ZCALLBACK minizip_io_filehandle_tell_file_fn (voidpf opaque, voidpf stream)\r\n{\r\n  return IOFN(lseek)(*(int*)stream, 0, SEEK_CUR);\r\n}\r\n\r\nlong ZCALLBACK minizip_io_filehandle_seek_file_fn (voidpf opaque, voidpf stream, uLong offset, int origin)\r\n{\r\n  int whence;\r\n  if (!opaque || !stream)\r\n    return -1;\r\n  switch (origin) {\r\n    case ZLIB_FILEFUNC_SEEK_CUR :\r\n      whence = SEEK_CUR;\r\n      break;\r\n    case ZLIB_FILEFUNC_SEEK_END :\r\n      whence = SEEK_END;\r\n      break;\r\n    case ZLIB_FILEFUNC_SEEK_SET :\r\n      whence = SEEK_SET;\r\n      break;\r\n    default :\r\n      return -1;\r\n  }\r\n  return (IOFN(lseek)(*(int*)stream, offset, whence) >= 0 ? 0 : -1);\r\n}\r\n#endif\r\n\r\nDLL_EXPORT_XLSXIO xlsxioreader xlsxioread_open_filehandle (int filehandle)\r\n{\r\n  xlsxioreader result;\r\n  if ((result = (xlsxioreader)malloc(sizeof(struct xlsxio_read_struct))) != NULL) {\r\n#ifdef USE_MINIZIP\r\n    zlib_filefunc_def minizip_io_filehandle_functions;\r\n    if ((minizip_io_filehandle_functions.opaque = malloc(sizeof(struct minizip_io_filehandle_data))) == NULL) {\r\n      free(result);\r\n      return NULL;\r\n    }\r\n    minizip_io_filehandle_functions.zopen_file = minizip_io_filehandle_open_file_fn;\r\n    minizip_io_filehandle_functions.zread_file = minizip_io_filehandle_read_file_fn;\r\n    minizip_io_filehandle_functions.zwrite_file = /*minizip_io_filehandle_write_file_fn*/NULL;\r\n    minizip_io_filehandle_functions.ztell_file = minizip_io_filehandle_tell_file_fn;\r\n    minizip_io_filehandle_functions.zseek_file = minizip_io_filehandle_seek_file_fn;\r\n    minizip_io_filehandle_functions.zclose_file = minizip_io_filehandle_close_file_fn;\r\n    minizip_io_filehandle_functions.zerror_file = minizip_io_filehandle_testerror_file_fn;\r\n    ((struct minizip_io_filehandle_data*)minizip_io_filehandle_functions.opaque)->filehandle = filehandle;\r\n    if ((result->zip = unzOpen2(NULL, &minizip_io_filehandle_functions)) == NULL) {\r\n      free(result);\r\n      return NULL;\r\n    }\r\n#else\r\n    if ((result->zip = zip_fdopen(filehandle, ZIP_RDONLY, NULL)) == NULL) {\r\n      free(result);\r\n      return NULL;\r\n    }\r\n#endif\r\n  }\r\n  return result;\r\n}\r\n\r\n#ifdef USE_MINIZIP\r\nstruct minizip_io_memory_data {\r\n  void* data;\r\n  uint64_t datalen;\r\n  int freedata;\r\n};\r\n\r\nstruct minizip_io_memory_handle {\r\n  uint64_t pos;\r\n};\r\n\r\nvoidpf ZCALLBACK minizip_io_memory_open_file_fn (voidpf opaque, const char* filename, int mode)\r\n{\r\n  struct minizip_io_memory_handle* result;\r\n  if (!opaque || !((struct minizip_io_memory_data*)opaque)->data)\r\n    return NULL;\r\n  if ((result = (struct minizip_io_memory_handle*)malloc(sizeof(struct minizip_io_memory_handle))) != NULL) {\r\n    result->pos = 0;\r\n  }\r\n  return result;\r\n}\r\n\r\nuLong ZCALLBACK minizip_io_memory_read_file_fn (voidpf opaque, voidpf stream, void* buf, uLong size)\r\n{\r\n  uLong len;\r\n  if (!opaque || !stream || !buf || size == 0)\r\n    return 0;\r\n  if (((struct minizip_io_memory_handle*)stream)->pos + size <= ((struct minizip_io_memory_data*)opaque)->datalen)\r\n    len = size;\r\n  else\r\n    len = ((struct minizip_io_memory_data*)opaque)->datalen - ((struct minizip_io_memory_handle*)stream)->pos;\r\n  memcpy(buf, (char *)(((struct minizip_io_memory_data*)opaque)->data) + ((struct minizip_io_memory_handle*)stream)->pos, len);\r\n  ((struct minizip_io_memory_handle*)stream)->pos += len;\r\n  return len;\r\n}\r\n\r\n/*\r\nuLong ZCALLBACK minizip_io_memory_write_file_fn (voidpf opaque, voidpf stream, const void* buf, uLong size)\r\n{\r\n  return 0;\r\n}\r\n*/\r\n\r\nint ZCALLBACK minizip_io_memory_close_file_fn (voidpf opaque, voidpf stream)\r\n{\r\n  free(stream);\r\n  if (opaque && ((struct minizip_io_memory_data*)opaque)->freedata)\r\n    free(((struct minizip_io_memory_data*)opaque)->data);\r\n  free(opaque);\r\n  return 0;\r\n}\r\n\r\nint ZCALLBACK minizip_io_memory_testerror_file_fn (voidpf opaque, voidpf stream)\r\n{\r\n  return 0;\r\n}\r\n\r\nlong ZCALLBACK minizip_io_memory_tell_file_fn (voidpf opaque, voidpf stream)\r\n{\r\n  if (!opaque || !stream)\r\n    return 0;\r\n  return ((struct minizip_io_memory_handle*)stream)->pos;\r\n}\r\n\r\nlong ZCALLBACK minizip_io_memory_seek_file_fn (voidpf opaque, voidpf stream, uLong offset, int origin)\r\n{\r\n  switch (origin) {\r\n    case ZLIB_FILEFUNC_SEEK_CUR :\r\n      /*if (offset < 0) {\r\n        if (((struct minizip_io_memory_handle*)stream)->pos < -offset)\r\n          ((struct minizip_io_memory_handle*)stream)->pos = 0;\r\n        else\r\n          ((struct minizip_io_memory_handle*)stream)->pos += offset;\r\n      } else*/ {\r\n        if (((struct minizip_io_memory_handle*)stream)->pos + offset > ((struct minizip_io_memory_data*)opaque)->datalen)\r\n          ((struct minizip_io_memory_handle*)stream)->pos = ((struct minizip_io_memory_data*)opaque)->datalen;\r\n        else\r\n          ((struct minizip_io_memory_handle*)stream)->pos += offset;\r\n      }\r\n      break;\r\n    case ZLIB_FILEFUNC_SEEK_END :\r\n      /*if (offset < 0) {\r\n        if (((struct minizip_io_memory_data*)opaque)->datalen < -offset)\r\n          ((struct minizip_io_memory_handle*)stream)->pos = 0;\r\n        else\r\n          ((struct minizip_io_memory_handle*)stream)->pos = ((struct minizip_io_memory_data*)opaque)->datalen + offset;\r\n      } else*/ {\r\n        ((struct minizip_io_memory_handle*)stream)->pos = ((struct minizip_io_memory_data*)opaque)->datalen;\r\n      }\r\n      break;\r\n    case ZLIB_FILEFUNC_SEEK_SET :\r\n      /*if (offset < 0) {\r\n        ((struct minizip_io_memory_handle*)stream)->pos = 0;\r\n      } else*/ {\r\n        if (offset > ((struct minizip_io_memory_data*)opaque)->datalen)\r\n          ((struct minizip_io_memory_handle*)stream)->pos = ((struct minizip_io_memory_data*)opaque)->datalen;\r\n        else\r\n          ((struct minizip_io_memory_handle*)stream)->pos = offset;\r\n      }\r\n      ((struct minizip_io_memory_handle*)stream)->pos = offset;\r\n      break;\r\n    default :\r\n      return -1;\r\n  }\r\n  return 0;\r\n}\r\n#endif\r\n\r\nDLL_EXPORT_XLSXIO xlsxioreader xlsxioread_open_memory (void* data, uint64_t datalen, int freedata)\r\n{\r\n  xlsxioreader result;\r\n#ifdef USE_MINIZIP\r\n  if ((result = (xlsxioreader)malloc(sizeof(struct xlsxio_read_struct))) != NULL) {\r\n    zlib_filefunc_def minizip_io_memory_functions;\r\n    if ((minizip_io_memory_functions.opaque = malloc(sizeof(struct minizip_io_memory_data))) == NULL) {\r\n      free(result);\r\n      return NULL;\r\n    }\r\n    minizip_io_memory_functions.zopen_file = minizip_io_memory_open_file_fn;\r\n    minizip_io_memory_functions.zread_file = minizip_io_memory_read_file_fn;\r\n    minizip_io_memory_functions.zwrite_file = /*minizip_io_memory_write_file_fn*/NULL;\r\n    minizip_io_memory_functions.ztell_file = minizip_io_memory_tell_file_fn;\r\n    minizip_io_memory_functions.zseek_file = minizip_io_memory_seek_file_fn;\r\n    minizip_io_memory_functions.zclose_file = minizip_io_memory_close_file_fn;\r\n    minizip_io_memory_functions.zerror_file = minizip_io_memory_testerror_file_fn;\r\n    ((struct minizip_io_memory_data*)minizip_io_memory_functions.opaque)->data = data;\r\n    ((struct minizip_io_memory_data*)minizip_io_memory_functions.opaque)->datalen = datalen;\r\n    ((struct minizip_io_memory_data*)minizip_io_memory_functions.opaque)->freedata = freedata;\r\n    if ((result->zip = unzOpen2(NULL, &minizip_io_memory_functions)) == NULL) {\r\n      free(result);\r\n      return NULL;\r\n    }\r\n  }\r\n#else\r\n  zip_source_t* zipsrc;\r\n  if ((zipsrc = zip_source_buffer_create(data, datalen, freedata, NULL)) == NULL) {\r\n    return NULL;\r\n  }\r\n  if ((result = (xlsxioreader)malloc(sizeof(struct xlsxio_read_struct))) != NULL) {\r\n    if ((result->zip = zip_open_from_source(zipsrc, ZIP_RDONLY, NULL)) == NULL) {\r\n      zip_source_free(zipsrc);\r\n      free(result);\r\n      return NULL;\r\n    }\r\n  }\r\n#endif\r\n  return result;\r\n}\r\n\r\nDLL_EXPORT_XLSXIO void xlsxioread_close (xlsxioreader handle)\r\n{\r\n  if (handle) {\r\n    //note: no need to call zip_source_free() after successful use in zip_open_from_source()\r\n#ifdef USE_MINIZIP\r\n    unzClose(handle->zip);\r\n#else\r\n    zip_close(handle->zip);\r\n#endif\r\n    free(handle);\r\n  }\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////\r\n\r\n//callback function definition for use with iterate_files_by_contenttype\r\ntypedef void (*contenttype_file_callback_fn)(ZIPFILETYPE* zip, const XML_Char* filename, const XML_Char* contenttype, void* callbackdata);\r\n\r\nstruct iterate_files_by_contenttype_callback_data {\r\n  ZIPFILETYPE* zip;\r\n  const XML_Char* contenttype;\r\n  contenttype_file_callback_fn filecallbackfn;\r\n  void* filecallbackdata;\r\n};\r\n\r\n//expat callback function for element start used by iterate_files_by_contenttype\r\nvoid iterate_files_by_contenttype_expat_callback_element_start (void* callbackdata, const XML_Char* name, const XML_Char** atts)\r\n{\r\n  struct iterate_files_by_contenttype_callback_data* data = (struct iterate_files_by_contenttype_callback_data*)callbackdata;\r\n  if (XML_Char_icmp_ins(name, X(\"Override\")) == 0) {\r\n    //explicitly specified file\r\n    const XML_Char* contenttype;\r\n    const XML_Char* partname;\r\n    if ((contenttype = get_expat_attr_by_name(atts, X(\"ContentType\"))) != NULL && XML_Char_icmp(contenttype, data->contenttype) == 0) {\r\n      if ((partname = get_expat_attr_by_name(atts, X(\"PartName\"))) != NULL) {\r\n        if (partname[0] == '/')\r\n          partname++;\r\n        data->filecallbackfn(data->zip, partname, contenttype, data->filecallbackdata);\r\n      }\r\n    }\r\n  } else if (XML_Char_icmp_ins(name, X(\"Default\")) == 0) {\r\n    //by extension\r\n    const XML_Char* contenttype;\r\n    const XML_Char* extension;\r\n    if ((contenttype = get_expat_attr_by_name(atts, X(\"ContentType\"))) != NULL && XML_Char_icmp(contenttype, data->contenttype) == 0) {\r\n      if ((extension = get_expat_attr_by_name(atts, X(\"Extension\"))) != NULL) {\r\n        XML_Char* filename;\r\n        size_t filenamelen;\r\n        size_t extensionlen = XML_Char_len(extension);\r\n#ifdef USE_MINIZIP\r\n#define UNZIP_FILENAME_BUFFER_STEP 32\r\n        char* buf;\r\n        size_t buflen;\r\n        int status;\r\nunz_global_info zipglobalinfo;\r\nunzGetGlobalInfo(data->zip, &zipglobalinfo);\r\n        buf = (char*)malloc(buflen = UNZIP_FILENAME_BUFFER_STEP);\r\n        status = unzGoToFirstFile(data->zip);\r\n        while (status == UNZ_OK) {\r\n          buf[buflen - 1] = 0;\r\n          while ((status = unzGetCurrentFileInfo(data->zip, NULL, buf, buflen, NULL, 0, NULL, 0)) == UNZ_OK && buf[buflen - 1] != 0) {\r\n            buflen += UNZIP_FILENAME_BUFFER_STEP;\r\n            buf = (char*)realloc(buf, buflen);\r\n            buf[buflen - 1] = 0;\r\n          }\r\n          if (status != UNZ_OK)\r\n            break;\r\n          filename = XML_Char_dupchar(buf);\r\n          status = unzGoToNextFile(data->zip);\r\n#else\r\n        zip_int64_t i;\r\n        zip_int64_t zipnumfiles = zip_get_num_entries(data->zip, 0);\r\n        for (i = 0; i < zipnumfiles; i++) {\r\n          filename = XML_Char_dupchar(zip_get_name(data->zip, i, ZIP_FL_ENC_GUESS));\r\n#endif\r\n          filenamelen = XML_Char_len(filename);\r\n          if (filenamelen > extensionlen && filename[filenamelen - extensionlen - 1] == '.' && XML_Char_icmp(filename + filenamelen - extensionlen, extension) == 0) {\r\n            data->filecallbackfn(data->zip, filename, contenttype, data->filecallbackdata);\r\n          }\r\n          free(filename);\r\n        }\r\n#ifdef USE_MINIZIP\r\n        free(buf);\r\n#endif\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n//list file names by content type\r\nint iterate_files_by_contenttype (ZIPFILETYPE* zip, const XML_Char* contenttype, contenttype_file_callback_fn filecallbackfn, void* filecallbackdata, XML_Parser* xmlparser)\r\n{\r\n  struct iterate_files_by_contenttype_callback_data callbackdata = {\r\n    .zip = zip,\r\n    .contenttype = contenttype,\r\n    .filecallbackfn = filecallbackfn,\r\n    .filecallbackdata = filecallbackdata\r\n  };\r\n  return expat_process_zip_file(zip, X(\"[Content_Types].xml\"), iterate_files_by_contenttype_expat_callback_element_start, NULL, NULL, &callbackdata, xmlparser);\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////\r\n\r\n//callback structure used by main_sheet_list_expat_callback_element_start\r\nstruct main_sheet_list_callback_data {\r\n  XML_Parser xmlparser;\r\n  xlsxioread_list_sheets_callback_fn callback;\r\n  void* callbackdata;\r\n};\r\n\r\n//callback used by xlsxioread_list_sheets\r\nvoid main_sheet_list_expat_callback_element_start (void* callbackdata, const XML_Char* name, const XML_Char** atts)\r\n{\r\n  struct main_sheet_list_callback_data* data = (struct main_sheet_list_callback_data*)callbackdata;\r\n  if (data && data->callback) {\r\n    if (XML_Char_icmp_ins(name, X(\"sheet\")) == 0) {\r\n      const XML_Char* sheetname;\r\n      //const XML_Char* relid = get_expat_attr_by_name(atts, X(\"r:id\"));\r\n      if ((sheetname = get_expat_attr_by_name(atts, X(\"name\"))) != NULL) {\r\n        if (data->callback) {\r\n          if ((*data->callback)(sheetname, data->callbackdata) != 0) {\r\n            XML_StopParser(data->xmlparser, XML_FALSE);\r\n            return;\r\n          }\r\n/*\r\n        } else {\r\n          //for non-calback method suspend here\r\n          XML_StopParser(data->xmlparser, XML_TRUE);\r\n*/\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n//process contents each sheet listed in main sheet\r\nvoid xlsxioread_list_sheets_callback (ZIPFILETYPE* zip, const XML_Char* filename, const XML_Char* contenttype, void* callbackdata)\r\n{\r\n  //get sheet information from file\r\n  expat_process_zip_file(zip, filename, main_sheet_list_expat_callback_element_start, NULL, NULL, callbackdata, &((struct main_sheet_list_callback_data*)callbackdata)->xmlparser);\r\n}\r\n\r\n//list all worksheets\r\nDLL_EXPORT_XLSXIO void xlsxioread_list_sheets (xlsxioreader handle, xlsxioread_list_sheets_callback_fn callback, void* callbackdata)\r\n{\r\n  if (!handle || !callback)\r\n    return;\r\n  //process contents of main sheet\r\n  struct main_sheet_list_callback_data sheetcallbackdata = {\r\n    .xmlparser = NULL,\r\n    .callback = callback,\r\n    .callbackdata = callbackdata\r\n  };\r\n  iterate_files_by_contenttype(handle->zip, xlsx_content_type, xlsxioread_list_sheets_callback, &sheetcallbackdata, &sheetcallbackdata.xmlparser);\r\n  iterate_files_by_contenttype(handle->zip, xlsm_content_type, xlsxioread_list_sheets_callback, &sheetcallbackdata, &sheetcallbackdata.xmlparser);\r\n  iterate_files_by_contenttype(handle->zip, xltx_content_type, xlsxioread_list_sheets_callback, &sheetcallbackdata, &sheetcallbackdata.xmlparser);\r\n  iterate_files_by_contenttype(handle->zip, xltm_content_type, xlsxioread_list_sheets_callback, &sheetcallbackdata, &sheetcallbackdata.xmlparser);\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////\r\n\r\n//callback data structure used by main_sheet_get_sheetfile_callback\r\nstruct main_sheet_get_rels_callback_data {\r\n  XML_Parser xmlparser;\r\n  const XML_Char* sheetname;\r\n  XML_Char* basepath;\r\n  XML_Char* sheetrelid;\r\n  XML_Char* sheetfile;\r\n  XML_Char* sharedstringsfile;\r\n  XML_Char* stylesfile;\r\n};\r\n\r\n//determine relationship id for specific sheet name\r\nvoid main_sheet_get_relid_expat_callback_element_start (void* callbackdata, const XML_Char* name, const XML_Char** atts)\r\n{\r\n  struct main_sheet_get_rels_callback_data* data = (struct main_sheet_get_rels_callback_data*)callbackdata;\r\n  if (XML_Char_icmp_ins(name, X(\"sheet\")) == 0) {\r\n    const XML_Char* sheetname;\r\n    if ((sheetname = get_expat_attr_by_name(atts, X(\"name\"))) != NULL && (!data->sheetname || XML_Char_icmp(sheetname, data->sheetname) == 0)) {\r\n      const XML_Char* relid = get_expat_attr_by_name(atts, X(\"r:id\"));\r\n      if (relid && *relid) {\r\n        data->sheetrelid = XML_Char_dup(relid);\r\n        XML_StopParser(data->xmlparser, XML_FALSE);\r\n        return;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n//determine file names for specific relationship id\r\nvoid main_sheet_get_sheetfile_expat_callback_element_start (void* callbackdata, const XML_Char* name, const XML_Char** atts)\r\n{\r\n  struct main_sheet_get_rels_callback_data* data = (struct main_sheet_get_rels_callback_data*)callbackdata;\r\n  if (data->sheetrelid) {\r\n    if (XML_Char_icmp_ins(name, X(\"Relationship\")) == 0) {\r\n      const XML_Char* reltype;\r\n      if ((reltype = get_expat_attr_by_name(atts, X(\"Type\"))) != NULL) {\r\n        if (XML_Char_icmp(reltype, X(\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet\")) == 0) {\r\n          const XML_Char* relid = get_expat_attr_by_name(atts, X(\"Id\"));\r\n          if (XML_Char_icmp(relid, data->sheetrelid) == 0) {\r\n            const XML_Char* filename = get_expat_attr_by_name(atts, X(\"Target\"));\r\n            if (filename && *filename) {\r\n              data->sheetfile = join_basepath_filename(data->basepath, filename);\r\n            }\r\n          }\r\n        } else if (XML_Char_icmp(reltype, X(\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings\")) == 0) {\r\n          const XML_Char* filename = get_expat_attr_by_name(atts, X(\"Target\"));\r\n          if (filename && *filename) {\r\n            data->sharedstringsfile = join_basepath_filename(data->basepath, filename);\r\n          }\r\n        } else if (XML_Char_icmp(reltype, X(\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles\")) == 0) {\r\n          const XML_Char* filename = get_expat_attr_by_name(atts, X(\"Target\"));\r\n          if (filename && *filename) {\r\n            data->stylesfile = join_basepath_filename(data->basepath, filename);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n//determine the file name for a specified sheet name\r\nvoid main_sheet_get_sheetfile_callback (ZIPFILETYPE* zip, const XML_Char* filename, const XML_Char* contenttype, void* callbackdata)\r\n{\r\n  struct main_sheet_get_rels_callback_data* data = (struct main_sheet_get_rels_callback_data*)callbackdata;\r\n  if (!data->sheetrelid) {\r\n    expat_process_zip_file(zip, filename, main_sheet_get_relid_expat_callback_element_start, NULL, NULL, callbackdata, &data->xmlparser);\r\n  }\r\n  if (data->sheetrelid) {\r\n    XML_Char* relfilename;\r\n    //determine base name (including trailing slash)\r\n    size_t i = XML_Char_len(filename);\r\n    while (i > 0) {\r\n      if (filename[i - 1] == '/')\r\n        break;\r\n      i--;\r\n    }\r\n    if (data->basepath)\r\n      free(data->basepath);\r\n    if ((data->basepath = XML_Char_malloc(i + 1)) != NULL) {\r\n      XML_Char_poscpy(data->basepath, 0, filename, i);\r\n      data->basepath[i] = 0;\r\n    }\r\n    //find sheet filename in relationship contents\r\n    if ((relfilename = get_relationship_filename(filename)) != NULL) {\r\n      expat_process_zip_file(zip, relfilename, main_sheet_get_sheetfile_expat_callback_element_start, NULL, NULL, callbackdata, &data->xmlparser);\r\n      free(relfilename);\r\n    } else {\r\n      free(data->sheetrelid);\r\n      data->sheetrelid = NULL;\r\n      if (data->basepath) {\r\n        free(data->basepath);\r\n        data->basepath = NULL;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////\r\n\r\ntypedef enum {\r\n  none,\r\n  value_string,\r\n  inline_string,\r\n  shared_string\r\n} cell_string_type_enum;\r\n\r\n#define XLSXIOREAD_NO_CALLBACK          0x80\r\n\r\nstruct data_sheet_callback_data {\r\n  XML_Parser xmlparser;\r\n  struct sharedstringlist* sharedstrings;\r\n  size_t rownr;\r\n  size_t colnr;\r\n  size_t cols;\r\n  size_t colsnotnull;\r\n  XML_Char* celldata;\r\n  size_t celldatalen;\r\n  cell_string_type_enum cell_string_type;\r\n  unsigned int flags;\r\n  XML_Char* skiptag;                    //tag to skip\r\n  size_t skiptagcount;                  //nesting level for current tag to skip\r\n  XML_StartElementHandler skip_start;   //start handler to set after skipping\r\n  XML_EndElementHandler skip_end;       //end handler to set after skipping\r\n  XML_CharacterDataHandler skip_data;   //data handler to set after skipping\r\n  xlsxioread_process_row_callback_fn sheet_row_callback;\r\n  xlsxioread_process_cell_callback_fn sheet_cell_callback;\r\n  void* callbackdata;\r\n};\r\n\r\nvoid data_sheet_callback_data_initialize (struct data_sheet_callback_data* data, struct sharedstringlist* sharedstrings, unsigned int flags, xlsxioread_process_cell_callback_fn cell_callback, xlsxioread_process_row_callback_fn row_callback, void* callbackdata)\r\n{\r\n  data->xmlparser = NULL;\r\n  data->sharedstrings = sharedstrings;\r\n  data->rownr = 0;\r\n  data->colnr = 0;\r\n  data->cols = 0;\r\n  data->colsnotnull = 0;\r\n  data->celldata = NULL;\r\n  data->celldatalen = 0;\r\n  data->cell_string_type = none;\r\n  data->flags = flags;\r\n  data->skiptag = NULL;\r\n  data->skiptagcount = 0;\r\n  data->skip_start = NULL;\r\n  data->skip_end = NULL;\r\n  data->skip_data = NULL;\r\n  data->sheet_cell_callback = cell_callback;\r\n  data->sheet_row_callback = row_callback;\r\n  data->callbackdata = callbackdata;\r\n}\r\n\r\nvoid data_sheet_callback_data_cleanup (struct data_sheet_callback_data* data)\r\n{\r\n  sharedstringlist_destroy(data->sharedstrings);\r\n  free(data->celldata);\r\n  free(data->skiptag);\r\n}\r\n\r\nvoid data_sheet_expat_callback_skip_tag_start (void* callbackdata, const XML_Char* name, const XML_Char** atts)\r\n{\r\n  struct data_sheet_callback_data* data = (struct data_sheet_callback_data*)callbackdata;\r\n  if (name && XML_Char_icmp_ins(name, data->skiptag) == 0) {\r\n    //increment nesting level\r\n    data->skiptagcount++;\r\n  }\r\n}\r\n\r\nvoid data_sheet_expat_callback_skip_tag_end (void* callbackdata, const XML_Char* name)\r\n{\r\n  struct data_sheet_callback_data* data = (struct data_sheet_callback_data*)callbackdata;\r\n  if (!name || XML_Char_icmp_ins(name, data->skiptag) == 0) {\r\n    if (--data->skiptagcount == 0) {\r\n      //restore handlers when done skipping\r\n      XML_SetElementHandler(data->xmlparser, data->skip_start, data->skip_end);\r\n      XML_SetCharacterDataHandler(data->xmlparser, data->skip_data);\r\n      free(data->skiptag);\r\n      data->skiptag = NULL;\r\n    }\r\n  }\r\n}\r\n\r\nvoid data_sheet_expat_callback_find_worksheet_start (void* callbackdata, const XML_Char* name, const XML_Char** atts);\r\nvoid data_sheet_expat_callback_find_worksheet_end (void* callbackdata, const XML_Char* name);\r\nvoid data_sheet_expat_callback_find_sheetdata_start (void* callbackdata, const XML_Char* name, const XML_Char** atts);\r\nvoid data_sheet_expat_callback_find_sheetdata_end (void* callbackdata, const XML_Char* name);\r\nvoid data_sheet_expat_callback_find_row_start (void* callbackdata, const XML_Char* name, const XML_Char** atts);\r\nvoid data_sheet_expat_callback_find_row_end (void* callbackdata, const XML_Char* name);\r\nvoid data_sheet_expat_callback_find_cell_start (void* callbackdata, const XML_Char* name, const XML_Char** atts);\r\nvoid data_sheet_expat_callback_find_cell_end (void* callbackdata, const XML_Char* name);\r\nvoid data_sheet_expat_callback_find_value_start (void* callbackdata, const XML_Char* name, const XML_Char** atts);\r\nvoid data_sheet_expat_callback_find_value_end (void* callbackdata, const XML_Char* name);\r\nvoid data_sheet_expat_callback_value_data (void* callbackdata, const XML_Char* buf, int buflen);\r\n\r\nvoid data_sheet_expat_callback_find_worksheet_start (void* callbackdata, const XML_Char* name, const XML_Char** atts)\r\n{\r\n  struct data_sheet_callback_data* data = (struct data_sheet_callback_data*)callbackdata;\r\n  if (XML_Char_icmp_ins(name, X(\"worksheet\")) == 0) {\r\n    XML_SetElementHandler(data->xmlparser, data_sheet_expat_callback_find_sheetdata_start, NULL);\r\n  }\r\n}\r\n\r\nvoid data_sheet_expat_callback_find_worksheet_end (void* callbackdata, const XML_Char* name)\r\n{\r\n  struct data_sheet_callback_data* data = (struct data_sheet_callback_data*)callbackdata;\r\n  if (XML_Char_icmp_ins(name, X(\"worksheet\")) == 0) {\r\n    XML_SetElementHandler(data->xmlparser, data_sheet_expat_callback_find_worksheet_start, NULL);\r\n  }\r\n}\r\n\r\nvoid data_sheet_expat_callback_find_sheetdata_start (void* callbackdata, const XML_Char* name, const XML_Char** atts)\r\n{\r\n  struct data_sheet_callback_data* data = (struct data_sheet_callback_data*)callbackdata;\r\n  if (XML_Char_icmp_ins(name, X(\"sheetData\")) == 0) {\r\n    XML_SetElementHandler(data->xmlparser, data_sheet_expat_callback_find_row_start, data_sheet_expat_callback_find_sheetdata_end);\r\n  }\r\n}\r\n\r\nvoid data_sheet_expat_callback_find_sheetdata_end (void* callbackdata, const XML_Char* name)\r\n{\r\n  struct data_sheet_callback_data* data = (struct data_sheet_callback_data*)callbackdata;\r\n  if (XML_Char_icmp_ins(name, X(\"sheetData\")) == 0) {\r\n    XML_SetElementHandler(data->xmlparser, data_sheet_expat_callback_find_sheetdata_start, data_sheet_expat_callback_find_worksheet_end);\r\n  } else {\r\n    data_sheet_expat_callback_find_worksheet_end(callbackdata, name);\r\n  }\r\n}\r\n\r\nvoid data_sheet_expat_callback_find_row_start (void* callbackdata, const XML_Char* name, const XML_Char** atts)\r\n{\r\n  struct data_sheet_callback_data* data = (struct data_sheet_callback_data*)callbackdata;\r\n  if (XML_Char_icmp_ins(name, X(\"row\")) == 0) {\r\n    const XML_Char* hidden = get_expat_attr_by_name(atts, X(\"hidden\"));\r\n    if (!(hidden && XML_Char_tol(hidden) != 0 && (data->flags & XLSXIOREAD_SKIP_HIDDEN_ROWS))) {\r\n      int skippedemptyrow = (data->rownr != 0 && data->colsnotnull == 0 && (data->flags & XLSXIOREAD_SKIP_EMPTY_ROWS));\r\n      data->rownr++;\r\n      data->colnr = 0;\r\n      data->colsnotnull = 0;\r\n      XML_SetElementHandler(data->xmlparser, data_sheet_expat_callback_find_cell_start, data_sheet_expat_callback_find_row_end);\r\n      //for non-calback method suspend here on new row\r\n      if (data->flags & XLSXIOREAD_NO_CALLBACK) {\r\n        if (!skippedemptyrow) {\r\n          XML_StopParser(data->xmlparser, XML_TRUE);\r\n        }\r\n      }\r\n    } else {\r\n      //skip hidden row\r\n      XML_SetElementHandler(data->xmlparser, NULL, data_sheet_expat_callback_find_row_end);\r\n    }\r\n  }\r\n}\r\n\r\nvoid data_sheet_expat_callback_find_row_end (void* callbackdata, const XML_Char* name)\r\n{\r\n  struct data_sheet_callback_data* data = (struct data_sheet_callback_data*)callbackdata;\r\n  if (XML_Char_icmp_ins(name, X(\"row\")) == 0) {\r\n    //determine number of columns based on first row\r\n    if ((data->flags & XLSXIOREAD_SKIP_EXTRA_CELLS) && data->rownr == 1 && data->cols == 0)\r\n      data->cols = data->colnr;\r\n    //add empty columns if needed\r\n    if (!(data->flags & XLSXIOREAD_NO_CALLBACK) && data->sheet_cell_callback && !(data->flags & XLSXIOREAD_SKIP_EMPTY_CELLS)) {\r\n      while (data->colnr < data->cols) {\r\n        if ((*data->sheet_cell_callback)(data->rownr, data->colnr + 1, NULL, data->callbackdata)) {\r\n          XML_StopParser(data->xmlparser, XML_FALSE);\r\n          return;\r\n        }\r\n        data->colnr++;\r\n      }\r\n    }\r\n    free(data->celldata);\r\n    data->celldata = NULL;\r\n    XML_SetElementHandler(data->xmlparser, data_sheet_expat_callback_find_row_start, data_sheet_expat_callback_find_sheetdata_end);\r\n    //process end of row\r\n    if (!(data->flags & XLSXIOREAD_NO_CALLBACK)) {\r\n      if (data->sheet_row_callback && !(data->colsnotnull == 0 && (data->flags & XLSXIOREAD_SKIP_EMPTY_ROWS))) {\r\n        if ((*data->sheet_row_callback)(data->rownr, data->colnr, data->callbackdata)) {\r\n          XML_StopParser(data->xmlparser, XML_FALSE);\r\n          return;\r\n        }\r\n      }\r\n    } else {\r\n      //for non-calback method suspend here on end of row\r\n      if (!(data->colsnotnull == 0 && (data->flags & XLSXIOREAD_SKIP_EMPTY_ROWS)))\r\n        XML_StopParser(data->xmlparser, XML_TRUE);\r\n    }\r\n  } else {\r\n    data_sheet_expat_callback_find_sheetdata_end(callbackdata, name);\r\n  }\r\n}\r\n\r\nvoid data_sheet_expat_callback_find_cell_start (void* callbackdata, const XML_Char* name, const XML_Char** atts)\r\n{\r\n  struct data_sheet_callback_data* data = (struct data_sheet_callback_data*)callbackdata;\r\n  if (XML_Char_icmp_ins(name, X(\"c\")) == 0) {\r\n    const XML_Char* t = get_expat_attr_by_name(atts, X(\"r\"));\r\n    size_t cellcolnr = get_col_nr(t);\r\n    //insert empty rows if needed\r\n    if (data->colnr == 0) {\r\n      size_t cellrownr = get_row_nr(t);\r\n      if (cellrownr) {\r\n        if (!(data->flags & XLSXIOREAD_SKIP_EMPTY_ROWS) && !(data->flags & XLSXIOREAD_NO_CALLBACK)) {\r\n          while (data->rownr < cellrownr) {\r\n            //insert empty columns\r\n            if (!(data->flags & XLSXIOREAD_SKIP_EMPTY_CELLS) && data->sheet_cell_callback) {\r\n              while (data->colnr < data->cols) {\r\n                if ((*data->sheet_cell_callback)(data->rownr, data->colnr + 1, NULL, data->callbackdata)) {\r\n                  XML_StopParser(data->xmlparser, XML_FALSE);\r\n                  return;\r\n                }\r\n                data->colnr++;\r\n              }\r\n            }\r\n            //finish empty row\r\n            if (data->sheet_row_callback) {\r\n              if ((*data->sheet_row_callback)(data->rownr, data->cols, data->callbackdata)) {\r\n                XML_StopParser(data->xmlparser, XML_FALSE);\r\n                return;\r\n              }\r\n            }\r\n            data->rownr++;\r\n            data->colnr = 0;\r\n          }\r\n        } else {\r\n          data->rownr = cellrownr;\r\n        }\r\n      }\r\n    }\r\n    //insert empty columns if needed\r\n    if (cellcolnr) {\r\n      cellcolnr--;\r\n      if ((data->flags & XLSXIOREAD_SKIP_EMPTY_CELLS) || data->colnr == 0 || (data->flags & XLSXIOREAD_NO_CALLBACK)) {\r\n        data->colnr = cellcolnr;\r\n      } else {\r\n        size_t cellmax = cellcolnr;\r\n        if ((data->flags & XLSXIOREAD_SKIP_EXTRA_CELLS) && data->cols > 0 && cellmax > data->cols)\r\n          cellmax = data->cols;\r\n        while (data->colnr < cellmax) {\r\n          if (data->colnr > 0 && data->sheet_cell_callback) {\r\n            if ((*data->sheet_cell_callback)(data->rownr, data->colnr + 1, NULL, data->callbackdata)) {\r\n              XML_StopParser(data->xmlparser, XML_FALSE);\r\n              return;\r\n            }\r\n          }\r\n          data->colnr++;\r\n        }\r\n      }\r\n    }\r\n    //determing value type\r\n    if ((t = get_expat_attr_by_name(atts, X(\"t\"))) != NULL && XML_Char_icmp(t, X(\"s\")) == 0)\r\n      data->cell_string_type = shared_string;\r\n    else\r\n      data->cell_string_type = value_string;\r\n    //prepare empty value data\r\n    free(data->celldata);\r\n    data->celldata = NULL;\r\n    data->celldatalen = 0;\r\n    XML_SetElementHandler(data->xmlparser, data_sheet_expat_callback_find_value_start, data_sheet_expat_callback_find_cell_end);\r\n  }\r\n}\r\n\r\nvoid data_sheet_expat_callback_find_cell_end (void* callbackdata, const XML_Char* name)\r\n{\r\n  struct data_sheet_callback_data* data = (struct data_sheet_callback_data*)callbackdata;\r\n  if (XML_Char_icmp_ins(name, X(\"c\")) == 0) {\r\n    //determine value\r\n    if (data->celldata) {\r\n      data->celldata[data->celldatalen] = 0;\r\n      if (data->cell_string_type == shared_string) {\r\n        //get shared string\r\n        XML_Char* p = NULL;\r\n        long num = XML_Char_strtol(data->celldata, &p, 10);\r\n        if (!p || (p != data->celldata && *p == 0)) {\r\n          const XML_Char* s = sharedstringlist_get(data->sharedstrings, num);\r\n          free(data->celldata);\r\n          data->celldata = (s ? XML_Char_dup(s) : NULL);\r\n        }\r\n      } else if (data->cell_string_type == none) {\r\n        //unknown value type\r\n        free(data->celldata);\r\n        data->celldata = NULL;\r\n      }\r\n    }\r\n    //reset data\r\n    data->colnr++;\r\n    data->cell_string_type = none;\r\n    data->celldatalen = 0;\r\n    XML_SetElementHandler(data->xmlparser, data_sheet_expat_callback_find_cell_start, data_sheet_expat_callback_find_row_end);\r\n    XML_SetCharacterDataHandler(data->xmlparser, NULL);\r\n    //process data if needed\r\n    if (data->celldata || !((data->flags & XLSXIOREAD_SKIP_EMPTY_CELLS) || ((data->flags & XLSXIOREAD_SKIP_EMPTY_ROWS) && data->colsnotnull == 0))) {\r\n      if (!((data->flags & XLSXIOREAD_SKIP_EXTRA_CELLS) && data->cols > 0 && data->colnr > data->cols)) {\r\n        //process data\r\n        if (!(data->flags & XLSXIOREAD_NO_CALLBACK)) {\r\n          if (data->sheet_cell_callback) {\r\n            //insert empty columns if needed in case of empty row detection\r\n            /////if ((data->flags & XLSXIOREAD_SKIP_EMPTY_ROWS) && !(data->flags & XLSXIOREAD_SKIP_EMPTY_CELLS) && data->colsnotnull == 0 && data->colnr > 1) {\r\n            if (!(data->flags & XLSXIOREAD_SKIP_EMPTY_CELLS) && data->colsnotnull == 0 && data->colnr > 1) {\r\n              size_t col;\r\n              for (col = 1; col < data->colnr; col++) {\r\n                if ((*data->sheet_cell_callback)(data->rownr, col, NULL, data->callbackdata)) {\r\n                  XML_StopParser(data->xmlparser, XML_FALSE);\r\n                  return;\r\n                }\r\n              }\r\n            }\r\n            //process current column data\r\n            if ((*data->sheet_cell_callback)(data->rownr, data->colnr, data->celldata, data->callbackdata)) {\r\n              XML_StopParser(data->xmlparser, XML_FALSE);\r\n              return;\r\n            }\r\n            data->colsnotnull++;\r\n          }\r\n        } else {\r\n          //for non-calback method suspend here with cell data (don't return NULL as that is used to indicate end of row)\r\n          if (!data->celldata)\r\n            data->celldata = XML_Char_dup(X(\"\"));\r\n          XML_StopParser(data->xmlparser, XML_TRUE);\r\n          data->colsnotnull++;\r\n        }\r\n      }\r\n    }\r\n  } else {\r\n    data_sheet_expat_callback_find_row_end(callbackdata, name);\r\n  }\r\n}\r\n\r\nvoid data_sheet_expat_callback_find_value_start (void* callbackdata, const XML_Char* name, const XML_Char** atts)\r\n{\r\n  struct data_sheet_callback_data* data = (struct data_sheet_callback_data*)callbackdata;\r\n  if (XML_Char_icmp_ins(name, X(\"v\")) == 0 || XML_Char_icmp_ins(name, X(\"t\")) == 0) {\r\n    XML_SetElementHandler(data->xmlparser, NULL, data_sheet_expat_callback_find_value_end);\r\n    XML_SetCharacterDataHandler(data->xmlparser, data_sheet_expat_callback_value_data);\r\n  } else if (XML_Char_icmp_ins(name, X(\"is\")) == 0) {\r\n    data->cell_string_type = inline_string;\r\n  } else if (XML_Char_icmp_ins(name, X(\"rPh\")) == 0) {\r\n    data->skiptag = XML_Char_dup(name);\r\n    data->skiptagcount = 1;\r\n    data->skip_start = data_sheet_expat_callback_find_value_start;\r\n    data->skip_end = data_sheet_expat_callback_find_cell_end;\r\n    data->skip_data = NULL;\r\n    XML_SetElementHandler(data->xmlparser, data_sheet_expat_callback_skip_tag_start, data_sheet_expat_callback_skip_tag_end);\r\n    XML_SetCharacterDataHandler(data->xmlparser, NULL);\r\n  }\r\n}\r\n\r\nvoid data_sheet_expat_callback_find_value_end (void* callbackdata, const XML_Char* name)\r\n{\r\n  struct data_sheet_callback_data* data = (struct data_sheet_callback_data*)callbackdata;\r\n  if (XML_Char_icmp_ins(name, X(\"v\")) == 0 || XML_Char_icmp_ins(name, X(\"t\")) == 0) {\r\n    XML_SetElementHandler(data->xmlparser, data_sheet_expat_callback_find_value_start, data_sheet_expat_callback_find_cell_end);\r\n    XML_SetCharacterDataHandler(data->xmlparser, NULL);\r\n  } else if (XML_Char_icmp_ins(name, X(\"is\")) == 0) {\r\n    data->cell_string_type = none;\r\n  } else {\r\n    data_sheet_expat_callback_find_row_end(callbackdata, name);\r\n  }\r\n}\r\n\r\nvoid data_sheet_expat_callback_value_data (void* callbackdata, const XML_Char* buf, int buflen)\r\n{\r\n  struct data_sheet_callback_data* data = (struct data_sheet_callback_data*)callbackdata;\r\n  if (data->cell_string_type != none) {\r\n    if ((data->celldata = XML_Char_realloc(data->celldata, data->celldatalen + buflen + 1)) == NULL) {\r\n      //memory allocation error\r\n      data->celldatalen = 0;\r\n    } else {\r\n      //add new data to value buffer\r\n      XML_Char_poscpy(data->celldata, data->celldatalen, buf, buflen);\r\n      data->celldatalen += buflen;\r\n    }\r\n  }\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////\r\n\r\nstruct xlsxio_read_sheet_struct {\r\n  xlsxioreader handle;\r\n  ZIPFILEENTRYTYPE* zipfile;\r\n  struct data_sheet_callback_data processcallbackdata;\r\n  size_t lastrownr;\r\n  size_t paddingrow;\r\n  size_t lastcolnr;\r\n  size_t paddingcol;\r\n};\r\n\r\nDLL_EXPORT_XLSXIO size_t xlsxioread_sheet_last_row_index (xlsxioreadersheet sheethandle)\r\n{\r\n  return sheethandle->lastrownr;\r\n}\r\n\r\nDLL_EXPORT_XLSXIO size_t xlsxioread_sheet_last_column_index (xlsxioreadersheet sheethandle)\r\n{\r\n  return sheethandle->lastcolnr;\r\n}\r\n\r\nDLL_EXPORT_XLSXIO unsigned int xlsxioread_sheet_flags (xlsxioreadersheet sheethandle)\r\n{\r\n  return sheethandle->processcallbackdata.flags;\r\n}\r\n\r\nDLL_EXPORT_XLSXIO int xlsxioread_process (xlsxioreader handle, const XLSXIOCHAR* sheetname, unsigned int flags, xlsxioread_process_cell_callback_fn cell_callback, xlsxioread_process_row_callback_fn row_callback, void* callbackdata)\r\n{\r\n  int result = 0;\r\n  //determine sheet file name\r\n  struct main_sheet_get_rels_callback_data getrelscallbackdata = {\r\n    .sheetname = sheetname,\r\n    .basepath = NULL,\r\n    .sheetrelid = NULL,\r\n    .sheetfile = NULL,\r\n    .sharedstringsfile = NULL,\r\n    .stylesfile = NULL\r\n  };\r\n  iterate_files_by_contenttype(handle->zip, xlsx_content_type, main_sheet_get_sheetfile_callback, &getrelscallbackdata, NULL);\r\n  if (!getrelscallbackdata.sheetrelid)\r\n    iterate_files_by_contenttype(handle->zip, xlsm_content_type, main_sheet_get_sheetfile_callback, &getrelscallbackdata, NULL);\r\n  if (!getrelscallbackdata.sheetrelid)\r\n    iterate_files_by_contenttype(handle->zip, xltx_content_type, main_sheet_get_sheetfile_callback, &getrelscallbackdata, NULL);\r\n  if (!getrelscallbackdata.sheetrelid)\r\n    iterate_files_by_contenttype(handle->zip, xltm_content_type, main_sheet_get_sheetfile_callback, &getrelscallbackdata, NULL);\r\n\r\n  //process shared strings\r\n  struct sharedstringlist* sharedstrings = NULL;\r\n  if (getrelscallbackdata.sharedstringsfile && getrelscallbackdata.sharedstringsfile[0]) {\r\n    sharedstrings = sharedstringlist_create();\r\n    struct shared_strings_callback_data sharedstringsdata;\r\n    shared_strings_callback_data_initialize(&sharedstringsdata, sharedstrings);\r\n    if (expat_process_zip_file(handle->zip, getrelscallbackdata.sharedstringsfile, shared_strings_callback_find_sharedstringtable_start, NULL, NULL, &sharedstringsdata, &sharedstringsdata.xmlparser) != 0) {\r\n      //no shared strings found\r\n      sharedstringlist_destroy(sharedstrings);\r\n      sharedstrings = NULL;\r\n    }\r\n    shared_strings_callback_data_cleanup(&sharedstringsdata);\r\n  }\r\n\r\n  //process sheet\r\n  if (!(flags & XLSXIOREAD_NO_CALLBACK)) {\r\n    //use callback mechanism\r\n    struct data_sheet_callback_data processcallbackdata;\r\n    data_sheet_callback_data_initialize(&processcallbackdata, sharedstrings, flags, cell_callback, row_callback, callbackdata);\r\n    expat_process_zip_file(handle->zip, getrelscallbackdata.sheetfile, data_sheet_expat_callback_find_worksheet_start, NULL, NULL, &processcallbackdata, &processcallbackdata.xmlparser);\r\n    data_sheet_callback_data_cleanup(&processcallbackdata);\r\n  } else {\r\n    //use simplified interface by suspending the XML parser when data is found\r\n    xlsxioreadersheet sheethandle = (xlsxioreadersheet)callbackdata;\r\n    data_sheet_callback_data_initialize(&sheethandle->processcallbackdata, sharedstrings, flags, NULL, NULL, sheethandle);\r\n    if ((sheethandle->zipfile = XML_Char_openzip(sheethandle->handle->zip, getrelscallbackdata.sheetfile, 0)) == NULL) {\r\n      result = 1;\r\n    }\r\n    if ((sheethandle->processcallbackdata.xmlparser = expat_process_zip_file_suspendable(sheethandle->zipfile, data_sheet_expat_callback_find_worksheet_start, NULL, NULL, &sheethandle->processcallbackdata)) == NULL) {\r\n      result = 2;\r\n    }\r\n  }\r\n\r\n  //clean up\r\n  free(getrelscallbackdata.basepath);\r\n  free(getrelscallbackdata.sheetrelid);\r\n  free(getrelscallbackdata.sheetfile);\r\n  free(getrelscallbackdata.sharedstringsfile);\r\n  free(getrelscallbackdata.stylesfile);\r\n  return result;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////\r\n\r\nstruct xlsxio_read_sheetlist_struct {\r\n  xlsxioreader handle;\r\n  ZIPFILEENTRYTYPE* zipfile;\r\n  struct main_sheet_list_callback_data sheetcallbackdata;\r\n  XML_Parser xmlparser;\r\n  XML_Char* nextsheetname;\r\n};\r\n\r\nint xlsxioread_list_sheets_resumable_callback (const XLSXIOCHAR* name, void* callbackdata)\r\n{\r\n  //struct main_sheet_list_callback_data* data = (struct main_sheet_list_callback_data*)callbackdata;\r\n  xlsxioreadersheetlist data = (xlsxioreadersheetlist)callbackdata;\r\n  data->nextsheetname = XML_Char_dup(name);\r\n  XML_StopParser(data->xmlparser, XML_TRUE);\r\n  return 0;\r\n}\r\n\r\nvoid xlsxioread_find_main_sheet_file_callback (ZIPFILETYPE* zip, const XML_Char* filename, const XML_Char* contenttype, void* callbackdata)\r\n{\r\n  XML_Char** data = (XML_Char**)callbackdata;\r\n  *data = XML_Char_dup(filename);\r\n}\r\n\r\nDLL_EXPORT_XLSXIO xlsxioreadersheetlist xlsxioread_sheetlist_open (xlsxioreader handle)\r\n{\r\n  //determine main sheet name\r\n  XML_Char* mainsheetfile = NULL;\r\n  iterate_files_by_contenttype(handle->zip, xlsx_content_type, xlsxioread_find_main_sheet_file_callback, &mainsheetfile, NULL);\r\n  if (!mainsheetfile)\r\n    iterate_files_by_contenttype(handle->zip, xlsm_content_type, xlsxioread_find_main_sheet_file_callback, &mainsheetfile, NULL);\r\n  if (!mainsheetfile)\r\n    iterate_files_by_contenttype(handle->zip, xltx_content_type, xlsxioread_find_main_sheet_file_callback, &mainsheetfile, NULL);\r\n  if (!mainsheetfile)\r\n    iterate_files_by_contenttype(handle->zip, xltm_content_type, xlsxioread_find_main_sheet_file_callback, &mainsheetfile, NULL);\r\n  if (!mainsheetfile)\r\n    return NULL;\r\n  //process contents of main sheet\r\n  xlsxioreadersheetlist result;\r\n  if ((result = (xlsxioreadersheetlist)malloc(sizeof(struct xlsxio_read_sheetlist_struct))) == NULL)\r\n    return NULL;\r\n  result->handle = handle;\r\n  result->sheetcallbackdata.xmlparser = NULL;\r\n  result->sheetcallbackdata.callback = xlsxioread_list_sheets_resumable_callback;\r\n  result->sheetcallbackdata.callbackdata = result;\r\n  result->nextsheetname = NULL;\r\n  if ((result->zipfile = XML_Char_openzip(handle->zip, mainsheetfile, 0)) != NULL) {\r\n    result->xmlparser = expat_process_zip_file_suspendable(result->zipfile, main_sheet_list_expat_callback_element_start, NULL, NULL, &result->sheetcallbackdata);\r\n  }\r\n  //clean up\r\n  free(mainsheetfile);\r\n  return result;\r\n}\r\n\r\nDLL_EXPORT_XLSXIO void xlsxioread_sheetlist_close (xlsxioreadersheetlist sheetlisthandle)\r\n{\r\n  if (!sheetlisthandle)\r\n    return;\r\n  if (sheetlisthandle->xmlparser)\r\n    XML_ParserFree(sheetlisthandle->xmlparser);\r\n  if (sheetlisthandle->zipfile)\r\n#ifdef USE_MINIZIP\r\n    unzCloseCurrentFile(sheetlisthandle->zipfile);\r\n#else\r\n    zip_fclose(sheetlisthandle->zipfile);\r\n#endif\r\n  free(sheetlisthandle->nextsheetname);\r\n  free(sheetlisthandle);\r\n\r\n}\r\n\r\nDLL_EXPORT_XLSXIO const XLSXIOCHAR* xlsxioread_sheetlist_next (xlsxioreadersheetlist sheetlisthandle)\r\n{\r\n  if (!sheetlisthandle->zipfile || !sheetlisthandle->xmlparser)\r\n    return NULL;\r\n  free(sheetlisthandle->nextsheetname);\r\n  sheetlisthandle->nextsheetname = NULL;\r\n  enum XML_Status status;\r\n  if ((status = expat_process_zip_file_resume(sheetlisthandle->zipfile, sheetlisthandle->xmlparser)) != XML_STATUS_SUSPENDED) {\r\n    return NULL;\r\n  }\r\n  return sheetlisthandle->nextsheetname;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////\r\n\r\nDLL_EXPORT_XLSXIO xlsxioreadersheet xlsxioread_sheet_open (xlsxioreader handle, const XLSXIOCHAR* sheetname, unsigned int flags)\r\n{\r\n  xlsxioreadersheet result;\r\n  if ((result = (xlsxioreadersheet)malloc(sizeof(struct xlsxio_read_sheet_struct))) == NULL)\r\n    return NULL;\r\n  result->handle = handle;\r\n  result->zipfile = NULL;\r\n  result->lastrownr = 0;\r\n  result->paddingrow = 0;\r\n  result->lastcolnr = 0;\r\n  result->paddingcol = 0;\r\n  xlsxioread_process(handle, sheetname, flags | XLSXIOREAD_NO_CALLBACK, NULL, NULL, result);  /* Note: currently broken when not using XLSXIOREAD_NO_CALLBACK flag */\r\n  return result;\r\n}\r\n\r\nDLL_EXPORT_XLSXIO void xlsxioread_sheet_close (xlsxioreadersheet sheethandle)\r\n{\r\n  if (!sheethandle)\r\n    return;\r\n  if (sheethandle->processcallbackdata.xmlparser)\r\n    XML_ParserFree(sheethandle->processcallbackdata.xmlparser);\r\n  data_sheet_callback_data_cleanup(&sheethandle->processcallbackdata);\r\n  if (sheethandle->zipfile)\r\n#ifdef USE_MINIZIP\r\n    unzCloseCurrentFile(sheethandle->zipfile);\r\n#else\r\n    zip_fclose(sheethandle->zipfile);\r\n#endif\r\n  free(sheethandle);\r\n}\r\n\r\nDLL_EXPORT_XLSXIO int xlsxioread_sheet_next_row (xlsxioreadersheet sheethandle)\r\n{\r\n  enum XML_Status status;\r\n  if (!sheethandle) {\r\n    return 0;\r\n  }\r\n  sheethandle->lastcolnr = 0;\r\n  //when padding rows don't retrieve new data\r\n  if (sheethandle->paddingrow) {\r\n    if (sheethandle->paddingrow < sheethandle->processcallbackdata.rownr) {\r\n      return 3;\r\n    } else {\r\n      sheethandle->paddingrow = 0;\r\n      return 2;\r\n    }\r\n  }\r\n  sheethandle->paddingcol = 0;\r\n  //go to beginning of next row\r\n  while ((status = expat_process_zip_file_resume(sheethandle->zipfile, sheethandle->processcallbackdata.xmlparser)) == XML_STATUS_SUSPENDED && sheethandle->processcallbackdata.colnr != 0) {\r\n  }\r\n  return (status == XML_STATUS_SUSPENDED ? 1 : 0);\r\n}\r\n\r\nDLL_EXPORT_XLSXIO XLSXIOCHAR* xlsxioread_sheet_next_cell (xlsxioreadersheet sheethandle)\r\n{\r\n  XML_Char* result;\r\n  if (!sheethandle)\r\n    return NULL;\r\n  //if (!(sheethandle->processcallbackdata.flags & XLSXIOREAD_SKIP_EMPTY_CELLS) && sheethandle->paddingcol) {\r\n  if ((!(sheethandle->processcallbackdata.flags & XLSXIOREAD_SKIP_EMPTY_CELLS) && sheethandle->paddingcol) || (!(sheethandle->processcallbackdata.flags & XLSXIOREAD_SKIP_EMPTY_ROWS) && sheethandle->paddingrow)) {\r\n    if ((/*sheethandle->processcallbackdata.cols > 0 &&*/ sheethandle->paddingcol > sheethandle->processcallbackdata.cols) || (sheethandle->processcallbackdata.flags & XLSXIOREAD_SKIP_EMPTY_CELLS)) {\r\n      //last empty column added, finish row\r\n      sheethandle->paddingcol = 0;\r\n      //when padding rows prepare for the next one\r\n      if (sheethandle->paddingrow) {\r\n        sheethandle->lastrownr++;\r\n        sheethandle->paddingrow++;\r\n        if (sheethandle->paddingrow + 1 < sheethandle->processcallbackdata.rownr) {\r\n          sheethandle->paddingcol = 1;\r\n        }\r\n      }\r\n      return NULL;\r\n    } else if ((sheethandle->processcallbackdata.flags & XLSXIOREAD_SKIP_EXTRA_CELLS) && sheethandle->processcallbackdata.cols > 0 && sheethandle->lastcolnr >= sheethandle->processcallbackdata.cols) {\r\n      //end of line when out of bounds\r\n      return NULL;\r\n    } else {\r\n      //add another empty column\r\n      sheethandle->paddingcol++;\r\n      sheethandle->lastcolnr++;\r\n      return XML_Char_dup(X(\"\"));\r\n    }\r\n  } else if ((sheethandle->processcallbackdata.flags & XLSXIOREAD_SKIP_EXTRA_CELLS) && sheethandle->processcallbackdata.cols > 0 && sheethandle->lastcolnr >= sheethandle->processcallbackdata.cols) {\r\n    //end of line when out of bounds\r\n    return NULL;\r\n  }\r\n  //get value\r\n  if (!sheethandle->processcallbackdata.celldata)\r\n    if (expat_process_zip_file_resume(sheethandle->zipfile, sheethandle->processcallbackdata.xmlparser) != XML_STATUS_SUSPENDED)\r\n      sheethandle->processcallbackdata.celldata = NULL;\r\n  //insert empty rows if needed\r\n  if (!(sheethandle->processcallbackdata.flags & XLSXIOREAD_SKIP_EMPTY_ROWS) && sheethandle->lastrownr + 1 < sheethandle->processcallbackdata.rownr) {\r\n    sheethandle->paddingrow = sheethandle->lastrownr + 1;\r\n    sheethandle->paddingcol = sheethandle->processcallbackdata.colnr*0 + 1;\r\n    return xlsxioread_sheet_next_cell(sheethandle);\r\n  }\r\n  //insert empty column before if needed\r\n  if (!(sheethandle->processcallbackdata.flags & XLSXIOREAD_SKIP_EMPTY_CELLS)) {\r\n    if (sheethandle->lastcolnr + 1 < sheethandle->processcallbackdata.colnr) {\r\n      if (0) {\r\n      //if ((sheethandle->processcallbackdata.flags & XLSXIOREAD_SKIP_EXTRA_CELLS) && sheethandle->processcallbackdata.cols > 0 && sheethandle->lastcolnr >= sheethandle->processcallbackdata.cols) {\r\n        //end of line when out of bounds\r\n        return NULL;\r\n      } else {\r\n        sheethandle->lastcolnr++;\r\n        return XML_Char_dup(X(\"\"));\r\n      }\r\n    }\r\n  }\r\n  result = sheethandle->processcallbackdata.celldata;\r\n  sheethandle->processcallbackdata.celldata = NULL;\r\n  //end of row\r\n  if (!result) {\r\n    sheethandle->lastrownr = sheethandle->processcallbackdata.rownr;\r\n    //insert empty column at end of row if needed\r\n    if (!(sheethandle->processcallbackdata.flags & XLSXIOREAD_SKIP_EMPTY_CELLS) && sheethandle->processcallbackdata.colnr < sheethandle->processcallbackdata.cols) {\r\n      sheethandle->paddingcol = sheethandle->lastcolnr + 1;\r\n      return xlsxioread_sheet_next_cell(sheethandle);\r\n    }\r\n  }\r\n  sheethandle->lastcolnr = sheethandle->processcallbackdata.colnr;\r\n  return result;\r\n}\r\n\r\nDLL_EXPORT_XLSXIO int xlsxioread_sheet_next_cell_string (xlsxioreadersheet sheethandle, XLSXIOCHAR** pvalue)\r\n{\r\n  XML_Char* result;\r\n  if (!sheethandle)\r\n    return -1;\r\n  if ((result = xlsxioread_sheet_next_cell(sheethandle)) == NULL)\r\n    return 0;\r\n  if (pvalue)\r\n    *pvalue = result;\r\n  return 1;\r\n}\r\n\r\nDLL_EXPORT_XLSXIO int xlsxioread_sheet_next_cell_int (xlsxioreadersheet sheethandle, int64_t* pvalue)\r\n{\r\n  XML_Char* result;\r\n  int status;\r\n  if ((result = xlsxioread_sheet_next_cell(sheethandle)) == NULL)\r\n    return 0;\r\n  if (pvalue) {\r\n    status = XML_Char_sscanf(result, X(\"%\" PRIi64), pvalue);\r\n    if (status == EOF || status == 0)\r\n      *pvalue = 0;\r\n    //alternative: use strtoimax()\r\n  }\r\n  free(result);\r\n  return 1;\r\n}\r\n\r\nDLL_EXPORT_XLSXIO int xlsxioread_sheet_next_cell_float (xlsxioreadersheet sheethandle, double* pvalue)\r\n{\r\n  XML_Char* result;\r\n  if ((result = xlsxioread_sheet_next_cell(sheethandle)) == NULL)\r\n    return 0;\r\n  if (pvalue)\r\n    *pvalue = XML_Char_tod(result);\r\n  free(result);\r\n  return 1;\r\n}\r\n\r\nDLL_EXPORT_XLSXIO int xlsxioread_sheet_next_cell_datetime (xlsxioreadersheet sheethandle, time_t* pvalue)\r\n{\r\n  XML_Char* result;\r\n  if ((result = xlsxioread_sheet_next_cell(sheethandle)) == NULL)\r\n    return 0;\r\n  if (pvalue) {\r\n    double value = XML_Char_tod(result);\r\n    if (value != 0) {\r\n      value = (value - 25569) * 86400;  //converstion from Excel to Unix timestamp\r\n    }\r\n    *pvalue = value;\r\n  }\r\n  free(result);\r\n  return 1;\r\n}\r\n\r\nDLL_EXPORT_XLSXIO void xlsxioread_free (XLSXIOCHAR* data)\r\n{\r\n  free(data);\r\n}\r\n"], "fixing_code": ["0.2.35\r\n\r\n2023-05-30  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * fix free of uninitialized pointer in xlsxioread_sheetlist_close() (#121)\r\n\r\n0.2.34\r\n\r\n2022-11-02  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * PR from captaingroove to add minizip-ng support (#115)\r\n\r\n0.2.33\r\n\r\n2022-07-05  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * PR from JackBoosY to export CMake targets automaticly (to cmake folder under install path) (#105)\r\n\r\n0.2.32\r\n\r\n2022-04-15  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * fixed crash issue when sheet name is NULL (#109)\r\n\r\n0.2.31\r\n\r\n2022-02-16  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * changed free() to xlsxioread_free() in example_xlsxio_read.c (issue #73)\r\n\r\n0.2.30\r\n\r\n2021-09-01  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * added .pc and .cmake file generation and installation to CMakeLists.txt\r\n\r\n2021-03-12  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * remove <AppVersion> tag from xlsxio_write.c and put version information in <Application> (issue #91)\r\n\r\n2021-03-11  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * fix CMakeLists.txt to generate and install pkg-config .pc files\r\n\r\n2020-12-29  Viest  https://github.com/viest\r\n\r\n  * added XLSXIOREAD_SKIP_HIDDEN_ROWS to xlsxio_read.h, skipping hidden rows is no longer the default setting\r\n  \r\n2020-12-29  akuhtr  https://github.com/akuhtr\r\n\r\n  * fixed example in README.md to use xlsxioread_free() instead of free()\r\n  \r\n2020-07-12  Remi Collet  https://github.com/remicollet\r\n\r\n  * added XLSXIO_VERSION_ID to xlsxio_version.h\r\n  \r\n0.2.29\r\n\r\n2020-07-10  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * only treat sheet as a table (with header rows) when XLSXIOREAD_SKIP_EXTRA_CELLS flag is used (issue #75)\r\n  * added xlsxioread_free() to fix crashes when calling library build with different compiler (issue #73)\r\n\r\n0.2.28\r\n\r\n2020-07-06  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * fixed issues with XLSXIOREAD_SKIP_EMPTY_CELLS/XLSXIOREAD_SKIP_EMPTY_ROWS/XLSXIOREAD_SKIP_ALL_EMPTY/XLSXIOREAD_SKIP_EXTRA_CELLS (issue #75)\r\n\r\n0.2.27\r\n\r\n2020-07-05  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * fixed issues with XLSXIOREAD_SKIP_EMPTY_CELLS/XLSXIOREAD_SKIP_EMPTY_ROWS/XLSXIOREAD_SKIP_ALL_EMPTY (issue #74)\r\n\r\n2020-05-08  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * changed Makefile to also generate .def files to be included in Windows packages\r\n\r\n2020-03-20  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * accepted patch (#63) to add xlsxioread_sheet_last_column_index() and xlsxioread_sheet_flags()\r\n  * when Doxygen is available HTML documentation is installed in {PREFIX}/share/xlsxio/html\r\n\r\n0.2.26\r\n\r\n2020-03-20  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * accepted patch (#63) to add xlsxioread_sheet_last_column_index() and xlsxioread_sheet_flags()\r\n  * added xlsxioread_sheet_last_row_index()\r\n\r\n0.2.25\r\n\r\n2020-03-20  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * fixed memory leaks in xlsxioread_sheet_next_cell_int/xlsxioread_sheet_next_cell_float/xlsxioread_sheet_next_cell_datetime (issue #54)\r\n  * added xml:space=\"preserve\" to text cells to preserve spacing (issue #57)\r\n  * ran valgrind tests on xlsxio_xlsx2csv and xlsxio_csv2xlsx\r\n  * fixed memory leak in write_cell_data() in xlsxio_write.c (result of get_A1col was not freed)\r\n  * rewrote get_A1col() in in xlsxio_write.c to avoid issues on platforms where multiple calls to va_start()/va_end() don't work\r\n\r\n0.2.24\r\n\r\n2020-03-19  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * fixed memory leak (missing free(data->basepath) in main_sheet_get_sheetfile_callback when sheet filename not found)\r\n  * added support for .xlsm, .xltx and .xltm files (thanks to coproc for suggesting this in issue #61)\r\n\r\n0.2.23\r\n\r\n2020-03-09  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * fixed missing #include <stdio.h> in xlsxio_read.c, needed for sscanf()\r\n  * fixed clang warning \"format string is not a string literal\" in xlsxio_write.c\r\n\r\n0.2.22\r\n\r\n2020-03-09  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * fixed CMakeLists.txt issue where BUILD_XLSXIO_DLL was also defined for static libraries\r\n  * added .travis.yml to allow building with Travis CI (on Linux)\r\n  * changes to xlsxio_write.c to support minizip2\r\n\r\n0.2.21\r\n\r\n2018-12-14  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * changes to xlsxio_read.c for better Microsoft Visual C++ support\r\n  * added generation and installation of .def files when building with MinGW (can be used to generate Microsoft Visual C++ .lib files)\r\n  * added information README.md about creating .lib files when using Microsoft Visual C++\r\n\r\n0.2.20\r\n\r\n2018-06-23  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * fixed join_basepath_filename in xlsx_read.c to also support absolute paths (issue reported by Matthew James Briggs)\r\n  * added CMake options to specify custom dependancy paths: ZLIB_DIR/MINIZIP_DIR/LIBZIP_DIR/EXPAT_DIR (requested by Yann Ducruy)\r\n\r\n0.2.19\r\n\r\n2018-06-18  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * fixed crash in xlsx_read.c when XML_Char_openzip is called with empty filename (crash reported by Matthew James Briggs)\r\n  \r\n2018-05-17  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * fixed memory allocation issue when using minizip version of xlsx_read\r\n\r\n0.2.18\r\n\r\n2018-04-27  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * fixed formatting issue with cell coordinates\r\n  \r\n0.2.17\r\n\r\n2018-03-22  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * fixed crash when trying to write to an existing .xlsx that is locked (e.g. opened in Excel)\r\n\r\n0.2.16\r\n\r\n2018-03-18  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * fixed formatting issue with cell coordinates\r\n  \r\n0.2.15\r\n\r\n2018-03-18  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * removed \"OPTIONAL_LINE_BREAK\" from sheet1.xml in libxlsxio_write\r\n  * fixed error when opening generated .xlsx files with Gnumeric (added row and cell coordinate references in sheet1.xml and cellStyleXfs in styles.xml)\r\n\r\n0.2.14\r\n\r\n2018-03-16  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * fixed Makefile issues, now properly builds with WIDE=1\r\n  * added build instructions to README.md\r\n  * added example code to README.md\r\n\r\n0.2.13\r\n\r\n2018-03-16  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * fixed hang on Windows when building release version with MinGW-64 (fixed by using stricmp instead of strcasecmp)\r\n  * added CMake option WITH_WIDE to build UTF-16 library (libxlsxio_readw) - experimental, only tested on Windows\r\n\r\n0.2.12\r\n\r\n2018-03-15  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * added support for minizip and made this the default instead of libzip\r\n  * xlsxioread_open_memory() parameter data is no longer const void* but void* to allow free()\r\n  * fixed Doxygen warnings\r\n  * fixed CMake issues with Windows static libraries\r\n\r\n2018-02-03  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * modified Makefile to support WIDE=1 parameter to build UTF-16 library (libxlsxio_readw)\r\n\r\n0.2.11\r\n\r\n2017-12-31  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * fixed CMakeLists.txt for proper DLL builds on Windows\r\n\r\n2017-11-28  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * fixed bug in XML_Char_poscpy when compiled for UTF-16 (thanks to https://github.com/dsmccall)\r\n\r\n2017-11-16  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * fixed minor memory leak whean cleaning up shared string list\r\n\r\n2017-11-11  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * added wchar_t support, requires building with -DXML_UNICODE and expat also built with -DXML_UNICODE\r\n  * fixed memory issue in xlsxioread_process()\r\n\r\n2017-11-09  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * added xlsxioread_open_filehandle() to read file using file descriptor\r\n\r\n0.2.10\r\n\r\n2017-10-31  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * added xlsxioread_open_memory() to read file from memory buffer\r\n  * fixed xlsxio_read_sharedstrings.c not being compiled in Makefile\r\n\r\n0.2.9\r\n\r\n2017-07-12  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * use strcasecmp instead of stricmp\r\n  * move shared strings functionality from xlsxio_read.c to seperate file\r\n\r\n0.2.8\r\n\r\n2016-10-24  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * skip issue where \"(null)\" is written if cell data is NULL\r\n  * limit sheet name to 31 characters\r\n\r\n0.2.7\r\n\r\n2016-09-03  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * skip phonetic data in <rPh> tag also in shared strings\r\n\r\n0.2.6\r\n\r\n2016-08-31  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * skip phonetic data in <rPh> tag (often used in Asian spreadsheets)\r\n\r\n0.2.5\r\n\r\n2016-06-28  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * fix reading data from cells with mixed formatting (thanks to bcTekGuy)\r\n\r\n2016-06-16  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * use correct formula for calculating column widths\r\n  * add -d parameter to xlsxio_csv2xlsx\r\n\r\n0.2.4\r\n\r\n2016-05-12  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * fixed crash in xlsxioread_sheetlist_close() when parameter is NULL\r\n\r\n0.2.3\r\n\r\n2016-05-11  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * fixed CMake build to use proper static/shared defines\r\n  * reintroduce DLL_EXPORT_XLSXIO in .c files except for Visual C\r\n\r\n0.2.2\r\n\r\n2016-05-07  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * fixed some compiler warnings\r\n  * only use DLL_EXPORT_XLSXIO in .h files (removed from .c files)\r\n\r\n0.2.1\r\n\r\n2016-05-05  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * added CMake BUILD_DOCUMENTATION option (defaults to ON if Doxygen is detected)\r\n  * workaround for missing stdint.h/unistd.h on Visual C \r\n  * removed -pthread when building for Apple\r\n  * released Windows binaries (32-bit and 64-bit)\r\n\r\n0.2.0\r\n\r\n2016-04-28  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * added CMake support and tested on multiple platforms:\r\n      + Windows 10 with MinGW compiler using MSYS shell\r\n      + Debian Linux 8.4\r\n      + OS X 10.11.3\r\n\r\n2016-04-25  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * added lastModifiedBy property (set to \"libxlsxio_write <version>\")\r\n\r\n2016-04-16  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * example C++ classes: XLSXIOWriter, XLSXIOReader, XLSXIOReaderSheet\r\n\r\n2016-04-11  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * added more comments in example files\r\n  * renamed the following for better naming consistency:\r\n      + XLSXIO_READ_NAME to XLSXIOREAD_NAME\r\n      + XLSXIO_READ_FULLNAME to XLSXIOREAD_FULLNAME\r\n      + XLSXIO_WRITE_NAME to XLSXIOWRITE_NAME\r\n      + XLSXIO_WRITE_FULLNAME to XLSXIOWRITE_FULLNAME\r\n  * added support to xlsxio_csv2xlsx to use - as standard input\r\n\r\n0.1.9\r\n\r\n2016-04-10  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * added xlsxio_csv2xlsx command line utility\r\n  * fixed warning in xlsxio_xlsx2csv when compiling with clang\r\n\r\n0.1.8\r\n\r\n2016-04-07  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * fixed issue with callback data pointer in row callback function\r\n  * added xlsxio_xlsx2csv command line utility\r\n\r\n0.1.7\r\n\r\n2016-03-28  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * changed integer type to int64_t in xlsxiowrite_add_cell_int() and xlsxioread_sheet_next_cell_int()\r\n\r\n0.1.6\r\n\r\n2016-03-24  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * delete destination file before writing to it\r\n  * fixed corruption issue when closing if no rows were written\r\n\r\n0.1.5\r\n\r\n2016-03-20  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * fixed issue with detecting witdh of columns with NULL data\r\n  * changed witdh detection to only count first line of multiline data\r\n  * fixed issue with inserting empty rows\r\n  * only freezes top row when columns were specified\r\n\r\n0.1.4\r\n\r\n2016-03-19  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * optimized code for writing cell data\r\n  * added witdh parameter to xlsxiowrite_add_column()\r\n  * added column witdh detection and xlsxiowrite_set_detection_rows()\r\n  * added xlsxiowrite_set_row_height()\r\n\r\n0.1.3\r\n\r\n2016-03-17  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n  * now reading ignores hidden rows\r\n  * added support for writing column names: xlsxiowrite_add_column()\r\n  * simplified xlsxio_write.c by using FILE* handles\r\n  * added sheetname parameter to xlsxiowrite_open()\r\n\r\n0.1.2\r\n\r\n2016-03-15  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n\t* added xlsxioread_sheetlist_ functions for getting worksheet names\r\n\t* fixed Excel error: \"That command cannot be used on multiple selections\"\r\n\t* use simpler folder structure inside .xlsx file\r\n\r\n0.1.1\r\n\r\n2016-03-13  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n\t* added header file with version information\r\n\t* additional functions for reading cells (integer, floating point, date/time)\r\n\r\n2016-03-12  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n\t* add support multiline text fields\r\n\t* set date/time value to proper display format\r\n\r\n2016-03-09  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n\t* add support for reading next row without having read all columns\r\n\t* additional functions for writing cells (integer, floating point, date/time)\r\n\t* added encoding of special XML characters in string data\r\n\r\n0.1.0\r\n\r\n2016-03-08  Brecht Sanders  https://github.com/brechtsanders/\r\n\r\n\t* initial release of working version\r\n", "/*****************************************************************************\r\nCopyright (C)  2016  Brecht Sanders  All Rights Reserved\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\nTHE SOFTWARE.\r\n*****************************************************************************/\r\n\r\n/**\r\n * @file xlsxio_version.h\r\n * @brief XLSX I/O header file with version information.\r\n * @author Brecht Sanders\r\n *\r\n * Only use this header file when version information is needed at compile\r\n * time. Otherwise the version functions in the libraries should be used.\r\n * \\sa     XLSXIO_VERSION_*\r\n * \\sa     XLSXIO_VERSION_STRING\r\n * \\sa     xlsxioread_get_version()\r\n * \\sa     xlsxioread_get_version_string()\r\n * \\sa     xlsxiowrite_get_version()\r\n * \\sa     xlsxiowrite_get_version_string()\r\n */\r\n\r\n#ifndef INCLUDED_XLSXIO_VERSION_H\r\n#define INCLUDED_XLSXIO_VERSION_H\r\n\r\n/*! \\brief version number constants\r\n * \\sa     xlsxioread_get_version()\r\n * \\sa     xlsxiowrite_get_version()\r\n * \\name   XLSXIO_VERSION_*\r\n * \\{\r\n */\r\n/*! \\brief major version number */\r\n#define XLSXIO_VERSION_MAJOR 0\r\n/*! \\brief minor version number */\r\n#define XLSXIO_VERSION_MINOR 2\r\n/*! \\brief micro version number */\r\n#define XLSXIO_VERSION_MICRO 35\r\n/*! @} */\r\n\r\n/*! \\cond PRIVATE */\r\n#ifndef XML_UNICODE_WCHAR_T\r\n#define XLSXIO_VERSION_STRINGIZE_(major, minor, micro) #major\".\"#minor\".\"#micro\r\n#else\r\n#define XLSXIO_VERSION_STRINGIZE_(major, minor, micro) L ## #major\".\"#minor\".\"#micro\r\n#endif\r\n#define XLSXIO_VERSION_STRINGIZE(major, minor, micro) XLSXIO_VERSION_STRINGIZE_(major, minor, micro)\r\n/*! \\endcond */\r\n\r\n/*! \\brief string with dotted version number \\hideinitializer */\r\n#define XLSXIO_VERSION_STRING XLSXIO_VERSION_STRINGIZE(XLSXIO_VERSION_MAJOR, XLSXIO_VERSION_MINOR, XLSXIO_VERSION_MICRO)\r\n\r\n/*! \\brief integer version of the library \\hideinitializer */\r\n#define XLSXIO_VERSION_ID (XLSXIO_VERSION_MAJOR * 10000 + XLSXIO_VERSION_MINOR * 100 + XLSXIO_VERSION_MICRO)\r\n\r\n/*! \\brief string with name of XLSX I/O reading library */\r\n#define XLSXIOREAD_NAME \"libxlsxio_read\"\r\n/*! \\brief string with name of XLSX I/O writing library */\r\n#define XLSXIOWRITE_NAME \"libxlsxio_write\"\r\n\r\n/*! \\brief string with name and version of XLSX I/O reading library \\hideinitializer */\r\n#define XLSXIOREAD_FULLNAME XLSXIOREAD_NAME \" \" XLSXIO_VERSION_STRING\r\n/*! \\brief string with name and version of XLSX I/O writing library \\hideinitializer */\r\n#define XLSXIOWRITE_FULLNAME XLSXIOWRITE_NAME \" \" XLSXIO_VERSION_STRING\r\n\r\n#endif\r\n", "#include \"xlsxio_private.h\"\r\n#include \"xlsxio_read_sharedstrings.h\"\r\n#include \"xlsxio_read.h\"\r\n#include \"xlsxio_version.h\"\r\n#include <stdlib.h>\r\n#include <stdio.h>\r\n#include <inttypes.h>\r\n#include <string.h>\r\n#include <expat.h>\r\n\r\n#if defined(USE_MINIZIP) || defined(USE_MINIZIP_NG)\r\n#  ifdef USE_MINIZIP_NG\r\n#    include <mz_compat.h>\r\n#  else\r\n#    include <minizip/unzip.h>\r\n#  endif\r\n#  define ZIPFILETYPE unzFile\r\n#  define ZIPFILEENTRYTYPE unzFile\r\n#  if defined(_MSC_VER)\r\n#    include <io.h>\r\n#    define IOSIZETYPE int\r\n#    define IOFN(fn) _##fn\r\n#  else\r\n#    include <unistd.h>\r\n#    define IOSIZETYPE ssize_t\r\n#    define IOFN(fn) fn\r\n#  endif\r\n\r\n#  if defined(MZ_COMPRESS_METHOD_DEFLATE) // support minizip2 which defines MZ_COMPRESS_METHOD_DEFLATE instead of Z_DEFLATED\r\n#    ifndef ZCALLBACK\r\n#      define ZCALLBACK\r\n#    endif\r\n#    define voidpf void*\r\n#    define uLong  unsigned long\r\n#  endif\r\n\r\n#else\r\n#  if (defined(STATIC) || defined(BUILD_XLSXIO_STATIC) || defined(BUILD_XLSXIO_STATIC_DLL) || (defined(BUILD_XLSXIO) && !defined(BUILD_XLSXIO_DLL) && !defined(BUILD_XLSXIO_SHARED))) && !defined(ZIP_STATIC)\r\n#    define ZIP_STATIC\r\n#  endif\r\n#  include <zip.h>\r\n#  define ZIPFILETYPE zip_t\r\n#  define ZIPFILEENTRYTYPE zip_file_t\r\n#  ifndef USE_LIBZIP\r\n#    define USE_LIBZIP\r\n#  endif\r\n#endif\r\n\r\n#if defined(_MSC_VER)\r\n#  undef DLL_EXPORT_XLSXIO\r\n#  define DLL_EXPORT_XLSXIO\r\n#endif\r\n\r\n#define PARSE_BUFFER_SIZE 256\r\n//#define PARSE_BUFFER_SIZE 4\r\n\r\nstatic const XLSXIOCHAR* xlsx_content_type = X(\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml\");\r\nstatic const XLSXIOCHAR* xlsm_content_type = X(\"application/vnd.ms-excel.sheet.macroEnabled.main+xml\");\r\nstatic const XLSXIOCHAR* xltx_content_type = X(\"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml\");\r\nstatic const XLSXIOCHAR* xltm_content_type = X(\"application/vnd.ms-excel.template.macroEnabled.main+xml\");\r\n\r\n#if !defined(XML_UNICODE_WCHAR_T) && !defined(XML_UNICODE)\r\n\r\n//UTF-8 version\r\n#define XML_Char_dupchar strdup\r\n\r\nstatic ZIPFILEENTRYTYPE* XML_Char_openzip (ZIPFILETYPE* archive, const XML_Char* filename, int flags)\r\n{\r\n  if (!filename || !*filename)\r\n    return NULL;\r\n#ifdef USE_MINIZIP\r\n  if (unzLocateFile(archive, filename, 0) != UNZ_OK)\r\n    return NULL;\r\n  if (unzOpenCurrentFile(archive) != UNZ_OK)\r\n    return NULL;\r\n  return archive;\r\n#else\r\n  return zip_fopen(archive, filename, flags);\r\n#endif\r\n}\r\n\r\n#else\r\n\r\n//UTF-16 version\r\nstatic XML_Char* XML_Char_dupchar(const char* s)\r\n{\r\n  size_t len;\r\n  XML_Char* result;\r\n  if (!s || (len = mbstowcs(NULL, s, 0)) < 0)\r\n    return NULL;\r\n  if ((result = XML_Char_malloc(len + 1)) != NULL) {\r\n    if ((mbstowcs(result, s, len + 1) != len)) {\r\n      free(result);\r\n      return NULL;\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\nstatic char* chardupXML_Char(const XML_Char* s)\r\n{\r\n  size_t len;\r\n  char* result;\r\n  if (!s || (len = wcstombs(NULL, s, 0)) == -1)\r\n    return NULL;\r\n  if ((result = (char*)malloc(len + 1)) != NULL) {\r\n    if ((wcstombs(result, s, len + 1) != len)) {\r\n      free(result);\r\n      return NULL;\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\nstatic ZIPFILEENTRYTYPE* XML_Char_openzip (ZIPFILETYPE* archive, const XML_Char* filename, int flags)\r\n{\r\n  ZIPFILEENTRYTYPE* result;\r\n  char* s;\r\n  if (!filename || !*filename)\r\n    return NULL;\r\n  if ((s = chardupXML_Char(filename)) == NULL)\r\n    return NULL;\r\n#ifdef USE_MINIZIP\r\n  if (unzLocateFile(archive, s, 0) != UNZ_OK)\r\n    result = NULL;\r\n  else if (unzOpenCurrentFile(archive) != UNZ_OK)\r\n    result = NULL;\r\n  else\r\n    result = archive;\r\n#else\r\n  result = zip_fopen(archive, s, flags);\r\n#endif\r\n  free(s);\r\n  return result;\r\n}\r\n\r\n#endif\r\n\r\n\r\nDLL_EXPORT_XLSXIO void xlsxioread_get_version (int* pmajor, int* pminor, int* pmicro)\r\n{\r\n  if (pmajor)\r\n    *pmajor = XLSXIO_VERSION_MAJOR;\r\n  if (pminor)\r\n    *pminor = XLSXIO_VERSION_MINOR;\r\n  if (pmicro)\r\n    *pmicro = XLSXIO_VERSION_MICRO;\r\n}\r\n\r\nDLL_EXPORT_XLSXIO const XLSXIOCHAR* xlsxioread_get_version_string ()\r\n{\r\n  return (const XLSXIOCHAR*)XLSXIO_VERSION_STRING;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////\r\n\r\n//process XML file contents\r\nint expat_process_zip_file (ZIPFILETYPE* zip, const XML_Char* filename, XML_StartElementHandler start_handler, XML_EndElementHandler end_handler, XML_CharacterDataHandler data_handler, void* callbackdata, XML_Parser* xmlparser)\r\n{\r\n  ZIPFILEENTRYTYPE* zipfile;\r\n  XML_Parser parser;\r\n  void* buf;\r\n#ifdef USE_MINIZIP\r\n  int buflen;\r\n#else\r\n  zip_int64_t buflen;\r\n#endif\r\n  int done;\r\n  enum XML_Status status = XML_STATUS_ERROR;\r\n  if ((zipfile = XML_Char_openzip(zip, filename, 0)) == NULL) {\r\n    return -1;\r\n  }\r\n  parser = XML_ParserCreate(NULL);\r\n  XML_SetUserData(parser, callbackdata);\r\n  XML_SetElementHandler(parser, start_handler, end_handler);\r\n  XML_SetCharacterDataHandler(parser, data_handler);\r\n  if (xmlparser)\r\n    *xmlparser = parser;\r\n  buf = XML_GetBuffer(parser, PARSE_BUFFER_SIZE);\r\n#ifdef USE_MINIZIP\r\n    while (buf && (buflen = unzReadCurrentFile(zip, buf, PARSE_BUFFER_SIZE)) >= 0) {\r\n#else\r\n    while (buf && (buflen = zip_fread(zipfile, buf, PARSE_BUFFER_SIZE)) >= 0) {\r\n#endif\r\n      done = buflen < PARSE_BUFFER_SIZE;\r\n      if ((status = XML_ParseBuffer(parser, (int)buflen, (done ? 1 : 0))) == XML_STATUS_ERROR) {\r\n        break;\r\n      }\r\n      if (xmlparser && status == XML_STATUS_SUSPENDED)\r\n        return 0;\r\n      if (done)\r\n        break;\r\n      buf = XML_GetBuffer(parser, PARSE_BUFFER_SIZE);\r\n    }\r\n  XML_ParserFree(parser);\r\n#ifdef USE_MINIZIP\r\n  unzCloseCurrentFile(zip);\r\n#else\r\n  zip_fclose(zipfile);\r\n#endif\r\n  //return (status == XML_STATUS_ERROR != XML_ERROR_FINISHED ? 1 : 0);\r\n  return 0;\r\n}\r\n\r\nXML_Parser expat_process_zip_file_suspendable (ZIPFILEENTRYTYPE* zipfile, XML_StartElementHandler start_handler, XML_EndElementHandler end_handler, XML_CharacterDataHandler data_handler, void* callbackdata)\r\n{\r\n  XML_Parser result;\r\n  if ((result = XML_ParserCreate(NULL)) != NULL) {\r\n    XML_SetUserData(result, callbackdata);\r\n    XML_SetElementHandler(result, start_handler, end_handler);\r\n    XML_SetCharacterDataHandler(result, data_handler);\r\n  }\r\n  return result;\r\n}\r\n\r\nenum XML_Status expat_process_zip_file_resume (ZIPFILEENTRYTYPE* zipfile, XML_Parser xmlparser)\r\n{\r\n  enum XML_Status status;\r\n  status = XML_ResumeParser(xmlparser);\r\n  if (status == XML_STATUS_SUSPENDED)\r\n    return status;\r\n  if (status == XML_STATUS_ERROR && XML_GetErrorCode(xmlparser) != XML_ERROR_NOT_SUSPENDED)\r\n    return status;\r\n  void* buf;\r\n#ifdef USE_MINIZIP\r\n  int buflen;\r\n#else\r\n  zip_int64_t buflen;\r\n#endif\r\n  int done;\r\n  buf = XML_GetBuffer(xmlparser, PARSE_BUFFER_SIZE);\r\n#ifdef USE_MINIZIP\r\n  while (buf && (buflen = unzReadCurrentFile(zipfile, buf, PARSE_BUFFER_SIZE)) >= 0) {\r\n#else\r\n  while (buf && (buflen = zip_fread(zipfile, buf, PARSE_BUFFER_SIZE)) >= 0) {\r\n#endif\r\n    done = buflen < PARSE_BUFFER_SIZE;\r\n    if ((status = XML_ParseBuffer(xmlparser, (int)buflen, (done ? 1 : 0))) == XML_STATUS_ERROR)\r\n      return status;\r\n    if (status == XML_STATUS_SUSPENDED)\r\n      return status;\r\n    if (done)\r\n      break;\r\n    buf = XML_GetBuffer(xmlparser, PARSE_BUFFER_SIZE);\r\n  }\r\n  //XML_ParserFree(xmlparser);\r\n  return status;\r\n}\r\n\r\n//compare XML name ignoring case and ignoring namespace (returns 0 on match)\r\n#ifdef ASSUME_NO_NAMESPACE\r\n#define XML_Char_icmp_ins XML_Char_icmp\r\n#else\r\nint XML_Char_icmp_ins (const XML_Char* value, const XML_Char* name)\r\n{\r\n  size_t valuelen;\r\n  size_t namelen;\r\n  if (!value)\r\n    return (!name ? 0 : -1);\r\n  if (!name)\r\n    return -1;\r\n  valuelen = XML_Char_len(value);\r\n  namelen = XML_Char_len(name);\r\n  if (valuelen == namelen)\r\n    return XML_Char_icmp(value, name);\r\n  if (valuelen > namelen) {\r\n    if (value[valuelen - namelen - 1] != ':')\r\n      return 1;\r\n    return XML_Char_icmp(value + (valuelen - namelen), name);\r\n  }\r\n  return -1;\r\n}\r\n#endif\r\n\r\n//get expat attribute by name, returns NULL if not found\r\nconst XML_Char* get_expat_attr_by_name (const XML_Char** atts, const XML_Char* name)\r\n{\r\n  const XML_Char** p = atts;\r\n  if (p) {\r\n    while (*p) {\r\n      //if (XML_Char_icmp(*p++, name) == 0)\r\n      if (XML_Char_icmp_ins(*p++, name) == 0)\r\n        return *p;\r\n      p++;\r\n    }\r\n  }\r\n  return NULL;\r\n}\r\n\r\n//generate .rels filename, returns NULL on error, caller must free result\r\nXML_Char* get_relationship_filename (const XML_Char* filename)\r\n{\r\n  XML_Char* result;\r\n  size_t filenamelen = XML_Char_len(filename);\r\n  if ((result = XML_Char_malloc(filenamelen + 12)) != NULL) {\r\n    size_t i = filenamelen;\r\n    while (i > 0) {\r\n      if (filename[i - 1] == '/')\r\n        break;\r\n      i--;\r\n    }\r\n    XML_Char_poscpy(result, 0, filename, i);\r\n    XML_Char_poscpy(result, i, X(\"_rels/\"), 6);\r\n    XML_Char_poscpy(result, i + 6, filename + i, filenamelen - i);\r\n    XML_Char_poscpy(result, filenamelen + 6, X(\".rels\"), 6);\r\n  }\r\n  return result;\r\n}\r\n\r\n//join basepath and filename (caller must free result)\r\nXML_Char* join_basepath_filename (const XML_Char* basepath, const XML_Char* filename)\r\n{\r\n  XML_Char* result = NULL;\r\n  if (filename && *filename) {\r\n    if (filename[0] == '/' && filename[1]) {\r\n      //file is absolute: remove leading slash\r\n      result = XML_Char_dup(filename + 1);\r\n    } else {\r\n      //file is relative: prepend base path\r\n      size_t basepathlen = (basepath ? XML_Char_len(basepath) : 0);\r\n      size_t filenamelen = XML_Char_len(filename);\r\n      if ((result = XML_Char_malloc(basepathlen + filenamelen + 1)) != NULL) {\r\n        if (basepathlen > 0)\r\n          XML_Char_poscpy(result, 0, basepath, basepathlen);\r\n        XML_Char_poscpy(result, basepathlen, filename, filenamelen);\r\n        result[basepathlen + filenamelen] = 0;\r\n      }\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\n//determine column number based on cell coordinate (e.g. \"A1\"), returns 1-based column number or 0 on error\r\nsize_t get_col_nr (const XML_Char* A1col)\r\n{\r\n  const XML_Char* p = A1col;\r\n  size_t result = 0;\r\n  if (p) {\r\n    while (*p) {\r\n      if (*p >= 'A' && *p <= 'Z')\r\n        result = result * 26 + (*p - 'A') + 1;\r\n      else if (*p >= 'a' && *p <= 'z')\r\n        result = result * 26 + (*p - 'a') + 1;\r\n      else if (*p >= '0' && *p <= '9' && p != A1col)\r\n        return result;\r\n      else\r\n        break;\r\n      p++;\r\n    }\r\n  }\r\n  return 0;\r\n}\r\n\r\n//determine row number based on cell coordinate (e.g. \"A1\"), returns 1-based row number or 0 on error\r\nsize_t get_row_nr (const XML_Char* A1col)\r\n{\r\n  const XML_Char* p = A1col;\r\n  size_t result = 0;\r\n  if (p) {\r\n    while (*p) {\r\n      if ((*p >= 'A' && *p <= 'Z') || (*p >= 'a' && *p <= 'z'))\r\n        ;\r\n      else if (*p >= '0' && *p <= '9' && p != A1col)\r\n        result = result * 10 + (*p - '0');\r\n      else\r\n        return 0;\r\n      p++;\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////\r\n\r\nstruct xlsxio_read_struct {\r\n  ZIPFILETYPE* zip;\r\n};\r\n\r\nDLL_EXPORT_XLSXIO xlsxioreader xlsxioread_open (const char* filename)\r\n{\r\n  xlsxioreader result;\r\n  if ((result = (xlsxioreader)malloc(sizeof(struct xlsxio_read_struct))) != NULL) {\r\n#ifdef USE_MINIZIP\r\n    if ((result->zip = unzOpen(filename)) == NULL) {\r\n#else\r\n    if ((result->zip = zip_open(filename, ZIP_RDONLY, NULL)) == NULL) {\r\n#endif\r\n      free(result);\r\n      return NULL;\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\n#ifdef USE_MINIZIP\r\nstruct minizip_io_filehandle_data {\r\n  int filehandle;\r\n};\r\n\r\nvoidpf ZCALLBACK minizip_io_filehandle_open_file_fn (voidpf opaque, const char* filename, int mode)\r\n{\r\n  if (!opaque || ((struct minizip_io_filehandle_data*)opaque)->filehandle < 0)\r\n    return NULL;\r\n  return &((struct minizip_io_filehandle_data*)opaque)->filehandle;\r\n}\r\n\r\nuLong ZCALLBACK minizip_io_filehandle_read_file_fn (voidpf opaque, voidpf stream, void* buf, uLong size)\r\n{\r\n  IOSIZETYPE len;\r\n  if (!opaque || !stream || !buf || size == 0)\r\n    return 0;\r\n  if ((len = IOFN(read)(*(int*)stream, buf, size)) < 0)\r\n    return 0;\r\n  return len;\r\n}\r\n\r\n/*\r\nuLong ZCALLBACK minizip_io_filehandle_write_file_fn (voidpf opaque, voidpf stream, const void* buf, uLong size)\r\n{\r\n  return 0;\r\n}\r\n*/\r\n\r\nint ZCALLBACK minizip_io_filehandle_close_file_fn (voidpf opaque, voidpf stream)\r\n{\r\n  if (stream)\r\n    close(*(int*)stream);\r\n  free(opaque);\r\n  return 0;\r\n}\r\n\r\nint ZCALLBACK minizip_io_filehandle_testerror_file_fn (voidpf opaque, voidpf stream)\r\n{\r\n  return 0;\r\n}\r\n\r\nlong ZCALLBACK minizip_io_filehandle_tell_file_fn (voidpf opaque, voidpf stream)\r\n{\r\n  return IOFN(lseek)(*(int*)stream, 0, SEEK_CUR);\r\n}\r\n\r\nlong ZCALLBACK minizip_io_filehandle_seek_file_fn (voidpf opaque, voidpf stream, uLong offset, int origin)\r\n{\r\n  int whence;\r\n  if (!opaque || !stream)\r\n    return -1;\r\n  switch (origin) {\r\n    case ZLIB_FILEFUNC_SEEK_CUR :\r\n      whence = SEEK_CUR;\r\n      break;\r\n    case ZLIB_FILEFUNC_SEEK_END :\r\n      whence = SEEK_END;\r\n      break;\r\n    case ZLIB_FILEFUNC_SEEK_SET :\r\n      whence = SEEK_SET;\r\n      break;\r\n    default :\r\n      return -1;\r\n  }\r\n  return (IOFN(lseek)(*(int*)stream, offset, whence) >= 0 ? 0 : -1);\r\n}\r\n#endif\r\n\r\nDLL_EXPORT_XLSXIO xlsxioreader xlsxioread_open_filehandle (int filehandle)\r\n{\r\n  xlsxioreader result;\r\n  if ((result = (xlsxioreader)malloc(sizeof(struct xlsxio_read_struct))) != NULL) {\r\n#ifdef USE_MINIZIP\r\n    zlib_filefunc_def minizip_io_filehandle_functions;\r\n    if ((minizip_io_filehandle_functions.opaque = malloc(sizeof(struct minizip_io_filehandle_data))) == NULL) {\r\n      free(result);\r\n      return NULL;\r\n    }\r\n    minizip_io_filehandle_functions.zopen_file = minizip_io_filehandle_open_file_fn;\r\n    minizip_io_filehandle_functions.zread_file = minizip_io_filehandle_read_file_fn;\r\n    minizip_io_filehandle_functions.zwrite_file = /*minizip_io_filehandle_write_file_fn*/NULL;\r\n    minizip_io_filehandle_functions.ztell_file = minizip_io_filehandle_tell_file_fn;\r\n    minizip_io_filehandle_functions.zseek_file = minizip_io_filehandle_seek_file_fn;\r\n    minizip_io_filehandle_functions.zclose_file = minizip_io_filehandle_close_file_fn;\r\n    minizip_io_filehandle_functions.zerror_file = minizip_io_filehandle_testerror_file_fn;\r\n    ((struct minizip_io_filehandle_data*)minizip_io_filehandle_functions.opaque)->filehandle = filehandle;\r\n    if ((result->zip = unzOpen2(NULL, &minizip_io_filehandle_functions)) == NULL) {\r\n      free(result);\r\n      return NULL;\r\n    }\r\n#else\r\n    if ((result->zip = zip_fdopen(filehandle, ZIP_RDONLY, NULL)) == NULL) {\r\n      free(result);\r\n      return NULL;\r\n    }\r\n#endif\r\n  }\r\n  return result;\r\n}\r\n\r\n#ifdef USE_MINIZIP\r\nstruct minizip_io_memory_data {\r\n  void* data;\r\n  uint64_t datalen;\r\n  int freedata;\r\n};\r\n\r\nstruct minizip_io_memory_handle {\r\n  uint64_t pos;\r\n};\r\n\r\nvoidpf ZCALLBACK minizip_io_memory_open_file_fn (voidpf opaque, const char* filename, int mode)\r\n{\r\n  struct minizip_io_memory_handle* result;\r\n  if (!opaque || !((struct minizip_io_memory_data*)opaque)->data)\r\n    return NULL;\r\n  if ((result = (struct minizip_io_memory_handle*)malloc(sizeof(struct minizip_io_memory_handle))) != NULL) {\r\n    result->pos = 0;\r\n  }\r\n  return result;\r\n}\r\n\r\nuLong ZCALLBACK minizip_io_memory_read_file_fn (voidpf opaque, voidpf stream, void* buf, uLong size)\r\n{\r\n  uLong len;\r\n  if (!opaque || !stream || !buf || size == 0)\r\n    return 0;\r\n  if (((struct minizip_io_memory_handle*)stream)->pos + size <= ((struct minizip_io_memory_data*)opaque)->datalen)\r\n    len = size;\r\n  else\r\n    len = ((struct minizip_io_memory_data*)opaque)->datalen - ((struct minizip_io_memory_handle*)stream)->pos;\r\n  memcpy(buf, (char *)(((struct minizip_io_memory_data*)opaque)->data) + ((struct minizip_io_memory_handle*)stream)->pos, len);\r\n  ((struct minizip_io_memory_handle*)stream)->pos += len;\r\n  return len;\r\n}\r\n\r\n/*\r\nuLong ZCALLBACK minizip_io_memory_write_file_fn (voidpf opaque, voidpf stream, const void* buf, uLong size)\r\n{\r\n  return 0;\r\n}\r\n*/\r\n\r\nint ZCALLBACK minizip_io_memory_close_file_fn (voidpf opaque, voidpf stream)\r\n{\r\n  free(stream);\r\n  if (opaque && ((struct minizip_io_memory_data*)opaque)->freedata)\r\n    free(((struct minizip_io_memory_data*)opaque)->data);\r\n  free(opaque);\r\n  return 0;\r\n}\r\n\r\nint ZCALLBACK minizip_io_memory_testerror_file_fn (voidpf opaque, voidpf stream)\r\n{\r\n  return 0;\r\n}\r\n\r\nlong ZCALLBACK minizip_io_memory_tell_file_fn (voidpf opaque, voidpf stream)\r\n{\r\n  if (!opaque || !stream)\r\n    return 0;\r\n  return ((struct minizip_io_memory_handle*)stream)->pos;\r\n}\r\n\r\nlong ZCALLBACK minizip_io_memory_seek_file_fn (voidpf opaque, voidpf stream, uLong offset, int origin)\r\n{\r\n  switch (origin) {\r\n    case ZLIB_FILEFUNC_SEEK_CUR :\r\n      /*if (offset < 0) {\r\n        if (((struct minizip_io_memory_handle*)stream)->pos < -offset)\r\n          ((struct minizip_io_memory_handle*)stream)->pos = 0;\r\n        else\r\n          ((struct minizip_io_memory_handle*)stream)->pos += offset;\r\n      } else*/ {\r\n        if (((struct minizip_io_memory_handle*)stream)->pos + offset > ((struct minizip_io_memory_data*)opaque)->datalen)\r\n          ((struct minizip_io_memory_handle*)stream)->pos = ((struct minizip_io_memory_data*)opaque)->datalen;\r\n        else\r\n          ((struct minizip_io_memory_handle*)stream)->pos += offset;\r\n      }\r\n      break;\r\n    case ZLIB_FILEFUNC_SEEK_END :\r\n      /*if (offset < 0) {\r\n        if (((struct minizip_io_memory_data*)opaque)->datalen < -offset)\r\n          ((struct minizip_io_memory_handle*)stream)->pos = 0;\r\n        else\r\n          ((struct minizip_io_memory_handle*)stream)->pos = ((struct minizip_io_memory_data*)opaque)->datalen + offset;\r\n      } else*/ {\r\n        ((struct minizip_io_memory_handle*)stream)->pos = ((struct minizip_io_memory_data*)opaque)->datalen;\r\n      }\r\n      break;\r\n    case ZLIB_FILEFUNC_SEEK_SET :\r\n      /*if (offset < 0) {\r\n        ((struct minizip_io_memory_handle*)stream)->pos = 0;\r\n      } else*/ {\r\n        if (offset > ((struct minizip_io_memory_data*)opaque)->datalen)\r\n          ((struct minizip_io_memory_handle*)stream)->pos = ((struct minizip_io_memory_data*)opaque)->datalen;\r\n        else\r\n          ((struct minizip_io_memory_handle*)stream)->pos = offset;\r\n      }\r\n      ((struct minizip_io_memory_handle*)stream)->pos = offset;\r\n      break;\r\n    default :\r\n      return -1;\r\n  }\r\n  return 0;\r\n}\r\n#endif\r\n\r\nDLL_EXPORT_XLSXIO xlsxioreader xlsxioread_open_memory (void* data, uint64_t datalen, int freedata)\r\n{\r\n  xlsxioreader result;\r\n#ifdef USE_MINIZIP\r\n  if ((result = (xlsxioreader)malloc(sizeof(struct xlsxio_read_struct))) != NULL) {\r\n    zlib_filefunc_def minizip_io_memory_functions;\r\n    if ((minizip_io_memory_functions.opaque = malloc(sizeof(struct minizip_io_memory_data))) == NULL) {\r\n      free(result);\r\n      return NULL;\r\n    }\r\n    minizip_io_memory_functions.zopen_file = minizip_io_memory_open_file_fn;\r\n    minizip_io_memory_functions.zread_file = minizip_io_memory_read_file_fn;\r\n    minizip_io_memory_functions.zwrite_file = /*minizip_io_memory_write_file_fn*/NULL;\r\n    minizip_io_memory_functions.ztell_file = minizip_io_memory_tell_file_fn;\r\n    minizip_io_memory_functions.zseek_file = minizip_io_memory_seek_file_fn;\r\n    minizip_io_memory_functions.zclose_file = minizip_io_memory_close_file_fn;\r\n    minizip_io_memory_functions.zerror_file = minizip_io_memory_testerror_file_fn;\r\n    ((struct minizip_io_memory_data*)minizip_io_memory_functions.opaque)->data = data;\r\n    ((struct minizip_io_memory_data*)minizip_io_memory_functions.opaque)->datalen = datalen;\r\n    ((struct minizip_io_memory_data*)minizip_io_memory_functions.opaque)->freedata = freedata;\r\n    if ((result->zip = unzOpen2(NULL, &minizip_io_memory_functions)) == NULL) {\r\n      free(result);\r\n      return NULL;\r\n    }\r\n  }\r\n#else\r\n  zip_source_t* zipsrc;\r\n  if ((zipsrc = zip_source_buffer_create(data, datalen, freedata, NULL)) == NULL) {\r\n    return NULL;\r\n  }\r\n  if ((result = (xlsxioreader)malloc(sizeof(struct xlsxio_read_struct))) != NULL) {\r\n    if ((result->zip = zip_open_from_source(zipsrc, ZIP_RDONLY, NULL)) == NULL) {\r\n      zip_source_free(zipsrc);\r\n      free(result);\r\n      return NULL;\r\n    }\r\n  }\r\n#endif\r\n  return result;\r\n}\r\n\r\nDLL_EXPORT_XLSXIO void xlsxioread_close (xlsxioreader handle)\r\n{\r\n  if (handle) {\r\n    //note: no need to call zip_source_free() after successful use in zip_open_from_source()\r\n#ifdef USE_MINIZIP\r\n    unzClose(handle->zip);\r\n#else\r\n    zip_close(handle->zip);\r\n#endif\r\n    free(handle);\r\n  }\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////\r\n\r\n//callback function definition for use with iterate_files_by_contenttype\r\ntypedef void (*contenttype_file_callback_fn)(ZIPFILETYPE* zip, const XML_Char* filename, const XML_Char* contenttype, void* callbackdata);\r\n\r\nstruct iterate_files_by_contenttype_callback_data {\r\n  ZIPFILETYPE* zip;\r\n  const XML_Char* contenttype;\r\n  contenttype_file_callback_fn filecallbackfn;\r\n  void* filecallbackdata;\r\n};\r\n\r\n//expat callback function for element start used by iterate_files_by_contenttype\r\nvoid iterate_files_by_contenttype_expat_callback_element_start (void* callbackdata, const XML_Char* name, const XML_Char** atts)\r\n{\r\n  struct iterate_files_by_contenttype_callback_data* data = (struct iterate_files_by_contenttype_callback_data*)callbackdata;\r\n  if (XML_Char_icmp_ins(name, X(\"Override\")) == 0) {\r\n    //explicitly specified file\r\n    const XML_Char* contenttype;\r\n    const XML_Char* partname;\r\n    if ((contenttype = get_expat_attr_by_name(atts, X(\"ContentType\"))) != NULL && XML_Char_icmp(contenttype, data->contenttype) == 0) {\r\n      if ((partname = get_expat_attr_by_name(atts, X(\"PartName\"))) != NULL) {\r\n        if (partname[0] == '/')\r\n          partname++;\r\n        data->filecallbackfn(data->zip, partname, contenttype, data->filecallbackdata);\r\n      }\r\n    }\r\n  } else if (XML_Char_icmp_ins(name, X(\"Default\")) == 0) {\r\n    //by extension\r\n    const XML_Char* contenttype;\r\n    const XML_Char* extension;\r\n    if ((contenttype = get_expat_attr_by_name(atts, X(\"ContentType\"))) != NULL && XML_Char_icmp(contenttype, data->contenttype) == 0) {\r\n      if ((extension = get_expat_attr_by_name(atts, X(\"Extension\"))) != NULL) {\r\n        XML_Char* filename;\r\n        size_t filenamelen;\r\n        size_t extensionlen = XML_Char_len(extension);\r\n#ifdef USE_MINIZIP\r\n#define UNZIP_FILENAME_BUFFER_STEP 32\r\n        char* buf;\r\n        size_t buflen;\r\n        int status;\r\nunz_global_info zipglobalinfo;\r\nunzGetGlobalInfo(data->zip, &zipglobalinfo);\r\n        buf = (char*)malloc(buflen = UNZIP_FILENAME_BUFFER_STEP);\r\n        status = unzGoToFirstFile(data->zip);\r\n        while (status == UNZ_OK) {\r\n          buf[buflen - 1] = 0;\r\n          while ((status = unzGetCurrentFileInfo(data->zip, NULL, buf, buflen, NULL, 0, NULL, 0)) == UNZ_OK && buf[buflen - 1] != 0) {\r\n            buflen += UNZIP_FILENAME_BUFFER_STEP;\r\n            buf = (char*)realloc(buf, buflen);\r\n            buf[buflen - 1] = 0;\r\n          }\r\n          if (status != UNZ_OK)\r\n            break;\r\n          filename = XML_Char_dupchar(buf);\r\n          status = unzGoToNextFile(data->zip);\r\n#else\r\n        zip_int64_t i;\r\n        zip_int64_t zipnumfiles = zip_get_num_entries(data->zip, 0);\r\n        for (i = 0; i < zipnumfiles; i++) {\r\n          filename = XML_Char_dupchar(zip_get_name(data->zip, i, ZIP_FL_ENC_GUESS));\r\n#endif\r\n          filenamelen = XML_Char_len(filename);\r\n          if (filenamelen > extensionlen && filename[filenamelen - extensionlen - 1] == '.' && XML_Char_icmp(filename + filenamelen - extensionlen, extension) == 0) {\r\n            data->filecallbackfn(data->zip, filename, contenttype, data->filecallbackdata);\r\n          }\r\n          free(filename);\r\n        }\r\n#ifdef USE_MINIZIP\r\n        free(buf);\r\n#endif\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n//list file names by content type\r\nint iterate_files_by_contenttype (ZIPFILETYPE* zip, const XML_Char* contenttype, contenttype_file_callback_fn filecallbackfn, void* filecallbackdata, XML_Parser* xmlparser)\r\n{\r\n  struct iterate_files_by_contenttype_callback_data callbackdata = {\r\n    .zip = zip,\r\n    .contenttype = contenttype,\r\n    .filecallbackfn = filecallbackfn,\r\n    .filecallbackdata = filecallbackdata\r\n  };\r\n  return expat_process_zip_file(zip, X(\"[Content_Types].xml\"), iterate_files_by_contenttype_expat_callback_element_start, NULL, NULL, &callbackdata, xmlparser);\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////\r\n\r\n//callback structure used by main_sheet_list_expat_callback_element_start\r\nstruct main_sheet_list_callback_data {\r\n  XML_Parser xmlparser;\r\n  xlsxioread_list_sheets_callback_fn callback;\r\n  void* callbackdata;\r\n};\r\n\r\n//callback used by xlsxioread_list_sheets\r\nvoid main_sheet_list_expat_callback_element_start (void* callbackdata, const XML_Char* name, const XML_Char** atts)\r\n{\r\n  struct main_sheet_list_callback_data* data = (struct main_sheet_list_callback_data*)callbackdata;\r\n  if (data && data->callback) {\r\n    if (XML_Char_icmp_ins(name, X(\"sheet\")) == 0) {\r\n      const XML_Char* sheetname;\r\n      //const XML_Char* relid = get_expat_attr_by_name(atts, X(\"r:id\"));\r\n      if ((sheetname = get_expat_attr_by_name(atts, X(\"name\"))) != NULL) {\r\n        if (data->callback) {\r\n          if ((*data->callback)(sheetname, data->callbackdata) != 0) {\r\n            XML_StopParser(data->xmlparser, XML_FALSE);\r\n            return;\r\n          }\r\n/*\r\n        } else {\r\n          //for non-calback method suspend here\r\n          XML_StopParser(data->xmlparser, XML_TRUE);\r\n*/\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n//process contents each sheet listed in main sheet\r\nvoid xlsxioread_list_sheets_callback (ZIPFILETYPE* zip, const XML_Char* filename, const XML_Char* contenttype, void* callbackdata)\r\n{\r\n  //get sheet information from file\r\n  expat_process_zip_file(zip, filename, main_sheet_list_expat_callback_element_start, NULL, NULL, callbackdata, &((struct main_sheet_list_callback_data*)callbackdata)->xmlparser);\r\n}\r\n\r\n//list all worksheets\r\nDLL_EXPORT_XLSXIO void xlsxioread_list_sheets (xlsxioreader handle, xlsxioread_list_sheets_callback_fn callback, void* callbackdata)\r\n{\r\n  if (!handle || !callback)\r\n    return;\r\n  //process contents of main sheet\r\n  struct main_sheet_list_callback_data sheetcallbackdata = {\r\n    .xmlparser = NULL,\r\n    .callback = callback,\r\n    .callbackdata = callbackdata\r\n  };\r\n  iterate_files_by_contenttype(handle->zip, xlsx_content_type, xlsxioread_list_sheets_callback, &sheetcallbackdata, &sheetcallbackdata.xmlparser);\r\n  iterate_files_by_contenttype(handle->zip, xlsm_content_type, xlsxioread_list_sheets_callback, &sheetcallbackdata, &sheetcallbackdata.xmlparser);\r\n  iterate_files_by_contenttype(handle->zip, xltx_content_type, xlsxioread_list_sheets_callback, &sheetcallbackdata, &sheetcallbackdata.xmlparser);\r\n  iterate_files_by_contenttype(handle->zip, xltm_content_type, xlsxioread_list_sheets_callback, &sheetcallbackdata, &sheetcallbackdata.xmlparser);\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////\r\n\r\n//callback data structure used by main_sheet_get_sheetfile_callback\r\nstruct main_sheet_get_rels_callback_data {\r\n  XML_Parser xmlparser;\r\n  const XML_Char* sheetname;\r\n  XML_Char* basepath;\r\n  XML_Char* sheetrelid;\r\n  XML_Char* sheetfile;\r\n  XML_Char* sharedstringsfile;\r\n  XML_Char* stylesfile;\r\n};\r\n\r\n//determine relationship id for specific sheet name\r\nvoid main_sheet_get_relid_expat_callback_element_start (void* callbackdata, const XML_Char* name, const XML_Char** atts)\r\n{\r\n  struct main_sheet_get_rels_callback_data* data = (struct main_sheet_get_rels_callback_data*)callbackdata;\r\n  if (XML_Char_icmp_ins(name, X(\"sheet\")) == 0) {\r\n    const XML_Char* sheetname;\r\n    if ((sheetname = get_expat_attr_by_name(atts, X(\"name\"))) != NULL && (!data->sheetname || XML_Char_icmp(sheetname, data->sheetname) == 0)) {\r\n      const XML_Char* relid = get_expat_attr_by_name(atts, X(\"r:id\"));\r\n      if (relid && *relid) {\r\n        data->sheetrelid = XML_Char_dup(relid);\r\n        XML_StopParser(data->xmlparser, XML_FALSE);\r\n        return;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n//determine file names for specific relationship id\r\nvoid main_sheet_get_sheetfile_expat_callback_element_start (void* callbackdata, const XML_Char* name, const XML_Char** atts)\r\n{\r\n  struct main_sheet_get_rels_callback_data* data = (struct main_sheet_get_rels_callback_data*)callbackdata;\r\n  if (data->sheetrelid) {\r\n    if (XML_Char_icmp_ins(name, X(\"Relationship\")) == 0) {\r\n      const XML_Char* reltype;\r\n      if ((reltype = get_expat_attr_by_name(atts, X(\"Type\"))) != NULL) {\r\n        if (XML_Char_icmp(reltype, X(\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet\")) == 0) {\r\n          const XML_Char* relid = get_expat_attr_by_name(atts, X(\"Id\"));\r\n          if (XML_Char_icmp(relid, data->sheetrelid) == 0) {\r\n            const XML_Char* filename = get_expat_attr_by_name(atts, X(\"Target\"));\r\n            if (filename && *filename) {\r\n              data->sheetfile = join_basepath_filename(data->basepath, filename);\r\n            }\r\n          }\r\n        } else if (XML_Char_icmp(reltype, X(\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings\")) == 0) {\r\n          const XML_Char* filename = get_expat_attr_by_name(atts, X(\"Target\"));\r\n          if (filename && *filename) {\r\n            data->sharedstringsfile = join_basepath_filename(data->basepath, filename);\r\n          }\r\n        } else if (XML_Char_icmp(reltype, X(\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles\")) == 0) {\r\n          const XML_Char* filename = get_expat_attr_by_name(atts, X(\"Target\"));\r\n          if (filename && *filename) {\r\n            data->stylesfile = join_basepath_filename(data->basepath, filename);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n//determine the file name for a specified sheet name\r\nvoid main_sheet_get_sheetfile_callback (ZIPFILETYPE* zip, const XML_Char* filename, const XML_Char* contenttype, void* callbackdata)\r\n{\r\n  struct main_sheet_get_rels_callback_data* data = (struct main_sheet_get_rels_callback_data*)callbackdata;\r\n  if (!data->sheetrelid) {\r\n    expat_process_zip_file(zip, filename, main_sheet_get_relid_expat_callback_element_start, NULL, NULL, callbackdata, &data->xmlparser);\r\n  }\r\n  if (data->sheetrelid) {\r\n    XML_Char* relfilename;\r\n    //determine base name (including trailing slash)\r\n    size_t i = XML_Char_len(filename);\r\n    while (i > 0) {\r\n      if (filename[i - 1] == '/')\r\n        break;\r\n      i--;\r\n    }\r\n    if (data->basepath)\r\n      free(data->basepath);\r\n    if ((data->basepath = XML_Char_malloc(i + 1)) != NULL) {\r\n      XML_Char_poscpy(data->basepath, 0, filename, i);\r\n      data->basepath[i] = 0;\r\n    }\r\n    //find sheet filename in relationship contents\r\n    if ((relfilename = get_relationship_filename(filename)) != NULL) {\r\n      expat_process_zip_file(zip, relfilename, main_sheet_get_sheetfile_expat_callback_element_start, NULL, NULL, callbackdata, &data->xmlparser);\r\n      free(relfilename);\r\n    } else {\r\n      free(data->sheetrelid);\r\n      data->sheetrelid = NULL;\r\n      if (data->basepath) {\r\n        free(data->basepath);\r\n        data->basepath = NULL;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////\r\n\r\ntypedef enum {\r\n  none,\r\n  value_string,\r\n  inline_string,\r\n  shared_string\r\n} cell_string_type_enum;\r\n\r\n#define XLSXIOREAD_NO_CALLBACK          0x80\r\n\r\nstruct data_sheet_callback_data {\r\n  XML_Parser xmlparser;\r\n  struct sharedstringlist* sharedstrings;\r\n  size_t rownr;\r\n  size_t colnr;\r\n  size_t cols;\r\n  size_t colsnotnull;\r\n  XML_Char* celldata;\r\n  size_t celldatalen;\r\n  cell_string_type_enum cell_string_type;\r\n  unsigned int flags;\r\n  XML_Char* skiptag;                    //tag to skip\r\n  size_t skiptagcount;                  //nesting level for current tag to skip\r\n  XML_StartElementHandler skip_start;   //start handler to set after skipping\r\n  XML_EndElementHandler skip_end;       //end handler to set after skipping\r\n  XML_CharacterDataHandler skip_data;   //data handler to set after skipping\r\n  xlsxioread_process_row_callback_fn sheet_row_callback;\r\n  xlsxioread_process_cell_callback_fn sheet_cell_callback;\r\n  void* callbackdata;\r\n};\r\n\r\nvoid data_sheet_callback_data_initialize (struct data_sheet_callback_data* data, struct sharedstringlist* sharedstrings, unsigned int flags, xlsxioread_process_cell_callback_fn cell_callback, xlsxioread_process_row_callback_fn row_callback, void* callbackdata)\r\n{\r\n  data->xmlparser = NULL;\r\n  data->sharedstrings = sharedstrings;\r\n  data->rownr = 0;\r\n  data->colnr = 0;\r\n  data->cols = 0;\r\n  data->colsnotnull = 0;\r\n  data->celldata = NULL;\r\n  data->celldatalen = 0;\r\n  data->cell_string_type = none;\r\n  data->flags = flags;\r\n  data->skiptag = NULL;\r\n  data->skiptagcount = 0;\r\n  data->skip_start = NULL;\r\n  data->skip_end = NULL;\r\n  data->skip_data = NULL;\r\n  data->sheet_cell_callback = cell_callback;\r\n  data->sheet_row_callback = row_callback;\r\n  data->callbackdata = callbackdata;\r\n}\r\n\r\nvoid data_sheet_callback_data_cleanup (struct data_sheet_callback_data* data)\r\n{\r\n  sharedstringlist_destroy(data->sharedstrings);\r\n  free(data->celldata);\r\n  free(data->skiptag);\r\n}\r\n\r\nvoid data_sheet_expat_callback_skip_tag_start (void* callbackdata, const XML_Char* name, const XML_Char** atts)\r\n{\r\n  struct data_sheet_callback_data* data = (struct data_sheet_callback_data*)callbackdata;\r\n  if (name && XML_Char_icmp_ins(name, data->skiptag) == 0) {\r\n    //increment nesting level\r\n    data->skiptagcount++;\r\n  }\r\n}\r\n\r\nvoid data_sheet_expat_callback_skip_tag_end (void* callbackdata, const XML_Char* name)\r\n{\r\n  struct data_sheet_callback_data* data = (struct data_sheet_callback_data*)callbackdata;\r\n  if (!name || XML_Char_icmp_ins(name, data->skiptag) == 0) {\r\n    if (--data->skiptagcount == 0) {\r\n      //restore handlers when done skipping\r\n      XML_SetElementHandler(data->xmlparser, data->skip_start, data->skip_end);\r\n      XML_SetCharacterDataHandler(data->xmlparser, data->skip_data);\r\n      free(data->skiptag);\r\n      data->skiptag = NULL;\r\n    }\r\n  }\r\n}\r\n\r\nvoid data_sheet_expat_callback_find_worksheet_start (void* callbackdata, const XML_Char* name, const XML_Char** atts);\r\nvoid data_sheet_expat_callback_find_worksheet_end (void* callbackdata, const XML_Char* name);\r\nvoid data_sheet_expat_callback_find_sheetdata_start (void* callbackdata, const XML_Char* name, const XML_Char** atts);\r\nvoid data_sheet_expat_callback_find_sheetdata_end (void* callbackdata, const XML_Char* name);\r\nvoid data_sheet_expat_callback_find_row_start (void* callbackdata, const XML_Char* name, const XML_Char** atts);\r\nvoid data_sheet_expat_callback_find_row_end (void* callbackdata, const XML_Char* name);\r\nvoid data_sheet_expat_callback_find_cell_start (void* callbackdata, const XML_Char* name, const XML_Char** atts);\r\nvoid data_sheet_expat_callback_find_cell_end (void* callbackdata, const XML_Char* name);\r\nvoid data_sheet_expat_callback_find_value_start (void* callbackdata, const XML_Char* name, const XML_Char** atts);\r\nvoid data_sheet_expat_callback_find_value_end (void* callbackdata, const XML_Char* name);\r\nvoid data_sheet_expat_callback_value_data (void* callbackdata, const XML_Char* buf, int buflen);\r\n\r\nvoid data_sheet_expat_callback_find_worksheet_start (void* callbackdata, const XML_Char* name, const XML_Char** atts)\r\n{\r\n  struct data_sheet_callback_data* data = (struct data_sheet_callback_data*)callbackdata;\r\n  if (XML_Char_icmp_ins(name, X(\"worksheet\")) == 0) {\r\n    XML_SetElementHandler(data->xmlparser, data_sheet_expat_callback_find_sheetdata_start, NULL);\r\n  }\r\n}\r\n\r\nvoid data_sheet_expat_callback_find_worksheet_end (void* callbackdata, const XML_Char* name)\r\n{\r\n  struct data_sheet_callback_data* data = (struct data_sheet_callback_data*)callbackdata;\r\n  if (XML_Char_icmp_ins(name, X(\"worksheet\")) == 0) {\r\n    XML_SetElementHandler(data->xmlparser, data_sheet_expat_callback_find_worksheet_start, NULL);\r\n  }\r\n}\r\n\r\nvoid data_sheet_expat_callback_find_sheetdata_start (void* callbackdata, const XML_Char* name, const XML_Char** atts)\r\n{\r\n  struct data_sheet_callback_data* data = (struct data_sheet_callback_data*)callbackdata;\r\n  if (XML_Char_icmp_ins(name, X(\"sheetData\")) == 0) {\r\n    XML_SetElementHandler(data->xmlparser, data_sheet_expat_callback_find_row_start, data_sheet_expat_callback_find_sheetdata_end);\r\n  }\r\n}\r\n\r\nvoid data_sheet_expat_callback_find_sheetdata_end (void* callbackdata, const XML_Char* name)\r\n{\r\n  struct data_sheet_callback_data* data = (struct data_sheet_callback_data*)callbackdata;\r\n  if (XML_Char_icmp_ins(name, X(\"sheetData\")) == 0) {\r\n    XML_SetElementHandler(data->xmlparser, data_sheet_expat_callback_find_sheetdata_start, data_sheet_expat_callback_find_worksheet_end);\r\n  } else {\r\n    data_sheet_expat_callback_find_worksheet_end(callbackdata, name);\r\n  }\r\n}\r\n\r\nvoid data_sheet_expat_callback_find_row_start (void* callbackdata, const XML_Char* name, const XML_Char** atts)\r\n{\r\n  struct data_sheet_callback_data* data = (struct data_sheet_callback_data*)callbackdata;\r\n  if (XML_Char_icmp_ins(name, X(\"row\")) == 0) {\r\n    const XML_Char* hidden = get_expat_attr_by_name(atts, X(\"hidden\"));\r\n    if (!(hidden && XML_Char_tol(hidden) != 0 && (data->flags & XLSXIOREAD_SKIP_HIDDEN_ROWS))) {\r\n      int skippedemptyrow = (data->rownr != 0 && data->colsnotnull == 0 && (data->flags & XLSXIOREAD_SKIP_EMPTY_ROWS));\r\n      data->rownr++;\r\n      data->colnr = 0;\r\n      data->colsnotnull = 0;\r\n      XML_SetElementHandler(data->xmlparser, data_sheet_expat_callback_find_cell_start, data_sheet_expat_callback_find_row_end);\r\n      //for non-calback method suspend here on new row\r\n      if (data->flags & XLSXIOREAD_NO_CALLBACK) {\r\n        if (!skippedemptyrow) {\r\n          XML_StopParser(data->xmlparser, XML_TRUE);\r\n        }\r\n      }\r\n    } else {\r\n      //skip hidden row\r\n      XML_SetElementHandler(data->xmlparser, NULL, data_sheet_expat_callback_find_row_end);\r\n    }\r\n  }\r\n}\r\n\r\nvoid data_sheet_expat_callback_find_row_end (void* callbackdata, const XML_Char* name)\r\n{\r\n  struct data_sheet_callback_data* data = (struct data_sheet_callback_data*)callbackdata;\r\n  if (XML_Char_icmp_ins(name, X(\"row\")) == 0) {\r\n    //determine number of columns based on first row\r\n    if ((data->flags & XLSXIOREAD_SKIP_EXTRA_CELLS) && data->rownr == 1 && data->cols == 0)\r\n      data->cols = data->colnr;\r\n    //add empty columns if needed\r\n    if (!(data->flags & XLSXIOREAD_NO_CALLBACK) && data->sheet_cell_callback && !(data->flags & XLSXIOREAD_SKIP_EMPTY_CELLS)) {\r\n      while (data->colnr < data->cols) {\r\n        if ((*data->sheet_cell_callback)(data->rownr, data->colnr + 1, NULL, data->callbackdata)) {\r\n          XML_StopParser(data->xmlparser, XML_FALSE);\r\n          return;\r\n        }\r\n        data->colnr++;\r\n      }\r\n    }\r\n    free(data->celldata);\r\n    data->celldata = NULL;\r\n    XML_SetElementHandler(data->xmlparser, data_sheet_expat_callback_find_row_start, data_sheet_expat_callback_find_sheetdata_end);\r\n    //process end of row\r\n    if (!(data->flags & XLSXIOREAD_NO_CALLBACK)) {\r\n      if (data->sheet_row_callback && !(data->colsnotnull == 0 && (data->flags & XLSXIOREAD_SKIP_EMPTY_ROWS))) {\r\n        if ((*data->sheet_row_callback)(data->rownr, data->colnr, data->callbackdata)) {\r\n          XML_StopParser(data->xmlparser, XML_FALSE);\r\n          return;\r\n        }\r\n      }\r\n    } else {\r\n      //for non-calback method suspend here on end of row\r\n      if (!(data->colsnotnull == 0 && (data->flags & XLSXIOREAD_SKIP_EMPTY_ROWS)))\r\n        XML_StopParser(data->xmlparser, XML_TRUE);\r\n    }\r\n  } else {\r\n    data_sheet_expat_callback_find_sheetdata_end(callbackdata, name);\r\n  }\r\n}\r\n\r\nvoid data_sheet_expat_callback_find_cell_start (void* callbackdata, const XML_Char* name, const XML_Char** atts)\r\n{\r\n  struct data_sheet_callback_data* data = (struct data_sheet_callback_data*)callbackdata;\r\n  if (XML_Char_icmp_ins(name, X(\"c\")) == 0) {\r\n    const XML_Char* t = get_expat_attr_by_name(atts, X(\"r\"));\r\n    size_t cellcolnr = get_col_nr(t);\r\n    //insert empty rows if needed\r\n    if (data->colnr == 0) {\r\n      size_t cellrownr = get_row_nr(t);\r\n      if (cellrownr) {\r\n        if (!(data->flags & XLSXIOREAD_SKIP_EMPTY_ROWS) && !(data->flags & XLSXIOREAD_NO_CALLBACK)) {\r\n          while (data->rownr < cellrownr) {\r\n            //insert empty columns\r\n            if (!(data->flags & XLSXIOREAD_SKIP_EMPTY_CELLS) && data->sheet_cell_callback) {\r\n              while (data->colnr < data->cols) {\r\n                if ((*data->sheet_cell_callback)(data->rownr, data->colnr + 1, NULL, data->callbackdata)) {\r\n                  XML_StopParser(data->xmlparser, XML_FALSE);\r\n                  return;\r\n                }\r\n                data->colnr++;\r\n              }\r\n            }\r\n            //finish empty row\r\n            if (data->sheet_row_callback) {\r\n              if ((*data->sheet_row_callback)(data->rownr, data->cols, data->callbackdata)) {\r\n                XML_StopParser(data->xmlparser, XML_FALSE);\r\n                return;\r\n              }\r\n            }\r\n            data->rownr++;\r\n            data->colnr = 0;\r\n          }\r\n        } else {\r\n          data->rownr = cellrownr;\r\n        }\r\n      }\r\n    }\r\n    //insert empty columns if needed\r\n    if (cellcolnr) {\r\n      cellcolnr--;\r\n      if ((data->flags & XLSXIOREAD_SKIP_EMPTY_CELLS) || data->colnr == 0 || (data->flags & XLSXIOREAD_NO_CALLBACK)) {\r\n        data->colnr = cellcolnr;\r\n      } else {\r\n        size_t cellmax = cellcolnr;\r\n        if ((data->flags & XLSXIOREAD_SKIP_EXTRA_CELLS) && data->cols > 0 && cellmax > data->cols)\r\n          cellmax = data->cols;\r\n        while (data->colnr < cellmax) {\r\n          if (data->colnr > 0 && data->sheet_cell_callback) {\r\n            if ((*data->sheet_cell_callback)(data->rownr, data->colnr + 1, NULL, data->callbackdata)) {\r\n              XML_StopParser(data->xmlparser, XML_FALSE);\r\n              return;\r\n            }\r\n          }\r\n          data->colnr++;\r\n        }\r\n      }\r\n    }\r\n    //determing value type\r\n    if ((t = get_expat_attr_by_name(atts, X(\"t\"))) != NULL && XML_Char_icmp(t, X(\"s\")) == 0)\r\n      data->cell_string_type = shared_string;\r\n    else\r\n      data->cell_string_type = value_string;\r\n    //prepare empty value data\r\n    free(data->celldata);\r\n    data->celldata = NULL;\r\n    data->celldatalen = 0;\r\n    XML_SetElementHandler(data->xmlparser, data_sheet_expat_callback_find_value_start, data_sheet_expat_callback_find_cell_end);\r\n  }\r\n}\r\n\r\nvoid data_sheet_expat_callback_find_cell_end (void* callbackdata, const XML_Char* name)\r\n{\r\n  struct data_sheet_callback_data* data = (struct data_sheet_callback_data*)callbackdata;\r\n  if (XML_Char_icmp_ins(name, X(\"c\")) == 0) {\r\n    //determine value\r\n    if (data->celldata) {\r\n      data->celldata[data->celldatalen] = 0;\r\n      if (data->cell_string_type == shared_string) {\r\n        //get shared string\r\n        XML_Char* p = NULL;\r\n        long num = XML_Char_strtol(data->celldata, &p, 10);\r\n        if (!p || (p != data->celldata && *p == 0)) {\r\n          const XML_Char* s = sharedstringlist_get(data->sharedstrings, num);\r\n          free(data->celldata);\r\n          data->celldata = (s ? XML_Char_dup(s) : NULL);\r\n        }\r\n      } else if (data->cell_string_type == none) {\r\n        //unknown value type\r\n        free(data->celldata);\r\n        data->celldata = NULL;\r\n      }\r\n    }\r\n    //reset data\r\n    data->colnr++;\r\n    data->cell_string_type = none;\r\n    data->celldatalen = 0;\r\n    XML_SetElementHandler(data->xmlparser, data_sheet_expat_callback_find_cell_start, data_sheet_expat_callback_find_row_end);\r\n    XML_SetCharacterDataHandler(data->xmlparser, NULL);\r\n    //process data if needed\r\n    if (data->celldata || !((data->flags & XLSXIOREAD_SKIP_EMPTY_CELLS) || ((data->flags & XLSXIOREAD_SKIP_EMPTY_ROWS) && data->colsnotnull == 0))) {\r\n      if (!((data->flags & XLSXIOREAD_SKIP_EXTRA_CELLS) && data->cols > 0 && data->colnr > data->cols)) {\r\n        //process data\r\n        if (!(data->flags & XLSXIOREAD_NO_CALLBACK)) {\r\n          if (data->sheet_cell_callback) {\r\n            //insert empty columns if needed in case of empty row detection\r\n            /////if ((data->flags & XLSXIOREAD_SKIP_EMPTY_ROWS) && !(data->flags & XLSXIOREAD_SKIP_EMPTY_CELLS) && data->colsnotnull == 0 && data->colnr > 1) {\r\n            if (!(data->flags & XLSXIOREAD_SKIP_EMPTY_CELLS) && data->colsnotnull == 0 && data->colnr > 1) {\r\n              size_t col;\r\n              for (col = 1; col < data->colnr; col++) {\r\n                if ((*data->sheet_cell_callback)(data->rownr, col, NULL, data->callbackdata)) {\r\n                  XML_StopParser(data->xmlparser, XML_FALSE);\r\n                  return;\r\n                }\r\n              }\r\n            }\r\n            //process current column data\r\n            if ((*data->sheet_cell_callback)(data->rownr, data->colnr, data->celldata, data->callbackdata)) {\r\n              XML_StopParser(data->xmlparser, XML_FALSE);\r\n              return;\r\n            }\r\n            data->colsnotnull++;\r\n          }\r\n        } else {\r\n          //for non-calback method suspend here with cell data (don't return NULL as that is used to indicate end of row)\r\n          if (!data->celldata)\r\n            data->celldata = XML_Char_dup(X(\"\"));\r\n          XML_StopParser(data->xmlparser, XML_TRUE);\r\n          data->colsnotnull++;\r\n        }\r\n      }\r\n    }\r\n  } else {\r\n    data_sheet_expat_callback_find_row_end(callbackdata, name);\r\n  }\r\n}\r\n\r\nvoid data_sheet_expat_callback_find_value_start (void* callbackdata, const XML_Char* name, const XML_Char** atts)\r\n{\r\n  struct data_sheet_callback_data* data = (struct data_sheet_callback_data*)callbackdata;\r\n  if (XML_Char_icmp_ins(name, X(\"v\")) == 0 || XML_Char_icmp_ins(name, X(\"t\")) == 0) {\r\n    XML_SetElementHandler(data->xmlparser, NULL, data_sheet_expat_callback_find_value_end);\r\n    XML_SetCharacterDataHandler(data->xmlparser, data_sheet_expat_callback_value_data);\r\n  } else if (XML_Char_icmp_ins(name, X(\"is\")) == 0) {\r\n    data->cell_string_type = inline_string;\r\n  } else if (XML_Char_icmp_ins(name, X(\"rPh\")) == 0) {\r\n    data->skiptag = XML_Char_dup(name);\r\n    data->skiptagcount = 1;\r\n    data->skip_start = data_sheet_expat_callback_find_value_start;\r\n    data->skip_end = data_sheet_expat_callback_find_cell_end;\r\n    data->skip_data = NULL;\r\n    XML_SetElementHandler(data->xmlparser, data_sheet_expat_callback_skip_tag_start, data_sheet_expat_callback_skip_tag_end);\r\n    XML_SetCharacterDataHandler(data->xmlparser, NULL);\r\n  }\r\n}\r\n\r\nvoid data_sheet_expat_callback_find_value_end (void* callbackdata, const XML_Char* name)\r\n{\r\n  struct data_sheet_callback_data* data = (struct data_sheet_callback_data*)callbackdata;\r\n  if (XML_Char_icmp_ins(name, X(\"v\")) == 0 || XML_Char_icmp_ins(name, X(\"t\")) == 0) {\r\n    XML_SetElementHandler(data->xmlparser, data_sheet_expat_callback_find_value_start, data_sheet_expat_callback_find_cell_end);\r\n    XML_SetCharacterDataHandler(data->xmlparser, NULL);\r\n  } else if (XML_Char_icmp_ins(name, X(\"is\")) == 0) {\r\n    data->cell_string_type = none;\r\n  } else {\r\n    data_sheet_expat_callback_find_row_end(callbackdata, name);\r\n  }\r\n}\r\n\r\nvoid data_sheet_expat_callback_value_data (void* callbackdata, const XML_Char* buf, int buflen)\r\n{\r\n  struct data_sheet_callback_data* data = (struct data_sheet_callback_data*)callbackdata;\r\n  if (data->cell_string_type != none) {\r\n    if ((data->celldata = XML_Char_realloc(data->celldata, data->celldatalen + buflen + 1)) == NULL) {\r\n      //memory allocation error\r\n      data->celldatalen = 0;\r\n    } else {\r\n      //add new data to value buffer\r\n      XML_Char_poscpy(data->celldata, data->celldatalen, buf, buflen);\r\n      data->celldatalen += buflen;\r\n    }\r\n  }\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////\r\n\r\nstruct xlsxio_read_sheet_struct {\r\n  xlsxioreader handle;\r\n  ZIPFILEENTRYTYPE* zipfile;\r\n  struct data_sheet_callback_data processcallbackdata;\r\n  size_t lastrownr;\r\n  size_t paddingrow;\r\n  size_t lastcolnr;\r\n  size_t paddingcol;\r\n};\r\n\r\nDLL_EXPORT_XLSXIO size_t xlsxioread_sheet_last_row_index (xlsxioreadersheet sheethandle)\r\n{\r\n  return sheethandle->lastrownr;\r\n}\r\n\r\nDLL_EXPORT_XLSXIO size_t xlsxioread_sheet_last_column_index (xlsxioreadersheet sheethandle)\r\n{\r\n  return sheethandle->lastcolnr;\r\n}\r\n\r\nDLL_EXPORT_XLSXIO unsigned int xlsxioread_sheet_flags (xlsxioreadersheet sheethandle)\r\n{\r\n  return sheethandle->processcallbackdata.flags;\r\n}\r\n\r\nDLL_EXPORT_XLSXIO int xlsxioread_process (xlsxioreader handle, const XLSXIOCHAR* sheetname, unsigned int flags, xlsxioread_process_cell_callback_fn cell_callback, xlsxioread_process_row_callback_fn row_callback, void* callbackdata)\r\n{\r\n  int result = 0;\r\n  //determine sheet file name\r\n  struct main_sheet_get_rels_callback_data getrelscallbackdata = {\r\n    .sheetname = sheetname,\r\n    .basepath = NULL,\r\n    .sheetrelid = NULL,\r\n    .sheetfile = NULL,\r\n    .sharedstringsfile = NULL,\r\n    .stylesfile = NULL\r\n  };\r\n  iterate_files_by_contenttype(handle->zip, xlsx_content_type, main_sheet_get_sheetfile_callback, &getrelscallbackdata, NULL);\r\n  if (!getrelscallbackdata.sheetrelid)\r\n    iterate_files_by_contenttype(handle->zip, xlsm_content_type, main_sheet_get_sheetfile_callback, &getrelscallbackdata, NULL);\r\n  if (!getrelscallbackdata.sheetrelid)\r\n    iterate_files_by_contenttype(handle->zip, xltx_content_type, main_sheet_get_sheetfile_callback, &getrelscallbackdata, NULL);\r\n  if (!getrelscallbackdata.sheetrelid)\r\n    iterate_files_by_contenttype(handle->zip, xltm_content_type, main_sheet_get_sheetfile_callback, &getrelscallbackdata, NULL);\r\n\r\n  //process shared strings\r\n  struct sharedstringlist* sharedstrings = NULL;\r\n  if (getrelscallbackdata.sharedstringsfile && getrelscallbackdata.sharedstringsfile[0]) {\r\n    sharedstrings = sharedstringlist_create();\r\n    struct shared_strings_callback_data sharedstringsdata;\r\n    shared_strings_callback_data_initialize(&sharedstringsdata, sharedstrings);\r\n    if (expat_process_zip_file(handle->zip, getrelscallbackdata.sharedstringsfile, shared_strings_callback_find_sharedstringtable_start, NULL, NULL, &sharedstringsdata, &sharedstringsdata.xmlparser) != 0) {\r\n      //no shared strings found\r\n      sharedstringlist_destroy(sharedstrings);\r\n      sharedstrings = NULL;\r\n    }\r\n    shared_strings_callback_data_cleanup(&sharedstringsdata);\r\n  }\r\n\r\n  //process sheet\r\n  if (!(flags & XLSXIOREAD_NO_CALLBACK)) {\r\n    //use callback mechanism\r\n    struct data_sheet_callback_data processcallbackdata;\r\n    data_sheet_callback_data_initialize(&processcallbackdata, sharedstrings, flags, cell_callback, row_callback, callbackdata);\r\n    expat_process_zip_file(handle->zip, getrelscallbackdata.sheetfile, data_sheet_expat_callback_find_worksheet_start, NULL, NULL, &processcallbackdata, &processcallbackdata.xmlparser);\r\n    data_sheet_callback_data_cleanup(&processcallbackdata);\r\n  } else {\r\n    //use simplified interface by suspending the XML parser when data is found\r\n    xlsxioreadersheet sheethandle = (xlsxioreadersheet)callbackdata;\r\n    data_sheet_callback_data_initialize(&sheethandle->processcallbackdata, sharedstrings, flags, NULL, NULL, sheethandle);\r\n    if ((sheethandle->zipfile = XML_Char_openzip(sheethandle->handle->zip, getrelscallbackdata.sheetfile, 0)) == NULL) {\r\n      result = 1;\r\n    }\r\n    if ((sheethandle->processcallbackdata.xmlparser = expat_process_zip_file_suspendable(sheethandle->zipfile, data_sheet_expat_callback_find_worksheet_start, NULL, NULL, &sheethandle->processcallbackdata)) == NULL) {\r\n      result = 2;\r\n    }\r\n  }\r\n\r\n  //clean up\r\n  free(getrelscallbackdata.basepath);\r\n  free(getrelscallbackdata.sheetrelid);\r\n  free(getrelscallbackdata.sheetfile);\r\n  free(getrelscallbackdata.sharedstringsfile);\r\n  free(getrelscallbackdata.stylesfile);\r\n  return result;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////\r\n\r\nstruct xlsxio_read_sheetlist_struct {\r\n  xlsxioreader handle;\r\n  ZIPFILEENTRYTYPE* zipfile;\r\n  struct main_sheet_list_callback_data sheetcallbackdata;\r\n  XML_Parser xmlparser;\r\n  XML_Char* nextsheetname;\r\n};\r\n\r\nint xlsxioread_list_sheets_resumable_callback (const XLSXIOCHAR* name, void* callbackdata)\r\n{\r\n  //struct main_sheet_list_callback_data* data = (struct main_sheet_list_callback_data*)callbackdata;\r\n  xlsxioreadersheetlist data = (xlsxioreadersheetlist)callbackdata;\r\n  data->nextsheetname = XML_Char_dup(name);\r\n  XML_StopParser(data->xmlparser, XML_TRUE);\r\n  return 0;\r\n}\r\n\r\nvoid xlsxioread_find_main_sheet_file_callback (ZIPFILETYPE* zip, const XML_Char* filename, const XML_Char* contenttype, void* callbackdata)\r\n{\r\n  XML_Char** data = (XML_Char**)callbackdata;\r\n  *data = XML_Char_dup(filename);\r\n}\r\n\r\nDLL_EXPORT_XLSXIO xlsxioreadersheetlist xlsxioread_sheetlist_open (xlsxioreader handle)\r\n{\r\n  //determine main sheet name\r\n  XML_Char* mainsheetfile = NULL;\r\n  iterate_files_by_contenttype(handle->zip, xlsx_content_type, xlsxioread_find_main_sheet_file_callback, &mainsheetfile, NULL);\r\n  if (!mainsheetfile)\r\n    iterate_files_by_contenttype(handle->zip, xlsm_content_type, xlsxioread_find_main_sheet_file_callback, &mainsheetfile, NULL);\r\n  if (!mainsheetfile)\r\n    iterate_files_by_contenttype(handle->zip, xltx_content_type, xlsxioread_find_main_sheet_file_callback, &mainsheetfile, NULL);\r\n  if (!mainsheetfile)\r\n    iterate_files_by_contenttype(handle->zip, xltm_content_type, xlsxioread_find_main_sheet_file_callback, &mainsheetfile, NULL);\r\n  if (!mainsheetfile)\r\n    return NULL;\r\n  //process contents of main sheet\r\n  xlsxioreadersheetlist result;\r\n  if ((result = (xlsxioreadersheetlist)malloc(sizeof(struct xlsxio_read_sheetlist_struct))) == NULL)\r\n    return NULL;\r\n  result->handle = handle;\r\n  result->sheetcallbackdata.xmlparser = NULL;\r\n  result->sheetcallbackdata.callback = xlsxioread_list_sheets_resumable_callback;\r\n  result->sheetcallbackdata.callbackdata = result;\r\n  result->xmlparser = NULL;\r\n  result->nextsheetname = NULL;\r\n  if ((result->zipfile = XML_Char_openzip(handle->zip, mainsheetfile, 0)) != NULL) {\r\n    result->xmlparser = expat_process_zip_file_suspendable(result->zipfile, main_sheet_list_expat_callback_element_start, NULL, NULL, &result->sheetcallbackdata);\r\n  }\r\n  //clean up\r\n  free(mainsheetfile);\r\n  return result;\r\n}\r\n\r\nDLL_EXPORT_XLSXIO void xlsxioread_sheetlist_close (xlsxioreadersheetlist sheetlisthandle)\r\n{\r\n  if (!sheetlisthandle)\r\n    return;\r\n  if (sheetlisthandle->xmlparser)\r\n    XML_ParserFree(sheetlisthandle->xmlparser);\r\n  if (sheetlisthandle->zipfile)\r\n#ifdef USE_MINIZIP\r\n    unzCloseCurrentFile(sheetlisthandle->zipfile);\r\n#else\r\n    zip_fclose(sheetlisthandle->zipfile);\r\n#endif\r\n  free(sheetlisthandle->nextsheetname);\r\n  free(sheetlisthandle);\r\n\r\n}\r\n\r\nDLL_EXPORT_XLSXIO const XLSXIOCHAR* xlsxioread_sheetlist_next (xlsxioreadersheetlist sheetlisthandle)\r\n{\r\n  if (!sheetlisthandle->zipfile || !sheetlisthandle->xmlparser)\r\n    return NULL;\r\n  free(sheetlisthandle->nextsheetname);\r\n  sheetlisthandle->nextsheetname = NULL;\r\n  enum XML_Status status;\r\n  if ((status = expat_process_zip_file_resume(sheetlisthandle->zipfile, sheetlisthandle->xmlparser)) != XML_STATUS_SUSPENDED) {\r\n    return NULL;\r\n  }\r\n  return sheetlisthandle->nextsheetname;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////\r\n\r\nDLL_EXPORT_XLSXIO xlsxioreadersheet xlsxioread_sheet_open (xlsxioreader handle, const XLSXIOCHAR* sheetname, unsigned int flags)\r\n{\r\n  xlsxioreadersheet result;\r\n  if ((result = (xlsxioreadersheet)malloc(sizeof(struct xlsxio_read_sheet_struct))) == NULL)\r\n    return NULL;\r\n  result->handle = handle;\r\n  result->zipfile = NULL;\r\n  result->lastrownr = 0;\r\n  result->paddingrow = 0;\r\n  result->lastcolnr = 0;\r\n  result->paddingcol = 0;\r\n  xlsxioread_process(handle, sheetname, flags | XLSXIOREAD_NO_CALLBACK, NULL, NULL, result);  /* Note: currently broken when not using XLSXIOREAD_NO_CALLBACK flag */\r\n  return result;\r\n}\r\n\r\nDLL_EXPORT_XLSXIO void xlsxioread_sheet_close (xlsxioreadersheet sheethandle)\r\n{\r\n  if (!sheethandle)\r\n    return;\r\n  if (sheethandle->processcallbackdata.xmlparser)\r\n    XML_ParserFree(sheethandle->processcallbackdata.xmlparser);\r\n  data_sheet_callback_data_cleanup(&sheethandle->processcallbackdata);\r\n  if (sheethandle->zipfile)\r\n#ifdef USE_MINIZIP\r\n    unzCloseCurrentFile(sheethandle->zipfile);\r\n#else\r\n    zip_fclose(sheethandle->zipfile);\r\n#endif\r\n  free(sheethandle);\r\n}\r\n\r\nDLL_EXPORT_XLSXIO int xlsxioread_sheet_next_row (xlsxioreadersheet sheethandle)\r\n{\r\n  enum XML_Status status;\r\n  if (!sheethandle) {\r\n    return 0;\r\n  }\r\n  sheethandle->lastcolnr = 0;\r\n  //when padding rows don't retrieve new data\r\n  if (sheethandle->paddingrow) {\r\n    if (sheethandle->paddingrow < sheethandle->processcallbackdata.rownr) {\r\n      return 3;\r\n    } else {\r\n      sheethandle->paddingrow = 0;\r\n      return 2;\r\n    }\r\n  }\r\n  sheethandle->paddingcol = 0;\r\n  //go to beginning of next row\r\n  while ((status = expat_process_zip_file_resume(sheethandle->zipfile, sheethandle->processcallbackdata.xmlparser)) == XML_STATUS_SUSPENDED && sheethandle->processcallbackdata.colnr != 0) {\r\n  }\r\n  return (status == XML_STATUS_SUSPENDED ? 1 : 0);\r\n}\r\n\r\nDLL_EXPORT_XLSXIO XLSXIOCHAR* xlsxioread_sheet_next_cell (xlsxioreadersheet sheethandle)\r\n{\r\n  XML_Char* result;\r\n  if (!sheethandle)\r\n    return NULL;\r\n  //if (!(sheethandle->processcallbackdata.flags & XLSXIOREAD_SKIP_EMPTY_CELLS) && sheethandle->paddingcol) {\r\n  if ((!(sheethandle->processcallbackdata.flags & XLSXIOREAD_SKIP_EMPTY_CELLS) && sheethandle->paddingcol) || (!(sheethandle->processcallbackdata.flags & XLSXIOREAD_SKIP_EMPTY_ROWS) && sheethandle->paddingrow)) {\r\n    if ((/*sheethandle->processcallbackdata.cols > 0 &&*/ sheethandle->paddingcol > sheethandle->processcallbackdata.cols) || (sheethandle->processcallbackdata.flags & XLSXIOREAD_SKIP_EMPTY_CELLS)) {\r\n      //last empty column added, finish row\r\n      sheethandle->paddingcol = 0;\r\n      //when padding rows prepare for the next one\r\n      if (sheethandle->paddingrow) {\r\n        sheethandle->lastrownr++;\r\n        sheethandle->paddingrow++;\r\n        if (sheethandle->paddingrow + 1 < sheethandle->processcallbackdata.rownr) {\r\n          sheethandle->paddingcol = 1;\r\n        }\r\n      }\r\n      return NULL;\r\n    } else if ((sheethandle->processcallbackdata.flags & XLSXIOREAD_SKIP_EXTRA_CELLS) && sheethandle->processcallbackdata.cols > 0 && sheethandle->lastcolnr >= sheethandle->processcallbackdata.cols) {\r\n      //end of line when out of bounds\r\n      return NULL;\r\n    } else {\r\n      //add another empty column\r\n      sheethandle->paddingcol++;\r\n      sheethandle->lastcolnr++;\r\n      return XML_Char_dup(X(\"\"));\r\n    }\r\n  } else if ((sheethandle->processcallbackdata.flags & XLSXIOREAD_SKIP_EXTRA_CELLS) && sheethandle->processcallbackdata.cols > 0 && sheethandle->lastcolnr >= sheethandle->processcallbackdata.cols) {\r\n    //end of line when out of bounds\r\n    return NULL;\r\n  }\r\n  //get value\r\n  if (!sheethandle->processcallbackdata.celldata)\r\n    if (expat_process_zip_file_resume(sheethandle->zipfile, sheethandle->processcallbackdata.xmlparser) != XML_STATUS_SUSPENDED)\r\n      sheethandle->processcallbackdata.celldata = NULL;\r\n  //insert empty rows if needed\r\n  if (!(sheethandle->processcallbackdata.flags & XLSXIOREAD_SKIP_EMPTY_ROWS) && sheethandle->lastrownr + 1 < sheethandle->processcallbackdata.rownr) {\r\n    sheethandle->paddingrow = sheethandle->lastrownr + 1;\r\n    sheethandle->paddingcol = sheethandle->processcallbackdata.colnr*0 + 1;\r\n    return xlsxioread_sheet_next_cell(sheethandle);\r\n  }\r\n  //insert empty column before if needed\r\n  if (!(sheethandle->processcallbackdata.flags & XLSXIOREAD_SKIP_EMPTY_CELLS)) {\r\n    if (sheethandle->lastcolnr + 1 < sheethandle->processcallbackdata.colnr) {\r\n      if (0) {\r\n      //if ((sheethandle->processcallbackdata.flags & XLSXIOREAD_SKIP_EXTRA_CELLS) && sheethandle->processcallbackdata.cols > 0 && sheethandle->lastcolnr >= sheethandle->processcallbackdata.cols) {\r\n        //end of line when out of bounds\r\n        return NULL;\r\n      } else {\r\n        sheethandle->lastcolnr++;\r\n        return XML_Char_dup(X(\"\"));\r\n      }\r\n    }\r\n  }\r\n  result = sheethandle->processcallbackdata.celldata;\r\n  sheethandle->processcallbackdata.celldata = NULL;\r\n  //end of row\r\n  if (!result) {\r\n    sheethandle->lastrownr = sheethandle->processcallbackdata.rownr;\r\n    //insert empty column at end of row if needed\r\n    if (!(sheethandle->processcallbackdata.flags & XLSXIOREAD_SKIP_EMPTY_CELLS) && sheethandle->processcallbackdata.colnr < sheethandle->processcallbackdata.cols) {\r\n      sheethandle->paddingcol = sheethandle->lastcolnr + 1;\r\n      return xlsxioread_sheet_next_cell(sheethandle);\r\n    }\r\n  }\r\n  sheethandle->lastcolnr = sheethandle->processcallbackdata.colnr;\r\n  return result;\r\n}\r\n\r\nDLL_EXPORT_XLSXIO int xlsxioread_sheet_next_cell_string (xlsxioreadersheet sheethandle, XLSXIOCHAR** pvalue)\r\n{\r\n  XML_Char* result;\r\n  if (!sheethandle)\r\n    return -1;\r\n  if ((result = xlsxioread_sheet_next_cell(sheethandle)) == NULL)\r\n    return 0;\r\n  if (pvalue)\r\n    *pvalue = result;\r\n  return 1;\r\n}\r\n\r\nDLL_EXPORT_XLSXIO int xlsxioread_sheet_next_cell_int (xlsxioreadersheet sheethandle, int64_t* pvalue)\r\n{\r\n  XML_Char* result;\r\n  int status;\r\n  if ((result = xlsxioread_sheet_next_cell(sheethandle)) == NULL)\r\n    return 0;\r\n  if (pvalue) {\r\n    status = XML_Char_sscanf(result, X(\"%\" PRIi64), pvalue);\r\n    if (status == EOF || status == 0)\r\n      *pvalue = 0;\r\n    //alternative: use strtoimax()\r\n  }\r\n  free(result);\r\n  return 1;\r\n}\r\n\r\nDLL_EXPORT_XLSXIO int xlsxioread_sheet_next_cell_float (xlsxioreadersheet sheethandle, double* pvalue)\r\n{\r\n  XML_Char* result;\r\n  if ((result = xlsxioread_sheet_next_cell(sheethandle)) == NULL)\r\n    return 0;\r\n  if (pvalue)\r\n    *pvalue = XML_Char_tod(result);\r\n  free(result);\r\n  return 1;\r\n}\r\n\r\nDLL_EXPORT_XLSXIO int xlsxioread_sheet_next_cell_datetime (xlsxioreadersheet sheethandle, time_t* pvalue)\r\n{\r\n  XML_Char* result;\r\n  if ((result = xlsxioread_sheet_next_cell(sheethandle)) == NULL)\r\n    return 0;\r\n  if (pvalue) {\r\n    double value = XML_Char_tod(result);\r\n    if (value != 0) {\r\n      value = (value - 25569) * 86400;  //converstion from Excel to Unix timestamp\r\n    }\r\n    *pvalue = value;\r\n  }\r\n  free(result);\r\n  return 1;\r\n}\r\n\r\nDLL_EXPORT_XLSXIO void xlsxioread_free (XLSXIOCHAR* data)\r\n{\r\n  free(data);\r\n}\r\n"], "filenames": ["Changelog.txt", "include/xlsxio_version.h", "lib/xlsxio_read.c"], "buggy_code_start_loc": [0, 52, 1412], "buggy_code_end_loc": [6, 53, 1412], "fixing_code_start_loc": [1, 52, 1413], "fixing_code_end_loc": [12, 53, 1414], "type": "CWE-416", "message": "xlsxio v0.1.2 to v0.2.34 was discovered to contain a free of uninitialized pointer in the xlsxioread_sheetlist_close() function. This vulnerability allows attackers to cause a Denial of Service (DoS) via a crafted XLSX file.", "other": {"cve": {"id": "CVE-2023-34795", "sourceIdentifier": "cve@mitre.org", "published": "2023-06-16T16:15:09.357", "lastModified": "2023-06-27T01:54:04.317", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "xlsxio v0.1.2 to v0.2.34 was discovered to contain a free of uninitialized pointer in the xlsxioread_sheetlist_close() function. This vulnerability allows attackers to cause a Denial of Service (DoS) via a crafted XLSX file."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:xlsxio_project:xlsxio:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.1.2", "versionEndIncluding": "0.2.34", "matchCriteriaId": "50C87490-7803-4A95-BAC2-918336FB88C6"}]}]}], "references": [{"url": "https://github.com/brechtsanders/xlsxio/commit/d653f1604b54532f11b45dca1fa164b4a1f15e2d", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/brechtsanders/xlsxio/issues/121", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/xf1les/cve-advisories/blob/main/2023/CVE-2023-34795.md", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/brechtsanders/xlsxio/commit/d653f1604b54532f11b45dca1fa164b4a1f15e2d"}}