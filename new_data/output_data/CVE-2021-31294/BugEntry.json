{"buggy_code": ["/*\n * Copyright (c) 2009-2016, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"server.h\"\n#include \"monotonic.h\"\n#include \"cluster.h\"\n#include \"slowlog.h\"\n#include \"bio.h\"\n#include \"latency.h\"\n#include \"atomicvar.h\"\n#include \"mt19937-64.h\"\n\n#include <time.h>\n#include <signal.h>\n#include <sys/wait.h>\n#include <errno.h>\n#include <assert.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <arpa/inet.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#include <sys/uio.h>\n#include <sys/un.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <sys/resource.h>\n#include <sys/utsname.h>\n#include <locale.h>\n#include <sys/socket.h>\n#include <sys/resource.h>\n\n#ifdef __linux__\n#include <sys/mman.h>\n#endif\n\n/* Our shared \"common\" objects */\n\nstruct sharedObjectsStruct shared;\n\n/* Global vars that are actually used as constants. The following double\n * values are used for double on-disk serialization, and are initialized\n * at runtime to avoid strange compiler optimizations. */\n\ndouble R_Zero, R_PosInf, R_NegInf, R_Nan;\n\n/*================================= Globals ================================= */\n\n/* Global vars */\nstruct redisServer server; /* Server global state */\n\n/* Our command table.\n *\n * Every entry is composed of the following fields:\n *\n * name:        A string representing the command name.\n *\n * function:    Pointer to the C function implementing the command.\n *\n * arity:       Number of arguments, it is possible to use -N to say >= N\n *\n * sflags:      Command flags as string. See below for a table of flags.\n *\n * flags:       Flags as bitmask. Computed by Redis using the 'sflags' field.\n *\n * get_keys_proc: An optional function to get key arguments from a command.\n *                This is only used when the following three fields are not\n *                enough to specify what arguments are keys.\n *\n * first_key_index: First argument that is a key\n *\n * last_key_index: Last argument that is a key\n *\n * key_step:    Step to get all the keys from first to last argument.\n *              For instance in MSET the step is two since arguments\n *              are key,val,key,val,...\n *\n * microseconds: Microseconds of total execution time for this command.\n *\n * calls:       Total number of calls of this command.\n *\n * id:          Command bit identifier for ACLs or other goals.\n *\n * The flags, microseconds and calls fields are computed by Redis and should\n * always be set to zero.\n *\n * Command flags are expressed using space separated strings, that are turned\n * into actual flags by the populateCommandTable() function.\n *\n * This is the meaning of the flags:\n *\n * write:       Write command (may modify the key space).\n *\n * read-only:   Commands just reading from keys without changing the content.\n *              Note that commands that don't read from the keyspace such as\n *              TIME, SELECT, INFO, administrative commands, and connection\n *              or transaction related commands (multi, exec, discard, ...)\n *              are not flagged as read-only commands, since they affect the\n *              server or the connection in other ways.\n *\n * use-memory:  May increase memory usage once called. Don't allow if out\n *              of memory.\n *\n * admin:       Administrative command, like SAVE or SHUTDOWN.\n *\n * pub-sub:     Pub/Sub related command.\n *\n * no-script:   Command not allowed in scripts.\n *\n * random:      Random command. Command is not deterministic, that is, the same\n *              command with the same arguments, with the same key space, may\n *              have different results. For instance SPOP and RANDOMKEY are\n *              two random commands.\n *\n * to-sort:     Sort command output array if called from script, so that the\n *              output is deterministic. When this flag is used (not always\n *              possible), then the \"random\" flag is not needed.\n *\n * ok-loading:  Allow the command while loading the database.\n *\n * ok-stale:    Allow the command while a slave has stale data but is not\n *              allowed to serve this data. Normally no command is accepted\n *              in this condition but just a few.\n *\n * no-monitor:  Do not automatically propagate the command on MONITOR.\n *\n * no-slowlog:  Do not automatically propagate the command to the slowlog.\n *\n * cluster-asking: Perform an implicit ASKING for this command, so the\n *              command will be accepted in cluster mode if the slot is marked\n *              as 'importing'.\n *\n * fast:        Fast command: O(1) or O(log(N)) command that should never\n *              delay its execution as long as the kernel scheduler is giving\n *              us time. Note that commands that may trigger a DEL as a side\n *              effect (like SET) are not fast commands.\n * \n * may-replicate: Command may produce replication traffic, but should be \n *                allowed under circumstances where write commands are disallowed. \n *                Examples include PUBLISH, which replicates pubsub messages,and \n *                EVAL, which may execute write commands, which are replicated, \n *                or may just execute read commands. A command can not be marked \n *                both \"write\" and \"may-replicate\"\n *\n * The following additional flags are only used in order to put commands\n * in a specific ACL category. Commands can have multiple ACL categories.\n *\n * @keyspace, @read, @write, @set, @sortedset, @list, @hash, @string, @bitmap,\n * @hyperloglog, @stream, @admin, @fast, @slow, @pubsub, @blocking, @dangerous,\n * @connection, @transaction, @scripting, @geo.\n *\n * Note that:\n *\n * 1) The read-only flag implies the @read ACL category.\n * 2) The write flag implies the @write ACL category.\n * 3) The fast flag implies the @fast ACL category.\n * 4) The admin flag implies the @admin and @dangerous ACL category.\n * 5) The pub-sub flag implies the @pubsub ACL category.\n * 6) The lack of fast flag implies the @slow ACL category.\n * 7) The non obvious \"keyspace\" category includes the commands\n *    that interact with keys without having anything to do with\n *    specific data structures, such as: DEL, RENAME, MOVE, SELECT,\n *    TYPE, EXPIRE*, PEXPIRE*, TTL, PTTL, ...\n */\n\nstruct redisCommand redisCommandTable[] = {\n    {\"module\",moduleCommand,-2,\n     \"admin no-script\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"get\",getCommand,2,\n     \"read-only fast @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"getex\",getexCommand,-2,\n     \"write fast @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"getdel\",getdelCommand,2,\n     \"write fast @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    /* Note that we can't flag set as fast, since it may perform an\n     * implicit DEL of a large key. */\n    {\"set\",setCommand,-3,\n     \"write use-memory @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"setnx\",setnxCommand,3,\n     \"write use-memory fast @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"setex\",setexCommand,4,\n     \"write use-memory @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"psetex\",psetexCommand,4,\n     \"write use-memory @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"append\",appendCommand,3,\n     \"write use-memory fast @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"strlen\",strlenCommand,2,\n     \"read-only fast @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"del\",delCommand,-2,\n     \"write @keyspace\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"unlink\",unlinkCommand,-2,\n     \"write fast @keyspace\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"exists\",existsCommand,-2,\n     \"read-only fast @keyspace\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"setbit\",setbitCommand,4,\n     \"write use-memory @bitmap\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"getbit\",getbitCommand,3,\n     \"read-only fast @bitmap\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"bitfield\",bitfieldCommand,-2,\n     \"write use-memory @bitmap\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"bitfield_ro\",bitfieldroCommand,-2,\n     \"read-only fast @bitmap\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"setrange\",setrangeCommand,4,\n     \"write use-memory @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"getrange\",getrangeCommand,4,\n     \"read-only @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"substr\",getrangeCommand,4,\n     \"read-only @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"incr\",incrCommand,2,\n     \"write use-memory fast @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"decr\",decrCommand,2,\n     \"write use-memory fast @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"mget\",mgetCommand,-2,\n     \"read-only fast @string\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"rpush\",rpushCommand,-3,\n     \"write use-memory fast @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"lpush\",lpushCommand,-3,\n     \"write use-memory fast @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"rpushx\",rpushxCommand,-3,\n     \"write use-memory fast @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"lpushx\",lpushxCommand,-3,\n     \"write use-memory fast @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"linsert\",linsertCommand,5,\n     \"write use-memory @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"rpop\",rpopCommand,-2,\n     \"write fast @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"lpop\",lpopCommand,-2,\n     \"write fast @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"brpop\",brpopCommand,-3,\n     \"write no-script @list @blocking\",\n     0,NULL,1,-2,1,0,0,0},\n\n    {\"brpoplpush\",brpoplpushCommand,4,\n     \"write use-memory no-script @list @blocking\",\n     0,NULL,1,2,1,0,0,0},\n\n    {\"blmove\",blmoveCommand,6,\n     \"write use-memory no-script @list @blocking\",\n     0,NULL,1,2,1,0,0,0},\n\n    {\"blpop\",blpopCommand,-3,\n     \"write no-script @list @blocking\",\n     0,NULL,1,-2,1,0,0,0},\n\n    {\"llen\",llenCommand,2,\n     \"read-only fast @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"lindex\",lindexCommand,3,\n     \"read-only @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"lset\",lsetCommand,4,\n     \"write use-memory @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"lrange\",lrangeCommand,4,\n     \"read-only @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"ltrim\",ltrimCommand,4,\n     \"write @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"lpos\",lposCommand,-3,\n     \"read-only @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"lrem\",lremCommand,4,\n     \"write @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"rpoplpush\",rpoplpushCommand,3,\n     \"write use-memory @list\",\n     0,NULL,1,2,1,0,0,0},\n\n    {\"lmove\",lmoveCommand,5,\n     \"write use-memory @list\",\n     0,NULL,1,2,1,0,0,0},\n\n    {\"sadd\",saddCommand,-3,\n     \"write use-memory fast @set\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"srem\",sremCommand,-3,\n     \"write fast @set\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"smove\",smoveCommand,4,\n     \"write fast @set\",\n     0,NULL,1,2,1,0,0,0},\n\n    {\"sismember\",sismemberCommand,3,\n     \"read-only fast @set\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"smismember\",smismemberCommand,-3,\n     \"read-only fast @set\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"scard\",scardCommand,2,\n     \"read-only fast @set\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"spop\",spopCommand,-2,\n     \"write random fast @set\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"srandmember\",srandmemberCommand,-2,\n     \"read-only random @set\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"sinter\",sinterCommand,-2,\n     \"read-only to-sort @set\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"sinterstore\",sinterstoreCommand,-3,\n     \"write use-memory @set\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"sunion\",sunionCommand,-2,\n     \"read-only to-sort @set\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"sunionstore\",sunionstoreCommand,-3,\n     \"write use-memory @set\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"sdiff\",sdiffCommand,-2,\n     \"read-only to-sort @set\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"sdiffstore\",sdiffstoreCommand,-3,\n     \"write use-memory @set\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"smembers\",sinterCommand,2,\n     \"read-only to-sort @set\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"sscan\",sscanCommand,-3,\n     \"read-only random @set\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zadd\",zaddCommand,-4,\n     \"write use-memory fast @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zincrby\",zincrbyCommand,4,\n     \"write use-memory fast @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zrem\",zremCommand,-3,\n     \"write fast @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zremrangebyscore\",zremrangebyscoreCommand,4,\n     \"write @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zremrangebyrank\",zremrangebyrankCommand,4,\n     \"write @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zremrangebylex\",zremrangebylexCommand,4,\n     \"write @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zunionstore\",zunionstoreCommand,-4,\n     \"write use-memory @sortedset\",\n     0,zunionInterDiffStoreGetKeys,1,1,1,0,0,0},\n\n    {\"zinterstore\",zinterstoreCommand,-4,\n     \"write use-memory @sortedset\",\n     0,zunionInterDiffStoreGetKeys,1,1,1,0,0,0},\n\n    {\"zdiffstore\",zdiffstoreCommand,-4,\n     \"write use-memory @sortedset\",\n     0,zunionInterDiffStoreGetKeys,1,1,1,0,0,0},\n\n    {\"zunion\",zunionCommand,-3,\n     \"read-only @sortedset\",\n     0,zunionInterDiffGetKeys,0,0,0,0,0,0},\n\n    {\"zinter\",zinterCommand,-3,\n     \"read-only @sortedset\",\n     0,zunionInterDiffGetKeys,0,0,0,0,0,0},\n\n    {\"zdiff\",zdiffCommand,-3,\n     \"read-only @sortedset\",\n     0,zunionInterDiffGetKeys,0,0,0,0,0,0},\n\n    {\"zrange\",zrangeCommand,-4,\n     \"read-only @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zrangestore\",zrangestoreCommand,-5,\n     \"write use-memory @sortedset\",\n     0,NULL,1,2,1,0,0,0},\n\n    {\"zrangebyscore\",zrangebyscoreCommand,-4,\n     \"read-only @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zrevrangebyscore\",zrevrangebyscoreCommand,-4,\n     \"read-only @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zrangebylex\",zrangebylexCommand,-4,\n     \"read-only @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zrevrangebylex\",zrevrangebylexCommand,-4,\n     \"read-only @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zcount\",zcountCommand,4,\n     \"read-only fast @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zlexcount\",zlexcountCommand,4,\n     \"read-only fast @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zrevrange\",zrevrangeCommand,-4,\n     \"read-only @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zcard\",zcardCommand,2,\n     \"read-only fast @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zscore\",zscoreCommand,3,\n     \"read-only fast @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zmscore\",zmscoreCommand,-3,\n     \"read-only fast @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zrank\",zrankCommand,3,\n     \"read-only fast @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zrevrank\",zrevrankCommand,3,\n     \"read-only fast @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zscan\",zscanCommand,-3,\n     \"read-only random @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zpopmin\",zpopminCommand,-2,\n     \"write fast @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zpopmax\",zpopmaxCommand,-2,\n     \"write fast @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"bzpopmin\",bzpopminCommand,-3,\n     \"write no-script fast @sortedset @blocking\",\n     0,NULL,1,-2,1,0,0,0},\n\n    {\"bzpopmax\",bzpopmaxCommand,-3,\n     \"write no-script fast @sortedset @blocking\",\n     0,NULL,1,-2,1,0,0,0},\n\n    {\"zrandmember\",zrandmemberCommand,-2,\n     \"read-only random @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hset\",hsetCommand,-4,\n     \"write use-memory fast @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hsetnx\",hsetnxCommand,4,\n     \"write use-memory fast @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hget\",hgetCommand,3,\n     \"read-only fast @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hmset\",hsetCommand,-4,\n     \"write use-memory fast @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hmget\",hmgetCommand,-3,\n     \"read-only fast @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hincrby\",hincrbyCommand,4,\n     \"write use-memory fast @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hincrbyfloat\",hincrbyfloatCommand,4,\n     \"write use-memory fast @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hdel\",hdelCommand,-3,\n     \"write fast @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hlen\",hlenCommand,2,\n     \"read-only fast @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hstrlen\",hstrlenCommand,3,\n     \"read-only fast @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hkeys\",hkeysCommand,2,\n     \"read-only to-sort @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hvals\",hvalsCommand,2,\n     \"read-only to-sort @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hgetall\",hgetallCommand,2,\n     \"read-only random @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hexists\",hexistsCommand,3,\n     \"read-only fast @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hrandfield\",hrandfieldCommand,-2,\n     \"read-only random @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hscan\",hscanCommand,-3,\n     \"read-only random @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"incrby\",incrbyCommand,3,\n     \"write use-memory fast @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"decrby\",decrbyCommand,3,\n     \"write use-memory fast @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"incrbyfloat\",incrbyfloatCommand,3,\n     \"write use-memory fast @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"getset\",getsetCommand,3,\n     \"write use-memory fast @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"mset\",msetCommand,-3,\n     \"write use-memory @string\",\n     0,NULL,1,-1,2,0,0,0},\n\n    {\"msetnx\",msetnxCommand,-3,\n     \"write use-memory @string\",\n     0,NULL,1,-1,2,0,0,0},\n\n    {\"randomkey\",randomkeyCommand,1,\n     \"read-only random @keyspace\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"select\",selectCommand,2,\n     \"ok-loading fast ok-stale @keyspace\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"swapdb\",swapdbCommand,3,\n     \"write fast @keyspace @dangerous\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"move\",moveCommand,3,\n     \"write fast @keyspace\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"copy\",copyCommand,-3,\n     \"write use-memory @keyspace\",\n     0,NULL,1,2,1,0,0,0},\n\n    /* Like for SET, we can't mark rename as a fast command because\n     * overwriting the target key may result in an implicit slow DEL. */\n    {\"rename\",renameCommand,3,\n     \"write @keyspace\",\n     0,NULL,1,2,1,0,0,0},\n\n    {\"renamenx\",renamenxCommand,3,\n     \"write fast @keyspace\",\n     0,NULL,1,2,1,0,0,0},\n\n    {\"expire\",expireCommand,3,\n     \"write fast @keyspace\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"expireat\",expireatCommand,3,\n     \"write fast @keyspace\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"pexpire\",pexpireCommand,3,\n     \"write fast @keyspace\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"pexpireat\",pexpireatCommand,3,\n     \"write fast @keyspace\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"keys\",keysCommand,2,\n     \"read-only to-sort @keyspace @dangerous\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"scan\",scanCommand,-2,\n     \"read-only random @keyspace\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"dbsize\",dbsizeCommand,1,\n     \"read-only fast @keyspace\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"auth\",authCommand,-2,\n     \"no-auth no-script ok-loading ok-stale fast no-monitor no-slowlog @connection\",\n     0,NULL,0,0,0,0,0,0},\n\n    /* We don't allow PING during loading since in Redis PING is used as\n     * failure detection, and a loading server is considered to be\n     * not available. */\n    {\"ping\",pingCommand,-1,\n     \"ok-stale fast @connection\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"echo\",echoCommand,2,\n     \"fast @connection\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"save\",saveCommand,1,\n     \"admin no-script\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"bgsave\",bgsaveCommand,-1,\n     \"admin no-script\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"bgrewriteaof\",bgrewriteaofCommand,1,\n     \"admin no-script\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"shutdown\",shutdownCommand,-1,\n     \"admin no-script ok-loading ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"lastsave\",lastsaveCommand,1,\n     \"random fast ok-loading ok-stale @admin @dangerous\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"type\",typeCommand,2,\n     \"read-only fast @keyspace\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"multi\",multiCommand,1,\n     \"no-script fast ok-loading ok-stale @transaction\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"exec\",execCommand,1,\n     \"no-script no-monitor no-slowlog ok-loading ok-stale @transaction\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"discard\",discardCommand,1,\n     \"no-script fast ok-loading ok-stale @transaction\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"sync\",syncCommand,1,\n     \"admin no-script\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"psync\",syncCommand,-3,\n     \"admin no-script\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"replconf\",replconfCommand,-1,\n     \"admin no-script ok-loading ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"flushdb\",flushdbCommand,-1,\n     \"write @keyspace @dangerous\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"flushall\",flushallCommand,-1,\n     \"write @keyspace @dangerous\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"sort\",sortCommand,-2,\n     \"write use-memory @list @set @sortedset @dangerous\",\n     0,sortGetKeys,1,1,1,0,0,0},\n\n    {\"info\",infoCommand,-1,\n     \"ok-loading ok-stale random @dangerous\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"monitor\",monitorCommand,1,\n     \"admin no-script ok-loading ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"ttl\",ttlCommand,2,\n     \"read-only fast random @keyspace\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"touch\",touchCommand,-2,\n     \"read-only fast @keyspace\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"pttl\",pttlCommand,2,\n     \"read-only fast random @keyspace\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"persist\",persistCommand,2,\n     \"write fast @keyspace\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"slaveof\",replicaofCommand,3,\n     \"admin no-script ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"replicaof\",replicaofCommand,3,\n     \"admin no-script ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"role\",roleCommand,1,\n     \"ok-loading ok-stale no-script fast @dangerous\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"debug\",debugCommand,-2,\n     \"admin no-script ok-loading ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"config\",configCommand,-2,\n     \"admin ok-loading ok-stale no-script\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"subscribe\",subscribeCommand,-2,\n     \"pub-sub no-script ok-loading ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"unsubscribe\",unsubscribeCommand,-1,\n     \"pub-sub no-script ok-loading ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"psubscribe\",psubscribeCommand,-2,\n     \"pub-sub no-script ok-loading ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"punsubscribe\",punsubscribeCommand,-1,\n     \"pub-sub no-script ok-loading ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"publish\",publishCommand,3,\n     \"pub-sub ok-loading ok-stale fast may-replicate\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"pubsub\",pubsubCommand,-2,\n     \"pub-sub ok-loading ok-stale random\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"watch\",watchCommand,-2,\n     \"no-script fast ok-loading ok-stale @transaction\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"unwatch\",unwatchCommand,1,\n     \"no-script fast ok-loading ok-stale @transaction\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"cluster\",clusterCommand,-2,\n     \"admin ok-stale random\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"restore\",restoreCommand,-4,\n     \"write use-memory @keyspace @dangerous\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"restore-asking\",restoreCommand,-4,\n    \"write use-memory cluster-asking @keyspace @dangerous\",\n    0,NULL,1,1,1,0,0,0},\n\n    {\"migrate\",migrateCommand,-6,\n     \"write random @keyspace @dangerous\",\n     0,migrateGetKeys,0,0,0,0,0,0},\n\n    {\"asking\",askingCommand,1,\n     \"fast @keyspace\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"readonly\",readonlyCommand,1,\n     \"fast @keyspace\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"readwrite\",readwriteCommand,1,\n     \"fast @keyspace\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"dump\",dumpCommand,2,\n     \"read-only random @keyspace\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"object\",objectCommand,-2,\n     \"read-only random @keyspace\",\n     0,NULL,2,2,1,0,0,0},\n\n    {\"memory\",memoryCommand,-2,\n     \"random read-only\",\n     0,memoryGetKeys,0,0,0,0,0,0},\n\n    {\"client\",clientCommand,-2,\n     \"admin no-script random ok-loading ok-stale @connection\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"hello\",helloCommand,-1,\n     \"no-auth no-script fast no-monitor ok-loading ok-stale @connection\",\n     0,NULL,0,0,0,0,0,0},\n\n    /* EVAL can modify the dataset, however it is not flagged as a write\n     * command since we do the check while running commands from Lua. */\n    {\"eval\",evalCommand,-3,\n     \"no-script may-replicate @scripting\",\n     0,evalGetKeys,0,0,0,0,0,0},\n\n    {\"evalsha\",evalShaCommand,-3,\n     \"no-script may-replicate @scripting\",\n     0,evalGetKeys,0,0,0,0,0,0},\n\n    {\"slowlog\",slowlogCommand,-2,\n     \"admin random ok-loading ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"script\",scriptCommand,-2,\n     \"no-script may-replicate @scripting\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"time\",timeCommand,1,\n     \"random fast ok-loading ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"bitop\",bitopCommand,-4,\n     \"write use-memory @bitmap\",\n     0,NULL,2,-1,1,0,0,0},\n\n    {\"bitcount\",bitcountCommand,-2,\n     \"read-only @bitmap\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"bitpos\",bitposCommand,-3,\n     \"read-only @bitmap\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"wait\",waitCommand,3,\n     \"no-script @keyspace\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"command\",commandCommand,-1,\n     \"ok-loading ok-stale random @connection\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"geoadd\",geoaddCommand,-5,\n     \"write use-memory @geo\",\n     0,NULL,1,1,1,0,0,0},\n\n    /* GEORADIUS has store options that may write. */\n    {\"georadius\",georadiusCommand,-6,\n     \"write use-memory @geo\",\n     0,georadiusGetKeys,1,1,1,0,0,0},\n\n    {\"georadius_ro\",georadiusroCommand,-6,\n     \"read-only @geo\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"georadiusbymember\",georadiusbymemberCommand,-5,\n     \"write use-memory @geo\",\n     0,georadiusGetKeys,1,1,1,0,0,0},\n\n    {\"georadiusbymember_ro\",georadiusbymemberroCommand,-5,\n     \"read-only @geo\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"geohash\",geohashCommand,-2,\n     \"read-only @geo\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"geopos\",geoposCommand,-2,\n     \"read-only @geo\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"geodist\",geodistCommand,-4,\n     \"read-only @geo\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"geosearch\",geosearchCommand,-7,\n     \"read-only @geo\",\n      0,NULL,1,1,1,0,0,0},\n\n    {\"geosearchstore\",geosearchstoreCommand,-8,\n     \"write use-memory @geo\",\n      0,NULL,1,2,1,0,0,0},\n\n    {\"pfselftest\",pfselftestCommand,1,\n     \"admin @hyperloglog\",\n      0,NULL,0,0,0,0,0,0},\n\n    {\"pfadd\",pfaddCommand,-2,\n     \"write use-memory fast @hyperloglog\",\n     0,NULL,1,1,1,0,0,0},\n\n    /* Technically speaking PFCOUNT may change the key since it changes the\n     * final bytes in the HyperLogLog representation. However in this case\n     * we claim that the representation, even if accessible, is an internal\n     * affair, and the command is semantically read only. */\n    {\"pfcount\",pfcountCommand,-2,\n     \"read-only may-replicate @hyperloglog\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"pfmerge\",pfmergeCommand,-2,\n     \"write use-memory @hyperloglog\",\n     0,NULL,1,-1,1,0,0,0},\n\n    /* Unlike PFCOUNT that is considered as a read-only command (although\n     * it changes a bit), PFDEBUG may change the entire key when converting\n     * from sparse to dense representation */\n    {\"pfdebug\",pfdebugCommand,-3,\n     \"admin write use-memory @hyperloglog\",\n     0,NULL,2,2,1,0,0,0},\n\n    {\"xadd\",xaddCommand,-5,\n     \"write use-memory fast random @stream\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"xrange\",xrangeCommand,-4,\n     \"read-only @stream\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"xrevrange\",xrevrangeCommand,-4,\n     \"read-only @stream\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"xlen\",xlenCommand,2,\n     \"read-only fast @stream\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"xread\",xreadCommand,-4,\n     \"read-only @stream @blocking\",\n     0,xreadGetKeys,0,0,0,0,0,0},\n\n    {\"xreadgroup\",xreadCommand,-7,\n     \"write @stream @blocking\",\n     0,xreadGetKeys,0,0,0,0,0,0},\n\n    {\"xgroup\",xgroupCommand,-2,\n     \"write use-memory @stream\",\n     0,NULL,2,2,1,0,0,0},\n\n    {\"xsetid\",xsetidCommand,3,\n     \"write use-memory fast @stream\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"xack\",xackCommand,-4,\n     \"write fast random @stream\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"xpending\",xpendingCommand,-3,\n     \"read-only random @stream\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"xclaim\",xclaimCommand,-6,\n     \"write random fast @stream\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"xautoclaim\",xautoclaimCommand,-6,\n     \"write random fast @stream\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"xinfo\",xinfoCommand,-2,\n     \"read-only random @stream\",\n     0,NULL,2,2,1,0,0,0},\n\n    {\"xdel\",xdelCommand,-3,\n     \"write fast @stream\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"xtrim\",xtrimCommand,-4,\n     \"write random @stream\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"post\",securityWarningCommand,-1,\n     \"ok-loading ok-stale read-only\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"host:\",securityWarningCommand,-1,\n     \"ok-loading ok-stale read-only\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"latency\",latencyCommand,-2,\n     \"admin no-script ok-loading ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"lolwut\",lolwutCommand,-1,\n     \"read-only fast\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"acl\",aclCommand,-2,\n     \"admin no-script ok-loading ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"stralgo\",stralgoCommand,-2,\n     \"read-only @string\",\n     0,lcsGetKeys,0,0,0,0,0,0},\n\n    {\"reset\",resetCommand,1,\n     \"no-script ok-stale ok-loading fast @connection\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"failover\",failoverCommand,-1,\n     \"admin no-script ok-stale\",\n     0,NULL,0,0,0,0,0,0}\n};\n\n/*============================ Utility functions ============================ */\n\n/* We use a private localtime implementation which is fork-safe. The logging\n * function of Redis may be called from other threads. */\nvoid nolocks_localtime(struct tm *tmp, time_t t, time_t tz, int dst);\n\n/* Low level logging. To use only for very big messages, otherwise\n * serverLog() is to prefer. */\nvoid serverLogRaw(int level, const char *msg) {\n    const int syslogLevelMap[] = { LOG_DEBUG, LOG_INFO, LOG_NOTICE, LOG_WARNING };\n    const char *c = \".-*#\";\n    FILE *fp;\n    char buf[64];\n    int rawmode = (level & LL_RAW);\n    int log_to_stdout = server.logfile[0] == '\\0';\n\n    level &= 0xff; /* clear flags */\n    if (level < server.verbosity) return;\n\n    fp = log_to_stdout ? stdout : fopen(server.logfile,\"a\");\n    if (!fp) return;\n\n    if (rawmode) {\n        fprintf(fp,\"%s\",msg);\n    } else {\n        int off;\n        struct timeval tv;\n        int role_char;\n        pid_t pid = getpid();\n\n        gettimeofday(&tv,NULL);\n        struct tm tm;\n        nolocks_localtime(&tm,tv.tv_sec,server.timezone,server.daylight_active);\n        off = strftime(buf,sizeof(buf),\"%d %b %Y %H:%M:%S.\",&tm);\n        snprintf(buf+off,sizeof(buf)-off,\"%03d\",(int)tv.tv_usec/1000);\n        if (server.sentinel_mode) {\n            role_char = 'X'; /* Sentinel. */\n        } else if (pid != server.pid) {\n            role_char = 'C'; /* RDB / AOF writing child. */\n        } else {\n            role_char = (server.masterhost ? 'S':'M'); /* Slave or Master. */\n        }\n        fprintf(fp,\"%d:%c %s %c %s\\n\",\n            (int)getpid(),role_char, buf,c[level],msg);\n    }\n    fflush(fp);\n\n    if (!log_to_stdout) fclose(fp);\n    if (server.syslog_enabled) syslog(syslogLevelMap[level], \"%s\", msg);\n}\n\n/* Like serverLogRaw() but with printf-alike support. This is the function that\n * is used across the code. The raw version is only used in order to dump\n * the INFO output on crash. */\nvoid _serverLog(int level, const char *fmt, ...) {\n    va_list ap;\n    char msg[LOG_MAX_LEN];\n\n    va_start(ap, fmt);\n    vsnprintf(msg, sizeof(msg), fmt, ap);\n    va_end(ap);\n\n    serverLogRaw(level,msg);\n}\n\n/* Log a fixed message without printf-alike capabilities, in a way that is\n * safe to call from a signal handler.\n *\n * We actually use this only for signals that are not fatal from the point\n * of view of Redis. Signals that are going to kill the server anyway and\n * where we need printf-alike features are served by serverLog(). */\nvoid serverLogFromHandler(int level, const char *msg) {\n    int fd;\n    int log_to_stdout = server.logfile[0] == '\\0';\n    char buf[64];\n\n    if ((level&0xff) < server.verbosity || (log_to_stdout && server.daemonize))\n        return;\n    fd = log_to_stdout ? STDOUT_FILENO :\n                         open(server.logfile, O_APPEND|O_CREAT|O_WRONLY, 0644);\n    if (fd == -1) return;\n    ll2string(buf,sizeof(buf),getpid());\n    if (write(fd,buf,strlen(buf)) == -1) goto err;\n    if (write(fd,\":signal-handler (\",17) == -1) goto err;\n    ll2string(buf,sizeof(buf),time(NULL));\n    if (write(fd,buf,strlen(buf)) == -1) goto err;\n    if (write(fd,\") \",2) == -1) goto err;\n    if (write(fd,msg,strlen(msg)) == -1) goto err;\n    if (write(fd,\"\\n\",1) == -1) goto err;\nerr:\n    if (!log_to_stdout) close(fd);\n}\n\n/* Return the UNIX time in microseconds */\nlong long ustime(void) {\n    struct timeval tv;\n    long long ust;\n\n    gettimeofday(&tv, NULL);\n    ust = ((long long)tv.tv_sec)*1000000;\n    ust += tv.tv_usec;\n    return ust;\n}\n\n/* Return the UNIX time in milliseconds */\nmstime_t mstime(void) {\n    return ustime()/1000;\n}\n\n/* After an RDB dump or AOF rewrite we exit from children using _exit() instead of\n * exit(), because the latter may interact with the same file objects used by\n * the parent process. However if we are testing the coverage normal exit() is\n * used in order to obtain the right coverage information. */\nvoid exitFromChild(int retcode) {\n#ifdef COVERAGE_TEST\n    exit(retcode);\n#else\n    _exit(retcode);\n#endif\n}\n\n/*====================== Hash table type implementation  ==================== */\n\n/* This is a hash table type that uses the SDS dynamic strings library as\n * keys and redis objects as values (objects can hold SDS strings,\n * lists, sets). */\n\nvoid dictVanillaFree(void *privdata, void *val)\n{\n    DICT_NOTUSED(privdata);\n    zfree(val);\n}\n\nvoid dictListDestructor(void *privdata, void *val)\n{\n    DICT_NOTUSED(privdata);\n    listRelease((list*)val);\n}\n\nint dictSdsKeyCompare(void *privdata, const void *key1,\n        const void *key2)\n{\n    int l1,l2;\n    DICT_NOTUSED(privdata);\n\n    l1 = sdslen((sds)key1);\n    l2 = sdslen((sds)key2);\n    if (l1 != l2) return 0;\n    return memcmp(key1, key2, l1) == 0;\n}\n\n/* A case insensitive version used for the command lookup table and other\n * places where case insensitive non binary-safe comparison is needed. */\nint dictSdsKeyCaseCompare(void *privdata, const void *key1,\n        const void *key2)\n{\n    DICT_NOTUSED(privdata);\n\n    return strcasecmp(key1, key2) == 0;\n}\n\nvoid dictObjectDestructor(void *privdata, void *val)\n{\n    DICT_NOTUSED(privdata);\n\n    if (val == NULL) return; /* Lazy freeing will set value to NULL. */\n    decrRefCount(val);\n}\n\nvoid dictSdsDestructor(void *privdata, void *val)\n{\n    DICT_NOTUSED(privdata);\n\n    sdsfree(val);\n}\n\nint dictObjKeyCompare(void *privdata, const void *key1,\n        const void *key2)\n{\n    const robj *o1 = key1, *o2 = key2;\n    return dictSdsKeyCompare(privdata,o1->ptr,o2->ptr);\n}\n\nuint64_t dictObjHash(const void *key) {\n    const robj *o = key;\n    return dictGenHashFunction(o->ptr, sdslen((sds)o->ptr));\n}\n\nuint64_t dictSdsHash(const void *key) {\n    return dictGenHashFunction((unsigned char*)key, sdslen((char*)key));\n}\n\nuint64_t dictSdsCaseHash(const void *key) {\n    return dictGenCaseHashFunction((unsigned char*)key, sdslen((char*)key));\n}\n\nint dictEncObjKeyCompare(void *privdata, const void *key1,\n        const void *key2)\n{\n    robj *o1 = (robj*) key1, *o2 = (robj*) key2;\n    int cmp;\n\n    if (o1->encoding == OBJ_ENCODING_INT &&\n        o2->encoding == OBJ_ENCODING_INT)\n            return o1->ptr == o2->ptr;\n\n    /* Due to OBJ_STATIC_REFCOUNT, we avoid calling getDecodedObject() without\n     * good reasons, because it would incrRefCount() the object, which\n     * is invalid. So we check to make sure dictFind() works with static\n     * objects as well. */\n    if (o1->refcount != OBJ_STATIC_REFCOUNT) o1 = getDecodedObject(o1);\n    if (o2->refcount != OBJ_STATIC_REFCOUNT) o2 = getDecodedObject(o2);\n    cmp = dictSdsKeyCompare(privdata,o1->ptr,o2->ptr);\n    if (o1->refcount != OBJ_STATIC_REFCOUNT) decrRefCount(o1);\n    if (o2->refcount != OBJ_STATIC_REFCOUNT) decrRefCount(o2);\n    return cmp;\n}\n\nuint64_t dictEncObjHash(const void *key) {\n    robj *o = (robj*) key;\n\n    if (sdsEncodedObject(o)) {\n        return dictGenHashFunction(o->ptr, sdslen((sds)o->ptr));\n    } else if (o->encoding == OBJ_ENCODING_INT) {\n        char buf[32];\n        int len;\n\n        len = ll2string(buf,32,(long)o->ptr);\n        return dictGenHashFunction((unsigned char*)buf, len);\n    } else {\n        serverPanic(\"Unknown string encoding\");\n    }\n}\n\n/* Return 1 if currently we allow dict to expand. Dict may allocate huge\n * memory to contain hash buckets when dict expands, that may lead redis\n * rejects user's requests or evicts some keys, we can stop dict to expand\n * provisionally if used memory will be over maxmemory after dict expands,\n * but to guarantee the performance of redis, we still allow dict to expand\n * if dict load factor exceeds HASHTABLE_MAX_LOAD_FACTOR. */\nint dictExpandAllowed(size_t moreMem, double usedRatio) {\n    if (usedRatio <= HASHTABLE_MAX_LOAD_FACTOR) {\n        return !overMaxmemoryAfterAlloc(moreMem);\n    } else {\n        return 1;\n    }\n}\n\n/* Generic hash table type where keys are Redis Objects, Values\n * dummy pointers. */\ndictType objectKeyPointerValueDictType = {\n    dictEncObjHash,            /* hash function */\n    NULL,                      /* key dup */\n    NULL,                      /* val dup */\n    dictEncObjKeyCompare,      /* key compare */\n    dictObjectDestructor,      /* key destructor */\n    NULL,                      /* val destructor */\n    NULL                       /* allow to expand */\n};\n\n/* Like objectKeyPointerValueDictType(), but values can be destroyed, if\n * not NULL, calling zfree(). */\ndictType objectKeyHeapPointerValueDictType = {\n    dictEncObjHash,            /* hash function */\n    NULL,                      /* key dup */\n    NULL,                      /* val dup */\n    dictEncObjKeyCompare,      /* key compare */\n    dictObjectDestructor,      /* key destructor */\n    dictVanillaFree,           /* val destructor */\n    NULL                       /* allow to expand */\n};\n\n/* Set dictionary type. Keys are SDS strings, values are not used. */\ndictType setDictType = {\n    dictSdsHash,               /* hash function */\n    NULL,                      /* key dup */\n    NULL,                      /* val dup */\n    dictSdsKeyCompare,         /* key compare */\n    dictSdsDestructor,         /* key destructor */\n    NULL                       /* val destructor */\n};\n\n/* Sorted sets hash (note: a skiplist is used in addition to the hash table) */\ndictType zsetDictType = {\n    dictSdsHash,               /* hash function */\n    NULL,                      /* key dup */\n    NULL,                      /* val dup */\n    dictSdsKeyCompare,         /* key compare */\n    NULL,                      /* Note: SDS string shared & freed by skiplist */\n    NULL,                      /* val destructor */\n    NULL                       /* allow to expand */\n};\n\n/* Db->dict, keys are sds strings, vals are Redis objects. */\ndictType dbDictType = {\n    dictSdsHash,                /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictSdsKeyCompare,          /* key compare */\n    dictSdsDestructor,          /* key destructor */\n    dictObjectDestructor,       /* val destructor */\n    dictExpandAllowed           /* allow to expand */\n};\n\n/* server.lua_scripts sha (as sds string) -> scripts (as robj) cache. */\ndictType shaScriptObjectDictType = {\n    dictSdsCaseHash,            /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictSdsKeyCaseCompare,      /* key compare */\n    dictSdsDestructor,          /* key destructor */\n    dictObjectDestructor,       /* val destructor */\n    NULL                        /* allow to expand */\n};\n\n/* Db->expires */\ndictType dbExpiresDictType = {\n    dictSdsHash,                /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictSdsKeyCompare,          /* key compare */\n    NULL,                       /* key destructor */\n    NULL,                       /* val destructor */\n    dictExpandAllowed           /* allow to expand */\n};\n\n/* Command table. sds string -> command struct pointer. */\ndictType commandTableDictType = {\n    dictSdsCaseHash,            /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictSdsKeyCaseCompare,      /* key compare */\n    dictSdsDestructor,          /* key destructor */\n    NULL,                       /* val destructor */\n    NULL                        /* allow to expand */\n};\n\n/* Hash type hash table (note that small hashes are represented with ziplists) */\ndictType hashDictType = {\n    dictSdsHash,                /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictSdsKeyCompare,          /* key compare */\n    dictSdsDestructor,          /* key destructor */\n    dictSdsDestructor,          /* val destructor */\n    NULL                        /* allow to expand */\n};\n\n/* Dict type without destructor */\ndictType sdsReplyDictType = {\n    dictSdsHash,                /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictSdsKeyCompare,          /* key compare */\n    NULL,                       /* key destructor */\n    NULL,                       /* val destructor */\n    NULL                        /* allow to expand */\n};\n\n/* Keylist hash table type has unencoded redis objects as keys and\n * lists as values. It's used for blocking operations (BLPOP) and to\n * map swapped keys to a list of clients waiting for this keys to be loaded. */\ndictType keylistDictType = {\n    dictObjHash,                /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictObjKeyCompare,          /* key compare */\n    dictObjectDestructor,       /* key destructor */\n    dictListDestructor,         /* val destructor */\n    NULL                        /* allow to expand */\n};\n\n/* Cluster nodes hash table, mapping nodes addresses 1.2.3.4:6379 to\n * clusterNode structures. */\ndictType clusterNodesDictType = {\n    dictSdsHash,                /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictSdsKeyCompare,          /* key compare */\n    dictSdsDestructor,          /* key destructor */\n    NULL,                       /* val destructor */\n    NULL                        /* allow to expand */\n};\n\n/* Cluster re-addition blacklist. This maps node IDs to the time\n * we can re-add this node. The goal is to avoid readding a removed\n * node for some time. */\ndictType clusterNodesBlackListDictType = {\n    dictSdsCaseHash,            /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictSdsKeyCaseCompare,      /* key compare */\n    dictSdsDestructor,          /* key destructor */\n    NULL,                       /* val destructor */\n    NULL                        /* allow to expand */\n};\n\n/* Modules system dictionary type. Keys are module name,\n * values are pointer to RedisModule struct. */\ndictType modulesDictType = {\n    dictSdsCaseHash,            /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictSdsKeyCaseCompare,      /* key compare */\n    dictSdsDestructor,          /* key destructor */\n    NULL,                       /* val destructor */\n    NULL                        /* allow to expand */\n};\n\n/* Migrate cache dict type. */\ndictType migrateCacheDictType = {\n    dictSdsHash,                /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictSdsKeyCompare,          /* key compare */\n    dictSdsDestructor,          /* key destructor */\n    NULL,                       /* val destructor */\n    NULL                        /* allow to expand */\n};\n\n/* Replication cached script dict (server.repl_scriptcache_dict).\n * Keys are sds SHA1 strings, while values are not used at all in the current\n * implementation. */\ndictType replScriptCacheDictType = {\n    dictSdsCaseHash,            /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictSdsKeyCaseCompare,      /* key compare */\n    dictSdsDestructor,          /* key destructor */\n    NULL,                       /* val destructor */\n    NULL                        /* allow to expand */\n};\n\nint htNeedsResize(dict *dict) {\n    long long size, used;\n\n    size = dictSlots(dict);\n    used = dictSize(dict);\n    return (size > DICT_HT_INITIAL_SIZE &&\n            (used*100/size < HASHTABLE_MIN_FILL));\n}\n\n/* If the percentage of used slots in the HT reaches HASHTABLE_MIN_FILL\n * we resize the hash table to save memory */\nvoid tryResizeHashTables(int dbid) {\n    if (htNeedsResize(server.db[dbid].dict))\n        dictResize(server.db[dbid].dict);\n    if (htNeedsResize(server.db[dbid].expires))\n        dictResize(server.db[dbid].expires);\n}\n\n/* Our hash table implementation performs rehashing incrementally while\n * we write/read from the hash table. Still if the server is idle, the hash\n * table will use two tables for a long time. So we try to use 1 millisecond\n * of CPU time at every call of this function to perform some rehashing.\n *\n * The function returns 1 if some rehashing was performed, otherwise 0\n * is returned. */\nint incrementallyRehash(int dbid) {\n    /* Keys dictionary */\n    if (dictIsRehashing(server.db[dbid].dict)) {\n        dictRehashMilliseconds(server.db[dbid].dict,1);\n        return 1; /* already used our millisecond for this loop... */\n    }\n    /* Expires */\n    if (dictIsRehashing(server.db[dbid].expires)) {\n        dictRehashMilliseconds(server.db[dbid].expires,1);\n        return 1; /* already used our millisecond for this loop... */\n    }\n    return 0;\n}\n\n/* This function is called once a background process of some kind terminates,\n * as we want to avoid resizing the hash tables when there is a child in order\n * to play well with copy-on-write (otherwise when a resize happens lots of\n * memory pages are copied). The goal of this function is to update the ability\n * for dict.c to resize the hash tables accordingly to the fact we have an\n * active fork child running. */\nvoid updateDictResizePolicy(void) {\n    if (!hasActiveChildProcess())\n        dictEnableResize();\n    else\n        dictDisableResize();\n}\n\nconst char *strChildType(int type) {\n    switch(type) {\n        case CHILD_TYPE_RDB: return \"RDB\";\n        case CHILD_TYPE_AOF: return \"AOF\";\n        case CHILD_TYPE_LDB: return \"LDB\";\n        case CHILD_TYPE_MODULE: return \"MODULE\";\n        default: return \"Unknown\";\n    }\n}\n\n/* Return true if there are active children processes doing RDB saving,\n * AOF rewriting, or some side process spawned by a loaded module. */\nint hasActiveChildProcess() {\n    return server.child_pid != -1;\n}\n\nvoid resetChildState() {\n    server.child_type = CHILD_TYPE_NONE;\n    server.child_pid = -1;\n    server.stat_current_cow_bytes = 0;\n    server.stat_current_cow_updated = 0;\n    server.stat_current_save_keys_processed = 0;\n    server.stat_module_progress = 0;\n    server.stat_current_save_keys_total = 0;\n    updateDictResizePolicy();\n    closeChildInfoPipe();\n    moduleFireServerEvent(REDISMODULE_EVENT_FORK_CHILD,\n                          REDISMODULE_SUBEVENT_FORK_CHILD_DIED,\n                          NULL);\n}\n\n/* Return if child type is mutual exclusive with other fork children */\nint isMutuallyExclusiveChildType(int type) {\n    return type == CHILD_TYPE_RDB || type == CHILD_TYPE_AOF || type == CHILD_TYPE_MODULE;\n}\n\n/* Return true if this instance has persistence completely turned off:\n * both RDB and AOF are disabled. */\nint allPersistenceDisabled(void) {\n    return server.saveparamslen == 0 && server.aof_state == AOF_OFF;\n}\n\n/* ======================= Cron: called every 100 ms ======================== */\n\n/* Add a sample to the operations per second array of samples. */\nvoid trackInstantaneousMetric(int metric, long long current_reading) {\n    long long now = mstime();\n    long long t = now - server.inst_metric[metric].last_sample_time;\n    long long ops = current_reading -\n                    server.inst_metric[metric].last_sample_count;\n    long long ops_sec;\n\n    ops_sec = t > 0 ? (ops*1000/t) : 0;\n\n    server.inst_metric[metric].samples[server.inst_metric[metric].idx] =\n        ops_sec;\n    server.inst_metric[metric].idx++;\n    server.inst_metric[metric].idx %= STATS_METRIC_SAMPLES;\n    server.inst_metric[metric].last_sample_time = now;\n    server.inst_metric[metric].last_sample_count = current_reading;\n}\n\n/* Return the mean of all the samples. */\nlong long getInstantaneousMetric(int metric) {\n    int j;\n    long long sum = 0;\n\n    for (j = 0; j < STATS_METRIC_SAMPLES; j++)\n        sum += server.inst_metric[metric].samples[j];\n    return sum / STATS_METRIC_SAMPLES;\n}\n\n/* The client query buffer is an sds.c string that can end with a lot of\n * free space not used, this function reclaims space if needed.\n *\n * The function always returns 0 as it never terminates the client. */\nint clientsCronResizeQueryBuffer(client *c) {\n    size_t querybuf_size = sdsAllocSize(c->querybuf);\n    time_t idletime = server.unixtime - c->lastinteraction;\n\n    /* There are two conditions to resize the query buffer:\n     * 1) Query buffer is > BIG_ARG and too big for latest peak.\n     * 2) Query buffer is > BIG_ARG and client is idle. */\n    if (querybuf_size > PROTO_MBULK_BIG_ARG &&\n         ((querybuf_size/(c->querybuf_peak+1)) > 2 ||\n          idletime > 2))\n    {\n        /* Only resize the query buffer if it is actually wasting\n         * at least a few kbytes. */\n        if (sdsavail(c->querybuf) > 1024*4) {\n            c->querybuf = sdsRemoveFreeSpace(c->querybuf);\n        }\n    }\n    /* Reset the peak again to capture the peak memory usage in the next\n     * cycle. */\n    c->querybuf_peak = 0;\n\n    /* Clients representing masters also use a \"pending query buffer\" that\n     * is the yet not applied part of the stream we are reading. Such buffer\n     * also needs resizing from time to time, otherwise after a very large\n     * transfer (a huge value or a big MIGRATE operation) it will keep using\n     * a lot of memory. */\n    if (c->flags & CLIENT_MASTER) {\n        /* There are two conditions to resize the pending query buffer:\n         * 1) Pending Query buffer is > LIMIT_PENDING_QUERYBUF.\n         * 2) Used length is smaller than pending_querybuf_size/2 */\n        size_t pending_querybuf_size = sdsAllocSize(c->pending_querybuf);\n        if(pending_querybuf_size > LIMIT_PENDING_QUERYBUF &&\n           sdslen(c->pending_querybuf) < (pending_querybuf_size/2))\n        {\n            c->pending_querybuf = sdsRemoveFreeSpace(c->pending_querybuf);\n        }\n    }\n    return 0;\n}\n\n/* This function is used in order to track clients using the biggest amount\n * of memory in the latest few seconds. This way we can provide such information\n * in the INFO output (clients section), without having to do an O(N) scan for\n * all the clients.\n *\n * This is how it works. We have an array of CLIENTS_PEAK_MEM_USAGE_SLOTS slots\n * where we track, for each, the biggest client output and input buffers we\n * saw in that slot. Every slot correspond to one of the latest seconds, since\n * the array is indexed by doing UNIXTIME % CLIENTS_PEAK_MEM_USAGE_SLOTS.\n *\n * When we want to know what was recently the peak memory usage, we just scan\n * such few slots searching for the maximum value. */\n#define CLIENTS_PEAK_MEM_USAGE_SLOTS 8\nsize_t ClientsPeakMemInput[CLIENTS_PEAK_MEM_USAGE_SLOTS] = {0};\nsize_t ClientsPeakMemOutput[CLIENTS_PEAK_MEM_USAGE_SLOTS] = {0};\n\nint clientsCronTrackExpansiveClients(client *c, int time_idx) {\n    size_t in_usage = sdsZmallocSize(c->querybuf) + c->argv_len_sum +\n\t              (c->argv ? zmalloc_size(c->argv) : 0);\n    size_t out_usage = getClientOutputBufferMemoryUsage(c);\n\n    /* Track the biggest values observed so far in this slot. */\n    if (in_usage > ClientsPeakMemInput[time_idx]) ClientsPeakMemInput[time_idx] = in_usage;\n    if (out_usage > ClientsPeakMemOutput[time_idx]) ClientsPeakMemOutput[time_idx] = out_usage;\n\n    return 0; /* This function never terminates the client. */\n}\n\n/* Iterating all the clients in getMemoryOverheadData() is too slow and\n * in turn would make the INFO command too slow. So we perform this\n * computation incrementally and track the (not instantaneous but updated\n * to the second) total memory used by clients using clinetsCron() in\n * a more incremental way (depending on server.hz). */\nint clientsCronTrackClientsMemUsage(client *c) {\n    size_t mem = 0;\n    int type = getClientType(c);\n    mem += getClientOutputBufferMemoryUsage(c);\n    mem += sdsZmallocSize(c->querybuf);\n    mem += zmalloc_size(c);\n    mem += c->argv_len_sum;\n    if (c->argv) mem += zmalloc_size(c->argv);\n    /* Now that we have the memory used by the client, remove the old\n     * value from the old category, and add it back. */\n    server.stat_clients_type_memory[c->client_cron_last_memory_type] -=\n        c->client_cron_last_memory_usage;\n    server.stat_clients_type_memory[type] += mem;\n    /* Remember what we added and where, to remove it next time. */\n    c->client_cron_last_memory_usage = mem;\n    c->client_cron_last_memory_type = type;\n    return 0;\n}\n\n/* Return the max samples in the memory usage of clients tracked by\n * the function clientsCronTrackExpansiveClients(). */\nvoid getExpansiveClientsInfo(size_t *in_usage, size_t *out_usage) {\n    size_t i = 0, o = 0;\n    for (int j = 0; j < CLIENTS_PEAK_MEM_USAGE_SLOTS; j++) {\n        if (ClientsPeakMemInput[j] > i) i = ClientsPeakMemInput[j];\n        if (ClientsPeakMemOutput[j] > o) o = ClientsPeakMemOutput[j];\n    }\n    *in_usage = i;\n    *out_usage = o;\n}\n\n/* This function is called by serverCron() and is used in order to perform\n * operations on clients that are important to perform constantly. For instance\n * we use this function in order to disconnect clients after a timeout, including\n * clients blocked in some blocking command with a non-zero timeout.\n *\n * The function makes some effort to process all the clients every second, even\n * if this cannot be strictly guaranteed, since serverCron() may be called with\n * an actual frequency lower than server.hz in case of latency events like slow\n * commands.\n *\n * It is very important for this function, and the functions it calls, to be\n * very fast: sometimes Redis has tens of hundreds of connected clients, and the\n * default server.hz value is 10, so sometimes here we need to process thousands\n * of clients per second, turning this function into a source of latency.\n */\n#define CLIENTS_CRON_MIN_ITERATIONS 5\nvoid clientsCron(void) {\n    /* Try to process at least numclients/server.hz of clients\n     * per call. Since normally (if there are no big latency events) this\n     * function is called server.hz times per second, in the average case we\n     * process all the clients in 1 second. */\n    int numclients = listLength(server.clients);\n    int iterations = numclients/server.hz;\n    mstime_t now = mstime();\n\n    /* Process at least a few clients while we are at it, even if we need\n     * to process less than CLIENTS_CRON_MIN_ITERATIONS to meet our contract\n     * of processing each client once per second. */\n    if (iterations < CLIENTS_CRON_MIN_ITERATIONS)\n        iterations = (numclients < CLIENTS_CRON_MIN_ITERATIONS) ?\n                     numclients : CLIENTS_CRON_MIN_ITERATIONS;\n\n\n    int curr_peak_mem_usage_slot = server.unixtime % CLIENTS_PEAK_MEM_USAGE_SLOTS;\n    /* Always zero the next sample, so that when we switch to that second, we'll\n     * only register samples that are greater in that second without considering\n     * the history of such slot.\n     *\n     * Note: our index may jump to any random position if serverCron() is not\n     * called for some reason with the normal frequency, for instance because\n     * some slow command is called taking multiple seconds to execute. In that\n     * case our array may end containing data which is potentially older\n     * than CLIENTS_PEAK_MEM_USAGE_SLOTS seconds: however this is not a problem\n     * since here we want just to track if \"recently\" there were very expansive\n     * clients from the POV of memory usage. */\n    int zeroidx = (curr_peak_mem_usage_slot+1) % CLIENTS_PEAK_MEM_USAGE_SLOTS;\n    ClientsPeakMemInput[zeroidx] = 0;\n    ClientsPeakMemOutput[zeroidx] = 0;\n\n\n    while(listLength(server.clients) && iterations--) {\n        client *c;\n        listNode *head;\n\n        /* Rotate the list, take the current head, process.\n         * This way if the client must be removed from the list it's the\n         * first element and we don't incur into O(N) computation. */\n        listRotateTailToHead(server.clients);\n        head = listFirst(server.clients);\n        c = listNodeValue(head);\n        /* The following functions do different service checks on the client.\n         * The protocol is that they return non-zero if the client was\n         * terminated. */\n        if (clientsCronHandleTimeout(c,now)) continue;\n        if (clientsCronResizeQueryBuffer(c)) continue;\n        if (clientsCronTrackExpansiveClients(c, curr_peak_mem_usage_slot)) continue;\n        if (clientsCronTrackClientsMemUsage(c)) continue;\n    }\n}\n\n/* This function handles 'background' operations we are required to do\n * incrementally in Redis databases, such as active key expiring, resizing,\n * rehashing. */\nvoid databasesCron(void) {\n    /* Expire keys by random sampling. Not required for slaves\n     * as master will synthesize DELs for us. */\n    if (server.active_expire_enabled) {\n        if (iAmMaster()) {\n            activeExpireCycle(ACTIVE_EXPIRE_CYCLE_SLOW);\n        } else {\n            expireSlaveKeys();\n        }\n    }\n\n    /* Defrag keys gradually. */\n    activeDefragCycle();\n\n    /* Perform hash tables rehashing if needed, but only if there are no\n     * other processes saving the DB on disk. Otherwise rehashing is bad\n     * as will cause a lot of copy-on-write of memory pages. */\n    if (!hasActiveChildProcess()) {\n        /* We use global counters so if we stop the computation at a given\n         * DB we'll be able to start from the successive in the next\n         * cron loop iteration. */\n        static unsigned int resize_db = 0;\n        static unsigned int rehash_db = 0;\n        int dbs_per_call = CRON_DBS_PER_CALL;\n        int j;\n\n        /* Don't test more DBs than we have. */\n        if (dbs_per_call > server.dbnum) dbs_per_call = server.dbnum;\n\n        /* Resize */\n        for (j = 0; j < dbs_per_call; j++) {\n            tryResizeHashTables(resize_db % server.dbnum);\n            resize_db++;\n        }\n\n        /* Rehash */\n        if (server.activerehashing) {\n            for (j = 0; j < dbs_per_call; j++) {\n                int work_done = incrementallyRehash(rehash_db);\n                if (work_done) {\n                    /* If the function did some work, stop here, we'll do\n                     * more at the next cron loop. */\n                    break;\n                } else {\n                    /* If this db didn't need rehash, we'll try the next one. */\n                    rehash_db++;\n                    rehash_db %= server.dbnum;\n                }\n            }\n        }\n    }\n}\n\n/* We take a cached value of the unix time in the global state because with\n * virtual memory and aging there is to store the current time in objects at\n * every object access, and accuracy is not needed. To access a global var is\n * a lot faster than calling time(NULL).\n *\n * This function should be fast because it is called at every command execution\n * in call(), so it is possible to decide if to update the daylight saving\n * info or not using the 'update_daylight_info' argument. Normally we update\n * such info only when calling this function from serverCron() but not when\n * calling it from call(). */\nvoid updateCachedTime(int update_daylight_info) {\n    server.ustime = ustime();\n    server.mstime = server.ustime / 1000;\n    time_t unixtime = server.mstime / 1000;\n    atomicSet(server.unixtime, unixtime);\n\n    /* To get information about daylight saving time, we need to call\n     * localtime_r and cache the result. However calling localtime_r in this\n     * context is safe since we will never fork() while here, in the main\n     * thread. The logging function will call a thread safe version of\n     * localtime that has no locks. */\n    if (update_daylight_info) {\n        struct tm tm;\n        time_t ut = server.unixtime;\n        localtime_r(&ut,&tm);\n        server.daylight_active = tm.tm_isdst;\n    }\n}\n\nvoid checkChildrenDone(void) {\n    int statloc = 0;\n    pid_t pid;\n\n    if ((pid = waitpid(-1, &statloc, WNOHANG)) != 0) {\n        int exitcode = WIFEXITED(statloc) ? WEXITSTATUS(statloc) : -1;\n        int bysignal = 0;\n\n        if (WIFSIGNALED(statloc)) bysignal = WTERMSIG(statloc);\n\n        /* sigKillChildHandler catches the signal and calls exit(), but we\n         * must make sure not to flag lastbgsave_status, etc incorrectly.\n         * We could directly terminate the child process via SIGUSR1\n         * without handling it */\n        if (exitcode == SERVER_CHILD_NOERROR_RETVAL) {\n            bysignal = SIGUSR1;\n            exitcode = 1;\n        }\n\n        if (pid == -1) {\n            serverLog(LL_WARNING,\"waitpid() returned an error: %s. \"\n                \"child_type: %s, child_pid = %d\",\n                strerror(errno),\n                strChildType(server.child_type),\n                (int) server.child_pid);\n        } else if (pid == server.child_pid) {\n            if (server.child_type == CHILD_TYPE_RDB) {\n                backgroundSaveDoneHandler(exitcode, bysignal);\n            } else if (server.child_type == CHILD_TYPE_AOF) {\n                backgroundRewriteDoneHandler(exitcode, bysignal);\n            } else if (server.child_type == CHILD_TYPE_MODULE) {\n                ModuleForkDoneHandler(exitcode, bysignal);\n            } else {\n                serverPanic(\"Unknown child type %d for child pid %d\", server.child_type, server.child_pid);\n                exit(1);\n            }\n            if (!bysignal && exitcode == 0) receiveChildInfo();\n            resetChildState();\n        } else {\n            if (!ldbRemoveChild(pid)) {\n                serverLog(LL_WARNING,\n                          \"Warning, detected child with unmatched pid: %ld\",\n                          (long) pid);\n            }\n        }\n\n        /* start any pending forks immediately. */\n        replicationStartPendingFork();\n    }\n}\n\n/* Called from serverCron and loadingCron to update cached memory metrics. */\nvoid cronUpdateMemoryStats() {\n    /* Record the max memory used since the server was started. */\n    if (zmalloc_used_memory() > server.stat_peak_memory)\n        server.stat_peak_memory = zmalloc_used_memory();\n\n    run_with_period(100) {\n        /* Sample the RSS and other metrics here since this is a relatively slow call.\n         * We must sample the zmalloc_used at the same time we take the rss, otherwise\n         * the frag ratio calculate may be off (ratio of two samples at different times) */\n        server.cron_malloc_stats.process_rss = zmalloc_get_rss();\n        server.cron_malloc_stats.zmalloc_used = zmalloc_used_memory();\n        /* Sampling the allocator info can be slow too.\n         * The fragmentation ratio it'll show is potentially more accurate\n         * it excludes other RSS pages such as: shared libraries, LUA and other non-zmalloc\n         * allocations, and allocator reserved pages that can be pursed (all not actual frag) */\n        zmalloc_get_allocator_info(&server.cron_malloc_stats.allocator_allocated,\n                                   &server.cron_malloc_stats.allocator_active,\n                                   &server.cron_malloc_stats.allocator_resident);\n        /* in case the allocator isn't providing these stats, fake them so that\n         * fragmentation info still shows some (inaccurate metrics) */\n        if (!server.cron_malloc_stats.allocator_resident) {\n            /* LUA memory isn't part of zmalloc_used, but it is part of the process RSS,\n             * so we must deduct it in order to be able to calculate correct\n             * \"allocator fragmentation\" ratio */\n            size_t lua_memory = lua_gc(server.lua,LUA_GCCOUNT,0)*1024LL;\n            server.cron_malloc_stats.allocator_resident = server.cron_malloc_stats.process_rss - lua_memory;\n        }\n        if (!server.cron_malloc_stats.allocator_active)\n            server.cron_malloc_stats.allocator_active = server.cron_malloc_stats.allocator_resident;\n        if (!server.cron_malloc_stats.allocator_allocated)\n            server.cron_malloc_stats.allocator_allocated = server.cron_malloc_stats.zmalloc_used;\n    }\n}\n\n/* This is our timer interrupt, called server.hz times per second.\n * Here is where we do a number of things that need to be done asynchronously.\n * For instance:\n *\n * - Active expired keys collection (it is also performed in a lazy way on\n *   lookup).\n * - Software watchdog.\n * - Update some statistic.\n * - Incremental rehashing of the DBs hash tables.\n * - Triggering BGSAVE / AOF rewrite, and handling of terminated children.\n * - Clients timeout of different kinds.\n * - Replication reconnection.\n * - Many more...\n *\n * Everything directly called here will be called server.hz times per second,\n * so in order to throttle execution of things we want to do less frequently\n * a macro is used: run_with_period(milliseconds) { .... }\n */\n\nint serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) {\n    int j;\n    UNUSED(eventLoop);\n    UNUSED(id);\n    UNUSED(clientData);\n\n    /* Software watchdog: deliver the SIGALRM that will reach the signal\n     * handler if we don't return here fast enough. */\n    if (server.watchdog_period) watchdogScheduleSignal(server.watchdog_period);\n\n    /* Update the time cache. */\n    updateCachedTime(1);\n\n    server.hz = server.config_hz;\n    /* Adapt the server.hz value to the number of configured clients. If we have\n     * many clients, we want to call serverCron() with an higher frequency. */\n    if (server.dynamic_hz) {\n        while (listLength(server.clients) / server.hz >\n               MAX_CLIENTS_PER_CLOCK_TICK)\n        {\n            server.hz *= 2;\n            if (server.hz > CONFIG_MAX_HZ) {\n                server.hz = CONFIG_MAX_HZ;\n                break;\n            }\n        }\n    }\n\n    run_with_period(100) {\n        long long stat_net_input_bytes, stat_net_output_bytes;\n        atomicGet(server.stat_net_input_bytes, stat_net_input_bytes);\n        atomicGet(server.stat_net_output_bytes, stat_net_output_bytes);\n\n        trackInstantaneousMetric(STATS_METRIC_COMMAND,server.stat_numcommands);\n        trackInstantaneousMetric(STATS_METRIC_NET_INPUT,\n                stat_net_input_bytes);\n        trackInstantaneousMetric(STATS_METRIC_NET_OUTPUT,\n                stat_net_output_bytes);\n    }\n\n    /* We have just LRU_BITS bits per object for LRU information.\n     * So we use an (eventually wrapping) LRU clock.\n     *\n     * Note that even if the counter wraps it's not a big problem,\n     * everything will still work but some object will appear younger\n     * to Redis. However for this to happen a given object should never be\n     * touched for all the time needed to the counter to wrap, which is\n     * not likely.\n     *\n     * Note that you can change the resolution altering the\n     * LRU_CLOCK_RESOLUTION define. */\n    unsigned int lruclock = getLRUClock();\n    atomicSet(server.lruclock,lruclock);\n\n    cronUpdateMemoryStats();\n\n    /* We received a SIGTERM, shutting down here in a safe way, as it is\n     * not ok doing so inside the signal handler. */\n    if (server.shutdown_asap) {\n        if (prepareForShutdown(SHUTDOWN_NOFLAGS) == C_OK) exit(0);\n        serverLog(LL_WARNING,\"SIGTERM received but errors trying to shut down the server, check the logs for more information\");\n        server.shutdown_asap = 0;\n    }\n\n    /* Show some info about non-empty databases */\n    if (server.verbosity <= LL_VERBOSE) {\n        run_with_period(5000) {\n            for (j = 0; j < server.dbnum; j++) {\n                long long size, used, vkeys;\n\n                size = dictSlots(server.db[j].dict);\n                used = dictSize(server.db[j].dict);\n                vkeys = dictSize(server.db[j].expires);\n                if (used || vkeys) {\n                    serverLog(LL_VERBOSE,\"DB %d: %lld keys (%lld volatile) in %lld slots HT.\",j,used,vkeys,size);\n                }\n            }\n        }\n    }\n\n    /* Show information about connected clients */\n    if (!server.sentinel_mode) {\n        run_with_period(5000) {\n            serverLog(LL_DEBUG,\n                \"%lu clients connected (%lu replicas), %zu bytes in use\",\n                listLength(server.clients)-listLength(server.slaves),\n                listLength(server.slaves),\n                zmalloc_used_memory());\n        }\n    }\n\n    /* We need to do a few operations on clients asynchronously. */\n    clientsCron();\n\n    /* Handle background operations on Redis databases. */\n    databasesCron();\n\n    /* Start a scheduled AOF rewrite if this was requested by the user while\n     * a BGSAVE was in progress. */\n    if (!hasActiveChildProcess() &&\n        server.aof_rewrite_scheduled)\n    {\n        rewriteAppendOnlyFileBackground();\n    }\n\n    /* Check if a background saving or AOF rewrite in progress terminated. */\n    if (hasActiveChildProcess() || ldbPendingChildren())\n    {\n        run_with_period(1000) receiveChildInfo();\n        checkChildrenDone();\n    } else {\n        /* If there is not a background saving/rewrite in progress check if\n         * we have to save/rewrite now. */\n        for (j = 0; j < server.saveparamslen; j++) {\n            struct saveparam *sp = server.saveparams+j;\n\n            /* Save if we reached the given amount of changes,\n             * the given amount of seconds, and if the latest bgsave was\n             * successful or if, in case of an error, at least\n             * CONFIG_BGSAVE_RETRY_DELAY seconds already elapsed. */\n            if (server.dirty >= sp->changes &&\n                server.unixtime-server.lastsave > sp->seconds &&\n                (server.unixtime-server.lastbgsave_try >\n                 CONFIG_BGSAVE_RETRY_DELAY ||\n                 server.lastbgsave_status == C_OK))\n            {\n                serverLog(LL_NOTICE,\"%d changes in %d seconds. Saving...\",\n                    sp->changes, (int)sp->seconds);\n                rdbSaveInfo rsi, *rsiptr;\n                rsiptr = rdbPopulateSaveInfo(&rsi);\n                rdbSaveBackground(server.rdb_filename,rsiptr);\n                break;\n            }\n        }\n\n        /* Trigger an AOF rewrite if needed. */\n        if (server.aof_state == AOF_ON &&\n            !hasActiveChildProcess() &&\n            server.aof_rewrite_perc &&\n            server.aof_current_size > server.aof_rewrite_min_size)\n        {\n            long long base = server.aof_rewrite_base_size ?\n                server.aof_rewrite_base_size : 1;\n            long long growth = (server.aof_current_size*100/base) - 100;\n            if (growth >= server.aof_rewrite_perc) {\n                serverLog(LL_NOTICE,\"Starting automatic rewriting of AOF on %lld%% growth\",growth);\n                rewriteAppendOnlyFileBackground();\n            }\n        }\n    }\n    /* Just for the sake of defensive programming, to avoid forgeting to\n     * call this function when need. */\n    updateDictResizePolicy();\n\n\n    /* AOF postponed flush: Try at every cron cycle if the slow fsync\n     * completed. */\n    if (server.aof_state == AOF_ON && server.aof_flush_postponed_start)\n        flushAppendOnlyFile(0);\n\n    /* AOF write errors: in this case we have a buffer to flush as well and\n     * clear the AOF error in case of success to make the DB writable again,\n     * however to try every second is enough in case of 'hz' is set to\n     * a higher frequency. */\n    run_with_period(1000) {\n        if (server.aof_state == AOF_ON && server.aof_last_write_status == C_ERR)\n            flushAppendOnlyFile(0);\n    }\n\n    /* Clear the paused clients state if needed. */\n    checkClientPauseTimeoutAndReturnIfPaused();\n\n    /* Replication cron function -- used to reconnect to master,\n     * detect transfer failures, start background RDB transfers and so forth. \n     * \n     * If Redis is trying to failover then run the replication cron faster so\n     * progress on the handshake happens more quickly. */\n    if (server.failover_state != NO_FAILOVER) {\n        run_with_period(100) replicationCron();\n    } else {\n        run_with_period(1000) replicationCron();\n    }\n\n    /* Run the Redis Cluster cron. */\n    run_with_period(100) {\n        if (server.cluster_enabled) clusterCron();\n    }\n\n    /* Run the Sentinel timer if we are in sentinel mode. */\n    if (server.sentinel_mode) sentinelTimer();\n\n    /* Cleanup expired MIGRATE cached sockets. */\n    run_with_period(1000) {\n        migrateCloseTimedoutSockets();\n    }\n\n    /* Stop the I/O threads if we don't have enough pending work. */\n    stopThreadedIOIfNeeded();\n\n    /* Resize tracking keys table if needed. This is also done at every\n     * command execution, but we want to be sure that if the last command\n     * executed changes the value via CONFIG SET, the server will perform\n     * the operation even if completely idle. */\n    if (server.tracking_clients) trackingLimitUsedSlots();\n\n    /* Start a scheduled BGSAVE if the corresponding flag is set. This is\n     * useful when we are forced to postpone a BGSAVE because an AOF\n     * rewrite is in progress.\n     *\n     * Note: this code must be after the replicationCron() call above so\n     * make sure when refactoring this file to keep this order. This is useful\n     * because we want to give priority to RDB savings for replication. */\n    if (!hasActiveChildProcess() &&\n        server.rdb_bgsave_scheduled &&\n        (server.unixtime-server.lastbgsave_try > CONFIG_BGSAVE_RETRY_DELAY ||\n         server.lastbgsave_status == C_OK))\n    {\n        rdbSaveInfo rsi, *rsiptr;\n        rsiptr = rdbPopulateSaveInfo(&rsi);\n        if (rdbSaveBackground(server.rdb_filename,rsiptr) == C_OK)\n            server.rdb_bgsave_scheduled = 0;\n    }\n\n    /* Fire the cron loop modules event. */\n    RedisModuleCronLoopV1 ei = {REDISMODULE_CRON_LOOP_VERSION,server.hz};\n    moduleFireServerEvent(REDISMODULE_EVENT_CRON_LOOP,\n                          0,\n                          &ei);\n\n    server.cronloops++;\n    return 1000/server.hz;\n}\n\n\nvoid blockingOperationStarts() {\n    if(!server.blocking_op_nesting++){\n        updateCachedTime(0);\n        server.blocked_last_cron = server.mstime;\n    }\n}\n\nvoid blockingOperationEnds() {\n    if(!(--server.blocking_op_nesting)){\n        server.blocked_last_cron = 0;\n    }\n}\n\n/* This function fill in the role of serverCron during RDB or AOF loading, and\n * also during blocked scripts.\n * It attempts to do its duties at a similar rate as the configured server.hz,\n * and updates cronloops variable so that similarly to serverCron, the\n * run_with_period can be used. */\nvoid whileBlockedCron() {\n    /* Here we may want to perform some cron jobs (normally done server.hz times\n     * per second). */\n\n    /* Since this function depends on a call to blockingOperationStarts, let's\n     * make sure it was done. */\n    serverAssert(server.blocked_last_cron);\n\n    /* In case we where called too soon, leave right away. This way one time\n     * jobs after the loop below don't need an if. and we don't bother to start\n     * latency monitor if this function is called too often. */\n    if (server.blocked_last_cron >= server.mstime)\n        return;\n\n    mstime_t latency;\n    latencyStartMonitor(latency);\n\n    /* In some cases we may be called with big intervals, so we may need to do\n     * extra work here. This is because some of the functions in serverCron rely\n     * on the fact that it is performed every 10 ms or so. For instance, if\n     * activeDefragCycle needs to utilize 25% cpu, it will utilize 2.5ms, so we\n     * need to call it multiple times. */\n    long hz_ms = 1000/server.hz;\n    while (server.blocked_last_cron < server.mstime) {\n\n        /* Defrag keys gradually. */\n        activeDefragCycle();\n\n        server.blocked_last_cron += hz_ms;\n\n        /* Increment cronloop so that run_with_period works. */\n        server.cronloops++;\n    }\n\n    /* Other cron jobs do not need to be done in a loop. No need to check\n     * server.blocked_last_cron since we have an early exit at the top. */\n\n    /* Update memory stats during loading (excluding blocked scripts) */\n    if (server.loading) cronUpdateMemoryStats();\n\n    latencyEndMonitor(latency);\n    latencyAddSampleIfNeeded(\"while-blocked-cron\",latency);\n}\n\nextern int ProcessingEventsWhileBlocked;\n\n/* This function gets called every time Redis is entering the\n * main loop of the event driven library, that is, before to sleep\n * for ready file descriptors.\n *\n * Note: This function is (currently) called from two functions:\n * 1. aeMain - The main server loop\n * 2. processEventsWhileBlocked - Process clients during RDB/AOF load\n *\n * If it was called from processEventsWhileBlocked we don't want\n * to perform all actions (For example, we don't want to expire\n * keys), but we do need to perform some actions.\n *\n * The most important is freeClientsInAsyncFreeQueue but we also\n * call some other low-risk functions. */\nvoid beforeSleep(struct aeEventLoop *eventLoop) {\n    UNUSED(eventLoop);\n\n    size_t zmalloc_used = zmalloc_used_memory();\n    if (zmalloc_used > server.stat_peak_memory)\n        server.stat_peak_memory = zmalloc_used;\n\n    /* Just call a subset of vital functions in case we are re-entering\n     * the event loop from processEventsWhileBlocked(). Note that in this\n     * case we keep track of the number of events we are processing, since\n     * processEventsWhileBlocked() wants to stop ASAP if there are no longer\n     * events to handle. */\n    if (ProcessingEventsWhileBlocked) {\n        uint64_t processed = 0;\n        processed += handleClientsWithPendingReadsUsingThreads();\n        processed += tlsProcessPendingData();\n        processed += handleClientsWithPendingWrites();\n        processed += freeClientsInAsyncFreeQueue();\n        server.events_processed_while_blocked += processed;\n        return;\n    }\n\n    /* Handle precise timeouts of blocked clients. */\n    handleBlockedClientsTimeout();\n\n    /* We should handle pending reads clients ASAP after event loop. */\n    handleClientsWithPendingReadsUsingThreads();\n\n    /* Handle TLS pending data. (must be done before flushAppendOnlyFile) */\n    tlsProcessPendingData();\n\n    /* If tls still has pending unread data don't sleep at all. */\n    aeSetDontWait(server.el, tlsHasPendingData());\n\n    /* Call the Redis Cluster before sleep function. Note that this function\n     * may change the state of Redis Cluster (from ok to fail or vice versa),\n     * so it's a good idea to call it before serving the unblocked clients\n     * later in this function. */\n    if (server.cluster_enabled) clusterBeforeSleep();\n\n    /* Run a fast expire cycle (the called function will return\n     * ASAP if a fast cycle is not needed). */\n    if (server.active_expire_enabled && server.masterhost == NULL)\n        activeExpireCycle(ACTIVE_EXPIRE_CYCLE_FAST);\n\n    /* Unblock all the clients blocked for synchronous replication\n     * in WAIT. */\n    if (listLength(server.clients_waiting_acks))\n        processClientsWaitingReplicas();\n\n    /* Check if there are clients unblocked by modules that implement\n     * blocking commands. */\n    if (moduleCount()) moduleHandleBlockedClients();\n\n    /* Try to process pending commands for clients that were just unblocked. */\n    if (listLength(server.unblocked_clients))\n        processUnblockedClients();\n\n    /* Send all the slaves an ACK request if at least one client blocked\n     * during the previous event loop iteration. Note that we do this after\n     * processUnblockedClients(), so if there are multiple pipelined WAITs\n     * and the just unblocked WAIT gets blocked again, we don't have to wait\n     * a server cron cycle in absence of other event loop events. See #6623.\n     * \n     * We also don't send the ACKs while clients are paused, since it can\n     * increment the replication backlog, they'll be sent after the pause\n     * if we are still the master. */\n    if (server.get_ack_from_slaves && !checkClientPauseTimeoutAndReturnIfPaused()) {\n        robj *argv[3];\n\n        argv[0] = shared.replconf;\n        argv[1] = shared.getack;\n        argv[2] = shared.special_asterick; /* Not used argument. */\n        replicationFeedSlaves(server.slaves, server.slaveseldb, argv, 3);\n        server.get_ack_from_slaves = 0;\n    }\n\n    /* We may have received updates from clients about their current offset. NOTE:\n     * this can't be done where the ACK is received since failover will disconnect \n     * our clients. */\n    updateFailoverStatus();\n\n    /* Send the invalidation messages to clients participating to the\n     * client side caching protocol in broadcasting (BCAST) mode. */\n    trackingBroadcastInvalidationMessages();\n\n    /* Write the AOF buffer on disk */\n    if (server.aof_state == AOF_ON)\n        flushAppendOnlyFile(0);\n\n    /* Handle writes with pending output buffers. */\n    handleClientsWithPendingWritesUsingThreads();\n\n    /* Close clients that need to be closed asynchronous */\n    freeClientsInAsyncFreeQueue();\n\n    /* Try to process blocked clients every once in while. Example: A module\n     * calls RM_SignalKeyAsReady from within a timer callback (So we don't\n     * visit processCommand() at all). */\n    handleClientsBlockedOnKeys();\n\n    /* Before we are going to sleep, let the threads access the dataset by\n     * releasing the GIL. Redis main thread will not touch anything at this\n     * time. */\n    if (moduleCount()) moduleReleaseGIL();\n\n    /* Do NOT add anything below moduleReleaseGIL !!! */\n}\n\n/* This function is called immediately after the event loop multiplexing\n * API returned, and the control is going to soon return to Redis by invoking\n * the different events callbacks. */\nvoid afterSleep(struct aeEventLoop *eventLoop) {\n    UNUSED(eventLoop);\n\n    /* Do NOT add anything above moduleAcquireGIL !!! */\n\n    /* Aquire the modules GIL so that their threads won't touch anything. */\n    if (!ProcessingEventsWhileBlocked) {\n        if (moduleCount()) moduleAcquireGIL();\n    }\n}\n\n/* =========================== Server initialization ======================== */\n\nvoid createSharedObjects(void) {\n    int j;\n\n    /* Shared command responses */\n    shared.crlf = createObject(OBJ_STRING,sdsnew(\"\\r\\n\"));\n    shared.ok = createObject(OBJ_STRING,sdsnew(\"+OK\\r\\n\"));\n    shared.emptybulk = createObject(OBJ_STRING,sdsnew(\"$0\\r\\n\\r\\n\"));\n    shared.czero = createObject(OBJ_STRING,sdsnew(\":0\\r\\n\"));\n    shared.cone = createObject(OBJ_STRING,sdsnew(\":1\\r\\n\"));\n    shared.emptyarray = createObject(OBJ_STRING,sdsnew(\"*0\\r\\n\"));\n    shared.pong = createObject(OBJ_STRING,sdsnew(\"+PONG\\r\\n\"));\n    shared.queued = createObject(OBJ_STRING,sdsnew(\"+QUEUED\\r\\n\"));\n    shared.emptyscan = createObject(OBJ_STRING,sdsnew(\"*2\\r\\n$1\\r\\n0\\r\\n*0\\r\\n\"));\n    shared.space = createObject(OBJ_STRING,sdsnew(\" \"));\n    shared.colon = createObject(OBJ_STRING,sdsnew(\":\"));\n    shared.plus = createObject(OBJ_STRING,sdsnew(\"+\"));\n\n    /* Shared command error responses */\n    shared.wrongtypeerr = createObject(OBJ_STRING,sdsnew(\n        \"-WRONGTYPE Operation against a key holding the wrong kind of value\\r\\n\"));\n    shared.err = createObject(OBJ_STRING,sdsnew(\"-ERR\\r\\n\"));\n    shared.nokeyerr = createObject(OBJ_STRING,sdsnew(\n        \"-ERR no such key\\r\\n\"));\n    shared.syntaxerr = createObject(OBJ_STRING,sdsnew(\n        \"-ERR syntax error\\r\\n\"));\n    shared.sameobjecterr = createObject(OBJ_STRING,sdsnew(\n        \"-ERR source and destination objects are the same\\r\\n\"));\n    shared.outofrangeerr = createObject(OBJ_STRING,sdsnew(\n        \"-ERR index out of range\\r\\n\"));\n    shared.noscripterr = createObject(OBJ_STRING,sdsnew(\n        \"-NOSCRIPT No matching script. Please use EVAL.\\r\\n\"));\n    shared.loadingerr = createObject(OBJ_STRING,sdsnew(\n        \"-LOADING Redis is loading the dataset in memory\\r\\n\"));\n    shared.slowscripterr = createObject(OBJ_STRING,sdsnew(\n        \"-BUSY Redis is busy running a script. You can only call SCRIPT KILL or SHUTDOWN NOSAVE.\\r\\n\"));\n    shared.masterdownerr = createObject(OBJ_STRING,sdsnew(\n        \"-MASTERDOWN Link with MASTER is down and replica-serve-stale-data is set to 'no'.\\r\\n\"));\n    shared.bgsaveerr = createObject(OBJ_STRING,sdsnew(\n        \"-MISCONF Redis is configured to save RDB snapshots, but it is currently not able to persist on disk. Commands that may modify the data set are disabled, because this instance is configured to report errors during writes if RDB snapshotting fails (stop-writes-on-bgsave-error option). Please check the Redis logs for details about the RDB error.\\r\\n\"));\n    shared.roslaveerr = createObject(OBJ_STRING,sdsnew(\n        \"-READONLY You can't write against a read only replica.\\r\\n\"));\n    shared.noautherr = createObject(OBJ_STRING,sdsnew(\n        \"-NOAUTH Authentication required.\\r\\n\"));\n    shared.oomerr = createObject(OBJ_STRING,sdsnew(\n        \"-OOM command not allowed when used memory > 'maxmemory'.\\r\\n\"));\n    shared.execaborterr = createObject(OBJ_STRING,sdsnew(\n        \"-EXECABORT Transaction discarded because of previous errors.\\r\\n\"));\n    shared.noreplicaserr = createObject(OBJ_STRING,sdsnew(\n        \"-NOREPLICAS Not enough good replicas to write.\\r\\n\"));\n    shared.busykeyerr = createObject(OBJ_STRING,sdsnew(\n        \"-BUSYKEY Target key name already exists.\\r\\n\"));\n\n    /* The shared NULL depends on the protocol version. */\n    shared.null[0] = NULL;\n    shared.null[1] = NULL;\n    shared.null[2] = createObject(OBJ_STRING,sdsnew(\"$-1\\r\\n\"));\n    shared.null[3] = createObject(OBJ_STRING,sdsnew(\"_\\r\\n\"));\n\n    shared.nullarray[0] = NULL;\n    shared.nullarray[1] = NULL;\n    shared.nullarray[2] = createObject(OBJ_STRING,sdsnew(\"*-1\\r\\n\"));\n    shared.nullarray[3] = createObject(OBJ_STRING,sdsnew(\"_\\r\\n\"));\n\n    shared.emptymap[0] = NULL;\n    shared.emptymap[1] = NULL;\n    shared.emptymap[2] = createObject(OBJ_STRING,sdsnew(\"*0\\r\\n\"));\n    shared.emptymap[3] = createObject(OBJ_STRING,sdsnew(\"%0\\r\\n\"));\n\n    shared.emptyset[0] = NULL;\n    shared.emptyset[1] = NULL;\n    shared.emptyset[2] = createObject(OBJ_STRING,sdsnew(\"*0\\r\\n\"));\n    shared.emptyset[3] = createObject(OBJ_STRING,sdsnew(\"~0\\r\\n\"));\n\n    for (j = 0; j < PROTO_SHARED_SELECT_CMDS; j++) {\n        char dictid_str[64];\n        int dictid_len;\n\n        dictid_len = ll2string(dictid_str,sizeof(dictid_str),j);\n        shared.select[j] = createObject(OBJ_STRING,\n            sdscatprintf(sdsempty(),\n                \"*2\\r\\n$6\\r\\nSELECT\\r\\n$%d\\r\\n%s\\r\\n\",\n                dictid_len, dictid_str));\n    }\n    shared.messagebulk = createStringObject(\"$7\\r\\nmessage\\r\\n\",13);\n    shared.pmessagebulk = createStringObject(\"$8\\r\\npmessage\\r\\n\",14);\n    shared.subscribebulk = createStringObject(\"$9\\r\\nsubscribe\\r\\n\",15);\n    shared.unsubscribebulk = createStringObject(\"$11\\r\\nunsubscribe\\r\\n\",18);\n    shared.psubscribebulk = createStringObject(\"$10\\r\\npsubscribe\\r\\n\",17);\n    shared.punsubscribebulk = createStringObject(\"$12\\r\\npunsubscribe\\r\\n\",19);\n\n    /* Shared command names */\n    shared.del = createStringObject(\"DEL\",3);\n    shared.unlink = createStringObject(\"UNLINK\",6);\n    shared.rpop = createStringObject(\"RPOP\",4);\n    shared.lpop = createStringObject(\"LPOP\",4);\n    shared.lpush = createStringObject(\"LPUSH\",5);\n    shared.rpoplpush = createStringObject(\"RPOPLPUSH\",9);\n    shared.lmove = createStringObject(\"LMOVE\",5);\n    shared.blmove = createStringObject(\"BLMOVE\",6);\n    shared.zpopmin = createStringObject(\"ZPOPMIN\",7);\n    shared.zpopmax = createStringObject(\"ZPOPMAX\",7);\n    shared.multi = createStringObject(\"MULTI\",5);\n    shared.exec = createStringObject(\"EXEC\",4);\n    shared.hset = createStringObject(\"HSET\",4);\n    shared.srem = createStringObject(\"SREM\",4);\n    shared.xgroup = createStringObject(\"XGROUP\",6);\n    shared.xclaim = createStringObject(\"XCLAIM\",6);\n    shared.script = createStringObject(\"SCRIPT\",6);\n    shared.replconf = createStringObject(\"REPLCONF\",8);\n    shared.pexpireat = createStringObject(\"PEXPIREAT\",9);\n    shared.pexpire = createStringObject(\"PEXPIRE\",7);\n    shared.persist = createStringObject(\"PERSIST\",7);\n    shared.set = createStringObject(\"SET\",3);\n    shared.eval = createStringObject(\"EVAL\",4);\n\n    /* Shared command argument */\n    shared.left = createStringObject(\"left\",4);\n    shared.right = createStringObject(\"right\",5);\n    shared.pxat = createStringObject(\"PXAT\", 4);\n    shared.px = createStringObject(\"PX\",2);\n    shared.time = createStringObject(\"TIME\",4);\n    shared.retrycount = createStringObject(\"RETRYCOUNT\",10);\n    shared.force = createStringObject(\"FORCE\",5);\n    shared.justid = createStringObject(\"JUSTID\",6);\n    shared.lastid = createStringObject(\"LASTID\",6);\n    shared.default_username = createStringObject(\"default\",7);\n    shared.ping = createStringObject(\"ping\",4);\n    shared.setid = createStringObject(\"SETID\",5);\n    shared.keepttl = createStringObject(\"KEEPTTL\",7);\n    shared.load = createStringObject(\"LOAD\",4);\n    shared.createconsumer = createStringObject(\"CREATECONSUMER\",14);\n    shared.getack = createStringObject(\"GETACK\",6);\n    shared.special_asterick = createStringObject(\"*\",1);\n    shared.special_equals = createStringObject(\"=\",1);\n\n    for (j = 0; j < OBJ_SHARED_INTEGERS; j++) {\n        shared.integers[j] =\n            makeObjectShared(createObject(OBJ_STRING,(void*)(long)j));\n        shared.integers[j]->encoding = OBJ_ENCODING_INT;\n    }\n    for (j = 0; j < OBJ_SHARED_BULKHDR_LEN; j++) {\n        shared.mbulkhdr[j] = createObject(OBJ_STRING,\n            sdscatprintf(sdsempty(),\"*%d\\r\\n\",j));\n        shared.bulkhdr[j] = createObject(OBJ_STRING,\n            sdscatprintf(sdsempty(),\"$%d\\r\\n\",j));\n    }\n    /* The following two shared objects, minstring and maxstrings, are not\n     * actually used for their value but as a special object meaning\n     * respectively the minimum possible string and the maximum possible\n     * string in string comparisons for the ZRANGEBYLEX command. */\n    shared.minstring = sdsnew(\"minstring\");\n    shared.maxstring = sdsnew(\"maxstring\");\n}\n\nvoid initServerConfig(void) {\n    int j;\n\n    updateCachedTime(1);\n    getRandomHexChars(server.runid,CONFIG_RUN_ID_SIZE);\n    server.runid[CONFIG_RUN_ID_SIZE] = '\\0';\n    changeReplicationId();\n    clearReplicationId2();\n    server.hz = CONFIG_DEFAULT_HZ; /* Initialize it ASAP, even if it may get\n                                      updated later after loading the config.\n                                      This value may be used before the server\n                                      is initialized. */\n    server.timezone = getTimeZone(); /* Initialized by tzset(). */\n    server.configfile = NULL;\n    server.executable = NULL;\n    server.arch_bits = (sizeof(long) == 8) ? 64 : 32;\n    server.bindaddr_count = 0;\n    server.unixsocketperm = CONFIG_DEFAULT_UNIX_SOCKET_PERM;\n    server.ipfd.count = 0;\n    server.tlsfd.count = 0;\n    server.sofd = -1;\n    server.active_expire_enabled = 1;\n    server.skip_checksum_validation = 0;\n    server.saveparams = NULL;\n    server.loading = 0;\n    server.loading_rdb_used_mem = 0;\n    server.logfile = zstrdup(CONFIG_DEFAULT_LOGFILE);\n    server.aof_state = AOF_OFF;\n    server.aof_rewrite_base_size = 0;\n    server.aof_rewrite_scheduled = 0;\n    server.aof_flush_sleep = 0;\n    server.aof_last_fsync = time(NULL);\n    atomicSet(server.aof_bio_fsync_status,C_OK);\n    server.aof_rewrite_time_last = -1;\n    server.aof_rewrite_time_start = -1;\n    server.aof_lastbgrewrite_status = C_OK;\n    server.aof_delayed_fsync = 0;\n    server.aof_fd = -1;\n    server.aof_selected_db = -1; /* Make sure the first time will not match */\n    server.aof_flush_postponed_start = 0;\n    server.pidfile = NULL;\n    server.active_defrag_running = 0;\n    server.notify_keyspace_events = 0;\n    server.blocked_clients = 0;\n    memset(server.blocked_clients_by_type,0,\n           sizeof(server.blocked_clients_by_type));\n    server.shutdown_asap = 0;\n    server.cluster_configfile = zstrdup(CONFIG_DEFAULT_CLUSTER_CONFIG_FILE);\n    server.cluster_module_flags = CLUSTER_MODULE_FLAG_NONE;\n    server.migrate_cached_sockets = dictCreate(&migrateCacheDictType,NULL);\n    server.next_client_id = 1; /* Client IDs, start from 1 .*/\n    server.loading_process_events_interval_bytes = (1024*1024*2);\n\n    unsigned int lruclock = getLRUClock();\n    atomicSet(server.lruclock,lruclock);\n    resetServerSaveParams();\n\n    appendServerSaveParams(60*60,1);  /* save after 1 hour and 1 change */\n    appendServerSaveParams(300,100);  /* save after 5 minutes and 100 changes */\n    appendServerSaveParams(60,10000); /* save after 1 minute and 10000 changes */\n\n    /* Replication related */\n    server.masterauth = NULL;\n    server.masterhost = NULL;\n    server.masterport = 6379;\n    server.master = NULL;\n    server.cached_master = NULL;\n    server.master_initial_offset = -1;\n    server.repl_state = REPL_STATE_NONE;\n    server.repl_transfer_tmpfile = NULL;\n    server.repl_transfer_fd = -1;\n    server.repl_transfer_s = NULL;\n    server.repl_syncio_timeout = CONFIG_REPL_SYNCIO_TIMEOUT;\n    server.repl_down_since = 0; /* Never connected, repl is down since EVER. */\n    server.master_repl_offset = 0;\n\n    /* Replication partial resync backlog */\n    server.repl_backlog = NULL;\n    server.repl_backlog_histlen = 0;\n    server.repl_backlog_idx = 0;\n    server.repl_backlog_off = 0;\n    server.repl_no_slaves_since = time(NULL);\n\n    /* Failover related */\n    server.failover_end_time = 0;\n    server.force_failover = 0;\n    server.target_replica_host = NULL;\n    server.target_replica_port = 0;\n    server.failover_state = NO_FAILOVER;\n\n    /* Client output buffer limits */\n    for (j = 0; j < CLIENT_TYPE_OBUF_COUNT; j++)\n        server.client_obuf_limits[j] = clientBufferLimitsDefaults[j];\n\n    /* Linux OOM Score config */\n    for (j = 0; j < CONFIG_OOM_COUNT; j++)\n        server.oom_score_adj_values[j] = configOOMScoreAdjValuesDefaults[j];\n\n    /* Double constants initialization */\n    R_Zero = 0.0;\n    R_PosInf = 1.0/R_Zero;\n    R_NegInf = -1.0/R_Zero;\n    R_Nan = R_Zero/R_Zero;\n\n    /* Command table -- we initialize it here as it is part of the\n     * initial configuration, since command names may be changed via\n     * redis.conf using the rename-command directive. */\n    server.commands = dictCreate(&commandTableDictType,NULL);\n    server.orig_commands = dictCreate(&commandTableDictType,NULL);\n    populateCommandTable();\n    server.delCommand = lookupCommandByCString(\"del\");\n    server.multiCommand = lookupCommandByCString(\"multi\");\n    server.lpushCommand = lookupCommandByCString(\"lpush\");\n    server.lpopCommand = lookupCommandByCString(\"lpop\");\n    server.rpopCommand = lookupCommandByCString(\"rpop\");\n    server.zpopminCommand = lookupCommandByCString(\"zpopmin\");\n    server.zpopmaxCommand = lookupCommandByCString(\"zpopmax\");\n    server.sremCommand = lookupCommandByCString(\"srem\");\n    server.execCommand = lookupCommandByCString(\"exec\");\n    server.expireCommand = lookupCommandByCString(\"expire\");\n    server.pexpireCommand = lookupCommandByCString(\"pexpire\");\n    server.xclaimCommand = lookupCommandByCString(\"xclaim\");\n    server.xgroupCommand = lookupCommandByCString(\"xgroup\");\n    server.rpoplpushCommand = lookupCommandByCString(\"rpoplpush\");\n    server.lmoveCommand = lookupCommandByCString(\"lmove\");\n\n    /* Debugging */\n    server.watchdog_period = 0;\n\n    /* By default we want scripts to be always replicated by effects\n     * (single commands executed by the script), and not by sending the\n     * script to the slave / AOF. This is the new way starting from\n     * Redis 5. However it is possible to revert it via redis.conf. */\n    server.lua_always_replicate_commands = 1;\n\n    initConfigValues();\n}\n\nextern char **environ;\n\n/* Restart the server, executing the same executable that started this\n * instance, with the same arguments and configuration file.\n *\n * The function is designed to directly call execve() so that the new\n * server instance will retain the PID of the previous one.\n *\n * The list of flags, that may be bitwise ORed together, alter the\n * behavior of this function:\n *\n * RESTART_SERVER_NONE              No flags.\n * RESTART_SERVER_GRACEFULLY        Do a proper shutdown before restarting.\n * RESTART_SERVER_CONFIG_REWRITE    Rewrite the config file before restarting.\n *\n * On success the function does not return, because the process turns into\n * a different process. On error C_ERR is returned. */\nint restartServer(int flags, mstime_t delay) {\n    int j;\n\n    /* Check if we still have accesses to the executable that started this\n     * server instance. */\n    if (access(server.executable,X_OK) == -1) {\n        serverLog(LL_WARNING,\"Can't restart: this process has no \"\n                             \"permissions to execute %s\", server.executable);\n        return C_ERR;\n    }\n\n    /* Config rewriting. */\n    if (flags & RESTART_SERVER_CONFIG_REWRITE &&\n        server.configfile &&\n        rewriteConfig(server.configfile, 0) == -1)\n    {\n        serverLog(LL_WARNING,\"Can't restart: configuration rewrite process \"\n                             \"failed\");\n        return C_ERR;\n    }\n\n    /* Perform a proper shutdown. */\n    if (flags & RESTART_SERVER_GRACEFULLY &&\n        prepareForShutdown(SHUTDOWN_NOFLAGS) != C_OK)\n    {\n        serverLog(LL_WARNING,\"Can't restart: error preparing for shutdown\");\n        return C_ERR;\n    }\n\n    /* Close all file descriptors, with the exception of stdin, stdout, strerr\n     * which are useful if we restart a Redis server which is not daemonized. */\n    for (j = 3; j < (int)server.maxclients + 1024; j++) {\n        /* Test the descriptor validity before closing it, otherwise\n         * Valgrind issues a warning on close(). */\n        if (fcntl(j,F_GETFD) != -1) close(j);\n    }\n\n    /* Execute the server with the original command line. */\n    if (delay) usleep(delay*1000);\n    zfree(server.exec_argv[0]);\n    server.exec_argv[0] = zstrdup(server.executable);\n    execve(server.executable,server.exec_argv,environ);\n\n    /* If an error occurred here, there is nothing we can do, but exit. */\n    _exit(1);\n\n    return C_ERR; /* Never reached. */\n}\n\nstatic void readOOMScoreAdj(void) {\n#ifdef HAVE_PROC_OOM_SCORE_ADJ\n    char buf[64];\n    int fd = open(\"/proc/self/oom_score_adj\", O_RDONLY);\n\n    if (fd < 0) return;\n    if (read(fd, buf, sizeof(buf)) > 0)\n        server.oom_score_adj_base = atoi(buf);\n    close(fd);\n#endif\n}\n\n/* This function will configure the current process's oom_score_adj according\n * to user specified configuration. This is currently implemented on Linux\n * only.\n *\n * A process_class value of -1 implies OOM_CONFIG_MASTER or OOM_CONFIG_REPLICA,\n * depending on current role.\n */\nint setOOMScoreAdj(int process_class) {\n\n    if (server.oom_score_adj == OOM_SCORE_ADJ_NO) return C_OK;\n    if (process_class == -1)\n        process_class = (server.masterhost ? CONFIG_OOM_REPLICA : CONFIG_OOM_MASTER);\n\n    serverAssert(process_class >= 0 && process_class < CONFIG_OOM_COUNT);\n\n#ifdef HAVE_PROC_OOM_SCORE_ADJ\n    int fd;\n    int val;\n    char buf[64];\n\n    val = server.oom_score_adj_values[process_class];\n    if (server.oom_score_adj == OOM_SCORE_RELATIVE)\n        val += server.oom_score_adj_base;\n    if (val > 1000) val = 1000;\n    if (val < -1000) val = -1000;\n\n    snprintf(buf, sizeof(buf) - 1, \"%d\\n\", val);\n\n    fd = open(\"/proc/self/oom_score_adj\", O_WRONLY);\n    if (fd < 0 || write(fd, buf, strlen(buf)) < 0) {\n        serverLog(LOG_WARNING, \"Unable to write oom_score_adj: %s\", strerror(errno));\n        if (fd != -1) close(fd);\n        return C_ERR;\n    }\n\n    close(fd);\n    return C_OK;\n#else\n    /* Unsupported */\n    return C_ERR;\n#endif\n}\n\n/* This function will try to raise the max number of open files accordingly to\n * the configured max number of clients. It also reserves a number of file\n * descriptors (CONFIG_MIN_RESERVED_FDS) for extra operations of\n * persistence, listening sockets, log files and so forth.\n *\n * If it will not be possible to set the limit accordingly to the configured\n * max number of clients, the function will do the reverse setting\n * server.maxclients to the value that we can actually handle. */\nvoid adjustOpenFilesLimit(void) {\n    rlim_t maxfiles = server.maxclients+CONFIG_MIN_RESERVED_FDS;\n    struct rlimit limit;\n\n    if (getrlimit(RLIMIT_NOFILE,&limit) == -1) {\n        serverLog(LL_WARNING,\"Unable to obtain the current NOFILE limit (%s), assuming 1024 and setting the max clients configuration accordingly.\",\n            strerror(errno));\n        server.maxclients = 1024-CONFIG_MIN_RESERVED_FDS;\n    } else {\n        rlim_t oldlimit = limit.rlim_cur;\n\n        /* Set the max number of files if the current limit is not enough\n         * for our needs. */\n        if (oldlimit < maxfiles) {\n            rlim_t bestlimit;\n            int setrlimit_error = 0;\n\n            /* Try to set the file limit to match 'maxfiles' or at least\n             * to the higher value supported less than maxfiles. */\n            bestlimit = maxfiles;\n            while(bestlimit > oldlimit) {\n                rlim_t decr_step = 16;\n\n                limit.rlim_cur = bestlimit;\n                limit.rlim_max = bestlimit;\n                if (setrlimit(RLIMIT_NOFILE,&limit) != -1) break;\n                setrlimit_error = errno;\n\n                /* We failed to set file limit to 'bestlimit'. Try with a\n                 * smaller limit decrementing by a few FDs per iteration. */\n                if (bestlimit < decr_step) break;\n                bestlimit -= decr_step;\n            }\n\n            /* Assume that the limit we get initially is still valid if\n             * our last try was even lower. */\n            if (bestlimit < oldlimit) bestlimit = oldlimit;\n\n            if (bestlimit < maxfiles) {\n                unsigned int old_maxclients = server.maxclients;\n                server.maxclients = bestlimit-CONFIG_MIN_RESERVED_FDS;\n                /* maxclients is unsigned so may overflow: in order\n                 * to check if maxclients is now logically less than 1\n                 * we test indirectly via bestlimit. */\n                if (bestlimit <= CONFIG_MIN_RESERVED_FDS) {\n                    serverLog(LL_WARNING,\"Your current 'ulimit -n' \"\n                        \"of %llu is not enough for the server to start. \"\n                        \"Please increase your open file limit to at least \"\n                        \"%llu. Exiting.\",\n                        (unsigned long long) oldlimit,\n                        (unsigned long long) maxfiles);\n                    exit(1);\n                }\n                serverLog(LL_WARNING,\"You requested maxclients of %d \"\n                    \"requiring at least %llu max file descriptors.\",\n                    old_maxclients,\n                    (unsigned long long) maxfiles);\n                serverLog(LL_WARNING,\"Server can't set maximum open files \"\n                    \"to %llu because of OS error: %s.\",\n                    (unsigned long long) maxfiles, strerror(setrlimit_error));\n                serverLog(LL_WARNING,\"Current maximum open files is %llu. \"\n                    \"maxclients has been reduced to %d to compensate for \"\n                    \"low ulimit. \"\n                    \"If you need higher maxclients increase 'ulimit -n'.\",\n                    (unsigned long long) bestlimit, server.maxclients);\n            } else {\n                serverLog(LL_NOTICE,\"Increased maximum number of open files \"\n                    \"to %llu (it was originally set to %llu).\",\n                    (unsigned long long) maxfiles,\n                    (unsigned long long) oldlimit);\n            }\n        }\n    }\n}\n\n/* Check that server.tcp_backlog can be actually enforced in Linux according\n * to the value of /proc/sys/net/core/somaxconn, or warn about it. */\nvoid checkTcpBacklogSettings(void) {\n#ifdef HAVE_PROC_SOMAXCONN\n    FILE *fp = fopen(\"/proc/sys/net/core/somaxconn\",\"r\");\n    char buf[1024];\n    if (!fp) return;\n    if (fgets(buf,sizeof(buf),fp) != NULL) {\n        int somaxconn = atoi(buf);\n        if (somaxconn > 0 && somaxconn < server.tcp_backlog) {\n            serverLog(LL_WARNING,\"WARNING: The TCP backlog setting of %d cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of %d.\", server.tcp_backlog, somaxconn);\n        }\n    }\n    fclose(fp);\n#endif\n}\n\nvoid closeSocketListeners(socketFds *sfd) {\n    int j;\n\n    for (j = 0; j < sfd->count; j++) {\n        if (sfd->fd[j] == -1) continue;\n\n        aeDeleteFileEvent(server.el, sfd->fd[j], AE_READABLE);\n        close(sfd->fd[j]);\n    }\n\n    sfd->count = 0;\n}\n\n/* Create an event handler for accepting new connections in TCP or TLS domain sockets.\n * This works atomically for all socket fds */\nint createSocketAcceptHandler(socketFds *sfd, aeFileProc *accept_handler) {\n    int j;\n\n    for (j = 0; j < sfd->count; j++) {\n        if (aeCreateFileEvent(server.el, sfd->fd[j], AE_READABLE, accept_handler,NULL) == AE_ERR) {\n            /* Rollback */\n            for (j = j-1; j >= 0; j--) aeDeleteFileEvent(server.el, sfd->fd[j], AE_READABLE);\n            return C_ERR;\n        }\n    }\n    return C_OK;\n}\n\n/* Initialize a set of file descriptors to listen to the specified 'port'\n * binding the addresses specified in the Redis server configuration.\n *\n * The listening file descriptors are stored in the integer array 'fds'\n * and their number is set in '*count'.\n *\n * The addresses to bind are specified in the global server.bindaddr array\n * and their number is server.bindaddr_count. If the server configuration\n * contains no specific addresses to bind, this function will try to\n * bind * (all addresses) for both the IPv4 and IPv6 protocols.\n *\n * On success the function returns C_OK.\n *\n * On error the function returns C_ERR. For the function to be on\n * error, at least one of the server.bindaddr addresses was\n * impossible to bind, or no bind addresses were specified in the server\n * configuration but the function is not able to bind * for at least\n * one of the IPv4 or IPv6 protocols. */\nint listenToPort(int port, socketFds *sfd) {\n    int j;\n    char **bindaddr = server.bindaddr;\n    int bindaddr_count = server.bindaddr_count;\n    char *default_bindaddr[2] = {\"*\", \"-::*\"};\n\n    /* Force binding of 0.0.0.0 if no bind address is specified. */\n    if (server.bindaddr_count == 0) {\n        bindaddr_count = 2;\n        bindaddr = default_bindaddr;\n    }\n\n    for (j = 0; j < bindaddr_count; j++) {\n        char* addr = bindaddr[j];\n        int optional = *addr == '-';\n        if (optional) addr++;\n        if (strchr(addr,':')) {\n            /* Bind IPv6 address. */\n            sfd->fd[sfd->count] = anetTcp6Server(server.neterr,port,addr,server.tcp_backlog);\n        } else {\n            /* Bind IPv4 address. */\n            sfd->fd[sfd->count] = anetTcpServer(server.neterr,port,addr,server.tcp_backlog);\n        }\n        if (sfd->fd[sfd->count] == ANET_ERR) {\n            int net_errno = errno;\n            serverLog(LL_WARNING,\n                \"Warning: Could not create server TCP listening socket %s:%d: %s\",\n                addr, port, server.neterr);\n            if (net_errno == EADDRNOTAVAIL && optional)\n                continue;\n            if (net_errno == ENOPROTOOPT     || net_errno == EPROTONOSUPPORT ||\n                net_errno == ESOCKTNOSUPPORT || net_errno == EPFNOSUPPORT ||\n                net_errno == EAFNOSUPPORT)\n                continue;\n\n            /* Rollback successful listens before exiting */\n            closeSocketListeners(sfd);\n            return C_ERR;\n        }\n        anetNonBlock(NULL,sfd->fd[sfd->count]);\n        anetCloexec(sfd->fd[sfd->count]);\n        sfd->count++;\n    }\n    return C_OK;\n}\n\n/* Resets the stats that we expose via INFO or other means that we want\n * to reset via CONFIG RESETSTAT. The function is also used in order to\n * initialize these fields in initServer() at server startup. */\nvoid resetServerStats(void) {\n    int j;\n\n    server.stat_numcommands = 0;\n    server.stat_numconnections = 0;\n    server.stat_expiredkeys = 0;\n    server.stat_expired_stale_perc = 0;\n    server.stat_expired_time_cap_reached_count = 0;\n    server.stat_expire_cycle_time_used = 0;\n    server.stat_evictedkeys = 0;\n    server.stat_keyspace_misses = 0;\n    server.stat_keyspace_hits = 0;\n    server.stat_active_defrag_hits = 0;\n    server.stat_active_defrag_misses = 0;\n    server.stat_active_defrag_key_hits = 0;\n    server.stat_active_defrag_key_misses = 0;\n    server.stat_active_defrag_scanned = 0;\n    server.stat_fork_time = 0;\n    server.stat_fork_rate = 0;\n    server.stat_total_forks = 0;\n    server.stat_rejected_conn = 0;\n    server.stat_sync_full = 0;\n    server.stat_sync_partial_ok = 0;\n    server.stat_sync_partial_err = 0;\n    server.stat_io_reads_processed = 0;\n    atomicSet(server.stat_total_reads_processed, 0);\n    server.stat_io_writes_processed = 0;\n    atomicSet(server.stat_total_writes_processed, 0);\n    for (j = 0; j < STATS_METRIC_COUNT; j++) {\n        server.inst_metric[j].idx = 0;\n        server.inst_metric[j].last_sample_time = mstime();\n        server.inst_metric[j].last_sample_count = 0;\n        memset(server.inst_metric[j].samples,0,\n            sizeof(server.inst_metric[j].samples));\n    }\n    atomicSet(server.stat_net_input_bytes, 0);\n    atomicSet(server.stat_net_output_bytes, 0);\n    server.stat_unexpected_error_replies = 0;\n    server.stat_total_error_replies = 0;\n    server.stat_dump_payload_sanitizations = 0;\n    server.aof_delayed_fsync = 0;\n}\n\n/* Make the thread killable at any time, so that kill threads functions\n * can work reliably (default cancelability type is PTHREAD_CANCEL_DEFERRED).\n * Needed for pthread_cancel used by the fast memory test used by the crash report. */\nvoid makeThreadKillable(void) {\n    pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);\n    pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);\n}\n\nvoid initServer(void) {\n    int j;\n\n    signal(SIGHUP, SIG_IGN);\n    signal(SIGPIPE, SIG_IGN);\n    setupSignalHandlers();\n    makeThreadKillable();\n\n    if (server.syslog_enabled) {\n        openlog(server.syslog_ident, LOG_PID | LOG_NDELAY | LOG_NOWAIT,\n            server.syslog_facility);\n    }\n\n    /* Initialization after setting defaults from the config system. */\n    server.aof_state = server.aof_enabled ? AOF_ON : AOF_OFF;\n    server.hz = server.config_hz;\n    server.pid = getpid();\n    server.in_fork_child = CHILD_TYPE_NONE;\n    server.main_thread_id = pthread_self();\n    server.current_client = NULL;\n    server.errors = raxNew();\n    server.fixed_time_expire = 0;\n    server.clients = listCreate();\n    server.clients_index = raxNew();\n    server.clients_to_close = listCreate();\n    server.slaves = listCreate();\n    server.monitors = listCreate();\n    server.clients_pending_write = listCreate();\n    server.clients_pending_read = listCreate();\n    server.clients_timeout_table = raxNew();\n    server.replication_allowed = 1;\n    server.slaveseldb = -1; /* Force to emit the first SELECT command. */\n    server.unblocked_clients = listCreate();\n    server.ready_keys = listCreate();\n    server.clients_waiting_acks = listCreate();\n    server.get_ack_from_slaves = 0;\n    server.client_pause_type = 0;\n    server.paused_clients = listCreate();\n    server.events_processed_while_blocked = 0;\n    server.system_memory_size = zmalloc_get_memory_size();\n    server.blocked_last_cron = 0;\n    server.blocking_op_nesting = 0;\n\n    if ((server.tls_port || server.tls_replication || server.tls_cluster)\n                && tlsConfigure(&server.tls_ctx_config) == C_ERR) {\n        serverLog(LL_WARNING, \"Failed to configure TLS. Check logs for more info.\");\n        exit(1);\n    }\n\n    createSharedObjects();\n    adjustOpenFilesLimit();\n    const char *clk_msg = monotonicInit();\n    serverLog(LL_NOTICE, \"monotonic clock: %s\", clk_msg);\n    server.el = aeCreateEventLoop(server.maxclients+CONFIG_FDSET_INCR);\n    if (server.el == NULL) {\n        serverLog(LL_WARNING,\n            \"Failed creating the event loop. Error message: '%s'\",\n            strerror(errno));\n        exit(1);\n    }\n    server.db = zmalloc(sizeof(redisDb)*server.dbnum);\n\n    /* Open the TCP listening socket for the user commands. */\n    if (server.port != 0 &&\n        listenToPort(server.port,&server.ipfd) == C_ERR) {\n        serverLog(LL_WARNING, \"Failed listening on port %u (TCP), aborting.\", server.port);\n        exit(1);\n    }\n    if (server.tls_port != 0 &&\n        listenToPort(server.tls_port,&server.tlsfd) == C_ERR) {\n        serverLog(LL_WARNING, \"Failed listening on port %u (TLS), aborting.\", server.tls_port);\n        exit(1);\n    }\n\n    /* Open the listening Unix domain socket. */\n    if (server.unixsocket != NULL) {\n        unlink(server.unixsocket); /* don't care if this fails */\n        server.sofd = anetUnixServer(server.neterr,server.unixsocket,\n            server.unixsocketperm, server.tcp_backlog);\n        if (server.sofd == ANET_ERR) {\n            serverLog(LL_WARNING, \"Opening Unix socket: %s\", server.neterr);\n            exit(1);\n        }\n        anetNonBlock(NULL,server.sofd);\n        anetCloexec(server.sofd);\n    }\n\n    /* Abort if there are no listening sockets at all. */\n    if (server.ipfd.count == 0 && server.tlsfd.count == 0 && server.sofd < 0) {\n        serverLog(LL_WARNING, \"Configured to not listen anywhere, exiting.\");\n        exit(1);\n    }\n\n    /* Create the Redis databases, and initialize other internal state. */\n    for (j = 0; j < server.dbnum; j++) {\n        server.db[j].dict = dictCreate(&dbDictType,NULL);\n        server.db[j].expires = dictCreate(&dbExpiresDictType,NULL);\n        server.db[j].expires_cursor = 0;\n        server.db[j].blocking_keys = dictCreate(&keylistDictType,NULL);\n        server.db[j].ready_keys = dictCreate(&objectKeyPointerValueDictType,NULL);\n        server.db[j].watched_keys = dictCreate(&keylistDictType,NULL);\n        server.db[j].id = j;\n        server.db[j].avg_ttl = 0;\n        server.db[j].defrag_later = listCreate();\n        listSetFreeMethod(server.db[j].defrag_later,(void (*)(void*))sdsfree);\n    }\n    evictionPoolAlloc(); /* Initialize the LRU keys pool. */\n    server.pubsub_channels = dictCreate(&keylistDictType,NULL);\n    server.pubsub_patterns = dictCreate(&keylistDictType,NULL);\n    server.cronloops = 0;\n    server.in_eval = 0;\n    server.in_exec = 0;\n    server.propagate_in_transaction = 0;\n    server.client_pause_in_transaction = 0;\n    server.child_pid = -1;\n    server.child_type = CHILD_TYPE_NONE;\n    server.rdb_child_type = RDB_CHILD_TYPE_NONE;\n    server.rdb_pipe_conns = NULL;\n    server.rdb_pipe_numconns = 0;\n    server.rdb_pipe_numconns_writing = 0;\n    server.rdb_pipe_buff = NULL;\n    server.rdb_pipe_bufflen = 0;\n    server.rdb_bgsave_scheduled = 0;\n    server.child_info_pipe[0] = -1;\n    server.child_info_pipe[1] = -1;\n    server.child_info_nread = 0;\n    aofRewriteBufferReset();\n    server.aof_buf = sdsempty();\n    server.lastsave = time(NULL); /* At startup we consider the DB saved. */\n    server.lastbgsave_try = 0;    /* At startup we never tried to BGSAVE. */\n    server.rdb_save_time_last = -1;\n    server.rdb_save_time_start = -1;\n    server.dirty = 0;\n    resetServerStats();\n    /* A few stats we don't want to reset: server startup time, and peak mem. */\n    server.stat_starttime = time(NULL);\n    server.stat_peak_memory = 0;\n    server.stat_current_cow_bytes = 0;\n    server.stat_current_cow_updated = 0;\n    server.stat_current_save_keys_processed = 0;\n    server.stat_current_save_keys_total = 0;\n    server.stat_rdb_cow_bytes = 0;\n    server.stat_aof_cow_bytes = 0;\n    server.stat_module_cow_bytes = 0;\n    server.stat_module_progress = 0;\n    for (int j = 0; j < CLIENT_TYPE_COUNT; j++)\n        server.stat_clients_type_memory[j] = 0;\n    server.cron_malloc_stats.zmalloc_used = 0;\n    server.cron_malloc_stats.process_rss = 0;\n    server.cron_malloc_stats.allocator_allocated = 0;\n    server.cron_malloc_stats.allocator_active = 0;\n    server.cron_malloc_stats.allocator_resident = 0;\n    server.lastbgsave_status = C_OK;\n    server.aof_last_write_status = C_OK;\n    server.aof_last_write_errno = 0;\n    server.repl_good_slaves_count = 0;\n\n    /* Create the timer callback, this is our way to process many background\n     * operations incrementally, like clients timeout, eviction of unaccessed\n     * expired keys and so forth. */\n    if (aeCreateTimeEvent(server.el, 1, serverCron, NULL, NULL) == AE_ERR) {\n        serverPanic(\"Can't create event loop timers.\");\n        exit(1);\n    }\n\n    /* Create an event handler for accepting new connections in TCP and Unix\n     * domain sockets. */\n    if (createSocketAcceptHandler(&server.ipfd, acceptTcpHandler) != C_OK) {\n        serverPanic(\"Unrecoverable error creating TCP socket accept handler.\");\n    }\n    if (createSocketAcceptHandler(&server.tlsfd, acceptTLSHandler) != C_OK) {\n        serverPanic(\"Unrecoverable error creating TLS socket accept handler.\");\n    }\n    if (server.sofd > 0 && aeCreateFileEvent(server.el,server.sofd,AE_READABLE,\n        acceptUnixHandler,NULL) == AE_ERR) serverPanic(\"Unrecoverable error creating server.sofd file event.\");\n\n\n    /* Register a readable event for the pipe used to awake the event loop\n     * when a blocked client in a module needs attention. */\n    if (aeCreateFileEvent(server.el, server.module_blocked_pipe[0], AE_READABLE,\n        moduleBlockedClientPipeReadable,NULL) == AE_ERR) {\n            serverPanic(\n                \"Error registering the readable event for the module \"\n                \"blocked clients subsystem.\");\n    }\n\n    /* Register before and after sleep handlers (note this needs to be done\n     * before loading persistence since it is used by processEventsWhileBlocked. */\n    aeSetBeforeSleepProc(server.el,beforeSleep);\n    aeSetAfterSleepProc(server.el,afterSleep);\n\n    /* Open the AOF file if needed. */\n    if (server.aof_state == AOF_ON) {\n        server.aof_fd = open(server.aof_filename,\n                               O_WRONLY|O_APPEND|O_CREAT,0644);\n        if (server.aof_fd == -1) {\n            serverLog(LL_WARNING, \"Can't open the append-only file: %s\",\n                strerror(errno));\n            exit(1);\n        }\n    }\n\n    /* 32 bit instances are limited to 4GB of address space, so if there is\n     * no explicit limit in the user provided configuration we set a limit\n     * at 3 GB using maxmemory with 'noeviction' policy'. This avoids\n     * useless crashes of the Redis instance for out of memory. */\n    if (server.arch_bits == 32 && server.maxmemory == 0) {\n        serverLog(LL_WARNING,\"Warning: 32 bit instance detected but no memory limit set. Setting 3 GB maxmemory limit with 'noeviction' policy now.\");\n        server.maxmemory = 3072LL*(1024*1024); /* 3 GB */\n        server.maxmemory_policy = MAXMEMORY_NO_EVICTION;\n    }\n\n    if (server.cluster_enabled) clusterInit();\n    replicationScriptCacheInit();\n    scriptingInit(1);\n    slowlogInit();\n    latencyMonitorInit();\n    \n    /* Initialize ACL default password if it exists */\n    ACLUpdateDefaultUserPassword(server.requirepass);\n}\n\n/* Some steps in server initialization need to be done last (after modules\n * are loaded).\n * Specifically, creation of threads due to a race bug in ld.so, in which\n * Thread Local Storage initialization collides with dlopen call.\n * see: https://sourceware.org/bugzilla/show_bug.cgi?id=19329 */\nvoid InitServerLast() {\n    bioInit();\n    initThreadedIO();\n    set_jemalloc_bg_thread(server.jemalloc_bg_thread);\n    server.initial_memory_usage = zmalloc_used_memory();\n}\n\n/* Parse the flags string description 'strflags' and set them to the\n * command 'c'. If the flags are all valid C_OK is returned, otherwise\n * C_ERR is returned (yet the recognized flags are set in the command). */\nint populateCommandTableParseFlags(struct redisCommand *c, char *strflags) {\n    int argc;\n    sds *argv;\n\n    /* Split the line into arguments for processing. */\n    argv = sdssplitargs(strflags,&argc);\n    if (argv == NULL) return C_ERR;\n\n    for (int j = 0; j < argc; j++) {\n        char *flag = argv[j];\n        if (!strcasecmp(flag,\"write\")) {\n            c->flags |= CMD_WRITE|CMD_CATEGORY_WRITE;\n        } else if (!strcasecmp(flag,\"read-only\")) {\n            c->flags |= CMD_READONLY|CMD_CATEGORY_READ;\n        } else if (!strcasecmp(flag,\"use-memory\")) {\n            c->flags |= CMD_DENYOOM;\n        } else if (!strcasecmp(flag,\"admin\")) {\n            c->flags |= CMD_ADMIN|CMD_CATEGORY_ADMIN|CMD_CATEGORY_DANGEROUS;\n        } else if (!strcasecmp(flag,\"pub-sub\")) {\n            c->flags |= CMD_PUBSUB|CMD_CATEGORY_PUBSUB;\n        } else if (!strcasecmp(flag,\"no-script\")) {\n            c->flags |= CMD_NOSCRIPT;\n        } else if (!strcasecmp(flag,\"random\")) {\n            c->flags |= CMD_RANDOM;\n        } else if (!strcasecmp(flag,\"to-sort\")) {\n            c->flags |= CMD_SORT_FOR_SCRIPT;\n        } else if (!strcasecmp(flag,\"ok-loading\")) {\n            c->flags |= CMD_LOADING;\n        } else if (!strcasecmp(flag,\"ok-stale\")) {\n            c->flags |= CMD_STALE;\n        } else if (!strcasecmp(flag,\"no-monitor\")) {\n            c->flags |= CMD_SKIP_MONITOR;\n        } else if (!strcasecmp(flag,\"no-slowlog\")) {\n            c->flags |= CMD_SKIP_SLOWLOG;\n        } else if (!strcasecmp(flag,\"cluster-asking\")) {\n            c->flags |= CMD_ASKING;\n        } else if (!strcasecmp(flag,\"fast\")) {\n            c->flags |= CMD_FAST | CMD_CATEGORY_FAST;\n        } else if (!strcasecmp(flag,\"no-auth\")) {\n            c->flags |= CMD_NO_AUTH;\n        } else if (!strcasecmp(flag,\"may-replicate\")) {\n            c->flags |= CMD_MAY_REPLICATE;\n        } else {\n            /* Parse ACL categories here if the flag name starts with @. */\n            uint64_t catflag;\n            if (flag[0] == '@' &&\n                (catflag = ACLGetCommandCategoryFlagByName(flag+1)) != 0)\n            {\n                c->flags |= catflag;\n            } else {\n                sdsfreesplitres(argv,argc);\n                return C_ERR;\n            }\n        }\n    }\n    /* If it's not @fast is @slow in this binary world. */\n    if (!(c->flags & CMD_CATEGORY_FAST)) c->flags |= CMD_CATEGORY_SLOW;\n\n    sdsfreesplitres(argv,argc);\n    return C_OK;\n}\n\n/* Populates the Redis Command Table starting from the hard coded list\n * we have on top of server.c file. */\nvoid populateCommandTable(void) {\n    int j;\n    int numcommands = sizeof(redisCommandTable)/sizeof(struct redisCommand);\n\n    for (j = 0; j < numcommands; j++) {\n        struct redisCommand *c = redisCommandTable+j;\n        int retval1, retval2;\n\n        /* Translate the command string flags description into an actual\n         * set of flags. */\n        if (populateCommandTableParseFlags(c,c->sflags) == C_ERR)\n            serverPanic(\"Unsupported command flag\");\n\n        c->id = ACLGetCommandID(c->name); /* Assign the ID used for ACL. */\n        retval1 = dictAdd(server.commands, sdsnew(c->name), c);\n        /* Populate an additional dictionary that will be unaffected\n         * by rename-command statements in redis.conf. */\n        retval2 = dictAdd(server.orig_commands, sdsnew(c->name), c);\n        serverAssert(retval1 == DICT_OK && retval2 == DICT_OK);\n    }\n}\n\nvoid resetCommandTableStats(void) {\n    struct redisCommand *c;\n    dictEntry *de;\n    dictIterator *di;\n\n    di = dictGetSafeIterator(server.commands);\n    while((de = dictNext(di)) != NULL) {\n        c = (struct redisCommand *) dictGetVal(de);\n        c->microseconds = 0;\n        c->calls = 0;\n        c->rejected_calls = 0;\n        c->failed_calls = 0;\n    }\n    dictReleaseIterator(di);\n\n}\n\nvoid resetErrorTableStats(void) {\n    raxFreeWithCallback(server.errors, zfree);\n    server.errors = raxNew();\n}\n\n/* ========================== Redis OP Array API ============================ */\n\nvoid redisOpArrayInit(redisOpArray *oa) {\n    oa->ops = NULL;\n    oa->numops = 0;\n}\n\nint redisOpArrayAppend(redisOpArray *oa, struct redisCommand *cmd, int dbid,\n                       robj **argv, int argc, int target)\n{\n    redisOp *op;\n\n    oa->ops = zrealloc(oa->ops,sizeof(redisOp)*(oa->numops+1));\n    op = oa->ops+oa->numops;\n    op->cmd = cmd;\n    op->dbid = dbid;\n    op->argv = argv;\n    op->argc = argc;\n    op->target = target;\n    oa->numops++;\n    return oa->numops;\n}\n\nvoid redisOpArrayFree(redisOpArray *oa) {\n    while(oa->numops) {\n        int j;\n        redisOp *op;\n\n        oa->numops--;\n        op = oa->ops+oa->numops;\n        for (j = 0; j < op->argc; j++)\n            decrRefCount(op->argv[j]);\n        zfree(op->argv);\n    }\n    zfree(oa->ops);\n    oa->ops = NULL;\n}\n\n/* ====================== Commands lookup and execution ===================== */\n\nstruct redisCommand *lookupCommand(sds name) {\n    return dictFetchValue(server.commands, name);\n}\n\nstruct redisCommand *lookupCommandByCString(const char *s) {\n    struct redisCommand *cmd;\n    sds name = sdsnew(s);\n\n    cmd = dictFetchValue(server.commands, name);\n    sdsfree(name);\n    return cmd;\n}\n\n/* Lookup the command in the current table, if not found also check in\n * the original table containing the original command names unaffected by\n * redis.conf rename-command statement.\n *\n * This is used by functions rewriting the argument vector such as\n * rewriteClientCommandVector() in order to set client->cmd pointer\n * correctly even if the command was renamed. */\nstruct redisCommand *lookupCommandOrOriginal(sds name) {\n    struct redisCommand *cmd = dictFetchValue(server.commands, name);\n\n    if (!cmd) cmd = dictFetchValue(server.orig_commands,name);\n    return cmd;\n}\n\n/* Propagate the specified command (in the context of the specified database id)\n * to AOF and Slaves.\n *\n * flags are an xor between:\n * + PROPAGATE_NONE (no propagation of command at all)\n * + PROPAGATE_AOF (propagate into the AOF file if is enabled)\n * + PROPAGATE_REPL (propagate into the replication link)\n *\n * This should not be used inside commands implementation since it will not\n * wrap the resulting commands in MULTI/EXEC. Use instead alsoPropagate(),\n * preventCommandPropagation(), forceCommandPropagation().\n *\n * However for functions that need to (also) propagate out of the context of a\n * command execution, for example when serving a blocked client, you\n * want to use propagate().\n */\nvoid propagate(struct redisCommand *cmd, int dbid, robj **argv, int argc,\n               int flags)\n{\n    if (!server.replication_allowed)\n        return;\n\n    /* Propagate a MULTI request once we encounter the first command which\n     * is a write command.\n     * This way we'll deliver the MULTI/..../EXEC block as a whole and\n     * both the AOF and the replication link will have the same consistency\n     * and atomicity guarantees. */\n    if (server.in_exec && !server.propagate_in_transaction)\n        execCommandPropagateMulti(dbid);\n\n    /* This needs to be unreachable since the dataset should be fixed during \n     * client pause, otherwise data may be lossed during a failover. */\n    serverAssert(!(areClientsPaused() && !server.client_pause_in_transaction));\n\n    if (server.aof_state != AOF_OFF && flags & PROPAGATE_AOF)\n        feedAppendOnlyFile(cmd,dbid,argv,argc);\n    if (flags & PROPAGATE_REPL)\n        replicationFeedSlaves(server.slaves,dbid,argv,argc);\n}\n\n/* Used inside commands to schedule the propagation of additional commands\n * after the current command is propagated to AOF / Replication.\n *\n * 'cmd' must be a pointer to the Redis command to replicate, dbid is the\n * database ID the command should be propagated into.\n * Arguments of the command to propagate are passed as an array of redis\n * objects pointers of len 'argc', using the 'argv' vector.\n *\n * The function does not take a reference to the passed 'argv' vector,\n * so it is up to the caller to release the passed argv (but it is usually\n * stack allocated).  The function automatically increments ref count of\n * passed objects, so the caller does not need to. */\nvoid alsoPropagate(struct redisCommand *cmd, int dbid, robj **argv, int argc,\n                   int target)\n{\n    robj **argvcopy;\n    int j;\n\n    if (server.loading) return; /* No propagation during loading. */\n\n    argvcopy = zmalloc(sizeof(robj*)*argc);\n    for (j = 0; j < argc; j++) {\n        argvcopy[j] = argv[j];\n        incrRefCount(argv[j]);\n    }\n    redisOpArrayAppend(&server.also_propagate,cmd,dbid,argvcopy,argc,target);\n}\n\n/* It is possible to call the function forceCommandPropagation() inside a\n * Redis command implementation in order to to force the propagation of a\n * specific command execution into AOF / Replication. */\nvoid forceCommandPropagation(client *c, int flags) {\n    serverAssert(c->cmd->flags & (CMD_WRITE | CMD_MAY_REPLICATE));\n    if (flags & PROPAGATE_REPL) c->flags |= CLIENT_FORCE_REPL;\n    if (flags & PROPAGATE_AOF) c->flags |= CLIENT_FORCE_AOF;\n}\n\n/* Avoid that the executed command is propagated at all. This way we\n * are free to just propagate what we want using the alsoPropagate()\n * API. */\nvoid preventCommandPropagation(client *c) {\n    c->flags |= CLIENT_PREVENT_PROP;\n}\n\n/* Avoid logging any information about this client's arguments\n * since they contain sensitive information. */\nvoid preventCommandLogging(client *c) {\n    c->flags |= CLIENT_PREVENT_LOGGING;\n}\n\n/* AOF specific version of preventCommandPropagation(). */\nvoid preventCommandAOF(client *c) {\n    c->flags |= CLIENT_PREVENT_AOF_PROP;\n}\n\n/* Replication specific version of preventCommandPropagation(). */\nvoid preventCommandReplication(client *c) {\n    c->flags |= CLIENT_PREVENT_REPL_PROP;\n}\n\n/* Log the last command a client executed into the slowlog. */\nvoid slowlogPushCurrentCommand(client *c, struct redisCommand *cmd, ustime_t duration) {\n    /* Some commands may contain sensitive data that should not be available in the slowlog. */\n    if ((c->flags & CLIENT_PREVENT_LOGGING) || (cmd->flags & CMD_SKIP_SLOWLOG))\n        return;\n\n    /* If command argument vector was rewritten, use the original\n     * arguments. */\n    robj **argv = c->original_argv ? c->original_argv : c->argv;\n    int argc = c->original_argv ? c->original_argc : c->argc;\n    slowlogPushEntryIfNeeded(c,argv,argc,duration);\n}\n\n/* Call() is the core of Redis execution of a command.\n *\n * The following flags can be passed:\n * CMD_CALL_NONE        No flags.\n * CMD_CALL_SLOWLOG     Check command speed and log in the slow log if needed.\n * CMD_CALL_STATS       Populate command stats.\n * CMD_CALL_PROPAGATE_AOF   Append command to AOF if it modified the dataset\n *                          or if the client flags are forcing propagation.\n * CMD_CALL_PROPAGATE_REPL  Send command to slaves if it modified the dataset\n *                          or if the client flags are forcing propagation.\n * CMD_CALL_PROPAGATE   Alias for PROPAGATE_AOF|PROPAGATE_REPL.\n * CMD_CALL_FULL        Alias for SLOWLOG|STATS|PROPAGATE.\n *\n * The exact propagation behavior depends on the client flags.\n * Specifically:\n *\n * 1. If the client flags CLIENT_FORCE_AOF or CLIENT_FORCE_REPL are set\n *    and assuming the corresponding CMD_CALL_PROPAGATE_AOF/REPL is set\n *    in the call flags, then the command is propagated even if the\n *    dataset was not affected by the command.\n * 2. If the client flags CLIENT_PREVENT_REPL_PROP or CLIENT_PREVENT_AOF_PROP\n *    are set, the propagation into AOF or to slaves is not performed even\n *    if the command modified the dataset.\n *\n * Note that regardless of the client flags, if CMD_CALL_PROPAGATE_AOF\n * or CMD_CALL_PROPAGATE_REPL are not set, then respectively AOF or\n * slaves propagation will never occur.\n *\n * Client flags are modified by the implementation of a given command\n * using the following API:\n *\n * forceCommandPropagation(client *c, int flags);\n * preventCommandPropagation(client *c);\n * preventCommandAOF(client *c);\n * preventCommandReplication(client *c);\n *\n */\nvoid call(client *c, int flags) {\n    long long dirty;\n    monotime call_timer;\n    int client_old_flags = c->flags;\n    struct redisCommand *real_cmd = c->cmd;\n    static long long prev_err_count;\n\n    server.fixed_time_expire++;\n\n    /* Send the command to clients in MONITOR mode if applicable.\n     * Administrative commands are considered too dangerous to be shown. */\n    if (listLength(server.monitors) &&\n        !server.loading &&\n        !(c->cmd->flags & (CMD_SKIP_MONITOR|CMD_ADMIN)))\n    {\n        replicationFeedMonitors(c,server.monitors,c->db->id,c->argv,c->argc);\n    }\n\n    /* Initialization: clear the flags that must be set by the command on\n     * demand, and initialize the array for additional commands propagation. */\n    c->flags &= ~(CLIENT_FORCE_AOF|CLIENT_FORCE_REPL|CLIENT_PREVENT_PROP);\n    redisOpArray prev_also_propagate = server.also_propagate;\n    redisOpArrayInit(&server.also_propagate);\n\n    /* Call the command. */\n    dirty = server.dirty;\n    prev_err_count = server.stat_total_error_replies;\n    updateCachedTime(0);\n    elapsedStart(&call_timer);\n    c->cmd->proc(c);\n    const long duration = elapsedUs(call_timer);\n    c->duration = duration;\n    dirty = server.dirty-dirty;\n    if (dirty < 0) dirty = 0;\n\n    /* Update failed command calls if required.\n     * We leverage a static variable (prev_err_count) to retain\n     * the counter across nested function calls and avoid logging\n     * the same error twice. */\n    if ((server.stat_total_error_replies - prev_err_count) > 0) {\n        real_cmd->failed_calls++;\n    }\n\n    /* After executing command, we will close the client after writing entire\n     * reply if it is set 'CLIENT_CLOSE_AFTER_COMMAND' flag. */\n    if (c->flags & CLIENT_CLOSE_AFTER_COMMAND) {\n        c->flags &= ~CLIENT_CLOSE_AFTER_COMMAND;\n        c->flags |= CLIENT_CLOSE_AFTER_REPLY;\n    }\n\n    /* When EVAL is called loading the AOF we don't want commands called\n     * from Lua to go into the slowlog or to populate statistics. */\n    if (server.loading && c->flags & CLIENT_LUA)\n        flags &= ~(CMD_CALL_SLOWLOG | CMD_CALL_STATS);\n\n    /* If the caller is Lua, we want to force the EVAL caller to propagate\n     * the script if the command flag or client flag are forcing the\n     * propagation. */\n    if (c->flags & CLIENT_LUA && server.lua_caller) {\n        if (c->flags & CLIENT_FORCE_REPL)\n            server.lua_caller->flags |= CLIENT_FORCE_REPL;\n        if (c->flags & CLIENT_FORCE_AOF)\n            server.lua_caller->flags |= CLIENT_FORCE_AOF;\n    }\n\n    /* Note: the code below uses the real command that was executed\n     * c->cmd and c->lastcmd may be different, in case of MULTI-EXEC or\n     * re-written commands such as EXPIRE, GEOADD, etc. */\n\n    /* Record the latency this command induced on the main thread.\n     * unless instructed by the caller not to log. (happens when processing\n     * a MULTI-EXEC from inside an AOF). */\n    if (flags & CMD_CALL_SLOWLOG) {\n        char *latency_event = (real_cmd->flags & CMD_FAST) ?\n                               \"fast-command\" : \"command\";\n        latencyAddSampleIfNeeded(latency_event,duration/1000);\n    }\n\n    /* Log the command into the Slow log if needed.\n     * If the client is blocked we will handle slowlog when it is unblocked. */\n    if ((flags & CMD_CALL_SLOWLOG) && !(c->flags & CLIENT_BLOCKED))\n        slowlogPushCurrentCommand(c, real_cmd, duration);\n\n    /* Clear the original argv.\n     * If the client is blocked we will handle slowlog when it is unblocked. */\n    if (!(c->flags & CLIENT_BLOCKED))\n        freeClientOriginalArgv(c);\n\n    /* populate the per-command statistics that we show in INFO commandstats. */\n    if (flags & CMD_CALL_STATS) {\n        real_cmd->microseconds += duration;\n        real_cmd->calls++;\n    }\n\n    /* Propagate the command into the AOF and replication link */\n    if (flags & CMD_CALL_PROPAGATE &&\n        (c->flags & CLIENT_PREVENT_PROP) != CLIENT_PREVENT_PROP)\n    {\n        int propagate_flags = PROPAGATE_NONE;\n\n        /* Check if the command operated changes in the data set. If so\n         * set for replication / AOF propagation. */\n        if (dirty) propagate_flags |= (PROPAGATE_AOF|PROPAGATE_REPL);\n\n        /* If the client forced AOF / replication of the command, set\n         * the flags regardless of the command effects on the data set. */\n        if (c->flags & CLIENT_FORCE_REPL) propagate_flags |= PROPAGATE_REPL;\n        if (c->flags & CLIENT_FORCE_AOF) propagate_flags |= PROPAGATE_AOF;\n\n        /* However prevent AOF / replication propagation if the command\n         * implementation called preventCommandPropagation() or similar,\n         * or if we don't have the call() flags to do so. */\n        if (c->flags & CLIENT_PREVENT_REPL_PROP ||\n            !(flags & CMD_CALL_PROPAGATE_REPL))\n                propagate_flags &= ~PROPAGATE_REPL;\n        if (c->flags & CLIENT_PREVENT_AOF_PROP ||\n            !(flags & CMD_CALL_PROPAGATE_AOF))\n                propagate_flags &= ~PROPAGATE_AOF;\n\n        /* Call propagate() only if at least one of AOF / replication\n         * propagation is needed. Note that modules commands handle replication\n         * in an explicit way, so we never replicate them automatically. */\n        if (propagate_flags != PROPAGATE_NONE && !(c->cmd->flags & CMD_MODULE))\n            propagate(c->cmd,c->db->id,c->argv,c->argc,propagate_flags);\n    }\n\n    /* Restore the old replication flags, since call() can be executed\n     * recursively. */\n    c->flags &= ~(CLIENT_FORCE_AOF|CLIENT_FORCE_REPL|CLIENT_PREVENT_PROP);\n    c->flags |= client_old_flags &\n        (CLIENT_FORCE_AOF|CLIENT_FORCE_REPL|CLIENT_PREVENT_PROP);\n\n    /* Handle the alsoPropagate() API to handle commands that want to propagate\n     * multiple separated commands. Note that alsoPropagate() is not affected\n     * by CLIENT_PREVENT_PROP flag. */\n    if (server.also_propagate.numops) {\n        int j;\n        redisOp *rop;\n\n        if (flags & CMD_CALL_PROPAGATE) {\n            int multi_emitted = 0;\n            /* Wrap the commands in server.also_propagate array,\n             * but don't wrap it if we are already in MULTI context,\n             * in case the nested MULTI/EXEC.\n             *\n             * And if the array contains only one command, no need to\n             * wrap it, since the single command is atomic. */\n            if (server.also_propagate.numops > 1 &&\n                !(c->cmd->flags & CMD_MODULE) &&\n                !(c->flags & CLIENT_MULTI) &&\n                !(flags & CMD_CALL_NOWRAP))\n            {\n                execCommandPropagateMulti(c->db->id);\n                multi_emitted = 1;\n            }\n\n            for (j = 0; j < server.also_propagate.numops; j++) {\n                rop = &server.also_propagate.ops[j];\n                int target = rop->target;\n                /* Whatever the command wish is, we honor the call() flags. */\n                if (!(flags&CMD_CALL_PROPAGATE_AOF)) target &= ~PROPAGATE_AOF;\n                if (!(flags&CMD_CALL_PROPAGATE_REPL)) target &= ~PROPAGATE_REPL;\n                if (target)\n                    propagate(rop->cmd,rop->dbid,rop->argv,rop->argc,target);\n            }\n\n            if (multi_emitted) {\n                execCommandPropagateExec(c->db->id);\n            }\n        }\n        redisOpArrayFree(&server.also_propagate);\n    }\n    server.also_propagate = prev_also_propagate;\n\n    /* Client pause takes effect after a transaction has finished. This needs\n     * to be located after everything is propagated. */\n    if (!server.in_exec && server.client_pause_in_transaction) {\n        server.client_pause_in_transaction = 0;\n    }\n\n    /* If the client has keys tracking enabled for client side caching,\n     * make sure to remember the keys it fetched via this command. */\n    if (c->cmd->flags & CMD_READONLY) {\n        client *caller = (c->flags & CLIENT_LUA && server.lua_caller) ?\n                            server.lua_caller : c;\n        if (caller->flags & CLIENT_TRACKING &&\n            !(caller->flags & CLIENT_TRACKING_BCAST))\n        {\n            trackingRememberKeys(caller);\n        }\n    }\n\n    server.fixed_time_expire--;\n    server.stat_numcommands++;\n    prev_err_count = server.stat_total_error_replies;\n\n    /* Record peak memory after each command and before the eviction that runs\n     * before the next command. */\n    size_t zmalloc_used = zmalloc_used_memory();\n    if (zmalloc_used > server.stat_peak_memory)\n        server.stat_peak_memory = zmalloc_used;\n}\n\n/* Used when a command that is ready for execution needs to be rejected, due to\n * varios pre-execution checks. it returns the appropriate error to the client.\n * If there's a transaction is flags it as dirty, and if the command is EXEC,\n * it aborts the transaction.\n * Note: 'reply' is expected to end with \\r\\n */\nvoid rejectCommand(client *c, robj *reply) {\n    flagTransaction(c);\n    if (c->cmd) c->cmd->rejected_calls++;\n    if (c->cmd && c->cmd->proc == execCommand) {\n        execCommandAbort(c, reply->ptr);\n    } else {\n        /* using addReplyError* rather than addReply so that the error can be logged. */\n        addReplyErrorObject(c, reply);\n    }\n}\n\nvoid rejectCommandFormat(client *c, const char *fmt, ...) {\n    if (c->cmd) c->cmd->rejected_calls++;\n    flagTransaction(c);\n    va_list ap;\n    va_start(ap,fmt);\n    sds s = sdscatvprintf(sdsempty(),fmt,ap);\n    va_end(ap);\n    /* Make sure there are no newlines in the string, otherwise invalid protocol\n     * is emitted (The args come from the user, they may contain any character). */\n    sdsmapchars(s, \"\\r\\n\", \"  \",  2);\n    if (c->cmd && c->cmd->proc == execCommand) {\n        execCommandAbort(c, s);\n        sdsfree(s);\n    } else {\n        /* The following frees 's'. */\n        addReplyErrorSds(c, s);\n    }\n}\n\n/* Returns 1 for commands that may have key names in their arguments, but have\n * no pre-determined key positions. */\nstatic int cmdHasMovableKeys(struct redisCommand *cmd) {\n    return (cmd->getkeys_proc && !(cmd->flags & CMD_MODULE)) ||\n            cmd->flags & CMD_MODULE_GETKEYS;\n}\n\n/* If this function gets called we already read a whole\n * command, arguments are in the client argv/argc fields.\n * processCommand() execute the command or prepare the\n * server for a bulk read from the client.\n *\n * If C_OK is returned the client is still alive and valid and\n * other operations can be performed by the caller. Otherwise\n * if C_ERR is returned the client was destroyed (i.e. after QUIT). */\nint processCommand(client *c) {\n    if (!server.lua_timedout) {\n        /* Both EXEC and EVAL call call() directly so there should be\n         * no way in_exec or in_eval or propagate_in_transaction is 1.\n         * That is unless lua_timedout, in which case client may run\n         * some commands. */\n        serverAssert(!server.propagate_in_transaction);\n        serverAssert(!server.in_exec);\n        serverAssert(!server.in_eval);\n    }\n\n    moduleCallCommandFilters(c);\n\n    /* The QUIT command is handled separately. Normal command procs will\n     * go through checking for replication and QUIT will cause trouble\n     * when FORCE_REPLICATION is enabled and would be implemented in\n     * a regular command proc. */\n    if (!strcasecmp(c->argv[0]->ptr,\"quit\")) {\n        addReply(c,shared.ok);\n        c->flags |= CLIENT_CLOSE_AFTER_REPLY;\n        return C_ERR;\n    }\n\n    /* Now lookup the command and check ASAP about trivial error conditions\n     * such as wrong arity, bad command name and so forth. */\n    c->cmd = c->lastcmd = lookupCommand(c->argv[0]->ptr);\n    if (!c->cmd) {\n        sds args = sdsempty();\n        int i;\n        for (i=1; i < c->argc && sdslen(args) < 128; i++)\n            args = sdscatprintf(args, \"`%.*s`, \", 128-(int)sdslen(args), (char*)c->argv[i]->ptr);\n        rejectCommandFormat(c,\"unknown command `%s`, with args beginning with: %s\",\n            (char*)c->argv[0]->ptr, args);\n        sdsfree(args);\n        return C_OK;\n    } else if ((c->cmd->arity > 0 && c->cmd->arity != c->argc) ||\n               (c->argc < -c->cmd->arity)) {\n        rejectCommandFormat(c,\"wrong number of arguments for '%s' command\",\n            c->cmd->name);\n        return C_OK;\n    }\n\n    int is_write_command = (c->cmd->flags & CMD_WRITE) ||\n                           (c->cmd->proc == execCommand && (c->mstate.cmd_flags & CMD_WRITE));\n    int is_denyoom_command = (c->cmd->flags & CMD_DENYOOM) ||\n                             (c->cmd->proc == execCommand && (c->mstate.cmd_flags & CMD_DENYOOM));\n    int is_denystale_command = !(c->cmd->flags & CMD_STALE) ||\n                               (c->cmd->proc == execCommand && (c->mstate.cmd_inv_flags & CMD_STALE));\n    int is_denyloading_command = !(c->cmd->flags & CMD_LOADING) ||\n                                 (c->cmd->proc == execCommand && (c->mstate.cmd_inv_flags & CMD_LOADING));\n    int is_may_replicate_command = (c->cmd->flags & (CMD_WRITE | CMD_MAY_REPLICATE)) ||\n                                   (c->cmd->proc == execCommand && (c->mstate.cmd_flags & (CMD_WRITE | CMD_MAY_REPLICATE)));\n\n    /* Check if the user is authenticated. This check is skipped in case\n     * the default user is flagged as \"nopass\" and is active. */\n    int auth_required = (!(DefaultUser->flags & USER_FLAG_NOPASS) ||\n                          (DefaultUser->flags & USER_FLAG_DISABLED)) &&\n                        !c->authenticated;\n    if (auth_required) {\n        /* AUTH and HELLO and no auth modules are valid even in\n         * non-authenticated state. */\n        if (!(c->cmd->flags & CMD_NO_AUTH)) {\n            rejectCommand(c,shared.noautherr);\n            return C_OK;\n        }\n    }\n\n    /* Check if the user can run this command according to the current\n     * ACLs. */\n    int acl_errpos;\n    int acl_retval = ACLCheckAllPerm(c,&acl_errpos);\n    if (acl_retval != ACL_OK) {\n        addACLLogEntry(c,acl_retval,acl_errpos,NULL);\n        switch (acl_retval) {\n        case ACL_DENIED_CMD:\n            rejectCommandFormat(c,\n                \"-NOPERM this user has no permissions to run \"\n                \"the '%s' command or its subcommand\", c->cmd->name);\n            break;\n        case ACL_DENIED_KEY:\n            rejectCommandFormat(c,\n                \"-NOPERM this user has no permissions to access \"\n                \"one of the keys used as arguments\");\n            break;\n        case ACL_DENIED_CHANNEL:\n            rejectCommandFormat(c,\n                \"-NOPERM this user has no permissions to access \"\n                \"one of the channels used as arguments\");\n            break;\n        default:\n            rejectCommandFormat(c, \"no permission\");\n            break;\n        }\n        return C_OK;\n    }\n\n    /* If cluster is enabled perform the cluster redirection here.\n     * However we don't perform the redirection if:\n     * 1) The sender of this command is our master.\n     * 2) The command has no key arguments. */\n    if (server.cluster_enabled &&\n        !(c->flags & CLIENT_MASTER) &&\n        !(c->flags & CLIENT_LUA &&\n          server.lua_caller->flags & CLIENT_MASTER) &&\n        !(!cmdHasMovableKeys(c->cmd) && c->cmd->firstkey == 0 &&\n          c->cmd->proc != execCommand))\n    {\n        int hashslot;\n        int error_code;\n        clusterNode *n = getNodeByQuery(c,c->cmd,c->argv,c->argc,\n                                        &hashslot,&error_code);\n        if (n == NULL || n != server.cluster->myself) {\n            if (c->cmd->proc == execCommand) {\n                discardTransaction(c);\n            } else {\n                flagTransaction(c);\n            }\n            clusterRedirectClient(c,n,hashslot,error_code);\n            c->cmd->rejected_calls++;\n            return C_OK;\n        }\n    }\n\n    /* Handle the maxmemory directive.\n     *\n     * Note that we do not want to reclaim memory if we are here re-entering\n     * the event loop since there is a busy Lua script running in timeout\n     * condition, to avoid mixing the propagation of scripts with the\n     * propagation of DELs due to eviction. */\n    if (server.maxmemory && !server.lua_timedout) {\n        int out_of_memory = (performEvictions() == EVICT_FAIL);\n        /* performEvictions may flush slave output buffers. This may result\n         * in a slave, that may be the active client, to be freed. */\n        if (server.current_client == NULL) return C_ERR;\n\n        int reject_cmd_on_oom = is_denyoom_command;\n        /* If client is in MULTI/EXEC context, queuing may consume an unlimited\n         * amount of memory, so we want to stop that.\n         * However, we never want to reject DISCARD, or even EXEC (unless it\n         * contains denied commands, in which case is_denyoom_command is already\n         * set. */\n        if (c->flags & CLIENT_MULTI &&\n            c->cmd->proc != execCommand &&\n            c->cmd->proc != discardCommand &&\n            c->cmd->proc != resetCommand) {\n            reject_cmd_on_oom = 1;\n        }\n\n        if (out_of_memory && reject_cmd_on_oom) {\n            rejectCommand(c, shared.oomerr);\n            return C_OK;\n        }\n\n        /* Save out_of_memory result at script start, otherwise if we check OOM\n         * until first write within script, memory used by lua stack and\n         * arguments might interfere. */\n        if (c->cmd->proc == evalCommand || c->cmd->proc == evalShaCommand) {\n            server.lua_oom = out_of_memory;\n        }\n    }\n\n    /* Make sure to use a reasonable amount of memory for client side\n     * caching metadata. */\n    if (server.tracking_clients) trackingLimitUsedSlots();\n\n    /* Don't accept write commands if there are problems persisting on disk\n     * and if this is a master instance. */\n    int deny_write_type = writeCommandsDeniedByDiskError();\n    if (deny_write_type != DISK_ERROR_TYPE_NONE &&\n        server.masterhost == NULL &&\n        (is_write_command ||c->cmd->proc == pingCommand))\n    {\n        if (deny_write_type == DISK_ERROR_TYPE_RDB)\n            rejectCommand(c, shared.bgsaveerr);\n        else\n            rejectCommandFormat(c,\n                \"-MISCONF Errors writing to the AOF file: %s\",\n                strerror(server.aof_last_write_errno));\n        return C_OK;\n    }\n\n    /* Don't accept write commands if there are not enough good slaves and\n     * user configured the min-slaves-to-write option. */\n    if (server.masterhost == NULL &&\n        server.repl_min_slaves_to_write &&\n        server.repl_min_slaves_max_lag &&\n        is_write_command &&\n        server.repl_good_slaves_count < server.repl_min_slaves_to_write)\n    {\n        rejectCommand(c, shared.noreplicaserr);\n        return C_OK;\n    }\n\n    /* Don't accept write commands if this is a read only slave. But\n     * accept write commands if this is our master. */\n    if (server.masterhost && server.repl_slave_ro &&\n        !(c->flags & CLIENT_MASTER) &&\n        is_write_command)\n    {\n        rejectCommand(c, shared.roslaveerr);\n        return C_OK;\n    }\n\n    /* Only allow a subset of commands in the context of Pub/Sub if the\n     * connection is in RESP2 mode. With RESP3 there are no limits. */\n    if ((c->flags & CLIENT_PUBSUB && c->resp == 2) &&\n        c->cmd->proc != pingCommand &&\n        c->cmd->proc != subscribeCommand &&\n        c->cmd->proc != unsubscribeCommand &&\n        c->cmd->proc != psubscribeCommand &&\n        c->cmd->proc != punsubscribeCommand &&\n        c->cmd->proc != resetCommand) {\n        rejectCommandFormat(c,\n            \"Can't execute '%s': only (P)SUBSCRIBE / \"\n            \"(P)UNSUBSCRIBE / PING / QUIT / RESET are allowed in this context\",\n            c->cmd->name);\n        return C_OK;\n    }\n\n    /* Only allow commands with flag \"t\", such as INFO, SLAVEOF and so on,\n     * when slave-serve-stale-data is no and we are a slave with a broken\n     * link with master. */\n    if (server.masterhost && server.repl_state != REPL_STATE_CONNECTED &&\n        server.repl_serve_stale_data == 0 &&\n        is_denystale_command)\n    {\n        rejectCommand(c, shared.masterdownerr);\n        return C_OK;\n    }\n\n    /* Loading DB? Return an error if the command has not the\n     * CMD_LOADING flag. */\n    if (server.loading && is_denyloading_command) {\n        rejectCommand(c, shared.loadingerr);\n        return C_OK;\n    }\n\n    /* Lua script too slow? Only allow a limited number of commands.\n     * Note that we need to allow the transactions commands, otherwise clients\n     * sending a transaction with pipelining without error checking, may have\n     * the MULTI plus a few initial commands refused, then the timeout\n     * condition resolves, and the bottom-half of the transaction gets\n     * executed, see Github PR #7022. */\n    if (server.lua_timedout &&\n          c->cmd->proc != authCommand &&\n          c->cmd->proc != helloCommand &&\n          c->cmd->proc != replconfCommand &&\n          c->cmd->proc != multiCommand &&\n          c->cmd->proc != discardCommand &&\n          c->cmd->proc != watchCommand &&\n          c->cmd->proc != unwatchCommand &&\n\t  c->cmd->proc != resetCommand &&\n        !(c->cmd->proc == shutdownCommand &&\n          c->argc == 2 &&\n          tolower(((char*)c->argv[1]->ptr)[0]) == 'n') &&\n        !(c->cmd->proc == scriptCommand &&\n          c->argc == 2 &&\n          tolower(((char*)c->argv[1]->ptr)[0]) == 'k'))\n    {\n        rejectCommand(c, shared.slowscripterr);\n        return C_OK;\n    }\n\n    /* If the server is paused, block the client until\n     * the pause has ended. Replicas are never paused. */\n    if (!(c->flags & CLIENT_SLAVE) && \n        ((server.client_pause_type == CLIENT_PAUSE_ALL) ||\n        (server.client_pause_type == CLIENT_PAUSE_WRITE && is_may_replicate_command)))\n    {\n        c->bpop.timeout = 0;\n        blockClient(c,BLOCKED_PAUSE);\n        return C_OK;       \n    }\n\n    /* Exec the command */\n    if (c->flags & CLIENT_MULTI &&\n        c->cmd->proc != execCommand && c->cmd->proc != discardCommand &&\n        c->cmd->proc != multiCommand && c->cmd->proc != watchCommand &&\n        c->cmd->proc != resetCommand)\n    {\n        queueMultiCommand(c);\n        addReply(c,shared.queued);\n    } else {\n        call(c,CMD_CALL_FULL);\n        c->woff = server.master_repl_offset;\n        if (listLength(server.ready_keys))\n            handleClientsBlockedOnKeys();\n    }\n\n    return C_OK;\n}\n\n/* ====================== Error lookup and execution ===================== */\n\nvoid incrementErrorCount(const char *fullerr, size_t namelen) {\n    struct redisError *error = raxFind(server.errors,(unsigned char*)fullerr,namelen);\n    if (error == raxNotFound) {\n        error = zmalloc(sizeof(*error));\n        error->count = 0;\n        raxInsert(server.errors,(unsigned char*)fullerr,namelen,error,NULL);\n    }\n    error->count++;\n}\n\n/*================================== Shutdown =============================== */\n\n/* Close listening sockets. Also unlink the unix domain socket if\n * unlink_unix_socket is non-zero. */\nvoid closeListeningSockets(int unlink_unix_socket) {\n    int j;\n\n    for (j = 0; j < server.ipfd.count; j++) close(server.ipfd.fd[j]);\n    for (j = 0; j < server.tlsfd.count; j++) close(server.tlsfd.fd[j]);\n    if (server.sofd != -1) close(server.sofd);\n    if (server.cluster_enabled)\n        for (j = 0; j < server.cfd.count; j++) close(server.cfd.fd[j]);\n    if (unlink_unix_socket && server.unixsocket) {\n        serverLog(LL_NOTICE,\"Removing the unix socket file.\");\n        unlink(server.unixsocket); /* don't care if this fails */\n    }\n}\n\nint prepareForShutdown(int flags) {\n    /* When SHUTDOWN is called while the server is loading a dataset in\n     * memory we need to make sure no attempt is performed to save\n     * the dataset on shutdown (otherwise it could overwrite the current DB\n     * with half-read data).\n     *\n     * Also when in Sentinel mode clear the SAVE flag and force NOSAVE. */\n    if (server.loading || server.sentinel_mode)\n        flags = (flags & ~SHUTDOWN_SAVE) | SHUTDOWN_NOSAVE;\n\n    int save = flags & SHUTDOWN_SAVE;\n    int nosave = flags & SHUTDOWN_NOSAVE;\n\n    serverLog(LL_WARNING,\"User requested shutdown...\");\n    if (server.supervised_mode == SUPERVISED_SYSTEMD)\n        redisCommunicateSystemd(\"STOPPING=1\\n\");\n\n    /* Kill all the Lua debugger forked sessions. */\n    ldbKillForkedSessions();\n\n    /* Kill the saving child if there is a background saving in progress.\n       We want to avoid race conditions, for instance our saving child may\n       overwrite the synchronous saving did by SHUTDOWN. */\n    if (server.child_type == CHILD_TYPE_RDB) {\n        serverLog(LL_WARNING,\"There is a child saving an .rdb. Killing it!\");\n        killRDBChild();\n        /* Note that, in killRDBChild normally has backgroundSaveDoneHandler\n         * doing it's cleanup, but in this case this code will not be reached,\n         * so we need to call rdbRemoveTempFile which will close fd(in order\n         * to unlink file actully) in background thread.\n         * The temp rdb file fd may won't be closed when redis exits quickly,\n         * but OS will close this fd when process exits. */\n        rdbRemoveTempFile(server.child_pid, 0);\n    }\n\n    /* Kill module child if there is one. */\n    if (server.child_type == CHILD_TYPE_MODULE) {\n        serverLog(LL_WARNING,\"There is a module fork child. Killing it!\");\n        TerminateModuleForkChild(server.child_pid,0);\n    }\n\n    if (server.aof_state != AOF_OFF) {\n        /* Kill the AOF saving child as the AOF we already have may be longer\n         * but contains the full dataset anyway. */\n        if (server.child_type == CHILD_TYPE_AOF) {\n            /* If we have AOF enabled but haven't written the AOF yet, don't\n             * shutdown or else the dataset will be lost. */\n            if (server.aof_state == AOF_WAIT_REWRITE) {\n                serverLog(LL_WARNING, \"Writing initial AOF, can't exit.\");\n                return C_ERR;\n            }\n            serverLog(LL_WARNING,\n                \"There is a child rewriting the AOF. Killing it!\");\n            killAppendOnlyChild();\n        }\n        /* Append only file: flush buffers and fsync() the AOF at exit */\n        serverLog(LL_NOTICE,\"Calling fsync() on the AOF file.\");\n        flushAppendOnlyFile(1);\n        if (redis_fsync(server.aof_fd) == -1) {\n            serverLog(LL_WARNING,\"Fail to fsync the AOF file: %s.\",\n                                 strerror(errno));\n        }\n    }\n\n    /* Create a new RDB file before exiting. */\n    if ((server.saveparamslen > 0 && !nosave) || save) {\n        serverLog(LL_NOTICE,\"Saving the final RDB snapshot before exiting.\");\n        if (server.supervised_mode == SUPERVISED_SYSTEMD)\n            redisCommunicateSystemd(\"STATUS=Saving the final RDB snapshot\\n\");\n        /* Snapshotting. Perform a SYNC SAVE and exit */\n        rdbSaveInfo rsi, *rsiptr;\n        rsiptr = rdbPopulateSaveInfo(&rsi);\n        if (rdbSave(server.rdb_filename,rsiptr) != C_OK) {\n            /* Ooops.. error saving! The best we can do is to continue\n             * operating. Note that if there was a background saving process,\n             * in the next cron() Redis will be notified that the background\n             * saving aborted, handling special stuff like slaves pending for\n             * synchronization... */\n            serverLog(LL_WARNING,\"Error trying to save the DB, can't exit.\");\n            if (server.supervised_mode == SUPERVISED_SYSTEMD)\n                redisCommunicateSystemd(\"STATUS=Error trying to save the DB, can't exit.\\n\");\n            return C_ERR;\n        }\n    }\n\n    /* Fire the shutdown modules event. */\n    moduleFireServerEvent(REDISMODULE_EVENT_SHUTDOWN,0,NULL);\n\n    /* Remove the pid file if possible and needed. */\n    if (server.daemonize || server.pidfile) {\n        serverLog(LL_NOTICE,\"Removing the pid file.\");\n        unlink(server.pidfile);\n    }\n\n    /* Best effort flush of slave output buffers, so that we hopefully\n     * send them pending writes. */\n    flushSlavesOutputBuffers();\n\n    /* Close the listening sockets. Apparently this allows faster restarts. */\n    closeListeningSockets(1);\n    serverLog(LL_WARNING,\"%s is now ready to exit, bye bye...\",\n        server.sentinel_mode ? \"Sentinel\" : \"Redis\");\n    return C_OK;\n}\n\n/*================================== Commands =============================== */\n\n/* Sometimes Redis cannot accept write commands because there is a persistence\n * error with the RDB or AOF file, and Redis is configured in order to stop\n * accepting writes in such situation. This function returns if such a\n * condition is active, and the type of the condition.\n *\n * Function return values:\n *\n * DISK_ERROR_TYPE_NONE:    No problems, we can accept writes.\n * DISK_ERROR_TYPE_AOF:     Don't accept writes: AOF errors.\n * DISK_ERROR_TYPE_RDB:     Don't accept writes: RDB errors.\n */\nint writeCommandsDeniedByDiskError(void) {\n    if (server.stop_writes_on_bgsave_err &&\n        server.saveparamslen > 0 &&\n        server.lastbgsave_status == C_ERR)\n    {\n        return DISK_ERROR_TYPE_RDB;\n    } else if (server.aof_state != AOF_OFF) {\n        if (server.aof_last_write_status == C_ERR) {\n            return DISK_ERROR_TYPE_AOF;\n        }\n        /* AOF fsync error. */\n        int aof_bio_fsync_status;\n        atomicGet(server.aof_bio_fsync_status,aof_bio_fsync_status);\n        if (aof_bio_fsync_status == C_ERR) {\n            atomicGet(server.aof_bio_fsync_errno,server.aof_last_write_errno);\n            return DISK_ERROR_TYPE_AOF;\n        }\n    }\n\n    return DISK_ERROR_TYPE_NONE;\n}\n\n/* The PING command. It works in a different way if the client is in\n * in Pub/Sub mode. */\nvoid pingCommand(client *c) {\n    /* The command takes zero or one arguments. */\n    if (c->argc > 2) {\n        addReplyErrorFormat(c,\"wrong number of arguments for '%s' command\",\n            c->cmd->name);\n        return;\n    }\n\n    if (c->flags & CLIENT_PUBSUB && c->resp == 2) {\n        addReply(c,shared.mbulkhdr[2]);\n        addReplyBulkCBuffer(c,\"pong\",4);\n        if (c->argc == 1)\n            addReplyBulkCBuffer(c,\"\",0);\n        else\n            addReplyBulk(c,c->argv[1]);\n    } else {\n        if (c->argc == 1)\n            addReply(c,shared.pong);\n        else\n            addReplyBulk(c,c->argv[1]);\n    }\n}\n\nvoid echoCommand(client *c) {\n    addReplyBulk(c,c->argv[1]);\n}\n\nvoid timeCommand(client *c) {\n    struct timeval tv;\n\n    /* gettimeofday() can only fail if &tv is a bad address so we\n     * don't check for errors. */\n    gettimeofday(&tv,NULL);\n    addReplyArrayLen(c,2);\n    addReplyBulkLongLong(c,tv.tv_sec);\n    addReplyBulkLongLong(c,tv.tv_usec);\n}\n\n/* Helper function for addReplyCommand() to output flags. */\nint addReplyCommandFlag(client *c, struct redisCommand *cmd, int f, char *reply) {\n    if (cmd->flags & f) {\n        addReplyStatus(c, reply);\n        return 1;\n    }\n    return 0;\n}\n\n/* Output the representation of a Redis command. Used by the COMMAND command. */\nvoid addReplyCommand(client *c, struct redisCommand *cmd) {\n    if (!cmd) {\n        addReplyNull(c);\n    } else {\n        /* We are adding: command name, arg count, flags, first, last, offset, categories */\n        addReplyArrayLen(c, 7);\n        addReplyBulkCString(c, cmd->name);\n        addReplyLongLong(c, cmd->arity);\n\n        int flagcount = 0;\n        void *flaglen = addReplyDeferredLen(c);\n        flagcount += addReplyCommandFlag(c,cmd,CMD_WRITE, \"write\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_READONLY, \"readonly\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_DENYOOM, \"denyoom\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_ADMIN, \"admin\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_PUBSUB, \"pubsub\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_NOSCRIPT, \"noscript\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_RANDOM, \"random\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_SORT_FOR_SCRIPT,\"sort_for_script\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_LOADING, \"loading\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_STALE, \"stale\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_SKIP_MONITOR, \"skip_monitor\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_SKIP_SLOWLOG, \"skip_slowlog\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_ASKING, \"asking\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_FAST, \"fast\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_NO_AUTH, \"no_auth\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_MAY_REPLICATE, \"may_replicate\");\n        if (cmdHasMovableKeys(cmd)) {\n            addReplyStatus(c, \"movablekeys\");\n            flagcount += 1;\n        }\n        setDeferredSetLen(c, flaglen, flagcount);\n\n        addReplyLongLong(c, cmd->firstkey);\n        addReplyLongLong(c, cmd->lastkey);\n        addReplyLongLong(c, cmd->keystep);\n\n        addReplyCommandCategories(c,cmd);\n    }\n}\n\n/* COMMAND <subcommand> <args> */\nvoid commandCommand(client *c) {\n    dictIterator *di;\n    dictEntry *de;\n\n    if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,\"help\")) {\n        const char *help[] = {\n\"(no subcommand)\",\n\"    Return details about all Redis commands.\",\n\"COUNT\",\n\"    Return the total number of commands in this Redis server.\",\n\"GETKEYS <full-command>\",\n\"    Return the keys from a full Redis command.\",\n\"INFO [<command-name> ...]\",\n\"    Return details about multiple Redis commands.\",\nNULL\n        };\n        addReplyHelp(c, help);\n    } else if (c->argc == 1) {\n        addReplyArrayLen(c, dictSize(server.commands));\n        di = dictGetIterator(server.commands);\n        while ((de = dictNext(di)) != NULL) {\n            addReplyCommand(c, dictGetVal(de));\n        }\n        dictReleaseIterator(di);\n    } else if (!strcasecmp(c->argv[1]->ptr, \"info\")) {\n        int i;\n        addReplyArrayLen(c, c->argc-2);\n        for (i = 2; i < c->argc; i++) {\n            addReplyCommand(c, dictFetchValue(server.commands, c->argv[i]->ptr));\n        }\n    } else if (!strcasecmp(c->argv[1]->ptr, \"count\") && c->argc == 2) {\n        addReplyLongLong(c, dictSize(server.commands));\n    } else if (!strcasecmp(c->argv[1]->ptr,\"getkeys\") && c->argc >= 3) {\n        struct redisCommand *cmd = lookupCommand(c->argv[2]->ptr);\n        getKeysResult result = GETKEYS_RESULT_INIT;\n        int j;\n\n        if (!cmd) {\n            addReplyError(c,\"Invalid command specified\");\n            return;\n        } else if (cmd->getkeys_proc == NULL && cmd->firstkey == 0) {\n            addReplyError(c,\"The command has no key arguments\");\n            return;\n        } else if ((cmd->arity > 0 && cmd->arity != c->argc-2) ||\n                   ((c->argc-2) < -cmd->arity))\n        {\n            addReplyError(c,\"Invalid number of arguments specified for command\");\n            return;\n        }\n\n        if (!getKeysFromCommand(cmd,c->argv+2,c->argc-2,&result)) {\n            addReplyError(c,\"Invalid arguments specified for command\");\n        } else {\n            addReplyArrayLen(c,result.numkeys);\n            for (j = 0; j < result.numkeys; j++) addReplyBulk(c,c->argv[result.keys[j]+2]);\n        }\n        getKeysFreeResult(&result);\n    } else {\n        addReplySubcommandSyntaxError(c);\n    }\n}\n\n/* Convert an amount of bytes into a human readable string in the form\n * of 100B, 2G, 100M, 4K, and so forth. */\nvoid bytesToHuman(char *s, unsigned long long n) {\n    double d;\n\n    if (n < 1024) {\n        /* Bytes */\n        sprintf(s,\"%lluB\",n);\n    } else if (n < (1024*1024)) {\n        d = (double)n/(1024);\n        sprintf(s,\"%.2fK\",d);\n    } else if (n < (1024LL*1024*1024)) {\n        d = (double)n/(1024*1024);\n        sprintf(s,\"%.2fM\",d);\n    } else if (n < (1024LL*1024*1024*1024)) {\n        d = (double)n/(1024LL*1024*1024);\n        sprintf(s,\"%.2fG\",d);\n    } else if (n < (1024LL*1024*1024*1024*1024)) {\n        d = (double)n/(1024LL*1024*1024*1024);\n        sprintf(s,\"%.2fT\",d);\n    } else if (n < (1024LL*1024*1024*1024*1024*1024)) {\n        d = (double)n/(1024LL*1024*1024*1024*1024);\n        sprintf(s,\"%.2fP\",d);\n    } else {\n        /* Let's hope we never need this */\n        sprintf(s,\"%lluB\",n);\n    }\n}\n\n/* Characters we sanitize on INFO output to maintain expected format. */\nstatic char unsafe_info_chars[] = \"#:\\n\\r\";\nstatic char unsafe_info_chars_substs[] = \"____\";   /* Must be same length as above */\n\n/* Returns a sanitized version of s that contains no unsafe info string chars.\n * If no unsafe characters are found, simply returns s. Caller needs to\n * free tmp if it is non-null on return.\n */\nconst char *getSafeInfoString(const char *s, size_t len, char **tmp) {\n    *tmp = NULL;\n    if (mempbrk(s, len, unsafe_info_chars,sizeof(unsafe_info_chars)-1)\n        == NULL) return s;\n    char *new = *tmp = zmalloc(len + 1);\n    memcpy(new, s, len);\n    new[len] = '\\0';\n    return memmapchars(new, len, unsafe_info_chars, unsafe_info_chars_substs,\n                       sizeof(unsafe_info_chars)-1);\n}\n\n/* Create the string returned by the INFO command. This is decoupled\n * by the INFO command itself as we need to report the same information\n * on memory corruption problems. */\nsds genRedisInfoString(const char *section) {\n    sds info = sdsempty();\n    time_t uptime = server.unixtime-server.stat_starttime;\n    int j;\n    int allsections = 0, defsections = 0, everything = 0, modules = 0;\n    int sections = 0;\n\n    if (section == NULL) section = \"default\";\n    allsections = strcasecmp(section,\"all\") == 0;\n    defsections = strcasecmp(section,\"default\") == 0;\n    everything = strcasecmp(section,\"everything\") == 0;\n    modules = strcasecmp(section,\"modules\") == 0;\n    if (everything) allsections = 1;\n\n    /* Server */\n    if (allsections || defsections || !strcasecmp(section,\"server\")) {\n        static int call_uname = 1;\n        static struct utsname name;\n        char *mode;\n        char *supervised;\n\n        if (server.cluster_enabled) mode = \"cluster\";\n        else if (server.sentinel_mode) mode = \"sentinel\";\n        else mode = \"standalone\";\n\n        if (server.supervised) {\n            if (server.supervised_mode == SUPERVISED_UPSTART) supervised = \"upstart\";\n            else if (server.supervised_mode == SUPERVISED_SYSTEMD) supervised = \"systemd\";\n            else supervised = \"unknown\";\n        } else {\n            supervised = \"no\";\n        }\n\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n\n        if (call_uname) {\n            /* Uname can be slow and is always the same output. Cache it. */\n            uname(&name);\n            call_uname = 0;\n        }\n\n        unsigned int lruclock;\n        atomicGet(server.lruclock,lruclock);\n        info = sdscatfmt(info,\n            \"# Server\\r\\n\"\n            \"redis_version:%s\\r\\n\"\n            \"redis_git_sha1:%s\\r\\n\"\n            \"redis_git_dirty:%i\\r\\n\"\n            \"redis_build_id:%s\\r\\n\"\n            \"redis_mode:%s\\r\\n\"\n            \"os:%s %s %s\\r\\n\"\n            \"arch_bits:%i\\r\\n\"\n            \"multiplexing_api:%s\\r\\n\"\n            \"atomicvar_api:%s\\r\\n\"\n            \"gcc_version:%i.%i.%i\\r\\n\"\n            \"process_id:%I\\r\\n\"\n            \"process_supervised:%s\\r\\n\"\n            \"run_id:%s\\r\\n\"\n            \"tcp_port:%i\\r\\n\"\n            \"server_time_usec:%I\\r\\n\"\n            \"uptime_in_seconds:%I\\r\\n\"\n            \"uptime_in_days:%I\\r\\n\"\n            \"hz:%i\\r\\n\"\n            \"configured_hz:%i\\r\\n\"\n            \"lru_clock:%u\\r\\n\"\n            \"executable:%s\\r\\n\"\n            \"config_file:%s\\r\\n\"\n            \"io_threads_active:%i\\r\\n\",\n            REDIS_VERSION,\n            redisGitSHA1(),\n            strtol(redisGitDirty(),NULL,10) > 0,\n            redisBuildIdString(),\n            mode,\n            name.sysname, name.release, name.machine,\n            server.arch_bits,\n            aeGetApiName(),\n            REDIS_ATOMIC_API,\n#ifdef __GNUC__\n            __GNUC__,__GNUC_MINOR__,__GNUC_PATCHLEVEL__,\n#else\n            0,0,0,\n#endif\n            (int64_t) getpid(),\n            supervised,\n            server.runid,\n            server.port ? server.port : server.tls_port,\n            (int64_t)server.ustime,\n            (int64_t)uptime,\n            (int64_t)(uptime/(3600*24)),\n            server.hz,\n            server.config_hz,\n            lruclock,\n            server.executable ? server.executable : \"\",\n            server.configfile ? server.configfile : \"\",\n            server.io_threads_active);\n    }\n\n    /* Clients */\n    if (allsections || defsections || !strcasecmp(section,\"clients\")) {\n        size_t maxin, maxout;\n        getExpansiveClientsInfo(&maxin,&maxout);\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n        info = sdscatprintf(info,\n            \"# Clients\\r\\n\"\n            \"connected_clients:%lu\\r\\n\"\n            \"cluster_connections:%lu\\r\\n\"\n            \"maxclients:%u\\r\\n\"\n            \"client_recent_max_input_buffer:%zu\\r\\n\"\n            \"client_recent_max_output_buffer:%zu\\r\\n\"\n            \"blocked_clients:%d\\r\\n\"\n            \"tracking_clients:%d\\r\\n\"\n            \"clients_in_timeout_table:%llu\\r\\n\",\n            listLength(server.clients)-listLength(server.slaves),\n            getClusterConnectionsCount(),\n            server.maxclients,\n            maxin, maxout,\n            server.blocked_clients,\n            server.tracking_clients,\n            (unsigned long long) raxSize(server.clients_timeout_table));\n    }\n\n    /* Memory */\n    if (allsections || defsections || !strcasecmp(section,\"memory\")) {\n        char hmem[64];\n        char peak_hmem[64];\n        char total_system_hmem[64];\n        char used_memory_lua_hmem[64];\n        char used_memory_scripts_hmem[64];\n        char used_memory_rss_hmem[64];\n        char maxmemory_hmem[64];\n        size_t zmalloc_used = zmalloc_used_memory();\n        size_t total_system_mem = server.system_memory_size;\n        const char *evict_policy = evictPolicyToString();\n        long long memory_lua = server.lua ? (long long)lua_gc(server.lua,LUA_GCCOUNT,0)*1024 : 0;\n        struct redisMemOverhead *mh = getMemoryOverheadData();\n\n        /* Peak memory is updated from time to time by serverCron() so it\n         * may happen that the instantaneous value is slightly bigger than\n         * the peak value. This may confuse users, so we update the peak\n         * if found smaller than the current memory usage. */\n        if (zmalloc_used > server.stat_peak_memory)\n            server.stat_peak_memory = zmalloc_used;\n\n        bytesToHuman(hmem,zmalloc_used);\n        bytesToHuman(peak_hmem,server.stat_peak_memory);\n        bytesToHuman(total_system_hmem,total_system_mem);\n        bytesToHuman(used_memory_lua_hmem,memory_lua);\n        bytesToHuman(used_memory_scripts_hmem,mh->lua_caches);\n        bytesToHuman(used_memory_rss_hmem,server.cron_malloc_stats.process_rss);\n        bytesToHuman(maxmemory_hmem,server.maxmemory);\n\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n        info = sdscatprintf(info,\n            \"# Memory\\r\\n\"\n            \"used_memory:%zu\\r\\n\"\n            \"used_memory_human:%s\\r\\n\"\n            \"used_memory_rss:%zu\\r\\n\"\n            \"used_memory_rss_human:%s\\r\\n\"\n            \"used_memory_peak:%zu\\r\\n\"\n            \"used_memory_peak_human:%s\\r\\n\"\n            \"used_memory_peak_perc:%.2f%%\\r\\n\"\n            \"used_memory_overhead:%zu\\r\\n\"\n            \"used_memory_startup:%zu\\r\\n\"\n            \"used_memory_dataset:%zu\\r\\n\"\n            \"used_memory_dataset_perc:%.2f%%\\r\\n\"\n            \"allocator_allocated:%zu\\r\\n\"\n            \"allocator_active:%zu\\r\\n\"\n            \"allocator_resident:%zu\\r\\n\"\n            \"total_system_memory:%lu\\r\\n\"\n            \"total_system_memory_human:%s\\r\\n\"\n            \"used_memory_lua:%lld\\r\\n\"\n            \"used_memory_lua_human:%s\\r\\n\"\n            \"used_memory_scripts:%lld\\r\\n\"\n            \"used_memory_scripts_human:%s\\r\\n\"\n            \"number_of_cached_scripts:%lu\\r\\n\"\n            \"maxmemory:%lld\\r\\n\"\n            \"maxmemory_human:%s\\r\\n\"\n            \"maxmemory_policy:%s\\r\\n\"\n            \"allocator_frag_ratio:%.2f\\r\\n\"\n            \"allocator_frag_bytes:%zu\\r\\n\"\n            \"allocator_rss_ratio:%.2f\\r\\n\"\n            \"allocator_rss_bytes:%zd\\r\\n\"\n            \"rss_overhead_ratio:%.2f\\r\\n\"\n            \"rss_overhead_bytes:%zd\\r\\n\"\n            \"mem_fragmentation_ratio:%.2f\\r\\n\"\n            \"mem_fragmentation_bytes:%zd\\r\\n\"\n            \"mem_not_counted_for_evict:%zu\\r\\n\"\n            \"mem_replication_backlog:%zu\\r\\n\"\n            \"mem_clients_slaves:%zu\\r\\n\"\n            \"mem_clients_normal:%zu\\r\\n\"\n            \"mem_aof_buffer:%zu\\r\\n\"\n            \"mem_allocator:%s\\r\\n\"\n            \"active_defrag_running:%d\\r\\n\"\n            \"lazyfree_pending_objects:%zu\\r\\n\"\n            \"lazyfreed_objects:%zu\\r\\n\",\n            zmalloc_used,\n            hmem,\n            server.cron_malloc_stats.process_rss,\n            used_memory_rss_hmem,\n            server.stat_peak_memory,\n            peak_hmem,\n            mh->peak_perc,\n            mh->overhead_total,\n            mh->startup_allocated,\n            mh->dataset,\n            mh->dataset_perc,\n            server.cron_malloc_stats.allocator_allocated,\n            server.cron_malloc_stats.allocator_active,\n            server.cron_malloc_stats.allocator_resident,\n            (unsigned long)total_system_mem,\n            total_system_hmem,\n            memory_lua,\n            used_memory_lua_hmem,\n            (long long) mh->lua_caches,\n            used_memory_scripts_hmem,\n            dictSize(server.lua_scripts),\n            server.maxmemory,\n            maxmemory_hmem,\n            evict_policy,\n            mh->allocator_frag,\n            mh->allocator_frag_bytes,\n            mh->allocator_rss,\n            mh->allocator_rss_bytes,\n            mh->rss_extra,\n            mh->rss_extra_bytes,\n            mh->total_frag,       /* This is the total RSS overhead, including\n                                     fragmentation, but not just it. This field\n                                     (and the next one) is named like that just\n                                     for backward compatibility. */\n            mh->total_frag_bytes,\n            freeMemoryGetNotCountedMemory(),\n            mh->repl_backlog,\n            mh->clients_slaves,\n            mh->clients_normal,\n            mh->aof_buffer,\n            ZMALLOC_LIB,\n            server.active_defrag_running,\n            lazyfreeGetPendingObjectsCount(),\n            lazyfreeGetFreedObjectsCount()\n        );\n        freeMemoryOverheadData(mh);\n    }\n\n    /* Persistence */\n    if (allsections || defsections || !strcasecmp(section,\"persistence\")) {\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n        double fork_perc = 0;\n        if (server.stat_module_progress) {\n            fork_perc = server.stat_module_progress * 100;\n        } else if (server.stat_current_save_keys_total) {\n            fork_perc = ((double)server.stat_current_save_keys_processed / server.stat_current_save_keys_total) * 100;\n        }\n        int aof_bio_fsync_status;\n        atomicGet(server.aof_bio_fsync_status,aof_bio_fsync_status);\n\n        info = sdscatprintf(info,\n            \"# Persistence\\r\\n\"\n            \"loading:%d\\r\\n\"\n            \"current_cow_size:%zu\\r\\n\"\n            \"current_cow_size_age:%lu\\r\\n\"\n            \"current_fork_perc:%.2f\\r\\n\"\n            \"current_save_keys_processed:%zu\\r\\n\"\n            \"current_save_keys_total:%zu\\r\\n\"\n            \"rdb_changes_since_last_save:%lld\\r\\n\"\n            \"rdb_bgsave_in_progress:%d\\r\\n\"\n            \"rdb_last_save_time:%jd\\r\\n\"\n            \"rdb_last_bgsave_status:%s\\r\\n\"\n            \"rdb_last_bgsave_time_sec:%jd\\r\\n\"\n            \"rdb_current_bgsave_time_sec:%jd\\r\\n\"\n            \"rdb_last_cow_size:%zu\\r\\n\"\n            \"aof_enabled:%d\\r\\n\"\n            \"aof_rewrite_in_progress:%d\\r\\n\"\n            \"aof_rewrite_scheduled:%d\\r\\n\"\n            \"aof_last_rewrite_time_sec:%jd\\r\\n\"\n            \"aof_current_rewrite_time_sec:%jd\\r\\n\"\n            \"aof_last_bgrewrite_status:%s\\r\\n\"\n            \"aof_last_write_status:%s\\r\\n\"\n            \"aof_last_cow_size:%zu\\r\\n\"\n            \"module_fork_in_progress:%d\\r\\n\"\n            \"module_fork_last_cow_size:%zu\\r\\n\",\n            (int)server.loading,\n            server.stat_current_cow_bytes,\n            server.stat_current_cow_updated ? (unsigned long) elapsedMs(server.stat_current_cow_updated) / 1000 : 0,\n            fork_perc,\n            server.stat_current_save_keys_processed,\n            server.stat_current_save_keys_total,\n            server.dirty,\n            server.child_type == CHILD_TYPE_RDB,\n            (intmax_t)server.lastsave,\n            (server.lastbgsave_status == C_OK) ? \"ok\" : \"err\",\n            (intmax_t)server.rdb_save_time_last,\n            (intmax_t)((server.child_type != CHILD_TYPE_RDB) ?\n                -1 : time(NULL)-server.rdb_save_time_start),\n            server.stat_rdb_cow_bytes,\n            server.aof_state != AOF_OFF,\n            server.child_type == CHILD_TYPE_AOF,\n            server.aof_rewrite_scheduled,\n            (intmax_t)server.aof_rewrite_time_last,\n            (intmax_t)((server.child_type != CHILD_TYPE_AOF) ?\n                -1 : time(NULL)-server.aof_rewrite_time_start),\n            (server.aof_lastbgrewrite_status == C_OK) ? \"ok\" : \"err\",\n            (server.aof_last_write_status == C_OK &&\n                aof_bio_fsync_status == C_OK) ? \"ok\" : \"err\",\n            server.stat_aof_cow_bytes,\n            server.child_type == CHILD_TYPE_MODULE,\n            server.stat_module_cow_bytes);\n\n        if (server.aof_enabled) {\n            info = sdscatprintf(info,\n                \"aof_current_size:%lld\\r\\n\"\n                \"aof_base_size:%lld\\r\\n\"\n                \"aof_pending_rewrite:%d\\r\\n\"\n                \"aof_buffer_length:%zu\\r\\n\"\n                \"aof_rewrite_buffer_length:%lu\\r\\n\"\n                \"aof_pending_bio_fsync:%llu\\r\\n\"\n                \"aof_delayed_fsync:%lu\\r\\n\",\n                (long long) server.aof_current_size,\n                (long long) server.aof_rewrite_base_size,\n                server.aof_rewrite_scheduled,\n                sdslen(server.aof_buf),\n                aofRewriteBufferSize(),\n                bioPendingJobsOfType(BIO_AOF_FSYNC),\n                server.aof_delayed_fsync);\n        }\n\n        if (server.loading) {\n            double perc = 0;\n            time_t eta, elapsed;\n            off_t remaining_bytes = 1;\n\n            if (server.loading_total_bytes) {\n                perc = ((double)server.loading_loaded_bytes / server.loading_total_bytes) * 100;\n                remaining_bytes = server.loading_total_bytes - server.loading_loaded_bytes;\n            } else if(server.loading_rdb_used_mem) {\n                perc = ((double)server.loading_loaded_bytes / server.loading_rdb_used_mem) * 100;\n                remaining_bytes = server.loading_rdb_used_mem - server.loading_loaded_bytes;\n                /* used mem is only a (bad) estimation of the rdb file size, avoid going over 100% */\n                if (perc > 99.99) perc = 99.99;\n                if (remaining_bytes < 1) remaining_bytes = 1;\n            }\n\n            elapsed = time(NULL)-server.loading_start_time;\n            if (elapsed == 0) {\n                eta = 1; /* A fake 1 second figure if we don't have\n                            enough info */\n            } else {\n                eta = (elapsed*remaining_bytes)/(server.loading_loaded_bytes+1);\n            }\n\n            info = sdscatprintf(info,\n                \"loading_start_time:%jd\\r\\n\"\n                \"loading_total_bytes:%llu\\r\\n\"\n                \"loading_rdb_used_mem:%llu\\r\\n\"\n                \"loading_loaded_bytes:%llu\\r\\n\"\n                \"loading_loaded_perc:%.2f\\r\\n\"\n                \"loading_eta_seconds:%jd\\r\\n\",\n                (intmax_t) server.loading_start_time,\n                (unsigned long long) server.loading_total_bytes,\n                (unsigned long long) server.loading_rdb_used_mem,\n                (unsigned long long) server.loading_loaded_bytes,\n                perc,\n                (intmax_t)eta\n            );\n        }\n    }\n\n    /* Stats */\n    if (allsections || defsections || !strcasecmp(section,\"stats\")) {\n        long long stat_total_reads_processed, stat_total_writes_processed;\n        long long stat_net_input_bytes, stat_net_output_bytes;\n        atomicGet(server.stat_total_reads_processed, stat_total_reads_processed);\n        atomicGet(server.stat_total_writes_processed, stat_total_writes_processed);\n        atomicGet(server.stat_net_input_bytes, stat_net_input_bytes);\n        atomicGet(server.stat_net_output_bytes, stat_net_output_bytes);\n\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n        info = sdscatprintf(info,\n            \"# Stats\\r\\n\"\n            \"total_connections_received:%lld\\r\\n\"\n            \"total_commands_processed:%lld\\r\\n\"\n            \"instantaneous_ops_per_sec:%lld\\r\\n\"\n            \"total_net_input_bytes:%lld\\r\\n\"\n            \"total_net_output_bytes:%lld\\r\\n\"\n            \"instantaneous_input_kbps:%.2f\\r\\n\"\n            \"instantaneous_output_kbps:%.2f\\r\\n\"\n            \"rejected_connections:%lld\\r\\n\"\n            \"sync_full:%lld\\r\\n\"\n            \"sync_partial_ok:%lld\\r\\n\"\n            \"sync_partial_err:%lld\\r\\n\"\n            \"expired_keys:%lld\\r\\n\"\n            \"expired_stale_perc:%.2f\\r\\n\"\n            \"expired_time_cap_reached_count:%lld\\r\\n\"\n            \"expire_cycle_cpu_milliseconds:%lld\\r\\n\"\n            \"evicted_keys:%lld\\r\\n\"\n            \"keyspace_hits:%lld\\r\\n\"\n            \"keyspace_misses:%lld\\r\\n\"\n            \"pubsub_channels:%ld\\r\\n\"\n            \"pubsub_patterns:%lu\\r\\n\"\n            \"latest_fork_usec:%lld\\r\\n\"\n            \"total_forks:%lld\\r\\n\"\n            \"migrate_cached_sockets:%ld\\r\\n\"\n            \"slave_expires_tracked_keys:%zu\\r\\n\"\n            \"active_defrag_hits:%lld\\r\\n\"\n            \"active_defrag_misses:%lld\\r\\n\"\n            \"active_defrag_key_hits:%lld\\r\\n\"\n            \"active_defrag_key_misses:%lld\\r\\n\"\n            \"tracking_total_keys:%lld\\r\\n\"\n            \"tracking_total_items:%lld\\r\\n\"\n            \"tracking_total_prefixes:%lld\\r\\n\"\n            \"unexpected_error_replies:%lld\\r\\n\"\n            \"total_error_replies:%lld\\r\\n\"\n            \"dump_payload_sanitizations:%lld\\r\\n\"\n            \"total_reads_processed:%lld\\r\\n\"\n            \"total_writes_processed:%lld\\r\\n\"\n            \"io_threaded_reads_processed:%lld\\r\\n\"\n            \"io_threaded_writes_processed:%lld\\r\\n\",\n            server.stat_numconnections,\n            server.stat_numcommands,\n            getInstantaneousMetric(STATS_METRIC_COMMAND),\n            stat_net_input_bytes,\n            stat_net_output_bytes,\n            (float)getInstantaneousMetric(STATS_METRIC_NET_INPUT)/1024,\n            (float)getInstantaneousMetric(STATS_METRIC_NET_OUTPUT)/1024,\n            server.stat_rejected_conn,\n            server.stat_sync_full,\n            server.stat_sync_partial_ok,\n            server.stat_sync_partial_err,\n            server.stat_expiredkeys,\n            server.stat_expired_stale_perc*100,\n            server.stat_expired_time_cap_reached_count,\n            server.stat_expire_cycle_time_used/1000,\n            server.stat_evictedkeys,\n            server.stat_keyspace_hits,\n            server.stat_keyspace_misses,\n            dictSize(server.pubsub_channels),\n            dictSize(server.pubsub_patterns),\n            server.stat_fork_time,\n            server.stat_total_forks,\n            dictSize(server.migrate_cached_sockets),\n            getSlaveKeyWithExpireCount(),\n            server.stat_active_defrag_hits,\n            server.stat_active_defrag_misses,\n            server.stat_active_defrag_key_hits,\n            server.stat_active_defrag_key_misses,\n            (unsigned long long) trackingGetTotalKeys(),\n            (unsigned long long) trackingGetTotalItems(),\n            (unsigned long long) trackingGetTotalPrefixes(),\n            server.stat_unexpected_error_replies,\n            server.stat_total_error_replies,\n            server.stat_dump_payload_sanitizations,\n            stat_total_reads_processed,\n            stat_total_writes_processed,\n            server.stat_io_reads_processed,\n            server.stat_io_writes_processed);\n    }\n\n    /* Replication */\n    if (allsections || defsections || !strcasecmp(section,\"replication\")) {\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n        info = sdscatprintf(info,\n            \"# Replication\\r\\n\"\n            \"role:%s\\r\\n\",\n            server.masterhost == NULL ? \"master\" : \"slave\");\n        if (server.masterhost) {\n            long long slave_repl_offset = 1;\n\n            if (server.master)\n                slave_repl_offset = server.master->reploff;\n            else if (server.cached_master)\n                slave_repl_offset = server.cached_master->reploff;\n\n            info = sdscatprintf(info,\n                \"master_host:%s\\r\\n\"\n                \"master_port:%d\\r\\n\"\n                \"master_link_status:%s\\r\\n\"\n                \"master_last_io_seconds_ago:%d\\r\\n\"\n                \"master_sync_in_progress:%d\\r\\n\"\n                \"slave_repl_offset:%lld\\r\\n\"\n                ,server.masterhost,\n                server.masterport,\n                (server.repl_state == REPL_STATE_CONNECTED) ?\n                    \"up\" : \"down\",\n                server.master ?\n                ((int)(server.unixtime-server.master->lastinteraction)) : -1,\n                server.repl_state == REPL_STATE_TRANSFER,\n                slave_repl_offset\n            );\n\n            if (server.repl_state == REPL_STATE_TRANSFER) {\n                double perc = 0;\n                if (server.repl_transfer_size) {\n                    perc = ((double)server.repl_transfer_read / server.repl_transfer_size) * 100;\n                }\n                info = sdscatprintf(info,\n                    \"master_sync_total_bytes:%lld\\r\\n\"\n                    \"master_sync_read_bytes:%lld\\r\\n\"\n                    \"master_sync_left_bytes:%lld\\r\\n\"\n                    \"master_sync_perc:%.2f\\r\\n\"\n                    \"master_sync_last_io_seconds_ago:%d\\r\\n\",\n                    (long long) server.repl_transfer_size,\n                    (long long) server.repl_transfer_read,\n                    (long long) (server.repl_transfer_size - server.repl_transfer_read),\n                    perc,\n                    (int)(server.unixtime-server.repl_transfer_lastio)\n                );\n            }\n\n            if (server.repl_state != REPL_STATE_CONNECTED) {\n                info = sdscatprintf(info,\n                    \"master_link_down_since_seconds:%jd\\r\\n\",\n                    server.repl_down_since ?\n                    (intmax_t)(server.unixtime-server.repl_down_since) : -1);\n            }\n            info = sdscatprintf(info,\n                \"slave_priority:%d\\r\\n\"\n                \"slave_read_only:%d\\r\\n\"\n                \"replica_announced:%d\\r\\n\",\n                server.slave_priority,\n                server.repl_slave_ro,\n                server.replica_announced);\n        }\n\n        info = sdscatprintf(info,\n            \"connected_slaves:%lu\\r\\n\",\n            listLength(server.slaves));\n\n        /* If min-slaves-to-write is active, write the number of slaves\n         * currently considered 'good'. */\n        if (server.repl_min_slaves_to_write &&\n            server.repl_min_slaves_max_lag) {\n            info = sdscatprintf(info,\n                \"min_slaves_good_slaves:%d\\r\\n\",\n                server.repl_good_slaves_count);\n        }\n\n        if (listLength(server.slaves)) {\n            int slaveid = 0;\n            listNode *ln;\n            listIter li;\n\n            listRewind(server.slaves,&li);\n            while((ln = listNext(&li))) {\n                client *slave = listNodeValue(ln);\n                char *state = NULL;\n                char ip[NET_IP_STR_LEN], *slaveip = slave->slave_addr;\n                int port;\n                long lag = 0;\n\n                if (!slaveip) {\n                    if (connPeerToString(slave->conn,ip,sizeof(ip),&port) == -1)\n                        continue;\n                    slaveip = ip;\n                }\n                switch(slave->replstate) {\n                case SLAVE_STATE_WAIT_BGSAVE_START:\n                case SLAVE_STATE_WAIT_BGSAVE_END:\n                    state = \"wait_bgsave\";\n                    break;\n                case SLAVE_STATE_SEND_BULK:\n                    state = \"send_bulk\";\n                    break;\n                case SLAVE_STATE_ONLINE:\n                    state = \"online\";\n                    break;\n                }\n                if (state == NULL) continue;\n                if (slave->replstate == SLAVE_STATE_ONLINE)\n                    lag = time(NULL) - slave->repl_ack_time;\n\n                info = sdscatprintf(info,\n                    \"slave%d:ip=%s,port=%d,state=%s,\"\n                    \"offset=%lld,lag=%ld\\r\\n\",\n                    slaveid,slaveip,slave->slave_listening_port,state,\n                    slave->repl_ack_off, lag);\n                slaveid++;\n            }\n        }\n        info = sdscatprintf(info,\n            \"master_failover_state:%s\\r\\n\"\n            \"master_replid:%s\\r\\n\"\n            \"master_replid2:%s\\r\\n\"\n            \"master_repl_offset:%lld\\r\\n\"\n            \"second_repl_offset:%lld\\r\\n\"\n            \"repl_backlog_active:%d\\r\\n\"\n            \"repl_backlog_size:%lld\\r\\n\"\n            \"repl_backlog_first_byte_offset:%lld\\r\\n\"\n            \"repl_backlog_histlen:%lld\\r\\n\",\n            getFailoverStateString(),\n            server.replid,\n            server.replid2,\n            server.master_repl_offset,\n            server.second_replid_offset,\n            server.repl_backlog != NULL,\n            server.repl_backlog_size,\n            server.repl_backlog_off,\n            server.repl_backlog_histlen);\n    }\n\n    /* CPU */\n    if (allsections || defsections || !strcasecmp(section,\"cpu\")) {\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n\n        struct rusage self_ru, c_ru;\n        getrusage(RUSAGE_SELF, &self_ru);\n        getrusage(RUSAGE_CHILDREN, &c_ru);\n        info = sdscatprintf(info,\n        \"# CPU\\r\\n\"\n        \"used_cpu_sys:%ld.%06ld\\r\\n\"\n        \"used_cpu_user:%ld.%06ld\\r\\n\"\n        \"used_cpu_sys_children:%ld.%06ld\\r\\n\"\n        \"used_cpu_user_children:%ld.%06ld\\r\\n\",\n        (long)self_ru.ru_stime.tv_sec, (long)self_ru.ru_stime.tv_usec,\n        (long)self_ru.ru_utime.tv_sec, (long)self_ru.ru_utime.tv_usec,\n        (long)c_ru.ru_stime.tv_sec, (long)c_ru.ru_stime.tv_usec,\n        (long)c_ru.ru_utime.tv_sec, (long)c_ru.ru_utime.tv_usec);\n#ifdef RUSAGE_THREAD\n        struct rusage m_ru;\n        getrusage(RUSAGE_THREAD, &m_ru);\n        info = sdscatprintf(info,\n            \"used_cpu_sys_main_thread:%ld.%06ld\\r\\n\"\n            \"used_cpu_user_main_thread:%ld.%06ld\\r\\n\",\n            (long)m_ru.ru_stime.tv_sec, (long)m_ru.ru_stime.tv_usec,\n            (long)m_ru.ru_utime.tv_sec, (long)m_ru.ru_utime.tv_usec);\n#endif  /* RUSAGE_THREAD */\n    }\n\n    /* Modules */\n    if (allsections || defsections || !strcasecmp(section,\"modules\")) {\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n        info = sdscatprintf(info,\"# Modules\\r\\n\");\n        info = genModulesInfoString(info);\n    }\n\n    /* Command statistics */\n    if (allsections || !strcasecmp(section,\"commandstats\")) {\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n        info = sdscatprintf(info, \"# Commandstats\\r\\n\");\n\n        struct redisCommand *c;\n        dictEntry *de;\n        dictIterator *di;\n        di = dictGetSafeIterator(server.commands);\n        while((de = dictNext(di)) != NULL) {\n            char *tmpsafe;\n            c = (struct redisCommand *) dictGetVal(de);\n            if (!c->calls && !c->failed_calls && !c->rejected_calls)\n                continue;\n            info = sdscatprintf(info,\n                \"cmdstat_%s:calls=%lld,usec=%lld,usec_per_call=%.2f\"\n                \",rejected_calls=%lld,failed_calls=%lld\\r\\n\",\n                getSafeInfoString(c->name, strlen(c->name), &tmpsafe), c->calls, c->microseconds,\n                (c->calls == 0) ? 0 : ((float)c->microseconds/c->calls),\n                c->rejected_calls, c->failed_calls);\n            if (tmpsafe != NULL) zfree(tmpsafe);\n        }\n        dictReleaseIterator(di);\n    }\n    /* Error statistics */\n    if (allsections || defsections || !strcasecmp(section,\"errorstats\")) {\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n        info = sdscat(info, \"# Errorstats\\r\\n\");\n        raxIterator ri;\n        raxStart(&ri,server.errors);\n        raxSeek(&ri,\"^\",NULL,0);\n        struct redisError *e;\n        while(raxNext(&ri)) {\n            char *tmpsafe;\n            e = (struct redisError *) ri.data;\n            info = sdscatprintf(info,\n                \"errorstat_%.*s:count=%lld\\r\\n\",\n                (int)ri.key_len, getSafeInfoString((char *) ri.key, ri.key_len, &tmpsafe), e->count);\n            if (tmpsafe != NULL) zfree(tmpsafe);\n        }\n        raxStop(&ri);\n    }\n\n    /* Cluster */\n    if (allsections || defsections || !strcasecmp(section,\"cluster\")) {\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n        info = sdscatprintf(info,\n        \"# Cluster\\r\\n\"\n        \"cluster_enabled:%d\\r\\n\",\n        server.cluster_enabled);\n    }\n\n    /* Key space */\n    if (allsections || defsections || !strcasecmp(section,\"keyspace\")) {\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n        info = sdscatprintf(info, \"# Keyspace\\r\\n\");\n        for (j = 0; j < server.dbnum; j++) {\n            long long keys, vkeys;\n\n            keys = dictSize(server.db[j].dict);\n            vkeys = dictSize(server.db[j].expires);\n            if (keys || vkeys) {\n                info = sdscatprintf(info,\n                    \"db%d:keys=%lld,expires=%lld,avg_ttl=%lld\\r\\n\",\n                    j, keys, vkeys, server.db[j].avg_ttl);\n            }\n        }\n    }\n\n    /* Get info from modules.\n     * if user asked for \"everything\" or \"modules\", or a specific section\n     * that's not found yet. */\n    if (everything || modules ||\n        (!allsections && !defsections && sections==0)) {\n        info = modulesCollectInfo(info,\n                                  everything || modules ? NULL: section,\n                                  0, /* not a crash report */\n                                  sections);\n    }\n    return info;\n}\n\nvoid infoCommand(client *c) {\n    char *section = c->argc == 2 ? c->argv[1]->ptr : \"default\";\n\n    if (c->argc > 2) {\n        addReplyErrorObject(c,shared.syntaxerr);\n        return;\n    }\n    sds info = genRedisInfoString(section);\n    addReplyVerbatim(c,info,sdslen(info),\"txt\");\n    sdsfree(info);\n}\n\nvoid monitorCommand(client *c) {\n    if (c->flags & CLIENT_DENY_BLOCKING) {\n        /**\n         * A client that has CLIENT_DENY_BLOCKING flag on\n         * expects a reply per command and so can't execute MONITOR. */\n        addReplyError(c, \"MONITOR isn't allowed for DENY BLOCKING client\");\n        return;\n    }\n\n    /* ignore MONITOR if already slave or in monitor mode */\n    if (c->flags & CLIENT_SLAVE) return;\n\n    c->flags |= (CLIENT_SLAVE|CLIENT_MONITOR);\n    listAddNodeTail(server.monitors,c);\n    addReply(c,shared.ok);\n}\n\n/* =================================== Main! ================================ */\n\nint checkIgnoreWarning(const char *warning) {\n    int argc, j;\n    sds *argv = sdssplitargs(server.ignore_warnings, &argc);\n    if (argv == NULL)\n        return 0;\n\n    for (j = 0; j < argc; j++) {\n        char *flag = argv[j];\n        if (!strcasecmp(flag, warning))\n            break;\n    }\n    sdsfreesplitres(argv,argc);\n    return j < argc;\n}\n\n#ifdef __linux__\nint linuxOvercommitMemoryValue(void) {\n    FILE *fp = fopen(\"/proc/sys/vm/overcommit_memory\",\"r\");\n    char buf[64];\n\n    if (!fp) return -1;\n    if (fgets(buf,64,fp) == NULL) {\n        fclose(fp);\n        return -1;\n    }\n    fclose(fp);\n\n    return atoi(buf);\n}\n\nvoid linuxMemoryWarnings(void) {\n    if (linuxOvercommitMemoryValue() == 0) {\n        serverLog(LL_WARNING,\"WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.\");\n    }\n    if (THPIsEnabled() && THPDisable()) {\n        serverLog(LL_WARNING,\"WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo madvise > /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled (set to 'madvise' or 'never').\");\n    }\n}\n\n#ifdef __arm64__\n\n/* Get size in kilobytes of the Shared_Dirty pages of the calling process for the\n * memory map corresponding to the provided address, or -1 on error. */\nstatic int smapsGetSharedDirty(unsigned long addr) {\n    int ret, in_mapping = 0, val = -1;\n    unsigned long from, to;\n    char buf[64];\n    FILE *f;\n\n    f = fopen(\"/proc/self/smaps\", \"r\");\n    if (!f) return -1;\n\n    while (1) {\n        if (!fgets(buf, sizeof(buf), f))\n            break;\n\n        ret = sscanf(buf, \"%lx-%lx\", &from, &to);\n        if (ret == 2)\n            in_mapping = from <= addr && addr < to;\n\n        if (in_mapping && !memcmp(buf, \"Shared_Dirty:\", 13)) {\n            sscanf(buf, \"%*s %d\", &val);\n            /* If parsing fails, we remain with val == -1 */\n            break;\n        }\n    }\n\n    fclose(f);\n    return val;\n}\n\n/* Older arm64 Linux kernels have a bug that could lead to data corruption\n * during background save in certain scenarios. This function checks if the\n * kernel is affected.\n * The bug was fixed in commit ff1712f953e27f0b0718762ec17d0adb15c9fd0b\n * titled: \"arm64: pgtable: Ensure dirty bit is preserved across pte_wrprotect()\"\n * Return -1 on unexpected test failure, 1 if the kernel seems to be affected,\n * and 0 otherwise. */\nint linuxMadvFreeForkBugCheck(void) {\n    int ret, pipefd[2] = { -1, -1 };\n    pid_t pid;\n    char *p = NULL, *q;\n    int bug_found = 0;\n    long page_size = sysconf(_SC_PAGESIZE);\n    long map_size = 3 * page_size;\n\n    /* Create a memory map that's in our full control (not one used by the allocator). */\n    p = mmap(NULL, map_size, PROT_READ, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n    if (p == MAP_FAILED) {\n        serverLog(LL_WARNING, \"Failed to mmap(): %s\", strerror(errno));\n        return -1;\n    }\n\n    q = p + page_size;\n\n    /* Split the memory map in 3 pages by setting their protection as RO|RW|RO to prevent\n     * Linux from merging this memory map with adjacent VMAs. */\n    ret = mprotect(q, page_size, PROT_READ | PROT_WRITE);\n    if (ret < 0) {\n        serverLog(LL_WARNING, \"Failed to mprotect(): %s\", strerror(errno));\n        bug_found = -1;\n        goto exit;\n    }\n\n    /* Write to the page once to make it resident */\n    *(volatile char*)q = 0;\n\n    /* Tell the kernel that this page is free to be reclaimed. */\n#ifndef MADV_FREE\n#define MADV_FREE 8\n#endif\n    ret = madvise(q, page_size, MADV_FREE);\n    if (ret < 0) {\n        /* MADV_FREE is not available on older kernels that are presumably\n         * not affected. */\n        if (errno == EINVAL) goto exit;\n\n        serverLog(LL_WARNING, \"Failed to madvise(): %s\", strerror(errno));\n        bug_found = -1;\n        goto exit;\n    }\n\n    /* Write to the page after being marked for freeing, this is supposed to take\n     * ownership of that page again. */\n    *(volatile char*)q = 0;\n\n    /* Create a pipe for the child to return the info to the parent. */\n    ret = pipe(pipefd);\n    if (ret < 0) {\n        serverLog(LL_WARNING, \"Failed to create pipe: %s\", strerror(errno));\n        bug_found = -1;\n        goto exit;\n    }\n\n    /* Fork the process. */\n    pid = fork();\n    if (pid < 0) {\n        serverLog(LL_WARNING, \"Failed to fork: %s\", strerror(errno));\n        bug_found = -1;\n        goto exit;\n    } else if (!pid) {\n        /* Child: check if the page is marked as dirty, page_size in kb.\n         * A value of 0 means the kernel is affected by the bug. */\n        ret = smapsGetSharedDirty((unsigned long) q);\n        if (!ret)\n            bug_found = 1;\n        else if (ret == -1)     /* Failed to read */\n            bug_found = -1;\n\n        if (write(pipefd[1], &bug_found, sizeof(bug_found)) < 0)\n            serverLog(LL_WARNING, \"Failed to write to parent: %s\", strerror(errno));\n        exit(0);\n    } else {\n        /* Read the result from the child. */\n        ret = read(pipefd[0], &bug_found, sizeof(bug_found));\n        if (ret < 0) {\n            serverLog(LL_WARNING, \"Failed to read from child: %s\", strerror(errno));\n            bug_found = -1;\n        }\n\n        /* Reap the child pid. */\n        waitpid(pid, NULL, 0);\n    }\n\nexit:\n    /* Cleanup */\n    if (pipefd[0] != -1) close(pipefd[0]);\n    if (pipefd[1] != -1) close(pipefd[1]);\n    if (p != NULL) munmap(p, map_size);\n\n    return bug_found;\n}\n#endif /* __arm64__ */\n#endif /* __linux__ */\n\nvoid createPidFile(void) {\n    /* If pidfile requested, but no pidfile defined, use\n     * default pidfile path */\n    if (!server.pidfile) server.pidfile = zstrdup(CONFIG_DEFAULT_PID_FILE);\n\n    /* Try to write the pid file in a best-effort way. */\n    FILE *fp = fopen(server.pidfile,\"w\");\n    if (fp) {\n        fprintf(fp,\"%d\\n\",(int)getpid());\n        fclose(fp);\n    }\n}\n\nvoid daemonize(void) {\n    int fd;\n\n    if (fork() != 0) exit(0); /* parent exits */\n    setsid(); /* create a new session */\n\n    /* Every output goes to /dev/null. If Redis is daemonized but\n     * the 'logfile' is set to 'stdout' in the configuration file\n     * it will not log at all. */\n    if ((fd = open(\"/dev/null\", O_RDWR, 0)) != -1) {\n        dup2(fd, STDIN_FILENO);\n        dup2(fd, STDOUT_FILENO);\n        dup2(fd, STDERR_FILENO);\n        if (fd > STDERR_FILENO) close(fd);\n    }\n}\n\nvoid version(void) {\n    printf(\"Redis server v=%s sha=%s:%d malloc=%s bits=%d build=%llx\\n\",\n        REDIS_VERSION,\n        redisGitSHA1(),\n        atoi(redisGitDirty()) > 0,\n        ZMALLOC_LIB,\n        sizeof(long) == 4 ? 32 : 64,\n        (unsigned long long) redisBuildId());\n    exit(0);\n}\n\nvoid usage(void) {\n    fprintf(stderr,\"Usage: ./redis-server [/path/to/redis.conf] [options] [-]\\n\");\n    fprintf(stderr,\"       ./redis-server - (read config from stdin)\\n\");\n    fprintf(stderr,\"       ./redis-server -v or --version\\n\");\n    fprintf(stderr,\"       ./redis-server -h or --help\\n\");\n    fprintf(stderr,\"       ./redis-server --test-memory <megabytes>\\n\\n\");\n    fprintf(stderr,\"Examples:\\n\");\n    fprintf(stderr,\"       ./redis-server (run the server with default conf)\\n\");\n    fprintf(stderr,\"       ./redis-server /etc/redis/6379.conf\\n\");\n    fprintf(stderr,\"       ./redis-server --port 7777\\n\");\n    fprintf(stderr,\"       ./redis-server --port 7777 --replicaof 127.0.0.1 8888\\n\");\n    fprintf(stderr,\"       ./redis-server /etc/myredis.conf --loglevel verbose -\\n\");\n    fprintf(stderr,\"       ./redis-server /etc/myredis.conf --loglevel verbose\\n\\n\");\n    fprintf(stderr,\"Sentinel mode:\\n\");\n    fprintf(stderr,\"       ./redis-server /etc/sentinel.conf --sentinel\\n\");\n    exit(1);\n}\n\nvoid redisAsciiArt(void) {\n#include \"asciilogo.h\"\n    char *buf = zmalloc(1024*16);\n    char *mode;\n\n    if (server.cluster_enabled) mode = \"cluster\";\n    else if (server.sentinel_mode) mode = \"sentinel\";\n    else mode = \"standalone\";\n\n    /* Show the ASCII logo if: log file is stdout AND stdout is a\n     * tty AND syslog logging is disabled. Also show logo if the user\n     * forced us to do so via redis.conf. */\n    int show_logo = ((!server.syslog_enabled &&\n                      server.logfile[0] == '\\0' &&\n                      isatty(fileno(stdout))) ||\n                     server.always_show_logo);\n\n    if (!show_logo) {\n        serverLog(LL_NOTICE,\n            \"Running mode=%s, port=%d.\",\n            mode, server.port ? server.port : server.tls_port\n        );\n    } else {\n        snprintf(buf,1024*16,ascii_logo,\n            REDIS_VERSION,\n            redisGitSHA1(),\n            strtol(redisGitDirty(),NULL,10) > 0,\n            (sizeof(long) == 8) ? \"64\" : \"32\",\n            mode, server.port ? server.port : server.tls_port,\n            (long) getpid()\n        );\n        serverLogRaw(LL_NOTICE|LL_RAW,buf);\n    }\n    zfree(buf);\n}\n\nint changeBindAddr(sds *addrlist, int addrlist_len) {\n    int i;\n    int result = C_OK;\n\n    char *prev_bindaddr[CONFIG_BINDADDR_MAX];\n    int prev_bindaddr_count;\n\n    /* Close old TCP and TLS servers */\n    closeSocketListeners(&server.ipfd);\n    closeSocketListeners(&server.tlsfd);\n\n    /* Keep previous settings */\n    prev_bindaddr_count = server.bindaddr_count;\n    memcpy(prev_bindaddr, server.bindaddr, sizeof(server.bindaddr));\n\n    /* Copy new settings */\n    memset(server.bindaddr, 0, sizeof(server.bindaddr));\n    for (i = 0; i < addrlist_len; i++) {\n        server.bindaddr[i] = zstrdup(addrlist[i]);\n    }\n    server.bindaddr_count = addrlist_len;\n\n    /* Bind to the new port */\n    if ((server.port != 0 && listenToPort(server.port, &server.ipfd) != C_OK) ||\n        (server.tls_port != 0 && listenToPort(server.tls_port, &server.tlsfd) != C_OK)) {\n        serverLog(LL_WARNING, \"Failed to bind, trying to restore old listening sockets.\");\n\n        /* Restore old bind addresses */\n        for (i = 0; i < addrlist_len; i++) {\n            zfree(server.bindaddr[i]);\n        }\n        memcpy(server.bindaddr, prev_bindaddr, sizeof(server.bindaddr));\n        server.bindaddr_count = prev_bindaddr_count;\n\n        /* Re-Listen TCP and TLS */\n        server.ipfd.count = 0;\n        if (server.port != 0 && listenToPort(server.port, &server.ipfd) != C_OK) {\n            serverPanic(\"Failed to restore old listening sockets.\");\n        }\n\n        server.tlsfd.count = 0;\n        if (server.tls_port != 0 && listenToPort(server.tls_port, &server.tlsfd) != C_OK) {\n            serverPanic(\"Failed to restore old listening sockets.\");\n        }\n\n        result = C_ERR;\n    } else {\n        /* Free old bind addresses */\n        for (i = 0; i < prev_bindaddr_count; i++) {\n            zfree(prev_bindaddr[i]);\n        }\n    }\n\n    /* Create TCP and TLS event handlers */\n    if (createSocketAcceptHandler(&server.ipfd, acceptTcpHandler) != C_OK) {\n        serverPanic(\"Unrecoverable error creating TCP socket accept handler.\");\n    }\n    if (createSocketAcceptHandler(&server.tlsfd, acceptTLSHandler) != C_OK) {\n        serverPanic(\"Unrecoverable error creating TLS socket accept handler.\");\n    }\n\n    if (server.set_proc_title) redisSetProcTitle(NULL);\n\n    return result;\n}\n\nint changeListenPort(int port, socketFds *sfd, aeFileProc *accept_handler) {\n    socketFds new_sfd = {{0}};\n\n    /* Just close the server if port disabled */\n    if (port == 0) {\n        closeSocketListeners(sfd);\n        if (server.set_proc_title) redisSetProcTitle(NULL);\n        return C_OK;\n    }\n\n    /* Bind to the new port */\n    if (listenToPort(port, &new_sfd) != C_OK) {\n        return C_ERR;\n    }\n\n    /* Create event handlers */\n    if (createSocketAcceptHandler(&new_sfd, accept_handler) != C_OK) {\n        closeSocketListeners(&new_sfd);\n        return C_ERR;\n    }\n\n    /* Close old servers */\n    closeSocketListeners(sfd);\n\n    /* Copy new descriptors */\n    sfd->count = new_sfd.count;\n    memcpy(sfd->fd, new_sfd.fd, sizeof(new_sfd.fd));\n\n    if (server.set_proc_title) redisSetProcTitle(NULL);\n\n    return C_OK;\n}\n\nstatic void sigShutdownHandler(int sig) {\n    char *msg;\n\n    switch (sig) {\n    case SIGINT:\n        msg = \"Received SIGINT scheduling shutdown...\";\n        break;\n    case SIGTERM:\n        msg = \"Received SIGTERM scheduling shutdown...\";\n        break;\n    default:\n        msg = \"Received shutdown signal, scheduling shutdown...\";\n    };\n\n    /* SIGINT is often delivered via Ctrl+C in an interactive session.\n     * If we receive the signal the second time, we interpret this as\n     * the user really wanting to quit ASAP without waiting to persist\n     * on disk. */\n    if (server.shutdown_asap && sig == SIGINT) {\n        serverLogFromHandler(LL_WARNING, \"You insist... exiting now.\");\n        rdbRemoveTempFile(getpid(), 1);\n        exit(1); /* Exit with an error since this was not a clean shutdown. */\n    } else if (server.loading) {\n        serverLogFromHandler(LL_WARNING, \"Received shutdown signal during loading, exiting now.\");\n        exit(0);\n    }\n\n    serverLogFromHandler(LL_WARNING, msg);\n    server.shutdown_asap = 1;\n}\n\nvoid setupSignalHandlers(void) {\n    struct sigaction act;\n\n    /* When the SA_SIGINFO flag is set in sa_flags then sa_sigaction is used.\n     * Otherwise, sa_handler is used. */\n    sigemptyset(&act.sa_mask);\n    act.sa_flags = 0;\n    act.sa_handler = sigShutdownHandler;\n    sigaction(SIGTERM, &act, NULL);\n    sigaction(SIGINT, &act, NULL);\n\n    sigemptyset(&act.sa_mask);\n    act.sa_flags = SA_NODEFER | SA_RESETHAND | SA_SIGINFO;\n    act.sa_sigaction = sigsegvHandler;\n    if(server.crashlog_enabled) {\n        sigaction(SIGSEGV, &act, NULL);\n        sigaction(SIGBUS, &act, NULL);\n        sigaction(SIGFPE, &act, NULL);\n        sigaction(SIGILL, &act, NULL);\n        sigaction(SIGABRT, &act, NULL);\n    }\n    return;\n}\n\nvoid removeSignalHandlers(void) {\n    struct sigaction act;\n    sigemptyset(&act.sa_mask);\n    act.sa_flags = SA_NODEFER | SA_RESETHAND;\n    act.sa_handler = SIG_DFL;\n    sigaction(SIGSEGV, &act, NULL);\n    sigaction(SIGBUS, &act, NULL);\n    sigaction(SIGFPE, &act, NULL);\n    sigaction(SIGILL, &act, NULL);\n    sigaction(SIGABRT, &act, NULL);\n}\n\n/* This is the signal handler for children process. It is currently useful\n * in order to track the SIGUSR1, that we send to a child in order to terminate\n * it in a clean way, without the parent detecting an error and stop\n * accepting writes because of a write error condition. */\nstatic void sigKillChildHandler(int sig) {\n    UNUSED(sig);\n    int level = server.in_fork_child == CHILD_TYPE_MODULE? LL_VERBOSE: LL_WARNING;\n    serverLogFromHandler(level, \"Received SIGUSR1 in child, exiting now.\");\n    exitFromChild(SERVER_CHILD_NOERROR_RETVAL);\n}\n\nvoid setupChildSignalHandlers(void) {\n    struct sigaction act;\n\n    /* When the SA_SIGINFO flag is set in sa_flags then sa_sigaction is used.\n     * Otherwise, sa_handler is used. */\n    sigemptyset(&act.sa_mask);\n    act.sa_flags = 0;\n    act.sa_handler = sigKillChildHandler;\n    sigaction(SIGUSR1, &act, NULL);\n    return;\n}\n\n/* After fork, the child process will inherit the resources\n * of the parent process, e.g. fd(socket or flock) etc.\n * should close the resources not used by the child process, so that if the\n * parent restarts it can bind/lock despite the child possibly still running. */\nvoid closeChildUnusedResourceAfterFork() {\n    closeListeningSockets(0);\n    if (server.cluster_enabled && server.cluster_config_file_lock_fd != -1)\n        close(server.cluster_config_file_lock_fd);  /* don't care if this fails */\n\n    /* Clear server.pidfile, this is the parent pidfile which should not\n     * be touched (or deleted) by the child (on exit / crash) */\n    zfree(server.pidfile);\n    server.pidfile = NULL;\n}\n\n/* purpose is one of CHILD_TYPE_ types */\nint redisFork(int purpose) {\n    if (isMutuallyExclusiveChildType(purpose)) {\n        if (hasActiveChildProcess())\n            return -1;\n\n        openChildInfoPipe();\n    }\n\n    int childpid;\n    long long start = ustime();\n    if ((childpid = fork()) == 0) {\n        /* Child */\n        server.in_fork_child = purpose;\n        setOOMScoreAdj(CONFIG_OOM_BGCHILD);\n        setupChildSignalHandlers();\n        closeChildUnusedResourceAfterFork();\n    } else {\n        /* Parent */\n        server.stat_total_forks++;\n        server.stat_fork_time = ustime()-start;\n        server.stat_fork_rate = (double) zmalloc_used_memory() * 1000000 / server.stat_fork_time / (1024*1024*1024); /* GB per second. */\n        latencyAddSampleIfNeeded(\"fork\",server.stat_fork_time/1000);\n        if (childpid == -1) {\n            if (isMutuallyExclusiveChildType(purpose)) closeChildInfoPipe();\n            return -1;\n        }\n\n        /* The child_pid and child_type are only for mutual exclusive children.\n         * other child types should handle and store their pid's in dedicated variables.\n         *\n         * Today, we allows CHILD_TYPE_LDB to run in parallel with the other fork types:\n         * - it isn't used for production, so it will not make the server be less efficient\n         * - used for debugging, and we don't want to block it from running while other\n         *   forks are running (like RDB and AOF) */\n        if (isMutuallyExclusiveChildType(purpose)) {\n            server.child_pid = childpid;\n            server.child_type = purpose;\n            server.stat_current_cow_bytes = 0;\n            server.stat_current_cow_updated = 0;\n            server.stat_current_save_keys_processed = 0;\n            server.stat_module_progress = 0;\n            server.stat_current_save_keys_total = dbTotalServerKeyCount();\n        }\n\n        updateDictResizePolicy();\n        moduleFireServerEvent(REDISMODULE_EVENT_FORK_CHILD,\n                              REDISMODULE_SUBEVENT_FORK_CHILD_BORN,\n                              NULL);\n    }\n    return childpid;\n}\n\nvoid sendChildCowInfo(childInfoType info_type, char *pname) {\n    sendChildInfoGeneric(info_type, 0, -1, pname);\n}\n\nvoid sendChildInfo(childInfoType info_type, size_t keys, char *pname) {\n    sendChildInfoGeneric(info_type, keys, -1, pname);\n}\n\nvoid memtest(size_t megabytes, int passes);\n\n/* Returns 1 if there is --sentinel among the arguments or if\n * argv[0] contains \"redis-sentinel\". */\nint checkForSentinelMode(int argc, char **argv) {\n    int j;\n\n    if (strstr(argv[0],\"redis-sentinel\") != NULL) return 1;\n    for (j = 1; j < argc; j++)\n        if (!strcmp(argv[j],\"--sentinel\")) return 1;\n    return 0;\n}\n\n/* Function called at startup to load RDB or AOF file in memory. */\nvoid loadDataFromDisk(void) {\n    long long start = ustime();\n    if (server.aof_state == AOF_ON) {\n        if (loadAppendOnlyFile(server.aof_filename) == C_OK)\n            serverLog(LL_NOTICE,\"DB loaded from append only file: %.3f seconds\",(float)(ustime()-start)/1000000);\n    } else {\n        rdbSaveInfo rsi = RDB_SAVE_INFO_INIT;\n        errno = 0; /* Prevent a stale value from affecting error checking */\n        if (rdbLoad(server.rdb_filename,&rsi,RDBFLAGS_NONE) == C_OK) {\n            serverLog(LL_NOTICE,\"DB loaded from disk: %.3f seconds\",\n                (float)(ustime()-start)/1000000);\n\n            /* Restore the replication ID / offset from the RDB file. */\n            if ((server.masterhost ||\n                (server.cluster_enabled &&\n                nodeIsSlave(server.cluster->myself))) &&\n                rsi.repl_id_is_set &&\n                rsi.repl_offset != -1 &&\n                /* Note that older implementations may save a repl_stream_db\n                 * of -1 inside the RDB file in a wrong way, see more\n                 * information in function rdbPopulateSaveInfo. */\n                rsi.repl_stream_db != -1)\n            {\n                memcpy(server.replid,rsi.repl_id,sizeof(server.replid));\n                server.master_repl_offset = rsi.repl_offset;\n                /* If we are a slave, create a cached master from this\n                 * information, in order to allow partial resynchronizations\n                 * with masters. */\n                replicationCacheMasterUsingMyself();\n                selectDb(server.cached_master,rsi.repl_stream_db);\n            }\n        } else if (errno != ENOENT) {\n            serverLog(LL_WARNING,\"Fatal error loading the DB: %s. Exiting.\",strerror(errno));\n            exit(1);\n        }\n    }\n}\n\nvoid redisOutOfMemoryHandler(size_t allocation_size) {\n    serverLog(LL_WARNING,\"Out Of Memory allocating %zu bytes!\",\n        allocation_size);\n    serverPanic(\"Redis aborting for OUT OF MEMORY. Allocating %zu bytes!\",\n        allocation_size);\n}\n\n/* Callback for sdstemplate on proc-title-template. See redis.conf for\n * supported variables.\n */\nstatic sds redisProcTitleGetVariable(const sds varname, void *arg)\n{\n    if (!strcmp(varname, \"title\")) {\n        return sdsnew(arg);\n    } else if (!strcmp(varname, \"listen-addr\")) {\n        if (server.port || server.tls_port)\n            return sdscatprintf(sdsempty(), \"%s:%u\",\n                                server.bindaddr_count ? server.bindaddr[0] : \"*\",\n                                server.port ? server.port : server.tls_port);\n        else\n            return sdscatprintf(sdsempty(), \"unixsocket:%s\", server.unixsocket);\n    } else if (!strcmp(varname, \"server-mode\")) {\n        if (server.cluster_enabled) return sdsnew(\"[cluster]\");\n        else if (server.sentinel_mode) return sdsnew(\"[sentinel]\");\n        else return sdsempty();\n    } else if (!strcmp(varname, \"config-file\")) {\n        return sdsnew(server.configfile ? server.configfile : \"-\");\n    } else if (!strcmp(varname, \"port\")) {\n        return sdscatprintf(sdsempty(), \"%u\", server.port);\n    } else if (!strcmp(varname, \"tls-port\")) {\n        return sdscatprintf(sdsempty(), \"%u\", server.tls_port);\n    } else if (!strcmp(varname, \"unixsocket\")) {\n        return sdsnew(server.unixsocket);\n    } else\n        return NULL;    /* Unknown variable name */\n}\n\n/* Expand the specified proc-title-template string and return a newly\n * allocated sds, or NULL. */\nstatic sds expandProcTitleTemplate(const char *template, const char *title) {\n    sds res = sdstemplate(template, redisProcTitleGetVariable, (void *) title);\n    if (!res)\n        return NULL;\n    return sdstrim(res, \" \");\n}\n/* Validate the specified template, returns 1 if valid or 0 otherwise. */\nint validateProcTitleTemplate(const char *template) {\n    int ok = 1;\n    sds res = expandProcTitleTemplate(template, \"\");\n    if (!res)\n        return 0;\n    if (sdslen(res) == 0) ok = 0;\n    sdsfree(res);\n    return ok;\n}\n\nint redisSetProcTitle(char *title) {\n#ifdef USE_SETPROCTITLE\n    if (!title) title = server.exec_argv[0];\n    sds proc_title = expandProcTitleTemplate(server.proc_title_template, title);\n    if (!proc_title) return C_ERR;  /* Not likely, proc_title_template is validated */\n\n    setproctitle(\"%s\", proc_title);\n    sdsfree(proc_title);\n#else\n    UNUSED(title);\n#endif\n\n    return C_OK;\n}\n\nvoid redisSetCpuAffinity(const char *cpulist) {\n#ifdef USE_SETCPUAFFINITY\n    setcpuaffinity(cpulist);\n#else\n    UNUSED(cpulist);\n#endif\n}\n\n/* Send a notify message to systemd. Returns sd_notify return code which is\n * a positive number on success. */\nint redisCommunicateSystemd(const char *sd_notify_msg) {\n#ifdef HAVE_LIBSYSTEMD\n    int ret = sd_notify(0, sd_notify_msg);\n\n    if (ret == 0)\n        serverLog(LL_WARNING, \"systemd supervision error: NOTIFY_SOCKET not found!\");\n    else if (ret < 0)\n        serverLog(LL_WARNING, \"systemd supervision error: sd_notify: %d\", ret);\n    return ret;\n#else\n    UNUSED(sd_notify_msg);\n    return 0;\n#endif\n}\n\n/* Attempt to set up upstart supervision. Returns 1 if successful. */\nstatic int redisSupervisedUpstart(void) {\n    const char *upstart_job = getenv(\"UPSTART_JOB\");\n\n    if (!upstart_job) {\n        serverLog(LL_WARNING,\n                \"upstart supervision requested, but UPSTART_JOB not found!\");\n        return 0;\n    }\n\n    serverLog(LL_NOTICE, \"supervised by upstart, will stop to signal readiness.\");\n    raise(SIGSTOP);\n    unsetenv(\"UPSTART_JOB\");\n    return 1;\n}\n\n/* Attempt to set up systemd supervision. Returns 1 if successful. */\nstatic int redisSupervisedSystemd(void) {\n#ifndef HAVE_LIBSYSTEMD\n    serverLog(LL_WARNING,\n            \"systemd supervision requested or auto-detected, but Redis is compiled without libsystemd support!\");\n    return 0;\n#else\n    if (redisCommunicateSystemd(\"STATUS=Redis is loading...\\n\") <= 0)\n        return 0;\n    serverLog(LL_NOTICE,\n        \"Supervised by systemd. Please make sure you set appropriate values for TimeoutStartSec and TimeoutStopSec in your service unit.\");\n    return 1;\n#endif\n}\n\nint redisIsSupervised(int mode) {\n    int ret = 0;\n\n    if (mode == SUPERVISED_AUTODETECT) {\n        if (getenv(\"UPSTART_JOB\")) {\n            serverLog(LL_VERBOSE, \"Upstart supervision detected.\");\n            mode = SUPERVISED_UPSTART;\n        } else if (getenv(\"NOTIFY_SOCKET\")) {\n            serverLog(LL_VERBOSE, \"Systemd supervision detected.\");\n            mode = SUPERVISED_SYSTEMD;\n        }\n    }\n\n    switch (mode) {\n        case SUPERVISED_UPSTART:\n            ret = redisSupervisedUpstart();\n            break;\n        case SUPERVISED_SYSTEMD:\n            ret = redisSupervisedSystemd();\n            break;\n        default:\n            break;\n    }\n\n    if (ret)\n        server.supervised_mode = mode;\n\n    return ret;\n}\n\nint iAmMaster(void) {\n    return ((!server.cluster_enabled && server.masterhost == NULL) ||\n            (server.cluster_enabled && nodeIsMaster(server.cluster->myself)));\n}\n\n#ifdef REDIS_TEST\ntypedef int redisTestProc(int argc, char **argv, int accurate);\nstruct redisTest {\n    char *name;\n    redisTestProc *proc;\n    int failed;\n} redisTests[] = {\n    {\"ziplist\", ziplistTest},\n    {\"quicklist\", quicklistTest},\n    {\"intset\", intsetTest},\n    {\"zipmap\", zipmapTest},\n    {\"sha1test\", sha1Test},\n    {\"util\", utilTest},\n    {\"endianconv\", endianconvTest},\n    {\"crc64\", crc64Test},\n    {\"zmalloc\", zmalloc_test},\n    {\"sds\", sdsTest},\n    {\"dict\", dictTest}\n};\nredisTestProc *getTestProcByName(const char *name) {\n    int numtests = sizeof(redisTests)/sizeof(struct redisTest);\n    for (int j = 0; j < numtests; j++) {\n        if (!strcasecmp(name,redisTests[j].name)) {\n            return redisTests[j].proc;\n        }\n    }\n    return NULL;\n}\n#endif\n\nint main(int argc, char **argv) {\n    struct timeval tv;\n    int j;\n    char config_from_stdin = 0;\n\n#ifdef REDIS_TEST\n    if (argc >= 3 && !strcasecmp(argv[1], \"test\")) {\n        int accurate = 0;\n        for (j = 3; j < argc; j++) {\n            if (!strcasecmp(argv[j], \"--accurate\")) {\n                accurate = 1;\n            }\n        }\n\n        if (!strcasecmp(argv[2], \"all\")) {\n            int numtests = sizeof(redisTests)/sizeof(struct redisTest);\n            for (j = 0; j < numtests; j++) {\n                redisTests[j].failed = (redisTests[j].proc(argc,argv,accurate) != 0);\n            }\n\n            /* Report tests result */\n            int failed_num = 0;\n            for (j = 0; j < numtests; j++) {\n                if (redisTests[j].failed) {\n                    failed_num++;\n                    printf(\"[failed] Test - %s\\n\", redisTests[j].name);\n                } else {\n                    printf(\"[ok] Test - %s\\n\", redisTests[j].name);\n                }\n            }\n\n            printf(\"%d tests, %d passed, %d failed\\n\", numtests,\n                   numtests-failed_num, failed_num);\n\n            return failed_num == 0 ? 0 : 1;\n        } else {\n            redisTestProc *proc = getTestProcByName(argv[2]);\n            if (!proc) return -1; /* test not found */\n            return proc(argc,argv,accurate);\n        }\n\n        return 0;\n    }\n#endif\n\n    /* We need to initialize our libraries, and the server configuration. */\n#ifdef INIT_SETPROCTITLE_REPLACEMENT\n    spt_init(argc, argv);\n#endif\n    setlocale(LC_COLLATE,\"\");\n    tzset(); /* Populates 'timezone' global. */\n    zmalloc_set_oom_handler(redisOutOfMemoryHandler);\n    srand(time(NULL)^getpid());\n    srandom(time(NULL)^getpid());\n    gettimeofday(&tv,NULL);\n    init_genrand64(((long long) tv.tv_sec * 1000000 + tv.tv_usec) ^ getpid());\n    crc64_init();\n\n    /* Store umask value. Because umask(2) only offers a set-and-get API we have\n     * to reset it and restore it back. We do this early to avoid a potential\n     * race condition with threads that could be creating files or directories.\n     */\n    umask(server.umask = umask(0777));\n\n    uint8_t hashseed[16];\n    getRandomBytes(hashseed,sizeof(hashseed));\n    dictSetHashFunctionSeed(hashseed);\n    server.sentinel_mode = checkForSentinelMode(argc,argv);\n    initServerConfig();\n    ACLInit(); /* The ACL subsystem must be initialized ASAP because the\n                  basic networking code and client creation depends on it. */\n    moduleInitModulesSystem();\n    tlsInit();\n\n    /* Store the executable path and arguments in a safe place in order\n     * to be able to restart the server later. */\n    server.executable = getAbsolutePath(argv[0]);\n    server.exec_argv = zmalloc(sizeof(char*)*(argc+1));\n    server.exec_argv[argc] = NULL;\n    for (j = 0; j < argc; j++) server.exec_argv[j] = zstrdup(argv[j]);\n\n    /* We need to init sentinel right now as parsing the configuration file\n     * in sentinel mode will have the effect of populating the sentinel\n     * data structures with master nodes to monitor. */\n    if (server.sentinel_mode) {\n        initSentinelConfig();\n        initSentinel();\n    }\n\n    /* Check if we need to start in redis-check-rdb/aof mode. We just execute\n     * the program main. However the program is part of the Redis executable\n     * so that we can easily execute an RDB check on loading errors. */\n    if (strstr(argv[0],\"redis-check-rdb\") != NULL)\n        redis_check_rdb_main(argc,argv,NULL);\n    else if (strstr(argv[0],\"redis-check-aof\") != NULL)\n        redis_check_aof_main(argc,argv);\n\n    if (argc >= 2) {\n        j = 1; /* First option to parse in argv[] */\n        sds options = sdsempty();\n\n        /* Handle special options --help and --version */\n        if (strcmp(argv[1], \"-v\") == 0 ||\n            strcmp(argv[1], \"--version\") == 0) version();\n        if (strcmp(argv[1], \"--help\") == 0 ||\n            strcmp(argv[1], \"-h\") == 0) usage();\n        if (strcmp(argv[1], \"--test-memory\") == 0) {\n            if (argc == 3) {\n                memtest(atoi(argv[2]),50);\n                exit(0);\n            } else {\n                fprintf(stderr,\"Please specify the amount of memory to test in megabytes.\\n\");\n                fprintf(stderr,\"Example: ./redis-server --test-memory 4096\\n\\n\");\n                exit(1);\n            }\n        }\n        /* Parse command line options\n         * Precedence wise, File, stdin, explicit options -- last config is the one that matters.\n         *\n         * First argument is the config file name? */\n        if (argv[1][0] != '-') {\n            /* Replace the config file in server.exec_argv with its absolute path. */\n            server.configfile = getAbsolutePath(argv[1]);\n            zfree(server.exec_argv[1]);\n            server.exec_argv[1] = zstrdup(server.configfile);\n            j = 2; // Skip this arg when parsing options\n        }\n        while(j < argc) {\n            /* Either first or last argument - Should we read config from stdin? */\n            if (argv[j][0] == '-' && argv[j][1] == '\\0' && (j == 1 || j == argc-1)) {\n                config_from_stdin = 1;\n            }\n            /* All the other options are parsed and conceptually appended to the\n             * configuration file. For instance --port 6380 will generate the\n             * string \"port 6380\\n\" to be parsed after the actual config file\n             * and stdin input are parsed (if they exist). */\n            else if (argv[j][0] == '-' && argv[j][1] == '-') {\n                /* Option name */\n                if (sdslen(options)) options = sdscat(options,\"\\n\");\n                options = sdscat(options,argv[j]+2);\n                options = sdscat(options,\" \");\n            } else {\n                /* Option argument */\n                options = sdscatrepr(options,argv[j],strlen(argv[j]));\n                options = sdscat(options,\" \");\n            }\n            j++;\n        }\n\n        loadServerConfig(server.configfile, config_from_stdin, options);\n        if (server.sentinel_mode) loadSentinelConfigFromQueue();\n        sdsfree(options);\n    }\n    if (server.sentinel_mode) sentinelCheckConfigFile();\n    server.supervised = redisIsSupervised(server.supervised_mode);\n    int background = server.daemonize && !server.supervised;\n    if (background) daemonize();\n\n    serverLog(LL_WARNING, \"oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo\");\n    serverLog(LL_WARNING,\n        \"Redis version=%s, bits=%d, commit=%s, modified=%d, pid=%d, just started\",\n            REDIS_VERSION,\n            (sizeof(long) == 8) ? 64 : 32,\n            redisGitSHA1(),\n            strtol(redisGitDirty(),NULL,10) > 0,\n            (int)getpid());\n\n    if (argc == 1) {\n        serverLog(LL_WARNING, \"Warning: no config file specified, using the default config. In order to specify a config file use %s /path/to/redis.conf\", argv[0]);\n    } else {\n        serverLog(LL_WARNING, \"Configuration loaded\");\n    }\n\n    readOOMScoreAdj();\n    initServer();\n    if (background || server.pidfile) createPidFile();\n    if (server.set_proc_title) redisSetProcTitle(NULL);\n    redisAsciiArt();\n    checkTcpBacklogSettings();\n\n    if (!server.sentinel_mode) {\n        /* Things not needed when running in Sentinel mode. */\n        serverLog(LL_WARNING,\"Server initialized\");\n    #ifdef __linux__\n        linuxMemoryWarnings();\n    #if defined (__arm64__)\n        int ret;\n        if ((ret = linuxMadvFreeForkBugCheck())) {\n            if (ret == 1)\n                serverLog(LL_WARNING,\"WARNING Your kernel has a bug that could lead to data corruption during background save. \"\n                                     \"Please upgrade to the latest stable kernel.\");\n            else\n                serverLog(LL_WARNING, \"Failed to test the kernel for a bug that could lead to data corruption during background save. \"\n                                      \"Your system could be affected, please report this error.\");\n            if (!checkIgnoreWarning(\"ARM64-COW-BUG\")) {\n                serverLog(LL_WARNING,\"Redis will now exit to prevent data corruption. \"\n                                     \"Note that it is possible to suppress this warning by setting the following config: ignore-warnings ARM64-COW-BUG\");\n                exit(1);\n            }\n        }\n    #endif /* __arm64__ */\n    #endif /* __linux__ */\n        moduleInitModulesSystemLast();\n        moduleLoadFromQueue();\n        ACLLoadUsersAtStartup();\n        InitServerLast();\n        loadDataFromDisk();\n        if (server.cluster_enabled) {\n            if (verifyClusterConfigWithData() == C_ERR) {\n                serverLog(LL_WARNING,\n                    \"You can't have keys in a DB different than DB 0 when in \"\n                    \"Cluster mode. Exiting.\");\n                exit(1);\n            }\n        }\n        if (server.ipfd.count > 0 || server.tlsfd.count > 0)\n            serverLog(LL_NOTICE,\"Ready to accept connections\");\n        if (server.sofd > 0)\n            serverLog(LL_NOTICE,\"The server is now ready to accept connections at %s\", server.unixsocket);\n        if (server.supervised_mode == SUPERVISED_SYSTEMD) {\n            if (!server.masterhost) {\n                redisCommunicateSystemd(\"STATUS=Ready to accept connections\\n\");\n            } else {\n                redisCommunicateSystemd(\"STATUS=Ready to accept connections in read-only mode. Waiting for MASTER <-> REPLICA sync\\n\");\n            }\n            redisCommunicateSystemd(\"READY=1\\n\");\n        }\n    } else {\n        ACLLoadUsersAtStartup();\n        InitServerLast();\n        sentinelIsRunning();\n        if (server.supervised_mode == SUPERVISED_SYSTEMD) {\n            redisCommunicateSystemd(\"STATUS=Ready to accept connections\\n\");\n            redisCommunicateSystemd(\"READY=1\\n\");\n        }\n    }\n\n    /* Warning the user about suspicious maxmemory setting. */\n    if (server.maxmemory > 0 && server.maxmemory < 1024*1024) {\n        serverLog(LL_WARNING,\"WARNING: You specified a maxmemory value that is less than 1MB (current value is %llu bytes). Are you sure this is what you really want?\", server.maxmemory);\n    }\n\n    redisSetCpuAffinity(server.server_cpulist);\n    setOOMScoreAdj(-1);\n\n    aeMain(server.el);\n    aeDeleteEventLoop(server.el);\n    return 0;\n}\n\n/* The End */\n"], "fixing_code": ["/*\n * Copyright (c) 2009-2016, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"server.h\"\n#include \"monotonic.h\"\n#include \"cluster.h\"\n#include \"slowlog.h\"\n#include \"bio.h\"\n#include \"latency.h\"\n#include \"atomicvar.h\"\n#include \"mt19937-64.h\"\n\n#include <time.h>\n#include <signal.h>\n#include <sys/wait.h>\n#include <errno.h>\n#include <assert.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <arpa/inet.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#include <sys/uio.h>\n#include <sys/un.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <sys/resource.h>\n#include <sys/utsname.h>\n#include <locale.h>\n#include <sys/socket.h>\n#include <sys/resource.h>\n\n#ifdef __linux__\n#include <sys/mman.h>\n#endif\n\n/* Our shared \"common\" objects */\n\nstruct sharedObjectsStruct shared;\n\n/* Global vars that are actually used as constants. The following double\n * values are used for double on-disk serialization, and are initialized\n * at runtime to avoid strange compiler optimizations. */\n\ndouble R_Zero, R_PosInf, R_NegInf, R_Nan;\n\n/*================================= Globals ================================= */\n\n/* Global vars */\nstruct redisServer server; /* Server global state */\n\n/* Our command table.\n *\n * Every entry is composed of the following fields:\n *\n * name:        A string representing the command name.\n *\n * function:    Pointer to the C function implementing the command.\n *\n * arity:       Number of arguments, it is possible to use -N to say >= N\n *\n * sflags:      Command flags as string. See below for a table of flags.\n *\n * flags:       Flags as bitmask. Computed by Redis using the 'sflags' field.\n *\n * get_keys_proc: An optional function to get key arguments from a command.\n *                This is only used when the following three fields are not\n *                enough to specify what arguments are keys.\n *\n * first_key_index: First argument that is a key\n *\n * last_key_index: Last argument that is a key\n *\n * key_step:    Step to get all the keys from first to last argument.\n *              For instance in MSET the step is two since arguments\n *              are key,val,key,val,...\n *\n * microseconds: Microseconds of total execution time for this command.\n *\n * calls:       Total number of calls of this command.\n *\n * id:          Command bit identifier for ACLs or other goals.\n *\n * The flags, microseconds and calls fields are computed by Redis and should\n * always be set to zero.\n *\n * Command flags are expressed using space separated strings, that are turned\n * into actual flags by the populateCommandTable() function.\n *\n * This is the meaning of the flags:\n *\n * write:       Write command (may modify the key space).\n *\n * read-only:   Commands just reading from keys without changing the content.\n *              Note that commands that don't read from the keyspace such as\n *              TIME, SELECT, INFO, administrative commands, and connection\n *              or transaction related commands (multi, exec, discard, ...)\n *              are not flagged as read-only commands, since they affect the\n *              server or the connection in other ways.\n *\n * use-memory:  May increase memory usage once called. Don't allow if out\n *              of memory.\n *\n * admin:       Administrative command, like SAVE or SHUTDOWN.\n *\n * pub-sub:     Pub/Sub related command.\n *\n * no-script:   Command not allowed in scripts.\n *\n * random:      Random command. Command is not deterministic, that is, the same\n *              command with the same arguments, with the same key space, may\n *              have different results. For instance SPOP and RANDOMKEY are\n *              two random commands.\n *\n * to-sort:     Sort command output array if called from script, so that the\n *              output is deterministic. When this flag is used (not always\n *              possible), then the \"random\" flag is not needed.\n *\n * ok-loading:  Allow the command while loading the database.\n *\n * ok-stale:    Allow the command while a slave has stale data but is not\n *              allowed to serve this data. Normally no command is accepted\n *              in this condition but just a few.\n *\n * no-monitor:  Do not automatically propagate the command on MONITOR.\n *\n * no-slowlog:  Do not automatically propagate the command to the slowlog.\n *\n * cluster-asking: Perform an implicit ASKING for this command, so the\n *              command will be accepted in cluster mode if the slot is marked\n *              as 'importing'.\n *\n * fast:        Fast command: O(1) or O(log(N)) command that should never\n *              delay its execution as long as the kernel scheduler is giving\n *              us time. Note that commands that may trigger a DEL as a side\n *              effect (like SET) are not fast commands.\n * \n * may-replicate: Command may produce replication traffic, but should be \n *                allowed under circumstances where write commands are disallowed. \n *                Examples include PUBLISH, which replicates pubsub messages,and \n *                EVAL, which may execute write commands, which are replicated, \n *                or may just execute read commands. A command can not be marked \n *                both \"write\" and \"may-replicate\"\n *\n * The following additional flags are only used in order to put commands\n * in a specific ACL category. Commands can have multiple ACL categories.\n *\n * @keyspace, @read, @write, @set, @sortedset, @list, @hash, @string, @bitmap,\n * @hyperloglog, @stream, @admin, @fast, @slow, @pubsub, @blocking, @dangerous,\n * @connection, @transaction, @scripting, @geo.\n *\n * Note that:\n *\n * 1) The read-only flag implies the @read ACL category.\n * 2) The write flag implies the @write ACL category.\n * 3) The fast flag implies the @fast ACL category.\n * 4) The admin flag implies the @admin and @dangerous ACL category.\n * 5) The pub-sub flag implies the @pubsub ACL category.\n * 6) The lack of fast flag implies the @slow ACL category.\n * 7) The non obvious \"keyspace\" category includes the commands\n *    that interact with keys without having anything to do with\n *    specific data structures, such as: DEL, RENAME, MOVE, SELECT,\n *    TYPE, EXPIRE*, PEXPIRE*, TTL, PTTL, ...\n */\n\nstruct redisCommand redisCommandTable[] = {\n    {\"module\",moduleCommand,-2,\n     \"admin no-script\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"get\",getCommand,2,\n     \"read-only fast @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"getex\",getexCommand,-2,\n     \"write fast @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"getdel\",getdelCommand,2,\n     \"write fast @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    /* Note that we can't flag set as fast, since it may perform an\n     * implicit DEL of a large key. */\n    {\"set\",setCommand,-3,\n     \"write use-memory @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"setnx\",setnxCommand,3,\n     \"write use-memory fast @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"setex\",setexCommand,4,\n     \"write use-memory @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"psetex\",psetexCommand,4,\n     \"write use-memory @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"append\",appendCommand,3,\n     \"write use-memory fast @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"strlen\",strlenCommand,2,\n     \"read-only fast @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"del\",delCommand,-2,\n     \"write @keyspace\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"unlink\",unlinkCommand,-2,\n     \"write fast @keyspace\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"exists\",existsCommand,-2,\n     \"read-only fast @keyspace\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"setbit\",setbitCommand,4,\n     \"write use-memory @bitmap\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"getbit\",getbitCommand,3,\n     \"read-only fast @bitmap\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"bitfield\",bitfieldCommand,-2,\n     \"write use-memory @bitmap\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"bitfield_ro\",bitfieldroCommand,-2,\n     \"read-only fast @bitmap\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"setrange\",setrangeCommand,4,\n     \"write use-memory @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"getrange\",getrangeCommand,4,\n     \"read-only @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"substr\",getrangeCommand,4,\n     \"read-only @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"incr\",incrCommand,2,\n     \"write use-memory fast @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"decr\",decrCommand,2,\n     \"write use-memory fast @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"mget\",mgetCommand,-2,\n     \"read-only fast @string\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"rpush\",rpushCommand,-3,\n     \"write use-memory fast @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"lpush\",lpushCommand,-3,\n     \"write use-memory fast @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"rpushx\",rpushxCommand,-3,\n     \"write use-memory fast @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"lpushx\",lpushxCommand,-3,\n     \"write use-memory fast @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"linsert\",linsertCommand,5,\n     \"write use-memory @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"rpop\",rpopCommand,-2,\n     \"write fast @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"lpop\",lpopCommand,-2,\n     \"write fast @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"brpop\",brpopCommand,-3,\n     \"write no-script @list @blocking\",\n     0,NULL,1,-2,1,0,0,0},\n\n    {\"brpoplpush\",brpoplpushCommand,4,\n     \"write use-memory no-script @list @blocking\",\n     0,NULL,1,2,1,0,0,0},\n\n    {\"blmove\",blmoveCommand,6,\n     \"write use-memory no-script @list @blocking\",\n     0,NULL,1,2,1,0,0,0},\n\n    {\"blpop\",blpopCommand,-3,\n     \"write no-script @list @blocking\",\n     0,NULL,1,-2,1,0,0,0},\n\n    {\"llen\",llenCommand,2,\n     \"read-only fast @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"lindex\",lindexCommand,3,\n     \"read-only @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"lset\",lsetCommand,4,\n     \"write use-memory @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"lrange\",lrangeCommand,4,\n     \"read-only @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"ltrim\",ltrimCommand,4,\n     \"write @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"lpos\",lposCommand,-3,\n     \"read-only @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"lrem\",lremCommand,4,\n     \"write @list\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"rpoplpush\",rpoplpushCommand,3,\n     \"write use-memory @list\",\n     0,NULL,1,2,1,0,0,0},\n\n    {\"lmove\",lmoveCommand,5,\n     \"write use-memory @list\",\n     0,NULL,1,2,1,0,0,0},\n\n    {\"sadd\",saddCommand,-3,\n     \"write use-memory fast @set\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"srem\",sremCommand,-3,\n     \"write fast @set\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"smove\",smoveCommand,4,\n     \"write fast @set\",\n     0,NULL,1,2,1,0,0,0},\n\n    {\"sismember\",sismemberCommand,3,\n     \"read-only fast @set\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"smismember\",smismemberCommand,-3,\n     \"read-only fast @set\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"scard\",scardCommand,2,\n     \"read-only fast @set\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"spop\",spopCommand,-2,\n     \"write random fast @set\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"srandmember\",srandmemberCommand,-2,\n     \"read-only random @set\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"sinter\",sinterCommand,-2,\n     \"read-only to-sort @set\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"sinterstore\",sinterstoreCommand,-3,\n     \"write use-memory @set\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"sunion\",sunionCommand,-2,\n     \"read-only to-sort @set\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"sunionstore\",sunionstoreCommand,-3,\n     \"write use-memory @set\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"sdiff\",sdiffCommand,-2,\n     \"read-only to-sort @set\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"sdiffstore\",sdiffstoreCommand,-3,\n     \"write use-memory @set\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"smembers\",sinterCommand,2,\n     \"read-only to-sort @set\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"sscan\",sscanCommand,-3,\n     \"read-only random @set\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zadd\",zaddCommand,-4,\n     \"write use-memory fast @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zincrby\",zincrbyCommand,4,\n     \"write use-memory fast @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zrem\",zremCommand,-3,\n     \"write fast @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zremrangebyscore\",zremrangebyscoreCommand,4,\n     \"write @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zremrangebyrank\",zremrangebyrankCommand,4,\n     \"write @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zremrangebylex\",zremrangebylexCommand,4,\n     \"write @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zunionstore\",zunionstoreCommand,-4,\n     \"write use-memory @sortedset\",\n     0,zunionInterDiffStoreGetKeys,1,1,1,0,0,0},\n\n    {\"zinterstore\",zinterstoreCommand,-4,\n     \"write use-memory @sortedset\",\n     0,zunionInterDiffStoreGetKeys,1,1,1,0,0,0},\n\n    {\"zdiffstore\",zdiffstoreCommand,-4,\n     \"write use-memory @sortedset\",\n     0,zunionInterDiffStoreGetKeys,1,1,1,0,0,0},\n\n    {\"zunion\",zunionCommand,-3,\n     \"read-only @sortedset\",\n     0,zunionInterDiffGetKeys,0,0,0,0,0,0},\n\n    {\"zinter\",zinterCommand,-3,\n     \"read-only @sortedset\",\n     0,zunionInterDiffGetKeys,0,0,0,0,0,0},\n\n    {\"zdiff\",zdiffCommand,-3,\n     \"read-only @sortedset\",\n     0,zunionInterDiffGetKeys,0,0,0,0,0,0},\n\n    {\"zrange\",zrangeCommand,-4,\n     \"read-only @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zrangestore\",zrangestoreCommand,-5,\n     \"write use-memory @sortedset\",\n     0,NULL,1,2,1,0,0,0},\n\n    {\"zrangebyscore\",zrangebyscoreCommand,-4,\n     \"read-only @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zrevrangebyscore\",zrevrangebyscoreCommand,-4,\n     \"read-only @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zrangebylex\",zrangebylexCommand,-4,\n     \"read-only @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zrevrangebylex\",zrevrangebylexCommand,-4,\n     \"read-only @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zcount\",zcountCommand,4,\n     \"read-only fast @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zlexcount\",zlexcountCommand,4,\n     \"read-only fast @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zrevrange\",zrevrangeCommand,-4,\n     \"read-only @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zcard\",zcardCommand,2,\n     \"read-only fast @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zscore\",zscoreCommand,3,\n     \"read-only fast @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zmscore\",zmscoreCommand,-3,\n     \"read-only fast @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zrank\",zrankCommand,3,\n     \"read-only fast @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zrevrank\",zrevrankCommand,3,\n     \"read-only fast @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zscan\",zscanCommand,-3,\n     \"read-only random @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zpopmin\",zpopminCommand,-2,\n     \"write fast @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"zpopmax\",zpopmaxCommand,-2,\n     \"write fast @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"bzpopmin\",bzpopminCommand,-3,\n     \"write no-script fast @sortedset @blocking\",\n     0,NULL,1,-2,1,0,0,0},\n\n    {\"bzpopmax\",bzpopmaxCommand,-3,\n     \"write no-script fast @sortedset @blocking\",\n     0,NULL,1,-2,1,0,0,0},\n\n    {\"zrandmember\",zrandmemberCommand,-2,\n     \"read-only random @sortedset\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hset\",hsetCommand,-4,\n     \"write use-memory fast @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hsetnx\",hsetnxCommand,4,\n     \"write use-memory fast @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hget\",hgetCommand,3,\n     \"read-only fast @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hmset\",hsetCommand,-4,\n     \"write use-memory fast @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hmget\",hmgetCommand,-3,\n     \"read-only fast @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hincrby\",hincrbyCommand,4,\n     \"write use-memory fast @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hincrbyfloat\",hincrbyfloatCommand,4,\n     \"write use-memory fast @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hdel\",hdelCommand,-3,\n     \"write fast @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hlen\",hlenCommand,2,\n     \"read-only fast @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hstrlen\",hstrlenCommand,3,\n     \"read-only fast @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hkeys\",hkeysCommand,2,\n     \"read-only to-sort @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hvals\",hvalsCommand,2,\n     \"read-only to-sort @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hgetall\",hgetallCommand,2,\n     \"read-only random @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hexists\",hexistsCommand,3,\n     \"read-only fast @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hrandfield\",hrandfieldCommand,-2,\n     \"read-only random @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"hscan\",hscanCommand,-3,\n     \"read-only random @hash\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"incrby\",incrbyCommand,3,\n     \"write use-memory fast @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"decrby\",decrbyCommand,3,\n     \"write use-memory fast @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"incrbyfloat\",incrbyfloatCommand,3,\n     \"write use-memory fast @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"getset\",getsetCommand,3,\n     \"write use-memory fast @string\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"mset\",msetCommand,-3,\n     \"write use-memory @string\",\n     0,NULL,1,-1,2,0,0,0},\n\n    {\"msetnx\",msetnxCommand,-3,\n     \"write use-memory @string\",\n     0,NULL,1,-1,2,0,0,0},\n\n    {\"randomkey\",randomkeyCommand,1,\n     \"read-only random @keyspace\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"select\",selectCommand,2,\n     \"ok-loading fast ok-stale @keyspace\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"swapdb\",swapdbCommand,3,\n     \"write fast @keyspace @dangerous\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"move\",moveCommand,3,\n     \"write fast @keyspace\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"copy\",copyCommand,-3,\n     \"write use-memory @keyspace\",\n     0,NULL,1,2,1,0,0,0},\n\n    /* Like for SET, we can't mark rename as a fast command because\n     * overwriting the target key may result in an implicit slow DEL. */\n    {\"rename\",renameCommand,3,\n     \"write @keyspace\",\n     0,NULL,1,2,1,0,0,0},\n\n    {\"renamenx\",renamenxCommand,3,\n     \"write fast @keyspace\",\n     0,NULL,1,2,1,0,0,0},\n\n    {\"expire\",expireCommand,3,\n     \"write fast @keyspace\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"expireat\",expireatCommand,3,\n     \"write fast @keyspace\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"pexpire\",pexpireCommand,3,\n     \"write fast @keyspace\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"pexpireat\",pexpireatCommand,3,\n     \"write fast @keyspace\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"keys\",keysCommand,2,\n     \"read-only to-sort @keyspace @dangerous\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"scan\",scanCommand,-2,\n     \"read-only random @keyspace\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"dbsize\",dbsizeCommand,1,\n     \"read-only fast @keyspace\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"auth\",authCommand,-2,\n     \"no-auth no-script ok-loading ok-stale fast no-monitor no-slowlog @connection\",\n     0,NULL,0,0,0,0,0,0},\n\n    /* We don't allow PING during loading since in Redis PING is used as\n     * failure detection, and a loading server is considered to be\n     * not available. */\n    {\"ping\",pingCommand,-1,\n     \"ok-stale fast @connection\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"echo\",echoCommand,2,\n     \"fast @connection\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"save\",saveCommand,1,\n     \"admin no-script\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"bgsave\",bgsaveCommand,-1,\n     \"admin no-script\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"bgrewriteaof\",bgrewriteaofCommand,1,\n     \"admin no-script\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"shutdown\",shutdownCommand,-1,\n     \"admin no-script ok-loading ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"lastsave\",lastsaveCommand,1,\n     \"random fast ok-loading ok-stale @admin @dangerous\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"type\",typeCommand,2,\n     \"read-only fast @keyspace\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"multi\",multiCommand,1,\n     \"no-script fast ok-loading ok-stale @transaction\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"exec\",execCommand,1,\n     \"no-script no-monitor no-slowlog ok-loading ok-stale @transaction\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"discard\",discardCommand,1,\n     \"no-script fast ok-loading ok-stale @transaction\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"sync\",syncCommand,1,\n     \"admin no-script\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"psync\",syncCommand,-3,\n     \"admin no-script\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"replconf\",replconfCommand,-1,\n     \"admin no-script ok-loading ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"flushdb\",flushdbCommand,-1,\n     \"write @keyspace @dangerous\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"flushall\",flushallCommand,-1,\n     \"write @keyspace @dangerous\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"sort\",sortCommand,-2,\n     \"write use-memory @list @set @sortedset @dangerous\",\n     0,sortGetKeys,1,1,1,0,0,0},\n\n    {\"info\",infoCommand,-1,\n     \"ok-loading ok-stale random @dangerous\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"monitor\",monitorCommand,1,\n     \"admin no-script ok-loading ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"ttl\",ttlCommand,2,\n     \"read-only fast random @keyspace\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"touch\",touchCommand,-2,\n     \"read-only fast @keyspace\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"pttl\",pttlCommand,2,\n     \"read-only fast random @keyspace\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"persist\",persistCommand,2,\n     \"write fast @keyspace\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"slaveof\",replicaofCommand,3,\n     \"admin no-script ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"replicaof\",replicaofCommand,3,\n     \"admin no-script ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"role\",roleCommand,1,\n     \"ok-loading ok-stale no-script fast @dangerous\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"debug\",debugCommand,-2,\n     \"admin no-script ok-loading ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"config\",configCommand,-2,\n     \"admin ok-loading ok-stale no-script\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"subscribe\",subscribeCommand,-2,\n     \"pub-sub no-script ok-loading ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"unsubscribe\",unsubscribeCommand,-1,\n     \"pub-sub no-script ok-loading ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"psubscribe\",psubscribeCommand,-2,\n     \"pub-sub no-script ok-loading ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"punsubscribe\",punsubscribeCommand,-1,\n     \"pub-sub no-script ok-loading ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"publish\",publishCommand,3,\n     \"pub-sub ok-loading ok-stale fast may-replicate\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"pubsub\",pubsubCommand,-2,\n     \"pub-sub ok-loading ok-stale random\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"watch\",watchCommand,-2,\n     \"no-script fast ok-loading ok-stale @transaction\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"unwatch\",unwatchCommand,1,\n     \"no-script fast ok-loading ok-stale @transaction\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"cluster\",clusterCommand,-2,\n     \"admin ok-stale random\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"restore\",restoreCommand,-4,\n     \"write use-memory @keyspace @dangerous\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"restore-asking\",restoreCommand,-4,\n    \"write use-memory cluster-asking @keyspace @dangerous\",\n    0,NULL,1,1,1,0,0,0},\n\n    {\"migrate\",migrateCommand,-6,\n     \"write random @keyspace @dangerous\",\n     0,migrateGetKeys,0,0,0,0,0,0},\n\n    {\"asking\",askingCommand,1,\n     \"fast @keyspace\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"readonly\",readonlyCommand,1,\n     \"fast @keyspace\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"readwrite\",readwriteCommand,1,\n     \"fast @keyspace\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"dump\",dumpCommand,2,\n     \"read-only random @keyspace\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"object\",objectCommand,-2,\n     \"read-only random @keyspace\",\n     0,NULL,2,2,1,0,0,0},\n\n    {\"memory\",memoryCommand,-2,\n     \"random read-only\",\n     0,memoryGetKeys,0,0,0,0,0,0},\n\n    {\"client\",clientCommand,-2,\n     \"admin no-script random ok-loading ok-stale @connection\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"hello\",helloCommand,-1,\n     \"no-auth no-script fast no-monitor ok-loading ok-stale @connection\",\n     0,NULL,0,0,0,0,0,0},\n\n    /* EVAL can modify the dataset, however it is not flagged as a write\n     * command since we do the check while running commands from Lua. */\n    {\"eval\",evalCommand,-3,\n     \"no-script may-replicate @scripting\",\n     0,evalGetKeys,0,0,0,0,0,0},\n\n    {\"evalsha\",evalShaCommand,-3,\n     \"no-script may-replicate @scripting\",\n     0,evalGetKeys,0,0,0,0,0,0},\n\n    {\"slowlog\",slowlogCommand,-2,\n     \"admin random ok-loading ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"script\",scriptCommand,-2,\n     \"no-script may-replicate @scripting\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"time\",timeCommand,1,\n     \"random fast ok-loading ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"bitop\",bitopCommand,-4,\n     \"write use-memory @bitmap\",\n     0,NULL,2,-1,1,0,0,0},\n\n    {\"bitcount\",bitcountCommand,-2,\n     \"read-only @bitmap\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"bitpos\",bitposCommand,-3,\n     \"read-only @bitmap\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"wait\",waitCommand,3,\n     \"no-script @keyspace\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"command\",commandCommand,-1,\n     \"ok-loading ok-stale random @connection\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"geoadd\",geoaddCommand,-5,\n     \"write use-memory @geo\",\n     0,NULL,1,1,1,0,0,0},\n\n    /* GEORADIUS has store options that may write. */\n    {\"georadius\",georadiusCommand,-6,\n     \"write use-memory @geo\",\n     0,georadiusGetKeys,1,1,1,0,0,0},\n\n    {\"georadius_ro\",georadiusroCommand,-6,\n     \"read-only @geo\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"georadiusbymember\",georadiusbymemberCommand,-5,\n     \"write use-memory @geo\",\n     0,georadiusGetKeys,1,1,1,0,0,0},\n\n    {\"georadiusbymember_ro\",georadiusbymemberroCommand,-5,\n     \"read-only @geo\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"geohash\",geohashCommand,-2,\n     \"read-only @geo\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"geopos\",geoposCommand,-2,\n     \"read-only @geo\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"geodist\",geodistCommand,-4,\n     \"read-only @geo\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"geosearch\",geosearchCommand,-7,\n     \"read-only @geo\",\n      0,NULL,1,1,1,0,0,0},\n\n    {\"geosearchstore\",geosearchstoreCommand,-8,\n     \"write use-memory @geo\",\n      0,NULL,1,2,1,0,0,0},\n\n    {\"pfselftest\",pfselftestCommand,1,\n     \"admin @hyperloglog\",\n      0,NULL,0,0,0,0,0,0},\n\n    {\"pfadd\",pfaddCommand,-2,\n     \"write use-memory fast @hyperloglog\",\n     0,NULL,1,1,1,0,0,0},\n\n    /* Technically speaking PFCOUNT may change the key since it changes the\n     * final bytes in the HyperLogLog representation. However in this case\n     * we claim that the representation, even if accessible, is an internal\n     * affair, and the command is semantically read only. */\n    {\"pfcount\",pfcountCommand,-2,\n     \"read-only may-replicate @hyperloglog\",\n     0,NULL,1,-1,1,0,0,0},\n\n    {\"pfmerge\",pfmergeCommand,-2,\n     \"write use-memory @hyperloglog\",\n     0,NULL,1,-1,1,0,0,0},\n\n    /* Unlike PFCOUNT that is considered as a read-only command (although\n     * it changes a bit), PFDEBUG may change the entire key when converting\n     * from sparse to dense representation */\n    {\"pfdebug\",pfdebugCommand,-3,\n     \"admin write use-memory @hyperloglog\",\n     0,NULL,2,2,1,0,0,0},\n\n    {\"xadd\",xaddCommand,-5,\n     \"write use-memory fast random @stream\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"xrange\",xrangeCommand,-4,\n     \"read-only @stream\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"xrevrange\",xrevrangeCommand,-4,\n     \"read-only @stream\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"xlen\",xlenCommand,2,\n     \"read-only fast @stream\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"xread\",xreadCommand,-4,\n     \"read-only @stream @blocking\",\n     0,xreadGetKeys,0,0,0,0,0,0},\n\n    {\"xreadgroup\",xreadCommand,-7,\n     \"write @stream @blocking\",\n     0,xreadGetKeys,0,0,0,0,0,0},\n\n    {\"xgroup\",xgroupCommand,-2,\n     \"write use-memory @stream\",\n     0,NULL,2,2,1,0,0,0},\n\n    {\"xsetid\",xsetidCommand,3,\n     \"write use-memory fast @stream\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"xack\",xackCommand,-4,\n     \"write fast random @stream\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"xpending\",xpendingCommand,-3,\n     \"read-only random @stream\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"xclaim\",xclaimCommand,-6,\n     \"write random fast @stream\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"xautoclaim\",xautoclaimCommand,-6,\n     \"write random fast @stream\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"xinfo\",xinfoCommand,-2,\n     \"read-only random @stream\",\n     0,NULL,2,2,1,0,0,0},\n\n    {\"xdel\",xdelCommand,-3,\n     \"write fast @stream\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"xtrim\",xtrimCommand,-4,\n     \"write random @stream\",\n     0,NULL,1,1,1,0,0,0},\n\n    {\"post\",securityWarningCommand,-1,\n     \"ok-loading ok-stale read-only\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"host:\",securityWarningCommand,-1,\n     \"ok-loading ok-stale read-only\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"latency\",latencyCommand,-2,\n     \"admin no-script ok-loading ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"lolwut\",lolwutCommand,-1,\n     \"read-only fast\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"acl\",aclCommand,-2,\n     \"admin no-script ok-loading ok-stale\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"stralgo\",stralgoCommand,-2,\n     \"read-only @string\",\n     0,lcsGetKeys,0,0,0,0,0,0},\n\n    {\"reset\",resetCommand,1,\n     \"no-script ok-stale ok-loading fast @connection\",\n     0,NULL,0,0,0,0,0,0},\n\n    {\"failover\",failoverCommand,-1,\n     \"admin no-script ok-stale\",\n     0,NULL,0,0,0,0,0,0}\n};\n\n/*============================ Utility functions ============================ */\n\n/* We use a private localtime implementation which is fork-safe. The logging\n * function of Redis may be called from other threads. */\nvoid nolocks_localtime(struct tm *tmp, time_t t, time_t tz, int dst);\n\n/* Low level logging. To use only for very big messages, otherwise\n * serverLog() is to prefer. */\nvoid serverLogRaw(int level, const char *msg) {\n    const int syslogLevelMap[] = { LOG_DEBUG, LOG_INFO, LOG_NOTICE, LOG_WARNING };\n    const char *c = \".-*#\";\n    FILE *fp;\n    char buf[64];\n    int rawmode = (level & LL_RAW);\n    int log_to_stdout = server.logfile[0] == '\\0';\n\n    level &= 0xff; /* clear flags */\n    if (level < server.verbosity) return;\n\n    fp = log_to_stdout ? stdout : fopen(server.logfile,\"a\");\n    if (!fp) return;\n\n    if (rawmode) {\n        fprintf(fp,\"%s\",msg);\n    } else {\n        int off;\n        struct timeval tv;\n        int role_char;\n        pid_t pid = getpid();\n\n        gettimeofday(&tv,NULL);\n        struct tm tm;\n        nolocks_localtime(&tm,tv.tv_sec,server.timezone,server.daylight_active);\n        off = strftime(buf,sizeof(buf),\"%d %b %Y %H:%M:%S.\",&tm);\n        snprintf(buf+off,sizeof(buf)-off,\"%03d\",(int)tv.tv_usec/1000);\n        if (server.sentinel_mode) {\n            role_char = 'X'; /* Sentinel. */\n        } else if (pid != server.pid) {\n            role_char = 'C'; /* RDB / AOF writing child. */\n        } else {\n            role_char = (server.masterhost ? 'S':'M'); /* Slave or Master. */\n        }\n        fprintf(fp,\"%d:%c %s %c %s\\n\",\n            (int)getpid(),role_char, buf,c[level],msg);\n    }\n    fflush(fp);\n\n    if (!log_to_stdout) fclose(fp);\n    if (server.syslog_enabled) syslog(syslogLevelMap[level], \"%s\", msg);\n}\n\n/* Like serverLogRaw() but with printf-alike support. This is the function that\n * is used across the code. The raw version is only used in order to dump\n * the INFO output on crash. */\nvoid _serverLog(int level, const char *fmt, ...) {\n    va_list ap;\n    char msg[LOG_MAX_LEN];\n\n    va_start(ap, fmt);\n    vsnprintf(msg, sizeof(msg), fmt, ap);\n    va_end(ap);\n\n    serverLogRaw(level,msg);\n}\n\n/* Log a fixed message without printf-alike capabilities, in a way that is\n * safe to call from a signal handler.\n *\n * We actually use this only for signals that are not fatal from the point\n * of view of Redis. Signals that are going to kill the server anyway and\n * where we need printf-alike features are served by serverLog(). */\nvoid serverLogFromHandler(int level, const char *msg) {\n    int fd;\n    int log_to_stdout = server.logfile[0] == '\\0';\n    char buf[64];\n\n    if ((level&0xff) < server.verbosity || (log_to_stdout && server.daemonize))\n        return;\n    fd = log_to_stdout ? STDOUT_FILENO :\n                         open(server.logfile, O_APPEND|O_CREAT|O_WRONLY, 0644);\n    if (fd == -1) return;\n    ll2string(buf,sizeof(buf),getpid());\n    if (write(fd,buf,strlen(buf)) == -1) goto err;\n    if (write(fd,\":signal-handler (\",17) == -1) goto err;\n    ll2string(buf,sizeof(buf),time(NULL));\n    if (write(fd,buf,strlen(buf)) == -1) goto err;\n    if (write(fd,\") \",2) == -1) goto err;\n    if (write(fd,msg,strlen(msg)) == -1) goto err;\n    if (write(fd,\"\\n\",1) == -1) goto err;\nerr:\n    if (!log_to_stdout) close(fd);\n}\n\n/* Return the UNIX time in microseconds */\nlong long ustime(void) {\n    struct timeval tv;\n    long long ust;\n\n    gettimeofday(&tv, NULL);\n    ust = ((long long)tv.tv_sec)*1000000;\n    ust += tv.tv_usec;\n    return ust;\n}\n\n/* Return the UNIX time in milliseconds */\nmstime_t mstime(void) {\n    return ustime()/1000;\n}\n\n/* After an RDB dump or AOF rewrite we exit from children using _exit() instead of\n * exit(), because the latter may interact with the same file objects used by\n * the parent process. However if we are testing the coverage normal exit() is\n * used in order to obtain the right coverage information. */\nvoid exitFromChild(int retcode) {\n#ifdef COVERAGE_TEST\n    exit(retcode);\n#else\n    _exit(retcode);\n#endif\n}\n\n/*====================== Hash table type implementation  ==================== */\n\n/* This is a hash table type that uses the SDS dynamic strings library as\n * keys and redis objects as values (objects can hold SDS strings,\n * lists, sets). */\n\nvoid dictVanillaFree(void *privdata, void *val)\n{\n    DICT_NOTUSED(privdata);\n    zfree(val);\n}\n\nvoid dictListDestructor(void *privdata, void *val)\n{\n    DICT_NOTUSED(privdata);\n    listRelease((list*)val);\n}\n\nint dictSdsKeyCompare(void *privdata, const void *key1,\n        const void *key2)\n{\n    int l1,l2;\n    DICT_NOTUSED(privdata);\n\n    l1 = sdslen((sds)key1);\n    l2 = sdslen((sds)key2);\n    if (l1 != l2) return 0;\n    return memcmp(key1, key2, l1) == 0;\n}\n\n/* A case insensitive version used for the command lookup table and other\n * places where case insensitive non binary-safe comparison is needed. */\nint dictSdsKeyCaseCompare(void *privdata, const void *key1,\n        const void *key2)\n{\n    DICT_NOTUSED(privdata);\n\n    return strcasecmp(key1, key2) == 0;\n}\n\nvoid dictObjectDestructor(void *privdata, void *val)\n{\n    DICT_NOTUSED(privdata);\n\n    if (val == NULL) return; /* Lazy freeing will set value to NULL. */\n    decrRefCount(val);\n}\n\nvoid dictSdsDestructor(void *privdata, void *val)\n{\n    DICT_NOTUSED(privdata);\n\n    sdsfree(val);\n}\n\nint dictObjKeyCompare(void *privdata, const void *key1,\n        const void *key2)\n{\n    const robj *o1 = key1, *o2 = key2;\n    return dictSdsKeyCompare(privdata,o1->ptr,o2->ptr);\n}\n\nuint64_t dictObjHash(const void *key) {\n    const robj *o = key;\n    return dictGenHashFunction(o->ptr, sdslen((sds)o->ptr));\n}\n\nuint64_t dictSdsHash(const void *key) {\n    return dictGenHashFunction((unsigned char*)key, sdslen((char*)key));\n}\n\nuint64_t dictSdsCaseHash(const void *key) {\n    return dictGenCaseHashFunction((unsigned char*)key, sdslen((char*)key));\n}\n\nint dictEncObjKeyCompare(void *privdata, const void *key1,\n        const void *key2)\n{\n    robj *o1 = (robj*) key1, *o2 = (robj*) key2;\n    int cmp;\n\n    if (o1->encoding == OBJ_ENCODING_INT &&\n        o2->encoding == OBJ_ENCODING_INT)\n            return o1->ptr == o2->ptr;\n\n    /* Due to OBJ_STATIC_REFCOUNT, we avoid calling getDecodedObject() without\n     * good reasons, because it would incrRefCount() the object, which\n     * is invalid. So we check to make sure dictFind() works with static\n     * objects as well. */\n    if (o1->refcount != OBJ_STATIC_REFCOUNT) o1 = getDecodedObject(o1);\n    if (o2->refcount != OBJ_STATIC_REFCOUNT) o2 = getDecodedObject(o2);\n    cmp = dictSdsKeyCompare(privdata,o1->ptr,o2->ptr);\n    if (o1->refcount != OBJ_STATIC_REFCOUNT) decrRefCount(o1);\n    if (o2->refcount != OBJ_STATIC_REFCOUNT) decrRefCount(o2);\n    return cmp;\n}\n\nuint64_t dictEncObjHash(const void *key) {\n    robj *o = (robj*) key;\n\n    if (sdsEncodedObject(o)) {\n        return dictGenHashFunction(o->ptr, sdslen((sds)o->ptr));\n    } else if (o->encoding == OBJ_ENCODING_INT) {\n        char buf[32];\n        int len;\n\n        len = ll2string(buf,32,(long)o->ptr);\n        return dictGenHashFunction((unsigned char*)buf, len);\n    } else {\n        serverPanic(\"Unknown string encoding\");\n    }\n}\n\n/* Return 1 if currently we allow dict to expand. Dict may allocate huge\n * memory to contain hash buckets when dict expands, that may lead redis\n * rejects user's requests or evicts some keys, we can stop dict to expand\n * provisionally if used memory will be over maxmemory after dict expands,\n * but to guarantee the performance of redis, we still allow dict to expand\n * if dict load factor exceeds HASHTABLE_MAX_LOAD_FACTOR. */\nint dictExpandAllowed(size_t moreMem, double usedRatio) {\n    if (usedRatio <= HASHTABLE_MAX_LOAD_FACTOR) {\n        return !overMaxmemoryAfterAlloc(moreMem);\n    } else {\n        return 1;\n    }\n}\n\n/* Generic hash table type where keys are Redis Objects, Values\n * dummy pointers. */\ndictType objectKeyPointerValueDictType = {\n    dictEncObjHash,            /* hash function */\n    NULL,                      /* key dup */\n    NULL,                      /* val dup */\n    dictEncObjKeyCompare,      /* key compare */\n    dictObjectDestructor,      /* key destructor */\n    NULL,                      /* val destructor */\n    NULL                       /* allow to expand */\n};\n\n/* Like objectKeyPointerValueDictType(), but values can be destroyed, if\n * not NULL, calling zfree(). */\ndictType objectKeyHeapPointerValueDictType = {\n    dictEncObjHash,            /* hash function */\n    NULL,                      /* key dup */\n    NULL,                      /* val dup */\n    dictEncObjKeyCompare,      /* key compare */\n    dictObjectDestructor,      /* key destructor */\n    dictVanillaFree,           /* val destructor */\n    NULL                       /* allow to expand */\n};\n\n/* Set dictionary type. Keys are SDS strings, values are not used. */\ndictType setDictType = {\n    dictSdsHash,               /* hash function */\n    NULL,                      /* key dup */\n    NULL,                      /* val dup */\n    dictSdsKeyCompare,         /* key compare */\n    dictSdsDestructor,         /* key destructor */\n    NULL                       /* val destructor */\n};\n\n/* Sorted sets hash (note: a skiplist is used in addition to the hash table) */\ndictType zsetDictType = {\n    dictSdsHash,               /* hash function */\n    NULL,                      /* key dup */\n    NULL,                      /* val dup */\n    dictSdsKeyCompare,         /* key compare */\n    NULL,                      /* Note: SDS string shared & freed by skiplist */\n    NULL,                      /* val destructor */\n    NULL                       /* allow to expand */\n};\n\n/* Db->dict, keys are sds strings, vals are Redis objects. */\ndictType dbDictType = {\n    dictSdsHash,                /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictSdsKeyCompare,          /* key compare */\n    dictSdsDestructor,          /* key destructor */\n    dictObjectDestructor,       /* val destructor */\n    dictExpandAllowed           /* allow to expand */\n};\n\n/* server.lua_scripts sha (as sds string) -> scripts (as robj) cache. */\ndictType shaScriptObjectDictType = {\n    dictSdsCaseHash,            /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictSdsKeyCaseCompare,      /* key compare */\n    dictSdsDestructor,          /* key destructor */\n    dictObjectDestructor,       /* val destructor */\n    NULL                        /* allow to expand */\n};\n\n/* Db->expires */\ndictType dbExpiresDictType = {\n    dictSdsHash,                /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictSdsKeyCompare,          /* key compare */\n    NULL,                       /* key destructor */\n    NULL,                       /* val destructor */\n    dictExpandAllowed           /* allow to expand */\n};\n\n/* Command table. sds string -> command struct pointer. */\ndictType commandTableDictType = {\n    dictSdsCaseHash,            /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictSdsKeyCaseCompare,      /* key compare */\n    dictSdsDestructor,          /* key destructor */\n    NULL,                       /* val destructor */\n    NULL                        /* allow to expand */\n};\n\n/* Hash type hash table (note that small hashes are represented with ziplists) */\ndictType hashDictType = {\n    dictSdsHash,                /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictSdsKeyCompare,          /* key compare */\n    dictSdsDestructor,          /* key destructor */\n    dictSdsDestructor,          /* val destructor */\n    NULL                        /* allow to expand */\n};\n\n/* Dict type without destructor */\ndictType sdsReplyDictType = {\n    dictSdsHash,                /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictSdsKeyCompare,          /* key compare */\n    NULL,                       /* key destructor */\n    NULL,                       /* val destructor */\n    NULL                        /* allow to expand */\n};\n\n/* Keylist hash table type has unencoded redis objects as keys and\n * lists as values. It's used for blocking operations (BLPOP) and to\n * map swapped keys to a list of clients waiting for this keys to be loaded. */\ndictType keylistDictType = {\n    dictObjHash,                /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictObjKeyCompare,          /* key compare */\n    dictObjectDestructor,       /* key destructor */\n    dictListDestructor,         /* val destructor */\n    NULL                        /* allow to expand */\n};\n\n/* Cluster nodes hash table, mapping nodes addresses 1.2.3.4:6379 to\n * clusterNode structures. */\ndictType clusterNodesDictType = {\n    dictSdsHash,                /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictSdsKeyCompare,          /* key compare */\n    dictSdsDestructor,          /* key destructor */\n    NULL,                       /* val destructor */\n    NULL                        /* allow to expand */\n};\n\n/* Cluster re-addition blacklist. This maps node IDs to the time\n * we can re-add this node. The goal is to avoid readding a removed\n * node for some time. */\ndictType clusterNodesBlackListDictType = {\n    dictSdsCaseHash,            /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictSdsKeyCaseCompare,      /* key compare */\n    dictSdsDestructor,          /* key destructor */\n    NULL,                       /* val destructor */\n    NULL                        /* allow to expand */\n};\n\n/* Modules system dictionary type. Keys are module name,\n * values are pointer to RedisModule struct. */\ndictType modulesDictType = {\n    dictSdsCaseHash,            /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictSdsKeyCaseCompare,      /* key compare */\n    dictSdsDestructor,          /* key destructor */\n    NULL,                       /* val destructor */\n    NULL                        /* allow to expand */\n};\n\n/* Migrate cache dict type. */\ndictType migrateCacheDictType = {\n    dictSdsHash,                /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictSdsKeyCompare,          /* key compare */\n    dictSdsDestructor,          /* key destructor */\n    NULL,                       /* val destructor */\n    NULL                        /* allow to expand */\n};\n\n/* Replication cached script dict (server.repl_scriptcache_dict).\n * Keys are sds SHA1 strings, while values are not used at all in the current\n * implementation. */\ndictType replScriptCacheDictType = {\n    dictSdsCaseHash,            /* hash function */\n    NULL,                       /* key dup */\n    NULL,                       /* val dup */\n    dictSdsKeyCaseCompare,      /* key compare */\n    dictSdsDestructor,          /* key destructor */\n    NULL,                       /* val destructor */\n    NULL                        /* allow to expand */\n};\n\nint htNeedsResize(dict *dict) {\n    long long size, used;\n\n    size = dictSlots(dict);\n    used = dictSize(dict);\n    return (size > DICT_HT_INITIAL_SIZE &&\n            (used*100/size < HASHTABLE_MIN_FILL));\n}\n\n/* If the percentage of used slots in the HT reaches HASHTABLE_MIN_FILL\n * we resize the hash table to save memory */\nvoid tryResizeHashTables(int dbid) {\n    if (htNeedsResize(server.db[dbid].dict))\n        dictResize(server.db[dbid].dict);\n    if (htNeedsResize(server.db[dbid].expires))\n        dictResize(server.db[dbid].expires);\n}\n\n/* Our hash table implementation performs rehashing incrementally while\n * we write/read from the hash table. Still if the server is idle, the hash\n * table will use two tables for a long time. So we try to use 1 millisecond\n * of CPU time at every call of this function to perform some rehashing.\n *\n * The function returns 1 if some rehashing was performed, otherwise 0\n * is returned. */\nint incrementallyRehash(int dbid) {\n    /* Keys dictionary */\n    if (dictIsRehashing(server.db[dbid].dict)) {\n        dictRehashMilliseconds(server.db[dbid].dict,1);\n        return 1; /* already used our millisecond for this loop... */\n    }\n    /* Expires */\n    if (dictIsRehashing(server.db[dbid].expires)) {\n        dictRehashMilliseconds(server.db[dbid].expires,1);\n        return 1; /* already used our millisecond for this loop... */\n    }\n    return 0;\n}\n\n/* This function is called once a background process of some kind terminates,\n * as we want to avoid resizing the hash tables when there is a child in order\n * to play well with copy-on-write (otherwise when a resize happens lots of\n * memory pages are copied). The goal of this function is to update the ability\n * for dict.c to resize the hash tables accordingly to the fact we have an\n * active fork child running. */\nvoid updateDictResizePolicy(void) {\n    if (!hasActiveChildProcess())\n        dictEnableResize();\n    else\n        dictDisableResize();\n}\n\nconst char *strChildType(int type) {\n    switch(type) {\n        case CHILD_TYPE_RDB: return \"RDB\";\n        case CHILD_TYPE_AOF: return \"AOF\";\n        case CHILD_TYPE_LDB: return \"LDB\";\n        case CHILD_TYPE_MODULE: return \"MODULE\";\n        default: return \"Unknown\";\n    }\n}\n\n/* Return true if there are active children processes doing RDB saving,\n * AOF rewriting, or some side process spawned by a loaded module. */\nint hasActiveChildProcess() {\n    return server.child_pid != -1;\n}\n\nvoid resetChildState() {\n    server.child_type = CHILD_TYPE_NONE;\n    server.child_pid = -1;\n    server.stat_current_cow_bytes = 0;\n    server.stat_current_cow_updated = 0;\n    server.stat_current_save_keys_processed = 0;\n    server.stat_module_progress = 0;\n    server.stat_current_save_keys_total = 0;\n    updateDictResizePolicy();\n    closeChildInfoPipe();\n    moduleFireServerEvent(REDISMODULE_EVENT_FORK_CHILD,\n                          REDISMODULE_SUBEVENT_FORK_CHILD_DIED,\n                          NULL);\n}\n\n/* Return if child type is mutual exclusive with other fork children */\nint isMutuallyExclusiveChildType(int type) {\n    return type == CHILD_TYPE_RDB || type == CHILD_TYPE_AOF || type == CHILD_TYPE_MODULE;\n}\n\n/* Return true if this instance has persistence completely turned off:\n * both RDB and AOF are disabled. */\nint allPersistenceDisabled(void) {\n    return server.saveparamslen == 0 && server.aof_state == AOF_OFF;\n}\n\n/* ======================= Cron: called every 100 ms ======================== */\n\n/* Add a sample to the operations per second array of samples. */\nvoid trackInstantaneousMetric(int metric, long long current_reading) {\n    long long now = mstime();\n    long long t = now - server.inst_metric[metric].last_sample_time;\n    long long ops = current_reading -\n                    server.inst_metric[metric].last_sample_count;\n    long long ops_sec;\n\n    ops_sec = t > 0 ? (ops*1000/t) : 0;\n\n    server.inst_metric[metric].samples[server.inst_metric[metric].idx] =\n        ops_sec;\n    server.inst_metric[metric].idx++;\n    server.inst_metric[metric].idx %= STATS_METRIC_SAMPLES;\n    server.inst_metric[metric].last_sample_time = now;\n    server.inst_metric[metric].last_sample_count = current_reading;\n}\n\n/* Return the mean of all the samples. */\nlong long getInstantaneousMetric(int metric) {\n    int j;\n    long long sum = 0;\n\n    for (j = 0; j < STATS_METRIC_SAMPLES; j++)\n        sum += server.inst_metric[metric].samples[j];\n    return sum / STATS_METRIC_SAMPLES;\n}\n\n/* The client query buffer is an sds.c string that can end with a lot of\n * free space not used, this function reclaims space if needed.\n *\n * The function always returns 0 as it never terminates the client. */\nint clientsCronResizeQueryBuffer(client *c) {\n    size_t querybuf_size = sdsAllocSize(c->querybuf);\n    time_t idletime = server.unixtime - c->lastinteraction;\n\n    /* There are two conditions to resize the query buffer:\n     * 1) Query buffer is > BIG_ARG and too big for latest peak.\n     * 2) Query buffer is > BIG_ARG and client is idle. */\n    if (querybuf_size > PROTO_MBULK_BIG_ARG &&\n         ((querybuf_size/(c->querybuf_peak+1)) > 2 ||\n          idletime > 2))\n    {\n        /* Only resize the query buffer if it is actually wasting\n         * at least a few kbytes. */\n        if (sdsavail(c->querybuf) > 1024*4) {\n            c->querybuf = sdsRemoveFreeSpace(c->querybuf);\n        }\n    }\n    /* Reset the peak again to capture the peak memory usage in the next\n     * cycle. */\n    c->querybuf_peak = 0;\n\n    /* Clients representing masters also use a \"pending query buffer\" that\n     * is the yet not applied part of the stream we are reading. Such buffer\n     * also needs resizing from time to time, otherwise after a very large\n     * transfer (a huge value or a big MIGRATE operation) it will keep using\n     * a lot of memory. */\n    if (c->flags & CLIENT_MASTER) {\n        /* There are two conditions to resize the pending query buffer:\n         * 1) Pending Query buffer is > LIMIT_PENDING_QUERYBUF.\n         * 2) Used length is smaller than pending_querybuf_size/2 */\n        size_t pending_querybuf_size = sdsAllocSize(c->pending_querybuf);\n        if(pending_querybuf_size > LIMIT_PENDING_QUERYBUF &&\n           sdslen(c->pending_querybuf) < (pending_querybuf_size/2))\n        {\n            c->pending_querybuf = sdsRemoveFreeSpace(c->pending_querybuf);\n        }\n    }\n    return 0;\n}\n\n/* This function is used in order to track clients using the biggest amount\n * of memory in the latest few seconds. This way we can provide such information\n * in the INFO output (clients section), without having to do an O(N) scan for\n * all the clients.\n *\n * This is how it works. We have an array of CLIENTS_PEAK_MEM_USAGE_SLOTS slots\n * where we track, for each, the biggest client output and input buffers we\n * saw in that slot. Every slot correspond to one of the latest seconds, since\n * the array is indexed by doing UNIXTIME % CLIENTS_PEAK_MEM_USAGE_SLOTS.\n *\n * When we want to know what was recently the peak memory usage, we just scan\n * such few slots searching for the maximum value. */\n#define CLIENTS_PEAK_MEM_USAGE_SLOTS 8\nsize_t ClientsPeakMemInput[CLIENTS_PEAK_MEM_USAGE_SLOTS] = {0};\nsize_t ClientsPeakMemOutput[CLIENTS_PEAK_MEM_USAGE_SLOTS] = {0};\n\nint clientsCronTrackExpansiveClients(client *c, int time_idx) {\n    size_t in_usage = sdsZmallocSize(c->querybuf) + c->argv_len_sum +\n\t              (c->argv ? zmalloc_size(c->argv) : 0);\n    size_t out_usage = getClientOutputBufferMemoryUsage(c);\n\n    /* Track the biggest values observed so far in this slot. */\n    if (in_usage > ClientsPeakMemInput[time_idx]) ClientsPeakMemInput[time_idx] = in_usage;\n    if (out_usage > ClientsPeakMemOutput[time_idx]) ClientsPeakMemOutput[time_idx] = out_usage;\n\n    return 0; /* This function never terminates the client. */\n}\n\n/* Iterating all the clients in getMemoryOverheadData() is too slow and\n * in turn would make the INFO command too slow. So we perform this\n * computation incrementally and track the (not instantaneous but updated\n * to the second) total memory used by clients using clinetsCron() in\n * a more incremental way (depending on server.hz). */\nint clientsCronTrackClientsMemUsage(client *c) {\n    size_t mem = 0;\n    int type = getClientType(c);\n    mem += getClientOutputBufferMemoryUsage(c);\n    mem += sdsZmallocSize(c->querybuf);\n    mem += zmalloc_size(c);\n    mem += c->argv_len_sum;\n    if (c->argv) mem += zmalloc_size(c->argv);\n    /* Now that we have the memory used by the client, remove the old\n     * value from the old category, and add it back. */\n    server.stat_clients_type_memory[c->client_cron_last_memory_type] -=\n        c->client_cron_last_memory_usage;\n    server.stat_clients_type_memory[type] += mem;\n    /* Remember what we added and where, to remove it next time. */\n    c->client_cron_last_memory_usage = mem;\n    c->client_cron_last_memory_type = type;\n    return 0;\n}\n\n/* Return the max samples in the memory usage of clients tracked by\n * the function clientsCronTrackExpansiveClients(). */\nvoid getExpansiveClientsInfo(size_t *in_usage, size_t *out_usage) {\n    size_t i = 0, o = 0;\n    for (int j = 0; j < CLIENTS_PEAK_MEM_USAGE_SLOTS; j++) {\n        if (ClientsPeakMemInput[j] > i) i = ClientsPeakMemInput[j];\n        if (ClientsPeakMemOutput[j] > o) o = ClientsPeakMemOutput[j];\n    }\n    *in_usage = i;\n    *out_usage = o;\n}\n\n/* This function is called by serverCron() and is used in order to perform\n * operations on clients that are important to perform constantly. For instance\n * we use this function in order to disconnect clients after a timeout, including\n * clients blocked in some blocking command with a non-zero timeout.\n *\n * The function makes some effort to process all the clients every second, even\n * if this cannot be strictly guaranteed, since serverCron() may be called with\n * an actual frequency lower than server.hz in case of latency events like slow\n * commands.\n *\n * It is very important for this function, and the functions it calls, to be\n * very fast: sometimes Redis has tens of hundreds of connected clients, and the\n * default server.hz value is 10, so sometimes here we need to process thousands\n * of clients per second, turning this function into a source of latency.\n */\n#define CLIENTS_CRON_MIN_ITERATIONS 5\nvoid clientsCron(void) {\n    /* Try to process at least numclients/server.hz of clients\n     * per call. Since normally (if there are no big latency events) this\n     * function is called server.hz times per second, in the average case we\n     * process all the clients in 1 second. */\n    int numclients = listLength(server.clients);\n    int iterations = numclients/server.hz;\n    mstime_t now = mstime();\n\n    /* Process at least a few clients while we are at it, even if we need\n     * to process less than CLIENTS_CRON_MIN_ITERATIONS to meet our contract\n     * of processing each client once per second. */\n    if (iterations < CLIENTS_CRON_MIN_ITERATIONS)\n        iterations = (numclients < CLIENTS_CRON_MIN_ITERATIONS) ?\n                     numclients : CLIENTS_CRON_MIN_ITERATIONS;\n\n\n    int curr_peak_mem_usage_slot = server.unixtime % CLIENTS_PEAK_MEM_USAGE_SLOTS;\n    /* Always zero the next sample, so that when we switch to that second, we'll\n     * only register samples that are greater in that second without considering\n     * the history of such slot.\n     *\n     * Note: our index may jump to any random position if serverCron() is not\n     * called for some reason with the normal frequency, for instance because\n     * some slow command is called taking multiple seconds to execute. In that\n     * case our array may end containing data which is potentially older\n     * than CLIENTS_PEAK_MEM_USAGE_SLOTS seconds: however this is not a problem\n     * since here we want just to track if \"recently\" there were very expansive\n     * clients from the POV of memory usage. */\n    int zeroidx = (curr_peak_mem_usage_slot+1) % CLIENTS_PEAK_MEM_USAGE_SLOTS;\n    ClientsPeakMemInput[zeroidx] = 0;\n    ClientsPeakMemOutput[zeroidx] = 0;\n\n\n    while(listLength(server.clients) && iterations--) {\n        client *c;\n        listNode *head;\n\n        /* Rotate the list, take the current head, process.\n         * This way if the client must be removed from the list it's the\n         * first element and we don't incur into O(N) computation. */\n        listRotateTailToHead(server.clients);\n        head = listFirst(server.clients);\n        c = listNodeValue(head);\n        /* The following functions do different service checks on the client.\n         * The protocol is that they return non-zero if the client was\n         * terminated. */\n        if (clientsCronHandleTimeout(c,now)) continue;\n        if (clientsCronResizeQueryBuffer(c)) continue;\n        if (clientsCronTrackExpansiveClients(c, curr_peak_mem_usage_slot)) continue;\n        if (clientsCronTrackClientsMemUsage(c)) continue;\n    }\n}\n\n/* This function handles 'background' operations we are required to do\n * incrementally in Redis databases, such as active key expiring, resizing,\n * rehashing. */\nvoid databasesCron(void) {\n    /* Expire keys by random sampling. Not required for slaves\n     * as master will synthesize DELs for us. */\n    if (server.active_expire_enabled) {\n        if (iAmMaster()) {\n            activeExpireCycle(ACTIVE_EXPIRE_CYCLE_SLOW);\n        } else {\n            expireSlaveKeys();\n        }\n    }\n\n    /* Defrag keys gradually. */\n    activeDefragCycle();\n\n    /* Perform hash tables rehashing if needed, but only if there are no\n     * other processes saving the DB on disk. Otherwise rehashing is bad\n     * as will cause a lot of copy-on-write of memory pages. */\n    if (!hasActiveChildProcess()) {\n        /* We use global counters so if we stop the computation at a given\n         * DB we'll be able to start from the successive in the next\n         * cron loop iteration. */\n        static unsigned int resize_db = 0;\n        static unsigned int rehash_db = 0;\n        int dbs_per_call = CRON_DBS_PER_CALL;\n        int j;\n\n        /* Don't test more DBs than we have. */\n        if (dbs_per_call > server.dbnum) dbs_per_call = server.dbnum;\n\n        /* Resize */\n        for (j = 0; j < dbs_per_call; j++) {\n            tryResizeHashTables(resize_db % server.dbnum);\n            resize_db++;\n        }\n\n        /* Rehash */\n        if (server.activerehashing) {\n            for (j = 0; j < dbs_per_call; j++) {\n                int work_done = incrementallyRehash(rehash_db);\n                if (work_done) {\n                    /* If the function did some work, stop here, we'll do\n                     * more at the next cron loop. */\n                    break;\n                } else {\n                    /* If this db didn't need rehash, we'll try the next one. */\n                    rehash_db++;\n                    rehash_db %= server.dbnum;\n                }\n            }\n        }\n    }\n}\n\n/* We take a cached value of the unix time in the global state because with\n * virtual memory and aging there is to store the current time in objects at\n * every object access, and accuracy is not needed. To access a global var is\n * a lot faster than calling time(NULL).\n *\n * This function should be fast because it is called at every command execution\n * in call(), so it is possible to decide if to update the daylight saving\n * info or not using the 'update_daylight_info' argument. Normally we update\n * such info only when calling this function from serverCron() but not when\n * calling it from call(). */\nvoid updateCachedTime(int update_daylight_info) {\n    server.ustime = ustime();\n    server.mstime = server.ustime / 1000;\n    time_t unixtime = server.mstime / 1000;\n    atomicSet(server.unixtime, unixtime);\n\n    /* To get information about daylight saving time, we need to call\n     * localtime_r and cache the result. However calling localtime_r in this\n     * context is safe since we will never fork() while here, in the main\n     * thread. The logging function will call a thread safe version of\n     * localtime that has no locks. */\n    if (update_daylight_info) {\n        struct tm tm;\n        time_t ut = server.unixtime;\n        localtime_r(&ut,&tm);\n        server.daylight_active = tm.tm_isdst;\n    }\n}\n\nvoid checkChildrenDone(void) {\n    int statloc = 0;\n    pid_t pid;\n\n    if ((pid = waitpid(-1, &statloc, WNOHANG)) != 0) {\n        int exitcode = WIFEXITED(statloc) ? WEXITSTATUS(statloc) : -1;\n        int bysignal = 0;\n\n        if (WIFSIGNALED(statloc)) bysignal = WTERMSIG(statloc);\n\n        /* sigKillChildHandler catches the signal and calls exit(), but we\n         * must make sure not to flag lastbgsave_status, etc incorrectly.\n         * We could directly terminate the child process via SIGUSR1\n         * without handling it */\n        if (exitcode == SERVER_CHILD_NOERROR_RETVAL) {\n            bysignal = SIGUSR1;\n            exitcode = 1;\n        }\n\n        if (pid == -1) {\n            serverLog(LL_WARNING,\"waitpid() returned an error: %s. \"\n                \"child_type: %s, child_pid = %d\",\n                strerror(errno),\n                strChildType(server.child_type),\n                (int) server.child_pid);\n        } else if (pid == server.child_pid) {\n            if (server.child_type == CHILD_TYPE_RDB) {\n                backgroundSaveDoneHandler(exitcode, bysignal);\n            } else if (server.child_type == CHILD_TYPE_AOF) {\n                backgroundRewriteDoneHandler(exitcode, bysignal);\n            } else if (server.child_type == CHILD_TYPE_MODULE) {\n                ModuleForkDoneHandler(exitcode, bysignal);\n            } else {\n                serverPanic(\"Unknown child type %d for child pid %d\", server.child_type, server.child_pid);\n                exit(1);\n            }\n            if (!bysignal && exitcode == 0) receiveChildInfo();\n            resetChildState();\n        } else {\n            if (!ldbRemoveChild(pid)) {\n                serverLog(LL_WARNING,\n                          \"Warning, detected child with unmatched pid: %ld\",\n                          (long) pid);\n            }\n        }\n\n        /* start any pending forks immediately. */\n        replicationStartPendingFork();\n    }\n}\n\n/* Called from serverCron and loadingCron to update cached memory metrics. */\nvoid cronUpdateMemoryStats() {\n    /* Record the max memory used since the server was started. */\n    if (zmalloc_used_memory() > server.stat_peak_memory)\n        server.stat_peak_memory = zmalloc_used_memory();\n\n    run_with_period(100) {\n        /* Sample the RSS and other metrics here since this is a relatively slow call.\n         * We must sample the zmalloc_used at the same time we take the rss, otherwise\n         * the frag ratio calculate may be off (ratio of two samples at different times) */\n        server.cron_malloc_stats.process_rss = zmalloc_get_rss();\n        server.cron_malloc_stats.zmalloc_used = zmalloc_used_memory();\n        /* Sampling the allocator info can be slow too.\n         * The fragmentation ratio it'll show is potentially more accurate\n         * it excludes other RSS pages such as: shared libraries, LUA and other non-zmalloc\n         * allocations, and allocator reserved pages that can be pursed (all not actual frag) */\n        zmalloc_get_allocator_info(&server.cron_malloc_stats.allocator_allocated,\n                                   &server.cron_malloc_stats.allocator_active,\n                                   &server.cron_malloc_stats.allocator_resident);\n        /* in case the allocator isn't providing these stats, fake them so that\n         * fragmentation info still shows some (inaccurate metrics) */\n        if (!server.cron_malloc_stats.allocator_resident) {\n            /* LUA memory isn't part of zmalloc_used, but it is part of the process RSS,\n             * so we must deduct it in order to be able to calculate correct\n             * \"allocator fragmentation\" ratio */\n            size_t lua_memory = lua_gc(server.lua,LUA_GCCOUNT,0)*1024LL;\n            server.cron_malloc_stats.allocator_resident = server.cron_malloc_stats.process_rss - lua_memory;\n        }\n        if (!server.cron_malloc_stats.allocator_active)\n            server.cron_malloc_stats.allocator_active = server.cron_malloc_stats.allocator_resident;\n        if (!server.cron_malloc_stats.allocator_allocated)\n            server.cron_malloc_stats.allocator_allocated = server.cron_malloc_stats.zmalloc_used;\n    }\n}\n\n/* This is our timer interrupt, called server.hz times per second.\n * Here is where we do a number of things that need to be done asynchronously.\n * For instance:\n *\n * - Active expired keys collection (it is also performed in a lazy way on\n *   lookup).\n * - Software watchdog.\n * - Update some statistic.\n * - Incremental rehashing of the DBs hash tables.\n * - Triggering BGSAVE / AOF rewrite, and handling of terminated children.\n * - Clients timeout of different kinds.\n * - Replication reconnection.\n * - Many more...\n *\n * Everything directly called here will be called server.hz times per second,\n * so in order to throttle execution of things we want to do less frequently\n * a macro is used: run_with_period(milliseconds) { .... }\n */\n\nint serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) {\n    int j;\n    UNUSED(eventLoop);\n    UNUSED(id);\n    UNUSED(clientData);\n\n    /* Software watchdog: deliver the SIGALRM that will reach the signal\n     * handler if we don't return here fast enough. */\n    if (server.watchdog_period) watchdogScheduleSignal(server.watchdog_period);\n\n    /* Update the time cache. */\n    updateCachedTime(1);\n\n    server.hz = server.config_hz;\n    /* Adapt the server.hz value to the number of configured clients. If we have\n     * many clients, we want to call serverCron() with an higher frequency. */\n    if (server.dynamic_hz) {\n        while (listLength(server.clients) / server.hz >\n               MAX_CLIENTS_PER_CLOCK_TICK)\n        {\n            server.hz *= 2;\n            if (server.hz > CONFIG_MAX_HZ) {\n                server.hz = CONFIG_MAX_HZ;\n                break;\n            }\n        }\n    }\n\n    run_with_period(100) {\n        long long stat_net_input_bytes, stat_net_output_bytes;\n        atomicGet(server.stat_net_input_bytes, stat_net_input_bytes);\n        atomicGet(server.stat_net_output_bytes, stat_net_output_bytes);\n\n        trackInstantaneousMetric(STATS_METRIC_COMMAND,server.stat_numcommands);\n        trackInstantaneousMetric(STATS_METRIC_NET_INPUT,\n                stat_net_input_bytes);\n        trackInstantaneousMetric(STATS_METRIC_NET_OUTPUT,\n                stat_net_output_bytes);\n    }\n\n    /* We have just LRU_BITS bits per object for LRU information.\n     * So we use an (eventually wrapping) LRU clock.\n     *\n     * Note that even if the counter wraps it's not a big problem,\n     * everything will still work but some object will appear younger\n     * to Redis. However for this to happen a given object should never be\n     * touched for all the time needed to the counter to wrap, which is\n     * not likely.\n     *\n     * Note that you can change the resolution altering the\n     * LRU_CLOCK_RESOLUTION define. */\n    unsigned int lruclock = getLRUClock();\n    atomicSet(server.lruclock,lruclock);\n\n    cronUpdateMemoryStats();\n\n    /* We received a SIGTERM, shutting down here in a safe way, as it is\n     * not ok doing so inside the signal handler. */\n    if (server.shutdown_asap) {\n        if (prepareForShutdown(SHUTDOWN_NOFLAGS) == C_OK) exit(0);\n        serverLog(LL_WARNING,\"SIGTERM received but errors trying to shut down the server, check the logs for more information\");\n        server.shutdown_asap = 0;\n    }\n\n    /* Show some info about non-empty databases */\n    if (server.verbosity <= LL_VERBOSE) {\n        run_with_period(5000) {\n            for (j = 0; j < server.dbnum; j++) {\n                long long size, used, vkeys;\n\n                size = dictSlots(server.db[j].dict);\n                used = dictSize(server.db[j].dict);\n                vkeys = dictSize(server.db[j].expires);\n                if (used || vkeys) {\n                    serverLog(LL_VERBOSE,\"DB %d: %lld keys (%lld volatile) in %lld slots HT.\",j,used,vkeys,size);\n                }\n            }\n        }\n    }\n\n    /* Show information about connected clients */\n    if (!server.sentinel_mode) {\n        run_with_period(5000) {\n            serverLog(LL_DEBUG,\n                \"%lu clients connected (%lu replicas), %zu bytes in use\",\n                listLength(server.clients)-listLength(server.slaves),\n                listLength(server.slaves),\n                zmalloc_used_memory());\n        }\n    }\n\n    /* We need to do a few operations on clients asynchronously. */\n    clientsCron();\n\n    /* Handle background operations on Redis databases. */\n    databasesCron();\n\n    /* Start a scheduled AOF rewrite if this was requested by the user while\n     * a BGSAVE was in progress. */\n    if (!hasActiveChildProcess() &&\n        server.aof_rewrite_scheduled)\n    {\n        rewriteAppendOnlyFileBackground();\n    }\n\n    /* Check if a background saving or AOF rewrite in progress terminated. */\n    if (hasActiveChildProcess() || ldbPendingChildren())\n    {\n        run_with_period(1000) receiveChildInfo();\n        checkChildrenDone();\n    } else {\n        /* If there is not a background saving/rewrite in progress check if\n         * we have to save/rewrite now. */\n        for (j = 0; j < server.saveparamslen; j++) {\n            struct saveparam *sp = server.saveparams+j;\n\n            /* Save if we reached the given amount of changes,\n             * the given amount of seconds, and if the latest bgsave was\n             * successful or if, in case of an error, at least\n             * CONFIG_BGSAVE_RETRY_DELAY seconds already elapsed. */\n            if (server.dirty >= sp->changes &&\n                server.unixtime-server.lastsave > sp->seconds &&\n                (server.unixtime-server.lastbgsave_try >\n                 CONFIG_BGSAVE_RETRY_DELAY ||\n                 server.lastbgsave_status == C_OK))\n            {\n                serverLog(LL_NOTICE,\"%d changes in %d seconds. Saving...\",\n                    sp->changes, (int)sp->seconds);\n                rdbSaveInfo rsi, *rsiptr;\n                rsiptr = rdbPopulateSaveInfo(&rsi);\n                rdbSaveBackground(server.rdb_filename,rsiptr);\n                break;\n            }\n        }\n\n        /* Trigger an AOF rewrite if needed. */\n        if (server.aof_state == AOF_ON &&\n            !hasActiveChildProcess() &&\n            server.aof_rewrite_perc &&\n            server.aof_current_size > server.aof_rewrite_min_size)\n        {\n            long long base = server.aof_rewrite_base_size ?\n                server.aof_rewrite_base_size : 1;\n            long long growth = (server.aof_current_size*100/base) - 100;\n            if (growth >= server.aof_rewrite_perc) {\n                serverLog(LL_NOTICE,\"Starting automatic rewriting of AOF on %lld%% growth\",growth);\n                rewriteAppendOnlyFileBackground();\n            }\n        }\n    }\n    /* Just for the sake of defensive programming, to avoid forgeting to\n     * call this function when need. */\n    updateDictResizePolicy();\n\n\n    /* AOF postponed flush: Try at every cron cycle if the slow fsync\n     * completed. */\n    if (server.aof_state == AOF_ON && server.aof_flush_postponed_start)\n        flushAppendOnlyFile(0);\n\n    /* AOF write errors: in this case we have a buffer to flush as well and\n     * clear the AOF error in case of success to make the DB writable again,\n     * however to try every second is enough in case of 'hz' is set to\n     * a higher frequency. */\n    run_with_period(1000) {\n        if (server.aof_state == AOF_ON && server.aof_last_write_status == C_ERR)\n            flushAppendOnlyFile(0);\n    }\n\n    /* Clear the paused clients state if needed. */\n    checkClientPauseTimeoutAndReturnIfPaused();\n\n    /* Replication cron function -- used to reconnect to master,\n     * detect transfer failures, start background RDB transfers and so forth. \n     * \n     * If Redis is trying to failover then run the replication cron faster so\n     * progress on the handshake happens more quickly. */\n    if (server.failover_state != NO_FAILOVER) {\n        run_with_period(100) replicationCron();\n    } else {\n        run_with_period(1000) replicationCron();\n    }\n\n    /* Run the Redis Cluster cron. */\n    run_with_period(100) {\n        if (server.cluster_enabled) clusterCron();\n    }\n\n    /* Run the Sentinel timer if we are in sentinel mode. */\n    if (server.sentinel_mode) sentinelTimer();\n\n    /* Cleanup expired MIGRATE cached sockets. */\n    run_with_period(1000) {\n        migrateCloseTimedoutSockets();\n    }\n\n    /* Stop the I/O threads if we don't have enough pending work. */\n    stopThreadedIOIfNeeded();\n\n    /* Resize tracking keys table if needed. This is also done at every\n     * command execution, but we want to be sure that if the last command\n     * executed changes the value via CONFIG SET, the server will perform\n     * the operation even if completely idle. */\n    if (server.tracking_clients) trackingLimitUsedSlots();\n\n    /* Start a scheduled BGSAVE if the corresponding flag is set. This is\n     * useful when we are forced to postpone a BGSAVE because an AOF\n     * rewrite is in progress.\n     *\n     * Note: this code must be after the replicationCron() call above so\n     * make sure when refactoring this file to keep this order. This is useful\n     * because we want to give priority to RDB savings for replication. */\n    if (!hasActiveChildProcess() &&\n        server.rdb_bgsave_scheduled &&\n        (server.unixtime-server.lastbgsave_try > CONFIG_BGSAVE_RETRY_DELAY ||\n         server.lastbgsave_status == C_OK))\n    {\n        rdbSaveInfo rsi, *rsiptr;\n        rsiptr = rdbPopulateSaveInfo(&rsi);\n        if (rdbSaveBackground(server.rdb_filename,rsiptr) == C_OK)\n            server.rdb_bgsave_scheduled = 0;\n    }\n\n    /* Fire the cron loop modules event. */\n    RedisModuleCronLoopV1 ei = {REDISMODULE_CRON_LOOP_VERSION,server.hz};\n    moduleFireServerEvent(REDISMODULE_EVENT_CRON_LOOP,\n                          0,\n                          &ei);\n\n    server.cronloops++;\n    return 1000/server.hz;\n}\n\n\nvoid blockingOperationStarts() {\n    if(!server.blocking_op_nesting++){\n        updateCachedTime(0);\n        server.blocked_last_cron = server.mstime;\n    }\n}\n\nvoid blockingOperationEnds() {\n    if(!(--server.blocking_op_nesting)){\n        server.blocked_last_cron = 0;\n    }\n}\n\n/* This function fill in the role of serverCron during RDB or AOF loading, and\n * also during blocked scripts.\n * It attempts to do its duties at a similar rate as the configured server.hz,\n * and updates cronloops variable so that similarly to serverCron, the\n * run_with_period can be used. */\nvoid whileBlockedCron() {\n    /* Here we may want to perform some cron jobs (normally done server.hz times\n     * per second). */\n\n    /* Since this function depends on a call to blockingOperationStarts, let's\n     * make sure it was done. */\n    serverAssert(server.blocked_last_cron);\n\n    /* In case we where called too soon, leave right away. This way one time\n     * jobs after the loop below don't need an if. and we don't bother to start\n     * latency monitor if this function is called too often. */\n    if (server.blocked_last_cron >= server.mstime)\n        return;\n\n    mstime_t latency;\n    latencyStartMonitor(latency);\n\n    /* In some cases we may be called with big intervals, so we may need to do\n     * extra work here. This is because some of the functions in serverCron rely\n     * on the fact that it is performed every 10 ms or so. For instance, if\n     * activeDefragCycle needs to utilize 25% cpu, it will utilize 2.5ms, so we\n     * need to call it multiple times. */\n    long hz_ms = 1000/server.hz;\n    while (server.blocked_last_cron < server.mstime) {\n\n        /* Defrag keys gradually. */\n        activeDefragCycle();\n\n        server.blocked_last_cron += hz_ms;\n\n        /* Increment cronloop so that run_with_period works. */\n        server.cronloops++;\n    }\n\n    /* Other cron jobs do not need to be done in a loop. No need to check\n     * server.blocked_last_cron since we have an early exit at the top. */\n\n    /* Update memory stats during loading (excluding blocked scripts) */\n    if (server.loading) cronUpdateMemoryStats();\n\n    latencyEndMonitor(latency);\n    latencyAddSampleIfNeeded(\"while-blocked-cron\",latency);\n}\n\nextern int ProcessingEventsWhileBlocked;\n\n/* This function gets called every time Redis is entering the\n * main loop of the event driven library, that is, before to sleep\n * for ready file descriptors.\n *\n * Note: This function is (currently) called from two functions:\n * 1. aeMain - The main server loop\n * 2. processEventsWhileBlocked - Process clients during RDB/AOF load\n *\n * If it was called from processEventsWhileBlocked we don't want\n * to perform all actions (For example, we don't want to expire\n * keys), but we do need to perform some actions.\n *\n * The most important is freeClientsInAsyncFreeQueue but we also\n * call some other low-risk functions. */\nvoid beforeSleep(struct aeEventLoop *eventLoop) {\n    UNUSED(eventLoop);\n\n    size_t zmalloc_used = zmalloc_used_memory();\n    if (zmalloc_used > server.stat_peak_memory)\n        server.stat_peak_memory = zmalloc_used;\n\n    /* Just call a subset of vital functions in case we are re-entering\n     * the event loop from processEventsWhileBlocked(). Note that in this\n     * case we keep track of the number of events we are processing, since\n     * processEventsWhileBlocked() wants to stop ASAP if there are no longer\n     * events to handle. */\n    if (ProcessingEventsWhileBlocked) {\n        uint64_t processed = 0;\n        processed += handleClientsWithPendingReadsUsingThreads();\n        processed += tlsProcessPendingData();\n        processed += handleClientsWithPendingWrites();\n        processed += freeClientsInAsyncFreeQueue();\n        server.events_processed_while_blocked += processed;\n        return;\n    }\n\n    /* Handle precise timeouts of blocked clients. */\n    handleBlockedClientsTimeout();\n\n    /* We should handle pending reads clients ASAP after event loop. */\n    handleClientsWithPendingReadsUsingThreads();\n\n    /* Handle TLS pending data. (must be done before flushAppendOnlyFile) */\n    tlsProcessPendingData();\n\n    /* If tls still has pending unread data don't sleep at all. */\n    aeSetDontWait(server.el, tlsHasPendingData());\n\n    /* Call the Redis Cluster before sleep function. Note that this function\n     * may change the state of Redis Cluster (from ok to fail or vice versa),\n     * so it's a good idea to call it before serving the unblocked clients\n     * later in this function. */\n    if (server.cluster_enabled) clusterBeforeSleep();\n\n    /* Run a fast expire cycle (the called function will return\n     * ASAP if a fast cycle is not needed). */\n    if (server.active_expire_enabled && server.masterhost == NULL)\n        activeExpireCycle(ACTIVE_EXPIRE_CYCLE_FAST);\n\n    /* Unblock all the clients blocked for synchronous replication\n     * in WAIT. */\n    if (listLength(server.clients_waiting_acks))\n        processClientsWaitingReplicas();\n\n    /* Check if there are clients unblocked by modules that implement\n     * blocking commands. */\n    if (moduleCount()) moduleHandleBlockedClients();\n\n    /* Try to process pending commands for clients that were just unblocked. */\n    if (listLength(server.unblocked_clients))\n        processUnblockedClients();\n\n    /* Send all the slaves an ACK request if at least one client blocked\n     * during the previous event loop iteration. Note that we do this after\n     * processUnblockedClients(), so if there are multiple pipelined WAITs\n     * and the just unblocked WAIT gets blocked again, we don't have to wait\n     * a server cron cycle in absence of other event loop events. See #6623.\n     * \n     * We also don't send the ACKs while clients are paused, since it can\n     * increment the replication backlog, they'll be sent after the pause\n     * if we are still the master. */\n    if (server.get_ack_from_slaves && !checkClientPauseTimeoutAndReturnIfPaused()) {\n        robj *argv[3];\n\n        argv[0] = shared.replconf;\n        argv[1] = shared.getack;\n        argv[2] = shared.special_asterick; /* Not used argument. */\n        replicationFeedSlaves(server.slaves, server.slaveseldb, argv, 3);\n        server.get_ack_from_slaves = 0;\n    }\n\n    /* We may have received updates from clients about their current offset. NOTE:\n     * this can't be done where the ACK is received since failover will disconnect \n     * our clients. */\n    updateFailoverStatus();\n\n    /* Send the invalidation messages to clients participating to the\n     * client side caching protocol in broadcasting (BCAST) mode. */\n    trackingBroadcastInvalidationMessages();\n\n    /* Write the AOF buffer on disk */\n    if (server.aof_state == AOF_ON)\n        flushAppendOnlyFile(0);\n\n    /* Handle writes with pending output buffers. */\n    handleClientsWithPendingWritesUsingThreads();\n\n    /* Close clients that need to be closed asynchronous */\n    freeClientsInAsyncFreeQueue();\n\n    /* Try to process blocked clients every once in while. Example: A module\n     * calls RM_SignalKeyAsReady from within a timer callback (So we don't\n     * visit processCommand() at all). */\n    handleClientsBlockedOnKeys();\n\n    /* Before we are going to sleep, let the threads access the dataset by\n     * releasing the GIL. Redis main thread will not touch anything at this\n     * time. */\n    if (moduleCount()) moduleReleaseGIL();\n\n    /* Do NOT add anything below moduleReleaseGIL !!! */\n}\n\n/* This function is called immediately after the event loop multiplexing\n * API returned, and the control is going to soon return to Redis by invoking\n * the different events callbacks. */\nvoid afterSleep(struct aeEventLoop *eventLoop) {\n    UNUSED(eventLoop);\n\n    /* Do NOT add anything above moduleAcquireGIL !!! */\n\n    /* Aquire the modules GIL so that their threads won't touch anything. */\n    if (!ProcessingEventsWhileBlocked) {\n        if (moduleCount()) moduleAcquireGIL();\n    }\n}\n\n/* =========================== Server initialization ======================== */\n\nvoid createSharedObjects(void) {\n    int j;\n\n    /* Shared command responses */\n    shared.crlf = createObject(OBJ_STRING,sdsnew(\"\\r\\n\"));\n    shared.ok = createObject(OBJ_STRING,sdsnew(\"+OK\\r\\n\"));\n    shared.emptybulk = createObject(OBJ_STRING,sdsnew(\"$0\\r\\n\\r\\n\"));\n    shared.czero = createObject(OBJ_STRING,sdsnew(\":0\\r\\n\"));\n    shared.cone = createObject(OBJ_STRING,sdsnew(\":1\\r\\n\"));\n    shared.emptyarray = createObject(OBJ_STRING,sdsnew(\"*0\\r\\n\"));\n    shared.pong = createObject(OBJ_STRING,sdsnew(\"+PONG\\r\\n\"));\n    shared.queued = createObject(OBJ_STRING,sdsnew(\"+QUEUED\\r\\n\"));\n    shared.emptyscan = createObject(OBJ_STRING,sdsnew(\"*2\\r\\n$1\\r\\n0\\r\\n*0\\r\\n\"));\n    shared.space = createObject(OBJ_STRING,sdsnew(\" \"));\n    shared.colon = createObject(OBJ_STRING,sdsnew(\":\"));\n    shared.plus = createObject(OBJ_STRING,sdsnew(\"+\"));\n\n    /* Shared command error responses */\n    shared.wrongtypeerr = createObject(OBJ_STRING,sdsnew(\n        \"-WRONGTYPE Operation against a key holding the wrong kind of value\\r\\n\"));\n    shared.err = createObject(OBJ_STRING,sdsnew(\"-ERR\\r\\n\"));\n    shared.nokeyerr = createObject(OBJ_STRING,sdsnew(\n        \"-ERR no such key\\r\\n\"));\n    shared.syntaxerr = createObject(OBJ_STRING,sdsnew(\n        \"-ERR syntax error\\r\\n\"));\n    shared.sameobjecterr = createObject(OBJ_STRING,sdsnew(\n        \"-ERR source and destination objects are the same\\r\\n\"));\n    shared.outofrangeerr = createObject(OBJ_STRING,sdsnew(\n        \"-ERR index out of range\\r\\n\"));\n    shared.noscripterr = createObject(OBJ_STRING,sdsnew(\n        \"-NOSCRIPT No matching script. Please use EVAL.\\r\\n\"));\n    shared.loadingerr = createObject(OBJ_STRING,sdsnew(\n        \"-LOADING Redis is loading the dataset in memory\\r\\n\"));\n    shared.slowscripterr = createObject(OBJ_STRING,sdsnew(\n        \"-BUSY Redis is busy running a script. You can only call SCRIPT KILL or SHUTDOWN NOSAVE.\\r\\n\"));\n    shared.masterdownerr = createObject(OBJ_STRING,sdsnew(\n        \"-MASTERDOWN Link with MASTER is down and replica-serve-stale-data is set to 'no'.\\r\\n\"));\n    shared.bgsaveerr = createObject(OBJ_STRING,sdsnew(\n        \"-MISCONF Redis is configured to save RDB snapshots, but it is currently not able to persist on disk. Commands that may modify the data set are disabled, because this instance is configured to report errors during writes if RDB snapshotting fails (stop-writes-on-bgsave-error option). Please check the Redis logs for details about the RDB error.\\r\\n\"));\n    shared.roslaveerr = createObject(OBJ_STRING,sdsnew(\n        \"-READONLY You can't write against a read only replica.\\r\\n\"));\n    shared.noautherr = createObject(OBJ_STRING,sdsnew(\n        \"-NOAUTH Authentication required.\\r\\n\"));\n    shared.oomerr = createObject(OBJ_STRING,sdsnew(\n        \"-OOM command not allowed when used memory > 'maxmemory'.\\r\\n\"));\n    shared.execaborterr = createObject(OBJ_STRING,sdsnew(\n        \"-EXECABORT Transaction discarded because of previous errors.\\r\\n\"));\n    shared.noreplicaserr = createObject(OBJ_STRING,sdsnew(\n        \"-NOREPLICAS Not enough good replicas to write.\\r\\n\"));\n    shared.busykeyerr = createObject(OBJ_STRING,sdsnew(\n        \"-BUSYKEY Target key name already exists.\\r\\n\"));\n\n    /* The shared NULL depends on the protocol version. */\n    shared.null[0] = NULL;\n    shared.null[1] = NULL;\n    shared.null[2] = createObject(OBJ_STRING,sdsnew(\"$-1\\r\\n\"));\n    shared.null[3] = createObject(OBJ_STRING,sdsnew(\"_\\r\\n\"));\n\n    shared.nullarray[0] = NULL;\n    shared.nullarray[1] = NULL;\n    shared.nullarray[2] = createObject(OBJ_STRING,sdsnew(\"*-1\\r\\n\"));\n    shared.nullarray[3] = createObject(OBJ_STRING,sdsnew(\"_\\r\\n\"));\n\n    shared.emptymap[0] = NULL;\n    shared.emptymap[1] = NULL;\n    shared.emptymap[2] = createObject(OBJ_STRING,sdsnew(\"*0\\r\\n\"));\n    shared.emptymap[3] = createObject(OBJ_STRING,sdsnew(\"%0\\r\\n\"));\n\n    shared.emptyset[0] = NULL;\n    shared.emptyset[1] = NULL;\n    shared.emptyset[2] = createObject(OBJ_STRING,sdsnew(\"*0\\r\\n\"));\n    shared.emptyset[3] = createObject(OBJ_STRING,sdsnew(\"~0\\r\\n\"));\n\n    for (j = 0; j < PROTO_SHARED_SELECT_CMDS; j++) {\n        char dictid_str[64];\n        int dictid_len;\n\n        dictid_len = ll2string(dictid_str,sizeof(dictid_str),j);\n        shared.select[j] = createObject(OBJ_STRING,\n            sdscatprintf(sdsempty(),\n                \"*2\\r\\n$6\\r\\nSELECT\\r\\n$%d\\r\\n%s\\r\\n\",\n                dictid_len, dictid_str));\n    }\n    shared.messagebulk = createStringObject(\"$7\\r\\nmessage\\r\\n\",13);\n    shared.pmessagebulk = createStringObject(\"$8\\r\\npmessage\\r\\n\",14);\n    shared.subscribebulk = createStringObject(\"$9\\r\\nsubscribe\\r\\n\",15);\n    shared.unsubscribebulk = createStringObject(\"$11\\r\\nunsubscribe\\r\\n\",18);\n    shared.psubscribebulk = createStringObject(\"$10\\r\\npsubscribe\\r\\n\",17);\n    shared.punsubscribebulk = createStringObject(\"$12\\r\\npunsubscribe\\r\\n\",19);\n\n    /* Shared command names */\n    shared.del = createStringObject(\"DEL\",3);\n    shared.unlink = createStringObject(\"UNLINK\",6);\n    shared.rpop = createStringObject(\"RPOP\",4);\n    shared.lpop = createStringObject(\"LPOP\",4);\n    shared.lpush = createStringObject(\"LPUSH\",5);\n    shared.rpoplpush = createStringObject(\"RPOPLPUSH\",9);\n    shared.lmove = createStringObject(\"LMOVE\",5);\n    shared.blmove = createStringObject(\"BLMOVE\",6);\n    shared.zpopmin = createStringObject(\"ZPOPMIN\",7);\n    shared.zpopmax = createStringObject(\"ZPOPMAX\",7);\n    shared.multi = createStringObject(\"MULTI\",5);\n    shared.exec = createStringObject(\"EXEC\",4);\n    shared.hset = createStringObject(\"HSET\",4);\n    shared.srem = createStringObject(\"SREM\",4);\n    shared.xgroup = createStringObject(\"XGROUP\",6);\n    shared.xclaim = createStringObject(\"XCLAIM\",6);\n    shared.script = createStringObject(\"SCRIPT\",6);\n    shared.replconf = createStringObject(\"REPLCONF\",8);\n    shared.pexpireat = createStringObject(\"PEXPIREAT\",9);\n    shared.pexpire = createStringObject(\"PEXPIRE\",7);\n    shared.persist = createStringObject(\"PERSIST\",7);\n    shared.set = createStringObject(\"SET\",3);\n    shared.eval = createStringObject(\"EVAL\",4);\n\n    /* Shared command argument */\n    shared.left = createStringObject(\"left\",4);\n    shared.right = createStringObject(\"right\",5);\n    shared.pxat = createStringObject(\"PXAT\", 4);\n    shared.px = createStringObject(\"PX\",2);\n    shared.time = createStringObject(\"TIME\",4);\n    shared.retrycount = createStringObject(\"RETRYCOUNT\",10);\n    shared.force = createStringObject(\"FORCE\",5);\n    shared.justid = createStringObject(\"JUSTID\",6);\n    shared.lastid = createStringObject(\"LASTID\",6);\n    shared.default_username = createStringObject(\"default\",7);\n    shared.ping = createStringObject(\"ping\",4);\n    shared.setid = createStringObject(\"SETID\",5);\n    shared.keepttl = createStringObject(\"KEEPTTL\",7);\n    shared.load = createStringObject(\"LOAD\",4);\n    shared.createconsumer = createStringObject(\"CREATECONSUMER\",14);\n    shared.getack = createStringObject(\"GETACK\",6);\n    shared.special_asterick = createStringObject(\"*\",1);\n    shared.special_equals = createStringObject(\"=\",1);\n\n    for (j = 0; j < OBJ_SHARED_INTEGERS; j++) {\n        shared.integers[j] =\n            makeObjectShared(createObject(OBJ_STRING,(void*)(long)j));\n        shared.integers[j]->encoding = OBJ_ENCODING_INT;\n    }\n    for (j = 0; j < OBJ_SHARED_BULKHDR_LEN; j++) {\n        shared.mbulkhdr[j] = createObject(OBJ_STRING,\n            sdscatprintf(sdsempty(),\"*%d\\r\\n\",j));\n        shared.bulkhdr[j] = createObject(OBJ_STRING,\n            sdscatprintf(sdsempty(),\"$%d\\r\\n\",j));\n    }\n    /* The following two shared objects, minstring and maxstrings, are not\n     * actually used for their value but as a special object meaning\n     * respectively the minimum possible string and the maximum possible\n     * string in string comparisons for the ZRANGEBYLEX command. */\n    shared.minstring = sdsnew(\"minstring\");\n    shared.maxstring = sdsnew(\"maxstring\");\n}\n\nvoid initServerConfig(void) {\n    int j;\n\n    updateCachedTime(1);\n    getRandomHexChars(server.runid,CONFIG_RUN_ID_SIZE);\n    server.runid[CONFIG_RUN_ID_SIZE] = '\\0';\n    changeReplicationId();\n    clearReplicationId2();\n    server.hz = CONFIG_DEFAULT_HZ; /* Initialize it ASAP, even if it may get\n                                      updated later after loading the config.\n                                      This value may be used before the server\n                                      is initialized. */\n    server.timezone = getTimeZone(); /* Initialized by tzset(). */\n    server.configfile = NULL;\n    server.executable = NULL;\n    server.arch_bits = (sizeof(long) == 8) ? 64 : 32;\n    server.bindaddr_count = 0;\n    server.unixsocketperm = CONFIG_DEFAULT_UNIX_SOCKET_PERM;\n    server.ipfd.count = 0;\n    server.tlsfd.count = 0;\n    server.sofd = -1;\n    server.active_expire_enabled = 1;\n    server.skip_checksum_validation = 0;\n    server.saveparams = NULL;\n    server.loading = 0;\n    server.loading_rdb_used_mem = 0;\n    server.logfile = zstrdup(CONFIG_DEFAULT_LOGFILE);\n    server.aof_state = AOF_OFF;\n    server.aof_rewrite_base_size = 0;\n    server.aof_rewrite_scheduled = 0;\n    server.aof_flush_sleep = 0;\n    server.aof_last_fsync = time(NULL);\n    atomicSet(server.aof_bio_fsync_status,C_OK);\n    server.aof_rewrite_time_last = -1;\n    server.aof_rewrite_time_start = -1;\n    server.aof_lastbgrewrite_status = C_OK;\n    server.aof_delayed_fsync = 0;\n    server.aof_fd = -1;\n    server.aof_selected_db = -1; /* Make sure the first time will not match */\n    server.aof_flush_postponed_start = 0;\n    server.pidfile = NULL;\n    server.active_defrag_running = 0;\n    server.notify_keyspace_events = 0;\n    server.blocked_clients = 0;\n    memset(server.blocked_clients_by_type,0,\n           sizeof(server.blocked_clients_by_type));\n    server.shutdown_asap = 0;\n    server.cluster_configfile = zstrdup(CONFIG_DEFAULT_CLUSTER_CONFIG_FILE);\n    server.cluster_module_flags = CLUSTER_MODULE_FLAG_NONE;\n    server.migrate_cached_sockets = dictCreate(&migrateCacheDictType,NULL);\n    server.next_client_id = 1; /* Client IDs, start from 1 .*/\n    server.loading_process_events_interval_bytes = (1024*1024*2);\n\n    unsigned int lruclock = getLRUClock();\n    atomicSet(server.lruclock,lruclock);\n    resetServerSaveParams();\n\n    appendServerSaveParams(60*60,1);  /* save after 1 hour and 1 change */\n    appendServerSaveParams(300,100);  /* save after 5 minutes and 100 changes */\n    appendServerSaveParams(60,10000); /* save after 1 minute and 10000 changes */\n\n    /* Replication related */\n    server.masterauth = NULL;\n    server.masterhost = NULL;\n    server.masterport = 6379;\n    server.master = NULL;\n    server.cached_master = NULL;\n    server.master_initial_offset = -1;\n    server.repl_state = REPL_STATE_NONE;\n    server.repl_transfer_tmpfile = NULL;\n    server.repl_transfer_fd = -1;\n    server.repl_transfer_s = NULL;\n    server.repl_syncio_timeout = CONFIG_REPL_SYNCIO_TIMEOUT;\n    server.repl_down_since = 0; /* Never connected, repl is down since EVER. */\n    server.master_repl_offset = 0;\n\n    /* Replication partial resync backlog */\n    server.repl_backlog = NULL;\n    server.repl_backlog_histlen = 0;\n    server.repl_backlog_idx = 0;\n    server.repl_backlog_off = 0;\n    server.repl_no_slaves_since = time(NULL);\n\n    /* Failover related */\n    server.failover_end_time = 0;\n    server.force_failover = 0;\n    server.target_replica_host = NULL;\n    server.target_replica_port = 0;\n    server.failover_state = NO_FAILOVER;\n\n    /* Client output buffer limits */\n    for (j = 0; j < CLIENT_TYPE_OBUF_COUNT; j++)\n        server.client_obuf_limits[j] = clientBufferLimitsDefaults[j];\n\n    /* Linux OOM Score config */\n    for (j = 0; j < CONFIG_OOM_COUNT; j++)\n        server.oom_score_adj_values[j] = configOOMScoreAdjValuesDefaults[j];\n\n    /* Double constants initialization */\n    R_Zero = 0.0;\n    R_PosInf = 1.0/R_Zero;\n    R_NegInf = -1.0/R_Zero;\n    R_Nan = R_Zero/R_Zero;\n\n    /* Command table -- we initialize it here as it is part of the\n     * initial configuration, since command names may be changed via\n     * redis.conf using the rename-command directive. */\n    server.commands = dictCreate(&commandTableDictType,NULL);\n    server.orig_commands = dictCreate(&commandTableDictType,NULL);\n    populateCommandTable();\n    server.delCommand = lookupCommandByCString(\"del\");\n    server.multiCommand = lookupCommandByCString(\"multi\");\n    server.lpushCommand = lookupCommandByCString(\"lpush\");\n    server.lpopCommand = lookupCommandByCString(\"lpop\");\n    server.rpopCommand = lookupCommandByCString(\"rpop\");\n    server.zpopminCommand = lookupCommandByCString(\"zpopmin\");\n    server.zpopmaxCommand = lookupCommandByCString(\"zpopmax\");\n    server.sremCommand = lookupCommandByCString(\"srem\");\n    server.execCommand = lookupCommandByCString(\"exec\");\n    server.expireCommand = lookupCommandByCString(\"expire\");\n    server.pexpireCommand = lookupCommandByCString(\"pexpire\");\n    server.xclaimCommand = lookupCommandByCString(\"xclaim\");\n    server.xgroupCommand = lookupCommandByCString(\"xgroup\");\n    server.rpoplpushCommand = lookupCommandByCString(\"rpoplpush\");\n    server.lmoveCommand = lookupCommandByCString(\"lmove\");\n\n    /* Debugging */\n    server.watchdog_period = 0;\n\n    /* By default we want scripts to be always replicated by effects\n     * (single commands executed by the script), and not by sending the\n     * script to the slave / AOF. This is the new way starting from\n     * Redis 5. However it is possible to revert it via redis.conf. */\n    server.lua_always_replicate_commands = 1;\n\n    initConfigValues();\n}\n\nextern char **environ;\n\n/* Restart the server, executing the same executable that started this\n * instance, with the same arguments and configuration file.\n *\n * The function is designed to directly call execve() so that the new\n * server instance will retain the PID of the previous one.\n *\n * The list of flags, that may be bitwise ORed together, alter the\n * behavior of this function:\n *\n * RESTART_SERVER_NONE              No flags.\n * RESTART_SERVER_GRACEFULLY        Do a proper shutdown before restarting.\n * RESTART_SERVER_CONFIG_REWRITE    Rewrite the config file before restarting.\n *\n * On success the function does not return, because the process turns into\n * a different process. On error C_ERR is returned. */\nint restartServer(int flags, mstime_t delay) {\n    int j;\n\n    /* Check if we still have accesses to the executable that started this\n     * server instance. */\n    if (access(server.executable,X_OK) == -1) {\n        serverLog(LL_WARNING,\"Can't restart: this process has no \"\n                             \"permissions to execute %s\", server.executable);\n        return C_ERR;\n    }\n\n    /* Config rewriting. */\n    if (flags & RESTART_SERVER_CONFIG_REWRITE &&\n        server.configfile &&\n        rewriteConfig(server.configfile, 0) == -1)\n    {\n        serverLog(LL_WARNING,\"Can't restart: configuration rewrite process \"\n                             \"failed\");\n        return C_ERR;\n    }\n\n    /* Perform a proper shutdown. */\n    if (flags & RESTART_SERVER_GRACEFULLY &&\n        prepareForShutdown(SHUTDOWN_NOFLAGS) != C_OK)\n    {\n        serverLog(LL_WARNING,\"Can't restart: error preparing for shutdown\");\n        return C_ERR;\n    }\n\n    /* Close all file descriptors, with the exception of stdin, stdout, strerr\n     * which are useful if we restart a Redis server which is not daemonized. */\n    for (j = 3; j < (int)server.maxclients + 1024; j++) {\n        /* Test the descriptor validity before closing it, otherwise\n         * Valgrind issues a warning on close(). */\n        if (fcntl(j,F_GETFD) != -1) close(j);\n    }\n\n    /* Execute the server with the original command line. */\n    if (delay) usleep(delay*1000);\n    zfree(server.exec_argv[0]);\n    server.exec_argv[0] = zstrdup(server.executable);\n    execve(server.executable,server.exec_argv,environ);\n\n    /* If an error occurred here, there is nothing we can do, but exit. */\n    _exit(1);\n\n    return C_ERR; /* Never reached. */\n}\n\nstatic void readOOMScoreAdj(void) {\n#ifdef HAVE_PROC_OOM_SCORE_ADJ\n    char buf[64];\n    int fd = open(\"/proc/self/oom_score_adj\", O_RDONLY);\n\n    if (fd < 0) return;\n    if (read(fd, buf, sizeof(buf)) > 0)\n        server.oom_score_adj_base = atoi(buf);\n    close(fd);\n#endif\n}\n\n/* This function will configure the current process's oom_score_adj according\n * to user specified configuration. This is currently implemented on Linux\n * only.\n *\n * A process_class value of -1 implies OOM_CONFIG_MASTER or OOM_CONFIG_REPLICA,\n * depending on current role.\n */\nint setOOMScoreAdj(int process_class) {\n\n    if (server.oom_score_adj == OOM_SCORE_ADJ_NO) return C_OK;\n    if (process_class == -1)\n        process_class = (server.masterhost ? CONFIG_OOM_REPLICA : CONFIG_OOM_MASTER);\n\n    serverAssert(process_class >= 0 && process_class < CONFIG_OOM_COUNT);\n\n#ifdef HAVE_PROC_OOM_SCORE_ADJ\n    int fd;\n    int val;\n    char buf[64];\n\n    val = server.oom_score_adj_values[process_class];\n    if (server.oom_score_adj == OOM_SCORE_RELATIVE)\n        val += server.oom_score_adj_base;\n    if (val > 1000) val = 1000;\n    if (val < -1000) val = -1000;\n\n    snprintf(buf, sizeof(buf) - 1, \"%d\\n\", val);\n\n    fd = open(\"/proc/self/oom_score_adj\", O_WRONLY);\n    if (fd < 0 || write(fd, buf, strlen(buf)) < 0) {\n        serverLog(LOG_WARNING, \"Unable to write oom_score_adj: %s\", strerror(errno));\n        if (fd != -1) close(fd);\n        return C_ERR;\n    }\n\n    close(fd);\n    return C_OK;\n#else\n    /* Unsupported */\n    return C_ERR;\n#endif\n}\n\n/* This function will try to raise the max number of open files accordingly to\n * the configured max number of clients. It also reserves a number of file\n * descriptors (CONFIG_MIN_RESERVED_FDS) for extra operations of\n * persistence, listening sockets, log files and so forth.\n *\n * If it will not be possible to set the limit accordingly to the configured\n * max number of clients, the function will do the reverse setting\n * server.maxclients to the value that we can actually handle. */\nvoid adjustOpenFilesLimit(void) {\n    rlim_t maxfiles = server.maxclients+CONFIG_MIN_RESERVED_FDS;\n    struct rlimit limit;\n\n    if (getrlimit(RLIMIT_NOFILE,&limit) == -1) {\n        serverLog(LL_WARNING,\"Unable to obtain the current NOFILE limit (%s), assuming 1024 and setting the max clients configuration accordingly.\",\n            strerror(errno));\n        server.maxclients = 1024-CONFIG_MIN_RESERVED_FDS;\n    } else {\n        rlim_t oldlimit = limit.rlim_cur;\n\n        /* Set the max number of files if the current limit is not enough\n         * for our needs. */\n        if (oldlimit < maxfiles) {\n            rlim_t bestlimit;\n            int setrlimit_error = 0;\n\n            /* Try to set the file limit to match 'maxfiles' or at least\n             * to the higher value supported less than maxfiles. */\n            bestlimit = maxfiles;\n            while(bestlimit > oldlimit) {\n                rlim_t decr_step = 16;\n\n                limit.rlim_cur = bestlimit;\n                limit.rlim_max = bestlimit;\n                if (setrlimit(RLIMIT_NOFILE,&limit) != -1) break;\n                setrlimit_error = errno;\n\n                /* We failed to set file limit to 'bestlimit'. Try with a\n                 * smaller limit decrementing by a few FDs per iteration. */\n                if (bestlimit < decr_step) break;\n                bestlimit -= decr_step;\n            }\n\n            /* Assume that the limit we get initially is still valid if\n             * our last try was even lower. */\n            if (bestlimit < oldlimit) bestlimit = oldlimit;\n\n            if (bestlimit < maxfiles) {\n                unsigned int old_maxclients = server.maxclients;\n                server.maxclients = bestlimit-CONFIG_MIN_RESERVED_FDS;\n                /* maxclients is unsigned so may overflow: in order\n                 * to check if maxclients is now logically less than 1\n                 * we test indirectly via bestlimit. */\n                if (bestlimit <= CONFIG_MIN_RESERVED_FDS) {\n                    serverLog(LL_WARNING,\"Your current 'ulimit -n' \"\n                        \"of %llu is not enough for the server to start. \"\n                        \"Please increase your open file limit to at least \"\n                        \"%llu. Exiting.\",\n                        (unsigned long long) oldlimit,\n                        (unsigned long long) maxfiles);\n                    exit(1);\n                }\n                serverLog(LL_WARNING,\"You requested maxclients of %d \"\n                    \"requiring at least %llu max file descriptors.\",\n                    old_maxclients,\n                    (unsigned long long) maxfiles);\n                serverLog(LL_WARNING,\"Server can't set maximum open files \"\n                    \"to %llu because of OS error: %s.\",\n                    (unsigned long long) maxfiles, strerror(setrlimit_error));\n                serverLog(LL_WARNING,\"Current maximum open files is %llu. \"\n                    \"maxclients has been reduced to %d to compensate for \"\n                    \"low ulimit. \"\n                    \"If you need higher maxclients increase 'ulimit -n'.\",\n                    (unsigned long long) bestlimit, server.maxclients);\n            } else {\n                serverLog(LL_NOTICE,\"Increased maximum number of open files \"\n                    \"to %llu (it was originally set to %llu).\",\n                    (unsigned long long) maxfiles,\n                    (unsigned long long) oldlimit);\n            }\n        }\n    }\n}\n\n/* Check that server.tcp_backlog can be actually enforced in Linux according\n * to the value of /proc/sys/net/core/somaxconn, or warn about it. */\nvoid checkTcpBacklogSettings(void) {\n#ifdef HAVE_PROC_SOMAXCONN\n    FILE *fp = fopen(\"/proc/sys/net/core/somaxconn\",\"r\");\n    char buf[1024];\n    if (!fp) return;\n    if (fgets(buf,sizeof(buf),fp) != NULL) {\n        int somaxconn = atoi(buf);\n        if (somaxconn > 0 && somaxconn < server.tcp_backlog) {\n            serverLog(LL_WARNING,\"WARNING: The TCP backlog setting of %d cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of %d.\", server.tcp_backlog, somaxconn);\n        }\n    }\n    fclose(fp);\n#endif\n}\n\nvoid closeSocketListeners(socketFds *sfd) {\n    int j;\n\n    for (j = 0; j < sfd->count; j++) {\n        if (sfd->fd[j] == -1) continue;\n\n        aeDeleteFileEvent(server.el, sfd->fd[j], AE_READABLE);\n        close(sfd->fd[j]);\n    }\n\n    sfd->count = 0;\n}\n\n/* Create an event handler for accepting new connections in TCP or TLS domain sockets.\n * This works atomically for all socket fds */\nint createSocketAcceptHandler(socketFds *sfd, aeFileProc *accept_handler) {\n    int j;\n\n    for (j = 0; j < sfd->count; j++) {\n        if (aeCreateFileEvent(server.el, sfd->fd[j], AE_READABLE, accept_handler,NULL) == AE_ERR) {\n            /* Rollback */\n            for (j = j-1; j >= 0; j--) aeDeleteFileEvent(server.el, sfd->fd[j], AE_READABLE);\n            return C_ERR;\n        }\n    }\n    return C_OK;\n}\n\n/* Initialize a set of file descriptors to listen to the specified 'port'\n * binding the addresses specified in the Redis server configuration.\n *\n * The listening file descriptors are stored in the integer array 'fds'\n * and their number is set in '*count'.\n *\n * The addresses to bind are specified in the global server.bindaddr array\n * and their number is server.bindaddr_count. If the server configuration\n * contains no specific addresses to bind, this function will try to\n * bind * (all addresses) for both the IPv4 and IPv6 protocols.\n *\n * On success the function returns C_OK.\n *\n * On error the function returns C_ERR. For the function to be on\n * error, at least one of the server.bindaddr addresses was\n * impossible to bind, or no bind addresses were specified in the server\n * configuration but the function is not able to bind * for at least\n * one of the IPv4 or IPv6 protocols. */\nint listenToPort(int port, socketFds *sfd) {\n    int j;\n    char **bindaddr = server.bindaddr;\n    int bindaddr_count = server.bindaddr_count;\n    char *default_bindaddr[2] = {\"*\", \"-::*\"};\n\n    /* Force binding of 0.0.0.0 if no bind address is specified. */\n    if (server.bindaddr_count == 0) {\n        bindaddr_count = 2;\n        bindaddr = default_bindaddr;\n    }\n\n    for (j = 0; j < bindaddr_count; j++) {\n        char* addr = bindaddr[j];\n        int optional = *addr == '-';\n        if (optional) addr++;\n        if (strchr(addr,':')) {\n            /* Bind IPv6 address. */\n            sfd->fd[sfd->count] = anetTcp6Server(server.neterr,port,addr,server.tcp_backlog);\n        } else {\n            /* Bind IPv4 address. */\n            sfd->fd[sfd->count] = anetTcpServer(server.neterr,port,addr,server.tcp_backlog);\n        }\n        if (sfd->fd[sfd->count] == ANET_ERR) {\n            int net_errno = errno;\n            serverLog(LL_WARNING,\n                \"Warning: Could not create server TCP listening socket %s:%d: %s\",\n                addr, port, server.neterr);\n            if (net_errno == EADDRNOTAVAIL && optional)\n                continue;\n            if (net_errno == ENOPROTOOPT     || net_errno == EPROTONOSUPPORT ||\n                net_errno == ESOCKTNOSUPPORT || net_errno == EPFNOSUPPORT ||\n                net_errno == EAFNOSUPPORT)\n                continue;\n\n            /* Rollback successful listens before exiting */\n            closeSocketListeners(sfd);\n            return C_ERR;\n        }\n        anetNonBlock(NULL,sfd->fd[sfd->count]);\n        anetCloexec(sfd->fd[sfd->count]);\n        sfd->count++;\n    }\n    return C_OK;\n}\n\n/* Resets the stats that we expose via INFO or other means that we want\n * to reset via CONFIG RESETSTAT. The function is also used in order to\n * initialize these fields in initServer() at server startup. */\nvoid resetServerStats(void) {\n    int j;\n\n    server.stat_numcommands = 0;\n    server.stat_numconnections = 0;\n    server.stat_expiredkeys = 0;\n    server.stat_expired_stale_perc = 0;\n    server.stat_expired_time_cap_reached_count = 0;\n    server.stat_expire_cycle_time_used = 0;\n    server.stat_evictedkeys = 0;\n    server.stat_keyspace_misses = 0;\n    server.stat_keyspace_hits = 0;\n    server.stat_active_defrag_hits = 0;\n    server.stat_active_defrag_misses = 0;\n    server.stat_active_defrag_key_hits = 0;\n    server.stat_active_defrag_key_misses = 0;\n    server.stat_active_defrag_scanned = 0;\n    server.stat_fork_time = 0;\n    server.stat_fork_rate = 0;\n    server.stat_total_forks = 0;\n    server.stat_rejected_conn = 0;\n    server.stat_sync_full = 0;\n    server.stat_sync_partial_ok = 0;\n    server.stat_sync_partial_err = 0;\n    server.stat_io_reads_processed = 0;\n    atomicSet(server.stat_total_reads_processed, 0);\n    server.stat_io_writes_processed = 0;\n    atomicSet(server.stat_total_writes_processed, 0);\n    for (j = 0; j < STATS_METRIC_COUNT; j++) {\n        server.inst_metric[j].idx = 0;\n        server.inst_metric[j].last_sample_time = mstime();\n        server.inst_metric[j].last_sample_count = 0;\n        memset(server.inst_metric[j].samples,0,\n            sizeof(server.inst_metric[j].samples));\n    }\n    atomicSet(server.stat_net_input_bytes, 0);\n    atomicSet(server.stat_net_output_bytes, 0);\n    server.stat_unexpected_error_replies = 0;\n    server.stat_total_error_replies = 0;\n    server.stat_dump_payload_sanitizations = 0;\n    server.aof_delayed_fsync = 0;\n}\n\n/* Make the thread killable at any time, so that kill threads functions\n * can work reliably (default cancelability type is PTHREAD_CANCEL_DEFERRED).\n * Needed for pthread_cancel used by the fast memory test used by the crash report. */\nvoid makeThreadKillable(void) {\n    pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);\n    pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);\n}\n\nvoid initServer(void) {\n    int j;\n\n    signal(SIGHUP, SIG_IGN);\n    signal(SIGPIPE, SIG_IGN);\n    setupSignalHandlers();\n    makeThreadKillable();\n\n    if (server.syslog_enabled) {\n        openlog(server.syslog_ident, LOG_PID | LOG_NDELAY | LOG_NOWAIT,\n            server.syslog_facility);\n    }\n\n    /* Initialization after setting defaults from the config system. */\n    server.aof_state = server.aof_enabled ? AOF_ON : AOF_OFF;\n    server.hz = server.config_hz;\n    server.pid = getpid();\n    server.in_fork_child = CHILD_TYPE_NONE;\n    server.main_thread_id = pthread_self();\n    server.current_client = NULL;\n    server.errors = raxNew();\n    server.fixed_time_expire = 0;\n    server.clients = listCreate();\n    server.clients_index = raxNew();\n    server.clients_to_close = listCreate();\n    server.slaves = listCreate();\n    server.monitors = listCreate();\n    server.clients_pending_write = listCreate();\n    server.clients_pending_read = listCreate();\n    server.clients_timeout_table = raxNew();\n    server.replication_allowed = 1;\n    server.slaveseldb = -1; /* Force to emit the first SELECT command. */\n    server.unblocked_clients = listCreate();\n    server.ready_keys = listCreate();\n    server.clients_waiting_acks = listCreate();\n    server.get_ack_from_slaves = 0;\n    server.client_pause_type = 0;\n    server.paused_clients = listCreate();\n    server.events_processed_while_blocked = 0;\n    server.system_memory_size = zmalloc_get_memory_size();\n    server.blocked_last_cron = 0;\n    server.blocking_op_nesting = 0;\n\n    if ((server.tls_port || server.tls_replication || server.tls_cluster)\n                && tlsConfigure(&server.tls_ctx_config) == C_ERR) {\n        serverLog(LL_WARNING, \"Failed to configure TLS. Check logs for more info.\");\n        exit(1);\n    }\n\n    createSharedObjects();\n    adjustOpenFilesLimit();\n    const char *clk_msg = monotonicInit();\n    serverLog(LL_NOTICE, \"monotonic clock: %s\", clk_msg);\n    server.el = aeCreateEventLoop(server.maxclients+CONFIG_FDSET_INCR);\n    if (server.el == NULL) {\n        serverLog(LL_WARNING,\n            \"Failed creating the event loop. Error message: '%s'\",\n            strerror(errno));\n        exit(1);\n    }\n    server.db = zmalloc(sizeof(redisDb)*server.dbnum);\n\n    /* Open the TCP listening socket for the user commands. */\n    if (server.port != 0 &&\n        listenToPort(server.port,&server.ipfd) == C_ERR) {\n        serverLog(LL_WARNING, \"Failed listening on port %u (TCP), aborting.\", server.port);\n        exit(1);\n    }\n    if (server.tls_port != 0 &&\n        listenToPort(server.tls_port,&server.tlsfd) == C_ERR) {\n        serverLog(LL_WARNING, \"Failed listening on port %u (TLS), aborting.\", server.tls_port);\n        exit(1);\n    }\n\n    /* Open the listening Unix domain socket. */\n    if (server.unixsocket != NULL) {\n        unlink(server.unixsocket); /* don't care if this fails */\n        server.sofd = anetUnixServer(server.neterr,server.unixsocket,\n            server.unixsocketperm, server.tcp_backlog);\n        if (server.sofd == ANET_ERR) {\n            serverLog(LL_WARNING, \"Opening Unix socket: %s\", server.neterr);\n            exit(1);\n        }\n        anetNonBlock(NULL,server.sofd);\n        anetCloexec(server.sofd);\n    }\n\n    /* Abort if there are no listening sockets at all. */\n    if (server.ipfd.count == 0 && server.tlsfd.count == 0 && server.sofd < 0) {\n        serverLog(LL_WARNING, \"Configured to not listen anywhere, exiting.\");\n        exit(1);\n    }\n\n    /* Create the Redis databases, and initialize other internal state. */\n    for (j = 0; j < server.dbnum; j++) {\n        server.db[j].dict = dictCreate(&dbDictType,NULL);\n        server.db[j].expires = dictCreate(&dbExpiresDictType,NULL);\n        server.db[j].expires_cursor = 0;\n        server.db[j].blocking_keys = dictCreate(&keylistDictType,NULL);\n        server.db[j].ready_keys = dictCreate(&objectKeyPointerValueDictType,NULL);\n        server.db[j].watched_keys = dictCreate(&keylistDictType,NULL);\n        server.db[j].id = j;\n        server.db[j].avg_ttl = 0;\n        server.db[j].defrag_later = listCreate();\n        listSetFreeMethod(server.db[j].defrag_later,(void (*)(void*))sdsfree);\n    }\n    evictionPoolAlloc(); /* Initialize the LRU keys pool. */\n    server.pubsub_channels = dictCreate(&keylistDictType,NULL);\n    server.pubsub_patterns = dictCreate(&keylistDictType,NULL);\n    server.cronloops = 0;\n    server.in_eval = 0;\n    server.in_exec = 0;\n    server.propagate_in_transaction = 0;\n    server.client_pause_in_transaction = 0;\n    server.child_pid = -1;\n    server.child_type = CHILD_TYPE_NONE;\n    server.rdb_child_type = RDB_CHILD_TYPE_NONE;\n    server.rdb_pipe_conns = NULL;\n    server.rdb_pipe_numconns = 0;\n    server.rdb_pipe_numconns_writing = 0;\n    server.rdb_pipe_buff = NULL;\n    server.rdb_pipe_bufflen = 0;\n    server.rdb_bgsave_scheduled = 0;\n    server.child_info_pipe[0] = -1;\n    server.child_info_pipe[1] = -1;\n    server.child_info_nread = 0;\n    aofRewriteBufferReset();\n    server.aof_buf = sdsempty();\n    server.lastsave = time(NULL); /* At startup we consider the DB saved. */\n    server.lastbgsave_try = 0;    /* At startup we never tried to BGSAVE. */\n    server.rdb_save_time_last = -1;\n    server.rdb_save_time_start = -1;\n    server.dirty = 0;\n    resetServerStats();\n    /* A few stats we don't want to reset: server startup time, and peak mem. */\n    server.stat_starttime = time(NULL);\n    server.stat_peak_memory = 0;\n    server.stat_current_cow_bytes = 0;\n    server.stat_current_cow_updated = 0;\n    server.stat_current_save_keys_processed = 0;\n    server.stat_current_save_keys_total = 0;\n    server.stat_rdb_cow_bytes = 0;\n    server.stat_aof_cow_bytes = 0;\n    server.stat_module_cow_bytes = 0;\n    server.stat_module_progress = 0;\n    for (int j = 0; j < CLIENT_TYPE_COUNT; j++)\n        server.stat_clients_type_memory[j] = 0;\n    server.cron_malloc_stats.zmalloc_used = 0;\n    server.cron_malloc_stats.process_rss = 0;\n    server.cron_malloc_stats.allocator_allocated = 0;\n    server.cron_malloc_stats.allocator_active = 0;\n    server.cron_malloc_stats.allocator_resident = 0;\n    server.lastbgsave_status = C_OK;\n    server.aof_last_write_status = C_OK;\n    server.aof_last_write_errno = 0;\n    server.repl_good_slaves_count = 0;\n\n    /* Create the timer callback, this is our way to process many background\n     * operations incrementally, like clients timeout, eviction of unaccessed\n     * expired keys and so forth. */\n    if (aeCreateTimeEvent(server.el, 1, serverCron, NULL, NULL) == AE_ERR) {\n        serverPanic(\"Can't create event loop timers.\");\n        exit(1);\n    }\n\n    /* Create an event handler for accepting new connections in TCP and Unix\n     * domain sockets. */\n    if (createSocketAcceptHandler(&server.ipfd, acceptTcpHandler) != C_OK) {\n        serverPanic(\"Unrecoverable error creating TCP socket accept handler.\");\n    }\n    if (createSocketAcceptHandler(&server.tlsfd, acceptTLSHandler) != C_OK) {\n        serverPanic(\"Unrecoverable error creating TLS socket accept handler.\");\n    }\n    if (server.sofd > 0 && aeCreateFileEvent(server.el,server.sofd,AE_READABLE,\n        acceptUnixHandler,NULL) == AE_ERR) serverPanic(\"Unrecoverable error creating server.sofd file event.\");\n\n\n    /* Register a readable event for the pipe used to awake the event loop\n     * when a blocked client in a module needs attention. */\n    if (aeCreateFileEvent(server.el, server.module_blocked_pipe[0], AE_READABLE,\n        moduleBlockedClientPipeReadable,NULL) == AE_ERR) {\n            serverPanic(\n                \"Error registering the readable event for the module \"\n                \"blocked clients subsystem.\");\n    }\n\n    /* Register before and after sleep handlers (note this needs to be done\n     * before loading persistence since it is used by processEventsWhileBlocked. */\n    aeSetBeforeSleepProc(server.el,beforeSleep);\n    aeSetAfterSleepProc(server.el,afterSleep);\n\n    /* Open the AOF file if needed. */\n    if (server.aof_state == AOF_ON) {\n        server.aof_fd = open(server.aof_filename,\n                               O_WRONLY|O_APPEND|O_CREAT,0644);\n        if (server.aof_fd == -1) {\n            serverLog(LL_WARNING, \"Can't open the append-only file: %s\",\n                strerror(errno));\n            exit(1);\n        }\n    }\n\n    /* 32 bit instances are limited to 4GB of address space, so if there is\n     * no explicit limit in the user provided configuration we set a limit\n     * at 3 GB using maxmemory with 'noeviction' policy'. This avoids\n     * useless crashes of the Redis instance for out of memory. */\n    if (server.arch_bits == 32 && server.maxmemory == 0) {\n        serverLog(LL_WARNING,\"Warning: 32 bit instance detected but no memory limit set. Setting 3 GB maxmemory limit with 'noeviction' policy now.\");\n        server.maxmemory = 3072LL*(1024*1024); /* 3 GB */\n        server.maxmemory_policy = MAXMEMORY_NO_EVICTION;\n    }\n\n    if (server.cluster_enabled) clusterInit();\n    replicationScriptCacheInit();\n    scriptingInit(1);\n    slowlogInit();\n    latencyMonitorInit();\n    \n    /* Initialize ACL default password if it exists */\n    ACLUpdateDefaultUserPassword(server.requirepass);\n}\n\n/* Some steps in server initialization need to be done last (after modules\n * are loaded).\n * Specifically, creation of threads due to a race bug in ld.so, in which\n * Thread Local Storage initialization collides with dlopen call.\n * see: https://sourceware.org/bugzilla/show_bug.cgi?id=19329 */\nvoid InitServerLast() {\n    bioInit();\n    initThreadedIO();\n    set_jemalloc_bg_thread(server.jemalloc_bg_thread);\n    server.initial_memory_usage = zmalloc_used_memory();\n}\n\n/* Parse the flags string description 'strflags' and set them to the\n * command 'c'. If the flags are all valid C_OK is returned, otherwise\n * C_ERR is returned (yet the recognized flags are set in the command). */\nint populateCommandTableParseFlags(struct redisCommand *c, char *strflags) {\n    int argc;\n    sds *argv;\n\n    /* Split the line into arguments for processing. */\n    argv = sdssplitargs(strflags,&argc);\n    if (argv == NULL) return C_ERR;\n\n    for (int j = 0; j < argc; j++) {\n        char *flag = argv[j];\n        if (!strcasecmp(flag,\"write\")) {\n            c->flags |= CMD_WRITE|CMD_CATEGORY_WRITE;\n        } else if (!strcasecmp(flag,\"read-only\")) {\n            c->flags |= CMD_READONLY|CMD_CATEGORY_READ;\n        } else if (!strcasecmp(flag,\"use-memory\")) {\n            c->flags |= CMD_DENYOOM;\n        } else if (!strcasecmp(flag,\"admin\")) {\n            c->flags |= CMD_ADMIN|CMD_CATEGORY_ADMIN|CMD_CATEGORY_DANGEROUS;\n        } else if (!strcasecmp(flag,\"pub-sub\")) {\n            c->flags |= CMD_PUBSUB|CMD_CATEGORY_PUBSUB;\n        } else if (!strcasecmp(flag,\"no-script\")) {\n            c->flags |= CMD_NOSCRIPT;\n        } else if (!strcasecmp(flag,\"random\")) {\n            c->flags |= CMD_RANDOM;\n        } else if (!strcasecmp(flag,\"to-sort\")) {\n            c->flags |= CMD_SORT_FOR_SCRIPT;\n        } else if (!strcasecmp(flag,\"ok-loading\")) {\n            c->flags |= CMD_LOADING;\n        } else if (!strcasecmp(flag,\"ok-stale\")) {\n            c->flags |= CMD_STALE;\n        } else if (!strcasecmp(flag,\"no-monitor\")) {\n            c->flags |= CMD_SKIP_MONITOR;\n        } else if (!strcasecmp(flag,\"no-slowlog\")) {\n            c->flags |= CMD_SKIP_SLOWLOG;\n        } else if (!strcasecmp(flag,\"cluster-asking\")) {\n            c->flags |= CMD_ASKING;\n        } else if (!strcasecmp(flag,\"fast\")) {\n            c->flags |= CMD_FAST | CMD_CATEGORY_FAST;\n        } else if (!strcasecmp(flag,\"no-auth\")) {\n            c->flags |= CMD_NO_AUTH;\n        } else if (!strcasecmp(flag,\"may-replicate\")) {\n            c->flags |= CMD_MAY_REPLICATE;\n        } else {\n            /* Parse ACL categories here if the flag name starts with @. */\n            uint64_t catflag;\n            if (flag[0] == '@' &&\n                (catflag = ACLGetCommandCategoryFlagByName(flag+1)) != 0)\n            {\n                c->flags |= catflag;\n            } else {\n                sdsfreesplitres(argv,argc);\n                return C_ERR;\n            }\n        }\n    }\n    /* If it's not @fast is @slow in this binary world. */\n    if (!(c->flags & CMD_CATEGORY_FAST)) c->flags |= CMD_CATEGORY_SLOW;\n\n    sdsfreesplitres(argv,argc);\n    return C_OK;\n}\n\n/* Populates the Redis Command Table starting from the hard coded list\n * we have on top of server.c file. */\nvoid populateCommandTable(void) {\n    int j;\n    int numcommands = sizeof(redisCommandTable)/sizeof(struct redisCommand);\n\n    for (j = 0; j < numcommands; j++) {\n        struct redisCommand *c = redisCommandTable+j;\n        int retval1, retval2;\n\n        /* Translate the command string flags description into an actual\n         * set of flags. */\n        if (populateCommandTableParseFlags(c,c->sflags) == C_ERR)\n            serverPanic(\"Unsupported command flag\");\n\n        c->id = ACLGetCommandID(c->name); /* Assign the ID used for ACL. */\n        retval1 = dictAdd(server.commands, sdsnew(c->name), c);\n        /* Populate an additional dictionary that will be unaffected\n         * by rename-command statements in redis.conf. */\n        retval2 = dictAdd(server.orig_commands, sdsnew(c->name), c);\n        serverAssert(retval1 == DICT_OK && retval2 == DICT_OK);\n    }\n}\n\nvoid resetCommandTableStats(void) {\n    struct redisCommand *c;\n    dictEntry *de;\n    dictIterator *di;\n\n    di = dictGetSafeIterator(server.commands);\n    while((de = dictNext(di)) != NULL) {\n        c = (struct redisCommand *) dictGetVal(de);\n        c->microseconds = 0;\n        c->calls = 0;\n        c->rejected_calls = 0;\n        c->failed_calls = 0;\n    }\n    dictReleaseIterator(di);\n\n}\n\nvoid resetErrorTableStats(void) {\n    raxFreeWithCallback(server.errors, zfree);\n    server.errors = raxNew();\n}\n\n/* ========================== Redis OP Array API ============================ */\n\nvoid redisOpArrayInit(redisOpArray *oa) {\n    oa->ops = NULL;\n    oa->numops = 0;\n}\n\nint redisOpArrayAppend(redisOpArray *oa, struct redisCommand *cmd, int dbid,\n                       robj **argv, int argc, int target)\n{\n    redisOp *op;\n\n    oa->ops = zrealloc(oa->ops,sizeof(redisOp)*(oa->numops+1));\n    op = oa->ops+oa->numops;\n    op->cmd = cmd;\n    op->dbid = dbid;\n    op->argv = argv;\n    op->argc = argc;\n    op->target = target;\n    oa->numops++;\n    return oa->numops;\n}\n\nvoid redisOpArrayFree(redisOpArray *oa) {\n    while(oa->numops) {\n        int j;\n        redisOp *op;\n\n        oa->numops--;\n        op = oa->ops+oa->numops;\n        for (j = 0; j < op->argc; j++)\n            decrRefCount(op->argv[j]);\n        zfree(op->argv);\n    }\n    zfree(oa->ops);\n    oa->ops = NULL;\n}\n\n/* ====================== Commands lookup and execution ===================== */\n\nstruct redisCommand *lookupCommand(sds name) {\n    return dictFetchValue(server.commands, name);\n}\n\nstruct redisCommand *lookupCommandByCString(const char *s) {\n    struct redisCommand *cmd;\n    sds name = sdsnew(s);\n\n    cmd = dictFetchValue(server.commands, name);\n    sdsfree(name);\n    return cmd;\n}\n\n/* Lookup the command in the current table, if not found also check in\n * the original table containing the original command names unaffected by\n * redis.conf rename-command statement.\n *\n * This is used by functions rewriting the argument vector such as\n * rewriteClientCommandVector() in order to set client->cmd pointer\n * correctly even if the command was renamed. */\nstruct redisCommand *lookupCommandOrOriginal(sds name) {\n    struct redisCommand *cmd = dictFetchValue(server.commands, name);\n\n    if (!cmd) cmd = dictFetchValue(server.orig_commands,name);\n    return cmd;\n}\n\n/* Propagate the specified command (in the context of the specified database id)\n * to AOF and Slaves.\n *\n * flags are an xor between:\n * + PROPAGATE_NONE (no propagation of command at all)\n * + PROPAGATE_AOF (propagate into the AOF file if is enabled)\n * + PROPAGATE_REPL (propagate into the replication link)\n *\n * This should not be used inside commands implementation since it will not\n * wrap the resulting commands in MULTI/EXEC. Use instead alsoPropagate(),\n * preventCommandPropagation(), forceCommandPropagation().\n *\n * However for functions that need to (also) propagate out of the context of a\n * command execution, for example when serving a blocked client, you\n * want to use propagate().\n */\nvoid propagate(struct redisCommand *cmd, int dbid, robj **argv, int argc,\n               int flags)\n{\n    if (!server.replication_allowed)\n        return;\n\n    /* Propagate a MULTI request once we encounter the first command which\n     * is a write command.\n     * This way we'll deliver the MULTI/..../EXEC block as a whole and\n     * both the AOF and the replication link will have the same consistency\n     * and atomicity guarantees. */\n    if (server.in_exec && !server.propagate_in_transaction)\n        execCommandPropagateMulti(dbid);\n\n    /* This needs to be unreachable since the dataset should be fixed during \n     * client pause, otherwise data may be lossed during a failover. */\n    serverAssert(!(areClientsPaused() && !server.client_pause_in_transaction));\n\n    if (server.aof_state != AOF_OFF && flags & PROPAGATE_AOF)\n        feedAppendOnlyFile(cmd,dbid,argv,argc);\n    if (flags & PROPAGATE_REPL)\n        replicationFeedSlaves(server.slaves,dbid,argv,argc);\n}\n\n/* Used inside commands to schedule the propagation of additional commands\n * after the current command is propagated to AOF / Replication.\n *\n * 'cmd' must be a pointer to the Redis command to replicate, dbid is the\n * database ID the command should be propagated into.\n * Arguments of the command to propagate are passed as an array of redis\n * objects pointers of len 'argc', using the 'argv' vector.\n *\n * The function does not take a reference to the passed 'argv' vector,\n * so it is up to the caller to release the passed argv (but it is usually\n * stack allocated).  The function automatically increments ref count of\n * passed objects, so the caller does not need to. */\nvoid alsoPropagate(struct redisCommand *cmd, int dbid, robj **argv, int argc,\n                   int target)\n{\n    robj **argvcopy;\n    int j;\n\n    if (server.loading) return; /* No propagation during loading. */\n\n    argvcopy = zmalloc(sizeof(robj*)*argc);\n    for (j = 0; j < argc; j++) {\n        argvcopy[j] = argv[j];\n        incrRefCount(argv[j]);\n    }\n    redisOpArrayAppend(&server.also_propagate,cmd,dbid,argvcopy,argc,target);\n}\n\n/* It is possible to call the function forceCommandPropagation() inside a\n * Redis command implementation in order to to force the propagation of a\n * specific command execution into AOF / Replication. */\nvoid forceCommandPropagation(client *c, int flags) {\n    serverAssert(c->cmd->flags & (CMD_WRITE | CMD_MAY_REPLICATE));\n    if (flags & PROPAGATE_REPL) c->flags |= CLIENT_FORCE_REPL;\n    if (flags & PROPAGATE_AOF) c->flags |= CLIENT_FORCE_AOF;\n}\n\n/* Avoid that the executed command is propagated at all. This way we\n * are free to just propagate what we want using the alsoPropagate()\n * API. */\nvoid preventCommandPropagation(client *c) {\n    c->flags |= CLIENT_PREVENT_PROP;\n}\n\n/* Avoid logging any information about this client's arguments\n * since they contain sensitive information. */\nvoid preventCommandLogging(client *c) {\n    c->flags |= CLIENT_PREVENT_LOGGING;\n}\n\n/* AOF specific version of preventCommandPropagation(). */\nvoid preventCommandAOF(client *c) {\n    c->flags |= CLIENT_PREVENT_AOF_PROP;\n}\n\n/* Replication specific version of preventCommandPropagation(). */\nvoid preventCommandReplication(client *c) {\n    c->flags |= CLIENT_PREVENT_REPL_PROP;\n}\n\n/* Log the last command a client executed into the slowlog. */\nvoid slowlogPushCurrentCommand(client *c, struct redisCommand *cmd, ustime_t duration) {\n    /* Some commands may contain sensitive data that should not be available in the slowlog. */\n    if ((c->flags & CLIENT_PREVENT_LOGGING) || (cmd->flags & CMD_SKIP_SLOWLOG))\n        return;\n\n    /* If command argument vector was rewritten, use the original\n     * arguments. */\n    robj **argv = c->original_argv ? c->original_argv : c->argv;\n    int argc = c->original_argv ? c->original_argc : c->argc;\n    slowlogPushEntryIfNeeded(c,argv,argc,duration);\n}\n\n/* Call() is the core of Redis execution of a command.\n *\n * The following flags can be passed:\n * CMD_CALL_NONE        No flags.\n * CMD_CALL_SLOWLOG     Check command speed and log in the slow log if needed.\n * CMD_CALL_STATS       Populate command stats.\n * CMD_CALL_PROPAGATE_AOF   Append command to AOF if it modified the dataset\n *                          or if the client flags are forcing propagation.\n * CMD_CALL_PROPAGATE_REPL  Send command to slaves if it modified the dataset\n *                          or if the client flags are forcing propagation.\n * CMD_CALL_PROPAGATE   Alias for PROPAGATE_AOF|PROPAGATE_REPL.\n * CMD_CALL_FULL        Alias for SLOWLOG|STATS|PROPAGATE.\n *\n * The exact propagation behavior depends on the client flags.\n * Specifically:\n *\n * 1. If the client flags CLIENT_FORCE_AOF or CLIENT_FORCE_REPL are set\n *    and assuming the corresponding CMD_CALL_PROPAGATE_AOF/REPL is set\n *    in the call flags, then the command is propagated even if the\n *    dataset was not affected by the command.\n * 2. If the client flags CLIENT_PREVENT_REPL_PROP or CLIENT_PREVENT_AOF_PROP\n *    are set, the propagation into AOF or to slaves is not performed even\n *    if the command modified the dataset.\n *\n * Note that regardless of the client flags, if CMD_CALL_PROPAGATE_AOF\n * or CMD_CALL_PROPAGATE_REPL are not set, then respectively AOF or\n * slaves propagation will never occur.\n *\n * Client flags are modified by the implementation of a given command\n * using the following API:\n *\n * forceCommandPropagation(client *c, int flags);\n * preventCommandPropagation(client *c);\n * preventCommandAOF(client *c);\n * preventCommandReplication(client *c);\n *\n */\nvoid call(client *c, int flags) {\n    long long dirty;\n    monotime call_timer;\n    int client_old_flags = c->flags;\n    struct redisCommand *real_cmd = c->cmd;\n    static long long prev_err_count;\n\n    server.fixed_time_expire++;\n\n    /* Send the command to clients in MONITOR mode if applicable.\n     * Administrative commands are considered too dangerous to be shown. */\n    if (listLength(server.monitors) &&\n        !server.loading &&\n        !(c->cmd->flags & (CMD_SKIP_MONITOR|CMD_ADMIN)))\n    {\n        replicationFeedMonitors(c,server.monitors,c->db->id,c->argv,c->argc);\n    }\n\n    /* Initialization: clear the flags that must be set by the command on\n     * demand, and initialize the array for additional commands propagation. */\n    c->flags &= ~(CLIENT_FORCE_AOF|CLIENT_FORCE_REPL|CLIENT_PREVENT_PROP);\n    redisOpArray prev_also_propagate = server.also_propagate;\n    redisOpArrayInit(&server.also_propagate);\n\n    /* Call the command. */\n    dirty = server.dirty;\n    prev_err_count = server.stat_total_error_replies;\n    updateCachedTime(0);\n    elapsedStart(&call_timer);\n    c->cmd->proc(c);\n    const long duration = elapsedUs(call_timer);\n    c->duration = duration;\n    dirty = server.dirty-dirty;\n    if (dirty < 0) dirty = 0;\n\n    /* Update failed command calls if required.\n     * We leverage a static variable (prev_err_count) to retain\n     * the counter across nested function calls and avoid logging\n     * the same error twice. */\n    if ((server.stat_total_error_replies - prev_err_count) > 0) {\n        real_cmd->failed_calls++;\n    }\n\n    /* After executing command, we will close the client after writing entire\n     * reply if it is set 'CLIENT_CLOSE_AFTER_COMMAND' flag. */\n    if (c->flags & CLIENT_CLOSE_AFTER_COMMAND) {\n        c->flags &= ~CLIENT_CLOSE_AFTER_COMMAND;\n        c->flags |= CLIENT_CLOSE_AFTER_REPLY;\n    }\n\n    /* When EVAL is called loading the AOF we don't want commands called\n     * from Lua to go into the slowlog or to populate statistics. */\n    if (server.loading && c->flags & CLIENT_LUA)\n        flags &= ~(CMD_CALL_SLOWLOG | CMD_CALL_STATS);\n\n    /* If the caller is Lua, we want to force the EVAL caller to propagate\n     * the script if the command flag or client flag are forcing the\n     * propagation. */\n    if (c->flags & CLIENT_LUA && server.lua_caller) {\n        if (c->flags & CLIENT_FORCE_REPL)\n            server.lua_caller->flags |= CLIENT_FORCE_REPL;\n        if (c->flags & CLIENT_FORCE_AOF)\n            server.lua_caller->flags |= CLIENT_FORCE_AOF;\n    }\n\n    /* Note: the code below uses the real command that was executed\n     * c->cmd and c->lastcmd may be different, in case of MULTI-EXEC or\n     * re-written commands such as EXPIRE, GEOADD, etc. */\n\n    /* Record the latency this command induced on the main thread.\n     * unless instructed by the caller not to log. (happens when processing\n     * a MULTI-EXEC from inside an AOF). */\n    if (flags & CMD_CALL_SLOWLOG) {\n        char *latency_event = (real_cmd->flags & CMD_FAST) ?\n                               \"fast-command\" : \"command\";\n        latencyAddSampleIfNeeded(latency_event,duration/1000);\n    }\n\n    /* Log the command into the Slow log if needed.\n     * If the client is blocked we will handle slowlog when it is unblocked. */\n    if ((flags & CMD_CALL_SLOWLOG) && !(c->flags & CLIENT_BLOCKED))\n        slowlogPushCurrentCommand(c, real_cmd, duration);\n\n    /* Clear the original argv.\n     * If the client is blocked we will handle slowlog when it is unblocked. */\n    if (!(c->flags & CLIENT_BLOCKED))\n        freeClientOriginalArgv(c);\n\n    /* populate the per-command statistics that we show in INFO commandstats. */\n    if (flags & CMD_CALL_STATS) {\n        real_cmd->microseconds += duration;\n        real_cmd->calls++;\n    }\n\n    /* Propagate the command into the AOF and replication link */\n    if (flags & CMD_CALL_PROPAGATE &&\n        (c->flags & CLIENT_PREVENT_PROP) != CLIENT_PREVENT_PROP)\n    {\n        int propagate_flags = PROPAGATE_NONE;\n\n        /* Check if the command operated changes in the data set. If so\n         * set for replication / AOF propagation. */\n        if (dirty) propagate_flags |= (PROPAGATE_AOF|PROPAGATE_REPL);\n\n        /* If the client forced AOF / replication of the command, set\n         * the flags regardless of the command effects on the data set. */\n        if (c->flags & CLIENT_FORCE_REPL) propagate_flags |= PROPAGATE_REPL;\n        if (c->flags & CLIENT_FORCE_AOF) propagate_flags |= PROPAGATE_AOF;\n\n        /* However prevent AOF / replication propagation if the command\n         * implementation called preventCommandPropagation() or similar,\n         * or if we don't have the call() flags to do so. */\n        if (c->flags & CLIENT_PREVENT_REPL_PROP ||\n            !(flags & CMD_CALL_PROPAGATE_REPL))\n                propagate_flags &= ~PROPAGATE_REPL;\n        if (c->flags & CLIENT_PREVENT_AOF_PROP ||\n            !(flags & CMD_CALL_PROPAGATE_AOF))\n                propagate_flags &= ~PROPAGATE_AOF;\n\n        /* Call propagate() only if at least one of AOF / replication\n         * propagation is needed. Note that modules commands handle replication\n         * in an explicit way, so we never replicate them automatically. */\n        if (propagate_flags != PROPAGATE_NONE && !(c->cmd->flags & CMD_MODULE))\n            propagate(c->cmd,c->db->id,c->argv,c->argc,propagate_flags);\n    }\n\n    /* Restore the old replication flags, since call() can be executed\n     * recursively. */\n    c->flags &= ~(CLIENT_FORCE_AOF|CLIENT_FORCE_REPL|CLIENT_PREVENT_PROP);\n    c->flags |= client_old_flags &\n        (CLIENT_FORCE_AOF|CLIENT_FORCE_REPL|CLIENT_PREVENT_PROP);\n\n    /* Handle the alsoPropagate() API to handle commands that want to propagate\n     * multiple separated commands. Note that alsoPropagate() is not affected\n     * by CLIENT_PREVENT_PROP flag. */\n    if (server.also_propagate.numops) {\n        int j;\n        redisOp *rop;\n\n        if (flags & CMD_CALL_PROPAGATE) {\n            int multi_emitted = 0;\n            /* Wrap the commands in server.also_propagate array,\n             * but don't wrap it if we are already in MULTI context,\n             * in case the nested MULTI/EXEC.\n             *\n             * And if the array contains only one command, no need to\n             * wrap it, since the single command is atomic. */\n            if (server.also_propagate.numops > 1 &&\n                !(c->cmd->flags & CMD_MODULE) &&\n                !(c->flags & CLIENT_MULTI) &&\n                !(flags & CMD_CALL_NOWRAP))\n            {\n                execCommandPropagateMulti(c->db->id);\n                multi_emitted = 1;\n            }\n\n            for (j = 0; j < server.also_propagate.numops; j++) {\n                rop = &server.also_propagate.ops[j];\n                int target = rop->target;\n                /* Whatever the command wish is, we honor the call() flags. */\n                if (!(flags&CMD_CALL_PROPAGATE_AOF)) target &= ~PROPAGATE_AOF;\n                if (!(flags&CMD_CALL_PROPAGATE_REPL)) target &= ~PROPAGATE_REPL;\n                if (target)\n                    propagate(rop->cmd,rop->dbid,rop->argv,rop->argc,target);\n            }\n\n            if (multi_emitted) {\n                execCommandPropagateExec(c->db->id);\n            }\n        }\n        redisOpArrayFree(&server.also_propagate);\n    }\n    server.also_propagate = prev_also_propagate;\n\n    /* Client pause takes effect after a transaction has finished. This needs\n     * to be located after everything is propagated. */\n    if (!server.in_exec && server.client_pause_in_transaction) {\n        server.client_pause_in_transaction = 0;\n    }\n\n    /* If the client has keys tracking enabled for client side caching,\n     * make sure to remember the keys it fetched via this command. */\n    if (c->cmd->flags & CMD_READONLY) {\n        client *caller = (c->flags & CLIENT_LUA && server.lua_caller) ?\n                            server.lua_caller : c;\n        if (caller->flags & CLIENT_TRACKING &&\n            !(caller->flags & CLIENT_TRACKING_BCAST))\n        {\n            trackingRememberKeys(caller);\n        }\n    }\n\n    server.fixed_time_expire--;\n    server.stat_numcommands++;\n    prev_err_count = server.stat_total_error_replies;\n\n    /* Record peak memory after each command and before the eviction that runs\n     * before the next command. */\n    size_t zmalloc_used = zmalloc_used_memory();\n    if (zmalloc_used > server.stat_peak_memory)\n        server.stat_peak_memory = zmalloc_used;\n}\n\n/* Used when a command that is ready for execution needs to be rejected, due to\n * varios pre-execution checks. it returns the appropriate error to the client.\n * If there's a transaction is flags it as dirty, and if the command is EXEC,\n * it aborts the transaction.\n * Note: 'reply' is expected to end with \\r\\n */\nvoid rejectCommand(client *c, robj *reply) {\n    flagTransaction(c);\n    if (c->cmd) c->cmd->rejected_calls++;\n    if (c->cmd && c->cmd->proc == execCommand) {\n        execCommandAbort(c, reply->ptr);\n    } else {\n        /* using addReplyError* rather than addReply so that the error can be logged. */\n        addReplyErrorObject(c, reply);\n    }\n}\n\nvoid rejectCommandFormat(client *c, const char *fmt, ...) {\n    if (c->cmd) c->cmd->rejected_calls++;\n    flagTransaction(c);\n    va_list ap;\n    va_start(ap,fmt);\n    sds s = sdscatvprintf(sdsempty(),fmt,ap);\n    va_end(ap);\n    /* Make sure there are no newlines in the string, otherwise invalid protocol\n     * is emitted (The args come from the user, they may contain any character). */\n    sdsmapchars(s, \"\\r\\n\", \"  \",  2);\n    if (c->cmd && c->cmd->proc == execCommand) {\n        execCommandAbort(c, s);\n        sdsfree(s);\n    } else {\n        /* The following frees 's'. */\n        addReplyErrorSds(c, s);\n    }\n}\n\n/* Returns 1 for commands that may have key names in their arguments, but have\n * no pre-determined key positions. */\nstatic int cmdHasMovableKeys(struct redisCommand *cmd) {\n    return (cmd->getkeys_proc && !(cmd->flags & CMD_MODULE)) ||\n            cmd->flags & CMD_MODULE_GETKEYS;\n}\n\n/* If this function gets called we already read a whole\n * command, arguments are in the client argv/argc fields.\n * processCommand() execute the command or prepare the\n * server for a bulk read from the client.\n *\n * If C_OK is returned the client is still alive and valid and\n * other operations can be performed by the caller. Otherwise\n * if C_ERR is returned the client was destroyed (i.e. after QUIT). */\nint processCommand(client *c) {\n    if (!server.lua_timedout) {\n        /* Both EXEC and EVAL call call() directly so there should be\n         * no way in_exec or in_eval or propagate_in_transaction is 1.\n         * That is unless lua_timedout, in which case client may run\n         * some commands. */\n        serverAssert(!server.propagate_in_transaction);\n        serverAssert(!server.in_exec);\n        serverAssert(!server.in_eval);\n    }\n\n    moduleCallCommandFilters(c);\n\n    /* The QUIT command is handled separately. Normal command procs will\n     * go through checking for replication and QUIT will cause trouble\n     * when FORCE_REPLICATION is enabled and would be implemented in\n     * a regular command proc. */\n    if (!strcasecmp(c->argv[0]->ptr,\"quit\")) {\n        addReply(c,shared.ok);\n        c->flags |= CLIENT_CLOSE_AFTER_REPLY;\n        return C_ERR;\n    }\n\n    /* Now lookup the command and check ASAP about trivial error conditions\n     * such as wrong arity, bad command name and so forth. */\n    c->cmd = c->lastcmd = lookupCommand(c->argv[0]->ptr);\n    if (!c->cmd) {\n        sds args = sdsempty();\n        int i;\n        for (i=1; i < c->argc && sdslen(args) < 128; i++)\n            args = sdscatprintf(args, \"`%.*s`, \", 128-(int)sdslen(args), (char*)c->argv[i]->ptr);\n        rejectCommandFormat(c,\"unknown command `%s`, with args beginning with: %s\",\n            (char*)c->argv[0]->ptr, args);\n        sdsfree(args);\n        return C_OK;\n    } else if ((c->cmd->arity > 0 && c->cmd->arity != c->argc) ||\n               (c->argc < -c->cmd->arity)) {\n        rejectCommandFormat(c,\"wrong number of arguments for '%s' command\",\n            c->cmd->name);\n        return C_OK;\n    }\n\n    int is_read_command = (c->cmd->flags & CMD_READONLY) ||\n                           (c->cmd->proc == execCommand && (c->mstate.cmd_flags & CMD_READONLY));\n    int is_write_command = (c->cmd->flags & CMD_WRITE) ||\n                           (c->cmd->proc == execCommand && (c->mstate.cmd_flags & CMD_WRITE));\n    int is_denyoom_command = (c->cmd->flags & CMD_DENYOOM) ||\n                             (c->cmd->proc == execCommand && (c->mstate.cmd_flags & CMD_DENYOOM));\n    int is_denystale_command = !(c->cmd->flags & CMD_STALE) ||\n                               (c->cmd->proc == execCommand && (c->mstate.cmd_inv_flags & CMD_STALE));\n    int is_denyloading_command = !(c->cmd->flags & CMD_LOADING) ||\n                                 (c->cmd->proc == execCommand && (c->mstate.cmd_inv_flags & CMD_LOADING));\n    int is_may_replicate_command = (c->cmd->flags & (CMD_WRITE | CMD_MAY_REPLICATE)) ||\n                                   (c->cmd->proc == execCommand && (c->mstate.cmd_flags & (CMD_WRITE | CMD_MAY_REPLICATE)));\n\n    /* Check if the user is authenticated. This check is skipped in case\n     * the default user is flagged as \"nopass\" and is active. */\n    int auth_required = (!(DefaultUser->flags & USER_FLAG_NOPASS) ||\n                          (DefaultUser->flags & USER_FLAG_DISABLED)) &&\n                        !c->authenticated;\n    if (auth_required) {\n        /* AUTH and HELLO and no auth modules are valid even in\n         * non-authenticated state. */\n        if (!(c->cmd->flags & CMD_NO_AUTH)) {\n            rejectCommand(c,shared.noautherr);\n            return C_OK;\n        }\n    }\n\n    /* Check if the user can run this command according to the current\n     * ACLs. */\n    int acl_errpos;\n    int acl_retval = ACLCheckAllPerm(c,&acl_errpos);\n    if (acl_retval != ACL_OK) {\n        addACLLogEntry(c,acl_retval,acl_errpos,NULL);\n        switch (acl_retval) {\n        case ACL_DENIED_CMD:\n            rejectCommandFormat(c,\n                \"-NOPERM this user has no permissions to run \"\n                \"the '%s' command or its subcommand\", c->cmd->name);\n            break;\n        case ACL_DENIED_KEY:\n            rejectCommandFormat(c,\n                \"-NOPERM this user has no permissions to access \"\n                \"one of the keys used as arguments\");\n            break;\n        case ACL_DENIED_CHANNEL:\n            rejectCommandFormat(c,\n                \"-NOPERM this user has no permissions to access \"\n                \"one of the channels used as arguments\");\n            break;\n        default:\n            rejectCommandFormat(c, \"no permission\");\n            break;\n        }\n        return C_OK;\n    }\n\n    /* If cluster is enabled perform the cluster redirection here.\n     * However we don't perform the redirection if:\n     * 1) The sender of this command is our master.\n     * 2) The command has no key arguments. */\n    if (server.cluster_enabled &&\n        !(c->flags & CLIENT_MASTER) &&\n        !(c->flags & CLIENT_LUA &&\n          server.lua_caller->flags & CLIENT_MASTER) &&\n        !(!cmdHasMovableKeys(c->cmd) && c->cmd->firstkey == 0 &&\n          c->cmd->proc != execCommand))\n    {\n        int hashslot;\n        int error_code;\n        clusterNode *n = getNodeByQuery(c,c->cmd,c->argv,c->argc,\n                                        &hashslot,&error_code);\n        if (n == NULL || n != server.cluster->myself) {\n            if (c->cmd->proc == execCommand) {\n                discardTransaction(c);\n            } else {\n                flagTransaction(c);\n            }\n            clusterRedirectClient(c,n,hashslot,error_code);\n            c->cmd->rejected_calls++;\n            return C_OK;\n        }\n    }\n\n    /* Handle the maxmemory directive.\n     *\n     * Note that we do not want to reclaim memory if we are here re-entering\n     * the event loop since there is a busy Lua script running in timeout\n     * condition, to avoid mixing the propagation of scripts with the\n     * propagation of DELs due to eviction. */\n    if (server.maxmemory && !server.lua_timedout) {\n        int out_of_memory = (performEvictions() == EVICT_FAIL);\n        /* performEvictions may flush slave output buffers. This may result\n         * in a slave, that may be the active client, to be freed. */\n        if (server.current_client == NULL) return C_ERR;\n\n        int reject_cmd_on_oom = is_denyoom_command;\n        /* If client is in MULTI/EXEC context, queuing may consume an unlimited\n         * amount of memory, so we want to stop that.\n         * However, we never want to reject DISCARD, or even EXEC (unless it\n         * contains denied commands, in which case is_denyoom_command is already\n         * set. */\n        if (c->flags & CLIENT_MULTI &&\n            c->cmd->proc != execCommand &&\n            c->cmd->proc != discardCommand &&\n            c->cmd->proc != resetCommand) {\n            reject_cmd_on_oom = 1;\n        }\n\n        if (out_of_memory && reject_cmd_on_oom) {\n            rejectCommand(c, shared.oomerr);\n            return C_OK;\n        }\n\n        /* Save out_of_memory result at script start, otherwise if we check OOM\n         * until first write within script, memory used by lua stack and\n         * arguments might interfere. */\n        if (c->cmd->proc == evalCommand || c->cmd->proc == evalShaCommand) {\n            server.lua_oom = out_of_memory;\n        }\n    }\n\n    /* Make sure to use a reasonable amount of memory for client side\n     * caching metadata. */\n    if (server.tracking_clients) trackingLimitUsedSlots();\n\n    /* Don't accept write commands if there are problems persisting on disk\n     * and if this is a master instance. */\n    int deny_write_type = writeCommandsDeniedByDiskError();\n    if (deny_write_type != DISK_ERROR_TYPE_NONE &&\n        server.masterhost == NULL &&\n        (is_write_command ||c->cmd->proc == pingCommand))\n    {\n        if (deny_write_type == DISK_ERROR_TYPE_RDB)\n            rejectCommand(c, shared.bgsaveerr);\n        else\n            rejectCommandFormat(c,\n                \"-MISCONF Errors writing to the AOF file: %s\",\n                strerror(server.aof_last_write_errno));\n        return C_OK;\n    }\n\n    /* Don't accept write commands if there are not enough good slaves and\n     * user configured the min-slaves-to-write option. */\n    if (server.masterhost == NULL &&\n        server.repl_min_slaves_to_write &&\n        server.repl_min_slaves_max_lag &&\n        is_write_command &&\n        server.repl_good_slaves_count < server.repl_min_slaves_to_write)\n    {\n        rejectCommand(c, shared.noreplicaserr);\n        return C_OK;\n    }\n\n    /* Don't accept write commands if this is a read only slave. But\n     * accept write commands if this is our master. */\n    if (server.masterhost && server.repl_slave_ro &&\n        !(c->flags & CLIENT_MASTER) &&\n        is_write_command)\n    {\n        rejectCommand(c, shared.roslaveerr);\n        return C_OK;\n    }\n\n    /* Only allow a subset of commands in the context of Pub/Sub if the\n     * connection is in RESP2 mode. With RESP3 there are no limits. */\n    if ((c->flags & CLIENT_PUBSUB && c->resp == 2) &&\n        c->cmd->proc != pingCommand &&\n        c->cmd->proc != subscribeCommand &&\n        c->cmd->proc != unsubscribeCommand &&\n        c->cmd->proc != psubscribeCommand &&\n        c->cmd->proc != punsubscribeCommand &&\n        c->cmd->proc != resetCommand) {\n        rejectCommandFormat(c,\n            \"Can't execute '%s': only (P)SUBSCRIBE / \"\n            \"(P)UNSUBSCRIBE / PING / QUIT / RESET are allowed in this context\",\n            c->cmd->name);\n        return C_OK;\n    }\n\n    /* Only allow commands with flag \"t\", such as INFO, SLAVEOF and so on,\n     * when slave-serve-stale-data is no and we are a slave with a broken\n     * link with master. */\n    if (server.masterhost && server.repl_state != REPL_STATE_CONNECTED &&\n        server.repl_serve_stale_data == 0 &&\n        is_denystale_command)\n    {\n        rejectCommand(c, shared.masterdownerr);\n        return C_OK;\n    }\n\n    /* Loading DB? Return an error if the command has not the\n     * CMD_LOADING flag. */\n    if (server.loading && is_denyloading_command) {\n        rejectCommand(c, shared.loadingerr);\n        return C_OK;\n    }\n\n    /* Lua script too slow? Only allow a limited number of commands.\n     * Note that we need to allow the transactions commands, otherwise clients\n     * sending a transaction with pipelining without error checking, may have\n     * the MULTI plus a few initial commands refused, then the timeout\n     * condition resolves, and the bottom-half of the transaction gets\n     * executed, see Github PR #7022. */\n    if (server.lua_timedout &&\n          c->cmd->proc != authCommand &&\n          c->cmd->proc != helloCommand &&\n          c->cmd->proc != replconfCommand &&\n          c->cmd->proc != multiCommand &&\n          c->cmd->proc != discardCommand &&\n          c->cmd->proc != watchCommand &&\n          c->cmd->proc != unwatchCommand &&\n          c->cmd->proc != resetCommand &&\n        !(c->cmd->proc == shutdownCommand &&\n          c->argc == 2 &&\n          tolower(((char*)c->argv[1]->ptr)[0]) == 'n') &&\n        !(c->cmd->proc == scriptCommand &&\n          c->argc == 2 &&\n          tolower(((char*)c->argv[1]->ptr)[0]) == 'k'))\n    {\n        rejectCommand(c, shared.slowscripterr);\n        return C_OK;\n    }\n\n    /* Prevent a replica from sending commands that access the keyspace.\n     * The main objective here is to prevent abuse of client pause check\n     * from which replicas are exempt. */\n    if ((c->flags & CLIENT_SLAVE) && (is_may_replicate_command || is_write_command || is_read_command)) {\n        rejectCommandFormat(c, \"Replica can't interract with the keyspace\");\n        return C_OK;\n    }\n\n    /* If the server is paused, block the client until\n     * the pause has ended. Replicas are never paused. */\n    if (!(c->flags & CLIENT_SLAVE) && \n        ((server.client_pause_type == CLIENT_PAUSE_ALL) ||\n        (server.client_pause_type == CLIENT_PAUSE_WRITE && is_may_replicate_command)))\n    {\n        c->bpop.timeout = 0;\n        blockClient(c,BLOCKED_PAUSE);\n        return C_OK;       \n    }\n\n    /* Exec the command */\n    if (c->flags & CLIENT_MULTI &&\n        c->cmd->proc != execCommand && c->cmd->proc != discardCommand &&\n        c->cmd->proc != multiCommand && c->cmd->proc != watchCommand &&\n        c->cmd->proc != resetCommand)\n    {\n        queueMultiCommand(c);\n        addReply(c,shared.queued);\n    } else {\n        call(c,CMD_CALL_FULL);\n        c->woff = server.master_repl_offset;\n        if (listLength(server.ready_keys))\n            handleClientsBlockedOnKeys();\n    }\n\n    return C_OK;\n}\n\n/* ====================== Error lookup and execution ===================== */\n\nvoid incrementErrorCount(const char *fullerr, size_t namelen) {\n    struct redisError *error = raxFind(server.errors,(unsigned char*)fullerr,namelen);\n    if (error == raxNotFound) {\n        error = zmalloc(sizeof(*error));\n        error->count = 0;\n        raxInsert(server.errors,(unsigned char*)fullerr,namelen,error,NULL);\n    }\n    error->count++;\n}\n\n/*================================== Shutdown =============================== */\n\n/* Close listening sockets. Also unlink the unix domain socket if\n * unlink_unix_socket is non-zero. */\nvoid closeListeningSockets(int unlink_unix_socket) {\n    int j;\n\n    for (j = 0; j < server.ipfd.count; j++) close(server.ipfd.fd[j]);\n    for (j = 0; j < server.tlsfd.count; j++) close(server.tlsfd.fd[j]);\n    if (server.sofd != -1) close(server.sofd);\n    if (server.cluster_enabled)\n        for (j = 0; j < server.cfd.count; j++) close(server.cfd.fd[j]);\n    if (unlink_unix_socket && server.unixsocket) {\n        serverLog(LL_NOTICE,\"Removing the unix socket file.\");\n        unlink(server.unixsocket); /* don't care if this fails */\n    }\n}\n\nint prepareForShutdown(int flags) {\n    /* When SHUTDOWN is called while the server is loading a dataset in\n     * memory we need to make sure no attempt is performed to save\n     * the dataset on shutdown (otherwise it could overwrite the current DB\n     * with half-read data).\n     *\n     * Also when in Sentinel mode clear the SAVE flag and force NOSAVE. */\n    if (server.loading || server.sentinel_mode)\n        flags = (flags & ~SHUTDOWN_SAVE) | SHUTDOWN_NOSAVE;\n\n    int save = flags & SHUTDOWN_SAVE;\n    int nosave = flags & SHUTDOWN_NOSAVE;\n\n    serverLog(LL_WARNING,\"User requested shutdown...\");\n    if (server.supervised_mode == SUPERVISED_SYSTEMD)\n        redisCommunicateSystemd(\"STOPPING=1\\n\");\n\n    /* Kill all the Lua debugger forked sessions. */\n    ldbKillForkedSessions();\n\n    /* Kill the saving child if there is a background saving in progress.\n       We want to avoid race conditions, for instance our saving child may\n       overwrite the synchronous saving did by SHUTDOWN. */\n    if (server.child_type == CHILD_TYPE_RDB) {\n        serverLog(LL_WARNING,\"There is a child saving an .rdb. Killing it!\");\n        killRDBChild();\n        /* Note that, in killRDBChild normally has backgroundSaveDoneHandler\n         * doing it's cleanup, but in this case this code will not be reached,\n         * so we need to call rdbRemoveTempFile which will close fd(in order\n         * to unlink file actully) in background thread.\n         * The temp rdb file fd may won't be closed when redis exits quickly,\n         * but OS will close this fd when process exits. */\n        rdbRemoveTempFile(server.child_pid, 0);\n    }\n\n    /* Kill module child if there is one. */\n    if (server.child_type == CHILD_TYPE_MODULE) {\n        serverLog(LL_WARNING,\"There is a module fork child. Killing it!\");\n        TerminateModuleForkChild(server.child_pid,0);\n    }\n\n    if (server.aof_state != AOF_OFF) {\n        /* Kill the AOF saving child as the AOF we already have may be longer\n         * but contains the full dataset anyway. */\n        if (server.child_type == CHILD_TYPE_AOF) {\n            /* If we have AOF enabled but haven't written the AOF yet, don't\n             * shutdown or else the dataset will be lost. */\n            if (server.aof_state == AOF_WAIT_REWRITE) {\n                serverLog(LL_WARNING, \"Writing initial AOF, can't exit.\");\n                return C_ERR;\n            }\n            serverLog(LL_WARNING,\n                \"There is a child rewriting the AOF. Killing it!\");\n            killAppendOnlyChild();\n        }\n        /* Append only file: flush buffers and fsync() the AOF at exit */\n        serverLog(LL_NOTICE,\"Calling fsync() on the AOF file.\");\n        flushAppendOnlyFile(1);\n        if (redis_fsync(server.aof_fd) == -1) {\n            serverLog(LL_WARNING,\"Fail to fsync the AOF file: %s.\",\n                                 strerror(errno));\n        }\n    }\n\n    /* Create a new RDB file before exiting. */\n    if ((server.saveparamslen > 0 && !nosave) || save) {\n        serverLog(LL_NOTICE,\"Saving the final RDB snapshot before exiting.\");\n        if (server.supervised_mode == SUPERVISED_SYSTEMD)\n            redisCommunicateSystemd(\"STATUS=Saving the final RDB snapshot\\n\");\n        /* Snapshotting. Perform a SYNC SAVE and exit */\n        rdbSaveInfo rsi, *rsiptr;\n        rsiptr = rdbPopulateSaveInfo(&rsi);\n        if (rdbSave(server.rdb_filename,rsiptr) != C_OK) {\n            /* Ooops.. error saving! The best we can do is to continue\n             * operating. Note that if there was a background saving process,\n             * in the next cron() Redis will be notified that the background\n             * saving aborted, handling special stuff like slaves pending for\n             * synchronization... */\n            serverLog(LL_WARNING,\"Error trying to save the DB, can't exit.\");\n            if (server.supervised_mode == SUPERVISED_SYSTEMD)\n                redisCommunicateSystemd(\"STATUS=Error trying to save the DB, can't exit.\\n\");\n            return C_ERR;\n        }\n    }\n\n    /* Fire the shutdown modules event. */\n    moduleFireServerEvent(REDISMODULE_EVENT_SHUTDOWN,0,NULL);\n\n    /* Remove the pid file if possible and needed. */\n    if (server.daemonize || server.pidfile) {\n        serverLog(LL_NOTICE,\"Removing the pid file.\");\n        unlink(server.pidfile);\n    }\n\n    /* Best effort flush of slave output buffers, so that we hopefully\n     * send them pending writes. */\n    flushSlavesOutputBuffers();\n\n    /* Close the listening sockets. Apparently this allows faster restarts. */\n    closeListeningSockets(1);\n    serverLog(LL_WARNING,\"%s is now ready to exit, bye bye...\",\n        server.sentinel_mode ? \"Sentinel\" : \"Redis\");\n    return C_OK;\n}\n\n/*================================== Commands =============================== */\n\n/* Sometimes Redis cannot accept write commands because there is a persistence\n * error with the RDB or AOF file, and Redis is configured in order to stop\n * accepting writes in such situation. This function returns if such a\n * condition is active, and the type of the condition.\n *\n * Function return values:\n *\n * DISK_ERROR_TYPE_NONE:    No problems, we can accept writes.\n * DISK_ERROR_TYPE_AOF:     Don't accept writes: AOF errors.\n * DISK_ERROR_TYPE_RDB:     Don't accept writes: RDB errors.\n */\nint writeCommandsDeniedByDiskError(void) {\n    if (server.stop_writes_on_bgsave_err &&\n        server.saveparamslen > 0 &&\n        server.lastbgsave_status == C_ERR)\n    {\n        return DISK_ERROR_TYPE_RDB;\n    } else if (server.aof_state != AOF_OFF) {\n        if (server.aof_last_write_status == C_ERR) {\n            return DISK_ERROR_TYPE_AOF;\n        }\n        /* AOF fsync error. */\n        int aof_bio_fsync_status;\n        atomicGet(server.aof_bio_fsync_status,aof_bio_fsync_status);\n        if (aof_bio_fsync_status == C_ERR) {\n            atomicGet(server.aof_bio_fsync_errno,server.aof_last_write_errno);\n            return DISK_ERROR_TYPE_AOF;\n        }\n    }\n\n    return DISK_ERROR_TYPE_NONE;\n}\n\n/* The PING command. It works in a different way if the client is in\n * in Pub/Sub mode. */\nvoid pingCommand(client *c) {\n    /* The command takes zero or one arguments. */\n    if (c->argc > 2) {\n        addReplyErrorFormat(c,\"wrong number of arguments for '%s' command\",\n            c->cmd->name);\n        return;\n    }\n\n    if (c->flags & CLIENT_PUBSUB && c->resp == 2) {\n        addReply(c,shared.mbulkhdr[2]);\n        addReplyBulkCBuffer(c,\"pong\",4);\n        if (c->argc == 1)\n            addReplyBulkCBuffer(c,\"\",0);\n        else\n            addReplyBulk(c,c->argv[1]);\n    } else {\n        if (c->argc == 1)\n            addReply(c,shared.pong);\n        else\n            addReplyBulk(c,c->argv[1]);\n    }\n}\n\nvoid echoCommand(client *c) {\n    addReplyBulk(c,c->argv[1]);\n}\n\nvoid timeCommand(client *c) {\n    struct timeval tv;\n\n    /* gettimeofday() can only fail if &tv is a bad address so we\n     * don't check for errors. */\n    gettimeofday(&tv,NULL);\n    addReplyArrayLen(c,2);\n    addReplyBulkLongLong(c,tv.tv_sec);\n    addReplyBulkLongLong(c,tv.tv_usec);\n}\n\n/* Helper function for addReplyCommand() to output flags. */\nint addReplyCommandFlag(client *c, struct redisCommand *cmd, int f, char *reply) {\n    if (cmd->flags & f) {\n        addReplyStatus(c, reply);\n        return 1;\n    }\n    return 0;\n}\n\n/* Output the representation of a Redis command. Used by the COMMAND command. */\nvoid addReplyCommand(client *c, struct redisCommand *cmd) {\n    if (!cmd) {\n        addReplyNull(c);\n    } else {\n        /* We are adding: command name, arg count, flags, first, last, offset, categories */\n        addReplyArrayLen(c, 7);\n        addReplyBulkCString(c, cmd->name);\n        addReplyLongLong(c, cmd->arity);\n\n        int flagcount = 0;\n        void *flaglen = addReplyDeferredLen(c);\n        flagcount += addReplyCommandFlag(c,cmd,CMD_WRITE, \"write\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_READONLY, \"readonly\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_DENYOOM, \"denyoom\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_ADMIN, \"admin\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_PUBSUB, \"pubsub\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_NOSCRIPT, \"noscript\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_RANDOM, \"random\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_SORT_FOR_SCRIPT,\"sort_for_script\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_LOADING, \"loading\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_STALE, \"stale\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_SKIP_MONITOR, \"skip_monitor\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_SKIP_SLOWLOG, \"skip_slowlog\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_ASKING, \"asking\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_FAST, \"fast\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_NO_AUTH, \"no_auth\");\n        flagcount += addReplyCommandFlag(c,cmd,CMD_MAY_REPLICATE, \"may_replicate\");\n        if (cmdHasMovableKeys(cmd)) {\n            addReplyStatus(c, \"movablekeys\");\n            flagcount += 1;\n        }\n        setDeferredSetLen(c, flaglen, flagcount);\n\n        addReplyLongLong(c, cmd->firstkey);\n        addReplyLongLong(c, cmd->lastkey);\n        addReplyLongLong(c, cmd->keystep);\n\n        addReplyCommandCategories(c,cmd);\n    }\n}\n\n/* COMMAND <subcommand> <args> */\nvoid commandCommand(client *c) {\n    dictIterator *di;\n    dictEntry *de;\n\n    if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,\"help\")) {\n        const char *help[] = {\n\"(no subcommand)\",\n\"    Return details about all Redis commands.\",\n\"COUNT\",\n\"    Return the total number of commands in this Redis server.\",\n\"GETKEYS <full-command>\",\n\"    Return the keys from a full Redis command.\",\n\"INFO [<command-name> ...]\",\n\"    Return details about multiple Redis commands.\",\nNULL\n        };\n        addReplyHelp(c, help);\n    } else if (c->argc == 1) {\n        addReplyArrayLen(c, dictSize(server.commands));\n        di = dictGetIterator(server.commands);\n        while ((de = dictNext(di)) != NULL) {\n            addReplyCommand(c, dictGetVal(de));\n        }\n        dictReleaseIterator(di);\n    } else if (!strcasecmp(c->argv[1]->ptr, \"info\")) {\n        int i;\n        addReplyArrayLen(c, c->argc-2);\n        for (i = 2; i < c->argc; i++) {\n            addReplyCommand(c, dictFetchValue(server.commands, c->argv[i]->ptr));\n        }\n    } else if (!strcasecmp(c->argv[1]->ptr, \"count\") && c->argc == 2) {\n        addReplyLongLong(c, dictSize(server.commands));\n    } else if (!strcasecmp(c->argv[1]->ptr,\"getkeys\") && c->argc >= 3) {\n        struct redisCommand *cmd = lookupCommand(c->argv[2]->ptr);\n        getKeysResult result = GETKEYS_RESULT_INIT;\n        int j;\n\n        if (!cmd) {\n            addReplyError(c,\"Invalid command specified\");\n            return;\n        } else if (cmd->getkeys_proc == NULL && cmd->firstkey == 0) {\n            addReplyError(c,\"The command has no key arguments\");\n            return;\n        } else if ((cmd->arity > 0 && cmd->arity != c->argc-2) ||\n                   ((c->argc-2) < -cmd->arity))\n        {\n            addReplyError(c,\"Invalid number of arguments specified for command\");\n            return;\n        }\n\n        if (!getKeysFromCommand(cmd,c->argv+2,c->argc-2,&result)) {\n            addReplyError(c,\"Invalid arguments specified for command\");\n        } else {\n            addReplyArrayLen(c,result.numkeys);\n            for (j = 0; j < result.numkeys; j++) addReplyBulk(c,c->argv[result.keys[j]+2]);\n        }\n        getKeysFreeResult(&result);\n    } else {\n        addReplySubcommandSyntaxError(c);\n    }\n}\n\n/* Convert an amount of bytes into a human readable string in the form\n * of 100B, 2G, 100M, 4K, and so forth. */\nvoid bytesToHuman(char *s, unsigned long long n) {\n    double d;\n\n    if (n < 1024) {\n        /* Bytes */\n        sprintf(s,\"%lluB\",n);\n    } else if (n < (1024*1024)) {\n        d = (double)n/(1024);\n        sprintf(s,\"%.2fK\",d);\n    } else if (n < (1024LL*1024*1024)) {\n        d = (double)n/(1024*1024);\n        sprintf(s,\"%.2fM\",d);\n    } else if (n < (1024LL*1024*1024*1024)) {\n        d = (double)n/(1024LL*1024*1024);\n        sprintf(s,\"%.2fG\",d);\n    } else if (n < (1024LL*1024*1024*1024*1024)) {\n        d = (double)n/(1024LL*1024*1024*1024);\n        sprintf(s,\"%.2fT\",d);\n    } else if (n < (1024LL*1024*1024*1024*1024*1024)) {\n        d = (double)n/(1024LL*1024*1024*1024*1024);\n        sprintf(s,\"%.2fP\",d);\n    } else {\n        /* Let's hope we never need this */\n        sprintf(s,\"%lluB\",n);\n    }\n}\n\n/* Characters we sanitize on INFO output to maintain expected format. */\nstatic char unsafe_info_chars[] = \"#:\\n\\r\";\nstatic char unsafe_info_chars_substs[] = \"____\";   /* Must be same length as above */\n\n/* Returns a sanitized version of s that contains no unsafe info string chars.\n * If no unsafe characters are found, simply returns s. Caller needs to\n * free tmp if it is non-null on return.\n */\nconst char *getSafeInfoString(const char *s, size_t len, char **tmp) {\n    *tmp = NULL;\n    if (mempbrk(s, len, unsafe_info_chars,sizeof(unsafe_info_chars)-1)\n        == NULL) return s;\n    char *new = *tmp = zmalloc(len + 1);\n    memcpy(new, s, len);\n    new[len] = '\\0';\n    return memmapchars(new, len, unsafe_info_chars, unsafe_info_chars_substs,\n                       sizeof(unsafe_info_chars)-1);\n}\n\n/* Create the string returned by the INFO command. This is decoupled\n * by the INFO command itself as we need to report the same information\n * on memory corruption problems. */\nsds genRedisInfoString(const char *section) {\n    sds info = sdsempty();\n    time_t uptime = server.unixtime-server.stat_starttime;\n    int j;\n    int allsections = 0, defsections = 0, everything = 0, modules = 0;\n    int sections = 0;\n\n    if (section == NULL) section = \"default\";\n    allsections = strcasecmp(section,\"all\") == 0;\n    defsections = strcasecmp(section,\"default\") == 0;\n    everything = strcasecmp(section,\"everything\") == 0;\n    modules = strcasecmp(section,\"modules\") == 0;\n    if (everything) allsections = 1;\n\n    /* Server */\n    if (allsections || defsections || !strcasecmp(section,\"server\")) {\n        static int call_uname = 1;\n        static struct utsname name;\n        char *mode;\n        char *supervised;\n\n        if (server.cluster_enabled) mode = \"cluster\";\n        else if (server.sentinel_mode) mode = \"sentinel\";\n        else mode = \"standalone\";\n\n        if (server.supervised) {\n            if (server.supervised_mode == SUPERVISED_UPSTART) supervised = \"upstart\";\n            else if (server.supervised_mode == SUPERVISED_SYSTEMD) supervised = \"systemd\";\n            else supervised = \"unknown\";\n        } else {\n            supervised = \"no\";\n        }\n\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n\n        if (call_uname) {\n            /* Uname can be slow and is always the same output. Cache it. */\n            uname(&name);\n            call_uname = 0;\n        }\n\n        unsigned int lruclock;\n        atomicGet(server.lruclock,lruclock);\n        info = sdscatfmt(info,\n            \"# Server\\r\\n\"\n            \"redis_version:%s\\r\\n\"\n            \"redis_git_sha1:%s\\r\\n\"\n            \"redis_git_dirty:%i\\r\\n\"\n            \"redis_build_id:%s\\r\\n\"\n            \"redis_mode:%s\\r\\n\"\n            \"os:%s %s %s\\r\\n\"\n            \"arch_bits:%i\\r\\n\"\n            \"multiplexing_api:%s\\r\\n\"\n            \"atomicvar_api:%s\\r\\n\"\n            \"gcc_version:%i.%i.%i\\r\\n\"\n            \"process_id:%I\\r\\n\"\n            \"process_supervised:%s\\r\\n\"\n            \"run_id:%s\\r\\n\"\n            \"tcp_port:%i\\r\\n\"\n            \"server_time_usec:%I\\r\\n\"\n            \"uptime_in_seconds:%I\\r\\n\"\n            \"uptime_in_days:%I\\r\\n\"\n            \"hz:%i\\r\\n\"\n            \"configured_hz:%i\\r\\n\"\n            \"lru_clock:%u\\r\\n\"\n            \"executable:%s\\r\\n\"\n            \"config_file:%s\\r\\n\"\n            \"io_threads_active:%i\\r\\n\",\n            REDIS_VERSION,\n            redisGitSHA1(),\n            strtol(redisGitDirty(),NULL,10) > 0,\n            redisBuildIdString(),\n            mode,\n            name.sysname, name.release, name.machine,\n            server.arch_bits,\n            aeGetApiName(),\n            REDIS_ATOMIC_API,\n#ifdef __GNUC__\n            __GNUC__,__GNUC_MINOR__,__GNUC_PATCHLEVEL__,\n#else\n            0,0,0,\n#endif\n            (int64_t) getpid(),\n            supervised,\n            server.runid,\n            server.port ? server.port : server.tls_port,\n            (int64_t)server.ustime,\n            (int64_t)uptime,\n            (int64_t)(uptime/(3600*24)),\n            server.hz,\n            server.config_hz,\n            lruclock,\n            server.executable ? server.executable : \"\",\n            server.configfile ? server.configfile : \"\",\n            server.io_threads_active);\n    }\n\n    /* Clients */\n    if (allsections || defsections || !strcasecmp(section,\"clients\")) {\n        size_t maxin, maxout;\n        getExpansiveClientsInfo(&maxin,&maxout);\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n        info = sdscatprintf(info,\n            \"# Clients\\r\\n\"\n            \"connected_clients:%lu\\r\\n\"\n            \"cluster_connections:%lu\\r\\n\"\n            \"maxclients:%u\\r\\n\"\n            \"client_recent_max_input_buffer:%zu\\r\\n\"\n            \"client_recent_max_output_buffer:%zu\\r\\n\"\n            \"blocked_clients:%d\\r\\n\"\n            \"tracking_clients:%d\\r\\n\"\n            \"clients_in_timeout_table:%llu\\r\\n\",\n            listLength(server.clients)-listLength(server.slaves),\n            getClusterConnectionsCount(),\n            server.maxclients,\n            maxin, maxout,\n            server.blocked_clients,\n            server.tracking_clients,\n            (unsigned long long) raxSize(server.clients_timeout_table));\n    }\n\n    /* Memory */\n    if (allsections || defsections || !strcasecmp(section,\"memory\")) {\n        char hmem[64];\n        char peak_hmem[64];\n        char total_system_hmem[64];\n        char used_memory_lua_hmem[64];\n        char used_memory_scripts_hmem[64];\n        char used_memory_rss_hmem[64];\n        char maxmemory_hmem[64];\n        size_t zmalloc_used = zmalloc_used_memory();\n        size_t total_system_mem = server.system_memory_size;\n        const char *evict_policy = evictPolicyToString();\n        long long memory_lua = server.lua ? (long long)lua_gc(server.lua,LUA_GCCOUNT,0)*1024 : 0;\n        struct redisMemOverhead *mh = getMemoryOverheadData();\n\n        /* Peak memory is updated from time to time by serverCron() so it\n         * may happen that the instantaneous value is slightly bigger than\n         * the peak value. This may confuse users, so we update the peak\n         * if found smaller than the current memory usage. */\n        if (zmalloc_used > server.stat_peak_memory)\n            server.stat_peak_memory = zmalloc_used;\n\n        bytesToHuman(hmem,zmalloc_used);\n        bytesToHuman(peak_hmem,server.stat_peak_memory);\n        bytesToHuman(total_system_hmem,total_system_mem);\n        bytesToHuman(used_memory_lua_hmem,memory_lua);\n        bytesToHuman(used_memory_scripts_hmem,mh->lua_caches);\n        bytesToHuman(used_memory_rss_hmem,server.cron_malloc_stats.process_rss);\n        bytesToHuman(maxmemory_hmem,server.maxmemory);\n\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n        info = sdscatprintf(info,\n            \"# Memory\\r\\n\"\n            \"used_memory:%zu\\r\\n\"\n            \"used_memory_human:%s\\r\\n\"\n            \"used_memory_rss:%zu\\r\\n\"\n            \"used_memory_rss_human:%s\\r\\n\"\n            \"used_memory_peak:%zu\\r\\n\"\n            \"used_memory_peak_human:%s\\r\\n\"\n            \"used_memory_peak_perc:%.2f%%\\r\\n\"\n            \"used_memory_overhead:%zu\\r\\n\"\n            \"used_memory_startup:%zu\\r\\n\"\n            \"used_memory_dataset:%zu\\r\\n\"\n            \"used_memory_dataset_perc:%.2f%%\\r\\n\"\n            \"allocator_allocated:%zu\\r\\n\"\n            \"allocator_active:%zu\\r\\n\"\n            \"allocator_resident:%zu\\r\\n\"\n            \"total_system_memory:%lu\\r\\n\"\n            \"total_system_memory_human:%s\\r\\n\"\n            \"used_memory_lua:%lld\\r\\n\"\n            \"used_memory_lua_human:%s\\r\\n\"\n            \"used_memory_scripts:%lld\\r\\n\"\n            \"used_memory_scripts_human:%s\\r\\n\"\n            \"number_of_cached_scripts:%lu\\r\\n\"\n            \"maxmemory:%lld\\r\\n\"\n            \"maxmemory_human:%s\\r\\n\"\n            \"maxmemory_policy:%s\\r\\n\"\n            \"allocator_frag_ratio:%.2f\\r\\n\"\n            \"allocator_frag_bytes:%zu\\r\\n\"\n            \"allocator_rss_ratio:%.2f\\r\\n\"\n            \"allocator_rss_bytes:%zd\\r\\n\"\n            \"rss_overhead_ratio:%.2f\\r\\n\"\n            \"rss_overhead_bytes:%zd\\r\\n\"\n            \"mem_fragmentation_ratio:%.2f\\r\\n\"\n            \"mem_fragmentation_bytes:%zd\\r\\n\"\n            \"mem_not_counted_for_evict:%zu\\r\\n\"\n            \"mem_replication_backlog:%zu\\r\\n\"\n            \"mem_clients_slaves:%zu\\r\\n\"\n            \"mem_clients_normal:%zu\\r\\n\"\n            \"mem_aof_buffer:%zu\\r\\n\"\n            \"mem_allocator:%s\\r\\n\"\n            \"active_defrag_running:%d\\r\\n\"\n            \"lazyfree_pending_objects:%zu\\r\\n\"\n            \"lazyfreed_objects:%zu\\r\\n\",\n            zmalloc_used,\n            hmem,\n            server.cron_malloc_stats.process_rss,\n            used_memory_rss_hmem,\n            server.stat_peak_memory,\n            peak_hmem,\n            mh->peak_perc,\n            mh->overhead_total,\n            mh->startup_allocated,\n            mh->dataset,\n            mh->dataset_perc,\n            server.cron_malloc_stats.allocator_allocated,\n            server.cron_malloc_stats.allocator_active,\n            server.cron_malloc_stats.allocator_resident,\n            (unsigned long)total_system_mem,\n            total_system_hmem,\n            memory_lua,\n            used_memory_lua_hmem,\n            (long long) mh->lua_caches,\n            used_memory_scripts_hmem,\n            dictSize(server.lua_scripts),\n            server.maxmemory,\n            maxmemory_hmem,\n            evict_policy,\n            mh->allocator_frag,\n            mh->allocator_frag_bytes,\n            mh->allocator_rss,\n            mh->allocator_rss_bytes,\n            mh->rss_extra,\n            mh->rss_extra_bytes,\n            mh->total_frag,       /* This is the total RSS overhead, including\n                                     fragmentation, but not just it. This field\n                                     (and the next one) is named like that just\n                                     for backward compatibility. */\n            mh->total_frag_bytes,\n            freeMemoryGetNotCountedMemory(),\n            mh->repl_backlog,\n            mh->clients_slaves,\n            mh->clients_normal,\n            mh->aof_buffer,\n            ZMALLOC_LIB,\n            server.active_defrag_running,\n            lazyfreeGetPendingObjectsCount(),\n            lazyfreeGetFreedObjectsCount()\n        );\n        freeMemoryOverheadData(mh);\n    }\n\n    /* Persistence */\n    if (allsections || defsections || !strcasecmp(section,\"persistence\")) {\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n        double fork_perc = 0;\n        if (server.stat_module_progress) {\n            fork_perc = server.stat_module_progress * 100;\n        } else if (server.stat_current_save_keys_total) {\n            fork_perc = ((double)server.stat_current_save_keys_processed / server.stat_current_save_keys_total) * 100;\n        }\n        int aof_bio_fsync_status;\n        atomicGet(server.aof_bio_fsync_status,aof_bio_fsync_status);\n\n        info = sdscatprintf(info,\n            \"# Persistence\\r\\n\"\n            \"loading:%d\\r\\n\"\n            \"current_cow_size:%zu\\r\\n\"\n            \"current_cow_size_age:%lu\\r\\n\"\n            \"current_fork_perc:%.2f\\r\\n\"\n            \"current_save_keys_processed:%zu\\r\\n\"\n            \"current_save_keys_total:%zu\\r\\n\"\n            \"rdb_changes_since_last_save:%lld\\r\\n\"\n            \"rdb_bgsave_in_progress:%d\\r\\n\"\n            \"rdb_last_save_time:%jd\\r\\n\"\n            \"rdb_last_bgsave_status:%s\\r\\n\"\n            \"rdb_last_bgsave_time_sec:%jd\\r\\n\"\n            \"rdb_current_bgsave_time_sec:%jd\\r\\n\"\n            \"rdb_last_cow_size:%zu\\r\\n\"\n            \"aof_enabled:%d\\r\\n\"\n            \"aof_rewrite_in_progress:%d\\r\\n\"\n            \"aof_rewrite_scheduled:%d\\r\\n\"\n            \"aof_last_rewrite_time_sec:%jd\\r\\n\"\n            \"aof_current_rewrite_time_sec:%jd\\r\\n\"\n            \"aof_last_bgrewrite_status:%s\\r\\n\"\n            \"aof_last_write_status:%s\\r\\n\"\n            \"aof_last_cow_size:%zu\\r\\n\"\n            \"module_fork_in_progress:%d\\r\\n\"\n            \"module_fork_last_cow_size:%zu\\r\\n\",\n            (int)server.loading,\n            server.stat_current_cow_bytes,\n            server.stat_current_cow_updated ? (unsigned long) elapsedMs(server.stat_current_cow_updated) / 1000 : 0,\n            fork_perc,\n            server.stat_current_save_keys_processed,\n            server.stat_current_save_keys_total,\n            server.dirty,\n            server.child_type == CHILD_TYPE_RDB,\n            (intmax_t)server.lastsave,\n            (server.lastbgsave_status == C_OK) ? \"ok\" : \"err\",\n            (intmax_t)server.rdb_save_time_last,\n            (intmax_t)((server.child_type != CHILD_TYPE_RDB) ?\n                -1 : time(NULL)-server.rdb_save_time_start),\n            server.stat_rdb_cow_bytes,\n            server.aof_state != AOF_OFF,\n            server.child_type == CHILD_TYPE_AOF,\n            server.aof_rewrite_scheduled,\n            (intmax_t)server.aof_rewrite_time_last,\n            (intmax_t)((server.child_type != CHILD_TYPE_AOF) ?\n                -1 : time(NULL)-server.aof_rewrite_time_start),\n            (server.aof_lastbgrewrite_status == C_OK) ? \"ok\" : \"err\",\n            (server.aof_last_write_status == C_OK &&\n                aof_bio_fsync_status == C_OK) ? \"ok\" : \"err\",\n            server.stat_aof_cow_bytes,\n            server.child_type == CHILD_TYPE_MODULE,\n            server.stat_module_cow_bytes);\n\n        if (server.aof_enabled) {\n            info = sdscatprintf(info,\n                \"aof_current_size:%lld\\r\\n\"\n                \"aof_base_size:%lld\\r\\n\"\n                \"aof_pending_rewrite:%d\\r\\n\"\n                \"aof_buffer_length:%zu\\r\\n\"\n                \"aof_rewrite_buffer_length:%lu\\r\\n\"\n                \"aof_pending_bio_fsync:%llu\\r\\n\"\n                \"aof_delayed_fsync:%lu\\r\\n\",\n                (long long) server.aof_current_size,\n                (long long) server.aof_rewrite_base_size,\n                server.aof_rewrite_scheduled,\n                sdslen(server.aof_buf),\n                aofRewriteBufferSize(),\n                bioPendingJobsOfType(BIO_AOF_FSYNC),\n                server.aof_delayed_fsync);\n        }\n\n        if (server.loading) {\n            double perc = 0;\n            time_t eta, elapsed;\n            off_t remaining_bytes = 1;\n\n            if (server.loading_total_bytes) {\n                perc = ((double)server.loading_loaded_bytes / server.loading_total_bytes) * 100;\n                remaining_bytes = server.loading_total_bytes - server.loading_loaded_bytes;\n            } else if(server.loading_rdb_used_mem) {\n                perc = ((double)server.loading_loaded_bytes / server.loading_rdb_used_mem) * 100;\n                remaining_bytes = server.loading_rdb_used_mem - server.loading_loaded_bytes;\n                /* used mem is only a (bad) estimation of the rdb file size, avoid going over 100% */\n                if (perc > 99.99) perc = 99.99;\n                if (remaining_bytes < 1) remaining_bytes = 1;\n            }\n\n            elapsed = time(NULL)-server.loading_start_time;\n            if (elapsed == 0) {\n                eta = 1; /* A fake 1 second figure if we don't have\n                            enough info */\n            } else {\n                eta = (elapsed*remaining_bytes)/(server.loading_loaded_bytes+1);\n            }\n\n            info = sdscatprintf(info,\n                \"loading_start_time:%jd\\r\\n\"\n                \"loading_total_bytes:%llu\\r\\n\"\n                \"loading_rdb_used_mem:%llu\\r\\n\"\n                \"loading_loaded_bytes:%llu\\r\\n\"\n                \"loading_loaded_perc:%.2f\\r\\n\"\n                \"loading_eta_seconds:%jd\\r\\n\",\n                (intmax_t) server.loading_start_time,\n                (unsigned long long) server.loading_total_bytes,\n                (unsigned long long) server.loading_rdb_used_mem,\n                (unsigned long long) server.loading_loaded_bytes,\n                perc,\n                (intmax_t)eta\n            );\n        }\n    }\n\n    /* Stats */\n    if (allsections || defsections || !strcasecmp(section,\"stats\")) {\n        long long stat_total_reads_processed, stat_total_writes_processed;\n        long long stat_net_input_bytes, stat_net_output_bytes;\n        atomicGet(server.stat_total_reads_processed, stat_total_reads_processed);\n        atomicGet(server.stat_total_writes_processed, stat_total_writes_processed);\n        atomicGet(server.stat_net_input_bytes, stat_net_input_bytes);\n        atomicGet(server.stat_net_output_bytes, stat_net_output_bytes);\n\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n        info = sdscatprintf(info,\n            \"# Stats\\r\\n\"\n            \"total_connections_received:%lld\\r\\n\"\n            \"total_commands_processed:%lld\\r\\n\"\n            \"instantaneous_ops_per_sec:%lld\\r\\n\"\n            \"total_net_input_bytes:%lld\\r\\n\"\n            \"total_net_output_bytes:%lld\\r\\n\"\n            \"instantaneous_input_kbps:%.2f\\r\\n\"\n            \"instantaneous_output_kbps:%.2f\\r\\n\"\n            \"rejected_connections:%lld\\r\\n\"\n            \"sync_full:%lld\\r\\n\"\n            \"sync_partial_ok:%lld\\r\\n\"\n            \"sync_partial_err:%lld\\r\\n\"\n            \"expired_keys:%lld\\r\\n\"\n            \"expired_stale_perc:%.2f\\r\\n\"\n            \"expired_time_cap_reached_count:%lld\\r\\n\"\n            \"expire_cycle_cpu_milliseconds:%lld\\r\\n\"\n            \"evicted_keys:%lld\\r\\n\"\n            \"keyspace_hits:%lld\\r\\n\"\n            \"keyspace_misses:%lld\\r\\n\"\n            \"pubsub_channels:%ld\\r\\n\"\n            \"pubsub_patterns:%lu\\r\\n\"\n            \"latest_fork_usec:%lld\\r\\n\"\n            \"total_forks:%lld\\r\\n\"\n            \"migrate_cached_sockets:%ld\\r\\n\"\n            \"slave_expires_tracked_keys:%zu\\r\\n\"\n            \"active_defrag_hits:%lld\\r\\n\"\n            \"active_defrag_misses:%lld\\r\\n\"\n            \"active_defrag_key_hits:%lld\\r\\n\"\n            \"active_defrag_key_misses:%lld\\r\\n\"\n            \"tracking_total_keys:%lld\\r\\n\"\n            \"tracking_total_items:%lld\\r\\n\"\n            \"tracking_total_prefixes:%lld\\r\\n\"\n            \"unexpected_error_replies:%lld\\r\\n\"\n            \"total_error_replies:%lld\\r\\n\"\n            \"dump_payload_sanitizations:%lld\\r\\n\"\n            \"total_reads_processed:%lld\\r\\n\"\n            \"total_writes_processed:%lld\\r\\n\"\n            \"io_threaded_reads_processed:%lld\\r\\n\"\n            \"io_threaded_writes_processed:%lld\\r\\n\",\n            server.stat_numconnections,\n            server.stat_numcommands,\n            getInstantaneousMetric(STATS_METRIC_COMMAND),\n            stat_net_input_bytes,\n            stat_net_output_bytes,\n            (float)getInstantaneousMetric(STATS_METRIC_NET_INPUT)/1024,\n            (float)getInstantaneousMetric(STATS_METRIC_NET_OUTPUT)/1024,\n            server.stat_rejected_conn,\n            server.stat_sync_full,\n            server.stat_sync_partial_ok,\n            server.stat_sync_partial_err,\n            server.stat_expiredkeys,\n            server.stat_expired_stale_perc*100,\n            server.stat_expired_time_cap_reached_count,\n            server.stat_expire_cycle_time_used/1000,\n            server.stat_evictedkeys,\n            server.stat_keyspace_hits,\n            server.stat_keyspace_misses,\n            dictSize(server.pubsub_channels),\n            dictSize(server.pubsub_patterns),\n            server.stat_fork_time,\n            server.stat_total_forks,\n            dictSize(server.migrate_cached_sockets),\n            getSlaveKeyWithExpireCount(),\n            server.stat_active_defrag_hits,\n            server.stat_active_defrag_misses,\n            server.stat_active_defrag_key_hits,\n            server.stat_active_defrag_key_misses,\n            (unsigned long long) trackingGetTotalKeys(),\n            (unsigned long long) trackingGetTotalItems(),\n            (unsigned long long) trackingGetTotalPrefixes(),\n            server.stat_unexpected_error_replies,\n            server.stat_total_error_replies,\n            server.stat_dump_payload_sanitizations,\n            stat_total_reads_processed,\n            stat_total_writes_processed,\n            server.stat_io_reads_processed,\n            server.stat_io_writes_processed);\n    }\n\n    /* Replication */\n    if (allsections || defsections || !strcasecmp(section,\"replication\")) {\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n        info = sdscatprintf(info,\n            \"# Replication\\r\\n\"\n            \"role:%s\\r\\n\",\n            server.masterhost == NULL ? \"master\" : \"slave\");\n        if (server.masterhost) {\n            long long slave_repl_offset = 1;\n\n            if (server.master)\n                slave_repl_offset = server.master->reploff;\n            else if (server.cached_master)\n                slave_repl_offset = server.cached_master->reploff;\n\n            info = sdscatprintf(info,\n                \"master_host:%s\\r\\n\"\n                \"master_port:%d\\r\\n\"\n                \"master_link_status:%s\\r\\n\"\n                \"master_last_io_seconds_ago:%d\\r\\n\"\n                \"master_sync_in_progress:%d\\r\\n\"\n                \"slave_repl_offset:%lld\\r\\n\"\n                ,server.masterhost,\n                server.masterport,\n                (server.repl_state == REPL_STATE_CONNECTED) ?\n                    \"up\" : \"down\",\n                server.master ?\n                ((int)(server.unixtime-server.master->lastinteraction)) : -1,\n                server.repl_state == REPL_STATE_TRANSFER,\n                slave_repl_offset\n            );\n\n            if (server.repl_state == REPL_STATE_TRANSFER) {\n                double perc = 0;\n                if (server.repl_transfer_size) {\n                    perc = ((double)server.repl_transfer_read / server.repl_transfer_size) * 100;\n                }\n                info = sdscatprintf(info,\n                    \"master_sync_total_bytes:%lld\\r\\n\"\n                    \"master_sync_read_bytes:%lld\\r\\n\"\n                    \"master_sync_left_bytes:%lld\\r\\n\"\n                    \"master_sync_perc:%.2f\\r\\n\"\n                    \"master_sync_last_io_seconds_ago:%d\\r\\n\",\n                    (long long) server.repl_transfer_size,\n                    (long long) server.repl_transfer_read,\n                    (long long) (server.repl_transfer_size - server.repl_transfer_read),\n                    perc,\n                    (int)(server.unixtime-server.repl_transfer_lastio)\n                );\n            }\n\n            if (server.repl_state != REPL_STATE_CONNECTED) {\n                info = sdscatprintf(info,\n                    \"master_link_down_since_seconds:%jd\\r\\n\",\n                    server.repl_down_since ?\n                    (intmax_t)(server.unixtime-server.repl_down_since) : -1);\n            }\n            info = sdscatprintf(info,\n                \"slave_priority:%d\\r\\n\"\n                \"slave_read_only:%d\\r\\n\"\n                \"replica_announced:%d\\r\\n\",\n                server.slave_priority,\n                server.repl_slave_ro,\n                server.replica_announced);\n        }\n\n        info = sdscatprintf(info,\n            \"connected_slaves:%lu\\r\\n\",\n            listLength(server.slaves));\n\n        /* If min-slaves-to-write is active, write the number of slaves\n         * currently considered 'good'. */\n        if (server.repl_min_slaves_to_write &&\n            server.repl_min_slaves_max_lag) {\n            info = sdscatprintf(info,\n                \"min_slaves_good_slaves:%d\\r\\n\",\n                server.repl_good_slaves_count);\n        }\n\n        if (listLength(server.slaves)) {\n            int slaveid = 0;\n            listNode *ln;\n            listIter li;\n\n            listRewind(server.slaves,&li);\n            while((ln = listNext(&li))) {\n                client *slave = listNodeValue(ln);\n                char *state = NULL;\n                char ip[NET_IP_STR_LEN], *slaveip = slave->slave_addr;\n                int port;\n                long lag = 0;\n\n                if (!slaveip) {\n                    if (connPeerToString(slave->conn,ip,sizeof(ip),&port) == -1)\n                        continue;\n                    slaveip = ip;\n                }\n                switch(slave->replstate) {\n                case SLAVE_STATE_WAIT_BGSAVE_START:\n                case SLAVE_STATE_WAIT_BGSAVE_END:\n                    state = \"wait_bgsave\";\n                    break;\n                case SLAVE_STATE_SEND_BULK:\n                    state = \"send_bulk\";\n                    break;\n                case SLAVE_STATE_ONLINE:\n                    state = \"online\";\n                    break;\n                }\n                if (state == NULL) continue;\n                if (slave->replstate == SLAVE_STATE_ONLINE)\n                    lag = time(NULL) - slave->repl_ack_time;\n\n                info = sdscatprintf(info,\n                    \"slave%d:ip=%s,port=%d,state=%s,\"\n                    \"offset=%lld,lag=%ld\\r\\n\",\n                    slaveid,slaveip,slave->slave_listening_port,state,\n                    slave->repl_ack_off, lag);\n                slaveid++;\n            }\n        }\n        info = sdscatprintf(info,\n            \"master_failover_state:%s\\r\\n\"\n            \"master_replid:%s\\r\\n\"\n            \"master_replid2:%s\\r\\n\"\n            \"master_repl_offset:%lld\\r\\n\"\n            \"second_repl_offset:%lld\\r\\n\"\n            \"repl_backlog_active:%d\\r\\n\"\n            \"repl_backlog_size:%lld\\r\\n\"\n            \"repl_backlog_first_byte_offset:%lld\\r\\n\"\n            \"repl_backlog_histlen:%lld\\r\\n\",\n            getFailoverStateString(),\n            server.replid,\n            server.replid2,\n            server.master_repl_offset,\n            server.second_replid_offset,\n            server.repl_backlog != NULL,\n            server.repl_backlog_size,\n            server.repl_backlog_off,\n            server.repl_backlog_histlen);\n    }\n\n    /* CPU */\n    if (allsections || defsections || !strcasecmp(section,\"cpu\")) {\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n\n        struct rusage self_ru, c_ru;\n        getrusage(RUSAGE_SELF, &self_ru);\n        getrusage(RUSAGE_CHILDREN, &c_ru);\n        info = sdscatprintf(info,\n        \"# CPU\\r\\n\"\n        \"used_cpu_sys:%ld.%06ld\\r\\n\"\n        \"used_cpu_user:%ld.%06ld\\r\\n\"\n        \"used_cpu_sys_children:%ld.%06ld\\r\\n\"\n        \"used_cpu_user_children:%ld.%06ld\\r\\n\",\n        (long)self_ru.ru_stime.tv_sec, (long)self_ru.ru_stime.tv_usec,\n        (long)self_ru.ru_utime.tv_sec, (long)self_ru.ru_utime.tv_usec,\n        (long)c_ru.ru_stime.tv_sec, (long)c_ru.ru_stime.tv_usec,\n        (long)c_ru.ru_utime.tv_sec, (long)c_ru.ru_utime.tv_usec);\n#ifdef RUSAGE_THREAD\n        struct rusage m_ru;\n        getrusage(RUSAGE_THREAD, &m_ru);\n        info = sdscatprintf(info,\n            \"used_cpu_sys_main_thread:%ld.%06ld\\r\\n\"\n            \"used_cpu_user_main_thread:%ld.%06ld\\r\\n\",\n            (long)m_ru.ru_stime.tv_sec, (long)m_ru.ru_stime.tv_usec,\n            (long)m_ru.ru_utime.tv_sec, (long)m_ru.ru_utime.tv_usec);\n#endif  /* RUSAGE_THREAD */\n    }\n\n    /* Modules */\n    if (allsections || defsections || !strcasecmp(section,\"modules\")) {\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n        info = sdscatprintf(info,\"# Modules\\r\\n\");\n        info = genModulesInfoString(info);\n    }\n\n    /* Command statistics */\n    if (allsections || !strcasecmp(section,\"commandstats\")) {\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n        info = sdscatprintf(info, \"# Commandstats\\r\\n\");\n\n        struct redisCommand *c;\n        dictEntry *de;\n        dictIterator *di;\n        di = dictGetSafeIterator(server.commands);\n        while((de = dictNext(di)) != NULL) {\n            char *tmpsafe;\n            c = (struct redisCommand *) dictGetVal(de);\n            if (!c->calls && !c->failed_calls && !c->rejected_calls)\n                continue;\n            info = sdscatprintf(info,\n                \"cmdstat_%s:calls=%lld,usec=%lld,usec_per_call=%.2f\"\n                \",rejected_calls=%lld,failed_calls=%lld\\r\\n\",\n                getSafeInfoString(c->name, strlen(c->name), &tmpsafe), c->calls, c->microseconds,\n                (c->calls == 0) ? 0 : ((float)c->microseconds/c->calls),\n                c->rejected_calls, c->failed_calls);\n            if (tmpsafe != NULL) zfree(tmpsafe);\n        }\n        dictReleaseIterator(di);\n    }\n    /* Error statistics */\n    if (allsections || defsections || !strcasecmp(section,\"errorstats\")) {\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n        info = sdscat(info, \"# Errorstats\\r\\n\");\n        raxIterator ri;\n        raxStart(&ri,server.errors);\n        raxSeek(&ri,\"^\",NULL,0);\n        struct redisError *e;\n        while(raxNext(&ri)) {\n            char *tmpsafe;\n            e = (struct redisError *) ri.data;\n            info = sdscatprintf(info,\n                \"errorstat_%.*s:count=%lld\\r\\n\",\n                (int)ri.key_len, getSafeInfoString((char *) ri.key, ri.key_len, &tmpsafe), e->count);\n            if (tmpsafe != NULL) zfree(tmpsafe);\n        }\n        raxStop(&ri);\n    }\n\n    /* Cluster */\n    if (allsections || defsections || !strcasecmp(section,\"cluster\")) {\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n        info = sdscatprintf(info,\n        \"# Cluster\\r\\n\"\n        \"cluster_enabled:%d\\r\\n\",\n        server.cluster_enabled);\n    }\n\n    /* Key space */\n    if (allsections || defsections || !strcasecmp(section,\"keyspace\")) {\n        if (sections++) info = sdscat(info,\"\\r\\n\");\n        info = sdscatprintf(info, \"# Keyspace\\r\\n\");\n        for (j = 0; j < server.dbnum; j++) {\n            long long keys, vkeys;\n\n            keys = dictSize(server.db[j].dict);\n            vkeys = dictSize(server.db[j].expires);\n            if (keys || vkeys) {\n                info = sdscatprintf(info,\n                    \"db%d:keys=%lld,expires=%lld,avg_ttl=%lld\\r\\n\",\n                    j, keys, vkeys, server.db[j].avg_ttl);\n            }\n        }\n    }\n\n    /* Get info from modules.\n     * if user asked for \"everything\" or \"modules\", or a specific section\n     * that's not found yet. */\n    if (everything || modules ||\n        (!allsections && !defsections && sections==0)) {\n        info = modulesCollectInfo(info,\n                                  everything || modules ? NULL: section,\n                                  0, /* not a crash report */\n                                  sections);\n    }\n    return info;\n}\n\nvoid infoCommand(client *c) {\n    char *section = c->argc == 2 ? c->argv[1]->ptr : \"default\";\n\n    if (c->argc > 2) {\n        addReplyErrorObject(c,shared.syntaxerr);\n        return;\n    }\n    sds info = genRedisInfoString(section);\n    addReplyVerbatim(c,info,sdslen(info),\"txt\");\n    sdsfree(info);\n}\n\nvoid monitorCommand(client *c) {\n    if (c->flags & CLIENT_DENY_BLOCKING) {\n        /**\n         * A client that has CLIENT_DENY_BLOCKING flag on\n         * expects a reply per command and so can't execute MONITOR. */\n        addReplyError(c, \"MONITOR isn't allowed for DENY BLOCKING client\");\n        return;\n    }\n\n    /* ignore MONITOR if already slave or in monitor mode */\n    if (c->flags & CLIENT_SLAVE) return;\n\n    c->flags |= (CLIENT_SLAVE|CLIENT_MONITOR);\n    listAddNodeTail(server.monitors,c);\n    addReply(c,shared.ok);\n}\n\n/* =================================== Main! ================================ */\n\nint checkIgnoreWarning(const char *warning) {\n    int argc, j;\n    sds *argv = sdssplitargs(server.ignore_warnings, &argc);\n    if (argv == NULL)\n        return 0;\n\n    for (j = 0; j < argc; j++) {\n        char *flag = argv[j];\n        if (!strcasecmp(flag, warning))\n            break;\n    }\n    sdsfreesplitres(argv,argc);\n    return j < argc;\n}\n\n#ifdef __linux__\nint linuxOvercommitMemoryValue(void) {\n    FILE *fp = fopen(\"/proc/sys/vm/overcommit_memory\",\"r\");\n    char buf[64];\n\n    if (!fp) return -1;\n    if (fgets(buf,64,fp) == NULL) {\n        fclose(fp);\n        return -1;\n    }\n    fclose(fp);\n\n    return atoi(buf);\n}\n\nvoid linuxMemoryWarnings(void) {\n    if (linuxOvercommitMemoryValue() == 0) {\n        serverLog(LL_WARNING,\"WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.\");\n    }\n    if (THPIsEnabled() && THPDisable()) {\n        serverLog(LL_WARNING,\"WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo madvise > /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled (set to 'madvise' or 'never').\");\n    }\n}\n\n#ifdef __arm64__\n\n/* Get size in kilobytes of the Shared_Dirty pages of the calling process for the\n * memory map corresponding to the provided address, or -1 on error. */\nstatic int smapsGetSharedDirty(unsigned long addr) {\n    int ret, in_mapping = 0, val = -1;\n    unsigned long from, to;\n    char buf[64];\n    FILE *f;\n\n    f = fopen(\"/proc/self/smaps\", \"r\");\n    if (!f) return -1;\n\n    while (1) {\n        if (!fgets(buf, sizeof(buf), f))\n            break;\n\n        ret = sscanf(buf, \"%lx-%lx\", &from, &to);\n        if (ret == 2)\n            in_mapping = from <= addr && addr < to;\n\n        if (in_mapping && !memcmp(buf, \"Shared_Dirty:\", 13)) {\n            sscanf(buf, \"%*s %d\", &val);\n            /* If parsing fails, we remain with val == -1 */\n            break;\n        }\n    }\n\n    fclose(f);\n    return val;\n}\n\n/* Older arm64 Linux kernels have a bug that could lead to data corruption\n * during background save in certain scenarios. This function checks if the\n * kernel is affected.\n * The bug was fixed in commit ff1712f953e27f0b0718762ec17d0adb15c9fd0b\n * titled: \"arm64: pgtable: Ensure dirty bit is preserved across pte_wrprotect()\"\n * Return -1 on unexpected test failure, 1 if the kernel seems to be affected,\n * and 0 otherwise. */\nint linuxMadvFreeForkBugCheck(void) {\n    int ret, pipefd[2] = { -1, -1 };\n    pid_t pid;\n    char *p = NULL, *q;\n    int bug_found = 0;\n    long page_size = sysconf(_SC_PAGESIZE);\n    long map_size = 3 * page_size;\n\n    /* Create a memory map that's in our full control (not one used by the allocator). */\n    p = mmap(NULL, map_size, PROT_READ, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n    if (p == MAP_FAILED) {\n        serverLog(LL_WARNING, \"Failed to mmap(): %s\", strerror(errno));\n        return -1;\n    }\n\n    q = p + page_size;\n\n    /* Split the memory map in 3 pages by setting their protection as RO|RW|RO to prevent\n     * Linux from merging this memory map with adjacent VMAs. */\n    ret = mprotect(q, page_size, PROT_READ | PROT_WRITE);\n    if (ret < 0) {\n        serverLog(LL_WARNING, \"Failed to mprotect(): %s\", strerror(errno));\n        bug_found = -1;\n        goto exit;\n    }\n\n    /* Write to the page once to make it resident */\n    *(volatile char*)q = 0;\n\n    /* Tell the kernel that this page is free to be reclaimed. */\n#ifndef MADV_FREE\n#define MADV_FREE 8\n#endif\n    ret = madvise(q, page_size, MADV_FREE);\n    if (ret < 0) {\n        /* MADV_FREE is not available on older kernels that are presumably\n         * not affected. */\n        if (errno == EINVAL) goto exit;\n\n        serverLog(LL_WARNING, \"Failed to madvise(): %s\", strerror(errno));\n        bug_found = -1;\n        goto exit;\n    }\n\n    /* Write to the page after being marked for freeing, this is supposed to take\n     * ownership of that page again. */\n    *(volatile char*)q = 0;\n\n    /* Create a pipe for the child to return the info to the parent. */\n    ret = pipe(pipefd);\n    if (ret < 0) {\n        serverLog(LL_WARNING, \"Failed to create pipe: %s\", strerror(errno));\n        bug_found = -1;\n        goto exit;\n    }\n\n    /* Fork the process. */\n    pid = fork();\n    if (pid < 0) {\n        serverLog(LL_WARNING, \"Failed to fork: %s\", strerror(errno));\n        bug_found = -1;\n        goto exit;\n    } else if (!pid) {\n        /* Child: check if the page is marked as dirty, page_size in kb.\n         * A value of 0 means the kernel is affected by the bug. */\n        ret = smapsGetSharedDirty((unsigned long) q);\n        if (!ret)\n            bug_found = 1;\n        else if (ret == -1)     /* Failed to read */\n            bug_found = -1;\n\n        if (write(pipefd[1], &bug_found, sizeof(bug_found)) < 0)\n            serverLog(LL_WARNING, \"Failed to write to parent: %s\", strerror(errno));\n        exit(0);\n    } else {\n        /* Read the result from the child. */\n        ret = read(pipefd[0], &bug_found, sizeof(bug_found));\n        if (ret < 0) {\n            serverLog(LL_WARNING, \"Failed to read from child: %s\", strerror(errno));\n            bug_found = -1;\n        }\n\n        /* Reap the child pid. */\n        waitpid(pid, NULL, 0);\n    }\n\nexit:\n    /* Cleanup */\n    if (pipefd[0] != -1) close(pipefd[0]);\n    if (pipefd[1] != -1) close(pipefd[1]);\n    if (p != NULL) munmap(p, map_size);\n\n    return bug_found;\n}\n#endif /* __arm64__ */\n#endif /* __linux__ */\n\nvoid createPidFile(void) {\n    /* If pidfile requested, but no pidfile defined, use\n     * default pidfile path */\n    if (!server.pidfile) server.pidfile = zstrdup(CONFIG_DEFAULT_PID_FILE);\n\n    /* Try to write the pid file in a best-effort way. */\n    FILE *fp = fopen(server.pidfile,\"w\");\n    if (fp) {\n        fprintf(fp,\"%d\\n\",(int)getpid());\n        fclose(fp);\n    }\n}\n\nvoid daemonize(void) {\n    int fd;\n\n    if (fork() != 0) exit(0); /* parent exits */\n    setsid(); /* create a new session */\n\n    /* Every output goes to /dev/null. If Redis is daemonized but\n     * the 'logfile' is set to 'stdout' in the configuration file\n     * it will not log at all. */\n    if ((fd = open(\"/dev/null\", O_RDWR, 0)) != -1) {\n        dup2(fd, STDIN_FILENO);\n        dup2(fd, STDOUT_FILENO);\n        dup2(fd, STDERR_FILENO);\n        if (fd > STDERR_FILENO) close(fd);\n    }\n}\n\nvoid version(void) {\n    printf(\"Redis server v=%s sha=%s:%d malloc=%s bits=%d build=%llx\\n\",\n        REDIS_VERSION,\n        redisGitSHA1(),\n        atoi(redisGitDirty()) > 0,\n        ZMALLOC_LIB,\n        sizeof(long) == 4 ? 32 : 64,\n        (unsigned long long) redisBuildId());\n    exit(0);\n}\n\nvoid usage(void) {\n    fprintf(stderr,\"Usage: ./redis-server [/path/to/redis.conf] [options] [-]\\n\");\n    fprintf(stderr,\"       ./redis-server - (read config from stdin)\\n\");\n    fprintf(stderr,\"       ./redis-server -v or --version\\n\");\n    fprintf(stderr,\"       ./redis-server -h or --help\\n\");\n    fprintf(stderr,\"       ./redis-server --test-memory <megabytes>\\n\\n\");\n    fprintf(stderr,\"Examples:\\n\");\n    fprintf(stderr,\"       ./redis-server (run the server with default conf)\\n\");\n    fprintf(stderr,\"       ./redis-server /etc/redis/6379.conf\\n\");\n    fprintf(stderr,\"       ./redis-server --port 7777\\n\");\n    fprintf(stderr,\"       ./redis-server --port 7777 --replicaof 127.0.0.1 8888\\n\");\n    fprintf(stderr,\"       ./redis-server /etc/myredis.conf --loglevel verbose -\\n\");\n    fprintf(stderr,\"       ./redis-server /etc/myredis.conf --loglevel verbose\\n\\n\");\n    fprintf(stderr,\"Sentinel mode:\\n\");\n    fprintf(stderr,\"       ./redis-server /etc/sentinel.conf --sentinel\\n\");\n    exit(1);\n}\n\nvoid redisAsciiArt(void) {\n#include \"asciilogo.h\"\n    char *buf = zmalloc(1024*16);\n    char *mode;\n\n    if (server.cluster_enabled) mode = \"cluster\";\n    else if (server.sentinel_mode) mode = \"sentinel\";\n    else mode = \"standalone\";\n\n    /* Show the ASCII logo if: log file is stdout AND stdout is a\n     * tty AND syslog logging is disabled. Also show logo if the user\n     * forced us to do so via redis.conf. */\n    int show_logo = ((!server.syslog_enabled &&\n                      server.logfile[0] == '\\0' &&\n                      isatty(fileno(stdout))) ||\n                     server.always_show_logo);\n\n    if (!show_logo) {\n        serverLog(LL_NOTICE,\n            \"Running mode=%s, port=%d.\",\n            mode, server.port ? server.port : server.tls_port\n        );\n    } else {\n        snprintf(buf,1024*16,ascii_logo,\n            REDIS_VERSION,\n            redisGitSHA1(),\n            strtol(redisGitDirty(),NULL,10) > 0,\n            (sizeof(long) == 8) ? \"64\" : \"32\",\n            mode, server.port ? server.port : server.tls_port,\n            (long) getpid()\n        );\n        serverLogRaw(LL_NOTICE|LL_RAW,buf);\n    }\n    zfree(buf);\n}\n\nint changeBindAddr(sds *addrlist, int addrlist_len) {\n    int i;\n    int result = C_OK;\n\n    char *prev_bindaddr[CONFIG_BINDADDR_MAX];\n    int prev_bindaddr_count;\n\n    /* Close old TCP and TLS servers */\n    closeSocketListeners(&server.ipfd);\n    closeSocketListeners(&server.tlsfd);\n\n    /* Keep previous settings */\n    prev_bindaddr_count = server.bindaddr_count;\n    memcpy(prev_bindaddr, server.bindaddr, sizeof(server.bindaddr));\n\n    /* Copy new settings */\n    memset(server.bindaddr, 0, sizeof(server.bindaddr));\n    for (i = 0; i < addrlist_len; i++) {\n        server.bindaddr[i] = zstrdup(addrlist[i]);\n    }\n    server.bindaddr_count = addrlist_len;\n\n    /* Bind to the new port */\n    if ((server.port != 0 && listenToPort(server.port, &server.ipfd) != C_OK) ||\n        (server.tls_port != 0 && listenToPort(server.tls_port, &server.tlsfd) != C_OK)) {\n        serverLog(LL_WARNING, \"Failed to bind, trying to restore old listening sockets.\");\n\n        /* Restore old bind addresses */\n        for (i = 0; i < addrlist_len; i++) {\n            zfree(server.bindaddr[i]);\n        }\n        memcpy(server.bindaddr, prev_bindaddr, sizeof(server.bindaddr));\n        server.bindaddr_count = prev_bindaddr_count;\n\n        /* Re-Listen TCP and TLS */\n        server.ipfd.count = 0;\n        if (server.port != 0 && listenToPort(server.port, &server.ipfd) != C_OK) {\n            serverPanic(\"Failed to restore old listening sockets.\");\n        }\n\n        server.tlsfd.count = 0;\n        if (server.tls_port != 0 && listenToPort(server.tls_port, &server.tlsfd) != C_OK) {\n            serverPanic(\"Failed to restore old listening sockets.\");\n        }\n\n        result = C_ERR;\n    } else {\n        /* Free old bind addresses */\n        for (i = 0; i < prev_bindaddr_count; i++) {\n            zfree(prev_bindaddr[i]);\n        }\n    }\n\n    /* Create TCP and TLS event handlers */\n    if (createSocketAcceptHandler(&server.ipfd, acceptTcpHandler) != C_OK) {\n        serverPanic(\"Unrecoverable error creating TCP socket accept handler.\");\n    }\n    if (createSocketAcceptHandler(&server.tlsfd, acceptTLSHandler) != C_OK) {\n        serverPanic(\"Unrecoverable error creating TLS socket accept handler.\");\n    }\n\n    if (server.set_proc_title) redisSetProcTitle(NULL);\n\n    return result;\n}\n\nint changeListenPort(int port, socketFds *sfd, aeFileProc *accept_handler) {\n    socketFds new_sfd = {{0}};\n\n    /* Just close the server if port disabled */\n    if (port == 0) {\n        closeSocketListeners(sfd);\n        if (server.set_proc_title) redisSetProcTitle(NULL);\n        return C_OK;\n    }\n\n    /* Bind to the new port */\n    if (listenToPort(port, &new_sfd) != C_OK) {\n        return C_ERR;\n    }\n\n    /* Create event handlers */\n    if (createSocketAcceptHandler(&new_sfd, accept_handler) != C_OK) {\n        closeSocketListeners(&new_sfd);\n        return C_ERR;\n    }\n\n    /* Close old servers */\n    closeSocketListeners(sfd);\n\n    /* Copy new descriptors */\n    sfd->count = new_sfd.count;\n    memcpy(sfd->fd, new_sfd.fd, sizeof(new_sfd.fd));\n\n    if (server.set_proc_title) redisSetProcTitle(NULL);\n\n    return C_OK;\n}\n\nstatic void sigShutdownHandler(int sig) {\n    char *msg;\n\n    switch (sig) {\n    case SIGINT:\n        msg = \"Received SIGINT scheduling shutdown...\";\n        break;\n    case SIGTERM:\n        msg = \"Received SIGTERM scheduling shutdown...\";\n        break;\n    default:\n        msg = \"Received shutdown signal, scheduling shutdown...\";\n    };\n\n    /* SIGINT is often delivered via Ctrl+C in an interactive session.\n     * If we receive the signal the second time, we interpret this as\n     * the user really wanting to quit ASAP without waiting to persist\n     * on disk. */\n    if (server.shutdown_asap && sig == SIGINT) {\n        serverLogFromHandler(LL_WARNING, \"You insist... exiting now.\");\n        rdbRemoveTempFile(getpid(), 1);\n        exit(1); /* Exit with an error since this was not a clean shutdown. */\n    } else if (server.loading) {\n        serverLogFromHandler(LL_WARNING, \"Received shutdown signal during loading, exiting now.\");\n        exit(0);\n    }\n\n    serverLogFromHandler(LL_WARNING, msg);\n    server.shutdown_asap = 1;\n}\n\nvoid setupSignalHandlers(void) {\n    struct sigaction act;\n\n    /* When the SA_SIGINFO flag is set in sa_flags then sa_sigaction is used.\n     * Otherwise, sa_handler is used. */\n    sigemptyset(&act.sa_mask);\n    act.sa_flags = 0;\n    act.sa_handler = sigShutdownHandler;\n    sigaction(SIGTERM, &act, NULL);\n    sigaction(SIGINT, &act, NULL);\n\n    sigemptyset(&act.sa_mask);\n    act.sa_flags = SA_NODEFER | SA_RESETHAND | SA_SIGINFO;\n    act.sa_sigaction = sigsegvHandler;\n    if(server.crashlog_enabled) {\n        sigaction(SIGSEGV, &act, NULL);\n        sigaction(SIGBUS, &act, NULL);\n        sigaction(SIGFPE, &act, NULL);\n        sigaction(SIGILL, &act, NULL);\n        sigaction(SIGABRT, &act, NULL);\n    }\n    return;\n}\n\nvoid removeSignalHandlers(void) {\n    struct sigaction act;\n    sigemptyset(&act.sa_mask);\n    act.sa_flags = SA_NODEFER | SA_RESETHAND;\n    act.sa_handler = SIG_DFL;\n    sigaction(SIGSEGV, &act, NULL);\n    sigaction(SIGBUS, &act, NULL);\n    sigaction(SIGFPE, &act, NULL);\n    sigaction(SIGILL, &act, NULL);\n    sigaction(SIGABRT, &act, NULL);\n}\n\n/* This is the signal handler for children process. It is currently useful\n * in order to track the SIGUSR1, that we send to a child in order to terminate\n * it in a clean way, without the parent detecting an error and stop\n * accepting writes because of a write error condition. */\nstatic void sigKillChildHandler(int sig) {\n    UNUSED(sig);\n    int level = server.in_fork_child == CHILD_TYPE_MODULE? LL_VERBOSE: LL_WARNING;\n    serverLogFromHandler(level, \"Received SIGUSR1 in child, exiting now.\");\n    exitFromChild(SERVER_CHILD_NOERROR_RETVAL);\n}\n\nvoid setupChildSignalHandlers(void) {\n    struct sigaction act;\n\n    /* When the SA_SIGINFO flag is set in sa_flags then sa_sigaction is used.\n     * Otherwise, sa_handler is used. */\n    sigemptyset(&act.sa_mask);\n    act.sa_flags = 0;\n    act.sa_handler = sigKillChildHandler;\n    sigaction(SIGUSR1, &act, NULL);\n    return;\n}\n\n/* After fork, the child process will inherit the resources\n * of the parent process, e.g. fd(socket or flock) etc.\n * should close the resources not used by the child process, so that if the\n * parent restarts it can bind/lock despite the child possibly still running. */\nvoid closeChildUnusedResourceAfterFork() {\n    closeListeningSockets(0);\n    if (server.cluster_enabled && server.cluster_config_file_lock_fd != -1)\n        close(server.cluster_config_file_lock_fd);  /* don't care if this fails */\n\n    /* Clear server.pidfile, this is the parent pidfile which should not\n     * be touched (or deleted) by the child (on exit / crash) */\n    zfree(server.pidfile);\n    server.pidfile = NULL;\n}\n\n/* purpose is one of CHILD_TYPE_ types */\nint redisFork(int purpose) {\n    if (isMutuallyExclusiveChildType(purpose)) {\n        if (hasActiveChildProcess())\n            return -1;\n\n        openChildInfoPipe();\n    }\n\n    int childpid;\n    long long start = ustime();\n    if ((childpid = fork()) == 0) {\n        /* Child */\n        server.in_fork_child = purpose;\n        setOOMScoreAdj(CONFIG_OOM_BGCHILD);\n        setupChildSignalHandlers();\n        closeChildUnusedResourceAfterFork();\n    } else {\n        /* Parent */\n        server.stat_total_forks++;\n        server.stat_fork_time = ustime()-start;\n        server.stat_fork_rate = (double) zmalloc_used_memory() * 1000000 / server.stat_fork_time / (1024*1024*1024); /* GB per second. */\n        latencyAddSampleIfNeeded(\"fork\",server.stat_fork_time/1000);\n        if (childpid == -1) {\n            if (isMutuallyExclusiveChildType(purpose)) closeChildInfoPipe();\n            return -1;\n        }\n\n        /* The child_pid and child_type are only for mutual exclusive children.\n         * other child types should handle and store their pid's in dedicated variables.\n         *\n         * Today, we allows CHILD_TYPE_LDB to run in parallel with the other fork types:\n         * - it isn't used for production, so it will not make the server be less efficient\n         * - used for debugging, and we don't want to block it from running while other\n         *   forks are running (like RDB and AOF) */\n        if (isMutuallyExclusiveChildType(purpose)) {\n            server.child_pid = childpid;\n            server.child_type = purpose;\n            server.stat_current_cow_bytes = 0;\n            server.stat_current_cow_updated = 0;\n            server.stat_current_save_keys_processed = 0;\n            server.stat_module_progress = 0;\n            server.stat_current_save_keys_total = dbTotalServerKeyCount();\n        }\n\n        updateDictResizePolicy();\n        moduleFireServerEvent(REDISMODULE_EVENT_FORK_CHILD,\n                              REDISMODULE_SUBEVENT_FORK_CHILD_BORN,\n                              NULL);\n    }\n    return childpid;\n}\n\nvoid sendChildCowInfo(childInfoType info_type, char *pname) {\n    sendChildInfoGeneric(info_type, 0, -1, pname);\n}\n\nvoid sendChildInfo(childInfoType info_type, size_t keys, char *pname) {\n    sendChildInfoGeneric(info_type, keys, -1, pname);\n}\n\nvoid memtest(size_t megabytes, int passes);\n\n/* Returns 1 if there is --sentinel among the arguments or if\n * argv[0] contains \"redis-sentinel\". */\nint checkForSentinelMode(int argc, char **argv) {\n    int j;\n\n    if (strstr(argv[0],\"redis-sentinel\") != NULL) return 1;\n    for (j = 1; j < argc; j++)\n        if (!strcmp(argv[j],\"--sentinel\")) return 1;\n    return 0;\n}\n\n/* Function called at startup to load RDB or AOF file in memory. */\nvoid loadDataFromDisk(void) {\n    long long start = ustime();\n    if (server.aof_state == AOF_ON) {\n        if (loadAppendOnlyFile(server.aof_filename) == C_OK)\n            serverLog(LL_NOTICE,\"DB loaded from append only file: %.3f seconds\",(float)(ustime()-start)/1000000);\n    } else {\n        rdbSaveInfo rsi = RDB_SAVE_INFO_INIT;\n        errno = 0; /* Prevent a stale value from affecting error checking */\n        if (rdbLoad(server.rdb_filename,&rsi,RDBFLAGS_NONE) == C_OK) {\n            serverLog(LL_NOTICE,\"DB loaded from disk: %.3f seconds\",\n                (float)(ustime()-start)/1000000);\n\n            /* Restore the replication ID / offset from the RDB file. */\n            if ((server.masterhost ||\n                (server.cluster_enabled &&\n                nodeIsSlave(server.cluster->myself))) &&\n                rsi.repl_id_is_set &&\n                rsi.repl_offset != -1 &&\n                /* Note that older implementations may save a repl_stream_db\n                 * of -1 inside the RDB file in a wrong way, see more\n                 * information in function rdbPopulateSaveInfo. */\n                rsi.repl_stream_db != -1)\n            {\n                memcpy(server.replid,rsi.repl_id,sizeof(server.replid));\n                server.master_repl_offset = rsi.repl_offset;\n                /* If we are a slave, create a cached master from this\n                 * information, in order to allow partial resynchronizations\n                 * with masters. */\n                replicationCacheMasterUsingMyself();\n                selectDb(server.cached_master,rsi.repl_stream_db);\n            }\n        } else if (errno != ENOENT) {\n            serverLog(LL_WARNING,\"Fatal error loading the DB: %s. Exiting.\",strerror(errno));\n            exit(1);\n        }\n    }\n}\n\nvoid redisOutOfMemoryHandler(size_t allocation_size) {\n    serverLog(LL_WARNING,\"Out Of Memory allocating %zu bytes!\",\n        allocation_size);\n    serverPanic(\"Redis aborting for OUT OF MEMORY. Allocating %zu bytes!\",\n        allocation_size);\n}\n\n/* Callback for sdstemplate on proc-title-template. See redis.conf for\n * supported variables.\n */\nstatic sds redisProcTitleGetVariable(const sds varname, void *arg)\n{\n    if (!strcmp(varname, \"title\")) {\n        return sdsnew(arg);\n    } else if (!strcmp(varname, \"listen-addr\")) {\n        if (server.port || server.tls_port)\n            return sdscatprintf(sdsempty(), \"%s:%u\",\n                                server.bindaddr_count ? server.bindaddr[0] : \"*\",\n                                server.port ? server.port : server.tls_port);\n        else\n            return sdscatprintf(sdsempty(), \"unixsocket:%s\", server.unixsocket);\n    } else if (!strcmp(varname, \"server-mode\")) {\n        if (server.cluster_enabled) return sdsnew(\"[cluster]\");\n        else if (server.sentinel_mode) return sdsnew(\"[sentinel]\");\n        else return sdsempty();\n    } else if (!strcmp(varname, \"config-file\")) {\n        return sdsnew(server.configfile ? server.configfile : \"-\");\n    } else if (!strcmp(varname, \"port\")) {\n        return sdscatprintf(sdsempty(), \"%u\", server.port);\n    } else if (!strcmp(varname, \"tls-port\")) {\n        return sdscatprintf(sdsempty(), \"%u\", server.tls_port);\n    } else if (!strcmp(varname, \"unixsocket\")) {\n        return sdsnew(server.unixsocket);\n    } else\n        return NULL;    /* Unknown variable name */\n}\n\n/* Expand the specified proc-title-template string and return a newly\n * allocated sds, or NULL. */\nstatic sds expandProcTitleTemplate(const char *template, const char *title) {\n    sds res = sdstemplate(template, redisProcTitleGetVariable, (void *) title);\n    if (!res)\n        return NULL;\n    return sdstrim(res, \" \");\n}\n/* Validate the specified template, returns 1 if valid or 0 otherwise. */\nint validateProcTitleTemplate(const char *template) {\n    int ok = 1;\n    sds res = expandProcTitleTemplate(template, \"\");\n    if (!res)\n        return 0;\n    if (sdslen(res) == 0) ok = 0;\n    sdsfree(res);\n    return ok;\n}\n\nint redisSetProcTitle(char *title) {\n#ifdef USE_SETPROCTITLE\n    if (!title) title = server.exec_argv[0];\n    sds proc_title = expandProcTitleTemplate(server.proc_title_template, title);\n    if (!proc_title) return C_ERR;  /* Not likely, proc_title_template is validated */\n\n    setproctitle(\"%s\", proc_title);\n    sdsfree(proc_title);\n#else\n    UNUSED(title);\n#endif\n\n    return C_OK;\n}\n\nvoid redisSetCpuAffinity(const char *cpulist) {\n#ifdef USE_SETCPUAFFINITY\n    setcpuaffinity(cpulist);\n#else\n    UNUSED(cpulist);\n#endif\n}\n\n/* Send a notify message to systemd. Returns sd_notify return code which is\n * a positive number on success. */\nint redisCommunicateSystemd(const char *sd_notify_msg) {\n#ifdef HAVE_LIBSYSTEMD\n    int ret = sd_notify(0, sd_notify_msg);\n\n    if (ret == 0)\n        serverLog(LL_WARNING, \"systemd supervision error: NOTIFY_SOCKET not found!\");\n    else if (ret < 0)\n        serverLog(LL_WARNING, \"systemd supervision error: sd_notify: %d\", ret);\n    return ret;\n#else\n    UNUSED(sd_notify_msg);\n    return 0;\n#endif\n}\n\n/* Attempt to set up upstart supervision. Returns 1 if successful. */\nstatic int redisSupervisedUpstart(void) {\n    const char *upstart_job = getenv(\"UPSTART_JOB\");\n\n    if (!upstart_job) {\n        serverLog(LL_WARNING,\n                \"upstart supervision requested, but UPSTART_JOB not found!\");\n        return 0;\n    }\n\n    serverLog(LL_NOTICE, \"supervised by upstart, will stop to signal readiness.\");\n    raise(SIGSTOP);\n    unsetenv(\"UPSTART_JOB\");\n    return 1;\n}\n\n/* Attempt to set up systemd supervision. Returns 1 if successful. */\nstatic int redisSupervisedSystemd(void) {\n#ifndef HAVE_LIBSYSTEMD\n    serverLog(LL_WARNING,\n            \"systemd supervision requested or auto-detected, but Redis is compiled without libsystemd support!\");\n    return 0;\n#else\n    if (redisCommunicateSystemd(\"STATUS=Redis is loading...\\n\") <= 0)\n        return 0;\n    serverLog(LL_NOTICE,\n        \"Supervised by systemd. Please make sure you set appropriate values for TimeoutStartSec and TimeoutStopSec in your service unit.\");\n    return 1;\n#endif\n}\n\nint redisIsSupervised(int mode) {\n    int ret = 0;\n\n    if (mode == SUPERVISED_AUTODETECT) {\n        if (getenv(\"UPSTART_JOB\")) {\n            serverLog(LL_VERBOSE, \"Upstart supervision detected.\");\n            mode = SUPERVISED_UPSTART;\n        } else if (getenv(\"NOTIFY_SOCKET\")) {\n            serverLog(LL_VERBOSE, \"Systemd supervision detected.\");\n            mode = SUPERVISED_SYSTEMD;\n        }\n    }\n\n    switch (mode) {\n        case SUPERVISED_UPSTART:\n            ret = redisSupervisedUpstart();\n            break;\n        case SUPERVISED_SYSTEMD:\n            ret = redisSupervisedSystemd();\n            break;\n        default:\n            break;\n    }\n\n    if (ret)\n        server.supervised_mode = mode;\n\n    return ret;\n}\n\nint iAmMaster(void) {\n    return ((!server.cluster_enabled && server.masterhost == NULL) ||\n            (server.cluster_enabled && nodeIsMaster(server.cluster->myself)));\n}\n\n#ifdef REDIS_TEST\ntypedef int redisTestProc(int argc, char **argv, int accurate);\nstruct redisTest {\n    char *name;\n    redisTestProc *proc;\n    int failed;\n} redisTests[] = {\n    {\"ziplist\", ziplistTest},\n    {\"quicklist\", quicklistTest},\n    {\"intset\", intsetTest},\n    {\"zipmap\", zipmapTest},\n    {\"sha1test\", sha1Test},\n    {\"util\", utilTest},\n    {\"endianconv\", endianconvTest},\n    {\"crc64\", crc64Test},\n    {\"zmalloc\", zmalloc_test},\n    {\"sds\", sdsTest},\n    {\"dict\", dictTest}\n};\nredisTestProc *getTestProcByName(const char *name) {\n    int numtests = sizeof(redisTests)/sizeof(struct redisTest);\n    for (int j = 0; j < numtests; j++) {\n        if (!strcasecmp(name,redisTests[j].name)) {\n            return redisTests[j].proc;\n        }\n    }\n    return NULL;\n}\n#endif\n\nint main(int argc, char **argv) {\n    struct timeval tv;\n    int j;\n    char config_from_stdin = 0;\n\n#ifdef REDIS_TEST\n    if (argc >= 3 && !strcasecmp(argv[1], \"test\")) {\n        int accurate = 0;\n        for (j = 3; j < argc; j++) {\n            if (!strcasecmp(argv[j], \"--accurate\")) {\n                accurate = 1;\n            }\n        }\n\n        if (!strcasecmp(argv[2], \"all\")) {\n            int numtests = sizeof(redisTests)/sizeof(struct redisTest);\n            for (j = 0; j < numtests; j++) {\n                redisTests[j].failed = (redisTests[j].proc(argc,argv,accurate) != 0);\n            }\n\n            /* Report tests result */\n            int failed_num = 0;\n            for (j = 0; j < numtests; j++) {\n                if (redisTests[j].failed) {\n                    failed_num++;\n                    printf(\"[failed] Test - %s\\n\", redisTests[j].name);\n                } else {\n                    printf(\"[ok] Test - %s\\n\", redisTests[j].name);\n                }\n            }\n\n            printf(\"%d tests, %d passed, %d failed\\n\", numtests,\n                   numtests-failed_num, failed_num);\n\n            return failed_num == 0 ? 0 : 1;\n        } else {\n            redisTestProc *proc = getTestProcByName(argv[2]);\n            if (!proc) return -1; /* test not found */\n            return proc(argc,argv,accurate);\n        }\n\n        return 0;\n    }\n#endif\n\n    /* We need to initialize our libraries, and the server configuration. */\n#ifdef INIT_SETPROCTITLE_REPLACEMENT\n    spt_init(argc, argv);\n#endif\n    setlocale(LC_COLLATE,\"\");\n    tzset(); /* Populates 'timezone' global. */\n    zmalloc_set_oom_handler(redisOutOfMemoryHandler);\n    srand(time(NULL)^getpid());\n    srandom(time(NULL)^getpid());\n    gettimeofday(&tv,NULL);\n    init_genrand64(((long long) tv.tv_sec * 1000000 + tv.tv_usec) ^ getpid());\n    crc64_init();\n\n    /* Store umask value. Because umask(2) only offers a set-and-get API we have\n     * to reset it and restore it back. We do this early to avoid a potential\n     * race condition with threads that could be creating files or directories.\n     */\n    umask(server.umask = umask(0777));\n\n    uint8_t hashseed[16];\n    getRandomBytes(hashseed,sizeof(hashseed));\n    dictSetHashFunctionSeed(hashseed);\n    server.sentinel_mode = checkForSentinelMode(argc,argv);\n    initServerConfig();\n    ACLInit(); /* The ACL subsystem must be initialized ASAP because the\n                  basic networking code and client creation depends on it. */\n    moduleInitModulesSystem();\n    tlsInit();\n\n    /* Store the executable path and arguments in a safe place in order\n     * to be able to restart the server later. */\n    server.executable = getAbsolutePath(argv[0]);\n    server.exec_argv = zmalloc(sizeof(char*)*(argc+1));\n    server.exec_argv[argc] = NULL;\n    for (j = 0; j < argc; j++) server.exec_argv[j] = zstrdup(argv[j]);\n\n    /* We need to init sentinel right now as parsing the configuration file\n     * in sentinel mode will have the effect of populating the sentinel\n     * data structures with master nodes to monitor. */\n    if (server.sentinel_mode) {\n        initSentinelConfig();\n        initSentinel();\n    }\n\n    /* Check if we need to start in redis-check-rdb/aof mode. We just execute\n     * the program main. However the program is part of the Redis executable\n     * so that we can easily execute an RDB check on loading errors. */\n    if (strstr(argv[0],\"redis-check-rdb\") != NULL)\n        redis_check_rdb_main(argc,argv,NULL);\n    else if (strstr(argv[0],\"redis-check-aof\") != NULL)\n        redis_check_aof_main(argc,argv);\n\n    if (argc >= 2) {\n        j = 1; /* First option to parse in argv[] */\n        sds options = sdsempty();\n\n        /* Handle special options --help and --version */\n        if (strcmp(argv[1], \"-v\") == 0 ||\n            strcmp(argv[1], \"--version\") == 0) version();\n        if (strcmp(argv[1], \"--help\") == 0 ||\n            strcmp(argv[1], \"-h\") == 0) usage();\n        if (strcmp(argv[1], \"--test-memory\") == 0) {\n            if (argc == 3) {\n                memtest(atoi(argv[2]),50);\n                exit(0);\n            } else {\n                fprintf(stderr,\"Please specify the amount of memory to test in megabytes.\\n\");\n                fprintf(stderr,\"Example: ./redis-server --test-memory 4096\\n\\n\");\n                exit(1);\n            }\n        }\n        /* Parse command line options\n         * Precedence wise, File, stdin, explicit options -- last config is the one that matters.\n         *\n         * First argument is the config file name? */\n        if (argv[1][0] != '-') {\n            /* Replace the config file in server.exec_argv with its absolute path. */\n            server.configfile = getAbsolutePath(argv[1]);\n            zfree(server.exec_argv[1]);\n            server.exec_argv[1] = zstrdup(server.configfile);\n            j = 2; // Skip this arg when parsing options\n        }\n        while(j < argc) {\n            /* Either first or last argument - Should we read config from stdin? */\n            if (argv[j][0] == '-' && argv[j][1] == '\\0' && (j == 1 || j == argc-1)) {\n                config_from_stdin = 1;\n            }\n            /* All the other options are parsed and conceptually appended to the\n             * configuration file. For instance --port 6380 will generate the\n             * string \"port 6380\\n\" to be parsed after the actual config file\n             * and stdin input are parsed (if they exist). */\n            else if (argv[j][0] == '-' && argv[j][1] == '-') {\n                /* Option name */\n                if (sdslen(options)) options = sdscat(options,\"\\n\");\n                options = sdscat(options,argv[j]+2);\n                options = sdscat(options,\" \");\n            } else {\n                /* Option argument */\n                options = sdscatrepr(options,argv[j],strlen(argv[j]));\n                options = sdscat(options,\" \");\n            }\n            j++;\n        }\n\n        loadServerConfig(server.configfile, config_from_stdin, options);\n        if (server.sentinel_mode) loadSentinelConfigFromQueue();\n        sdsfree(options);\n    }\n    if (server.sentinel_mode) sentinelCheckConfigFile();\n    server.supervised = redisIsSupervised(server.supervised_mode);\n    int background = server.daemonize && !server.supervised;\n    if (background) daemonize();\n\n    serverLog(LL_WARNING, \"oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo\");\n    serverLog(LL_WARNING,\n        \"Redis version=%s, bits=%d, commit=%s, modified=%d, pid=%d, just started\",\n            REDIS_VERSION,\n            (sizeof(long) == 8) ? 64 : 32,\n            redisGitSHA1(),\n            strtol(redisGitDirty(),NULL,10) > 0,\n            (int)getpid());\n\n    if (argc == 1) {\n        serverLog(LL_WARNING, \"Warning: no config file specified, using the default config. In order to specify a config file use %s /path/to/redis.conf\", argv[0]);\n    } else {\n        serverLog(LL_WARNING, \"Configuration loaded\");\n    }\n\n    readOOMScoreAdj();\n    initServer();\n    if (background || server.pidfile) createPidFile();\n    if (server.set_proc_title) redisSetProcTitle(NULL);\n    redisAsciiArt();\n    checkTcpBacklogSettings();\n\n    if (!server.sentinel_mode) {\n        /* Things not needed when running in Sentinel mode. */\n        serverLog(LL_WARNING,\"Server initialized\");\n    #ifdef __linux__\n        linuxMemoryWarnings();\n    #if defined (__arm64__)\n        int ret;\n        if ((ret = linuxMadvFreeForkBugCheck())) {\n            if (ret == 1)\n                serverLog(LL_WARNING,\"WARNING Your kernel has a bug that could lead to data corruption during background save. \"\n                                     \"Please upgrade to the latest stable kernel.\");\n            else\n                serverLog(LL_WARNING, \"Failed to test the kernel for a bug that could lead to data corruption during background save. \"\n                                      \"Your system could be affected, please report this error.\");\n            if (!checkIgnoreWarning(\"ARM64-COW-BUG\")) {\n                serverLog(LL_WARNING,\"Redis will now exit to prevent data corruption. \"\n                                     \"Note that it is possible to suppress this warning by setting the following config: ignore-warnings ARM64-COW-BUG\");\n                exit(1);\n            }\n        }\n    #endif /* __arm64__ */\n    #endif /* __linux__ */\n        moduleInitModulesSystemLast();\n        moduleLoadFromQueue();\n        ACLLoadUsersAtStartup();\n        InitServerLast();\n        loadDataFromDisk();\n        if (server.cluster_enabled) {\n            if (verifyClusterConfigWithData() == C_ERR) {\n                serverLog(LL_WARNING,\n                    \"You can't have keys in a DB different than DB 0 when in \"\n                    \"Cluster mode. Exiting.\");\n                exit(1);\n            }\n        }\n        if (server.ipfd.count > 0 || server.tlsfd.count > 0)\n            serverLog(LL_NOTICE,\"Ready to accept connections\");\n        if (server.sofd > 0)\n            serverLog(LL_NOTICE,\"The server is now ready to accept connections at %s\", server.unixsocket);\n        if (server.supervised_mode == SUPERVISED_SYSTEMD) {\n            if (!server.masterhost) {\n                redisCommunicateSystemd(\"STATUS=Ready to accept connections\\n\");\n            } else {\n                redisCommunicateSystemd(\"STATUS=Ready to accept connections in read-only mode. Waiting for MASTER <-> REPLICA sync\\n\");\n            }\n            redisCommunicateSystemd(\"READY=1\\n\");\n        }\n    } else {\n        ACLLoadUsersAtStartup();\n        InitServerLast();\n        sentinelIsRunning();\n        if (server.supervised_mode == SUPERVISED_SYSTEMD) {\n            redisCommunicateSystemd(\"STATUS=Ready to accept connections\\n\");\n            redisCommunicateSystemd(\"READY=1\\n\");\n        }\n    }\n\n    /* Warning the user about suspicious maxmemory setting. */\n    if (server.maxmemory > 0 && server.maxmemory < 1024*1024) {\n        serverLog(LL_WARNING,\"WARNING: You specified a maxmemory value that is less than 1MB (current value is %llu bytes). Are you sure this is what you really want?\", server.maxmemory);\n    }\n\n    redisSetCpuAffinity(server.server_cpulist);\n    setOOMScoreAdj(-1);\n\n    aeMain(server.el);\n    aeDeleteEventLoop(server.el);\n    return 0;\n}\n\n/* The End */\n"], "filenames": ["src/server.c"], "buggy_code_start_loc": [3987], "buggy_code_end_loc": [4205], "fixing_code_start_loc": [3988], "fixing_code_end_loc": [4216], "type": "CWE-617", "message": "Redis before 6cbea7d allows a replica to cause an assertion failure in a primary server by sending a non-administrative command (specifically, a SET command). NOTE: this was fixed for Redis 6.2.x and 7.x in 2021. Versions before 6.2 were not intended to have safety guarantees related to this.", "other": {"cve": {"id": "CVE-2021-31294", "sourceIdentifier": "cve@mitre.org", "published": "2023-07-15T23:15:09.203", "lastModified": "2023-08-14T19:15:09.193", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Redis before 6cbea7d allows a replica to cause an assertion failure in a primary server by sending a non-administrative command (specifically, a SET command). NOTE: this was fixed for Redis 6.2.x and 7.x in 2021. Versions before 6.2 were not intended to have safety guarantees related to this."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-617"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redis:redis:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.2.0", "matchCriteriaId": "28E377D7-3E6B-40DE-B628-CABF8CFF59AB"}]}]}], "references": [{"url": "https://github.com/redis/redis/commit/46f4ebbe842620f0976a36741a72482620aa4b48", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/redis/redis/commit/6cbea7d29b5285692843bc1c351abba1a7ef326f", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/redis/redis/issues/8712", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20230814-0007/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/redis/redis/commit/46f4ebbe842620f0976a36741a72482620aa4b48"}}