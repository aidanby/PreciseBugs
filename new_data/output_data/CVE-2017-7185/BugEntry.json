{"buggy_code": ["#include \"mongoose.h\"\n#ifdef MG_MODULE_LINES\n#line 1 \"mongoose/src/internal.h\"\n#endif\n/*\n * Copyright (c) 2014 Cesanta Software Limited\n * All rights reserved\n */\n\n#ifndef CS_MONGOOSE_SRC_INTERNAL_H_\n#define CS_MONGOOSE_SRC_INTERNAL_H_\n\n/* Amalgamated: #include \"common/mg_mem.h\" */\n\n#ifndef MBUF_REALLOC\n#define MBUF_REALLOC MG_REALLOC\n#endif\n\n#ifndef MBUF_FREE\n#define MBUF_FREE MG_FREE\n#endif\n\n#define MG_SET_PTRPTR(_ptr, _v) \\\n  do {                          \\\n    if (_ptr) *(_ptr) = _v;     \\\n  } while (0)\n\n#ifndef MG_INTERNAL\n#define MG_INTERNAL static\n#endif\n\n#ifdef PICOTCP\n#define NO_LIBC\n#define MG_DISABLE_PFS\n#endif\n\n/* Amalgamated: #include \"mongoose/src/net.h\" */\n/* Amalgamated: #include \"mongoose/src/http.h\" */\n/* Amalgamated: #include \"common/cs_dbg.h\" */\n\n#define MG_CTL_MSG_MESSAGE_SIZE 8192\n\n/* internals that need to be accessible in unit tests */\nMG_INTERNAL struct mg_connection *mg_do_connect(struct mg_connection *nc,\n                                                int proto,\n                                                union socket_address *sa);\n\nMG_INTERNAL int mg_parse_address(const char *str, union socket_address *sa,\n                                 int *proto, char *host, size_t host_len);\nMG_INTERNAL void mg_call(struct mg_connection *nc,\n                         mg_event_handler_t ev_handler, void *user_data, int ev,\n                         void *ev_data);\nvoid mg_forward(struct mg_connection *from, struct mg_connection *to);\nMG_INTERNAL void mg_add_conn(struct mg_mgr *mgr, struct mg_connection *c);\nMG_INTERNAL void mg_remove_conn(struct mg_connection *c);\nMG_INTERNAL struct mg_connection *mg_create_connection(\n    struct mg_mgr *mgr, mg_event_handler_t callback,\n    struct mg_add_sock_opts opts);\n#ifdef _WIN32\n/* Retur value is the same as for MultiByteToWideChar. */\nint to_wchar(const char *path, wchar_t *wbuf, size_t wbuf_len);\n#endif\n\nstruct ctl_msg {\n  mg_event_handler_t callback;\n  char message[MG_CTL_MSG_MESSAGE_SIZE];\n};\n\n#if MG_ENABLE_MQTT\nstruct mg_mqtt_message;\nMG_INTERNAL int parse_mqtt(struct mbuf *io, struct mg_mqtt_message *mm);\n#endif\n\n/* Forward declarations for testing. */\nextern void *(*test_malloc)(size_t size);\nextern void *(*test_calloc)(size_t count, size_t size);\n\n#ifndef MIN\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n#endif\n\n#if MG_ENABLE_HTTP\nstruct mg_serve_http_opts;\n\n/*\n * Reassemble the content of the buffer (buf, blen) which should be\n * in the HTTP chunked encoding, by collapsing data chunks to the\n * beginning of the buffer.\n *\n * If chunks get reassembled, modify hm->body to point to the reassembled\n * body and fire MG_EV_HTTP_CHUNK event. If handler sets MG_F_DELETE_CHUNK\n * in nc->flags, delete reassembled body from the mbuf.\n *\n * Return reassembled body size.\n */\nMG_INTERNAL size_t mg_handle_chunked(struct mg_connection *nc,\n                                     struct http_message *hm, char *buf,\n                                     size_t blen);\n\nMG_INTERNAL int mg_http_common_url_parse(const char *url, const char *schema,\n                                         const char *schema_tls, int *use_ssl,\n                                         char **user, char **pass, char **addr,\n                                         int *port_i, const char **path);\n\n#if MG_ENABLE_FILESYSTEM\nMG_INTERNAL int mg_uri_to_local_path(struct http_message *hm,\n                                     const struct mg_serve_http_opts *opts,\n                                     char **local_path,\n                                     struct mg_str *remainder);\nMG_INTERNAL time_t mg_parse_date_string(const char *datetime);\nMG_INTERNAL int mg_is_not_modified(struct http_message *hm, cs_stat_t *st);\n#endif\n#if MG_ENABLE_HTTP_CGI\nMG_INTERNAL void mg_handle_cgi(struct mg_connection *nc, const char *prog,\n                               const struct mg_str *path_info,\n                               const struct http_message *hm,\n                               const struct mg_serve_http_opts *opts);\nstruct mg_http_proto_data_cgi;\nMG_INTERNAL void mg_http_free_proto_data_cgi(struct mg_http_proto_data_cgi *d);\n#endif\n#if MG_ENABLE_HTTP_SSI\nMG_INTERNAL void mg_handle_ssi_request(struct mg_connection *nc,\n                                       struct http_message *hm,\n                                       const char *path,\n                                       const struct mg_serve_http_opts *opts);\n#endif\n#if MG_ENABLE_HTTP_WEBDAV\nMG_INTERNAL int mg_is_dav_request(const struct mg_str *s);\nMG_INTERNAL void mg_handle_propfind(struct mg_connection *nc, const char *path,\n                                    cs_stat_t *stp, struct http_message *hm,\n                                    struct mg_serve_http_opts *opts);\nMG_INTERNAL void mg_handle_lock(struct mg_connection *nc, const char *path);\nMG_INTERNAL void mg_handle_mkcol(struct mg_connection *nc, const char *path,\n                                 struct http_message *hm);\nMG_INTERNAL void mg_handle_move(struct mg_connection *c,\n                                const struct mg_serve_http_opts *opts,\n                                const char *path, struct http_message *hm);\nMG_INTERNAL void mg_handle_delete(struct mg_connection *nc,\n                                  const struct mg_serve_http_opts *opts,\n                                  const char *path);\nMG_INTERNAL void mg_handle_put(struct mg_connection *nc, const char *path,\n                               struct http_message *hm);\n#endif\n#if MG_ENABLE_HTTP_WEBSOCKET\nMG_INTERNAL void mg_ws_handler(struct mg_connection *nc, int ev,\n                               void *ev_data MG_UD_ARG(void *user_data));\nMG_INTERNAL void mg_ws_handshake(struct mg_connection *nc,\n                                 const struct mg_str *key);\n#endif\n#endif /* MG_ENABLE_HTTP */\n\nMG_INTERNAL int mg_get_errno(void);\n\nMG_INTERNAL void mg_close_conn(struct mg_connection *conn);\n\nMG_INTERNAL int mg_http_common_url_parse(const char *url, const char *schema,\n                                         const char *schema_tls, int *use_ssl,\n                                         char **user, char **pass, char **addr,\n                                         int *port_i, const char **path);\n\n#if MG_ENABLE_SNTP\nMG_INTERNAL int mg_sntp_parse_reply(const char *buf, int len,\n                                    struct mg_sntp_message *msg);\n#endif\n\n#endif /* CS_MONGOOSE_SRC_INTERNAL_H_ */\n#ifdef MG_MODULE_LINES\n#line 1 \"common/mg_mem.h\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#ifndef CS_COMMON_MG_MEM_H_\n#define CS_COMMON_MG_MEM_H_\n\n#ifndef MG_MALLOC\n#define MG_MALLOC malloc\n#endif\n\n#ifndef MG_CALLOC\n#define MG_CALLOC calloc\n#endif\n\n#ifndef MG_REALLOC\n#define MG_REALLOC realloc\n#endif\n\n#ifndef MG_FREE\n#define MG_FREE free\n#endif\n\n#endif /* CS_COMMON_MG_MEM_H_ */\n#ifdef MG_MODULE_LINES\n#line 1 \"common/cs_dbg.h\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#ifndef CS_COMMON_CS_DBG_H_\n#define CS_COMMON_CS_DBG_H_\n\n/* Amalgamated: #include \"common/platform.h\" */\n\n#if CS_ENABLE_STDIO\n#include <stdio.h>\n#endif\n\n#ifndef CS_ENABLE_DEBUG\n#define CS_ENABLE_DEBUG 0\n#endif\n\n#ifndef CS_LOG_ENABLE_TS_DIFF\n#define CS_LOG_ENABLE_TS_DIFF 0\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif /* __cplusplus */\n\nenum cs_log_level {\n  LL_NONE = -1,\n  LL_ERROR = 0,\n  LL_WARN = 1,\n  LL_INFO = 2,\n  LL_DEBUG = 3,\n  LL_VERBOSE_DEBUG = 4,\n\n  _LL_MIN = -2,\n  _LL_MAX = 5,\n};\n\nvoid cs_log_set_level(enum cs_log_level level);\n\n#if CS_ENABLE_STDIO\n\nvoid cs_log_set_file(FILE *file);\nextern enum cs_log_level cs_log_level;\nvoid cs_log_print_prefix(const char *func);\nvoid cs_log_printf(const char *fmt, ...);\n\n#define LOG(l, x)                    \\\n  do {                               \\\n    if (cs_log_level >= l) {         \\\n      cs_log_print_prefix(__func__); \\\n      cs_log_printf x;               \\\n    }                                \\\n  } while (0)\n\n#ifndef CS_NDEBUG\n\n#define DBG(x)                              \\\n  do {                                      \\\n    if (cs_log_level >= LL_VERBOSE_DEBUG) { \\\n      cs_log_print_prefix(__func__);        \\\n      cs_log_printf x;                      \\\n    }                                       \\\n  } while (0)\n\n#else /* NDEBUG */\n\n#define DBG(x)\n\n#endif\n\n#else /* CS_ENABLE_STDIO */\n\n#define LOG(l, x)\n#define DBG(x)\n\n#endif\n\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n\n#endif /* CS_COMMON_CS_DBG_H_ */\n#ifdef MG_MODULE_LINES\n#line 1 \"common/cs_dbg.c\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n/* Amalgamated: #include \"common/cs_dbg.h\" */\n\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n\n/* Amalgamated: #include \"common/cs_time.h\" */\n\nenum cs_log_level cs_log_level WEAK =\n#if CS_ENABLE_DEBUG\n    LL_VERBOSE_DEBUG;\n#else\n    LL_ERROR;\n#endif\n\n#if CS_ENABLE_STDIO\n\nFILE *cs_log_file WEAK = NULL;\n\n#if CS_LOG_ENABLE_TS_DIFF\ndouble cs_log_ts WEAK;\n#endif\n\nvoid cs_log_print_prefix(const char *func) WEAK;\nvoid cs_log_print_prefix(const char *func) {\n  char prefix[21];\n  strncpy(prefix, func, 20);\n  prefix[20] = '\\0';\n  if (cs_log_file == NULL) cs_log_file = stderr;\n  fprintf(cs_log_file, \"%-20s \", prefix);\n#if CS_LOG_ENABLE_TS_DIFF\n  {\n    double now = cs_time();\n    fprintf(cs_log_file, \"%7u \", (unsigned int) ((now - cs_log_ts) * 1000000));\n    cs_log_ts = now;\n  }\n#endif\n}\n\nvoid cs_log_printf(const char *fmt, ...) WEAK;\nvoid cs_log_printf(const char *fmt, ...) {\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(cs_log_file, fmt, ap);\n  va_end(ap);\n  fputc('\\n', cs_log_file);\n  fflush(cs_log_file);\n}\n\nvoid cs_log_set_file(FILE *file) WEAK;\nvoid cs_log_set_file(FILE *file) {\n  cs_log_file = file;\n}\n\n#endif /* CS_ENABLE_STDIO */\n\nvoid cs_log_set_level(enum cs_log_level level) WEAK;\nvoid cs_log_set_level(enum cs_log_level level) {\n  cs_log_level = level;\n#if CS_LOG_ENABLE_TS_DIFF && CS_ENABLE_STDIO\n  cs_log_ts = cs_time();\n#endif\n}\n#ifdef MG_MODULE_LINES\n#line 1 \"common/base64.c\"\n#endif\n/*\n * Copyright (c) 2014 Cesanta Software Limited\n * All rights reserved\n */\n\n#ifndef EXCLUDE_COMMON\n\n/* Amalgamated: #include \"common/base64.h\" */\n\n#include <string.h>\n\n/* Amalgamated: #include \"common/cs_dbg.h\" */\n\n/* ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/ */\n\n#define NUM_UPPERCASES ('Z' - 'A' + 1)\n#define NUM_LETTERS (NUM_UPPERCASES * 2)\n#define NUM_DIGITS ('9' - '0' + 1)\n\n/*\n * Emit a base64 code char.\n *\n * Doesn't use memory, thus it's safe to use to safely dump memory in crashdumps\n */\nstatic void cs_base64_emit_code(struct cs_base64_ctx *ctx, int v) {\n  if (v < NUM_UPPERCASES) {\n    ctx->b64_putc(v + 'A', ctx->user_data);\n  } else if (v < (NUM_LETTERS)) {\n    ctx->b64_putc(v - NUM_UPPERCASES + 'a', ctx->user_data);\n  } else if (v < (NUM_LETTERS + NUM_DIGITS)) {\n    ctx->b64_putc(v - NUM_LETTERS + '0', ctx->user_data);\n  } else {\n    ctx->b64_putc(v - NUM_LETTERS - NUM_DIGITS == 0 ? '+' : '/',\n                  ctx->user_data);\n  }\n}\n\nstatic void cs_base64_emit_chunk(struct cs_base64_ctx *ctx) {\n  int a, b, c;\n\n  a = ctx->chunk[0];\n  b = ctx->chunk[1];\n  c = ctx->chunk[2];\n\n  cs_base64_emit_code(ctx, a >> 2);\n  cs_base64_emit_code(ctx, ((a & 3) << 4) | (b >> 4));\n  if (ctx->chunk_size > 1) {\n    cs_base64_emit_code(ctx, (b & 15) << 2 | (c >> 6));\n  }\n  if (ctx->chunk_size > 2) {\n    cs_base64_emit_code(ctx, c & 63);\n  }\n}\n\nvoid cs_base64_init(struct cs_base64_ctx *ctx, cs_base64_putc_t b64_putc,\n                    void *user_data) {\n  ctx->chunk_size = 0;\n  ctx->b64_putc = b64_putc;\n  ctx->user_data = user_data;\n}\n\nvoid cs_base64_update(struct cs_base64_ctx *ctx, const char *str, size_t len) {\n  const unsigned char *src = (const unsigned char *) str;\n  size_t i;\n  for (i = 0; i < len; i++) {\n    ctx->chunk[ctx->chunk_size++] = src[i];\n    if (ctx->chunk_size == 3) {\n      cs_base64_emit_chunk(ctx);\n      ctx->chunk_size = 0;\n    }\n  }\n}\n\nvoid cs_base64_finish(struct cs_base64_ctx *ctx) {\n  if (ctx->chunk_size > 0) {\n    int i;\n    memset(&ctx->chunk[ctx->chunk_size], 0, 3 - ctx->chunk_size);\n    cs_base64_emit_chunk(ctx);\n    for (i = 0; i < (3 - ctx->chunk_size); i++) {\n      ctx->b64_putc('=', ctx->user_data);\n    }\n  }\n}\n\n#define BASE64_ENCODE_BODY                                                \\\n  static const char *b64 =                                                \\\n      \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"; \\\n  int i, j, a, b, c;                                                      \\\n                                                                          \\\n  for (i = j = 0; i < src_len; i += 3) {                                  \\\n    a = src[i];                                                           \\\n    b = i + 1 >= src_len ? 0 : src[i + 1];                                \\\n    c = i + 2 >= src_len ? 0 : src[i + 2];                                \\\n                                                                          \\\n    BASE64_OUT(b64[a >> 2]);                                              \\\n    BASE64_OUT(b64[((a & 3) << 4) | (b >> 4)]);                           \\\n    if (i + 1 < src_len) {                                                \\\n      BASE64_OUT(b64[(b & 15) << 2 | (c >> 6)]);                          \\\n    }                                                                     \\\n    if (i + 2 < src_len) {                                                \\\n      BASE64_OUT(b64[c & 63]);                                            \\\n    }                                                                     \\\n  }                                                                       \\\n                                                                          \\\n  while (j % 4 != 0) {                                                    \\\n    BASE64_OUT('=');                                                      \\\n  }                                                                       \\\n  BASE64_FLUSH()\n\n#define BASE64_OUT(ch) \\\n  do {                 \\\n    dst[j++] = (ch);   \\\n  } while (0)\n\n#define BASE64_FLUSH() \\\n  do {                 \\\n    dst[j++] = '\\0';   \\\n  } while (0)\n\nvoid cs_base64_encode(const unsigned char *src, int src_len, char *dst) {\n  BASE64_ENCODE_BODY;\n}\n\n#undef BASE64_OUT\n#undef BASE64_FLUSH\n\n#if CS_ENABLE_STDIO\n#define BASE64_OUT(ch)      \\\n  do {                      \\\n    fprintf(f, \"%c\", (ch)); \\\n    j++;                    \\\n  } while (0)\n\n#define BASE64_FLUSH()\n\nvoid cs_fprint_base64(FILE *f, const unsigned char *src, int src_len) {\n  BASE64_ENCODE_BODY;\n}\n\n#undef BASE64_OUT\n#undef BASE64_FLUSH\n#endif /* CS_ENABLE_STDIO */\n\n/* Convert one byte of encoded base64 input stream to 6-bit chunk */\nstatic unsigned char from_b64(unsigned char ch) {\n  /* Inverse lookup map */\n  static const unsigned char tab[128] = {\n      255, 255, 255, 255,\n      255, 255, 255, 255, /*  0 */\n      255, 255, 255, 255,\n      255, 255, 255, 255, /*  8 */\n      255, 255, 255, 255,\n      255, 255, 255, 255, /*  16 */\n      255, 255, 255, 255,\n      255, 255, 255, 255, /*  24 */\n      255, 255, 255, 255,\n      255, 255, 255, 255, /*  32 */\n      255, 255, 255, 62,\n      255, 255, 255, 63, /*  40 */\n      52,  53,  54,  55,\n      56,  57,  58,  59, /*  48 */\n      60,  61,  255, 255,\n      255, 200, 255, 255, /*  56   '=' is 200, on index 61 */\n      255, 0,   1,   2,\n      3,   4,   5,   6, /*  64 */\n      7,   8,   9,   10,\n      11,  12,  13,  14, /*  72 */\n      15,  16,  17,  18,\n      19,  20,  21,  22, /*  80 */\n      23,  24,  25,  255,\n      255, 255, 255, 255, /*  88 */\n      255, 26,  27,  28,\n      29,  30,  31,  32, /*  96 */\n      33,  34,  35,  36,\n      37,  38,  39,  40, /*  104 */\n      41,  42,  43,  44,\n      45,  46,  47,  48, /*  112 */\n      49,  50,  51,  255,\n      255, 255, 255, 255, /*  120 */\n  };\n  return tab[ch & 127];\n}\n\nint cs_base64_decode(const unsigned char *s, int len, char *dst, int *dec_len) {\n  unsigned char a, b, c, d;\n  int orig_len = len;\n  char *orig_dst = dst;\n  while (len >= 4 && (a = from_b64(s[0])) != 255 &&\n         (b = from_b64(s[1])) != 255 && (c = from_b64(s[2])) != 255 &&\n         (d = from_b64(s[3])) != 255) {\n    s += 4;\n    len -= 4;\n    if (a == 200 || b == 200) break; /* '=' can't be there */\n    *dst++ = a << 2 | b >> 4;\n    if (c == 200) break;\n    *dst++ = b << 4 | c >> 2;\n    if (d == 200) break;\n    *dst++ = c << 6 | d;\n  }\n  *dst = 0;\n  if (dec_len != NULL) *dec_len = (dst - orig_dst);\n  return orig_len - len;\n}\n\n#endif /* EXCLUDE_COMMON */\n#ifdef MG_MODULE_LINES\n#line 1 \"common/cs_dirent.h\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#ifndef CS_COMMON_CS_DIRENT_H_\n#define CS_COMMON_CS_DIRENT_H_\n\n#include <limits.h>\n\n/* Amalgamated: #include \"common/platform.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif /* __cplusplus */\n\n#ifdef CS_DEFINE_DIRENT\ntypedef struct { int dummy; } DIR;\n\nstruct dirent {\n  int d_ino;\n#ifdef _WIN32\n  char d_name[MAX_PATH];\n#else\n  /* TODO(rojer): Use PATH_MAX but make sure it's sane on every platform */\n  char d_name[256];\n#endif\n};\n\nDIR *opendir(const char *dir_name);\nint closedir(DIR *dir);\nstruct dirent *readdir(DIR *dir);\n#endif /* CS_DEFINE_DIRENT */\n\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n\n#endif /* CS_COMMON_CS_DIRENT_H_ */\n#ifdef MG_MODULE_LINES\n#line 1 \"common/cs_dirent.c\"\n#endif\n/*\n * Copyright (c) 2015 Cesanta Software Limited\n * All rights reserved\n */\n\n#ifndef EXCLUDE_COMMON\n\n/* Amalgamated: #include \"common/mg_mem.h\" */\n/* Amalgamated: #include \"common/cs_dirent.h\" */\n\n/*\n * This file contains POSIX opendir/closedir/readdir API implementation\n * for systems which do not natively support it (e.g. Windows).\n */\n\n#ifdef _WIN32\nstruct win32_dir {\n  DIR d;\n  HANDLE handle;\n  WIN32_FIND_DATAW info;\n  struct dirent result;\n};\n\nDIR *opendir(const char *name) {\n  struct win32_dir *dir = NULL;\n  wchar_t wpath[MAX_PATH];\n  DWORD attrs;\n\n  if (name == NULL) {\n    SetLastError(ERROR_BAD_ARGUMENTS);\n  } else if ((dir = (struct win32_dir *) MG_MALLOC(sizeof(*dir))) == NULL) {\n    SetLastError(ERROR_NOT_ENOUGH_MEMORY);\n  } else {\n    to_wchar(name, wpath, ARRAY_SIZE(wpath));\n    attrs = GetFileAttributesW(wpath);\n    if (attrs != 0xFFFFFFFF && (attrs & FILE_ATTRIBUTE_DIRECTORY)) {\n      (void) wcscat(wpath, L\"\\\\*\");\n      dir->handle = FindFirstFileW(wpath, &dir->info);\n      dir->result.d_name[0] = '\\0';\n    } else {\n      MG_FREE(dir);\n      dir = NULL;\n    }\n  }\n\n  return (DIR *) dir;\n}\n\nint closedir(DIR *d) {\n  struct win32_dir *dir = (struct win32_dir *) d;\n  int result = 0;\n\n  if (dir != NULL) {\n    if (dir->handle != INVALID_HANDLE_VALUE)\n      result = FindClose(dir->handle) ? 0 : -1;\n    MG_FREE(dir);\n  } else {\n    result = -1;\n    SetLastError(ERROR_BAD_ARGUMENTS);\n  }\n\n  return result;\n}\n\nstruct dirent *readdir(DIR *d) {\n  struct win32_dir *dir = (struct win32_dir *) d;\n  struct dirent *result = NULL;\n\n  if (dir) {\n    memset(&dir->result, 0, sizeof(dir->result));\n    if (dir->handle != INVALID_HANDLE_VALUE) {\n      result = &dir->result;\n      (void) WideCharToMultiByte(CP_UTF8, 0, dir->info.cFileName, -1,\n                                 result->d_name, sizeof(result->d_name), NULL,\n                                 NULL);\n\n      if (!FindNextFileW(dir->handle, &dir->info)) {\n        (void) FindClose(dir->handle);\n        dir->handle = INVALID_HANDLE_VALUE;\n      }\n\n    } else {\n      SetLastError(ERROR_FILE_NOT_FOUND);\n    }\n  } else {\n    SetLastError(ERROR_BAD_ARGUMENTS);\n  }\n\n  return result;\n}\n#endif\n\n#endif /* EXCLUDE_COMMON */\n\n/* ISO C requires a translation unit to contain at least one declaration */\ntypedef int cs_dirent_dummy;\n#ifdef MG_MODULE_LINES\n#line 1 \"common/cs_time.c\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n/* Amalgamated: #include \"common/cs_time.h\" */\n\n#ifndef _WIN32\n#include <stddef.h>\n/*\n * There is no sys/time.h on ARMCC.\n */\n#if !(defined(__ARMCC_VERSION) || defined(__ICCARM__)) && \\\n    !defined(__TI_COMPILER_VERSION__) &&                  \\\n    (!defined(CS_PLATFORM) || CS_PLATFORM != CS_P_NXP_LPC)\n#include <sys/time.h>\n#endif\n#else\n#include <windows.h>\n#endif\n\ndouble cs_time(void) WEAK;\ndouble cs_time(void) {\n  double now;\n#ifndef _WIN32\n  struct timeval tv;\n  if (gettimeofday(&tv, NULL /* tz */) != 0) return 0;\n  now = (double) tv.tv_sec + (((double) tv.tv_usec) / 1000000.0);\n#else\n  SYSTEMTIME sysnow;\n  FILETIME ftime;\n  GetLocalTime(&sysnow);\n  SystemTimeToFileTime(&sysnow, &ftime);\n  /*\n   * 1. VC 6.0 doesn't support conversion uint64 -> double, so, using int64\n   * This should not cause a problems in this (21th) century\n   * 2. Windows FILETIME is a number of 100-nanosecond intervals since January\n   * 1, 1601 while time_t is a number of _seconds_ since January 1, 1970 UTC,\n   * thus, we need to convert to seconds and adjust amount (subtract 11644473600\n   * seconds)\n   */\n  now = (double) (((int64_t) ftime.dwLowDateTime +\n                   ((int64_t) ftime.dwHighDateTime << 32)) /\n                  10000000.0) -\n        11644473600;\n#endif /* _WIN32 */\n  return now;\n}\n#ifdef MG_MODULE_LINES\n#line 1 \"common/cs_endian.h\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#ifndef CS_COMMON_CS_ENDIAN_H_\n#define CS_COMMON_CS_ENDIAN_H_\n\n/*\n * clang with std=-c99 uses __LITTLE_ENDIAN, by default\n * while for ex, RTOS gcc - LITTLE_ENDIAN, by default\n * it depends on __USE_BSD, but let's have everything\n */\n#if !defined(BYTE_ORDER) && defined(__BYTE_ORDER)\n#define BYTE_ORDER __BYTE_ORDER\n#ifndef LITTLE_ENDIAN\n#define LITTLE_ENDIAN __LITTLE_ENDIAN\n#endif /* LITTLE_ENDIAN */\n#ifndef BIG_ENDIAN\n#define BIG_ENDIAN __LITTLE_ENDIAN\n#endif /* BIG_ENDIAN */\n#endif /* BYTE_ORDER */\n\n#endif /* CS_COMMON_CS_ENDIAN_H_ */\n#ifdef MG_MODULE_LINES\n#line 1 \"common/md5.c\"\n#endif\n/*\n * This code implements the MD5 message-digest algorithm.\n * The algorithm is due to Ron Rivest.  This code was\n * written by Colin Plumb in 1993, no copyright is claimed.\n * This code is in the public domain; do with it what you wish.\n *\n * Equivalent code is available from RSA Data Security, Inc.\n * This code has been tested against that, and is equivalent,\n * except that you don't need to include two pages of legalese\n * with every copy.\n *\n * To compute the message digest of a chunk of bytes, declare an\n * MD5Context structure, pass it to MD5Init, call MD5Update as\n * needed on buffers full of bytes, and then call MD5Final, which\n * will fill a supplied 16-byte array with the digest.\n */\n\n/* Amalgamated: #include \"common/md5.h\" */\n/* Amalgamated: #include \"common/str_util.h\" */\n\n#if !defined(EXCLUDE_COMMON)\n#if !CS_DISABLE_MD5\n\n/* Amalgamated: #include \"common/cs_endian.h\" */\n\nstatic void byteReverse(unsigned char *buf, unsigned longs) {\n/* Forrest: MD5 expect LITTLE_ENDIAN, swap if BIG_ENDIAN */\n#if BYTE_ORDER == BIG_ENDIAN\n  do {\n    uint32_t t = (uint32_t)((unsigned) buf[3] << 8 | buf[2]) << 16 |\n                 ((unsigned) buf[1] << 8 | buf[0]);\n    *(uint32_t *) buf = t;\n    buf += 4;\n  } while (--longs);\n#else\n  (void) buf;\n  (void) longs;\n#endif\n}\n\n#define F1(x, y, z) (z ^ (x & (y ^ z)))\n#define F2(x, y, z) F1(z, x, y)\n#define F3(x, y, z) (x ^ y ^ z)\n#define F4(x, y, z) (y ^ (x | ~z))\n\n#define MD5STEP(f, w, x, y, z, data, s) \\\n  (w += f(x, y, z) + data, w = w << s | w >> (32 - s), w += x)\n\n/*\n * Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious\n * initialization constants.\n */\nvoid MD5_Init(MD5_CTX *ctx) {\n  ctx->buf[0] = 0x67452301;\n  ctx->buf[1] = 0xefcdab89;\n  ctx->buf[2] = 0x98badcfe;\n  ctx->buf[3] = 0x10325476;\n\n  ctx->bits[0] = 0;\n  ctx->bits[1] = 0;\n}\n\nstatic void MD5Transform(uint32_t buf[4], uint32_t const in[16]) {\n  register uint32_t a, b, c, d;\n\n  a = buf[0];\n  b = buf[1];\n  c = buf[2];\n  d = buf[3];\n\n  MD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);\n  MD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);\n  MD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);\n  MD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);\n  MD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);\n  MD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);\n  MD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);\n  MD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);\n  MD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);\n  MD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);\n  MD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);\n  MD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);\n  MD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);\n  MD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);\n  MD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);\n  MD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);\n\n  MD5STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5);\n  MD5STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9);\n  MD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);\n  MD5STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);\n  MD5STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5);\n  MD5STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);\n  MD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);\n  MD5STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);\n  MD5STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5);\n  MD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);\n  MD5STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14);\n  MD5STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20);\n  MD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);\n  MD5STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);\n  MD5STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14);\n  MD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);\n\n  MD5STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4);\n  MD5STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11);\n  MD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);\n  MD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);\n  MD5STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4);\n  MD5STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);\n  MD5STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);\n  MD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);\n  MD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);\n  MD5STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11);\n  MD5STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);\n  MD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);\n  MD5STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);\n  MD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);\n  MD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);\n  MD5STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23);\n\n  MD5STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6);\n  MD5STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10);\n  MD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);\n  MD5STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21);\n  MD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);\n  MD5STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);\n  MD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);\n  MD5STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21);\n  MD5STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);\n  MD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);\n  MD5STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15);\n  MD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);\n  MD5STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6);\n  MD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);\n  MD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);\n  MD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);\n\n  buf[0] += a;\n  buf[1] += b;\n  buf[2] += c;\n  buf[3] += d;\n}\n\nvoid MD5_Update(MD5_CTX *ctx, const unsigned char *buf, size_t len) {\n  uint32_t t;\n\n  t = ctx->bits[0];\n  if ((ctx->bits[0] = t + ((uint32_t) len << 3)) < t) ctx->bits[1]++;\n  ctx->bits[1] += (uint32_t) len >> 29;\n\n  t = (t >> 3) & 0x3f;\n\n  if (t) {\n    unsigned char *p = (unsigned char *) ctx->in + t;\n\n    t = 64 - t;\n    if (len < t) {\n      memcpy(p, buf, len);\n      return;\n    }\n    memcpy(p, buf, t);\n    byteReverse(ctx->in, 16);\n    MD5Transform(ctx->buf, (uint32_t *) ctx->in);\n    buf += t;\n    len -= t;\n  }\n\n  while (len >= 64) {\n    memcpy(ctx->in, buf, 64);\n    byteReverse(ctx->in, 16);\n    MD5Transform(ctx->buf, (uint32_t *) ctx->in);\n    buf += 64;\n    len -= 64;\n  }\n\n  memcpy(ctx->in, buf, len);\n}\n\nvoid MD5_Final(unsigned char digest[16], MD5_CTX *ctx) {\n  unsigned count;\n  unsigned char *p;\n  uint32_t *a;\n\n  count = (ctx->bits[0] >> 3) & 0x3F;\n\n  p = ctx->in + count;\n  *p++ = 0x80;\n  count = 64 - 1 - count;\n  if (count < 8) {\n    memset(p, 0, count);\n    byteReverse(ctx->in, 16);\n    MD5Transform(ctx->buf, (uint32_t *) ctx->in);\n    memset(ctx->in, 0, 56);\n  } else {\n    memset(p, 0, count - 8);\n  }\n  byteReverse(ctx->in, 14);\n\n  a = (uint32_t *) ctx->in;\n  a[14] = ctx->bits[0];\n  a[15] = ctx->bits[1];\n\n  MD5Transform(ctx->buf, (uint32_t *) ctx->in);\n  byteReverse((unsigned char *) ctx->buf, 4);\n  memcpy(digest, ctx->buf, 16);\n  memset((char *) ctx, 0, sizeof(*ctx));\n}\n\nchar *cs_md5(char buf[33], ...) {\n  unsigned char hash[16];\n  const unsigned char *p;\n  va_list ap;\n  MD5_CTX ctx;\n\n  MD5_Init(&ctx);\n\n  va_start(ap, buf);\n  while ((p = va_arg(ap, const unsigned char *) ) != NULL) {\n    size_t len = va_arg(ap, size_t);\n    MD5_Update(&ctx, p, len);\n  }\n  va_end(ap);\n\n  MD5_Final(hash, &ctx);\n  cs_to_hex(buf, hash, sizeof(hash));\n\n  return buf;\n}\n\n#endif /* CS_DISABLE_MD5 */\n#endif /* EXCLUDE_COMMON */\n#ifdef MG_MODULE_LINES\n#line 1 \"common/mbuf.c\"\n#endif\n/*\n * Copyright (c) 2014 Cesanta Software Limited\n * All rights reserved\n */\n\n#ifndef EXCLUDE_COMMON\n\n#include <assert.h>\n#include <string.h>\n/* Amalgamated: #include \"common/mbuf.h\" */\n\n#ifndef MBUF_REALLOC\n#define MBUF_REALLOC realloc\n#endif\n\n#ifndef MBUF_FREE\n#define MBUF_FREE free\n#endif\n\nvoid mbuf_init(struct mbuf *mbuf, size_t initial_size) WEAK;\nvoid mbuf_init(struct mbuf *mbuf, size_t initial_size) {\n  mbuf->len = mbuf->size = 0;\n  mbuf->buf = NULL;\n  mbuf_resize(mbuf, initial_size);\n}\n\nvoid mbuf_free(struct mbuf *mbuf) WEAK;\nvoid mbuf_free(struct mbuf *mbuf) {\n  if (mbuf->buf != NULL) {\n    MBUF_FREE(mbuf->buf);\n    mbuf_init(mbuf, 0);\n  }\n}\n\nvoid mbuf_resize(struct mbuf *a, size_t new_size) WEAK;\nvoid mbuf_resize(struct mbuf *a, size_t new_size) {\n  if (new_size > a->size || (new_size < a->size && new_size >= a->len)) {\n    char *buf = (char *) MBUF_REALLOC(a->buf, new_size);\n    /*\n     * In case realloc fails, there's not much we can do, except keep things as\n     * they are. Note that NULL is a valid return value from realloc when\n     * size == 0, but that is covered too.\n     */\n    if (buf == NULL && new_size != 0) return;\n    a->buf = buf;\n    a->size = new_size;\n  }\n}\n\nvoid mbuf_trim(struct mbuf *mbuf) WEAK;\nvoid mbuf_trim(struct mbuf *mbuf) {\n  mbuf_resize(mbuf, mbuf->len);\n}\n\nsize_t mbuf_insert(struct mbuf *a, size_t off, const void *buf, size_t) WEAK;\nsize_t mbuf_insert(struct mbuf *a, size_t off, const void *buf, size_t len) {\n  char *p = NULL;\n\n  assert(a != NULL);\n  assert(a->len <= a->size);\n  assert(off <= a->len);\n\n  /* check overflow */\n  if (~(size_t) 0 - (size_t) a->buf < len) return 0;\n\n  if (a->len + len <= a->size) {\n    memmove(a->buf + off + len, a->buf + off, a->len - off);\n    if (buf != NULL) {\n      memcpy(a->buf + off, buf, len);\n    }\n    a->len += len;\n  } else {\n    size_t new_size = (size_t)((a->len + len) * MBUF_SIZE_MULTIPLIER);\n    if ((p = (char *) MBUF_REALLOC(a->buf, new_size)) != NULL) {\n      a->buf = p;\n      memmove(a->buf + off + len, a->buf + off, a->len - off);\n      if (buf != NULL) memcpy(a->buf + off, buf, len);\n      a->len += len;\n      a->size = new_size;\n    } else {\n      len = 0;\n    }\n  }\n\n  return len;\n}\n\nsize_t mbuf_append(struct mbuf *a, const void *buf, size_t len) WEAK;\nsize_t mbuf_append(struct mbuf *a, const void *buf, size_t len) {\n  return mbuf_insert(a, a->len, buf, len);\n}\n\nvoid mbuf_remove(struct mbuf *mb, size_t n) WEAK;\nvoid mbuf_remove(struct mbuf *mb, size_t n) {\n  if (n > 0 && n <= mb->len) {\n    memmove(mb->buf, mb->buf + n, mb->len - n);\n    mb->len -= n;\n  }\n}\n\n#endif /* EXCLUDE_COMMON */\n#ifdef MG_MODULE_LINES\n#line 1 \"common/mg_str.c\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n/* Amalgamated: #include \"common/mg_mem.h\" */\n/* Amalgamated: #include \"common/mg_str.h\" */\n\n#include <stdlib.h>\n#include <string.h>\n\nint mg_ncasecmp(const char *s1, const char *s2, size_t len) WEAK;\n\nstruct mg_str mg_mk_str(const char *s) WEAK;\nstruct mg_str mg_mk_str(const char *s) {\n  struct mg_str ret = {s, 0};\n  if (s != NULL) ret.len = strlen(s);\n  return ret;\n}\n\nstruct mg_str mg_mk_str_n(const char *s, size_t len) WEAK;\nstruct mg_str mg_mk_str_n(const char *s, size_t len) {\n  struct mg_str ret = {s, len};\n  return ret;\n}\n\nint mg_vcmp(const struct mg_str *str1, const char *str2) WEAK;\nint mg_vcmp(const struct mg_str *str1, const char *str2) {\n  size_t n2 = strlen(str2), n1 = str1->len;\n  int r = strncmp(str1->p, str2, (n1 < n2) ? n1 : n2);\n  if (r == 0) {\n    return n1 - n2;\n  }\n  return r;\n}\n\nint mg_vcasecmp(const struct mg_str *str1, const char *str2) WEAK;\nint mg_vcasecmp(const struct mg_str *str1, const char *str2) {\n  size_t n2 = strlen(str2), n1 = str1->len;\n  int r = mg_ncasecmp(str1->p, str2, (n1 < n2) ? n1 : n2);\n  if (r == 0) {\n    return n1 - n2;\n  }\n  return r;\n}\n\nstruct mg_str mg_strdup(const struct mg_str s) WEAK;\nstruct mg_str mg_strdup(const struct mg_str s) {\n  struct mg_str r = {NULL, 0};\n  if (s.len > 0 && s.p != NULL) {\n    r.p = (char *) MG_MALLOC(s.len);\n    if (r.p != NULL) {\n      memcpy((char *) r.p, s.p, s.len);\n      r.len = s.len;\n    }\n  }\n  return r;\n}\n\nint mg_strcmp(const struct mg_str str1, const struct mg_str str2) WEAK;\nint mg_strcmp(const struct mg_str str1, const struct mg_str str2) {\n  size_t i = 0;\n  while (i < str1.len && i < str2.len) {\n    if (str1.p[i] < str2.p[i]) return -1;\n    if (str1.p[i] > str2.p[i]) return 1;\n    i++;\n  }\n  if (i < str1.len) return 1;\n  if (i < str2.len) return -1;\n  return 0;\n}\n\nint mg_strncmp(const struct mg_str, const struct mg_str, size_t n) WEAK;\nint mg_strncmp(const struct mg_str str1, const struct mg_str str2, size_t n) {\n  struct mg_str s1 = str1;\n  struct mg_str s2 = str2;\n\n  if (s1.len > n) {\n    s1.len = n;\n  }\n  if (s2.len > n) {\n    s2.len = n;\n  }\n  return mg_strcmp(s1, s2);\n}\n#ifdef MG_MODULE_LINES\n#line 1 \"common/sha1.c\"\n#endif\n/* Copyright(c) By Steve Reid <steve@edmweb.com> */\n/* 100% Public Domain */\n\n/* Amalgamated: #include \"common/sha1.h\" */\n\n#if !CS_DISABLE_SHA1 && !defined(EXCLUDE_COMMON)\n\n/* Amalgamated: #include \"common/cs_endian.h\" */\n\n#define SHA1HANDSOFF\n#if defined(__sun)\n/* Amalgamated: #include \"common/solarisfixes.h\" */\n#endif\n\nunion char64long16 {\n  unsigned char c[64];\n  uint32_t l[16];\n};\n\n#define rol(value, bits) (((value) << (bits)) | ((value) >> (32 - (bits))))\n\nstatic uint32_t blk0(union char64long16 *block, int i) {\n/* Forrest: SHA expect BIG_ENDIAN, swap if LITTLE_ENDIAN */\n#if BYTE_ORDER == LITTLE_ENDIAN\n  block->l[i] =\n      (rol(block->l[i], 24) & 0xFF00FF00) | (rol(block->l[i], 8) & 0x00FF00FF);\n#endif\n  return block->l[i];\n}\n\n/* Avoid redefine warning (ARM /usr/include/sys/ucontext.h define R0~R4) */\n#undef blk\n#undef R0\n#undef R1\n#undef R2\n#undef R3\n#undef R4\n\n#define blk(i)                                                               \\\n  (block->l[i & 15] = rol(block->l[(i + 13) & 15] ^ block->l[(i + 8) & 15] ^ \\\n                              block->l[(i + 2) & 15] ^ block->l[i & 15],     \\\n                          1))\n#define R0(v, w, x, y, z, i)                                          \\\n  z += ((w & (x ^ y)) ^ y) + blk0(block, i) + 0x5A827999 + rol(v, 5); \\\n  w = rol(w, 30);\n#define R1(v, w, x, y, z, i)                                  \\\n  z += ((w & (x ^ y)) ^ y) + blk(i) + 0x5A827999 + rol(v, 5); \\\n  w = rol(w, 30);\n#define R2(v, w, x, y, z, i)                          \\\n  z += (w ^ x ^ y) + blk(i) + 0x6ED9EBA1 + rol(v, 5); \\\n  w = rol(w, 30);\n#define R3(v, w, x, y, z, i)                                        \\\n  z += (((w | x) & y) | (w & x)) + blk(i) + 0x8F1BBCDC + rol(v, 5); \\\n  w = rol(w, 30);\n#define R4(v, w, x, y, z, i)                          \\\n  z += (w ^ x ^ y) + blk(i) + 0xCA62C1D6 + rol(v, 5); \\\n  w = rol(w, 30);\n\nvoid cs_sha1_transform(uint32_t state[5], const unsigned char buffer[64]) {\n  uint32_t a, b, c, d, e;\n  union char64long16 block[1];\n\n  memcpy(block, buffer, 64);\n  a = state[0];\n  b = state[1];\n  c = state[2];\n  d = state[3];\n  e = state[4];\n  R0(a, b, c, d, e, 0);\n  R0(e, a, b, c, d, 1);\n  R0(d, e, a, b, c, 2);\n  R0(c, d, e, a, b, 3);\n  R0(b, c, d, e, a, 4);\n  R0(a, b, c, d, e, 5);\n  R0(e, a, b, c, d, 6);\n  R0(d, e, a, b, c, 7);\n  R0(c, d, e, a, b, 8);\n  R0(b, c, d, e, a, 9);\n  R0(a, b, c, d, e, 10);\n  R0(e, a, b, c, d, 11);\n  R0(d, e, a, b, c, 12);\n  R0(c, d, e, a, b, 13);\n  R0(b, c, d, e, a, 14);\n  R0(a, b, c, d, e, 15);\n  R1(e, a, b, c, d, 16);\n  R1(d, e, a, b, c, 17);\n  R1(c, d, e, a, b, 18);\n  R1(b, c, d, e, a, 19);\n  R2(a, b, c, d, e, 20);\n  R2(e, a, b, c, d, 21);\n  R2(d, e, a, b, c, 22);\n  R2(c, d, e, a, b, 23);\n  R2(b, c, d, e, a, 24);\n  R2(a, b, c, d, e, 25);\n  R2(e, a, b, c, d, 26);\n  R2(d, e, a, b, c, 27);\n  R2(c, d, e, a, b, 28);\n  R2(b, c, d, e, a, 29);\n  R2(a, b, c, d, e, 30);\n  R2(e, a, b, c, d, 31);\n  R2(d, e, a, b, c, 32);\n  R2(c, d, e, a, b, 33);\n  R2(b, c, d, e, a, 34);\n  R2(a, b, c, d, e, 35);\n  R2(e, a, b, c, d, 36);\n  R2(d, e, a, b, c, 37);\n  R2(c, d, e, a, b, 38);\n  R2(b, c, d, e, a, 39);\n  R3(a, b, c, d, e, 40);\n  R3(e, a, b, c, d, 41);\n  R3(d, e, a, b, c, 42);\n  R3(c, d, e, a, b, 43);\n  R3(b, c, d, e, a, 44);\n  R3(a, b, c, d, e, 45);\n  R3(e, a, b, c, d, 46);\n  R3(d, e, a, b, c, 47);\n  R3(c, d, e, a, b, 48);\n  R3(b, c, d, e, a, 49);\n  R3(a, b, c, d, e, 50);\n  R3(e, a, b, c, d, 51);\n  R3(d, e, a, b, c, 52);\n  R3(c, d, e, a, b, 53);\n  R3(b, c, d, e, a, 54);\n  R3(a, b, c, d, e, 55);\n  R3(e, a, b, c, d, 56);\n  R3(d, e, a, b, c, 57);\n  R3(c, d, e, a, b, 58);\n  R3(b, c, d, e, a, 59);\n  R4(a, b, c, d, e, 60);\n  R4(e, a, b, c, d, 61);\n  R4(d, e, a, b, c, 62);\n  R4(c, d, e, a, b, 63);\n  R4(b, c, d, e, a, 64);\n  R4(a, b, c, d, e, 65);\n  R4(e, a, b, c, d, 66);\n  R4(d, e, a, b, c, 67);\n  R4(c, d, e, a, b, 68);\n  R4(b, c, d, e, a, 69);\n  R4(a, b, c, d, e, 70);\n  R4(e, a, b, c, d, 71);\n  R4(d, e, a, b, c, 72);\n  R4(c, d, e, a, b, 73);\n  R4(b, c, d, e, a, 74);\n  R4(a, b, c, d, e, 75);\n  R4(e, a, b, c, d, 76);\n  R4(d, e, a, b, c, 77);\n  R4(c, d, e, a, b, 78);\n  R4(b, c, d, e, a, 79);\n  state[0] += a;\n  state[1] += b;\n  state[2] += c;\n  state[3] += d;\n  state[4] += e;\n  /* Erase working structures. The order of operations is important,\n   * used to ensure that compiler doesn't optimize those out. */\n  memset(block, 0, sizeof(block));\n  a = b = c = d = e = 0;\n  (void) a;\n  (void) b;\n  (void) c;\n  (void) d;\n  (void) e;\n}\n\nvoid cs_sha1_init(cs_sha1_ctx *context) {\n  context->state[0] = 0x67452301;\n  context->state[1] = 0xEFCDAB89;\n  context->state[2] = 0x98BADCFE;\n  context->state[3] = 0x10325476;\n  context->state[4] = 0xC3D2E1F0;\n  context->count[0] = context->count[1] = 0;\n}\n\nvoid cs_sha1_update(cs_sha1_ctx *context, const unsigned char *data,\n                    uint32_t len) {\n  uint32_t i, j;\n\n  j = context->count[0];\n  if ((context->count[0] += len << 3) < j) context->count[1]++;\n  context->count[1] += (len >> 29);\n  j = (j >> 3) & 63;\n  if ((j + len) > 63) {\n    memcpy(&context->buffer[j], data, (i = 64 - j));\n    cs_sha1_transform(context->state, context->buffer);\n    for (; i + 63 < len; i += 64) {\n      cs_sha1_transform(context->state, &data[i]);\n    }\n    j = 0;\n  } else\n    i = 0;\n  memcpy(&context->buffer[j], &data[i], len - i);\n}\n\nvoid cs_sha1_final(unsigned char digest[20], cs_sha1_ctx *context) {\n  unsigned i;\n  unsigned char finalcount[8], c;\n\n  for (i = 0; i < 8; i++) {\n    finalcount[i] = (unsigned char) ((context->count[(i >= 4 ? 0 : 1)] >>\n                                      ((3 - (i & 3)) * 8)) &\n                                     255);\n  }\n  c = 0200;\n  cs_sha1_update(context, &c, 1);\n  while ((context->count[0] & 504) != 448) {\n    c = 0000;\n    cs_sha1_update(context, &c, 1);\n  }\n  cs_sha1_update(context, finalcount, 8);\n  for (i = 0; i < 20; i++) {\n    digest[i] =\n        (unsigned char) ((context->state[i >> 2] >> ((3 - (i & 3)) * 8)) & 255);\n  }\n  memset(context, '\\0', sizeof(*context));\n  memset(&finalcount, '\\0', sizeof(finalcount));\n}\n\nvoid cs_hmac_sha1(const unsigned char *key, size_t keylen,\n                  const unsigned char *data, size_t datalen,\n                  unsigned char out[20]) {\n  cs_sha1_ctx ctx;\n  unsigned char buf1[64], buf2[64], tmp_key[20], i;\n\n  if (keylen > sizeof(buf1)) {\n    cs_sha1_init(&ctx);\n    cs_sha1_update(&ctx, key, keylen);\n    cs_sha1_final(tmp_key, &ctx);\n    key = tmp_key;\n    keylen = sizeof(tmp_key);\n  }\n\n  memset(buf1, 0, sizeof(buf1));\n  memset(buf2, 0, sizeof(buf2));\n  memcpy(buf1, key, keylen);\n  memcpy(buf2, key, keylen);\n\n  for (i = 0; i < sizeof(buf1); i++) {\n    buf1[i] ^= 0x36;\n    buf2[i] ^= 0x5c;\n  }\n\n  cs_sha1_init(&ctx);\n  cs_sha1_update(&ctx, buf1, sizeof(buf1));\n  cs_sha1_update(&ctx, data, datalen);\n  cs_sha1_final(out, &ctx);\n\n  cs_sha1_init(&ctx);\n  cs_sha1_update(&ctx, buf2, sizeof(buf2));\n  cs_sha1_update(&ctx, out, 20);\n  cs_sha1_final(out, &ctx);\n}\n\n#endif /* EXCLUDE_COMMON */\n#ifdef MG_MODULE_LINES\n#line 1 \"common/str_util.c\"\n#endif\n/*\n * Copyright (c) 2015 Cesanta Software Limited\n * All rights reserved\n */\n\n#ifndef EXCLUDE_COMMON\n\n/* Amalgamated: #include \"common/mg_mem.h\" */\n/* Amalgamated: #include \"common/platform.h\" */\n/* Amalgamated: #include \"common/str_util.h\" */\n\n#ifndef C_DISABLE_BUILTIN_SNPRINTF\n#define C_DISABLE_BUILTIN_SNPRINTF 0\n#endif\n\n/* Amalgamated: #include \"common/mg_mem.h\" */\n\nsize_t c_strnlen(const char *s, size_t maxlen) WEAK;\nsize_t c_strnlen(const char *s, size_t maxlen) {\n  size_t l = 0;\n  for (; l < maxlen && s[l] != '\\0'; l++) {\n  }\n  return l;\n}\n\n#define C_SNPRINTF_APPEND_CHAR(ch)       \\\n  do {                                   \\\n    if (i < (int) buf_size) buf[i] = ch; \\\n    i++;                                 \\\n  } while (0)\n\n#define C_SNPRINTF_FLAG_ZERO 1\n\n#if C_DISABLE_BUILTIN_SNPRINTF\nint c_vsnprintf(char *buf, size_t buf_size, const char *fmt, va_list ap) WEAK;\nint c_vsnprintf(char *buf, size_t buf_size, const char *fmt, va_list ap) {\n  return vsnprintf(buf, buf_size, fmt, ap);\n}\n#else\nstatic int c_itoa(char *buf, size_t buf_size, int64_t num, int base, int flags,\n                  int field_width) {\n  char tmp[40];\n  int i = 0, k = 0, neg = 0;\n\n  if (num < 0) {\n    neg++;\n    num = -num;\n  }\n\n  /* Print into temporary buffer - in reverse order */\n  do {\n    int rem = num % base;\n    if (rem < 10) {\n      tmp[k++] = '0' + rem;\n    } else {\n      tmp[k++] = 'a' + (rem - 10);\n    }\n    num /= base;\n  } while (num > 0);\n\n  /* Zero padding */\n  if (flags && C_SNPRINTF_FLAG_ZERO) {\n    while (k < field_width && k < (int) sizeof(tmp) - 1) {\n      tmp[k++] = '0';\n    }\n  }\n\n  /* And sign */\n  if (neg) {\n    tmp[k++] = '-';\n  }\n\n  /* Now output */\n  while (--k >= 0) {\n    C_SNPRINTF_APPEND_CHAR(tmp[k]);\n  }\n\n  return i;\n}\n\nint c_vsnprintf(char *buf, size_t buf_size, const char *fmt, va_list ap) WEAK;\nint c_vsnprintf(char *buf, size_t buf_size, const char *fmt, va_list ap) {\n  int ch, i = 0, len_mod, flags, precision, field_width;\n\n  while ((ch = *fmt++) != '\\0') {\n    if (ch != '%') {\n      C_SNPRINTF_APPEND_CHAR(ch);\n    } else {\n      /*\n       * Conversion specification:\n       *   zero or more flags (one of: # 0 - <space> + ')\n       *   an optional minimum  field  width (digits)\n       *   an  optional precision (. followed by digits, or *)\n       *   an optional length modifier (one of: hh h l ll L q j z t)\n       *   conversion specifier (one of: d i o u x X e E f F g G a A c s p n)\n       */\n      flags = field_width = precision = len_mod = 0;\n\n      /* Flags. only zero-pad flag is supported. */\n      if (*fmt == '0') {\n        flags |= C_SNPRINTF_FLAG_ZERO;\n      }\n\n      /* Field width */\n      while (*fmt >= '0' && *fmt <= '9') {\n        field_width *= 10;\n        field_width += *fmt++ - '0';\n      }\n      /* Dynamic field width */\n      if (*fmt == '*') {\n        field_width = va_arg(ap, int);\n        fmt++;\n      }\n\n      /* Precision */\n      if (*fmt == '.') {\n        fmt++;\n        if (*fmt == '*') {\n          precision = va_arg(ap, int);\n          fmt++;\n        } else {\n          while (*fmt >= '0' && *fmt <= '9') {\n            precision *= 10;\n            precision += *fmt++ - '0';\n          }\n        }\n      }\n\n      /* Length modifier */\n      switch (*fmt) {\n        case 'h':\n        case 'l':\n        case 'L':\n        case 'I':\n        case 'q':\n        case 'j':\n        case 'z':\n        case 't':\n          len_mod = *fmt++;\n          if (*fmt == 'h') {\n            len_mod = 'H';\n            fmt++;\n          }\n          if (*fmt == 'l') {\n            len_mod = 'q';\n            fmt++;\n          }\n          break;\n      }\n\n      ch = *fmt++;\n      if (ch == 's') {\n        const char *s = va_arg(ap, const char *); /* Always fetch parameter */\n        int j;\n        int pad = field_width - (precision >= 0 ? c_strnlen(s, precision) : 0);\n        for (j = 0; j < pad; j++) {\n          C_SNPRINTF_APPEND_CHAR(' ');\n        }\n\n        /* `s` may be NULL in case of %.*s */\n        if (s != NULL) {\n          /* Ignore negative and 0 precisions */\n          for (j = 0; (precision <= 0 || j < precision) && s[j] != '\\0'; j++) {\n            C_SNPRINTF_APPEND_CHAR(s[j]);\n          }\n        }\n      } else if (ch == 'c') {\n        ch = va_arg(ap, int); /* Always fetch parameter */\n        C_SNPRINTF_APPEND_CHAR(ch);\n      } else if (ch == 'd' && len_mod == 0) {\n        i += c_itoa(buf + i, buf_size - i, va_arg(ap, int), 10, flags,\n                    field_width);\n      } else if (ch == 'd' && len_mod == 'l') {\n        i += c_itoa(buf + i, buf_size - i, va_arg(ap, long), 10, flags,\n                    field_width);\n#ifdef SSIZE_MAX\n      } else if (ch == 'd' && len_mod == 'z') {\n        i += c_itoa(buf + i, buf_size - i, va_arg(ap, ssize_t), 10, flags,\n                    field_width);\n#endif\n      } else if (ch == 'd' && len_mod == 'q') {\n        i += c_itoa(buf + i, buf_size - i, va_arg(ap, int64_t), 10, flags,\n                    field_width);\n      } else if ((ch == 'x' || ch == 'u') && len_mod == 0) {\n        i += c_itoa(buf + i, buf_size - i, va_arg(ap, unsigned),\n                    ch == 'x' ? 16 : 10, flags, field_width);\n      } else if ((ch == 'x' || ch == 'u') && len_mod == 'l') {\n        i += c_itoa(buf + i, buf_size - i, va_arg(ap, unsigned long),\n                    ch == 'x' ? 16 : 10, flags, field_width);\n      } else if ((ch == 'x' || ch == 'u') && len_mod == 'z') {\n        i += c_itoa(buf + i, buf_size - i, va_arg(ap, size_t),\n                    ch == 'x' ? 16 : 10, flags, field_width);\n      } else if (ch == 'p') {\n        unsigned long num = (unsigned long) (uintptr_t) va_arg(ap, void *);\n        C_SNPRINTF_APPEND_CHAR('0');\n        C_SNPRINTF_APPEND_CHAR('x');\n        i += c_itoa(buf + i, buf_size - i, num, 16, flags, 0);\n      } else {\n#ifndef NO_LIBC\n        /*\n         * TODO(lsm): abort is not nice in a library, remove it\n         * Also, ESP8266 SDK doesn't have it\n         */\n        abort();\n#endif\n      }\n    }\n  }\n\n  /* Zero-terminate the result */\n  if (buf_size > 0) {\n    buf[i < (int) buf_size ? i : (int) buf_size - 1] = '\\0';\n  }\n\n  return i;\n}\n#endif\n\nint c_snprintf(char *buf, size_t buf_size, const char *fmt, ...) WEAK;\nint c_snprintf(char *buf, size_t buf_size, const char *fmt, ...) {\n  int result;\n  va_list ap;\n  va_start(ap, fmt);\n  result = c_vsnprintf(buf, buf_size, fmt, ap);\n  va_end(ap);\n  return result;\n}\n\n#ifdef _WIN32\nint to_wchar(const char *path, wchar_t *wbuf, size_t wbuf_len) {\n  int ret;\n  char buf[MAX_PATH * 2], buf2[MAX_PATH * 2], *p;\n\n  strncpy(buf, path, sizeof(buf));\n  buf[sizeof(buf) - 1] = '\\0';\n\n  /* Trim trailing slashes. Leave backslash for paths like \"X:\\\" */\n  p = buf + strlen(buf) - 1;\n  while (p > buf && p[-1] != ':' && (p[0] == '\\\\' || p[0] == '/')) *p-- = '\\0';\n\n  memset(wbuf, 0, wbuf_len * sizeof(wchar_t));\n  ret = MultiByteToWideChar(CP_UTF8, 0, buf, -1, wbuf, (int) wbuf_len);\n\n  /*\n   * Convert back to Unicode. If doubly-converted string does not match the\n   * original, something is fishy, reject.\n   */\n  WideCharToMultiByte(CP_UTF8, 0, wbuf, (int) wbuf_len, buf2, sizeof(buf2),\n                      NULL, NULL);\n  if (strcmp(buf, buf2) != 0) {\n    wbuf[0] = L'\\0';\n    ret = 0;\n  }\n\n  return ret;\n}\n#endif /* _WIN32 */\n\n/* The simplest O(mn) algorithm. Better implementation are GPLed */\nconst char *c_strnstr(const char *s, const char *find, size_t slen) WEAK;\nconst char *c_strnstr(const char *s, const char *find, size_t slen) {\n  size_t find_length = strlen(find);\n  size_t i;\n\n  for (i = 0; i < slen; i++) {\n    if (i + find_length > slen) {\n      return NULL;\n    }\n\n    if (strncmp(&s[i], find, find_length) == 0) {\n      return &s[i];\n    }\n  }\n\n  return NULL;\n}\n\n#if CS_ENABLE_STRDUP\nchar *strdup(const char *src) WEAK;\nchar *strdup(const char *src) {\n  size_t len = strlen(src) + 1;\n  char *ret = MG_MALLOC(len);\n  if (ret != NULL) {\n    strcpy(ret, src);\n  }\n  return ret;\n}\n#endif\n\nvoid cs_to_hex(char *to, const unsigned char *p, size_t len) WEAK;\nvoid cs_to_hex(char *to, const unsigned char *p, size_t len) {\n  static const char *hex = \"0123456789abcdef\";\n\n  for (; len--; p++) {\n    *to++ = hex[p[0] >> 4];\n    *to++ = hex[p[0] & 0x0f];\n  }\n  *to = '\\0';\n}\n\nstatic int fourbit(int ch) {\n  if (ch >= '0' && ch <= '9') {\n    return ch - '0';\n  } else if (ch >= 'a' && ch <= 'f') {\n    return ch - 'a' + 10;\n  } else if (ch >= 'A' && ch <= 'F') {\n    return ch - 'A' + 10;\n  }\n  return 0;\n}\n\nvoid cs_from_hex(char *to, const char *p, size_t len) WEAK;\nvoid cs_from_hex(char *to, const char *p, size_t len) {\n  size_t i;\n\n  for (i = 0; i < len; i += 2) {\n    *to++ = (fourbit(p[i]) << 4) + fourbit(p[i + 1]);\n  }\n  *to = '\\0';\n}\n\n#if CS_ENABLE_TO64\nint64_t cs_to64(const char *s) WEAK;\nint64_t cs_to64(const char *s) {\n  int64_t result = 0;\n  int64_t neg = 1;\n  while (*s && isspace((unsigned char) *s)) s++;\n  if (*s == '-') {\n    neg = -1;\n    s++;\n  }\n  while (isdigit((unsigned char) *s)) {\n    result *= 10;\n    result += (*s - '0');\n    s++;\n  }\n  return result * neg;\n}\n#endif\n\nstatic int str_util_lowercase(const char *s) {\n  return tolower(*(const unsigned char *) s);\n}\n\nint mg_ncasecmp(const char *s1, const char *s2, size_t len) WEAK;\nint mg_ncasecmp(const char *s1, const char *s2, size_t len) {\n  int diff = 0;\n\n  if (len > 0) do {\n      diff = str_util_lowercase(s1++) - str_util_lowercase(s2++);\n    } while (diff == 0 && s1[-1] != '\\0' && --len > 0);\n\n  return diff;\n}\n\nint mg_casecmp(const char *s1, const char *s2) WEAK;\nint mg_casecmp(const char *s1, const char *s2) {\n  return mg_ncasecmp(s1, s2, (size_t) ~0);\n}\n\nint mg_asprintf(char **buf, size_t size, const char *fmt, ...) WEAK;\nint mg_asprintf(char **buf, size_t size, const char *fmt, ...) {\n  int ret;\n  va_list ap;\n  va_start(ap, fmt);\n  ret = mg_avprintf(buf, size, fmt, ap);\n  va_end(ap);\n  return ret;\n}\n\nint mg_avprintf(char **buf, size_t size, const char *fmt, va_list ap) WEAK;\nint mg_avprintf(char **buf, size_t size, const char *fmt, va_list ap) {\n  va_list ap_copy;\n  int len;\n\n  va_copy(ap_copy, ap);\n  len = vsnprintf(*buf, size, fmt, ap_copy);\n  va_end(ap_copy);\n\n  if (len < 0) {\n    /* eCos and Windows are not standard-compliant and return -1 when\n     * the buffer is too small. Keep allocating larger buffers until we\n     * succeed or out of memory. */\n    *buf = NULL; /* LCOV_EXCL_START */\n    while (len < 0) {\n      MG_FREE(*buf);\n      size *= 2;\n      if ((*buf = (char *) MG_MALLOC(size)) == NULL) break;\n      va_copy(ap_copy, ap);\n      len = vsnprintf(*buf, size, fmt, ap_copy);\n      va_end(ap_copy);\n    }\n    /* LCOV_EXCL_STOP */\n  } else if (len >= (int) size) {\n    /* Standard-compliant code path. Allocate a buffer that is large enough. */\n    if ((*buf = (char *) MG_MALLOC(len + 1)) == NULL) {\n      len = -1; /* LCOV_EXCL_LINE */\n    } else {    /* LCOV_EXCL_LINE */\n      va_copy(ap_copy, ap);\n      len = vsnprintf(*buf, len + 1, fmt, ap_copy);\n      va_end(ap_copy);\n    }\n  }\n\n  return len;\n}\n\n#endif /* EXCLUDE_COMMON */\n#ifdef MG_MODULE_LINES\n#line 1 \"mongoose/src/tun.h\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#ifndef CS_MONGOOSE_SRC_TUN_H_\n#define CS_MONGOOSE_SRC_TUN_H_\n\n#if MG_ENABLE_TUN\n\n/* Amalgamated: #include \"mongoose/src/net.h\" */\n/* Amalgamated: #include \"common/mg_str.h\" */\n\n#ifndef MG_TUN_RECONNECT_INTERVAL\n#define MG_TUN_RECONNECT_INTERVAL 1\n#endif\n\n#define MG_TUN_PROTO_NAME \"mg_tun\"\n\n#define MG_TUN_DATA_FRAME 0x0\n#define MG_TUN_F_END_STREAM 0x1\n\n/*\n * MG TUN frame format is loosely based on HTTP/2.\n * However since the communication happens via WebSocket\n * there is no need to encode the frame length, since that's\n * solved by WebSocket framing.\n *\n * TODO(mkm): Detailed description of the protocol.\n */\nstruct mg_tun_frame {\n  uint8_t type;\n  uint8_t flags;\n  uint32_t stream_id; /* opaque stream identifier */\n  struct mg_str body;\n};\n\nstruct mg_tun_ssl_opts {\n#if MG_ENABLE_SSL\n  const char *ssl_cert;\n  const char *ssl_key;\n  const char *ssl_ca_cert;\n#else\n  int dummy; /* some compilers don't like empty structs */\n#endif\n};\n\nstruct mg_tun_client {\n  struct mg_mgr *mgr;\n  struct mg_iface *iface;\n  const char *disp_url;\n  struct mg_tun_ssl_opts ssl;\n\n  uint32_t last_stream_id; /* stream id of most recently accepted connection */\n\n  struct mg_connection *disp;\n  struct mg_connection *listener;\n  struct mg_connection *reconnect;\n};\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif /* __cplusplus */\n\nstruct mg_connection *mg_tun_bind_opt(struct mg_mgr *mgr,\n                                      const char *dispatcher,\n                                      MG_CB(mg_event_handler_t handler,\n                                            void *user_data),\n                                      struct mg_bind_opts opts);\n\nint mg_tun_parse_frame(void *data, size_t len, struct mg_tun_frame *frame);\n\nvoid mg_tun_send_frame(struct mg_connection *ws, uint32_t stream_id,\n                       uint8_t type, uint8_t flags, struct mg_str msg);\n\nvoid mg_tun_destroy_client(struct mg_tun_client *client);\n\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n\n#endif /* MG_ENABLE_TUN */\n\n#endif /* CS_MONGOOSE_SRC_TUN_H_ */\n#ifdef MG_MODULE_LINES\n#line 1 \"mongoose/src/net.c\"\n#endif\n/*\n * Copyright (c) 2014 Cesanta Software Limited\n * All rights reserved\n *\n * This software is dual-licensed: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation. For the terms of this\n * license, see <http://www.gnu.org/licenses/>.\n *\n * You are free to use this software under the terms of the GNU General\n * Public License, but WITHOUT ANY WARRANTY; without even the implied\n * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License for more details.\n *\n * Alternatively, you can license this software under a commercial\n * license, as set out in <https://www.cesanta.com/license>.\n */\n\n/* Amalgamated: #include \"common/cs_time.h\" */\n/* Amalgamated: #include \"mongoose/src/dns.h\" */\n/* Amalgamated: #include \"mongoose/src/internal.h\" */\n/* Amalgamated: #include \"mongoose/src/resolv.h\" */\n/* Amalgamated: #include \"mongoose/src/util.h\" */\n/* Amalgamated: #include \"mongoose/src/tun.h\" */\n\n#define MG_MAX_HOST_LEN 200\n\n#define MG_COPY_COMMON_CONNECTION_OPTIONS(dst, src) \\\n  memcpy(dst, src, sizeof(*dst));\n\n/* Which flags can be pre-set by the user at connection creation time. */\n#define _MG_ALLOWED_CONNECT_FLAGS_MASK                                   \\\n  (MG_F_USER_1 | MG_F_USER_2 | MG_F_USER_3 | MG_F_USER_4 | MG_F_USER_5 | \\\n   MG_F_USER_6 | MG_F_WEBSOCKET_NO_DEFRAG | MG_F_ENABLE_BROADCAST)\n/* Which flags should be modifiable by user's callbacks. */\n#define _MG_CALLBACK_MODIFIABLE_FLAGS_MASK                               \\\n  (MG_F_USER_1 | MG_F_USER_2 | MG_F_USER_3 | MG_F_USER_4 | MG_F_USER_5 | \\\n   MG_F_USER_6 | MG_F_WEBSOCKET_NO_DEFRAG | MG_F_SEND_AND_CLOSE |        \\\n   MG_F_CLOSE_IMMEDIATELY | MG_F_IS_WEBSOCKET | MG_F_DELETE_CHUNK)\n\n#ifndef intptr_t\n#define intptr_t long\n#endif\n\nMG_INTERNAL void mg_add_conn(struct mg_mgr *mgr, struct mg_connection *c) {\n  DBG((\"%p %p\", mgr, c));\n  c->mgr = mgr;\n  c->next = mgr->active_connections;\n  mgr->active_connections = c;\n  c->prev = NULL;\n  if (c->next != NULL) c->next->prev = c;\n  if (c->sock != INVALID_SOCKET) {\n    c->iface->vtable->add_conn(c);\n  }\n}\n\nMG_INTERNAL void mg_remove_conn(struct mg_connection *conn) {\n  if (conn->prev == NULL) conn->mgr->active_connections = conn->next;\n  if (conn->prev) conn->prev->next = conn->next;\n  if (conn->next) conn->next->prev = conn->prev;\n  conn->prev = conn->next = NULL;\n  conn->iface->vtable->remove_conn(conn);\n}\n\nMG_INTERNAL void mg_call(struct mg_connection *nc,\n                         mg_event_handler_t ev_handler, void *user_data, int ev,\n                         void *ev_data) {\n  if (ev_handler == NULL) {\n    /*\n     * If protocol handler is specified, call it. Otherwise, call user-specified\n     * event handler.\n     */\n    ev_handler = nc->proto_handler ? nc->proto_handler : nc->handler;\n  }\n  if (ev != MG_EV_POLL) {\n    DBG((\"%p %s ev=%d ev_data=%p flags=%lu rmbl=%d smbl=%d\", nc,\n         ev_handler == nc->handler ? \"user\" : \"proto\", ev, ev_data, nc->flags,\n         (int) nc->recv_mbuf.len, (int) nc->send_mbuf.len));\n  }\n\n#if !defined(NO_LIBC) && MG_ENABLE_HEXDUMP\n  /* LCOV_EXCL_START */\n  if (nc->mgr->hexdump_file != NULL && ev != MG_EV_POLL &&\n      ev != MG_EV_SEND /* handled separately */) {\n    if (ev == MG_EV_RECV) {\n      mg_hexdump_connection(nc, nc->mgr->hexdump_file, nc->recv_mbuf.buf,\n                            *(int *) ev_data, ev);\n    } else {\n      mg_hexdump_connection(nc, nc->mgr->hexdump_file, NULL, 0, ev);\n    }\n  }\n/* LCOV_EXCL_STOP */\n#endif\n  if (ev_handler != NULL) {\n    unsigned long flags_before = nc->flags;\n    size_t recv_mbuf_before = nc->recv_mbuf.len, recved;\n    ev_handler(nc, ev, ev_data MG_UD_ARG(user_data));\n    recved = (recv_mbuf_before - nc->recv_mbuf.len);\n    /* Prevent user handler from fiddling with system flags. */\n    if (ev_handler == nc->handler && nc->flags != flags_before) {\n      nc->flags = (flags_before & ~_MG_CALLBACK_MODIFIABLE_FLAGS_MASK) |\n                  (nc->flags & _MG_CALLBACK_MODIFIABLE_FLAGS_MASK);\n    }\n    if (recved > 0 && !(nc->flags & MG_F_UDP)) {\n      nc->iface->vtable->recved(nc, recved);\n    }\n  }\n  if (ev != MG_EV_POLL) {\n    DBG((\"%p after %s flags=%lu rmbl=%d smbl=%d\", nc,\n         ev_handler == nc->handler ? \"user\" : \"proto\", nc->flags,\n         (int) nc->recv_mbuf.len, (int) nc->send_mbuf.len));\n  }\n#if !MG_ENABLE_CALLBACK_USERDATA\n  (void) user_data;\n#endif\n}\n\nvoid mg_if_timer(struct mg_connection *c, double now) {\n  if (c->ev_timer_time > 0 && now >= c->ev_timer_time) {\n    double old_value = c->ev_timer_time;\n    mg_call(c, NULL, c->user_data, MG_EV_TIMER, &now);\n    /*\n     * To prevent timer firing all the time, reset the timer after delivery.\n     * However, in case user sets it to new value, do not reset.\n     */\n    if (c->ev_timer_time == old_value) {\n      c->ev_timer_time = 0;\n    }\n  }\n}\n\nvoid mg_if_poll(struct mg_connection *nc, time_t now) {\n  if (!(nc->flags & MG_F_SSL) || (nc->flags & MG_F_SSL_HANDSHAKE_DONE)) {\n    mg_call(nc, NULL, nc->user_data, MG_EV_POLL, &now);\n  }\n}\n\nstatic void mg_destroy_conn(struct mg_connection *conn, int destroy_if) {\n  if (destroy_if) conn->iface->vtable->destroy_conn(conn);\n  if (conn->proto_data != NULL && conn->proto_data_destructor != NULL) {\n    conn->proto_data_destructor(conn->proto_data);\n  }\n#if MG_ENABLE_SSL\n  mg_ssl_if_conn_free(conn);\n#endif\n  mbuf_free(&conn->recv_mbuf);\n  mbuf_free(&conn->send_mbuf);\n\n  memset(conn, 0, sizeof(*conn));\n  MG_FREE(conn);\n}\n\nvoid mg_close_conn(struct mg_connection *conn) {\n  DBG((\"%p %lu %d\", conn, conn->flags, conn->sock));\n#if MG_ENABLE_SSL\n  if (conn->flags & MG_F_SSL_HANDSHAKE_DONE) {\n    mg_ssl_if_conn_close_notify(conn);\n  }\n#endif\n  mg_remove_conn(conn);\n  conn->iface->vtable->destroy_conn(conn);\n  mg_call(conn, NULL, conn->user_data, MG_EV_CLOSE, NULL);\n  mg_destroy_conn(conn, 0 /* destroy_if */);\n}\n\nvoid mg_mgr_init(struct mg_mgr *m, void *user_data) {\n  struct mg_mgr_init_opts opts;\n  memset(&opts, 0, sizeof(opts));\n  mg_mgr_init_opt(m, user_data, opts);\n}\n\nvoid mg_mgr_init_opt(struct mg_mgr *m, void *user_data,\n                     struct mg_mgr_init_opts opts) {\n  memset(m, 0, sizeof(*m));\n#if MG_ENABLE_BROADCAST\n  m->ctl[0] = m->ctl[1] = INVALID_SOCKET;\n#endif\n  m->user_data = user_data;\n\n#ifdef _WIN32\n  {\n    WSADATA data;\n    WSAStartup(MAKEWORD(2, 2), &data);\n  }\n#elif defined(__unix__)\n  /* Ignore SIGPIPE signal, so if client cancels the request, it\n   * won't kill the whole process. */\n  signal(SIGPIPE, SIG_IGN);\n#endif\n\n#if MG_ENABLE_SSL\n  {\n    static int init_done;\n    if (!init_done) {\n      mg_ssl_if_init();\n      init_done++;\n    }\n  }\n#endif\n  {\n    int i;\n    if (opts.num_ifaces == 0) {\n      opts.num_ifaces = mg_num_ifaces;\n      opts.ifaces = mg_ifaces;\n    }\n    if (opts.main_iface != NULL) {\n      opts.ifaces[MG_MAIN_IFACE] = opts.main_iface;\n    }\n    m->num_ifaces = opts.num_ifaces;\n    m->ifaces =\n        (struct mg_iface **) MG_MALLOC(sizeof(*m->ifaces) * opts.num_ifaces);\n    for (i = 0; i < mg_num_ifaces; i++) {\n      m->ifaces[i] = mg_if_create_iface(opts.ifaces[i], m);\n      m->ifaces[i]->vtable->init(m->ifaces[i]);\n    }\n  }\n  if (opts.nameserver != NULL) {\n    m->nameserver = strdup(opts.nameserver);\n  }\n  DBG((\"==================================\"));\n  DBG((\"init mgr=%p\", m));\n}\n\n#if MG_ENABLE_JAVASCRIPT\nstatic enum v7_err mg_send_js(struct v7 *v7, v7_val_t *res) {\n  v7_val_t arg0 = v7_arg(v7, 0);\n  v7_val_t arg1 = v7_arg(v7, 1);\n  struct mg_connection *c = (struct mg_connection *) v7_get_ptr(v7, arg0);\n  size_t len = 0;\n\n  if (v7_is_string(arg1)) {\n    const char *data = v7_get_string(v7, &arg1, &len);\n    mg_send(c, data, len);\n  }\n\n  *res = v7_mk_number(v7, len);\n\n  return V7_OK;\n}\n\nenum v7_err mg_enable_javascript(struct mg_mgr *m, struct v7 *v7,\n                                 const char *init_file_name) {\n  v7_val_t v;\n  m->v7 = v7;\n  v7_set_method(v7, v7_get_global(v7), \"mg_send\", mg_send_js);\n  return v7_exec_file(v7, init_file_name, &v);\n}\n#endif\n\nvoid mg_mgr_free(struct mg_mgr *m) {\n  struct mg_connection *conn, *tmp_conn;\n\n  DBG((\"%p\", m));\n  if (m == NULL) return;\n  /* Do one last poll, see https://github.com/cesanta/mongoose/issues/286 */\n  mg_mgr_poll(m, 0);\n\n#if MG_ENABLE_BROADCAST\n  if (m->ctl[0] != INVALID_SOCKET) closesocket(m->ctl[0]);\n  if (m->ctl[1] != INVALID_SOCKET) closesocket(m->ctl[1]);\n  m->ctl[0] = m->ctl[1] = INVALID_SOCKET;\n#endif\n\n  for (conn = m->active_connections; conn != NULL; conn = tmp_conn) {\n    tmp_conn = conn->next;\n    mg_close_conn(conn);\n  }\n\n  {\n    int i;\n    for (i = 0; i < m->num_ifaces; i++) {\n      m->ifaces[i]->vtable->free(m->ifaces[i]);\n      MG_FREE(m->ifaces[i]);\n    }\n    MG_FREE(m->ifaces);\n  }\n\n  MG_FREE((char *) m->nameserver);\n}\n\ntime_t mg_mgr_poll(struct mg_mgr *m, int timeout_ms) {\n  int i;\n  time_t now = 0; /* oh GCC, seriously ? */\n\n  if (m->num_ifaces == 0) {\n    LOG(LL_ERROR, (\"cannot poll: no interfaces\"));\n    return 0;\n  }\n\n  for (i = 0; i < m->num_ifaces; i++) {\n    now = m->ifaces[i]->vtable->poll(m->ifaces[i], timeout_ms);\n  }\n  return now;\n}\n\nint mg_vprintf(struct mg_connection *nc, const char *fmt, va_list ap) {\n  char mem[MG_VPRINTF_BUFFER_SIZE], *buf = mem;\n  int len;\n\n  if ((len = mg_avprintf(&buf, sizeof(mem), fmt, ap)) > 0) {\n    mg_send(nc, buf, len);\n  }\n  if (buf != mem && buf != NULL) {\n    MG_FREE(buf); /* LCOV_EXCL_LINE */\n  }               /* LCOV_EXCL_LINE */\n\n  return len;\n}\n\nint mg_printf(struct mg_connection *conn, const char *fmt, ...) {\n  int len;\n  va_list ap;\n  va_start(ap, fmt);\n  len = mg_vprintf(conn, fmt, ap);\n  va_end(ap);\n  return len;\n}\n\n#if MG_ENABLE_SYNC_RESOLVER\n/* TODO(lsm): use non-blocking resolver */\nstatic int mg_resolve2(const char *host, struct in_addr *ina) {\n#if MG_ENABLE_GETADDRINFO\n  int rv = 0;\n  struct addrinfo hints, *servinfo, *p;\n  struct sockaddr_in *h = NULL;\n  memset(&hints, 0, sizeof hints);\n  hints.ai_family = AF_INET;\n  hints.ai_socktype = SOCK_STREAM;\n  if ((rv = getaddrinfo(host, NULL, NULL, &servinfo)) != 0) {\n    DBG((\"getaddrinfo(%s) failed: %s\", host, strerror(mg_get_errno())));\n    return 0;\n  }\n  for (p = servinfo; p != NULL; p = p->ai_next) {\n    memcpy(&h, &p->ai_addr, sizeof(struct sockaddr_in *));\n    memcpy(ina, &h->sin_addr, sizeof(ina));\n  }\n  freeaddrinfo(servinfo);\n  return 1;\n#else\n  struct hostent *he;\n  if ((he = gethostbyname(host)) == NULL) {\n    DBG((\"gethostbyname(%s) failed: %s\", host, strerror(mg_get_errno())));\n  } else {\n    memcpy(ina, he->h_addr_list[0], sizeof(*ina));\n    return 1;\n  }\n  return 0;\n#endif /* MG_ENABLE_GETADDRINFO */\n}\n\nint mg_resolve(const char *host, char *buf, size_t n) {\n  struct in_addr ad;\n  return mg_resolve2(host, &ad) ? snprintf(buf, n, \"%s\", inet_ntoa(ad)) : 0;\n}\n#endif /* MG_ENABLE_SYNC_RESOLVER */\n\nMG_INTERNAL struct mg_connection *mg_create_connection_base(\n    struct mg_mgr *mgr, mg_event_handler_t callback,\n    struct mg_add_sock_opts opts) {\n  struct mg_connection *conn;\n\n  if ((conn = (struct mg_connection *) MG_CALLOC(1, sizeof(*conn))) != NULL) {\n    conn->sock = INVALID_SOCKET;\n    conn->handler = callback;\n    conn->mgr = mgr;\n    conn->last_io_time = (time_t) mg_time();\n    conn->iface =\n        (opts.iface != NULL ? opts.iface : mgr->ifaces[MG_MAIN_IFACE]);\n    conn->flags = opts.flags & _MG_ALLOWED_CONNECT_FLAGS_MASK;\n    conn->user_data = opts.user_data;\n    /*\n     * SIZE_MAX is defined as a long long constant in\n     * system headers on some platforms and so it\n     * doesn't compile with pedantic ansi flags.\n     */\n    conn->recv_mbuf_limit = ~0;\n  } else {\n    MG_SET_PTRPTR(opts.error_string, \"failed to create connection\");\n  }\n\n  return conn;\n}\n\nMG_INTERNAL struct mg_connection *mg_create_connection(\n    struct mg_mgr *mgr, mg_event_handler_t callback,\n    struct mg_add_sock_opts opts) {\n  struct mg_connection *conn = mg_create_connection_base(mgr, callback, opts);\n\n  if (conn != NULL && !conn->iface->vtable->create_conn(conn)) {\n    MG_FREE(conn);\n    conn = NULL;\n  }\n  if (conn == NULL) {\n    MG_SET_PTRPTR(opts.error_string, \"failed to init connection\");\n  }\n\n  return conn;\n}\n\n/*\n * Address format: [PROTO://][HOST]:PORT\n *\n * HOST could be IPv4/IPv6 address or a host name.\n * `host` is a destination buffer to hold parsed HOST part. Should be at least\n * MG_MAX_HOST_LEN bytes long.\n * `proto` is a returned socket type, either SOCK_STREAM or SOCK_DGRAM\n *\n * Return:\n *   -1   on parse error\n *    0   if HOST needs DNS lookup\n *   >0   length of the address string\n */\nMG_INTERNAL int mg_parse_address(const char *str, union socket_address *sa,\n                                 int *proto, char *host, size_t host_len) {\n  unsigned int a, b, c, d, port = 0;\n  int ch, len = 0;\n#if MG_ENABLE_IPV6\n  char buf[100];\n#endif\n\n  /*\n   * MacOS needs that. If we do not zero it, subsequent bind() will fail.\n   * Also, all-zeroes in the socket address means binding to all addresses\n   * for both IPv4 and IPv6 (INADDR_ANY and IN6ADDR_ANY_INIT).\n   */\n  memset(sa, 0, sizeof(*sa));\n  sa->sin.sin_family = AF_INET;\n\n  *proto = SOCK_STREAM;\n\n  if (strncmp(str, \"udp://\", 6) == 0) {\n    str += 6;\n    *proto = SOCK_DGRAM;\n  } else if (strncmp(str, \"tcp://\", 6) == 0) {\n    str += 6;\n  }\n\n  if (sscanf(str, \"%u.%u.%u.%u:%u%n\", &a, &b, &c, &d, &port, &len) == 5) {\n    /* Bind to a specific IPv4 address, e.g. 192.168.1.5:8080 */\n    sa->sin.sin_addr.s_addr =\n        htonl(((uint32_t) a << 24) | ((uint32_t) b << 16) | c << 8 | d);\n    sa->sin.sin_port = htons((uint16_t) port);\n#if MG_ENABLE_IPV6\n  } else if (sscanf(str, \"[%99[^]]]:%u%n\", buf, &port, &len) == 2 &&\n             inet_pton(AF_INET6, buf, &sa->sin6.sin6_addr)) {\n    /* IPv6 address, e.g. [3ffe:2a00:100:7031::1]:8080 */\n    sa->sin6.sin6_family = AF_INET6;\n    sa->sin.sin_port = htons((uint16_t) port);\n#endif\n#if MG_ENABLE_ASYNC_RESOLVER\n  } else if (strlen(str) < host_len &&\n             sscanf(str, \"%[^ :]:%u%n\", host, &port, &len) == 2) {\n    sa->sin.sin_port = htons((uint16_t) port);\n    if (mg_resolve_from_hosts_file(host, sa) != 0) {\n      /*\n       * if resolving from hosts file failed and the host\n       * we are trying to resolve is `localhost` - we should\n       * try to resolve it using `gethostbyname` and do not try\n       * to resolve it via DNS server if gethostbyname has failed too\n       */\n      if (mg_ncasecmp(host, \"localhost\", 9) != 0) {\n        return 0;\n      }\n\n#if MG_ENABLE_SYNC_RESOLVER\n      if (!mg_resolve2(host, &sa->sin.sin_addr)) {\n        return -1;\n      }\n#else\n      return -1;\n#endif\n    }\n#endif\n  } else if (sscanf(str, \":%u%n\", &port, &len) == 1 ||\n             sscanf(str, \"%u%n\", &port, &len) == 1) {\n    /* If only port is specified, bind to IPv4, INADDR_ANY */\n    sa->sin.sin_port = htons((uint16_t) port);\n  } else {\n    return -1;\n  }\n\n  /* Required for MG_ENABLE_ASYNC_RESOLVER=0 */\n  (void) host;\n  (void) host_len;\n\n  ch = str[len]; /* Character that follows the address */\n  return port < 0xffffUL && (ch == '\\0' || ch == ',' || isspace(ch)) ? len : -1;\n}\n\nstruct mg_connection *mg_if_accept_new_conn(struct mg_connection *lc) {\n  struct mg_add_sock_opts opts;\n  struct mg_connection *nc;\n  memset(&opts, 0, sizeof(opts));\n  nc = mg_create_connection(lc->mgr, lc->handler, opts);\n  if (nc == NULL) return NULL;\n  nc->listener = lc;\n  nc->proto_handler = lc->proto_handler;\n  nc->user_data = lc->user_data;\n  nc->recv_mbuf_limit = lc->recv_mbuf_limit;\n  nc->iface = lc->iface;\n  if (lc->flags & MG_F_SSL) nc->flags |= MG_F_SSL;\n  mg_add_conn(nc->mgr, nc);\n  DBG((\"%p %p %d %d\", lc, nc, nc->sock, (int) nc->flags));\n  return nc;\n}\n\nvoid mg_if_accept_tcp_cb(struct mg_connection *nc, union socket_address *sa,\n                         size_t sa_len) {\n  (void) sa_len;\n  nc->sa = *sa;\n  mg_call(nc, NULL, nc->user_data, MG_EV_ACCEPT, &nc->sa);\n}\n\nvoid mg_send(struct mg_connection *nc, const void *buf, int len) {\n  nc->last_io_time = (time_t) mg_time();\n  if (nc->flags & MG_F_UDP) {\n    nc->iface->vtable->udp_send(nc, buf, len);\n  } else {\n    nc->iface->vtable->tcp_send(nc, buf, len);\n  }\n#if !defined(NO_LIBC) && MG_ENABLE_HEXDUMP\n  if (nc->mgr && nc->mgr->hexdump_file != NULL) {\n    mg_hexdump_connection(nc, nc->mgr->hexdump_file, buf, len, MG_EV_SEND);\n  }\n#endif\n}\n\nvoid mg_if_sent_cb(struct mg_connection *nc, int num_sent) {\n  if (num_sent < 0) {\n    nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n  }\n  mg_call(nc, NULL, nc->user_data, MG_EV_SEND, &num_sent);\n}\n\nMG_INTERNAL void mg_recv_common(struct mg_connection *nc, void *buf, int len,\n                                int own) {\n  DBG((\"%p %d %u\", nc, len, (unsigned int) nc->recv_mbuf.len));\n  if (nc->flags & MG_F_CLOSE_IMMEDIATELY) {\n    DBG((\"%p discarded %d bytes\", nc, len));\n    /*\n     * This connection will not survive next poll. Do not deliver events,\n     * send data to /dev/null without acking.\n     */\n    if (own) {\n      MG_FREE(buf);\n    }\n    return;\n  }\n  nc->last_io_time = (time_t) mg_time();\n  if (!own) {\n    mbuf_append(&nc->recv_mbuf, buf, len);\n  } else if (nc->recv_mbuf.len == 0) {\n    /* Adopt buf as recv_mbuf's backing store. */\n    mbuf_free(&nc->recv_mbuf);\n    nc->recv_mbuf.buf = (char *) buf;\n    nc->recv_mbuf.size = nc->recv_mbuf.len = len;\n  } else {\n    mbuf_append(&nc->recv_mbuf, buf, len);\n    MG_FREE(buf);\n  }\n  mg_call(nc, NULL, nc->user_data, MG_EV_RECV, &len);\n}\n\nvoid mg_if_recv_tcp_cb(struct mg_connection *nc, void *buf, int len, int own) {\n  mg_recv_common(nc, buf, len, own);\n}\n\nvoid mg_if_recv_udp_cb(struct mg_connection *nc, void *buf, int len,\n                       union socket_address *sa, size_t sa_len) {\n  assert(nc->flags & MG_F_UDP);\n  DBG((\"%p %u\", nc, (unsigned int) len));\n  if (nc->flags & MG_F_LISTENING) {\n    struct mg_connection *lc = nc;\n    /*\n     * Do we have an existing connection for this source?\n     * This is very inefficient for long connection lists.\n     */\n    for (nc = mg_next(lc->mgr, NULL); nc != NULL; nc = mg_next(lc->mgr, nc)) {\n      if (memcmp(&nc->sa.sa, &sa->sa, sa_len) == 0 && nc->listener == lc) {\n        break;\n      }\n    }\n    if (nc == NULL) {\n      struct mg_add_sock_opts opts;\n      memset(&opts, 0, sizeof(opts));\n      /* Create fake connection w/out sock initialization */\n      nc = mg_create_connection_base(lc->mgr, lc->handler, opts);\n      if (nc != NULL) {\n        nc->sock = lc->sock;\n        nc->listener = lc;\n        nc->sa = *sa;\n        nc->proto_handler = lc->proto_handler;\n        nc->user_data = lc->user_data;\n        nc->recv_mbuf_limit = lc->recv_mbuf_limit;\n        nc->flags = MG_F_UDP;\n        /*\n         * Long-lived UDP \"connections\" i.e. interactions that involve more\n         * than one request and response are rare, most are transactional:\n         * response is sent and the \"connection\" is closed. Or - should be.\n         * But users (including ourselves) tend to forget about that part,\n         * because UDP is connectionless and one does not think about\n         * processing a UDP request as handling a connection that needs to be\n         * closed. Thus, we begin with SEND_AND_CLOSE flag set, which should\n         * be a reasonable default for most use cases, but it is possible to\n         * turn it off the connection should be kept alive after processing.\n         */\n        nc->flags |= MG_F_SEND_AND_CLOSE;\n        mg_add_conn(lc->mgr, nc);\n        mg_call(nc, NULL, nc->user_data, MG_EV_ACCEPT, &nc->sa);\n      } else {\n        DBG((\"OOM\"));\n        /* No return here, we still need to drop on the floor */\n      }\n    }\n  }\n  if (nc != NULL) {\n    mg_recv_common(nc, buf, len, 1);\n  } else {\n    /* Drop on the floor. */\n    MG_FREE(buf);\n    nc->iface->vtable->recved(nc, len);\n  }\n}\n\n/*\n * Schedules an async connect for a resolved address and proto.\n * Called from two places: `mg_connect_opt()` and from async resolver.\n * When called from the async resolver, it must trigger `MG_EV_CONNECT` event\n * with a failure flag to indicate connection failure.\n */\nMG_INTERNAL struct mg_connection *mg_do_connect(struct mg_connection *nc,\n                                                int proto,\n                                                union socket_address *sa) {\n  DBG((\"%p %s://%s:%hu\", nc, proto == SOCK_DGRAM ? \"udp\" : \"tcp\",\n       inet_ntoa(sa->sin.sin_addr), ntohs(sa->sin.sin_port)));\n\n  nc->flags |= MG_F_CONNECTING;\n  if (proto == SOCK_DGRAM) {\n    nc->iface->vtable->connect_udp(nc);\n  } else {\n    nc->iface->vtable->connect_tcp(nc, sa);\n  }\n  mg_add_conn(nc->mgr, nc);\n  return nc;\n}\n\nvoid mg_if_connect_cb(struct mg_connection *nc, int err) {\n  DBG((\"%p connect, err=%d\", nc, err));\n  nc->flags &= ~MG_F_CONNECTING;\n  if (err != 0) {\n    nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n  }\n  mg_call(nc, NULL, nc->user_data, MG_EV_CONNECT, &err);\n}\n\n#if MG_ENABLE_ASYNC_RESOLVER\n/*\n * Callback for the async resolver on mg_connect_opt() call.\n * Main task of this function is to trigger MG_EV_CONNECT event with\n *    either failure (and dealloc the connection)\n *    or success (and proceed with connect()\n */\nstatic void resolve_cb(struct mg_dns_message *msg, void *data,\n                       enum mg_resolve_err e) {\n  struct mg_connection *nc = (struct mg_connection *) data;\n  int i;\n  int failure = -1;\n\n  nc->flags &= ~MG_F_RESOLVING;\n  if (msg != NULL) {\n    /*\n     * Take the first DNS A answer and run...\n     */\n    for (i = 0; i < msg->num_answers; i++) {\n      if (msg->answers[i].rtype == MG_DNS_A_RECORD) {\n        /*\n         * Async resolver guarantees that there is at least one answer.\n         * TODO(lsm): handle IPv6 answers too\n         */\n        mg_dns_parse_record_data(msg, &msg->answers[i], &nc->sa.sin.sin_addr,\n                                 4);\n        mg_do_connect(nc, nc->flags & MG_F_UDP ? SOCK_DGRAM : SOCK_STREAM,\n                      &nc->sa);\n        return;\n      }\n    }\n  }\n\n  if (e == MG_RESOLVE_TIMEOUT) {\n    double now = mg_time();\n    mg_call(nc, NULL, nc->user_data, MG_EV_TIMER, &now);\n  }\n\n  /*\n   * If we get there was no MG_DNS_A_RECORD in the answer\n   */\n  mg_call(nc, NULL, nc->user_data, MG_EV_CONNECT, &failure);\n  mg_call(nc, NULL, nc->user_data, MG_EV_CLOSE, NULL);\n  mg_destroy_conn(nc, 1 /* destroy_if */);\n}\n#endif\n\nstruct mg_connection *mg_connect(struct mg_mgr *mgr, const char *address,\n                                 MG_CB(mg_event_handler_t callback,\n                                       void *user_data)) {\n  struct mg_connect_opts opts;\n  memset(&opts, 0, sizeof(opts));\n  return mg_connect_opt(mgr, address, MG_CB(callback, user_data), opts);\n}\n\nstruct mg_connection *mg_connect_opt(struct mg_mgr *mgr, const char *address,\n                                     MG_CB(mg_event_handler_t callback,\n                                           void *user_data),\n                                     struct mg_connect_opts opts) {\n  struct mg_connection *nc = NULL;\n  int proto, rc;\n  struct mg_add_sock_opts add_sock_opts;\n  char host[MG_MAX_HOST_LEN];\n\n  MG_COPY_COMMON_CONNECTION_OPTIONS(&add_sock_opts, &opts);\n\n  if ((nc = mg_create_connection(mgr, callback, add_sock_opts)) == NULL) {\n    return NULL;\n  }\n\n  if ((rc = mg_parse_address(address, &nc->sa, &proto, host, sizeof(host))) <\n      0) {\n    /* Address is malformed */\n    MG_SET_PTRPTR(opts.error_string, \"cannot parse address\");\n    mg_destroy_conn(nc, 1 /* destroy_if */);\n    return NULL;\n  }\n\n  nc->flags |= opts.flags & _MG_ALLOWED_CONNECT_FLAGS_MASK;\n  nc->flags |= (proto == SOCK_DGRAM) ? MG_F_UDP : 0;\n#if MG_ENABLE_CALLBACK_USERDATA\n  nc->user_data = user_data;\n#else\n  nc->user_data = opts.user_data;\n#endif\n\n#if MG_ENABLE_SSL\n  DBG((\"%p %s %s,%s,%s\", nc, address, (opts.ssl_cert ? opts.ssl_cert : \"-\"),\n       (opts.ssl_key ? opts.ssl_key : \"-\"),\n       (opts.ssl_ca_cert ? opts.ssl_ca_cert : \"-\")));\n\n  if (opts.ssl_cert != NULL || opts.ssl_ca_cert != NULL ||\n      opts.ssl_psk_identity != NULL) {\n    const char *err_msg = NULL;\n    struct mg_ssl_if_conn_params params;\n    if (nc->flags & MG_F_UDP) {\n      MG_SET_PTRPTR(opts.error_string, \"SSL for UDP is not supported\");\n      mg_destroy_conn(nc, 1 /* destroy_if */);\n      return NULL;\n    }\n    memset(&params, 0, sizeof(params));\n    params.cert = opts.ssl_cert;\n    params.key = opts.ssl_key;\n    params.ca_cert = opts.ssl_ca_cert;\n    params.cipher_suites = opts.ssl_cipher_suites;\n    params.psk_identity = opts.ssl_psk_identity;\n    params.psk_key = opts.ssl_psk_key;\n    if (opts.ssl_ca_cert != NULL) {\n      if (opts.ssl_server_name != NULL) {\n        if (strcmp(opts.ssl_server_name, \"*\") != 0) {\n          params.server_name = opts.ssl_server_name;\n        }\n      } else if (rc == 0) { /* If it's a DNS name, use host. */\n        params.server_name = host;\n      }\n    }\n    if (mg_ssl_if_conn_init(nc, &params, &err_msg) != MG_SSL_OK) {\n      MG_SET_PTRPTR(opts.error_string, err_msg);\n      mg_destroy_conn(nc, 1 /* destroy_if */);\n      return NULL;\n    }\n    nc->flags |= MG_F_SSL;\n  }\n#endif /* MG_ENABLE_SSL */\n\n  if (rc == 0) {\n#if MG_ENABLE_ASYNC_RESOLVER\n    /*\n     * DNS resolution is required for host.\n     * mg_parse_address() fills port in nc->sa, which we pass to resolve_cb()\n     */\n    struct mg_connection *dns_conn = NULL;\n    struct mg_resolve_async_opts o;\n    memset(&o, 0, sizeof(o));\n    o.dns_conn = &dns_conn;\n    o.nameserver = opts.nameserver;\n    if (mg_resolve_async_opt(nc->mgr, host, MG_DNS_A_RECORD, resolve_cb, nc,\n                             o) != 0) {\n      MG_SET_PTRPTR(opts.error_string, \"cannot schedule DNS lookup\");\n      mg_destroy_conn(nc, 1 /* destroy_if */);\n      return NULL;\n    }\n    nc->priv_2 = dns_conn;\n    nc->flags |= MG_F_RESOLVING;\n    return nc;\n#else\n    MG_SET_PTRPTR(opts.error_string, \"Resolver is disabled\");\n    mg_destroy_conn(nc, 1 /* destroy_if */);\n    return NULL;\n#endif\n  } else {\n    /* Address is parsed and resolved to IP. proceed with connect() */\n    return mg_do_connect(nc, proto, &nc->sa);\n  }\n}\n\nstruct mg_connection *mg_bind(struct mg_mgr *srv, const char *address,\n                              MG_CB(mg_event_handler_t event_handler,\n                                    void *user_data)) {\n  struct mg_bind_opts opts;\n  memset(&opts, 0, sizeof(opts));\n  return mg_bind_opt(srv, address, MG_CB(event_handler, user_data), opts);\n}\n\nstruct mg_connection *mg_bind_opt(struct mg_mgr *mgr, const char *address,\n                                  MG_CB(mg_event_handler_t callback,\n                                        void *user_data),\n                                  struct mg_bind_opts opts) {\n  union socket_address sa;\n  struct mg_connection *nc = NULL;\n  int proto, rc;\n  struct mg_add_sock_opts add_sock_opts;\n  char host[MG_MAX_HOST_LEN];\n\n  MG_COPY_COMMON_CONNECTION_OPTIONS(&add_sock_opts, &opts);\n\n#if MG_ENABLE_TUN\n  if (mg_strncmp(mg_mk_str(address), mg_mk_str(\"ws://\"), 5) == 0 ||\n      mg_strncmp(mg_mk_str(address), mg_mk_str(\"wss://\"), 6) == 0) {\n    return mg_tun_bind_opt(mgr, address, MG_CB(callback, user_data), opts);\n  }\n#endif\n\n  if (mg_parse_address(address, &sa, &proto, host, sizeof(host)) <= 0) {\n    MG_SET_PTRPTR(opts.error_string, \"cannot parse address\");\n    return NULL;\n  }\n\n  nc = mg_create_connection(mgr, callback, add_sock_opts);\n  if (nc == NULL) {\n    return NULL;\n  }\n\n  nc->sa = sa;\n  nc->flags |= MG_F_LISTENING;\n  if (proto == SOCK_DGRAM) nc->flags |= MG_F_UDP;\n\n#if MG_ENABLE_SSL\n  DBG((\"%p %s %s,%s,%s\", nc, address, (opts.ssl_cert ? opts.ssl_cert : \"-\"),\n       (opts.ssl_key ? opts.ssl_key : \"-\"),\n       (opts.ssl_ca_cert ? opts.ssl_ca_cert : \"-\")));\n\n  if (opts.ssl_cert != NULL || opts.ssl_ca_cert != NULL) {\n    const char *err_msg = NULL;\n    struct mg_ssl_if_conn_params params;\n    if (nc->flags & MG_F_UDP) {\n      MG_SET_PTRPTR(opts.error_string, \"SSL for UDP is not supported\");\n      mg_destroy_conn(nc, 1 /* destroy_if */);\n      return NULL;\n    }\n    memset(&params, 0, sizeof(params));\n    params.cert = opts.ssl_cert;\n    params.key = opts.ssl_key;\n    params.ca_cert = opts.ssl_ca_cert;\n    params.cipher_suites = opts.ssl_cipher_suites;\n    if (mg_ssl_if_conn_init(nc, &params, &err_msg) != MG_SSL_OK) {\n      MG_SET_PTRPTR(opts.error_string, err_msg);\n      mg_destroy_conn(nc, 1 /* destroy_if */);\n      return NULL;\n    }\n    nc->flags |= MG_F_SSL;\n  }\n#endif /* MG_ENABLE_SSL */\n\n  if (nc->flags & MG_F_UDP) {\n    rc = nc->iface->vtable->listen_udp(nc, &nc->sa);\n  } else {\n    rc = nc->iface->vtable->listen_tcp(nc, &nc->sa);\n  }\n  if (rc != 0) {\n    DBG((\"Failed to open listener: %d\", rc));\n    MG_SET_PTRPTR(opts.error_string, \"failed to open listener\");\n    mg_destroy_conn(nc, 1 /* destroy_if */);\n    return NULL;\n  }\n  mg_add_conn(nc->mgr, nc);\n\n#if MG_ENABLE_CALLBACK_USERDATA\n  (void) user_data;\n#endif\n  return nc;\n}\n\nstruct mg_connection *mg_next(struct mg_mgr *s, struct mg_connection *conn) {\n  return conn == NULL ? s->active_connections : conn->next;\n}\n\n#if MG_ENABLE_BROADCAST\nvoid mg_broadcast(struct mg_mgr *mgr, mg_event_handler_t cb, void *data,\n                  size_t len) {\n  struct ctl_msg ctl_msg;\n\n  /*\n   * Mongoose manager has a socketpair, `struct mg_mgr::ctl`,\n   * where `mg_broadcast()` pushes the message.\n   * `mg_mgr_poll()` wakes up, reads a message from the socket pair, and calls\n   * specified callback for each connection. Thus the callback function executes\n   * in event manager thread.\n   */\n  if (mgr->ctl[0] != INVALID_SOCKET && data != NULL &&\n      len < sizeof(ctl_msg.message)) {\n    size_t dummy;\n\n    ctl_msg.callback = cb;\n    memcpy(ctl_msg.message, data, len);\n    dummy = MG_SEND_FUNC(mgr->ctl[0], (char *) &ctl_msg,\n                         offsetof(struct ctl_msg, message) + len, 0);\n    dummy = MG_RECV_FUNC(mgr->ctl[0], (char *) &len, 1, 0);\n    (void) dummy; /* https://gcc.gnu.org/bugzilla/show_bug.cgi?id=25509 */\n  }\n}\n#endif /* MG_ENABLE_BROADCAST */\n\nstatic int isbyte(int n) {\n  return n >= 0 && n <= 255;\n}\n\nstatic int parse_net(const char *spec, uint32_t *net, uint32_t *mask) {\n  int n, a, b, c, d, slash = 32, len = 0;\n\n  if ((sscanf(spec, \"%d.%d.%d.%d/%d%n\", &a, &b, &c, &d, &slash, &n) == 5 ||\n       sscanf(spec, \"%d.%d.%d.%d%n\", &a, &b, &c, &d, &n) == 4) &&\n      isbyte(a) && isbyte(b) && isbyte(c) && isbyte(d) && slash >= 0 &&\n      slash < 33) {\n    len = n;\n    *net =\n        ((uint32_t) a << 24) | ((uint32_t) b << 16) | ((uint32_t) c << 8) | d;\n    *mask = slash ? 0xffffffffU << (32 - slash) : 0;\n  }\n\n  return len;\n}\n\nint mg_check_ip_acl(const char *acl, uint32_t remote_ip) {\n  int allowed, flag;\n  uint32_t net, mask;\n  struct mg_str vec;\n\n  /* If any ACL is set, deny by default */\n  allowed = (acl == NULL || *acl == '\\0') ? '+' : '-';\n\n  while ((acl = mg_next_comma_list_entry(acl, &vec, NULL)) != NULL) {\n    flag = vec.p[0];\n    if ((flag != '+' && flag != '-') ||\n        parse_net(&vec.p[1], &net, &mask) == 0) {\n      return -1;\n    }\n\n    if (net == (remote_ip & mask)) {\n      allowed = flag;\n    }\n  }\n\n  DBG((\"%08x %c\", remote_ip, allowed));\n  return allowed == '+';\n}\n\n/* Move data from one connection to another */\nvoid mg_forward(struct mg_connection *from, struct mg_connection *to) {\n  mg_send(to, from->recv_mbuf.buf, from->recv_mbuf.len);\n  mbuf_remove(&from->recv_mbuf, from->recv_mbuf.len);\n}\n\ndouble mg_set_timer(struct mg_connection *c, double timestamp) {\n  double result = c->ev_timer_time;\n  c->ev_timer_time = timestamp;\n  /*\n   * If this connection is resolving, it's not in the list of active\n   * connections, so not processed yet. It has a DNS resolver connection\n   * linked to it. Set up a timer for the DNS connection.\n   */\n  DBG((\"%p %p %d -> %lu\", c, c->priv_2, c->flags & MG_F_RESOLVING,\n       (unsigned long) timestamp));\n  if ((c->flags & MG_F_RESOLVING) && c->priv_2 != NULL) {\n    ((struct mg_connection *) c->priv_2)->ev_timer_time = timestamp;\n  }\n  return result;\n}\n\nvoid mg_sock_set(struct mg_connection *nc, sock_t sock) {\n  if (sock != INVALID_SOCKET) {\n    nc->iface->vtable->sock_set(nc, sock);\n  }\n}\n\nvoid mg_if_get_conn_addr(struct mg_connection *nc, int remote,\n                         union socket_address *sa) {\n  nc->iface->vtable->get_conn_addr(nc, remote, sa);\n}\n\nstruct mg_connection *mg_add_sock_opt(struct mg_mgr *s, sock_t sock,\n                                      MG_CB(mg_event_handler_t callback,\n                                            void *user_data),\n                                      struct mg_add_sock_opts opts) {\n#if MG_ENABLE_CALLBACK_USERDATA\n  opts.user_data = user_data;\n#endif\n\n  struct mg_connection *nc = mg_create_connection_base(s, callback, opts);\n  if (nc != NULL) {\n    mg_sock_set(nc, sock);\n    mg_add_conn(nc->mgr, nc);\n  }\n  return nc;\n}\n\nstruct mg_connection *mg_add_sock(struct mg_mgr *s, sock_t sock,\n                                  MG_CB(mg_event_handler_t callback,\n                                        void *user_data)) {\n  struct mg_add_sock_opts opts;\n  memset(&opts, 0, sizeof(opts));\n  return mg_add_sock_opt(s, sock, MG_CB(callback, user_data), opts);\n}\n\ndouble mg_time(void) {\n  return cs_time();\n}\n#ifdef MG_MODULE_LINES\n#line 1 \"mongoose/src/net_if_socket.h\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#ifndef CS_MONGOOSE_SRC_NET_IF_SOCKET_H_\n#define CS_MONGOOSE_SRC_NET_IF_SOCKET_H_\n\n/* Amalgamated: #include \"mongoose/src/net_if.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif /* __cplusplus */\n\n#ifndef MG_ENABLE_NET_IF_SOCKET\n#define MG_ENABLE_NET_IF_SOCKET MG_NET_IF == MG_NET_IF_SOCKET\n#endif\n\nextern const struct mg_iface_vtable mg_socket_iface_vtable;\n\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n\n#endif /* CS_MONGOOSE_SRC_NET_IF_SOCKET_H_ */\n#ifdef MG_MODULE_LINES\n#line 1 \"mongoose/src/net_if_tun.h\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#ifndef CS_MONGOOSE_SRC_NET_IF_TUN_H_\n#define CS_MONGOOSE_SRC_NET_IF_TUN_H_\n\n#if MG_ENABLE_TUN\n\n/* Amalgamated: #include \"mongoose/src/net_if.h\" */\n\nstruct mg_tun_client;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif /* __cplusplus */\n\nextern const struct mg_iface_vtable mg_tun_iface_vtable;\n\nstruct mg_connection *mg_tun_if_find_conn(struct mg_tun_client *client,\n                                          uint32_t stream_id);\n\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n\n#endif /* MG_ENABLE_TUN */\n\n#endif /* CS_MONGOOSE_SRC_NET_IF_TUN_H_ */\n#ifdef MG_MODULE_LINES\n#line 1 \"mongoose/src/net_if.c\"\n#endif\n/* Amalgamated: #include \"mongoose/src/net_if.h\" */\n/* Amalgamated: #include \"mongoose/src/internal.h\" */\n/* Amalgamated: #include \"mongoose/src/net_if_socket.h\" */\n/* Amalgamated: #include \"mongoose/src/net_if_tun.h\" */\n\nextern const struct mg_iface_vtable mg_default_iface_vtable;\n\n#if MG_ENABLE_TUN\nconst struct mg_iface_vtable *mg_ifaces[] = {&mg_default_iface_vtable,\n                                             &mg_tun_iface_vtable};\n#else\nconst struct mg_iface_vtable *mg_ifaces[] = {&mg_default_iface_vtable};\n#endif\n\nint mg_num_ifaces = (int) (sizeof(mg_ifaces) / sizeof(mg_ifaces[0]));\n\nstruct mg_iface *mg_if_create_iface(const struct mg_iface_vtable *vtable,\n                                    struct mg_mgr *mgr) {\n  struct mg_iface *iface = (struct mg_iface *) MG_CALLOC(1, sizeof(*iface));\n  iface->mgr = mgr;\n  iface->data = NULL;\n  iface->vtable = vtable;\n  return iface;\n}\n\nstruct mg_iface *mg_find_iface(struct mg_mgr *mgr,\n                               const struct mg_iface_vtable *vtable,\n                               struct mg_iface *from) {\n  int i = 0;\n  if (from != NULL) {\n    for (i = 0; i < mgr->num_ifaces; i++) {\n      if (mgr->ifaces[i] == from) {\n        i++;\n        break;\n      }\n    }\n  }\n\n  for (; i < mgr->num_ifaces; i++) {\n    if (mgr->ifaces[i]->vtable == vtable) {\n      return mgr->ifaces[i];\n    }\n  }\n  return NULL;\n}\n#ifdef MG_MODULE_LINES\n#line 1 \"mongoose/src/net_if_socket.c\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#if MG_ENABLE_NET_IF_SOCKET\n\n/* Amalgamated: #include \"mongoose/src/net_if_socket.h\" */\n/* Amalgamated: #include \"mongoose/src/internal.h\" */\n/* Amalgamated: #include \"mongoose/src/util.h\" */\n\n#define MG_TCP_RECV_BUFFER_SIZE 1024\n#define MG_UDP_RECV_BUFFER_SIZE 1500\n\nstatic sock_t mg_open_listening_socket(union socket_address *sa, int type,\n                                       int proto);\n#if MG_ENABLE_SSL\nstatic void mg_ssl_begin(struct mg_connection *nc);\n#endif\n\nvoid mg_set_non_blocking_mode(sock_t sock) {\n#ifdef _WIN32\n  unsigned long on = 1;\n  ioctlsocket(sock, FIONBIO, &on);\n#else\n  int flags = fcntl(sock, F_GETFL, 0);\n  fcntl(sock, F_SETFL, flags | O_NONBLOCK);\n#endif\n}\n\nstatic int mg_is_error(int n) {\n  int err = mg_get_errno();\n  return (n < 0 && err != EINPROGRESS && err != EWOULDBLOCK\n#ifndef WINCE\n          && err != EAGAIN && err != EINTR\n#endif\n#ifdef _WIN32\n          && WSAGetLastError() != WSAEINTR &&\n          WSAGetLastError() != WSAEWOULDBLOCK\n#endif\n          );\n}\n\nvoid mg_socket_if_connect_tcp(struct mg_connection *nc,\n                              const union socket_address *sa) {\n  int rc, proto = 0;\n  nc->sock = socket(AF_INET, SOCK_STREAM, proto);\n  if (nc->sock == INVALID_SOCKET) {\n    nc->err = mg_get_errno() ? mg_get_errno() : 1;\n    return;\n  }\n#if !defined(MG_ESP8266)\n  mg_set_non_blocking_mode(nc->sock);\n#endif\n  rc = connect(nc->sock, &sa->sa, sizeof(sa->sin));\n  nc->err = mg_is_error(rc) ? mg_get_errno() : 0;\n  DBG((\"%p sock %d rc %d errno %d err %d\", nc, nc->sock, rc, mg_get_errno(),\n       nc->err));\n}\n\nvoid mg_socket_if_connect_udp(struct mg_connection *nc) {\n  nc->sock = socket(AF_INET, SOCK_DGRAM, 0);\n  if (nc->sock == INVALID_SOCKET) {\n    nc->err = mg_get_errno() ? mg_get_errno() : 1;\n    return;\n  }\n  if (nc->flags & MG_F_ENABLE_BROADCAST) {\n    int optval = 1;\n    setsockopt(nc->sock, SOL_SOCKET, SO_BROADCAST, (const char *) &optval,\n               sizeof(optval));\n  }\n  nc->err = 0;\n}\n\nint mg_socket_if_listen_tcp(struct mg_connection *nc,\n                            union socket_address *sa) {\n  int proto = 0;\n  sock_t sock = mg_open_listening_socket(sa, SOCK_STREAM, proto);\n  if (sock == INVALID_SOCKET) {\n    return (mg_get_errno() ? mg_get_errno() : 1);\n  }\n  mg_sock_set(nc, sock);\n  return 0;\n}\n\nint mg_socket_if_listen_udp(struct mg_connection *nc,\n                            union socket_address *sa) {\n  sock_t sock = mg_open_listening_socket(sa, SOCK_DGRAM, 0);\n  if (sock == INVALID_SOCKET) return (mg_get_errno() ? mg_get_errno() : 1);\n  mg_sock_set(nc, sock);\n  return 0;\n}\n\nvoid mg_socket_if_tcp_send(struct mg_connection *nc, const void *buf,\n                           size_t len) {\n  mbuf_append(&nc->send_mbuf, buf, len);\n}\n\nvoid mg_socket_if_udp_send(struct mg_connection *nc, const void *buf,\n                           size_t len) {\n  mbuf_append(&nc->send_mbuf, buf, len);\n}\n\nvoid mg_socket_if_recved(struct mg_connection *nc, size_t len) {\n  (void) nc;\n  (void) len;\n}\n\nint mg_socket_if_create_conn(struct mg_connection *nc) {\n  (void) nc;\n  return 1;\n}\n\nvoid mg_socket_if_destroy_conn(struct mg_connection *nc) {\n  if (nc->sock == INVALID_SOCKET) return;\n  if (!(nc->flags & MG_F_UDP)) {\n    closesocket(nc->sock);\n  } else {\n    /* Only close outgoing UDP sockets or listeners. */\n    if (nc->listener == NULL) closesocket(nc->sock);\n  }\n  nc->sock = INVALID_SOCKET;\n}\n\nstatic int mg_accept_conn(struct mg_connection *lc) {\n  struct mg_connection *nc;\n  union socket_address sa;\n  socklen_t sa_len = sizeof(sa);\n  /* NOTE(lsm): on Windows, sock is always > FD_SETSIZE */\n  sock_t sock = accept(lc->sock, &sa.sa, &sa_len);\n  if (sock == INVALID_SOCKET) {\n    if (mg_is_error(-1)) DBG((\"%p: failed to accept: %d\", lc, mg_get_errno()));\n    return 0;\n  }\n  nc = mg_if_accept_new_conn(lc);\n  if (nc == NULL) {\n    closesocket(sock);\n    return 0;\n  }\n  DBG((\"%p conn from %s:%d\", nc, inet_ntoa(sa.sin.sin_addr),\n       ntohs(sa.sin.sin_port)));\n  mg_sock_set(nc, sock);\n#if MG_ENABLE_SSL\n  if (lc->flags & MG_F_SSL) {\n    if (mg_ssl_if_conn_accept(nc, lc) != MG_SSL_OK) mg_close_conn(nc);\n  } else\n#endif\n  {\n    mg_if_accept_tcp_cb(nc, &sa, sa_len);\n  }\n  return 1;\n}\n\n/* 'sa' must be an initialized address to bind to */\nstatic sock_t mg_open_listening_socket(union socket_address *sa, int type,\n                                       int proto) {\n  socklen_t sa_len =\n      (sa->sa.sa_family == AF_INET) ? sizeof(sa->sin) : sizeof(sa->sin6);\n  sock_t sock = INVALID_SOCKET;\n#if !MG_LWIP\n  int on = 1;\n#endif\n\n  if ((sock = socket(sa->sa.sa_family, type, proto)) != INVALID_SOCKET &&\n#if !MG_LWIP /* LWIP doesn't support either */\n#if defined(_WIN32) && defined(SO_EXCLUSIVEADDRUSE) && !defined(WINCE)\n      /* \"Using SO_REUSEADDR and SO_EXCLUSIVEADDRUSE\" http://goo.gl/RmrFTm */\n      !setsockopt(sock, SOL_SOCKET, SO_EXCLUSIVEADDRUSE, (void *) &on,\n                  sizeof(on)) &&\n#endif\n\n#if !defined(_WIN32) || !defined(SO_EXCLUSIVEADDRUSE)\n      /*\n       * SO_RESUSEADDR is not enabled on Windows because the semantics of\n       * SO_REUSEADDR on UNIX and Windows is different. On Windows,\n       * SO_REUSEADDR allows to bind a socket to a port without error even if\n       * the port is already open by another program. This is not the behavior\n       * SO_REUSEADDR was designed for, and leads to hard-to-track failure\n       * scenarios. Therefore, SO_REUSEADDR was disabled on Windows unless\n       * SO_EXCLUSIVEADDRUSE is supported and set on a socket.\n       */\n      !setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (void *) &on, sizeof(on)) &&\n#endif\n#endif /* !MG_LWIP */\n\n      !bind(sock, &sa->sa, sa_len) &&\n      (type == SOCK_DGRAM || listen(sock, SOMAXCONN) == 0)) {\n#if !MG_LWIP\n    mg_set_non_blocking_mode(sock);\n    /* In case port was set to 0, get the real port number */\n    (void) getsockname(sock, &sa->sa, &sa_len);\n#endif\n  } else if (sock != INVALID_SOCKET) {\n    closesocket(sock);\n    sock = INVALID_SOCKET;\n  }\n\n  return sock;\n}\n\nstatic void mg_write_to_socket(struct mg_connection *nc) {\n  struct mbuf *io = &nc->send_mbuf;\n  int n = 0;\n\n#if MG_LWIP\n  /* With LWIP we don't know if the socket is ready */\n  if (io->len == 0) return;\n#endif\n\n  assert(io->len > 0);\n\n  if (nc->flags & MG_F_UDP) {\n    int n =\n        sendto(nc->sock, io->buf, io->len, 0, &nc->sa.sa, sizeof(nc->sa.sin));\n    DBG((\"%p %d %d %d %s:%hu\", nc, nc->sock, n, mg_get_errno(),\n         inet_ntoa(nc->sa.sin.sin_addr), ntohs(nc->sa.sin.sin_port)));\n    if (n > 0) {\n      mbuf_remove(io, n);\n      mg_if_sent_cb(nc, n);\n    }\n    return;\n  }\n\n#if MG_ENABLE_SSL\n  if (nc->flags & MG_F_SSL) {\n    if (nc->flags & MG_F_SSL_HANDSHAKE_DONE) {\n      n = mg_ssl_if_write(nc, io->buf, io->len);\n      DBG((\"%p %d bytes -> %d (SSL)\", nc, n, nc->sock));\n      if (n < 0) {\n        if (n != MG_SSL_WANT_READ && n != MG_SSL_WANT_WRITE) {\n          nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n        }\n        return;\n      } else {\n        /* Successful SSL operation, clear off SSL wait flags */\n        nc->flags &= ~(MG_F_WANT_READ | MG_F_WANT_WRITE);\n      }\n    } else {\n      mg_ssl_begin(nc);\n      return;\n    }\n  } else\n#endif\n  {\n    n = (int) MG_SEND_FUNC(nc->sock, io->buf, io->len, 0);\n    DBG((\"%p %d bytes -> %d\", nc, n, nc->sock));\n    if (n < 0 && mg_is_error(n)) {\n      /* Something went wrong, drop the connection. */\n      nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n      return;\n    }\n  }\n\n  if (n > 0) {\n    mbuf_remove(io, n);\n    mg_if_sent_cb(nc, n);\n  }\n}\n\nMG_INTERNAL size_t recv_avail_size(struct mg_connection *conn, size_t max) {\n  size_t avail;\n  if (conn->recv_mbuf_limit < conn->recv_mbuf.len) return 0;\n  avail = conn->recv_mbuf_limit - conn->recv_mbuf.len;\n  return avail > max ? max : avail;\n}\n\nstatic void mg_handle_tcp_read(struct mg_connection *conn) {\n  int n = 0;\n  char *buf = (char *) MG_MALLOC(MG_TCP_RECV_BUFFER_SIZE);\n\n  if (buf == NULL) {\n    DBG((\"OOM\"));\n    return;\n  }\n\n#if MG_ENABLE_SSL\n  if (conn->flags & MG_F_SSL) {\n    if (conn->flags & MG_F_SSL_HANDSHAKE_DONE) {\n      /* SSL library may have more bytes ready to read than we ask to read.\n       * Therefore, read in a loop until we read everything. Without the loop,\n       * we skip to the next select() cycle which can just timeout. */\n      while ((n = mg_ssl_if_read(conn, buf, MG_TCP_RECV_BUFFER_SIZE)) > 0) {\n        DBG((\"%p %d bytes <- %d (SSL)\", conn, n, conn->sock));\n        mg_if_recv_tcp_cb(conn, buf, n, 1 /* own */);\n        buf = NULL;\n        if (conn->flags & MG_F_CLOSE_IMMEDIATELY) break;\n        /* buf has been freed, we need a new one. */\n        buf = (char *) MG_MALLOC(MG_TCP_RECV_BUFFER_SIZE);\n        if (buf == NULL) break;\n      }\n      MG_FREE(buf);\n      if (n < 0 && n != MG_SSL_WANT_READ) conn->flags |= MG_F_CLOSE_IMMEDIATELY;\n    } else {\n      MG_FREE(buf);\n      mg_ssl_begin(conn);\n      return;\n    }\n  } else\n#endif\n  {\n    n = (int) MG_RECV_FUNC(conn->sock, buf,\n                           recv_avail_size(conn, MG_TCP_RECV_BUFFER_SIZE), 0);\n    DBG((\"%p %d bytes (PLAIN) <- %d\", conn, n, conn->sock));\n    if (n > 0) {\n      mg_if_recv_tcp_cb(conn, buf, n, 1 /* own */);\n    } else {\n      MG_FREE(buf);\n    }\n    if (n == 0) {\n      /* Orderly shutdown of the socket, try flushing output. */\n      conn->flags |= MG_F_SEND_AND_CLOSE;\n    } else if (mg_is_error(n)) {\n      conn->flags |= MG_F_CLOSE_IMMEDIATELY;\n    }\n  }\n}\n\nstatic int mg_recvfrom(struct mg_connection *nc, union socket_address *sa,\n                       socklen_t *sa_len, char **buf) {\n  int n;\n  *buf = (char *) MG_MALLOC(MG_UDP_RECV_BUFFER_SIZE);\n  if (*buf == NULL) {\n    DBG((\"Out of memory\"));\n    return -ENOMEM;\n  }\n  n = recvfrom(nc->sock, *buf, MG_UDP_RECV_BUFFER_SIZE, 0, &sa->sa, sa_len);\n  if (n <= 0) {\n    DBG((\"%p recvfrom: %s\", nc, strerror(mg_get_errno())));\n    MG_FREE(*buf);\n  }\n  return n;\n}\n\nstatic void mg_handle_udp_read(struct mg_connection *nc) {\n  char *buf = NULL;\n  union socket_address sa;\n  socklen_t sa_len = sizeof(sa);\n  int n = mg_recvfrom(nc, &sa, &sa_len, &buf);\n  DBG((\"%p %d bytes from %s:%d\", nc, n, inet_ntoa(nc->sa.sin.sin_addr),\n       ntohs(nc->sa.sin.sin_port)));\n  mg_if_recv_udp_cb(nc, buf, n, &sa, sa_len);\n}\n\n#if MG_ENABLE_SSL\nstatic void mg_ssl_begin(struct mg_connection *nc) {\n  int server_side = (nc->listener != NULL);\n  enum mg_ssl_if_result res = mg_ssl_if_handshake(nc);\n  DBG((\"%p %d res %d\", nc, server_side, res));\n\n  if (res == MG_SSL_OK) {\n    nc->flags |= MG_F_SSL_HANDSHAKE_DONE;\n    nc->flags &= ~(MG_F_WANT_READ | MG_F_WANT_WRITE);\n\n    if (server_side) {\n      union socket_address sa;\n      socklen_t sa_len = sizeof(sa);\n      (void) getpeername(nc->sock, &sa.sa, &sa_len);\n      mg_if_accept_tcp_cb(nc, &sa, sa_len);\n    } else {\n      mg_if_connect_cb(nc, 0);\n    }\n  } else if (res != MG_SSL_WANT_READ && res != MG_SSL_WANT_WRITE) {\n    if (!server_side) {\n      mg_if_connect_cb(nc, res);\n    }\n    nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n  }\n}\n#endif /* MG_ENABLE_SSL */\n\n#define _MG_F_FD_CAN_READ 1\n#define _MG_F_FD_CAN_WRITE 1 << 1\n#define _MG_F_FD_ERROR 1 << 2\n\nvoid mg_mgr_handle_conn(struct mg_connection *nc, int fd_flags, double now) {\n  int worth_logging =\n      fd_flags != 0 || (nc->flags & (MG_F_WANT_READ | MG_F_WANT_WRITE));\n  if (worth_logging) {\n    DBG((\"%p fd=%d fd_flags=%d nc_flags=%lu rmbl=%d smbl=%d\", nc, nc->sock,\n         fd_flags, nc->flags, (int) nc->recv_mbuf.len,\n         (int) nc->send_mbuf.len));\n  }\n\n  if (nc->flags & MG_F_CONNECTING) {\n    if (fd_flags != 0) {\n      int err = 0;\n#if !defined(MG_ESP8266)\n      if (!(nc->flags & MG_F_UDP)) {\n        socklen_t len = sizeof(err);\n        int ret =\n            getsockopt(nc->sock, SOL_SOCKET, SO_ERROR, (char *) &err, &len);\n        if (ret != 0) {\n          err = 1;\n        } else if (err == EAGAIN || err == EWOULDBLOCK) {\n          err = 0;\n        }\n      }\n#else\n      /*\n       * On ESP8266 we use blocking connect.\n       */\n      err = nc->err;\n#endif\n#if MG_ENABLE_SSL\n      if ((nc->flags & MG_F_SSL) && err == 0) {\n        mg_ssl_begin(nc);\n      } else {\n        mg_if_connect_cb(nc, err);\n      }\n#else\n      mg_if_connect_cb(nc, err);\n#endif\n    } else if (nc->err != 0) {\n      mg_if_connect_cb(nc, nc->err);\n    }\n  }\n\n  if (fd_flags & _MG_F_FD_CAN_READ) {\n    if (nc->flags & MG_F_UDP) {\n      mg_handle_udp_read(nc);\n    } else {\n      if (nc->flags & MG_F_LISTENING) {\n        /*\n         * We're not looping here, and accepting just one connection at\n         * a time. The reason is that eCos does not respect non-blocking\n         * flag on a listening socket and hangs in a loop.\n         */\n        mg_accept_conn(nc);\n      } else {\n        mg_handle_tcp_read(nc);\n      }\n    }\n  }\n\n  if (!(nc->flags & MG_F_CLOSE_IMMEDIATELY)) {\n    if ((fd_flags & _MG_F_FD_CAN_WRITE) && nc->send_mbuf.len > 0) {\n      mg_write_to_socket(nc);\n    }\n    mg_if_poll(nc, (time_t) now);\n    mg_if_timer(nc, now);\n  }\n\n  if (worth_logging) {\n    DBG((\"%p after fd=%d nc_flags=%lu rmbl=%d smbl=%d\", nc, nc->sock, nc->flags,\n         (int) nc->recv_mbuf.len, (int) nc->send_mbuf.len));\n  }\n}\n\n#if MG_ENABLE_BROADCAST\nstatic void mg_mgr_handle_ctl_sock(struct mg_mgr *mgr) {\n  struct ctl_msg ctl_msg;\n  int len =\n      (int) MG_RECV_FUNC(mgr->ctl[1], (char *) &ctl_msg, sizeof(ctl_msg), 0);\n  size_t dummy = MG_SEND_FUNC(mgr->ctl[1], ctl_msg.message, 1, 0);\n  DBG((\"read %d from ctl socket\", len));\n  (void) dummy; /* https://gcc.gnu.org/bugzilla/show_bug.cgi?id=25509 */\n  if (len >= (int) sizeof(ctl_msg.callback) && ctl_msg.callback != NULL) {\n    struct mg_connection *nc;\n    for (nc = mg_next(mgr, NULL); nc != NULL; nc = mg_next(mgr, nc)) {\n      ctl_msg.callback(nc, MG_EV_POLL,\n                       ctl_msg.message MG_UD_ARG(nc->user_data));\n    }\n  }\n}\n#endif\n\n/* Associate a socket to a connection. */\nvoid mg_socket_if_sock_set(struct mg_connection *nc, sock_t sock) {\n  mg_set_non_blocking_mode(sock);\n  mg_set_close_on_exec(sock);\n  nc->sock = sock;\n  DBG((\"%p %d\", nc, sock));\n}\n\nvoid mg_socket_if_init(struct mg_iface *iface) {\n  (void) iface;\n  DBG((\"%p using select()\", iface->mgr));\n#if MG_ENABLE_BROADCAST\n  do {\n    mg_socketpair(iface->mgr->ctl, SOCK_DGRAM);\n  } while (iface->mgr->ctl[0] == INVALID_SOCKET);\n#endif\n}\n\nvoid mg_socket_if_free(struct mg_iface *iface) {\n  (void) iface;\n}\n\nvoid mg_socket_if_add_conn(struct mg_connection *nc) {\n  (void) nc;\n}\n\nvoid mg_socket_if_remove_conn(struct mg_connection *nc) {\n  (void) nc;\n}\n\nvoid mg_add_to_set(sock_t sock, fd_set *set, sock_t *max_fd) {\n  if (sock != INVALID_SOCKET\n#ifdef __unix__\n      && sock < (sock_t) FD_SETSIZE\n#endif\n      ) {\n    FD_SET(sock, set);\n    if (*max_fd == INVALID_SOCKET || sock > *max_fd) {\n      *max_fd = sock;\n    }\n  }\n}\n\ntime_t mg_socket_if_poll(struct mg_iface *iface, int timeout_ms) {\n  struct mg_mgr *mgr = iface->mgr;\n  double now = mg_time();\n  double min_timer;\n  struct mg_connection *nc, *tmp;\n  struct timeval tv;\n  fd_set read_set, write_set, err_set;\n  sock_t max_fd = INVALID_SOCKET;\n  int num_fds, num_ev, num_timers = 0;\n#ifdef __unix__\n  int try_dup = 1;\n#endif\n\n  FD_ZERO(&read_set);\n  FD_ZERO(&write_set);\n  FD_ZERO(&err_set);\n#if MG_ENABLE_BROADCAST\n  mg_add_to_set(mgr->ctl[1], &read_set, &max_fd);\n#endif\n\n  /*\n   * Note: it is ok to have connections with sock == INVALID_SOCKET in the list,\n   * e.g. timer-only \"connections\".\n   */\n  min_timer = 0;\n  for (nc = mgr->active_connections, num_fds = 0; nc != NULL; nc = tmp) {\n    tmp = nc->next;\n\n    if (nc->sock != INVALID_SOCKET) {\n      num_fds++;\n\n#ifdef __unix__\n      /* A hack to make sure all our file descriptos fit into FD_SETSIZE. */\n      if (nc->sock >= (sock_t) FD_SETSIZE && try_dup) {\n        int new_sock = dup(nc->sock);\n        if (new_sock >= 0 && new_sock < (sock_t) FD_SETSIZE) {\n          closesocket(nc->sock);\n          DBG((\"new sock %d -> %d\", nc->sock, new_sock));\n          nc->sock = new_sock;\n        } else {\n          try_dup = 0;\n        }\n      }\n#endif\n\n      if (!(nc->flags & MG_F_WANT_WRITE) &&\n          nc->recv_mbuf.len < nc->recv_mbuf_limit &&\n          (!(nc->flags & MG_F_UDP) || nc->listener == NULL)) {\n        mg_add_to_set(nc->sock, &read_set, &max_fd);\n      }\n\n      if (((nc->flags & MG_F_CONNECTING) && !(nc->flags & MG_F_WANT_READ)) ||\n          (nc->send_mbuf.len > 0 && !(nc->flags & MG_F_CONNECTING))) {\n        mg_add_to_set(nc->sock, &write_set, &max_fd);\n        mg_add_to_set(nc->sock, &err_set, &max_fd);\n      }\n    }\n\n    if (nc->ev_timer_time > 0) {\n      if (num_timers == 0 || nc->ev_timer_time < min_timer) {\n        min_timer = nc->ev_timer_time;\n      }\n      num_timers++;\n    }\n  }\n\n  /*\n   * If there is a timer to be fired earlier than the requested timeout,\n   * adjust the timeout.\n   */\n  if (num_timers > 0) {\n    double timer_timeout_ms = (min_timer - mg_time()) * 1000 + 1 /* rounding */;\n    if (timer_timeout_ms < timeout_ms) {\n      timeout_ms = (int) timer_timeout_ms;\n    }\n  }\n  if (timeout_ms < 0) timeout_ms = 0;\n\n  tv.tv_sec = timeout_ms / 1000;\n  tv.tv_usec = (timeout_ms % 1000) * 1000;\n\n  num_ev = select((int) max_fd + 1, &read_set, &write_set, &err_set, &tv);\n  now = mg_time();\n#if 0\n  DBG((\"select @ %ld num_ev=%d of %d, timeout=%d\", (long) now, num_ev, num_fds,\n       timeout_ms));\n#endif\n\n#if MG_ENABLE_BROADCAST\n  if (num_ev > 0 && mgr->ctl[1] != INVALID_SOCKET &&\n      FD_ISSET(mgr->ctl[1], &read_set)) {\n    mg_mgr_handle_ctl_sock(mgr);\n  }\n#endif\n\n  for (nc = mgr->active_connections; nc != NULL; nc = tmp) {\n    int fd_flags = 0;\n    if (nc->sock != INVALID_SOCKET) {\n      if (num_ev > 0) {\n        fd_flags = (FD_ISSET(nc->sock, &read_set) &&\n                            (!(nc->flags & MG_F_UDP) || nc->listener == NULL)\n                        ? _MG_F_FD_CAN_READ\n                        : 0) |\n                   (FD_ISSET(nc->sock, &write_set) ? _MG_F_FD_CAN_WRITE : 0) |\n                   (FD_ISSET(nc->sock, &err_set) ? _MG_F_FD_ERROR : 0);\n      }\n#if MG_LWIP\n      /* With LWIP socket emulation layer, we don't get write events for UDP */\n      if ((nc->flags & MG_F_UDP) && nc->listener == NULL) {\n        fd_flags |= _MG_F_FD_CAN_WRITE;\n      }\n#endif\n    }\n    tmp = nc->next;\n    mg_mgr_handle_conn(nc, fd_flags, now);\n  }\n\n  for (nc = mgr->active_connections; nc != NULL; nc = tmp) {\n    tmp = nc->next;\n    if ((nc->flags & MG_F_CLOSE_IMMEDIATELY) ||\n        (nc->send_mbuf.len == 0 && (nc->flags & MG_F_SEND_AND_CLOSE))) {\n      mg_close_conn(nc);\n    }\n  }\n\n  return (time_t) now;\n}\n\n#if MG_ENABLE_BROADCAST\nint mg_socketpair(sock_t sp[2], int sock_type) {\n  union socket_address sa;\n  sock_t sock;\n  socklen_t len = sizeof(sa.sin);\n  int ret = 0;\n\n  sock = sp[0] = sp[1] = INVALID_SOCKET;\n\n  (void) memset(&sa, 0, sizeof(sa));\n  sa.sin.sin_family = AF_INET;\n  sa.sin.sin_port = htons(0);\n  sa.sin.sin_addr.s_addr = htonl(0x7f000001); /* 127.0.0.1 */\n\n  if ((sock = socket(AF_INET, sock_type, 0)) == INVALID_SOCKET) {\n  } else if (bind(sock, &sa.sa, len) != 0) {\n  } else if (sock_type == SOCK_STREAM && listen(sock, 1) != 0) {\n  } else if (getsockname(sock, &sa.sa, &len) != 0) {\n  } else if ((sp[0] = socket(AF_INET, sock_type, 0)) == INVALID_SOCKET) {\n  } else if (connect(sp[0], &sa.sa, len) != 0) {\n  } else if (sock_type == SOCK_DGRAM &&\n             (getsockname(sp[0], &sa.sa, &len) != 0 ||\n              connect(sock, &sa.sa, len) != 0)) {\n  } else if ((sp[1] = (sock_type == SOCK_DGRAM ? sock\n                                               : accept(sock, &sa.sa, &len))) ==\n             INVALID_SOCKET) {\n  } else {\n    mg_set_close_on_exec(sp[0]);\n    mg_set_close_on_exec(sp[1]);\n    if (sock_type == SOCK_STREAM) closesocket(sock);\n    ret = 1;\n  }\n\n  if (!ret) {\n    if (sp[0] != INVALID_SOCKET) closesocket(sp[0]);\n    if (sp[1] != INVALID_SOCKET) closesocket(sp[1]);\n    if (sock != INVALID_SOCKET) closesocket(sock);\n    sock = sp[0] = sp[1] = INVALID_SOCKET;\n  }\n\n  return ret;\n}\n#endif /* MG_ENABLE_BROADCAST */\n\nstatic void mg_sock_get_addr(sock_t sock, int remote,\n                             union socket_address *sa) {\n  socklen_t slen = sizeof(*sa);\n  memset(sa, 0, slen);\n  if (remote) {\n    getpeername(sock, &sa->sa, &slen);\n  } else {\n    getsockname(sock, &sa->sa, &slen);\n  }\n}\n\nvoid mg_sock_to_str(sock_t sock, char *buf, size_t len, int flags) {\n  union socket_address sa;\n  mg_sock_get_addr(sock, flags & MG_SOCK_STRINGIFY_REMOTE, &sa);\n  mg_sock_addr_to_str(&sa, buf, len, flags);\n}\n\nvoid mg_socket_if_get_conn_addr(struct mg_connection *nc, int remote,\n                                union socket_address *sa) {\n  mg_sock_get_addr(nc->sock, remote, sa);\n}\n\n/* clang-format off */\n#define MG_SOCKET_IFACE_VTABLE                                          \\\n  {                                                                     \\\n    mg_socket_if_init,                                                  \\\n    mg_socket_if_free,                                                  \\\n    mg_socket_if_add_conn,                                              \\\n    mg_socket_if_remove_conn,                                           \\\n    mg_socket_if_poll,                                                  \\\n    mg_socket_if_listen_tcp,                                            \\\n    mg_socket_if_listen_udp,                                            \\\n    mg_socket_if_connect_tcp,                                           \\\n    mg_socket_if_connect_udp,                                           \\\n    mg_socket_if_tcp_send,                                              \\\n    mg_socket_if_udp_send,                                              \\\n    mg_socket_if_recved,                                                \\\n    mg_socket_if_create_conn,                                           \\\n    mg_socket_if_destroy_conn,                                          \\\n    mg_socket_if_sock_set,                                              \\\n    mg_socket_if_get_conn_addr,                                         \\\n  }\n/* clang-format on */\n\nconst struct mg_iface_vtable mg_socket_iface_vtable = MG_SOCKET_IFACE_VTABLE;\n#if MG_NET_IF == MG_NET_IF_SOCKET\nconst struct mg_iface_vtable mg_default_iface_vtable = MG_SOCKET_IFACE_VTABLE;\n#endif\n\n#endif /* MG_ENABLE_NET_IF_SOCKET */\n#ifdef MG_MODULE_LINES\n#line 1 \"mongoose/src/net_if_tun.c\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#if MG_ENABLE_TUN\n\n/* Amalgamated: #include \"common/cs_dbg.h\" */\n/* Amalgamated: #include \"common/cs_time.h\" */\n/* Amalgamated: #include \"mongoose/src/internal.h\" */\n/* Amalgamated: #include \"mongoose/src/net_if_tun.h\" */\n/* Amalgamated: #include \"mongoose/src/tun.h\" */\n/* Amalgamated: #include \"mongoose/src/util.h\" */\n\n#define MG_TCP_RECV_BUFFER_SIZE 1024\n#define MG_UDP_RECV_BUFFER_SIZE 1500\n\nvoid mg_tun_if_connect_tcp(struct mg_connection *nc,\n                           const union socket_address *sa) {\n  (void) nc;\n  (void) sa;\n}\n\nvoid mg_tun_if_connect_udp(struct mg_connection *nc) {\n  (void) nc;\n}\n\nint mg_tun_if_listen_tcp(struct mg_connection *nc, union socket_address *sa) {\n  (void) nc;\n  (void) sa;\n  return 0;\n}\n\nint mg_tun_if_listen_udp(struct mg_connection *nc, union socket_address *sa) {\n  (void) nc;\n  (void) sa;\n  return -1;\n}\n\nvoid mg_tun_if_tcp_send(struct mg_connection *nc, const void *buf, size_t len) {\n  struct mg_tun_client *client = (struct mg_tun_client *) nc->iface->data;\n  uint32_t stream_id = (uint32_t)(uintptr_t) nc->mgr_data;\n  struct mg_str msg = {(char *) buf, len};\n#if MG_ENABLE_HEXDUMP\n  char hex[512];\n  mg_hexdump(buf, len, hex, sizeof(hex));\n  LOG(LL_DEBUG, (\"sending to stream %zu:\\n%s\", stream_id, hex));\n#endif\n\n  mg_tun_send_frame(client->disp, stream_id, MG_TUN_DATA_FRAME, 0, msg);\n}\n\nvoid mg_tun_if_udp_send(struct mg_connection *nc, const void *buf, size_t len) {\n  (void) nc;\n  (void) buf;\n  (void) len;\n}\n\nvoid mg_tun_if_recved(struct mg_connection *nc, size_t len) {\n  (void) nc;\n  (void) len;\n}\n\nint mg_tun_if_create_conn(struct mg_connection *nc) {\n  (void) nc;\n  return 1;\n}\n\nvoid mg_tun_if_destroy_conn(struct mg_connection *nc) {\n  struct mg_tun_client *client = (struct mg_tun_client *) nc->iface->data;\n\n  if (nc->flags & MG_F_LISTENING) {\n    mg_tun_destroy_client(client);\n  } else if (client->disp) {\n    uint32_t stream_id = (uint32_t)(uintptr_t) nc->mgr_data;\n    struct mg_str msg = {NULL, 0};\n\n    LOG(LL_DEBUG, (\"closing %zu:\", stream_id));\n    mg_tun_send_frame(client->disp, stream_id, MG_TUN_DATA_FRAME,\n                      MG_TUN_F_END_STREAM, msg);\n  }\n}\n\n/* Associate a socket to a connection. */\nvoid mg_tun_if_sock_set(struct mg_connection *nc, sock_t sock) {\n  (void) nc;\n  (void) sock;\n}\n\nvoid mg_tun_if_init(struct mg_iface *iface) {\n  (void) iface;\n}\n\nvoid mg_tun_if_free(struct mg_iface *iface) {\n  (void) iface;\n}\n\nvoid mg_tun_if_add_conn(struct mg_connection *nc) {\n  nc->sock = INVALID_SOCKET;\n}\n\nvoid mg_tun_if_remove_conn(struct mg_connection *nc) {\n  (void) nc;\n}\n\ntime_t mg_tun_if_poll(struct mg_iface *iface, int timeout_ms) {\n  (void) iface;\n  (void) timeout_ms;\n  return (time_t) cs_time();\n}\n\nvoid mg_tun_if_get_conn_addr(struct mg_connection *nc, int remote,\n                             union socket_address *sa) {\n  (void) nc;\n  (void) remote;\n  (void) sa;\n}\n\nstruct mg_connection *mg_tun_if_find_conn(struct mg_tun_client *client,\n                                          uint32_t stream_id) {\n  struct mg_connection *nc = NULL;\n\n  for (nc = client->mgr->active_connections; nc != NULL; nc = nc->next) {\n    if (nc->iface != client->iface || (nc->flags & MG_F_LISTENING)) {\n      continue;\n    }\n    if (stream_id == (uint32_t)(uintptr_t) nc->mgr_data) {\n      return nc;\n    }\n  }\n\n  if (stream_id > client->last_stream_id) {\n    /* create a new connection */\n    LOG(LL_DEBUG, (\"new stream 0x%lx, accepting\", stream_id));\n    nc = mg_if_accept_new_conn(client->listener);\n    nc->mgr_data = (void *) (uintptr_t) stream_id;\n    client->last_stream_id = stream_id;\n  } else {\n    LOG(LL_DEBUG, (\"Ignoring stream 0x%lx (last_stream_id 0x%lx)\", stream_id,\n                   client->last_stream_id));\n  }\n\n  return nc;\n}\n\n/* clang-format off */\n#define MG_TUN_IFACE_VTABLE                                             \\\n  {                                                                     \\\n    mg_tun_if_init,                                                     \\\n    mg_tun_if_free,                                                     \\\n    mg_tun_if_add_conn,                                                 \\\n    mg_tun_if_remove_conn,                                              \\\n    mg_tun_if_poll,                                                     \\\n    mg_tun_if_listen_tcp,                                               \\\n    mg_tun_if_listen_udp,                                               \\\n    mg_tun_if_connect_tcp,                                              \\\n    mg_tun_if_connect_udp,                                              \\\n    mg_tun_if_tcp_send,                                                 \\\n    mg_tun_if_udp_send,                                                 \\\n    mg_tun_if_recved,                                                   \\\n    mg_tun_if_create_conn,                                              \\\n    mg_tun_if_destroy_conn,                                             \\\n    mg_tun_if_sock_set,                                                 \\\n    mg_tun_if_get_conn_addr,                                            \\\n  }\n/* clang-format on */\n\nconst struct mg_iface_vtable mg_tun_iface_vtable = MG_TUN_IFACE_VTABLE;\n\n#endif /* MG_ENABLE_TUN */\n#ifdef MG_MODULE_LINES\n#line 1 \"mongoose/src/ssl_if_openssl.c\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#if MG_ENABLE_SSL && MG_SSL_IF == MG_SSL_IF_OPENSSL\n\n#ifdef __APPLE__\n#pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n#endif\n\n#include <openssl/ssl.h>\n\nstruct mg_ssl_if_ctx {\n  SSL *ssl;\n  SSL_CTX *ssl_ctx;\n  struct mbuf psk;\n  size_t identity_len;\n};\n\nvoid mg_ssl_if_init() {\n  SSL_library_init();\n}\n\nenum mg_ssl_if_result mg_ssl_if_conn_accept(struct mg_connection *nc,\n                                            struct mg_connection *lc) {\n  struct mg_ssl_if_ctx *ctx =\n      (struct mg_ssl_if_ctx *) MG_CALLOC(1, sizeof(*ctx));\n  struct mg_ssl_if_ctx *lc_ctx = (struct mg_ssl_if_ctx *) lc->ssl_if_data;\n  nc->ssl_if_data = ctx;\n  if (ctx == NULL || lc_ctx == NULL) return MG_SSL_ERROR;\n  ctx->ssl_ctx = lc_ctx->ssl_ctx;\n  if ((ctx->ssl = SSL_new(ctx->ssl_ctx)) == NULL) {\n    return MG_SSL_ERROR;\n  }\n  return MG_SSL_OK;\n}\n\nstatic enum mg_ssl_if_result mg_use_cert(SSL_CTX *ctx, const char *cert,\n                                         const char *key, const char **err_msg);\nstatic enum mg_ssl_if_result mg_use_ca_cert(SSL_CTX *ctx, const char *cert);\nstatic enum mg_ssl_if_result mg_set_cipher_list(SSL_CTX *ctx, const char *cl);\nstatic enum mg_ssl_if_result mg_ssl_if_ossl_set_psk(struct mg_ssl_if_ctx *ctx,\n                                                    const char *identity,\n                                                    const char *key_str);\n\nenum mg_ssl_if_result mg_ssl_if_conn_init(\n    struct mg_connection *nc, const struct mg_ssl_if_conn_params *params,\n    const char **err_msg) {\n  struct mg_ssl_if_ctx *ctx =\n      (struct mg_ssl_if_ctx *) MG_CALLOC(1, sizeof(*ctx));\n  DBG((\"%p %s,%s,%s\", nc, (params->cert ? params->cert : \"\"),\n       (params->key ? params->key : \"\"),\n       (params->ca_cert ? params->ca_cert : \"\")));\n  if (ctx == NULL) {\n    MG_SET_PTRPTR(err_msg, \"Out of memory\");\n    return MG_SSL_ERROR;\n  }\n  nc->ssl_if_data = ctx;\n  if (nc->flags & MG_F_LISTENING) {\n    ctx->ssl_ctx = SSL_CTX_new(SSLv23_server_method());\n  } else {\n    ctx->ssl_ctx = SSL_CTX_new(SSLv23_client_method());\n  }\n  if (ctx->ssl_ctx == NULL) {\n    MG_SET_PTRPTR(err_msg, \"Failed to create SSL context\");\n    return MG_SSL_ERROR;\n  }\n\n  if (params->cert != NULL &&\n      mg_use_cert(ctx->ssl_ctx, params->cert, params->key, err_msg) !=\n          MG_SSL_OK) {\n    return MG_SSL_ERROR;\n  }\n\n  if (params->ca_cert != NULL &&\n      mg_use_ca_cert(ctx->ssl_ctx, params->ca_cert) != MG_SSL_OK) {\n    MG_SET_PTRPTR(err_msg, \"Invalid SSL CA cert\");\n    return MG_SSL_ERROR;\n  }\n\n  if (params->server_name != NULL) {\n#ifdef KR_VERSION\n    SSL_CTX_kr_set_verify_name(ctx->ssl_ctx, params->server_name);\n#else\n/* TODO(rojer): Implement server name verification on OpenSSL. */\n#endif\n  }\n\n  if (mg_set_cipher_list(ctx->ssl_ctx, params->cipher_suites) != MG_SSL_OK) {\n    MG_SET_PTRPTR(err_msg, \"Invalid cipher suite list\");\n    return MG_SSL_ERROR;\n  }\n\n  mbuf_init(&ctx->psk, 0);\n  if (mg_ssl_if_ossl_set_psk(ctx, params->psk_identity, params->psk_key) !=\n      MG_SSL_OK) {\n    MG_SET_PTRPTR(err_msg, \"Invalid PSK settings\");\n    return MG_SSL_ERROR;\n  }\n\n  if (!(nc->flags & MG_F_LISTENING) &&\n      (ctx->ssl = SSL_new(ctx->ssl_ctx)) == NULL) {\n    MG_SET_PTRPTR(err_msg, \"Failed to create SSL session\");\n    return MG_SSL_ERROR;\n  }\n\n  nc->flags |= MG_F_SSL;\n\n  return MG_SSL_OK;\n}\n\nstatic enum mg_ssl_if_result mg_ssl_if_ssl_err(struct mg_connection *nc,\n                                               int res) {\n  struct mg_ssl_if_ctx *ctx = (struct mg_ssl_if_ctx *) nc->ssl_if_data;\n  int err = SSL_get_error(ctx->ssl, res);\n  if (err == SSL_ERROR_WANT_READ) return MG_SSL_WANT_READ;\n  if (err == SSL_ERROR_WANT_WRITE) return MG_SSL_WANT_WRITE;\n  DBG((\"%p %p SSL error: %d %d\", nc, ctx->ssl_ctx, res, err));\n  nc->err = err;\n  return MG_SSL_ERROR;\n}\n\nenum mg_ssl_if_result mg_ssl_if_handshake(struct mg_connection *nc) {\n  struct mg_ssl_if_ctx *ctx = (struct mg_ssl_if_ctx *) nc->ssl_if_data;\n  int server_side = (nc->listener != NULL);\n  int res;\n  /* If descriptor is not yet set, do it now. */\n  if (SSL_get_fd(ctx->ssl) < 0) {\n    if (SSL_set_fd(ctx->ssl, nc->sock) != 1) return MG_SSL_ERROR;\n  }\n  res = server_side ? SSL_accept(ctx->ssl) : SSL_connect(ctx->ssl);\n  if (res != 1) return mg_ssl_if_ssl_err(nc, res);\n  return MG_SSL_OK;\n}\n\nint mg_ssl_if_read(struct mg_connection *nc, void *buf, size_t buf_size) {\n  struct mg_ssl_if_ctx *ctx = (struct mg_ssl_if_ctx *) nc->ssl_if_data;\n  int n = SSL_read(ctx->ssl, buf, buf_size);\n  DBG((\"%p %d -> %d\", nc, (int) buf_size, n));\n  if (n < 0) return mg_ssl_if_ssl_err(nc, n);\n  if (n == 0) nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n  return n;\n}\n\nint mg_ssl_if_write(struct mg_connection *nc, const void *data, size_t len) {\n  struct mg_ssl_if_ctx *ctx = (struct mg_ssl_if_ctx *) nc->ssl_if_data;\n  int n = SSL_write(ctx->ssl, data, len);\n  DBG((\"%p %d -> %d\", nc, (int) len, n));\n  if (n <= 0) return mg_ssl_if_ssl_err(nc, n);\n  return n;\n}\n\nvoid mg_ssl_if_conn_close_notify(struct mg_connection *nc) {\n  struct mg_ssl_if_ctx *ctx = (struct mg_ssl_if_ctx *) nc->ssl_if_data;\n  if (ctx == NULL) return;\n  SSL_shutdown(ctx->ssl);\n}\n\nvoid mg_ssl_if_conn_free(struct mg_connection *nc) {\n  struct mg_ssl_if_ctx *ctx = (struct mg_ssl_if_ctx *) nc->ssl_if_data;\n  if (ctx == NULL) return;\n  nc->ssl_if_data = NULL;\n  if (ctx->ssl != NULL) SSL_free(ctx->ssl);\n  if (ctx->ssl_ctx != NULL && nc->listener == NULL) SSL_CTX_free(ctx->ssl_ctx);\n  mbuf_free(&ctx->psk);\n  memset(ctx, 0, sizeof(*ctx));\n  MG_FREE(ctx);\n}\n\n/*\n * Cipher suite options used for TLS negotiation.\n * https://wiki.mozilla.org/Security/Server_Side_TLS#Recommended_configurations\n */\nstatic const char mg_s_cipher_list[] =\n#if defined(MG_SSL_CRYPTO_MODERN)\n    \"ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:\"\n    \"ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:\"\n    \"DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:\"\n    \"ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:\"\n    \"ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:\"\n    \"ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:\"\n    \"DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:\"\n    \"DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:\"\n    \"!aNULL:!eNULL:!EXPORT:!DES:!RC4:!3DES:!MD5:!PSK\"\n#elif defined(MG_SSL_CRYPTO_OLD)\n    \"ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:\"\n    \"ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:\"\n    \"DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:\"\n    \"ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:\"\n    \"ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:\"\n    \"ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:\"\n    \"DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:\"\n    \"DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:ECDHE-RSA-DES-CBC3-SHA:\"\n    \"ECDHE-ECDSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:\"\n    \"AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:DES-CBC3-SHA:\"\n    \"HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:\"\n    \"!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA\"\n#else /* Default - intermediate. */\n    \"ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:\"\n    \"ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:\"\n    \"DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:\"\n    \"ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:\"\n    \"ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:\"\n    \"ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:\"\n    \"DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:\"\n    \"DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:\"\n    \"AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:CAMELLIA:\"\n    \"DES-CBC3-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:\"\n    \"!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA\"\n#endif\n    ;\n\n/*\n * Default DH params for PFS cipher negotiation. This is a 2048-bit group.\n * Will be used if none are provided by the user in the certificate file.\n */\n#if !MG_DISABLE_PFS && !defined(KR_VERSION)\nstatic const char mg_s_default_dh_params[] =\n    \"\\\n-----BEGIN DH PARAMETERS-----\\n\\\nMIIBCAKCAQEAlvbgD/qh9znWIlGFcV0zdltD7rq8FeShIqIhkQ0C7hYFThrBvF2E\\n\\\nZ9bmgaP+sfQwGpVlv9mtaWjvERbu6mEG7JTkgmVUJrUt/wiRzwTaCXBqZkdUO8Tq\\n\\\n+E6VOEQAilstG90ikN1Tfo+K6+X68XkRUIlgawBTKuvKVwBhuvlqTGerOtnXWnrt\\n\\\nym//hd3cd5PBYGBix0i7oR4xdghvfR2WLVu0LgdThTBb6XP7gLd19cQ1JuBtAajZ\\n\\\nwMuPn7qlUkEFDIkAZy59/Hue/H2Q2vU/JsvVhHWCQBL4F1ofEAt50il6ZxR1QfFK\\n\\\n9VGKDC4oOgm9DlxwwBoC2FjqmvQlqVV3kwIBAg==\\n\\\n-----END DH PARAMETERS-----\\n\";\n#endif\n\nstatic enum mg_ssl_if_result mg_use_ca_cert(SSL_CTX *ctx, const char *cert) {\n  if (cert == NULL || strcmp(cert, \"*\") == 0) {\n    return MG_SSL_OK;\n  }\n  SSL_CTX_set_verify(ctx, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT, 0);\n  return SSL_CTX_load_verify_locations(ctx, cert, NULL) == 1 ? MG_SSL_OK\n                                                             : MG_SSL_ERROR;\n}\n\nstatic enum mg_ssl_if_result mg_use_cert(SSL_CTX *ctx, const char *cert,\n                                         const char *key,\n                                         const char **err_msg) {\n  if (key == NULL) key = cert;\n  if (cert == NULL || cert[0] == '\\0' || key == NULL || key[0] == '\\0') {\n    return MG_SSL_OK;\n  } else if (SSL_CTX_use_certificate_file(ctx, cert, 1) == 0) {\n    MG_SET_PTRPTR(err_msg, \"Invalid SSL cert\");\n    return MG_SSL_ERROR;\n  } else if (SSL_CTX_use_PrivateKey_file(ctx, key, 1) == 0) {\n    MG_SET_PTRPTR(err_msg, \"Invalid SSL key\");\n    return MG_SSL_ERROR;\n  } else if (SSL_CTX_use_certificate_chain_file(ctx, cert) == 0) {\n    MG_SET_PTRPTR(err_msg, \"Invalid CA bundle\");\n    return MG_SSL_ERROR;\n  } else {\n    SSL_CTX_set_mode(ctx, SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER);\n#if !MG_DISABLE_PFS && !defined(KR_VERSION)\n    BIO *bio = NULL;\n    DH *dh = NULL;\n\n    /* Try to read DH parameters from the cert/key file. */\n    bio = BIO_new_file(cert, \"r\");\n    if (bio != NULL) {\n      dh = PEM_read_bio_DHparams(bio, NULL, NULL, NULL);\n      BIO_free(bio);\n    }\n    /*\n     * If there are no DH params in the file, fall back to hard-coded ones.\n     * Not ideal, but better than nothing.\n     */\n    if (dh == NULL) {\n      bio = BIO_new_mem_buf((void *) mg_s_default_dh_params, -1);\n      dh = PEM_read_bio_DHparams(bio, NULL, NULL, NULL);\n      BIO_free(bio);\n    }\n    if (dh != NULL) {\n      SSL_CTX_set_tmp_dh(ctx, dh);\n      SSL_CTX_set_options(ctx, SSL_OP_SINGLE_DH_USE);\n      DH_free(dh);\n    }\n#if OPENSSL_VERSION_NUMBER > 0x10002000L\n    SSL_CTX_set_ecdh_auto(ctx, 1);\n#endif\n#endif\n  }\n  return MG_SSL_OK;\n}\n\nstatic enum mg_ssl_if_result mg_set_cipher_list(SSL_CTX *ctx, const char *cl) {\n  return (SSL_CTX_set_cipher_list(ctx, cl ? cl : mg_s_cipher_list) == 1\n              ? MG_SSL_OK\n              : MG_SSL_ERROR);\n}\n\n#ifndef KR_VERSION\nstatic unsigned int mg_ssl_if_ossl_psk_cb(SSL *ssl, const char *hint,\n                                          char *identity,\n                                          unsigned int max_identity_len,\n                                          unsigned char *psk,\n                                          unsigned int max_psk_len) {\n  struct mg_ssl_if_ctx *ctx =\n      (struct mg_ssl_if_ctx *) ssl->ctx->msg_callback_arg;\n  size_t key_len = ctx->psk.len - ctx->identity_len - 1;\n  DBG((\"hint: '%s'\", (hint ? hint : \"\")));\n  if (ctx->identity_len + 1 > max_identity_len) {\n    DBG((\"identity too long\"));\n    return 0;\n  }\n  if (key_len > max_psk_len) {\n    DBG((\"key too long\"));\n    return 0;\n  }\n  memcpy(identity, ctx->psk.buf, ctx->identity_len + 1);\n  memcpy(psk, ctx->psk.buf + ctx->identity_len + 1, key_len);\n  (void) ssl;\n  return key_len;\n}\n\nstatic enum mg_ssl_if_result mg_ssl_if_ossl_set_psk(struct mg_ssl_if_ctx *ctx,\n                                                    const char *identity,\n                                                    const char *key_str) {\n  unsigned char key[32];\n  size_t key_len;\n  size_t i = 0;\n  if (identity == NULL && key_str == NULL) return MG_SSL_OK;\n  if (identity == NULL || key_str == NULL) return MG_SSL_ERROR;\n  key_len = strlen(key_str);\n  if (key_len != 32 && key_len != 64) return MG_SSL_ERROR;\n  memset(key, 0, sizeof(key));\n  key_len = 0;\n  for (i = 0; key_str[i] != '\\0'; i++) {\n    unsigned char c;\n    char hc = tolower((int) key_str[i]);\n    if (hc >= '0' && hc <= '9') {\n      c = hc - '0';\n    } else if (hc >= 'a' && hc <= 'f') {\n      c = hc - 'a' + 0xa;\n    } else {\n      return MG_SSL_ERROR;\n    }\n    key_len = i / 2;\n    key[key_len] <<= 4;\n    key[key_len] |= c;\n  }\n  key_len++;\n  DBG((\"identity = '%s', key = (%u)\", identity, (unsigned int) key_len));\n  ctx->identity_len = strlen(identity);\n  mbuf_append(&ctx->psk, identity, ctx->identity_len + 1);\n  mbuf_append(&ctx->psk, key, key_len);\n  SSL_CTX_set_psk_client_callback(ctx->ssl_ctx, mg_ssl_if_ossl_psk_cb);\n  /* Hack: there is no field for us to keep this, so we use msg_callback_arg */\n  ctx->ssl_ctx->msg_callback_arg = ctx;\n  return MG_SSL_OK;\n}\n#else\nstatic enum mg_ssl_if_result mg_ssl_if_ossl_set_psk(struct mg_ssl_if_ctx *ctx,\n                                                    const char *identity,\n                                                    const char *key_str) {\n  (void) ctx;\n  (void) identity;\n  (void) key_str;\n  /* Krypton does not support PSK. */\n  return MG_SSL_ERROR;\n}\n#endif /* defined(KR_VERSION) */\n\nconst char *mg_set_ssl(struct mg_connection *nc, const char *cert,\n                       const char *ca_cert) {\n  const char *err_msg = NULL;\n  struct mg_ssl_if_conn_params params;\n  memset(&params, 0, sizeof(params));\n  params.cert = cert;\n  params.ca_cert = ca_cert;\n  if (mg_ssl_if_conn_init(nc, &params, &err_msg) != MG_SSL_OK) {\n    return err_msg;\n  }\n  return NULL;\n}\n\n#endif /* MG_ENABLE_SSL && MG_SSL_IF == MG_SSL_IF_OPENSSL */\n#ifdef MG_MODULE_LINES\n#line 1 \"mongoose/src/ssl_if_mbedtls.c\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#if MG_ENABLE_SSL && MG_SSL_IF == MG_SSL_IF_MBEDTLS\n\n#include <mbedtls/debug.h>\n#include <mbedtls/ecp.h>\n#include <mbedtls/platform.h>\n#include <mbedtls/ssl.h>\n#include <mbedtls/x509_crt.h>\n\nstatic void mg_ssl_mbed_log(void *ctx, int level, const char *file, int line,\n                            const char *str) {\n  enum cs_log_level cs_level;\n  switch (level) {\n    case 1:\n      cs_level = LL_ERROR;\n      break;\n    case 2:\n    case 3:\n      cs_level = LL_DEBUG;\n      break;\n    default:\n      cs_level = LL_VERBOSE_DEBUG;\n  }\n  /* mbedTLS passes strings with \\n at the end, strip it. */\n  LOG(cs_level, (\"%p %.*s\", ctx, (int) (strlen(str) - 1), str));\n  (void) file;\n  (void) line;\n}\n\nstruct mg_ssl_if_ctx {\n  mbedtls_ssl_config *conf;\n  mbedtls_ssl_context *ssl;\n  mbedtls_x509_crt *cert;\n  mbedtls_pk_context *key;\n  mbedtls_x509_crt *ca_cert;\n  struct mbuf cipher_suites;\n};\n\n/* Must be provided by the platform. ctx is struct mg_connection. */\nextern int mg_ssl_if_mbed_random(void *ctx, unsigned char *buf, size_t len);\n\nvoid mg_ssl_if_init() {\n}\n\nenum mg_ssl_if_result mg_ssl_if_conn_accept(struct mg_connection *nc,\n                                            struct mg_connection *lc) {\n  struct mg_ssl_if_ctx *ctx =\n      (struct mg_ssl_if_ctx *) MG_CALLOC(1, sizeof(*ctx));\n  struct mg_ssl_if_ctx *lc_ctx = (struct mg_ssl_if_ctx *) lc->ssl_if_data;\n  nc->ssl_if_data = ctx;\n  if (ctx == NULL || lc_ctx == NULL) return MG_SSL_ERROR;\n  ctx->ssl = (mbedtls_ssl_context *) MG_CALLOC(1, sizeof(*ctx->ssl));\n  if (mbedtls_ssl_setup(ctx->ssl, lc_ctx->conf) != 0) {\n    return MG_SSL_ERROR;\n  }\n  return MG_SSL_OK;\n}\n\nstatic enum mg_ssl_if_result mg_use_cert(struct mg_ssl_if_ctx *ctx,\n                                         const char *cert, const char *key,\n                                         const char **err_msg);\nstatic enum mg_ssl_if_result mg_use_ca_cert(struct mg_ssl_if_ctx *ctx,\n                                            const char *cert);\nstatic enum mg_ssl_if_result mg_set_cipher_list(struct mg_ssl_if_ctx *ctx,\n                                                const char *ciphers);\nstatic enum mg_ssl_if_result mg_ssl_if_mbed_set_psk(struct mg_ssl_if_ctx *ctx,\n                                                    const char *identity,\n                                                    const char *key);\n\nenum mg_ssl_if_result mg_ssl_if_conn_init(\n    struct mg_connection *nc, const struct mg_ssl_if_conn_params *params,\n    const char **err_msg) {\n  struct mg_ssl_if_ctx *ctx =\n      (struct mg_ssl_if_ctx *) MG_CALLOC(1, sizeof(*ctx));\n  DBG((\"%p %s,%s,%s\", nc, (params->cert ? params->cert : \"\"),\n       (params->key ? params->key : \"\"),\n       (params->ca_cert ? params->ca_cert : \"\")));\n\n  if (ctx == NULL) {\n    MG_SET_PTRPTR(err_msg, \"Out of memory\");\n    return MG_SSL_ERROR;\n  }\n  nc->ssl_if_data = ctx;\n  ctx->conf = (mbedtls_ssl_config *) MG_CALLOC(1, sizeof(*ctx->conf));\n  mbuf_init(&ctx->cipher_suites, 0);\n  mbedtls_ssl_config_init(ctx->conf);\n  mbedtls_ssl_conf_dbg(ctx->conf, mg_ssl_mbed_log, nc);\n  if (mbedtls_ssl_config_defaults(\n          ctx->conf, (nc->flags & MG_F_LISTENING ? MBEDTLS_SSL_IS_SERVER\n                                                 : MBEDTLS_SSL_IS_CLIENT),\n          MBEDTLS_SSL_TRANSPORT_STREAM, MBEDTLS_SSL_PRESET_DEFAULT) != 0) {\n    MG_SET_PTRPTR(err_msg, \"Failed to init SSL config\");\n    return MG_SSL_ERROR;\n  }\n\n  /* TLS 1.2 and up */\n  mbedtls_ssl_conf_min_version(ctx->conf, MBEDTLS_SSL_MAJOR_VERSION_3,\n                               MBEDTLS_SSL_MINOR_VERSION_3);\n  mbedtls_ssl_conf_rng(ctx->conf, mg_ssl_if_mbed_random, nc);\n\n  if (params->cert != NULL &&\n      mg_use_cert(ctx, params->cert, params->key, err_msg) != MG_SSL_OK) {\n    return MG_SSL_ERROR;\n  }\n\n  if (params->ca_cert != NULL &&\n      mg_use_ca_cert(ctx, params->ca_cert) != MG_SSL_OK) {\n    MG_SET_PTRPTR(err_msg, \"Invalid SSL CA cert\");\n    return MG_SSL_ERROR;\n  }\n\n  if (mg_set_cipher_list(ctx, params->cipher_suites) != MG_SSL_OK) {\n    MG_SET_PTRPTR(err_msg, \"Invalid cipher suite list\");\n    return MG_SSL_ERROR;\n  }\n\n  if (mg_ssl_if_mbed_set_psk(ctx, params->psk_identity, params->psk_key) !=\n      MG_SSL_OK) {\n    MG_SET_PTRPTR(err_msg, \"Invalid PSK settings\");\n    return MG_SSL_ERROR;\n  }\n\n  if (!(nc->flags & MG_F_LISTENING)) {\n    ctx->ssl = (mbedtls_ssl_context *) MG_CALLOC(1, sizeof(*ctx->ssl));\n    mbedtls_ssl_init(ctx->ssl);\n    if (mbedtls_ssl_setup(ctx->ssl, ctx->conf) != 0) {\n      MG_SET_PTRPTR(err_msg, \"Failed to create SSL session\");\n      return MG_SSL_ERROR;\n    }\n    if (params->server_name != NULL &&\n        mbedtls_ssl_set_hostname(ctx->ssl, params->server_name) != 0) {\n      return MG_SSL_ERROR;\n    }\n  }\n\n#ifdef MG_SSL_IF_MBEDTLS_MAX_FRAG_LEN\n  if (mbedtls_ssl_conf_max_frag_len(ctx->conf,\n#if MG_SSL_IF_MBEDTLS_MAX_FRAG_LEN == 512\n                                    MBEDTLS_SSL_MAX_FRAG_LEN_512\n#elif MG_SSL_IF_MBEDTLS_MAX_FRAG_LEN == 1024\n                                    MBEDTLS_SSL_MAX_FRAG_LEN_1024\n#elif MG_SSL_IF_MBEDTLS_MAX_FRAG_LEN == 2048\n                                    MBEDTLS_SSL_MAX_FRAG_LEN_2048\n#elif MG_SSL_IF_MBEDTLS_MAX_FRAG_LEN == 4096\n                                    MBEDTLS_SSL_MAX_FRAG_LEN_4096\n#else\n#error Invalid MG_SSL_IF_MBEDTLS_MAX_FRAG_LEN\n#endif\n                                    ) != 0) {\n    return MG_SSL_ERROR;\n  }\n#endif\n\n  nc->flags |= MG_F_SSL;\n\n  return MG_SSL_OK;\n}\n\n#if MG_NET_IF == MG_NET_IF_LWIP_LOW_LEVEL\nint ssl_socket_send(void *ctx, const unsigned char *buf, size_t len);\nint ssl_socket_recv(void *ctx, unsigned char *buf, size_t len);\n#else\nstatic int ssl_socket_send(void *ctx, const unsigned char *buf, size_t len) {\n  struct mg_connection *nc = (struct mg_connection *) ctx;\n  int n = (int) MG_SEND_FUNC(nc->sock, buf, len, 0);\n  LOG(LL_DEBUG, (\"%p %d -> %d\", nc, (int) len, n));\n  if (n >= 0) return n;\n  n = mg_get_errno();\n  return ((n == EAGAIN || n == EINPROGRESS) ? MBEDTLS_ERR_SSL_WANT_WRITE : -1);\n}\n\nstatic int ssl_socket_recv(void *ctx, unsigned char *buf, size_t len) {\n  struct mg_connection *nc = (struct mg_connection *) ctx;\n  int n = (int) MG_RECV_FUNC(nc->sock, buf, len, 0);\n  LOG(LL_DEBUG, (\"%p %d <- %d\", nc, (int) len, n));\n  if (n >= 0) return n;\n  n = mg_get_errno();\n  return ((n == EAGAIN || n == EINPROGRESS) ? MBEDTLS_ERR_SSL_WANT_READ : -1);\n}\n#endif\n\nstatic enum mg_ssl_if_result mg_ssl_if_mbed_err(struct mg_connection *nc,\n                                                int ret) {\n  if (ret == MBEDTLS_ERR_SSL_WANT_READ) return MG_SSL_WANT_READ;\n  if (ret == MBEDTLS_ERR_SSL_WANT_WRITE) return MG_SSL_WANT_WRITE;\n  if (ret !=\n      MBEDTLS_ERR_SSL_PEER_CLOSE_NOTIFY) { /* CLOSE_NOTIFY = Normal shutdown */\n    LOG(LL_ERROR, (\"%p SSL error: %d\", nc, ret));\n  }\n  nc->err = ret;\n  nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n  return MG_SSL_ERROR;\n}\n\nstatic void mg_ssl_if_mbed_free_certs_and_keys(struct mg_ssl_if_ctx *ctx) {\n  if (ctx->cert != NULL) {\n    mbedtls_x509_crt_free(ctx->cert);\n    MG_FREE(ctx->cert);\n    ctx->cert = NULL;\n    mbedtls_pk_free(ctx->key);\n    MG_FREE(ctx->key);\n    ctx->key = NULL;\n  }\n  if (ctx->ca_cert != NULL) {\n    mbedtls_ssl_conf_ca_chain(ctx->conf, NULL, NULL);\n    mbedtls_x509_crt_free(ctx->ca_cert);\n    MG_FREE(ctx->ca_cert);\n    ctx->ca_cert = NULL;\n  }\n}\n\nenum mg_ssl_if_result mg_ssl_if_handshake(struct mg_connection *nc) {\n  struct mg_ssl_if_ctx *ctx = (struct mg_ssl_if_ctx *) nc->ssl_if_data;\n  int err;\n  /* If bio is not yet set, do it now. */\n  if (ctx->ssl->p_bio == NULL) {\n    mbedtls_ssl_set_bio(ctx->ssl, nc, ssl_socket_send, ssl_socket_recv, NULL);\n  }\n  err = mbedtls_ssl_handshake(ctx->ssl);\n  if (err != 0) return mg_ssl_if_mbed_err(nc, err);\n#ifdef MG_SSL_IF_MBEDTLS_FREE_CERTS\n  /*\n   * Free the peer certificate, we don't need it after handshake.\n   * Note that this effectively disables renegotiation.\n   */\n  mbedtls_x509_crt_free(ctx->ssl->session->peer_cert);\n  mbedtls_free(ctx->ssl->session->peer_cert);\n  ctx->ssl->session->peer_cert = NULL;\n  /* On a client connection we can also free our own and CA certs. */\n  if (nc->listener == NULL) {\n    if (ctx->conf->key_cert != NULL) {\n      /* Note that this assumes one key_cert entry, which matches our init. */\n      MG_FREE(ctx->conf->key_cert);\n      ctx->conf->key_cert = NULL;\n    }\n    mbedtls_ssl_conf_ca_chain(ctx->conf, NULL, NULL);\n    mg_ssl_if_mbed_free_certs_and_keys(ctx);\n  }\n#endif\n  return MG_SSL_OK;\n}\n\nint mg_ssl_if_read(struct mg_connection *nc, void *buf, size_t buf_size) {\n  struct mg_ssl_if_ctx *ctx = (struct mg_ssl_if_ctx *) nc->ssl_if_data;\n  int n = mbedtls_ssl_read(ctx->ssl, (unsigned char *) buf, buf_size);\n  DBG((\"%p %d -> %d\", nc, (int) buf_size, n));\n  if (n < 0) return mg_ssl_if_mbed_err(nc, n);\n  if (n == 0) nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n  return n;\n}\n\nint mg_ssl_if_write(struct mg_connection *nc, const void *data, size_t len) {\n  struct mg_ssl_if_ctx *ctx = (struct mg_ssl_if_ctx *) nc->ssl_if_data;\n  int n = mbedtls_ssl_write(ctx->ssl, (const unsigned char *) data, len);\n  DBG((\"%p %d -> %d\", nc, (int) len, n));\n  if (n < 0) return mg_ssl_if_mbed_err(nc, n);\n  return n;\n}\n\nvoid mg_ssl_if_conn_close_notify(struct mg_connection *nc) {\n  struct mg_ssl_if_ctx *ctx = (struct mg_ssl_if_ctx *) nc->ssl_if_data;\n  if (ctx == NULL) return;\n  mbedtls_ssl_close_notify(ctx->ssl);\n}\n\nvoid mg_ssl_if_conn_free(struct mg_connection *nc) {\n  struct mg_ssl_if_ctx *ctx = (struct mg_ssl_if_ctx *) nc->ssl_if_data;\n  if (ctx == NULL) return;\n  nc->ssl_if_data = NULL;\n  if (ctx->ssl != NULL) {\n    mbedtls_ssl_free(ctx->ssl);\n    MG_FREE(ctx->ssl);\n  }\n  mg_ssl_if_mbed_free_certs_and_keys(ctx);\n  if (ctx->conf != NULL) {\n    mbedtls_ssl_config_free(ctx->conf);\n    MG_FREE(ctx->conf);\n  }\n  mbuf_free(&ctx->cipher_suites);\n  memset(ctx, 0, sizeof(*ctx));\n  MG_FREE(ctx);\n}\n\nstatic enum mg_ssl_if_result mg_use_ca_cert(struct mg_ssl_if_ctx *ctx,\n                                            const char *ca_cert) {\n  if (ca_cert == NULL || strcmp(ca_cert, \"*\") == 0) {\n    return MG_SSL_OK;\n  }\n  ctx->ca_cert = (mbedtls_x509_crt *) MG_CALLOC(1, sizeof(*ctx->ca_cert));\n  mbedtls_x509_crt_init(ctx->ca_cert);\n  if (mbedtls_x509_crt_parse_file(ctx->ca_cert, ca_cert) != 0) {\n    return MG_SSL_ERROR;\n  }\n  mbedtls_ssl_conf_ca_chain(ctx->conf, ctx->ca_cert, NULL);\n  mbedtls_ssl_conf_authmode(ctx->conf, MBEDTLS_SSL_VERIFY_REQUIRED);\n  return MG_SSL_OK;\n}\n\nstatic enum mg_ssl_if_result mg_use_cert(struct mg_ssl_if_ctx *ctx,\n                                         const char *cert, const char *key,\n                                         const char **err_msg) {\n  if (key == NULL) key = cert;\n  if (cert == NULL || cert[0] == '\\0' || key == NULL || key[0] == '\\0') {\n    return MG_SSL_OK;\n  }\n  ctx->cert = (mbedtls_x509_crt *) MG_CALLOC(1, sizeof(*ctx->cert));\n  mbedtls_x509_crt_init(ctx->cert);\n  ctx->key = (mbedtls_pk_context *) MG_CALLOC(1, sizeof(*ctx->key));\n  mbedtls_pk_init(ctx->key);\n  if (mbedtls_x509_crt_parse_file(ctx->cert, cert) != 0) {\n    MG_SET_PTRPTR(err_msg, \"Invalid SSL cert\");\n    return MG_SSL_ERROR;\n  }\n  if (mbedtls_pk_parse_keyfile(ctx->key, key, NULL) != 0) {\n    MG_SET_PTRPTR(err_msg, \"Invalid SSL key\");\n    return MG_SSL_ERROR;\n  }\n  if (mbedtls_ssl_conf_own_cert(ctx->conf, ctx->cert, ctx->key) != 0) {\n    MG_SET_PTRPTR(err_msg, \"Invalid SSL key or cert\");\n    return MG_SSL_ERROR;\n  }\n  return MG_SSL_OK;\n}\n\nstatic const int mg_s_cipher_list[] = {\n    MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,\n    MBEDTLS_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,\n    MBEDTLS_TLS_DHE_RSA_WITH_AES_128_GCM_SHA256,\n    MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256,\n    MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256,\n    MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256,\n    MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA,\n    MBEDTLS_TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256,\n    MBEDTLS_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256,\n    MBEDTLS_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA,\n    MBEDTLS_TLS_RSA_WITH_AES_128_GCM_SHA256,\n    MBEDTLS_TLS_RSA_WITH_AES_128_CBC_SHA256,\n    MBEDTLS_TLS_RSA_WITH_AES_128_CBC_SHA, 0};\n\n/*\n * Ciphers can be specified as a colon-separated list of cipher suite names.\n * These can be found in\n * https://github.com/ARMmbed/mbedtls/blob/development/library/ssl_ciphersuites.c#L267\n * E.g.: TLS-ECDHE-ECDSA-WITH-AES-128-GCM-SHA256:TLS-DHE-RSA-WITH-AES-256-CCM\n */\nstatic enum mg_ssl_if_result mg_set_cipher_list(struct mg_ssl_if_ctx *ctx,\n                                                const char *ciphers) {\n  if (ciphers != NULL) {\n    int l, id;\n    const char *s = ciphers, *e;\n    char tmp[50];\n    while (s != NULL) {\n      e = strchr(s, ':');\n      l = (e != NULL ? (e - s) : (int) strlen(s));\n      strncpy(tmp, s, l);\n      tmp[l] = '\\0';\n      id = mbedtls_ssl_get_ciphersuite_id(tmp);\n      DBG((\"%s -> %04x\", tmp, id));\n      if (id != 0) {\n        mbuf_append(&ctx->cipher_suites, &id, sizeof(id));\n      }\n      s = (e != NULL ? e + 1 : NULL);\n    }\n    if (ctx->cipher_suites.len == 0) return MG_SSL_ERROR;\n    id = 0;\n    mbuf_append(&ctx->cipher_suites, &id, sizeof(id));\n    mbuf_trim(&ctx->cipher_suites);\n    mbedtls_ssl_conf_ciphersuites(ctx->conf,\n                                  (const int *) ctx->cipher_suites.buf);\n  } else {\n    mbedtls_ssl_conf_ciphersuites(ctx->conf, mg_s_cipher_list);\n  }\n  return MG_SSL_OK;\n}\n\nstatic enum mg_ssl_if_result mg_ssl_if_mbed_set_psk(struct mg_ssl_if_ctx *ctx,\n                                                    const char *identity,\n                                                    const char *key_str) {\n  unsigned char key[32];\n  size_t key_len;\n  if (identity == NULL && key_str == NULL) return MG_SSL_OK;\n  if (identity == NULL || key_str == NULL) return MG_SSL_ERROR;\n  key_len = strlen(key_str);\n  if (key_len != 32 && key_len != 64) return MG_SSL_ERROR;\n  size_t i = 0;\n  memset(key, 0, sizeof(key));\n  key_len = 0;\n  for (i = 0; key_str[i] != '\\0'; i++) {\n    unsigned char c;\n    char hc = tolower((int) key_str[i]);\n    if (hc >= '0' && hc <= '9') {\n      c = hc - '0';\n    } else if (hc >= 'a' && hc <= 'f') {\n      c = hc - 'a' + 0xa;\n    } else {\n      return MG_SSL_ERROR;\n    }\n    key_len = i / 2;\n    key[key_len] <<= 4;\n    key[key_len] |= c;\n  }\n  key_len++;\n  DBG((\"identity = '%s', key = (%u)\", identity, (unsigned int) key_len));\n  /* mbedTLS makes copies of psk and identity. */\n  if (mbedtls_ssl_conf_psk(ctx->conf, (const unsigned char *) key, key_len,\n                           (const unsigned char *) identity,\n                           strlen(identity)) != 0) {\n    return MG_SSL_ERROR;\n  }\n  return MG_SSL_OK;\n}\n\nconst char *mg_set_ssl(struct mg_connection *nc, const char *cert,\n                       const char *ca_cert) {\n  const char *err_msg = NULL;\n  struct mg_ssl_if_conn_params params;\n  memset(&params, 0, sizeof(params));\n  params.cert = cert;\n  params.ca_cert = ca_cert;\n  if (mg_ssl_if_conn_init(nc, &params, &err_msg) != MG_SSL_OK) {\n    return err_msg;\n  }\n  return NULL;\n}\n\n/* Lazy RNG. Warning: it would be a bad idea to do this in production! */\n#ifdef MG_SSL_MBED_DUMMY_RANDOM\nint mg_ssl_if_mbed_random(void *ctx, unsigned char *buf, size_t len) {\n  (void) ctx;\n  while (len--) *buf++ = rand();\n  return 0;\n}\n#endif\n\n#endif /* MG_ENABLE_SSL && MG_SSL_IF == MG_SSL_IF_MBEDTLS */\n#ifdef MG_MODULE_LINES\n#line 1 \"mongoose/src/uri.c\"\n#endif\n/*\n * Copyright (c) 2014 Cesanta Software Limited\n * All rights reserved\n */\n\n/* Amalgamated: #include \"mongoose/src/internal.h\" */\n/* Amalgamated: #include \"mongoose/src/uri.h\" */\n\n/*\n * scan string until `sep`, keeping track of component boundaries in `res`.\n *\n * `p` will point to the char after the separator or it will be `end`.\n */\nstatic void parse_uri_component(const char **p, const char *end, char sep,\n                                struct mg_str *res) {\n  res->p = *p;\n  for (; *p < end; (*p)++) {\n    if (**p == sep) {\n      break;\n    }\n  }\n  res->len = (*p) - res->p;\n  if (*p < end) (*p)++;\n}\n\nint mg_parse_uri(struct mg_str uri, struct mg_str *scheme,\n                 struct mg_str *user_info, struct mg_str *host,\n                 unsigned int *port, struct mg_str *path, struct mg_str *query,\n                 struct mg_str *fragment) {\n  struct mg_str rscheme = {0, 0}, ruser_info = {0, 0}, rhost = {0, 0},\n                rpath = {0, 0}, rquery = {0, 0}, rfragment = {0, 0};\n  unsigned int rport = 0;\n  enum {\n    P_START,\n    P_SCHEME_OR_PORT,\n    P_USER_INFO,\n    P_HOST,\n    P_PORT,\n    P_REST\n  } state = P_START;\n\n  const char *p = uri.p, *end = p + uri.len;\n  while (p < end) {\n    switch (state) {\n      case P_START:\n        /*\n         * expecting on of:\n         * - `scheme://xxxx`\n         * - `xxxx:port`\n         * - `xxxx/path`\n         */\n        for (; p < end; p++) {\n          if (*p == ':') {\n            state = P_SCHEME_OR_PORT;\n            break;\n          } else if (*p == '/') {\n            state = P_REST;\n            break;\n          }\n        }\n        if (state == P_START || state == P_REST) {\n          rhost.p = uri.p;\n          rhost.len = p - uri.p;\n        }\n        break;\n      case P_SCHEME_OR_PORT:\n        if (end - p >= 3 && strncmp(p, \"://\", 3) == 0) {\n          rscheme.p = uri.p;\n          rscheme.len = p - uri.p;\n          state = P_USER_INFO;\n          p += 2; /* point to last separator char */\n        } else {\n          rhost.p = uri.p;\n          rhost.len = p - uri.p;\n          state = P_PORT;\n        }\n        break;\n      case P_USER_INFO:\n        p++;\n        ruser_info.p = p;\n        for (; p < end; p++) {\n          if (*p == '@') {\n            state = P_HOST;\n            break;\n          } else if (*p == '/') {\n            break;\n          }\n        }\n        if (p == end || *p == '/') {\n          /* backtrack and parse as host */\n          state = P_HOST;\n          p = ruser_info.p;\n        }\n        ruser_info.len = p - ruser_info.p;\n        break;\n      case P_HOST:\n        if (*p == '@') p++;\n        rhost.p = p;\n        for (; p < end; p++) {\n          if (*p == ':') {\n            state = P_PORT;\n            break;\n          } else if (*p == '/') {\n            state = P_REST;\n            break;\n          }\n        }\n        rhost.len = p - rhost.p;\n        break;\n      case P_PORT:\n        p++;\n        for (; p < end; p++) {\n          if (*p == '/') {\n            state = P_REST;\n            break;\n          }\n          rport *= 10;\n          rport += *p - '0';\n        }\n        break;\n      case P_REST:\n        /* `p` points to separator. `path` includes the separator */\n        parse_uri_component(&p, end, '?', &rpath);\n        parse_uri_component(&p, end, '#', &rquery);\n        parse_uri_component(&p, end, '\\0', &rfragment);\n        break;\n    }\n  }\n\n  if (scheme != 0) *scheme = rscheme;\n  if (user_info != 0) *user_info = ruser_info;\n  if (host != 0) *host = rhost;\n  if (port != 0) *port = rport;\n  if (path != 0) *path = rpath;\n  if (query != 0) *query = rquery;\n  if (fragment != 0) *fragment = rfragment;\n\n  return 0;\n}\n\n/* Normalize the URI path. Remove/resolve \".\" and \"..\". */\nint mg_normalize_uri_path(const struct mg_str *in, struct mg_str *out) {\n  const char *s = in->p, *se = s + in->len;\n  char *cp = (char *) out->p, *d;\n\n  if (in->len == 0 || *s != '/') {\n    out->len = 0;\n    return 0;\n  }\n\n  d = cp;\n\n  while (s < se) {\n    const char *next = s;\n    struct mg_str component;\n    parse_uri_component(&next, se, '/', &component);\n    if (mg_vcmp(&component, \".\") == 0) {\n      /* Yum. */\n    } else if (mg_vcmp(&component, \"..\") == 0) {\n      /* Backtrack to previous slash. */\n      if (d > cp + 1 && *(d - 1) == '/') d--;\n      while (d > cp && *(d - 1) != '/') d--;\n    } else {\n      memmove(d, s, next - s);\n      d += next - s;\n    }\n    s = next;\n  }\n  if (d == cp) *d++ = '/';\n\n  out->p = cp;\n  out->len = d - cp;\n  return 1;\n}\n#ifdef MG_MODULE_LINES\n#line 1 \"mongoose/src/http.c\"\n#endif\n/*\n * Copyright (c) 2014 Cesanta Software Limited\n * All rights reserved\n */\n\n#if MG_ENABLE_HTTP\n\n/* Amalgamated: #include \"common/md5.h\" */\n/* Amalgamated: #include \"common/sha1.h\" */\n/* Amalgamated: #include \"mongoose/src/internal.h\" */\n/* Amalgamated: #include \"mongoose/src/util.h\" */\n\nstatic const char *mg_version_header = \"Mongoose/\" MG_VERSION;\n\nenum mg_http_proto_data_type { DATA_NONE, DATA_FILE, DATA_PUT };\n\nstruct mg_http_proto_data_file {\n  FILE *fp;      /* Opened file. */\n  int64_t cl;    /* Content-Length. How many bytes to send. */\n  int64_t sent;  /* How many bytes have been already sent. */\n  int keepalive; /* Keep connection open after sending. */\n  enum mg_http_proto_data_type type;\n};\n\n#if MG_ENABLE_HTTP_CGI\nstruct mg_http_proto_data_cgi {\n  struct mg_connection *cgi_nc;\n};\n#endif\n\nstruct mg_http_proto_data_chuncked {\n  int64_t body_len; /* How many bytes of chunked body was reassembled. */\n};\n\nstruct mg_http_endpoint {\n  struct mg_http_endpoint *next;\n  const char *name;\n  size_t name_len;\n  mg_event_handler_t handler;\n#if MG_ENABLE_CALLBACK_USERDATA\n  void *user_data;\n#endif\n};\n\nenum mg_http_multipart_stream_state {\n  MPS_BEGIN,\n  MPS_WAITING_FOR_BOUNDARY,\n  MPS_WAITING_FOR_CHUNK,\n  MPS_GOT_CHUNK,\n  MPS_GOT_BOUNDARY,\n  MPS_FINALIZE,\n  MPS_FINISHED\n};\n\nstruct mg_http_multipart_stream {\n  const char *boundary;\n  int boundary_len;\n  const char *var_name;\n  const char *file_name;\n  void *user_data;\n  int prev_io_len;\n  enum mg_http_multipart_stream_state state;\n  int processing_part;\n};\n\nstruct mg_reverse_proxy_data {\n  struct mg_connection *linked_conn;\n};\n\nstruct mg_http_proto_data {\n#if MG_ENABLE_FILESYSTEM\n  struct mg_http_proto_data_file file;\n#endif\n#if MG_ENABLE_HTTP_CGI\n  struct mg_http_proto_data_cgi cgi;\n#endif\n#if MG_ENABLE_HTTP_STREAMING_MULTIPART\n  struct mg_http_multipart_stream mp_stream;\n#endif\n  struct mg_http_proto_data_chuncked chunk;\n  struct mg_http_endpoint *endpoints;\n  mg_event_handler_t endpoint_handler;\n  struct mg_reverse_proxy_data reverse_proxy_data;\n};\n\nstatic void mg_http_conn_destructor(void *proto_data);\nstruct mg_connection *mg_connect_http_base(\n    struct mg_mgr *mgr, MG_CB(mg_event_handler_t ev_handler, void *user_data),\n    struct mg_connect_opts opts, const char *schema, const char *schema_ssl,\n    const char *url, const char **path, char **user, char **pass, char **addr);\n\nstatic struct mg_http_proto_data *mg_http_get_proto_data(\n    struct mg_connection *c) {\n  if (c->proto_data == NULL) {\n    c->proto_data = MG_CALLOC(1, sizeof(struct mg_http_proto_data));\n    c->proto_data_destructor = mg_http_conn_destructor;\n  }\n\n  return (struct mg_http_proto_data *) c->proto_data;\n}\n\n#if MG_ENABLE_HTTP_STREAMING_MULTIPART\nstatic void mg_http_free_proto_data_mp_stream(\n    struct mg_http_multipart_stream *mp) {\n  MG_FREE((void *) mp->boundary);\n  MG_FREE((void *) mp->var_name);\n  MG_FREE((void *) mp->file_name);\n  memset(mp, 0, sizeof(*mp));\n}\n#endif\n\n#if MG_ENABLE_FILESYSTEM\nstatic void mg_http_free_proto_data_file(struct mg_http_proto_data_file *d) {\n  if (d != NULL) {\n    if (d->fp != NULL) {\n      fclose(d->fp);\n    }\n    memset(d, 0, sizeof(struct mg_http_proto_data_file));\n  }\n}\n#endif\n\nstatic void mg_http_free_proto_data_endpoints(struct mg_http_endpoint **ep) {\n  struct mg_http_endpoint *current = *ep;\n\n  while (current != NULL) {\n    struct mg_http_endpoint *tmp = current->next;\n    MG_FREE((void *) current->name);\n    MG_FREE(current);\n    current = tmp;\n  }\n\n  ep = NULL;\n}\n\nstatic void mg_http_free_reverse_proxy_data(struct mg_reverse_proxy_data *rpd) {\n  if (rpd->linked_conn != NULL) {\n    /*\n     * Connection has linked one, we have to unlink & close it\n     * since _this_ connection is going to die and\n     * it doesn't make sense to keep another one\n     */\n    struct mg_http_proto_data *pd = mg_http_get_proto_data(rpd->linked_conn);\n    if (pd->reverse_proxy_data.linked_conn != NULL) {\n      pd->reverse_proxy_data.linked_conn->flags |= MG_F_SEND_AND_CLOSE;\n      pd->reverse_proxy_data.linked_conn = NULL;\n    }\n    rpd->linked_conn = NULL;\n  }\n}\n\nstatic void mg_http_conn_destructor(void *proto_data) {\n  struct mg_http_proto_data *pd = (struct mg_http_proto_data *) proto_data;\n#if MG_ENABLE_FILESYSTEM\n  mg_http_free_proto_data_file(&pd->file);\n#endif\n#if MG_ENABLE_HTTP_CGI\n  mg_http_free_proto_data_cgi(&pd->cgi);\n#endif\n#if MG_ENABLE_HTTP_STREAMING_MULTIPART\n  mg_http_free_proto_data_mp_stream(&pd->mp_stream);\n#endif\n  mg_http_free_proto_data_endpoints(&pd->endpoints);\n  mg_http_free_reverse_proxy_data(&pd->reverse_proxy_data);\n  MG_FREE(proto_data);\n}\n\n#if MG_ENABLE_FILESYSTEM\n\n#define MIME_ENTRY(_ext, _type) \\\n  { _ext, sizeof(_ext) - 1, _type }\nstatic const struct {\n  const char *extension;\n  size_t ext_len;\n  const char *mime_type;\n} mg_static_builtin_mime_types[] = {\n    MIME_ENTRY(\"html\", \"text/html\"),\n    MIME_ENTRY(\"html\", \"text/html\"),\n    MIME_ENTRY(\"htm\", \"text/html\"),\n    MIME_ENTRY(\"shtm\", \"text/html\"),\n    MIME_ENTRY(\"shtml\", \"text/html\"),\n    MIME_ENTRY(\"css\", \"text/css\"),\n    MIME_ENTRY(\"js\", \"application/x-javascript\"),\n    MIME_ENTRY(\"ico\", \"image/x-icon\"),\n    MIME_ENTRY(\"gif\", \"image/gif\"),\n    MIME_ENTRY(\"jpg\", \"image/jpeg\"),\n    MIME_ENTRY(\"jpeg\", \"image/jpeg\"),\n    MIME_ENTRY(\"png\", \"image/png\"),\n    MIME_ENTRY(\"svg\", \"image/svg+xml\"),\n    MIME_ENTRY(\"txt\", \"text/plain\"),\n    MIME_ENTRY(\"torrent\", \"application/x-bittorrent\"),\n    MIME_ENTRY(\"wav\", \"audio/x-wav\"),\n    MIME_ENTRY(\"mp3\", \"audio/x-mp3\"),\n    MIME_ENTRY(\"mid\", \"audio/mid\"),\n    MIME_ENTRY(\"m3u\", \"audio/x-mpegurl\"),\n    MIME_ENTRY(\"ogg\", \"application/ogg\"),\n    MIME_ENTRY(\"ram\", \"audio/x-pn-realaudio\"),\n    MIME_ENTRY(\"xml\", \"text/xml\"),\n    MIME_ENTRY(\"ttf\", \"application/x-font-ttf\"),\n    MIME_ENTRY(\"json\", \"application/json\"),\n    MIME_ENTRY(\"xslt\", \"application/xml\"),\n    MIME_ENTRY(\"xsl\", \"application/xml\"),\n    MIME_ENTRY(\"ra\", \"audio/x-pn-realaudio\"),\n    MIME_ENTRY(\"doc\", \"application/msword\"),\n    MIME_ENTRY(\"exe\", \"application/octet-stream\"),\n    MIME_ENTRY(\"zip\", \"application/x-zip-compressed\"),\n    MIME_ENTRY(\"xls\", \"application/excel\"),\n    MIME_ENTRY(\"tgz\", \"application/x-tar-gz\"),\n    MIME_ENTRY(\"tar\", \"application/x-tar\"),\n    MIME_ENTRY(\"gz\", \"application/x-gunzip\"),\n    MIME_ENTRY(\"arj\", \"application/x-arj-compressed\"),\n    MIME_ENTRY(\"rar\", \"application/x-rar-compressed\"),\n    MIME_ENTRY(\"rtf\", \"application/rtf\"),\n    MIME_ENTRY(\"pdf\", \"application/pdf\"),\n    MIME_ENTRY(\"swf\", \"application/x-shockwave-flash\"),\n    MIME_ENTRY(\"mpg\", \"video/mpeg\"),\n    MIME_ENTRY(\"webm\", \"video/webm\"),\n    MIME_ENTRY(\"mpeg\", \"video/mpeg\"),\n    MIME_ENTRY(\"mov\", \"video/quicktime\"),\n    MIME_ENTRY(\"mp4\", \"video/mp4\"),\n    MIME_ENTRY(\"m4v\", \"video/x-m4v\"),\n    MIME_ENTRY(\"asf\", \"video/x-ms-asf\"),\n    MIME_ENTRY(\"avi\", \"video/x-msvideo\"),\n    MIME_ENTRY(\"bmp\", \"image/bmp\"),\n    {NULL, 0, NULL}};\n\nstatic struct mg_str mg_get_mime_type(const char *path, const char *dflt,\n                                      const struct mg_serve_http_opts *opts) {\n  const char *ext, *overrides;\n  size_t i, path_len;\n  struct mg_str r, k, v;\n\n  path_len = strlen(path);\n\n  overrides = opts->custom_mime_types;\n  while ((overrides = mg_next_comma_list_entry(overrides, &k, &v)) != NULL) {\n    ext = path + (path_len - k.len);\n    if (path_len > k.len && mg_vcasecmp(&k, ext) == 0) {\n      return v;\n    }\n  }\n\n  for (i = 0; mg_static_builtin_mime_types[i].extension != NULL; i++) {\n    ext = path + (path_len - mg_static_builtin_mime_types[i].ext_len);\n    if (path_len > mg_static_builtin_mime_types[i].ext_len && ext[-1] == '.' &&\n        mg_casecmp(ext, mg_static_builtin_mime_types[i].extension) == 0) {\n      r.p = mg_static_builtin_mime_types[i].mime_type;\n      r.len = strlen(r.p);\n      return r;\n    }\n  }\n\n  r.p = dflt;\n  r.len = strlen(r.p);\n  return r;\n}\n#endif\n\n/*\n * Check whether full request is buffered. Return:\n *   -1  if request is malformed\n *    0  if request is not yet fully buffered\n *   >0  actual request length, including last \\r\\n\\r\\n\n */\nstatic int mg_http_get_request_len(const char *s, int buf_len) {\n  const unsigned char *buf = (unsigned char *) s;\n  int i;\n\n  for (i = 0; i < buf_len; i++) {\n    if (!isprint(buf[i]) && buf[i] != '\\r' && buf[i] != '\\n' && buf[i] < 128) {\n      return -1;\n    } else if (buf[i] == '\\n' && i + 1 < buf_len && buf[i + 1] == '\\n') {\n      return i + 2;\n    } else if (buf[i] == '\\n' && i + 2 < buf_len && buf[i + 1] == '\\r' &&\n               buf[i + 2] == '\\n') {\n      return i + 3;\n    }\n  }\n\n  return 0;\n}\n\nstatic const char *mg_http_parse_headers(const char *s, const char *end,\n                                         int len, struct http_message *req) {\n  int i = 0;\n  while (i < (int) ARRAY_SIZE(req->header_names) - 1) {\n    struct mg_str *k = &req->header_names[i], *v = &req->header_values[i];\n\n    s = mg_skip(s, end, \": \", k);\n    s = mg_skip(s, end, \"\\r\\n\", v);\n\n    while (v->len > 0 && v->p[v->len - 1] == ' ') {\n      v->len--; /* Trim trailing spaces in header value */\n    }\n\n    /*\n     * If header value is empty - skip it and go to next (if any).\n     * NOTE: Do not add it to headers_values because such addition changes API\n     * behaviour\n     */\n    if (k->len != 0 && v->len == 0) {\n      continue;\n    }\n\n    if (k->len == 0 || v->len == 0) {\n      k->p = v->p = NULL;\n      k->len = v->len = 0;\n      break;\n    }\n\n    if (!mg_ncasecmp(k->p, \"Content-Length\", 14)) {\n      req->body.len = (size_t) to64(v->p);\n      req->message.len = len + req->body.len;\n    }\n\n    i++;\n  }\n\n  return s;\n}\n\nint mg_parse_http(const char *s, int n, struct http_message *hm, int is_req) {\n  const char *end, *qs;\n  int len = mg_http_get_request_len(s, n);\n\n  if (len <= 0) return len;\n\n  memset(hm, 0, sizeof(*hm));\n  hm->message.p = s;\n  hm->body.p = s + len;\n  hm->message.len = hm->body.len = (size_t) ~0;\n  end = s + len;\n\n  /* Request is fully buffered. Skip leading whitespaces. */\n  while (s < end && isspace(*(unsigned char *) s)) s++;\n\n  if (is_req) {\n    /* Parse request line: method, URI, proto */\n    s = mg_skip(s, end, \" \", &hm->method);\n    s = mg_skip(s, end, \" \", &hm->uri);\n    s = mg_skip(s, end, \"\\r\\n\", &hm->proto);\n    if (hm->uri.p <= hm->method.p || hm->proto.p <= hm->uri.p) return -1;\n\n    /* If URI contains '?' character, initialize query_string */\n    if ((qs = (char *) memchr(hm->uri.p, '?', hm->uri.len)) != NULL) {\n      hm->query_string.p = qs + 1;\n      hm->query_string.len = &hm->uri.p[hm->uri.len] - (qs + 1);\n      hm->uri.len = qs - hm->uri.p;\n    }\n  } else {\n    s = mg_skip(s, end, \" \", &hm->proto);\n    if (end - s < 4 || s[3] != ' ') return -1;\n    hm->resp_code = atoi(s);\n    if (hm->resp_code < 100 || hm->resp_code >= 600) return -1;\n    s += 4;\n    s = mg_skip(s, end, \"\\r\\n\", &hm->resp_status_msg);\n  }\n\n  s = mg_http_parse_headers(s, end, len, hm);\n\n  /*\n   * mg_parse_http() is used to parse both HTTP requests and HTTP\n   * responses. If HTTP response does not have Content-Length set, then\n   * body is read until socket is closed, i.e. body.len is infinite (~0).\n   *\n   * For HTTP requests though, according to\n   * http://tools.ietf.org/html/rfc7231#section-8.1.3,\n   * only POST and PUT methods have defined body semantics.\n   * Therefore, if Content-Length is not specified and methods are\n   * not one of PUT or POST, set body length to 0.\n   *\n   * So,\n   * if it is HTTP request, and Content-Length is not set,\n   * and method is not (PUT or POST) then reset body length to zero.\n   */\n  if (hm->body.len == (size_t) ~0 && is_req &&\n      mg_vcasecmp(&hm->method, \"PUT\") != 0 &&\n      mg_vcasecmp(&hm->method, \"POST\") != 0) {\n    hm->body.len = 0;\n    hm->message.len = len;\n  }\n\n  return len;\n}\n\nstruct mg_str *mg_get_http_header(struct http_message *hm, const char *name) {\n  size_t i, len = strlen(name);\n\n  for (i = 0; hm->header_names[i].len > 0; i++) {\n    struct mg_str *h = &hm->header_names[i], *v = &hm->header_values[i];\n    if (h->p != NULL && h->len == len && !mg_ncasecmp(h->p, name, len))\n      return v;\n  }\n\n  return NULL;\n}\n\n#if MG_ENABLE_FILESYSTEM\nstatic void mg_http_transfer_file_data(struct mg_connection *nc) {\n  struct mg_http_proto_data *pd = mg_http_get_proto_data(nc);\n  char buf[MG_MAX_HTTP_SEND_MBUF];\n  size_t n = 0, to_read = 0, left = (size_t)(pd->file.cl - pd->file.sent);\n\n  if (pd->file.type == DATA_FILE) {\n    struct mbuf *io = &nc->send_mbuf;\n    if (io->len < sizeof(buf)) {\n      to_read = sizeof(buf) - io->len;\n    }\n\n    if (left > 0 && to_read > left) {\n      to_read = left;\n    }\n\n    if (to_read == 0) {\n      /* Rate limiting. send_mbuf is too full, wait until it's drained. */\n    } else if (pd->file.sent < pd->file.cl &&\n               (n = mg_fread(buf, 1, to_read, pd->file.fp)) > 0) {\n      mg_send(nc, buf, n);\n      pd->file.sent += n;\n    } else {\n      if (!pd->file.keepalive) nc->flags |= MG_F_SEND_AND_CLOSE;\n      mg_http_free_proto_data_file(&pd->file);\n    }\n  } else if (pd->file.type == DATA_PUT) {\n    struct mbuf *io = &nc->recv_mbuf;\n    size_t to_write = left <= 0 ? 0 : left < io->len ? (size_t) left : io->len;\n    size_t n = mg_fwrite(io->buf, 1, to_write, pd->file.fp);\n    if (n > 0) {\n      mbuf_remove(io, n);\n      pd->file.sent += n;\n    }\n    if (n == 0 || pd->file.sent >= pd->file.cl) {\n      if (!pd->file.keepalive) nc->flags |= MG_F_SEND_AND_CLOSE;\n      mg_http_free_proto_data_file(&pd->file);\n    }\n  }\n#if MG_ENABLE_HTTP_CGI\n  else if (pd->cgi.cgi_nc != NULL) {\n    /* This is POST data that needs to be forwarded to the CGI process */\n    if (pd->cgi.cgi_nc != NULL) {\n      mg_forward(nc, pd->cgi.cgi_nc);\n    } else {\n      nc->flags |= MG_F_SEND_AND_CLOSE;\n    }\n  }\n#endif\n}\n#endif /* MG_ENABLE_FILESYSTEM */\n\n/*\n * Parse chunked-encoded buffer. Return 0 if the buffer is not encoded, or\n * if it's incomplete. If the chunk is fully buffered, return total number of\n * bytes in a chunk, and store data in `data`, `data_len`.\n */\nstatic size_t mg_http_parse_chunk(char *buf, size_t len, char **chunk_data,\n                                  size_t *chunk_len) {\n  unsigned char *s = (unsigned char *) buf;\n  size_t n = 0; /* scanned chunk length */\n  size_t i = 0; /* index in s */\n\n  /* Scan chunk length. That should be a hexadecimal number. */\n  while (i < len && isxdigit(s[i])) {\n    n *= 16;\n    n += (s[i] >= '0' && s[i] <= '9') ? s[i] - '0' : tolower(s[i]) - 'a' + 10;\n    i++;\n  }\n\n  /* Skip new line */\n  if (i == 0 || i + 2 > len || s[i] != '\\r' || s[i + 1] != '\\n') {\n    return 0;\n  }\n  i += 2;\n\n  /* Record where the data is */\n  *chunk_data = (char *) s + i;\n  *chunk_len = n;\n\n  /* Skip data */\n  i += n;\n\n  /* Skip new line */\n  if (i == 0 || i + 2 > len || s[i] != '\\r' || s[i + 1] != '\\n') {\n    return 0;\n  }\n  return i + 2;\n}\n\nMG_INTERNAL size_t mg_handle_chunked(struct mg_connection *nc,\n                                     struct http_message *hm, char *buf,\n                                     size_t blen) {\n  struct mg_http_proto_data *pd = mg_http_get_proto_data(nc);\n  char *data;\n  size_t i, n, data_len, body_len, zero_chunk_received = 0;\n  /* Find out piece of received data that is not yet reassembled */\n  body_len = (size_t) pd->chunk.body_len;\n  assert(blen >= body_len);\n\n  /* Traverse all fully buffered chunks */\n  for (i = body_len;\n       (n = mg_http_parse_chunk(buf + i, blen - i, &data, &data_len)) > 0;\n       i += n) {\n    /* Collapse chunk data to the rest of HTTP body */\n    memmove(buf + body_len, data, data_len);\n    body_len += data_len;\n    hm->body.len = body_len;\n\n    if (data_len == 0) {\n      zero_chunk_received = 1;\n      i += n;\n      break;\n    }\n  }\n\n  if (i > body_len) {\n    /* Shift unparsed content to the parsed body */\n    assert(i <= blen);\n    memmove(buf + body_len, buf + i, blen - i);\n    memset(buf + body_len + blen - i, 0, i - body_len);\n    nc->recv_mbuf.len -= i - body_len;\n    pd->chunk.body_len = body_len;\n\n    /* Send MG_EV_HTTP_CHUNK event */\n    nc->flags &= ~MG_F_DELETE_CHUNK;\n    mg_call(nc, nc->handler, nc->user_data, MG_EV_HTTP_CHUNK, hm);\n\n    /* Delete processed data if user set MG_F_DELETE_CHUNK flag */\n    if (nc->flags & MG_F_DELETE_CHUNK) {\n      memset(buf, 0, body_len);\n      memmove(buf, buf + body_len, blen - i);\n      nc->recv_mbuf.len -= body_len;\n      hm->body.len = 0;\n      pd->chunk.body_len = 0;\n    }\n\n    if (zero_chunk_received) {\n      /* Total message size is len(body) + len(headers) */\n      hm->message.len =\n          (size_t) pd->chunk.body_len + blen - i + (hm->body.p - hm->message.p);\n    }\n  }\n\n  return body_len;\n}\n\nstruct mg_http_endpoint *mg_http_get_endpoint_handler(struct mg_connection *nc,\n                                                      struct mg_str *uri_path) {\n  struct mg_http_proto_data *pd;\n  struct mg_http_endpoint *ret = NULL;\n  int matched, matched_max = 0;\n  struct mg_http_endpoint *ep;\n\n  if (nc == NULL) {\n    return NULL;\n  }\n\n  pd = mg_http_get_proto_data(nc);\n\n  ep = pd->endpoints;\n  while (ep != NULL) {\n    const struct mg_str name_s = {ep->name, ep->name_len};\n    if ((matched = mg_match_prefix_n(name_s, *uri_path)) != -1) {\n      if (matched > matched_max) {\n        /* Looking for the longest suitable handler */\n        ret = ep;\n        matched_max = matched;\n      }\n    }\n\n    ep = ep->next;\n  }\n\n  return ret;\n}\n\nstatic void mg_http_call_endpoint_handler(struct mg_connection *nc, int ev,\n                                          struct http_message *hm) {\n  struct mg_http_proto_data *pd = mg_http_get_proto_data(nc);\n  void *user_data = nc->user_data;\n\n  if (ev == MG_EV_HTTP_REQUEST) {\n    struct mg_http_endpoint *ep =\n        mg_http_get_endpoint_handler(nc->listener, &hm->uri);\n    if (ep != NULL) {\n      pd->endpoint_handler = ep->handler;\n#if MG_ENABLE_CALLBACK_USERDATA\n      user_data = ep->user_data;\n#endif\n    }\n  }\n  mg_call(nc, pd->endpoint_handler ? pd->endpoint_handler : nc->handler,\n          user_data, ev, hm);\n}\n\n#if MG_ENABLE_HTTP_STREAMING_MULTIPART\nstatic void mg_http_multipart_continue(struct mg_connection *nc);\n\nstatic void mg_http_multipart_begin(struct mg_connection *nc,\n                                    struct http_message *hm, int req_len);\n\n#endif\n\n/*\n * lx106 compiler has a bug (TODO(mkm) report and insert tracking bug here)\n * If a big structure is declared in a big function, lx106 gcc will make it\n * even bigger (round up to 4k, from 700 bytes of actual size).\n */\n#ifdef __xtensa__\nstatic void mg_http_handler2(struct mg_connection *nc, int ev,\n                             void *ev_data MG_UD_ARG(void *user_data),\n                             struct http_message *hm) __attribute__((noinline));\n\nvoid mg_http_handler(struct mg_connection *nc, int ev,\n                     void *ev_data MG_UD_ARG(void *user_data)) {\n  struct http_message hm;\n  mg_http_handler2(nc, ev, ev_data MG_UD_ARG(user_data), &hm);\n}\n\nstatic void mg_http_handler2(struct mg_connection *nc, int ev,\n                             void *ev_data MG_UD_ARG(void *user_data),\n                             struct http_message *hm) {\n#else  /* !__XTENSA__ */\nvoid mg_http_handler(struct mg_connection *nc, int ev,\n                     void *ev_data MG_UD_ARG(void *user_data)) {\n  struct http_message shm;\n  struct http_message *hm = &shm;\n#endif /* __XTENSA__ */\n  struct mg_http_proto_data *pd = mg_http_get_proto_data(nc);\n  struct mbuf *io = &nc->recv_mbuf;\n  int req_len;\n  const int is_req = (nc->listener != NULL);\n#if MG_ENABLE_HTTP_WEBSOCKET\n  struct mg_str *vec;\n#endif\n  if (ev == MG_EV_CLOSE) {\n#if MG_ENABLE_HTTP_CGI\n    /* Close associated CGI forwarder connection */\n    if (pd->cgi.cgi_nc != NULL) {\n      pd->cgi.cgi_nc->user_data = NULL;\n      pd->cgi.cgi_nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n    }\n#endif\n#if MG_ENABLE_HTTP_STREAMING_MULTIPART\n    if (pd->mp_stream.boundary != NULL) {\n      /*\n       * Multipart message is in progress, but connection is closed.\n       * Finish part and request with an error flag.\n       */\n      struct mg_http_multipart_part mp;\n      memset(&mp, 0, sizeof(mp));\n      mp.status = -1;\n      mp.var_name = pd->mp_stream.var_name;\n      mp.file_name = pd->mp_stream.file_name;\n      mg_call(nc, (pd->endpoint_handler ? pd->endpoint_handler : nc->handler),\n              nc->user_data, MG_EV_HTTP_PART_END, &mp);\n      mp.var_name = NULL;\n      mp.file_name = NULL;\n      mg_call(nc, (pd->endpoint_handler ? pd->endpoint_handler : nc->handler),\n              nc->user_data, MG_EV_HTTP_MULTIPART_REQUEST_END, &mp);\n    } else\n#endif\n        if (io->len > 0 && mg_parse_http(io->buf, io->len, hm, is_req) > 0) {\n      /*\n      * For HTTP messages without Content-Length, always send HTTP message\n      * before MG_EV_CLOSE message.\n      */\n      int ev2 = is_req ? MG_EV_HTTP_REQUEST : MG_EV_HTTP_REPLY;\n      hm->message.len = io->len;\n      hm->body.len = io->buf + io->len - hm->body.p;\n      mg_http_call_endpoint_handler(nc, ev2, hm);\n    }\n  }\n\n#if MG_ENABLE_FILESYSTEM\n  if (pd->file.fp != NULL) {\n    mg_http_transfer_file_data(nc);\n  }\n#endif\n\n  mg_call(nc, nc->handler, nc->user_data, ev, ev_data);\n\n  if (ev == MG_EV_RECV) {\n    struct mg_str *s;\n\n#if MG_ENABLE_HTTP_STREAMING_MULTIPART\n    if (pd->mp_stream.boundary != NULL) {\n      mg_http_multipart_continue(nc);\n      return;\n    }\n#endif /* MG_ENABLE_HTTP_STREAMING_MULTIPART */\n\n    req_len = mg_parse_http(io->buf, io->len, hm, is_req);\n\n    if (req_len > 0 &&\n        (s = mg_get_http_header(hm, \"Transfer-Encoding\")) != NULL &&\n        mg_vcasecmp(s, \"chunked\") == 0) {\n      mg_handle_chunked(nc, hm, io->buf + req_len, io->len - req_len);\n    }\n\n#if MG_ENABLE_HTTP_STREAMING_MULTIPART\n    if (req_len > 0 && (s = mg_get_http_header(hm, \"Content-Type\")) != NULL &&\n        s->len >= 9 && strncmp(s->p, \"multipart\", 9) == 0) {\n      mg_http_multipart_begin(nc, hm, req_len);\n      mg_http_multipart_continue(nc);\n      return;\n    }\n#endif /* MG_ENABLE_HTTP_STREAMING_MULTIPART */\n\n    /* TODO(alashkin): refactor this ifelseifelseifelseifelse */\n    if ((req_len < 0 ||\n         (req_len == 0 && io->len >= MG_MAX_HTTP_REQUEST_SIZE))) {\n      DBG((\"invalid request\"));\n      nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n    } else if (req_len == 0) {\n      /* Do nothing, request is not yet fully buffered */\n    }\n#if MG_ENABLE_HTTP_WEBSOCKET\n    else if (nc->listener == NULL &&\n             mg_get_http_header(hm, \"Sec-WebSocket-Accept\")) {\n      /* We're websocket client, got handshake response from server. */\n      /* TODO(lsm): check the validity of accept Sec-WebSocket-Accept */\n      mbuf_remove(io, req_len);\n      nc->proto_handler = mg_ws_handler;\n      nc->flags |= MG_F_IS_WEBSOCKET;\n      mg_call(nc, nc->handler, nc->user_data, MG_EV_WEBSOCKET_HANDSHAKE_DONE,\n              NULL);\n      mg_ws_handler(nc, MG_EV_RECV, ev_data MG_UD_ARG(user_data));\n    } else if (nc->listener != NULL &&\n               (vec = mg_get_http_header(hm, \"Sec-WebSocket-Key\")) != NULL) {\n      struct mg_http_endpoint *ep;\n\n      /* This is a websocket request. Switch protocol handlers. */\n      mbuf_remove(io, req_len);\n      nc->proto_handler = mg_ws_handler;\n      nc->flags |= MG_F_IS_WEBSOCKET;\n\n      /*\n       * If we have a handler set up with mg_register_http_endpoint(),\n       * deliver subsequent websocket events to this handler after the\n       * protocol switch.\n       */\n      ep = mg_http_get_endpoint_handler(nc->listener, &hm->uri);\n      if (ep != NULL) {\n        nc->handler = ep->handler;\n#if MG_ENABLE_CALLBACK_USERDATA\n        nc->user_data = ep->user_data;\n#endif\n      }\n\n      /* Send handshake */\n      mg_call(nc, nc->handler, nc->user_data, MG_EV_WEBSOCKET_HANDSHAKE_REQUEST,\n              hm);\n      if (!(nc->flags & (MG_F_CLOSE_IMMEDIATELY | MG_F_SEND_AND_CLOSE))) {\n        if (nc->send_mbuf.len == 0) {\n          mg_ws_handshake(nc, vec);\n        }\n        mg_call(nc, nc->handler, nc->user_data, MG_EV_WEBSOCKET_HANDSHAKE_DONE,\n                NULL);\n        mg_ws_handler(nc, MG_EV_RECV, ev_data MG_UD_ARG(user_data));\n      }\n    }\n#endif /* MG_ENABLE_HTTP_WEBSOCKET */\n    else if (hm->message.len <= io->len) {\n      int trigger_ev = nc->listener ? MG_EV_HTTP_REQUEST : MG_EV_HTTP_REPLY;\n      char addr[32];\n      mg_sock_addr_to_str(&nc->sa, addr, sizeof(addr),\n                          MG_SOCK_STRINGIFY_IP | MG_SOCK_STRINGIFY_PORT);\n      DBG((\"%p %s %.*s %.*s\", nc, addr, (int) hm->method.len, hm->method.p,\n           (int) hm->uri.len, hm->uri.p));\n\n/* Whole HTTP message is fully buffered, call event handler */\n\n#if MG_ENABLE_JAVASCRIPT\n      v7_val_t v1, v2, headers, req, args, res;\n      struct v7 *v7 = nc->mgr->v7;\n      const char *ev_name = trigger_ev == MG_EV_HTTP_REPLY ? \"onsnd\" : \"onrcv\";\n      int i, js_callback_handled_request = 0;\n\n      if (v7 != NULL) {\n        /* Lookup JS callback */\n        v1 = v7_get(v7, v7_get_global(v7), \"Http\", ~0);\n        v2 = v7_get(v7, v1, ev_name, ~0);\n\n        /* Create callback params. TODO(lsm): own/disown those */\n        args = v7_mk_array(v7);\n        req = v7_mk_object(v7);\n        headers = v7_mk_object(v7);\n\n        /* Populate request object */\n        v7_set(v7, req, \"method\", ~0,\n               v7_mk_string(v7, hm->method.p, hm->method.len, 1));\n        v7_set(v7, req, \"uri\", ~0, v7_mk_string(v7, hm->uri.p, hm->uri.len, 1));\n        v7_set(v7, req, \"body\", ~0,\n               v7_mk_string(v7, hm->body.p, hm->body.len, 1));\n        v7_set(v7, req, \"headers\", ~0, headers);\n        for (i = 0; hm->header_names[i].len > 0; i++) {\n          const struct mg_str *name = &hm->header_names[i];\n          const struct mg_str *value = &hm->header_values[i];\n          v7_set(v7, headers, name->p, name->len,\n                 v7_mk_string(v7, value->p, value->len, 1));\n        }\n\n        /* Invoke callback. TODO(lsm): report errors */\n        v7_array_push(v7, args, v7_mk_foreign(v7, nc));\n        v7_array_push(v7, args, req);\n        if (v7_apply(v7, v2, V7_UNDEFINED, args, &res) == V7_OK &&\n            v7_is_truthy(v7, res)) {\n          js_callback_handled_request++;\n        }\n      }\n\n      /* If JS callback returns true, stop request processing */\n      if (js_callback_handled_request) {\n        nc->flags |= MG_F_SEND_AND_CLOSE;\n      } else {\n        mg_http_call_endpoint_handler(nc, trigger_ev, hm);\n      }\n#else\n      mg_http_call_endpoint_handler(nc, trigger_ev, hm);\n#endif\n      mbuf_remove(io, hm->message.len);\n    }\n  }\n  (void) pd;\n}\n\nstatic size_t mg_get_line_len(const char *buf, size_t buf_len) {\n  size_t len = 0;\n  while (len < buf_len && buf[len] != '\\n') len++;\n  return len == buf_len ? 0 : len + 1;\n}\n\n#if MG_ENABLE_HTTP_STREAMING_MULTIPART\nstatic void mg_http_multipart_begin(struct mg_connection *nc,\n                                    struct http_message *hm, int req_len) {\n  struct mg_http_proto_data *pd = mg_http_get_proto_data(nc);\n  struct mg_str *ct;\n  struct mbuf *io = &nc->recv_mbuf;\n  void *user_data = nc->user_data;\n\n  char boundary[100];\n  int boundary_len;\n\n  ct = mg_get_http_header(hm, \"Content-Type\");\n  if (ct == NULL) {\n    /* We need more data - or it isn't multipart mesage */\n    goto exit_mp;\n  }\n\n  /* Content-type should start with \"multipart\" */\n  if (ct->len < 9 || strncmp(ct->p, \"multipart\", 9) != 0) {\n    goto exit_mp;\n  }\n\n  boundary_len =\n      mg_http_parse_header(ct, \"boundary\", boundary, sizeof(boundary));\n  if (boundary_len == 0) {\n    /*\n     * Content type is multipart, but there is no boundary,\n     * probably malformed request\n     */\n    nc->flags = MG_F_CLOSE_IMMEDIATELY;\n    DBG((\"invalid request\"));\n    goto exit_mp;\n  }\n\n  /* If we reach this place - that is multipart request */\n\n  if (pd->mp_stream.boundary != NULL) {\n    /*\n     * Another streaming request was in progress,\n     * looks like protocol error\n     */\n    nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n  } else {\n    struct mg_http_endpoint *ep = NULL;\n    pd->mp_stream.state = MPS_BEGIN;\n    pd->mp_stream.boundary = strdup(boundary);\n    pd->mp_stream.boundary_len = strlen(boundary);\n    pd->mp_stream.var_name = pd->mp_stream.file_name = NULL;\n    pd->endpoint_handler = nc->handler;\n\n    ep = mg_http_get_endpoint_handler(nc->listener, &hm->uri);\n    if (ep != NULL) {\n      pd->endpoint_handler = ep->handler;\n#if MG_ENABLE_CALLBACK_USERDATA\n      user_data = ep->user_data;\n#endif\n    }\n\n    mg_call(nc, pd->endpoint_handler, user_data, MG_EV_HTTP_MULTIPART_REQUEST,\n            hm);\n\n    mbuf_remove(io, req_len);\n  }\nexit_mp:\n  ;\n}\n\n#define CONTENT_DISPOSITION \"Content-Disposition: \"\n\nstatic void mg_http_multipart_call_handler(struct mg_connection *c, int ev,\n                                           const char *data, size_t data_len) {\n  struct mg_http_multipart_part mp;\n  struct mg_http_proto_data *pd = mg_http_get_proto_data(c);\n  memset(&mp, 0, sizeof(mp));\n\n  mp.var_name = pd->mp_stream.var_name;\n  mp.file_name = pd->mp_stream.file_name;\n  mp.user_data = pd->mp_stream.user_data;\n  mp.data.p = data;\n  mp.data.len = data_len;\n  mg_call(c, pd->endpoint_handler, c->user_data, ev, &mp);\n  pd->mp_stream.user_data = mp.user_data;\n}\n\nstatic int mg_http_multipart_got_chunk(struct mg_connection *c) {\n  struct mg_http_proto_data *pd = mg_http_get_proto_data(c);\n  struct mbuf *io = &c->recv_mbuf;\n\n  mg_http_multipart_call_handler(c, MG_EV_HTTP_PART_DATA, io->buf,\n                                 pd->mp_stream.prev_io_len);\n  mbuf_remove(io, pd->mp_stream.prev_io_len);\n  pd->mp_stream.prev_io_len = 0;\n  pd->mp_stream.state = MPS_WAITING_FOR_CHUNK;\n\n  return 0;\n}\n\nstatic int mg_http_multipart_finalize(struct mg_connection *c) {\n  struct mg_http_proto_data *pd = mg_http_get_proto_data(c);\n\n  mg_http_multipart_call_handler(c, MG_EV_HTTP_PART_END, NULL, 0);\n  MG_FREE((void *) pd->mp_stream.file_name);\n  pd->mp_stream.file_name = NULL;\n  MG_FREE((void *) pd->mp_stream.var_name);\n  pd->mp_stream.var_name = NULL;\n  mg_http_multipart_call_handler(c, MG_EV_HTTP_MULTIPART_REQUEST_END, NULL, 0);\n  mg_http_free_proto_data_mp_stream(&pd->mp_stream);\n  pd->mp_stream.state = MPS_FINISHED;\n\n  return 1;\n}\n\nstatic int mg_http_multipart_wait_for_boundary(struct mg_connection *c) {\n  const char *boundary;\n  struct mbuf *io = &c->recv_mbuf;\n  struct mg_http_proto_data *pd = mg_http_get_proto_data(c);\n\n  if ((int) io->len < pd->mp_stream.boundary_len + 2) {\n    return 0;\n  }\n\n  boundary = c_strnstr(io->buf, pd->mp_stream.boundary, io->len);\n  if (boundary != NULL) {\n    const char *boundary_end = (boundary + pd->mp_stream.boundary_len);\n    if (io->len - (boundary_end - io->buf) < 4) {\n      return 0;\n    }\n    if (strncmp(boundary_end, \"--\\r\\n\", 4) == 0) {\n      pd->mp_stream.state = MPS_FINALIZE;\n      mbuf_remove(io, (boundary_end - io->buf) + 4);\n    } else {\n      pd->mp_stream.state = MPS_GOT_BOUNDARY;\n    }\n  } else {\n    return 0;\n  }\n\n  return 1;\n}\n\nstatic int mg_http_multipart_process_boundary(struct mg_connection *c) {\n  int data_size;\n  const char *boundary, *block_begin;\n  struct mbuf *io = &c->recv_mbuf;\n  struct mg_http_proto_data *pd = mg_http_get_proto_data(c);\n  char file_name[100], var_name[100];\n  int line_len;\n  boundary = c_strnstr(io->buf, pd->mp_stream.boundary, io->len);\n  block_begin = boundary + pd->mp_stream.boundary_len + 2;\n  data_size = io->len - (block_begin - io->buf);\n\n  while (data_size > 0 &&\n         (line_len = mg_get_line_len(block_begin, data_size)) != 0) {\n    if (line_len > (int) sizeof(CONTENT_DISPOSITION) &&\n        mg_ncasecmp(block_begin, CONTENT_DISPOSITION,\n                    sizeof(CONTENT_DISPOSITION) - 1) == 0) {\n      struct mg_str header;\n\n      header.p = block_begin + sizeof(CONTENT_DISPOSITION) - 1;\n      header.len = line_len - sizeof(CONTENT_DISPOSITION) - 1;\n      mg_http_parse_header(&header, \"name\", var_name, sizeof(var_name) - 2);\n      mg_http_parse_header(&header, \"filename\", file_name,\n                           sizeof(file_name) - 2);\n      block_begin += line_len;\n      data_size -= line_len;\n      continue;\n    }\n\n    if (line_len == 2 && mg_ncasecmp(block_begin, \"\\r\\n\", 2) == 0) {\n      mbuf_remove(io, block_begin - io->buf + 2);\n\n      if (pd->mp_stream.processing_part != 0) {\n        mg_http_multipart_call_handler(c, MG_EV_HTTP_PART_END, NULL, 0);\n      }\n\n      MG_FREE((void *) pd->mp_stream.file_name);\n      pd->mp_stream.file_name = strdup(file_name);\n      MG_FREE((void *) pd->mp_stream.var_name);\n      pd->mp_stream.var_name = strdup(var_name);\n\n      mg_http_multipart_call_handler(c, MG_EV_HTTP_PART_BEGIN, NULL, 0);\n      pd->mp_stream.state = MPS_WAITING_FOR_CHUNK;\n      pd->mp_stream.processing_part++;\n      return 1;\n    }\n\n    block_begin += line_len;\n  }\n\n  pd->mp_stream.state = MPS_WAITING_FOR_BOUNDARY;\n\n  return 0;\n}\n\nstatic int mg_http_multipart_continue_wait_for_chunk(struct mg_connection *c) {\n  struct mg_http_proto_data *pd = mg_http_get_proto_data(c);\n  struct mbuf *io = &c->recv_mbuf;\n\n  const char *boundary;\n  if ((int) io->len < pd->mp_stream.boundary_len + 6 /* \\r\\n, --, -- */) {\n    return 0;\n  }\n\n  boundary = c_strnstr(io->buf, pd->mp_stream.boundary, io->len);\n  if (boundary == NULL && pd->mp_stream.prev_io_len == 0) {\n    pd->mp_stream.prev_io_len = io->len;\n    return 0;\n  } else if (boundary == NULL &&\n             (int) io->len >\n                 pd->mp_stream.prev_io_len + pd->mp_stream.boundary_len + 4) {\n    pd->mp_stream.state = MPS_GOT_CHUNK;\n    return 1;\n  } else if (boundary != NULL) {\n    int data_size = (boundary - io->buf - 4);\n    mg_http_multipart_call_handler(c, MG_EV_HTTP_PART_DATA, io->buf, data_size);\n    mbuf_remove(io, (boundary - io->buf));\n    pd->mp_stream.prev_io_len = 0;\n    pd->mp_stream.state = MPS_WAITING_FOR_BOUNDARY;\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\nstatic void mg_http_multipart_continue(struct mg_connection *c) {\n  struct mg_http_proto_data *pd = mg_http_get_proto_data(c);\n  while (1) {\n    switch (pd->mp_stream.state) {\n      case MPS_BEGIN: {\n        pd->mp_stream.state = MPS_WAITING_FOR_BOUNDARY;\n        break;\n      }\n      case MPS_WAITING_FOR_BOUNDARY: {\n        if (mg_http_multipart_wait_for_boundary(c) == 0) {\n          return;\n        }\n        break;\n      }\n      case MPS_GOT_BOUNDARY: {\n        if (mg_http_multipart_process_boundary(c) == 0) {\n          return;\n        }\n        break;\n      }\n      case MPS_WAITING_FOR_CHUNK: {\n        if (mg_http_multipart_continue_wait_for_chunk(c) == 0) {\n          return;\n        }\n        break;\n      }\n      case MPS_GOT_CHUNK: {\n        if (mg_http_multipart_got_chunk(c) == 0) {\n          return;\n        }\n        break;\n      }\n      case MPS_FINALIZE: {\n        if (mg_http_multipart_finalize(c) == 0) {\n          return;\n        }\n        break;\n      }\n      case MPS_FINISHED: {\n        mbuf_remove(&c->recv_mbuf, c->recv_mbuf.len);\n        return;\n      }\n    }\n  }\n}\n\nstruct file_upload_state {\n  char *lfn;\n  size_t num_recd;\n  FILE *fp;\n};\n\n#endif /* MG_ENABLE_HTTP_STREAMING_MULTIPART */\n\nvoid mg_set_protocol_http_websocket(struct mg_connection *nc) {\n  nc->proto_handler = mg_http_handler;\n}\n\nconst char *mg_status_message(int status_code) {\n  switch (status_code) {\n    case 206:\n      return \"Partial Content\";\n    case 301:\n      return \"Moved\";\n    case 302:\n      return \"Found\";\n    case 400:\n      return \"Bad Request\";\n    case 401:\n      return \"Unauthorized\";\n    case 403:\n      return \"Forbidden\";\n    case 404:\n      return \"Not Found\";\n    case 416:\n      return \"Requested Range Not Satisfiable\";\n    case 418:\n      return \"I'm a teapot\";\n    case 500:\n      return \"Internal Server Error\";\n    case 502:\n      return \"Bad Gateway\";\n    case 503:\n      return \"Service Unavailable\";\n\n#if MG_ENABLE_EXTRA_ERRORS_DESC\n    case 100:\n      return \"Continue\";\n    case 101:\n      return \"Switching Protocols\";\n    case 102:\n      return \"Processing\";\n    case 200:\n      return \"OK\";\n    case 201:\n      return \"Created\";\n    case 202:\n      return \"Accepted\";\n    case 203:\n      return \"Non-Authoritative Information\";\n    case 204:\n      return \"No Content\";\n    case 205:\n      return \"Reset Content\";\n    case 207:\n      return \"Multi-Status\";\n    case 208:\n      return \"Already Reported\";\n    case 226:\n      return \"IM Used\";\n    case 300:\n      return \"Multiple Choices\";\n    case 303:\n      return \"See Other\";\n    case 304:\n      return \"Not Modified\";\n    case 305:\n      return \"Use Proxy\";\n    case 306:\n      return \"Switch Proxy\";\n    case 307:\n      return \"Temporary Redirect\";\n    case 308:\n      return \"Permanent Redirect\";\n    case 402:\n      return \"Payment Required\";\n    case 405:\n      return \"Method Not Allowed\";\n    case 406:\n      return \"Not Acceptable\";\n    case 407:\n      return \"Proxy Authentication Required\";\n    case 408:\n      return \"Request Timeout\";\n    case 409:\n      return \"Conflict\";\n    case 410:\n      return \"Gone\";\n    case 411:\n      return \"Length Required\";\n    case 412:\n      return \"Precondition Failed\";\n    case 413:\n      return \"Payload Too Large\";\n    case 414:\n      return \"URI Too Long\";\n    case 415:\n      return \"Unsupported Media Type\";\n    case 417:\n      return \"Expectation Failed\";\n    case 422:\n      return \"Unprocessable Entity\";\n    case 423:\n      return \"Locked\";\n    case 424:\n      return \"Failed Dependency\";\n    case 426:\n      return \"Upgrade Required\";\n    case 428:\n      return \"Precondition Required\";\n    case 429:\n      return \"Too Many Requests\";\n    case 431:\n      return \"Request Header Fields Too Large\";\n    case 451:\n      return \"Unavailable For Legal Reasons\";\n    case 501:\n      return \"Not Implemented\";\n    case 504:\n      return \"Gateway Timeout\";\n    case 505:\n      return \"HTTP Version Not Supported\";\n    case 506:\n      return \"Variant Also Negotiates\";\n    case 507:\n      return \"Insufficient Storage\";\n    case 508:\n      return \"Loop Detected\";\n    case 510:\n      return \"Not Extended\";\n    case 511:\n      return \"Network Authentication Required\";\n#endif /* MG_ENABLE_EXTRA_ERRORS_DESC */\n\n    default:\n      return \"OK\";\n  }\n}\n\nvoid mg_send_response_line_s(struct mg_connection *nc, int status_code,\n                             const struct mg_str extra_headers) {\n  mg_printf(nc, \"HTTP/1.1 %d %s\\r\\nServer: %s\\r\\n\", status_code,\n            mg_status_message(status_code), mg_version_header);\n  if (extra_headers.len > 0) {\n    mg_printf(nc, \"%.*s\\r\\n\", (int) extra_headers.len, extra_headers.p);\n  }\n}\n\nvoid mg_send_response_line(struct mg_connection *nc, int status_code,\n                           const char *extra_headers) {\n  mg_send_response_line_s(nc, status_code, mg_mk_str(extra_headers));\n}\n\nvoid mg_http_send_redirect(struct mg_connection *nc, int status_code,\n                           const struct mg_str location,\n                           const struct mg_str extra_headers) {\n  char bbody[100], *pbody = bbody;\n  int bl = mg_asprintf(&pbody, sizeof(bbody),\n                       \"<p>Moved <a href='%.*s'>here</a>.\\r\\n\",\n                       (int) location.len, location.p);\n  char bhead[150], *phead = bhead;\n  mg_asprintf(&phead, sizeof(bhead),\n              \"Location: %.*s\\r\\n\"\n              \"Content-Type: text/html\\r\\n\"\n              \"Content-Length: %d\\r\\n\"\n              \"Cache-Control: no-cache\\r\\n\"\n              \"%.*s%s\",\n              (int) location.len, location.p, bl, (int) extra_headers.len,\n              extra_headers.p, (extra_headers.len > 0 ? \"\\r\\n\" : \"\"));\n  mg_send_response_line(nc, status_code, phead);\n  if (phead != bhead) MG_FREE(phead);\n  mg_send(nc, pbody, bl);\n  if (pbody != bbody) MG_FREE(pbody);\n}\n\nvoid mg_send_head(struct mg_connection *c, int status_code,\n                  int64_t content_length, const char *extra_headers) {\n  mg_send_response_line(c, status_code, extra_headers);\n  if (content_length < 0) {\n    mg_printf(c, \"%s\", \"Transfer-Encoding: chunked\\r\\n\");\n  } else {\n    mg_printf(c, \"Content-Length: %\" INT64_FMT \"\\r\\n\", content_length);\n  }\n  mg_send(c, \"\\r\\n\", 2);\n}\n\nvoid mg_http_send_error(struct mg_connection *nc, int code,\n                        const char *reason) {\n  if (!reason) reason = mg_status_message(code);\n  LOG(LL_DEBUG, (\"%p %d %s\", nc, code, reason));\n  mg_send_head(nc, code, strlen(reason),\n               \"Content-Type: text/plain\\r\\nConnection: close\");\n  mg_send(nc, reason, strlen(reason));\n  nc->flags |= MG_F_SEND_AND_CLOSE;\n}\n\n#if MG_ENABLE_FILESYSTEM\nstatic void mg_http_construct_etag(char *buf, size_t buf_len,\n                                   const cs_stat_t *st) {\n  snprintf(buf, buf_len, \"\\\"%lx.%\" INT64_FMT \"\\\"\", (unsigned long) st->st_mtime,\n           (int64_t) st->st_size);\n}\n\n#ifndef WINCE\nstatic void mg_gmt_time_string(char *buf, size_t buf_len, time_t *t) {\n  strftime(buf, buf_len, \"%a, %d %b %Y %H:%M:%S GMT\", gmtime(t));\n}\n#else\n/* Look wince_lib.c for WindowsCE implementation */\nstatic void mg_gmt_time_string(char *buf, size_t buf_len, time_t *t);\n#endif\n\nstatic int mg_http_parse_range_header(const struct mg_str *header, int64_t *a,\n                                      int64_t *b) {\n  /*\n   * There is no snscanf. Headers are not guaranteed to be NUL-terminated,\n   * so we have this. Ugh.\n   */\n  int result;\n  char *p = (char *) MG_MALLOC(header->len + 1);\n  if (p == NULL) return 0;\n  memcpy(p, header->p, header->len);\n  p[header->len] = '\\0';\n  result = sscanf(p, \"bytes=%\" INT64_FMT \"-%\" INT64_FMT, a, b);\n  MG_FREE(p);\n  return result;\n}\n\nvoid mg_http_serve_file(struct mg_connection *nc, struct http_message *hm,\n                        const char *path, const struct mg_str mime_type,\n                        const struct mg_str extra_headers) {\n  struct mg_http_proto_data *pd = mg_http_get_proto_data(nc);\n  cs_stat_t st;\n  LOG(LL_DEBUG, (\"%p [%s] %.*s\", nc, path, (int) mime_type.len, mime_type.p));\n  if (mg_stat(path, &st) != 0 || (pd->file.fp = mg_fopen(path, \"rb\")) == NULL) {\n    int code, err = mg_get_errno();\n    switch (err) {\n      case EACCES:\n        code = 403;\n        break;\n      case ENOENT:\n        code = 404;\n        break;\n      default:\n        code = 500;\n    };\n    mg_http_send_error(nc, code, \"Open failed\");\n  } else {\n    char etag[50], current_time[50], last_modified[50], range[70];\n    time_t t = (time_t) mg_time();\n    int64_t r1 = 0, r2 = 0, cl = st.st_size;\n    struct mg_str *range_hdr = mg_get_http_header(hm, \"Range\");\n    int n, status_code = 200;\n\n    /* Handle Range header */\n    range[0] = '\\0';\n    if (range_hdr != NULL &&\n        (n = mg_http_parse_range_header(range_hdr, &r1, &r2)) > 0 && r1 >= 0 &&\n        r2 >= 0) {\n      /* If range is specified like \"400-\", set second limit to content len */\n      if (n == 1) {\n        r2 = cl - 1;\n      }\n      if (r1 > r2 || r2 >= cl) {\n        status_code = 416;\n        cl = 0;\n        snprintf(range, sizeof(range),\n                 \"Content-Range: bytes */%\" INT64_FMT \"\\r\\n\",\n                 (int64_t) st.st_size);\n      } else {\n        status_code = 206;\n        cl = r2 - r1 + 1;\n        snprintf(range, sizeof(range), \"Content-Range: bytes %\" INT64_FMT\n                                       \"-%\" INT64_FMT \"/%\" INT64_FMT \"\\r\\n\",\n                 r1, r1 + cl - 1, (int64_t) st.st_size);\n#if _FILE_OFFSET_BITS == 64 || _POSIX_C_SOURCE >= 200112L || \\\n    _XOPEN_SOURCE >= 600\n        fseeko(pd->file.fp, r1, SEEK_SET);\n#else\n        fseek(pd->file.fp, (long) r1, SEEK_SET);\n#endif\n      }\n    }\n\n#if !MG_DISABLE_HTTP_KEEP_ALIVE\n    {\n      struct mg_str *conn_hdr = mg_get_http_header(hm, \"Connection\");\n      if (conn_hdr != NULL) {\n        pd->file.keepalive = (mg_vcasecmp(conn_hdr, \"keep-alive\") == 0);\n      } else {\n        pd->file.keepalive = (mg_vcmp(&hm->proto, \"HTTP/1.1\") == 0);\n      }\n    }\n#endif\n\n    mg_http_construct_etag(etag, sizeof(etag), &st);\n    mg_gmt_time_string(current_time, sizeof(current_time), &t);\n    mg_gmt_time_string(last_modified, sizeof(last_modified), &st.st_mtime);\n    /*\n     * Content length casted to size_t because:\n     * 1) that's the maximum buffer size anyway\n     * 2) ESP8266 RTOS SDK newlib vprintf cannot contain a 64bit arg at non-last\n     *    position\n     * TODO(mkm): fix ESP8266 RTOS SDK\n     */\n    mg_send_response_line_s(nc, status_code, extra_headers);\n    mg_printf(nc,\n              \"Date: %s\\r\\n\"\n              \"Last-Modified: %s\\r\\n\"\n              \"Accept-Ranges: bytes\\r\\n\"\n              \"Content-Type: %.*s\\r\\n\"\n              \"Connection: %s\\r\\n\"\n              \"Content-Length: %\" SIZE_T_FMT\n              \"\\r\\n\"\n              \"%sEtag: %s\\r\\n\\r\\n\",\n              current_time, last_modified, (int) mime_type.len, mime_type.p,\n              (pd->file.keepalive ? \"keep-alive\" : \"close\"), (size_t) cl, range,\n              etag);\n\n    pd->file.cl = cl;\n    pd->file.type = DATA_FILE;\n    mg_http_transfer_file_data(nc);\n  }\n}\n\nstatic void mg_http_serve_file2(struct mg_connection *nc, const char *path,\n                                struct http_message *hm,\n                                struct mg_serve_http_opts *opts) {\n#if MG_ENABLE_HTTP_SSI\n  if (mg_match_prefix(opts->ssi_pattern, strlen(opts->ssi_pattern), path) > 0) {\n    mg_handle_ssi_request(nc, hm, path, opts);\n    return;\n  }\n#endif\n  mg_http_serve_file(nc, hm, path, mg_get_mime_type(path, \"text/plain\", opts),\n                     mg_mk_str(opts->extra_headers));\n}\n\n#endif\n\nint mg_url_decode(const char *src, int src_len, char *dst, int dst_len,\n                  int is_form_url_encoded) {\n  int i, j, a, b;\n#define HEXTOI(x) (isdigit(x) ? x - '0' : x - 'W')\n\n  for (i = j = 0; i < src_len && j < dst_len - 1; i++, j++) {\n    if (src[i] == '%') {\n      if (i < src_len - 2 && isxdigit(*(const unsigned char *) (src + i + 1)) &&\n          isxdigit(*(const unsigned char *) (src + i + 2))) {\n        a = tolower(*(const unsigned char *) (src + i + 1));\n        b = tolower(*(const unsigned char *) (src + i + 2));\n        dst[j] = (char) ((HEXTOI(a) << 4) | HEXTOI(b));\n        i += 2;\n      } else {\n        return -1;\n      }\n    } else if (is_form_url_encoded && src[i] == '+') {\n      dst[j] = ' ';\n    } else {\n      dst[j] = src[i];\n    }\n  }\n\n  dst[j] = '\\0'; /* Null-terminate the destination */\n\n  return i >= src_len ? j : -1;\n}\n\nint mg_get_http_var(const struct mg_str *buf, const char *name, char *dst,\n                    size_t dst_len) {\n  const char *p, *e, *s;\n  size_t name_len;\n  int len;\n\n  /*\n   * According to the documentation function returns negative\n   * value in case of error. For debug purposes it returns:\n   * -1 - src is wrong (NUUL)\n   * -2 - dst is wrong (NULL)\n   * -3 - failed to decode url or dst is to small\n   */\n  if (dst == NULL || dst_len == 0) {\n    len = -2;\n  } else if (buf->p == NULL || name == NULL || buf->len == 0) {\n    len = -1;\n    dst[0] = '\\0';\n  } else {\n    name_len = strlen(name);\n    e = buf->p + buf->len;\n    len = 0;\n    dst[0] = '\\0';\n\n    for (p = buf->p; p + name_len < e; p++) {\n      if ((p == buf->p || p[-1] == '&') && p[name_len] == '=' &&\n          !mg_ncasecmp(name, p, name_len)) {\n        p += name_len + 1;\n        s = (const char *) memchr(p, '&', (size_t)(e - p));\n        if (s == NULL) {\n          s = e;\n        }\n        len = mg_url_decode(p, (size_t)(s - p), dst, dst_len, 1);\n        /* -1 means: failed to decode or dst is too small */\n        if (len == -1) {\n          len = -3;\n        }\n        break;\n      }\n    }\n  }\n\n  return len;\n}\n\nvoid mg_send_http_chunk(struct mg_connection *nc, const char *buf, size_t len) {\n  char chunk_size[50];\n  int n;\n\n  n = snprintf(chunk_size, sizeof(chunk_size), \"%lX\\r\\n\", (unsigned long) len);\n  mg_send(nc, chunk_size, n);\n  mg_send(nc, buf, len);\n  mg_send(nc, \"\\r\\n\", 2);\n}\n\nvoid mg_printf_http_chunk(struct mg_connection *nc, const char *fmt, ...) {\n  char mem[MG_VPRINTF_BUFFER_SIZE], *buf = mem;\n  int len;\n  va_list ap;\n\n  va_start(ap, fmt);\n  len = mg_avprintf(&buf, sizeof(mem), fmt, ap);\n  va_end(ap);\n\n  if (len >= 0) {\n    mg_send_http_chunk(nc, buf, len);\n  }\n\n  /* LCOV_EXCL_START */\n  if (buf != mem && buf != NULL) {\n    MG_FREE(buf);\n  }\n  /* LCOV_EXCL_STOP */\n}\n\nvoid mg_printf_html_escape(struct mg_connection *nc, const char *fmt, ...) {\n  char mem[MG_VPRINTF_BUFFER_SIZE], *buf = mem;\n  int i, j, len;\n  va_list ap;\n\n  va_start(ap, fmt);\n  len = mg_avprintf(&buf, sizeof(mem), fmt, ap);\n  va_end(ap);\n\n  if (len >= 0) {\n    for (i = j = 0; i < len; i++) {\n      if (buf[i] == '<' || buf[i] == '>') {\n        mg_send(nc, buf + j, i - j);\n        mg_send(nc, buf[i] == '<' ? \"&lt;\" : \"&gt;\", 4);\n        j = i + 1;\n      }\n    }\n    mg_send(nc, buf + j, i - j);\n  }\n\n  /* LCOV_EXCL_START */\n  if (buf != mem && buf != NULL) {\n    MG_FREE(buf);\n  }\n  /* LCOV_EXCL_STOP */\n}\n\nint mg_http_parse_header(struct mg_str *hdr, const char *var_name, char *buf,\n                         size_t buf_size) {\n  int ch = ' ', ch1 = ',', len = 0, n = strlen(var_name);\n  const char *p, *end = hdr ? hdr->p + hdr->len : NULL, *s = NULL;\n\n  if (buf != NULL && buf_size > 0) buf[0] = '\\0';\n  if (hdr == NULL) return 0;\n\n  /* Find where variable starts */\n  for (s = hdr->p; s != NULL && s + n < end; s++) {\n    if ((s == hdr->p || s[-1] == ch || s[-1] == ch1 || s[-1] == ';') &&\n        s[n] == '=' && !strncmp(s, var_name, n))\n      break;\n  }\n\n  if (s != NULL && &s[n + 1] < end) {\n    s += n + 1;\n    if (*s == '\"' || *s == '\\'') {\n      ch = ch1 = *s++;\n    }\n    p = s;\n    while (p < end && p[0] != ch && p[0] != ch1 && len < (int) buf_size) {\n      if (ch != ' ' && p[0] == '\\\\' && p[1] == ch) p++;\n      buf[len++] = *p++;\n    }\n    if (len >= (int) buf_size || (ch != ' ' && *p != ch)) {\n      len = 0;\n    } else {\n      if (len > 0 && s[len - 1] == ',') len--;\n      if (len > 0 && s[len - 1] == ';') len--;\n      buf[len] = '\\0';\n    }\n  }\n\n  return len;\n}\n\nint mg_get_http_basic_auth(struct http_message *hm, char *user, size_t user_len,\n                           char *pass, size_t pass_len) {\n  struct mg_str *hdr = mg_get_http_header(hm, \"Authorization\");\n  if (hdr == NULL) return -1;\n  return mg_parse_http_basic_auth(hdr, user, user_len, pass, pass_len);\n}\n\nint mg_parse_http_basic_auth(struct mg_str *hdr, char *user, size_t user_len,\n                             char *pass, size_t pass_len) {\n  char *buf = NULL;\n  char fmt[64];\n  int res = 0;\n\n  if (mg_strncmp(*hdr, mg_mk_str(\"Basic \"), 6) != 0) return -1;\n\n  buf = (char *) MG_MALLOC(hdr->len);\n  cs_base64_decode((unsigned char *) hdr->p + 6, hdr->len, buf, NULL);\n\n  /* e.g. \"%123[^:]:%321[^\\n]\" */\n  snprintf(fmt, sizeof(fmt), \"%%%\" SIZE_T_FMT \"[^:]:%%%\" SIZE_T_FMT \"[^\\n]\",\n           user_len - 1, pass_len - 1);\n  if (sscanf(buf, fmt, user, pass) == 0) {\n    res = -1;\n  }\n\n  MG_FREE(buf);\n  return res;\n}\n\n#if MG_ENABLE_FILESYSTEM\nstatic int mg_is_file_hidden(const char *path,\n                             const struct mg_serve_http_opts *opts,\n                             int exclude_specials) {\n  const char *p1 = opts->per_directory_auth_file;\n  const char *p2 = opts->hidden_file_pattern;\n\n  /* Strip directory path from the file name */\n  const char *pdir = strrchr(path, DIRSEP);\n  if (pdir != NULL) {\n    path = pdir + 1;\n  }\n\n  return (exclude_specials && (!strcmp(path, \".\") || !strcmp(path, \"..\"))) ||\n         (p1 != NULL &&\n          mg_match_prefix(p1, strlen(p1), path) == (int) strlen(p1)) ||\n         (p2 != NULL && mg_match_prefix(p2, strlen(p2), path) > 0);\n}\n\n#if !MG_DISABLE_HTTP_DIGEST_AUTH\nstatic void mg_mkmd5resp(const char *method, size_t method_len, const char *uri,\n                         size_t uri_len, const char *ha1, size_t ha1_len,\n                         const char *nonce, size_t nonce_len, const char *nc,\n                         size_t nc_len, const char *cnonce, size_t cnonce_len,\n                         const char *qop, size_t qop_len, char *resp) {\n  static const char colon[] = \":\";\n  static const size_t one = 1;\n  char ha2[33];\n\n  cs_md5(ha2, method, method_len, colon, one, uri, uri_len, NULL);\n  cs_md5(resp, ha1, ha1_len, colon, one, nonce, nonce_len, colon, one, nc,\n         nc_len, colon, one, cnonce, cnonce_len, colon, one, qop, qop_len,\n         colon, one, ha2, sizeof(ha2) - 1, NULL);\n}\n\nint mg_http_create_digest_auth_header(char *buf, size_t buf_len,\n                                      const char *method, const char *uri,\n                                      const char *auth_domain, const char *user,\n                                      const char *passwd) {\n  static const char colon[] = \":\", qop[] = \"auth\";\n  static const size_t one = 1;\n  char ha1[33], resp[33], cnonce[40];\n\n  snprintf(cnonce, sizeof(cnonce), \"%x\", (unsigned int) mg_time());\n  cs_md5(ha1, user, (size_t) strlen(user), colon, one, auth_domain,\n         (size_t) strlen(auth_domain), colon, one, passwd,\n         (size_t) strlen(passwd), NULL);\n  mg_mkmd5resp(method, strlen(method), uri, strlen(uri), ha1, sizeof(ha1) - 1,\n               cnonce, strlen(cnonce), \"1\", one, cnonce, strlen(cnonce), qop,\n               sizeof(qop) - 1, resp);\n  return snprintf(buf, buf_len,\n                  \"Authorization: Digest username=\\\"%s\\\",\"\n                  \"realm=\\\"%s\\\",uri=\\\"%s\\\",qop=%s,nc=1,cnonce=%s,\"\n                  \"nonce=%s,response=%s\\r\\n\",\n                  user, auth_domain, uri, qop, cnonce, cnonce, resp);\n}\n\n/*\n * Check for authentication timeout.\n * Clients send time stamp encoded in nonce. Make sure it is not too old,\n * to prevent replay attacks.\n * Assumption: nonce is a hexadecimal number of seconds since 1970.\n */\nstatic int mg_check_nonce(const char *nonce) {\n  unsigned long now = (unsigned long) mg_time();\n  unsigned long val = (unsigned long) strtoul(nonce, NULL, 16);\n  return now < val || now - val < 3600;\n}\n\nint mg_http_check_digest_auth(struct http_message *hm, const char *auth_domain,\n                              FILE *fp) {\n  struct mg_str *hdr;\n  char buf[128], f_user[sizeof(buf)], f_ha1[sizeof(buf)], f_domain[sizeof(buf)];\n  char user[50], cnonce[33], response[40], uri[200], qop[20], nc[20], nonce[30];\n  char expected_response[33];\n\n  /* Parse \"Authorization:\" header, fail fast on parse error */\n  if (hm == NULL || fp == NULL ||\n      (hdr = mg_get_http_header(hm, \"Authorization\")) == NULL ||\n      mg_http_parse_header(hdr, \"username\", user, sizeof(user)) == 0 ||\n      mg_http_parse_header(hdr, \"cnonce\", cnonce, sizeof(cnonce)) == 0 ||\n      mg_http_parse_header(hdr, \"response\", response, sizeof(response)) == 0 ||\n      mg_http_parse_header(hdr, \"uri\", uri, sizeof(uri)) == 0 ||\n      mg_http_parse_header(hdr, \"qop\", qop, sizeof(qop)) == 0 ||\n      mg_http_parse_header(hdr, \"nc\", nc, sizeof(nc)) == 0 ||\n      mg_http_parse_header(hdr, \"nonce\", nonce, sizeof(nonce)) == 0 ||\n      mg_check_nonce(nonce) == 0) {\n    return 0;\n  }\n\n  /*\n   * Read passwords file line by line. If should have htdigest format,\n   * i.e. each line should be a colon-separated sequence:\n   * USER_NAME:DOMAIN_NAME:HA1_HASH_OF_USER_DOMAIN_AND_PASSWORD\n   */\n  while (fgets(buf, sizeof(buf), fp) != NULL) {\n    if (sscanf(buf, \"%[^:]:%[^:]:%s\", f_user, f_domain, f_ha1) == 3 &&\n        strcmp(user, f_user) == 0 &&\n        /* NOTE(lsm): due to a bug in MSIE, we do not compare URIs */\n        strcmp(auth_domain, f_domain) == 0) {\n      /* User and domain matched, check the password */\n      mg_mkmd5resp(\n          hm->method.p, hm->method.len, hm->uri.p,\n          hm->uri.len + (hm->query_string.len ? hm->query_string.len + 1 : 0),\n          f_ha1, strlen(f_ha1), nonce, strlen(nonce), nc, strlen(nc), cnonce,\n          strlen(cnonce), qop, strlen(qop), expected_response);\n      return mg_casecmp(response, expected_response) == 0;\n    }\n  }\n\n  /* None of the entries in the passwords file matched - return failure */\n  return 0;\n}\n\nstatic int mg_is_authorized(struct http_message *hm, const char *path,\n                            int is_directory, const char *domain,\n                            const char *passwords_file,\n                            int is_global_pass_file) {\n  char buf[MG_MAX_PATH];\n  const char *p;\n  FILE *fp;\n  int authorized = 1;\n\n  if (domain != NULL && passwords_file != NULL) {\n    if (is_global_pass_file) {\n      fp = mg_fopen(passwords_file, \"r\");\n    } else if (is_directory) {\n      snprintf(buf, sizeof(buf), \"%s%c%s\", path, DIRSEP, passwords_file);\n      fp = mg_fopen(buf, \"r\");\n    } else {\n      p = strrchr(path, DIRSEP);\n      if (p == NULL) p = path;\n      snprintf(buf, sizeof(buf), \"%.*s%c%s\", (int) (p - path), path, DIRSEP,\n               passwords_file);\n      fp = mg_fopen(buf, \"r\");\n    }\n\n    if (fp != NULL) {\n      authorized = mg_http_check_digest_auth(hm, domain, fp);\n      fclose(fp);\n    }\n  }\n\n  LOG(LL_DEBUG, (\"%s '%s' %d %d\", path, passwords_file ? passwords_file : \"\",\n                 is_global_pass_file, authorized));\n  return authorized;\n}\n#else\nstatic int mg_is_authorized(struct http_message *hm, const char *path,\n                            int is_directory, const char *domain,\n                            const char *passwords_file,\n                            int is_global_pass_file) {\n  (void) hm;\n  (void) path;\n  (void) is_directory;\n  (void) domain;\n  (void) passwords_file;\n  (void) is_global_pass_file;\n  return 1;\n}\n#endif\n\n#if MG_ENABLE_DIRECTORY_LISTING\nstatic size_t mg_url_encode(const char *src, size_t s_len, char *dst,\n                            size_t dst_len) {\n  static const char *dont_escape = \"._-$,;~()/\";\n  static const char *hex = \"0123456789abcdef\";\n  size_t i = 0, j = 0;\n\n  for (i = j = 0; dst_len > 0 && i < s_len && j + 2 < dst_len - 1; i++, j++) {\n    if (isalnum(*(const unsigned char *) (src + i)) ||\n        strchr(dont_escape, *(const unsigned char *) (src + i)) != NULL) {\n      dst[j] = src[i];\n    } else if (j + 3 < dst_len) {\n      dst[j] = '%';\n      dst[j + 1] = hex[(*(const unsigned char *) (src + i)) >> 4];\n      dst[j + 2] = hex[(*(const unsigned char *) (src + i)) & 0xf];\n      j += 2;\n    }\n  }\n\n  dst[j] = '\\0';\n  return j;\n}\n\nstatic void mg_escape(const char *src, char *dst, size_t dst_len) {\n  size_t n = 0;\n  while (*src != '\\0' && n + 5 < dst_len) {\n    unsigned char ch = *(unsigned char *) src++;\n    if (ch == '<') {\n      n += snprintf(dst + n, dst_len - n, \"%s\", \"&lt;\");\n    } else {\n      dst[n++] = ch;\n    }\n  }\n  dst[n] = '\\0';\n}\n\nstatic void mg_print_dir_entry(struct mg_connection *nc, const char *file_name,\n                               cs_stat_t *stp) {\n  char size[64], mod[64], href[MAX_PATH_SIZE * 3], path[MAX_PATH_SIZE];\n  int64_t fsize = stp->st_size;\n  int is_dir = S_ISDIR(stp->st_mode);\n  const char *slash = is_dir ? \"/\" : \"\";\n\n  if (is_dir) {\n    snprintf(size, sizeof(size), \"%s\", \"[DIRECTORY]\");\n  } else {\n    /*\n     * We use (double) cast below because MSVC 6 compiler cannot\n     * convert unsigned __int64 to double.\n     */\n    if (fsize < 1024) {\n      snprintf(size, sizeof(size), \"%d\", (int) fsize);\n    } else if (fsize < 0x100000) {\n      snprintf(size, sizeof(size), \"%.1fk\", (double) fsize / 1024.0);\n    } else if (fsize < 0x40000000) {\n      snprintf(size, sizeof(size), \"%.1fM\", (double) fsize / 1048576);\n    } else {\n      snprintf(size, sizeof(size), \"%.1fG\", (double) fsize / 1073741824);\n    }\n  }\n  strftime(mod, sizeof(mod), \"%d-%b-%Y %H:%M\", localtime(&stp->st_mtime));\n  mg_escape(file_name, path, sizeof(path));\n  mg_url_encode(file_name, strlen(file_name), href, sizeof(href));\n  mg_printf_http_chunk(nc,\n                       \"<tr><td><a href=\\\"%s%s\\\">%s%s</a></td>\"\n                       \"<td>%s</td><td name=%\" INT64_FMT \">%s</td></tr>\\n\",\n                       href, slash, path, slash, mod, is_dir ? -1 : fsize,\n                       size);\n}\n\nstatic void mg_scan_directory(struct mg_connection *nc, const char *dir,\n                              const struct mg_serve_http_opts *opts,\n                              void (*func)(struct mg_connection *, const char *,\n                                           cs_stat_t *)) {\n  char path[MAX_PATH_SIZE];\n  cs_stat_t st;\n  struct dirent *dp;\n  DIR *dirp;\n\n  LOG(LL_DEBUG, (\"%p [%s]\", nc, dir));\n  if ((dirp = (opendir(dir))) != NULL) {\n    while ((dp = readdir(dirp)) != NULL) {\n      /* Do not show current dir and hidden files */\n      if (mg_is_file_hidden((const char *) dp->d_name, opts, 1)) {\n        continue;\n      }\n      snprintf(path, sizeof(path), \"%s/%s\", dir, dp->d_name);\n      if (mg_stat(path, &st) == 0) {\n        func(nc, (const char *) dp->d_name, &st);\n      }\n    }\n    closedir(dirp);\n  } else {\n    LOG(LL_DEBUG, (\"%p opendir(%s) -> %d\", nc, dir, mg_get_errno()));\n  }\n}\n\nstatic void mg_send_directory_listing(struct mg_connection *nc, const char *dir,\n                                      struct http_message *hm,\n                                      struct mg_serve_http_opts *opts) {\n  static const char *sort_js_code =\n      \"<script>function srt(tb, sc, so, d) {\"\n      \"var tr = Array.prototype.slice.call(tb.rows, 0),\"\n      \"tr = tr.sort(function (a, b) { var c1 = a.cells[sc], c2 = b.cells[sc],\"\n      \"n1 = c1.getAttribute('name'), n2 = c2.getAttribute('name'), \"\n      \"t1 = a.cells[2].getAttribute('name'), \"\n      \"t2 = b.cells[2].getAttribute('name'); \"\n      \"return so * (t1 < 0 && t2 >= 0 ? -1 : t2 < 0 && t1 >= 0 ? 1 : \"\n      \"n1 ? parseInt(n2) - parseInt(n1) : \"\n      \"c1.textContent.trim().localeCompare(c2.textContent.trim())); });\";\n  static const char *sort_js_code2 =\n      \"for (var i = 0; i < tr.length; i++) tb.appendChild(tr[i]); \"\n      \"if (!d) window.location.hash = ('sc=' + sc + '&so=' + so); \"\n      \"};\"\n      \"window.onload = function() {\"\n      \"var tb = document.getElementById('tb');\"\n      \"var m = /sc=([012]).so=(1|-1)/.exec(window.location.hash) || [0, 2, 1];\"\n      \"var sc = m[1], so = m[2]; document.onclick = function(ev) { \"\n      \"var c = ev.target.rel; if (c) {if (c == sc) so *= -1; srt(tb, c, so); \"\n      \"sc = c; ev.preventDefault();}};\"\n      \"srt(tb, sc, so, true);\"\n      \"}\"\n      \"</script>\";\n\n  mg_send_response_line(nc, 200, opts->extra_headers);\n  mg_printf(nc, \"%s: %s\\r\\n%s: %s\\r\\n\\r\\n\", \"Transfer-Encoding\", \"chunked\",\n            \"Content-Type\", \"text/html; charset=utf-8\");\n\n  mg_printf_http_chunk(\n      nc,\n      \"<html><head><title>Index of %.*s</title>%s%s\"\n      \"<style>th,td {text-align: left; padding-right: 1em; \"\n      \"font-family: monospace; }</style></head>\\n\"\n      \"<body><h1>Index of %.*s</h1>\\n<table cellpadding=0><thead>\"\n      \"<tr><th><a href=# rel=0>Name</a></th><th>\"\n      \"<a href=# rel=1>Modified</a</th>\"\n      \"<th><a href=# rel=2>Size</a></th></tr>\"\n      \"<tr><td colspan=3><hr></td></tr>\\n\"\n      \"</thead>\\n\"\n      \"<tbody id=tb>\",\n      (int) hm->uri.len, hm->uri.p, sort_js_code, sort_js_code2,\n      (int) hm->uri.len, hm->uri.p);\n  mg_scan_directory(nc, dir, opts, mg_print_dir_entry);\n  mg_printf_http_chunk(nc,\n                       \"</tbody><tr><td colspan=3><hr></td></tr>\\n\"\n                       \"</table>\\n\"\n                       \"<address>%s</address>\\n\"\n                       \"</body></html>\",\n                       mg_version_header);\n  mg_send_http_chunk(nc, \"\", 0);\n  /* TODO(rojer): Remove when cesanta/dev/issues/197 is fixed. */\n  nc->flags |= MG_F_SEND_AND_CLOSE;\n}\n#endif /* MG_ENABLE_DIRECTORY_LISTING */\n\n/*\n * Given a directory path, find one of the files specified in the\n * comma-separated list of index files `list`.\n * First found index file wins. If an index file is found, then gets\n * appended to the `path`, stat-ed, and result of `stat()` passed to `stp`.\n * If index file is not found, then `path` and `stp` remain unchanged.\n */\nMG_INTERNAL void mg_find_index_file(const char *path, const char *list,\n                                    char **index_file, cs_stat_t *stp) {\n  struct mg_str vec;\n  size_t path_len = strlen(path);\n  int found = 0;\n  *index_file = NULL;\n\n  /* Traverse index files list. For each entry, append it to the given */\n  /* path and see if the file exists. If it exists, break the loop */\n  while ((list = mg_next_comma_list_entry(list, &vec, NULL)) != NULL) {\n    cs_stat_t st;\n    size_t len = path_len + 1 + vec.len + 1;\n    *index_file = (char *) MG_REALLOC(*index_file, len);\n    if (*index_file == NULL) break;\n    snprintf(*index_file, len, \"%s%c%.*s\", path, DIRSEP, (int) vec.len, vec.p);\n\n    /* Does it exist? Is it a file? */\n    if (mg_stat(*index_file, &st) == 0 && S_ISREG(st.st_mode)) {\n      /* Yes it does, break the loop */\n      *stp = st;\n      found = 1;\n      break;\n    }\n  }\n  if (!found) {\n    MG_FREE(*index_file);\n    *index_file = NULL;\n  }\n  LOG(LL_DEBUG, (\"[%s] [%s]\", path, (*index_file ? *index_file : \"\")));\n}\n\n#if MG_ENABLE_HTTP_URL_REWRITES\nstatic int mg_http_send_port_based_redirect(\n    struct mg_connection *c, struct http_message *hm,\n    const struct mg_serve_http_opts *opts) {\n  const char *rewrites = opts->url_rewrites;\n  struct mg_str a, b;\n  char local_port[20] = {'%'};\n\n  mg_conn_addr_to_str(c, local_port + 1, sizeof(local_port) - 1,\n                      MG_SOCK_STRINGIFY_PORT);\n\n  while ((rewrites = mg_next_comma_list_entry(rewrites, &a, &b)) != NULL) {\n    if (mg_vcmp(&a, local_port) == 0) {\n      mg_send_response_line(c, 301, NULL);\n      mg_printf(c, \"Content-Length: 0\\r\\nLocation: %.*s%.*s\\r\\n\\r\\n\",\n                (int) b.len, b.p, (int) (hm->proto.p - hm->uri.p - 1),\n                hm->uri.p);\n      return 1;\n    }\n  }\n\n  return 0;\n}\n\nstatic void mg_reverse_proxy_handler(struct mg_connection *nc, int ev,\n                                     void *ev_data MG_UD_ARG(void *user_data)) {\n  struct http_message *hm = (struct http_message *) ev_data;\n  struct mg_http_proto_data *pd = mg_http_get_proto_data(nc);\n\n  if (pd == NULL || pd->reverse_proxy_data.linked_conn == NULL) {\n    DBG((\"%p: upstream closed\", nc));\n    return;\n  }\n\n  switch (ev) {\n    case MG_EV_CONNECT:\n      if (*(int *) ev_data != 0) {\n        mg_http_send_error(pd->reverse_proxy_data.linked_conn, 502, NULL);\n      }\n      break;\n    /* TODO(mkm): handle streaming */\n    case MG_EV_HTTP_REPLY:\n      mg_send(pd->reverse_proxy_data.linked_conn, hm->message.p,\n              hm->message.len);\n      pd->reverse_proxy_data.linked_conn->flags |= MG_F_SEND_AND_CLOSE;\n      nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n      break;\n    case MG_EV_CLOSE:\n      pd->reverse_proxy_data.linked_conn->flags |= MG_F_SEND_AND_CLOSE;\n      break;\n  }\n\n#if MG_ENABLE_CALLBACK_USERDATA\n  (void) user_data;\n#endif\n}\n\nvoid mg_http_reverse_proxy(struct mg_connection *nc,\n                           const struct http_message *hm, struct mg_str mount,\n                           struct mg_str upstream) {\n  struct mg_connection *be;\n  char burl[256], *purl = burl;\n  char *addr = NULL;\n  const char *path = NULL;\n  int i;\n  const char *error;\n  struct mg_connect_opts opts;\n  memset(&opts, 0, sizeof(opts));\n  opts.error_string = &error;\n\n  mg_asprintf(&purl, sizeof(burl), \"%.*s%.*s\", (int) upstream.len, upstream.p,\n              (int) (hm->uri.len - mount.len), hm->uri.p + mount.len);\n\n  be = mg_connect_http_base(nc->mgr, MG_CB(mg_reverse_proxy_handler, NULL),\n                            opts, \"http://\", \"https://\", purl, &path,\n                            NULL /* user */, NULL /* pass */, &addr);\n  LOG(LL_DEBUG, (\"Proxying %.*s to %s (rule: %.*s)\", (int) hm->uri.len,\n                 hm->uri.p, purl, (int) mount.len, mount.p));\n\n  if (be == NULL) {\n    LOG(LL_ERROR, (\"Error connecting to %s: %s\", purl, error));\n    mg_http_send_error(nc, 502, NULL);\n    goto cleanup;\n  }\n\n  /* link connections to each other, they must live and die together */\n  mg_http_get_proto_data(be)->reverse_proxy_data.linked_conn = nc;\n  mg_http_get_proto_data(nc)->reverse_proxy_data.linked_conn = be;\n\n  /* send request upstream */\n  mg_printf(be, \"%.*s %s HTTP/1.1\\r\\n\", (int) hm->method.len, hm->method.p,\n            path);\n\n  mg_printf(be, \"Host: %s\\r\\n\", addr);\n  for (i = 0; i < MG_MAX_HTTP_HEADERS && hm->header_names[i].len > 0; i++) {\n    struct mg_str hn = hm->header_names[i];\n    struct mg_str hv = hm->header_values[i];\n\n    /* we rewrite the host header */\n    if (mg_vcasecmp(&hn, \"Host\") == 0) continue;\n    /*\n     * Don't pass chunked transfer encoding to the client because hm->body is\n     * already dechunked when we arrive here.\n     */\n    if (mg_vcasecmp(&hn, \"Transfer-encoding\") == 0 &&\n        mg_vcasecmp(&hv, \"chunked\") == 0) {\n      mg_printf(be, \"Content-Length: %\" SIZE_T_FMT \"\\r\\n\", hm->body.len);\n      continue;\n    }\n    /* We don't support proxying Expect: 100-continue. */\n    if (mg_vcasecmp(&hn, \"Expect\") == 0 &&\n        mg_vcasecmp(&hv, \"100-continue\") == 0) {\n      continue;\n    }\n\n    mg_printf(be, \"%.*s: %.*s\\r\\n\", (int) hn.len, hn.p, (int) hv.len, hv.p);\n  }\n\n  mg_send(be, \"\\r\\n\", 2);\n  mg_send(be, hm->body.p, hm->body.len);\n\ncleanup:\n  if (purl != burl) MG_FREE(purl);\n}\n\nstatic int mg_http_handle_forwarding(struct mg_connection *nc,\n                                     struct http_message *hm,\n                                     const struct mg_serve_http_opts *opts) {\n  const char *rewrites = opts->url_rewrites;\n  struct mg_str a, b;\n  struct mg_str p1 = MG_MK_STR(\"http://\"), p2 = MG_MK_STR(\"https://\");\n\n  while ((rewrites = mg_next_comma_list_entry(rewrites, &a, &b)) != NULL) {\n    if (mg_strncmp(a, hm->uri, a.len) == 0) {\n      if (mg_strncmp(b, p1, p1.len) == 0 || mg_strncmp(b, p2, p2.len) == 0) {\n        mg_http_reverse_proxy(nc, hm, a, b);\n        return 1;\n      }\n    }\n  }\n\n  return 0;\n}\n#endif\n\nMG_INTERNAL int mg_uri_to_local_path(struct http_message *hm,\n                                     const struct mg_serve_http_opts *opts,\n                                     char **local_path,\n                                     struct mg_str *remainder) {\n  int ok = 1;\n  const char *cp = hm->uri.p, *cp_end = hm->uri.p + hm->uri.len;\n  struct mg_str root = {NULL, 0};\n  const char *file_uri_start = cp;\n  *local_path = NULL;\n  remainder->p = NULL;\n  remainder->len = 0;\n\n  { /* 1. Determine which root to use. */\n\n#if MG_ENABLE_HTTP_URL_REWRITES\n    const char *rewrites = opts->url_rewrites;\n#else\n    const char *rewrites = \"\";\n#endif\n    struct mg_str *hh = mg_get_http_header(hm, \"Host\");\n    struct mg_str a, b;\n    /* Check rewrites first. */\n    while ((rewrites = mg_next_comma_list_entry(rewrites, &a, &b)) != NULL) {\n      if (a.len > 1 && a.p[0] == '@') {\n        /* Host rewrite. */\n        if (hh != NULL && hh->len == a.len - 1 &&\n            mg_ncasecmp(a.p + 1, hh->p, a.len - 1) == 0) {\n          root = b;\n          break;\n        }\n      } else {\n        /* Regular rewrite, URI=directory */\n        int match_len = mg_match_prefix_n(a, hm->uri);\n        if (match_len > 0) {\n          file_uri_start = hm->uri.p + match_len;\n          if (*file_uri_start == '/' || file_uri_start == cp_end) {\n            /* Match ended at component boundary, ok. */\n          } else if (*(file_uri_start - 1) == '/') {\n            /* Pattern ends with '/', backtrack. */\n            file_uri_start--;\n          } else {\n            /* No match: must fall on the component boundary. */\n            continue;\n          }\n          root = b;\n          break;\n        }\n      }\n    }\n    /* If no rewrite rules matched, use DAV or regular document root. */\n    if (root.p == NULL) {\n#if MG_ENABLE_HTTP_WEBDAV\n      if (opts->dav_document_root != NULL && mg_is_dav_request(&hm->method)) {\n        root.p = opts->dav_document_root;\n        root.len = strlen(opts->dav_document_root);\n      } else\n#endif\n      {\n        root.p = opts->document_root;\n        root.len = strlen(opts->document_root);\n      }\n    }\n    assert(root.p != NULL && root.len > 0);\n  }\n\n  { /* 2. Find where in the canonical URI path the local path ends. */\n    const char *u = file_uri_start + 1;\n    char *lp = (char *) MG_MALLOC(root.len + hm->uri.len + 1);\n    char *lp_end = lp + root.len + hm->uri.len + 1;\n    char *p = lp, *ps;\n    int exists = 1;\n    if (lp == NULL) {\n      ok = 0;\n      goto out;\n    }\n    memcpy(p, root.p, root.len);\n    p += root.len;\n    if (*(p - 1) == DIRSEP) p--;\n    *p = '\\0';\n    ps = p;\n\n    /* Chop off URI path components one by one and build local path. */\n    while (u <= cp_end) {\n      const char *next = u;\n      struct mg_str component;\n      if (exists) {\n        cs_stat_t st;\n        exists = (mg_stat(lp, &st) == 0);\n        if (exists && S_ISREG(st.st_mode)) {\n          /* We found the terminal, the rest of the URI (if any) is path_info.\n           */\n          if (*(u - 1) == '/') u--;\n          break;\n        }\n      }\n      if (u >= cp_end) break;\n      parse_uri_component((const char **) &next, cp_end, '/', &component);\n      if (component.len > 0) {\n        int len;\n        memmove(p + 1, component.p, component.len);\n        len = mg_url_decode(p + 1, component.len, p + 1, lp_end - p - 1, 0);\n        if (len <= 0) {\n          ok = 0;\n          break;\n        }\n        component.p = p + 1;\n        component.len = len;\n        if (mg_vcmp(&component, \".\") == 0) {\n          /* Yum. */\n        } else if (mg_vcmp(&component, \"..\") == 0) {\n          while (p > ps && *p != DIRSEP) p--;\n          *p = '\\0';\n        } else {\n          size_t i;\n#ifdef _WIN32\n          /* On Windows, make sure it's valid Unicode (no funny stuff). */\n          wchar_t buf[MG_MAX_PATH * 2];\n          if (to_wchar(component.p, buf, MG_MAX_PATH) == 0) {\n            DBG((\"[%.*s] smells funny\", (int) component.len, component.p));\n            ok = 0;\n            break;\n          }\n#endif\n          *p++ = DIRSEP;\n          /* No NULs and DIRSEPs in the component (percent-encoded). */\n          for (i = 0; i < component.len; i++, p++) {\n            if (*p == '\\0' || *p == DIRSEP\n#ifdef _WIN32\n                /* On Windows, \"/\" is also accepted, so check for that too. */\n                ||\n                *p == '/'\n#endif\n                ) {\n              ok = 0;\n              break;\n            }\n          }\n        }\n      }\n      u = next;\n    }\n    if (ok) {\n      *local_path = lp;\n      if (u > cp_end) u = cp_end;\n      remainder->p = u;\n      remainder->len = cp_end - u;\n    } else {\n      MG_FREE(lp);\n    }\n  }\n\nout:\n  LOG(LL_DEBUG,\n      (\"'%.*s' -> '%s' + '%.*s'\", (int) hm->uri.len, hm->uri.p,\n       *local_path ? *local_path : \"\", (int) remainder->len, remainder->p));\n  return ok;\n}\n\nstatic int mg_get_month_index(const char *s) {\n  static const char *month_names[] = {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n                                      \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"};\n  size_t i;\n\n  for (i = 0; i < ARRAY_SIZE(month_names); i++)\n    if (!strcmp(s, month_names[i])) return (int) i;\n\n  return -1;\n}\n\nstatic int mg_num_leap_years(int year) {\n  return year / 4 - year / 100 + year / 400;\n}\n\n/* Parse UTC date-time string, and return the corresponding time_t value. */\nMG_INTERNAL time_t mg_parse_date_string(const char *datetime) {\n  static const unsigned short days_before_month[] = {\n      0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};\n  char month_str[32];\n  int second, minute, hour, day, month, year, leap_days, days;\n  time_t result = (time_t) 0;\n\n  if (((sscanf(datetime, \"%d/%3s/%d %d:%d:%d\", &day, month_str, &year, &hour,\n               &minute, &second) == 6) ||\n       (sscanf(datetime, \"%d %3s %d %d:%d:%d\", &day, month_str, &year, &hour,\n               &minute, &second) == 6) ||\n       (sscanf(datetime, \"%*3s, %d %3s %d %d:%d:%d\", &day, month_str, &year,\n               &hour, &minute, &second) == 6) ||\n       (sscanf(datetime, \"%d-%3s-%d %d:%d:%d\", &day, month_str, &year, &hour,\n               &minute, &second) == 6)) &&\n      year > 1970 && (month = mg_get_month_index(month_str)) != -1) {\n    leap_days = mg_num_leap_years(year) - mg_num_leap_years(1970);\n    year -= 1970;\n    days = year * 365 + days_before_month[month] + (day - 1) + leap_days;\n    result = days * 24 * 3600 + hour * 3600 + minute * 60 + second;\n  }\n\n  return result;\n}\n\nMG_INTERNAL int mg_is_not_modified(struct http_message *hm, cs_stat_t *st) {\n  struct mg_str *hdr;\n  if ((hdr = mg_get_http_header(hm, \"If-None-Match\")) != NULL) {\n    char etag[64];\n    mg_http_construct_etag(etag, sizeof(etag), st);\n    return mg_vcasecmp(hdr, etag) == 0;\n  } else if ((hdr = mg_get_http_header(hm, \"If-Modified-Since\")) != NULL) {\n    return st->st_mtime <= mg_parse_date_string(hdr->p);\n  } else {\n    return 0;\n  }\n}\n\nstatic void mg_http_send_digest_auth_request(struct mg_connection *c,\n                                             const char *domain) {\n  mg_printf(c,\n            \"HTTP/1.1 401 Unauthorized\\r\\n\"\n            \"WWW-Authenticate: Digest qop=\\\"auth\\\", \"\n            \"realm=\\\"%s\\\", nonce=\\\"%lu\\\"\\r\\n\"\n            \"Content-Length: 0\\r\\n\\r\\n\",\n            domain, (unsigned long) mg_time());\n}\n\nstatic void mg_http_send_options(struct mg_connection *nc) {\n  mg_printf(nc, \"%s\",\n            \"HTTP/1.1 200 OK\\r\\nAllow: GET, POST, HEAD, CONNECT, OPTIONS\"\n#if MG_ENABLE_HTTP_WEBDAV\n            \", MKCOL, PUT, DELETE, PROPFIND, MOVE\\r\\nDAV: 1,2\"\n#endif\n            \"\\r\\n\\r\\n\");\n  nc->flags |= MG_F_SEND_AND_CLOSE;\n}\n\nstatic int mg_is_creation_request(const struct http_message *hm) {\n  return mg_vcmp(&hm->method, \"MKCOL\") == 0 || mg_vcmp(&hm->method, \"PUT\") == 0;\n}\n\nMG_INTERNAL void mg_send_http_file(struct mg_connection *nc, char *path,\n                                   const struct mg_str *path_info,\n                                   struct http_message *hm,\n                                   struct mg_serve_http_opts *opts) {\n  int exists, is_directory, is_cgi;\n#if MG_ENABLE_HTTP_WEBDAV\n  int is_dav = mg_is_dav_request(&hm->method);\n#else\n  int is_dav = 0;\n#endif\n  char *index_file = NULL;\n  cs_stat_t st;\n\n  exists = (mg_stat(path, &st) == 0);\n  is_directory = exists && S_ISDIR(st.st_mode);\n\n  if (is_directory)\n    mg_find_index_file(path, opts->index_files, &index_file, &st);\n\n  is_cgi =\n      (mg_match_prefix(opts->cgi_file_pattern, strlen(opts->cgi_file_pattern),\n                       index_file ? index_file : path) > 0);\n\n  LOG(LL_DEBUG,\n      (\"%p %.*s [%s] exists=%d is_dir=%d is_dav=%d is_cgi=%d index=%s\", nc,\n       (int) hm->method.len, hm->method.p, path, exists, is_directory, is_dav,\n       is_cgi, index_file ? index_file : \"\"));\n\n  if (is_directory && hm->uri.p[hm->uri.len - 1] != '/' && !is_dav) {\n    mg_printf(nc,\n              \"HTTP/1.1 301 Moved\\r\\nLocation: %.*s/\\r\\n\"\n              \"Content-Length: 0\\r\\n\\r\\n\",\n              (int) hm->uri.len, hm->uri.p);\n    MG_FREE(index_file);\n    return;\n  }\n\n  /* If we have path_info, the only way to handle it is CGI. */\n  if (path_info->len > 0 && !is_cgi) {\n    mg_http_send_error(nc, 501, NULL);\n    MG_FREE(index_file);\n    return;\n  }\n\n  if (is_dav && opts->dav_document_root == NULL) {\n    mg_http_send_error(nc, 501, NULL);\n  } else if (!mg_is_authorized(hm, path, is_directory, opts->auth_domain,\n                               opts->global_auth_file, 1) ||\n             !mg_is_authorized(hm, path, is_directory, opts->auth_domain,\n                               opts->per_directory_auth_file, 0)) {\n    mg_http_send_digest_auth_request(nc, opts->auth_domain);\n  } else if (is_cgi) {\n#if MG_ENABLE_HTTP_CGI\n    mg_handle_cgi(nc, index_file ? index_file : path, path_info, hm, opts);\n#else\n    mg_http_send_error(nc, 501, NULL);\n#endif /* MG_ENABLE_HTTP_CGI */\n  } else if ((!exists ||\n              mg_is_file_hidden(path, opts, 0 /* specials are ok */)) &&\n             !mg_is_creation_request(hm)) {\n    mg_http_send_error(nc, 404, NULL);\n#if MG_ENABLE_HTTP_WEBDAV\n  } else if (!mg_vcmp(&hm->method, \"PROPFIND\")) {\n    mg_handle_propfind(nc, path, &st, hm, opts);\n#if !MG_DISABLE_DAV_AUTH\n  } else if (is_dav &&\n             (opts->dav_auth_file == NULL ||\n              (strcmp(opts->dav_auth_file, \"-\") != 0 &&\n               !mg_is_authorized(hm, path, is_directory, opts->auth_domain,\n                                 opts->dav_auth_file, 1)))) {\n    mg_http_send_digest_auth_request(nc, opts->auth_domain);\n#endif\n  } else if (!mg_vcmp(&hm->method, \"MKCOL\")) {\n    mg_handle_mkcol(nc, path, hm);\n  } else if (!mg_vcmp(&hm->method, \"DELETE\")) {\n    mg_handle_delete(nc, opts, path);\n  } else if (!mg_vcmp(&hm->method, \"PUT\")) {\n    mg_handle_put(nc, path, hm);\n  } else if (!mg_vcmp(&hm->method, \"MOVE\")) {\n    mg_handle_move(nc, opts, path, hm);\n#if MG_ENABLE_FAKE_DAVLOCK\n  } else if (!mg_vcmp(&hm->method, \"LOCK\")) {\n    mg_handle_lock(nc, path);\n#endif\n#endif /* MG_ENABLE_HTTP_WEBDAV */\n  } else if (!mg_vcmp(&hm->method, \"OPTIONS\")) {\n    mg_http_send_options(nc);\n  } else if (is_directory && index_file == NULL) {\n#if MG_ENABLE_DIRECTORY_LISTING\n    if (strcmp(opts->enable_directory_listing, \"yes\") == 0) {\n      mg_send_directory_listing(nc, path, hm, opts);\n    } else {\n      mg_http_send_error(nc, 403, NULL);\n    }\n#else\n    mg_http_send_error(nc, 501, NULL);\n#endif\n  } else if (mg_is_not_modified(hm, &st)) {\n    mg_http_send_error(nc, 304, \"Not Modified\");\n  } else {\n    mg_http_serve_file2(nc, index_file ? index_file : path, hm, opts);\n  }\n  MG_FREE(index_file);\n}\n\nvoid mg_serve_http(struct mg_connection *nc, struct http_message *hm,\n                   struct mg_serve_http_opts opts) {\n  char *path = NULL;\n  struct mg_str *hdr, path_info;\n  uint32_t remote_ip = ntohl(*(uint32_t *) &nc->sa.sin.sin_addr);\n\n  if (mg_check_ip_acl(opts.ip_acl, remote_ip) != 1) {\n    /* Not allowed to connect */\n    mg_http_send_error(nc, 403, NULL);\n    nc->flags |= MG_F_SEND_AND_CLOSE;\n    return;\n  }\n\n#if MG_ENABLE_HTTP_URL_REWRITES\n  if (mg_http_handle_forwarding(nc, hm, &opts)) {\n    return;\n  }\n\n  if (mg_http_send_port_based_redirect(nc, hm, &opts)) {\n    return;\n  }\n#endif\n\n  if (opts.document_root == NULL) {\n    opts.document_root = \".\";\n  }\n  if (opts.per_directory_auth_file == NULL) {\n    opts.per_directory_auth_file = \".htpasswd\";\n  }\n  if (opts.enable_directory_listing == NULL) {\n    opts.enable_directory_listing = \"yes\";\n  }\n  if (opts.cgi_file_pattern == NULL) {\n    opts.cgi_file_pattern = \"**.cgi$|**.php$\";\n  }\n  if (opts.ssi_pattern == NULL) {\n    opts.ssi_pattern = \"**.shtml$|**.shtm$\";\n  }\n  if (opts.index_files == NULL) {\n    opts.index_files = \"index.html,index.htm,index.shtml,index.cgi,index.php\";\n  }\n  /* Normalize path - resolve \".\" and \"..\" (in-place). */\n  if (!mg_normalize_uri_path(&hm->uri, &hm->uri)) {\n    mg_http_send_error(nc, 400, NULL);\n    return;\n  }\n  if (mg_uri_to_local_path(hm, &opts, &path, &path_info) == 0) {\n    mg_http_send_error(nc, 404, NULL);\n    return;\n  }\n  mg_send_http_file(nc, path, &path_info, hm, &opts);\n\n  MG_FREE(path);\n  path = NULL;\n\n  /* Close connection for non-keep-alive requests */\n  if (mg_vcmp(&hm->proto, \"HTTP/1.1\") != 0 ||\n      ((hdr = mg_get_http_header(hm, \"Connection\")) != NULL &&\n       mg_vcmp(hdr, \"keep-alive\") != 0)) {\n#if 0\n    nc->flags |= MG_F_SEND_AND_CLOSE;\n#endif\n  }\n}\n\n#if MG_ENABLE_HTTP_STREAMING_MULTIPART\nvoid mg_file_upload_handler(struct mg_connection *nc, int ev, void *ev_data,\n                            mg_fu_fname_fn local_name_fn\n                                MG_UD_ARG(void *user_data)) {\n  switch (ev) {\n    case MG_EV_HTTP_PART_BEGIN: {\n      struct mg_http_multipart_part *mp =\n          (struct mg_http_multipart_part *) ev_data;\n      struct file_upload_state *fus =\n          (struct file_upload_state *) MG_CALLOC(1, sizeof(*fus));\n      struct mg_str lfn = local_name_fn(nc, mg_mk_str(mp->file_name));\n      mp->user_data = NULL;\n      if (lfn.p == NULL || lfn.len == 0) {\n        LOG(LL_ERROR, (\"%p Not allowed to upload %s\", nc, mp->file_name));\n        mg_printf(nc,\n                  \"HTTP/1.1 403 Not Allowed\\r\\n\"\n                  \"Content-Type: text/plain\\r\\n\"\n                  \"Connection: close\\r\\n\\r\\n\"\n                  \"Not allowed to upload %s\\r\\n\",\n                  mp->file_name);\n        nc->flags |= MG_F_SEND_AND_CLOSE;\n        return;\n      }\n      fus->lfn = (char *) MG_MALLOC(lfn.len + 1);\n      memcpy(fus->lfn, lfn.p, lfn.len);\n      fus->lfn[lfn.len] = '\\0';\n      if (lfn.p != mp->file_name) MG_FREE((char *) lfn.p);\n      LOG(LL_DEBUG,\n          (\"%p Receiving file %s -> %s\", nc, mp->file_name, fus->lfn));\n      fus->fp = mg_fopen(fus->lfn, \"w\");\n      if (fus->fp == NULL) {\n        mg_printf(nc,\n                  \"HTTP/1.1 500 Internal Server Error\\r\\n\"\n                  \"Content-Type: text/plain\\r\\n\"\n                  \"Connection: close\\r\\n\\r\\n\");\n        LOG(LL_ERROR, (\"Failed to open %s: %d\\n\", fus->lfn, mg_get_errno()));\n        mg_printf(nc, \"Failed to open %s: %d\\n\", fus->lfn, mg_get_errno());\n        /* Do not close the connection just yet, discard remainder of the data.\n         * This is because at the time of writing some browsers (Chrome) fail to\n         * render response before all the data is sent. */\n      }\n      mp->user_data = (void *) fus;\n      break;\n    }\n    case MG_EV_HTTP_PART_DATA: {\n      struct mg_http_multipart_part *mp =\n          (struct mg_http_multipart_part *) ev_data;\n      struct file_upload_state *fus =\n          (struct file_upload_state *) mp->user_data;\n      if (fus == NULL || fus->fp == NULL) break;\n      if (mg_fwrite(mp->data.p, 1, mp->data.len, fus->fp) != mp->data.len) {\n        LOG(LL_ERROR, (\"Failed to write to %s: %d, wrote %d\", fus->lfn,\n                       mg_get_errno(), (int) fus->num_recd));\n        if (mg_get_errno() == ENOSPC\n#ifdef SPIFFS_ERR_FULL\n            || mg_get_errno() == SPIFFS_ERR_FULL\n#endif\n            ) {\n          mg_printf(nc,\n                    \"HTTP/1.1 413 Payload Too Large\\r\\n\"\n                    \"Content-Type: text/plain\\r\\n\"\n                    \"Connection: close\\r\\n\\r\\n\");\n          mg_printf(nc, \"Failed to write to %s: no space left; wrote %d\\r\\n\",\n                    fus->lfn, (int) fus->num_recd);\n        } else {\n          mg_printf(nc,\n                    \"HTTP/1.1 500 Internal Server Error\\r\\n\"\n                    \"Content-Type: text/plain\\r\\n\"\n                    \"Connection: close\\r\\n\\r\\n\");\n          mg_printf(nc, \"Failed to write to %s: %d, wrote %d\", mp->file_name,\n                    mg_get_errno(), (int) fus->num_recd);\n        }\n        fclose(fus->fp);\n        remove(fus->lfn);\n        fus->fp = NULL;\n        /* Do not close the connection just yet, discard remainder of the data.\n         * This is because at the time of writing some browsers (Chrome) fail to\n         * render response before all the data is sent. */\n        return;\n      }\n      fus->num_recd += mp->data.len;\n      LOG(LL_DEBUG, (\"%p rec'd %d bytes, %d total\", nc, (int) mp->data.len,\n                     (int) fus->num_recd));\n      break;\n    }\n    case MG_EV_HTTP_PART_END: {\n      struct mg_http_multipart_part *mp =\n          (struct mg_http_multipart_part *) ev_data;\n      struct file_upload_state *fus =\n          (struct file_upload_state *) mp->user_data;\n      if (fus == NULL) break;\n      if (mp->status >= 0 && fus->fp != NULL) {\n        LOG(LL_DEBUG, (\"%p Uploaded %s (%s), %d bytes\", nc, mp->file_name,\n                       fus->lfn, (int) fus->num_recd));\n        mg_printf(nc,\n                  \"HTTP/1.1 200 OK\\r\\n\"\n                  \"Content-Type: text/plain\\r\\n\"\n                  \"Connection: close\\r\\n\\r\\n\"\n                  \"Ok, %s - %d bytes.\\r\\n\",\n                  mp->file_name, (int) fus->num_recd);\n      } else {\n        LOG(LL_ERROR, (\"Failed to store %s (%s)\", mp->file_name, fus->lfn));\n        /*\n         * mp->status < 0 means connection was terminated, so no reason to send\n         * HTTP reply\n         */\n      }\n      if (fus->fp != NULL) fclose(fus->fp);\n      MG_FREE(fus->lfn);\n      MG_FREE(fus);\n      mp->user_data = NULL;\n      nc->flags |= MG_F_SEND_AND_CLOSE;\n      break;\n    }\n  }\n\n#if MG_ENABLE_CALLBACK_USERDATA\n  (void) user_data;\n#endif\n}\n\n#endif /* MG_ENABLE_HTTP_STREAMING_MULTIPART */\n#endif /* MG_ENABLE_FILESYSTEM */\n\n/* returns 0 on success, -1 on error */\nMG_INTERNAL int mg_http_common_url_parse(const char *url, const char *schema,\n                                         const char *schema_tls, int *use_ssl,\n                                         char **user, char **pass, char **addr,\n                                         int *port_i, const char **path) {\n  int addr_len = 0;\n  int auth_sep_pos = -1;\n  int user_sep_pos = -1;\n  int port_pos = -1;\n  (void) user;\n  (void) pass;\n\n  if (strncmp(url, schema, strlen(schema)) == 0) {\n    url += strlen(schema);\n  } else if (strncmp(url, schema_tls, strlen(schema_tls)) == 0) {\n    url += strlen(schema_tls);\n    *use_ssl = 1;\n#if !MG_ENABLE_SSL\n    return -1; /* SSL is not enabled, cannot do HTTPS URLs */\n#endif\n  }\n\n  while (*url != '\\0') {\n    *addr = (char *) MG_REALLOC(*addr, addr_len + 6 /* space for port too. */);\n    if (*addr == NULL) {\n      DBG((\"OOM\"));\n      return -1;\n    }\n    if (*url == '/') {\n      break;\n    }\n    if (*url == '@') {\n      auth_sep_pos = addr_len;\n      user_sep_pos = port_pos;\n      port_pos = -1;\n    }\n    if (*url == ':') port_pos = addr_len;\n    (*addr)[addr_len++] = *url;\n    (*addr)[addr_len] = '\\0';\n    url++;\n  }\n\n  if (addr_len == 0) goto cleanup;\n  if (port_pos < 0) {\n    *port_i = addr_len;\n    addr_len += sprintf(*addr + addr_len, \":%d\", *use_ssl ? 443 : 80);\n  } else {\n    *port_i = -1;\n  }\n\n  if (*path == NULL) *path = url;\n\n  if (**path == '\\0') *path = \"/\";\n\n  if (user != NULL && pass != NULL) {\n    if (auth_sep_pos == -1) {\n      *user = NULL;\n      *pass = NULL;\n    } else {\n      /* user is from 0 to user_sep_pos */\n      *user = (char *) MG_MALLOC(user_sep_pos + 1);\n      memcpy(*user, *addr, user_sep_pos);\n      (*user)[user_sep_pos] = '\\0';\n      /* pass is from user_sep_pos + 1 to auth_sep_pos */\n      *pass = (char *) MG_MALLOC(auth_sep_pos - user_sep_pos - 1 + 1);\n      memcpy(*pass, *addr + user_sep_pos + 1, auth_sep_pos - user_sep_pos - 1);\n      (*pass)[auth_sep_pos - user_sep_pos - 1] = '\\0';\n\n      /* move address proper to the front */\n      memmove(*addr, *addr + auth_sep_pos + 1, addr_len - auth_sep_pos);\n    }\n  }\n\n  DBG((\"%s %s\", *addr, *path));\n\n  return 0;\n\ncleanup:\n  MG_FREE(*addr);\n  return -1;\n}\n\nstruct mg_connection *mg_connect_http_base(\n    struct mg_mgr *mgr, MG_CB(mg_event_handler_t ev_handler, void *user_data),\n    struct mg_connect_opts opts, const char *schema, const char *schema_ssl,\n    const char *url, const char **path, char **user, char **pass, char **addr) {\n  struct mg_connection *nc = NULL;\n  int port_i = -1;\n  int use_ssl = 0;\n\n  if (mg_http_common_url_parse(url, schema, schema_ssl, &use_ssl, user, pass,\n                               addr, &port_i, path) < 0) {\n    MG_SET_PTRPTR(opts.error_string, \"cannot parse url\");\n    return NULL;\n  }\n\n  LOG(LL_DEBUG, (\"%s use_ssl? %d\", url, use_ssl));\n  if (use_ssl) {\n#if MG_ENABLE_SSL\n    /*\n     * Schema requires SSL, but no SSL parameters were provided in opts.\n     * In order to maintain backward compatibility, use a faux-SSL with no\n     * verification.\n     */\n    if (opts.ssl_ca_cert == NULL) {\n      opts.ssl_ca_cert = \"*\";\n    }\n#else\n    MG_SET_PTRPTR(opts.error_string, \"ssl is disabled\");\n    if (user != NULL) MG_FREE(*user);\n    if (pass != NULL) MG_FREE(*pass);\n    MG_FREE(*addr);\n    return NULL;\n#endif\n  }\n\n  if ((nc = mg_connect_opt(mgr, *addr, MG_CB(ev_handler, user_data), opts)) !=\n      NULL) {\n    mg_set_protocol_http_websocket(nc);\n    /* If the port was addred by us, restore the original host. */\n    if (port_i >= 0) (*addr)[port_i] = '\\0';\n  }\n\n  return nc;\n}\n\nstruct mg_connection *mg_connect_http_opt(\n    struct mg_mgr *mgr, MG_CB(mg_event_handler_t ev_handler, void *user_data),\n    struct mg_connect_opts opts, const char *url, const char *extra_headers,\n    const char *post_data) {\n  char *user = NULL, *pass = NULL, *addr = NULL;\n  const char *path = NULL;\n  struct mbuf auth;\n  struct mg_connection *nc =\n      mg_connect_http_base(mgr, MG_CB(ev_handler, user_data), opts, \"http://\",\n                           \"https://\", url, &path, &user, &pass, &addr);\n\n  if (nc == NULL) {\n    return NULL;\n  }\n\n  mbuf_init(&auth, 0);\n  if (user != NULL) {\n    mg_basic_auth_header(user, pass, &auth);\n  }\n\n  if (post_data == NULL) post_data = \"\";\n  if (extra_headers == NULL) extra_headers = \"\";\n\n  mg_printf(nc, \"%s %s HTTP/1.1\\r\\nHost: %s\\r\\nContent-Length: %\" SIZE_T_FMT\n                \"\\r\\n%.*s%s\\r\\n%s\",\n            post_data[0] == '\\0' ? \"GET\" : \"POST\", path, addr,\n            strlen(post_data), (int) auth.len,\n            (auth.buf == NULL ? \"\" : auth.buf), extra_headers, post_data);\n\n  mbuf_free(&auth);\n  MG_FREE(user);\n  MG_FREE(pass);\n  MG_FREE(addr);\n  return nc;\n}\n\nstruct mg_connection *mg_connect_http(\n    struct mg_mgr *mgr, MG_CB(mg_event_handler_t ev_handler, void *user_data),\n    const char *url, const char *extra_headers, const char *post_data) {\n  struct mg_connect_opts opts;\n  memset(&opts, 0, sizeof(opts));\n  return mg_connect_http_opt(mgr, MG_CB(ev_handler, user_data), opts, url,\n                             extra_headers, post_data);\n}\n\nsize_t mg_parse_multipart(const char *buf, size_t buf_len, char *var_name,\n                          size_t var_name_len, char *file_name,\n                          size_t file_name_len, const char **data,\n                          size_t *data_len) {\n  static const char cd[] = \"Content-Disposition: \";\n  size_t hl, bl, n, ll, pos, cdl = sizeof(cd) - 1;\n\n  if (buf == NULL || buf_len <= 0) return 0;\n  if ((hl = mg_http_get_request_len(buf, buf_len)) <= 0) return 0;\n  if (buf[0] != '-' || buf[1] != '-' || buf[2] == '\\n') return 0;\n\n  /* Get boundary length */\n  bl = mg_get_line_len(buf, buf_len);\n\n  /* Loop through headers, fetch variable name and file name */\n  var_name[0] = file_name[0] = '\\0';\n  for (n = bl; (ll = mg_get_line_len(buf + n, hl - n)) > 0; n += ll) {\n    if (mg_ncasecmp(cd, buf + n, cdl) == 0) {\n      struct mg_str header;\n      header.p = buf + n + cdl;\n      header.len = ll - (cdl + 2);\n      mg_http_parse_header(&header, \"name\", var_name, var_name_len);\n      mg_http_parse_header(&header, \"filename\", file_name, file_name_len);\n    }\n  }\n\n  /* Scan through the body, search for terminating boundary */\n  for (pos = hl; pos + (bl - 2) < buf_len; pos++) {\n    if (buf[pos] == '-' && !strncmp(buf, &buf[pos], bl - 2)) {\n      if (data_len != NULL) *data_len = (pos - 2) - hl;\n      if (data != NULL) *data = buf + hl;\n      return pos;\n    }\n  }\n\n  return 0;\n}\n\nvoid mg_register_http_endpoint(struct mg_connection *nc, const char *uri_path,\n                               MG_CB(mg_event_handler_t handler,\n                                     void *user_data)) {\n  struct mg_http_proto_data *pd = NULL;\n  struct mg_http_endpoint *new_ep = NULL;\n\n  if (nc == NULL) return;\n  new_ep = (struct mg_http_endpoint *) MG_CALLOC(1, sizeof(*new_ep));\n  if (new_ep == NULL) return;\n\n  pd = mg_http_get_proto_data(nc);\n  new_ep->name = strdup(uri_path);\n  new_ep->name_len = strlen(new_ep->name);\n  new_ep->handler = handler;\n#if MG_ENABLE_CALLBACK_USERDATA\n  new_ep->user_data = user_data;\n#endif\n  new_ep->next = pd->endpoints;\n  pd->endpoints = new_ep;\n}\n\n#endif /* MG_ENABLE_HTTP */\n#ifdef MG_MODULE_LINES\n#line 1 \"mongoose/src/http_cgi.c\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#if MG_ENABLE_HTTP && MG_ENABLE_HTTP_CGI\n\n#ifndef MG_MAX_CGI_ENVIR_VARS\n#define MG_MAX_CGI_ENVIR_VARS 64\n#endif\n\n#ifndef MG_ENV_EXPORT_TO_CGI\n#define MG_ENV_EXPORT_TO_CGI \"MONGOOSE_CGI\"\n#endif\n\n/*\n * This structure helps to create an environment for the spawned CGI program.\n * Environment is an array of \"VARIABLE=VALUE\\0\" ASCIIZ strings,\n * last element must be NULL.\n * However, on Windows there is a requirement that all these VARIABLE=VALUE\\0\n * strings must reside in a contiguous buffer. The end of the buffer is\n * marked by two '\\0' characters.\n * We satisfy both worlds: we create an envp array (which is vars), all\n * entries are actually pointers inside buf.\n */\nstruct mg_cgi_env_block {\n  struct mg_connection *nc;\n  char buf[MG_CGI_ENVIRONMENT_SIZE];       /* Environment buffer */\n  const char *vars[MG_MAX_CGI_ENVIR_VARS]; /* char *envp[] */\n  int len;                                 /* Space taken */\n  int nvars;                               /* Number of variables in envp[] */\n};\n\n#ifdef _WIN32\nstruct mg_threadparam {\n  sock_t s;\n  HANDLE hPipe;\n};\n\nstatic int mg_wait_until_ready(sock_t sock, int for_read) {\n  fd_set set;\n  FD_ZERO(&set);\n  FD_SET(sock, &set);\n  return select(sock + 1, for_read ? &set : 0, for_read ? 0 : &set, 0, 0) == 1;\n}\n\nstatic void *mg_push_to_stdin(void *arg) {\n  struct mg_threadparam *tp = (struct mg_threadparam *) arg;\n  int n, sent, stop = 0;\n  DWORD k;\n  char buf[BUFSIZ];\n\n  while (!stop && mg_wait_until_ready(tp->s, 1) &&\n         (n = recv(tp->s, buf, sizeof(buf), 0)) > 0) {\n    if (n == -1 && GetLastError() == WSAEWOULDBLOCK) continue;\n    for (sent = 0; !stop && sent < n; sent += k) {\n      if (!WriteFile(tp->hPipe, buf + sent, n - sent, &k, 0)) stop = 1;\n    }\n  }\n  DBG((\"%s\", \"FORWARED EVERYTHING TO CGI\"));\n  CloseHandle(tp->hPipe);\n  MG_FREE(tp);\n  return NULL;\n}\n\nstatic void *mg_pull_from_stdout(void *arg) {\n  struct mg_threadparam *tp = (struct mg_threadparam *) arg;\n  int k = 0, stop = 0;\n  DWORD n, sent;\n  char buf[BUFSIZ];\n\n  while (!stop && ReadFile(tp->hPipe, buf, sizeof(buf), &n, NULL)) {\n    for (sent = 0; !stop && sent < n; sent += k) {\n      if (mg_wait_until_ready(tp->s, 0) &&\n          (k = send(tp->s, buf + sent, n - sent, 0)) <= 0)\n        stop = 1;\n    }\n  }\n  DBG((\"%s\", \"EOF FROM CGI\"));\n  CloseHandle(tp->hPipe);\n  shutdown(tp->s, 2);  // Without this, IO thread may get truncated data\n  closesocket(tp->s);\n  MG_FREE(tp);\n  return NULL;\n}\n\nstatic void mg_spawn_stdio_thread(sock_t sock, HANDLE hPipe,\n                                  void *(*func)(void *)) {\n  struct mg_threadparam *tp = (struct mg_threadparam *) MG_MALLOC(sizeof(*tp));\n  if (tp != NULL) {\n    tp->s = sock;\n    tp->hPipe = hPipe;\n    mg_start_thread(func, tp);\n  }\n}\n\nstatic void mg_abs_path(const char *utf8_path, char *abs_path, size_t len) {\n  wchar_t buf[MAX_PATH_SIZE], buf2[MAX_PATH_SIZE];\n  to_wchar(utf8_path, buf, ARRAY_SIZE(buf));\n  GetFullPathNameW(buf, ARRAY_SIZE(buf2), buf2, NULL);\n  WideCharToMultiByte(CP_UTF8, 0, buf2, wcslen(buf2) + 1, abs_path, len, 0, 0);\n}\n\nstatic int mg_start_process(const char *interp, const char *cmd,\n                            const char *env, const char *envp[],\n                            const char *dir, sock_t sock) {\n  STARTUPINFOW si;\n  PROCESS_INFORMATION pi;\n  HANDLE a[2], b[2], me = GetCurrentProcess();\n  wchar_t wcmd[MAX_PATH_SIZE], full_dir[MAX_PATH_SIZE];\n  char buf[MAX_PATH_SIZE], buf2[MAX_PATH_SIZE], buf5[MAX_PATH_SIZE],\n      buf4[MAX_PATH_SIZE], cmdline[MAX_PATH_SIZE];\n  DWORD flags = DUPLICATE_CLOSE_SOURCE | DUPLICATE_SAME_ACCESS;\n  FILE *fp;\n\n  memset(&si, 0, sizeof(si));\n  memset(&pi, 0, sizeof(pi));\n\n  si.cb = sizeof(si);\n  si.dwFlags = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;\n  si.wShowWindow = SW_HIDE;\n  si.hStdError = GetStdHandle(STD_ERROR_HANDLE);\n\n  CreatePipe(&a[0], &a[1], NULL, 0);\n  CreatePipe(&b[0], &b[1], NULL, 0);\n  DuplicateHandle(me, a[0], me, &si.hStdInput, 0, TRUE, flags);\n  DuplicateHandle(me, b[1], me, &si.hStdOutput, 0, TRUE, flags);\n\n  if (interp == NULL && (fp = mg_fopen(cmd, \"r\")) != NULL) {\n    buf[0] = buf[1] = '\\0';\n    fgets(buf, sizeof(buf), fp);\n    buf[sizeof(buf) - 1] = '\\0';\n    if (buf[0] == '#' && buf[1] == '!') {\n      interp = buf + 2;\n      /* Trim leading spaces: https://github.com/cesanta/mongoose/issues/489 */\n      while (*interp != '\\0' && isspace(*(unsigned char *) interp)) {\n        interp++;\n      }\n    }\n    fclose(fp);\n  }\n\n  snprintf(buf, sizeof(buf), \"%s/%s\", dir, cmd);\n  mg_abs_path(buf, buf2, ARRAY_SIZE(buf2));\n\n  mg_abs_path(dir, buf5, ARRAY_SIZE(buf5));\n  to_wchar(dir, full_dir, ARRAY_SIZE(full_dir));\n\n  if (interp != NULL) {\n    mg_abs_path(interp, buf4, ARRAY_SIZE(buf4));\n    snprintf(cmdline, sizeof(cmdline), \"%s \\\"%s\\\"\", buf4, buf2);\n  } else {\n    snprintf(cmdline, sizeof(cmdline), \"\\\"%s\\\"\", buf2);\n  }\n  to_wchar(cmdline, wcmd, ARRAY_SIZE(wcmd));\n\n  if (CreateProcessW(NULL, wcmd, NULL, NULL, TRUE, CREATE_NEW_PROCESS_GROUP,\n                     (void *) env, full_dir, &si, &pi) != 0) {\n    mg_spawn_stdio_thread(sock, a[1], mg_push_to_stdin);\n    mg_spawn_stdio_thread(sock, b[0], mg_pull_from_stdout);\n\n    CloseHandle(si.hStdOutput);\n    CloseHandle(si.hStdInput);\n\n    CloseHandle(pi.hThread);\n    CloseHandle(pi.hProcess);\n  } else {\n    CloseHandle(a[1]);\n    CloseHandle(b[0]);\n    closesocket(sock);\n  }\n  DBG((\"CGI command: [%ls] -> %p\", wcmd, pi.hProcess));\n\n  /* Not closing a[0] and b[1] because we've used DUPLICATE_CLOSE_SOURCE */\n  (void) envp;\n  return (pi.hProcess != NULL);\n}\n#else\nstatic int mg_start_process(const char *interp, const char *cmd,\n                            const char *env, const char *envp[],\n                            const char *dir, sock_t sock) {\n  char buf[500];\n  pid_t pid = fork();\n  (void) env;\n\n  if (pid == 0) {\n    /*\n     * In Linux `chdir` declared with `warn_unused_result` attribute\n     * To shutup compiler we have yo use result in some way\n     */\n    int tmp = chdir(dir);\n    (void) tmp;\n    (void) dup2(sock, 0);\n    (void) dup2(sock, 1);\n    closesocket(sock);\n\n    /*\n     * After exec, all signal handlers are restored to their default values,\n     * with one exception of SIGCHLD. According to POSIX.1-2001 and Linux's\n     * implementation, SIGCHLD's handler will leave unchanged after exec\n     * if it was set to be ignored. Restore it to default action.\n     */\n    signal(SIGCHLD, SIG_DFL);\n\n    if (interp == NULL) {\n      execle(cmd, cmd, (char *) 0, envp); /* (char *) 0 to squash warning */\n    } else {\n      execle(interp, interp, cmd, (char *) 0, envp);\n    }\n    snprintf(buf, sizeof(buf),\n             \"Status: 500\\r\\n\\r\\n\"\n             \"500 Server Error: %s%s%s: %s\",\n             interp == NULL ? \"\" : interp, interp == NULL ? \"\" : \" \", cmd,\n             strerror(errno));\n    send(1, buf, strlen(buf), 0);\n    _exit(EXIT_FAILURE); /* exec call failed */\n  }\n\n  return (pid != 0);\n}\n#endif /* _WIN32 */\n\n/*\n * Append VARIABLE=VALUE\\0 string to the buffer, and add a respective\n * pointer into the vars array.\n */\nstatic char *mg_addenv(struct mg_cgi_env_block *block, const char *fmt, ...) {\n  int n, space;\n  char *added = block->buf + block->len;\n  va_list ap;\n\n  /* Calculate how much space is left in the buffer */\n  space = sizeof(block->buf) - (block->len + 2);\n  if (space > 0) {\n    /* Copy VARIABLE=VALUE\\0 string into the free space */\n    va_start(ap, fmt);\n    n = vsnprintf(added, (size_t) space, fmt, ap);\n    va_end(ap);\n\n    /* Make sure we do not overflow buffer and the envp array */\n    if (n > 0 && n + 1 < space &&\n        block->nvars < (int) ARRAY_SIZE(block->vars) - 2) {\n      /* Append a pointer to the added string into the envp array */\n      block->vars[block->nvars++] = added;\n      /* Bump up used length counter. Include \\0 terminator */\n      block->len += n + 1;\n    }\n  }\n\n  return added;\n}\n\nstatic void mg_addenv2(struct mg_cgi_env_block *blk, const char *name) {\n  const char *s;\n  if ((s = getenv(name)) != NULL) mg_addenv(blk, \"%s=%s\", name, s);\n}\n\nstatic void mg_prepare_cgi_environment(struct mg_connection *nc,\n                                       const char *prog,\n                                       const struct mg_str *path_info,\n                                       const struct http_message *hm,\n                                       const struct mg_serve_http_opts *opts,\n                                       struct mg_cgi_env_block *blk) {\n  const char *s;\n  struct mg_str *h;\n  char *p;\n  size_t i;\n  char buf[100];\n\n  blk->len = blk->nvars = 0;\n  blk->nc = nc;\n\n  if ((s = getenv(\"SERVER_NAME\")) != NULL) {\n    mg_addenv(blk, \"SERVER_NAME=%s\", s);\n  } else {\n    mg_sock_to_str(nc->sock, buf, sizeof(buf), 3);\n    mg_addenv(blk, \"SERVER_NAME=%s\", buf);\n  }\n  mg_addenv(blk, \"SERVER_ROOT=%s\", opts->document_root);\n  mg_addenv(blk, \"DOCUMENT_ROOT=%s\", opts->document_root);\n  mg_addenv(blk, \"SERVER_SOFTWARE=%s/%s\", \"Mongoose\", MG_VERSION);\n\n  /* Prepare the environment block */\n  mg_addenv(blk, \"%s\", \"GATEWAY_INTERFACE=CGI/1.1\");\n  mg_addenv(blk, \"%s\", \"SERVER_PROTOCOL=HTTP/1.1\");\n  mg_addenv(blk, \"%s\", \"REDIRECT_STATUS=200\"); /* For PHP */\n\n  mg_addenv(blk, \"REQUEST_METHOD=%.*s\", (int) hm->method.len, hm->method.p);\n\n  mg_addenv(blk, \"REQUEST_URI=%.*s%s%.*s\", (int) hm->uri.len, hm->uri.p,\n            hm->query_string.len == 0 ? \"\" : \"?\", (int) hm->query_string.len,\n            hm->query_string.p);\n\n  mg_conn_addr_to_str(nc, buf, sizeof(buf),\n                      MG_SOCK_STRINGIFY_REMOTE | MG_SOCK_STRINGIFY_IP);\n  mg_addenv(blk, \"REMOTE_ADDR=%s\", buf);\n  mg_conn_addr_to_str(nc, buf, sizeof(buf), MG_SOCK_STRINGIFY_PORT);\n  mg_addenv(blk, \"SERVER_PORT=%s\", buf);\n\n  s = hm->uri.p + hm->uri.len - path_info->len - 1;\n  if (*s == '/') {\n    const char *base_name = strrchr(prog, DIRSEP);\n    mg_addenv(blk, \"SCRIPT_NAME=%.*s/%s\", (int) (s - hm->uri.p), hm->uri.p,\n              (base_name != NULL ? base_name + 1 : prog));\n  } else {\n    mg_addenv(blk, \"SCRIPT_NAME=%.*s\", (int) (s - hm->uri.p + 1), hm->uri.p);\n  }\n  mg_addenv(blk, \"SCRIPT_FILENAME=%s\", prog);\n\n  if (path_info != NULL && path_info->len > 0) {\n    mg_addenv(blk, \"PATH_INFO=%.*s\", (int) path_info->len, path_info->p);\n    /* Not really translated... */\n    mg_addenv(blk, \"PATH_TRANSLATED=%.*s\", (int) path_info->len, path_info->p);\n  }\n\n#if MG_ENABLE_SSL\n  mg_addenv(blk, \"HTTPS=%s\", (nc->flags & MG_F_SSL ? \"on\" : \"off\"));\n#else\n  mg_addenv(blk, \"HTTPS=off\");\n#endif\n\n  if ((h = mg_get_http_header((struct http_message *) hm, \"Content-Type\")) !=\n      NULL) {\n    mg_addenv(blk, \"CONTENT_TYPE=%.*s\", (int) h->len, h->p);\n  }\n\n  if (hm->query_string.len > 0) {\n    mg_addenv(blk, \"QUERY_STRING=%.*s\", (int) hm->query_string.len,\n              hm->query_string.p);\n  }\n\n  if ((h = mg_get_http_header((struct http_message *) hm, \"Content-Length\")) !=\n      NULL) {\n    mg_addenv(blk, \"CONTENT_LENGTH=%.*s\", (int) h->len, h->p);\n  }\n\n  mg_addenv2(blk, \"PATH\");\n  mg_addenv2(blk, \"TMP\");\n  mg_addenv2(blk, \"TEMP\");\n  mg_addenv2(blk, \"TMPDIR\");\n  mg_addenv2(blk, \"PERLLIB\");\n  mg_addenv2(blk, MG_ENV_EXPORT_TO_CGI);\n\n#ifdef _WIN32\n  mg_addenv2(blk, \"COMSPEC\");\n  mg_addenv2(blk, \"SYSTEMROOT\");\n  mg_addenv2(blk, \"SystemDrive\");\n  mg_addenv2(blk, \"ProgramFiles\");\n  mg_addenv2(blk, \"ProgramFiles(x86)\");\n  mg_addenv2(blk, \"CommonProgramFiles(x86)\");\n#else\n  mg_addenv2(blk, \"LD_LIBRARY_PATH\");\n#endif /* _WIN32 */\n\n  /* Add all headers as HTTP_* variables */\n  for (i = 0; hm->header_names[i].len > 0; i++) {\n    p = mg_addenv(blk, \"HTTP_%.*s=%.*s\", (int) hm->header_names[i].len,\n                  hm->header_names[i].p, (int) hm->header_values[i].len,\n                  hm->header_values[i].p);\n\n    /* Convert variable name into uppercase, and change - to _ */\n    for (; *p != '=' && *p != '\\0'; p++) {\n      if (*p == '-') *p = '_';\n      *p = (char) toupper(*(unsigned char *) p);\n    }\n  }\n\n  blk->vars[blk->nvars++] = NULL;\n  blk->buf[blk->len++] = '\\0';\n}\n\nstatic void mg_cgi_ev_handler(struct mg_connection *cgi_nc, int ev,\n                              void *ev_data MG_UD_ARG(void *user_data)) {\n#if !MG_ENABLE_CALLBACK_USERDATA\n  void *user_data = cgi_nc->user_data;\n#endif\n  struct mg_connection *nc = (struct mg_connection *) user_data;\n  (void) ev_data;\n\n  if (nc == NULL) {\n    cgi_nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n    return;\n  }\n\n  switch (ev) {\n    case MG_EV_RECV:\n      /*\n       * CGI script does not output reply line, like \"HTTP/1.1 CODE XXXXX\\n\"\n       * It outputs headers, then body. Headers might include \"Status\"\n       * header, which changes CODE, and it might include \"Location\" header\n       * which changes CODE to 302.\n       *\n       * Therefore we do not send the output from the CGI script to the user\n       * until all CGI headers are received.\n       *\n       * Here we parse the output from the CGI script, and if all headers has\n       * been received, send appropriate reply line, and forward all\n       * received headers to the client.\n       */\n      if (nc->flags & MG_F_USER_1) {\n        struct mbuf *io = &cgi_nc->recv_mbuf;\n        int len = mg_http_get_request_len(io->buf, io->len);\n\n        if (len == 0) break;\n        if (len < 0 || io->len > MG_MAX_HTTP_REQUEST_SIZE) {\n          cgi_nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n          mg_http_send_error(nc, 500, \"Bad headers\");\n        } else {\n          struct http_message hm;\n          struct mg_str *h;\n          mg_http_parse_headers(io->buf, io->buf + io->len, io->len, &hm);\n          if (mg_get_http_header(&hm, \"Location\") != NULL) {\n            mg_printf(nc, \"%s\", \"HTTP/1.1 302 Moved\\r\\n\");\n          } else if ((h = mg_get_http_header(&hm, \"Status\")) != NULL) {\n            mg_printf(nc, \"HTTP/1.1 %.*s\\r\\n\", (int) h->len, h->p);\n          } else {\n            mg_printf(nc, \"%s\", \"HTTP/1.1 200 OK\\r\\n\");\n          }\n        }\n        nc->flags &= ~MG_F_USER_1;\n      }\n      if (!(nc->flags & MG_F_USER_1)) {\n        mg_forward(cgi_nc, nc);\n      }\n      break;\n    case MG_EV_CLOSE:\n      mg_http_free_proto_data_cgi(&mg_http_get_proto_data(nc)->cgi);\n      nc->flags |= MG_F_SEND_AND_CLOSE;\n      break;\n  }\n}\n\nMG_INTERNAL void mg_handle_cgi(struct mg_connection *nc, const char *prog,\n                               const struct mg_str *path_info,\n                               const struct http_message *hm,\n                               const struct mg_serve_http_opts *opts) {\n  struct mg_cgi_env_block blk;\n  char dir[MAX_PATH_SIZE];\n  const char *p;\n  sock_t fds[2];\n\n  DBG((\"%p [%s]\", nc, prog));\n  mg_prepare_cgi_environment(nc, prog, path_info, hm, opts, &blk);\n  /*\n   * CGI must be executed in its own directory. 'dir' must point to the\n   * directory containing executable program, 'p' must point to the\n   * executable program name relative to 'dir'.\n   */\n  if ((p = strrchr(prog, DIRSEP)) == NULL) {\n    snprintf(dir, sizeof(dir), \"%s\", \".\");\n  } else {\n    snprintf(dir, sizeof(dir), \"%.*s\", (int) (p - prog), prog);\n    prog = p + 1;\n  }\n\n  /*\n   * Try to create socketpair in a loop until success. mg_socketpair()\n   * can be interrupted by a signal and fail.\n   * TODO(lsm): use sigaction to restart interrupted syscall\n   */\n  do {\n    mg_socketpair(fds, SOCK_STREAM);\n  } while (fds[0] == INVALID_SOCKET);\n\n  if (mg_start_process(opts->cgi_interpreter, prog, blk.buf, blk.vars, dir,\n                       fds[1]) != 0) {\n    size_t n = nc->recv_mbuf.len - (hm->message.len - hm->body.len);\n    struct mg_connection *cgi_nc =\n        mg_add_sock(nc->mgr, fds[0], mg_cgi_ev_handler MG_UD_ARG(nc));\n    struct mg_http_proto_data *cgi_pd = mg_http_get_proto_data(nc);\n    cgi_pd->cgi.cgi_nc = cgi_nc;\n#if !MG_ENABLE_CALLBACK_USERDATA\n    cgi_pd->cgi.cgi_nc->user_data = nc;\n#endif\n    nc->flags |= MG_F_USER_1;\n    /* Push POST data to the CGI */\n    if (n > 0 && n < nc->recv_mbuf.len) {\n      mg_send(cgi_pd->cgi.cgi_nc, hm->body.p, n);\n    }\n    mbuf_remove(&nc->recv_mbuf, nc->recv_mbuf.len);\n  } else {\n    closesocket(fds[0]);\n    mg_http_send_error(nc, 500, \"CGI failure\");\n  }\n\n#ifndef _WIN32\n  closesocket(fds[1]); /* On Windows, CGI stdio thread closes that socket */\n#endif\n}\n\nMG_INTERNAL void mg_http_free_proto_data_cgi(struct mg_http_proto_data_cgi *d) {\n  if (d != NULL) {\n    if (d->cgi_nc != NULL) d->cgi_nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n    memset(d, 0, sizeof(struct mg_http_proto_data_cgi));\n  }\n}\n\n#endif /* MG_ENABLE_HTTP && MG_ENABLE_HTTP_CGI */\n#ifdef MG_MODULE_LINES\n#line 1 \"mongoose/src/http_ssi.c\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#if MG_ENABLE_HTTP && MG_ENABLE_HTTP_SSI && MG_ENABLE_FILESYSTEM\n\nstatic void mg_send_ssi_file(struct mg_connection *nc, struct http_message *hm,\n                             const char *path, FILE *fp, int include_level,\n                             const struct mg_serve_http_opts *opts);\n\nstatic void mg_send_file_data(struct mg_connection *nc, FILE *fp) {\n  char buf[BUFSIZ];\n  size_t n;\n  while ((n = mg_fread(buf, 1, sizeof(buf), fp)) > 0) {\n    mg_send(nc, buf, n);\n  }\n}\n\nstatic void mg_do_ssi_include(struct mg_connection *nc, struct http_message *hm,\n                              const char *ssi, char *tag, int include_level,\n                              const struct mg_serve_http_opts *opts) {\n  char file_name[BUFSIZ], path[MAX_PATH_SIZE], *p;\n  FILE *fp;\n\n  /*\n   * sscanf() is safe here, since send_ssi_file() also uses buffer\n   * of size MG_BUF_LEN to get the tag. So strlen(tag) is always < MG_BUF_LEN.\n   */\n  if (sscanf(tag, \" virtual=\\\"%[^\\\"]\\\"\", file_name) == 1) {\n    /* File name is relative to the webserver root */\n    snprintf(path, sizeof(path), \"%s/%s\", opts->document_root, file_name);\n  } else if (sscanf(tag, \" abspath=\\\"%[^\\\"]\\\"\", file_name) == 1) {\n    /*\n     * File name is relative to the webserver working directory\n     * or it is absolute system path\n     */\n    snprintf(path, sizeof(path), \"%s\", file_name);\n  } else if (sscanf(tag, \" file=\\\"%[^\\\"]\\\"\", file_name) == 1 ||\n             sscanf(tag, \" \\\"%[^\\\"]\\\"\", file_name) == 1) {\n    /* File name is relative to the currect document */\n    snprintf(path, sizeof(path), \"%s\", ssi);\n    if ((p = strrchr(path, DIRSEP)) != NULL) {\n      p[1] = '\\0';\n    }\n    snprintf(path + strlen(path), sizeof(path) - strlen(path), \"%s\", file_name);\n  } else {\n    mg_printf(nc, \"Bad SSI #include: [%s]\", tag);\n    return;\n  }\n\n  if ((fp = mg_fopen(path, \"rb\")) == NULL) {\n    mg_printf(nc, \"SSI include error: mg_fopen(%s): %s\", path,\n              strerror(mg_get_errno()));\n  } else {\n    mg_set_close_on_exec((sock_t) fileno(fp));\n    if (mg_match_prefix(opts->ssi_pattern, strlen(opts->ssi_pattern), path) >\n        0) {\n      mg_send_ssi_file(nc, hm, path, fp, include_level + 1, opts);\n    } else {\n      mg_send_file_data(nc, fp);\n    }\n    fclose(fp);\n  }\n}\n\n#if MG_ENABLE_HTTP_SSI_EXEC\nstatic void do_ssi_exec(struct mg_connection *nc, char *tag) {\n  char cmd[BUFSIZ];\n  FILE *fp;\n\n  if (sscanf(tag, \" \\\"%[^\\\"]\\\"\", cmd) != 1) {\n    mg_printf(nc, \"Bad SSI #exec: [%s]\", tag);\n  } else if ((fp = popen(cmd, \"r\")) == NULL) {\n    mg_printf(nc, \"Cannot SSI #exec: [%s]: %s\", cmd, strerror(mg_get_errno()));\n  } else {\n    mg_send_file_data(nc, fp);\n    pclose(fp);\n  }\n}\n#endif /* MG_ENABLE_HTTP_SSI_EXEC */\n\n/*\n * SSI directive has the following format:\n * <!--#directive parameter=value parameter=value -->\n */\nstatic void mg_send_ssi_file(struct mg_connection *nc, struct http_message *hm,\n                             const char *path, FILE *fp, int include_level,\n                             const struct mg_serve_http_opts *opts) {\n  static const struct mg_str btag = MG_MK_STR(\"<!--#\");\n  static const struct mg_str d_include = MG_MK_STR(\"include\");\n  static const struct mg_str d_call = MG_MK_STR(\"call\");\n#if MG_ENABLE_HTTP_SSI_EXEC\n  static const struct mg_str d_exec = MG_MK_STR(\"exec\");\n#endif\n  char buf[BUFSIZ], *p = buf + btag.len; /* p points to SSI directive */\n  int ch, len, in_ssi_tag;\n\n  if (include_level > 10) {\n    mg_printf(nc, \"SSI #include level is too deep (%s)\", path);\n    return;\n  }\n\n  in_ssi_tag = len = 0;\n  while ((ch = fgetc(fp)) != EOF) {\n    if (in_ssi_tag && ch == '>' && buf[len - 1] == '-' && buf[len - 2] == '-') {\n      size_t i = len - 2;\n      in_ssi_tag = 0;\n\n      /* Trim closing --> */\n      buf[i--] = '\\0';\n      while (i > 0 && buf[i] == ' ') {\n        buf[i--] = '\\0';\n      }\n\n      /* Handle known SSI directives */\n      if (strncmp(p, d_include.p, d_include.len) == 0) {\n        mg_do_ssi_include(nc, hm, path, p + d_include.len + 1, include_level,\n                          opts);\n      } else if (strncmp(p, d_call.p, d_call.len) == 0) {\n        struct mg_ssi_call_ctx cctx;\n        memset(&cctx, 0, sizeof(cctx));\n        cctx.req = hm;\n        cctx.file = mg_mk_str(path);\n        cctx.arg = mg_mk_str(p + d_call.len + 1);\n        mg_call(nc, NULL, nc->user_data, MG_EV_SSI_CALL,\n                (void *) cctx.arg.p); /* NUL added above */\n        mg_call(nc, NULL, nc->user_data, MG_EV_SSI_CALL_CTX, &cctx);\n#if MG_ENABLE_HTTP_SSI_EXEC\n      } else if (strncmp(p, d_exec.p, d_exec.len) == 0) {\n        do_ssi_exec(nc, p + d_exec.len + 1);\n#endif\n      } else {\n        /* Silently ignore unknown SSI directive. */\n      }\n      len = 0;\n    } else if (ch == '<') {\n      in_ssi_tag = 1;\n      if (len > 0) {\n        mg_send(nc, buf, (size_t) len);\n      }\n      len = 0;\n      buf[len++] = ch & 0xff;\n    } else if (in_ssi_tag) {\n      if (len == (int) btag.len && strncmp(buf, btag.p, btag.len) != 0) {\n        /* Not an SSI tag */\n        in_ssi_tag = 0;\n      } else if (len == (int) sizeof(buf) - 2) {\n        mg_printf(nc, \"%s: SSI tag is too large\", path);\n        len = 0;\n      }\n      buf[len++] = ch & 0xff;\n    } else {\n      buf[len++] = ch & 0xff;\n      if (len == (int) sizeof(buf)) {\n        mg_send(nc, buf, (size_t) len);\n        len = 0;\n      }\n    }\n  }\n\n  /* Send the rest of buffered data */\n  if (len > 0) {\n    mg_send(nc, buf, (size_t) len);\n  }\n}\n\nMG_INTERNAL void mg_handle_ssi_request(struct mg_connection *nc,\n                                       struct http_message *hm,\n                                       const char *path,\n                                       const struct mg_serve_http_opts *opts) {\n  FILE *fp;\n  struct mg_str mime_type;\n  DBG((\"%p %s\", nc, path));\n\n  if ((fp = mg_fopen(path, \"rb\")) == NULL) {\n    mg_http_send_error(nc, 404, NULL);\n  } else {\n    mg_set_close_on_exec((sock_t) fileno(fp));\n\n    mime_type = mg_get_mime_type(path, \"text/plain\", opts);\n    mg_send_response_line(nc, 200, opts->extra_headers);\n    mg_printf(nc,\n              \"Content-Type: %.*s\\r\\n\"\n              \"Connection: close\\r\\n\\r\\n\",\n              (int) mime_type.len, mime_type.p);\n    mg_send_ssi_file(nc, hm, path, fp, 0, opts);\n    fclose(fp);\n    nc->flags |= MG_F_SEND_AND_CLOSE;\n  }\n}\n\n#endif /* MG_ENABLE_HTTP_SSI && MG_ENABLE_HTTP && MG_ENABLE_FILESYSTEM */\n#ifdef MG_MODULE_LINES\n#line 1 \"mongoose/src/http_webdav.c\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#if MG_ENABLE_HTTP && MG_ENABLE_HTTP_WEBDAV\n\nMG_INTERNAL int mg_is_dav_request(const struct mg_str *s) {\n  static const char *methods[] = {\n    \"PUT\",\n    \"DELETE\",\n    \"MKCOL\",\n    \"PROPFIND\",\n    \"MOVE\"\n#if MG_ENABLE_FAKE_DAVLOCK\n    ,\n    \"LOCK\",\n    \"UNLOCK\"\n#endif\n  };\n  size_t i;\n\n  for (i = 0; i < ARRAY_SIZE(methods); i++) {\n    if (mg_vcmp(s, methods[i]) == 0) {\n      return 1;\n    }\n  }\n\n  return 0;\n}\n\nstatic int mg_mkdir(const char *path, uint32_t mode) {\n#ifndef _WIN32\n  return mkdir(path, mode);\n#else\n  (void) mode;\n  return _mkdir(path);\n#endif\n}\n\nstatic void mg_print_props(struct mg_connection *nc, const char *name,\n                           cs_stat_t *stp) {\n  char mtime[64], buf[MAX_PATH_SIZE * 3];\n  time_t t = stp->st_mtime; /* store in local variable for NDK compile */\n  mg_gmt_time_string(mtime, sizeof(mtime), &t);\n  mg_url_encode(name, strlen(name), buf, sizeof(buf));\n  mg_printf(nc,\n            \"<d:response>\"\n            \"<d:href>%s</d:href>\"\n            \"<d:propstat>\"\n            \"<d:prop>\"\n            \"<d:resourcetype>%s</d:resourcetype>\"\n            \"<d:getcontentlength>%\" INT64_FMT\n            \"</d:getcontentlength>\"\n            \"<d:getlastmodified>%s</d:getlastmodified>\"\n            \"</d:prop>\"\n            \"<d:status>HTTP/1.1 200 OK</d:status>\"\n            \"</d:propstat>\"\n            \"</d:response>\\n\",\n            buf, S_ISDIR(stp->st_mode) ? \"<d:collection/>\" : \"\",\n            (int64_t) stp->st_size, mtime);\n}\n\nMG_INTERNAL void mg_handle_propfind(struct mg_connection *nc, const char *path,\n                                    cs_stat_t *stp, struct http_message *hm,\n                                    struct mg_serve_http_opts *opts) {\n  static const char header[] =\n      \"HTTP/1.1 207 Multi-Status\\r\\n\"\n      \"Connection: close\\r\\n\"\n      \"Content-Type: text/xml; charset=utf-8\\r\\n\\r\\n\"\n      \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\"\n      \"<d:multistatus xmlns:d='DAV:'>\\n\";\n  static const char footer[] = \"</d:multistatus>\\n\";\n  const struct mg_str *depth = mg_get_http_header(hm, \"Depth\");\n\n  /* Print properties for the requested resource itself */\n  if (S_ISDIR(stp->st_mode) &&\n      strcmp(opts->enable_directory_listing, \"yes\") != 0) {\n    mg_printf(nc, \"%s\", \"HTTP/1.1 403 Directory Listing Denied\\r\\n\\r\\n\");\n  } else {\n    char uri[MAX_PATH_SIZE];\n    mg_send(nc, header, sizeof(header) - 1);\n    snprintf(uri, sizeof(uri), \"%.*s\", (int) hm->uri.len, hm->uri.p);\n    mg_print_props(nc, uri, stp);\n    if (S_ISDIR(stp->st_mode) && (depth == NULL || mg_vcmp(depth, \"0\") != 0)) {\n      mg_scan_directory(nc, path, opts, mg_print_props);\n    }\n    mg_send(nc, footer, sizeof(footer) - 1);\n    nc->flags |= MG_F_SEND_AND_CLOSE;\n  }\n}\n\n#if MG_ENABLE_FAKE_DAVLOCK\n/*\n * Windows explorer (probably there are another WebDav clients like it)\n * requires LOCK support in webdav. W/out this, it still works, but fails\n * to save file: shows error message and offers \"Save As\".\n * \"Save as\" works, but this message is very annoying.\n * This is fake lock, which doesn't lock something, just returns LOCK token,\n * UNLOCK always answers \"OK\".\n * With this fake LOCK Windows Explorer looks happy and saves file.\n * NOTE: that is not DAV LOCK imlementation, it is just a way to shut up\n * Windows native DAV client. This is why FAKE LOCK is not enabed by default\n */\nMG_INTERNAL void mg_handle_lock(struct mg_connection *nc, const char *path) {\n  static const char *reply =\n      \"HTTP/1.1 207 Multi-Status\\r\\n\"\n      \"Connection: close\\r\\n\"\n      \"Content-Type: text/xml; charset=utf-8\\r\\n\\r\\n\"\n      \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\"\n      \"<d:multistatus xmlns:d='DAV:'>\\n\"\n      \"<D:lockdiscovery>\\n\"\n      \"<D:activelock>\\n\"\n      \"<D:locktoken>\\n\"\n      \"<D:href>\\n\"\n      \"opaquelocktoken:%s%u\"\n      \"</D:href>\"\n      \"</D:locktoken>\"\n      \"</D:activelock>\\n\"\n      \"</D:lockdiscovery>\"\n      \"</d:multistatus>\\n\";\n  mg_printf(nc, reply, path, (unsigned int) mg_time());\n  nc->flags |= MG_F_SEND_AND_CLOSE;\n}\n#endif\n\nMG_INTERNAL void mg_handle_mkcol(struct mg_connection *nc, const char *path,\n                                 struct http_message *hm) {\n  int status_code = 500;\n  if (hm->body.len != (size_t) ~0 && hm->body.len > 0) {\n    status_code = 415;\n  } else if (!mg_mkdir(path, 0755)) {\n    status_code = 201;\n  } else if (errno == EEXIST) {\n    status_code = 405;\n  } else if (errno == EACCES) {\n    status_code = 403;\n  } else if (errno == ENOENT) {\n    status_code = 409;\n  } else {\n    status_code = 500;\n  }\n  mg_http_send_error(nc, status_code, NULL);\n}\n\nstatic int mg_remove_directory(const struct mg_serve_http_opts *opts,\n                               const char *dir) {\n  char path[MAX_PATH_SIZE];\n  struct dirent *dp;\n  cs_stat_t st;\n  DIR *dirp;\n\n  if ((dirp = opendir(dir)) == NULL) return 0;\n\n  while ((dp = readdir(dirp)) != NULL) {\n    if (mg_is_file_hidden((const char *) dp->d_name, opts, 1)) {\n      continue;\n    }\n    snprintf(path, sizeof(path), \"%s%c%s\", dir, '/', dp->d_name);\n    mg_stat(path, &st);\n    if (S_ISDIR(st.st_mode)) {\n      mg_remove_directory(opts, path);\n    } else {\n      remove(path);\n    }\n  }\n  closedir(dirp);\n  rmdir(dir);\n\n  return 1;\n}\n\nMG_INTERNAL void mg_handle_move(struct mg_connection *c,\n                                const struct mg_serve_http_opts *opts,\n                                const char *path, struct http_message *hm) {\n  const struct mg_str *dest = mg_get_http_header(hm, \"Destination\");\n  if (dest == NULL) {\n    mg_http_send_error(c, 411, NULL);\n  } else {\n    const char *p = (char *) memchr(dest->p, '/', dest->len);\n    if (p != NULL && p[1] == '/' &&\n        (p = (char *) memchr(p + 2, '/', dest->p + dest->len - p)) != NULL) {\n      char buf[MAX_PATH_SIZE];\n      snprintf(buf, sizeof(buf), \"%s%.*s\", opts->dav_document_root,\n               (int) (dest->p + dest->len - p), p);\n      if (rename(path, buf) == 0) {\n        mg_http_send_error(c, 200, NULL);\n      } else {\n        mg_http_send_error(c, 418, NULL);\n      }\n    } else {\n      mg_http_send_error(c, 500, NULL);\n    }\n  }\n}\n\nMG_INTERNAL void mg_handle_delete(struct mg_connection *nc,\n                                  const struct mg_serve_http_opts *opts,\n                                  const char *path) {\n  cs_stat_t st;\n  if (mg_stat(path, &st) != 0) {\n    mg_http_send_error(nc, 404, NULL);\n  } else if (S_ISDIR(st.st_mode)) {\n    mg_remove_directory(opts, path);\n    mg_http_send_error(nc, 204, NULL);\n  } else if (remove(path) == 0) {\n    mg_http_send_error(nc, 204, NULL);\n  } else {\n    mg_http_send_error(nc, 423, NULL);\n  }\n}\n\n/* Return -1 on error, 1 on success. */\nstatic int mg_create_itermediate_directories(const char *path) {\n  const char *s;\n\n  /* Create intermediate directories if they do not exist */\n  for (s = path + 1; *s != '\\0'; s++) {\n    if (*s == '/') {\n      char buf[MAX_PATH_SIZE];\n      cs_stat_t st;\n      snprintf(buf, sizeof(buf), \"%.*s\", (int) (s - path), path);\n      buf[sizeof(buf) - 1] = '\\0';\n      if (mg_stat(buf, &st) != 0 && mg_mkdir(buf, 0755) != 0) {\n        return -1;\n      }\n    }\n  }\n\n  return 1;\n}\n\nMG_INTERNAL void mg_handle_put(struct mg_connection *nc, const char *path,\n                               struct http_message *hm) {\n  struct mg_http_proto_data *pd = mg_http_get_proto_data(nc);\n  cs_stat_t st;\n  const struct mg_str *cl_hdr = mg_get_http_header(hm, \"Content-Length\");\n  int rc, status_code = mg_stat(path, &st) == 0 ? 200 : 201;\n\n  mg_http_free_proto_data_file(&pd->file);\n  if ((rc = mg_create_itermediate_directories(path)) == 0) {\n    mg_printf(nc, \"HTTP/1.1 %d OK\\r\\nContent-Length: 0\\r\\n\\r\\n\", status_code);\n  } else if (rc == -1) {\n    mg_http_send_error(nc, 500, NULL);\n  } else if (cl_hdr == NULL) {\n    mg_http_send_error(nc, 411, NULL);\n  } else if ((pd->file.fp = mg_fopen(path, \"w+b\")) == NULL) {\n    mg_http_send_error(nc, 500, NULL);\n  } else {\n    const struct mg_str *range_hdr = mg_get_http_header(hm, \"Content-Range\");\n    int64_t r1 = 0, r2 = 0;\n    pd->file.type = DATA_PUT;\n    mg_set_close_on_exec((sock_t) fileno(pd->file.fp));\n    pd->file.cl = to64(cl_hdr->p);\n    if (range_hdr != NULL &&\n        mg_http_parse_range_header(range_hdr, &r1, &r2) > 0) {\n      status_code = 206;\n      fseeko(pd->file.fp, r1, SEEK_SET);\n      pd->file.cl = r2 > r1 ? r2 - r1 + 1 : pd->file.cl - r1;\n    }\n    mg_printf(nc, \"HTTP/1.1 %d OK\\r\\nContent-Length: 0\\r\\n\\r\\n\", status_code);\n    /* Remove HTTP request from the mbuf, leave only payload */\n    mbuf_remove(&nc->recv_mbuf, hm->message.len - hm->body.len);\n    mg_http_transfer_file_data(nc);\n  }\n}\n\n#endif /* MG_ENABLE_HTTP && MG_ENABLE_HTTP_WEBDAV */\n#ifdef MG_MODULE_LINES\n#line 1 \"mongoose/src/http_websocket.c\"\n#endif\n/*\n * Copyright (c) 2014 Cesanta Software Limited\n * All rights reserved\n */\n\n#if MG_ENABLE_HTTP && MG_ENABLE_HTTP_WEBSOCKET\n\n#ifndef MG_WEBSOCKET_PING_INTERVAL_SECONDS\n#define MG_WEBSOCKET_PING_INTERVAL_SECONDS 5\n#endif\n\n#define MG_WS_NO_HOST_HEADER_MAGIC ((char *) 0x1)\n\nstatic int mg_is_ws_fragment(unsigned char flags) {\n  return (flags & 0x80) == 0 || (flags & 0x0f) == 0;\n}\n\nstatic int mg_is_ws_first_fragment(unsigned char flags) {\n  return (flags & 0x80) == 0 && (flags & 0x0f) != 0;\n}\n\nstatic void mg_handle_incoming_websocket_frame(struct mg_connection *nc,\n                                               struct websocket_message *wsm) {\n  if (wsm->flags & 0x8) {\n    mg_call(nc, nc->handler, nc->user_data, MG_EV_WEBSOCKET_CONTROL_FRAME, wsm);\n  } else {\n    mg_call(nc, nc->handler, nc->user_data, MG_EV_WEBSOCKET_FRAME, wsm);\n  }\n}\n\nstatic int mg_deliver_websocket_data(struct mg_connection *nc) {\n  /* Using unsigned char *, cause of integer arithmetic below */\n  uint64_t i, data_len = 0, frame_len = 0, buf_len = nc->recv_mbuf.len, len,\n              mask_len = 0, header_len = 0;\n  unsigned char *p = (unsigned char *) nc->recv_mbuf.buf, *buf = p,\n                *e = p + buf_len;\n  unsigned *sizep = (unsigned *) &p[1]; /* Size ptr for defragmented frames */\n  int ok, reass = buf_len > 0 && mg_is_ws_fragment(p[0]) &&\n                  !(nc->flags & MG_F_WEBSOCKET_NO_DEFRAG);\n\n  /* If that's a continuation frame that must be reassembled, handle it */\n  if (reass && !mg_is_ws_first_fragment(p[0]) &&\n      buf_len >= 1 + sizeof(*sizep) && buf_len >= 1 + sizeof(*sizep) + *sizep) {\n    buf += 1 + sizeof(*sizep) + *sizep;\n    buf_len -= 1 + sizeof(*sizep) + *sizep;\n  }\n\n  if (buf_len >= 2) {\n    len = buf[1] & 127;\n    mask_len = buf[1] & 128 ? 4 : 0;\n    if (len < 126 && buf_len >= mask_len) {\n      data_len = len;\n      header_len = 2 + mask_len;\n    } else if (len == 126 && buf_len >= 4 + mask_len) {\n      header_len = 4 + mask_len;\n      data_len = ntohs(*(uint16_t *) &buf[2]);\n    } else if (buf_len >= 10 + mask_len) {\n      header_len = 10 + mask_len;\n      data_len = (((uint64_t) ntohl(*(uint32_t *) &buf[2])) << 32) +\n                 ntohl(*(uint32_t *) &buf[6]);\n    }\n  }\n\n  frame_len = header_len + data_len;\n  ok = frame_len > 0 && frame_len <= buf_len;\n\n  if (ok) {\n    struct websocket_message wsm;\n\n    wsm.size = (size_t) data_len;\n    wsm.data = buf + header_len;\n    wsm.flags = buf[0];\n\n    /* Apply mask if necessary */\n    if (mask_len > 0) {\n      for (i = 0; i < data_len; i++) {\n        buf[i + header_len] ^= (buf + header_len - mask_len)[i % 4];\n      }\n    }\n\n    if (reass) {\n      /* On first fragmented frame, nullify size */\n      if (mg_is_ws_first_fragment(wsm.flags)) {\n        mbuf_resize(&nc->recv_mbuf, nc->recv_mbuf.size + sizeof(*sizep));\n        p[0] &= ~0x0f; /* Next frames will be treated as continuation */\n        buf = p + 1 + sizeof(*sizep);\n        *sizep = 0; /* TODO(lsm): fix. this can stomp over frame data */\n      }\n\n      /* Append this frame to the reassembled buffer */\n      memmove(buf, wsm.data, e - wsm.data);\n      (*sizep) += wsm.size;\n      nc->recv_mbuf.len -= wsm.data - buf;\n\n      /* On last fragmented frame - call user handler and remove data */\n      if (wsm.flags & 0x80) {\n        wsm.data = p + 1 + sizeof(*sizep);\n        wsm.size = *sizep;\n        mg_handle_incoming_websocket_frame(nc, &wsm);\n        mbuf_remove(&nc->recv_mbuf, 1 + sizeof(*sizep) + *sizep);\n      }\n    } else {\n      /* TODO(lsm): properly handle OOB control frames during defragmentation */\n      mg_handle_incoming_websocket_frame(nc, &wsm);\n      mbuf_remove(&nc->recv_mbuf, (size_t) frame_len); /* Cleanup frame */\n    }\n\n    /* If the frame is not reassembled - client closes and close too */\n    if (!reass && (buf[0] & 0x0f) == WEBSOCKET_OP_CLOSE) {\n      nc->flags |= MG_F_SEND_AND_CLOSE;\n    }\n  }\n\n  return ok;\n}\n\nstruct ws_mask_ctx {\n  size_t pos; /* zero means unmasked */\n  uint32_t mask;\n};\n\nstatic uint32_t mg_ws_random_mask(void) {\n  uint32_t mask;\n/*\n * The spec requires WS client to generate hard to\n * guess mask keys. From RFC6455, Section 5.3:\n *\n * The unpredictability of the masking key is essential to prevent\n * authors of malicious applications from selecting the bytes that appear on\n * the wire.\n *\n * Hence this feature is essential when the actual end user of this API\n * is untrusted code that wouldn't have access to a lower level net API\n * anyway (e.g. web browsers). Hence this feature is low prio for most\n * mongoose use cases and thus can be disabled, e.g. when porting to a platform\n * that lacks rand().\n */\n#if MG_DISABLE_WS_RANDOM_MASK\n  mask = 0xefbeadde; /* generated with a random number generator, I swear */\n#else\n  if (sizeof(long) >= 4) {\n    mask = (uint32_t) rand();\n  } else if (sizeof(long) == 2) {\n    mask = (uint32_t) rand() << 16 | (uint32_t) rand();\n  }\n#endif\n  return mask;\n}\n\nstatic void mg_send_ws_header(struct mg_connection *nc, int op, size_t len,\n                              struct ws_mask_ctx *ctx) {\n  int header_len;\n  unsigned char header[10];\n\n  header[0] = (op & WEBSOCKET_DONT_FIN ? 0x0 : 0x80) + (op & 0x0f);\n  if (len < 126) {\n    header[1] = (unsigned char) len;\n    header_len = 2;\n  } else if (len < 65535) {\n    uint16_t tmp = htons((uint16_t) len);\n    header[1] = 126;\n    memcpy(&header[2], &tmp, sizeof(tmp));\n    header_len = 4;\n  } else {\n    uint32_t tmp;\n    header[1] = 127;\n    tmp = htonl((uint32_t)((uint64_t) len >> 32));\n    memcpy(&header[2], &tmp, sizeof(tmp));\n    tmp = htonl((uint32_t)(len & 0xffffffff));\n    memcpy(&header[6], &tmp, sizeof(tmp));\n    header_len = 10;\n  }\n\n  /* client connections enable masking */\n  if (nc->listener == NULL) {\n    header[1] |= 1 << 7; /* set masking flag */\n    mg_send(nc, header, header_len);\n    ctx->mask = mg_ws_random_mask();\n    mg_send(nc, &ctx->mask, sizeof(ctx->mask));\n    ctx->pos = nc->send_mbuf.len;\n  } else {\n    mg_send(nc, header, header_len);\n    ctx->pos = 0;\n  }\n}\n\nstatic void mg_ws_mask_frame(struct mbuf *mbuf, struct ws_mask_ctx *ctx) {\n  size_t i;\n  if (ctx->pos == 0) return;\n  for (i = 0; i < (mbuf->len - ctx->pos); i++) {\n    mbuf->buf[ctx->pos + i] ^= ((char *) &ctx->mask)[i % 4];\n  }\n}\n\nvoid mg_send_websocket_frame(struct mg_connection *nc, int op, const void *data,\n                             size_t len) {\n  struct ws_mask_ctx ctx;\n  DBG((\"%p %d %d\", nc, op, (int) len));\n  mg_send_ws_header(nc, op, len, &ctx);\n  mg_send(nc, data, len);\n\n  mg_ws_mask_frame(&nc->send_mbuf, &ctx);\n\n  if (op == WEBSOCKET_OP_CLOSE) {\n    nc->flags |= MG_F_SEND_AND_CLOSE;\n  }\n}\n\nvoid mg_send_websocket_framev(struct mg_connection *nc, int op,\n                              const struct mg_str *strv, int strvcnt) {\n  struct ws_mask_ctx ctx;\n  int i;\n  int len = 0;\n  for (i = 0; i < strvcnt; i++) {\n    len += strv[i].len;\n  }\n\n  mg_send_ws_header(nc, op, len, &ctx);\n\n  for (i = 0; i < strvcnt; i++) {\n    mg_send(nc, strv[i].p, strv[i].len);\n  }\n\n  mg_ws_mask_frame(&nc->send_mbuf, &ctx);\n\n  if (op == WEBSOCKET_OP_CLOSE) {\n    nc->flags |= MG_F_SEND_AND_CLOSE;\n  }\n}\n\nvoid mg_printf_websocket_frame(struct mg_connection *nc, int op,\n                               const char *fmt, ...) {\n  char mem[MG_VPRINTF_BUFFER_SIZE], *buf = mem;\n  va_list ap;\n  int len;\n\n  va_start(ap, fmt);\n  if ((len = mg_avprintf(&buf, sizeof(mem), fmt, ap)) > 0) {\n    mg_send_websocket_frame(nc, op, buf, len);\n  }\n  va_end(ap);\n\n  if (buf != mem && buf != NULL) {\n    MG_FREE(buf);\n  }\n}\n\nMG_INTERNAL void mg_ws_handler(struct mg_connection *nc, int ev,\n                               void *ev_data MG_UD_ARG(void *user_data)) {\n  mg_call(nc, nc->handler, nc->user_data, ev, ev_data);\n\n  switch (ev) {\n    case MG_EV_RECV:\n      do {\n      } while (mg_deliver_websocket_data(nc));\n      break;\n    case MG_EV_POLL:\n      /* Ping idle websocket connections */\n      {\n        time_t now = *(time_t *) ev_data;\n        if (nc->flags & MG_F_IS_WEBSOCKET &&\n            now > nc->last_io_time + MG_WEBSOCKET_PING_INTERVAL_SECONDS) {\n          mg_send_websocket_frame(nc, WEBSOCKET_OP_PING, \"\", 0);\n        }\n      }\n      break;\n    default:\n      break;\n  }\n#if MG_ENABLE_CALLBACK_USERDATA\n  (void) user_data;\n#endif\n}\n\n#ifndef MG_EXT_SHA1\nstatic void mg_hash_sha1_v(size_t num_msgs, const uint8_t *msgs[],\n                           const size_t *msg_lens, uint8_t *digest) {\n  size_t i;\n  cs_sha1_ctx sha_ctx;\n  cs_sha1_init(&sha_ctx);\n  for (i = 0; i < num_msgs; i++) {\n    cs_sha1_update(&sha_ctx, msgs[i], msg_lens[i]);\n  }\n  cs_sha1_final(digest, &sha_ctx);\n}\n#else\nextern void mg_hash_sha1_v(size_t num_msgs, const uint8_t *msgs[],\n                           const size_t *msg_lens, uint8_t *digest);\n#endif\n\nMG_INTERNAL void mg_ws_handshake(struct mg_connection *nc,\n                                 const struct mg_str *key) {\n  static const char *magic = \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\n  const uint8_t *msgs[2] = {(const uint8_t *) key->p, (const uint8_t *) magic};\n  const size_t msg_lens[2] = {key->len, 36};\n  unsigned char sha[20];\n  char b64_sha[30];\n\n  mg_hash_sha1_v(2, msgs, msg_lens, sha);\n  mg_base64_encode(sha, sizeof(sha), b64_sha);\n  mg_printf(nc, \"%s%s%s\",\n            \"HTTP/1.1 101 Switching Protocols\\r\\n\"\n            \"Upgrade: websocket\\r\\n\"\n            \"Connection: Upgrade\\r\\n\"\n            \"Sec-WebSocket-Accept: \",\n            b64_sha, \"\\r\\n\\r\\n\");\n  DBG((\"%p %.*s %s\", nc, (int) key->len, key->p, b64_sha));\n}\n\nvoid mg_send_websocket_handshake2(struct mg_connection *nc, const char *path,\n                                  const char *host, const char *protocol,\n                                  const char *extra_headers) {\n  mg_send_websocket_handshake3(nc, path, host, protocol, extra_headers, NULL,\n                               NULL);\n}\n\nvoid mg_send_websocket_handshake3(struct mg_connection *nc, const char *path,\n                                  const char *host, const char *protocol,\n                                  const char *extra_headers, const char *user,\n                                  const char *pass) {\n  struct mbuf auth;\n  char key[25];\n  uint32_t nonce[4];\n  nonce[0] = mg_ws_random_mask();\n  nonce[1] = mg_ws_random_mask();\n  nonce[2] = mg_ws_random_mask();\n  nonce[3] = mg_ws_random_mask();\n  mg_base64_encode((unsigned char *) &nonce, sizeof(nonce), key);\n\n  mbuf_init(&auth, 0);\n  if (user != NULL) {\n    mg_basic_auth_header(user, pass, &auth);\n  }\n\n  /*\n   * NOTE: the  (auth.buf == NULL ? \"\" : auth.buf) is because cc3200 libc is\n   * broken: it doesn't like zero length to be passed to %.*s\n   * i.e. sprintf(\"f%.*so\", (int)0, NULL), yields `f\\0o`.\n   * because it handles NULL specially (and incorrectly).\n   */\n  mg_printf(nc,\n            \"GET %s HTTP/1.1\\r\\n\"\n            \"Upgrade: websocket\\r\\n\"\n            \"Connection: Upgrade\\r\\n\"\n            \"%.*s\"\n            \"Sec-WebSocket-Version: 13\\r\\n\"\n            \"Sec-WebSocket-Key: %s\\r\\n\",\n            path, (int) auth.len, (auth.buf == NULL ? \"\" : auth.buf), key);\n\n  /* TODO(mkm): take default hostname from http proto data if host == NULL */\n  if (host != MG_WS_NO_HOST_HEADER_MAGIC) {\n    mg_printf(nc, \"Host: %s\\r\\n\", host);\n  }\n  if (protocol != NULL) {\n    mg_printf(nc, \"Sec-WebSocket-Protocol: %s\\r\\n\", protocol);\n  }\n  if (extra_headers != NULL) {\n    mg_printf(nc, \"%s\", extra_headers);\n  }\n  mg_printf(nc, \"\\r\\n\");\n\n  mbuf_free(&auth);\n}\n\nvoid mg_send_websocket_handshake(struct mg_connection *nc, const char *path,\n                                 const char *extra_headers) {\n  mg_send_websocket_handshake2(nc, path, MG_WS_NO_HOST_HEADER_MAGIC, NULL,\n                               extra_headers);\n}\n\nstruct mg_connection *mg_connect_ws_opt(\n    struct mg_mgr *mgr, MG_CB(mg_event_handler_t ev_handler, void *user_data),\n    struct mg_connect_opts opts, const char *url, const char *protocol,\n    const char *extra_headers) {\n  char *user = NULL, *pass = NULL, *addr = NULL;\n  const char *path = NULL;\n  struct mg_connection *nc =\n      mg_connect_http_base(mgr, MG_CB(ev_handler, user_data), opts, \"ws://\",\n                           \"wss://\", url, &path, &user, &pass, &addr);\n\n  if (nc != NULL) {\n    mg_send_websocket_handshake3(nc, path, addr, protocol, extra_headers, user,\n                                 pass);\n  }\n\n  MG_FREE(addr);\n  MG_FREE(user);\n  MG_FREE(pass);\n  return nc;\n}\n\nstruct mg_connection *mg_connect_ws(\n    struct mg_mgr *mgr, MG_CB(mg_event_handler_t ev_handler, void *user_data),\n    const char *url, const char *protocol, const char *extra_headers) {\n  struct mg_connect_opts opts;\n  memset(&opts, 0, sizeof(opts));\n  return mg_connect_ws_opt(mgr, MG_CB(ev_handler, user_data), opts, url,\n                           protocol, extra_headers);\n}\n#endif /* MG_ENABLE_HTTP && MG_ENABLE_HTTP_WEBSOCKET */\n#ifdef MG_MODULE_LINES\n#line 1 \"mongoose/src/util.c\"\n#endif\n/*\n * Copyright (c) 2014 Cesanta Software Limited\n * All rights reserved\n */\n\n/* Amalgamated: #include \"common/base64.h\" */\n/* Amalgamated: #include \"mongoose/src/internal.h\" */\n/* Amalgamated: #include \"mongoose/src/util.h\" */\n\n/* For platforms with limited libc */\n#ifndef MAX\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n#endif\n\nconst char *mg_skip(const char *s, const char *end, const char *delims,\n                    struct mg_str *v) {\n  v->p = s;\n  while (s < end && strchr(delims, *(unsigned char *) s) == NULL) s++;\n  v->len = s - v->p;\n  while (s < end && strchr(delims, *(unsigned char *) s) != NULL) s++;\n  return s;\n}\n\nstatic int lowercase(const char *s) {\n  return tolower(*(const unsigned char *) s);\n}\n\n#if MG_ENABLE_FILESYSTEM && !defined(MG_USER_FILE_FUNCTIONS)\nint mg_stat(const char *path, cs_stat_t *st) {\n#ifdef _WIN32\n  wchar_t wpath[MAX_PATH_SIZE];\n  to_wchar(path, wpath, ARRAY_SIZE(wpath));\n  DBG((\"[%ls] -> %d\", wpath, _wstati64(wpath, st)));\n  return _wstati64(wpath, st);\n#else\n  return stat(path, st);\n#endif\n}\n\nFILE *mg_fopen(const char *path, const char *mode) {\n#ifdef _WIN32\n  wchar_t wpath[MAX_PATH_SIZE], wmode[10];\n  to_wchar(path, wpath, ARRAY_SIZE(wpath));\n  to_wchar(mode, wmode, ARRAY_SIZE(wmode));\n  return _wfopen(wpath, wmode);\n#else\n  return fopen(path, mode);\n#endif\n}\n\nint mg_open(const char *path, int flag, int mode) { /* LCOV_EXCL_LINE */\n#if defined(_WIN32) && !defined(WINCE)\n  wchar_t wpath[MAX_PATH_SIZE];\n  to_wchar(path, wpath, ARRAY_SIZE(wpath));\n  return _wopen(wpath, flag, mode);\n#else\n  return open(path, flag, mode); /* LCOV_EXCL_LINE */\n#endif\n}\n\nsize_t mg_fread(void *ptr, size_t size, size_t count, FILE *f) {\n  return fread(ptr, size, count, f);\n}\n\nsize_t mg_fwrite(const void *ptr, size_t size, size_t count, FILE *f) {\n  return fwrite(ptr, size, count, f);\n}\n#endif\n\nvoid mg_base64_encode(const unsigned char *src, int src_len, char *dst) {\n  cs_base64_encode(src, src_len, dst);\n}\n\nint mg_base64_decode(const unsigned char *s, int len, char *dst) {\n  return cs_base64_decode(s, len, dst, NULL);\n}\n\n#if MG_ENABLE_THREADS\nvoid *mg_start_thread(void *(*f)(void *), void *p) {\n#ifdef WINCE\n  return (void *) CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) f, p, 0, NULL);\n#elif defined(_WIN32)\n  return (void *) _beginthread((void(__cdecl *) (void *) ) f, 0, p);\n#else\n  pthread_t thread_id = (pthread_t) 0;\n  pthread_attr_t attr;\n\n  (void) pthread_attr_init(&attr);\n  (void) pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\n#if defined(MG_STACK_SIZE) && MG_STACK_SIZE > 1\n  (void) pthread_attr_setstacksize(&attr, MG_STACK_SIZE);\n#endif\n\n  pthread_create(&thread_id, &attr, f, p);\n  pthread_attr_destroy(&attr);\n\n  return (void *) thread_id;\n#endif\n}\n#endif /* MG_ENABLE_THREADS */\n\n/* Set close-on-exec bit for a given socket. */\nvoid mg_set_close_on_exec(sock_t sock) {\n#if defined(_WIN32) && !defined(WINCE)\n  (void) SetHandleInformation((HANDLE) sock, HANDLE_FLAG_INHERIT, 0);\n#elif defined(__unix__)\n  fcntl(sock, F_SETFD, FD_CLOEXEC);\n#else\n  (void) sock;\n#endif\n}\n\nvoid mg_sock_addr_to_str(const union socket_address *sa, char *buf, size_t len,\n                         int flags) {\n  int is_v6;\n  if (buf == NULL || len <= 0) return;\n  memset(buf, 0, len);\n#if MG_ENABLE_IPV6\n  is_v6 = sa->sa.sa_family == AF_INET6;\n#else\n  is_v6 = 0;\n#endif\n  if (flags & MG_SOCK_STRINGIFY_IP) {\n#if MG_ENABLE_IPV6\n    const void *addr = NULL;\n    char *start = buf;\n    socklen_t capacity = len;\n    if (!is_v6) {\n      addr = &sa->sin.sin_addr;\n    } else {\n      addr = (void *) &sa->sin6.sin6_addr;\n      if (flags & MG_SOCK_STRINGIFY_PORT) {\n        *buf = '[';\n        start++;\n        capacity--;\n      }\n    }\n    if (inet_ntop(sa->sa.sa_family, addr, start, capacity) == NULL) {\n      goto cleanup;\n    }\n#elif defined(_WIN32) || MG_LWIP || (MG_NET_IF == MG_NET_IF_PIC32)\n    /* Only Windoze Vista (and newer) have inet_ntop() */\n    char *addr_str = inet_ntoa(sa->sin.sin_addr);\n    if (addr_str != NULL) {\n      strncpy(buf, inet_ntoa(sa->sin.sin_addr), len - 1);\n    } else {\n      goto cleanup;\n    }\n#else\n    if (inet_ntop(AF_INET, (void *) &sa->sin.sin_addr, buf, len - 1) == NULL) {\n      goto cleanup;\n    }\n#endif\n  }\n  if (flags & MG_SOCK_STRINGIFY_PORT) {\n    int port = ntohs(sa->sin.sin_port);\n    if (flags & MG_SOCK_STRINGIFY_IP) {\n      int buf_len = strlen(buf);\n      snprintf(buf + buf_len, len - (buf_len + 1), \"%s:%d\", (is_v6 ? \"]\" : \"\"),\n               port);\n    } else {\n      snprintf(buf, len, \"%d\", port);\n    }\n  }\n\n  return;\n\ncleanup:\n  *buf = '\\0';\n}\n\nvoid mg_conn_addr_to_str(struct mg_connection *nc, char *buf, size_t len,\n                         int flags) {\n  union socket_address sa;\n  memset(&sa, 0, sizeof(sa));\n  mg_if_get_conn_addr(nc, flags & MG_SOCK_STRINGIFY_REMOTE, &sa);\n  mg_sock_addr_to_str(&sa, buf, len, flags);\n}\n\n#if MG_ENABLE_HEXDUMP\nstatic int mg_hexdump_n(const void *buf, int len, char *dst, int dst_len,\n                        int offset) {\n  const unsigned char *p = (const unsigned char *) buf;\n  char ascii[17] = \"\";\n  int i, idx, n = 0;\n\n  for (i = 0; i < len; i++) {\n    idx = i % 16;\n    if (idx == 0) {\n      if (i > 0) n += snprintf(dst + n, MAX(dst_len - n, 0), \"  %s\\n\", ascii);\n      n += snprintf(dst + n, MAX(dst_len - n, 0), \"%04x \", i + offset);\n    }\n    if (dst_len - n < 0) {\n      return n;\n    }\n    n += snprintf(dst + n, MAX(dst_len - n, 0), \" %02x\", p[i]);\n    ascii[idx] = p[i] < 0x20 || p[i] > 0x7e ? '.' : p[i];\n    ascii[idx + 1] = '\\0';\n  }\n\n  while (i++ % 16) n += snprintf(dst + n, MAX(dst_len - n, 0), \"%s\", \"   \");\n  n += snprintf(dst + n, MAX(dst_len - n, 0), \"  %s\\n\", ascii);\n\n  return n;\n}\n\nint mg_hexdump(const void *buf, int len, char *dst, int dst_len) {\n  return mg_hexdump_n(buf, len, dst, dst_len, 0);\n}\n\nvoid mg_hexdumpf(FILE *fp, const void *buf, int len) {\n  char tmp[80];\n  int offset = 0, n;\n  while (len > 0) {\n    n = (len < 16 ? len : 16);\n    mg_hexdump_n(((const char *) buf) + offset, n, tmp, sizeof(tmp), offset);\n    fputs(tmp, fp);\n    offset += n;\n    len -= n;\n  }\n}\n\nvoid mg_hexdump_connection(struct mg_connection *nc, const char *path,\n                           const void *buf, int num_bytes, int ev) {\n  FILE *fp = NULL;\n  char *hexbuf, src[60], dst[60];\n  int buf_size = num_bytes * 5 + 100;\n\n  if (strcmp(path, \"-\") == 0) {\n    fp = stdout;\n  } else if (strcmp(path, \"--\") == 0) {\n    fp = stderr;\n#if MG_ENABLE_FILESYSTEM\n  } else {\n    fp = mg_fopen(path, \"a\");\n#endif\n  }\n  if (fp == NULL) return;\n\n  mg_conn_addr_to_str(nc, src, sizeof(src),\n                      MG_SOCK_STRINGIFY_IP | MG_SOCK_STRINGIFY_PORT);\n  mg_conn_addr_to_str(nc, dst, sizeof(dst), MG_SOCK_STRINGIFY_IP |\n                                                MG_SOCK_STRINGIFY_PORT |\n                                                MG_SOCK_STRINGIFY_REMOTE);\n  fprintf(\n      fp, \"%lu %p %s %s %s %d\\n\", (unsigned long) mg_time(), (void *) nc, src,\n      ev == MG_EV_RECV ? \"<-\" : ev == MG_EV_SEND\n                                    ? \"->\"\n                                    : ev == MG_EV_ACCEPT\n                                          ? \"<A\"\n                                          : ev == MG_EV_CONNECT ? \"C>\" : \"XX\",\n      dst, num_bytes);\n  if (num_bytes > 0 && (hexbuf = (char *) MG_MALLOC(buf_size)) != NULL) {\n    mg_hexdump(buf, num_bytes, hexbuf, buf_size);\n    fprintf(fp, \"%s\", hexbuf);\n    MG_FREE(hexbuf);\n  }\n  if (fp != stdin && fp != stdout) fclose(fp);\n}\n#endif\n\nint mg_is_big_endian(void) {\n  static const int n = 1;\n  /* TODO(mkm) use compiletime check with 4-byte char literal */\n  return ((char *) &n)[0] == 0;\n}\n\nconst char *mg_next_comma_list_entry(const char *list, struct mg_str *val,\n                                     struct mg_str *eq_val) {\n  if (list == NULL || *list == '\\0') {\n    /* End of the list */\n    list = NULL;\n  } else {\n    val->p = list;\n    if ((list = strchr(val->p, ',')) != NULL) {\n      /* Comma found. Store length and shift the list ptr */\n      val->len = list - val->p;\n      list++;\n    } else {\n      /* This value is the last one */\n      list = val->p + strlen(val->p);\n      val->len = list - val->p;\n    }\n\n    if (eq_val != NULL) {\n      /* Value has form \"x=y\", adjust pointers and lengths */\n      /* so that val points to \"x\", and eq_val points to \"y\". */\n      eq_val->len = 0;\n      eq_val->p = (const char *) memchr(val->p, '=', val->len);\n      if (eq_val->p != NULL) {\n        eq_val->p++; /* Skip over '=' character */\n        eq_val->len = val->p + val->len - eq_val->p;\n        val->len = (eq_val->p - val->p) - 1;\n      }\n    }\n  }\n\n  return list;\n}\n\nint mg_match_prefix_n(const struct mg_str pattern, const struct mg_str str) {\n  const char *or_str;\n  size_t len, i = 0, j = 0;\n  int res;\n\n  if ((or_str = (const char *) memchr(pattern.p, '|', pattern.len)) != NULL) {\n    struct mg_str pstr = {pattern.p, (size_t)(or_str - pattern.p)};\n    res = mg_match_prefix_n(pstr, str);\n    if (res > 0) return res;\n    pstr.p = or_str + 1;\n    pstr.len = (pattern.p + pattern.len) - (or_str + 1);\n    return mg_match_prefix_n(pstr, str);\n  }\n\n  for (; i < pattern.len; i++, j++) {\n    if (pattern.p[i] == '?' && j != str.len) {\n      continue;\n    } else if (pattern.p[i] == '$') {\n      return j == str.len ? (int) j : -1;\n    } else if (pattern.p[i] == '*') {\n      i++;\n      if (pattern.p[i] == '*') {\n        i++;\n        len = str.len - j;\n      } else {\n        len = 0;\n        while (j + len != str.len && str.p[j + len] != '/') {\n          len++;\n        }\n      }\n      if (i == pattern.len) {\n        return j + len;\n      }\n      do {\n        const struct mg_str pstr = {pattern.p + i, pattern.len - i};\n        const struct mg_str sstr = {str.p + j + len, str.len - j - len};\n        res = mg_match_prefix_n(pstr, sstr);\n      } while (res == -1 && len-- > 0);\n      return res == -1 ? -1 : (int) (j + res + len);\n    } else if (lowercase(&pattern.p[i]) != lowercase(&str.p[j])) {\n      return -1;\n    }\n  }\n  return j;\n}\n\nint mg_match_prefix(const char *pattern, int pattern_len, const char *str) {\n  const struct mg_str pstr = {pattern, (size_t) pattern_len};\n  return mg_match_prefix_n(pstr, mg_mk_str(str));\n}\n\nDO_NOT_WARN_UNUSED MG_INTERNAL int mg_get_errno(void) {\n#ifndef WINCE\n  return errno;\n#else\n  /* TODO(alashkin): translate error codes? */\n  return GetLastError();\n#endif\n}\n\nvoid mg_mbuf_append_base64_putc(char ch, void *user_data) {\n  struct mbuf *mbuf = (struct mbuf *) user_data;\n  mbuf_append(mbuf, &ch, sizeof(ch));\n}\n\nvoid mg_mbuf_append_base64(struct mbuf *mbuf, const void *data, size_t len) {\n  struct cs_base64_ctx ctx;\n  cs_base64_init(&ctx, mg_mbuf_append_base64_putc, mbuf);\n  cs_base64_update(&ctx, (const char *) data, len);\n  cs_base64_finish(&ctx);\n}\n\nvoid mg_basic_auth_header(const char *user, const char *pass,\n                          struct mbuf *buf) {\n  const char *header_prefix = \"Authorization: Basic \";\n  const char *header_suffix = \"\\r\\n\";\n\n  struct cs_base64_ctx ctx;\n  cs_base64_init(&ctx, mg_mbuf_append_base64_putc, buf);\n\n  mbuf_append(buf, header_prefix, strlen(header_prefix));\n\n  cs_base64_update(&ctx, user, strlen(user));\n  if (pass != NULL) {\n    cs_base64_update(&ctx, \":\", 1);\n    cs_base64_update(&ctx, pass, strlen(pass));\n  }\n  cs_base64_finish(&ctx);\n  mbuf_append(buf, header_suffix, strlen(header_suffix));\n}\n#ifdef MG_MODULE_LINES\n#line 1 \"mongoose/src/mqtt.c\"\n#endif\n/*\n * Copyright (c) 2014 Cesanta Software Limited\n * All rights reserved\n */\n\n#if MG_ENABLE_MQTT\n\n#include <string.h>\n\n/* Amalgamated: #include \"mongoose/src/internal.h\" */\n/* Amalgamated: #include \"mongoose/src/mqtt.h\" */\n\nstatic uint16_t getu16(const char *p) {\n  const uint8_t *up = (const uint8_t *) p;\n  return (up[0] << 8) + up[1];\n}\n\nstatic const char *scanto(const char *p, struct mg_str *s) {\n  s->len = getu16(p);\n  s->p = p + 2;\n  return s->p + s->len;\n}\n\nMG_INTERNAL int parse_mqtt(struct mbuf *io, struct mg_mqtt_message *mm) {\n  uint8_t header;\n  size_t len = 0;\n  int cmd;\n  const char *p = &io->buf[1], *end;\n\n  if (io->len < 2) return -1;\n  header = io->buf[0];\n  cmd = header >> 4;\n\n  /* decode mqtt variable length */\n  do {\n    len += (*p & 127) << 7 * (p - &io->buf[1]);\n  } while ((*p++ & 128) != 0 && ((size_t)(p - io->buf) <= io->len));\n\n  end = p + len;\n  if (end > io->buf + io->len + 1) {\n    return -1;\n  }\n\n  mm->cmd = cmd;\n  mm->qos = MG_MQTT_GET_QOS(header);\n\n  switch (cmd) {\n    case MG_MQTT_CMD_CONNECT: {\n      p = scanto(p, &mm->protocol_name);\n      mm->protocol_version = *(uint8_t *) p++;\n      mm->connect_flags = *(uint8_t *) p++;\n      mm->keep_alive_timer = getu16(p);\n      p += 2;\n      if (p < end) p = scanto(p, &mm->client_id);\n      if (p < end && (mm->connect_flags & MG_MQTT_HAS_WILL))\n        p = scanto(p, &mm->will_topic);\n      if (p < end && (mm->connect_flags & MG_MQTT_HAS_WILL))\n        p = scanto(p, &mm->will_message);\n      if (p < end && (mm->connect_flags & MG_MQTT_HAS_USER_NAME))\n        p = scanto(p, &mm->user_name);\n      if (p < end && (mm->connect_flags & MG_MQTT_HAS_PASSWORD))\n        p = scanto(p, &mm->password);\n\n      LOG(LL_DEBUG,\n          (\"%d %2x %d proto [%.*s] client_id [%.*s] will_topic [%.*s] \"\n           \"will_msg [%.*s] user_name [%.*s] password [%.*s]\",\n           len, (int) mm->connect_flags, (int) mm->keep_alive_timer,\n           (int) mm->protocol_name.len, mm->protocol_name.p,\n           (int) mm->client_id.len, mm->client_id.p, (int) mm->will_topic.len,\n           mm->will_topic.p, (int) mm->will_message.len, mm->will_message.p,\n           (int) mm->user_name.len, mm->user_name.p, (int) mm->password.len,\n           mm->password.p));\n      break;\n    }\n    case MG_MQTT_CMD_CONNACK:\n      mm->connack_ret_code = p[1];\n      break;\n    case MG_MQTT_CMD_PUBACK:\n    case MG_MQTT_CMD_PUBREC:\n    case MG_MQTT_CMD_PUBREL:\n    case MG_MQTT_CMD_PUBCOMP:\n    case MG_MQTT_CMD_SUBACK:\n      mm->message_id = getu16(p);\n      break;\n    case MG_MQTT_CMD_PUBLISH: {\n      p = scanto(p, &mm->topic);\n      if (mm->qos > 0) {\n        mm->message_id = getu16(p);\n        p += 2;\n      }\n      mm->payload.p = p;\n      mm->payload.len = end - p;\n      break;\n    }\n    case MG_MQTT_CMD_SUBSCRIBE:\n      mm->message_id = getu16(p);\n      p += 2;\n      /*\n       * topic expressions are left in the payload and can be parsed with\n       * `mg_mqtt_next_subscribe_topic`\n       */\n      mm->payload.p = p;\n      mm->payload.len = end - p;\n      break;\n    default:\n      /* Unhandled command */\n      break;\n  }\n\n  return end - io->buf;\n}\n\nstatic void mqtt_handler(struct mg_connection *nc, int ev,\n                         void *ev_data MG_UD_ARG(void *user_data)) {\n  int len;\n  struct mbuf *io = &nc->recv_mbuf;\n  struct mg_mqtt_message mm;\n  memset(&mm, 0, sizeof(mm));\n\n  nc->handler(nc, ev, ev_data MG_UD_ARG(user_data));\n\n  switch (ev) {\n    case MG_EV_RECV:\n      len = parse_mqtt(io, &mm);\n      if (len == -1) break; /* not fully buffered */\n      nc->handler(nc, MG_MQTT_EVENT_BASE + mm.cmd, &mm MG_UD_ARG(user_data));\n      mbuf_remove(io, len);\n      break;\n  }\n}\n\nstatic void mg_mqtt_proto_data_destructor(void *proto_data) {\n  MG_FREE(proto_data);\n}\n\nint mg_mqtt_match_topic_expression(struct mg_str exp, struct mg_str topic) {\n  /* TODO(mkm): implement real matching */\n  if (memchr(exp.p, '#', exp.len)) {\n    /* exp `foo/#` will become `foo/` */\n    exp.len -= 1;\n    /*\n     * topic should be longer than the expression: e.g. topic `foo/bar` does\n     * match `foo/#`, but neither `foo` nor `foo/` do.\n     */\n    if (topic.len <= exp.len) {\n      return 0;\n    }\n\n    /* Truncate topic so that it'll pass the next length check */\n    topic.len = exp.len;\n  }\n  if (topic.len != exp.len) {\n    return 0;\n  }\n  return strncmp(topic.p, exp.p, exp.len) == 0;\n}\n\nint mg_mqtt_vmatch_topic_expression(const char *exp, struct mg_str topic) {\n  return mg_mqtt_match_topic_expression(mg_mk_str(exp), topic);\n}\n\nvoid mg_set_protocol_mqtt(struct mg_connection *nc) {\n  nc->proto_handler = mqtt_handler;\n  nc->proto_data = MG_CALLOC(1, sizeof(struct mg_mqtt_proto_data));\n  nc->proto_data_destructor = mg_mqtt_proto_data_destructor;\n}\n\nvoid mg_send_mqtt_handshake(struct mg_connection *nc, const char *client_id) {\n  static struct mg_send_mqtt_handshake_opts opts;\n  mg_send_mqtt_handshake_opt(nc, client_id, opts);\n}\n\nvoid mg_send_mqtt_handshake_opt(struct mg_connection *nc, const char *client_id,\n                                struct mg_send_mqtt_handshake_opts opts) {\n  uint8_t header = MG_MQTT_CMD_CONNECT << 4;\n  uint8_t rem_len;\n  uint16_t keep_alive;\n  uint16_t len;\n  struct mg_mqtt_proto_data *pd = (struct mg_mqtt_proto_data *) nc->proto_data;\n\n  /*\n   * 9: version_header(len, magic_string, version_number), 1: flags, 2:\n   * keep-alive timer,\n   * 2: client_identifier_len, n: client_id\n   */\n  rem_len = 9 + 1 + 2 + 2 + (uint8_t) strlen(client_id);\n\n  if (opts.user_name != NULL) {\n    opts.flags |= MG_MQTT_HAS_USER_NAME;\n    rem_len += (uint8_t) strlen(opts.user_name) + 2;\n  }\n  if (opts.password != NULL) {\n    opts.flags |= MG_MQTT_HAS_PASSWORD;\n    rem_len += (uint8_t) strlen(opts.password) + 2;\n  }\n  if (opts.will_topic != NULL && opts.will_message != NULL) {\n    opts.flags |= MG_MQTT_HAS_WILL;\n    rem_len += (uint8_t) strlen(opts.will_topic) + 2;\n    rem_len += (uint8_t) strlen(opts.will_message) + 2;\n  }\n\n  mg_send(nc, &header, 1);\n  mg_send(nc, &rem_len, 1);\n  mg_send(nc, \"\\00\\06MQIsdp\\03\", 9);\n  mg_send(nc, &opts.flags, 1);\n\n  if (opts.keep_alive == 0) {\n    opts.keep_alive = 60;\n  }\n\n  keep_alive = htons(opts.keep_alive);\n  mg_send(nc, &keep_alive, 2);\n\n  len = htons((uint16_t) strlen(client_id));\n  mg_send(nc, &len, 2);\n  mg_send(nc, client_id, strlen(client_id));\n\n  if (opts.flags & MG_MQTT_HAS_WILL) {\n    len = htons((uint16_t) strlen(opts.will_topic));\n    mg_send(nc, &len, 2);\n    mg_send(nc, opts.will_topic, strlen(opts.will_topic));\n\n    len = htons((uint16_t) strlen(opts.will_message));\n    mg_send(nc, &len, 2);\n    mg_send(nc, opts.will_message, strlen(opts.will_message));\n  }\n\n  if (opts.flags & MG_MQTT_HAS_USER_NAME) {\n    len = htons((uint16_t) strlen(opts.user_name));\n    mg_send(nc, &len, 2);\n    mg_send(nc, opts.user_name, strlen(opts.user_name));\n  }\n  if (opts.flags & MG_MQTT_HAS_PASSWORD) {\n    len = htons((uint16_t) strlen(opts.password));\n    mg_send(nc, &len, 2);\n    mg_send(nc, opts.password, strlen(opts.password));\n  }\n\n  if (pd != NULL) {\n    pd->keep_alive = opts.keep_alive;\n  }\n}\n\nstatic void mg_mqtt_prepend_header(struct mg_connection *nc, uint8_t cmd,\n                                   uint8_t flags, size_t len) {\n  size_t off = nc->send_mbuf.len - len;\n  uint8_t header = cmd << 4 | (uint8_t) flags;\n\n  uint8_t buf[1 + sizeof(size_t)];\n  uint8_t *vlen = &buf[1];\n\n  assert(nc->send_mbuf.len >= len);\n\n  buf[0] = header;\n\n  /* mqtt variable length encoding */\n  do {\n    *vlen = len % 0x80;\n    len /= 0x80;\n    if (len > 0) *vlen |= 0x80;\n    vlen++;\n  } while (len > 0);\n\n  mbuf_insert(&nc->send_mbuf, off, buf, vlen - buf);\n}\n\nvoid mg_mqtt_publish(struct mg_connection *nc, const char *topic,\n                     uint16_t message_id, int flags, const void *data,\n                     size_t len) {\n  size_t old_len = nc->send_mbuf.len;\n\n  uint16_t topic_len = htons((uint16_t) strlen(topic));\n  uint16_t message_id_net = htons(message_id);\n\n  mg_send(nc, &topic_len, 2);\n  mg_send(nc, topic, strlen(topic));\n  if (MG_MQTT_GET_QOS(flags) > 0) {\n    mg_send(nc, &message_id_net, 2);\n  }\n  mg_send(nc, data, len);\n\n  mg_mqtt_prepend_header(nc, MG_MQTT_CMD_PUBLISH, flags,\n                         nc->send_mbuf.len - old_len);\n}\n\nvoid mg_mqtt_subscribe(struct mg_connection *nc,\n                       const struct mg_mqtt_topic_expression *topics,\n                       size_t topics_len, uint16_t message_id) {\n  size_t old_len = nc->send_mbuf.len;\n\n  uint16_t message_id_n = htons(message_id);\n  size_t i;\n\n  mg_send(nc, (char *) &message_id_n, 2);\n  for (i = 0; i < topics_len; i++) {\n    uint16_t topic_len_n = htons((uint16_t) strlen(topics[i].topic));\n    mg_send(nc, &topic_len_n, 2);\n    mg_send(nc, topics[i].topic, strlen(topics[i].topic));\n    mg_send(nc, &topics[i].qos, 1);\n  }\n\n  mg_mqtt_prepend_header(nc, MG_MQTT_CMD_SUBSCRIBE, MG_MQTT_QOS(1),\n                         nc->send_mbuf.len - old_len);\n}\n\nint mg_mqtt_next_subscribe_topic(struct mg_mqtt_message *msg,\n                                 struct mg_str *topic, uint8_t *qos, int pos) {\n  unsigned char *buf = (unsigned char *) msg->payload.p + pos;\n\n  if ((size_t) pos >= msg->payload.len) {\n    return -1;\n  }\n\n  topic->len = buf[0] << 8 | buf[1];\n  topic->p = (char *) buf + 2;\n  *qos = buf[2 + topic->len];\n  return pos + 2 + topic->len + 1;\n}\n\nvoid mg_mqtt_unsubscribe(struct mg_connection *nc, char **topics,\n                         size_t topics_len, uint16_t message_id) {\n  size_t old_len = nc->send_mbuf.len;\n\n  uint16_t message_id_n = htons(message_id);\n  size_t i;\n\n  mg_send(nc, (char *) &message_id_n, 2);\n  for (i = 0; i < topics_len; i++) {\n    uint16_t topic_len_n = htons((uint16_t) strlen(topics[i]));\n    mg_send(nc, &topic_len_n, 2);\n    mg_send(nc, topics[i], strlen(topics[i]));\n  }\n\n  mg_mqtt_prepend_header(nc, MG_MQTT_CMD_UNSUBSCRIBE, MG_MQTT_QOS(1),\n                         nc->send_mbuf.len - old_len);\n}\n\nvoid mg_mqtt_connack(struct mg_connection *nc, uint8_t return_code) {\n  uint8_t unused = 0;\n  mg_send(nc, &unused, 1);\n  mg_send(nc, &return_code, 1);\n  mg_mqtt_prepend_header(nc, MG_MQTT_CMD_CONNACK, 0, 2);\n}\n\n/*\n * Sends a command which contains only a `message_id` and a QoS level of 1.\n *\n * Helper function.\n */\nstatic void mg_send_mqtt_short_command(struct mg_connection *nc, uint8_t cmd,\n                                       uint16_t message_id) {\n  uint16_t message_id_net = htons(message_id);\n  uint8_t flags = (cmd == MG_MQTT_CMD_PUBREL ? 2 : 0);\n  mg_send(nc, &message_id_net, 2);\n  mg_mqtt_prepend_header(nc, cmd, flags, 2 /* len */);\n}\n\nvoid mg_mqtt_puback(struct mg_connection *nc, uint16_t message_id) {\n  mg_send_mqtt_short_command(nc, MG_MQTT_CMD_PUBACK, message_id);\n}\n\nvoid mg_mqtt_pubrec(struct mg_connection *nc, uint16_t message_id) {\n  mg_send_mqtt_short_command(nc, MG_MQTT_CMD_PUBREC, message_id);\n}\n\nvoid mg_mqtt_pubrel(struct mg_connection *nc, uint16_t message_id) {\n  mg_send_mqtt_short_command(nc, MG_MQTT_CMD_PUBREL, message_id);\n}\n\nvoid mg_mqtt_pubcomp(struct mg_connection *nc, uint16_t message_id) {\n  mg_send_mqtt_short_command(nc, MG_MQTT_CMD_PUBCOMP, message_id);\n}\n\nvoid mg_mqtt_suback(struct mg_connection *nc, uint8_t *qoss, size_t qoss_len,\n                    uint16_t message_id) {\n  size_t i;\n  uint16_t message_id_net = htons(message_id);\n  mg_send(nc, &message_id_net, 2);\n  for (i = 0; i < qoss_len; i++) {\n    mg_send(nc, &qoss[i], 1);\n  }\n  mg_mqtt_prepend_header(nc, MG_MQTT_CMD_SUBACK, MG_MQTT_QOS(1), 2 + qoss_len);\n}\n\nvoid mg_mqtt_unsuback(struct mg_connection *nc, uint16_t message_id) {\n  mg_send_mqtt_short_command(nc, MG_MQTT_CMD_UNSUBACK, message_id);\n}\n\nvoid mg_mqtt_ping(struct mg_connection *nc) {\n  mg_mqtt_prepend_header(nc, MG_MQTT_CMD_PINGREQ, 0, 0);\n}\n\nvoid mg_mqtt_pong(struct mg_connection *nc) {\n  mg_mqtt_prepend_header(nc, MG_MQTT_CMD_PINGRESP, 0, 0);\n}\n\nvoid mg_mqtt_disconnect(struct mg_connection *nc) {\n  mg_mqtt_prepend_header(nc, MG_MQTT_CMD_DISCONNECT, 0, 0);\n}\n\n#endif /* MG_ENABLE_MQTT */\n#ifdef MG_MODULE_LINES\n#line 1 \"mongoose/src/mqtt_server.c\"\n#endif\n/*\n * Copyright (c) 2014 Cesanta Software Limited\n * All rights reserved\n */\n\n/* Amalgamated: #include \"mongoose/src/internal.h\" */\n/* Amalgamated: #include \"mongoose/src/mqtt-server.h\" */\n\n#if MG_ENABLE_MQTT_BROKER\n\nstatic void mg_mqtt_session_init(struct mg_mqtt_broker *brk,\n                                 struct mg_mqtt_session *s,\n                                 struct mg_connection *nc) {\n  s->brk = brk;\n  s->subscriptions = NULL;\n  s->num_subscriptions = 0;\n  s->nc = nc;\n}\n\nstatic void mg_mqtt_add_session(struct mg_mqtt_session *s) {\n  LIST_INSERT_HEAD(&s->brk->sessions, s, link);\n}\n\nstatic void mg_mqtt_remove_session(struct mg_mqtt_session *s) {\n  LIST_REMOVE(s, link);\n}\n\nstatic void mg_mqtt_destroy_session(struct mg_mqtt_session *s) {\n  size_t i;\n  for (i = 0; i < s->num_subscriptions; i++) {\n    MG_FREE((void *) s->subscriptions[i].topic);\n  }\n  MG_FREE(s->subscriptions);\n  MG_FREE(s);\n}\n\nstatic void mg_mqtt_close_session(struct mg_mqtt_session *s) {\n  mg_mqtt_remove_session(s);\n  mg_mqtt_destroy_session(s);\n}\n\nvoid mg_mqtt_broker_init(struct mg_mqtt_broker *brk, void *user_data) {\n  LIST_INIT(&brk->sessions);\n  brk->user_data = user_data;\n}\n\nstatic void mg_mqtt_broker_handle_connect(struct mg_mqtt_broker *brk,\n                                          struct mg_connection *nc) {\n  struct mg_mqtt_session *s =\n      (struct mg_mqtt_session *) MG_CALLOC(1, sizeof *s);\n  if (s == NULL) {\n    /* LCOV_EXCL_START */\n    mg_mqtt_connack(nc, MG_EV_MQTT_CONNACK_SERVER_UNAVAILABLE);\n    return;\n    /* LCOV_EXCL_STOP */\n  }\n\n  /* TODO(mkm): check header (magic and version) */\n\n  mg_mqtt_session_init(brk, s, nc);\n  s->user_data = nc->user_data;\n  nc->user_data = s;\n  mg_mqtt_add_session(s);\n\n  mg_mqtt_connack(nc, MG_EV_MQTT_CONNACK_ACCEPTED);\n}\n\nstatic void mg_mqtt_broker_handle_subscribe(struct mg_connection *nc,\n                                            struct mg_mqtt_message *msg) {\n  struct mg_mqtt_session *ss = (struct mg_mqtt_session *) nc->user_data;\n  uint8_t qoss[512];\n  size_t qoss_len = 0;\n  struct mg_str topic;\n  uint8_t qos;\n  int pos;\n  struct mg_mqtt_topic_expression *te;\n\n  for (pos = 0;\n       (pos = mg_mqtt_next_subscribe_topic(msg, &topic, &qos, pos)) != -1;) {\n    qoss[qoss_len++] = qos;\n  }\n\n  ss->subscriptions = (struct mg_mqtt_topic_expression *) MG_REALLOC(\n      ss->subscriptions, sizeof(*ss->subscriptions) * qoss_len);\n  for (pos = 0;\n       (pos = mg_mqtt_next_subscribe_topic(msg, &topic, &qos, pos)) != -1;\n       ss->num_subscriptions++) {\n    te = &ss->subscriptions[ss->num_subscriptions];\n    te->topic = (char *) MG_MALLOC(topic.len + 1);\n    te->qos = qos;\n    strncpy((char *) te->topic, topic.p, topic.len + 1);\n  }\n\n  mg_mqtt_suback(nc, qoss, qoss_len, msg->message_id);\n}\n\nstatic void mg_mqtt_broker_handle_publish(struct mg_mqtt_broker *brk,\n                                          struct mg_mqtt_message *msg) {\n  struct mg_mqtt_session *s;\n  size_t i;\n\n  for (s = mg_mqtt_next(brk, NULL); s != NULL; s = mg_mqtt_next(brk, s)) {\n    for (i = 0; i < s->num_subscriptions; i++) {\n      if (mg_mqtt_vmatch_topic_expression(s->subscriptions[i].topic,\n                                          msg->topic)) {\n        char buf[100], *p = buf;\n        mg_asprintf(&p, sizeof(buf), \"%.*s\", (int) msg->topic.len,\n                    msg->topic.p);\n        if (p == NULL) {\n          return;\n        }\n        mg_mqtt_publish(s->nc, p, 0, 0, msg->payload.p, msg->payload.len);\n        if (p != buf) {\n          MG_FREE(p);\n        }\n        break;\n      }\n    }\n  }\n}\n\nvoid mg_mqtt_broker(struct mg_connection *nc, int ev, void *data) {\n  struct mg_mqtt_message *msg = (struct mg_mqtt_message *) data;\n  struct mg_mqtt_broker *brk;\n\n  if (nc->listener) {\n    brk = (struct mg_mqtt_broker *) nc->listener->user_data;\n  } else {\n    brk = (struct mg_mqtt_broker *) nc->user_data;\n  }\n\n  switch (ev) {\n    case MG_EV_ACCEPT:\n      mg_set_protocol_mqtt(nc);\n      nc->user_data = NULL; /* Clear up the inherited pointer to broker */\n      break;\n    case MG_EV_MQTT_CONNECT:\n      mg_mqtt_broker_handle_connect(brk, nc);\n      break;\n    case MG_EV_MQTT_SUBSCRIBE:\n      mg_mqtt_broker_handle_subscribe(nc, msg);\n      break;\n    case MG_EV_MQTT_PUBLISH:\n      mg_mqtt_broker_handle_publish(brk, msg);\n      break;\n    case MG_EV_CLOSE:\n      if (nc->listener && nc->user_data != NULL) {\n        mg_mqtt_close_session((struct mg_mqtt_session *) nc->user_data);\n      }\n      break;\n  }\n}\n\nstruct mg_mqtt_session *mg_mqtt_next(struct mg_mqtt_broker *brk,\n                                     struct mg_mqtt_session *s) {\n  return s == NULL ? LIST_FIRST(&brk->sessions) : LIST_NEXT(s, link);\n}\n\n#endif /* MG_ENABLE_MQTT_BROKER */\n#ifdef MG_MODULE_LINES\n#line 1 \"mongoose/src/dns.c\"\n#endif\n/*\n * Copyright (c) 2014 Cesanta Software Limited\n * All rights reserved\n */\n\n#if MG_ENABLE_DNS\n\n/* Amalgamated: #include \"mongoose/src/internal.h\" */\n/* Amalgamated: #include \"mongoose/src/dns.h\" */\n\nstatic int mg_dns_tid = 0xa0;\n\nstruct mg_dns_header {\n  uint16_t transaction_id;\n  uint16_t flags;\n  uint16_t num_questions;\n  uint16_t num_answers;\n  uint16_t num_authority_prs;\n  uint16_t num_other_prs;\n};\n\nstruct mg_dns_resource_record *mg_dns_next_record(\n    struct mg_dns_message *msg, int query,\n    struct mg_dns_resource_record *prev) {\n  struct mg_dns_resource_record *rr;\n\n  for (rr = (prev == NULL ? msg->answers : prev + 1);\n       rr - msg->answers < msg->num_answers; rr++) {\n    if (rr->rtype == query) {\n      return rr;\n    }\n  }\n  return NULL;\n}\n\nint mg_dns_parse_record_data(struct mg_dns_message *msg,\n                             struct mg_dns_resource_record *rr, void *data,\n                             size_t data_len) {\n  switch (rr->rtype) {\n    case MG_DNS_A_RECORD:\n      if (data_len < sizeof(struct in_addr)) {\n        return -1;\n      }\n      if (rr->rdata.p + data_len > msg->pkt.p + msg->pkt.len) {\n        return -1;\n      }\n      memcpy(data, rr->rdata.p, data_len);\n      return 0;\n#if MG_ENABLE_IPV6\n    case MG_DNS_AAAA_RECORD:\n      if (data_len < sizeof(struct in6_addr)) {\n        return -1; /* LCOV_EXCL_LINE */\n      }\n      memcpy(data, rr->rdata.p, data_len);\n      return 0;\n#endif\n    case MG_DNS_CNAME_RECORD:\n      mg_dns_uncompress_name(msg, &rr->rdata, (char *) data, data_len);\n      return 0;\n  }\n\n  return -1;\n}\n\nint mg_dns_insert_header(struct mbuf *io, size_t pos,\n                         struct mg_dns_message *msg) {\n  struct mg_dns_header header;\n\n  memset(&header, 0, sizeof(header));\n  header.transaction_id = msg->transaction_id;\n  header.flags = htons(msg->flags);\n  header.num_questions = htons(msg->num_questions);\n  header.num_answers = htons(msg->num_answers);\n\n  return mbuf_insert(io, pos, &header, sizeof(header));\n}\n\nint mg_dns_copy_questions(struct mbuf *io, struct mg_dns_message *msg) {\n  unsigned char *begin, *end;\n  struct mg_dns_resource_record *last_q;\n  if (msg->num_questions <= 0) return 0;\n  begin = (unsigned char *) msg->pkt.p + sizeof(struct mg_dns_header);\n  last_q = &msg->questions[msg->num_questions - 1];\n  end = (unsigned char *) last_q->name.p + last_q->name.len + 4;\n  return mbuf_append(io, begin, end - begin);\n}\n\nint mg_dns_encode_name(struct mbuf *io, const char *name, size_t len) {\n  const char *s;\n  unsigned char n;\n  size_t pos = io->len;\n\n  do {\n    if ((s = strchr(name, '.')) == NULL) {\n      s = name + len;\n    }\n\n    if (s - name > 127) {\n      return -1; /* TODO(mkm) cover */\n    }\n    n = s - name;           /* chunk length */\n    mbuf_append(io, &n, 1); /* send length */\n    mbuf_append(io, name, n);\n\n    if (*s == '.') {\n      n++;\n    }\n\n    name += n;\n    len -= n;\n  } while (*s != '\\0');\n  mbuf_append(io, \"\\0\", 1); /* Mark end of host name */\n\n  return io->len - pos;\n}\n\nint mg_dns_encode_record(struct mbuf *io, struct mg_dns_resource_record *rr,\n                         const char *name, size_t nlen, const void *rdata,\n                         size_t rlen) {\n  size_t pos = io->len;\n  uint16_t u16;\n  uint32_t u32;\n\n  if (rr->kind == MG_DNS_INVALID_RECORD) {\n    return -1; /* LCOV_EXCL_LINE */\n  }\n\n  if (mg_dns_encode_name(io, name, nlen) == -1) {\n    return -1;\n  }\n\n  u16 = htons(rr->rtype);\n  mbuf_append(io, &u16, 2);\n  u16 = htons(rr->rclass);\n  mbuf_append(io, &u16, 2);\n\n  if (rr->kind == MG_DNS_ANSWER) {\n    u32 = htonl(rr->ttl);\n    mbuf_append(io, &u32, 4);\n\n    if (rr->rtype == MG_DNS_CNAME_RECORD) {\n      int clen;\n      /* fill size after encoding */\n      size_t off = io->len;\n      mbuf_append(io, &u16, 2);\n      if ((clen = mg_dns_encode_name(io, (const char *) rdata, rlen)) == -1) {\n        return -1;\n      }\n      u16 = clen;\n      io->buf[off] = u16 >> 8;\n      io->buf[off + 1] = u16 & 0xff;\n    } else {\n      u16 = htons((uint16_t) rlen);\n      mbuf_append(io, &u16, 2);\n      mbuf_append(io, rdata, rlen);\n    }\n  }\n\n  return io->len - pos;\n}\n\nvoid mg_send_dns_query(struct mg_connection *nc, const char *name,\n                       int query_type) {\n  struct mg_dns_message *msg =\n      (struct mg_dns_message *) MG_CALLOC(1, sizeof(*msg));\n  struct mbuf pkt;\n  struct mg_dns_resource_record *rr = &msg->questions[0];\n\n  DBG((\"%s %d\", name, query_type));\n\n  mbuf_init(&pkt, 64 /* Start small, it'll grow as needed. */);\n\n  msg->transaction_id = ++mg_dns_tid;\n  msg->flags = 0x100;\n  msg->num_questions = 1;\n\n  mg_dns_insert_header(&pkt, 0, msg);\n\n  rr->rtype = query_type;\n  rr->rclass = 1; /* Class: inet */\n  rr->kind = MG_DNS_QUESTION;\n\n  if (mg_dns_encode_record(&pkt, rr, name, strlen(name), NULL, 0) == -1) {\n    /* TODO(mkm): return an error code */\n    goto cleanup; /* LCOV_EXCL_LINE */\n  }\n\n  /* TCP DNS requires messages to be prefixed with len */\n  if (!(nc->flags & MG_F_UDP)) {\n    uint16_t len = htons((uint16_t) pkt.len);\n    mbuf_insert(&pkt, 0, &len, 2);\n  }\n\n  mg_send(nc, pkt.buf, pkt.len);\n  mbuf_free(&pkt);\n\ncleanup:\n  MG_FREE(msg);\n}\n\nstatic unsigned char *mg_parse_dns_resource_record(\n    unsigned char *data, unsigned char *end, struct mg_dns_resource_record *rr,\n    int reply) {\n  unsigned char *name = data;\n  int chunk_len, data_len;\n\n  while (data < end && (chunk_len = *data)) {\n    if (((unsigned char *) data)[0] & 0xc0) {\n      data += 1;\n      break;\n    }\n    data += chunk_len + 1;\n  }\n\n  if (data > end - 5) {\n    return NULL;\n  }\n\n  rr->name.p = (char *) name;\n  rr->name.len = data - name + 1;\n  data++;\n\n  rr->rtype = data[0] << 8 | data[1];\n  data += 2;\n\n  rr->rclass = data[0] << 8 | data[1];\n  data += 2;\n\n  rr->kind = reply ? MG_DNS_ANSWER : MG_DNS_QUESTION;\n  if (reply) {\n    if (data >= end - 6) {\n      return NULL;\n    }\n\n    rr->ttl = (uint32_t) data[0] << 24 | (uint32_t) data[1] << 16 |\n              data[2] << 8 | data[3];\n    data += 4;\n\n    data_len = *data << 8 | *(data + 1);\n    data += 2;\n\n    rr->rdata.p = (char *) data;\n    rr->rdata.len = data_len;\n    data += data_len;\n  }\n  return data;\n}\n\nint mg_parse_dns(const char *buf, int len, struct mg_dns_message *msg) {\n  struct mg_dns_header *header = (struct mg_dns_header *) buf;\n  unsigned char *data = (unsigned char *) buf + sizeof(*header);\n  unsigned char *end = (unsigned char *) buf + len;\n  int i;\n\n  memset(msg, 0, sizeof(*msg));\n  msg->pkt.p = buf;\n  msg->pkt.len = len;\n\n  if (len < (int) sizeof(*header)) return -1;\n\n  msg->transaction_id = header->transaction_id;\n  msg->flags = ntohs(header->flags);\n  msg->num_questions = ntohs(header->num_questions);\n  if (msg->num_questions > (int) ARRAY_SIZE(msg->questions)) {\n    msg->num_questions = (int) ARRAY_SIZE(msg->questions);\n  }\n  msg->num_answers = ntohs(header->num_answers);\n  if (msg->num_answers > (int) ARRAY_SIZE(msg->answers)) {\n    msg->num_answers = (int) ARRAY_SIZE(msg->answers);\n  }\n\n  for (i = 0; i < msg->num_questions; i++) {\n    data = mg_parse_dns_resource_record(data, end, &msg->questions[i], 0);\n    if (data == NULL) return -1;\n  }\n\n  for (i = 0; i < msg->num_answers; i++) {\n    data = mg_parse_dns_resource_record(data, end, &msg->answers[i], 1);\n    if (data == NULL) return -1;\n  }\n\n  return 0;\n}\n\nsize_t mg_dns_uncompress_name(struct mg_dns_message *msg, struct mg_str *name,\n                              char *dst, int dst_len) {\n  int chunk_len;\n  char *old_dst = dst;\n  const unsigned char *data = (unsigned char *) name->p;\n  const unsigned char *end = (unsigned char *) msg->pkt.p + msg->pkt.len;\n\n  if (data >= end) {\n    return 0;\n  }\n\n  while ((chunk_len = *data++)) {\n    int leeway = dst_len - (dst - old_dst);\n    if (data >= end) {\n      return 0;\n    }\n\n    if (chunk_len & 0xc0) {\n      uint16_t off = (data[-1] & (~0xc0)) << 8 | data[0];\n      if (off >= msg->pkt.len) {\n        return 0;\n      }\n      data = (unsigned char *) msg->pkt.p + off;\n      continue;\n    }\n    if (chunk_len > leeway) {\n      chunk_len = leeway;\n    }\n\n    if (data + chunk_len >= end) {\n      return 0;\n    }\n\n    memcpy(dst, data, chunk_len);\n    data += chunk_len;\n    dst += chunk_len;\n    leeway -= chunk_len;\n    if (leeway == 0) {\n      return dst - old_dst;\n    }\n    *dst++ = '.';\n  }\n\n  if (dst != old_dst) {\n    *--dst = 0;\n  }\n  return dst - old_dst;\n}\n\nstatic void dns_handler(struct mg_connection *nc, int ev,\n                        void *ev_data MG_UD_ARG(void *user_data)) {\n  struct mbuf *io = &nc->recv_mbuf;\n  struct mg_dns_message msg;\n\n  /* Pass low-level events to the user handler */\n  nc->handler(nc, ev, ev_data MG_UD_ARG(user_data));\n\n  switch (ev) {\n    case MG_EV_RECV:\n      if (!(nc->flags & MG_F_UDP)) {\n        mbuf_remove(&nc->recv_mbuf, 2);\n      }\n      if (mg_parse_dns(nc->recv_mbuf.buf, nc->recv_mbuf.len, &msg) == -1) {\n        /* reply + recursion allowed + format error */\n        memset(&msg, 0, sizeof(msg));\n        msg.flags = 0x8081;\n        mg_dns_insert_header(io, 0, &msg);\n        if (!(nc->flags & MG_F_UDP)) {\n          uint16_t len = htons((uint16_t) io->len);\n          mbuf_insert(io, 0, &len, 2);\n        }\n        mg_send(nc, io->buf, io->len);\n      } else {\n        /* Call user handler with parsed message */\n        nc->handler(nc, MG_DNS_MESSAGE, &msg MG_UD_ARG(user_data));\n      }\n      mbuf_remove(io, io->len);\n      break;\n  }\n}\n\nvoid mg_set_protocol_dns(struct mg_connection *nc) {\n  nc->proto_handler = dns_handler;\n}\n\n#endif /* MG_ENABLE_DNS */\n#ifdef MG_MODULE_LINES\n#line 1 \"mongoose/src/dns_server.c\"\n#endif\n/*\n * Copyright (c) 2014 Cesanta Software Limited\n * All rights reserved\n */\n\n#if MG_ENABLE_DNS_SERVER\n\n/* Amalgamated: #include \"mongoose/src/internal.h\" */\n/* Amalgamated: #include \"mongoose/src/dns-server.h\" */\n\nstruct mg_dns_reply mg_dns_create_reply(struct mbuf *io,\n                                        struct mg_dns_message *msg) {\n  struct mg_dns_reply rep;\n  rep.msg = msg;\n  rep.io = io;\n  rep.start = io->len;\n\n  /* reply + recursion allowed */\n  msg->flags |= 0x8080;\n  mg_dns_copy_questions(io, msg);\n\n  msg->num_answers = 0;\n  return rep;\n}\n\nvoid mg_dns_send_reply(struct mg_connection *nc, struct mg_dns_reply *r) {\n  size_t sent = r->io->len - r->start;\n  mg_dns_insert_header(r->io, r->start, r->msg);\n  if (!(nc->flags & MG_F_UDP)) {\n    uint16_t len = htons((uint16_t) sent);\n    mbuf_insert(r->io, r->start, &len, 2);\n  }\n\n  if (&nc->send_mbuf != r->io) {\n    mg_send(nc, r->io->buf + r->start, r->io->len - r->start);\n    r->io->len = r->start;\n  }\n}\n\nint mg_dns_reply_record(struct mg_dns_reply *reply,\n                        struct mg_dns_resource_record *question,\n                        const char *name, int rtype, int ttl, const void *rdata,\n                        size_t rdata_len) {\n  struct mg_dns_message *msg = (struct mg_dns_message *) reply->msg;\n  char rname[512];\n  struct mg_dns_resource_record *ans = &msg->answers[msg->num_answers];\n  if (msg->num_answers >= MG_MAX_DNS_ANSWERS) {\n    return -1; /* LCOV_EXCL_LINE */\n  }\n\n  if (name == NULL) {\n    name = rname;\n    rname[511] = 0;\n    mg_dns_uncompress_name(msg, &question->name, rname, sizeof(rname) - 1);\n  }\n\n  *ans = *question;\n  ans->kind = MG_DNS_ANSWER;\n  ans->rtype = rtype;\n  ans->ttl = ttl;\n\n  if (mg_dns_encode_record(reply->io, ans, name, strlen(name), rdata,\n                           rdata_len) == -1) {\n    return -1; /* LCOV_EXCL_LINE */\n  };\n\n  msg->num_answers++;\n  return 0;\n}\n\n#endif /* MG_ENABLE_DNS_SERVER */\n#ifdef MG_MODULE_LINES\n#line 1 \"mongoose/src/resolv.c\"\n#endif\n/*\n * Copyright (c) 2014 Cesanta Software Limited\n * All rights reserved\n */\n\n#if MG_ENABLE_ASYNC_RESOLVER\n\n/* Amalgamated: #include \"mongoose/src/internal.h\" */\n/* Amalgamated: #include \"mongoose/src/resolv.h\" */\n\n#ifndef MG_DEFAULT_NAMESERVER\n#define MG_DEFAULT_NAMESERVER \"8.8.8.8\"\n#endif\n\nstruct mg_resolve_async_request {\n  char name[1024];\n  int query;\n  mg_resolve_callback_t callback;\n  void *data;\n  time_t timeout;\n  int max_retries;\n  enum mg_resolve_err err;\n\n  /* state */\n  time_t last_time;\n  int retries;\n};\n\n/*\n * Find what nameserver to use.\n *\n * Return 0 if OK, -1 if error\n */\nstatic int mg_get_ip_address_of_nameserver(char *name, size_t name_len) {\n  int ret = -1;\n\n#ifdef _WIN32\n  int i;\n  LONG err;\n  HKEY hKey, hSub;\n  wchar_t subkey[512], value[128],\n      *key = L\"SYSTEM\\\\ControlSet001\\\\Services\\\\Tcpip\\\\Parameters\\\\Interfaces\";\n\n  if ((err = RegOpenKeyExW(HKEY_LOCAL_MACHINE, key, 0, KEY_READ, &hKey)) !=\n      ERROR_SUCCESS) {\n    fprintf(stderr, \"cannot open reg key %S: %ld\\n\", key, err);\n    ret = -1;\n  } else {\n    for (ret = -1, i = 0; 1; i++) {\n      DWORD subkey_size = sizeof(subkey), type, len = sizeof(value);\n      if (RegEnumKeyExW(hKey, i, subkey, &subkey_size, NULL, NULL, NULL,\n                        NULL) != ERROR_SUCCESS) {\n        break;\n      }\n      if (RegOpenKeyExW(hKey, subkey, 0, KEY_READ, &hSub) == ERROR_SUCCESS &&\n          (RegQueryValueExW(hSub, L\"NameServer\", 0, &type, (void *) value,\n                            &len) == ERROR_SUCCESS ||\n           RegQueryValueExW(hSub, L\"DhcpNameServer\", 0, &type, (void *) value,\n                            &len) == ERROR_SUCCESS)) {\n        /*\n         * See https://github.com/cesanta/mongoose/issues/176\n         * The value taken from the registry can be empty, a single\n         * IP address, or multiple IP addresses separated by comma.\n         * If it's empty, check the next interface.\n         * If it's multiple IP addresses, take the first one.\n         */\n        wchar_t *comma = wcschr(value, ',');\n        if (value[0] == '\\0') {\n          continue;\n        }\n        if (comma != NULL) {\n          *comma = '\\0';\n        }\n        /* %S will convert wchar_t -> char */\n        snprintf(name, name_len, \"%S\", value);\n        ret = 0;\n        RegCloseKey(hSub);\n        break;\n      }\n    }\n    RegCloseKey(hKey);\n  }\n#elif MG_ENABLE_FILESYSTEM\n  FILE *fp;\n  char line[512];\n\n  if ((fp = mg_fopen(\"/etc/resolv.conf\", \"r\")) == NULL) {\n    ret = -1;\n  } else {\n    /* Try to figure out what nameserver to use */\n    for (ret = -1; fgets(line, sizeof(line), fp) != NULL;) {\n      unsigned int a, b, c, d;\n      if (sscanf(line, \"nameserver %u.%u.%u.%u\", &a, &b, &c, &d) == 4) {\n        snprintf(name, name_len, \"%u.%u.%u.%u\", a, b, c, d);\n        ret = 0;\n        break;\n      }\n    }\n    (void) fclose(fp);\n  }\n#else\n  snprintf(name, name_len, \"%s\", MG_DEFAULT_NAMESERVER);\n#endif /* _WIN32 */\n\n  return ret;\n}\n\nint mg_resolve_from_hosts_file(const char *name, union socket_address *usa) {\n#if MG_ENABLE_FILESYSTEM\n  /* TODO(mkm) cache /etc/hosts */\n  FILE *fp;\n  char line[1024];\n  char *p;\n  char alias[256];\n  unsigned int a, b, c, d;\n  int len = 0;\n\n  if ((fp = mg_fopen(\"/etc/hosts\", \"r\")) == NULL) {\n    return -1;\n  }\n\n  for (; fgets(line, sizeof(line), fp) != NULL;) {\n    if (line[0] == '#') continue;\n\n    if (sscanf(line, \"%u.%u.%u.%u%n\", &a, &b, &c, &d, &len) == 0) {\n      /* TODO(mkm): handle ipv6 */\n      continue;\n    }\n    for (p = line + len; sscanf(p, \"%s%n\", alias, &len) == 1; p += len) {\n      if (strcmp(alias, name) == 0) {\n        usa->sin.sin_addr.s_addr = htonl(a << 24 | b << 16 | c << 8 | d);\n        fclose(fp);\n        return 0;\n      }\n    }\n  }\n\n  fclose(fp);\n#else\n  (void) name;\n  (void) usa;\n#endif\n\n  return -1;\n}\n\nstatic void mg_resolve_async_eh(struct mg_connection *nc, int ev,\n                                void *data MG_UD_ARG(void *user_data)) {\n  time_t now = (time_t) mg_time();\n  struct mg_resolve_async_request *req;\n  struct mg_dns_message *msg;\n  int first = 0;\n#if !MG_ENABLE_CALLBACK_USERDATA\n  void *user_data = nc->user_data;\n#endif\n\n  if (ev != MG_EV_POLL) DBG((\"ev=%d user_data=%p\", ev, user_data));\n\n  req = (struct mg_resolve_async_request *) user_data;\n\n  if (req == NULL) {\n    return;\n  }\n\n  switch (ev) {\n    case MG_EV_CONNECT:\n      /* don't depend on timer not being at epoch for sending out first req */\n      first = 1;\n    /* fallthrough */\n    case MG_EV_POLL:\n      if (req->retries > req->max_retries) {\n        req->err = MG_RESOLVE_EXCEEDED_RETRY_COUNT;\n        nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n        break;\n      }\n      if (first || now - req->last_time >= req->timeout) {\n        mg_send_dns_query(nc, req->name, req->query);\n        req->last_time = now;\n        req->retries++;\n      }\n      break;\n    case MG_EV_RECV:\n      msg = (struct mg_dns_message *) MG_MALLOC(sizeof(*msg));\n      if (mg_parse_dns(nc->recv_mbuf.buf, *(int *) data, msg) == 0 &&\n          msg->num_answers > 0) {\n        req->callback(msg, req->data, MG_RESOLVE_OK);\n        nc->user_data = NULL;\n        MG_FREE(req);\n      } else {\n        req->err = MG_RESOLVE_NO_ANSWERS;\n      }\n      MG_FREE(msg);\n      nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n      break;\n    case MG_EV_SEND:\n      /*\n       * If a send error occurs, prevent closing of the connection by the core.\n       * We will retry after timeout.\n       */\n      nc->flags &= ~MG_F_CLOSE_IMMEDIATELY;\n      mbuf_remove(&nc->send_mbuf, nc->send_mbuf.len);\n      break;\n    case MG_EV_TIMER:\n      req->err = MG_RESOLVE_TIMEOUT;\n      nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n      break;\n    case MG_EV_CLOSE:\n      /* If we got here with request still not done, fire an error callback. */\n      if (req != NULL) {\n        req->callback(NULL, req->data, req->err);\n        nc->user_data = NULL;\n        MG_FREE(req);\n      }\n      break;\n  }\n}\n\nint mg_resolve_async(struct mg_mgr *mgr, const char *name, int query,\n                     mg_resolve_callback_t cb, void *data) {\n  struct mg_resolve_async_opts opts;\n  memset(&opts, 0, sizeof(opts));\n  return mg_resolve_async_opt(mgr, name, query, cb, data, opts);\n}\n\nint mg_resolve_async_opt(struct mg_mgr *mgr, const char *name, int query,\n                         mg_resolve_callback_t cb, void *data,\n                         struct mg_resolve_async_opts opts) {\n  struct mg_resolve_async_request *req;\n  struct mg_connection *dns_nc;\n  const char *nameserver = opts.nameserver;\n  char dns_server_buff[17], nameserver_url[26];\n\n  if (nameserver == NULL) {\n    nameserver = mgr->nameserver;\n  }\n\n  DBG((\"%s %d %p\", name, query, opts.dns_conn));\n\n  /* resolve with DNS */\n  req = (struct mg_resolve_async_request *) MG_CALLOC(1, sizeof(*req));\n  if (req == NULL) {\n    return -1;\n  }\n\n  strncpy(req->name, name, sizeof(req->name));\n  req->query = query;\n  req->callback = cb;\n  req->data = data;\n  /* TODO(mkm): parse defaults out of resolve.conf */\n  req->max_retries = opts.max_retries ? opts.max_retries : 2;\n  req->timeout = opts.timeout ? opts.timeout : 5;\n\n  /* Lazily initialize dns server */\n  if (nameserver == NULL) {\n    if (mg_get_ip_address_of_nameserver(dns_server_buff,\n                                        sizeof(dns_server_buff)) != -1) {\n      nameserver = dns_server_buff;\n    } else {\n      nameserver = MG_DEFAULT_NAMESERVER;\n    }\n  }\n\n  snprintf(nameserver_url, sizeof(nameserver_url), \"udp://%s:53\", nameserver);\n\n  dns_nc = mg_connect(mgr, nameserver_url, MG_CB(mg_resolve_async_eh, NULL));\n  if (dns_nc == NULL) {\n    MG_FREE(req);\n    return -1;\n  }\n  dns_nc->user_data = req;\n  if (opts.dns_conn != NULL) {\n    *opts.dns_conn = dns_nc;\n  }\n\n  return 0;\n}\n\nvoid mg_set_nameserver(struct mg_mgr *mgr, const char *nameserver) {\n  MG_FREE((char *) mgr->nameserver);\n  if (nameserver != NULL) {\n    mgr->nameserver = strdup(nameserver);\n  }\n}\n\n#endif /* MG_ENABLE_ASYNC_RESOLVER */\n#ifdef MG_MODULE_LINES\n#line 1 \"mongoose/src/coap.c\"\n#endif\n/*\n * Copyright (c) 2015 Cesanta Software Limited\n * All rights reserved\n * This software is dual-licensed: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation. For the terms of this\n * license, see <http://www.gnu.org/licenses/>.\n *\n * You are free to use this software under the terms of the GNU General\n * Public License, but WITHOUT ANY WARRANTY; without even the implied\n * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License for more details.\n *\n * Alternatively, you can license this software under a commercial\n * license, as set out in <https://www.cesanta.com/license>.\n */\n\n/* Amalgamated: #include \"mongoose/src/internal.h\" */\n/* Amalgamated: #include \"mongoose/src/coap.h\" */\n\n#if MG_ENABLE_COAP\n\nvoid mg_coap_free_options(struct mg_coap_message *cm) {\n  while (cm->options != NULL) {\n    struct mg_coap_option *next = cm->options->next;\n    MG_FREE(cm->options);\n    cm->options = next;\n  }\n}\n\nstruct mg_coap_option *mg_coap_add_option(struct mg_coap_message *cm,\n                                          uint32_t number, char *value,\n                                          size_t len) {\n  struct mg_coap_option *new_option =\n      (struct mg_coap_option *) MG_CALLOC(1, sizeof(*new_option));\n\n  new_option->number = number;\n  new_option->value.p = value;\n  new_option->value.len = len;\n\n  if (cm->options == NULL) {\n    cm->options = cm->optiomg_tail = new_option;\n  } else {\n    /*\n     * A very simple attention to help clients to compose options:\n     * CoAP wants to see options ASC ordered.\n     * Could be change by using sort in coap_compose\n     */\n    if (cm->optiomg_tail->number <= new_option->number) {\n      /* if option is already ordered just add it */\n      cm->optiomg_tail = cm->optiomg_tail->next = new_option;\n    } else {\n      /* looking for appropriate position */\n      struct mg_coap_option *current_opt = cm->options;\n      struct mg_coap_option *prev_opt = 0;\n\n      while (current_opt != NULL) {\n        if (current_opt->number > new_option->number) {\n          break;\n        }\n        prev_opt = current_opt;\n        current_opt = current_opt->next;\n      }\n\n      if (prev_opt != NULL) {\n        prev_opt->next = new_option;\n        new_option->next = current_opt;\n      } else {\n        /* insert new_option to the beginning */\n        new_option->next = cm->options;\n        cm->options = new_option;\n      }\n    }\n  }\n\n  return new_option;\n}\n\n/*\n * Fills CoAP header in mg_coap_message.\n *\n * Helper function.\n */\nstatic char *coap_parse_header(char *ptr, struct mbuf *io,\n                               struct mg_coap_message *cm) {\n  if (io->len < sizeof(uint32_t)) {\n    cm->flags |= MG_COAP_NOT_ENOUGH_DATA;\n    return NULL;\n  }\n\n  /*\n   * Version (Ver):  2-bit unsigned integer.  Indicates the CoAP version\n   * number.  Implementations of this specification MUST set this field\n   * to 1 (01 binary).  Other values are reserved for future versions.\n   * Messages with unknown version numbers MUST be silently ignored.\n   */\n  if (((uint8_t) *ptr >> 6) != 1) {\n    cm->flags |= MG_COAP_IGNORE;\n    return NULL;\n  }\n\n  /*\n   * Type (T):  2-bit unsigned integer.  Indicates if this message is of\n   * type Confirmable (0), Non-confirmable (1), Acknowledgement (2), or\n   * Reset (3).\n   */\n  cm->msg_type = ((uint8_t) *ptr & 0x30) >> 4;\n  cm->flags |= MG_COAP_MSG_TYPE_FIELD;\n\n  /*\n   * Token Length (TKL):  4-bit unsigned integer.  Indicates the length of\n   * the variable-length Token field (0-8 bytes).  Lengths 9-15 are\n   * reserved, MUST NOT be sent, and MUST be processed as a message\n   * format error.\n   */\n  cm->token.len = *ptr & 0x0F;\n  if (cm->token.len > 8) {\n    cm->flags |= MG_COAP_FORMAT_ERROR;\n    return NULL;\n  }\n\n  ptr++;\n\n  /*\n   * Code:  8-bit unsigned integer, split into a 3-bit class (most\n   * significant bits) and a 5-bit detail (least significant bits)\n   */\n  cm->code_class = (uint8_t) *ptr >> 5;\n  cm->code_detail = *ptr & 0x1F;\n  cm->flags |= (MG_COAP_CODE_CLASS_FIELD | MG_COAP_CODE_DETAIL_FIELD);\n\n  ptr++;\n\n  /* Message ID:  16-bit unsigned integer in network byte order. */\n  cm->msg_id = (uint8_t) *ptr << 8 | (uint8_t) * (ptr + 1);\n  cm->flags |= MG_COAP_MSG_ID_FIELD;\n\n  ptr += 2;\n\n  return ptr;\n}\n\n/*\n * Fills token information in mg_coap_message.\n *\n * Helper function.\n */\nstatic char *coap_get_token(char *ptr, struct mbuf *io,\n                            struct mg_coap_message *cm) {\n  if (cm->token.len != 0) {\n    if (ptr + cm->token.len > io->buf + io->len) {\n      cm->flags |= MG_COAP_NOT_ENOUGH_DATA;\n      return NULL;\n    } else {\n      cm->token.p = ptr;\n      ptr += cm->token.len;\n      cm->flags |= MG_COAP_TOKEN_FIELD;\n    }\n  }\n\n  return ptr;\n}\n\n/*\n * Returns Option Delta or Length.\n *\n * Helper function.\n */\nstatic int coap_get_ext_opt(char *ptr, struct mbuf *io, uint16_t *opt_info) {\n  int ret = 0;\n\n  if (*opt_info == 13) {\n    /*\n     * 13:  An 8-bit unsigned integer follows the initial byte and\n     * indicates the Option Delta/Length minus 13.\n     */\n    if (ptr < io->buf + io->len) {\n      *opt_info = (uint8_t) *ptr + 13;\n      ret = sizeof(uint8_t);\n    } else {\n      ret = -1; /* LCOV_EXCL_LINE */\n    }\n  } else if (*opt_info == 14) {\n    /*\n     * 14:  A 16-bit unsigned integer in network byte order follows the\n     * initial byte and indicates the Option Delta/Length minus 269.\n     */\n    if (ptr + sizeof(uint8_t) < io->buf + io->len) {\n      *opt_info = ((uint8_t) *ptr << 8 | (uint8_t) * (ptr + 1)) + 269;\n      ret = sizeof(uint16_t);\n    } else {\n      ret = -1; /* LCOV_EXCL_LINE */\n    }\n  }\n\n  return ret;\n}\n\n/*\n * Fills options in mg_coap_message.\n *\n * Helper function.\n *\n * General options format:\n * +---------------+---------------+\n * | Option Delta  | Option Length |  1 byte\n * +---------------+---------------+\n * \\    Option Delta (extended)    \\  0-2 bytes\n * +-------------------------------+\n * / Option Length  (extended)     \\  0-2 bytes\n * +-------------------------------+\n * \\         Option Value          \\  0 or more bytes\n * +-------------------------------+\n */\nstatic char *coap_get_options(char *ptr, struct mbuf *io,\n                              struct mg_coap_message *cm) {\n  uint16_t prev_opt = 0;\n\n  if (ptr == io->buf + io->len) {\n    /* end of packet, ok */\n    return NULL;\n  }\n\n  /* 0xFF is payload marker */\n  while (ptr < io->buf + io->len && (uint8_t) *ptr != 0xFF) {\n    uint16_t option_delta, option_lenght;\n    int optinfo_len;\n\n    /* Option Delta:  4-bit unsigned integer */\n    option_delta = ((uint8_t) *ptr & 0xF0) >> 4;\n    /* Option Length:  4-bit unsigned integer */\n    option_lenght = *ptr & 0x0F;\n\n    if (option_delta == 15 || option_lenght == 15) {\n      /*\n       * 15:  Reserved for future use.  If the field is set to this value,\n       * it MUST be processed as a message format error\n       */\n      cm->flags |= MG_COAP_FORMAT_ERROR;\n      break;\n    }\n\n    ptr++;\n\n    /* check for extended option delta */\n    optinfo_len = coap_get_ext_opt(ptr, io, &option_delta);\n    if (optinfo_len == -1) {\n      cm->flags |= MG_COAP_NOT_ENOUGH_DATA; /* LCOV_EXCL_LINE */\n      break;                                /* LCOV_EXCL_LINE */\n    }\n\n    ptr += optinfo_len;\n\n    /* check or extended option lenght */\n    optinfo_len = coap_get_ext_opt(ptr, io, &option_lenght);\n    if (optinfo_len == -1) {\n      cm->flags |= MG_COAP_NOT_ENOUGH_DATA; /* LCOV_EXCL_LINE */\n      break;                                /* LCOV_EXCL_LINE */\n    }\n\n    ptr += optinfo_len;\n\n    /*\n     * Instead of specifying the Option Number directly, the instances MUST\n     * appear in order of their Option Numbers and a delta encoding is used\n     * between them.\n     */\n    option_delta += prev_opt;\n\n    mg_coap_add_option(cm, option_delta, ptr, option_lenght);\n\n    prev_opt = option_delta;\n\n    if (ptr + option_lenght > io->buf + io->len) {\n      cm->flags |= MG_COAP_NOT_ENOUGH_DATA; /* LCOV_EXCL_LINE */\n      break;                                /* LCOV_EXCL_LINE */\n    }\n\n    ptr += option_lenght;\n  }\n\n  if ((cm->flags & MG_COAP_ERROR) != 0) {\n    mg_coap_free_options(cm);\n    return NULL;\n  }\n\n  cm->flags |= MG_COAP_OPTIOMG_FIELD;\n\n  if (ptr == io->buf + io->len) {\n    /* end of packet, ok */\n    return NULL;\n  }\n\n  ptr++;\n\n  return ptr;\n}\n\nuint32_t mg_coap_parse(struct mbuf *io, struct mg_coap_message *cm) {\n  char *ptr;\n\n  memset(cm, 0, sizeof(*cm));\n\n  if ((ptr = coap_parse_header(io->buf, io, cm)) == NULL) {\n    return cm->flags;\n  }\n\n  if ((ptr = coap_get_token(ptr, io, cm)) == NULL) {\n    return cm->flags;\n  }\n\n  if ((ptr = coap_get_options(ptr, io, cm)) == NULL) {\n    return cm->flags;\n  }\n\n  /* the rest is payload */\n  cm->payload.len = io->len - (ptr - io->buf);\n  if (cm->payload.len != 0) {\n    cm->payload.p = ptr;\n    cm->flags |= MG_COAP_PAYLOAD_FIELD;\n  }\n\n  return cm->flags;\n}\n\n/*\n * Calculates extended size of given Opt Number/Length in coap message.\n *\n * Helper function.\n */\nstatic size_t coap_get_ext_opt_size(uint32_t value) {\n  int ret = 0;\n\n  if (value >= 13 && value <= 0xFF + 13) {\n    ret = sizeof(uint8_t);\n  } else if (value > 0xFF + 13 && value <= 0xFFFF + 269) {\n    ret = sizeof(uint16_t);\n  }\n\n  return ret;\n}\n\n/*\n * Splits given Opt Number/Length into base and ext values.\n *\n * Helper function.\n */\nstatic int coap_split_opt(uint32_t value, uint8_t *base, uint16_t *ext) {\n  int ret = 0;\n\n  if (value < 13) {\n    *base = value;\n  } else if (value >= 13 && value <= 0xFF + 13) {\n    *base = 13;\n    *ext = value - 13;\n    ret = sizeof(uint8_t);\n  } else if (value > 0xFF + 13 && value <= 0xFFFF + 269) {\n    *base = 14;\n    *ext = value - 269;\n    ret = sizeof(uint16_t);\n  }\n\n  return ret;\n}\n\n/*\n * Puts uint16_t (in network order) into given char stream.\n *\n * Helper function.\n */\nstatic char *coap_add_uint16(char *ptr, uint16_t val) {\n  *ptr = val >> 8;\n  ptr++;\n  *ptr = val & 0x00FF;\n  ptr++;\n  return ptr;\n}\n\n/*\n * Puts extended value of Opt Number/Length into given char stream.\n *\n * Helper function.\n */\nstatic char *coap_add_opt_info(char *ptr, uint16_t val, size_t len) {\n  if (len == sizeof(uint8_t)) {\n    *ptr = (char) val;\n    ptr++;\n  } else if (len == sizeof(uint16_t)) {\n    ptr = coap_add_uint16(ptr, val);\n  }\n\n  return ptr;\n}\n\n/*\n * Verifies given mg_coap_message and calculates message size for it.\n *\n * Helper function.\n */\nstatic uint32_t coap_calculate_packet_size(struct mg_coap_message *cm,\n                                           size_t *len) {\n  struct mg_coap_option *opt;\n  uint32_t prev_opt_number;\n\n  *len = 4; /* header */\n  if (cm->msg_type > MG_COAP_MSG_MAX) {\n    return MG_COAP_ERROR | MG_COAP_MSG_TYPE_FIELD;\n  }\n  if (cm->token.len > 8) {\n    return MG_COAP_ERROR | MG_COAP_TOKEN_FIELD;\n  }\n  if (cm->code_class > 7) {\n    return MG_COAP_ERROR | MG_COAP_CODE_CLASS_FIELD;\n  }\n  if (cm->code_detail > 31) {\n    return MG_COAP_ERROR | MG_COAP_CODE_DETAIL_FIELD;\n  }\n\n  *len += cm->token.len;\n  if (cm->payload.len != 0) {\n    *len += cm->payload.len + 1; /* ... + 1; add payload marker */\n  }\n\n  opt = cm->options;\n  prev_opt_number = 0;\n  while (opt != NULL) {\n    *len += 1; /* basic delta/length */\n    *len += coap_get_ext_opt_size(opt->number - prev_opt_number);\n    *len += coap_get_ext_opt_size((uint32_t) opt->value.len);\n    /*\n     * Current implementation performs check if\n     * option_number > previous option_number and produces an error\n     * TODO(alashkin): write design doc with limitations\n     * May be resorting is more suitable solution.\n     */\n    if ((opt->next != NULL && opt->number > opt->next->number) ||\n        opt->value.len > 0xFFFF + 269 ||\n        opt->number - prev_opt_number > 0xFFFF + 269) {\n      return MG_COAP_ERROR | MG_COAP_OPTIOMG_FIELD;\n    }\n    *len += opt->value.len;\n    prev_opt_number = opt->number;\n    opt = opt->next;\n  }\n\n  return 0;\n}\n\nuint32_t mg_coap_compose(struct mg_coap_message *cm, struct mbuf *io) {\n  struct mg_coap_option *opt;\n  uint32_t res, prev_opt_number;\n  size_t prev_io_len, packet_size;\n  char *ptr;\n\n  res = coap_calculate_packet_size(cm, &packet_size);\n  if (res != 0) {\n    return res;\n  }\n\n  /* saving previous lenght to handle non-empty mbuf */\n  prev_io_len = io->len;\n  mbuf_append(io, NULL, packet_size);\n  ptr = io->buf + prev_io_len;\n\n  /*\n   * since cm is verified, it is possible to use bits shift operator\n   * without additional zeroing of unused bits\n   */\n\n  /* ver: 2 bits, msg_type: 2 bits, toklen: 4 bits */\n  *ptr = (1 << 6) | (cm->msg_type << 4) | (uint8_t)(cm->token.len);\n  ptr++;\n\n  /* code class: 3 bits, code detail: 5 bits */\n  *ptr = (cm->code_class << 5) | (cm->code_detail);\n  ptr++;\n\n  ptr = coap_add_uint16(ptr, cm->msg_id);\n\n  if (cm->token.len != 0) {\n    memcpy(ptr, cm->token.p, cm->token.len);\n    ptr += cm->token.len;\n  }\n\n  opt = cm->options;\n  prev_opt_number = 0;\n  while (opt != NULL) {\n    uint8_t delta_base = 0, length_base = 0;\n    uint16_t delta_ext = 0, length_ext = 0;\n\n    size_t opt_delta_len =\n        coap_split_opt(opt->number - prev_opt_number, &delta_base, &delta_ext);\n    size_t opt_lenght_len =\n        coap_split_opt((uint32_t) opt->value.len, &length_base, &length_ext);\n\n    *ptr = (delta_base << 4) | length_base;\n    ptr++;\n\n    ptr = coap_add_opt_info(ptr, delta_ext, opt_delta_len);\n    ptr = coap_add_opt_info(ptr, length_ext, opt_lenght_len);\n\n    if (opt->value.len != 0) {\n      memcpy(ptr, opt->value.p, opt->value.len);\n      ptr += opt->value.len;\n    }\n\n    prev_opt_number = opt->number;\n    opt = opt->next;\n  }\n\n  if (cm->payload.len != 0) {\n    *ptr = (char) -1;\n    ptr++;\n    memcpy(ptr, cm->payload.p, cm->payload.len);\n  }\n\n  return 0;\n}\n\nuint32_t mg_coap_send_message(struct mg_connection *nc,\n                              struct mg_coap_message *cm) {\n  struct mbuf packet_out;\n  uint32_t compose_res;\n\n  mbuf_init(&packet_out, 0);\n  compose_res = mg_coap_compose(cm, &packet_out);\n  if (compose_res != 0) {\n    return compose_res; /* LCOV_EXCL_LINE */\n  }\n\n  mg_send(nc, packet_out.buf, (int) packet_out.len);\n  mbuf_free(&packet_out);\n\n  return 0;\n}\n\nuint32_t mg_coap_send_ack(struct mg_connection *nc, uint16_t msg_id) {\n  struct mg_coap_message cm;\n  memset(&cm, 0, sizeof(cm));\n  cm.msg_type = MG_COAP_MSG_ACK;\n  cm.msg_id = msg_id;\n\n  return mg_coap_send_message(nc, &cm);\n}\n\nstatic void coap_handler(struct mg_connection *nc, int ev,\n                         void *ev_data MG_UD_ARG(void *user_data)) {\n  struct mbuf *io = &nc->recv_mbuf;\n  struct mg_coap_message cm;\n  uint32_t parse_res;\n\n  memset(&cm, 0, sizeof(cm));\n\n  nc->handler(nc, ev, ev_data MG_UD_ARG(user_data));\n\n  switch (ev) {\n    case MG_EV_RECV:\n      parse_res = mg_coap_parse(io, &cm);\n      if ((parse_res & MG_COAP_IGNORE) == 0) {\n        if ((cm.flags & MG_COAP_NOT_ENOUGH_DATA) != 0) {\n          /*\n           * Since we support UDP only\n           * MG_COAP_NOT_ENOUGH_DATA == MG_COAP_FORMAT_ERROR\n           */\n          cm.flags |= MG_COAP_FORMAT_ERROR; /* LCOV_EXCL_LINE */\n        }                                   /* LCOV_EXCL_LINE */\n        nc->handler(nc, MG_COAP_EVENT_BASE + cm.msg_type,\n                    &cm MG_UD_ARG(user_data));\n      }\n\n      mg_coap_free_options(&cm);\n      mbuf_remove(io, io->len);\n      break;\n  }\n}\n/*\n * Attach built-in CoAP event handler to the given connection.\n *\n * The user-defined event handler will receive following extra events:\n *\n * - MG_EV_COAP_CON\n * - MG_EV_COAP_NOC\n * - MG_EV_COAP_ACK\n * - MG_EV_COAP_RST\n */\nint mg_set_protocol_coap(struct mg_connection *nc) {\n  /* supports UDP only */\n  if ((nc->flags & MG_F_UDP) == 0) {\n    return -1;\n  }\n\n  nc->proto_handler = coap_handler;\n\n  return 0;\n}\n\n#endif /* MG_ENABLE_COAP */\n#ifdef MG_MODULE_LINES\n#line 1 \"mongoose/src/tun.c\"\n#endif\n/*\n * Copyright (c) 2014 Cesanta Software Limited\n * All rights reserved\n */\n\n#if MG_ENABLE_TUN\n\n/* Amalgamated: #include \"common/cs_dbg.h\" */\n/* Amalgamated: #include \"mongoose/src/http.h\" */\n/* Amalgamated: #include \"mongoose/src/internal.h\" */\n/* Amalgamated: #include \"mongoose/src/net.h\" */\n/* Amalgamated: #include \"mongoose/src/net_if_tun.h\" */\n/* Amalgamated: #include \"mongoose/src/tun.h\" */\n/* Amalgamated: #include \"mongoose/src/util.h\" */\n\nstatic void mg_tun_reconnect(struct mg_tun_client *client, int timeout);\n\nstatic void mg_tun_init_client(struct mg_tun_client *client, struct mg_mgr *mgr,\n                               struct mg_iface *iface, const char *dispatcher,\n                               struct mg_tun_ssl_opts ssl) {\n  client->mgr = mgr;\n  client->iface = iface;\n  client->disp_url = dispatcher;\n  client->last_stream_id = 0;\n  client->ssl = ssl;\n\n  client->disp = NULL;      /* will be set by mg_tun_reconnect */\n  client->listener = NULL;  /* will be set by mg_do_bind */\n  client->reconnect = NULL; /* will be set by mg_tun_reconnect */\n}\n\nvoid mg_tun_log_frame(struct mg_tun_frame *frame) {\n  LOG(LL_DEBUG, (\"Got TUN frame: type=0x%x, flags=0x%x stream_id=0x%lx, \"\n                 \"len=%zu\",\n                 frame->type, frame->flags, frame->stream_id, frame->body.len));\n#if MG_ENABLE_HEXDUMP\n  {\n    char hex[512];\n    mg_hexdump(frame->body.p, frame->body.len, hex, sizeof(hex) - 1);\n    hex[sizeof(hex) - 1] = '\\0';\n    LOG(LL_DEBUG, (\"body:\\n%s\", hex));\n  }\n#else\n  LOG(LL_DEBUG, (\"body: '%.*s'\", (int) frame->body.len, frame->body.p));\n#endif\n}\n\nstatic void mg_tun_close_all(struct mg_tun_client *client) {\n  struct mg_connection *nc;\n  for (nc = client->mgr->active_connections; nc != NULL; nc = nc->next) {\n    if (nc->iface == client->iface && !(nc->flags & MG_F_LISTENING)) {\n      LOG(LL_DEBUG, (\"Closing tunneled connection %p\", nc));\n      nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n      /* mg_close_conn(nc); */\n    }\n  }\n}\n\nstatic void mg_tun_client_handler(struct mg_connection *nc, int ev,\n                                  void *ev_data MG_UD_ARG(void *user_data)) {\n#if !MG_ENABLE_CALLBACK_USERDATA\n  void *user_data = nc->user_data;\n#else\n  (void) nc;\n#endif\n  struct mg_tun_client *client = (struct mg_tun_client *) user_data;\n\n  switch (ev) {\n    case MG_EV_CONNECT: {\n      int err = *(int *) ev_data;\n\n      if (err) {\n        LOG(LL_ERROR, (\"Cannot connect to the tunnel dispatcher: %d\", err));\n      } else {\n        LOG(LL_INFO, (\"Connected to the tunnel dispatcher\"));\n      }\n      break;\n    }\n    case MG_EV_HTTP_REPLY: {\n      struct http_message *hm = (struct http_message *) ev_data;\n\n      if (hm->resp_code != 200) {\n        LOG(LL_ERROR,\n            (\"Tunnel dispatcher reply non-OK status code %d\", hm->resp_code));\n      }\n      break;\n    }\n    case MG_EV_WEBSOCKET_HANDSHAKE_DONE: {\n      LOG(LL_INFO, (\"Tunnel dispatcher handshake done\"));\n      break;\n    }\n    case MG_EV_WEBSOCKET_FRAME: {\n      struct websocket_message *wm = (struct websocket_message *) ev_data;\n      struct mg_connection *tc;\n      struct mg_tun_frame frame;\n\n      if (mg_tun_parse_frame(wm->data, wm->size, &frame) == -1) {\n        LOG(LL_ERROR, (\"Got invalid tun frame dropping\", wm->size));\n        break;\n      }\n\n      mg_tun_log_frame(&frame);\n\n      tc = mg_tun_if_find_conn(client, frame.stream_id);\n      if (tc == NULL) {\n        if (frame.body.len > 0) {\n          LOG(LL_DEBUG, (\"Got frame after receiving end has been closed\"));\n        }\n        break;\n      }\n      if (frame.body.len > 0) {\n        mg_if_recv_tcp_cb(tc, (void *) frame.body.p, frame.body.len,\n                          0 /* own */);\n      }\n      if (frame.flags & MG_TUN_F_END_STREAM) {\n        LOG(LL_DEBUG, (\"Closing tunneled connection because got end of stream \"\n                       \"from other end\"));\n        tc->flags |= MG_F_CLOSE_IMMEDIATELY;\n        mg_close_conn(tc);\n      }\n      break;\n    }\n    case MG_EV_CLOSE: {\n      LOG(LL_DEBUG, (\"Closing all tunneled connections\"));\n      /*\n       * The client might have been already freed when the listening socket is\n       * closed.\n       */\n      if (client != NULL) {\n        mg_tun_close_all(client);\n        client->disp = NULL;\n        LOG(LL_INFO, (\"Dispatcher connection is no more, reconnecting\"));\n        /* TODO(mkm): implement exp back off */\n        mg_tun_reconnect(client, MG_TUN_RECONNECT_INTERVAL);\n      }\n      break;\n    }\n    default:\n      break;\n  }\n}\n\nstatic void mg_tun_do_reconnect(struct mg_tun_client *client) {\n  struct mg_connection *dc;\n  struct mg_connect_opts opts;\n  memset(&opts, 0, sizeof(opts));\n#if MG_ENABLE_SSL\n  opts.ssl_cert = client->ssl.ssl_cert;\n  opts.ssl_key = client->ssl.ssl_key;\n  opts.ssl_ca_cert = client->ssl.ssl_ca_cert;\n#endif\n  /* HTTP/Websocket listener */\n  if ((dc = mg_connect_ws_opt(client->mgr, MG_CB(mg_tun_client_handler, client),\n                              opts, client->disp_url, MG_TUN_PROTO_NAME,\n                              NULL)) == NULL) {\n    LOG(LL_ERROR,\n        (\"Cannot connect to WS server on addr [%s]\\n\", client->disp_url));\n    return;\n  }\n\n  client->disp = dc;\n#if !MG_ENABLE_CALLBACK_USERDATA\n  dc->user_data = client;\n#endif\n}\n\nvoid mg_tun_reconnect_ev_handler(struct mg_connection *nc, int ev,\n                                 void *ev_data MG_UD_ARG(void *user_data)) {\n#if !MG_ENABLE_CALLBACK_USERDATA\n  void *user_data = nc->user_data;\n#else\n  (void) nc;\n#endif\n  struct mg_tun_client *client = (struct mg_tun_client *) user_data;\n  (void) ev_data;\n\n  switch (ev) {\n    case MG_EV_TIMER:\n      if (!(client->listener->flags & MG_F_TUN_DO_NOT_RECONNECT)) {\n        mg_tun_do_reconnect(client);\n      } else {\n        /* Reconnecting is suppressed, we'll check again at the next poll */\n        mg_tun_reconnect(client, 0);\n      }\n      break;\n  }\n}\n\nstatic void mg_tun_reconnect(struct mg_tun_client *client, int timeout) {\n  if (client->reconnect == NULL) {\n    client->reconnect = mg_add_sock(client->mgr, INVALID_SOCKET,\n                                    MG_CB(mg_tun_reconnect_ev_handler, client));\n#if !MG_ENABLE_CALLBACK_USERDATA\n    client->reconnect->user_data = client;\n#endif\n  }\n  client->reconnect->ev_timer_time = mg_time() + timeout;\n}\n\nstatic struct mg_tun_client *mg_tun_create_client(struct mg_mgr *mgr,\n                                                  const char *dispatcher,\n                                                  struct mg_tun_ssl_opts ssl) {\n  struct mg_tun_client *client = NULL;\n  struct mg_iface *iface = mg_find_iface(mgr, &mg_tun_iface_vtable, NULL);\n  if (iface == NULL) {\n    LOG(LL_ERROR, (\"The tun feature requires the manager to have a tun \"\n                   \"interface enabled\"));\n    return NULL;\n  }\n\n  client = (struct mg_tun_client *) MG_MALLOC(sizeof(*client));\n  mg_tun_init_client(client, mgr, iface, dispatcher, ssl);\n  iface->data = client;\n\n  /*\n   * We need to give application a chance to set MG_F_TUN_DO_NOT_RECONNECT on a\n   * listening connection right after mg_tun_bind_opt() returned it, so we\n   * should use mg_tun_reconnect() here, instead of mg_tun_do_reconnect()\n   */\n  mg_tun_reconnect(client, 0);\n  return client;\n}\n\nvoid mg_tun_destroy_client(struct mg_tun_client *client) {\n  /*\n   *  NOTE:\n   * `client` is NULL in case of OOM\n   * `client->disp` is NULL if connection failed\n   * `client->iface is NULL is `mg_find_iface` failed\n   */\n\n  if (client != NULL && client->disp != NULL) {\n    /* the dispatcher connection handler will in turn close all tunnels */\n    client->disp->flags |= MG_F_CLOSE_IMMEDIATELY;\n    /* this is used as a signal to other tun handlers that the party is over */\n    client->disp->user_data = NULL;\n  }\n\n  if (client != NULL && client->reconnect != NULL) {\n    client->reconnect->flags |= MG_F_CLOSE_IMMEDIATELY;\n  }\n\n  if (client != NULL && client->iface != NULL) {\n    client->iface->data = NULL;\n  }\n\n  MG_FREE(client);\n}\n\nstatic struct mg_connection *mg_tun_do_bind(struct mg_tun_client *client,\n                                            MG_CB(mg_event_handler_t handler,\n                                                  void *user_data),\n                                            struct mg_bind_opts opts) {\n  struct mg_connection *lc;\n  opts.iface = client->iface;\n  lc = mg_bind_opt(client->mgr, \":1234\" /* dummy port */,\n                   MG_CB(handler, user_data), opts);\n  client->listener = lc;\n  return lc;\n}\n\nstruct mg_connection *mg_tun_bind_opt(struct mg_mgr *mgr,\n                                      const char *dispatcher,\n                                      MG_CB(mg_event_handler_t handler,\n                                            void *user_data),\n                                      struct mg_bind_opts opts) {\n#if MG_ENABLE_SSL\n  struct mg_tun_ssl_opts ssl = {opts.ssl_cert, opts.ssl_key, opts.ssl_ca_cert};\n#else\n  struct mg_tun_ssl_opts ssl = {0};\n#endif\n  struct mg_tun_client *client = mg_tun_create_client(mgr, dispatcher, ssl);\n  if (client == NULL) {\n    return NULL;\n  }\n#if MG_ENABLE_SSL\n  /* these options don't make sense in the local mouth of the tunnel */\n  opts.ssl_cert = NULL;\n  opts.ssl_key = NULL;\n  opts.ssl_ca_cert = NULL;\n#endif\n  return mg_tun_do_bind(client, MG_CB(handler, user_data), opts);\n}\n\nint mg_tun_parse_frame(void *data, size_t len, struct mg_tun_frame *frame) {\n  const size_t header_size = sizeof(uint32_t) + sizeof(uint8_t) * 2;\n  if (len < header_size) {\n    return -1;\n  }\n\n  frame->type = *(uint8_t *) (data);\n  frame->flags = *(uint8_t *) ((char *) data + 1);\n  memcpy(&frame->stream_id, (char *) data + 2, sizeof(uint32_t));\n  frame->stream_id = ntohl(frame->stream_id);\n  frame->body.p = (char *) data + header_size;\n  frame->body.len = len - header_size;\n  return 0;\n}\n\nvoid mg_tun_send_frame(struct mg_connection *ws, uint32_t stream_id,\n                       uint8_t type, uint8_t flags, struct mg_str msg) {\n  stream_id = htonl(stream_id);\n  {\n    struct mg_str parts[] = {\n        {(char *) &type, sizeof(type)},\n        {(char *) &flags, sizeof(flags)},\n        {(char *) &stream_id, sizeof(stream_id)},\n        {msg.p, msg.len} /* vc6 doesn't like just `msg` here */};\n    mg_send_websocket_framev(ws, WEBSOCKET_OP_BINARY, parts,\n                             sizeof(parts) / sizeof(parts[0]));\n  }\n}\n\n#endif /* MG_ENABLE_TUN */\n#ifdef MG_MODULE_LINES\n#line 1 \"mongoose/src/sntp.c\"\n#endif\n/*\n * Copyright (c) 2016 Cesanta Software Limited\n * All rights reserved\n */\n\n/* Amalgamated: #include \"mongoose/src/internal.h\" */\n/* Amalgamated: #include \"mongoose/src/sntp.h\" */\n/* Amalgamated: #include \"mongoose/src/util.h\" */\n\n#if MG_ENABLE_SNTP\n\n#define SNTP_TIME_OFFSET 2208988800\n\n#ifndef SNTP_TIMEOUT\n#define SNTP_TIMEOUT 10\n#endif\n\n#ifndef SNTP_ATTEMPTS\n#define SNTP_ATTEMPTS 3\n#endif\n\nstatic uint64_t mg_get_sec(uint64_t val) {\n  return (val & 0xFFFFFFFF00000000) >> 32;\n}\n\nstatic uint64_t mg_get_usec(uint64_t val) {\n  uint64_t tmp = (val & 0x00000000FFFFFFFF);\n  tmp *= 1000000;\n  tmp >>= 32;\n  return tmp;\n}\n\nstatic void mg_ntp_to_tv(uint64_t val, struct timeval *tv) {\n  uint64_t tmp;\n  tmp = mg_get_sec(val);\n  tmp -= SNTP_TIME_OFFSET;\n  tv->tv_sec = tmp;\n  tv->tv_usec = mg_get_usec(val);\n}\n\nstatic void mg_get_ntp_ts(const char *ntp, uint64_t *val) {\n  uint32_t tmp;\n  memcpy(&tmp, ntp, sizeof(tmp));\n  tmp = ntohl(tmp);\n  *val = (uint64_t) tmp << 32;\n  memcpy(&tmp, ntp + 4, sizeof(tmp));\n  tmp = ntohl(tmp);\n  *val |= tmp;\n}\n\nvoid mg_sntp_send_request(struct mg_connection *c) {\n  char buf[48] = {0};\n  /*\n   * header - 8 bit:\n   * LI (2 bit) - 3 (not in sync), VN (3 bit) - 4 (version),\n   * mode (3 bit) - 3 (client)\n   */\n  buf[0] = (3 << 6) | (4 << 3) | 3;\n\n/*\n * Next fields should be empty in client request\n * stratum, 8 bit\n * poll interval, 8 bit\n * rrecision, 8 bit\n * root delay, 32 bit\n * root dispersion, 32 bit\n * ref id, 32 bit\n * ref timestamp, 64 bit\n * originate Timestamp, 64 bit\n * receive Timestamp, 64 bit\n*/\n\n/*\n * convert time to sntp format (sntp starts from 00:00:00 01.01.1900)\n * according to rfc868 it is 2208988800L sec\n * this information is used to correct roundtrip delay\n * but if local clock is absolutely broken (and doesn't work even\n * as simple timer), it is better to disable it\n*/\n#ifndef MG_SNMP_NO_DELAY_CORRECTION\n  uint32_t sec;\n  sec = htonl((uint32_t)(mg_time() + SNTP_TIME_OFFSET));\n  memcpy(&buf[40], &sec, sizeof(sec));\n#endif\n\n  mg_send(c, buf, sizeof(buf));\n}\n\n#ifndef MG_SNMP_NO_DELAY_CORRECTION\nstatic uint64_t mg_calculate_delay(uint64_t t1, uint64_t t2, uint64_t t3) {\n  /* roundloop delay = (T4 - T1) - (T3 - T2) */\n  uint64_t d1 = ((mg_time() + SNTP_TIME_OFFSET) * 1000000) -\n                (mg_get_sec(t1) * 1000000 + mg_get_usec(t1));\n  uint64_t d2 = (mg_get_sec(t3) * 1000000 + mg_get_usec(t3)) -\n                (mg_get_sec(t2) * 1000000 + mg_get_usec(t2));\n\n  return (d1 > d2) ? d1 - d2 : 0;\n}\n#endif\n\nMG_INTERNAL int mg_sntp_parse_reply(const char *buf, int len,\n                                    struct mg_sntp_message *msg) {\n  uint8_t hdr;\n  uint64_t orig_ts_T1, recv_ts_T2, trsm_ts_T3, delay = 0;\n  int mode;\n  struct timeval tv;\n\n  (void) orig_ts_T1;\n  (void) recv_ts_T2;\n  if (len < 48) {\n    return -1;\n  }\n\n  hdr = buf[0];\n\n  if ((hdr & 0x38) >> 3 != 4) {\n    /* Wrong version */\n    return -1;\n  }\n\n  mode = hdr & 0x7;\n  if (mode != 4 && mode != 5) {\n    /* Not a server reply */\n    return -1;\n  }\n\n  memset(msg, 0, sizeof(*msg));\n\n  msg->kiss_of_death = (buf[1] == 0); /* Server asks to not send requests */\n\n  mg_get_ntp_ts(&buf[40], &trsm_ts_T3);\n\n#ifndef MG_SNMP_NO_DELAY_CORRECTION\n  mg_get_ntp_ts(&buf[24], &orig_ts_T1);\n  mg_get_ntp_ts(&buf[32], &recv_ts_T2);\n  delay = mg_calculate_delay(orig_ts_T1, recv_ts_T2, trsm_ts_T3);\n#endif\n\n  mg_ntp_to_tv(trsm_ts_T3, &tv);\n\n  msg->time = (double) tv.tv_sec + (((double) tv.tv_usec + delay) / 1000000.0);\n\n  return 0;\n}\n\nstatic void mg_sntp_handler(struct mg_connection *c, int ev,\n                            void *ev_data MG_UD_ARG(void *user_data)) {\n  struct mbuf *io = &c->recv_mbuf;\n  struct mg_sntp_message msg;\n\n  c->handler(c, ev, ev_data MG_UD_ARG(user_data));\n\n  switch (ev) {\n    case MG_EV_RECV: {\n      if (mg_sntp_parse_reply(io->buf, io->len, &msg) < 0) {\n        DBG((\"Invalid SNTP packet received (%d)\", (int) io->len));\n        c->handler(c, MG_SNTP_MALFORMED_REPLY, NULL MG_UD_ARG(user_data));\n      } else {\n        c->handler(c, MG_SNTP_REPLY, (void *) &msg MG_UD_ARG(user_data));\n      }\n\n      mbuf_remove(io, io->len);\n      break;\n    }\n  }\n}\n\nint mg_set_protocol_sntp(struct mg_connection *c) {\n  if ((c->flags & MG_F_UDP) == 0) {\n    return -1;\n  }\n\n  c->proto_handler = mg_sntp_handler;\n\n  return 0;\n}\n\nstruct mg_connection *mg_sntp_connect(struct mg_mgr *mgr,\n                                      MG_CB(mg_event_handler_t event_handler,\n                                            void *user_data),\n                                      const char *sntp_server_name) {\n  struct mg_connection *c = NULL;\n  char url[100], *p_url = url;\n  const char *proto = \"\", *port = \"\", *tmp;\n\n  /* If port is not specified, use default (123) */\n  tmp = strchr(sntp_server_name, ':');\n  if (tmp != NULL && *(tmp + 1) == '/') {\n    tmp = strchr(tmp + 1, ':');\n  }\n\n  if (tmp == NULL) {\n    port = \":123\";\n  }\n\n  /* Add udp:// if needed */\n  if (strncmp(sntp_server_name, \"udp://\", 6) != 0) {\n    proto = \"udp://\";\n  }\n\n  mg_asprintf(&p_url, sizeof(url), \"%s%s%s\", proto, sntp_server_name, port);\n\n  c = mg_connect(mgr, p_url, event_handler MG_UD_ARG(user_data));\n\n  if (c == NULL) {\n    goto cleanup;\n  }\n\n  mg_set_protocol_sntp(c);\n\ncleanup:\n  if (p_url != url) {\n    MG_FREE(p_url);\n  }\n\n  return c;\n}\n\nstruct sntp_data {\n  mg_event_handler_t hander;\n  int count;\n};\n\nstatic void mg_sntp_util_ev_handler(struct mg_connection *c, int ev,\n                                    void *ev_data MG_UD_ARG(void *user_data)) {\n#if !MG_ENABLE_CALLBACK_USERDATA\n  void *user_data = c->user_data;\n#endif\n  struct sntp_data *sd = (struct sntp_data *) user_data;\n\n  switch (ev) {\n    case MG_EV_CONNECT:\n      if (*(int *) ev_data != 0) {\n        mg_call(c, sd->hander, c->user_data, MG_SNTP_FAILED, NULL);\n        break;\n      }\n    /* fallthrough */\n    case MG_EV_TIMER:\n      if (sd->count <= SNTP_ATTEMPTS) {\n        mg_sntp_send_request(c);\n        mg_set_timer(c, mg_time() + 10);\n        sd->count++;\n      } else {\n        mg_call(c, sd->hander, c->user_data, MG_SNTP_FAILED, NULL);\n        c->flags |= MG_F_CLOSE_IMMEDIATELY;\n      }\n      break;\n    case MG_SNTP_MALFORMED_REPLY:\n      mg_call(c, sd->hander, c->user_data, MG_SNTP_FAILED, NULL);\n      c->flags |= MG_F_CLOSE_IMMEDIATELY;\n      break;\n    case MG_SNTP_REPLY:\n      mg_call(c, sd->hander, c->user_data, MG_SNTP_REPLY, ev_data);\n      c->flags |= MG_F_CLOSE_IMMEDIATELY;\n      break;\n    case MG_EV_CLOSE:\n      MG_FREE(user_data);\n      c->user_data = NULL;\n      break;\n  }\n}\n\nstruct mg_connection *mg_sntp_get_time(struct mg_mgr *mgr,\n                                       mg_event_handler_t event_handler,\n                                       const char *sntp_server_name) {\n  struct mg_connection *c;\n  struct sntp_data *sd = (struct sntp_data *) MG_CALLOC(1, sizeof(*sd));\n  if (sd == NULL) {\n    return NULL;\n  }\n\n  c = mg_sntp_connect(mgr, MG_CB(mg_sntp_util_ev_handler, sd),\n                      sntp_server_name);\n  if (c == NULL) {\n    MG_FREE(sd);\n    return NULL;\n  }\n\n  sd->hander = event_handler;\n#if !MG_ENABLE_CALLBACK_USERDATA\n  c->user_data = sd;\n#endif\n\n  return c;\n}\n\n#endif /* MG_ENABLE_SNTP */\n#ifdef MG_MODULE_LINES\n#line 1 \"common/platforms/cc3200/cc3200_libc.c\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#if CS_PLATFORM == CS_P_CC3200\n\n/* Amalgamated: #include \"common/mg_mem.h\" */\n#include <stdio.h>\n#include <string.h>\n\n#ifndef __TI_COMPILER_VERSION__\n#include <reent.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <unistd.h>\n#endif\n\n#include <inc/hw_types.h>\n#include <inc/hw_memmap.h>\n#include <driverlib/prcm.h>\n#include <driverlib/rom.h>\n#include <driverlib/rom_map.h>\n#include <driverlib/uart.h>\n#include <driverlib/utils.h>\n\n#define CONSOLE_UART UARTA0_BASE\n\n#ifdef __TI_COMPILER_VERSION__\nint asprintf(char **strp, const char *fmt, ...) {\n  va_list ap;\n  int len;\n\n  *strp = MG_MALLOC(BUFSIZ);\n  if (*strp == NULL) return -1;\n\n  va_start(ap, fmt);\n  len = vsnprintf(*strp, BUFSIZ, fmt, ap);\n  va_end(ap);\n\n  if (len > 0) {\n    *strp = MG_REALLOC(*strp, len + 1);\n    if (*strp == NULL) return -1;\n  }\n\n  if (len >= BUFSIZ) {\n    va_start(ap, fmt);\n    len = vsnprintf(*strp, len + 1, fmt, ap);\n    va_end(ap);\n  }\n\n  return len;\n}\n\n#if MG_TI_NO_HOST_INTERFACE\ntime_t HOSTtime() {\n  struct timeval tp;\n  gettimeofday(&tp, NULL);\n  return tp.tv_sec;\n}\n#endif\n\n#endif /* __TI_COMPILER_VERSION__ */\n\n#ifndef __TI_COMPILER_VERSION__\nint _gettimeofday_r(struct _reent *r, struct timeval *tp, void *tzp) {\n#else\nint gettimeofday(struct timeval *tp, void *tzp) {\n#endif\n  unsigned long long r1 = 0, r2;\n  /* Achieve two consecutive reads of the same value. */\n  do {\n    r2 = r1;\n    r1 = PRCMSlowClkCtrFastGet();\n  } while (r1 != r2);\n  /* This is a 32768 Hz counter. */\n  tp->tv_sec = (r1 >> 15);\n  /* 1/32768-th of a second is 30.517578125 microseconds, approx. 31,\n   * but we round down so it doesn't overflow at 32767 */\n  tp->tv_usec = (r1 & 0x7FFF) * 30;\n  return 0;\n}\n\nvoid fprint_str(FILE *fp, const char *str) {\n  while (*str != '\\0') {\n    if (*str == '\\n') MAP_UARTCharPut(CONSOLE_UART, '\\r');\n    MAP_UARTCharPut(CONSOLE_UART, *str++);\n  }\n}\n\nvoid _exit(int status) {\n  fprint_str(stderr, \"_exit\\n\");\n  /* cause an unaligned access exception, that will drop you into gdb */\n  *(int *) 1 = status;\n  while (1)\n    ; /* avoid gcc warning because stdlib abort() has noreturn attribute */\n}\n\nvoid _not_implemented(const char *what) {\n  fprint_str(stderr, what);\n  fprint_str(stderr, \" is not implemented\\n\");\n  _exit(42);\n}\n\nint _kill(int pid, int sig) {\n  (void) pid;\n  (void) sig;\n  _not_implemented(\"_kill\");\n  return -1;\n}\n\nint _getpid() {\n  fprint_str(stderr, \"_getpid is not implemented\\n\");\n  return 42;\n}\n\nint _isatty(int fd) {\n  /* 0, 1 and 2 are TTYs. */\n  return fd < 2;\n}\n\n#endif /* CS_PLATFORM == CS_P_CC3200 */\n#ifdef MG_MODULE_LINES\n#line 1 \"common/platforms/msp432/msp432_libc.c\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#if CS_PLATFORM == CS_P_MSP432\n\n#include <ti/sysbios/BIOS.h>\n#include <ti/sysbios/knl/Clock.h>\n\nint gettimeofday(struct timeval *tp, void *tzp) {\n  uint32_t ticks = Clock_getTicks();\n  tp->tv_sec = ticks / 1000;\n  tp->tv_usec = (ticks % 1000) * 1000;\n  return 0;\n}\n\n#endif /* CS_PLATFORM == CS_P_MSP432 */\n#ifdef MG_MODULE_LINES\n#line 1 \"common/platforms/nrf5/nrf5_libc.c\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#if (CS_PLATFORM == CS_P_NRF51 || CS_PLATFORM == CS_P_NRF52) && \\\n    defined(__ARMCC_VERSION)\nint gettimeofday(struct timeval *tp, void *tzp) {\n  /* TODO */\n  tp->tv_sec = 0;\n  tp->tv_usec = 0;\n  return 0;\n}\n#endif\n#ifdef MG_MODULE_LINES\n#line 1 \"common/platforms/simplelink/sl_fs_slfs.h\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#ifndef CS_COMMON_PLATFORMS_SIMPLELINK_SL_FS_SLFS_H_\n#define CS_COMMON_PLATFORMS_SIMPLELINK_SL_FS_SLFS_H_\n\n#if defined(MG_FS_SLFS)\n\n#include <stdio.h>\n#ifndef __TI_COMPILER_VERSION__\n#include <unistd.h>\n#include <sys/stat.h>\n#endif\n\n#define MAX_OPEN_SLFS_FILES 8\n\n/* Indirect libc interface - same functions, different names. */\nint fs_slfs_open(const char *pathname, int flags, mode_t mode);\nint fs_slfs_close(int fd);\nssize_t fs_slfs_read(int fd, void *buf, size_t count);\nssize_t fs_slfs_write(int fd, const void *buf, size_t count);\nint fs_slfs_stat(const char *pathname, struct stat *s);\nint fs_slfs_fstat(int fd, struct stat *s);\noff_t fs_slfs_lseek(int fd, off_t offset, int whence);\nint fs_slfs_unlink(const char *filename);\nint fs_slfs_rename(const char *from, const char *to);\n\nvoid fs_slfs_set_new_file_size(const char *name, size_t size);\n\n#endif /* defined(MG_FS_SLFS) */\n\n#endif /* CS_COMMON_PLATFORMS_SIMPLELINK_SL_FS_SLFS_H_ */\n#ifdef MG_MODULE_LINES\n#line 1 \"common/platforms/simplelink/sl_fs_slfs.c\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n/* Standard libc interface to TI SimpleLink FS. */\n\n#if defined(MG_FS_SLFS) || defined(CC3200_FS_SLFS)\n\n/* Amalgamated: #include \"common/platforms/simplelink/sl_fs_slfs.h\" */\n\n#include <errno.h>\n\n#if CS_PLATFORM == CS_P_CC3200\n#include <inc/hw_types.h>\n#endif\n#include <simplelink/include/simplelink.h>\n#include <simplelink/include/fs.h>\n\n/* Amalgamated: #include \"common/cs_dbg.h\" */\n/* Amalgamated: #include \"common/mg_mem.h\" */\n\n/* From sl_fs.c */\nextern int set_errno(int e);\nstatic const char *drop_dir(const char *fname, bool *is_slfs);\n\n/*\n * With SLFS, you have to pre-declare max file size. Yes. Really.\n * 64K should be enough for everyone. Right?\n */\n#ifndef FS_SLFS_MAX_FILE_SIZE\n#define FS_SLFS_MAX_FILE_SIZE (64 * 1024)\n#endif\n\nstruct sl_file_size_hint {\n  char *name;\n  size_t size;\n};\n\nstruct sl_fd_info {\n  _i32 fh;\n  _off_t pos;\n  size_t size;\n};\n\nstatic struct sl_fd_info s_sl_fds[MAX_OPEN_SLFS_FILES];\nstatic struct sl_file_size_hint s_sl_file_size_hints[MAX_OPEN_SLFS_FILES];\n\nstatic int sl_fs_to_errno(_i32 r) {\n  DBG((\"SL error: %d\", (int) r));\n  switch (r) {\n    case SL_FS_OK:\n      return 0;\n    case SL_FS_FILE_NAME_EXIST:\n      return EEXIST;\n    case SL_FS_WRONG_FILE_NAME:\n      return EINVAL;\n    case SL_FS_ERR_NO_AVAILABLE_NV_INDEX:\n    case SL_FS_ERR_NO_AVAILABLE_BLOCKS:\n      return ENOSPC;\n    case SL_FS_ERR_FAILED_TO_ALLOCATE_MEM:\n      return ENOMEM;\n    case SL_FS_ERR_FILE_NOT_EXISTS:\n      return ENOENT;\n    case SL_FS_ERR_NOT_SUPPORTED:\n      return ENOTSUP;\n  }\n  return ENXIO;\n}\n\nint fs_slfs_open(const char *pathname, int flags, mode_t mode) {\n  int fd;\n  for (fd = 0; fd < MAX_OPEN_SLFS_FILES; fd++) {\n    if (s_sl_fds[fd].fh <= 0) break;\n  }\n  if (fd >= MAX_OPEN_SLFS_FILES) return set_errno(ENOMEM);\n  struct sl_fd_info *fi = &s_sl_fds[fd];\n\n  /*\n   * Apply path manipulations again, in case we got here directly\n   * (via TI libc's \"add_device\").\n   */\n  pathname = drop_dir(pathname, NULL);\n\n  _u32 am = 0;\n  fi->size = (size_t) -1;\n  int rw = (flags & 3);\n  if (rw == O_RDONLY) {\n    SlFsFileInfo_t sl_fi;\n    _i32 r = sl_FsGetInfo((const _u8 *) pathname, 0, &sl_fi);\n    if (r == SL_FS_OK) {\n      fi->size = sl_fi.FileLen;\n    }\n    am = FS_MODE_OPEN_READ;\n  } else {\n    if (!(flags & O_TRUNC) || (flags & O_APPEND)) {\n      // FailFS files cannot be opened for append and will be truncated\n      // when opened for write.\n      return set_errno(ENOTSUP);\n    }\n    if (flags & O_CREAT) {\n      size_t i, size = FS_SLFS_MAX_FILE_SIZE;\n      for (i = 0; i < MAX_OPEN_SLFS_FILES; i++) {\n        if (s_sl_file_size_hints[i].name != NULL &&\n            strcmp(s_sl_file_size_hints[i].name, pathname) == 0) {\n          size = s_sl_file_size_hints[i].size;\n          MG_FREE(s_sl_file_size_hints[i].name);\n          s_sl_file_size_hints[i].name = NULL;\n          break;\n        }\n      }\n      DBG((\"creating %s with max size %d\", pathname, (int) size));\n      am = FS_MODE_OPEN_CREATE(size, 0);\n    } else {\n      am = FS_MODE_OPEN_WRITE;\n    }\n  }\n  _i32 r = sl_FsOpen((_u8 *) pathname, am, NULL, &fi->fh);\n  DBG((\"sl_FsOpen(%s, 0x%x) = %d, %d\", pathname, (int) am, (int) r,\n       (int) fi->fh));\n  if (r == SL_FS_OK) {\n    fi->pos = 0;\n    r = fd;\n  } else {\n    fi->fh = -1;\n    r = set_errno(sl_fs_to_errno(r));\n  }\n  return r;\n}\n\nint fs_slfs_close(int fd) {\n  struct sl_fd_info *fi = &s_sl_fds[fd];\n  if (fi->fh <= 0) return set_errno(EBADF);\n  _i32 r = sl_FsClose(fi->fh, NULL, NULL, 0);\n  DBG((\"sl_FsClose(%d) = %d\", (int) fi->fh, (int) r));\n  s_sl_fds[fd].fh = -1;\n  return set_errno(sl_fs_to_errno(r));\n}\n\nssize_t fs_slfs_read(int fd, void *buf, size_t count) {\n  struct sl_fd_info *fi = &s_sl_fds[fd];\n  if (fi->fh <= 0) return set_errno(EBADF);\n  /* Simulate EOF. sl_FsRead @ file_size return SL_FS_ERR_OFFSET_OUT_OF_RANGE.\n   */\n  if (fi->pos == fi->size) return 0;\n  _i32 r = sl_FsRead(fi->fh, fi->pos, buf, count);\n  DBG((\"sl_FsRead(%d, %d, %d) = %d\", (int) fi->fh, (int) fi->pos, (int) count,\n       (int) r));\n  if (r >= 0) {\n    fi->pos += r;\n    return r;\n  }\n  return set_errno(sl_fs_to_errno(r));\n}\n\nssize_t fs_slfs_write(int fd, const void *buf, size_t count) {\n  struct sl_fd_info *fi = &s_sl_fds[fd];\n  if (fi->fh <= 0) return set_errno(EBADF);\n  _i32 r = sl_FsWrite(fi->fh, fi->pos, (_u8 *) buf, count);\n  DBG((\"sl_FsWrite(%d, %d, %d) = %d\", (int) fi->fh, (int) fi->pos, (int) count,\n       (int) r));\n  if (r >= 0) {\n    fi->pos += r;\n    return r;\n  }\n  return set_errno(sl_fs_to_errno(r));\n}\n\nint fs_slfs_stat(const char *pathname, struct stat *s) {\n  SlFsFileInfo_t sl_fi;\n  /*\n   * Apply path manipulations again, in case we got here directly\n   * (via TI libc's \"add_device\").\n   */\n  pathname = drop_dir(pathname, NULL);\n  _i32 r = sl_FsGetInfo((const _u8 *) pathname, 0, &sl_fi);\n  if (r == SL_FS_OK) {\n    s->st_mode = S_IFREG | 0666;\n    s->st_nlink = 1;\n    s->st_size = sl_fi.FileLen;\n    return 0;\n  }\n  return set_errno(sl_fs_to_errno(r));\n}\n\nint fs_slfs_fstat(int fd, struct stat *s) {\n  struct sl_fd_info *fi = &s_sl_fds[fd];\n  if (fi->fh <= 0) return set_errno(EBADF);\n  s->st_mode = 0666;\n  s->st_mode = S_IFREG | 0666;\n  s->st_nlink = 1;\n  s->st_size = fi->size;\n  return 0;\n}\n\noff_t fs_slfs_lseek(int fd, off_t offset, int whence) {\n  if (s_sl_fds[fd].fh <= 0) return set_errno(EBADF);\n  switch (whence) {\n    case SEEK_SET:\n      s_sl_fds[fd].pos = offset;\n      break;\n    case SEEK_CUR:\n      s_sl_fds[fd].pos += offset;\n      break;\n    case SEEK_END:\n      return set_errno(ENOTSUP);\n  }\n  return 0;\n}\n\nint fs_slfs_unlink(const char *pathname) {\n  /*\n   * Apply path manipulations again, in case we got here directly\n   * (via TI libc's \"add_device\").\n   */\n  pathname = drop_dir(pathname, NULL);\n  return set_errno(sl_fs_to_errno(sl_FsDel((const _u8 *) pathname, 0)));\n}\n\nint fs_slfs_rename(const char *from, const char *to) {\n  return set_errno(ENOTSUP);\n}\n\nvoid fs_slfs_set_new_file_size(const char *name, size_t size) {\n  int i;\n  for (i = 0; i < MAX_OPEN_SLFS_FILES; i++) {\n    if (s_sl_file_size_hints[i].name == NULL) {\n      DBG((\"File size hint: %s %d\", name, (int) size));\n      s_sl_file_size_hints[i].name = strdup(name);\n      s_sl_file_size_hints[i].size = size;\n      break;\n    }\n  }\n}\n\n#endif /* defined(MG_FS_SLFS) || defined(CC3200_FS_SLFS) */\n#ifdef MG_MODULE_LINES\n#line 1 \"common/platforms/simplelink/sl_fs.c\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#if MG_NET_IF == MG_NET_IF_SIMPLELINK && \\\n    (defined(MG_FS_SLFS) || defined(MG_FS_SPIFFS))\n\n#include <errno.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef __TI_COMPILER_VERSION__\n#include <file.h>\n#endif\n\n/* Amalgamated: #include \"common/cs_dbg.h\" */\n/* Amalgamated: #include \"common/platform.h\" */\n\n#ifdef CC3200_FS_SPIFFS\n/* Amalgamated: #include \"cc3200_fs_spiffs.h\" */\n#endif\n\n#ifdef MG_FS_SLFS\n/* Amalgamated: #include \"sl_fs_slfs.h\" */\n#endif\n\n#define NUM_SYS_FDS 3\n#define SPIFFS_FD_BASE 10\n#define SLFS_FD_BASE 100\n\n#ifndef MG_UART_CHAR_PUT\n#if CS_PLATFORM == CS_P_CC3200\n#include <inc/hw_types.h>\n#include <inc/hw_memmap.h>\n#include <driverlib/rom.h>\n#include <driverlib/rom_map.h>\n#include <driverlib/uart.h>\n#define MG_UART_CHAR_PUT(fd, c) MAP_UARTCharPut(UARTA0_BASE, c);\n#else\n#define MG_UART_CHAR_PUT(fd, c)\n#endif /* CS_PLATFORM == CS_P_CC3200 */\n#endif /* !MG_UART_CHAR_PUT */\n\nint set_errno(int e) {\n  errno = e;\n  return (e == 0 ? 0 : -1);\n}\n\nstatic const char *drop_dir(const char *fname, bool *is_slfs) {\n  if (is_slfs != NULL) {\n    *is_slfs = (strncmp(fname, \"SL:\", 3) == 0);\n    if (*is_slfs) fname += 3;\n  }\n  /* Drop \"./\", if any */\n  if (fname[0] == '.' && fname[1] == '/') {\n    fname += 2;\n  }\n  /*\n   * Drop / if it is the only one in the path.\n   * This allows use of /pretend/directories but serves /file.txt as normal.\n   */\n  if (fname[0] == '/' && strchr(fname + 1, '/') == NULL) {\n    fname++;\n  }\n  return fname;\n}\n\nenum fd_type {\n  FD_INVALID,\n  FD_SYS,\n#ifdef CC3200_FS_SPIFFS\n  FD_SPIFFS,\n#endif\n#ifdef MG_FS_SLFS\n  FD_SLFS\n#endif\n};\nstatic int fd_type(int fd) {\n  if (fd >= 0 && fd < NUM_SYS_FDS) return FD_SYS;\n#ifdef CC3200_FS_SPIFFS\n  if (fd >= SPIFFS_FD_BASE && fd < SPIFFS_FD_BASE + MAX_OPEN_SPIFFS_FILES) {\n    return FD_SPIFFS;\n  }\n#endif\n#ifdef MG_FS_SLFS\n  if (fd >= SLFS_FD_BASE && fd < SLFS_FD_BASE + MAX_OPEN_SLFS_FILES) {\n    return FD_SLFS;\n  }\n#endif\n  return FD_INVALID;\n}\n\n#if MG_TI_NO_HOST_INTERFACE\nint open(const char *pathname, unsigned flags, int mode) {\n#else\nint _open(const char *pathname, int flags, mode_t mode) {\n#endif\n  int fd = -1;\n  bool is_sl;\n  const char *fname = drop_dir(pathname, &is_sl);\n  if (is_sl) {\n#ifdef MG_FS_SLFS\n    fd = fs_slfs_open(fname, flags, mode);\n    if (fd >= 0) fd += SLFS_FD_BASE;\n#endif\n  } else {\n#ifdef CC3200_FS_SPIFFS\n    fd = fs_spiffs_open(fname, flags, mode);\n    if (fd >= 0) fd += SPIFFS_FD_BASE;\n#endif\n  }\n  LOG(LL_DEBUG,\n      (\"open(%s, 0x%x) = %d, fname = %s\", pathname, flags, fd, fname));\n  return fd;\n}\n\nint _stat(const char *pathname, struct stat *st) {\n  int res = -1;\n  bool is_sl;\n  const char *fname = drop_dir(pathname, &is_sl);\n  memset(st, 0, sizeof(*st));\n  /* Simulate statting the root directory. */\n  if (fname[0] == '\\0' || strcmp(fname, \".\") == 0) {\n    st->st_ino = 0;\n    st->st_mode = S_IFDIR | 0777;\n    st->st_nlink = 1;\n    st->st_size = 0;\n    return 0;\n  }\n  if (is_sl) {\n#ifdef MG_FS_SLFS\n    res = fs_slfs_stat(fname, st);\n#endif\n  } else {\n#ifdef CC3200_FS_SPIFFS\n    res = fs_spiffs_stat(fname, st);\n#endif\n  }\n  LOG(LL_DEBUG, (\"stat(%s) = %d; fname = %s\", pathname, res, fname));\n  return res;\n}\n\n#if MG_TI_NO_HOST_INTERFACE\nint close(int fd) {\n#else\nint _close(int fd) {\n#endif\n  int r = -1;\n  switch (fd_type(fd)) {\n    case FD_INVALID:\n      r = set_errno(EBADF);\n      break;\n    case FD_SYS:\n      r = set_errno(EACCES);\n      break;\n#ifdef CC3200_FS_SPIFFS\n    case FD_SPIFFS:\n      r = fs_spiffs_close(fd - SPIFFS_FD_BASE);\n      break;\n#endif\n#ifdef MG_FS_SLFS\n    case FD_SLFS:\n      r = fs_slfs_close(fd - SLFS_FD_BASE);\n      break;\n#endif\n  }\n  DBG((\"close(%d) = %d\", fd, r));\n  return r;\n}\n\n#if MG_TI_NO_HOST_INTERFACE\noff_t lseek(int fd, off_t offset, int whence) {\n#else\noff_t _lseek(int fd, off_t offset, int whence) {\n#endif\n  int r = -1;\n  switch (fd_type(fd)) {\n    case FD_INVALID:\n      r = set_errno(EBADF);\n      break;\n    case FD_SYS:\n      r = set_errno(ESPIPE);\n      break;\n#ifdef CC3200_FS_SPIFFS\n    case FD_SPIFFS:\n      r = fs_spiffs_lseek(fd - SPIFFS_FD_BASE, offset, whence);\n      break;\n#endif\n#ifdef MG_FS_SLFS\n    case FD_SLFS:\n      r = fs_slfs_lseek(fd - SLFS_FD_BASE, offset, whence);\n      break;\n#endif\n  }\n  DBG((\"lseek(%d, %d, %d) = %d\", fd, (int) offset, whence, r));\n  return r;\n}\n\nint _fstat(int fd, struct stat *s) {\n  int r = -1;\n  memset(s, 0, sizeof(*s));\n  switch (fd_type(fd)) {\n    case FD_INVALID:\n      r = set_errno(EBADF);\n      break;\n    case FD_SYS: {\n      /* Create barely passable stats for STD{IN,OUT,ERR}. */\n      memset(s, 0, sizeof(*s));\n      s->st_ino = fd;\n      s->st_mode = S_IFCHR | 0666;\n      r = 0;\n      break;\n    }\n#ifdef CC3200_FS_SPIFFS\n    case FD_SPIFFS:\n      r = fs_spiffs_fstat(fd - SPIFFS_FD_BASE, s);\n      break;\n#endif\n#ifdef MG_FS_SLFS\n    case FD_SLFS:\n      r = fs_slfs_fstat(fd - SLFS_FD_BASE, s);\n      break;\n#endif\n  }\n  DBG((\"fstat(%d) = %d\", fd, r));\n  return r;\n}\n\n#if MG_TI_NO_HOST_INTERFACE\nint read(int fd, char *buf, unsigned count) {\n#else\nssize_t _read(int fd, void *buf, size_t count) {\n#endif\n  int r = -1;\n  switch (fd_type(fd)) {\n    case FD_INVALID:\n      r = set_errno(EBADF);\n      break;\n    case FD_SYS: {\n      if (fd != 0) {\n        r = set_errno(EACCES);\n        break;\n      }\n      /* Should we allow reading from stdin = uart? */\n      r = set_errno(ENOTSUP);\n      break;\n    }\n#ifdef CC3200_FS_SPIFFS\n    case FD_SPIFFS:\n      r = fs_spiffs_read(fd - SPIFFS_FD_BASE, buf, count);\n      break;\n#endif\n#ifdef MG_FS_SLFS\n    case FD_SLFS:\n      r = fs_slfs_read(fd - SLFS_FD_BASE, buf, count);\n      break;\n#endif\n  }\n  DBG((\"read(%d, %u) = %d\", fd, count, r));\n  return r;\n}\n\n#if MG_TI_NO_HOST_INTERFACE\nint write(int fd, const char *buf, unsigned count) {\n#else\nssize_t _write(int fd, const void *buf, size_t count) {\n#endif\n  int r = -1;\n  size_t i = 0;\n  switch (fd_type(fd)) {\n    case FD_INVALID:\n      r = set_errno(EBADF);\n      break;\n    case FD_SYS: {\n      if (fd == 0) {\n        r = set_errno(EACCES);\n        break;\n      }\n      for (i = 0; i < count; i++) {\n        const char c = ((const char *) buf)[i];\n        if (c == '\\n') MG_UART_CHAR_PUT(fd, '\\r');\n        MG_UART_CHAR_PUT(fd, c);\n      }\n      r = count;\n      break;\n    }\n#ifdef CC3200_FS_SPIFFS\n    case FD_SPIFFS:\n      r = fs_spiffs_write(fd - SPIFFS_FD_BASE, buf, count);\n      break;\n#endif\n#ifdef MG_FS_SLFS\n    case FD_SLFS:\n      r = fs_slfs_write(fd - SLFS_FD_BASE, buf, count);\n      break;\n#endif\n  }\n  return r;\n}\n\n/*\n * On Newlib we override rename directly too, because the default\n * implementation using _link and _unlink doesn't work for us.\n */\n#if MG_TI_NO_HOST_INTERFACE || defined(_NEWLIB_VERSION)\nint rename(const char *frompath, const char *topath) {\n  int r = -1;\n  bool is_sl_from, is_sl_to;\n  const char *from = drop_dir(frompath, &is_sl_from);\n  const char *to = drop_dir(topath, &is_sl_to);\n  if (is_sl_from || is_sl_to) {\n    set_errno(ENOTSUP);\n  } else {\n#ifdef CC3200_FS_SPIFFS\n    r = fs_spiffs_rename(from, to);\n#endif\n  }\n  DBG((\"rename(%s, %s) = %d\", from, to, r));\n  return r;\n}\n#endif /* MG_TI_NO_HOST_INTERFACE || defined(_NEWLIB_VERSION) */\n\n#if MG_TI_NO_HOST_INTERFACE\nint unlink(const char *pathname) {\n#else\nint _unlink(const char *pathname) {\n#endif\n  int r = -1;\n  bool is_sl;\n  const char *fname = drop_dir(pathname, &is_sl);\n  if (is_sl) {\n#ifdef MG_FS_SLFS\n    r = fs_slfs_unlink(fname);\n#endif\n  } else {\n#ifdef CC3200_FS_SPIFFS\n    r = fs_spiffs_unlink(fname);\n#endif\n  }\n  DBG((\"unlink(%s) = %d, fname = %s\", pathname, r, fname));\n  return r;\n}\n\n#ifdef CC3200_FS_SPIFFS /* FailFS does not support listing files. */\nDIR *opendir(const char *dir_name) {\n  DIR *r = NULL;\n  bool is_sl;\n  drop_dir(dir_name, &is_sl);\n  if (is_sl) {\n    r = NULL;\n    set_errno(ENOTSUP);\n  } else {\n    r = fs_spiffs_opendir(dir_name);\n  }\n  DBG((\"opendir(%s) = %p\", dir_name, r));\n  return r;\n}\n\nstruct dirent *readdir(DIR *dir) {\n  struct dirent *res = fs_spiffs_readdir(dir);\n  DBG((\"readdir(%p) = %p\", dir, res));\n  return res;\n}\n\nint closedir(DIR *dir) {\n  int res = fs_spiffs_closedir(dir);\n  DBG((\"closedir(%p) = %d\", dir, res));\n  return res;\n}\n\nint rmdir(const char *path) {\n  return fs_spiffs_rmdir(path);\n}\n\nint mkdir(const char *path, mode_t mode) {\n  (void) path;\n  (void) mode;\n  /* for spiffs supports only root dir, which comes from mongoose as '.' */\n  return (strlen(path) == 1 && *path == '.') ? 0 : ENOTDIR;\n}\n#endif\n\nint sl_fs_init(void) {\n  int ret = 1;\n#ifdef __TI_COMPILER_VERSION__\n#ifdef MG_FS_SLFS\n#pragma diag_push\n#pragma diag_suppress 169 /* Nothing we can do about the prototype mismatch. \\\n                             */\n  ret = (add_device(\"SL\", _MSA, fs_slfs_open, fs_slfs_close, fs_slfs_read,\n                    fs_slfs_write, fs_slfs_lseek, fs_slfs_unlink,\n                    fs_slfs_rename) == 0);\n#pragma diag_pop\n#endif\n#endif\n  return ret;\n}\n\n#endif /* MG_NET_IF == MG_NET_IF_SIMPLELINK && (defined(MG_FS_SLFS) || \\\n          defined(MG_FS_SPIFFS)) */\n#ifdef MG_MODULE_LINES\n#line 1 \"common/platforms/simplelink/sl_socket.c\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#if MG_NET_IF == MG_NET_IF_SIMPLELINK\n\n#include <errno.h>\n#include <stdio.h>\n\n/* Amalgamated: #include \"common/platform.h\" */\n\nconst char *inet_ntop(int af, const void *src, char *dst, socklen_t size) {\n  int res;\n  struct in_addr *in = (struct in_addr *) src;\n  if (af != AF_INET) {\n    errno = EAFNOSUPPORT;\n    return NULL;\n  }\n  res = snprintf(dst, size, \"%lu.%lu.%lu.%lu\", SL_IPV4_BYTE(in->s_addr, 0),\n                 SL_IPV4_BYTE(in->s_addr, 1), SL_IPV4_BYTE(in->s_addr, 2),\n                 SL_IPV4_BYTE(in->s_addr, 3));\n  return res > 0 ? dst : NULL;\n}\n\nchar *inet_ntoa(struct in_addr n) {\n  static char a[16];\n  return (char *) inet_ntop(AF_INET, &n, a, sizeof(a));\n}\n\nint inet_pton(int af, const char *src, void *dst) {\n  uint32_t a0, a1, a2, a3;\n  uint8_t *db = (uint8_t *) dst;\n  if (af != AF_INET) {\n    errno = EAFNOSUPPORT;\n    return 0;\n  }\n  if (sscanf(src, \"%lu.%lu.%lu.%lu\", &a0, &a1, &a2, &a3) != 4) {\n    return 0;\n  }\n  *db = a3;\n  *(db + 1) = a2;\n  *(db + 2) = a1;\n  *(db + 3) = a0;\n  return 1;\n}\n\n#endif /* MG_NET_IF == MG_NET_IF_SIMPLELINK */\n#ifdef MG_MODULE_LINES\n#line 1 \"common/platforms/simplelink/sl_mg_task.c\"\n#endif\n#if MG_NET_IF == MG_NET_IF_SIMPLELINK && !defined(MG_SIMPLELINK_NO_OSI)\n\n/* Amalgamated: #include \"mg_task.h\" */\n\n#include <oslib/osi.h>\n\nenum mg_q_msg_type {\n  MG_Q_MSG_CB,\n};\nstruct mg_q_msg {\n  enum mg_q_msg_type type;\n  void (*cb)(struct mg_mgr *mgr, void *arg);\n  void *arg;\n};\nstatic OsiMsgQ_t s_mg_q;\nstatic void mg_task(void *arg);\n\nbool mg_start_task(int priority, int stack_size, mg_init_cb mg_init) {\n  if (osi_MsgQCreate(&s_mg_q, \"MG\", sizeof(struct mg_q_msg), 16) != OSI_OK) {\n    return false;\n  }\n  if (osi_TaskCreate(mg_task, (const signed char *) \"MG\", stack_size,\n                     (void *) mg_init, priority, NULL) != OSI_OK) {\n    return false;\n  }\n  return true;\n}\n\nstatic void mg_task(void *arg) {\n  struct mg_mgr mgr;\n  mg_init_cb mg_init = (mg_init_cb) arg;\n  mg_mgr_init(&mgr, NULL);\n  mg_init(&mgr);\n  while (1) {\n    struct mg_q_msg msg;\n    mg_mgr_poll(&mgr, 1);\n    if (osi_MsgQRead(&s_mg_q, &msg, 1) != OSI_OK) continue;\n    switch (msg.type) {\n      case MG_Q_MSG_CB: {\n        msg.cb(&mgr, msg.arg);\n      }\n    }\n  }\n}\n\nvoid mg_run_in_task(void (*cb)(struct mg_mgr *mgr, void *arg), void *cb_arg) {\n  struct mg_q_msg msg = {MG_Q_MSG_CB, cb, cb_arg};\n  osi_MsgQWrite(&s_mg_q, &msg, OSI_NO_WAIT);\n}\n\n#endif /* MG_NET_IF == MG_NET_IF_SIMPLELINK && !defined(MG_SIMPLELINK_NO_OSI) \\\n          */\n#ifdef MG_MODULE_LINES\n#line 1 \"common/platforms/simplelink/sl_net_if.h\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#ifndef CS_COMMON_PLATFORMS_SIMPLELINK_SL_NET_IF_H_\n#define CS_COMMON_PLATFORMS_SIMPLELINK_SL_NET_IF_H_\n\n/* Amalgamated: #include \"mongoose/src/net_if.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif /* __cplusplus */\n\n#ifndef MG_ENABLE_NET_IF_SIMPLELINK\n#define MG_ENABLE_NET_IF_SIMPLELINK MG_NET_IF == MG_NET_IF_SIMPLELINK\n#endif\n\nextern const struct mg_iface_vtable mg_simplelink_iface_vtable;\n\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n\n#endif /* CS_COMMON_PLATFORMS_SIMPLELINK_SL_NET_IF_H_ */\n#ifdef MG_MODULE_LINES\n#line 1 \"common/platforms/simplelink/sl_net_if.c\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n/* Amalgamated: #include \"common/platforms/simplelink/sl_net_if.h\" */\n\n#if MG_ENABLE_NET_IF_SIMPLELINK\n\n/* Amalgamated: #include \"mongoose/src/internal.h\" */\n/* Amalgamated: #include \"mongoose/src/util.h\" */\n\n#define MG_TCP_RECV_BUFFER_SIZE 1024\n#define MG_UDP_RECV_BUFFER_SIZE 1500\n\nstatic sock_t mg_open_listening_socket(union socket_address *sa, int type,\n                                       int proto);\n\nint sl_set_ssl_opts(struct mg_connection *nc);\n\nvoid mg_set_non_blocking_mode(sock_t sock) {\n  SlSockNonblocking_t opt;\n  opt.NonblockingEnabled = 1;\n  sl_SetSockOpt(sock, SL_SOL_SOCKET, SL_SO_NONBLOCKING, &opt, sizeof(opt));\n}\n\nstatic int mg_is_error(int n) {\n  return (n < 0 && n != SL_EALREADY && n != SL_EAGAIN);\n}\n\nvoid mg_sl_if_connect_tcp(struct mg_connection *nc,\n                          const union socket_address *sa) {\n  int proto = 0;\n  if (nc->flags & MG_F_SSL) proto = SL_SEC_SOCKET;\n  sock_t sock = sl_Socket(AF_INET, SOCK_STREAM, proto);\n  if (sock < 0) {\n    nc->err = sock;\n    goto out;\n  }\n  mg_sock_set(nc, sock);\n#if MG_ENABLE_SSL\n  nc->err = sl_set_ssl_opts(nc);\n  if (nc->err != 0) goto out;\n#endif\n  nc->err = sl_Connect(sock, &sa->sa, sizeof(sa->sin));\nout:\n  DBG((\"%p to %s:%d sock %d %d err %d\", nc, inet_ntoa(sa->sin.sin_addr),\n       ntohs(sa->sin.sin_port), nc->sock, proto, nc->err));\n}\n\nvoid mg_sl_if_connect_udp(struct mg_connection *nc) {\n  sock_t sock = sl_Socket(AF_INET, SOCK_DGRAM, 0);\n  if (sock < 0) {\n    nc->err = sock;\n    return;\n  }\n  mg_sock_set(nc, sock);\n  nc->err = 0;\n}\n\nint mg_sl_if_listen_tcp(struct mg_connection *nc, union socket_address *sa) {\n  int proto = 0;\n  if (nc->flags & MG_F_SSL) proto = SL_SEC_SOCKET;\n  sock_t sock = mg_open_listening_socket(sa, SOCK_STREAM, proto);\n  if (sock < 0) return sock;\n  mg_sock_set(nc, sock);\n#if MG_ENABLE_SSL\n  return sl_set_ssl_opts(nc);\n#else\n  return 0;\n#endif\n}\n\nint mg_sl_if_listen_udp(struct mg_connection *nc, union socket_address *sa) {\n  sock_t sock = mg_open_listening_socket(sa, SOCK_DGRAM, 0);\n  if (sock == INVALID_SOCKET) return (errno ? errno : 1);\n  mg_sock_set(nc, sock);\n  return 0;\n}\n\nvoid mg_sl_if_tcp_send(struct mg_connection *nc, const void *buf, size_t len) {\n  mbuf_append(&nc->send_mbuf, buf, len);\n}\n\nvoid mg_sl_if_udp_send(struct mg_connection *nc, const void *buf, size_t len) {\n  mbuf_append(&nc->send_mbuf, buf, len);\n}\n\nvoid mg_sl_if_recved(struct mg_connection *nc, size_t len) {\n  (void) nc;\n  (void) len;\n}\n\nint mg_sl_if_create_conn(struct mg_connection *nc) {\n  (void) nc;\n  return 1;\n}\n\nvoid mg_sl_if_destroy_conn(struct mg_connection *nc) {\n  if (nc->sock == INVALID_SOCKET) return;\n  /* For UDP, only close outgoing sockets or listeners. */\n  if (!(nc->flags & MG_F_UDP) || nc->listener == NULL) {\n    sl_Close(nc->sock);\n  }\n  nc->sock = INVALID_SOCKET;\n}\n\nstatic int mg_accept_conn(struct mg_connection *lc) {\n  struct mg_connection *nc;\n  union socket_address sa;\n  socklen_t sa_len = sizeof(sa);\n  sock_t sock = sl_Accept(lc->sock, &sa.sa, &sa_len);\n  if (sock < 0) {\n    DBG((\"%p: failed to accept: %d\", lc, sock));\n    return 0;\n  }\n  nc = mg_if_accept_new_conn(lc);\n  if (nc == NULL) {\n    sl_Close(sock);\n    return 0;\n  }\n  DBG((\"%p conn from %s:%d\", nc, inet_ntoa(sa.sin.sin_addr),\n       ntohs(sa.sin.sin_port)));\n  mg_sock_set(nc, sock);\n  if (nc->flags & MG_F_SSL) nc->flags |= MG_F_SSL_HANDSHAKE_DONE;\n  mg_if_accept_tcp_cb(nc, &sa, sa_len);\n  return 1;\n}\n\n/* 'sa' must be an initialized address to bind to */\nstatic sock_t mg_open_listening_socket(union socket_address *sa, int type,\n                                       int proto) {\n  int r;\n  socklen_t sa_len =\n      (sa->sa.sa_family == AF_INET) ? sizeof(sa->sin) : sizeof(sa->sin6);\n  sock_t sock = sl_Socket(sa->sa.sa_family, type, proto);\n  if (sock < 0) return sock;\n  if ((r = sl_Bind(sock, &sa->sa, sa_len)) < 0) {\n    sl_Close(sock);\n    return r;\n  }\n  if (type != SOCK_DGRAM && (r = sl_Listen(sock, SOMAXCONN)) < 0) {\n    sl_Close(sock);\n    return r;\n  }\n  mg_set_non_blocking_mode(sock);\n  return sock;\n}\n\nstatic void mg_write_to_socket(struct mg_connection *nc) {\n  struct mbuf *io = &nc->send_mbuf;\n  int n = 0;\n\n  if (nc->flags & MG_F_UDP) {\n    n = sl_SendTo(nc->sock, io->buf, io->len, 0, &nc->sa.sa,\n                  sizeof(nc->sa.sin));\n    DBG((\"%p %d %d %d %s:%hu\", nc, nc->sock, n, errno,\n         inet_ntoa(nc->sa.sin.sin_addr), ntohs(nc->sa.sin.sin_port)));\n  } else {\n    n = (int) sl_Send(nc->sock, io->buf, io->len, 0);\n    DBG((\"%p %d bytes -> %d\", nc, n, nc->sock));\n  }\n\n  if (n > 0) {\n    mbuf_remove(io, n);\n    mg_if_sent_cb(nc, n);\n  } else if (n < 0 && mg_is_error(n)) {\n    /* Something went wrong, drop the connection. */\n    nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n  }\n}\n\nMG_INTERNAL size_t recv_avail_size(struct mg_connection *conn, size_t max) {\n  size_t avail;\n  if (conn->recv_mbuf_limit < conn->recv_mbuf.len) return 0;\n  avail = conn->recv_mbuf_limit - conn->recv_mbuf.len;\n  return avail > max ? max : avail;\n}\n\nstatic void mg_handle_tcp_read(struct mg_connection *conn) {\n  int n = 0;\n  char *buf = (char *) MG_MALLOC(MG_TCP_RECV_BUFFER_SIZE);\n\n  if (buf == NULL) {\n    DBG((\"OOM\"));\n    return;\n  }\n\n  n = (int) sl_Recv(conn->sock, buf,\n                    recv_avail_size(conn, MG_TCP_RECV_BUFFER_SIZE), 0);\n  DBG((\"%p %d bytes <- %d\", conn, n, conn->sock));\n  if (n > 0) {\n    mg_if_recv_tcp_cb(conn, buf, n, 1 /* own */);\n  } else {\n    MG_FREE(buf);\n  }\n  if (n == 0) {\n    /* Orderly shutdown of the socket, try flushing output. */\n    conn->flags |= MG_F_SEND_AND_CLOSE;\n  } else if (mg_is_error(n)) {\n    conn->flags |= MG_F_CLOSE_IMMEDIATELY;\n  }\n}\n\nstatic void mg_handle_udp_read(struct mg_connection *nc) {\n  char *buf = (char *) MG_MALLOC(MG_UDP_RECV_BUFFER_SIZE);\n  if (buf == NULL) return;\n  union socket_address sa;\n  socklen_t sa_len = sizeof(sa);\n  int n = sl_RecvFrom(nc->sock, buf, MG_UDP_RECV_BUFFER_SIZE, 0,\n                      (SlSockAddr_t *) &sa, &sa_len);\n  DBG((\"%p %d bytes from %s:%d\", nc, n, inet_ntoa(nc->sa.sin.sin_addr),\n       ntohs(nc->sa.sin.sin_port)));\n  if (n > 0) {\n    mg_if_recv_udp_cb(nc, buf, n, &sa, sa_len);\n  } else {\n    MG_FREE(buf);\n  }\n}\n\n#define _MG_F_FD_CAN_READ 1\n#define _MG_F_FD_CAN_WRITE 1 << 1\n#define _MG_F_FD_ERROR 1 << 2\n\nvoid mg_mgr_handle_conn(struct mg_connection *nc, int fd_flags, double now) {\n  DBG((\"%p fd=%d fd_flags=%d nc_flags=%lu rmbl=%d smbl=%d\", nc, nc->sock,\n       fd_flags, nc->flags, (int) nc->recv_mbuf.len, (int) nc->send_mbuf.len));\n\n  if (nc->flags & MG_F_CONNECTING) {\n    if (nc->flags & MG_F_UDP || nc->err != SL_EALREADY) {\n      mg_if_connect_cb(nc, nc->err);\n    } else {\n      /* In SimpleLink, to get status of non-blocking connect() we need to wait\n       * until socket is writable and repeat the call to sl_Connect again,\n       * which will now return the real status. */\n      if (fd_flags & _MG_F_FD_CAN_WRITE) {\n        nc->err = sl_Connect(nc->sock, &nc->sa.sa, sizeof(nc->sa.sin));\n        DBG((\"%p conn res=%d\", nc, nc->err));\n        if (nc->err == SL_ESECSNOVERIFY ||\n            /* TODO(rojer): Provide API to set the date for verification. */\n            nc->err == SL_ESECDATEERROR) {\n          nc->err = 0;\n        }\n        if (nc->flags & MG_F_SSL && nc->err == 0) {\n          nc->flags |= MG_F_SSL_HANDSHAKE_DONE;\n        }\n        mg_if_connect_cb(nc, nc->err);\n      }\n    }\n    /* Ignore read/write in further processing, we've handled it. */\n    fd_flags &= ~(_MG_F_FD_CAN_READ | _MG_F_FD_CAN_WRITE);\n  }\n\n  if (fd_flags & _MG_F_FD_CAN_READ) {\n    if (nc->flags & MG_F_UDP) {\n      mg_handle_udp_read(nc);\n    } else {\n      if (nc->flags & MG_F_LISTENING) {\n        mg_accept_conn(nc);\n      } else {\n        mg_handle_tcp_read(nc);\n      }\n    }\n  }\n\n  if (!(nc->flags & MG_F_CLOSE_IMMEDIATELY)) {\n    if ((fd_flags & _MG_F_FD_CAN_WRITE) && nc->send_mbuf.len > 0) {\n      mg_write_to_socket(nc);\n    }\n\n    if (!(fd_flags & (_MG_F_FD_CAN_READ | _MG_F_FD_CAN_WRITE))) {\n      mg_if_poll(nc, now);\n    }\n    mg_if_timer(nc, now);\n  }\n\n  DBG((\"%p after fd=%d nc_flags=%lu rmbl=%d smbl=%d\", nc, nc->sock, nc->flags,\n       (int) nc->recv_mbuf.len, (int) nc->send_mbuf.len));\n}\n\n/* Associate a socket to a connection. */\nvoid mg_sl_if_sock_set(struct mg_connection *nc, sock_t sock) {\n  mg_set_non_blocking_mode(sock);\n  nc->sock = sock;\n  DBG((\"%p %d\", nc, sock));\n}\n\nvoid mg_sl_if_init(struct mg_iface *iface) {\n  (void) iface;\n  DBG((\"%p using sl_Select()\", iface->mgr));\n}\n\nvoid mg_sl_if_free(struct mg_iface *iface) {\n  (void) iface;\n}\n\nvoid mg_sl_if_add_conn(struct mg_connection *nc) {\n  (void) nc;\n}\n\nvoid mg_sl_if_remove_conn(struct mg_connection *nc) {\n  (void) nc;\n}\n\ntime_t mg_sl_if_poll(struct mg_iface *iface, int timeout_ms) {\n  struct mg_mgr *mgr = iface->mgr;\n  double now = mg_time();\n  double min_timer;\n  struct mg_connection *nc, *tmp;\n  struct SlTimeval_t tv;\n  SlFdSet_t read_set, write_set, err_set;\n  sock_t max_fd = INVALID_SOCKET;\n  int num_fds, num_ev = 0, num_timers = 0;\n\n  SL_FD_ZERO(&read_set);\n  SL_FD_ZERO(&write_set);\n  SL_FD_ZERO(&err_set);\n\n  /*\n   * Note: it is ok to have connections with sock == INVALID_SOCKET in the list,\n   * e.g. timer-only \"connections\".\n   */\n  min_timer = 0;\n  for (nc = mgr->active_connections, num_fds = 0; nc != NULL; nc = tmp) {\n    tmp = nc->next;\n\n    if (nc->sock != INVALID_SOCKET) {\n      num_fds++;\n\n      if (!(nc->flags & MG_F_WANT_WRITE) &&\n          nc->recv_mbuf.len < nc->recv_mbuf_limit &&\n          (!(nc->flags & MG_F_UDP) || nc->listener == NULL)) {\n        SL_FD_SET(nc->sock, &read_set);\n        if (max_fd == INVALID_SOCKET || nc->sock > max_fd) max_fd = nc->sock;\n      }\n\n      if (((nc->flags & MG_F_CONNECTING) && !(nc->flags & MG_F_WANT_READ)) ||\n          (nc->send_mbuf.len > 0 && !(nc->flags & MG_F_CONNECTING))) {\n        SL_FD_SET(nc->sock, &write_set);\n        SL_FD_SET(nc->sock, &err_set);\n        if (max_fd == INVALID_SOCKET || nc->sock > max_fd) max_fd = nc->sock;\n      }\n    }\n\n    if (nc->ev_timer_time > 0) {\n      if (num_timers == 0 || nc->ev_timer_time < min_timer) {\n        min_timer = nc->ev_timer_time;\n      }\n      num_timers++;\n    }\n  }\n\n  /*\n   * If there is a timer to be fired earlier than the requested timeout,\n   * adjust the timeout.\n   */\n  if (num_timers > 0) {\n    double timer_timeout_ms = (min_timer - mg_time()) * 1000 + 1 /* rounding */;\n    if (timer_timeout_ms < timeout_ms) {\n      timeout_ms = timer_timeout_ms;\n    }\n  }\n  if (timeout_ms < 0) timeout_ms = 0;\n\n  tv.tv_sec = timeout_ms / 1000;\n  tv.tv_usec = (timeout_ms % 1000) * 1000;\n\n  if (num_fds > 0) {\n    num_ev = sl_Select((int) max_fd + 1, &read_set, &write_set, &err_set, &tv);\n  }\n\n  now = mg_time();\n  DBG((\"sl_Select @ %ld num_ev=%d of %d, timeout=%d\", (long) now, num_ev,\n       num_fds, timeout_ms));\n\n  for (nc = mgr->active_connections; nc != NULL; nc = tmp) {\n    int fd_flags = 0;\n    if (nc->sock != INVALID_SOCKET) {\n      if (num_ev > 0) {\n        fd_flags =\n            (SL_FD_ISSET(nc->sock, &read_set) &&\n                     (!(nc->flags & MG_F_UDP) || nc->listener == NULL)\n                 ? _MG_F_FD_CAN_READ\n                 : 0) |\n            (SL_FD_ISSET(nc->sock, &write_set) ? _MG_F_FD_CAN_WRITE : 0) |\n            (SL_FD_ISSET(nc->sock, &err_set) ? _MG_F_FD_ERROR : 0);\n      }\n      /* SimpleLink does not report UDP sockets as writable. */\n      if (nc->flags & MG_F_UDP && nc->send_mbuf.len > 0) {\n        fd_flags |= _MG_F_FD_CAN_WRITE;\n      }\n    }\n    tmp = nc->next;\n    mg_mgr_handle_conn(nc, fd_flags, now);\n  }\n\n  for (nc = mgr->active_connections; nc != NULL; nc = tmp) {\n    tmp = nc->next;\n    if ((nc->flags & MG_F_CLOSE_IMMEDIATELY) ||\n        (nc->send_mbuf.len == 0 && (nc->flags & MG_F_SEND_AND_CLOSE))) {\n      mg_close_conn(nc);\n    }\n  }\n\n  return now;\n}\n\nvoid mg_sl_if_get_conn_addr(struct mg_connection *nc, int remote,\n                            union socket_address *sa) {\n  /* SimpleLink does not provide a way to get socket's peer address after\n   * accept or connect. Address should have been preserved in the connection,\n   * so we do our best here by using it. */\n  if (remote) memcpy(sa, &nc->sa, sizeof(*sa));\n}\n\nvoid sl_restart_cb(struct mg_mgr *mgr) {\n  /*\n   * SimpleLink has been restarted, meaning all sockets have been invalidated.\n   * We try our best - we'll restart the listeners, but for outgoing\n   * connections we have no option but to terminate.\n   */\n  struct mg_connection *nc;\n  for (nc = mg_next(mgr, NULL); nc != NULL; nc = mg_next(mgr, nc)) {\n    if (nc->sock == INVALID_SOCKET) continue; /* Could be a timer */\n    if (nc->flags & MG_F_LISTENING) {\n      DBG((\"restarting %p %s:%d\", nc, inet_ntoa(nc->sa.sin.sin_addr),\n           ntohs(nc->sa.sin.sin_port)));\n      int res = (nc->flags & MG_F_UDP ? mg_sl_if_listen_udp(nc, &nc->sa)\n                                      : mg_sl_if_listen_tcp(nc, &nc->sa));\n      if (res == 0) continue;\n      /* Well, we tried and failed. Fall through to closing. */\n    }\n    nc->sock = INVALID_SOCKET;\n    DBG((\"terminating %p %s:%d\", nc, inet_ntoa(nc->sa.sin.sin_addr),\n         ntohs(nc->sa.sin.sin_port)));\n    /* TODO(rojer): Outgoing UDP? */\n    nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n  }\n}\n\n/* clang-format off */\n#define MG_SL_IFACE_VTABLE                                              \\\n  {                                                                     \\\n    mg_sl_if_init,                                                      \\\n    mg_sl_if_free,                                                      \\\n    mg_sl_if_add_conn,                                                  \\\n    mg_sl_if_remove_conn,                                               \\\n    mg_sl_if_poll,                                                      \\\n    mg_sl_if_listen_tcp,                                                \\\n    mg_sl_if_listen_udp,                                                \\\n    mg_sl_if_connect_tcp,                                               \\\n    mg_sl_if_connect_udp,                                               \\\n    mg_sl_if_tcp_send,                                                  \\\n    mg_sl_if_udp_send,                                                  \\\n    mg_sl_if_recved,                                                    \\\n    mg_sl_if_create_conn,                                               \\\n    mg_sl_if_destroy_conn,                                              \\\n    mg_sl_if_sock_set,                                                  \\\n    mg_sl_if_get_conn_addr,                                             \\\n  }\n/* clang-format on */\n\nconst struct mg_iface_vtable mg_simplelink_iface_vtable = MG_SL_IFACE_VTABLE;\n#if MG_NET_IF == MG_NET_IF_SIMPLELINK\nconst struct mg_iface_vtable mg_default_iface_vtable = MG_SL_IFACE_VTABLE;\n#endif\n\n#endif /* MG_ENABLE_NET_IF_SIMPLELINK */\n#ifdef MG_MODULE_LINES\n#line 1 \"common/platforms/simplelink/sl_ssl_if.c\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#if MG_ENABLE_SSL && MG_SSL_IF == MG_SSL_IF_SIMPLELINK\n\n/* Amalgamated: #include \"common/mg_mem.h\" */\n\nstruct mg_ssl_if_ctx {\n  char *ssl_cert;\n  char *ssl_key;\n  char *ssl_ca_cert;\n  char *ssl_server_name;\n};\n\nvoid mg_ssl_if_init() {\n}\n\nenum mg_ssl_if_result mg_ssl_if_conn_init(\n    struct mg_connection *nc, const struct mg_ssl_if_conn_params *params,\n    const char **err_msg) {\n  struct mg_ssl_if_ctx *ctx =\n      (struct mg_ssl_if_ctx *) MG_CALLOC(1, sizeof(*ctx));\n  if (ctx == NULL) {\n    MG_SET_PTRPTR(err_msg, \"Out of memory\");\n    return MG_SSL_ERROR;\n  }\n  nc->ssl_if_data = ctx;\n\n  if (params->cert != NULL || params->key != NULL) {\n    if (params->cert != NULL && params->key != NULL) {\n      ctx->ssl_cert = strdup(params->cert);\n      ctx->ssl_key = strdup(params->key);\n    } else {\n      MG_SET_PTRPTR(err_msg, \"Both cert and key are required.\");\n      return MG_SSL_ERROR;\n    }\n  }\n  if (params->ca_cert != NULL && strcmp(params->ca_cert, \"*\") != 0) {\n    ctx->ssl_ca_cert = strdup(params->ca_cert);\n  }\n  /* TODO(rojer): cipher_suites. */\n  if (params->server_name != NULL) {\n    ctx->ssl_server_name = strdup(params->server_name);\n  }\n  return MG_SSL_OK;\n}\n\nvoid mg_ssl_if_conn_close_notify(struct mg_connection *nc) {\n  /* Nothing to do */\n  (void) nc;\n}\n\nvoid mg_ssl_if_conn_free(struct mg_connection *nc) {\n  struct mg_ssl_if_ctx *ctx = (struct mg_ssl_if_ctx *) nc->ssl_if_data;\n  if (ctx == NULL) return;\n  nc->ssl_if_data = NULL;\n  MG_FREE(ctx->ssl_cert);\n  MG_FREE(ctx->ssl_key);\n  MG_FREE(ctx->ssl_ca_cert);\n  MG_FREE(ctx->ssl_server_name);\n  memset(ctx, 0, sizeof(*ctx));\n  MG_FREE(ctx);\n}\n\nbool pem_to_der(const char *pem_file, const char *der_file) {\n  bool ret = false;\n  FILE *pf = NULL, *df = NULL;\n  bool writing = false;\n  pf = fopen(pem_file, \"r\");\n  if (pf == NULL) goto clean;\n  remove(der_file);\n  fs_slfs_set_new_file_size(der_file + 3, 2048);\n  df = fopen(der_file, \"w\");\n  if (df == NULL) goto clean;\n  while (1) {\n    char pem_buf[70];\n    char der_buf[48];\n    if (!fgets(pem_buf, sizeof(pem_buf), pf)) break;\n    if (writing) {\n      if (strstr(pem_buf, \"-----END \") != NULL) {\n        ret = true;\n        break;\n      }\n      int l = 0;\n      while (!isspace((unsigned int) pem_buf[l])) l++;\n      int der_len = 0;\n      cs_base64_decode((const unsigned char *) pem_buf, sizeof(pem_buf),\n                       der_buf, &der_len);\n      if (der_len <= 0) break;\n      if (fwrite(der_buf, 1, der_len, df) != der_len) break;\n    } else if (strstr(pem_buf, \"-----BEGIN \") != NULL) {\n      writing = true;\n    }\n  }\n\nclean:\n  if (pf != NULL) fclose(pf);\n  if (df != NULL) {\n    fclose(df);\n    if (!ret) remove(der_file);\n  }\n  return ret;\n}\n\n#if MG_ENABLE_FILESYSTEM && defined(MG_FS_SLFS)\n/* If the file's extension is .pem, convert it to DER format and put on SLFS. */\nstatic char *sl_pem2der(const char *pem_file) {\n  const char *pem_ext = strstr(pem_file, \".pem\");\n  if (pem_ext == NULL || *(pem_ext + 4) != '\\0') {\n    return strdup(pem_file);\n  }\n  char *der_file = NULL;\n  /* DER file must be located on SLFS, add prefix. */\n  int l = mg_asprintf(&der_file, 0, \"SL:%.*s.der\", (int) (pem_ext - pem_file),\n                      pem_file);\n  if (der_file == NULL) return NULL;\n  bool result = false;\n  cs_stat_t st;\n  if (mg_stat(der_file, &st) != 0) {\n    result = pem_to_der(pem_file, der_file);\n    LOG(LL_DEBUG, (\"%s -> %s = %d\", pem_file, der_file, result));\n  } else {\n    /* File exists, assume it's already been converted. */\n    result = true;\n  }\n  if (result) {\n    /* Strip the SL: prefix we added since NWP does not expect it. */\n    memmove(der_file, der_file + 3, l - 2 /* including \\0 */);\n  } else {\n    MG_FREE(der_file);\n    der_file = NULL;\n  }\n  return der_file;\n}\n#else\nstatic char *sl_pem2der(const char *pem_file) {\n  return strdup(pem_file);\n}\n#endif\n\nint sl_set_ssl_opts(struct mg_connection *nc) {\n  int err;\n  struct mg_ssl_if_ctx *ctx = (struct mg_ssl_if_ctx *) nc->ssl_if_data;\n  DBG((\"%p ssl ctx: %p\", nc, ctx));\n\n  if (ctx != NULL) {\n    DBG((\"%p %s,%s,%s,%s\", nc, (ctx->ssl_cert ? ctx->ssl_cert : \"-\"),\n         (ctx->ssl_key ? ctx->ssl_cert : \"-\"),\n         (ctx->ssl_ca_cert ? ctx->ssl_ca_cert : \"-\"),\n         (ctx->ssl_server_name ? ctx->ssl_server_name : \"-\")));\n    if (ctx->ssl_cert != NULL && ctx->ssl_key != NULL) {\n      char *ssl_cert = sl_pem2der(ctx->ssl_cert);\n      char *ssl_key = sl_pem2der(ctx->ssl_key);\n      if (ssl_cert != NULL && ssl_key != NULL) {\n        err = sl_SetSockOpt(nc->sock, SL_SOL_SOCKET,\n                            SL_SO_SECURE_FILES_CERTIFICATE_FILE_NAME, ssl_cert,\n                            strlen(ssl_cert));\n        LOG(LL_INFO, (\"CERTIFICATE_FILE_NAME %s -> %d\", ssl_cert, err));\n        err = sl_SetSockOpt(nc->sock, SL_SOL_SOCKET,\n                            SL_SO_SECURE_FILES_PRIVATE_KEY_FILE_NAME, ssl_key,\n                            strlen(ssl_key));\n        LOG(LL_INFO, (\"PRIVATE_KEY_FILE_NAME %s -> %d\", ssl_key, err));\n      } else {\n        err = -1;\n      }\n      MG_FREE(ssl_cert);\n      MG_FREE(ssl_key);\n      if (err != 0) return err;\n    }\n    if (ctx->ssl_ca_cert != NULL) {\n      if (ctx->ssl_ca_cert[0] != '\\0') {\n        char *ssl_ca_cert = sl_pem2der(ctx->ssl_ca_cert);\n        if (ssl_ca_cert != NULL) {\n          err = sl_SetSockOpt(nc->sock, SL_SOL_SOCKET,\n                              SL_SO_SECURE_FILES_CA_FILE_NAME, ssl_ca_cert,\n                              strlen(ssl_ca_cert));\n          LOG(LL_INFO, (\"CA_FILE_NAME %s -> %d\", ssl_ca_cert, err));\n        } else {\n          err = -1;\n        }\n        MG_FREE(ssl_ca_cert);\n        if (err != 0) return err;\n      }\n    }\n    if (ctx->ssl_server_name != NULL) {\n      err = sl_SetSockOpt(nc->sock, SL_SOL_SOCKET,\n                          SO_SECURE_DOMAIN_NAME_VERIFICATION,\n                          ctx->ssl_server_name, strlen(ctx->ssl_server_name));\n      DBG((\"DOMAIN_NAME_VERIFICATION %s -> %d\", ctx->ssl_server_name, err));\n      /* Domain name verificationw as added in a NWP service pack, older\n       * versions return SL_ENOPROTOOPT. There isn't much we can do about it,\n       * so we ignore the error. */\n      if (err != 0 && err != SL_ENOPROTOOPT) return err;\n    }\n  }\n  return 0;\n}\n\n#endif /* MG_ENABLE_SSL && MG_SSL_IF == MG_SSL_IF_SIMPLELINK */\n#ifdef MG_MODULE_LINES\n#line 1 \"common/platforms/lwip/mg_lwip_net_if.h\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#ifndef CS_COMMON_PLATFORMS_LWIP_MG_NET_IF_LWIP_H_\n#define CS_COMMON_PLATFORMS_LWIP_MG_NET_IF_LWIP_H_\n\n#ifndef MG_ENABLE_NET_IF_LWIP_LOW_LEVEL\n#define MG_ENABLE_NET_IF_LWIP_LOW_LEVEL MG_NET_IF == MG_NET_IF_LWIP_LOW_LEVEL\n#endif\n\n#if MG_ENABLE_NET_IF_LWIP_LOW_LEVEL\n\n#include <stdint.h>\n\nextern const struct mg_iface_vtable mg_lwip_iface_vtable;\n\nstruct mg_lwip_conn_state {\n  struct mg_connection *nc;\n  struct mg_connection *lc;\n  union {\n    struct tcp_pcb *tcp;\n    struct udp_pcb *udp;\n  } pcb;\n  err_t err;\n  size_t num_sent; /* Number of acknowledged bytes to be reported to the core */\n  struct pbuf *rx_chain; /* Chain of incoming data segments. */\n  size_t rx_offset; /* Offset within the first pbuf (if partially consumed) */\n  /* Last SSL write size, for retries. */\n  int last_ssl_write_size;\n  /* Whether MG_SIG_RECV is already pending for this connection */\n  int recv_pending;\n};\n\nenum mg_sig_type {\n  MG_SIG_CONNECT_RESULT = 1,\n  MG_SIG_RECV = 2,\n  MG_SIG_SENT_CB = 3,\n  MG_SIG_CLOSE_CONN = 4,\n  MG_SIG_TOMBSTONE = 5,\n  MG_SIG_ACCEPT = 6,\n};\n\nvoid mg_lwip_post_signal(enum mg_sig_type sig, struct mg_connection *nc);\n\n/* To be implemented by the platform. */\nvoid mg_lwip_mgr_schedule_poll(struct mg_mgr *mgr);\n\n#endif /* MG_ENABLE_NET_IF_LWIP_LOW_LEVEL */\n\n#endif /* CS_COMMON_PLATFORMS_LWIP_MG_NET_IF_LWIP_H_ */\n#ifdef MG_MODULE_LINES\n#line 1 \"common/platforms/lwip/mg_lwip_net_if.c\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#if MG_ENABLE_NET_IF_LWIP_LOW_LEVEL\n\n/* Amalgamated: #include \"common/mg_mem.h\" */\n\n#include <lwip/pbuf.h>\n#include <lwip/tcp.h>\n#if CS_PLATFORM != CS_P_STM32\n#include <lwip/tcp_impl.h>\n#endif\n#include <lwip/udp.h>\n\n/* Amalgamated: #include \"common/cs_dbg.h\" */\n\n/*\n * Depending on whether Mongoose is compiled with ipv6 support, use right\n * lwip functions\n */\n#if MG_ENABLE_IPV6\n#define TCP_NEW tcp_new_ip6\n#define TCP_BIND tcp_bind_ip6\n#define UDP_BIND udp_bind_ip6\n#define IPADDR_NTOA(x) ip6addr_ntoa((const ip6_addr_t *)(x))\n#define SET_ADDR(dst, src)                               \\\n  memcpy((dst)->sin6.sin6_addr.s6_addr, (src)->ip6.addr, \\\n         sizeof((dst)->sin6.sin6_addr.s6_addr))\n#else\n#define TCP_NEW tcp_new\n#define TCP_BIND tcp_bind\n#define UDP_BIND udp_bind\n#define IPADDR_NTOA ipaddr_ntoa\n#define SET_ADDR(dst, src) (dst)->sin.sin_addr.s_addr = GET_IPV4(src)\n#endif\n\n/*\n * If lwip is compiled with ipv6 support, then API changes even for ipv4\n */\n#if !defined(LWIP_IPV6) || !LWIP_IPV6\n#define GET_IPV4(ipX_addr) ((ipX_addr)->addr)\n#else\n#define GET_IPV4(ipX_addr) ((ipX_addr)->ip4.addr)\n#endif\n\nvoid mg_lwip_ssl_do_hs(struct mg_connection *nc);\nvoid mg_lwip_ssl_send(struct mg_connection *nc);\nvoid mg_lwip_ssl_recv(struct mg_connection *nc);\n\nvoid mg_lwip_if_init(struct mg_iface *iface);\nvoid mg_lwip_if_free(struct mg_iface *iface);\nvoid mg_lwip_if_add_conn(struct mg_connection *nc);\nvoid mg_lwip_if_remove_conn(struct mg_connection *nc);\ntime_t mg_lwip_if_poll(struct mg_iface *iface, int timeout_ms);\n\n#ifdef RTOS_SDK\nextern void mgos_lock();\nextern void mgos_unlock();\n#else\n#define mgos_lock()\n#define mgos_unlock()\n#endif\n\nstatic void mg_lwip_recv_common(struct mg_connection *nc, struct pbuf *p);\n\n#if LWIP_TCP_KEEPALIVE\nvoid mg_lwip_set_keepalive_params(struct mg_connection *nc, int idle,\n                                  int interval, int count) {\n  if (nc->sock == INVALID_SOCKET || nc->flags & MG_F_UDP) {\n    return;\n  }\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n  struct tcp_pcb *tpcb = cs->pcb.tcp;\n  if (idle > 0 && interval > 0 && count > 0) {\n    tpcb->keep_idle = idle * 1000;\n    tpcb->keep_intvl = interval * 1000;\n    tpcb->keep_cnt = count;\n    tpcb->so_options |= SOF_KEEPALIVE;\n  } else {\n    tpcb->so_options &= ~SOF_KEEPALIVE;\n  }\n}\n#elif !defined(MG_NO_LWIP_TCP_KEEPALIVE)\n#warning LWIP TCP keepalive is disabled. Please consider enabling it.\n#endif /* LWIP_TCP_KEEPALIVE */\n\nstatic err_t mg_lwip_tcp_conn_cb(void *arg, struct tcp_pcb *tpcb, err_t err) {\n  struct mg_connection *nc = (struct mg_connection *) arg;\n  DBG((\"%p connect to %s:%u = %d\", nc, IPADDR_NTOA(ipX_2_ip(&tpcb->remote_ip)),\n       tpcb->remote_port, err));\n  if (nc == NULL) {\n    tcp_abort(tpcb);\n    return ERR_ARG;\n  }\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n  cs->err = err;\n#if LWIP_TCP_KEEPALIVE\n  if (err == 0) mg_lwip_set_keepalive_params(nc, 60, 10, 6);\n#endif\n  mg_lwip_post_signal(MG_SIG_CONNECT_RESULT, nc);\n  return ERR_OK;\n}\n\nstatic void mg_lwip_tcp_error_cb(void *arg, err_t err) {\n  struct mg_connection *nc = (struct mg_connection *) arg;\n  DBG((\"%p conn error %d\", nc, err));\n  if (nc == NULL) return;\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n  cs->pcb.tcp = NULL; /* Has already been deallocated */\n  if (nc->flags & MG_F_CONNECTING) {\n    cs->err = err;\n    mg_lwip_post_signal(MG_SIG_CONNECT_RESULT, nc);\n  } else {\n    mg_lwip_post_signal(MG_SIG_CLOSE_CONN, nc);\n  }\n}\n\nstatic err_t mg_lwip_tcp_recv_cb(void *arg, struct tcp_pcb *tpcb,\n                                 struct pbuf *p, err_t err) {\n  struct mg_connection *nc = (struct mg_connection *) arg;\n  DBG((\"%p %p %u %d\", nc, tpcb, (p != NULL ? p->tot_len : 0), err));\n  if (p == NULL) {\n    if (nc != NULL) {\n      mg_lwip_post_signal(MG_SIG_CLOSE_CONN, nc);\n    } else {\n      /* Tombstoned connection, do nothing. */\n    }\n    return ERR_OK;\n  } else if (nc == NULL) {\n    tcp_abort(tpcb);\n    return ERR_ARG;\n  }\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n  /*\n   * If we get a chain of more than one segment at once, we need to bump\n   * refcount on the subsequent bufs to make them independent.\n   */\n  if (p->next != NULL) {\n    struct pbuf *q = p->next;\n    for (; q != NULL; q = q->next) pbuf_ref(q);\n  }\n  if (cs->rx_chain == NULL) {\n    cs->rx_offset = 0;\n  } else if (pbuf_clen(cs->rx_chain) >= 4) {\n    /* ESP SDK has a limited pool of 5 pbufs. We must not hog them all or RX\n     * will be completely blocked. We already have at least 4 in the chain,\n     * this one is, so we have to make a copy and release this one. */\n    struct pbuf *np = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);\n    if (np != NULL) {\n      pbuf_copy(np, p);\n      pbuf_free(p);\n      p = np;\n    }\n  }\n  mg_lwip_recv_common(nc, p);\n  return ERR_OK;\n}\n\nstatic void mg_lwip_handle_recv_tcp(struct mg_connection *nc) {\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n\n#if MG_ENABLE_SSL\n  if (nc->flags & MG_F_SSL) {\n    if (nc->flags & MG_F_SSL_HANDSHAKE_DONE) {\n      mg_lwip_ssl_recv(nc);\n    } else {\n      mg_lwip_ssl_do_hs(nc);\n    }\n    return;\n  }\n#endif\n\n  mgos_lock();\n  while (cs->rx_chain != NULL) {\n    struct pbuf *seg = cs->rx_chain;\n    size_t len = (seg->len - cs->rx_offset);\n    char *data = (char *) MG_MALLOC(len);\n    if (data == NULL) {\n      mgos_unlock();\n      DBG((\"OOM\"));\n      return;\n    }\n    pbuf_copy_partial(seg, data, len, cs->rx_offset);\n    cs->rx_offset += len;\n    if (cs->rx_offset == cs->rx_chain->len) {\n      cs->rx_chain = pbuf_dechain(cs->rx_chain);\n      pbuf_free(seg);\n      cs->rx_offset = 0;\n    }\n    mgos_unlock();\n    mg_if_recv_tcp_cb(nc, data, len, 1 /* own */);\n    mgos_lock();\n  }\n  mgos_unlock();\n\n  if (nc->send_mbuf.len > 0) {\n    mg_lwip_mgr_schedule_poll(nc->mgr);\n  }\n}\n\nstatic err_t mg_lwip_tcp_sent_cb(void *arg, struct tcp_pcb *tpcb,\n                                 u16_t num_sent) {\n  struct mg_connection *nc = (struct mg_connection *) arg;\n  DBG((\"%p %p %u\", nc, tpcb, num_sent));\n  if (nc == NULL) {\n    tcp_abort(tpcb);\n    return ERR_ABRT;\n  }\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n  cs->num_sent += num_sent;\n\n  mg_lwip_post_signal(MG_SIG_SENT_CB, nc);\n  return ERR_OK;\n}\n\nvoid mg_lwip_if_connect_tcp(struct mg_connection *nc,\n                            const union socket_address *sa) {\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n  struct tcp_pcb *tpcb = TCP_NEW();\n  cs->pcb.tcp = tpcb;\n  ip_addr_t *ip = (ip_addr_t *) &sa->sin.sin_addr.s_addr;\n  u16_t port = ntohs(sa->sin.sin_port);\n  tcp_arg(tpcb, nc);\n  tcp_err(tpcb, mg_lwip_tcp_error_cb);\n  tcp_sent(tpcb, mg_lwip_tcp_sent_cb);\n  tcp_recv(tpcb, mg_lwip_tcp_recv_cb);\n  cs->err = TCP_BIND(tpcb, IP_ADDR_ANY, 0 /* any port */);\n  DBG((\"%p tcp_bind = %d\", nc, cs->err));\n  if (cs->err != ERR_OK) {\n    mg_lwip_post_signal(MG_SIG_CONNECT_RESULT, nc);\n    return;\n  }\n  cs->err = tcp_connect(tpcb, ip, port, mg_lwip_tcp_conn_cb);\n  DBG((\"%p tcp_connect %p = %d\", nc, tpcb, cs->err));\n  if (cs->err != ERR_OK) {\n    mg_lwip_post_signal(MG_SIG_CONNECT_RESULT, nc);\n    return;\n  }\n}\n\n/*\n * Lwip included in the SDKs for nRF5x chips has different type for the\n * callback of `udp_recv()`\n */\n#if CS_PLATFORM == CS_P_NRF51 || CS_PLATFORM == CS_P_NRF52 || \\\n    CS_PLATFORM == CS_P_STM32\nstatic void mg_lwip_udp_recv_cb(void *arg, struct udp_pcb *pcb, struct pbuf *p,\n                                const ip_addr_t *addr, u16_t port)\n#else\nstatic void mg_lwip_udp_recv_cb(void *arg, struct udp_pcb *pcb, struct pbuf *p,\n                                ip_addr_t *addr, u16_t port)\n#endif\n{\n  struct mg_connection *nc = (struct mg_connection *) arg;\n  DBG((\"%p %s:%u %p %u %u\", nc, IPADDR_NTOA(addr), port, p, p->ref, p->len));\n  /* Put address in a separate pbuf and tack it onto the packet. */\n  struct pbuf *sap =\n      pbuf_alloc(PBUF_RAW, sizeof(union socket_address), PBUF_RAM);\n  if (sap == NULL) {\n    pbuf_free(p);\n    return;\n  }\n  union socket_address *sa = (union socket_address *) sap->payload;\n  sa->sin.sin_addr.s_addr = addr->addr;\n  sa->sin.sin_port = htons(port);\n  /* Logic in the recv handler requires that there be exactly one data pbuf. */\n  p = pbuf_coalesce(p, PBUF_RAW);\n  pbuf_chain(sap, p);\n  mg_lwip_recv_common(nc, sap);\n  (void) pcb;\n}\n\nstatic void mg_lwip_recv_common(struct mg_connection *nc, struct pbuf *p) {\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n  mgos_lock();\n  if (cs->rx_chain == NULL) {\n    cs->rx_chain = p;\n  } else {\n    pbuf_chain(cs->rx_chain, p);\n  }\n  if (!cs->recv_pending) {\n    cs->recv_pending = 1;\n    mg_lwip_post_signal(MG_SIG_RECV, nc);\n  }\n  mgos_unlock();\n}\n\nstatic void mg_lwip_handle_recv_udp(struct mg_connection *nc) {\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n  /*\n   * For UDP, RX chain consists of interleaved address and packet bufs:\n   * Address pbuf followed by exactly one data pbuf (recv_cb took care of that).\n   */\n  while (cs->rx_chain != NULL) {\n    struct pbuf *sap = cs->rx_chain;\n    struct pbuf *p = sap->next;\n    cs->rx_chain = pbuf_dechain(p);\n    size_t data_len = p->len;\n    char *data = (char *) MG_MALLOC(data_len);\n    if (data != NULL) {\n      pbuf_copy_partial(p, data, data_len, 0);\n      pbuf_free(p);\n      mg_if_recv_udp_cb(nc, data, data_len,\n                        (union socket_address *) sap->payload, sap->len);\n      pbuf_free(sap);\n    } else {\n      pbuf_free(p);\n      pbuf_free(sap);\n    }\n  }\n}\n\nvoid mg_lwip_if_connect_udp(struct mg_connection *nc) {\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n  struct udp_pcb *upcb = udp_new();\n  cs->err = UDP_BIND(upcb, IP_ADDR_ANY, 0 /* any port */);\n  DBG((\"%p udp_bind %p = %d\", nc, upcb, cs->err));\n  if (cs->err == ERR_OK) {\n    udp_recv(upcb, mg_lwip_udp_recv_cb, nc);\n    cs->pcb.udp = upcb;\n  } else {\n    udp_remove(upcb);\n  }\n  mg_lwip_post_signal(MG_SIG_CONNECT_RESULT, nc);\n}\n\nvoid mg_lwip_accept_conn(struct mg_connection *nc, struct tcp_pcb *tpcb) {\n  union socket_address sa;\n  SET_ADDR(&sa, &tpcb->remote_ip);\n  sa.sin.sin_port = htons(tpcb->remote_port);\n  mg_if_accept_tcp_cb(nc, &sa, sizeof(sa.sin));\n}\n\nvoid mg_lwip_handle_accept(struct mg_connection *nc) {\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n#if MG_ENABLE_SSL\n  if (cs->lc->flags & MG_F_SSL) {\n    if (mg_ssl_if_conn_accept(nc, cs->lc) != MG_SSL_OK) {\n      LOG(LL_ERROR, (\"SSL error\"));\n      tcp_close(cs->pcb.tcp);\n    }\n  } else\n#endif\n  {\n    mg_lwip_accept_conn(nc, cs->pcb.tcp);\n  }\n}\n\nstatic err_t mg_lwip_accept_cb(void *arg, struct tcp_pcb *newtpcb, err_t err) {\n  struct mg_connection *lc = (struct mg_connection *) arg;\n  DBG((\"%p conn %p from %s:%u\", lc, newtpcb,\n       IPADDR_NTOA(ipX_2_ip(&newtpcb->remote_ip)), newtpcb->remote_port));\n  struct mg_connection *nc = mg_if_accept_new_conn(lc);\n  if (nc == NULL) {\n    tcp_abort(newtpcb);\n    return ERR_ABRT;\n  }\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n  cs->lc = lc;\n  cs->pcb.tcp = newtpcb;\n  /* We need to set up callbacks before returning because data may start\n   * arriving immediately. */\n  tcp_arg(newtpcb, nc);\n  tcp_err(newtpcb, mg_lwip_tcp_error_cb);\n  tcp_sent(newtpcb, mg_lwip_tcp_sent_cb);\n  tcp_recv(newtpcb, mg_lwip_tcp_recv_cb);\n#if LWIP_TCP_KEEPALIVE\n  mg_lwip_set_keepalive_params(nc, 60, 10, 6);\n#endif\n  mg_lwip_post_signal(MG_SIG_ACCEPT, nc);\n  (void) err;\n  return ERR_OK;\n}\n\nint mg_lwip_if_listen_tcp(struct mg_connection *nc, union socket_address *sa) {\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n  struct tcp_pcb *tpcb = TCP_NEW();\n  ip_addr_t *ip = (ip_addr_t *) &sa->sin.sin_addr.s_addr;\n  u16_t port = ntohs(sa->sin.sin_port);\n  cs->err = TCP_BIND(tpcb, ip, port);\n  DBG((\"%p tcp_bind(%s:%u) = %d\", nc, IPADDR_NTOA(ip), port, cs->err));\n  if (cs->err != ERR_OK) {\n    tcp_close(tpcb);\n    return -1;\n  }\n  tcp_arg(tpcb, nc);\n  tpcb = tcp_listen(tpcb);\n  cs->pcb.tcp = tpcb;\n  tcp_accept(tpcb, mg_lwip_accept_cb);\n  return 0;\n}\n\nint mg_lwip_if_listen_udp(struct mg_connection *nc, union socket_address *sa) {\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n  struct udp_pcb *upcb = udp_new();\n  ip_addr_t *ip = (ip_addr_t *) &sa->sin.sin_addr.s_addr;\n  u16_t port = ntohs(sa->sin.sin_port);\n  cs->err = UDP_BIND(upcb, ip, port);\n  DBG((\"%p udb_bind(%s:%u) = %d\", nc, IPADDR_NTOA(ip), port, cs->err));\n  if (cs->err != ERR_OK) {\n    udp_remove(upcb);\n    return -1;\n  }\n  udp_recv(upcb, mg_lwip_udp_recv_cb, nc);\n  cs->pcb.udp = upcb;\n  return 0;\n}\n\nint mg_lwip_tcp_write(struct mg_connection *nc, const void *data,\n                      uint16_t len) {\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n  struct tcp_pcb *tpcb = cs->pcb.tcp;\n  if (tpcb == NULL) return -1;\n  len = MIN(tpcb->mss, MIN(len, tpcb->snd_buf));\n  if (len == 0) {\n    DBG((\"%p no buf avail %u %u %u %p %p\", tpcb, tpcb->acked, tpcb->snd_buf,\n         tpcb->snd_queuelen, tpcb->unsent, tpcb->unacked));\n    tcp_output(tpcb);\n    return 0;\n  }\n/*\n * On ESP8266 we only allow one TCP segment in flight at any given time.\n * This may increase latency and reduce efficiency of tcp windowing,\n * but memory is scarce and precious on that platform so we do this to\n * reduce footprint.\n */\n#if CS_PLATFORM == CS_P_ESP8266\n  if (tpcb->unacked != NULL) {\n    return 0;\n  }\n  if (tpcb->unsent != NULL) {\n    len = MIN(len, (TCP_MSS - tpcb->unsent->len));\n  }\n#endif\n  err_t err = tcp_write(tpcb, data, len, TCP_WRITE_FLAG_COPY);\n  DBG((\"%p tcp_write %u = %d\", tpcb, len, err));\n  if (err != ERR_OK) {\n    /*\n     * We ignore ERR_MEM because memory will be freed up when the data is sent\n     * and we'll retry.\n     */\n    return (err == ERR_MEM ? 0 : -1);\n  }\n  return len;\n}\n\nstatic void mg_lwip_send_more(struct mg_connection *nc) {\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n  if (nc->sock == INVALID_SOCKET || cs->pcb.tcp == NULL) {\n    DBG((\"%p invalid socket\", nc));\n    return;\n  }\n  int num_written = mg_lwip_tcp_write(nc, nc->send_mbuf.buf, nc->send_mbuf.len);\n  DBG((\"%p mg_lwip_tcp_write %u = %d\", nc, nc->send_mbuf.len, num_written));\n  if (num_written == 0) return;\n  if (num_written < 0) {\n    mg_lwip_post_signal(MG_SIG_CLOSE_CONN, nc);\n  }\n  mbuf_remove(&nc->send_mbuf, num_written);\n  mbuf_trim(&nc->send_mbuf);\n}\n\nvoid mg_lwip_if_tcp_send(struct mg_connection *nc, const void *buf,\n                         size_t len) {\n  mbuf_append(&nc->send_mbuf, buf, len);\n  mg_lwip_mgr_schedule_poll(nc->mgr);\n}\n\nvoid mg_lwip_if_udp_send(struct mg_connection *nc, const void *buf,\n                         size_t len) {\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n  if (nc->sock == INVALID_SOCKET || cs->pcb.udp == NULL) {\n    /*\n     * In case of UDP, this usually means, what\n     * async DNS resolve is still in progress and connection\n     * is not ready yet\n     */\n    DBG((\"%p socket is not connected\", nc));\n    return;\n  }\n  struct udp_pcb *upcb = cs->pcb.udp;\n  struct pbuf *p = pbuf_alloc(PBUF_TRANSPORT, len, PBUF_RAM);\n  ip_addr_t *ip = (ip_addr_t *) &nc->sa.sin.sin_addr.s_addr;\n  u16_t port = ntohs(nc->sa.sin.sin_port);\n  if (p == NULL) {\n    DBG((\"OOM\"));\n    return;\n  }\n  memcpy(p->payload, buf, len);\n  cs->err = udp_sendto(upcb, p, (ip_addr_t *) ip, port);\n  DBG((\"%p udp_sendto = %d\", nc, cs->err));\n  pbuf_free(p);\n  if (cs->err != ERR_OK) {\n    mg_lwip_post_signal(MG_SIG_CLOSE_CONN, nc);\n  } else {\n    cs->num_sent += len;\n    mg_lwip_post_signal(MG_SIG_SENT_CB, nc);\n  }\n}\n\nvoid mg_lwip_if_recved(struct mg_connection *nc, size_t len) {\n  if (nc->flags & MG_F_UDP) return;\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n  if (nc->sock == INVALID_SOCKET || cs->pcb.tcp == NULL) {\n    DBG((\"%p invalid socket\", nc));\n    return;\n  }\n  DBG((\"%p %p %u\", nc, cs->pcb.tcp, len));\n/* Currently SSL acknowledges data immediately.\n * TODO(rojer): Find a way to propagate mg_lwip_if_recved. */\n#if MG_ENABLE_SSL\n  if (!(nc->flags & MG_F_SSL)) {\n    tcp_recved(cs->pcb.tcp, len);\n  }\n#else\n  tcp_recved(cs->pcb.tcp, len);\n#endif\n  mbuf_trim(&nc->recv_mbuf);\n}\n\nint mg_lwip_if_create_conn(struct mg_connection *nc) {\n  struct mg_lwip_conn_state *cs =\n      (struct mg_lwip_conn_state *) MG_CALLOC(1, sizeof(*cs));\n  if (cs == NULL) return 0;\n  cs->nc = nc;\n  nc->sock = (intptr_t) cs;\n  return 1;\n}\n\nvoid mg_lwip_if_destroy_conn(struct mg_connection *nc) {\n  if (nc->sock == INVALID_SOCKET) return;\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n  if (!(nc->flags & MG_F_UDP)) {\n    struct tcp_pcb *tpcb = cs->pcb.tcp;\n    if (tpcb != NULL) {\n      tcp_arg(tpcb, NULL);\n      DBG((\"%p tcp_close %p\", nc, tpcb));\n      tcp_arg(tpcb, NULL);\n      tcp_close(tpcb);\n    }\n    while (cs->rx_chain != NULL) {\n      struct pbuf *seg = cs->rx_chain;\n      cs->rx_chain = pbuf_dechain(cs->rx_chain);\n      pbuf_free(seg);\n    }\n    memset(cs, 0, sizeof(*cs));\n    MG_FREE(cs);\n  } else if (nc->listener == NULL) {\n    /* Only close outgoing UDP pcb or listeners. */\n    struct udp_pcb *upcb = cs->pcb.udp;\n    if (upcb != NULL) {\n      DBG((\"%p udp_remove %p\", nc, upcb));\n      udp_remove(upcb);\n    }\n    memset(cs, 0, sizeof(*cs));\n    MG_FREE(cs);\n  }\n  nc->sock = INVALID_SOCKET;\n}\n\nvoid mg_lwip_if_get_conn_addr(struct mg_connection *nc, int remote,\n                              union socket_address *sa) {\n  memset(sa, 0, sizeof(*sa));\n  if (nc->sock == INVALID_SOCKET) return;\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n  if (nc->flags & MG_F_UDP) {\n    struct udp_pcb *upcb = cs->pcb.udp;\n    if (remote) {\n      memcpy(sa, &nc->sa, sizeof(*sa));\n    } else {\n      sa->sin.sin_port = htons(upcb->local_port);\n      SET_ADDR(sa, &upcb->local_ip);\n    }\n  } else {\n    struct tcp_pcb *tpcb = cs->pcb.tcp;\n    if (remote) {\n      sa->sin.sin_port = htons(tpcb->remote_port);\n      SET_ADDR(sa, &tpcb->remote_ip);\n    } else {\n      sa->sin.sin_port = htons(tpcb->local_port);\n      SET_ADDR(sa, &tpcb->local_ip);\n    }\n  }\n}\n\nvoid mg_lwip_if_sock_set(struct mg_connection *nc, sock_t sock) {\n  nc->sock = sock;\n}\n\n/* clang-format off */\n#define MG_LWIP_IFACE_VTABLE                                          \\\n  {                                                                   \\\n    mg_lwip_if_init,                                                  \\\n    mg_lwip_if_free,                                                  \\\n    mg_lwip_if_add_conn,                                              \\\n    mg_lwip_if_remove_conn,                                           \\\n    mg_lwip_if_poll,                                                  \\\n    mg_lwip_if_listen_tcp,                                            \\\n    mg_lwip_if_listen_udp,                                            \\\n    mg_lwip_if_connect_tcp,                                           \\\n    mg_lwip_if_connect_udp,                                           \\\n    mg_lwip_if_tcp_send,                                              \\\n    mg_lwip_if_udp_send,                                              \\\n    mg_lwip_if_recved,                                                \\\n    mg_lwip_if_create_conn,                                           \\\n    mg_lwip_if_destroy_conn,                                          \\\n    mg_lwip_if_sock_set,                                              \\\n    mg_lwip_if_get_conn_addr,                                         \\\n  }\n/* clang-format on */\n\nconst struct mg_iface_vtable mg_lwip_iface_vtable = MG_LWIP_IFACE_VTABLE;\n#if MG_NET_IF == MG_NET_IF_LWIP_LOW_LEVEL\nconst struct mg_iface_vtable mg_default_iface_vtable = MG_LWIP_IFACE_VTABLE;\n#endif\n\n#endif /* MG_ENABLE_NET_IF_LWIP_LOW_LEVEL */\n#ifdef MG_MODULE_LINES\n#line 1 \"common/platforms/lwip/mg_lwip_ev_mgr.c\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#if MG_NET_IF == MG_NET_IF_LWIP_LOW_LEVEL\n\n#ifndef MG_SIG_QUEUE_LEN\n#define MG_SIG_QUEUE_LEN 32\n#endif\n\nstruct mg_ev_mgr_lwip_signal {\n  int sig;\n  struct mg_connection *nc;\n};\n\nstruct mg_ev_mgr_lwip_data {\n  struct mg_ev_mgr_lwip_signal sig_queue[MG_SIG_QUEUE_LEN];\n  int sig_queue_len;\n  int start_index;\n};\n\nvoid mg_lwip_post_signal(enum mg_sig_type sig, struct mg_connection *nc) {\n  struct mg_ev_mgr_lwip_data *md =\n      (struct mg_ev_mgr_lwip_data *) nc->iface->data;\n  mgos_lock();\n  if (md->sig_queue_len >= MG_SIG_QUEUE_LEN) {\n    mgos_unlock();\n    return;\n  }\n  int end_index = (md->start_index + md->sig_queue_len) % MG_SIG_QUEUE_LEN;\n  md->sig_queue[end_index].sig = sig;\n  md->sig_queue[end_index].nc = nc;\n  md->sig_queue_len++;\n  mg_lwip_mgr_schedule_poll(nc->mgr);\n  mgos_unlock();\n}\n\nvoid mg_ev_mgr_lwip_process_signals(struct mg_mgr *mgr) {\n  struct mg_ev_mgr_lwip_data *md =\n      (struct mg_ev_mgr_lwip_data *) mgr->ifaces[MG_MAIN_IFACE]->data;\n  while (md->sig_queue_len > 0) {\n    mgos_lock();\n    int sig = md->sig_queue[md->start_index].sig;\n    struct mg_connection *nc = md->sig_queue[md->start_index].nc;\n    struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n    md->start_index = (md->start_index + 1) % MG_SIG_QUEUE_LEN;\n    md->sig_queue_len--;\n    mgos_unlock();\n    if (nc->iface == NULL || nc->mgr == NULL) continue;\n    switch (sig) {\n      case MG_SIG_CONNECT_RESULT: {\n#if MG_ENABLE_SSL\n        if (cs->err == 0 && (nc->flags & MG_F_SSL) &&\n            !(nc->flags & MG_F_SSL_HANDSHAKE_DONE)) {\n          mg_lwip_ssl_do_hs(nc);\n        } else\n#endif\n        {\n          mg_if_connect_cb(nc, cs->err);\n        }\n        break;\n      }\n      case MG_SIG_CLOSE_CONN: {\n        nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n        mg_close_conn(nc);\n        break;\n      }\n      case MG_SIG_RECV: {\n        cs->recv_pending = 0;\n        if (nc->flags & MG_F_UDP) {\n          mg_lwip_handle_recv_udp(nc);\n        } else {\n          mg_lwip_handle_recv_tcp(nc);\n        }\n        break;\n      }\n      case MG_SIG_SENT_CB: {\n        if (cs->num_sent > 0) mg_if_sent_cb(nc, cs->num_sent);\n        cs->num_sent = 0;\n\n        if (nc->send_mbuf.len == 0 && (nc->flags & MG_F_SEND_AND_CLOSE) &&\n            !(nc->flags & MG_F_WANT_WRITE)) {\n          mg_close_conn(nc);\n        }\n\n        break;\n      }\n      case MG_SIG_TOMBSTONE: {\n        break;\n      }\n      case MG_SIG_ACCEPT: {\n        mg_lwip_handle_accept(nc);\n        break;\n      }\n    }\n  }\n}\n\nvoid mg_lwip_if_init(struct mg_iface *iface) {\n  LOG(LL_INFO, (\"%p Mongoose init\"));\n  iface->data = MG_CALLOC(1, sizeof(struct mg_ev_mgr_lwip_data));\n}\n\nvoid mg_lwip_if_free(struct mg_iface *iface) {\n  MG_FREE(iface->data);\n  iface->data = NULL;\n}\n\nvoid mg_lwip_if_add_conn(struct mg_connection *nc) {\n  (void) nc;\n}\n\nvoid mg_lwip_if_remove_conn(struct mg_connection *nc) {\n  struct mg_ev_mgr_lwip_data *md =\n      (struct mg_ev_mgr_lwip_data *) nc->iface->data;\n  /* Walk the queue and null-out further signals for this conn. */\n  for (int i = 0; i < MG_SIG_QUEUE_LEN; i++) {\n    if (md->sig_queue[i].nc == nc) {\n      md->sig_queue[i].sig = MG_SIG_TOMBSTONE;\n    }\n  }\n}\n\ntime_t mg_lwip_if_poll(struct mg_iface *iface, int timeout_ms) {\n  struct mg_mgr *mgr = iface->mgr;\n  int n = 0;\n  double now = mg_time();\n  struct mg_connection *nc, *tmp;\n  double min_timer = 0;\n  int num_timers = 0;\n#if 0\n  DBG((\"begin poll @%u\", (unsigned int) (now * 1000)));\n#endif\n  mg_ev_mgr_lwip_process_signals(mgr);\n  for (nc = mgr->active_connections; nc != NULL; nc = tmp) {\n    struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n    tmp = nc->next;\n    n++;\n    if ((nc->flags & MG_F_CLOSE_IMMEDIATELY) ||\n        ((nc->flags & MG_F_SEND_AND_CLOSE) && (nc->flags & MG_F_UDP) &&\n         (nc->send_mbuf.len == 0))) {\n      mg_close_conn(nc);\n      continue;\n    }\n    mg_if_poll(nc, now);\n    mg_if_timer(nc, now);\n#if MG_ENABLE_SSL\n    if ((nc->flags & MG_F_SSL) && cs != NULL && cs->pcb.tcp != NULL &&\n        cs->pcb.tcp->state == ESTABLISHED) {\n      if (((nc->flags & MG_F_WANT_WRITE) ||\n           ((nc->send_mbuf.len > 0) &&\n            (nc->flags & MG_F_SSL_HANDSHAKE_DONE))) &&\n          cs->pcb.tcp->snd_buf > 0) {\n        /* Can write more. */\n        if (nc->flags & MG_F_SSL_HANDSHAKE_DONE) {\n          if (!(nc->flags & MG_F_CONNECTING)) mg_lwip_ssl_send(nc);\n        } else {\n          mg_lwip_ssl_do_hs(nc);\n        }\n      }\n      if (cs->rx_chain != NULL || (nc->flags & MG_F_WANT_READ)) {\n        if (nc->flags & MG_F_SSL_HANDSHAKE_DONE) {\n          if (!(nc->flags & MG_F_CONNECTING)) mg_lwip_ssl_recv(nc);\n        } else {\n          mg_lwip_ssl_do_hs(nc);\n        }\n      }\n    } else\n#endif /* MG_ENABLE_SSL */\n    {\n      if (!(nc->flags & (MG_F_CONNECTING | MG_F_UDP))) {\n        if (nc->send_mbuf.len > 0) mg_lwip_send_more(nc);\n      }\n    }\n    if (nc->sock != INVALID_SOCKET &&\n        !(nc->flags & (MG_F_UDP | MG_F_LISTENING)) && cs->pcb.tcp != NULL &&\n        cs->pcb.tcp->unsent != NULL) {\n      tcp_output(cs->pcb.tcp);\n    }\n    if (nc->ev_timer_time > 0) {\n      if (num_timers == 0 || nc->ev_timer_time < min_timer) {\n        min_timer = nc->ev_timer_time;\n      }\n      num_timers++;\n    }\n  }\n#if 0\n  DBG((\"end poll @%u, %d conns, %d timers (min %u), next in %d ms\",\n       (unsigned int) (now * 1000), n, num_timers,\n       (unsigned int) (min_timer * 1000), timeout_ms));\n#endif\n  (void) timeout_ms;\n  return now;\n}\n\nuint32_t mg_lwip_get_poll_delay_ms(struct mg_mgr *mgr) {\n  struct mg_connection *nc;\n  double now = mg_time();\n  double min_timer = 0;\n  int num_timers = 0;\n  mg_ev_mgr_lwip_process_signals(mgr);\n  for (nc = mg_next(mgr, NULL); nc != NULL; nc = mg_next(mgr, nc)) {\n    struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n    if (nc->ev_timer_time > 0) {\n      if (num_timers == 0 || nc->ev_timer_time < min_timer) {\n        min_timer = nc->ev_timer_time;\n      }\n      num_timers++;\n    }\n    if (nc->send_mbuf.len > 0) {\n      int can_send = 0;\n      /* We have stuff to send, but can we? */\n      if (nc->flags & MG_F_UDP) {\n        /* UDP is always ready for sending. */\n        can_send = (cs->pcb.udp != NULL);\n      } else {\n        can_send = (cs->pcb.tcp != NULL && cs->pcb.tcp->snd_buf > 0);\n      }\n      /* We want and can send, request a poll immediately. */\n      if (can_send) return 0;\n    }\n  }\n  uint32_t timeout_ms = ~0;\n  if (num_timers > 0) {\n    double timer_timeout_ms = (min_timer - now) * 1000 + 1 /* rounding */;\n    if (timer_timeout_ms < timeout_ms) {\n      timeout_ms = timer_timeout_ms;\n    }\n  }\n  return timeout_ms;\n}\n\n#endif /* MG_NET_IF == MG_NET_IF_LWIP_LOW_LEVEL */\n#ifdef MG_MODULE_LINES\n#line 1 \"common/platforms/lwip/mg_lwip_ssl_if.c\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#if MG_ENABLE_SSL && MG_NET_IF == MG_NET_IF_LWIP_LOW_LEVEL\n\n/* Amalgamated: #include \"common/mg_mem.h\" */\n/* Amalgamated: #include \"common/cs_dbg.h\" */\n\n#include <lwip/pbuf.h>\n#include <lwip/tcp.h>\n\n#ifndef MG_LWIP_SSL_IO_SIZE\n#define MG_LWIP_SSL_IO_SIZE 1024\n#endif\n\n/*\n * Stop processing incoming SSL traffic when recv_mbuf.size is this big.\n * It'a a uick solution for SSL recv pushback.\n */\n#ifndef MG_LWIP_SSL_RECV_MBUF_LIMIT\n#define MG_LWIP_SSL_RECV_MBUF_LIMIT 3072\n#endif\n\n#ifndef MIN\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n#endif\n\nvoid mg_lwip_ssl_do_hs(struct mg_connection *nc) {\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n  int server_side = (nc->listener != NULL);\n  enum mg_ssl_if_result res;\n  if (nc->flags & MG_F_CLOSE_IMMEDIATELY) return;\n  res = mg_ssl_if_handshake(nc);\n  DBG((\"%p %d %d %d\", nc, nc->flags, server_side, res));\n  if (res != MG_SSL_OK) {\n    if (res == MG_SSL_WANT_WRITE) {\n      nc->flags |= MG_F_WANT_WRITE;\n      cs->err = 0;\n    } else if (res == MG_SSL_WANT_READ) {\n      /*\n       * Nothing to do in particular, we are callback-driven.\n       * What we definitely do not need anymore is SSL reading (nothing left).\n       */\n      nc->flags &= ~MG_F_WANT_READ;\n      cs->err = 0;\n    } else {\n      cs->err = res;\n      if (server_side) {\n        mg_lwip_post_signal(MG_SIG_CLOSE_CONN, nc);\n      } else {\n        mg_lwip_post_signal(MG_SIG_CONNECT_RESULT, nc);\n      }\n    }\n  } else {\n    cs->err = 0;\n    nc->flags &= ~MG_F_WANT_WRITE;\n    /*\n     * Handshake is done. Schedule a read immediately to consume app data\n     * which may already be waiting.\n     */\n    nc->flags |= (MG_F_SSL_HANDSHAKE_DONE | MG_F_WANT_READ);\n    if (server_side) {\n      mg_lwip_accept_conn(nc, cs->pcb.tcp);\n    } else {\n      mg_lwip_post_signal(MG_SIG_CONNECT_RESULT, nc);\n    }\n  }\n}\n\nvoid mg_lwip_ssl_send(struct mg_connection *nc) {\n  if (nc->sock == INVALID_SOCKET) {\n    DBG((\"%p invalid socket\", nc));\n    return;\n  }\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n  /* It's ok if the buffer is empty. Return value of 0 may also be valid. */\n  int len = cs->last_ssl_write_size;\n  if (len == 0) {\n    len = MIN(MG_LWIP_SSL_IO_SIZE, nc->send_mbuf.len);\n  }\n  int ret = mg_ssl_if_write(nc, nc->send_mbuf.buf, len);\n  DBG((\"%p SSL_write %u = %d, %d\", nc, len, ret));\n  if (ret > 0) {\n    mbuf_remove(&nc->send_mbuf, ret);\n    mbuf_trim(&nc->send_mbuf);\n    cs->last_ssl_write_size = 0;\n  } else if (ret < 0) {\n    /* This is tricky. We must remember the exact data we were sending to retry\n     * exactly the same send next time. */\n    cs->last_ssl_write_size = len;\n  }\n  if (ret == len) {\n    nc->flags &= ~MG_F_WANT_WRITE;\n  } else if (ret == MG_SSL_WANT_WRITE) {\n    nc->flags |= MG_F_WANT_WRITE;\n  } else {\n    mg_lwip_post_signal(MG_SIG_CLOSE_CONN, nc);\n  }\n}\n\nvoid mg_lwip_ssl_recv(struct mg_connection *nc) {\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n  /* Don't deliver data before connect callback */\n  if (nc->flags & MG_F_CONNECTING) return;\n  while (nc->recv_mbuf.len < MG_LWIP_SSL_RECV_MBUF_LIMIT) {\n    char *buf = (char *) MG_MALLOC(MG_LWIP_SSL_IO_SIZE);\n    if (buf == NULL) return;\n    int ret = mg_ssl_if_read(nc, buf, MG_LWIP_SSL_IO_SIZE);\n    DBG((\"%p %p SSL_read %u = %d\", nc, cs->rx_chain, MG_LWIP_SSL_IO_SIZE, ret));\n    if (ret <= 0) {\n      MG_FREE(buf);\n      if (ret == MG_SSL_WANT_WRITE) {\n        nc->flags |= MG_F_WANT_WRITE;\n        return;\n      } else if (ret == MG_SSL_WANT_READ) {\n        /*\n         * Nothing to do in particular, we are callback-driven.\n         * What we definitely do not need anymore is SSL reading (nothing left).\n         */\n        nc->flags &= ~MG_F_WANT_READ;\n        cs->err = 0;\n        return;\n      } else {\n        mg_lwip_post_signal(MG_SIG_CLOSE_CONN, nc);\n        return;\n      }\n    } else {\n      mg_if_recv_tcp_cb(nc, buf, ret, 1 /* own */);\n    }\n  }\n}\n\n#ifdef KR_VERSION\n\nssize_t kr_send(int fd, const void *buf, size_t len) {\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) fd;\n  int ret = mg_lwip_tcp_write(cs->nc, buf, len);\n  DBG((\"%p mg_lwip_tcp_write %u = %d\", cs->nc, len, ret));\n  if (ret == 0) ret = KR_IO_WOULDBLOCK;\n  return ret;\n}\n\nssize_t kr_recv(int fd, void *buf, size_t len) {\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) fd;\n  struct pbuf *seg = cs->rx_chain;\n  if (seg == NULL) {\n    DBG((\"%u - nothing to read\", len));\n    return KR_IO_WOULDBLOCK;\n  }\n  size_t seg_len = (seg->len - cs->rx_offset);\n  DBG((\"%u %u %u %u\", len, cs->rx_chain->len, seg_len, cs->rx_chain->tot_len));\n  len = MIN(len, seg_len);\n  pbuf_copy_partial(seg, buf, len, cs->rx_offset);\n  cs->rx_offset += len;\n  tcp_recved(cs->pcb.tcp, len);\n  if (cs->rx_offset == cs->rx_chain->len) {\n    cs->rx_chain = pbuf_dechain(cs->rx_chain);\n    pbuf_free(seg);\n    cs->rx_offset = 0;\n  }\n  return len;\n}\n\n#elif MG_SSL_IF == MG_SSL_IF_MBEDTLS\n\nint ssl_socket_send(void *ctx, const unsigned char *buf, size_t len) {\n  struct mg_connection *nc = (struct mg_connection *) ctx;\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n  int ret = mg_lwip_tcp_write(cs->nc, buf, len);\n  LOG(LL_DEBUG, (\"%p %d -> %d\", nc, len, ret));\n  if (ret == 0) ret = MBEDTLS_ERR_SSL_WANT_WRITE;\n  return ret;\n}\n\nint ssl_socket_recv(void *ctx, unsigned char *buf, size_t len) {\n  struct mg_connection *nc = (struct mg_connection *) ctx;\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n  struct pbuf *seg = cs->rx_chain;\n  if (seg == NULL) {\n    DBG((\"%u - nothing to read\", len));\n    return MBEDTLS_ERR_SSL_WANT_READ;\n  }\n  size_t seg_len = (seg->len - cs->rx_offset);\n  DBG((\"%u %u %u %u\", len, cs->rx_chain->len, seg_len, cs->rx_chain->tot_len));\n  len = MIN(len, seg_len);\n  pbuf_copy_partial(seg, buf, len, cs->rx_offset);\n  cs->rx_offset += len;\n  /* TCP PCB may be NULL if connection has already been closed\n   * but we still have data to deliver to SSL. */\n  if (cs->pcb.tcp != NULL) tcp_recved(cs->pcb.tcp, len);\n  if (cs->rx_offset == cs->rx_chain->len) {\n    cs->rx_chain = pbuf_dechain(cs->rx_chain);\n    pbuf_free(seg);\n    cs->rx_offset = 0;\n  }\n  LOG(LL_DEBUG, (\"%p <- %d\", nc, (int) len));\n  return len;\n}\n\n#endif\n\n#endif /* MG_ENABLE_SSL && MG_NET_IF == MG_NET_IF_LWIP_LOW_LEVEL */\n#ifdef MG_MODULE_LINES\n#line 1 \"common/platforms/wince/wince_libc.c\"\n#endif\n/*\n * Copyright (c) 2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#ifdef WINCE\n\nconst char *strerror(int err) {\n  /*\n   * TODO(alashkin): there is no strerror on WinCE;\n   * look for similar wce_xxxx function\n   */\n  static char buf[10];\n  snprintf(buf, sizeof(buf), \"%d\", err);\n  return buf;\n}\n\nint open(const char *filename, int oflag, int pmode) {\n  /*\n   * TODO(alashkin): mg_open function is not used in mongoose\n   * but exists in documentation as utility function\n   * Shall we delete it at all or implement for WinCE as well?\n   */\n  DebugBreak();\n  return 0; /* for compiler */\n}\n\nint _wstati64(const wchar_t *path, cs_stat_t *st) {\n  DWORD fa = GetFileAttributesW(path);\n  if (fa == INVALID_FILE_ATTRIBUTES) {\n    return -1;\n  }\n  memset(st, 0, sizeof(*st));\n  if ((fa & FILE_ATTRIBUTE_DIRECTORY) == 0) {\n    HANDLE h;\n    FILETIME ftime;\n    st->st_mode |= _S_IFREG;\n    h = CreateFileW(path, GENERIC_READ, 0, NULL, OPEN_EXISTING,\n                    FILE_ATTRIBUTE_NORMAL, NULL);\n    if (h == INVALID_HANDLE_VALUE) {\n      return -1;\n    }\n    st->st_size = GetFileSize(h, NULL);\n    GetFileTime(h, NULL, NULL, &ftime);\n    st->st_mtime = (uint32_t)((((uint64_t) ftime.dwLowDateTime +\n                                ((uint64_t) ftime.dwHighDateTime << 32)) /\n                               10000000.0) -\n                              11644473600);\n    CloseHandle(h);\n  } else {\n    st->st_mode |= _S_IFDIR;\n  }\n  return 0;\n}\n\n/* Windows CE doesn't have neither gmtime nor strftime */\nstatic void mg_gmt_time_string(char *buf, size_t buf_len, time_t *t) {\n  FILETIME ft;\n  SYSTEMTIME systime;\n  if (t != NULL) {\n    uint64_t filetime = (*t + 11644473600) * 10000000;\n    ft.dwLowDateTime = filetime & 0xFFFFFFFF;\n    ft.dwHighDateTime = (filetime & 0xFFFFFFFF00000000) >> 32;\n    FileTimeToSystemTime(&ft, &systime);\n  } else {\n    GetSystemTime(&systime);\n  }\n  /* There is no PRIu16 in WinCE SDK */\n  snprintf(buf, buf_len, \"%d.%d.%d %d:%d:%d GMT\", (int) systime.wYear,\n           (int) systime.wMonth, (int) systime.wDay, (int) systime.wHour,\n           (int) systime.wMinute, (int) systime.wSecond);\n}\n\n#endif\n#ifdef MG_MODULE_LINES\n#line 1 \"common/platforms/pic32/pic32_net_if.h\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#ifndef CS_COMMON_PLATFORMS_PIC32_NET_IF_H_\n#define CS_COMMON_PLATFORMS_PIC32_NET_IF_H_\n\n/* Amalgamated: #include \"mongoose/src/net_if.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif /* __cplusplus */\n\n#ifndef MG_ENABLE_NET_IF_PIC32\n#define MG_ENABLE_NET_IF_PIC32 MG_NET_IF == MG_NET_IF_PIC32\n#endif\n\nextern const struct mg_iface_vtable mg_pic32_iface_vtable;\n\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n\n#endif /* CS_COMMON_PLATFORMS_PIC32_NET_IF_H_ */\n#ifdef MG_MODULE_LINES\n#line 1 \"common/platforms/pic32/pic32_net_if.c\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#if MG_ENABLE_NET_IF_PIC32\n\nint mg_pic32_if_create_conn(struct mg_connection *nc) {\n  (void) nc;\n  return 1;\n}\n\nvoid mg_pic32_if_recved(struct mg_connection *nc, size_t len) {\n  (void) nc;\n  (void) len;\n}\n\nvoid mg_pic32_if_add_conn(struct mg_connection *nc) {\n  (void) nc;\n}\n\nvoid mg_pic32_if_init(struct mg_iface *iface) {\n  (void) iface;\n  (void) mg_get_errno(); /* Shutup compiler */\n}\n\nvoid mg_pic32_if_free(struct mg_iface *iface) {\n  (void) iface;\n}\n\nvoid mg_pic32_if_remove_conn(struct mg_connection *nc) {\n  (void) nc;\n}\n\nvoid mg_pic32_if_destroy_conn(struct mg_connection *nc) {\n  if (nc->sock == INVALID_SOCKET) return;\n  /* For UDP, only close outgoing sockets or listeners. */\n  if (!(nc->flags & MG_F_UDP)) {\n    /* Close TCP */\n    TCPIP_TCP_Close((TCP_SOCKET) nc->sock);\n  } else if (nc->listener == NULL) {\n    /* Only close outgoing UDP or listeners. */\n    TCPIP_UDP_Close((UDP_SOCKET) nc->sock);\n  }\n\n  nc->sock = INVALID_SOCKET;\n}\n\nint mg_pic32_if_listen_udp(struct mg_connection *nc, union socket_address *sa) {\n  nc->sock = TCPIP_UDP_ServerOpen(\n      sa->sin.sin_family == AF_INET ? IP_ADDRESS_TYPE_IPV4\n                                    : IP_ADDRESS_TYPE_IPV6,\n      ntohs(sa->sin.sin_port),\n      sa->sin.sin_addr.s_addr == 0 ? 0 : (IP_MULTI_ADDRESS *) &sa->sin);\n  if (nc->sock == INVALID_SOCKET) {\n    return -1;\n  }\n  return 0;\n}\n\nvoid mg_pic32_if_udp_send(struct mg_connection *nc, const void *buf,\n                          size_t len) {\n  mbuf_append(&nc->send_mbuf, buf, len);\n}\n\nvoid mg_pic32_if_tcp_send(struct mg_connection *nc, const void *buf,\n                          size_t len) {\n  mbuf_append(&nc->send_mbuf, buf, len);\n}\n\nint mg_pic32_if_listen_tcp(struct mg_connection *nc, union socket_address *sa) {\n  nc->sock = TCPIP_TCP_ServerOpen(\n      sa->sin.sin_family == AF_INET ? IP_ADDRESS_TYPE_IPV4\n                                    : IP_ADDRESS_TYPE_IPV6,\n      ntohs(sa->sin.sin_port),\n      sa->sin.sin_addr.s_addr == 0 ? 0 : (IP_MULTI_ADDRESS *) &sa->sin);\n  memcpy(&nc->sa, sa, sizeof(*sa));\n  if (nc->sock == INVALID_SOCKET) {\n    return -1;\n  }\n  return 0;\n}\n\nstatic int mg_accept_conn(struct mg_connection *lc) {\n  struct mg_connection *nc;\n  TCP_SOCKET_INFO si;\n  union socket_address sa;\n\n  nc = mg_if_accept_new_conn(lc);\n\n  if (nc == NULL) {\n    return 0;\n  }\n\n  nc->sock = lc->sock;\n  nc->flags &= ~MG_F_LISTENING;\n\n  if (!TCPIP_TCP_SocketInfoGet((TCP_SOCKET) nc->sock, &si)) {\n    return 0;\n  }\n\n  if (si.addressType == IP_ADDRESS_TYPE_IPV4) {\n    sa.sin.sin_family = AF_INET;\n    sa.sin.sin_port = htons(si.remotePort);\n    sa.sin.sin_addr.s_addr = si.remoteIPaddress.v4Add.Val;\n  } else {\n    /* TODO(alashkin): do something with _potential_ IPv6 */\n    memset(&sa, 0, sizeof(sa));\n  }\n\n  mg_if_accept_tcp_cb(nc, (union socket_address *) &sa, sizeof(sa));\n\n  return mg_pic32_if_listen_tcp(lc, &lc->sa) >= 0;\n}\n\nchar *inet_ntoa(struct in_addr in) {\n  static char addr[17];\n  snprintf(addr, sizeof(addr), \"%d.%d.%d.%d\", (int) in.S_un.S_un_b.s_b1,\n           (int) in.S_un.S_un_b.s_b2, (int) in.S_un.S_un_b.s_b3,\n           (int) in.S_un.S_un_b.s_b4);\n  return addr;\n}\n\nstatic void mg_handle_send(struct mg_connection *nc) {\n  uint16_t bytes_written = 0;\n  if (nc->flags & MG_F_UDP) {\n    if (!TCPIP_UDP_RemoteBind(\n            (UDP_SOCKET) nc->sock,\n            nc->sa.sin.sin_family == AF_INET ? IP_ADDRESS_TYPE_IPV4\n                                             : IP_ADDRESS_TYPE_IPV6,\n            ntohs(nc->sa.sin.sin_port), (IP_MULTI_ADDRESS *) &nc->sa.sin)) {\n      nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n      return;\n    }\n    bytes_written = TCPIP_UDP_TxPutIsReady((UDP_SOCKET) nc->sock, 0);\n    if (bytes_written >= nc->send_mbuf.len) {\n      if (TCPIP_UDP_ArrayPut((UDP_SOCKET) nc->sock,\n                             (uint8_t *) nc->send_mbuf.buf,\n                             nc->send_mbuf.len) != nc->send_mbuf.len) {\n        nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n        bytes_written = 0;\n      }\n    }\n  } else {\n    bytes_written = TCPIP_TCP_FifoTxFreeGet((TCP_SOCKET) nc->sock);\n    if (bytes_written != 0) {\n      if (bytes_written > nc->send_mbuf.len) {\n        bytes_written = nc->send_mbuf.len;\n      }\n      if (TCPIP_TCP_ArrayPut((TCP_SOCKET) nc->sock,\n                             (uint8_t *) nc->send_mbuf.buf,\n                             bytes_written) != bytes_written) {\n        nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n        bytes_written = 0;\n      }\n    }\n  }\n\n  if (bytes_written != 0) {\n    mbuf_remove(&nc->send_mbuf, bytes_written);\n    mg_if_sent_cb(nc, bytes_written);\n  }\n}\n\nstatic void mg_handle_recv(struct mg_connection *nc) {\n  uint16_t bytes_read = 0;\n  uint8_t *buf = NULL;\n  if (nc->flags & MG_F_UDP) {\n    bytes_read = TCPIP_UDP_GetIsReady((UDP_SOCKET) nc->sock);\n    if (bytes_read != 0 &&\n        (nc->recv_mbuf_limit == -1 ||\n         nc->recv_mbuf.len + bytes_read < nc->recv_mbuf_limit)) {\n      buf = (uint8_t *) MG_MALLOC(bytes_read);\n      if (TCPIP_UDP_ArrayGet((UDP_SOCKET) nc->sock, buf, bytes_read) !=\n          bytes_read) {\n        nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n        bytes_read = 0;\n        MG_FREE(buf);\n      }\n    }\n  } else {\n    bytes_read = TCPIP_TCP_GetIsReady((TCP_SOCKET) nc->sock);\n    if (bytes_read != 0) {\n      if (nc->recv_mbuf_limit != -1 &&\n          nc->recv_mbuf_limit - nc->recv_mbuf.len > bytes_read) {\n        bytes_read = nc->recv_mbuf_limit - nc->recv_mbuf.len;\n      }\n      buf = (uint8_t *) MG_MALLOC(bytes_read);\n      if (TCPIP_TCP_ArrayGet((TCP_SOCKET) nc->sock, buf, bytes_read) !=\n          bytes_read) {\n        nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n        MG_FREE(buf);\n        bytes_read = 0;\n      }\n    }\n  }\n\n  if (bytes_read != 0) {\n    mg_if_recv_tcp_cb(nc, buf, bytes_read, 1 /* own */);\n  }\n}\n\ntime_t mg_pic32_if_poll(struct mg_iface *iface, int timeout_ms) {\n  struct mg_mgr *mgr = iface->mgr;\n  double now = mg_time();\n  struct mg_connection *nc, *tmp;\n\n  for (nc = mgr->active_connections; nc != NULL; nc = tmp) {\n    tmp = nc->next;\n\n    if (nc->flags & MG_F_CONNECTING) {\n      /* processing connections */\n      if (nc->flags & MG_F_UDP ||\n          TCPIP_TCP_IsConnected((TCP_SOCKET) nc->sock)) {\n        mg_if_connect_cb(nc, 0);\n      }\n    } else if (nc->flags & MG_F_LISTENING) {\n      if (TCPIP_TCP_IsConnected((TCP_SOCKET) nc->sock)) {\n        /* accept new connections */\n        mg_accept_conn(nc);\n      }\n    } else {\n      if (nc->send_mbuf.len != 0) {\n        mg_handle_send(nc);\n      }\n\n      if (nc->recv_mbuf_limit == -1 ||\n          nc->recv_mbuf.len < nc->recv_mbuf_limit) {\n        mg_handle_recv(nc);\n      }\n    }\n  }\n\n  for (nc = mgr->active_connections; nc != NULL; nc = tmp) {\n    tmp = nc->next;\n    if ((nc->flags & MG_F_CLOSE_IMMEDIATELY) ||\n        (nc->send_mbuf.len == 0 && (nc->flags & MG_F_SEND_AND_CLOSE))) {\n      mg_close_conn(nc);\n    }\n  }\n\n  return now;\n}\n\nvoid mg_pic32_if_sock_set(struct mg_connection *nc, sock_t sock) {\n  nc->sock = sock;\n}\n\nvoid mg_pic32_if_get_conn_addr(struct mg_connection *nc, int remote,\n                               union socket_address *sa) {\n  /* TODO(alaskin): not implemented yet */\n}\n\nvoid mg_pic32_if_connect_tcp(struct mg_connection *nc,\n                             const union socket_address *sa) {\n  nc->sock = TCPIP_TCP_ClientOpen(\n      sa->sin.sin_family == AF_INET ? IP_ADDRESS_TYPE_IPV4\n                                    : IP_ADDRESS_TYPE_IPV6,\n      ntohs(sa->sin.sin_port), (IP_MULTI_ADDRESS *) &sa->sin);\n  nc->err = (nc->sock == INVALID_SOCKET) ? -1 : 0;\n}\n\nvoid mg_pic32_if_connect_udp(struct mg_connection *nc) {\n  nc->sock = TCPIP_UDP_ClientOpen(IP_ADDRESS_TYPE_ANY, 0, NULL);\n  nc->err = (nc->sock == INVALID_SOCKET) ? -1 : 0;\n}\n\n/* clang-format off */\n#define MG_PIC32_IFACE_VTABLE                                   \\\n  {                                                             \\\n    mg_pic32_if_init,                                           \\\n    mg_pic32_if_free,                                           \\\n    mg_pic32_if_add_conn,                                       \\\n    mg_pic32_if_remove_conn,                                    \\\n    mg_pic32_if_poll,                                           \\\n    mg_pic32_if_listen_tcp,                                     \\\n    mg_pic32_if_listen_udp,                                     \\\n    mg_pic32_if_connect_tcp,                                    \\\n    mg_pic32_if_connect_udp,                                    \\\n    mg_pic32_if_tcp_send,                                       \\\n    mg_pic32_if_udp_send,                                       \\\n    mg_pic32_if_recved,                                         \\\n    mg_pic32_if_create_conn,                                    \\\n    mg_pic32_if_destroy_conn,                                   \\\n    mg_pic32_if_sock_set,                                       \\\n    mg_pic32_if_get_conn_addr,                                  \\\n  }\n/* clang-format on */\n\nconst struct mg_iface_vtable mg_pic32_iface_vtable = MG_PIC32_IFACE_VTABLE;\n#if MG_NET_IF == MG_NET_IF_PIC32\nconst struct mg_iface_vtable mg_default_iface_vtable = MG_PIC32_IFACE_VTABLE;\n#endif\n\n#endif /* MG_ENABLE_NET_IF_PIC32 */\n"], "fixing_code": ["#include \"mongoose.h\"\n#ifdef MG_MODULE_LINES\n#line 1 \"mongoose/src/internal.h\"\n#endif\n/*\n * Copyright (c) 2014 Cesanta Software Limited\n * All rights reserved\n */\n\n#ifndef CS_MONGOOSE_SRC_INTERNAL_H_\n#define CS_MONGOOSE_SRC_INTERNAL_H_\n\n/* Amalgamated: #include \"common/mg_mem.h\" */\n\n#ifndef MBUF_REALLOC\n#define MBUF_REALLOC MG_REALLOC\n#endif\n\n#ifndef MBUF_FREE\n#define MBUF_FREE MG_FREE\n#endif\n\n#define MG_SET_PTRPTR(_ptr, _v) \\\n  do {                          \\\n    if (_ptr) *(_ptr) = _v;     \\\n  } while (0)\n\n#ifndef MG_INTERNAL\n#define MG_INTERNAL static\n#endif\n\n#ifdef PICOTCP\n#define NO_LIBC\n#define MG_DISABLE_PFS\n#endif\n\n/* Amalgamated: #include \"mongoose/src/net.h\" */\n/* Amalgamated: #include \"mongoose/src/http.h\" */\n/* Amalgamated: #include \"common/cs_dbg.h\" */\n\n#define MG_CTL_MSG_MESSAGE_SIZE 8192\n\n/* internals that need to be accessible in unit tests */\nMG_INTERNAL struct mg_connection *mg_do_connect(struct mg_connection *nc,\n                                                int proto,\n                                                union socket_address *sa);\n\nMG_INTERNAL int mg_parse_address(const char *str, union socket_address *sa,\n                                 int *proto, char *host, size_t host_len);\nMG_INTERNAL void mg_call(struct mg_connection *nc,\n                         mg_event_handler_t ev_handler, void *user_data, int ev,\n                         void *ev_data);\nvoid mg_forward(struct mg_connection *from, struct mg_connection *to);\nMG_INTERNAL void mg_add_conn(struct mg_mgr *mgr, struct mg_connection *c);\nMG_INTERNAL void mg_remove_conn(struct mg_connection *c);\nMG_INTERNAL struct mg_connection *mg_create_connection(\n    struct mg_mgr *mgr, mg_event_handler_t callback,\n    struct mg_add_sock_opts opts);\n#ifdef _WIN32\n/* Retur value is the same as for MultiByteToWideChar. */\nint to_wchar(const char *path, wchar_t *wbuf, size_t wbuf_len);\n#endif\n\nstruct ctl_msg {\n  mg_event_handler_t callback;\n  char message[MG_CTL_MSG_MESSAGE_SIZE];\n};\n\n#if MG_ENABLE_MQTT\nstruct mg_mqtt_message;\nMG_INTERNAL int parse_mqtt(struct mbuf *io, struct mg_mqtt_message *mm);\n#endif\n\n/* Forward declarations for testing. */\nextern void *(*test_malloc)(size_t size);\nextern void *(*test_calloc)(size_t count, size_t size);\n\n#ifndef MIN\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n#endif\n\n#if MG_ENABLE_HTTP\nstruct mg_serve_http_opts;\n\n/*\n * Reassemble the content of the buffer (buf, blen) which should be\n * in the HTTP chunked encoding, by collapsing data chunks to the\n * beginning of the buffer.\n *\n * If chunks get reassembled, modify hm->body to point to the reassembled\n * body and fire MG_EV_HTTP_CHUNK event. If handler sets MG_F_DELETE_CHUNK\n * in nc->flags, delete reassembled body from the mbuf.\n *\n * Return reassembled body size.\n */\nMG_INTERNAL size_t mg_handle_chunked(struct mg_connection *nc,\n                                     struct http_message *hm, char *buf,\n                                     size_t blen);\n\nMG_INTERNAL int mg_http_common_url_parse(const char *url, const char *schema,\n                                         const char *schema_tls, int *use_ssl,\n                                         char **user, char **pass, char **addr,\n                                         int *port_i, const char **path);\n\n#if MG_ENABLE_FILESYSTEM\nMG_INTERNAL int mg_uri_to_local_path(struct http_message *hm,\n                                     const struct mg_serve_http_opts *opts,\n                                     char **local_path,\n                                     struct mg_str *remainder);\nMG_INTERNAL time_t mg_parse_date_string(const char *datetime);\nMG_INTERNAL int mg_is_not_modified(struct http_message *hm, cs_stat_t *st);\n#endif\n#if MG_ENABLE_HTTP_CGI\nMG_INTERNAL void mg_handle_cgi(struct mg_connection *nc, const char *prog,\n                               const struct mg_str *path_info,\n                               const struct http_message *hm,\n                               const struct mg_serve_http_opts *opts);\nstruct mg_http_proto_data_cgi;\nMG_INTERNAL void mg_http_free_proto_data_cgi(struct mg_http_proto_data_cgi *d);\n#endif\n#if MG_ENABLE_HTTP_SSI\nMG_INTERNAL void mg_handle_ssi_request(struct mg_connection *nc,\n                                       struct http_message *hm,\n                                       const char *path,\n                                       const struct mg_serve_http_opts *opts);\n#endif\n#if MG_ENABLE_HTTP_WEBDAV\nMG_INTERNAL int mg_is_dav_request(const struct mg_str *s);\nMG_INTERNAL void mg_handle_propfind(struct mg_connection *nc, const char *path,\n                                    cs_stat_t *stp, struct http_message *hm,\n                                    struct mg_serve_http_opts *opts);\nMG_INTERNAL void mg_handle_lock(struct mg_connection *nc, const char *path);\nMG_INTERNAL void mg_handle_mkcol(struct mg_connection *nc, const char *path,\n                                 struct http_message *hm);\nMG_INTERNAL void mg_handle_move(struct mg_connection *c,\n                                const struct mg_serve_http_opts *opts,\n                                const char *path, struct http_message *hm);\nMG_INTERNAL void mg_handle_delete(struct mg_connection *nc,\n                                  const struct mg_serve_http_opts *opts,\n                                  const char *path);\nMG_INTERNAL void mg_handle_put(struct mg_connection *nc, const char *path,\n                               struct http_message *hm);\n#endif\n#if MG_ENABLE_HTTP_WEBSOCKET\nMG_INTERNAL void mg_ws_handler(struct mg_connection *nc, int ev,\n                               void *ev_data MG_UD_ARG(void *user_data));\nMG_INTERNAL void mg_ws_handshake(struct mg_connection *nc,\n                                 const struct mg_str *key);\n#endif\n#endif /* MG_ENABLE_HTTP */\n\nMG_INTERNAL int mg_get_errno(void);\n\nMG_INTERNAL void mg_close_conn(struct mg_connection *conn);\n\nMG_INTERNAL int mg_http_common_url_parse(const char *url, const char *schema,\n                                         const char *schema_tls, int *use_ssl,\n                                         char **user, char **pass, char **addr,\n                                         int *port_i, const char **path);\n\n#if MG_ENABLE_SNTP\nMG_INTERNAL int mg_sntp_parse_reply(const char *buf, int len,\n                                    struct mg_sntp_message *msg);\n#endif\n\n#endif /* CS_MONGOOSE_SRC_INTERNAL_H_ */\n#ifdef MG_MODULE_LINES\n#line 1 \"common/mg_mem.h\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#ifndef CS_COMMON_MG_MEM_H_\n#define CS_COMMON_MG_MEM_H_\n\n#ifndef MG_MALLOC\n#define MG_MALLOC malloc\n#endif\n\n#ifndef MG_CALLOC\n#define MG_CALLOC calloc\n#endif\n\n#ifndef MG_REALLOC\n#define MG_REALLOC realloc\n#endif\n\n#ifndef MG_FREE\n#define MG_FREE free\n#endif\n\n#endif /* CS_COMMON_MG_MEM_H_ */\n#ifdef MG_MODULE_LINES\n#line 1 \"common/cs_dbg.h\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#ifndef CS_COMMON_CS_DBG_H_\n#define CS_COMMON_CS_DBG_H_\n\n/* Amalgamated: #include \"common/platform.h\" */\n\n#if CS_ENABLE_STDIO\n#include <stdio.h>\n#endif\n\n#ifndef CS_ENABLE_DEBUG\n#define CS_ENABLE_DEBUG 0\n#endif\n\n#ifndef CS_LOG_ENABLE_TS_DIFF\n#define CS_LOG_ENABLE_TS_DIFF 0\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif /* __cplusplus */\n\nenum cs_log_level {\n  LL_NONE = -1,\n  LL_ERROR = 0,\n  LL_WARN = 1,\n  LL_INFO = 2,\n  LL_DEBUG = 3,\n  LL_VERBOSE_DEBUG = 4,\n\n  _LL_MIN = -2,\n  _LL_MAX = 5,\n};\n\nvoid cs_log_set_level(enum cs_log_level level);\n\n#if CS_ENABLE_STDIO\n\nvoid cs_log_set_file(FILE *file);\nextern enum cs_log_level cs_log_level;\nvoid cs_log_print_prefix(const char *func);\nvoid cs_log_printf(const char *fmt, ...);\n\n#define LOG(l, x)                    \\\n  do {                               \\\n    if (cs_log_level >= l) {         \\\n      cs_log_print_prefix(__func__); \\\n      cs_log_printf x;               \\\n    }                                \\\n  } while (0)\n\n#ifndef CS_NDEBUG\n\n#define DBG(x)                              \\\n  do {                                      \\\n    if (cs_log_level >= LL_VERBOSE_DEBUG) { \\\n      cs_log_print_prefix(__func__);        \\\n      cs_log_printf x;                      \\\n    }                                       \\\n  } while (0)\n\n#else /* NDEBUG */\n\n#define DBG(x)\n\n#endif\n\n#else /* CS_ENABLE_STDIO */\n\n#define LOG(l, x)\n#define DBG(x)\n\n#endif\n\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n\n#endif /* CS_COMMON_CS_DBG_H_ */\n#ifdef MG_MODULE_LINES\n#line 1 \"common/cs_dbg.c\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n/* Amalgamated: #include \"common/cs_dbg.h\" */\n\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n\n/* Amalgamated: #include \"common/cs_time.h\" */\n\nenum cs_log_level cs_log_level WEAK =\n#if CS_ENABLE_DEBUG\n    LL_VERBOSE_DEBUG;\n#else\n    LL_ERROR;\n#endif\n\n#if CS_ENABLE_STDIO\n\nFILE *cs_log_file WEAK = NULL;\n\n#if CS_LOG_ENABLE_TS_DIFF\ndouble cs_log_ts WEAK;\n#endif\n\nvoid cs_log_print_prefix(const char *func) WEAK;\nvoid cs_log_print_prefix(const char *func) {\n  char prefix[21];\n  strncpy(prefix, func, 20);\n  prefix[20] = '\\0';\n  if (cs_log_file == NULL) cs_log_file = stderr;\n  fprintf(cs_log_file, \"%-20s \", prefix);\n#if CS_LOG_ENABLE_TS_DIFF\n  {\n    double now = cs_time();\n    fprintf(cs_log_file, \"%7u \", (unsigned int) ((now - cs_log_ts) * 1000000));\n    cs_log_ts = now;\n  }\n#endif\n}\n\nvoid cs_log_printf(const char *fmt, ...) WEAK;\nvoid cs_log_printf(const char *fmt, ...) {\n  va_list ap;\n  va_start(ap, fmt);\n  vfprintf(cs_log_file, fmt, ap);\n  va_end(ap);\n  fputc('\\n', cs_log_file);\n  fflush(cs_log_file);\n}\n\nvoid cs_log_set_file(FILE *file) WEAK;\nvoid cs_log_set_file(FILE *file) {\n  cs_log_file = file;\n}\n\n#endif /* CS_ENABLE_STDIO */\n\nvoid cs_log_set_level(enum cs_log_level level) WEAK;\nvoid cs_log_set_level(enum cs_log_level level) {\n  cs_log_level = level;\n#if CS_LOG_ENABLE_TS_DIFF && CS_ENABLE_STDIO\n  cs_log_ts = cs_time();\n#endif\n}\n#ifdef MG_MODULE_LINES\n#line 1 \"common/base64.c\"\n#endif\n/*\n * Copyright (c) 2014 Cesanta Software Limited\n * All rights reserved\n */\n\n#ifndef EXCLUDE_COMMON\n\n/* Amalgamated: #include \"common/base64.h\" */\n\n#include <string.h>\n\n/* Amalgamated: #include \"common/cs_dbg.h\" */\n\n/* ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/ */\n\n#define NUM_UPPERCASES ('Z' - 'A' + 1)\n#define NUM_LETTERS (NUM_UPPERCASES * 2)\n#define NUM_DIGITS ('9' - '0' + 1)\n\n/*\n * Emit a base64 code char.\n *\n * Doesn't use memory, thus it's safe to use to safely dump memory in crashdumps\n */\nstatic void cs_base64_emit_code(struct cs_base64_ctx *ctx, int v) {\n  if (v < NUM_UPPERCASES) {\n    ctx->b64_putc(v + 'A', ctx->user_data);\n  } else if (v < (NUM_LETTERS)) {\n    ctx->b64_putc(v - NUM_UPPERCASES + 'a', ctx->user_data);\n  } else if (v < (NUM_LETTERS + NUM_DIGITS)) {\n    ctx->b64_putc(v - NUM_LETTERS + '0', ctx->user_data);\n  } else {\n    ctx->b64_putc(v - NUM_LETTERS - NUM_DIGITS == 0 ? '+' : '/',\n                  ctx->user_data);\n  }\n}\n\nstatic void cs_base64_emit_chunk(struct cs_base64_ctx *ctx) {\n  int a, b, c;\n\n  a = ctx->chunk[0];\n  b = ctx->chunk[1];\n  c = ctx->chunk[2];\n\n  cs_base64_emit_code(ctx, a >> 2);\n  cs_base64_emit_code(ctx, ((a & 3) << 4) | (b >> 4));\n  if (ctx->chunk_size > 1) {\n    cs_base64_emit_code(ctx, (b & 15) << 2 | (c >> 6));\n  }\n  if (ctx->chunk_size > 2) {\n    cs_base64_emit_code(ctx, c & 63);\n  }\n}\n\nvoid cs_base64_init(struct cs_base64_ctx *ctx, cs_base64_putc_t b64_putc,\n                    void *user_data) {\n  ctx->chunk_size = 0;\n  ctx->b64_putc = b64_putc;\n  ctx->user_data = user_data;\n}\n\nvoid cs_base64_update(struct cs_base64_ctx *ctx, const char *str, size_t len) {\n  const unsigned char *src = (const unsigned char *) str;\n  size_t i;\n  for (i = 0; i < len; i++) {\n    ctx->chunk[ctx->chunk_size++] = src[i];\n    if (ctx->chunk_size == 3) {\n      cs_base64_emit_chunk(ctx);\n      ctx->chunk_size = 0;\n    }\n  }\n}\n\nvoid cs_base64_finish(struct cs_base64_ctx *ctx) {\n  if (ctx->chunk_size > 0) {\n    int i;\n    memset(&ctx->chunk[ctx->chunk_size], 0, 3 - ctx->chunk_size);\n    cs_base64_emit_chunk(ctx);\n    for (i = 0; i < (3 - ctx->chunk_size); i++) {\n      ctx->b64_putc('=', ctx->user_data);\n    }\n  }\n}\n\n#define BASE64_ENCODE_BODY                                                \\\n  static const char *b64 =                                                \\\n      \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"; \\\n  int i, j, a, b, c;                                                      \\\n                                                                          \\\n  for (i = j = 0; i < src_len; i += 3) {                                  \\\n    a = src[i];                                                           \\\n    b = i + 1 >= src_len ? 0 : src[i + 1];                                \\\n    c = i + 2 >= src_len ? 0 : src[i + 2];                                \\\n                                                                          \\\n    BASE64_OUT(b64[a >> 2]);                                              \\\n    BASE64_OUT(b64[((a & 3) << 4) | (b >> 4)]);                           \\\n    if (i + 1 < src_len) {                                                \\\n      BASE64_OUT(b64[(b & 15) << 2 | (c >> 6)]);                          \\\n    }                                                                     \\\n    if (i + 2 < src_len) {                                                \\\n      BASE64_OUT(b64[c & 63]);                                            \\\n    }                                                                     \\\n  }                                                                       \\\n                                                                          \\\n  while (j % 4 != 0) {                                                    \\\n    BASE64_OUT('=');                                                      \\\n  }                                                                       \\\n  BASE64_FLUSH()\n\n#define BASE64_OUT(ch) \\\n  do {                 \\\n    dst[j++] = (ch);   \\\n  } while (0)\n\n#define BASE64_FLUSH() \\\n  do {                 \\\n    dst[j++] = '\\0';   \\\n  } while (0)\n\nvoid cs_base64_encode(const unsigned char *src, int src_len, char *dst) {\n  BASE64_ENCODE_BODY;\n}\n\n#undef BASE64_OUT\n#undef BASE64_FLUSH\n\n#if CS_ENABLE_STDIO\n#define BASE64_OUT(ch)      \\\n  do {                      \\\n    fprintf(f, \"%c\", (ch)); \\\n    j++;                    \\\n  } while (0)\n\n#define BASE64_FLUSH()\n\nvoid cs_fprint_base64(FILE *f, const unsigned char *src, int src_len) {\n  BASE64_ENCODE_BODY;\n}\n\n#undef BASE64_OUT\n#undef BASE64_FLUSH\n#endif /* CS_ENABLE_STDIO */\n\n/* Convert one byte of encoded base64 input stream to 6-bit chunk */\nstatic unsigned char from_b64(unsigned char ch) {\n  /* Inverse lookup map */\n  static const unsigned char tab[128] = {\n      255, 255, 255, 255,\n      255, 255, 255, 255, /*  0 */\n      255, 255, 255, 255,\n      255, 255, 255, 255, /*  8 */\n      255, 255, 255, 255,\n      255, 255, 255, 255, /*  16 */\n      255, 255, 255, 255,\n      255, 255, 255, 255, /*  24 */\n      255, 255, 255, 255,\n      255, 255, 255, 255, /*  32 */\n      255, 255, 255, 62,\n      255, 255, 255, 63, /*  40 */\n      52,  53,  54,  55,\n      56,  57,  58,  59, /*  48 */\n      60,  61,  255, 255,\n      255, 200, 255, 255, /*  56   '=' is 200, on index 61 */\n      255, 0,   1,   2,\n      3,   4,   5,   6, /*  64 */\n      7,   8,   9,   10,\n      11,  12,  13,  14, /*  72 */\n      15,  16,  17,  18,\n      19,  20,  21,  22, /*  80 */\n      23,  24,  25,  255,\n      255, 255, 255, 255, /*  88 */\n      255, 26,  27,  28,\n      29,  30,  31,  32, /*  96 */\n      33,  34,  35,  36,\n      37,  38,  39,  40, /*  104 */\n      41,  42,  43,  44,\n      45,  46,  47,  48, /*  112 */\n      49,  50,  51,  255,\n      255, 255, 255, 255, /*  120 */\n  };\n  return tab[ch & 127];\n}\n\nint cs_base64_decode(const unsigned char *s, int len, char *dst, int *dec_len) {\n  unsigned char a, b, c, d;\n  int orig_len = len;\n  char *orig_dst = dst;\n  while (len >= 4 && (a = from_b64(s[0])) != 255 &&\n         (b = from_b64(s[1])) != 255 && (c = from_b64(s[2])) != 255 &&\n         (d = from_b64(s[3])) != 255) {\n    s += 4;\n    len -= 4;\n    if (a == 200 || b == 200) break; /* '=' can't be there */\n    *dst++ = a << 2 | b >> 4;\n    if (c == 200) break;\n    *dst++ = b << 4 | c >> 2;\n    if (d == 200) break;\n    *dst++ = c << 6 | d;\n  }\n  *dst = 0;\n  if (dec_len != NULL) *dec_len = (dst - orig_dst);\n  return orig_len - len;\n}\n\n#endif /* EXCLUDE_COMMON */\n#ifdef MG_MODULE_LINES\n#line 1 \"common/cs_dirent.h\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#ifndef CS_COMMON_CS_DIRENT_H_\n#define CS_COMMON_CS_DIRENT_H_\n\n#include <limits.h>\n\n/* Amalgamated: #include \"common/platform.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif /* __cplusplus */\n\n#ifdef CS_DEFINE_DIRENT\ntypedef struct { int dummy; } DIR;\n\nstruct dirent {\n  int d_ino;\n#ifdef _WIN32\n  char d_name[MAX_PATH];\n#else\n  /* TODO(rojer): Use PATH_MAX but make sure it's sane on every platform */\n  char d_name[256];\n#endif\n};\n\nDIR *opendir(const char *dir_name);\nint closedir(DIR *dir);\nstruct dirent *readdir(DIR *dir);\n#endif /* CS_DEFINE_DIRENT */\n\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n\n#endif /* CS_COMMON_CS_DIRENT_H_ */\n#ifdef MG_MODULE_LINES\n#line 1 \"common/cs_dirent.c\"\n#endif\n/*\n * Copyright (c) 2015 Cesanta Software Limited\n * All rights reserved\n */\n\n#ifndef EXCLUDE_COMMON\n\n/* Amalgamated: #include \"common/mg_mem.h\" */\n/* Amalgamated: #include \"common/cs_dirent.h\" */\n\n/*\n * This file contains POSIX opendir/closedir/readdir API implementation\n * for systems which do not natively support it (e.g. Windows).\n */\n\n#ifdef _WIN32\nstruct win32_dir {\n  DIR d;\n  HANDLE handle;\n  WIN32_FIND_DATAW info;\n  struct dirent result;\n};\n\nDIR *opendir(const char *name) {\n  struct win32_dir *dir = NULL;\n  wchar_t wpath[MAX_PATH];\n  DWORD attrs;\n\n  if (name == NULL) {\n    SetLastError(ERROR_BAD_ARGUMENTS);\n  } else if ((dir = (struct win32_dir *) MG_MALLOC(sizeof(*dir))) == NULL) {\n    SetLastError(ERROR_NOT_ENOUGH_MEMORY);\n  } else {\n    to_wchar(name, wpath, ARRAY_SIZE(wpath));\n    attrs = GetFileAttributesW(wpath);\n    if (attrs != 0xFFFFFFFF && (attrs & FILE_ATTRIBUTE_DIRECTORY)) {\n      (void) wcscat(wpath, L\"\\\\*\");\n      dir->handle = FindFirstFileW(wpath, &dir->info);\n      dir->result.d_name[0] = '\\0';\n    } else {\n      MG_FREE(dir);\n      dir = NULL;\n    }\n  }\n\n  return (DIR *) dir;\n}\n\nint closedir(DIR *d) {\n  struct win32_dir *dir = (struct win32_dir *) d;\n  int result = 0;\n\n  if (dir != NULL) {\n    if (dir->handle != INVALID_HANDLE_VALUE)\n      result = FindClose(dir->handle) ? 0 : -1;\n    MG_FREE(dir);\n  } else {\n    result = -1;\n    SetLastError(ERROR_BAD_ARGUMENTS);\n  }\n\n  return result;\n}\n\nstruct dirent *readdir(DIR *d) {\n  struct win32_dir *dir = (struct win32_dir *) d;\n  struct dirent *result = NULL;\n\n  if (dir) {\n    memset(&dir->result, 0, sizeof(dir->result));\n    if (dir->handle != INVALID_HANDLE_VALUE) {\n      result = &dir->result;\n      (void) WideCharToMultiByte(CP_UTF8, 0, dir->info.cFileName, -1,\n                                 result->d_name, sizeof(result->d_name), NULL,\n                                 NULL);\n\n      if (!FindNextFileW(dir->handle, &dir->info)) {\n        (void) FindClose(dir->handle);\n        dir->handle = INVALID_HANDLE_VALUE;\n      }\n\n    } else {\n      SetLastError(ERROR_FILE_NOT_FOUND);\n    }\n  } else {\n    SetLastError(ERROR_BAD_ARGUMENTS);\n  }\n\n  return result;\n}\n#endif\n\n#endif /* EXCLUDE_COMMON */\n\n/* ISO C requires a translation unit to contain at least one declaration */\ntypedef int cs_dirent_dummy;\n#ifdef MG_MODULE_LINES\n#line 1 \"common/cs_time.c\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n/* Amalgamated: #include \"common/cs_time.h\" */\n\n#ifndef _WIN32\n#include <stddef.h>\n/*\n * There is no sys/time.h on ARMCC.\n */\n#if !(defined(__ARMCC_VERSION) || defined(__ICCARM__)) && \\\n    !defined(__TI_COMPILER_VERSION__) &&                  \\\n    (!defined(CS_PLATFORM) || CS_PLATFORM != CS_P_NXP_LPC)\n#include <sys/time.h>\n#endif\n#else\n#include <windows.h>\n#endif\n\ndouble cs_time(void) WEAK;\ndouble cs_time(void) {\n  double now;\n#ifndef _WIN32\n  struct timeval tv;\n  if (gettimeofday(&tv, NULL /* tz */) != 0) return 0;\n  now = (double) tv.tv_sec + (((double) tv.tv_usec) / 1000000.0);\n#else\n  SYSTEMTIME sysnow;\n  FILETIME ftime;\n  GetLocalTime(&sysnow);\n  SystemTimeToFileTime(&sysnow, &ftime);\n  /*\n   * 1. VC 6.0 doesn't support conversion uint64 -> double, so, using int64\n   * This should not cause a problems in this (21th) century\n   * 2. Windows FILETIME is a number of 100-nanosecond intervals since January\n   * 1, 1601 while time_t is a number of _seconds_ since January 1, 1970 UTC,\n   * thus, we need to convert to seconds and adjust amount (subtract 11644473600\n   * seconds)\n   */\n  now = (double) (((int64_t) ftime.dwLowDateTime +\n                   ((int64_t) ftime.dwHighDateTime << 32)) /\n                  10000000.0) -\n        11644473600;\n#endif /* _WIN32 */\n  return now;\n}\n#ifdef MG_MODULE_LINES\n#line 1 \"common/cs_endian.h\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#ifndef CS_COMMON_CS_ENDIAN_H_\n#define CS_COMMON_CS_ENDIAN_H_\n\n/*\n * clang with std=-c99 uses __LITTLE_ENDIAN, by default\n * while for ex, RTOS gcc - LITTLE_ENDIAN, by default\n * it depends on __USE_BSD, but let's have everything\n */\n#if !defined(BYTE_ORDER) && defined(__BYTE_ORDER)\n#define BYTE_ORDER __BYTE_ORDER\n#ifndef LITTLE_ENDIAN\n#define LITTLE_ENDIAN __LITTLE_ENDIAN\n#endif /* LITTLE_ENDIAN */\n#ifndef BIG_ENDIAN\n#define BIG_ENDIAN __LITTLE_ENDIAN\n#endif /* BIG_ENDIAN */\n#endif /* BYTE_ORDER */\n\n#endif /* CS_COMMON_CS_ENDIAN_H_ */\n#ifdef MG_MODULE_LINES\n#line 1 \"common/md5.c\"\n#endif\n/*\n * This code implements the MD5 message-digest algorithm.\n * The algorithm is due to Ron Rivest.  This code was\n * written by Colin Plumb in 1993, no copyright is claimed.\n * This code is in the public domain; do with it what you wish.\n *\n * Equivalent code is available from RSA Data Security, Inc.\n * This code has been tested against that, and is equivalent,\n * except that you don't need to include two pages of legalese\n * with every copy.\n *\n * To compute the message digest of a chunk of bytes, declare an\n * MD5Context structure, pass it to MD5Init, call MD5Update as\n * needed on buffers full of bytes, and then call MD5Final, which\n * will fill a supplied 16-byte array with the digest.\n */\n\n/* Amalgamated: #include \"common/md5.h\" */\n/* Amalgamated: #include \"common/str_util.h\" */\n\n#if !defined(EXCLUDE_COMMON)\n#if !CS_DISABLE_MD5\n\n/* Amalgamated: #include \"common/cs_endian.h\" */\n\nstatic void byteReverse(unsigned char *buf, unsigned longs) {\n/* Forrest: MD5 expect LITTLE_ENDIAN, swap if BIG_ENDIAN */\n#if BYTE_ORDER == BIG_ENDIAN\n  do {\n    uint32_t t = (uint32_t)((unsigned) buf[3] << 8 | buf[2]) << 16 |\n                 ((unsigned) buf[1] << 8 | buf[0]);\n    *(uint32_t *) buf = t;\n    buf += 4;\n  } while (--longs);\n#else\n  (void) buf;\n  (void) longs;\n#endif\n}\n\n#define F1(x, y, z) (z ^ (x & (y ^ z)))\n#define F2(x, y, z) F1(z, x, y)\n#define F3(x, y, z) (x ^ y ^ z)\n#define F4(x, y, z) (y ^ (x | ~z))\n\n#define MD5STEP(f, w, x, y, z, data, s) \\\n  (w += f(x, y, z) + data, w = w << s | w >> (32 - s), w += x)\n\n/*\n * Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious\n * initialization constants.\n */\nvoid MD5_Init(MD5_CTX *ctx) {\n  ctx->buf[0] = 0x67452301;\n  ctx->buf[1] = 0xefcdab89;\n  ctx->buf[2] = 0x98badcfe;\n  ctx->buf[3] = 0x10325476;\n\n  ctx->bits[0] = 0;\n  ctx->bits[1] = 0;\n}\n\nstatic void MD5Transform(uint32_t buf[4], uint32_t const in[16]) {\n  register uint32_t a, b, c, d;\n\n  a = buf[0];\n  b = buf[1];\n  c = buf[2];\n  d = buf[3];\n\n  MD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);\n  MD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);\n  MD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);\n  MD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);\n  MD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);\n  MD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);\n  MD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);\n  MD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);\n  MD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);\n  MD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);\n  MD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);\n  MD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);\n  MD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);\n  MD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);\n  MD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);\n  MD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);\n\n  MD5STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5);\n  MD5STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9);\n  MD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);\n  MD5STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);\n  MD5STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5);\n  MD5STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);\n  MD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);\n  MD5STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);\n  MD5STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5);\n  MD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);\n  MD5STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14);\n  MD5STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20);\n  MD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);\n  MD5STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);\n  MD5STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14);\n  MD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);\n\n  MD5STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4);\n  MD5STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11);\n  MD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);\n  MD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);\n  MD5STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4);\n  MD5STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);\n  MD5STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);\n  MD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);\n  MD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);\n  MD5STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11);\n  MD5STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);\n  MD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);\n  MD5STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);\n  MD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);\n  MD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);\n  MD5STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23);\n\n  MD5STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6);\n  MD5STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10);\n  MD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);\n  MD5STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21);\n  MD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);\n  MD5STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);\n  MD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);\n  MD5STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21);\n  MD5STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);\n  MD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);\n  MD5STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15);\n  MD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);\n  MD5STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6);\n  MD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);\n  MD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);\n  MD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);\n\n  buf[0] += a;\n  buf[1] += b;\n  buf[2] += c;\n  buf[3] += d;\n}\n\nvoid MD5_Update(MD5_CTX *ctx, const unsigned char *buf, size_t len) {\n  uint32_t t;\n\n  t = ctx->bits[0];\n  if ((ctx->bits[0] = t + ((uint32_t) len << 3)) < t) ctx->bits[1]++;\n  ctx->bits[1] += (uint32_t) len >> 29;\n\n  t = (t >> 3) & 0x3f;\n\n  if (t) {\n    unsigned char *p = (unsigned char *) ctx->in + t;\n\n    t = 64 - t;\n    if (len < t) {\n      memcpy(p, buf, len);\n      return;\n    }\n    memcpy(p, buf, t);\n    byteReverse(ctx->in, 16);\n    MD5Transform(ctx->buf, (uint32_t *) ctx->in);\n    buf += t;\n    len -= t;\n  }\n\n  while (len >= 64) {\n    memcpy(ctx->in, buf, 64);\n    byteReverse(ctx->in, 16);\n    MD5Transform(ctx->buf, (uint32_t *) ctx->in);\n    buf += 64;\n    len -= 64;\n  }\n\n  memcpy(ctx->in, buf, len);\n}\n\nvoid MD5_Final(unsigned char digest[16], MD5_CTX *ctx) {\n  unsigned count;\n  unsigned char *p;\n  uint32_t *a;\n\n  count = (ctx->bits[0] >> 3) & 0x3F;\n\n  p = ctx->in + count;\n  *p++ = 0x80;\n  count = 64 - 1 - count;\n  if (count < 8) {\n    memset(p, 0, count);\n    byteReverse(ctx->in, 16);\n    MD5Transform(ctx->buf, (uint32_t *) ctx->in);\n    memset(ctx->in, 0, 56);\n  } else {\n    memset(p, 0, count - 8);\n  }\n  byteReverse(ctx->in, 14);\n\n  a = (uint32_t *) ctx->in;\n  a[14] = ctx->bits[0];\n  a[15] = ctx->bits[1];\n\n  MD5Transform(ctx->buf, (uint32_t *) ctx->in);\n  byteReverse((unsigned char *) ctx->buf, 4);\n  memcpy(digest, ctx->buf, 16);\n  memset((char *) ctx, 0, sizeof(*ctx));\n}\n\nchar *cs_md5(char buf[33], ...) {\n  unsigned char hash[16];\n  const unsigned char *p;\n  va_list ap;\n  MD5_CTX ctx;\n\n  MD5_Init(&ctx);\n\n  va_start(ap, buf);\n  while ((p = va_arg(ap, const unsigned char *) ) != NULL) {\n    size_t len = va_arg(ap, size_t);\n    MD5_Update(&ctx, p, len);\n  }\n  va_end(ap);\n\n  MD5_Final(hash, &ctx);\n  cs_to_hex(buf, hash, sizeof(hash));\n\n  return buf;\n}\n\n#endif /* CS_DISABLE_MD5 */\n#endif /* EXCLUDE_COMMON */\n#ifdef MG_MODULE_LINES\n#line 1 \"common/mbuf.c\"\n#endif\n/*\n * Copyright (c) 2014 Cesanta Software Limited\n * All rights reserved\n */\n\n#ifndef EXCLUDE_COMMON\n\n#include <assert.h>\n#include <string.h>\n/* Amalgamated: #include \"common/mbuf.h\" */\n\n#ifndef MBUF_REALLOC\n#define MBUF_REALLOC realloc\n#endif\n\n#ifndef MBUF_FREE\n#define MBUF_FREE free\n#endif\n\nvoid mbuf_init(struct mbuf *mbuf, size_t initial_size) WEAK;\nvoid mbuf_init(struct mbuf *mbuf, size_t initial_size) {\n  mbuf->len = mbuf->size = 0;\n  mbuf->buf = NULL;\n  mbuf_resize(mbuf, initial_size);\n}\n\nvoid mbuf_free(struct mbuf *mbuf) WEAK;\nvoid mbuf_free(struct mbuf *mbuf) {\n  if (mbuf->buf != NULL) {\n    MBUF_FREE(mbuf->buf);\n    mbuf_init(mbuf, 0);\n  }\n}\n\nvoid mbuf_resize(struct mbuf *a, size_t new_size) WEAK;\nvoid mbuf_resize(struct mbuf *a, size_t new_size) {\n  if (new_size > a->size || (new_size < a->size && new_size >= a->len)) {\n    char *buf = (char *) MBUF_REALLOC(a->buf, new_size);\n    /*\n     * In case realloc fails, there's not much we can do, except keep things as\n     * they are. Note that NULL is a valid return value from realloc when\n     * size == 0, but that is covered too.\n     */\n    if (buf == NULL && new_size != 0) return;\n    a->buf = buf;\n    a->size = new_size;\n  }\n}\n\nvoid mbuf_trim(struct mbuf *mbuf) WEAK;\nvoid mbuf_trim(struct mbuf *mbuf) {\n  mbuf_resize(mbuf, mbuf->len);\n}\n\nsize_t mbuf_insert(struct mbuf *a, size_t off, const void *buf, size_t) WEAK;\nsize_t mbuf_insert(struct mbuf *a, size_t off, const void *buf, size_t len) {\n  char *p = NULL;\n\n  assert(a != NULL);\n  assert(a->len <= a->size);\n  assert(off <= a->len);\n\n  /* check overflow */\n  if (~(size_t) 0 - (size_t) a->buf < len) return 0;\n\n  if (a->len + len <= a->size) {\n    memmove(a->buf + off + len, a->buf + off, a->len - off);\n    if (buf != NULL) {\n      memcpy(a->buf + off, buf, len);\n    }\n    a->len += len;\n  } else {\n    size_t new_size = (size_t)((a->len + len) * MBUF_SIZE_MULTIPLIER);\n    if ((p = (char *) MBUF_REALLOC(a->buf, new_size)) != NULL) {\n      a->buf = p;\n      memmove(a->buf + off + len, a->buf + off, a->len - off);\n      if (buf != NULL) memcpy(a->buf + off, buf, len);\n      a->len += len;\n      a->size = new_size;\n    } else {\n      len = 0;\n    }\n  }\n\n  return len;\n}\n\nsize_t mbuf_append(struct mbuf *a, const void *buf, size_t len) WEAK;\nsize_t mbuf_append(struct mbuf *a, const void *buf, size_t len) {\n  return mbuf_insert(a, a->len, buf, len);\n}\n\nvoid mbuf_remove(struct mbuf *mb, size_t n) WEAK;\nvoid mbuf_remove(struct mbuf *mb, size_t n) {\n  if (n > 0 && n <= mb->len) {\n    memmove(mb->buf, mb->buf + n, mb->len - n);\n    mb->len -= n;\n  }\n}\n\n#endif /* EXCLUDE_COMMON */\n#ifdef MG_MODULE_LINES\n#line 1 \"common/mg_str.c\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n/* Amalgamated: #include \"common/mg_mem.h\" */\n/* Amalgamated: #include \"common/mg_str.h\" */\n\n#include <stdlib.h>\n#include <string.h>\n\nint mg_ncasecmp(const char *s1, const char *s2, size_t len) WEAK;\n\nstruct mg_str mg_mk_str(const char *s) WEAK;\nstruct mg_str mg_mk_str(const char *s) {\n  struct mg_str ret = {s, 0};\n  if (s != NULL) ret.len = strlen(s);\n  return ret;\n}\n\nstruct mg_str mg_mk_str_n(const char *s, size_t len) WEAK;\nstruct mg_str mg_mk_str_n(const char *s, size_t len) {\n  struct mg_str ret = {s, len};\n  return ret;\n}\n\nint mg_vcmp(const struct mg_str *str1, const char *str2) WEAK;\nint mg_vcmp(const struct mg_str *str1, const char *str2) {\n  size_t n2 = strlen(str2), n1 = str1->len;\n  int r = strncmp(str1->p, str2, (n1 < n2) ? n1 : n2);\n  if (r == 0) {\n    return n1 - n2;\n  }\n  return r;\n}\n\nint mg_vcasecmp(const struct mg_str *str1, const char *str2) WEAK;\nint mg_vcasecmp(const struct mg_str *str1, const char *str2) {\n  size_t n2 = strlen(str2), n1 = str1->len;\n  int r = mg_ncasecmp(str1->p, str2, (n1 < n2) ? n1 : n2);\n  if (r == 0) {\n    return n1 - n2;\n  }\n  return r;\n}\n\nstruct mg_str mg_strdup(const struct mg_str s) WEAK;\nstruct mg_str mg_strdup(const struct mg_str s) {\n  struct mg_str r = {NULL, 0};\n  if (s.len > 0 && s.p != NULL) {\n    r.p = (char *) MG_MALLOC(s.len);\n    if (r.p != NULL) {\n      memcpy((char *) r.p, s.p, s.len);\n      r.len = s.len;\n    }\n  }\n  return r;\n}\n\nint mg_strcmp(const struct mg_str str1, const struct mg_str str2) WEAK;\nint mg_strcmp(const struct mg_str str1, const struct mg_str str2) {\n  size_t i = 0;\n  while (i < str1.len && i < str2.len) {\n    if (str1.p[i] < str2.p[i]) return -1;\n    if (str1.p[i] > str2.p[i]) return 1;\n    i++;\n  }\n  if (i < str1.len) return 1;\n  if (i < str2.len) return -1;\n  return 0;\n}\n\nint mg_strncmp(const struct mg_str, const struct mg_str, size_t n) WEAK;\nint mg_strncmp(const struct mg_str str1, const struct mg_str str2, size_t n) {\n  struct mg_str s1 = str1;\n  struct mg_str s2 = str2;\n\n  if (s1.len > n) {\n    s1.len = n;\n  }\n  if (s2.len > n) {\n    s2.len = n;\n  }\n  return mg_strcmp(s1, s2);\n}\n#ifdef MG_MODULE_LINES\n#line 1 \"common/sha1.c\"\n#endif\n/* Copyright(c) By Steve Reid <steve@edmweb.com> */\n/* 100% Public Domain */\n\n/* Amalgamated: #include \"common/sha1.h\" */\n\n#if !CS_DISABLE_SHA1 && !defined(EXCLUDE_COMMON)\n\n/* Amalgamated: #include \"common/cs_endian.h\" */\n\n#define SHA1HANDSOFF\n#if defined(__sun)\n/* Amalgamated: #include \"common/solarisfixes.h\" */\n#endif\n\nunion char64long16 {\n  unsigned char c[64];\n  uint32_t l[16];\n};\n\n#define rol(value, bits) (((value) << (bits)) | ((value) >> (32 - (bits))))\n\nstatic uint32_t blk0(union char64long16 *block, int i) {\n/* Forrest: SHA expect BIG_ENDIAN, swap if LITTLE_ENDIAN */\n#if BYTE_ORDER == LITTLE_ENDIAN\n  block->l[i] =\n      (rol(block->l[i], 24) & 0xFF00FF00) | (rol(block->l[i], 8) & 0x00FF00FF);\n#endif\n  return block->l[i];\n}\n\n/* Avoid redefine warning (ARM /usr/include/sys/ucontext.h define R0~R4) */\n#undef blk\n#undef R0\n#undef R1\n#undef R2\n#undef R3\n#undef R4\n\n#define blk(i)                                                               \\\n  (block->l[i & 15] = rol(block->l[(i + 13) & 15] ^ block->l[(i + 8) & 15] ^ \\\n                              block->l[(i + 2) & 15] ^ block->l[i & 15],     \\\n                          1))\n#define R0(v, w, x, y, z, i)                                          \\\n  z += ((w & (x ^ y)) ^ y) + blk0(block, i) + 0x5A827999 + rol(v, 5); \\\n  w = rol(w, 30);\n#define R1(v, w, x, y, z, i)                                  \\\n  z += ((w & (x ^ y)) ^ y) + blk(i) + 0x5A827999 + rol(v, 5); \\\n  w = rol(w, 30);\n#define R2(v, w, x, y, z, i)                          \\\n  z += (w ^ x ^ y) + blk(i) + 0x6ED9EBA1 + rol(v, 5); \\\n  w = rol(w, 30);\n#define R3(v, w, x, y, z, i)                                        \\\n  z += (((w | x) & y) | (w & x)) + blk(i) + 0x8F1BBCDC + rol(v, 5); \\\n  w = rol(w, 30);\n#define R4(v, w, x, y, z, i)                          \\\n  z += (w ^ x ^ y) + blk(i) + 0xCA62C1D6 + rol(v, 5); \\\n  w = rol(w, 30);\n\nvoid cs_sha1_transform(uint32_t state[5], const unsigned char buffer[64]) {\n  uint32_t a, b, c, d, e;\n  union char64long16 block[1];\n\n  memcpy(block, buffer, 64);\n  a = state[0];\n  b = state[1];\n  c = state[2];\n  d = state[3];\n  e = state[4];\n  R0(a, b, c, d, e, 0);\n  R0(e, a, b, c, d, 1);\n  R0(d, e, a, b, c, 2);\n  R0(c, d, e, a, b, 3);\n  R0(b, c, d, e, a, 4);\n  R0(a, b, c, d, e, 5);\n  R0(e, a, b, c, d, 6);\n  R0(d, e, a, b, c, 7);\n  R0(c, d, e, a, b, 8);\n  R0(b, c, d, e, a, 9);\n  R0(a, b, c, d, e, 10);\n  R0(e, a, b, c, d, 11);\n  R0(d, e, a, b, c, 12);\n  R0(c, d, e, a, b, 13);\n  R0(b, c, d, e, a, 14);\n  R0(a, b, c, d, e, 15);\n  R1(e, a, b, c, d, 16);\n  R1(d, e, a, b, c, 17);\n  R1(c, d, e, a, b, 18);\n  R1(b, c, d, e, a, 19);\n  R2(a, b, c, d, e, 20);\n  R2(e, a, b, c, d, 21);\n  R2(d, e, a, b, c, 22);\n  R2(c, d, e, a, b, 23);\n  R2(b, c, d, e, a, 24);\n  R2(a, b, c, d, e, 25);\n  R2(e, a, b, c, d, 26);\n  R2(d, e, a, b, c, 27);\n  R2(c, d, e, a, b, 28);\n  R2(b, c, d, e, a, 29);\n  R2(a, b, c, d, e, 30);\n  R2(e, a, b, c, d, 31);\n  R2(d, e, a, b, c, 32);\n  R2(c, d, e, a, b, 33);\n  R2(b, c, d, e, a, 34);\n  R2(a, b, c, d, e, 35);\n  R2(e, a, b, c, d, 36);\n  R2(d, e, a, b, c, 37);\n  R2(c, d, e, a, b, 38);\n  R2(b, c, d, e, a, 39);\n  R3(a, b, c, d, e, 40);\n  R3(e, a, b, c, d, 41);\n  R3(d, e, a, b, c, 42);\n  R3(c, d, e, a, b, 43);\n  R3(b, c, d, e, a, 44);\n  R3(a, b, c, d, e, 45);\n  R3(e, a, b, c, d, 46);\n  R3(d, e, a, b, c, 47);\n  R3(c, d, e, a, b, 48);\n  R3(b, c, d, e, a, 49);\n  R3(a, b, c, d, e, 50);\n  R3(e, a, b, c, d, 51);\n  R3(d, e, a, b, c, 52);\n  R3(c, d, e, a, b, 53);\n  R3(b, c, d, e, a, 54);\n  R3(a, b, c, d, e, 55);\n  R3(e, a, b, c, d, 56);\n  R3(d, e, a, b, c, 57);\n  R3(c, d, e, a, b, 58);\n  R3(b, c, d, e, a, 59);\n  R4(a, b, c, d, e, 60);\n  R4(e, a, b, c, d, 61);\n  R4(d, e, a, b, c, 62);\n  R4(c, d, e, a, b, 63);\n  R4(b, c, d, e, a, 64);\n  R4(a, b, c, d, e, 65);\n  R4(e, a, b, c, d, 66);\n  R4(d, e, a, b, c, 67);\n  R4(c, d, e, a, b, 68);\n  R4(b, c, d, e, a, 69);\n  R4(a, b, c, d, e, 70);\n  R4(e, a, b, c, d, 71);\n  R4(d, e, a, b, c, 72);\n  R4(c, d, e, a, b, 73);\n  R4(b, c, d, e, a, 74);\n  R4(a, b, c, d, e, 75);\n  R4(e, a, b, c, d, 76);\n  R4(d, e, a, b, c, 77);\n  R4(c, d, e, a, b, 78);\n  R4(b, c, d, e, a, 79);\n  state[0] += a;\n  state[1] += b;\n  state[2] += c;\n  state[3] += d;\n  state[4] += e;\n  /* Erase working structures. The order of operations is important,\n   * used to ensure that compiler doesn't optimize those out. */\n  memset(block, 0, sizeof(block));\n  a = b = c = d = e = 0;\n  (void) a;\n  (void) b;\n  (void) c;\n  (void) d;\n  (void) e;\n}\n\nvoid cs_sha1_init(cs_sha1_ctx *context) {\n  context->state[0] = 0x67452301;\n  context->state[1] = 0xEFCDAB89;\n  context->state[2] = 0x98BADCFE;\n  context->state[3] = 0x10325476;\n  context->state[4] = 0xC3D2E1F0;\n  context->count[0] = context->count[1] = 0;\n}\n\nvoid cs_sha1_update(cs_sha1_ctx *context, const unsigned char *data,\n                    uint32_t len) {\n  uint32_t i, j;\n\n  j = context->count[0];\n  if ((context->count[0] += len << 3) < j) context->count[1]++;\n  context->count[1] += (len >> 29);\n  j = (j >> 3) & 63;\n  if ((j + len) > 63) {\n    memcpy(&context->buffer[j], data, (i = 64 - j));\n    cs_sha1_transform(context->state, context->buffer);\n    for (; i + 63 < len; i += 64) {\n      cs_sha1_transform(context->state, &data[i]);\n    }\n    j = 0;\n  } else\n    i = 0;\n  memcpy(&context->buffer[j], &data[i], len - i);\n}\n\nvoid cs_sha1_final(unsigned char digest[20], cs_sha1_ctx *context) {\n  unsigned i;\n  unsigned char finalcount[8], c;\n\n  for (i = 0; i < 8; i++) {\n    finalcount[i] = (unsigned char) ((context->count[(i >= 4 ? 0 : 1)] >>\n                                      ((3 - (i & 3)) * 8)) &\n                                     255);\n  }\n  c = 0200;\n  cs_sha1_update(context, &c, 1);\n  while ((context->count[0] & 504) != 448) {\n    c = 0000;\n    cs_sha1_update(context, &c, 1);\n  }\n  cs_sha1_update(context, finalcount, 8);\n  for (i = 0; i < 20; i++) {\n    digest[i] =\n        (unsigned char) ((context->state[i >> 2] >> ((3 - (i & 3)) * 8)) & 255);\n  }\n  memset(context, '\\0', sizeof(*context));\n  memset(&finalcount, '\\0', sizeof(finalcount));\n}\n\nvoid cs_hmac_sha1(const unsigned char *key, size_t keylen,\n                  const unsigned char *data, size_t datalen,\n                  unsigned char out[20]) {\n  cs_sha1_ctx ctx;\n  unsigned char buf1[64], buf2[64], tmp_key[20], i;\n\n  if (keylen > sizeof(buf1)) {\n    cs_sha1_init(&ctx);\n    cs_sha1_update(&ctx, key, keylen);\n    cs_sha1_final(tmp_key, &ctx);\n    key = tmp_key;\n    keylen = sizeof(tmp_key);\n  }\n\n  memset(buf1, 0, sizeof(buf1));\n  memset(buf2, 0, sizeof(buf2));\n  memcpy(buf1, key, keylen);\n  memcpy(buf2, key, keylen);\n\n  for (i = 0; i < sizeof(buf1); i++) {\n    buf1[i] ^= 0x36;\n    buf2[i] ^= 0x5c;\n  }\n\n  cs_sha1_init(&ctx);\n  cs_sha1_update(&ctx, buf1, sizeof(buf1));\n  cs_sha1_update(&ctx, data, datalen);\n  cs_sha1_final(out, &ctx);\n\n  cs_sha1_init(&ctx);\n  cs_sha1_update(&ctx, buf2, sizeof(buf2));\n  cs_sha1_update(&ctx, out, 20);\n  cs_sha1_final(out, &ctx);\n}\n\n#endif /* EXCLUDE_COMMON */\n#ifdef MG_MODULE_LINES\n#line 1 \"common/str_util.c\"\n#endif\n/*\n * Copyright (c) 2015 Cesanta Software Limited\n * All rights reserved\n */\n\n#ifndef EXCLUDE_COMMON\n\n/* Amalgamated: #include \"common/mg_mem.h\" */\n/* Amalgamated: #include \"common/platform.h\" */\n/* Amalgamated: #include \"common/str_util.h\" */\n\n#ifndef C_DISABLE_BUILTIN_SNPRINTF\n#define C_DISABLE_BUILTIN_SNPRINTF 0\n#endif\n\n/* Amalgamated: #include \"common/mg_mem.h\" */\n\nsize_t c_strnlen(const char *s, size_t maxlen) WEAK;\nsize_t c_strnlen(const char *s, size_t maxlen) {\n  size_t l = 0;\n  for (; l < maxlen && s[l] != '\\0'; l++) {\n  }\n  return l;\n}\n\n#define C_SNPRINTF_APPEND_CHAR(ch)       \\\n  do {                                   \\\n    if (i < (int) buf_size) buf[i] = ch; \\\n    i++;                                 \\\n  } while (0)\n\n#define C_SNPRINTF_FLAG_ZERO 1\n\n#if C_DISABLE_BUILTIN_SNPRINTF\nint c_vsnprintf(char *buf, size_t buf_size, const char *fmt, va_list ap) WEAK;\nint c_vsnprintf(char *buf, size_t buf_size, const char *fmt, va_list ap) {\n  return vsnprintf(buf, buf_size, fmt, ap);\n}\n#else\nstatic int c_itoa(char *buf, size_t buf_size, int64_t num, int base, int flags,\n                  int field_width) {\n  char tmp[40];\n  int i = 0, k = 0, neg = 0;\n\n  if (num < 0) {\n    neg++;\n    num = -num;\n  }\n\n  /* Print into temporary buffer - in reverse order */\n  do {\n    int rem = num % base;\n    if (rem < 10) {\n      tmp[k++] = '0' + rem;\n    } else {\n      tmp[k++] = 'a' + (rem - 10);\n    }\n    num /= base;\n  } while (num > 0);\n\n  /* Zero padding */\n  if (flags && C_SNPRINTF_FLAG_ZERO) {\n    while (k < field_width && k < (int) sizeof(tmp) - 1) {\n      tmp[k++] = '0';\n    }\n  }\n\n  /* And sign */\n  if (neg) {\n    tmp[k++] = '-';\n  }\n\n  /* Now output */\n  while (--k >= 0) {\n    C_SNPRINTF_APPEND_CHAR(tmp[k]);\n  }\n\n  return i;\n}\n\nint c_vsnprintf(char *buf, size_t buf_size, const char *fmt, va_list ap) WEAK;\nint c_vsnprintf(char *buf, size_t buf_size, const char *fmt, va_list ap) {\n  int ch, i = 0, len_mod, flags, precision, field_width;\n\n  while ((ch = *fmt++) != '\\0') {\n    if (ch != '%') {\n      C_SNPRINTF_APPEND_CHAR(ch);\n    } else {\n      /*\n       * Conversion specification:\n       *   zero or more flags (one of: # 0 - <space> + ')\n       *   an optional minimum  field  width (digits)\n       *   an  optional precision (. followed by digits, or *)\n       *   an optional length modifier (one of: hh h l ll L q j z t)\n       *   conversion specifier (one of: d i o u x X e E f F g G a A c s p n)\n       */\n      flags = field_width = precision = len_mod = 0;\n\n      /* Flags. only zero-pad flag is supported. */\n      if (*fmt == '0') {\n        flags |= C_SNPRINTF_FLAG_ZERO;\n      }\n\n      /* Field width */\n      while (*fmt >= '0' && *fmt <= '9') {\n        field_width *= 10;\n        field_width += *fmt++ - '0';\n      }\n      /* Dynamic field width */\n      if (*fmt == '*') {\n        field_width = va_arg(ap, int);\n        fmt++;\n      }\n\n      /* Precision */\n      if (*fmt == '.') {\n        fmt++;\n        if (*fmt == '*') {\n          precision = va_arg(ap, int);\n          fmt++;\n        } else {\n          while (*fmt >= '0' && *fmt <= '9') {\n            precision *= 10;\n            precision += *fmt++ - '0';\n          }\n        }\n      }\n\n      /* Length modifier */\n      switch (*fmt) {\n        case 'h':\n        case 'l':\n        case 'L':\n        case 'I':\n        case 'q':\n        case 'j':\n        case 'z':\n        case 't':\n          len_mod = *fmt++;\n          if (*fmt == 'h') {\n            len_mod = 'H';\n            fmt++;\n          }\n          if (*fmt == 'l') {\n            len_mod = 'q';\n            fmt++;\n          }\n          break;\n      }\n\n      ch = *fmt++;\n      if (ch == 's') {\n        const char *s = va_arg(ap, const char *); /* Always fetch parameter */\n        int j;\n        int pad = field_width - (precision >= 0 ? c_strnlen(s, precision) : 0);\n        for (j = 0; j < pad; j++) {\n          C_SNPRINTF_APPEND_CHAR(' ');\n        }\n\n        /* `s` may be NULL in case of %.*s */\n        if (s != NULL) {\n          /* Ignore negative and 0 precisions */\n          for (j = 0; (precision <= 0 || j < precision) && s[j] != '\\0'; j++) {\n            C_SNPRINTF_APPEND_CHAR(s[j]);\n          }\n        }\n      } else if (ch == 'c') {\n        ch = va_arg(ap, int); /* Always fetch parameter */\n        C_SNPRINTF_APPEND_CHAR(ch);\n      } else if (ch == 'd' && len_mod == 0) {\n        i += c_itoa(buf + i, buf_size - i, va_arg(ap, int), 10, flags,\n                    field_width);\n      } else if (ch == 'd' && len_mod == 'l') {\n        i += c_itoa(buf + i, buf_size - i, va_arg(ap, long), 10, flags,\n                    field_width);\n#ifdef SSIZE_MAX\n      } else if (ch == 'd' && len_mod == 'z') {\n        i += c_itoa(buf + i, buf_size - i, va_arg(ap, ssize_t), 10, flags,\n                    field_width);\n#endif\n      } else if (ch == 'd' && len_mod == 'q') {\n        i += c_itoa(buf + i, buf_size - i, va_arg(ap, int64_t), 10, flags,\n                    field_width);\n      } else if ((ch == 'x' || ch == 'u') && len_mod == 0) {\n        i += c_itoa(buf + i, buf_size - i, va_arg(ap, unsigned),\n                    ch == 'x' ? 16 : 10, flags, field_width);\n      } else if ((ch == 'x' || ch == 'u') && len_mod == 'l') {\n        i += c_itoa(buf + i, buf_size - i, va_arg(ap, unsigned long),\n                    ch == 'x' ? 16 : 10, flags, field_width);\n      } else if ((ch == 'x' || ch == 'u') && len_mod == 'z') {\n        i += c_itoa(buf + i, buf_size - i, va_arg(ap, size_t),\n                    ch == 'x' ? 16 : 10, flags, field_width);\n      } else if (ch == 'p') {\n        unsigned long num = (unsigned long) (uintptr_t) va_arg(ap, void *);\n        C_SNPRINTF_APPEND_CHAR('0');\n        C_SNPRINTF_APPEND_CHAR('x');\n        i += c_itoa(buf + i, buf_size - i, num, 16, flags, 0);\n      } else {\n#ifndef NO_LIBC\n        /*\n         * TODO(lsm): abort is not nice in a library, remove it\n         * Also, ESP8266 SDK doesn't have it\n         */\n        abort();\n#endif\n      }\n    }\n  }\n\n  /* Zero-terminate the result */\n  if (buf_size > 0) {\n    buf[i < (int) buf_size ? i : (int) buf_size - 1] = '\\0';\n  }\n\n  return i;\n}\n#endif\n\nint c_snprintf(char *buf, size_t buf_size, const char *fmt, ...) WEAK;\nint c_snprintf(char *buf, size_t buf_size, const char *fmt, ...) {\n  int result;\n  va_list ap;\n  va_start(ap, fmt);\n  result = c_vsnprintf(buf, buf_size, fmt, ap);\n  va_end(ap);\n  return result;\n}\n\n#ifdef _WIN32\nint to_wchar(const char *path, wchar_t *wbuf, size_t wbuf_len) {\n  int ret;\n  char buf[MAX_PATH * 2], buf2[MAX_PATH * 2], *p;\n\n  strncpy(buf, path, sizeof(buf));\n  buf[sizeof(buf) - 1] = '\\0';\n\n  /* Trim trailing slashes. Leave backslash for paths like \"X:\\\" */\n  p = buf + strlen(buf) - 1;\n  while (p > buf && p[-1] != ':' && (p[0] == '\\\\' || p[0] == '/')) *p-- = '\\0';\n\n  memset(wbuf, 0, wbuf_len * sizeof(wchar_t));\n  ret = MultiByteToWideChar(CP_UTF8, 0, buf, -1, wbuf, (int) wbuf_len);\n\n  /*\n   * Convert back to Unicode. If doubly-converted string does not match the\n   * original, something is fishy, reject.\n   */\n  WideCharToMultiByte(CP_UTF8, 0, wbuf, (int) wbuf_len, buf2, sizeof(buf2),\n                      NULL, NULL);\n  if (strcmp(buf, buf2) != 0) {\n    wbuf[0] = L'\\0';\n    ret = 0;\n  }\n\n  return ret;\n}\n#endif /* _WIN32 */\n\n/* The simplest O(mn) algorithm. Better implementation are GPLed */\nconst char *c_strnstr(const char *s, const char *find, size_t slen) WEAK;\nconst char *c_strnstr(const char *s, const char *find, size_t slen) {\n  size_t find_length = strlen(find);\n  size_t i;\n\n  for (i = 0; i < slen; i++) {\n    if (i + find_length > slen) {\n      return NULL;\n    }\n\n    if (strncmp(&s[i], find, find_length) == 0) {\n      return &s[i];\n    }\n  }\n\n  return NULL;\n}\n\n#if CS_ENABLE_STRDUP\nchar *strdup(const char *src) WEAK;\nchar *strdup(const char *src) {\n  size_t len = strlen(src) + 1;\n  char *ret = MG_MALLOC(len);\n  if (ret != NULL) {\n    strcpy(ret, src);\n  }\n  return ret;\n}\n#endif\n\nvoid cs_to_hex(char *to, const unsigned char *p, size_t len) WEAK;\nvoid cs_to_hex(char *to, const unsigned char *p, size_t len) {\n  static const char *hex = \"0123456789abcdef\";\n\n  for (; len--; p++) {\n    *to++ = hex[p[0] >> 4];\n    *to++ = hex[p[0] & 0x0f];\n  }\n  *to = '\\0';\n}\n\nstatic int fourbit(int ch) {\n  if (ch >= '0' && ch <= '9') {\n    return ch - '0';\n  } else if (ch >= 'a' && ch <= 'f') {\n    return ch - 'a' + 10;\n  } else if (ch >= 'A' && ch <= 'F') {\n    return ch - 'A' + 10;\n  }\n  return 0;\n}\n\nvoid cs_from_hex(char *to, const char *p, size_t len) WEAK;\nvoid cs_from_hex(char *to, const char *p, size_t len) {\n  size_t i;\n\n  for (i = 0; i < len; i += 2) {\n    *to++ = (fourbit(p[i]) << 4) + fourbit(p[i + 1]);\n  }\n  *to = '\\0';\n}\n\n#if CS_ENABLE_TO64\nint64_t cs_to64(const char *s) WEAK;\nint64_t cs_to64(const char *s) {\n  int64_t result = 0;\n  int64_t neg = 1;\n  while (*s && isspace((unsigned char) *s)) s++;\n  if (*s == '-') {\n    neg = -1;\n    s++;\n  }\n  while (isdigit((unsigned char) *s)) {\n    result *= 10;\n    result += (*s - '0');\n    s++;\n  }\n  return result * neg;\n}\n#endif\n\nstatic int str_util_lowercase(const char *s) {\n  return tolower(*(const unsigned char *) s);\n}\n\nint mg_ncasecmp(const char *s1, const char *s2, size_t len) WEAK;\nint mg_ncasecmp(const char *s1, const char *s2, size_t len) {\n  int diff = 0;\n\n  if (len > 0) do {\n      diff = str_util_lowercase(s1++) - str_util_lowercase(s2++);\n    } while (diff == 0 && s1[-1] != '\\0' && --len > 0);\n\n  return diff;\n}\n\nint mg_casecmp(const char *s1, const char *s2) WEAK;\nint mg_casecmp(const char *s1, const char *s2) {\n  return mg_ncasecmp(s1, s2, (size_t) ~0);\n}\n\nint mg_asprintf(char **buf, size_t size, const char *fmt, ...) WEAK;\nint mg_asprintf(char **buf, size_t size, const char *fmt, ...) {\n  int ret;\n  va_list ap;\n  va_start(ap, fmt);\n  ret = mg_avprintf(buf, size, fmt, ap);\n  va_end(ap);\n  return ret;\n}\n\nint mg_avprintf(char **buf, size_t size, const char *fmt, va_list ap) WEAK;\nint mg_avprintf(char **buf, size_t size, const char *fmt, va_list ap) {\n  va_list ap_copy;\n  int len;\n\n  va_copy(ap_copy, ap);\n  len = vsnprintf(*buf, size, fmt, ap_copy);\n  va_end(ap_copy);\n\n  if (len < 0) {\n    /* eCos and Windows are not standard-compliant and return -1 when\n     * the buffer is too small. Keep allocating larger buffers until we\n     * succeed or out of memory. */\n    *buf = NULL; /* LCOV_EXCL_START */\n    while (len < 0) {\n      MG_FREE(*buf);\n      size *= 2;\n      if ((*buf = (char *) MG_MALLOC(size)) == NULL) break;\n      va_copy(ap_copy, ap);\n      len = vsnprintf(*buf, size, fmt, ap_copy);\n      va_end(ap_copy);\n    }\n    /* LCOV_EXCL_STOP */\n  } else if (len >= (int) size) {\n    /* Standard-compliant code path. Allocate a buffer that is large enough. */\n    if ((*buf = (char *) MG_MALLOC(len + 1)) == NULL) {\n      len = -1; /* LCOV_EXCL_LINE */\n    } else {    /* LCOV_EXCL_LINE */\n      va_copy(ap_copy, ap);\n      len = vsnprintf(*buf, len + 1, fmt, ap_copy);\n      va_end(ap_copy);\n    }\n  }\n\n  return len;\n}\n\n#endif /* EXCLUDE_COMMON */\n#ifdef MG_MODULE_LINES\n#line 1 \"mongoose/src/tun.h\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#ifndef CS_MONGOOSE_SRC_TUN_H_\n#define CS_MONGOOSE_SRC_TUN_H_\n\n#if MG_ENABLE_TUN\n\n/* Amalgamated: #include \"mongoose/src/net.h\" */\n/* Amalgamated: #include \"common/mg_str.h\" */\n\n#ifndef MG_TUN_RECONNECT_INTERVAL\n#define MG_TUN_RECONNECT_INTERVAL 1\n#endif\n\n#define MG_TUN_PROTO_NAME \"mg_tun\"\n\n#define MG_TUN_DATA_FRAME 0x0\n#define MG_TUN_F_END_STREAM 0x1\n\n/*\n * MG TUN frame format is loosely based on HTTP/2.\n * However since the communication happens via WebSocket\n * there is no need to encode the frame length, since that's\n * solved by WebSocket framing.\n *\n * TODO(mkm): Detailed description of the protocol.\n */\nstruct mg_tun_frame {\n  uint8_t type;\n  uint8_t flags;\n  uint32_t stream_id; /* opaque stream identifier */\n  struct mg_str body;\n};\n\nstruct mg_tun_ssl_opts {\n#if MG_ENABLE_SSL\n  const char *ssl_cert;\n  const char *ssl_key;\n  const char *ssl_ca_cert;\n#else\n  int dummy; /* some compilers don't like empty structs */\n#endif\n};\n\nstruct mg_tun_client {\n  struct mg_mgr *mgr;\n  struct mg_iface *iface;\n  const char *disp_url;\n  struct mg_tun_ssl_opts ssl;\n\n  uint32_t last_stream_id; /* stream id of most recently accepted connection */\n\n  struct mg_connection *disp;\n  struct mg_connection *listener;\n  struct mg_connection *reconnect;\n};\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif /* __cplusplus */\n\nstruct mg_connection *mg_tun_bind_opt(struct mg_mgr *mgr,\n                                      const char *dispatcher,\n                                      MG_CB(mg_event_handler_t handler,\n                                            void *user_data),\n                                      struct mg_bind_opts opts);\n\nint mg_tun_parse_frame(void *data, size_t len, struct mg_tun_frame *frame);\n\nvoid mg_tun_send_frame(struct mg_connection *ws, uint32_t stream_id,\n                       uint8_t type, uint8_t flags, struct mg_str msg);\n\nvoid mg_tun_destroy_client(struct mg_tun_client *client);\n\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n\n#endif /* MG_ENABLE_TUN */\n\n#endif /* CS_MONGOOSE_SRC_TUN_H_ */\n#ifdef MG_MODULE_LINES\n#line 1 \"mongoose/src/net.c\"\n#endif\n/*\n * Copyright (c) 2014 Cesanta Software Limited\n * All rights reserved\n *\n * This software is dual-licensed: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation. For the terms of this\n * license, see <http://www.gnu.org/licenses/>.\n *\n * You are free to use this software under the terms of the GNU General\n * Public License, but WITHOUT ANY WARRANTY; without even the implied\n * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License for more details.\n *\n * Alternatively, you can license this software under a commercial\n * license, as set out in <https://www.cesanta.com/license>.\n */\n\n/* Amalgamated: #include \"common/cs_time.h\" */\n/* Amalgamated: #include \"mongoose/src/dns.h\" */\n/* Amalgamated: #include \"mongoose/src/internal.h\" */\n/* Amalgamated: #include \"mongoose/src/resolv.h\" */\n/* Amalgamated: #include \"mongoose/src/util.h\" */\n/* Amalgamated: #include \"mongoose/src/tun.h\" */\n\n#define MG_MAX_HOST_LEN 200\n\n#define MG_COPY_COMMON_CONNECTION_OPTIONS(dst, src) \\\n  memcpy(dst, src, sizeof(*dst));\n\n/* Which flags can be pre-set by the user at connection creation time. */\n#define _MG_ALLOWED_CONNECT_FLAGS_MASK                                   \\\n  (MG_F_USER_1 | MG_F_USER_2 | MG_F_USER_3 | MG_F_USER_4 | MG_F_USER_5 | \\\n   MG_F_USER_6 | MG_F_WEBSOCKET_NO_DEFRAG | MG_F_ENABLE_BROADCAST)\n/* Which flags should be modifiable by user's callbacks. */\n#define _MG_CALLBACK_MODIFIABLE_FLAGS_MASK                               \\\n  (MG_F_USER_1 | MG_F_USER_2 | MG_F_USER_3 | MG_F_USER_4 | MG_F_USER_5 | \\\n   MG_F_USER_6 | MG_F_WEBSOCKET_NO_DEFRAG | MG_F_SEND_AND_CLOSE |        \\\n   MG_F_CLOSE_IMMEDIATELY | MG_F_IS_WEBSOCKET | MG_F_DELETE_CHUNK)\n\n#ifndef intptr_t\n#define intptr_t long\n#endif\n\nMG_INTERNAL void mg_add_conn(struct mg_mgr *mgr, struct mg_connection *c) {\n  DBG((\"%p %p\", mgr, c));\n  c->mgr = mgr;\n  c->next = mgr->active_connections;\n  mgr->active_connections = c;\n  c->prev = NULL;\n  if (c->next != NULL) c->next->prev = c;\n  if (c->sock != INVALID_SOCKET) {\n    c->iface->vtable->add_conn(c);\n  }\n}\n\nMG_INTERNAL void mg_remove_conn(struct mg_connection *conn) {\n  if (conn->prev == NULL) conn->mgr->active_connections = conn->next;\n  if (conn->prev) conn->prev->next = conn->next;\n  if (conn->next) conn->next->prev = conn->prev;\n  conn->prev = conn->next = NULL;\n  conn->iface->vtable->remove_conn(conn);\n}\n\nMG_INTERNAL void mg_call(struct mg_connection *nc,\n                         mg_event_handler_t ev_handler, void *user_data, int ev,\n                         void *ev_data) {\n  if (ev_handler == NULL) {\n    /*\n     * If protocol handler is specified, call it. Otherwise, call user-specified\n     * event handler.\n     */\n    ev_handler = nc->proto_handler ? nc->proto_handler : nc->handler;\n  }\n  if (ev != MG_EV_POLL) {\n    DBG((\"%p %s ev=%d ev_data=%p flags=%lu rmbl=%d smbl=%d\", nc,\n         ev_handler == nc->handler ? \"user\" : \"proto\", ev, ev_data, nc->flags,\n         (int) nc->recv_mbuf.len, (int) nc->send_mbuf.len));\n  }\n\n#if !defined(NO_LIBC) && MG_ENABLE_HEXDUMP\n  /* LCOV_EXCL_START */\n  if (nc->mgr->hexdump_file != NULL && ev != MG_EV_POLL &&\n      ev != MG_EV_SEND /* handled separately */) {\n    if (ev == MG_EV_RECV) {\n      mg_hexdump_connection(nc, nc->mgr->hexdump_file, nc->recv_mbuf.buf,\n                            *(int *) ev_data, ev);\n    } else {\n      mg_hexdump_connection(nc, nc->mgr->hexdump_file, NULL, 0, ev);\n    }\n  }\n/* LCOV_EXCL_STOP */\n#endif\n  if (ev_handler != NULL) {\n    unsigned long flags_before = nc->flags;\n    size_t recv_mbuf_before = nc->recv_mbuf.len, recved;\n    ev_handler(nc, ev, ev_data MG_UD_ARG(user_data));\n    recved = (recv_mbuf_before - nc->recv_mbuf.len);\n    /* Prevent user handler from fiddling with system flags. */\n    if (ev_handler == nc->handler && nc->flags != flags_before) {\n      nc->flags = (flags_before & ~_MG_CALLBACK_MODIFIABLE_FLAGS_MASK) |\n                  (nc->flags & _MG_CALLBACK_MODIFIABLE_FLAGS_MASK);\n    }\n    if (recved > 0 && !(nc->flags & MG_F_UDP)) {\n      nc->iface->vtable->recved(nc, recved);\n    }\n  }\n  if (ev != MG_EV_POLL) {\n    DBG((\"%p after %s flags=%lu rmbl=%d smbl=%d\", nc,\n         ev_handler == nc->handler ? \"user\" : \"proto\", nc->flags,\n         (int) nc->recv_mbuf.len, (int) nc->send_mbuf.len));\n  }\n#if !MG_ENABLE_CALLBACK_USERDATA\n  (void) user_data;\n#endif\n}\n\nvoid mg_if_timer(struct mg_connection *c, double now) {\n  if (c->ev_timer_time > 0 && now >= c->ev_timer_time) {\n    double old_value = c->ev_timer_time;\n    mg_call(c, NULL, c->user_data, MG_EV_TIMER, &now);\n    /*\n     * To prevent timer firing all the time, reset the timer after delivery.\n     * However, in case user sets it to new value, do not reset.\n     */\n    if (c->ev_timer_time == old_value) {\n      c->ev_timer_time = 0;\n    }\n  }\n}\n\nvoid mg_if_poll(struct mg_connection *nc, time_t now) {\n  if (!(nc->flags & MG_F_SSL) || (nc->flags & MG_F_SSL_HANDSHAKE_DONE)) {\n    mg_call(nc, NULL, nc->user_data, MG_EV_POLL, &now);\n  }\n}\n\nstatic void mg_destroy_conn(struct mg_connection *conn, int destroy_if) {\n  if (destroy_if) conn->iface->vtable->destroy_conn(conn);\n  if (conn->proto_data != NULL && conn->proto_data_destructor != NULL) {\n    conn->proto_data_destructor(conn->proto_data);\n  }\n#if MG_ENABLE_SSL\n  mg_ssl_if_conn_free(conn);\n#endif\n  mbuf_free(&conn->recv_mbuf);\n  mbuf_free(&conn->send_mbuf);\n\n  memset(conn, 0, sizeof(*conn));\n  MG_FREE(conn);\n}\n\nvoid mg_close_conn(struct mg_connection *conn) {\n  DBG((\"%p %lu %d\", conn, conn->flags, conn->sock));\n#if MG_ENABLE_SSL\n  if (conn->flags & MG_F_SSL_HANDSHAKE_DONE) {\n    mg_ssl_if_conn_close_notify(conn);\n  }\n#endif\n  mg_remove_conn(conn);\n  conn->iface->vtable->destroy_conn(conn);\n  mg_call(conn, NULL, conn->user_data, MG_EV_CLOSE, NULL);\n  mg_destroy_conn(conn, 0 /* destroy_if */);\n}\n\nvoid mg_mgr_init(struct mg_mgr *m, void *user_data) {\n  struct mg_mgr_init_opts opts;\n  memset(&opts, 0, sizeof(opts));\n  mg_mgr_init_opt(m, user_data, opts);\n}\n\nvoid mg_mgr_init_opt(struct mg_mgr *m, void *user_data,\n                     struct mg_mgr_init_opts opts) {\n  memset(m, 0, sizeof(*m));\n#if MG_ENABLE_BROADCAST\n  m->ctl[0] = m->ctl[1] = INVALID_SOCKET;\n#endif\n  m->user_data = user_data;\n\n#ifdef _WIN32\n  {\n    WSADATA data;\n    WSAStartup(MAKEWORD(2, 2), &data);\n  }\n#elif defined(__unix__)\n  /* Ignore SIGPIPE signal, so if client cancels the request, it\n   * won't kill the whole process. */\n  signal(SIGPIPE, SIG_IGN);\n#endif\n\n#if MG_ENABLE_SSL\n  {\n    static int init_done;\n    if (!init_done) {\n      mg_ssl_if_init();\n      init_done++;\n    }\n  }\n#endif\n  {\n    int i;\n    if (opts.num_ifaces == 0) {\n      opts.num_ifaces = mg_num_ifaces;\n      opts.ifaces = mg_ifaces;\n    }\n    if (opts.main_iface != NULL) {\n      opts.ifaces[MG_MAIN_IFACE] = opts.main_iface;\n    }\n    m->num_ifaces = opts.num_ifaces;\n    m->ifaces =\n        (struct mg_iface **) MG_MALLOC(sizeof(*m->ifaces) * opts.num_ifaces);\n    for (i = 0; i < mg_num_ifaces; i++) {\n      m->ifaces[i] = mg_if_create_iface(opts.ifaces[i], m);\n      m->ifaces[i]->vtable->init(m->ifaces[i]);\n    }\n  }\n  if (opts.nameserver != NULL) {\n    m->nameserver = strdup(opts.nameserver);\n  }\n  DBG((\"==================================\"));\n  DBG((\"init mgr=%p\", m));\n}\n\n#if MG_ENABLE_JAVASCRIPT\nstatic enum v7_err mg_send_js(struct v7 *v7, v7_val_t *res) {\n  v7_val_t arg0 = v7_arg(v7, 0);\n  v7_val_t arg1 = v7_arg(v7, 1);\n  struct mg_connection *c = (struct mg_connection *) v7_get_ptr(v7, arg0);\n  size_t len = 0;\n\n  if (v7_is_string(arg1)) {\n    const char *data = v7_get_string(v7, &arg1, &len);\n    mg_send(c, data, len);\n  }\n\n  *res = v7_mk_number(v7, len);\n\n  return V7_OK;\n}\n\nenum v7_err mg_enable_javascript(struct mg_mgr *m, struct v7 *v7,\n                                 const char *init_file_name) {\n  v7_val_t v;\n  m->v7 = v7;\n  v7_set_method(v7, v7_get_global(v7), \"mg_send\", mg_send_js);\n  return v7_exec_file(v7, init_file_name, &v);\n}\n#endif\n\nvoid mg_mgr_free(struct mg_mgr *m) {\n  struct mg_connection *conn, *tmp_conn;\n\n  DBG((\"%p\", m));\n  if (m == NULL) return;\n  /* Do one last poll, see https://github.com/cesanta/mongoose/issues/286 */\n  mg_mgr_poll(m, 0);\n\n#if MG_ENABLE_BROADCAST\n  if (m->ctl[0] != INVALID_SOCKET) closesocket(m->ctl[0]);\n  if (m->ctl[1] != INVALID_SOCKET) closesocket(m->ctl[1]);\n  m->ctl[0] = m->ctl[1] = INVALID_SOCKET;\n#endif\n\n  for (conn = m->active_connections; conn != NULL; conn = tmp_conn) {\n    tmp_conn = conn->next;\n    mg_close_conn(conn);\n  }\n\n  {\n    int i;\n    for (i = 0; i < m->num_ifaces; i++) {\n      m->ifaces[i]->vtable->free(m->ifaces[i]);\n      MG_FREE(m->ifaces[i]);\n    }\n    MG_FREE(m->ifaces);\n  }\n\n  MG_FREE((char *) m->nameserver);\n}\n\ntime_t mg_mgr_poll(struct mg_mgr *m, int timeout_ms) {\n  int i;\n  time_t now = 0; /* oh GCC, seriously ? */\n\n  if (m->num_ifaces == 0) {\n    LOG(LL_ERROR, (\"cannot poll: no interfaces\"));\n    return 0;\n  }\n\n  for (i = 0; i < m->num_ifaces; i++) {\n    now = m->ifaces[i]->vtable->poll(m->ifaces[i], timeout_ms);\n  }\n  return now;\n}\n\nint mg_vprintf(struct mg_connection *nc, const char *fmt, va_list ap) {\n  char mem[MG_VPRINTF_BUFFER_SIZE], *buf = mem;\n  int len;\n\n  if ((len = mg_avprintf(&buf, sizeof(mem), fmt, ap)) > 0) {\n    mg_send(nc, buf, len);\n  }\n  if (buf != mem && buf != NULL) {\n    MG_FREE(buf); /* LCOV_EXCL_LINE */\n  }               /* LCOV_EXCL_LINE */\n\n  return len;\n}\n\nint mg_printf(struct mg_connection *conn, const char *fmt, ...) {\n  int len;\n  va_list ap;\n  va_start(ap, fmt);\n  len = mg_vprintf(conn, fmt, ap);\n  va_end(ap);\n  return len;\n}\n\n#if MG_ENABLE_SYNC_RESOLVER\n/* TODO(lsm): use non-blocking resolver */\nstatic int mg_resolve2(const char *host, struct in_addr *ina) {\n#if MG_ENABLE_GETADDRINFO\n  int rv = 0;\n  struct addrinfo hints, *servinfo, *p;\n  struct sockaddr_in *h = NULL;\n  memset(&hints, 0, sizeof hints);\n  hints.ai_family = AF_INET;\n  hints.ai_socktype = SOCK_STREAM;\n  if ((rv = getaddrinfo(host, NULL, NULL, &servinfo)) != 0) {\n    DBG((\"getaddrinfo(%s) failed: %s\", host, strerror(mg_get_errno())));\n    return 0;\n  }\n  for (p = servinfo; p != NULL; p = p->ai_next) {\n    memcpy(&h, &p->ai_addr, sizeof(struct sockaddr_in *));\n    memcpy(ina, &h->sin_addr, sizeof(ina));\n  }\n  freeaddrinfo(servinfo);\n  return 1;\n#else\n  struct hostent *he;\n  if ((he = gethostbyname(host)) == NULL) {\n    DBG((\"gethostbyname(%s) failed: %s\", host, strerror(mg_get_errno())));\n  } else {\n    memcpy(ina, he->h_addr_list[0], sizeof(*ina));\n    return 1;\n  }\n  return 0;\n#endif /* MG_ENABLE_GETADDRINFO */\n}\n\nint mg_resolve(const char *host, char *buf, size_t n) {\n  struct in_addr ad;\n  return mg_resolve2(host, &ad) ? snprintf(buf, n, \"%s\", inet_ntoa(ad)) : 0;\n}\n#endif /* MG_ENABLE_SYNC_RESOLVER */\n\nMG_INTERNAL struct mg_connection *mg_create_connection_base(\n    struct mg_mgr *mgr, mg_event_handler_t callback,\n    struct mg_add_sock_opts opts) {\n  struct mg_connection *conn;\n\n  if ((conn = (struct mg_connection *) MG_CALLOC(1, sizeof(*conn))) != NULL) {\n    conn->sock = INVALID_SOCKET;\n    conn->handler = callback;\n    conn->mgr = mgr;\n    conn->last_io_time = (time_t) mg_time();\n    conn->iface =\n        (opts.iface != NULL ? opts.iface : mgr->ifaces[MG_MAIN_IFACE]);\n    conn->flags = opts.flags & _MG_ALLOWED_CONNECT_FLAGS_MASK;\n    conn->user_data = opts.user_data;\n    /*\n     * SIZE_MAX is defined as a long long constant in\n     * system headers on some platforms and so it\n     * doesn't compile with pedantic ansi flags.\n     */\n    conn->recv_mbuf_limit = ~0;\n  } else {\n    MG_SET_PTRPTR(opts.error_string, \"failed to create connection\");\n  }\n\n  return conn;\n}\n\nMG_INTERNAL struct mg_connection *mg_create_connection(\n    struct mg_mgr *mgr, mg_event_handler_t callback,\n    struct mg_add_sock_opts opts) {\n  struct mg_connection *conn = mg_create_connection_base(mgr, callback, opts);\n\n  if (conn != NULL && !conn->iface->vtable->create_conn(conn)) {\n    MG_FREE(conn);\n    conn = NULL;\n  }\n  if (conn == NULL) {\n    MG_SET_PTRPTR(opts.error_string, \"failed to init connection\");\n  }\n\n  return conn;\n}\n\n/*\n * Address format: [PROTO://][HOST]:PORT\n *\n * HOST could be IPv4/IPv6 address or a host name.\n * `host` is a destination buffer to hold parsed HOST part. Should be at least\n * MG_MAX_HOST_LEN bytes long.\n * `proto` is a returned socket type, either SOCK_STREAM or SOCK_DGRAM\n *\n * Return:\n *   -1   on parse error\n *    0   if HOST needs DNS lookup\n *   >0   length of the address string\n */\nMG_INTERNAL int mg_parse_address(const char *str, union socket_address *sa,\n                                 int *proto, char *host, size_t host_len) {\n  unsigned int a, b, c, d, port = 0;\n  int ch, len = 0;\n#if MG_ENABLE_IPV6\n  char buf[100];\n#endif\n\n  /*\n   * MacOS needs that. If we do not zero it, subsequent bind() will fail.\n   * Also, all-zeroes in the socket address means binding to all addresses\n   * for both IPv4 and IPv6 (INADDR_ANY and IN6ADDR_ANY_INIT).\n   */\n  memset(sa, 0, sizeof(*sa));\n  sa->sin.sin_family = AF_INET;\n\n  *proto = SOCK_STREAM;\n\n  if (strncmp(str, \"udp://\", 6) == 0) {\n    str += 6;\n    *proto = SOCK_DGRAM;\n  } else if (strncmp(str, \"tcp://\", 6) == 0) {\n    str += 6;\n  }\n\n  if (sscanf(str, \"%u.%u.%u.%u:%u%n\", &a, &b, &c, &d, &port, &len) == 5) {\n    /* Bind to a specific IPv4 address, e.g. 192.168.1.5:8080 */\n    sa->sin.sin_addr.s_addr =\n        htonl(((uint32_t) a << 24) | ((uint32_t) b << 16) | c << 8 | d);\n    sa->sin.sin_port = htons((uint16_t) port);\n#if MG_ENABLE_IPV6\n  } else if (sscanf(str, \"[%99[^]]]:%u%n\", buf, &port, &len) == 2 &&\n             inet_pton(AF_INET6, buf, &sa->sin6.sin6_addr)) {\n    /* IPv6 address, e.g. [3ffe:2a00:100:7031::1]:8080 */\n    sa->sin6.sin6_family = AF_INET6;\n    sa->sin.sin_port = htons((uint16_t) port);\n#endif\n#if MG_ENABLE_ASYNC_RESOLVER\n  } else if (strlen(str) < host_len &&\n             sscanf(str, \"%[^ :]:%u%n\", host, &port, &len) == 2) {\n    sa->sin.sin_port = htons((uint16_t) port);\n    if (mg_resolve_from_hosts_file(host, sa) != 0) {\n      /*\n       * if resolving from hosts file failed and the host\n       * we are trying to resolve is `localhost` - we should\n       * try to resolve it using `gethostbyname` and do not try\n       * to resolve it via DNS server if gethostbyname has failed too\n       */\n      if (mg_ncasecmp(host, \"localhost\", 9) != 0) {\n        return 0;\n      }\n\n#if MG_ENABLE_SYNC_RESOLVER\n      if (!mg_resolve2(host, &sa->sin.sin_addr)) {\n        return -1;\n      }\n#else\n      return -1;\n#endif\n    }\n#endif\n  } else if (sscanf(str, \":%u%n\", &port, &len) == 1 ||\n             sscanf(str, \"%u%n\", &port, &len) == 1) {\n    /* If only port is specified, bind to IPv4, INADDR_ANY */\n    sa->sin.sin_port = htons((uint16_t) port);\n  } else {\n    return -1;\n  }\n\n  /* Required for MG_ENABLE_ASYNC_RESOLVER=0 */\n  (void) host;\n  (void) host_len;\n\n  ch = str[len]; /* Character that follows the address */\n  return port < 0xffffUL && (ch == '\\0' || ch == ',' || isspace(ch)) ? len : -1;\n}\n\nstruct mg_connection *mg_if_accept_new_conn(struct mg_connection *lc) {\n  struct mg_add_sock_opts opts;\n  struct mg_connection *nc;\n  memset(&opts, 0, sizeof(opts));\n  nc = mg_create_connection(lc->mgr, lc->handler, opts);\n  if (nc == NULL) return NULL;\n  nc->listener = lc;\n  nc->proto_handler = lc->proto_handler;\n  nc->user_data = lc->user_data;\n  nc->recv_mbuf_limit = lc->recv_mbuf_limit;\n  nc->iface = lc->iface;\n  if (lc->flags & MG_F_SSL) nc->flags |= MG_F_SSL;\n  mg_add_conn(nc->mgr, nc);\n  DBG((\"%p %p %d %d\", lc, nc, nc->sock, (int) nc->flags));\n  return nc;\n}\n\nvoid mg_if_accept_tcp_cb(struct mg_connection *nc, union socket_address *sa,\n                         size_t sa_len) {\n  (void) sa_len;\n  nc->sa = *sa;\n  mg_call(nc, NULL, nc->user_data, MG_EV_ACCEPT, &nc->sa);\n}\n\nvoid mg_send(struct mg_connection *nc, const void *buf, int len) {\n  nc->last_io_time = (time_t) mg_time();\n  if (nc->flags & MG_F_UDP) {\n    nc->iface->vtable->udp_send(nc, buf, len);\n  } else {\n    nc->iface->vtable->tcp_send(nc, buf, len);\n  }\n#if !defined(NO_LIBC) && MG_ENABLE_HEXDUMP\n  if (nc->mgr && nc->mgr->hexdump_file != NULL) {\n    mg_hexdump_connection(nc, nc->mgr->hexdump_file, buf, len, MG_EV_SEND);\n  }\n#endif\n}\n\nvoid mg_if_sent_cb(struct mg_connection *nc, int num_sent) {\n  if (num_sent < 0) {\n    nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n  }\n  mg_call(nc, NULL, nc->user_data, MG_EV_SEND, &num_sent);\n}\n\nMG_INTERNAL void mg_recv_common(struct mg_connection *nc, void *buf, int len,\n                                int own) {\n  DBG((\"%p %d %u\", nc, len, (unsigned int) nc->recv_mbuf.len));\n  if (nc->flags & MG_F_CLOSE_IMMEDIATELY) {\n    DBG((\"%p discarded %d bytes\", nc, len));\n    /*\n     * This connection will not survive next poll. Do not deliver events,\n     * send data to /dev/null without acking.\n     */\n    if (own) {\n      MG_FREE(buf);\n    }\n    return;\n  }\n  nc->last_io_time = (time_t) mg_time();\n  if (!own) {\n    mbuf_append(&nc->recv_mbuf, buf, len);\n  } else if (nc->recv_mbuf.len == 0) {\n    /* Adopt buf as recv_mbuf's backing store. */\n    mbuf_free(&nc->recv_mbuf);\n    nc->recv_mbuf.buf = (char *) buf;\n    nc->recv_mbuf.size = nc->recv_mbuf.len = len;\n  } else {\n    mbuf_append(&nc->recv_mbuf, buf, len);\n    MG_FREE(buf);\n  }\n  mg_call(nc, NULL, nc->user_data, MG_EV_RECV, &len);\n}\n\nvoid mg_if_recv_tcp_cb(struct mg_connection *nc, void *buf, int len, int own) {\n  mg_recv_common(nc, buf, len, own);\n}\n\nvoid mg_if_recv_udp_cb(struct mg_connection *nc, void *buf, int len,\n                       union socket_address *sa, size_t sa_len) {\n  assert(nc->flags & MG_F_UDP);\n  DBG((\"%p %u\", nc, (unsigned int) len));\n  if (nc->flags & MG_F_LISTENING) {\n    struct mg_connection *lc = nc;\n    /*\n     * Do we have an existing connection for this source?\n     * This is very inefficient for long connection lists.\n     */\n    for (nc = mg_next(lc->mgr, NULL); nc != NULL; nc = mg_next(lc->mgr, nc)) {\n      if (memcmp(&nc->sa.sa, &sa->sa, sa_len) == 0 && nc->listener == lc) {\n        break;\n      }\n    }\n    if (nc == NULL) {\n      struct mg_add_sock_opts opts;\n      memset(&opts, 0, sizeof(opts));\n      /* Create fake connection w/out sock initialization */\n      nc = mg_create_connection_base(lc->mgr, lc->handler, opts);\n      if (nc != NULL) {\n        nc->sock = lc->sock;\n        nc->listener = lc;\n        nc->sa = *sa;\n        nc->proto_handler = lc->proto_handler;\n        nc->user_data = lc->user_data;\n        nc->recv_mbuf_limit = lc->recv_mbuf_limit;\n        nc->flags = MG_F_UDP;\n        /*\n         * Long-lived UDP \"connections\" i.e. interactions that involve more\n         * than one request and response are rare, most are transactional:\n         * response is sent and the \"connection\" is closed. Or - should be.\n         * But users (including ourselves) tend to forget about that part,\n         * because UDP is connectionless and one does not think about\n         * processing a UDP request as handling a connection that needs to be\n         * closed. Thus, we begin with SEND_AND_CLOSE flag set, which should\n         * be a reasonable default for most use cases, but it is possible to\n         * turn it off the connection should be kept alive after processing.\n         */\n        nc->flags |= MG_F_SEND_AND_CLOSE;\n        mg_add_conn(lc->mgr, nc);\n        mg_call(nc, NULL, nc->user_data, MG_EV_ACCEPT, &nc->sa);\n      } else {\n        DBG((\"OOM\"));\n        /* No return here, we still need to drop on the floor */\n      }\n    }\n  }\n  if (nc != NULL) {\n    mg_recv_common(nc, buf, len, 1);\n  } else {\n    /* Drop on the floor. */\n    MG_FREE(buf);\n    nc->iface->vtable->recved(nc, len);\n  }\n}\n\n/*\n * Schedules an async connect for a resolved address and proto.\n * Called from two places: `mg_connect_opt()` and from async resolver.\n * When called from the async resolver, it must trigger `MG_EV_CONNECT` event\n * with a failure flag to indicate connection failure.\n */\nMG_INTERNAL struct mg_connection *mg_do_connect(struct mg_connection *nc,\n                                                int proto,\n                                                union socket_address *sa) {\n  DBG((\"%p %s://%s:%hu\", nc, proto == SOCK_DGRAM ? \"udp\" : \"tcp\",\n       inet_ntoa(sa->sin.sin_addr), ntohs(sa->sin.sin_port)));\n\n  nc->flags |= MG_F_CONNECTING;\n  if (proto == SOCK_DGRAM) {\n    nc->iface->vtable->connect_udp(nc);\n  } else {\n    nc->iface->vtable->connect_tcp(nc, sa);\n  }\n  mg_add_conn(nc->mgr, nc);\n  return nc;\n}\n\nvoid mg_if_connect_cb(struct mg_connection *nc, int err) {\n  DBG((\"%p connect, err=%d\", nc, err));\n  nc->flags &= ~MG_F_CONNECTING;\n  if (err != 0) {\n    nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n  }\n  mg_call(nc, NULL, nc->user_data, MG_EV_CONNECT, &err);\n}\n\n#if MG_ENABLE_ASYNC_RESOLVER\n/*\n * Callback for the async resolver on mg_connect_opt() call.\n * Main task of this function is to trigger MG_EV_CONNECT event with\n *    either failure (and dealloc the connection)\n *    or success (and proceed with connect()\n */\nstatic void resolve_cb(struct mg_dns_message *msg, void *data,\n                       enum mg_resolve_err e) {\n  struct mg_connection *nc = (struct mg_connection *) data;\n  int i;\n  int failure = -1;\n\n  nc->flags &= ~MG_F_RESOLVING;\n  if (msg != NULL) {\n    /*\n     * Take the first DNS A answer and run...\n     */\n    for (i = 0; i < msg->num_answers; i++) {\n      if (msg->answers[i].rtype == MG_DNS_A_RECORD) {\n        /*\n         * Async resolver guarantees that there is at least one answer.\n         * TODO(lsm): handle IPv6 answers too\n         */\n        mg_dns_parse_record_data(msg, &msg->answers[i], &nc->sa.sin.sin_addr,\n                                 4);\n        mg_do_connect(nc, nc->flags & MG_F_UDP ? SOCK_DGRAM : SOCK_STREAM,\n                      &nc->sa);\n        return;\n      }\n    }\n  }\n\n  if (e == MG_RESOLVE_TIMEOUT) {\n    double now = mg_time();\n    mg_call(nc, NULL, nc->user_data, MG_EV_TIMER, &now);\n  }\n\n  /*\n   * If we get there was no MG_DNS_A_RECORD in the answer\n   */\n  mg_call(nc, NULL, nc->user_data, MG_EV_CONNECT, &failure);\n  mg_call(nc, NULL, nc->user_data, MG_EV_CLOSE, NULL);\n  mg_destroy_conn(nc, 1 /* destroy_if */);\n}\n#endif\n\nstruct mg_connection *mg_connect(struct mg_mgr *mgr, const char *address,\n                                 MG_CB(mg_event_handler_t callback,\n                                       void *user_data)) {\n  struct mg_connect_opts opts;\n  memset(&opts, 0, sizeof(opts));\n  return mg_connect_opt(mgr, address, MG_CB(callback, user_data), opts);\n}\n\nstruct mg_connection *mg_connect_opt(struct mg_mgr *mgr, const char *address,\n                                     MG_CB(mg_event_handler_t callback,\n                                           void *user_data),\n                                     struct mg_connect_opts opts) {\n  struct mg_connection *nc = NULL;\n  int proto, rc;\n  struct mg_add_sock_opts add_sock_opts;\n  char host[MG_MAX_HOST_LEN];\n\n  MG_COPY_COMMON_CONNECTION_OPTIONS(&add_sock_opts, &opts);\n\n  if ((nc = mg_create_connection(mgr, callback, add_sock_opts)) == NULL) {\n    return NULL;\n  }\n\n  if ((rc = mg_parse_address(address, &nc->sa, &proto, host, sizeof(host))) <\n      0) {\n    /* Address is malformed */\n    MG_SET_PTRPTR(opts.error_string, \"cannot parse address\");\n    mg_destroy_conn(nc, 1 /* destroy_if */);\n    return NULL;\n  }\n\n  nc->flags |= opts.flags & _MG_ALLOWED_CONNECT_FLAGS_MASK;\n  nc->flags |= (proto == SOCK_DGRAM) ? MG_F_UDP : 0;\n#if MG_ENABLE_CALLBACK_USERDATA\n  nc->user_data = user_data;\n#else\n  nc->user_data = opts.user_data;\n#endif\n\n#if MG_ENABLE_SSL\n  DBG((\"%p %s %s,%s,%s\", nc, address, (opts.ssl_cert ? opts.ssl_cert : \"-\"),\n       (opts.ssl_key ? opts.ssl_key : \"-\"),\n       (opts.ssl_ca_cert ? opts.ssl_ca_cert : \"-\")));\n\n  if (opts.ssl_cert != NULL || opts.ssl_ca_cert != NULL ||\n      opts.ssl_psk_identity != NULL) {\n    const char *err_msg = NULL;\n    struct mg_ssl_if_conn_params params;\n    if (nc->flags & MG_F_UDP) {\n      MG_SET_PTRPTR(opts.error_string, \"SSL for UDP is not supported\");\n      mg_destroy_conn(nc, 1 /* destroy_if */);\n      return NULL;\n    }\n    memset(&params, 0, sizeof(params));\n    params.cert = opts.ssl_cert;\n    params.key = opts.ssl_key;\n    params.ca_cert = opts.ssl_ca_cert;\n    params.cipher_suites = opts.ssl_cipher_suites;\n    params.psk_identity = opts.ssl_psk_identity;\n    params.psk_key = opts.ssl_psk_key;\n    if (opts.ssl_ca_cert != NULL) {\n      if (opts.ssl_server_name != NULL) {\n        if (strcmp(opts.ssl_server_name, \"*\") != 0) {\n          params.server_name = opts.ssl_server_name;\n        }\n      } else if (rc == 0) { /* If it's a DNS name, use host. */\n        params.server_name = host;\n      }\n    }\n    if (mg_ssl_if_conn_init(nc, &params, &err_msg) != MG_SSL_OK) {\n      MG_SET_PTRPTR(opts.error_string, err_msg);\n      mg_destroy_conn(nc, 1 /* destroy_if */);\n      return NULL;\n    }\n    nc->flags |= MG_F_SSL;\n  }\n#endif /* MG_ENABLE_SSL */\n\n  if (rc == 0) {\n#if MG_ENABLE_ASYNC_RESOLVER\n    /*\n     * DNS resolution is required for host.\n     * mg_parse_address() fills port in nc->sa, which we pass to resolve_cb()\n     */\n    struct mg_connection *dns_conn = NULL;\n    struct mg_resolve_async_opts o;\n    memset(&o, 0, sizeof(o));\n    o.dns_conn = &dns_conn;\n    o.nameserver = opts.nameserver;\n    if (mg_resolve_async_opt(nc->mgr, host, MG_DNS_A_RECORD, resolve_cb, nc,\n                             o) != 0) {\n      MG_SET_PTRPTR(opts.error_string, \"cannot schedule DNS lookup\");\n      mg_destroy_conn(nc, 1 /* destroy_if */);\n      return NULL;\n    }\n    nc->priv_2 = dns_conn;\n    nc->flags |= MG_F_RESOLVING;\n    return nc;\n#else\n    MG_SET_PTRPTR(opts.error_string, \"Resolver is disabled\");\n    mg_destroy_conn(nc, 1 /* destroy_if */);\n    return NULL;\n#endif\n  } else {\n    /* Address is parsed and resolved to IP. proceed with connect() */\n    return mg_do_connect(nc, proto, &nc->sa);\n  }\n}\n\nstruct mg_connection *mg_bind(struct mg_mgr *srv, const char *address,\n                              MG_CB(mg_event_handler_t event_handler,\n                                    void *user_data)) {\n  struct mg_bind_opts opts;\n  memset(&opts, 0, sizeof(opts));\n  return mg_bind_opt(srv, address, MG_CB(event_handler, user_data), opts);\n}\n\nstruct mg_connection *mg_bind_opt(struct mg_mgr *mgr, const char *address,\n                                  MG_CB(mg_event_handler_t callback,\n                                        void *user_data),\n                                  struct mg_bind_opts opts) {\n  union socket_address sa;\n  struct mg_connection *nc = NULL;\n  int proto, rc;\n  struct mg_add_sock_opts add_sock_opts;\n  char host[MG_MAX_HOST_LEN];\n\n  MG_COPY_COMMON_CONNECTION_OPTIONS(&add_sock_opts, &opts);\n\n#if MG_ENABLE_TUN\n  if (mg_strncmp(mg_mk_str(address), mg_mk_str(\"ws://\"), 5) == 0 ||\n      mg_strncmp(mg_mk_str(address), mg_mk_str(\"wss://\"), 6) == 0) {\n    return mg_tun_bind_opt(mgr, address, MG_CB(callback, user_data), opts);\n  }\n#endif\n\n  if (mg_parse_address(address, &sa, &proto, host, sizeof(host)) <= 0) {\n    MG_SET_PTRPTR(opts.error_string, \"cannot parse address\");\n    return NULL;\n  }\n\n  nc = mg_create_connection(mgr, callback, add_sock_opts);\n  if (nc == NULL) {\n    return NULL;\n  }\n\n  nc->sa = sa;\n  nc->flags |= MG_F_LISTENING;\n  if (proto == SOCK_DGRAM) nc->flags |= MG_F_UDP;\n\n#if MG_ENABLE_SSL\n  DBG((\"%p %s %s,%s,%s\", nc, address, (opts.ssl_cert ? opts.ssl_cert : \"-\"),\n       (opts.ssl_key ? opts.ssl_key : \"-\"),\n       (opts.ssl_ca_cert ? opts.ssl_ca_cert : \"-\")));\n\n  if (opts.ssl_cert != NULL || opts.ssl_ca_cert != NULL) {\n    const char *err_msg = NULL;\n    struct mg_ssl_if_conn_params params;\n    if (nc->flags & MG_F_UDP) {\n      MG_SET_PTRPTR(opts.error_string, \"SSL for UDP is not supported\");\n      mg_destroy_conn(nc, 1 /* destroy_if */);\n      return NULL;\n    }\n    memset(&params, 0, sizeof(params));\n    params.cert = opts.ssl_cert;\n    params.key = opts.ssl_key;\n    params.ca_cert = opts.ssl_ca_cert;\n    params.cipher_suites = opts.ssl_cipher_suites;\n    if (mg_ssl_if_conn_init(nc, &params, &err_msg) != MG_SSL_OK) {\n      MG_SET_PTRPTR(opts.error_string, err_msg);\n      mg_destroy_conn(nc, 1 /* destroy_if */);\n      return NULL;\n    }\n    nc->flags |= MG_F_SSL;\n  }\n#endif /* MG_ENABLE_SSL */\n\n  if (nc->flags & MG_F_UDP) {\n    rc = nc->iface->vtable->listen_udp(nc, &nc->sa);\n  } else {\n    rc = nc->iface->vtable->listen_tcp(nc, &nc->sa);\n  }\n  if (rc != 0) {\n    DBG((\"Failed to open listener: %d\", rc));\n    MG_SET_PTRPTR(opts.error_string, \"failed to open listener\");\n    mg_destroy_conn(nc, 1 /* destroy_if */);\n    return NULL;\n  }\n  mg_add_conn(nc->mgr, nc);\n\n#if MG_ENABLE_CALLBACK_USERDATA\n  (void) user_data;\n#endif\n  return nc;\n}\n\nstruct mg_connection *mg_next(struct mg_mgr *s, struct mg_connection *conn) {\n  return conn == NULL ? s->active_connections : conn->next;\n}\n\n#if MG_ENABLE_BROADCAST\nvoid mg_broadcast(struct mg_mgr *mgr, mg_event_handler_t cb, void *data,\n                  size_t len) {\n  struct ctl_msg ctl_msg;\n\n  /*\n   * Mongoose manager has a socketpair, `struct mg_mgr::ctl`,\n   * where `mg_broadcast()` pushes the message.\n   * `mg_mgr_poll()` wakes up, reads a message from the socket pair, and calls\n   * specified callback for each connection. Thus the callback function executes\n   * in event manager thread.\n   */\n  if (mgr->ctl[0] != INVALID_SOCKET && data != NULL &&\n      len < sizeof(ctl_msg.message)) {\n    size_t dummy;\n\n    ctl_msg.callback = cb;\n    memcpy(ctl_msg.message, data, len);\n    dummy = MG_SEND_FUNC(mgr->ctl[0], (char *) &ctl_msg,\n                         offsetof(struct ctl_msg, message) + len, 0);\n    dummy = MG_RECV_FUNC(mgr->ctl[0], (char *) &len, 1, 0);\n    (void) dummy; /* https://gcc.gnu.org/bugzilla/show_bug.cgi?id=25509 */\n  }\n}\n#endif /* MG_ENABLE_BROADCAST */\n\nstatic int isbyte(int n) {\n  return n >= 0 && n <= 255;\n}\n\nstatic int parse_net(const char *spec, uint32_t *net, uint32_t *mask) {\n  int n, a, b, c, d, slash = 32, len = 0;\n\n  if ((sscanf(spec, \"%d.%d.%d.%d/%d%n\", &a, &b, &c, &d, &slash, &n) == 5 ||\n       sscanf(spec, \"%d.%d.%d.%d%n\", &a, &b, &c, &d, &n) == 4) &&\n      isbyte(a) && isbyte(b) && isbyte(c) && isbyte(d) && slash >= 0 &&\n      slash < 33) {\n    len = n;\n    *net =\n        ((uint32_t) a << 24) | ((uint32_t) b << 16) | ((uint32_t) c << 8) | d;\n    *mask = slash ? 0xffffffffU << (32 - slash) : 0;\n  }\n\n  return len;\n}\n\nint mg_check_ip_acl(const char *acl, uint32_t remote_ip) {\n  int allowed, flag;\n  uint32_t net, mask;\n  struct mg_str vec;\n\n  /* If any ACL is set, deny by default */\n  allowed = (acl == NULL || *acl == '\\0') ? '+' : '-';\n\n  while ((acl = mg_next_comma_list_entry(acl, &vec, NULL)) != NULL) {\n    flag = vec.p[0];\n    if ((flag != '+' && flag != '-') ||\n        parse_net(&vec.p[1], &net, &mask) == 0) {\n      return -1;\n    }\n\n    if (net == (remote_ip & mask)) {\n      allowed = flag;\n    }\n  }\n\n  DBG((\"%08x %c\", remote_ip, allowed));\n  return allowed == '+';\n}\n\n/* Move data from one connection to another */\nvoid mg_forward(struct mg_connection *from, struct mg_connection *to) {\n  mg_send(to, from->recv_mbuf.buf, from->recv_mbuf.len);\n  mbuf_remove(&from->recv_mbuf, from->recv_mbuf.len);\n}\n\ndouble mg_set_timer(struct mg_connection *c, double timestamp) {\n  double result = c->ev_timer_time;\n  c->ev_timer_time = timestamp;\n  /*\n   * If this connection is resolving, it's not in the list of active\n   * connections, so not processed yet. It has a DNS resolver connection\n   * linked to it. Set up a timer for the DNS connection.\n   */\n  DBG((\"%p %p %d -> %lu\", c, c->priv_2, c->flags & MG_F_RESOLVING,\n       (unsigned long) timestamp));\n  if ((c->flags & MG_F_RESOLVING) && c->priv_2 != NULL) {\n    ((struct mg_connection *) c->priv_2)->ev_timer_time = timestamp;\n  }\n  return result;\n}\n\nvoid mg_sock_set(struct mg_connection *nc, sock_t sock) {\n  if (sock != INVALID_SOCKET) {\n    nc->iface->vtable->sock_set(nc, sock);\n  }\n}\n\nvoid mg_if_get_conn_addr(struct mg_connection *nc, int remote,\n                         union socket_address *sa) {\n  nc->iface->vtable->get_conn_addr(nc, remote, sa);\n}\n\nstruct mg_connection *mg_add_sock_opt(struct mg_mgr *s, sock_t sock,\n                                      MG_CB(mg_event_handler_t callback,\n                                            void *user_data),\n                                      struct mg_add_sock_opts opts) {\n#if MG_ENABLE_CALLBACK_USERDATA\n  opts.user_data = user_data;\n#endif\n\n  struct mg_connection *nc = mg_create_connection_base(s, callback, opts);\n  if (nc != NULL) {\n    mg_sock_set(nc, sock);\n    mg_add_conn(nc->mgr, nc);\n  }\n  return nc;\n}\n\nstruct mg_connection *mg_add_sock(struct mg_mgr *s, sock_t sock,\n                                  MG_CB(mg_event_handler_t callback,\n                                        void *user_data)) {\n  struct mg_add_sock_opts opts;\n  memset(&opts, 0, sizeof(opts));\n  return mg_add_sock_opt(s, sock, MG_CB(callback, user_data), opts);\n}\n\ndouble mg_time(void) {\n  return cs_time();\n}\n#ifdef MG_MODULE_LINES\n#line 1 \"mongoose/src/net_if_socket.h\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#ifndef CS_MONGOOSE_SRC_NET_IF_SOCKET_H_\n#define CS_MONGOOSE_SRC_NET_IF_SOCKET_H_\n\n/* Amalgamated: #include \"mongoose/src/net_if.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif /* __cplusplus */\n\n#ifndef MG_ENABLE_NET_IF_SOCKET\n#define MG_ENABLE_NET_IF_SOCKET MG_NET_IF == MG_NET_IF_SOCKET\n#endif\n\nextern const struct mg_iface_vtable mg_socket_iface_vtable;\n\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n\n#endif /* CS_MONGOOSE_SRC_NET_IF_SOCKET_H_ */\n#ifdef MG_MODULE_LINES\n#line 1 \"mongoose/src/net_if_tun.h\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#ifndef CS_MONGOOSE_SRC_NET_IF_TUN_H_\n#define CS_MONGOOSE_SRC_NET_IF_TUN_H_\n\n#if MG_ENABLE_TUN\n\n/* Amalgamated: #include \"mongoose/src/net_if.h\" */\n\nstruct mg_tun_client;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif /* __cplusplus */\n\nextern const struct mg_iface_vtable mg_tun_iface_vtable;\n\nstruct mg_connection *mg_tun_if_find_conn(struct mg_tun_client *client,\n                                          uint32_t stream_id);\n\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n\n#endif /* MG_ENABLE_TUN */\n\n#endif /* CS_MONGOOSE_SRC_NET_IF_TUN_H_ */\n#ifdef MG_MODULE_LINES\n#line 1 \"mongoose/src/net_if.c\"\n#endif\n/* Amalgamated: #include \"mongoose/src/net_if.h\" */\n/* Amalgamated: #include \"mongoose/src/internal.h\" */\n/* Amalgamated: #include \"mongoose/src/net_if_socket.h\" */\n/* Amalgamated: #include \"mongoose/src/net_if_tun.h\" */\n\nextern const struct mg_iface_vtable mg_default_iface_vtable;\n\n#if MG_ENABLE_TUN\nconst struct mg_iface_vtable *mg_ifaces[] = {&mg_default_iface_vtable,\n                                             &mg_tun_iface_vtable};\n#else\nconst struct mg_iface_vtable *mg_ifaces[] = {&mg_default_iface_vtable};\n#endif\n\nint mg_num_ifaces = (int) (sizeof(mg_ifaces) / sizeof(mg_ifaces[0]));\n\nstruct mg_iface *mg_if_create_iface(const struct mg_iface_vtable *vtable,\n                                    struct mg_mgr *mgr) {\n  struct mg_iface *iface = (struct mg_iface *) MG_CALLOC(1, sizeof(*iface));\n  iface->mgr = mgr;\n  iface->data = NULL;\n  iface->vtable = vtable;\n  return iface;\n}\n\nstruct mg_iface *mg_find_iface(struct mg_mgr *mgr,\n                               const struct mg_iface_vtable *vtable,\n                               struct mg_iface *from) {\n  int i = 0;\n  if (from != NULL) {\n    for (i = 0; i < mgr->num_ifaces; i++) {\n      if (mgr->ifaces[i] == from) {\n        i++;\n        break;\n      }\n    }\n  }\n\n  for (; i < mgr->num_ifaces; i++) {\n    if (mgr->ifaces[i]->vtable == vtable) {\n      return mgr->ifaces[i];\n    }\n  }\n  return NULL;\n}\n#ifdef MG_MODULE_LINES\n#line 1 \"mongoose/src/net_if_socket.c\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#if MG_ENABLE_NET_IF_SOCKET\n\n/* Amalgamated: #include \"mongoose/src/net_if_socket.h\" */\n/* Amalgamated: #include \"mongoose/src/internal.h\" */\n/* Amalgamated: #include \"mongoose/src/util.h\" */\n\n#define MG_TCP_RECV_BUFFER_SIZE 1024\n#define MG_UDP_RECV_BUFFER_SIZE 1500\n\nstatic sock_t mg_open_listening_socket(union socket_address *sa, int type,\n                                       int proto);\n#if MG_ENABLE_SSL\nstatic void mg_ssl_begin(struct mg_connection *nc);\n#endif\n\nvoid mg_set_non_blocking_mode(sock_t sock) {\n#ifdef _WIN32\n  unsigned long on = 1;\n  ioctlsocket(sock, FIONBIO, &on);\n#else\n  int flags = fcntl(sock, F_GETFL, 0);\n  fcntl(sock, F_SETFL, flags | O_NONBLOCK);\n#endif\n}\n\nstatic int mg_is_error(int n) {\n  int err = mg_get_errno();\n  return (n < 0 && err != EINPROGRESS && err != EWOULDBLOCK\n#ifndef WINCE\n          && err != EAGAIN && err != EINTR\n#endif\n#ifdef _WIN32\n          && WSAGetLastError() != WSAEINTR &&\n          WSAGetLastError() != WSAEWOULDBLOCK\n#endif\n          );\n}\n\nvoid mg_socket_if_connect_tcp(struct mg_connection *nc,\n                              const union socket_address *sa) {\n  int rc, proto = 0;\n  nc->sock = socket(AF_INET, SOCK_STREAM, proto);\n  if (nc->sock == INVALID_SOCKET) {\n    nc->err = mg_get_errno() ? mg_get_errno() : 1;\n    return;\n  }\n#if !defined(MG_ESP8266)\n  mg_set_non_blocking_mode(nc->sock);\n#endif\n  rc = connect(nc->sock, &sa->sa, sizeof(sa->sin));\n  nc->err = mg_is_error(rc) ? mg_get_errno() : 0;\n  DBG((\"%p sock %d rc %d errno %d err %d\", nc, nc->sock, rc, mg_get_errno(),\n       nc->err));\n}\n\nvoid mg_socket_if_connect_udp(struct mg_connection *nc) {\n  nc->sock = socket(AF_INET, SOCK_DGRAM, 0);\n  if (nc->sock == INVALID_SOCKET) {\n    nc->err = mg_get_errno() ? mg_get_errno() : 1;\n    return;\n  }\n  if (nc->flags & MG_F_ENABLE_BROADCAST) {\n    int optval = 1;\n    setsockopt(nc->sock, SOL_SOCKET, SO_BROADCAST, (const char *) &optval,\n               sizeof(optval));\n  }\n  nc->err = 0;\n}\n\nint mg_socket_if_listen_tcp(struct mg_connection *nc,\n                            union socket_address *sa) {\n  int proto = 0;\n  sock_t sock = mg_open_listening_socket(sa, SOCK_STREAM, proto);\n  if (sock == INVALID_SOCKET) {\n    return (mg_get_errno() ? mg_get_errno() : 1);\n  }\n  mg_sock_set(nc, sock);\n  return 0;\n}\n\nint mg_socket_if_listen_udp(struct mg_connection *nc,\n                            union socket_address *sa) {\n  sock_t sock = mg_open_listening_socket(sa, SOCK_DGRAM, 0);\n  if (sock == INVALID_SOCKET) return (mg_get_errno() ? mg_get_errno() : 1);\n  mg_sock_set(nc, sock);\n  return 0;\n}\n\nvoid mg_socket_if_tcp_send(struct mg_connection *nc, const void *buf,\n                           size_t len) {\n  mbuf_append(&nc->send_mbuf, buf, len);\n}\n\nvoid mg_socket_if_udp_send(struct mg_connection *nc, const void *buf,\n                           size_t len) {\n  mbuf_append(&nc->send_mbuf, buf, len);\n}\n\nvoid mg_socket_if_recved(struct mg_connection *nc, size_t len) {\n  (void) nc;\n  (void) len;\n}\n\nint mg_socket_if_create_conn(struct mg_connection *nc) {\n  (void) nc;\n  return 1;\n}\n\nvoid mg_socket_if_destroy_conn(struct mg_connection *nc) {\n  if (nc->sock == INVALID_SOCKET) return;\n  if (!(nc->flags & MG_F_UDP)) {\n    closesocket(nc->sock);\n  } else {\n    /* Only close outgoing UDP sockets or listeners. */\n    if (nc->listener == NULL) closesocket(nc->sock);\n  }\n  nc->sock = INVALID_SOCKET;\n}\n\nstatic int mg_accept_conn(struct mg_connection *lc) {\n  struct mg_connection *nc;\n  union socket_address sa;\n  socklen_t sa_len = sizeof(sa);\n  /* NOTE(lsm): on Windows, sock is always > FD_SETSIZE */\n  sock_t sock = accept(lc->sock, &sa.sa, &sa_len);\n  if (sock == INVALID_SOCKET) {\n    if (mg_is_error(-1)) DBG((\"%p: failed to accept: %d\", lc, mg_get_errno()));\n    return 0;\n  }\n  nc = mg_if_accept_new_conn(lc);\n  if (nc == NULL) {\n    closesocket(sock);\n    return 0;\n  }\n  DBG((\"%p conn from %s:%d\", nc, inet_ntoa(sa.sin.sin_addr),\n       ntohs(sa.sin.sin_port)));\n  mg_sock_set(nc, sock);\n#if MG_ENABLE_SSL\n  if (lc->flags & MG_F_SSL) {\n    if (mg_ssl_if_conn_accept(nc, lc) != MG_SSL_OK) mg_close_conn(nc);\n  } else\n#endif\n  {\n    mg_if_accept_tcp_cb(nc, &sa, sa_len);\n  }\n  return 1;\n}\n\n/* 'sa' must be an initialized address to bind to */\nstatic sock_t mg_open_listening_socket(union socket_address *sa, int type,\n                                       int proto) {\n  socklen_t sa_len =\n      (sa->sa.sa_family == AF_INET) ? sizeof(sa->sin) : sizeof(sa->sin6);\n  sock_t sock = INVALID_SOCKET;\n#if !MG_LWIP\n  int on = 1;\n#endif\n\n  if ((sock = socket(sa->sa.sa_family, type, proto)) != INVALID_SOCKET &&\n#if !MG_LWIP /* LWIP doesn't support either */\n#if defined(_WIN32) && defined(SO_EXCLUSIVEADDRUSE) && !defined(WINCE)\n      /* \"Using SO_REUSEADDR and SO_EXCLUSIVEADDRUSE\" http://goo.gl/RmrFTm */\n      !setsockopt(sock, SOL_SOCKET, SO_EXCLUSIVEADDRUSE, (void *) &on,\n                  sizeof(on)) &&\n#endif\n\n#if !defined(_WIN32) || !defined(SO_EXCLUSIVEADDRUSE)\n      /*\n       * SO_RESUSEADDR is not enabled on Windows because the semantics of\n       * SO_REUSEADDR on UNIX and Windows is different. On Windows,\n       * SO_REUSEADDR allows to bind a socket to a port without error even if\n       * the port is already open by another program. This is not the behavior\n       * SO_REUSEADDR was designed for, and leads to hard-to-track failure\n       * scenarios. Therefore, SO_REUSEADDR was disabled on Windows unless\n       * SO_EXCLUSIVEADDRUSE is supported and set on a socket.\n       */\n      !setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (void *) &on, sizeof(on)) &&\n#endif\n#endif /* !MG_LWIP */\n\n      !bind(sock, &sa->sa, sa_len) &&\n      (type == SOCK_DGRAM || listen(sock, SOMAXCONN) == 0)) {\n#if !MG_LWIP\n    mg_set_non_blocking_mode(sock);\n    /* In case port was set to 0, get the real port number */\n    (void) getsockname(sock, &sa->sa, &sa_len);\n#endif\n  } else if (sock != INVALID_SOCKET) {\n    closesocket(sock);\n    sock = INVALID_SOCKET;\n  }\n\n  return sock;\n}\n\nstatic void mg_write_to_socket(struct mg_connection *nc) {\n  struct mbuf *io = &nc->send_mbuf;\n  int n = 0;\n\n#if MG_LWIP\n  /* With LWIP we don't know if the socket is ready */\n  if (io->len == 0) return;\n#endif\n\n  assert(io->len > 0);\n\n  if (nc->flags & MG_F_UDP) {\n    int n =\n        sendto(nc->sock, io->buf, io->len, 0, &nc->sa.sa, sizeof(nc->sa.sin));\n    DBG((\"%p %d %d %d %s:%hu\", nc, nc->sock, n, mg_get_errno(),\n         inet_ntoa(nc->sa.sin.sin_addr), ntohs(nc->sa.sin.sin_port)));\n    if (n > 0) {\n      mbuf_remove(io, n);\n      mg_if_sent_cb(nc, n);\n    }\n    return;\n  }\n\n#if MG_ENABLE_SSL\n  if (nc->flags & MG_F_SSL) {\n    if (nc->flags & MG_F_SSL_HANDSHAKE_DONE) {\n      n = mg_ssl_if_write(nc, io->buf, io->len);\n      DBG((\"%p %d bytes -> %d (SSL)\", nc, n, nc->sock));\n      if (n < 0) {\n        if (n != MG_SSL_WANT_READ && n != MG_SSL_WANT_WRITE) {\n          nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n        }\n        return;\n      } else {\n        /* Successful SSL operation, clear off SSL wait flags */\n        nc->flags &= ~(MG_F_WANT_READ | MG_F_WANT_WRITE);\n      }\n    } else {\n      mg_ssl_begin(nc);\n      return;\n    }\n  } else\n#endif\n  {\n    n = (int) MG_SEND_FUNC(nc->sock, io->buf, io->len, 0);\n    DBG((\"%p %d bytes -> %d\", nc, n, nc->sock));\n    if (n < 0 && mg_is_error(n)) {\n      /* Something went wrong, drop the connection. */\n      nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n      return;\n    }\n  }\n\n  if (n > 0) {\n    mbuf_remove(io, n);\n    mg_if_sent_cb(nc, n);\n  }\n}\n\nMG_INTERNAL size_t recv_avail_size(struct mg_connection *conn, size_t max) {\n  size_t avail;\n  if (conn->recv_mbuf_limit < conn->recv_mbuf.len) return 0;\n  avail = conn->recv_mbuf_limit - conn->recv_mbuf.len;\n  return avail > max ? max : avail;\n}\n\nstatic void mg_handle_tcp_read(struct mg_connection *conn) {\n  int n = 0;\n  char *buf = (char *) MG_MALLOC(MG_TCP_RECV_BUFFER_SIZE);\n\n  if (buf == NULL) {\n    DBG((\"OOM\"));\n    return;\n  }\n\n#if MG_ENABLE_SSL\n  if (conn->flags & MG_F_SSL) {\n    if (conn->flags & MG_F_SSL_HANDSHAKE_DONE) {\n      /* SSL library may have more bytes ready to read than we ask to read.\n       * Therefore, read in a loop until we read everything. Without the loop,\n       * we skip to the next select() cycle which can just timeout. */\n      while ((n = mg_ssl_if_read(conn, buf, MG_TCP_RECV_BUFFER_SIZE)) > 0) {\n        DBG((\"%p %d bytes <- %d (SSL)\", conn, n, conn->sock));\n        mg_if_recv_tcp_cb(conn, buf, n, 1 /* own */);\n        buf = NULL;\n        if (conn->flags & MG_F_CLOSE_IMMEDIATELY) break;\n        /* buf has been freed, we need a new one. */\n        buf = (char *) MG_MALLOC(MG_TCP_RECV_BUFFER_SIZE);\n        if (buf == NULL) break;\n      }\n      MG_FREE(buf);\n      if (n < 0 && n != MG_SSL_WANT_READ) conn->flags |= MG_F_CLOSE_IMMEDIATELY;\n    } else {\n      MG_FREE(buf);\n      mg_ssl_begin(conn);\n      return;\n    }\n  } else\n#endif\n  {\n    n = (int) MG_RECV_FUNC(conn->sock, buf,\n                           recv_avail_size(conn, MG_TCP_RECV_BUFFER_SIZE), 0);\n    DBG((\"%p %d bytes (PLAIN) <- %d\", conn, n, conn->sock));\n    if (n > 0) {\n      mg_if_recv_tcp_cb(conn, buf, n, 1 /* own */);\n    } else {\n      MG_FREE(buf);\n    }\n    if (n == 0) {\n      /* Orderly shutdown of the socket, try flushing output. */\n      conn->flags |= MG_F_SEND_AND_CLOSE;\n    } else if (mg_is_error(n)) {\n      conn->flags |= MG_F_CLOSE_IMMEDIATELY;\n    }\n  }\n}\n\nstatic int mg_recvfrom(struct mg_connection *nc, union socket_address *sa,\n                       socklen_t *sa_len, char **buf) {\n  int n;\n  *buf = (char *) MG_MALLOC(MG_UDP_RECV_BUFFER_SIZE);\n  if (*buf == NULL) {\n    DBG((\"Out of memory\"));\n    return -ENOMEM;\n  }\n  n = recvfrom(nc->sock, *buf, MG_UDP_RECV_BUFFER_SIZE, 0, &sa->sa, sa_len);\n  if (n <= 0) {\n    DBG((\"%p recvfrom: %s\", nc, strerror(mg_get_errno())));\n    MG_FREE(*buf);\n  }\n  return n;\n}\n\nstatic void mg_handle_udp_read(struct mg_connection *nc) {\n  char *buf = NULL;\n  union socket_address sa;\n  socklen_t sa_len = sizeof(sa);\n  int n = mg_recvfrom(nc, &sa, &sa_len, &buf);\n  DBG((\"%p %d bytes from %s:%d\", nc, n, inet_ntoa(nc->sa.sin.sin_addr),\n       ntohs(nc->sa.sin.sin_port)));\n  mg_if_recv_udp_cb(nc, buf, n, &sa, sa_len);\n}\n\n#if MG_ENABLE_SSL\nstatic void mg_ssl_begin(struct mg_connection *nc) {\n  int server_side = (nc->listener != NULL);\n  enum mg_ssl_if_result res = mg_ssl_if_handshake(nc);\n  DBG((\"%p %d res %d\", nc, server_side, res));\n\n  if (res == MG_SSL_OK) {\n    nc->flags |= MG_F_SSL_HANDSHAKE_DONE;\n    nc->flags &= ~(MG_F_WANT_READ | MG_F_WANT_WRITE);\n\n    if (server_side) {\n      union socket_address sa;\n      socklen_t sa_len = sizeof(sa);\n      (void) getpeername(nc->sock, &sa.sa, &sa_len);\n      mg_if_accept_tcp_cb(nc, &sa, sa_len);\n    } else {\n      mg_if_connect_cb(nc, 0);\n    }\n  } else if (res != MG_SSL_WANT_READ && res != MG_SSL_WANT_WRITE) {\n    if (!server_side) {\n      mg_if_connect_cb(nc, res);\n    }\n    nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n  }\n}\n#endif /* MG_ENABLE_SSL */\n\n#define _MG_F_FD_CAN_READ 1\n#define _MG_F_FD_CAN_WRITE 1 << 1\n#define _MG_F_FD_ERROR 1 << 2\n\nvoid mg_mgr_handle_conn(struct mg_connection *nc, int fd_flags, double now) {\n  int worth_logging =\n      fd_flags != 0 || (nc->flags & (MG_F_WANT_READ | MG_F_WANT_WRITE));\n  if (worth_logging) {\n    DBG((\"%p fd=%d fd_flags=%d nc_flags=%lu rmbl=%d smbl=%d\", nc, nc->sock,\n         fd_flags, nc->flags, (int) nc->recv_mbuf.len,\n         (int) nc->send_mbuf.len));\n  }\n\n  if (nc->flags & MG_F_CONNECTING) {\n    if (fd_flags != 0) {\n      int err = 0;\n#if !defined(MG_ESP8266)\n      if (!(nc->flags & MG_F_UDP)) {\n        socklen_t len = sizeof(err);\n        int ret =\n            getsockopt(nc->sock, SOL_SOCKET, SO_ERROR, (char *) &err, &len);\n        if (ret != 0) {\n          err = 1;\n        } else if (err == EAGAIN || err == EWOULDBLOCK) {\n          err = 0;\n        }\n      }\n#else\n      /*\n       * On ESP8266 we use blocking connect.\n       */\n      err = nc->err;\n#endif\n#if MG_ENABLE_SSL\n      if ((nc->flags & MG_F_SSL) && err == 0) {\n        mg_ssl_begin(nc);\n      } else {\n        mg_if_connect_cb(nc, err);\n      }\n#else\n      mg_if_connect_cb(nc, err);\n#endif\n    } else if (nc->err != 0) {\n      mg_if_connect_cb(nc, nc->err);\n    }\n  }\n\n  if (fd_flags & _MG_F_FD_CAN_READ) {\n    if (nc->flags & MG_F_UDP) {\n      mg_handle_udp_read(nc);\n    } else {\n      if (nc->flags & MG_F_LISTENING) {\n        /*\n         * We're not looping here, and accepting just one connection at\n         * a time. The reason is that eCos does not respect non-blocking\n         * flag on a listening socket and hangs in a loop.\n         */\n        mg_accept_conn(nc);\n      } else {\n        mg_handle_tcp_read(nc);\n      }\n    }\n  }\n\n  if (!(nc->flags & MG_F_CLOSE_IMMEDIATELY)) {\n    if ((fd_flags & _MG_F_FD_CAN_WRITE) && nc->send_mbuf.len > 0) {\n      mg_write_to_socket(nc);\n    }\n    mg_if_poll(nc, (time_t) now);\n    mg_if_timer(nc, now);\n  }\n\n  if (worth_logging) {\n    DBG((\"%p after fd=%d nc_flags=%lu rmbl=%d smbl=%d\", nc, nc->sock, nc->flags,\n         (int) nc->recv_mbuf.len, (int) nc->send_mbuf.len));\n  }\n}\n\n#if MG_ENABLE_BROADCAST\nstatic void mg_mgr_handle_ctl_sock(struct mg_mgr *mgr) {\n  struct ctl_msg ctl_msg;\n  int len =\n      (int) MG_RECV_FUNC(mgr->ctl[1], (char *) &ctl_msg, sizeof(ctl_msg), 0);\n  size_t dummy = MG_SEND_FUNC(mgr->ctl[1], ctl_msg.message, 1, 0);\n  DBG((\"read %d from ctl socket\", len));\n  (void) dummy; /* https://gcc.gnu.org/bugzilla/show_bug.cgi?id=25509 */\n  if (len >= (int) sizeof(ctl_msg.callback) && ctl_msg.callback != NULL) {\n    struct mg_connection *nc;\n    for (nc = mg_next(mgr, NULL); nc != NULL; nc = mg_next(mgr, nc)) {\n      ctl_msg.callback(nc, MG_EV_POLL,\n                       ctl_msg.message MG_UD_ARG(nc->user_data));\n    }\n  }\n}\n#endif\n\n/* Associate a socket to a connection. */\nvoid mg_socket_if_sock_set(struct mg_connection *nc, sock_t sock) {\n  mg_set_non_blocking_mode(sock);\n  mg_set_close_on_exec(sock);\n  nc->sock = sock;\n  DBG((\"%p %d\", nc, sock));\n}\n\nvoid mg_socket_if_init(struct mg_iface *iface) {\n  (void) iface;\n  DBG((\"%p using select()\", iface->mgr));\n#if MG_ENABLE_BROADCAST\n  do {\n    mg_socketpair(iface->mgr->ctl, SOCK_DGRAM);\n  } while (iface->mgr->ctl[0] == INVALID_SOCKET);\n#endif\n}\n\nvoid mg_socket_if_free(struct mg_iface *iface) {\n  (void) iface;\n}\n\nvoid mg_socket_if_add_conn(struct mg_connection *nc) {\n  (void) nc;\n}\n\nvoid mg_socket_if_remove_conn(struct mg_connection *nc) {\n  (void) nc;\n}\n\nvoid mg_add_to_set(sock_t sock, fd_set *set, sock_t *max_fd) {\n  if (sock != INVALID_SOCKET\n#ifdef __unix__\n      && sock < (sock_t) FD_SETSIZE\n#endif\n      ) {\n    FD_SET(sock, set);\n    if (*max_fd == INVALID_SOCKET || sock > *max_fd) {\n      *max_fd = sock;\n    }\n  }\n}\n\ntime_t mg_socket_if_poll(struct mg_iface *iface, int timeout_ms) {\n  struct mg_mgr *mgr = iface->mgr;\n  double now = mg_time();\n  double min_timer;\n  struct mg_connection *nc, *tmp;\n  struct timeval tv;\n  fd_set read_set, write_set, err_set;\n  sock_t max_fd = INVALID_SOCKET;\n  int num_fds, num_ev, num_timers = 0;\n#ifdef __unix__\n  int try_dup = 1;\n#endif\n\n  FD_ZERO(&read_set);\n  FD_ZERO(&write_set);\n  FD_ZERO(&err_set);\n#if MG_ENABLE_BROADCAST\n  mg_add_to_set(mgr->ctl[1], &read_set, &max_fd);\n#endif\n\n  /*\n   * Note: it is ok to have connections with sock == INVALID_SOCKET in the list,\n   * e.g. timer-only \"connections\".\n   */\n  min_timer = 0;\n  for (nc = mgr->active_connections, num_fds = 0; nc != NULL; nc = tmp) {\n    tmp = nc->next;\n\n    if (nc->sock != INVALID_SOCKET) {\n      num_fds++;\n\n#ifdef __unix__\n      /* A hack to make sure all our file descriptos fit into FD_SETSIZE. */\n      if (nc->sock >= (sock_t) FD_SETSIZE && try_dup) {\n        int new_sock = dup(nc->sock);\n        if (new_sock >= 0 && new_sock < (sock_t) FD_SETSIZE) {\n          closesocket(nc->sock);\n          DBG((\"new sock %d -> %d\", nc->sock, new_sock));\n          nc->sock = new_sock;\n        } else {\n          try_dup = 0;\n        }\n      }\n#endif\n\n      if (!(nc->flags & MG_F_WANT_WRITE) &&\n          nc->recv_mbuf.len < nc->recv_mbuf_limit &&\n          (!(nc->flags & MG_F_UDP) || nc->listener == NULL)) {\n        mg_add_to_set(nc->sock, &read_set, &max_fd);\n      }\n\n      if (((nc->flags & MG_F_CONNECTING) && !(nc->flags & MG_F_WANT_READ)) ||\n          (nc->send_mbuf.len > 0 && !(nc->flags & MG_F_CONNECTING))) {\n        mg_add_to_set(nc->sock, &write_set, &max_fd);\n        mg_add_to_set(nc->sock, &err_set, &max_fd);\n      }\n    }\n\n    if (nc->ev_timer_time > 0) {\n      if (num_timers == 0 || nc->ev_timer_time < min_timer) {\n        min_timer = nc->ev_timer_time;\n      }\n      num_timers++;\n    }\n  }\n\n  /*\n   * If there is a timer to be fired earlier than the requested timeout,\n   * adjust the timeout.\n   */\n  if (num_timers > 0) {\n    double timer_timeout_ms = (min_timer - mg_time()) * 1000 + 1 /* rounding */;\n    if (timer_timeout_ms < timeout_ms) {\n      timeout_ms = (int) timer_timeout_ms;\n    }\n  }\n  if (timeout_ms < 0) timeout_ms = 0;\n\n  tv.tv_sec = timeout_ms / 1000;\n  tv.tv_usec = (timeout_ms % 1000) * 1000;\n\n  num_ev = select((int) max_fd + 1, &read_set, &write_set, &err_set, &tv);\n  now = mg_time();\n#if 0\n  DBG((\"select @ %ld num_ev=%d of %d, timeout=%d\", (long) now, num_ev, num_fds,\n       timeout_ms));\n#endif\n\n#if MG_ENABLE_BROADCAST\n  if (num_ev > 0 && mgr->ctl[1] != INVALID_SOCKET &&\n      FD_ISSET(mgr->ctl[1], &read_set)) {\n    mg_mgr_handle_ctl_sock(mgr);\n  }\n#endif\n\n  for (nc = mgr->active_connections; nc != NULL; nc = tmp) {\n    int fd_flags = 0;\n    if (nc->sock != INVALID_SOCKET) {\n      if (num_ev > 0) {\n        fd_flags = (FD_ISSET(nc->sock, &read_set) &&\n                            (!(nc->flags & MG_F_UDP) || nc->listener == NULL)\n                        ? _MG_F_FD_CAN_READ\n                        : 0) |\n                   (FD_ISSET(nc->sock, &write_set) ? _MG_F_FD_CAN_WRITE : 0) |\n                   (FD_ISSET(nc->sock, &err_set) ? _MG_F_FD_ERROR : 0);\n      }\n#if MG_LWIP\n      /* With LWIP socket emulation layer, we don't get write events for UDP */\n      if ((nc->flags & MG_F_UDP) && nc->listener == NULL) {\n        fd_flags |= _MG_F_FD_CAN_WRITE;\n      }\n#endif\n    }\n    tmp = nc->next;\n    mg_mgr_handle_conn(nc, fd_flags, now);\n  }\n\n  for (nc = mgr->active_connections; nc != NULL; nc = tmp) {\n    tmp = nc->next;\n    if ((nc->flags & MG_F_CLOSE_IMMEDIATELY) ||\n        (nc->send_mbuf.len == 0 && (nc->flags & MG_F_SEND_AND_CLOSE))) {\n      mg_close_conn(nc);\n    }\n  }\n\n  return (time_t) now;\n}\n\n#if MG_ENABLE_BROADCAST\nint mg_socketpair(sock_t sp[2], int sock_type) {\n  union socket_address sa;\n  sock_t sock;\n  socklen_t len = sizeof(sa.sin);\n  int ret = 0;\n\n  sock = sp[0] = sp[1] = INVALID_SOCKET;\n\n  (void) memset(&sa, 0, sizeof(sa));\n  sa.sin.sin_family = AF_INET;\n  sa.sin.sin_port = htons(0);\n  sa.sin.sin_addr.s_addr = htonl(0x7f000001); /* 127.0.0.1 */\n\n  if ((sock = socket(AF_INET, sock_type, 0)) == INVALID_SOCKET) {\n  } else if (bind(sock, &sa.sa, len) != 0) {\n  } else if (sock_type == SOCK_STREAM && listen(sock, 1) != 0) {\n  } else if (getsockname(sock, &sa.sa, &len) != 0) {\n  } else if ((sp[0] = socket(AF_INET, sock_type, 0)) == INVALID_SOCKET) {\n  } else if (connect(sp[0], &sa.sa, len) != 0) {\n  } else if (sock_type == SOCK_DGRAM &&\n             (getsockname(sp[0], &sa.sa, &len) != 0 ||\n              connect(sock, &sa.sa, len) != 0)) {\n  } else if ((sp[1] = (sock_type == SOCK_DGRAM ? sock\n                                               : accept(sock, &sa.sa, &len))) ==\n             INVALID_SOCKET) {\n  } else {\n    mg_set_close_on_exec(sp[0]);\n    mg_set_close_on_exec(sp[1]);\n    if (sock_type == SOCK_STREAM) closesocket(sock);\n    ret = 1;\n  }\n\n  if (!ret) {\n    if (sp[0] != INVALID_SOCKET) closesocket(sp[0]);\n    if (sp[1] != INVALID_SOCKET) closesocket(sp[1]);\n    if (sock != INVALID_SOCKET) closesocket(sock);\n    sock = sp[0] = sp[1] = INVALID_SOCKET;\n  }\n\n  return ret;\n}\n#endif /* MG_ENABLE_BROADCAST */\n\nstatic void mg_sock_get_addr(sock_t sock, int remote,\n                             union socket_address *sa) {\n  socklen_t slen = sizeof(*sa);\n  memset(sa, 0, slen);\n  if (remote) {\n    getpeername(sock, &sa->sa, &slen);\n  } else {\n    getsockname(sock, &sa->sa, &slen);\n  }\n}\n\nvoid mg_sock_to_str(sock_t sock, char *buf, size_t len, int flags) {\n  union socket_address sa;\n  mg_sock_get_addr(sock, flags & MG_SOCK_STRINGIFY_REMOTE, &sa);\n  mg_sock_addr_to_str(&sa, buf, len, flags);\n}\n\nvoid mg_socket_if_get_conn_addr(struct mg_connection *nc, int remote,\n                                union socket_address *sa) {\n  mg_sock_get_addr(nc->sock, remote, sa);\n}\n\n/* clang-format off */\n#define MG_SOCKET_IFACE_VTABLE                                          \\\n  {                                                                     \\\n    mg_socket_if_init,                                                  \\\n    mg_socket_if_free,                                                  \\\n    mg_socket_if_add_conn,                                              \\\n    mg_socket_if_remove_conn,                                           \\\n    mg_socket_if_poll,                                                  \\\n    mg_socket_if_listen_tcp,                                            \\\n    mg_socket_if_listen_udp,                                            \\\n    mg_socket_if_connect_tcp,                                           \\\n    mg_socket_if_connect_udp,                                           \\\n    mg_socket_if_tcp_send,                                              \\\n    mg_socket_if_udp_send,                                              \\\n    mg_socket_if_recved,                                                \\\n    mg_socket_if_create_conn,                                           \\\n    mg_socket_if_destroy_conn,                                          \\\n    mg_socket_if_sock_set,                                              \\\n    mg_socket_if_get_conn_addr,                                         \\\n  }\n/* clang-format on */\n\nconst struct mg_iface_vtable mg_socket_iface_vtable = MG_SOCKET_IFACE_VTABLE;\n#if MG_NET_IF == MG_NET_IF_SOCKET\nconst struct mg_iface_vtable mg_default_iface_vtable = MG_SOCKET_IFACE_VTABLE;\n#endif\n\n#endif /* MG_ENABLE_NET_IF_SOCKET */\n#ifdef MG_MODULE_LINES\n#line 1 \"mongoose/src/net_if_tun.c\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#if MG_ENABLE_TUN\n\n/* Amalgamated: #include \"common/cs_dbg.h\" */\n/* Amalgamated: #include \"common/cs_time.h\" */\n/* Amalgamated: #include \"mongoose/src/internal.h\" */\n/* Amalgamated: #include \"mongoose/src/net_if_tun.h\" */\n/* Amalgamated: #include \"mongoose/src/tun.h\" */\n/* Amalgamated: #include \"mongoose/src/util.h\" */\n\n#define MG_TCP_RECV_BUFFER_SIZE 1024\n#define MG_UDP_RECV_BUFFER_SIZE 1500\n\nvoid mg_tun_if_connect_tcp(struct mg_connection *nc,\n                           const union socket_address *sa) {\n  (void) nc;\n  (void) sa;\n}\n\nvoid mg_tun_if_connect_udp(struct mg_connection *nc) {\n  (void) nc;\n}\n\nint mg_tun_if_listen_tcp(struct mg_connection *nc, union socket_address *sa) {\n  (void) nc;\n  (void) sa;\n  return 0;\n}\n\nint mg_tun_if_listen_udp(struct mg_connection *nc, union socket_address *sa) {\n  (void) nc;\n  (void) sa;\n  return -1;\n}\n\nvoid mg_tun_if_tcp_send(struct mg_connection *nc, const void *buf, size_t len) {\n  struct mg_tun_client *client = (struct mg_tun_client *) nc->iface->data;\n  uint32_t stream_id = (uint32_t)(uintptr_t) nc->mgr_data;\n  struct mg_str msg = {(char *) buf, len};\n#if MG_ENABLE_HEXDUMP\n  char hex[512];\n  mg_hexdump(buf, len, hex, sizeof(hex));\n  LOG(LL_DEBUG, (\"sending to stream %zu:\\n%s\", stream_id, hex));\n#endif\n\n  mg_tun_send_frame(client->disp, stream_id, MG_TUN_DATA_FRAME, 0, msg);\n}\n\nvoid mg_tun_if_udp_send(struct mg_connection *nc, const void *buf, size_t len) {\n  (void) nc;\n  (void) buf;\n  (void) len;\n}\n\nvoid mg_tun_if_recved(struct mg_connection *nc, size_t len) {\n  (void) nc;\n  (void) len;\n}\n\nint mg_tun_if_create_conn(struct mg_connection *nc) {\n  (void) nc;\n  return 1;\n}\n\nvoid mg_tun_if_destroy_conn(struct mg_connection *nc) {\n  struct mg_tun_client *client = (struct mg_tun_client *) nc->iface->data;\n\n  if (nc->flags & MG_F_LISTENING) {\n    mg_tun_destroy_client(client);\n  } else if (client->disp) {\n    uint32_t stream_id = (uint32_t)(uintptr_t) nc->mgr_data;\n    struct mg_str msg = {NULL, 0};\n\n    LOG(LL_DEBUG, (\"closing %zu:\", stream_id));\n    mg_tun_send_frame(client->disp, stream_id, MG_TUN_DATA_FRAME,\n                      MG_TUN_F_END_STREAM, msg);\n  }\n}\n\n/* Associate a socket to a connection. */\nvoid mg_tun_if_sock_set(struct mg_connection *nc, sock_t sock) {\n  (void) nc;\n  (void) sock;\n}\n\nvoid mg_tun_if_init(struct mg_iface *iface) {\n  (void) iface;\n}\n\nvoid mg_tun_if_free(struct mg_iface *iface) {\n  (void) iface;\n}\n\nvoid mg_tun_if_add_conn(struct mg_connection *nc) {\n  nc->sock = INVALID_SOCKET;\n}\n\nvoid mg_tun_if_remove_conn(struct mg_connection *nc) {\n  (void) nc;\n}\n\ntime_t mg_tun_if_poll(struct mg_iface *iface, int timeout_ms) {\n  (void) iface;\n  (void) timeout_ms;\n  return (time_t) cs_time();\n}\n\nvoid mg_tun_if_get_conn_addr(struct mg_connection *nc, int remote,\n                             union socket_address *sa) {\n  (void) nc;\n  (void) remote;\n  (void) sa;\n}\n\nstruct mg_connection *mg_tun_if_find_conn(struct mg_tun_client *client,\n                                          uint32_t stream_id) {\n  struct mg_connection *nc = NULL;\n\n  for (nc = client->mgr->active_connections; nc != NULL; nc = nc->next) {\n    if (nc->iface != client->iface || (nc->flags & MG_F_LISTENING)) {\n      continue;\n    }\n    if (stream_id == (uint32_t)(uintptr_t) nc->mgr_data) {\n      return nc;\n    }\n  }\n\n  if (stream_id > client->last_stream_id) {\n    /* create a new connection */\n    LOG(LL_DEBUG, (\"new stream 0x%lx, accepting\", stream_id));\n    nc = mg_if_accept_new_conn(client->listener);\n    nc->mgr_data = (void *) (uintptr_t) stream_id;\n    client->last_stream_id = stream_id;\n  } else {\n    LOG(LL_DEBUG, (\"Ignoring stream 0x%lx (last_stream_id 0x%lx)\", stream_id,\n                   client->last_stream_id));\n  }\n\n  return nc;\n}\n\n/* clang-format off */\n#define MG_TUN_IFACE_VTABLE                                             \\\n  {                                                                     \\\n    mg_tun_if_init,                                                     \\\n    mg_tun_if_free,                                                     \\\n    mg_tun_if_add_conn,                                                 \\\n    mg_tun_if_remove_conn,                                              \\\n    mg_tun_if_poll,                                                     \\\n    mg_tun_if_listen_tcp,                                               \\\n    mg_tun_if_listen_udp,                                               \\\n    mg_tun_if_connect_tcp,                                              \\\n    mg_tun_if_connect_udp,                                              \\\n    mg_tun_if_tcp_send,                                                 \\\n    mg_tun_if_udp_send,                                                 \\\n    mg_tun_if_recved,                                                   \\\n    mg_tun_if_create_conn,                                              \\\n    mg_tun_if_destroy_conn,                                             \\\n    mg_tun_if_sock_set,                                                 \\\n    mg_tun_if_get_conn_addr,                                            \\\n  }\n/* clang-format on */\n\nconst struct mg_iface_vtable mg_tun_iface_vtable = MG_TUN_IFACE_VTABLE;\n\n#endif /* MG_ENABLE_TUN */\n#ifdef MG_MODULE_LINES\n#line 1 \"mongoose/src/ssl_if_openssl.c\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#if MG_ENABLE_SSL && MG_SSL_IF == MG_SSL_IF_OPENSSL\n\n#ifdef __APPLE__\n#pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n#endif\n\n#include <openssl/ssl.h>\n\nstruct mg_ssl_if_ctx {\n  SSL *ssl;\n  SSL_CTX *ssl_ctx;\n  struct mbuf psk;\n  size_t identity_len;\n};\n\nvoid mg_ssl_if_init() {\n  SSL_library_init();\n}\n\nenum mg_ssl_if_result mg_ssl_if_conn_accept(struct mg_connection *nc,\n                                            struct mg_connection *lc) {\n  struct mg_ssl_if_ctx *ctx =\n      (struct mg_ssl_if_ctx *) MG_CALLOC(1, sizeof(*ctx));\n  struct mg_ssl_if_ctx *lc_ctx = (struct mg_ssl_if_ctx *) lc->ssl_if_data;\n  nc->ssl_if_data = ctx;\n  if (ctx == NULL || lc_ctx == NULL) return MG_SSL_ERROR;\n  ctx->ssl_ctx = lc_ctx->ssl_ctx;\n  if ((ctx->ssl = SSL_new(ctx->ssl_ctx)) == NULL) {\n    return MG_SSL_ERROR;\n  }\n  return MG_SSL_OK;\n}\n\nstatic enum mg_ssl_if_result mg_use_cert(SSL_CTX *ctx, const char *cert,\n                                         const char *key, const char **err_msg);\nstatic enum mg_ssl_if_result mg_use_ca_cert(SSL_CTX *ctx, const char *cert);\nstatic enum mg_ssl_if_result mg_set_cipher_list(SSL_CTX *ctx, const char *cl);\nstatic enum mg_ssl_if_result mg_ssl_if_ossl_set_psk(struct mg_ssl_if_ctx *ctx,\n                                                    const char *identity,\n                                                    const char *key_str);\n\nenum mg_ssl_if_result mg_ssl_if_conn_init(\n    struct mg_connection *nc, const struct mg_ssl_if_conn_params *params,\n    const char **err_msg) {\n  struct mg_ssl_if_ctx *ctx =\n      (struct mg_ssl_if_ctx *) MG_CALLOC(1, sizeof(*ctx));\n  DBG((\"%p %s,%s,%s\", nc, (params->cert ? params->cert : \"\"),\n       (params->key ? params->key : \"\"),\n       (params->ca_cert ? params->ca_cert : \"\")));\n  if (ctx == NULL) {\n    MG_SET_PTRPTR(err_msg, \"Out of memory\");\n    return MG_SSL_ERROR;\n  }\n  nc->ssl_if_data = ctx;\n  if (nc->flags & MG_F_LISTENING) {\n    ctx->ssl_ctx = SSL_CTX_new(SSLv23_server_method());\n  } else {\n    ctx->ssl_ctx = SSL_CTX_new(SSLv23_client_method());\n  }\n  if (ctx->ssl_ctx == NULL) {\n    MG_SET_PTRPTR(err_msg, \"Failed to create SSL context\");\n    return MG_SSL_ERROR;\n  }\n\n  if (params->cert != NULL &&\n      mg_use_cert(ctx->ssl_ctx, params->cert, params->key, err_msg) !=\n          MG_SSL_OK) {\n    return MG_SSL_ERROR;\n  }\n\n  if (params->ca_cert != NULL &&\n      mg_use_ca_cert(ctx->ssl_ctx, params->ca_cert) != MG_SSL_OK) {\n    MG_SET_PTRPTR(err_msg, \"Invalid SSL CA cert\");\n    return MG_SSL_ERROR;\n  }\n\n  if (params->server_name != NULL) {\n#ifdef KR_VERSION\n    SSL_CTX_kr_set_verify_name(ctx->ssl_ctx, params->server_name);\n#else\n/* TODO(rojer): Implement server name verification on OpenSSL. */\n#endif\n  }\n\n  if (mg_set_cipher_list(ctx->ssl_ctx, params->cipher_suites) != MG_SSL_OK) {\n    MG_SET_PTRPTR(err_msg, \"Invalid cipher suite list\");\n    return MG_SSL_ERROR;\n  }\n\n  mbuf_init(&ctx->psk, 0);\n  if (mg_ssl_if_ossl_set_psk(ctx, params->psk_identity, params->psk_key) !=\n      MG_SSL_OK) {\n    MG_SET_PTRPTR(err_msg, \"Invalid PSK settings\");\n    return MG_SSL_ERROR;\n  }\n\n  if (!(nc->flags & MG_F_LISTENING) &&\n      (ctx->ssl = SSL_new(ctx->ssl_ctx)) == NULL) {\n    MG_SET_PTRPTR(err_msg, \"Failed to create SSL session\");\n    return MG_SSL_ERROR;\n  }\n\n  nc->flags |= MG_F_SSL;\n\n  return MG_SSL_OK;\n}\n\nstatic enum mg_ssl_if_result mg_ssl_if_ssl_err(struct mg_connection *nc,\n                                               int res) {\n  struct mg_ssl_if_ctx *ctx = (struct mg_ssl_if_ctx *) nc->ssl_if_data;\n  int err = SSL_get_error(ctx->ssl, res);\n  if (err == SSL_ERROR_WANT_READ) return MG_SSL_WANT_READ;\n  if (err == SSL_ERROR_WANT_WRITE) return MG_SSL_WANT_WRITE;\n  DBG((\"%p %p SSL error: %d %d\", nc, ctx->ssl_ctx, res, err));\n  nc->err = err;\n  return MG_SSL_ERROR;\n}\n\nenum mg_ssl_if_result mg_ssl_if_handshake(struct mg_connection *nc) {\n  struct mg_ssl_if_ctx *ctx = (struct mg_ssl_if_ctx *) nc->ssl_if_data;\n  int server_side = (nc->listener != NULL);\n  int res;\n  /* If descriptor is not yet set, do it now. */\n  if (SSL_get_fd(ctx->ssl) < 0) {\n    if (SSL_set_fd(ctx->ssl, nc->sock) != 1) return MG_SSL_ERROR;\n  }\n  res = server_side ? SSL_accept(ctx->ssl) : SSL_connect(ctx->ssl);\n  if (res != 1) return mg_ssl_if_ssl_err(nc, res);\n  return MG_SSL_OK;\n}\n\nint mg_ssl_if_read(struct mg_connection *nc, void *buf, size_t buf_size) {\n  struct mg_ssl_if_ctx *ctx = (struct mg_ssl_if_ctx *) nc->ssl_if_data;\n  int n = SSL_read(ctx->ssl, buf, buf_size);\n  DBG((\"%p %d -> %d\", nc, (int) buf_size, n));\n  if (n < 0) return mg_ssl_if_ssl_err(nc, n);\n  if (n == 0) nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n  return n;\n}\n\nint mg_ssl_if_write(struct mg_connection *nc, const void *data, size_t len) {\n  struct mg_ssl_if_ctx *ctx = (struct mg_ssl_if_ctx *) nc->ssl_if_data;\n  int n = SSL_write(ctx->ssl, data, len);\n  DBG((\"%p %d -> %d\", nc, (int) len, n));\n  if (n <= 0) return mg_ssl_if_ssl_err(nc, n);\n  return n;\n}\n\nvoid mg_ssl_if_conn_close_notify(struct mg_connection *nc) {\n  struct mg_ssl_if_ctx *ctx = (struct mg_ssl_if_ctx *) nc->ssl_if_data;\n  if (ctx == NULL) return;\n  SSL_shutdown(ctx->ssl);\n}\n\nvoid mg_ssl_if_conn_free(struct mg_connection *nc) {\n  struct mg_ssl_if_ctx *ctx = (struct mg_ssl_if_ctx *) nc->ssl_if_data;\n  if (ctx == NULL) return;\n  nc->ssl_if_data = NULL;\n  if (ctx->ssl != NULL) SSL_free(ctx->ssl);\n  if (ctx->ssl_ctx != NULL && nc->listener == NULL) SSL_CTX_free(ctx->ssl_ctx);\n  mbuf_free(&ctx->psk);\n  memset(ctx, 0, sizeof(*ctx));\n  MG_FREE(ctx);\n}\n\n/*\n * Cipher suite options used for TLS negotiation.\n * https://wiki.mozilla.org/Security/Server_Side_TLS#Recommended_configurations\n */\nstatic const char mg_s_cipher_list[] =\n#if defined(MG_SSL_CRYPTO_MODERN)\n    \"ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:\"\n    \"ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:\"\n    \"DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:\"\n    \"ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:\"\n    \"ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:\"\n    \"ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:\"\n    \"DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:\"\n    \"DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:\"\n    \"!aNULL:!eNULL:!EXPORT:!DES:!RC4:!3DES:!MD5:!PSK\"\n#elif defined(MG_SSL_CRYPTO_OLD)\n    \"ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:\"\n    \"ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:\"\n    \"DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:\"\n    \"ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:\"\n    \"ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:\"\n    \"ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:\"\n    \"DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:\"\n    \"DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:ECDHE-RSA-DES-CBC3-SHA:\"\n    \"ECDHE-ECDSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:\"\n    \"AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:DES-CBC3-SHA:\"\n    \"HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:\"\n    \"!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA\"\n#else /* Default - intermediate. */\n    \"ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:\"\n    \"ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:\"\n    \"DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:\"\n    \"ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:\"\n    \"ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:\"\n    \"ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:\"\n    \"DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:\"\n    \"DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:\"\n    \"AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:CAMELLIA:\"\n    \"DES-CBC3-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:\"\n    \"!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA\"\n#endif\n    ;\n\n/*\n * Default DH params for PFS cipher negotiation. This is a 2048-bit group.\n * Will be used if none are provided by the user in the certificate file.\n */\n#if !MG_DISABLE_PFS && !defined(KR_VERSION)\nstatic const char mg_s_default_dh_params[] =\n    \"\\\n-----BEGIN DH PARAMETERS-----\\n\\\nMIIBCAKCAQEAlvbgD/qh9znWIlGFcV0zdltD7rq8FeShIqIhkQ0C7hYFThrBvF2E\\n\\\nZ9bmgaP+sfQwGpVlv9mtaWjvERbu6mEG7JTkgmVUJrUt/wiRzwTaCXBqZkdUO8Tq\\n\\\n+E6VOEQAilstG90ikN1Tfo+K6+X68XkRUIlgawBTKuvKVwBhuvlqTGerOtnXWnrt\\n\\\nym//hd3cd5PBYGBix0i7oR4xdghvfR2WLVu0LgdThTBb6XP7gLd19cQ1JuBtAajZ\\n\\\nwMuPn7qlUkEFDIkAZy59/Hue/H2Q2vU/JsvVhHWCQBL4F1ofEAt50il6ZxR1QfFK\\n\\\n9VGKDC4oOgm9DlxwwBoC2FjqmvQlqVV3kwIBAg==\\n\\\n-----END DH PARAMETERS-----\\n\";\n#endif\n\nstatic enum mg_ssl_if_result mg_use_ca_cert(SSL_CTX *ctx, const char *cert) {\n  if (cert == NULL || strcmp(cert, \"*\") == 0) {\n    return MG_SSL_OK;\n  }\n  SSL_CTX_set_verify(ctx, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT, 0);\n  return SSL_CTX_load_verify_locations(ctx, cert, NULL) == 1 ? MG_SSL_OK\n                                                             : MG_SSL_ERROR;\n}\n\nstatic enum mg_ssl_if_result mg_use_cert(SSL_CTX *ctx, const char *cert,\n                                         const char *key,\n                                         const char **err_msg) {\n  if (key == NULL) key = cert;\n  if (cert == NULL || cert[0] == '\\0' || key == NULL || key[0] == '\\0') {\n    return MG_SSL_OK;\n  } else if (SSL_CTX_use_certificate_file(ctx, cert, 1) == 0) {\n    MG_SET_PTRPTR(err_msg, \"Invalid SSL cert\");\n    return MG_SSL_ERROR;\n  } else if (SSL_CTX_use_PrivateKey_file(ctx, key, 1) == 0) {\n    MG_SET_PTRPTR(err_msg, \"Invalid SSL key\");\n    return MG_SSL_ERROR;\n  } else if (SSL_CTX_use_certificate_chain_file(ctx, cert) == 0) {\n    MG_SET_PTRPTR(err_msg, \"Invalid CA bundle\");\n    return MG_SSL_ERROR;\n  } else {\n    SSL_CTX_set_mode(ctx, SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER);\n#if !MG_DISABLE_PFS && !defined(KR_VERSION)\n    BIO *bio = NULL;\n    DH *dh = NULL;\n\n    /* Try to read DH parameters from the cert/key file. */\n    bio = BIO_new_file(cert, \"r\");\n    if (bio != NULL) {\n      dh = PEM_read_bio_DHparams(bio, NULL, NULL, NULL);\n      BIO_free(bio);\n    }\n    /*\n     * If there are no DH params in the file, fall back to hard-coded ones.\n     * Not ideal, but better than nothing.\n     */\n    if (dh == NULL) {\n      bio = BIO_new_mem_buf((void *) mg_s_default_dh_params, -1);\n      dh = PEM_read_bio_DHparams(bio, NULL, NULL, NULL);\n      BIO_free(bio);\n    }\n    if (dh != NULL) {\n      SSL_CTX_set_tmp_dh(ctx, dh);\n      SSL_CTX_set_options(ctx, SSL_OP_SINGLE_DH_USE);\n      DH_free(dh);\n    }\n#if OPENSSL_VERSION_NUMBER > 0x10002000L\n    SSL_CTX_set_ecdh_auto(ctx, 1);\n#endif\n#endif\n  }\n  return MG_SSL_OK;\n}\n\nstatic enum mg_ssl_if_result mg_set_cipher_list(SSL_CTX *ctx, const char *cl) {\n  return (SSL_CTX_set_cipher_list(ctx, cl ? cl : mg_s_cipher_list) == 1\n              ? MG_SSL_OK\n              : MG_SSL_ERROR);\n}\n\n#ifndef KR_VERSION\nstatic unsigned int mg_ssl_if_ossl_psk_cb(SSL *ssl, const char *hint,\n                                          char *identity,\n                                          unsigned int max_identity_len,\n                                          unsigned char *psk,\n                                          unsigned int max_psk_len) {\n  struct mg_ssl_if_ctx *ctx =\n      (struct mg_ssl_if_ctx *) ssl->ctx->msg_callback_arg;\n  size_t key_len = ctx->psk.len - ctx->identity_len - 1;\n  DBG((\"hint: '%s'\", (hint ? hint : \"\")));\n  if (ctx->identity_len + 1 > max_identity_len) {\n    DBG((\"identity too long\"));\n    return 0;\n  }\n  if (key_len > max_psk_len) {\n    DBG((\"key too long\"));\n    return 0;\n  }\n  memcpy(identity, ctx->psk.buf, ctx->identity_len + 1);\n  memcpy(psk, ctx->psk.buf + ctx->identity_len + 1, key_len);\n  (void) ssl;\n  return key_len;\n}\n\nstatic enum mg_ssl_if_result mg_ssl_if_ossl_set_psk(struct mg_ssl_if_ctx *ctx,\n                                                    const char *identity,\n                                                    const char *key_str) {\n  unsigned char key[32];\n  size_t key_len;\n  size_t i = 0;\n  if (identity == NULL && key_str == NULL) return MG_SSL_OK;\n  if (identity == NULL || key_str == NULL) return MG_SSL_ERROR;\n  key_len = strlen(key_str);\n  if (key_len != 32 && key_len != 64) return MG_SSL_ERROR;\n  memset(key, 0, sizeof(key));\n  key_len = 0;\n  for (i = 0; key_str[i] != '\\0'; i++) {\n    unsigned char c;\n    char hc = tolower((int) key_str[i]);\n    if (hc >= '0' && hc <= '9') {\n      c = hc - '0';\n    } else if (hc >= 'a' && hc <= 'f') {\n      c = hc - 'a' + 0xa;\n    } else {\n      return MG_SSL_ERROR;\n    }\n    key_len = i / 2;\n    key[key_len] <<= 4;\n    key[key_len] |= c;\n  }\n  key_len++;\n  DBG((\"identity = '%s', key = (%u)\", identity, (unsigned int) key_len));\n  ctx->identity_len = strlen(identity);\n  mbuf_append(&ctx->psk, identity, ctx->identity_len + 1);\n  mbuf_append(&ctx->psk, key, key_len);\n  SSL_CTX_set_psk_client_callback(ctx->ssl_ctx, mg_ssl_if_ossl_psk_cb);\n  /* Hack: there is no field for us to keep this, so we use msg_callback_arg */\n  ctx->ssl_ctx->msg_callback_arg = ctx;\n  return MG_SSL_OK;\n}\n#else\nstatic enum mg_ssl_if_result mg_ssl_if_ossl_set_psk(struct mg_ssl_if_ctx *ctx,\n                                                    const char *identity,\n                                                    const char *key_str) {\n  (void) ctx;\n  (void) identity;\n  (void) key_str;\n  /* Krypton does not support PSK. */\n  return MG_SSL_ERROR;\n}\n#endif /* defined(KR_VERSION) */\n\nconst char *mg_set_ssl(struct mg_connection *nc, const char *cert,\n                       const char *ca_cert) {\n  const char *err_msg = NULL;\n  struct mg_ssl_if_conn_params params;\n  memset(&params, 0, sizeof(params));\n  params.cert = cert;\n  params.ca_cert = ca_cert;\n  if (mg_ssl_if_conn_init(nc, &params, &err_msg) != MG_SSL_OK) {\n    return err_msg;\n  }\n  return NULL;\n}\n\n#endif /* MG_ENABLE_SSL && MG_SSL_IF == MG_SSL_IF_OPENSSL */\n#ifdef MG_MODULE_LINES\n#line 1 \"mongoose/src/ssl_if_mbedtls.c\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#if MG_ENABLE_SSL && MG_SSL_IF == MG_SSL_IF_MBEDTLS\n\n#include <mbedtls/debug.h>\n#include <mbedtls/ecp.h>\n#include <mbedtls/platform.h>\n#include <mbedtls/ssl.h>\n#include <mbedtls/x509_crt.h>\n\nstatic void mg_ssl_mbed_log(void *ctx, int level, const char *file, int line,\n                            const char *str) {\n  enum cs_log_level cs_level;\n  switch (level) {\n    case 1:\n      cs_level = LL_ERROR;\n      break;\n    case 2:\n    case 3:\n      cs_level = LL_DEBUG;\n      break;\n    default:\n      cs_level = LL_VERBOSE_DEBUG;\n  }\n  /* mbedTLS passes strings with \\n at the end, strip it. */\n  LOG(cs_level, (\"%p %.*s\", ctx, (int) (strlen(str) - 1), str));\n  (void) file;\n  (void) line;\n}\n\nstruct mg_ssl_if_ctx {\n  mbedtls_ssl_config *conf;\n  mbedtls_ssl_context *ssl;\n  mbedtls_x509_crt *cert;\n  mbedtls_pk_context *key;\n  mbedtls_x509_crt *ca_cert;\n  struct mbuf cipher_suites;\n};\n\n/* Must be provided by the platform. ctx is struct mg_connection. */\nextern int mg_ssl_if_mbed_random(void *ctx, unsigned char *buf, size_t len);\n\nvoid mg_ssl_if_init() {\n}\n\nenum mg_ssl_if_result mg_ssl_if_conn_accept(struct mg_connection *nc,\n                                            struct mg_connection *lc) {\n  struct mg_ssl_if_ctx *ctx =\n      (struct mg_ssl_if_ctx *) MG_CALLOC(1, sizeof(*ctx));\n  struct mg_ssl_if_ctx *lc_ctx = (struct mg_ssl_if_ctx *) lc->ssl_if_data;\n  nc->ssl_if_data = ctx;\n  if (ctx == NULL || lc_ctx == NULL) return MG_SSL_ERROR;\n  ctx->ssl = (mbedtls_ssl_context *) MG_CALLOC(1, sizeof(*ctx->ssl));\n  if (mbedtls_ssl_setup(ctx->ssl, lc_ctx->conf) != 0) {\n    return MG_SSL_ERROR;\n  }\n  return MG_SSL_OK;\n}\n\nstatic enum mg_ssl_if_result mg_use_cert(struct mg_ssl_if_ctx *ctx,\n                                         const char *cert, const char *key,\n                                         const char **err_msg);\nstatic enum mg_ssl_if_result mg_use_ca_cert(struct mg_ssl_if_ctx *ctx,\n                                            const char *cert);\nstatic enum mg_ssl_if_result mg_set_cipher_list(struct mg_ssl_if_ctx *ctx,\n                                                const char *ciphers);\nstatic enum mg_ssl_if_result mg_ssl_if_mbed_set_psk(struct mg_ssl_if_ctx *ctx,\n                                                    const char *identity,\n                                                    const char *key);\n\nenum mg_ssl_if_result mg_ssl_if_conn_init(\n    struct mg_connection *nc, const struct mg_ssl_if_conn_params *params,\n    const char **err_msg) {\n  struct mg_ssl_if_ctx *ctx =\n      (struct mg_ssl_if_ctx *) MG_CALLOC(1, sizeof(*ctx));\n  DBG((\"%p %s,%s,%s\", nc, (params->cert ? params->cert : \"\"),\n       (params->key ? params->key : \"\"),\n       (params->ca_cert ? params->ca_cert : \"\")));\n\n  if (ctx == NULL) {\n    MG_SET_PTRPTR(err_msg, \"Out of memory\");\n    return MG_SSL_ERROR;\n  }\n  nc->ssl_if_data = ctx;\n  ctx->conf = (mbedtls_ssl_config *) MG_CALLOC(1, sizeof(*ctx->conf));\n  mbuf_init(&ctx->cipher_suites, 0);\n  mbedtls_ssl_config_init(ctx->conf);\n  mbedtls_ssl_conf_dbg(ctx->conf, mg_ssl_mbed_log, nc);\n  if (mbedtls_ssl_config_defaults(\n          ctx->conf, (nc->flags & MG_F_LISTENING ? MBEDTLS_SSL_IS_SERVER\n                                                 : MBEDTLS_SSL_IS_CLIENT),\n          MBEDTLS_SSL_TRANSPORT_STREAM, MBEDTLS_SSL_PRESET_DEFAULT) != 0) {\n    MG_SET_PTRPTR(err_msg, \"Failed to init SSL config\");\n    return MG_SSL_ERROR;\n  }\n\n  /* TLS 1.2 and up */\n  mbedtls_ssl_conf_min_version(ctx->conf, MBEDTLS_SSL_MAJOR_VERSION_3,\n                               MBEDTLS_SSL_MINOR_VERSION_3);\n  mbedtls_ssl_conf_rng(ctx->conf, mg_ssl_if_mbed_random, nc);\n\n  if (params->cert != NULL &&\n      mg_use_cert(ctx, params->cert, params->key, err_msg) != MG_SSL_OK) {\n    return MG_SSL_ERROR;\n  }\n\n  if (params->ca_cert != NULL &&\n      mg_use_ca_cert(ctx, params->ca_cert) != MG_SSL_OK) {\n    MG_SET_PTRPTR(err_msg, \"Invalid SSL CA cert\");\n    return MG_SSL_ERROR;\n  }\n\n  if (mg_set_cipher_list(ctx, params->cipher_suites) != MG_SSL_OK) {\n    MG_SET_PTRPTR(err_msg, \"Invalid cipher suite list\");\n    return MG_SSL_ERROR;\n  }\n\n  if (mg_ssl_if_mbed_set_psk(ctx, params->psk_identity, params->psk_key) !=\n      MG_SSL_OK) {\n    MG_SET_PTRPTR(err_msg, \"Invalid PSK settings\");\n    return MG_SSL_ERROR;\n  }\n\n  if (!(nc->flags & MG_F_LISTENING)) {\n    ctx->ssl = (mbedtls_ssl_context *) MG_CALLOC(1, sizeof(*ctx->ssl));\n    mbedtls_ssl_init(ctx->ssl);\n    if (mbedtls_ssl_setup(ctx->ssl, ctx->conf) != 0) {\n      MG_SET_PTRPTR(err_msg, \"Failed to create SSL session\");\n      return MG_SSL_ERROR;\n    }\n    if (params->server_name != NULL &&\n        mbedtls_ssl_set_hostname(ctx->ssl, params->server_name) != 0) {\n      return MG_SSL_ERROR;\n    }\n  }\n\n#ifdef MG_SSL_IF_MBEDTLS_MAX_FRAG_LEN\n  if (mbedtls_ssl_conf_max_frag_len(ctx->conf,\n#if MG_SSL_IF_MBEDTLS_MAX_FRAG_LEN == 512\n                                    MBEDTLS_SSL_MAX_FRAG_LEN_512\n#elif MG_SSL_IF_MBEDTLS_MAX_FRAG_LEN == 1024\n                                    MBEDTLS_SSL_MAX_FRAG_LEN_1024\n#elif MG_SSL_IF_MBEDTLS_MAX_FRAG_LEN == 2048\n                                    MBEDTLS_SSL_MAX_FRAG_LEN_2048\n#elif MG_SSL_IF_MBEDTLS_MAX_FRAG_LEN == 4096\n                                    MBEDTLS_SSL_MAX_FRAG_LEN_4096\n#else\n#error Invalid MG_SSL_IF_MBEDTLS_MAX_FRAG_LEN\n#endif\n                                    ) != 0) {\n    return MG_SSL_ERROR;\n  }\n#endif\n\n  nc->flags |= MG_F_SSL;\n\n  return MG_SSL_OK;\n}\n\n#if MG_NET_IF == MG_NET_IF_LWIP_LOW_LEVEL\nint ssl_socket_send(void *ctx, const unsigned char *buf, size_t len);\nint ssl_socket_recv(void *ctx, unsigned char *buf, size_t len);\n#else\nstatic int ssl_socket_send(void *ctx, const unsigned char *buf, size_t len) {\n  struct mg_connection *nc = (struct mg_connection *) ctx;\n  int n = (int) MG_SEND_FUNC(nc->sock, buf, len, 0);\n  LOG(LL_DEBUG, (\"%p %d -> %d\", nc, (int) len, n));\n  if (n >= 0) return n;\n  n = mg_get_errno();\n  return ((n == EAGAIN || n == EINPROGRESS) ? MBEDTLS_ERR_SSL_WANT_WRITE : -1);\n}\n\nstatic int ssl_socket_recv(void *ctx, unsigned char *buf, size_t len) {\n  struct mg_connection *nc = (struct mg_connection *) ctx;\n  int n = (int) MG_RECV_FUNC(nc->sock, buf, len, 0);\n  LOG(LL_DEBUG, (\"%p %d <- %d\", nc, (int) len, n));\n  if (n >= 0) return n;\n  n = mg_get_errno();\n  return ((n == EAGAIN || n == EINPROGRESS) ? MBEDTLS_ERR_SSL_WANT_READ : -1);\n}\n#endif\n\nstatic enum mg_ssl_if_result mg_ssl_if_mbed_err(struct mg_connection *nc,\n                                                int ret) {\n  if (ret == MBEDTLS_ERR_SSL_WANT_READ) return MG_SSL_WANT_READ;\n  if (ret == MBEDTLS_ERR_SSL_WANT_WRITE) return MG_SSL_WANT_WRITE;\n  if (ret !=\n      MBEDTLS_ERR_SSL_PEER_CLOSE_NOTIFY) { /* CLOSE_NOTIFY = Normal shutdown */\n    LOG(LL_ERROR, (\"%p SSL error: %d\", nc, ret));\n  }\n  nc->err = ret;\n  nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n  return MG_SSL_ERROR;\n}\n\nstatic void mg_ssl_if_mbed_free_certs_and_keys(struct mg_ssl_if_ctx *ctx) {\n  if (ctx->cert != NULL) {\n    mbedtls_x509_crt_free(ctx->cert);\n    MG_FREE(ctx->cert);\n    ctx->cert = NULL;\n    mbedtls_pk_free(ctx->key);\n    MG_FREE(ctx->key);\n    ctx->key = NULL;\n  }\n  if (ctx->ca_cert != NULL) {\n    mbedtls_ssl_conf_ca_chain(ctx->conf, NULL, NULL);\n    mbedtls_x509_crt_free(ctx->ca_cert);\n    MG_FREE(ctx->ca_cert);\n    ctx->ca_cert = NULL;\n  }\n}\n\nenum mg_ssl_if_result mg_ssl_if_handshake(struct mg_connection *nc) {\n  struct mg_ssl_if_ctx *ctx = (struct mg_ssl_if_ctx *) nc->ssl_if_data;\n  int err;\n  /* If bio is not yet set, do it now. */\n  if (ctx->ssl->p_bio == NULL) {\n    mbedtls_ssl_set_bio(ctx->ssl, nc, ssl_socket_send, ssl_socket_recv, NULL);\n  }\n  err = mbedtls_ssl_handshake(ctx->ssl);\n  if (err != 0) return mg_ssl_if_mbed_err(nc, err);\n#ifdef MG_SSL_IF_MBEDTLS_FREE_CERTS\n  /*\n   * Free the peer certificate, we don't need it after handshake.\n   * Note that this effectively disables renegotiation.\n   */\n  mbedtls_x509_crt_free(ctx->ssl->session->peer_cert);\n  mbedtls_free(ctx->ssl->session->peer_cert);\n  ctx->ssl->session->peer_cert = NULL;\n  /* On a client connection we can also free our own and CA certs. */\n  if (nc->listener == NULL) {\n    if (ctx->conf->key_cert != NULL) {\n      /* Note that this assumes one key_cert entry, which matches our init. */\n      MG_FREE(ctx->conf->key_cert);\n      ctx->conf->key_cert = NULL;\n    }\n    mbedtls_ssl_conf_ca_chain(ctx->conf, NULL, NULL);\n    mg_ssl_if_mbed_free_certs_and_keys(ctx);\n  }\n#endif\n  return MG_SSL_OK;\n}\n\nint mg_ssl_if_read(struct mg_connection *nc, void *buf, size_t buf_size) {\n  struct mg_ssl_if_ctx *ctx = (struct mg_ssl_if_ctx *) nc->ssl_if_data;\n  int n = mbedtls_ssl_read(ctx->ssl, (unsigned char *) buf, buf_size);\n  DBG((\"%p %d -> %d\", nc, (int) buf_size, n));\n  if (n < 0) return mg_ssl_if_mbed_err(nc, n);\n  if (n == 0) nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n  return n;\n}\n\nint mg_ssl_if_write(struct mg_connection *nc, const void *data, size_t len) {\n  struct mg_ssl_if_ctx *ctx = (struct mg_ssl_if_ctx *) nc->ssl_if_data;\n  int n = mbedtls_ssl_write(ctx->ssl, (const unsigned char *) data, len);\n  DBG((\"%p %d -> %d\", nc, (int) len, n));\n  if (n < 0) return mg_ssl_if_mbed_err(nc, n);\n  return n;\n}\n\nvoid mg_ssl_if_conn_close_notify(struct mg_connection *nc) {\n  struct mg_ssl_if_ctx *ctx = (struct mg_ssl_if_ctx *) nc->ssl_if_data;\n  if (ctx == NULL) return;\n  mbedtls_ssl_close_notify(ctx->ssl);\n}\n\nvoid mg_ssl_if_conn_free(struct mg_connection *nc) {\n  struct mg_ssl_if_ctx *ctx = (struct mg_ssl_if_ctx *) nc->ssl_if_data;\n  if (ctx == NULL) return;\n  nc->ssl_if_data = NULL;\n  if (ctx->ssl != NULL) {\n    mbedtls_ssl_free(ctx->ssl);\n    MG_FREE(ctx->ssl);\n  }\n  mg_ssl_if_mbed_free_certs_and_keys(ctx);\n  if (ctx->conf != NULL) {\n    mbedtls_ssl_config_free(ctx->conf);\n    MG_FREE(ctx->conf);\n  }\n  mbuf_free(&ctx->cipher_suites);\n  memset(ctx, 0, sizeof(*ctx));\n  MG_FREE(ctx);\n}\n\nstatic enum mg_ssl_if_result mg_use_ca_cert(struct mg_ssl_if_ctx *ctx,\n                                            const char *ca_cert) {\n  if (ca_cert == NULL || strcmp(ca_cert, \"*\") == 0) {\n    return MG_SSL_OK;\n  }\n  ctx->ca_cert = (mbedtls_x509_crt *) MG_CALLOC(1, sizeof(*ctx->ca_cert));\n  mbedtls_x509_crt_init(ctx->ca_cert);\n  if (mbedtls_x509_crt_parse_file(ctx->ca_cert, ca_cert) != 0) {\n    return MG_SSL_ERROR;\n  }\n  mbedtls_ssl_conf_ca_chain(ctx->conf, ctx->ca_cert, NULL);\n  mbedtls_ssl_conf_authmode(ctx->conf, MBEDTLS_SSL_VERIFY_REQUIRED);\n  return MG_SSL_OK;\n}\n\nstatic enum mg_ssl_if_result mg_use_cert(struct mg_ssl_if_ctx *ctx,\n                                         const char *cert, const char *key,\n                                         const char **err_msg) {\n  if (key == NULL) key = cert;\n  if (cert == NULL || cert[0] == '\\0' || key == NULL || key[0] == '\\0') {\n    return MG_SSL_OK;\n  }\n  ctx->cert = (mbedtls_x509_crt *) MG_CALLOC(1, sizeof(*ctx->cert));\n  mbedtls_x509_crt_init(ctx->cert);\n  ctx->key = (mbedtls_pk_context *) MG_CALLOC(1, sizeof(*ctx->key));\n  mbedtls_pk_init(ctx->key);\n  if (mbedtls_x509_crt_parse_file(ctx->cert, cert) != 0) {\n    MG_SET_PTRPTR(err_msg, \"Invalid SSL cert\");\n    return MG_SSL_ERROR;\n  }\n  if (mbedtls_pk_parse_keyfile(ctx->key, key, NULL) != 0) {\n    MG_SET_PTRPTR(err_msg, \"Invalid SSL key\");\n    return MG_SSL_ERROR;\n  }\n  if (mbedtls_ssl_conf_own_cert(ctx->conf, ctx->cert, ctx->key) != 0) {\n    MG_SET_PTRPTR(err_msg, \"Invalid SSL key or cert\");\n    return MG_SSL_ERROR;\n  }\n  return MG_SSL_OK;\n}\n\nstatic const int mg_s_cipher_list[] = {\n    MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,\n    MBEDTLS_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,\n    MBEDTLS_TLS_DHE_RSA_WITH_AES_128_GCM_SHA256,\n    MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256,\n    MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256,\n    MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256,\n    MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA,\n    MBEDTLS_TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256,\n    MBEDTLS_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256,\n    MBEDTLS_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA,\n    MBEDTLS_TLS_RSA_WITH_AES_128_GCM_SHA256,\n    MBEDTLS_TLS_RSA_WITH_AES_128_CBC_SHA256,\n    MBEDTLS_TLS_RSA_WITH_AES_128_CBC_SHA, 0};\n\n/*\n * Ciphers can be specified as a colon-separated list of cipher suite names.\n * These can be found in\n * https://github.com/ARMmbed/mbedtls/blob/development/library/ssl_ciphersuites.c#L267\n * E.g.: TLS-ECDHE-ECDSA-WITH-AES-128-GCM-SHA256:TLS-DHE-RSA-WITH-AES-256-CCM\n */\nstatic enum mg_ssl_if_result mg_set_cipher_list(struct mg_ssl_if_ctx *ctx,\n                                                const char *ciphers) {\n  if (ciphers != NULL) {\n    int l, id;\n    const char *s = ciphers, *e;\n    char tmp[50];\n    while (s != NULL) {\n      e = strchr(s, ':');\n      l = (e != NULL ? (e - s) : (int) strlen(s));\n      strncpy(tmp, s, l);\n      tmp[l] = '\\0';\n      id = mbedtls_ssl_get_ciphersuite_id(tmp);\n      DBG((\"%s -> %04x\", tmp, id));\n      if (id != 0) {\n        mbuf_append(&ctx->cipher_suites, &id, sizeof(id));\n      }\n      s = (e != NULL ? e + 1 : NULL);\n    }\n    if (ctx->cipher_suites.len == 0) return MG_SSL_ERROR;\n    id = 0;\n    mbuf_append(&ctx->cipher_suites, &id, sizeof(id));\n    mbuf_trim(&ctx->cipher_suites);\n    mbedtls_ssl_conf_ciphersuites(ctx->conf,\n                                  (const int *) ctx->cipher_suites.buf);\n  } else {\n    mbedtls_ssl_conf_ciphersuites(ctx->conf, mg_s_cipher_list);\n  }\n  return MG_SSL_OK;\n}\n\nstatic enum mg_ssl_if_result mg_ssl_if_mbed_set_psk(struct mg_ssl_if_ctx *ctx,\n                                                    const char *identity,\n                                                    const char *key_str) {\n  unsigned char key[32];\n  size_t key_len;\n  if (identity == NULL && key_str == NULL) return MG_SSL_OK;\n  if (identity == NULL || key_str == NULL) return MG_SSL_ERROR;\n  key_len = strlen(key_str);\n  if (key_len != 32 && key_len != 64) return MG_SSL_ERROR;\n  size_t i = 0;\n  memset(key, 0, sizeof(key));\n  key_len = 0;\n  for (i = 0; key_str[i] != '\\0'; i++) {\n    unsigned char c;\n    char hc = tolower((int) key_str[i]);\n    if (hc >= '0' && hc <= '9') {\n      c = hc - '0';\n    } else if (hc >= 'a' && hc <= 'f') {\n      c = hc - 'a' + 0xa;\n    } else {\n      return MG_SSL_ERROR;\n    }\n    key_len = i / 2;\n    key[key_len] <<= 4;\n    key[key_len] |= c;\n  }\n  key_len++;\n  DBG((\"identity = '%s', key = (%u)\", identity, (unsigned int) key_len));\n  /* mbedTLS makes copies of psk and identity. */\n  if (mbedtls_ssl_conf_psk(ctx->conf, (const unsigned char *) key, key_len,\n                           (const unsigned char *) identity,\n                           strlen(identity)) != 0) {\n    return MG_SSL_ERROR;\n  }\n  return MG_SSL_OK;\n}\n\nconst char *mg_set_ssl(struct mg_connection *nc, const char *cert,\n                       const char *ca_cert) {\n  const char *err_msg = NULL;\n  struct mg_ssl_if_conn_params params;\n  memset(&params, 0, sizeof(params));\n  params.cert = cert;\n  params.ca_cert = ca_cert;\n  if (mg_ssl_if_conn_init(nc, &params, &err_msg) != MG_SSL_OK) {\n    return err_msg;\n  }\n  return NULL;\n}\n\n/* Lazy RNG. Warning: it would be a bad idea to do this in production! */\n#ifdef MG_SSL_MBED_DUMMY_RANDOM\nint mg_ssl_if_mbed_random(void *ctx, unsigned char *buf, size_t len) {\n  (void) ctx;\n  while (len--) *buf++ = rand();\n  return 0;\n}\n#endif\n\n#endif /* MG_ENABLE_SSL && MG_SSL_IF == MG_SSL_IF_MBEDTLS */\n#ifdef MG_MODULE_LINES\n#line 1 \"mongoose/src/uri.c\"\n#endif\n/*\n * Copyright (c) 2014 Cesanta Software Limited\n * All rights reserved\n */\n\n/* Amalgamated: #include \"mongoose/src/internal.h\" */\n/* Amalgamated: #include \"mongoose/src/uri.h\" */\n\n/*\n * scan string until `sep`, keeping track of component boundaries in `res`.\n *\n * `p` will point to the char after the separator or it will be `end`.\n */\nstatic void parse_uri_component(const char **p, const char *end, char sep,\n                                struct mg_str *res) {\n  res->p = *p;\n  for (; *p < end; (*p)++) {\n    if (**p == sep) {\n      break;\n    }\n  }\n  res->len = (*p) - res->p;\n  if (*p < end) (*p)++;\n}\n\nint mg_parse_uri(struct mg_str uri, struct mg_str *scheme,\n                 struct mg_str *user_info, struct mg_str *host,\n                 unsigned int *port, struct mg_str *path, struct mg_str *query,\n                 struct mg_str *fragment) {\n  struct mg_str rscheme = {0, 0}, ruser_info = {0, 0}, rhost = {0, 0},\n                rpath = {0, 0}, rquery = {0, 0}, rfragment = {0, 0};\n  unsigned int rport = 0;\n  enum {\n    P_START,\n    P_SCHEME_OR_PORT,\n    P_USER_INFO,\n    P_HOST,\n    P_PORT,\n    P_REST\n  } state = P_START;\n\n  const char *p = uri.p, *end = p + uri.len;\n  while (p < end) {\n    switch (state) {\n      case P_START:\n        /*\n         * expecting on of:\n         * - `scheme://xxxx`\n         * - `xxxx:port`\n         * - `xxxx/path`\n         */\n        for (; p < end; p++) {\n          if (*p == ':') {\n            state = P_SCHEME_OR_PORT;\n            break;\n          } else if (*p == '/') {\n            state = P_REST;\n            break;\n          }\n        }\n        if (state == P_START || state == P_REST) {\n          rhost.p = uri.p;\n          rhost.len = p - uri.p;\n        }\n        break;\n      case P_SCHEME_OR_PORT:\n        if (end - p >= 3 && strncmp(p, \"://\", 3) == 0) {\n          rscheme.p = uri.p;\n          rscheme.len = p - uri.p;\n          state = P_USER_INFO;\n          p += 2; /* point to last separator char */\n        } else {\n          rhost.p = uri.p;\n          rhost.len = p - uri.p;\n          state = P_PORT;\n        }\n        break;\n      case P_USER_INFO:\n        p++;\n        ruser_info.p = p;\n        for (; p < end; p++) {\n          if (*p == '@') {\n            state = P_HOST;\n            break;\n          } else if (*p == '/') {\n            break;\n          }\n        }\n        if (p == end || *p == '/') {\n          /* backtrack and parse as host */\n          state = P_HOST;\n          p = ruser_info.p;\n        }\n        ruser_info.len = p - ruser_info.p;\n        break;\n      case P_HOST:\n        if (*p == '@') p++;\n        rhost.p = p;\n        for (; p < end; p++) {\n          if (*p == ':') {\n            state = P_PORT;\n            break;\n          } else if (*p == '/') {\n            state = P_REST;\n            break;\n          }\n        }\n        rhost.len = p - rhost.p;\n        break;\n      case P_PORT:\n        p++;\n        for (; p < end; p++) {\n          if (*p == '/') {\n            state = P_REST;\n            break;\n          }\n          rport *= 10;\n          rport += *p - '0';\n        }\n        break;\n      case P_REST:\n        /* `p` points to separator. `path` includes the separator */\n        parse_uri_component(&p, end, '?', &rpath);\n        parse_uri_component(&p, end, '#', &rquery);\n        parse_uri_component(&p, end, '\\0', &rfragment);\n        break;\n    }\n  }\n\n  if (scheme != 0) *scheme = rscheme;\n  if (user_info != 0) *user_info = ruser_info;\n  if (host != 0) *host = rhost;\n  if (port != 0) *port = rport;\n  if (path != 0) *path = rpath;\n  if (query != 0) *query = rquery;\n  if (fragment != 0) *fragment = rfragment;\n\n  return 0;\n}\n\n/* Normalize the URI path. Remove/resolve \".\" and \"..\". */\nint mg_normalize_uri_path(const struct mg_str *in, struct mg_str *out) {\n  const char *s = in->p, *se = s + in->len;\n  char *cp = (char *) out->p, *d;\n\n  if (in->len == 0 || *s != '/') {\n    out->len = 0;\n    return 0;\n  }\n\n  d = cp;\n\n  while (s < se) {\n    const char *next = s;\n    struct mg_str component;\n    parse_uri_component(&next, se, '/', &component);\n    if (mg_vcmp(&component, \".\") == 0) {\n      /* Yum. */\n    } else if (mg_vcmp(&component, \"..\") == 0) {\n      /* Backtrack to previous slash. */\n      if (d > cp + 1 && *(d - 1) == '/') d--;\n      while (d > cp && *(d - 1) != '/') d--;\n    } else {\n      memmove(d, s, next - s);\n      d += next - s;\n    }\n    s = next;\n  }\n  if (d == cp) *d++ = '/';\n\n  out->p = cp;\n  out->len = d - cp;\n  return 1;\n}\n#ifdef MG_MODULE_LINES\n#line 1 \"mongoose/src/http.c\"\n#endif\n/*\n * Copyright (c) 2014 Cesanta Software Limited\n * All rights reserved\n */\n\n#if MG_ENABLE_HTTP\n\n/* Amalgamated: #include \"common/md5.h\" */\n/* Amalgamated: #include \"common/sha1.h\" */\n/* Amalgamated: #include \"mongoose/src/internal.h\" */\n/* Amalgamated: #include \"mongoose/src/util.h\" */\n\nstatic const char *mg_version_header = \"Mongoose/\" MG_VERSION;\n\nenum mg_http_proto_data_type { DATA_NONE, DATA_FILE, DATA_PUT };\n\nstruct mg_http_proto_data_file {\n  FILE *fp;      /* Opened file. */\n  int64_t cl;    /* Content-Length. How many bytes to send. */\n  int64_t sent;  /* How many bytes have been already sent. */\n  int keepalive; /* Keep connection open after sending. */\n  enum mg_http_proto_data_type type;\n};\n\n#if MG_ENABLE_HTTP_CGI\nstruct mg_http_proto_data_cgi {\n  struct mg_connection *cgi_nc;\n};\n#endif\n\nstruct mg_http_proto_data_chuncked {\n  int64_t body_len; /* How many bytes of chunked body was reassembled. */\n};\n\nstruct mg_http_endpoint {\n  struct mg_http_endpoint *next;\n  const char *name;\n  size_t name_len;\n  mg_event_handler_t handler;\n#if MG_ENABLE_CALLBACK_USERDATA\n  void *user_data;\n#endif\n};\n\nenum mg_http_multipart_stream_state {\n  MPS_BEGIN,\n  MPS_WAITING_FOR_BOUNDARY,\n  MPS_WAITING_FOR_CHUNK,\n  MPS_GOT_CHUNK,\n  MPS_GOT_BOUNDARY,\n  MPS_FINALIZE,\n  MPS_FINISHED\n};\n\nstruct mg_http_multipart_stream {\n  const char *boundary;\n  int boundary_len;\n  const char *var_name;\n  const char *file_name;\n  void *user_data;\n  int prev_io_len;\n  enum mg_http_multipart_stream_state state;\n  int processing_part;\n};\n\nstruct mg_reverse_proxy_data {\n  struct mg_connection *linked_conn;\n};\n\nstruct mg_http_proto_data {\n#if MG_ENABLE_FILESYSTEM\n  struct mg_http_proto_data_file file;\n#endif\n#if MG_ENABLE_HTTP_CGI\n  struct mg_http_proto_data_cgi cgi;\n#endif\n#if MG_ENABLE_HTTP_STREAMING_MULTIPART\n  struct mg_http_multipart_stream mp_stream;\n#endif\n  struct mg_http_proto_data_chuncked chunk;\n  struct mg_http_endpoint *endpoints;\n  mg_event_handler_t endpoint_handler;\n  struct mg_reverse_proxy_data reverse_proxy_data;\n};\n\nstatic void mg_http_conn_destructor(void *proto_data);\nstruct mg_connection *mg_connect_http_base(\n    struct mg_mgr *mgr, MG_CB(mg_event_handler_t ev_handler, void *user_data),\n    struct mg_connect_opts opts, const char *schema, const char *schema_ssl,\n    const char *url, const char **path, char **user, char **pass, char **addr);\n\nstatic struct mg_http_proto_data *mg_http_get_proto_data(\n    struct mg_connection *c) {\n  if (c->proto_data == NULL) {\n    c->proto_data = MG_CALLOC(1, sizeof(struct mg_http_proto_data));\n    c->proto_data_destructor = mg_http_conn_destructor;\n  }\n\n  return (struct mg_http_proto_data *) c->proto_data;\n}\n\n#if MG_ENABLE_HTTP_STREAMING_MULTIPART\nstatic void mg_http_free_proto_data_mp_stream(\n    struct mg_http_multipart_stream *mp) {\n  MG_FREE((void *) mp->boundary);\n  MG_FREE((void *) mp->var_name);\n  MG_FREE((void *) mp->file_name);\n  memset(mp, 0, sizeof(*mp));\n}\n#endif\n\n#if MG_ENABLE_FILESYSTEM\nstatic void mg_http_free_proto_data_file(struct mg_http_proto_data_file *d) {\n  if (d != NULL) {\n    if (d->fp != NULL) {\n      fclose(d->fp);\n    }\n    memset(d, 0, sizeof(struct mg_http_proto_data_file));\n  }\n}\n#endif\n\nstatic void mg_http_free_proto_data_endpoints(struct mg_http_endpoint **ep) {\n  struct mg_http_endpoint *current = *ep;\n\n  while (current != NULL) {\n    struct mg_http_endpoint *tmp = current->next;\n    MG_FREE((void *) current->name);\n    MG_FREE(current);\n    current = tmp;\n  }\n\n  ep = NULL;\n}\n\nstatic void mg_http_free_reverse_proxy_data(struct mg_reverse_proxy_data *rpd) {\n  if (rpd->linked_conn != NULL) {\n    /*\n     * Connection has linked one, we have to unlink & close it\n     * since _this_ connection is going to die and\n     * it doesn't make sense to keep another one\n     */\n    struct mg_http_proto_data *pd = mg_http_get_proto_data(rpd->linked_conn);\n    if (pd->reverse_proxy_data.linked_conn != NULL) {\n      pd->reverse_proxy_data.linked_conn->flags |= MG_F_SEND_AND_CLOSE;\n      pd->reverse_proxy_data.linked_conn = NULL;\n    }\n    rpd->linked_conn = NULL;\n  }\n}\n\nstatic void mg_http_conn_destructor(void *proto_data) {\n  struct mg_http_proto_data *pd = (struct mg_http_proto_data *) proto_data;\n#if MG_ENABLE_FILESYSTEM\n  mg_http_free_proto_data_file(&pd->file);\n#endif\n#if MG_ENABLE_HTTP_CGI\n  mg_http_free_proto_data_cgi(&pd->cgi);\n#endif\n#if MG_ENABLE_HTTP_STREAMING_MULTIPART\n  mg_http_free_proto_data_mp_stream(&pd->mp_stream);\n#endif\n  mg_http_free_proto_data_endpoints(&pd->endpoints);\n  mg_http_free_reverse_proxy_data(&pd->reverse_proxy_data);\n  MG_FREE(proto_data);\n}\n\n#if MG_ENABLE_FILESYSTEM\n\n#define MIME_ENTRY(_ext, _type) \\\n  { _ext, sizeof(_ext) - 1, _type }\nstatic const struct {\n  const char *extension;\n  size_t ext_len;\n  const char *mime_type;\n} mg_static_builtin_mime_types[] = {\n    MIME_ENTRY(\"html\", \"text/html\"),\n    MIME_ENTRY(\"html\", \"text/html\"),\n    MIME_ENTRY(\"htm\", \"text/html\"),\n    MIME_ENTRY(\"shtm\", \"text/html\"),\n    MIME_ENTRY(\"shtml\", \"text/html\"),\n    MIME_ENTRY(\"css\", \"text/css\"),\n    MIME_ENTRY(\"js\", \"application/x-javascript\"),\n    MIME_ENTRY(\"ico\", \"image/x-icon\"),\n    MIME_ENTRY(\"gif\", \"image/gif\"),\n    MIME_ENTRY(\"jpg\", \"image/jpeg\"),\n    MIME_ENTRY(\"jpeg\", \"image/jpeg\"),\n    MIME_ENTRY(\"png\", \"image/png\"),\n    MIME_ENTRY(\"svg\", \"image/svg+xml\"),\n    MIME_ENTRY(\"txt\", \"text/plain\"),\n    MIME_ENTRY(\"torrent\", \"application/x-bittorrent\"),\n    MIME_ENTRY(\"wav\", \"audio/x-wav\"),\n    MIME_ENTRY(\"mp3\", \"audio/x-mp3\"),\n    MIME_ENTRY(\"mid\", \"audio/mid\"),\n    MIME_ENTRY(\"m3u\", \"audio/x-mpegurl\"),\n    MIME_ENTRY(\"ogg\", \"application/ogg\"),\n    MIME_ENTRY(\"ram\", \"audio/x-pn-realaudio\"),\n    MIME_ENTRY(\"xml\", \"text/xml\"),\n    MIME_ENTRY(\"ttf\", \"application/x-font-ttf\"),\n    MIME_ENTRY(\"json\", \"application/json\"),\n    MIME_ENTRY(\"xslt\", \"application/xml\"),\n    MIME_ENTRY(\"xsl\", \"application/xml\"),\n    MIME_ENTRY(\"ra\", \"audio/x-pn-realaudio\"),\n    MIME_ENTRY(\"doc\", \"application/msword\"),\n    MIME_ENTRY(\"exe\", \"application/octet-stream\"),\n    MIME_ENTRY(\"zip\", \"application/x-zip-compressed\"),\n    MIME_ENTRY(\"xls\", \"application/excel\"),\n    MIME_ENTRY(\"tgz\", \"application/x-tar-gz\"),\n    MIME_ENTRY(\"tar\", \"application/x-tar\"),\n    MIME_ENTRY(\"gz\", \"application/x-gunzip\"),\n    MIME_ENTRY(\"arj\", \"application/x-arj-compressed\"),\n    MIME_ENTRY(\"rar\", \"application/x-rar-compressed\"),\n    MIME_ENTRY(\"rtf\", \"application/rtf\"),\n    MIME_ENTRY(\"pdf\", \"application/pdf\"),\n    MIME_ENTRY(\"swf\", \"application/x-shockwave-flash\"),\n    MIME_ENTRY(\"mpg\", \"video/mpeg\"),\n    MIME_ENTRY(\"webm\", \"video/webm\"),\n    MIME_ENTRY(\"mpeg\", \"video/mpeg\"),\n    MIME_ENTRY(\"mov\", \"video/quicktime\"),\n    MIME_ENTRY(\"mp4\", \"video/mp4\"),\n    MIME_ENTRY(\"m4v\", \"video/x-m4v\"),\n    MIME_ENTRY(\"asf\", \"video/x-ms-asf\"),\n    MIME_ENTRY(\"avi\", \"video/x-msvideo\"),\n    MIME_ENTRY(\"bmp\", \"image/bmp\"),\n    {NULL, 0, NULL}};\n\nstatic struct mg_str mg_get_mime_type(const char *path, const char *dflt,\n                                      const struct mg_serve_http_opts *opts) {\n  const char *ext, *overrides;\n  size_t i, path_len;\n  struct mg_str r, k, v;\n\n  path_len = strlen(path);\n\n  overrides = opts->custom_mime_types;\n  while ((overrides = mg_next_comma_list_entry(overrides, &k, &v)) != NULL) {\n    ext = path + (path_len - k.len);\n    if (path_len > k.len && mg_vcasecmp(&k, ext) == 0) {\n      return v;\n    }\n  }\n\n  for (i = 0; mg_static_builtin_mime_types[i].extension != NULL; i++) {\n    ext = path + (path_len - mg_static_builtin_mime_types[i].ext_len);\n    if (path_len > mg_static_builtin_mime_types[i].ext_len && ext[-1] == '.' &&\n        mg_casecmp(ext, mg_static_builtin_mime_types[i].extension) == 0) {\n      r.p = mg_static_builtin_mime_types[i].mime_type;\n      r.len = strlen(r.p);\n      return r;\n    }\n  }\n\n  r.p = dflt;\n  r.len = strlen(r.p);\n  return r;\n}\n#endif\n\n/*\n * Check whether full request is buffered. Return:\n *   -1  if request is malformed\n *    0  if request is not yet fully buffered\n *   >0  actual request length, including last \\r\\n\\r\\n\n */\nstatic int mg_http_get_request_len(const char *s, int buf_len) {\n  const unsigned char *buf = (unsigned char *) s;\n  int i;\n\n  for (i = 0; i < buf_len; i++) {\n    if (!isprint(buf[i]) && buf[i] != '\\r' && buf[i] != '\\n' && buf[i] < 128) {\n      return -1;\n    } else if (buf[i] == '\\n' && i + 1 < buf_len && buf[i + 1] == '\\n') {\n      return i + 2;\n    } else if (buf[i] == '\\n' && i + 2 < buf_len && buf[i + 1] == '\\r' &&\n               buf[i + 2] == '\\n') {\n      return i + 3;\n    }\n  }\n\n  return 0;\n}\n\nstatic const char *mg_http_parse_headers(const char *s, const char *end,\n                                         int len, struct http_message *req) {\n  int i = 0;\n  while (i < (int) ARRAY_SIZE(req->header_names) - 1) {\n    struct mg_str *k = &req->header_names[i], *v = &req->header_values[i];\n\n    s = mg_skip(s, end, \": \", k);\n    s = mg_skip(s, end, \"\\r\\n\", v);\n\n    while (v->len > 0 && v->p[v->len - 1] == ' ') {\n      v->len--; /* Trim trailing spaces in header value */\n    }\n\n    /*\n     * If header value is empty - skip it and go to next (if any).\n     * NOTE: Do not add it to headers_values because such addition changes API\n     * behaviour\n     */\n    if (k->len != 0 && v->len == 0) {\n      continue;\n    }\n\n    if (k->len == 0 || v->len == 0) {\n      k->p = v->p = NULL;\n      k->len = v->len = 0;\n      break;\n    }\n\n    if (!mg_ncasecmp(k->p, \"Content-Length\", 14)) {\n      req->body.len = (size_t) to64(v->p);\n      req->message.len = len + req->body.len;\n    }\n\n    i++;\n  }\n\n  return s;\n}\n\nint mg_parse_http(const char *s, int n, struct http_message *hm, int is_req) {\n  const char *end, *qs;\n  int len = mg_http_get_request_len(s, n);\n\n  if (len <= 0) return len;\n\n  memset(hm, 0, sizeof(*hm));\n  hm->message.p = s;\n  hm->body.p = s + len;\n  hm->message.len = hm->body.len = (size_t) ~0;\n  end = s + len;\n\n  /* Request is fully buffered. Skip leading whitespaces. */\n  while (s < end && isspace(*(unsigned char *) s)) s++;\n\n  if (is_req) {\n    /* Parse request line: method, URI, proto */\n    s = mg_skip(s, end, \" \", &hm->method);\n    s = mg_skip(s, end, \" \", &hm->uri);\n    s = mg_skip(s, end, \"\\r\\n\", &hm->proto);\n    if (hm->uri.p <= hm->method.p || hm->proto.p <= hm->uri.p) return -1;\n\n    /* If URI contains '?' character, initialize query_string */\n    if ((qs = (char *) memchr(hm->uri.p, '?', hm->uri.len)) != NULL) {\n      hm->query_string.p = qs + 1;\n      hm->query_string.len = &hm->uri.p[hm->uri.len] - (qs + 1);\n      hm->uri.len = qs - hm->uri.p;\n    }\n  } else {\n    s = mg_skip(s, end, \" \", &hm->proto);\n    if (end - s < 4 || s[3] != ' ') return -1;\n    hm->resp_code = atoi(s);\n    if (hm->resp_code < 100 || hm->resp_code >= 600) return -1;\n    s += 4;\n    s = mg_skip(s, end, \"\\r\\n\", &hm->resp_status_msg);\n  }\n\n  s = mg_http_parse_headers(s, end, len, hm);\n\n  /*\n   * mg_parse_http() is used to parse both HTTP requests and HTTP\n   * responses. If HTTP response does not have Content-Length set, then\n   * body is read until socket is closed, i.e. body.len is infinite (~0).\n   *\n   * For HTTP requests though, according to\n   * http://tools.ietf.org/html/rfc7231#section-8.1.3,\n   * only POST and PUT methods have defined body semantics.\n   * Therefore, if Content-Length is not specified and methods are\n   * not one of PUT or POST, set body length to 0.\n   *\n   * So,\n   * if it is HTTP request, and Content-Length is not set,\n   * and method is not (PUT or POST) then reset body length to zero.\n   */\n  if (hm->body.len == (size_t) ~0 && is_req &&\n      mg_vcasecmp(&hm->method, \"PUT\") != 0 &&\n      mg_vcasecmp(&hm->method, \"POST\") != 0) {\n    hm->body.len = 0;\n    hm->message.len = len;\n  }\n\n  return len;\n}\n\nstruct mg_str *mg_get_http_header(struct http_message *hm, const char *name) {\n  size_t i, len = strlen(name);\n\n  for (i = 0; hm->header_names[i].len > 0; i++) {\n    struct mg_str *h = &hm->header_names[i], *v = &hm->header_values[i];\n    if (h->p != NULL && h->len == len && !mg_ncasecmp(h->p, name, len))\n      return v;\n  }\n\n  return NULL;\n}\n\n#if MG_ENABLE_FILESYSTEM\nstatic void mg_http_transfer_file_data(struct mg_connection *nc) {\n  struct mg_http_proto_data *pd = mg_http_get_proto_data(nc);\n  char buf[MG_MAX_HTTP_SEND_MBUF];\n  size_t n = 0, to_read = 0, left = (size_t)(pd->file.cl - pd->file.sent);\n\n  if (pd->file.type == DATA_FILE) {\n    struct mbuf *io = &nc->send_mbuf;\n    if (io->len < sizeof(buf)) {\n      to_read = sizeof(buf) - io->len;\n    }\n\n    if (left > 0 && to_read > left) {\n      to_read = left;\n    }\n\n    if (to_read == 0) {\n      /* Rate limiting. send_mbuf is too full, wait until it's drained. */\n    } else if (pd->file.sent < pd->file.cl &&\n               (n = mg_fread(buf, 1, to_read, pd->file.fp)) > 0) {\n      mg_send(nc, buf, n);\n      pd->file.sent += n;\n    } else {\n      if (!pd->file.keepalive) nc->flags |= MG_F_SEND_AND_CLOSE;\n      mg_http_free_proto_data_file(&pd->file);\n    }\n  } else if (pd->file.type == DATA_PUT) {\n    struct mbuf *io = &nc->recv_mbuf;\n    size_t to_write = left <= 0 ? 0 : left < io->len ? (size_t) left : io->len;\n    size_t n = mg_fwrite(io->buf, 1, to_write, pd->file.fp);\n    if (n > 0) {\n      mbuf_remove(io, n);\n      pd->file.sent += n;\n    }\n    if (n == 0 || pd->file.sent >= pd->file.cl) {\n      if (!pd->file.keepalive) nc->flags |= MG_F_SEND_AND_CLOSE;\n      mg_http_free_proto_data_file(&pd->file);\n    }\n  }\n#if MG_ENABLE_HTTP_CGI\n  else if (pd->cgi.cgi_nc != NULL) {\n    /* This is POST data that needs to be forwarded to the CGI process */\n    if (pd->cgi.cgi_nc != NULL) {\n      mg_forward(nc, pd->cgi.cgi_nc);\n    } else {\n      nc->flags |= MG_F_SEND_AND_CLOSE;\n    }\n  }\n#endif\n}\n#endif /* MG_ENABLE_FILESYSTEM */\n\n/*\n * Parse chunked-encoded buffer. Return 0 if the buffer is not encoded, or\n * if it's incomplete. If the chunk is fully buffered, return total number of\n * bytes in a chunk, and store data in `data`, `data_len`.\n */\nstatic size_t mg_http_parse_chunk(char *buf, size_t len, char **chunk_data,\n                                  size_t *chunk_len) {\n  unsigned char *s = (unsigned char *) buf;\n  size_t n = 0; /* scanned chunk length */\n  size_t i = 0; /* index in s */\n\n  /* Scan chunk length. That should be a hexadecimal number. */\n  while (i < len && isxdigit(s[i])) {\n    n *= 16;\n    n += (s[i] >= '0' && s[i] <= '9') ? s[i] - '0' : tolower(s[i]) - 'a' + 10;\n    i++;\n  }\n\n  /* Skip new line */\n  if (i == 0 || i + 2 > len || s[i] != '\\r' || s[i + 1] != '\\n') {\n    return 0;\n  }\n  i += 2;\n\n  /* Record where the data is */\n  *chunk_data = (char *) s + i;\n  *chunk_len = n;\n\n  /* Skip data */\n  i += n;\n\n  /* Skip new line */\n  if (i == 0 || i + 2 > len || s[i] != '\\r' || s[i + 1] != '\\n') {\n    return 0;\n  }\n  return i + 2;\n}\n\nMG_INTERNAL size_t mg_handle_chunked(struct mg_connection *nc,\n                                     struct http_message *hm, char *buf,\n                                     size_t blen) {\n  struct mg_http_proto_data *pd = mg_http_get_proto_data(nc);\n  char *data;\n  size_t i, n, data_len, body_len, zero_chunk_received = 0;\n  /* Find out piece of received data that is not yet reassembled */\n  body_len = (size_t) pd->chunk.body_len;\n  assert(blen >= body_len);\n\n  /* Traverse all fully buffered chunks */\n  for (i = body_len;\n       (n = mg_http_parse_chunk(buf + i, blen - i, &data, &data_len)) > 0;\n       i += n) {\n    /* Collapse chunk data to the rest of HTTP body */\n    memmove(buf + body_len, data, data_len);\n    body_len += data_len;\n    hm->body.len = body_len;\n\n    if (data_len == 0) {\n      zero_chunk_received = 1;\n      i += n;\n      break;\n    }\n  }\n\n  if (i > body_len) {\n    /* Shift unparsed content to the parsed body */\n    assert(i <= blen);\n    memmove(buf + body_len, buf + i, blen - i);\n    memset(buf + body_len + blen - i, 0, i - body_len);\n    nc->recv_mbuf.len -= i - body_len;\n    pd->chunk.body_len = body_len;\n\n    /* Send MG_EV_HTTP_CHUNK event */\n    nc->flags &= ~MG_F_DELETE_CHUNK;\n    mg_call(nc, nc->handler, nc->user_data, MG_EV_HTTP_CHUNK, hm);\n\n    /* Delete processed data if user set MG_F_DELETE_CHUNK flag */\n    if (nc->flags & MG_F_DELETE_CHUNK) {\n      memset(buf, 0, body_len);\n      memmove(buf, buf + body_len, blen - i);\n      nc->recv_mbuf.len -= body_len;\n      hm->body.len = 0;\n      pd->chunk.body_len = 0;\n    }\n\n    if (zero_chunk_received) {\n      /* Total message size is len(body) + len(headers) */\n      hm->message.len =\n          (size_t) pd->chunk.body_len + blen - i + (hm->body.p - hm->message.p);\n    }\n  }\n\n  return body_len;\n}\n\nstruct mg_http_endpoint *mg_http_get_endpoint_handler(struct mg_connection *nc,\n                                                      struct mg_str *uri_path) {\n  struct mg_http_proto_data *pd;\n  struct mg_http_endpoint *ret = NULL;\n  int matched, matched_max = 0;\n  struct mg_http_endpoint *ep;\n\n  if (nc == NULL) {\n    return NULL;\n  }\n\n  pd = mg_http_get_proto_data(nc);\n\n  ep = pd->endpoints;\n  while (ep != NULL) {\n    const struct mg_str name_s = {ep->name, ep->name_len};\n    if ((matched = mg_match_prefix_n(name_s, *uri_path)) != -1) {\n      if (matched > matched_max) {\n        /* Looking for the longest suitable handler */\n        ret = ep;\n        matched_max = matched;\n      }\n    }\n\n    ep = ep->next;\n  }\n\n  return ret;\n}\n\nstatic void mg_http_call_endpoint_handler(struct mg_connection *nc, int ev,\n                                          struct http_message *hm) {\n  struct mg_http_proto_data *pd = mg_http_get_proto_data(nc);\n  void *user_data = nc->user_data;\n\n  if (ev == MG_EV_HTTP_REQUEST) {\n    struct mg_http_endpoint *ep =\n        mg_http_get_endpoint_handler(nc->listener, &hm->uri);\n    if (ep != NULL) {\n      pd->endpoint_handler = ep->handler;\n#if MG_ENABLE_CALLBACK_USERDATA\n      user_data = ep->user_data;\n#endif\n    }\n  }\n  mg_call(nc, pd->endpoint_handler ? pd->endpoint_handler : nc->handler,\n          user_data, ev, hm);\n}\n\n#if MG_ENABLE_HTTP_STREAMING_MULTIPART\nstatic void mg_http_multipart_continue(struct mg_connection *nc);\n\nstatic void mg_http_multipart_begin(struct mg_connection *nc,\n                                    struct http_message *hm, int req_len);\n\n#endif\n\n/*\n * lx106 compiler has a bug (TODO(mkm) report and insert tracking bug here)\n * If a big structure is declared in a big function, lx106 gcc will make it\n * even bigger (round up to 4k, from 700 bytes of actual size).\n */\n#ifdef __xtensa__\nstatic void mg_http_handler2(struct mg_connection *nc, int ev,\n                             void *ev_data MG_UD_ARG(void *user_data),\n                             struct http_message *hm) __attribute__((noinline));\n\nvoid mg_http_handler(struct mg_connection *nc, int ev,\n                     void *ev_data MG_UD_ARG(void *user_data)) {\n  struct http_message hm;\n  mg_http_handler2(nc, ev, ev_data MG_UD_ARG(user_data), &hm);\n}\n\nstatic void mg_http_handler2(struct mg_connection *nc, int ev,\n                             void *ev_data MG_UD_ARG(void *user_data),\n                             struct http_message *hm) {\n#else  /* !__XTENSA__ */\nvoid mg_http_handler(struct mg_connection *nc, int ev,\n                     void *ev_data MG_UD_ARG(void *user_data)) {\n  struct http_message shm;\n  struct http_message *hm = &shm;\n#endif /* __XTENSA__ */\n  struct mg_http_proto_data *pd = mg_http_get_proto_data(nc);\n  struct mbuf *io = &nc->recv_mbuf;\n  int req_len;\n  const int is_req = (nc->listener != NULL);\n#if MG_ENABLE_HTTP_WEBSOCKET\n  struct mg_str *vec;\n#endif\n  if (ev == MG_EV_CLOSE) {\n#if MG_ENABLE_HTTP_CGI\n    /* Close associated CGI forwarder connection */\n    if (pd->cgi.cgi_nc != NULL) {\n      pd->cgi.cgi_nc->user_data = NULL;\n      pd->cgi.cgi_nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n    }\n#endif\n#if MG_ENABLE_HTTP_STREAMING_MULTIPART\n    if (pd->mp_stream.boundary != NULL) {\n      /*\n       * Multipart message is in progress, but connection is closed.\n       * Finish part and request with an error flag.\n       */\n      struct mg_http_multipart_part mp;\n      memset(&mp, 0, sizeof(mp));\n      mp.status = -1;\n      mp.var_name = pd->mp_stream.var_name;\n      mp.file_name = pd->mp_stream.file_name;\n      mg_call(nc, (pd->endpoint_handler ? pd->endpoint_handler : nc->handler),\n              nc->user_data, MG_EV_HTTP_PART_END, &mp);\n      mp.var_name = NULL;\n      mp.file_name = NULL;\n      mg_call(nc, (pd->endpoint_handler ? pd->endpoint_handler : nc->handler),\n              nc->user_data, MG_EV_HTTP_MULTIPART_REQUEST_END, &mp);\n    } else\n#endif\n        if (io->len > 0 && mg_parse_http(io->buf, io->len, hm, is_req) > 0) {\n      /*\n      * For HTTP messages without Content-Length, always send HTTP message\n      * before MG_EV_CLOSE message.\n      */\n      int ev2 = is_req ? MG_EV_HTTP_REQUEST : MG_EV_HTTP_REPLY;\n      hm->message.len = io->len;\n      hm->body.len = io->buf + io->len - hm->body.p;\n      mg_http_call_endpoint_handler(nc, ev2, hm);\n    }\n  }\n\n#if MG_ENABLE_FILESYSTEM\n  if (pd->file.fp != NULL) {\n    mg_http_transfer_file_data(nc);\n  }\n#endif\n\n  mg_call(nc, nc->handler, nc->user_data, ev, ev_data);\n\n  if (ev == MG_EV_RECV) {\n    struct mg_str *s;\n\n#if MG_ENABLE_HTTP_STREAMING_MULTIPART\n    if (pd->mp_stream.boundary != NULL) {\n      mg_http_multipart_continue(nc);\n      return;\n    }\n#endif /* MG_ENABLE_HTTP_STREAMING_MULTIPART */\n\n    req_len = mg_parse_http(io->buf, io->len, hm, is_req);\n\n    if (req_len > 0 &&\n        (s = mg_get_http_header(hm, \"Transfer-Encoding\")) != NULL &&\n        mg_vcasecmp(s, \"chunked\") == 0) {\n      mg_handle_chunked(nc, hm, io->buf + req_len, io->len - req_len);\n    }\n\n#if MG_ENABLE_HTTP_STREAMING_MULTIPART\n    if (req_len > 0 && (s = mg_get_http_header(hm, \"Content-Type\")) != NULL &&\n        s->len >= 9 && strncmp(s->p, \"multipart\", 9) == 0) {\n      mg_http_multipart_begin(nc, hm, req_len);\n      mg_http_multipart_continue(nc);\n      return;\n    }\n#endif /* MG_ENABLE_HTTP_STREAMING_MULTIPART */\n\n    /* TODO(alashkin): refactor this ifelseifelseifelseifelse */\n    if ((req_len < 0 ||\n         (req_len == 0 && io->len >= MG_MAX_HTTP_REQUEST_SIZE))) {\n      DBG((\"invalid request\"));\n      nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n    } else if (req_len == 0) {\n      /* Do nothing, request is not yet fully buffered */\n    }\n#if MG_ENABLE_HTTP_WEBSOCKET\n    else if (nc->listener == NULL &&\n             mg_get_http_header(hm, \"Sec-WebSocket-Accept\")) {\n      /* We're websocket client, got handshake response from server. */\n      /* TODO(lsm): check the validity of accept Sec-WebSocket-Accept */\n      mbuf_remove(io, req_len);\n      nc->proto_handler = mg_ws_handler;\n      nc->flags |= MG_F_IS_WEBSOCKET;\n      mg_call(nc, nc->handler, nc->user_data, MG_EV_WEBSOCKET_HANDSHAKE_DONE,\n              NULL);\n      mg_ws_handler(nc, MG_EV_RECV, ev_data MG_UD_ARG(user_data));\n    } else if (nc->listener != NULL &&\n               (vec = mg_get_http_header(hm, \"Sec-WebSocket-Key\")) != NULL) {\n      struct mg_http_endpoint *ep;\n\n      /* This is a websocket request. Switch protocol handlers. */\n      mbuf_remove(io, req_len);\n      nc->proto_handler = mg_ws_handler;\n      nc->flags |= MG_F_IS_WEBSOCKET;\n\n      /*\n       * If we have a handler set up with mg_register_http_endpoint(),\n       * deliver subsequent websocket events to this handler after the\n       * protocol switch.\n       */\n      ep = mg_http_get_endpoint_handler(nc->listener, &hm->uri);\n      if (ep != NULL) {\n        nc->handler = ep->handler;\n#if MG_ENABLE_CALLBACK_USERDATA\n        nc->user_data = ep->user_data;\n#endif\n      }\n\n      /* Send handshake */\n      mg_call(nc, nc->handler, nc->user_data, MG_EV_WEBSOCKET_HANDSHAKE_REQUEST,\n              hm);\n      if (!(nc->flags & (MG_F_CLOSE_IMMEDIATELY | MG_F_SEND_AND_CLOSE))) {\n        if (nc->send_mbuf.len == 0) {\n          mg_ws_handshake(nc, vec);\n        }\n        mg_call(nc, nc->handler, nc->user_data, MG_EV_WEBSOCKET_HANDSHAKE_DONE,\n                NULL);\n        mg_ws_handler(nc, MG_EV_RECV, ev_data MG_UD_ARG(user_data));\n      }\n    }\n#endif /* MG_ENABLE_HTTP_WEBSOCKET */\n    else if (hm->message.len <= io->len) {\n      int trigger_ev = nc->listener ? MG_EV_HTTP_REQUEST : MG_EV_HTTP_REPLY;\n      char addr[32];\n      mg_sock_addr_to_str(&nc->sa, addr, sizeof(addr),\n                          MG_SOCK_STRINGIFY_IP | MG_SOCK_STRINGIFY_PORT);\n      DBG((\"%p %s %.*s %.*s\", nc, addr, (int) hm->method.len, hm->method.p,\n           (int) hm->uri.len, hm->uri.p));\n\n/* Whole HTTP message is fully buffered, call event handler */\n\n#if MG_ENABLE_JAVASCRIPT\n      v7_val_t v1, v2, headers, req, args, res;\n      struct v7 *v7 = nc->mgr->v7;\n      const char *ev_name = trigger_ev == MG_EV_HTTP_REPLY ? \"onsnd\" : \"onrcv\";\n      int i, js_callback_handled_request = 0;\n\n      if (v7 != NULL) {\n        /* Lookup JS callback */\n        v1 = v7_get(v7, v7_get_global(v7), \"Http\", ~0);\n        v2 = v7_get(v7, v1, ev_name, ~0);\n\n        /* Create callback params. TODO(lsm): own/disown those */\n        args = v7_mk_array(v7);\n        req = v7_mk_object(v7);\n        headers = v7_mk_object(v7);\n\n        /* Populate request object */\n        v7_set(v7, req, \"method\", ~0,\n               v7_mk_string(v7, hm->method.p, hm->method.len, 1));\n        v7_set(v7, req, \"uri\", ~0, v7_mk_string(v7, hm->uri.p, hm->uri.len, 1));\n        v7_set(v7, req, \"body\", ~0,\n               v7_mk_string(v7, hm->body.p, hm->body.len, 1));\n        v7_set(v7, req, \"headers\", ~0, headers);\n        for (i = 0; hm->header_names[i].len > 0; i++) {\n          const struct mg_str *name = &hm->header_names[i];\n          const struct mg_str *value = &hm->header_values[i];\n          v7_set(v7, headers, name->p, name->len,\n                 v7_mk_string(v7, value->p, value->len, 1));\n        }\n\n        /* Invoke callback. TODO(lsm): report errors */\n        v7_array_push(v7, args, v7_mk_foreign(v7, nc));\n        v7_array_push(v7, args, req);\n        if (v7_apply(v7, v2, V7_UNDEFINED, args, &res) == V7_OK &&\n            v7_is_truthy(v7, res)) {\n          js_callback_handled_request++;\n        }\n      }\n\n      /* If JS callback returns true, stop request processing */\n      if (js_callback_handled_request) {\n        nc->flags |= MG_F_SEND_AND_CLOSE;\n      } else {\n        mg_http_call_endpoint_handler(nc, trigger_ev, hm);\n      }\n#else\n      mg_http_call_endpoint_handler(nc, trigger_ev, hm);\n#endif\n      mbuf_remove(io, hm->message.len);\n    }\n  }\n  (void) pd;\n}\n\nstatic size_t mg_get_line_len(const char *buf, size_t buf_len) {\n  size_t len = 0;\n  while (len < buf_len && buf[len] != '\\n') len++;\n  return len == buf_len ? 0 : len + 1;\n}\n\n#if MG_ENABLE_HTTP_STREAMING_MULTIPART\nstatic void mg_http_multipart_begin(struct mg_connection *nc,\n                                    struct http_message *hm, int req_len) {\n  struct mg_http_proto_data *pd = mg_http_get_proto_data(nc);\n  struct mg_str *ct;\n  struct mbuf *io = &nc->recv_mbuf;\n  void *user_data = nc->user_data;\n\n  char boundary[100];\n  int boundary_len;\n\n  ct = mg_get_http_header(hm, \"Content-Type\");\n  if (ct == NULL) {\n    /* We need more data - or it isn't multipart mesage */\n    goto exit_mp;\n  }\n\n  /* Content-type should start with \"multipart\" */\n  if (ct->len < 9 || strncmp(ct->p, \"multipart\", 9) != 0) {\n    goto exit_mp;\n  }\n\n  boundary_len =\n      mg_http_parse_header(ct, \"boundary\", boundary, sizeof(boundary));\n  if (boundary_len == 0) {\n    /*\n     * Content type is multipart, but there is no boundary,\n     * probably malformed request\n     */\n    nc->flags = MG_F_CLOSE_IMMEDIATELY;\n    DBG((\"invalid request\"));\n    goto exit_mp;\n  }\n\n  /* If we reach this place - that is multipart request */\n\n  if (pd->mp_stream.boundary != NULL) {\n    /*\n     * Another streaming request was in progress,\n     * looks like protocol error\n     */\n    nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n  } else {\n    struct mg_http_endpoint *ep = NULL;\n    pd->mp_stream.state = MPS_BEGIN;\n    pd->mp_stream.boundary = strdup(boundary);\n    pd->mp_stream.boundary_len = strlen(boundary);\n    pd->mp_stream.var_name = pd->mp_stream.file_name = NULL;\n    pd->endpoint_handler = nc->handler;\n\n    ep = mg_http_get_endpoint_handler(nc->listener, &hm->uri);\n    if (ep != NULL) {\n      pd->endpoint_handler = ep->handler;\n#if MG_ENABLE_CALLBACK_USERDATA\n      user_data = ep->user_data;\n#endif\n    }\n\n    mg_call(nc, pd->endpoint_handler, user_data, MG_EV_HTTP_MULTIPART_REQUEST,\n            hm);\n\n    mbuf_remove(io, req_len);\n  }\nexit_mp:\n  ;\n}\n\n#define CONTENT_DISPOSITION \"Content-Disposition: \"\n\nstatic void mg_http_multipart_call_handler(struct mg_connection *c, int ev,\n                                           const char *data, size_t data_len) {\n  struct mg_http_multipart_part mp;\n  struct mg_http_proto_data *pd = mg_http_get_proto_data(c);\n  memset(&mp, 0, sizeof(mp));\n\n  mp.var_name = pd->mp_stream.var_name;\n  mp.file_name = pd->mp_stream.file_name;\n  mp.user_data = pd->mp_stream.user_data;\n  mp.data.p = data;\n  mp.data.len = data_len;\n  mg_call(c, pd->endpoint_handler, c->user_data, ev, &mp);\n  pd->mp_stream.user_data = mp.user_data;\n}\n\nstatic int mg_http_multipart_got_chunk(struct mg_connection *c) {\n  struct mg_http_proto_data *pd = mg_http_get_proto_data(c);\n  struct mbuf *io = &c->recv_mbuf;\n\n  mg_http_multipart_call_handler(c, MG_EV_HTTP_PART_DATA, io->buf,\n                                 pd->mp_stream.prev_io_len);\n  mbuf_remove(io, pd->mp_stream.prev_io_len);\n  pd->mp_stream.prev_io_len = 0;\n  pd->mp_stream.state = MPS_WAITING_FOR_CHUNK;\n\n  return 0;\n}\n\nstatic int mg_http_multipart_finalize(struct mg_connection *c) {\n  struct mg_http_proto_data *pd = mg_http_get_proto_data(c);\n\n  mg_http_multipart_call_handler(c, MG_EV_HTTP_PART_END, NULL, 0);\n  MG_FREE((void *) pd->mp_stream.file_name);\n  pd->mp_stream.file_name = NULL;\n  MG_FREE((void *) pd->mp_stream.var_name);\n  pd->mp_stream.var_name = NULL;\n  mg_http_multipart_call_handler(c, MG_EV_HTTP_MULTIPART_REQUEST_END, NULL, 0);\n  mg_http_free_proto_data_mp_stream(&pd->mp_stream);\n  pd->mp_stream.state = MPS_FINISHED;\n\n  return 1;\n}\n\nstatic int mg_http_multipart_wait_for_boundary(struct mg_connection *c) {\n  const char *boundary;\n  struct mbuf *io = &c->recv_mbuf;\n  struct mg_http_proto_data *pd = mg_http_get_proto_data(c);\n\n  if (pd->mp_stream.boundary == NULL) {\n    pd->mp_stream.state = MPS_FINALIZE;\n    DBG((\"Invalid request: boundary not initilaized\"));\n    return 0;\n  }\n\n  if ((int) io->len < pd->mp_stream.boundary_len + 2) {\n    return 0;\n  }\n\n  boundary = c_strnstr(io->buf, pd->mp_stream.boundary, io->len);\n  if (boundary != NULL) {\n    const char *boundary_end = (boundary + pd->mp_stream.boundary_len);\n    if (io->len - (boundary_end - io->buf) < 4) {\n      return 0;\n    }\n    if (strncmp(boundary_end, \"--\\r\\n\", 4) == 0) {\n      pd->mp_stream.state = MPS_FINALIZE;\n      mbuf_remove(io, (boundary_end - io->buf) + 4);\n    } else {\n      pd->mp_stream.state = MPS_GOT_BOUNDARY;\n    }\n  } else {\n    return 0;\n  }\n\n  return 1;\n}\n\nstatic int mg_http_multipart_process_boundary(struct mg_connection *c) {\n  int data_size;\n  const char *boundary, *block_begin;\n  struct mbuf *io = &c->recv_mbuf;\n  struct mg_http_proto_data *pd = mg_http_get_proto_data(c);\n  char file_name[100], var_name[100];\n  int line_len;\n  boundary = c_strnstr(io->buf, pd->mp_stream.boundary, io->len);\n  block_begin = boundary + pd->mp_stream.boundary_len + 2;\n  data_size = io->len - (block_begin - io->buf);\n\n  while (data_size > 0 &&\n         (line_len = mg_get_line_len(block_begin, data_size)) != 0) {\n    if (line_len > (int) sizeof(CONTENT_DISPOSITION) &&\n        mg_ncasecmp(block_begin, CONTENT_DISPOSITION,\n                    sizeof(CONTENT_DISPOSITION) - 1) == 0) {\n      struct mg_str header;\n\n      header.p = block_begin + sizeof(CONTENT_DISPOSITION) - 1;\n      header.len = line_len - sizeof(CONTENT_DISPOSITION) - 1;\n      mg_http_parse_header(&header, \"name\", var_name, sizeof(var_name) - 2);\n      mg_http_parse_header(&header, \"filename\", file_name,\n                           sizeof(file_name) - 2);\n      block_begin += line_len;\n      data_size -= line_len;\n      continue;\n    }\n\n    if (line_len == 2 && mg_ncasecmp(block_begin, \"\\r\\n\", 2) == 0) {\n      mbuf_remove(io, block_begin - io->buf + 2);\n\n      if (pd->mp_stream.processing_part != 0) {\n        mg_http_multipart_call_handler(c, MG_EV_HTTP_PART_END, NULL, 0);\n      }\n\n      MG_FREE((void *) pd->mp_stream.file_name);\n      pd->mp_stream.file_name = strdup(file_name);\n      MG_FREE((void *) pd->mp_stream.var_name);\n      pd->mp_stream.var_name = strdup(var_name);\n\n      mg_http_multipart_call_handler(c, MG_EV_HTTP_PART_BEGIN, NULL, 0);\n      pd->mp_stream.state = MPS_WAITING_FOR_CHUNK;\n      pd->mp_stream.processing_part++;\n      return 1;\n    }\n\n    block_begin += line_len;\n  }\n\n  pd->mp_stream.state = MPS_WAITING_FOR_BOUNDARY;\n\n  return 0;\n}\n\nstatic int mg_http_multipart_continue_wait_for_chunk(struct mg_connection *c) {\n  struct mg_http_proto_data *pd = mg_http_get_proto_data(c);\n  struct mbuf *io = &c->recv_mbuf;\n\n  const char *boundary;\n  if ((int) io->len < pd->mp_stream.boundary_len + 6 /* \\r\\n, --, -- */) {\n    return 0;\n  }\n\n  boundary = c_strnstr(io->buf, pd->mp_stream.boundary, io->len);\n  if (boundary == NULL && pd->mp_stream.prev_io_len == 0) {\n    pd->mp_stream.prev_io_len = io->len;\n    return 0;\n  } else if (boundary == NULL &&\n             (int) io->len >\n                 pd->mp_stream.prev_io_len + pd->mp_stream.boundary_len + 4) {\n    pd->mp_stream.state = MPS_GOT_CHUNK;\n    return 1;\n  } else if (boundary != NULL) {\n    int data_size = (boundary - io->buf - 4);\n    mg_http_multipart_call_handler(c, MG_EV_HTTP_PART_DATA, io->buf, data_size);\n    mbuf_remove(io, (boundary - io->buf));\n    pd->mp_stream.prev_io_len = 0;\n    pd->mp_stream.state = MPS_WAITING_FOR_BOUNDARY;\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\nstatic void mg_http_multipart_continue(struct mg_connection *c) {\n  struct mg_http_proto_data *pd = mg_http_get_proto_data(c);\n  while (1) {\n    switch (pd->mp_stream.state) {\n      case MPS_BEGIN: {\n        pd->mp_stream.state = MPS_WAITING_FOR_BOUNDARY;\n        break;\n      }\n      case MPS_WAITING_FOR_BOUNDARY: {\n        if (mg_http_multipart_wait_for_boundary(c) == 0) {\n          return;\n        }\n        break;\n      }\n      case MPS_GOT_BOUNDARY: {\n        if (mg_http_multipart_process_boundary(c) == 0) {\n          return;\n        }\n        break;\n      }\n      case MPS_WAITING_FOR_CHUNK: {\n        if (mg_http_multipart_continue_wait_for_chunk(c) == 0) {\n          return;\n        }\n        break;\n      }\n      case MPS_GOT_CHUNK: {\n        if (mg_http_multipart_got_chunk(c) == 0) {\n          return;\n        }\n        break;\n      }\n      case MPS_FINALIZE: {\n        if (mg_http_multipart_finalize(c) == 0) {\n          return;\n        }\n        break;\n      }\n      case MPS_FINISHED: {\n        mbuf_remove(&c->recv_mbuf, c->recv_mbuf.len);\n        return;\n      }\n    }\n  }\n}\n\nstruct file_upload_state {\n  char *lfn;\n  size_t num_recd;\n  FILE *fp;\n};\n\n#endif /* MG_ENABLE_HTTP_STREAMING_MULTIPART */\n\nvoid mg_set_protocol_http_websocket(struct mg_connection *nc) {\n  nc->proto_handler = mg_http_handler;\n}\n\nconst char *mg_status_message(int status_code) {\n  switch (status_code) {\n    case 206:\n      return \"Partial Content\";\n    case 301:\n      return \"Moved\";\n    case 302:\n      return \"Found\";\n    case 400:\n      return \"Bad Request\";\n    case 401:\n      return \"Unauthorized\";\n    case 403:\n      return \"Forbidden\";\n    case 404:\n      return \"Not Found\";\n    case 416:\n      return \"Requested Range Not Satisfiable\";\n    case 418:\n      return \"I'm a teapot\";\n    case 500:\n      return \"Internal Server Error\";\n    case 502:\n      return \"Bad Gateway\";\n    case 503:\n      return \"Service Unavailable\";\n\n#if MG_ENABLE_EXTRA_ERRORS_DESC\n    case 100:\n      return \"Continue\";\n    case 101:\n      return \"Switching Protocols\";\n    case 102:\n      return \"Processing\";\n    case 200:\n      return \"OK\";\n    case 201:\n      return \"Created\";\n    case 202:\n      return \"Accepted\";\n    case 203:\n      return \"Non-Authoritative Information\";\n    case 204:\n      return \"No Content\";\n    case 205:\n      return \"Reset Content\";\n    case 207:\n      return \"Multi-Status\";\n    case 208:\n      return \"Already Reported\";\n    case 226:\n      return \"IM Used\";\n    case 300:\n      return \"Multiple Choices\";\n    case 303:\n      return \"See Other\";\n    case 304:\n      return \"Not Modified\";\n    case 305:\n      return \"Use Proxy\";\n    case 306:\n      return \"Switch Proxy\";\n    case 307:\n      return \"Temporary Redirect\";\n    case 308:\n      return \"Permanent Redirect\";\n    case 402:\n      return \"Payment Required\";\n    case 405:\n      return \"Method Not Allowed\";\n    case 406:\n      return \"Not Acceptable\";\n    case 407:\n      return \"Proxy Authentication Required\";\n    case 408:\n      return \"Request Timeout\";\n    case 409:\n      return \"Conflict\";\n    case 410:\n      return \"Gone\";\n    case 411:\n      return \"Length Required\";\n    case 412:\n      return \"Precondition Failed\";\n    case 413:\n      return \"Payload Too Large\";\n    case 414:\n      return \"URI Too Long\";\n    case 415:\n      return \"Unsupported Media Type\";\n    case 417:\n      return \"Expectation Failed\";\n    case 422:\n      return \"Unprocessable Entity\";\n    case 423:\n      return \"Locked\";\n    case 424:\n      return \"Failed Dependency\";\n    case 426:\n      return \"Upgrade Required\";\n    case 428:\n      return \"Precondition Required\";\n    case 429:\n      return \"Too Many Requests\";\n    case 431:\n      return \"Request Header Fields Too Large\";\n    case 451:\n      return \"Unavailable For Legal Reasons\";\n    case 501:\n      return \"Not Implemented\";\n    case 504:\n      return \"Gateway Timeout\";\n    case 505:\n      return \"HTTP Version Not Supported\";\n    case 506:\n      return \"Variant Also Negotiates\";\n    case 507:\n      return \"Insufficient Storage\";\n    case 508:\n      return \"Loop Detected\";\n    case 510:\n      return \"Not Extended\";\n    case 511:\n      return \"Network Authentication Required\";\n#endif /* MG_ENABLE_EXTRA_ERRORS_DESC */\n\n    default:\n      return \"OK\";\n  }\n}\n\nvoid mg_send_response_line_s(struct mg_connection *nc, int status_code,\n                             const struct mg_str extra_headers) {\n  mg_printf(nc, \"HTTP/1.1 %d %s\\r\\nServer: %s\\r\\n\", status_code,\n            mg_status_message(status_code), mg_version_header);\n  if (extra_headers.len > 0) {\n    mg_printf(nc, \"%.*s\\r\\n\", (int) extra_headers.len, extra_headers.p);\n  }\n}\n\nvoid mg_send_response_line(struct mg_connection *nc, int status_code,\n                           const char *extra_headers) {\n  mg_send_response_line_s(nc, status_code, mg_mk_str(extra_headers));\n}\n\nvoid mg_http_send_redirect(struct mg_connection *nc, int status_code,\n                           const struct mg_str location,\n                           const struct mg_str extra_headers) {\n  char bbody[100], *pbody = bbody;\n  int bl = mg_asprintf(&pbody, sizeof(bbody),\n                       \"<p>Moved <a href='%.*s'>here</a>.\\r\\n\",\n                       (int) location.len, location.p);\n  char bhead[150], *phead = bhead;\n  mg_asprintf(&phead, sizeof(bhead),\n              \"Location: %.*s\\r\\n\"\n              \"Content-Type: text/html\\r\\n\"\n              \"Content-Length: %d\\r\\n\"\n              \"Cache-Control: no-cache\\r\\n\"\n              \"%.*s%s\",\n              (int) location.len, location.p, bl, (int) extra_headers.len,\n              extra_headers.p, (extra_headers.len > 0 ? \"\\r\\n\" : \"\"));\n  mg_send_response_line(nc, status_code, phead);\n  if (phead != bhead) MG_FREE(phead);\n  mg_send(nc, pbody, bl);\n  if (pbody != bbody) MG_FREE(pbody);\n}\n\nvoid mg_send_head(struct mg_connection *c, int status_code,\n                  int64_t content_length, const char *extra_headers) {\n  mg_send_response_line(c, status_code, extra_headers);\n  if (content_length < 0) {\n    mg_printf(c, \"%s\", \"Transfer-Encoding: chunked\\r\\n\");\n  } else {\n    mg_printf(c, \"Content-Length: %\" INT64_FMT \"\\r\\n\", content_length);\n  }\n  mg_send(c, \"\\r\\n\", 2);\n}\n\nvoid mg_http_send_error(struct mg_connection *nc, int code,\n                        const char *reason) {\n  if (!reason) reason = mg_status_message(code);\n  LOG(LL_DEBUG, (\"%p %d %s\", nc, code, reason));\n  mg_send_head(nc, code, strlen(reason),\n               \"Content-Type: text/plain\\r\\nConnection: close\");\n  mg_send(nc, reason, strlen(reason));\n  nc->flags |= MG_F_SEND_AND_CLOSE;\n}\n\n#if MG_ENABLE_FILESYSTEM\nstatic void mg_http_construct_etag(char *buf, size_t buf_len,\n                                   const cs_stat_t *st) {\n  snprintf(buf, buf_len, \"\\\"%lx.%\" INT64_FMT \"\\\"\", (unsigned long) st->st_mtime,\n           (int64_t) st->st_size);\n}\n\n#ifndef WINCE\nstatic void mg_gmt_time_string(char *buf, size_t buf_len, time_t *t) {\n  strftime(buf, buf_len, \"%a, %d %b %Y %H:%M:%S GMT\", gmtime(t));\n}\n#else\n/* Look wince_lib.c for WindowsCE implementation */\nstatic void mg_gmt_time_string(char *buf, size_t buf_len, time_t *t);\n#endif\n\nstatic int mg_http_parse_range_header(const struct mg_str *header, int64_t *a,\n                                      int64_t *b) {\n  /*\n   * There is no snscanf. Headers are not guaranteed to be NUL-terminated,\n   * so we have this. Ugh.\n   */\n  int result;\n  char *p = (char *) MG_MALLOC(header->len + 1);\n  if (p == NULL) return 0;\n  memcpy(p, header->p, header->len);\n  p[header->len] = '\\0';\n  result = sscanf(p, \"bytes=%\" INT64_FMT \"-%\" INT64_FMT, a, b);\n  MG_FREE(p);\n  return result;\n}\n\nvoid mg_http_serve_file(struct mg_connection *nc, struct http_message *hm,\n                        const char *path, const struct mg_str mime_type,\n                        const struct mg_str extra_headers) {\n  struct mg_http_proto_data *pd = mg_http_get_proto_data(nc);\n  cs_stat_t st;\n  LOG(LL_DEBUG, (\"%p [%s] %.*s\", nc, path, (int) mime_type.len, mime_type.p));\n  if (mg_stat(path, &st) != 0 || (pd->file.fp = mg_fopen(path, \"rb\")) == NULL) {\n    int code, err = mg_get_errno();\n    switch (err) {\n      case EACCES:\n        code = 403;\n        break;\n      case ENOENT:\n        code = 404;\n        break;\n      default:\n        code = 500;\n    };\n    mg_http_send_error(nc, code, \"Open failed\");\n  } else {\n    char etag[50], current_time[50], last_modified[50], range[70];\n    time_t t = (time_t) mg_time();\n    int64_t r1 = 0, r2 = 0, cl = st.st_size;\n    struct mg_str *range_hdr = mg_get_http_header(hm, \"Range\");\n    int n, status_code = 200;\n\n    /* Handle Range header */\n    range[0] = '\\0';\n    if (range_hdr != NULL &&\n        (n = mg_http_parse_range_header(range_hdr, &r1, &r2)) > 0 && r1 >= 0 &&\n        r2 >= 0) {\n      /* If range is specified like \"400-\", set second limit to content len */\n      if (n == 1) {\n        r2 = cl - 1;\n      }\n      if (r1 > r2 || r2 >= cl) {\n        status_code = 416;\n        cl = 0;\n        snprintf(range, sizeof(range),\n                 \"Content-Range: bytes */%\" INT64_FMT \"\\r\\n\",\n                 (int64_t) st.st_size);\n      } else {\n        status_code = 206;\n        cl = r2 - r1 + 1;\n        snprintf(range, sizeof(range), \"Content-Range: bytes %\" INT64_FMT\n                                       \"-%\" INT64_FMT \"/%\" INT64_FMT \"\\r\\n\",\n                 r1, r1 + cl - 1, (int64_t) st.st_size);\n#if _FILE_OFFSET_BITS == 64 || _POSIX_C_SOURCE >= 200112L || \\\n    _XOPEN_SOURCE >= 600\n        fseeko(pd->file.fp, r1, SEEK_SET);\n#else\n        fseek(pd->file.fp, (long) r1, SEEK_SET);\n#endif\n      }\n    }\n\n#if !MG_DISABLE_HTTP_KEEP_ALIVE\n    {\n      struct mg_str *conn_hdr = mg_get_http_header(hm, \"Connection\");\n      if (conn_hdr != NULL) {\n        pd->file.keepalive = (mg_vcasecmp(conn_hdr, \"keep-alive\") == 0);\n      } else {\n        pd->file.keepalive = (mg_vcmp(&hm->proto, \"HTTP/1.1\") == 0);\n      }\n    }\n#endif\n\n    mg_http_construct_etag(etag, sizeof(etag), &st);\n    mg_gmt_time_string(current_time, sizeof(current_time), &t);\n    mg_gmt_time_string(last_modified, sizeof(last_modified), &st.st_mtime);\n    /*\n     * Content length casted to size_t because:\n     * 1) that's the maximum buffer size anyway\n     * 2) ESP8266 RTOS SDK newlib vprintf cannot contain a 64bit arg at non-last\n     *    position\n     * TODO(mkm): fix ESP8266 RTOS SDK\n     */\n    mg_send_response_line_s(nc, status_code, extra_headers);\n    mg_printf(nc,\n              \"Date: %s\\r\\n\"\n              \"Last-Modified: %s\\r\\n\"\n              \"Accept-Ranges: bytes\\r\\n\"\n              \"Content-Type: %.*s\\r\\n\"\n              \"Connection: %s\\r\\n\"\n              \"Content-Length: %\" SIZE_T_FMT\n              \"\\r\\n\"\n              \"%sEtag: %s\\r\\n\\r\\n\",\n              current_time, last_modified, (int) mime_type.len, mime_type.p,\n              (pd->file.keepalive ? \"keep-alive\" : \"close\"), (size_t) cl, range,\n              etag);\n\n    pd->file.cl = cl;\n    pd->file.type = DATA_FILE;\n    mg_http_transfer_file_data(nc);\n  }\n}\n\nstatic void mg_http_serve_file2(struct mg_connection *nc, const char *path,\n                                struct http_message *hm,\n                                struct mg_serve_http_opts *opts) {\n#if MG_ENABLE_HTTP_SSI\n  if (mg_match_prefix(opts->ssi_pattern, strlen(opts->ssi_pattern), path) > 0) {\n    mg_handle_ssi_request(nc, hm, path, opts);\n    return;\n  }\n#endif\n  mg_http_serve_file(nc, hm, path, mg_get_mime_type(path, \"text/plain\", opts),\n                     mg_mk_str(opts->extra_headers));\n}\n\n#endif\n\nint mg_url_decode(const char *src, int src_len, char *dst, int dst_len,\n                  int is_form_url_encoded) {\n  int i, j, a, b;\n#define HEXTOI(x) (isdigit(x) ? x - '0' : x - 'W')\n\n  for (i = j = 0; i < src_len && j < dst_len - 1; i++, j++) {\n    if (src[i] == '%') {\n      if (i < src_len - 2 && isxdigit(*(const unsigned char *) (src + i + 1)) &&\n          isxdigit(*(const unsigned char *) (src + i + 2))) {\n        a = tolower(*(const unsigned char *) (src + i + 1));\n        b = tolower(*(const unsigned char *) (src + i + 2));\n        dst[j] = (char) ((HEXTOI(a) << 4) | HEXTOI(b));\n        i += 2;\n      } else {\n        return -1;\n      }\n    } else if (is_form_url_encoded && src[i] == '+') {\n      dst[j] = ' ';\n    } else {\n      dst[j] = src[i];\n    }\n  }\n\n  dst[j] = '\\0'; /* Null-terminate the destination */\n\n  return i >= src_len ? j : -1;\n}\n\nint mg_get_http_var(const struct mg_str *buf, const char *name, char *dst,\n                    size_t dst_len) {\n  const char *p, *e, *s;\n  size_t name_len;\n  int len;\n\n  /*\n   * According to the documentation function returns negative\n   * value in case of error. For debug purposes it returns:\n   * -1 - src is wrong (NUUL)\n   * -2 - dst is wrong (NULL)\n   * -3 - failed to decode url or dst is to small\n   */\n  if (dst == NULL || dst_len == 0) {\n    len = -2;\n  } else if (buf->p == NULL || name == NULL || buf->len == 0) {\n    len = -1;\n    dst[0] = '\\0';\n  } else {\n    name_len = strlen(name);\n    e = buf->p + buf->len;\n    len = 0;\n    dst[0] = '\\0';\n\n    for (p = buf->p; p + name_len < e; p++) {\n      if ((p == buf->p || p[-1] == '&') && p[name_len] == '=' &&\n          !mg_ncasecmp(name, p, name_len)) {\n        p += name_len + 1;\n        s = (const char *) memchr(p, '&', (size_t)(e - p));\n        if (s == NULL) {\n          s = e;\n        }\n        len = mg_url_decode(p, (size_t)(s - p), dst, dst_len, 1);\n        /* -1 means: failed to decode or dst is too small */\n        if (len == -1) {\n          len = -3;\n        }\n        break;\n      }\n    }\n  }\n\n  return len;\n}\n\nvoid mg_send_http_chunk(struct mg_connection *nc, const char *buf, size_t len) {\n  char chunk_size[50];\n  int n;\n\n  n = snprintf(chunk_size, sizeof(chunk_size), \"%lX\\r\\n\", (unsigned long) len);\n  mg_send(nc, chunk_size, n);\n  mg_send(nc, buf, len);\n  mg_send(nc, \"\\r\\n\", 2);\n}\n\nvoid mg_printf_http_chunk(struct mg_connection *nc, const char *fmt, ...) {\n  char mem[MG_VPRINTF_BUFFER_SIZE], *buf = mem;\n  int len;\n  va_list ap;\n\n  va_start(ap, fmt);\n  len = mg_avprintf(&buf, sizeof(mem), fmt, ap);\n  va_end(ap);\n\n  if (len >= 0) {\n    mg_send_http_chunk(nc, buf, len);\n  }\n\n  /* LCOV_EXCL_START */\n  if (buf != mem && buf != NULL) {\n    MG_FREE(buf);\n  }\n  /* LCOV_EXCL_STOP */\n}\n\nvoid mg_printf_html_escape(struct mg_connection *nc, const char *fmt, ...) {\n  char mem[MG_VPRINTF_BUFFER_SIZE], *buf = mem;\n  int i, j, len;\n  va_list ap;\n\n  va_start(ap, fmt);\n  len = mg_avprintf(&buf, sizeof(mem), fmt, ap);\n  va_end(ap);\n\n  if (len >= 0) {\n    for (i = j = 0; i < len; i++) {\n      if (buf[i] == '<' || buf[i] == '>') {\n        mg_send(nc, buf + j, i - j);\n        mg_send(nc, buf[i] == '<' ? \"&lt;\" : \"&gt;\", 4);\n        j = i + 1;\n      }\n    }\n    mg_send(nc, buf + j, i - j);\n  }\n\n  /* LCOV_EXCL_START */\n  if (buf != mem && buf != NULL) {\n    MG_FREE(buf);\n  }\n  /* LCOV_EXCL_STOP */\n}\n\nint mg_http_parse_header(struct mg_str *hdr, const char *var_name, char *buf,\n                         size_t buf_size) {\n  int ch = ' ', ch1 = ',', len = 0, n = strlen(var_name);\n  const char *p, *end = hdr ? hdr->p + hdr->len : NULL, *s = NULL;\n\n  if (buf != NULL && buf_size > 0) buf[0] = '\\0';\n  if (hdr == NULL) return 0;\n\n  /* Find where variable starts */\n  for (s = hdr->p; s != NULL && s + n < end; s++) {\n    if ((s == hdr->p || s[-1] == ch || s[-1] == ch1 || s[-1] == ';') &&\n        s[n] == '=' && !strncmp(s, var_name, n))\n      break;\n  }\n\n  if (s != NULL && &s[n + 1] < end) {\n    s += n + 1;\n    if (*s == '\"' || *s == '\\'') {\n      ch = ch1 = *s++;\n    }\n    p = s;\n    while (p < end && p[0] != ch && p[0] != ch1 && len < (int) buf_size) {\n      if (ch != ' ' && p[0] == '\\\\' && p[1] == ch) p++;\n      buf[len++] = *p++;\n    }\n    if (len >= (int) buf_size || (ch != ' ' && *p != ch)) {\n      len = 0;\n    } else {\n      if (len > 0 && s[len - 1] == ',') len--;\n      if (len > 0 && s[len - 1] == ';') len--;\n      buf[len] = '\\0';\n    }\n  }\n\n  return len;\n}\n\nint mg_get_http_basic_auth(struct http_message *hm, char *user, size_t user_len,\n                           char *pass, size_t pass_len) {\n  struct mg_str *hdr = mg_get_http_header(hm, \"Authorization\");\n  if (hdr == NULL) return -1;\n  return mg_parse_http_basic_auth(hdr, user, user_len, pass, pass_len);\n}\n\nint mg_parse_http_basic_auth(struct mg_str *hdr, char *user, size_t user_len,\n                             char *pass, size_t pass_len) {\n  char *buf = NULL;\n  char fmt[64];\n  int res = 0;\n\n  if (mg_strncmp(*hdr, mg_mk_str(\"Basic \"), 6) != 0) return -1;\n\n  buf = (char *) MG_MALLOC(hdr->len);\n  cs_base64_decode((unsigned char *) hdr->p + 6, hdr->len, buf, NULL);\n\n  /* e.g. \"%123[^:]:%321[^\\n]\" */\n  snprintf(fmt, sizeof(fmt), \"%%%\" SIZE_T_FMT \"[^:]:%%%\" SIZE_T_FMT \"[^\\n]\",\n           user_len - 1, pass_len - 1);\n  if (sscanf(buf, fmt, user, pass) == 0) {\n    res = -1;\n  }\n\n  MG_FREE(buf);\n  return res;\n}\n\n#if MG_ENABLE_FILESYSTEM\nstatic int mg_is_file_hidden(const char *path,\n                             const struct mg_serve_http_opts *opts,\n                             int exclude_specials) {\n  const char *p1 = opts->per_directory_auth_file;\n  const char *p2 = opts->hidden_file_pattern;\n\n  /* Strip directory path from the file name */\n  const char *pdir = strrchr(path, DIRSEP);\n  if (pdir != NULL) {\n    path = pdir + 1;\n  }\n\n  return (exclude_specials && (!strcmp(path, \".\") || !strcmp(path, \"..\"))) ||\n         (p1 != NULL &&\n          mg_match_prefix(p1, strlen(p1), path) == (int) strlen(p1)) ||\n         (p2 != NULL && mg_match_prefix(p2, strlen(p2), path) > 0);\n}\n\n#if !MG_DISABLE_HTTP_DIGEST_AUTH\nstatic void mg_mkmd5resp(const char *method, size_t method_len, const char *uri,\n                         size_t uri_len, const char *ha1, size_t ha1_len,\n                         const char *nonce, size_t nonce_len, const char *nc,\n                         size_t nc_len, const char *cnonce, size_t cnonce_len,\n                         const char *qop, size_t qop_len, char *resp) {\n  static const char colon[] = \":\";\n  static const size_t one = 1;\n  char ha2[33];\n\n  cs_md5(ha2, method, method_len, colon, one, uri, uri_len, NULL);\n  cs_md5(resp, ha1, ha1_len, colon, one, nonce, nonce_len, colon, one, nc,\n         nc_len, colon, one, cnonce, cnonce_len, colon, one, qop, qop_len,\n         colon, one, ha2, sizeof(ha2) - 1, NULL);\n}\n\nint mg_http_create_digest_auth_header(char *buf, size_t buf_len,\n                                      const char *method, const char *uri,\n                                      const char *auth_domain, const char *user,\n                                      const char *passwd) {\n  static const char colon[] = \":\", qop[] = \"auth\";\n  static const size_t one = 1;\n  char ha1[33], resp[33], cnonce[40];\n\n  snprintf(cnonce, sizeof(cnonce), \"%x\", (unsigned int) mg_time());\n  cs_md5(ha1, user, (size_t) strlen(user), colon, one, auth_domain,\n         (size_t) strlen(auth_domain), colon, one, passwd,\n         (size_t) strlen(passwd), NULL);\n  mg_mkmd5resp(method, strlen(method), uri, strlen(uri), ha1, sizeof(ha1) - 1,\n               cnonce, strlen(cnonce), \"1\", one, cnonce, strlen(cnonce), qop,\n               sizeof(qop) - 1, resp);\n  return snprintf(buf, buf_len,\n                  \"Authorization: Digest username=\\\"%s\\\",\"\n                  \"realm=\\\"%s\\\",uri=\\\"%s\\\",qop=%s,nc=1,cnonce=%s,\"\n                  \"nonce=%s,response=%s\\r\\n\",\n                  user, auth_domain, uri, qop, cnonce, cnonce, resp);\n}\n\n/*\n * Check for authentication timeout.\n * Clients send time stamp encoded in nonce. Make sure it is not too old,\n * to prevent replay attacks.\n * Assumption: nonce is a hexadecimal number of seconds since 1970.\n */\nstatic int mg_check_nonce(const char *nonce) {\n  unsigned long now = (unsigned long) mg_time();\n  unsigned long val = (unsigned long) strtoul(nonce, NULL, 16);\n  return now < val || now - val < 3600;\n}\n\nint mg_http_check_digest_auth(struct http_message *hm, const char *auth_domain,\n                              FILE *fp) {\n  struct mg_str *hdr;\n  char buf[128], f_user[sizeof(buf)], f_ha1[sizeof(buf)], f_domain[sizeof(buf)];\n  char user[50], cnonce[33], response[40], uri[200], qop[20], nc[20], nonce[30];\n  char expected_response[33];\n\n  /* Parse \"Authorization:\" header, fail fast on parse error */\n  if (hm == NULL || fp == NULL ||\n      (hdr = mg_get_http_header(hm, \"Authorization\")) == NULL ||\n      mg_http_parse_header(hdr, \"username\", user, sizeof(user)) == 0 ||\n      mg_http_parse_header(hdr, \"cnonce\", cnonce, sizeof(cnonce)) == 0 ||\n      mg_http_parse_header(hdr, \"response\", response, sizeof(response)) == 0 ||\n      mg_http_parse_header(hdr, \"uri\", uri, sizeof(uri)) == 0 ||\n      mg_http_parse_header(hdr, \"qop\", qop, sizeof(qop)) == 0 ||\n      mg_http_parse_header(hdr, \"nc\", nc, sizeof(nc)) == 0 ||\n      mg_http_parse_header(hdr, \"nonce\", nonce, sizeof(nonce)) == 0 ||\n      mg_check_nonce(nonce) == 0) {\n    return 0;\n  }\n\n  /*\n   * Read passwords file line by line. If should have htdigest format,\n   * i.e. each line should be a colon-separated sequence:\n   * USER_NAME:DOMAIN_NAME:HA1_HASH_OF_USER_DOMAIN_AND_PASSWORD\n   */\n  while (fgets(buf, sizeof(buf), fp) != NULL) {\n    if (sscanf(buf, \"%[^:]:%[^:]:%s\", f_user, f_domain, f_ha1) == 3 &&\n        strcmp(user, f_user) == 0 &&\n        /* NOTE(lsm): due to a bug in MSIE, we do not compare URIs */\n        strcmp(auth_domain, f_domain) == 0) {\n      /* User and domain matched, check the password */\n      mg_mkmd5resp(\n          hm->method.p, hm->method.len, hm->uri.p,\n          hm->uri.len + (hm->query_string.len ? hm->query_string.len + 1 : 0),\n          f_ha1, strlen(f_ha1), nonce, strlen(nonce), nc, strlen(nc), cnonce,\n          strlen(cnonce), qop, strlen(qop), expected_response);\n      return mg_casecmp(response, expected_response) == 0;\n    }\n  }\n\n  /* None of the entries in the passwords file matched - return failure */\n  return 0;\n}\n\nstatic int mg_is_authorized(struct http_message *hm, const char *path,\n                            int is_directory, const char *domain,\n                            const char *passwords_file,\n                            int is_global_pass_file) {\n  char buf[MG_MAX_PATH];\n  const char *p;\n  FILE *fp;\n  int authorized = 1;\n\n  if (domain != NULL && passwords_file != NULL) {\n    if (is_global_pass_file) {\n      fp = mg_fopen(passwords_file, \"r\");\n    } else if (is_directory) {\n      snprintf(buf, sizeof(buf), \"%s%c%s\", path, DIRSEP, passwords_file);\n      fp = mg_fopen(buf, \"r\");\n    } else {\n      p = strrchr(path, DIRSEP);\n      if (p == NULL) p = path;\n      snprintf(buf, sizeof(buf), \"%.*s%c%s\", (int) (p - path), path, DIRSEP,\n               passwords_file);\n      fp = mg_fopen(buf, \"r\");\n    }\n\n    if (fp != NULL) {\n      authorized = mg_http_check_digest_auth(hm, domain, fp);\n      fclose(fp);\n    }\n  }\n\n  LOG(LL_DEBUG, (\"%s '%s' %d %d\", path, passwords_file ? passwords_file : \"\",\n                 is_global_pass_file, authorized));\n  return authorized;\n}\n#else\nstatic int mg_is_authorized(struct http_message *hm, const char *path,\n                            int is_directory, const char *domain,\n                            const char *passwords_file,\n                            int is_global_pass_file) {\n  (void) hm;\n  (void) path;\n  (void) is_directory;\n  (void) domain;\n  (void) passwords_file;\n  (void) is_global_pass_file;\n  return 1;\n}\n#endif\n\n#if MG_ENABLE_DIRECTORY_LISTING\nstatic size_t mg_url_encode(const char *src, size_t s_len, char *dst,\n                            size_t dst_len) {\n  static const char *dont_escape = \"._-$,;~()/\";\n  static const char *hex = \"0123456789abcdef\";\n  size_t i = 0, j = 0;\n\n  for (i = j = 0; dst_len > 0 && i < s_len && j + 2 < dst_len - 1; i++, j++) {\n    if (isalnum(*(const unsigned char *) (src + i)) ||\n        strchr(dont_escape, *(const unsigned char *) (src + i)) != NULL) {\n      dst[j] = src[i];\n    } else if (j + 3 < dst_len) {\n      dst[j] = '%';\n      dst[j + 1] = hex[(*(const unsigned char *) (src + i)) >> 4];\n      dst[j + 2] = hex[(*(const unsigned char *) (src + i)) & 0xf];\n      j += 2;\n    }\n  }\n\n  dst[j] = '\\0';\n  return j;\n}\n\nstatic void mg_escape(const char *src, char *dst, size_t dst_len) {\n  size_t n = 0;\n  while (*src != '\\0' && n + 5 < dst_len) {\n    unsigned char ch = *(unsigned char *) src++;\n    if (ch == '<') {\n      n += snprintf(dst + n, dst_len - n, \"%s\", \"&lt;\");\n    } else {\n      dst[n++] = ch;\n    }\n  }\n  dst[n] = '\\0';\n}\n\nstatic void mg_print_dir_entry(struct mg_connection *nc, const char *file_name,\n                               cs_stat_t *stp) {\n  char size[64], mod[64], href[MAX_PATH_SIZE * 3], path[MAX_PATH_SIZE];\n  int64_t fsize = stp->st_size;\n  int is_dir = S_ISDIR(stp->st_mode);\n  const char *slash = is_dir ? \"/\" : \"\";\n\n  if (is_dir) {\n    snprintf(size, sizeof(size), \"%s\", \"[DIRECTORY]\");\n  } else {\n    /*\n     * We use (double) cast below because MSVC 6 compiler cannot\n     * convert unsigned __int64 to double.\n     */\n    if (fsize < 1024) {\n      snprintf(size, sizeof(size), \"%d\", (int) fsize);\n    } else if (fsize < 0x100000) {\n      snprintf(size, sizeof(size), \"%.1fk\", (double) fsize / 1024.0);\n    } else if (fsize < 0x40000000) {\n      snprintf(size, sizeof(size), \"%.1fM\", (double) fsize / 1048576);\n    } else {\n      snprintf(size, sizeof(size), \"%.1fG\", (double) fsize / 1073741824);\n    }\n  }\n  strftime(mod, sizeof(mod), \"%d-%b-%Y %H:%M\", localtime(&stp->st_mtime));\n  mg_escape(file_name, path, sizeof(path));\n  mg_url_encode(file_name, strlen(file_name), href, sizeof(href));\n  mg_printf_http_chunk(nc,\n                       \"<tr><td><a href=\\\"%s%s\\\">%s%s</a></td>\"\n                       \"<td>%s</td><td name=%\" INT64_FMT \">%s</td></tr>\\n\",\n                       href, slash, path, slash, mod, is_dir ? -1 : fsize,\n                       size);\n}\n\nstatic void mg_scan_directory(struct mg_connection *nc, const char *dir,\n                              const struct mg_serve_http_opts *opts,\n                              void (*func)(struct mg_connection *, const char *,\n                                           cs_stat_t *)) {\n  char path[MAX_PATH_SIZE];\n  cs_stat_t st;\n  struct dirent *dp;\n  DIR *dirp;\n\n  LOG(LL_DEBUG, (\"%p [%s]\", nc, dir));\n  if ((dirp = (opendir(dir))) != NULL) {\n    while ((dp = readdir(dirp)) != NULL) {\n      /* Do not show current dir and hidden files */\n      if (mg_is_file_hidden((const char *) dp->d_name, opts, 1)) {\n        continue;\n      }\n      snprintf(path, sizeof(path), \"%s/%s\", dir, dp->d_name);\n      if (mg_stat(path, &st) == 0) {\n        func(nc, (const char *) dp->d_name, &st);\n      }\n    }\n    closedir(dirp);\n  } else {\n    LOG(LL_DEBUG, (\"%p opendir(%s) -> %d\", nc, dir, mg_get_errno()));\n  }\n}\n\nstatic void mg_send_directory_listing(struct mg_connection *nc, const char *dir,\n                                      struct http_message *hm,\n                                      struct mg_serve_http_opts *opts) {\n  static const char *sort_js_code =\n      \"<script>function srt(tb, sc, so, d) {\"\n      \"var tr = Array.prototype.slice.call(tb.rows, 0),\"\n      \"tr = tr.sort(function (a, b) { var c1 = a.cells[sc], c2 = b.cells[sc],\"\n      \"n1 = c1.getAttribute('name'), n2 = c2.getAttribute('name'), \"\n      \"t1 = a.cells[2].getAttribute('name'), \"\n      \"t2 = b.cells[2].getAttribute('name'); \"\n      \"return so * (t1 < 0 && t2 >= 0 ? -1 : t2 < 0 && t1 >= 0 ? 1 : \"\n      \"n1 ? parseInt(n2) - parseInt(n1) : \"\n      \"c1.textContent.trim().localeCompare(c2.textContent.trim())); });\";\n  static const char *sort_js_code2 =\n      \"for (var i = 0; i < tr.length; i++) tb.appendChild(tr[i]); \"\n      \"if (!d) window.location.hash = ('sc=' + sc + '&so=' + so); \"\n      \"};\"\n      \"window.onload = function() {\"\n      \"var tb = document.getElementById('tb');\"\n      \"var m = /sc=([012]).so=(1|-1)/.exec(window.location.hash) || [0, 2, 1];\"\n      \"var sc = m[1], so = m[2]; document.onclick = function(ev) { \"\n      \"var c = ev.target.rel; if (c) {if (c == sc) so *= -1; srt(tb, c, so); \"\n      \"sc = c; ev.preventDefault();}};\"\n      \"srt(tb, sc, so, true);\"\n      \"}\"\n      \"</script>\";\n\n  mg_send_response_line(nc, 200, opts->extra_headers);\n  mg_printf(nc, \"%s: %s\\r\\n%s: %s\\r\\n\\r\\n\", \"Transfer-Encoding\", \"chunked\",\n            \"Content-Type\", \"text/html; charset=utf-8\");\n\n  mg_printf_http_chunk(\n      nc,\n      \"<html><head><title>Index of %.*s</title>%s%s\"\n      \"<style>th,td {text-align: left; padding-right: 1em; \"\n      \"font-family: monospace; }</style></head>\\n\"\n      \"<body><h1>Index of %.*s</h1>\\n<table cellpadding=0><thead>\"\n      \"<tr><th><a href=# rel=0>Name</a></th><th>\"\n      \"<a href=# rel=1>Modified</a</th>\"\n      \"<th><a href=# rel=2>Size</a></th></tr>\"\n      \"<tr><td colspan=3><hr></td></tr>\\n\"\n      \"</thead>\\n\"\n      \"<tbody id=tb>\",\n      (int) hm->uri.len, hm->uri.p, sort_js_code, sort_js_code2,\n      (int) hm->uri.len, hm->uri.p);\n  mg_scan_directory(nc, dir, opts, mg_print_dir_entry);\n  mg_printf_http_chunk(nc,\n                       \"</tbody><tr><td colspan=3><hr></td></tr>\\n\"\n                       \"</table>\\n\"\n                       \"<address>%s</address>\\n\"\n                       \"</body></html>\",\n                       mg_version_header);\n  mg_send_http_chunk(nc, \"\", 0);\n  /* TODO(rojer): Remove when cesanta/dev/issues/197 is fixed. */\n  nc->flags |= MG_F_SEND_AND_CLOSE;\n}\n#endif /* MG_ENABLE_DIRECTORY_LISTING */\n\n/*\n * Given a directory path, find one of the files specified in the\n * comma-separated list of index files `list`.\n * First found index file wins. If an index file is found, then gets\n * appended to the `path`, stat-ed, and result of `stat()` passed to `stp`.\n * If index file is not found, then `path` and `stp` remain unchanged.\n */\nMG_INTERNAL void mg_find_index_file(const char *path, const char *list,\n                                    char **index_file, cs_stat_t *stp) {\n  struct mg_str vec;\n  size_t path_len = strlen(path);\n  int found = 0;\n  *index_file = NULL;\n\n  /* Traverse index files list. For each entry, append it to the given */\n  /* path and see if the file exists. If it exists, break the loop */\n  while ((list = mg_next_comma_list_entry(list, &vec, NULL)) != NULL) {\n    cs_stat_t st;\n    size_t len = path_len + 1 + vec.len + 1;\n    *index_file = (char *) MG_REALLOC(*index_file, len);\n    if (*index_file == NULL) break;\n    snprintf(*index_file, len, \"%s%c%.*s\", path, DIRSEP, (int) vec.len, vec.p);\n\n    /* Does it exist? Is it a file? */\n    if (mg_stat(*index_file, &st) == 0 && S_ISREG(st.st_mode)) {\n      /* Yes it does, break the loop */\n      *stp = st;\n      found = 1;\n      break;\n    }\n  }\n  if (!found) {\n    MG_FREE(*index_file);\n    *index_file = NULL;\n  }\n  LOG(LL_DEBUG, (\"[%s] [%s]\", path, (*index_file ? *index_file : \"\")));\n}\n\n#if MG_ENABLE_HTTP_URL_REWRITES\nstatic int mg_http_send_port_based_redirect(\n    struct mg_connection *c, struct http_message *hm,\n    const struct mg_serve_http_opts *opts) {\n  const char *rewrites = opts->url_rewrites;\n  struct mg_str a, b;\n  char local_port[20] = {'%'};\n\n  mg_conn_addr_to_str(c, local_port + 1, sizeof(local_port) - 1,\n                      MG_SOCK_STRINGIFY_PORT);\n\n  while ((rewrites = mg_next_comma_list_entry(rewrites, &a, &b)) != NULL) {\n    if (mg_vcmp(&a, local_port) == 0) {\n      mg_send_response_line(c, 301, NULL);\n      mg_printf(c, \"Content-Length: 0\\r\\nLocation: %.*s%.*s\\r\\n\\r\\n\",\n                (int) b.len, b.p, (int) (hm->proto.p - hm->uri.p - 1),\n                hm->uri.p);\n      return 1;\n    }\n  }\n\n  return 0;\n}\n\nstatic void mg_reverse_proxy_handler(struct mg_connection *nc, int ev,\n                                     void *ev_data MG_UD_ARG(void *user_data)) {\n  struct http_message *hm = (struct http_message *) ev_data;\n  struct mg_http_proto_data *pd = mg_http_get_proto_data(nc);\n\n  if (pd == NULL || pd->reverse_proxy_data.linked_conn == NULL) {\n    DBG((\"%p: upstream closed\", nc));\n    return;\n  }\n\n  switch (ev) {\n    case MG_EV_CONNECT:\n      if (*(int *) ev_data != 0) {\n        mg_http_send_error(pd->reverse_proxy_data.linked_conn, 502, NULL);\n      }\n      break;\n    /* TODO(mkm): handle streaming */\n    case MG_EV_HTTP_REPLY:\n      mg_send(pd->reverse_proxy_data.linked_conn, hm->message.p,\n              hm->message.len);\n      pd->reverse_proxy_data.linked_conn->flags |= MG_F_SEND_AND_CLOSE;\n      nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n      break;\n    case MG_EV_CLOSE:\n      pd->reverse_proxy_data.linked_conn->flags |= MG_F_SEND_AND_CLOSE;\n      break;\n  }\n\n#if MG_ENABLE_CALLBACK_USERDATA\n  (void) user_data;\n#endif\n}\n\nvoid mg_http_reverse_proxy(struct mg_connection *nc,\n                           const struct http_message *hm, struct mg_str mount,\n                           struct mg_str upstream) {\n  struct mg_connection *be;\n  char burl[256], *purl = burl;\n  char *addr = NULL;\n  const char *path = NULL;\n  int i;\n  const char *error;\n  struct mg_connect_opts opts;\n  memset(&opts, 0, sizeof(opts));\n  opts.error_string = &error;\n\n  mg_asprintf(&purl, sizeof(burl), \"%.*s%.*s\", (int) upstream.len, upstream.p,\n              (int) (hm->uri.len - mount.len), hm->uri.p + mount.len);\n\n  be = mg_connect_http_base(nc->mgr, MG_CB(mg_reverse_proxy_handler, NULL),\n                            opts, \"http://\", \"https://\", purl, &path,\n                            NULL /* user */, NULL /* pass */, &addr);\n  LOG(LL_DEBUG, (\"Proxying %.*s to %s (rule: %.*s)\", (int) hm->uri.len,\n                 hm->uri.p, purl, (int) mount.len, mount.p));\n\n  if (be == NULL) {\n    LOG(LL_ERROR, (\"Error connecting to %s: %s\", purl, error));\n    mg_http_send_error(nc, 502, NULL);\n    goto cleanup;\n  }\n\n  /* link connections to each other, they must live and die together */\n  mg_http_get_proto_data(be)->reverse_proxy_data.linked_conn = nc;\n  mg_http_get_proto_data(nc)->reverse_proxy_data.linked_conn = be;\n\n  /* send request upstream */\n  mg_printf(be, \"%.*s %s HTTP/1.1\\r\\n\", (int) hm->method.len, hm->method.p,\n            path);\n\n  mg_printf(be, \"Host: %s\\r\\n\", addr);\n  for (i = 0; i < MG_MAX_HTTP_HEADERS && hm->header_names[i].len > 0; i++) {\n    struct mg_str hn = hm->header_names[i];\n    struct mg_str hv = hm->header_values[i];\n\n    /* we rewrite the host header */\n    if (mg_vcasecmp(&hn, \"Host\") == 0) continue;\n    /*\n     * Don't pass chunked transfer encoding to the client because hm->body is\n     * already dechunked when we arrive here.\n     */\n    if (mg_vcasecmp(&hn, \"Transfer-encoding\") == 0 &&\n        mg_vcasecmp(&hv, \"chunked\") == 0) {\n      mg_printf(be, \"Content-Length: %\" SIZE_T_FMT \"\\r\\n\", hm->body.len);\n      continue;\n    }\n    /* We don't support proxying Expect: 100-continue. */\n    if (mg_vcasecmp(&hn, \"Expect\") == 0 &&\n        mg_vcasecmp(&hv, \"100-continue\") == 0) {\n      continue;\n    }\n\n    mg_printf(be, \"%.*s: %.*s\\r\\n\", (int) hn.len, hn.p, (int) hv.len, hv.p);\n  }\n\n  mg_send(be, \"\\r\\n\", 2);\n  mg_send(be, hm->body.p, hm->body.len);\n\ncleanup:\n  if (purl != burl) MG_FREE(purl);\n}\n\nstatic int mg_http_handle_forwarding(struct mg_connection *nc,\n                                     struct http_message *hm,\n                                     const struct mg_serve_http_opts *opts) {\n  const char *rewrites = opts->url_rewrites;\n  struct mg_str a, b;\n  struct mg_str p1 = MG_MK_STR(\"http://\"), p2 = MG_MK_STR(\"https://\");\n\n  while ((rewrites = mg_next_comma_list_entry(rewrites, &a, &b)) != NULL) {\n    if (mg_strncmp(a, hm->uri, a.len) == 0) {\n      if (mg_strncmp(b, p1, p1.len) == 0 || mg_strncmp(b, p2, p2.len) == 0) {\n        mg_http_reverse_proxy(nc, hm, a, b);\n        return 1;\n      }\n    }\n  }\n\n  return 0;\n}\n#endif\n\nMG_INTERNAL int mg_uri_to_local_path(struct http_message *hm,\n                                     const struct mg_serve_http_opts *opts,\n                                     char **local_path,\n                                     struct mg_str *remainder) {\n  int ok = 1;\n  const char *cp = hm->uri.p, *cp_end = hm->uri.p + hm->uri.len;\n  struct mg_str root = {NULL, 0};\n  const char *file_uri_start = cp;\n  *local_path = NULL;\n  remainder->p = NULL;\n  remainder->len = 0;\n\n  { /* 1. Determine which root to use. */\n\n#if MG_ENABLE_HTTP_URL_REWRITES\n    const char *rewrites = opts->url_rewrites;\n#else\n    const char *rewrites = \"\";\n#endif\n    struct mg_str *hh = mg_get_http_header(hm, \"Host\");\n    struct mg_str a, b;\n    /* Check rewrites first. */\n    while ((rewrites = mg_next_comma_list_entry(rewrites, &a, &b)) != NULL) {\n      if (a.len > 1 && a.p[0] == '@') {\n        /* Host rewrite. */\n        if (hh != NULL && hh->len == a.len - 1 &&\n            mg_ncasecmp(a.p + 1, hh->p, a.len - 1) == 0) {\n          root = b;\n          break;\n        }\n      } else {\n        /* Regular rewrite, URI=directory */\n        int match_len = mg_match_prefix_n(a, hm->uri);\n        if (match_len > 0) {\n          file_uri_start = hm->uri.p + match_len;\n          if (*file_uri_start == '/' || file_uri_start == cp_end) {\n            /* Match ended at component boundary, ok. */\n          } else if (*(file_uri_start - 1) == '/') {\n            /* Pattern ends with '/', backtrack. */\n            file_uri_start--;\n          } else {\n            /* No match: must fall on the component boundary. */\n            continue;\n          }\n          root = b;\n          break;\n        }\n      }\n    }\n    /* If no rewrite rules matched, use DAV or regular document root. */\n    if (root.p == NULL) {\n#if MG_ENABLE_HTTP_WEBDAV\n      if (opts->dav_document_root != NULL && mg_is_dav_request(&hm->method)) {\n        root.p = opts->dav_document_root;\n        root.len = strlen(opts->dav_document_root);\n      } else\n#endif\n      {\n        root.p = opts->document_root;\n        root.len = strlen(opts->document_root);\n      }\n    }\n    assert(root.p != NULL && root.len > 0);\n  }\n\n  { /* 2. Find where in the canonical URI path the local path ends. */\n    const char *u = file_uri_start + 1;\n    char *lp = (char *) MG_MALLOC(root.len + hm->uri.len + 1);\n    char *lp_end = lp + root.len + hm->uri.len + 1;\n    char *p = lp, *ps;\n    int exists = 1;\n    if (lp == NULL) {\n      ok = 0;\n      goto out;\n    }\n    memcpy(p, root.p, root.len);\n    p += root.len;\n    if (*(p - 1) == DIRSEP) p--;\n    *p = '\\0';\n    ps = p;\n\n    /* Chop off URI path components one by one and build local path. */\n    while (u <= cp_end) {\n      const char *next = u;\n      struct mg_str component;\n      if (exists) {\n        cs_stat_t st;\n        exists = (mg_stat(lp, &st) == 0);\n        if (exists && S_ISREG(st.st_mode)) {\n          /* We found the terminal, the rest of the URI (if any) is path_info.\n           */\n          if (*(u - 1) == '/') u--;\n          break;\n        }\n      }\n      if (u >= cp_end) break;\n      parse_uri_component((const char **) &next, cp_end, '/', &component);\n      if (component.len > 0) {\n        int len;\n        memmove(p + 1, component.p, component.len);\n        len = mg_url_decode(p + 1, component.len, p + 1, lp_end - p - 1, 0);\n        if (len <= 0) {\n          ok = 0;\n          break;\n        }\n        component.p = p + 1;\n        component.len = len;\n        if (mg_vcmp(&component, \".\") == 0) {\n          /* Yum. */\n        } else if (mg_vcmp(&component, \"..\") == 0) {\n          while (p > ps && *p != DIRSEP) p--;\n          *p = '\\0';\n        } else {\n          size_t i;\n#ifdef _WIN32\n          /* On Windows, make sure it's valid Unicode (no funny stuff). */\n          wchar_t buf[MG_MAX_PATH * 2];\n          if (to_wchar(component.p, buf, MG_MAX_PATH) == 0) {\n            DBG((\"[%.*s] smells funny\", (int) component.len, component.p));\n            ok = 0;\n            break;\n          }\n#endif\n          *p++ = DIRSEP;\n          /* No NULs and DIRSEPs in the component (percent-encoded). */\n          for (i = 0; i < component.len; i++, p++) {\n            if (*p == '\\0' || *p == DIRSEP\n#ifdef _WIN32\n                /* On Windows, \"/\" is also accepted, so check for that too. */\n                ||\n                *p == '/'\n#endif\n                ) {\n              ok = 0;\n              break;\n            }\n          }\n        }\n      }\n      u = next;\n    }\n    if (ok) {\n      *local_path = lp;\n      if (u > cp_end) u = cp_end;\n      remainder->p = u;\n      remainder->len = cp_end - u;\n    } else {\n      MG_FREE(lp);\n    }\n  }\n\nout:\n  LOG(LL_DEBUG,\n      (\"'%.*s' -> '%s' + '%.*s'\", (int) hm->uri.len, hm->uri.p,\n       *local_path ? *local_path : \"\", (int) remainder->len, remainder->p));\n  return ok;\n}\n\nstatic int mg_get_month_index(const char *s) {\n  static const char *month_names[] = {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n                                      \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"};\n  size_t i;\n\n  for (i = 0; i < ARRAY_SIZE(month_names); i++)\n    if (!strcmp(s, month_names[i])) return (int) i;\n\n  return -1;\n}\n\nstatic int mg_num_leap_years(int year) {\n  return year / 4 - year / 100 + year / 400;\n}\n\n/* Parse UTC date-time string, and return the corresponding time_t value. */\nMG_INTERNAL time_t mg_parse_date_string(const char *datetime) {\n  static const unsigned short days_before_month[] = {\n      0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};\n  char month_str[32];\n  int second, minute, hour, day, month, year, leap_days, days;\n  time_t result = (time_t) 0;\n\n  if (((sscanf(datetime, \"%d/%3s/%d %d:%d:%d\", &day, month_str, &year, &hour,\n               &minute, &second) == 6) ||\n       (sscanf(datetime, \"%d %3s %d %d:%d:%d\", &day, month_str, &year, &hour,\n               &minute, &second) == 6) ||\n       (sscanf(datetime, \"%*3s, %d %3s %d %d:%d:%d\", &day, month_str, &year,\n               &hour, &minute, &second) == 6) ||\n       (sscanf(datetime, \"%d-%3s-%d %d:%d:%d\", &day, month_str, &year, &hour,\n               &minute, &second) == 6)) &&\n      year > 1970 && (month = mg_get_month_index(month_str)) != -1) {\n    leap_days = mg_num_leap_years(year) - mg_num_leap_years(1970);\n    year -= 1970;\n    days = year * 365 + days_before_month[month] + (day - 1) + leap_days;\n    result = days * 24 * 3600 + hour * 3600 + minute * 60 + second;\n  }\n\n  return result;\n}\n\nMG_INTERNAL int mg_is_not_modified(struct http_message *hm, cs_stat_t *st) {\n  struct mg_str *hdr;\n  if ((hdr = mg_get_http_header(hm, \"If-None-Match\")) != NULL) {\n    char etag[64];\n    mg_http_construct_etag(etag, sizeof(etag), st);\n    return mg_vcasecmp(hdr, etag) == 0;\n  } else if ((hdr = mg_get_http_header(hm, \"If-Modified-Since\")) != NULL) {\n    return st->st_mtime <= mg_parse_date_string(hdr->p);\n  } else {\n    return 0;\n  }\n}\n\nstatic void mg_http_send_digest_auth_request(struct mg_connection *c,\n                                             const char *domain) {\n  mg_printf(c,\n            \"HTTP/1.1 401 Unauthorized\\r\\n\"\n            \"WWW-Authenticate: Digest qop=\\\"auth\\\", \"\n            \"realm=\\\"%s\\\", nonce=\\\"%lu\\\"\\r\\n\"\n            \"Content-Length: 0\\r\\n\\r\\n\",\n            domain, (unsigned long) mg_time());\n}\n\nstatic void mg_http_send_options(struct mg_connection *nc) {\n  mg_printf(nc, \"%s\",\n            \"HTTP/1.1 200 OK\\r\\nAllow: GET, POST, HEAD, CONNECT, OPTIONS\"\n#if MG_ENABLE_HTTP_WEBDAV\n            \", MKCOL, PUT, DELETE, PROPFIND, MOVE\\r\\nDAV: 1,2\"\n#endif\n            \"\\r\\n\\r\\n\");\n  nc->flags |= MG_F_SEND_AND_CLOSE;\n}\n\nstatic int mg_is_creation_request(const struct http_message *hm) {\n  return mg_vcmp(&hm->method, \"MKCOL\") == 0 || mg_vcmp(&hm->method, \"PUT\") == 0;\n}\n\nMG_INTERNAL void mg_send_http_file(struct mg_connection *nc, char *path,\n                                   const struct mg_str *path_info,\n                                   struct http_message *hm,\n                                   struct mg_serve_http_opts *opts) {\n  int exists, is_directory, is_cgi;\n#if MG_ENABLE_HTTP_WEBDAV\n  int is_dav = mg_is_dav_request(&hm->method);\n#else\n  int is_dav = 0;\n#endif\n  char *index_file = NULL;\n  cs_stat_t st;\n\n  exists = (mg_stat(path, &st) == 0);\n  is_directory = exists && S_ISDIR(st.st_mode);\n\n  if (is_directory)\n    mg_find_index_file(path, opts->index_files, &index_file, &st);\n\n  is_cgi =\n      (mg_match_prefix(opts->cgi_file_pattern, strlen(opts->cgi_file_pattern),\n                       index_file ? index_file : path) > 0);\n\n  LOG(LL_DEBUG,\n      (\"%p %.*s [%s] exists=%d is_dir=%d is_dav=%d is_cgi=%d index=%s\", nc,\n       (int) hm->method.len, hm->method.p, path, exists, is_directory, is_dav,\n       is_cgi, index_file ? index_file : \"\"));\n\n  if (is_directory && hm->uri.p[hm->uri.len - 1] != '/' && !is_dav) {\n    mg_printf(nc,\n              \"HTTP/1.1 301 Moved\\r\\nLocation: %.*s/\\r\\n\"\n              \"Content-Length: 0\\r\\n\\r\\n\",\n              (int) hm->uri.len, hm->uri.p);\n    MG_FREE(index_file);\n    return;\n  }\n\n  /* If we have path_info, the only way to handle it is CGI. */\n  if (path_info->len > 0 && !is_cgi) {\n    mg_http_send_error(nc, 501, NULL);\n    MG_FREE(index_file);\n    return;\n  }\n\n  if (is_dav && opts->dav_document_root == NULL) {\n    mg_http_send_error(nc, 501, NULL);\n  } else if (!mg_is_authorized(hm, path, is_directory, opts->auth_domain,\n                               opts->global_auth_file, 1) ||\n             !mg_is_authorized(hm, path, is_directory, opts->auth_domain,\n                               opts->per_directory_auth_file, 0)) {\n    mg_http_send_digest_auth_request(nc, opts->auth_domain);\n  } else if (is_cgi) {\n#if MG_ENABLE_HTTP_CGI\n    mg_handle_cgi(nc, index_file ? index_file : path, path_info, hm, opts);\n#else\n    mg_http_send_error(nc, 501, NULL);\n#endif /* MG_ENABLE_HTTP_CGI */\n  } else if ((!exists ||\n              mg_is_file_hidden(path, opts, 0 /* specials are ok */)) &&\n             !mg_is_creation_request(hm)) {\n    mg_http_send_error(nc, 404, NULL);\n#if MG_ENABLE_HTTP_WEBDAV\n  } else if (!mg_vcmp(&hm->method, \"PROPFIND\")) {\n    mg_handle_propfind(nc, path, &st, hm, opts);\n#if !MG_DISABLE_DAV_AUTH\n  } else if (is_dav &&\n             (opts->dav_auth_file == NULL ||\n              (strcmp(opts->dav_auth_file, \"-\") != 0 &&\n               !mg_is_authorized(hm, path, is_directory, opts->auth_domain,\n                                 opts->dav_auth_file, 1)))) {\n    mg_http_send_digest_auth_request(nc, opts->auth_domain);\n#endif\n  } else if (!mg_vcmp(&hm->method, \"MKCOL\")) {\n    mg_handle_mkcol(nc, path, hm);\n  } else if (!mg_vcmp(&hm->method, \"DELETE\")) {\n    mg_handle_delete(nc, opts, path);\n  } else if (!mg_vcmp(&hm->method, \"PUT\")) {\n    mg_handle_put(nc, path, hm);\n  } else if (!mg_vcmp(&hm->method, \"MOVE\")) {\n    mg_handle_move(nc, opts, path, hm);\n#if MG_ENABLE_FAKE_DAVLOCK\n  } else if (!mg_vcmp(&hm->method, \"LOCK\")) {\n    mg_handle_lock(nc, path);\n#endif\n#endif /* MG_ENABLE_HTTP_WEBDAV */\n  } else if (!mg_vcmp(&hm->method, \"OPTIONS\")) {\n    mg_http_send_options(nc);\n  } else if (is_directory && index_file == NULL) {\n#if MG_ENABLE_DIRECTORY_LISTING\n    if (strcmp(opts->enable_directory_listing, \"yes\") == 0) {\n      mg_send_directory_listing(nc, path, hm, opts);\n    } else {\n      mg_http_send_error(nc, 403, NULL);\n    }\n#else\n    mg_http_send_error(nc, 501, NULL);\n#endif\n  } else if (mg_is_not_modified(hm, &st)) {\n    mg_http_send_error(nc, 304, \"Not Modified\");\n  } else {\n    mg_http_serve_file2(nc, index_file ? index_file : path, hm, opts);\n  }\n  MG_FREE(index_file);\n}\n\nvoid mg_serve_http(struct mg_connection *nc, struct http_message *hm,\n                   struct mg_serve_http_opts opts) {\n  char *path = NULL;\n  struct mg_str *hdr, path_info;\n  uint32_t remote_ip = ntohl(*(uint32_t *) &nc->sa.sin.sin_addr);\n\n  if (mg_check_ip_acl(opts.ip_acl, remote_ip) != 1) {\n    /* Not allowed to connect */\n    mg_http_send_error(nc, 403, NULL);\n    nc->flags |= MG_F_SEND_AND_CLOSE;\n    return;\n  }\n\n#if MG_ENABLE_HTTP_URL_REWRITES\n  if (mg_http_handle_forwarding(nc, hm, &opts)) {\n    return;\n  }\n\n  if (mg_http_send_port_based_redirect(nc, hm, &opts)) {\n    return;\n  }\n#endif\n\n  if (opts.document_root == NULL) {\n    opts.document_root = \".\";\n  }\n  if (opts.per_directory_auth_file == NULL) {\n    opts.per_directory_auth_file = \".htpasswd\";\n  }\n  if (opts.enable_directory_listing == NULL) {\n    opts.enable_directory_listing = \"yes\";\n  }\n  if (opts.cgi_file_pattern == NULL) {\n    opts.cgi_file_pattern = \"**.cgi$|**.php$\";\n  }\n  if (opts.ssi_pattern == NULL) {\n    opts.ssi_pattern = \"**.shtml$|**.shtm$\";\n  }\n  if (opts.index_files == NULL) {\n    opts.index_files = \"index.html,index.htm,index.shtml,index.cgi,index.php\";\n  }\n  /* Normalize path - resolve \".\" and \"..\" (in-place). */\n  if (!mg_normalize_uri_path(&hm->uri, &hm->uri)) {\n    mg_http_send_error(nc, 400, NULL);\n    return;\n  }\n  if (mg_uri_to_local_path(hm, &opts, &path, &path_info) == 0) {\n    mg_http_send_error(nc, 404, NULL);\n    return;\n  }\n  mg_send_http_file(nc, path, &path_info, hm, &opts);\n\n  MG_FREE(path);\n  path = NULL;\n\n  /* Close connection for non-keep-alive requests */\n  if (mg_vcmp(&hm->proto, \"HTTP/1.1\") != 0 ||\n      ((hdr = mg_get_http_header(hm, \"Connection\")) != NULL &&\n       mg_vcmp(hdr, \"keep-alive\") != 0)) {\n#if 0\n    nc->flags |= MG_F_SEND_AND_CLOSE;\n#endif\n  }\n}\n\n#if MG_ENABLE_HTTP_STREAMING_MULTIPART\nvoid mg_file_upload_handler(struct mg_connection *nc, int ev, void *ev_data,\n                            mg_fu_fname_fn local_name_fn\n                                MG_UD_ARG(void *user_data)) {\n  switch (ev) {\n    case MG_EV_HTTP_PART_BEGIN: {\n      struct mg_http_multipart_part *mp =\n          (struct mg_http_multipart_part *) ev_data;\n      struct file_upload_state *fus =\n          (struct file_upload_state *) MG_CALLOC(1, sizeof(*fus));\n      struct mg_str lfn = local_name_fn(nc, mg_mk_str(mp->file_name));\n      mp->user_data = NULL;\n      if (lfn.p == NULL || lfn.len == 0) {\n        LOG(LL_ERROR, (\"%p Not allowed to upload %s\", nc, mp->file_name));\n        mg_printf(nc,\n                  \"HTTP/1.1 403 Not Allowed\\r\\n\"\n                  \"Content-Type: text/plain\\r\\n\"\n                  \"Connection: close\\r\\n\\r\\n\"\n                  \"Not allowed to upload %s\\r\\n\",\n                  mp->file_name);\n        nc->flags |= MG_F_SEND_AND_CLOSE;\n        return;\n      }\n      fus->lfn = (char *) MG_MALLOC(lfn.len + 1);\n      memcpy(fus->lfn, lfn.p, lfn.len);\n      fus->lfn[lfn.len] = '\\0';\n      if (lfn.p != mp->file_name) MG_FREE((char *) lfn.p);\n      LOG(LL_DEBUG,\n          (\"%p Receiving file %s -> %s\", nc, mp->file_name, fus->lfn));\n      fus->fp = mg_fopen(fus->lfn, \"w\");\n      if (fus->fp == NULL) {\n        mg_printf(nc,\n                  \"HTTP/1.1 500 Internal Server Error\\r\\n\"\n                  \"Content-Type: text/plain\\r\\n\"\n                  \"Connection: close\\r\\n\\r\\n\");\n        LOG(LL_ERROR, (\"Failed to open %s: %d\\n\", fus->lfn, mg_get_errno()));\n        mg_printf(nc, \"Failed to open %s: %d\\n\", fus->lfn, mg_get_errno());\n        /* Do not close the connection just yet, discard remainder of the data.\n         * This is because at the time of writing some browsers (Chrome) fail to\n         * render response before all the data is sent. */\n      }\n      mp->user_data = (void *) fus;\n      break;\n    }\n    case MG_EV_HTTP_PART_DATA: {\n      struct mg_http_multipart_part *mp =\n          (struct mg_http_multipart_part *) ev_data;\n      struct file_upload_state *fus =\n          (struct file_upload_state *) mp->user_data;\n      if (fus == NULL || fus->fp == NULL) break;\n      if (mg_fwrite(mp->data.p, 1, mp->data.len, fus->fp) != mp->data.len) {\n        LOG(LL_ERROR, (\"Failed to write to %s: %d, wrote %d\", fus->lfn,\n                       mg_get_errno(), (int) fus->num_recd));\n        if (mg_get_errno() == ENOSPC\n#ifdef SPIFFS_ERR_FULL\n            || mg_get_errno() == SPIFFS_ERR_FULL\n#endif\n            ) {\n          mg_printf(nc,\n                    \"HTTP/1.1 413 Payload Too Large\\r\\n\"\n                    \"Content-Type: text/plain\\r\\n\"\n                    \"Connection: close\\r\\n\\r\\n\");\n          mg_printf(nc, \"Failed to write to %s: no space left; wrote %d\\r\\n\",\n                    fus->lfn, (int) fus->num_recd);\n        } else {\n          mg_printf(nc,\n                    \"HTTP/1.1 500 Internal Server Error\\r\\n\"\n                    \"Content-Type: text/plain\\r\\n\"\n                    \"Connection: close\\r\\n\\r\\n\");\n          mg_printf(nc, \"Failed to write to %s: %d, wrote %d\", mp->file_name,\n                    mg_get_errno(), (int) fus->num_recd);\n        }\n        fclose(fus->fp);\n        remove(fus->lfn);\n        fus->fp = NULL;\n        /* Do not close the connection just yet, discard remainder of the data.\n         * This is because at the time of writing some browsers (Chrome) fail to\n         * render response before all the data is sent. */\n        return;\n      }\n      fus->num_recd += mp->data.len;\n      LOG(LL_DEBUG, (\"%p rec'd %d bytes, %d total\", nc, (int) mp->data.len,\n                     (int) fus->num_recd));\n      break;\n    }\n    case MG_EV_HTTP_PART_END: {\n      struct mg_http_multipart_part *mp =\n          (struct mg_http_multipart_part *) ev_data;\n      struct file_upload_state *fus =\n          (struct file_upload_state *) mp->user_data;\n      if (fus == NULL) break;\n      if (mp->status >= 0 && fus->fp != NULL) {\n        LOG(LL_DEBUG, (\"%p Uploaded %s (%s), %d bytes\", nc, mp->file_name,\n                       fus->lfn, (int) fus->num_recd));\n        mg_printf(nc,\n                  \"HTTP/1.1 200 OK\\r\\n\"\n                  \"Content-Type: text/plain\\r\\n\"\n                  \"Connection: close\\r\\n\\r\\n\"\n                  \"Ok, %s - %d bytes.\\r\\n\",\n                  mp->file_name, (int) fus->num_recd);\n      } else {\n        LOG(LL_ERROR, (\"Failed to store %s (%s)\", mp->file_name, fus->lfn));\n        /*\n         * mp->status < 0 means connection was terminated, so no reason to send\n         * HTTP reply\n         */\n      }\n      if (fus->fp != NULL) fclose(fus->fp);\n      MG_FREE(fus->lfn);\n      MG_FREE(fus);\n      mp->user_data = NULL;\n      nc->flags |= MG_F_SEND_AND_CLOSE;\n      break;\n    }\n  }\n\n#if MG_ENABLE_CALLBACK_USERDATA\n  (void) user_data;\n#endif\n}\n\n#endif /* MG_ENABLE_HTTP_STREAMING_MULTIPART */\n#endif /* MG_ENABLE_FILESYSTEM */\n\n/* returns 0 on success, -1 on error */\nMG_INTERNAL int mg_http_common_url_parse(const char *url, const char *schema,\n                                         const char *schema_tls, int *use_ssl,\n                                         char **user, char **pass, char **addr,\n                                         int *port_i, const char **path) {\n  int addr_len = 0;\n  int auth_sep_pos = -1;\n  int user_sep_pos = -1;\n  int port_pos = -1;\n  (void) user;\n  (void) pass;\n\n  if (strncmp(url, schema, strlen(schema)) == 0) {\n    url += strlen(schema);\n  } else if (strncmp(url, schema_tls, strlen(schema_tls)) == 0) {\n    url += strlen(schema_tls);\n    *use_ssl = 1;\n#if !MG_ENABLE_SSL\n    return -1; /* SSL is not enabled, cannot do HTTPS URLs */\n#endif\n  }\n\n  while (*url != '\\0') {\n    *addr = (char *) MG_REALLOC(*addr, addr_len + 6 /* space for port too. */);\n    if (*addr == NULL) {\n      DBG((\"OOM\"));\n      return -1;\n    }\n    if (*url == '/') {\n      break;\n    }\n    if (*url == '@') {\n      auth_sep_pos = addr_len;\n      user_sep_pos = port_pos;\n      port_pos = -1;\n    }\n    if (*url == ':') port_pos = addr_len;\n    (*addr)[addr_len++] = *url;\n    (*addr)[addr_len] = '\\0';\n    url++;\n  }\n\n  if (addr_len == 0) goto cleanup;\n  if (port_pos < 0) {\n    *port_i = addr_len;\n    addr_len += sprintf(*addr + addr_len, \":%d\", *use_ssl ? 443 : 80);\n  } else {\n    *port_i = -1;\n  }\n\n  if (*path == NULL) *path = url;\n\n  if (**path == '\\0') *path = \"/\";\n\n  if (user != NULL && pass != NULL) {\n    if (auth_sep_pos == -1) {\n      *user = NULL;\n      *pass = NULL;\n    } else {\n      /* user is from 0 to user_sep_pos */\n      *user = (char *) MG_MALLOC(user_sep_pos + 1);\n      memcpy(*user, *addr, user_sep_pos);\n      (*user)[user_sep_pos] = '\\0';\n      /* pass is from user_sep_pos + 1 to auth_sep_pos */\n      *pass = (char *) MG_MALLOC(auth_sep_pos - user_sep_pos - 1 + 1);\n      memcpy(*pass, *addr + user_sep_pos + 1, auth_sep_pos - user_sep_pos - 1);\n      (*pass)[auth_sep_pos - user_sep_pos - 1] = '\\0';\n\n      /* move address proper to the front */\n      memmove(*addr, *addr + auth_sep_pos + 1, addr_len - auth_sep_pos);\n    }\n  }\n\n  DBG((\"%s %s\", *addr, *path));\n\n  return 0;\n\ncleanup:\n  MG_FREE(*addr);\n  return -1;\n}\n\nstruct mg_connection *mg_connect_http_base(\n    struct mg_mgr *mgr, MG_CB(mg_event_handler_t ev_handler, void *user_data),\n    struct mg_connect_opts opts, const char *schema, const char *schema_ssl,\n    const char *url, const char **path, char **user, char **pass, char **addr) {\n  struct mg_connection *nc = NULL;\n  int port_i = -1;\n  int use_ssl = 0;\n\n  if (mg_http_common_url_parse(url, schema, schema_ssl, &use_ssl, user, pass,\n                               addr, &port_i, path) < 0) {\n    MG_SET_PTRPTR(opts.error_string, \"cannot parse url\");\n    return NULL;\n  }\n\n  LOG(LL_DEBUG, (\"%s use_ssl? %d\", url, use_ssl));\n  if (use_ssl) {\n#if MG_ENABLE_SSL\n    /*\n     * Schema requires SSL, but no SSL parameters were provided in opts.\n     * In order to maintain backward compatibility, use a faux-SSL with no\n     * verification.\n     */\n    if (opts.ssl_ca_cert == NULL) {\n      opts.ssl_ca_cert = \"*\";\n    }\n#else\n    MG_SET_PTRPTR(opts.error_string, \"ssl is disabled\");\n    if (user != NULL) MG_FREE(*user);\n    if (pass != NULL) MG_FREE(*pass);\n    MG_FREE(*addr);\n    return NULL;\n#endif\n  }\n\n  if ((nc = mg_connect_opt(mgr, *addr, MG_CB(ev_handler, user_data), opts)) !=\n      NULL) {\n    mg_set_protocol_http_websocket(nc);\n    /* If the port was addred by us, restore the original host. */\n    if (port_i >= 0) (*addr)[port_i] = '\\0';\n  }\n\n  return nc;\n}\n\nstruct mg_connection *mg_connect_http_opt(\n    struct mg_mgr *mgr, MG_CB(mg_event_handler_t ev_handler, void *user_data),\n    struct mg_connect_opts opts, const char *url, const char *extra_headers,\n    const char *post_data) {\n  char *user = NULL, *pass = NULL, *addr = NULL;\n  const char *path = NULL;\n  struct mbuf auth;\n  struct mg_connection *nc =\n      mg_connect_http_base(mgr, MG_CB(ev_handler, user_data), opts, \"http://\",\n                           \"https://\", url, &path, &user, &pass, &addr);\n\n  if (nc == NULL) {\n    return NULL;\n  }\n\n  mbuf_init(&auth, 0);\n  if (user != NULL) {\n    mg_basic_auth_header(user, pass, &auth);\n  }\n\n  if (post_data == NULL) post_data = \"\";\n  if (extra_headers == NULL) extra_headers = \"\";\n\n  mg_printf(nc, \"%s %s HTTP/1.1\\r\\nHost: %s\\r\\nContent-Length: %\" SIZE_T_FMT\n                \"\\r\\n%.*s%s\\r\\n%s\",\n            post_data[0] == '\\0' ? \"GET\" : \"POST\", path, addr,\n            strlen(post_data), (int) auth.len,\n            (auth.buf == NULL ? \"\" : auth.buf), extra_headers, post_data);\n\n  mbuf_free(&auth);\n  MG_FREE(user);\n  MG_FREE(pass);\n  MG_FREE(addr);\n  return nc;\n}\n\nstruct mg_connection *mg_connect_http(\n    struct mg_mgr *mgr, MG_CB(mg_event_handler_t ev_handler, void *user_data),\n    const char *url, const char *extra_headers, const char *post_data) {\n  struct mg_connect_opts opts;\n  memset(&opts, 0, sizeof(opts));\n  return mg_connect_http_opt(mgr, MG_CB(ev_handler, user_data), opts, url,\n                             extra_headers, post_data);\n}\n\nsize_t mg_parse_multipart(const char *buf, size_t buf_len, char *var_name,\n                          size_t var_name_len, char *file_name,\n                          size_t file_name_len, const char **data,\n                          size_t *data_len) {\n  static const char cd[] = \"Content-Disposition: \";\n  size_t hl, bl, n, ll, pos, cdl = sizeof(cd) - 1;\n\n  if (buf == NULL || buf_len <= 0) return 0;\n  if ((hl = mg_http_get_request_len(buf, buf_len)) <= 0) return 0;\n  if (buf[0] != '-' || buf[1] != '-' || buf[2] == '\\n') return 0;\n\n  /* Get boundary length */\n  bl = mg_get_line_len(buf, buf_len);\n\n  /* Loop through headers, fetch variable name and file name */\n  var_name[0] = file_name[0] = '\\0';\n  for (n = bl; (ll = mg_get_line_len(buf + n, hl - n)) > 0; n += ll) {\n    if (mg_ncasecmp(cd, buf + n, cdl) == 0) {\n      struct mg_str header;\n      header.p = buf + n + cdl;\n      header.len = ll - (cdl + 2);\n      mg_http_parse_header(&header, \"name\", var_name, var_name_len);\n      mg_http_parse_header(&header, \"filename\", file_name, file_name_len);\n    }\n  }\n\n  /* Scan through the body, search for terminating boundary */\n  for (pos = hl; pos + (bl - 2) < buf_len; pos++) {\n    if (buf[pos] == '-' && !strncmp(buf, &buf[pos], bl - 2)) {\n      if (data_len != NULL) *data_len = (pos - 2) - hl;\n      if (data != NULL) *data = buf + hl;\n      return pos;\n    }\n  }\n\n  return 0;\n}\n\nvoid mg_register_http_endpoint(struct mg_connection *nc, const char *uri_path,\n                               MG_CB(mg_event_handler_t handler,\n                                     void *user_data)) {\n  struct mg_http_proto_data *pd = NULL;\n  struct mg_http_endpoint *new_ep = NULL;\n\n  if (nc == NULL) return;\n  new_ep = (struct mg_http_endpoint *) MG_CALLOC(1, sizeof(*new_ep));\n  if (new_ep == NULL) return;\n\n  pd = mg_http_get_proto_data(nc);\n  new_ep->name = strdup(uri_path);\n  new_ep->name_len = strlen(new_ep->name);\n  new_ep->handler = handler;\n#if MG_ENABLE_CALLBACK_USERDATA\n  new_ep->user_data = user_data;\n#endif\n  new_ep->next = pd->endpoints;\n  pd->endpoints = new_ep;\n}\n\n#endif /* MG_ENABLE_HTTP */\n#ifdef MG_MODULE_LINES\n#line 1 \"mongoose/src/http_cgi.c\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#if MG_ENABLE_HTTP && MG_ENABLE_HTTP_CGI\n\n#ifndef MG_MAX_CGI_ENVIR_VARS\n#define MG_MAX_CGI_ENVIR_VARS 64\n#endif\n\n#ifndef MG_ENV_EXPORT_TO_CGI\n#define MG_ENV_EXPORT_TO_CGI \"MONGOOSE_CGI\"\n#endif\n\n/*\n * This structure helps to create an environment for the spawned CGI program.\n * Environment is an array of \"VARIABLE=VALUE\\0\" ASCIIZ strings,\n * last element must be NULL.\n * However, on Windows there is a requirement that all these VARIABLE=VALUE\\0\n * strings must reside in a contiguous buffer. The end of the buffer is\n * marked by two '\\0' characters.\n * We satisfy both worlds: we create an envp array (which is vars), all\n * entries are actually pointers inside buf.\n */\nstruct mg_cgi_env_block {\n  struct mg_connection *nc;\n  char buf[MG_CGI_ENVIRONMENT_SIZE];       /* Environment buffer */\n  const char *vars[MG_MAX_CGI_ENVIR_VARS]; /* char *envp[] */\n  int len;                                 /* Space taken */\n  int nvars;                               /* Number of variables in envp[] */\n};\n\n#ifdef _WIN32\nstruct mg_threadparam {\n  sock_t s;\n  HANDLE hPipe;\n};\n\nstatic int mg_wait_until_ready(sock_t sock, int for_read) {\n  fd_set set;\n  FD_ZERO(&set);\n  FD_SET(sock, &set);\n  return select(sock + 1, for_read ? &set : 0, for_read ? 0 : &set, 0, 0) == 1;\n}\n\nstatic void *mg_push_to_stdin(void *arg) {\n  struct mg_threadparam *tp = (struct mg_threadparam *) arg;\n  int n, sent, stop = 0;\n  DWORD k;\n  char buf[BUFSIZ];\n\n  while (!stop && mg_wait_until_ready(tp->s, 1) &&\n         (n = recv(tp->s, buf, sizeof(buf), 0)) > 0) {\n    if (n == -1 && GetLastError() == WSAEWOULDBLOCK) continue;\n    for (sent = 0; !stop && sent < n; sent += k) {\n      if (!WriteFile(tp->hPipe, buf + sent, n - sent, &k, 0)) stop = 1;\n    }\n  }\n  DBG((\"%s\", \"FORWARED EVERYTHING TO CGI\"));\n  CloseHandle(tp->hPipe);\n  MG_FREE(tp);\n  return NULL;\n}\n\nstatic void *mg_pull_from_stdout(void *arg) {\n  struct mg_threadparam *tp = (struct mg_threadparam *) arg;\n  int k = 0, stop = 0;\n  DWORD n, sent;\n  char buf[BUFSIZ];\n\n  while (!stop && ReadFile(tp->hPipe, buf, sizeof(buf), &n, NULL)) {\n    for (sent = 0; !stop && sent < n; sent += k) {\n      if (mg_wait_until_ready(tp->s, 0) &&\n          (k = send(tp->s, buf + sent, n - sent, 0)) <= 0)\n        stop = 1;\n    }\n  }\n  DBG((\"%s\", \"EOF FROM CGI\"));\n  CloseHandle(tp->hPipe);\n  shutdown(tp->s, 2);  // Without this, IO thread may get truncated data\n  closesocket(tp->s);\n  MG_FREE(tp);\n  return NULL;\n}\n\nstatic void mg_spawn_stdio_thread(sock_t sock, HANDLE hPipe,\n                                  void *(*func)(void *)) {\n  struct mg_threadparam *tp = (struct mg_threadparam *) MG_MALLOC(sizeof(*tp));\n  if (tp != NULL) {\n    tp->s = sock;\n    tp->hPipe = hPipe;\n    mg_start_thread(func, tp);\n  }\n}\n\nstatic void mg_abs_path(const char *utf8_path, char *abs_path, size_t len) {\n  wchar_t buf[MAX_PATH_SIZE], buf2[MAX_PATH_SIZE];\n  to_wchar(utf8_path, buf, ARRAY_SIZE(buf));\n  GetFullPathNameW(buf, ARRAY_SIZE(buf2), buf2, NULL);\n  WideCharToMultiByte(CP_UTF8, 0, buf2, wcslen(buf2) + 1, abs_path, len, 0, 0);\n}\n\nstatic int mg_start_process(const char *interp, const char *cmd,\n                            const char *env, const char *envp[],\n                            const char *dir, sock_t sock) {\n  STARTUPINFOW si;\n  PROCESS_INFORMATION pi;\n  HANDLE a[2], b[2], me = GetCurrentProcess();\n  wchar_t wcmd[MAX_PATH_SIZE], full_dir[MAX_PATH_SIZE];\n  char buf[MAX_PATH_SIZE], buf2[MAX_PATH_SIZE], buf5[MAX_PATH_SIZE],\n      buf4[MAX_PATH_SIZE], cmdline[MAX_PATH_SIZE];\n  DWORD flags = DUPLICATE_CLOSE_SOURCE | DUPLICATE_SAME_ACCESS;\n  FILE *fp;\n\n  memset(&si, 0, sizeof(si));\n  memset(&pi, 0, sizeof(pi));\n\n  si.cb = sizeof(si);\n  si.dwFlags = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;\n  si.wShowWindow = SW_HIDE;\n  si.hStdError = GetStdHandle(STD_ERROR_HANDLE);\n\n  CreatePipe(&a[0], &a[1], NULL, 0);\n  CreatePipe(&b[0], &b[1], NULL, 0);\n  DuplicateHandle(me, a[0], me, &si.hStdInput, 0, TRUE, flags);\n  DuplicateHandle(me, b[1], me, &si.hStdOutput, 0, TRUE, flags);\n\n  if (interp == NULL && (fp = mg_fopen(cmd, \"r\")) != NULL) {\n    buf[0] = buf[1] = '\\0';\n    fgets(buf, sizeof(buf), fp);\n    buf[sizeof(buf) - 1] = '\\0';\n    if (buf[0] == '#' && buf[1] == '!') {\n      interp = buf + 2;\n      /* Trim leading spaces: https://github.com/cesanta/mongoose/issues/489 */\n      while (*interp != '\\0' && isspace(*(unsigned char *) interp)) {\n        interp++;\n      }\n    }\n    fclose(fp);\n  }\n\n  snprintf(buf, sizeof(buf), \"%s/%s\", dir, cmd);\n  mg_abs_path(buf, buf2, ARRAY_SIZE(buf2));\n\n  mg_abs_path(dir, buf5, ARRAY_SIZE(buf5));\n  to_wchar(dir, full_dir, ARRAY_SIZE(full_dir));\n\n  if (interp != NULL) {\n    mg_abs_path(interp, buf4, ARRAY_SIZE(buf4));\n    snprintf(cmdline, sizeof(cmdline), \"%s \\\"%s\\\"\", buf4, buf2);\n  } else {\n    snprintf(cmdline, sizeof(cmdline), \"\\\"%s\\\"\", buf2);\n  }\n  to_wchar(cmdline, wcmd, ARRAY_SIZE(wcmd));\n\n  if (CreateProcessW(NULL, wcmd, NULL, NULL, TRUE, CREATE_NEW_PROCESS_GROUP,\n                     (void *) env, full_dir, &si, &pi) != 0) {\n    mg_spawn_stdio_thread(sock, a[1], mg_push_to_stdin);\n    mg_spawn_stdio_thread(sock, b[0], mg_pull_from_stdout);\n\n    CloseHandle(si.hStdOutput);\n    CloseHandle(si.hStdInput);\n\n    CloseHandle(pi.hThread);\n    CloseHandle(pi.hProcess);\n  } else {\n    CloseHandle(a[1]);\n    CloseHandle(b[0]);\n    closesocket(sock);\n  }\n  DBG((\"CGI command: [%ls] -> %p\", wcmd, pi.hProcess));\n\n  /* Not closing a[0] and b[1] because we've used DUPLICATE_CLOSE_SOURCE */\n  (void) envp;\n  return (pi.hProcess != NULL);\n}\n#else\nstatic int mg_start_process(const char *interp, const char *cmd,\n                            const char *env, const char *envp[],\n                            const char *dir, sock_t sock) {\n  char buf[500];\n  pid_t pid = fork();\n  (void) env;\n\n  if (pid == 0) {\n    /*\n     * In Linux `chdir` declared with `warn_unused_result` attribute\n     * To shutup compiler we have yo use result in some way\n     */\n    int tmp = chdir(dir);\n    (void) tmp;\n    (void) dup2(sock, 0);\n    (void) dup2(sock, 1);\n    closesocket(sock);\n\n    /*\n     * After exec, all signal handlers are restored to their default values,\n     * with one exception of SIGCHLD. According to POSIX.1-2001 and Linux's\n     * implementation, SIGCHLD's handler will leave unchanged after exec\n     * if it was set to be ignored. Restore it to default action.\n     */\n    signal(SIGCHLD, SIG_DFL);\n\n    if (interp == NULL) {\n      execle(cmd, cmd, (char *) 0, envp); /* (char *) 0 to squash warning */\n    } else {\n      execle(interp, interp, cmd, (char *) 0, envp);\n    }\n    snprintf(buf, sizeof(buf),\n             \"Status: 500\\r\\n\\r\\n\"\n             \"500 Server Error: %s%s%s: %s\",\n             interp == NULL ? \"\" : interp, interp == NULL ? \"\" : \" \", cmd,\n             strerror(errno));\n    send(1, buf, strlen(buf), 0);\n    _exit(EXIT_FAILURE); /* exec call failed */\n  }\n\n  return (pid != 0);\n}\n#endif /* _WIN32 */\n\n/*\n * Append VARIABLE=VALUE\\0 string to the buffer, and add a respective\n * pointer into the vars array.\n */\nstatic char *mg_addenv(struct mg_cgi_env_block *block, const char *fmt, ...) {\n  int n, space;\n  char *added = block->buf + block->len;\n  va_list ap;\n\n  /* Calculate how much space is left in the buffer */\n  space = sizeof(block->buf) - (block->len + 2);\n  if (space > 0) {\n    /* Copy VARIABLE=VALUE\\0 string into the free space */\n    va_start(ap, fmt);\n    n = vsnprintf(added, (size_t) space, fmt, ap);\n    va_end(ap);\n\n    /* Make sure we do not overflow buffer and the envp array */\n    if (n > 0 && n + 1 < space &&\n        block->nvars < (int) ARRAY_SIZE(block->vars) - 2) {\n      /* Append a pointer to the added string into the envp array */\n      block->vars[block->nvars++] = added;\n      /* Bump up used length counter. Include \\0 terminator */\n      block->len += n + 1;\n    }\n  }\n\n  return added;\n}\n\nstatic void mg_addenv2(struct mg_cgi_env_block *blk, const char *name) {\n  const char *s;\n  if ((s = getenv(name)) != NULL) mg_addenv(blk, \"%s=%s\", name, s);\n}\n\nstatic void mg_prepare_cgi_environment(struct mg_connection *nc,\n                                       const char *prog,\n                                       const struct mg_str *path_info,\n                                       const struct http_message *hm,\n                                       const struct mg_serve_http_opts *opts,\n                                       struct mg_cgi_env_block *blk) {\n  const char *s;\n  struct mg_str *h;\n  char *p;\n  size_t i;\n  char buf[100];\n\n  blk->len = blk->nvars = 0;\n  blk->nc = nc;\n\n  if ((s = getenv(\"SERVER_NAME\")) != NULL) {\n    mg_addenv(blk, \"SERVER_NAME=%s\", s);\n  } else {\n    mg_sock_to_str(nc->sock, buf, sizeof(buf), 3);\n    mg_addenv(blk, \"SERVER_NAME=%s\", buf);\n  }\n  mg_addenv(blk, \"SERVER_ROOT=%s\", opts->document_root);\n  mg_addenv(blk, \"DOCUMENT_ROOT=%s\", opts->document_root);\n  mg_addenv(blk, \"SERVER_SOFTWARE=%s/%s\", \"Mongoose\", MG_VERSION);\n\n  /* Prepare the environment block */\n  mg_addenv(blk, \"%s\", \"GATEWAY_INTERFACE=CGI/1.1\");\n  mg_addenv(blk, \"%s\", \"SERVER_PROTOCOL=HTTP/1.1\");\n  mg_addenv(blk, \"%s\", \"REDIRECT_STATUS=200\"); /* For PHP */\n\n  mg_addenv(blk, \"REQUEST_METHOD=%.*s\", (int) hm->method.len, hm->method.p);\n\n  mg_addenv(blk, \"REQUEST_URI=%.*s%s%.*s\", (int) hm->uri.len, hm->uri.p,\n            hm->query_string.len == 0 ? \"\" : \"?\", (int) hm->query_string.len,\n            hm->query_string.p);\n\n  mg_conn_addr_to_str(nc, buf, sizeof(buf),\n                      MG_SOCK_STRINGIFY_REMOTE | MG_SOCK_STRINGIFY_IP);\n  mg_addenv(blk, \"REMOTE_ADDR=%s\", buf);\n  mg_conn_addr_to_str(nc, buf, sizeof(buf), MG_SOCK_STRINGIFY_PORT);\n  mg_addenv(blk, \"SERVER_PORT=%s\", buf);\n\n  s = hm->uri.p + hm->uri.len - path_info->len - 1;\n  if (*s == '/') {\n    const char *base_name = strrchr(prog, DIRSEP);\n    mg_addenv(blk, \"SCRIPT_NAME=%.*s/%s\", (int) (s - hm->uri.p), hm->uri.p,\n              (base_name != NULL ? base_name + 1 : prog));\n  } else {\n    mg_addenv(blk, \"SCRIPT_NAME=%.*s\", (int) (s - hm->uri.p + 1), hm->uri.p);\n  }\n  mg_addenv(blk, \"SCRIPT_FILENAME=%s\", prog);\n\n  if (path_info != NULL && path_info->len > 0) {\n    mg_addenv(blk, \"PATH_INFO=%.*s\", (int) path_info->len, path_info->p);\n    /* Not really translated... */\n    mg_addenv(blk, \"PATH_TRANSLATED=%.*s\", (int) path_info->len, path_info->p);\n  }\n\n#if MG_ENABLE_SSL\n  mg_addenv(blk, \"HTTPS=%s\", (nc->flags & MG_F_SSL ? \"on\" : \"off\"));\n#else\n  mg_addenv(blk, \"HTTPS=off\");\n#endif\n\n  if ((h = mg_get_http_header((struct http_message *) hm, \"Content-Type\")) !=\n      NULL) {\n    mg_addenv(blk, \"CONTENT_TYPE=%.*s\", (int) h->len, h->p);\n  }\n\n  if (hm->query_string.len > 0) {\n    mg_addenv(blk, \"QUERY_STRING=%.*s\", (int) hm->query_string.len,\n              hm->query_string.p);\n  }\n\n  if ((h = mg_get_http_header((struct http_message *) hm, \"Content-Length\")) !=\n      NULL) {\n    mg_addenv(blk, \"CONTENT_LENGTH=%.*s\", (int) h->len, h->p);\n  }\n\n  mg_addenv2(blk, \"PATH\");\n  mg_addenv2(blk, \"TMP\");\n  mg_addenv2(blk, \"TEMP\");\n  mg_addenv2(blk, \"TMPDIR\");\n  mg_addenv2(blk, \"PERLLIB\");\n  mg_addenv2(blk, MG_ENV_EXPORT_TO_CGI);\n\n#ifdef _WIN32\n  mg_addenv2(blk, \"COMSPEC\");\n  mg_addenv2(blk, \"SYSTEMROOT\");\n  mg_addenv2(blk, \"SystemDrive\");\n  mg_addenv2(blk, \"ProgramFiles\");\n  mg_addenv2(blk, \"ProgramFiles(x86)\");\n  mg_addenv2(blk, \"CommonProgramFiles(x86)\");\n#else\n  mg_addenv2(blk, \"LD_LIBRARY_PATH\");\n#endif /* _WIN32 */\n\n  /* Add all headers as HTTP_* variables */\n  for (i = 0; hm->header_names[i].len > 0; i++) {\n    p = mg_addenv(blk, \"HTTP_%.*s=%.*s\", (int) hm->header_names[i].len,\n                  hm->header_names[i].p, (int) hm->header_values[i].len,\n                  hm->header_values[i].p);\n\n    /* Convert variable name into uppercase, and change - to _ */\n    for (; *p != '=' && *p != '\\0'; p++) {\n      if (*p == '-') *p = '_';\n      *p = (char) toupper(*(unsigned char *) p);\n    }\n  }\n\n  blk->vars[blk->nvars++] = NULL;\n  blk->buf[blk->len++] = '\\0';\n}\n\nstatic void mg_cgi_ev_handler(struct mg_connection *cgi_nc, int ev,\n                              void *ev_data MG_UD_ARG(void *user_data)) {\n#if !MG_ENABLE_CALLBACK_USERDATA\n  void *user_data = cgi_nc->user_data;\n#endif\n  struct mg_connection *nc = (struct mg_connection *) user_data;\n  (void) ev_data;\n\n  if (nc == NULL) {\n    cgi_nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n    return;\n  }\n\n  switch (ev) {\n    case MG_EV_RECV:\n      /*\n       * CGI script does not output reply line, like \"HTTP/1.1 CODE XXXXX\\n\"\n       * It outputs headers, then body. Headers might include \"Status\"\n       * header, which changes CODE, and it might include \"Location\" header\n       * which changes CODE to 302.\n       *\n       * Therefore we do not send the output from the CGI script to the user\n       * until all CGI headers are received.\n       *\n       * Here we parse the output from the CGI script, and if all headers has\n       * been received, send appropriate reply line, and forward all\n       * received headers to the client.\n       */\n      if (nc->flags & MG_F_USER_1) {\n        struct mbuf *io = &cgi_nc->recv_mbuf;\n        int len = mg_http_get_request_len(io->buf, io->len);\n\n        if (len == 0) break;\n        if (len < 0 || io->len > MG_MAX_HTTP_REQUEST_SIZE) {\n          cgi_nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n          mg_http_send_error(nc, 500, \"Bad headers\");\n        } else {\n          struct http_message hm;\n          struct mg_str *h;\n          mg_http_parse_headers(io->buf, io->buf + io->len, io->len, &hm);\n          if (mg_get_http_header(&hm, \"Location\") != NULL) {\n            mg_printf(nc, \"%s\", \"HTTP/1.1 302 Moved\\r\\n\");\n          } else if ((h = mg_get_http_header(&hm, \"Status\")) != NULL) {\n            mg_printf(nc, \"HTTP/1.1 %.*s\\r\\n\", (int) h->len, h->p);\n          } else {\n            mg_printf(nc, \"%s\", \"HTTP/1.1 200 OK\\r\\n\");\n          }\n        }\n        nc->flags &= ~MG_F_USER_1;\n      }\n      if (!(nc->flags & MG_F_USER_1)) {\n        mg_forward(cgi_nc, nc);\n      }\n      break;\n    case MG_EV_CLOSE:\n      mg_http_free_proto_data_cgi(&mg_http_get_proto_data(nc)->cgi);\n      nc->flags |= MG_F_SEND_AND_CLOSE;\n      break;\n  }\n}\n\nMG_INTERNAL void mg_handle_cgi(struct mg_connection *nc, const char *prog,\n                               const struct mg_str *path_info,\n                               const struct http_message *hm,\n                               const struct mg_serve_http_opts *opts) {\n  struct mg_cgi_env_block blk;\n  char dir[MAX_PATH_SIZE];\n  const char *p;\n  sock_t fds[2];\n\n  DBG((\"%p [%s]\", nc, prog));\n  mg_prepare_cgi_environment(nc, prog, path_info, hm, opts, &blk);\n  /*\n   * CGI must be executed in its own directory. 'dir' must point to the\n   * directory containing executable program, 'p' must point to the\n   * executable program name relative to 'dir'.\n   */\n  if ((p = strrchr(prog, DIRSEP)) == NULL) {\n    snprintf(dir, sizeof(dir), \"%s\", \".\");\n  } else {\n    snprintf(dir, sizeof(dir), \"%.*s\", (int) (p - prog), prog);\n    prog = p + 1;\n  }\n\n  /*\n   * Try to create socketpair in a loop until success. mg_socketpair()\n   * can be interrupted by a signal and fail.\n   * TODO(lsm): use sigaction to restart interrupted syscall\n   */\n  do {\n    mg_socketpair(fds, SOCK_STREAM);\n  } while (fds[0] == INVALID_SOCKET);\n\n  if (mg_start_process(opts->cgi_interpreter, prog, blk.buf, blk.vars, dir,\n                       fds[1]) != 0) {\n    size_t n = nc->recv_mbuf.len - (hm->message.len - hm->body.len);\n    struct mg_connection *cgi_nc =\n        mg_add_sock(nc->mgr, fds[0], mg_cgi_ev_handler MG_UD_ARG(nc));\n    struct mg_http_proto_data *cgi_pd = mg_http_get_proto_data(nc);\n    cgi_pd->cgi.cgi_nc = cgi_nc;\n#if !MG_ENABLE_CALLBACK_USERDATA\n    cgi_pd->cgi.cgi_nc->user_data = nc;\n#endif\n    nc->flags |= MG_F_USER_1;\n    /* Push POST data to the CGI */\n    if (n > 0 && n < nc->recv_mbuf.len) {\n      mg_send(cgi_pd->cgi.cgi_nc, hm->body.p, n);\n    }\n    mbuf_remove(&nc->recv_mbuf, nc->recv_mbuf.len);\n  } else {\n    closesocket(fds[0]);\n    mg_http_send_error(nc, 500, \"CGI failure\");\n  }\n\n#ifndef _WIN32\n  closesocket(fds[1]); /* On Windows, CGI stdio thread closes that socket */\n#endif\n}\n\nMG_INTERNAL void mg_http_free_proto_data_cgi(struct mg_http_proto_data_cgi *d) {\n  if (d != NULL) {\n    if (d->cgi_nc != NULL) d->cgi_nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n    memset(d, 0, sizeof(struct mg_http_proto_data_cgi));\n  }\n}\n\n#endif /* MG_ENABLE_HTTP && MG_ENABLE_HTTP_CGI */\n#ifdef MG_MODULE_LINES\n#line 1 \"mongoose/src/http_ssi.c\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#if MG_ENABLE_HTTP && MG_ENABLE_HTTP_SSI && MG_ENABLE_FILESYSTEM\n\nstatic void mg_send_ssi_file(struct mg_connection *nc, struct http_message *hm,\n                             const char *path, FILE *fp, int include_level,\n                             const struct mg_serve_http_opts *opts);\n\nstatic void mg_send_file_data(struct mg_connection *nc, FILE *fp) {\n  char buf[BUFSIZ];\n  size_t n;\n  while ((n = mg_fread(buf, 1, sizeof(buf), fp)) > 0) {\n    mg_send(nc, buf, n);\n  }\n}\n\nstatic void mg_do_ssi_include(struct mg_connection *nc, struct http_message *hm,\n                              const char *ssi, char *tag, int include_level,\n                              const struct mg_serve_http_opts *opts) {\n  char file_name[BUFSIZ], path[MAX_PATH_SIZE], *p;\n  FILE *fp;\n\n  /*\n   * sscanf() is safe here, since send_ssi_file() also uses buffer\n   * of size MG_BUF_LEN to get the tag. So strlen(tag) is always < MG_BUF_LEN.\n   */\n  if (sscanf(tag, \" virtual=\\\"%[^\\\"]\\\"\", file_name) == 1) {\n    /* File name is relative to the webserver root */\n    snprintf(path, sizeof(path), \"%s/%s\", opts->document_root, file_name);\n  } else if (sscanf(tag, \" abspath=\\\"%[^\\\"]\\\"\", file_name) == 1) {\n    /*\n     * File name is relative to the webserver working directory\n     * or it is absolute system path\n     */\n    snprintf(path, sizeof(path), \"%s\", file_name);\n  } else if (sscanf(tag, \" file=\\\"%[^\\\"]\\\"\", file_name) == 1 ||\n             sscanf(tag, \" \\\"%[^\\\"]\\\"\", file_name) == 1) {\n    /* File name is relative to the currect document */\n    snprintf(path, sizeof(path), \"%s\", ssi);\n    if ((p = strrchr(path, DIRSEP)) != NULL) {\n      p[1] = '\\0';\n    }\n    snprintf(path + strlen(path), sizeof(path) - strlen(path), \"%s\", file_name);\n  } else {\n    mg_printf(nc, \"Bad SSI #include: [%s]\", tag);\n    return;\n  }\n\n  if ((fp = mg_fopen(path, \"rb\")) == NULL) {\n    mg_printf(nc, \"SSI include error: mg_fopen(%s): %s\", path,\n              strerror(mg_get_errno()));\n  } else {\n    mg_set_close_on_exec((sock_t) fileno(fp));\n    if (mg_match_prefix(opts->ssi_pattern, strlen(opts->ssi_pattern), path) >\n        0) {\n      mg_send_ssi_file(nc, hm, path, fp, include_level + 1, opts);\n    } else {\n      mg_send_file_data(nc, fp);\n    }\n    fclose(fp);\n  }\n}\n\n#if MG_ENABLE_HTTP_SSI_EXEC\nstatic void do_ssi_exec(struct mg_connection *nc, char *tag) {\n  char cmd[BUFSIZ];\n  FILE *fp;\n\n  if (sscanf(tag, \" \\\"%[^\\\"]\\\"\", cmd) != 1) {\n    mg_printf(nc, \"Bad SSI #exec: [%s]\", tag);\n  } else if ((fp = popen(cmd, \"r\")) == NULL) {\n    mg_printf(nc, \"Cannot SSI #exec: [%s]: %s\", cmd, strerror(mg_get_errno()));\n  } else {\n    mg_send_file_data(nc, fp);\n    pclose(fp);\n  }\n}\n#endif /* MG_ENABLE_HTTP_SSI_EXEC */\n\n/*\n * SSI directive has the following format:\n * <!--#directive parameter=value parameter=value -->\n */\nstatic void mg_send_ssi_file(struct mg_connection *nc, struct http_message *hm,\n                             const char *path, FILE *fp, int include_level,\n                             const struct mg_serve_http_opts *opts) {\n  static const struct mg_str btag = MG_MK_STR(\"<!--#\");\n  static const struct mg_str d_include = MG_MK_STR(\"include\");\n  static const struct mg_str d_call = MG_MK_STR(\"call\");\n#if MG_ENABLE_HTTP_SSI_EXEC\n  static const struct mg_str d_exec = MG_MK_STR(\"exec\");\n#endif\n  char buf[BUFSIZ], *p = buf + btag.len; /* p points to SSI directive */\n  int ch, len, in_ssi_tag;\n\n  if (include_level > 10) {\n    mg_printf(nc, \"SSI #include level is too deep (%s)\", path);\n    return;\n  }\n\n  in_ssi_tag = len = 0;\n  while ((ch = fgetc(fp)) != EOF) {\n    if (in_ssi_tag && ch == '>' && buf[len - 1] == '-' && buf[len - 2] == '-') {\n      size_t i = len - 2;\n      in_ssi_tag = 0;\n\n      /* Trim closing --> */\n      buf[i--] = '\\0';\n      while (i > 0 && buf[i] == ' ') {\n        buf[i--] = '\\0';\n      }\n\n      /* Handle known SSI directives */\n      if (strncmp(p, d_include.p, d_include.len) == 0) {\n        mg_do_ssi_include(nc, hm, path, p + d_include.len + 1, include_level,\n                          opts);\n      } else if (strncmp(p, d_call.p, d_call.len) == 0) {\n        struct mg_ssi_call_ctx cctx;\n        memset(&cctx, 0, sizeof(cctx));\n        cctx.req = hm;\n        cctx.file = mg_mk_str(path);\n        cctx.arg = mg_mk_str(p + d_call.len + 1);\n        mg_call(nc, NULL, nc->user_data, MG_EV_SSI_CALL,\n                (void *) cctx.arg.p); /* NUL added above */\n        mg_call(nc, NULL, nc->user_data, MG_EV_SSI_CALL_CTX, &cctx);\n#if MG_ENABLE_HTTP_SSI_EXEC\n      } else if (strncmp(p, d_exec.p, d_exec.len) == 0) {\n        do_ssi_exec(nc, p + d_exec.len + 1);\n#endif\n      } else {\n        /* Silently ignore unknown SSI directive. */\n      }\n      len = 0;\n    } else if (ch == '<') {\n      in_ssi_tag = 1;\n      if (len > 0) {\n        mg_send(nc, buf, (size_t) len);\n      }\n      len = 0;\n      buf[len++] = ch & 0xff;\n    } else if (in_ssi_tag) {\n      if (len == (int) btag.len && strncmp(buf, btag.p, btag.len) != 0) {\n        /* Not an SSI tag */\n        in_ssi_tag = 0;\n      } else if (len == (int) sizeof(buf) - 2) {\n        mg_printf(nc, \"%s: SSI tag is too large\", path);\n        len = 0;\n      }\n      buf[len++] = ch & 0xff;\n    } else {\n      buf[len++] = ch & 0xff;\n      if (len == (int) sizeof(buf)) {\n        mg_send(nc, buf, (size_t) len);\n        len = 0;\n      }\n    }\n  }\n\n  /* Send the rest of buffered data */\n  if (len > 0) {\n    mg_send(nc, buf, (size_t) len);\n  }\n}\n\nMG_INTERNAL void mg_handle_ssi_request(struct mg_connection *nc,\n                                       struct http_message *hm,\n                                       const char *path,\n                                       const struct mg_serve_http_opts *opts) {\n  FILE *fp;\n  struct mg_str mime_type;\n  DBG((\"%p %s\", nc, path));\n\n  if ((fp = mg_fopen(path, \"rb\")) == NULL) {\n    mg_http_send_error(nc, 404, NULL);\n  } else {\n    mg_set_close_on_exec((sock_t) fileno(fp));\n\n    mime_type = mg_get_mime_type(path, \"text/plain\", opts);\n    mg_send_response_line(nc, 200, opts->extra_headers);\n    mg_printf(nc,\n              \"Content-Type: %.*s\\r\\n\"\n              \"Connection: close\\r\\n\\r\\n\",\n              (int) mime_type.len, mime_type.p);\n    mg_send_ssi_file(nc, hm, path, fp, 0, opts);\n    fclose(fp);\n    nc->flags |= MG_F_SEND_AND_CLOSE;\n  }\n}\n\n#endif /* MG_ENABLE_HTTP_SSI && MG_ENABLE_HTTP && MG_ENABLE_FILESYSTEM */\n#ifdef MG_MODULE_LINES\n#line 1 \"mongoose/src/http_webdav.c\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#if MG_ENABLE_HTTP && MG_ENABLE_HTTP_WEBDAV\n\nMG_INTERNAL int mg_is_dav_request(const struct mg_str *s) {\n  static const char *methods[] = {\n    \"PUT\",\n    \"DELETE\",\n    \"MKCOL\",\n    \"PROPFIND\",\n    \"MOVE\"\n#if MG_ENABLE_FAKE_DAVLOCK\n    ,\n    \"LOCK\",\n    \"UNLOCK\"\n#endif\n  };\n  size_t i;\n\n  for (i = 0; i < ARRAY_SIZE(methods); i++) {\n    if (mg_vcmp(s, methods[i]) == 0) {\n      return 1;\n    }\n  }\n\n  return 0;\n}\n\nstatic int mg_mkdir(const char *path, uint32_t mode) {\n#ifndef _WIN32\n  return mkdir(path, mode);\n#else\n  (void) mode;\n  return _mkdir(path);\n#endif\n}\n\nstatic void mg_print_props(struct mg_connection *nc, const char *name,\n                           cs_stat_t *stp) {\n  char mtime[64], buf[MAX_PATH_SIZE * 3];\n  time_t t = stp->st_mtime; /* store in local variable for NDK compile */\n  mg_gmt_time_string(mtime, sizeof(mtime), &t);\n  mg_url_encode(name, strlen(name), buf, sizeof(buf));\n  mg_printf(nc,\n            \"<d:response>\"\n            \"<d:href>%s</d:href>\"\n            \"<d:propstat>\"\n            \"<d:prop>\"\n            \"<d:resourcetype>%s</d:resourcetype>\"\n            \"<d:getcontentlength>%\" INT64_FMT\n            \"</d:getcontentlength>\"\n            \"<d:getlastmodified>%s</d:getlastmodified>\"\n            \"</d:prop>\"\n            \"<d:status>HTTP/1.1 200 OK</d:status>\"\n            \"</d:propstat>\"\n            \"</d:response>\\n\",\n            buf, S_ISDIR(stp->st_mode) ? \"<d:collection/>\" : \"\",\n            (int64_t) stp->st_size, mtime);\n}\n\nMG_INTERNAL void mg_handle_propfind(struct mg_connection *nc, const char *path,\n                                    cs_stat_t *stp, struct http_message *hm,\n                                    struct mg_serve_http_opts *opts) {\n  static const char header[] =\n      \"HTTP/1.1 207 Multi-Status\\r\\n\"\n      \"Connection: close\\r\\n\"\n      \"Content-Type: text/xml; charset=utf-8\\r\\n\\r\\n\"\n      \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\"\n      \"<d:multistatus xmlns:d='DAV:'>\\n\";\n  static const char footer[] = \"</d:multistatus>\\n\";\n  const struct mg_str *depth = mg_get_http_header(hm, \"Depth\");\n\n  /* Print properties for the requested resource itself */\n  if (S_ISDIR(stp->st_mode) &&\n      strcmp(opts->enable_directory_listing, \"yes\") != 0) {\n    mg_printf(nc, \"%s\", \"HTTP/1.1 403 Directory Listing Denied\\r\\n\\r\\n\");\n  } else {\n    char uri[MAX_PATH_SIZE];\n    mg_send(nc, header, sizeof(header) - 1);\n    snprintf(uri, sizeof(uri), \"%.*s\", (int) hm->uri.len, hm->uri.p);\n    mg_print_props(nc, uri, stp);\n    if (S_ISDIR(stp->st_mode) && (depth == NULL || mg_vcmp(depth, \"0\") != 0)) {\n      mg_scan_directory(nc, path, opts, mg_print_props);\n    }\n    mg_send(nc, footer, sizeof(footer) - 1);\n    nc->flags |= MG_F_SEND_AND_CLOSE;\n  }\n}\n\n#if MG_ENABLE_FAKE_DAVLOCK\n/*\n * Windows explorer (probably there are another WebDav clients like it)\n * requires LOCK support in webdav. W/out this, it still works, but fails\n * to save file: shows error message and offers \"Save As\".\n * \"Save as\" works, but this message is very annoying.\n * This is fake lock, which doesn't lock something, just returns LOCK token,\n * UNLOCK always answers \"OK\".\n * With this fake LOCK Windows Explorer looks happy and saves file.\n * NOTE: that is not DAV LOCK imlementation, it is just a way to shut up\n * Windows native DAV client. This is why FAKE LOCK is not enabed by default\n */\nMG_INTERNAL void mg_handle_lock(struct mg_connection *nc, const char *path) {\n  static const char *reply =\n      \"HTTP/1.1 207 Multi-Status\\r\\n\"\n      \"Connection: close\\r\\n\"\n      \"Content-Type: text/xml; charset=utf-8\\r\\n\\r\\n\"\n      \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\"\n      \"<d:multistatus xmlns:d='DAV:'>\\n\"\n      \"<D:lockdiscovery>\\n\"\n      \"<D:activelock>\\n\"\n      \"<D:locktoken>\\n\"\n      \"<D:href>\\n\"\n      \"opaquelocktoken:%s%u\"\n      \"</D:href>\"\n      \"</D:locktoken>\"\n      \"</D:activelock>\\n\"\n      \"</D:lockdiscovery>\"\n      \"</d:multistatus>\\n\";\n  mg_printf(nc, reply, path, (unsigned int) mg_time());\n  nc->flags |= MG_F_SEND_AND_CLOSE;\n}\n#endif\n\nMG_INTERNAL void mg_handle_mkcol(struct mg_connection *nc, const char *path,\n                                 struct http_message *hm) {\n  int status_code = 500;\n  if (hm->body.len != (size_t) ~0 && hm->body.len > 0) {\n    status_code = 415;\n  } else if (!mg_mkdir(path, 0755)) {\n    status_code = 201;\n  } else if (errno == EEXIST) {\n    status_code = 405;\n  } else if (errno == EACCES) {\n    status_code = 403;\n  } else if (errno == ENOENT) {\n    status_code = 409;\n  } else {\n    status_code = 500;\n  }\n  mg_http_send_error(nc, status_code, NULL);\n}\n\nstatic int mg_remove_directory(const struct mg_serve_http_opts *opts,\n                               const char *dir) {\n  char path[MAX_PATH_SIZE];\n  struct dirent *dp;\n  cs_stat_t st;\n  DIR *dirp;\n\n  if ((dirp = opendir(dir)) == NULL) return 0;\n\n  while ((dp = readdir(dirp)) != NULL) {\n    if (mg_is_file_hidden((const char *) dp->d_name, opts, 1)) {\n      continue;\n    }\n    snprintf(path, sizeof(path), \"%s%c%s\", dir, '/', dp->d_name);\n    mg_stat(path, &st);\n    if (S_ISDIR(st.st_mode)) {\n      mg_remove_directory(opts, path);\n    } else {\n      remove(path);\n    }\n  }\n  closedir(dirp);\n  rmdir(dir);\n\n  return 1;\n}\n\nMG_INTERNAL void mg_handle_move(struct mg_connection *c,\n                                const struct mg_serve_http_opts *opts,\n                                const char *path, struct http_message *hm) {\n  const struct mg_str *dest = mg_get_http_header(hm, \"Destination\");\n  if (dest == NULL) {\n    mg_http_send_error(c, 411, NULL);\n  } else {\n    const char *p = (char *) memchr(dest->p, '/', dest->len);\n    if (p != NULL && p[1] == '/' &&\n        (p = (char *) memchr(p + 2, '/', dest->p + dest->len - p)) != NULL) {\n      char buf[MAX_PATH_SIZE];\n      snprintf(buf, sizeof(buf), \"%s%.*s\", opts->dav_document_root,\n               (int) (dest->p + dest->len - p), p);\n      if (rename(path, buf) == 0) {\n        mg_http_send_error(c, 200, NULL);\n      } else {\n        mg_http_send_error(c, 418, NULL);\n      }\n    } else {\n      mg_http_send_error(c, 500, NULL);\n    }\n  }\n}\n\nMG_INTERNAL void mg_handle_delete(struct mg_connection *nc,\n                                  const struct mg_serve_http_opts *opts,\n                                  const char *path) {\n  cs_stat_t st;\n  if (mg_stat(path, &st) != 0) {\n    mg_http_send_error(nc, 404, NULL);\n  } else if (S_ISDIR(st.st_mode)) {\n    mg_remove_directory(opts, path);\n    mg_http_send_error(nc, 204, NULL);\n  } else if (remove(path) == 0) {\n    mg_http_send_error(nc, 204, NULL);\n  } else {\n    mg_http_send_error(nc, 423, NULL);\n  }\n}\n\n/* Return -1 on error, 1 on success. */\nstatic int mg_create_itermediate_directories(const char *path) {\n  const char *s;\n\n  /* Create intermediate directories if they do not exist */\n  for (s = path + 1; *s != '\\0'; s++) {\n    if (*s == '/') {\n      char buf[MAX_PATH_SIZE];\n      cs_stat_t st;\n      snprintf(buf, sizeof(buf), \"%.*s\", (int) (s - path), path);\n      buf[sizeof(buf) - 1] = '\\0';\n      if (mg_stat(buf, &st) != 0 && mg_mkdir(buf, 0755) != 0) {\n        return -1;\n      }\n    }\n  }\n\n  return 1;\n}\n\nMG_INTERNAL void mg_handle_put(struct mg_connection *nc, const char *path,\n                               struct http_message *hm) {\n  struct mg_http_proto_data *pd = mg_http_get_proto_data(nc);\n  cs_stat_t st;\n  const struct mg_str *cl_hdr = mg_get_http_header(hm, \"Content-Length\");\n  int rc, status_code = mg_stat(path, &st) == 0 ? 200 : 201;\n\n  mg_http_free_proto_data_file(&pd->file);\n  if ((rc = mg_create_itermediate_directories(path)) == 0) {\n    mg_printf(nc, \"HTTP/1.1 %d OK\\r\\nContent-Length: 0\\r\\n\\r\\n\", status_code);\n  } else if (rc == -1) {\n    mg_http_send_error(nc, 500, NULL);\n  } else if (cl_hdr == NULL) {\n    mg_http_send_error(nc, 411, NULL);\n  } else if ((pd->file.fp = mg_fopen(path, \"w+b\")) == NULL) {\n    mg_http_send_error(nc, 500, NULL);\n  } else {\n    const struct mg_str *range_hdr = mg_get_http_header(hm, \"Content-Range\");\n    int64_t r1 = 0, r2 = 0;\n    pd->file.type = DATA_PUT;\n    mg_set_close_on_exec((sock_t) fileno(pd->file.fp));\n    pd->file.cl = to64(cl_hdr->p);\n    if (range_hdr != NULL &&\n        mg_http_parse_range_header(range_hdr, &r1, &r2) > 0) {\n      status_code = 206;\n      fseeko(pd->file.fp, r1, SEEK_SET);\n      pd->file.cl = r2 > r1 ? r2 - r1 + 1 : pd->file.cl - r1;\n    }\n    mg_printf(nc, \"HTTP/1.1 %d OK\\r\\nContent-Length: 0\\r\\n\\r\\n\", status_code);\n    /* Remove HTTP request from the mbuf, leave only payload */\n    mbuf_remove(&nc->recv_mbuf, hm->message.len - hm->body.len);\n    mg_http_transfer_file_data(nc);\n  }\n}\n\n#endif /* MG_ENABLE_HTTP && MG_ENABLE_HTTP_WEBDAV */\n#ifdef MG_MODULE_LINES\n#line 1 \"mongoose/src/http_websocket.c\"\n#endif\n/*\n * Copyright (c) 2014 Cesanta Software Limited\n * All rights reserved\n */\n\n#if MG_ENABLE_HTTP && MG_ENABLE_HTTP_WEBSOCKET\n\n#ifndef MG_WEBSOCKET_PING_INTERVAL_SECONDS\n#define MG_WEBSOCKET_PING_INTERVAL_SECONDS 5\n#endif\n\n#define MG_WS_NO_HOST_HEADER_MAGIC ((char *) 0x1)\n\nstatic int mg_is_ws_fragment(unsigned char flags) {\n  return (flags & 0x80) == 0 || (flags & 0x0f) == 0;\n}\n\nstatic int mg_is_ws_first_fragment(unsigned char flags) {\n  return (flags & 0x80) == 0 && (flags & 0x0f) != 0;\n}\n\nstatic void mg_handle_incoming_websocket_frame(struct mg_connection *nc,\n                                               struct websocket_message *wsm) {\n  if (wsm->flags & 0x8) {\n    mg_call(nc, nc->handler, nc->user_data, MG_EV_WEBSOCKET_CONTROL_FRAME, wsm);\n  } else {\n    mg_call(nc, nc->handler, nc->user_data, MG_EV_WEBSOCKET_FRAME, wsm);\n  }\n}\n\nstatic int mg_deliver_websocket_data(struct mg_connection *nc) {\n  /* Using unsigned char *, cause of integer arithmetic below */\n  uint64_t i, data_len = 0, frame_len = 0, buf_len = nc->recv_mbuf.len, len,\n              mask_len = 0, header_len = 0;\n  unsigned char *p = (unsigned char *) nc->recv_mbuf.buf, *buf = p,\n                *e = p + buf_len;\n  unsigned *sizep = (unsigned *) &p[1]; /* Size ptr for defragmented frames */\n  int ok, reass = buf_len > 0 && mg_is_ws_fragment(p[0]) &&\n                  !(nc->flags & MG_F_WEBSOCKET_NO_DEFRAG);\n\n  /* If that's a continuation frame that must be reassembled, handle it */\n  if (reass && !mg_is_ws_first_fragment(p[0]) &&\n      buf_len >= 1 + sizeof(*sizep) && buf_len >= 1 + sizeof(*sizep) + *sizep) {\n    buf += 1 + sizeof(*sizep) + *sizep;\n    buf_len -= 1 + sizeof(*sizep) + *sizep;\n  }\n\n  if (buf_len >= 2) {\n    len = buf[1] & 127;\n    mask_len = buf[1] & 128 ? 4 : 0;\n    if (len < 126 && buf_len >= mask_len) {\n      data_len = len;\n      header_len = 2 + mask_len;\n    } else if (len == 126 && buf_len >= 4 + mask_len) {\n      header_len = 4 + mask_len;\n      data_len = ntohs(*(uint16_t *) &buf[2]);\n    } else if (buf_len >= 10 + mask_len) {\n      header_len = 10 + mask_len;\n      data_len = (((uint64_t) ntohl(*(uint32_t *) &buf[2])) << 32) +\n                 ntohl(*(uint32_t *) &buf[6]);\n    }\n  }\n\n  frame_len = header_len + data_len;\n  ok = frame_len > 0 && frame_len <= buf_len;\n\n  if (ok) {\n    struct websocket_message wsm;\n\n    wsm.size = (size_t) data_len;\n    wsm.data = buf + header_len;\n    wsm.flags = buf[0];\n\n    /* Apply mask if necessary */\n    if (mask_len > 0) {\n      for (i = 0; i < data_len; i++) {\n        buf[i + header_len] ^= (buf + header_len - mask_len)[i % 4];\n      }\n    }\n\n    if (reass) {\n      /* On first fragmented frame, nullify size */\n      if (mg_is_ws_first_fragment(wsm.flags)) {\n        mbuf_resize(&nc->recv_mbuf, nc->recv_mbuf.size + sizeof(*sizep));\n        p[0] &= ~0x0f; /* Next frames will be treated as continuation */\n        buf = p + 1 + sizeof(*sizep);\n        *sizep = 0; /* TODO(lsm): fix. this can stomp over frame data */\n      }\n\n      /* Append this frame to the reassembled buffer */\n      memmove(buf, wsm.data, e - wsm.data);\n      (*sizep) += wsm.size;\n      nc->recv_mbuf.len -= wsm.data - buf;\n\n      /* On last fragmented frame - call user handler and remove data */\n      if (wsm.flags & 0x80) {\n        wsm.data = p + 1 + sizeof(*sizep);\n        wsm.size = *sizep;\n        mg_handle_incoming_websocket_frame(nc, &wsm);\n        mbuf_remove(&nc->recv_mbuf, 1 + sizeof(*sizep) + *sizep);\n      }\n    } else {\n      /* TODO(lsm): properly handle OOB control frames during defragmentation */\n      mg_handle_incoming_websocket_frame(nc, &wsm);\n      mbuf_remove(&nc->recv_mbuf, (size_t) frame_len); /* Cleanup frame */\n    }\n\n    /* If the frame is not reassembled - client closes and close too */\n    if (!reass && (buf[0] & 0x0f) == WEBSOCKET_OP_CLOSE) {\n      nc->flags |= MG_F_SEND_AND_CLOSE;\n    }\n  }\n\n  return ok;\n}\n\nstruct ws_mask_ctx {\n  size_t pos; /* zero means unmasked */\n  uint32_t mask;\n};\n\nstatic uint32_t mg_ws_random_mask(void) {\n  uint32_t mask;\n/*\n * The spec requires WS client to generate hard to\n * guess mask keys. From RFC6455, Section 5.3:\n *\n * The unpredictability of the masking key is essential to prevent\n * authors of malicious applications from selecting the bytes that appear on\n * the wire.\n *\n * Hence this feature is essential when the actual end user of this API\n * is untrusted code that wouldn't have access to a lower level net API\n * anyway (e.g. web browsers). Hence this feature is low prio for most\n * mongoose use cases and thus can be disabled, e.g. when porting to a platform\n * that lacks rand().\n */\n#if MG_DISABLE_WS_RANDOM_MASK\n  mask = 0xefbeadde; /* generated with a random number generator, I swear */\n#else\n  if (sizeof(long) >= 4) {\n    mask = (uint32_t) rand();\n  } else if (sizeof(long) == 2) {\n    mask = (uint32_t) rand() << 16 | (uint32_t) rand();\n  }\n#endif\n  return mask;\n}\n\nstatic void mg_send_ws_header(struct mg_connection *nc, int op, size_t len,\n                              struct ws_mask_ctx *ctx) {\n  int header_len;\n  unsigned char header[10];\n\n  header[0] = (op & WEBSOCKET_DONT_FIN ? 0x0 : 0x80) + (op & 0x0f);\n  if (len < 126) {\n    header[1] = (unsigned char) len;\n    header_len = 2;\n  } else if (len < 65535) {\n    uint16_t tmp = htons((uint16_t) len);\n    header[1] = 126;\n    memcpy(&header[2], &tmp, sizeof(tmp));\n    header_len = 4;\n  } else {\n    uint32_t tmp;\n    header[1] = 127;\n    tmp = htonl((uint32_t)((uint64_t) len >> 32));\n    memcpy(&header[2], &tmp, sizeof(tmp));\n    tmp = htonl((uint32_t)(len & 0xffffffff));\n    memcpy(&header[6], &tmp, sizeof(tmp));\n    header_len = 10;\n  }\n\n  /* client connections enable masking */\n  if (nc->listener == NULL) {\n    header[1] |= 1 << 7; /* set masking flag */\n    mg_send(nc, header, header_len);\n    ctx->mask = mg_ws_random_mask();\n    mg_send(nc, &ctx->mask, sizeof(ctx->mask));\n    ctx->pos = nc->send_mbuf.len;\n  } else {\n    mg_send(nc, header, header_len);\n    ctx->pos = 0;\n  }\n}\n\nstatic void mg_ws_mask_frame(struct mbuf *mbuf, struct ws_mask_ctx *ctx) {\n  size_t i;\n  if (ctx->pos == 0) return;\n  for (i = 0; i < (mbuf->len - ctx->pos); i++) {\n    mbuf->buf[ctx->pos + i] ^= ((char *) &ctx->mask)[i % 4];\n  }\n}\n\nvoid mg_send_websocket_frame(struct mg_connection *nc, int op, const void *data,\n                             size_t len) {\n  struct ws_mask_ctx ctx;\n  DBG((\"%p %d %d\", nc, op, (int) len));\n  mg_send_ws_header(nc, op, len, &ctx);\n  mg_send(nc, data, len);\n\n  mg_ws_mask_frame(&nc->send_mbuf, &ctx);\n\n  if (op == WEBSOCKET_OP_CLOSE) {\n    nc->flags |= MG_F_SEND_AND_CLOSE;\n  }\n}\n\nvoid mg_send_websocket_framev(struct mg_connection *nc, int op,\n                              const struct mg_str *strv, int strvcnt) {\n  struct ws_mask_ctx ctx;\n  int i;\n  int len = 0;\n  for (i = 0; i < strvcnt; i++) {\n    len += strv[i].len;\n  }\n\n  mg_send_ws_header(nc, op, len, &ctx);\n\n  for (i = 0; i < strvcnt; i++) {\n    mg_send(nc, strv[i].p, strv[i].len);\n  }\n\n  mg_ws_mask_frame(&nc->send_mbuf, &ctx);\n\n  if (op == WEBSOCKET_OP_CLOSE) {\n    nc->flags |= MG_F_SEND_AND_CLOSE;\n  }\n}\n\nvoid mg_printf_websocket_frame(struct mg_connection *nc, int op,\n                               const char *fmt, ...) {\n  char mem[MG_VPRINTF_BUFFER_SIZE], *buf = mem;\n  va_list ap;\n  int len;\n\n  va_start(ap, fmt);\n  if ((len = mg_avprintf(&buf, sizeof(mem), fmt, ap)) > 0) {\n    mg_send_websocket_frame(nc, op, buf, len);\n  }\n  va_end(ap);\n\n  if (buf != mem && buf != NULL) {\n    MG_FREE(buf);\n  }\n}\n\nMG_INTERNAL void mg_ws_handler(struct mg_connection *nc, int ev,\n                               void *ev_data MG_UD_ARG(void *user_data)) {\n  mg_call(nc, nc->handler, nc->user_data, ev, ev_data);\n\n  switch (ev) {\n    case MG_EV_RECV:\n      do {\n      } while (mg_deliver_websocket_data(nc));\n      break;\n    case MG_EV_POLL:\n      /* Ping idle websocket connections */\n      {\n        time_t now = *(time_t *) ev_data;\n        if (nc->flags & MG_F_IS_WEBSOCKET &&\n            now > nc->last_io_time + MG_WEBSOCKET_PING_INTERVAL_SECONDS) {\n          mg_send_websocket_frame(nc, WEBSOCKET_OP_PING, \"\", 0);\n        }\n      }\n      break;\n    default:\n      break;\n  }\n#if MG_ENABLE_CALLBACK_USERDATA\n  (void) user_data;\n#endif\n}\n\n#ifndef MG_EXT_SHA1\nstatic void mg_hash_sha1_v(size_t num_msgs, const uint8_t *msgs[],\n                           const size_t *msg_lens, uint8_t *digest) {\n  size_t i;\n  cs_sha1_ctx sha_ctx;\n  cs_sha1_init(&sha_ctx);\n  for (i = 0; i < num_msgs; i++) {\n    cs_sha1_update(&sha_ctx, msgs[i], msg_lens[i]);\n  }\n  cs_sha1_final(digest, &sha_ctx);\n}\n#else\nextern void mg_hash_sha1_v(size_t num_msgs, const uint8_t *msgs[],\n                           const size_t *msg_lens, uint8_t *digest);\n#endif\n\nMG_INTERNAL void mg_ws_handshake(struct mg_connection *nc,\n                                 const struct mg_str *key) {\n  static const char *magic = \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\n  const uint8_t *msgs[2] = {(const uint8_t *) key->p, (const uint8_t *) magic};\n  const size_t msg_lens[2] = {key->len, 36};\n  unsigned char sha[20];\n  char b64_sha[30];\n\n  mg_hash_sha1_v(2, msgs, msg_lens, sha);\n  mg_base64_encode(sha, sizeof(sha), b64_sha);\n  mg_printf(nc, \"%s%s%s\",\n            \"HTTP/1.1 101 Switching Protocols\\r\\n\"\n            \"Upgrade: websocket\\r\\n\"\n            \"Connection: Upgrade\\r\\n\"\n            \"Sec-WebSocket-Accept: \",\n            b64_sha, \"\\r\\n\\r\\n\");\n  DBG((\"%p %.*s %s\", nc, (int) key->len, key->p, b64_sha));\n}\n\nvoid mg_send_websocket_handshake2(struct mg_connection *nc, const char *path,\n                                  const char *host, const char *protocol,\n                                  const char *extra_headers) {\n  mg_send_websocket_handshake3(nc, path, host, protocol, extra_headers, NULL,\n                               NULL);\n}\n\nvoid mg_send_websocket_handshake3(struct mg_connection *nc, const char *path,\n                                  const char *host, const char *protocol,\n                                  const char *extra_headers, const char *user,\n                                  const char *pass) {\n  struct mbuf auth;\n  char key[25];\n  uint32_t nonce[4];\n  nonce[0] = mg_ws_random_mask();\n  nonce[1] = mg_ws_random_mask();\n  nonce[2] = mg_ws_random_mask();\n  nonce[3] = mg_ws_random_mask();\n  mg_base64_encode((unsigned char *) &nonce, sizeof(nonce), key);\n\n  mbuf_init(&auth, 0);\n  if (user != NULL) {\n    mg_basic_auth_header(user, pass, &auth);\n  }\n\n  /*\n   * NOTE: the  (auth.buf == NULL ? \"\" : auth.buf) is because cc3200 libc is\n   * broken: it doesn't like zero length to be passed to %.*s\n   * i.e. sprintf(\"f%.*so\", (int)0, NULL), yields `f\\0o`.\n   * because it handles NULL specially (and incorrectly).\n   */\n  mg_printf(nc,\n            \"GET %s HTTP/1.1\\r\\n\"\n            \"Upgrade: websocket\\r\\n\"\n            \"Connection: Upgrade\\r\\n\"\n            \"%.*s\"\n            \"Sec-WebSocket-Version: 13\\r\\n\"\n            \"Sec-WebSocket-Key: %s\\r\\n\",\n            path, (int) auth.len, (auth.buf == NULL ? \"\" : auth.buf), key);\n\n  /* TODO(mkm): take default hostname from http proto data if host == NULL */\n  if (host != MG_WS_NO_HOST_HEADER_MAGIC) {\n    mg_printf(nc, \"Host: %s\\r\\n\", host);\n  }\n  if (protocol != NULL) {\n    mg_printf(nc, \"Sec-WebSocket-Protocol: %s\\r\\n\", protocol);\n  }\n  if (extra_headers != NULL) {\n    mg_printf(nc, \"%s\", extra_headers);\n  }\n  mg_printf(nc, \"\\r\\n\");\n\n  mbuf_free(&auth);\n}\n\nvoid mg_send_websocket_handshake(struct mg_connection *nc, const char *path,\n                                 const char *extra_headers) {\n  mg_send_websocket_handshake2(nc, path, MG_WS_NO_HOST_HEADER_MAGIC, NULL,\n                               extra_headers);\n}\n\nstruct mg_connection *mg_connect_ws_opt(\n    struct mg_mgr *mgr, MG_CB(mg_event_handler_t ev_handler, void *user_data),\n    struct mg_connect_opts opts, const char *url, const char *protocol,\n    const char *extra_headers) {\n  char *user = NULL, *pass = NULL, *addr = NULL;\n  const char *path = NULL;\n  struct mg_connection *nc =\n      mg_connect_http_base(mgr, MG_CB(ev_handler, user_data), opts, \"ws://\",\n                           \"wss://\", url, &path, &user, &pass, &addr);\n\n  if (nc != NULL) {\n    mg_send_websocket_handshake3(nc, path, addr, protocol, extra_headers, user,\n                                 pass);\n  }\n\n  MG_FREE(addr);\n  MG_FREE(user);\n  MG_FREE(pass);\n  return nc;\n}\n\nstruct mg_connection *mg_connect_ws(\n    struct mg_mgr *mgr, MG_CB(mg_event_handler_t ev_handler, void *user_data),\n    const char *url, const char *protocol, const char *extra_headers) {\n  struct mg_connect_opts opts;\n  memset(&opts, 0, sizeof(opts));\n  return mg_connect_ws_opt(mgr, MG_CB(ev_handler, user_data), opts, url,\n                           protocol, extra_headers);\n}\n#endif /* MG_ENABLE_HTTP && MG_ENABLE_HTTP_WEBSOCKET */\n#ifdef MG_MODULE_LINES\n#line 1 \"mongoose/src/util.c\"\n#endif\n/*\n * Copyright (c) 2014 Cesanta Software Limited\n * All rights reserved\n */\n\n/* Amalgamated: #include \"common/base64.h\" */\n/* Amalgamated: #include \"mongoose/src/internal.h\" */\n/* Amalgamated: #include \"mongoose/src/util.h\" */\n\n/* For platforms with limited libc */\n#ifndef MAX\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n#endif\n\nconst char *mg_skip(const char *s, const char *end, const char *delims,\n                    struct mg_str *v) {\n  v->p = s;\n  while (s < end && strchr(delims, *(unsigned char *) s) == NULL) s++;\n  v->len = s - v->p;\n  while (s < end && strchr(delims, *(unsigned char *) s) != NULL) s++;\n  return s;\n}\n\nstatic int lowercase(const char *s) {\n  return tolower(*(const unsigned char *) s);\n}\n\n#if MG_ENABLE_FILESYSTEM && !defined(MG_USER_FILE_FUNCTIONS)\nint mg_stat(const char *path, cs_stat_t *st) {\n#ifdef _WIN32\n  wchar_t wpath[MAX_PATH_SIZE];\n  to_wchar(path, wpath, ARRAY_SIZE(wpath));\n  DBG((\"[%ls] -> %d\", wpath, _wstati64(wpath, st)));\n  return _wstati64(wpath, st);\n#else\n  return stat(path, st);\n#endif\n}\n\nFILE *mg_fopen(const char *path, const char *mode) {\n#ifdef _WIN32\n  wchar_t wpath[MAX_PATH_SIZE], wmode[10];\n  to_wchar(path, wpath, ARRAY_SIZE(wpath));\n  to_wchar(mode, wmode, ARRAY_SIZE(wmode));\n  return _wfopen(wpath, wmode);\n#else\n  return fopen(path, mode);\n#endif\n}\n\nint mg_open(const char *path, int flag, int mode) { /* LCOV_EXCL_LINE */\n#if defined(_WIN32) && !defined(WINCE)\n  wchar_t wpath[MAX_PATH_SIZE];\n  to_wchar(path, wpath, ARRAY_SIZE(wpath));\n  return _wopen(wpath, flag, mode);\n#else\n  return open(path, flag, mode); /* LCOV_EXCL_LINE */\n#endif\n}\n\nsize_t mg_fread(void *ptr, size_t size, size_t count, FILE *f) {\n  return fread(ptr, size, count, f);\n}\n\nsize_t mg_fwrite(const void *ptr, size_t size, size_t count, FILE *f) {\n  return fwrite(ptr, size, count, f);\n}\n#endif\n\nvoid mg_base64_encode(const unsigned char *src, int src_len, char *dst) {\n  cs_base64_encode(src, src_len, dst);\n}\n\nint mg_base64_decode(const unsigned char *s, int len, char *dst) {\n  return cs_base64_decode(s, len, dst, NULL);\n}\n\n#if MG_ENABLE_THREADS\nvoid *mg_start_thread(void *(*f)(void *), void *p) {\n#ifdef WINCE\n  return (void *) CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) f, p, 0, NULL);\n#elif defined(_WIN32)\n  return (void *) _beginthread((void(__cdecl *) (void *) ) f, 0, p);\n#else\n  pthread_t thread_id = (pthread_t) 0;\n  pthread_attr_t attr;\n\n  (void) pthread_attr_init(&attr);\n  (void) pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\n#if defined(MG_STACK_SIZE) && MG_STACK_SIZE > 1\n  (void) pthread_attr_setstacksize(&attr, MG_STACK_SIZE);\n#endif\n\n  pthread_create(&thread_id, &attr, f, p);\n  pthread_attr_destroy(&attr);\n\n  return (void *) thread_id;\n#endif\n}\n#endif /* MG_ENABLE_THREADS */\n\n/* Set close-on-exec bit for a given socket. */\nvoid mg_set_close_on_exec(sock_t sock) {\n#if defined(_WIN32) && !defined(WINCE)\n  (void) SetHandleInformation((HANDLE) sock, HANDLE_FLAG_INHERIT, 0);\n#elif defined(__unix__)\n  fcntl(sock, F_SETFD, FD_CLOEXEC);\n#else\n  (void) sock;\n#endif\n}\n\nvoid mg_sock_addr_to_str(const union socket_address *sa, char *buf, size_t len,\n                         int flags) {\n  int is_v6;\n  if (buf == NULL || len <= 0) return;\n  memset(buf, 0, len);\n#if MG_ENABLE_IPV6\n  is_v6 = sa->sa.sa_family == AF_INET6;\n#else\n  is_v6 = 0;\n#endif\n  if (flags & MG_SOCK_STRINGIFY_IP) {\n#if MG_ENABLE_IPV6\n    const void *addr = NULL;\n    char *start = buf;\n    socklen_t capacity = len;\n    if (!is_v6) {\n      addr = &sa->sin.sin_addr;\n    } else {\n      addr = (void *) &sa->sin6.sin6_addr;\n      if (flags & MG_SOCK_STRINGIFY_PORT) {\n        *buf = '[';\n        start++;\n        capacity--;\n      }\n    }\n    if (inet_ntop(sa->sa.sa_family, addr, start, capacity) == NULL) {\n      goto cleanup;\n    }\n#elif defined(_WIN32) || MG_LWIP || (MG_NET_IF == MG_NET_IF_PIC32)\n    /* Only Windoze Vista (and newer) have inet_ntop() */\n    char *addr_str = inet_ntoa(sa->sin.sin_addr);\n    if (addr_str != NULL) {\n      strncpy(buf, inet_ntoa(sa->sin.sin_addr), len - 1);\n    } else {\n      goto cleanup;\n    }\n#else\n    if (inet_ntop(AF_INET, (void *) &sa->sin.sin_addr, buf, len - 1) == NULL) {\n      goto cleanup;\n    }\n#endif\n  }\n  if (flags & MG_SOCK_STRINGIFY_PORT) {\n    int port = ntohs(sa->sin.sin_port);\n    if (flags & MG_SOCK_STRINGIFY_IP) {\n      int buf_len = strlen(buf);\n      snprintf(buf + buf_len, len - (buf_len + 1), \"%s:%d\", (is_v6 ? \"]\" : \"\"),\n               port);\n    } else {\n      snprintf(buf, len, \"%d\", port);\n    }\n  }\n\n  return;\n\ncleanup:\n  *buf = '\\0';\n}\n\nvoid mg_conn_addr_to_str(struct mg_connection *nc, char *buf, size_t len,\n                         int flags) {\n  union socket_address sa;\n  memset(&sa, 0, sizeof(sa));\n  mg_if_get_conn_addr(nc, flags & MG_SOCK_STRINGIFY_REMOTE, &sa);\n  mg_sock_addr_to_str(&sa, buf, len, flags);\n}\n\n#if MG_ENABLE_HEXDUMP\nstatic int mg_hexdump_n(const void *buf, int len, char *dst, int dst_len,\n                        int offset) {\n  const unsigned char *p = (const unsigned char *) buf;\n  char ascii[17] = \"\";\n  int i, idx, n = 0;\n\n  for (i = 0; i < len; i++) {\n    idx = i % 16;\n    if (idx == 0) {\n      if (i > 0) n += snprintf(dst + n, MAX(dst_len - n, 0), \"  %s\\n\", ascii);\n      n += snprintf(dst + n, MAX(dst_len - n, 0), \"%04x \", i + offset);\n    }\n    if (dst_len - n < 0) {\n      return n;\n    }\n    n += snprintf(dst + n, MAX(dst_len - n, 0), \" %02x\", p[i]);\n    ascii[idx] = p[i] < 0x20 || p[i] > 0x7e ? '.' : p[i];\n    ascii[idx + 1] = '\\0';\n  }\n\n  while (i++ % 16) n += snprintf(dst + n, MAX(dst_len - n, 0), \"%s\", \"   \");\n  n += snprintf(dst + n, MAX(dst_len - n, 0), \"  %s\\n\", ascii);\n\n  return n;\n}\n\nint mg_hexdump(const void *buf, int len, char *dst, int dst_len) {\n  return mg_hexdump_n(buf, len, dst, dst_len, 0);\n}\n\nvoid mg_hexdumpf(FILE *fp, const void *buf, int len) {\n  char tmp[80];\n  int offset = 0, n;\n  while (len > 0) {\n    n = (len < 16 ? len : 16);\n    mg_hexdump_n(((const char *) buf) + offset, n, tmp, sizeof(tmp), offset);\n    fputs(tmp, fp);\n    offset += n;\n    len -= n;\n  }\n}\n\nvoid mg_hexdump_connection(struct mg_connection *nc, const char *path,\n                           const void *buf, int num_bytes, int ev) {\n  FILE *fp = NULL;\n  char *hexbuf, src[60], dst[60];\n  int buf_size = num_bytes * 5 + 100;\n\n  if (strcmp(path, \"-\") == 0) {\n    fp = stdout;\n  } else if (strcmp(path, \"--\") == 0) {\n    fp = stderr;\n#if MG_ENABLE_FILESYSTEM\n  } else {\n    fp = mg_fopen(path, \"a\");\n#endif\n  }\n  if (fp == NULL) return;\n\n  mg_conn_addr_to_str(nc, src, sizeof(src),\n                      MG_SOCK_STRINGIFY_IP | MG_SOCK_STRINGIFY_PORT);\n  mg_conn_addr_to_str(nc, dst, sizeof(dst), MG_SOCK_STRINGIFY_IP |\n                                                MG_SOCK_STRINGIFY_PORT |\n                                                MG_SOCK_STRINGIFY_REMOTE);\n  fprintf(\n      fp, \"%lu %p %s %s %s %d\\n\", (unsigned long) mg_time(), (void *) nc, src,\n      ev == MG_EV_RECV ? \"<-\" : ev == MG_EV_SEND\n                                    ? \"->\"\n                                    : ev == MG_EV_ACCEPT\n                                          ? \"<A\"\n                                          : ev == MG_EV_CONNECT ? \"C>\" : \"XX\",\n      dst, num_bytes);\n  if (num_bytes > 0 && (hexbuf = (char *) MG_MALLOC(buf_size)) != NULL) {\n    mg_hexdump(buf, num_bytes, hexbuf, buf_size);\n    fprintf(fp, \"%s\", hexbuf);\n    MG_FREE(hexbuf);\n  }\n  if (fp != stdin && fp != stdout) fclose(fp);\n}\n#endif\n\nint mg_is_big_endian(void) {\n  static const int n = 1;\n  /* TODO(mkm) use compiletime check with 4-byte char literal */\n  return ((char *) &n)[0] == 0;\n}\n\nconst char *mg_next_comma_list_entry(const char *list, struct mg_str *val,\n                                     struct mg_str *eq_val) {\n  if (list == NULL || *list == '\\0') {\n    /* End of the list */\n    list = NULL;\n  } else {\n    val->p = list;\n    if ((list = strchr(val->p, ',')) != NULL) {\n      /* Comma found. Store length and shift the list ptr */\n      val->len = list - val->p;\n      list++;\n    } else {\n      /* This value is the last one */\n      list = val->p + strlen(val->p);\n      val->len = list - val->p;\n    }\n\n    if (eq_val != NULL) {\n      /* Value has form \"x=y\", adjust pointers and lengths */\n      /* so that val points to \"x\", and eq_val points to \"y\". */\n      eq_val->len = 0;\n      eq_val->p = (const char *) memchr(val->p, '=', val->len);\n      if (eq_val->p != NULL) {\n        eq_val->p++; /* Skip over '=' character */\n        eq_val->len = val->p + val->len - eq_val->p;\n        val->len = (eq_val->p - val->p) - 1;\n      }\n    }\n  }\n\n  return list;\n}\n\nint mg_match_prefix_n(const struct mg_str pattern, const struct mg_str str) {\n  const char *or_str;\n  size_t len, i = 0, j = 0;\n  int res;\n\n  if ((or_str = (const char *) memchr(pattern.p, '|', pattern.len)) != NULL) {\n    struct mg_str pstr = {pattern.p, (size_t)(or_str - pattern.p)};\n    res = mg_match_prefix_n(pstr, str);\n    if (res > 0) return res;\n    pstr.p = or_str + 1;\n    pstr.len = (pattern.p + pattern.len) - (or_str + 1);\n    return mg_match_prefix_n(pstr, str);\n  }\n\n  for (; i < pattern.len; i++, j++) {\n    if (pattern.p[i] == '?' && j != str.len) {\n      continue;\n    } else if (pattern.p[i] == '$') {\n      return j == str.len ? (int) j : -1;\n    } else if (pattern.p[i] == '*') {\n      i++;\n      if (pattern.p[i] == '*') {\n        i++;\n        len = str.len - j;\n      } else {\n        len = 0;\n        while (j + len != str.len && str.p[j + len] != '/') {\n          len++;\n        }\n      }\n      if (i == pattern.len) {\n        return j + len;\n      }\n      do {\n        const struct mg_str pstr = {pattern.p + i, pattern.len - i};\n        const struct mg_str sstr = {str.p + j + len, str.len - j - len};\n        res = mg_match_prefix_n(pstr, sstr);\n      } while (res == -1 && len-- > 0);\n      return res == -1 ? -1 : (int) (j + res + len);\n    } else if (lowercase(&pattern.p[i]) != lowercase(&str.p[j])) {\n      return -1;\n    }\n  }\n  return j;\n}\n\nint mg_match_prefix(const char *pattern, int pattern_len, const char *str) {\n  const struct mg_str pstr = {pattern, (size_t) pattern_len};\n  return mg_match_prefix_n(pstr, mg_mk_str(str));\n}\n\nDO_NOT_WARN_UNUSED MG_INTERNAL int mg_get_errno(void) {\n#ifndef WINCE\n  return errno;\n#else\n  /* TODO(alashkin): translate error codes? */\n  return GetLastError();\n#endif\n}\n\nvoid mg_mbuf_append_base64_putc(char ch, void *user_data) {\n  struct mbuf *mbuf = (struct mbuf *) user_data;\n  mbuf_append(mbuf, &ch, sizeof(ch));\n}\n\nvoid mg_mbuf_append_base64(struct mbuf *mbuf, const void *data, size_t len) {\n  struct cs_base64_ctx ctx;\n  cs_base64_init(&ctx, mg_mbuf_append_base64_putc, mbuf);\n  cs_base64_update(&ctx, (const char *) data, len);\n  cs_base64_finish(&ctx);\n}\n\nvoid mg_basic_auth_header(const char *user, const char *pass,\n                          struct mbuf *buf) {\n  const char *header_prefix = \"Authorization: Basic \";\n  const char *header_suffix = \"\\r\\n\";\n\n  struct cs_base64_ctx ctx;\n  cs_base64_init(&ctx, mg_mbuf_append_base64_putc, buf);\n\n  mbuf_append(buf, header_prefix, strlen(header_prefix));\n\n  cs_base64_update(&ctx, user, strlen(user));\n  if (pass != NULL) {\n    cs_base64_update(&ctx, \":\", 1);\n    cs_base64_update(&ctx, pass, strlen(pass));\n  }\n  cs_base64_finish(&ctx);\n  mbuf_append(buf, header_suffix, strlen(header_suffix));\n}\n#ifdef MG_MODULE_LINES\n#line 1 \"mongoose/src/mqtt.c\"\n#endif\n/*\n * Copyright (c) 2014 Cesanta Software Limited\n * All rights reserved\n */\n\n#if MG_ENABLE_MQTT\n\n#include <string.h>\n\n/* Amalgamated: #include \"mongoose/src/internal.h\" */\n/* Amalgamated: #include \"mongoose/src/mqtt.h\" */\n\nstatic uint16_t getu16(const char *p) {\n  const uint8_t *up = (const uint8_t *) p;\n  return (up[0] << 8) + up[1];\n}\n\nstatic const char *scanto(const char *p, struct mg_str *s) {\n  s->len = getu16(p);\n  s->p = p + 2;\n  return s->p + s->len;\n}\n\nMG_INTERNAL int parse_mqtt(struct mbuf *io, struct mg_mqtt_message *mm) {\n  uint8_t header;\n  size_t len = 0;\n  int cmd;\n  const char *p = &io->buf[1], *end;\n\n  if (io->len < 2) return -1;\n  header = io->buf[0];\n  cmd = header >> 4;\n\n  /* decode mqtt variable length */\n  do {\n    len += (*p & 127) << 7 * (p - &io->buf[1]);\n  } while ((*p++ & 128) != 0 && ((size_t)(p - io->buf) <= io->len));\n\n  end = p + len;\n  if (end > io->buf + io->len + 1) {\n    return -1;\n  }\n\n  mm->cmd = cmd;\n  mm->qos = MG_MQTT_GET_QOS(header);\n\n  switch (cmd) {\n    case MG_MQTT_CMD_CONNECT: {\n      p = scanto(p, &mm->protocol_name);\n      mm->protocol_version = *(uint8_t *) p++;\n      mm->connect_flags = *(uint8_t *) p++;\n      mm->keep_alive_timer = getu16(p);\n      p += 2;\n      if (p < end) p = scanto(p, &mm->client_id);\n      if (p < end && (mm->connect_flags & MG_MQTT_HAS_WILL))\n        p = scanto(p, &mm->will_topic);\n      if (p < end && (mm->connect_flags & MG_MQTT_HAS_WILL))\n        p = scanto(p, &mm->will_message);\n      if (p < end && (mm->connect_flags & MG_MQTT_HAS_USER_NAME))\n        p = scanto(p, &mm->user_name);\n      if (p < end && (mm->connect_flags & MG_MQTT_HAS_PASSWORD))\n        p = scanto(p, &mm->password);\n\n      LOG(LL_DEBUG,\n          (\"%d %2x %d proto [%.*s] client_id [%.*s] will_topic [%.*s] \"\n           \"will_msg [%.*s] user_name [%.*s] password [%.*s]\",\n           len, (int) mm->connect_flags, (int) mm->keep_alive_timer,\n           (int) mm->protocol_name.len, mm->protocol_name.p,\n           (int) mm->client_id.len, mm->client_id.p, (int) mm->will_topic.len,\n           mm->will_topic.p, (int) mm->will_message.len, mm->will_message.p,\n           (int) mm->user_name.len, mm->user_name.p, (int) mm->password.len,\n           mm->password.p));\n      break;\n    }\n    case MG_MQTT_CMD_CONNACK:\n      mm->connack_ret_code = p[1];\n      break;\n    case MG_MQTT_CMD_PUBACK:\n    case MG_MQTT_CMD_PUBREC:\n    case MG_MQTT_CMD_PUBREL:\n    case MG_MQTT_CMD_PUBCOMP:\n    case MG_MQTT_CMD_SUBACK:\n      mm->message_id = getu16(p);\n      break;\n    case MG_MQTT_CMD_PUBLISH: {\n      p = scanto(p, &mm->topic);\n      if (mm->qos > 0) {\n        mm->message_id = getu16(p);\n        p += 2;\n      }\n      mm->payload.p = p;\n      mm->payload.len = end - p;\n      break;\n    }\n    case MG_MQTT_CMD_SUBSCRIBE:\n      mm->message_id = getu16(p);\n      p += 2;\n      /*\n       * topic expressions are left in the payload and can be parsed with\n       * `mg_mqtt_next_subscribe_topic`\n       */\n      mm->payload.p = p;\n      mm->payload.len = end - p;\n      break;\n    default:\n      /* Unhandled command */\n      break;\n  }\n\n  return end - io->buf;\n}\n\nstatic void mqtt_handler(struct mg_connection *nc, int ev,\n                         void *ev_data MG_UD_ARG(void *user_data)) {\n  int len;\n  struct mbuf *io = &nc->recv_mbuf;\n  struct mg_mqtt_message mm;\n  memset(&mm, 0, sizeof(mm));\n\n  nc->handler(nc, ev, ev_data MG_UD_ARG(user_data));\n\n  switch (ev) {\n    case MG_EV_RECV:\n      len = parse_mqtt(io, &mm);\n      if (len == -1) break; /* not fully buffered */\n      nc->handler(nc, MG_MQTT_EVENT_BASE + mm.cmd, &mm MG_UD_ARG(user_data));\n      mbuf_remove(io, len);\n      break;\n  }\n}\n\nstatic void mg_mqtt_proto_data_destructor(void *proto_data) {\n  MG_FREE(proto_data);\n}\n\nint mg_mqtt_match_topic_expression(struct mg_str exp, struct mg_str topic) {\n  /* TODO(mkm): implement real matching */\n  if (memchr(exp.p, '#', exp.len)) {\n    /* exp `foo/#` will become `foo/` */\n    exp.len -= 1;\n    /*\n     * topic should be longer than the expression: e.g. topic `foo/bar` does\n     * match `foo/#`, but neither `foo` nor `foo/` do.\n     */\n    if (topic.len <= exp.len) {\n      return 0;\n    }\n\n    /* Truncate topic so that it'll pass the next length check */\n    topic.len = exp.len;\n  }\n  if (topic.len != exp.len) {\n    return 0;\n  }\n  return strncmp(topic.p, exp.p, exp.len) == 0;\n}\n\nint mg_mqtt_vmatch_topic_expression(const char *exp, struct mg_str topic) {\n  return mg_mqtt_match_topic_expression(mg_mk_str(exp), topic);\n}\n\nvoid mg_set_protocol_mqtt(struct mg_connection *nc) {\n  nc->proto_handler = mqtt_handler;\n  nc->proto_data = MG_CALLOC(1, sizeof(struct mg_mqtt_proto_data));\n  nc->proto_data_destructor = mg_mqtt_proto_data_destructor;\n}\n\nvoid mg_send_mqtt_handshake(struct mg_connection *nc, const char *client_id) {\n  static struct mg_send_mqtt_handshake_opts opts;\n  mg_send_mqtt_handshake_opt(nc, client_id, opts);\n}\n\nvoid mg_send_mqtt_handshake_opt(struct mg_connection *nc, const char *client_id,\n                                struct mg_send_mqtt_handshake_opts opts) {\n  uint8_t header = MG_MQTT_CMD_CONNECT << 4;\n  uint8_t rem_len;\n  uint16_t keep_alive;\n  uint16_t len;\n  struct mg_mqtt_proto_data *pd = (struct mg_mqtt_proto_data *) nc->proto_data;\n\n  /*\n   * 9: version_header(len, magic_string, version_number), 1: flags, 2:\n   * keep-alive timer,\n   * 2: client_identifier_len, n: client_id\n   */\n  rem_len = 9 + 1 + 2 + 2 + (uint8_t) strlen(client_id);\n\n  if (opts.user_name != NULL) {\n    opts.flags |= MG_MQTT_HAS_USER_NAME;\n    rem_len += (uint8_t) strlen(opts.user_name) + 2;\n  }\n  if (opts.password != NULL) {\n    opts.flags |= MG_MQTT_HAS_PASSWORD;\n    rem_len += (uint8_t) strlen(opts.password) + 2;\n  }\n  if (opts.will_topic != NULL && opts.will_message != NULL) {\n    opts.flags |= MG_MQTT_HAS_WILL;\n    rem_len += (uint8_t) strlen(opts.will_topic) + 2;\n    rem_len += (uint8_t) strlen(opts.will_message) + 2;\n  }\n\n  mg_send(nc, &header, 1);\n  mg_send(nc, &rem_len, 1);\n  mg_send(nc, \"\\00\\06MQIsdp\\03\", 9);\n  mg_send(nc, &opts.flags, 1);\n\n  if (opts.keep_alive == 0) {\n    opts.keep_alive = 60;\n  }\n\n  keep_alive = htons(opts.keep_alive);\n  mg_send(nc, &keep_alive, 2);\n\n  len = htons((uint16_t) strlen(client_id));\n  mg_send(nc, &len, 2);\n  mg_send(nc, client_id, strlen(client_id));\n\n  if (opts.flags & MG_MQTT_HAS_WILL) {\n    len = htons((uint16_t) strlen(opts.will_topic));\n    mg_send(nc, &len, 2);\n    mg_send(nc, opts.will_topic, strlen(opts.will_topic));\n\n    len = htons((uint16_t) strlen(opts.will_message));\n    mg_send(nc, &len, 2);\n    mg_send(nc, opts.will_message, strlen(opts.will_message));\n  }\n\n  if (opts.flags & MG_MQTT_HAS_USER_NAME) {\n    len = htons((uint16_t) strlen(opts.user_name));\n    mg_send(nc, &len, 2);\n    mg_send(nc, opts.user_name, strlen(opts.user_name));\n  }\n  if (opts.flags & MG_MQTT_HAS_PASSWORD) {\n    len = htons((uint16_t) strlen(opts.password));\n    mg_send(nc, &len, 2);\n    mg_send(nc, opts.password, strlen(opts.password));\n  }\n\n  if (pd != NULL) {\n    pd->keep_alive = opts.keep_alive;\n  }\n}\n\nstatic void mg_mqtt_prepend_header(struct mg_connection *nc, uint8_t cmd,\n                                   uint8_t flags, size_t len) {\n  size_t off = nc->send_mbuf.len - len;\n  uint8_t header = cmd << 4 | (uint8_t) flags;\n\n  uint8_t buf[1 + sizeof(size_t)];\n  uint8_t *vlen = &buf[1];\n\n  assert(nc->send_mbuf.len >= len);\n\n  buf[0] = header;\n\n  /* mqtt variable length encoding */\n  do {\n    *vlen = len % 0x80;\n    len /= 0x80;\n    if (len > 0) *vlen |= 0x80;\n    vlen++;\n  } while (len > 0);\n\n  mbuf_insert(&nc->send_mbuf, off, buf, vlen - buf);\n}\n\nvoid mg_mqtt_publish(struct mg_connection *nc, const char *topic,\n                     uint16_t message_id, int flags, const void *data,\n                     size_t len) {\n  size_t old_len = nc->send_mbuf.len;\n\n  uint16_t topic_len = htons((uint16_t) strlen(topic));\n  uint16_t message_id_net = htons(message_id);\n\n  mg_send(nc, &topic_len, 2);\n  mg_send(nc, topic, strlen(topic));\n  if (MG_MQTT_GET_QOS(flags) > 0) {\n    mg_send(nc, &message_id_net, 2);\n  }\n  mg_send(nc, data, len);\n\n  mg_mqtt_prepend_header(nc, MG_MQTT_CMD_PUBLISH, flags,\n                         nc->send_mbuf.len - old_len);\n}\n\nvoid mg_mqtt_subscribe(struct mg_connection *nc,\n                       const struct mg_mqtt_topic_expression *topics,\n                       size_t topics_len, uint16_t message_id) {\n  size_t old_len = nc->send_mbuf.len;\n\n  uint16_t message_id_n = htons(message_id);\n  size_t i;\n\n  mg_send(nc, (char *) &message_id_n, 2);\n  for (i = 0; i < topics_len; i++) {\n    uint16_t topic_len_n = htons((uint16_t) strlen(topics[i].topic));\n    mg_send(nc, &topic_len_n, 2);\n    mg_send(nc, topics[i].topic, strlen(topics[i].topic));\n    mg_send(nc, &topics[i].qos, 1);\n  }\n\n  mg_mqtt_prepend_header(nc, MG_MQTT_CMD_SUBSCRIBE, MG_MQTT_QOS(1),\n                         nc->send_mbuf.len - old_len);\n}\n\nint mg_mqtt_next_subscribe_topic(struct mg_mqtt_message *msg,\n                                 struct mg_str *topic, uint8_t *qos, int pos) {\n  unsigned char *buf = (unsigned char *) msg->payload.p + pos;\n\n  if ((size_t) pos >= msg->payload.len) {\n    return -1;\n  }\n\n  topic->len = buf[0] << 8 | buf[1];\n  topic->p = (char *) buf + 2;\n  *qos = buf[2 + topic->len];\n  return pos + 2 + topic->len + 1;\n}\n\nvoid mg_mqtt_unsubscribe(struct mg_connection *nc, char **topics,\n                         size_t topics_len, uint16_t message_id) {\n  size_t old_len = nc->send_mbuf.len;\n\n  uint16_t message_id_n = htons(message_id);\n  size_t i;\n\n  mg_send(nc, (char *) &message_id_n, 2);\n  for (i = 0; i < topics_len; i++) {\n    uint16_t topic_len_n = htons((uint16_t) strlen(topics[i]));\n    mg_send(nc, &topic_len_n, 2);\n    mg_send(nc, topics[i], strlen(topics[i]));\n  }\n\n  mg_mqtt_prepend_header(nc, MG_MQTT_CMD_UNSUBSCRIBE, MG_MQTT_QOS(1),\n                         nc->send_mbuf.len - old_len);\n}\n\nvoid mg_mqtt_connack(struct mg_connection *nc, uint8_t return_code) {\n  uint8_t unused = 0;\n  mg_send(nc, &unused, 1);\n  mg_send(nc, &return_code, 1);\n  mg_mqtt_prepend_header(nc, MG_MQTT_CMD_CONNACK, 0, 2);\n}\n\n/*\n * Sends a command which contains only a `message_id` and a QoS level of 1.\n *\n * Helper function.\n */\nstatic void mg_send_mqtt_short_command(struct mg_connection *nc, uint8_t cmd,\n                                       uint16_t message_id) {\n  uint16_t message_id_net = htons(message_id);\n  uint8_t flags = (cmd == MG_MQTT_CMD_PUBREL ? 2 : 0);\n  mg_send(nc, &message_id_net, 2);\n  mg_mqtt_prepend_header(nc, cmd, flags, 2 /* len */);\n}\n\nvoid mg_mqtt_puback(struct mg_connection *nc, uint16_t message_id) {\n  mg_send_mqtt_short_command(nc, MG_MQTT_CMD_PUBACK, message_id);\n}\n\nvoid mg_mqtt_pubrec(struct mg_connection *nc, uint16_t message_id) {\n  mg_send_mqtt_short_command(nc, MG_MQTT_CMD_PUBREC, message_id);\n}\n\nvoid mg_mqtt_pubrel(struct mg_connection *nc, uint16_t message_id) {\n  mg_send_mqtt_short_command(nc, MG_MQTT_CMD_PUBREL, message_id);\n}\n\nvoid mg_mqtt_pubcomp(struct mg_connection *nc, uint16_t message_id) {\n  mg_send_mqtt_short_command(nc, MG_MQTT_CMD_PUBCOMP, message_id);\n}\n\nvoid mg_mqtt_suback(struct mg_connection *nc, uint8_t *qoss, size_t qoss_len,\n                    uint16_t message_id) {\n  size_t i;\n  uint16_t message_id_net = htons(message_id);\n  mg_send(nc, &message_id_net, 2);\n  for (i = 0; i < qoss_len; i++) {\n    mg_send(nc, &qoss[i], 1);\n  }\n  mg_mqtt_prepend_header(nc, MG_MQTT_CMD_SUBACK, MG_MQTT_QOS(1), 2 + qoss_len);\n}\n\nvoid mg_mqtt_unsuback(struct mg_connection *nc, uint16_t message_id) {\n  mg_send_mqtt_short_command(nc, MG_MQTT_CMD_UNSUBACK, message_id);\n}\n\nvoid mg_mqtt_ping(struct mg_connection *nc) {\n  mg_mqtt_prepend_header(nc, MG_MQTT_CMD_PINGREQ, 0, 0);\n}\n\nvoid mg_mqtt_pong(struct mg_connection *nc) {\n  mg_mqtt_prepend_header(nc, MG_MQTT_CMD_PINGRESP, 0, 0);\n}\n\nvoid mg_mqtt_disconnect(struct mg_connection *nc) {\n  mg_mqtt_prepend_header(nc, MG_MQTT_CMD_DISCONNECT, 0, 0);\n}\n\n#endif /* MG_ENABLE_MQTT */\n#ifdef MG_MODULE_LINES\n#line 1 \"mongoose/src/mqtt_server.c\"\n#endif\n/*\n * Copyright (c) 2014 Cesanta Software Limited\n * All rights reserved\n */\n\n/* Amalgamated: #include \"mongoose/src/internal.h\" */\n/* Amalgamated: #include \"mongoose/src/mqtt-server.h\" */\n\n#if MG_ENABLE_MQTT_BROKER\n\nstatic void mg_mqtt_session_init(struct mg_mqtt_broker *brk,\n                                 struct mg_mqtt_session *s,\n                                 struct mg_connection *nc) {\n  s->brk = brk;\n  s->subscriptions = NULL;\n  s->num_subscriptions = 0;\n  s->nc = nc;\n}\n\nstatic void mg_mqtt_add_session(struct mg_mqtt_session *s) {\n  LIST_INSERT_HEAD(&s->brk->sessions, s, link);\n}\n\nstatic void mg_mqtt_remove_session(struct mg_mqtt_session *s) {\n  LIST_REMOVE(s, link);\n}\n\nstatic void mg_mqtt_destroy_session(struct mg_mqtt_session *s) {\n  size_t i;\n  for (i = 0; i < s->num_subscriptions; i++) {\n    MG_FREE((void *) s->subscriptions[i].topic);\n  }\n  MG_FREE(s->subscriptions);\n  MG_FREE(s);\n}\n\nstatic void mg_mqtt_close_session(struct mg_mqtt_session *s) {\n  mg_mqtt_remove_session(s);\n  mg_mqtt_destroy_session(s);\n}\n\nvoid mg_mqtt_broker_init(struct mg_mqtt_broker *brk, void *user_data) {\n  LIST_INIT(&brk->sessions);\n  brk->user_data = user_data;\n}\n\nstatic void mg_mqtt_broker_handle_connect(struct mg_mqtt_broker *brk,\n                                          struct mg_connection *nc) {\n  struct mg_mqtt_session *s =\n      (struct mg_mqtt_session *) MG_CALLOC(1, sizeof *s);\n  if (s == NULL) {\n    /* LCOV_EXCL_START */\n    mg_mqtt_connack(nc, MG_EV_MQTT_CONNACK_SERVER_UNAVAILABLE);\n    return;\n    /* LCOV_EXCL_STOP */\n  }\n\n  /* TODO(mkm): check header (magic and version) */\n\n  mg_mqtt_session_init(brk, s, nc);\n  s->user_data = nc->user_data;\n  nc->user_data = s;\n  mg_mqtt_add_session(s);\n\n  mg_mqtt_connack(nc, MG_EV_MQTT_CONNACK_ACCEPTED);\n}\n\nstatic void mg_mqtt_broker_handle_subscribe(struct mg_connection *nc,\n                                            struct mg_mqtt_message *msg) {\n  struct mg_mqtt_session *ss = (struct mg_mqtt_session *) nc->user_data;\n  uint8_t qoss[512];\n  size_t qoss_len = 0;\n  struct mg_str topic;\n  uint8_t qos;\n  int pos;\n  struct mg_mqtt_topic_expression *te;\n\n  for (pos = 0;\n       (pos = mg_mqtt_next_subscribe_topic(msg, &topic, &qos, pos)) != -1;) {\n    qoss[qoss_len++] = qos;\n  }\n\n  ss->subscriptions = (struct mg_mqtt_topic_expression *) MG_REALLOC(\n      ss->subscriptions, sizeof(*ss->subscriptions) * qoss_len);\n  for (pos = 0;\n       (pos = mg_mqtt_next_subscribe_topic(msg, &topic, &qos, pos)) != -1;\n       ss->num_subscriptions++) {\n    te = &ss->subscriptions[ss->num_subscriptions];\n    te->topic = (char *) MG_MALLOC(topic.len + 1);\n    te->qos = qos;\n    strncpy((char *) te->topic, topic.p, topic.len + 1);\n  }\n\n  mg_mqtt_suback(nc, qoss, qoss_len, msg->message_id);\n}\n\nstatic void mg_mqtt_broker_handle_publish(struct mg_mqtt_broker *brk,\n                                          struct mg_mqtt_message *msg) {\n  struct mg_mqtt_session *s;\n  size_t i;\n\n  for (s = mg_mqtt_next(brk, NULL); s != NULL; s = mg_mqtt_next(brk, s)) {\n    for (i = 0; i < s->num_subscriptions; i++) {\n      if (mg_mqtt_vmatch_topic_expression(s->subscriptions[i].topic,\n                                          msg->topic)) {\n        char buf[100], *p = buf;\n        mg_asprintf(&p, sizeof(buf), \"%.*s\", (int) msg->topic.len,\n                    msg->topic.p);\n        if (p == NULL) {\n          return;\n        }\n        mg_mqtt_publish(s->nc, p, 0, 0, msg->payload.p, msg->payload.len);\n        if (p != buf) {\n          MG_FREE(p);\n        }\n        break;\n      }\n    }\n  }\n}\n\nvoid mg_mqtt_broker(struct mg_connection *nc, int ev, void *data) {\n  struct mg_mqtt_message *msg = (struct mg_mqtt_message *) data;\n  struct mg_mqtt_broker *brk;\n\n  if (nc->listener) {\n    brk = (struct mg_mqtt_broker *) nc->listener->user_data;\n  } else {\n    brk = (struct mg_mqtt_broker *) nc->user_data;\n  }\n\n  switch (ev) {\n    case MG_EV_ACCEPT:\n      mg_set_protocol_mqtt(nc);\n      nc->user_data = NULL; /* Clear up the inherited pointer to broker */\n      break;\n    case MG_EV_MQTT_CONNECT:\n      mg_mqtt_broker_handle_connect(brk, nc);\n      break;\n    case MG_EV_MQTT_SUBSCRIBE:\n      mg_mqtt_broker_handle_subscribe(nc, msg);\n      break;\n    case MG_EV_MQTT_PUBLISH:\n      mg_mqtt_broker_handle_publish(brk, msg);\n      break;\n    case MG_EV_CLOSE:\n      if (nc->listener && nc->user_data != NULL) {\n        mg_mqtt_close_session((struct mg_mqtt_session *) nc->user_data);\n      }\n      break;\n  }\n}\n\nstruct mg_mqtt_session *mg_mqtt_next(struct mg_mqtt_broker *brk,\n                                     struct mg_mqtt_session *s) {\n  return s == NULL ? LIST_FIRST(&brk->sessions) : LIST_NEXT(s, link);\n}\n\n#endif /* MG_ENABLE_MQTT_BROKER */\n#ifdef MG_MODULE_LINES\n#line 1 \"mongoose/src/dns.c\"\n#endif\n/*\n * Copyright (c) 2014 Cesanta Software Limited\n * All rights reserved\n */\n\n#if MG_ENABLE_DNS\n\n/* Amalgamated: #include \"mongoose/src/internal.h\" */\n/* Amalgamated: #include \"mongoose/src/dns.h\" */\n\nstatic int mg_dns_tid = 0xa0;\n\nstruct mg_dns_header {\n  uint16_t transaction_id;\n  uint16_t flags;\n  uint16_t num_questions;\n  uint16_t num_answers;\n  uint16_t num_authority_prs;\n  uint16_t num_other_prs;\n};\n\nstruct mg_dns_resource_record *mg_dns_next_record(\n    struct mg_dns_message *msg, int query,\n    struct mg_dns_resource_record *prev) {\n  struct mg_dns_resource_record *rr;\n\n  for (rr = (prev == NULL ? msg->answers : prev + 1);\n       rr - msg->answers < msg->num_answers; rr++) {\n    if (rr->rtype == query) {\n      return rr;\n    }\n  }\n  return NULL;\n}\n\nint mg_dns_parse_record_data(struct mg_dns_message *msg,\n                             struct mg_dns_resource_record *rr, void *data,\n                             size_t data_len) {\n  switch (rr->rtype) {\n    case MG_DNS_A_RECORD:\n      if (data_len < sizeof(struct in_addr)) {\n        return -1;\n      }\n      if (rr->rdata.p + data_len > msg->pkt.p + msg->pkt.len) {\n        return -1;\n      }\n      memcpy(data, rr->rdata.p, data_len);\n      return 0;\n#if MG_ENABLE_IPV6\n    case MG_DNS_AAAA_RECORD:\n      if (data_len < sizeof(struct in6_addr)) {\n        return -1; /* LCOV_EXCL_LINE */\n      }\n      memcpy(data, rr->rdata.p, data_len);\n      return 0;\n#endif\n    case MG_DNS_CNAME_RECORD:\n      mg_dns_uncompress_name(msg, &rr->rdata, (char *) data, data_len);\n      return 0;\n  }\n\n  return -1;\n}\n\nint mg_dns_insert_header(struct mbuf *io, size_t pos,\n                         struct mg_dns_message *msg) {\n  struct mg_dns_header header;\n\n  memset(&header, 0, sizeof(header));\n  header.transaction_id = msg->transaction_id;\n  header.flags = htons(msg->flags);\n  header.num_questions = htons(msg->num_questions);\n  header.num_answers = htons(msg->num_answers);\n\n  return mbuf_insert(io, pos, &header, sizeof(header));\n}\n\nint mg_dns_copy_questions(struct mbuf *io, struct mg_dns_message *msg) {\n  unsigned char *begin, *end;\n  struct mg_dns_resource_record *last_q;\n  if (msg->num_questions <= 0) return 0;\n  begin = (unsigned char *) msg->pkt.p + sizeof(struct mg_dns_header);\n  last_q = &msg->questions[msg->num_questions - 1];\n  end = (unsigned char *) last_q->name.p + last_q->name.len + 4;\n  return mbuf_append(io, begin, end - begin);\n}\n\nint mg_dns_encode_name(struct mbuf *io, const char *name, size_t len) {\n  const char *s;\n  unsigned char n;\n  size_t pos = io->len;\n\n  do {\n    if ((s = strchr(name, '.')) == NULL) {\n      s = name + len;\n    }\n\n    if (s - name > 127) {\n      return -1; /* TODO(mkm) cover */\n    }\n    n = s - name;           /* chunk length */\n    mbuf_append(io, &n, 1); /* send length */\n    mbuf_append(io, name, n);\n\n    if (*s == '.') {\n      n++;\n    }\n\n    name += n;\n    len -= n;\n  } while (*s != '\\0');\n  mbuf_append(io, \"\\0\", 1); /* Mark end of host name */\n\n  return io->len - pos;\n}\n\nint mg_dns_encode_record(struct mbuf *io, struct mg_dns_resource_record *rr,\n                         const char *name, size_t nlen, const void *rdata,\n                         size_t rlen) {\n  size_t pos = io->len;\n  uint16_t u16;\n  uint32_t u32;\n\n  if (rr->kind == MG_DNS_INVALID_RECORD) {\n    return -1; /* LCOV_EXCL_LINE */\n  }\n\n  if (mg_dns_encode_name(io, name, nlen) == -1) {\n    return -1;\n  }\n\n  u16 = htons(rr->rtype);\n  mbuf_append(io, &u16, 2);\n  u16 = htons(rr->rclass);\n  mbuf_append(io, &u16, 2);\n\n  if (rr->kind == MG_DNS_ANSWER) {\n    u32 = htonl(rr->ttl);\n    mbuf_append(io, &u32, 4);\n\n    if (rr->rtype == MG_DNS_CNAME_RECORD) {\n      int clen;\n      /* fill size after encoding */\n      size_t off = io->len;\n      mbuf_append(io, &u16, 2);\n      if ((clen = mg_dns_encode_name(io, (const char *) rdata, rlen)) == -1) {\n        return -1;\n      }\n      u16 = clen;\n      io->buf[off] = u16 >> 8;\n      io->buf[off + 1] = u16 & 0xff;\n    } else {\n      u16 = htons((uint16_t) rlen);\n      mbuf_append(io, &u16, 2);\n      mbuf_append(io, rdata, rlen);\n    }\n  }\n\n  return io->len - pos;\n}\n\nvoid mg_send_dns_query(struct mg_connection *nc, const char *name,\n                       int query_type) {\n  struct mg_dns_message *msg =\n      (struct mg_dns_message *) MG_CALLOC(1, sizeof(*msg));\n  struct mbuf pkt;\n  struct mg_dns_resource_record *rr = &msg->questions[0];\n\n  DBG((\"%s %d\", name, query_type));\n\n  mbuf_init(&pkt, 64 /* Start small, it'll grow as needed. */);\n\n  msg->transaction_id = ++mg_dns_tid;\n  msg->flags = 0x100;\n  msg->num_questions = 1;\n\n  mg_dns_insert_header(&pkt, 0, msg);\n\n  rr->rtype = query_type;\n  rr->rclass = 1; /* Class: inet */\n  rr->kind = MG_DNS_QUESTION;\n\n  if (mg_dns_encode_record(&pkt, rr, name, strlen(name), NULL, 0) == -1) {\n    /* TODO(mkm): return an error code */\n    goto cleanup; /* LCOV_EXCL_LINE */\n  }\n\n  /* TCP DNS requires messages to be prefixed with len */\n  if (!(nc->flags & MG_F_UDP)) {\n    uint16_t len = htons((uint16_t) pkt.len);\n    mbuf_insert(&pkt, 0, &len, 2);\n  }\n\n  mg_send(nc, pkt.buf, pkt.len);\n  mbuf_free(&pkt);\n\ncleanup:\n  MG_FREE(msg);\n}\n\nstatic unsigned char *mg_parse_dns_resource_record(\n    unsigned char *data, unsigned char *end, struct mg_dns_resource_record *rr,\n    int reply) {\n  unsigned char *name = data;\n  int chunk_len, data_len;\n\n  while (data < end && (chunk_len = *data)) {\n    if (((unsigned char *) data)[0] & 0xc0) {\n      data += 1;\n      break;\n    }\n    data += chunk_len + 1;\n  }\n\n  if (data > end - 5) {\n    return NULL;\n  }\n\n  rr->name.p = (char *) name;\n  rr->name.len = data - name + 1;\n  data++;\n\n  rr->rtype = data[0] << 8 | data[1];\n  data += 2;\n\n  rr->rclass = data[0] << 8 | data[1];\n  data += 2;\n\n  rr->kind = reply ? MG_DNS_ANSWER : MG_DNS_QUESTION;\n  if (reply) {\n    if (data >= end - 6) {\n      return NULL;\n    }\n\n    rr->ttl = (uint32_t) data[0] << 24 | (uint32_t) data[1] << 16 |\n              data[2] << 8 | data[3];\n    data += 4;\n\n    data_len = *data << 8 | *(data + 1);\n    data += 2;\n\n    rr->rdata.p = (char *) data;\n    rr->rdata.len = data_len;\n    data += data_len;\n  }\n  return data;\n}\n\nint mg_parse_dns(const char *buf, int len, struct mg_dns_message *msg) {\n  struct mg_dns_header *header = (struct mg_dns_header *) buf;\n  unsigned char *data = (unsigned char *) buf + sizeof(*header);\n  unsigned char *end = (unsigned char *) buf + len;\n  int i;\n\n  memset(msg, 0, sizeof(*msg));\n  msg->pkt.p = buf;\n  msg->pkt.len = len;\n\n  if (len < (int) sizeof(*header)) return -1;\n\n  msg->transaction_id = header->transaction_id;\n  msg->flags = ntohs(header->flags);\n  msg->num_questions = ntohs(header->num_questions);\n  if (msg->num_questions > (int) ARRAY_SIZE(msg->questions)) {\n    msg->num_questions = (int) ARRAY_SIZE(msg->questions);\n  }\n  msg->num_answers = ntohs(header->num_answers);\n  if (msg->num_answers > (int) ARRAY_SIZE(msg->answers)) {\n    msg->num_answers = (int) ARRAY_SIZE(msg->answers);\n  }\n\n  for (i = 0; i < msg->num_questions; i++) {\n    data = mg_parse_dns_resource_record(data, end, &msg->questions[i], 0);\n    if (data == NULL) return -1;\n  }\n\n  for (i = 0; i < msg->num_answers; i++) {\n    data = mg_parse_dns_resource_record(data, end, &msg->answers[i], 1);\n    if (data == NULL) return -1;\n  }\n\n  return 0;\n}\n\nsize_t mg_dns_uncompress_name(struct mg_dns_message *msg, struct mg_str *name,\n                              char *dst, int dst_len) {\n  int chunk_len;\n  char *old_dst = dst;\n  const unsigned char *data = (unsigned char *) name->p;\n  const unsigned char *end = (unsigned char *) msg->pkt.p + msg->pkt.len;\n\n  if (data >= end) {\n    return 0;\n  }\n\n  while ((chunk_len = *data++)) {\n    int leeway = dst_len - (dst - old_dst);\n    if (data >= end) {\n      return 0;\n    }\n\n    if (chunk_len & 0xc0) {\n      uint16_t off = (data[-1] & (~0xc0)) << 8 | data[0];\n      if (off >= msg->pkt.len) {\n        return 0;\n      }\n      data = (unsigned char *) msg->pkt.p + off;\n      continue;\n    }\n    if (chunk_len > leeway) {\n      chunk_len = leeway;\n    }\n\n    if (data + chunk_len >= end) {\n      return 0;\n    }\n\n    memcpy(dst, data, chunk_len);\n    data += chunk_len;\n    dst += chunk_len;\n    leeway -= chunk_len;\n    if (leeway == 0) {\n      return dst - old_dst;\n    }\n    *dst++ = '.';\n  }\n\n  if (dst != old_dst) {\n    *--dst = 0;\n  }\n  return dst - old_dst;\n}\n\nstatic void dns_handler(struct mg_connection *nc, int ev,\n                        void *ev_data MG_UD_ARG(void *user_data)) {\n  struct mbuf *io = &nc->recv_mbuf;\n  struct mg_dns_message msg;\n\n  /* Pass low-level events to the user handler */\n  nc->handler(nc, ev, ev_data MG_UD_ARG(user_data));\n\n  switch (ev) {\n    case MG_EV_RECV:\n      if (!(nc->flags & MG_F_UDP)) {\n        mbuf_remove(&nc->recv_mbuf, 2);\n      }\n      if (mg_parse_dns(nc->recv_mbuf.buf, nc->recv_mbuf.len, &msg) == -1) {\n        /* reply + recursion allowed + format error */\n        memset(&msg, 0, sizeof(msg));\n        msg.flags = 0x8081;\n        mg_dns_insert_header(io, 0, &msg);\n        if (!(nc->flags & MG_F_UDP)) {\n          uint16_t len = htons((uint16_t) io->len);\n          mbuf_insert(io, 0, &len, 2);\n        }\n        mg_send(nc, io->buf, io->len);\n      } else {\n        /* Call user handler with parsed message */\n        nc->handler(nc, MG_DNS_MESSAGE, &msg MG_UD_ARG(user_data));\n      }\n      mbuf_remove(io, io->len);\n      break;\n  }\n}\n\nvoid mg_set_protocol_dns(struct mg_connection *nc) {\n  nc->proto_handler = dns_handler;\n}\n\n#endif /* MG_ENABLE_DNS */\n#ifdef MG_MODULE_LINES\n#line 1 \"mongoose/src/dns_server.c\"\n#endif\n/*\n * Copyright (c) 2014 Cesanta Software Limited\n * All rights reserved\n */\n\n#if MG_ENABLE_DNS_SERVER\n\n/* Amalgamated: #include \"mongoose/src/internal.h\" */\n/* Amalgamated: #include \"mongoose/src/dns-server.h\" */\n\nstruct mg_dns_reply mg_dns_create_reply(struct mbuf *io,\n                                        struct mg_dns_message *msg) {\n  struct mg_dns_reply rep;\n  rep.msg = msg;\n  rep.io = io;\n  rep.start = io->len;\n\n  /* reply + recursion allowed */\n  msg->flags |= 0x8080;\n  mg_dns_copy_questions(io, msg);\n\n  msg->num_answers = 0;\n  return rep;\n}\n\nvoid mg_dns_send_reply(struct mg_connection *nc, struct mg_dns_reply *r) {\n  size_t sent = r->io->len - r->start;\n  mg_dns_insert_header(r->io, r->start, r->msg);\n  if (!(nc->flags & MG_F_UDP)) {\n    uint16_t len = htons((uint16_t) sent);\n    mbuf_insert(r->io, r->start, &len, 2);\n  }\n\n  if (&nc->send_mbuf != r->io) {\n    mg_send(nc, r->io->buf + r->start, r->io->len - r->start);\n    r->io->len = r->start;\n  }\n}\n\nint mg_dns_reply_record(struct mg_dns_reply *reply,\n                        struct mg_dns_resource_record *question,\n                        const char *name, int rtype, int ttl, const void *rdata,\n                        size_t rdata_len) {\n  struct mg_dns_message *msg = (struct mg_dns_message *) reply->msg;\n  char rname[512];\n  struct mg_dns_resource_record *ans = &msg->answers[msg->num_answers];\n  if (msg->num_answers >= MG_MAX_DNS_ANSWERS) {\n    return -1; /* LCOV_EXCL_LINE */\n  }\n\n  if (name == NULL) {\n    name = rname;\n    rname[511] = 0;\n    mg_dns_uncompress_name(msg, &question->name, rname, sizeof(rname) - 1);\n  }\n\n  *ans = *question;\n  ans->kind = MG_DNS_ANSWER;\n  ans->rtype = rtype;\n  ans->ttl = ttl;\n\n  if (mg_dns_encode_record(reply->io, ans, name, strlen(name), rdata,\n                           rdata_len) == -1) {\n    return -1; /* LCOV_EXCL_LINE */\n  };\n\n  msg->num_answers++;\n  return 0;\n}\n\n#endif /* MG_ENABLE_DNS_SERVER */\n#ifdef MG_MODULE_LINES\n#line 1 \"mongoose/src/resolv.c\"\n#endif\n/*\n * Copyright (c) 2014 Cesanta Software Limited\n * All rights reserved\n */\n\n#if MG_ENABLE_ASYNC_RESOLVER\n\n/* Amalgamated: #include \"mongoose/src/internal.h\" */\n/* Amalgamated: #include \"mongoose/src/resolv.h\" */\n\n#ifndef MG_DEFAULT_NAMESERVER\n#define MG_DEFAULT_NAMESERVER \"8.8.8.8\"\n#endif\n\nstruct mg_resolve_async_request {\n  char name[1024];\n  int query;\n  mg_resolve_callback_t callback;\n  void *data;\n  time_t timeout;\n  int max_retries;\n  enum mg_resolve_err err;\n\n  /* state */\n  time_t last_time;\n  int retries;\n};\n\n/*\n * Find what nameserver to use.\n *\n * Return 0 if OK, -1 if error\n */\nstatic int mg_get_ip_address_of_nameserver(char *name, size_t name_len) {\n  int ret = -1;\n\n#ifdef _WIN32\n  int i;\n  LONG err;\n  HKEY hKey, hSub;\n  wchar_t subkey[512], value[128],\n      *key = L\"SYSTEM\\\\ControlSet001\\\\Services\\\\Tcpip\\\\Parameters\\\\Interfaces\";\n\n  if ((err = RegOpenKeyExW(HKEY_LOCAL_MACHINE, key, 0, KEY_READ, &hKey)) !=\n      ERROR_SUCCESS) {\n    fprintf(stderr, \"cannot open reg key %S: %ld\\n\", key, err);\n    ret = -1;\n  } else {\n    for (ret = -1, i = 0; 1; i++) {\n      DWORD subkey_size = sizeof(subkey), type, len = sizeof(value);\n      if (RegEnumKeyExW(hKey, i, subkey, &subkey_size, NULL, NULL, NULL,\n                        NULL) != ERROR_SUCCESS) {\n        break;\n      }\n      if (RegOpenKeyExW(hKey, subkey, 0, KEY_READ, &hSub) == ERROR_SUCCESS &&\n          (RegQueryValueExW(hSub, L\"NameServer\", 0, &type, (void *) value,\n                            &len) == ERROR_SUCCESS ||\n           RegQueryValueExW(hSub, L\"DhcpNameServer\", 0, &type, (void *) value,\n                            &len) == ERROR_SUCCESS)) {\n        /*\n         * See https://github.com/cesanta/mongoose/issues/176\n         * The value taken from the registry can be empty, a single\n         * IP address, or multiple IP addresses separated by comma.\n         * If it's empty, check the next interface.\n         * If it's multiple IP addresses, take the first one.\n         */\n        wchar_t *comma = wcschr(value, ',');\n        if (value[0] == '\\0') {\n          continue;\n        }\n        if (comma != NULL) {\n          *comma = '\\0';\n        }\n        /* %S will convert wchar_t -> char */\n        snprintf(name, name_len, \"%S\", value);\n        ret = 0;\n        RegCloseKey(hSub);\n        break;\n      }\n    }\n    RegCloseKey(hKey);\n  }\n#elif MG_ENABLE_FILESYSTEM\n  FILE *fp;\n  char line[512];\n\n  if ((fp = mg_fopen(\"/etc/resolv.conf\", \"r\")) == NULL) {\n    ret = -1;\n  } else {\n    /* Try to figure out what nameserver to use */\n    for (ret = -1; fgets(line, sizeof(line), fp) != NULL;) {\n      unsigned int a, b, c, d;\n      if (sscanf(line, \"nameserver %u.%u.%u.%u\", &a, &b, &c, &d) == 4) {\n        snprintf(name, name_len, \"%u.%u.%u.%u\", a, b, c, d);\n        ret = 0;\n        break;\n      }\n    }\n    (void) fclose(fp);\n  }\n#else\n  snprintf(name, name_len, \"%s\", MG_DEFAULT_NAMESERVER);\n#endif /* _WIN32 */\n\n  return ret;\n}\n\nint mg_resolve_from_hosts_file(const char *name, union socket_address *usa) {\n#if MG_ENABLE_FILESYSTEM\n  /* TODO(mkm) cache /etc/hosts */\n  FILE *fp;\n  char line[1024];\n  char *p;\n  char alias[256];\n  unsigned int a, b, c, d;\n  int len = 0;\n\n  if ((fp = mg_fopen(\"/etc/hosts\", \"r\")) == NULL) {\n    return -1;\n  }\n\n  for (; fgets(line, sizeof(line), fp) != NULL;) {\n    if (line[0] == '#') continue;\n\n    if (sscanf(line, \"%u.%u.%u.%u%n\", &a, &b, &c, &d, &len) == 0) {\n      /* TODO(mkm): handle ipv6 */\n      continue;\n    }\n    for (p = line + len; sscanf(p, \"%s%n\", alias, &len) == 1; p += len) {\n      if (strcmp(alias, name) == 0) {\n        usa->sin.sin_addr.s_addr = htonl(a << 24 | b << 16 | c << 8 | d);\n        fclose(fp);\n        return 0;\n      }\n    }\n  }\n\n  fclose(fp);\n#else\n  (void) name;\n  (void) usa;\n#endif\n\n  return -1;\n}\n\nstatic void mg_resolve_async_eh(struct mg_connection *nc, int ev,\n                                void *data MG_UD_ARG(void *user_data)) {\n  time_t now = (time_t) mg_time();\n  struct mg_resolve_async_request *req;\n  struct mg_dns_message *msg;\n  int first = 0;\n#if !MG_ENABLE_CALLBACK_USERDATA\n  void *user_data = nc->user_data;\n#endif\n\n  if (ev != MG_EV_POLL) DBG((\"ev=%d user_data=%p\", ev, user_data));\n\n  req = (struct mg_resolve_async_request *) user_data;\n\n  if (req == NULL) {\n    return;\n  }\n\n  switch (ev) {\n    case MG_EV_CONNECT:\n      /* don't depend on timer not being at epoch for sending out first req */\n      first = 1;\n    /* fallthrough */\n    case MG_EV_POLL:\n      if (req->retries > req->max_retries) {\n        req->err = MG_RESOLVE_EXCEEDED_RETRY_COUNT;\n        nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n        break;\n      }\n      if (first || now - req->last_time >= req->timeout) {\n        mg_send_dns_query(nc, req->name, req->query);\n        req->last_time = now;\n        req->retries++;\n      }\n      break;\n    case MG_EV_RECV:\n      msg = (struct mg_dns_message *) MG_MALLOC(sizeof(*msg));\n      if (mg_parse_dns(nc->recv_mbuf.buf, *(int *) data, msg) == 0 &&\n          msg->num_answers > 0) {\n        req->callback(msg, req->data, MG_RESOLVE_OK);\n        nc->user_data = NULL;\n        MG_FREE(req);\n      } else {\n        req->err = MG_RESOLVE_NO_ANSWERS;\n      }\n      MG_FREE(msg);\n      nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n      break;\n    case MG_EV_SEND:\n      /*\n       * If a send error occurs, prevent closing of the connection by the core.\n       * We will retry after timeout.\n       */\n      nc->flags &= ~MG_F_CLOSE_IMMEDIATELY;\n      mbuf_remove(&nc->send_mbuf, nc->send_mbuf.len);\n      break;\n    case MG_EV_TIMER:\n      req->err = MG_RESOLVE_TIMEOUT;\n      nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n      break;\n    case MG_EV_CLOSE:\n      /* If we got here with request still not done, fire an error callback. */\n      if (req != NULL) {\n        req->callback(NULL, req->data, req->err);\n        nc->user_data = NULL;\n        MG_FREE(req);\n      }\n      break;\n  }\n}\n\nint mg_resolve_async(struct mg_mgr *mgr, const char *name, int query,\n                     mg_resolve_callback_t cb, void *data) {\n  struct mg_resolve_async_opts opts;\n  memset(&opts, 0, sizeof(opts));\n  return mg_resolve_async_opt(mgr, name, query, cb, data, opts);\n}\n\nint mg_resolve_async_opt(struct mg_mgr *mgr, const char *name, int query,\n                         mg_resolve_callback_t cb, void *data,\n                         struct mg_resolve_async_opts opts) {\n  struct mg_resolve_async_request *req;\n  struct mg_connection *dns_nc;\n  const char *nameserver = opts.nameserver;\n  char dns_server_buff[17], nameserver_url[26];\n\n  if (nameserver == NULL) {\n    nameserver = mgr->nameserver;\n  }\n\n  DBG((\"%s %d %p\", name, query, opts.dns_conn));\n\n  /* resolve with DNS */\n  req = (struct mg_resolve_async_request *) MG_CALLOC(1, sizeof(*req));\n  if (req == NULL) {\n    return -1;\n  }\n\n  strncpy(req->name, name, sizeof(req->name));\n  req->query = query;\n  req->callback = cb;\n  req->data = data;\n  /* TODO(mkm): parse defaults out of resolve.conf */\n  req->max_retries = opts.max_retries ? opts.max_retries : 2;\n  req->timeout = opts.timeout ? opts.timeout : 5;\n\n  /* Lazily initialize dns server */\n  if (nameserver == NULL) {\n    if (mg_get_ip_address_of_nameserver(dns_server_buff,\n                                        sizeof(dns_server_buff)) != -1) {\n      nameserver = dns_server_buff;\n    } else {\n      nameserver = MG_DEFAULT_NAMESERVER;\n    }\n  }\n\n  snprintf(nameserver_url, sizeof(nameserver_url), \"udp://%s:53\", nameserver);\n\n  dns_nc = mg_connect(mgr, nameserver_url, MG_CB(mg_resolve_async_eh, NULL));\n  if (dns_nc == NULL) {\n    MG_FREE(req);\n    return -1;\n  }\n  dns_nc->user_data = req;\n  if (opts.dns_conn != NULL) {\n    *opts.dns_conn = dns_nc;\n  }\n\n  return 0;\n}\n\nvoid mg_set_nameserver(struct mg_mgr *mgr, const char *nameserver) {\n  MG_FREE((char *) mgr->nameserver);\n  if (nameserver != NULL) {\n    mgr->nameserver = strdup(nameserver);\n  }\n}\n\n#endif /* MG_ENABLE_ASYNC_RESOLVER */\n#ifdef MG_MODULE_LINES\n#line 1 \"mongoose/src/coap.c\"\n#endif\n/*\n * Copyright (c) 2015 Cesanta Software Limited\n * All rights reserved\n * This software is dual-licensed: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation. For the terms of this\n * license, see <http://www.gnu.org/licenses/>.\n *\n * You are free to use this software under the terms of the GNU General\n * Public License, but WITHOUT ANY WARRANTY; without even the implied\n * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License for more details.\n *\n * Alternatively, you can license this software under a commercial\n * license, as set out in <https://www.cesanta.com/license>.\n */\n\n/* Amalgamated: #include \"mongoose/src/internal.h\" */\n/* Amalgamated: #include \"mongoose/src/coap.h\" */\n\n#if MG_ENABLE_COAP\n\nvoid mg_coap_free_options(struct mg_coap_message *cm) {\n  while (cm->options != NULL) {\n    struct mg_coap_option *next = cm->options->next;\n    MG_FREE(cm->options);\n    cm->options = next;\n  }\n}\n\nstruct mg_coap_option *mg_coap_add_option(struct mg_coap_message *cm,\n                                          uint32_t number, char *value,\n                                          size_t len) {\n  struct mg_coap_option *new_option =\n      (struct mg_coap_option *) MG_CALLOC(1, sizeof(*new_option));\n\n  new_option->number = number;\n  new_option->value.p = value;\n  new_option->value.len = len;\n\n  if (cm->options == NULL) {\n    cm->options = cm->optiomg_tail = new_option;\n  } else {\n    /*\n     * A very simple attention to help clients to compose options:\n     * CoAP wants to see options ASC ordered.\n     * Could be change by using sort in coap_compose\n     */\n    if (cm->optiomg_tail->number <= new_option->number) {\n      /* if option is already ordered just add it */\n      cm->optiomg_tail = cm->optiomg_tail->next = new_option;\n    } else {\n      /* looking for appropriate position */\n      struct mg_coap_option *current_opt = cm->options;\n      struct mg_coap_option *prev_opt = 0;\n\n      while (current_opt != NULL) {\n        if (current_opt->number > new_option->number) {\n          break;\n        }\n        prev_opt = current_opt;\n        current_opt = current_opt->next;\n      }\n\n      if (prev_opt != NULL) {\n        prev_opt->next = new_option;\n        new_option->next = current_opt;\n      } else {\n        /* insert new_option to the beginning */\n        new_option->next = cm->options;\n        cm->options = new_option;\n      }\n    }\n  }\n\n  return new_option;\n}\n\n/*\n * Fills CoAP header in mg_coap_message.\n *\n * Helper function.\n */\nstatic char *coap_parse_header(char *ptr, struct mbuf *io,\n                               struct mg_coap_message *cm) {\n  if (io->len < sizeof(uint32_t)) {\n    cm->flags |= MG_COAP_NOT_ENOUGH_DATA;\n    return NULL;\n  }\n\n  /*\n   * Version (Ver):  2-bit unsigned integer.  Indicates the CoAP version\n   * number.  Implementations of this specification MUST set this field\n   * to 1 (01 binary).  Other values are reserved for future versions.\n   * Messages with unknown version numbers MUST be silently ignored.\n   */\n  if (((uint8_t) *ptr >> 6) != 1) {\n    cm->flags |= MG_COAP_IGNORE;\n    return NULL;\n  }\n\n  /*\n   * Type (T):  2-bit unsigned integer.  Indicates if this message is of\n   * type Confirmable (0), Non-confirmable (1), Acknowledgement (2), or\n   * Reset (3).\n   */\n  cm->msg_type = ((uint8_t) *ptr & 0x30) >> 4;\n  cm->flags |= MG_COAP_MSG_TYPE_FIELD;\n\n  /*\n   * Token Length (TKL):  4-bit unsigned integer.  Indicates the length of\n   * the variable-length Token field (0-8 bytes).  Lengths 9-15 are\n   * reserved, MUST NOT be sent, and MUST be processed as a message\n   * format error.\n   */\n  cm->token.len = *ptr & 0x0F;\n  if (cm->token.len > 8) {\n    cm->flags |= MG_COAP_FORMAT_ERROR;\n    return NULL;\n  }\n\n  ptr++;\n\n  /*\n   * Code:  8-bit unsigned integer, split into a 3-bit class (most\n   * significant bits) and a 5-bit detail (least significant bits)\n   */\n  cm->code_class = (uint8_t) *ptr >> 5;\n  cm->code_detail = *ptr & 0x1F;\n  cm->flags |= (MG_COAP_CODE_CLASS_FIELD | MG_COAP_CODE_DETAIL_FIELD);\n\n  ptr++;\n\n  /* Message ID:  16-bit unsigned integer in network byte order. */\n  cm->msg_id = (uint8_t) *ptr << 8 | (uint8_t) * (ptr + 1);\n  cm->flags |= MG_COAP_MSG_ID_FIELD;\n\n  ptr += 2;\n\n  return ptr;\n}\n\n/*\n * Fills token information in mg_coap_message.\n *\n * Helper function.\n */\nstatic char *coap_get_token(char *ptr, struct mbuf *io,\n                            struct mg_coap_message *cm) {\n  if (cm->token.len != 0) {\n    if (ptr + cm->token.len > io->buf + io->len) {\n      cm->flags |= MG_COAP_NOT_ENOUGH_DATA;\n      return NULL;\n    } else {\n      cm->token.p = ptr;\n      ptr += cm->token.len;\n      cm->flags |= MG_COAP_TOKEN_FIELD;\n    }\n  }\n\n  return ptr;\n}\n\n/*\n * Returns Option Delta or Length.\n *\n * Helper function.\n */\nstatic int coap_get_ext_opt(char *ptr, struct mbuf *io, uint16_t *opt_info) {\n  int ret = 0;\n\n  if (*opt_info == 13) {\n    /*\n     * 13:  An 8-bit unsigned integer follows the initial byte and\n     * indicates the Option Delta/Length minus 13.\n     */\n    if (ptr < io->buf + io->len) {\n      *opt_info = (uint8_t) *ptr + 13;\n      ret = sizeof(uint8_t);\n    } else {\n      ret = -1; /* LCOV_EXCL_LINE */\n    }\n  } else if (*opt_info == 14) {\n    /*\n     * 14:  A 16-bit unsigned integer in network byte order follows the\n     * initial byte and indicates the Option Delta/Length minus 269.\n     */\n    if (ptr + sizeof(uint8_t) < io->buf + io->len) {\n      *opt_info = ((uint8_t) *ptr << 8 | (uint8_t) * (ptr + 1)) + 269;\n      ret = sizeof(uint16_t);\n    } else {\n      ret = -1; /* LCOV_EXCL_LINE */\n    }\n  }\n\n  return ret;\n}\n\n/*\n * Fills options in mg_coap_message.\n *\n * Helper function.\n *\n * General options format:\n * +---------------+---------------+\n * | Option Delta  | Option Length |  1 byte\n * +---------------+---------------+\n * \\    Option Delta (extended)    \\  0-2 bytes\n * +-------------------------------+\n * / Option Length  (extended)     \\  0-2 bytes\n * +-------------------------------+\n * \\         Option Value          \\  0 or more bytes\n * +-------------------------------+\n */\nstatic char *coap_get_options(char *ptr, struct mbuf *io,\n                              struct mg_coap_message *cm) {\n  uint16_t prev_opt = 0;\n\n  if (ptr == io->buf + io->len) {\n    /* end of packet, ok */\n    return NULL;\n  }\n\n  /* 0xFF is payload marker */\n  while (ptr < io->buf + io->len && (uint8_t) *ptr != 0xFF) {\n    uint16_t option_delta, option_lenght;\n    int optinfo_len;\n\n    /* Option Delta:  4-bit unsigned integer */\n    option_delta = ((uint8_t) *ptr & 0xF0) >> 4;\n    /* Option Length:  4-bit unsigned integer */\n    option_lenght = *ptr & 0x0F;\n\n    if (option_delta == 15 || option_lenght == 15) {\n      /*\n       * 15:  Reserved for future use.  If the field is set to this value,\n       * it MUST be processed as a message format error\n       */\n      cm->flags |= MG_COAP_FORMAT_ERROR;\n      break;\n    }\n\n    ptr++;\n\n    /* check for extended option delta */\n    optinfo_len = coap_get_ext_opt(ptr, io, &option_delta);\n    if (optinfo_len == -1) {\n      cm->flags |= MG_COAP_NOT_ENOUGH_DATA; /* LCOV_EXCL_LINE */\n      break;                                /* LCOV_EXCL_LINE */\n    }\n\n    ptr += optinfo_len;\n\n    /* check or extended option lenght */\n    optinfo_len = coap_get_ext_opt(ptr, io, &option_lenght);\n    if (optinfo_len == -1) {\n      cm->flags |= MG_COAP_NOT_ENOUGH_DATA; /* LCOV_EXCL_LINE */\n      break;                                /* LCOV_EXCL_LINE */\n    }\n\n    ptr += optinfo_len;\n\n    /*\n     * Instead of specifying the Option Number directly, the instances MUST\n     * appear in order of their Option Numbers and a delta encoding is used\n     * between them.\n     */\n    option_delta += prev_opt;\n\n    mg_coap_add_option(cm, option_delta, ptr, option_lenght);\n\n    prev_opt = option_delta;\n\n    if (ptr + option_lenght > io->buf + io->len) {\n      cm->flags |= MG_COAP_NOT_ENOUGH_DATA; /* LCOV_EXCL_LINE */\n      break;                                /* LCOV_EXCL_LINE */\n    }\n\n    ptr += option_lenght;\n  }\n\n  if ((cm->flags & MG_COAP_ERROR) != 0) {\n    mg_coap_free_options(cm);\n    return NULL;\n  }\n\n  cm->flags |= MG_COAP_OPTIOMG_FIELD;\n\n  if (ptr == io->buf + io->len) {\n    /* end of packet, ok */\n    return NULL;\n  }\n\n  ptr++;\n\n  return ptr;\n}\n\nuint32_t mg_coap_parse(struct mbuf *io, struct mg_coap_message *cm) {\n  char *ptr;\n\n  memset(cm, 0, sizeof(*cm));\n\n  if ((ptr = coap_parse_header(io->buf, io, cm)) == NULL) {\n    return cm->flags;\n  }\n\n  if ((ptr = coap_get_token(ptr, io, cm)) == NULL) {\n    return cm->flags;\n  }\n\n  if ((ptr = coap_get_options(ptr, io, cm)) == NULL) {\n    return cm->flags;\n  }\n\n  /* the rest is payload */\n  cm->payload.len = io->len - (ptr - io->buf);\n  if (cm->payload.len != 0) {\n    cm->payload.p = ptr;\n    cm->flags |= MG_COAP_PAYLOAD_FIELD;\n  }\n\n  return cm->flags;\n}\n\n/*\n * Calculates extended size of given Opt Number/Length in coap message.\n *\n * Helper function.\n */\nstatic size_t coap_get_ext_opt_size(uint32_t value) {\n  int ret = 0;\n\n  if (value >= 13 && value <= 0xFF + 13) {\n    ret = sizeof(uint8_t);\n  } else if (value > 0xFF + 13 && value <= 0xFFFF + 269) {\n    ret = sizeof(uint16_t);\n  }\n\n  return ret;\n}\n\n/*\n * Splits given Opt Number/Length into base and ext values.\n *\n * Helper function.\n */\nstatic int coap_split_opt(uint32_t value, uint8_t *base, uint16_t *ext) {\n  int ret = 0;\n\n  if (value < 13) {\n    *base = value;\n  } else if (value >= 13 && value <= 0xFF + 13) {\n    *base = 13;\n    *ext = value - 13;\n    ret = sizeof(uint8_t);\n  } else if (value > 0xFF + 13 && value <= 0xFFFF + 269) {\n    *base = 14;\n    *ext = value - 269;\n    ret = sizeof(uint16_t);\n  }\n\n  return ret;\n}\n\n/*\n * Puts uint16_t (in network order) into given char stream.\n *\n * Helper function.\n */\nstatic char *coap_add_uint16(char *ptr, uint16_t val) {\n  *ptr = val >> 8;\n  ptr++;\n  *ptr = val & 0x00FF;\n  ptr++;\n  return ptr;\n}\n\n/*\n * Puts extended value of Opt Number/Length into given char stream.\n *\n * Helper function.\n */\nstatic char *coap_add_opt_info(char *ptr, uint16_t val, size_t len) {\n  if (len == sizeof(uint8_t)) {\n    *ptr = (char) val;\n    ptr++;\n  } else if (len == sizeof(uint16_t)) {\n    ptr = coap_add_uint16(ptr, val);\n  }\n\n  return ptr;\n}\n\n/*\n * Verifies given mg_coap_message and calculates message size for it.\n *\n * Helper function.\n */\nstatic uint32_t coap_calculate_packet_size(struct mg_coap_message *cm,\n                                           size_t *len) {\n  struct mg_coap_option *opt;\n  uint32_t prev_opt_number;\n\n  *len = 4; /* header */\n  if (cm->msg_type > MG_COAP_MSG_MAX) {\n    return MG_COAP_ERROR | MG_COAP_MSG_TYPE_FIELD;\n  }\n  if (cm->token.len > 8) {\n    return MG_COAP_ERROR | MG_COAP_TOKEN_FIELD;\n  }\n  if (cm->code_class > 7) {\n    return MG_COAP_ERROR | MG_COAP_CODE_CLASS_FIELD;\n  }\n  if (cm->code_detail > 31) {\n    return MG_COAP_ERROR | MG_COAP_CODE_DETAIL_FIELD;\n  }\n\n  *len += cm->token.len;\n  if (cm->payload.len != 0) {\n    *len += cm->payload.len + 1; /* ... + 1; add payload marker */\n  }\n\n  opt = cm->options;\n  prev_opt_number = 0;\n  while (opt != NULL) {\n    *len += 1; /* basic delta/length */\n    *len += coap_get_ext_opt_size(opt->number - prev_opt_number);\n    *len += coap_get_ext_opt_size((uint32_t) opt->value.len);\n    /*\n     * Current implementation performs check if\n     * option_number > previous option_number and produces an error\n     * TODO(alashkin): write design doc with limitations\n     * May be resorting is more suitable solution.\n     */\n    if ((opt->next != NULL && opt->number > opt->next->number) ||\n        opt->value.len > 0xFFFF + 269 ||\n        opt->number - prev_opt_number > 0xFFFF + 269) {\n      return MG_COAP_ERROR | MG_COAP_OPTIOMG_FIELD;\n    }\n    *len += opt->value.len;\n    prev_opt_number = opt->number;\n    opt = opt->next;\n  }\n\n  return 0;\n}\n\nuint32_t mg_coap_compose(struct mg_coap_message *cm, struct mbuf *io) {\n  struct mg_coap_option *opt;\n  uint32_t res, prev_opt_number;\n  size_t prev_io_len, packet_size;\n  char *ptr;\n\n  res = coap_calculate_packet_size(cm, &packet_size);\n  if (res != 0) {\n    return res;\n  }\n\n  /* saving previous lenght to handle non-empty mbuf */\n  prev_io_len = io->len;\n  mbuf_append(io, NULL, packet_size);\n  ptr = io->buf + prev_io_len;\n\n  /*\n   * since cm is verified, it is possible to use bits shift operator\n   * without additional zeroing of unused bits\n   */\n\n  /* ver: 2 bits, msg_type: 2 bits, toklen: 4 bits */\n  *ptr = (1 << 6) | (cm->msg_type << 4) | (uint8_t)(cm->token.len);\n  ptr++;\n\n  /* code class: 3 bits, code detail: 5 bits */\n  *ptr = (cm->code_class << 5) | (cm->code_detail);\n  ptr++;\n\n  ptr = coap_add_uint16(ptr, cm->msg_id);\n\n  if (cm->token.len != 0) {\n    memcpy(ptr, cm->token.p, cm->token.len);\n    ptr += cm->token.len;\n  }\n\n  opt = cm->options;\n  prev_opt_number = 0;\n  while (opt != NULL) {\n    uint8_t delta_base = 0, length_base = 0;\n    uint16_t delta_ext = 0, length_ext = 0;\n\n    size_t opt_delta_len =\n        coap_split_opt(opt->number - prev_opt_number, &delta_base, &delta_ext);\n    size_t opt_lenght_len =\n        coap_split_opt((uint32_t) opt->value.len, &length_base, &length_ext);\n\n    *ptr = (delta_base << 4) | length_base;\n    ptr++;\n\n    ptr = coap_add_opt_info(ptr, delta_ext, opt_delta_len);\n    ptr = coap_add_opt_info(ptr, length_ext, opt_lenght_len);\n\n    if (opt->value.len != 0) {\n      memcpy(ptr, opt->value.p, opt->value.len);\n      ptr += opt->value.len;\n    }\n\n    prev_opt_number = opt->number;\n    opt = opt->next;\n  }\n\n  if (cm->payload.len != 0) {\n    *ptr = (char) -1;\n    ptr++;\n    memcpy(ptr, cm->payload.p, cm->payload.len);\n  }\n\n  return 0;\n}\n\nuint32_t mg_coap_send_message(struct mg_connection *nc,\n                              struct mg_coap_message *cm) {\n  struct mbuf packet_out;\n  uint32_t compose_res;\n\n  mbuf_init(&packet_out, 0);\n  compose_res = mg_coap_compose(cm, &packet_out);\n  if (compose_res != 0) {\n    return compose_res; /* LCOV_EXCL_LINE */\n  }\n\n  mg_send(nc, packet_out.buf, (int) packet_out.len);\n  mbuf_free(&packet_out);\n\n  return 0;\n}\n\nuint32_t mg_coap_send_ack(struct mg_connection *nc, uint16_t msg_id) {\n  struct mg_coap_message cm;\n  memset(&cm, 0, sizeof(cm));\n  cm.msg_type = MG_COAP_MSG_ACK;\n  cm.msg_id = msg_id;\n\n  return mg_coap_send_message(nc, &cm);\n}\n\nstatic void coap_handler(struct mg_connection *nc, int ev,\n                         void *ev_data MG_UD_ARG(void *user_data)) {\n  struct mbuf *io = &nc->recv_mbuf;\n  struct mg_coap_message cm;\n  uint32_t parse_res;\n\n  memset(&cm, 0, sizeof(cm));\n\n  nc->handler(nc, ev, ev_data MG_UD_ARG(user_data));\n\n  switch (ev) {\n    case MG_EV_RECV:\n      parse_res = mg_coap_parse(io, &cm);\n      if ((parse_res & MG_COAP_IGNORE) == 0) {\n        if ((cm.flags & MG_COAP_NOT_ENOUGH_DATA) != 0) {\n          /*\n           * Since we support UDP only\n           * MG_COAP_NOT_ENOUGH_DATA == MG_COAP_FORMAT_ERROR\n           */\n          cm.flags |= MG_COAP_FORMAT_ERROR; /* LCOV_EXCL_LINE */\n        }                                   /* LCOV_EXCL_LINE */\n        nc->handler(nc, MG_COAP_EVENT_BASE + cm.msg_type,\n                    &cm MG_UD_ARG(user_data));\n      }\n\n      mg_coap_free_options(&cm);\n      mbuf_remove(io, io->len);\n      break;\n  }\n}\n/*\n * Attach built-in CoAP event handler to the given connection.\n *\n * The user-defined event handler will receive following extra events:\n *\n * - MG_EV_COAP_CON\n * - MG_EV_COAP_NOC\n * - MG_EV_COAP_ACK\n * - MG_EV_COAP_RST\n */\nint mg_set_protocol_coap(struct mg_connection *nc) {\n  /* supports UDP only */\n  if ((nc->flags & MG_F_UDP) == 0) {\n    return -1;\n  }\n\n  nc->proto_handler = coap_handler;\n\n  return 0;\n}\n\n#endif /* MG_ENABLE_COAP */\n#ifdef MG_MODULE_LINES\n#line 1 \"mongoose/src/tun.c\"\n#endif\n/*\n * Copyright (c) 2014 Cesanta Software Limited\n * All rights reserved\n */\n\n#if MG_ENABLE_TUN\n\n/* Amalgamated: #include \"common/cs_dbg.h\" */\n/* Amalgamated: #include \"mongoose/src/http.h\" */\n/* Amalgamated: #include \"mongoose/src/internal.h\" */\n/* Amalgamated: #include \"mongoose/src/net.h\" */\n/* Amalgamated: #include \"mongoose/src/net_if_tun.h\" */\n/* Amalgamated: #include \"mongoose/src/tun.h\" */\n/* Amalgamated: #include \"mongoose/src/util.h\" */\n\nstatic void mg_tun_reconnect(struct mg_tun_client *client, int timeout);\n\nstatic void mg_tun_init_client(struct mg_tun_client *client, struct mg_mgr *mgr,\n                               struct mg_iface *iface, const char *dispatcher,\n                               struct mg_tun_ssl_opts ssl) {\n  client->mgr = mgr;\n  client->iface = iface;\n  client->disp_url = dispatcher;\n  client->last_stream_id = 0;\n  client->ssl = ssl;\n\n  client->disp = NULL;      /* will be set by mg_tun_reconnect */\n  client->listener = NULL;  /* will be set by mg_do_bind */\n  client->reconnect = NULL; /* will be set by mg_tun_reconnect */\n}\n\nvoid mg_tun_log_frame(struct mg_tun_frame *frame) {\n  LOG(LL_DEBUG, (\"Got TUN frame: type=0x%x, flags=0x%x stream_id=0x%lx, \"\n                 \"len=%zu\",\n                 frame->type, frame->flags, frame->stream_id, frame->body.len));\n#if MG_ENABLE_HEXDUMP\n  {\n    char hex[512];\n    mg_hexdump(frame->body.p, frame->body.len, hex, sizeof(hex) - 1);\n    hex[sizeof(hex) - 1] = '\\0';\n    LOG(LL_DEBUG, (\"body:\\n%s\", hex));\n  }\n#else\n  LOG(LL_DEBUG, (\"body: '%.*s'\", (int) frame->body.len, frame->body.p));\n#endif\n}\n\nstatic void mg_tun_close_all(struct mg_tun_client *client) {\n  struct mg_connection *nc;\n  for (nc = client->mgr->active_connections; nc != NULL; nc = nc->next) {\n    if (nc->iface == client->iface && !(nc->flags & MG_F_LISTENING)) {\n      LOG(LL_DEBUG, (\"Closing tunneled connection %p\", nc));\n      nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n      /* mg_close_conn(nc); */\n    }\n  }\n}\n\nstatic void mg_tun_client_handler(struct mg_connection *nc, int ev,\n                                  void *ev_data MG_UD_ARG(void *user_data)) {\n#if !MG_ENABLE_CALLBACK_USERDATA\n  void *user_data = nc->user_data;\n#else\n  (void) nc;\n#endif\n  struct mg_tun_client *client = (struct mg_tun_client *) user_data;\n\n  switch (ev) {\n    case MG_EV_CONNECT: {\n      int err = *(int *) ev_data;\n\n      if (err) {\n        LOG(LL_ERROR, (\"Cannot connect to the tunnel dispatcher: %d\", err));\n      } else {\n        LOG(LL_INFO, (\"Connected to the tunnel dispatcher\"));\n      }\n      break;\n    }\n    case MG_EV_HTTP_REPLY: {\n      struct http_message *hm = (struct http_message *) ev_data;\n\n      if (hm->resp_code != 200) {\n        LOG(LL_ERROR,\n            (\"Tunnel dispatcher reply non-OK status code %d\", hm->resp_code));\n      }\n      break;\n    }\n    case MG_EV_WEBSOCKET_HANDSHAKE_DONE: {\n      LOG(LL_INFO, (\"Tunnel dispatcher handshake done\"));\n      break;\n    }\n    case MG_EV_WEBSOCKET_FRAME: {\n      struct websocket_message *wm = (struct websocket_message *) ev_data;\n      struct mg_connection *tc;\n      struct mg_tun_frame frame;\n\n      if (mg_tun_parse_frame(wm->data, wm->size, &frame) == -1) {\n        LOG(LL_ERROR, (\"Got invalid tun frame dropping\", wm->size));\n        break;\n      }\n\n      mg_tun_log_frame(&frame);\n\n      tc = mg_tun_if_find_conn(client, frame.stream_id);\n      if (tc == NULL) {\n        if (frame.body.len > 0) {\n          LOG(LL_DEBUG, (\"Got frame after receiving end has been closed\"));\n        }\n        break;\n      }\n      if (frame.body.len > 0) {\n        mg_if_recv_tcp_cb(tc, (void *) frame.body.p, frame.body.len,\n                          0 /* own */);\n      }\n      if (frame.flags & MG_TUN_F_END_STREAM) {\n        LOG(LL_DEBUG, (\"Closing tunneled connection because got end of stream \"\n                       \"from other end\"));\n        tc->flags |= MG_F_CLOSE_IMMEDIATELY;\n        mg_close_conn(tc);\n      }\n      break;\n    }\n    case MG_EV_CLOSE: {\n      LOG(LL_DEBUG, (\"Closing all tunneled connections\"));\n      /*\n       * The client might have been already freed when the listening socket is\n       * closed.\n       */\n      if (client != NULL) {\n        mg_tun_close_all(client);\n        client->disp = NULL;\n        LOG(LL_INFO, (\"Dispatcher connection is no more, reconnecting\"));\n        /* TODO(mkm): implement exp back off */\n        mg_tun_reconnect(client, MG_TUN_RECONNECT_INTERVAL);\n      }\n      break;\n    }\n    default:\n      break;\n  }\n}\n\nstatic void mg_tun_do_reconnect(struct mg_tun_client *client) {\n  struct mg_connection *dc;\n  struct mg_connect_opts opts;\n  memset(&opts, 0, sizeof(opts));\n#if MG_ENABLE_SSL\n  opts.ssl_cert = client->ssl.ssl_cert;\n  opts.ssl_key = client->ssl.ssl_key;\n  opts.ssl_ca_cert = client->ssl.ssl_ca_cert;\n#endif\n  /* HTTP/Websocket listener */\n  if ((dc = mg_connect_ws_opt(client->mgr, MG_CB(mg_tun_client_handler, client),\n                              opts, client->disp_url, MG_TUN_PROTO_NAME,\n                              NULL)) == NULL) {\n    LOG(LL_ERROR,\n        (\"Cannot connect to WS server on addr [%s]\\n\", client->disp_url));\n    return;\n  }\n\n  client->disp = dc;\n#if !MG_ENABLE_CALLBACK_USERDATA\n  dc->user_data = client;\n#endif\n}\n\nvoid mg_tun_reconnect_ev_handler(struct mg_connection *nc, int ev,\n                                 void *ev_data MG_UD_ARG(void *user_data)) {\n#if !MG_ENABLE_CALLBACK_USERDATA\n  void *user_data = nc->user_data;\n#else\n  (void) nc;\n#endif\n  struct mg_tun_client *client = (struct mg_tun_client *) user_data;\n  (void) ev_data;\n\n  switch (ev) {\n    case MG_EV_TIMER:\n      if (!(client->listener->flags & MG_F_TUN_DO_NOT_RECONNECT)) {\n        mg_tun_do_reconnect(client);\n      } else {\n        /* Reconnecting is suppressed, we'll check again at the next poll */\n        mg_tun_reconnect(client, 0);\n      }\n      break;\n  }\n}\n\nstatic void mg_tun_reconnect(struct mg_tun_client *client, int timeout) {\n  if (client->reconnect == NULL) {\n    client->reconnect = mg_add_sock(client->mgr, INVALID_SOCKET,\n                                    MG_CB(mg_tun_reconnect_ev_handler, client));\n#if !MG_ENABLE_CALLBACK_USERDATA\n    client->reconnect->user_data = client;\n#endif\n  }\n  client->reconnect->ev_timer_time = mg_time() + timeout;\n}\n\nstatic struct mg_tun_client *mg_tun_create_client(struct mg_mgr *mgr,\n                                                  const char *dispatcher,\n                                                  struct mg_tun_ssl_opts ssl) {\n  struct mg_tun_client *client = NULL;\n  struct mg_iface *iface = mg_find_iface(mgr, &mg_tun_iface_vtable, NULL);\n  if (iface == NULL) {\n    LOG(LL_ERROR, (\"The tun feature requires the manager to have a tun \"\n                   \"interface enabled\"));\n    return NULL;\n  }\n\n  client = (struct mg_tun_client *) MG_MALLOC(sizeof(*client));\n  mg_tun_init_client(client, mgr, iface, dispatcher, ssl);\n  iface->data = client;\n\n  /*\n   * We need to give application a chance to set MG_F_TUN_DO_NOT_RECONNECT on a\n   * listening connection right after mg_tun_bind_opt() returned it, so we\n   * should use mg_tun_reconnect() here, instead of mg_tun_do_reconnect()\n   */\n  mg_tun_reconnect(client, 0);\n  return client;\n}\n\nvoid mg_tun_destroy_client(struct mg_tun_client *client) {\n  /*\n   *  NOTE:\n   * `client` is NULL in case of OOM\n   * `client->disp` is NULL if connection failed\n   * `client->iface is NULL is `mg_find_iface` failed\n   */\n\n  if (client != NULL && client->disp != NULL) {\n    /* the dispatcher connection handler will in turn close all tunnels */\n    client->disp->flags |= MG_F_CLOSE_IMMEDIATELY;\n    /* this is used as a signal to other tun handlers that the party is over */\n    client->disp->user_data = NULL;\n  }\n\n  if (client != NULL && client->reconnect != NULL) {\n    client->reconnect->flags |= MG_F_CLOSE_IMMEDIATELY;\n  }\n\n  if (client != NULL && client->iface != NULL) {\n    client->iface->data = NULL;\n  }\n\n  MG_FREE(client);\n}\n\nstatic struct mg_connection *mg_tun_do_bind(struct mg_tun_client *client,\n                                            MG_CB(mg_event_handler_t handler,\n                                                  void *user_data),\n                                            struct mg_bind_opts opts) {\n  struct mg_connection *lc;\n  opts.iface = client->iface;\n  lc = mg_bind_opt(client->mgr, \":1234\" /* dummy port */,\n                   MG_CB(handler, user_data), opts);\n  client->listener = lc;\n  return lc;\n}\n\nstruct mg_connection *mg_tun_bind_opt(struct mg_mgr *mgr,\n                                      const char *dispatcher,\n                                      MG_CB(mg_event_handler_t handler,\n                                            void *user_data),\n                                      struct mg_bind_opts opts) {\n#if MG_ENABLE_SSL\n  struct mg_tun_ssl_opts ssl = {opts.ssl_cert, opts.ssl_key, opts.ssl_ca_cert};\n#else\n  struct mg_tun_ssl_opts ssl = {0};\n#endif\n  struct mg_tun_client *client = mg_tun_create_client(mgr, dispatcher, ssl);\n  if (client == NULL) {\n    return NULL;\n  }\n#if MG_ENABLE_SSL\n  /* these options don't make sense in the local mouth of the tunnel */\n  opts.ssl_cert = NULL;\n  opts.ssl_key = NULL;\n  opts.ssl_ca_cert = NULL;\n#endif\n  return mg_tun_do_bind(client, MG_CB(handler, user_data), opts);\n}\n\nint mg_tun_parse_frame(void *data, size_t len, struct mg_tun_frame *frame) {\n  const size_t header_size = sizeof(uint32_t) + sizeof(uint8_t) * 2;\n  if (len < header_size) {\n    return -1;\n  }\n\n  frame->type = *(uint8_t *) (data);\n  frame->flags = *(uint8_t *) ((char *) data + 1);\n  memcpy(&frame->stream_id, (char *) data + 2, sizeof(uint32_t));\n  frame->stream_id = ntohl(frame->stream_id);\n  frame->body.p = (char *) data + header_size;\n  frame->body.len = len - header_size;\n  return 0;\n}\n\nvoid mg_tun_send_frame(struct mg_connection *ws, uint32_t stream_id,\n                       uint8_t type, uint8_t flags, struct mg_str msg) {\n  stream_id = htonl(stream_id);\n  {\n    struct mg_str parts[] = {\n        {(char *) &type, sizeof(type)},\n        {(char *) &flags, sizeof(flags)},\n        {(char *) &stream_id, sizeof(stream_id)},\n        {msg.p, msg.len} /* vc6 doesn't like just `msg` here */};\n    mg_send_websocket_framev(ws, WEBSOCKET_OP_BINARY, parts,\n                             sizeof(parts) / sizeof(parts[0]));\n  }\n}\n\n#endif /* MG_ENABLE_TUN */\n#ifdef MG_MODULE_LINES\n#line 1 \"mongoose/src/sntp.c\"\n#endif\n/*\n * Copyright (c) 2016 Cesanta Software Limited\n * All rights reserved\n */\n\n/* Amalgamated: #include \"mongoose/src/internal.h\" */\n/* Amalgamated: #include \"mongoose/src/sntp.h\" */\n/* Amalgamated: #include \"mongoose/src/util.h\" */\n\n#if MG_ENABLE_SNTP\n\n#define SNTP_TIME_OFFSET 2208988800\n\n#ifndef SNTP_TIMEOUT\n#define SNTP_TIMEOUT 10\n#endif\n\n#ifndef SNTP_ATTEMPTS\n#define SNTP_ATTEMPTS 3\n#endif\n\nstatic uint64_t mg_get_sec(uint64_t val) {\n  return (val & 0xFFFFFFFF00000000) >> 32;\n}\n\nstatic uint64_t mg_get_usec(uint64_t val) {\n  uint64_t tmp = (val & 0x00000000FFFFFFFF);\n  tmp *= 1000000;\n  tmp >>= 32;\n  return tmp;\n}\n\nstatic void mg_ntp_to_tv(uint64_t val, struct timeval *tv) {\n  uint64_t tmp;\n  tmp = mg_get_sec(val);\n  tmp -= SNTP_TIME_OFFSET;\n  tv->tv_sec = tmp;\n  tv->tv_usec = mg_get_usec(val);\n}\n\nstatic void mg_get_ntp_ts(const char *ntp, uint64_t *val) {\n  uint32_t tmp;\n  memcpy(&tmp, ntp, sizeof(tmp));\n  tmp = ntohl(tmp);\n  *val = (uint64_t) tmp << 32;\n  memcpy(&tmp, ntp + 4, sizeof(tmp));\n  tmp = ntohl(tmp);\n  *val |= tmp;\n}\n\nvoid mg_sntp_send_request(struct mg_connection *c) {\n  char buf[48] = {0};\n  /*\n   * header - 8 bit:\n   * LI (2 bit) - 3 (not in sync), VN (3 bit) - 4 (version),\n   * mode (3 bit) - 3 (client)\n   */\n  buf[0] = (3 << 6) | (4 << 3) | 3;\n\n/*\n * Next fields should be empty in client request\n * stratum, 8 bit\n * poll interval, 8 bit\n * rrecision, 8 bit\n * root delay, 32 bit\n * root dispersion, 32 bit\n * ref id, 32 bit\n * ref timestamp, 64 bit\n * originate Timestamp, 64 bit\n * receive Timestamp, 64 bit\n*/\n\n/*\n * convert time to sntp format (sntp starts from 00:00:00 01.01.1900)\n * according to rfc868 it is 2208988800L sec\n * this information is used to correct roundtrip delay\n * but if local clock is absolutely broken (and doesn't work even\n * as simple timer), it is better to disable it\n*/\n#ifndef MG_SNMP_NO_DELAY_CORRECTION\n  uint32_t sec;\n  sec = htonl((uint32_t)(mg_time() + SNTP_TIME_OFFSET));\n  memcpy(&buf[40], &sec, sizeof(sec));\n#endif\n\n  mg_send(c, buf, sizeof(buf));\n}\n\n#ifndef MG_SNMP_NO_DELAY_CORRECTION\nstatic uint64_t mg_calculate_delay(uint64_t t1, uint64_t t2, uint64_t t3) {\n  /* roundloop delay = (T4 - T1) - (T3 - T2) */\n  uint64_t d1 = ((mg_time() + SNTP_TIME_OFFSET) * 1000000) -\n                (mg_get_sec(t1) * 1000000 + mg_get_usec(t1));\n  uint64_t d2 = (mg_get_sec(t3) * 1000000 + mg_get_usec(t3)) -\n                (mg_get_sec(t2) * 1000000 + mg_get_usec(t2));\n\n  return (d1 > d2) ? d1 - d2 : 0;\n}\n#endif\n\nMG_INTERNAL int mg_sntp_parse_reply(const char *buf, int len,\n                                    struct mg_sntp_message *msg) {\n  uint8_t hdr;\n  uint64_t orig_ts_T1, recv_ts_T2, trsm_ts_T3, delay = 0;\n  int mode;\n  struct timeval tv;\n\n  (void) orig_ts_T1;\n  (void) recv_ts_T2;\n  if (len < 48) {\n    return -1;\n  }\n\n  hdr = buf[0];\n\n  if ((hdr & 0x38) >> 3 != 4) {\n    /* Wrong version */\n    return -1;\n  }\n\n  mode = hdr & 0x7;\n  if (mode != 4 && mode != 5) {\n    /* Not a server reply */\n    return -1;\n  }\n\n  memset(msg, 0, sizeof(*msg));\n\n  msg->kiss_of_death = (buf[1] == 0); /* Server asks to not send requests */\n\n  mg_get_ntp_ts(&buf[40], &trsm_ts_T3);\n\n#ifndef MG_SNMP_NO_DELAY_CORRECTION\n  mg_get_ntp_ts(&buf[24], &orig_ts_T1);\n  mg_get_ntp_ts(&buf[32], &recv_ts_T2);\n  delay = mg_calculate_delay(orig_ts_T1, recv_ts_T2, trsm_ts_T3);\n#endif\n\n  mg_ntp_to_tv(trsm_ts_T3, &tv);\n\n  msg->time = (double) tv.tv_sec + (((double) tv.tv_usec + delay) / 1000000.0);\n\n  return 0;\n}\n\nstatic void mg_sntp_handler(struct mg_connection *c, int ev,\n                            void *ev_data MG_UD_ARG(void *user_data)) {\n  struct mbuf *io = &c->recv_mbuf;\n  struct mg_sntp_message msg;\n\n  c->handler(c, ev, ev_data MG_UD_ARG(user_data));\n\n  switch (ev) {\n    case MG_EV_RECV: {\n      if (mg_sntp_parse_reply(io->buf, io->len, &msg) < 0) {\n        DBG((\"Invalid SNTP packet received (%d)\", (int) io->len));\n        c->handler(c, MG_SNTP_MALFORMED_REPLY, NULL MG_UD_ARG(user_data));\n      } else {\n        c->handler(c, MG_SNTP_REPLY, (void *) &msg MG_UD_ARG(user_data));\n      }\n\n      mbuf_remove(io, io->len);\n      break;\n    }\n  }\n}\n\nint mg_set_protocol_sntp(struct mg_connection *c) {\n  if ((c->flags & MG_F_UDP) == 0) {\n    return -1;\n  }\n\n  c->proto_handler = mg_sntp_handler;\n\n  return 0;\n}\n\nstruct mg_connection *mg_sntp_connect(struct mg_mgr *mgr,\n                                      MG_CB(mg_event_handler_t event_handler,\n                                            void *user_data),\n                                      const char *sntp_server_name) {\n  struct mg_connection *c = NULL;\n  char url[100], *p_url = url;\n  const char *proto = \"\", *port = \"\", *tmp;\n\n  /* If port is not specified, use default (123) */\n  tmp = strchr(sntp_server_name, ':');\n  if (tmp != NULL && *(tmp + 1) == '/') {\n    tmp = strchr(tmp + 1, ':');\n  }\n\n  if (tmp == NULL) {\n    port = \":123\";\n  }\n\n  /* Add udp:// if needed */\n  if (strncmp(sntp_server_name, \"udp://\", 6) != 0) {\n    proto = \"udp://\";\n  }\n\n  mg_asprintf(&p_url, sizeof(url), \"%s%s%s\", proto, sntp_server_name, port);\n\n  c = mg_connect(mgr, p_url, event_handler MG_UD_ARG(user_data));\n\n  if (c == NULL) {\n    goto cleanup;\n  }\n\n  mg_set_protocol_sntp(c);\n\ncleanup:\n  if (p_url != url) {\n    MG_FREE(p_url);\n  }\n\n  return c;\n}\n\nstruct sntp_data {\n  mg_event_handler_t hander;\n  int count;\n};\n\nstatic void mg_sntp_util_ev_handler(struct mg_connection *c, int ev,\n                                    void *ev_data MG_UD_ARG(void *user_data)) {\n#if !MG_ENABLE_CALLBACK_USERDATA\n  void *user_data = c->user_data;\n#endif\n  struct sntp_data *sd = (struct sntp_data *) user_data;\n\n  switch (ev) {\n    case MG_EV_CONNECT:\n      if (*(int *) ev_data != 0) {\n        mg_call(c, sd->hander, c->user_data, MG_SNTP_FAILED, NULL);\n        break;\n      }\n    /* fallthrough */\n    case MG_EV_TIMER:\n      if (sd->count <= SNTP_ATTEMPTS) {\n        mg_sntp_send_request(c);\n        mg_set_timer(c, mg_time() + 10);\n        sd->count++;\n      } else {\n        mg_call(c, sd->hander, c->user_data, MG_SNTP_FAILED, NULL);\n        c->flags |= MG_F_CLOSE_IMMEDIATELY;\n      }\n      break;\n    case MG_SNTP_MALFORMED_REPLY:\n      mg_call(c, sd->hander, c->user_data, MG_SNTP_FAILED, NULL);\n      c->flags |= MG_F_CLOSE_IMMEDIATELY;\n      break;\n    case MG_SNTP_REPLY:\n      mg_call(c, sd->hander, c->user_data, MG_SNTP_REPLY, ev_data);\n      c->flags |= MG_F_CLOSE_IMMEDIATELY;\n      break;\n    case MG_EV_CLOSE:\n      MG_FREE(user_data);\n      c->user_data = NULL;\n      break;\n  }\n}\n\nstruct mg_connection *mg_sntp_get_time(struct mg_mgr *mgr,\n                                       mg_event_handler_t event_handler,\n                                       const char *sntp_server_name) {\n  struct mg_connection *c;\n  struct sntp_data *sd = (struct sntp_data *) MG_CALLOC(1, sizeof(*sd));\n  if (sd == NULL) {\n    return NULL;\n  }\n\n  c = mg_sntp_connect(mgr, MG_CB(mg_sntp_util_ev_handler, sd),\n                      sntp_server_name);\n  if (c == NULL) {\n    MG_FREE(sd);\n    return NULL;\n  }\n\n  sd->hander = event_handler;\n#if !MG_ENABLE_CALLBACK_USERDATA\n  c->user_data = sd;\n#endif\n\n  return c;\n}\n\n#endif /* MG_ENABLE_SNTP */\n#ifdef MG_MODULE_LINES\n#line 1 \"common/platforms/cc3200/cc3200_libc.c\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#if CS_PLATFORM == CS_P_CC3200\n\n/* Amalgamated: #include \"common/mg_mem.h\" */\n#include <stdio.h>\n#include <string.h>\n\n#ifndef __TI_COMPILER_VERSION__\n#include <reent.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <unistd.h>\n#endif\n\n#include <inc/hw_types.h>\n#include <inc/hw_memmap.h>\n#include <driverlib/prcm.h>\n#include <driverlib/rom.h>\n#include <driverlib/rom_map.h>\n#include <driverlib/uart.h>\n#include <driverlib/utils.h>\n\n#define CONSOLE_UART UARTA0_BASE\n\n#ifdef __TI_COMPILER_VERSION__\nint asprintf(char **strp, const char *fmt, ...) {\n  va_list ap;\n  int len;\n\n  *strp = MG_MALLOC(BUFSIZ);\n  if (*strp == NULL) return -1;\n\n  va_start(ap, fmt);\n  len = vsnprintf(*strp, BUFSIZ, fmt, ap);\n  va_end(ap);\n\n  if (len > 0) {\n    *strp = MG_REALLOC(*strp, len + 1);\n    if (*strp == NULL) return -1;\n  }\n\n  if (len >= BUFSIZ) {\n    va_start(ap, fmt);\n    len = vsnprintf(*strp, len + 1, fmt, ap);\n    va_end(ap);\n  }\n\n  return len;\n}\n\n#if MG_TI_NO_HOST_INTERFACE\ntime_t HOSTtime() {\n  struct timeval tp;\n  gettimeofday(&tp, NULL);\n  return tp.tv_sec;\n}\n#endif\n\n#endif /* __TI_COMPILER_VERSION__ */\n\n#ifndef __TI_COMPILER_VERSION__\nint _gettimeofday_r(struct _reent *r, struct timeval *tp, void *tzp) {\n#else\nint gettimeofday(struct timeval *tp, void *tzp) {\n#endif\n  unsigned long long r1 = 0, r2;\n  /* Achieve two consecutive reads of the same value. */\n  do {\n    r2 = r1;\n    r1 = PRCMSlowClkCtrFastGet();\n  } while (r1 != r2);\n  /* This is a 32768 Hz counter. */\n  tp->tv_sec = (r1 >> 15);\n  /* 1/32768-th of a second is 30.517578125 microseconds, approx. 31,\n   * but we round down so it doesn't overflow at 32767 */\n  tp->tv_usec = (r1 & 0x7FFF) * 30;\n  return 0;\n}\n\nvoid fprint_str(FILE *fp, const char *str) {\n  while (*str != '\\0') {\n    if (*str == '\\n') MAP_UARTCharPut(CONSOLE_UART, '\\r');\n    MAP_UARTCharPut(CONSOLE_UART, *str++);\n  }\n}\n\nvoid _exit(int status) {\n  fprint_str(stderr, \"_exit\\n\");\n  /* cause an unaligned access exception, that will drop you into gdb */\n  *(int *) 1 = status;\n  while (1)\n    ; /* avoid gcc warning because stdlib abort() has noreturn attribute */\n}\n\nvoid _not_implemented(const char *what) {\n  fprint_str(stderr, what);\n  fprint_str(stderr, \" is not implemented\\n\");\n  _exit(42);\n}\n\nint _kill(int pid, int sig) {\n  (void) pid;\n  (void) sig;\n  _not_implemented(\"_kill\");\n  return -1;\n}\n\nint _getpid() {\n  fprint_str(stderr, \"_getpid is not implemented\\n\");\n  return 42;\n}\n\nint _isatty(int fd) {\n  /* 0, 1 and 2 are TTYs. */\n  return fd < 2;\n}\n\n#endif /* CS_PLATFORM == CS_P_CC3200 */\n#ifdef MG_MODULE_LINES\n#line 1 \"common/platforms/msp432/msp432_libc.c\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#if CS_PLATFORM == CS_P_MSP432\n\n#include <ti/sysbios/BIOS.h>\n#include <ti/sysbios/knl/Clock.h>\n\nint gettimeofday(struct timeval *tp, void *tzp) {\n  uint32_t ticks = Clock_getTicks();\n  tp->tv_sec = ticks / 1000;\n  tp->tv_usec = (ticks % 1000) * 1000;\n  return 0;\n}\n\n#endif /* CS_PLATFORM == CS_P_MSP432 */\n#ifdef MG_MODULE_LINES\n#line 1 \"common/platforms/nrf5/nrf5_libc.c\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#if (CS_PLATFORM == CS_P_NRF51 || CS_PLATFORM == CS_P_NRF52) && \\\n    defined(__ARMCC_VERSION)\nint gettimeofday(struct timeval *tp, void *tzp) {\n  /* TODO */\n  tp->tv_sec = 0;\n  tp->tv_usec = 0;\n  return 0;\n}\n#endif\n#ifdef MG_MODULE_LINES\n#line 1 \"common/platforms/simplelink/sl_fs_slfs.h\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#ifndef CS_COMMON_PLATFORMS_SIMPLELINK_SL_FS_SLFS_H_\n#define CS_COMMON_PLATFORMS_SIMPLELINK_SL_FS_SLFS_H_\n\n#if defined(MG_FS_SLFS)\n\n#include <stdio.h>\n#ifndef __TI_COMPILER_VERSION__\n#include <unistd.h>\n#include <sys/stat.h>\n#endif\n\n#define MAX_OPEN_SLFS_FILES 8\n\n/* Indirect libc interface - same functions, different names. */\nint fs_slfs_open(const char *pathname, int flags, mode_t mode);\nint fs_slfs_close(int fd);\nssize_t fs_slfs_read(int fd, void *buf, size_t count);\nssize_t fs_slfs_write(int fd, const void *buf, size_t count);\nint fs_slfs_stat(const char *pathname, struct stat *s);\nint fs_slfs_fstat(int fd, struct stat *s);\noff_t fs_slfs_lseek(int fd, off_t offset, int whence);\nint fs_slfs_unlink(const char *filename);\nint fs_slfs_rename(const char *from, const char *to);\n\nvoid fs_slfs_set_new_file_size(const char *name, size_t size);\n\n#endif /* defined(MG_FS_SLFS) */\n\n#endif /* CS_COMMON_PLATFORMS_SIMPLELINK_SL_FS_SLFS_H_ */\n#ifdef MG_MODULE_LINES\n#line 1 \"common/platforms/simplelink/sl_fs_slfs.c\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n/* Standard libc interface to TI SimpleLink FS. */\n\n#if defined(MG_FS_SLFS) || defined(CC3200_FS_SLFS)\n\n/* Amalgamated: #include \"common/platforms/simplelink/sl_fs_slfs.h\" */\n\n#include <errno.h>\n\n#if CS_PLATFORM == CS_P_CC3200\n#include <inc/hw_types.h>\n#endif\n#include <simplelink/include/simplelink.h>\n#include <simplelink/include/fs.h>\n\n/* Amalgamated: #include \"common/cs_dbg.h\" */\n/* Amalgamated: #include \"common/mg_mem.h\" */\n\n/* From sl_fs.c */\nextern int set_errno(int e);\nstatic const char *drop_dir(const char *fname, bool *is_slfs);\n\n/*\n * With SLFS, you have to pre-declare max file size. Yes. Really.\n * 64K should be enough for everyone. Right?\n */\n#ifndef FS_SLFS_MAX_FILE_SIZE\n#define FS_SLFS_MAX_FILE_SIZE (64 * 1024)\n#endif\n\nstruct sl_file_size_hint {\n  char *name;\n  size_t size;\n};\n\nstruct sl_fd_info {\n  _i32 fh;\n  _off_t pos;\n  size_t size;\n};\n\nstatic struct sl_fd_info s_sl_fds[MAX_OPEN_SLFS_FILES];\nstatic struct sl_file_size_hint s_sl_file_size_hints[MAX_OPEN_SLFS_FILES];\n\nstatic int sl_fs_to_errno(_i32 r) {\n  DBG((\"SL error: %d\", (int) r));\n  switch (r) {\n    case SL_FS_OK:\n      return 0;\n    case SL_FS_FILE_NAME_EXIST:\n      return EEXIST;\n    case SL_FS_WRONG_FILE_NAME:\n      return EINVAL;\n    case SL_FS_ERR_NO_AVAILABLE_NV_INDEX:\n    case SL_FS_ERR_NO_AVAILABLE_BLOCKS:\n      return ENOSPC;\n    case SL_FS_ERR_FAILED_TO_ALLOCATE_MEM:\n      return ENOMEM;\n    case SL_FS_ERR_FILE_NOT_EXISTS:\n      return ENOENT;\n    case SL_FS_ERR_NOT_SUPPORTED:\n      return ENOTSUP;\n  }\n  return ENXIO;\n}\n\nint fs_slfs_open(const char *pathname, int flags, mode_t mode) {\n  int fd;\n  for (fd = 0; fd < MAX_OPEN_SLFS_FILES; fd++) {\n    if (s_sl_fds[fd].fh <= 0) break;\n  }\n  if (fd >= MAX_OPEN_SLFS_FILES) return set_errno(ENOMEM);\n  struct sl_fd_info *fi = &s_sl_fds[fd];\n\n  /*\n   * Apply path manipulations again, in case we got here directly\n   * (via TI libc's \"add_device\").\n   */\n  pathname = drop_dir(pathname, NULL);\n\n  _u32 am = 0;\n  fi->size = (size_t) -1;\n  int rw = (flags & 3);\n  if (rw == O_RDONLY) {\n    SlFsFileInfo_t sl_fi;\n    _i32 r = sl_FsGetInfo((const _u8 *) pathname, 0, &sl_fi);\n    if (r == SL_FS_OK) {\n      fi->size = sl_fi.FileLen;\n    }\n    am = FS_MODE_OPEN_READ;\n  } else {\n    if (!(flags & O_TRUNC) || (flags & O_APPEND)) {\n      // FailFS files cannot be opened for append and will be truncated\n      // when opened for write.\n      return set_errno(ENOTSUP);\n    }\n    if (flags & O_CREAT) {\n      size_t i, size = FS_SLFS_MAX_FILE_SIZE;\n      for (i = 0; i < MAX_OPEN_SLFS_FILES; i++) {\n        if (s_sl_file_size_hints[i].name != NULL &&\n            strcmp(s_sl_file_size_hints[i].name, pathname) == 0) {\n          size = s_sl_file_size_hints[i].size;\n          MG_FREE(s_sl_file_size_hints[i].name);\n          s_sl_file_size_hints[i].name = NULL;\n          break;\n        }\n      }\n      DBG((\"creating %s with max size %d\", pathname, (int) size));\n      am = FS_MODE_OPEN_CREATE(size, 0);\n    } else {\n      am = FS_MODE_OPEN_WRITE;\n    }\n  }\n  _i32 r = sl_FsOpen((_u8 *) pathname, am, NULL, &fi->fh);\n  DBG((\"sl_FsOpen(%s, 0x%x) = %d, %d\", pathname, (int) am, (int) r,\n       (int) fi->fh));\n  if (r == SL_FS_OK) {\n    fi->pos = 0;\n    r = fd;\n  } else {\n    fi->fh = -1;\n    r = set_errno(sl_fs_to_errno(r));\n  }\n  return r;\n}\n\nint fs_slfs_close(int fd) {\n  struct sl_fd_info *fi = &s_sl_fds[fd];\n  if (fi->fh <= 0) return set_errno(EBADF);\n  _i32 r = sl_FsClose(fi->fh, NULL, NULL, 0);\n  DBG((\"sl_FsClose(%d) = %d\", (int) fi->fh, (int) r));\n  s_sl_fds[fd].fh = -1;\n  return set_errno(sl_fs_to_errno(r));\n}\n\nssize_t fs_slfs_read(int fd, void *buf, size_t count) {\n  struct sl_fd_info *fi = &s_sl_fds[fd];\n  if (fi->fh <= 0) return set_errno(EBADF);\n  /* Simulate EOF. sl_FsRead @ file_size return SL_FS_ERR_OFFSET_OUT_OF_RANGE.\n   */\n  if (fi->pos == fi->size) return 0;\n  _i32 r = sl_FsRead(fi->fh, fi->pos, buf, count);\n  DBG((\"sl_FsRead(%d, %d, %d) = %d\", (int) fi->fh, (int) fi->pos, (int) count,\n       (int) r));\n  if (r >= 0) {\n    fi->pos += r;\n    return r;\n  }\n  return set_errno(sl_fs_to_errno(r));\n}\n\nssize_t fs_slfs_write(int fd, const void *buf, size_t count) {\n  struct sl_fd_info *fi = &s_sl_fds[fd];\n  if (fi->fh <= 0) return set_errno(EBADF);\n  _i32 r = sl_FsWrite(fi->fh, fi->pos, (_u8 *) buf, count);\n  DBG((\"sl_FsWrite(%d, %d, %d) = %d\", (int) fi->fh, (int) fi->pos, (int) count,\n       (int) r));\n  if (r >= 0) {\n    fi->pos += r;\n    return r;\n  }\n  return set_errno(sl_fs_to_errno(r));\n}\n\nint fs_slfs_stat(const char *pathname, struct stat *s) {\n  SlFsFileInfo_t sl_fi;\n  /*\n   * Apply path manipulations again, in case we got here directly\n   * (via TI libc's \"add_device\").\n   */\n  pathname = drop_dir(pathname, NULL);\n  _i32 r = sl_FsGetInfo((const _u8 *) pathname, 0, &sl_fi);\n  if (r == SL_FS_OK) {\n    s->st_mode = S_IFREG | 0666;\n    s->st_nlink = 1;\n    s->st_size = sl_fi.FileLen;\n    return 0;\n  }\n  return set_errno(sl_fs_to_errno(r));\n}\n\nint fs_slfs_fstat(int fd, struct stat *s) {\n  struct sl_fd_info *fi = &s_sl_fds[fd];\n  if (fi->fh <= 0) return set_errno(EBADF);\n  s->st_mode = 0666;\n  s->st_mode = S_IFREG | 0666;\n  s->st_nlink = 1;\n  s->st_size = fi->size;\n  return 0;\n}\n\noff_t fs_slfs_lseek(int fd, off_t offset, int whence) {\n  if (s_sl_fds[fd].fh <= 0) return set_errno(EBADF);\n  switch (whence) {\n    case SEEK_SET:\n      s_sl_fds[fd].pos = offset;\n      break;\n    case SEEK_CUR:\n      s_sl_fds[fd].pos += offset;\n      break;\n    case SEEK_END:\n      return set_errno(ENOTSUP);\n  }\n  return 0;\n}\n\nint fs_slfs_unlink(const char *pathname) {\n  /*\n   * Apply path manipulations again, in case we got here directly\n   * (via TI libc's \"add_device\").\n   */\n  pathname = drop_dir(pathname, NULL);\n  return set_errno(sl_fs_to_errno(sl_FsDel((const _u8 *) pathname, 0)));\n}\n\nint fs_slfs_rename(const char *from, const char *to) {\n  return set_errno(ENOTSUP);\n}\n\nvoid fs_slfs_set_new_file_size(const char *name, size_t size) {\n  int i;\n  for (i = 0; i < MAX_OPEN_SLFS_FILES; i++) {\n    if (s_sl_file_size_hints[i].name == NULL) {\n      DBG((\"File size hint: %s %d\", name, (int) size));\n      s_sl_file_size_hints[i].name = strdup(name);\n      s_sl_file_size_hints[i].size = size;\n      break;\n    }\n  }\n}\n\n#endif /* defined(MG_FS_SLFS) || defined(CC3200_FS_SLFS) */\n#ifdef MG_MODULE_LINES\n#line 1 \"common/platforms/simplelink/sl_fs.c\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#if MG_NET_IF == MG_NET_IF_SIMPLELINK && \\\n    (defined(MG_FS_SLFS) || defined(MG_FS_SPIFFS))\n\n#include <errno.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef __TI_COMPILER_VERSION__\n#include <file.h>\n#endif\n\n/* Amalgamated: #include \"common/cs_dbg.h\" */\n/* Amalgamated: #include \"common/platform.h\" */\n\n#ifdef CC3200_FS_SPIFFS\n/* Amalgamated: #include \"cc3200_fs_spiffs.h\" */\n#endif\n\n#ifdef MG_FS_SLFS\n/* Amalgamated: #include \"sl_fs_slfs.h\" */\n#endif\n\n#define NUM_SYS_FDS 3\n#define SPIFFS_FD_BASE 10\n#define SLFS_FD_BASE 100\n\n#ifndef MG_UART_CHAR_PUT\n#if CS_PLATFORM == CS_P_CC3200\n#include <inc/hw_types.h>\n#include <inc/hw_memmap.h>\n#include <driverlib/rom.h>\n#include <driverlib/rom_map.h>\n#include <driverlib/uart.h>\n#define MG_UART_CHAR_PUT(fd, c) MAP_UARTCharPut(UARTA0_BASE, c);\n#else\n#define MG_UART_CHAR_PUT(fd, c)\n#endif /* CS_PLATFORM == CS_P_CC3200 */\n#endif /* !MG_UART_CHAR_PUT */\n\nint set_errno(int e) {\n  errno = e;\n  return (e == 0 ? 0 : -1);\n}\n\nstatic const char *drop_dir(const char *fname, bool *is_slfs) {\n  if (is_slfs != NULL) {\n    *is_slfs = (strncmp(fname, \"SL:\", 3) == 0);\n    if (*is_slfs) fname += 3;\n  }\n  /* Drop \"./\", if any */\n  if (fname[0] == '.' && fname[1] == '/') {\n    fname += 2;\n  }\n  /*\n   * Drop / if it is the only one in the path.\n   * This allows use of /pretend/directories but serves /file.txt as normal.\n   */\n  if (fname[0] == '/' && strchr(fname + 1, '/') == NULL) {\n    fname++;\n  }\n  return fname;\n}\n\nenum fd_type {\n  FD_INVALID,\n  FD_SYS,\n#ifdef CC3200_FS_SPIFFS\n  FD_SPIFFS,\n#endif\n#ifdef MG_FS_SLFS\n  FD_SLFS\n#endif\n};\nstatic int fd_type(int fd) {\n  if (fd >= 0 && fd < NUM_SYS_FDS) return FD_SYS;\n#ifdef CC3200_FS_SPIFFS\n  if (fd >= SPIFFS_FD_BASE && fd < SPIFFS_FD_BASE + MAX_OPEN_SPIFFS_FILES) {\n    return FD_SPIFFS;\n  }\n#endif\n#ifdef MG_FS_SLFS\n  if (fd >= SLFS_FD_BASE && fd < SLFS_FD_BASE + MAX_OPEN_SLFS_FILES) {\n    return FD_SLFS;\n  }\n#endif\n  return FD_INVALID;\n}\n\n#if MG_TI_NO_HOST_INTERFACE\nint open(const char *pathname, unsigned flags, int mode) {\n#else\nint _open(const char *pathname, int flags, mode_t mode) {\n#endif\n  int fd = -1;\n  bool is_sl;\n  const char *fname = drop_dir(pathname, &is_sl);\n  if (is_sl) {\n#ifdef MG_FS_SLFS\n    fd = fs_slfs_open(fname, flags, mode);\n    if (fd >= 0) fd += SLFS_FD_BASE;\n#endif\n  } else {\n#ifdef CC3200_FS_SPIFFS\n    fd = fs_spiffs_open(fname, flags, mode);\n    if (fd >= 0) fd += SPIFFS_FD_BASE;\n#endif\n  }\n  LOG(LL_DEBUG,\n      (\"open(%s, 0x%x) = %d, fname = %s\", pathname, flags, fd, fname));\n  return fd;\n}\n\nint _stat(const char *pathname, struct stat *st) {\n  int res = -1;\n  bool is_sl;\n  const char *fname = drop_dir(pathname, &is_sl);\n  memset(st, 0, sizeof(*st));\n  /* Simulate statting the root directory. */\n  if (fname[0] == '\\0' || strcmp(fname, \".\") == 0) {\n    st->st_ino = 0;\n    st->st_mode = S_IFDIR | 0777;\n    st->st_nlink = 1;\n    st->st_size = 0;\n    return 0;\n  }\n  if (is_sl) {\n#ifdef MG_FS_SLFS\n    res = fs_slfs_stat(fname, st);\n#endif\n  } else {\n#ifdef CC3200_FS_SPIFFS\n    res = fs_spiffs_stat(fname, st);\n#endif\n  }\n  LOG(LL_DEBUG, (\"stat(%s) = %d; fname = %s\", pathname, res, fname));\n  return res;\n}\n\n#if MG_TI_NO_HOST_INTERFACE\nint close(int fd) {\n#else\nint _close(int fd) {\n#endif\n  int r = -1;\n  switch (fd_type(fd)) {\n    case FD_INVALID:\n      r = set_errno(EBADF);\n      break;\n    case FD_SYS:\n      r = set_errno(EACCES);\n      break;\n#ifdef CC3200_FS_SPIFFS\n    case FD_SPIFFS:\n      r = fs_spiffs_close(fd - SPIFFS_FD_BASE);\n      break;\n#endif\n#ifdef MG_FS_SLFS\n    case FD_SLFS:\n      r = fs_slfs_close(fd - SLFS_FD_BASE);\n      break;\n#endif\n  }\n  DBG((\"close(%d) = %d\", fd, r));\n  return r;\n}\n\n#if MG_TI_NO_HOST_INTERFACE\noff_t lseek(int fd, off_t offset, int whence) {\n#else\noff_t _lseek(int fd, off_t offset, int whence) {\n#endif\n  int r = -1;\n  switch (fd_type(fd)) {\n    case FD_INVALID:\n      r = set_errno(EBADF);\n      break;\n    case FD_SYS:\n      r = set_errno(ESPIPE);\n      break;\n#ifdef CC3200_FS_SPIFFS\n    case FD_SPIFFS:\n      r = fs_spiffs_lseek(fd - SPIFFS_FD_BASE, offset, whence);\n      break;\n#endif\n#ifdef MG_FS_SLFS\n    case FD_SLFS:\n      r = fs_slfs_lseek(fd - SLFS_FD_BASE, offset, whence);\n      break;\n#endif\n  }\n  DBG((\"lseek(%d, %d, %d) = %d\", fd, (int) offset, whence, r));\n  return r;\n}\n\nint _fstat(int fd, struct stat *s) {\n  int r = -1;\n  memset(s, 0, sizeof(*s));\n  switch (fd_type(fd)) {\n    case FD_INVALID:\n      r = set_errno(EBADF);\n      break;\n    case FD_SYS: {\n      /* Create barely passable stats for STD{IN,OUT,ERR}. */\n      memset(s, 0, sizeof(*s));\n      s->st_ino = fd;\n      s->st_mode = S_IFCHR | 0666;\n      r = 0;\n      break;\n    }\n#ifdef CC3200_FS_SPIFFS\n    case FD_SPIFFS:\n      r = fs_spiffs_fstat(fd - SPIFFS_FD_BASE, s);\n      break;\n#endif\n#ifdef MG_FS_SLFS\n    case FD_SLFS:\n      r = fs_slfs_fstat(fd - SLFS_FD_BASE, s);\n      break;\n#endif\n  }\n  DBG((\"fstat(%d) = %d\", fd, r));\n  return r;\n}\n\n#if MG_TI_NO_HOST_INTERFACE\nint read(int fd, char *buf, unsigned count) {\n#else\nssize_t _read(int fd, void *buf, size_t count) {\n#endif\n  int r = -1;\n  switch (fd_type(fd)) {\n    case FD_INVALID:\n      r = set_errno(EBADF);\n      break;\n    case FD_SYS: {\n      if (fd != 0) {\n        r = set_errno(EACCES);\n        break;\n      }\n      /* Should we allow reading from stdin = uart? */\n      r = set_errno(ENOTSUP);\n      break;\n    }\n#ifdef CC3200_FS_SPIFFS\n    case FD_SPIFFS:\n      r = fs_spiffs_read(fd - SPIFFS_FD_BASE, buf, count);\n      break;\n#endif\n#ifdef MG_FS_SLFS\n    case FD_SLFS:\n      r = fs_slfs_read(fd - SLFS_FD_BASE, buf, count);\n      break;\n#endif\n  }\n  DBG((\"read(%d, %u) = %d\", fd, count, r));\n  return r;\n}\n\n#if MG_TI_NO_HOST_INTERFACE\nint write(int fd, const char *buf, unsigned count) {\n#else\nssize_t _write(int fd, const void *buf, size_t count) {\n#endif\n  int r = -1;\n  size_t i = 0;\n  switch (fd_type(fd)) {\n    case FD_INVALID:\n      r = set_errno(EBADF);\n      break;\n    case FD_SYS: {\n      if (fd == 0) {\n        r = set_errno(EACCES);\n        break;\n      }\n      for (i = 0; i < count; i++) {\n        const char c = ((const char *) buf)[i];\n        if (c == '\\n') MG_UART_CHAR_PUT(fd, '\\r');\n        MG_UART_CHAR_PUT(fd, c);\n      }\n      r = count;\n      break;\n    }\n#ifdef CC3200_FS_SPIFFS\n    case FD_SPIFFS:\n      r = fs_spiffs_write(fd - SPIFFS_FD_BASE, buf, count);\n      break;\n#endif\n#ifdef MG_FS_SLFS\n    case FD_SLFS:\n      r = fs_slfs_write(fd - SLFS_FD_BASE, buf, count);\n      break;\n#endif\n  }\n  return r;\n}\n\n/*\n * On Newlib we override rename directly too, because the default\n * implementation using _link and _unlink doesn't work for us.\n */\n#if MG_TI_NO_HOST_INTERFACE || defined(_NEWLIB_VERSION)\nint rename(const char *frompath, const char *topath) {\n  int r = -1;\n  bool is_sl_from, is_sl_to;\n  const char *from = drop_dir(frompath, &is_sl_from);\n  const char *to = drop_dir(topath, &is_sl_to);\n  if (is_sl_from || is_sl_to) {\n    set_errno(ENOTSUP);\n  } else {\n#ifdef CC3200_FS_SPIFFS\n    r = fs_spiffs_rename(from, to);\n#endif\n  }\n  DBG((\"rename(%s, %s) = %d\", from, to, r));\n  return r;\n}\n#endif /* MG_TI_NO_HOST_INTERFACE || defined(_NEWLIB_VERSION) */\n\n#if MG_TI_NO_HOST_INTERFACE\nint unlink(const char *pathname) {\n#else\nint _unlink(const char *pathname) {\n#endif\n  int r = -1;\n  bool is_sl;\n  const char *fname = drop_dir(pathname, &is_sl);\n  if (is_sl) {\n#ifdef MG_FS_SLFS\n    r = fs_slfs_unlink(fname);\n#endif\n  } else {\n#ifdef CC3200_FS_SPIFFS\n    r = fs_spiffs_unlink(fname);\n#endif\n  }\n  DBG((\"unlink(%s) = %d, fname = %s\", pathname, r, fname));\n  return r;\n}\n\n#ifdef CC3200_FS_SPIFFS /* FailFS does not support listing files. */\nDIR *opendir(const char *dir_name) {\n  DIR *r = NULL;\n  bool is_sl;\n  drop_dir(dir_name, &is_sl);\n  if (is_sl) {\n    r = NULL;\n    set_errno(ENOTSUP);\n  } else {\n    r = fs_spiffs_opendir(dir_name);\n  }\n  DBG((\"opendir(%s) = %p\", dir_name, r));\n  return r;\n}\n\nstruct dirent *readdir(DIR *dir) {\n  struct dirent *res = fs_spiffs_readdir(dir);\n  DBG((\"readdir(%p) = %p\", dir, res));\n  return res;\n}\n\nint closedir(DIR *dir) {\n  int res = fs_spiffs_closedir(dir);\n  DBG((\"closedir(%p) = %d\", dir, res));\n  return res;\n}\n\nint rmdir(const char *path) {\n  return fs_spiffs_rmdir(path);\n}\n\nint mkdir(const char *path, mode_t mode) {\n  (void) path;\n  (void) mode;\n  /* for spiffs supports only root dir, which comes from mongoose as '.' */\n  return (strlen(path) == 1 && *path == '.') ? 0 : ENOTDIR;\n}\n#endif\n\nint sl_fs_init(void) {\n  int ret = 1;\n#ifdef __TI_COMPILER_VERSION__\n#ifdef MG_FS_SLFS\n#pragma diag_push\n#pragma diag_suppress 169 /* Nothing we can do about the prototype mismatch. \\\n                             */\n  ret = (add_device(\"SL\", _MSA, fs_slfs_open, fs_slfs_close, fs_slfs_read,\n                    fs_slfs_write, fs_slfs_lseek, fs_slfs_unlink,\n                    fs_slfs_rename) == 0);\n#pragma diag_pop\n#endif\n#endif\n  return ret;\n}\n\n#endif /* MG_NET_IF == MG_NET_IF_SIMPLELINK && (defined(MG_FS_SLFS) || \\\n          defined(MG_FS_SPIFFS)) */\n#ifdef MG_MODULE_LINES\n#line 1 \"common/platforms/simplelink/sl_socket.c\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#if MG_NET_IF == MG_NET_IF_SIMPLELINK\n\n#include <errno.h>\n#include <stdio.h>\n\n/* Amalgamated: #include \"common/platform.h\" */\n\nconst char *inet_ntop(int af, const void *src, char *dst, socklen_t size) {\n  int res;\n  struct in_addr *in = (struct in_addr *) src;\n  if (af != AF_INET) {\n    errno = EAFNOSUPPORT;\n    return NULL;\n  }\n  res = snprintf(dst, size, \"%lu.%lu.%lu.%lu\", SL_IPV4_BYTE(in->s_addr, 0),\n                 SL_IPV4_BYTE(in->s_addr, 1), SL_IPV4_BYTE(in->s_addr, 2),\n                 SL_IPV4_BYTE(in->s_addr, 3));\n  return res > 0 ? dst : NULL;\n}\n\nchar *inet_ntoa(struct in_addr n) {\n  static char a[16];\n  return (char *) inet_ntop(AF_INET, &n, a, sizeof(a));\n}\n\nint inet_pton(int af, const char *src, void *dst) {\n  uint32_t a0, a1, a2, a3;\n  uint8_t *db = (uint8_t *) dst;\n  if (af != AF_INET) {\n    errno = EAFNOSUPPORT;\n    return 0;\n  }\n  if (sscanf(src, \"%lu.%lu.%lu.%lu\", &a0, &a1, &a2, &a3) != 4) {\n    return 0;\n  }\n  *db = a3;\n  *(db + 1) = a2;\n  *(db + 2) = a1;\n  *(db + 3) = a0;\n  return 1;\n}\n\n#endif /* MG_NET_IF == MG_NET_IF_SIMPLELINK */\n#ifdef MG_MODULE_LINES\n#line 1 \"common/platforms/simplelink/sl_mg_task.c\"\n#endif\n#if MG_NET_IF == MG_NET_IF_SIMPLELINK && !defined(MG_SIMPLELINK_NO_OSI)\n\n/* Amalgamated: #include \"mg_task.h\" */\n\n#include <oslib/osi.h>\n\nenum mg_q_msg_type {\n  MG_Q_MSG_CB,\n};\nstruct mg_q_msg {\n  enum mg_q_msg_type type;\n  void (*cb)(struct mg_mgr *mgr, void *arg);\n  void *arg;\n};\nstatic OsiMsgQ_t s_mg_q;\nstatic void mg_task(void *arg);\n\nbool mg_start_task(int priority, int stack_size, mg_init_cb mg_init) {\n  if (osi_MsgQCreate(&s_mg_q, \"MG\", sizeof(struct mg_q_msg), 16) != OSI_OK) {\n    return false;\n  }\n  if (osi_TaskCreate(mg_task, (const signed char *) \"MG\", stack_size,\n                     (void *) mg_init, priority, NULL) != OSI_OK) {\n    return false;\n  }\n  return true;\n}\n\nstatic void mg_task(void *arg) {\n  struct mg_mgr mgr;\n  mg_init_cb mg_init = (mg_init_cb) arg;\n  mg_mgr_init(&mgr, NULL);\n  mg_init(&mgr);\n  while (1) {\n    struct mg_q_msg msg;\n    mg_mgr_poll(&mgr, 1);\n    if (osi_MsgQRead(&s_mg_q, &msg, 1) != OSI_OK) continue;\n    switch (msg.type) {\n      case MG_Q_MSG_CB: {\n        msg.cb(&mgr, msg.arg);\n      }\n    }\n  }\n}\n\nvoid mg_run_in_task(void (*cb)(struct mg_mgr *mgr, void *arg), void *cb_arg) {\n  struct mg_q_msg msg = {MG_Q_MSG_CB, cb, cb_arg};\n  osi_MsgQWrite(&s_mg_q, &msg, OSI_NO_WAIT);\n}\n\n#endif /* MG_NET_IF == MG_NET_IF_SIMPLELINK && !defined(MG_SIMPLELINK_NO_OSI) \\\n          */\n#ifdef MG_MODULE_LINES\n#line 1 \"common/platforms/simplelink/sl_net_if.h\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#ifndef CS_COMMON_PLATFORMS_SIMPLELINK_SL_NET_IF_H_\n#define CS_COMMON_PLATFORMS_SIMPLELINK_SL_NET_IF_H_\n\n/* Amalgamated: #include \"mongoose/src/net_if.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif /* __cplusplus */\n\n#ifndef MG_ENABLE_NET_IF_SIMPLELINK\n#define MG_ENABLE_NET_IF_SIMPLELINK MG_NET_IF == MG_NET_IF_SIMPLELINK\n#endif\n\nextern const struct mg_iface_vtable mg_simplelink_iface_vtable;\n\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n\n#endif /* CS_COMMON_PLATFORMS_SIMPLELINK_SL_NET_IF_H_ */\n#ifdef MG_MODULE_LINES\n#line 1 \"common/platforms/simplelink/sl_net_if.c\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n/* Amalgamated: #include \"common/platforms/simplelink/sl_net_if.h\" */\n\n#if MG_ENABLE_NET_IF_SIMPLELINK\n\n/* Amalgamated: #include \"mongoose/src/internal.h\" */\n/* Amalgamated: #include \"mongoose/src/util.h\" */\n\n#define MG_TCP_RECV_BUFFER_SIZE 1024\n#define MG_UDP_RECV_BUFFER_SIZE 1500\n\nstatic sock_t mg_open_listening_socket(union socket_address *sa, int type,\n                                       int proto);\n\nint sl_set_ssl_opts(struct mg_connection *nc);\n\nvoid mg_set_non_blocking_mode(sock_t sock) {\n  SlSockNonblocking_t opt;\n  opt.NonblockingEnabled = 1;\n  sl_SetSockOpt(sock, SL_SOL_SOCKET, SL_SO_NONBLOCKING, &opt, sizeof(opt));\n}\n\nstatic int mg_is_error(int n) {\n  return (n < 0 && n != SL_EALREADY && n != SL_EAGAIN);\n}\n\nvoid mg_sl_if_connect_tcp(struct mg_connection *nc,\n                          const union socket_address *sa) {\n  int proto = 0;\n  if (nc->flags & MG_F_SSL) proto = SL_SEC_SOCKET;\n  sock_t sock = sl_Socket(AF_INET, SOCK_STREAM, proto);\n  if (sock < 0) {\n    nc->err = sock;\n    goto out;\n  }\n  mg_sock_set(nc, sock);\n#if MG_ENABLE_SSL\n  nc->err = sl_set_ssl_opts(nc);\n  if (nc->err != 0) goto out;\n#endif\n  nc->err = sl_Connect(sock, &sa->sa, sizeof(sa->sin));\nout:\n  DBG((\"%p to %s:%d sock %d %d err %d\", nc, inet_ntoa(sa->sin.sin_addr),\n       ntohs(sa->sin.sin_port), nc->sock, proto, nc->err));\n}\n\nvoid mg_sl_if_connect_udp(struct mg_connection *nc) {\n  sock_t sock = sl_Socket(AF_INET, SOCK_DGRAM, 0);\n  if (sock < 0) {\n    nc->err = sock;\n    return;\n  }\n  mg_sock_set(nc, sock);\n  nc->err = 0;\n}\n\nint mg_sl_if_listen_tcp(struct mg_connection *nc, union socket_address *sa) {\n  int proto = 0;\n  if (nc->flags & MG_F_SSL) proto = SL_SEC_SOCKET;\n  sock_t sock = mg_open_listening_socket(sa, SOCK_STREAM, proto);\n  if (sock < 0) return sock;\n  mg_sock_set(nc, sock);\n#if MG_ENABLE_SSL\n  return sl_set_ssl_opts(nc);\n#else\n  return 0;\n#endif\n}\n\nint mg_sl_if_listen_udp(struct mg_connection *nc, union socket_address *sa) {\n  sock_t sock = mg_open_listening_socket(sa, SOCK_DGRAM, 0);\n  if (sock == INVALID_SOCKET) return (errno ? errno : 1);\n  mg_sock_set(nc, sock);\n  return 0;\n}\n\nvoid mg_sl_if_tcp_send(struct mg_connection *nc, const void *buf, size_t len) {\n  mbuf_append(&nc->send_mbuf, buf, len);\n}\n\nvoid mg_sl_if_udp_send(struct mg_connection *nc, const void *buf, size_t len) {\n  mbuf_append(&nc->send_mbuf, buf, len);\n}\n\nvoid mg_sl_if_recved(struct mg_connection *nc, size_t len) {\n  (void) nc;\n  (void) len;\n}\n\nint mg_sl_if_create_conn(struct mg_connection *nc) {\n  (void) nc;\n  return 1;\n}\n\nvoid mg_sl_if_destroy_conn(struct mg_connection *nc) {\n  if (nc->sock == INVALID_SOCKET) return;\n  /* For UDP, only close outgoing sockets or listeners. */\n  if (!(nc->flags & MG_F_UDP) || nc->listener == NULL) {\n    sl_Close(nc->sock);\n  }\n  nc->sock = INVALID_SOCKET;\n}\n\nstatic int mg_accept_conn(struct mg_connection *lc) {\n  struct mg_connection *nc;\n  union socket_address sa;\n  socklen_t sa_len = sizeof(sa);\n  sock_t sock = sl_Accept(lc->sock, &sa.sa, &sa_len);\n  if (sock < 0) {\n    DBG((\"%p: failed to accept: %d\", lc, sock));\n    return 0;\n  }\n  nc = mg_if_accept_new_conn(lc);\n  if (nc == NULL) {\n    sl_Close(sock);\n    return 0;\n  }\n  DBG((\"%p conn from %s:%d\", nc, inet_ntoa(sa.sin.sin_addr),\n       ntohs(sa.sin.sin_port)));\n  mg_sock_set(nc, sock);\n  if (nc->flags & MG_F_SSL) nc->flags |= MG_F_SSL_HANDSHAKE_DONE;\n  mg_if_accept_tcp_cb(nc, &sa, sa_len);\n  return 1;\n}\n\n/* 'sa' must be an initialized address to bind to */\nstatic sock_t mg_open_listening_socket(union socket_address *sa, int type,\n                                       int proto) {\n  int r;\n  socklen_t sa_len =\n      (sa->sa.sa_family == AF_INET) ? sizeof(sa->sin) : sizeof(sa->sin6);\n  sock_t sock = sl_Socket(sa->sa.sa_family, type, proto);\n  if (sock < 0) return sock;\n  if ((r = sl_Bind(sock, &sa->sa, sa_len)) < 0) {\n    sl_Close(sock);\n    return r;\n  }\n  if (type != SOCK_DGRAM && (r = sl_Listen(sock, SOMAXCONN)) < 0) {\n    sl_Close(sock);\n    return r;\n  }\n  mg_set_non_blocking_mode(sock);\n  return sock;\n}\n\nstatic void mg_write_to_socket(struct mg_connection *nc) {\n  struct mbuf *io = &nc->send_mbuf;\n  int n = 0;\n\n  if (nc->flags & MG_F_UDP) {\n    n = sl_SendTo(nc->sock, io->buf, io->len, 0, &nc->sa.sa,\n                  sizeof(nc->sa.sin));\n    DBG((\"%p %d %d %d %s:%hu\", nc, nc->sock, n, errno,\n         inet_ntoa(nc->sa.sin.sin_addr), ntohs(nc->sa.sin.sin_port)));\n  } else {\n    n = (int) sl_Send(nc->sock, io->buf, io->len, 0);\n    DBG((\"%p %d bytes -> %d\", nc, n, nc->sock));\n  }\n\n  if (n > 0) {\n    mbuf_remove(io, n);\n    mg_if_sent_cb(nc, n);\n  } else if (n < 0 && mg_is_error(n)) {\n    /* Something went wrong, drop the connection. */\n    nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n  }\n}\n\nMG_INTERNAL size_t recv_avail_size(struct mg_connection *conn, size_t max) {\n  size_t avail;\n  if (conn->recv_mbuf_limit < conn->recv_mbuf.len) return 0;\n  avail = conn->recv_mbuf_limit - conn->recv_mbuf.len;\n  return avail > max ? max : avail;\n}\n\nstatic void mg_handle_tcp_read(struct mg_connection *conn) {\n  int n = 0;\n  char *buf = (char *) MG_MALLOC(MG_TCP_RECV_BUFFER_SIZE);\n\n  if (buf == NULL) {\n    DBG((\"OOM\"));\n    return;\n  }\n\n  n = (int) sl_Recv(conn->sock, buf,\n                    recv_avail_size(conn, MG_TCP_RECV_BUFFER_SIZE), 0);\n  DBG((\"%p %d bytes <- %d\", conn, n, conn->sock));\n  if (n > 0) {\n    mg_if_recv_tcp_cb(conn, buf, n, 1 /* own */);\n  } else {\n    MG_FREE(buf);\n  }\n  if (n == 0) {\n    /* Orderly shutdown of the socket, try flushing output. */\n    conn->flags |= MG_F_SEND_AND_CLOSE;\n  } else if (mg_is_error(n)) {\n    conn->flags |= MG_F_CLOSE_IMMEDIATELY;\n  }\n}\n\nstatic void mg_handle_udp_read(struct mg_connection *nc) {\n  char *buf = (char *) MG_MALLOC(MG_UDP_RECV_BUFFER_SIZE);\n  if (buf == NULL) return;\n  union socket_address sa;\n  socklen_t sa_len = sizeof(sa);\n  int n = sl_RecvFrom(nc->sock, buf, MG_UDP_RECV_BUFFER_SIZE, 0,\n                      (SlSockAddr_t *) &sa, &sa_len);\n  DBG((\"%p %d bytes from %s:%d\", nc, n, inet_ntoa(nc->sa.sin.sin_addr),\n       ntohs(nc->sa.sin.sin_port)));\n  if (n > 0) {\n    mg_if_recv_udp_cb(nc, buf, n, &sa, sa_len);\n  } else {\n    MG_FREE(buf);\n  }\n}\n\n#define _MG_F_FD_CAN_READ 1\n#define _MG_F_FD_CAN_WRITE 1 << 1\n#define _MG_F_FD_ERROR 1 << 2\n\nvoid mg_mgr_handle_conn(struct mg_connection *nc, int fd_flags, double now) {\n  DBG((\"%p fd=%d fd_flags=%d nc_flags=%lu rmbl=%d smbl=%d\", nc, nc->sock,\n       fd_flags, nc->flags, (int) nc->recv_mbuf.len, (int) nc->send_mbuf.len));\n\n  if (nc->flags & MG_F_CONNECTING) {\n    if (nc->flags & MG_F_UDP || nc->err != SL_EALREADY) {\n      mg_if_connect_cb(nc, nc->err);\n    } else {\n      /* In SimpleLink, to get status of non-blocking connect() we need to wait\n       * until socket is writable and repeat the call to sl_Connect again,\n       * which will now return the real status. */\n      if (fd_flags & _MG_F_FD_CAN_WRITE) {\n        nc->err = sl_Connect(nc->sock, &nc->sa.sa, sizeof(nc->sa.sin));\n        DBG((\"%p conn res=%d\", nc, nc->err));\n        if (nc->err == SL_ESECSNOVERIFY ||\n            /* TODO(rojer): Provide API to set the date for verification. */\n            nc->err == SL_ESECDATEERROR) {\n          nc->err = 0;\n        }\n        if (nc->flags & MG_F_SSL && nc->err == 0) {\n          nc->flags |= MG_F_SSL_HANDSHAKE_DONE;\n        }\n        mg_if_connect_cb(nc, nc->err);\n      }\n    }\n    /* Ignore read/write in further processing, we've handled it. */\n    fd_flags &= ~(_MG_F_FD_CAN_READ | _MG_F_FD_CAN_WRITE);\n  }\n\n  if (fd_flags & _MG_F_FD_CAN_READ) {\n    if (nc->flags & MG_F_UDP) {\n      mg_handle_udp_read(nc);\n    } else {\n      if (nc->flags & MG_F_LISTENING) {\n        mg_accept_conn(nc);\n      } else {\n        mg_handle_tcp_read(nc);\n      }\n    }\n  }\n\n  if (!(nc->flags & MG_F_CLOSE_IMMEDIATELY)) {\n    if ((fd_flags & _MG_F_FD_CAN_WRITE) && nc->send_mbuf.len > 0) {\n      mg_write_to_socket(nc);\n    }\n\n    if (!(fd_flags & (_MG_F_FD_CAN_READ | _MG_F_FD_CAN_WRITE))) {\n      mg_if_poll(nc, now);\n    }\n    mg_if_timer(nc, now);\n  }\n\n  DBG((\"%p after fd=%d nc_flags=%lu rmbl=%d smbl=%d\", nc, nc->sock, nc->flags,\n       (int) nc->recv_mbuf.len, (int) nc->send_mbuf.len));\n}\n\n/* Associate a socket to a connection. */\nvoid mg_sl_if_sock_set(struct mg_connection *nc, sock_t sock) {\n  mg_set_non_blocking_mode(sock);\n  nc->sock = sock;\n  DBG((\"%p %d\", nc, sock));\n}\n\nvoid mg_sl_if_init(struct mg_iface *iface) {\n  (void) iface;\n  DBG((\"%p using sl_Select()\", iface->mgr));\n}\n\nvoid mg_sl_if_free(struct mg_iface *iface) {\n  (void) iface;\n}\n\nvoid mg_sl_if_add_conn(struct mg_connection *nc) {\n  (void) nc;\n}\n\nvoid mg_sl_if_remove_conn(struct mg_connection *nc) {\n  (void) nc;\n}\n\ntime_t mg_sl_if_poll(struct mg_iface *iface, int timeout_ms) {\n  struct mg_mgr *mgr = iface->mgr;\n  double now = mg_time();\n  double min_timer;\n  struct mg_connection *nc, *tmp;\n  struct SlTimeval_t tv;\n  SlFdSet_t read_set, write_set, err_set;\n  sock_t max_fd = INVALID_SOCKET;\n  int num_fds, num_ev = 0, num_timers = 0;\n\n  SL_FD_ZERO(&read_set);\n  SL_FD_ZERO(&write_set);\n  SL_FD_ZERO(&err_set);\n\n  /*\n   * Note: it is ok to have connections with sock == INVALID_SOCKET in the list,\n   * e.g. timer-only \"connections\".\n   */\n  min_timer = 0;\n  for (nc = mgr->active_connections, num_fds = 0; nc != NULL; nc = tmp) {\n    tmp = nc->next;\n\n    if (nc->sock != INVALID_SOCKET) {\n      num_fds++;\n\n      if (!(nc->flags & MG_F_WANT_WRITE) &&\n          nc->recv_mbuf.len < nc->recv_mbuf_limit &&\n          (!(nc->flags & MG_F_UDP) || nc->listener == NULL)) {\n        SL_FD_SET(nc->sock, &read_set);\n        if (max_fd == INVALID_SOCKET || nc->sock > max_fd) max_fd = nc->sock;\n      }\n\n      if (((nc->flags & MG_F_CONNECTING) && !(nc->flags & MG_F_WANT_READ)) ||\n          (nc->send_mbuf.len > 0 && !(nc->flags & MG_F_CONNECTING))) {\n        SL_FD_SET(nc->sock, &write_set);\n        SL_FD_SET(nc->sock, &err_set);\n        if (max_fd == INVALID_SOCKET || nc->sock > max_fd) max_fd = nc->sock;\n      }\n    }\n\n    if (nc->ev_timer_time > 0) {\n      if (num_timers == 0 || nc->ev_timer_time < min_timer) {\n        min_timer = nc->ev_timer_time;\n      }\n      num_timers++;\n    }\n  }\n\n  /*\n   * If there is a timer to be fired earlier than the requested timeout,\n   * adjust the timeout.\n   */\n  if (num_timers > 0) {\n    double timer_timeout_ms = (min_timer - mg_time()) * 1000 + 1 /* rounding */;\n    if (timer_timeout_ms < timeout_ms) {\n      timeout_ms = timer_timeout_ms;\n    }\n  }\n  if (timeout_ms < 0) timeout_ms = 0;\n\n  tv.tv_sec = timeout_ms / 1000;\n  tv.tv_usec = (timeout_ms % 1000) * 1000;\n\n  if (num_fds > 0) {\n    num_ev = sl_Select((int) max_fd + 1, &read_set, &write_set, &err_set, &tv);\n  }\n\n  now = mg_time();\n  DBG((\"sl_Select @ %ld num_ev=%d of %d, timeout=%d\", (long) now, num_ev,\n       num_fds, timeout_ms));\n\n  for (nc = mgr->active_connections; nc != NULL; nc = tmp) {\n    int fd_flags = 0;\n    if (nc->sock != INVALID_SOCKET) {\n      if (num_ev > 0) {\n        fd_flags =\n            (SL_FD_ISSET(nc->sock, &read_set) &&\n                     (!(nc->flags & MG_F_UDP) || nc->listener == NULL)\n                 ? _MG_F_FD_CAN_READ\n                 : 0) |\n            (SL_FD_ISSET(nc->sock, &write_set) ? _MG_F_FD_CAN_WRITE : 0) |\n            (SL_FD_ISSET(nc->sock, &err_set) ? _MG_F_FD_ERROR : 0);\n      }\n      /* SimpleLink does not report UDP sockets as writable. */\n      if (nc->flags & MG_F_UDP && nc->send_mbuf.len > 0) {\n        fd_flags |= _MG_F_FD_CAN_WRITE;\n      }\n    }\n    tmp = nc->next;\n    mg_mgr_handle_conn(nc, fd_flags, now);\n  }\n\n  for (nc = mgr->active_connections; nc != NULL; nc = tmp) {\n    tmp = nc->next;\n    if ((nc->flags & MG_F_CLOSE_IMMEDIATELY) ||\n        (nc->send_mbuf.len == 0 && (nc->flags & MG_F_SEND_AND_CLOSE))) {\n      mg_close_conn(nc);\n    }\n  }\n\n  return now;\n}\n\nvoid mg_sl_if_get_conn_addr(struct mg_connection *nc, int remote,\n                            union socket_address *sa) {\n  /* SimpleLink does not provide a way to get socket's peer address after\n   * accept or connect. Address should have been preserved in the connection,\n   * so we do our best here by using it. */\n  if (remote) memcpy(sa, &nc->sa, sizeof(*sa));\n}\n\nvoid sl_restart_cb(struct mg_mgr *mgr) {\n  /*\n   * SimpleLink has been restarted, meaning all sockets have been invalidated.\n   * We try our best - we'll restart the listeners, but for outgoing\n   * connections we have no option but to terminate.\n   */\n  struct mg_connection *nc;\n  for (nc = mg_next(mgr, NULL); nc != NULL; nc = mg_next(mgr, nc)) {\n    if (nc->sock == INVALID_SOCKET) continue; /* Could be a timer */\n    if (nc->flags & MG_F_LISTENING) {\n      DBG((\"restarting %p %s:%d\", nc, inet_ntoa(nc->sa.sin.sin_addr),\n           ntohs(nc->sa.sin.sin_port)));\n      int res = (nc->flags & MG_F_UDP ? mg_sl_if_listen_udp(nc, &nc->sa)\n                                      : mg_sl_if_listen_tcp(nc, &nc->sa));\n      if (res == 0) continue;\n      /* Well, we tried and failed. Fall through to closing. */\n    }\n    nc->sock = INVALID_SOCKET;\n    DBG((\"terminating %p %s:%d\", nc, inet_ntoa(nc->sa.sin.sin_addr),\n         ntohs(nc->sa.sin.sin_port)));\n    /* TODO(rojer): Outgoing UDP? */\n    nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n  }\n}\n\n/* clang-format off */\n#define MG_SL_IFACE_VTABLE                                              \\\n  {                                                                     \\\n    mg_sl_if_init,                                                      \\\n    mg_sl_if_free,                                                      \\\n    mg_sl_if_add_conn,                                                  \\\n    mg_sl_if_remove_conn,                                               \\\n    mg_sl_if_poll,                                                      \\\n    mg_sl_if_listen_tcp,                                                \\\n    mg_sl_if_listen_udp,                                                \\\n    mg_sl_if_connect_tcp,                                               \\\n    mg_sl_if_connect_udp,                                               \\\n    mg_sl_if_tcp_send,                                                  \\\n    mg_sl_if_udp_send,                                                  \\\n    mg_sl_if_recved,                                                    \\\n    mg_sl_if_create_conn,                                               \\\n    mg_sl_if_destroy_conn,                                              \\\n    mg_sl_if_sock_set,                                                  \\\n    mg_sl_if_get_conn_addr,                                             \\\n  }\n/* clang-format on */\n\nconst struct mg_iface_vtable mg_simplelink_iface_vtable = MG_SL_IFACE_VTABLE;\n#if MG_NET_IF == MG_NET_IF_SIMPLELINK\nconst struct mg_iface_vtable mg_default_iface_vtable = MG_SL_IFACE_VTABLE;\n#endif\n\n#endif /* MG_ENABLE_NET_IF_SIMPLELINK */\n#ifdef MG_MODULE_LINES\n#line 1 \"common/platforms/simplelink/sl_ssl_if.c\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#if MG_ENABLE_SSL && MG_SSL_IF == MG_SSL_IF_SIMPLELINK\n\n/* Amalgamated: #include \"common/mg_mem.h\" */\n\nstruct mg_ssl_if_ctx {\n  char *ssl_cert;\n  char *ssl_key;\n  char *ssl_ca_cert;\n  char *ssl_server_name;\n};\n\nvoid mg_ssl_if_init() {\n}\n\nenum mg_ssl_if_result mg_ssl_if_conn_init(\n    struct mg_connection *nc, const struct mg_ssl_if_conn_params *params,\n    const char **err_msg) {\n  struct mg_ssl_if_ctx *ctx =\n      (struct mg_ssl_if_ctx *) MG_CALLOC(1, sizeof(*ctx));\n  if (ctx == NULL) {\n    MG_SET_PTRPTR(err_msg, \"Out of memory\");\n    return MG_SSL_ERROR;\n  }\n  nc->ssl_if_data = ctx;\n\n  if (params->cert != NULL || params->key != NULL) {\n    if (params->cert != NULL && params->key != NULL) {\n      ctx->ssl_cert = strdup(params->cert);\n      ctx->ssl_key = strdup(params->key);\n    } else {\n      MG_SET_PTRPTR(err_msg, \"Both cert and key are required.\");\n      return MG_SSL_ERROR;\n    }\n  }\n  if (params->ca_cert != NULL && strcmp(params->ca_cert, \"*\") != 0) {\n    ctx->ssl_ca_cert = strdup(params->ca_cert);\n  }\n  /* TODO(rojer): cipher_suites. */\n  if (params->server_name != NULL) {\n    ctx->ssl_server_name = strdup(params->server_name);\n  }\n  return MG_SSL_OK;\n}\n\nvoid mg_ssl_if_conn_close_notify(struct mg_connection *nc) {\n  /* Nothing to do */\n  (void) nc;\n}\n\nvoid mg_ssl_if_conn_free(struct mg_connection *nc) {\n  struct mg_ssl_if_ctx *ctx = (struct mg_ssl_if_ctx *) nc->ssl_if_data;\n  if (ctx == NULL) return;\n  nc->ssl_if_data = NULL;\n  MG_FREE(ctx->ssl_cert);\n  MG_FREE(ctx->ssl_key);\n  MG_FREE(ctx->ssl_ca_cert);\n  MG_FREE(ctx->ssl_server_name);\n  memset(ctx, 0, sizeof(*ctx));\n  MG_FREE(ctx);\n}\n\nbool pem_to_der(const char *pem_file, const char *der_file) {\n  bool ret = false;\n  FILE *pf = NULL, *df = NULL;\n  bool writing = false;\n  pf = fopen(pem_file, \"r\");\n  if (pf == NULL) goto clean;\n  remove(der_file);\n  fs_slfs_set_new_file_size(der_file + 3, 2048);\n  df = fopen(der_file, \"w\");\n  if (df == NULL) goto clean;\n  while (1) {\n    char pem_buf[70];\n    char der_buf[48];\n    if (!fgets(pem_buf, sizeof(pem_buf), pf)) break;\n    if (writing) {\n      if (strstr(pem_buf, \"-----END \") != NULL) {\n        ret = true;\n        break;\n      }\n      int l = 0;\n      while (!isspace((unsigned int) pem_buf[l])) l++;\n      int der_len = 0;\n      cs_base64_decode((const unsigned char *) pem_buf, sizeof(pem_buf),\n                       der_buf, &der_len);\n      if (der_len <= 0) break;\n      if (fwrite(der_buf, 1, der_len, df) != der_len) break;\n    } else if (strstr(pem_buf, \"-----BEGIN \") != NULL) {\n      writing = true;\n    }\n  }\n\nclean:\n  if (pf != NULL) fclose(pf);\n  if (df != NULL) {\n    fclose(df);\n    if (!ret) remove(der_file);\n  }\n  return ret;\n}\n\n#if MG_ENABLE_FILESYSTEM && defined(MG_FS_SLFS)\n/* If the file's extension is .pem, convert it to DER format and put on SLFS. */\nstatic char *sl_pem2der(const char *pem_file) {\n  const char *pem_ext = strstr(pem_file, \".pem\");\n  if (pem_ext == NULL || *(pem_ext + 4) != '\\0') {\n    return strdup(pem_file);\n  }\n  char *der_file = NULL;\n  /* DER file must be located on SLFS, add prefix. */\n  int l = mg_asprintf(&der_file, 0, \"SL:%.*s.der\", (int) (pem_ext - pem_file),\n                      pem_file);\n  if (der_file == NULL) return NULL;\n  bool result = false;\n  cs_stat_t st;\n  if (mg_stat(der_file, &st) != 0) {\n    result = pem_to_der(pem_file, der_file);\n    LOG(LL_DEBUG, (\"%s -> %s = %d\", pem_file, der_file, result));\n  } else {\n    /* File exists, assume it's already been converted. */\n    result = true;\n  }\n  if (result) {\n    /* Strip the SL: prefix we added since NWP does not expect it. */\n    memmove(der_file, der_file + 3, l - 2 /* including \\0 */);\n  } else {\n    MG_FREE(der_file);\n    der_file = NULL;\n  }\n  return der_file;\n}\n#else\nstatic char *sl_pem2der(const char *pem_file) {\n  return strdup(pem_file);\n}\n#endif\n\nint sl_set_ssl_opts(struct mg_connection *nc) {\n  int err;\n  struct mg_ssl_if_ctx *ctx = (struct mg_ssl_if_ctx *) nc->ssl_if_data;\n  DBG((\"%p ssl ctx: %p\", nc, ctx));\n\n  if (ctx != NULL) {\n    DBG((\"%p %s,%s,%s,%s\", nc, (ctx->ssl_cert ? ctx->ssl_cert : \"-\"),\n         (ctx->ssl_key ? ctx->ssl_cert : \"-\"),\n         (ctx->ssl_ca_cert ? ctx->ssl_ca_cert : \"-\"),\n         (ctx->ssl_server_name ? ctx->ssl_server_name : \"-\")));\n    if (ctx->ssl_cert != NULL && ctx->ssl_key != NULL) {\n      char *ssl_cert = sl_pem2der(ctx->ssl_cert);\n      char *ssl_key = sl_pem2der(ctx->ssl_key);\n      if (ssl_cert != NULL && ssl_key != NULL) {\n        err = sl_SetSockOpt(nc->sock, SL_SOL_SOCKET,\n                            SL_SO_SECURE_FILES_CERTIFICATE_FILE_NAME, ssl_cert,\n                            strlen(ssl_cert));\n        LOG(LL_INFO, (\"CERTIFICATE_FILE_NAME %s -> %d\", ssl_cert, err));\n        err = sl_SetSockOpt(nc->sock, SL_SOL_SOCKET,\n                            SL_SO_SECURE_FILES_PRIVATE_KEY_FILE_NAME, ssl_key,\n                            strlen(ssl_key));\n        LOG(LL_INFO, (\"PRIVATE_KEY_FILE_NAME %s -> %d\", ssl_key, err));\n      } else {\n        err = -1;\n      }\n      MG_FREE(ssl_cert);\n      MG_FREE(ssl_key);\n      if (err != 0) return err;\n    }\n    if (ctx->ssl_ca_cert != NULL) {\n      if (ctx->ssl_ca_cert[0] != '\\0') {\n        char *ssl_ca_cert = sl_pem2der(ctx->ssl_ca_cert);\n        if (ssl_ca_cert != NULL) {\n          err = sl_SetSockOpt(nc->sock, SL_SOL_SOCKET,\n                              SL_SO_SECURE_FILES_CA_FILE_NAME, ssl_ca_cert,\n                              strlen(ssl_ca_cert));\n          LOG(LL_INFO, (\"CA_FILE_NAME %s -> %d\", ssl_ca_cert, err));\n        } else {\n          err = -1;\n        }\n        MG_FREE(ssl_ca_cert);\n        if (err != 0) return err;\n      }\n    }\n    if (ctx->ssl_server_name != NULL) {\n      err = sl_SetSockOpt(nc->sock, SL_SOL_SOCKET,\n                          SO_SECURE_DOMAIN_NAME_VERIFICATION,\n                          ctx->ssl_server_name, strlen(ctx->ssl_server_name));\n      DBG((\"DOMAIN_NAME_VERIFICATION %s -> %d\", ctx->ssl_server_name, err));\n      /* Domain name verificationw as added in a NWP service pack, older\n       * versions return SL_ENOPROTOOPT. There isn't much we can do about it,\n       * so we ignore the error. */\n      if (err != 0 && err != SL_ENOPROTOOPT) return err;\n    }\n  }\n  return 0;\n}\n\n#endif /* MG_ENABLE_SSL && MG_SSL_IF == MG_SSL_IF_SIMPLELINK */\n#ifdef MG_MODULE_LINES\n#line 1 \"common/platforms/lwip/mg_lwip_net_if.h\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#ifndef CS_COMMON_PLATFORMS_LWIP_MG_NET_IF_LWIP_H_\n#define CS_COMMON_PLATFORMS_LWIP_MG_NET_IF_LWIP_H_\n\n#ifndef MG_ENABLE_NET_IF_LWIP_LOW_LEVEL\n#define MG_ENABLE_NET_IF_LWIP_LOW_LEVEL MG_NET_IF == MG_NET_IF_LWIP_LOW_LEVEL\n#endif\n\n#if MG_ENABLE_NET_IF_LWIP_LOW_LEVEL\n\n#include <stdint.h>\n\nextern const struct mg_iface_vtable mg_lwip_iface_vtable;\n\nstruct mg_lwip_conn_state {\n  struct mg_connection *nc;\n  struct mg_connection *lc;\n  union {\n    struct tcp_pcb *tcp;\n    struct udp_pcb *udp;\n  } pcb;\n  err_t err;\n  size_t num_sent; /* Number of acknowledged bytes to be reported to the core */\n  struct pbuf *rx_chain; /* Chain of incoming data segments. */\n  size_t rx_offset; /* Offset within the first pbuf (if partially consumed) */\n  /* Last SSL write size, for retries. */\n  int last_ssl_write_size;\n  /* Whether MG_SIG_RECV is already pending for this connection */\n  int recv_pending;\n};\n\nenum mg_sig_type {\n  MG_SIG_CONNECT_RESULT = 1,\n  MG_SIG_RECV = 2,\n  MG_SIG_SENT_CB = 3,\n  MG_SIG_CLOSE_CONN = 4,\n  MG_SIG_TOMBSTONE = 5,\n  MG_SIG_ACCEPT = 6,\n};\n\nvoid mg_lwip_post_signal(enum mg_sig_type sig, struct mg_connection *nc);\n\n/* To be implemented by the platform. */\nvoid mg_lwip_mgr_schedule_poll(struct mg_mgr *mgr);\n\n#endif /* MG_ENABLE_NET_IF_LWIP_LOW_LEVEL */\n\n#endif /* CS_COMMON_PLATFORMS_LWIP_MG_NET_IF_LWIP_H_ */\n#ifdef MG_MODULE_LINES\n#line 1 \"common/platforms/lwip/mg_lwip_net_if.c\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#if MG_ENABLE_NET_IF_LWIP_LOW_LEVEL\n\n/* Amalgamated: #include \"common/mg_mem.h\" */\n\n#include <lwip/pbuf.h>\n#include <lwip/tcp.h>\n#if CS_PLATFORM != CS_P_STM32\n#include <lwip/tcp_impl.h>\n#endif\n#include <lwip/udp.h>\n\n/* Amalgamated: #include \"common/cs_dbg.h\" */\n\n/*\n * Depending on whether Mongoose is compiled with ipv6 support, use right\n * lwip functions\n */\n#if MG_ENABLE_IPV6\n#define TCP_NEW tcp_new_ip6\n#define TCP_BIND tcp_bind_ip6\n#define UDP_BIND udp_bind_ip6\n#define IPADDR_NTOA(x) ip6addr_ntoa((const ip6_addr_t *)(x))\n#define SET_ADDR(dst, src)                               \\\n  memcpy((dst)->sin6.sin6_addr.s6_addr, (src)->ip6.addr, \\\n         sizeof((dst)->sin6.sin6_addr.s6_addr))\n#else\n#define TCP_NEW tcp_new\n#define TCP_BIND tcp_bind\n#define UDP_BIND udp_bind\n#define IPADDR_NTOA ipaddr_ntoa\n#define SET_ADDR(dst, src) (dst)->sin.sin_addr.s_addr = GET_IPV4(src)\n#endif\n\n/*\n * If lwip is compiled with ipv6 support, then API changes even for ipv4\n */\n#if !defined(LWIP_IPV6) || !LWIP_IPV6\n#define GET_IPV4(ipX_addr) ((ipX_addr)->addr)\n#else\n#define GET_IPV4(ipX_addr) ((ipX_addr)->ip4.addr)\n#endif\n\nvoid mg_lwip_ssl_do_hs(struct mg_connection *nc);\nvoid mg_lwip_ssl_send(struct mg_connection *nc);\nvoid mg_lwip_ssl_recv(struct mg_connection *nc);\n\nvoid mg_lwip_if_init(struct mg_iface *iface);\nvoid mg_lwip_if_free(struct mg_iface *iface);\nvoid mg_lwip_if_add_conn(struct mg_connection *nc);\nvoid mg_lwip_if_remove_conn(struct mg_connection *nc);\ntime_t mg_lwip_if_poll(struct mg_iface *iface, int timeout_ms);\n\n#ifdef RTOS_SDK\nextern void mgos_lock();\nextern void mgos_unlock();\n#else\n#define mgos_lock()\n#define mgos_unlock()\n#endif\n\nstatic void mg_lwip_recv_common(struct mg_connection *nc, struct pbuf *p);\n\n#if LWIP_TCP_KEEPALIVE\nvoid mg_lwip_set_keepalive_params(struct mg_connection *nc, int idle,\n                                  int interval, int count) {\n  if (nc->sock == INVALID_SOCKET || nc->flags & MG_F_UDP) {\n    return;\n  }\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n  struct tcp_pcb *tpcb = cs->pcb.tcp;\n  if (idle > 0 && interval > 0 && count > 0) {\n    tpcb->keep_idle = idle * 1000;\n    tpcb->keep_intvl = interval * 1000;\n    tpcb->keep_cnt = count;\n    tpcb->so_options |= SOF_KEEPALIVE;\n  } else {\n    tpcb->so_options &= ~SOF_KEEPALIVE;\n  }\n}\n#elif !defined(MG_NO_LWIP_TCP_KEEPALIVE)\n#warning LWIP TCP keepalive is disabled. Please consider enabling it.\n#endif /* LWIP_TCP_KEEPALIVE */\n\nstatic err_t mg_lwip_tcp_conn_cb(void *arg, struct tcp_pcb *tpcb, err_t err) {\n  struct mg_connection *nc = (struct mg_connection *) arg;\n  DBG((\"%p connect to %s:%u = %d\", nc, IPADDR_NTOA(ipX_2_ip(&tpcb->remote_ip)),\n       tpcb->remote_port, err));\n  if (nc == NULL) {\n    tcp_abort(tpcb);\n    return ERR_ARG;\n  }\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n  cs->err = err;\n#if LWIP_TCP_KEEPALIVE\n  if (err == 0) mg_lwip_set_keepalive_params(nc, 60, 10, 6);\n#endif\n  mg_lwip_post_signal(MG_SIG_CONNECT_RESULT, nc);\n  return ERR_OK;\n}\n\nstatic void mg_lwip_tcp_error_cb(void *arg, err_t err) {\n  struct mg_connection *nc = (struct mg_connection *) arg;\n  DBG((\"%p conn error %d\", nc, err));\n  if (nc == NULL) return;\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n  cs->pcb.tcp = NULL; /* Has already been deallocated */\n  if (nc->flags & MG_F_CONNECTING) {\n    cs->err = err;\n    mg_lwip_post_signal(MG_SIG_CONNECT_RESULT, nc);\n  } else {\n    mg_lwip_post_signal(MG_SIG_CLOSE_CONN, nc);\n  }\n}\n\nstatic err_t mg_lwip_tcp_recv_cb(void *arg, struct tcp_pcb *tpcb,\n                                 struct pbuf *p, err_t err) {\n  struct mg_connection *nc = (struct mg_connection *) arg;\n  DBG((\"%p %p %u %d\", nc, tpcb, (p != NULL ? p->tot_len : 0), err));\n  if (p == NULL) {\n    if (nc != NULL) {\n      mg_lwip_post_signal(MG_SIG_CLOSE_CONN, nc);\n    } else {\n      /* Tombstoned connection, do nothing. */\n    }\n    return ERR_OK;\n  } else if (nc == NULL) {\n    tcp_abort(tpcb);\n    return ERR_ARG;\n  }\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n  /*\n   * If we get a chain of more than one segment at once, we need to bump\n   * refcount on the subsequent bufs to make them independent.\n   */\n  if (p->next != NULL) {\n    struct pbuf *q = p->next;\n    for (; q != NULL; q = q->next) pbuf_ref(q);\n  }\n  if (cs->rx_chain == NULL) {\n    cs->rx_offset = 0;\n  } else if (pbuf_clen(cs->rx_chain) >= 4) {\n    /* ESP SDK has a limited pool of 5 pbufs. We must not hog them all or RX\n     * will be completely blocked. We already have at least 4 in the chain,\n     * this one is, so we have to make a copy and release this one. */\n    struct pbuf *np = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);\n    if (np != NULL) {\n      pbuf_copy(np, p);\n      pbuf_free(p);\n      p = np;\n    }\n  }\n  mg_lwip_recv_common(nc, p);\n  return ERR_OK;\n}\n\nstatic void mg_lwip_handle_recv_tcp(struct mg_connection *nc) {\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n\n#if MG_ENABLE_SSL\n  if (nc->flags & MG_F_SSL) {\n    if (nc->flags & MG_F_SSL_HANDSHAKE_DONE) {\n      mg_lwip_ssl_recv(nc);\n    } else {\n      mg_lwip_ssl_do_hs(nc);\n    }\n    return;\n  }\n#endif\n\n  mgos_lock();\n  while (cs->rx_chain != NULL) {\n    struct pbuf *seg = cs->rx_chain;\n    size_t len = (seg->len - cs->rx_offset);\n    char *data = (char *) MG_MALLOC(len);\n    if (data == NULL) {\n      mgos_unlock();\n      DBG((\"OOM\"));\n      return;\n    }\n    pbuf_copy_partial(seg, data, len, cs->rx_offset);\n    cs->rx_offset += len;\n    if (cs->rx_offset == cs->rx_chain->len) {\n      cs->rx_chain = pbuf_dechain(cs->rx_chain);\n      pbuf_free(seg);\n      cs->rx_offset = 0;\n    }\n    mgos_unlock();\n    mg_if_recv_tcp_cb(nc, data, len, 1 /* own */);\n    mgos_lock();\n  }\n  mgos_unlock();\n\n  if (nc->send_mbuf.len > 0) {\n    mg_lwip_mgr_schedule_poll(nc->mgr);\n  }\n}\n\nstatic err_t mg_lwip_tcp_sent_cb(void *arg, struct tcp_pcb *tpcb,\n                                 u16_t num_sent) {\n  struct mg_connection *nc = (struct mg_connection *) arg;\n  DBG((\"%p %p %u\", nc, tpcb, num_sent));\n  if (nc == NULL) {\n    tcp_abort(tpcb);\n    return ERR_ABRT;\n  }\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n  cs->num_sent += num_sent;\n\n  mg_lwip_post_signal(MG_SIG_SENT_CB, nc);\n  return ERR_OK;\n}\n\nvoid mg_lwip_if_connect_tcp(struct mg_connection *nc,\n                            const union socket_address *sa) {\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n  struct tcp_pcb *tpcb = TCP_NEW();\n  cs->pcb.tcp = tpcb;\n  ip_addr_t *ip = (ip_addr_t *) &sa->sin.sin_addr.s_addr;\n  u16_t port = ntohs(sa->sin.sin_port);\n  tcp_arg(tpcb, nc);\n  tcp_err(tpcb, mg_lwip_tcp_error_cb);\n  tcp_sent(tpcb, mg_lwip_tcp_sent_cb);\n  tcp_recv(tpcb, mg_lwip_tcp_recv_cb);\n  cs->err = TCP_BIND(tpcb, IP_ADDR_ANY, 0 /* any port */);\n  DBG((\"%p tcp_bind = %d\", nc, cs->err));\n  if (cs->err != ERR_OK) {\n    mg_lwip_post_signal(MG_SIG_CONNECT_RESULT, nc);\n    return;\n  }\n  cs->err = tcp_connect(tpcb, ip, port, mg_lwip_tcp_conn_cb);\n  DBG((\"%p tcp_connect %p = %d\", nc, tpcb, cs->err));\n  if (cs->err != ERR_OK) {\n    mg_lwip_post_signal(MG_SIG_CONNECT_RESULT, nc);\n    return;\n  }\n}\n\n/*\n * Lwip included in the SDKs for nRF5x chips has different type for the\n * callback of `udp_recv()`\n */\n#if CS_PLATFORM == CS_P_NRF51 || CS_PLATFORM == CS_P_NRF52 || \\\n    CS_PLATFORM == CS_P_STM32\nstatic void mg_lwip_udp_recv_cb(void *arg, struct udp_pcb *pcb, struct pbuf *p,\n                                const ip_addr_t *addr, u16_t port)\n#else\nstatic void mg_lwip_udp_recv_cb(void *arg, struct udp_pcb *pcb, struct pbuf *p,\n                                ip_addr_t *addr, u16_t port)\n#endif\n{\n  struct mg_connection *nc = (struct mg_connection *) arg;\n  DBG((\"%p %s:%u %p %u %u\", nc, IPADDR_NTOA(addr), port, p, p->ref, p->len));\n  /* Put address in a separate pbuf and tack it onto the packet. */\n  struct pbuf *sap =\n      pbuf_alloc(PBUF_RAW, sizeof(union socket_address), PBUF_RAM);\n  if (sap == NULL) {\n    pbuf_free(p);\n    return;\n  }\n  union socket_address *sa = (union socket_address *) sap->payload;\n  sa->sin.sin_addr.s_addr = addr->addr;\n  sa->sin.sin_port = htons(port);\n  /* Logic in the recv handler requires that there be exactly one data pbuf. */\n  p = pbuf_coalesce(p, PBUF_RAW);\n  pbuf_chain(sap, p);\n  mg_lwip_recv_common(nc, sap);\n  (void) pcb;\n}\n\nstatic void mg_lwip_recv_common(struct mg_connection *nc, struct pbuf *p) {\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n  mgos_lock();\n  if (cs->rx_chain == NULL) {\n    cs->rx_chain = p;\n  } else {\n    pbuf_chain(cs->rx_chain, p);\n  }\n  if (!cs->recv_pending) {\n    cs->recv_pending = 1;\n    mg_lwip_post_signal(MG_SIG_RECV, nc);\n  }\n  mgos_unlock();\n}\n\nstatic void mg_lwip_handle_recv_udp(struct mg_connection *nc) {\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n  /*\n   * For UDP, RX chain consists of interleaved address and packet bufs:\n   * Address pbuf followed by exactly one data pbuf (recv_cb took care of that).\n   */\n  while (cs->rx_chain != NULL) {\n    struct pbuf *sap = cs->rx_chain;\n    struct pbuf *p = sap->next;\n    cs->rx_chain = pbuf_dechain(p);\n    size_t data_len = p->len;\n    char *data = (char *) MG_MALLOC(data_len);\n    if (data != NULL) {\n      pbuf_copy_partial(p, data, data_len, 0);\n      pbuf_free(p);\n      mg_if_recv_udp_cb(nc, data, data_len,\n                        (union socket_address *) sap->payload, sap->len);\n      pbuf_free(sap);\n    } else {\n      pbuf_free(p);\n      pbuf_free(sap);\n    }\n  }\n}\n\nvoid mg_lwip_if_connect_udp(struct mg_connection *nc) {\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n  struct udp_pcb *upcb = udp_new();\n  cs->err = UDP_BIND(upcb, IP_ADDR_ANY, 0 /* any port */);\n  DBG((\"%p udp_bind %p = %d\", nc, upcb, cs->err));\n  if (cs->err == ERR_OK) {\n    udp_recv(upcb, mg_lwip_udp_recv_cb, nc);\n    cs->pcb.udp = upcb;\n  } else {\n    udp_remove(upcb);\n  }\n  mg_lwip_post_signal(MG_SIG_CONNECT_RESULT, nc);\n}\n\nvoid mg_lwip_accept_conn(struct mg_connection *nc, struct tcp_pcb *tpcb) {\n  union socket_address sa;\n  SET_ADDR(&sa, &tpcb->remote_ip);\n  sa.sin.sin_port = htons(tpcb->remote_port);\n  mg_if_accept_tcp_cb(nc, &sa, sizeof(sa.sin));\n}\n\nvoid mg_lwip_handle_accept(struct mg_connection *nc) {\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n#if MG_ENABLE_SSL\n  if (cs->lc->flags & MG_F_SSL) {\n    if (mg_ssl_if_conn_accept(nc, cs->lc) != MG_SSL_OK) {\n      LOG(LL_ERROR, (\"SSL error\"));\n      tcp_close(cs->pcb.tcp);\n    }\n  } else\n#endif\n  {\n    mg_lwip_accept_conn(nc, cs->pcb.tcp);\n  }\n}\n\nstatic err_t mg_lwip_accept_cb(void *arg, struct tcp_pcb *newtpcb, err_t err) {\n  struct mg_connection *lc = (struct mg_connection *) arg;\n  DBG((\"%p conn %p from %s:%u\", lc, newtpcb,\n       IPADDR_NTOA(ipX_2_ip(&newtpcb->remote_ip)), newtpcb->remote_port));\n  struct mg_connection *nc = mg_if_accept_new_conn(lc);\n  if (nc == NULL) {\n    tcp_abort(newtpcb);\n    return ERR_ABRT;\n  }\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n  cs->lc = lc;\n  cs->pcb.tcp = newtpcb;\n  /* We need to set up callbacks before returning because data may start\n   * arriving immediately. */\n  tcp_arg(newtpcb, nc);\n  tcp_err(newtpcb, mg_lwip_tcp_error_cb);\n  tcp_sent(newtpcb, mg_lwip_tcp_sent_cb);\n  tcp_recv(newtpcb, mg_lwip_tcp_recv_cb);\n#if LWIP_TCP_KEEPALIVE\n  mg_lwip_set_keepalive_params(nc, 60, 10, 6);\n#endif\n  mg_lwip_post_signal(MG_SIG_ACCEPT, nc);\n  (void) err;\n  return ERR_OK;\n}\n\nint mg_lwip_if_listen_tcp(struct mg_connection *nc, union socket_address *sa) {\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n  struct tcp_pcb *tpcb = TCP_NEW();\n  ip_addr_t *ip = (ip_addr_t *) &sa->sin.sin_addr.s_addr;\n  u16_t port = ntohs(sa->sin.sin_port);\n  cs->err = TCP_BIND(tpcb, ip, port);\n  DBG((\"%p tcp_bind(%s:%u) = %d\", nc, IPADDR_NTOA(ip), port, cs->err));\n  if (cs->err != ERR_OK) {\n    tcp_close(tpcb);\n    return -1;\n  }\n  tcp_arg(tpcb, nc);\n  tpcb = tcp_listen(tpcb);\n  cs->pcb.tcp = tpcb;\n  tcp_accept(tpcb, mg_lwip_accept_cb);\n  return 0;\n}\n\nint mg_lwip_if_listen_udp(struct mg_connection *nc, union socket_address *sa) {\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n  struct udp_pcb *upcb = udp_new();\n  ip_addr_t *ip = (ip_addr_t *) &sa->sin.sin_addr.s_addr;\n  u16_t port = ntohs(sa->sin.sin_port);\n  cs->err = UDP_BIND(upcb, ip, port);\n  DBG((\"%p udb_bind(%s:%u) = %d\", nc, IPADDR_NTOA(ip), port, cs->err));\n  if (cs->err != ERR_OK) {\n    udp_remove(upcb);\n    return -1;\n  }\n  udp_recv(upcb, mg_lwip_udp_recv_cb, nc);\n  cs->pcb.udp = upcb;\n  return 0;\n}\n\nint mg_lwip_tcp_write(struct mg_connection *nc, const void *data,\n                      uint16_t len) {\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n  struct tcp_pcb *tpcb = cs->pcb.tcp;\n  if (tpcb == NULL) return -1;\n  len = MIN(tpcb->mss, MIN(len, tpcb->snd_buf));\n  if (len == 0) {\n    DBG((\"%p no buf avail %u %u %u %p %p\", tpcb, tpcb->acked, tpcb->snd_buf,\n         tpcb->snd_queuelen, tpcb->unsent, tpcb->unacked));\n    tcp_output(tpcb);\n    return 0;\n  }\n/*\n * On ESP8266 we only allow one TCP segment in flight at any given time.\n * This may increase latency and reduce efficiency of tcp windowing,\n * but memory is scarce and precious on that platform so we do this to\n * reduce footprint.\n */\n#if CS_PLATFORM == CS_P_ESP8266\n  if (tpcb->unacked != NULL) {\n    return 0;\n  }\n  if (tpcb->unsent != NULL) {\n    len = MIN(len, (TCP_MSS - tpcb->unsent->len));\n  }\n#endif\n  err_t err = tcp_write(tpcb, data, len, TCP_WRITE_FLAG_COPY);\n  DBG((\"%p tcp_write %u = %d\", tpcb, len, err));\n  if (err != ERR_OK) {\n    /*\n     * We ignore ERR_MEM because memory will be freed up when the data is sent\n     * and we'll retry.\n     */\n    return (err == ERR_MEM ? 0 : -1);\n  }\n  return len;\n}\n\nstatic void mg_lwip_send_more(struct mg_connection *nc) {\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n  if (nc->sock == INVALID_SOCKET || cs->pcb.tcp == NULL) {\n    DBG((\"%p invalid socket\", nc));\n    return;\n  }\n  int num_written = mg_lwip_tcp_write(nc, nc->send_mbuf.buf, nc->send_mbuf.len);\n  DBG((\"%p mg_lwip_tcp_write %u = %d\", nc, nc->send_mbuf.len, num_written));\n  if (num_written == 0) return;\n  if (num_written < 0) {\n    mg_lwip_post_signal(MG_SIG_CLOSE_CONN, nc);\n  }\n  mbuf_remove(&nc->send_mbuf, num_written);\n  mbuf_trim(&nc->send_mbuf);\n}\n\nvoid mg_lwip_if_tcp_send(struct mg_connection *nc, const void *buf,\n                         size_t len) {\n  mbuf_append(&nc->send_mbuf, buf, len);\n  mg_lwip_mgr_schedule_poll(nc->mgr);\n}\n\nvoid mg_lwip_if_udp_send(struct mg_connection *nc, const void *buf,\n                         size_t len) {\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n  if (nc->sock == INVALID_SOCKET || cs->pcb.udp == NULL) {\n    /*\n     * In case of UDP, this usually means, what\n     * async DNS resolve is still in progress and connection\n     * is not ready yet\n     */\n    DBG((\"%p socket is not connected\", nc));\n    return;\n  }\n  struct udp_pcb *upcb = cs->pcb.udp;\n  struct pbuf *p = pbuf_alloc(PBUF_TRANSPORT, len, PBUF_RAM);\n  ip_addr_t *ip = (ip_addr_t *) &nc->sa.sin.sin_addr.s_addr;\n  u16_t port = ntohs(nc->sa.sin.sin_port);\n  if (p == NULL) {\n    DBG((\"OOM\"));\n    return;\n  }\n  memcpy(p->payload, buf, len);\n  cs->err = udp_sendto(upcb, p, (ip_addr_t *) ip, port);\n  DBG((\"%p udp_sendto = %d\", nc, cs->err));\n  pbuf_free(p);\n  if (cs->err != ERR_OK) {\n    mg_lwip_post_signal(MG_SIG_CLOSE_CONN, nc);\n  } else {\n    cs->num_sent += len;\n    mg_lwip_post_signal(MG_SIG_SENT_CB, nc);\n  }\n}\n\nvoid mg_lwip_if_recved(struct mg_connection *nc, size_t len) {\n  if (nc->flags & MG_F_UDP) return;\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n  if (nc->sock == INVALID_SOCKET || cs->pcb.tcp == NULL) {\n    DBG((\"%p invalid socket\", nc));\n    return;\n  }\n  DBG((\"%p %p %u\", nc, cs->pcb.tcp, len));\n/* Currently SSL acknowledges data immediately.\n * TODO(rojer): Find a way to propagate mg_lwip_if_recved. */\n#if MG_ENABLE_SSL\n  if (!(nc->flags & MG_F_SSL)) {\n    tcp_recved(cs->pcb.tcp, len);\n  }\n#else\n  tcp_recved(cs->pcb.tcp, len);\n#endif\n  mbuf_trim(&nc->recv_mbuf);\n}\n\nint mg_lwip_if_create_conn(struct mg_connection *nc) {\n  struct mg_lwip_conn_state *cs =\n      (struct mg_lwip_conn_state *) MG_CALLOC(1, sizeof(*cs));\n  if (cs == NULL) return 0;\n  cs->nc = nc;\n  nc->sock = (intptr_t) cs;\n  return 1;\n}\n\nvoid mg_lwip_if_destroy_conn(struct mg_connection *nc) {\n  if (nc->sock == INVALID_SOCKET) return;\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n  if (!(nc->flags & MG_F_UDP)) {\n    struct tcp_pcb *tpcb = cs->pcb.tcp;\n    if (tpcb != NULL) {\n      tcp_arg(tpcb, NULL);\n      DBG((\"%p tcp_close %p\", nc, tpcb));\n      tcp_arg(tpcb, NULL);\n      tcp_close(tpcb);\n    }\n    while (cs->rx_chain != NULL) {\n      struct pbuf *seg = cs->rx_chain;\n      cs->rx_chain = pbuf_dechain(cs->rx_chain);\n      pbuf_free(seg);\n    }\n    memset(cs, 0, sizeof(*cs));\n    MG_FREE(cs);\n  } else if (nc->listener == NULL) {\n    /* Only close outgoing UDP pcb or listeners. */\n    struct udp_pcb *upcb = cs->pcb.udp;\n    if (upcb != NULL) {\n      DBG((\"%p udp_remove %p\", nc, upcb));\n      udp_remove(upcb);\n    }\n    memset(cs, 0, sizeof(*cs));\n    MG_FREE(cs);\n  }\n  nc->sock = INVALID_SOCKET;\n}\n\nvoid mg_lwip_if_get_conn_addr(struct mg_connection *nc, int remote,\n                              union socket_address *sa) {\n  memset(sa, 0, sizeof(*sa));\n  if (nc->sock == INVALID_SOCKET) return;\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n  if (nc->flags & MG_F_UDP) {\n    struct udp_pcb *upcb = cs->pcb.udp;\n    if (remote) {\n      memcpy(sa, &nc->sa, sizeof(*sa));\n    } else {\n      sa->sin.sin_port = htons(upcb->local_port);\n      SET_ADDR(sa, &upcb->local_ip);\n    }\n  } else {\n    struct tcp_pcb *tpcb = cs->pcb.tcp;\n    if (remote) {\n      sa->sin.sin_port = htons(tpcb->remote_port);\n      SET_ADDR(sa, &tpcb->remote_ip);\n    } else {\n      sa->sin.sin_port = htons(tpcb->local_port);\n      SET_ADDR(sa, &tpcb->local_ip);\n    }\n  }\n}\n\nvoid mg_lwip_if_sock_set(struct mg_connection *nc, sock_t sock) {\n  nc->sock = sock;\n}\n\n/* clang-format off */\n#define MG_LWIP_IFACE_VTABLE                                          \\\n  {                                                                   \\\n    mg_lwip_if_init,                                                  \\\n    mg_lwip_if_free,                                                  \\\n    mg_lwip_if_add_conn,                                              \\\n    mg_lwip_if_remove_conn,                                           \\\n    mg_lwip_if_poll,                                                  \\\n    mg_lwip_if_listen_tcp,                                            \\\n    mg_lwip_if_listen_udp,                                            \\\n    mg_lwip_if_connect_tcp,                                           \\\n    mg_lwip_if_connect_udp,                                           \\\n    mg_lwip_if_tcp_send,                                              \\\n    mg_lwip_if_udp_send,                                              \\\n    mg_lwip_if_recved,                                                \\\n    mg_lwip_if_create_conn,                                           \\\n    mg_lwip_if_destroy_conn,                                          \\\n    mg_lwip_if_sock_set,                                              \\\n    mg_lwip_if_get_conn_addr,                                         \\\n  }\n/* clang-format on */\n\nconst struct mg_iface_vtable mg_lwip_iface_vtable = MG_LWIP_IFACE_VTABLE;\n#if MG_NET_IF == MG_NET_IF_LWIP_LOW_LEVEL\nconst struct mg_iface_vtable mg_default_iface_vtable = MG_LWIP_IFACE_VTABLE;\n#endif\n\n#endif /* MG_ENABLE_NET_IF_LWIP_LOW_LEVEL */\n#ifdef MG_MODULE_LINES\n#line 1 \"common/platforms/lwip/mg_lwip_ev_mgr.c\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#if MG_NET_IF == MG_NET_IF_LWIP_LOW_LEVEL\n\n#ifndef MG_SIG_QUEUE_LEN\n#define MG_SIG_QUEUE_LEN 32\n#endif\n\nstruct mg_ev_mgr_lwip_signal {\n  int sig;\n  struct mg_connection *nc;\n};\n\nstruct mg_ev_mgr_lwip_data {\n  struct mg_ev_mgr_lwip_signal sig_queue[MG_SIG_QUEUE_LEN];\n  int sig_queue_len;\n  int start_index;\n};\n\nvoid mg_lwip_post_signal(enum mg_sig_type sig, struct mg_connection *nc) {\n  struct mg_ev_mgr_lwip_data *md =\n      (struct mg_ev_mgr_lwip_data *) nc->iface->data;\n  mgos_lock();\n  if (md->sig_queue_len >= MG_SIG_QUEUE_LEN) {\n    mgos_unlock();\n    return;\n  }\n  int end_index = (md->start_index + md->sig_queue_len) % MG_SIG_QUEUE_LEN;\n  md->sig_queue[end_index].sig = sig;\n  md->sig_queue[end_index].nc = nc;\n  md->sig_queue_len++;\n  mg_lwip_mgr_schedule_poll(nc->mgr);\n  mgos_unlock();\n}\n\nvoid mg_ev_mgr_lwip_process_signals(struct mg_mgr *mgr) {\n  struct mg_ev_mgr_lwip_data *md =\n      (struct mg_ev_mgr_lwip_data *) mgr->ifaces[MG_MAIN_IFACE]->data;\n  while (md->sig_queue_len > 0) {\n    mgos_lock();\n    int sig = md->sig_queue[md->start_index].sig;\n    struct mg_connection *nc = md->sig_queue[md->start_index].nc;\n    struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n    md->start_index = (md->start_index + 1) % MG_SIG_QUEUE_LEN;\n    md->sig_queue_len--;\n    mgos_unlock();\n    if (nc->iface == NULL || nc->mgr == NULL) continue;\n    switch (sig) {\n      case MG_SIG_CONNECT_RESULT: {\n#if MG_ENABLE_SSL\n        if (cs->err == 0 && (nc->flags & MG_F_SSL) &&\n            !(nc->flags & MG_F_SSL_HANDSHAKE_DONE)) {\n          mg_lwip_ssl_do_hs(nc);\n        } else\n#endif\n        {\n          mg_if_connect_cb(nc, cs->err);\n        }\n        break;\n      }\n      case MG_SIG_CLOSE_CONN: {\n        nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n        mg_close_conn(nc);\n        break;\n      }\n      case MG_SIG_RECV: {\n        cs->recv_pending = 0;\n        if (nc->flags & MG_F_UDP) {\n          mg_lwip_handle_recv_udp(nc);\n        } else {\n          mg_lwip_handle_recv_tcp(nc);\n        }\n        break;\n      }\n      case MG_SIG_SENT_CB: {\n        if (cs->num_sent > 0) mg_if_sent_cb(nc, cs->num_sent);\n        cs->num_sent = 0;\n\n        if (nc->send_mbuf.len == 0 && (nc->flags & MG_F_SEND_AND_CLOSE) &&\n            !(nc->flags & MG_F_WANT_WRITE)) {\n          mg_close_conn(nc);\n        }\n\n        break;\n      }\n      case MG_SIG_TOMBSTONE: {\n        break;\n      }\n      case MG_SIG_ACCEPT: {\n        mg_lwip_handle_accept(nc);\n        break;\n      }\n    }\n  }\n}\n\nvoid mg_lwip_if_init(struct mg_iface *iface) {\n  LOG(LL_INFO, (\"%p Mongoose init\"));\n  iface->data = MG_CALLOC(1, sizeof(struct mg_ev_mgr_lwip_data));\n}\n\nvoid mg_lwip_if_free(struct mg_iface *iface) {\n  MG_FREE(iface->data);\n  iface->data = NULL;\n}\n\nvoid mg_lwip_if_add_conn(struct mg_connection *nc) {\n  (void) nc;\n}\n\nvoid mg_lwip_if_remove_conn(struct mg_connection *nc) {\n  struct mg_ev_mgr_lwip_data *md =\n      (struct mg_ev_mgr_lwip_data *) nc->iface->data;\n  /* Walk the queue and null-out further signals for this conn. */\n  for (int i = 0; i < MG_SIG_QUEUE_LEN; i++) {\n    if (md->sig_queue[i].nc == nc) {\n      md->sig_queue[i].sig = MG_SIG_TOMBSTONE;\n    }\n  }\n}\n\ntime_t mg_lwip_if_poll(struct mg_iface *iface, int timeout_ms) {\n  struct mg_mgr *mgr = iface->mgr;\n  int n = 0;\n  double now = mg_time();\n  struct mg_connection *nc, *tmp;\n  double min_timer = 0;\n  int num_timers = 0;\n#if 0\n  DBG((\"begin poll @%u\", (unsigned int) (now * 1000)));\n#endif\n  mg_ev_mgr_lwip_process_signals(mgr);\n  for (nc = mgr->active_connections; nc != NULL; nc = tmp) {\n    struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n    tmp = nc->next;\n    n++;\n    if ((nc->flags & MG_F_CLOSE_IMMEDIATELY) ||\n        ((nc->flags & MG_F_SEND_AND_CLOSE) && (nc->flags & MG_F_UDP) &&\n         (nc->send_mbuf.len == 0))) {\n      mg_close_conn(nc);\n      continue;\n    }\n    mg_if_poll(nc, now);\n    mg_if_timer(nc, now);\n#if MG_ENABLE_SSL\n    if ((nc->flags & MG_F_SSL) && cs != NULL && cs->pcb.tcp != NULL &&\n        cs->pcb.tcp->state == ESTABLISHED) {\n      if (((nc->flags & MG_F_WANT_WRITE) ||\n           ((nc->send_mbuf.len > 0) &&\n            (nc->flags & MG_F_SSL_HANDSHAKE_DONE))) &&\n          cs->pcb.tcp->snd_buf > 0) {\n        /* Can write more. */\n        if (nc->flags & MG_F_SSL_HANDSHAKE_DONE) {\n          if (!(nc->flags & MG_F_CONNECTING)) mg_lwip_ssl_send(nc);\n        } else {\n          mg_lwip_ssl_do_hs(nc);\n        }\n      }\n      if (cs->rx_chain != NULL || (nc->flags & MG_F_WANT_READ)) {\n        if (nc->flags & MG_F_SSL_HANDSHAKE_DONE) {\n          if (!(nc->flags & MG_F_CONNECTING)) mg_lwip_ssl_recv(nc);\n        } else {\n          mg_lwip_ssl_do_hs(nc);\n        }\n      }\n    } else\n#endif /* MG_ENABLE_SSL */\n    {\n      if (!(nc->flags & (MG_F_CONNECTING | MG_F_UDP))) {\n        if (nc->send_mbuf.len > 0) mg_lwip_send_more(nc);\n      }\n    }\n    if (nc->sock != INVALID_SOCKET &&\n        !(nc->flags & (MG_F_UDP | MG_F_LISTENING)) && cs->pcb.tcp != NULL &&\n        cs->pcb.tcp->unsent != NULL) {\n      tcp_output(cs->pcb.tcp);\n    }\n    if (nc->ev_timer_time > 0) {\n      if (num_timers == 0 || nc->ev_timer_time < min_timer) {\n        min_timer = nc->ev_timer_time;\n      }\n      num_timers++;\n    }\n  }\n#if 0\n  DBG((\"end poll @%u, %d conns, %d timers (min %u), next in %d ms\",\n       (unsigned int) (now * 1000), n, num_timers,\n       (unsigned int) (min_timer * 1000), timeout_ms));\n#endif\n  (void) timeout_ms;\n  return now;\n}\n\nuint32_t mg_lwip_get_poll_delay_ms(struct mg_mgr *mgr) {\n  struct mg_connection *nc;\n  double now = mg_time();\n  double min_timer = 0;\n  int num_timers = 0;\n  mg_ev_mgr_lwip_process_signals(mgr);\n  for (nc = mg_next(mgr, NULL); nc != NULL; nc = mg_next(mgr, nc)) {\n    struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n    if (nc->ev_timer_time > 0) {\n      if (num_timers == 0 || nc->ev_timer_time < min_timer) {\n        min_timer = nc->ev_timer_time;\n      }\n      num_timers++;\n    }\n    if (nc->send_mbuf.len > 0) {\n      int can_send = 0;\n      /* We have stuff to send, but can we? */\n      if (nc->flags & MG_F_UDP) {\n        /* UDP is always ready for sending. */\n        can_send = (cs->pcb.udp != NULL);\n      } else {\n        can_send = (cs->pcb.tcp != NULL && cs->pcb.tcp->snd_buf > 0);\n      }\n      /* We want and can send, request a poll immediately. */\n      if (can_send) return 0;\n    }\n  }\n  uint32_t timeout_ms = ~0;\n  if (num_timers > 0) {\n    double timer_timeout_ms = (min_timer - now) * 1000 + 1 /* rounding */;\n    if (timer_timeout_ms < timeout_ms) {\n      timeout_ms = timer_timeout_ms;\n    }\n  }\n  return timeout_ms;\n}\n\n#endif /* MG_NET_IF == MG_NET_IF_LWIP_LOW_LEVEL */\n#ifdef MG_MODULE_LINES\n#line 1 \"common/platforms/lwip/mg_lwip_ssl_if.c\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#if MG_ENABLE_SSL && MG_NET_IF == MG_NET_IF_LWIP_LOW_LEVEL\n\n/* Amalgamated: #include \"common/mg_mem.h\" */\n/* Amalgamated: #include \"common/cs_dbg.h\" */\n\n#include <lwip/pbuf.h>\n#include <lwip/tcp.h>\n\n#ifndef MG_LWIP_SSL_IO_SIZE\n#define MG_LWIP_SSL_IO_SIZE 1024\n#endif\n\n/*\n * Stop processing incoming SSL traffic when recv_mbuf.size is this big.\n * It'a a uick solution for SSL recv pushback.\n */\n#ifndef MG_LWIP_SSL_RECV_MBUF_LIMIT\n#define MG_LWIP_SSL_RECV_MBUF_LIMIT 3072\n#endif\n\n#ifndef MIN\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n#endif\n\nvoid mg_lwip_ssl_do_hs(struct mg_connection *nc) {\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n  int server_side = (nc->listener != NULL);\n  enum mg_ssl_if_result res;\n  if (nc->flags & MG_F_CLOSE_IMMEDIATELY) return;\n  res = mg_ssl_if_handshake(nc);\n  DBG((\"%p %d %d %d\", nc, nc->flags, server_side, res));\n  if (res != MG_SSL_OK) {\n    if (res == MG_SSL_WANT_WRITE) {\n      nc->flags |= MG_F_WANT_WRITE;\n      cs->err = 0;\n    } else if (res == MG_SSL_WANT_READ) {\n      /*\n       * Nothing to do in particular, we are callback-driven.\n       * What we definitely do not need anymore is SSL reading (nothing left).\n       */\n      nc->flags &= ~MG_F_WANT_READ;\n      cs->err = 0;\n    } else {\n      cs->err = res;\n      if (server_side) {\n        mg_lwip_post_signal(MG_SIG_CLOSE_CONN, nc);\n      } else {\n        mg_lwip_post_signal(MG_SIG_CONNECT_RESULT, nc);\n      }\n    }\n  } else {\n    cs->err = 0;\n    nc->flags &= ~MG_F_WANT_WRITE;\n    /*\n     * Handshake is done. Schedule a read immediately to consume app data\n     * which may already be waiting.\n     */\n    nc->flags |= (MG_F_SSL_HANDSHAKE_DONE | MG_F_WANT_READ);\n    if (server_side) {\n      mg_lwip_accept_conn(nc, cs->pcb.tcp);\n    } else {\n      mg_lwip_post_signal(MG_SIG_CONNECT_RESULT, nc);\n    }\n  }\n}\n\nvoid mg_lwip_ssl_send(struct mg_connection *nc) {\n  if (nc->sock == INVALID_SOCKET) {\n    DBG((\"%p invalid socket\", nc));\n    return;\n  }\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n  /* It's ok if the buffer is empty. Return value of 0 may also be valid. */\n  int len = cs->last_ssl_write_size;\n  if (len == 0) {\n    len = MIN(MG_LWIP_SSL_IO_SIZE, nc->send_mbuf.len);\n  }\n  int ret = mg_ssl_if_write(nc, nc->send_mbuf.buf, len);\n  DBG((\"%p SSL_write %u = %d, %d\", nc, len, ret));\n  if (ret > 0) {\n    mbuf_remove(&nc->send_mbuf, ret);\n    mbuf_trim(&nc->send_mbuf);\n    cs->last_ssl_write_size = 0;\n  } else if (ret < 0) {\n    /* This is tricky. We must remember the exact data we were sending to retry\n     * exactly the same send next time. */\n    cs->last_ssl_write_size = len;\n  }\n  if (ret == len) {\n    nc->flags &= ~MG_F_WANT_WRITE;\n  } else if (ret == MG_SSL_WANT_WRITE) {\n    nc->flags |= MG_F_WANT_WRITE;\n  } else {\n    mg_lwip_post_signal(MG_SIG_CLOSE_CONN, nc);\n  }\n}\n\nvoid mg_lwip_ssl_recv(struct mg_connection *nc) {\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n  /* Don't deliver data before connect callback */\n  if (nc->flags & MG_F_CONNECTING) return;\n  while (nc->recv_mbuf.len < MG_LWIP_SSL_RECV_MBUF_LIMIT) {\n    char *buf = (char *) MG_MALLOC(MG_LWIP_SSL_IO_SIZE);\n    if (buf == NULL) return;\n    int ret = mg_ssl_if_read(nc, buf, MG_LWIP_SSL_IO_SIZE);\n    DBG((\"%p %p SSL_read %u = %d\", nc, cs->rx_chain, MG_LWIP_SSL_IO_SIZE, ret));\n    if (ret <= 0) {\n      MG_FREE(buf);\n      if (ret == MG_SSL_WANT_WRITE) {\n        nc->flags |= MG_F_WANT_WRITE;\n        return;\n      } else if (ret == MG_SSL_WANT_READ) {\n        /*\n         * Nothing to do in particular, we are callback-driven.\n         * What we definitely do not need anymore is SSL reading (nothing left).\n         */\n        nc->flags &= ~MG_F_WANT_READ;\n        cs->err = 0;\n        return;\n      } else {\n        mg_lwip_post_signal(MG_SIG_CLOSE_CONN, nc);\n        return;\n      }\n    } else {\n      mg_if_recv_tcp_cb(nc, buf, ret, 1 /* own */);\n    }\n  }\n}\n\n#ifdef KR_VERSION\n\nssize_t kr_send(int fd, const void *buf, size_t len) {\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) fd;\n  int ret = mg_lwip_tcp_write(cs->nc, buf, len);\n  DBG((\"%p mg_lwip_tcp_write %u = %d\", cs->nc, len, ret));\n  if (ret == 0) ret = KR_IO_WOULDBLOCK;\n  return ret;\n}\n\nssize_t kr_recv(int fd, void *buf, size_t len) {\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) fd;\n  struct pbuf *seg = cs->rx_chain;\n  if (seg == NULL) {\n    DBG((\"%u - nothing to read\", len));\n    return KR_IO_WOULDBLOCK;\n  }\n  size_t seg_len = (seg->len - cs->rx_offset);\n  DBG((\"%u %u %u %u\", len, cs->rx_chain->len, seg_len, cs->rx_chain->tot_len));\n  len = MIN(len, seg_len);\n  pbuf_copy_partial(seg, buf, len, cs->rx_offset);\n  cs->rx_offset += len;\n  tcp_recved(cs->pcb.tcp, len);\n  if (cs->rx_offset == cs->rx_chain->len) {\n    cs->rx_chain = pbuf_dechain(cs->rx_chain);\n    pbuf_free(seg);\n    cs->rx_offset = 0;\n  }\n  return len;\n}\n\n#elif MG_SSL_IF == MG_SSL_IF_MBEDTLS\n\nint ssl_socket_send(void *ctx, const unsigned char *buf, size_t len) {\n  struct mg_connection *nc = (struct mg_connection *) ctx;\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n  int ret = mg_lwip_tcp_write(cs->nc, buf, len);\n  LOG(LL_DEBUG, (\"%p %d -> %d\", nc, len, ret));\n  if (ret == 0) ret = MBEDTLS_ERR_SSL_WANT_WRITE;\n  return ret;\n}\n\nint ssl_socket_recv(void *ctx, unsigned char *buf, size_t len) {\n  struct mg_connection *nc = (struct mg_connection *) ctx;\n  struct mg_lwip_conn_state *cs = (struct mg_lwip_conn_state *) nc->sock;\n  struct pbuf *seg = cs->rx_chain;\n  if (seg == NULL) {\n    DBG((\"%u - nothing to read\", len));\n    return MBEDTLS_ERR_SSL_WANT_READ;\n  }\n  size_t seg_len = (seg->len - cs->rx_offset);\n  DBG((\"%u %u %u %u\", len, cs->rx_chain->len, seg_len, cs->rx_chain->tot_len));\n  len = MIN(len, seg_len);\n  pbuf_copy_partial(seg, buf, len, cs->rx_offset);\n  cs->rx_offset += len;\n  /* TCP PCB may be NULL if connection has already been closed\n   * but we still have data to deliver to SSL. */\n  if (cs->pcb.tcp != NULL) tcp_recved(cs->pcb.tcp, len);\n  if (cs->rx_offset == cs->rx_chain->len) {\n    cs->rx_chain = pbuf_dechain(cs->rx_chain);\n    pbuf_free(seg);\n    cs->rx_offset = 0;\n  }\n  LOG(LL_DEBUG, (\"%p <- %d\", nc, (int) len));\n  return len;\n}\n\n#endif\n\n#endif /* MG_ENABLE_SSL && MG_NET_IF == MG_NET_IF_LWIP_LOW_LEVEL */\n#ifdef MG_MODULE_LINES\n#line 1 \"common/platforms/wince/wince_libc.c\"\n#endif\n/*\n * Copyright (c) 2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#ifdef WINCE\n\nconst char *strerror(int err) {\n  /*\n   * TODO(alashkin): there is no strerror on WinCE;\n   * look for similar wce_xxxx function\n   */\n  static char buf[10];\n  snprintf(buf, sizeof(buf), \"%d\", err);\n  return buf;\n}\n\nint open(const char *filename, int oflag, int pmode) {\n  /*\n   * TODO(alashkin): mg_open function is not used in mongoose\n   * but exists in documentation as utility function\n   * Shall we delete it at all or implement for WinCE as well?\n   */\n  DebugBreak();\n  return 0; /* for compiler */\n}\n\nint _wstati64(const wchar_t *path, cs_stat_t *st) {\n  DWORD fa = GetFileAttributesW(path);\n  if (fa == INVALID_FILE_ATTRIBUTES) {\n    return -1;\n  }\n  memset(st, 0, sizeof(*st));\n  if ((fa & FILE_ATTRIBUTE_DIRECTORY) == 0) {\n    HANDLE h;\n    FILETIME ftime;\n    st->st_mode |= _S_IFREG;\n    h = CreateFileW(path, GENERIC_READ, 0, NULL, OPEN_EXISTING,\n                    FILE_ATTRIBUTE_NORMAL, NULL);\n    if (h == INVALID_HANDLE_VALUE) {\n      return -1;\n    }\n    st->st_size = GetFileSize(h, NULL);\n    GetFileTime(h, NULL, NULL, &ftime);\n    st->st_mtime = (uint32_t)((((uint64_t) ftime.dwLowDateTime +\n                                ((uint64_t) ftime.dwHighDateTime << 32)) /\n                               10000000.0) -\n                              11644473600);\n    CloseHandle(h);\n  } else {\n    st->st_mode |= _S_IFDIR;\n  }\n  return 0;\n}\n\n/* Windows CE doesn't have neither gmtime nor strftime */\nstatic void mg_gmt_time_string(char *buf, size_t buf_len, time_t *t) {\n  FILETIME ft;\n  SYSTEMTIME systime;\n  if (t != NULL) {\n    uint64_t filetime = (*t + 11644473600) * 10000000;\n    ft.dwLowDateTime = filetime & 0xFFFFFFFF;\n    ft.dwHighDateTime = (filetime & 0xFFFFFFFF00000000) >> 32;\n    FileTimeToSystemTime(&ft, &systime);\n  } else {\n    GetSystemTime(&systime);\n  }\n  /* There is no PRIu16 in WinCE SDK */\n  snprintf(buf, buf_len, \"%d.%d.%d %d:%d:%d GMT\", (int) systime.wYear,\n           (int) systime.wMonth, (int) systime.wDay, (int) systime.wHour,\n           (int) systime.wMinute, (int) systime.wSecond);\n}\n\n#endif\n#ifdef MG_MODULE_LINES\n#line 1 \"common/platforms/pic32/pic32_net_if.h\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#ifndef CS_COMMON_PLATFORMS_PIC32_NET_IF_H_\n#define CS_COMMON_PLATFORMS_PIC32_NET_IF_H_\n\n/* Amalgamated: #include \"mongoose/src/net_if.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif /* __cplusplus */\n\n#ifndef MG_ENABLE_NET_IF_PIC32\n#define MG_ENABLE_NET_IF_PIC32 MG_NET_IF == MG_NET_IF_PIC32\n#endif\n\nextern const struct mg_iface_vtable mg_pic32_iface_vtable;\n\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n\n#endif /* CS_COMMON_PLATFORMS_PIC32_NET_IF_H_ */\n#ifdef MG_MODULE_LINES\n#line 1 \"common/platforms/pic32/pic32_net_if.c\"\n#endif\n/*\n * Copyright (c) 2014-2016 Cesanta Software Limited\n * All rights reserved\n */\n\n#if MG_ENABLE_NET_IF_PIC32\n\nint mg_pic32_if_create_conn(struct mg_connection *nc) {\n  (void) nc;\n  return 1;\n}\n\nvoid mg_pic32_if_recved(struct mg_connection *nc, size_t len) {\n  (void) nc;\n  (void) len;\n}\n\nvoid mg_pic32_if_add_conn(struct mg_connection *nc) {\n  (void) nc;\n}\n\nvoid mg_pic32_if_init(struct mg_iface *iface) {\n  (void) iface;\n  (void) mg_get_errno(); /* Shutup compiler */\n}\n\nvoid mg_pic32_if_free(struct mg_iface *iface) {\n  (void) iface;\n}\n\nvoid mg_pic32_if_remove_conn(struct mg_connection *nc) {\n  (void) nc;\n}\n\nvoid mg_pic32_if_destroy_conn(struct mg_connection *nc) {\n  if (nc->sock == INVALID_SOCKET) return;\n  /* For UDP, only close outgoing sockets or listeners. */\n  if (!(nc->flags & MG_F_UDP)) {\n    /* Close TCP */\n    TCPIP_TCP_Close((TCP_SOCKET) nc->sock);\n  } else if (nc->listener == NULL) {\n    /* Only close outgoing UDP or listeners. */\n    TCPIP_UDP_Close((UDP_SOCKET) nc->sock);\n  }\n\n  nc->sock = INVALID_SOCKET;\n}\n\nint mg_pic32_if_listen_udp(struct mg_connection *nc, union socket_address *sa) {\n  nc->sock = TCPIP_UDP_ServerOpen(\n      sa->sin.sin_family == AF_INET ? IP_ADDRESS_TYPE_IPV4\n                                    : IP_ADDRESS_TYPE_IPV6,\n      ntohs(sa->sin.sin_port),\n      sa->sin.sin_addr.s_addr == 0 ? 0 : (IP_MULTI_ADDRESS *) &sa->sin);\n  if (nc->sock == INVALID_SOCKET) {\n    return -1;\n  }\n  return 0;\n}\n\nvoid mg_pic32_if_udp_send(struct mg_connection *nc, const void *buf,\n                          size_t len) {\n  mbuf_append(&nc->send_mbuf, buf, len);\n}\n\nvoid mg_pic32_if_tcp_send(struct mg_connection *nc, const void *buf,\n                          size_t len) {\n  mbuf_append(&nc->send_mbuf, buf, len);\n}\n\nint mg_pic32_if_listen_tcp(struct mg_connection *nc, union socket_address *sa) {\n  nc->sock = TCPIP_TCP_ServerOpen(\n      sa->sin.sin_family == AF_INET ? IP_ADDRESS_TYPE_IPV4\n                                    : IP_ADDRESS_TYPE_IPV6,\n      ntohs(sa->sin.sin_port),\n      sa->sin.sin_addr.s_addr == 0 ? 0 : (IP_MULTI_ADDRESS *) &sa->sin);\n  memcpy(&nc->sa, sa, sizeof(*sa));\n  if (nc->sock == INVALID_SOCKET) {\n    return -1;\n  }\n  return 0;\n}\n\nstatic int mg_accept_conn(struct mg_connection *lc) {\n  struct mg_connection *nc;\n  TCP_SOCKET_INFO si;\n  union socket_address sa;\n\n  nc = mg_if_accept_new_conn(lc);\n\n  if (nc == NULL) {\n    return 0;\n  }\n\n  nc->sock = lc->sock;\n  nc->flags &= ~MG_F_LISTENING;\n\n  if (!TCPIP_TCP_SocketInfoGet((TCP_SOCKET) nc->sock, &si)) {\n    return 0;\n  }\n\n  if (si.addressType == IP_ADDRESS_TYPE_IPV4) {\n    sa.sin.sin_family = AF_INET;\n    sa.sin.sin_port = htons(si.remotePort);\n    sa.sin.sin_addr.s_addr = si.remoteIPaddress.v4Add.Val;\n  } else {\n    /* TODO(alashkin): do something with _potential_ IPv6 */\n    memset(&sa, 0, sizeof(sa));\n  }\n\n  mg_if_accept_tcp_cb(nc, (union socket_address *) &sa, sizeof(sa));\n\n  return mg_pic32_if_listen_tcp(lc, &lc->sa) >= 0;\n}\n\nchar *inet_ntoa(struct in_addr in) {\n  static char addr[17];\n  snprintf(addr, sizeof(addr), \"%d.%d.%d.%d\", (int) in.S_un.S_un_b.s_b1,\n           (int) in.S_un.S_un_b.s_b2, (int) in.S_un.S_un_b.s_b3,\n           (int) in.S_un.S_un_b.s_b4);\n  return addr;\n}\n\nstatic void mg_handle_send(struct mg_connection *nc) {\n  uint16_t bytes_written = 0;\n  if (nc->flags & MG_F_UDP) {\n    if (!TCPIP_UDP_RemoteBind(\n            (UDP_SOCKET) nc->sock,\n            nc->sa.sin.sin_family == AF_INET ? IP_ADDRESS_TYPE_IPV4\n                                             : IP_ADDRESS_TYPE_IPV6,\n            ntohs(nc->sa.sin.sin_port), (IP_MULTI_ADDRESS *) &nc->sa.sin)) {\n      nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n      return;\n    }\n    bytes_written = TCPIP_UDP_TxPutIsReady((UDP_SOCKET) nc->sock, 0);\n    if (bytes_written >= nc->send_mbuf.len) {\n      if (TCPIP_UDP_ArrayPut((UDP_SOCKET) nc->sock,\n                             (uint8_t *) nc->send_mbuf.buf,\n                             nc->send_mbuf.len) != nc->send_mbuf.len) {\n        nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n        bytes_written = 0;\n      }\n    }\n  } else {\n    bytes_written = TCPIP_TCP_FifoTxFreeGet((TCP_SOCKET) nc->sock);\n    if (bytes_written != 0) {\n      if (bytes_written > nc->send_mbuf.len) {\n        bytes_written = nc->send_mbuf.len;\n      }\n      if (TCPIP_TCP_ArrayPut((TCP_SOCKET) nc->sock,\n                             (uint8_t *) nc->send_mbuf.buf,\n                             bytes_written) != bytes_written) {\n        nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n        bytes_written = 0;\n      }\n    }\n  }\n\n  if (bytes_written != 0) {\n    mbuf_remove(&nc->send_mbuf, bytes_written);\n    mg_if_sent_cb(nc, bytes_written);\n  }\n}\n\nstatic void mg_handle_recv(struct mg_connection *nc) {\n  uint16_t bytes_read = 0;\n  uint8_t *buf = NULL;\n  if (nc->flags & MG_F_UDP) {\n    bytes_read = TCPIP_UDP_GetIsReady((UDP_SOCKET) nc->sock);\n    if (bytes_read != 0 &&\n        (nc->recv_mbuf_limit == -1 ||\n         nc->recv_mbuf.len + bytes_read < nc->recv_mbuf_limit)) {\n      buf = (uint8_t *) MG_MALLOC(bytes_read);\n      if (TCPIP_UDP_ArrayGet((UDP_SOCKET) nc->sock, buf, bytes_read) !=\n          bytes_read) {\n        nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n        bytes_read = 0;\n        MG_FREE(buf);\n      }\n    }\n  } else {\n    bytes_read = TCPIP_TCP_GetIsReady((TCP_SOCKET) nc->sock);\n    if (bytes_read != 0) {\n      if (nc->recv_mbuf_limit != -1 &&\n          nc->recv_mbuf_limit - nc->recv_mbuf.len > bytes_read) {\n        bytes_read = nc->recv_mbuf_limit - nc->recv_mbuf.len;\n      }\n      buf = (uint8_t *) MG_MALLOC(bytes_read);\n      if (TCPIP_TCP_ArrayGet((TCP_SOCKET) nc->sock, buf, bytes_read) !=\n          bytes_read) {\n        nc->flags |= MG_F_CLOSE_IMMEDIATELY;\n        MG_FREE(buf);\n        bytes_read = 0;\n      }\n    }\n  }\n\n  if (bytes_read != 0) {\n    mg_if_recv_tcp_cb(nc, buf, bytes_read, 1 /* own */);\n  }\n}\n\ntime_t mg_pic32_if_poll(struct mg_iface *iface, int timeout_ms) {\n  struct mg_mgr *mgr = iface->mgr;\n  double now = mg_time();\n  struct mg_connection *nc, *tmp;\n\n  for (nc = mgr->active_connections; nc != NULL; nc = tmp) {\n    tmp = nc->next;\n\n    if (nc->flags & MG_F_CONNECTING) {\n      /* processing connections */\n      if (nc->flags & MG_F_UDP ||\n          TCPIP_TCP_IsConnected((TCP_SOCKET) nc->sock)) {\n        mg_if_connect_cb(nc, 0);\n      }\n    } else if (nc->flags & MG_F_LISTENING) {\n      if (TCPIP_TCP_IsConnected((TCP_SOCKET) nc->sock)) {\n        /* accept new connections */\n        mg_accept_conn(nc);\n      }\n    } else {\n      if (nc->send_mbuf.len != 0) {\n        mg_handle_send(nc);\n      }\n\n      if (nc->recv_mbuf_limit == -1 ||\n          nc->recv_mbuf.len < nc->recv_mbuf_limit) {\n        mg_handle_recv(nc);\n      }\n    }\n  }\n\n  for (nc = mgr->active_connections; nc != NULL; nc = tmp) {\n    tmp = nc->next;\n    if ((nc->flags & MG_F_CLOSE_IMMEDIATELY) ||\n        (nc->send_mbuf.len == 0 && (nc->flags & MG_F_SEND_AND_CLOSE))) {\n      mg_close_conn(nc);\n    }\n  }\n\n  return now;\n}\n\nvoid mg_pic32_if_sock_set(struct mg_connection *nc, sock_t sock) {\n  nc->sock = sock;\n}\n\nvoid mg_pic32_if_get_conn_addr(struct mg_connection *nc, int remote,\n                               union socket_address *sa) {\n  /* TODO(alaskin): not implemented yet */\n}\n\nvoid mg_pic32_if_connect_tcp(struct mg_connection *nc,\n                             const union socket_address *sa) {\n  nc->sock = TCPIP_TCP_ClientOpen(\n      sa->sin.sin_family == AF_INET ? IP_ADDRESS_TYPE_IPV4\n                                    : IP_ADDRESS_TYPE_IPV6,\n      ntohs(sa->sin.sin_port), (IP_MULTI_ADDRESS *) &sa->sin);\n  nc->err = (nc->sock == INVALID_SOCKET) ? -1 : 0;\n}\n\nvoid mg_pic32_if_connect_udp(struct mg_connection *nc) {\n  nc->sock = TCPIP_UDP_ClientOpen(IP_ADDRESS_TYPE_ANY, 0, NULL);\n  nc->err = (nc->sock == INVALID_SOCKET) ? -1 : 0;\n}\n\n/* clang-format off */\n#define MG_PIC32_IFACE_VTABLE                                   \\\n  {                                                             \\\n    mg_pic32_if_init,                                           \\\n    mg_pic32_if_free,                                           \\\n    mg_pic32_if_add_conn,                                       \\\n    mg_pic32_if_remove_conn,                                    \\\n    mg_pic32_if_poll,                                           \\\n    mg_pic32_if_listen_tcp,                                     \\\n    mg_pic32_if_listen_udp,                                     \\\n    mg_pic32_if_connect_tcp,                                    \\\n    mg_pic32_if_connect_udp,                                    \\\n    mg_pic32_if_tcp_send,                                       \\\n    mg_pic32_if_udp_send,                                       \\\n    mg_pic32_if_recved,                                         \\\n    mg_pic32_if_create_conn,                                    \\\n    mg_pic32_if_destroy_conn,                                   \\\n    mg_pic32_if_sock_set,                                       \\\n    mg_pic32_if_get_conn_addr,                                  \\\n  }\n/* clang-format on */\n\nconst struct mg_iface_vtable mg_pic32_iface_vtable = MG_PIC32_IFACE_VTABLE;\n#if MG_NET_IF == MG_NET_IF_PIC32\nconst struct mg_iface_vtable mg_default_iface_vtable = MG_PIC32_IFACE_VTABLE;\n#endif\n\n#endif /* MG_ENABLE_NET_IF_PIC32 */\n"], "filenames": ["mongoose/mongoose.c"], "buggy_code_start_loc": [5963], "buggy_code_end_loc": [5963], "fixing_code_start_loc": [5964], "fixing_code_end_loc": [5970], "type": "CWE-416", "message": "Use-after-free vulnerability in the mg_http_multipart_wait_for_boundary function in mongoose.c in Cesanta Mongoose Embedded Web Server Library 6.7 and earlier and Mongoose OS 1.2 and earlier allows remote attackers to cause a denial of service (crash) via a multipart/form-data POST request without a MIME boundary string.", "other": {"cve": {"id": "CVE-2017-7185", "sourceIdentifier": "cve@mitre.org", "published": "2017-04-10T15:59:00.503", "lastModified": "2018-10-09T20:01:43.417", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Use-after-free vulnerability in the mg_http_multipart_wait_for_boundary function in mongoose.c in Cesanta Mongoose Embedded Web Server Library 6.7 and earlier and Mongoose OS 1.2 and earlier allows remote attackers to cause a denial of service (crash) via a multipart/form-data POST request without a MIME boundary string."}, {"lang": "es", "value": "Vulnerabilidad use-after-free en la funci\u00f3n mg_http_multipart_wait_for_boundary en mongoose.c en Cesanta Mongoose Embedded Web Server Library 6.7 y anteriores y Mongoose OS 1.2 y anteriores permite a los atacantes remotos provocar una denegaci\u00f3n de servicio (ca\u00edda) a trav\u00e9s de un multipart/form-data POST solicitud sin una cadena de l\u00edmite MIME."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:cesanta:mongoose_embedded_web_server_library:*:*:*:*:*:*:*:*", "versionEndIncluding": "6.7", "matchCriteriaId": "C372E1D0-CC94-4C7F-8EDE-A25656D73A28"}, {"vulnerable": true, "criteria": "cpe:2.3:o:cesanta:mongoose_os:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.2", "matchCriteriaId": "39C742BC-F245-41E6-8332-9915E2EB0963"}]}]}], "references": [{"url": "http://www.securityfocus.com/archive/1/540355/100/0/threaded", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/97370", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/cesanta/mongoose-os/commit/042eb437973a202d00589b13d628181c6de5cf5b", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/cesanta/mongoose/commit/b8402ed0733e3f244588b61ad5fedd093e3cf9cc", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.compass-security.com/fileadmin/Datein/Research/Advisories/CVE-2017-7185_mongoose_os_use_after_free.txt", "source": "cve@mitre.org", "tags": ["Exploit", "Technical Description", "Third Party Advisory"]}, {"url": "https://www.exploit-db.com/exploits/41826/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/cesanta/mongoose-os/commit/042eb437973a202d00589b13d628181c6de5cf5b"}}