{"buggy_code": ["/*\t$OpenBSD: table.c,v 1.48 2019/01/10 07:40:52 eric Exp $\t*/\n\n/*\n * Copyright (c) 2013 Eric Faurot <eric@openbsd.org>\n * Copyright (c) 2008 Gilles Chehade <gilles@poolp.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/queue.h>\n#include <sys/tree.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <net/if.h>\n\n#include <errno.h>\n#include <event.h>\n#include <imsg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <regex.h>\n#include <limits.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"smtpd.h\"\n#include \"log.h\"\n\nstruct table_backend *table_backend_lookup(const char *);\n\nextern struct table_backend table_backend_static;\nextern struct table_backend table_backend_db;\nextern struct table_backend table_backend_getpwnam;\nextern struct table_backend table_backend_proc;\n\nstatic const char * table_service_name(enum table_service);\nstatic int table_parse_lookup(enum table_service, const char *, const char *,\n    union lookup *);\nstatic int parse_sockaddr(struct sockaddr *, int, const char *);\n\nstatic unsigned int last_table_id = 0;\n\nstatic struct table_backend *backends[] = {\n\t&table_backend_static,\n\t&table_backend_db,\n\t&table_backend_getpwnam,\n\t&table_backend_proc,\n\tNULL\n};\n\nstruct table_backend *\ntable_backend_lookup(const char *backend)\n{\n\tint i;\n\n\tif (!strcmp(backend, \"file\"))\n\t\tbackend = \"static\";\n\n\tfor (i = 0; backends[i]; i++)\n\t\tif (!strcmp(backends[i]->name, backend))\n\t\t\treturn (backends[i]);\n\n\treturn NULL;\n}\n\nstatic const char *\ntable_service_name(enum table_service s)\n{\n\tswitch (s) {\n\tcase K_NONE:\t\treturn \"NONE\";\n\tcase K_ALIAS:\t\treturn \"ALIAS\";\n\tcase K_DOMAIN:\t\treturn \"DOMAIN\";\n\tcase K_CREDENTIALS:\treturn \"CREDENTIALS\";\n\tcase K_NETADDR:\t\treturn \"NETADDR\";\n\tcase K_USERINFO:\treturn \"USERINFO\";\n\tcase K_SOURCE:\t\treturn \"SOURCE\";\n\tcase K_MAILADDR:\treturn \"MAILADDR\";\n\tcase K_ADDRNAME:\treturn \"ADDRNAME\";\n\tcase K_MAILADDRMAP:\treturn \"MAILADDRMAP\";\n\tcase K_RELAYHOST:\treturn \"RELAYHOST\";\n\tcase K_STRING:\t\treturn \"STRING\";\n\tcase K_REGEX:\t\treturn \"REGEX\";\n\t}\n\treturn \"???\";\n}\n\nstruct table *\ntable_find(struct smtpd *conf, const char *name)\n{\n\treturn dict_get(conf->sc_tables_dict, name);\n}\n\nint\ntable_match(struct table *table, enum table_service kind, const char *key)\n{\n\treturn table_lookup(table, kind, key, NULL);\n}\n\nint\ntable_lookup(struct table *table, enum table_service kind, const char *key,\n    union lookup *lk)\n{\n\tchar lkey[1024], *buf = NULL;\n\tint r;\n\n\tr = -1;\n\tif (table->t_backend->lookup == NULL)\n\t\terrno = ENOTSUP;\n\telse if (!lowercase(lkey, key, sizeof lkey)) {\n\t\tlog_warnx(\"warn: lookup key too long: %s\", key);\n\t\terrno = EINVAL;\n\t}\n\telse\n\t\tr = table->t_backend->lookup(table, kind, lkey, lk ? &buf : NULL);\n\n\tif (r == 1) {\n\t\tlog_trace(TRACE_LOOKUP, \"lookup: %s \\\"%s\\\" as %s in table %s:%s -> %s%s%s\",\n\t\t    lk ? \"lookup\" : \"match\",\n\t\t    key,\n\t\t    table_service_name(kind),\n\t\t    table->t_backend->name,\n\t\t    table->t_name,\n\t\t    lk ? \"\\\"\" : \"\",\n\t\t    lk ? buf : \"true\",\n\t\t    lk ? \"\\\"\" : \"\");\n\t\tif (buf)\n\t\t\tr = table_parse_lookup(kind, lkey, buf, lk);\n\t}\n\telse\n\t\tlog_trace(TRACE_LOOKUP, \"lookup: %s \\\"%s\\\" as %s in table %s:%s -> %s%s\",\n\t\t    lk ? \"lookup\" : \"match\",\n\t\t    key,\n\t\t    table_service_name(kind),\n\t\t    table->t_backend->name,\n\t\t    table->t_name,\n\t\t    (r == -1) ? \"error: \" : (lk ? \"none\" : \"false\"),\n\t\t    (r == -1) ? strerror(errno) : \"\");\n\n\tfree(buf);\n\n\treturn (r);\n}\n\nint\ntable_fetch(struct table *table, enum table_service kind, union lookup *lk)\n{\n\tchar *buf = NULL;\n\tint r;\n\n\tr = -1;\n\tif (table->t_backend->fetch == NULL)\n\t\terrno = ENOTSUP;\n\telse\n\t\tr = table->t_backend->fetch(table, kind, &buf);\n\n\tif (r == 1) {\n\t\tlog_trace(TRACE_LOOKUP, \"lookup: fetch %s from table %s:%s -> \\\"%s\\\"\",\n\t\t    table_service_name(kind),\n\t\t    table->t_backend->name,\n\t\t    table->t_name,\n\t\t    buf);\n\t\tr = table_parse_lookup(kind, NULL, buf, lk);\n\t}\n\telse\n\t\tlog_trace(TRACE_LOOKUP, \"lookup: fetch %s from table %s:%s -> %s%s\",\n\t\t    table_service_name(kind),\n\t\t    table->t_backend->name,\n\t\t    table->t_name,\n\t\t    (r == -1) ? \"error: \" : \"none\",\n\t\t    (r == -1) ? strerror(errno) : \"\");\n\n\tfree(buf);\n\n\treturn (r);\n}\n\nstruct table *\ntable_create(struct smtpd *conf, const char *backend, const char *name,\n    const char *config)\n{\n\tstruct table\t\t*t;\n\tstruct table_backend\t*tb;\n\tchar\t\t\t path[LINE_MAX];\n\tsize_t\t\t\t n;\n\tstruct stat\t\t sb;\n\n\tif (name && table_find(conf, name))\n\t\tfatalx(\"table_create: table \\\"%s\\\" already defined\", name);\n\n\tif ((tb = table_backend_lookup(backend)) == NULL) {\n\t\tif ((size_t)snprintf(path, sizeof(path), PATH_LIBEXEC\"/table-%s\",\n\t\t\tbackend) >= sizeof(path)) {\n\t\t\tfatalx(\"table_create: path too long \\\"\"\n\t\t\t    PATH_LIBEXEC\"/table-%s\\\"\", backend);\n\t\t}\n\t\tif (stat(path, &sb) == 0) {\n\t\t\ttb = table_backend_lookup(\"proc\");\n\t\t\t(void)strlcpy(path, backend, sizeof(path));\n\t\t\tif (config) {\n\t\t\t\t(void)strlcat(path, \":\", sizeof(path));\n\t\t\t\tif (strlcat(path, config, sizeof(path))\n\t\t\t\t    >= sizeof(path))\n\t\t\t\t\tfatalx(\"table_create: config file path too long\");\n\t\t\t}\n\t\t\tconfig = path;\n\t\t}\n\t}\n\n\tif (tb == NULL)\n\t\tfatalx(\"table_create: backend \\\"%s\\\" does not exist\", backend);\n\n\tt = xcalloc(1, sizeof(*t));\n\tt->t_backend = tb;\n\n\tif (config) {\n\t\tif (strlcpy(t->t_config, config, sizeof t->t_config)\n\t\t    >= sizeof t->t_config)\n\t\t\tfatalx(\"table_create: table config \\\"%s\\\" too large\",\n\t\t\t    t->t_config);\n\t}\n\n\tif (strcmp(tb->name, \"static\") != 0)\n\t\tt->t_type = T_DYNAMIC;\n\n\tif (name == NULL)\n\t\t(void)snprintf(t->t_name, sizeof(t->t_name), \"<dynamic:%u>\",\n\t\t    last_table_id++);\n\telse {\n\t\tn = strlcpy(t->t_name, name, sizeof(t->t_name));\n\t\tif (n >= sizeof(t->t_name))\n\t\t\tfatalx(\"table_create: table name too long\");\n\t}\n\n\tdict_set(conf->sc_tables_dict, t->t_name, t);\n\n\treturn (t);\n}\n\nvoid\ntable_destroy(struct smtpd *conf, struct table *t)\n{\n\tdict_xpop(conf->sc_tables_dict, t->t_name);\n\tfree(t);\n}\n\nint\ntable_config(struct table *t)\n{\n\tif (t->t_backend->config == NULL)\n\t\treturn (1);\n\treturn (t->t_backend->config(t));\n}\n\nvoid\ntable_add(struct table *t, const char *key, const char *val)\n{\n\tif (t->t_backend->add == NULL)\n\t\tfatalx(\"table_add: cannot add to table\");\n\n\tif (t->t_backend->add(t, key, val) == 0)\n\t\tlog_warnx(\"warn: failed to add \\\"%s\\\" in table \\\"%s\\\"\", key, t->t_name);\n}\n\nvoid\ntable_dump(struct table *t)\n{\n\tconst char *type;\n\tchar buf[LINE_MAX];\n\n\tswitch(t->t_type) {\n\tcase T_NONE:\n\t\ttype = \"NONE\";\n\t\tbreak;\n\tcase T_DYNAMIC:\n\t\ttype = \"DYNAMIC\";\n\t\tbreak;\n\tcase T_LIST:\n\t\ttype = \"LIST\";\n\t\tbreak;\n\tcase T_HASH:\n\t\ttype = \"HASH\";\n\t\tbreak;\n\tdefault:\n\t\ttype = \"???\";\n\t\tbreak;\n\t}\n\n\tif (t->t_config[0])\n\t\tsnprintf(buf, sizeof(buf), \" config=\\\"%s\\\"\", t->t_config);\n\telse\n\t\tbuf[0] = '\\0';\n\n\tlog_debug(\"TABLE \\\"%s\\\" backend=%s type=%s%s\", t->t_name,\n\t    t->t_backend->name, type, buf);\n\n\tif (t->t_backend->dump)\n\t\tt->t_backend->dump(t);\n}\n\nint\ntable_check_type(struct table *t, uint32_t mask)\n{\n\treturn t->t_type & mask;\n}\n\nint\ntable_check_service(struct table *t, uint32_t mask)\n{\n\treturn t->t_backend->services & mask;\n}\n\nint\ntable_check_use(struct table *t, uint32_t tmask, uint32_t smask)\n{\n\treturn table_check_type(t, tmask) && table_check_service(t, smask);\n}\n\nint\ntable_open(struct table *t)\n{\n\tif (t->t_backend->open == NULL)\n\t\treturn (1);\n\treturn (t->t_backend->open(t));\n}\n\nvoid\ntable_close(struct table *t)\n{\n\tif (t->t_backend->close)\n\t\tt->t_backend->close(t);\n}\n\nint\ntable_update(struct table *t)\n{\n\tif (t->t_backend->update == NULL)\n\t\treturn (1);\n\treturn (t->t_backend->update(t));\n}\n\n\n/*\n * quick reminder:\n * in *_match() s1 comes from session, s2 comes from table\n */\n\nint\ntable_domain_match(const char *s1, const char *s2)\n{\n\treturn hostname_match(s1, s2);\n}\n\nint\ntable_mailaddr_match(const char *s1, const char *s2)\n{\n\tstruct mailaddr m1;\n\tstruct mailaddr m2;\n\n\tif (!text_to_mailaddr(&m1, s1))\n\t\treturn 0;\n\tif (!text_to_mailaddr(&m2, s2))\n\t\treturn 0;\n\treturn mailaddr_match(&m1, &m2);\n}\n\nstatic int table_match_mask(struct sockaddr_storage *, struct netaddr *);\nstatic int table_inet4_match(struct sockaddr_in *, struct netaddr *);\nstatic int table_inet6_match(struct sockaddr_in6 *, struct netaddr *);\n\nint\ntable_netaddr_match(const char *s1, const char *s2)\n{\n\tstruct netaddr n1;\n\tstruct netaddr n2;\n\n\tif (strcasecmp(s1, s2) == 0)\n\t\treturn 1;\n\tif (!text_to_netaddr(&n1, s1))\n\t\treturn 0;\n\tif (!text_to_netaddr(&n2, s2))\n\t\treturn 0;\n\tif (n1.ss.ss_family != n2.ss.ss_family)\n\t\treturn 0;\n\tif (n1.ss.ss_len != n2.ss.ss_len)\n\t\treturn 0;\n\treturn table_match_mask(&n1.ss, &n2);\n}\n\nstatic int\ntable_match_mask(struct sockaddr_storage *ss, struct netaddr *ssmask)\n{\n\tif (ss->ss_family == AF_INET)\n\t\treturn table_inet4_match((struct sockaddr_in *)ss, ssmask);\n\n\tif (ss->ss_family == AF_INET6)\n\t\treturn table_inet6_match((struct sockaddr_in6 *)ss, ssmask);\n\n\treturn (0);\n}\n\nstatic int\ntable_inet4_match(struct sockaddr_in *ss, struct netaddr *ssmask)\n{\n\tin_addr_t mask;\n\tint i;\n\n\t/* a.b.c.d/8 -> htonl(0xff000000) */\n\tmask = 0;\n\tfor (i = 0; i < ssmask->bits; ++i)\n\t\tmask = (mask >> 1) | 0x80000000;\n\tmask = htonl(mask);\n\n\t/* (addr & mask) == (net & mask) */\n\tif ((ss->sin_addr.s_addr & mask) ==\n\t    (((struct sockaddr_in *)ssmask)->sin_addr.s_addr & mask))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int\ntable_inet6_match(struct sockaddr_in6 *ss, struct netaddr *ssmask)\n{\n\tstruct in6_addr\t*in;\n\tstruct in6_addr\t*inmask;\n\tstruct in6_addr\t mask;\n\tint\t\t i;\n\n\tmemset(&mask, 0, sizeof(mask));\n\tfor (i = 0; i < ssmask->bits / 8; i++)\n\t\tmask.s6_addr[i] = 0xff;\n\ti = ssmask->bits % 8;\n\tif (i)\n\t\tmask.s6_addr[ssmask->bits / 8] = 0xff00 >> i;\n\n\tin = &ss->sin6_addr;\n\tinmask = &((struct sockaddr_in6 *)&ssmask->ss)->sin6_addr;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif ((in->s6_addr[i] & mask.s6_addr[i]) !=\n\t\t    (inmask->s6_addr[i] & mask.s6_addr[i]))\n\t\t\treturn (0);\n\t}\n\n\treturn (1);\n}\n\nint\ntable_regex_match(const char *string, const char *pattern)\n{\n\tregex_t preg;\n\tint\tcflags = REG_EXTENDED|REG_NOSUB;\n\n\tif (strncmp(pattern, \"(?i)\", 4) == 0) {\n\t\tcflags |= REG_ICASE;\n\t\tpattern += 4;\n\t}\n\n\tif (regcomp(&preg, pattern, cflags) != 0)\n\t\treturn (0);\n\n\tif (regexec(&preg, string, 0, NULL, 0) != 0)\n\t\treturn (0);\n\n\treturn (1);\n}\n\nvoid\ntable_dump_all(struct smtpd *conf)\n{\n\tstruct table\t*t;\n\tvoid\t\t*iter;\n\n\titer = NULL;\n\twhile (dict_iter(conf->sc_tables_dict, &iter, NULL, (void **)&t))\n\t\ttable_dump(t);\n}\n\nvoid\ntable_open_all(struct smtpd *conf)\n{\n\tstruct table\t*t;\n\tvoid\t\t*iter;\n\n\titer = NULL;\n\twhile (dict_iter(conf->sc_tables_dict, &iter, NULL, (void **)&t))\n\t\tif (!table_open(t))\n\t\t\tfatalx(\"failed to open table %s\", t->t_name);\n}\n\nvoid\ntable_close_all(struct smtpd *conf)\n{\n\tstruct table\t*t;\n\tvoid\t\t*iter;\n\n\titer = NULL;\n\twhile (dict_iter(conf->sc_tables_dict, &iter, NULL, (void **)&t))\n\t\ttable_close(t);\n}\n\nstatic int\ntable_parse_lookup(enum table_service service, const char *key,\n    const char *line, union lookup *lk)\n{\n\tchar\tbuffer[LINE_MAX], *p;\n\tsize_t\tlen;\n\n\tlen = strlen(line);\n\n\tswitch (service) {\n\tcase K_ALIAS:\n\t\tlk->expand = calloc(1, sizeof(*lk->expand));\n\t\tif (lk->expand == NULL)\n\t\t\treturn (-1);\n\t\tif (!expand_line(lk->expand, line, 1)) {\n\t\t\texpand_free(lk->expand);\n\t\t\treturn (-1);\n\t\t}\n\t\treturn (1);\n\n\tcase K_DOMAIN:\n\t\tif (strlcpy(lk->domain.name, line, sizeof(lk->domain.name))\n\t\t    >= sizeof(lk->domain.name))\n\t\t\treturn (-1);\n\t\treturn (1);\n\n\tcase K_CREDENTIALS:\n\n\t\t/* credentials are stored as user:password */\n\t\tif (len < 3)\n\t\t\treturn (-1);\n\n\t\t/* too big to fit in a smtp session line */\n\t\tif (len >= LINE_MAX)\n\t\t\treturn (-1);\n\n\t\tp = strchr(line, ':');\n\t\tif (p == NULL) {\n\t\t\tif (strlcpy(lk->creds.username, key, sizeof (lk->creds.username))\n\t\t\t    >= sizeof (lk->creds.username))\n\t\t\t\treturn (-1);\n\t\t\tif (strlcpy(lk->creds.password, line, sizeof(lk->creds.password))\n\t\t\t    >= sizeof(lk->creds.password))\n\t\t\t\treturn (-1);\n\t\t\treturn (1);\n\t\t}\n\n\t\tif (p == line || p == line + len - 1)\n\t\t\treturn (-1);\n\n\t\tmemmove(lk->creds.username, line, p - line);\n\t\tlk->creds.username[p - line] = '\\0';\n\n\t\tif (strlcpy(lk->creds.password, p+1, sizeof(lk->creds.password))\n\t\t    >= sizeof(lk->creds.password))\n\t\t\treturn (-1);\n\n\t\treturn (1);\n\n\tcase K_NETADDR:\n\t\tif (!text_to_netaddr(&lk->netaddr, line))\n\t\t\treturn (-1);\n\t\treturn (1);\n\n\tcase K_USERINFO:\n\t\tif (!bsnprintf(buffer, sizeof(buffer), \"%s:%s\", key, line))\n\t\t\treturn (-1);\n\t\tif (!text_to_userinfo(&lk->userinfo, buffer))\n\t\t\treturn (-1);\n \t\treturn (1);\n\n\tcase K_SOURCE:\n\t\tif (parse_sockaddr((struct sockaddr *)&lk->source.addr,\n\t\t    PF_UNSPEC, line) == -1)\n\t\t\treturn (-1);\n\t\treturn (1);\n\n\tcase K_MAILADDR:\n\t\tif (!text_to_mailaddr(&lk->mailaddr, line))\n\t\t\treturn (-1);\n\t\treturn (1);\n\n\tcase K_MAILADDRMAP:\n\t\tlk->maddrmap = calloc(1, sizeof(*lk->maddrmap));\n\t\tif (lk->maddrmap == NULL)\n\t\t\treturn (-1);\n\t\tmaddrmap_init(lk->maddrmap);\n\t\tif (!mailaddr_line(lk->maddrmap, line)) {\n\t\t\tmaddrmap_free(lk->maddrmap);\n\t\t\treturn (-1);\n\t\t}\n\t\treturn (1);\n\n\tcase K_ADDRNAME:\n\t\tif (parse_sockaddr((struct sockaddr *)&lk->addrname.addr,\n\t\t    PF_UNSPEC, key) == -1)\n\t\t\treturn (-1);\n\t\tif (strlcpy(lk->addrname.name, line, sizeof(lk->addrname.name))\n\t\t    >= sizeof(lk->addrname.name))\n\t\t\treturn (-1);\n\t\treturn (1);\n\n\tcase K_RELAYHOST:\n\t\tif (strlcpy(lk->relayhost, line, sizeof(lk->relayhost))\n\t\t    >= sizeof(lk->relayhost))\n\t\t\treturn (-1);\n\t\treturn (1);\n\n\tdefault:\n\t\treturn (-1);\n\t}\n}\n\nstatic int\nparse_sockaddr(struct sockaddr *sa, int family, const char *str)\n{\n\tstruct in_addr\t\t ina;\n\tstruct in6_addr\t\t in6a;\n\tstruct sockaddr_in\t*sin;\n\tstruct sockaddr_in6\t*sin6;\n\tchar\t\t\t*cp, *str2;\n\tconst char\t\t*errstr;\n\n\tswitch (family) {\n\tcase PF_UNSPEC:\n\t\tif (parse_sockaddr(sa, PF_INET, str) == 0)\n\t\t\treturn (0);\n\t\treturn parse_sockaddr(sa, PF_INET6, str);\n\n\tcase PF_INET:\n\t\tif (inet_pton(PF_INET, str, &ina) != 1)\n\t\t\treturn (-1);\n\n\t\tsin = (struct sockaddr_in *)sa;\n\t\tmemset(sin, 0, sizeof *sin);\n\t\tsin->sin_len = sizeof(struct sockaddr_in);\n\t\tsin->sin_family = PF_INET;\n\t\tsin->sin_addr.s_addr = ina.s_addr;\n\t\treturn (0);\n\n\tcase PF_INET6:\n\t\tif (strncasecmp(\"ipv6:\", str, 5) == 0)\n\t\t\tstr += 5;\n\t\tcp = strchr(str, SCOPE_DELIMITER);\n\t\tif (cp) {\n\t\t\tstr2 = strdup(str);\n\t\t\tif (str2 == NULL)\n\t\t\t\treturn (-1);\n\t\t\tstr2[cp - str] = '\\0';\n\t\t\tif (inet_pton(PF_INET6, str2, &in6a) != 1) {\n\t\t\t\tfree(str2);\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tcp++;\n\t\t\tfree(str2);\n\t\t} else if (inet_pton(PF_INET6, str, &in6a) != 1)\n\t\t\treturn (-1);\n\n\t\tsin6 = (struct sockaddr_in6 *)sa;\n\t\tmemset(sin6, 0, sizeof *sin6);\n\t\tsin6->sin6_len = sizeof(struct sockaddr_in6);\n\t\tsin6->sin6_family = PF_INET6;\n\t\tsin6->sin6_addr = in6a;\n\n\t\tif (cp == NULL)\n\t\t\treturn (0);\n\n\t\tif (IN6_IS_ADDR_LINKLOCAL(&in6a) ||\n\t\t    IN6_IS_ADDR_MC_LINKLOCAL(&in6a) ||\n\t\t    IN6_IS_ADDR_MC_INTFACELOCAL(&in6a))\n\t\t\tif ((sin6->sin6_scope_id = if_nametoindex(cp)))\n\t\t\t\treturn (0);\n\n\t\tsin6->sin6_scope_id = strtonum(cp, 0, UINT32_MAX, &errstr);\n\t\tif (errstr)\n\t\t\treturn (-1);\n\t\treturn (0);\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn (-1);\n}\n"], "fixing_code": ["/*\t$OpenBSD: table.c,v 1.49 2020/12/23 08:12:14 martijn Exp $\t*/\n\n/*\n * Copyright (c) 2013 Eric Faurot <eric@openbsd.org>\n * Copyright (c) 2008 Gilles Chehade <gilles@poolp.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n#include <sys/queue.h>\n#include <sys/tree.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <net/if.h>\n\n#include <errno.h>\n#include <event.h>\n#include <imsg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <regex.h>\n#include <limits.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"smtpd.h\"\n#include \"log.h\"\n\nstruct table_backend *table_backend_lookup(const char *);\n\nextern struct table_backend table_backend_static;\nextern struct table_backend table_backend_db;\nextern struct table_backend table_backend_getpwnam;\nextern struct table_backend table_backend_proc;\n\nstatic const char * table_service_name(enum table_service);\nstatic int table_parse_lookup(enum table_service, const char *, const char *,\n    union lookup *);\nstatic int parse_sockaddr(struct sockaddr *, int, const char *);\n\nstatic unsigned int last_table_id = 0;\n\nstatic struct table_backend *backends[] = {\n\t&table_backend_static,\n\t&table_backend_db,\n\t&table_backend_getpwnam,\n\t&table_backend_proc,\n\tNULL\n};\n\nstruct table_backend *\ntable_backend_lookup(const char *backend)\n{\n\tint i;\n\n\tif (!strcmp(backend, \"file\"))\n\t\tbackend = \"static\";\n\n\tfor (i = 0; backends[i]; i++)\n\t\tif (!strcmp(backends[i]->name, backend))\n\t\t\treturn (backends[i]);\n\n\treturn NULL;\n}\n\nstatic const char *\ntable_service_name(enum table_service s)\n{\n\tswitch (s) {\n\tcase K_NONE:\t\treturn \"NONE\";\n\tcase K_ALIAS:\t\treturn \"ALIAS\";\n\tcase K_DOMAIN:\t\treturn \"DOMAIN\";\n\tcase K_CREDENTIALS:\treturn \"CREDENTIALS\";\n\tcase K_NETADDR:\t\treturn \"NETADDR\";\n\tcase K_USERINFO:\treturn \"USERINFO\";\n\tcase K_SOURCE:\t\treturn \"SOURCE\";\n\tcase K_MAILADDR:\treturn \"MAILADDR\";\n\tcase K_ADDRNAME:\treturn \"ADDRNAME\";\n\tcase K_MAILADDRMAP:\treturn \"MAILADDRMAP\";\n\tcase K_RELAYHOST:\treturn \"RELAYHOST\";\n\tcase K_STRING:\t\treturn \"STRING\";\n\tcase K_REGEX:\t\treturn \"REGEX\";\n\t}\n\treturn \"???\";\n}\n\nstruct table *\ntable_find(struct smtpd *conf, const char *name)\n{\n\treturn dict_get(conf->sc_tables_dict, name);\n}\n\nint\ntable_match(struct table *table, enum table_service kind, const char *key)\n{\n\treturn table_lookup(table, kind, key, NULL);\n}\n\nint\ntable_lookup(struct table *table, enum table_service kind, const char *key,\n    union lookup *lk)\n{\n\tchar lkey[1024], *buf = NULL;\n\tint r;\n\n\tr = -1;\n\tif (table->t_backend->lookup == NULL)\n\t\terrno = ENOTSUP;\n\telse if (!lowercase(lkey, key, sizeof lkey)) {\n\t\tlog_warnx(\"warn: lookup key too long: %s\", key);\n\t\terrno = EINVAL;\n\t}\n\telse\n\t\tr = table->t_backend->lookup(table, kind, lkey, lk ? &buf : NULL);\n\n\tif (r == 1) {\n\t\tlog_trace(TRACE_LOOKUP, \"lookup: %s \\\"%s\\\" as %s in table %s:%s -> %s%s%s\",\n\t\t    lk ? \"lookup\" : \"match\",\n\t\t    key,\n\t\t    table_service_name(kind),\n\t\t    table->t_backend->name,\n\t\t    table->t_name,\n\t\t    lk ? \"\\\"\" : \"\",\n\t\t    lk ? buf : \"true\",\n\t\t    lk ? \"\\\"\" : \"\");\n\t\tif (buf)\n\t\t\tr = table_parse_lookup(kind, lkey, buf, lk);\n\t}\n\telse\n\t\tlog_trace(TRACE_LOOKUP, \"lookup: %s \\\"%s\\\" as %s in table %s:%s -> %s%s\",\n\t\t    lk ? \"lookup\" : \"match\",\n\t\t    key,\n\t\t    table_service_name(kind),\n\t\t    table->t_backend->name,\n\t\t    table->t_name,\n\t\t    (r == -1) ? \"error: \" : (lk ? \"none\" : \"false\"),\n\t\t    (r == -1) ? strerror(errno) : \"\");\n\n\tfree(buf);\n\n\treturn (r);\n}\n\nint\ntable_fetch(struct table *table, enum table_service kind, union lookup *lk)\n{\n\tchar *buf = NULL;\n\tint r;\n\n\tr = -1;\n\tif (table->t_backend->fetch == NULL)\n\t\terrno = ENOTSUP;\n\telse\n\t\tr = table->t_backend->fetch(table, kind, &buf);\n\n\tif (r == 1) {\n\t\tlog_trace(TRACE_LOOKUP, \"lookup: fetch %s from table %s:%s -> \\\"%s\\\"\",\n\t\t    table_service_name(kind),\n\t\t    table->t_backend->name,\n\t\t    table->t_name,\n\t\t    buf);\n\t\tr = table_parse_lookup(kind, NULL, buf, lk);\n\t}\n\telse\n\t\tlog_trace(TRACE_LOOKUP, \"lookup: fetch %s from table %s:%s -> %s%s\",\n\t\t    table_service_name(kind),\n\t\t    table->t_backend->name,\n\t\t    table->t_name,\n\t\t    (r == -1) ? \"error: \" : \"none\",\n\t\t    (r == -1) ? strerror(errno) : \"\");\n\n\tfree(buf);\n\n\treturn (r);\n}\n\nstruct table *\ntable_create(struct smtpd *conf, const char *backend, const char *name,\n    const char *config)\n{\n\tstruct table\t\t*t;\n\tstruct table_backend\t*tb;\n\tchar\t\t\t path[LINE_MAX];\n\tsize_t\t\t\t n;\n\tstruct stat\t\t sb;\n\n\tif (name && table_find(conf, name))\n\t\tfatalx(\"table_create: table \\\"%s\\\" already defined\", name);\n\n\tif ((tb = table_backend_lookup(backend)) == NULL) {\n\t\tif ((size_t)snprintf(path, sizeof(path), PATH_LIBEXEC\"/table-%s\",\n\t\t\tbackend) >= sizeof(path)) {\n\t\t\tfatalx(\"table_create: path too long \\\"\"\n\t\t\t    PATH_LIBEXEC\"/table-%s\\\"\", backend);\n\t\t}\n\t\tif (stat(path, &sb) == 0) {\n\t\t\ttb = table_backend_lookup(\"proc\");\n\t\t\t(void)strlcpy(path, backend, sizeof(path));\n\t\t\tif (config) {\n\t\t\t\t(void)strlcat(path, \":\", sizeof(path));\n\t\t\t\tif (strlcat(path, config, sizeof(path))\n\t\t\t\t    >= sizeof(path))\n\t\t\t\t\tfatalx(\"table_create: config file path too long\");\n\t\t\t}\n\t\t\tconfig = path;\n\t\t}\n\t}\n\n\tif (tb == NULL)\n\t\tfatalx(\"table_create: backend \\\"%s\\\" does not exist\", backend);\n\n\tt = xcalloc(1, sizeof(*t));\n\tt->t_backend = tb;\n\n\tif (config) {\n\t\tif (strlcpy(t->t_config, config, sizeof t->t_config)\n\t\t    >= sizeof t->t_config)\n\t\t\tfatalx(\"table_create: table config \\\"%s\\\" too large\",\n\t\t\t    t->t_config);\n\t}\n\n\tif (strcmp(tb->name, \"static\") != 0)\n\t\tt->t_type = T_DYNAMIC;\n\n\tif (name == NULL)\n\t\t(void)snprintf(t->t_name, sizeof(t->t_name), \"<dynamic:%u>\",\n\t\t    last_table_id++);\n\telse {\n\t\tn = strlcpy(t->t_name, name, sizeof(t->t_name));\n\t\tif (n >= sizeof(t->t_name))\n\t\t\tfatalx(\"table_create: table name too long\");\n\t}\n\n\tdict_set(conf->sc_tables_dict, t->t_name, t);\n\n\treturn (t);\n}\n\nvoid\ntable_destroy(struct smtpd *conf, struct table *t)\n{\n\tdict_xpop(conf->sc_tables_dict, t->t_name);\n\tfree(t);\n}\n\nint\ntable_config(struct table *t)\n{\n\tif (t->t_backend->config == NULL)\n\t\treturn (1);\n\treturn (t->t_backend->config(t));\n}\n\nvoid\ntable_add(struct table *t, const char *key, const char *val)\n{\n\tif (t->t_backend->add == NULL)\n\t\tfatalx(\"table_add: cannot add to table\");\n\n\tif (t->t_backend->add(t, key, val) == 0)\n\t\tlog_warnx(\"warn: failed to add \\\"%s\\\" in table \\\"%s\\\"\", key, t->t_name);\n}\n\nvoid\ntable_dump(struct table *t)\n{\n\tconst char *type;\n\tchar buf[LINE_MAX];\n\n\tswitch(t->t_type) {\n\tcase T_NONE:\n\t\ttype = \"NONE\";\n\t\tbreak;\n\tcase T_DYNAMIC:\n\t\ttype = \"DYNAMIC\";\n\t\tbreak;\n\tcase T_LIST:\n\t\ttype = \"LIST\";\n\t\tbreak;\n\tcase T_HASH:\n\t\ttype = \"HASH\";\n\t\tbreak;\n\tdefault:\n\t\ttype = \"???\";\n\t\tbreak;\n\t}\n\n\tif (t->t_config[0])\n\t\tsnprintf(buf, sizeof(buf), \" config=\\\"%s\\\"\", t->t_config);\n\telse\n\t\tbuf[0] = '\\0';\n\n\tlog_debug(\"TABLE \\\"%s\\\" backend=%s type=%s%s\", t->t_name,\n\t    t->t_backend->name, type, buf);\n\n\tif (t->t_backend->dump)\n\t\tt->t_backend->dump(t);\n}\n\nint\ntable_check_type(struct table *t, uint32_t mask)\n{\n\treturn t->t_type & mask;\n}\n\nint\ntable_check_service(struct table *t, uint32_t mask)\n{\n\treturn t->t_backend->services & mask;\n}\n\nint\ntable_check_use(struct table *t, uint32_t tmask, uint32_t smask)\n{\n\treturn table_check_type(t, tmask) && table_check_service(t, smask);\n}\n\nint\ntable_open(struct table *t)\n{\n\tif (t->t_backend->open == NULL)\n\t\treturn (1);\n\treturn (t->t_backend->open(t));\n}\n\nvoid\ntable_close(struct table *t)\n{\n\tif (t->t_backend->close)\n\t\tt->t_backend->close(t);\n}\n\nint\ntable_update(struct table *t)\n{\n\tif (t->t_backend->update == NULL)\n\t\treturn (1);\n\treturn (t->t_backend->update(t));\n}\n\n\n/*\n * quick reminder:\n * in *_match() s1 comes from session, s2 comes from table\n */\n\nint\ntable_domain_match(const char *s1, const char *s2)\n{\n\treturn hostname_match(s1, s2);\n}\n\nint\ntable_mailaddr_match(const char *s1, const char *s2)\n{\n\tstruct mailaddr m1;\n\tstruct mailaddr m2;\n\n\tif (!text_to_mailaddr(&m1, s1))\n\t\treturn 0;\n\tif (!text_to_mailaddr(&m2, s2))\n\t\treturn 0;\n\treturn mailaddr_match(&m1, &m2);\n}\n\nstatic int table_match_mask(struct sockaddr_storage *, struct netaddr *);\nstatic int table_inet4_match(struct sockaddr_in *, struct netaddr *);\nstatic int table_inet6_match(struct sockaddr_in6 *, struct netaddr *);\n\nint\ntable_netaddr_match(const char *s1, const char *s2)\n{\n\tstruct netaddr n1;\n\tstruct netaddr n2;\n\n\tif (strcasecmp(s1, s2) == 0)\n\t\treturn 1;\n\tif (!text_to_netaddr(&n1, s1))\n\t\treturn 0;\n\tif (!text_to_netaddr(&n2, s2))\n\t\treturn 0;\n\tif (n1.ss.ss_family != n2.ss.ss_family)\n\t\treturn 0;\n\tif (n1.ss.ss_len != n2.ss.ss_len)\n\t\treturn 0;\n\treturn table_match_mask(&n1.ss, &n2);\n}\n\nstatic int\ntable_match_mask(struct sockaddr_storage *ss, struct netaddr *ssmask)\n{\n\tif (ss->ss_family == AF_INET)\n\t\treturn table_inet4_match((struct sockaddr_in *)ss, ssmask);\n\n\tif (ss->ss_family == AF_INET6)\n\t\treturn table_inet6_match((struct sockaddr_in6 *)ss, ssmask);\n\n\treturn (0);\n}\n\nstatic int\ntable_inet4_match(struct sockaddr_in *ss, struct netaddr *ssmask)\n{\n\tin_addr_t mask;\n\tint i;\n\n\t/* a.b.c.d/8 -> htonl(0xff000000) */\n\tmask = 0;\n\tfor (i = 0; i < ssmask->bits; ++i)\n\t\tmask = (mask >> 1) | 0x80000000;\n\tmask = htonl(mask);\n\n\t/* (addr & mask) == (net & mask) */\n\tif ((ss->sin_addr.s_addr & mask) ==\n\t    (((struct sockaddr_in *)ssmask)->sin_addr.s_addr & mask))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int\ntable_inet6_match(struct sockaddr_in6 *ss, struct netaddr *ssmask)\n{\n\tstruct in6_addr\t*in;\n\tstruct in6_addr\t*inmask;\n\tstruct in6_addr\t mask;\n\tint\t\t i;\n\n\tmemset(&mask, 0, sizeof(mask));\n\tfor (i = 0; i < ssmask->bits / 8; i++)\n\t\tmask.s6_addr[i] = 0xff;\n\ti = ssmask->bits % 8;\n\tif (i)\n\t\tmask.s6_addr[ssmask->bits / 8] = 0xff00 >> i;\n\n\tin = &ss->sin6_addr;\n\tinmask = &((struct sockaddr_in6 *)&ssmask->ss)->sin6_addr;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif ((in->s6_addr[i] & mask.s6_addr[i]) !=\n\t\t    (inmask->s6_addr[i] & mask.s6_addr[i]))\n\t\t\treturn (0);\n\t}\n\n\treturn (1);\n}\n\nint\ntable_regex_match(const char *string, const char *pattern)\n{\n\tregex_t preg;\n\tint\tcflags = REG_EXTENDED|REG_NOSUB;\n\tint ret;\n\n\tif (strncmp(pattern, \"(?i)\", 4) == 0) {\n\t\tcflags |= REG_ICASE;\n\t\tpattern += 4;\n\t}\n\n\tif (regcomp(&preg, pattern, cflags) != 0)\n\t\treturn (0);\n\n\tret = regexec(&preg, string, 0, NULL, 0);\n\n\tregfree(&preg);\n\n\tif (ret != 0)\n\t\treturn (0);\n\n\treturn (1);\n}\n\nvoid\ntable_dump_all(struct smtpd *conf)\n{\n\tstruct table\t*t;\n\tvoid\t\t*iter;\n\n\titer = NULL;\n\twhile (dict_iter(conf->sc_tables_dict, &iter, NULL, (void **)&t))\n\t\ttable_dump(t);\n}\n\nvoid\ntable_open_all(struct smtpd *conf)\n{\n\tstruct table\t*t;\n\tvoid\t\t*iter;\n\n\titer = NULL;\n\twhile (dict_iter(conf->sc_tables_dict, &iter, NULL, (void **)&t))\n\t\tif (!table_open(t))\n\t\t\tfatalx(\"failed to open table %s\", t->t_name);\n}\n\nvoid\ntable_close_all(struct smtpd *conf)\n{\n\tstruct table\t*t;\n\tvoid\t\t*iter;\n\n\titer = NULL;\n\twhile (dict_iter(conf->sc_tables_dict, &iter, NULL, (void **)&t))\n\t\ttable_close(t);\n}\n\nstatic int\ntable_parse_lookup(enum table_service service, const char *key,\n    const char *line, union lookup *lk)\n{\n\tchar\tbuffer[LINE_MAX], *p;\n\tsize_t\tlen;\n\n\tlen = strlen(line);\n\n\tswitch (service) {\n\tcase K_ALIAS:\n\t\tlk->expand = calloc(1, sizeof(*lk->expand));\n\t\tif (lk->expand == NULL)\n\t\t\treturn (-1);\n\t\tif (!expand_line(lk->expand, line, 1)) {\n\t\t\texpand_free(lk->expand);\n\t\t\treturn (-1);\n\t\t}\n\t\treturn (1);\n\n\tcase K_DOMAIN:\n\t\tif (strlcpy(lk->domain.name, line, sizeof(lk->domain.name))\n\t\t    >= sizeof(lk->domain.name))\n\t\t\treturn (-1);\n\t\treturn (1);\n\n\tcase K_CREDENTIALS:\n\n\t\t/* credentials are stored as user:password */\n\t\tif (len < 3)\n\t\t\treturn (-1);\n\n\t\t/* too big to fit in a smtp session line */\n\t\tif (len >= LINE_MAX)\n\t\t\treturn (-1);\n\n\t\tp = strchr(line, ':');\n\t\tif (p == NULL) {\n\t\t\tif (strlcpy(lk->creds.username, key, sizeof (lk->creds.username))\n\t\t\t    >= sizeof (lk->creds.username))\n\t\t\t\treturn (-1);\n\t\t\tif (strlcpy(lk->creds.password, line, sizeof(lk->creds.password))\n\t\t\t    >= sizeof(lk->creds.password))\n\t\t\t\treturn (-1);\n\t\t\treturn (1);\n\t\t}\n\n\t\tif (p == line || p == line + len - 1)\n\t\t\treturn (-1);\n\n\t\tmemmove(lk->creds.username, line, p - line);\n\t\tlk->creds.username[p - line] = '\\0';\n\n\t\tif (strlcpy(lk->creds.password, p+1, sizeof(lk->creds.password))\n\t\t    >= sizeof(lk->creds.password))\n\t\t\treturn (-1);\n\n\t\treturn (1);\n\n\tcase K_NETADDR:\n\t\tif (!text_to_netaddr(&lk->netaddr, line))\n\t\t\treturn (-1);\n\t\treturn (1);\n\n\tcase K_USERINFO:\n\t\tif (!bsnprintf(buffer, sizeof(buffer), \"%s:%s\", key, line))\n\t\t\treturn (-1);\n\t\tif (!text_to_userinfo(&lk->userinfo, buffer))\n\t\t\treturn (-1);\n \t\treturn (1);\n\n\tcase K_SOURCE:\n\t\tif (parse_sockaddr((struct sockaddr *)&lk->source.addr,\n\t\t    PF_UNSPEC, line) == -1)\n\t\t\treturn (-1);\n\t\treturn (1);\n\n\tcase K_MAILADDR:\n\t\tif (!text_to_mailaddr(&lk->mailaddr, line))\n\t\t\treturn (-1);\n\t\treturn (1);\n\n\tcase K_MAILADDRMAP:\n\t\tlk->maddrmap = calloc(1, sizeof(*lk->maddrmap));\n\t\tif (lk->maddrmap == NULL)\n\t\t\treturn (-1);\n\t\tmaddrmap_init(lk->maddrmap);\n\t\tif (!mailaddr_line(lk->maddrmap, line)) {\n\t\t\tmaddrmap_free(lk->maddrmap);\n\t\t\treturn (-1);\n\t\t}\n\t\treturn (1);\n\n\tcase K_ADDRNAME:\n\t\tif (parse_sockaddr((struct sockaddr *)&lk->addrname.addr,\n\t\t    PF_UNSPEC, key) == -1)\n\t\t\treturn (-1);\n\t\tif (strlcpy(lk->addrname.name, line, sizeof(lk->addrname.name))\n\t\t    >= sizeof(lk->addrname.name))\n\t\t\treturn (-1);\n\t\treturn (1);\n\n\tcase K_RELAYHOST:\n\t\tif (strlcpy(lk->relayhost, line, sizeof(lk->relayhost))\n\t\t    >= sizeof(lk->relayhost))\n\t\t\treturn (-1);\n\t\treturn (1);\n\n\tdefault:\n\t\treturn (-1);\n\t}\n}\n\nstatic int\nparse_sockaddr(struct sockaddr *sa, int family, const char *str)\n{\n\tstruct in_addr\t\t ina;\n\tstruct in6_addr\t\t in6a;\n\tstruct sockaddr_in\t*sin;\n\tstruct sockaddr_in6\t*sin6;\n\tchar\t\t\t*cp, *str2;\n\tconst char\t\t*errstr;\n\n\tswitch (family) {\n\tcase PF_UNSPEC:\n\t\tif (parse_sockaddr(sa, PF_INET, str) == 0)\n\t\t\treturn (0);\n\t\treturn parse_sockaddr(sa, PF_INET6, str);\n\n\tcase PF_INET:\n\t\tif (inet_pton(PF_INET, str, &ina) != 1)\n\t\t\treturn (-1);\n\n\t\tsin = (struct sockaddr_in *)sa;\n\t\tmemset(sin, 0, sizeof *sin);\n\t\tsin->sin_len = sizeof(struct sockaddr_in);\n\t\tsin->sin_family = PF_INET;\n\t\tsin->sin_addr.s_addr = ina.s_addr;\n\t\treturn (0);\n\n\tcase PF_INET6:\n\t\tif (strncasecmp(\"ipv6:\", str, 5) == 0)\n\t\t\tstr += 5;\n\t\tcp = strchr(str, SCOPE_DELIMITER);\n\t\tif (cp) {\n\t\t\tstr2 = strdup(str);\n\t\t\tif (str2 == NULL)\n\t\t\t\treturn (-1);\n\t\t\tstr2[cp - str] = '\\0';\n\t\t\tif (inet_pton(PF_INET6, str2, &in6a) != 1) {\n\t\t\t\tfree(str2);\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tcp++;\n\t\t\tfree(str2);\n\t\t} else if (inet_pton(PF_INET6, str, &in6a) != 1)\n\t\t\treturn (-1);\n\n\t\tsin6 = (struct sockaddr_in6 *)sa;\n\t\tmemset(sin6, 0, sizeof *sin6);\n\t\tsin6->sin6_len = sizeof(struct sockaddr_in6);\n\t\tsin6->sin6_family = PF_INET6;\n\t\tsin6->sin6_addr = in6a;\n\n\t\tif (cp == NULL)\n\t\t\treturn (0);\n\n\t\tif (IN6_IS_ADDR_LINKLOCAL(&in6a) ||\n\t\t    IN6_IS_ADDR_MC_LINKLOCAL(&in6a) ||\n\t\t    IN6_IS_ADDR_MC_INTFACELOCAL(&in6a))\n\t\t\tif ((sin6->sin6_scope_id = if_nametoindex(cp)))\n\t\t\t\treturn (0);\n\n\t\tsin6->sin6_scope_id = strtonum(cp, 0, UINT32_MAX, &errstr);\n\t\tif (errstr)\n\t\t\treturn (-1);\n\t\treturn (0);\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn (-1);\n}\n"], "filenames": ["usr.sbin/smtpd/table.c"], "buggy_code_start_loc": [1], "buggy_code_end_loc": [477], "fixing_code_start_loc": [1], "fixing_code_end_loc": [482], "type": "CWE-401", "message": "smtpd/table.c in OpenSMTPD before 6.8.0p1 lacks a certain regfree, which might allow attackers to trigger a \"very significant\" memory leak via messages to an instance that performs many regex lookups.", "other": {"cve": {"id": "CVE-2020-35679", "sourceIdentifier": "cve@mitre.org", "published": "2020-12-24T16:15:15.537", "lastModified": "2022-04-26T16:13:23.743", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "smtpd/table.c in OpenSMTPD before 6.8.0p1 lacks a certain regfree, which might allow attackers to trigger a \"very significant\" memory leak via messages to an instance that performs many regex lookups."}, {"lang": "es", "value": "El archivo smtpd/table.c en OpenSMTPD versiones anteriores a 6.8.0p1, carece de determinado regfree, lo que podr\u00eda permitir a atacantes activar un filtrado de memoria \"very significant\" por medio de mensajes hacia una instancia que lleva a cabo muchas b\u00fasquedas de expresiones regulares"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:opensmtpd:opensmtpd:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.8.0", "matchCriteriaId": "95277BD3-1335-4B27-AE1A-61FB5C85FE60"}, {"vulnerable": true, "criteria": "cpe:2.3:a:opensmtpd:opensmtpd:6.8.0:-:*:*:*:*:*:*", "matchCriteriaId": "65FA0447-DC89-4609-824B-ED31E56AD47D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:opensmtpd:opensmtpd:6.8.0:patch1-rc1:*:*:*:*:*:*", "matchCriteriaId": "DDFB59E5-863A-454F-BDC4-8894E9A15B3D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:32:*:*:*:*:*:*:*", "matchCriteriaId": "36D96259-24BD-44E2-96D9-78CE1D41F956"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}]}]}], "references": [{"url": "https://github.com/openbsd/src/commit/79a034b4aed29e965f45a13409268290c9910043", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/5LKTFBQCHGMVPR4IZWHQIYAPM5J3LN3J/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/TYAYXRV2DM5K4RU7RHCDZSA2UF6VCTRC/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://poolp.org/posts/2020-12-24/december-2020-opensmtpd-6.8.0p1-released-fixed-several-bugs-proposed-several-diffs-book-is-on-github/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202105-12", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.mail-archive.com/misc@opensmtpd.org/msg05188.html", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/openbsd/src/commit/79a034b4aed29e965f45a13409268290c9910043"}}