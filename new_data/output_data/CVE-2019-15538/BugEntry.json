{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n * Copyright (c) 2000-2005 Silicon Graphics, Inc.\n * All Rights Reserved.\n */\n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_iomap.h\"\n\n#include <linux/xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/security.h>\n#include <linux/iversion.h>\n\n/*\n * Directories have different lock order w.r.t. mmap_sem compared to regular\n * files. This is due to readdir potentially triggering page faults on a user\n * buffer inside filldir(), and this happens with the ilock on the directory\n * held. For regular files, the lock order is the other way around - the\n * mmap_sem is taken during the page fault, and then we lock the ilock to do\n * block mapping. Hence we need a different class for the directory ilock so\n * that lockdep can tell them apart.\n */\nstatic struct lock_class_key xfs_nondir_ilock_class;\nstatic struct lock_class_key xfs_dir_ilock_class;\n\nstatic int\nxfs_initxattrs(\n\tstruct inode\t\t*inode,\n\tconst struct xattr\t*xattr_array,\n\tvoid\t\t\t*fs_info)\n{\n\tconst struct xattr\t*xattr;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tint\t\t\terror = 0;\n\n\tfor (xattr = xattr_array; xattr->name != NULL; xattr++) {\n\t\terror = xfs_attr_set(ip, xattr->name, xattr->value,\n\t\t\t\t      xattr->value_len, ATTR_SECURE);\n\t\tif (error < 0)\n\t\t\tbreak;\n\t}\n\treturn error;\n}\n\n/*\n * Hook in SELinux.  This is not quite correct yet, what we really need\n * here (as we do for default ACLs) is a mechanism by which creation of\n * these attrs can be journalled at inode creation time (along with the\n * inode, of course, such that log replay can't cause these to be lost).\n */\n\nSTATIC int\nxfs_init_security(\n\tstruct inode\t*inode,\n\tstruct inode\t*dir,\n\tconst struct qstr *qstr)\n{\n\treturn security_inode_init_security(inode, dir, qstr,\n\t\t\t\t\t     &xfs_initxattrs, NULL);\n}\n\nstatic void\nxfs_dentry_to_name(\n\tstruct xfs_name\t*namep,\n\tstruct dentry\t*dentry)\n{\n\tnamep->name = dentry->d_name.name;\n\tnamep->len = dentry->d_name.len;\n\tnamep->type = XFS_DIR3_FT_UNKNOWN;\n}\n\nstatic int\nxfs_dentry_mode_to_name(\n\tstruct xfs_name\t*namep,\n\tstruct dentry\t*dentry,\n\tint\t\tmode)\n{\n\tnamep->name = dentry->d_name.name;\n\tnamep->len = dentry->d_name.len;\n\tnamep->type = xfs_mode_to_ftype(mode);\n\n\tif (unlikely(namep->type == XFS_DIR3_FT_UNKNOWN))\n\t\treturn -EFSCORRUPTED;\n\n\treturn 0;\n}\n\nSTATIC void\nxfs_cleanup_inode(\n\tstruct inode\t*dir,\n\tstruct inode\t*inode,\n\tstruct dentry\t*dentry)\n{\n\tstruct xfs_name\tteardown;\n\n\t/* Oh, the horror.\n\t * If we can't add the ACL or we fail in\n\t * xfs_init_security we must back out.\n\t * ENOSPC can hit here, among other things.\n\t */\n\txfs_dentry_to_name(&teardown, dentry);\n\n\txfs_remove(XFS_I(dir), &teardown, XFS_I(inode));\n}\n\nSTATIC int\nxfs_generic_create(\n\tstruct inode\t*dir,\n\tstruct dentry\t*dentry,\n\tumode_t\t\tmode,\n\tdev_t\t\trdev,\n\tbool\t\ttmpfile)\t/* unnamed file */\n{\n\tstruct inode\t*inode;\n\tstruct xfs_inode *ip = NULL;\n\tstruct posix_acl *default_acl, *acl;\n\tstruct xfs_name\tname;\n\tint\t\terror;\n\n\t/*\n\t * Irix uses Missed'em'V split, but doesn't want to see\n\t * the upper 5 bits of (14bit) major.\n\t */\n\tif (S_ISCHR(mode) || S_ISBLK(mode)) {\n\t\tif (unlikely(!sysv_valid_dev(rdev) || MAJOR(rdev) & ~0x1ff))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\trdev = 0;\n\t}\n\n\terror = posix_acl_create(dir, &mode, &default_acl, &acl);\n\tif (error)\n\t\treturn error;\n\n\t/* Verify mode is valid also for tmpfile case */\n\terror = xfs_dentry_mode_to_name(&name, dentry, mode);\n\tif (unlikely(error))\n\t\tgoto out_free_acl;\n\n\tif (!tmpfile) {\n\t\terror = xfs_create(XFS_I(dir), &name, mode, rdev, &ip);\n\t} else {\n\t\terror = xfs_create_tmpfile(XFS_I(dir), mode, &ip);\n\t}\n\tif (unlikely(error))\n\t\tgoto out_free_acl;\n\n\tinode = VFS_I(ip);\n\n\terror = xfs_init_security(inode, dir, &dentry->d_name);\n\tif (unlikely(error))\n\t\tgoto out_cleanup_inode;\n\n#ifdef CONFIG_XFS_POSIX_ACL\n\tif (default_acl) {\n\t\terror = __xfs_set_acl(inode, default_acl, ACL_TYPE_DEFAULT);\n\t\tif (error)\n\t\t\tgoto out_cleanup_inode;\n\t}\n\tif (acl) {\n\t\terror = __xfs_set_acl(inode, acl, ACL_TYPE_ACCESS);\n\t\tif (error)\n\t\t\tgoto out_cleanup_inode;\n\t}\n#endif\n\n\txfs_setup_iops(ip);\n\n\tif (tmpfile) {\n\t\t/*\n\t\t * The VFS requires that any inode fed to d_tmpfile must have\n\t\t * nlink == 1 so that it can decrement the nlink in d_tmpfile.\n\t\t * However, we created the temp file with nlink == 0 because\n\t\t * we're not allowed to put an inode with nlink > 0 on the\n\t\t * unlinked list.  Therefore we have to set nlink to 1 so that\n\t\t * d_tmpfile can immediately set it back to zero.\n\t\t */\n\t\tset_nlink(inode, 1);\n\t\td_tmpfile(dentry, inode);\n\t} else\n\t\td_instantiate(dentry, inode);\n\n\txfs_finish_inode_setup(ip);\n\n out_free_acl:\n\tif (default_acl)\n\t\tposix_acl_release(default_acl);\n\tif (acl)\n\t\tposix_acl_release(acl);\n\treturn error;\n\n out_cleanup_inode:\n\txfs_finish_inode_setup(ip);\n\tif (!tmpfile)\n\t\txfs_cleanup_inode(dir, inode, dentry);\n\txfs_irele(ip);\n\tgoto out_free_acl;\n}\n\nSTATIC int\nxfs_vn_mknod(\n\tstruct inode\t*dir,\n\tstruct dentry\t*dentry,\n\tumode_t\t\tmode,\n\tdev_t\t\trdev)\n{\n\treturn xfs_generic_create(dir, dentry, mode, rdev, false);\n}\n\nSTATIC int\nxfs_vn_create(\n\tstruct inode\t*dir,\n\tstruct dentry\t*dentry,\n\tumode_t\t\tmode,\n\tbool\t\tflags)\n{\n\treturn xfs_vn_mknod(dir, dentry, mode, 0);\n}\n\nSTATIC int\nxfs_vn_mkdir(\n\tstruct inode\t*dir,\n\tstruct dentry\t*dentry,\n\tumode_t\t\tmode)\n{\n\treturn xfs_vn_mknod(dir, dentry, mode|S_IFDIR, 0);\n}\n\nSTATIC struct dentry *\nxfs_vn_lookup(\n\tstruct inode\t*dir,\n\tstruct dentry\t*dentry,\n\tunsigned int flags)\n{\n\tstruct inode *inode;\n\tstruct xfs_inode *cip;\n\tstruct xfs_name\tname;\n\tint\t\terror;\n\n\tif (dentry->d_name.len >= MAXNAMELEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\txfs_dentry_to_name(&name, dentry);\n\terror = xfs_lookup(XFS_I(dir), &name, &cip, NULL);\n\tif (likely(!error))\n\t\tinode = VFS_I(cip);\n\telse if (likely(error == -ENOENT))\n\t\tinode = NULL;\n\telse\n\t\tinode = ERR_PTR(error);\n\treturn d_splice_alias(inode, dentry);\n}\n\nSTATIC struct dentry *\nxfs_vn_ci_lookup(\n\tstruct inode\t*dir,\n\tstruct dentry\t*dentry,\n\tunsigned int flags)\n{\n\tstruct xfs_inode *ip;\n\tstruct xfs_name\txname;\n\tstruct xfs_name ci_name;\n\tstruct qstr\tdname;\n\tint\t\terror;\n\n\tif (dentry->d_name.len >= MAXNAMELEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\txfs_dentry_to_name(&xname, dentry);\n\terror = xfs_lookup(XFS_I(dir), &xname, &ip, &ci_name);\n\tif (unlikely(error)) {\n\t\tif (unlikely(error != -ENOENT))\n\t\t\treturn ERR_PTR(error);\n\t\t/*\n\t\t * call d_add(dentry, NULL) here when d_drop_negative_children\n\t\t * is called in xfs_vn_mknod (ie. allow negative dentries\n\t\t * with CI filesystems).\n\t\t */\n\t\treturn NULL;\n\t}\n\n\t/* if exact match, just splice and exit */\n\tif (!ci_name.name)\n\t\treturn d_splice_alias(VFS_I(ip), dentry);\n\n\t/* else case-insensitive match... */\n\tdname.name = ci_name.name;\n\tdname.len = ci_name.len;\n\tdentry = d_add_ci(dentry, VFS_I(ip), &dname);\n\tkmem_free(ci_name.name);\n\treturn dentry;\n}\n\nSTATIC int\nxfs_vn_link(\n\tstruct dentry\t*old_dentry,\n\tstruct inode\t*dir,\n\tstruct dentry\t*dentry)\n{\n\tstruct inode\t*inode = d_inode(old_dentry);\n\tstruct xfs_name\tname;\n\tint\t\terror;\n\n\terror = xfs_dentry_mode_to_name(&name, dentry, inode->i_mode);\n\tif (unlikely(error))\n\t\treturn error;\n\n\terror = xfs_link(XFS_I(dir), XFS_I(inode), &name);\n\tif (unlikely(error))\n\t\treturn error;\n\n\tihold(inode);\n\td_instantiate(dentry, inode);\n\treturn 0;\n}\n\nSTATIC int\nxfs_vn_unlink(\n\tstruct inode\t*dir,\n\tstruct dentry\t*dentry)\n{\n\tstruct xfs_name\tname;\n\tint\t\terror;\n\n\txfs_dentry_to_name(&name, dentry);\n\n\terror = xfs_remove(XFS_I(dir), &name, XFS_I(d_inode(dentry)));\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * With unlink, the VFS makes the dentry \"negative\": no inode,\n\t * but still hashed. This is incompatible with case-insensitive\n\t * mode, so invalidate (unhash) the dentry in CI-mode.\n\t */\n\tif (xfs_sb_version_hasasciici(&XFS_M(dir->i_sb)->m_sb))\n\t\td_invalidate(dentry);\n\treturn 0;\n}\n\nSTATIC int\nxfs_vn_symlink(\n\tstruct inode\t*dir,\n\tstruct dentry\t*dentry,\n\tconst char\t*symname)\n{\n\tstruct inode\t*inode;\n\tstruct xfs_inode *cip = NULL;\n\tstruct xfs_name\tname;\n\tint\t\terror;\n\tumode_t\t\tmode;\n\n\tmode = S_IFLNK |\n\t\t(irix_symlink_mode ? 0777 & ~current_umask() : S_IRWXUGO);\n\terror = xfs_dentry_mode_to_name(&name, dentry, mode);\n\tif (unlikely(error))\n\t\tgoto out;\n\n\terror = xfs_symlink(XFS_I(dir), &name, symname, mode, &cip);\n\tif (unlikely(error))\n\t\tgoto out;\n\n\tinode = VFS_I(cip);\n\n\terror = xfs_init_security(inode, dir, &dentry->d_name);\n\tif (unlikely(error))\n\t\tgoto out_cleanup_inode;\n\n\txfs_setup_iops(cip);\n\n\td_instantiate(dentry, inode);\n\txfs_finish_inode_setup(cip);\n\treturn 0;\n\n out_cleanup_inode:\n\txfs_finish_inode_setup(cip);\n\txfs_cleanup_inode(dir, inode, dentry);\n\txfs_irele(cip);\n out:\n\treturn error;\n}\n\nSTATIC int\nxfs_vn_rename(\n\tstruct inode\t*odir,\n\tstruct dentry\t*odentry,\n\tstruct inode\t*ndir,\n\tstruct dentry\t*ndentry,\n\tunsigned int\tflags)\n{\n\tstruct inode\t*new_inode = d_inode(ndentry);\n\tint\t\tomode = 0;\n\tint\t\terror;\n\tstruct xfs_name\toname;\n\tstruct xfs_name\tnname;\n\n\tif (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE | RENAME_WHITEOUT))\n\t\treturn -EINVAL;\n\n\t/* if we are exchanging files, we need to set i_mode of both files */\n\tif (flags & RENAME_EXCHANGE)\n\t\tomode = d_inode(ndentry)->i_mode;\n\n\terror = xfs_dentry_mode_to_name(&oname, odentry, omode);\n\tif (omode && unlikely(error))\n\t\treturn error;\n\n\terror = xfs_dentry_mode_to_name(&nname, ndentry,\n\t\t\t\t\td_inode(odentry)->i_mode);\n\tif (unlikely(error))\n\t\treturn error;\n\n\treturn xfs_rename(XFS_I(odir), &oname, XFS_I(d_inode(odentry)),\n\t\t\t  XFS_I(ndir), &nname,\n\t\t\t  new_inode ? XFS_I(new_inode) : NULL, flags);\n}\n\n/*\n * careful here - this function can get called recursively, so\n * we need to be very careful about how much stack we use.\n * uio is kmalloced for this reason...\n */\nSTATIC const char *\nxfs_vn_get_link(\n\tstruct dentry\t\t*dentry,\n\tstruct inode\t\t*inode,\n\tstruct delayed_call\t*done)\n{\n\tchar\t\t\t*link;\n\tint\t\t\terror = -ENOMEM;\n\n\tif (!dentry)\n\t\treturn ERR_PTR(-ECHILD);\n\n\tlink = kmalloc(XFS_SYMLINK_MAXLEN+1, GFP_KERNEL);\n\tif (!link)\n\t\tgoto out_err;\n\n\terror = xfs_readlink(XFS_I(d_inode(dentry)), link);\n\tif (unlikely(error))\n\t\tgoto out_kfree;\n\n\tset_delayed_call(done, kfree_link, link);\n\treturn link;\n\n out_kfree:\n\tkfree(link);\n out_err:\n\treturn ERR_PTR(error);\n}\n\nSTATIC const char *\nxfs_vn_get_link_inline(\n\tstruct dentry\t\t*dentry,\n\tstruct inode\t\t*inode,\n\tstruct delayed_call\t*done)\n{\n\tchar\t\t\t*link;\n\n\tASSERT(XFS_I(inode)->i_df.if_flags & XFS_IFINLINE);\n\n\t/*\n\t * The VFS crashes on a NULL pointer, so return -EFSCORRUPTED if\n\t * if_data is junk.\n\t */\n\tlink = XFS_I(inode)->i_df.if_u1.if_data;\n\tif (!link)\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\treturn link;\n}\n\nSTATIC int\nxfs_vn_getattr(\n\tconst struct path\t*path,\n\tstruct kstat\t\t*stat,\n\tu32\t\t\trequest_mask,\n\tunsigned int\t\tquery_flags)\n{\n\tstruct inode\t\t*inode = d_inode(path->dentry);\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\n\ttrace_xfs_getattr(ip);\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tstat->size = XFS_ISIZE(ip);\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->mode = inode->i_mode;\n\tstat->nlink = inode->i_nlink;\n\tstat->uid = inode->i_uid;\n\tstat->gid = inode->i_gid;\n\tstat->ino = ip->i_ino;\n\tstat->atime = inode->i_atime;\n\tstat->mtime = inode->i_mtime;\n\tstat->ctime = inode->i_ctime;\n\tstat->blocks =\n\t\tXFS_FSB_TO_BB(mp, ip->i_d.di_nblocks + ip->i_delayed_blks);\n\n\tif (ip->i_d.di_version == 3) {\n\t\tif (request_mask & STATX_BTIME) {\n\t\t\tstat->result_mask |= STATX_BTIME;\n\t\t\tstat->btime.tv_sec = ip->i_d.di_crtime.t_sec;\n\t\t\tstat->btime.tv_nsec = ip->i_d.di_crtime.t_nsec;\n\t\t}\n\t}\n\n\t/*\n\t * Note: If you add another clause to set an attribute flag, please\n\t * update attributes_mask below.\n\t */\n\tif (ip->i_d.di_flags & XFS_DIFLAG_IMMUTABLE)\n\t\tstat->attributes |= STATX_ATTR_IMMUTABLE;\n\tif (ip->i_d.di_flags & XFS_DIFLAG_APPEND)\n\t\tstat->attributes |= STATX_ATTR_APPEND;\n\tif (ip->i_d.di_flags & XFS_DIFLAG_NODUMP)\n\t\tstat->attributes |= STATX_ATTR_NODUMP;\n\n\tstat->attributes_mask |= (STATX_ATTR_IMMUTABLE |\n\t\t\t\t  STATX_ATTR_APPEND |\n\t\t\t\t  STATX_ATTR_NODUMP);\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\t\tstat->blksize = BLKDEV_IOSIZE;\n\t\tstat->rdev = inode->i_rdev;\n\t\tbreak;\n\tdefault:\n\t\tif (XFS_IS_REALTIME_INODE(ip)) {\n\t\t\t/*\n\t\t\t * If the file blocks are being allocated from a\n\t\t\t * realtime volume, then return the inode's realtime\n\t\t\t * extent size or the realtime volume's extent size.\n\t\t\t */\n\t\t\tstat->blksize =\n\t\t\t\txfs_get_extsz_hint(ip) << mp->m_sb.sb_blocklog;\n\t\t} else\n\t\t\tstat->blksize = xfs_preferred_iosize(mp);\n\t\tstat->rdev = 0;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nxfs_setattr_mode(\n\tstruct xfs_inode\t*ip,\n\tstruct iattr\t\t*iattr)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tumode_t\t\t\tmode = iattr->ia_mode;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tinode->i_mode &= S_IFMT;\n\tinode->i_mode |= mode & ~S_IFMT;\n}\n\nvoid\nxfs_setattr_time(\n\tstruct xfs_inode\t*ip,\n\tstruct iattr\t\t*iattr)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tif (iattr->ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = iattr->ia_atime;\n\tif (iattr->ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = iattr->ia_ctime;\n\tif (iattr->ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = iattr->ia_mtime;\n}\n\nstatic int\nxfs_vn_change_ok(\n\tstruct dentry\t*dentry,\n\tstruct iattr\t*iattr)\n{\n\tstruct xfs_mount\t*mp = XFS_I(d_inode(dentry))->i_mount;\n\n\tif (mp->m_flags & XFS_MOUNT_RDONLY)\n\t\treturn -EROFS;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\treturn setattr_prepare(dentry, iattr);\n}\n\n/*\n * Set non-size attributes of an inode.\n *\n * Caution: The caller of this function is responsible for calling\n * setattr_prepare() or otherwise verifying the change is fine.\n */\nint\nxfs_setattr_nonsize(\n\tstruct xfs_inode\t*ip,\n\tstruct iattr\t\t*iattr,\n\tint\t\t\tflags)\n{\n\txfs_mount_t\t\t*mp = ip->i_mount;\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tint\t\t\tmask = iattr->ia_valid;\n\txfs_trans_t\t\t*tp;\n\tint\t\t\terror;\n\tkuid_t\t\t\tuid = GLOBAL_ROOT_UID, iuid = GLOBAL_ROOT_UID;\n\tkgid_t\t\t\tgid = GLOBAL_ROOT_GID, igid = GLOBAL_ROOT_GID;\n\tstruct xfs_dquot\t*udqp = NULL, *gdqp = NULL;\n\tstruct xfs_dquot\t*olddquot1 = NULL, *olddquot2 = NULL;\n\n\tASSERT((mask & ATTR_SIZE) == 0);\n\n\t/*\n\t * If disk quotas is on, we make sure that the dquots do exist on disk,\n\t * before we start any other transactions. Trying to do this later\n\t * is messy. We don't care to take a readlock to look at the ids\n\t * in inode here, because we can't hold it across the trans_reserve.\n\t * If the IDs do change before we take the ilock, we're covered\n\t * because the i_*dquot fields will get updated anyway.\n\t */\n\tif (XFS_IS_QUOTA_ON(mp) && (mask & (ATTR_UID|ATTR_GID))) {\n\t\tuint\tqflags = 0;\n\n\t\tif ((mask & ATTR_UID) && XFS_IS_UQUOTA_ON(mp)) {\n\t\t\tuid = iattr->ia_uid;\n\t\t\tqflags |= XFS_QMOPT_UQUOTA;\n\t\t} else {\n\t\t\tuid = inode->i_uid;\n\t\t}\n\t\tif ((mask & ATTR_GID) && XFS_IS_GQUOTA_ON(mp)) {\n\t\t\tgid = iattr->ia_gid;\n\t\t\tqflags |= XFS_QMOPT_GQUOTA;\n\t\t}  else {\n\t\t\tgid = inode->i_gid;\n\t\t}\n\n\t\t/*\n\t\t * We take a reference when we initialize udqp and gdqp,\n\t\t * so it is important that we never blindly double trip on\n\t\t * the same variable. See xfs_create() for an example.\n\t\t */\n\t\tASSERT(udqp == NULL);\n\t\tASSERT(gdqp == NULL);\n\t\terror = xfs_qm_vop_dqalloc(ip, xfs_kuid_to_uid(uid),\n\t\t\t\t\t   xfs_kgid_to_gid(gid),\n\t\t\t\t\t   xfs_get_projid(ip),\n\t\t\t\t\t   qflags, &udqp, &gdqp, NULL);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\terror = xfs_trans_alloc(mp, &M_RES(mp)->tr_ichange, 0, 0, 0, &tp);\n\tif (error)\n\t\tgoto out_dqrele;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, 0);\n\n\t/*\n\t * Change file ownership.  Must be the owner or privileged.\n\t */\n\tif (mask & (ATTR_UID|ATTR_GID)) {\n\t\t/*\n\t\t * These IDs could have changed since we last looked at them.\n\t\t * But, we're assured that if the ownership did change\n\t\t * while we didn't have the inode locked, inode's dquot(s)\n\t\t * would have changed also.\n\t\t */\n\t\tiuid = inode->i_uid;\n\t\tigid = inode->i_gid;\n\t\tgid = (mask & ATTR_GID) ? iattr->ia_gid : igid;\n\t\tuid = (mask & ATTR_UID) ? iattr->ia_uid : iuid;\n\n\t\t/*\n\t\t * Do a quota reservation only if uid/gid is actually\n\t\t * going to change.\n\t\t */\n\t\tif (XFS_IS_QUOTA_RUNNING(mp) &&\n\t\t    ((XFS_IS_UQUOTA_ON(mp) && !uid_eq(iuid, uid)) ||\n\t\t     (XFS_IS_GQUOTA_ON(mp) && !gid_eq(igid, gid)))) {\n\t\t\tASSERT(tp);\n\t\t\terror = xfs_qm_vop_chown_reserve(tp, ip, udqp, gdqp,\n\t\t\t\t\t\tNULL, capable(CAP_FOWNER) ?\n\t\t\t\t\t\tXFS_QMOPT_FORCE_RES : 0);\n\t\t\tif (error)\t/* out of quota */\n\t\t\t\tgoto out_cancel;\n\t\t}\n\t}\n\n\t/*\n\t * Change file ownership.  Must be the owner or privileged.\n\t */\n\tif (mask & (ATTR_UID|ATTR_GID)) {\n\t\t/*\n\t\t * CAP_FSETID overrides the following restrictions:\n\t\t *\n\t\t * The set-user-ID and set-group-ID bits of a file will be\n\t\t * cleared upon successful return from chown()\n\t\t */\n\t\tif ((inode->i_mode & (S_ISUID|S_ISGID)) &&\n\t\t    !capable(CAP_FSETID))\n\t\t\tinode->i_mode &= ~(S_ISUID|S_ISGID);\n\n\t\t/*\n\t\t * Change the ownerships and register quota modifications\n\t\t * in the transaction.\n\t\t */\n\t\tif (!uid_eq(iuid, uid)) {\n\t\t\tif (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_UQUOTA_ON(mp)) {\n\t\t\t\tASSERT(mask & ATTR_UID);\n\t\t\t\tASSERT(udqp);\n\t\t\t\tolddquot1 = xfs_qm_vop_chown(tp, ip,\n\t\t\t\t\t\t\t&ip->i_udquot, udqp);\n\t\t\t}\n\t\t\tip->i_d.di_uid = xfs_kuid_to_uid(uid);\n\t\t\tinode->i_uid = uid;\n\t\t}\n\t\tif (!gid_eq(igid, gid)) {\n\t\t\tif (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_GQUOTA_ON(mp)) {\n\t\t\t\tASSERT(xfs_sb_version_has_pquotino(&mp->m_sb) ||\n\t\t\t\t       !XFS_IS_PQUOTA_ON(mp));\n\t\t\t\tASSERT(mask & ATTR_GID);\n\t\t\t\tASSERT(gdqp);\n\t\t\t\tolddquot2 = xfs_qm_vop_chown(tp, ip,\n\t\t\t\t\t\t\t&ip->i_gdquot, gdqp);\n\t\t\t}\n\t\t\tip->i_d.di_gid = xfs_kgid_to_gid(gid);\n\t\t\tinode->i_gid = gid;\n\t\t}\n\t}\n\n\tif (mask & ATTR_MODE)\n\t\txfs_setattr_mode(ip, iattr);\n\tif (mask & (ATTR_ATIME|ATTR_CTIME|ATTR_MTIME))\n\t\txfs_setattr_time(ip, iattr);\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tXFS_STATS_INC(mp, xs_ig_attrchg);\n\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(tp);\n\terror = xfs_trans_commit(tp);\n\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\t/*\n\t * Release any dquot(s) the inode had kept before chown.\n\t */\n\txfs_qm_dqrele(olddquot1);\n\txfs_qm_dqrele(olddquot2);\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * XXX(hch): Updating the ACL entries is not atomic vs the i_mode\n\t * \t     update.  We could avoid this with linked transactions\n\t * \t     and passing down the transaction pointer all the way\n\t *\t     to attr_set.  No previous user of the generic\n\t * \t     Posix ACL code seems to care about this issue either.\n\t */\n\tif ((mask & ATTR_MODE) && !(flags & XFS_ATTR_NOACL)) {\n\t\terror = posix_acl_chmod(inode, inode->i_mode);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n\nout_cancel:\n\txfs_trans_cancel(tp);\nout_dqrele:\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\treturn error;\n}\n\nint\nxfs_vn_setattr_nonsize(\n\tstruct dentry\t\t*dentry,\n\tstruct iattr\t\t*iattr)\n{\n\tstruct xfs_inode\t*ip = XFS_I(d_inode(dentry));\n\tint error;\n\n\ttrace_xfs_setattr(ip);\n\n\terror = xfs_vn_change_ok(dentry, iattr);\n\tif (error)\n\t\treturn error;\n\treturn xfs_setattr_nonsize(ip, iattr, 0);\n}\n\n/*\n * Truncate file.  Must have write permission and not be a directory.\n *\n * Caution: The caller of this function is responsible for calling\n * setattr_prepare() or otherwise verifying the change is fine.\n */\nSTATIC int\nxfs_setattr_size(\n\tstruct xfs_inode\t*ip,\n\tstruct iattr\t\t*iattr)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct inode\t\t*inode = VFS_I(ip);\n\txfs_off_t\t\toldsize, newsize;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\tuint\t\t\tlock_flags = 0;\n\tbool\t\t\tdid_zeroing = false;\n\n\tASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\tASSERT(xfs_isilocked(ip, XFS_MMAPLOCK_EXCL));\n\tASSERT(S_ISREG(inode->i_mode));\n\tASSERT((iattr->ia_valid & (ATTR_UID|ATTR_GID|ATTR_ATIME|ATTR_ATIME_SET|\n\t\tATTR_MTIME_SET|ATTR_KILL_PRIV|ATTR_TIMES_SET)) == 0);\n\n\toldsize = inode->i_size;\n\tnewsize = iattr->ia_size;\n\n\t/*\n\t * Short circuit the truncate case for zero length files.\n\t */\n\tif (newsize == 0 && oldsize == 0 && ip->i_d.di_nextents == 0) {\n\t\tif (!(iattr->ia_valid & (ATTR_CTIME|ATTR_MTIME)))\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * Use the regular setattr path to update the timestamps.\n\t\t */\n\t\tiattr->ia_valid &= ~ATTR_SIZE;\n\t\treturn xfs_setattr_nonsize(ip, iattr, 0);\n\t}\n\n\t/*\n\t * Make sure that the dquots are attached to the inode.\n\t */\n\terror = xfs_qm_dqattach(ip);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Wait for all direct I/O to complete.\n\t */\n\tinode_dio_wait(inode);\n\n\t/*\n\t * File data changes must be complete before we start the transaction to\n\t * modify the inode.  This needs to be done before joining the inode to\n\t * the transaction because the inode cannot be unlocked once it is a\n\t * part of the transaction.\n\t *\n\t * Start with zeroing any data beyond EOF that we may expose on file\n\t * extension, or zeroing out the rest of the block on a downward\n\t * truncate.\n\t */\n\tif (newsize > oldsize) {\n\t\ttrace_xfs_zero_eof(ip, oldsize, newsize - oldsize);\n\t\terror = iomap_zero_range(inode, oldsize, newsize - oldsize,\n\t\t\t\t&did_zeroing, &xfs_iomap_ops);\n\t} else {\n\t\terror = iomap_truncate_page(inode, newsize, &did_zeroing,\n\t\t\t\t&xfs_iomap_ops);\n\t}\n\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * We've already locked out new page faults, so now we can safely remove\n\t * pages from the page cache knowing they won't get refaulted until we\n\t * drop the XFS_MMAP_EXCL lock after the extent manipulations are\n\t * complete. The truncate_setsize() call also cleans partial EOF page\n\t * PTEs on extending truncates and hence ensures sub-page block size\n\t * filesystems are correctly handled, too.\n\t *\n\t * We have to do all the page cache truncate work outside the\n\t * transaction context as the \"lock\" order is page lock->log space\n\t * reservation as defined by extent allocation in the writeback path.\n\t * Hence a truncate can fail with ENOMEM from xfs_trans_alloc(), but\n\t * having already truncated the in-memory version of the file (i.e. made\n\t * user visible changes). There's not much we can do about this, except\n\t * to hope that the caller sees ENOMEM and retries the truncate\n\t * operation.\n\t *\n\t * And we update in-core i_size and truncate page cache beyond newsize\n\t * before writeback the [di_size, newsize] range, so we're guaranteed\n\t * not to write stale data past the new EOF on truncate down.\n\t */\n\ttruncate_setsize(inode, newsize);\n\n\t/*\n\t * We are going to log the inode size change in this transaction so\n\t * any previous writes that are beyond the on disk EOF and the new\n\t * EOF that have not been written out need to be written here.  If we\n\t * do not write the data out, we expose ourselves to the null files\n\t * problem. Note that this includes any block zeroing we did above;\n\t * otherwise those blocks may not be zeroed after a crash.\n\t */\n\tif (did_zeroing ||\n\t    (newsize > ip->i_d.di_size && oldsize != ip->i_d.di_size)) {\n\t\terror = filemap_write_and_wait_range(VFS_I(ip)->i_mapping,\n\t\t\t\t\t\tip->i_d.di_size, newsize - 1);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\terror = xfs_trans_alloc(mp, &M_RES(mp)->tr_itruncate, 0, 0, 0, &tp);\n\tif (error)\n\t\treturn error;\n\n\tlock_flags |= XFS_ILOCK_EXCL;\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, 0);\n\n\t/*\n\t * Only change the c/mtime if we are changing the size or we are\n\t * explicitly asked to change it.  This handles the semantic difference\n\t * between truncate() and ftruncate() as implemented in the VFS.\n\t *\n\t * The regular truncate() case without ATTR_CTIME and ATTR_MTIME is a\n\t * special case where we need to update the times despite not having\n\t * these flags set.  For all other operations the VFS set these flags\n\t * explicitly if it wants a timestamp update.\n\t */\n\tif (newsize != oldsize &&\n\t    !(iattr->ia_valid & (ATTR_CTIME | ATTR_MTIME))) {\n\t\tiattr->ia_ctime = iattr->ia_mtime =\n\t\t\tcurrent_time(inode);\n\t\tiattr->ia_valid |= ATTR_CTIME | ATTR_MTIME;\n\t}\n\n\t/*\n\t * The first thing we do is set the size to new_size permanently on\n\t * disk.  This way we don't have to worry about anyone ever being able\n\t * to look at the data being freed even in the face of a crash.\n\t * What we're getting around here is the case where we free a block, it\n\t * is allocated to another file, it is written to, and then we crash.\n\t * If the new data gets written to the file but the log buffers\n\t * containing the free and reallocation don't, then we'd end up with\n\t * garbage in the blocks being freed.  As long as we make the new size\n\t * permanent before actually freeing any blocks it doesn't matter if\n\t * they get written to.\n\t */\n\tip->i_d.di_size = newsize;\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tif (newsize <= oldsize) {\n\t\terror = xfs_itruncate_extents(&tp, ip, XFS_DATA_FORK, newsize);\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\n\t\t/*\n\t\t * Truncated \"down\", so we're removing references to old data\n\t\t * here - if we delay flushing for a long time, we expose\n\t\t * ourselves unduly to the notorious NULL files problem.  So,\n\t\t * we mark this inode and flush it when the file is closed,\n\t\t * and do not wait the usual (long) time for writeout.\n\t\t */\n\t\txfs_iflags_set(ip, XFS_ITRUNCATED);\n\n\t\t/* A truncate down always removes post-EOF blocks. */\n\t\txfs_inode_clear_eofblocks_tag(ip);\n\t}\n\n\tif (iattr->ia_valid & ATTR_MODE)\n\t\txfs_setattr_mode(ip, iattr);\n\tif (iattr->ia_valid & (ATTR_ATIME|ATTR_CTIME|ATTR_MTIME))\n\t\txfs_setattr_time(ip, iattr);\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tXFS_STATS_INC(mp, xs_ig_attrchg);\n\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(tp);\n\n\terror = xfs_trans_commit(tp);\nout_unlock:\n\tif (lock_flags)\n\t\txfs_iunlock(ip, lock_flags);\n\treturn error;\n\nout_trans_cancel:\n\txfs_trans_cancel(tp);\n\tgoto out_unlock;\n}\n\nint\nxfs_vn_setattr_size(\n\tstruct dentry\t\t*dentry,\n\tstruct iattr\t\t*iattr)\n{\n\tstruct xfs_inode\t*ip = XFS_I(d_inode(dentry));\n\tint error;\n\n\ttrace_xfs_setattr(ip);\n\n\terror = xfs_vn_change_ok(dentry, iattr);\n\tif (error)\n\t\treturn error;\n\treturn xfs_setattr_size(ip, iattr);\n}\n\nSTATIC int\nxfs_vn_setattr(\n\tstruct dentry\t\t*dentry,\n\tstruct iattr\t\t*iattr)\n{\n\tint\t\t\terror;\n\n\tif (iattr->ia_valid & ATTR_SIZE) {\n\t\tstruct inode\t\t*inode = d_inode(dentry);\n\t\tstruct xfs_inode\t*ip = XFS_I(inode);\n\t\tuint\t\t\tiolock;\n\n\t\txfs_ilock(ip, XFS_MMAPLOCK_EXCL);\n\t\tiolock = XFS_IOLOCK_EXCL | XFS_MMAPLOCK_EXCL;\n\n\t\terror = xfs_break_layouts(inode, &iolock, BREAK_UNMAP);\n\t\tif (error) {\n\t\t\txfs_iunlock(ip, XFS_MMAPLOCK_EXCL);\n\t\t\treturn error;\n\t\t}\n\n\t\terror = xfs_vn_setattr_size(dentry, iattr);\n\t\txfs_iunlock(ip, XFS_MMAPLOCK_EXCL);\n\t} else {\n\t\terror = xfs_vn_setattr_nonsize(dentry, iattr);\n\t}\n\n\treturn error;\n}\n\nSTATIC int\nxfs_vn_update_time(\n\tstruct inode\t\t*inode,\n\tstruct timespec64\t*now,\n\tint\t\t\tflags)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tint\t\t\tlog_flags = XFS_ILOG_TIMESTAMP;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\ttrace_xfs_update_time(ip);\n\n\tif (inode->i_sb->s_flags & SB_LAZYTIME) {\n\t\tif (!((flags & S_VERSION) &&\n\t\t      inode_maybe_inc_iversion(inode, false)))\n\t\t\treturn generic_update_time(inode, now, flags);\n\n\t\t/* Capture the iversion update that just occurred */\n\t\tlog_flags |= XFS_ILOG_CORE;\n\t}\n\n\terror = xfs_trans_alloc(mp, &M_RES(mp)->tr_fsyncts, 0, 0, 0, &tp);\n\tif (error)\n\t\treturn error;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\tif (flags & S_CTIME)\n\t\tinode->i_ctime = *now;\n\tif (flags & S_MTIME)\n\t\tinode->i_mtime = *now;\n\tif (flags & S_ATIME)\n\t\tinode->i_atime = *now;\n\n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\txfs_trans_log_inode(tp, ip, log_flags);\n\treturn xfs_trans_commit(tp);\n}\n\nSTATIC int\nxfs_vn_fiemap(\n\tstruct inode\t\t*inode,\n\tstruct fiemap_extent_info *fieinfo,\n\tu64\t\t\tstart,\n\tu64\t\t\tlength)\n{\n\tint\t\t\terror;\n\n\txfs_ilock(XFS_I(inode), XFS_IOLOCK_SHARED);\n\tif (fieinfo->fi_flags & FIEMAP_FLAG_XATTR) {\n\t\tfieinfo->fi_flags &= ~FIEMAP_FLAG_XATTR;\n\t\terror = iomap_fiemap(inode, fieinfo, start, length,\n\t\t\t\t&xfs_xattr_iomap_ops);\n\t} else {\n\t\terror = iomap_fiemap(inode, fieinfo, start, length,\n\t\t\t\t&xfs_iomap_ops);\n\t}\n\txfs_iunlock(XFS_I(inode), XFS_IOLOCK_SHARED);\n\n\treturn error;\n}\n\nSTATIC int\nxfs_vn_tmpfile(\n\tstruct inode\t*dir,\n\tstruct dentry\t*dentry,\n\tumode_t\t\tmode)\n{\n\treturn xfs_generic_create(dir, dentry, mode, 0, true);\n}\n\nstatic const struct inode_operations xfs_inode_operations = {\n\t.get_acl\t\t= xfs_get_acl,\n\t.set_acl\t\t= xfs_set_acl,\n\t.getattr\t\t= xfs_vn_getattr,\n\t.setattr\t\t= xfs_vn_setattr,\n\t.listxattr\t\t= xfs_vn_listxattr,\n\t.fiemap\t\t\t= xfs_vn_fiemap,\n\t.update_time\t\t= xfs_vn_update_time,\n};\n\nstatic const struct inode_operations xfs_dir_inode_operations = {\n\t.create\t\t\t= xfs_vn_create,\n\t.lookup\t\t\t= xfs_vn_lookup,\n\t.link\t\t\t= xfs_vn_link,\n\t.unlink\t\t\t= xfs_vn_unlink,\n\t.symlink\t\t= xfs_vn_symlink,\n\t.mkdir\t\t\t= xfs_vn_mkdir,\n\t/*\n\t * Yes, XFS uses the same method for rmdir and unlink.\n\t *\n\t * There are some subtile differences deeper in the code,\n\t * but we use S_ISDIR to check for those.\n\t */\n\t.rmdir\t\t\t= xfs_vn_unlink,\n\t.mknod\t\t\t= xfs_vn_mknod,\n\t.rename\t\t\t= xfs_vn_rename,\n\t.get_acl\t\t= xfs_get_acl,\n\t.set_acl\t\t= xfs_set_acl,\n\t.getattr\t\t= xfs_vn_getattr,\n\t.setattr\t\t= xfs_vn_setattr,\n\t.listxattr\t\t= xfs_vn_listxattr,\n\t.update_time\t\t= xfs_vn_update_time,\n\t.tmpfile\t\t= xfs_vn_tmpfile,\n};\n\nstatic const struct inode_operations xfs_dir_ci_inode_operations = {\n\t.create\t\t\t= xfs_vn_create,\n\t.lookup\t\t\t= xfs_vn_ci_lookup,\n\t.link\t\t\t= xfs_vn_link,\n\t.unlink\t\t\t= xfs_vn_unlink,\n\t.symlink\t\t= xfs_vn_symlink,\n\t.mkdir\t\t\t= xfs_vn_mkdir,\n\t/*\n\t * Yes, XFS uses the same method for rmdir and unlink.\n\t *\n\t * There are some subtile differences deeper in the code,\n\t * but we use S_ISDIR to check for those.\n\t */\n\t.rmdir\t\t\t= xfs_vn_unlink,\n\t.mknod\t\t\t= xfs_vn_mknod,\n\t.rename\t\t\t= xfs_vn_rename,\n\t.get_acl\t\t= xfs_get_acl,\n\t.set_acl\t\t= xfs_set_acl,\n\t.getattr\t\t= xfs_vn_getattr,\n\t.setattr\t\t= xfs_vn_setattr,\n\t.listxattr\t\t= xfs_vn_listxattr,\n\t.update_time\t\t= xfs_vn_update_time,\n\t.tmpfile\t\t= xfs_vn_tmpfile,\n};\n\nstatic const struct inode_operations xfs_symlink_inode_operations = {\n\t.get_link\t\t= xfs_vn_get_link,\n\t.getattr\t\t= xfs_vn_getattr,\n\t.setattr\t\t= xfs_vn_setattr,\n\t.listxattr\t\t= xfs_vn_listxattr,\n\t.update_time\t\t= xfs_vn_update_time,\n};\n\nstatic const struct inode_operations xfs_inline_symlink_inode_operations = {\n\t.get_link\t\t= xfs_vn_get_link_inline,\n\t.getattr\t\t= xfs_vn_getattr,\n\t.setattr\t\t= xfs_vn_setattr,\n\t.listxattr\t\t= xfs_vn_listxattr,\n\t.update_time\t\t= xfs_vn_update_time,\n};\n\n/* Figure out if this file actually supports DAX. */\nstatic bool\nxfs_inode_supports_dax(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\n\t/* Only supported on non-reflinked files. */\n\tif (!S_ISREG(VFS_I(ip)->i_mode) || xfs_is_reflink_inode(ip))\n\t\treturn false;\n\n\t/* DAX mount option or DAX iflag must be set. */\n\tif (!(mp->m_flags & XFS_MOUNT_DAX) &&\n\t    !(ip->i_d.di_flags2 & XFS_DIFLAG2_DAX))\n\t\treturn false;\n\n\t/* Block size must match page size */\n\tif (mp->m_sb.sb_blocksize != PAGE_SIZE)\n\t\treturn false;\n\n\t/* Device has to support DAX too. */\n\treturn xfs_find_daxdev_for_inode(VFS_I(ip)) != NULL;\n}\n\nSTATIC void\nxfs_diflags_to_iflags(\n\tstruct inode\t\t*inode,\n\tstruct xfs_inode\t*ip)\n{\n\tuint16_t\t\tflags = ip->i_d.di_flags;\n\n\tinode->i_flags &= ~(S_IMMUTABLE | S_APPEND | S_SYNC |\n\t\t\t    S_NOATIME | S_DAX);\n\n\tif (flags & XFS_DIFLAG_IMMUTABLE)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\tif (flags & XFS_DIFLAG_APPEND)\n\t\tinode->i_flags |= S_APPEND;\n\tif (flags & XFS_DIFLAG_SYNC)\n\t\tinode->i_flags |= S_SYNC;\n\tif (flags & XFS_DIFLAG_NOATIME)\n\t\tinode->i_flags |= S_NOATIME;\n\tif (xfs_inode_supports_dax(ip))\n\t\tinode->i_flags |= S_DAX;\n}\n\n/*\n * Initialize the Linux inode.\n *\n * When reading existing inodes from disk this is called directly from xfs_iget,\n * when creating a new inode it is called from xfs_ialloc after setting up the\n * inode. These callers have different criteria for clearing XFS_INEW, so leave\n * it up to the caller to deal with unlocking the inode appropriately.\n */\nvoid\nxfs_setup_inode(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct inode\t\t*inode = &ip->i_vnode;\n\tgfp_t\t\t\tgfp_mask;\n\n\tinode->i_ino = ip->i_ino;\n\tinode->i_state = I_NEW;\n\n\tinode_sb_list_add(inode);\n\t/* make the inode look hashed for the writeback code */\n\tinode_fake_hash(inode);\n\n\tinode->i_uid    = xfs_uid_to_kuid(ip->i_d.di_uid);\n\tinode->i_gid    = xfs_gid_to_kgid(ip->i_d.di_gid);\n\n\ti_size_write(inode, ip->i_d.di_size);\n\txfs_diflags_to_iflags(inode, ip);\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\t/*\n\t\t * We set the i_rwsem class here to avoid potential races with\n\t\t * lockdep_annotate_inode_mutex_key() reinitialising the lock\n\t\t * after a filehandle lookup has already found the inode in\n\t\t * cache before it has been unlocked via unlock_new_inode().\n\t\t */\n\t\tlockdep_set_class(&inode->i_rwsem,\n\t\t\t\t  &inode->i_sb->s_type->i_mutex_dir_key);\n\t\tlockdep_set_class(&ip->i_lock.mr_lock, &xfs_dir_ilock_class);\n\t\tip->d_ops = ip->i_mount->m_dir_inode_ops;\n\t} else {\n\t\tip->d_ops = ip->i_mount->m_nondir_inode_ops;\n\t\tlockdep_set_class(&ip->i_lock.mr_lock, &xfs_nondir_ilock_class);\n\t}\n\n\t/*\n\t * Ensure all page cache allocations are done from GFP_NOFS context to\n\t * prevent direct reclaim recursion back into the filesystem and blowing\n\t * stacks or deadlocking.\n\t */\n\tgfp_mask = mapping_gfp_mask(inode->i_mapping);\n\tmapping_set_gfp_mask(inode->i_mapping, (gfp_mask & ~(__GFP_FS)));\n\n\t/*\n\t * If there is no attribute fork no ACL can exist on this inode,\n\t * and it can't have any file capabilities attached to it either.\n\t */\n\tif (!XFS_IFORK_Q(ip)) {\n\t\tinode_has_no_xattr(inode);\n\t\tcache_no_acl(inode);\n\t}\n}\n\nvoid\nxfs_setup_iops(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct inode\t\t*inode = &ip->i_vnode;\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tinode->i_op = &xfs_inode_operations;\n\t\tinode->i_fop = &xfs_file_operations;\n\t\tif (IS_DAX(inode))\n\t\t\tinode->i_mapping->a_ops = &xfs_dax_aops;\n\t\telse\n\t\t\tinode->i_mapping->a_ops = &xfs_address_space_operations;\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tif (xfs_sb_version_hasasciici(&XFS_M(inode->i_sb)->m_sb))\n\t\t\tinode->i_op = &xfs_dir_ci_inode_operations;\n\t\telse\n\t\t\tinode->i_op = &xfs_dir_inode_operations;\n\t\tinode->i_fop = &xfs_dir_file_operations;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tif (ip->i_df.if_flags & XFS_IFINLINE)\n\t\t\tinode->i_op = &xfs_inline_symlink_inode_operations;\n\t\telse\n\t\t\tinode->i_op = &xfs_symlink_inode_operations;\n\t\tbreak;\n\tdefault:\n\t\tinode->i_op = &xfs_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\t}\n}\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n * Copyright (c) 2000-2005 Silicon Graphics, Inc.\n * All Rights Reserved.\n */\n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_iomap.h\"\n\n#include <linux/xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/security.h>\n#include <linux/iversion.h>\n\n/*\n * Directories have different lock order w.r.t. mmap_sem compared to regular\n * files. This is due to readdir potentially triggering page faults on a user\n * buffer inside filldir(), and this happens with the ilock on the directory\n * held. For regular files, the lock order is the other way around - the\n * mmap_sem is taken during the page fault, and then we lock the ilock to do\n * block mapping. Hence we need a different class for the directory ilock so\n * that lockdep can tell them apart.\n */\nstatic struct lock_class_key xfs_nondir_ilock_class;\nstatic struct lock_class_key xfs_dir_ilock_class;\n\nstatic int\nxfs_initxattrs(\n\tstruct inode\t\t*inode,\n\tconst struct xattr\t*xattr_array,\n\tvoid\t\t\t*fs_info)\n{\n\tconst struct xattr\t*xattr;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tint\t\t\terror = 0;\n\n\tfor (xattr = xattr_array; xattr->name != NULL; xattr++) {\n\t\terror = xfs_attr_set(ip, xattr->name, xattr->value,\n\t\t\t\t      xattr->value_len, ATTR_SECURE);\n\t\tif (error < 0)\n\t\t\tbreak;\n\t}\n\treturn error;\n}\n\n/*\n * Hook in SELinux.  This is not quite correct yet, what we really need\n * here (as we do for default ACLs) is a mechanism by which creation of\n * these attrs can be journalled at inode creation time (along with the\n * inode, of course, such that log replay can't cause these to be lost).\n */\n\nSTATIC int\nxfs_init_security(\n\tstruct inode\t*inode,\n\tstruct inode\t*dir,\n\tconst struct qstr *qstr)\n{\n\treturn security_inode_init_security(inode, dir, qstr,\n\t\t\t\t\t     &xfs_initxattrs, NULL);\n}\n\nstatic void\nxfs_dentry_to_name(\n\tstruct xfs_name\t*namep,\n\tstruct dentry\t*dentry)\n{\n\tnamep->name = dentry->d_name.name;\n\tnamep->len = dentry->d_name.len;\n\tnamep->type = XFS_DIR3_FT_UNKNOWN;\n}\n\nstatic int\nxfs_dentry_mode_to_name(\n\tstruct xfs_name\t*namep,\n\tstruct dentry\t*dentry,\n\tint\t\tmode)\n{\n\tnamep->name = dentry->d_name.name;\n\tnamep->len = dentry->d_name.len;\n\tnamep->type = xfs_mode_to_ftype(mode);\n\n\tif (unlikely(namep->type == XFS_DIR3_FT_UNKNOWN))\n\t\treturn -EFSCORRUPTED;\n\n\treturn 0;\n}\n\nSTATIC void\nxfs_cleanup_inode(\n\tstruct inode\t*dir,\n\tstruct inode\t*inode,\n\tstruct dentry\t*dentry)\n{\n\tstruct xfs_name\tteardown;\n\n\t/* Oh, the horror.\n\t * If we can't add the ACL or we fail in\n\t * xfs_init_security we must back out.\n\t * ENOSPC can hit here, among other things.\n\t */\n\txfs_dentry_to_name(&teardown, dentry);\n\n\txfs_remove(XFS_I(dir), &teardown, XFS_I(inode));\n}\n\nSTATIC int\nxfs_generic_create(\n\tstruct inode\t*dir,\n\tstruct dentry\t*dentry,\n\tumode_t\t\tmode,\n\tdev_t\t\trdev,\n\tbool\t\ttmpfile)\t/* unnamed file */\n{\n\tstruct inode\t*inode;\n\tstruct xfs_inode *ip = NULL;\n\tstruct posix_acl *default_acl, *acl;\n\tstruct xfs_name\tname;\n\tint\t\terror;\n\n\t/*\n\t * Irix uses Missed'em'V split, but doesn't want to see\n\t * the upper 5 bits of (14bit) major.\n\t */\n\tif (S_ISCHR(mode) || S_ISBLK(mode)) {\n\t\tif (unlikely(!sysv_valid_dev(rdev) || MAJOR(rdev) & ~0x1ff))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\trdev = 0;\n\t}\n\n\terror = posix_acl_create(dir, &mode, &default_acl, &acl);\n\tif (error)\n\t\treturn error;\n\n\t/* Verify mode is valid also for tmpfile case */\n\terror = xfs_dentry_mode_to_name(&name, dentry, mode);\n\tif (unlikely(error))\n\t\tgoto out_free_acl;\n\n\tif (!tmpfile) {\n\t\terror = xfs_create(XFS_I(dir), &name, mode, rdev, &ip);\n\t} else {\n\t\terror = xfs_create_tmpfile(XFS_I(dir), mode, &ip);\n\t}\n\tif (unlikely(error))\n\t\tgoto out_free_acl;\n\n\tinode = VFS_I(ip);\n\n\terror = xfs_init_security(inode, dir, &dentry->d_name);\n\tif (unlikely(error))\n\t\tgoto out_cleanup_inode;\n\n#ifdef CONFIG_XFS_POSIX_ACL\n\tif (default_acl) {\n\t\terror = __xfs_set_acl(inode, default_acl, ACL_TYPE_DEFAULT);\n\t\tif (error)\n\t\t\tgoto out_cleanup_inode;\n\t}\n\tif (acl) {\n\t\terror = __xfs_set_acl(inode, acl, ACL_TYPE_ACCESS);\n\t\tif (error)\n\t\t\tgoto out_cleanup_inode;\n\t}\n#endif\n\n\txfs_setup_iops(ip);\n\n\tif (tmpfile) {\n\t\t/*\n\t\t * The VFS requires that any inode fed to d_tmpfile must have\n\t\t * nlink == 1 so that it can decrement the nlink in d_tmpfile.\n\t\t * However, we created the temp file with nlink == 0 because\n\t\t * we're not allowed to put an inode with nlink > 0 on the\n\t\t * unlinked list.  Therefore we have to set nlink to 1 so that\n\t\t * d_tmpfile can immediately set it back to zero.\n\t\t */\n\t\tset_nlink(inode, 1);\n\t\td_tmpfile(dentry, inode);\n\t} else\n\t\td_instantiate(dentry, inode);\n\n\txfs_finish_inode_setup(ip);\n\n out_free_acl:\n\tif (default_acl)\n\t\tposix_acl_release(default_acl);\n\tif (acl)\n\t\tposix_acl_release(acl);\n\treturn error;\n\n out_cleanup_inode:\n\txfs_finish_inode_setup(ip);\n\tif (!tmpfile)\n\t\txfs_cleanup_inode(dir, inode, dentry);\n\txfs_irele(ip);\n\tgoto out_free_acl;\n}\n\nSTATIC int\nxfs_vn_mknod(\n\tstruct inode\t*dir,\n\tstruct dentry\t*dentry,\n\tumode_t\t\tmode,\n\tdev_t\t\trdev)\n{\n\treturn xfs_generic_create(dir, dentry, mode, rdev, false);\n}\n\nSTATIC int\nxfs_vn_create(\n\tstruct inode\t*dir,\n\tstruct dentry\t*dentry,\n\tumode_t\t\tmode,\n\tbool\t\tflags)\n{\n\treturn xfs_vn_mknod(dir, dentry, mode, 0);\n}\n\nSTATIC int\nxfs_vn_mkdir(\n\tstruct inode\t*dir,\n\tstruct dentry\t*dentry,\n\tumode_t\t\tmode)\n{\n\treturn xfs_vn_mknod(dir, dentry, mode|S_IFDIR, 0);\n}\n\nSTATIC struct dentry *\nxfs_vn_lookup(\n\tstruct inode\t*dir,\n\tstruct dentry\t*dentry,\n\tunsigned int flags)\n{\n\tstruct inode *inode;\n\tstruct xfs_inode *cip;\n\tstruct xfs_name\tname;\n\tint\t\terror;\n\n\tif (dentry->d_name.len >= MAXNAMELEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\txfs_dentry_to_name(&name, dentry);\n\terror = xfs_lookup(XFS_I(dir), &name, &cip, NULL);\n\tif (likely(!error))\n\t\tinode = VFS_I(cip);\n\telse if (likely(error == -ENOENT))\n\t\tinode = NULL;\n\telse\n\t\tinode = ERR_PTR(error);\n\treturn d_splice_alias(inode, dentry);\n}\n\nSTATIC struct dentry *\nxfs_vn_ci_lookup(\n\tstruct inode\t*dir,\n\tstruct dentry\t*dentry,\n\tunsigned int flags)\n{\n\tstruct xfs_inode *ip;\n\tstruct xfs_name\txname;\n\tstruct xfs_name ci_name;\n\tstruct qstr\tdname;\n\tint\t\terror;\n\n\tif (dentry->d_name.len >= MAXNAMELEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\txfs_dentry_to_name(&xname, dentry);\n\terror = xfs_lookup(XFS_I(dir), &xname, &ip, &ci_name);\n\tif (unlikely(error)) {\n\t\tif (unlikely(error != -ENOENT))\n\t\t\treturn ERR_PTR(error);\n\t\t/*\n\t\t * call d_add(dentry, NULL) here when d_drop_negative_children\n\t\t * is called in xfs_vn_mknod (ie. allow negative dentries\n\t\t * with CI filesystems).\n\t\t */\n\t\treturn NULL;\n\t}\n\n\t/* if exact match, just splice and exit */\n\tif (!ci_name.name)\n\t\treturn d_splice_alias(VFS_I(ip), dentry);\n\n\t/* else case-insensitive match... */\n\tdname.name = ci_name.name;\n\tdname.len = ci_name.len;\n\tdentry = d_add_ci(dentry, VFS_I(ip), &dname);\n\tkmem_free(ci_name.name);\n\treturn dentry;\n}\n\nSTATIC int\nxfs_vn_link(\n\tstruct dentry\t*old_dentry,\n\tstruct inode\t*dir,\n\tstruct dentry\t*dentry)\n{\n\tstruct inode\t*inode = d_inode(old_dentry);\n\tstruct xfs_name\tname;\n\tint\t\terror;\n\n\terror = xfs_dentry_mode_to_name(&name, dentry, inode->i_mode);\n\tif (unlikely(error))\n\t\treturn error;\n\n\terror = xfs_link(XFS_I(dir), XFS_I(inode), &name);\n\tif (unlikely(error))\n\t\treturn error;\n\n\tihold(inode);\n\td_instantiate(dentry, inode);\n\treturn 0;\n}\n\nSTATIC int\nxfs_vn_unlink(\n\tstruct inode\t*dir,\n\tstruct dentry\t*dentry)\n{\n\tstruct xfs_name\tname;\n\tint\t\terror;\n\n\txfs_dentry_to_name(&name, dentry);\n\n\terror = xfs_remove(XFS_I(dir), &name, XFS_I(d_inode(dentry)));\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * With unlink, the VFS makes the dentry \"negative\": no inode,\n\t * but still hashed. This is incompatible with case-insensitive\n\t * mode, so invalidate (unhash) the dentry in CI-mode.\n\t */\n\tif (xfs_sb_version_hasasciici(&XFS_M(dir->i_sb)->m_sb))\n\t\td_invalidate(dentry);\n\treturn 0;\n}\n\nSTATIC int\nxfs_vn_symlink(\n\tstruct inode\t*dir,\n\tstruct dentry\t*dentry,\n\tconst char\t*symname)\n{\n\tstruct inode\t*inode;\n\tstruct xfs_inode *cip = NULL;\n\tstruct xfs_name\tname;\n\tint\t\terror;\n\tumode_t\t\tmode;\n\n\tmode = S_IFLNK |\n\t\t(irix_symlink_mode ? 0777 & ~current_umask() : S_IRWXUGO);\n\terror = xfs_dentry_mode_to_name(&name, dentry, mode);\n\tif (unlikely(error))\n\t\tgoto out;\n\n\terror = xfs_symlink(XFS_I(dir), &name, symname, mode, &cip);\n\tif (unlikely(error))\n\t\tgoto out;\n\n\tinode = VFS_I(cip);\n\n\terror = xfs_init_security(inode, dir, &dentry->d_name);\n\tif (unlikely(error))\n\t\tgoto out_cleanup_inode;\n\n\txfs_setup_iops(cip);\n\n\td_instantiate(dentry, inode);\n\txfs_finish_inode_setup(cip);\n\treturn 0;\n\n out_cleanup_inode:\n\txfs_finish_inode_setup(cip);\n\txfs_cleanup_inode(dir, inode, dentry);\n\txfs_irele(cip);\n out:\n\treturn error;\n}\n\nSTATIC int\nxfs_vn_rename(\n\tstruct inode\t*odir,\n\tstruct dentry\t*odentry,\n\tstruct inode\t*ndir,\n\tstruct dentry\t*ndentry,\n\tunsigned int\tflags)\n{\n\tstruct inode\t*new_inode = d_inode(ndentry);\n\tint\t\tomode = 0;\n\tint\t\terror;\n\tstruct xfs_name\toname;\n\tstruct xfs_name\tnname;\n\n\tif (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE | RENAME_WHITEOUT))\n\t\treturn -EINVAL;\n\n\t/* if we are exchanging files, we need to set i_mode of both files */\n\tif (flags & RENAME_EXCHANGE)\n\t\tomode = d_inode(ndentry)->i_mode;\n\n\terror = xfs_dentry_mode_to_name(&oname, odentry, omode);\n\tif (omode && unlikely(error))\n\t\treturn error;\n\n\terror = xfs_dentry_mode_to_name(&nname, ndentry,\n\t\t\t\t\td_inode(odentry)->i_mode);\n\tif (unlikely(error))\n\t\treturn error;\n\n\treturn xfs_rename(XFS_I(odir), &oname, XFS_I(d_inode(odentry)),\n\t\t\t  XFS_I(ndir), &nname,\n\t\t\t  new_inode ? XFS_I(new_inode) : NULL, flags);\n}\n\n/*\n * careful here - this function can get called recursively, so\n * we need to be very careful about how much stack we use.\n * uio is kmalloced for this reason...\n */\nSTATIC const char *\nxfs_vn_get_link(\n\tstruct dentry\t\t*dentry,\n\tstruct inode\t\t*inode,\n\tstruct delayed_call\t*done)\n{\n\tchar\t\t\t*link;\n\tint\t\t\terror = -ENOMEM;\n\n\tif (!dentry)\n\t\treturn ERR_PTR(-ECHILD);\n\n\tlink = kmalloc(XFS_SYMLINK_MAXLEN+1, GFP_KERNEL);\n\tif (!link)\n\t\tgoto out_err;\n\n\terror = xfs_readlink(XFS_I(d_inode(dentry)), link);\n\tif (unlikely(error))\n\t\tgoto out_kfree;\n\n\tset_delayed_call(done, kfree_link, link);\n\treturn link;\n\n out_kfree:\n\tkfree(link);\n out_err:\n\treturn ERR_PTR(error);\n}\n\nSTATIC const char *\nxfs_vn_get_link_inline(\n\tstruct dentry\t\t*dentry,\n\tstruct inode\t\t*inode,\n\tstruct delayed_call\t*done)\n{\n\tchar\t\t\t*link;\n\n\tASSERT(XFS_I(inode)->i_df.if_flags & XFS_IFINLINE);\n\n\t/*\n\t * The VFS crashes on a NULL pointer, so return -EFSCORRUPTED if\n\t * if_data is junk.\n\t */\n\tlink = XFS_I(inode)->i_df.if_u1.if_data;\n\tif (!link)\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\treturn link;\n}\n\nSTATIC int\nxfs_vn_getattr(\n\tconst struct path\t*path,\n\tstruct kstat\t\t*stat,\n\tu32\t\t\trequest_mask,\n\tunsigned int\t\tquery_flags)\n{\n\tstruct inode\t\t*inode = d_inode(path->dentry);\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\n\ttrace_xfs_getattr(ip);\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tstat->size = XFS_ISIZE(ip);\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->mode = inode->i_mode;\n\tstat->nlink = inode->i_nlink;\n\tstat->uid = inode->i_uid;\n\tstat->gid = inode->i_gid;\n\tstat->ino = ip->i_ino;\n\tstat->atime = inode->i_atime;\n\tstat->mtime = inode->i_mtime;\n\tstat->ctime = inode->i_ctime;\n\tstat->blocks =\n\t\tXFS_FSB_TO_BB(mp, ip->i_d.di_nblocks + ip->i_delayed_blks);\n\n\tif (ip->i_d.di_version == 3) {\n\t\tif (request_mask & STATX_BTIME) {\n\t\t\tstat->result_mask |= STATX_BTIME;\n\t\t\tstat->btime.tv_sec = ip->i_d.di_crtime.t_sec;\n\t\t\tstat->btime.tv_nsec = ip->i_d.di_crtime.t_nsec;\n\t\t}\n\t}\n\n\t/*\n\t * Note: If you add another clause to set an attribute flag, please\n\t * update attributes_mask below.\n\t */\n\tif (ip->i_d.di_flags & XFS_DIFLAG_IMMUTABLE)\n\t\tstat->attributes |= STATX_ATTR_IMMUTABLE;\n\tif (ip->i_d.di_flags & XFS_DIFLAG_APPEND)\n\t\tstat->attributes |= STATX_ATTR_APPEND;\n\tif (ip->i_d.di_flags & XFS_DIFLAG_NODUMP)\n\t\tstat->attributes |= STATX_ATTR_NODUMP;\n\n\tstat->attributes_mask |= (STATX_ATTR_IMMUTABLE |\n\t\t\t\t  STATX_ATTR_APPEND |\n\t\t\t\t  STATX_ATTR_NODUMP);\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\t\tstat->blksize = BLKDEV_IOSIZE;\n\t\tstat->rdev = inode->i_rdev;\n\t\tbreak;\n\tdefault:\n\t\tif (XFS_IS_REALTIME_INODE(ip)) {\n\t\t\t/*\n\t\t\t * If the file blocks are being allocated from a\n\t\t\t * realtime volume, then return the inode's realtime\n\t\t\t * extent size or the realtime volume's extent size.\n\t\t\t */\n\t\t\tstat->blksize =\n\t\t\t\txfs_get_extsz_hint(ip) << mp->m_sb.sb_blocklog;\n\t\t} else\n\t\t\tstat->blksize = xfs_preferred_iosize(mp);\n\t\tstat->rdev = 0;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nxfs_setattr_mode(\n\tstruct xfs_inode\t*ip,\n\tstruct iattr\t\t*iattr)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tumode_t\t\t\tmode = iattr->ia_mode;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tinode->i_mode &= S_IFMT;\n\tinode->i_mode |= mode & ~S_IFMT;\n}\n\nvoid\nxfs_setattr_time(\n\tstruct xfs_inode\t*ip,\n\tstruct iattr\t\t*iattr)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tif (iattr->ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = iattr->ia_atime;\n\tif (iattr->ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = iattr->ia_ctime;\n\tif (iattr->ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = iattr->ia_mtime;\n}\n\nstatic int\nxfs_vn_change_ok(\n\tstruct dentry\t*dentry,\n\tstruct iattr\t*iattr)\n{\n\tstruct xfs_mount\t*mp = XFS_I(d_inode(dentry))->i_mount;\n\n\tif (mp->m_flags & XFS_MOUNT_RDONLY)\n\t\treturn -EROFS;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\treturn setattr_prepare(dentry, iattr);\n}\n\n/*\n * Set non-size attributes of an inode.\n *\n * Caution: The caller of this function is responsible for calling\n * setattr_prepare() or otherwise verifying the change is fine.\n */\nint\nxfs_setattr_nonsize(\n\tstruct xfs_inode\t*ip,\n\tstruct iattr\t\t*iattr,\n\tint\t\t\tflags)\n{\n\txfs_mount_t\t\t*mp = ip->i_mount;\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tint\t\t\tmask = iattr->ia_valid;\n\txfs_trans_t\t\t*tp;\n\tint\t\t\terror;\n\tkuid_t\t\t\tuid = GLOBAL_ROOT_UID, iuid = GLOBAL_ROOT_UID;\n\tkgid_t\t\t\tgid = GLOBAL_ROOT_GID, igid = GLOBAL_ROOT_GID;\n\tstruct xfs_dquot\t*udqp = NULL, *gdqp = NULL;\n\tstruct xfs_dquot\t*olddquot1 = NULL, *olddquot2 = NULL;\n\n\tASSERT((mask & ATTR_SIZE) == 0);\n\n\t/*\n\t * If disk quotas is on, we make sure that the dquots do exist on disk,\n\t * before we start any other transactions. Trying to do this later\n\t * is messy. We don't care to take a readlock to look at the ids\n\t * in inode here, because we can't hold it across the trans_reserve.\n\t * If the IDs do change before we take the ilock, we're covered\n\t * because the i_*dquot fields will get updated anyway.\n\t */\n\tif (XFS_IS_QUOTA_ON(mp) && (mask & (ATTR_UID|ATTR_GID))) {\n\t\tuint\tqflags = 0;\n\n\t\tif ((mask & ATTR_UID) && XFS_IS_UQUOTA_ON(mp)) {\n\t\t\tuid = iattr->ia_uid;\n\t\t\tqflags |= XFS_QMOPT_UQUOTA;\n\t\t} else {\n\t\t\tuid = inode->i_uid;\n\t\t}\n\t\tif ((mask & ATTR_GID) && XFS_IS_GQUOTA_ON(mp)) {\n\t\t\tgid = iattr->ia_gid;\n\t\t\tqflags |= XFS_QMOPT_GQUOTA;\n\t\t}  else {\n\t\t\tgid = inode->i_gid;\n\t\t}\n\n\t\t/*\n\t\t * We take a reference when we initialize udqp and gdqp,\n\t\t * so it is important that we never blindly double trip on\n\t\t * the same variable. See xfs_create() for an example.\n\t\t */\n\t\tASSERT(udqp == NULL);\n\t\tASSERT(gdqp == NULL);\n\t\terror = xfs_qm_vop_dqalloc(ip, xfs_kuid_to_uid(uid),\n\t\t\t\t\t   xfs_kgid_to_gid(gid),\n\t\t\t\t\t   xfs_get_projid(ip),\n\t\t\t\t\t   qflags, &udqp, &gdqp, NULL);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\terror = xfs_trans_alloc(mp, &M_RES(mp)->tr_ichange, 0, 0, 0, &tp);\n\tif (error)\n\t\tgoto out_dqrele;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, 0);\n\n\t/*\n\t * Change file ownership.  Must be the owner or privileged.\n\t */\n\tif (mask & (ATTR_UID|ATTR_GID)) {\n\t\t/*\n\t\t * These IDs could have changed since we last looked at them.\n\t\t * But, we're assured that if the ownership did change\n\t\t * while we didn't have the inode locked, inode's dquot(s)\n\t\t * would have changed also.\n\t\t */\n\t\tiuid = inode->i_uid;\n\t\tigid = inode->i_gid;\n\t\tgid = (mask & ATTR_GID) ? iattr->ia_gid : igid;\n\t\tuid = (mask & ATTR_UID) ? iattr->ia_uid : iuid;\n\n\t\t/*\n\t\t * Do a quota reservation only if uid/gid is actually\n\t\t * going to change.\n\t\t */\n\t\tif (XFS_IS_QUOTA_RUNNING(mp) &&\n\t\t    ((XFS_IS_UQUOTA_ON(mp) && !uid_eq(iuid, uid)) ||\n\t\t     (XFS_IS_GQUOTA_ON(mp) && !gid_eq(igid, gid)))) {\n\t\t\tASSERT(tp);\n\t\t\terror = xfs_qm_vop_chown_reserve(tp, ip, udqp, gdqp,\n\t\t\t\t\t\tNULL, capable(CAP_FOWNER) ?\n\t\t\t\t\t\tXFS_QMOPT_FORCE_RES : 0);\n\t\t\tif (error)\t/* out of quota */\n\t\t\t\tgoto out_cancel;\n\t\t}\n\t}\n\n\t/*\n\t * Change file ownership.  Must be the owner or privileged.\n\t */\n\tif (mask & (ATTR_UID|ATTR_GID)) {\n\t\t/*\n\t\t * CAP_FSETID overrides the following restrictions:\n\t\t *\n\t\t * The set-user-ID and set-group-ID bits of a file will be\n\t\t * cleared upon successful return from chown()\n\t\t */\n\t\tif ((inode->i_mode & (S_ISUID|S_ISGID)) &&\n\t\t    !capable(CAP_FSETID))\n\t\t\tinode->i_mode &= ~(S_ISUID|S_ISGID);\n\n\t\t/*\n\t\t * Change the ownerships and register quota modifications\n\t\t * in the transaction.\n\t\t */\n\t\tif (!uid_eq(iuid, uid)) {\n\t\t\tif (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_UQUOTA_ON(mp)) {\n\t\t\t\tASSERT(mask & ATTR_UID);\n\t\t\t\tASSERT(udqp);\n\t\t\t\tolddquot1 = xfs_qm_vop_chown(tp, ip,\n\t\t\t\t\t\t\t&ip->i_udquot, udqp);\n\t\t\t}\n\t\t\tip->i_d.di_uid = xfs_kuid_to_uid(uid);\n\t\t\tinode->i_uid = uid;\n\t\t}\n\t\tif (!gid_eq(igid, gid)) {\n\t\t\tif (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_GQUOTA_ON(mp)) {\n\t\t\t\tASSERT(xfs_sb_version_has_pquotino(&mp->m_sb) ||\n\t\t\t\t       !XFS_IS_PQUOTA_ON(mp));\n\t\t\t\tASSERT(mask & ATTR_GID);\n\t\t\t\tASSERT(gdqp);\n\t\t\t\tolddquot2 = xfs_qm_vop_chown(tp, ip,\n\t\t\t\t\t\t\t&ip->i_gdquot, gdqp);\n\t\t\t}\n\t\t\tip->i_d.di_gid = xfs_kgid_to_gid(gid);\n\t\t\tinode->i_gid = gid;\n\t\t}\n\t}\n\n\tif (mask & ATTR_MODE)\n\t\txfs_setattr_mode(ip, iattr);\n\tif (mask & (ATTR_ATIME|ATTR_CTIME|ATTR_MTIME))\n\t\txfs_setattr_time(ip, iattr);\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tXFS_STATS_INC(mp, xs_ig_attrchg);\n\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(tp);\n\terror = xfs_trans_commit(tp);\n\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\t/*\n\t * Release any dquot(s) the inode had kept before chown.\n\t */\n\txfs_qm_dqrele(olddquot1);\n\txfs_qm_dqrele(olddquot2);\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * XXX(hch): Updating the ACL entries is not atomic vs the i_mode\n\t * \t     update.  We could avoid this with linked transactions\n\t * \t     and passing down the transaction pointer all the way\n\t *\t     to attr_set.  No previous user of the generic\n\t * \t     Posix ACL code seems to care about this issue either.\n\t */\n\tif ((mask & ATTR_MODE) && !(flags & XFS_ATTR_NOACL)) {\n\t\terror = posix_acl_chmod(inode, inode->i_mode);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n\nout_cancel:\n\txfs_trans_cancel(tp);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\nout_dqrele:\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\treturn error;\n}\n\nint\nxfs_vn_setattr_nonsize(\n\tstruct dentry\t\t*dentry,\n\tstruct iattr\t\t*iattr)\n{\n\tstruct xfs_inode\t*ip = XFS_I(d_inode(dentry));\n\tint error;\n\n\ttrace_xfs_setattr(ip);\n\n\terror = xfs_vn_change_ok(dentry, iattr);\n\tif (error)\n\t\treturn error;\n\treturn xfs_setattr_nonsize(ip, iattr, 0);\n}\n\n/*\n * Truncate file.  Must have write permission and not be a directory.\n *\n * Caution: The caller of this function is responsible for calling\n * setattr_prepare() or otherwise verifying the change is fine.\n */\nSTATIC int\nxfs_setattr_size(\n\tstruct xfs_inode\t*ip,\n\tstruct iattr\t\t*iattr)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct inode\t\t*inode = VFS_I(ip);\n\txfs_off_t\t\toldsize, newsize;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\tuint\t\t\tlock_flags = 0;\n\tbool\t\t\tdid_zeroing = false;\n\n\tASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\tASSERT(xfs_isilocked(ip, XFS_MMAPLOCK_EXCL));\n\tASSERT(S_ISREG(inode->i_mode));\n\tASSERT((iattr->ia_valid & (ATTR_UID|ATTR_GID|ATTR_ATIME|ATTR_ATIME_SET|\n\t\tATTR_MTIME_SET|ATTR_KILL_PRIV|ATTR_TIMES_SET)) == 0);\n\n\toldsize = inode->i_size;\n\tnewsize = iattr->ia_size;\n\n\t/*\n\t * Short circuit the truncate case for zero length files.\n\t */\n\tif (newsize == 0 && oldsize == 0 && ip->i_d.di_nextents == 0) {\n\t\tif (!(iattr->ia_valid & (ATTR_CTIME|ATTR_MTIME)))\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * Use the regular setattr path to update the timestamps.\n\t\t */\n\t\tiattr->ia_valid &= ~ATTR_SIZE;\n\t\treturn xfs_setattr_nonsize(ip, iattr, 0);\n\t}\n\n\t/*\n\t * Make sure that the dquots are attached to the inode.\n\t */\n\terror = xfs_qm_dqattach(ip);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Wait for all direct I/O to complete.\n\t */\n\tinode_dio_wait(inode);\n\n\t/*\n\t * File data changes must be complete before we start the transaction to\n\t * modify the inode.  This needs to be done before joining the inode to\n\t * the transaction because the inode cannot be unlocked once it is a\n\t * part of the transaction.\n\t *\n\t * Start with zeroing any data beyond EOF that we may expose on file\n\t * extension, or zeroing out the rest of the block on a downward\n\t * truncate.\n\t */\n\tif (newsize > oldsize) {\n\t\ttrace_xfs_zero_eof(ip, oldsize, newsize - oldsize);\n\t\terror = iomap_zero_range(inode, oldsize, newsize - oldsize,\n\t\t\t\t&did_zeroing, &xfs_iomap_ops);\n\t} else {\n\t\terror = iomap_truncate_page(inode, newsize, &did_zeroing,\n\t\t\t\t&xfs_iomap_ops);\n\t}\n\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * We've already locked out new page faults, so now we can safely remove\n\t * pages from the page cache knowing they won't get refaulted until we\n\t * drop the XFS_MMAP_EXCL lock after the extent manipulations are\n\t * complete. The truncate_setsize() call also cleans partial EOF page\n\t * PTEs on extending truncates and hence ensures sub-page block size\n\t * filesystems are correctly handled, too.\n\t *\n\t * We have to do all the page cache truncate work outside the\n\t * transaction context as the \"lock\" order is page lock->log space\n\t * reservation as defined by extent allocation in the writeback path.\n\t * Hence a truncate can fail with ENOMEM from xfs_trans_alloc(), but\n\t * having already truncated the in-memory version of the file (i.e. made\n\t * user visible changes). There's not much we can do about this, except\n\t * to hope that the caller sees ENOMEM and retries the truncate\n\t * operation.\n\t *\n\t * And we update in-core i_size and truncate page cache beyond newsize\n\t * before writeback the [di_size, newsize] range, so we're guaranteed\n\t * not to write stale data past the new EOF on truncate down.\n\t */\n\ttruncate_setsize(inode, newsize);\n\n\t/*\n\t * We are going to log the inode size change in this transaction so\n\t * any previous writes that are beyond the on disk EOF and the new\n\t * EOF that have not been written out need to be written here.  If we\n\t * do not write the data out, we expose ourselves to the null files\n\t * problem. Note that this includes any block zeroing we did above;\n\t * otherwise those blocks may not be zeroed after a crash.\n\t */\n\tif (did_zeroing ||\n\t    (newsize > ip->i_d.di_size && oldsize != ip->i_d.di_size)) {\n\t\terror = filemap_write_and_wait_range(VFS_I(ip)->i_mapping,\n\t\t\t\t\t\tip->i_d.di_size, newsize - 1);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\terror = xfs_trans_alloc(mp, &M_RES(mp)->tr_itruncate, 0, 0, 0, &tp);\n\tif (error)\n\t\treturn error;\n\n\tlock_flags |= XFS_ILOCK_EXCL;\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, 0);\n\n\t/*\n\t * Only change the c/mtime if we are changing the size or we are\n\t * explicitly asked to change it.  This handles the semantic difference\n\t * between truncate() and ftruncate() as implemented in the VFS.\n\t *\n\t * The regular truncate() case without ATTR_CTIME and ATTR_MTIME is a\n\t * special case where we need to update the times despite not having\n\t * these flags set.  For all other operations the VFS set these flags\n\t * explicitly if it wants a timestamp update.\n\t */\n\tif (newsize != oldsize &&\n\t    !(iattr->ia_valid & (ATTR_CTIME | ATTR_MTIME))) {\n\t\tiattr->ia_ctime = iattr->ia_mtime =\n\t\t\tcurrent_time(inode);\n\t\tiattr->ia_valid |= ATTR_CTIME | ATTR_MTIME;\n\t}\n\n\t/*\n\t * The first thing we do is set the size to new_size permanently on\n\t * disk.  This way we don't have to worry about anyone ever being able\n\t * to look at the data being freed even in the face of a crash.\n\t * What we're getting around here is the case where we free a block, it\n\t * is allocated to another file, it is written to, and then we crash.\n\t * If the new data gets written to the file but the log buffers\n\t * containing the free and reallocation don't, then we'd end up with\n\t * garbage in the blocks being freed.  As long as we make the new size\n\t * permanent before actually freeing any blocks it doesn't matter if\n\t * they get written to.\n\t */\n\tip->i_d.di_size = newsize;\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tif (newsize <= oldsize) {\n\t\terror = xfs_itruncate_extents(&tp, ip, XFS_DATA_FORK, newsize);\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\n\t\t/*\n\t\t * Truncated \"down\", so we're removing references to old data\n\t\t * here - if we delay flushing for a long time, we expose\n\t\t * ourselves unduly to the notorious NULL files problem.  So,\n\t\t * we mark this inode and flush it when the file is closed,\n\t\t * and do not wait the usual (long) time for writeout.\n\t\t */\n\t\txfs_iflags_set(ip, XFS_ITRUNCATED);\n\n\t\t/* A truncate down always removes post-EOF blocks. */\n\t\txfs_inode_clear_eofblocks_tag(ip);\n\t}\n\n\tif (iattr->ia_valid & ATTR_MODE)\n\t\txfs_setattr_mode(ip, iattr);\n\tif (iattr->ia_valid & (ATTR_ATIME|ATTR_CTIME|ATTR_MTIME))\n\t\txfs_setattr_time(ip, iattr);\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tXFS_STATS_INC(mp, xs_ig_attrchg);\n\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(tp);\n\n\terror = xfs_trans_commit(tp);\nout_unlock:\n\tif (lock_flags)\n\t\txfs_iunlock(ip, lock_flags);\n\treturn error;\n\nout_trans_cancel:\n\txfs_trans_cancel(tp);\n\tgoto out_unlock;\n}\n\nint\nxfs_vn_setattr_size(\n\tstruct dentry\t\t*dentry,\n\tstruct iattr\t\t*iattr)\n{\n\tstruct xfs_inode\t*ip = XFS_I(d_inode(dentry));\n\tint error;\n\n\ttrace_xfs_setattr(ip);\n\n\terror = xfs_vn_change_ok(dentry, iattr);\n\tif (error)\n\t\treturn error;\n\treturn xfs_setattr_size(ip, iattr);\n}\n\nSTATIC int\nxfs_vn_setattr(\n\tstruct dentry\t\t*dentry,\n\tstruct iattr\t\t*iattr)\n{\n\tint\t\t\terror;\n\n\tif (iattr->ia_valid & ATTR_SIZE) {\n\t\tstruct inode\t\t*inode = d_inode(dentry);\n\t\tstruct xfs_inode\t*ip = XFS_I(inode);\n\t\tuint\t\t\tiolock;\n\n\t\txfs_ilock(ip, XFS_MMAPLOCK_EXCL);\n\t\tiolock = XFS_IOLOCK_EXCL | XFS_MMAPLOCK_EXCL;\n\n\t\terror = xfs_break_layouts(inode, &iolock, BREAK_UNMAP);\n\t\tif (error) {\n\t\t\txfs_iunlock(ip, XFS_MMAPLOCK_EXCL);\n\t\t\treturn error;\n\t\t}\n\n\t\terror = xfs_vn_setattr_size(dentry, iattr);\n\t\txfs_iunlock(ip, XFS_MMAPLOCK_EXCL);\n\t} else {\n\t\terror = xfs_vn_setattr_nonsize(dentry, iattr);\n\t}\n\n\treturn error;\n}\n\nSTATIC int\nxfs_vn_update_time(\n\tstruct inode\t\t*inode,\n\tstruct timespec64\t*now,\n\tint\t\t\tflags)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tint\t\t\tlog_flags = XFS_ILOG_TIMESTAMP;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\ttrace_xfs_update_time(ip);\n\n\tif (inode->i_sb->s_flags & SB_LAZYTIME) {\n\t\tif (!((flags & S_VERSION) &&\n\t\t      inode_maybe_inc_iversion(inode, false)))\n\t\t\treturn generic_update_time(inode, now, flags);\n\n\t\t/* Capture the iversion update that just occurred */\n\t\tlog_flags |= XFS_ILOG_CORE;\n\t}\n\n\terror = xfs_trans_alloc(mp, &M_RES(mp)->tr_fsyncts, 0, 0, 0, &tp);\n\tif (error)\n\t\treturn error;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\tif (flags & S_CTIME)\n\t\tinode->i_ctime = *now;\n\tif (flags & S_MTIME)\n\t\tinode->i_mtime = *now;\n\tif (flags & S_ATIME)\n\t\tinode->i_atime = *now;\n\n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\txfs_trans_log_inode(tp, ip, log_flags);\n\treturn xfs_trans_commit(tp);\n}\n\nSTATIC int\nxfs_vn_fiemap(\n\tstruct inode\t\t*inode,\n\tstruct fiemap_extent_info *fieinfo,\n\tu64\t\t\tstart,\n\tu64\t\t\tlength)\n{\n\tint\t\t\terror;\n\n\txfs_ilock(XFS_I(inode), XFS_IOLOCK_SHARED);\n\tif (fieinfo->fi_flags & FIEMAP_FLAG_XATTR) {\n\t\tfieinfo->fi_flags &= ~FIEMAP_FLAG_XATTR;\n\t\terror = iomap_fiemap(inode, fieinfo, start, length,\n\t\t\t\t&xfs_xattr_iomap_ops);\n\t} else {\n\t\terror = iomap_fiemap(inode, fieinfo, start, length,\n\t\t\t\t&xfs_iomap_ops);\n\t}\n\txfs_iunlock(XFS_I(inode), XFS_IOLOCK_SHARED);\n\n\treturn error;\n}\n\nSTATIC int\nxfs_vn_tmpfile(\n\tstruct inode\t*dir,\n\tstruct dentry\t*dentry,\n\tumode_t\t\tmode)\n{\n\treturn xfs_generic_create(dir, dentry, mode, 0, true);\n}\n\nstatic const struct inode_operations xfs_inode_operations = {\n\t.get_acl\t\t= xfs_get_acl,\n\t.set_acl\t\t= xfs_set_acl,\n\t.getattr\t\t= xfs_vn_getattr,\n\t.setattr\t\t= xfs_vn_setattr,\n\t.listxattr\t\t= xfs_vn_listxattr,\n\t.fiemap\t\t\t= xfs_vn_fiemap,\n\t.update_time\t\t= xfs_vn_update_time,\n};\n\nstatic const struct inode_operations xfs_dir_inode_operations = {\n\t.create\t\t\t= xfs_vn_create,\n\t.lookup\t\t\t= xfs_vn_lookup,\n\t.link\t\t\t= xfs_vn_link,\n\t.unlink\t\t\t= xfs_vn_unlink,\n\t.symlink\t\t= xfs_vn_symlink,\n\t.mkdir\t\t\t= xfs_vn_mkdir,\n\t/*\n\t * Yes, XFS uses the same method for rmdir and unlink.\n\t *\n\t * There are some subtile differences deeper in the code,\n\t * but we use S_ISDIR to check for those.\n\t */\n\t.rmdir\t\t\t= xfs_vn_unlink,\n\t.mknod\t\t\t= xfs_vn_mknod,\n\t.rename\t\t\t= xfs_vn_rename,\n\t.get_acl\t\t= xfs_get_acl,\n\t.set_acl\t\t= xfs_set_acl,\n\t.getattr\t\t= xfs_vn_getattr,\n\t.setattr\t\t= xfs_vn_setattr,\n\t.listxattr\t\t= xfs_vn_listxattr,\n\t.update_time\t\t= xfs_vn_update_time,\n\t.tmpfile\t\t= xfs_vn_tmpfile,\n};\n\nstatic const struct inode_operations xfs_dir_ci_inode_operations = {\n\t.create\t\t\t= xfs_vn_create,\n\t.lookup\t\t\t= xfs_vn_ci_lookup,\n\t.link\t\t\t= xfs_vn_link,\n\t.unlink\t\t\t= xfs_vn_unlink,\n\t.symlink\t\t= xfs_vn_symlink,\n\t.mkdir\t\t\t= xfs_vn_mkdir,\n\t/*\n\t * Yes, XFS uses the same method for rmdir and unlink.\n\t *\n\t * There are some subtile differences deeper in the code,\n\t * but we use S_ISDIR to check for those.\n\t */\n\t.rmdir\t\t\t= xfs_vn_unlink,\n\t.mknod\t\t\t= xfs_vn_mknod,\n\t.rename\t\t\t= xfs_vn_rename,\n\t.get_acl\t\t= xfs_get_acl,\n\t.set_acl\t\t= xfs_set_acl,\n\t.getattr\t\t= xfs_vn_getattr,\n\t.setattr\t\t= xfs_vn_setattr,\n\t.listxattr\t\t= xfs_vn_listxattr,\n\t.update_time\t\t= xfs_vn_update_time,\n\t.tmpfile\t\t= xfs_vn_tmpfile,\n};\n\nstatic const struct inode_operations xfs_symlink_inode_operations = {\n\t.get_link\t\t= xfs_vn_get_link,\n\t.getattr\t\t= xfs_vn_getattr,\n\t.setattr\t\t= xfs_vn_setattr,\n\t.listxattr\t\t= xfs_vn_listxattr,\n\t.update_time\t\t= xfs_vn_update_time,\n};\n\nstatic const struct inode_operations xfs_inline_symlink_inode_operations = {\n\t.get_link\t\t= xfs_vn_get_link_inline,\n\t.getattr\t\t= xfs_vn_getattr,\n\t.setattr\t\t= xfs_vn_setattr,\n\t.listxattr\t\t= xfs_vn_listxattr,\n\t.update_time\t\t= xfs_vn_update_time,\n};\n\n/* Figure out if this file actually supports DAX. */\nstatic bool\nxfs_inode_supports_dax(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\n\t/* Only supported on non-reflinked files. */\n\tif (!S_ISREG(VFS_I(ip)->i_mode) || xfs_is_reflink_inode(ip))\n\t\treturn false;\n\n\t/* DAX mount option or DAX iflag must be set. */\n\tif (!(mp->m_flags & XFS_MOUNT_DAX) &&\n\t    !(ip->i_d.di_flags2 & XFS_DIFLAG2_DAX))\n\t\treturn false;\n\n\t/* Block size must match page size */\n\tif (mp->m_sb.sb_blocksize != PAGE_SIZE)\n\t\treturn false;\n\n\t/* Device has to support DAX too. */\n\treturn xfs_find_daxdev_for_inode(VFS_I(ip)) != NULL;\n}\n\nSTATIC void\nxfs_diflags_to_iflags(\n\tstruct inode\t\t*inode,\n\tstruct xfs_inode\t*ip)\n{\n\tuint16_t\t\tflags = ip->i_d.di_flags;\n\n\tinode->i_flags &= ~(S_IMMUTABLE | S_APPEND | S_SYNC |\n\t\t\t    S_NOATIME | S_DAX);\n\n\tif (flags & XFS_DIFLAG_IMMUTABLE)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\tif (flags & XFS_DIFLAG_APPEND)\n\t\tinode->i_flags |= S_APPEND;\n\tif (flags & XFS_DIFLAG_SYNC)\n\t\tinode->i_flags |= S_SYNC;\n\tif (flags & XFS_DIFLAG_NOATIME)\n\t\tinode->i_flags |= S_NOATIME;\n\tif (xfs_inode_supports_dax(ip))\n\t\tinode->i_flags |= S_DAX;\n}\n\n/*\n * Initialize the Linux inode.\n *\n * When reading existing inodes from disk this is called directly from xfs_iget,\n * when creating a new inode it is called from xfs_ialloc after setting up the\n * inode. These callers have different criteria for clearing XFS_INEW, so leave\n * it up to the caller to deal with unlocking the inode appropriately.\n */\nvoid\nxfs_setup_inode(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct inode\t\t*inode = &ip->i_vnode;\n\tgfp_t\t\t\tgfp_mask;\n\n\tinode->i_ino = ip->i_ino;\n\tinode->i_state = I_NEW;\n\n\tinode_sb_list_add(inode);\n\t/* make the inode look hashed for the writeback code */\n\tinode_fake_hash(inode);\n\n\tinode->i_uid    = xfs_uid_to_kuid(ip->i_d.di_uid);\n\tinode->i_gid    = xfs_gid_to_kgid(ip->i_d.di_gid);\n\n\ti_size_write(inode, ip->i_d.di_size);\n\txfs_diflags_to_iflags(inode, ip);\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\t/*\n\t\t * We set the i_rwsem class here to avoid potential races with\n\t\t * lockdep_annotate_inode_mutex_key() reinitialising the lock\n\t\t * after a filehandle lookup has already found the inode in\n\t\t * cache before it has been unlocked via unlock_new_inode().\n\t\t */\n\t\tlockdep_set_class(&inode->i_rwsem,\n\t\t\t\t  &inode->i_sb->s_type->i_mutex_dir_key);\n\t\tlockdep_set_class(&ip->i_lock.mr_lock, &xfs_dir_ilock_class);\n\t\tip->d_ops = ip->i_mount->m_dir_inode_ops;\n\t} else {\n\t\tip->d_ops = ip->i_mount->m_nondir_inode_ops;\n\t\tlockdep_set_class(&ip->i_lock.mr_lock, &xfs_nondir_ilock_class);\n\t}\n\n\t/*\n\t * Ensure all page cache allocations are done from GFP_NOFS context to\n\t * prevent direct reclaim recursion back into the filesystem and blowing\n\t * stacks or deadlocking.\n\t */\n\tgfp_mask = mapping_gfp_mask(inode->i_mapping);\n\tmapping_set_gfp_mask(inode->i_mapping, (gfp_mask & ~(__GFP_FS)));\n\n\t/*\n\t * If there is no attribute fork no ACL can exist on this inode,\n\t * and it can't have any file capabilities attached to it either.\n\t */\n\tif (!XFS_IFORK_Q(ip)) {\n\t\tinode_has_no_xattr(inode);\n\t\tcache_no_acl(inode);\n\t}\n}\n\nvoid\nxfs_setup_iops(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct inode\t\t*inode = &ip->i_vnode;\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tinode->i_op = &xfs_inode_operations;\n\t\tinode->i_fop = &xfs_file_operations;\n\t\tif (IS_DAX(inode))\n\t\t\tinode->i_mapping->a_ops = &xfs_dax_aops;\n\t\telse\n\t\t\tinode->i_mapping->a_ops = &xfs_address_space_operations;\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tif (xfs_sb_version_hasasciici(&XFS_M(inode->i_sb)->m_sb))\n\t\t\tinode->i_op = &xfs_dir_ci_inode_operations;\n\t\telse\n\t\t\tinode->i_op = &xfs_dir_inode_operations;\n\t\tinode->i_fop = &xfs_dir_file_operations;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tif (ip->i_df.if_flags & XFS_IFINLINE)\n\t\t\tinode->i_op = &xfs_inline_symlink_inode_operations;\n\t\telse\n\t\t\tinode->i_op = &xfs_symlink_inode_operations;\n\t\tbreak;\n\tdefault:\n\t\tinode->i_op = &xfs_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\t}\n}\n"], "filenames": ["fs/xfs/xfs_iops.c"], "buggy_code_start_loc": [795], "buggy_code_end_loc": [795], "fixing_code_start_loc": [796], "fixing_code_end_loc": [797], "type": "CWE-400", "message": "An issue was discovered in xfs_setattr_nonsize in fs/xfs/xfs_iops.c in the Linux kernel through 5.2.9. XFS partially wedges when a chgrp fails on account of being out of disk quota. xfs_setattr_nonsize is failing to unlock the ILOCK after the xfs_qm_vop_chown_reserve call fails. This is primarily a local DoS attack vector, but it might result as well in remote DoS if the XFS filesystem is exported for instance via NFS.", "other": {"cve": {"id": "CVE-2019-15538", "sourceIdentifier": "cve@mitre.org", "published": "2019-08-25T16:15:11.033", "lastModified": "2021-06-02T15:22:13.143", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in xfs_setattr_nonsize in fs/xfs/xfs_iops.c in the Linux kernel through 5.2.9. XFS partially wedges when a chgrp fails on account of being out of disk quota. xfs_setattr_nonsize is failing to unlock the ILOCK after the xfs_qm_vop_chown_reserve call fails. This is primarily a local DoS attack vector, but it might result as well in remote DoS if the XFS filesystem is exported for instance via NFS."}, {"lang": "es", "value": "Se descubri\u00f3 un problema en xfs_setattr_nonsize en fs / xfs / xfs_iops.c en el kernel de Linux a trav\u00e9s de 5.2.9. XFS se bloquea parcialmente cuando falla un chgrp debido a que no se encuentra en la cuota de disco. xfs_setattr_nonsize no puede desbloquear el ILOCK despu\u00e9s de que la llamada xfs_qm_vop_chown_reserve falla. Este es principalmente un vector de ataque DoS local, pero tambi\u00e9n podr\u00eda resultar en DoS remoto si el sistema de archivos XFS se exporta, por ejemplo, a trav\u00e9s de NFS."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.8}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.7", "versionEndExcluding": "4.9.191", "matchCriteriaId": "00418608-9472-43CD-B79B-0092EE6013C4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.14", "versionEndExcluding": "4.14.141", "matchCriteriaId": "64B33B35-9C01-4462-AC1F-C30ED99CAEDE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.19", "versionEndExcluding": "4.19.69", "matchCriteriaId": "36723BB3-95E0-4390-95D5-9B7292AAB1BB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.2", "versionEndExcluding": "5.2.11", "matchCriteriaId": "69709BBB-06CE-4983-B7B9-872CE9B123DC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.3:-:*:*:*:*:*:*", "matchCriteriaId": "D036D76E-AC69-4382-B4C1-8EDA1ABB2941"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.3:rc1:*:*:*:*:*:*", "matchCriteriaId": "9E57A227-1EC1-4E47-AE4E-CCD42CAA4710"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.3:rc2:*:*:*:*:*:*", "matchCriteriaId": "89F70981-A72F-4796-9572-1DD96ED27A31"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.3:rc3:*:*:*:*:*:*", "matchCriteriaId": "D88C4C1B-9E6A-447B-B49B-C94AE24CB1C6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.3:rc4:*:*:*:*:*:*", "matchCriteriaId": "EBAE804E-3CC3-44C2-B1F5-2DC3EE4FF793"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.3:rc5:*:*:*:*:*:*", "matchCriteriaId": "8721379D-C6BC-43BF-8098-396F32182BEF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.3:rc6:*:*:*:*:*:*", "matchCriteriaId": "65AF2469-2B9F-4D4D-8886-2B8BA66D5FDC"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.04:*:*:*:*:*:*:*", "matchCriteriaId": "CD783B0C-9246-47D9-A937-6144FE8BFF0F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:data_availability_services:-:*:*:*:*:*:*:*", "matchCriteriaId": "0EF46487-B64A-454E-AECC-D74B83170ACD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:hci_management_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "A3C19813-E823-456A-B1CE-EC0684CE1953"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:solidfire:-:*:*:*:*:*:*:*", "matchCriteriaId": "A6E9EF0C-AFA8-4F7B-9FDC-1E0F7C26E737"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:aff_a700s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "952F55C9-7E7C-4539-9D08-E736B3488569"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:aff_a700s:-:*:*:*:*:*:*:*", "matchCriteriaId": "9FED1B0D-F901-413A-85D9-05D4C427570D"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h300s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "6770B6C3-732E-4E22-BF1C-2D2FD610061C"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h300s:-:*:*:*:*:*:*:*", "matchCriteriaId": "9F9C8C20-42EB-4AB5-BD97-212DEB070C43"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h500s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "7FFF7106-ED78-49BA-9EC5-B889E3685D53"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h500s:-:*:*:*:*:*:*:*", "matchCriteriaId": "E63D8B0F-006E-4801-BF9D-1C001BBFB4F9"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h700s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "56409CEC-5A1E-4450-AA42-641E459CC2AF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h700s:-:*:*:*:*:*:*:*", "matchCriteriaId": "B06F4839-D16A-4A61-9BB5-55B13F41E47F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h300e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "108A2215-50FB-4074-94CF-C130FA14566D"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h300e:-:*:*:*:*:*:*:*", "matchCriteriaId": "7AFC73CE-ABB9-42D3-9A71-3F5BC5381E0E"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h500e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "32F0B6C0-F930-480D-962B-3F4EFDCC13C7"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h500e:-:*:*:*:*:*:*:*", "matchCriteriaId": "803BC414-B250-4E3A-A478-A3881340D6B8"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h700e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "0FEB3337-BFDE-462A-908B-176F92053CEC"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h700e:-:*:*:*:*:*:*:*", "matchCriteriaId": "736AEAE9-782B-4F71-9893-DED53367E102"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "D0B4AD8A-F172-4558-AEC6-FF424BA2D912"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410s:-:*:*:*:*:*:*:*", "matchCriteriaId": "8497A4C9-8474-4A62-8331-3FE862ED4098"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410c_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "234DEFE0-5CE5-4B0A-96B8-5D227CB8ED31"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410c:-:*:*:*:*:*:*:*", "matchCriteriaId": "CDDF61B7-EC5C-467C-B710-B89F502CD04F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h610s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "FD7CFE0E-9D1E-4495-B302-89C3096FC0DF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h610s:-:*:*:*:*:*:*:*", "matchCriteriaId": "F63A3FA7-AAED-4A9D-9FDE-6195302DA0F6"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.0:*:*:*:*:*:*:*", "matchCriteriaId": "F1E78106-58E6-4D59-990F-75DA575BFAD9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:29:*:*:*:*:*:*:*", "matchCriteriaId": "D100F7CE-FC64-4CC6-852A-6136D72DA419"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:30:*:*:*:*:*:*:*", "matchCriteriaId": "97A4B8DF-58DA-4AB6-A1F9-331B36409BA3"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-09/msg00064.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-09/msg00066.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=1fb254aa983bf190cfd685d40c64a480a9bafaee", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/1fb254aa983bf190cfd685d40c64a480a9bafaee", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/09/msg00014.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/09/msg00015.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/O3RUDQJXRJQVGHCGR4YZWTQ3ECBI7TXH/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/T4JZ6AEUKFWBHQAROGMQARJ274PQP2QP/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lore.kernel.org/linux-xfs/20190823035528.GH1037422@magnolia/", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://lore.kernel.org/linux-xfs/20190823192433.GA8736@eldamar.local", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20191004-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://support.f5.com/csp/article/K32592426?utm_source=f5support&amp;utm_medium=RSS", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4144-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4147-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/1fb254aa983bf190cfd685d40c64a480a9bafaee"}}