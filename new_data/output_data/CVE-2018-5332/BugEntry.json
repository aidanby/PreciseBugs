{"buggy_code": ["/*\n * Copyright (c) 2007 Oracle.  All rights reserved.\n *\n * This software is available to you under a choice of one of two\n * licenses.  You may choose to be licensed under the terms of the GNU\n * General Public License (GPL) Version 2, available from the file\n * COPYING in the main directory of this source tree, or the\n * OpenIB.org BSD license below:\n *\n *     Redistribution and use in source and binary forms, with or\n *     without modification, are permitted provided that the following\n *     conditions are met:\n *\n *      - Redistributions of source code must retain the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer.\n *\n *      - Redistributions in binary form must reproduce the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer in the documentation and/or other materials\n *        provided with the distribution.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n */\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/dma-mapping.h> /* for DMA_*_DEVICE */\n\n#include \"rds.h\"\n\n/*\n * XXX\n *  - build with sparse\n *  - should we detect duplicate keys on a socket?  hmm.\n *  - an rdma is an mlock, apply rlimit?\n */\n\n/*\n * get the number of pages by looking at the page indices that the start and\n * end addresses fall in.\n *\n * Returns 0 if the vec is invalid.  It is invalid if the number of bytes\n * causes the address to wrap or overflows an unsigned int.  This comes\n * from being stored in the 'length' member of 'struct scatterlist'.\n */\nstatic unsigned int rds_pages_in_vec(struct rds_iovec *vec)\n{\n\tif ((vec->addr + vec->bytes <= vec->addr) ||\n\t    (vec->bytes > (u64)UINT_MAX))\n\t\treturn 0;\n\n\treturn ((vec->addr + vec->bytes + PAGE_SIZE - 1) >> PAGE_SHIFT) -\n\t\t(vec->addr >> PAGE_SHIFT);\n}\n\nstatic struct rds_mr *rds_mr_tree_walk(struct rb_root *root, u64 key,\n\t\t\t\t       struct rds_mr *insert)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct rds_mr *mr;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tmr = rb_entry(parent, struct rds_mr, r_rb_node);\n\n\t\tif (key < mr->r_key)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (key > mr->r_key)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn mr;\n\t}\n\n\tif (insert) {\n\t\trb_link_node(&insert->r_rb_node, parent, p);\n\t\trb_insert_color(&insert->r_rb_node, root);\n\t\trefcount_inc(&insert->r_refcount);\n\t}\n\treturn NULL;\n}\n\n/*\n * Destroy the transport-specific part of a MR.\n */\nstatic void rds_destroy_mr(struct rds_mr *mr)\n{\n\tstruct rds_sock *rs = mr->r_sock;\n\tvoid *trans_private = NULL;\n\tunsigned long flags;\n\n\trdsdebug(\"RDS: destroy mr key is %x refcnt %u\\n\",\n\t\t\tmr->r_key, refcount_read(&mr->r_refcount));\n\n\tif (test_and_set_bit(RDS_MR_DEAD, &mr->r_state))\n\t\treturn;\n\n\tspin_lock_irqsave(&rs->rs_rdma_lock, flags);\n\tif (!RB_EMPTY_NODE(&mr->r_rb_node))\n\t\trb_erase(&mr->r_rb_node, &rs->rs_rdma_keys);\n\ttrans_private = mr->r_trans_private;\n\tmr->r_trans_private = NULL;\n\tspin_unlock_irqrestore(&rs->rs_rdma_lock, flags);\n\n\tif (trans_private)\n\t\tmr->r_trans->free_mr(trans_private, mr->r_invalidate);\n}\n\nvoid __rds_put_mr_final(struct rds_mr *mr)\n{\n\trds_destroy_mr(mr);\n\tkfree(mr);\n}\n\n/*\n * By the time this is called we can't have any more ioctls called on\n * the socket so we don't need to worry about racing with others.\n */\nvoid rds_rdma_drop_keys(struct rds_sock *rs)\n{\n\tstruct rds_mr *mr;\n\tstruct rb_node *node;\n\tunsigned long flags;\n\n\t/* Release any MRs associated with this socket */\n\tspin_lock_irqsave(&rs->rs_rdma_lock, flags);\n\twhile ((node = rb_first(&rs->rs_rdma_keys))) {\n\t\tmr = rb_entry(node, struct rds_mr, r_rb_node);\n\t\tif (mr->r_trans == rs->rs_transport)\n\t\t\tmr->r_invalidate = 0;\n\t\trb_erase(&mr->r_rb_node, &rs->rs_rdma_keys);\n\t\tRB_CLEAR_NODE(&mr->r_rb_node);\n\t\tspin_unlock_irqrestore(&rs->rs_rdma_lock, flags);\n\t\trds_destroy_mr(mr);\n\t\trds_mr_put(mr);\n\t\tspin_lock_irqsave(&rs->rs_rdma_lock, flags);\n\t}\n\tspin_unlock_irqrestore(&rs->rs_rdma_lock, flags);\n\n\tif (rs->rs_transport && rs->rs_transport->flush_mrs)\n\t\trs->rs_transport->flush_mrs();\n}\n\n/*\n * Helper function to pin user pages.\n */\nstatic int rds_pin_pages(unsigned long user_addr, unsigned int nr_pages,\n\t\t\tstruct page **pages, int write)\n{\n\tint ret;\n\n\tret = get_user_pages_fast(user_addr, nr_pages, write, pages);\n\n\tif (ret >= 0 && ret < nr_pages) {\n\t\twhile (ret--)\n\t\t\tput_page(pages[ret]);\n\t\tret = -EFAULT;\n\t}\n\n\treturn ret;\n}\n\nstatic int __rds_rdma_map(struct rds_sock *rs, struct rds_get_mr_args *args,\n\t\t\t\tu64 *cookie_ret, struct rds_mr **mr_ret)\n{\n\tstruct rds_mr *mr = NULL, *found;\n\tunsigned int nr_pages;\n\tstruct page **pages = NULL;\n\tstruct scatterlist *sg;\n\tvoid *trans_private;\n\tunsigned long flags;\n\trds_rdma_cookie_t cookie;\n\tunsigned int nents;\n\tlong i;\n\tint ret;\n\n\tif (rs->rs_bound_addr == 0 || !rs->rs_transport) {\n\t\tret = -ENOTCONN; /* XXX not a great errno */\n\t\tgoto out;\n\t}\n\n\tif (!rs->rs_transport->get_mr) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tnr_pages = rds_pages_in_vec(&args->vec);\n\tif (nr_pages == 0) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Restrict the size of mr irrespective of underlying transport\n\t * To account for unaligned mr regions, subtract one from nr_pages\n\t */\n\tif ((nr_pages - 1) > (RDS_MAX_MSG_SIZE >> PAGE_SHIFT)) {\n\t\tret = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\trdsdebug(\"RDS: get_mr addr %llx len %llu nr_pages %u\\n\",\n\t\targs->vec.addr, args->vec.bytes, nr_pages);\n\n\t/* XXX clamp nr_pages to limit the size of this alloc? */\n\tpages = kcalloc(nr_pages, sizeof(struct page *), GFP_KERNEL);\n\tif (!pages) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmr = kzalloc(sizeof(struct rds_mr), GFP_KERNEL);\n\tif (!mr) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trefcount_set(&mr->r_refcount, 1);\n\tRB_CLEAR_NODE(&mr->r_rb_node);\n\tmr->r_trans = rs->rs_transport;\n\tmr->r_sock = rs;\n\n\tif (args->flags & RDS_RDMA_USE_ONCE)\n\t\tmr->r_use_once = 1;\n\tif (args->flags & RDS_RDMA_INVALIDATE)\n\t\tmr->r_invalidate = 1;\n\tif (args->flags & RDS_RDMA_READWRITE)\n\t\tmr->r_write = 1;\n\n\t/*\n\t * Pin the pages that make up the user buffer and transfer the page\n\t * pointers to the mr's sg array.  We check to see if we've mapped\n\t * the whole region after transferring the partial page references\n\t * to the sg array so that we can have one page ref cleanup path.\n\t *\n\t * For now we have no flag that tells us whether the mapping is\n\t * r/o or r/w. We need to assume r/w, or we'll do a lot of RDMA to\n\t * the zero page.\n\t */\n\tret = rds_pin_pages(args->vec.addr, nr_pages, pages, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tnents = ret;\n\tsg = kcalloc(nents, sizeof(*sg), GFP_KERNEL);\n\tif (!sg) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tWARN_ON(!nents);\n\tsg_init_table(sg, nents);\n\n\t/* Stick all pages into the scatterlist */\n\tfor (i = 0 ; i < nents; i++)\n\t\tsg_set_page(&sg[i], pages[i], PAGE_SIZE, 0);\n\n\trdsdebug(\"RDS: trans_private nents is %u\\n\", nents);\n\n\t/* Obtain a transport specific MR. If this succeeds, the\n\t * s/g list is now owned by the MR.\n\t * Note that dma_map() implies that pending writes are\n\t * flushed to RAM, so no dma_sync is needed here. */\n\ttrans_private = rs->rs_transport->get_mr(sg, nents, rs,\n\t\t\t\t\t\t &mr->r_key);\n\n\tif (IS_ERR(trans_private)) {\n\t\tfor (i = 0 ; i < nents; i++)\n\t\t\tput_page(sg_page(&sg[i]));\n\t\tkfree(sg);\n\t\tret = PTR_ERR(trans_private);\n\t\tgoto out;\n\t}\n\n\tmr->r_trans_private = trans_private;\n\n\trdsdebug(\"RDS: get_mr put_user key is %x cookie_addr %p\\n\",\n\t       mr->r_key, (void *)(unsigned long) args->cookie_addr);\n\n\t/* The user may pass us an unaligned address, but we can only\n\t * map page aligned regions. So we keep the offset, and build\n\t * a 64bit cookie containing <R_Key, offset> and pass that\n\t * around. */\n\tcookie = rds_rdma_make_cookie(mr->r_key, args->vec.addr & ~PAGE_MASK);\n\tif (cookie_ret)\n\t\t*cookie_ret = cookie;\n\n\tif (args->cookie_addr && put_user(cookie, (u64 __user *)(unsigned long) args->cookie_addr)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t/* Inserting the new MR into the rbtree bumps its\n\t * reference count. */\n\tspin_lock_irqsave(&rs->rs_rdma_lock, flags);\n\tfound = rds_mr_tree_walk(&rs->rs_rdma_keys, mr->r_key, mr);\n\tspin_unlock_irqrestore(&rs->rs_rdma_lock, flags);\n\n\tBUG_ON(found && found != mr);\n\n\trdsdebug(\"RDS: get_mr key is %x\\n\", mr->r_key);\n\tif (mr_ret) {\n\t\trefcount_inc(&mr->r_refcount);\n\t\t*mr_ret = mr;\n\t}\n\n\tret = 0;\nout:\n\tkfree(pages);\n\tif (mr)\n\t\trds_mr_put(mr);\n\treturn ret;\n}\n\nint rds_get_mr(struct rds_sock *rs, char __user *optval, int optlen)\n{\n\tstruct rds_get_mr_args args;\n\n\tif (optlen != sizeof(struct rds_get_mr_args))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&args, (struct rds_get_mr_args __user *)optval,\n\t\t\t   sizeof(struct rds_get_mr_args)))\n\t\treturn -EFAULT;\n\n\treturn __rds_rdma_map(rs, &args, NULL, NULL);\n}\n\nint rds_get_mr_for_dest(struct rds_sock *rs, char __user *optval, int optlen)\n{\n\tstruct rds_get_mr_for_dest_args args;\n\tstruct rds_get_mr_args new_args;\n\n\tif (optlen != sizeof(struct rds_get_mr_for_dest_args))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&args, (struct rds_get_mr_for_dest_args __user *)optval,\n\t\t\t   sizeof(struct rds_get_mr_for_dest_args)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * Initially, just behave like get_mr().\n\t * TODO: Implement get_mr as wrapper around this\n\t *\t and deprecate it.\n\t */\n\tnew_args.vec = args.vec;\n\tnew_args.cookie_addr = args.cookie_addr;\n\tnew_args.flags = args.flags;\n\n\treturn __rds_rdma_map(rs, &new_args, NULL, NULL);\n}\n\n/*\n * Free the MR indicated by the given R_Key\n */\nint rds_free_mr(struct rds_sock *rs, char __user *optval, int optlen)\n{\n\tstruct rds_free_mr_args args;\n\tstruct rds_mr *mr;\n\tunsigned long flags;\n\n\tif (optlen != sizeof(struct rds_free_mr_args))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&args, (struct rds_free_mr_args __user *)optval,\n\t\t\t   sizeof(struct rds_free_mr_args)))\n\t\treturn -EFAULT;\n\n\t/* Special case - a null cookie means flush all unused MRs */\n\tif (args.cookie == 0) {\n\t\tif (!rs->rs_transport || !rs->rs_transport->flush_mrs)\n\t\t\treturn -EINVAL;\n\t\trs->rs_transport->flush_mrs();\n\t\treturn 0;\n\t}\n\n\t/* Look up the MR given its R_key and remove it from the rbtree\n\t * so nobody else finds it.\n\t * This should also prevent races with rds_rdma_unuse.\n\t */\n\tspin_lock_irqsave(&rs->rs_rdma_lock, flags);\n\tmr = rds_mr_tree_walk(&rs->rs_rdma_keys, rds_rdma_cookie_key(args.cookie), NULL);\n\tif (mr) {\n\t\trb_erase(&mr->r_rb_node, &rs->rs_rdma_keys);\n\t\tRB_CLEAR_NODE(&mr->r_rb_node);\n\t\tif (args.flags & RDS_RDMA_INVALIDATE)\n\t\t\tmr->r_invalidate = 1;\n\t}\n\tspin_unlock_irqrestore(&rs->rs_rdma_lock, flags);\n\n\tif (!mr)\n\t\treturn -EINVAL;\n\n\t/*\n\t * call rds_destroy_mr() ourselves so that we're sure it's done by the time\n\t * we return.  If we let rds_mr_put() do it it might not happen until\n\t * someone else drops their ref.\n\t */\n\trds_destroy_mr(mr);\n\trds_mr_put(mr);\n\treturn 0;\n}\n\n/*\n * This is called when we receive an extension header that\n * tells us this MR was used. It allows us to implement\n * use_once semantics\n */\nvoid rds_rdma_unuse(struct rds_sock *rs, u32 r_key, int force)\n{\n\tstruct rds_mr *mr;\n\tunsigned long flags;\n\tint zot_me = 0;\n\n\tspin_lock_irqsave(&rs->rs_rdma_lock, flags);\n\tmr = rds_mr_tree_walk(&rs->rs_rdma_keys, r_key, NULL);\n\tif (!mr) {\n\t\tpr_debug(\"rds: trying to unuse MR with unknown r_key %u!\\n\",\n\t\t\t r_key);\n\t\tspin_unlock_irqrestore(&rs->rs_rdma_lock, flags);\n\t\treturn;\n\t}\n\n\tif (mr->r_use_once || force) {\n\t\trb_erase(&mr->r_rb_node, &rs->rs_rdma_keys);\n\t\tRB_CLEAR_NODE(&mr->r_rb_node);\n\t\tzot_me = 1;\n\t}\n\tspin_unlock_irqrestore(&rs->rs_rdma_lock, flags);\n\n\t/* May have to issue a dma_sync on this memory region.\n\t * Note we could avoid this if the operation was a RDMA READ,\n\t * but at this point we can't tell. */\n\tif (mr->r_trans->sync_mr)\n\t\tmr->r_trans->sync_mr(mr->r_trans_private, DMA_FROM_DEVICE);\n\n\t/* If the MR was marked as invalidate, this will\n\t * trigger an async flush. */\n\tif (zot_me) {\n\t\trds_destroy_mr(mr);\n\t\trds_mr_put(mr);\n\t}\n}\n\nvoid rds_rdma_free_op(struct rm_rdma_op *ro)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ro->op_nents; i++) {\n\t\tstruct page *page = sg_page(&ro->op_sg[i]);\n\n\t\t/* Mark page dirty if it was possibly modified, which\n\t\t * is the case for a RDMA_READ which copies from remote\n\t\t * to local memory */\n\t\tif (!ro->op_write) {\n\t\t\tWARN_ON(!page->mapping && irqs_disabled());\n\t\t\tset_page_dirty(page);\n\t\t}\n\t\tput_page(page);\n\t}\n\n\tkfree(ro->op_notifier);\n\tro->op_notifier = NULL;\n\tro->op_active = 0;\n}\n\nvoid rds_atomic_free_op(struct rm_atomic_op *ao)\n{\n\tstruct page *page = sg_page(ao->op_sg);\n\n\t/* Mark page dirty if it was possibly modified, which\n\t * is the case for a RDMA_READ which copies from remote\n\t * to local memory */\n\tset_page_dirty(page);\n\tput_page(page);\n\n\tkfree(ao->op_notifier);\n\tao->op_notifier = NULL;\n\tao->op_active = 0;\n}\n\n\n/*\n * Count the number of pages needed to describe an incoming iovec array.\n */\nstatic int rds_rdma_pages(struct rds_iovec iov[], int nr_iovecs)\n{\n\tint tot_pages = 0;\n\tunsigned int nr_pages;\n\tunsigned int i;\n\n\t/* figure out the number of pages in the vector */\n\tfor (i = 0; i < nr_iovecs; i++) {\n\t\tnr_pages = rds_pages_in_vec(&iov[i]);\n\t\tif (nr_pages == 0)\n\t\t\treturn -EINVAL;\n\n\t\ttot_pages += nr_pages;\n\n\t\t/*\n\t\t * nr_pages for one entry is limited to (UINT_MAX>>PAGE_SHIFT)+1,\n\t\t * so tot_pages cannot overflow without first going negative.\n\t\t */\n\t\tif (tot_pages < 0)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn tot_pages;\n}\n\nint rds_rdma_extra_size(struct rds_rdma_args *args)\n{\n\tstruct rds_iovec vec;\n\tstruct rds_iovec __user *local_vec;\n\tint tot_pages = 0;\n\tunsigned int nr_pages;\n\tunsigned int i;\n\n\tlocal_vec = (struct rds_iovec __user *)(unsigned long) args->local_vec_addr;\n\n\t/* figure out the number of pages in the vector */\n\tfor (i = 0; i < args->nr_local; i++) {\n\t\tif (copy_from_user(&vec, &local_vec[i],\n\t\t\t\t   sizeof(struct rds_iovec)))\n\t\t\treturn -EFAULT;\n\n\t\tnr_pages = rds_pages_in_vec(&vec);\n\t\tif (nr_pages == 0)\n\t\t\treturn -EINVAL;\n\n\t\ttot_pages += nr_pages;\n\n\t\t/*\n\t\t * nr_pages for one entry is limited to (UINT_MAX>>PAGE_SHIFT)+1,\n\t\t * so tot_pages cannot overflow without first going negative.\n\t\t */\n\t\tif (tot_pages < 0)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn tot_pages * sizeof(struct scatterlist);\n}\n\n/*\n * The application asks for a RDMA transfer.\n * Extract all arguments and set up the rdma_op\n */\nint rds_cmsg_rdma_args(struct rds_sock *rs, struct rds_message *rm,\n\t\t\t  struct cmsghdr *cmsg)\n{\n\tstruct rds_rdma_args *args;\n\tstruct rm_rdma_op *op = &rm->rdma;\n\tint nr_pages;\n\tunsigned int nr_bytes;\n\tstruct page **pages = NULL;\n\tstruct rds_iovec iovstack[UIO_FASTIOV], *iovs = iovstack;\n\tint iov_size;\n\tunsigned int i, j;\n\tint ret = 0;\n\n\tif (cmsg->cmsg_len < CMSG_LEN(sizeof(struct rds_rdma_args))\n\t    || rm->rdma.op_active)\n\t\treturn -EINVAL;\n\n\targs = CMSG_DATA(cmsg);\n\n\tif (rs->rs_bound_addr == 0) {\n\t\tret = -ENOTCONN; /* XXX not a great errno */\n\t\tgoto out_ret;\n\t}\n\n\tif (args->nr_local > UIO_MAXIOV) {\n\t\tret = -EMSGSIZE;\n\t\tgoto out_ret;\n\t}\n\n\t/* Check whether to allocate the iovec area */\n\tiov_size = args->nr_local * sizeof(struct rds_iovec);\n\tif (args->nr_local > UIO_FASTIOV) {\n\t\tiovs = sock_kmalloc(rds_rs_to_sk(rs), iov_size, GFP_KERNEL);\n\t\tif (!iovs) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_ret;\n\t\t}\n\t}\n\n\tif (copy_from_user(iovs, (struct rds_iovec __user *)(unsigned long) args->local_vec_addr, iov_size)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tnr_pages = rds_rdma_pages(iovs, args->nr_local);\n\tif (nr_pages < 0) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tpages = kcalloc(nr_pages, sizeof(struct page *), GFP_KERNEL);\n\tif (!pages) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\top->op_write = !!(args->flags & RDS_RDMA_READWRITE);\n\top->op_fence = !!(args->flags & RDS_RDMA_FENCE);\n\top->op_notify = !!(args->flags & RDS_RDMA_NOTIFY_ME);\n\top->op_silent = !!(args->flags & RDS_RDMA_SILENT);\n\top->op_active = 1;\n\top->op_recverr = rs->rs_recverr;\n\tWARN_ON(!nr_pages);\n\top->op_sg = rds_message_alloc_sgs(rm, nr_pages);\n\tif (!op->op_sg) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (op->op_notify || op->op_recverr) {\n\t\t/* We allocate an uninitialized notifier here, because\n\t\t * we don't want to do that in the completion handler. We\n\t\t * would have to use GFP_ATOMIC there, and don't want to deal\n\t\t * with failed allocations.\n\t\t */\n\t\top->op_notifier = kmalloc(sizeof(struct rds_notifier), GFP_KERNEL);\n\t\tif (!op->op_notifier) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\top->op_notifier->n_user_token = args->user_token;\n\t\top->op_notifier->n_status = RDS_RDMA_SUCCESS;\n\n\t\t/* Enable rmda notification on data operation for composite\n\t\t * rds messages and make sure notification is enabled only\n\t\t * for the data operation which follows it so that application\n\t\t * gets notified only after full message gets delivered.\n\t\t */\n\t\tif (rm->data.op_sg) {\n\t\t\trm->rdma.op_notify = 0;\n\t\t\trm->data.op_notify = !!(args->flags & RDS_RDMA_NOTIFY_ME);\n\t\t}\n\t}\n\n\t/* The cookie contains the R_Key of the remote memory region, and\n\t * optionally an offset into it. This is how we implement RDMA into\n\t * unaligned memory.\n\t * When setting up the RDMA, we need to add that offset to the\n\t * destination address (which is really an offset into the MR)\n\t * FIXME: We may want to move this into ib_rdma.c\n\t */\n\top->op_rkey = rds_rdma_cookie_key(args->cookie);\n\top->op_remote_addr = args->remote_vec.addr + rds_rdma_cookie_offset(args->cookie);\n\n\tnr_bytes = 0;\n\n\trdsdebug(\"RDS: rdma prepare nr_local %llu rva %llx rkey %x\\n\",\n\t       (unsigned long long)args->nr_local,\n\t       (unsigned long long)args->remote_vec.addr,\n\t       op->op_rkey);\n\n\tfor (i = 0; i < args->nr_local; i++) {\n\t\tstruct rds_iovec *iov = &iovs[i];\n\t\t/* don't need to check, rds_rdma_pages() verified nr will be +nonzero */\n\t\tunsigned int nr = rds_pages_in_vec(iov);\n\n\t\trs->rs_user_addr = iov->addr;\n\t\trs->rs_user_bytes = iov->bytes;\n\n\t\t/* If it's a WRITE operation, we want to pin the pages for reading.\n\t\t * If it's a READ operation, we need to pin the pages for writing.\n\t\t */\n\t\tret = rds_pin_pages(iov->addr, nr, pages, !op->op_write);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\telse\n\t\t\tret = 0;\n\n\t\trdsdebug(\"RDS: nr_bytes %u nr %u iov->bytes %llu iov->addr %llx\\n\",\n\t\t\t nr_bytes, nr, iov->bytes, iov->addr);\n\n\t\tnr_bytes += iov->bytes;\n\n\t\tfor (j = 0; j < nr; j++) {\n\t\t\tunsigned int offset = iov->addr & ~PAGE_MASK;\n\t\t\tstruct scatterlist *sg;\n\n\t\t\tsg = &op->op_sg[op->op_nents + j];\n\t\t\tsg_set_page(sg, pages[j],\n\t\t\t\t\tmin_t(unsigned int, iov->bytes, PAGE_SIZE - offset),\n\t\t\t\t\toffset);\n\n\t\t\trdsdebug(\"RDS: sg->offset %x sg->len %x iov->addr %llx iov->bytes %llu\\n\",\n\t\t\t       sg->offset, sg->length, iov->addr, iov->bytes);\n\n\t\t\tiov->addr += sg->length;\n\t\t\tiov->bytes -= sg->length;\n\t\t}\n\n\t\top->op_nents += nr;\n\t}\n\n\tif (nr_bytes > args->remote_vec.bytes) {\n\t\trdsdebug(\"RDS nr_bytes %u remote_bytes %u do not match\\n\",\n\t\t\t\tnr_bytes,\n\t\t\t\t(unsigned int) args->remote_vec.bytes);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\top->op_bytes = nr_bytes;\n\nout:\n\tif (iovs != iovstack)\n\t\tsock_kfree_s(rds_rs_to_sk(rs), iovs, iov_size);\n\tkfree(pages);\nout_ret:\n\tif (ret)\n\t\trds_rdma_free_op(op);\n\telse\n\t\trds_stats_inc(s_send_rdma);\n\n\treturn ret;\n}\n\n/*\n * The application wants us to pass an RDMA destination (aka MR)\n * to the remote\n */\nint rds_cmsg_rdma_dest(struct rds_sock *rs, struct rds_message *rm,\n\t\t\t  struct cmsghdr *cmsg)\n{\n\tunsigned long flags;\n\tstruct rds_mr *mr;\n\tu32 r_key;\n\tint err = 0;\n\n\tif (cmsg->cmsg_len < CMSG_LEN(sizeof(rds_rdma_cookie_t)) ||\n\t    rm->m_rdma_cookie != 0)\n\t\treturn -EINVAL;\n\n\tmemcpy(&rm->m_rdma_cookie, CMSG_DATA(cmsg), sizeof(rm->m_rdma_cookie));\n\n\t/* We are reusing a previously mapped MR here. Most likely, the\n\t * application has written to the buffer, so we need to explicitly\n\t * flush those writes to RAM. Otherwise the HCA may not see them\n\t * when doing a DMA from that buffer.\n\t */\n\tr_key = rds_rdma_cookie_key(rm->m_rdma_cookie);\n\n\tspin_lock_irqsave(&rs->rs_rdma_lock, flags);\n\tmr = rds_mr_tree_walk(&rs->rs_rdma_keys, r_key, NULL);\n\tif (!mr)\n\t\terr = -EINVAL;\t/* invalid r_key */\n\telse\n\t\trefcount_inc(&mr->r_refcount);\n\tspin_unlock_irqrestore(&rs->rs_rdma_lock, flags);\n\n\tif (mr) {\n\t\tmr->r_trans->sync_mr(mr->r_trans_private, DMA_TO_DEVICE);\n\t\trm->rdma.op_rdma_mr = mr;\n\t}\n\treturn err;\n}\n\n/*\n * The application passes us an address range it wants to enable RDMA\n * to/from. We map the area, and save the <R_Key,offset> pair\n * in rm->m_rdma_cookie. This causes it to be sent along to the peer\n * in an extension header.\n */\nint rds_cmsg_rdma_map(struct rds_sock *rs, struct rds_message *rm,\n\t\t\t  struct cmsghdr *cmsg)\n{\n\tif (cmsg->cmsg_len < CMSG_LEN(sizeof(struct rds_get_mr_args)) ||\n\t    rm->m_rdma_cookie != 0)\n\t\treturn -EINVAL;\n\n\treturn __rds_rdma_map(rs, CMSG_DATA(cmsg), &rm->m_rdma_cookie, &rm->rdma.op_rdma_mr);\n}\n\n/*\n * Fill in rds_message for an atomic request.\n */\nint rds_cmsg_atomic(struct rds_sock *rs, struct rds_message *rm,\n\t\t    struct cmsghdr *cmsg)\n{\n\tstruct page *page = NULL;\n\tstruct rds_atomic_args *args;\n\tint ret = 0;\n\n\tif (cmsg->cmsg_len < CMSG_LEN(sizeof(struct rds_atomic_args))\n\t || rm->atomic.op_active)\n\t\treturn -EINVAL;\n\n\targs = CMSG_DATA(cmsg);\n\n\t/* Nonmasked & masked cmsg ops converted to masked hw ops */\n\tswitch (cmsg->cmsg_type) {\n\tcase RDS_CMSG_ATOMIC_FADD:\n\t\trm->atomic.op_type = RDS_ATOMIC_TYPE_FADD;\n\t\trm->atomic.op_m_fadd.add = args->fadd.add;\n\t\trm->atomic.op_m_fadd.nocarry_mask = 0;\n\t\tbreak;\n\tcase RDS_CMSG_MASKED_ATOMIC_FADD:\n\t\trm->atomic.op_type = RDS_ATOMIC_TYPE_FADD;\n\t\trm->atomic.op_m_fadd.add = args->m_fadd.add;\n\t\trm->atomic.op_m_fadd.nocarry_mask = args->m_fadd.nocarry_mask;\n\t\tbreak;\n\tcase RDS_CMSG_ATOMIC_CSWP:\n\t\trm->atomic.op_type = RDS_ATOMIC_TYPE_CSWP;\n\t\trm->atomic.op_m_cswp.compare = args->cswp.compare;\n\t\trm->atomic.op_m_cswp.swap = args->cswp.swap;\n\t\trm->atomic.op_m_cswp.compare_mask = ~0;\n\t\trm->atomic.op_m_cswp.swap_mask = ~0;\n\t\tbreak;\n\tcase RDS_CMSG_MASKED_ATOMIC_CSWP:\n\t\trm->atomic.op_type = RDS_ATOMIC_TYPE_CSWP;\n\t\trm->atomic.op_m_cswp.compare = args->m_cswp.compare;\n\t\trm->atomic.op_m_cswp.swap = args->m_cswp.swap;\n\t\trm->atomic.op_m_cswp.compare_mask = args->m_cswp.compare_mask;\n\t\trm->atomic.op_m_cswp.swap_mask = args->m_cswp.swap_mask;\n\t\tbreak;\n\tdefault:\n\t\tBUG(); /* should never happen */\n\t}\n\n\trm->atomic.op_notify = !!(args->flags & RDS_RDMA_NOTIFY_ME);\n\trm->atomic.op_silent = !!(args->flags & RDS_RDMA_SILENT);\n\trm->atomic.op_active = 1;\n\trm->atomic.op_recverr = rs->rs_recverr;\n\trm->atomic.op_sg = rds_message_alloc_sgs(rm, 1);\n\tif (!rm->atomic.op_sg) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t/* verify 8 byte-aligned */\n\tif (args->local_addr & 0x7) {\n\t\tret = -EFAULT;\n\t\tgoto err;\n\t}\n\n\tret = rds_pin_pages(args->local_addr, 1, &page, 1);\n\tif (ret != 1)\n\t\tgoto err;\n\tret = 0;\n\n\tsg_set_page(rm->atomic.op_sg, page, 8, offset_in_page(args->local_addr));\n\n\tif (rm->atomic.op_notify || rm->atomic.op_recverr) {\n\t\t/* We allocate an uninitialized notifier here, because\n\t\t * we don't want to do that in the completion handler. We\n\t\t * would have to use GFP_ATOMIC there, and don't want to deal\n\t\t * with failed allocations.\n\t\t */\n\t\trm->atomic.op_notifier = kmalloc(sizeof(*rm->atomic.op_notifier), GFP_KERNEL);\n\t\tif (!rm->atomic.op_notifier) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\trm->atomic.op_notifier->n_user_token = args->user_token;\n\t\trm->atomic.op_notifier->n_status = RDS_RDMA_SUCCESS;\n\t}\n\n\trm->atomic.op_rkey = rds_rdma_cookie_key(args->cookie);\n\trm->atomic.op_remote_addr = args->remote_addr + rds_rdma_cookie_offset(args->cookie);\n\n\treturn ret;\nerr:\n\tif (page)\n\t\tput_page(page);\n\tkfree(rm->atomic.op_notifier);\n\n\treturn ret;\n}\n"], "fixing_code": ["/*\n * Copyright (c) 2007 Oracle.  All rights reserved.\n *\n * This software is available to you under a choice of one of two\n * licenses.  You may choose to be licensed under the terms of the GNU\n * General Public License (GPL) Version 2, available from the file\n * COPYING in the main directory of this source tree, or the\n * OpenIB.org BSD license below:\n *\n *     Redistribution and use in source and binary forms, with or\n *     without modification, are permitted provided that the following\n *     conditions are met:\n *\n *      - Redistributions of source code must retain the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer.\n *\n *      - Redistributions in binary form must reproduce the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer in the documentation and/or other materials\n *        provided with the distribution.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n */\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/dma-mapping.h> /* for DMA_*_DEVICE */\n\n#include \"rds.h\"\n\n/*\n * XXX\n *  - build with sparse\n *  - should we detect duplicate keys on a socket?  hmm.\n *  - an rdma is an mlock, apply rlimit?\n */\n\n/*\n * get the number of pages by looking at the page indices that the start and\n * end addresses fall in.\n *\n * Returns 0 if the vec is invalid.  It is invalid if the number of bytes\n * causes the address to wrap or overflows an unsigned int.  This comes\n * from being stored in the 'length' member of 'struct scatterlist'.\n */\nstatic unsigned int rds_pages_in_vec(struct rds_iovec *vec)\n{\n\tif ((vec->addr + vec->bytes <= vec->addr) ||\n\t    (vec->bytes > (u64)UINT_MAX))\n\t\treturn 0;\n\n\treturn ((vec->addr + vec->bytes + PAGE_SIZE - 1) >> PAGE_SHIFT) -\n\t\t(vec->addr >> PAGE_SHIFT);\n}\n\nstatic struct rds_mr *rds_mr_tree_walk(struct rb_root *root, u64 key,\n\t\t\t\t       struct rds_mr *insert)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct rds_mr *mr;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tmr = rb_entry(parent, struct rds_mr, r_rb_node);\n\n\t\tif (key < mr->r_key)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (key > mr->r_key)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn mr;\n\t}\n\n\tif (insert) {\n\t\trb_link_node(&insert->r_rb_node, parent, p);\n\t\trb_insert_color(&insert->r_rb_node, root);\n\t\trefcount_inc(&insert->r_refcount);\n\t}\n\treturn NULL;\n}\n\n/*\n * Destroy the transport-specific part of a MR.\n */\nstatic void rds_destroy_mr(struct rds_mr *mr)\n{\n\tstruct rds_sock *rs = mr->r_sock;\n\tvoid *trans_private = NULL;\n\tunsigned long flags;\n\n\trdsdebug(\"RDS: destroy mr key is %x refcnt %u\\n\",\n\t\t\tmr->r_key, refcount_read(&mr->r_refcount));\n\n\tif (test_and_set_bit(RDS_MR_DEAD, &mr->r_state))\n\t\treturn;\n\n\tspin_lock_irqsave(&rs->rs_rdma_lock, flags);\n\tif (!RB_EMPTY_NODE(&mr->r_rb_node))\n\t\trb_erase(&mr->r_rb_node, &rs->rs_rdma_keys);\n\ttrans_private = mr->r_trans_private;\n\tmr->r_trans_private = NULL;\n\tspin_unlock_irqrestore(&rs->rs_rdma_lock, flags);\n\n\tif (trans_private)\n\t\tmr->r_trans->free_mr(trans_private, mr->r_invalidate);\n}\n\nvoid __rds_put_mr_final(struct rds_mr *mr)\n{\n\trds_destroy_mr(mr);\n\tkfree(mr);\n}\n\n/*\n * By the time this is called we can't have any more ioctls called on\n * the socket so we don't need to worry about racing with others.\n */\nvoid rds_rdma_drop_keys(struct rds_sock *rs)\n{\n\tstruct rds_mr *mr;\n\tstruct rb_node *node;\n\tunsigned long flags;\n\n\t/* Release any MRs associated with this socket */\n\tspin_lock_irqsave(&rs->rs_rdma_lock, flags);\n\twhile ((node = rb_first(&rs->rs_rdma_keys))) {\n\t\tmr = rb_entry(node, struct rds_mr, r_rb_node);\n\t\tif (mr->r_trans == rs->rs_transport)\n\t\t\tmr->r_invalidate = 0;\n\t\trb_erase(&mr->r_rb_node, &rs->rs_rdma_keys);\n\t\tRB_CLEAR_NODE(&mr->r_rb_node);\n\t\tspin_unlock_irqrestore(&rs->rs_rdma_lock, flags);\n\t\trds_destroy_mr(mr);\n\t\trds_mr_put(mr);\n\t\tspin_lock_irqsave(&rs->rs_rdma_lock, flags);\n\t}\n\tspin_unlock_irqrestore(&rs->rs_rdma_lock, flags);\n\n\tif (rs->rs_transport && rs->rs_transport->flush_mrs)\n\t\trs->rs_transport->flush_mrs();\n}\n\n/*\n * Helper function to pin user pages.\n */\nstatic int rds_pin_pages(unsigned long user_addr, unsigned int nr_pages,\n\t\t\tstruct page **pages, int write)\n{\n\tint ret;\n\n\tret = get_user_pages_fast(user_addr, nr_pages, write, pages);\n\n\tif (ret >= 0 && ret < nr_pages) {\n\t\twhile (ret--)\n\t\t\tput_page(pages[ret]);\n\t\tret = -EFAULT;\n\t}\n\n\treturn ret;\n}\n\nstatic int __rds_rdma_map(struct rds_sock *rs, struct rds_get_mr_args *args,\n\t\t\t\tu64 *cookie_ret, struct rds_mr **mr_ret)\n{\n\tstruct rds_mr *mr = NULL, *found;\n\tunsigned int nr_pages;\n\tstruct page **pages = NULL;\n\tstruct scatterlist *sg;\n\tvoid *trans_private;\n\tunsigned long flags;\n\trds_rdma_cookie_t cookie;\n\tunsigned int nents;\n\tlong i;\n\tint ret;\n\n\tif (rs->rs_bound_addr == 0 || !rs->rs_transport) {\n\t\tret = -ENOTCONN; /* XXX not a great errno */\n\t\tgoto out;\n\t}\n\n\tif (!rs->rs_transport->get_mr) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tnr_pages = rds_pages_in_vec(&args->vec);\n\tif (nr_pages == 0) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Restrict the size of mr irrespective of underlying transport\n\t * To account for unaligned mr regions, subtract one from nr_pages\n\t */\n\tif ((nr_pages - 1) > (RDS_MAX_MSG_SIZE >> PAGE_SHIFT)) {\n\t\tret = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\trdsdebug(\"RDS: get_mr addr %llx len %llu nr_pages %u\\n\",\n\t\targs->vec.addr, args->vec.bytes, nr_pages);\n\n\t/* XXX clamp nr_pages to limit the size of this alloc? */\n\tpages = kcalloc(nr_pages, sizeof(struct page *), GFP_KERNEL);\n\tif (!pages) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmr = kzalloc(sizeof(struct rds_mr), GFP_KERNEL);\n\tif (!mr) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trefcount_set(&mr->r_refcount, 1);\n\tRB_CLEAR_NODE(&mr->r_rb_node);\n\tmr->r_trans = rs->rs_transport;\n\tmr->r_sock = rs;\n\n\tif (args->flags & RDS_RDMA_USE_ONCE)\n\t\tmr->r_use_once = 1;\n\tif (args->flags & RDS_RDMA_INVALIDATE)\n\t\tmr->r_invalidate = 1;\n\tif (args->flags & RDS_RDMA_READWRITE)\n\t\tmr->r_write = 1;\n\n\t/*\n\t * Pin the pages that make up the user buffer and transfer the page\n\t * pointers to the mr's sg array.  We check to see if we've mapped\n\t * the whole region after transferring the partial page references\n\t * to the sg array so that we can have one page ref cleanup path.\n\t *\n\t * For now we have no flag that tells us whether the mapping is\n\t * r/o or r/w. We need to assume r/w, or we'll do a lot of RDMA to\n\t * the zero page.\n\t */\n\tret = rds_pin_pages(args->vec.addr, nr_pages, pages, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tnents = ret;\n\tsg = kcalloc(nents, sizeof(*sg), GFP_KERNEL);\n\tif (!sg) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tWARN_ON(!nents);\n\tsg_init_table(sg, nents);\n\n\t/* Stick all pages into the scatterlist */\n\tfor (i = 0 ; i < nents; i++)\n\t\tsg_set_page(&sg[i], pages[i], PAGE_SIZE, 0);\n\n\trdsdebug(\"RDS: trans_private nents is %u\\n\", nents);\n\n\t/* Obtain a transport specific MR. If this succeeds, the\n\t * s/g list is now owned by the MR.\n\t * Note that dma_map() implies that pending writes are\n\t * flushed to RAM, so no dma_sync is needed here. */\n\ttrans_private = rs->rs_transport->get_mr(sg, nents, rs,\n\t\t\t\t\t\t &mr->r_key);\n\n\tif (IS_ERR(trans_private)) {\n\t\tfor (i = 0 ; i < nents; i++)\n\t\t\tput_page(sg_page(&sg[i]));\n\t\tkfree(sg);\n\t\tret = PTR_ERR(trans_private);\n\t\tgoto out;\n\t}\n\n\tmr->r_trans_private = trans_private;\n\n\trdsdebug(\"RDS: get_mr put_user key is %x cookie_addr %p\\n\",\n\t       mr->r_key, (void *)(unsigned long) args->cookie_addr);\n\n\t/* The user may pass us an unaligned address, but we can only\n\t * map page aligned regions. So we keep the offset, and build\n\t * a 64bit cookie containing <R_Key, offset> and pass that\n\t * around. */\n\tcookie = rds_rdma_make_cookie(mr->r_key, args->vec.addr & ~PAGE_MASK);\n\tif (cookie_ret)\n\t\t*cookie_ret = cookie;\n\n\tif (args->cookie_addr && put_user(cookie, (u64 __user *)(unsigned long) args->cookie_addr)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t/* Inserting the new MR into the rbtree bumps its\n\t * reference count. */\n\tspin_lock_irqsave(&rs->rs_rdma_lock, flags);\n\tfound = rds_mr_tree_walk(&rs->rs_rdma_keys, mr->r_key, mr);\n\tspin_unlock_irqrestore(&rs->rs_rdma_lock, flags);\n\n\tBUG_ON(found && found != mr);\n\n\trdsdebug(\"RDS: get_mr key is %x\\n\", mr->r_key);\n\tif (mr_ret) {\n\t\trefcount_inc(&mr->r_refcount);\n\t\t*mr_ret = mr;\n\t}\n\n\tret = 0;\nout:\n\tkfree(pages);\n\tif (mr)\n\t\trds_mr_put(mr);\n\treturn ret;\n}\n\nint rds_get_mr(struct rds_sock *rs, char __user *optval, int optlen)\n{\n\tstruct rds_get_mr_args args;\n\n\tif (optlen != sizeof(struct rds_get_mr_args))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&args, (struct rds_get_mr_args __user *)optval,\n\t\t\t   sizeof(struct rds_get_mr_args)))\n\t\treturn -EFAULT;\n\n\treturn __rds_rdma_map(rs, &args, NULL, NULL);\n}\n\nint rds_get_mr_for_dest(struct rds_sock *rs, char __user *optval, int optlen)\n{\n\tstruct rds_get_mr_for_dest_args args;\n\tstruct rds_get_mr_args new_args;\n\n\tif (optlen != sizeof(struct rds_get_mr_for_dest_args))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&args, (struct rds_get_mr_for_dest_args __user *)optval,\n\t\t\t   sizeof(struct rds_get_mr_for_dest_args)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * Initially, just behave like get_mr().\n\t * TODO: Implement get_mr as wrapper around this\n\t *\t and deprecate it.\n\t */\n\tnew_args.vec = args.vec;\n\tnew_args.cookie_addr = args.cookie_addr;\n\tnew_args.flags = args.flags;\n\n\treturn __rds_rdma_map(rs, &new_args, NULL, NULL);\n}\n\n/*\n * Free the MR indicated by the given R_Key\n */\nint rds_free_mr(struct rds_sock *rs, char __user *optval, int optlen)\n{\n\tstruct rds_free_mr_args args;\n\tstruct rds_mr *mr;\n\tunsigned long flags;\n\n\tif (optlen != sizeof(struct rds_free_mr_args))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&args, (struct rds_free_mr_args __user *)optval,\n\t\t\t   sizeof(struct rds_free_mr_args)))\n\t\treturn -EFAULT;\n\n\t/* Special case - a null cookie means flush all unused MRs */\n\tif (args.cookie == 0) {\n\t\tif (!rs->rs_transport || !rs->rs_transport->flush_mrs)\n\t\t\treturn -EINVAL;\n\t\trs->rs_transport->flush_mrs();\n\t\treturn 0;\n\t}\n\n\t/* Look up the MR given its R_key and remove it from the rbtree\n\t * so nobody else finds it.\n\t * This should also prevent races with rds_rdma_unuse.\n\t */\n\tspin_lock_irqsave(&rs->rs_rdma_lock, flags);\n\tmr = rds_mr_tree_walk(&rs->rs_rdma_keys, rds_rdma_cookie_key(args.cookie), NULL);\n\tif (mr) {\n\t\trb_erase(&mr->r_rb_node, &rs->rs_rdma_keys);\n\t\tRB_CLEAR_NODE(&mr->r_rb_node);\n\t\tif (args.flags & RDS_RDMA_INVALIDATE)\n\t\t\tmr->r_invalidate = 1;\n\t}\n\tspin_unlock_irqrestore(&rs->rs_rdma_lock, flags);\n\n\tif (!mr)\n\t\treturn -EINVAL;\n\n\t/*\n\t * call rds_destroy_mr() ourselves so that we're sure it's done by the time\n\t * we return.  If we let rds_mr_put() do it it might not happen until\n\t * someone else drops their ref.\n\t */\n\trds_destroy_mr(mr);\n\trds_mr_put(mr);\n\treturn 0;\n}\n\n/*\n * This is called when we receive an extension header that\n * tells us this MR was used. It allows us to implement\n * use_once semantics\n */\nvoid rds_rdma_unuse(struct rds_sock *rs, u32 r_key, int force)\n{\n\tstruct rds_mr *mr;\n\tunsigned long flags;\n\tint zot_me = 0;\n\n\tspin_lock_irqsave(&rs->rs_rdma_lock, flags);\n\tmr = rds_mr_tree_walk(&rs->rs_rdma_keys, r_key, NULL);\n\tif (!mr) {\n\t\tpr_debug(\"rds: trying to unuse MR with unknown r_key %u!\\n\",\n\t\t\t r_key);\n\t\tspin_unlock_irqrestore(&rs->rs_rdma_lock, flags);\n\t\treturn;\n\t}\n\n\tif (mr->r_use_once || force) {\n\t\trb_erase(&mr->r_rb_node, &rs->rs_rdma_keys);\n\t\tRB_CLEAR_NODE(&mr->r_rb_node);\n\t\tzot_me = 1;\n\t}\n\tspin_unlock_irqrestore(&rs->rs_rdma_lock, flags);\n\n\t/* May have to issue a dma_sync on this memory region.\n\t * Note we could avoid this if the operation was a RDMA READ,\n\t * but at this point we can't tell. */\n\tif (mr->r_trans->sync_mr)\n\t\tmr->r_trans->sync_mr(mr->r_trans_private, DMA_FROM_DEVICE);\n\n\t/* If the MR was marked as invalidate, this will\n\t * trigger an async flush. */\n\tif (zot_me) {\n\t\trds_destroy_mr(mr);\n\t\trds_mr_put(mr);\n\t}\n}\n\nvoid rds_rdma_free_op(struct rm_rdma_op *ro)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ro->op_nents; i++) {\n\t\tstruct page *page = sg_page(&ro->op_sg[i]);\n\n\t\t/* Mark page dirty if it was possibly modified, which\n\t\t * is the case for a RDMA_READ which copies from remote\n\t\t * to local memory */\n\t\tif (!ro->op_write) {\n\t\t\tWARN_ON(!page->mapping && irqs_disabled());\n\t\t\tset_page_dirty(page);\n\t\t}\n\t\tput_page(page);\n\t}\n\n\tkfree(ro->op_notifier);\n\tro->op_notifier = NULL;\n\tro->op_active = 0;\n}\n\nvoid rds_atomic_free_op(struct rm_atomic_op *ao)\n{\n\tstruct page *page = sg_page(ao->op_sg);\n\n\t/* Mark page dirty if it was possibly modified, which\n\t * is the case for a RDMA_READ which copies from remote\n\t * to local memory */\n\tset_page_dirty(page);\n\tput_page(page);\n\n\tkfree(ao->op_notifier);\n\tao->op_notifier = NULL;\n\tao->op_active = 0;\n}\n\n\n/*\n * Count the number of pages needed to describe an incoming iovec array.\n */\nstatic int rds_rdma_pages(struct rds_iovec iov[], int nr_iovecs)\n{\n\tint tot_pages = 0;\n\tunsigned int nr_pages;\n\tunsigned int i;\n\n\t/* figure out the number of pages in the vector */\n\tfor (i = 0; i < nr_iovecs; i++) {\n\t\tnr_pages = rds_pages_in_vec(&iov[i]);\n\t\tif (nr_pages == 0)\n\t\t\treturn -EINVAL;\n\n\t\ttot_pages += nr_pages;\n\n\t\t/*\n\t\t * nr_pages for one entry is limited to (UINT_MAX>>PAGE_SHIFT)+1,\n\t\t * so tot_pages cannot overflow without first going negative.\n\t\t */\n\t\tif (tot_pages < 0)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn tot_pages;\n}\n\nint rds_rdma_extra_size(struct rds_rdma_args *args)\n{\n\tstruct rds_iovec vec;\n\tstruct rds_iovec __user *local_vec;\n\tint tot_pages = 0;\n\tunsigned int nr_pages;\n\tunsigned int i;\n\n\tlocal_vec = (struct rds_iovec __user *)(unsigned long) args->local_vec_addr;\n\n\tif (args->nr_local == 0)\n\t\treturn -EINVAL;\n\n\t/* figure out the number of pages in the vector */\n\tfor (i = 0; i < args->nr_local; i++) {\n\t\tif (copy_from_user(&vec, &local_vec[i],\n\t\t\t\t   sizeof(struct rds_iovec)))\n\t\t\treturn -EFAULT;\n\n\t\tnr_pages = rds_pages_in_vec(&vec);\n\t\tif (nr_pages == 0)\n\t\t\treturn -EINVAL;\n\n\t\ttot_pages += nr_pages;\n\n\t\t/*\n\t\t * nr_pages for one entry is limited to (UINT_MAX>>PAGE_SHIFT)+1,\n\t\t * so tot_pages cannot overflow without first going negative.\n\t\t */\n\t\tif (tot_pages < 0)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn tot_pages * sizeof(struct scatterlist);\n}\n\n/*\n * The application asks for a RDMA transfer.\n * Extract all arguments and set up the rdma_op\n */\nint rds_cmsg_rdma_args(struct rds_sock *rs, struct rds_message *rm,\n\t\t\t  struct cmsghdr *cmsg)\n{\n\tstruct rds_rdma_args *args;\n\tstruct rm_rdma_op *op = &rm->rdma;\n\tint nr_pages;\n\tunsigned int nr_bytes;\n\tstruct page **pages = NULL;\n\tstruct rds_iovec iovstack[UIO_FASTIOV], *iovs = iovstack;\n\tint iov_size;\n\tunsigned int i, j;\n\tint ret = 0;\n\n\tif (cmsg->cmsg_len < CMSG_LEN(sizeof(struct rds_rdma_args))\n\t    || rm->rdma.op_active)\n\t\treturn -EINVAL;\n\n\targs = CMSG_DATA(cmsg);\n\n\tif (rs->rs_bound_addr == 0) {\n\t\tret = -ENOTCONN; /* XXX not a great errno */\n\t\tgoto out_ret;\n\t}\n\n\tif (args->nr_local > UIO_MAXIOV) {\n\t\tret = -EMSGSIZE;\n\t\tgoto out_ret;\n\t}\n\n\t/* Check whether to allocate the iovec area */\n\tiov_size = args->nr_local * sizeof(struct rds_iovec);\n\tif (args->nr_local > UIO_FASTIOV) {\n\t\tiovs = sock_kmalloc(rds_rs_to_sk(rs), iov_size, GFP_KERNEL);\n\t\tif (!iovs) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_ret;\n\t\t}\n\t}\n\n\tif (copy_from_user(iovs, (struct rds_iovec __user *)(unsigned long) args->local_vec_addr, iov_size)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tnr_pages = rds_rdma_pages(iovs, args->nr_local);\n\tif (nr_pages < 0) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tpages = kcalloc(nr_pages, sizeof(struct page *), GFP_KERNEL);\n\tif (!pages) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\top->op_write = !!(args->flags & RDS_RDMA_READWRITE);\n\top->op_fence = !!(args->flags & RDS_RDMA_FENCE);\n\top->op_notify = !!(args->flags & RDS_RDMA_NOTIFY_ME);\n\top->op_silent = !!(args->flags & RDS_RDMA_SILENT);\n\top->op_active = 1;\n\top->op_recverr = rs->rs_recverr;\n\tWARN_ON(!nr_pages);\n\top->op_sg = rds_message_alloc_sgs(rm, nr_pages);\n\tif (!op->op_sg) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (op->op_notify || op->op_recverr) {\n\t\t/* We allocate an uninitialized notifier here, because\n\t\t * we don't want to do that in the completion handler. We\n\t\t * would have to use GFP_ATOMIC there, and don't want to deal\n\t\t * with failed allocations.\n\t\t */\n\t\top->op_notifier = kmalloc(sizeof(struct rds_notifier), GFP_KERNEL);\n\t\tif (!op->op_notifier) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\top->op_notifier->n_user_token = args->user_token;\n\t\top->op_notifier->n_status = RDS_RDMA_SUCCESS;\n\n\t\t/* Enable rmda notification on data operation for composite\n\t\t * rds messages and make sure notification is enabled only\n\t\t * for the data operation which follows it so that application\n\t\t * gets notified only after full message gets delivered.\n\t\t */\n\t\tif (rm->data.op_sg) {\n\t\t\trm->rdma.op_notify = 0;\n\t\t\trm->data.op_notify = !!(args->flags & RDS_RDMA_NOTIFY_ME);\n\t\t}\n\t}\n\n\t/* The cookie contains the R_Key of the remote memory region, and\n\t * optionally an offset into it. This is how we implement RDMA into\n\t * unaligned memory.\n\t * When setting up the RDMA, we need to add that offset to the\n\t * destination address (which is really an offset into the MR)\n\t * FIXME: We may want to move this into ib_rdma.c\n\t */\n\top->op_rkey = rds_rdma_cookie_key(args->cookie);\n\top->op_remote_addr = args->remote_vec.addr + rds_rdma_cookie_offset(args->cookie);\n\n\tnr_bytes = 0;\n\n\trdsdebug(\"RDS: rdma prepare nr_local %llu rva %llx rkey %x\\n\",\n\t       (unsigned long long)args->nr_local,\n\t       (unsigned long long)args->remote_vec.addr,\n\t       op->op_rkey);\n\n\tfor (i = 0; i < args->nr_local; i++) {\n\t\tstruct rds_iovec *iov = &iovs[i];\n\t\t/* don't need to check, rds_rdma_pages() verified nr will be +nonzero */\n\t\tunsigned int nr = rds_pages_in_vec(iov);\n\n\t\trs->rs_user_addr = iov->addr;\n\t\trs->rs_user_bytes = iov->bytes;\n\n\t\t/* If it's a WRITE operation, we want to pin the pages for reading.\n\t\t * If it's a READ operation, we need to pin the pages for writing.\n\t\t */\n\t\tret = rds_pin_pages(iov->addr, nr, pages, !op->op_write);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\telse\n\t\t\tret = 0;\n\n\t\trdsdebug(\"RDS: nr_bytes %u nr %u iov->bytes %llu iov->addr %llx\\n\",\n\t\t\t nr_bytes, nr, iov->bytes, iov->addr);\n\n\t\tnr_bytes += iov->bytes;\n\n\t\tfor (j = 0; j < nr; j++) {\n\t\t\tunsigned int offset = iov->addr & ~PAGE_MASK;\n\t\t\tstruct scatterlist *sg;\n\n\t\t\tsg = &op->op_sg[op->op_nents + j];\n\t\t\tsg_set_page(sg, pages[j],\n\t\t\t\t\tmin_t(unsigned int, iov->bytes, PAGE_SIZE - offset),\n\t\t\t\t\toffset);\n\n\t\t\trdsdebug(\"RDS: sg->offset %x sg->len %x iov->addr %llx iov->bytes %llu\\n\",\n\t\t\t       sg->offset, sg->length, iov->addr, iov->bytes);\n\n\t\t\tiov->addr += sg->length;\n\t\t\tiov->bytes -= sg->length;\n\t\t}\n\n\t\top->op_nents += nr;\n\t}\n\n\tif (nr_bytes > args->remote_vec.bytes) {\n\t\trdsdebug(\"RDS nr_bytes %u remote_bytes %u do not match\\n\",\n\t\t\t\tnr_bytes,\n\t\t\t\t(unsigned int) args->remote_vec.bytes);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\top->op_bytes = nr_bytes;\n\nout:\n\tif (iovs != iovstack)\n\t\tsock_kfree_s(rds_rs_to_sk(rs), iovs, iov_size);\n\tkfree(pages);\nout_ret:\n\tif (ret)\n\t\trds_rdma_free_op(op);\n\telse\n\t\trds_stats_inc(s_send_rdma);\n\n\treturn ret;\n}\n\n/*\n * The application wants us to pass an RDMA destination (aka MR)\n * to the remote\n */\nint rds_cmsg_rdma_dest(struct rds_sock *rs, struct rds_message *rm,\n\t\t\t  struct cmsghdr *cmsg)\n{\n\tunsigned long flags;\n\tstruct rds_mr *mr;\n\tu32 r_key;\n\tint err = 0;\n\n\tif (cmsg->cmsg_len < CMSG_LEN(sizeof(rds_rdma_cookie_t)) ||\n\t    rm->m_rdma_cookie != 0)\n\t\treturn -EINVAL;\n\n\tmemcpy(&rm->m_rdma_cookie, CMSG_DATA(cmsg), sizeof(rm->m_rdma_cookie));\n\n\t/* We are reusing a previously mapped MR here. Most likely, the\n\t * application has written to the buffer, so we need to explicitly\n\t * flush those writes to RAM. Otherwise the HCA may not see them\n\t * when doing a DMA from that buffer.\n\t */\n\tr_key = rds_rdma_cookie_key(rm->m_rdma_cookie);\n\n\tspin_lock_irqsave(&rs->rs_rdma_lock, flags);\n\tmr = rds_mr_tree_walk(&rs->rs_rdma_keys, r_key, NULL);\n\tif (!mr)\n\t\terr = -EINVAL;\t/* invalid r_key */\n\telse\n\t\trefcount_inc(&mr->r_refcount);\n\tspin_unlock_irqrestore(&rs->rs_rdma_lock, flags);\n\n\tif (mr) {\n\t\tmr->r_trans->sync_mr(mr->r_trans_private, DMA_TO_DEVICE);\n\t\trm->rdma.op_rdma_mr = mr;\n\t}\n\treturn err;\n}\n\n/*\n * The application passes us an address range it wants to enable RDMA\n * to/from. We map the area, and save the <R_Key,offset> pair\n * in rm->m_rdma_cookie. This causes it to be sent along to the peer\n * in an extension header.\n */\nint rds_cmsg_rdma_map(struct rds_sock *rs, struct rds_message *rm,\n\t\t\t  struct cmsghdr *cmsg)\n{\n\tif (cmsg->cmsg_len < CMSG_LEN(sizeof(struct rds_get_mr_args)) ||\n\t    rm->m_rdma_cookie != 0)\n\t\treturn -EINVAL;\n\n\treturn __rds_rdma_map(rs, CMSG_DATA(cmsg), &rm->m_rdma_cookie, &rm->rdma.op_rdma_mr);\n}\n\n/*\n * Fill in rds_message for an atomic request.\n */\nint rds_cmsg_atomic(struct rds_sock *rs, struct rds_message *rm,\n\t\t    struct cmsghdr *cmsg)\n{\n\tstruct page *page = NULL;\n\tstruct rds_atomic_args *args;\n\tint ret = 0;\n\n\tif (cmsg->cmsg_len < CMSG_LEN(sizeof(struct rds_atomic_args))\n\t || rm->atomic.op_active)\n\t\treturn -EINVAL;\n\n\targs = CMSG_DATA(cmsg);\n\n\t/* Nonmasked & masked cmsg ops converted to masked hw ops */\n\tswitch (cmsg->cmsg_type) {\n\tcase RDS_CMSG_ATOMIC_FADD:\n\t\trm->atomic.op_type = RDS_ATOMIC_TYPE_FADD;\n\t\trm->atomic.op_m_fadd.add = args->fadd.add;\n\t\trm->atomic.op_m_fadd.nocarry_mask = 0;\n\t\tbreak;\n\tcase RDS_CMSG_MASKED_ATOMIC_FADD:\n\t\trm->atomic.op_type = RDS_ATOMIC_TYPE_FADD;\n\t\trm->atomic.op_m_fadd.add = args->m_fadd.add;\n\t\trm->atomic.op_m_fadd.nocarry_mask = args->m_fadd.nocarry_mask;\n\t\tbreak;\n\tcase RDS_CMSG_ATOMIC_CSWP:\n\t\trm->atomic.op_type = RDS_ATOMIC_TYPE_CSWP;\n\t\trm->atomic.op_m_cswp.compare = args->cswp.compare;\n\t\trm->atomic.op_m_cswp.swap = args->cswp.swap;\n\t\trm->atomic.op_m_cswp.compare_mask = ~0;\n\t\trm->atomic.op_m_cswp.swap_mask = ~0;\n\t\tbreak;\n\tcase RDS_CMSG_MASKED_ATOMIC_CSWP:\n\t\trm->atomic.op_type = RDS_ATOMIC_TYPE_CSWP;\n\t\trm->atomic.op_m_cswp.compare = args->m_cswp.compare;\n\t\trm->atomic.op_m_cswp.swap = args->m_cswp.swap;\n\t\trm->atomic.op_m_cswp.compare_mask = args->m_cswp.compare_mask;\n\t\trm->atomic.op_m_cswp.swap_mask = args->m_cswp.swap_mask;\n\t\tbreak;\n\tdefault:\n\t\tBUG(); /* should never happen */\n\t}\n\n\trm->atomic.op_notify = !!(args->flags & RDS_RDMA_NOTIFY_ME);\n\trm->atomic.op_silent = !!(args->flags & RDS_RDMA_SILENT);\n\trm->atomic.op_active = 1;\n\trm->atomic.op_recverr = rs->rs_recverr;\n\trm->atomic.op_sg = rds_message_alloc_sgs(rm, 1);\n\tif (!rm->atomic.op_sg) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t/* verify 8 byte-aligned */\n\tif (args->local_addr & 0x7) {\n\t\tret = -EFAULT;\n\t\tgoto err;\n\t}\n\n\tret = rds_pin_pages(args->local_addr, 1, &page, 1);\n\tif (ret != 1)\n\t\tgoto err;\n\tret = 0;\n\n\tsg_set_page(rm->atomic.op_sg, page, 8, offset_in_page(args->local_addr));\n\n\tif (rm->atomic.op_notify || rm->atomic.op_recverr) {\n\t\t/* We allocate an uninitialized notifier here, because\n\t\t * we don't want to do that in the completion handler. We\n\t\t * would have to use GFP_ATOMIC there, and don't want to deal\n\t\t * with failed allocations.\n\t\t */\n\t\trm->atomic.op_notifier = kmalloc(sizeof(*rm->atomic.op_notifier), GFP_KERNEL);\n\t\tif (!rm->atomic.op_notifier) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\trm->atomic.op_notifier->n_user_token = args->user_token;\n\t\trm->atomic.op_notifier->n_status = RDS_RDMA_SUCCESS;\n\t}\n\n\trm->atomic.op_rkey = rds_rdma_cookie_key(args->cookie);\n\trm->atomic.op_remote_addr = args->remote_addr + rds_rdma_cookie_offset(args->cookie);\n\n\treturn ret;\nerr:\n\tif (page)\n\t\tput_page(page);\n\tkfree(rm->atomic.op_notifier);\n\n\treturn ret;\n}\n"], "filenames": ["net/rds/rdma.c"], "buggy_code_start_loc": [527], "buggy_code_end_loc": [527], "fixing_code_start_loc": [528], "fixing_code_end_loc": [531], "type": "CWE-787", "message": "In the Linux kernel through 3.2, the rds_message_alloc_sgs() function does not validate a value that is used during DMA page allocation, leading to a heap-based out-of-bounds write (related to the rds_rdma_extra_size function in net/rds/rdma.c).", "other": {"cve": {"id": "CVE-2018-5332", "sourceIdentifier": "cve@mitre.org", "published": "2018-01-11T07:29:00.217", "lastModified": "2023-02-24T18:43:39.280", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In the Linux kernel through 3.2, the rds_message_alloc_sgs() function does not validate a value that is used during DMA page allocation, leading to a heap-based out-of-bounds write (related to the rds_rdma_extra_size function in net/rds/rdma.c)."}, {"lang": "es", "value": "En el kernel de Linux hasta la versi\u00f3n 3.2, la funci\u00f3n rds_message_alloc_sgs() no valida un valor empleado durante la asignaci\u00f3n de p\u00e1gina DMA, lo que conduce a una escritura fuera de l\u00edmites basada en memoria din\u00e1mica (heap), relacionado con la funci\u00f3n rds_rdma_extra_size en net/rds/rdma.c"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.2.99", "matchCriteriaId": "87B791D3-1C62-44B7-B4E4-E70E6F183462"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.3", "versionEndExcluding": "3.16.54", "matchCriteriaId": "D999C96C-7B24-4418-9FEE-AF2D2539E28E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.17", "versionEndExcluding": "3.18.92", "matchCriteriaId": "56D29D8F-12F1-42E4-92EC-4DEC7214BA16"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.19", "versionEndExcluding": "4.1.50", "matchCriteriaId": "F71F6650-13B4-486F-80AC-20D871806D44"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.2", "versionEndExcluding": "4.4.112", "matchCriteriaId": "899C6EC3-5202-4A9A-9304-901FA4DECAFF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.5", "versionEndExcluding": "4.9.77", "matchCriteriaId": "0B51DE9C-D416-43D5-81C9-83F8958ADB2E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.10", "versionEndExcluding": "4.14.44", "matchCriteriaId": "CC51E40C-0FA7-41BD-ABDD-BA28D2B35761"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "16F59A04-14CF-49E2-9973-645477EA09DA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:esm:*:*:*", "matchCriteriaId": "8D305F7A-D159-4716-AB26-5E38BB5CD991"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:17.10:*:*:*:*:*:*:*", "matchCriteriaId": "9070C9D8-A14A-467F-8253-33B966C16886"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=c095508770aebf1b9218e77026e48345d719b17c", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "http://www.securityfocus.com/bid/102507", "source": "cve@mitre.org", "tags": ["Broken Link", "Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:0470", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git/commit/?id=60daca9efbb3e4109ebc1f7069543e5573fc124e", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/c095508770aebf1b9218e77026e48345d719b17c", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/05/msg00000.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3617-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3617-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3617-3/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3619-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3619-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3620-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3620-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3632-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4187", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/c095508770aebf1b9218e77026e48345d719b17c"}}