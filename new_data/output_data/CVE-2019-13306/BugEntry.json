{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            PPPP   N   N  M   M                              %\n%                            P   P  NN  N  MM MM                              %\n%                            PPPP   N N N  M M M                              %\n%                            P      N  NN  M   M                              %\n%                            P      N   N  M   M                              %\n%                                                                             %\n%                                                                             %\n%               Read/Write PBMPlus Portable Anymap Image Format               %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n\f\n/*\n  Typedef declarations.\n*/\ntypedef struct _CommentInfo\n{\n  char\n    *comment;\n\n  size_t\n    extent;\n} CommentInfo;\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WritePNMImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s P N M                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsPNM() returns MagickTrue if the image format type, identified by the\n%  magick string, is PNM.\n%\n%  The format of the IsPNM method is:\n%\n%      MagickBooleanType IsPNM(const unsigned char *magick,const size_t extent)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o extent: Specifies the extent of the magick string.\n%\n*/\nstatic MagickBooleanType IsPNM(const unsigned char *magick,const size_t extent)\n{\n  if (extent < 2)\n    return(MagickFalse);\n  if ((*magick == (unsigned char) 'P') &&\n      ((magick[1] == '1') || (magick[1] == '2') || (magick[1] == '3') ||\n       (magick[1] == '4') || (magick[1] == '5') || (magick[1] == '6') ||\n       (magick[1] == '7') || (magick[1] == 'F') || (magick[1] == 'f')))\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d P N M I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadPNMImage() reads a Portable Anymap image file and returns it.\n%  It allocates the memory necessary for the new Image structure and returns\n%  a pointer to the new image.\n%\n%  The format of the ReadPNMImage method is:\n%\n%      Image *ReadPNMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic int PNMComment(Image *image,CommentInfo *comment_info,\n  ExceptionInfo *exception)\n{\n  int\n    c;\n\n  register char\n    *p;\n\n  /*\n    Read comment.\n  */\n  p=comment_info->comment+strlen(comment_info->comment);\n  for (c='#'; (c != EOF) && (c != (int) '\\n') && (c != (int) '\\r'); p++)\n  {\n    if ((size_t) (p-comment_info->comment+1) >= comment_info->extent)\n      {\n        comment_info->extent<<=1;\n        comment_info->comment=(char *) ResizeQuantumMemory(\n          comment_info->comment,comment_info->extent,\n          sizeof(*comment_info->comment));\n        if (comment_info->comment == (char *) NULL)\n          return(-1);\n        p=comment_info->comment+strlen(comment_info->comment);\n      }\n    c=ReadBlobByte(image);\n    if (c != EOF)\n      {\n        *p=(char) c;\n        *(p+1)='\\0';\n      }\n  }\n  return(c);\n}\n\nstatic unsigned int PNMInteger(Image *image,CommentInfo *comment_info,\n  const unsigned int base,ExceptionInfo *exception)\n{\n  int\n    c;\n\n  unsigned int\n    value;\n\n  /*\n    Skip any leading whitespace.\n  */\n  do\n  {\n    c=ReadBlobByte(image);\n    if (c == EOF)\n      return(0);\n    if (c == (int) '#')\n      c=PNMComment(image,comment_info,exception);\n  } while ((c == ' ') || (c == '\\t') || (c == '\\n') || (c == '\\r'));\n  if (base == 2)\n    return((unsigned int) (c-(int) '0'));\n  /*\n    Evaluate number.\n  */\n  value=0;\n  while (isdigit(c) != 0)\n  {\n    if (value <= (unsigned int) (INT_MAX/10))\n      {\n        value*=10;\n        if (value <= (unsigned int) (INT_MAX-(c-(int) '0')))\n          value+=c-(int) '0';\n      }\n    c=ReadBlobByte(image);\n    if (c == EOF)\n      return(0);\n  }\n  if (c == (int) '#')\n    c=PNMComment(image,comment_info,exception);\n  return(value);\n}\n\nstatic Image *ReadPNMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define ThrowPNMException(exception,message) \\\n{ \\\n  if (comment_info.comment != (char *) NULL)  \\\n    comment_info.comment=DestroyString(comment_info.comment); \\\n  ThrowReaderException((exception),(message)); \\\n}\n\n  char\n    format;\n\n  CommentInfo\n    comment_info;\n\n  double\n    quantum_scale;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  QuantumAny\n    max_value;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  size_t\n    depth,\n    extent,\n    packet_size;\n\n  ssize_t\n    count,\n    row,\n    y;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read PNM image.\n  */\n  count=ReadBlob(image,1,(unsigned char *) &format);\n  do\n  {\n    /*\n      Initialize image structure.\n    */\n    comment_info.comment=AcquireString(NULL);\n    comment_info.extent=MagickPathExtent;\n    if ((count != 1) || (format != 'P'))\n      ThrowPNMException(CorruptImageError,\"ImproperImageHeader\");\n    max_value=1;\n    quantum_type=RGBQuantum;\n    quantum_scale=1.0;\n    format=(char) ReadBlobByte(image);\n    if (format != '7')\n      {\n        /*\n          PBM, PGM, PPM, and PNM.\n        */\n        image->columns=(size_t) PNMInteger(image,&comment_info,10,exception);\n        image->rows=(size_t) PNMInteger(image,&comment_info,10,exception);\n        if ((format == 'f') || (format == 'F'))\n          {\n            char\n              scale[MagickPathExtent];\n\n            if (ReadBlobString(image,scale) != (char *) NULL)\n              quantum_scale=StringToDouble(scale,(char **) NULL);\n          }\n        else\n          {\n            if ((format == '1') || (format == '4'))\n              max_value=1;  /* bitmap */\n            else\n              max_value=(QuantumAny) PNMInteger(image,&comment_info,10,\n                exception);\n          }\n      }\n    else\n      {\n        char\n          keyword[MagickPathExtent],\n          value[MagickPathExtent];\n\n        int\n          c;\n\n        register char\n          *p;\n\n        /*\n          PAM.\n        */\n        for (c=ReadBlobByte(image); c != EOF; c=ReadBlobByte(image))\n        {\n          while (isspace((int) ((unsigned char) c)) != 0)\n            c=ReadBlobByte(image);\n          if (c == '#')\n            {\n              /*\n                Comment.\n              */\n              c=PNMComment(image,&comment_info,exception);\n              c=ReadBlobByte(image);\n              while (isspace((int) ((unsigned char) c)) != 0)\n                c=ReadBlobByte(image);\n            }\n          p=keyword;\n          do\n          {\n            if ((size_t) (p-keyword) < (MagickPathExtent-1))\n              *p++=c;\n            c=ReadBlobByte(image);\n          } while (isalnum(c));\n          *p='\\0';\n          if (LocaleCompare(keyword,\"endhdr\") == 0)\n            break;\n          while (isspace((int) ((unsigned char) c)) != 0)\n            c=ReadBlobByte(image);\n          p=value;\n          while (isalnum(c) || (c == '_'))\n          {\n            if ((size_t) (p-value) < (MagickPathExtent-1))\n              *p++=c;\n            c=ReadBlobByte(image);\n          }\n          *p='\\0';\n          /*\n            Assign a value to the specified keyword.\n          */\n          if (LocaleCompare(keyword,\"depth\") == 0)\n            packet_size=StringToUnsignedLong(value);\n          (void) packet_size;\n          if (LocaleCompare(keyword,\"height\") == 0)\n            image->rows=StringToUnsignedLong(value);\n          if (LocaleCompare(keyword,\"maxval\") == 0)\n            max_value=StringToUnsignedLong(value);\n          if (LocaleCompare(keyword,\"TUPLTYPE\") == 0)\n            {\n              if (LocaleCompare(value,\"BLACKANDWHITE\") == 0)\n                {\n                  (void) SetImageColorspace(image,GRAYColorspace,exception);\n                  quantum_type=GrayQuantum;\n                }\n              if (LocaleCompare(value,\"BLACKANDWHITE_ALPHA\") == 0)\n                {\n                  (void) SetImageColorspace(image,GRAYColorspace,exception);\n                  image->alpha_trait=BlendPixelTrait;\n                  quantum_type=GrayAlphaQuantum;\n                }\n              if (LocaleCompare(value,\"GRAYSCALE\") == 0)\n                {\n                  quantum_type=GrayQuantum;\n                  (void) SetImageColorspace(image,GRAYColorspace,exception);\n                }\n              if (LocaleCompare(value,\"GRAYSCALE_ALPHA\") == 0)\n                {\n                  (void) SetImageColorspace(image,GRAYColorspace,exception);\n                  image->alpha_trait=BlendPixelTrait;\n                  quantum_type=GrayAlphaQuantum;\n                }\n              if (LocaleCompare(value,\"RGB_ALPHA\") == 0)\n                {\n                  image->alpha_trait=BlendPixelTrait;\n                  quantum_type=RGBAQuantum;\n                }\n              if (LocaleCompare(value,\"CMYK\") == 0)\n                {\n                  (void) SetImageColorspace(image,CMYKColorspace,exception);\n                  quantum_type=CMYKQuantum;\n                }\n              if (LocaleCompare(value,\"CMYK_ALPHA\") == 0)\n                {\n                  (void) SetImageColorspace(image,CMYKColorspace,exception);\n                  image->alpha_trait=BlendPixelTrait;\n                  quantum_type=CMYKAQuantum;\n                }\n            }\n          if (LocaleCompare(keyword,\"width\") == 0)\n            image->columns=StringToUnsignedLong(value);\n        }\n      }\n    if ((image->columns == 0) || (image->rows == 0))\n      ThrowPNMException(CorruptImageError,\"NegativeOrZeroImageSize\");\n    if ((max_value == 0) || (max_value > 4294967295UL))\n      ThrowPNMException(CorruptImageError,\"ImproperImageHeader\");\n    for (depth=1; GetQuantumRange(depth) < max_value; depth++) ;\n    image->depth=depth;\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if ((MagickSizeType) (image->columns*image->rows/8) > GetBlobSize(image))\n      ThrowPNMException(CorruptImageError,\"InsufficientImageDataInFile\");\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      {\n        comment_info.comment=DestroyString(comment_info.comment); \\\n        return(DestroyImageList(image));\n      }\n    (void) ResetImagePixels(image,exception);\n    /*\n      Convert PNM pixels to runextent-encoded MIFF packets.\n    */\n    row=0;\n    y=0;\n    switch (format)\n    {\n      case '1':\n      {\n        /*\n          Convert PBM image to pixel packets.\n        */\n        (void) SetImageColorspace(image,GRAYColorspace,exception);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register ssize_t\n            x;\n\n          register Quantum\n            *magick_restrict q;\n\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelGray(image,PNMInteger(image,&comment_info,2,exception) ==\n              0 ? QuantumRange : 0,q);\n            if (EOFBlob(image) != MagickFalse)\n              break;\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n          if (EOFBlob(image) != MagickFalse)\n            break;\n        }\n        image->type=BilevelType;\n        break;\n      }\n      case '2':\n      {\n        Quantum\n          intensity;\n\n        /*\n          Convert PGM image to pixel packets.\n        */\n        (void) SetImageColorspace(image,GRAYColorspace,exception);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register ssize_t\n            x;\n\n          register Quantum\n            *magick_restrict q;\n\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            intensity=ScaleAnyToQuantum(PNMInteger(image,&comment_info,10,\n              exception),max_value);\n            if (EOFBlob(image) != MagickFalse)\n              break;\n            SetPixelGray(image,intensity,q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n          if (EOFBlob(image) != MagickFalse)\n            break;\n        }\n        image->type=GrayscaleType;\n        break;\n      }\n      case '3':\n      {\n        /*\n          Convert PNM image to pixel packets.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register ssize_t\n            x;\n\n          register Quantum\n            *magick_restrict q;\n\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            Quantum\n              pixel;\n\n            pixel=ScaleAnyToQuantum(PNMInteger(image,&comment_info,10,\n              exception),max_value);\n            if (EOFBlob(image) != MagickFalse)\n              break;\n            SetPixelRed(image,pixel,q);\n            pixel=ScaleAnyToQuantum(PNMInteger(image,&comment_info,10,\n              exception),max_value);\n            SetPixelGreen(image,pixel,q);\n            pixel=ScaleAnyToQuantum(PNMInteger(image,&comment_info,10,\n              exception),max_value);\n            SetPixelBlue(image,pixel,q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n          if (EOFBlob(image) != MagickFalse)\n            break;\n        }\n        break;\n      }\n      case '4':\n      {\n        /*\n          Convert PBM raw image to pixel packets.\n        */\n        (void) SetImageColorspace(image,GRAYColorspace,exception);\n        quantum_type=GrayQuantum;\n        if (image->storage_class == PseudoClass)\n          quantum_type=IndexQuantum;\n        quantum_info=AcquireQuantumInfo(image_info,image);\n        if (quantum_info == (QuantumInfo *) NULL)\n          ThrowPNMException(ResourceLimitError,\"MemoryAllocationFailed\");\n        SetQuantumMinIsWhite(quantum_info,MagickTrue);\n        extent=GetQuantumExtent(image,quantum_info,quantum_type);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          const unsigned char\n            *pixels;\n\n          MagickBooleanType\n            sync;\n\n          register Quantum\n            *magick_restrict q;\n\n          ssize_t\n            offset;\n\n          size_t\n            length;\n\n          pixels=(unsigned char *) ReadBlobStream(image,extent,\n            GetQuantumPixels(quantum_info),&count);\n          if (count != (ssize_t) extent)\n            break;\n          if ((image->progress_monitor != (MagickProgressMonitor) NULL) &&\n              (image->previous == (Image *) NULL))\n            {\n              MagickBooleanType\n                proceed;\n\n              proceed=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                row,image->rows);\n              if (proceed == MagickFalse)\n                break;\n            }\n          offset=row++;\n          q=QueueAuthenticPixels(image,0,offset,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          length=ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          if (length != extent)\n            break;\n          sync=SyncAuthenticPixels(image,exception);\n          if (sync == MagickFalse)\n            break;\n        }\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        SetQuantumImageType(image,quantum_type);\n        break;\n      }\n      case '5':\n      {\n        /*\n          Convert PGM raw image to pixel packets.\n        */\n        (void) SetImageColorspace(image,GRAYColorspace,exception);\n        quantum_type=GrayQuantum;\n        extent=(image->depth <= 8 ? 1 : image->depth <= 16 ? 2 : 4)*\n          image->columns;\n        quantum_info=AcquireQuantumInfo(image_info,image);\n        if (quantum_info == (QuantumInfo *) NULL)\n          ThrowPNMException(ResourceLimitError,\"MemoryAllocationFailed\");\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          const unsigned char\n            *pixels;\n\n          MagickBooleanType\n            sync;\n\n          register const unsigned char\n            *magick_restrict p;\n\n          register ssize_t\n            x;\n\n          register Quantum\n            *magick_restrict q;\n\n          ssize_t\n            offset;\n\n          pixels=(unsigned char *) ReadBlobStream(image,extent,\n            GetQuantumPixels(quantum_info),&count);\n          if (count != (ssize_t) extent)\n            break;\n          if ((image->progress_monitor != (MagickProgressMonitor) NULL) &&\n              (image->previous == (Image *) NULL))\n            {\n              MagickBooleanType\n                proceed;\n\n              proceed=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                row,image->rows);\n              if (proceed == MagickFalse)\n                break;\n            }\n          offset=row++;\n          q=QueueAuthenticPixels(image,0,offset,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          p=pixels;\n          switch (image->depth)\n          {\n            case 8:\n            case 16:\n            case 32:\n            {\n              (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                quantum_type,pixels,exception);\n              break;\n            }\n            default:\n            {\n              if (image->depth <= 8)\n                {\n                  unsigned char\n                    pixel;\n\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    p=PushCharPixel(p,&pixel);\n                    SetPixelGray(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    q+=GetPixelChannels(image);\n                  }\n                }\n              else if (image->depth <= 16)\n                {\n                  unsigned short\n                    pixel;\n\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    p=PushShortPixel(MSBEndian,p,&pixel);\n                    SetPixelGray(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    q+=GetPixelChannels(image);\n                  }\n                }\n              else\n                {\n                  unsigned int\n                    pixel;\n\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    p=PushLongPixel(MSBEndian,p,&pixel);\n                    SetPixelGray(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    q+=GetPixelChannels(image);\n                  }\n                }\n              break;\n            }\n          }\n          sync=SyncAuthenticPixels(image,exception);\n          if (sync == MagickFalse)\n            break;\n        }\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        SetQuantumImageType(image,quantum_type);\n        break;\n      }\n      case '6':\n      {\n        /*\n          Convert PNM raster image to pixel packets.\n        */\n        quantum_type=RGBQuantum;\n        extent=3*(image->depth <= 8 ? 1 : image->depth <= 16 ? 2 : 4)*\n          image->columns;\n        quantum_info=AcquireQuantumInfo(image_info,image);\n        if (quantum_info == (QuantumInfo *) NULL)\n          ThrowPNMException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) SetQuantumEndian(image,quantum_info,MSBEndian);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          const unsigned char\n            *pixels;\n\n          MagickBooleanType\n            sync;\n\n          register const unsigned char\n            *magick_restrict p;\n\n          register ssize_t\n            x;\n\n          register Quantum\n            *magick_restrict q;\n\n          ssize_t\n            offset;\n\n          pixels=(unsigned char *) ReadBlobStream(image,extent,\n            GetQuantumPixels(quantum_info),&count);\n          if (count != (ssize_t) extent)\n            break;\n          if ((image->progress_monitor != (MagickProgressMonitor) NULL) &&\n              (image->previous == (Image *) NULL))\n            {\n              MagickBooleanType\n                proceed;\n\n              proceed=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                row,image->rows);\n              if (proceed == MagickFalse)\n                break;\n            }\n          offset=row++;\n          q=QueueAuthenticPixels(image,0,offset,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          p=pixels;\n          switch (image->depth)\n          {\n            case 8:\n            {\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n                SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n                SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n                SetPixelAlpha(image,OpaqueAlpha,q);\n                q+=GetPixelChannels(image);\n              }\n              break;\n            }\n            case 16:\n            {\n              unsigned short\n                pixel;\n\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                p=PushShortPixel(MSBEndian,p,&pixel);\n                SetPixelRed(image,ScaleShortToQuantum(pixel),q);\n                p=PushShortPixel(MSBEndian,p,&pixel);\n                SetPixelGreen(image,ScaleShortToQuantum(pixel),q);\n                p=PushShortPixel(MSBEndian,p,&pixel);\n                SetPixelBlue(image,ScaleShortToQuantum(pixel),q);\n                SetPixelAlpha(image,OpaqueAlpha,q);\n                q+=GetPixelChannels(image);\n              }\n              break;\n            }\n            case 32:\n            {\n              unsigned int\n                pixel;\n\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                p=PushLongPixel(MSBEndian,p,&pixel);\n                SetPixelRed(image,ScaleLongToQuantum(pixel),q);\n                p=PushLongPixel(MSBEndian,p,&pixel);\n                SetPixelGreen(image,ScaleLongToQuantum(pixel),q);\n                p=PushLongPixel(MSBEndian,p,&pixel);\n                SetPixelBlue(image,ScaleLongToQuantum(pixel),q);\n                SetPixelAlpha(image,OpaqueAlpha,q);\n                q+=GetPixelChannels(image);\n              }\n              break;\n            }\n            default:\n            {\n              if (image->depth <= 8)\n                {\n                  unsigned char\n                    pixel;\n\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    p=PushCharPixel(p,&pixel);\n                    SetPixelRed(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    p=PushCharPixel(p,&pixel);\n                    SetPixelGreen(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    p=PushCharPixel(p,&pixel);\n                    SetPixelBlue(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    SetPixelAlpha(image,OpaqueAlpha,q);\n                    q+=GetPixelChannels(image);\n                  }\n                }\n              else if (image->depth <= 16)\n                {\n                  unsigned short\n                    pixel;\n\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    p=PushShortPixel(MSBEndian,p,&pixel);\n                    SetPixelRed(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    p=PushShortPixel(MSBEndian,p,&pixel);\n                    SetPixelGreen(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    p=PushShortPixel(MSBEndian,p,&pixel);\n                    SetPixelBlue(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    SetPixelAlpha(image,OpaqueAlpha,q);\n                    q+=GetPixelChannels(image);\n                  }\n                }\n              else\n                {\n                  unsigned int\n                    pixel;\n\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    p=PushLongPixel(MSBEndian,p,&pixel);\n                    SetPixelRed(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    p=PushLongPixel(MSBEndian,p,&pixel);\n                    SetPixelGreen(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    p=PushLongPixel(MSBEndian,p,&pixel);\n                    SetPixelBlue(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    SetPixelAlpha(image,OpaqueAlpha,q);\n                    q+=GetPixelChannels(image);\n                  }\n                }\n              break;\n            }\n          }\n          sync=SyncAuthenticPixels(image,exception);\n          if (sync == MagickFalse)\n            break;\n        }\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        break;\n      }\n      case '7':\n      {\n        size_t\n          channels;\n\n        /*\n          Convert PAM raster image to pixel packets.\n        */\n        switch (quantum_type)\n        {\n          case GrayQuantum:\n          case GrayAlphaQuantum:\n          {\n            channels=1;\n            break;\n          }\n          case CMYKQuantum:\n          case CMYKAQuantum:\n          {\n            channels=4;\n            break;\n          }\n          default:\n          {\n            channels=3;\n            break;\n          }\n        }\n        if (image->alpha_trait != UndefinedPixelTrait)\n          channels++;\n        extent=channels*(image->depth <= 8 ? 1 : image->depth <= 16 ? 2 : 4)*\n          image->columns;\n        quantum_info=AcquireQuantumInfo(image_info,image);\n        if (quantum_info == (QuantumInfo *) NULL)\n          ThrowPNMException(ResourceLimitError,\"MemoryAllocationFailed\");\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          const unsigned char\n            *pixels;\n\n          MagickBooleanType\n            sync;\n\n          register const unsigned char\n            *magick_restrict p;\n\n          register ssize_t\n            x;\n\n          register Quantum\n            *magick_restrict q;\n\n          ssize_t\n            offset;\n\n          pixels=(unsigned char *) ReadBlobStream(image,extent,\n            GetQuantumPixels(quantum_info),&count);\n          if (count != (ssize_t) extent)\n            break;\n          if ((image->progress_monitor != (MagickProgressMonitor) NULL) &&\n              (image->previous == (Image *) NULL))\n            {\n              MagickBooleanType\n                proceed;\n\n              proceed=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                row,image->rows);\n              if (proceed == MagickFalse)\n                break;\n            }\n          offset=row++;\n          q=QueueAuthenticPixels(image,0,offset,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          p=pixels;\n          switch (image->depth)\n          {\n            case 8:\n            case 16:\n            case 32:\n            {\n              (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                quantum_type,pixels,exception);\n              break;\n            }\n            default:\n            {\n              switch (quantum_type)\n              {\n                case GrayQuantum:\n                case GrayAlphaQuantum:\n                {\n                  if (image->depth <= 8)\n                    {\n                      unsigned char\n                        pixel;\n\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        p=PushCharPixel(p,&pixel);\n                        SetPixelGray(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        SetPixelAlpha(image,OpaqueAlpha,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            p=PushCharPixel(p,&pixel);\n                            if (image->depth != 1)\n                              SetPixelAlpha(image,ScaleAnyToQuantum(pixel,\n                                max_value),q);\n                            else\n                              SetPixelAlpha(image,QuantumRange-\n                                ScaleAnyToQuantum(pixel,max_value),q);\n                          }\n                        q+=GetPixelChannels(image);\n                      }\n                    }\n                  else if (image->depth <= 16)\n                    {\n                      unsigned short\n                        pixel;\n\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        p=PushShortPixel(MSBEndian,p,&pixel);\n                        SetPixelGray(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        SetPixelAlpha(image,OpaqueAlpha,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            p=PushShortPixel(MSBEndian,p,&pixel);\n                            SetPixelAlpha(image,ScaleAnyToQuantum(pixel,\n                              max_value),q);\n                          }\n                        q+=GetPixelChannels(image);\n                      }\n                    }\n                  else\n                    {\n                      unsigned int\n                        pixel;\n\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        p=PushLongPixel(MSBEndian,p,&pixel);\n                        SetPixelGray(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        SetPixelAlpha(image,OpaqueAlpha,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            p=PushLongPixel(MSBEndian,p,&pixel);\n                            SetPixelAlpha(image,ScaleAnyToQuantum(pixel,\n                              max_value),q);\n                          }\n                        q+=GetPixelChannels(image);\n                      }\n                    }\n                  break;\n                }\n                case CMYKQuantum:\n                case CMYKAQuantum:\n                {\n                  if (image->depth <= 8)\n                    {\n                      unsigned char\n                        pixel;\n\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        p=PushCharPixel(p,&pixel);\n                        SetPixelRed(image,ScaleAnyToQuantum(pixel,max_value),q);\n                        p=PushCharPixel(p,&pixel);\n                        SetPixelGreen(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        p=PushCharPixel(p,&pixel);\n                        SetPixelBlue(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        p=PushCharPixel(p,&pixel);\n                        SetPixelBlack(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        SetPixelAlpha(image,OpaqueAlpha,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            p=PushCharPixel(p,&pixel);\n                            SetPixelAlpha(image,ScaleAnyToQuantum(pixel,\n                              max_value),q);\n                          }\n                        q+=GetPixelChannels(image);\n                      }\n                    }\n                  else if (image->depth <= 16)\n                    {\n                      unsigned short\n                        pixel;\n\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        p=PushShortPixel(MSBEndian,p,&pixel);\n                        SetPixelRed(image,ScaleAnyToQuantum(pixel,max_value),q);\n                        p=PushShortPixel(MSBEndian,p,&pixel);\n                        SetPixelGreen(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        p=PushShortPixel(MSBEndian,p,&pixel);\n                        SetPixelBlue(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        p=PushShortPixel(MSBEndian,p,&pixel);\n                        SetPixelBlack(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        SetPixelAlpha(image,OpaqueAlpha,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            p=PushShortPixel(MSBEndian,p,&pixel);\n                            SetPixelAlpha(image,ScaleAnyToQuantum(pixel,\n                              max_value),q);\n                          }\n                        q+=GetPixelChannels(image);\n                      }\n                    }\n                  else\n                    {\n                      unsigned int\n                        pixel;\n\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        p=PushLongPixel(MSBEndian,p,&pixel);\n                        SetPixelRed(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        p=PushLongPixel(MSBEndian,p,&pixel);\n                        SetPixelGreen(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        p=PushLongPixel(MSBEndian,p,&pixel);\n                        SetPixelBlue(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        p=PushLongPixel(MSBEndian,p,&pixel);\n                        SetPixelBlack(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        SetPixelAlpha(image,OpaqueAlpha,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            p=PushLongPixel(MSBEndian,p,&pixel);\n                            SetPixelAlpha(image,ScaleAnyToQuantum(pixel,\n                              max_value),q);\n                          }\n                        q+=GetPixelChannels(image);\n                    }\n                  }\n                  break;\n                }\n                default:\n                {\n                  if (image->depth <= 8)\n                    {\n                      unsigned char\n                        pixel;\n\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        p=PushCharPixel(p,&pixel);\n                        SetPixelRed(image,ScaleAnyToQuantum(pixel,max_value),q);\n                        p=PushCharPixel(p,&pixel);\n                        SetPixelGreen(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        p=PushCharPixel(p,&pixel);\n                        SetPixelBlue(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        SetPixelAlpha(image,OpaqueAlpha,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            p=PushCharPixel(p,&pixel);\n                            SetPixelAlpha(image,ScaleAnyToQuantum(pixel,\n                              max_value),q);\n                          }\n                        q+=GetPixelChannels(image);\n                      }\n                    }\n                  else if (image->depth <= 16)\n                    {\n                      unsigned short\n                        pixel;\n\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        p=PushShortPixel(MSBEndian,p,&pixel);\n                        SetPixelRed(image,ScaleAnyToQuantum(pixel,max_value),q);\n                        p=PushShortPixel(MSBEndian,p,&pixel);\n                        SetPixelGreen(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        p=PushShortPixel(MSBEndian,p,&pixel);\n                        SetPixelBlue(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        SetPixelAlpha(image,OpaqueAlpha,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            p=PushShortPixel(MSBEndian,p,&pixel);\n                            SetPixelAlpha(image,ScaleAnyToQuantum(pixel,\n                              max_value),q);\n                          }\n                        q+=GetPixelChannels(image);\n                      }\n                    }\n                  else\n                    {\n                      unsigned int\n                        pixel;\n\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        p=PushLongPixel(MSBEndian,p,&pixel);\n                        SetPixelRed(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        p=PushLongPixel(MSBEndian,p,&pixel);\n                        SetPixelGreen(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        p=PushLongPixel(MSBEndian,p,&pixel);\n                        SetPixelBlue(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        SetPixelAlpha(image,OpaqueAlpha,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            p=PushLongPixel(MSBEndian,p,&pixel);\n                            SetPixelAlpha(image,ScaleAnyToQuantum(pixel,\n                              max_value),q);\n                          }\n                        q+=GetPixelChannels(image);\n                      }\n                    }\n                  break;\n                }\n              }\n            }\n          }\n          sync=SyncAuthenticPixels(image,exception);\n          if (sync == MagickFalse)\n            break;\n        }\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        SetQuantumImageType(image,quantum_type);\n        break;\n      }\n      case 'F':\n      case 'f':\n      {\n        /*\n          Convert PFM raster image to pixel packets.\n        */\n        if (format == 'f')\n          (void) SetImageColorspace(image,GRAYColorspace,exception);\n        quantum_type=format == 'f' ? GrayQuantum : RGBQuantum;\n        image->endian=quantum_scale < 0.0 ? LSBEndian : MSBEndian;\n        image->depth=32;\n        quantum_info=AcquireQuantumInfo(image_info,image);\n        if (quantum_info == (QuantumInfo *) NULL)\n          ThrowPNMException(ResourceLimitError,\"MemoryAllocationFailed\");\n        status=SetQuantumDepth(image,quantum_info,32);\n        if (status == MagickFalse)\n          ThrowPNMException(ResourceLimitError,\"MemoryAllocationFailed\");\n        status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n        if (status == MagickFalse)\n          ThrowPNMException(ResourceLimitError,\"MemoryAllocationFailed\");\n        SetQuantumScale(quantum_info,(double) QuantumRange*fabs(quantum_scale));\n        extent=GetQuantumExtent(image,quantum_info,quantum_type);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          const unsigned char\n            *pixels;\n\n          MagickBooleanType\n            sync;\n\n          register Quantum\n            *magick_restrict q;\n\n          ssize_t\n            offset;\n\n          size_t\n            length;\n\n          pixels=(unsigned char *) ReadBlobStream(image,extent,\n            GetQuantumPixels(quantum_info),&count);\n          if (count != (ssize_t) extent)\n            break;\n          if ((image->progress_monitor != (MagickProgressMonitor) NULL) &&\n              (image->previous == (Image *) NULL))\n            {\n              MagickBooleanType\n                proceed;\n\n              proceed=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                row,image->rows);\n              if (proceed == MagickFalse)\n                break;\n            }\n          offset=row++;\n          q=QueueAuthenticPixels(image,0,(ssize_t) (image->rows-offset-1),\n            image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          length=ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          if (length != extent)\n            break;\n          sync=SyncAuthenticPixels(image,exception);\n          if (sync == MagickFalse)\n            break;\n        }\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        SetQuantumImageType(image,quantum_type);\n        break;\n      }\n      default:\n        ThrowPNMException(CorruptImageError,\"ImproperImageHeader\");\n    }\n    if (*comment_info.comment != '\\0')\n      (void) SetImageProperty(image,\"comment\",comment_info.comment,exception);\n    comment_info.comment=DestroyString(comment_info.comment);\n    if (y < (ssize_t) image->rows)\n      ThrowPNMException(CorruptImageError,\"UnableToReadImageData\");\n    if (EOFBlob(image) != MagickFalse)\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          CorruptImageError,\"UnexpectedEndOfFile\",\"`%s'\",image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if ((format == '1') || (format == '2') || (format == '3'))\n      do\n      {\n        /*\n          Skip to end of line.\n        */\n        count=ReadBlob(image,1,(unsigned char *) &format);\n        if (count != 1)\n          break;\n        if (format == 'P')\n          break;\n      } while (format != '\\n');\n    count=ReadBlob(image,1,(unsigned char *) &format);\n    if ((count == 1) && (format == 'P'))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            status=MagickFalse;\n            break;\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((count == 1) && (format == 'P'));\n  (void) CloseBlob(image);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r P N M I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterPNMImage() adds properties for the PNM image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterPNMImage method is:\n%\n%      size_t RegisterPNMImage(void)\n%\n*/\nModuleExport size_t RegisterPNMImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"PNM\",\"PAM\",\"Common 2-dimensional bitmap format\");\n  entry->decoder=(DecodeImageHandler *) ReadPNMImage;\n  entry->encoder=(EncodeImageHandler *) WritePNMImage;\n  entry->mime_type=ConstantString(\"image/x-portable-pixmap\");\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PNM\",\"PBM\",\n    \"Portable bitmap format (black and white)\");\n  entry->decoder=(DecodeImageHandler *) ReadPNMImage;\n  entry->encoder=(EncodeImageHandler *) WritePNMImage;\n  entry->mime_type=ConstantString(\"image/x-portable-bitmap\");\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PNM\",\"PFM\",\"Portable float format\");\n  entry->decoder=(DecodeImageHandler *) ReadPNMImage;\n  entry->encoder=(EncodeImageHandler *) WritePNMImage;\n  entry->flags|=CoderEndianSupportFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PNM\",\"PGM\",\"Portable graymap format (gray scale)\");\n  entry->decoder=(DecodeImageHandler *) ReadPNMImage;\n  entry->encoder=(EncodeImageHandler *) WritePNMImage;\n  entry->mime_type=ConstantString(\"image/x-portable-greymap\");\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PNM\",\"PNM\",\"Portable anymap\");\n  entry->decoder=(DecodeImageHandler *) ReadPNMImage;\n  entry->encoder=(EncodeImageHandler *) WritePNMImage;\n  entry->magick=(IsImageFormatHandler *) IsPNM;\n  entry->mime_type=ConstantString(\"image/x-portable-pixmap\");\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PNM\",\"PPM\",\"Portable pixmap format (color)\");\n  entry->decoder=(DecodeImageHandler *) ReadPNMImage;\n  entry->encoder=(EncodeImageHandler *) WritePNMImage;\n  entry->mime_type=ConstantString(\"image/x-portable-pixmap\");\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r P N M I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterPNMImage() removes format registrations made by the\n%  PNM module from the list of supported formats.\n%\n%  The format of the UnregisterPNMImage method is:\n%\n%      UnregisterPNMImage(void)\n%\n*/\nModuleExport void UnregisterPNMImage(void)\n{\n  (void) UnregisterMagickInfo(\"PAM\");\n  (void) UnregisterMagickInfo(\"PBM\");\n  (void) UnregisterMagickInfo(\"PGM\");\n  (void) UnregisterMagickInfo(\"PNM\");\n  (void) UnregisterMagickInfo(\"PPM\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e P N M I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WritePNMImage() writes an image to a file in the PNM rasterfile format.\n%\n%  The format of the WritePNMImage method is:\n%\n%      MagickBooleanType WritePNMImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WritePNMImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  char\n    buffer[MagickPathExtent],\n    format,\n    magick[MagickPathExtent];\n\n  const char\n    *value;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  Quantum\n    index;\n\n  QuantumAny\n    pixel;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  register unsigned char\n    *q;\n\n  size_t\n    extent,\n    imageListLength,\n    packet_size;\n\n  ssize_t\n    count,\n    y;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  scene=0;\n  imageListLength=GetImageListLength(image);\n  do\n  {\n    QuantumAny\n      max_value;\n\n    /*\n      Write PNM file header.\n    */\n    packet_size=3;\n    quantum_type=RGBQuantum;\n    (void) CopyMagickString(magick,image_info->magick,MagickPathExtent);\n    max_value=GetQuantumRange(image->depth);\n    switch (magick[1])\n    {\n      case 'A':\n      case 'a':\n      {\n        format='7';\n        break;\n      }\n      case 'B':\n      case 'b':\n      {\n        format='4';\n        if (image_info->compression == NoCompression)\n          format='1';\n        break;\n      }\n      case 'F':\n      case 'f':\n      {\n        format='F';\n        if (SetImageGray(image,exception) != MagickFalse)\n          format='f';\n        break;\n      }\n      case 'G':\n      case 'g':\n      {\n        format='5';\n        if (image_info->compression == NoCompression)\n          format='2';\n        break;\n      }\n      case 'N':\n      case 'n':\n      {\n        if ((image_info->type != TrueColorType) &&\n            (SetImageGray(image,exception) != MagickFalse))\n          {\n            format='5';\n            if (image_info->compression == NoCompression)\n              format='2';\n            if (SetImageMonochrome(image,exception) != MagickFalse)\n              {\n                format='4';\n                if (image_info->compression == NoCompression)\n                  format='1';\n              }\n            break;\n          }\n      }\n      default:\n      {\n        format='6';\n        if (image_info->compression == NoCompression)\n          format='3';\n        break;\n      }\n    }\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"P%c\\n\",format);\n    (void) WriteBlobString(image,buffer);\n    value=GetImageProperty(image,\"comment\",exception);\n    if (value != (const char *) NULL)\n      {\n        register const char\n          *p;\n\n        /*\n          Write comments to file.\n        */\n        (void) WriteBlobByte(image,'#');\n        for (p=value; *p != '\\0'; p++)\n        {\n          (void) WriteBlobByte(image,(unsigned char) *p);\n          if ((*p == '\\n') || (*p == '\\r'))\n            (void) WriteBlobByte(image,'#');\n        }\n        (void) WriteBlobByte(image,'\\n');\n      }\n    if (format != '7')\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g %.20g\\n\",\n          (double) image->columns,(double) image->rows);\n        (void) WriteBlobString(image,buffer);\n      }\n    else\n      {\n        char\n          type[MagickPathExtent];\n\n        /*\n          PAM header.\n        */\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"WIDTH %.20g\\nHEIGHT %.20g\\n\",(double) image->columns,(double)\n          image->rows);\n        (void) WriteBlobString(image,buffer);\n        quantum_type=GetQuantumType(image,exception);\n        switch (quantum_type)\n        {\n          case CMYKQuantum:\n          case CMYKAQuantum:\n          {\n            packet_size=4;\n            (void) CopyMagickString(type,\"CMYK\",MagickPathExtent);\n            break;\n          }\n          case GrayQuantum:\n          case GrayAlphaQuantum:\n          {\n            packet_size=1;\n            (void) CopyMagickString(type,\"GRAYSCALE\",MagickPathExtent);\n            if (IdentifyImageMonochrome(image,exception) != MagickFalse)\n              (void) CopyMagickString(type,\"BLACKANDWHITE\",MagickPathExtent);\n            break;\n          }\n          default:\n          {\n            quantum_type=RGBQuantum;\n            if (image->alpha_trait != UndefinedPixelTrait)\n              quantum_type=RGBAQuantum;\n            packet_size=3;\n            (void) CopyMagickString(type,\"RGB\",MagickPathExtent);\n            break;\n          }\n        }\n        if (image->alpha_trait != UndefinedPixelTrait)\n          {\n            packet_size++;\n            (void) ConcatenateMagickString(type,\"_ALPHA\",MagickPathExtent);\n          }\n        if (image->depth > 32)\n          image->depth=32;\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"DEPTH %.20g\\nMAXVAL %.20g\\n\",(double) packet_size,(double)\n          ((MagickOffsetType) GetQuantumRange(image->depth)));\n        (void) WriteBlobString(image,buffer);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"TUPLTYPE %s\\nENDHDR\\n\",type);\n        (void) WriteBlobString(image,buffer);\n      }\n    /*\n      Convert runextent encoded to PNM raster pixels.\n    */\n    switch (format)\n    {\n      case '1':\n      {\n        unsigned char\n          pixels[2048];\n\n        /*\n          Convert image to a PBM image.\n        */\n        (void) SetImageType(image,BilevelType,exception);\n        q=pixels;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=(unsigned char) (GetPixelLuma(image,p) >= (QuantumRange/2.0) ?\n              '0' : '1');\n            *q++=' ';\n            if ((q-pixels+1) >= (ssize_t) sizeof(pixels))\n              {\n                *q++='\\n';\n                (void) WriteBlob(image,q-pixels,pixels);\n                q=pixels;\n              }\n            p+=GetPixelChannels(image);\n          }\n          *q++='\\n';\n          (void) WriteBlob(image,q-pixels,pixels);\n          q=pixels;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        if (q != pixels)\n          {\n            *q++='\\n';\n            (void) WriteBlob(image,q-pixels,pixels);\n          }\n        break;\n      }\n      case '2':\n      {\n        unsigned char\n          pixels[2048];\n\n        /*\n          Convert image to a PGM image.\n        */\n        if (image->depth <= 8)\n          (void) WriteBlobString(image,\"255\\n\");\n        else\n          if (image->depth <= 16)\n            (void) WriteBlobString(image,\"65535\\n\");\n          else\n            (void) WriteBlobString(image,\"4294967295\\n\");\n        q=pixels;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            index=ClampToQuantum(GetPixelLuma(image,p));\n            if (image->depth <= 8)\n              count=(ssize_t) FormatLocaleString(buffer,MagickPathExtent,\"%u \",\n                ScaleQuantumToChar(index));\n            else\n              if (image->depth <= 16)\n                count=(ssize_t) FormatLocaleString(buffer,MagickPathExtent,\n                  \"%u \",ScaleQuantumToShort(index));\n              else\n                count=(ssize_t) FormatLocaleString(buffer,MagickPathExtent,\n                  \"%u \",ScaleQuantumToLong(index));\n            extent=(size_t) count;\n            (void) strncpy((char *) q,buffer,extent);\n            q+=extent;\n            if ((q-pixels+extent+1) >= sizeof(pixels))\n              {\n                *q++='\\n';\n                (void) WriteBlob(image,q-pixels,pixels);\n                q=pixels;\n              }\n            p+=GetPixelChannels(image);\n          }\n          *q++='\\n';\n          (void) WriteBlob(image,q-pixels,pixels);\n          q=pixels;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        if (q != pixels)\n          {\n            *q++='\\n';\n            (void) WriteBlob(image,q-pixels,pixels);\n          }\n        break;\n      }\n      case '3':\n      {\n        unsigned char\n          pixels[2048];\n\n        /*\n          Convert image to a PNM image.\n        */\n        (void) TransformImageColorspace(image,sRGBColorspace,exception);\n        if (image->depth <= 8)\n          (void) WriteBlobString(image,\"255\\n\");\n        else\n          if (image->depth <= 16)\n            (void) WriteBlobString(image,\"65535\\n\");\n          else\n            (void) WriteBlobString(image,\"4294967295\\n\");\n        q=pixels;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            if (image->depth <= 8)\n              count=(ssize_t) FormatLocaleString(buffer,MagickPathExtent,\n                \"%u %u %u \",ScaleQuantumToChar(GetPixelRed(image,p)),\n                ScaleQuantumToChar(GetPixelGreen(image,p)),\n                ScaleQuantumToChar(GetPixelBlue(image,p)));\n            else\n              if (image->depth <= 16)\n                count=(ssize_t) FormatLocaleString(buffer,MagickPathExtent,\n                  \"%u %u %u \",ScaleQuantumToShort(GetPixelRed(image,p)),\n                  ScaleQuantumToShort(GetPixelGreen(image,p)),\n                  ScaleQuantumToShort(GetPixelBlue(image,p)));\n              else\n                count=(ssize_t) FormatLocaleString(buffer,MagickPathExtent,\n                  \"%u %u %u \",ScaleQuantumToLong(GetPixelRed(image,p)),\n                  ScaleQuantumToLong(GetPixelGreen(image,p)),\n                  ScaleQuantumToLong(GetPixelBlue(image,p)));\n            extent=(size_t) count;\n            (void) strncpy((char *) q,buffer,extent);\n            q+=extent;\n            if ((q-pixels+extent+1) >= sizeof(pixels))\n              {\n                *q++='\\n';\n                (void) WriteBlob(image,q-pixels,pixels);\n                q=pixels;\n              }\n            p+=GetPixelChannels(image);\n          }\n          *q++='\\n';\n          (void) WriteBlob(image,q-pixels,pixels);\n          q=pixels;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        if (q != pixels)\n          {\n            *q++='\\n';\n            (void) WriteBlob(image,q-pixels,pixels);\n          }\n        break;\n      }\n      case '4':\n      {\n        register unsigned char\n          *pixels;\n\n        /*\n          Convert image to a PBM image.\n        */\n        (void) SetImageType(image,BilevelType,exception);\n        image->depth=1;\n        quantum_info=AcquireQuantumInfo(image_info,image);\n        if (quantum_info == (QuantumInfo *) NULL)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) SetQuantumEndian(image,quantum_info,MSBEndian);\n        quantum_info->min_is_white=MagickTrue;\n        pixels=GetQuantumPixels(quantum_info);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          extent=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            GrayQuantum,pixels,exception);\n          count=WriteBlob(image,extent,pixels);\n          if (count != (ssize_t) extent)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        break;\n      }\n      case '5':\n      {\n        register unsigned char\n          *pixels;\n\n        /*\n          Convert image to a PGM image.\n        */\n        if (image->depth > 32)\n          image->depth=32;\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g\\n\",(double)\n          ((MagickOffsetType) GetQuantumRange(image->depth)));\n        (void) WriteBlobString(image,buffer);\n        quantum_info=AcquireQuantumInfo(image_info,image);\n        if (quantum_info == (QuantumInfo *) NULL)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) SetQuantumEndian(image,quantum_info,MSBEndian);\n        quantum_info->min_is_white=MagickTrue;\n        pixels=GetQuantumPixels(quantum_info);\n        extent=GetQuantumExtent(image,quantum_info,GrayQuantum);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels;\n          switch (image->depth)\n          {\n            case 8:\n            case 16:\n            case 32:\n            {\n              extent=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                GrayQuantum,pixels,exception);\n              break;\n            }\n            default:\n            {\n              if (image->depth <= 8)\n                {\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    if (IsPixelGray(image,p) == MagickFalse)\n                      pixel=ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(\n                        image,p)),max_value);\n                    else\n                      {\n                        if (image->depth == 8)\n                          pixel=ScaleQuantumToChar(GetPixelRed(image,p));\n                        else\n                          pixel=ScaleQuantumToAny(GetPixelRed(image,p),\n                            max_value);\n                      }\n                    q=PopCharPixel((unsigned char) pixel,q);\n                    p+=GetPixelChannels(image);\n                  }\n                  extent=(size_t) (q-pixels);\n                  break;\n                }\n              if (image->depth <= 16)\n                {\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    if (IsPixelGray(image,p) == MagickFalse)\n                      pixel=ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(image,\n                        p)),max_value);\n                    else\n                      {\n                        if (image->depth == 16)\n                          pixel=ScaleQuantumToShort(GetPixelRed(image,p));\n                        else\n                          pixel=ScaleQuantumToAny(GetPixelRed(image,p),\n                            max_value);\n                      }\n                    q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                    p+=GetPixelChannels(image);\n                  }\n                  extent=(size_t) (q-pixels);\n                  break;\n                }\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                if (IsPixelGray(image,p) == MagickFalse)\n                  pixel=ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(image,p)),\n                    max_value);\n                else\n                  {\n                    if (image->depth == 16)\n                      pixel=ScaleQuantumToLong(GetPixelRed(image,p));\n                    else\n                      pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);\n                  }\n                q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                p+=GetPixelChannels(image);\n              }\n              extent=(size_t) (q-pixels);\n              break;\n            }\n          }\n          count=WriteBlob(image,extent,pixels);\n          if (count != (ssize_t) extent)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        break;\n      }\n      case '6':\n      {\n        register unsigned char\n          *pixels;\n\n        /*\n          Convert image to a PNM image.\n        */\n        (void) TransformImageColorspace(image,sRGBColorspace,exception);\n        if (image->depth > 32)\n          image->depth=32;\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g\\n\",(double)\n          ((MagickOffsetType) GetQuantumRange(image->depth)));\n        (void) WriteBlobString(image,buffer);\n        quantum_info=AcquireQuantumInfo(image_info,image);\n        if (quantum_info == (QuantumInfo *) NULL)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) SetQuantumEndian(image,quantum_info,MSBEndian);\n        pixels=GetQuantumPixels(quantum_info);\n        extent=GetQuantumExtent(image,quantum_info,quantum_type);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels;\n          switch (image->depth)\n          {\n            case 8:\n            case 16:\n            case 32:\n            {\n              extent=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                quantum_type,pixels,exception);\n              break;\n            }\n            default:\n            {\n              if (image->depth <= 8)\n                {\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);\n                    q=PopCharPixel((unsigned char) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelGreen(image,p),max_value);\n                    q=PopCharPixel((unsigned char) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelBlue(image,p),max_value);\n                    q=PopCharPixel((unsigned char) pixel,q);\n                    p+=GetPixelChannels(image);\n                  }\n                  extent=(size_t) (q-pixels);\n                  break;\n                }\n              if (image->depth <= 16)\n                {\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);\n                    q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelGreen(image,p),max_value);\n                    q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelBlue(image,p),max_value);\n                    q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                    p+=GetPixelChannels(image);\n                  }\n                  extent=(size_t) (q-pixels);\n                  break;\n                }\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);\n                q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                pixel=ScaleQuantumToAny(GetPixelGreen(image,p),max_value);\n                q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                pixel=ScaleQuantumToAny(GetPixelBlue(image,p),max_value);\n                q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                p+=GetPixelChannels(image);\n              }\n              extent=(size_t) (q-pixels);\n              break;\n            }\n          }\n          count=WriteBlob(image,extent,pixels);\n          if (count != (ssize_t) extent)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        break;\n      }\n      case '7':\n      {\n        register unsigned char\n          *pixels;\n\n        /*\n          Convert image to a PAM.\n        */\n        if (image->depth > 32)\n          image->depth=32;\n        quantum_info=AcquireQuantumInfo(image_info,image);\n        if (quantum_info == (QuantumInfo *) NULL)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) SetQuantumEndian(image,quantum_info,MSBEndian);\n        pixels=GetQuantumPixels(quantum_info);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels;\n          switch (image->depth)\n          {\n            case 8:\n            case 16:\n            case 32:\n            {\n              extent=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                quantum_type,pixels,exception);\n              break;\n            }\n            default:\n            {\n              switch (quantum_type)\n              {\n                case GrayQuantum:\n                case GrayAlphaQuantum:\n                {\n                  if (image->depth <= 8)\n                    {\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        pixel=ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(\n                          image,p)),max_value);\n                        q=PopCharPixel((unsigned char) pixel,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            pixel=(unsigned char) ScaleQuantumToAny(\n                              GetPixelAlpha(image,p),max_value);\n                            q=PopCharPixel((unsigned char) pixel,q);\n                          }\n                        p+=GetPixelChannels(image);\n                      }\n                      break;\n                    }\n                  if (image->depth <= 16)\n                    {\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        pixel=ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(\n                          image,p)),max_value);\n                        q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            pixel=(unsigned char) ScaleQuantumToAny(\n                              GetPixelAlpha(image,p),max_value);\n                            q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                          }\n                        p+=GetPixelChannels(image);\n                      }\n                      break;\n                    }\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    pixel=ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(image,\n                      p)),max_value);\n                    q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                    if (image->alpha_trait != UndefinedPixelTrait)\n                      {\n                        pixel=(unsigned char) ScaleQuantumToAny(\n                          GetPixelAlpha(image,p),max_value);\n                        q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                      }\n                    p+=GetPixelChannels(image);\n                  }\n                  break;\n                }\n                case CMYKQuantum:\n                case CMYKAQuantum:\n                {\n                  if (image->depth <= 8)\n                    {\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);\n                        q=PopCharPixel((unsigned char) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelGreen(image,p),\n                          max_value);\n                        q=PopCharPixel((unsigned char) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelBlue(image,p),\n                          max_value);\n                        q=PopCharPixel((unsigned char) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelBlack(image,p),\n                          max_value);\n                        q=PopCharPixel((unsigned char) pixel,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            pixel=ScaleQuantumToAny(GetPixelAlpha(image,p),\n                              max_value);\n                            q=PopCharPixel((unsigned char) pixel,q);\n                          }\n                        p+=GetPixelChannels(image);\n                      }\n                      break;\n                    }\n                  if (image->depth <= 16)\n                    {\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);\n                        q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelGreen(image,p),\n                          max_value);\n                        q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelBlue(image,p),\n                          max_value);\n                        q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelBlack(image,p),\n                          max_value);\n                        q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            pixel=ScaleQuantumToAny(GetPixelAlpha(image,p),\n                              max_value);\n                            q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                          }\n                        p+=GetPixelChannels(image);\n                      }\n                      break;\n                    }\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);\n                    q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelGreen(image,p),max_value);\n                    q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelBlue(image,p),max_value);\n                    q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelBlack(image,p),max_value);\n                    q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                    if (image->alpha_trait != UndefinedPixelTrait)\n                      {\n                        pixel=ScaleQuantumToAny(GetPixelAlpha(image,p),\n                          max_value);\n                        q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                      }\n                    p+=GetPixelChannels(image);\n                  }\n                  break;\n                }\n                default:\n                {\n                  if (image->depth <= 8)\n                    {\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);\n                        q=PopCharPixel((unsigned char) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelGreen(image,p),\n                          max_value);\n                        q=PopCharPixel((unsigned char) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelBlue(image,p),\n                          max_value);\n                        q=PopCharPixel((unsigned char) pixel,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            pixel=ScaleQuantumToAny(GetPixelAlpha(image,p),\n                              max_value);\n                            q=PopCharPixel((unsigned char) pixel,q);\n                          }\n                        p+=GetPixelChannels(image);\n                      }\n                      break;\n                    }\n                  if (image->depth <= 16)\n                    {\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);\n                        q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelGreen(image,p),\n                          max_value);\n                        q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelBlue(image,p),\n                          max_value);\n                        q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            pixel=ScaleQuantumToAny(GetPixelAlpha(image,p),\n                              max_value);\n                            q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                          }\n                        p+=GetPixelChannels(image);\n                      }\n                      break;\n                    }\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);\n                    q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelGreen(image,p),max_value);\n                    q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelBlue(image,p),max_value);\n                    q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                    if (image->alpha_trait != UndefinedPixelTrait)\n                      {\n                        pixel=ScaleQuantumToAny(GetPixelAlpha(image,p),\n                          max_value);\n                        q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                      }\n                    p+=GetPixelChannels(image);\n                  }\n                  break;\n                }\n              }\n              extent=(size_t) (q-pixels);\n              break;\n            }\n          }\n          count=WriteBlob(image,extent,pixels);\n          if (count != (ssize_t) extent)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        break;\n      }\n      case 'F':\n      case 'f':\n      {\n        register unsigned char\n          *pixels;\n\n        (void) WriteBlobString(image,image->endian == LSBEndian ? \"-1.0\\n\" :\n          \"1.0\\n\");\n        image->depth=32;\n        quantum_type=format == 'f' ? GrayQuantum : RGBQuantum;\n        quantum_info=AcquireQuantumInfo(image_info,image);\n        if (quantum_info == (QuantumInfo *) NULL)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n        if (status == MagickFalse)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        pixels=GetQuantumPixels(quantum_info);\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          extent=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          (void) WriteBlob(image,extent,pixels);\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        break;\n      }\n    }\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,imageListLength);\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            PPPP   N   N  M   M                              %\n%                            P   P  NN  N  MM MM                              %\n%                            PPPP   N N N  M M M                              %\n%                            P      N  NN  M   M                              %\n%                            P      N   N  M   M                              %\n%                                                                             %\n%                                                                             %\n%               Read/Write PBMPlus Portable Anymap Image Format               %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n\f\n/*\n  Typedef declarations.\n*/\ntypedef struct _CommentInfo\n{\n  char\n    *comment;\n\n  size_t\n    extent;\n} CommentInfo;\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WritePNMImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s P N M                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsPNM() returns MagickTrue if the image format type, identified by the\n%  magick string, is PNM.\n%\n%  The format of the IsPNM method is:\n%\n%      MagickBooleanType IsPNM(const unsigned char *magick,const size_t extent)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o extent: Specifies the extent of the magick string.\n%\n*/\nstatic MagickBooleanType IsPNM(const unsigned char *magick,const size_t extent)\n{\n  if (extent < 2)\n    return(MagickFalse);\n  if ((*magick == (unsigned char) 'P') &&\n      ((magick[1] == '1') || (magick[1] == '2') || (magick[1] == '3') ||\n       (magick[1] == '4') || (magick[1] == '5') || (magick[1] == '6') ||\n       (magick[1] == '7') || (magick[1] == 'F') || (magick[1] == 'f')))\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d P N M I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadPNMImage() reads a Portable Anymap image file and returns it.\n%  It allocates the memory necessary for the new Image structure and returns\n%  a pointer to the new image.\n%\n%  The format of the ReadPNMImage method is:\n%\n%      Image *ReadPNMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic int PNMComment(Image *image,CommentInfo *comment_info,\n  ExceptionInfo *exception)\n{\n  int\n    c;\n\n  register char\n    *p;\n\n  /*\n    Read comment.\n  */\n  p=comment_info->comment+strlen(comment_info->comment);\n  for (c='#'; (c != EOF) && (c != (int) '\\n') && (c != (int) '\\r'); p++)\n  {\n    if ((size_t) (p-comment_info->comment+1) >= comment_info->extent)\n      {\n        comment_info->extent<<=1;\n        comment_info->comment=(char *) ResizeQuantumMemory(\n          comment_info->comment,comment_info->extent,\n          sizeof(*comment_info->comment));\n        if (comment_info->comment == (char *) NULL)\n          return(-1);\n        p=comment_info->comment+strlen(comment_info->comment);\n      }\n    c=ReadBlobByte(image);\n    if (c != EOF)\n      {\n        *p=(char) c;\n        *(p+1)='\\0';\n      }\n  }\n  return(c);\n}\n\nstatic unsigned int PNMInteger(Image *image,CommentInfo *comment_info,\n  const unsigned int base,ExceptionInfo *exception)\n{\n  int\n    c;\n\n  unsigned int\n    value;\n\n  /*\n    Skip any leading whitespace.\n  */\n  do\n  {\n    c=ReadBlobByte(image);\n    if (c == EOF)\n      return(0);\n    if (c == (int) '#')\n      c=PNMComment(image,comment_info,exception);\n  } while ((c == ' ') || (c == '\\t') || (c == '\\n') || (c == '\\r'));\n  if (base == 2)\n    return((unsigned int) (c-(int) '0'));\n  /*\n    Evaluate number.\n  */\n  value=0;\n  while (isdigit(c) != 0)\n  {\n    if (value <= (unsigned int) (INT_MAX/10))\n      {\n        value*=10;\n        if (value <= (unsigned int) (INT_MAX-(c-(int) '0')))\n          value+=c-(int) '0';\n      }\n    c=ReadBlobByte(image);\n    if (c == EOF)\n      return(0);\n  }\n  if (c == (int) '#')\n    c=PNMComment(image,comment_info,exception);\n  return(value);\n}\n\nstatic Image *ReadPNMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define ThrowPNMException(exception,message) \\\n{ \\\n  if (comment_info.comment != (char *) NULL)  \\\n    comment_info.comment=DestroyString(comment_info.comment); \\\n  ThrowReaderException((exception),(message)); \\\n}\n\n  char\n    format;\n\n  CommentInfo\n    comment_info;\n\n  double\n    quantum_scale;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  QuantumAny\n    max_value;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  size_t\n    depth,\n    extent,\n    packet_size;\n\n  ssize_t\n    count,\n    row,\n    y;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read PNM image.\n  */\n  count=ReadBlob(image,1,(unsigned char *) &format);\n  do\n  {\n    /*\n      Initialize image structure.\n    */\n    comment_info.comment=AcquireString(NULL);\n    comment_info.extent=MagickPathExtent;\n    if ((count != 1) || (format != 'P'))\n      ThrowPNMException(CorruptImageError,\"ImproperImageHeader\");\n    max_value=1;\n    quantum_type=RGBQuantum;\n    quantum_scale=1.0;\n    format=(char) ReadBlobByte(image);\n    if (format != '7')\n      {\n        /*\n          PBM, PGM, PPM, and PNM.\n        */\n        image->columns=(size_t) PNMInteger(image,&comment_info,10,exception);\n        image->rows=(size_t) PNMInteger(image,&comment_info,10,exception);\n        if ((format == 'f') || (format == 'F'))\n          {\n            char\n              scale[MagickPathExtent];\n\n            if (ReadBlobString(image,scale) != (char *) NULL)\n              quantum_scale=StringToDouble(scale,(char **) NULL);\n          }\n        else\n          {\n            if ((format == '1') || (format == '4'))\n              max_value=1;  /* bitmap */\n            else\n              max_value=(QuantumAny) PNMInteger(image,&comment_info,10,\n                exception);\n          }\n      }\n    else\n      {\n        char\n          keyword[MagickPathExtent],\n          value[MagickPathExtent];\n\n        int\n          c;\n\n        register char\n          *p;\n\n        /*\n          PAM.\n        */\n        for (c=ReadBlobByte(image); c != EOF; c=ReadBlobByte(image))\n        {\n          while (isspace((int) ((unsigned char) c)) != 0)\n            c=ReadBlobByte(image);\n          if (c == '#')\n            {\n              /*\n                Comment.\n              */\n              c=PNMComment(image,&comment_info,exception);\n              c=ReadBlobByte(image);\n              while (isspace((int) ((unsigned char) c)) != 0)\n                c=ReadBlobByte(image);\n            }\n          p=keyword;\n          do\n          {\n            if ((size_t) (p-keyword) < (MagickPathExtent-1))\n              *p++=c;\n            c=ReadBlobByte(image);\n          } while (isalnum(c));\n          *p='\\0';\n          if (LocaleCompare(keyword,\"endhdr\") == 0)\n            break;\n          while (isspace((int) ((unsigned char) c)) != 0)\n            c=ReadBlobByte(image);\n          p=value;\n          while (isalnum(c) || (c == '_'))\n          {\n            if ((size_t) (p-value) < (MagickPathExtent-1))\n              *p++=c;\n            c=ReadBlobByte(image);\n          }\n          *p='\\0';\n          /*\n            Assign a value to the specified keyword.\n          */\n          if (LocaleCompare(keyword,\"depth\") == 0)\n            packet_size=StringToUnsignedLong(value);\n          (void) packet_size;\n          if (LocaleCompare(keyword,\"height\") == 0)\n            image->rows=StringToUnsignedLong(value);\n          if (LocaleCompare(keyword,\"maxval\") == 0)\n            max_value=StringToUnsignedLong(value);\n          if (LocaleCompare(keyword,\"TUPLTYPE\") == 0)\n            {\n              if (LocaleCompare(value,\"BLACKANDWHITE\") == 0)\n                {\n                  (void) SetImageColorspace(image,GRAYColorspace,exception);\n                  quantum_type=GrayQuantum;\n                }\n              if (LocaleCompare(value,\"BLACKANDWHITE_ALPHA\") == 0)\n                {\n                  (void) SetImageColorspace(image,GRAYColorspace,exception);\n                  image->alpha_trait=BlendPixelTrait;\n                  quantum_type=GrayAlphaQuantum;\n                }\n              if (LocaleCompare(value,\"GRAYSCALE\") == 0)\n                {\n                  quantum_type=GrayQuantum;\n                  (void) SetImageColorspace(image,GRAYColorspace,exception);\n                }\n              if (LocaleCompare(value,\"GRAYSCALE_ALPHA\") == 0)\n                {\n                  (void) SetImageColorspace(image,GRAYColorspace,exception);\n                  image->alpha_trait=BlendPixelTrait;\n                  quantum_type=GrayAlphaQuantum;\n                }\n              if (LocaleCompare(value,\"RGB_ALPHA\") == 0)\n                {\n                  image->alpha_trait=BlendPixelTrait;\n                  quantum_type=RGBAQuantum;\n                }\n              if (LocaleCompare(value,\"CMYK\") == 0)\n                {\n                  (void) SetImageColorspace(image,CMYKColorspace,exception);\n                  quantum_type=CMYKQuantum;\n                }\n              if (LocaleCompare(value,\"CMYK_ALPHA\") == 0)\n                {\n                  (void) SetImageColorspace(image,CMYKColorspace,exception);\n                  image->alpha_trait=BlendPixelTrait;\n                  quantum_type=CMYKAQuantum;\n                }\n            }\n          if (LocaleCompare(keyword,\"width\") == 0)\n            image->columns=StringToUnsignedLong(value);\n        }\n      }\n    if ((image->columns == 0) || (image->rows == 0))\n      ThrowPNMException(CorruptImageError,\"NegativeOrZeroImageSize\");\n    if ((max_value == 0) || (max_value > 4294967295UL))\n      ThrowPNMException(CorruptImageError,\"ImproperImageHeader\");\n    for (depth=1; GetQuantumRange(depth) < max_value; depth++) ;\n    image->depth=depth;\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if ((MagickSizeType) (image->columns*image->rows/8) > GetBlobSize(image))\n      ThrowPNMException(CorruptImageError,\"InsufficientImageDataInFile\");\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      {\n        comment_info.comment=DestroyString(comment_info.comment); \\\n        return(DestroyImageList(image));\n      }\n    (void) ResetImagePixels(image,exception);\n    /*\n      Convert PNM pixels to runextent-encoded MIFF packets.\n    */\n    row=0;\n    y=0;\n    switch (format)\n    {\n      case '1':\n      {\n        /*\n          Convert PBM image to pixel packets.\n        */\n        (void) SetImageColorspace(image,GRAYColorspace,exception);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register ssize_t\n            x;\n\n          register Quantum\n            *magick_restrict q;\n\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelGray(image,PNMInteger(image,&comment_info,2,exception) ==\n              0 ? QuantumRange : 0,q);\n            if (EOFBlob(image) != MagickFalse)\n              break;\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n          if (EOFBlob(image) != MagickFalse)\n            break;\n        }\n        image->type=BilevelType;\n        break;\n      }\n      case '2':\n      {\n        Quantum\n          intensity;\n\n        /*\n          Convert PGM image to pixel packets.\n        */\n        (void) SetImageColorspace(image,GRAYColorspace,exception);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register ssize_t\n            x;\n\n          register Quantum\n            *magick_restrict q;\n\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            intensity=ScaleAnyToQuantum(PNMInteger(image,&comment_info,10,\n              exception),max_value);\n            if (EOFBlob(image) != MagickFalse)\n              break;\n            SetPixelGray(image,intensity,q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n          if (EOFBlob(image) != MagickFalse)\n            break;\n        }\n        image->type=GrayscaleType;\n        break;\n      }\n      case '3':\n      {\n        /*\n          Convert PNM image to pixel packets.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register ssize_t\n            x;\n\n          register Quantum\n            *magick_restrict q;\n\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            Quantum\n              pixel;\n\n            pixel=ScaleAnyToQuantum(PNMInteger(image,&comment_info,10,\n              exception),max_value);\n            if (EOFBlob(image) != MagickFalse)\n              break;\n            SetPixelRed(image,pixel,q);\n            pixel=ScaleAnyToQuantum(PNMInteger(image,&comment_info,10,\n              exception),max_value);\n            SetPixelGreen(image,pixel,q);\n            pixel=ScaleAnyToQuantum(PNMInteger(image,&comment_info,10,\n              exception),max_value);\n            SetPixelBlue(image,pixel,q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n          if (EOFBlob(image) != MagickFalse)\n            break;\n        }\n        break;\n      }\n      case '4':\n      {\n        /*\n          Convert PBM raw image to pixel packets.\n        */\n        (void) SetImageColorspace(image,GRAYColorspace,exception);\n        quantum_type=GrayQuantum;\n        if (image->storage_class == PseudoClass)\n          quantum_type=IndexQuantum;\n        quantum_info=AcquireQuantumInfo(image_info,image);\n        if (quantum_info == (QuantumInfo *) NULL)\n          ThrowPNMException(ResourceLimitError,\"MemoryAllocationFailed\");\n        SetQuantumMinIsWhite(quantum_info,MagickTrue);\n        extent=GetQuantumExtent(image,quantum_info,quantum_type);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          const unsigned char\n            *pixels;\n\n          MagickBooleanType\n            sync;\n\n          register Quantum\n            *magick_restrict q;\n\n          ssize_t\n            offset;\n\n          size_t\n            length;\n\n          pixels=(unsigned char *) ReadBlobStream(image,extent,\n            GetQuantumPixels(quantum_info),&count);\n          if (count != (ssize_t) extent)\n            break;\n          if ((image->progress_monitor != (MagickProgressMonitor) NULL) &&\n              (image->previous == (Image *) NULL))\n            {\n              MagickBooleanType\n                proceed;\n\n              proceed=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                row,image->rows);\n              if (proceed == MagickFalse)\n                break;\n            }\n          offset=row++;\n          q=QueueAuthenticPixels(image,0,offset,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          length=ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          if (length != extent)\n            break;\n          sync=SyncAuthenticPixels(image,exception);\n          if (sync == MagickFalse)\n            break;\n        }\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        SetQuantumImageType(image,quantum_type);\n        break;\n      }\n      case '5':\n      {\n        /*\n          Convert PGM raw image to pixel packets.\n        */\n        (void) SetImageColorspace(image,GRAYColorspace,exception);\n        quantum_type=GrayQuantum;\n        extent=(image->depth <= 8 ? 1 : image->depth <= 16 ? 2 : 4)*\n          image->columns;\n        quantum_info=AcquireQuantumInfo(image_info,image);\n        if (quantum_info == (QuantumInfo *) NULL)\n          ThrowPNMException(ResourceLimitError,\"MemoryAllocationFailed\");\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          const unsigned char\n            *pixels;\n\n          MagickBooleanType\n            sync;\n\n          register const unsigned char\n            *magick_restrict p;\n\n          register ssize_t\n            x;\n\n          register Quantum\n            *magick_restrict q;\n\n          ssize_t\n            offset;\n\n          pixels=(unsigned char *) ReadBlobStream(image,extent,\n            GetQuantumPixels(quantum_info),&count);\n          if (count != (ssize_t) extent)\n            break;\n          if ((image->progress_monitor != (MagickProgressMonitor) NULL) &&\n              (image->previous == (Image *) NULL))\n            {\n              MagickBooleanType\n                proceed;\n\n              proceed=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                row,image->rows);\n              if (proceed == MagickFalse)\n                break;\n            }\n          offset=row++;\n          q=QueueAuthenticPixels(image,0,offset,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          p=pixels;\n          switch (image->depth)\n          {\n            case 8:\n            case 16:\n            case 32:\n            {\n              (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                quantum_type,pixels,exception);\n              break;\n            }\n            default:\n            {\n              if (image->depth <= 8)\n                {\n                  unsigned char\n                    pixel;\n\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    p=PushCharPixel(p,&pixel);\n                    SetPixelGray(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    q+=GetPixelChannels(image);\n                  }\n                }\n              else if (image->depth <= 16)\n                {\n                  unsigned short\n                    pixel;\n\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    p=PushShortPixel(MSBEndian,p,&pixel);\n                    SetPixelGray(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    q+=GetPixelChannels(image);\n                  }\n                }\n              else\n                {\n                  unsigned int\n                    pixel;\n\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    p=PushLongPixel(MSBEndian,p,&pixel);\n                    SetPixelGray(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    q+=GetPixelChannels(image);\n                  }\n                }\n              break;\n            }\n          }\n          sync=SyncAuthenticPixels(image,exception);\n          if (sync == MagickFalse)\n            break;\n        }\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        SetQuantumImageType(image,quantum_type);\n        break;\n      }\n      case '6':\n      {\n        /*\n          Convert PNM raster image to pixel packets.\n        */\n        quantum_type=RGBQuantum;\n        extent=3*(image->depth <= 8 ? 1 : image->depth <= 16 ? 2 : 4)*\n          image->columns;\n        quantum_info=AcquireQuantumInfo(image_info,image);\n        if (quantum_info == (QuantumInfo *) NULL)\n          ThrowPNMException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) SetQuantumEndian(image,quantum_info,MSBEndian);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          const unsigned char\n            *pixels;\n\n          MagickBooleanType\n            sync;\n\n          register const unsigned char\n            *magick_restrict p;\n\n          register ssize_t\n            x;\n\n          register Quantum\n            *magick_restrict q;\n\n          ssize_t\n            offset;\n\n          pixels=(unsigned char *) ReadBlobStream(image,extent,\n            GetQuantumPixels(quantum_info),&count);\n          if (count != (ssize_t) extent)\n            break;\n          if ((image->progress_monitor != (MagickProgressMonitor) NULL) &&\n              (image->previous == (Image *) NULL))\n            {\n              MagickBooleanType\n                proceed;\n\n              proceed=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                row,image->rows);\n              if (proceed == MagickFalse)\n                break;\n            }\n          offset=row++;\n          q=QueueAuthenticPixels(image,0,offset,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          p=pixels;\n          switch (image->depth)\n          {\n            case 8:\n            {\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n                SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n                SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n                SetPixelAlpha(image,OpaqueAlpha,q);\n                q+=GetPixelChannels(image);\n              }\n              break;\n            }\n            case 16:\n            {\n              unsigned short\n                pixel;\n\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                p=PushShortPixel(MSBEndian,p,&pixel);\n                SetPixelRed(image,ScaleShortToQuantum(pixel),q);\n                p=PushShortPixel(MSBEndian,p,&pixel);\n                SetPixelGreen(image,ScaleShortToQuantum(pixel),q);\n                p=PushShortPixel(MSBEndian,p,&pixel);\n                SetPixelBlue(image,ScaleShortToQuantum(pixel),q);\n                SetPixelAlpha(image,OpaqueAlpha,q);\n                q+=GetPixelChannels(image);\n              }\n              break;\n            }\n            case 32:\n            {\n              unsigned int\n                pixel;\n\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                p=PushLongPixel(MSBEndian,p,&pixel);\n                SetPixelRed(image,ScaleLongToQuantum(pixel),q);\n                p=PushLongPixel(MSBEndian,p,&pixel);\n                SetPixelGreen(image,ScaleLongToQuantum(pixel),q);\n                p=PushLongPixel(MSBEndian,p,&pixel);\n                SetPixelBlue(image,ScaleLongToQuantum(pixel),q);\n                SetPixelAlpha(image,OpaqueAlpha,q);\n                q+=GetPixelChannels(image);\n              }\n              break;\n            }\n            default:\n            {\n              if (image->depth <= 8)\n                {\n                  unsigned char\n                    pixel;\n\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    p=PushCharPixel(p,&pixel);\n                    SetPixelRed(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    p=PushCharPixel(p,&pixel);\n                    SetPixelGreen(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    p=PushCharPixel(p,&pixel);\n                    SetPixelBlue(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    SetPixelAlpha(image,OpaqueAlpha,q);\n                    q+=GetPixelChannels(image);\n                  }\n                }\n              else if (image->depth <= 16)\n                {\n                  unsigned short\n                    pixel;\n\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    p=PushShortPixel(MSBEndian,p,&pixel);\n                    SetPixelRed(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    p=PushShortPixel(MSBEndian,p,&pixel);\n                    SetPixelGreen(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    p=PushShortPixel(MSBEndian,p,&pixel);\n                    SetPixelBlue(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    SetPixelAlpha(image,OpaqueAlpha,q);\n                    q+=GetPixelChannels(image);\n                  }\n                }\n              else\n                {\n                  unsigned int\n                    pixel;\n\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    p=PushLongPixel(MSBEndian,p,&pixel);\n                    SetPixelRed(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    p=PushLongPixel(MSBEndian,p,&pixel);\n                    SetPixelGreen(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    p=PushLongPixel(MSBEndian,p,&pixel);\n                    SetPixelBlue(image,ScaleAnyToQuantum(pixel,max_value),q);\n                    SetPixelAlpha(image,OpaqueAlpha,q);\n                    q+=GetPixelChannels(image);\n                  }\n                }\n              break;\n            }\n          }\n          sync=SyncAuthenticPixels(image,exception);\n          if (sync == MagickFalse)\n            break;\n        }\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        break;\n      }\n      case '7':\n      {\n        size_t\n          channels;\n\n        /*\n          Convert PAM raster image to pixel packets.\n        */\n        switch (quantum_type)\n        {\n          case GrayQuantum:\n          case GrayAlphaQuantum:\n          {\n            channels=1;\n            break;\n          }\n          case CMYKQuantum:\n          case CMYKAQuantum:\n          {\n            channels=4;\n            break;\n          }\n          default:\n          {\n            channels=3;\n            break;\n          }\n        }\n        if (image->alpha_trait != UndefinedPixelTrait)\n          channels++;\n        extent=channels*(image->depth <= 8 ? 1 : image->depth <= 16 ? 2 : 4)*\n          image->columns;\n        quantum_info=AcquireQuantumInfo(image_info,image);\n        if (quantum_info == (QuantumInfo *) NULL)\n          ThrowPNMException(ResourceLimitError,\"MemoryAllocationFailed\");\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          const unsigned char\n            *pixels;\n\n          MagickBooleanType\n            sync;\n\n          register const unsigned char\n            *magick_restrict p;\n\n          register ssize_t\n            x;\n\n          register Quantum\n            *magick_restrict q;\n\n          ssize_t\n            offset;\n\n          pixels=(unsigned char *) ReadBlobStream(image,extent,\n            GetQuantumPixels(quantum_info),&count);\n          if (count != (ssize_t) extent)\n            break;\n          if ((image->progress_monitor != (MagickProgressMonitor) NULL) &&\n              (image->previous == (Image *) NULL))\n            {\n              MagickBooleanType\n                proceed;\n\n              proceed=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                row,image->rows);\n              if (proceed == MagickFalse)\n                break;\n            }\n          offset=row++;\n          q=QueueAuthenticPixels(image,0,offset,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          p=pixels;\n          switch (image->depth)\n          {\n            case 8:\n            case 16:\n            case 32:\n            {\n              (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                quantum_type,pixels,exception);\n              break;\n            }\n            default:\n            {\n              switch (quantum_type)\n              {\n                case GrayQuantum:\n                case GrayAlphaQuantum:\n                {\n                  if (image->depth <= 8)\n                    {\n                      unsigned char\n                        pixel;\n\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        p=PushCharPixel(p,&pixel);\n                        SetPixelGray(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        SetPixelAlpha(image,OpaqueAlpha,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            p=PushCharPixel(p,&pixel);\n                            if (image->depth != 1)\n                              SetPixelAlpha(image,ScaleAnyToQuantum(pixel,\n                                max_value),q);\n                            else\n                              SetPixelAlpha(image,QuantumRange-\n                                ScaleAnyToQuantum(pixel,max_value),q);\n                          }\n                        q+=GetPixelChannels(image);\n                      }\n                    }\n                  else if (image->depth <= 16)\n                    {\n                      unsigned short\n                        pixel;\n\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        p=PushShortPixel(MSBEndian,p,&pixel);\n                        SetPixelGray(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        SetPixelAlpha(image,OpaqueAlpha,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            p=PushShortPixel(MSBEndian,p,&pixel);\n                            SetPixelAlpha(image,ScaleAnyToQuantum(pixel,\n                              max_value),q);\n                          }\n                        q+=GetPixelChannels(image);\n                      }\n                    }\n                  else\n                    {\n                      unsigned int\n                        pixel;\n\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        p=PushLongPixel(MSBEndian,p,&pixel);\n                        SetPixelGray(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        SetPixelAlpha(image,OpaqueAlpha,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            p=PushLongPixel(MSBEndian,p,&pixel);\n                            SetPixelAlpha(image,ScaleAnyToQuantum(pixel,\n                              max_value),q);\n                          }\n                        q+=GetPixelChannels(image);\n                      }\n                    }\n                  break;\n                }\n                case CMYKQuantum:\n                case CMYKAQuantum:\n                {\n                  if (image->depth <= 8)\n                    {\n                      unsigned char\n                        pixel;\n\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        p=PushCharPixel(p,&pixel);\n                        SetPixelRed(image,ScaleAnyToQuantum(pixel,max_value),q);\n                        p=PushCharPixel(p,&pixel);\n                        SetPixelGreen(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        p=PushCharPixel(p,&pixel);\n                        SetPixelBlue(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        p=PushCharPixel(p,&pixel);\n                        SetPixelBlack(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        SetPixelAlpha(image,OpaqueAlpha,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            p=PushCharPixel(p,&pixel);\n                            SetPixelAlpha(image,ScaleAnyToQuantum(pixel,\n                              max_value),q);\n                          }\n                        q+=GetPixelChannels(image);\n                      }\n                    }\n                  else if (image->depth <= 16)\n                    {\n                      unsigned short\n                        pixel;\n\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        p=PushShortPixel(MSBEndian,p,&pixel);\n                        SetPixelRed(image,ScaleAnyToQuantum(pixel,max_value),q);\n                        p=PushShortPixel(MSBEndian,p,&pixel);\n                        SetPixelGreen(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        p=PushShortPixel(MSBEndian,p,&pixel);\n                        SetPixelBlue(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        p=PushShortPixel(MSBEndian,p,&pixel);\n                        SetPixelBlack(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        SetPixelAlpha(image,OpaqueAlpha,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            p=PushShortPixel(MSBEndian,p,&pixel);\n                            SetPixelAlpha(image,ScaleAnyToQuantum(pixel,\n                              max_value),q);\n                          }\n                        q+=GetPixelChannels(image);\n                      }\n                    }\n                  else\n                    {\n                      unsigned int\n                        pixel;\n\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        p=PushLongPixel(MSBEndian,p,&pixel);\n                        SetPixelRed(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        p=PushLongPixel(MSBEndian,p,&pixel);\n                        SetPixelGreen(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        p=PushLongPixel(MSBEndian,p,&pixel);\n                        SetPixelBlue(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        p=PushLongPixel(MSBEndian,p,&pixel);\n                        SetPixelBlack(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        SetPixelAlpha(image,OpaqueAlpha,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            p=PushLongPixel(MSBEndian,p,&pixel);\n                            SetPixelAlpha(image,ScaleAnyToQuantum(pixel,\n                              max_value),q);\n                          }\n                        q+=GetPixelChannels(image);\n                    }\n                  }\n                  break;\n                }\n                default:\n                {\n                  if (image->depth <= 8)\n                    {\n                      unsigned char\n                        pixel;\n\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        p=PushCharPixel(p,&pixel);\n                        SetPixelRed(image,ScaleAnyToQuantum(pixel,max_value),q);\n                        p=PushCharPixel(p,&pixel);\n                        SetPixelGreen(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        p=PushCharPixel(p,&pixel);\n                        SetPixelBlue(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        SetPixelAlpha(image,OpaqueAlpha,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            p=PushCharPixel(p,&pixel);\n                            SetPixelAlpha(image,ScaleAnyToQuantum(pixel,\n                              max_value),q);\n                          }\n                        q+=GetPixelChannels(image);\n                      }\n                    }\n                  else if (image->depth <= 16)\n                    {\n                      unsigned short\n                        pixel;\n\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        p=PushShortPixel(MSBEndian,p,&pixel);\n                        SetPixelRed(image,ScaleAnyToQuantum(pixel,max_value),q);\n                        p=PushShortPixel(MSBEndian,p,&pixel);\n                        SetPixelGreen(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        p=PushShortPixel(MSBEndian,p,&pixel);\n                        SetPixelBlue(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        SetPixelAlpha(image,OpaqueAlpha,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            p=PushShortPixel(MSBEndian,p,&pixel);\n                            SetPixelAlpha(image,ScaleAnyToQuantum(pixel,\n                              max_value),q);\n                          }\n                        q+=GetPixelChannels(image);\n                      }\n                    }\n                  else\n                    {\n                      unsigned int\n                        pixel;\n\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        p=PushLongPixel(MSBEndian,p,&pixel);\n                        SetPixelRed(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        p=PushLongPixel(MSBEndian,p,&pixel);\n                        SetPixelGreen(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        p=PushLongPixel(MSBEndian,p,&pixel);\n                        SetPixelBlue(image,ScaleAnyToQuantum(pixel,max_value),\n                          q);\n                        SetPixelAlpha(image,OpaqueAlpha,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            p=PushLongPixel(MSBEndian,p,&pixel);\n                            SetPixelAlpha(image,ScaleAnyToQuantum(pixel,\n                              max_value),q);\n                          }\n                        q+=GetPixelChannels(image);\n                      }\n                    }\n                  break;\n                }\n              }\n            }\n          }\n          sync=SyncAuthenticPixels(image,exception);\n          if (sync == MagickFalse)\n            break;\n        }\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        SetQuantumImageType(image,quantum_type);\n        break;\n      }\n      case 'F':\n      case 'f':\n      {\n        /*\n          Convert PFM raster image to pixel packets.\n        */\n        if (format == 'f')\n          (void) SetImageColorspace(image,GRAYColorspace,exception);\n        quantum_type=format == 'f' ? GrayQuantum : RGBQuantum;\n        image->endian=quantum_scale < 0.0 ? LSBEndian : MSBEndian;\n        image->depth=32;\n        quantum_info=AcquireQuantumInfo(image_info,image);\n        if (quantum_info == (QuantumInfo *) NULL)\n          ThrowPNMException(ResourceLimitError,\"MemoryAllocationFailed\");\n        status=SetQuantumDepth(image,quantum_info,32);\n        if (status == MagickFalse)\n          ThrowPNMException(ResourceLimitError,\"MemoryAllocationFailed\");\n        status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n        if (status == MagickFalse)\n          ThrowPNMException(ResourceLimitError,\"MemoryAllocationFailed\");\n        SetQuantumScale(quantum_info,(double) QuantumRange*fabs(quantum_scale));\n        extent=GetQuantumExtent(image,quantum_info,quantum_type);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          const unsigned char\n            *pixels;\n\n          MagickBooleanType\n            sync;\n\n          register Quantum\n            *magick_restrict q;\n\n          ssize_t\n            offset;\n\n          size_t\n            length;\n\n          pixels=(unsigned char *) ReadBlobStream(image,extent,\n            GetQuantumPixels(quantum_info),&count);\n          if (count != (ssize_t) extent)\n            break;\n          if ((image->progress_monitor != (MagickProgressMonitor) NULL) &&\n              (image->previous == (Image *) NULL))\n            {\n              MagickBooleanType\n                proceed;\n\n              proceed=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                row,image->rows);\n              if (proceed == MagickFalse)\n                break;\n            }\n          offset=row++;\n          q=QueueAuthenticPixels(image,0,(ssize_t) (image->rows-offset-1),\n            image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          length=ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          if (length != extent)\n            break;\n          sync=SyncAuthenticPixels(image,exception);\n          if (sync == MagickFalse)\n            break;\n        }\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        SetQuantumImageType(image,quantum_type);\n        break;\n      }\n      default:\n        ThrowPNMException(CorruptImageError,\"ImproperImageHeader\");\n    }\n    if (*comment_info.comment != '\\0')\n      (void) SetImageProperty(image,\"comment\",comment_info.comment,exception);\n    comment_info.comment=DestroyString(comment_info.comment);\n    if (y < (ssize_t) image->rows)\n      ThrowPNMException(CorruptImageError,\"UnableToReadImageData\");\n    if (EOFBlob(image) != MagickFalse)\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          CorruptImageError,\"UnexpectedEndOfFile\",\"`%s'\",image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if ((format == '1') || (format == '2') || (format == '3'))\n      do\n      {\n        /*\n          Skip to end of line.\n        */\n        count=ReadBlob(image,1,(unsigned char *) &format);\n        if (count != 1)\n          break;\n        if (format == 'P')\n          break;\n      } while (format != '\\n');\n    count=ReadBlob(image,1,(unsigned char *) &format);\n    if ((count == 1) && (format == 'P'))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            status=MagickFalse;\n            break;\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((count == 1) && (format == 'P'));\n  (void) CloseBlob(image);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r P N M I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterPNMImage() adds properties for the PNM image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterPNMImage method is:\n%\n%      size_t RegisterPNMImage(void)\n%\n*/\nModuleExport size_t RegisterPNMImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"PNM\",\"PAM\",\"Common 2-dimensional bitmap format\");\n  entry->decoder=(DecodeImageHandler *) ReadPNMImage;\n  entry->encoder=(EncodeImageHandler *) WritePNMImage;\n  entry->mime_type=ConstantString(\"image/x-portable-pixmap\");\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PNM\",\"PBM\",\n    \"Portable bitmap format (black and white)\");\n  entry->decoder=(DecodeImageHandler *) ReadPNMImage;\n  entry->encoder=(EncodeImageHandler *) WritePNMImage;\n  entry->mime_type=ConstantString(\"image/x-portable-bitmap\");\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PNM\",\"PFM\",\"Portable float format\");\n  entry->decoder=(DecodeImageHandler *) ReadPNMImage;\n  entry->encoder=(EncodeImageHandler *) WritePNMImage;\n  entry->flags|=CoderEndianSupportFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PNM\",\"PGM\",\"Portable graymap format (gray scale)\");\n  entry->decoder=(DecodeImageHandler *) ReadPNMImage;\n  entry->encoder=(EncodeImageHandler *) WritePNMImage;\n  entry->mime_type=ConstantString(\"image/x-portable-greymap\");\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PNM\",\"PNM\",\"Portable anymap\");\n  entry->decoder=(DecodeImageHandler *) ReadPNMImage;\n  entry->encoder=(EncodeImageHandler *) WritePNMImage;\n  entry->magick=(IsImageFormatHandler *) IsPNM;\n  entry->mime_type=ConstantString(\"image/x-portable-pixmap\");\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PNM\",\"PPM\",\"Portable pixmap format (color)\");\n  entry->decoder=(DecodeImageHandler *) ReadPNMImage;\n  entry->encoder=(EncodeImageHandler *) WritePNMImage;\n  entry->mime_type=ConstantString(\"image/x-portable-pixmap\");\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r P N M I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterPNMImage() removes format registrations made by the\n%  PNM module from the list of supported formats.\n%\n%  The format of the UnregisterPNMImage method is:\n%\n%      UnregisterPNMImage(void)\n%\n*/\nModuleExport void UnregisterPNMImage(void)\n{\n  (void) UnregisterMagickInfo(\"PAM\");\n  (void) UnregisterMagickInfo(\"PBM\");\n  (void) UnregisterMagickInfo(\"PGM\");\n  (void) UnregisterMagickInfo(\"PNM\");\n  (void) UnregisterMagickInfo(\"PPM\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e P N M I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WritePNMImage() writes an image to a file in the PNM rasterfile format.\n%\n%  The format of the WritePNMImage method is:\n%\n%      MagickBooleanType WritePNMImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WritePNMImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  char\n    buffer[MagickPathExtent],\n    format,\n    magick[MagickPathExtent];\n\n  const char\n    *value;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  Quantum\n    index;\n\n  QuantumAny\n    pixel;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  register unsigned char\n    *q;\n\n  size_t\n    extent,\n    imageListLength,\n    packet_size;\n\n  ssize_t\n    count,\n    y;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  scene=0;\n  imageListLength=GetImageListLength(image);\n  do\n  {\n    QuantumAny\n      max_value;\n\n    /*\n      Write PNM file header.\n    */\n    packet_size=3;\n    quantum_type=RGBQuantum;\n    (void) CopyMagickString(magick,image_info->magick,MagickPathExtent);\n    max_value=GetQuantumRange(image->depth);\n    switch (magick[1])\n    {\n      case 'A':\n      case 'a':\n      {\n        format='7';\n        break;\n      }\n      case 'B':\n      case 'b':\n      {\n        format='4';\n        if (image_info->compression == NoCompression)\n          format='1';\n        break;\n      }\n      case 'F':\n      case 'f':\n      {\n        format='F';\n        if (SetImageGray(image,exception) != MagickFalse)\n          format='f';\n        break;\n      }\n      case 'G':\n      case 'g':\n      {\n        format='5';\n        if (image_info->compression == NoCompression)\n          format='2';\n        break;\n      }\n      case 'N':\n      case 'n':\n      {\n        if ((image_info->type != TrueColorType) &&\n            (SetImageGray(image,exception) != MagickFalse))\n          {\n            format='5';\n            if (image_info->compression == NoCompression)\n              format='2';\n            if (SetImageMonochrome(image,exception) != MagickFalse)\n              {\n                format='4';\n                if (image_info->compression == NoCompression)\n                  format='1';\n              }\n            break;\n          }\n      }\n      default:\n      {\n        format='6';\n        if (image_info->compression == NoCompression)\n          format='3';\n        break;\n      }\n    }\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"P%c\\n\",format);\n    (void) WriteBlobString(image,buffer);\n    value=GetImageProperty(image,\"comment\",exception);\n    if (value != (const char *) NULL)\n      {\n        register const char\n          *p;\n\n        /*\n          Write comments to file.\n        */\n        (void) WriteBlobByte(image,'#');\n        for (p=value; *p != '\\0'; p++)\n        {\n          (void) WriteBlobByte(image,(unsigned char) *p);\n          if ((*p == '\\n') || (*p == '\\r'))\n            (void) WriteBlobByte(image,'#');\n        }\n        (void) WriteBlobByte(image,'\\n');\n      }\n    if (format != '7')\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g %.20g\\n\",\n          (double) image->columns,(double) image->rows);\n        (void) WriteBlobString(image,buffer);\n      }\n    else\n      {\n        char\n          type[MagickPathExtent];\n\n        /*\n          PAM header.\n        */\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"WIDTH %.20g\\nHEIGHT %.20g\\n\",(double) image->columns,(double)\n          image->rows);\n        (void) WriteBlobString(image,buffer);\n        quantum_type=GetQuantumType(image,exception);\n        switch (quantum_type)\n        {\n          case CMYKQuantum:\n          case CMYKAQuantum:\n          {\n            packet_size=4;\n            (void) CopyMagickString(type,\"CMYK\",MagickPathExtent);\n            break;\n          }\n          case GrayQuantum:\n          case GrayAlphaQuantum:\n          {\n            packet_size=1;\n            (void) CopyMagickString(type,\"GRAYSCALE\",MagickPathExtent);\n            if (IdentifyImageMonochrome(image,exception) != MagickFalse)\n              (void) CopyMagickString(type,\"BLACKANDWHITE\",MagickPathExtent);\n            break;\n          }\n          default:\n          {\n            quantum_type=RGBQuantum;\n            if (image->alpha_trait != UndefinedPixelTrait)\n              quantum_type=RGBAQuantum;\n            packet_size=3;\n            (void) CopyMagickString(type,\"RGB\",MagickPathExtent);\n            break;\n          }\n        }\n        if (image->alpha_trait != UndefinedPixelTrait)\n          {\n            packet_size++;\n            (void) ConcatenateMagickString(type,\"_ALPHA\",MagickPathExtent);\n          }\n        if (image->depth > 32)\n          image->depth=32;\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"DEPTH %.20g\\nMAXVAL %.20g\\n\",(double) packet_size,(double)\n          ((MagickOffsetType) GetQuantumRange(image->depth)));\n        (void) WriteBlobString(image,buffer);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"TUPLTYPE %s\\nENDHDR\\n\",type);\n        (void) WriteBlobString(image,buffer);\n      }\n    /*\n      Convert runextent encoded to PNM raster pixels.\n    */\n    switch (format)\n    {\n      case '1':\n      {\n        unsigned char\n          pixels[2048];\n\n        /*\n          Convert image to a PBM image.\n        */\n        (void) SetImageType(image,BilevelType,exception);\n        q=pixels;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=(unsigned char) (GetPixelLuma(image,p) >= (QuantumRange/2.0) ?\n              '0' : '1');\n            *q++=' ';\n            if ((q-pixels+1) >= (ssize_t) sizeof(pixels))\n              {\n                *q++='\\n';\n                (void) WriteBlob(image,q-pixels,pixels);\n                q=pixels;\n              }\n            p+=GetPixelChannels(image);\n          }\n          *q++='\\n';\n          (void) WriteBlob(image,q-pixels,pixels);\n          q=pixels;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        if (q != pixels)\n          {\n            *q++='\\n';\n            (void) WriteBlob(image,q-pixels,pixels);\n          }\n        break;\n      }\n      case '2':\n      {\n        unsigned char\n          pixels[2048];\n\n        /*\n          Convert image to a PGM image.\n        */\n        if (image->depth <= 8)\n          (void) WriteBlobString(image,\"255\\n\");\n        else\n          if (image->depth <= 16)\n            (void) WriteBlobString(image,\"65535\\n\");\n          else\n            (void) WriteBlobString(image,\"4294967295\\n\");\n        q=pixels;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            index=ClampToQuantum(GetPixelLuma(image,p));\n            if (image->depth <= 8)\n              count=(ssize_t) FormatLocaleString(buffer,MagickPathExtent,\"%u \",\n                ScaleQuantumToChar(index));\n            else\n              if (image->depth <= 16)\n                count=(ssize_t) FormatLocaleString(buffer,MagickPathExtent,\n                  \"%u \",ScaleQuantumToShort(index));\n              else\n                count=(ssize_t) FormatLocaleString(buffer,MagickPathExtent,\n                  \"%u \",ScaleQuantumToLong(index));\n            extent=(size_t) count;\n            (void) strncpy((char *) q,buffer,extent);\n            q+=extent;\n            if ((q-pixels+extent+2) >= sizeof(pixels))\n              {\n                *q++='\\n';\n                (void) WriteBlob(image,q-pixels,pixels);\n                q=pixels;\n              }\n            p+=GetPixelChannels(image);\n          }\n          *q++='\\n';\n          (void) WriteBlob(image,q-pixels,pixels);\n          q=pixels;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        if (q != pixels)\n          {\n            *q++='\\n';\n            (void) WriteBlob(image,q-pixels,pixels);\n          }\n        break;\n      }\n      case '3':\n      {\n        unsigned char\n          pixels[2048];\n\n        /*\n          Convert image to a PNM image.\n        */\n        (void) TransformImageColorspace(image,sRGBColorspace,exception);\n        if (image->depth <= 8)\n          (void) WriteBlobString(image,\"255\\n\");\n        else\n          if (image->depth <= 16)\n            (void) WriteBlobString(image,\"65535\\n\");\n          else\n            (void) WriteBlobString(image,\"4294967295\\n\");\n        q=pixels;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            if (image->depth <= 8)\n              count=(ssize_t) FormatLocaleString(buffer,MagickPathExtent,\n                \"%u %u %u \",ScaleQuantumToChar(GetPixelRed(image,p)),\n                ScaleQuantumToChar(GetPixelGreen(image,p)),\n                ScaleQuantumToChar(GetPixelBlue(image,p)));\n            else\n              if (image->depth <= 16)\n                count=(ssize_t) FormatLocaleString(buffer,MagickPathExtent,\n                  \"%u %u %u \",ScaleQuantumToShort(GetPixelRed(image,p)),\n                  ScaleQuantumToShort(GetPixelGreen(image,p)),\n                  ScaleQuantumToShort(GetPixelBlue(image,p)));\n              else\n                count=(ssize_t) FormatLocaleString(buffer,MagickPathExtent,\n                  \"%u %u %u \",ScaleQuantumToLong(GetPixelRed(image,p)),\n                  ScaleQuantumToLong(GetPixelGreen(image,p)),\n                  ScaleQuantumToLong(GetPixelBlue(image,p)));\n            extent=(size_t) count;\n            (void) strncpy((char *) q,buffer,extent);\n            q+=extent;\n            if ((q-pixels+extent+2) >= sizeof(pixels))\n              {\n                *q++='\\n';\n                (void) WriteBlob(image,q-pixels,pixels);\n                q=pixels;\n              }\n            p+=GetPixelChannels(image);\n          }\n          *q++='\\n';\n          (void) WriteBlob(image,q-pixels,pixels);\n          q=pixels;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        if (q != pixels)\n          {\n            *q++='\\n';\n            (void) WriteBlob(image,q-pixels,pixels);\n          }\n        break;\n      }\n      case '4':\n      {\n        register unsigned char\n          *pixels;\n\n        /*\n          Convert image to a PBM image.\n        */\n        (void) SetImageType(image,BilevelType,exception);\n        image->depth=1;\n        quantum_info=AcquireQuantumInfo(image_info,image);\n        if (quantum_info == (QuantumInfo *) NULL)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) SetQuantumEndian(image,quantum_info,MSBEndian);\n        quantum_info->min_is_white=MagickTrue;\n        pixels=GetQuantumPixels(quantum_info);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          extent=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            GrayQuantum,pixels,exception);\n          count=WriteBlob(image,extent,pixels);\n          if (count != (ssize_t) extent)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        break;\n      }\n      case '5':\n      {\n        register unsigned char\n          *pixels;\n\n        /*\n          Convert image to a PGM image.\n        */\n        if (image->depth > 32)\n          image->depth=32;\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g\\n\",(double)\n          ((MagickOffsetType) GetQuantumRange(image->depth)));\n        (void) WriteBlobString(image,buffer);\n        quantum_info=AcquireQuantumInfo(image_info,image);\n        if (quantum_info == (QuantumInfo *) NULL)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) SetQuantumEndian(image,quantum_info,MSBEndian);\n        quantum_info->min_is_white=MagickTrue;\n        pixels=GetQuantumPixels(quantum_info);\n        extent=GetQuantumExtent(image,quantum_info,GrayQuantum);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels;\n          switch (image->depth)\n          {\n            case 8:\n            case 16:\n            case 32:\n            {\n              extent=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                GrayQuantum,pixels,exception);\n              break;\n            }\n            default:\n            {\n              if (image->depth <= 8)\n                {\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    if (IsPixelGray(image,p) == MagickFalse)\n                      pixel=ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(\n                        image,p)),max_value);\n                    else\n                      {\n                        if (image->depth == 8)\n                          pixel=ScaleQuantumToChar(GetPixelRed(image,p));\n                        else\n                          pixel=ScaleQuantumToAny(GetPixelRed(image,p),\n                            max_value);\n                      }\n                    q=PopCharPixel((unsigned char) pixel,q);\n                    p+=GetPixelChannels(image);\n                  }\n                  extent=(size_t) (q-pixels);\n                  break;\n                }\n              if (image->depth <= 16)\n                {\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    if (IsPixelGray(image,p) == MagickFalse)\n                      pixel=ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(image,\n                        p)),max_value);\n                    else\n                      {\n                        if (image->depth == 16)\n                          pixel=ScaleQuantumToShort(GetPixelRed(image,p));\n                        else\n                          pixel=ScaleQuantumToAny(GetPixelRed(image,p),\n                            max_value);\n                      }\n                    q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                    p+=GetPixelChannels(image);\n                  }\n                  extent=(size_t) (q-pixels);\n                  break;\n                }\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                if (IsPixelGray(image,p) == MagickFalse)\n                  pixel=ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(image,p)),\n                    max_value);\n                else\n                  {\n                    if (image->depth == 16)\n                      pixel=ScaleQuantumToLong(GetPixelRed(image,p));\n                    else\n                      pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);\n                  }\n                q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                p+=GetPixelChannels(image);\n              }\n              extent=(size_t) (q-pixels);\n              break;\n            }\n          }\n          count=WriteBlob(image,extent,pixels);\n          if (count != (ssize_t) extent)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        break;\n      }\n      case '6':\n      {\n        register unsigned char\n          *pixels;\n\n        /*\n          Convert image to a PNM image.\n        */\n        (void) TransformImageColorspace(image,sRGBColorspace,exception);\n        if (image->depth > 32)\n          image->depth=32;\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g\\n\",(double)\n          ((MagickOffsetType) GetQuantumRange(image->depth)));\n        (void) WriteBlobString(image,buffer);\n        quantum_info=AcquireQuantumInfo(image_info,image);\n        if (quantum_info == (QuantumInfo *) NULL)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) SetQuantumEndian(image,quantum_info,MSBEndian);\n        pixels=GetQuantumPixels(quantum_info);\n        extent=GetQuantumExtent(image,quantum_info,quantum_type);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels;\n          switch (image->depth)\n          {\n            case 8:\n            case 16:\n            case 32:\n            {\n              extent=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                quantum_type,pixels,exception);\n              break;\n            }\n            default:\n            {\n              if (image->depth <= 8)\n                {\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);\n                    q=PopCharPixel((unsigned char) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelGreen(image,p),max_value);\n                    q=PopCharPixel((unsigned char) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelBlue(image,p),max_value);\n                    q=PopCharPixel((unsigned char) pixel,q);\n                    p+=GetPixelChannels(image);\n                  }\n                  extent=(size_t) (q-pixels);\n                  break;\n                }\n              if (image->depth <= 16)\n                {\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);\n                    q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelGreen(image,p),max_value);\n                    q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelBlue(image,p),max_value);\n                    q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                    p+=GetPixelChannels(image);\n                  }\n                  extent=(size_t) (q-pixels);\n                  break;\n                }\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);\n                q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                pixel=ScaleQuantumToAny(GetPixelGreen(image,p),max_value);\n                q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                pixel=ScaleQuantumToAny(GetPixelBlue(image,p),max_value);\n                q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                p+=GetPixelChannels(image);\n              }\n              extent=(size_t) (q-pixels);\n              break;\n            }\n          }\n          count=WriteBlob(image,extent,pixels);\n          if (count != (ssize_t) extent)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        break;\n      }\n      case '7':\n      {\n        register unsigned char\n          *pixels;\n\n        /*\n          Convert image to a PAM.\n        */\n        if (image->depth > 32)\n          image->depth=32;\n        quantum_info=AcquireQuantumInfo(image_info,image);\n        if (quantum_info == (QuantumInfo *) NULL)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) SetQuantumEndian(image,quantum_info,MSBEndian);\n        pixels=GetQuantumPixels(quantum_info);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels;\n          switch (image->depth)\n          {\n            case 8:\n            case 16:\n            case 32:\n            {\n              extent=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                quantum_type,pixels,exception);\n              break;\n            }\n            default:\n            {\n              switch (quantum_type)\n              {\n                case GrayQuantum:\n                case GrayAlphaQuantum:\n                {\n                  if (image->depth <= 8)\n                    {\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        pixel=ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(\n                          image,p)),max_value);\n                        q=PopCharPixel((unsigned char) pixel,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            pixel=(unsigned char) ScaleQuantumToAny(\n                              GetPixelAlpha(image,p),max_value);\n                            q=PopCharPixel((unsigned char) pixel,q);\n                          }\n                        p+=GetPixelChannels(image);\n                      }\n                      break;\n                    }\n                  if (image->depth <= 16)\n                    {\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        pixel=ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(\n                          image,p)),max_value);\n                        q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            pixel=(unsigned char) ScaleQuantumToAny(\n                              GetPixelAlpha(image,p),max_value);\n                            q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                          }\n                        p+=GetPixelChannels(image);\n                      }\n                      break;\n                    }\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    pixel=ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(image,\n                      p)),max_value);\n                    q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                    if (image->alpha_trait != UndefinedPixelTrait)\n                      {\n                        pixel=(unsigned char) ScaleQuantumToAny(\n                          GetPixelAlpha(image,p),max_value);\n                        q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                      }\n                    p+=GetPixelChannels(image);\n                  }\n                  break;\n                }\n                case CMYKQuantum:\n                case CMYKAQuantum:\n                {\n                  if (image->depth <= 8)\n                    {\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);\n                        q=PopCharPixel((unsigned char) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelGreen(image,p),\n                          max_value);\n                        q=PopCharPixel((unsigned char) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelBlue(image,p),\n                          max_value);\n                        q=PopCharPixel((unsigned char) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelBlack(image,p),\n                          max_value);\n                        q=PopCharPixel((unsigned char) pixel,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            pixel=ScaleQuantumToAny(GetPixelAlpha(image,p),\n                              max_value);\n                            q=PopCharPixel((unsigned char) pixel,q);\n                          }\n                        p+=GetPixelChannels(image);\n                      }\n                      break;\n                    }\n                  if (image->depth <= 16)\n                    {\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);\n                        q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelGreen(image,p),\n                          max_value);\n                        q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelBlue(image,p),\n                          max_value);\n                        q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelBlack(image,p),\n                          max_value);\n                        q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            pixel=ScaleQuantumToAny(GetPixelAlpha(image,p),\n                              max_value);\n                            q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                          }\n                        p+=GetPixelChannels(image);\n                      }\n                      break;\n                    }\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);\n                    q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelGreen(image,p),max_value);\n                    q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelBlue(image,p),max_value);\n                    q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelBlack(image,p),max_value);\n                    q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                    if (image->alpha_trait != UndefinedPixelTrait)\n                      {\n                        pixel=ScaleQuantumToAny(GetPixelAlpha(image,p),\n                          max_value);\n                        q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                      }\n                    p+=GetPixelChannels(image);\n                  }\n                  break;\n                }\n                default:\n                {\n                  if (image->depth <= 8)\n                    {\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);\n                        q=PopCharPixel((unsigned char) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelGreen(image,p),\n                          max_value);\n                        q=PopCharPixel((unsigned char) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelBlue(image,p),\n                          max_value);\n                        q=PopCharPixel((unsigned char) pixel,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            pixel=ScaleQuantumToAny(GetPixelAlpha(image,p),\n                              max_value);\n                            q=PopCharPixel((unsigned char) pixel,q);\n                          }\n                        p+=GetPixelChannels(image);\n                      }\n                      break;\n                    }\n                  if (image->depth <= 16)\n                    {\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);\n                        q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelGreen(image,p),\n                          max_value);\n                        q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelBlue(image,p),\n                          max_value);\n                        q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            pixel=ScaleQuantumToAny(GetPixelAlpha(image,p),\n                              max_value);\n                            q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                          }\n                        p+=GetPixelChannels(image);\n                      }\n                      break;\n                    }\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);\n                    q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelGreen(image,p),max_value);\n                    q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelBlue(image,p),max_value);\n                    q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                    if (image->alpha_trait != UndefinedPixelTrait)\n                      {\n                        pixel=ScaleQuantumToAny(GetPixelAlpha(image,p),\n                          max_value);\n                        q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                      }\n                    p+=GetPixelChannels(image);\n                  }\n                  break;\n                }\n              }\n              extent=(size_t) (q-pixels);\n              break;\n            }\n          }\n          count=WriteBlob(image,extent,pixels);\n          if (count != (ssize_t) extent)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        break;\n      }\n      case 'F':\n      case 'f':\n      {\n        register unsigned char\n          *pixels;\n\n        (void) WriteBlobString(image,image->endian == LSBEndian ? \"-1.0\\n\" :\n          \"1.0\\n\");\n        image->depth=32;\n        quantum_type=format == 'f' ? GrayQuantum : RGBQuantum;\n        quantum_info=AcquireQuantumInfo(image_info,image);\n        if (quantum_info == (QuantumInfo *) NULL)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n        if (status == MagickFalse)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        pixels=GetQuantumPixels(quantum_info);\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          extent=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          (void) WriteBlob(image,extent,pixels);\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        break;\n      }\n    }\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,imageListLength);\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "filenames": ["coders/pnm.c"], "buggy_code_start_loc": [1837], "buggy_code_end_loc": [1913], "fixing_code_start_loc": [1837], "fixing_code_end_loc": [1913], "type": "CWE-193", "message": "ImageMagick 7.0.8-50 Q16 has a stack-based buffer overflow at coders/pnm.c in WritePNMImage because of off-by-one errors.", "other": {"cve": {"id": "CVE-2019-13306", "sourceIdentifier": "cve@mitre.org", "published": "2019-07-05T01:15:10.623", "lastModified": "2023-02-23T15:10:08.390", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ImageMagick 7.0.8-50 Q16 has a stack-based buffer overflow at coders/pnm.c in WritePNMImage because of off-by-one errors."}, {"lang": "es", "value": "ImageMagick versi\u00f3n 7.0.8-50 Q16 tiene un desbordamiento de b\u00fafer basado en pila en coders/pnm.c en WritePNMImage debido a los errores de superaci\u00f3n de l\u00edmite (off-by-one)."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-193"}, {"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.8-50:q16:*:*:*:*:*:*", "matchCriteriaId": "25CCEA99-8329-46C6-9625-4FE15F24CF69"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.04:*:*:*:*:*:*:*", "matchCriteriaId": "CD783B0C-9246-47D9-A937-6144FE8BFF0F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.0:*:*:*:*:*:*:*", "matchCriteriaId": "F1E78106-58E6-4D59-990F-75DA575BFAD9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-08/msg00069.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/e92040ea6ee2a844ebfd2344174076795a4787bd", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/1612", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick6/commit/cb5ec7d98195aa74d5ed299b38eff2a68122f3fa", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/08/msg00021.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4192-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2020/dsa-4715", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/e92040ea6ee2a844ebfd2344174076795a4787bd"}}