{"buggy_code": ["/* thread_info.h: MIPS low-level thread information\n *\n * Copyright (C) 2002  David Howells (dhowells@redhat.com)\n * - Incorporating suggestions made by Linus Torvalds and Dave Miller\n */\n\n#ifndef _ASM_THREAD_INFO_H\n#define _ASM_THREAD_INFO_H\n\n#ifdef __KERNEL__\n\n\n#ifndef __ASSEMBLY__\n\n#include <asm/processor.h>\n\n/*\n * low level task data that entry.S needs immediate access to\n * - this struct should fit entirely inside of one cache line\n * - this struct shares the supervisor stack pages\n * - if the contents of this structure are changed, the assembly constants\n *   must also be changed\n */\nstruct thread_info {\n\tstruct task_struct\t*task;\t\t/* main task structure */\n\tstruct exec_domain\t*exec_domain;\t/* execution domain */\n\tunsigned long\t\tflags;\t\t/* low level flags */\n\tunsigned long\t\ttp_value;\t/* thread pointer */\n\t__u32\t\t\tcpu;\t\t/* current CPU */\n\tint\t\t\tpreempt_count;\t/* 0 => preemptable, <0 => BUG */\n\n\tmm_segment_t\t\taddr_limit;\t/*\n\t\t\t\t\t\t * thread address space limit:\n\t\t\t\t\t\t * 0x7fffffff for user-thead\n\t\t\t\t\t\t * 0xffffffff for kernel-thread\n\t\t\t\t\t\t */\n\tstruct restart_block\trestart_block;\n\tstruct pt_regs\t\t*regs;\n};\n\n/*\n * macros/functions for gaining access to the thread information structure\n */\n#define INIT_THREAD_INFO(tsk)\t\t\t\\\n{\t\t\t\t\t\t\\\n\t.task\t\t= &tsk,\t\t\t\\\n\t.exec_domain\t= &default_exec_domain, \\\n\t.flags\t\t= _TIF_FIXADE,\t\t\\\n\t.cpu\t\t= 0,\t\t\t\\\n\t.preempt_count\t= INIT_PREEMPT_COUNT,\t\\\n\t.addr_limit\t= KERNEL_DS,\t\t\\\n\t.restart_block\t= {\t\t\t\\\n\t\t.fn = do_no_restart_syscall,\t\\\n\t},\t\t\t\t\t\\\n}\n\n#define init_thread_info\t(init_thread_union.thread_info)\n#define init_stack\t\t(init_thread_union.stack)\n\n/* How to get the thread information struct from C.  */\nstatic inline struct thread_info *current_thread_info(void)\n{\n\tregister struct thread_info *__current_thread_info __asm__(\"$28\");\n\n\treturn __current_thread_info;\n}\n\n#endif /* !__ASSEMBLY__ */\n\n/* thread information allocation */\n#if defined(CONFIG_PAGE_SIZE_4KB) && defined(CONFIG_32BIT)\n#define THREAD_SIZE_ORDER (1)\n#endif\n#if defined(CONFIG_PAGE_SIZE_4KB) && defined(CONFIG_64BIT)\n#define THREAD_SIZE_ORDER (2)\n#endif\n#ifdef CONFIG_PAGE_SIZE_8KB\n#define THREAD_SIZE_ORDER (1)\n#endif\n#ifdef CONFIG_PAGE_SIZE_16KB\n#define THREAD_SIZE_ORDER (0)\n#endif\n#ifdef CONFIG_PAGE_SIZE_32KB\n#define THREAD_SIZE_ORDER (0)\n#endif\n#ifdef CONFIG_PAGE_SIZE_64KB\n#define THREAD_SIZE_ORDER (0)\n#endif\n\n#define THREAD_SIZE (PAGE_SIZE << THREAD_SIZE_ORDER)\n#define THREAD_MASK (THREAD_SIZE - 1UL)\n\n#define STACK_WARN\t(THREAD_SIZE / 8)\n\n/*\n * thread information flags\n * - these are process state flags that various assembly files may need to\n *   access\n * - pending work-to-be-done flags are in LSW\n * - other flags in MSW\n */\n#define TIF_SIGPENDING\t\t1\t/* signal pending */\n#define TIF_NEED_RESCHED\t2\t/* rescheduling necessary */\n#define TIF_SYSCALL_AUDIT\t3\t/* syscall auditing active */\n#define TIF_SECCOMP\t\t4\t/* secure computing */\n#define TIF_NOTIFY_RESUME\t5\t/* callback before returning to user */\n#define TIF_RESTORE_SIGMASK\t9\t/* restore signal mask in do_signal() */\n#define TIF_USEDFPU\t\t16\t/* FPU was used by this task this quantum (SMP) */\n#define TIF_MEMDIE\t\t18\t/* is terminating due to OOM killer */\n#define TIF_NOHZ\t\t19\t/* in adaptive nohz mode */\n#define TIF_FIXADE\t\t20\t/* Fix address errors in software */\n#define TIF_LOGADE\t\t21\t/* Log address errors to syslog */\n#define TIF_32BIT_REGS\t\t22\t/* 32-bit general purpose registers */\n#define TIF_32BIT_ADDR\t\t23\t/* 32-bit address space (o32/n32) */\n#define TIF_FPUBOUND\t\t24\t/* thread bound to FPU-full CPU set */\n#define TIF_LOAD_WATCH\t\t25\t/* If set, load watch registers */\n#define TIF_SYSCALL_TRACEPOINT\t26\t/* syscall tracepoint instrumentation */\n#define TIF_32BIT_FPREGS\t27\t/* 32-bit floating point registers */\n#define TIF_SYSCALL_TRACE\t31\t/* syscall trace active */\n\n#define _TIF_SYSCALL_TRACE\t(1<<TIF_SYSCALL_TRACE)\n#define _TIF_SIGPENDING\t\t(1<<TIF_SIGPENDING)\n#define _TIF_NEED_RESCHED\t(1<<TIF_NEED_RESCHED)\n#define _TIF_SYSCALL_AUDIT\t(1<<TIF_SYSCALL_AUDIT)\n#define _TIF_SECCOMP\t\t(1<<TIF_SECCOMP)\n#define _TIF_NOTIFY_RESUME\t(1<<TIF_NOTIFY_RESUME)\n#define _TIF_USEDFPU\t\t(1<<TIF_USEDFPU)\n#define _TIF_NOHZ\t\t(1<<TIF_NOHZ)\n#define _TIF_FIXADE\t\t(1<<TIF_FIXADE)\n#define _TIF_LOGADE\t\t(1<<TIF_LOGADE)\n#define _TIF_32BIT_REGS\t\t(1<<TIF_32BIT_REGS)\n#define _TIF_32BIT_ADDR\t\t(1<<TIF_32BIT_ADDR)\n#define _TIF_FPUBOUND\t\t(1<<TIF_FPUBOUND)\n#define _TIF_LOAD_WATCH\t\t(1<<TIF_LOAD_WATCH)\n#define _TIF_32BIT_FPREGS\t(1<<TIF_32BIT_FPREGS)\n#define _TIF_SYSCALL_TRACEPOINT\t(1<<TIF_SYSCALL_TRACEPOINT)\n\n#define _TIF_WORK_SYSCALL_ENTRY\t(_TIF_NOHZ | _TIF_SYSCALL_TRACE |\t\\\n\t\t\t\t _TIF_SYSCALL_AUDIT | _TIF_SYSCALL_TRACEPOINT)\n\n/* work to do in syscall_trace_leave() */\n#define _TIF_WORK_SYSCALL_EXIT\t(_TIF_NOHZ | _TIF_SYSCALL_TRACE |\t\\\n\t\t\t\t _TIF_SYSCALL_AUDIT | _TIF_SYSCALL_TRACEPOINT)\n\n/* work to do on interrupt/exception return */\n#define _TIF_WORK_MASK\t\t\\\n\t(_TIF_SIGPENDING | _TIF_NEED_RESCHED | _TIF_NOTIFY_RESUME)\n/* work to do on any return to u-space */\n#define _TIF_ALLWORK_MASK\t(_TIF_NOHZ | _TIF_WORK_MASK |\t\t\\\n\t\t\t\t _TIF_WORK_SYSCALL_EXIT |\t\t\\\n\t\t\t\t _TIF_SYSCALL_TRACEPOINT)\n\n/*\n * We stash processor id into a COP0 register to retrieve it fast\n * at kernel exception entry.\n */\n#if defined(CONFIG_MIPS_MT_SMTC)\n#define SMP_CPUID_REG\t\t2, 2\t/* TCBIND */\n#define ASM_SMP_CPUID_REG\t$2, 2\n#define SMP_CPUID_PTRSHIFT\t19\n#elif defined(CONFIG_MIPS_PGD_C0_CONTEXT)\n#define SMP_CPUID_REG\t\t20, 0\t/* XCONTEXT */\n#define ASM_SMP_CPUID_REG\t$20\n#define SMP_CPUID_PTRSHIFT\t48\n#else\n#define SMP_CPUID_REG\t\t4, 0\t/* CONTEXT */\n#define ASM_SMP_CPUID_REG\t$4\n#define SMP_CPUID_PTRSHIFT\t23\n#endif\n\n#ifdef CONFIG_64BIT\n#define SMP_CPUID_REGSHIFT\t(SMP_CPUID_PTRSHIFT + 3)\n#else\n#define SMP_CPUID_REGSHIFT\t(SMP_CPUID_PTRSHIFT + 2)\n#endif\n\n#ifdef CONFIG_MIPS_MT_SMTC\n#define ASM_CPUID_MFC0\t\tmfc0\n#define UASM_i_CPUID_MFC0\tuasm_i_mfc0\n#else\n#define ASM_CPUID_MFC0\t\tMFC0\n#define UASM_i_CPUID_MFC0\tUASM_i_MFC0\n#endif\n\n#endif /* __KERNEL__ */\n#endif /* _ASM_THREAD_INFO_H */\n"], "fixing_code": ["/* thread_info.h: MIPS low-level thread information\n *\n * Copyright (C) 2002  David Howells (dhowells@redhat.com)\n * - Incorporating suggestions made by Linus Torvalds and Dave Miller\n */\n\n#ifndef _ASM_THREAD_INFO_H\n#define _ASM_THREAD_INFO_H\n\n#ifdef __KERNEL__\n\n\n#ifndef __ASSEMBLY__\n\n#include <asm/processor.h>\n\n/*\n * low level task data that entry.S needs immediate access to\n * - this struct should fit entirely inside of one cache line\n * - this struct shares the supervisor stack pages\n * - if the contents of this structure are changed, the assembly constants\n *   must also be changed\n */\nstruct thread_info {\n\tstruct task_struct\t*task;\t\t/* main task structure */\n\tstruct exec_domain\t*exec_domain;\t/* execution domain */\n\tunsigned long\t\tflags;\t\t/* low level flags */\n\tunsigned long\t\ttp_value;\t/* thread pointer */\n\t__u32\t\t\tcpu;\t\t/* current CPU */\n\tint\t\t\tpreempt_count;\t/* 0 => preemptable, <0 => BUG */\n\n\tmm_segment_t\t\taddr_limit;\t/*\n\t\t\t\t\t\t * thread address space limit:\n\t\t\t\t\t\t * 0x7fffffff for user-thead\n\t\t\t\t\t\t * 0xffffffff for kernel-thread\n\t\t\t\t\t\t */\n\tstruct restart_block\trestart_block;\n\tstruct pt_regs\t\t*regs;\n};\n\n/*\n * macros/functions for gaining access to the thread information structure\n */\n#define INIT_THREAD_INFO(tsk)\t\t\t\\\n{\t\t\t\t\t\t\\\n\t.task\t\t= &tsk,\t\t\t\\\n\t.exec_domain\t= &default_exec_domain, \\\n\t.flags\t\t= _TIF_FIXADE,\t\t\\\n\t.cpu\t\t= 0,\t\t\t\\\n\t.preempt_count\t= INIT_PREEMPT_COUNT,\t\\\n\t.addr_limit\t= KERNEL_DS,\t\t\\\n\t.restart_block\t= {\t\t\t\\\n\t\t.fn = do_no_restart_syscall,\t\\\n\t},\t\t\t\t\t\\\n}\n\n#define init_thread_info\t(init_thread_union.thread_info)\n#define init_stack\t\t(init_thread_union.stack)\n\n/* How to get the thread information struct from C.  */\nstatic inline struct thread_info *current_thread_info(void)\n{\n\tregister struct thread_info *__current_thread_info __asm__(\"$28\");\n\n\treturn __current_thread_info;\n}\n\n#endif /* !__ASSEMBLY__ */\n\n/* thread information allocation */\n#if defined(CONFIG_PAGE_SIZE_4KB) && defined(CONFIG_32BIT)\n#define THREAD_SIZE_ORDER (1)\n#endif\n#if defined(CONFIG_PAGE_SIZE_4KB) && defined(CONFIG_64BIT)\n#define THREAD_SIZE_ORDER (2)\n#endif\n#ifdef CONFIG_PAGE_SIZE_8KB\n#define THREAD_SIZE_ORDER (1)\n#endif\n#ifdef CONFIG_PAGE_SIZE_16KB\n#define THREAD_SIZE_ORDER (0)\n#endif\n#ifdef CONFIG_PAGE_SIZE_32KB\n#define THREAD_SIZE_ORDER (0)\n#endif\n#ifdef CONFIG_PAGE_SIZE_64KB\n#define THREAD_SIZE_ORDER (0)\n#endif\n\n#define THREAD_SIZE (PAGE_SIZE << THREAD_SIZE_ORDER)\n#define THREAD_MASK (THREAD_SIZE - 1UL)\n\n#define STACK_WARN\t(THREAD_SIZE / 8)\n\n/*\n * thread information flags\n * - these are process state flags that various assembly files may need to\n *   access\n * - pending work-to-be-done flags are in LSW\n * - other flags in MSW\n */\n#define TIF_SIGPENDING\t\t1\t/* signal pending */\n#define TIF_NEED_RESCHED\t2\t/* rescheduling necessary */\n#define TIF_SYSCALL_AUDIT\t3\t/* syscall auditing active */\n#define TIF_SECCOMP\t\t4\t/* secure computing */\n#define TIF_NOTIFY_RESUME\t5\t/* callback before returning to user */\n#define TIF_RESTORE_SIGMASK\t9\t/* restore signal mask in do_signal() */\n#define TIF_USEDFPU\t\t16\t/* FPU was used by this task this quantum (SMP) */\n#define TIF_MEMDIE\t\t18\t/* is terminating due to OOM killer */\n#define TIF_NOHZ\t\t19\t/* in adaptive nohz mode */\n#define TIF_FIXADE\t\t20\t/* Fix address errors in software */\n#define TIF_LOGADE\t\t21\t/* Log address errors to syslog */\n#define TIF_32BIT_REGS\t\t22\t/* 32-bit general purpose registers */\n#define TIF_32BIT_ADDR\t\t23\t/* 32-bit address space (o32/n32) */\n#define TIF_FPUBOUND\t\t24\t/* thread bound to FPU-full CPU set */\n#define TIF_LOAD_WATCH\t\t25\t/* If set, load watch registers */\n#define TIF_SYSCALL_TRACEPOINT\t26\t/* syscall tracepoint instrumentation */\n#define TIF_32BIT_FPREGS\t27\t/* 32-bit floating point registers */\n#define TIF_SYSCALL_TRACE\t31\t/* syscall trace active */\n\n#define _TIF_SYSCALL_TRACE\t(1<<TIF_SYSCALL_TRACE)\n#define _TIF_SIGPENDING\t\t(1<<TIF_SIGPENDING)\n#define _TIF_NEED_RESCHED\t(1<<TIF_NEED_RESCHED)\n#define _TIF_SYSCALL_AUDIT\t(1<<TIF_SYSCALL_AUDIT)\n#define _TIF_SECCOMP\t\t(1<<TIF_SECCOMP)\n#define _TIF_NOTIFY_RESUME\t(1<<TIF_NOTIFY_RESUME)\n#define _TIF_USEDFPU\t\t(1<<TIF_USEDFPU)\n#define _TIF_NOHZ\t\t(1<<TIF_NOHZ)\n#define _TIF_FIXADE\t\t(1<<TIF_FIXADE)\n#define _TIF_LOGADE\t\t(1<<TIF_LOGADE)\n#define _TIF_32BIT_REGS\t\t(1<<TIF_32BIT_REGS)\n#define _TIF_32BIT_ADDR\t\t(1<<TIF_32BIT_ADDR)\n#define _TIF_FPUBOUND\t\t(1<<TIF_FPUBOUND)\n#define _TIF_LOAD_WATCH\t\t(1<<TIF_LOAD_WATCH)\n#define _TIF_32BIT_FPREGS\t(1<<TIF_32BIT_FPREGS)\n#define _TIF_SYSCALL_TRACEPOINT\t(1<<TIF_SYSCALL_TRACEPOINT)\n\n#define _TIF_WORK_SYSCALL_ENTRY\t(_TIF_NOHZ | _TIF_SYSCALL_TRACE |\t\\\n\t\t\t\t _TIF_SYSCALL_AUDIT | \\\n\t\t\t\t _TIF_SYSCALL_TRACEPOINT | _TIF_SECCOMP)\n\n/* work to do in syscall_trace_leave() */\n#define _TIF_WORK_SYSCALL_EXIT\t(_TIF_NOHZ | _TIF_SYSCALL_TRACE |\t\\\n\t\t\t\t _TIF_SYSCALL_AUDIT | _TIF_SYSCALL_TRACEPOINT)\n\n/* work to do on interrupt/exception return */\n#define _TIF_WORK_MASK\t\t\\\n\t(_TIF_SIGPENDING | _TIF_NEED_RESCHED | _TIF_NOTIFY_RESUME)\n/* work to do on any return to u-space */\n#define _TIF_ALLWORK_MASK\t(_TIF_NOHZ | _TIF_WORK_MASK |\t\t\\\n\t\t\t\t _TIF_WORK_SYSCALL_EXIT |\t\t\\\n\t\t\t\t _TIF_SYSCALL_TRACEPOINT)\n\n/*\n * We stash processor id into a COP0 register to retrieve it fast\n * at kernel exception entry.\n */\n#if defined(CONFIG_MIPS_MT_SMTC)\n#define SMP_CPUID_REG\t\t2, 2\t/* TCBIND */\n#define ASM_SMP_CPUID_REG\t$2, 2\n#define SMP_CPUID_PTRSHIFT\t19\n#elif defined(CONFIG_MIPS_PGD_C0_CONTEXT)\n#define SMP_CPUID_REG\t\t20, 0\t/* XCONTEXT */\n#define ASM_SMP_CPUID_REG\t$20\n#define SMP_CPUID_PTRSHIFT\t48\n#else\n#define SMP_CPUID_REG\t\t4, 0\t/* CONTEXT */\n#define ASM_SMP_CPUID_REG\t$4\n#define SMP_CPUID_PTRSHIFT\t23\n#endif\n\n#ifdef CONFIG_64BIT\n#define SMP_CPUID_REGSHIFT\t(SMP_CPUID_PTRSHIFT + 3)\n#else\n#define SMP_CPUID_REGSHIFT\t(SMP_CPUID_PTRSHIFT + 2)\n#endif\n\n#ifdef CONFIG_MIPS_MT_SMTC\n#define ASM_CPUID_MFC0\t\tmfc0\n#define UASM_i_CPUID_MFC0\tuasm_i_mfc0\n#else\n#define ASM_CPUID_MFC0\t\tMFC0\n#define UASM_i_CPUID_MFC0\tUASM_i_MFC0\n#endif\n\n#endif /* __KERNEL__ */\n#endif /* _ASM_THREAD_INFO_H */\n"], "filenames": ["arch/mips/include/asm/thread_info.h"], "buggy_code_start_loc": [139], "buggy_code_end_loc": [140], "fixing_code_start_loc": [139], "fixing_code_end_loc": [141], "type": "CWE-264", "message": "arch/mips/include/asm/thread_info.h in the Linux kernel before 3.14.8 on the MIPS platform does not configure _TIF_SECCOMP checks on the fast system-call path, which allows local users to bypass intended PR_SET_SECCOMP restrictions by executing a crafted application without invoking a trace or audit subsystem.", "other": {"cve": {"id": "CVE-2014-4157", "sourceIdentifier": "security@debian.org", "published": "2014-06-23T11:21:19.217", "lastModified": "2018-12-18T14:36:08.597", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "arch/mips/include/asm/thread_info.h in the Linux kernel before 3.14.8 on the MIPS platform does not configure _TIF_SECCOMP checks on the fast system-call path, which allows local users to bypass intended PR_SET_SECCOMP restrictions by executing a crafted application without invoking a trace or audit subsystem."}, {"lang": "es", "value": "arch/mips/include/asm/thread_info.h en el kernel de Linux anterior a 3.14.8 en la plataforma MIPS no configura comprobaciones _TIF_SECCOMP en la ruta r\u00e1pida de llamadas del sistema, lo que permite a usuarios locales evadir restricciones PR_SET_SECCOMP mediante la ejecuci\u00f3n de una aplicaci\u00f3n manipulada sin la invocaci\u00f3n de una traza o un subsistema de auditoria."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-264"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.14.8", "matchCriteriaId": "07C0B41C-8466-4CBF-B996-6CCD9B07FEFD"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=137f7df8cead00688524c82360930845396b8a21", "source": "security@debian.org", "tags": ["Exploit", "Patch", "Vendor Advisory"]}, {"url": "http://openwall.com/lists/oss-security/2014/06/16/1", "source": "security@debian.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.14.8", "source": "security@debian.org", "tags": ["Vendor Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2014/06/17/17", "source": "security@debian.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=751417", "source": "security@debian.org", "tags": ["Mailing List", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/137f7df8cead00688524c82360930845396b8a21", "source": "security@debian.org", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/137f7df8cead00688524c82360930845396b8a21"}}