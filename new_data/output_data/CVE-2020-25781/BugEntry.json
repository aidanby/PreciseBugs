{"buggy_code": ["<?php\n# MantisBT - A PHP based bugtracking system\n\n# MantisBT is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 2 of the License, or\n# (at your option) any later version.\n#\n# MantisBT is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with MantisBT.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * File API\n *\n * @package CoreAPI\n * @subpackage FileAPI\n * @copyright Copyright 2000 - 2002  Kenzaburo Ito - kenito@300baud.org\n * @copyright Copyright 2002  MantisBT Team - mantisbt-dev@lists.sourceforge.net\n * @link http://www.mantisbt.org\n *\n * @uses access_api.php\n * @uses antispam_api.php\n * @uses authentication_api.php\n * @uses bug_api.php\n * @uses config_api.php\n * @uses constant_inc.php\n * @uses database_api.php\n * @uses gpc_api.php\n * @uses helper_api.php\n * @uses history_api.php\n * @uses project_api.php\n * @uses utility_api.php\n */\n\nrequire_api( 'access_api.php' );\nrequire_api( 'antispam_api.php' );\nrequire_api( 'authentication_api.php' );\nrequire_api( 'bug_api.php' );\nrequire_api( 'config_api.php' );\nrequire_api( 'constant_inc.php' );\nrequire_api( 'database_api.php' );\nrequire_api( 'gpc_api.php' );\nrequire_api( 'helper_api.php' );\nrequire_api( 'history_api.php' );\nrequire_api( 'project_api.php' );\nrequire_api( 'utility_api.php' );\n\nuse Mantis\\Exceptions\\ClientException;\nuse Mantis\\Exceptions\\ServiceException;\n\n$g_cache_file_count = array();\n\n/**\n * Attached specified files to issue.\n *\n * @param int $p_bug_id    The bug id.\n * @param array $p_files   The array of files, if null, then do nothing.\n * @param int $p_bugnote_id The bugnote id, or 0 if issue attachments.\n * @return array Array of file info arrays.\n */\nfunction file_attach_files( $p_bug_id, $p_files, $p_bugnote_id = 0 ) {\n\tif( $p_files === null || count( $p_files ) == 0 ) {\n\t\treturn array();\n\t}\n\n\t$t_file_infos = array();\n\tforeach( $p_files as $t_file ) {\n\t\tif( !empty( $t_file['name'] ) ) {\n\t\t\t# $p_bug_id, array $p_file, $p_table = 'bug', $p_title = '', $p_desc = '', $p_user_id = null, $p_date_added = 0, $p_skip_bug_update = false, $p_bugnote_id = 0\n\t\t\t$t_file_infos[] = file_add(\n\t\t\t\t$p_bug_id,\n\t\t\t\t$t_file,\n\t\t\t\t'bug',\n\t\t\t\t'', /* title */\n\t\t\t\t'', /* desc */\n\t\t\t\tnull, /* user_id */\n\t\t\t\t0, /* date_added */\n\t\t\t\t0, /* skip_bug_update */\n\t\t\t\t$p_bugnote_id );\n\t\t}\n\t}\n\n\treturn $t_file_infos;\n}\n\n/**\n * Gets the filename without the bug id prefix.\n * @param string $p_filename Filename.\n * @return string\n */\nfunction file_get_display_name( $p_filename ) {\n\t# Check if it's a project document filename (doc-0000000-filename)\n\t# or a bug attachment filename (0000000-filename)\n\t# for newer filenames, the filename in schema is correct.\n\t# This is important to handle filenames with '-'s properly\n\t$t_doc_match = '/^' . config_get( 'document_files_prefix' ) . '-\\d{7}-/';\n\t$t_name = preg_split( $t_doc_match, $p_filename );\n\tif( isset( $t_name[1] ) ) {\n\t\treturn $t_name[1];\n\t} else {\n\t\t$t_bug_match = '/^\\d{7}-/';\n\t\t$t_name = preg_split( $t_bug_match, $p_filename );\n\t\tif( isset( $t_name[1] ) ) {\n\t\t\treturn $t_name[1];\n\t\t} else {\n\t\t\treturn $p_filename;\n\t\t}\n\t}\n}\n\n/**\n * Fills the cache with the attachment count from a list of bugs\n * If the bug doesn't have attachments, cache its value as 0.\n * @global array $g_cache_file_count\n * @param array $p_bug_ids Array of bug ids\n * @return void\n */\nfunction file_bug_attachment_count_cache( array $p_bug_ids ) {\n\tglobal $g_cache_file_count;\n\n\tif( empty( $p_bug_ids ) ) {\n\t\treturn;\n\t}\n\n\t$t_ids_to_search = array();\n\tforeach( $p_bug_ids as $t_id ) {\n\t\t$c_id = (int)$t_id;\n\t\t$t_ids_to_search[$c_id] = $c_id;\n\t}\n\n\tdb_param_push();\n\t$t_params = array();\n\t$t_in_values = array();\n\tforeach( $t_ids_to_search as $t_id ) {\n\t\t$t_params[] = (int)$t_id;\n\t\t$t_in_values[] = db_param();\n\t}\n\n\t$t_query = 'SELECT B.id AS bug_id, COUNT(F.bug_id) AS attachments'\n\t\t\t. ' FROM {bug} B JOIN {bug_file} F ON ( B.id = F.bug_id )'\n\t\t\t. ' WHERE B.id IN (' . implode( ',', $t_in_values ) . ')'\n\t\t\t. ' GROUP BY B.id';\n\n\t$t_result = db_query( $t_query, $t_params );\n\twhile( $t_row = db_fetch_array( $t_result ) ) {\n\t\t$c_bug_id = (int)$t_row['bug_id'];\n\t\t$g_cache_file_count[$c_bug_id] = (int)$t_row['attachments'];\n\t\tunset( $t_ids_to_search[$c_bug_id] );\n\t}\n\n\t# set bugs without result to 0\n\tforeach( $t_ids_to_search as $t_id ) {\n\t\t$g_cache_file_count[$t_id] = 0;\n\t}\n}\n\n/**\n * Check the number of attachments a bug has (if any)\n * @param integer $p_bug_id A bug identifier.\n * @return integer\n */\nfunction file_bug_attachment_count( $p_bug_id ) {\n\tglobal $g_cache_file_count;\n\n\t# If it's not in cache, load the value\n\tif( !isset( $g_cache_file_count[$p_bug_id] ) ) {\n\t\tfile_bug_attachment_count_cache( array( (int)$p_bug_id ) );\n\t}\n\n\treturn $g_cache_file_count[$p_bug_id];\n}\n\n/**\n * Clear a bug from the cache or all bugs if no bug id specified.\n * @param integer $p_bug_id A bug identifier to clear (optional).\n * @return boolean\n * @access public\n */\nfunction file_bug_attachment_count_clear_cache( $p_bug_id = null ) {\n\tglobal $g_cache_file_count;\n\n\tif( null === $p_bug_id ) {\n\t\t$g_cache_file_count = array();\n\t} else {\n\t\tunset( $g_cache_file_count[(int)$p_bug_id] );\n\t}\n\n\treturn true;\n}\n\n/**\n * Check if a specific bug has attachments\n * @param integer $p_bug_id A bug identifier.\n * @return boolean\n */\nfunction file_bug_has_attachments( $p_bug_id ) {\n\tif( file_bug_attachment_count( $p_bug_id ) > 0 ) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\n/**\n * Check if the current user can view or download attachments.\n *\n * Generic call used by\n * - {@see file_can_view_bug_attachments()}\n * - {@see file_can_view_bugnote_attachments}\n * - {@see file_can_download_bug_attachments()}\n * - {@see file_can_download_bugnote_attachments}\n *\n * @param string   $p_action            'view' or 'download'\n * @param int      $p_bug_id            A bug identifier\n * @param int      $p_uploader_user_id  The user who uploaded the attachment\n *\n * @return bool\n *\n * @internal Should not be used outside of File API.\n */\nfunction file_can_view_or_download( $p_action, $p_bug_id, $p_uploader_user_id ) {\n\tswitch( $p_action ) {\n\t\tcase 'view':\n\t\t\t$t_threshold_global = 'view_attachments_threshold';\n\t\t\t$t_threshold_own = 'allow_view_own_attachments';\n\t\t\tbreak;\n\t\tcase 'download':\n\t\t\t$t_threshold_global = 'download_attachments_threshold';\n\t\t\t$t_threshold_own = 'allow_download_own_attachments';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttrigger_error( ERROR_GENERIC, ERROR );\n\t}\n\n\t$t_project_id = bug_get_field( $p_bug_id, 'project_id' );\n\t$t_access_global = config_get( $t_threshold_global,null, null, $t_project_id );\n\n\t$t_can_access = access_has_bug_level( $t_access_global, $p_bug_id );\n\tif( $t_can_access ) {\n\t\treturn true;\n\t}\n\n\t$t_uploaded_by_me = auth_get_current_user_id() == $p_uploader_user_id;\n\t$t_view_own = config_get( $t_threshold_own, null, null, $t_project_id );\n\treturn $t_uploaded_by_me && $t_view_own;\n}\n\n/**\n * Check if the current user can view attachments for the specified bug.\n *\n * @param integer $p_bug_id           A bug identifier.\n * @param integer $p_uploader_user_id A user identifier.\n *\n * @return boolean\n */\nfunction file_can_view_bug_attachments( $p_bug_id, $p_uploader_user_id = null ) {\n\treturn file_can_view_or_download( 'view', $p_bug_id, $p_uploader_user_id );\n}\n\n/**\n * Check if the current user can download attachments for the specified bug.\n *\n * @param integer $p_bug_id           A bug identifier.\n * @param integer $p_uploader_user_id The user who uploaded the attachment.\n *\n * @return boolean\n */\nfunction file_can_download_bug_attachments( $p_bug_id, $p_uploader_user_id = null ) {\n\treturn file_can_view_or_download( 'download', $p_bug_id, $p_uploader_user_id );\n}\n\n/**\n * Check if the current user can delete attachments from the specified bug.\n * @param integer $p_bug_id           A bug identifier.\n * @param integer $p_uploader_user_id A user identifier.\n * @return boolean\n */\nfunction file_can_delete_bug_attachments( $p_bug_id, $p_uploader_user_id = null ) {\n\tif( bug_is_readonly( $p_bug_id ) ) {\n\t\treturn false;\n\t}\n\t$t_uploaded_by_me = auth_get_current_user_id() === $p_uploader_user_id;\n\t$t_can_delete = access_has_bug_level( config_get( 'delete_attachments_threshold' ), $p_bug_id );\n\t$t_can_delete = $t_can_delete || ( $t_uploaded_by_me && config_get( 'allow_delete_own_attachments' ) );\n\treturn $t_can_delete;\n}\n\n/**\n * Get icon corresponding to the specified filename\n * returns an associative array with \"url\" and \"alt\" text.\n * @param string $p_display_filename Filename.\n * @return array\n */\nfunction file_get_icon_url( $p_display_filename ) {\n\t$t_file_type_icons = config_get_global( 'file_type_icons' );\n\n\t$t_ext = mb_strtolower( pathinfo( $p_display_filename, PATHINFO_EXTENSION ) );\n\tif( is_blank( $t_ext ) || !isset( $t_file_type_icons[$t_ext] ) ) {\n\t\t$t_ext = '?';\n\t}\n\n\t$t_name = $t_file_type_icons[$t_ext];\n\treturn array( 'url' => $t_name, 'alt' => $t_ext );\n}\n\n/**\n * Combines a path and a file name making sure that the separator exists.\n *\n * @param string $p_path     The path.\n * @param string $p_filename The file name.\n * @return string The combined full path.\n */\nfunction file_path_combine( $p_path, $p_filename ) {\n\t$t_path = rtrim( $p_path, '/\\\\' ) . DIRECTORY_SEPARATOR;\n\n\t$t_path .= $p_filename;\n\n\treturn $t_path;\n}\n\n/**\n * Normalizes the disk file path based on the following algorithm:\n * 1. If disk file exists, then return as is.\n * 2. If not, and a project path is available, then check with that, if exists return it.\n * 3. If not, then use default upload path, then check with that, if exists return it.\n * 4. If disk file does not include a path, then return expected path based on project path or default path.\n * 5. Otherwise return as is.\n *\n * @param string  $p_diskfile   The disk file (full path or just filename).\n * @param integer $p_project_id The project id - shouldn't be 0 (ALL_PROJECTS).\n * @return string The normalized full path.\n */\nfunction file_normalize_attachment_path( $p_diskfile, $p_project_id ) {\n\tif( file_exists( $p_diskfile ) ) {\n\t\treturn $p_diskfile;\n\t}\n\n\t$t_basename = basename( $p_diskfile );\n\n\t$t_expected_file_path = '';\n\n\tif( $p_project_id != ALL_PROJECTS ) {\n\t\t$t_path = project_get_field( $p_project_id, 'file_path' );\n\t\tif( !is_blank( $t_path ) ) {\n\t\t\t$t_diskfile = file_path_combine( $t_path, $t_basename );\n\n\t\t\tif( file_exists( $t_diskfile ) ) {\n\t\t\t\treturn $t_diskfile;\n\t\t\t}\n\n\t\t\t# if we don't find the file, then this is the path we want to return.\n\t\t\t$t_expected_file_path = $t_diskfile;\n\t\t}\n\t}\n\n\t$t_path = config_get_global( 'absolute_path_default_upload_folder' );\n\tif( !is_blank( $t_path ) ) {\n\t\t$t_diskfile = file_path_combine( $t_path, $t_basename );\n\n\t\tif( file_exists( $t_diskfile ) ) {\n\t\t\treturn $t_diskfile;\n\t\t}\n\n\t\t# if the expected path not set to project directory, then set it to default directory.\n\t\tif( is_blank( $t_expected_file_path ) ) {\n\t\t\t$t_expected_file_path = $t_diskfile;\n\t\t}\n\t}\n\n\t# if diskfile doesn't include a path, then use the expected filename.\n\tif( ( strstr( $p_diskfile, DIRECTORY_SEPARATOR ) === false ||\n\t       strstr( $p_diskfile, '\\\\' ) === false ) &&\n\t     !is_blank( $t_expected_file_path ) ) {\n\t    return $t_expected_file_path;\n\t}\n\n\t# otherwise return as is.\n\treturn $p_diskfile;\n}\n\n/**\n * Gets an array of attachments that are visible to the currently logged in user.\n * Each element of the array contains the following:\n * display_name - The attachment display name (i.e. file name dot extension)\n * size - The attachment size in bytes.\n * date_added - The date where the attachment was added.\n * can_download - true: logged in user has access to download the attachment, false: otherwise.\n * diskfile - The name of the file on disk.  Typically this is a hash without an extension.\n * download_url - The download URL for the attachment (only set if can_download is true).\n * exists - Applicable for DISK attachments.  true: file exists, otherwise false.\n * can_delete - The logged in user can delete the attachments.\n * preview - true: the attachment should be previewable, otherwise false.\n * type - Can be \"image\", \"text\" or empty for other types.\n * alt - The alternate text to be associated with the icon.\n * icon - array with icon information, contains 'url' and 'alt' elements.\n * @param integer $p_bug_id A bug identifier.\n * @return array\n */\nfunction file_get_visible_attachments( $p_bug_id ) {\n\t$t_attachment_rows = bug_get_attachments( $p_bug_id );\n\t$t_visible_attachments = array();\n\n\t$t_attachments_count = count( $t_attachment_rows );\n\tif( $t_attachments_count === 0 ) {\n\t\treturn $t_visible_attachments;\n\t}\n\n\t$t_attachments = array();\n\n\t$t_preview_text_ext = config_get( 'preview_text_extensions' );\n\t$t_preview_image_ext = config_get( 'preview_image_extensions' );\n\t$t_attachments_view_threshold = config_get( 'view_attachments_threshold' );\n\n\t$t_image_previewed = false;\n\tfor( $i = 0;$i < $t_attachments_count;$i++ ) {\n\t\t$t_row = $t_attachment_rows[$i];\n\t\t$t_user_id = (int)$t_row['user_id'];\n\n\t\t# This covers access checks for issue attachments\n\t\tif( !file_can_view_bug_attachments( $p_bug_id, $t_user_id ) ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t# This covers access checks for issue note attachments\n\t\t$t_attachment_note_id = (int)$t_row['bugnote_id'];\n\t\tif( $t_attachment_note_id !== 0 ) {\n\t\t\tif( bugnote_get_field( $t_attachment_note_id, 'view_state' ) != VS_PUBLIC ) {\n\t\t\t\tif( !access_has_bugnote_level( $t_attachments_view_threshold, $t_attachment_note_id ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t$t_id = (int)$t_row['id'];\n\t\t$t_filename = $t_row['filename'];\n\t\t$t_filesize = $t_row['filesize'];\n\t\t$t_diskfile = file_normalize_attachment_path( $t_row['diskfile'], bug_get_field( $p_bug_id, 'project_id' ) );\n\t\t$t_date_added = $t_row['date_added'];\n\n\t\t$t_attachment = array();\n\t\t$t_attachment['id'] = $t_id;\n\t\t$t_attachment['user_id'] = $t_user_id;\n\t\t$t_attachment['display_name'] = file_get_display_name( $t_filename );\n\t\t$t_attachment['size'] = (int)$t_filesize;\n\t\t$t_attachment['date_added'] = $t_date_added;\n\t\t$t_attachment['diskfile'] = $t_diskfile;\n\t\t$t_attachment['file_type'] = $t_row['file_type'];\n\t\t$t_attachment['bugnote_id'] = (int)$t_row['bugnote_id'];\n\n\t\t$t_attachment['can_download'] = file_can_download_bug_attachments( $p_bug_id, (int)$t_row['user_id'] );\n\t\t$t_attachment['can_delete'] = file_can_delete_bug_attachments( $p_bug_id, (int)$t_row['user_id'] );\n\n\t\tif( $t_attachment['can_download'] ) {\n\t\t\t$t_attachment['download_url'] = 'file_download.php?file_id=' . $t_id . '&type=bug';\n\t\t}\n\n\t\tif( $t_image_previewed ) {\n\t\t\t$t_image_previewed = false;\n\t\t}\n\n\t\t$t_attachment['exists'] = config_get( 'file_upload_method' ) != DISK || file_exists( $t_diskfile );\n\t\t$t_attachment['icon'] = file_get_icon_url( $t_attachment['display_name'] );\n\n\t\t$t_attachment['preview'] = false;\n\t\t$t_attachment['type'] = '';\n\n\t\t$t_ext = strtolower( pathinfo( $t_attachment['display_name'], PATHINFO_EXTENSION ) );\n\t\t$t_attachment['alt'] = $t_ext;\n\n\t\tif( $t_attachment['exists'] && $t_attachment['can_download'] && $t_filesize != 0 ) {\n\t\t\t$t_preview = $t_filesize <= config_get( 'preview_attachments_inline_max_size' );\n\n\t\t\tif( stripos( $t_attachment['file_type'], 'text/' ) === 0 || in_array( $t_ext, $t_preview_text_ext, true ) ) {\n\t\t\t\t$t_attachment['preview'] = $t_preview;\n\t\t\t\t$t_attachment['type'] = 'text';\n\t\t\t} else if( stripos( $t_attachment['file_type'], 'image/' ) === 0 || in_array( $t_ext, $t_preview_image_ext, true ) ) {\n\t\t\t\t$t_attachment['preview'] = $t_preview;\n\t\t\t\t$t_attachment['type'] = 'image';\n\t\t\t} else if( stripos( $t_attachment['file_type'], 'audio/' ) === 0 ) {\n\t\t\t\t$t_attachment['preview'] = $t_preview;\n\t\t\t\t$t_attachment['type'] = 'audio';\n\t\t\t} else if( stripos( $t_attachment['file_type'], 'video/' ) === 0 ) {\n\t\t\t\t$t_attachment['preview'] = $t_preview;\n\t\t\t\t$t_attachment['type'] = 'video';\n\t\t\t}\n\t\t}\n\n\t\t$t_attachments[] = $t_attachment;\n\t}\n\n\treturn $t_attachments;\n}\n\n/**\n * delete all files that are associated with the given bug\n * @param integer $p_bug_id A bug identifier.\n * @return boolean\n */\nfunction file_delete_attachments( $p_bug_id ) {\n\t$t_method = config_get( 'file_upload_method' );\n\n\t# Delete files from disk\n\tdb_param_push();\n\t$t_query = 'SELECT diskfile, filename FROM {bug_file} WHERE bug_id=' . db_param();\n\t$t_result = db_query( $t_query, array( $p_bug_id ) );\n\n\t$t_file_count = db_num_rows( $t_result );\n\tif( 0 == $t_file_count ) {\n\t\treturn true;\n\t}\n\n\tif( DISK == $t_method ) {\n\t\tfor( $i = 0; $i < $t_file_count; $i++ ) {\n\t\t\t$t_row = db_fetch_array( $t_result );\n\n\t\t\t$t_local_diskfile = file_normalize_attachment_path( $t_row['diskfile'], bug_get_field( $p_bug_id, 'project_id' ) );\n\t\t\tfile_delete_local( $t_local_diskfile );\n\t\t}\n\t}\n\n\t# Delete the corresponding db records\n\tdb_param_push();\n\t$t_query = 'DELETE FROM {bug_file} WHERE bug_id=' . db_param();\n\tdb_query( $t_query, array( $p_bug_id ) );\n\n\t# db_query() errors on failure so:\n\treturn true;\n}\n\n/**\n * Delete all files that are associated with the given bug note.\n * @param integer $p_bug_id A bug identifier.\n * @param integer $p_bugnote_id A bugnote identifier.\n * @return boolean\n */\nfunction file_delete_bugnote_attachments( $p_bug_id, $p_bugnote_id ) {\n\tdb_param_push();\n\t$t_query = 'SELECT id, diskfile, filename FROM {bug_file} WHERE bug_id=' . db_param() . ' AND bugnote_id=' . db_param();\n\t$t_result = db_query( $t_query, array( $p_bug_id, $p_bugnote_id ) );\n\n\twhile( $t_row = db_fetch_array( $t_result ) ) {\n\t\tfile_delete( (int)$t_row['id'], 'bug', $p_bugnote_id );\n\t}\n\n\t# db_query() errors on failure so:\n\treturn true;\n}\n\n/**\n * Link the specified file to the specified bugnote.\n * \n * @param integer $p_file_id The file id.\n * @param integer $p_bugnote_id A bugnote identifier.\n * @return void\n */\nfunction file_link_to_bugnote( $p_file_id, $p_bugnote_id ) {\n\tdb_param_push();\n\n\t$t_query = 'UPDATE {bug_file} SET bugnote_id=' . db_param() . ' WHERE id=' . db_param();\n\tdb_query( $t_query, array( $p_bugnote_id, $p_file_id ) );\n}\n\n/**\n * Delete files by project\n * @param integer $p_project_id A project identifier.\n * @return void\n */\nfunction file_delete_project_files( $p_project_id ) {\n\t$t_method = config_get( 'file_upload_method' );\n\n\t# Delete the file physically (if stored via DISK)\n\tif( DISK == $t_method ) {\n\t\t# Delete files from disk\n\t\tdb_param_push();\n\t\t$t_query = 'SELECT diskfile, filename FROM {project_file} WHERE project_id=' . db_param();\n\t\t$t_result = db_query( $t_query, array( (int)$p_project_id ) );\n\n\t\t$t_file_count = db_num_rows( $t_result );\n\n\t\tfor( $i = 0;$i < $t_file_count;$i++ ) {\n\t\t\t$t_row = db_fetch_array( $t_result );\n\n\t\t\t$t_local_diskfile = file_normalize_attachment_path( $t_row['diskfile'], $p_project_id );\n\t\t\tfile_delete_local( $t_local_diskfile );\n\t\t}\n\t}\n\n\t# Delete the corresponding database records\n\tdb_param_push();\n\t$t_query = 'DELETE FROM {project_file} WHERE project_id=' . db_param();\n\tdb_query( $t_query, array( (int)$p_project_id ) );\n}\n\n/**\n * Delete a local file even if it is read-only.\n * @param string $p_filename File name.\n * @return void\n */\nfunction file_delete_local( $p_filename ) {\n\tif( file_exists( $p_filename ) ) {\n\t\tchmod( $p_filename, 0775 );\n\t\tunlink( $p_filename );\n\t}\n}\n\n/**\n * Return the specified field value\n * @param integer $p_file_id    File identifier.\n * @param string  $p_field_name Database field name to retrieve.\n * @param string  $p_table      Database table name.\n * @return string\n */\nfunction file_get_field( $p_file_id, $p_field_name, $p_table = 'bug' ) {\n\t$t_bug_file_table = db_get_table( $p_table . '_file' );\n\tif( !db_field_exists( $p_field_name, $t_bug_file_table ) ) {\n\t\ttrigger_error( ERROR_DB_FIELD_NOT_FOUND, ERROR );\n\t}\n\n\tdb_param_push();\n\t$t_query = 'SELECT ' . $p_field_name . ' FROM ' . $t_bug_file_table . ' WHERE id=' . db_param();\n\t$t_result = db_query( $t_query, array( (int)$p_file_id ), 1 );\n\n\treturn db_result( $t_result );\n}\n\n/**\n * Delete File\n * @param integer $p_file_id File identifier.\n * @param string  $p_table   Table identifier.\n * @param integer $p_bugnote_id The bugnote id the file is attached to or 0 if attached to issue.\n * @return boolean\n */\nfunction file_delete( $p_file_id, $p_table = 'bug', $p_bugnote_id = 0 ) {\n\t$t_upload_method = config_get( 'file_upload_method' );\n\n\t$c_file_id = (int)$p_file_id;\n\t$t_filename = file_get_field( $p_file_id, 'filename', $p_table );\n\t$t_diskfile = file_get_field( $p_file_id, 'diskfile', $p_table );\n\n\tif( $p_table == 'bug' ) {\n\t\t$t_bug_id = file_get_field( $p_file_id, 'bug_id', $p_table );\n\t\t$t_project_id = bug_get_field( $t_bug_id, 'project_id' );\n\t} else {\n\t\t$t_project_id = file_get_field( $p_file_id, 'project_id', $p_table );\n\t}\n\n\tif( DISK == $t_upload_method ) {\n\t\t$t_local_disk_file = file_normalize_attachment_path( $t_diskfile, $t_project_id );\n\t\tif( file_exists( $t_local_disk_file ) ) {\n\t\t\tfile_delete_local( $t_local_disk_file );\n\t\t}\n\t}\n\n\tif( 'bug' == $p_table ) {\n\t\t# log file deletion\n\t\thistory_log_event_special( $t_bug_id, FILE_DELETED, file_get_display_name( $t_filename ), $p_bugnote_id );\n\t}\n\n\t$t_file_table = db_get_table( $p_table . '_file' );\n\tdb_param_push();\n\t$t_query = 'DELETE FROM ' . $t_file_table . ' WHERE id=' . db_param();\n\tdb_query( $t_query, array( $c_file_id ) );\n\treturn true;\n}\n\n/**\n * File type check\n * @param string $p_file_name File name.\n * @return boolean\n */\nfunction file_type_check( $p_file_name ) {\n\t$t_allowed_files = config_get( 'allowed_files' );\n\t$t_disallowed_files = config_get( 'disallowed_files' );\n\n\t# grab extension\n\t$t_extension = pathinfo( $p_file_name, PATHINFO_EXTENSION );\n\n\t# check against disallowed files\n\tif( !is_blank( $t_disallowed_files ) ) {\n\t\t$t_disallowed_arr = explode( ',', $t_disallowed_files );\n\t\tforeach( $t_disallowed_arr as $t_val ) {\n\t\t\tif( 0 == strcasecmp( $t_val, $t_extension ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\t# if the allowed list is note populated then the file must be allowed\n\tif( is_blank( $t_allowed_files ) ) {\n\t\treturn true;\n\t}\n\n\t# check against allowed files\n\t$t_allowed_arr = explode( ',', $t_allowed_files );\n\tforeach( $t_allowed_arr as $t_val ) {\n\t\tif( 0 == strcasecmp( $t_val, $t_extension ) ) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n/**\n * clean file name by removing sensitive characters and replacing them with underscores\n * @param string $p_filename File name.\n * @return string\n */\nfunction file_clean_name( $p_filename ) {\n\treturn preg_replace( '/[\\/*?\"<>|\\\\ :&]/', '_', $p_filename );\n}\n\n/**\n * Generate a UNIQUE string for a given file path to use as the identifier for the file\n * The string returned should be 32 characters in length\n * @param string $p_filepath File path.\n * @return string\n */\nfunction file_generate_unique_name( $p_filepath ) {\n\tdo {\n\t\t$t_string = md5( crypto_generate_random_string( 32, false ) );\n\t} while( !diskfile_is_name_unique( $t_string, $p_filepath ) );\n\n\treturn $t_string;\n}\n\n/**\n * Validates that the given disk file name identifier is unique, checking both\n * in the DB tables (bug and project) and on disk.\n * This ensures that in case a file has been deleted from disk but its record\n * remains in the DB, we never get in a situation where the DB points to a file\n * which is not the originally uploaded one.\n * @param string $p_name     File name.\n * @param string $p_filepath File path.\n * @return boolean true if unique\n */\nfunction diskfile_is_name_unique( $p_name, $p_filepath ) {\n\t$c_name = $p_filepath . $p_name;\n\n\tdb_param_push();\n\t$t_query = 'SELECT count(*)\n\t\tFROM (\n\t\t\tSELECT diskfile FROM {bug_file} WHERE diskfile=' . db_param() . '\n\t\t\tUNION\n\t\t\tSELECT diskfile FROM {project_file} WHERE diskfile=' . db_param() . '\n\t\t\t) f';\n\t$t_result = db_query( $t_query, array( $c_name, $c_name) );\n\t$t_count = db_result( $t_result );\n\n\treturn ( $t_count == 0 ) && !file_exists( $c_name );\n}\n\n/**\n * Validates that the given file name is unique in the given context (we don't\n * allow multiple attachments with the same name for a given bug or project)\n * @param string  $p_name   File name.\n * @param integer $p_bug_id A bug identifier (not used for project files).\n * @param string  $p_table  Optional file table to check: 'project' or 'bug' (default).\n * @return boolean true if unique\n */\nfunction file_is_name_unique( $p_name, $p_bug_id, $p_table = 'bug' ) {\n\t$t_file_table = db_get_table( \"${p_table}_file\" );\n\n\tdb_param_push();\n\t$t_query = 'SELECT COUNT(*) FROM ' . $t_file_table . ' WHERE filename=' . db_param();\n\t$t_param = array( $p_name );\n\tif( $p_table == 'bug' ) {\n\t\t$t_query .= ' AND bug_id=' . db_param();\n\t\t$t_param[] = $p_bug_id;\n\t}\n\n\t$t_result = db_query( $t_query, $t_param );\n\t$t_count = db_result( $t_result );\n\n\treturn ( $t_count == 0 );\n}\n\n/**\n * Add a file to the system using the configured storage method\n *\n * If file was not uploaded by the browser standard POST method, set value\n * for key `browser_upload` on $p_file to false.  Otherwise, the file_add()\n * operation will fail.\n *\n * @param integer $p_bug_id          The bug id (should be 0 when adding project doc).\n * @param array   $p_file            The uploaded file info, as retrieved from gpc_get_file().\n * @param string  $p_table           Either 'bug' or 'project' depending on attachment type.\n * @param string  $p_title           File title.\n * @param string  $p_desc            File description.\n * @param integer $p_user_id         User id (defaults to current user).\n * @param integer $p_date_added      Date added.\n * @param boolean $p_skip_bug_update Skip bug last modification update (useful when importing bug attachments).\n * @param int     $p_bugnote_id      The bugnote id or 0 if associated with the issue.\n * @return array The file info array (keys: name, size)\n */\nfunction file_add( $p_bug_id, array $p_file, $p_table = 'bug', $p_title = '', $p_desc = '', $p_user_id = null, $p_date_added = 0, $p_skip_bug_update = false, $p_bugnote_id = 0 ) {\n\t$t_file_info = array();\n\n\tif( !isset( $p_file['error'] ) ) {\n\t\t$p_file['error'] = UPLOAD_ERR_OK;\n\t}\n\n\tif( !isset( $p_file['browser_upload'] ) ) {\n\t\t$p_file['browser_upload'] = true;\n\t}\n\n\t$t_tmp_file = $p_file['tmp_name'];\n\n\t# Override passed value with one detected by PHP (if available).\n\t# If PHP can't detect it, then use supplied value.\n\t# If no value supplied, then default to a reasonable value.\n\t# The value will be overridden by PHP anyway if content type is\n\t# known at rendering time.\n\t$t_type = file_get_mime_type( $t_tmp_file );\n\tif( $t_type !== false ) {\n\t\t$p_file['type'] = $t_type;\n\t} else if( !isset( $p_file['type'] ) ) {\n\t\t$p_file['type'] = 'application/octet-stream';\n\t}\n\n\tfile_ensure_uploaded( $p_file );\n\t$t_file_name = $p_file['name'];\n\n\tif( !file_type_check( $t_file_name ) ) {\n\t\tthrow new ClientException(\n\t\t\tsprintf( \"File '%s' type not allowed\", $t_file_name ),\n\t\t\tERROR_FILE_NOT_ALLOWED\n\t\t);\n\t}\n\n\t$t_org_filename = $t_file_name;\n\t$t_suffix_id = 1;\n\n\twhile( !file_is_name_unique( $t_file_name, $p_bug_id ) ) {\n\t\t$t_suffix_id++;\n\n\t\t$t_dot_index = strripos( $t_org_filename, '.' );\n\t\tif( $t_dot_index === false ) {\n\t\t\t$t_file_name = $t_org_filename . '-' . $t_suffix_id;\n\t\t} else {\n\t\t\t$t_extension = substr( $t_org_filename, $t_dot_index, strlen( $t_org_filename ) - $t_dot_index );\n\t\t\t$t_file_name = substr( $t_org_filename, 0, $t_dot_index ) . '-' . $t_suffix_id . $t_extension;\n\t\t}\n\t}\n\n\t$t_file_info['name'] = $t_file_name;\n\tantispam_check();\n\n\t$t_file_size = filesize( $t_tmp_file );\n\tif( 0 == $t_file_size ) {\n\t\tthrow new ClientException(\n\t\t\tsprintf( \"File '%s' not uploaded\", $t_file_name ),\n\t\t\tERROR_FILE_NO_UPLOAD_FAILURE );\n\t}\n\n\t$t_file_info['size'] = $t_file_size;\n\n\t$t_max_file_size = (int)min( ini_get_number( 'upload_max_filesize' ), ini_get_number( 'post_max_size' ), config_get( 'max_file_size' ) );\n\tif( $t_file_size > $t_max_file_size ) {\n\t\tthrow new ClientException(\n\t\t\tsprintf( \"File '%s' too big\", $t_file_name ),\n\t\t\tERROR_FILE_TOO_BIG );\n\t}\n\n\tif( 'bug' == $p_table ) {\n\t\t$t_project_id = bug_get_field( $p_bug_id, 'project_id' );\n\t\t$t_id = (int)$p_bug_id;\n\t} else {\n\t\t$t_project_id = helper_get_current_project();\n\t\t$t_id = $t_project_id;\n\t}\n\n\tif( $p_user_id === null ) {\n\t\t$p_user_id = auth_get_current_user_id();\n\t}\n\n\tif( $p_date_added <= 0 ) {\n\t\t$p_date_added = db_now();\n\t}\n\n\tif( $t_project_id == ALL_PROJECTS ) {\n\t\t$t_file_path = config_get_global( 'absolute_path_default_upload_folder' );\n\t} else {\n\t\t$t_file_path = project_get_field( $t_project_id, 'file_path' );\n\t\tif( is_blank( $t_file_path ) ) {\n\t\t\t$t_file_path = config_get_global( 'absolute_path_default_upload_folder' );\n\t\t}\n\t}\n\n\t$t_unique_name = file_generate_unique_name( $t_file_path );\n\t$t_method = config_get( 'file_upload_method' );\n\n\tswitch( $t_method ) {\n\t\tcase DISK:\n\t\t\tfile_ensure_valid_upload_path( $t_file_path );\n\n\t\t\t$t_disk_file_name = $t_file_path . $t_unique_name;\n\t\t\tif( !file_exists( $t_disk_file_name ) ) {\n\t\t\t\tif( $p_file['browser_upload'] ) {\n\t\t\t\t\tif( !move_uploaded_file( $t_tmp_file, $t_disk_file_name ) ) {\n\t\t\t\t\t\tthrow new ServiceException(\n\t\t\t\t\t\t\t'Unable to move uploaded file',\n\t\t\t\t\t\t\tERROR_FILE_MOVE_FAILED\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif( !copy( $t_tmp_file, $t_disk_file_name ) || !unlink( $t_tmp_file ) ) {\n\t\t\t\t\t\tthrow new ServiceException(\n\t\t\t\t\t\t\t'Unable to move uploaded file',\n\t\t\t\t\t\t\tERROR_FILE_MOVE_FAILED\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tchmod( $t_disk_file_name, config_get( 'attachments_file_permissions' ) );\n\n\t\t\t\t$c_content = '';\n\t\t\t} else {\n\t\t\t\tthrow new ClientException( 'Duplicate file', ERROR_FILE_DUPLICATE );\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DATABASE:\n\t\t\t$c_content = db_prepare_binary_string( fread( fopen( $t_tmp_file, 'rb' ), $t_file_size ) );\n\t\t\t$t_file_path = '';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new ServiceException( 'Unknown file upload method', ERROR_GENERIC );\n\t}\n\n\t$t_file_table = db_get_table( $p_table . '_file' );\n\t$t_id_col = $p_table . '_id';\n\n\tdb_param_push();\n\n\t$t_param = array(\n\t\t$t_id_col     => $t_id,\n\t\t'title'       => $p_title,\n\t\t'description' => $p_desc,\n\t\t'diskfile'    => $t_unique_name,\n\t\t'filename'    => $t_file_name,\n\t\t'folder'      => $t_file_path,\n\t\t'filesize'    => $t_file_size,\n\t\t'file_type'   => $p_file['type'],\n\t\t'date_added'  => $p_date_added,\n\t\t'user_id'     => (int)$p_user_id\n\t);\n\tif( 'bug' == $p_table ) {\n\t\t$t_param['bugnote_id'] = is_null( $p_bugnote_id ) ? null : (int)$p_bugnote_id;\n\t}\n\t# Oracle has to update BLOBs separately\n\tif( !db_is_oracle() ) {\n\t\t$t_param['content'] = $c_content;\n\t}\n\n\t$t_query_param = db_param();\n\tfor( $i = 1; $i < count( $t_param ); $i++ ) {\n\t\t$t_query_param .= ', ' . db_param();\n\t}\n\n\t$t_query = 'INSERT INTO ' . $t_file_table . '\n\t\t( ' . implode( ', ', array_keys( $t_param ) ) . ' )\n\tVALUES\n\t\t( ' . $t_query_param . ' )';\n\tdb_query( $t_query, array_values( $t_param ) );\n\n\t$t_file_info['id'] = db_insert_id( $t_file_table );\n\n\tif( db_is_oracle() ) {\n\t\tdb_update_blob( $t_file_table, 'content', $c_content, \"diskfile='$t_unique_name'\" );\n\t}\n\n\tif( 'bug' == $p_table ) {\n\t\t# update the last_updated date\n\t\tif( !$p_skip_bug_update ) {\n\t\t\tbug_update_date( $p_bug_id );\n\t\t}\n\n\t\t# log file added to bug history\n\t\thistory_log_event_special( $p_bug_id, FILE_ADDED, $t_file_name, $p_bugnote_id );\n\t}\n\n\treturn $t_file_info;\n}\n\n/**\n * Return true if file uploading is enabled (in our config and PHP's), false otherwise\n * @return boolean\n */\nfunction file_is_uploading_enabled() {\n\tif( ini_get_bool( 'file_uploads' ) && ( ON == config_get( 'allow_file_upload' ) ) ) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\n/**\n * Check if the user can upload files for this project\n * return true if they can, false otherwise\n * the project defaults to the current project and the user to the current user\n * @param integer $p_project_id A project identifier.\n * @param integer $p_user_id    A user identifier.\n * @return boolean\n */\nfunction file_allow_project_upload( $p_project_id = null, $p_user_id = null ) {\n\tif( null === $p_project_id ) {\n\t\t$p_project_id = helper_get_current_project();\n\t}\n\tif( null === $p_user_id ) {\n\t\t$p_user_id = auth_get_current_user_id();\n\t}\n\treturn( file_is_uploading_enabled() && ( access_has_project_level( config_get( 'upload_project_file_threshold' ), $p_project_id, $p_user_id ) ) );\n}\n\n/**\n * Check if the user can upload files for this bug\n * return true if they can, false otherwise\n * the user defaults to the current user\n *\n * if the bug null (the default) we answer whether the user can\n * upload a file to a new bug in the current project\n * @param integer $p_bug_id  A bug identifier.\n * @param integer $p_user_id A user identifier.\n * @param integer $p_project_id The project id to check for or null for bug project or current project.\n * @return boolean\n */\nfunction file_allow_bug_upload( $p_bug_id = null, $p_user_id = null, $p_project_id = null ) {\n\tif( null === $p_user_id ) {\n\t\t$p_user_id = auth_get_current_user_id();\n\t}\n\n\t# If uploads are disabled just return false\n\tif( !file_is_uploading_enabled() ) {\n\t\treturn false;\n\t}\n\n\tif( null === $p_bug_id ) {\n\t\t# new bug\n\t\t$t_project_id = $p_project_id === null ? helper_get_current_project() : $p_project_id;\n\n\t\t# the user must be the reporter if they're reporting a new bug\n\t\t$t_reporter = true;\n\t} else {\n\t\t# existing bug\n\t\t$t_project_id = bug_get_field( $p_bug_id, 'project_id' );\n\n\t\t# check if the user is the reporter of the bug\n\t\t$t_reporter = bug_is_user_reporter( $p_bug_id, $p_user_id );\n\t}\n\n\tif( $t_reporter && ( ON == config_get( 'allow_reporter_upload' ) ) ) {\n\t\treturn true;\n\t}\n\n\t# Check the access level against the config setting\n\treturn access_has_project_level( config_get( 'upload_bug_file_threshold' ), $t_project_id, $p_user_id );\n}\n\n/**\n * checks whether the specified upload path exists and is writable\n * @param string $p_upload_path Upload path.\n * @return void\n */\nfunction file_ensure_valid_upload_path( $p_upload_path ) {\n\tif( !file_exists( $p_upload_path ) || !is_dir( $p_upload_path ) || !is_writable( $p_upload_path ) || !is_readable( $p_upload_path ) ) {\n\t\tthrow new ServiceException(\n\t\t\t'Upload folder not valid',\n\t\t\tERROR_FILE_INVALID_UPLOAD_PATH );\n\t}\n}\n\n/**\n * Ensure a file was uploaded\n *\n * This function perform various checks for determining if the upload was successful\n *\n * @param array $p_file The uploaded file info, as retrieved from gpc_get_file().\n * @return void\n */\nfunction file_ensure_uploaded( array $p_file ) {\n\tswitch( $p_file['error'] ) {\n\t\tcase UPLOAD_ERR_INI_SIZE:\n\t\tcase UPLOAD_ERR_FORM_SIZE:\n\t\t\tthrow new ClientException(\n\t\t\t\tsprintf( \"File '%s' too big\", $p_file['name'] ),\n\t\t\t\tERROR_FILE_TOO_BIG );\n\n\t\tcase UPLOAD_ERR_PARTIAL:\n\t\tcase UPLOAD_ERR_NO_FILE:\n\t\t\tthrow new ClientException(\n\t\t\t\tsprintf( \"File '%s' upload failure\", $p_file['name'] ),\n\t\t\t\tERROR_FILE_NO_UPLOAD_FAILURE );\n\t}\n\n\tif( ( '' == $p_file['tmp_name'] ) || ( '' == $p_file['name'] ) ) {\n\t\tthrow new ClientException(\n\t\t\t'File name or path is empty',\n\t\t\tERROR_FILE_NO_UPLOAD_FAILURE );\n\t}\n\n\tif( !is_readable( $p_file['tmp_name'] ) ) {\n\t\tthrow new ClientException( 'File is not readable', ERROR_UPLOAD_FAILURE );\n\t}\n}\n\n/**\n * Return instance of fileinfo class\n * @return finfo instance of finfo class.\n */\nfunction file_create_finfo() {\n\t$t_info_file = config_get_global( 'fileinfo_magic_db_file' );\n\n\tif( is_blank( $t_info_file ) ) {\n\t\t$t_finfo = new finfo( FILEINFO_MIME );\n\t} else {\n\t\t$t_finfo = new finfo( FILEINFO_MIME, $t_info_file );\n\t}\n\n\treturn $t_finfo;\n}\n\n/**\n * Get mime type for the specified file.\n *\n * @param string $p_file_path The file path.\n * @return boolean|string The mime type or false on failure.\n */\nfunction file_get_mime_type( $p_file_path ) {\n\tif( !file_exists( $p_file_path ) ) {\n\t\treturn false;\n\t}\n\n\t$t_finfo = file_create_finfo();\n\treturn $t_finfo->file( $p_file_path );\n}\n\n/**\n * Get mime type for the specified content.\n *\n * @param string $p_content The content.\n * @return boolean|string The mime type or false on failure.\n */\nfunction file_get_mime_type_for_content( $p_content ) {\n\t$t_finfo = file_create_finfo();\n\treturn $t_finfo->buffer( $p_content );\n}\n\n/**\n * Get file content\n *\n * @param integer $p_file_id File identifier.\n * @param string  $p_type    File type (either 'bug' or 'doc').\n * @return array|boolean array containing file type and content or false on failure to retrieve file\n */\nfunction file_get_content( $p_file_id, $p_type = 'bug' ) {\n\t# we handle the case where the file is attached to a bug\n\t# or attached to a project as a project doc.\n\tdb_param_push();\n\tswitch( $p_type ) {\n\t\tcase 'bug':\n\t\t\t$t_query = 'SELECT * FROM {bug_file} WHERE id=' . db_param();\n\t\t\tbreak;\n\t\tcase 'doc':\n\t\t\t$t_query = 'SELECT * FROM {project_file} WHERE id=' . db_param();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn false;\n\t}\n\n\t$t_result = db_query( $t_query, array( $p_file_id ) );\n\t$t_row = db_fetch_array( $t_result );\n\n\tif( $p_type == 'bug' ) {\n\t\t$t_project_id = bug_get_field( $t_row['bug_id'], 'project_id' );\n\t} else {\n\t\t$t_project_id = $t_row['bug_id'];\n\t}\n\n\t$t_content_type = $t_row['file_type'];\n\n\tswitch( config_get( 'file_upload_method' ) ) {\n\t\tcase DISK:\n\t\t\t$t_local_disk_file = file_normalize_attachment_path( $t_row['diskfile'], $t_project_id );\n\n\t\t\tif( file_exists( $t_local_disk_file ) ) {\n\t\t\t\t$t_file_info_type = file_get_mime_type( $t_local_disk_file );\n\n\t\t\t\tif( $t_file_info_type !== false ) {\n\t\t\t\t\t$t_content_type = $t_file_info_type;\n\t\t\t\t}\n\n\t\t\t\treturn array( 'type' => $t_content_type, 'content' => file_get_contents( $t_local_disk_file ) );\n\t\t\t}\n\t\t\treturn false;\n\t\t\tbreak;\n\t\tcase DATABASE:\n\t\t\t$t_file_info_type = file_get_mime_type_for_content( $t_row['content'] );\n\n\t\t\tif( $t_file_info_type !== false ) {\n\t\t\t\t$t_content_type = $t_file_info_type;\n\t\t\t}\n\n\t\t\treturn array( 'type' => $t_content_type, 'content' => $t_row['content'] );\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttrigger_error( ERROR_GENERIC, ERROR );\n\t}\n}\n\n/**\n * Move any attachments as needed when a bug is moved from project to project.\n *\n * @param integer $p_bug_id        ID of bug containing attachments to be moved.\n * @param integer $p_project_id_to Destination project ID for the bug.\n * @return void\n *\n * @todo: this function can't cope with source or target storing attachments in DB\n */\nfunction file_move_bug_attachments( $p_bug_id, $p_project_id_to ) {\n\t$t_project_id_from = bug_get_field( $p_bug_id, 'project_id' );\n\tif( $t_project_id_from == $p_project_id_to ) {\n\t\treturn;\n\t}\n\n\t$t_method = config_get( 'file_upload_method' );\n\tif( $t_method != DISK ) {\n\t\treturn;\n\t}\n\n\tif( !file_bug_has_attachments( $p_bug_id ) ) {\n\t\treturn;\n\t}\n\n\t$t_path_from = project_get_field( $t_project_id_from, 'file_path' );\n\tif( is_blank( $t_path_from ) ) {\n\t\t$t_path_from = config_get_global( 'absolute_path_default_upload_folder' );\n\t}\n\tfile_ensure_valid_upload_path( $t_path_from );\n\t$t_path_to = project_get_field( $p_project_id_to, 'file_path' );\n\tif( is_blank( $t_path_to ) ) {\n\t\t$t_path_to = config_get_global( 'absolute_path_default_upload_folder' );\n\t}\n\tfile_ensure_valid_upload_path( $t_path_to );\n\tif( $t_path_from == $t_path_to ) {\n\t\treturn;\n\t}\n\n\t# Initialize the update query to update a single row\n\t$c_bug_id = (int)$p_bug_id;\n\tdb_param_push();\n\t$t_query_disk_attachment_update = 'UPDATE {bug_file}\n\t                                 SET folder=' . db_param() . '\n\t                                 WHERE bug_id=' . db_param() . '\n\t                                 AND id =' . db_param();\n\n\t$t_attachment_rows = bug_get_attachments( $p_bug_id );\n\t$t_attachments_count = count( $t_attachment_rows );\n\tfor( $i = 0; $i < $t_attachments_count; $i++ ) {\n\t\t$t_row = $t_attachment_rows[$i];\n\t\t$t_basename = basename( $t_row['diskfile'] );\n\n\t\t$t_disk_file_name_from = file_path_combine( $t_path_from, $t_basename );\n\t\t$t_disk_file_name_to = file_path_combine( $t_path_to, $t_basename );\n\n\t\tif( !file_exists( $t_disk_file_name_to ) ) {\n\t\t\tchmod( $t_disk_file_name_from, 0775 );\n\t\t\tif( !rename( $t_disk_file_name_from, $t_disk_file_name_to ) ) {\n\t\t\t\tif( !copy( $t_disk_file_name_from, $t_disk_file_name_to ) ) {\n\t\t\t\t\ttrigger_error( ERROR_FILE_MOVE_FAILED, ERROR );\n\t\t\t\t}\n\t\t\t\tfile_delete_local( $t_disk_file_name_from );\n\t\t\t}\n\t\t\tchmod( $t_disk_file_name_to, config_get( 'attachments_file_permissions' ) );\n\t\t\t# Don't pop the parameters after query execution since we're in a loop\n\t\t\tdb_query( $t_query_disk_attachment_update, array( db_prepare_string( $t_path_to ), $c_bug_id, (int)$t_row['id'] ), -1, -1, false );\n\t\t} else {\n\t\t\ttrigger_error( ERROR_FILE_DUPLICATE, ERROR );\n\t\t}\n\t}\n\tdb_param_pop();\n}\n\n/**\n * Copies all attachments from the source bug to the destination bug\n *\n * Does not perform history logging and does not perform access checks.\n *\n * @param integer $p_source_bug_id Source Bug.\n * @param integer $p_dest_bug_id   Destination Bug.\n * @return void\n */\nfunction file_copy_attachments( $p_source_bug_id, $p_dest_bug_id ) {\n\tdb_param_push();\n\t$t_query = 'SELECT * FROM {bug_file} WHERE bug_id = ' . db_param();\n\t$t_result = db_query( $t_query, array( $p_source_bug_id ) );\n\t$t_count = db_num_rows( $t_result );\n\n\t$t_project_id = bug_get_field( $p_source_bug_id, 'project_id' );\n\n\tfor( $i = 0;$i < $t_count;$i++ ) {\n\t\t$t_bug_file = db_fetch_array( $t_result );\n\n\t\t# prepare the new diskfile name and then copy the file\n\t\t$t_source_file = $t_bug_file['folder'] . $t_bug_file['diskfile'];\n\t\tif( ( config_get( 'file_upload_method' ) == DISK ) ) {\n\t\t\t$t_source_file = file_normalize_attachment_path( $t_source_file, $t_project_id );\n\t\t\t$t_file_path = dirname( $t_source_file ) . DIRECTORY_SEPARATOR;\n\t\t} else {\n\t\t\t$t_file_path = $t_bug_file['folder'];\n\t\t}\n\t\t$t_new_diskfile_name = file_generate_unique_name( $t_file_path );\n\t\t$t_new_diskfile_location = $t_file_path . $t_new_diskfile_name;\n\t\t$t_new_file_name = file_get_display_name( $t_bug_file['filename'] );\n\t\tif( ( config_get( 'file_upload_method' ) == DISK ) ) {\n\t\t\t# Skip copy operation if file does not exist (i.e. target bug will have missing attachment)\n\t\t\t# @todo maybe we should trigger an error instead in this case ?\n\t\t\tif( file_exists( $t_source_file ) ) {\n\t\t\t\tcopy( $t_source_file, $t_new_diskfile_location );\n\t\t\t\tchmod( $t_new_diskfile_location, config_get( 'attachments_file_permissions' ) );\n\t\t\t}\n\t\t}\n\n\t\tdb_param_push();\n\t\t$t_query = 'INSERT INTO {bug_file} (\n\t\t\t\tbug_id, title, description, diskfile, filename, folder,\n\t\t\t\tfilesize, file_type, date_added, user_id, content\n\t\t\t)\n\t\t\tVALUES ( '\n\t\t\t. db_param() . ', ' . db_param() . ', ' . db_param() . ', '\n\t\t\t. db_param() . ', ' . db_param() . ', ' . db_param() . ', '\n\t\t\t. db_param() . ', ' . db_param() . ', ' . db_param() . ', '\n\t\t\t. db_param() . ', ' . db_param() .\n\t\t\t')';\n\t\tdb_query( $t_query, array(\n\t\t\t$p_dest_bug_id, $t_bug_file['title'], $t_bug_file['description'],\n\t\t\t$t_new_diskfile_name, $t_new_file_name, $t_file_path,\n\t\t\t$t_bug_file['filesize'], $t_bug_file['file_type'], $t_bug_file['date_added'],\n\t\t\t$t_bug_file['user_id'], $t_bug_file['content']\n\t\t) );\n\t}\n}\n\n/**\n * Returns a possibly override content type for a file name\n *\n * @param string $p_filename The filename of the file which will be downloaded.\n * @return string the content type, or empty if it should not be overridden\n */\nfunction file_get_content_type_override( $p_filename ) {\n\tglobal $g_file_download_content_type_overrides;\n\n\t$t_extension = pathinfo( $p_filename, PATHINFO_EXTENSION );\n\n\tif( isset( $g_file_download_content_type_overrides[$t_extension] ) ) {\n\t\treturn $g_file_download_content_type_overrides[$t_extension];\n\t}\n\n\treturn null;\n}\n\n/**\n * Return the maximum file size that can be uploaded, based on mantis and php\n * configured setting.\n * @return integer\tFile size in bytes\n */\nfunction file_get_max_file_size() {\n\treturn (int)min( ini_get_number( 'upload_max_filesize' ), ini_get_number( 'post_max_size' ), config_get( 'max_file_size' ) );\n}"], "fixing_code": ["<?php\n# MantisBT - A PHP based bugtracking system\n\n# MantisBT is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 2 of the License, or\n# (at your option) any later version.\n#\n# MantisBT is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with MantisBT.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * File API\n *\n * @package CoreAPI\n * @subpackage FileAPI\n * @copyright Copyright 2000 - 2002  Kenzaburo Ito - kenito@300baud.org\n * @copyright Copyright 2002  MantisBT Team - mantisbt-dev@lists.sourceforge.net\n * @link http://www.mantisbt.org\n *\n * @uses access_api.php\n * @uses antispam_api.php\n * @uses authentication_api.php\n * @uses bug_api.php\n * @uses config_api.php\n * @uses constant_inc.php\n * @uses database_api.php\n * @uses gpc_api.php\n * @uses helper_api.php\n * @uses history_api.php\n * @uses project_api.php\n * @uses utility_api.php\n */\n\nrequire_api( 'access_api.php' );\nrequire_api( 'antispam_api.php' );\nrequire_api( 'authentication_api.php' );\nrequire_api( 'bug_api.php' );\nrequire_api( 'config_api.php' );\nrequire_api( 'constant_inc.php' );\nrequire_api( 'database_api.php' );\nrequire_api( 'gpc_api.php' );\nrequire_api( 'helper_api.php' );\nrequire_api( 'history_api.php' );\nrequire_api( 'project_api.php' );\nrequire_api( 'utility_api.php' );\n\nuse Mantis\\Exceptions\\ClientException;\nuse Mantis\\Exceptions\\ServiceException;\n\n$g_cache_file_count = array();\n\n/**\n * Attached specified files to issue.\n *\n * @param int $p_bug_id    The bug id.\n * @param array $p_files   The array of files, if null, then do nothing.\n * @param int $p_bugnote_id The bugnote id, or 0 if issue attachments.\n * @return array Array of file info arrays.\n */\nfunction file_attach_files( $p_bug_id, $p_files, $p_bugnote_id = 0 ) {\n\tif( $p_files === null || count( $p_files ) == 0 ) {\n\t\treturn array();\n\t}\n\n\t$t_file_infos = array();\n\tforeach( $p_files as $t_file ) {\n\t\tif( !empty( $t_file['name'] ) ) {\n\t\t\t# $p_bug_id, array $p_file, $p_table = 'bug', $p_title = '', $p_desc = '', $p_user_id = null, $p_date_added = 0, $p_skip_bug_update = false, $p_bugnote_id = 0\n\t\t\t$t_file_infos[] = file_add(\n\t\t\t\t$p_bug_id,\n\t\t\t\t$t_file,\n\t\t\t\t'bug',\n\t\t\t\t'', /* title */\n\t\t\t\t'', /* desc */\n\t\t\t\tnull, /* user_id */\n\t\t\t\t0, /* date_added */\n\t\t\t\t0, /* skip_bug_update */\n\t\t\t\t$p_bugnote_id );\n\t\t}\n\t}\n\n\treturn $t_file_infos;\n}\n\n/**\n * Gets the filename without the bug id prefix.\n * @param string $p_filename Filename.\n * @return string\n */\nfunction file_get_display_name( $p_filename ) {\n\t# Check if it's a project document filename (doc-0000000-filename)\n\t# or a bug attachment filename (0000000-filename)\n\t# for newer filenames, the filename in schema is correct.\n\t# This is important to handle filenames with '-'s properly\n\t$t_doc_match = '/^' . config_get( 'document_files_prefix' ) . '-\\d{7}-/';\n\t$t_name = preg_split( $t_doc_match, $p_filename );\n\tif( isset( $t_name[1] ) ) {\n\t\treturn $t_name[1];\n\t} else {\n\t\t$t_bug_match = '/^\\d{7}-/';\n\t\t$t_name = preg_split( $t_bug_match, $p_filename );\n\t\tif( isset( $t_name[1] ) ) {\n\t\t\treturn $t_name[1];\n\t\t} else {\n\t\t\treturn $p_filename;\n\t\t}\n\t}\n}\n\n/**\n * Fills the cache with the attachment count from a list of bugs\n * If the bug doesn't have attachments, cache its value as 0.\n * @global array $g_cache_file_count\n * @param array $p_bug_ids Array of bug ids\n * @return void\n */\nfunction file_bug_attachment_count_cache( array $p_bug_ids ) {\n\tglobal $g_cache_file_count;\n\n\tif( empty( $p_bug_ids ) ) {\n\t\treturn;\n\t}\n\n\t$t_ids_to_search = array();\n\tforeach( $p_bug_ids as $t_id ) {\n\t\t$c_id = (int)$t_id;\n\t\t$t_ids_to_search[$c_id] = $c_id;\n\t}\n\n\tdb_param_push();\n\t$t_params = array();\n\t$t_in_values = array();\n\tforeach( $t_ids_to_search as $t_id ) {\n\t\t$t_params[] = (int)$t_id;\n\t\t$t_in_values[] = db_param();\n\t}\n\n\t$t_query = 'SELECT B.id AS bug_id, COUNT(F.bug_id) AS attachments'\n\t\t\t. ' FROM {bug} B JOIN {bug_file} F ON ( B.id = F.bug_id )'\n\t\t\t. ' WHERE B.id IN (' . implode( ',', $t_in_values ) . ')'\n\t\t\t. ' GROUP BY B.id';\n\n\t$t_result = db_query( $t_query, $t_params );\n\twhile( $t_row = db_fetch_array( $t_result ) ) {\n\t\t$c_bug_id = (int)$t_row['bug_id'];\n\t\t$g_cache_file_count[$c_bug_id] = (int)$t_row['attachments'];\n\t\tunset( $t_ids_to_search[$c_bug_id] );\n\t}\n\n\t# set bugs without result to 0\n\tforeach( $t_ids_to_search as $t_id ) {\n\t\t$g_cache_file_count[$t_id] = 0;\n\t}\n}\n\n/**\n * Check the number of attachments a bug has (if any)\n * @param integer $p_bug_id A bug identifier.\n * @return integer\n */\nfunction file_bug_attachment_count( $p_bug_id ) {\n\tglobal $g_cache_file_count;\n\n\t# If it's not in cache, load the value\n\tif( !isset( $g_cache_file_count[$p_bug_id] ) ) {\n\t\tfile_bug_attachment_count_cache( array( (int)$p_bug_id ) );\n\t}\n\n\treturn $g_cache_file_count[$p_bug_id];\n}\n\n/**\n * Clear a bug from the cache or all bugs if no bug id specified.\n * @param integer $p_bug_id A bug identifier to clear (optional).\n * @return boolean\n * @access public\n */\nfunction file_bug_attachment_count_clear_cache( $p_bug_id = null ) {\n\tglobal $g_cache_file_count;\n\n\tif( null === $p_bug_id ) {\n\t\t$g_cache_file_count = array();\n\t} else {\n\t\tunset( $g_cache_file_count[(int)$p_bug_id] );\n\t}\n\n\treturn true;\n}\n\n/**\n * Check if a specific bug has attachments\n * @param integer $p_bug_id A bug identifier.\n * @return boolean\n */\nfunction file_bug_has_attachments( $p_bug_id ) {\n\tif( file_bug_attachment_count( $p_bug_id ) > 0 ) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\n/**\n * Check if the current user can view or download attachments.\n *\n * Generic call used by\n * - {@see file_can_view_bug_attachments()}\n * - {@see file_can_view_bugnote_attachments}\n * - {@see file_can_download_bug_attachments()}\n * - {@see file_can_download_bugnote_attachments}\n *\n * @param string   $p_action            'view' or 'download'\n * @param int      $p_bug_id            A bug identifier\n * @param int      $p_uploader_user_id  The user who uploaded the attachment\n * @param int|null $p_bugnote_id        If specified, will check at bugnote level\n *\n * @return bool\n *\n * @internal Should not be used outside of File API.\n */\nfunction file_can_view_or_download( $p_action, $p_bug_id, $p_uploader_user_id, $p_bugnote_id = null ) {\n\tswitch( $p_action ) {\n\t\tcase 'view':\n\t\t\t$t_threshold_global = 'view_attachments_threshold';\n\t\t\t$t_threshold_own = 'allow_view_own_attachments';\n\t\t\tbreak;\n\t\tcase 'download':\n\t\t\t$t_threshold_global = 'download_attachments_threshold';\n\t\t\t$t_threshold_own = 'allow_download_own_attachments';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttrigger_error( ERROR_GENERIC, ERROR );\n\t}\n\n\t$t_project_id = bug_get_field( $p_bug_id, 'project_id' );\n\t$t_access_global = config_get( $t_threshold_global,null, null, $t_project_id );\n\n\tif( $p_bugnote_id === null ) {\n\t\t$t_can_access = access_has_bug_level( $t_access_global, $p_bug_id );\n\t} else {\n\t\t$t_can_access = access_has_bugnote_level( $t_access_global, $p_bugnote_id );\n\t}\n\tif( $t_can_access ) {\n\t\treturn true;\n\t}\n\n\t$t_uploaded_by_me = auth_get_current_user_id() == $p_uploader_user_id;\n\t$t_view_own = config_get( $t_threshold_own, null, null, $t_project_id );\n\treturn $t_uploaded_by_me && $t_view_own;\n}\n\n/**\n * Check if the current user can view attachments for the specified bug.\n *\n * @param integer $p_bug_id           A bug identifier.\n * @param integer $p_uploader_user_id A user identifier.\n *\n * @return boolean\n */\nfunction file_can_view_bug_attachments( $p_bug_id, $p_uploader_user_id = null ) {\n\treturn file_can_view_or_download( 'view', $p_bug_id, $p_uploader_user_id );\n}\n\n/**\n * Check if the current user can view attachments for the specified bug note.\n *\n * @param integer $p_bugnote_id       A bugnote identifier.\n * @param integer $p_uploader_user_id The user who uploaded the attachment.\n *\n * @return boolean\n */\nfunction file_can_view_bugnote_attachments( $p_bugnote_id, $p_uploader_user_id = null ) {\n\tif( $p_bugnote_id == 0 ) {\n\t\treturn true;\n\t}\n\t$t_bug_id = bugnote_get_field( $p_bugnote_id, 'bug_id' );\n\treturn file_can_view_or_download( 'view', $t_bug_id, $p_uploader_user_id );\n}\n\n/**\n * Check if the current user can download attachments for the specified bug.\n *\n * @param integer $p_bug_id           A bug identifier.\n * @param integer $p_uploader_user_id The user who uploaded the attachment.\n *\n * @return boolean\n */\nfunction file_can_download_bug_attachments( $p_bug_id, $p_uploader_user_id = null ) {\n\treturn file_can_view_or_download( 'download', $p_bug_id, $p_uploader_user_id );\n}\n\n/**\n * Check if the current user can download attachments for the specified bug note.\n *\n * @param integer $p_bugnote_id       A bugnote identifier.\n * @param integer $p_uploader_user_id The user who uploaded the attachment.\n *\n * @return boolean\n */\nfunction file_can_download_bugnote_attachments( $p_bugnote_id, $p_uploader_user_id = null ) {\n\tif( $p_bugnote_id == 0 ) {\n\t\treturn true;\n\t}\n\t$t_bug_id = bugnote_get_field( $p_bugnote_id, 'bug_id' );\n\treturn file_can_view_or_download( 'download', $t_bug_id, $p_uploader_user_id, $p_bugnote_id );\n}\n\n/**\n * Check if the current user can delete attachments from the specified bug.\n * @param integer $p_bug_id           A bug identifier.\n * @param integer $p_uploader_user_id A user identifier.\n * @return boolean\n */\nfunction file_can_delete_bug_attachments( $p_bug_id, $p_uploader_user_id = null ) {\n\tif( bug_is_readonly( $p_bug_id ) ) {\n\t\treturn false;\n\t}\n\t$t_uploaded_by_me = auth_get_current_user_id() === $p_uploader_user_id;\n\t$t_can_delete = access_has_bug_level( config_get( 'delete_attachments_threshold' ), $p_bug_id );\n\t$t_can_delete = $t_can_delete || ( $t_uploaded_by_me && config_get( 'allow_delete_own_attachments' ) );\n\treturn $t_can_delete;\n}\n\n/**\n * Get icon corresponding to the specified filename\n * returns an associative array with \"url\" and \"alt\" text.\n * @param string $p_display_filename Filename.\n * @return array\n */\nfunction file_get_icon_url( $p_display_filename ) {\n\t$t_file_type_icons = config_get_global( 'file_type_icons' );\n\n\t$t_ext = mb_strtolower( pathinfo( $p_display_filename, PATHINFO_EXTENSION ) );\n\tif( is_blank( $t_ext ) || !isset( $t_file_type_icons[$t_ext] ) ) {\n\t\t$t_ext = '?';\n\t}\n\n\t$t_name = $t_file_type_icons[$t_ext];\n\treturn array( 'url' => $t_name, 'alt' => $t_ext );\n}\n\n/**\n * Combines a path and a file name making sure that the separator exists.\n *\n * @param string $p_path     The path.\n * @param string $p_filename The file name.\n * @return string The combined full path.\n */\nfunction file_path_combine( $p_path, $p_filename ) {\n\t$t_path = rtrim( $p_path, '/\\\\' ) . DIRECTORY_SEPARATOR;\n\n\t$t_path .= $p_filename;\n\n\treturn $t_path;\n}\n\n/**\n * Normalizes the disk file path based on the following algorithm:\n * 1. If disk file exists, then return as is.\n * 2. If not, and a project path is available, then check with that, if exists return it.\n * 3. If not, then use default upload path, then check with that, if exists return it.\n * 4. If disk file does not include a path, then return expected path based on project path or default path.\n * 5. Otherwise return as is.\n *\n * @param string  $p_diskfile   The disk file (full path or just filename).\n * @param integer $p_project_id The project id - shouldn't be 0 (ALL_PROJECTS).\n * @return string The normalized full path.\n */\nfunction file_normalize_attachment_path( $p_diskfile, $p_project_id ) {\n\tif( file_exists( $p_diskfile ) ) {\n\t\treturn $p_diskfile;\n\t}\n\n\t$t_basename = basename( $p_diskfile );\n\n\t$t_expected_file_path = '';\n\n\tif( $p_project_id != ALL_PROJECTS ) {\n\t\t$t_path = project_get_field( $p_project_id, 'file_path' );\n\t\tif( !is_blank( $t_path ) ) {\n\t\t\t$t_diskfile = file_path_combine( $t_path, $t_basename );\n\n\t\t\tif( file_exists( $t_diskfile ) ) {\n\t\t\t\treturn $t_diskfile;\n\t\t\t}\n\n\t\t\t# if we don't find the file, then this is the path we want to return.\n\t\t\t$t_expected_file_path = $t_diskfile;\n\t\t}\n\t}\n\n\t$t_path = config_get_global( 'absolute_path_default_upload_folder' );\n\tif( !is_blank( $t_path ) ) {\n\t\t$t_diskfile = file_path_combine( $t_path, $t_basename );\n\n\t\tif( file_exists( $t_diskfile ) ) {\n\t\t\treturn $t_diskfile;\n\t\t}\n\n\t\t# if the expected path not set to project directory, then set it to default directory.\n\t\tif( is_blank( $t_expected_file_path ) ) {\n\t\t\t$t_expected_file_path = $t_diskfile;\n\t\t}\n\t}\n\n\t# if diskfile doesn't include a path, then use the expected filename.\n\tif( ( strstr( $p_diskfile, DIRECTORY_SEPARATOR ) === false ||\n\t       strstr( $p_diskfile, '\\\\' ) === false ) &&\n\t     !is_blank( $t_expected_file_path ) ) {\n\t    return $t_expected_file_path;\n\t}\n\n\t# otherwise return as is.\n\treturn $p_diskfile;\n}\n\n/**\n * Gets an array of attachments that are visible to the currently logged in user.\n * Each element of the array contains the following:\n * display_name - The attachment display name (i.e. file name dot extension)\n * size - The attachment size in bytes.\n * date_added - The date where the attachment was added.\n * can_download - true: logged in user has access to download the attachment, false: otherwise.\n * diskfile - The name of the file on disk.  Typically this is a hash without an extension.\n * download_url - The download URL for the attachment (only set if can_download is true).\n * exists - Applicable for DISK attachments.  true: file exists, otherwise false.\n * can_delete - The logged in user can delete the attachments.\n * preview - true: the attachment should be previewable, otherwise false.\n * type - Can be \"image\", \"text\" or empty for other types.\n * alt - The alternate text to be associated with the icon.\n * icon - array with icon information, contains 'url' and 'alt' elements.\n * @param integer $p_bug_id A bug identifier.\n * @return array\n */\nfunction file_get_visible_attachments( $p_bug_id ) {\n\t$t_attachment_rows = bug_get_attachments( $p_bug_id );\n\t$t_visible_attachments = array();\n\n\t$t_attachments_count = count( $t_attachment_rows );\n\tif( $t_attachments_count === 0 ) {\n\t\treturn $t_visible_attachments;\n\t}\n\n\t$t_attachments = array();\n\n\t$t_preview_text_ext = config_get( 'preview_text_extensions' );\n\t$t_preview_image_ext = config_get( 'preview_image_extensions' );\n\t$t_attachments_view_threshold = config_get( 'view_attachments_threshold' );\n\n\t$t_image_previewed = false;\n\tfor( $i = 0;$i < $t_attachments_count;$i++ ) {\n\t\t$t_row = $t_attachment_rows[$i];\n\t\t$t_user_id = (int)$t_row['user_id'];\n\n\t\t# This covers access checks for issue attachments\n\t\tif( !file_can_view_bug_attachments( $p_bug_id, $t_user_id ) ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t# This covers access checks for issue note attachments\n\t\t$t_attachment_note_id = (int)$t_row['bugnote_id'];\n\t\tif( $t_attachment_note_id !== 0 ) {\n\t\t\tif( bugnote_get_field( $t_attachment_note_id, 'view_state' ) != VS_PUBLIC ) {\n\t\t\t\tif( !access_has_bugnote_level( $t_attachments_view_threshold, $t_attachment_note_id ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t$t_id = (int)$t_row['id'];\n\t\t$t_filename = $t_row['filename'];\n\t\t$t_filesize = $t_row['filesize'];\n\t\t$t_diskfile = file_normalize_attachment_path( $t_row['diskfile'], bug_get_field( $p_bug_id, 'project_id' ) );\n\t\t$t_date_added = $t_row['date_added'];\n\n\t\t$t_attachment = array();\n\t\t$t_attachment['id'] = $t_id;\n\t\t$t_attachment['user_id'] = $t_user_id;\n\t\t$t_attachment['display_name'] = file_get_display_name( $t_filename );\n\t\t$t_attachment['size'] = (int)$t_filesize;\n\t\t$t_attachment['date_added'] = $t_date_added;\n\t\t$t_attachment['diskfile'] = $t_diskfile;\n\t\t$t_attachment['file_type'] = $t_row['file_type'];\n\t\t$t_attachment['bugnote_id'] = (int)$t_row['bugnote_id'];\n\n\t\t$t_attachment['can_download'] = file_can_download_bug_attachments( $p_bug_id, (int)$t_row['user_id'] );\n\t\t$t_attachment['can_delete'] = file_can_delete_bug_attachments( $p_bug_id, (int)$t_row['user_id'] );\n\n\t\tif( $t_attachment['can_download'] ) {\n\t\t\t$t_attachment['download_url'] = 'file_download.php?file_id=' . $t_id . '&type=bug';\n\t\t}\n\n\t\tif( $t_image_previewed ) {\n\t\t\t$t_image_previewed = false;\n\t\t}\n\n\t\t$t_attachment['exists'] = config_get( 'file_upload_method' ) != DISK || file_exists( $t_diskfile );\n\t\t$t_attachment['icon'] = file_get_icon_url( $t_attachment['display_name'] );\n\n\t\t$t_attachment['preview'] = false;\n\t\t$t_attachment['type'] = '';\n\n\t\t$t_ext = strtolower( pathinfo( $t_attachment['display_name'], PATHINFO_EXTENSION ) );\n\t\t$t_attachment['alt'] = $t_ext;\n\n\t\tif( $t_attachment['exists'] && $t_attachment['can_download'] && $t_filesize != 0 ) {\n\t\t\t$t_preview = $t_filesize <= config_get( 'preview_attachments_inline_max_size' );\n\n\t\t\tif( stripos( $t_attachment['file_type'], 'text/' ) === 0 || in_array( $t_ext, $t_preview_text_ext, true ) ) {\n\t\t\t\t$t_attachment['preview'] = $t_preview;\n\t\t\t\t$t_attachment['type'] = 'text';\n\t\t\t} else if( stripos( $t_attachment['file_type'], 'image/' ) === 0 || in_array( $t_ext, $t_preview_image_ext, true ) ) {\n\t\t\t\t$t_attachment['preview'] = $t_preview;\n\t\t\t\t$t_attachment['type'] = 'image';\n\t\t\t} else if( stripos( $t_attachment['file_type'], 'audio/' ) === 0 ) {\n\t\t\t\t$t_attachment['preview'] = $t_preview;\n\t\t\t\t$t_attachment['type'] = 'audio';\n\t\t\t} else if( stripos( $t_attachment['file_type'], 'video/' ) === 0 ) {\n\t\t\t\t$t_attachment['preview'] = $t_preview;\n\t\t\t\t$t_attachment['type'] = 'video';\n\t\t\t}\n\t\t}\n\n\t\t$t_attachments[] = $t_attachment;\n\t}\n\n\treturn $t_attachments;\n}\n\n/**\n * delete all files that are associated with the given bug\n * @param integer $p_bug_id A bug identifier.\n * @return boolean\n */\nfunction file_delete_attachments( $p_bug_id ) {\n\t$t_method = config_get( 'file_upload_method' );\n\n\t# Delete files from disk\n\tdb_param_push();\n\t$t_query = 'SELECT diskfile, filename FROM {bug_file} WHERE bug_id=' . db_param();\n\t$t_result = db_query( $t_query, array( $p_bug_id ) );\n\n\t$t_file_count = db_num_rows( $t_result );\n\tif( 0 == $t_file_count ) {\n\t\treturn true;\n\t}\n\n\tif( DISK == $t_method ) {\n\t\tfor( $i = 0; $i < $t_file_count; $i++ ) {\n\t\t\t$t_row = db_fetch_array( $t_result );\n\n\t\t\t$t_local_diskfile = file_normalize_attachment_path( $t_row['diskfile'], bug_get_field( $p_bug_id, 'project_id' ) );\n\t\t\tfile_delete_local( $t_local_diskfile );\n\t\t}\n\t}\n\n\t# Delete the corresponding db records\n\tdb_param_push();\n\t$t_query = 'DELETE FROM {bug_file} WHERE bug_id=' . db_param();\n\tdb_query( $t_query, array( $p_bug_id ) );\n\n\t# db_query() errors on failure so:\n\treturn true;\n}\n\n/**\n * Delete all files that are associated with the given bug note.\n * @param integer $p_bug_id A bug identifier.\n * @param integer $p_bugnote_id A bugnote identifier.\n * @return boolean\n */\nfunction file_delete_bugnote_attachments( $p_bug_id, $p_bugnote_id ) {\n\tdb_param_push();\n\t$t_query = 'SELECT id, diskfile, filename FROM {bug_file} WHERE bug_id=' . db_param() . ' AND bugnote_id=' . db_param();\n\t$t_result = db_query( $t_query, array( $p_bug_id, $p_bugnote_id ) );\n\n\twhile( $t_row = db_fetch_array( $t_result ) ) {\n\t\tfile_delete( (int)$t_row['id'], 'bug', $p_bugnote_id );\n\t}\n\n\t# db_query() errors on failure so:\n\treturn true;\n}\n\n/**\n * Link the specified file to the specified bugnote.\n * \n * @param integer $p_file_id The file id.\n * @param integer $p_bugnote_id A bugnote identifier.\n * @return void\n */\nfunction file_link_to_bugnote( $p_file_id, $p_bugnote_id ) {\n\tdb_param_push();\n\n\t$t_query = 'UPDATE {bug_file} SET bugnote_id=' . db_param() . ' WHERE id=' . db_param();\n\tdb_query( $t_query, array( $p_bugnote_id, $p_file_id ) );\n}\n\n/**\n * Delete files by project\n * @param integer $p_project_id A project identifier.\n * @return void\n */\nfunction file_delete_project_files( $p_project_id ) {\n\t$t_method = config_get( 'file_upload_method' );\n\n\t# Delete the file physically (if stored via DISK)\n\tif( DISK == $t_method ) {\n\t\t# Delete files from disk\n\t\tdb_param_push();\n\t\t$t_query = 'SELECT diskfile, filename FROM {project_file} WHERE project_id=' . db_param();\n\t\t$t_result = db_query( $t_query, array( (int)$p_project_id ) );\n\n\t\t$t_file_count = db_num_rows( $t_result );\n\n\t\tfor( $i = 0;$i < $t_file_count;$i++ ) {\n\t\t\t$t_row = db_fetch_array( $t_result );\n\n\t\t\t$t_local_diskfile = file_normalize_attachment_path( $t_row['diskfile'], $p_project_id );\n\t\t\tfile_delete_local( $t_local_diskfile );\n\t\t}\n\t}\n\n\t# Delete the corresponding database records\n\tdb_param_push();\n\t$t_query = 'DELETE FROM {project_file} WHERE project_id=' . db_param();\n\tdb_query( $t_query, array( (int)$p_project_id ) );\n}\n\n/**\n * Delete a local file even if it is read-only.\n * @param string $p_filename File name.\n * @return void\n */\nfunction file_delete_local( $p_filename ) {\n\tif( file_exists( $p_filename ) ) {\n\t\tchmod( $p_filename, 0775 );\n\t\tunlink( $p_filename );\n\t}\n}\n\n/**\n * Return the specified field value\n * @param integer $p_file_id    File identifier.\n * @param string  $p_field_name Database field name to retrieve.\n * @param string  $p_table      Database table name.\n * @return string\n */\nfunction file_get_field( $p_file_id, $p_field_name, $p_table = 'bug' ) {\n\t$t_bug_file_table = db_get_table( $p_table . '_file' );\n\tif( !db_field_exists( $p_field_name, $t_bug_file_table ) ) {\n\t\ttrigger_error( ERROR_DB_FIELD_NOT_FOUND, ERROR );\n\t}\n\n\tdb_param_push();\n\t$t_query = 'SELECT ' . $p_field_name . ' FROM ' . $t_bug_file_table . ' WHERE id=' . db_param();\n\t$t_result = db_query( $t_query, array( (int)$p_file_id ), 1 );\n\n\treturn db_result( $t_result );\n}\n\n/**\n * Delete File\n * @param integer $p_file_id File identifier.\n * @param string  $p_table   Table identifier.\n * @param integer $p_bugnote_id The bugnote id the file is attached to or 0 if attached to issue.\n * @return boolean\n */\nfunction file_delete( $p_file_id, $p_table = 'bug', $p_bugnote_id = 0 ) {\n\t$t_upload_method = config_get( 'file_upload_method' );\n\n\t$c_file_id = (int)$p_file_id;\n\t$t_filename = file_get_field( $p_file_id, 'filename', $p_table );\n\t$t_diskfile = file_get_field( $p_file_id, 'diskfile', $p_table );\n\n\tif( $p_table == 'bug' ) {\n\t\t$t_bug_id = file_get_field( $p_file_id, 'bug_id', $p_table );\n\t\t$t_project_id = bug_get_field( $t_bug_id, 'project_id' );\n\t} else {\n\t\t$t_project_id = file_get_field( $p_file_id, 'project_id', $p_table );\n\t}\n\n\tif( DISK == $t_upload_method ) {\n\t\t$t_local_disk_file = file_normalize_attachment_path( $t_diskfile, $t_project_id );\n\t\tif( file_exists( $t_local_disk_file ) ) {\n\t\t\tfile_delete_local( $t_local_disk_file );\n\t\t}\n\t}\n\n\tif( 'bug' == $p_table ) {\n\t\t# log file deletion\n\t\thistory_log_event_special( $t_bug_id, FILE_DELETED, file_get_display_name( $t_filename ), $p_bugnote_id );\n\t}\n\n\t$t_file_table = db_get_table( $p_table . '_file' );\n\tdb_param_push();\n\t$t_query = 'DELETE FROM ' . $t_file_table . ' WHERE id=' . db_param();\n\tdb_query( $t_query, array( $c_file_id ) );\n\treturn true;\n}\n\n/**\n * File type check\n * @param string $p_file_name File name.\n * @return boolean\n */\nfunction file_type_check( $p_file_name ) {\n\t$t_allowed_files = config_get( 'allowed_files' );\n\t$t_disallowed_files = config_get( 'disallowed_files' );\n\n\t# grab extension\n\t$t_extension = pathinfo( $p_file_name, PATHINFO_EXTENSION );\n\n\t# check against disallowed files\n\tif( !is_blank( $t_disallowed_files ) ) {\n\t\t$t_disallowed_arr = explode( ',', $t_disallowed_files );\n\t\tforeach( $t_disallowed_arr as $t_val ) {\n\t\t\tif( 0 == strcasecmp( $t_val, $t_extension ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\t# if the allowed list is note populated then the file must be allowed\n\tif( is_blank( $t_allowed_files ) ) {\n\t\treturn true;\n\t}\n\n\t# check against allowed files\n\t$t_allowed_arr = explode( ',', $t_allowed_files );\n\tforeach( $t_allowed_arr as $t_val ) {\n\t\tif( 0 == strcasecmp( $t_val, $t_extension ) ) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n/**\n * clean file name by removing sensitive characters and replacing them with underscores\n * @param string $p_filename File name.\n * @return string\n */\nfunction file_clean_name( $p_filename ) {\n\treturn preg_replace( '/[\\/*?\"<>|\\\\ :&]/', '_', $p_filename );\n}\n\n/**\n * Generate a UNIQUE string for a given file path to use as the identifier for the file\n * The string returned should be 32 characters in length\n * @param string $p_filepath File path.\n * @return string\n */\nfunction file_generate_unique_name( $p_filepath ) {\n\tdo {\n\t\t$t_string = md5( crypto_generate_random_string( 32, false ) );\n\t} while( !diskfile_is_name_unique( $t_string, $p_filepath ) );\n\n\treturn $t_string;\n}\n\n/**\n * Validates that the given disk file name identifier is unique, checking both\n * in the DB tables (bug and project) and on disk.\n * This ensures that in case a file has been deleted from disk but its record\n * remains in the DB, we never get in a situation where the DB points to a file\n * which is not the originally uploaded one.\n * @param string $p_name     File name.\n * @param string $p_filepath File path.\n * @return boolean true if unique\n */\nfunction diskfile_is_name_unique( $p_name, $p_filepath ) {\n\t$c_name = $p_filepath . $p_name;\n\n\tdb_param_push();\n\t$t_query = 'SELECT count(*)\n\t\tFROM (\n\t\t\tSELECT diskfile FROM {bug_file} WHERE diskfile=' . db_param() . '\n\t\t\tUNION\n\t\t\tSELECT diskfile FROM {project_file} WHERE diskfile=' . db_param() . '\n\t\t\t) f';\n\t$t_result = db_query( $t_query, array( $c_name, $c_name) );\n\t$t_count = db_result( $t_result );\n\n\treturn ( $t_count == 0 ) && !file_exists( $c_name );\n}\n\n/**\n * Validates that the given file name is unique in the given context (we don't\n * allow multiple attachments with the same name for a given bug or project)\n * @param string  $p_name   File name.\n * @param integer $p_bug_id A bug identifier (not used for project files).\n * @param string  $p_table  Optional file table to check: 'project' or 'bug' (default).\n * @return boolean true if unique\n */\nfunction file_is_name_unique( $p_name, $p_bug_id, $p_table = 'bug' ) {\n\t$t_file_table = db_get_table( \"${p_table}_file\" );\n\n\tdb_param_push();\n\t$t_query = 'SELECT COUNT(*) FROM ' . $t_file_table . ' WHERE filename=' . db_param();\n\t$t_param = array( $p_name );\n\tif( $p_table == 'bug' ) {\n\t\t$t_query .= ' AND bug_id=' . db_param();\n\t\t$t_param[] = $p_bug_id;\n\t}\n\n\t$t_result = db_query( $t_query, $t_param );\n\t$t_count = db_result( $t_result );\n\n\treturn ( $t_count == 0 );\n}\n\n/**\n * Add a file to the system using the configured storage method\n *\n * If file was not uploaded by the browser standard POST method, set value\n * for key `browser_upload` on $p_file to false.  Otherwise, the file_add()\n * operation will fail.\n *\n * @param integer $p_bug_id          The bug id (should be 0 when adding project doc).\n * @param array   $p_file            The uploaded file info, as retrieved from gpc_get_file().\n * @param string  $p_table           Either 'bug' or 'project' depending on attachment type.\n * @param string  $p_title           File title.\n * @param string  $p_desc            File description.\n * @param integer $p_user_id         User id (defaults to current user).\n * @param integer $p_date_added      Date added.\n * @param boolean $p_skip_bug_update Skip bug last modification update (useful when importing bug attachments).\n * @param int     $p_bugnote_id      The bugnote id or 0 if associated with the issue.\n * @return array The file info array (keys: name, size)\n */\nfunction file_add( $p_bug_id, array $p_file, $p_table = 'bug', $p_title = '', $p_desc = '', $p_user_id = null, $p_date_added = 0, $p_skip_bug_update = false, $p_bugnote_id = 0 ) {\n\t$t_file_info = array();\n\n\tif( !isset( $p_file['error'] ) ) {\n\t\t$p_file['error'] = UPLOAD_ERR_OK;\n\t}\n\n\tif( !isset( $p_file['browser_upload'] ) ) {\n\t\t$p_file['browser_upload'] = true;\n\t}\n\n\t$t_tmp_file = $p_file['tmp_name'];\n\n\t# Override passed value with one detected by PHP (if available).\n\t# If PHP can't detect it, then use supplied value.\n\t# If no value supplied, then default to a reasonable value.\n\t# The value will be overridden by PHP anyway if content type is\n\t# known at rendering time.\n\t$t_type = file_get_mime_type( $t_tmp_file );\n\tif( $t_type !== false ) {\n\t\t$p_file['type'] = $t_type;\n\t} else if( !isset( $p_file['type'] ) ) {\n\t\t$p_file['type'] = 'application/octet-stream';\n\t}\n\n\tfile_ensure_uploaded( $p_file );\n\t$t_file_name = $p_file['name'];\n\n\tif( !file_type_check( $t_file_name ) ) {\n\t\tthrow new ClientException(\n\t\t\tsprintf( \"File '%s' type not allowed\", $t_file_name ),\n\t\t\tERROR_FILE_NOT_ALLOWED\n\t\t);\n\t}\n\n\t$t_org_filename = $t_file_name;\n\t$t_suffix_id = 1;\n\n\twhile( !file_is_name_unique( $t_file_name, $p_bug_id ) ) {\n\t\t$t_suffix_id++;\n\n\t\t$t_dot_index = strripos( $t_org_filename, '.' );\n\t\tif( $t_dot_index === false ) {\n\t\t\t$t_file_name = $t_org_filename . '-' . $t_suffix_id;\n\t\t} else {\n\t\t\t$t_extension = substr( $t_org_filename, $t_dot_index, strlen( $t_org_filename ) - $t_dot_index );\n\t\t\t$t_file_name = substr( $t_org_filename, 0, $t_dot_index ) . '-' . $t_suffix_id . $t_extension;\n\t\t}\n\t}\n\n\t$t_file_info['name'] = $t_file_name;\n\tantispam_check();\n\n\t$t_file_size = filesize( $t_tmp_file );\n\tif( 0 == $t_file_size ) {\n\t\tthrow new ClientException(\n\t\t\tsprintf( \"File '%s' not uploaded\", $t_file_name ),\n\t\t\tERROR_FILE_NO_UPLOAD_FAILURE );\n\t}\n\n\t$t_file_info['size'] = $t_file_size;\n\n\t$t_max_file_size = (int)min( ini_get_number( 'upload_max_filesize' ), ini_get_number( 'post_max_size' ), config_get( 'max_file_size' ) );\n\tif( $t_file_size > $t_max_file_size ) {\n\t\tthrow new ClientException(\n\t\t\tsprintf( \"File '%s' too big\", $t_file_name ),\n\t\t\tERROR_FILE_TOO_BIG );\n\t}\n\n\tif( 'bug' == $p_table ) {\n\t\t$t_project_id = bug_get_field( $p_bug_id, 'project_id' );\n\t\t$t_id = (int)$p_bug_id;\n\t} else {\n\t\t$t_project_id = helper_get_current_project();\n\t\t$t_id = $t_project_id;\n\t}\n\n\tif( $p_user_id === null ) {\n\t\t$p_user_id = auth_get_current_user_id();\n\t}\n\n\tif( $p_date_added <= 0 ) {\n\t\t$p_date_added = db_now();\n\t}\n\n\tif( $t_project_id == ALL_PROJECTS ) {\n\t\t$t_file_path = config_get_global( 'absolute_path_default_upload_folder' );\n\t} else {\n\t\t$t_file_path = project_get_field( $t_project_id, 'file_path' );\n\t\tif( is_blank( $t_file_path ) ) {\n\t\t\t$t_file_path = config_get_global( 'absolute_path_default_upload_folder' );\n\t\t}\n\t}\n\n\t$t_unique_name = file_generate_unique_name( $t_file_path );\n\t$t_method = config_get( 'file_upload_method' );\n\n\tswitch( $t_method ) {\n\t\tcase DISK:\n\t\t\tfile_ensure_valid_upload_path( $t_file_path );\n\n\t\t\t$t_disk_file_name = $t_file_path . $t_unique_name;\n\t\t\tif( !file_exists( $t_disk_file_name ) ) {\n\t\t\t\tif( $p_file['browser_upload'] ) {\n\t\t\t\t\tif( !move_uploaded_file( $t_tmp_file, $t_disk_file_name ) ) {\n\t\t\t\t\t\tthrow new ServiceException(\n\t\t\t\t\t\t\t'Unable to move uploaded file',\n\t\t\t\t\t\t\tERROR_FILE_MOVE_FAILED\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif( !copy( $t_tmp_file, $t_disk_file_name ) || !unlink( $t_tmp_file ) ) {\n\t\t\t\t\t\tthrow new ServiceException(\n\t\t\t\t\t\t\t'Unable to move uploaded file',\n\t\t\t\t\t\t\tERROR_FILE_MOVE_FAILED\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tchmod( $t_disk_file_name, config_get( 'attachments_file_permissions' ) );\n\n\t\t\t\t$c_content = '';\n\t\t\t} else {\n\t\t\t\tthrow new ClientException( 'Duplicate file', ERROR_FILE_DUPLICATE );\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DATABASE:\n\t\t\t$c_content = db_prepare_binary_string( fread( fopen( $t_tmp_file, 'rb' ), $t_file_size ) );\n\t\t\t$t_file_path = '';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new ServiceException( 'Unknown file upload method', ERROR_GENERIC );\n\t}\n\n\t$t_file_table = db_get_table( $p_table . '_file' );\n\t$t_id_col = $p_table . '_id';\n\n\tdb_param_push();\n\n\t$t_param = array(\n\t\t$t_id_col     => $t_id,\n\t\t'title'       => $p_title,\n\t\t'description' => $p_desc,\n\t\t'diskfile'    => $t_unique_name,\n\t\t'filename'    => $t_file_name,\n\t\t'folder'      => $t_file_path,\n\t\t'filesize'    => $t_file_size,\n\t\t'file_type'   => $p_file['type'],\n\t\t'date_added'  => $p_date_added,\n\t\t'user_id'     => (int)$p_user_id\n\t);\n\tif( 'bug' == $p_table ) {\n\t\t$t_param['bugnote_id'] = is_null( $p_bugnote_id ) ? null : (int)$p_bugnote_id;\n\t}\n\t# Oracle has to update BLOBs separately\n\tif( !db_is_oracle() ) {\n\t\t$t_param['content'] = $c_content;\n\t}\n\n\t$t_query_param = db_param();\n\tfor( $i = 1; $i < count( $t_param ); $i++ ) {\n\t\t$t_query_param .= ', ' . db_param();\n\t}\n\n\t$t_query = 'INSERT INTO ' . $t_file_table . '\n\t\t( ' . implode( ', ', array_keys( $t_param ) ) . ' )\n\tVALUES\n\t\t( ' . $t_query_param . ' )';\n\tdb_query( $t_query, array_values( $t_param ) );\n\n\t$t_file_info['id'] = db_insert_id( $t_file_table );\n\n\tif( db_is_oracle() ) {\n\t\tdb_update_blob( $t_file_table, 'content', $c_content, \"diskfile='$t_unique_name'\" );\n\t}\n\n\tif( 'bug' == $p_table ) {\n\t\t# update the last_updated date\n\t\tif( !$p_skip_bug_update ) {\n\t\t\tbug_update_date( $p_bug_id );\n\t\t}\n\n\t\t# log file added to bug history\n\t\thistory_log_event_special( $p_bug_id, FILE_ADDED, $t_file_name, $p_bugnote_id );\n\t}\n\n\treturn $t_file_info;\n}\n\n/**\n * Return true if file uploading is enabled (in our config and PHP's), false otherwise\n * @return boolean\n */\nfunction file_is_uploading_enabled() {\n\tif( ini_get_bool( 'file_uploads' ) && ( ON == config_get( 'allow_file_upload' ) ) ) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\n/**\n * Check if the user can upload files for this project\n * return true if they can, false otherwise\n * the project defaults to the current project and the user to the current user\n * @param integer $p_project_id A project identifier.\n * @param integer $p_user_id    A user identifier.\n * @return boolean\n */\nfunction file_allow_project_upload( $p_project_id = null, $p_user_id = null ) {\n\tif( null === $p_project_id ) {\n\t\t$p_project_id = helper_get_current_project();\n\t}\n\tif( null === $p_user_id ) {\n\t\t$p_user_id = auth_get_current_user_id();\n\t}\n\treturn( file_is_uploading_enabled() && ( access_has_project_level( config_get( 'upload_project_file_threshold' ), $p_project_id, $p_user_id ) ) );\n}\n\n/**\n * Check if the user can upload files for this bug\n * return true if they can, false otherwise\n * the user defaults to the current user\n *\n * if the bug null (the default) we answer whether the user can\n * upload a file to a new bug in the current project\n * @param integer $p_bug_id  A bug identifier.\n * @param integer $p_user_id A user identifier.\n * @param integer $p_project_id The project id to check for or null for bug project or current project.\n * @return boolean\n */\nfunction file_allow_bug_upload( $p_bug_id = null, $p_user_id = null, $p_project_id = null ) {\n\tif( null === $p_user_id ) {\n\t\t$p_user_id = auth_get_current_user_id();\n\t}\n\n\t# If uploads are disabled just return false\n\tif( !file_is_uploading_enabled() ) {\n\t\treturn false;\n\t}\n\n\tif( null === $p_bug_id ) {\n\t\t# new bug\n\t\t$t_project_id = $p_project_id === null ? helper_get_current_project() : $p_project_id;\n\n\t\t# the user must be the reporter if they're reporting a new bug\n\t\t$t_reporter = true;\n\t} else {\n\t\t# existing bug\n\t\t$t_project_id = bug_get_field( $p_bug_id, 'project_id' );\n\n\t\t# check if the user is the reporter of the bug\n\t\t$t_reporter = bug_is_user_reporter( $p_bug_id, $p_user_id );\n\t}\n\n\tif( $t_reporter && ( ON == config_get( 'allow_reporter_upload' ) ) ) {\n\t\treturn true;\n\t}\n\n\t# Check the access level against the config setting\n\treturn access_has_project_level( config_get( 'upload_bug_file_threshold' ), $t_project_id, $p_user_id );\n}\n\n/**\n * checks whether the specified upload path exists and is writable\n * @param string $p_upload_path Upload path.\n * @return void\n */\nfunction file_ensure_valid_upload_path( $p_upload_path ) {\n\tif( !file_exists( $p_upload_path ) || !is_dir( $p_upload_path ) || !is_writable( $p_upload_path ) || !is_readable( $p_upload_path ) ) {\n\t\tthrow new ServiceException(\n\t\t\t'Upload folder not valid',\n\t\t\tERROR_FILE_INVALID_UPLOAD_PATH );\n\t}\n}\n\n/**\n * Ensure a file was uploaded\n *\n * This function perform various checks for determining if the upload was successful\n *\n * @param array $p_file The uploaded file info, as retrieved from gpc_get_file().\n * @return void\n */\nfunction file_ensure_uploaded( array $p_file ) {\n\tswitch( $p_file['error'] ) {\n\t\tcase UPLOAD_ERR_INI_SIZE:\n\t\tcase UPLOAD_ERR_FORM_SIZE:\n\t\t\tthrow new ClientException(\n\t\t\t\tsprintf( \"File '%s' too big\", $p_file['name'] ),\n\t\t\t\tERROR_FILE_TOO_BIG );\n\n\t\tcase UPLOAD_ERR_PARTIAL:\n\t\tcase UPLOAD_ERR_NO_FILE:\n\t\t\tthrow new ClientException(\n\t\t\t\tsprintf( \"File '%s' upload failure\", $p_file['name'] ),\n\t\t\t\tERROR_FILE_NO_UPLOAD_FAILURE );\n\t}\n\n\tif( ( '' == $p_file['tmp_name'] ) || ( '' == $p_file['name'] ) ) {\n\t\tthrow new ClientException(\n\t\t\t'File name or path is empty',\n\t\t\tERROR_FILE_NO_UPLOAD_FAILURE );\n\t}\n\n\tif( !is_readable( $p_file['tmp_name'] ) ) {\n\t\tthrow new ClientException( 'File is not readable', ERROR_UPLOAD_FAILURE );\n\t}\n}\n\n/**\n * Return instance of fileinfo class\n * @return finfo instance of finfo class.\n */\nfunction file_create_finfo() {\n\t$t_info_file = config_get_global( 'fileinfo_magic_db_file' );\n\n\tif( is_blank( $t_info_file ) ) {\n\t\t$t_finfo = new finfo( FILEINFO_MIME );\n\t} else {\n\t\t$t_finfo = new finfo( FILEINFO_MIME, $t_info_file );\n\t}\n\n\treturn $t_finfo;\n}\n\n/**\n * Get mime type for the specified file.\n *\n * @param string $p_file_path The file path.\n * @return boolean|string The mime type or false on failure.\n */\nfunction file_get_mime_type( $p_file_path ) {\n\tif( !file_exists( $p_file_path ) ) {\n\t\treturn false;\n\t}\n\n\t$t_finfo = file_create_finfo();\n\treturn $t_finfo->file( $p_file_path );\n}\n\n/**\n * Get mime type for the specified content.\n *\n * @param string $p_content The content.\n * @return boolean|string The mime type or false on failure.\n */\nfunction file_get_mime_type_for_content( $p_content ) {\n\t$t_finfo = file_create_finfo();\n\treturn $t_finfo->buffer( $p_content );\n}\n\n/**\n * Get file content\n *\n * @param integer $p_file_id File identifier.\n * @param string  $p_type    File type (either 'bug' or 'doc').\n * @return array|boolean array containing file type and content or false on failure to retrieve file\n */\nfunction file_get_content( $p_file_id, $p_type = 'bug' ) {\n\t# we handle the case where the file is attached to a bug\n\t# or attached to a project as a project doc.\n\tdb_param_push();\n\tswitch( $p_type ) {\n\t\tcase 'bug':\n\t\t\t$t_query = 'SELECT * FROM {bug_file} WHERE id=' . db_param();\n\t\t\tbreak;\n\t\tcase 'doc':\n\t\t\t$t_query = 'SELECT * FROM {project_file} WHERE id=' . db_param();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn false;\n\t}\n\n\t$t_result = db_query( $t_query, array( $p_file_id ) );\n\t$t_row = db_fetch_array( $t_result );\n\n\tif( $p_type == 'bug' ) {\n\t\t$t_project_id = bug_get_field( $t_row['bug_id'], 'project_id' );\n\t} else {\n\t\t$t_project_id = $t_row['bug_id'];\n\t}\n\n\t$t_content_type = $t_row['file_type'];\n\n\tswitch( config_get( 'file_upload_method' ) ) {\n\t\tcase DISK:\n\t\t\t$t_local_disk_file = file_normalize_attachment_path( $t_row['diskfile'], $t_project_id );\n\n\t\t\tif( file_exists( $t_local_disk_file ) ) {\n\t\t\t\t$t_file_info_type = file_get_mime_type( $t_local_disk_file );\n\n\t\t\t\tif( $t_file_info_type !== false ) {\n\t\t\t\t\t$t_content_type = $t_file_info_type;\n\t\t\t\t}\n\n\t\t\t\treturn array( 'type' => $t_content_type, 'content' => file_get_contents( $t_local_disk_file ) );\n\t\t\t}\n\t\t\treturn false;\n\t\t\tbreak;\n\t\tcase DATABASE:\n\t\t\t$t_file_info_type = file_get_mime_type_for_content( $t_row['content'] );\n\n\t\t\tif( $t_file_info_type !== false ) {\n\t\t\t\t$t_content_type = $t_file_info_type;\n\t\t\t}\n\n\t\t\treturn array( 'type' => $t_content_type, 'content' => $t_row['content'] );\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttrigger_error( ERROR_GENERIC, ERROR );\n\t}\n}\n\n/**\n * Move any attachments as needed when a bug is moved from project to project.\n *\n * @param integer $p_bug_id        ID of bug containing attachments to be moved.\n * @param integer $p_project_id_to Destination project ID for the bug.\n * @return void\n *\n * @todo: this function can't cope with source or target storing attachments in DB\n */\nfunction file_move_bug_attachments( $p_bug_id, $p_project_id_to ) {\n\t$t_project_id_from = bug_get_field( $p_bug_id, 'project_id' );\n\tif( $t_project_id_from == $p_project_id_to ) {\n\t\treturn;\n\t}\n\n\t$t_method = config_get( 'file_upload_method' );\n\tif( $t_method != DISK ) {\n\t\treturn;\n\t}\n\n\tif( !file_bug_has_attachments( $p_bug_id ) ) {\n\t\treturn;\n\t}\n\n\t$t_path_from = project_get_field( $t_project_id_from, 'file_path' );\n\tif( is_blank( $t_path_from ) ) {\n\t\t$t_path_from = config_get_global( 'absolute_path_default_upload_folder' );\n\t}\n\tfile_ensure_valid_upload_path( $t_path_from );\n\t$t_path_to = project_get_field( $p_project_id_to, 'file_path' );\n\tif( is_blank( $t_path_to ) ) {\n\t\t$t_path_to = config_get_global( 'absolute_path_default_upload_folder' );\n\t}\n\tfile_ensure_valid_upload_path( $t_path_to );\n\tif( $t_path_from == $t_path_to ) {\n\t\treturn;\n\t}\n\n\t# Initialize the update query to update a single row\n\t$c_bug_id = (int)$p_bug_id;\n\tdb_param_push();\n\t$t_query_disk_attachment_update = 'UPDATE {bug_file}\n\t                                 SET folder=' . db_param() . '\n\t                                 WHERE bug_id=' . db_param() . '\n\t                                 AND id =' . db_param();\n\n\t$t_attachment_rows = bug_get_attachments( $p_bug_id );\n\t$t_attachments_count = count( $t_attachment_rows );\n\tfor( $i = 0; $i < $t_attachments_count; $i++ ) {\n\t\t$t_row = $t_attachment_rows[$i];\n\t\t$t_basename = basename( $t_row['diskfile'] );\n\n\t\t$t_disk_file_name_from = file_path_combine( $t_path_from, $t_basename );\n\t\t$t_disk_file_name_to = file_path_combine( $t_path_to, $t_basename );\n\n\t\tif( !file_exists( $t_disk_file_name_to ) ) {\n\t\t\tchmod( $t_disk_file_name_from, 0775 );\n\t\t\tif( !rename( $t_disk_file_name_from, $t_disk_file_name_to ) ) {\n\t\t\t\tif( !copy( $t_disk_file_name_from, $t_disk_file_name_to ) ) {\n\t\t\t\t\ttrigger_error( ERROR_FILE_MOVE_FAILED, ERROR );\n\t\t\t\t}\n\t\t\t\tfile_delete_local( $t_disk_file_name_from );\n\t\t\t}\n\t\t\tchmod( $t_disk_file_name_to, config_get( 'attachments_file_permissions' ) );\n\t\t\t# Don't pop the parameters after query execution since we're in a loop\n\t\t\tdb_query( $t_query_disk_attachment_update, array( db_prepare_string( $t_path_to ), $c_bug_id, (int)$t_row['id'] ), -1, -1, false );\n\t\t} else {\n\t\t\ttrigger_error( ERROR_FILE_DUPLICATE, ERROR );\n\t\t}\n\t}\n\tdb_param_pop();\n}\n\n/**\n * Copies all attachments from the source bug to the destination bug\n *\n * Does not perform history logging and does not perform access checks.\n *\n * @param integer $p_source_bug_id Source Bug.\n * @param integer $p_dest_bug_id   Destination Bug.\n * @return void\n */\nfunction file_copy_attachments( $p_source_bug_id, $p_dest_bug_id ) {\n\tdb_param_push();\n\t$t_query = 'SELECT * FROM {bug_file} WHERE bug_id = ' . db_param();\n\t$t_result = db_query( $t_query, array( $p_source_bug_id ) );\n\t$t_count = db_num_rows( $t_result );\n\n\t$t_project_id = bug_get_field( $p_source_bug_id, 'project_id' );\n\n\tfor( $i = 0;$i < $t_count;$i++ ) {\n\t\t$t_bug_file = db_fetch_array( $t_result );\n\n\t\t# prepare the new diskfile name and then copy the file\n\t\t$t_source_file = $t_bug_file['folder'] . $t_bug_file['diskfile'];\n\t\tif( ( config_get( 'file_upload_method' ) == DISK ) ) {\n\t\t\t$t_source_file = file_normalize_attachment_path( $t_source_file, $t_project_id );\n\t\t\t$t_file_path = dirname( $t_source_file ) . DIRECTORY_SEPARATOR;\n\t\t} else {\n\t\t\t$t_file_path = $t_bug_file['folder'];\n\t\t}\n\t\t$t_new_diskfile_name = file_generate_unique_name( $t_file_path );\n\t\t$t_new_diskfile_location = $t_file_path . $t_new_diskfile_name;\n\t\t$t_new_file_name = file_get_display_name( $t_bug_file['filename'] );\n\t\tif( ( config_get( 'file_upload_method' ) == DISK ) ) {\n\t\t\t# Skip copy operation if file does not exist (i.e. target bug will have missing attachment)\n\t\t\t# @todo maybe we should trigger an error instead in this case ?\n\t\t\tif( file_exists( $t_source_file ) ) {\n\t\t\t\tcopy( $t_source_file, $t_new_diskfile_location );\n\t\t\t\tchmod( $t_new_diskfile_location, config_get( 'attachments_file_permissions' ) );\n\t\t\t}\n\t\t}\n\n\t\tdb_param_push();\n\t\t$t_query = 'INSERT INTO {bug_file} (\n\t\t\t\tbug_id, title, description, diskfile, filename, folder,\n\t\t\t\tfilesize, file_type, date_added, user_id, content\n\t\t\t)\n\t\t\tVALUES ( '\n\t\t\t. db_param() . ', ' . db_param() . ', ' . db_param() . ', '\n\t\t\t. db_param() . ', ' . db_param() . ', ' . db_param() . ', '\n\t\t\t. db_param() . ', ' . db_param() . ', ' . db_param() . ', '\n\t\t\t. db_param() . ', ' . db_param() .\n\t\t\t')';\n\t\tdb_query( $t_query, array(\n\t\t\t$p_dest_bug_id, $t_bug_file['title'], $t_bug_file['description'],\n\t\t\t$t_new_diskfile_name, $t_new_file_name, $t_file_path,\n\t\t\t$t_bug_file['filesize'], $t_bug_file['file_type'], $t_bug_file['date_added'],\n\t\t\t$t_bug_file['user_id'], $t_bug_file['content']\n\t\t) );\n\t}\n}\n\n/**\n * Returns a possibly override content type for a file name\n *\n * @param string $p_filename The filename of the file which will be downloaded.\n * @return string the content type, or empty if it should not be overridden\n */\nfunction file_get_content_type_override( $p_filename ) {\n\tglobal $g_file_download_content_type_overrides;\n\n\t$t_extension = pathinfo( $p_filename, PATHINFO_EXTENSION );\n\n\tif( isset( $g_file_download_content_type_overrides[$t_extension] ) ) {\n\t\treturn $g_file_download_content_type_overrides[$t_extension];\n\t}\n\n\treturn null;\n}\n\n/**\n * Return the maximum file size that can be uploaded, based on mantis and php\n * configured setting.\n * @return integer\tFile size in bytes\n */\nfunction file_get_max_file_size() {\n\treturn (int)min( ini_get_number( 'upload_max_filesize' ), ini_get_number( 'post_max_size' ), config_get( 'max_file_size' ) );\n}"], "filenames": ["core/file_api.php"], "buggy_code_start_loc": [220], "buggy_code_end_loc": [274], "fixing_code_start_loc": [221], "fixing_code_end_loc": [312], "type": "CWE-862", "message": "An issue was discovered in file_download.php in MantisBT before 2.24.3. Users without access to view private issue notes are able to download the (supposedly private) attachments linked to these notes by accessing the corresponding file download URL directly.", "other": {"cve": {"id": "CVE-2020-25781", "sourceIdentifier": "cve@mitre.org", "published": "2020-09-30T21:15:13.230", "lastModified": "2021-07-21T11:39:23.747", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in file_download.php in MantisBT before 2.24.3. Users without access to view private issue notes are able to download the (supposedly private) attachments linked to these notes by accessing the corresponding file download URL directly."}, {"lang": "es", "value": "Se detect\u00f3 un problema en el archivo file_download.php en MantisBT versiones anteriores a 2.24.3.&#xa0;Los usuarios sin acceso para visualizar notas de problemas privados pueden descargar los archivos adjuntos (supuestamente privados) vinculados a estas notas al acceder directamente a la URL de descarga de archivo correspondiente"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-862"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.24.3", "matchCriteriaId": "AAC99001-43F4-461D-9C3A-AB33CA4B9F94"}]}]}], "references": [{"url": "http://github.com/mantisbt/mantisbt/commit/5595c90f11c48164331a20bb9c66098980516e93", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "http://github.com/mantisbt/mantisbt/commit/9de20c09e5a557e57159a61657ce62f1a4f578fe", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://mantisbt.org/bugs/view.php?id=27039", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Vendor Advisory"]}]}, "github_commit_url": "http://github.com/mantisbt/mantisbt/commit/5595c90f11c48164331a20bb9c66098980516e93"}}