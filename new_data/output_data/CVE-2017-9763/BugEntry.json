{"buggy_code": ["/* radare - LGPL - Copyright 2009-2017 // pancake */\n\nstatic int cmd_mkdir(void *data, const char *input) {\n\tchar *res = r_syscmd_mkdir (input);\n\tif (res) {\n\t\tr_cons_print (res);\n\t\tfree (res);\n\t}\n\treturn 0;\n}\n\nstatic int cmd_mv(void *data, const char *input) {\n\treturn r_syscmd_mv (input)? 1: 0;\n}\n\nstatic int cmd_mount(void *data, const char *_input) {\n\tut64 off = 0;\n\tchar *input, *oinput, *ptr, *ptr2;\n\tRList *list;\n\tRListIter *iter;\n\tRFSFile *file;\n\tRFSRoot *root;\n\tRFSPlugin *plug;\n\tRFSPartition *part;\n\tRCore *core = (RCore *)data;\n\n\tif (!strncmp (\"kdir\", _input, 4)) {\n\t\treturn cmd_mkdir (data, _input);\n\t}\n\tif (!strncmp (\"v\", _input, 1)) {\n\t\treturn cmd_mv (data, _input);\n\t}\n\tinput = oinput = strdup (_input);\n\n\tswitch (*input) {\n\tcase ' ':\n\t\tinput++;\n\t\tif (input[0]==' ')\n\t\t\tinput++;\n\t\tptr = strchr (input, ' ');\n\t\tif (ptr) {\n\t\t\t*ptr = 0;\n\t\t\tptr++;\n\t\t\tptr2 = strchr (ptr, ' ');\n\t\t\tif (ptr2) {\n\t\t\t\t*ptr2 = 0;\n\t\t\t\toff = r_num_math (core->num, ptr2+1);\n\t\t\t}\n\t\t\tif (!r_fs_mount (core->fs, ptr, input, off))\n\t\t\t\teprintf (\"Cannot mount %s\\n\", input);\n\t\t} else {\n\t\t\tif (!(ptr = r_fs_name (core->fs, core->offset)))\n\t\t\t\teprintf (\"Unknown filesystem type\\n\");\n\t\t\telse if (!r_fs_mount (core->fs, ptr, input, core->offset))\n\t\t\t\teprintf (\"Cannot mount %s\\n\", input);\n\t\t\tfree (ptr);\n\t\t}\n\t\tbreak;\n\tcase '-':\n\t\tr_fs_umount (core->fs, input+1);\n\t\tbreak;\n\tcase '*':\n\t\teprintf (\"List commands in radare format\\n\");\n\t\tr_list_foreach (core->fs->roots, iter, root) {\n\t\t\tr_cons_printf (\"m %s %s 0x%\"PFMT64x\"\\n\",\n\t\t\t\troot-> path, root->p->name, root->delta);\n\t\t}\n\t\tbreak;\n\tcase '\\0':\n\t\tr_list_foreach (core->fs->roots, iter, root) {\n\t\t\tr_cons_printf (\"%s\\t0x%\"PFMT64x\"\\t%s\\n\",\n\t\t\t\troot->p->name, root->delta, root->path);\n\t\t}\n\t\tbreak;\n\tcase 'l': // list of plugins\n\t\tr_list_foreach (core->fs->plugins, iter, plug) {\n\t\t\tr_cons_printf (\"%10s  %s\\n\", plug->name, plug->desc);\n\t\t}\n\t\tbreak;\n\tcase 'd':\n\t\tinput++;\n\t\tif (input[0]==' ')\n\t\t\tinput++;\n\t\tlist = r_fs_dir (core->fs, input);\n\t\tif (list) {\n\t\t\tr_list_foreach (list, iter, file) {\n\t\t\t\tr_cons_printf (\"%c %s\\n\", file->type, file->name);\n\t\t\t}\n\t\t\tr_list_free (list);\n\t\t} else eprintf (\"Cannot open '%s' directory\\n\", input);\n\t\tbreak;\n\tcase 'p':\n\t\tinput++;\n\t\tif (*input == ' ')\n\t\t\tinput++;\n\t\tptr = strchr (input, ' ');\n\t\tif (ptr) {\n\t\t\t*ptr = 0;\n\t\t\toff = r_num_math (core->num, ptr+1);\n\t\t}\n\t\tlist = r_fs_partitions (core->fs, input, off);\n\t\tif (list) {\n\t\t\tr_list_foreach (list, iter, part) {\n\t\t\t\tr_cons_printf (\"%d %02x 0x%010\"PFMT64x\" 0x%010\"PFMT64x\"\\n\",\n\t\t\t\t\tpart->number, part->type,\n\t\t\t\t\tpart->start, part->start+part->length);\n\t\t\t}\n\t\t\tr_list_free (list);\n\t\t} else eprintf (\"Cannot read partition\\n\");\n\t\tbreak;\n\tcase 'o':\n\t\tinput++;\n\t\tif (input[0]==' ')\n\t\t\tinput++;\n\t\tfile = r_fs_open (core->fs, input);\n\t\tif (file) {\n\t\t\t// XXX: dump to file or just pipe?\n\t\t\tr_fs_read (core->fs, file, 0, file->size);\n\t\t\tr_cons_printf (\"f file %d 0x%08\"PFMT64x\"\\n\", file->size, file->off);\n\t\t\tr_fs_close (core->fs, file);\n\t\t} else eprintf (\"Cannot open file\\n\");\n\t\tbreak;\n\tcase 'g':\n\t\tinput++;\n\t\tif (*input == ' ')\n\t\t\tinput++;\n\t\tptr = strchr (input, ' ');\n\t\tif (ptr)\n\t\t\t*ptr++ = 0;\n\t\telse\n\t\t\tptr = \"./\";\n\t\tfile = r_fs_open (core->fs, input);\n\t\tif (file) {\n\t\t\tr_fs_read (core->fs, file, 0, file->size);\n\t\t\twrite (1, file->data, file->size);\n\t\t\tr_fs_close (core->fs, file);\n\t\t\twrite (1, \"\\n\", 1);\n\t\t} else if (!r_fs_dir_dump (core->fs, input, ptr))\n\t\t\teprintf (\"Cannot open file\\n\");\n\t\tbreak;\n\tcase 'f':\n\t\tinput++;\n\t\tswitch (*input) {\n\t\tcase '?':\n\t\t\tr_cons_printf (\n\t\t\t\"Usage: mf[no] [...]\\n\"\n\t\t\t\" mfn /foo *.c       ; search files by name in /foo path\\n\"\n\t\t\t\" mfo /foo 0x5e91    ; search files by offset in /foo path\\n\"\n\t\t\t);\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tinput++;\n\t\t\tif (*input == ' ')\n\t\t\t\tinput++;\n\t\t\tptr = strchr (input, ' ');\n\t\t\tif (ptr) {\n\t\t\t\t*ptr++ = 0;\n\t\t\t\tlist = r_fs_find_name (core->fs, input, ptr);\n\t\t\t\tr_list_foreach (list, iter, ptr) {\n\t\t\t\t\tr_str_chop_path (ptr);\n\t\t\t\t\tprintf (\"%s\\n\", ptr);\n\t\t\t\t}\n\t\t\t\t//XXX: r_list_purge (list);\n\t\t\t} else eprintf (\"Unknown store path\\n\");\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tinput++;\n\t\t\tif (*input == ' ')\n\t\t\t\tinput++;\n\t\t\tptr = strchr (input, ' ');\n\t\t\tif (ptr) {\n\t\t\t\t*ptr++ = 0;\n\t\t\t\tut64 off = r_num_math (core->num, ptr);\n\t\t\t\tlist = r_fs_find_off (core->fs, input, off);\n\t\t\t\tr_list_foreach (list, iter, ptr) {\n\t\t\t\t\tr_str_chop_path (ptr);\n\t\t\t\t\tprintf (\"%s\\n\", ptr);\n\t\t\t\t}\n\t\t\t\t//XXX: r_list_purge (list);\n\t\t\t} else eprintf (\"Unknown store path\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 's':\n\t\tif (core->http_up) {\n\t\t\tfree (oinput);\n\t\t\treturn false;\n\t\t}\n\t\tinput++;\n\t\tif (input[0]==' ')\n\t\t\tinput++;\n\t\tr_fs_prompt (core->fs, input);\n\t\tbreak;\n\tcase 'y':\n\t\teprintf (\"TODO\\n\");\n\t\tbreak;\n\tcase '?': {\n\t\tconst char* help_msg[] = {\n\t\t\t\"Usage:\", \"m[-?*dgy] [...] \", \"Mountpoints management\",\n\t\t\t\"m\", \"\", \"List all mountpoints in human readable format\",\n\t\t\t\"m*\", \"\", \"Same as above, but in r2 commands\",\n\t\t\t\"ml\", \"\", \"List filesystem plugins\",\n\t\t\t\"m\", \" /mnt\", \"Mount fs at /mnt with autodetect fs and current offset\",\n\t\t\t\"m\", \" /mnt ext2 0\", \"Mount ext2 fs at /mnt with delta 0 on IO\",\n\t\t\t\"m-/\", \"\", \"Umount given path (/)\",\n\t\t\t\"my\", \"\", \"Yank contents of file into clipboard\",\n\t\t\t\"mo\", \" /foo\", \"Get offset and size of given file\",\n\t\t\t\"mg\", \" /foo\", \"Get contents of file/dir dumped to disk (XXX?)\",\n\t\t\t\"mf\", \"[?] [o|n]\", \"Search files for given filename or for offset\",\n\t\t\t\"md\", \" /\", \"List directory contents for path\",\n\t\t\t\"mp\", \"\", \"List all supported partition types\",\n\t\t\t\"mp\", \" msdos 0\", \"Show partitions in msdos format at offset 0\",\n\t\t\t\"ms\", \" /mnt\", \"Open filesystem prompt at /mnt\",\n\t\t\t//\"TODO: support multiple mountpoints and RFile IO's (need io+core refactorn\",\n\t\t\tNULL};\n\t\tr_core_cmd_help (core, help_msg);\n\t\t}\n\t\tbreak;\n\t}\n\tfree (oinput);\n\treturn 0;\n}\n\n\n", "/* ext2.c - Second Extended filesystem */\n/*\n *  GRUB  --  GRand Unified Bootloader\n *  Copyright (C) 2003,2004,2005,2007,2008,2009  Free Software Foundation, Inc.\n *\n *  GRUB is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  GRUB is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/* Magic value used to identify an ext2 filesystem.  */\n#define\tEXT2_MAGIC\t\t0xEF53\n/* Amount of indirect blocks in an inode.  */\n#define INDIRECT_BLOCKS\t\t12\n/* Maximum length of a pathname.  */\n#define EXT2_PATH_MAX\t\t4096\n/* Maximum nesting of symlinks, used to prevent a loop.  */\n#define\tEXT2_MAX_SYMLINKCNT\t8\n\n/* The good old revision and the default inode size.  */\n#define EXT2_GOOD_OLD_REVISION\t\t0\n#define EXT2_GOOD_OLD_INODE_SIZE\t128\n\n/* Filetype used in directory entry.  */\n#define\tFILETYPE_UNKNOWN\t0\n#define\tFILETYPE_REG\t\t1\n#define\tFILETYPE_DIRECTORY\t2\n#define\tFILETYPE_SYMLINK\t7\n\n/* Filetype information as used in inodes.  */\n#define FILETYPE_INO_MASK\t0170000\n#define FILETYPE_INO_REG\t0100000\n#define FILETYPE_INO_DIRECTORY\t0040000\n#define FILETYPE_INO_SYMLINK\t0120000\n\n#include <grub/err.h>\n#include <grub/file.h>\n#include <grub/mm.h>\n#include <grub/misc.h>\n#include <grub/disk.h>\n#include <grub/dl.h>\n#include <grub/types.h>\n#include <grub/fshelp.h>\n\n/* Log2 size of ext2 block in 512 blocks.  */\n#define LOG2_EXT2_BLOCK_SIZE(data)\t\t\t\\\n\t(grub_le_to_cpu32 (data->sblock.log2_block_size) + 1)\n\n/* Log2 size of ext2 block in bytes.  */\n#define LOG2_BLOCK_SIZE(data)\t\t\t\t\t\\\n\t(grub_le_to_cpu32 (data->sblock.log2_block_size) + 10)\n\n/* The size of an ext2 block in bytes.  */\n#define EXT2_BLOCK_SIZE(data)\t\t(1 << LOG2_BLOCK_SIZE (data))\n\n/* The revision level.  */\n#define EXT2_REVISION(data)\tgrub_le_to_cpu32 (data->sblock.revision_level)\n\n/* The inode size.  */\n#define EXT2_INODE_SIZE(data)\t\\\n        (EXT2_REVISION (data) == EXT2_GOOD_OLD_REVISION \\\n         ? EXT2_GOOD_OLD_INODE_SIZE \\\n         : grub_le_to_cpu16 (data->sblock.inode_size))\n\n/* Superblock filesystem feature flags (RW compatible)\n * A filesystem with any of these enabled can be read and written by a driver\n * that does not understand them without causing metadata/data corruption.  */\n#define EXT2_FEATURE_COMPAT_DIR_PREALLOC\t0x0001\n#define EXT2_FEATURE_COMPAT_IMAGIC_INODES\t0x0002\n#define EXT3_FEATURE_COMPAT_HAS_JOURNAL\t\t0x0004\n#define EXT2_FEATURE_COMPAT_EXT_ATTR\t\t0x0008\n#define EXT2_FEATURE_COMPAT_RESIZE_INODE\t0x0010\n#define EXT2_FEATURE_COMPAT_DIR_INDEX\t\t0x0020\n/* Superblock filesystem feature flags (RO compatible)\n * A filesystem with any of these enabled can be safely read by a driver that\n * does not understand them, but should not be written to, usually because\n * additional metadata is required.  */\n#define EXT2_FEATURE_RO_COMPAT_SPARSE_SUPER\t0x0001\n#define EXT2_FEATURE_RO_COMPAT_LARGE_FILE\t0x0002\n#define EXT2_FEATURE_RO_COMPAT_BTREE_DIR\t0x0004\n#define EXT4_FEATURE_RO_COMPAT_GDT_CSUM\t\t0x0010\n#define EXT4_FEATURE_RO_COMPAT_DIR_NLINK\t0x0020\n#define EXT4_FEATURE_RO_COMPAT_EXTRA_ISIZE\t0x0040\n/* Superblock filesystem feature flags (back-incompatible)\n * A filesystem with any of these enabled should not be attempted to be read\n * by a driver that does not understand them, since they usually indicate\n * metadata format changes that might confuse the reader.  */\n#define EXT2_FEATURE_INCOMPAT_COMPRESSION\t0x0001\n#define EXT2_FEATURE_INCOMPAT_FILETYPE\t\t0x0002\n#define EXT3_FEATURE_INCOMPAT_RECOVER\t\t0x0004 /* Needs recovery */\n#define EXT3_FEATURE_INCOMPAT_JOURNAL_DEV\t0x0008 /* Volume is journal device */\n#define EXT2_FEATURE_INCOMPAT_META_BG\t\t0x0010\n#define EXT4_FEATURE_INCOMPAT_EXTENTS\t\t0x0040 /* Extents used */\n#define EXT4_FEATURE_INCOMPAT_64BIT\t\t0x0080\n#define EXT4_FEATURE_INCOMPAT_FLEX_BG\t\t0x0200\n\n/* The set of back-incompatible features this driver DOES support. Add (OR)\n * flags here as the related features are implemented into the driver.  */\n#define EXT2_DRIVER_SUPPORTED_INCOMPAT ( EXT2_FEATURE_INCOMPAT_FILETYPE \\\n                                       | EXT4_FEATURE_INCOMPAT_EXTENTS  \\\n                                       | EXT4_FEATURE_INCOMPAT_FLEX_BG )\n/* List of rationales for the ignored \"incompatible\" features:\n * needs_recovery: Not really back-incompatible - was added as such to forbid\n *                 ext2 drivers from mounting an ext3 volume with a dirty\n *                 journal because they will ignore the journal, but the next\n *                 ext3 driver to mount the volume will find the journal and\n *                 replay it, potentially corrupting the metadata written by\n *                 the ext2 drivers. Safe to ignore for this RO driver.  */\n#define EXT2_DRIVER_IGNORED_INCOMPAT ( EXT3_FEATURE_INCOMPAT_RECOVER )\n\n\n#define EXT3_JOURNAL_MAGIC_NUMBER\t0xc03b3998U\n\n#define EXT3_JOURNAL_DESCRIPTOR_BLOCK\t1\n#define EXT3_JOURNAL_COMMIT_BLOCK\t2\n#define EXT3_JOURNAL_SUPERBLOCK_V1\t3\n#define EXT3_JOURNAL_SUPERBLOCK_V2\t4\n#define EXT3_JOURNAL_REVOKE_BLOCK\t5\n\n#define EXT3_JOURNAL_FLAG_ESCAPE\t1\n#define EXT3_JOURNAL_FLAG_SAME_UUID\t2\n#define EXT3_JOURNAL_FLAG_DELETED\t4\n#define EXT3_JOURNAL_FLAG_LAST_TAG\t8\n\n#define EXT4_EXTENTS_FLAG\t\t0x80000\n\n/* The ext2 superblock.  */\nstruct grub_ext2_sblock\n{\n  grub_uint32_t total_inodes;\n  grub_uint32_t total_blocks;\n  grub_uint32_t reserved_blocks;\n  grub_uint32_t free_blocks;\n  grub_uint32_t free_inodes;\n  grub_uint32_t first_data_block;\n  grub_uint32_t log2_block_size;\n  grub_uint32_t log2_fragment_size;\n  grub_uint32_t blocks_per_group;\n  grub_uint32_t fragments_per_group;\n  grub_uint32_t inodes_per_group;\n  grub_uint32_t mtime;\n  grub_uint32_t utime;\n  grub_uint16_t mnt_count;\n  grub_uint16_t max_mnt_count;\n  grub_uint16_t magic;\n  grub_uint16_t fs_state;\n  grub_uint16_t error_handling;\n  grub_uint16_t minor_revision_level;\n  grub_uint32_t lastcheck;\n  grub_uint32_t checkinterval;\n  grub_uint32_t creator_os;\n  grub_uint32_t revision_level;\n  grub_uint16_t uid_reserved;\n  grub_uint16_t gid_reserved;\n  grub_uint32_t first_inode;\n  grub_uint16_t inode_size;\n  grub_uint16_t block_group_number;\n  grub_uint32_t feature_compatibility;\n  grub_uint32_t feature_incompat;\n  grub_uint32_t feature_ro_compat;\n  grub_uint16_t uuid[8];\n  char volume_name[16];\n  char last_mounted_on[64];\n  grub_uint32_t compression_info;\n  grub_uint8_t prealloc_blocks;\n  grub_uint8_t prealloc_dir_blocks;\n  grub_uint16_t reserved_gdt_blocks;\n  grub_uint8_t journal_uuid[16];\n  grub_uint32_t journal_inum;\n  grub_uint32_t journal_dev;\n  grub_uint32_t last_orphan;\n  grub_uint32_t hash_seed[4];\n  grub_uint8_t def_hash_version;\n  grub_uint8_t jnl_backup_type;\n  grub_uint16_t reserved_word_pad;\n  grub_uint32_t default_mount_opts;\n  grub_uint32_t first_meta_bg;\n  grub_uint32_t mkfs_time;\n  grub_uint32_t jnl_blocks[17];\n};\n\n/* The ext2 blockgroup.  */\nstruct grub_ext2_block_group\n{\n  grub_uint32_t block_id;\n  grub_uint32_t inode_id;\n  grub_uint32_t inode_table_id;\n  grub_uint16_t free_blocks;\n  grub_uint16_t free_inodes;\n  grub_uint16_t used_dirs;\n  grub_uint16_t pad;\n  grub_uint32_t reserved[3];\n};\n\n/* The ext2 inode.  */\nstruct grub_ext2_inode\n{\n  grub_uint16_t mode;\n  grub_uint16_t uid;\n  grub_uint32_t size;\n  grub_uint32_t atime;\n  grub_uint32_t ctime;\n  grub_uint32_t mtime;\n  grub_uint32_t dtime;\n  grub_uint16_t gid;\n  grub_uint16_t nlinks;\n  grub_uint32_t blockcnt;  /* Blocks of 512 bytes!! */\n  grub_uint32_t flags;\n  grub_uint32_t osd1;\n  union\n  {\n    struct datablocks\n    {\n      grub_uint32_t dir_blocks[INDIRECT_BLOCKS];\n      grub_uint32_t indir_block;\n      grub_uint32_t double_indir_block;\n      grub_uint32_t triple_indir_block;\n    } blocks;\n    char symlink[60];\n  };\n  grub_uint32_t version;\n  grub_uint32_t acl;\n  grub_uint32_t dir_acl;\n  grub_uint32_t fragment_addr;\n  grub_uint32_t osd2[3];\n};\n\n/* The header of an ext2 directory entry.  */\nstruct ext2_dirent\n{\n  grub_uint32_t inode;\n  grub_uint16_t direntlen;\n  grub_uint8_t namelen;\n  grub_uint8_t filetype;\n};\n\nstruct grub_ext3_journal_header\n{\n  grub_uint32_t magic;\n  grub_uint32_t block_type;\n  grub_uint32_t sequence;\n};\n\nstruct grub_ext3_journal_revoke_header\n{\n  struct grub_ext3_journal_header header;\n  grub_uint32_t count;\n  grub_uint32_t data[0];\n};\n\nstruct grub_ext3_journal_block_tag\n{\n  grub_uint32_t block;\n  grub_uint32_t flags;\n};\n\nstruct grub_ext3_journal_sblock\n{\n  struct grub_ext3_journal_header header;\n  grub_uint32_t block_size;\n  grub_uint32_t maxlen;\n  grub_uint32_t first;\n  grub_uint32_t sequence;\n  grub_uint32_t start;\n};\n\n#define EXT4_EXT_MAGIC\t\t0xf30a\n\nstruct grub_ext4_extent_header\n{\n  grub_uint16_t magic;\n  grub_uint16_t entries;\n  grub_uint16_t max;\n  grub_uint16_t depth;\n  grub_uint32_t generation;\n};\n\nstruct grub_ext4_extent\n{\n  grub_uint32_t block;\n  grub_uint16_t len;\n  grub_uint16_t start_hi;\n  grub_uint32_t start;\n};\n\nstruct grub_ext4_extent_idx\n{\n  grub_uint32_t block;\n  grub_uint32_t leaf;\n  grub_uint16_t leaf_hi;\n  grub_uint16_t unused;\n};\n\nstruct grub_fshelp_node\n{\n  struct grub_ext2_data *data;\n  struct grub_ext2_inode inode;\n  int ino;\n  int inode_read;\n};\n\n/* Information about a \"mounted\" ext2 filesystem.  */\nstruct grub_ext2_data\n{\n  struct grub_ext2_sblock sblock;\n  grub_disk_t disk;\n  struct grub_ext2_inode *inode;\n  struct grub_fshelp_node diropen;\n};\n\nstatic grub_dl_t my_mod;\n\n\f\n\n/* Read into BLKGRP the blockgroup descriptor of blockgroup GROUP of\n   the mounted filesystem DATA.  */\ninline static grub_err_t\ngrub_ext2_blockgroup (struct grub_ext2_data *data, int group,\n\t\t      struct grub_ext2_block_group *blkgrp)\n{\n  return grub_disk_read (data->disk,\n                         ((grub_le_to_cpu32 (data->sblock.first_data_block) + 1)\n                          << LOG2_EXT2_BLOCK_SIZE (data)),\n\t\t\t group * sizeof (struct grub_ext2_block_group),\n\t\t\t sizeof (struct grub_ext2_block_group), blkgrp);\n}\n\nstatic struct grub_ext4_extent_header *\ngrub_ext4_find_leaf (struct grub_ext2_data *data, char *buf,\n                     struct grub_ext4_extent_header *ext_block,\n                     grub_uint32_t fileblock)\n{\n  struct grub_ext4_extent_idx *index;\n\n  while (1)\n    {\n      int i;\n      grub_disk_addr_t block;\n\n      index = (struct grub_ext4_extent_idx *) (ext_block + 1);\n\n      if (grub_le_to_cpu16(ext_block->magic) != EXT4_EXT_MAGIC)\n        return 0;\n\n      if (ext_block->depth == 0)\n        return ext_block;\n\n      for (i = 0; i < grub_le_to_cpu16 (ext_block->entries); i++)\n        {\n          if (fileblock < grub_le_to_cpu32(index[i].block))\n            break;\n        }\n\n      if (--i < 0)\n        return 0;\n\n      block = grub_le_to_cpu16 (index[i].leaf_hi);\n      block = (block << 32) + grub_le_to_cpu32 (index[i].leaf);\n      if (grub_disk_read (data->disk,\n                          block << LOG2_EXT2_BLOCK_SIZE (data),\n                          0, EXT2_BLOCK_SIZE(data), buf))\n        return 0;\n\n      ext_block = (struct grub_ext4_extent_header *) buf;\n    }\n}\n\nstatic grub_disk_addr_t\ngrub_ext2_read_block (grub_fshelp_node_t node, grub_disk_addr_t fileblock)\n{\n  struct grub_ext2_data *data = node->data;\n  struct grub_ext2_inode *inode = &node->inode;\n  int blknr = -1;\n  unsigned int blksz = EXT2_BLOCK_SIZE (data);\n  int log2_blksz = LOG2_EXT2_BLOCK_SIZE (data);\n\n  if (grub_le_to_cpu32(inode->flags) & EXT4_EXTENTS_FLAG)\n    {\n#ifndef _MSC_VER\n\t  char buf[EXT2_BLOCK_SIZE (data)];\n#else\n\t  char * buf = grub_malloc (EXT2_BLOCK_SIZE(data));\n#endif\n      struct grub_ext4_extent_header *leaf;\n      struct grub_ext4_extent *ext;\n      int i;\n\n      leaf = grub_ext4_find_leaf (data, buf,\n\t\t  (struct grub_ext4_extent_header *) inode->blocks.dir_blocks,\n\t\t  fileblock);\n      if (! leaf)\n        {\n          grub_error (GRUB_ERR_BAD_FS, \"invalid extent\");\n          return -1;\n        }\n\n      ext = (struct grub_ext4_extent *) (leaf + 1);\n      for (i = 0; i < grub_le_to_cpu16 (leaf->entries); i++)\n        {\n          if (fileblock < grub_le_to_cpu32 (ext[i].block))\n            break;\n        }\n\n      if (--i >= 0)\n        {\n          fileblock -= grub_le_to_cpu32 (ext[i].block);\n          if (fileblock >= grub_le_to_cpu16 (ext[i].len))\n            return 0;\n          else\n            {\n              grub_disk_addr_t start;\n\n              start = grub_le_to_cpu16 (ext[i].start_hi);\n              start = (start << 32) + grub_le_to_cpu32 (ext[i].start);\n\n              return fileblock + start;\n            }\n        }\n      else\n        {\n          grub_error (GRUB_ERR_BAD_FS, \"something wrong with extent\");\n          return -1;\n        }\n    }\n  /* Direct blocks.  */\n  if (fileblock < INDIRECT_BLOCKS) {\n    blknr = grub_le_to_cpu32 (inode->blocks.dir_blocks[fileblock]);\n  /* Indirect.  */\n  } else if (fileblock < INDIRECT_BLOCKS + blksz / 4)\n    {\n      grub_uint32_t *indir;\n\n      indir = grub_malloc (blksz);\n      if (! indir)\n\treturn grub_errno;\n\n      if (grub_disk_read (data->disk,\n\t\t\t  ((grub_disk_addr_t)\n\t\t\t   grub_le_to_cpu32 (inode->blocks.indir_block))\n\t\t\t  << log2_blksz,\n\t\t\t  0, blksz, indir))\n\treturn grub_errno;\n\n      blknr = grub_le_to_cpu32 (indir[fileblock - INDIRECT_BLOCKS]);\n      grub_free (indir);\n    }\n  /* Double indirect.  */\n  else if (fileblock < (grub_disk_addr_t)(INDIRECT_BLOCKS + blksz / 4) \\\n\t\t  * (grub_disk_addr_t)(blksz / 4 + 1))\n    {\n      unsigned int perblock = blksz / 4;\n      unsigned int rblock = fileblock - (INDIRECT_BLOCKS\n\t\t\t\t\t + blksz / 4);\n      grub_uint32_t *indir;\n\n      indir = grub_malloc (blksz);\n      if (! indir)\n\treturn grub_errno;\n\n      if (grub_disk_read (data->disk,\n\t\t\t  ((grub_disk_addr_t)\n\t\t\t   grub_le_to_cpu32 (inode->blocks.double_indir_block))\n\t\t\t  << log2_blksz,\n\t\t\t  0, blksz, indir))\n\treturn grub_errno;\n\n      if (grub_disk_read (data->disk,\n\t\t\t  ((grub_disk_addr_t)\n\t\t\t   grub_le_to_cpu32 (indir[rblock / perblock]))\n\t\t\t  << log2_blksz,\n\t\t\t  0, blksz, indir))\n\treturn grub_errno;\n\n      blknr = grub_le_to_cpu32 (indir[rblock % perblock]);\n            grub_free (indir);\n    }\n  /* triple indirect.  */\n  else\n    {\n      grub_error (GRUB_ERR_NOT_IMPLEMENTED_YET,\n\t\t  \"ext2fs doesn't support triple indirect blocks\");\n    }\n\n  return blknr;\n}\n\n/* Read LEN bytes from the file described by DATA starting with byte\n   POS.  Return the amount of read bytes in READ.  */\nstatic grub_ssize_t\ngrub_ext2_read_file (grub_fshelp_node_t node,\n     void (*read_hook) (grub_disk_addr_t sector,\n\t\tunsigned offset, unsigned length, void *closure),\n     void *closure, int flags, int pos, grub_size_t len, char *buf)\n{\n\treturn grub_fshelp_read_file (node->data->disk, node, read_hook, closure,\n\t\tflags, pos, len, buf, grub_ext2_read_block,\n\t\tnode->inode.size, LOG2_EXT2_BLOCK_SIZE (node->data));\n}\n\n\n/* Read the inode INO for the file described by DATA into INODE.  */\nstatic grub_err_t\ngrub_ext2_read_inode (struct grub_ext2_data *data,\n\t\t      int ino, struct grub_ext2_inode *inode)\n{\n  struct grub_ext2_block_group blkgrp;\n  struct grub_ext2_sblock *sblock = &data->sblock;\n  int inodes_per_block;\n  unsigned int blkno;\n  unsigned int blkoff;\n\n  /* It is easier to calculate if the first inode is 0.  */\n  ino--;\n  int div = grub_le_to_cpu32 (sblock->inodes_per_group);\n  if (div < 1) {\n    return grub_errno = GRUB_ERR_BAD_FS;\n  }\n  grub_ext2_blockgroup (data, ino / div, &blkgrp);\n  if (grub_errno)\n    return grub_errno;\n\n  int inode_size = EXT2_INODE_SIZE (data);\n  if (inode_size < 1) {\n    return grub_errno = GRUB_ERR_BAD_FS;\n  }\n  inodes_per_block = EXT2_BLOCK_SIZE (data) / inode_size;\n  if (inodes_per_block < 1) {\n    return grub_errno = GRUB_ERR_BAD_FS;\n  }\n  blkno = (ino % grub_le_to_cpu32 (sblock->inodes_per_group))\n    / inodes_per_block;\n  blkoff = (ino % grub_le_to_cpu32 (sblock->inodes_per_group))\n    % inodes_per_block;\n\n  /* Read the inode.  */\n  if (grub_disk_read (data->disk,\n\t\t      ((grub_le_to_cpu32 (blkgrp.inode_table_id) + blkno)\n\t\t        << LOG2_EXT2_BLOCK_SIZE (data)),\n\t\t      EXT2_INODE_SIZE (data) * blkoff,\n\t\t      sizeof (struct grub_ext2_inode), inode))\n    return grub_errno;\n\n  return 0;\n}\n\nstatic struct grub_ext2_data *\ngrub_ext2_mount (grub_disk_t disk)\n{\n  struct grub_ext2_data *data;\n\n  data = grub_malloc (sizeof (struct grub_ext2_data));\n  if (!data)\n    return 0;\n\n  /* Read the superblock.  */\n  grub_disk_read (disk, 1 * 2, 0, sizeof (struct grub_ext2_sblock),\n                  &data->sblock);\n  if (grub_errno)\n    goto fail;\n\n  /* Make sure this is an ext2 filesystem.  */\n  if (grub_le_to_cpu16 (data->sblock.magic) != EXT2_MAGIC)\n    {\n      grub_error (GRUB_ERR_BAD_FS, \"not an ext2 filesystem\");\n      goto fail;\n    }\n\n  /* Check the FS doesn't have feature bits enabled that we don't support. */\n  if (grub_le_to_cpu32 (data->sblock.feature_incompat)\n        & ~(EXT2_DRIVER_SUPPORTED_INCOMPAT | EXT2_DRIVER_IGNORED_INCOMPAT))\n    {\n      grub_error (GRUB_ERR_BAD_FS, \"filesystem has unsupported incompatible features\");\n      goto fail;\n    }\n\n\n  data->disk = disk;\n\n  data->diropen.data = data;\n  data->diropen.ino = 2;\n  data->diropen.inode_read = 1;\n\n  data->inode = &data->diropen.inode;\n\n  grub_ext2_read_inode (data, 2, data->inode);\n  if (grub_errno)\n    goto fail;\n\n  return data;\n\n fail:\n  if (grub_errno == GRUB_ERR_OUT_OF_RANGE)\n    grub_error (GRUB_ERR_BAD_FS, \"not an ext2 filesystem\");\n\n  grub_free (data);\n  return 0;\n}\n\nstatic char *\ngrub_ext2_read_symlink (grub_fshelp_node_t node)\n{\n  char *symlink;\n  struct grub_fshelp_node *diro = node;\n\n  if (! diro->inode_read)\n    {\n      grub_ext2_read_inode (diro->data, diro->ino, &diro->inode);\n      if (grub_errno)\n\treturn 0;\n    }\n\n  symlink = grub_malloc (grub_le_to_cpu32 (diro->inode.size) + 1);\n  if (! symlink)\n    return 0;\n\n  /* If the filesize of the symlink is bigger than\n     60 the symlink is stored in a separate block,\n     otherwise it is stored in the inode.  */\n  if (grub_le_to_cpu32 (diro->inode.size) <= 60)\n    grub_strncpy (symlink,\n\t\t  diro->inode.symlink,\n\t\t  grub_le_to_cpu32 (diro->inode.size));\n  else\n    {\n      grub_ext2_read_file (diro, 0, 0, 0, 0,\n\t\t\t   grub_le_to_cpu32 (diro->inode.size),\n\t\t\t   symlink);\n      if (grub_errno)\n\t{\n\t  grub_free (symlink);\n\t  return 0;\n\t}\n    }\n\n  symlink[grub_le_to_cpu32 (diro->inode.size)] = '\\0';\n  return symlink;\n}\n\nstatic int\ngrub_ext2_iterate_dir (grub_fshelp_node_t dir,\n\t\t       int (*hook) (const char *filename,\n\t\t\t\t    enum grub_fshelp_filetype filetype,\n\t\t\t\t    grub_fshelp_node_t node,\n\t\t\t\t    void *closure),\n\t\t       void *closure)\n{\n  unsigned int fpos = 0;\n  struct grub_fshelp_node *diro = (struct grub_fshelp_node *) dir;\n\n  if (! diro->inode_read)\n    {\n      grub_ext2_read_inode (diro->data, diro->ino, &diro->inode);\n      if (grub_errno)\n\treturn 0;\n    }\n\n  /* Search the file.  */\n  if (hook)\n  while (fpos < grub_le_to_cpu32 (diro->inode.size))\n    {\n      struct ext2_dirent dirent;\n\n      grub_ext2_read_file (diro, NULL, NULL, 0, fpos, sizeof (dirent),\n\t\t\t   (char *) &dirent);\n      if (grub_errno)\n\treturn 0;\n\n      if (dirent.direntlen == 0)\n        return 0;\n\n      if (dirent.namelen != 0)\n\t{\n\t  char * filename = grub_malloc (dirent.namelen + 1);\n\t  struct grub_fshelp_node *fdiro;\n\t  enum grub_fshelp_filetype type = GRUB_FSHELP_UNKNOWN;\n\nif (!filename) {\nbreak;\n}\n\t  grub_ext2_read_file (diro, 0, 0, 0,\n\t\t\t       fpos + sizeof (struct ext2_dirent),\n\t\t\t       dirent.namelen, filename);\n\t  if (grub_errno) {\n            grub_free (filename);\n\t    return 0;\n\t  }\n\n\t  fdiro = grub_malloc (sizeof (struct grub_fshelp_node));\n\t  if (! fdiro) {\n            grub_free (filename);\n\t    return 0;\n          }\n\n\t  fdiro->data = diro->data;\n\t  fdiro->ino = grub_le_to_cpu32 (dirent.inode);\n\n\t  filename[dirent.namelen] = '\\0';\n\n\t  if (dirent.filetype != FILETYPE_UNKNOWN)\n\t    {\n\t      fdiro->inode_read = 0;\n\n\t      if (dirent.filetype == FILETYPE_DIRECTORY)\n\t\ttype = GRUB_FSHELP_DIR;\n\t      else if (dirent.filetype == FILETYPE_SYMLINK)\n\t\ttype = GRUB_FSHELP_SYMLINK;\n\t      else if (dirent.filetype == FILETYPE_REG)\n\t\ttype = GRUB_FSHELP_REG;\n\t    }\n\t  else\n\t    {\n\t      /* The filetype can not be read from the dirent, read\n\t\t the inode to get more information.  */\n\t      grub_ext2_read_inode (diro->data,\n                                    grub_le_to_cpu32 (dirent.inode),\n\t\t\t\t    &fdiro->inode);\n\t      if (grub_errno) {\n                  grub_free (filename);\n\t\t  grub_free (fdiro);\n\t\t  return 0;\n\t\t}\n\n\t      fdiro->inode_read = 1;\n\n\t      if ((grub_le_to_cpu16 (fdiro->inode.mode)\n\t\t   & FILETYPE_INO_MASK) == FILETYPE_INO_DIRECTORY)\n\t\ttype = GRUB_FSHELP_DIR;\n\t      else if ((grub_le_to_cpu16 (fdiro->inode.mode)\n\t\t\t& FILETYPE_INO_MASK) == FILETYPE_INO_SYMLINK)\n\t\ttype = GRUB_FSHELP_SYMLINK;\n\t      else if ((grub_le_to_cpu16 (fdiro->inode.mode)\n\t\t\t& FILETYPE_INO_MASK) == FILETYPE_INO_REG)\n\t\ttype = GRUB_FSHELP_REG;\n\t    }\n\n\t  if (hook (filename, type, fdiro, closure)) {\n            grub_free (filename);\n\t    return 1;\n          }\n          grub_free (filename);\n\t}\n\n      fpos += grub_le_to_cpu16 (dirent.direntlen);\n    }\n\n  return 0;\n}\n\n/* Open a file named NAME and initialize FILE.  */\nstatic grub_err_t\ngrub_ext2_open (struct grub_file *file, const char *name)\n{\n  struct grub_ext2_data *data;\n  struct grub_fshelp_node *fdiro = 0;\n\n  grub_dl_ref (my_mod);\n\n  data = grub_ext2_mount (file->device->disk);\n  if (! data)\n    goto fail;\n\n  grub_fshelp_find_file (name, &data->diropen, &fdiro, grub_ext2_iterate_dir, 0,\n\t\t\t grub_ext2_read_symlink, GRUB_FSHELP_REG);\n  if (grub_errno)\n    goto fail;\n\n  if (! fdiro->inode_read)\n    {\n      grub_ext2_read_inode (data, fdiro->ino, &fdiro->inode);\n      if (grub_errno)\n\tgoto fail;\n    }\n\n  grub_memcpy (data->inode, &fdiro->inode, sizeof (struct grub_ext2_inode));\n  grub_free (fdiro);\n\n  file->size = grub_le_to_cpu32 (data->inode->size);\n  file->data = data;\n  file->offset = 0;\n\n  return 0;\n\n fail:\n  if (fdiro != &data->diropen)\n    grub_free (fdiro);\n  grub_free (data);\n\n  grub_dl_unref (my_mod);\n\n  return grub_errno;\n}\n\nstatic grub_err_t\ngrub_ext2_close (grub_file_t file)\n{\n  grub_free (file->data);\n\n  grub_dl_unref (my_mod);\n\n  return GRUB_ERR_NONE;\n}\n\n/* Read LEN bytes data from FILE into BUF.  */\nstatic grub_ssize_t\ngrub_ext2_read (grub_file_t file, char *buf, grub_size_t len)\n{\n  struct grub_ext2_data *data = (struct grub_ext2_data *) file->data;\n  return grub_ext2_read_file (&data->diropen, file->read_hook, file->closure,\n\t\t\t      file->flags, file->offset, len, buf);\n}\n\nstruct grub_ext2_dir_closure\n{\n  int (*hook) (const char *filename,\n\t       const struct grub_dirhook_info *info,\n\t       void *closure);\n  void *closure;\n  struct grub_ext2_data *data;\n};\n\nstatic int\niterate (const char *filename,\n\t enum grub_fshelp_filetype filetype,\n\t grub_fshelp_node_t node,\n\t void *closure)\n{\n  struct grub_ext2_dir_closure *c = closure;\n  struct grub_dirhook_info info;\n  grub_memset (&info, 0, sizeof (info));\n  if (! node->inode_read)\n    {\n      grub_ext2_read_inode (c->data, node->ino, &node->inode);\n      if (!grub_errno)\n\tnode->inode_read = 1;\n      grub_errno = GRUB_ERR_NONE;\n    }\n  if (node->inode_read)\n    {\n      info.mtimeset = 1;\n      info.mtime = grub_le_to_cpu32 (node->inode.mtime);\n    }\n\n  info.dir = ((filetype & GRUB_FSHELP_TYPE_MASK) == GRUB_FSHELP_DIR);\n  grub_free (node);\n  return (c->hook != NULL)? c->hook (filename, &info, c->closure): 0;\n}\n\nstatic grub_err_t\ngrub_ext2_dir (grub_device_t device, const char *path,\n\t       int (*hook) (const char *filename,\n\t\t\t    const struct grub_dirhook_info *info,\n\t\t\t    void *closure),\n\t       void *closure)\n{\n  struct grub_ext2_data *data = 0;\n  struct grub_fshelp_node *fdiro = 0;\n  struct grub_ext2_dir_closure c;\n\n  grub_dl_ref (my_mod);\n\n  data = grub_ext2_mount (device->disk);\n  if (! data)\n    goto fail;\n\n  grub_fshelp_find_file (path, &data->diropen, &fdiro, grub_ext2_iterate_dir,\n\t\t\t 0, grub_ext2_read_symlink, GRUB_FSHELP_DIR);\n  if (grub_errno)\n    goto fail;\n\n  c.hook = hook;\n  c.closure = closure;\n  c.data = data;\n  grub_ext2_iterate_dir (fdiro, iterate, &c);\n\n fail:\n  if (fdiro != &data->diropen)\n    grub_free (fdiro);\n  grub_free (data);\n\n  grub_dl_unref (my_mod);\n\n  return grub_errno;\n}\n\nstatic grub_err_t\ngrub_ext2_label (grub_device_t device, char **label)\n{\n  struct grub_ext2_data *data;\n  grub_disk_t disk = device->disk;\n\n  grub_dl_ref (my_mod);\n\n  data = grub_ext2_mount (disk);\n  if (data)\n    *label = grub_strndup (data->sblock.volume_name, 14);\n  else\n    *label = NULL;\n\n  grub_dl_unref (my_mod);\n\n  grub_free (data);\n\n  return grub_errno;\n}\n\nstatic grub_err_t\ngrub_ext2_uuid (grub_device_t device, char **uuid)\n{\n  struct grub_ext2_data *data;\n  grub_disk_t disk = device->disk;\n\n  grub_dl_ref (my_mod);\n\n  data = grub_ext2_mount (disk);\n  if (data)\n    {\n      *uuid = grub_xasprintf (\"%04x%04x-%04x-%04x-%04x-%04x%04x%04x\",\n\t\t\t     grub_be_to_cpu16 (data->sblock.uuid[0]),\n\t\t\t     grub_be_to_cpu16 (data->sblock.uuid[1]),\n\t\t\t     grub_be_to_cpu16 (data->sblock.uuid[2]),\n\t\t\t     grub_be_to_cpu16 (data->sblock.uuid[3]),\n\t\t\t     grub_be_to_cpu16 (data->sblock.uuid[4]),\n\t\t\t     grub_be_to_cpu16 (data->sblock.uuid[5]),\n\t\t\t     grub_be_to_cpu16 (data->sblock.uuid[6]),\n\t\t\t     grub_be_to_cpu16 (data->sblock.uuid[7]));\n    }\n  else\n    *uuid = NULL;\n\n  grub_dl_unref (my_mod);\n\n  grub_free (data);\n\n  return grub_errno;\n}\n\n/* Get mtime.  */\nstatic grub_err_t\ngrub_ext2_mtime (grub_device_t device, grub_int32_t *tm)\n{\n  struct grub_ext2_data *data;\n  grub_disk_t disk = device->disk;\n\n  grub_dl_ref (my_mod);\n\n  data = grub_ext2_mount (disk);\n  if (!data)\n    *tm = 0;\n  else\n    *tm = grub_le_to_cpu32 (data->sblock.utime);\n\n  grub_dl_unref (my_mod);\n\n  grub_free (data);\n\n  return grub_errno;\n\n}\n\n\n\f\nstruct grub_fs grub_ext2_fs =\n  {\n    .name = \"ext2\",\n    .dir = grub_ext2_dir,\n    .open = grub_ext2_open,\n    .read = grub_ext2_read,\n    .close = grub_ext2_close,\n    .label = grub_ext2_label,\n    .uuid = grub_ext2_uuid,\n    .mtime = grub_ext2_mtime,\n#ifdef GRUB_UTIL\n    .reserved_first_sector = 1,\n#endif\n    .next = 0\n  };\n", "/* fshelp.c -- Filesystem helper functions */\n/*\n *  GRUB  --  GRand Unified Bootloader\n *  Copyright (C) 2004,2005,2006,2007,2008  Free Software Foundation, Inc.\n *\n *  GRUB is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  GRUB is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <grub/err.h>\n#include <grub/mm.h>\n#include <grub/misc.h>\n#include <grub/disk.h>\n#include <grub/fshelp.h>\n\nGRUB_EXPORT(grub_fshelp_view);\nGRUB_EXPORT(grub_fshelp_find_file);\nGRUB_EXPORT(grub_fshelp_log2blksize);\nGRUB_EXPORT(grub_fshelp_read_file);\n\nint grub_fshelp_view = 0;\n\nstruct grub_fshelp_find_file_closure\n{\n  grub_fshelp_node_t rootnode;\n  int (*iterate_dir) (grub_fshelp_node_t dir,\n\t\t      int (*hook)\n\t\t      (const char *filename,\n\t\t       enum grub_fshelp_filetype filetype,\n\t\t       grub_fshelp_node_t node, void *closure),\n\t\t      void *closure);\n  void *closure;\n  char *(*read_symlink) (grub_fshelp_node_t node);\n  int symlinknest;\n  enum grub_fshelp_filetype foundtype;\n  grub_fshelp_node_t currroot;\n};\n\nstatic void\nfree_node (grub_fshelp_node_t node, struct grub_fshelp_find_file_closure *c)\n{\n  if (node != c->rootnode && node != c->currroot)\n    grub_free (node);\n}\n\nstruct find_file_closure\n{\n  char *name;\n  enum grub_fshelp_filetype *type;\n  grub_fshelp_node_t *oldnode;\n  grub_fshelp_node_t *currnode;\n};\n\nstatic int\niterate (const char *filename,\n\t enum grub_fshelp_filetype filetype,\n\t grub_fshelp_node_t node,\n\t void *closure)\n{\n  struct find_file_closure *c = closure;\n\n  if (filetype == GRUB_FSHELP_UNKNOWN ||\n      (grub_strcmp (c->name, filename) &&\n       (! (filetype & GRUB_FSHELP_CASE_INSENSITIVE) ||\n\tgrub_strncasecmp (c->name, filename, GRUB_LONG_MAX))))\n    {\n      grub_free (node);\n      return 0;\n    }\n\n  /* The node is found, stop iterating over the nodes.  */\n  *(c->type) = filetype & ~GRUB_FSHELP_CASE_INSENSITIVE;\n  *(c->oldnode) = *(c->currnode);\n  *(c->currnode) = node;\n\n  return 1;\n}\n\nstatic grub_err_t\nfind_file (const char *currpath, grub_fshelp_node_t currroot,\n\t   grub_fshelp_node_t *currfound,\n\t   struct grub_fshelp_find_file_closure *c)\n{\n#ifndef _MSC_VER\n\tchar fpath[grub_strlen (currpath) + 1];\n#else\n\tchar *fpath = grub_malloc (grub_strlen (currpath) + 1);\n#endif\n  char *name = fpath;\n  char *next;\n  enum grub_fshelp_filetype type = GRUB_FSHELP_DIR;\n  grub_fshelp_node_t currnode = currroot;\n  grub_fshelp_node_t oldnode = currroot;\n\n  c->currroot = currroot;\n\n  grub_strncpy (fpath, currpath, grub_strlen (currpath) + 1);\n\n  /* Remove all leading slashes.  */\n  while (*name == '/')\n    name++;\n\n  if (! *name)\n    {\n      *currfound = currnode;\n      return 0;\n    }\n\n  for (;;)\n    {\n      int found;\n      struct find_file_closure cc;\n\n      /* Extract the actual part from the pathname.  */\n      next = grub_strchr (name, '/');\n      if (next)\n\t{\n\t  /* Remove all leading slashes.  */\n\t  while (*next == '/')\n\t    *(next++) = '\\0';\n\t}\n\n      /* At this point it is expected that the current node is a\n\t directory, check if this is true.  */\n      if (type != GRUB_FSHELP_DIR)\n\t{\n\t  free_node (currnode, c);\n\t  return grub_error (GRUB_ERR_BAD_FILE_TYPE, \"not a directory\");\n\t}\n\n      cc.name = name;\n      cc.type = &type;\n      cc.oldnode = &oldnode;\n      cc.currnode = &currnode;\n      /* Iterate over the directory.  */\n      found = c->iterate_dir (currnode, iterate, &cc);\n      if (! found)\n\t{\n\t  if (grub_errno)\n\t    return grub_errno;\n\n\t  break;\n\t}\n\n      /* Read in the symlink and follow it.  */\n      if (type == GRUB_FSHELP_SYMLINK)\n\t{\n\t  char *symlink;\n\n\t  /* Test if the symlink does not loop.  */\n\t  if (++(c->symlinknest) == 8)\n\t    {\n\t      free_node (currnode, c);\n\t      free_node (oldnode, c);\n\t      return grub_error (GRUB_ERR_SYMLINK_LOOP,\n\t\t\t\t \"too deep nesting of symlinks\");\n\t    }\n\n\t  symlink = c->read_symlink (currnode);\n\t  free_node (currnode, c);\n\n\t  if (!symlink)\n\t    {\n\t      free_node (oldnode, c);\n\t      return grub_errno;\n\t    }\n\n\t  /* The symlink is an absolute path, go back to the root inode.  */\n\t  if (symlink[0] == '/')\n\t    {\n\t      free_node (oldnode, c);\n\t      oldnode = c->rootnode;\n\t    }\n\n\t  /* Lookup the node the symlink points to.  */\n\t  find_file (symlink, oldnode, &currnode, c);\n\t  type = c->foundtype;\n\t  grub_free (symlink);\n\n\t  if (grub_errno)\n\t    {\n\t      free_node (oldnode, c);\n\t      return grub_errno;\n\t    }\n\t}\n\n      free_node (oldnode, c);\n\n      /* Found the node!  */\n      if (! next || *next == '\\0')\n\t{\n\t  *currfound = currnode;\n\t  c->foundtype = type;\n\t  return 0;\n\t}\n\n      name = next;\n    }\n\n  return grub_error (GRUB_ERR_FILE_NOT_FOUND, \"file not found\");\n}\n\n/* Lookup the node PATH.  The node ROOTNODE describes the root of the\n   directory tree.  The node found is returned in FOUNDNODE, which is\n   either a ROOTNODE or a new malloc'ed node.  ITERATE_DIR is used to\n   iterate over all directory entries in the current node.\n   READ_SYMLINK is used to read the symlink if a node is a symlink.\n   EXPECTTYPE is the type node that is expected by the called, an\n   error is generated if the node is not of the expected type.  Make\n   sure you use the NESTED_FUNC_ATTR macro for HOOK, this is required\n   because GCC has a nasty bug when using regparm=3.  */\ngrub_err_t\ngrub_fshelp_find_file (const char *path, grub_fshelp_node_t rootnode,\n\t\t       grub_fshelp_node_t *foundnode,\n\t\t       int (*iterate_dir) (grub_fshelp_node_t dir,\n\t\t\t\t\t   int (*hook)\n\t\t\t\t\t   (const char *filename,\n\t\t\t\t\t    enum grub_fshelp_filetype filetype,\n\t\t\t\t\t    grub_fshelp_node_t node,\n\t\t\t\t\t    void *closure),\n\t\t\t\t\t   void *closure),\n\t\t       void *closure,\n\t\t       char *(*read_symlink) (grub_fshelp_node_t node),\n\t\t       enum grub_fshelp_filetype expecttype)\n{\n  grub_err_t err;\n  struct grub_fshelp_find_file_closure c;\n\n  c.rootnode = rootnode;\n  c.iterate_dir = iterate_dir;\n  c.closure = closure;\n  c.read_symlink = read_symlink;\n  c.symlinknest = 0;\n  c.foundtype = GRUB_FSHELP_DIR;\n\n  if (!path || path[0] != '/')\n    {\n      grub_error (GRUB_ERR_BAD_FILENAME, \"bad filename\");\n      return grub_errno;\n    }\n\n  err = find_file (path, rootnode, foundnode, &c);\n  if (err)\n    return err;\n\n  /* Check if the node that was found was of the expected type.  */\n  if (expecttype == GRUB_FSHELP_REG && c.foundtype != expecttype)\n    return grub_error (GRUB_ERR_BAD_FILE_TYPE, \"not a regular file\");\n  else if (expecttype == GRUB_FSHELP_DIR && c.foundtype != expecttype)\n    return grub_error (GRUB_ERR_BAD_FILE_TYPE, \"not a directory\");\n\n  return 0;\n}\nunsigned long long grub_hack_lastoff = 0;\n\n/* Read LEN bytes from the file NODE on disk DISK into the buffer BUF,\n   beginning with the block POS.  READ_HOOK should be set before\n   reading a block from the file.  GET_BLOCK is used to translate file\n   blocks to disk blocks.  The file is FILESIZE bytes big and the\n   blocks have a size of LOG2BLOCKSIZE (in log2).  */\ngrub_ssize_t\ngrub_fshelp_read_file (grub_disk_t disk, grub_fshelp_node_t node,\n\t\t       void (*read_hook) (grub_disk_addr_t sector,\n\t\t\t\t\t  unsigned offset,\n\t\t\t\t\t  unsigned length,\n\t\t\t\t\t  void *closure),\n\t\t       void *closure, int flags,\n\t\t       grub_off_t pos, grub_size_t len, char *buf,\n\t\t       grub_disk_addr_t (*get_block) (grub_fshelp_node_t node,\n\t\t\t\t\t\t      grub_disk_addr_t block),\n\t\t       grub_off_t filesize, int log2blocksize)\n{\n  grub_disk_addr_t i, blockcnt;\n  int blocksize = 1 << (log2blocksize + GRUB_DISK_SECTOR_BITS);\n\n  /* Adjust LEN so it we can't read past the end of the file.  */\n  if (pos + len > filesize)\n    len = filesize - pos;\n\n  if (len < 1 || len == 0xffffffff) {\n    return -1;\n  }\n\n  blockcnt = ((len + pos) + blocksize - 1) >>\n    (log2blocksize + GRUB_DISK_SECTOR_BITS);\n\n  for (i = pos >> (log2blocksize + GRUB_DISK_SECTOR_BITS); i < blockcnt; i++)\n    {\n      grub_disk_addr_t blknr;\n      int blockoff = pos & (blocksize - 1);\n      int blockend = blocksize;\n\n      int skipfirst = 0;\n\n      blknr = get_block (node, i);\n      if (grub_errno)\n\treturn -1;\n\n      blknr = blknr << log2blocksize;\n\n      /* Last block.  */\n      if (i == blockcnt - 1)\n\t{\n\t  blockend = (len + pos) & (blocksize - 1);\n\n\t  /* The last portion is exactly blocksize.  */\n\t  if (! blockend)\n\t    blockend = blocksize;\n\t}\n\n      /* First block.  */\n      if (i == (pos >> (log2blocksize + GRUB_DISK_SECTOR_BITS)))\n\t{\n\t  skipfirst = blockoff;\n\t  blockend -= skipfirst;\n\t}\n\n      /* If the block number is 0 this block is not stored on disk but\n\t is zero filled instead.  */\n      if (blknr)\n\t{\n\t  disk->read_hook = read_hook;\n\t  disk->closure = closure;\n\n//printf (\"blknr: %d\\n\", blknr);\ngrub_hack_lastoff = blknr * 512;\n\t  grub_disk_read_ex (disk, blknr, skipfirst, blockend, buf, flags);\n\t  disk->read_hook = 0;\n\t  if (grub_errno)\n\t    return -1;\n\t}\n      else if (buf)\n\tgrub_memset (buf, 0, blockend);\n\n      if (buf)\n\tbuf += blocksize - skipfirst;\n    }\n\n  return len;\n}\n\nunsigned int\ngrub_fshelp_log2blksize (unsigned int blksize, unsigned int *pow)\n{\n  int mod;\n\n  *pow = 0;\n  while (blksize > 1)\n    {\n      mod = blksize - ((blksize >> 1) << 1);\n      blksize >>= 1;\n\n      /* Check if it really is a power of two.  */\n      if (mod)\n\treturn grub_error (GRUB_ERR_BAD_NUMBER,\n\t\t\t   \"the blocksize is not a power of two\");\n      (*pow)++;\n    }\n\n  return GRUB_ERR_NONE;\n}\n", "/* radare - LGPL - Copyright 2011 pancake<nopcode.org> */\n\n#include <r_io.h>\n#include <r_fs.h>\n#include \"grubfs.h\"\n#include <stdio.h>\n#include <string.h>\n\n\nstatic RIOBind *bio = NULL;\nstatic ut64 delta = 0;\n\nstatic void* empty (int sz) {\n\tvoid *p = malloc (sz);\n\tif (p) memset (p, '\\0', sz);\n\treturn p;\n}\n\nstatic grub_err_t read_foo (struct grub_disk *disk, grub_disk_addr_t sector, grub_size_t size, char *buf) {\n\tif (disk != NULL) {\n\t\tconst int blocksize = 512; // unhardcode 512\n\t\tint ret;\n\t\tRIOBind *iob = disk->data;\n\t\tif (bio) iob = bio;\n\t\t//printf (\"io %p\\n\", file->root->iob.io);\n\t\tret = iob->read_at (iob->io, delta+(blocksize*sector),\n\t\t\t(ut8*)buf, size*blocksize);\n\t\tif (ret == -1)\n\t\t\treturn 1;\n\t\t//printf (\"DISK PTR = %p\\n\", disk->data);\n\t\t//printf (\"\\nBUF: %x %x %x %x\\n\", buf[0], buf[1], buf[2], buf[3]);\n\t} else eprintf (\"oops. no disk\\n\");\n\treturn 0; // 0 is ok\n}\n\nGrubFS *grubfs_new (struct grub_fs *myfs, void *data) {\n\tstruct grub_file *file;\n\tGrubFS *gfs = empty (sizeof (GrubFS));\n\t// hacky mallocs :D\n\tgfs->file = file = empty (sizeof (struct grub_file));\n\tfile->device = empty (sizeof (struct grub_device)+1024);\n\tfile->device->disk = empty (sizeof (struct grub_disk));\n\tfile->device->disk->dev = (grub_disk_dev_t)file->device; // hack!\n\tfile->device->disk->dev->read = read_foo; // grub_disk_dev\n\tfile->device->disk->data = data;\n\t//file->device->disk->read_hook = read_foo; //read_hook;\n\tfile->fs = myfs;\n\treturn gfs;\n}\n\ngrub_disk_t grubfs_disk (void *data) {\n\tstruct grub_disk *disk = empty (sizeof (struct grub_disk));\n\tdisk->dev = empty (sizeof (struct grub_disk_dev));\n\tdisk->dev->read = read_foo; // grub_disk_dev\n\tdisk->data = data;\n\treturn disk;\n}\n\nvoid grubfs_free (GrubFS *gf) {\n\tif (gf) {\n\t\tif (gf->file && gf->file->device)\n\t\t\tfree (gf->file->device->disk);\n\t\t//free (gf->file->device);\n\t\tfree (gf->file);\n\t\tfree (gf);\n\t}\n}\n\nvoid grubfs_bind_io (RIOBind *iob, ut64 _delta) {\n\tbio = iob;\n\tdelta = _delta;\n}\n", "#!/bin/sh\n\nwhile : ; do\n\tif [ -f sys/rebuild.sh ]; then\n\t\tbreak\n\tfi\n\tcd ..\n\tif [ \"`pwd`\" = / ]; then\n\t\techo \"Cant find sys/rebuild.sh\"\n\t\texit 1\n\tfi\ndone\n\nRebuild() {\n\tcd \"$1\" || exit 1\n\tmake clean\n\tmake -j8 || exit 1\n\tcd -\n}\n\nBuild() {\n\tcd \"$1\" || exit 1\n\tmake -j8 || exit 1\n\tcd -\n}\n\nRebuildIOSDebug() {\n\tRebuild libr/debug\n\t# Rebuild libr/util\n\t# Rebuild libr/core\n\tRebuild binr/radare2\n\tmake -C binr/radare2 ios-sign\n\tif [ -n \"${IOSIP}\" ]; then\n\t\tscp binr/radare2/radare2 root@\"${IOSIP}:.\"\n\telse\n\t\techo \"Set IOSIP environment variable to scp the radare2 program\"\n\tfi\n}\n\nRebuildJava() {\n\tRebuild shlr/java\n\tRebuild libr/asm\n\tRebuild libr/bin\n\tRebuild libr/core\n}\n\nRebuildCapstone() {\n\tRebuild shlr/capstone\n\tRebuild libr/asm\n\tRebuild libr/anal\n}\n\nRebuildSdb() {\n\tRebuild shlr/sdb\n\tRebuild libr/util\n}\n\nRebuildFs() {\n\tRebuild shlr/grub\n\tRebuild libr/fs\n}\n\nRebuildBin() {\n\tRebuild libr/bin\n\tRebuild libr/core\n}\n\nRebuildGdb() {\n\tRebuild shlr/gdb\n\tRebuild libr/io\n\tRebuild libr/debug\n}\n\ncase \"$1\" in\nfs)     RebuildFs; ;;\nbin)    RebuildBin ; ;;\ngdb)    RebuildGdb ; ;;\nsdb)    RebuildSdb ; ;;\nspp)    RebuildSpp ; ;;\nbin)    RebuildBin ; ;;\njava)   RebuildJava ; ;;\niosdbg) RebuildIOSDebug ; ;;\ncapstone|cs) RebuildCapstone ; ;;\n*)\n\techo \"Usage: sys/rebuild.sh [gdb|java|capstone|sdb|iosdbg|cs|sdb|bin]\"\n\t;;\nesac\n"], "fixing_code": ["/* radare - LGPL - Copyright 2009-2017 // pancake */\n\nstatic int cmd_mkdir(void *data, const char *input) {\n\tchar *res = r_syscmd_mkdir (input);\n\tif (res) {\n\t\tr_cons_print (res);\n\t\tfree (res);\n\t}\n\treturn 0;\n}\n\nstatic int cmd_mv(void *data, const char *input) {\n\treturn r_syscmd_mv (input)? 1: 0;\n}\n\nstatic int cmd_mount(void *data, const char *_input) {\n\tut64 off = 0;\n\tchar *input, *oinput, *ptr, *ptr2;\n\tRList *list;\n\tRListIter *iter;\n\tRFSFile *file;\n\tRFSRoot *root;\n\tRFSPlugin *plug;\n\tRFSPartition *part;\n\tRCore *core = (RCore *)data;\n\n\tif (!strncmp (\"kdir\", _input, 4)) {\n\t\treturn cmd_mkdir (data, _input);\n\t}\n\tif (!strncmp (\"v\", _input, 1)) {\n\t\treturn cmd_mv (data, _input);\n\t}\n\tinput = oinput = strdup (_input);\n\n\tswitch (*input) {\n\tcase ' ':\n\t\tinput++;\n\t\tif (input[0]==' ') {\n\t\t\tinput++;\n\t\t}\n\t\tptr = strchr (input, ' ');\n\t\tif (ptr) {\n\t\t\t*ptr = 0;\n\t\t\tptr++;\n\t\t\tptr2 = strchr (ptr, ' ');\n\t\t\tif (ptr2) {\n\t\t\t\t*ptr2 = 0;\n\t\t\t\toff = r_num_math (core->num, ptr2+1);\n\t\t\t}\n\t\t\tif (!r_fs_mount (core->fs, ptr, input, off)) {\n\t\t\t\teprintf (\"Cannot mount %s\\n\", input);\n\t\t\t}\n\t\t} else {\n\t\t\tif (!(ptr = r_fs_name (core->fs, core->offset))) {\n\t\t\t\teprintf (\"Unknown filesystem type\\n\");\n\t\t\t} else if (!r_fs_mount (core->fs, ptr, input, core->offset)) {\n\t\t\t\teprintf (\"Cannot mount %s\\n\", input);\n\t\t\t}\n\t\t\tfree (ptr);\n\t\t}\n\t\tbreak;\n\tcase '-':\n\t\tr_fs_umount (core->fs, input+1);\n\t\tbreak;\n\tcase '*':\n\t\teprintf (\"List commands in radare format\\n\");\n\t\tr_list_foreach (core->fs->roots, iter, root) {\n\t\t\tr_cons_printf (\"m %s %s 0x%\"PFMT64x\"\\n\",\n\t\t\t\troot-> path, root->p->name, root->delta);\n\t\t}\n\t\tbreak;\n\tcase '\\0':\n\t\tr_list_foreach (core->fs->roots, iter, root) {\n\t\t\tr_cons_printf (\"%s\\t0x%\"PFMT64x\"\\t%s\\n\",\n\t\t\t\troot->p->name, root->delta, root->path);\n\t\t}\n\t\tbreak;\n\tcase 'l': // list of plugins\n\t\tr_list_foreach (core->fs->plugins, iter, plug) {\n\t\t\tr_cons_printf (\"%10s  %s\\n\", plug->name, plug->desc);\n\t\t}\n\t\tbreak;\n\tcase 'd':\n\t\tinput++;\n\t\tif (input[0]==' ')\n\t\t\tinput++;\n\t\tlist = r_fs_dir (core->fs, input);\n\t\tif (list) {\n\t\t\tr_list_foreach (list, iter, file) {\n\t\t\t\tr_cons_printf (\"%c %s\\n\", file->type, file->name);\n\t\t\t}\n\t\t\tr_list_free (list);\n\t\t} else eprintf (\"Cannot open '%s' directory\\n\", input);\n\t\tbreak;\n\tcase 'p':\n\t\tinput++;\n\t\tif (*input == ' ')\n\t\t\tinput++;\n\t\tptr = strchr (input, ' ');\n\t\tif (ptr) {\n\t\t\t*ptr = 0;\n\t\t\toff = r_num_math (core->num, ptr+1);\n\t\t}\n\t\tlist = r_fs_partitions (core->fs, input, off);\n\t\tif (list) {\n\t\t\tr_list_foreach (list, iter, part) {\n\t\t\t\tr_cons_printf (\"%d %02x 0x%010\"PFMT64x\" 0x%010\"PFMT64x\"\\n\",\n\t\t\t\t\tpart->number, part->type,\n\t\t\t\t\tpart->start, part->start+part->length);\n\t\t\t}\n\t\t\tr_list_free (list);\n\t\t} else eprintf (\"Cannot read partition\\n\");\n\t\tbreak;\n\tcase 'o':\n\t\tinput++;\n\t\tif (input[0]==' ')\n\t\t\tinput++;\n\t\tfile = r_fs_open (core->fs, input);\n\t\tif (file) {\n\t\t\t// XXX: dump to file or just pipe?\n\t\t\tr_fs_read (core->fs, file, 0, file->size);\n\t\t\tr_cons_printf (\"f file %d 0x%08\"PFMT64x\"\\n\", file->size, file->off);\n\t\t\tr_fs_close (core->fs, file);\n\t\t} else eprintf (\"Cannot open file\\n\");\n\t\tbreak;\n\tcase 'g':\n\t\tinput++;\n\t\tif (*input == ' ')\n\t\t\tinput++;\n\t\tptr = strchr (input, ' ');\n\t\tif (ptr)\n\t\t\t*ptr++ = 0;\n\t\telse\n\t\t\tptr = \"./\";\n\t\tfile = r_fs_open (core->fs, input);\n\t\tif (file) {\n\t\t\tr_fs_read (core->fs, file, 0, file->size);\n\t\t\twrite (1, file->data, file->size);\n\t\t\tr_fs_close (core->fs, file);\n\t\t\twrite (1, \"\\n\", 1);\n\t\t} else if (!r_fs_dir_dump (core->fs, input, ptr))\n\t\t\teprintf (\"Cannot open file\\n\");\n\t\tbreak;\n\tcase 'f':\n\t\tinput++;\n\t\tswitch (*input) {\n\t\tcase '?':\n\t\t\tr_cons_printf (\n\t\t\t\"Usage: mf[no] [...]\\n\"\n\t\t\t\" mfn /foo *.c       ; search files by name in /foo path\\n\"\n\t\t\t\" mfo /foo 0x5e91    ; search files by offset in /foo path\\n\"\n\t\t\t);\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tinput++;\n\t\t\tif (*input == ' ')\n\t\t\t\tinput++;\n\t\t\tptr = strchr (input, ' ');\n\t\t\tif (ptr) {\n\t\t\t\t*ptr++ = 0;\n\t\t\t\tlist = r_fs_find_name (core->fs, input, ptr);\n\t\t\t\tr_list_foreach (list, iter, ptr) {\n\t\t\t\t\tr_str_chop_path (ptr);\n\t\t\t\t\tprintf (\"%s\\n\", ptr);\n\t\t\t\t}\n\t\t\t\t//XXX: r_list_purge (list);\n\t\t\t} else eprintf (\"Unknown store path\\n\");\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tinput++;\n\t\t\tif (*input == ' ')\n\t\t\t\tinput++;\n\t\t\tptr = strchr (input, ' ');\n\t\t\tif (ptr) {\n\t\t\t\t*ptr++ = 0;\n\t\t\t\tut64 off = r_num_math (core->num, ptr);\n\t\t\t\tlist = r_fs_find_off (core->fs, input, off);\n\t\t\t\tr_list_foreach (list, iter, ptr) {\n\t\t\t\t\tr_str_chop_path (ptr);\n\t\t\t\t\tprintf (\"%s\\n\", ptr);\n\t\t\t\t}\n\t\t\t\t//XXX: r_list_purge (list);\n\t\t\t} else eprintf (\"Unknown store path\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 's':\n\t\tif (core->http_up) {\n\t\t\tfree (oinput);\n\t\t\treturn false;\n\t\t}\n\t\tinput++;\n\t\tif (input[0]==' ')\n\t\t\tinput++;\n\t\tr_fs_prompt (core->fs, input);\n\t\tbreak;\n\tcase 'y':\n\t\teprintf (\"TODO\\n\");\n\t\tbreak;\n\tcase '?': {\n\t\tconst char* help_msg[] = {\n\t\t\t\"Usage:\", \"m[-?*dgy] [...] \", \"Mountpoints management\",\n\t\t\t\"m\", \"\", \"List all mountpoints in human readable format\",\n\t\t\t\"m*\", \"\", \"Same as above, but in r2 commands\",\n\t\t\t\"ml\", \"\", \"List filesystem plugins\",\n\t\t\t\"m\", \" /mnt\", \"Mount fs at /mnt with autodetect fs and current offset\",\n\t\t\t\"m\", \" /mnt ext2 0\", \"Mount ext2 fs at /mnt with delta 0 on IO\",\n\t\t\t\"m-/\", \"\", \"Umount given path (/)\",\n\t\t\t\"my\", \"\", \"Yank contents of file into clipboard\",\n\t\t\t\"mo\", \" /foo\", \"Get offset and size of given file\",\n\t\t\t\"mg\", \" /foo\", \"Get contents of file/dir dumped to disk (XXX?)\",\n\t\t\t\"mf\", \"[?] [o|n]\", \"Search files for given filename or for offset\",\n\t\t\t\"md\", \" /\", \"List directory contents for path\",\n\t\t\t\"mp\", \"\", \"List all supported partition types\",\n\t\t\t\"mp\", \" msdos 0\", \"Show partitions in msdos format at offset 0\",\n\t\t\t\"ms\", \" /mnt\", \"Open filesystem prompt at /mnt\",\n\t\t\t//\"TODO: support multiple mountpoints and RFile IO's (need io+core refactorn\",\n\t\t\tNULL};\n\t\tr_core_cmd_help (core, help_msg);\n\t\t}\n\t\tbreak;\n\t}\n\tfree (oinput);\n\treturn 0;\n}\n\n\n", "/* ext2.c - Second Extended filesystem */\n/*\n *  GRUB  --  GRand Unified Bootloader\n *  Copyright (C) 2003,2004,2005,2007,2008,2009  Free Software Foundation, Inc.\n *\n *  GRUB is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  GRUB is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/* Magic value used to identify an ext2 filesystem.  */\n#define\tEXT2_MAGIC\t\t0xEF53\n/* Amount of indirect blocks in an inode.  */\n#define INDIRECT_BLOCKS\t\t12\n/* Maximum length of a pathname.  */\n#define EXT2_PATH_MAX\t\t4096\n/* Maximum nesting of symlinks, used to prevent a loop.  */\n#define\tEXT2_MAX_SYMLINKCNT\t8\n\n/* The good old revision and the default inode size.  */\n#define EXT2_GOOD_OLD_REVISION\t\t0\n#define EXT2_GOOD_OLD_INODE_SIZE\t128\n\n/* Filetype used in directory entry.  */\n#define\tFILETYPE_UNKNOWN\t0\n#define\tFILETYPE_REG\t\t1\n#define\tFILETYPE_DIRECTORY\t2\n#define\tFILETYPE_SYMLINK\t7\n\n/* Filetype information as used in inodes.  */\n#define FILETYPE_INO_MASK\t0170000\n#define FILETYPE_INO_REG\t0100000\n#define FILETYPE_INO_DIRECTORY\t0040000\n#define FILETYPE_INO_SYMLINK\t0120000\n\n#include <stdlib.h>\n#include <grub/err.h>\n#include <grub/file.h>\n#include <grub/mm.h>\n#include <grub/misc.h>\n#include <grub/disk.h>\n#include <grub/dl.h>\n#include <grub/types.h>\n#include <grub/fshelp.h>\n\n/* Log2 size of ext2 block in 512 blocks.  */\n#define LOG2_EXT2_BLOCK_SIZE(data)\t\t\t\\\n\t(grub_le_to_cpu32 (data->sblock.log2_block_size) + 1)\n\n/* Log2 size of ext2 block in bytes.  */\n#define LOG2_BLOCK_SIZE(data)\t\t\t\t\t\\\n\t(grub_le_to_cpu32 (data->sblock.log2_block_size) + 10)\n\n/* The size of an ext2 block in bytes.  */\n#define EXT2_BLOCK_SIZE(data)\t\t(1 << LOG2_BLOCK_SIZE (data))\n\n/* The revision level.  */\n#define EXT2_REVISION(data)\tgrub_le_to_cpu32 (data->sblock.revision_level)\n\n/* The inode size.  */\n#define EXT2_INODE_SIZE(data)\t\\\n        (EXT2_REVISION (data) == EXT2_GOOD_OLD_REVISION \\\n         ? EXT2_GOOD_OLD_INODE_SIZE \\\n         : grub_le_to_cpu16 (data->sblock.inode_size))\n\n/* Superblock filesystem feature flags (RW compatible)\n * A filesystem with any of these enabled can be read and written by a driver\n * that does not understand them without causing metadata/data corruption.  */\n#define EXT2_FEATURE_COMPAT_DIR_PREALLOC\t0x0001\n#define EXT2_FEATURE_COMPAT_IMAGIC_INODES\t0x0002\n#define EXT3_FEATURE_COMPAT_HAS_JOURNAL\t\t0x0004\n#define EXT2_FEATURE_COMPAT_EXT_ATTR\t\t0x0008\n#define EXT2_FEATURE_COMPAT_RESIZE_INODE\t0x0010\n#define EXT2_FEATURE_COMPAT_DIR_INDEX\t\t0x0020\n/* Superblock filesystem feature flags (RO compatible)\n * A filesystem with any of these enabled can be safely read by a driver that\n * does not understand them, but should not be written to, usually because\n * additional metadata is required.  */\n#define EXT2_FEATURE_RO_COMPAT_SPARSE_SUPER\t0x0001\n#define EXT2_FEATURE_RO_COMPAT_LARGE_FILE\t0x0002\n#define EXT2_FEATURE_RO_COMPAT_BTREE_DIR\t0x0004\n#define EXT4_FEATURE_RO_COMPAT_GDT_CSUM\t\t0x0010\n#define EXT4_FEATURE_RO_COMPAT_DIR_NLINK\t0x0020\n#define EXT4_FEATURE_RO_COMPAT_EXTRA_ISIZE\t0x0040\n/* Superblock filesystem feature flags (back-incompatible)\n * A filesystem with any of these enabled should not be attempted to be read\n * by a driver that does not understand them, since they usually indicate\n * metadata format changes that might confuse the reader.  */\n#define EXT2_FEATURE_INCOMPAT_COMPRESSION\t0x0001\n#define EXT2_FEATURE_INCOMPAT_FILETYPE\t\t0x0002\n#define EXT3_FEATURE_INCOMPAT_RECOVER\t\t0x0004 /* Needs recovery */\n#define EXT3_FEATURE_INCOMPAT_JOURNAL_DEV\t0x0008 /* Volume is journal device */\n#define EXT2_FEATURE_INCOMPAT_META_BG\t\t0x0010\n#define EXT4_FEATURE_INCOMPAT_EXTENTS\t\t0x0040 /* Extents used */\n#define EXT4_FEATURE_INCOMPAT_64BIT\t\t0x0080\n#define EXT4_FEATURE_INCOMPAT_FLEX_BG\t\t0x0200\n\n/* The set of back-incompatible features this driver DOES support. Add (OR)\n * flags here as the related features are implemented into the driver.  */\n#define EXT2_DRIVER_SUPPORTED_INCOMPAT ( EXT2_FEATURE_INCOMPAT_FILETYPE \\\n                                       | EXT4_FEATURE_INCOMPAT_EXTENTS  \\\n                                       | EXT4_FEATURE_INCOMPAT_FLEX_BG )\n/* List of rationales for the ignored \"incompatible\" features:\n * needs_recovery: Not really back-incompatible - was added as such to forbid\n *                 ext2 drivers from mounting an ext3 volume with a dirty\n *                 journal because they will ignore the journal, but the next\n *                 ext3 driver to mount the volume will find the journal and\n *                 replay it, potentially corrupting the metadata written by\n *                 the ext2 drivers. Safe to ignore for this RO driver.  */\n#define EXT2_DRIVER_IGNORED_INCOMPAT ( EXT3_FEATURE_INCOMPAT_RECOVER )\n\n\n#define EXT3_JOURNAL_MAGIC_NUMBER\t0xc03b3998U\n\n#define EXT3_JOURNAL_DESCRIPTOR_BLOCK\t1\n#define EXT3_JOURNAL_COMMIT_BLOCK\t2\n#define EXT3_JOURNAL_SUPERBLOCK_V1\t3\n#define EXT3_JOURNAL_SUPERBLOCK_V2\t4\n#define EXT3_JOURNAL_REVOKE_BLOCK\t5\n\n#define EXT3_JOURNAL_FLAG_ESCAPE\t1\n#define EXT3_JOURNAL_FLAG_SAME_UUID\t2\n#define EXT3_JOURNAL_FLAG_DELETED\t4\n#define EXT3_JOURNAL_FLAG_LAST_TAG\t8\n\n#define EXT4_EXTENTS_FLAG\t\t0x80000\n\n/* The ext2 superblock.  */\nstruct grub_ext2_sblock\n{\n  grub_uint32_t total_inodes;\n  grub_uint32_t total_blocks;\n  grub_uint32_t reserved_blocks;\n  grub_uint32_t free_blocks;\n  grub_uint32_t free_inodes;\n  grub_uint32_t first_data_block;\n  grub_uint32_t log2_block_size;\n  grub_uint32_t log2_fragment_size;\n  grub_uint32_t blocks_per_group;\n  grub_uint32_t fragments_per_group;\n  grub_uint32_t inodes_per_group;\n  grub_uint32_t mtime;\n  grub_uint32_t utime;\n  grub_uint16_t mnt_count;\n  grub_uint16_t max_mnt_count;\n  grub_uint16_t magic;\n  grub_uint16_t fs_state;\n  grub_uint16_t error_handling;\n  grub_uint16_t minor_revision_level;\n  grub_uint32_t lastcheck;\n  grub_uint32_t checkinterval;\n  grub_uint32_t creator_os;\n  grub_uint32_t revision_level;\n  grub_uint16_t uid_reserved;\n  grub_uint16_t gid_reserved;\n  grub_uint32_t first_inode;\n  grub_uint16_t inode_size;\n  grub_uint16_t block_group_number;\n  grub_uint32_t feature_compatibility;\n  grub_uint32_t feature_incompat;\n  grub_uint32_t feature_ro_compat;\n  grub_uint16_t uuid[8];\n  char volume_name[16];\n  char last_mounted_on[64];\n  grub_uint32_t compression_info;\n  grub_uint8_t prealloc_blocks;\n  grub_uint8_t prealloc_dir_blocks;\n  grub_uint16_t reserved_gdt_blocks;\n  grub_uint8_t journal_uuid[16];\n  grub_uint32_t journal_inum;\n  grub_uint32_t journal_dev;\n  grub_uint32_t last_orphan;\n  grub_uint32_t hash_seed[4];\n  grub_uint8_t def_hash_version;\n  grub_uint8_t jnl_backup_type;\n  grub_uint16_t reserved_word_pad;\n  grub_uint32_t default_mount_opts;\n  grub_uint32_t first_meta_bg;\n  grub_uint32_t mkfs_time;\n  grub_uint32_t jnl_blocks[17];\n};\n\n/* The ext2 blockgroup.  */\nstruct grub_ext2_block_group\n{\n  grub_uint32_t block_id;\n  grub_uint32_t inode_id;\n  grub_uint32_t inode_table_id;\n  grub_uint16_t free_blocks;\n  grub_uint16_t free_inodes;\n  grub_uint16_t used_dirs;\n  grub_uint16_t pad;\n  grub_uint32_t reserved[3];\n};\n\n/* The ext2 inode.  */\nstruct grub_ext2_inode\n{\n  grub_uint16_t mode;\n  grub_uint16_t uid;\n  grub_uint32_t size;\n  grub_uint32_t atime;\n  grub_uint32_t ctime;\n  grub_uint32_t mtime;\n  grub_uint32_t dtime;\n  grub_uint16_t gid;\n  grub_uint16_t nlinks;\n  grub_uint32_t blockcnt;  /* Blocks of 512 bytes!! */\n  grub_uint32_t flags;\n  grub_uint32_t osd1;\n  union\n  {\n    struct datablocks\n    {\n      grub_uint32_t dir_blocks[INDIRECT_BLOCKS];\n      grub_uint32_t indir_block;\n      grub_uint32_t double_indir_block;\n      grub_uint32_t triple_indir_block;\n    } blocks;\n    char symlink[60];\n  };\n  grub_uint32_t version;\n  grub_uint32_t acl;\n  grub_uint32_t dir_acl;\n  grub_uint32_t fragment_addr;\n  grub_uint32_t osd2[3];\n};\n\n/* The header of an ext2 directory entry.  */\nstruct ext2_dirent\n{\n  grub_uint32_t inode;\n  grub_uint16_t direntlen;\n  grub_uint8_t namelen;\n  grub_uint8_t filetype;\n};\n\nstruct grub_ext3_journal_header\n{\n  grub_uint32_t magic;\n  grub_uint32_t block_type;\n  grub_uint32_t sequence;\n};\n\nstruct grub_ext3_journal_revoke_header\n{\n  struct grub_ext3_journal_header header;\n  grub_uint32_t count;\n  grub_uint32_t data[0];\n};\n\nstruct grub_ext3_journal_block_tag\n{\n  grub_uint32_t block;\n  grub_uint32_t flags;\n};\n\nstruct grub_ext3_journal_sblock\n{\n  struct grub_ext3_journal_header header;\n  grub_uint32_t block_size;\n  grub_uint32_t maxlen;\n  grub_uint32_t first;\n  grub_uint32_t sequence;\n  grub_uint32_t start;\n};\n\n#define EXT4_EXT_MAGIC\t\t0xf30a\n\nstruct grub_ext4_extent_header\n{\n  grub_uint16_t magic;\n  grub_uint16_t entries;\n  grub_uint16_t max;\n  grub_uint16_t depth;\n  grub_uint32_t generation;\n};\n\nstruct grub_ext4_extent\n{\n  grub_uint32_t block;\n  grub_uint16_t len;\n  grub_uint16_t start_hi;\n  grub_uint32_t start;\n};\n\nstruct grub_ext4_extent_idx\n{\n  grub_uint32_t block;\n  grub_uint32_t leaf;\n  grub_uint16_t leaf_hi;\n  grub_uint16_t unused;\n};\n\nstruct grub_fshelp_node\n{\n  struct grub_ext2_data *data;\n  struct grub_ext2_inode inode;\n  int ino;\n  int inode_read;\n};\n\n/* Information about a \"mounted\" ext2 filesystem.  */\nstruct grub_ext2_data\n{\n  struct grub_ext2_sblock sblock;\n  grub_disk_t disk;\n  struct grub_ext2_inode *inode;\n  struct grub_fshelp_node diropen;\n};\n\nstatic grub_dl_t my_mod;\n\n\f\n\n/* Read into BLKGRP the blockgroup descriptor of blockgroup GROUP of\n   the mounted filesystem DATA.  */\ninline static grub_err_t\ngrub_ext2_blockgroup (struct grub_ext2_data *data, int group,\n\t\t      struct grub_ext2_block_group *blkgrp)\n{\n  return grub_disk_read (data->disk,\n                         ((grub_le_to_cpu32 (data->sblock.first_data_block) + 1)\n                          << LOG2_EXT2_BLOCK_SIZE (data)),\n\t\t\t group * sizeof (struct grub_ext2_block_group),\n\t\t\t sizeof (struct grub_ext2_block_group), blkgrp);\n}\n\nstatic struct grub_ext4_extent_header *\ngrub_ext4_find_leaf (struct grub_ext2_data *data, char *buf,\n                     struct grub_ext4_extent_header *ext_block,\n                     grub_uint32_t fileblock)\n{\n  struct grub_ext4_extent_idx *index;\n\n  while (1)\n    {\n      int i;\n      grub_disk_addr_t block;\n\n      index = (struct grub_ext4_extent_idx *) (ext_block + 1);\n\n      if (grub_le_to_cpu16(ext_block->magic) != EXT4_EXT_MAGIC)\n        return 0;\n\n      if (ext_block->depth == 0)\n        return ext_block;\n\n      for (i = 0; i < grub_le_to_cpu16 (ext_block->entries); i++)\n        {\n          if (fileblock < grub_le_to_cpu32(index[i].block))\n            break;\n        }\n\n      if (--i < 0)\n        return 0;\n\n      block = grub_le_to_cpu16 (index[i].leaf_hi);\n      block = (block << 32) + grub_le_to_cpu32 (index[i].leaf);\n      if (grub_disk_read (data->disk,\n                          block << LOG2_EXT2_BLOCK_SIZE (data),\n                          0, EXT2_BLOCK_SIZE(data), buf)) {\n        return 0;\n      }\n\n      ext_block = (struct grub_ext4_extent_header *) buf;\n    }\n}\n\nstatic grub_disk_addr_t\ngrub_ext2_read_block (grub_fshelp_node_t node, grub_disk_addr_t fileblock)\n{\n  struct grub_ext2_data *data = node->data;\n  struct grub_ext2_inode *inode = &node->inode;\n  int blknr = -1;\n  unsigned int blksz = EXT2_BLOCK_SIZE (data);\n  int log2_blksz = LOG2_EXT2_BLOCK_SIZE (data);\n\n  if (grub_le_to_cpu32(inode->flags) & EXT4_EXTENTS_FLAG)\n    {\n\t  char * buf = grub_malloc (EXT2_BLOCK_SIZE (data));\n          if (!buf) {\n              return -1;\n          }\n      struct grub_ext4_extent_header *leaf;\n      struct grub_ext4_extent *ext;\n      int i;\n\n      leaf = grub_ext4_find_leaf (data, buf,\n\t\t  (struct grub_ext4_extent_header *) inode->blocks.dir_blocks,\n\t\t  fileblock);\n      if (! leaf)\n        {\n          grub_error (GRUB_ERR_BAD_FS, \"invalid extent\");\n\t  free (buf);\n          return -1;\n        }\n\n      ext = (struct grub_ext4_extent *) (leaf + 1);\n      for (i = 0; i < grub_le_to_cpu16 (leaf->entries); i++)\n        {\n          if (fileblock < grub_le_to_cpu32 (ext[i].block))\n            break;\n        }\n\n      if (--i >= 0)\n        {\n          fileblock -= grub_le_to_cpu32 (ext[i].block);\n          if (fileblock >= grub_le_to_cpu16 (ext[i].len)) {\n  \t    free (buf);\n            return 0;\n          } else\n            {\n              grub_disk_addr_t start;\n\n              start = grub_le_to_cpu16 (ext[i].start_hi);\n              start = (start << 32) + grub_le_to_cpu32 (ext[i].start);\n  \t    free (buf);\n\n              return fileblock + start;\n            }\n        }\n      else\n        {\n          grub_error (GRUB_ERR_BAD_FS, \"something wrong with extent\");\n  \t    free (buf);\n          return -1;\n        }\nfree (buf);\n    }\n  /* Direct blocks.  */\n  if (fileblock < INDIRECT_BLOCKS) {\n    blknr = grub_le_to_cpu32 (inode->blocks.dir_blocks[fileblock]);\n  /* Indirect.  */\n  } else if (fileblock < INDIRECT_BLOCKS + blksz / 4)\n    {\n      grub_uint32_t *indir;\n\n      indir = grub_malloc (blksz);\n      if (! indir) {\n\treturn grub_errno;\n}\n\n      if (grub_disk_read (data->disk,\n\t\t\t  ((grub_disk_addr_t)\n\t\t\t   grub_le_to_cpu32 (inode->blocks.indir_block))\n\t\t\t  << log2_blksz,\n\t\t\t  0, blksz, indir)) {\n\treturn grub_errno;\n}\n\n      blknr = grub_le_to_cpu32 (indir[fileblock - INDIRECT_BLOCKS]);\n      grub_free (indir);\n    }\n  /* Double indirect.  */\n  else if (fileblock < (grub_disk_addr_t)(INDIRECT_BLOCKS + blksz / 4) \\\n\t\t  * (grub_disk_addr_t)(blksz / 4 + 1))\n    {\n      unsigned int perblock = blksz / 4;\n      unsigned int rblock = fileblock - (INDIRECT_BLOCKS\n\t\t\t\t\t + blksz / 4);\n      grub_uint32_t *indir;\n\n      indir = grub_malloc (blksz);\n      if (! indir) {\n\treturn grub_errno;\n}\n\n      if (grub_disk_read (data->disk,\n\t\t\t  ((grub_disk_addr_t)\n\t\t\t   grub_le_to_cpu32 (inode->blocks.double_indir_block))\n\t\t\t  << log2_blksz,\n\t\t\t  0, blksz, indir)) {\n\treturn grub_errno;\n}\n\n      if (grub_disk_read (data->disk,\n\t\t\t  ((grub_disk_addr_t)\n\t\t\t   grub_le_to_cpu32 (indir[rblock / perblock]))\n\t\t\t  << log2_blksz,\n\t\t\t  0, blksz, indir)) {\n\treturn grub_errno;\n}\n\n      blknr = grub_le_to_cpu32 (indir[rblock % perblock]);\n            grub_free (indir);\n    }\n  /* triple indirect.  */\n  else\n    {\n      grub_error (GRUB_ERR_NOT_IMPLEMENTED_YET,\n\t\t  \"ext2fs doesn't support triple indirect blocks\");\n    }\n\n  return blknr;\n}\n\n/* Read LEN bytes from the file described by DATA starting with byte\n   POS.  Return the amount of read bytes in READ.  */\nstatic grub_ssize_t\ngrub_ext2_read_file (grub_fshelp_node_t node,\n     void (*read_hook) (grub_disk_addr_t sector,\n\t\tunsigned offset, unsigned length, void *closure),\n     void *closure, int flags, int pos, grub_size_t len, char *buf)\n{\n\treturn grub_fshelp_read_file (node->data->disk, node, read_hook, closure,\n\t\tflags, pos, len, buf, grub_ext2_read_block,\n\t\tnode->inode.size, LOG2_EXT2_BLOCK_SIZE (node->data));\n}\n\n\n/* Read the inode INO for the file described by DATA into INODE.  */\nstatic grub_err_t\ngrub_ext2_read_inode (struct grub_ext2_data *data,\n\t\t      int ino, struct grub_ext2_inode *inode)\n{\n  struct grub_ext2_block_group blkgrp;\n  struct grub_ext2_sblock *sblock = &data->sblock;\n  int inodes_per_block;\n  unsigned int blkno;\n  unsigned int blkoff;\n\n  /* It is easier to calculate if the first inode is 0.  */\n  ino--;\n  int div = grub_le_to_cpu32 (sblock->inodes_per_group);\n  if (div < 1) {\n    return grub_errno = GRUB_ERR_BAD_FS;\n  }\n  grub_ext2_blockgroup (data, ino / div, &blkgrp);\n  if (grub_errno)\n    return grub_errno;\n\n  int inode_size = EXT2_INODE_SIZE (data);\n  if (inode_size < 1) {\n    return grub_errno = GRUB_ERR_BAD_FS;\n  }\n  inodes_per_block = EXT2_BLOCK_SIZE (data) / inode_size;\n  if (inodes_per_block < 1) {\n    return grub_errno = GRUB_ERR_BAD_FS;\n  }\n  blkno = (ino % grub_le_to_cpu32 (sblock->inodes_per_group))\n    / inodes_per_block;\n  blkoff = (ino % grub_le_to_cpu32 (sblock->inodes_per_group))\n    % inodes_per_block;\n\n  /* Read the inode.  */\n  if (grub_disk_read (data->disk,\n\t\t      ((grub_le_to_cpu32 (blkgrp.inode_table_id) + blkno)\n\t\t        << LOG2_EXT2_BLOCK_SIZE (data)),\n\t\t      EXT2_INODE_SIZE (data) * blkoff,\n\t\t      sizeof (struct grub_ext2_inode), inode))\n    return grub_errno;\n\n  return 0;\n}\n\nstatic struct grub_ext2_data *\ngrub_ext2_mount (grub_disk_t disk)\n{\n  struct grub_ext2_data *data;\n\n  data = grub_malloc (sizeof (struct grub_ext2_data));\n  if (!data)\n    return 0;\n\n  /* Read the superblock.  */\n  grub_disk_read (disk, 1 * 2, 0, sizeof (struct grub_ext2_sblock),\n                  &data->sblock);\n  if (grub_errno)\n    goto fail;\n\n  /* Make sure this is an ext2 filesystem.  */\n  if (grub_le_to_cpu16 (data->sblock.magic) != EXT2_MAGIC)\n    {\n      grub_error (GRUB_ERR_BAD_FS, \"not an ext2 filesystem\");\n      goto fail;\n    }\n\n  /* Check the FS doesn't have feature bits enabled that we don't support. */\n  if (grub_le_to_cpu32 (data->sblock.feature_incompat)\n        & ~(EXT2_DRIVER_SUPPORTED_INCOMPAT | EXT2_DRIVER_IGNORED_INCOMPAT))\n    {\n      grub_error (GRUB_ERR_BAD_FS, \"filesystem has unsupported incompatible features\");\n      goto fail;\n    }\n\n\n  data->disk = disk;\n\n  data->diropen.data = data;\n  data->diropen.ino = 2;\n  data->diropen.inode_read = 1;\n\n  data->inode = &data->diropen.inode;\n\n  grub_ext2_read_inode (data, 2, data->inode);\n  if (grub_errno)\n    goto fail;\n\n  return data;\n\n fail:\n  if (grub_errno == GRUB_ERR_OUT_OF_RANGE)\n    grub_error (GRUB_ERR_BAD_FS, \"not an ext2 filesystem\");\n\n  grub_free (data);\n  return 0;\n}\n\nstatic char *\ngrub_ext2_read_symlink (grub_fshelp_node_t node)\n{\n  char *symlink;\n  struct grub_fshelp_node *diro = node;\n\n  if (! diro->inode_read)\n    {\n      grub_ext2_read_inode (diro->data, diro->ino, &diro->inode);\n      if (grub_errno)\n\treturn 0;\n    }\n\n  symlink = grub_malloc (grub_le_to_cpu32 (diro->inode.size) + 1);\n  if (! symlink)\n    return 0;\n\n  /* If the filesize of the symlink is bigger than\n     60 the symlink is stored in a separate block,\n     otherwise it is stored in the inode.  */\n  if (grub_le_to_cpu32 (diro->inode.size) <= 60)\n    grub_strncpy (symlink,\n\t\t  diro->inode.symlink,\n\t\t  grub_le_to_cpu32 (diro->inode.size));\n  else\n    {\n      grub_ext2_read_file (diro, 0, 0, 0, 0,\n\t\t\t   grub_le_to_cpu32 (diro->inode.size),\n\t\t\t   symlink);\n      if (grub_errno)\n\t{\n\t  grub_free (symlink);\n\t  return 0;\n\t}\n    }\n\n  symlink[grub_le_to_cpu32 (diro->inode.size)] = '\\0';\n  return symlink;\n}\n\nstatic int\ngrub_ext2_iterate_dir (grub_fshelp_node_t dir,\n\t\t       int (*hook) (const char *filename,\n\t\t\t\t    enum grub_fshelp_filetype filetype,\n\t\t\t\t    grub_fshelp_node_t node,\n\t\t\t\t    void *closure),\n\t\t       void *closure)\n{\n  unsigned int fpos = 0;\n  struct grub_fshelp_node *diro = (struct grub_fshelp_node *) dir;\n\n  if (! diro->inode_read)\n    {\n      grub_ext2_read_inode (diro->data, diro->ino, &diro->inode);\n      if (grub_errno)\n\treturn 0;\n    }\n\n  /* Search the file.  */\n  if (hook)\n  while (fpos < grub_le_to_cpu32 (diro->inode.size))\n    {\n      struct ext2_dirent dirent;\n\n      grub_ext2_read_file (diro, NULL, NULL, 0, fpos, sizeof (dirent),\n\t\t\t   (char *) &dirent);\n      if (grub_errno)\n\treturn 0;\n\n      if (dirent.direntlen == 0)\n        return 0;\n\n      if (dirent.namelen != 0)\n\t{\n\t  char * filename = grub_malloc (dirent.namelen + 1);\n\t  struct grub_fshelp_node *fdiro;\n\t  enum grub_fshelp_filetype type = GRUB_FSHELP_UNKNOWN;\n\nif (!filename) {\nbreak;\n}\n\t  grub_ext2_read_file (diro, 0, 0, 0,\n\t\t\t       fpos + sizeof (struct ext2_dirent),\n\t\t\t       dirent.namelen, filename);\n\t  if (grub_errno) {\n            grub_free (filename);\n\t    return 0;\n\t  }\n\n\t  fdiro = grub_malloc (sizeof (struct grub_fshelp_node));\n\t  if (! fdiro) {\n            grub_free (filename);\n\t    return 0;\n          }\n\n\t  fdiro->data = diro->data;\n\t  fdiro->ino = grub_le_to_cpu32 (dirent.inode);\n\n\t  filename[dirent.namelen] = '\\0';\n\n\t  if (dirent.filetype != FILETYPE_UNKNOWN)\n\t    {\n\t      fdiro->inode_read = 0;\n\n\t      if (dirent.filetype == FILETYPE_DIRECTORY)\n\t\ttype = GRUB_FSHELP_DIR;\n\t      else if (dirent.filetype == FILETYPE_SYMLINK)\n\t\ttype = GRUB_FSHELP_SYMLINK;\n\t      else if (dirent.filetype == FILETYPE_REG)\n\t\ttype = GRUB_FSHELP_REG;\n\t    }\n\t  else\n\t    {\n\t      /* The filetype can not be read from the dirent, read\n\t\t the inode to get more information.  */\n\t      grub_ext2_read_inode (diro->data,\n                                    grub_le_to_cpu32 (dirent.inode),\n\t\t\t\t    &fdiro->inode);\n\t      if (grub_errno) {\n                  grub_free (filename);\n\t\t  grub_free (fdiro);\n\t\t  return 0;\n\t\t}\n\n\t      fdiro->inode_read = 1;\n\n\t      if ((grub_le_to_cpu16 (fdiro->inode.mode)\n\t\t   & FILETYPE_INO_MASK) == FILETYPE_INO_DIRECTORY)\n\t\ttype = GRUB_FSHELP_DIR;\n\t      else if ((grub_le_to_cpu16 (fdiro->inode.mode)\n\t\t\t& FILETYPE_INO_MASK) == FILETYPE_INO_SYMLINK)\n\t\ttype = GRUB_FSHELP_SYMLINK;\n\t      else if ((grub_le_to_cpu16 (fdiro->inode.mode)\n\t\t\t& FILETYPE_INO_MASK) == FILETYPE_INO_REG)\n\t\ttype = GRUB_FSHELP_REG;\n\t    }\n\n\t  if (hook (filename, type, fdiro, closure)) {\n            grub_free (filename);\n\t    return 1;\n          }\n          grub_free (filename);\n\t}\n\n      fpos += grub_le_to_cpu16 (dirent.direntlen);\n    }\n\n  return 0;\n}\n\n/* Open a file named NAME and initialize FILE.  */\nstatic grub_err_t\ngrub_ext2_open (struct grub_file *file, const char *name)\n{\n  struct grub_ext2_data *data;\n  struct grub_fshelp_node *fdiro = 0;\n\n  grub_dl_ref (my_mod);\n\n  data = grub_ext2_mount (file->device->disk);\n  if (! data)\n    goto fail;\n\n  grub_fshelp_find_file (name, &data->diropen, &fdiro, grub_ext2_iterate_dir, 0,\n\t\t\t grub_ext2_read_symlink, GRUB_FSHELP_REG);\n  if (grub_errno)\n    goto fail;\n\n  if (! fdiro->inode_read)\n    {\n      grub_ext2_read_inode (data, fdiro->ino, &fdiro->inode);\n      if (grub_errno)\n\tgoto fail;\n    }\n\n  grub_memcpy (data->inode, &fdiro->inode, sizeof (struct grub_ext2_inode));\n  grub_free (fdiro);\n\n  file->size = grub_le_to_cpu32 (data->inode->size);\n  file->data = data;\n  file->offset = 0;\n\n  return 0;\n\n fail:\n  if (fdiro != &data->diropen)\n    grub_free (fdiro);\n  grub_free (data);\n\n  grub_dl_unref (my_mod);\n\n  return grub_errno;\n}\n\nstatic grub_err_t\ngrub_ext2_close (grub_file_t file)\n{\n  grub_free (file->data);\n\n  grub_dl_unref (my_mod);\n\n  return GRUB_ERR_NONE;\n}\n\n/* Read LEN bytes data from FILE into BUF.  */\nstatic grub_ssize_t\ngrub_ext2_read (grub_file_t file, char *buf, grub_size_t len)\n{\n  struct grub_ext2_data *data = (struct grub_ext2_data *) file->data;\n  return grub_ext2_read_file (&data->diropen, file->read_hook, file->closure,\n\t\t\t      file->flags, file->offset, len, buf);\n}\n\nstruct grub_ext2_dir_closure\n{\n  int (*hook) (const char *filename,\n\t       const struct grub_dirhook_info *info,\n\t       void *closure);\n  void *closure;\n  struct grub_ext2_data *data;\n};\n\nstatic int\niterate (const char *filename,\n\t enum grub_fshelp_filetype filetype,\n\t grub_fshelp_node_t node,\n\t void *closure)\n{\n  struct grub_ext2_dir_closure *c = closure;\n  struct grub_dirhook_info info;\n  grub_memset (&info, 0, sizeof (info));\n  if (! node->inode_read)\n    {\n      grub_ext2_read_inode (c->data, node->ino, &node->inode);\n      if (!grub_errno)\n\tnode->inode_read = 1;\n      grub_errno = GRUB_ERR_NONE;\n    }\n  if (node->inode_read)\n    {\n      info.mtimeset = 1;\n      info.mtime = grub_le_to_cpu32 (node->inode.mtime);\n    }\n\n  info.dir = ((filetype & GRUB_FSHELP_TYPE_MASK) == GRUB_FSHELP_DIR);\n  grub_free (node);\n  return (c->hook != NULL)? c->hook (filename, &info, c->closure): 0;\n}\n\nstatic grub_err_t\ngrub_ext2_dir (grub_device_t device, const char *path,\n\t       int (*hook) (const char *filename,\n\t\t\t    const struct grub_dirhook_info *info,\n\t\t\t    void *closure),\n\t       void *closure)\n{\n  struct grub_ext2_data *data = 0;\n  struct grub_fshelp_node *fdiro = 0;\n  struct grub_ext2_dir_closure c;\n\n  grub_dl_ref (my_mod);\n\n  data = grub_ext2_mount (device->disk);\n  if (! data)\n    goto fail;\n\n  grub_fshelp_find_file (path, &data->diropen, &fdiro, grub_ext2_iterate_dir,\n\t\t\t 0, grub_ext2_read_symlink, GRUB_FSHELP_DIR);\n  if (grub_errno)\n    goto fail;\n\n  c.hook = hook;\n  c.closure = closure;\n  c.data = data;\n  grub_ext2_iterate_dir (fdiro, iterate, &c);\n\n fail:\n  if (fdiro != &data->diropen)\n    grub_free (fdiro);\n  grub_free (data);\n\n  grub_dl_unref (my_mod);\n\n  return grub_errno;\n}\n\nstatic grub_err_t\ngrub_ext2_label (grub_device_t device, char **label)\n{\n  struct grub_ext2_data *data;\n  grub_disk_t disk = device->disk;\n\n  grub_dl_ref (my_mod);\n\n  data = grub_ext2_mount (disk);\n  if (data)\n    *label = grub_strndup (data->sblock.volume_name, 14);\n  else\n    *label = NULL;\n\n  grub_dl_unref (my_mod);\n\n  grub_free (data);\n\n  return grub_errno;\n}\n\nstatic grub_err_t\ngrub_ext2_uuid (grub_device_t device, char **uuid)\n{\n  struct grub_ext2_data *data;\n  grub_disk_t disk = device->disk;\n\n  grub_dl_ref (my_mod);\n\n  data = grub_ext2_mount (disk);\n  if (data)\n    {\n      *uuid = grub_xasprintf (\"%04x%04x-%04x-%04x-%04x-%04x%04x%04x\",\n\t\t\t     grub_be_to_cpu16 (data->sblock.uuid[0]),\n\t\t\t     grub_be_to_cpu16 (data->sblock.uuid[1]),\n\t\t\t     grub_be_to_cpu16 (data->sblock.uuid[2]),\n\t\t\t     grub_be_to_cpu16 (data->sblock.uuid[3]),\n\t\t\t     grub_be_to_cpu16 (data->sblock.uuid[4]),\n\t\t\t     grub_be_to_cpu16 (data->sblock.uuid[5]),\n\t\t\t     grub_be_to_cpu16 (data->sblock.uuid[6]),\n\t\t\t     grub_be_to_cpu16 (data->sblock.uuid[7]));\n    }\n  else\n    *uuid = NULL;\n\n  grub_dl_unref (my_mod);\n\n  grub_free (data);\n\n  return grub_errno;\n}\n\n/* Get mtime.  */\nstatic grub_err_t\ngrub_ext2_mtime (grub_device_t device, grub_int32_t *tm)\n{\n  struct grub_ext2_data *data;\n  grub_disk_t disk = device->disk;\n\n  grub_dl_ref (my_mod);\n\n  data = grub_ext2_mount (disk);\n  if (!data)\n    *tm = 0;\n  else\n    *tm = grub_le_to_cpu32 (data->sblock.utime);\n\n  grub_dl_unref (my_mod);\n\n  grub_free (data);\n\n  return grub_errno;\n\n}\n\n\n\f\nstruct grub_fs grub_ext2_fs =\n  {\n    .name = \"ext2\",\n    .dir = grub_ext2_dir,\n    .open = grub_ext2_open,\n    .read = grub_ext2_read,\n    .close = grub_ext2_close,\n    .label = grub_ext2_label,\n    .uuid = grub_ext2_uuid,\n    .mtime = grub_ext2_mtime,\n#ifdef GRUB_UTIL\n    .reserved_first_sector = 1,\n#endif\n    .next = 0\n  };\n", "/* fshelp.c -- Filesystem helper functions */\n/*\n *  GRUB  --  GRand Unified Bootloader\n *  Copyright (C) 2004,2005,2006,2007,2008  Free Software Foundation, Inc.\n *\n *  GRUB is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  GRUB is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <grub/err.h>\n#include <grub/mm.h>\n#include <grub/misc.h>\n#include <grub/disk.h>\n#include <grub/fshelp.h>\n\nGRUB_EXPORT(grub_fshelp_view);\nGRUB_EXPORT(grub_fshelp_find_file);\nGRUB_EXPORT(grub_fshelp_log2blksize);\nGRUB_EXPORT(grub_fshelp_read_file);\n\nint grub_fshelp_view = 0;\n\nstruct grub_fshelp_find_file_closure\n{\n  grub_fshelp_node_t rootnode;\n  int (*iterate_dir) (grub_fshelp_node_t dir,\n\t\t      int (*hook)\n\t\t      (const char *filename,\n\t\t       enum grub_fshelp_filetype filetype,\n\t\t       grub_fshelp_node_t node, void *closure),\n\t\t      void *closure);\n  void *closure;\n  char *(*read_symlink) (grub_fshelp_node_t node);\n  int symlinknest;\n  enum grub_fshelp_filetype foundtype;\n  grub_fshelp_node_t currroot;\n};\n\nstatic void\nfree_node (grub_fshelp_node_t node, struct grub_fshelp_find_file_closure *c)\n{\n  if (node != c->rootnode && node != c->currroot)\n    grub_free (node);\n}\n\nstruct find_file_closure\n{\n  char *name;\n  enum grub_fshelp_filetype *type;\n  grub_fshelp_node_t *oldnode;\n  grub_fshelp_node_t *currnode;\n};\n\nstatic int\niterate (const char *filename,\n\t enum grub_fshelp_filetype filetype,\n\t grub_fshelp_node_t node,\n\t void *closure)\n{\n  struct find_file_closure *c = closure;\n\n  if (filetype == GRUB_FSHELP_UNKNOWN ||\n      (grub_strcmp (c->name, filename) &&\n       (! (filetype & GRUB_FSHELP_CASE_INSENSITIVE) ||\n\tgrub_strncasecmp (c->name, filename, GRUB_LONG_MAX))))\n    {\n      grub_free (node);\n      return 0;\n    }\n\n  /* The node is found, stop iterating over the nodes.  */\n  *(c->type) = filetype & ~GRUB_FSHELP_CASE_INSENSITIVE;\n  *(c->oldnode) = *(c->currnode);\n  *(c->currnode) = node;\n\n  return 1;\n}\n\nstatic grub_err_t\nfind_file (const char *currpath, grub_fshelp_node_t currroot,\n\t   grub_fshelp_node_t *currfound,\n\t   struct grub_fshelp_find_file_closure *c)\n{\n\tchar *fpath = grub_malloc (grub_strlen (currpath) + 1);\n  char *name = fpath;\n  char *next;\n  enum grub_fshelp_filetype type = GRUB_FSHELP_DIR;\n  grub_fshelp_node_t currnode = currroot;\n  grub_fshelp_node_t oldnode = currroot;\n\n  c->currroot = currroot;\n\n  grub_strncpy (fpath, currpath, grub_strlen (currpath) + 1);\n\n  /* Remove all leading slashes.  */\n  while (*name == '/')\n    name++;\n\n  if (! *name)\n    {\n      *currfound = currnode;\nfree (fpath);\n      return 0;\n    }\n\n  for (;;)\n    {\n      int found;\n      struct find_file_closure cc;\n\n      /* Extract the actual part from the pathname.  */\n      next = grub_strchr (name, '/');\n      if (next)\n\t{\n\t  /* Remove all leading slashes.  */\n\t  while (*next == '/')\n\t    *(next++) = '\\0';\n\t}\n\n      /* At this point it is expected that the current node is a\n\t directory, check if this is true.  */\n      if (type != GRUB_FSHELP_DIR)\n\t{\n\t  free_node (currnode, c);\nfree (fpath);\n\t  return grub_error (GRUB_ERR_BAD_FILE_TYPE, \"not a directory\");\n\t}\n\n      cc.name = name;\n      cc.type = &type;\n      cc.oldnode = &oldnode;\n      cc.currnode = &currnode;\n      /* Iterate over the directory.  */\n      found = c->iterate_dir (currnode, iterate, &cc);\n      if (! found)\n\t{\n\t  if (grub_errno) {\nfree (fpath);\n\t    return grub_errno;\n}\n\n\t  break;\n\t}\n\n      /* Read in the symlink and follow it.  */\n      if (type == GRUB_FSHELP_SYMLINK)\n\t{\n\t  char *symlink;\n\n\t  /* Test if the symlink does not loop.  */\n\t  if (++(c->symlinknest) == 8)\n\t    {\n\t      free_node (currnode, c);\n\t      free_node (oldnode, c);\nfree (fpath);\n\t      return grub_error (GRUB_ERR_SYMLINK_LOOP,\n\t\t\t\t \"too deep nesting of symlinks\");\n\t    }\n\n\t  symlink = c->read_symlink (currnode);\n\t  free_node (currnode, c);\n\n\t  if (!symlink)\n\t    {\n\t      free_node (oldnode, c);\nfree (fpath);\n\t      return grub_errno;\n\t    }\n\n\t  /* The symlink is an absolute path, go back to the root inode.  */\n\t  if (symlink[0] == '/')\n\t    {\n\t      free_node (oldnode, c);\n\t      oldnode = c->rootnode;\n\t    }\n\n\t  /* Lookup the node the symlink points to.  */\n\t  find_file (symlink, oldnode, &currnode, c);\n\t  type = c->foundtype;\n\t  grub_free (symlink);\n\n\t  if (grub_errno)\n\t    {\n\t      free_node (oldnode, c);\nfree (fpath);\n\t      return grub_errno;\n\t    }\n\t}\n\n      free_node (oldnode, c);\n\n      /* Found the node!  */\n      if (! next || *next == '\\0')\n\t{\n\t  *currfound = currnode;\n\t  c->foundtype = type;\nfree (fpath);\n\t  return 0;\n\t}\n\n      name = next;\n    }\n\nfree (fpath);\n  return grub_error (GRUB_ERR_FILE_NOT_FOUND, \"file not found\");\n}\n\n/* Lookup the node PATH.  The node ROOTNODE describes the root of the\n   directory tree.  The node found is returned in FOUNDNODE, which is\n   either a ROOTNODE or a new malloc'ed node.  ITERATE_DIR is used to\n   iterate over all directory entries in the current node.\n   READ_SYMLINK is used to read the symlink if a node is a symlink.\n   EXPECTTYPE is the type node that is expected by the called, an\n   error is generated if the node is not of the expected type.  Make\n   sure you use the NESTED_FUNC_ATTR macro for HOOK, this is required\n   because GCC has a nasty bug when using regparm=3.  */\ngrub_err_t\ngrub_fshelp_find_file (const char *path, grub_fshelp_node_t rootnode,\n\t\t       grub_fshelp_node_t *foundnode,\n\t\t       int (*iterate_dir) (grub_fshelp_node_t dir,\n\t\t\t\t\t   int (*hook)\n\t\t\t\t\t   (const char *filename,\n\t\t\t\t\t    enum grub_fshelp_filetype filetype,\n\t\t\t\t\t    grub_fshelp_node_t node,\n\t\t\t\t\t    void *closure),\n\t\t\t\t\t   void *closure),\n\t\t       void *closure,\n\t\t       char *(*read_symlink) (grub_fshelp_node_t node),\n\t\t       enum grub_fshelp_filetype expecttype)\n{\n  grub_err_t err;\n  struct grub_fshelp_find_file_closure c;\n\n  c.rootnode = rootnode;\n  c.iterate_dir = iterate_dir;\n  c.closure = closure;\n  c.read_symlink = read_symlink;\n  c.symlinknest = 0;\n  c.foundtype = GRUB_FSHELP_DIR;\n\n  if (!path || path[0] != '/')\n    {\n      grub_error (GRUB_ERR_BAD_FILENAME, \"bad filename\");\n      return grub_errno;\n    }\n\n  err = find_file (path, rootnode, foundnode, &c);\n  if (err)\n    return err;\n\n  /* Check if the node that was found was of the expected type.  */\n  if (expecttype == GRUB_FSHELP_REG && c.foundtype != expecttype)\n    return grub_error (GRUB_ERR_BAD_FILE_TYPE, \"not a regular file\");\n  else if (expecttype == GRUB_FSHELP_DIR && c.foundtype != expecttype)\n    return grub_error (GRUB_ERR_BAD_FILE_TYPE, \"not a directory\");\n\n  return 0;\n}\nunsigned long long grub_hack_lastoff = 0;\n\n/* Read LEN bytes from the file NODE on disk DISK into the buffer BUF,\n   beginning with the block POS.  READ_HOOK should be set before\n   reading a block from the file.  GET_BLOCK is used to translate file\n   blocks to disk blocks.  The file is FILESIZE bytes big and the\n   blocks have a size of LOG2BLOCKSIZE (in log2).  */\ngrub_ssize_t\ngrub_fshelp_read_file (grub_disk_t disk, grub_fshelp_node_t node,\n\t\t       void (*read_hook) (grub_disk_addr_t sector,\n\t\t\t\t\t  unsigned offset,\n\t\t\t\t\t  unsigned length,\n\t\t\t\t\t  void *closure),\n\t\t       void *closure, int flags,\n\t\t       grub_off_t pos, grub_size_t len, char *buf,\n\t\t       grub_disk_addr_t (*get_block) (grub_fshelp_node_t node,\n\t\t\t\t\t\t      grub_disk_addr_t block),\n\t\t       grub_off_t filesize, int log2blocksize)\n{\n  grub_disk_addr_t i, blockcnt;\n  int blocksize = 1 << (log2blocksize + GRUB_DISK_SECTOR_BITS);\n\n  /* Adjust LEN so it we can't read past the end of the file.  */\n  if (pos + len > filesize)\n    len = filesize - pos;\n\n  if (len < 1 || len == 0xffffffff) {\n    return -1;\n  }\n\n  blockcnt = ((len + pos) + blocksize - 1) >>\n    (log2blocksize + GRUB_DISK_SECTOR_BITS);\n\n  for (i = pos >> (log2blocksize + GRUB_DISK_SECTOR_BITS); i < blockcnt; i++)\n    {\n      grub_disk_addr_t blknr;\n      int blockoff = pos & (blocksize - 1);\n      int blockend = blocksize;\n\n      int skipfirst = 0;\n\n      blknr = get_block (node, i);\n      if (grub_errno)\n\treturn -1;\n\n      blknr = blknr << log2blocksize;\n\n      /* Last block.  */\n      if (i == blockcnt - 1)\n\t{\n\t  blockend = (len + pos) & (blocksize - 1);\n\n\t  /* The last portion is exactly blocksize.  */\n\t  if (! blockend)\n\t    blockend = blocksize;\n\t}\n\n      /* First block.  */\n      if (i == (pos >> (log2blocksize + GRUB_DISK_SECTOR_BITS)))\n\t{\n\t  skipfirst = blockoff;\n\t  blockend -= skipfirst;\n\t}\n\n      /* If the block number is 0 this block is not stored on disk but\n\t is zero filled instead.  */\n      if (blknr)\n\t{\n\t  disk->read_hook = read_hook;\n\t  disk->closure = closure;\n\n//printf (\"blknr: %d\\n\", blknr);\ngrub_hack_lastoff = blknr * 512;\n\t  grub_disk_read_ex (disk, blknr, skipfirst, blockend, buf, flags);\n\t  disk->read_hook = 0;\n\t  if (grub_errno)\n\t    return -1;\n\t}\n      else if (buf)\n\tgrub_memset (buf, 0, blockend);\n\n      if (buf)\n\tbuf += blocksize - skipfirst;\n    }\n\n  return len;\n}\n\nunsigned int\ngrub_fshelp_log2blksize (unsigned int blksize, unsigned int *pow)\n{\n  int mod;\n\n  *pow = 0;\n  while (blksize > 1)\n    {\n      mod = blksize - ((blksize >> 1) << 1);\n      blksize >>= 1;\n\n      /* Check if it really is a power of two.  */\n      if (mod)\n\treturn grub_error (GRUB_ERR_BAD_NUMBER,\n\t\t\t   \"the blocksize is not a power of two\");\n      (*pow)++;\n    }\n\n  return GRUB_ERR_NONE;\n}\n", "/* radare - LGPL - Copyright 2011-2017 pancake<nopcode.org> */\n\n#include <r_io.h>\n#include <r_fs.h>\n#include \"grubfs.h\"\n#include <stdio.h>\n#include <string.h>\n\n\nstatic RIOBind *bio = NULL;\nstatic ut64 delta = 0;\n\nstatic void* empty (int sz) {\n\tvoid *p = malloc (sz);\n\tif (p) memset (p, '\\0', sz);\n\treturn p;\n}\n\nstatic grub_err_t read_foo (struct grub_disk *disk, grub_disk_addr_t sector, grub_size_t size, char *buf) {\n\tif (!disk) {\n\t\teprintf (\"oops. no disk\\n\");\n\t\treturn 1;\n\t}\n\tconst int blocksize = 512; // TODO unhardcode 512\n\tRIOBind *iob = disk->data;\n\tif (bio) {\n\t\tiob = bio;\n\t}\n\t//printf (\"io %p\\n\", file->root->iob.io);\n\tif (iob->read_at (iob->io, delta+(blocksize*sector), (ut8*)buf, size*blocksize) == -1) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nGrubFS *grubfs_new (struct grub_fs *myfs, void *data) {\n\tstruct grub_file *file;\n\tGrubFS *gfs = empty (sizeof (GrubFS));\n\t// hacky mallocs :D\n\tgfs->file = file = empty (sizeof (struct grub_file));\n\tfile->device = empty (sizeof (struct grub_device)+1024);\n\tfile->device->disk = empty (sizeof (struct grub_disk));\n\tfile->device->disk->dev = (grub_disk_dev_t)file->device; // hack!\n\tfile->device->disk->dev->read = read_foo; // grub_disk_dev\n\tfile->device->disk->data = data;\n\t//file->device->disk->read_hook = read_foo; //read_hook;\n\tfile->fs = myfs;\n\treturn gfs;\n}\n\ngrub_disk_t grubfs_disk (void *data) {\n\tstruct grub_disk *disk = empty (sizeof (struct grub_disk));\n\tdisk->dev = empty (sizeof (struct grub_disk_dev));\n\tdisk->dev->read = read_foo; // grub_disk_dev\n\tdisk->data = data;\n\treturn disk;\n}\n\nvoid grubfs_free (GrubFS *gf) {\n\tif (gf) {\n\t\tif (gf->file && gf->file->device) {\n\t\t\tfree (gf->file->device->disk);\n\t\t}\n\t\t//free (gf->file->device);\n\t\tfree (gf->file);\n\t\tfree (gf);\n\t}\n}\n\nvoid grubfs_bind_io (RIOBind *iob, ut64 _delta) {\n\tbio = iob;\n\tdelta = _delta;\n}\n", "#!/bin/sh\n\nwhile : ; do\n\tif [ -f sys/rebuild.sh ]; then\n\t\tbreak\n\tfi\n\tcd ..\n\tif [ \"`pwd`\" = / ]; then\n\t\techo \"Cant find sys/rebuild.sh\"\n\t\texit 1\n\tfi\ndone\n\nRebuild() {\n\tcd \"$1\" || exit 1\n\tmake clean\n\tmake -j8 || exit 1\n\tcd -\n}\n\nBuild() {\n\tcd \"$1\" || exit 1\n\tmake -j8 || exit 1\n\tcd -\n}\n\nRebuildIOSDebug() {\n\tRebuild libr/debug\n\t# Rebuild libr/util\n\t# Rebuild libr/core\n\tRebuild binr/radare2\n\tmake -C binr/radare2 ios-sign\n\tif [ -n \"${IOSIP}\" ]; then\n\t\tscp binr/radare2/radare2 root@\"${IOSIP}:.\"\n\telse\n\t\techo \"Set IOSIP environment variable to scp the radare2 program\"\n\tfi\n}\n\nRebuildJava() {\n\tRebuild shlr/java\n\tRebuild libr/asm\n\tRebuild libr/bin\n\tRebuild libr/core\n}\n\nRebuildCapstone() {\n\tRebuild shlr/capstone\n\tRebuild libr/asm\n\tRebuild libr/anal\n}\n\nRebuildSdb() {\n\tRebuild shlr/sdb\n\tRebuild libr/util\n}\n\nRebuildFs() {\n\tRebuild shlr/grub\n\tRebuild libr/fs\n}\n\nRebuildBin() {\n\tRebuild libr/bin\n\tRebuild libr/core\n}\n\nRebuildGdb() {\n\tRebuild shlr/gdb\n\tRebuild libr/io\n\tRebuild libr/debug\n}\n\ncase \"$1\" in\ngrub|fs)RebuildFs; ;;\nbin)    RebuildBin ; ;;\ngdb)    RebuildGdb ; ;;\nsdb)    RebuildSdb ; ;;\nspp)    RebuildSpp ; ;;\nbin)    RebuildBin ; ;;\njava)   RebuildJava ; ;;\niosdbg) RebuildIOSDebug ; ;;\ncapstone|cs) RebuildCapstone ; ;;\n*)\n\techo \"Usage: sys/rebuild.sh [gdb|java|capstone|sdb|iosdbg|cs|sdb|bin]\"\n\t;;\nesac\n"], "filenames": ["libr/core/cmd_mount.c", "shlr/grub/fs/ext2.c", "shlr/grub/fs/fshelp.c", "shlr/grub/grubfs.c", "sys/rebuild.sh"], "buggy_code_start_loc": [38, 44, 94, 1, 75], "buggy_code_end_loc": [55, 482, 209, 62, 76], "fixing_code_start_loc": [38, 45, 93, 1, 75], "fixing_code_end_loc": [59, 494, 215, 64, 76], "type": "CWE-119", "message": "The grub_ext2_read_block function in fs/ext2.c in GNU GRUB before 2013-11-12, as used in shlr/grub/fs/ext2.c in radare2 1.5.0, allows remote attackers to cause a denial of service (excessive stack use and application crash) via a crafted binary file, related to use of a variable-size stack array.", "other": {"cve": {"id": "CVE-2017-9763", "sourceIdentifier": "cve@mitre.org", "published": "2017-06-19T16:29:00.797", "lastModified": "2017-07-05T17:54:49.083", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The grub_ext2_read_block function in fs/ext2.c in GNU GRUB before 2013-11-12, as used in shlr/grub/fs/ext2.c in radare2 1.5.0, allows remote attackers to cause a denial of service (excessive stack use and application crash) via a crafted binary file, related to use of a variable-size stack array."}, {"lang": "es", "value": "La funci\u00f3n grub_ext2_read_block en fs/ext2.c en GNU GRUB antes del 2013-11-12, tal y como se usa en shlr/grub/fs/ext2.c en radare2 1.5.0, permite que atacantes remotos provoquen una denegaci\u00f3n de servicio (uso excesivo de la pila y cierre inesperado de la aplicaci\u00f3n) mediante un archivo binario manipulado. Esto est\u00e1 relacionado con el uso de un array de pila variable-size."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:1.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "1F6336FC-AB50-4F45-B01E-2BC3BA758117"}]}]}], "references": [{"url": "http://git.savannah.gnu.org/cgit/grub.git/commit/grub-core/fs/ext2.c?id=ac8cac1dac50daaf1c390d701cca3b55e16ee768", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/99141", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/radare/radare2/commit/65000a7fd9eea62359e6d6714f17b94a99a82edd", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/radare/radare2/issues/7723", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/radare/radare2/commit/65000a7fd9eea62359e6d6714f17b94a99a82edd"}}