{"buggy_code": ["<SECTION>\n<FILE>cache</FILE>\nlibmnt_cache\nmnt_new_cache\nmnt_free_cache\nmnt_ref_cache\nmnt_unref_cache\nmnt_cache_device_has_tag\nmnt_cache_find_tag_value\nmnt_cache_read_tags\nmnt_cache_set_targets\nmnt_get_fstype\nmnt_pretty_path\nmnt_resolve_path\nmnt_resolve_spec\nmnt_resolve_tag\nmnt_resolve_target\n</SECTION>\n\n<SECTION>\n<FILE>context</FILE>\nlibmnt_context\nlibmnt_ns\nmnt_free_context\nmnt_new_context\nmnt_reset_context\nmnt_context_append_options\nmnt_context_apply_fstab\nmnt_context_disable_canonicalize\nmnt_context_disable_helpers\nmnt_context_disable_mtab\nmnt_context_disable_swapmatch\nmnt_context_enable_fake\nmnt_context_enable_force\nmnt_context_enable_fork\nmnt_context_enable_lazy\nmnt_context_enable_loopdel\nmnt_context_enable_rdonly_umount\nmnt_context_enable_rwonly_mount\nmnt_context_enable_sloppy\nmnt_context_enable_verbose\nmnt_context_forced_rdonly\nmnt_context_force_unrestricted\nmnt_context_get_cache\nmnt_context_get_excode\nmnt_context_get_fs\nmnt_context_get_fstab\nmnt_context_get_fstab_userdata\nmnt_context_get_fstype\nmnt_context_get_fs_userdata\nmnt_context_get_helper_status\nmnt_context_get_lock\nmnt_context_get_mflags\nmnt_context_get_mtab\nmnt_context_get_mtab_userdata\nmnt_context_get_options\nmnt_context_get_optsmode\nmnt_context_get_origin_ns\nmnt_context_get_source\nmnt_context_get_status\nmnt_context_get_syscall_errno\nmnt_context_get_table\nmnt_context_get_target\nmnt_context_get_target_ns\nmnt_context_get_target_prefix\nmnt_context_get_user_mflags\nmnt_context_helper_executed\nmnt_context_helper_setopt\nmnt_context_init_helper\nmnt_context_is_child\nmnt_context_is_fake\nmnt_context_is_force\nmnt_context_is_fork\nmnt_context_is_fs_mounted\nmnt_context_is_lazy\nmnt_context_is_loopdel\nmnt_context_is_nocanonicalize\nmnt_context_is_nohelpers\nmnt_context_is_nomtab\nmnt_context_is_parent\nmnt_context_is_rdonly_umount\nmnt_context_is_restricted\nmnt_context_is_rwonly_mount\nmnt_context_is_sloppy\nmnt_context_is_swapmatch\nmnt_context_is_verbose\nmnt_context_reset_status\nmnt_context_set_cache\nmnt_context_set_fs\nmnt_context_set_fstab\nmnt_context_set_fstype\nmnt_context_set_fstype_pattern\nmnt_context_set_mflags\nmnt_context_set_mountdata\nmnt_context_set_options\nmnt_context_set_options_pattern\nmnt_context_set_optsmode\nmnt_context_set_passwd_cb\nmnt_context_set_source\nmnt_context_set_syscall_status\nmnt_context_set_tables_errcb\nmnt_context_set_target\nmnt_context_set_target_ns\nmnt_context_set_target_prefix\nmnt_context_set_user_mflags\nmnt_context_strerror\nmnt_context_switch_ns\nmnt_context_switch_origin_ns\nmnt_context_switch_target_ns\nmnt_context_syscall_called\nmnt_context_tab_applied\nmnt_context_wait_for_children\n<SUBSECTION>\nMNT_ERR_AMBIFS\nMNT_ERR_APPLYFLAGS\nMNT_ERR_LOOPDEV\nMNT_ERR_MOUNTOPT\nMNT_ERR_NOFSTAB\nMNT_ERR_NOFSTYPE\nMNT_ERR_NOSOURCE\nMNT_ERR_LOOPOVERLAP\nMNT_ERR_LOCK\nMNT_ERR_NAMESPACE\n<SUBSECTION>\nMNT_EX_SUCCESS\nMNT_EX_USAGE\nMNT_EX_SYSERR\nMNT_EX_SOFTWARE\nMNT_EX_USER\nMNT_EX_FILEIO\nMNT_EX_FAIL\nMNT_EX_SOMEOK\n</SECTION>\n\n<SECTION>\n<FILE>context-mount</FILE>\nmnt_context_do_mount\nmnt_context_finalize_mount\nmnt_context_mount\nmnt_context_next_mount\nmnt_context_next_remount\nmnt_context_prepare_mount\n<SUBSECTION>\nMNT_MS_COMMENT\nMNT_MS_GROUP\nMNT_MS_HELPER\nMNT_MS_LOOP\nMNT_MS_NETDEV\nMNT_MS_NOAUTO\nMNT_MS_NOFAIL\nMNT_MS_OFFSET\nMNT_MS_OWNER\nMNT_MS_SIZELIMIT\nMNT_MS_ENCRYPTION\nMNT_MS_UHELPER\nMNT_MS_USER\nMNT_MS_USERS\nMNT_MS_XCOMMENT\nMNT_MS_XFSTABCOMM\nMNT_MS_HASH_DEVICE\nMNT_MS_ROOT_HASH\nMNT_MS_HASH_OFFSET\nMNT_MS_ROOT_HASH_FILE\nMNT_MS_FEC_DEVICE\nMNT_MS_FEC_OFFSET\nMNT_MS_FEC_ROOTS\nMNT_MS_ROOT_HASH_SIG\n<SUBSECTION>\nMS_BIND\nMS_DIRSYNC\nMS_I_VERSION\nMS_MANDLOCK\nMS_MGC_MSK\nMS_MGC_VAL\nMS_MOVE\nMS_NOATIME\nMS_NODEV\nMS_NODIRATIME\nMS_NOEXEC\nMS_NOSUID\nMS_OWNERSECURE\nMS_PRIVATE\nMS_PROPAGATION\nMS_RDONLY\nMS_REC\nMS_RELATIME\nMS_REMOUNT\nMS_SECURE\nMS_SHARED\nMS_SILENT\nMS_SLAVE\nMS_STRICTATIME\nMS_SYNCHRONOUS\nMS_UNBINDABLE\nMS_LAZYTIME\n</SECTION>\n\n<SECTION>\n<FILE>context-umount</FILE>\nmnt_context_find_umount_fs\nmnt_context_do_umount\nmnt_context_finalize_umount\nmnt_context_next_umount\nmnt_context_prepare_umount\nmnt_context_umount\n</SECTION>\n\n<SECTION>\n<FILE>fs</FILE>\nlibmnt_fs\nmnt_copy_fs\nmnt_free_fs\nmnt_free_mntent\nmnt_ref_fs\nmnt_unref_fs\nmnt_fs_append_attributes\nmnt_fs_append_comment\nmnt_fs_append_options\nmnt_fs_get_attribute\nmnt_fs_get_attributes\nmnt_fs_get_bindsrc\nmnt_fs_get_comment\nmnt_fs_get_devno\nmnt_fs_get_freq\nmnt_fs_get_fs_options\nmnt_fs_get_fstype\nmnt_fs_get_id\nmnt_fs_get_option\nmnt_fs_get_optional_fields\nmnt_fs_get_options\nmnt_fs_get_parent_id\nmnt_fs_get_passno\nmnt_fs_get_priority\nmnt_fs_get_propagation\nmnt_fs_get_root\nmnt_fs_get_size\nmnt_fs_get_source\nmnt_fs_get_srcpath\nmnt_fs_get_swaptype\nmnt_fs_get_tag\nmnt_fs_get_table\nmnt_fs_get_target\nmnt_fs_get_tid\nmnt_fs_get_usedsize\nmnt_fs_get_userdata\nmnt_fs_get_user_options\nmnt_fs_get_vfs_options\nmnt_fs_get_vfs_options_all\nmnt_fs_is_deleted\nmnt_fs_is_kernel\nmnt_fs_is_netfs\nmnt_fs_is_pseudofs\nmnt_fs_is_regularfs\nmnt_fs_is_swaparea\nmnt_fs_match_fstype\nmnt_fs_match_options\nmnt_fs_match_source\nmnt_fs_match_target\nmnt_fs_prepend_attributes\nmnt_fs_prepend_options\nmnt_fs_print_debug\nmnt_fs_set_attributes\nmnt_fs_set_bindsrc\nmnt_fs_set_comment\nmnt_fs_set_freq\nmnt_fs_set_fstype\nmnt_fs_set_options\nmnt_fs_set_passno\nmnt_fs_set_priority\nmnt_fs_set_root\nmnt_fs_set_source\nmnt_fs_set_target\nmnt_fs_set_userdata\nmnt_fs_strdup_options\nmnt_fs_streq_srcpath\nmnt_fs_streq_target\nmnt_fs_to_mntent\nmnt_new_fs\nmnt_reset_fs\n</SECTION>\n\n<SECTION>\n<FILE>init</FILE>\nmnt_init_debug\n</SECTION>\n\n<SECTION>\n<FILE>iter</FILE>\nlibmnt_iter\nmnt_free_iter\nmnt_iter_get_direction\nmnt_new_iter\nmnt_reset_iter\n</SECTION>\n\n<SECTION>\n<FILE>lock</FILE>\nlibmnt_lock\nmnt_free_lock\nmnt_lock_file\nmnt_new_lock\nmnt_unlock_file\nmnt_lock_block_signals\n</SECTION>\n\n<SECTION>\n<FILE>optmap</FILE>\nlibmnt_optmap\nmnt_get_builtin_optmap\nMNT_INVERT\nMNT_NOMTAB\nMNT_PREFIX\nMNT_NOHLPS\n</SECTION>\n\n<SECTION>\n<FILE>optstr</FILE>\nmnt_optstr_append_option\nmnt_optstr_apply_flags\nmnt_optstr_deduplicate_option\nmnt_optstr_get_flags\nmnt_optstr_get_option\nmnt_optstr_get_options\nmnt_optstr_next_option\nmnt_optstr_prepend_option\nmnt_optstr_remove_option\nmnt_optstr_set_option\nmnt_split_optstr\nmnt_match_options\n</SECTION>\n\n<SECTION>\n<FILE>table</FILE>\nlibmnt_table\nmnt_free_table\nmnt_new_table\nmnt_reset_table\nmnt_ref_table\nmnt_unref_table\nmnt_new_table_from_dir\nmnt_new_table_from_file\nmnt_table_add_fs\nmnt_table_append_intro_comment\nmnt_table_append_trailing_comment\nmnt_table_enable_comments\nmnt_table_find_devno\nmnt_table_find_fs\nmnt_table_find_mountpoint\nmnt_table_find_next_fs\nmnt_table_find_pair\nmnt_table_find_source\nmnt_table_find_srcpath\nmnt_table_find_tag\nmnt_table_find_target\nmnt_table_find_target_with_option\nmnt_table_first_fs\nmnt_table_get_cache\nmnt_table_get_intro_comment\nmnt_table_get_nents\nmnt_table_get_root_fs\nmnt_table_get_trailing_comment\nmnt_table_get_userdata\nmnt_table_insert_fs\nmnt_table_is_empty\nmnt_table_is_fs_mounted\nmnt_table_last_fs\nmnt_table_move_fs\nmnt_table_next_child_fs\nmnt_table_next_fs\nmnt_table_over_fs\nmnt_table_parse_dir\nmnt_table_parse_file\nmnt_table_parse_fstab\nmnt_table_parse_mtab\nmnt_table_parse_stream\nmnt_table_parse_swaps\nmnt_table_remove_fs\nmnt_table_set_cache\nmnt_table_set_intro_comment\nmnt_table_set_iter\nmnt_table_set_parser_errcb\nmnt_table_set_trailing_comment\nmnt_table_set_userdata\nmnt_table_uniq_fs\nmnt_table_with_comments\n</SECTION>\n\n<SECTION>\n<FILE>tabdiff</FILE>\nlibmnt_tabdiff\nmnt_new_tabdiff\nmnt_free_tabdiff\nmnt_tabdiff_next_change\nmnt_diff_tables\n</SECTION>\n\n<SECTION>\n<FILE>update</FILE>\nlibmnt_update\nmnt_free_update\nmnt_new_update\nmnt_table_replace_file\nmnt_table_write_file\nmnt_update_force_rdonly\nmnt_update_get_filename\nmnt_update_get_fs\nmnt_update_get_mflags\nmnt_update_is_ready\nmnt_update_set_fs\nmnt_update_table\n</SECTION>\n\n<SECTION>\n<FILE>utils</FILE>\nmnt_fstype_is_netfs\nmnt_fstype_is_pseudofs\nmnt_get_fstab_path\nmnt_get_mountpoint\nmnt_get_mtab_path\nmnt_get_swaps_path\nmnt_guess_system_root\nmnt_has_regular_mtab\nmnt_mangle\nmnt_match_fstype\nmnt_tag_is_valid\nmnt_unmangle\n</SECTION>\n\n<SECTION>\n<FILE>version-utils</FILE>\nLIBMOUNT_MAJOR_VERSION\nLIBMOUNT_MINOR_VERSION\nLIBMOUNT_PATCH_VERSION\nmnt_parse_version_string\nmnt_get_library_version\nmnt_get_library_features\nLIBMOUNT_VERSION\n</SECTION>\n\n<SECTION>\n<FILE>monitor</FILE>\nlibmnt_monitor\nmnt_new_monitor\nmnt_ref_monitor\nmnt_unref_monitor\nmnt_monitor_enable_userspace\nmnt_monitor_enable_kernel\nmnt_monitor_get_fd\nmnt_monitor_close_fd\nmnt_monitor_next_change\nmnt_monitor_event_cleanup\nmnt_monitor_wait\n</SECTION>\n", "/* SPDX-License-Identifier: LGPL-2.1-or-later */\n/*\n * This file is part of libmount from util-linux project.\n *\n * Copyright (C) 2008-2018 Karel Zak <kzak@redhat.com>\n *\n * libmount is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n */\n\n/**\n * SECTION: fs\n * @title: Filesystem\n * @short_description: represents one entry from fstab, mtab, or mountinfo file\n *\n */\n#include <ctype.h>\n#include <blkid.h>\n#include <stddef.h>\n\n#include \"mountP.h\"\n#include \"strutils.h\"\n\n/**\n * mnt_new_fs:\n *\n * The initial refcount is 1, and needs to be decremented to\n * release the resources of the filesystem.\n *\n * Returns: newly allocated struct libmnt_fs.\n */\nstruct libmnt_fs *mnt_new_fs(void)\n{\n\tstruct libmnt_fs *fs = calloc(1, sizeof(*fs));\n\tif (!fs)\n\t\treturn NULL;\n\n\tfs->refcount = 1;\n\tINIT_LIST_HEAD(&fs->ents);\n\tDBG(FS, ul_debugobj(fs, \"alloc\"));\n\treturn fs;\n}\n\n/**\n * mnt_free_fs:\n * @fs: fs pointer\n *\n * Deallocates the fs. This function does not care about reference count. Don't\n * use this function directly -- it's better to use mnt_unref_fs().\n *\n * The reference counting is supported since util-linux v2.24.\n */\nvoid mnt_free_fs(struct libmnt_fs *fs)\n{\n\tif (!fs)\n\t\treturn;\n\n\tDBG(FS, ul_debugobj(fs, \"free [refcount=%d]\", fs->refcount));\n\n\tmnt_reset_fs(fs);\n\tfree(fs);\n}\n\n/**\n * mnt_reset_fs:\n * @fs: fs pointer\n *\n * Resets (zeroize) @fs.\n */\nvoid mnt_reset_fs(struct libmnt_fs *fs)\n{\n\tint ref;\n\n\tif (!fs)\n\t\treturn;\n\n\tref = fs->refcount;\n\n\tlist_del(&fs->ents);\n\tfree(fs->source);\n\tfree(fs->bindsrc);\n\tfree(fs->tagname);\n\tfree(fs->tagval);\n\tfree(fs->root);\n\tfree(fs->swaptype);\n\tfree(fs->target);\n\tfree(fs->fstype);\n\tfree(fs->optstr);\n\tfree(fs->vfs_optstr);\n\tfree(fs->fs_optstr);\n\tfree(fs->user_optstr);\n\tfree(fs->attrs);\n\tfree(fs->opt_fields);\n\tfree(fs->comment);\n\n\tmemset(fs, 0, sizeof(*fs));\n\tINIT_LIST_HEAD(&fs->ents);\n\tfs->refcount = ref;\n}\n\n/**\n * mnt_ref_fs:\n * @fs: fs pointer\n *\n * Increments reference counter.\n */\nvoid mnt_ref_fs(struct libmnt_fs *fs)\n{\n\tif (fs) {\n\t\tfs->refcount++;\n\t\t/*DBG(FS, ul_debugobj(fs, \"ref=%d\", fs->refcount));*/\n\t}\n}\n\n/**\n * mnt_unref_fs:\n * @fs: fs pointer\n *\n * De-increments reference counter, on zero the @fs is automatically\n * deallocated by mnt_free_fs().\n */\nvoid mnt_unref_fs(struct libmnt_fs *fs)\n{\n\tif (fs) {\n\t\tfs->refcount--;\n\t\t/*DBG(FS, ul_debugobj(fs, \"unref=%d\", fs->refcount));*/\n\t\tif (fs->refcount <= 0)\n\t\t\tmnt_free_fs(fs);\n\t}\n}\n\nstatic inline int update_str(char **dest, const char *src)\n{\n\tsize_t sz;\n\tchar *x;\n\n\tassert(dest);\n\n\tif (!src) {\n\t\tfree(*dest);\n\t\t*dest = NULL;\n\t\treturn 0;\t/* source (old) is empty */\n\t}\n\n\tsz = strlen(src) + 1;\n\tx = realloc(*dest, sz);\n\tif (!x)\n\t\treturn -ENOMEM;\n\t*dest = x;\n\tmemcpy(*dest, src, sz);\n\treturn 0;\n}\n\n/* This function does NOT overwrite (replace) the string in @new, the string in\n * @new has to be NULL otherwise this is no-op. */\nstatic inline int cpy_str_at_offset(void *new, const void *old, size_t offset)\n{\n\tchar **o = (char **) ((char *) old + offset);\n\tchar **n = (char **) ((char *) new + offset);\n\n\tif (*n)\n\t\treturn 0;\t/* already set, don't overwrite */\n\n\treturn update_str(n, *o);\n}\n\n/**\n * mnt_copy_fs:\n * @dest: destination FS\n * @src: source FS\n *\n * If @dest is NULL, then a new FS is allocated, if any @dest field is already\n * set, then the field is NOT overwritten.\n *\n * This function does not copy userdata (se mnt_fs_set_userdata()). A new copy is\n * not linked with any existing mnt_tab.\n *\n * Returns: @dest or NULL in case of error\n */\nstruct libmnt_fs *mnt_copy_fs(struct libmnt_fs *dest,\n\t\t\t      const struct libmnt_fs *src)\n{\n\tconst struct libmnt_fs *org = dest;\n\n\tif (!src)\n\t\treturn NULL;\n\tif (!dest) {\n\t\tdest = mnt_new_fs();\n\t\tif (!dest)\n\t\t\treturn NULL;\n\n\t\tdest->tab\t = NULL;\n\t}\n\n\tdest->id         = src->id;\n\tdest->parent     = src->parent;\n\tdest->devno      = src->devno;\n\tdest->tid        = src->tid;\n\n\tif (cpy_str_at_offset(dest, src, offsetof(struct libmnt_fs, source)))\n\t\tgoto err;\n\tif (cpy_str_at_offset(dest, src, offsetof(struct libmnt_fs, tagname)))\n\t\tgoto err;\n\tif (cpy_str_at_offset(dest, src, offsetof(struct libmnt_fs, tagval)))\n\t\tgoto err;\n\tif (cpy_str_at_offset(dest, src, offsetof(struct libmnt_fs, root)))\n\t\tgoto err;\n\tif (cpy_str_at_offset(dest, src, offsetof(struct libmnt_fs, swaptype)))\n\t\tgoto err;\n\tif (cpy_str_at_offset(dest, src, offsetof(struct libmnt_fs, target)))\n\t\tgoto err;\n\tif (cpy_str_at_offset(dest, src, offsetof(struct libmnt_fs, fstype)))\n\t\tgoto err;\n\tif (cpy_str_at_offset(dest, src, offsetof(struct libmnt_fs, optstr)))\n\t\tgoto err;\n\tif (cpy_str_at_offset(dest, src, offsetof(struct libmnt_fs, vfs_optstr)))\n\t\tgoto err;\n\tif (cpy_str_at_offset(dest, src, offsetof(struct libmnt_fs, fs_optstr)))\n\t\tgoto err;\n\tif (cpy_str_at_offset(dest, src, offsetof(struct libmnt_fs, user_optstr)))\n\t\tgoto err;\n\tif (cpy_str_at_offset(dest, src, offsetof(struct libmnt_fs, attrs)))\n\t\tgoto err;\n\tif (cpy_str_at_offset(dest, src, offsetof(struct libmnt_fs, bindsrc)))\n\t\tgoto err;\n\n\tdest->freq       = src->freq;\n\tdest->passno     = src->passno;\n\tdest->flags      = src->flags;\n\tdest->size\t = src->size;\n\tdest->usedsize   = src->usedsize;\n\tdest->priority   = src->priority;\n\n\treturn dest;\nerr:\n\tif (!org)\n\t\tmnt_free_fs(dest);\n\treturn NULL;\n}\n\n/*\n * This function copies all @fs description except information that does not\n * belong to /etc/mtab (e.g. VFS and userspace mount options with MNT_NOMTAB\n * mask).\n *\n * Returns: copy of @fs.\n */\nstruct libmnt_fs *mnt_copy_mtab_fs(const struct libmnt_fs *fs)\n{\n\tstruct libmnt_fs *n = mnt_new_fs();\n\n\tassert(fs);\n\tif (!n)\n\t\treturn NULL;\n\n\tif (strdup_between_structs(n, fs, source))\n\t\tgoto err;\n\tif (strdup_between_structs(n, fs, target))\n\t\tgoto err;\n\tif (strdup_between_structs(n, fs, fstype))\n\t\tgoto err;\n\n\tif (fs->vfs_optstr) {\n\t\tchar *p = NULL;\n\t\tmnt_optstr_get_options(fs->vfs_optstr, &p,\n\t\t\t\tmnt_get_builtin_optmap(MNT_LINUX_MAP),\n\t\t\t\tMNT_NOMTAB);\n\t\tn->vfs_optstr = p;\n\t}\n\n\tif (fs->user_optstr) {\n\t\tchar *p = NULL;\n\t\tmnt_optstr_get_options(fs->user_optstr, &p,\n\t\t\t\tmnt_get_builtin_optmap(MNT_USERSPACE_MAP),\n\t\t\t\tMNT_NOMTAB);\n\t\tn->user_optstr = p;\n\t}\n\n\tif (strdup_between_structs(n, fs, fs_optstr))\n\t\tgoto err;\n\n\t/* we cannot copy original optstr, the new optstr has to be without\n\t * non-mtab options -- so, let's generate a new string */\n\tn->optstr = mnt_fs_strdup_options(n);\n\n\tn->freq       = fs->freq;\n\tn->passno     = fs->passno;\n\tn->flags      = fs->flags;\n\n\treturn n;\nerr:\n\tmnt_free_fs(n);\n\treturn NULL;\n\n}\n\n/**\n * mnt_fs_get_userdata:\n * @fs: struct libmnt_file instance\n *\n * Returns: private data set by mnt_fs_set_userdata() or NULL.\n */\nvoid *mnt_fs_get_userdata(struct libmnt_fs *fs)\n{\n\tif (!fs)\n\t\treturn NULL;\n\treturn fs->userdata;\n}\n\n/**\n * mnt_fs_set_userdata:\n * @fs: struct libmnt_file instance\n * @data: user data\n *\n * The \"userdata\" are library independent data.\n *\n * Returns: 0 or negative number in case of error (if @fs is NULL).\n */\nint mnt_fs_set_userdata(struct libmnt_fs *fs, void *data)\n{\n\tif (!fs)\n\t\treturn -EINVAL;\n\tfs->userdata = data;\n\treturn 0;\n}\n\n/**\n * mnt_fs_get_srcpath:\n * @fs: struct libmnt_file (fstab/mtab/mountinfo) fs\n *\n * The mount \"source path\" is:\n * - a directory for 'bind' mounts (in fstab or mtab only)\n * - a device name for standard mounts\n *\n * See also mnt_fs_get_tag() and mnt_fs_get_source().\n *\n * Returns: mount source path or NULL in case of error or when the path\n * is not defined.\n */\nconst char *mnt_fs_get_srcpath(struct libmnt_fs *fs)\n{\n\tif (!fs)\n\t\treturn NULL;\n\n\t/* fstab-like fs */\n\tif (fs->tagname)\n\t\treturn NULL;\t/* the source contains a \"NAME=value\" */\n\treturn fs->source;\n}\n\n/**\n * mnt_fs_get_source:\n * @fs: struct libmnt_file (fstab/mtab/mountinfo) fs\n *\n * Returns: mount source. Note that the source could be unparsed TAG\n * (LABEL/UUID). See also mnt_fs_get_srcpath() and mnt_fs_get_tag().\n */\nconst char *mnt_fs_get_source(struct libmnt_fs *fs)\n{\n\treturn fs ? fs->source : NULL;\n}\n\n/*\n * Used by the parser ONLY (@source has to be freed on error)\n */\nint __mnt_fs_set_source_ptr(struct libmnt_fs *fs, char *source)\n{\n\tchar *t = NULL, *v = NULL;\n\n\tassert(fs);\n\n\tif (source && blkid_parse_tag_string(source, &t, &v) == 0 &&\n\t    !mnt_valid_tagname(t)) {\n\t\t/* parsable but unknown tag -- ignore */\n\t\tfree(t);\n\t\tfree(v);\n\t\tt = v = NULL;\n\t}\n\n\tif (fs->source != source)\n\t\tfree(fs->source);\n\n\tfree(fs->tagname);\n\tfree(fs->tagval);\n\n\tfs->source = source;\n\tfs->tagname = t;\n\tfs->tagval = v;\n\treturn 0;\n}\n\n/**\n * mnt_fs_set_source:\n * @fs: fstab/mtab/mountinfo entry\n * @source: new source\n *\n * This function creates a private copy (strdup()) of @source.\n *\n * Returns: 0 on success or negative number in case of error.\n */\nint mnt_fs_set_source(struct libmnt_fs *fs, const char *source)\n{\n\tchar *p = NULL;\n\tint rc;\n\n\tif (!fs)\n\t\treturn -EINVAL;\n\n\tif (source) {\n\t\tp = strdup(source);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t}\n\n\trc = __mnt_fs_set_source_ptr(fs, p);\n\tif (rc)\n\t\tfree(p);\n\treturn rc;\n}\n\n/**\n * mnt_fs_streq_srcpath:\n * @fs: fs\n * @path: source path\n *\n * Compares @fs source path with @path. The redundant slashes are ignored.\n * This function compares strings and does not canonicalize the paths.\n * See also more heavy and generic mnt_fs_match_source().\n *\n * Returns: 1 if @fs source path equal to @path, otherwise 0.\n */\nint mnt_fs_streq_srcpath(struct libmnt_fs *fs, const char *path)\n{\n\tconst char *p;\n\n\tif (!fs)\n\t\treturn 0;\n\n\tp = mnt_fs_get_srcpath(fs);\n\n\tif (!mnt_fs_is_pseudofs(fs))\n\t\treturn streq_paths(p, path);\n\n\tif (!p && !path)\n\t\treturn 1;\n\n\treturn p && path && strcmp(p, path) == 0;\n}\n\n/**\n * mnt_fs_get_table:\n * @fs: table entry\n * @tb: table that contains @fs\n *\n * Returns: 0 or negative number on error (if @fs or @tb is NULL).\n *\n * Since: 2.34\n */\nint mnt_fs_get_table(struct libmnt_fs *fs, struct libmnt_table **tb)\n{\n\tif (!fs || !tb)\n\t\treturn -EINVAL;\n\n\t*tb = fs->tab;\n\treturn 0;\n}\n\n/**\n * mnt_fs_streq_target:\n * @fs: fs\n * @path: mount point\n *\n * Compares @fs target path with @path. The redundant slashes are ignored.\n * This function compares strings and does not canonicalize the paths.\n * See also more generic mnt_fs_match_target().\n *\n * Returns: 1 if @fs target path equal to @path, otherwise 0.\n */\nint mnt_fs_streq_target(struct libmnt_fs *fs, const char *path)\n{\n\treturn fs && streq_paths(mnt_fs_get_target(fs), path);\n}\n\n/**\n * mnt_fs_get_tag:\n * @fs: fs\n * @name: returns pointer to NAME string\n * @value: returns pointer to VALUE string\n *\n * \"TAG\" is NAME=VALUE (e.g. LABEL=foo)\n *\n * The TAG is the first column in the fstab file. The TAG or \"srcpath\" always has\n * to be set for all entries.\n *\n * See also mnt_fs_get_source().\n *\n * <informalexample>\n *   <programlisting>\n *\tchar *src;\n *\tstruct libmnt_fs *fs = mnt_table_find_target(tb, \"/home\", MNT_ITER_FORWARD);\n *\n *\tif (!fs)\n *\t\tgoto err;\n *\n *\tsrc = mnt_fs_get_srcpath(fs);\n *\tif (!src) {\n *\t\tchar *tag, *val;\n *\t\tif (mnt_fs_get_tag(fs, &tag, &val) == 0)\n *\t\t\tprintf(\"%s: %s\\n\", tag, val);\t// LABEL or UUID\n *\t} else\n *\t\tprintf(\"device: %s\\n\", src);\t\t// device or bind path\n *   </programlisting>\n * </informalexample>\n *\n * Returns: 0 on success or negative number in case a TAG is not defined.\n */\nint mnt_fs_get_tag(struct libmnt_fs *fs, const char **name, const char **value)\n{\n\tif (fs == NULL || !fs->tagname)\n\t\treturn -EINVAL;\n\tif (name)\n\t\t*name = fs->tagname;\n\tif (value)\n\t\t*value = fs->tagval;\n\treturn 0;\n}\n\n/**\n * mnt_fs_get_target:\n * @fs: fstab/mtab/mountinfo entry pointer\n *\n * Returns: pointer to mountpoint path or NULL\n */\nconst char *mnt_fs_get_target(struct libmnt_fs *fs)\n{\n\treturn fs ? fs->target : NULL;\n}\n\n/**\n * mnt_fs_set_target:\n * @fs: fstab/mtab/mountinfo entry\n * @tgt: mountpoint\n *\n * This function creates a private copy (strdup()) of @tgt.\n *\n * Returns: 0 on success or negative number in case of error.\n */\nint mnt_fs_set_target(struct libmnt_fs *fs, const char *tgt)\n{\n\treturn strdup_to_struct_member(fs, target, tgt);\n}\n\nstatic int mnt_fs_get_flags(struct libmnt_fs *fs)\n{\n\treturn fs ? fs->flags : 0;\n}\n\n/**\n * mnt_fs_get_propagation:\n * @fs: mountinfo entry\n * @flags: returns propagation MS_* flags as present in the mountinfo file\n *\n * Note that this function sets @flags to zero if no propagation flags are found\n * in the mountinfo file. The kernel default is MS_PRIVATE, this flag is not stored\n * in the mountinfo file.\n *\n * Returns: 0 on success or negative number in case of error.\n */\nint mnt_fs_get_propagation(struct libmnt_fs *fs, unsigned long *flags)\n{\n\tif (!fs || !flags)\n\t\treturn -EINVAL;\n\n\t*flags = 0;\n\n\tif (!fs->opt_fields)\n\t\treturn 0;\n\n\t /*\n\t * The optional fields format is incompatible with mount options\n\t * ... we have to parse the field here.\n\t */\n\t*flags |= strstr(fs->opt_fields, \"shared:\") ? MS_SHARED : MS_PRIVATE;\n\n\tif (strstr(fs->opt_fields, \"master:\"))\n\t\t*flags |= MS_SLAVE;\n\tif (strstr(fs->opt_fields, \"unbindable\"))\n\t\t*flags |= MS_UNBINDABLE;\n\n\treturn 0;\n}\n\n/**\n * mnt_fs_is_kernel:\n * @fs: filesystem\n *\n * Returns: 1 if the filesystem description is read from kernel e.g. /proc/mounts.\n */\nint mnt_fs_is_kernel(struct libmnt_fs *fs)\n{\n\treturn mnt_fs_get_flags(fs) & MNT_FS_KERNEL;\n}\n\n/**\n * mnt_fs_is_swaparea:\n * @fs: filesystem\n *\n * Returns: 1 if the filesystem uses \"swap\" as a type\n */\nint mnt_fs_is_swaparea(struct libmnt_fs *fs)\n{\n\treturn mnt_fs_get_flags(fs) & MNT_FS_SWAP;\n}\n\n/**\n * mnt_fs_is_pseudofs:\n * @fs: filesystem\n *\n * Returns: 1 if the filesystem is a pseudo fs type (proc, cgroups)\n */\nint mnt_fs_is_pseudofs(struct libmnt_fs *fs)\n{\n\treturn mnt_fs_get_flags(fs) & MNT_FS_PSEUDO;\n}\n\n/**\n * mnt_fs_is_netfs:\n * @fs: filesystem\n *\n * Returns: 1 if the filesystem is a network filesystem\n */\nint mnt_fs_is_netfs(struct libmnt_fs *fs)\n{\n\treturn mnt_fs_get_flags(fs) & MNT_FS_NET;\n}\n\n/**\n * mnt_fs_is_regularfs:\n * @fs: filesystem\n *\n * Returns: 1 if the filesystem is a regular filesystem (not network or pseudo filesystem).\n *\n * Since: 2.38\n */\nint mnt_fs_is_regularfs(struct libmnt_fs *fs)\n{\n\treturn !(mnt_fs_is_pseudofs(fs)\n\t\t || mnt_fs_is_netfs(fs)\n\t\t || mnt_fs_is_swaparea(fs));\n}\n\n/**\n * mnt_fs_is_deleted:\n * @fs: filesystem\n *\n * Returns: 1 if the filesystem target is a marked as deleted by kernel\n */\nint mnt_fs_is_deleted(struct libmnt_fs *fs)\n{\n\treturn mnt_fs_get_flags(fs) & MNT_FS_DELETED;\n}\n\n/**\n * mnt_fs_get_fstype:\n * @fs: fstab/mtab/mountinfo entry pointer\n *\n * Returns: pointer to filesystem type.\n */\nconst char *mnt_fs_get_fstype(struct libmnt_fs *fs)\n{\n\treturn fs ? fs->fstype : NULL;\n}\n\n/* Used by the struct libmnt_file parser only */\nint __mnt_fs_set_fstype_ptr(struct libmnt_fs *fs, char *fstype)\n{\n\tassert(fs);\n\n\tif (fstype != fs->fstype)\n\t\tfree(fs->fstype);\n\n\tfs->fstype = fstype;\n\tfs->flags &= ~MNT_FS_PSEUDO;\n\tfs->flags &= ~MNT_FS_NET;\n\tfs->flags &= ~MNT_FS_SWAP;\n\n\t/* save info about pseudo filesystems */\n\tif (fs->fstype) {\n\t\tif (mnt_fstype_is_pseudofs(fs->fstype))\n\t\t\tfs->flags |= MNT_FS_PSEUDO;\n\t\telse if (mnt_fstype_is_netfs(fs->fstype))\n\t\t\tfs->flags |= MNT_FS_NET;\n\t\telse if (!strcmp(fs->fstype, \"swap\"))\n\t\t\tfs->flags |= MNT_FS_SWAP;\n\t}\n\treturn 0;\n}\n\n/**\n * mnt_fs_set_fstype:\n * @fs: fstab/mtab/mountinfo entry\n * @fstype: filesystem type\n *\n * This function creates a private copy (strdup()) of @fstype.\n *\n * Returns: 0 on success or negative number in case of error.\n */\nint mnt_fs_set_fstype(struct libmnt_fs *fs, const char *fstype)\n{\n\tchar *p = NULL;\n\n\tif (!fs)\n\t\treturn -EINVAL;\n\tif (fstype) {\n\t\tp = strdup(fstype);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t}\n\treturn  __mnt_fs_set_fstype_ptr(fs, p);\n}\n\n/*\n * Merges @vfs and @fs options strings into a new string.\n * This function cares about 'ro/rw' options. The 'ro' is\n * always used if @vfs or @fs is read-only.\n * For example:\n *\n *    mnt_merge_optstr(\"rw,noexec\", \"ro,journal=update\")\n *\n *           returns: \"ro,noexec,journal=update\"\n *\n *    mnt_merge_optstr(\"rw,noexec\", \"rw,journal=update\")\n *\n *           returns: \"rw,noexec,journal=update\"\n */\nstatic char *merge_optstr(const char *vfs, const char *fs)\n{\n\tchar *res, *p;\n\tsize_t sz;\n\tint ro = 0, rw = 0;\n\n\tif (!vfs && !fs)\n\t\treturn NULL;\n\tif (!vfs || !fs)\n\t\treturn strdup(fs ? fs : vfs);\n\tif (!strcmp(vfs, fs))\n\t\treturn strdup(vfs);\t\t/* e.g. \"aaa\" and \"aaa\" */\n\n\t/* leave space for the leading \"r[ow],\", \",\" and the trailing zero */\n\tsz = strlen(vfs) + strlen(fs) + 5;\n\tres = malloc(sz);\n\tif (!res)\n\t\treturn NULL;\n\tp = res + 3;\t\t\t/* make a room for rw/ro flag */\n\n\tsnprintf(p, sz - 3, \"%s,%s\", vfs, fs);\n\n\t/* remove 'rw' flags */\n\trw += !mnt_optstr_remove_option(&p, \"rw\");\t/* from vfs */\n\trw += !mnt_optstr_remove_option(&p, \"rw\");\t/* from fs */\n\n\t/* remove 'ro' flags if necessary */\n\tif (rw != 2) {\n\t\tro += !mnt_optstr_remove_option(&p, \"ro\");\n\t\tif (ro + rw < 2)\n\t\t\tro += !mnt_optstr_remove_option(&p, \"ro\");\n\t}\n\n\tif (!strlen(p))\n\t\tmemcpy(res, ro ? \"ro\" : \"rw\", 3);\n\telse\n\t\tmemcpy(res, ro ? \"ro,\" : \"rw,\", 3);\n\treturn res;\n}\n\n/**\n * mnt_fs_strdup_options:\n * @fs: fstab/mtab/mountinfo entry pointer\n *\n * Merges all mount options (VFS, FS and userspace) to one options string\n * and returns the result. This function does not modify @fs.\n *\n * Returns: pointer to string (can be freed by free(3)) or NULL in case of error.\n */\nchar *mnt_fs_strdup_options(struct libmnt_fs *fs)\n{\n\tchar *res;\n\n\tif (!fs)\n\t\treturn NULL;\n\n\terrno = 0;\n\tif (fs->optstr)\n\t\treturn strdup(fs->optstr);\n\n\tres = merge_optstr(fs->vfs_optstr, fs->fs_optstr);\n\tif (!res && errno)\n\t\treturn NULL;\n\tif (fs->user_optstr &&\n\t    mnt_optstr_append_option(&res, fs->user_optstr, NULL)) {\n\t\tfree(res);\n\t\tres = NULL;\n\t}\n\treturn res;\n}\n\n/**\n * mnt_fs_get_options:\n * @fs: fstab/mtab/mountinfo entry pointer\n *\n * Returns: pointer to string or NULL in case of error.\n */\nconst char *mnt_fs_get_options(struct libmnt_fs *fs)\n{\n\treturn fs ? fs->optstr : NULL;\n}\n\n/**\n * mnt_fs_get_optional_fields\n * @fs: mountinfo entry pointer\n *\n * Returns: pointer to string with mountinfo optional fields\n *          or NULL in case of error.\n */\nconst char *mnt_fs_get_optional_fields(struct libmnt_fs *fs)\n{\n\treturn fs ? fs->opt_fields : NULL;\n}\n\n/**\n * mnt_fs_set_options:\n * @fs: fstab/mtab/mountinfo entry pointer\n * @optstr: options string\n *\n * Splits @optstr to VFS, FS and userspace mount options and updates relevant\n * parts of @fs.\n *\n * Returns: 0 on success, or negative number in case of error.\n */\nint mnt_fs_set_options(struct libmnt_fs *fs, const char *optstr)\n{\n\tchar *v = NULL, *f = NULL, *u = NULL, *n = NULL;\n\n\tif (!fs)\n\t\treturn -EINVAL;\n\tif (optstr) {\n\t\tint rc = mnt_split_optstr(optstr, &u, &v, &f, 0, 0);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tn = strdup(optstr);\n\t\tif (!n) {\n\t\t\tfree(u);\n\t\t\tfree(v);\n\t\t\tfree(f);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tfree(fs->fs_optstr);\n\tfree(fs->vfs_optstr);\n\tfree(fs->user_optstr);\n\tfree(fs->optstr);\n\n\tfs->fs_optstr = f;\n\tfs->vfs_optstr = v;\n\tfs->user_optstr = u;\n\tfs->optstr = n;\n\n\treturn 0;\n}\n\n/**\n * mnt_fs_append_options:\n * @fs: fstab/mtab/mountinfo entry\n * @optstr: mount options\n *\n * Parses (splits) @optstr and appends results to VFS, FS and userspace lists\n * of options.\n *\n * If @optstr is NULL, then @fs is not modified and 0 is returned.\n *\n * Returns: 0 on success or negative number in case of error.\n */\nint mnt_fs_append_options(struct libmnt_fs *fs, const char *optstr)\n{\n\tchar *v = NULL, *f = NULL, *u = NULL;\n\tint rc;\n\n\tif (!fs)\n\t\treturn -EINVAL;\n\tif (!optstr)\n\t\treturn 0;\n\n\trc = mnt_split_optstr(optstr, &u, &v, &f, 0, 0);\n\tif (rc)\n\t\treturn rc;\n\n\tif (!rc && v)\n\t\trc = mnt_optstr_append_option(&fs->vfs_optstr, v, NULL);\n\tif (!rc && f)\n\t\trc = mnt_optstr_append_option(&fs->fs_optstr, f, NULL);\n\tif (!rc && u)\n\t\trc = mnt_optstr_append_option(&fs->user_optstr, u, NULL);\n\tif (!rc)\n\t\trc = mnt_optstr_append_option(&fs->optstr, optstr, NULL);\n\n\tfree(v);\n\tfree(f);\n\tfree(u);\n\n\treturn rc;\n}\n\n/**\n * mnt_fs_prepend_options:\n * @fs: fstab/mtab/mountinfo entry\n * @optstr: mount options\n *\n * Parses (splits) @optstr and prepends the results to VFS, FS and userspace lists\n * of options.\n *\n * If @optstr is NULL, then @fs is not modified and 0 is returned.\n *\n * Returns: 0 on success or negative number in case of error.\n */\nint mnt_fs_prepend_options(struct libmnt_fs *fs, const char *optstr)\n{\n\tchar *v = NULL, *f = NULL, *u = NULL;\n\tint rc;\n\n\tif (!fs)\n\t\treturn -EINVAL;\n\tif (!optstr)\n\t\treturn 0;\n\n\trc = mnt_split_optstr(optstr, &u, &v, &f, 0, 0);\n\tif (rc)\n\t\treturn rc;\n\n\tif (!rc && v)\n\t\trc = mnt_optstr_prepend_option(&fs->vfs_optstr, v, NULL);\n\tif (!rc && f)\n\t\trc = mnt_optstr_prepend_option(&fs->fs_optstr, f, NULL);\n\tif (!rc && u)\n\t\trc = mnt_optstr_prepend_option(&fs->user_optstr, u, NULL);\n\tif (!rc)\n\t\trc = mnt_optstr_prepend_option(&fs->optstr, optstr, NULL);\n\n\tfree(v);\n\tfree(f);\n\tfree(u);\n\n\treturn rc;\n}\n\n/*\n * mnt_fs_get_fs_options:\n * @fs: fstab/mtab/mountinfo entry pointer\n *\n * Returns: pointer to superblock (fs-depend) mount option string or NULL.\n */\nconst char *mnt_fs_get_fs_options(struct libmnt_fs *fs)\n{\n\treturn fs ? fs->fs_optstr : NULL;\n}\n\n/**\n * mnt_fs_get_vfs_options:\n * @fs: fstab/mtab entry pointer\n *\n * Returns: pointer to fs-independent (VFS) mount option string or NULL.\n */\nconst char *mnt_fs_get_vfs_options(struct libmnt_fs *fs)\n{\n\treturn fs ? fs->vfs_optstr : NULL;\n}\n\n/**\n * mnt_fs_get_vfs_options_all:\n * @fs: fstab/mtab entry pointer\n *\n * Returns: pointer to newlly allocated string (can be freed by free(3)) or\n * NULL in case of error.  The string contains all (including defaults) mount\n * options.\n */\nchar *mnt_fs_get_vfs_options_all(struct libmnt_fs *fs)\n{\n\tconst struct libmnt_optmap *map = mnt_get_builtin_optmap(MNT_LINUX_MAP);\n\tconst struct libmnt_optmap *ent;\n\tconst char *opts = mnt_fs_get_options(fs);\n\tchar *result = NULL;\n\tunsigned long flags = 0;\n\n\tif (!opts || mnt_optstr_get_flags(opts, &flags, map))\n\t\treturn NULL;\n\n\tfor (ent = map ; ent && ent->name ; ent++){\n\t\tif (ent->id & flags) { /* non-default value */\n\t\t\tif (!(ent->mask & MNT_INVERT))\n\t\t\t\tmnt_optstr_append_option(&result, ent->name, NULL);\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t} else if (ent->mask & MNT_INVERT)\n\t\t\tmnt_optstr_append_option(&result, ent->name, NULL);\n\t}\n\n\treturn result;\n}\n\n/**\n * mnt_fs_get_user_options:\n * @fs: fstab/mtab entry pointer\n *\n * Returns: pointer to userspace mount option string or NULL.\n */\nconst char *mnt_fs_get_user_options(struct libmnt_fs *fs)\n{\n\treturn fs ? fs->user_optstr : NULL;\n}\n\n/**\n * mnt_fs_get_attributes:\n * @fs: fstab/mtab entry pointer\n *\n * Returns: pointer to attributes string or NULL.\n */\nconst char *mnt_fs_get_attributes(struct libmnt_fs *fs)\n{\n\treturn fs ? fs->attrs : NULL;\n}\n\n/**\n * mnt_fs_set_attributes:\n * @fs: fstab/mtab/mountinfo entry\n * @optstr: options string\n *\n * Sets mount attributes. The attributes are mount(2) and mount(8) independent\n * options, these options are not sent to the kernel and are not interpreted by\n * libmount. The attributes are stored in /run/mount/utab only.\n *\n * The attributes are managed by libmount in userspace only. It's possible\n * that information stored in userspace will not be available for libmount\n * after CLONE_FS unshare. Be careful, and don't use attributes if possible.\n *\n * Returns: 0 on success or negative number in case of error.\n */\nint mnt_fs_set_attributes(struct libmnt_fs *fs, const char *optstr)\n{\n\treturn strdup_to_struct_member(fs, attrs, optstr);\n}\n\n/**\n * mnt_fs_append_attributes\n * @fs: fstab/mtab/mountinfo entry\n * @optstr: options string\n *\n * Appends mount attributes. (See mnt_fs_set_attributes()).\n *\n * Returns: 0 on success or negative number in case of error.\n */\nint mnt_fs_append_attributes(struct libmnt_fs *fs, const char *optstr)\n{\n\tif (!fs)\n\t\treturn -EINVAL;\n\tif (!optstr)\n\t\treturn 0;\n\treturn mnt_optstr_append_option(&fs->attrs, optstr, NULL);\n}\n\n/**\n * mnt_fs_prepend_attributes\n * @fs: fstab/mtab/mountinfo entry\n * @optstr: options string\n *\n * Prepends mount attributes. (See mnt_fs_set_attributes()).\n *\n * Returns: 0 on success or negative number in case of error.\n */\nint mnt_fs_prepend_attributes(struct libmnt_fs *fs, const char *optstr)\n{\n\tif (!fs)\n\t\treturn -EINVAL;\n\tif (!optstr)\n\t\treturn 0;\n\treturn mnt_optstr_prepend_option(&fs->attrs, optstr, NULL);\n}\n\n\n/**\n * mnt_fs_get_freq:\n * @fs: fstab/mtab/mountinfo entry pointer\n *\n * Returns: dump frequency in days.\n */\nint mnt_fs_get_freq(struct libmnt_fs *fs)\n{\n\treturn fs ? fs->freq : 0;\n}\n\n/**\n * mnt_fs_set_freq:\n * @fs: fstab/mtab entry pointer\n * @freq: dump frequency in days\n *\n * Returns: 0 on success or negative number in case of error.\n */\nint mnt_fs_set_freq(struct libmnt_fs *fs, int freq)\n{\n\tif (!fs)\n\t\treturn -EINVAL;\n\tfs->freq = freq;\n\treturn 0;\n}\n\n/**\n * mnt_fs_get_passno:\n * @fs: fstab/mtab entry pointer\n *\n * Returns: \"pass number on parallel fsck\".\n */\nint mnt_fs_get_passno(struct libmnt_fs *fs)\n{\n\treturn fs ? fs->passno: 0;\n}\n\n/**\n * mnt_fs_set_passno:\n * @fs: fstab/mtab entry pointer\n * @passno: pass number\n *\n * Returns: 0 on success or negative number in case of error.\n */\nint mnt_fs_set_passno(struct libmnt_fs *fs, int passno)\n{\n\tif (!fs)\n\t\treturn -EINVAL;\n\tfs->passno = passno;\n\treturn 0;\n}\n\n/**\n * mnt_fs_get_root:\n * @fs: /proc/self/mountinfo entry\n *\n * Returns: root of the mount within the filesystem or NULL\n */\nconst char *mnt_fs_get_root(struct libmnt_fs *fs)\n{\n\treturn fs ? fs->root : NULL;\n}\n\n/**\n * mnt_fs_set_root:\n * @fs: mountinfo entry\n * @path: root path\n *\n * Returns: 0 on success or negative number in case of error.\n */\nint mnt_fs_set_root(struct libmnt_fs *fs, const char *path)\n{\n\treturn strdup_to_struct_member(fs, root, path);\n}\n\n/**\n * mnt_fs_get_swaptype:\n * @fs: /proc/swaps entry\n *\n * Returns: swap type or NULL\n */\nconst char *mnt_fs_get_swaptype(struct libmnt_fs *fs)\n{\n\treturn fs ? fs->swaptype : NULL;\n}\n\n/**\n * mnt_fs_get_size:\n * @fs: /proc/swaps entry\n *\n * Returns: size\n */\noff_t mnt_fs_get_size(struct libmnt_fs *fs)\n{\n\treturn fs ? fs->size : 0;\n}\n\n/**\n * mnt_fs_get_usedsize:\n * @fs: /proc/swaps entry\n *\n * Returns: used size\n */\noff_t mnt_fs_get_usedsize(struct libmnt_fs *fs)\n{\n\treturn fs ? fs->usedsize : 0;\n}\n\n/**\n * mnt_fs_get_priority:\n * @fs: /proc/swaps entry\n *\n * Returns: priority\n */\nint mnt_fs_get_priority(struct libmnt_fs *fs)\n{\n\treturn fs ? fs->priority : 0;\n}\n\n/**\n * mnt_fs_set_priority:\n * @fs: /proc/swaps entry\n * @prio: priority\n *\n * Since: 2.28\n *\n * Returns: 0 or -1 in case of error\n */\nint mnt_fs_set_priority(struct libmnt_fs *fs, int prio)\n{\n\tif (!fs)\n\t\treturn -EINVAL;\n\tfs->priority = prio;\n\treturn 0;\n}\n\n/**\n * mnt_fs_get_bindsrc:\n * @fs: /run/mount/utab entry\n *\n * Returns: full path that was used for mount(2) on MS_BIND\n */\nconst char *mnt_fs_get_bindsrc(struct libmnt_fs *fs)\n{\n\treturn fs ? fs->bindsrc : NULL;\n}\n\n/**\n * mnt_fs_set_bindsrc:\n * @fs: filesystem\n * @src: path\n *\n * Returns: 0 on success or negative number in case of error.\n */\nint mnt_fs_set_bindsrc(struct libmnt_fs *fs, const char *src)\n{\n\treturn strdup_to_struct_member(fs, bindsrc, src);\n}\n\n/**\n * mnt_fs_get_id:\n * @fs: /proc/self/mountinfo entry\n *\n * Returns: mount ID (unique identifier of the mount) or negative number in case of error.\n */\nint mnt_fs_get_id(struct libmnt_fs *fs)\n{\n\treturn fs ? fs->id : -EINVAL;\n}\n\n/**\n * mnt_fs_get_parent_id:\n * @fs: /proc/self/mountinfo entry\n *\n * Returns: parent mount ID or negative number in case of error.\n */\nint mnt_fs_get_parent_id(struct libmnt_fs *fs)\n{\n\treturn fs ? fs->parent : -EINVAL;\n}\n\n/**\n * mnt_fs_get_devno:\n * @fs: /proc/self/mountinfo entry\n *\n * Returns: value of st_dev for files on filesystem or 0 in case of error.\n */\ndev_t mnt_fs_get_devno(struct libmnt_fs *fs)\n{\n\treturn fs ? fs->devno : 0;\n}\n\n/**\n * mnt_fs_get_tid:\n * @fs: /proc/tid/mountinfo entry\n *\n * Returns: TID (task ID) for filesystems read from the mountinfo file\n */\npid_t mnt_fs_get_tid(struct libmnt_fs *fs)\n{\n\treturn fs ? fs->tid : 0;\n}\n\n/**\n * mnt_fs_get_option:\n * @fs: fstab/mtab/mountinfo entry pointer\n * @name: option name\n * @value: returns pointer to the beginning of the value (e.g. name=VALUE) or NULL\n * @valsz: returns size of options value or 0\n *\n * Returns: 0 on success, 1 when @name not found or negative number in case of error.\n */\nint mnt_fs_get_option(struct libmnt_fs *fs, const char *name,\n\t\tchar **value, size_t *valsz)\n{\n\tchar rc = 1;\n\n\tif (!fs)\n\t\treturn -EINVAL;\n\tif (fs->fs_optstr)\n\t\trc = mnt_optstr_get_option(fs->fs_optstr, name, value, valsz);\n\tif (rc == 1 && fs->vfs_optstr)\n\t\trc = mnt_optstr_get_option(fs->vfs_optstr, name, value, valsz);\n\tif (rc == 1 && fs->user_optstr)\n\t\trc = mnt_optstr_get_option(fs->user_optstr, name, value, valsz);\n\treturn rc;\n}\n\n/**\n * mnt_fs_get_attribute:\n * @fs: fstab/mtab/mountinfo entry pointer\n * @name: option name\n * @value: returns pointer to the beginning of the value (e.g. name=VALUE) or NULL\n * @valsz: returns size of options value or 0\n *\n * Returns: 0 on success, 1 when @name not found or negative number in case of error.\n */\nint mnt_fs_get_attribute(struct libmnt_fs *fs, const char *name,\n\t\tchar **value, size_t *valsz)\n{\n\tchar rc = 1;\n\n\tif (!fs)\n\t\treturn -EINVAL;\n\tif (fs->attrs)\n\t\trc = mnt_optstr_get_option(fs->attrs, name, value, valsz);\n\treturn rc;\n}\n\n/**\n * mnt_fs_get_comment:\n * @fs: fstab/mtab/mountinfo entry pointer\n *\n * Returns: 0 on success, 1 when not found the @name or negative number in case of error.\n */\nconst char *mnt_fs_get_comment(struct libmnt_fs *fs)\n{\n\tif (!fs)\n\t\treturn NULL;\n\treturn fs->comment;\n}\n\n/**\n * mnt_fs_set_comment:\n * @fs: fstab entry pointer\n * @comm: comment string\n *\n * Note that the comment has to be terminated by '\\n' (new line), otherwise\n * the whole filesystem entry will be written as a comment to the tabfile (e.g.\n * fstab).\n *\n * Returns: 0 on success or <0 in case of error.\n */\nint mnt_fs_set_comment(struct libmnt_fs *fs, const char *comm)\n{\n\treturn strdup_to_struct_member(fs, comment, comm);\n}\n\n/**\n * mnt_fs_append_comment:\n * @fs: fstab entry pointer\n * @comm: comment string\n *\n * See also mnt_fs_set_comment().\n *\n * Returns: 0 on success or <0 in case of error.\n */\nint mnt_fs_append_comment(struct libmnt_fs *fs, const char *comm)\n{\n\tif (!fs)\n\t\treturn -EINVAL;\n\n\treturn strappend(&fs->comment, comm);\n}\n\n/**\n * mnt_fs_match_target:\n * @fs: filesystem\n * @target: mountpoint path\n * @cache: tags/paths cache or NULL\n *\n * Possible are three attempts:\n *\t1) compare @target with @fs->target\n *\n *\t2) realpath(@target) with @fs->target\n *\n *\t3) realpath(@target) with realpath(@fs->target) if @fs is not from\n *\t   /proc/self/mountinfo.\n *\n *\t   However, if mnt_cache_set_targets(cache, mtab) was called, and the\n *\t   path @target or @fs->target is found in the @mtab, the canonicalization is\n *\t   is not performed (see mnt_resolve_target()).\n *\n * The 2nd and 3rd attempts are not performed when @cache is NULL.\n *\n * Returns: 1 if @fs target is equal to @target, else 0.\n */\nint mnt_fs_match_target(struct libmnt_fs *fs, const char *target,\n\t\t\tstruct libmnt_cache *cache)\n{\n\tint rc = 0;\n\n\tif (!fs || !target || !fs->target)\n\t\treturn 0;\n\n\t/* 1) native paths */\n\trc = mnt_fs_streq_target(fs, target);\n\n\tif (!rc && cache) {\n\t\t/* 2) - canonicalized and non-canonicalized */\n\t\tchar *cn = mnt_resolve_target(target, cache);\n\t\trc = (cn && mnt_fs_streq_target(fs, cn));\n\n\t\t/* 3) - canonicalized and canonicalized */\n\t\tif (!rc && cn && !mnt_fs_is_kernel(fs) && !mnt_fs_is_swaparea(fs)) {\n\t\t\tchar *tcn = mnt_resolve_target(fs->target, cache);\n\t\t\trc = (tcn && strcmp(cn, tcn) == 0);\n\t\t}\n\t}\n\n\treturn rc;\n}\n\n/**\n * mnt_fs_match_source:\n * @fs: filesystem\n * @source: tag or path (device or so) or NULL\n * @cache: tags/paths cache or NULL\n *\n * Four attempts are possible:\n *\t1) compare @source with @fs->source\n *\t2) compare realpath(@source) with @fs->source\n *\t3) compare realpath(@source) with realpath(@fs->source)\n *\t4) compare realpath(@source) with evaluated tag from @fs->source\n *\n * The 2nd, 3rd and 4th attempts are not performed when @cache is NULL. The\n * 2nd and 3rd attempts are not performed if @fs->source is tag.\n *\n * Returns: 1 if @fs source is equal to @source, else 0.\n */\nint mnt_fs_match_source(struct libmnt_fs *fs, const char *source,\n\t\t\tstruct libmnt_cache *cache)\n{\n\tchar *cn;\n\tconst char *src, *t, *v;\n\n\tif (!fs)\n\t\treturn 0;\n\n\t/* 1) native paths... */\n\tif (mnt_fs_streq_srcpath(fs, source) == 1)\n\t\treturn 1;\n\n\tif (!source || !fs->source)\n\t\treturn 0;\n\n\t/* ... and tags */\n\tif (fs->tagname && strcmp(source, fs->source) == 0)\n\t\treturn 1;\n\n\tif (!cache)\n\t\treturn 0;\n\tif (fs->flags & (MNT_FS_NET | MNT_FS_PSEUDO))\n\t\treturn 0;\n\n\tcn = mnt_resolve_spec(source, cache);\n\tif (!cn)\n\t\treturn 0;\n\n\t/* 2) canonicalized and native */\n\tsrc = mnt_fs_get_srcpath(fs);\n\tif (src && mnt_fs_streq_srcpath(fs, cn))\n\t\treturn 1;\n\n\t/* 3) canonicalized and canonicalized */\n\tif (src) {\n\t\tsrc = mnt_resolve_path(src, cache);\n\t\tif (src && !strcmp(cn, src))\n\t\t\treturn 1;\n\t}\n\tif (src || mnt_fs_get_tag(fs, &t, &v))\n\t\t/* src path does not match and the tag is not defined */\n\t\treturn 0;\n\n\t/* read @source's tags to the cache */\n\tif (mnt_cache_read_tags(cache, cn) < 0) {\n\t\tif (errno == EACCES) {\n\t\t\t/* we don't have permissions to read TAGs from\n\t\t\t * @source, but can translate the @fs tag to devname.\n\t\t\t *\n\t\t\t * (because libblkid uses udev symlinks and this is\n\t\t\t * accessible for non-root uses)\n\t\t\t */\n\t\t\tchar *x = mnt_resolve_tag(t, v, cache);\n\t\t\tif (x && !strcmp(x, cn))\n\t\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* 4) has the @source a tag that matches with the tag from @fs ? */\n\tif (mnt_cache_device_has_tag(cache, cn, t, v))\n\t\treturn 1;\n\n\treturn 0;\n}\n\n/**\n * mnt_fs_match_fstype:\n * @fs: filesystem\n * @types: filesystem name or comma delimited list of filesystems\n *\n * For more details see mnt_match_fstype().\n *\n * Returns: 1 if @fs type is matching to @types, else 0. The function returns\n * 0 when types is NULL.\n */\nint mnt_fs_match_fstype(struct libmnt_fs *fs, const char *types)\n{\n\treturn mnt_match_fstype(fs->fstype, types);\n}\n\n/**\n * mnt_fs_match_options:\n * @fs: filesystem\n * @options: comma delimited list of options (and nooptions)\n *\n * For more details see mnt_match_options().\n *\n * Returns: 1 if @fs type is matching to @options, else 0. The function returns\n * 0 when types is NULL.\n */\nint mnt_fs_match_options(struct libmnt_fs *fs, const char *options)\n{\n\treturn mnt_match_options(mnt_fs_get_options(fs), options);\n}\n\n/**\n * mnt_fs_print_debug\n * @fs: fstab/mtab/mountinfo entry\n * @file: file stream\n *\n * Returns: 0 on success or negative number in case of error.\n */\nint mnt_fs_print_debug(struct libmnt_fs *fs, FILE *file)\n{\n\tif (!fs || !file)\n\t\treturn -EINVAL;\n\tfprintf(file, \"------ fs:\\n\");\n\tfprintf(file, \"source: %s\\n\", mnt_fs_get_source(fs));\n\tfprintf(file, \"target: %s\\n\", mnt_fs_get_target(fs));\n\tfprintf(file, \"fstype: %s\\n\", mnt_fs_get_fstype(fs));\n\n\tif (mnt_fs_get_options(fs))\n\t\tfprintf(file, \"optstr: %s\\n\", mnt_fs_get_options(fs));\n\tif (mnt_fs_get_vfs_options(fs))\n\t\tfprintf(file, \"VFS-optstr: %s\\n\", mnt_fs_get_vfs_options(fs));\n\tif (mnt_fs_get_fs_options(fs))\n\t\tfprintf(file, \"FS-opstr: %s\\n\", mnt_fs_get_fs_options(fs));\n\tif (mnt_fs_get_user_options(fs))\n\t\tfprintf(file, \"user-optstr: %s\\n\", mnt_fs_get_user_options(fs));\n\tif (mnt_fs_get_optional_fields(fs))\n\t\tfprintf(file, \"optional-fields: '%s'\\n\", mnt_fs_get_optional_fields(fs));\n\tif (mnt_fs_get_attributes(fs))\n\t\tfprintf(file, \"attributes: %s\\n\", mnt_fs_get_attributes(fs));\n\n\tif (mnt_fs_get_root(fs))\n\t\tfprintf(file, \"root:   %s\\n\", mnt_fs_get_root(fs));\n\n\tif (mnt_fs_get_swaptype(fs))\n\t\tfprintf(file, \"swaptype: %s\\n\", mnt_fs_get_swaptype(fs));\n\tif (mnt_fs_get_size(fs))\n\t\tfprintf(file, \"size: %jd\\n\", mnt_fs_get_size(fs));\n\tif (mnt_fs_get_usedsize(fs))\n\t\tfprintf(file, \"usedsize: %jd\\n\", mnt_fs_get_usedsize(fs));\n\tif (mnt_fs_get_priority(fs))\n\t\tfprintf(file, \"priority: %d\\n\", mnt_fs_get_priority(fs));\n\n\tif (mnt_fs_get_bindsrc(fs))\n\t\tfprintf(file, \"bindsrc: %s\\n\", mnt_fs_get_bindsrc(fs));\n\tif (mnt_fs_get_freq(fs))\n\t\tfprintf(file, \"freq:   %d\\n\", mnt_fs_get_freq(fs));\n\tif (mnt_fs_get_passno(fs))\n\t\tfprintf(file, \"pass:   %d\\n\", mnt_fs_get_passno(fs));\n\tif (mnt_fs_get_id(fs))\n\t\tfprintf(file, \"id:     %d\\n\", mnt_fs_get_id(fs));\n\tif (mnt_fs_get_parent_id(fs))\n\t\tfprintf(file, \"parent: %d\\n\", mnt_fs_get_parent_id(fs));\n\tif (mnt_fs_get_devno(fs))\n\t\tfprintf(file, \"devno:  %d:%d\\n\", major(mnt_fs_get_devno(fs)),\n\t\t\t\t\t\tminor(mnt_fs_get_devno(fs)));\n\tif (mnt_fs_get_tid(fs))\n\t\tfprintf(file, \"tid:    %d\\n\", mnt_fs_get_tid(fs));\n\tif (mnt_fs_get_comment(fs))\n\t\tfprintf(file, \"comment: '%s'\\n\", mnt_fs_get_comment(fs));\n\n\treturn 0;\n}\n\n/**\n * mnt_free_mntent:\n * @mnt: mount entry\n *\n * Deallocates the \"mntent.h\" mount entry.\n */\nvoid mnt_free_mntent(struct mntent *mnt)\n{\n\tif (mnt) {\n\t\tfree(mnt->mnt_fsname);\n\t\tfree(mnt->mnt_dir);\n\t\tfree(mnt->mnt_type);\n\t\tfree(mnt->mnt_opts);\n\t\tfree(mnt);\n\t}\n}\n\n/**\n * mnt_fs_to_mntent:\n * @fs: filesystem\n * @mnt: mount description (as described in mntent.h)\n *\n * Copies the information from @fs to struct mntent @mnt. If @mnt is already set,\n * then the struct mntent items are reallocated and updated. See also\n * mnt_free_mntent().\n *\n * Returns: 0 on success and a negative number in case of error.\n */\nint mnt_fs_to_mntent(struct libmnt_fs *fs, struct mntent **mnt)\n{\n\tint rc;\n\tstruct mntent *m;\n\n\tif (!fs || !mnt)\n\t\treturn -EINVAL;\n\n\tm = *mnt;\n\tif (!m) {\n\t\tm = calloc(1, sizeof(*m));\n\t\tif (!m)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif ((rc = update_str(&m->mnt_fsname, mnt_fs_get_source(fs))))\n\t\tgoto err;\n\tif ((rc = update_str(&m->mnt_dir, mnt_fs_get_target(fs))))\n\t\tgoto err;\n\tif ((rc = update_str(&m->mnt_type, mnt_fs_get_fstype(fs))))\n\t\tgoto err;\n\n\terrno = 0;\n\tm->mnt_opts = mnt_fs_strdup_options(fs);\n\tif (!m->mnt_opts && errno) {\n\t\trc = -errno;\n\t\tgoto err;\n\t}\n\n\tm->mnt_freq = mnt_fs_get_freq(fs);\n\tm->mnt_passno = mnt_fs_get_passno(fs);\n\n\tif (!m->mnt_fsname) {\n\t\tm->mnt_fsname = strdup(\"none\");\n\t\tif (!m->mnt_fsname)\n\t\t\tgoto err;\n\t}\n\t*mnt = m;\n\n\treturn 0;\nerr:\n\tif (m != *mnt)\n\t\tmnt_free_mntent(m);\n\treturn rc;\n}\n", "/* SPDX-License-Identifier: LGPL-2.1-or-later */\n/*\n * libmount.h - libmount API\n *\n * This file is part of libmount from util-linux project.\n *\n * Copyright (C) 2008-2018 Karel Zak <kzak@redhat.com>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n\n#ifndef _LIBMOUNT_MOUNT_H\n#define _LIBMOUNT_MOUNT_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include <stdio.h>\n#include <mntent.h>\n#include <sys/types.h>\n\n/* Make sure libc MS_* definitions are used by default. Note that MS_* flags\n * may be already defined by linux/fs.h or another file -- in this case we\n * don't want to include sys/mount.h at all to avoid collisions.\n */\n#if defined(__linux__) && !defined(MS_RDONLY)\n# include <sys/mount.h>\n#endif\n\n#define LIBMOUNT_VERSION   \"@LIBMOUNT_VERSION@\"\n#define LIBMOUNT_MAJOR_VERSION   @LIBMOUNT_MAJOR_VERSION@\n#define LIBMOUNT_MINOR_VERSION   @LIBMOUNT_MINOR_VERSION@\n#define LIBMOUNT_PATCH_VERSION   @LIBMOUNT_PATCH_VERSION@\n\n/**\n * libmnt_cache:\n *\n * Stores canonicalized paths and evaluated tags\n */\nstruct libmnt_cache;\n\n/**\n * libmnt_lock:\n *\n * Stores information about the locked file (e.g. /etc/mtab)\n */\nstruct libmnt_lock;\n\n/**\n * libmnt_iter:\n *\n * Generic iterator (stores state about lists)\n */\nstruct libmnt_iter;\n\n/**\n * libmnt_optmap:\n * @name: option name[=type] where type is printf-like type specifier\")\n * @id: option ID or MS_* flags (e.g MS_RDONLY)\n * @mask: MNT_{NOMTAB,INVERT,...} mask\n *\n * Mount options description (map)\n */\nstruct libmnt_optmap\n{\n\tconst char\t*name;\n\tint\t\tid;\n\tint\t\tmask;\n};\n\n/*\n * mount options map masks\n */\n#define MNT_INVERT\t(1 << 1) /* invert the mountflag */\n#define MNT_NOMTAB\t(1 << 2) /* skip in the mtab option string */\n#define MNT_PREFIX\t(1 << 3) /* prefix used for some options (e.g. \"x-foo\") */\n#define MNT_NOHLPS\t(1 << 4) /* don't add the option to mount.<type> helpers command line */\n\n/**\n * libmnt_fs:\n *\n * Parsed fstab/mtab/mountinfo entry\n */\nstruct libmnt_fs;\n\n/**\n * libmnt_table:\n *\n * List of struct libmnt_fs entries (parsed fstab/mtab/mountinfo)\n */\nstruct libmnt_table;\n\n/**\n * libmnt_update\n *\n * /etc/mtab or utab update description\n */\nstruct libmnt_update;\n\n/**\n * libmnt_context\n *\n * Mount/umount status\n */\nstruct libmnt_context;\n\n/**\n * libmnt_monitor\n *\n * Mount tables monitor\n */\nstruct libmnt_monitor;\n\n/**\n * libmnt_tabdiff:\n *\n * Stores mountinfo state\n */\nstruct libmnt_tabdiff;\n\n/**\n * libmnt_ns:\n *\n * Describes mount namespace\n */\nstruct libmnt_ns;\n\n/*\n * Actions\n */\nenum {\n\tMNT_ACT_MOUNT = 1,\n\tMNT_ACT_UMOUNT\n};\n\n/*\n * Errors -- by default libmount returns -errno for generic errors (ENOMEM,\n * EINVAL, ...) and for mount(2) errors, but for some specific operations it\n * returns private error codes. Note that maximum system errno value should be\n * 4095 on UNIXes.\n *\n * See also mnt_context_get_syscall_errno() and mnt_context_get_helper_status().\n */\n/**\n * MNT_ERR_NOFSTAB:\n *\n * not found required entry in fstab\n */\n#define MNT_ERR_NOFSTAB      5000\n/**\n * MNT_ERR_NOFSTYPE:\n *\n * failed to detect filesystem type\n */\n#define MNT_ERR_NOFSTYPE     5001\n/**\n * MNT_ERR_NOSOURCE:\n *\n * required mount source undefined\n */\n#define MNT_ERR_NOSOURCE     5002\n/**\n * MNT_ERR_LOOPDEV:\n *\n * loopdev setup failed, errno set by libc\n */\n#define MNT_ERR_LOOPDEV      5003\n/**\n * MNT_ERR_MOUNTOPT:\n *\n * failed to parse/use userspace mount options\n */\n#define MNT_ERR_MOUNTOPT     5004\n/**\n * MNT_ERR_APPLYFLAGS:\n *\n * failed to apply MS_PROPAGATION flags\n */\n#define MNT_ERR_APPLYFLAGS   5005\n/**\n * MNT_ERR_AMBIFS:\n *\n * libblkid detected more filesystems on the device\n */\n#define MNT_ERR_AMBIFS       5006\n/**\n * MNT_ERR_LOOPOVERLAP:\n *\n * detected overlapping loop device that cannot be re-used\n */\n#define MNT_ERR_LOOPOVERLAP 5007\n/**\n * MNT_ERR_LOCK:\n *\n * failed to lock mtab/utab or so.\n */\n#define MNT_ERR_LOCK         5008\n/**\n * MNT_ERR_NAMESPACE:\n *\n * failed to switch namespace\n */\n#define MNT_ERR_NAMESPACE    5009\n\n\n/*\n * Overall return codes -- based on mount(8) and umount(8) return codes.\n * See mnt_context_get_excode() for more details.\n */\n\n/**\n * MNT_EX_SUCCESS:\n *\n * [u]mount(8) exit code: no errors\n */\n#define MNT_EX_SUCCESS\t0\n\n/**\n * MNT_EX_USAGE:\n *\n * [u]mount(8) exit code: incorrect invocation or permission\n */\n#define MNT_EX_USAGE\t1\n\n/**\n * MNT_EX_SYSERR:\n *\n * [u]mount(8) exit code: out of memory, cannot fork, ...\n */\n\n#define MNT_EX_SYSERR\t2\n\n/**\n * MNT_EX_SOFTWARE:\n *\n * [u]mount(8) exit code: internal mount bug or wrong version\n */\n#define MNT_EX_SOFTWARE\t4\n\n/**\n * MNT_EX_USER:\n *\n * [u]mount(8) exit code: user interrupt\n */\n#define MNT_EX_USER\t8\n\n/**\n * MNT_EX_FILEIO:\n *\n * [u]mount(8) exit code: problems writing, locking, ... mtab/utab\n */\n#define MNT_EX_FILEIO\t16\n\n/**\n * MNT_EX_FAIL:\n *\n * [u]mount(8) exit code: mount failure\n */\n#define MNT_EX_FAIL\t32\n\n/**\n * MNT_EX_SOMEOK:\n *\n * [u]mount(8) exit code: some mount succeeded; usually when executed with\n * --all options. Never returned by libmount.\n */\n#define MNT_EX_SOMEOK\t64\n\n\n\n#ifndef __GNUC_PREREQ\n# if defined __GNUC__ && defined __GNUC_MINOR__\n#  define __GNUC_PREREQ(maj, min)  ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((maj) << 16) + (min))\n# else\n#  define __GNUC_PREREQ(maj, min) 0\n# endif\n#endif\n\n#ifndef __ul_attribute__\n# if __GNUC_PREREQ (3, 4)\n#  define __ul_attribute__(_a_) __attribute__(_a_)\n# else\n#  define __ul_attribute__(_a_)\n# endif\n#endif\n\n\n/* init.c */\nextern void mnt_init_debug(int mask);\n\n/* version.c */\nextern int mnt_parse_version_string(const char *ver_string);\nextern int mnt_get_library_version(const char **ver_string);\nextern int mnt_get_library_features(const char ***features);\n\n/* utils.c */\nextern char *mnt_mangle(const char *str)\n\t\t\t__ul_attribute__((warn_unused_result));\nextern char *mnt_unmangle(const char *str)\n\t\t\t__ul_attribute__((warn_unused_result));\n\nextern int mnt_tag_is_valid(const char *tag);\nextern int mnt_fstype_is_netfs(const char *type);\nextern int mnt_fstype_is_pseudofs(const char *type);\n\nextern int mnt_match_fstype(const char *type, const char *pattern)\n\t\t\t__ul_attribute__((warn_unused_result));\nextern int mnt_match_options(const char *optstr, const char *pattern)\n\t\t\t__ul_attribute__((warn_unused_result));\nextern const char *mnt_get_fstab_path(void);\nextern const char *mnt_get_swaps_path(void);\nextern const char *mnt_get_mtab_path(void);\nextern int mnt_has_regular_mtab(const char **mtab, int *writable);\nextern char *mnt_get_mountpoint(const char *path)\n\t\t\t__ul_attribute__((warn_unused_result));\nextern int mnt_guess_system_root(dev_t devno, struct libmnt_cache *cache, char **path)\n\t\t\t__ul_attribute__((nonnull(3)));\n\n/* cache.c */\nextern struct libmnt_cache *mnt_new_cache(void)\n\t\t\t__ul_attribute__((warn_unused_result));\nextern void mnt_free_cache(struct libmnt_cache *cache);\n\nextern void mnt_ref_cache(struct libmnt_cache *cache);\nextern void mnt_unref_cache(struct libmnt_cache *cache);\n\nextern int mnt_cache_set_targets(struct libmnt_cache *cache,\n\t\t\t\tstruct libmnt_table *mtab);\nextern int mnt_cache_read_tags(struct libmnt_cache *cache, const char *devname);\n\nextern int mnt_cache_device_has_tag(struct libmnt_cache *cache,\n\t\t\t\tconst char *devname,\n                                const char *token,\n\t\t\t\tconst char *value);\n\nextern char *mnt_cache_find_tag_value(struct libmnt_cache *cache,\n\t\t\t\tconst char *devname, const char *token);\n\nextern char *mnt_get_fstype(const char *devname, int *ambi,\n\t\t\t    struct libmnt_cache *cache)\n\t\t\t__ul_attribute__((warn_unused_result));\nextern char *mnt_resolve_path(const char *path, struct libmnt_cache *cache)\n\t\t\t__ul_attribute__((warn_unused_result));\nextern char *mnt_resolve_target(const char *path, struct libmnt_cache *cache)\n\t\t\t__ul_attribute__((warn_unused_result));\nextern char *mnt_resolve_tag(const char *token, const char *value,\n\t\t\t     struct libmnt_cache *cache)\n\t\t\t__ul_attribute__((warn_unused_result));\nextern char *mnt_resolve_spec(const char *spec, struct libmnt_cache *cache)\n\t\t\t__ul_attribute__((warn_unused_result));\nextern char *mnt_pretty_path(const char *path, struct libmnt_cache *cache)\n\t\t\t__ul_attribute__((warn_unused_result));\n\n/* optstr.c */\nextern int mnt_optstr_next_option(char **optstr, char **name, size_t *namesz,\n\t\t\t\tchar **value, size_t *valuesz);\nextern int mnt_optstr_append_option(char **optstr, const char *name,\n\t\t\t\tconst char *value);\nextern int mnt_optstr_prepend_option(char **optstr, const char *name,\n\t\t\t\tconst char *value);\n\nextern int mnt_optstr_get_option(const char *optstr, const char *name,\n\t\t\t\tchar **value, size_t *valsz);\nextern int mnt_optstr_set_option(char **optstr, const char *name,\n\t\t\t\tconst char *value);\nextern int mnt_optstr_remove_option(char **optstr, const char *name);\nextern int mnt_optstr_deduplicate_option(char **optstr, const char *name);\n\nextern int mnt_split_optstr(const char *optstr,\n\t\t\t    char **user, char **vfs, char **fs,\n\t\t\t    int ignore_user, int ignore_vfs);\n\nextern int mnt_optstr_get_options(const char *optstr, char **subset,\n                            const struct libmnt_optmap *map, int ignore);\n\nextern int mnt_optstr_get_flags(const char *optstr, unsigned long *flags,\n\t\t\t\tconst struct libmnt_optmap *map);\n\nextern int mnt_optstr_apply_flags(char **optstr, unsigned long flags,\n                                const struct libmnt_optmap *map);\n\n/* iter.c */\nenum {\n\n\tMNT_ITER_FORWARD = 0,\n\tMNT_ITER_BACKWARD\n};\nextern struct libmnt_iter *mnt_new_iter(int direction)\n\t\t\t__ul_attribute__((warn_unused_result));\nextern void mnt_free_iter(struct libmnt_iter *itr);\n\nextern void mnt_reset_iter(struct libmnt_iter *itr, int direction)\n\t\t\t__ul_attribute__((nonnull));\nextern int mnt_iter_get_direction(struct libmnt_iter *itr)\n\t\t\t__ul_attribute__((nonnull));\n\n/* optmap.c */\nenum {\n\tMNT_LINUX_MAP = 1,\n\tMNT_USERSPACE_MAP\n};\nextern const struct libmnt_optmap *mnt_get_builtin_optmap(int id);\n\n/* lock.c */\nextern struct libmnt_lock *mnt_new_lock(const char *datafile, pid_t id)\n\t\t\t__ul_attribute__((warn_unused_result));\nextern void mnt_free_lock(struct libmnt_lock *ml);\n\nextern void mnt_unlock_file(struct libmnt_lock *ml);\nextern int mnt_lock_file(struct libmnt_lock *ml);\nextern int mnt_lock_block_signals(struct libmnt_lock *ml, int enable);\n\n/* fs.c */\nextern struct libmnt_fs *mnt_new_fs(void)\n\t\t\t__ul_attribute__((warn_unused_result));\nextern void mnt_free_fs(struct libmnt_fs *fs);\nextern void mnt_ref_fs(struct libmnt_fs *fs);\nextern void mnt_unref_fs(struct libmnt_fs *fs);\n\nextern void mnt_reset_fs(struct libmnt_fs *fs);\nextern struct libmnt_fs *mnt_copy_fs(struct libmnt_fs *dest,\n\t\t\t\t     const struct libmnt_fs *src)\n\t\t\t__ul_attribute__((warn_unused_result));\nextern void *mnt_fs_get_userdata(struct libmnt_fs *fs);\nextern int mnt_fs_set_userdata(struct libmnt_fs *fs, void *data);\nextern const char *mnt_fs_get_source(struct libmnt_fs *fs);\nextern int mnt_fs_set_source(struct libmnt_fs *fs, const char *source);\nextern const char *mnt_fs_get_srcpath(struct libmnt_fs *fs);\nextern int mnt_fs_get_table(struct libmnt_fs *fs, struct libmnt_table **tb);\n\nextern int mnt_fs_get_tag(struct libmnt_fs *fs, const char **name,\n\t\t\t  const char **value);\nextern const char *mnt_fs_get_target(struct libmnt_fs *fs);\nextern int mnt_fs_set_target(struct libmnt_fs *fs, const char *tgt);\nextern const char *mnt_fs_get_fstype(struct libmnt_fs *fs);\nextern int mnt_fs_set_fstype(struct libmnt_fs *fs, const char *fstype);\n\nextern int mnt_fs_streq_srcpath(struct libmnt_fs *fs, const char *path)\n\t\t\t__ul_attribute__((warn_unused_result));\nextern int mnt_fs_streq_target(struct libmnt_fs *fs, const char *path)\n\t\t\t__ul_attribute__((warn_unused_result));\n\nextern char *mnt_fs_strdup_options(struct libmnt_fs *fs)\n\t\t\t__ul_attribute__((warn_unused_result));\nextern const char *mnt_fs_get_options(struct libmnt_fs *fs)\n\t\t\t__ul_attribute__((warn_unused_result));\nextern const char *mnt_fs_get_optional_fields(struct libmnt_fs *fs)\n\t\t\t__ul_attribute__((warn_unused_result));\nextern int mnt_fs_get_propagation(struct libmnt_fs *fs, unsigned long *flags);\n\nextern int mnt_fs_set_options(struct libmnt_fs *fs, const char *optstr);\nextern int mnt_fs_append_options(struct libmnt_fs *fs, const char *optstr);\nextern int mnt_fs_prepend_options(struct libmnt_fs *fs, const char *optstr);\n\nextern int mnt_fs_get_option(struct libmnt_fs *fs, const char *name,\n\t\t\t\tchar **value, size_t *valsz);\n\nextern const char *mnt_fs_get_fs_options(struct libmnt_fs *fs);\nextern const char *mnt_fs_get_vfs_options(struct libmnt_fs *fs);\nextern const char *mnt_fs_get_user_options(struct libmnt_fs *fs);\nextern char *mnt_fs_get_vfs_options_all(struct libmnt_fs *fs);\n\nextern const char *mnt_fs_get_attributes(struct libmnt_fs *fs);\nextern int mnt_fs_set_attributes(struct libmnt_fs *fs, const char *optstr);\nextern int mnt_fs_get_attribute(struct libmnt_fs *fs, const char *name,\n\t\t\t\tchar **value, size_t *valsz);\nextern int mnt_fs_append_attributes(struct libmnt_fs *fs, const char *optstr);\nextern int mnt_fs_prepend_attributes(struct libmnt_fs *fs, const char *optstr);\n\nextern int mnt_fs_get_freq(struct libmnt_fs *fs);\nextern int mnt_fs_set_freq(struct libmnt_fs *fs, int freq);\nextern int mnt_fs_get_passno(struct libmnt_fs *fs);\nextern int mnt_fs_set_passno(struct libmnt_fs *fs, int passno);\nextern const char *mnt_fs_get_root(struct libmnt_fs *fs);\nextern int mnt_fs_set_root(struct libmnt_fs *fs, const char *path);\nextern const char *mnt_fs_get_bindsrc(struct libmnt_fs *fs);\nextern int mnt_fs_set_bindsrc(struct libmnt_fs *fs, const char *src);\nextern int mnt_fs_get_id(struct libmnt_fs *fs);\nextern int mnt_fs_get_parent_id(struct libmnt_fs *fs);\nextern dev_t mnt_fs_get_devno(struct libmnt_fs *fs);\nextern pid_t mnt_fs_get_tid(struct libmnt_fs *fs);\n\nextern const char *mnt_fs_get_swaptype(struct libmnt_fs *fs);\nextern off_t mnt_fs_get_size(struct libmnt_fs *fs);\nextern off_t mnt_fs_get_usedsize(struct libmnt_fs *fs);\nextern int mnt_fs_get_priority(struct libmnt_fs *fs);\nextern int mnt_fs_set_priority(struct libmnt_fs *fs, int prio);\n\nextern const char *mnt_fs_get_comment(struct libmnt_fs *fs);\nextern int mnt_fs_set_comment(struct libmnt_fs *fs, const char *comm);\nextern int mnt_fs_append_comment(struct libmnt_fs *fs, const char *comm);\n\nextern int mnt_fs_match_target(struct libmnt_fs *fs, const char *target,\n\t\t\t       struct libmnt_cache *cache);\nextern int mnt_fs_match_source(struct libmnt_fs *fs, const char *source,\n\t\t\t       struct libmnt_cache *cache);\nextern int mnt_fs_match_fstype(struct libmnt_fs *fs, const char *types);\nextern int mnt_fs_match_options(struct libmnt_fs *fs, const char *options);\nextern int mnt_fs_print_debug(struct libmnt_fs *fs, FILE *file);\n\nextern int mnt_fs_is_kernel(struct libmnt_fs *fs);\nextern int mnt_fs_is_deleted(struct libmnt_fs *fs);\nextern int mnt_fs_is_swaparea(struct libmnt_fs *fs);\nextern int mnt_fs_is_netfs(struct libmnt_fs *fs);\nextern int mnt_fs_is_pseudofs(struct libmnt_fs *fs);\nextern int mnt_fs_is_regularfs(struct libmnt_fs *fs);\n\nextern void mnt_free_mntent(struct mntent *mnt);\nextern int mnt_fs_to_mntent(struct libmnt_fs *fs, struct mntent **mnt);\n\n/* tab-parse.c */\nextern struct libmnt_table *mnt_new_table_from_file(const char *filename)\n\t\t\t__ul_attribute__((warn_unused_result));\nextern struct libmnt_table *mnt_new_table_from_dir(const char *dirname)\n\t\t\t__ul_attribute__((warn_unused_result));\nextern int mnt_table_parse_stream(struct libmnt_table *tb, FILE *f,\n\t\t\t\t  const char *filename);\nextern int mnt_table_parse_file(struct libmnt_table *tb, const char *filename);\nextern int mnt_table_parse_dir(struct libmnt_table *tb, const char *dirname);\n\nextern int mnt_table_parse_fstab(struct libmnt_table *tb, const char *filename);\nextern int mnt_table_parse_swaps(struct libmnt_table *tb, const char *filename);\nextern int mnt_table_parse_mtab(struct libmnt_table *tb, const char *filename);\nextern int mnt_table_set_parser_errcb(struct libmnt_table *tb,\n                int (*cb)(struct libmnt_table *tb, const char *filename, int line));\n\n/* tab.c */\nextern struct libmnt_table *mnt_new_table(void)\n\t\t\t__ul_attribute__((warn_unused_result));\nextern void mnt_free_table(struct libmnt_table *tb);\n\nextern void mnt_ref_table(struct libmnt_table *tb);\nextern void mnt_unref_table(struct libmnt_table *tb);\n\nextern int mnt_reset_table(struct libmnt_table *tb);\nextern int mnt_table_get_nents(struct libmnt_table *tb);\nextern int mnt_table_is_empty(struct libmnt_table *tb);\n\nextern int mnt_table_set_userdata(struct libmnt_table *tb, void *data);\nextern void *mnt_table_get_userdata(struct libmnt_table *tb);\n\nextern void mnt_table_enable_comments(struct libmnt_table *tb, int enable);\nextern int mnt_table_with_comments(struct libmnt_table *tb);\nextern const char *mnt_table_get_intro_comment(struct libmnt_table *tb);\nextern int mnt_table_set_intro_comment(struct libmnt_table *tb, const char *comm);\nextern int mnt_table_append_intro_comment(struct libmnt_table *tb, const char *comm);\nextern int mnt_table_set_trailing_comment(struct libmnt_table *tb, const char *comm);\nextern const char *mnt_table_get_trailing_comment(struct libmnt_table *tb);\nextern int mnt_table_append_trailing_comment(struct libmnt_table *tb, const char *comm);\n\nextern int mnt_table_set_cache(struct libmnt_table *tb, struct libmnt_cache *mpc);\nextern struct libmnt_cache *mnt_table_get_cache(struct libmnt_table *tb);\nextern int mnt_table_add_fs(struct libmnt_table *tb, struct libmnt_fs *fs);\nextern int mnt_table_find_fs(struct libmnt_table *tb, struct libmnt_fs *fs);\nextern int mnt_table_insert_fs(struct libmnt_table *tb, int before,\n\t\t\t\tstruct libmnt_fs *pos, struct libmnt_fs *fs);\nextern int mnt_table_move_fs(struct libmnt_table *src, struct libmnt_table *dst,\n                      int before, struct libmnt_fs *pos, struct libmnt_fs *fs);\nextern int mnt_table_remove_fs(struct libmnt_table *tb, struct libmnt_fs *fs);\nextern int mnt_table_first_fs(struct libmnt_table *tb, struct libmnt_fs **fs);\nextern int mnt_table_last_fs(struct libmnt_table *tb, struct libmnt_fs **fs);\nextern int mnt_table_over_fs(struct libmnt_table *tb, struct libmnt_fs *parent,\n                             struct libmnt_fs **child);\nextern int mnt_table_next_fs(struct libmnt_table *tb, struct libmnt_iter *itr,\n\t\t\t     struct libmnt_fs **fs);\nextern int mnt_table_next_child_fs(struct libmnt_table *tb, struct libmnt_iter *itr,\n\t                        struct libmnt_fs *parent, struct libmnt_fs **chld);\nextern int mnt_table_get_root_fs(struct libmnt_table *tb, struct libmnt_fs **root);\nextern int mnt_table_set_iter(struct libmnt_table *tb, struct libmnt_iter *itr,\n\t\t\t      struct libmnt_fs *fs);\n\nenum {\n\tMNT_UNIQ_FORWARD  = (1 << 1),\t/* default is backward */\n\tMNT_UNIQ_KEEPTREE = (1 << 2)\n};\nextern int mnt_table_uniq_fs(struct libmnt_table *tb, int flags,\n\t\t\t\tint (*cmp)(struct libmnt_table *,\n\t\t\t\t\t   struct libmnt_fs *,\n\t\t\t\t\t   struct libmnt_fs *));\n\nextern struct libmnt_fs *mnt_table_find_mountpoint(struct libmnt_table *tb,\n\t\t\t\tconst char *path, int direction);\nextern struct libmnt_fs *mnt_table_find_target(struct libmnt_table *tb,\n\t\t\t\tconst char *path, int direction);\nextern struct libmnt_fs *mnt_table_find_srcpath(struct libmnt_table *tb,\n\t\t\t\tconst char *path, int direction);\nextern struct libmnt_fs *mnt_table_find_tag(struct libmnt_table *tb, const char *tag,\n\t\t\t\tconst char *val, int direction);\nextern struct libmnt_fs *mnt_table_find_target_with_option(struct libmnt_table *tb, const char *path,\n\t\t\tconst char *option, const char *val, int direction);\nextern struct libmnt_fs *mnt_table_find_source(struct libmnt_table *tb,\n\t\t\t\tconst char *source, int direction);\nextern struct libmnt_fs *mnt_table_find_pair(struct libmnt_table *tb,\n\t\t\t\tconst char *source,\n\t\t\t\tconst char *target, int direction);\nextern struct libmnt_fs *mnt_table_find_devno(struct libmnt_table *tb,\n\t\t\t\tdev_t devno, int direction);\n\nextern int mnt_table_find_next_fs(struct libmnt_table *tb,\n\t\t\tstruct libmnt_iter *itr,\n\t\t\tint (*match_func)(struct libmnt_fs *, void *),\n\t\t\tvoid *userdata,\n\t\t        struct libmnt_fs **fs);\n\nextern int mnt_table_is_fs_mounted(struct libmnt_table *tb, struct libmnt_fs *fstab_fs);\n\n/* tab_update.c */\nextern struct libmnt_update *mnt_new_update(void)\n\t\t\t__ul_attribute__((warn_unused_result));\nextern void mnt_free_update(struct libmnt_update *upd);\n\nextern int mnt_table_replace_file(struct libmnt_table *tb, const char *filename);\nextern int mnt_table_write_file(struct libmnt_table *tb, FILE *file);\n\nextern int mnt_update_is_ready(struct libmnt_update *upd);\nextern int mnt_update_set_fs(struct libmnt_update *upd, unsigned long mountflags,\n\t                      const char *target, struct libmnt_fs *fs);\nextern int mnt_update_table(struct libmnt_update *upd, struct libmnt_lock *lc);\nextern unsigned long mnt_update_get_mflags(struct libmnt_update *upd);\nextern int mnt_update_force_rdonly(struct libmnt_update *upd, int rdonly);\nextern const char *mnt_update_get_filename(struct libmnt_update *upd);\nextern struct libmnt_fs *mnt_update_get_fs(struct libmnt_update *upd);\n\n/* tab_diff.c */\nenum {\n\tMNT_TABDIFF_MOUNT = 1,\n\tMNT_TABDIFF_UMOUNT,\n\tMNT_TABDIFF_MOVE,\n\tMNT_TABDIFF_REMOUNT,\n\tMNT_TABDIFF_PROPAGATION,\t/* not implemented yet (TODO) */\n};\n\nextern struct libmnt_tabdiff *mnt_new_tabdiff(void)\n\t\t\t__ul_attribute__((warn_unused_result));\nextern void mnt_free_tabdiff(struct libmnt_tabdiff *df);\n\nextern int mnt_diff_tables(struct libmnt_tabdiff *df,\n\t\t\t   struct libmnt_table *old_tab,\n\t\t\t   struct libmnt_table *new_tab);\n\nextern int mnt_tabdiff_next_change(struct libmnt_tabdiff *df,\n\t\t\t\t   struct libmnt_iter *itr,\n\t\t\t\t   struct libmnt_fs **old_fs,\n\t\t\t\t   struct libmnt_fs **new_fs,\n\t\t\t\t   int *oper);\n\n/* monitor.c */\nenum {\n\tMNT_MONITOR_TYPE_USERSPACE = 1,\t/* userspace mount options */\n\tMNT_MONITOR_TYPE_KERNEL\t\t/* kernel mount table */\n};\n\nextern struct libmnt_monitor *mnt_new_monitor(void);\nextern void mnt_ref_monitor(struct libmnt_monitor *mn);\nextern void mnt_unref_monitor(struct libmnt_monitor *mn);\n\nextern int mnt_monitor_enable_kernel(struct libmnt_monitor *mn, int enable);\nextern int mnt_monitor_enable_userspace(struct libmnt_monitor *mn,\n\t\t\t\tint enable, const char *filename);\n\nextern int mnt_monitor_get_fd(struct libmnt_monitor *mn);\nextern int mnt_monitor_close_fd(struct libmnt_monitor *mn);\nextern int mnt_monitor_wait(struct libmnt_monitor *mn, int timeout);\n\nextern int mnt_monitor_next_change(struct libmnt_monitor *mn,\n\t\t\t     const char **filename, int *type);\nextern int mnt_monitor_event_cleanup(struct libmnt_monitor *mn);\n\n\n/* context.c */\n\n/*\n * Mode for mount options from fstab (or mtab), see mnt_context_set_optsmode().\n */\nenum {\n\tMNT_OMODE_IGNORE  = (1 << 1),\t/* ignore mtab/fstab options */\n\tMNT_OMODE_APPEND  = (1 << 2),\t/* append mtab/fstab options to existing options */\n\tMNT_OMODE_PREPEND = (1 << 3),\t/* prepend mtab/fstab options to existing options */\n\tMNT_OMODE_REPLACE = (1 << 4),\t/* replace existing options with options from mtab/fstab */\n\n\tMNT_OMODE_FORCE   = (1 << 5),   /* always read mtab/fstab options */\n\n\tMNT_OMODE_FSTAB   = (1 << 10),\t/* read from fstab */\n\tMNT_OMODE_MTAB    = (1 << 11),\t/* read from mtab if fstab not enabled or failed */\n\tMNT_OMODE_NOTAB   = (1 << 12),\t/* do not read fstab/mtab at all */\n\n\t/* default */\n\tMNT_OMODE_AUTO   = (MNT_OMODE_PREPEND | MNT_OMODE_FSTAB | MNT_OMODE_MTAB),\n\t/* non-root users */\n\tMNT_OMODE_USER   = (MNT_OMODE_REPLACE | MNT_OMODE_FORCE | MNT_OMODE_FSTAB)\n};\n\nextern struct libmnt_context *mnt_new_context(void)\n\t\t\t__ul_attribute__((warn_unused_result));\nextern void mnt_free_context(struct libmnt_context *cxt);\n\nextern int mnt_reset_context(struct libmnt_context *cxt);\nextern int mnt_context_is_restricted(struct libmnt_context *cxt)\n\t\t\t__ul_attribute__((nonnull));\nextern int mnt_context_force_unrestricted(struct libmnt_context *cxt);\n\nextern int mnt_context_init_helper(struct libmnt_context *cxt,\n\t\t\t\t   int action, int flags);\nextern int mnt_context_helper_setopt(struct libmnt_context *cxt, int c, char *arg);\n\nextern int mnt_context_set_optsmode(struct libmnt_context *cxt, int mode);\nextern int mnt_context_disable_canonicalize(struct libmnt_context *cxt, int disable);\nextern int mnt_context_enable_lazy(struct libmnt_context *cxt, int enable);\nextern int mnt_context_enable_rdonly_umount(struct libmnt_context *cxt, int enable);\nextern int mnt_context_enable_rwonly_mount(struct libmnt_context *cxt, int enable);\nextern int mnt_context_disable_helpers(struct libmnt_context *cxt, int disable);\nextern int mnt_context_enable_sloppy(struct libmnt_context *cxt, int enable);\nextern int mnt_context_enable_fake(struct libmnt_context *cxt, int enable);\nextern int mnt_context_disable_mtab(struct libmnt_context *cxt, int disable);\nextern int mnt_context_enable_force(struct libmnt_context *cxt, int enable);\nextern int mnt_context_enable_verbose(struct libmnt_context *cxt, int enable);\nextern int mnt_context_enable_loopdel(struct libmnt_context *cxt, int enable);\nextern int mnt_context_enable_fork(struct libmnt_context *cxt, int enable);\nextern int mnt_context_disable_swapmatch(struct libmnt_context *cxt, int disable);\n\nextern int mnt_context_get_optsmode(struct libmnt_context *cxt);\n\nextern int mnt_context_is_lazy(struct libmnt_context *cxt)\n\t\t\t__ul_attribute__((nonnull));\nextern int mnt_context_is_rdonly_umount(struct libmnt_context *cxt)\n\t\t\t__ul_attribute__((nonnull));\nextern int mnt_context_is_rwonly_mount(struct libmnt_context *cxt)\n\t\t\t__ul_attribute__((nonnull));\nextern int mnt_context_is_sloppy(struct libmnt_context *cxt)\n\t\t\t__ul_attribute__((nonnull));\nextern int mnt_context_is_fake(struct libmnt_context *cxt)\n\t\t\t__ul_attribute__((nonnull));\nextern int mnt_context_is_nomtab(struct libmnt_context *cxt)\n\t\t\t__ul_attribute__((nonnull));\nextern int mnt_context_is_force(struct libmnt_context *cxt)\n\t\t\t__ul_attribute__((nonnull));\nextern int mnt_context_is_verbose(struct libmnt_context *cxt)\n\t\t\t__ul_attribute__((nonnull));\nextern int mnt_context_is_loopdel(struct libmnt_context *cxt)\n\t\t\t__ul_attribute__((nonnull));\nextern int mnt_context_is_nohelpers(struct libmnt_context *cxt)\n\t\t\t__ul_attribute__((nonnull));\nextern int mnt_context_is_nocanonicalize(struct libmnt_context *cxt)\n\t\t\t__ul_attribute__((nonnull));\nextern int mnt_context_is_swapmatch(struct libmnt_context *cxt)\n\t\t\t__ul_attribute__((nonnull));\nextern int mnt_context_forced_rdonly(struct libmnt_context *cxt)\n\t\t\t__ul_attribute__((nonnull));\n\nextern int mnt_context_is_fork(struct libmnt_context *cxt)\n\t\t\t__ul_attribute__((nonnull));\nextern int mnt_context_is_parent(struct libmnt_context *cxt)\n\t\t\t__ul_attribute__((nonnull));\nextern int mnt_context_is_child(struct libmnt_context *cxt)\n\t\t\t__ul_attribute__((nonnull));\n\nextern int mnt_context_wait_for_children(struct libmnt_context *cxt,\n                                  int *nchildren, int *nerrs);\n\nextern int mnt_context_is_fs_mounted(struct libmnt_context *cxt,\n                              struct libmnt_fs *fs, int *mounted);\nextern int mnt_context_set_fs(struct libmnt_context *cxt, struct libmnt_fs *fs);\nextern struct libmnt_fs *mnt_context_get_fs(struct libmnt_context *cxt);\n\nextern int mnt_context_set_source(struct libmnt_context *cxt, const char *source);\nextern int mnt_context_set_target(struct libmnt_context *cxt, const char *target);\nextern int mnt_context_set_fstype(struct libmnt_context *cxt, const char *fstype);\nextern int mnt_context_set_target_prefix(struct libmnt_context *cxt, const char *path);\n\nextern const char *mnt_context_get_source(struct libmnt_context *cxt);\nextern const char *mnt_context_get_target(struct libmnt_context *cxt);\nextern const char *mnt_context_get_fstype(struct libmnt_context *cxt);\nextern const char *mnt_context_get_target_prefix(struct libmnt_context *cxt);\n\nextern void *mnt_context_get_mtab_userdata(struct libmnt_context *cxt);\nextern void *mnt_context_get_fstab_userdata(struct libmnt_context *cxt);\nextern void *mnt_context_get_fs_userdata(struct libmnt_context *cxt);\n\nextern int mnt_context_set_options(struct libmnt_context *cxt, const char *optstr);\nextern int mnt_context_append_options(struct libmnt_context *cxt, const char *optstr);\n\nextern const char *mnt_context_get_options(struct libmnt_context *cxt);\n\nextern int mnt_context_set_fstype_pattern(struct libmnt_context *cxt, const char *pattern);\nextern int mnt_context_set_options_pattern(struct libmnt_context *cxt, const char *pattern);\n\nextern int mnt_context_set_passwd_cb(struct libmnt_context *cxt,\n\t\t\t      char *(*get)(struct libmnt_context *),\n\t\t\t      void (*release)(struct libmnt_context *, char *))\n\t\t\t__ul_attribute__((deprecated));\n\nextern int mnt_context_set_tables_errcb(struct libmnt_context *cxt,\n        int (*cb)(struct libmnt_table *tb, const char *filename, int line));\nextern int mnt_context_set_fstab(struct libmnt_context *cxt,\n\t\t\t\t struct libmnt_table *tb);\nextern int mnt_context_get_fstab(struct libmnt_context *cxt,\n\t\t\t\t struct libmnt_table **tb);\n\nextern int mnt_context_get_mtab(struct libmnt_context *cxt,\n\t\t\t\tstruct libmnt_table **tb);\nextern int mnt_context_get_table(struct libmnt_context *cxt,\n\t\t\t\tconst char *filename,\n\t\t\t\tstruct libmnt_table **tb);\nextern int mnt_context_set_cache(struct libmnt_context *cxt,\n\t\t\t\t struct libmnt_cache *cache);\nextern struct libmnt_cache *mnt_context_get_cache(struct libmnt_context *cxt);\nextern struct libmnt_lock *mnt_context_get_lock(struct libmnt_context *cxt);\nextern int mnt_context_set_mflags(struct libmnt_context *cxt,\n\t\t\t\t      unsigned long flags);\nextern int mnt_context_get_mflags(struct libmnt_context *cxt,\n\t\t\t\t      unsigned long *flags);\nextern int mnt_context_set_user_mflags(struct libmnt_context *cxt,\n\t\t\t\t\t\tunsigned long flags);\nextern int mnt_context_get_user_mflags(struct libmnt_context *cxt,\n\t\t\t\t\t\tunsigned long *flags);\n\nextern int mnt_context_set_mountdata(struct libmnt_context *cxt, void *data);\nextern int mnt_context_apply_fstab(struct libmnt_context *cxt);\n\nextern int mnt_context_reset_status(struct libmnt_context *cxt);\nextern int mnt_context_get_status(struct libmnt_context *cxt);\n\nextern int mnt_context_helper_executed(struct libmnt_context *cxt);\nextern int mnt_context_get_helper_status(struct libmnt_context *cxt);\n\nextern int mnt_context_syscall_called(struct libmnt_context *cxt);\n\nextern int mnt_context_get_syscall_errno(struct libmnt_context *cxt);\n\nextern int mnt_context_strerror(struct libmnt_context *cxt, char *buf,\n\t\t\t\tsize_t bufsiz)\n\t\t\t\t__ul_attribute__((deprecated));\n\nextern int mnt_context_get_excode(struct libmnt_context *cxt,\n                        int rc, char *buf, size_t bufsz);\n\nextern int mnt_context_set_target_ns(struct libmnt_context *cxt, const char *path);\nextern struct libmnt_ns *mnt_context_get_target_ns(struct libmnt_context *cxt);\nextern struct libmnt_ns *mnt_context_get_origin_ns(struct libmnt_context *cxt);\nextern struct libmnt_ns *mnt_context_switch_ns(struct libmnt_context *cxt, struct libmnt_ns *ns);\nextern struct libmnt_ns *mnt_context_switch_origin_ns(struct libmnt_context *cxt);\nextern struct libmnt_ns *mnt_context_switch_target_ns(struct libmnt_context *cxt);\n\n\n/* context_mount.c */\nextern int mnt_context_mount(struct libmnt_context *cxt);\nextern int mnt_context_umount(struct libmnt_context *cxt);\nextern int mnt_context_next_mount(struct libmnt_context *cxt,\n\t\t\t\tstruct libmnt_iter *itr,\n\t\t\t\tstruct libmnt_fs **fs,\n\t\t\t\tint *mntrc, int *ignored);\n\nextern int mnt_context_next_remount(struct libmnt_context *cxt,\n                           struct libmnt_iter *itr,\n                           struct libmnt_fs **fs,\n                           int *mntrc,\n                           int *ignored);\n\nextern int mnt_context_prepare_mount(struct libmnt_context *cxt)\n\t\t\t__ul_attribute__((warn_unused_result));\nextern int mnt_context_do_mount(struct libmnt_context *cxt);\nextern int mnt_context_finalize_mount(struct libmnt_context *cxt);\n\n/* context_umount.c */\nextern int mnt_context_find_umount_fs(struct libmnt_context *cxt,\n\t\t\t       const char *tgt,\n\t\t\t       struct libmnt_fs **pfs);\nextern int mnt_context_next_umount(struct libmnt_context *cxt,\n\t\t\t\tstruct libmnt_iter *itr,\n\t\t\t\tstruct libmnt_fs **fs,\n\t\t\t\tint *mntrc, int *ignored);\n\nextern int mnt_context_prepare_umount(struct libmnt_context *cxt)\n\t\t\t__ul_attribute__((warn_unused_result));\nextern int mnt_context_do_umount(struct libmnt_context *cxt);\nextern int mnt_context_finalize_umount(struct libmnt_context *cxt);\n\nextern int mnt_context_tab_applied(struct libmnt_context *cxt);\nextern int mnt_context_set_syscall_status(struct libmnt_context *cxt, int status);\n\n/*\n * mount(8) userspace options masks (MNT_MAP_USERSPACE map)\n */\n#define MNT_MS_NOAUTO\t(1 << 2)\n#define MNT_MS_USER\t(1 << 3)\n#define MNT_MS_USERS\t(1 << 4)\n#define MNT_MS_OWNER\t(1 << 5)\n#define MNT_MS_GROUP\t(1 << 6)\n#define MNT_MS_NETDEV\t(1 << 7)\n#define MNT_MS_COMMENT  (1 << 8)\n#define MNT_MS_LOOP     (1 << 9)\n#define MNT_MS_NOFAIL   (1 << 10)\n#define MNT_MS_UHELPER  (1 << 11)\n#define MNT_MS_HELPER   (1 << 12)\n#define MNT_MS_XCOMMENT (1 << 13)\n#define MNT_MS_OFFSET   (1 << 14)\n#define MNT_MS_SIZELIMIT (1 << 15)\n#define MNT_MS_ENCRYPTION (1 << 16)\n#define MNT_MS_XFSTABCOMM (1 << 17)\n#define MNT_MS_HASH_DEVICE (1 << 18)\n#define MNT_MS_ROOT_HASH (1 << 19)\n#define MNT_MS_HASH_OFFSET (1 << 20)\n#define MNT_MS_ROOT_HASH_FILE (1 << 21)\n#define MNT_MS_FEC_DEVICE (1 << 22)\n#define MNT_MS_FEC_OFFSET (1 << 23)\n#define MNT_MS_FEC_ROOTS (1 << 24)\n#define MNT_MS_ROOT_HASH_SIG (1 << 25)\n#define MNT_MS_VERITY_ON_CORRUPTION (1 << 26)\n\n/*\n * mount(2) MS_* masks (MNT_MAP_LINUX map)\n */\n#ifndef MS_RDONLY\n#define MS_RDONLY\t 1\t/* Mount read-only */\n#endif\n#ifndef MS_NOSUID\n#define MS_NOSUID\t 2\t/* Ignore suid and sgid bits */\n#endif\n#ifndef MS_NODEV\n#define MS_NODEV\t 4\t/* Disallow access to device special files */\n#endif\n#ifndef MS_NOEXEC\n#define MS_NOEXEC\t 8\t/* Disallow program execution */\n#endif\n#ifndef MS_SYNCHRONOUS\n#define MS_SYNCHRONOUS\t16\t/* Writes are synced at once */\n#endif\n#ifndef MS_REMOUNT\n#define MS_REMOUNT\t32\t/* Alter flags of a mounted FS */\n#endif\n#ifndef MS_MANDLOCK\n#define MS_MANDLOCK\t64\t/* Allow mandatory locks on an FS */\n#endif\n#ifndef MS_DIRSYNC\n#define MS_DIRSYNC\t128\t/* Directory modifications are synchronous */\n#endif\n#ifndef MS_NOSYMFOLLOW\n#define MS_NOSYMFOLLOW\t256\t/* Don't follow symlinks */\n#endif\n#ifndef MS_NOATIME\n#define MS_NOATIME\t0x400\t/* 1024: Do not update access times. */\n#endif\n#ifndef MS_NODIRATIME\n#define MS_NODIRATIME   0x800\t/* 2048: Don't update directory access times */\n#endif\n#ifndef MS_BIND\n#define\tMS_BIND\t\t0x1000\t/* 4096: Mount existing tree elsewhere as well */\n#endif\n#ifndef MS_MOVE\n#define MS_MOVE\t\t0x2000\t/* 8192: Atomically move the tree */\n#endif\n#ifndef MS_REC\n#define MS_REC\t\t0x4000\t/* 16384: Recursive loopback */\n#endif\n#ifndef MS_SILENT\n#define MS_SILENT\t0x8000\t/* 32768: Don't emit certain kernel messages */\n#endif\n#ifndef MS_UNBINDABLE\n#define MS_UNBINDABLE\t(1<<17)\t/* 131072: Make unbindable */\n#endif\n#ifndef MS_PRIVATE\n#define MS_PRIVATE\t(1<<18)\t/* 262144: Make private */\n#endif\n#ifndef MS_SLAVE\n#define MS_SLAVE\t(1<<19)\t/* 524288: Make slave */\n#endif\n#ifndef MS_SHARED\n#define MS_SHARED\t(1<<20)\t/* 1048576: Make shared */\n#endif\n#ifndef MS_RELATIME\n#define MS_RELATIME\t(1<<21) /* 2097152: Update atime relative to mtime/ctime */\n#endif\n#ifndef MS_I_VERSION\n#define MS_I_VERSION\t(1<<23)\t/* Update the inode I_version field */\n#endif\n#ifndef MS_STRICTATIME\n#define MS_STRICTATIME\t(1<<24) /* Always perform atime updates */\n#endif\n#ifndef MS_LAZYTIME\n#define MS_LAZYTIME     (1<<25) /* Update the on-disk [acm]times lazily */\n#endif\n\n\n/*\n * Magic mount flag number. Had to be or-ed to the flag values.  Deprecated and\n * no more used since libmount v2.33; required for Linux <= 2.4.\n */\n#ifndef MS_MGC_VAL\n#define MS_MGC_VAL 0xC0ED0000\t/* magic flag number to indicate \"new\" flags */\n#endif\n#ifndef MS_MGC_MSK\n#define MS_MGC_MSK 0xffff0000\t/* magic flag number mask */\n#endif\n\n\n/* Shared-subtree options */\n#define MS_PROPAGATION  (MS_SHARED|MS_SLAVE|MS_UNBINDABLE|MS_PRIVATE)\n\n/* Options that we make ordinary users have by default.  */\n#define MS_SECURE\t(MS_NOEXEC|MS_NOSUID|MS_NODEV)\n\n/* Options that we make owner-mounted devices have by default */\n#define MS_OWNERSECURE\t(MS_NOSUID|MS_NODEV)\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* _LIBMOUNT_MOUNT_H */\n", "/*\n * SPDX-License-Identifier: LGPL-2.1-or-later\n *\n * This file is part of libmount from util-linux project.\n *\n * Copyright (C) 2011-2018 Karel Zak <kzak@redhat.com>\n *\n * libmount is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n *\n * The symbol versioning ensures that a new application requiring symbol foo,\n * can't run with old library.so not providing foo.\n *\n * Version info can't enforce this since we never change the SONAME.\n */\nMOUNT_2.19 {\nglobal:\n\tmnt_cache_device_has_tag;\n\tmnt_cache_find_tag_value;\n\tmnt_cache_read_tags;\n\tmnt_context_append_options;\n\tmnt_context_apply_fstab;\n\tmnt_context_disable_canonicalize;\n\tmnt_context_disable_helpers;\n\tmnt_context_disable_mtab;\n\tmnt_context_do_mount;\n\tmnt_context_do_umount;\n\tmnt_context_enable_fake;\n\tmnt_context_enable_force;\n\tmnt_context_enable_lazy;\n\tmnt_context_enable_loopdel;\n\tmnt_context_enable_rdonly_umount;\n\tmnt_context_enable_sloppy;\n\tmnt_context_enable_verbose;\n\tmnt_context_finalize_mount;\n\tmnt_context_finalize_umount;\n\tmnt_context_get_cache;\n\tmnt_context_get_fs;\n\tmnt_context_get_fstab;\n\tmnt_context_get_fstype;\n\tmnt_context_get_lock;\n\tmnt_context_get_mflags;\n\tmnt_context_get_mtab;\n\tmnt_context_get_optsmode;\n\tmnt_context_get_source;\n\tmnt_context_get_status;\n\tmnt_context_get_target;\n\tmnt_context_get_user_mflags;\n\tmnt_context_helper_setopt;\n\tmnt_context_init_helper;\n\tmnt_context_is_fake;\n\tmnt_context_is_force;\n\tmnt_context_is_lazy;\n\tmnt_context_is_nomtab;\n\tmnt_context_is_rdonly_umount;\n\tmnt_context_is_restricted;\n\tmnt_context_is_sloppy;\n\tmnt_context_is_verbose;\n\tmnt_context_mount;\n\tmnt_context_prepare_mount;\n\tmnt_context_prepare_umount;\n\tmnt_context_set_cache;\n\tmnt_context_set_fs;\n\tmnt_context_set_fstab;\n\tmnt_context_set_fstype;\n\tmnt_context_set_fstype_pattern;\n\tmnt_context_set_mflags;\n\tmnt_context_set_mountdata;\n\tmnt_context_set_options;\n\tmnt_context_set_options_pattern;\n\tmnt_context_set_optsmode;\n\tmnt_context_set_source;\n\tmnt_context_set_syscall_status;\n\tmnt_context_set_target;\n\tmnt_context_set_user_mflags;\n\tmnt_context_strerror;\n\tmnt_context_umount;\n\tmnt_copy_fs;\n\tmnt_free_cache;\n\tmnt_free_context;\n\tmnt_free_fs;\n\tmnt_free_iter;\n\tmnt_free_lock;\n\tmnt_free_mntent;\n\tmnt_free_table;\n\tmnt_free_update;\n\tmnt_fs_append_attributes;\n\tmnt_fs_append_options;\n\tmnt_fs_get_attribute;\n\tmnt_fs_get_attributes;\n\tmnt_fs_get_bindsrc;\n\tmnt_fs_get_devno;\n\tmnt_fs_get_freq;\n\tmnt_fs_get_fs_options;\n\tmnt_fs_get_fstype;\n\tmnt_fs_get_id;\n\tmnt_fs_get_option;\n\tmnt_fs_get_parent_id;\n\tmnt_fs_get_passno;\n\tmnt_fs_get_root;\n\tmnt_fs_get_source;\n\tmnt_fs_get_srcpath;\n\tmnt_fs_get_tag;\n\tmnt_fs_get_target;\n\tmnt_fs_get_userdata;\n\tmnt_fs_get_user_options;\n\tmnt_fs_get_vfs_options;\n\tmnt_fs_is_kernel;\n\tmnt_fs_match_fstype;\n\tmnt_fs_match_options;\n\tmnt_fs_match_source;\n\tmnt_fs_match_target;\n\tmnt_fs_prepend_attributes;\n\tmnt_fs_prepend_options;\n\tmnt_fs_print_debug;\n\tmnt_fs_set_attributes;\n\tmnt_fs_set_bindsrc;\n\tmnt_fs_set_freq;\n\tmnt_fs_set_fstype;\n\tmnt_fs_set_options;\n\tmnt_fs_set_passno;\n\tmnt_fs_set_root;\n\tmnt_fs_set_source;\n\tmnt_fs_set_target;\n\tmnt_fs_set_userdata;\n\tmnt_fs_strdup_options;\n\tmnt_fs_to_mntent;\n\tmnt_fstype_is_netfs;\n\tmnt_fstype_is_pseudofs;\n\tmnt_get_builtin_optmap;\n\tmnt_get_fstab_path;\n\tmnt_get_fstype;\n\tmnt_get_library_version;\n\tmnt_get_mtab_path;\n\tmnt_has_regular_mtab;\n\tmnt_init_debug;\n\tmnt_iter_get_direction;\n\tmnt_lock_file;\n\tmnt_mangle;\n\tmnt_match_fstype;\n\tmnt_match_options;\n\tmnt_new_cache;\n\tmnt_new_context;\n\tmnt_new_fs;\n\tmnt_new_iter;\n\tmnt_new_lock;\n\tmnt_new_table;\n\tmnt_new_table_from_dir;\n\tmnt_new_table_from_file;\n\tmnt_new_update;\n\tmnt_optstr_append_option;\n\tmnt_optstr_apply_flags;\n\tmnt_optstr_get_flags;\n\tmnt_optstr_get_option;\n\tmnt_optstr_get_options;\n\tmnt_optstr_next_option;\n\tmnt_optstr_prepend_option;\n\tmnt_optstr_remove_option;\n\tmnt_optstr_set_option;\n\tmnt_parse_version_string;\n\tmnt_reset_context;\n\tmnt_reset_fs;\n\tmnt_reset_iter;\n\tmnt_resolve_path;\n\tmnt_resolve_spec;\n\tmnt_resolve_tag;\n\tmnt_split_optstr;\n\tmnt_table_add_fs;\n\tmnt_table_find_next_fs;\n\tmnt_table_find_pair;\n\tmnt_table_find_source;\n\tmnt_table_find_srcpath;\n\tmnt_table_find_tag;\n\tmnt_table_find_target;\n\tmnt_table_get_cache;\n\tmnt_table_get_nents;\n\tmnt_table_get_root_fs;\n\tmnt_table_next_child_fs;\n\tmnt_table_next_fs;\n\tmnt_table_parse_file;\n\tmnt_table_parse_fstab;\n\tmnt_table_parse_mtab;\n\tmnt_table_parse_stream;\n\tmnt_table_remove_fs;\n\tmnt_table_set_cache;\n\tmnt_table_set_iter;\n\tmnt_table_set_parser_errcb;\n\tmnt_unlock_file;\n\tmnt_unmangle;\n\tmnt_update_force_rdonly;\n\tmnt_update_get_filename;\n\tmnt_update_get_fs;\n\tmnt_update_get_mflags;\n\tmnt_update_is_ready;\n\tmnt_update_set_fs;\n\tmnt_update_table;\nlocal:\n\t*;\n};\n\nMOUNT_2.20 {\nglobal:\n\tmnt_context_get_table;\n\tmnt_context_is_fs_mounted;\n\tmnt_context_next_mount;\n\tmnt_context_set_tables_errcb;\n\tmnt_diff_tables;\n\tmnt_free_tabdiff;\n\tmnt_fs_get_options;\n\tmnt_lock_block_signals;\n\tmnt_new_tabdiff;\n\tmnt_pretty_path;\n\tmnt_reset_table;\n\tmnt_tabdiff_next_change;\n\tmnt_table_is_fs_mounted;\n} MOUNT_2.19;\n\nMOUNT_2.21 {\nglobal:\n\tmnt_context_enable_fork;\n\tmnt_context_get_helper_status;\n\tmnt_context_get_syscall_errno;\n\tmnt_context_helper_executed;\n\tmnt_context_is_child;\n\tmnt_context_is_fork;\n\tmnt_context_is_parent;\n\tmnt_context_next_umount;\n\tmnt_context_reset_status;\n\tmnt_context_set_passwd_cb;\n\tmnt_context_syscall_called;\n\tmnt_context_wait_for_children;\n\tmnt_fs_is_netfs;\n\tmnt_fs_is_pseudofs;\n\tmnt_fs_is_swaparea;\n\tmnt_get_library_features;\n\tmnt_table_parse_dir;\n} MOUNT_2.20;\n\nMOUNT_2.22 {\nglobal:\n\tmnt_context_disable_swapmatch;\n\tmnt_context_get_options;\n\tmnt_context_is_loopdel;\n\tmnt_context_is_nocanonicalize;\n\tmnt_context_is_nohelpers;\n\tmnt_context_is_swapmatch;\n\tmnt_context_tab_applied;\n\tmnt_fs_get_priority;\n\tmnt_fs_get_size;\n\tmnt_fs_get_swaptype;\n\tmnt_fs_get_tid;\n\tmnt_fs_get_usedsize;\n\tmnt_fs_streq_srcpath;\n\tmnt_fs_streq_target;\n\tmnt_get_mountpoint;\n\tmnt_get_swaps_path;\n\tmnt_optstr_deduplicate_option;\n\tmnt_table_find_devno;\n\tmnt_table_parse_swaps;\n} MOUNT_2.21;\n\nMOUNT_2.23 {\nglobal:\n\tmnt_fs_get_optional_fields;\n\tmnt_fs_get_propagation;\n\tmnt_context_find_umount_fs;\n\tmnt_table_find_mountpoint;\n} MOUNT_2.22;\n\nMOUNT_2.24 {\nglobal:\n\tmnt_context_get_fstab_userdata;\n\tmnt_context_get_fs_userdata;\n\tmnt_context_get_mtab_userdata;\n\tmnt_fs_append_comment;\n\tmnt_fs_get_comment;\n\tmnt_fs_set_comment;\n\tmnt_ref_cache;\n\tmnt_ref_fs;\n\tmnt_ref_table;\n\tmnt_table_append_intro_comment;\n\tmnt_table_append_trailing_comment;\n\tmnt_table_enable_comments;\n\tmnt_table_first_fs;\n\tmnt_table_get_intro_comment;\n\tmnt_table_get_trailing_comment;\n\tmnt_table_get_userdata;\n\tmnt_table_is_empty;\n\tmnt_table_last_fs;\n\tmnt_table_replace_file;\n\tmnt_table_set_intro_comment;\n\tmnt_table_set_trailing_comment;\n\tmnt_table_set_userdata;\n\tmnt_table_with_comments;\n\tmnt_table_write_file;\n\tmnt_unref_cache;\n\tmnt_unref_fs;\n\tmnt_unref_table;\n} MOUNT_2.23;\n\nMOUNT_2.25 {\n\tmnt_cache_set_targets;\n\tmnt_resolve_target;\n\tmnt_table_uniq_fs;\n\tmnt_tag_is_valid;\n} MOUNT_2.24;\n\nMOUNT_2.26 {\n\tmnt_monitor_close_fd;\n\tmnt_monitor_enable_userspace;\n\tmnt_monitor_enable_kernel;\n\tmnt_monitor_event_cleanup;\n\tmnt_monitor_get_fd;\n\tmnt_monitor_next_change;\n\tmnt_monitor_wait;\n\tmnt_new_monitor;\n\tmnt_ref_monitor;\n\tmnt_unref_monitor;\n} MOUNT_2.25;\n\nMOUNT_2.28 {\n\tmnt_table_find_target_with_option;\n\tmnt_fs_set_priority;\n} MOUNT_2.26;\n\nMOUNT_2.30 {\n\tmnt_context_is_rwonly_mount;\n\tmnt_context_forced_rdonly;\n\tmnt_context_enable_rwonly_mount;\n\tmnt_context_get_excode;\n} MOUNT_2.28;\n\nMOUNT_2.33 {\n\tmnt_context_get_origin_ns;\n\tmnt_context_get_target_ns;\n\tmnt_context_set_target_ns;\n\tmnt_context_switch_ns;\n\tmnt_context_switch_origin_ns;\n\tmnt_context_switch_target_ns;\n} MOUNT_2.30;\n\nMOUNT_2.34 {\n\tmnt_context_next_remount;\n\tmnt_fs_get_table;\n\tmnt_guess_system_root;\n\tmnt_table_find_fs;\n\tmnt_table_insert_fs;\n\tmnt_table_move_fs;\n} MOUNT_2.33;\n\nMOUNT_2_35 {\n\tmnt_context_force_unrestricted;\n\tmnt_context_get_target_prefix;\n\tmnt_context_set_target_prefix;\n} MOUNT_2.34;\n\nMOUNT_2_37 {\n\tmnt_fs_get_vfs_options_all;\n\tmnt_table_over_fs;\n} MOUNT_2_35;\n\n\nMOUNT_2_38 {\n\tmnt_fs_is_regularfs;\n\tmnt_fs_is_deleted;\n} MOUNT_2_37;\n", "/* SPDX-License-Identifier: LGPL-2.1-or-later */\n/*\n * mountP.h - private library header file\n *\n * This file is part of libmount from util-linux project.\n *\n * Copyright (C) 2008-2018 Karel Zak <kzak@redhat.com>\n *\n * libmount is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n */\n#ifndef _LIBMOUNT_PRIVATE_H\n#define _LIBMOUNT_PRIVATE_H\n\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/vfs.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n\n#include \"c.h\"\n#include \"list.h\"\n#include \"debug.h\"\n#include \"libmount.h\"\n\n/*\n * Debug\n */\n#define MNT_DEBUG_HELP\t\t(1 << 0)\n#define MNT_DEBUG_INIT\t\t(1 << 1)\n#define MNT_DEBUG_CACHE\t\t(1 << 2)\n#define MNT_DEBUG_OPTIONS\t(1 << 3)\n#define MNT_DEBUG_LOCKS\t\t(1 << 4)\n#define MNT_DEBUG_TAB\t\t(1 << 5)\n#define MNT_DEBUG_FS\t\t(1 << 6)\n#define MNT_DEBUG_UPDATE\t(1 << 7)\n#define MNT_DEBUG_UTILS\t\t(1 << 8)\n#define MNT_DEBUG_CXT\t\t(1 << 9)\n#define MNT_DEBUG_DIFF\t\t(1 << 10)\n#define MNT_DEBUG_MONITOR\t(1 << 11)\n#define MNT_DEBUG_BTRFS\t\t(1 << 12)\n#define MNT_DEBUG_LOOP\t\t(1 << 13)\n#define MNT_DEBUG_VERITY\t(1 << 14)\n\n#define MNT_DEBUG_ALL\t\t0xFFFF\n\nUL_DEBUG_DECLARE_MASK(libmount);\n#define DBG(m, x)\t__UL_DBG(libmount, MNT_DEBUG_, m, x)\n#define ON_DBG(m, x)\t__UL_DBG_CALL(libmount, MNT_DEBUG_, m, x)\n#define DBG_FLUSH\t__UL_DBG_FLUSH(libmount, MNT_DEBUG_)\n\n#define UL_DEBUG_CURRENT_MASK\tUL_DEBUG_MASK(libmount)\n#include \"debugobj.h\"\n\n/*\n * NLS -- the library has to be independent on main program, so define\n * UL_TEXTDOMAIN_EXPLICIT before you include nls.h.\n *\n * Now we use util-linux.po (=PACKAGE), rather than maintain the texts\n * in the separate libmount.po file.\n */\n#define LIBMOUNT_TEXTDOMAIN\tPACKAGE\n#define UL_TEXTDOMAIN_EXPLICIT\tLIBMOUNT_TEXTDOMAIN\n#include \"nls.h\"\n\n\n/* extension for files in the directory */\n#define MNT_MNTTABDIR_EXT\t\".fstab\"\n\n/* library private paths */\n#define MNT_RUNTIME_TOPDIR\t\"/run\"\n/* private userspace mount table */\n#define MNT_PATH_UTAB\t\tMNT_RUNTIME_TOPDIR \"/mount/utab\"\n/* temporary mount target */\n#define MNT_PATH_TMPTGT\t\tMNT_RUNTIME_TOPDIR \"/mount/tmptgt\"\n\n#define MNT_UTAB_HEADER\t\"# libmount utab file\\n\"\n\n#ifdef TEST_PROGRAM\nstruct libmnt_test {\n\tconst char\t*name;\n\tint\t\t(*body)(struct libmnt_test *ts, int argc, char *argv[]);\n\tconst char\t*usage;\n};\n\n/* test.c */\nextern int mnt_run_test(struct libmnt_test *tests, int argc, char *argv[]);\n#endif\n\n/* utils.c */\nextern int mnt_valid_tagname(const char *tagname);\n\nextern const char *mnt_statfs_get_fstype(struct statfs *vfs);\nextern int is_file_empty(const char *name);\n\nextern int mnt_is_readonly(const char *path)\n\t\t\t__attribute__((nonnull));\n\nextern int mnt_parse_offset(const char *str, size_t len, uintmax_t *res);\n\nextern int mnt_chdir_to_parent(const char *target, char **filename);\n\nextern char *mnt_get_username(const uid_t uid);\nextern int mnt_get_uid(const char *username, uid_t *uid);\nextern int mnt_get_gid(const char *groupname, gid_t *gid);\nextern int mnt_in_group(gid_t gid);\n\nextern int mnt_open_uniq_filename(const char *filename, char **name);\n\nextern int mnt_has_regular_utab(const char **utab, int *writable);\nextern const char *mnt_get_utab_path(void);\n\nextern int mnt_get_filesystems(char ***filesystems, const char *pattern);\nextern void mnt_free_filesystems(char **filesystems);\n\nextern char *mnt_get_kernel_cmdline_option(const char *name);\nextern int mnt_stat_mountpoint(const char *target, struct stat *st);\nextern int mnt_lstat_mountpoint(const char *target, struct stat *st);\n\nextern int mnt_tmptgt_unshare(int *old_ns_fd);\nextern int mnt_tmptgt_cleanup(int old_ns_fd);\n\n/* tab.c */\nextern int is_mountinfo(struct libmnt_table *tb);\nextern int mnt_table_set_parser_fltrcb(\tstruct libmnt_table *tb,\n\t\t\t\t\tint (*cb)(struct libmnt_fs *, void *),\n\t\t\t\t\tvoid *data);\n\nextern int __mnt_table_parse_mtab(struct libmnt_table *tb,\n\t\t\t\t\tconst char *filename,\n\t\t\t\t\tstruct libmnt_table *u_tb);\n\nextern struct libmnt_fs *mnt_table_get_fs_root(struct libmnt_table *tb,\n\t\t\t\t\tstruct libmnt_fs *fs,\n\t\t\t\t\tunsigned long mountflags,\n\t\t\t\t\tchar **fsroot);\n\nextern int __mnt_table_is_fs_mounted(\tstruct libmnt_table *tb,\n\t\t\t\t\tstruct libmnt_fs *fstab_fs,\n\t\t\t\t\tconst char *tgt_prefix);\n\n/*\n * Generic iterator\n */\nstruct libmnt_iter {\n        struct list_head        *p;\t\t/* current position */\n        struct list_head        *head;\t\t/* start position */\n\tint\t\t\tdirection;\t/* MNT_ITER_{FOR,BACK}WARD */\n};\n\n#define IS_ITER_FORWARD(_i)\t((_i)->direction == MNT_ITER_FORWARD)\n#define IS_ITER_BACKWARD(_i)\t((_i)->direction == MNT_ITER_BACKWARD)\n\n#define MNT_ITER_INIT(itr, list) \\\n\tdo { \\\n\t\t(itr)->p = IS_ITER_FORWARD(itr) ? \\\n\t\t\t\t(list)->next : (list)->prev; \\\n\t\t(itr)->head = (list); \\\n\t} while(0)\n\n#define MNT_ITER_ITERATE(itr, res, restype, member) \\\n\tdo { \\\n\t\tres = list_entry((itr)->p, restype, member); \\\n\t\t(itr)->p = IS_ITER_FORWARD(itr) ? \\\n\t\t\t\t(itr)->p->next : (itr)->p->prev; \\\n\t} while(0)\n\n\n/*\n * This struct represents one entry in a mtab/fstab/mountinfo file.\n * (note that fstab[1] means the first column from fstab, and so on...)\n */\nstruct libmnt_fs {\n\tstruct list_head ents;\n\tstruct libmnt_table *tab;\n\n\tint\t\trefcount;\t/* reference counter */\n\tint\t\tid;\t\t/* mountinfo[1]: ID */\n\tint\t\tparent;\t\t/* mountinfo[2]: parent */\n\tdev_t\t\tdevno;\t\t/* mountinfo[3]: st_dev */\n\n\tchar\t\t*bindsrc;\t/* utab, full path from fstab[1] for bind mounts */\n\n\tchar\t\t*source;\t/* fstab[1], mountinfo[10], swaps[1]:\n                                         * source dev, file, dir or TAG */\n\tchar\t\t*tagname;\t/* fstab[1]: tag name - \"LABEL\", \"UUID\", ..*/\n\tchar\t\t*tagval;\t/*           tag value */\n\n\tchar\t\t*root;\t\t/* mountinfo[4]: root of the mount within the FS */\n\tchar\t\t*target;\t/* mountinfo[5], fstab[2]: mountpoint */\n\tchar\t\t*fstype;\t/* mountinfo[9], fstab[3]: filesystem type */\n\n\tchar\t\t*optstr;\t/* fstab[4], merged options */\n\tchar\t\t*vfs_optstr;\t/* mountinfo[6]: fs-independent (VFS) options */\n\tchar\t\t*opt_fields;\t/* mountinfo[7]: optional fields */\n\tchar\t\t*fs_optstr;\t/* mountinfo[11]: fs-dependent options */\n\tchar\t\t*user_optstr;\t/* userspace mount options */\n\tchar\t\t*attrs;\t\t/* mount attributes */\n\n\tint\t\tfreq;\t\t/* fstab[5]: dump frequency in days */\n\tint\t\tpassno;\t\t/* fstab[6]: pass number on parallel fsck */\n\n\t/* /proc/swaps */\n\tchar\t\t*swaptype;\t/* swaps[2]: device type (partition, file, ...) */\n\toff_t\t\tsize;\t\t/* swaps[3]: swaparea size */\n\toff_t\t\tusedsize;\t/* swaps[4]: used size */\n\tint\t\tpriority;\t/* swaps[5]: swap priority */\n\n\tint\t\tflags;\t\t/* MNT_FS_* flags */\n\tpid_t\t\ttid;\t\t/* /proc/<tid>/mountinfo otherwise zero */\n\n\tchar\t\t*comment;\t/* fstab comment */\n\n\tvoid\t\t*userdata;\t/* library independent data */\n};\n\n/*\n * fs flags\n */\n#define MNT_FS_PSEUDO\t(1 << 1) /* pseudo filesystem */\n#define MNT_FS_NET\t(1 << 2) /* network filesystem */\n#define MNT_FS_SWAP\t(1 << 3) /* swap device */\n#define MNT_FS_KERNEL\t(1 << 4) /* data from /proc/{mounts,self/mountinfo} */\n#define MNT_FS_MERGED\t(1 << 5) /* already merged data from /run/mount/utab */\n#define MNT_FS_DELETED\t(1 << 6) /* target path in mountinfo contains \"(deleted)\" */\n\n/*\n * mtab/fstab/mountinfo file\n */\nstruct libmnt_table {\n\tint\t\tfmt;\t\t/* MNT_FMT_* file format */\n\tint\t\tnents;\t\t/* number of entries */\n\tint\t\trefcount;\t/* reference counter */\n\tint\t\tcomms;\t\t/* enable/disable comment parsing */\n\tchar\t\t*comm_intro;\t/* First comment in file */\n\tchar\t\t*comm_tail;\t/* Last comment in file */\n\n\tstruct libmnt_cache *cache;\t\t/* canonicalized paths/tags cache */\n\n        int\t\t(*errcb)(struct libmnt_table *tb,\n\t\t\t\t const char *filename, int line);\n\n\tint\t\t(*fltrcb)(struct libmnt_fs *fs, void *data);\n\tvoid\t\t*fltrcb_data;\n\n\n\tstruct list_head\tents;\t/* list of entries (libmnt_fs) */\n\tvoid\t\t*userdata;\n};\n\nextern struct libmnt_table *__mnt_new_table_from_file(const char *filename, int fmt, int empty_for_enoent);\n\n/*\n * Tab file format\n */\nenum {\n\tMNT_FMT_GUESS,\n\tMNT_FMT_FSTAB,\t\t\t/* /etc/{fs,m}tab */\n\tMNT_FMT_MTAB = MNT_FMT_FSTAB,\t/* alias */\n\tMNT_FMT_MOUNTINFO,\t\t/* /proc/#/mountinfo */\n\tMNT_FMT_UTAB,\t\t\t/* /run/mount/utab */\n\tMNT_FMT_SWAPS\t\t\t/* /proc/swaps */\n};\n\n/*\n * Additional mounts\n */\nstruct libmnt_addmount {\n\tunsigned long mountflags;\n\n\tstruct list_head\tmounts;\n};\n\nstruct libmnt_ns {\n\tint fd;\t\t\t\t/* file descriptor of namespace, -1 when inactive */\n\tstruct libmnt_cache *cache;\t/* paths cache associated with NS */\n};\n\n/*\n * Mount context -- high-level API\n */\nstruct libmnt_context\n{\n\tint\taction;\t\t/* MNT_ACT_{MOUNT,UMOUNT} */\n\tint\trestricted;\t/* root or not? */\n\n\tchar\t*fstype_pattern;\t/* for mnt_match_fstype() */\n\tchar\t*optstr_pattern;\t/* for mnt_match_options() */\n\n\tchar\t*subdir;\t\t/* X-mount.subdir= */\n\n\tstruct libmnt_fs *fs;\t\t/* filesystem description (type, mountpoint, device, ...) */\n\tstruct libmnt_fs *fs_template;\t/* used for @fs on mnt_reset_context() */\n\n\tstruct libmnt_table *fstab;\t/* fstab (or mtab for some remounts) entries */\n\tstruct libmnt_table *mtab;\t/* mtab entries */\n\tstruct libmnt_table *utab;\t/* rarely used by umount only */\n\n\tint\t(*table_errcb)(struct libmnt_table *tb,\t/* callback for libmnt_table structs */\n\t\t\t const char *filename, int line);\n\n\tint\t(*table_fltrcb)(struct libmnt_fs *fs, void *data);\t/* callback for libmnt_table structs */\n\tvoid\t*table_fltrcb_data;\n\n\tchar\t*(*pwd_get_cb)(struct libmnt_context *);\t\t/* get encryption password */\n\tvoid\t(*pwd_release_cb)(struct libmnt_context *, char *);\t/* release password */\n\n\tint\toptsmode;\t/* fstab optstr mode MNT_OPTSMODE_{AUTO,FORCE,IGNORE} */\n\tint\tloopdev_fd;\t/* open loopdev */\n\n\tunsigned long\tmountflags;\t/* final mount(2) flags */\n\tconst void\t*mountdata;\t/* final mount(2) data, string or binary data */\n\n\tunsigned long\tuser_mountflags;\t/* MNT_MS_* (loop=, user=, ...) */\n\n\tstruct list_head\taddmounts;\t/* additional mounts */\n\n\tstruct libmnt_cache\t*cache;\t/* paths cache */\n\tstruct libmnt_lock\t*lock;\t/* mtab lock */\n\tstruct libmnt_update\t*update;/* mtab/utab update */\n\n\tconst char\t*mtab_path; /* path to mtab */\n\tint\t\tmtab_writable; /* is mtab writable */\n\n\tconst char\t*utab_path; /* path to utab */\n\tint\t\tutab_writable; /* is utab writable */\n\n\tchar\t\t*tgt_prefix;\t/* path used for all targets */\n\n\tint\tflags;\t\t/* private context flags */\n\n\tchar\t*helper;\t/* name of the used /sbin/[u]mount.<type> helper */\n\tint\thelper_status;\t/* helper wait(2) status */\n\tint\thelper_exec_status; /* 1: not called yet, 0: success, <0: -errno */\n\n\tchar\t*orig_user;\t/* original (non-fixed) user= option */\n\n\tpid_t\t*children;\t/* \"mount -a --fork\" PIDs */\n\tint\tnchildren;\t/* number of children */\n\tpid_t\tpid;\t\t/* 0=parent; PID=child */\n\n\n\tint\tsyscall_status;\t/* 1: not called yet, 0: success, <0: -errno */\n\n\tstruct libmnt_ns\tns_orig;\t/* original namespace */\n\tstruct libmnt_ns\tns_tgt;\t\t/* target namespace */\n\tstruct libmnt_ns\t*ns_cur;\t/* pointer to current namespace */\n\n\tunsigned int\tenabled_textdomain : 1;\t\t/* bindtextdomain() called */\n};\n\n/* flags */\n#define MNT_FL_NOMTAB\t\t(1 << 1)\n#define MNT_FL_FAKE\t\t(1 << 2)\n#define MNT_FL_SLOPPY\t\t(1 << 3)\n#define MNT_FL_VERBOSE\t\t(1 << 4)\n#define MNT_FL_NOHELPERS\t(1 << 5)\n#define MNT_FL_LOOPDEL\t\t(1 << 6)\n#define MNT_FL_LAZY\t\t(1 << 7)\n#define MNT_FL_FORCE\t\t(1 << 8)\n#define MNT_FL_NOCANONICALIZE\t(1 << 9)\n#define MNT_FL_RDONLY_UMOUNT\t(1 << 11)\t/* remount,ro after EBUSY umount(2) */\n#define MNT_FL_FORK\t\t(1 << 12)\n#define MNT_FL_NOSWAPMATCH\t(1 << 13)\n#define MNT_FL_RWONLY_MOUNT\t(1 << 14)\t/* explicit mount -w; never try read-only  */\n\n#define MNT_FL_MOUNTDATA\t(1 << 20)\n#define MNT_FL_TAB_APPLIED\t(1 << 21)\t/* mtab/fstab merged to cxt->fs */\n#define MNT_FL_MOUNTFLAGS_MERGED (1 << 22)\t/* MS_* flags was read from optstr */\n#define MNT_FL_SAVED_USER\t(1 << 23)\n#define MNT_FL_PREPARED\t\t(1 << 24)\n#define MNT_FL_HELPER\t\t(1 << 25)\t/* [u]mount.<type> */\n#define MNT_FL_LOOPDEV_READY\t(1 << 26)\t/* /dev/loop<N> initialized by the library */\n#define MNT_FL_MOUNTOPTS_FIXED  (1 << 27)\n#define MNT_FL_TABPATHS_CHECKED\t(1 << 28)\n#define MNT_FL_FORCED_RDONLY\t(1 << 29)\t/* mounted read-only on write-protected device */\n#define MNT_FL_VERITYDEV_READY\t(1 << 30)\t/* /dev/mapper/<FOO> initialized by the library */\n\n/* default flags */\n#define MNT_FL_DEFAULT\t\t0\n\n/* Flags usable with MS_BIND|MS_REMOUNT */\n#define MNT_BIND_SETTABLE\t(MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_NOATIME|MS_NODIRATIME|MS_RELATIME|MS_RDONLY)\n\n/* lock.c */\nextern int mnt_lock_use_simplelock(struct libmnt_lock *ml, int enable);\n\n/* optmap.c */\nextern const struct libmnt_optmap *mnt_optmap_get_entry(\n\t\t\t     struct libmnt_optmap const **maps,\n                             int nmaps,\n\t\t\t     const char *name,\n                             size_t namelen,\n\t\t\t     const struct libmnt_optmap **mapent);\n\n/* optstr.c */\nextern int mnt_optstr_remove_option_at(char **optstr, char *begin, char *end);\nextern int mnt_optstr_fix_gid(char **optstr, char *value, size_t valsz, char **next);\nextern int mnt_optstr_fix_uid(char **optstr, char *value, size_t valsz, char **next);\nextern int mnt_optstr_fix_secontext(char **optstr, char *value, size_t valsz, char **next);\nextern int mnt_optstr_fix_user(char **optstr);\n\n/* fs.c */\nextern struct libmnt_fs *mnt_copy_mtab_fs(const struct libmnt_fs *fs)\n\t\t\t__attribute__((nonnull));\nextern int __mnt_fs_set_source_ptr(struct libmnt_fs *fs, char *source)\n\t\t\t__attribute__((nonnull(1)));\nextern int __mnt_fs_set_fstype_ptr(struct libmnt_fs *fs, char *fstype)\n\t\t\t__attribute__((nonnull(1)));\n\n/* context.c */\nextern struct libmnt_context *mnt_copy_context(struct libmnt_context *o);\nextern int mnt_context_mtab_writable(struct libmnt_context *cxt);\nextern int mnt_context_utab_writable(struct libmnt_context *cxt);\nextern const char *mnt_context_get_writable_tabpath(struct libmnt_context *cxt);\n\nextern int mnt_context_get_mtab_for_target(struct libmnt_context *cxt,\n\t\t\t\t    struct libmnt_table **mtab, const char *tgt);\n\nextern int mnt_context_prepare_srcpath(struct libmnt_context *cxt);\nextern int mnt_context_prepare_target(struct libmnt_context *cxt);\nextern int mnt_context_guess_srcpath_fstype(struct libmnt_context *cxt, char **type);\nextern int mnt_context_guess_fstype(struct libmnt_context *cxt);\nextern int mnt_context_prepare_helper(struct libmnt_context *cxt,\n\t\t\t\t      const char *name, const char *type);\nextern int mnt_context_prepare_update(struct libmnt_context *cxt);\nextern int mnt_context_merge_mflags(struct libmnt_context *cxt);\nextern int mnt_context_update_tabs(struct libmnt_context *cxt);\n\nextern int mnt_context_umount_setopt(struct libmnt_context *cxt, int c, char *arg);\nextern int mnt_context_mount_setopt(struct libmnt_context *cxt, int c, char *arg);\n\nextern int mnt_context_is_loopdev(struct libmnt_context *cxt)\n\t\t\t__attribute__((nonnull));\n\nextern int mnt_context_propagation_only(struct libmnt_context *cxt)\n\t\t\t__attribute__((nonnull));\n\nextern struct libmnt_addmount *mnt_new_addmount(void);\nextern void mnt_free_addmount(struct libmnt_addmount *ad);\n\nextern int mnt_context_setup_loopdev(struct libmnt_context *cxt);\nextern int mnt_context_delete_loopdev(struct libmnt_context *cxt);\nextern int mnt_context_clear_loopdev(struct libmnt_context *cxt);\n\nextern int mnt_fork_context(struct libmnt_context *cxt);\n\nextern int mnt_context_set_tabfilter(struct libmnt_context *cxt,\n\t\t\t\t     int (*fltr)(struct libmnt_fs *, void *),\n\t\t\t\t     void *data);\n\nextern int mnt_context_get_generic_excode(int rc, char *buf, size_t bufsz, const char *fmt, ...)\n\t\t\t\t__attribute__ ((__format__ (__printf__, 4, 5)));\nextern int mnt_context_get_mount_excode(struct libmnt_context *cxt, int mntrc, char *buf, size_t bufsz);\nextern int mnt_context_get_umount_excode(struct libmnt_context *cxt, int mntrc, char *buf, size_t bufsz);\n\nextern int mnt_context_has_template(struct libmnt_context *cxt);\nextern int mnt_context_apply_template(struct libmnt_context *cxt);\nextern int mnt_context_save_template(struct libmnt_context *cxt);\n\nextern int mnt_context_apply_fs(struct libmnt_context *cxt, struct libmnt_fs *fs);\n\nextern int mnt_context_is_veritydev(struct libmnt_context *cxt)\n\t\t\t__attribute__((nonnull));\nextern int mnt_context_setup_veritydev(struct libmnt_context *cxt);\nextern int mnt_context_deferred_delete_veritydev(struct libmnt_context *cxt);\n\n/* tab_update.c */\nextern int mnt_update_set_filename(struct libmnt_update *upd,\n\t\t\t\t   const char *filename, int userspace_only);\nextern int mnt_update_already_done(struct libmnt_update *upd,\n\t\t\t\t   struct libmnt_lock *lc);\n\n#if __linux__\n/* btrfs.c */\nextern uint64_t btrfs_get_default_subvol_id(const char *path);\n#endif\n\n#endif /* _LIBMOUNT_PRIVATE_H */\n", "/* SPDX-License-Identifier: LGPL-2.1-or-later */\n/*\n * This file is part of libmount from util-linux project.\n *\n * Copyright (C) 2009-2018 Karel Zak <kzak@redhat.com>\n *\n * libmount is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n */\n#ifdef HAVE_SCANDIRAT\n#ifndef __USE_GNU\n#define __USE_GNU\n#endif\t/* !__USE_GNU */\n#endif\t/* HAVE_SCANDIRAT */\n\n#include <ctype.h>\n#include <limits.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n\n#include \"fileutils.h\"\n#include \"mangle.h\"\n#include \"mountP.h\"\n#include \"pathnames.h\"\n#include \"strutils.h\"\n\nstruct libmnt_parser {\n\tFILE\t*f;\t\t/* fstab, mtab, swaps or mountinfo ... */\n\tconst char *filename;\t/* file name or NULL */\n\tchar\t*buf;\t\t/* buffer (the current line content) */\n\tsize_t\tbufsiz;\t\t/* size of the buffer */\n\tsize_t\tline;\t\t/* current line */\n};\n\nstatic void parser_cleanup(struct libmnt_parser *pa)\n{\n\tif (!pa)\n\t\treturn;\n\tfree(pa->buf);\n\tmemset(pa, 0, sizeof(*pa));\n}\n\nstatic const char *next_s32(const char *s, int *num, int *rc)\n{\n\tchar *end = NULL;\n\n\tif (!s || !*s)\n\t\treturn s;\n\n\terrno = 0;\n\t*rc = -EINVAL;\n\t*num = strtol(s, &end, 10);\n\tif (end == NULL || s == end)\n\t       return s;\n\tif (errno == 0 && (*end == ' ' || *end == '\\t' || *end == '\\0'))\n\t\t*rc = 0;\n\treturn end;\n}\n\nstatic const char *next_u64(const char *s, uint64_t *num, int *rc)\n{\n\tchar *end = NULL;\n\n\tif (!s || !*s)\n\t\treturn s;\n\n\terrno = 0;\n\t*rc = -EINVAL;\n\t*num = (uint64_t) strtoumax(s, &end, 10);\n\tif (end == NULL || s == end)\n\t       return s;\n\tif (errno == 0 && (*end == ' ' || *end == '\\t' || *end == '\\0'))\n\t\t*rc = 0;\n\treturn end;\n}\n\nstatic inline const char *skip_separator(const char *p)\n{\n\twhile (p && (*p == ' ' || *p == '\\t'))\n\t\t++p;\n\treturn p;\n}\n\nstatic inline const char *skip_nonspearator(const char *p)\n{\n\twhile (p && *p && !(*p == ' ' || *p == '\\t'))\n\t\tp++;\n\treturn p;\n}\n\n/*\n * Parses one line from {fs,m}tab\n */\nstatic int mnt_parse_table_line(struct libmnt_fs *fs, const char *s)\n{\n\tint rc = 0;\n\tchar *p = NULL;\n\n\tfs->passno = fs->freq = 0;\n\n\t/* (1) source */\n\tp = unmangle(s, &s);\n\tif (!p || (rc = __mnt_fs_set_source_ptr(fs, p))) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [source]\"));\n\t\tfree(p);\n\t\tgoto fail;\n\t}\n\n\ts = skip_separator(s);\n\n\t/* (2) target */\n\tfs->target = unmangle(s, &s);\n\tif (!fs->target) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [target]\"));\n\t\tgoto fail;\n\t}\n\n\ts = skip_separator(s);\n\n\t/* (3) FS type */\n\tp = unmangle(s, &s);\n\tif (!p || (rc = __mnt_fs_set_fstype_ptr(fs, p))) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [fstype]\"));\n\t\tfree(p);\n\t\tgoto fail;\n\t}\n\n\ts = skip_separator(s);\n\n\t/* (4) options (optional) */\n\tp = unmangle(s, &s);\n\tif (p && (rc = mnt_fs_set_options(fs, p))) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [options]\"));\n\t\tfree(p);\n\t\tgoto fail;\n\t}\n\tif (!p)\n\t\tgoto done;\n\tfree(p);\n\n\ts = skip_separator(s);\n\tif (!s || !*s)\n\t\tgoto done;\n\n\t/* (5) freq (optional) */\n\ts = next_s32(s, &fs->freq, &rc);\n\tif (s && *s && rc) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [freq]\"));\n\t\tgoto fail;\n\t}\n\n\ts = skip_separator(s);\n\tif (!s || !*s)\n\t\tgoto done;\n\n\t/* (6) passno (optional) */\n\ts = next_s32(s, &fs->passno, &rc);\n\tif (s && *s && rc) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [passno]\"));\n\t\tgoto fail;\n\t}\n\ndone:\n\treturn 0;\nfail:\n\tif (rc == 0)\n\t\trc = -EINVAL;\n\tDBG(TAB, ul_debug(\"tab parse error on: '%s' [rc=%d]\", s, rc));\n\treturn rc;\n}\n\n\n/*\n * Parses one line from a mountinfo file\n */\nstatic int mnt_parse_mountinfo_line(struct libmnt_fs *fs, const char *s)\n{\n\tint rc = 0;\n\tunsigned int maj, min;\n\tchar *p;\n\n\tfs->flags |= MNT_FS_KERNEL;\n\n\t/* (1) id */\n\ts = next_s32(s, &fs->id, &rc);\n\tif (!s || !*s || rc) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [id]\"));\n\t\tgoto fail;\n\t}\n\n\ts = skip_separator(s);\n\n\t/* (2) parent */\n\ts = next_s32(s, &fs->parent, &rc);\n\tif (!s || !*s || rc) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [parent]\"));\n\t\tgoto fail;\n\t}\n\n\ts = skip_separator(s);\n\n\t/* (3) maj:min */\n\tif (sscanf(s, \"%u:%u\", &maj, &min) != 2) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [maj:min]\"));\n\t\tgoto fail;\n\t}\n\tfs->devno = makedev(maj, min);\n\ts = skip_nonspearator(s);\n\ts = skip_separator(s);\n\n\t/* (4) mountroot */\n\tfs->root = unmangle(s, &s);\n\tif (!fs->root) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [mountroot]\"));\n\t\tgoto fail;\n\t}\n\n\ts = skip_separator(s);\n\n\t/* (5) target */\n\tfs->target = unmangle(s, &s);\n\tif (!fs->target) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [target]\"));\n\t\tgoto fail;\n\t}\n\n\t/* remove \"\\040(deleted)\" suffix */\n\tp = (char *) endswith(fs->target, PATH_DELETED_SUFFIX);\n\tif (p && *p) {\n\t\t*p = '\\0';\n\t\tfs->flags |= MNT_FS_DELETED;\n\t}\n\n\ts = skip_separator(s);\n\n\t/* (6) vfs options (fs-independent) */\n\tfs->vfs_optstr = unmangle(s, &s);\n\tif (!fs->vfs_optstr) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [VFS options]\"));\n\t\tgoto fail;\n\t}\n\n\t/* (7) optional fields, terminated by \" - \" */\n\tp = strstr(s, \" - \");\n\tif (!p) {\n\t\tDBG(TAB, ul_debug(\"mountinfo parse error: separator not found\"));\n\t\treturn -EINVAL;\n\t}\n\tif (p > s + 1)\n\t\tfs->opt_fields = strndup(s + 1, p - s - 1);\n\n\ts = skip_separator(p + 3);\n\n\t/* (8) FS type */\n\tp = unmangle(s, &s);\n\tif (!p || (rc = __mnt_fs_set_fstype_ptr(fs, p))) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [fstype]\"));\n\t\tfree(p);\n\t\tgoto fail;\n\t}\n\n\t/* (9) source -- maybe empty string */\n\tif (!s || !*s) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [source]\"));\n\t\tgoto fail;\n\t} else if (*s == ' ' && *(s+1) == ' ') {\n\t\tif ((rc = mnt_fs_set_source(fs, \"\"))) {\n\t\t\tDBG(TAB, ul_debug(\"tab parse error: [empty source]\"));\n\t\t\tgoto fail;\n\t\t}\n\t} else {\n\t\ts = skip_separator(s);\n\t\tp = unmangle(s, &s);\n\t\tif (!p || (rc = __mnt_fs_set_source_ptr(fs, p))) {\n\t\t\tDBG(TAB, ul_debug(\"tab parse error: [regular source]\"));\n\t\t\tfree(p);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\ts = skip_separator(s);\n\n\t/* (10) fs options (fs specific) */\n\tfs->fs_optstr = unmangle(s, &s);\n\tif (!fs->fs_optstr) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [FS options]\"));\n\t\tgoto fail;\n\t}\n\n\t/* merge VFS and FS options to one string */\n\tfs->optstr = mnt_fs_strdup_options(fs);\n\tif (!fs->optstr) {\n\t\trc = -ENOMEM;\n\t\tDBG(TAB, ul_debug(\"tab parse error: [merge VFS and FS options]\"));\n\t\tgoto fail;\n\t}\n\n\treturn 0;\nfail:\n\tif (rc == 0)\n\t\trc = -EINVAL;\n\tDBG(TAB, ul_debug(\"tab parse error on: '%s' [rc=%d]\", s, rc));\n\treturn rc;\n}\n\n/*\n * Parses one line from utab file\n */\nstatic int mnt_parse_utab_line(struct libmnt_fs *fs, const char *s)\n{\n\tconst char *p = s;\n\n\tassert(fs);\n\tassert(s);\n\tassert(!fs->source);\n\tassert(!fs->target);\n\n\twhile (p && *p) {\n\t\tconst char *end = NULL;\n\n\t\twhile (*p == ' ') p++;\n\t\tif (!*p)\n\t\t\tbreak;\n\n\t\tif (!fs->source && !strncmp(p, \"SRC=\", 4)) {\n\t\t\tchar *v = unmangle(p + 4, &end);\n\t\t\tif (!v)\n\t\t\t\tgoto enomem;\n\t\t\tif (__mnt_fs_set_source_ptr(fs, v))\n\t\t\t\tfree(v);\n\n\t\t} else if (!fs->target && !strncmp(p, \"TARGET=\", 7)) {\n\t\t\tfs->target = unmangle(p + 7, &end);\n\t\t\tif (!fs->target)\n\t\t\t\tgoto enomem;\n\n\t\t} else if (!fs->root && !strncmp(p, \"ROOT=\", 5)) {\n\t\t\tfs->root = unmangle(p + 5, &end);\n\t\t\tif (!fs->root)\n\t\t\t\tgoto enomem;\n\n\t\t} else if (!fs->bindsrc && !strncmp(p, \"BINDSRC=\", 8)) {\n\t\t\tfs->bindsrc = unmangle(p + 8, &end);\n\t\t\tif (!fs->bindsrc)\n\t\t\t\tgoto enomem;\n\n\t\t} else if (!fs->user_optstr && !strncmp(p, \"OPTS=\", 5)) {\n\t\t\tfs->user_optstr = unmangle(p + 5, &end);\n\t\t\tif (!fs->user_optstr)\n\t\t\t\tgoto enomem;\n\n\t\t} else if (!fs->attrs && !strncmp(p, \"ATTRS=\", 6)) {\n\t\t\tfs->attrs = unmangle(p + 6, &end);\n\t\t\tif (!fs->attrs)\n\t\t\t\tgoto enomem;\n\n\t\t} else {\n\t\t\t/* unknown variable */\n\t\t\twhile (*p && *p != ' ') p++;\n\t\t}\n\t\tif (end)\n\t\t\tp = end;\n\t}\n\n\treturn 0;\nenomem:\n\tDBG(TAB, ul_debug(\"utab parse error: ENOMEM\"));\n\treturn -ENOMEM;\n}\n\n/*\n * Parses one line from /proc/swaps\n */\nstatic int mnt_parse_swaps_line(struct libmnt_fs *fs, const char *s)\n{\n\tuint64_t num;\n\tint rc = 0;\n\tchar *p;\n\n\t/* (1) source */\n\tp = unmangle(s, &s);\n\tif (p) {\n\t\tchar *x = (char *) endswith(p, PATH_DELETED_SUFFIX);\n\t\tif (x && *x)\n\t\t\t*x = '\\0';\n\t}\n\tif (!p || (rc = __mnt_fs_set_source_ptr(fs, p))) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [source]\"));\n\t\tfree(p);\n\t\tgoto fail;\n\t}\n\n\ts = skip_separator(s);\n\n\t/* (2) type */\n\tfs->swaptype = unmangle(s, &s);\n\tif (!fs->swaptype) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [swaptype]\"));\n\t\tgoto fail;\n\t}\n\n\ts = skip_separator(s);\n\n\t/* (3) size */\n\ts = next_u64(s, &num, &rc);\n\tif (!s || !*s || rc) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [size]\"));\n\t\tgoto fail;\n\t}\n\tfs->size = num;\n\n\ts = skip_separator(s);\n\n\t/* (4) size */\n\ts = next_u64(s, &num, &rc);\n\tif (!s || !*s || rc) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [used size]\"));\n\t\tgoto fail;\n\t}\n\tfs->usedsize = num;\n\n\ts = skip_separator(s);\n\n\t/* (5) priority */\n\ts = next_s32(s, &fs->priority, &rc);\n\tif (rc) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [priority]\"));\n\t\tgoto fail;\n\t}\n\n\tmnt_fs_set_fstype(fs, \"swap\");\n\treturn 0;\nfail:\n\tif (rc == 0)\n\t\trc = -EINVAL;\n\tDBG(TAB, ul_debug(\"tab parse error on: '%s' [rc=%d]\", s, rc));\n\treturn rc;\n}\n\n\n/*\n * Returns {m,fs}tab or mountinfo file format (MNT_FMT_*)\n *\n * Note that we aren't trying to guess the utab file format, because this file\n * always has to be parsed by private libmount routines with an explicitly defined\n * format.\n *\n * mountinfo: \"<number> <number> ... \"\n */\nstatic int guess_table_format(const char *line)\n{\n\tunsigned int a, b;\n\n\tDBG(TAB, ul_debug(\"trying to guess table type\"));\n\n\tif (sscanf(line, \"%u %u\", &a, &b) == 2)\n\t\treturn MNT_FMT_MOUNTINFO;\n\n\tif (strncmp(line, \"Filename\\t\", 9) == 0)\n\t\treturn MNT_FMT_SWAPS;\n\n\treturn MNT_FMT_FSTAB;\t\t/* fstab, mtab or /proc/mounts */\n}\n\nstatic int is_comment_line(const char *line)\n{\n\tconst char *p = skip_blank(line);\n\n\tif (p && (*p == '#' || *p == '\\n'))\n\t\treturn 1;\n\treturn 0;\n}\n\n/* returns 1 if the last line in the @str is blank */\nstatic int is_terminated_by_blank(const char *str)\n{\n\tsize_t sz = str ? strlen(str) : 0;\n\tconst char *p = sz ? str + (sz - 1) : NULL;\n\n\tif (!sz || !p || *p != '\\n')\n\t\treturn 0;\t\t/* empty or not terminated by '\\n' */\n\tif (p == str)\n\t\treturn 1;\t\t/* only '\\n' */\n\tp--;\n\twhile (p > str && (*p == ' ' || *p == '\\t'))\n\t\tp--;\n\treturn *p == '\\n' ? 1 : 0;\n}\n\n/*\n * Reads the next line from the file.\n *\n * Returns 0 if the line is a comment\n *         1 if the line is not a comment\n *        <0 on error\n */\nstatic int next_comment_line(struct libmnt_parser *pa, char **last)\n{\n\tif (getline(&pa->buf, &pa->bufsiz, pa->f) < 0)\n\t\treturn feof(pa->f) ? 1 : -errno;\n\n\tpa->line++;\n\t*last = strchr(pa->buf, '\\n');\n\n\treturn is_comment_line(pa->buf) ? 0 : 1;\n}\n\nstatic int append_comment(struct libmnt_table *tb,\n\t\t\t  struct libmnt_fs *fs,\n\t\t\t  const char *comm,\n\t\t\t  int eof)\n{\n\tint rc, intro = mnt_table_get_nents(tb) == 0;\n\n\tif (intro && is_terminated_by_blank(mnt_table_get_intro_comment(tb)))\n\t\tintro = 0;\n\n\tDBG(TAB, ul_debugobj(tb, \"appending %s comment\",\n\t\t\tintro ? \"intro\" :\n\t\t\teof ? \"trailing\" : \"fs\"));\n\tif (intro)\n\t\trc = mnt_table_append_intro_comment(tb, comm);\n\telse if (eof) {\n\t\trc = mnt_table_set_trailing_comment(tb,\n\t\t\t\tmnt_fs_get_comment(fs));\n\t\tif (!rc)\n\t\t\trc = mnt_table_append_trailing_comment(tb, comm);\n\t\tif (!rc)\n\t\t\trc = mnt_fs_set_comment(fs, NULL);\n\t} else\n\t\trc = mnt_fs_append_comment(fs, comm);\n\treturn rc;\n}\n\n/*\n * Read and parse the next line from {fs,m}tab or mountinfo\n */\nstatic int mnt_table_parse_next(struct libmnt_parser *pa,\n\t\t\t\tstruct libmnt_table *tb,\n\t\t\t\tstruct libmnt_fs *fs)\n{\n\tchar *s;\n\tint rc;\n\n\tassert(tb);\n\tassert(pa);\n\tassert(fs);\n\n\t/* read the next non-blank non-comment line */\nnext_line:\n\tdo {\n\t\tif (getline(&pa->buf, &pa->bufsiz, pa->f) < 0)\n\t\t\treturn -EINVAL;\n\t\tpa->line++;\n\t\ts = strchr(pa->buf, '\\n');\n\t\tif (!s) {\n\t\t\tDBG(TAB, ul_debugobj(tb, \"%s:%zu: no final newline\",\n\t\t\t\t\t\tpa->filename, pa->line));\n\n\t\t\t/* Missing final newline?  Otherwise an extremely */\n\t\t\t/* long line - assume file was corrupted */\n\t\t\tif (feof(pa->f))\n\t\t\t\ts = memchr(pa->buf, '\\0', pa->bufsiz);\n\n\t\t/* comments parser */\n\t\t} else if (tb->comms\n\t\t    && (tb->fmt == MNT_FMT_GUESS || tb->fmt == MNT_FMT_FSTAB)\n\t\t    && is_comment_line(pa->buf)) {\n\t\t\tdo {\n\t\t\t\trc = append_comment(tb, fs, pa->buf, feof(pa->f));\n\t\t\t\tif (!rc)\n\t\t\t\t\trc = next_comment_line(pa, &s);\n\t\t\t} while (rc == 0);\n\n\t\t\tif (rc == 1 && feof(pa->f))\n\t\t\t\trc = append_comment(tb, fs, NULL, 1);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\n\t\t}\n\n\t\tif (!s)\n\t\t\tgoto err;\n\t\t*s = '\\0';\n\t\tif (s > pa->buf && *(s - 1)  == '\\r')\n\t\t\t*(--s) = '\\0';\n\t\ts = (char *) skip_blank(pa->buf);\n\t} while (*s == '\\0' || *s == '#');\n\n\tif (tb->fmt == MNT_FMT_GUESS) {\n\t\ttb->fmt = guess_table_format(s);\n\t\tif (tb->fmt == MNT_FMT_SWAPS)\n\t\t\tgoto next_line;\t\t\t/* skip swap header */\n\t}\n\n\tswitch (tb->fmt) {\n\tcase MNT_FMT_FSTAB:\n\t\trc = mnt_parse_table_line(fs, s);\n\t\tbreak;\n\tcase MNT_FMT_MOUNTINFO:\n\t\trc = mnt_parse_mountinfo_line(fs, s);\n\t\tbreak;\n\tcase MNT_FMT_UTAB:\n\t\trc = mnt_parse_utab_line(fs, s);\n\t\tbreak;\n\tcase MNT_FMT_SWAPS:\n\t\tif (strncmp(s, \"Filename\\t\", 9) == 0)\n\t\t\tgoto next_line;\t\t\t/* skip swap header */\n\t\trc = mnt_parse_swaps_line(fs, s);\n\t\tbreak;\n\tdefault:\n\t\trc = -1;\t/* unknown format */\n\t\tbreak;\n\t}\n\n\tif (rc == 0)\n\t\treturn 0;\nerr:\n\tDBG(TAB, ul_debugobj(tb, \"%s:%zu: %s parse error\", pa->filename, pa->line,\n\t\t\t\ttb->fmt == MNT_FMT_MOUNTINFO ? \"mountinfo\" :\n\t\t\t\ttb->fmt == MNT_FMT_SWAPS ? \"swaps\" :\n\t\t\t\ttb->fmt == MNT_FMT_FSTAB ? \"tab\" : \"utab\"));\n\n\t/* by default all errors are recoverable, otherwise behavior depends on\n\t * the errcb() function. See mnt_table_set_parser_errcb().\n\t */\n\treturn tb->errcb ? tb->errcb(tb, pa->filename, pa->line) : 1;\n}\n\nstatic pid_t path_to_tid(const char *filename)\n{\n\tchar *path = mnt_resolve_path(filename, NULL);\n\tchar *p, *end = NULL;\n\tpid_t tid = 0;\n\n\tif (!path)\n\t\tgoto done;\n\tp = strrchr(path, '/');\n\tif (!p)\n\t\tgoto done;\n\t*p = '\\0';\n\tp = strrchr(path, '/');\n\tif (!p)\n\t\tgoto done;\n\tp++;\n\n\terrno = 0;\n\ttid = strtol(p, &end, 10);\n\tif (errno || p == end || (end && *end)) {\n\t\ttid = 0;\n\t\tgoto done;\n\t}\n\tDBG(TAB, ul_debug(\"TID for %s is %d\", filename, tid));\ndone:\n\tfree(path);\n\treturn tid;\n}\n\nstatic int kernel_fs_postparse(struct libmnt_table *tb,\n\t\t\t       struct libmnt_fs *fs, pid_t *tid,\n\t\t\t       const char *filename)\n{\n\tint rc = 0;\n\tconst char *src = mnt_fs_get_srcpath(fs);\n\n\t/* This is a filesystem description from /proc, so we're in some process\n\t * namespace. Let's remember the process PID.\n\t */\n\tif (filename && *tid == -1)\n\t\t*tid = path_to_tid(filename);\n\n\tfs->tid = *tid;\n\n\t/*\n\t * Convert obscure /dev/root to something more usable\n\t */\n\tif (src && strcmp(src, \"/dev/root\") == 0) {\n\t\tchar *real = NULL;\n\n\t\trc = mnt_guess_system_root(fs->devno, tb->cache, &real);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tif (rc == 0 && real) {\n\t\t\tDBG(TAB, ul_debugobj(tb, \"canonical root FS: %s\", real));\n\t\t\trc = __mnt_fs_set_source_ptr(fs, real);\n\n\t\t} else if (rc == 1) {\n\t\t\t/* mnt_guess_system_root() returns 1 if not able to convert to\n\t\t\t * the real devname; ignore this problem */\n\t\t\trc = 0;\n\t\t}\n\t}\n\n\treturn rc;\n}\n\n/**\n * mnt_table_parse_stream:\n * @tb: tab pointer\n * @f: file stream\n * @filename: filename used for debug and error messages\n *\n * Returns: 0 on success, negative number in case of error.\n */\nint mnt_table_parse_stream(struct libmnt_table *tb, FILE *f, const char *filename)\n{\n\tint rc = -1;\n\tint flags = 0;\n\tpid_t tid = -1;\n\tstruct libmnt_parser pa = { .line = 0 };\n\n\tassert(tb);\n\tassert(f);\n\tassert(filename);\n\n\tDBG(TAB, ul_debugobj(tb, \"%s: start parsing [entries=%d, filter=%s]\",\n\t\t\t\tfilename, mnt_table_get_nents(tb),\n\t\t\t\ttb->fltrcb ? \"yes\" : \"not\"));\n\n\tpa.filename = filename;\n\tpa.f = f;\n\n\t/* necessary for /proc/mounts only, the /proc/self/mountinfo\n\t * parser sets the flag properly\n\t */\n\tif (tb->fmt == MNT_FMT_SWAPS)\n\t\tflags = MNT_FS_SWAP;\n\telse if (filename && strcmp(filename, _PATH_PROC_MOUNTS) == 0)\n\t\tflags = MNT_FS_KERNEL;\n\n\tdo {\n\t\tstruct libmnt_fs *fs;\n\n\t\tif (feof(f)) {\n\t\t\tDBG(TAB, ul_debugobj(tb, \"end-of-file\"));\n\t\t\tbreak;\n\t\t}\n\t\tfs = mnt_new_fs();\n\t\tif (!fs)\n\t\t\tgoto err;\n\n\t\t/* parse */\n\t\trc = mnt_table_parse_next(&pa, tb, fs);\n\n\t\tif (rc == 0 && tb->fltrcb && tb->fltrcb(fs, tb->fltrcb_data))\n\t\t\trc = 1;\t/* filtered out by callback... */\n\n\t\t/* add to the table */\n\t\tif (rc == 0) {\n\t\t\trc = mnt_table_add_fs(tb, fs);\n\t\t\tfs->flags |= flags;\n\n\t\t\tif (rc == 0 && tb->fmt == MNT_FMT_MOUNTINFO) {\n\t\t\t\trc = kernel_fs_postparse(tb, fs, &tid, filename);\n\t\t\t\tif (rc)\n\t\t\t\t\tmnt_table_remove_fs(tb, fs);\n\t\t\t}\n\t\t}\n\n\t\t/* remove reference (or deallocate on error) */\n\t\tmnt_unref_fs(fs);\n\n\t\t/* recoverable error */\n\t\tif (rc > 0) {\n\t\t\tDBG(TAB, ul_debugobj(tb, \"recoverable error (continue)\"));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* fatal errors */\n\t\tif (rc < 0 && !feof(f)) {\n\t\t\tDBG(TAB, ul_debugobj(tb, \"fatal error\"));\n\t\t\tgoto err;\n\t\t}\n\t} while (1);\n\n\tDBG(TAB, ul_debugobj(tb, \"%s: stop parsing (%d entries)\",\n\t\t\t\tfilename, mnt_table_get_nents(tb)));\n\tparser_cleanup(&pa);\n\treturn 0;\nerr:\n\tDBG(TAB, ul_debugobj(tb, \"%s: parse error (rc=%d)\", filename, rc));\n\tparser_cleanup(&pa);\n\treturn rc;\n}\n\n/**\n * mnt_table_parse_file:\n * @tb: tab pointer\n * @filename: file\n *\n * Parses the whole table (e.g. /etc/fstab) and appends new records to the @tab.\n *\n * The libmount parser ignores broken (syntax error) lines, these lines are\n * reported to the caller by the errcb() function (see mnt_table_set_parser_errcb()).\n *\n * Returns: 0 on success, negative number in case of error.\n */\nint mnt_table_parse_file(struct libmnt_table *tb, const char *filename)\n{\n\tFILE *f;\n\tint rc;\n\n\tif (!filename || !tb)\n\t\treturn -EINVAL;\n\n\tf = fopen(filename, \"r\" UL_CLOEXECSTR);\n\tif (f) {\n\t\trc = mnt_table_parse_stream(tb, f, filename);\n\t\tfclose(f);\n\t} else\n\t\trc = -errno;\n\n\tDBG(TAB, ul_debugobj(tb, \"parsing done [filename=%s, rc=%d]\", filename, rc));\n\treturn rc;\n}\n\nstatic int mnt_table_parse_dir_filter(const struct dirent *d)\n{\n\tsize_t namesz;\n\n#ifdef _DIRENT_HAVE_D_TYPE\n\tif (d->d_type != DT_UNKNOWN && d->d_type != DT_REG &&\n\t    d->d_type != DT_LNK)\n\t\treturn 0;\n#endif\n\tif (*d->d_name == '.')\n\t\treturn 0;\n\n#define MNT_MNTTABDIR_EXTSIZ\t(sizeof(MNT_MNTTABDIR_EXT) - 1)\n\n\tnamesz = strlen(d->d_name);\n\tif (!namesz || namesz < MNT_MNTTABDIR_EXTSIZ + 1 ||\n\t    strcmp(d->d_name + (namesz - MNT_MNTTABDIR_EXTSIZ),\n\t\t   MNT_MNTTABDIR_EXT) != 0)\n\t\treturn 0;\n\n\t/* Accept this */\n\treturn 1;\n}\n\n#ifdef HAVE_SCANDIRAT\nstatic int __mnt_table_parse_dir(struct libmnt_table *tb, const char *dirname)\n{\n\tint n = 0, i;\n\tint dd;\n\tstruct dirent **namelist = NULL;\n\n\tdd = open(dirname, O_RDONLY|O_CLOEXEC|O_DIRECTORY);\n\tif (dd < 0)\n\t        return -errno;\n\n\tn = scandirat(dd, \".\", &namelist, mnt_table_parse_dir_filter, versionsort);\n\tif (n <= 0) {\n\t        close(dd);\n\t        return 0;\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\t\tstruct dirent *d = namelist[i];\n\t\tstruct stat st;\n\t\tFILE *f;\n\n\t\tif (fstatat(dd, d->d_name, &st, 0) ||\n\t\t    !S_ISREG(st.st_mode))\n\t\t\tcontinue;\n\n\t\tf = fopen_at(dd, d->d_name, O_RDONLY|O_CLOEXEC, \"r\" UL_CLOEXECSTR);\n\t\tif (f) {\n\t\t\tmnt_table_parse_stream(tb, f, d->d_name);\n\t\t\tfclose(f);\n\t\t}\n\t}\n\n\tfor (i = 0; i < n; i++)\n\t\tfree(namelist[i]);\n\tfree(namelist);\n\tclose(dd);\n\treturn 0;\n}\n#else\nstatic int __mnt_table_parse_dir(struct libmnt_table *tb, const char *dirname)\n{\n\tint n = 0, i, r = 0;\n\tDIR *dir = NULL;\n\tstruct dirent **namelist = NULL;\n\n\tn = scandir(dirname, &namelist, mnt_table_parse_dir_filter, versionsort);\n\tif (n <= 0)\n\t\treturn 0;\n\n\t/* let's use \"at\" functions rather than playing crazy games with paths... */\n\tdir = opendir(dirname);\n\tif (!dir) {\n\t\tr = -errno;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\t\tstruct dirent *d = namelist[i];\n\t\tstruct stat st;\n\t\tFILE *f;\n\n\t\tif (fstatat(dirfd(dir), d->d_name, &st, 0) ||\n\t\t    !S_ISREG(st.st_mode))\n\t\t\tcontinue;\n\n\t\tf = fopen_at(dirfd(dir), d->d_name,\n\t\t\t\tO_RDONLY|O_CLOEXEC, \"r\" UL_CLOEXECSTR);\n\t\tif (f) {\n\t\t\tmnt_table_parse_stream(tb, f, d->d_name);\n\t\t\tfclose(f);\n\t\t}\n\t}\n\nout:\n\tfor (i = 0; i < n; i++)\n\t\tfree(namelist[i]);\n\tfree(namelist);\n\tif (dir)\n\t\tclosedir(dir);\n\treturn r;\n}\n#endif\n\n/**\n * mnt_table_parse_dir:\n * @tb: mount table\n * @dirname: directory\n *\n * The directory:\n *\t- files are sorted by strverscmp(3)\n *\t- files that start with \".\" are ignored (e.g. \".10foo.fstab\")\n *\t- files without the \".fstab\" extension are ignored\n *\n * Returns: 0 on success or negative number in case of error.\n */\nint mnt_table_parse_dir(struct libmnt_table *tb, const char *dirname)\n{\n\treturn __mnt_table_parse_dir(tb, dirname);\n}\n\nstruct libmnt_table *__mnt_new_table_from_file(const char *filename, int fmt, int empty_for_enoent)\n{\n\tstruct libmnt_table *tb;\n\tstruct stat st;\n\n\tif (!filename)\n\t\treturn NULL;\n\tif (stat(filename, &st))\n\t\treturn empty_for_enoent ? mnt_new_table() : NULL;\n\n\ttb = mnt_new_table();\n\tif (tb) {\n\t\tDBG(TAB, ul_debugobj(tb, \"new tab for file: %s\", filename));\n\t\ttb->fmt = fmt;\n\t\tif (mnt_table_parse_file(tb, filename) != 0) {\n\t\t\tmnt_unref_table(tb);\n\t\t\ttb = NULL;\n\t\t}\n\t}\n\treturn tb;\n}\n\n/**\n * mnt_new_table_from_file:\n * @filename: /etc/{m,fs}tab or /proc/self/mountinfo path\n *\n * Same as mnt_new_table() + mnt_table_parse_file(). Use this function for private\n * files only. This function does not allow using the error callback, so you\n * cannot provide any feedback to end-users about broken records in files (e.g.\n * fstab).\n *\n * Returns: newly allocated tab on success and NULL in case of error.\n */\nstruct libmnt_table *mnt_new_table_from_file(const char *filename)\n{\n\tif (!filename)\n\t\treturn NULL;\n\n\treturn __mnt_new_table_from_file(filename, MNT_FMT_GUESS, 0);\n}\n\n/**\n * mnt_new_table_from_dir\n * @dirname: directory with *.fstab files\n *\n * Returns: newly allocated tab on success and NULL in case of error.\n */\nstruct libmnt_table *mnt_new_table_from_dir(const char *dirname)\n{\n\tstruct libmnt_table *tb;\n\n\tif (!dirname)\n\t\treturn NULL;\n\ttb = mnt_new_table();\n\tif (tb && mnt_table_parse_dir(tb, dirname) != 0) {\n\t\tmnt_unref_table(tb);\n\t\ttb = NULL;\n\t}\n\treturn tb;\n}\n\n/**\n * mnt_table_set_parser_errcb:\n * @tb: pointer to table\n * @cb: pointer to callback function\n *\n * The error callback function is called by table parser (mnt_table_parse_file())\n * in case of a syntax error. The callback function could be used for error\n * evaluation, libmount will continue/stop parsing according to callback return\n * codes:\n *\n *   <0  : fatal error (abort parsing)\n *    0\t : success (parsing continues)\n *   >0  : recoverable error (the line is ignored, parsing continues).\n *\n * Returns: 0 on success or negative number in case of error.\n */\nint mnt_table_set_parser_errcb(struct libmnt_table *tb,\n\t\tint (*cb)(struct libmnt_table *tb, const char *filename, int line))\n{\n\tif (!tb)\n\t\treturn -EINVAL;\n\ttb->errcb = cb;\n\treturn 0;\n}\n\n/*\n * Filter out entries during tab file parsing. If @cb returns 1, then the entry\n * is ignored.\n */\nint mnt_table_set_parser_fltrcb(struct libmnt_table *tb,\n\t\tint (*cb)(struct libmnt_fs *, void *),\n\t\tvoid *data)\n{\n\tif (!tb)\n\t\treturn -EINVAL;\n\n\tDBG(TAB, ul_debugobj(tb, \"%s table parser filter\", cb ? \"set\" : \"unset\"));\n\ttb->fltrcb = cb;\n\ttb->fltrcb_data = data;\n\treturn 0;\n}\n\n/**\n * mnt_table_parse_swaps:\n * @tb: table\n * @filename: overwrites default (/proc/swaps or $LIBMOUNT_SWAPS) or NULL\n *\n * This function parses /proc/swaps and appends new lines to the @tab.\n *\n * See also mnt_table_set_parser_errcb().\n *\n * Returns: 0 on success or negative number in case of error.\n */\nint mnt_table_parse_swaps(struct libmnt_table *tb, const char *filename)\n{\n\tif (!tb)\n\t\treturn -EINVAL;\n\tif (!filename) {\n\t\tfilename = mnt_get_swaps_path();\n\t\tif (!filename)\n\t\t\treturn -EINVAL;\n\t}\n\n\ttb->fmt = MNT_FMT_SWAPS;\n\n\treturn mnt_table_parse_file(tb, filename);\n}\n\n/**\n * mnt_table_parse_fstab:\n * @tb: table\n * @filename: overwrites default (/etc/fstab or $LIBMOUNT_FSTAB) or NULL\n *\n * This function parses /etc/fstab and appends new lines to the @tab. If the\n * @filename is a directory, then mnt_table_parse_dir() is called.\n *\n * See also mnt_table_set_parser_errcb().\n *\n * Returns: 0 on success or negative number in case of error.\n */\nint mnt_table_parse_fstab(struct libmnt_table *tb, const char *filename)\n{\n\tstruct stat st;\n\tint rc = 0;\n\n\tif (!tb)\n\t\treturn -EINVAL;\n\tif (!filename)\n\t\tfilename = mnt_get_fstab_path();\n\tif (!filename)\n\t\treturn -EINVAL;\n\tif (stat(filename, &st) != 0)\n\t\treturn -errno;\n\n\ttb->fmt = MNT_FMT_FSTAB;\n\n\tif (S_ISREG(st.st_mode))\n\t\trc = mnt_table_parse_file(tb, filename);\n\telse if (S_ISDIR(st.st_mode))\n\t\trc = mnt_table_parse_dir(tb, filename);\n\telse\n\t\trc = -EINVAL;\n\n\treturn rc;\n}\n\n/*\n * This function uses @uf to find a corresponding record in @tb, then the record\n * from @tb is updated (user specific mount options are added).\n *\n * Note that @uf must contain only user specific mount options instead of\n * VFS options (note that FS options are ignored).\n *\n * Returns modified filesystem (from @tb) or NULL.\n */\nstatic struct libmnt_fs *mnt_table_merge_user_fs(struct libmnt_table *tb, struct libmnt_fs *uf)\n{\n\tstruct libmnt_fs *fs;\n\tstruct libmnt_iter itr;\n\tconst char *optstr, *src, *target, *root, *attrs;\n\n\tif (!tb || !uf)\n\t\treturn NULL;\n\n\tDBG(TAB, ul_debugobj(tb, \"merging user fs\"));\n\n\tsrc = mnt_fs_get_srcpath(uf);\n\ttarget = mnt_fs_get_target(uf);\n\toptstr = mnt_fs_get_user_options(uf);\n\tattrs = mnt_fs_get_attributes(uf);\n\troot = mnt_fs_get_root(uf);\n\n\tif (!src || !target || !root || (!attrs && !optstr))\n\t\treturn NULL;\n\n\tmnt_reset_iter(&itr, MNT_ITER_BACKWARD);\n\n\twhile(mnt_table_next_fs(tb, &itr, &fs) == 0) {\n\t\tconst char *r = mnt_fs_get_root(fs);\n\n\t\tif (fs->flags & MNT_FS_MERGED)\n\t\t\tcontinue;\n\n\t\tif (r && strcmp(r, root) == 0\n\t\t    && mnt_fs_streq_target(fs, target)\n\t\t    && mnt_fs_streq_srcpath(fs, src))\n\t\t\tbreak;\n\t}\n\n\tif (fs) {\n\t\tDBG(TAB, ul_debugobj(tb, \"found fs -- appending user optstr\"));\n\t\tmnt_fs_append_options(fs, optstr);\n\t\tmnt_fs_append_attributes(fs, attrs);\n\t\tmnt_fs_set_bindsrc(fs, mnt_fs_get_bindsrc(uf));\n\t\tfs->flags |= MNT_FS_MERGED;\n\n\t\tDBG(TAB, ul_debugobj(tb, \"found fs:\"));\n\t\tDBG(TAB, mnt_fs_print_debug(fs, stderr));\n\t}\n\treturn fs;\n}\n\n/* default filename is /proc/self/mountinfo\n */\nint __mnt_table_parse_mtab(struct libmnt_table *tb, const char *filename,\n\t\t\t   struct libmnt_table *u_tb)\n{\n\tint rc = 0, priv_utab = 0;\n\tint explicit_file = filename ? 1 : 0;\n\n\tassert(tb);\n\n\tif (filename)\n\t\tDBG(TAB, ul_debugobj(tb, \"%s requested as mtab\", filename));\n\n#ifdef USE_LIBMOUNT_SUPPORT_MTAB\n\tif (mnt_has_regular_mtab(&filename, NULL)) {\n\n\t\tDBG(TAB, ul_debugobj(tb, \"force mtab usage [filename=%s]\", filename));\n\n\t\trc = mnt_table_parse_file(tb, filename);\n\n\t\t/*\n\t\t * If @filename forces us to read from /proc then also read\n\t\t * utab file to merge userspace mount options.\n\t\t */\n\t\tif (rc == 0 && is_mountinfo(tb))\n\t\t\tgoto read_utab;\n\n\t\tif (!rc)\n\t\t\treturn 0;\n\t\tfilename = NULL;\t/* failed */\n\t} else\n\t\tfilename = NULL;\t/* mtab useless */\n#endif\n\n\tif (!filename || strcmp(filename, _PATH_PROC_MOUNTINFO) == 0) {\n\t\tfilename = _PATH_PROC_MOUNTINFO;\n\t\ttb->fmt = MNT_FMT_MOUNTINFO;\n\t\tDBG(TAB, ul_debugobj(tb, \"mtab parse: #1 read mountinfo\"));\n\t} else\n\t\ttb->fmt = MNT_FMT_GUESS;\n\n\trc = mnt_table_parse_file(tb, filename);\n\tif (rc) {\n\t\tif (explicit_file)\n\t\t\treturn rc;\n\n\t\t/* hmm, old kernel? ...try /proc/mounts */\n\t\ttb->fmt = MNT_FMT_MTAB;\n\t\treturn mnt_table_parse_file(tb, _PATH_PROC_MOUNTS);\n\t}\n\n\tif (!is_mountinfo(tb))\n\t\treturn 0;\n#ifdef USE_LIBMOUNT_SUPPORT_MTAB\nread_utab:\n#endif\n\tDBG(TAB, ul_debugobj(tb, \"mtab parse: #2 read utab\"));\n\n\tif (mnt_table_get_nents(tb) == 0)\n\t\treturn 0;\t\t\t/* empty, ignore utab */\n\t/*\n\t * try to read the user specific information from /run/mount/utabs\n\t */\n\tif (!u_tb) {\n\t\tconst char *utab = mnt_get_utab_path();\n\n\t\tif (!utab || is_file_empty(utab))\n\t\t\treturn 0;\n\n\t\tu_tb = mnt_new_table();\n\t\tif (!u_tb)\n\t\t\treturn -ENOMEM;\n\n\t\tu_tb->fmt = MNT_FMT_UTAB;\n\t\tmnt_table_set_parser_fltrcb(u_tb, tb->fltrcb, tb->fltrcb_data);\n\n\t\trc = mnt_table_parse_file(u_tb, utab);\n\t\tpriv_utab = 1;\n\t}\n\n\tDBG(TAB, ul_debugobj(tb, \"mtab parse: #3 merge utab\"));\n\n\tif (rc == 0) {\n\t\tstruct libmnt_fs *u_fs;\n\t\tstruct libmnt_iter itr;\n\n\t\tmnt_reset_iter(&itr, MNT_ITER_BACKWARD);\n\n\t\t/*  merge user options into mountinfo from the kernel */\n\t\twhile(mnt_table_next_fs(u_tb, &itr, &u_fs) == 0)\n\t\t\tmnt_table_merge_user_fs(tb, u_fs);\n\t}\n\n\n\tif (priv_utab)\n\t\tmnt_unref_table(u_tb);\n\treturn 0;\n}\n/**\n * mnt_table_parse_mtab:\n * @tb: table\n * @filename: overwrites default or NULL\n *\n * The default filename is /proc/self/mountinfo. If the mount table is a\n * mountinfo file then /run/mount/utabs is parsed too and both files are merged\n * to the one libmnt_table.\n *\n * If libmount is compiled with classic mtab file support, and the /etc/mtab is\n * a regular file then this file is parsed.\n *\n * It's strongly recommended to use NULL as a @filename to keep code portable.\n *\n * See also mnt_table_set_parser_errcb().\n *\n * Returns: 0 on success or negative number in case of error.\n */\nint mnt_table_parse_mtab(struct libmnt_table *tb, const char *filename)\n{\n\treturn __mnt_table_parse_mtab(tb, filename, NULL);\n}\n", "/*\n * findmnt(8)\n *\n * Copyright (C) 2010-2015 Red Hat, Inc. All rights reserved.\n * Written by Karel Zak <kzak@redhat.com>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it would be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <getopt.h>\n#include <string.h>\n#include <termios.h>\n#ifdef HAVE_SYS_IOCTL_H\n# include <sys/ioctl.h>\n#endif\n#include <assert.h>\n#include <poll.h>\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#ifdef HAVE_LIBUDEV\n# include <libudev.h>\n#endif\n#include <blkid.h>\n#include <libmount.h>\n#include <libsmartcols.h>\n\n#include \"pathnames.h\"\n#include \"nls.h\"\n#include \"closestream.h\"\n#include \"c.h\"\n#include \"strutils.h\"\n#include \"xalloc.h\"\n#include \"optutils.h\"\n#include \"mangle.h\"\n#include \"buffer.h\"\n\n#include \"findmnt.h\"\n\n/* column IDs */\nenum {\n\tCOL_ACTION,\n\tCOL_AVAIL,\n\tCOL_DELETED,\n\tCOL_FREQ,\n\tCOL_FSROOT,\n\tCOL_FSTYPE,\n\tCOL_FS_OPTIONS,\n\tCOL_ID,\n\tCOL_LABEL,\n\tCOL_MAJMIN,\n\tCOL_OLD_OPTIONS,\n\tCOL_OLD_TARGET,\n\tCOL_OPTIONS,\n\tCOL_OPT_FIELDS,\n\tCOL_PARENT,\n\tCOL_PARTLABEL,\n\tCOL_PARTUUID,\n\tCOL_PASSNO,\n\tCOL_PROPAGATION,\n\tCOL_SIZE,\n\tCOL_SOURCE,\n\tCOL_SOURCES,\n\tCOL_TARGET,\n\tCOL_TID,\n\tCOL_USED,\n\tCOL_USEPERC,\n\tCOL_UUID,\n\tCOL_VFS_OPTIONS\n};\n\nenum {\n\tTABTYPE_FSTAB = 1,\n\tTABTYPE_MTAB,\n\tTABTYPE_KERNEL\n};\n\n/* column names */\nstruct colinfo {\n\tconst char\t*name;\t\t/* header */\n\tdouble\t\twhint;\t\t/* width hint (N < 1 is in percent of termwidth) */\n\tint\t\tflags;\t\t/* libsmartcols flags */\n\tconst char      *help;\t\t/* column description */\n\tconst char\t*match;\t\t/* pattern for match_func() */\n\tvoid\t\t*match_data;\t/* match specific data */\n};\n\n/* columns descriptions (don't use const, this is writable) */\nstatic struct colinfo infos[] = {\n\t[COL_ACTION]       = { \"ACTION\",         10, SCOLS_FL_STRICTWIDTH, N_(\"action detected by --poll\") },\n\t[COL_AVAIL]        = { \"AVAIL\",           5, SCOLS_FL_RIGHT, N_(\"filesystem size available\") },\n\t[COL_DELETED]      = { \"DELETED\",         1, SCOLS_FL_RIGHT, N_(\"filesystem target marked as deleted\") },\n\t[COL_FREQ]         = { \"FREQ\",            1, SCOLS_FL_RIGHT, N_(\"dump(8) period in days [fstab only]\") },\n\t[COL_FSROOT]       = { \"FSROOT\",       0.25, SCOLS_FL_NOEXTREMES, N_(\"filesystem root\") },\n\t[COL_FSTYPE]       = { \"FSTYPE\",       0.10, SCOLS_FL_TRUNC, N_(\"filesystem type\") },\n\t[COL_FS_OPTIONS]   = { \"FS-OPTIONS\",   0.10, SCOLS_FL_TRUNC, N_(\"FS specific mount options\") },\n\t[COL_ID]           = { \"ID\",              2, SCOLS_FL_RIGHT, N_(\"mount ID\") },\n\t[COL_LABEL]        = { \"LABEL\",        0.10, 0, N_(\"filesystem label\") },\n\t[COL_MAJMIN]       = { \"MAJ:MIN\",         6, 0, N_(\"major:minor device number\") },\n\t[COL_OLD_OPTIONS]  = { \"OLD-OPTIONS\",  0.10, SCOLS_FL_TRUNC, N_(\"old mount options saved by --poll\") },\n\t[COL_OLD_TARGET]   = { \"OLD-TARGET\",   0.30, 0, N_(\"old mountpoint saved by --poll\") },\n\t[COL_OPTIONS]      = { \"OPTIONS\",      0.10, SCOLS_FL_TRUNC, N_(\"all mount options\") },\n\t[COL_OPT_FIELDS]   = { \"OPT-FIELDS\",   0.10, SCOLS_FL_TRUNC, N_(\"optional mount fields\") },\n\t[COL_PARENT]       = { \"PARENT\",          2, SCOLS_FL_RIGHT, N_(\"mount parent ID\") },\n\t[COL_PARTLABEL]    = { \"PARTLABEL\",    0.10, 0, N_(\"partition label\") },\n\t[COL_PARTUUID]     = { \"PARTUUID\",       36, 0, N_(\"partition UUID\") },\n\t[COL_PASSNO]       = { \"PASSNO\",          1, SCOLS_FL_RIGHT, N_(\"pass number on parallel fsck(8) [fstab only]\") },\n\t[COL_PROPAGATION]  = { \"PROPAGATION\",  0.10, 0, N_(\"VFS propagation flags\") },\n\t[COL_SIZE]         = { \"SIZE\",            5, SCOLS_FL_RIGHT, N_(\"filesystem size\") },\n\t[COL_SOURCES]      = { \"SOURCES\",      0.25, SCOLS_FL_WRAP, N_(\"all possible source devices [fstab only]\") },\n\t[COL_SOURCE]       = { \"SOURCE\",       0.25, SCOLS_FL_NOEXTREMES, N_(\"source device\") },\n\t[COL_TARGET]       = { \"TARGET\",       0.30, SCOLS_FL_TREE| SCOLS_FL_NOEXTREMES, N_(\"mountpoint\") },\n\t[COL_TID]          = { \"TID\",             4, SCOLS_FL_RIGHT, N_(\"task ID\") },\n\t[COL_USED]         = { \"USED\",            5, SCOLS_FL_RIGHT, N_(\"filesystem size used\") },\n\t[COL_USEPERC]      = { \"USE%\",            3, SCOLS_FL_RIGHT, N_(\"filesystem use percentage\") },\n\t[COL_UUID]         = { \"UUID\",           36, 0, N_(\"filesystem UUID\") },\n\t[COL_VFS_OPTIONS]  = { \"VFS-OPTIONS\",  0.20, SCOLS_FL_TRUNC, N_(\"VFS specific mount options\") }\n};\n\n/* columns[] array specifies all currently wanted output column. The columns\n * are defined by infos[] array and you can specify (on command line) each\n * column twice. That's enough, dynamically allocated array of the columns is\n * unnecessary overkill and over-engineering in this case */\nstatic int columns[ARRAY_SIZE(infos) * 2];\nstatic size_t ncolumns;\n\nstatic inline size_t err_columns_index(size_t arysz, size_t idx)\n{\n\tif (idx >= arysz)\n\t\terrx(EXIT_FAILURE, _(\"too many columns specified, \"\n\t\t\t\t     \"the limit is %zu columns\"),\n\t\t\t\tarysz - 1);\n\treturn idx;\n}\n\n#define add_column(ary, n, id)\t\\\n\t\t((ary)[ err_columns_index(ARRAY_SIZE(ary), (n)) ] = (id))\n\n/* poll actions (parsed --poll=<list> */\n#define FINDMNT_NACTIONS\t4\t\t/* mount, umount, move, remount */\nstatic int actions[FINDMNT_NACTIONS];\nstatic int nactions;\n\n/* global (accessed from findmnt-verify.c too) */\nunsigned int flags;\nint parse_nerrors;\nstruct libmnt_cache *cache;\n\n\n#ifdef HAVE_LIBUDEV\nstatic struct udev *udev;\n#endif\n\nstatic int match_func(struct libmnt_fs *fs, void *data __attribute__ ((__unused__)));\n\n\nstatic int get_column_id(int num)\n{\n\tassert(num >= 0);\n\tassert((size_t) num < ncolumns);\n\tassert((size_t) columns[num] < ARRAY_SIZE(infos));\n\treturn columns[num];\n}\n\nstatic struct colinfo *get_column_info(int num)\n{\n\treturn &infos[ get_column_id(num) ];\n}\n\nstatic const char *column_id_to_name(int id)\n{\n\tassert((size_t) id < ARRAY_SIZE(infos));\n\treturn infos[id].name;\n}\n\nstatic const char *get_column_name(int num)\n{\n\treturn get_column_info(num)->name;\n}\n\nstatic float get_column_whint(int num)\n{\n\treturn get_column_info(num)->whint;\n}\n\nstatic int get_column_flags(int num)\n{\n\treturn get_column_info(num)->flags;\n}\n\nstatic const char *get_match(int id)\n{\n\tassert((size_t) id < ARRAY_SIZE(infos));\n\treturn infos[id].match;\n}\n\nstatic void *get_match_data(int id)\n{\n\tassert((size_t) id < ARRAY_SIZE(infos));\n\treturn infos[id].match_data;\n}\n\nstatic void set_match(int id, const char *match)\n{\n\tassert((size_t) id < ARRAY_SIZE(infos));\n\tinfos[id].match = match;\n}\n\nstatic void set_match_data(int id, void *data)\n{\n\tassert((size_t) id < ARRAY_SIZE(infos));\n\tinfos[id].match_data = data;\n}\n\n/*\n * source match means COL_SOURCE *or* COL_MAJMIN, depends on\n * data format.\n */\nstatic void set_source_match(const char *data)\n{\n\tint maj, min;\n\n\tif (sscanf(data, \"%d:%d\", &maj, &min) == 2) {\n\t\tdev_t *devno = xmalloc(sizeof(dev_t));\n\n\t\t*devno = makedev(maj, min);\n\t\tset_match(COL_MAJMIN, data);\n\t\tset_match_data(COL_MAJMIN, (void *) devno);\n\t\tflags |= FL_NOSWAPMATCH;\n\t} else\n\t\tset_match(COL_SOURCE, data);\n}\n\n/*\n * Extra functionality for --target <path>. The function mnt_table_find_mountpoint()\n * also checks parents (path elements in reverse order) to get mountpoint.\n *\n * @tb has to be from kernel (so no fstab or so)!\n */\nstatic void enable_extra_target_match(struct libmnt_table *tb)\n{\n\tchar *cn = NULL;\n\tconst char *tgt = NULL, *mnt = NULL;\n\tstruct libmnt_fs *fs;\n\n\t/*\n\t * Check if match pattern is mountpoint, if not use the\n\t * real mountpoint.\n\t */\n\tif (flags & FL_NOCACHE)\n\t\ttgt = get_match(COL_TARGET);\n\telse {\n\t\ttgt = cn = mnt_resolve_path(get_match(COL_TARGET), cache);\n\t\tif (!cn)\n\t\t\treturn;\n\t}\n\n\tfs = mnt_table_find_mountpoint(tb, tgt, MNT_ITER_BACKWARD);\n\tif (fs)\n\t\tmnt = mnt_fs_get_target(fs);\n\tif (mnt && strcmp(mnt, tgt) != 0)\n\t\tset_match(COL_TARGET, xstrdup(mnt));\t/* replace the current setting */\n\n\tif (!cache)\n\t\tfree(cn);\n}\n\n\nstatic int is_tabdiff_column(int id)\n{\n\tassert((size_t) id < ARRAY_SIZE(infos));\n\n\tswitch(id) {\n\tcase COL_ACTION:\n\tcase COL_OLD_TARGET:\n\tcase COL_OLD_OPTIONS:\n\t\treturn 1;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n/*\n * \"findmnt\" without any filter\n */\nint is_listall_mode(void)\n{\n\tif ((flags & FL_DF || flags & FL_REAL || flags & FL_PSEUDO) && !(flags & FL_ALL))\n\t\treturn 0;\n\n\treturn (!get_match(COL_SOURCE) &&\n\t\t!get_match(COL_TARGET) &&\n\t\t!get_match(COL_FSTYPE) &&\n\t\t!get_match(COL_OPTIONS) &&\n\t\t!get_match(COL_MAJMIN));\n}\n\n/*\n * Returns 1 if the @act is in the --poll=<list>\n */\nstatic int has_poll_action(int act)\n{\n\tint i;\n\n\tif (!nactions)\n\t\treturn 1;\t/* all actions enabled */\n\tfor (i = 0; i < nactions; i++)\n\t\tif (actions[i] == act)\n\t\t\treturn 1;\n\treturn 0;\n}\n\nstatic int poll_action_name_to_id(const char *name, size_t namesz)\n{\n\tint id = -1;\n\n\tif (strncasecmp(name, \"move\", namesz) == 0 && namesz == 4)\n\t\tid = MNT_TABDIFF_MOVE;\n\telse if (strncasecmp(name, \"mount\", namesz) == 0 && namesz == 5)\n\t\tid = MNT_TABDIFF_MOUNT;\n\telse if (strncasecmp(name, \"umount\", namesz) == 0 && namesz == 6)\n\t\tid = MNT_TABDIFF_UMOUNT;\n\telse if (strncasecmp(name, \"remount\", namesz) == 0 && namesz == 7)\n\t\tid = MNT_TABDIFF_REMOUNT;\n\telse\n\t\twarnx(_(\"unknown action: %s\"), name);\n\n\treturn id;\n}\n\n/*\n * findmnt --first-only <devname|TAG=|mountpoint>\n *\n * ... it works like \"mount <devname|TAG=|mountpoint>\"\n */\nstatic int is_mount_compatible_mode(void)\n{\n\tif (!get_match(COL_SOURCE))\n\t       return 0;\t\t/* <devname|TAG=|mountpoint> is required */\n\tif (get_match(COL_FSTYPE) || get_match(COL_OPTIONS))\n\t\treturn 0;\t\t/* cannot be restricted by -t or -O */\n\tif (!(flags & FL_FIRSTONLY))\n\t\treturn 0;\t\t/* we have to return the first entry only */\n\n\treturn 1;\t\t\t/* ok */\n}\n\nstatic void disable_columns_truncate(void)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < ARRAY_SIZE(infos); i++)\n\t\tinfos[i].flags &= ~SCOLS_FL_TRUNC;\n}\n\n/*\n * converts @name to column ID\n */\nstatic int column_name_to_id(const char *name, size_t namesz)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < ARRAY_SIZE(infos); i++) {\n\t\tconst char *cn = column_id_to_name(i);\n\n\t\tif (!strncasecmp(name, cn, namesz) && !*(cn + namesz))\n\t\t\treturn i;\n\t}\n\twarnx(_(\"unknown column: %s\"), name);\n\treturn -1;\n}\n\n\n#ifdef HAVE_LIBUDEV\nstatic char *get_tag_from_udev(const char *devname, int col)\n{\n\tstruct udev_device *dev;\n\tconst char *data = NULL;\n\tchar *res = NULL, *path;\n\n\tif (!udev)\n\t\tudev = udev_new();\n\tif (!udev)\n\t\treturn NULL;\n\n\t/* libudev don't like /dev/mapper/ symlinks */\n\tpath = realpath(devname, NULL);\n\tif (path)\n\t\tdevname = path;\n\n\tif (strncmp(devname, \"/dev/\", 5) == 0)\n\t\tdevname += 5;\n\n\tdev = udev_device_new_from_subsystem_sysname(udev, \"block\", devname);\n\tfree(path);\n\n\tif (!dev)\n\t\treturn NULL;\n\n\tswitch(col) {\n\tcase COL_LABEL:\n\t\tdata = udev_device_get_property_value(dev, \"ID_FS_LABEL_ENC\");\n\t\tbreak;\n\tcase COL_UUID:\n\t\tdata = udev_device_get_property_value(dev, \"ID_FS_UUID_ENC\");\n\t\tbreak;\n\tcase COL_PARTUUID:\n\t\tdata = udev_device_get_property_value(dev, \"ID_PART_ENTRY_UUID\");\n\t\tbreak;\n\tcase COL_PARTLABEL:\n\t\tdata = udev_device_get_property_value(dev, \"ID_PART_ENTRY_NAME\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (data) {\n\t\tres = xstrdup(data);\n\t\tunhexmangle_string(res);\n\t}\n\n\tudev_device_unref(dev);\n\treturn res;\n}\n#endif /* HAVE_LIBUDEV */\n\n/* Returns LABEL or UUID */\nstatic char *get_tag(struct libmnt_fs *fs, const char *tagname, int col\n#ifndef HAVE_LIBUDEV\n\t\t__attribute__((__unused__))\n#endif\n\t\t)\n{\n\tconst char *t, *v;\n\tchar *res = NULL;\n\n\tif (!mnt_fs_get_tag(fs, &t, &v) && !strcmp(t, tagname))\n\t\tres = xstrdup(v);\n\telse {\n\t\tconst char *dev = mnt_fs_get_source(fs);\n\n\t\tif (dev && !(flags & FL_NOCACHE))\n\t\t\tdev = mnt_resolve_spec(dev, cache);\n#ifdef HAVE_LIBUDEV\n\t\tif (dev)\n\t\t\tres = get_tag_from_udev(dev, col);\n#endif\n\t\tif (!res) {\n\t\t\tres = mnt_cache_find_tag_value(cache, dev, tagname);\n\t\t\tif (res && cache)\n\t\t\t\t/* don't return pointer to cache */\n\t\t\t\tres = xstrdup(res);\n\t\t}\n\t}\n\n\treturn res;\n}\n\nstatic char *get_vfs_attr(struct libmnt_fs *fs, int sizetype)\n{\n\tstruct statvfs buf;\n\tuint64_t vfs_attr = 0;\n\tchar *sizestr;\n\n\tif (statvfs(mnt_fs_get_target(fs), &buf) != 0)\n\t\treturn NULL;\n\n\tswitch(sizetype) {\n\tcase COL_SIZE:\n\t\tvfs_attr = buf.f_frsize * buf.f_blocks;\n\t\tbreak;\n\tcase COL_AVAIL:\n\t\tvfs_attr = buf.f_frsize * buf.f_bavail;\n\t\tbreak;\n\tcase COL_USED:\n\t\tvfs_attr = buf.f_frsize * (buf.f_blocks - buf.f_bfree);\n\t\tbreak;\n\tcase COL_USEPERC:\n\t\tif (buf.f_blocks == 0)\n\t\t\treturn xstrdup(\"-\");\n\n\t\txasprintf(&sizestr, \"%.0f%%\",\n\t\t\t\t(double)(buf.f_blocks - buf.f_bfree) /\n\t\t\t\tbuf.f_blocks * 100);\n\t\treturn sizestr;\n\t}\n\n\tif (!vfs_attr)\n\t\tsizestr = xstrdup(\"0\");\n\telse if (flags & FL_BYTES)\n\t\txasprintf(&sizestr, \"%ju\", vfs_attr);\n\telse\n\t\tsizestr = size_to_human_string(SIZE_SUFFIX_1LETTER, vfs_attr);\n\n\treturn sizestr;\n}\n\n/* reads FS data from libmount\n */\nstatic char *get_data(struct libmnt_fs *fs, int num)\n{\n\tchar *str = NULL;\n\tconst char *t = NULL, *v = NULL;\n\tint col_id = get_column_id(num);\n\n\tswitch (col_id) {\n\tcase COL_SOURCES:\n\t\t/* print all devices with the same tag (LABEL, UUID) */\n\t\tif ((flags & FL_EVALUATE) &&\n\t\t    mnt_fs_get_tag(fs, &t, &v) == 0) {\n\t\t\tblkid_dev_iterate iter;\n\t\t\tblkid_dev dev;\n\t\t\tblkid_cache cache = NULL;\n\t\t\tstruct ul_buffer buf = UL_INIT_BUFFER;\n\t\t\tint i = 0;\n\n\t\t\tif (blkid_get_cache(&cache, NULL) < 0)\n\t\t\t\tbreak;\n\n\t\t\tblkid_probe_all(cache);\n\n\t\t\titer = blkid_dev_iterate_begin(cache);\n\t\t\tblkid_dev_set_search(iter, t, v);\n\t\t\twhile (blkid_dev_next(iter, &dev) == 0) {\n\t\t\t\tdev = blkid_verify(cache, dev);\n\t\t\t\tif (!dev)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (i != 0)\n\t\t\t\t\tul_buffer_append_data(&buf, \"\\n\", 1);\n\t\t\t\tul_buffer_append_string(&buf, blkid_dev_devname(dev));\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tblkid_dev_iterate_end(iter);\n\t\t\tstr = ul_buffer_get_data(&buf, NULL, NULL);\n\t\t\tbreak;\n\t\t}\n\t\t/* fallthrough */\n\tcase COL_SOURCE:\n\t{\n\t\tconst char *root = mnt_fs_get_root(fs);\n\t\tconst char *spec = mnt_fs_get_srcpath(fs);\n\t\tchar *cn = NULL;\n\n\t\tif (spec && (flags & FL_CANONICALIZE))\n\t\t\tspec = cn = mnt_resolve_path(spec, cache);\n\t\tif (!spec) {\n\t\t\tspec = mnt_fs_get_source(fs);\n\n\t\t\tif (spec && (flags & FL_EVALUATE))\n\t\t\t\tspec = cn = mnt_resolve_spec(spec, cache);\n\t\t}\n\t\tif (root && spec && !(flags & FL_NOFSROOT) && strcmp(root, \"/\") != 0)\n\t\t\txasprintf(&str, \"%s[%s]\", spec, root);\n\t\telse if (spec)\n\t\t\tstr = xstrdup(spec);\n\t\tif (!cache)\n\t\t\tfree(cn);\n\t\tbreak;\n\t}\n\n\tcase COL_TARGET:\n\t\tif (mnt_fs_get_target(fs))\n\t\t\tstr = xstrdup(mnt_fs_get_target(fs));\n\t\tbreak;\n\tcase COL_FSTYPE:\n\t\tif (mnt_fs_get_fstype(fs))\n\t\t\tstr = xstrdup(mnt_fs_get_fstype(fs));\n\t\tbreak;\n\tcase COL_OPTIONS:\n\t\tif (mnt_fs_get_options(fs))\n\t\t\tstr = xstrdup(mnt_fs_get_options(fs));\n\t\tbreak;\n\tcase COL_VFS_OPTIONS:\n\t\tif (flags & FL_VFS_ALL)\n\t\t\tstr = mnt_fs_get_vfs_options_all(fs);\n\t\telse if (mnt_fs_get_vfs_options(fs))\n\t\t\tstr = xstrdup(mnt_fs_get_vfs_options(fs));\n\t\tbreak;\n\tcase COL_FS_OPTIONS:\n\t\tif (mnt_fs_get_fs_options(fs))\n\t\t\tstr = xstrdup(mnt_fs_get_fs_options(fs));\n\t\tbreak;\n\tcase COL_OPT_FIELDS:\n\t\tif (mnt_fs_get_optional_fields(fs))\n\t\t\tstr = xstrdup(mnt_fs_get_optional_fields(fs));\n\t\tbreak;\n\tcase COL_UUID:\n\t\tstr = get_tag(fs, \"UUID\", col_id);\n\t\tbreak;\n\tcase COL_PARTUUID:\n\t\tstr = get_tag(fs, \"PARTUUID\", col_id);\n\t\tbreak;\n\tcase COL_LABEL:\n\t\tstr = get_tag(fs, \"LABEL\", col_id);\n\t\tbreak;\n\tcase COL_PARTLABEL:\n\t\tstr = get_tag(fs, \"PARTLABEL\", col_id);\n\t\tbreak;\n\n\tcase COL_MAJMIN:\n\t{\n\t\tdev_t devno = mnt_fs_get_devno(fs);\n\t\tif (!devno)\n\t\t\tbreak;\n\n\t\tif ((flags & FL_RAW) || (flags & FL_EXPORT) || (flags & FL_JSON))\n\t\t\txasprintf(&str, \"%u:%u\", major(devno), minor(devno));\n\t\telse\n\t\t\txasprintf(&str, \"%3u:%-3u\", major(devno), minor(devno));\n\t\tbreak;\n\t}\n\tcase COL_SIZE:\n\tcase COL_AVAIL:\n\tcase COL_USED:\n\tcase COL_USEPERC:\n\t\tstr = get_vfs_attr(fs, col_id);\n\t\tbreak;\n\tcase COL_FSROOT:\n\t\tif (mnt_fs_get_root(fs))\n\t\t\tstr = xstrdup(mnt_fs_get_root(fs));\n\t\tbreak;\n\tcase COL_TID:\n\t\tif (mnt_fs_get_tid(fs))\n\t\t\txasprintf(&str, \"%d\", mnt_fs_get_tid(fs));\n\t\tbreak;\n\tcase COL_ID:\n\t\tif (mnt_fs_get_id(fs))\n\t\t\txasprintf(&str, \"%d\", mnt_fs_get_id(fs));\n\t\tbreak;\n\tcase COL_PARENT:\n\t\tif (mnt_fs_get_parent_id(fs))\n\t\t\txasprintf(&str, \"%d\", mnt_fs_get_parent_id(fs));\n\t\tbreak;\n\tcase COL_PROPAGATION:\n\t\tif (mnt_fs_is_kernel(fs)) {\n\t\t\tunsigned long fl = 0;\n\t\t\tchar *n = NULL;\n\n\t\t\tif (mnt_fs_get_propagation(fs, &fl) != 0)\n\t\t\t\tbreak;\n\n\t\t\tn = xstrdup((fl & MS_SHARED) ? \"shared\" : \"private\");\n\n\t\t\tif (fl & MS_SLAVE) {\n\t\t\t\txasprintf(&str, \"%s,slave\", n);\n\t\t\t\tfree(n);\n\t\t\t\tn = str;\n\t\t\t}\n\t\t\tif (fl & MS_UNBINDABLE) {\n\t\t\t\txasprintf(&str, \"%s,unbindable\", n);\n\t\t\t\tfree(n);\n\t\t\t\tn = str;\n\t\t\t}\n\t\t\tstr = n;\n\t\t}\n\t\tbreak;\n\tcase COL_FREQ:\n\t\tif (!mnt_fs_is_kernel(fs))\n\t\t\txasprintf(&str, \"%d\", mnt_fs_get_freq(fs));\n\t\tbreak;\n\tcase COL_PASSNO:\n\t\tif (!mnt_fs_is_kernel(fs))\n\t\t\txasprintf(&str, \"%d\", mnt_fs_get_passno(fs));\n\t\tbreak;\n\tcase COL_DELETED:\n\t\tstr = xstrdup(mnt_fs_is_deleted(fs) ? \"1\" : \"0\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn str;\n}\n\nstatic char *get_tabdiff_data(struct libmnt_fs *old_fs,\n\t\t\t\t    struct libmnt_fs *new_fs,\n\t\t\t\t    int change,\n\t\t\t\t    int num)\n{\n\tchar *str = NULL;\n\n\tswitch (get_column_id(num)) {\n\tcase COL_ACTION:\n\t\tswitch (change) {\n\t\tcase MNT_TABDIFF_MOUNT:\n\t\t\tstr = _(\"mount\");\n\t\t\tbreak;\n\t\tcase MNT_TABDIFF_UMOUNT:\n\t\t\tstr = _(\"umount\");\n\t\t\tbreak;\n\t\tcase MNT_TABDIFF_REMOUNT:\n\t\t\tstr = _(\"remount\");\n\t\t\tbreak;\n\t\tcase MNT_TABDIFF_MOVE:\n\t\t\tstr = _(\"move\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstr = _(\"unknown\");\n\t\t\tbreak;\n\t\t}\n\t\tstr = xstrdup(str);\n\t\tbreak;\n\tcase COL_OLD_OPTIONS:\n\t\tif (old_fs && (change == MNT_TABDIFF_REMOUNT ||\n\t\t\t       change == MNT_TABDIFF_UMOUNT)\n\t\t           && mnt_fs_get_options(old_fs))\n\t\t\tstr = xstrdup(mnt_fs_get_options(old_fs));\n\t\tbreak;\n\tcase COL_OLD_TARGET:\n\t\tif (old_fs && (change == MNT_TABDIFF_MOVE ||\n\t\t\t       change == MNT_TABDIFF_UMOUNT)\n\t\t\t   && mnt_fs_get_target(old_fs))\n\t\t\tstr = xstrdup(mnt_fs_get_target(old_fs));\n\t\tbreak;\n\tdefault:\n\t\tif (new_fs)\n\t\t\tstr = get_data(new_fs, num);\n\t\telse\n\t\t\tstr = get_data(old_fs, num);\n\t\tbreak;\n\t}\n\treturn str;\n}\n\n/* adds one line to the output @tab */\nstatic struct libscols_line *add_line(struct libscols_table *table, struct libmnt_fs *fs,\n\t\t\t\t\tstruct libscols_line *parent)\n{\n\tsize_t i;\n\tstruct libscols_line *line = scols_table_new_line(table, parent);\n\n\tif (!line)\n\t\terr(EXIT_FAILURE, _(\"failed to allocate output line\"));\n\n\tfor (i = 0; i < ncolumns; i++) {\n\t\tif (scols_line_refer_data(line, i, get_data(fs, i)))\n\t\t\terr(EXIT_FAILURE, _(\"failed to add output data\"));\n\t}\n\n\tscols_line_set_userdata(line, fs);\n\treturn line;\n}\n\nstatic struct libscols_line *add_tabdiff_line(struct libscols_table *table, struct libmnt_fs *new_fs,\n\t\t\tstruct libmnt_fs *old_fs, int change)\n{\n\tsize_t i;\n\tstruct libscols_line *line = scols_table_new_line(table, NULL);\n\n\tif (!line)\n\t\terr(EXIT_FAILURE, _(\"failed to allocate output line\"));\n\n\tfor (i = 0; i < ncolumns; i++) {\n\t\tif (scols_line_refer_data(line, i,\n\t\t\t\tget_tabdiff_data(old_fs, new_fs, change, i)))\n\t\t\terr(EXIT_FAILURE, _(\"failed to add output data\"));\n\t}\n\n\treturn line;\n}\n\nstatic int has_line(struct libscols_table *table, struct libmnt_fs *fs)\n{\n\tstruct libscols_line *ln;\n\tstruct libscols_iter *itr;\n\tint rc = 0;\n\n\titr = scols_new_iter(SCOLS_ITER_FORWARD);\n\tif (!itr)\n\t\treturn 0;\n\n\twhile (scols_table_next_line(table, itr, &ln) == 0) {\n\t\tif ((struct libmnt_fs *) scols_line_get_userdata(ln) == fs) {\n\t\t\trc = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tscols_free_iter(itr);\n\treturn rc;\n}\n\n/* reads filesystems from @tb (libmount) and fillin @table (output table) */\nstatic int create_treenode(struct libscols_table *table, struct libmnt_table *tb,\n\t\t\t   struct libmnt_fs *fs, struct libscols_line *parent_line)\n{\n\tstruct libmnt_fs *chld = NULL;\n\tstruct libmnt_iter *itr = NULL;\n\tstruct libscols_line *line;\n\tint rc = -1, first = 0;\n\n\tif (!fs) {\n\t\t/* first call, get root FS */\n\t\tif (mnt_table_get_root_fs(tb, &fs))\n\t\t\tgoto leave;\n\t\tparent_line = NULL;\n\t\tfirst = 1;\n\n\t} else if ((flags & FL_SUBMOUNTS) && has_line(table, fs))\n\t\treturn 0;\n\n\titr = mnt_new_iter(MNT_ITER_FORWARD);\n\tif (!itr)\n\t\tgoto leave;\n\n\tif ((flags & FL_SUBMOUNTS) || match_func(fs, NULL)) {\n\t\tline = add_line(table, fs, parent_line);\n\t\tif (!line)\n\t\t\tgoto leave;\n\t} else\n\t\tline = parent_line;\n\n\t/*\n\t * add all children to the output table\n\t */\n\twhile (mnt_table_next_child_fs(tb, itr, fs, &chld) == 0) {\n\t\tif (create_treenode(table, tb, chld, line))\n\t\t\tgoto leave;\n\t}\n\trc = 0;\n\n\t/* make sure all entries are in the tree */\n\tif (first && (size_t) mnt_table_get_nents(tb) >\n\t\t     (size_t) scols_table_get_nlines(table)) {\n\t\tmnt_reset_iter(itr, MNT_ITER_FORWARD);\n\t\tfs = NULL;\n\n\t\twhile (mnt_table_next_fs(tb, itr, &fs) == 0) {\n\t\t\tif (!has_line(table, fs) && match_func(fs, NULL))\n\t\t\t\tcreate_treenode(table, tb, fs, NULL);\n\t\t}\n\t}\nleave:\n\tmnt_free_iter(itr);\n\treturn rc;\n}\n\n/* error callback */\nstatic int parser_errcb(struct libmnt_table *tb __attribute__ ((__unused__)),\n\t\t\tconst char *filename, int line)\n{\n\twarnx(_(\"%s: parse error at line %d -- ignored\"), filename, line);\n\t++parse_nerrors;\n\treturn 1;\n}\n\nstatic char **append_tabfile(char **files, int *nfiles, char *filename)\n{\n\tfiles = xrealloc(files, sizeof(char *) * (*nfiles + 1));\n\tfiles[(*nfiles)++] = filename;\n\treturn files;\n}\n\nstatic char **append_pid_tabfile(char **files, int *nfiles, pid_t pid)\n{\n\tchar *path = NULL;\n\n\txasprintf(&path, \"/proc/%d/mountinfo\", (int) pid);\n\treturn append_tabfile(files, nfiles, path);\n}\n\n/* calls libmount fstab/mtab/mountinfo parser */\nstatic struct libmnt_table *parse_tabfiles(char **files,\n\t\t\t\t\t   int nfiles,\n\t\t\t\t\t   int tabtype)\n{\n\tstruct libmnt_table *tb;\n\tint rc = 0;\n\n\ttb = mnt_new_table();\n\tif (!tb) {\n\t\twarn(_(\"failed to initialize libmount table\"));\n\t\treturn NULL;\n\t}\n\tmnt_table_set_parser_errcb(tb, parser_errcb);\n\n\tdo {\n\t\t/* NULL means that libmount will use default paths */\n\t\tconst char *path = nfiles ? *files++ : NULL;\n\n\t\tswitch (tabtype) {\n\t\tcase TABTYPE_FSTAB:\n\t\t\trc = mnt_table_parse_fstab(tb, path);\n\t\t\tbreak;\n\t\tcase TABTYPE_MTAB:\n\t\t\trc = mnt_table_parse_mtab(tb, path);\n\t\t\tbreak;\n\t\tcase TABTYPE_KERNEL:\n\t\t\tif (!path)\n\t\t\t\tpath = access(_PATH_PROC_MOUNTINFO, R_OK) == 0 ?\n\t\t\t\t\t      _PATH_PROC_MOUNTINFO :\n\t\t\t\t\t      _PATH_PROC_MOUNTS;\n\n\t\t\trc = mnt_table_parse_file(tb, path);\n\t\t\tbreak;\n\t\t}\n\t\tif (rc) {\n\t\t\tmnt_unref_table(tb);\n\t\t\twarn(_(\"can't read %s\"), path);\n\t\t\treturn NULL;\n\t\t}\n\t} while (--nfiles > 0);\n\n\treturn tb;\n}\n\n/*\n * Parses mountinfo and calls mnt_cache_set_targets(cache, mtab). Only\n * necessary if @tb in main() was read from a non-kernel source.\n */\nstatic void cache_set_targets(struct libmnt_cache *tmp)\n{\n\tstruct libmnt_table *tb;\n\tconst char *path;\n\n\ttb = mnt_new_table();\n\tif (!tb)\n\t\treturn;\n\n\tpath = access(_PATH_PROC_MOUNTINFO, R_OK) == 0 ?\n\t\t_PATH_PROC_MOUNTINFO :\n\t\t_PATH_PROC_MOUNTS;\n\n\tif (mnt_table_parse_file(tb, path) == 0)\n\t\tmnt_cache_set_targets(tmp, tb);\n\n\tmnt_unref_table(tb);\n}\n\n/* checks if @tb contains parent->child relations */\nstatic int tab_is_tree(struct libmnt_table *tb)\n{\n\tstruct libmnt_fs *fs = NULL;\n\tstruct libmnt_iter *itr;\n\tint rc = 0;\n\n\titr = mnt_new_iter(MNT_ITER_BACKWARD);\n\tif (!itr)\n\t\treturn 0;\n\n\trc = (mnt_table_next_fs(tb, itr, &fs) == 0 &&\n\t      mnt_fs_is_kernel(fs) &&\n\t      mnt_fs_get_root(fs));\n\n\tmnt_free_iter(itr);\n\treturn rc;\n}\n\n/* checks if all fs in @tb are from kernel */\nstatic int tab_is_kernel(struct libmnt_table *tb)\n{\n\tstruct libmnt_fs *fs = NULL;\n\tstruct libmnt_iter *itr;\n\n\titr = mnt_new_iter(MNT_ITER_BACKWARD);\n\tif (!itr)\n\t\treturn 0;\n\n\twhile (mnt_table_next_fs(tb, itr, &fs) == 0) {\n\t\tif (!mnt_fs_is_kernel(fs)) {\n\t\t\tmnt_free_iter(itr);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tmnt_free_iter(itr);\n\treturn 1;\n}\n\n/* filter function for libmount (mnt_table_find_next_fs()) */\nstatic int match_func(struct libmnt_fs *fs,\n\t\t      void *data __attribute__ ((__unused__)))\n{\n\tint rc = flags & FL_INVERT ? 1 : 0;\n\tconst char *m;\n\tvoid *md;\n\n\tm = get_match(COL_FSTYPE);\n\tif (m && !mnt_fs_match_fstype(fs, m))\n\t\treturn rc;\n\n\tm = get_match(COL_OPTIONS);\n\tif (m && !mnt_fs_match_options(fs, m))\n\t\treturn rc;\n\n\tmd = get_match_data(COL_MAJMIN);\n\tif (md && mnt_fs_get_devno(fs) != *((dev_t *) md))\n\t\treturn rc;\n\n\tm = get_match(COL_TARGET);\n\tif (m && !mnt_fs_match_target(fs, m, cache))\n\t\treturn rc;\n\n\tm = get_match(COL_SOURCE);\n\tif (m && !mnt_fs_match_source(fs, m, cache))\n\t\treturn rc;\n\n\tif ((flags & FL_DF) && !(flags & FL_ALL)) {\n\t\tconst char *type = mnt_fs_get_fstype(fs);\n\n\t\tif (type && strstr(type, \"tmpfs\"))\t/* tmpfs is wanted */\n\t\t\treturn !rc;\n\n\t\tif (mnt_fs_is_pseudofs(fs))\n\t\t\treturn rc;\n\t}\n\n\tif ((flags & FL_REAL) && mnt_fs_is_pseudofs(fs))\n\t    return rc;\n\n\tif ((flags & FL_PSEUDO) && !mnt_fs_is_pseudofs(fs))\n\t    return rc;\n\n\tif ((flags & FL_SHADOWED)) {\n\t\tstruct libmnt_table *tb = NULL;\n\n\t\tmnt_fs_get_table(fs, &tb);\n\t\tif (tb && mnt_table_over_fs(tb, fs, NULL) != 0)\n\t\t\treturn rc;\n\t}\n\n\tif ((flags & FL_DELETED) && !mnt_fs_is_deleted(fs))\n\t\treturn rc;\n\n\treturn !rc;\n}\n\n/* iterate over filesystems in @tb */\nstruct libmnt_fs *get_next_fs(struct libmnt_table *tb,\n\t\t\t\t     struct libmnt_iter *itr)\n{\n\tstruct libmnt_fs *fs = NULL;\n\n\tif (is_listall_mode()) {\n\t\t/*\n\t\t * Print whole file\n\t\t */\n\t\tif (mnt_table_next_fs(tb, itr, &fs) != 0)\n\t\t\treturn NULL;\n\n\t} else if (is_mount_compatible_mode()) {\n\t\t/*\n\t\t * Look up for FS in the same way how mount(8) searches in fstab\n\t\t *\n\t\t *   findmnt -f <spec>\n\t\t */\n\t\tfs = mnt_table_find_source(tb, get_match(COL_SOURCE),\n\t\t\t\t\tmnt_iter_get_direction(itr));\n\n\t\tif (!fs && !(flags & FL_NOSWAPMATCH))\n\t\t\tfs = mnt_table_find_target(tb, get_match(COL_SOURCE),\n\t\t\t\t\tmnt_iter_get_direction(itr));\n\t} else {\n\t\t/*\n\t\t * Look up for all matching entries\n\t\t *\n\t\t *    findmnt [-l] <source> <target> [-O <options>] [-t <types>]\n\t\t *    findmnt [-l] <spec> [-O <options>] [-t <types>]\n\t\t */\nagain:\n\t\tif (mnt_table_find_next_fs(tb, itr, match_func,  NULL, &fs) != 0)\n\t\t\tfs = NULL;\n\n\t\tif (!fs &&\n\t\t    !(flags & FL_NOSWAPMATCH) &&\n\t\t    !get_match(COL_TARGET) && get_match(COL_SOURCE)) {\n\n\t\t\t/* swap 'spec' and target. */\n\t\t\tset_match(COL_TARGET, get_match(COL_SOURCE));\n\t\t\tset_match(COL_SOURCE, NULL);\n\t\t\tmnt_reset_iter(itr, -1);\n\n\t\t\tgoto again;\n\t\t}\n\t}\n\n\treturn fs;\n}\n\n/*\n * Filter out unwanted lines for --list output or top level lines for\n * --submounts tree output.\n */\nstatic int add_matching_lines(struct libmnt_table *tb,\n\t\t\t      struct libscols_table *table, int direction)\n{\n\tstruct libmnt_iter *itr;\n\tstruct libmnt_fs *fs;\n\tint nlines = 0, rc = -1;\n\n\titr = mnt_new_iter(direction);\n\tif (!itr) {\n\t\twarn(_(\"failed to initialize libmount iterator\"));\n\t\tgoto done;\n\t}\n\n\twhile((fs = get_next_fs(tb, itr))) {\n\t\tif ((flags & FL_TREE) || (flags & FL_SUBMOUNTS))\n\t\t\trc = create_treenode(table, tb, fs, NULL);\n\t\telse\n\t\t\trc = !add_line(table, fs, NULL);\n\t\tif (rc)\n\t\t\tgoto done;\n\t\tnlines++;\n\t\tif (flags & FL_FIRSTONLY)\n\t\t\tbreak;\n\t\tflags |= FL_NOSWAPMATCH;\n\t}\n\n\tif (nlines)\n\t\trc = 0;\ndone:\n\tmnt_free_iter(itr);\n\treturn rc;\n}\n\nstatic int poll_match(struct libmnt_fs *fs)\n{\n\tint rc = match_func(fs, NULL);\n\n\tif (rc == 0 && !(flags & FL_NOSWAPMATCH) &&\n\t    get_match(COL_SOURCE) && !get_match(COL_TARGET)) {\n\t\t/*\n\t\t * findmnt --poll /foo\n\t\t * The '/foo' maybe source as well as target.\n\t\t */\n\t\tconst char *str = get_match(COL_SOURCE);\n\n\t\tset_match(COL_TARGET, str);\t/* swap */\n\t\tset_match(COL_SOURCE, NULL);\n\n\t\trc = match_func(fs, NULL);\n\n\t\tset_match(COL_TARGET, NULL);\t/* restore */\n\t\tset_match(COL_SOURCE, str);\n\n\t}\n\treturn rc;\n}\n\nstatic int poll_table(struct libmnt_table *tb, const char *tabfile,\n\t\t  int timeout, struct libscols_table *table, int direction)\n{\n\tFILE *f = NULL;\n\tint rc = -1;\n\tstruct libmnt_iter *itr = NULL;\n\tstruct libmnt_table *tb_new;\n\tstruct libmnt_tabdiff *diff = NULL;\n\tstruct pollfd fds[1];\n\n\ttb_new = mnt_new_table();\n\tif (!tb_new) {\n\t\twarn(_(\"failed to initialize libmount table\"));\n\t\tgoto done;\n\t}\n\n\titr = mnt_new_iter(direction);\n\tif (!itr) {\n\t\twarn(_(\"failed to initialize libmount iterator\"));\n\t\tgoto done;\n\t}\n\n\tdiff = mnt_new_tabdiff();\n\tif (!diff) {\n\t\twarn(_(\"failed to initialize libmount tabdiff\"));\n\t\tgoto done;\n\t}\n\n\t/* cache is unnecessary to detect changes */\n\tmnt_table_set_cache(tb, NULL);\n\tmnt_table_set_cache(tb_new, NULL);\n\n\tf = fopen(tabfile, \"r\");\n\tif (!f) {\n\t\twarn(_(\"cannot open %s\"), tabfile);\n\t\tgoto done;\n\t}\n\n\tmnt_table_set_parser_errcb(tb_new, parser_errcb);\n\n\tfds[0].fd = fileno(f);\n\tfds[0].events = POLLPRI;\n\n\twhile (1) {\n\t\tstruct libmnt_table *tmp;\n\t\tstruct libmnt_fs *old, *new;\n\t\tint change, count;\n\n\t\tcount = poll(fds, 1, timeout);\n\t\tif (count == 0)\n\t\t\tbreak;\t/* timeout */\n\t\tif (count < 0) {\n\t\t\twarn(_(\"poll() failed\"));\n\t\t\tgoto done;\n\t\t}\n\n\t\trewind(f);\n\t\trc = mnt_table_parse_stream(tb_new, f, tabfile);\n\t\tif (!rc)\n\t\t\trc = mnt_diff_tables(diff, tb, tb_new);\n\t\tif (rc < 0)\n\t\t\tgoto done;\n\n\t\tcount = 0;\n\t\tmnt_reset_iter(itr, direction);\n\t\twhile(mnt_tabdiff_next_change(\n\t\t\t\tdiff, itr, &old, &new, &change) == 0) {\n\n\t\t\tif (!has_poll_action(change))\n\t\t\t\tcontinue;\n\t\t\tif (!poll_match(new ? new : old))\n\t\t\t\tcontinue;\n\t\t\tcount++;\n\t\t\trc = !add_tabdiff_line(table, new, old, change);\n\t\t\tif (rc)\n\t\t\t\tgoto done;\n\t\t\tif (flags & FL_FIRSTONLY)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (count) {\n\t\t\trc = scols_table_print_range(table, NULL, NULL);\n\t\t\tif (rc == 0)\n\t\t\t\tfputc('\\n', scols_table_get_stream(table));\n\t\t\tfflush(stdout);\n\t\t\tif (rc)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\t/* swap tables */\n\t\ttmp = tb;\n\t\ttb = tb_new;\n\t\ttb_new = tmp;\n\n\t\t/* remove already printed lines to reduce memory usage */\n\t\tscols_table_remove_lines(table);\n\t\tmnt_reset_table(tb_new);\n\n\t\tif (count && (flags & FL_FIRSTONLY))\n\t\t\tbreak;\n\t}\n\n\trc = 0;\ndone:\n\tmnt_unref_table(tb_new);\n\tmnt_free_tabdiff(diff);\n\tmnt_free_iter(itr);\n\tif (f)\n\t\tfclose(f);\n\treturn rc;\n}\n\nstatic int uniq_fs_target_cmp(\n\t\tstruct libmnt_table *tb __attribute__((__unused__)),\n\t\tstruct libmnt_fs *a,\n\t\tstruct libmnt_fs *b)\n{\n\treturn !mnt_fs_match_target(a, mnt_fs_get_target(b), cache);\n}\n\nstatic void __attribute__((__noreturn__)) usage(void)\n{\n\tFILE *out = stdout;\n\tsize_t i;\n\n\tfputs(USAGE_HEADER, out);\n\tfprintf(out, _(\n\t\" %1$s [options]\\n\"\n\t\" %1$s [options] <device> | <mountpoint>\\n\"\n\t\" %1$s [options] <device> <mountpoint>\\n\"\n\t\" %1$s [options] [--source <device>] [--target <path> | --mountpoint <dir>]\\n\"),\n\t\tprogram_invocation_short_name);\n\n\tfputs(USAGE_SEPARATOR, out);\n\tfputs(_(\"Find a (mounted) filesystem.\\n\"), out);\n\n\tfputs(USAGE_OPTIONS, out);\n\tfputs(_(\" -s, --fstab            search in static table of filesystems\\n\"), out);\n\tfputs(_(\" -m, --mtab             search in table of mounted filesystems\\n\"\n\t\t\"                          (includes user space mount options)\\n\"), out);\n\tfputs(_(\" -k, --kernel           search in kernel table of mounted\\n\"\n\t\t\"                          filesystems (default)\\n\"), out);\n\tfputc('\\n', out);\n\tfputs(_(\" -p, --poll[=<list>]    monitor changes in table of mounted filesystems\\n\"), out);\n\tfputs(_(\" -w, --timeout <num>    upper limit in milliseconds that --poll will block\\n\"), out);\n\tfputc('\\n', out);\n\n\tfputs(_(\" -A, --all              disable all built-in filters, print all filesystems\\n\"), out);\n\tfputs(_(\" -a, --ascii            use ASCII chars for tree formatting\\n\"), out);\n\tfputs(_(\" -b, --bytes            print sizes in bytes rather than in human readable format\\n\"), out);\n\tfputs(_(\" -C, --nocanonicalize   don't canonicalize when comparing paths\\n\"), out);\n\tfputs(_(\" -c, --canonicalize     canonicalize printed paths\\n\"), out);\n\tfputs(_(\"     --deleted          print filesystems with mountpoint marked as deleted\\n\"), out);\n\tfputs(_(\" -D, --df               imitate the output of df(1)\\n\"), out);\n\tfputs(_(\" -d, --direction <word> direction of search, 'forward' or 'backward'\\n\"), out);\n\tfputs(_(\" -e, --evaluate         convert tags (LABEL,UUID,PARTUUID,PARTLABEL) \\n\"\n\t        \"                          to device names\\n\"), out);\n\tfputs(_(\" -F, --tab-file <path>  alternative file for -s, -m or -k options\\n\"), out);\n\tfputs(_(\" -f, --first-only       print the first found filesystem only\\n\"), out);\n\tfputs(_(\" -i, --invert           invert the sense of matching\\n\"), out);\n\tfputs(_(\" -J, --json             use JSON output format\\n\"), out);\n\tfputs(_(\" -l, --list             use list format output\\n\"), out);\n\tfputs(_(\" -N, --task <tid>       use alternative namespace (/proc/<tid>/mountinfo file)\\n\"), out);\n\tfputs(_(\" -n, --noheadings       don't print column headings\\n\"), out);\n\tfputs(_(\" -O, --options <list>   limit the set of filesystems by mount options\\n\"), out);\n\tfputs(_(\" -o, --output <list>    the output columns to be shown\\n\"), out);\n\tfputs(_(\"     --output-all       output all available columns\\n\"), out);\n\tfputs(_(\" -P, --pairs            use key=\\\"value\\\" output format\\n\"), out);\n\tfputs(_(\"     --pseudo           print only pseudo-filesystems\\n\"), out);\n\tfputs(_(\"     --shadowed         print only filesystems over-mounted by another filesystem\\n\"), out);\n\tfputs(_(\" -R, --submounts        print all submounts for the matching filesystems\\n\"), out);\n\tfputs(_(\" -r, --raw              use raw output format\\n\"), out);\n\tfputs(_(\"     --real             print only real filesystems\\n\"), out);\n\tfputs(_(\" -S, --source <string>  the device to mount (by name, maj:min, \\n\"\n\t        \"                          LABEL=, UUID=, PARTUUID=, PARTLABEL=)\\n\"), out);\n\tfputs(_(\" -T, --target <path>    the path to the filesystem to use\\n\"), out);\n\tfputs(_(\"     --tree             enable tree format output if possible\\n\"), out);\n\tfputs(_(\" -M, --mountpoint <dir> the mountpoint directory\\n\"), out);\n\tfputs(_(\" -t, --types <list>     limit the set of filesystems by FS types\\n\"), out);\n\tfputs(_(\" -U, --uniq             ignore filesystems with duplicate target\\n\"), out);\n\tfputs(_(\" -u, --notruncate       don't truncate text in columns\\n\"), out);\n\tfputs(_(\" -v, --nofsroot         don't print [/dir] for bind or btrfs mounts\\n\"), out);\n\n\tfputc('\\n', out);\n\tfputs(_(\" -x, --verify           verify mount table content (default is fstab)\\n\"), out);\n\tfputs(_(\"     --verbose          print more details\\n\"), out);\n\tfputs(_(\"     --vfs-all          print all VFS options\\n\"), out);\n\n\tfputs(USAGE_SEPARATOR, out);\n\tprintf(USAGE_HELP_OPTIONS(24));\n\n\tfputs(USAGE_COLUMNS, out);\n\tfor (i = 0; i < ARRAY_SIZE(infos); i++)\n\t\tfprintf(out, \" %11s  %s\\n\", infos[i].name, _(infos[i].help));\n\n\tprintf(USAGE_MAN_TAIL(\"findmnt(8)\"));\n\n\texit(EXIT_SUCCESS);\n}\n\nint main(int argc, char *argv[])\n{\n\tstruct libmnt_table *tb = NULL;\n\tchar **tabfiles = NULL;\n\tint direction = MNT_ITER_FORWARD;\n\tint verify = 0;\n\tint c, rc = -1, timeout = -1;\n\tint ntabfiles = 0, tabtype = 0;\n\tchar *outarg = NULL;\n\tsize_t i;\n\tint force_tree = 0, istree = 0;\n\n\tstruct libscols_table *table = NULL;\n\n\tenum {\n\t\tFINDMNT_OPT_VERBOSE = CHAR_MAX + 1,\n\t\tFINDMNT_OPT_TREE,\n\t\tFINDMNT_OPT_OUTPUT_ALL,\n\t\tFINDMNT_OPT_PSEUDO,\n\t\tFINDMNT_OPT_REAL,\n\t\tFINDMNT_OPT_VFS_ALL,\n\t\tFINDMNT_OPT_SHADOWED,\n\t\tFINDMNT_OPT_DELETED,\n\t};\n\n\tstatic const struct option longopts[] = {\n\t\t{ \"all\",\t    no_argument,       NULL, 'A'\t\t },\n\t\t{ \"ascii\",\t    no_argument,       NULL, 'a'\t\t },\n\t\t{ \"bytes\",\t    no_argument,       NULL, 'b'\t\t },\n\t\t{ \"canonicalize\",   no_argument,       NULL, 'c'\t\t },\n\t\t{ \"deleted\",        no_argument,       NULL, FINDMNT_OPT_DELETED },\n\t\t{ \"direction\",\t    required_argument, NULL, 'd'\t\t },\n\t\t{ \"df\",\t\t    no_argument,       NULL, 'D'\t\t },\n\t\t{ \"evaluate\",\t    no_argument,       NULL, 'e'\t\t },\n\t\t{ \"first-only\",\t    no_argument,       NULL, 'f'\t\t },\n\t\t{ \"fstab\",\t    no_argument,       NULL, 's'\t\t },\n\t\t{ \"help\",\t    no_argument,       NULL, 'h'\t\t },\n\t\t{ \"invert\",\t    no_argument,       NULL, 'i'\t\t },\n\t\t{ \"json\",\t    no_argument,       NULL, 'J'\t\t },\n\t\t{ \"kernel\",\t    no_argument,       NULL, 'k'\t\t },\n\t\t{ \"list\",\t    no_argument,       NULL, 'l'\t\t },\n\t\t{ \"mountpoint\",\t    required_argument, NULL, 'M'\t\t },\n\t\t{ \"mtab\",\t    no_argument,       NULL, 'm'\t\t },\n\t\t{ \"noheadings\",\t    no_argument,       NULL, 'n'\t\t },\n\t\t{ \"notruncate\",\t    no_argument,       NULL, 'u'\t\t },\n\t\t{ \"options\",\t    required_argument, NULL, 'O'\t\t },\n\t\t{ \"output\",\t    required_argument, NULL, 'o'\t\t },\n\t\t{ \"output-all\",\t    no_argument,       NULL, FINDMNT_OPT_OUTPUT_ALL },\n\t\t{ \"poll\",\t    optional_argument, NULL, 'p'\t\t },\n\t\t{ \"pairs\",\t    no_argument,       NULL, 'P'\t\t },\n\t\t{ \"raw\",\t    no_argument,       NULL, 'r'\t\t },\n\t\t{ \"types\",\t    required_argument, NULL, 't'\t\t },\n\t\t{ \"nocanonicalize\", no_argument,       NULL, 'C'\t\t },\n\t\t{ \"nofsroot\",\t    no_argument,       NULL, 'v'\t\t },\n\t\t{ \"submounts\",\t    no_argument,       NULL, 'R'\t\t },\n\t\t{ \"source\",\t    required_argument, NULL, 'S'\t\t },\n\t\t{ \"tab-file\",\t    required_argument, NULL, 'F'\t\t },\n\t\t{ \"task\",\t    required_argument, NULL, 'N'\t\t },\n\t\t{ \"target\",\t    required_argument, NULL, 'T'\t\t },\n\t\t{ \"timeout\",\t    required_argument, NULL, 'w'\t\t },\n\t\t{ \"uniq\",\t    no_argument,       NULL, 'U'\t\t },\n\t\t{ \"verify\",\t    no_argument,       NULL, 'x'\t\t },\n\t\t{ \"version\",\t    no_argument,       NULL, 'V'\t\t },\n\t\t{ \"verbose\",\t    no_argument,       NULL, FINDMNT_OPT_VERBOSE },\n\t\t{ \"tree\",\t    no_argument,       NULL, FINDMNT_OPT_TREE\t },\n\t\t{ \"real\",\t    no_argument,       NULL, FINDMNT_OPT_REAL\t },\n\t\t{ \"pseudo\",\t    no_argument,       NULL, FINDMNT_OPT_PSEUDO\t },\n\t\t{ \"vfs-all\",\t    no_argument,       NULL, FINDMNT_OPT_VFS_ALL },\n\t\t{ \"shadowed\",       no_argument,       NULL, FINDMNT_OPT_SHADOWED },\n\t\t{ NULL, 0, NULL, 0 }\n\t};\n\n\tstatic const ul_excl_t excl[] = {\t/* rows and cols in ASCII order */\n\t\t{ 'C', 'c'},\t\t\t/* [no]canonicalize */\n\t\t{ 'C', 'e' },\t\t\t/* nocanonicalize, evaluate */\n\t\t{ 'J', 'P', 'r','x' },\t\t/* json,pairs,raw,verify */\n\t\t{ 'M', 'T' },\t\t\t/* mountpoint, target */\n\t\t{ 'N','k','m','s' },\t\t/* task,kernel,mtab,fstab */\n\t\t{ 'P','l','r','x' },\t\t/* pairs,list,raw,verify */\n\t\t{ 'p','x' },\t\t\t/* poll,verify */\n\t\t{ 'm','p','s' },\t\t/* mtab,poll,fstab */\n\t\t{ FINDMNT_OPT_PSEUDO, FINDMNT_OPT_REAL },\n\t\t{ 0 }\n\t};\n\tint excl_st[ARRAY_SIZE(excl)] = UL_EXCL_STATUS_INIT;\n\n\tsetlocale(LC_ALL, \"\");\n\tbindtextdomain(PACKAGE, LOCALEDIR);\n\ttextdomain(PACKAGE);\n\tclose_stdout_atexit();\n\n\t/* default output format */\n\tflags |= FL_TREE;\n\n\twhile ((c = getopt_long(argc, argv,\n\t\t\t\t\"AabCcDd:ehiJfF:o:O:p::PklmM:nN:rst:uvRS:T:Uw:Vx\",\n\t\t\t\tlongopts, NULL)) != -1) {\n\n\t\terr_exclusive_options(c, longopts, excl, excl_st);\n\n\t\tswitch(c) {\n\t\tcase 'A':\n\t\t\tflags |= FL_ALL;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tflags |= FL_ASCII;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tflags |= FL_BYTES;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tflags |= FL_NOCACHE;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tflags |= FL_CANONICALIZE;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tflags &= ~FL_TREE;\n\t\t\tflags |= FL_DF;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tif (!strcmp(optarg, \"forward\"))\n\t\t\t\tdirection = MNT_ITER_FORWARD;\n\t\t\telse if (!strcmp(optarg, \"backward\"))\n\t\t\t\tdirection = MNT_ITER_BACKWARD;\n\t\t\telse\n\t\t\t\terrx(EXIT_FAILURE,\n\t\t\t\t\t_(\"unknown direction '%s'\"), optarg);\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tflags |= FL_EVALUATE;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tflags |= FL_INVERT;\n\t\t\tbreak;\n\t\tcase 'J':\n\t\t\tflags |= FL_JSON;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tflags |= FL_FIRSTONLY;\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\ttabfiles = append_tabfile(tabfiles, &ntabfiles, optarg);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tdisable_columns_truncate();\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\toutarg = optarg;\n\t\t\tbreak;\n\t\tcase FINDMNT_OPT_OUTPUT_ALL:\n\t\t\tfor (ncolumns = 0; ncolumns < ARRAY_SIZE(infos); ncolumns++) {\n\t\t\t\tif (is_tabdiff_column(ncolumns))\n\t\t\t\t\tcontinue;\n\t\t\t\tcolumns[ncolumns] = ncolumns;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tset_match(COL_OPTIONS, optarg);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tif (optarg) {\n\t\t\t\tnactions = string_to_idarray(optarg,\n\t\t\t\t\t\tactions, ARRAY_SIZE(actions),\n\t\t\t\t\t\tpoll_action_name_to_id);\n\t\t\t\tif (nactions < 0)\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\tflags |= FL_POLL;\n\t\t\tflags &= ~FL_TREE;\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tflags |= FL_EXPORT;\n\t\t\tflags &= ~FL_TREE;\n\t\t\tbreak;\n\t\tcase 'm':\t\t/* mtab */\n\t\t\ttabtype = TABTYPE_MTAB;\n\t\t\tflags &= ~FL_TREE;\n\t\t\tbreak;\n\t\tcase 's':\t\t/* fstab */\n\t\t\ttabtype = TABTYPE_FSTAB;\n\t\t\tflags &= ~FL_TREE;\n\t\t\tbreak;\n\t\tcase 'k':\t\t/* kernel (mountinfo) */\n\t\t\ttabtype = TABTYPE_KERNEL;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tset_match(COL_FSTYPE, optarg);\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tflags &= ~FL_TREE;\t/* disable the default */\n\t\t\tflags |= FL_RAW;\t/* enable raw */\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tflags &= ~FL_TREE;\t/* disable the default */\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tflags |= FL_NOHEADINGS;\n\t\t\tbreak;\n\t\tcase 'N':\n\t\t\ttabtype = TABTYPE_KERNEL;\n\t\t\ttabfiles = append_pid_tabfile(tabfiles, &ntabfiles,\n\t\t\t\t\tstrtou32_or_err(optarg,\n\t\t\t\t\t\t_(\"invalid TID argument\")));\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tflags |= FL_NOFSROOT;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tflags |= FL_SUBMOUNTS;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tset_source_match(optarg);\n\t\t\tflags |= FL_NOSWAPMATCH;\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\tflags |= FL_STRICTTARGET;\n\t\t\t/* fallthrough */\n\t\tcase 'T':\n\t\t\tset_match(COL_TARGET, optarg);\n\t\t\tflags |= FL_NOSWAPMATCH;\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\tflags |= FL_UNIQ;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\ttimeout = strtos32_or_err(optarg, _(\"invalid timeout argument\"));\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\tverify = 1;\n\t\t\tbreak;\n\t\tcase FINDMNT_OPT_VERBOSE:\n\t\t\tflags |= FL_VERBOSE;\n\t\t\tbreak;\n\t\tcase FINDMNT_OPT_TREE:\n\t\t\tforce_tree = 1;\n\t\t\tbreak;\n\t\tcase FINDMNT_OPT_PSEUDO:\n\t\t\tflags |= FL_PSEUDO;\n\t\t\tbreak;\n\t\tcase FINDMNT_OPT_REAL:\n\t\t\tflags |= FL_REAL;\n\t\t\tbreak;\n\t\tcase FINDMNT_OPT_VFS_ALL:\n\t\t\tflags |= FL_VFS_ALL;\n\t\t\tbreak;\n\t\tcase FINDMNT_OPT_SHADOWED:\n\t\t\tflags |= FL_SHADOWED;\n\t\t\tbreak;\n\t\tcase FINDMNT_OPT_DELETED:\n\t\t\tflags |= FL_DELETED;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage();\n\t\tcase 'V':\n\t\t\tprint_version(EXIT_SUCCESS);\n\t\tdefault:\n\t\t\terrtryhelp(EXIT_FAILURE);\n\t\t}\n\t}\n\n\tif (!ncolumns && (flags & FL_DF)) {\n\t\tadd_column(columns, ncolumns++, COL_SOURCE);\n\t\tadd_column(columns, ncolumns++, COL_FSTYPE);\n\t\tadd_column(columns, ncolumns++, COL_SIZE);\n\t\tadd_column(columns, ncolumns++, COL_USED);\n\t\tadd_column(columns, ncolumns++, COL_AVAIL);\n\t\tadd_column(columns, ncolumns++, COL_USEPERC);\n\t\tadd_column(columns, ncolumns++, COL_TARGET);\n\t}\n\n\t/* default columns */\n\tif (!ncolumns) {\n\t\tif (flags & FL_POLL)\n\t\t\tadd_column(columns, ncolumns++, COL_ACTION);\n\n\t\tadd_column(columns, ncolumns++, COL_TARGET);\n\t\tadd_column(columns, ncolumns++, COL_SOURCE);\n\t\tadd_column(columns, ncolumns++, COL_FSTYPE);\n\t\tadd_column(columns, ncolumns++, COL_OPTIONS);\n\t}\n\n\tif (outarg && string_add_to_idarray(outarg, columns, ARRAY_SIZE(columns),\n\t\t\t\t\t &ncolumns, column_name_to_id) < 0)\n\t\treturn EXIT_FAILURE;\n\n\tif (!tabtype)\n\t\ttabtype = verify ? TABTYPE_FSTAB : TABTYPE_KERNEL;\n\n\tif ((flags & FL_POLL) && ntabfiles > 1)\n\t\terrx(EXIT_FAILURE, _(\"--poll accepts only one file, but more specified by --tab-file\"));\n\n\tif (optind < argc && (get_match(COL_SOURCE) || get_match(COL_TARGET)))\n\t\terrx(EXIT_FAILURE, _(\n\t\t\t\"options --target and --source can't be used together \"\n\t\t\t\"with command line element that is not an option\"));\n\n\tif (optind < argc)\n\t\tset_source_match(argv[optind++]);\t/* dev/tag/mountpoint/maj:min */\n\tif (optind < argc)\n\t\tset_match(COL_TARGET, argv[optind++]);\t/* mountpoint */\n\n\tif ((flags & FL_SUBMOUNTS) && is_listall_mode())\n\t\t/* don't care about submounts if list all mounts */\n\t\tflags &= ~FL_SUBMOUNTS;\n\n\tif (!(flags & FL_SUBMOUNTS) && ((flags & FL_FIRSTONLY)\n\t    || get_match(COL_TARGET)\n\t    || get_match(COL_SOURCE)\n\t    || get_match(COL_MAJMIN)))\n\t\tflags &= ~FL_TREE;\n\n\tif (!(flags & FL_NOSWAPMATCH) &&\n\t    !get_match(COL_TARGET) && get_match(COL_SOURCE)) {\n\t\t/*\n\t\t * Check if we can swap source and target, it's\n\t\t * not possible if the source is LABEL=/UUID=\n\t\t */\n\t\tconst char *x = get_match(COL_SOURCE);\n\n\t\tif (!strncmp(x, \"LABEL=\", 6) || !strncmp(x, \"UUID=\", 5) ||\n\t\t    !strncmp(x, \"PARTLABEL=\", 10) || !strncmp(x, \"PARTUUID=\", 9))\n\t\t\tflags |= FL_NOSWAPMATCH;\n\t}\n\n\t/*\n\t * initialize libmount\n\t */\n\tmnt_init_debug(0);\n\n\ttb = parse_tabfiles(tabfiles, ntabfiles, tabtype);\n\tif (!tb)\n\t\tgoto leave;\n\n\tif (tabtype == TABTYPE_MTAB && tab_is_kernel(tb))\n\t\ttabtype = TABTYPE_KERNEL;\n\n\tistree = tab_is_tree(tb);\n\tif (istree && force_tree)\n\t\tflags |= FL_TREE;\n\n\tif ((flags & FL_TREE) && (ntabfiles > 1 || !istree))\n\t\tflags &= ~FL_TREE;\n\n\tif (!(flags & FL_NOCACHE)) {\n\t\tcache = mnt_new_cache();\n\t\tif (!cache) {\n\t\t\twarn(_(\"failed to initialize libmount cache\"));\n\t\t\tgoto leave;\n\t\t}\n\t\tmnt_table_set_cache(tb, cache);\n\n\t\tif (tabtype != TABTYPE_KERNEL)\n\t\t\tcache_set_targets(cache);\n\t}\n\n\tif (flags & FL_UNIQ)\n\t\tmnt_table_uniq_fs(tb, MNT_UNIQ_KEEPTREE, uniq_fs_target_cmp);\n\n\tif (verify) {\n\t\trc = verify_table(tb);\n\t\tgoto leave;\n\t}\n\n\t/*\n\t * initialize libsmartcols\n\t */\n\tscols_init_debug(0);\n\ttable = scols_new_table();\n\tif (!table) {\n\t\twarn(_(\"failed to allocate output table\"));\n\t\tgoto leave;\n\t}\n\tscols_table_enable_raw(table,        !!(flags & FL_RAW));\n\tscols_table_enable_export(table,     !!(flags & FL_EXPORT));\n\tscols_table_enable_json(table,       !!(flags & FL_JSON));\n\tscols_table_enable_ascii(table,      !!(flags & FL_ASCII));\n\tscols_table_enable_noheadings(table, !!(flags & FL_NOHEADINGS));\n\n\tif (flags & FL_JSON)\n\t\tscols_table_set_name(table, \"filesystems\");\n\n\tfor (i = 0; i < ncolumns; i++) {\n\t\tstruct libscols_column *cl;\n\t\tint fl = get_column_flags(i);\n\t\tint id = get_column_id(i);\n\n\t\tif (!(flags & FL_TREE))\n\t\t\tfl &= ~SCOLS_FL_TREE;\n\n\t\tif (!(flags & FL_POLL) && is_tabdiff_column(id)) {\n\t\t\twarnx(_(\"%s column is requested, but --poll \"\n\t\t\t       \"is not enabled\"), get_column_name(i));\n\t\t\tgoto leave;\n\t\t}\n\t\tcl = scols_table_new_column(table, get_column_name(i),\n\t\t\t\t\tget_column_whint(i), fl);\n\t\tif (!cl)\t{\n\t\t\twarn(_(\"failed to allocate output column\"));\n\t\t\tgoto leave;\n\t\t}\n\t\t/* multi-line cells (now used for SOURCES) */\n\t\tif (fl & SCOLS_FL_WRAP) {\n\t\t\tscols_column_set_wrapfunc(cl,\n\t\t\t\t\t\tscols_wrapnl_chunksize,\n\t\t\t\t\t\tscols_wrapnl_nextchunk,\n\t\t\t\t\t\tNULL);\n\t\t\tscols_column_set_safechars(cl, \"\\n\");\n\t\t}\n\t\tif (flags & FL_JSON) {\n\t\t\tswitch (id) {\n\t\t\tcase COL_SIZE:\n\t\t\tcase COL_AVAIL:\n\t\t\tcase COL_USED:\n\t\t\t\tif (!(flags & FL_BYTES))\n\t\t\t\t\tbreak;\n\t\t\t\t/* fallthrough */\n\t\t\tcase COL_ID:\n\t\t\tcase COL_PARENT:\n\t\t\tcase COL_FREQ:\n\t\t\tcase COL_PASSNO:\n\t\t\tcase COL_TID:\n\t\t\t\tscols_column_set_json_type(cl, SCOLS_JSON_NUMBER);\n\t\t\t\tbreak;\n\t\t\tcase COL_DELETED:\n\t\t\t\tscols_column_set_json_type(cl, SCOLS_JSON_BOOLEAN);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (fl & SCOLS_FL_WRAP)\n\t\t\t\t\tscols_column_set_json_type(cl, SCOLS_JSON_ARRAY_STRING);\n\t\t\t\telse\n\t\t\t\t\tscols_column_set_json_type(cl, SCOLS_JSON_STRING);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Fill in data to the output table\n\t */\n\tif (flags & FL_POLL) {\n\t\t/* poll mode (accept the first tabfile only) */\n\t\trc = poll_table(tb, tabfiles ? *tabfiles : _PATH_PROC_MOUNTINFO, timeout, table, direction);\n\n\t} else if ((flags & FL_TREE) && !(flags & FL_SUBMOUNTS)) {\n\t\t/* whole tree */\n\t\trc = create_treenode(table, tb, NULL, NULL);\n\t} else {\n\t\t/* whole list of sub-tree */\n\t\trc = add_matching_lines(tb, table, direction);\n\n\t\tif (rc != 0\n\t\t    && tabtype == TABTYPE_KERNEL\n\t\t    && (flags & FL_NOSWAPMATCH)\n\t\t    && !(flags & FL_STRICTTARGET)\n\t\t    && get_match(COL_TARGET)) {\n\t\t\t/*\n\t\t\t * Found nothing, maybe the --target is regular file,\n\t\t\t * try it again with extra functionality for target\n\t\t\t * match\n\t\t\t */\n\t\t\tenable_extra_target_match(tb);\n\t\t\trc = add_matching_lines(tb, table, direction);\n\t\t}\n\t}\n\n\t/*\n\t * Print the output table for non-poll modes\n\t */\n\tif (!rc && !(flags & FL_POLL))\n\t\tscols_print_table(table);\nleave:\n\tscols_unref_table(table);\n\n\tmnt_unref_table(tb);\n\tmnt_unref_cache(cache);\n\n\tfree(tabfiles);\n#ifdef HAVE_LIBUDEV\n\tudev_unref(udev);\n#endif\n\treturn rc ? EXIT_FAILURE : EXIT_SUCCESS;\n}\n"], "fixing_code": ["<SECTION>\n<FILE>cache</FILE>\nlibmnt_cache\nmnt_new_cache\nmnt_free_cache\nmnt_ref_cache\nmnt_unref_cache\nmnt_cache_device_has_tag\nmnt_cache_find_tag_value\nmnt_cache_read_tags\nmnt_cache_set_targets\nmnt_get_fstype\nmnt_pretty_path\nmnt_resolve_path\nmnt_resolve_spec\nmnt_resolve_tag\nmnt_resolve_target\n</SECTION>\n\n<SECTION>\n<FILE>context</FILE>\nlibmnt_context\nlibmnt_ns\nmnt_free_context\nmnt_new_context\nmnt_reset_context\nmnt_context_append_options\nmnt_context_apply_fstab\nmnt_context_disable_canonicalize\nmnt_context_disable_helpers\nmnt_context_disable_mtab\nmnt_context_disable_swapmatch\nmnt_context_enable_fake\nmnt_context_enable_force\nmnt_context_enable_fork\nmnt_context_enable_lazy\nmnt_context_enable_loopdel\nmnt_context_enable_rdonly_umount\nmnt_context_enable_rwonly_mount\nmnt_context_enable_sloppy\nmnt_context_enable_verbose\nmnt_context_forced_rdonly\nmnt_context_force_unrestricted\nmnt_context_get_cache\nmnt_context_get_excode\nmnt_context_get_fs\nmnt_context_get_fstab\nmnt_context_get_fstab_userdata\nmnt_context_get_fstype\nmnt_context_get_fs_userdata\nmnt_context_get_helper_status\nmnt_context_get_lock\nmnt_context_get_mflags\nmnt_context_get_mtab\nmnt_context_get_mtab_userdata\nmnt_context_get_options\nmnt_context_get_optsmode\nmnt_context_get_origin_ns\nmnt_context_get_source\nmnt_context_get_status\nmnt_context_get_syscall_errno\nmnt_context_get_table\nmnt_context_get_target\nmnt_context_get_target_ns\nmnt_context_get_target_prefix\nmnt_context_get_user_mflags\nmnt_context_helper_executed\nmnt_context_helper_setopt\nmnt_context_init_helper\nmnt_context_is_child\nmnt_context_is_fake\nmnt_context_is_force\nmnt_context_is_fork\nmnt_context_is_fs_mounted\nmnt_context_is_lazy\nmnt_context_is_loopdel\nmnt_context_is_nocanonicalize\nmnt_context_is_nohelpers\nmnt_context_is_nomtab\nmnt_context_is_parent\nmnt_context_is_rdonly_umount\nmnt_context_is_restricted\nmnt_context_is_rwonly_mount\nmnt_context_is_sloppy\nmnt_context_is_swapmatch\nmnt_context_is_verbose\nmnt_context_reset_status\nmnt_context_set_cache\nmnt_context_set_fs\nmnt_context_set_fstab\nmnt_context_set_fstype\nmnt_context_set_fstype_pattern\nmnt_context_set_mflags\nmnt_context_set_mountdata\nmnt_context_set_options\nmnt_context_set_options_pattern\nmnt_context_set_optsmode\nmnt_context_set_passwd_cb\nmnt_context_set_source\nmnt_context_set_syscall_status\nmnt_context_set_tables_errcb\nmnt_context_set_target\nmnt_context_set_target_ns\nmnt_context_set_target_prefix\nmnt_context_set_user_mflags\nmnt_context_strerror\nmnt_context_switch_ns\nmnt_context_switch_origin_ns\nmnt_context_switch_target_ns\nmnt_context_syscall_called\nmnt_context_tab_applied\nmnt_context_wait_for_children\n<SUBSECTION>\nMNT_ERR_AMBIFS\nMNT_ERR_APPLYFLAGS\nMNT_ERR_LOOPDEV\nMNT_ERR_MOUNTOPT\nMNT_ERR_NOFSTAB\nMNT_ERR_NOFSTYPE\nMNT_ERR_NOSOURCE\nMNT_ERR_LOOPOVERLAP\nMNT_ERR_LOCK\nMNT_ERR_NAMESPACE\n<SUBSECTION>\nMNT_EX_SUCCESS\nMNT_EX_USAGE\nMNT_EX_SYSERR\nMNT_EX_SOFTWARE\nMNT_EX_USER\nMNT_EX_FILEIO\nMNT_EX_FAIL\nMNT_EX_SOMEOK\n</SECTION>\n\n<SECTION>\n<FILE>context-mount</FILE>\nmnt_context_do_mount\nmnt_context_finalize_mount\nmnt_context_mount\nmnt_context_next_mount\nmnt_context_next_remount\nmnt_context_prepare_mount\n<SUBSECTION>\nMNT_MS_COMMENT\nMNT_MS_GROUP\nMNT_MS_HELPER\nMNT_MS_LOOP\nMNT_MS_NETDEV\nMNT_MS_NOAUTO\nMNT_MS_NOFAIL\nMNT_MS_OFFSET\nMNT_MS_OWNER\nMNT_MS_SIZELIMIT\nMNT_MS_ENCRYPTION\nMNT_MS_UHELPER\nMNT_MS_USER\nMNT_MS_USERS\nMNT_MS_XCOMMENT\nMNT_MS_XFSTABCOMM\nMNT_MS_HASH_DEVICE\nMNT_MS_ROOT_HASH\nMNT_MS_HASH_OFFSET\nMNT_MS_ROOT_HASH_FILE\nMNT_MS_FEC_DEVICE\nMNT_MS_FEC_OFFSET\nMNT_MS_FEC_ROOTS\nMNT_MS_ROOT_HASH_SIG\n<SUBSECTION>\nMS_BIND\nMS_DIRSYNC\nMS_I_VERSION\nMS_MANDLOCK\nMS_MGC_MSK\nMS_MGC_VAL\nMS_MOVE\nMS_NOATIME\nMS_NODEV\nMS_NODIRATIME\nMS_NOEXEC\nMS_NOSUID\nMS_OWNERSECURE\nMS_PRIVATE\nMS_PROPAGATION\nMS_RDONLY\nMS_REC\nMS_RELATIME\nMS_REMOUNT\nMS_SECURE\nMS_SHARED\nMS_SILENT\nMS_SLAVE\nMS_STRICTATIME\nMS_SYNCHRONOUS\nMS_UNBINDABLE\nMS_LAZYTIME\n</SECTION>\n\n<SECTION>\n<FILE>context-umount</FILE>\nmnt_context_find_umount_fs\nmnt_context_do_umount\nmnt_context_finalize_umount\nmnt_context_next_umount\nmnt_context_prepare_umount\nmnt_context_umount\n</SECTION>\n\n<SECTION>\n<FILE>fs</FILE>\nlibmnt_fs\nmnt_copy_fs\nmnt_free_fs\nmnt_free_mntent\nmnt_ref_fs\nmnt_unref_fs\nmnt_fs_append_attributes\nmnt_fs_append_comment\nmnt_fs_append_options\nmnt_fs_get_attribute\nmnt_fs_get_attributes\nmnt_fs_get_bindsrc\nmnt_fs_get_comment\nmnt_fs_get_devno\nmnt_fs_get_freq\nmnt_fs_get_fs_options\nmnt_fs_get_fstype\nmnt_fs_get_id\nmnt_fs_get_option\nmnt_fs_get_optional_fields\nmnt_fs_get_options\nmnt_fs_get_parent_id\nmnt_fs_get_passno\nmnt_fs_get_priority\nmnt_fs_get_propagation\nmnt_fs_get_root\nmnt_fs_get_size\nmnt_fs_get_source\nmnt_fs_get_srcpath\nmnt_fs_get_swaptype\nmnt_fs_get_tag\nmnt_fs_get_table\nmnt_fs_get_target\nmnt_fs_get_tid\nmnt_fs_get_usedsize\nmnt_fs_get_userdata\nmnt_fs_get_user_options\nmnt_fs_get_vfs_options\nmnt_fs_get_vfs_options_all\nmnt_fs_is_kernel\nmnt_fs_is_netfs\nmnt_fs_is_pseudofs\nmnt_fs_is_regularfs\nmnt_fs_is_swaparea\nmnt_fs_match_fstype\nmnt_fs_match_options\nmnt_fs_match_source\nmnt_fs_match_target\nmnt_fs_prepend_attributes\nmnt_fs_prepend_options\nmnt_fs_print_debug\nmnt_fs_set_attributes\nmnt_fs_set_bindsrc\nmnt_fs_set_comment\nmnt_fs_set_freq\nmnt_fs_set_fstype\nmnt_fs_set_options\nmnt_fs_set_passno\nmnt_fs_set_priority\nmnt_fs_set_root\nmnt_fs_set_source\nmnt_fs_set_target\nmnt_fs_set_userdata\nmnt_fs_strdup_options\nmnt_fs_streq_srcpath\nmnt_fs_streq_target\nmnt_fs_to_mntent\nmnt_new_fs\nmnt_reset_fs\n</SECTION>\n\n<SECTION>\n<FILE>init</FILE>\nmnt_init_debug\n</SECTION>\n\n<SECTION>\n<FILE>iter</FILE>\nlibmnt_iter\nmnt_free_iter\nmnt_iter_get_direction\nmnt_new_iter\nmnt_reset_iter\n</SECTION>\n\n<SECTION>\n<FILE>lock</FILE>\nlibmnt_lock\nmnt_free_lock\nmnt_lock_file\nmnt_new_lock\nmnt_unlock_file\nmnt_lock_block_signals\n</SECTION>\n\n<SECTION>\n<FILE>optmap</FILE>\nlibmnt_optmap\nmnt_get_builtin_optmap\nMNT_INVERT\nMNT_NOMTAB\nMNT_PREFIX\nMNT_NOHLPS\n</SECTION>\n\n<SECTION>\n<FILE>optstr</FILE>\nmnt_optstr_append_option\nmnt_optstr_apply_flags\nmnt_optstr_deduplicate_option\nmnt_optstr_get_flags\nmnt_optstr_get_option\nmnt_optstr_get_options\nmnt_optstr_next_option\nmnt_optstr_prepend_option\nmnt_optstr_remove_option\nmnt_optstr_set_option\nmnt_split_optstr\nmnt_match_options\n</SECTION>\n\n<SECTION>\n<FILE>table</FILE>\nlibmnt_table\nmnt_free_table\nmnt_new_table\nmnt_reset_table\nmnt_ref_table\nmnt_unref_table\nmnt_new_table_from_dir\nmnt_new_table_from_file\nmnt_table_add_fs\nmnt_table_append_intro_comment\nmnt_table_append_trailing_comment\nmnt_table_enable_comments\nmnt_table_find_devno\nmnt_table_find_fs\nmnt_table_find_mountpoint\nmnt_table_find_next_fs\nmnt_table_find_pair\nmnt_table_find_source\nmnt_table_find_srcpath\nmnt_table_find_tag\nmnt_table_find_target\nmnt_table_find_target_with_option\nmnt_table_first_fs\nmnt_table_get_cache\nmnt_table_get_intro_comment\nmnt_table_get_nents\nmnt_table_get_root_fs\nmnt_table_get_trailing_comment\nmnt_table_get_userdata\nmnt_table_insert_fs\nmnt_table_is_empty\nmnt_table_is_fs_mounted\nmnt_table_last_fs\nmnt_table_move_fs\nmnt_table_next_child_fs\nmnt_table_next_fs\nmnt_table_over_fs\nmnt_table_parse_dir\nmnt_table_parse_file\nmnt_table_parse_fstab\nmnt_table_parse_mtab\nmnt_table_parse_stream\nmnt_table_parse_swaps\nmnt_table_remove_fs\nmnt_table_set_cache\nmnt_table_set_intro_comment\nmnt_table_set_iter\nmnt_table_set_parser_errcb\nmnt_table_set_trailing_comment\nmnt_table_set_userdata\nmnt_table_uniq_fs\nmnt_table_with_comments\n</SECTION>\n\n<SECTION>\n<FILE>tabdiff</FILE>\nlibmnt_tabdiff\nmnt_new_tabdiff\nmnt_free_tabdiff\nmnt_tabdiff_next_change\nmnt_diff_tables\n</SECTION>\n\n<SECTION>\n<FILE>update</FILE>\nlibmnt_update\nmnt_free_update\nmnt_new_update\nmnt_table_replace_file\nmnt_table_write_file\nmnt_update_force_rdonly\nmnt_update_get_filename\nmnt_update_get_fs\nmnt_update_get_mflags\nmnt_update_is_ready\nmnt_update_set_fs\nmnt_update_table\n</SECTION>\n\n<SECTION>\n<FILE>utils</FILE>\nmnt_fstype_is_netfs\nmnt_fstype_is_pseudofs\nmnt_get_fstab_path\nmnt_get_mountpoint\nmnt_get_mtab_path\nmnt_get_swaps_path\nmnt_guess_system_root\nmnt_has_regular_mtab\nmnt_mangle\nmnt_match_fstype\nmnt_tag_is_valid\nmnt_unmangle\n</SECTION>\n\n<SECTION>\n<FILE>version-utils</FILE>\nLIBMOUNT_MAJOR_VERSION\nLIBMOUNT_MINOR_VERSION\nLIBMOUNT_PATCH_VERSION\nmnt_parse_version_string\nmnt_get_library_version\nmnt_get_library_features\nLIBMOUNT_VERSION\n</SECTION>\n\n<SECTION>\n<FILE>monitor</FILE>\nlibmnt_monitor\nmnt_new_monitor\nmnt_ref_monitor\nmnt_unref_monitor\nmnt_monitor_enable_userspace\nmnt_monitor_enable_kernel\nmnt_monitor_get_fd\nmnt_monitor_close_fd\nmnt_monitor_next_change\nmnt_monitor_event_cleanup\nmnt_monitor_wait\n</SECTION>\n", "/* SPDX-License-Identifier: LGPL-2.1-or-later */\n/*\n * This file is part of libmount from util-linux project.\n *\n * Copyright (C) 2008-2018 Karel Zak <kzak@redhat.com>\n *\n * libmount is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n */\n\n/**\n * SECTION: fs\n * @title: Filesystem\n * @short_description: represents one entry from fstab, mtab, or mountinfo file\n *\n */\n#include <ctype.h>\n#include <blkid.h>\n#include <stddef.h>\n\n#include \"mountP.h\"\n#include \"strutils.h\"\n\n/**\n * mnt_new_fs:\n *\n * The initial refcount is 1, and needs to be decremented to\n * release the resources of the filesystem.\n *\n * Returns: newly allocated struct libmnt_fs.\n */\nstruct libmnt_fs *mnt_new_fs(void)\n{\n\tstruct libmnt_fs *fs = calloc(1, sizeof(*fs));\n\tif (!fs)\n\t\treturn NULL;\n\n\tfs->refcount = 1;\n\tINIT_LIST_HEAD(&fs->ents);\n\tDBG(FS, ul_debugobj(fs, \"alloc\"));\n\treturn fs;\n}\n\n/**\n * mnt_free_fs:\n * @fs: fs pointer\n *\n * Deallocates the fs. This function does not care about reference count. Don't\n * use this function directly -- it's better to use mnt_unref_fs().\n *\n * The reference counting is supported since util-linux v2.24.\n */\nvoid mnt_free_fs(struct libmnt_fs *fs)\n{\n\tif (!fs)\n\t\treturn;\n\n\tDBG(FS, ul_debugobj(fs, \"free [refcount=%d]\", fs->refcount));\n\n\tmnt_reset_fs(fs);\n\tfree(fs);\n}\n\n/**\n * mnt_reset_fs:\n * @fs: fs pointer\n *\n * Resets (zeroize) @fs.\n */\nvoid mnt_reset_fs(struct libmnt_fs *fs)\n{\n\tint ref;\n\n\tif (!fs)\n\t\treturn;\n\n\tref = fs->refcount;\n\n\tlist_del(&fs->ents);\n\tfree(fs->source);\n\tfree(fs->bindsrc);\n\tfree(fs->tagname);\n\tfree(fs->tagval);\n\tfree(fs->root);\n\tfree(fs->swaptype);\n\tfree(fs->target);\n\tfree(fs->fstype);\n\tfree(fs->optstr);\n\tfree(fs->vfs_optstr);\n\tfree(fs->fs_optstr);\n\tfree(fs->user_optstr);\n\tfree(fs->attrs);\n\tfree(fs->opt_fields);\n\tfree(fs->comment);\n\n\tmemset(fs, 0, sizeof(*fs));\n\tINIT_LIST_HEAD(&fs->ents);\n\tfs->refcount = ref;\n}\n\n/**\n * mnt_ref_fs:\n * @fs: fs pointer\n *\n * Increments reference counter.\n */\nvoid mnt_ref_fs(struct libmnt_fs *fs)\n{\n\tif (fs) {\n\t\tfs->refcount++;\n\t\t/*DBG(FS, ul_debugobj(fs, \"ref=%d\", fs->refcount));*/\n\t}\n}\n\n/**\n * mnt_unref_fs:\n * @fs: fs pointer\n *\n * De-increments reference counter, on zero the @fs is automatically\n * deallocated by mnt_free_fs().\n */\nvoid mnt_unref_fs(struct libmnt_fs *fs)\n{\n\tif (fs) {\n\t\tfs->refcount--;\n\t\t/*DBG(FS, ul_debugobj(fs, \"unref=%d\", fs->refcount));*/\n\t\tif (fs->refcount <= 0)\n\t\t\tmnt_free_fs(fs);\n\t}\n}\n\nstatic inline int update_str(char **dest, const char *src)\n{\n\tsize_t sz;\n\tchar *x;\n\n\tassert(dest);\n\n\tif (!src) {\n\t\tfree(*dest);\n\t\t*dest = NULL;\n\t\treturn 0;\t/* source (old) is empty */\n\t}\n\n\tsz = strlen(src) + 1;\n\tx = realloc(*dest, sz);\n\tif (!x)\n\t\treturn -ENOMEM;\n\t*dest = x;\n\tmemcpy(*dest, src, sz);\n\treturn 0;\n}\n\n/* This function does NOT overwrite (replace) the string in @new, the string in\n * @new has to be NULL otherwise this is no-op. */\nstatic inline int cpy_str_at_offset(void *new, const void *old, size_t offset)\n{\n\tchar **o = (char **) ((char *) old + offset);\n\tchar **n = (char **) ((char *) new + offset);\n\n\tif (*n)\n\t\treturn 0;\t/* already set, don't overwrite */\n\n\treturn update_str(n, *o);\n}\n\n/**\n * mnt_copy_fs:\n * @dest: destination FS\n * @src: source FS\n *\n * If @dest is NULL, then a new FS is allocated, if any @dest field is already\n * set, then the field is NOT overwritten.\n *\n * This function does not copy userdata (se mnt_fs_set_userdata()). A new copy is\n * not linked with any existing mnt_tab.\n *\n * Returns: @dest or NULL in case of error\n */\nstruct libmnt_fs *mnt_copy_fs(struct libmnt_fs *dest,\n\t\t\t      const struct libmnt_fs *src)\n{\n\tconst struct libmnt_fs *org = dest;\n\n\tif (!src)\n\t\treturn NULL;\n\tif (!dest) {\n\t\tdest = mnt_new_fs();\n\t\tif (!dest)\n\t\t\treturn NULL;\n\n\t\tdest->tab\t = NULL;\n\t}\n\n\tdest->id         = src->id;\n\tdest->parent     = src->parent;\n\tdest->devno      = src->devno;\n\tdest->tid        = src->tid;\n\n\tif (cpy_str_at_offset(dest, src, offsetof(struct libmnt_fs, source)))\n\t\tgoto err;\n\tif (cpy_str_at_offset(dest, src, offsetof(struct libmnt_fs, tagname)))\n\t\tgoto err;\n\tif (cpy_str_at_offset(dest, src, offsetof(struct libmnt_fs, tagval)))\n\t\tgoto err;\n\tif (cpy_str_at_offset(dest, src, offsetof(struct libmnt_fs, root)))\n\t\tgoto err;\n\tif (cpy_str_at_offset(dest, src, offsetof(struct libmnt_fs, swaptype)))\n\t\tgoto err;\n\tif (cpy_str_at_offset(dest, src, offsetof(struct libmnt_fs, target)))\n\t\tgoto err;\n\tif (cpy_str_at_offset(dest, src, offsetof(struct libmnt_fs, fstype)))\n\t\tgoto err;\n\tif (cpy_str_at_offset(dest, src, offsetof(struct libmnt_fs, optstr)))\n\t\tgoto err;\n\tif (cpy_str_at_offset(dest, src, offsetof(struct libmnt_fs, vfs_optstr)))\n\t\tgoto err;\n\tif (cpy_str_at_offset(dest, src, offsetof(struct libmnt_fs, fs_optstr)))\n\t\tgoto err;\n\tif (cpy_str_at_offset(dest, src, offsetof(struct libmnt_fs, user_optstr)))\n\t\tgoto err;\n\tif (cpy_str_at_offset(dest, src, offsetof(struct libmnt_fs, attrs)))\n\t\tgoto err;\n\tif (cpy_str_at_offset(dest, src, offsetof(struct libmnt_fs, bindsrc)))\n\t\tgoto err;\n\n\tdest->freq       = src->freq;\n\tdest->passno     = src->passno;\n\tdest->flags      = src->flags;\n\tdest->size\t = src->size;\n\tdest->usedsize   = src->usedsize;\n\tdest->priority   = src->priority;\n\n\treturn dest;\nerr:\n\tif (!org)\n\t\tmnt_free_fs(dest);\n\treturn NULL;\n}\n\n/*\n * This function copies all @fs description except information that does not\n * belong to /etc/mtab (e.g. VFS and userspace mount options with MNT_NOMTAB\n * mask).\n *\n * Returns: copy of @fs.\n */\nstruct libmnt_fs *mnt_copy_mtab_fs(const struct libmnt_fs *fs)\n{\n\tstruct libmnt_fs *n = mnt_new_fs();\n\n\tassert(fs);\n\tif (!n)\n\t\treturn NULL;\n\n\tif (strdup_between_structs(n, fs, source))\n\t\tgoto err;\n\tif (strdup_between_structs(n, fs, target))\n\t\tgoto err;\n\tif (strdup_between_structs(n, fs, fstype))\n\t\tgoto err;\n\n\tif (fs->vfs_optstr) {\n\t\tchar *p = NULL;\n\t\tmnt_optstr_get_options(fs->vfs_optstr, &p,\n\t\t\t\tmnt_get_builtin_optmap(MNT_LINUX_MAP),\n\t\t\t\tMNT_NOMTAB);\n\t\tn->vfs_optstr = p;\n\t}\n\n\tif (fs->user_optstr) {\n\t\tchar *p = NULL;\n\t\tmnt_optstr_get_options(fs->user_optstr, &p,\n\t\t\t\tmnt_get_builtin_optmap(MNT_USERSPACE_MAP),\n\t\t\t\tMNT_NOMTAB);\n\t\tn->user_optstr = p;\n\t}\n\n\tif (strdup_between_structs(n, fs, fs_optstr))\n\t\tgoto err;\n\n\t/* we cannot copy original optstr, the new optstr has to be without\n\t * non-mtab options -- so, let's generate a new string */\n\tn->optstr = mnt_fs_strdup_options(n);\n\n\tn->freq       = fs->freq;\n\tn->passno     = fs->passno;\n\tn->flags      = fs->flags;\n\n\treturn n;\nerr:\n\tmnt_free_fs(n);\n\treturn NULL;\n\n}\n\n/**\n * mnt_fs_get_userdata:\n * @fs: struct libmnt_file instance\n *\n * Returns: private data set by mnt_fs_set_userdata() or NULL.\n */\nvoid *mnt_fs_get_userdata(struct libmnt_fs *fs)\n{\n\tif (!fs)\n\t\treturn NULL;\n\treturn fs->userdata;\n}\n\n/**\n * mnt_fs_set_userdata:\n * @fs: struct libmnt_file instance\n * @data: user data\n *\n * The \"userdata\" are library independent data.\n *\n * Returns: 0 or negative number in case of error (if @fs is NULL).\n */\nint mnt_fs_set_userdata(struct libmnt_fs *fs, void *data)\n{\n\tif (!fs)\n\t\treturn -EINVAL;\n\tfs->userdata = data;\n\treturn 0;\n}\n\n/**\n * mnt_fs_get_srcpath:\n * @fs: struct libmnt_file (fstab/mtab/mountinfo) fs\n *\n * The mount \"source path\" is:\n * - a directory for 'bind' mounts (in fstab or mtab only)\n * - a device name for standard mounts\n *\n * See also mnt_fs_get_tag() and mnt_fs_get_source().\n *\n * Returns: mount source path or NULL in case of error or when the path\n * is not defined.\n */\nconst char *mnt_fs_get_srcpath(struct libmnt_fs *fs)\n{\n\tif (!fs)\n\t\treturn NULL;\n\n\t/* fstab-like fs */\n\tif (fs->tagname)\n\t\treturn NULL;\t/* the source contains a \"NAME=value\" */\n\treturn fs->source;\n}\n\n/**\n * mnt_fs_get_source:\n * @fs: struct libmnt_file (fstab/mtab/mountinfo) fs\n *\n * Returns: mount source. Note that the source could be unparsed TAG\n * (LABEL/UUID). See also mnt_fs_get_srcpath() and mnt_fs_get_tag().\n */\nconst char *mnt_fs_get_source(struct libmnt_fs *fs)\n{\n\treturn fs ? fs->source : NULL;\n}\n\n/*\n * Used by the parser ONLY (@source has to be freed on error)\n */\nint __mnt_fs_set_source_ptr(struct libmnt_fs *fs, char *source)\n{\n\tchar *t = NULL, *v = NULL;\n\n\tassert(fs);\n\n\tif (source && blkid_parse_tag_string(source, &t, &v) == 0 &&\n\t    !mnt_valid_tagname(t)) {\n\t\t/* parsable but unknown tag -- ignore */\n\t\tfree(t);\n\t\tfree(v);\n\t\tt = v = NULL;\n\t}\n\n\tif (fs->source != source)\n\t\tfree(fs->source);\n\n\tfree(fs->tagname);\n\tfree(fs->tagval);\n\n\tfs->source = source;\n\tfs->tagname = t;\n\tfs->tagval = v;\n\treturn 0;\n}\n\n/**\n * mnt_fs_set_source:\n * @fs: fstab/mtab/mountinfo entry\n * @source: new source\n *\n * This function creates a private copy (strdup()) of @source.\n *\n * Returns: 0 on success or negative number in case of error.\n */\nint mnt_fs_set_source(struct libmnt_fs *fs, const char *source)\n{\n\tchar *p = NULL;\n\tint rc;\n\n\tif (!fs)\n\t\treturn -EINVAL;\n\n\tif (source) {\n\t\tp = strdup(source);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t}\n\n\trc = __mnt_fs_set_source_ptr(fs, p);\n\tif (rc)\n\t\tfree(p);\n\treturn rc;\n}\n\n/**\n * mnt_fs_streq_srcpath:\n * @fs: fs\n * @path: source path\n *\n * Compares @fs source path with @path. The redundant slashes are ignored.\n * This function compares strings and does not canonicalize the paths.\n * See also more heavy and generic mnt_fs_match_source().\n *\n * Returns: 1 if @fs source path equal to @path, otherwise 0.\n */\nint mnt_fs_streq_srcpath(struct libmnt_fs *fs, const char *path)\n{\n\tconst char *p;\n\n\tif (!fs)\n\t\treturn 0;\n\n\tp = mnt_fs_get_srcpath(fs);\n\n\tif (!mnt_fs_is_pseudofs(fs))\n\t\treturn streq_paths(p, path);\n\n\tif (!p && !path)\n\t\treturn 1;\n\n\treturn p && path && strcmp(p, path) == 0;\n}\n\n/**\n * mnt_fs_get_table:\n * @fs: table entry\n * @tb: table that contains @fs\n *\n * Returns: 0 or negative number on error (if @fs or @tb is NULL).\n *\n * Since: 2.34\n */\nint mnt_fs_get_table(struct libmnt_fs *fs, struct libmnt_table **tb)\n{\n\tif (!fs || !tb)\n\t\treturn -EINVAL;\n\n\t*tb = fs->tab;\n\treturn 0;\n}\n\n/**\n * mnt_fs_streq_target:\n * @fs: fs\n * @path: mount point\n *\n * Compares @fs target path with @path. The redundant slashes are ignored.\n * This function compares strings and does not canonicalize the paths.\n * See also more generic mnt_fs_match_target().\n *\n * Returns: 1 if @fs target path equal to @path, otherwise 0.\n */\nint mnt_fs_streq_target(struct libmnt_fs *fs, const char *path)\n{\n\treturn fs && streq_paths(mnt_fs_get_target(fs), path);\n}\n\n/**\n * mnt_fs_get_tag:\n * @fs: fs\n * @name: returns pointer to NAME string\n * @value: returns pointer to VALUE string\n *\n * \"TAG\" is NAME=VALUE (e.g. LABEL=foo)\n *\n * The TAG is the first column in the fstab file. The TAG or \"srcpath\" always has\n * to be set for all entries.\n *\n * See also mnt_fs_get_source().\n *\n * <informalexample>\n *   <programlisting>\n *\tchar *src;\n *\tstruct libmnt_fs *fs = mnt_table_find_target(tb, \"/home\", MNT_ITER_FORWARD);\n *\n *\tif (!fs)\n *\t\tgoto err;\n *\n *\tsrc = mnt_fs_get_srcpath(fs);\n *\tif (!src) {\n *\t\tchar *tag, *val;\n *\t\tif (mnt_fs_get_tag(fs, &tag, &val) == 0)\n *\t\t\tprintf(\"%s: %s\\n\", tag, val);\t// LABEL or UUID\n *\t} else\n *\t\tprintf(\"device: %s\\n\", src);\t\t// device or bind path\n *   </programlisting>\n * </informalexample>\n *\n * Returns: 0 on success or negative number in case a TAG is not defined.\n */\nint mnt_fs_get_tag(struct libmnt_fs *fs, const char **name, const char **value)\n{\n\tif (fs == NULL || !fs->tagname)\n\t\treturn -EINVAL;\n\tif (name)\n\t\t*name = fs->tagname;\n\tif (value)\n\t\t*value = fs->tagval;\n\treturn 0;\n}\n\n/**\n * mnt_fs_get_target:\n * @fs: fstab/mtab/mountinfo entry pointer\n *\n * Returns: pointer to mountpoint path or NULL\n */\nconst char *mnt_fs_get_target(struct libmnt_fs *fs)\n{\n\treturn fs ? fs->target : NULL;\n}\n\n/**\n * mnt_fs_set_target:\n * @fs: fstab/mtab/mountinfo entry\n * @tgt: mountpoint\n *\n * This function creates a private copy (strdup()) of @tgt.\n *\n * Returns: 0 on success or negative number in case of error.\n */\nint mnt_fs_set_target(struct libmnt_fs *fs, const char *tgt)\n{\n\treturn strdup_to_struct_member(fs, target, tgt);\n}\n\nstatic int mnt_fs_get_flags(struct libmnt_fs *fs)\n{\n\treturn fs ? fs->flags : 0;\n}\n\n/**\n * mnt_fs_get_propagation:\n * @fs: mountinfo entry\n * @flags: returns propagation MS_* flags as present in the mountinfo file\n *\n * Note that this function sets @flags to zero if no propagation flags are found\n * in the mountinfo file. The kernel default is MS_PRIVATE, this flag is not stored\n * in the mountinfo file.\n *\n * Returns: 0 on success or negative number in case of error.\n */\nint mnt_fs_get_propagation(struct libmnt_fs *fs, unsigned long *flags)\n{\n\tif (!fs || !flags)\n\t\treturn -EINVAL;\n\n\t*flags = 0;\n\n\tif (!fs->opt_fields)\n\t\treturn 0;\n\n\t /*\n\t * The optional fields format is incompatible with mount options\n\t * ... we have to parse the field here.\n\t */\n\t*flags |= strstr(fs->opt_fields, \"shared:\") ? MS_SHARED : MS_PRIVATE;\n\n\tif (strstr(fs->opt_fields, \"master:\"))\n\t\t*flags |= MS_SLAVE;\n\tif (strstr(fs->opt_fields, \"unbindable\"))\n\t\t*flags |= MS_UNBINDABLE;\n\n\treturn 0;\n}\n\n/**\n * mnt_fs_is_kernel:\n * @fs: filesystem\n *\n * Returns: 1 if the filesystem description is read from kernel e.g. /proc/mounts.\n */\nint mnt_fs_is_kernel(struct libmnt_fs *fs)\n{\n\treturn mnt_fs_get_flags(fs) & MNT_FS_KERNEL;\n}\n\n/**\n * mnt_fs_is_swaparea:\n * @fs: filesystem\n *\n * Returns: 1 if the filesystem uses \"swap\" as a type\n */\nint mnt_fs_is_swaparea(struct libmnt_fs *fs)\n{\n\treturn mnt_fs_get_flags(fs) & MNT_FS_SWAP;\n}\n\n/**\n * mnt_fs_is_pseudofs:\n * @fs: filesystem\n *\n * Returns: 1 if the filesystem is a pseudo fs type (proc, cgroups)\n */\nint mnt_fs_is_pseudofs(struct libmnt_fs *fs)\n{\n\treturn mnt_fs_get_flags(fs) & MNT_FS_PSEUDO;\n}\n\n/**\n * mnt_fs_is_netfs:\n * @fs: filesystem\n *\n * Returns: 1 if the filesystem is a network filesystem\n */\nint mnt_fs_is_netfs(struct libmnt_fs *fs)\n{\n\treturn mnt_fs_get_flags(fs) & MNT_FS_NET;\n}\n\n/**\n * mnt_fs_is_regularfs:\n * @fs: filesystem\n *\n * Returns: 1 if the filesystem is a regular filesystem (not network or pseudo filesystem).\n *\n * Since: 2.38\n */\nint mnt_fs_is_regularfs(struct libmnt_fs *fs)\n{\n\treturn !(mnt_fs_is_pseudofs(fs)\n\t\t || mnt_fs_is_netfs(fs)\n\t\t || mnt_fs_is_swaparea(fs));\n}\n\n/**\n * mnt_fs_get_fstype:\n * @fs: fstab/mtab/mountinfo entry pointer\n *\n * Returns: pointer to filesystem type.\n */\nconst char *mnt_fs_get_fstype(struct libmnt_fs *fs)\n{\n\treturn fs ? fs->fstype : NULL;\n}\n\n/* Used by the struct libmnt_file parser only */\nint __mnt_fs_set_fstype_ptr(struct libmnt_fs *fs, char *fstype)\n{\n\tassert(fs);\n\n\tif (fstype != fs->fstype)\n\t\tfree(fs->fstype);\n\n\tfs->fstype = fstype;\n\tfs->flags &= ~MNT_FS_PSEUDO;\n\tfs->flags &= ~MNT_FS_NET;\n\tfs->flags &= ~MNT_FS_SWAP;\n\n\t/* save info about pseudo filesystems */\n\tif (fs->fstype) {\n\t\tif (mnt_fstype_is_pseudofs(fs->fstype))\n\t\t\tfs->flags |= MNT_FS_PSEUDO;\n\t\telse if (mnt_fstype_is_netfs(fs->fstype))\n\t\t\tfs->flags |= MNT_FS_NET;\n\t\telse if (!strcmp(fs->fstype, \"swap\"))\n\t\t\tfs->flags |= MNT_FS_SWAP;\n\t}\n\treturn 0;\n}\n\n/**\n * mnt_fs_set_fstype:\n * @fs: fstab/mtab/mountinfo entry\n * @fstype: filesystem type\n *\n * This function creates a private copy (strdup()) of @fstype.\n *\n * Returns: 0 on success or negative number in case of error.\n */\nint mnt_fs_set_fstype(struct libmnt_fs *fs, const char *fstype)\n{\n\tchar *p = NULL;\n\n\tif (!fs)\n\t\treturn -EINVAL;\n\tif (fstype) {\n\t\tp = strdup(fstype);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t}\n\treturn  __mnt_fs_set_fstype_ptr(fs, p);\n}\n\n/*\n * Merges @vfs and @fs options strings into a new string.\n * This function cares about 'ro/rw' options. The 'ro' is\n * always used if @vfs or @fs is read-only.\n * For example:\n *\n *    mnt_merge_optstr(\"rw,noexec\", \"ro,journal=update\")\n *\n *           returns: \"ro,noexec,journal=update\"\n *\n *    mnt_merge_optstr(\"rw,noexec\", \"rw,journal=update\")\n *\n *           returns: \"rw,noexec,journal=update\"\n */\nstatic char *merge_optstr(const char *vfs, const char *fs)\n{\n\tchar *res, *p;\n\tsize_t sz;\n\tint ro = 0, rw = 0;\n\n\tif (!vfs && !fs)\n\t\treturn NULL;\n\tif (!vfs || !fs)\n\t\treturn strdup(fs ? fs : vfs);\n\tif (!strcmp(vfs, fs))\n\t\treturn strdup(vfs);\t\t/* e.g. \"aaa\" and \"aaa\" */\n\n\t/* leave space for the leading \"r[ow],\", \",\" and the trailing zero */\n\tsz = strlen(vfs) + strlen(fs) + 5;\n\tres = malloc(sz);\n\tif (!res)\n\t\treturn NULL;\n\tp = res + 3;\t\t\t/* make a room for rw/ro flag */\n\n\tsnprintf(p, sz - 3, \"%s,%s\", vfs, fs);\n\n\t/* remove 'rw' flags */\n\trw += !mnt_optstr_remove_option(&p, \"rw\");\t/* from vfs */\n\trw += !mnt_optstr_remove_option(&p, \"rw\");\t/* from fs */\n\n\t/* remove 'ro' flags if necessary */\n\tif (rw != 2) {\n\t\tro += !mnt_optstr_remove_option(&p, \"ro\");\n\t\tif (ro + rw < 2)\n\t\t\tro += !mnt_optstr_remove_option(&p, \"ro\");\n\t}\n\n\tif (!strlen(p))\n\t\tmemcpy(res, ro ? \"ro\" : \"rw\", 3);\n\telse\n\t\tmemcpy(res, ro ? \"ro,\" : \"rw,\", 3);\n\treturn res;\n}\n\n/**\n * mnt_fs_strdup_options:\n * @fs: fstab/mtab/mountinfo entry pointer\n *\n * Merges all mount options (VFS, FS and userspace) to one options string\n * and returns the result. This function does not modify @fs.\n *\n * Returns: pointer to string (can be freed by free(3)) or NULL in case of error.\n */\nchar *mnt_fs_strdup_options(struct libmnt_fs *fs)\n{\n\tchar *res;\n\n\tif (!fs)\n\t\treturn NULL;\n\n\terrno = 0;\n\tif (fs->optstr)\n\t\treturn strdup(fs->optstr);\n\n\tres = merge_optstr(fs->vfs_optstr, fs->fs_optstr);\n\tif (!res && errno)\n\t\treturn NULL;\n\tif (fs->user_optstr &&\n\t    mnt_optstr_append_option(&res, fs->user_optstr, NULL)) {\n\t\tfree(res);\n\t\tres = NULL;\n\t}\n\treturn res;\n}\n\n/**\n * mnt_fs_get_options:\n * @fs: fstab/mtab/mountinfo entry pointer\n *\n * Returns: pointer to string or NULL in case of error.\n */\nconst char *mnt_fs_get_options(struct libmnt_fs *fs)\n{\n\treturn fs ? fs->optstr : NULL;\n}\n\n/**\n * mnt_fs_get_optional_fields\n * @fs: mountinfo entry pointer\n *\n * Returns: pointer to string with mountinfo optional fields\n *          or NULL in case of error.\n */\nconst char *mnt_fs_get_optional_fields(struct libmnt_fs *fs)\n{\n\treturn fs ? fs->opt_fields : NULL;\n}\n\n/**\n * mnt_fs_set_options:\n * @fs: fstab/mtab/mountinfo entry pointer\n * @optstr: options string\n *\n * Splits @optstr to VFS, FS and userspace mount options and updates relevant\n * parts of @fs.\n *\n * Returns: 0 on success, or negative number in case of error.\n */\nint mnt_fs_set_options(struct libmnt_fs *fs, const char *optstr)\n{\n\tchar *v = NULL, *f = NULL, *u = NULL, *n = NULL;\n\n\tif (!fs)\n\t\treturn -EINVAL;\n\tif (optstr) {\n\t\tint rc = mnt_split_optstr(optstr, &u, &v, &f, 0, 0);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tn = strdup(optstr);\n\t\tif (!n) {\n\t\t\tfree(u);\n\t\t\tfree(v);\n\t\t\tfree(f);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tfree(fs->fs_optstr);\n\tfree(fs->vfs_optstr);\n\tfree(fs->user_optstr);\n\tfree(fs->optstr);\n\n\tfs->fs_optstr = f;\n\tfs->vfs_optstr = v;\n\tfs->user_optstr = u;\n\tfs->optstr = n;\n\n\treturn 0;\n}\n\n/**\n * mnt_fs_append_options:\n * @fs: fstab/mtab/mountinfo entry\n * @optstr: mount options\n *\n * Parses (splits) @optstr and appends results to VFS, FS and userspace lists\n * of options.\n *\n * If @optstr is NULL, then @fs is not modified and 0 is returned.\n *\n * Returns: 0 on success or negative number in case of error.\n */\nint mnt_fs_append_options(struct libmnt_fs *fs, const char *optstr)\n{\n\tchar *v = NULL, *f = NULL, *u = NULL;\n\tint rc;\n\n\tif (!fs)\n\t\treturn -EINVAL;\n\tif (!optstr)\n\t\treturn 0;\n\n\trc = mnt_split_optstr(optstr, &u, &v, &f, 0, 0);\n\tif (rc)\n\t\treturn rc;\n\n\tif (!rc && v)\n\t\trc = mnt_optstr_append_option(&fs->vfs_optstr, v, NULL);\n\tif (!rc && f)\n\t\trc = mnt_optstr_append_option(&fs->fs_optstr, f, NULL);\n\tif (!rc && u)\n\t\trc = mnt_optstr_append_option(&fs->user_optstr, u, NULL);\n\tif (!rc)\n\t\trc = mnt_optstr_append_option(&fs->optstr, optstr, NULL);\n\n\tfree(v);\n\tfree(f);\n\tfree(u);\n\n\treturn rc;\n}\n\n/**\n * mnt_fs_prepend_options:\n * @fs: fstab/mtab/mountinfo entry\n * @optstr: mount options\n *\n * Parses (splits) @optstr and prepends the results to VFS, FS and userspace lists\n * of options.\n *\n * If @optstr is NULL, then @fs is not modified and 0 is returned.\n *\n * Returns: 0 on success or negative number in case of error.\n */\nint mnt_fs_prepend_options(struct libmnt_fs *fs, const char *optstr)\n{\n\tchar *v = NULL, *f = NULL, *u = NULL;\n\tint rc;\n\n\tif (!fs)\n\t\treturn -EINVAL;\n\tif (!optstr)\n\t\treturn 0;\n\n\trc = mnt_split_optstr(optstr, &u, &v, &f, 0, 0);\n\tif (rc)\n\t\treturn rc;\n\n\tif (!rc && v)\n\t\trc = mnt_optstr_prepend_option(&fs->vfs_optstr, v, NULL);\n\tif (!rc && f)\n\t\trc = mnt_optstr_prepend_option(&fs->fs_optstr, f, NULL);\n\tif (!rc && u)\n\t\trc = mnt_optstr_prepend_option(&fs->user_optstr, u, NULL);\n\tif (!rc)\n\t\trc = mnt_optstr_prepend_option(&fs->optstr, optstr, NULL);\n\n\tfree(v);\n\tfree(f);\n\tfree(u);\n\n\treturn rc;\n}\n\n/*\n * mnt_fs_get_fs_options:\n * @fs: fstab/mtab/mountinfo entry pointer\n *\n * Returns: pointer to superblock (fs-depend) mount option string or NULL.\n */\nconst char *mnt_fs_get_fs_options(struct libmnt_fs *fs)\n{\n\treturn fs ? fs->fs_optstr : NULL;\n}\n\n/**\n * mnt_fs_get_vfs_options:\n * @fs: fstab/mtab entry pointer\n *\n * Returns: pointer to fs-independent (VFS) mount option string or NULL.\n */\nconst char *mnt_fs_get_vfs_options(struct libmnt_fs *fs)\n{\n\treturn fs ? fs->vfs_optstr : NULL;\n}\n\n/**\n * mnt_fs_get_vfs_options_all:\n * @fs: fstab/mtab entry pointer\n *\n * Returns: pointer to newlly allocated string (can be freed by free(3)) or\n * NULL in case of error.  The string contains all (including defaults) mount\n * options.\n */\nchar *mnt_fs_get_vfs_options_all(struct libmnt_fs *fs)\n{\n\tconst struct libmnt_optmap *map = mnt_get_builtin_optmap(MNT_LINUX_MAP);\n\tconst struct libmnt_optmap *ent;\n\tconst char *opts = mnt_fs_get_options(fs);\n\tchar *result = NULL;\n\tunsigned long flags = 0;\n\n\tif (!opts || mnt_optstr_get_flags(opts, &flags, map))\n\t\treturn NULL;\n\n\tfor (ent = map ; ent && ent->name ; ent++){\n\t\tif (ent->id & flags) { /* non-default value */\n\t\t\tif (!(ent->mask & MNT_INVERT))\n\t\t\t\tmnt_optstr_append_option(&result, ent->name, NULL);\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t} else if (ent->mask & MNT_INVERT)\n\t\t\tmnt_optstr_append_option(&result, ent->name, NULL);\n\t}\n\n\treturn result;\n}\n\n/**\n * mnt_fs_get_user_options:\n * @fs: fstab/mtab entry pointer\n *\n * Returns: pointer to userspace mount option string or NULL.\n */\nconst char *mnt_fs_get_user_options(struct libmnt_fs *fs)\n{\n\treturn fs ? fs->user_optstr : NULL;\n}\n\n/**\n * mnt_fs_get_attributes:\n * @fs: fstab/mtab entry pointer\n *\n * Returns: pointer to attributes string or NULL.\n */\nconst char *mnt_fs_get_attributes(struct libmnt_fs *fs)\n{\n\treturn fs ? fs->attrs : NULL;\n}\n\n/**\n * mnt_fs_set_attributes:\n * @fs: fstab/mtab/mountinfo entry\n * @optstr: options string\n *\n * Sets mount attributes. The attributes are mount(2) and mount(8) independent\n * options, these options are not sent to the kernel and are not interpreted by\n * libmount. The attributes are stored in /run/mount/utab only.\n *\n * The attributes are managed by libmount in userspace only. It's possible\n * that information stored in userspace will not be available for libmount\n * after CLONE_FS unshare. Be careful, and don't use attributes if possible.\n *\n * Returns: 0 on success or negative number in case of error.\n */\nint mnt_fs_set_attributes(struct libmnt_fs *fs, const char *optstr)\n{\n\treturn strdup_to_struct_member(fs, attrs, optstr);\n}\n\n/**\n * mnt_fs_append_attributes\n * @fs: fstab/mtab/mountinfo entry\n * @optstr: options string\n *\n * Appends mount attributes. (See mnt_fs_set_attributes()).\n *\n * Returns: 0 on success or negative number in case of error.\n */\nint mnt_fs_append_attributes(struct libmnt_fs *fs, const char *optstr)\n{\n\tif (!fs)\n\t\treturn -EINVAL;\n\tif (!optstr)\n\t\treturn 0;\n\treturn mnt_optstr_append_option(&fs->attrs, optstr, NULL);\n}\n\n/**\n * mnt_fs_prepend_attributes\n * @fs: fstab/mtab/mountinfo entry\n * @optstr: options string\n *\n * Prepends mount attributes. (See mnt_fs_set_attributes()).\n *\n * Returns: 0 on success or negative number in case of error.\n */\nint mnt_fs_prepend_attributes(struct libmnt_fs *fs, const char *optstr)\n{\n\tif (!fs)\n\t\treturn -EINVAL;\n\tif (!optstr)\n\t\treturn 0;\n\treturn mnt_optstr_prepend_option(&fs->attrs, optstr, NULL);\n}\n\n\n/**\n * mnt_fs_get_freq:\n * @fs: fstab/mtab/mountinfo entry pointer\n *\n * Returns: dump frequency in days.\n */\nint mnt_fs_get_freq(struct libmnt_fs *fs)\n{\n\treturn fs ? fs->freq : 0;\n}\n\n/**\n * mnt_fs_set_freq:\n * @fs: fstab/mtab entry pointer\n * @freq: dump frequency in days\n *\n * Returns: 0 on success or negative number in case of error.\n */\nint mnt_fs_set_freq(struct libmnt_fs *fs, int freq)\n{\n\tif (!fs)\n\t\treturn -EINVAL;\n\tfs->freq = freq;\n\treturn 0;\n}\n\n/**\n * mnt_fs_get_passno:\n * @fs: fstab/mtab entry pointer\n *\n * Returns: \"pass number on parallel fsck\".\n */\nint mnt_fs_get_passno(struct libmnt_fs *fs)\n{\n\treturn fs ? fs->passno: 0;\n}\n\n/**\n * mnt_fs_set_passno:\n * @fs: fstab/mtab entry pointer\n * @passno: pass number\n *\n * Returns: 0 on success or negative number in case of error.\n */\nint mnt_fs_set_passno(struct libmnt_fs *fs, int passno)\n{\n\tif (!fs)\n\t\treturn -EINVAL;\n\tfs->passno = passno;\n\treturn 0;\n}\n\n/**\n * mnt_fs_get_root:\n * @fs: /proc/self/mountinfo entry\n *\n * Returns: root of the mount within the filesystem or NULL\n */\nconst char *mnt_fs_get_root(struct libmnt_fs *fs)\n{\n\treturn fs ? fs->root : NULL;\n}\n\n/**\n * mnt_fs_set_root:\n * @fs: mountinfo entry\n * @path: root path\n *\n * Returns: 0 on success or negative number in case of error.\n */\nint mnt_fs_set_root(struct libmnt_fs *fs, const char *path)\n{\n\treturn strdup_to_struct_member(fs, root, path);\n}\n\n/**\n * mnt_fs_get_swaptype:\n * @fs: /proc/swaps entry\n *\n * Returns: swap type or NULL\n */\nconst char *mnt_fs_get_swaptype(struct libmnt_fs *fs)\n{\n\treturn fs ? fs->swaptype : NULL;\n}\n\n/**\n * mnt_fs_get_size:\n * @fs: /proc/swaps entry\n *\n * Returns: size\n */\noff_t mnt_fs_get_size(struct libmnt_fs *fs)\n{\n\treturn fs ? fs->size : 0;\n}\n\n/**\n * mnt_fs_get_usedsize:\n * @fs: /proc/swaps entry\n *\n * Returns: used size\n */\noff_t mnt_fs_get_usedsize(struct libmnt_fs *fs)\n{\n\treturn fs ? fs->usedsize : 0;\n}\n\n/**\n * mnt_fs_get_priority:\n * @fs: /proc/swaps entry\n *\n * Returns: priority\n */\nint mnt_fs_get_priority(struct libmnt_fs *fs)\n{\n\treturn fs ? fs->priority : 0;\n}\n\n/**\n * mnt_fs_set_priority:\n * @fs: /proc/swaps entry\n * @prio: priority\n *\n * Since: 2.28\n *\n * Returns: 0 or -1 in case of error\n */\nint mnt_fs_set_priority(struct libmnt_fs *fs, int prio)\n{\n\tif (!fs)\n\t\treturn -EINVAL;\n\tfs->priority = prio;\n\treturn 0;\n}\n\n/**\n * mnt_fs_get_bindsrc:\n * @fs: /run/mount/utab entry\n *\n * Returns: full path that was used for mount(2) on MS_BIND\n */\nconst char *mnt_fs_get_bindsrc(struct libmnt_fs *fs)\n{\n\treturn fs ? fs->bindsrc : NULL;\n}\n\n/**\n * mnt_fs_set_bindsrc:\n * @fs: filesystem\n * @src: path\n *\n * Returns: 0 on success or negative number in case of error.\n */\nint mnt_fs_set_bindsrc(struct libmnt_fs *fs, const char *src)\n{\n\treturn strdup_to_struct_member(fs, bindsrc, src);\n}\n\n/**\n * mnt_fs_get_id:\n * @fs: /proc/self/mountinfo entry\n *\n * Returns: mount ID (unique identifier of the mount) or negative number in case of error.\n */\nint mnt_fs_get_id(struct libmnt_fs *fs)\n{\n\treturn fs ? fs->id : -EINVAL;\n}\n\n/**\n * mnt_fs_get_parent_id:\n * @fs: /proc/self/mountinfo entry\n *\n * Returns: parent mount ID or negative number in case of error.\n */\nint mnt_fs_get_parent_id(struct libmnt_fs *fs)\n{\n\treturn fs ? fs->parent : -EINVAL;\n}\n\n/**\n * mnt_fs_get_devno:\n * @fs: /proc/self/mountinfo entry\n *\n * Returns: value of st_dev for files on filesystem or 0 in case of error.\n */\ndev_t mnt_fs_get_devno(struct libmnt_fs *fs)\n{\n\treturn fs ? fs->devno : 0;\n}\n\n/**\n * mnt_fs_get_tid:\n * @fs: /proc/tid/mountinfo entry\n *\n * Returns: TID (task ID) for filesystems read from the mountinfo file\n */\npid_t mnt_fs_get_tid(struct libmnt_fs *fs)\n{\n\treturn fs ? fs->tid : 0;\n}\n\n/**\n * mnt_fs_get_option:\n * @fs: fstab/mtab/mountinfo entry pointer\n * @name: option name\n * @value: returns pointer to the beginning of the value (e.g. name=VALUE) or NULL\n * @valsz: returns size of options value or 0\n *\n * Returns: 0 on success, 1 when @name not found or negative number in case of error.\n */\nint mnt_fs_get_option(struct libmnt_fs *fs, const char *name,\n\t\tchar **value, size_t *valsz)\n{\n\tchar rc = 1;\n\n\tif (!fs)\n\t\treturn -EINVAL;\n\tif (fs->fs_optstr)\n\t\trc = mnt_optstr_get_option(fs->fs_optstr, name, value, valsz);\n\tif (rc == 1 && fs->vfs_optstr)\n\t\trc = mnt_optstr_get_option(fs->vfs_optstr, name, value, valsz);\n\tif (rc == 1 && fs->user_optstr)\n\t\trc = mnt_optstr_get_option(fs->user_optstr, name, value, valsz);\n\treturn rc;\n}\n\n/**\n * mnt_fs_get_attribute:\n * @fs: fstab/mtab/mountinfo entry pointer\n * @name: option name\n * @value: returns pointer to the beginning of the value (e.g. name=VALUE) or NULL\n * @valsz: returns size of options value or 0\n *\n * Returns: 0 on success, 1 when @name not found or negative number in case of error.\n */\nint mnt_fs_get_attribute(struct libmnt_fs *fs, const char *name,\n\t\tchar **value, size_t *valsz)\n{\n\tchar rc = 1;\n\n\tif (!fs)\n\t\treturn -EINVAL;\n\tif (fs->attrs)\n\t\trc = mnt_optstr_get_option(fs->attrs, name, value, valsz);\n\treturn rc;\n}\n\n/**\n * mnt_fs_get_comment:\n * @fs: fstab/mtab/mountinfo entry pointer\n *\n * Returns: 0 on success, 1 when not found the @name or negative number in case of error.\n */\nconst char *mnt_fs_get_comment(struct libmnt_fs *fs)\n{\n\tif (!fs)\n\t\treturn NULL;\n\treturn fs->comment;\n}\n\n/**\n * mnt_fs_set_comment:\n * @fs: fstab entry pointer\n * @comm: comment string\n *\n * Note that the comment has to be terminated by '\\n' (new line), otherwise\n * the whole filesystem entry will be written as a comment to the tabfile (e.g.\n * fstab).\n *\n * Returns: 0 on success or <0 in case of error.\n */\nint mnt_fs_set_comment(struct libmnt_fs *fs, const char *comm)\n{\n\treturn strdup_to_struct_member(fs, comment, comm);\n}\n\n/**\n * mnt_fs_append_comment:\n * @fs: fstab entry pointer\n * @comm: comment string\n *\n * See also mnt_fs_set_comment().\n *\n * Returns: 0 on success or <0 in case of error.\n */\nint mnt_fs_append_comment(struct libmnt_fs *fs, const char *comm)\n{\n\tif (!fs)\n\t\treturn -EINVAL;\n\n\treturn strappend(&fs->comment, comm);\n}\n\n/**\n * mnt_fs_match_target:\n * @fs: filesystem\n * @target: mountpoint path\n * @cache: tags/paths cache or NULL\n *\n * Possible are three attempts:\n *\t1) compare @target with @fs->target\n *\n *\t2) realpath(@target) with @fs->target\n *\n *\t3) realpath(@target) with realpath(@fs->target) if @fs is not from\n *\t   /proc/self/mountinfo.\n *\n *\t   However, if mnt_cache_set_targets(cache, mtab) was called, and the\n *\t   path @target or @fs->target is found in the @mtab, the canonicalization is\n *\t   is not performed (see mnt_resolve_target()).\n *\n * The 2nd and 3rd attempts are not performed when @cache is NULL.\n *\n * Returns: 1 if @fs target is equal to @target, else 0.\n */\nint mnt_fs_match_target(struct libmnt_fs *fs, const char *target,\n\t\t\tstruct libmnt_cache *cache)\n{\n\tint rc = 0;\n\n\tif (!fs || !target || !fs->target)\n\t\treturn 0;\n\n\t/* 1) native paths */\n\trc = mnt_fs_streq_target(fs, target);\n\n\tif (!rc && cache) {\n\t\t/* 2) - canonicalized and non-canonicalized */\n\t\tchar *cn = mnt_resolve_target(target, cache);\n\t\trc = (cn && mnt_fs_streq_target(fs, cn));\n\n\t\t/* 3) - canonicalized and canonicalized */\n\t\tif (!rc && cn && !mnt_fs_is_kernel(fs) && !mnt_fs_is_swaparea(fs)) {\n\t\t\tchar *tcn = mnt_resolve_target(fs->target, cache);\n\t\t\trc = (tcn && strcmp(cn, tcn) == 0);\n\t\t}\n\t}\n\n\treturn rc;\n}\n\n/**\n * mnt_fs_match_source:\n * @fs: filesystem\n * @source: tag or path (device or so) or NULL\n * @cache: tags/paths cache or NULL\n *\n * Four attempts are possible:\n *\t1) compare @source with @fs->source\n *\t2) compare realpath(@source) with @fs->source\n *\t3) compare realpath(@source) with realpath(@fs->source)\n *\t4) compare realpath(@source) with evaluated tag from @fs->source\n *\n * The 2nd, 3rd and 4th attempts are not performed when @cache is NULL. The\n * 2nd and 3rd attempts are not performed if @fs->source is tag.\n *\n * Returns: 1 if @fs source is equal to @source, else 0.\n */\nint mnt_fs_match_source(struct libmnt_fs *fs, const char *source,\n\t\t\tstruct libmnt_cache *cache)\n{\n\tchar *cn;\n\tconst char *src, *t, *v;\n\n\tif (!fs)\n\t\treturn 0;\n\n\t/* 1) native paths... */\n\tif (mnt_fs_streq_srcpath(fs, source) == 1)\n\t\treturn 1;\n\n\tif (!source || !fs->source)\n\t\treturn 0;\n\n\t/* ... and tags */\n\tif (fs->tagname && strcmp(source, fs->source) == 0)\n\t\treturn 1;\n\n\tif (!cache)\n\t\treturn 0;\n\tif (fs->flags & (MNT_FS_NET | MNT_FS_PSEUDO))\n\t\treturn 0;\n\n\tcn = mnt_resolve_spec(source, cache);\n\tif (!cn)\n\t\treturn 0;\n\n\t/* 2) canonicalized and native */\n\tsrc = mnt_fs_get_srcpath(fs);\n\tif (src && mnt_fs_streq_srcpath(fs, cn))\n\t\treturn 1;\n\n\t/* 3) canonicalized and canonicalized */\n\tif (src) {\n\t\tsrc = mnt_resolve_path(src, cache);\n\t\tif (src && !strcmp(cn, src))\n\t\t\treturn 1;\n\t}\n\tif (src || mnt_fs_get_tag(fs, &t, &v))\n\t\t/* src path does not match and the tag is not defined */\n\t\treturn 0;\n\n\t/* read @source's tags to the cache */\n\tif (mnt_cache_read_tags(cache, cn) < 0) {\n\t\tif (errno == EACCES) {\n\t\t\t/* we don't have permissions to read TAGs from\n\t\t\t * @source, but can translate the @fs tag to devname.\n\t\t\t *\n\t\t\t * (because libblkid uses udev symlinks and this is\n\t\t\t * accessible for non-root uses)\n\t\t\t */\n\t\t\tchar *x = mnt_resolve_tag(t, v, cache);\n\t\t\tif (x && !strcmp(x, cn))\n\t\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* 4) has the @source a tag that matches with the tag from @fs ? */\n\tif (mnt_cache_device_has_tag(cache, cn, t, v))\n\t\treturn 1;\n\n\treturn 0;\n}\n\n/**\n * mnt_fs_match_fstype:\n * @fs: filesystem\n * @types: filesystem name or comma delimited list of filesystems\n *\n * For more details see mnt_match_fstype().\n *\n * Returns: 1 if @fs type is matching to @types, else 0. The function returns\n * 0 when types is NULL.\n */\nint mnt_fs_match_fstype(struct libmnt_fs *fs, const char *types)\n{\n\treturn mnt_match_fstype(fs->fstype, types);\n}\n\n/**\n * mnt_fs_match_options:\n * @fs: filesystem\n * @options: comma delimited list of options (and nooptions)\n *\n * For more details see mnt_match_options().\n *\n * Returns: 1 if @fs type is matching to @options, else 0. The function returns\n * 0 when types is NULL.\n */\nint mnt_fs_match_options(struct libmnt_fs *fs, const char *options)\n{\n\treturn mnt_match_options(mnt_fs_get_options(fs), options);\n}\n\n/**\n * mnt_fs_print_debug\n * @fs: fstab/mtab/mountinfo entry\n * @file: file stream\n *\n * Returns: 0 on success or negative number in case of error.\n */\nint mnt_fs_print_debug(struct libmnt_fs *fs, FILE *file)\n{\n\tif (!fs || !file)\n\t\treturn -EINVAL;\n\tfprintf(file, \"------ fs:\\n\");\n\tfprintf(file, \"source: %s\\n\", mnt_fs_get_source(fs));\n\tfprintf(file, \"target: %s\\n\", mnt_fs_get_target(fs));\n\tfprintf(file, \"fstype: %s\\n\", mnt_fs_get_fstype(fs));\n\n\tif (mnt_fs_get_options(fs))\n\t\tfprintf(file, \"optstr: %s\\n\", mnt_fs_get_options(fs));\n\tif (mnt_fs_get_vfs_options(fs))\n\t\tfprintf(file, \"VFS-optstr: %s\\n\", mnt_fs_get_vfs_options(fs));\n\tif (mnt_fs_get_fs_options(fs))\n\t\tfprintf(file, \"FS-opstr: %s\\n\", mnt_fs_get_fs_options(fs));\n\tif (mnt_fs_get_user_options(fs))\n\t\tfprintf(file, \"user-optstr: %s\\n\", mnt_fs_get_user_options(fs));\n\tif (mnt_fs_get_optional_fields(fs))\n\t\tfprintf(file, \"optional-fields: '%s'\\n\", mnt_fs_get_optional_fields(fs));\n\tif (mnt_fs_get_attributes(fs))\n\t\tfprintf(file, \"attributes: %s\\n\", mnt_fs_get_attributes(fs));\n\n\tif (mnt_fs_get_root(fs))\n\t\tfprintf(file, \"root:   %s\\n\", mnt_fs_get_root(fs));\n\n\tif (mnt_fs_get_swaptype(fs))\n\t\tfprintf(file, \"swaptype: %s\\n\", mnt_fs_get_swaptype(fs));\n\tif (mnt_fs_get_size(fs))\n\t\tfprintf(file, \"size: %jd\\n\", mnt_fs_get_size(fs));\n\tif (mnt_fs_get_usedsize(fs))\n\t\tfprintf(file, \"usedsize: %jd\\n\", mnt_fs_get_usedsize(fs));\n\tif (mnt_fs_get_priority(fs))\n\t\tfprintf(file, \"priority: %d\\n\", mnt_fs_get_priority(fs));\n\n\tif (mnt_fs_get_bindsrc(fs))\n\t\tfprintf(file, \"bindsrc: %s\\n\", mnt_fs_get_bindsrc(fs));\n\tif (mnt_fs_get_freq(fs))\n\t\tfprintf(file, \"freq:   %d\\n\", mnt_fs_get_freq(fs));\n\tif (mnt_fs_get_passno(fs))\n\t\tfprintf(file, \"pass:   %d\\n\", mnt_fs_get_passno(fs));\n\tif (mnt_fs_get_id(fs))\n\t\tfprintf(file, \"id:     %d\\n\", mnt_fs_get_id(fs));\n\tif (mnt_fs_get_parent_id(fs))\n\t\tfprintf(file, \"parent: %d\\n\", mnt_fs_get_parent_id(fs));\n\tif (mnt_fs_get_devno(fs))\n\t\tfprintf(file, \"devno:  %d:%d\\n\", major(mnt_fs_get_devno(fs)),\n\t\t\t\t\t\tminor(mnt_fs_get_devno(fs)));\n\tif (mnt_fs_get_tid(fs))\n\t\tfprintf(file, \"tid:    %d\\n\", mnt_fs_get_tid(fs));\n\tif (mnt_fs_get_comment(fs))\n\t\tfprintf(file, \"comment: '%s'\\n\", mnt_fs_get_comment(fs));\n\n\treturn 0;\n}\n\n/**\n * mnt_free_mntent:\n * @mnt: mount entry\n *\n * Deallocates the \"mntent.h\" mount entry.\n */\nvoid mnt_free_mntent(struct mntent *mnt)\n{\n\tif (mnt) {\n\t\tfree(mnt->mnt_fsname);\n\t\tfree(mnt->mnt_dir);\n\t\tfree(mnt->mnt_type);\n\t\tfree(mnt->mnt_opts);\n\t\tfree(mnt);\n\t}\n}\n\n/**\n * mnt_fs_to_mntent:\n * @fs: filesystem\n * @mnt: mount description (as described in mntent.h)\n *\n * Copies the information from @fs to struct mntent @mnt. If @mnt is already set,\n * then the struct mntent items are reallocated and updated. See also\n * mnt_free_mntent().\n *\n * Returns: 0 on success and a negative number in case of error.\n */\nint mnt_fs_to_mntent(struct libmnt_fs *fs, struct mntent **mnt)\n{\n\tint rc;\n\tstruct mntent *m;\n\n\tif (!fs || !mnt)\n\t\treturn -EINVAL;\n\n\tm = *mnt;\n\tif (!m) {\n\t\tm = calloc(1, sizeof(*m));\n\t\tif (!m)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif ((rc = update_str(&m->mnt_fsname, mnt_fs_get_source(fs))))\n\t\tgoto err;\n\tif ((rc = update_str(&m->mnt_dir, mnt_fs_get_target(fs))))\n\t\tgoto err;\n\tif ((rc = update_str(&m->mnt_type, mnt_fs_get_fstype(fs))))\n\t\tgoto err;\n\n\terrno = 0;\n\tm->mnt_opts = mnt_fs_strdup_options(fs);\n\tif (!m->mnt_opts && errno) {\n\t\trc = -errno;\n\t\tgoto err;\n\t}\n\n\tm->mnt_freq = mnt_fs_get_freq(fs);\n\tm->mnt_passno = mnt_fs_get_passno(fs);\n\n\tif (!m->mnt_fsname) {\n\t\tm->mnt_fsname = strdup(\"none\");\n\t\tif (!m->mnt_fsname)\n\t\t\tgoto err;\n\t}\n\t*mnt = m;\n\n\treturn 0;\nerr:\n\tif (m != *mnt)\n\t\tmnt_free_mntent(m);\n\treturn rc;\n}\n", "/* SPDX-License-Identifier: LGPL-2.1-or-later */\n/*\n * libmount.h - libmount API\n *\n * This file is part of libmount from util-linux project.\n *\n * Copyright (C) 2008-2018 Karel Zak <kzak@redhat.com>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n\n#ifndef _LIBMOUNT_MOUNT_H\n#define _LIBMOUNT_MOUNT_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include <stdio.h>\n#include <mntent.h>\n#include <sys/types.h>\n\n/* Make sure libc MS_* definitions are used by default. Note that MS_* flags\n * may be already defined by linux/fs.h or another file -- in this case we\n * don't want to include sys/mount.h at all to avoid collisions.\n */\n#if defined(__linux__) && !defined(MS_RDONLY)\n# include <sys/mount.h>\n#endif\n\n#define LIBMOUNT_VERSION   \"@LIBMOUNT_VERSION@\"\n#define LIBMOUNT_MAJOR_VERSION   @LIBMOUNT_MAJOR_VERSION@\n#define LIBMOUNT_MINOR_VERSION   @LIBMOUNT_MINOR_VERSION@\n#define LIBMOUNT_PATCH_VERSION   @LIBMOUNT_PATCH_VERSION@\n\n/**\n * libmnt_cache:\n *\n * Stores canonicalized paths and evaluated tags\n */\nstruct libmnt_cache;\n\n/**\n * libmnt_lock:\n *\n * Stores information about the locked file (e.g. /etc/mtab)\n */\nstruct libmnt_lock;\n\n/**\n * libmnt_iter:\n *\n * Generic iterator (stores state about lists)\n */\nstruct libmnt_iter;\n\n/**\n * libmnt_optmap:\n * @name: option name[=type] where type is printf-like type specifier\")\n * @id: option ID or MS_* flags (e.g MS_RDONLY)\n * @mask: MNT_{NOMTAB,INVERT,...} mask\n *\n * Mount options description (map)\n */\nstruct libmnt_optmap\n{\n\tconst char\t*name;\n\tint\t\tid;\n\tint\t\tmask;\n};\n\n/*\n * mount options map masks\n */\n#define MNT_INVERT\t(1 << 1) /* invert the mountflag */\n#define MNT_NOMTAB\t(1 << 2) /* skip in the mtab option string */\n#define MNT_PREFIX\t(1 << 3) /* prefix used for some options (e.g. \"x-foo\") */\n#define MNT_NOHLPS\t(1 << 4) /* don't add the option to mount.<type> helpers command line */\n\n/**\n * libmnt_fs:\n *\n * Parsed fstab/mtab/mountinfo entry\n */\nstruct libmnt_fs;\n\n/**\n * libmnt_table:\n *\n * List of struct libmnt_fs entries (parsed fstab/mtab/mountinfo)\n */\nstruct libmnt_table;\n\n/**\n * libmnt_update\n *\n * /etc/mtab or utab update description\n */\nstruct libmnt_update;\n\n/**\n * libmnt_context\n *\n * Mount/umount status\n */\nstruct libmnt_context;\n\n/**\n * libmnt_monitor\n *\n * Mount tables monitor\n */\nstruct libmnt_monitor;\n\n/**\n * libmnt_tabdiff:\n *\n * Stores mountinfo state\n */\nstruct libmnt_tabdiff;\n\n/**\n * libmnt_ns:\n *\n * Describes mount namespace\n */\nstruct libmnt_ns;\n\n/*\n * Actions\n */\nenum {\n\tMNT_ACT_MOUNT = 1,\n\tMNT_ACT_UMOUNT\n};\n\n/*\n * Errors -- by default libmount returns -errno for generic errors (ENOMEM,\n * EINVAL, ...) and for mount(2) errors, but for some specific operations it\n * returns private error codes. Note that maximum system errno value should be\n * 4095 on UNIXes.\n *\n * See also mnt_context_get_syscall_errno() and mnt_context_get_helper_status().\n */\n/**\n * MNT_ERR_NOFSTAB:\n *\n * not found required entry in fstab\n */\n#define MNT_ERR_NOFSTAB      5000\n/**\n * MNT_ERR_NOFSTYPE:\n *\n * failed to detect filesystem type\n */\n#define MNT_ERR_NOFSTYPE     5001\n/**\n * MNT_ERR_NOSOURCE:\n *\n * required mount source undefined\n */\n#define MNT_ERR_NOSOURCE     5002\n/**\n * MNT_ERR_LOOPDEV:\n *\n * loopdev setup failed, errno set by libc\n */\n#define MNT_ERR_LOOPDEV      5003\n/**\n * MNT_ERR_MOUNTOPT:\n *\n * failed to parse/use userspace mount options\n */\n#define MNT_ERR_MOUNTOPT     5004\n/**\n * MNT_ERR_APPLYFLAGS:\n *\n * failed to apply MS_PROPAGATION flags\n */\n#define MNT_ERR_APPLYFLAGS   5005\n/**\n * MNT_ERR_AMBIFS:\n *\n * libblkid detected more filesystems on the device\n */\n#define MNT_ERR_AMBIFS       5006\n/**\n * MNT_ERR_LOOPOVERLAP:\n *\n * detected overlapping loop device that cannot be re-used\n */\n#define MNT_ERR_LOOPOVERLAP 5007\n/**\n * MNT_ERR_LOCK:\n *\n * failed to lock mtab/utab or so.\n */\n#define MNT_ERR_LOCK         5008\n/**\n * MNT_ERR_NAMESPACE:\n *\n * failed to switch namespace\n */\n#define MNT_ERR_NAMESPACE    5009\n\n\n/*\n * Overall return codes -- based on mount(8) and umount(8) return codes.\n * See mnt_context_get_excode() for more details.\n */\n\n/**\n * MNT_EX_SUCCESS:\n *\n * [u]mount(8) exit code: no errors\n */\n#define MNT_EX_SUCCESS\t0\n\n/**\n * MNT_EX_USAGE:\n *\n * [u]mount(8) exit code: incorrect invocation or permission\n */\n#define MNT_EX_USAGE\t1\n\n/**\n * MNT_EX_SYSERR:\n *\n * [u]mount(8) exit code: out of memory, cannot fork, ...\n */\n\n#define MNT_EX_SYSERR\t2\n\n/**\n * MNT_EX_SOFTWARE:\n *\n * [u]mount(8) exit code: internal mount bug or wrong version\n */\n#define MNT_EX_SOFTWARE\t4\n\n/**\n * MNT_EX_USER:\n *\n * [u]mount(8) exit code: user interrupt\n */\n#define MNT_EX_USER\t8\n\n/**\n * MNT_EX_FILEIO:\n *\n * [u]mount(8) exit code: problems writing, locking, ... mtab/utab\n */\n#define MNT_EX_FILEIO\t16\n\n/**\n * MNT_EX_FAIL:\n *\n * [u]mount(8) exit code: mount failure\n */\n#define MNT_EX_FAIL\t32\n\n/**\n * MNT_EX_SOMEOK:\n *\n * [u]mount(8) exit code: some mount succeeded; usually when executed with\n * --all options. Never returned by libmount.\n */\n#define MNT_EX_SOMEOK\t64\n\n\n\n#ifndef __GNUC_PREREQ\n# if defined __GNUC__ && defined __GNUC_MINOR__\n#  define __GNUC_PREREQ(maj, min)  ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((maj) << 16) + (min))\n# else\n#  define __GNUC_PREREQ(maj, min) 0\n# endif\n#endif\n\n#ifndef __ul_attribute__\n# if __GNUC_PREREQ (3, 4)\n#  define __ul_attribute__(_a_) __attribute__(_a_)\n# else\n#  define __ul_attribute__(_a_)\n# endif\n#endif\n\n\n/* init.c */\nextern void mnt_init_debug(int mask);\n\n/* version.c */\nextern int mnt_parse_version_string(const char *ver_string);\nextern int mnt_get_library_version(const char **ver_string);\nextern int mnt_get_library_features(const char ***features);\n\n/* utils.c */\nextern char *mnt_mangle(const char *str)\n\t\t\t__ul_attribute__((warn_unused_result));\nextern char *mnt_unmangle(const char *str)\n\t\t\t__ul_attribute__((warn_unused_result));\n\nextern int mnt_tag_is_valid(const char *tag);\nextern int mnt_fstype_is_netfs(const char *type);\nextern int mnt_fstype_is_pseudofs(const char *type);\n\nextern int mnt_match_fstype(const char *type, const char *pattern)\n\t\t\t__ul_attribute__((warn_unused_result));\nextern int mnt_match_options(const char *optstr, const char *pattern)\n\t\t\t__ul_attribute__((warn_unused_result));\nextern const char *mnt_get_fstab_path(void);\nextern const char *mnt_get_swaps_path(void);\nextern const char *mnt_get_mtab_path(void);\nextern int mnt_has_regular_mtab(const char **mtab, int *writable);\nextern char *mnt_get_mountpoint(const char *path)\n\t\t\t__ul_attribute__((warn_unused_result));\nextern int mnt_guess_system_root(dev_t devno, struct libmnt_cache *cache, char **path)\n\t\t\t__ul_attribute__((nonnull(3)));\n\n/* cache.c */\nextern struct libmnt_cache *mnt_new_cache(void)\n\t\t\t__ul_attribute__((warn_unused_result));\nextern void mnt_free_cache(struct libmnt_cache *cache);\n\nextern void mnt_ref_cache(struct libmnt_cache *cache);\nextern void mnt_unref_cache(struct libmnt_cache *cache);\n\nextern int mnt_cache_set_targets(struct libmnt_cache *cache,\n\t\t\t\tstruct libmnt_table *mtab);\nextern int mnt_cache_read_tags(struct libmnt_cache *cache, const char *devname);\n\nextern int mnt_cache_device_has_tag(struct libmnt_cache *cache,\n\t\t\t\tconst char *devname,\n                                const char *token,\n\t\t\t\tconst char *value);\n\nextern char *mnt_cache_find_tag_value(struct libmnt_cache *cache,\n\t\t\t\tconst char *devname, const char *token);\n\nextern char *mnt_get_fstype(const char *devname, int *ambi,\n\t\t\t    struct libmnt_cache *cache)\n\t\t\t__ul_attribute__((warn_unused_result));\nextern char *mnt_resolve_path(const char *path, struct libmnt_cache *cache)\n\t\t\t__ul_attribute__((warn_unused_result));\nextern char *mnt_resolve_target(const char *path, struct libmnt_cache *cache)\n\t\t\t__ul_attribute__((warn_unused_result));\nextern char *mnt_resolve_tag(const char *token, const char *value,\n\t\t\t     struct libmnt_cache *cache)\n\t\t\t__ul_attribute__((warn_unused_result));\nextern char *mnt_resolve_spec(const char *spec, struct libmnt_cache *cache)\n\t\t\t__ul_attribute__((warn_unused_result));\nextern char *mnt_pretty_path(const char *path, struct libmnt_cache *cache)\n\t\t\t__ul_attribute__((warn_unused_result));\n\n/* optstr.c */\nextern int mnt_optstr_next_option(char **optstr, char **name, size_t *namesz,\n\t\t\t\tchar **value, size_t *valuesz);\nextern int mnt_optstr_append_option(char **optstr, const char *name,\n\t\t\t\tconst char *value);\nextern int mnt_optstr_prepend_option(char **optstr, const char *name,\n\t\t\t\tconst char *value);\n\nextern int mnt_optstr_get_option(const char *optstr, const char *name,\n\t\t\t\tchar **value, size_t *valsz);\nextern int mnt_optstr_set_option(char **optstr, const char *name,\n\t\t\t\tconst char *value);\nextern int mnt_optstr_remove_option(char **optstr, const char *name);\nextern int mnt_optstr_deduplicate_option(char **optstr, const char *name);\n\nextern int mnt_split_optstr(const char *optstr,\n\t\t\t    char **user, char **vfs, char **fs,\n\t\t\t    int ignore_user, int ignore_vfs);\n\nextern int mnt_optstr_get_options(const char *optstr, char **subset,\n                            const struct libmnt_optmap *map, int ignore);\n\nextern int mnt_optstr_get_flags(const char *optstr, unsigned long *flags,\n\t\t\t\tconst struct libmnt_optmap *map);\n\nextern int mnt_optstr_apply_flags(char **optstr, unsigned long flags,\n                                const struct libmnt_optmap *map);\n\n/* iter.c */\nenum {\n\n\tMNT_ITER_FORWARD = 0,\n\tMNT_ITER_BACKWARD\n};\nextern struct libmnt_iter *mnt_new_iter(int direction)\n\t\t\t__ul_attribute__((warn_unused_result));\nextern void mnt_free_iter(struct libmnt_iter *itr);\n\nextern void mnt_reset_iter(struct libmnt_iter *itr, int direction)\n\t\t\t__ul_attribute__((nonnull));\nextern int mnt_iter_get_direction(struct libmnt_iter *itr)\n\t\t\t__ul_attribute__((nonnull));\n\n/* optmap.c */\nenum {\n\tMNT_LINUX_MAP = 1,\n\tMNT_USERSPACE_MAP\n};\nextern const struct libmnt_optmap *mnt_get_builtin_optmap(int id);\n\n/* lock.c */\nextern struct libmnt_lock *mnt_new_lock(const char *datafile, pid_t id)\n\t\t\t__ul_attribute__((warn_unused_result));\nextern void mnt_free_lock(struct libmnt_lock *ml);\n\nextern void mnt_unlock_file(struct libmnt_lock *ml);\nextern int mnt_lock_file(struct libmnt_lock *ml);\nextern int mnt_lock_block_signals(struct libmnt_lock *ml, int enable);\n\n/* fs.c */\nextern struct libmnt_fs *mnt_new_fs(void)\n\t\t\t__ul_attribute__((warn_unused_result));\nextern void mnt_free_fs(struct libmnt_fs *fs);\nextern void mnt_ref_fs(struct libmnt_fs *fs);\nextern void mnt_unref_fs(struct libmnt_fs *fs);\n\nextern void mnt_reset_fs(struct libmnt_fs *fs);\nextern struct libmnt_fs *mnt_copy_fs(struct libmnt_fs *dest,\n\t\t\t\t     const struct libmnt_fs *src)\n\t\t\t__ul_attribute__((warn_unused_result));\nextern void *mnt_fs_get_userdata(struct libmnt_fs *fs);\nextern int mnt_fs_set_userdata(struct libmnt_fs *fs, void *data);\nextern const char *mnt_fs_get_source(struct libmnt_fs *fs);\nextern int mnt_fs_set_source(struct libmnt_fs *fs, const char *source);\nextern const char *mnt_fs_get_srcpath(struct libmnt_fs *fs);\nextern int mnt_fs_get_table(struct libmnt_fs *fs, struct libmnt_table **tb);\n\nextern int mnt_fs_get_tag(struct libmnt_fs *fs, const char **name,\n\t\t\t  const char **value);\nextern const char *mnt_fs_get_target(struct libmnt_fs *fs);\nextern int mnt_fs_set_target(struct libmnt_fs *fs, const char *tgt);\nextern const char *mnt_fs_get_fstype(struct libmnt_fs *fs);\nextern int mnt_fs_set_fstype(struct libmnt_fs *fs, const char *fstype);\n\nextern int mnt_fs_streq_srcpath(struct libmnt_fs *fs, const char *path)\n\t\t\t__ul_attribute__((warn_unused_result));\nextern int mnt_fs_streq_target(struct libmnt_fs *fs, const char *path)\n\t\t\t__ul_attribute__((warn_unused_result));\n\nextern char *mnt_fs_strdup_options(struct libmnt_fs *fs)\n\t\t\t__ul_attribute__((warn_unused_result));\nextern const char *mnt_fs_get_options(struct libmnt_fs *fs)\n\t\t\t__ul_attribute__((warn_unused_result));\nextern const char *mnt_fs_get_optional_fields(struct libmnt_fs *fs)\n\t\t\t__ul_attribute__((warn_unused_result));\nextern int mnt_fs_get_propagation(struct libmnt_fs *fs, unsigned long *flags);\n\nextern int mnt_fs_set_options(struct libmnt_fs *fs, const char *optstr);\nextern int mnt_fs_append_options(struct libmnt_fs *fs, const char *optstr);\nextern int mnt_fs_prepend_options(struct libmnt_fs *fs, const char *optstr);\n\nextern int mnt_fs_get_option(struct libmnt_fs *fs, const char *name,\n\t\t\t\tchar **value, size_t *valsz);\n\nextern const char *mnt_fs_get_fs_options(struct libmnt_fs *fs);\nextern const char *mnt_fs_get_vfs_options(struct libmnt_fs *fs);\nextern const char *mnt_fs_get_user_options(struct libmnt_fs *fs);\nextern char *mnt_fs_get_vfs_options_all(struct libmnt_fs *fs);\n\nextern const char *mnt_fs_get_attributes(struct libmnt_fs *fs);\nextern int mnt_fs_set_attributes(struct libmnt_fs *fs, const char *optstr);\nextern int mnt_fs_get_attribute(struct libmnt_fs *fs, const char *name,\n\t\t\t\tchar **value, size_t *valsz);\nextern int mnt_fs_append_attributes(struct libmnt_fs *fs, const char *optstr);\nextern int mnt_fs_prepend_attributes(struct libmnt_fs *fs, const char *optstr);\n\nextern int mnt_fs_get_freq(struct libmnt_fs *fs);\nextern int mnt_fs_set_freq(struct libmnt_fs *fs, int freq);\nextern int mnt_fs_get_passno(struct libmnt_fs *fs);\nextern int mnt_fs_set_passno(struct libmnt_fs *fs, int passno);\nextern const char *mnt_fs_get_root(struct libmnt_fs *fs);\nextern int mnt_fs_set_root(struct libmnt_fs *fs, const char *path);\nextern const char *mnt_fs_get_bindsrc(struct libmnt_fs *fs);\nextern int mnt_fs_set_bindsrc(struct libmnt_fs *fs, const char *src);\nextern int mnt_fs_get_id(struct libmnt_fs *fs);\nextern int mnt_fs_get_parent_id(struct libmnt_fs *fs);\nextern dev_t mnt_fs_get_devno(struct libmnt_fs *fs);\nextern pid_t mnt_fs_get_tid(struct libmnt_fs *fs);\n\nextern const char *mnt_fs_get_swaptype(struct libmnt_fs *fs);\nextern off_t mnt_fs_get_size(struct libmnt_fs *fs);\nextern off_t mnt_fs_get_usedsize(struct libmnt_fs *fs);\nextern int mnt_fs_get_priority(struct libmnt_fs *fs);\nextern int mnt_fs_set_priority(struct libmnt_fs *fs, int prio);\n\nextern const char *mnt_fs_get_comment(struct libmnt_fs *fs);\nextern int mnt_fs_set_comment(struct libmnt_fs *fs, const char *comm);\nextern int mnt_fs_append_comment(struct libmnt_fs *fs, const char *comm);\n\nextern int mnt_fs_match_target(struct libmnt_fs *fs, const char *target,\n\t\t\t       struct libmnt_cache *cache);\nextern int mnt_fs_match_source(struct libmnt_fs *fs, const char *source,\n\t\t\t       struct libmnt_cache *cache);\nextern int mnt_fs_match_fstype(struct libmnt_fs *fs, const char *types);\nextern int mnt_fs_match_options(struct libmnt_fs *fs, const char *options);\nextern int mnt_fs_print_debug(struct libmnt_fs *fs, FILE *file);\n\nextern int mnt_fs_is_kernel(struct libmnt_fs *fs);\nextern int mnt_fs_is_swaparea(struct libmnt_fs *fs);\nextern int mnt_fs_is_netfs(struct libmnt_fs *fs);\nextern int mnt_fs_is_pseudofs(struct libmnt_fs *fs);\nextern int mnt_fs_is_regularfs(struct libmnt_fs *fs);\n\nextern void mnt_free_mntent(struct mntent *mnt);\nextern int mnt_fs_to_mntent(struct libmnt_fs *fs, struct mntent **mnt);\n\n/* tab-parse.c */\nextern struct libmnt_table *mnt_new_table_from_file(const char *filename)\n\t\t\t__ul_attribute__((warn_unused_result));\nextern struct libmnt_table *mnt_new_table_from_dir(const char *dirname)\n\t\t\t__ul_attribute__((warn_unused_result));\nextern int mnt_table_parse_stream(struct libmnt_table *tb, FILE *f,\n\t\t\t\t  const char *filename);\nextern int mnt_table_parse_file(struct libmnt_table *tb, const char *filename);\nextern int mnt_table_parse_dir(struct libmnt_table *tb, const char *dirname);\n\nextern int mnt_table_parse_fstab(struct libmnt_table *tb, const char *filename);\nextern int mnt_table_parse_swaps(struct libmnt_table *tb, const char *filename);\nextern int mnt_table_parse_mtab(struct libmnt_table *tb, const char *filename);\nextern int mnt_table_set_parser_errcb(struct libmnt_table *tb,\n                int (*cb)(struct libmnt_table *tb, const char *filename, int line));\n\n/* tab.c */\nextern struct libmnt_table *mnt_new_table(void)\n\t\t\t__ul_attribute__((warn_unused_result));\nextern void mnt_free_table(struct libmnt_table *tb);\n\nextern void mnt_ref_table(struct libmnt_table *tb);\nextern void mnt_unref_table(struct libmnt_table *tb);\n\nextern int mnt_reset_table(struct libmnt_table *tb);\nextern int mnt_table_get_nents(struct libmnt_table *tb);\nextern int mnt_table_is_empty(struct libmnt_table *tb);\n\nextern int mnt_table_set_userdata(struct libmnt_table *tb, void *data);\nextern void *mnt_table_get_userdata(struct libmnt_table *tb);\n\nextern void mnt_table_enable_comments(struct libmnt_table *tb, int enable);\nextern int mnt_table_with_comments(struct libmnt_table *tb);\nextern const char *mnt_table_get_intro_comment(struct libmnt_table *tb);\nextern int mnt_table_set_intro_comment(struct libmnt_table *tb, const char *comm);\nextern int mnt_table_append_intro_comment(struct libmnt_table *tb, const char *comm);\nextern int mnt_table_set_trailing_comment(struct libmnt_table *tb, const char *comm);\nextern const char *mnt_table_get_trailing_comment(struct libmnt_table *tb);\nextern int mnt_table_append_trailing_comment(struct libmnt_table *tb, const char *comm);\n\nextern int mnt_table_set_cache(struct libmnt_table *tb, struct libmnt_cache *mpc);\nextern struct libmnt_cache *mnt_table_get_cache(struct libmnt_table *tb);\nextern int mnt_table_add_fs(struct libmnt_table *tb, struct libmnt_fs *fs);\nextern int mnt_table_find_fs(struct libmnt_table *tb, struct libmnt_fs *fs);\nextern int mnt_table_insert_fs(struct libmnt_table *tb, int before,\n\t\t\t\tstruct libmnt_fs *pos, struct libmnt_fs *fs);\nextern int mnt_table_move_fs(struct libmnt_table *src, struct libmnt_table *dst,\n                      int before, struct libmnt_fs *pos, struct libmnt_fs *fs);\nextern int mnt_table_remove_fs(struct libmnt_table *tb, struct libmnt_fs *fs);\nextern int mnt_table_first_fs(struct libmnt_table *tb, struct libmnt_fs **fs);\nextern int mnt_table_last_fs(struct libmnt_table *tb, struct libmnt_fs **fs);\nextern int mnt_table_over_fs(struct libmnt_table *tb, struct libmnt_fs *parent,\n                             struct libmnt_fs **child);\nextern int mnt_table_next_fs(struct libmnt_table *tb, struct libmnt_iter *itr,\n\t\t\t     struct libmnt_fs **fs);\nextern int mnt_table_next_child_fs(struct libmnt_table *tb, struct libmnt_iter *itr,\n\t                        struct libmnt_fs *parent, struct libmnt_fs **chld);\nextern int mnt_table_get_root_fs(struct libmnt_table *tb, struct libmnt_fs **root);\nextern int mnt_table_set_iter(struct libmnt_table *tb, struct libmnt_iter *itr,\n\t\t\t      struct libmnt_fs *fs);\n\nenum {\n\tMNT_UNIQ_FORWARD  = (1 << 1),\t/* default is backward */\n\tMNT_UNIQ_KEEPTREE = (1 << 2)\n};\nextern int mnt_table_uniq_fs(struct libmnt_table *tb, int flags,\n\t\t\t\tint (*cmp)(struct libmnt_table *,\n\t\t\t\t\t   struct libmnt_fs *,\n\t\t\t\t\t   struct libmnt_fs *));\n\nextern struct libmnt_fs *mnt_table_find_mountpoint(struct libmnt_table *tb,\n\t\t\t\tconst char *path, int direction);\nextern struct libmnt_fs *mnt_table_find_target(struct libmnt_table *tb,\n\t\t\t\tconst char *path, int direction);\nextern struct libmnt_fs *mnt_table_find_srcpath(struct libmnt_table *tb,\n\t\t\t\tconst char *path, int direction);\nextern struct libmnt_fs *mnt_table_find_tag(struct libmnt_table *tb, const char *tag,\n\t\t\t\tconst char *val, int direction);\nextern struct libmnt_fs *mnt_table_find_target_with_option(struct libmnt_table *tb, const char *path,\n\t\t\tconst char *option, const char *val, int direction);\nextern struct libmnt_fs *mnt_table_find_source(struct libmnt_table *tb,\n\t\t\t\tconst char *source, int direction);\nextern struct libmnt_fs *mnt_table_find_pair(struct libmnt_table *tb,\n\t\t\t\tconst char *source,\n\t\t\t\tconst char *target, int direction);\nextern struct libmnt_fs *mnt_table_find_devno(struct libmnt_table *tb,\n\t\t\t\tdev_t devno, int direction);\n\nextern int mnt_table_find_next_fs(struct libmnt_table *tb,\n\t\t\tstruct libmnt_iter *itr,\n\t\t\tint (*match_func)(struct libmnt_fs *, void *),\n\t\t\tvoid *userdata,\n\t\t        struct libmnt_fs **fs);\n\nextern int mnt_table_is_fs_mounted(struct libmnt_table *tb, struct libmnt_fs *fstab_fs);\n\n/* tab_update.c */\nextern struct libmnt_update *mnt_new_update(void)\n\t\t\t__ul_attribute__((warn_unused_result));\nextern void mnt_free_update(struct libmnt_update *upd);\n\nextern int mnt_table_replace_file(struct libmnt_table *tb, const char *filename);\nextern int mnt_table_write_file(struct libmnt_table *tb, FILE *file);\n\nextern int mnt_update_is_ready(struct libmnt_update *upd);\nextern int mnt_update_set_fs(struct libmnt_update *upd, unsigned long mountflags,\n\t                      const char *target, struct libmnt_fs *fs);\nextern int mnt_update_table(struct libmnt_update *upd, struct libmnt_lock *lc);\nextern unsigned long mnt_update_get_mflags(struct libmnt_update *upd);\nextern int mnt_update_force_rdonly(struct libmnt_update *upd, int rdonly);\nextern const char *mnt_update_get_filename(struct libmnt_update *upd);\nextern struct libmnt_fs *mnt_update_get_fs(struct libmnt_update *upd);\n\n/* tab_diff.c */\nenum {\n\tMNT_TABDIFF_MOUNT = 1,\n\tMNT_TABDIFF_UMOUNT,\n\tMNT_TABDIFF_MOVE,\n\tMNT_TABDIFF_REMOUNT,\n\tMNT_TABDIFF_PROPAGATION,\t/* not implemented yet (TODO) */\n};\n\nextern struct libmnt_tabdiff *mnt_new_tabdiff(void)\n\t\t\t__ul_attribute__((warn_unused_result));\nextern void mnt_free_tabdiff(struct libmnt_tabdiff *df);\n\nextern int mnt_diff_tables(struct libmnt_tabdiff *df,\n\t\t\t   struct libmnt_table *old_tab,\n\t\t\t   struct libmnt_table *new_tab);\n\nextern int mnt_tabdiff_next_change(struct libmnt_tabdiff *df,\n\t\t\t\t   struct libmnt_iter *itr,\n\t\t\t\t   struct libmnt_fs **old_fs,\n\t\t\t\t   struct libmnt_fs **new_fs,\n\t\t\t\t   int *oper);\n\n/* monitor.c */\nenum {\n\tMNT_MONITOR_TYPE_USERSPACE = 1,\t/* userspace mount options */\n\tMNT_MONITOR_TYPE_KERNEL\t\t/* kernel mount table */\n};\n\nextern struct libmnt_monitor *mnt_new_monitor(void);\nextern void mnt_ref_monitor(struct libmnt_monitor *mn);\nextern void mnt_unref_monitor(struct libmnt_monitor *mn);\n\nextern int mnt_monitor_enable_kernel(struct libmnt_monitor *mn, int enable);\nextern int mnt_monitor_enable_userspace(struct libmnt_monitor *mn,\n\t\t\t\tint enable, const char *filename);\n\nextern int mnt_monitor_get_fd(struct libmnt_monitor *mn);\nextern int mnt_monitor_close_fd(struct libmnt_monitor *mn);\nextern int mnt_monitor_wait(struct libmnt_monitor *mn, int timeout);\n\nextern int mnt_monitor_next_change(struct libmnt_monitor *mn,\n\t\t\t     const char **filename, int *type);\nextern int mnt_monitor_event_cleanup(struct libmnt_monitor *mn);\n\n\n/* context.c */\n\n/*\n * Mode for mount options from fstab (or mtab), see mnt_context_set_optsmode().\n */\nenum {\n\tMNT_OMODE_IGNORE  = (1 << 1),\t/* ignore mtab/fstab options */\n\tMNT_OMODE_APPEND  = (1 << 2),\t/* append mtab/fstab options to existing options */\n\tMNT_OMODE_PREPEND = (1 << 3),\t/* prepend mtab/fstab options to existing options */\n\tMNT_OMODE_REPLACE = (1 << 4),\t/* replace existing options with options from mtab/fstab */\n\n\tMNT_OMODE_FORCE   = (1 << 5),   /* always read mtab/fstab options */\n\n\tMNT_OMODE_FSTAB   = (1 << 10),\t/* read from fstab */\n\tMNT_OMODE_MTAB    = (1 << 11),\t/* read from mtab if fstab not enabled or failed */\n\tMNT_OMODE_NOTAB   = (1 << 12),\t/* do not read fstab/mtab at all */\n\n\t/* default */\n\tMNT_OMODE_AUTO   = (MNT_OMODE_PREPEND | MNT_OMODE_FSTAB | MNT_OMODE_MTAB),\n\t/* non-root users */\n\tMNT_OMODE_USER   = (MNT_OMODE_REPLACE | MNT_OMODE_FORCE | MNT_OMODE_FSTAB)\n};\n\nextern struct libmnt_context *mnt_new_context(void)\n\t\t\t__ul_attribute__((warn_unused_result));\nextern void mnt_free_context(struct libmnt_context *cxt);\n\nextern int mnt_reset_context(struct libmnt_context *cxt);\nextern int mnt_context_is_restricted(struct libmnt_context *cxt)\n\t\t\t__ul_attribute__((nonnull));\nextern int mnt_context_force_unrestricted(struct libmnt_context *cxt);\n\nextern int mnt_context_init_helper(struct libmnt_context *cxt,\n\t\t\t\t   int action, int flags);\nextern int mnt_context_helper_setopt(struct libmnt_context *cxt, int c, char *arg);\n\nextern int mnt_context_set_optsmode(struct libmnt_context *cxt, int mode);\nextern int mnt_context_disable_canonicalize(struct libmnt_context *cxt, int disable);\nextern int mnt_context_enable_lazy(struct libmnt_context *cxt, int enable);\nextern int mnt_context_enable_rdonly_umount(struct libmnt_context *cxt, int enable);\nextern int mnt_context_enable_rwonly_mount(struct libmnt_context *cxt, int enable);\nextern int mnt_context_disable_helpers(struct libmnt_context *cxt, int disable);\nextern int mnt_context_enable_sloppy(struct libmnt_context *cxt, int enable);\nextern int mnt_context_enable_fake(struct libmnt_context *cxt, int enable);\nextern int mnt_context_disable_mtab(struct libmnt_context *cxt, int disable);\nextern int mnt_context_enable_force(struct libmnt_context *cxt, int enable);\nextern int mnt_context_enable_verbose(struct libmnt_context *cxt, int enable);\nextern int mnt_context_enable_loopdel(struct libmnt_context *cxt, int enable);\nextern int mnt_context_enable_fork(struct libmnt_context *cxt, int enable);\nextern int mnt_context_disable_swapmatch(struct libmnt_context *cxt, int disable);\n\nextern int mnt_context_get_optsmode(struct libmnt_context *cxt);\n\nextern int mnt_context_is_lazy(struct libmnt_context *cxt)\n\t\t\t__ul_attribute__((nonnull));\nextern int mnt_context_is_rdonly_umount(struct libmnt_context *cxt)\n\t\t\t__ul_attribute__((nonnull));\nextern int mnt_context_is_rwonly_mount(struct libmnt_context *cxt)\n\t\t\t__ul_attribute__((nonnull));\nextern int mnt_context_is_sloppy(struct libmnt_context *cxt)\n\t\t\t__ul_attribute__((nonnull));\nextern int mnt_context_is_fake(struct libmnt_context *cxt)\n\t\t\t__ul_attribute__((nonnull));\nextern int mnt_context_is_nomtab(struct libmnt_context *cxt)\n\t\t\t__ul_attribute__((nonnull));\nextern int mnt_context_is_force(struct libmnt_context *cxt)\n\t\t\t__ul_attribute__((nonnull));\nextern int mnt_context_is_verbose(struct libmnt_context *cxt)\n\t\t\t__ul_attribute__((nonnull));\nextern int mnt_context_is_loopdel(struct libmnt_context *cxt)\n\t\t\t__ul_attribute__((nonnull));\nextern int mnt_context_is_nohelpers(struct libmnt_context *cxt)\n\t\t\t__ul_attribute__((nonnull));\nextern int mnt_context_is_nocanonicalize(struct libmnt_context *cxt)\n\t\t\t__ul_attribute__((nonnull));\nextern int mnt_context_is_swapmatch(struct libmnt_context *cxt)\n\t\t\t__ul_attribute__((nonnull));\nextern int mnt_context_forced_rdonly(struct libmnt_context *cxt)\n\t\t\t__ul_attribute__((nonnull));\n\nextern int mnt_context_is_fork(struct libmnt_context *cxt)\n\t\t\t__ul_attribute__((nonnull));\nextern int mnt_context_is_parent(struct libmnt_context *cxt)\n\t\t\t__ul_attribute__((nonnull));\nextern int mnt_context_is_child(struct libmnt_context *cxt)\n\t\t\t__ul_attribute__((nonnull));\n\nextern int mnt_context_wait_for_children(struct libmnt_context *cxt,\n                                  int *nchildren, int *nerrs);\n\nextern int mnt_context_is_fs_mounted(struct libmnt_context *cxt,\n                              struct libmnt_fs *fs, int *mounted);\nextern int mnt_context_set_fs(struct libmnt_context *cxt, struct libmnt_fs *fs);\nextern struct libmnt_fs *mnt_context_get_fs(struct libmnt_context *cxt);\n\nextern int mnt_context_set_source(struct libmnt_context *cxt, const char *source);\nextern int mnt_context_set_target(struct libmnt_context *cxt, const char *target);\nextern int mnt_context_set_fstype(struct libmnt_context *cxt, const char *fstype);\nextern int mnt_context_set_target_prefix(struct libmnt_context *cxt, const char *path);\n\nextern const char *mnt_context_get_source(struct libmnt_context *cxt);\nextern const char *mnt_context_get_target(struct libmnt_context *cxt);\nextern const char *mnt_context_get_fstype(struct libmnt_context *cxt);\nextern const char *mnt_context_get_target_prefix(struct libmnt_context *cxt);\n\nextern void *mnt_context_get_mtab_userdata(struct libmnt_context *cxt);\nextern void *mnt_context_get_fstab_userdata(struct libmnt_context *cxt);\nextern void *mnt_context_get_fs_userdata(struct libmnt_context *cxt);\n\nextern int mnt_context_set_options(struct libmnt_context *cxt, const char *optstr);\nextern int mnt_context_append_options(struct libmnt_context *cxt, const char *optstr);\n\nextern const char *mnt_context_get_options(struct libmnt_context *cxt);\n\nextern int mnt_context_set_fstype_pattern(struct libmnt_context *cxt, const char *pattern);\nextern int mnt_context_set_options_pattern(struct libmnt_context *cxt, const char *pattern);\n\nextern int mnt_context_set_passwd_cb(struct libmnt_context *cxt,\n\t\t\t      char *(*get)(struct libmnt_context *),\n\t\t\t      void (*release)(struct libmnt_context *, char *))\n\t\t\t__ul_attribute__((deprecated));\n\nextern int mnt_context_set_tables_errcb(struct libmnt_context *cxt,\n        int (*cb)(struct libmnt_table *tb, const char *filename, int line));\nextern int mnt_context_set_fstab(struct libmnt_context *cxt,\n\t\t\t\t struct libmnt_table *tb);\nextern int mnt_context_get_fstab(struct libmnt_context *cxt,\n\t\t\t\t struct libmnt_table **tb);\n\nextern int mnt_context_get_mtab(struct libmnt_context *cxt,\n\t\t\t\tstruct libmnt_table **tb);\nextern int mnt_context_get_table(struct libmnt_context *cxt,\n\t\t\t\tconst char *filename,\n\t\t\t\tstruct libmnt_table **tb);\nextern int mnt_context_set_cache(struct libmnt_context *cxt,\n\t\t\t\t struct libmnt_cache *cache);\nextern struct libmnt_cache *mnt_context_get_cache(struct libmnt_context *cxt);\nextern struct libmnt_lock *mnt_context_get_lock(struct libmnt_context *cxt);\nextern int mnt_context_set_mflags(struct libmnt_context *cxt,\n\t\t\t\t      unsigned long flags);\nextern int mnt_context_get_mflags(struct libmnt_context *cxt,\n\t\t\t\t      unsigned long *flags);\nextern int mnt_context_set_user_mflags(struct libmnt_context *cxt,\n\t\t\t\t\t\tunsigned long flags);\nextern int mnt_context_get_user_mflags(struct libmnt_context *cxt,\n\t\t\t\t\t\tunsigned long *flags);\n\nextern int mnt_context_set_mountdata(struct libmnt_context *cxt, void *data);\nextern int mnt_context_apply_fstab(struct libmnt_context *cxt);\n\nextern int mnt_context_reset_status(struct libmnt_context *cxt);\nextern int mnt_context_get_status(struct libmnt_context *cxt);\n\nextern int mnt_context_helper_executed(struct libmnt_context *cxt);\nextern int mnt_context_get_helper_status(struct libmnt_context *cxt);\n\nextern int mnt_context_syscall_called(struct libmnt_context *cxt);\n\nextern int mnt_context_get_syscall_errno(struct libmnt_context *cxt);\n\nextern int mnt_context_strerror(struct libmnt_context *cxt, char *buf,\n\t\t\t\tsize_t bufsiz)\n\t\t\t\t__ul_attribute__((deprecated));\n\nextern int mnt_context_get_excode(struct libmnt_context *cxt,\n                        int rc, char *buf, size_t bufsz);\n\nextern int mnt_context_set_target_ns(struct libmnt_context *cxt, const char *path);\nextern struct libmnt_ns *mnt_context_get_target_ns(struct libmnt_context *cxt);\nextern struct libmnt_ns *mnt_context_get_origin_ns(struct libmnt_context *cxt);\nextern struct libmnt_ns *mnt_context_switch_ns(struct libmnt_context *cxt, struct libmnt_ns *ns);\nextern struct libmnt_ns *mnt_context_switch_origin_ns(struct libmnt_context *cxt);\nextern struct libmnt_ns *mnt_context_switch_target_ns(struct libmnt_context *cxt);\n\n\n/* context_mount.c */\nextern int mnt_context_mount(struct libmnt_context *cxt);\nextern int mnt_context_umount(struct libmnt_context *cxt);\nextern int mnt_context_next_mount(struct libmnt_context *cxt,\n\t\t\t\tstruct libmnt_iter *itr,\n\t\t\t\tstruct libmnt_fs **fs,\n\t\t\t\tint *mntrc, int *ignored);\n\nextern int mnt_context_next_remount(struct libmnt_context *cxt,\n                           struct libmnt_iter *itr,\n                           struct libmnt_fs **fs,\n                           int *mntrc,\n                           int *ignored);\n\nextern int mnt_context_prepare_mount(struct libmnt_context *cxt)\n\t\t\t__ul_attribute__((warn_unused_result));\nextern int mnt_context_do_mount(struct libmnt_context *cxt);\nextern int mnt_context_finalize_mount(struct libmnt_context *cxt);\n\n/* context_umount.c */\nextern int mnt_context_find_umount_fs(struct libmnt_context *cxt,\n\t\t\t       const char *tgt,\n\t\t\t       struct libmnt_fs **pfs);\nextern int mnt_context_next_umount(struct libmnt_context *cxt,\n\t\t\t\tstruct libmnt_iter *itr,\n\t\t\t\tstruct libmnt_fs **fs,\n\t\t\t\tint *mntrc, int *ignored);\n\nextern int mnt_context_prepare_umount(struct libmnt_context *cxt)\n\t\t\t__ul_attribute__((warn_unused_result));\nextern int mnt_context_do_umount(struct libmnt_context *cxt);\nextern int mnt_context_finalize_umount(struct libmnt_context *cxt);\n\nextern int mnt_context_tab_applied(struct libmnt_context *cxt);\nextern int mnt_context_set_syscall_status(struct libmnt_context *cxt, int status);\n\n/*\n * mount(8) userspace options masks (MNT_MAP_USERSPACE map)\n */\n#define MNT_MS_NOAUTO\t(1 << 2)\n#define MNT_MS_USER\t(1 << 3)\n#define MNT_MS_USERS\t(1 << 4)\n#define MNT_MS_OWNER\t(1 << 5)\n#define MNT_MS_GROUP\t(1 << 6)\n#define MNT_MS_NETDEV\t(1 << 7)\n#define MNT_MS_COMMENT  (1 << 8)\n#define MNT_MS_LOOP     (1 << 9)\n#define MNT_MS_NOFAIL   (1 << 10)\n#define MNT_MS_UHELPER  (1 << 11)\n#define MNT_MS_HELPER   (1 << 12)\n#define MNT_MS_XCOMMENT (1 << 13)\n#define MNT_MS_OFFSET   (1 << 14)\n#define MNT_MS_SIZELIMIT (1 << 15)\n#define MNT_MS_ENCRYPTION (1 << 16)\n#define MNT_MS_XFSTABCOMM (1 << 17)\n#define MNT_MS_HASH_DEVICE (1 << 18)\n#define MNT_MS_ROOT_HASH (1 << 19)\n#define MNT_MS_HASH_OFFSET (1 << 20)\n#define MNT_MS_ROOT_HASH_FILE (1 << 21)\n#define MNT_MS_FEC_DEVICE (1 << 22)\n#define MNT_MS_FEC_OFFSET (1 << 23)\n#define MNT_MS_FEC_ROOTS (1 << 24)\n#define MNT_MS_ROOT_HASH_SIG (1 << 25)\n#define MNT_MS_VERITY_ON_CORRUPTION (1 << 26)\n\n/*\n * mount(2) MS_* masks (MNT_MAP_LINUX map)\n */\n#ifndef MS_RDONLY\n#define MS_RDONLY\t 1\t/* Mount read-only */\n#endif\n#ifndef MS_NOSUID\n#define MS_NOSUID\t 2\t/* Ignore suid and sgid bits */\n#endif\n#ifndef MS_NODEV\n#define MS_NODEV\t 4\t/* Disallow access to device special files */\n#endif\n#ifndef MS_NOEXEC\n#define MS_NOEXEC\t 8\t/* Disallow program execution */\n#endif\n#ifndef MS_SYNCHRONOUS\n#define MS_SYNCHRONOUS\t16\t/* Writes are synced at once */\n#endif\n#ifndef MS_REMOUNT\n#define MS_REMOUNT\t32\t/* Alter flags of a mounted FS */\n#endif\n#ifndef MS_MANDLOCK\n#define MS_MANDLOCK\t64\t/* Allow mandatory locks on an FS */\n#endif\n#ifndef MS_DIRSYNC\n#define MS_DIRSYNC\t128\t/* Directory modifications are synchronous */\n#endif\n#ifndef MS_NOSYMFOLLOW\n#define MS_NOSYMFOLLOW\t256\t/* Don't follow symlinks */\n#endif\n#ifndef MS_NOATIME\n#define MS_NOATIME\t0x400\t/* 1024: Do not update access times. */\n#endif\n#ifndef MS_NODIRATIME\n#define MS_NODIRATIME   0x800\t/* 2048: Don't update directory access times */\n#endif\n#ifndef MS_BIND\n#define\tMS_BIND\t\t0x1000\t/* 4096: Mount existing tree elsewhere as well */\n#endif\n#ifndef MS_MOVE\n#define MS_MOVE\t\t0x2000\t/* 8192: Atomically move the tree */\n#endif\n#ifndef MS_REC\n#define MS_REC\t\t0x4000\t/* 16384: Recursive loopback */\n#endif\n#ifndef MS_SILENT\n#define MS_SILENT\t0x8000\t/* 32768: Don't emit certain kernel messages */\n#endif\n#ifndef MS_UNBINDABLE\n#define MS_UNBINDABLE\t(1<<17)\t/* 131072: Make unbindable */\n#endif\n#ifndef MS_PRIVATE\n#define MS_PRIVATE\t(1<<18)\t/* 262144: Make private */\n#endif\n#ifndef MS_SLAVE\n#define MS_SLAVE\t(1<<19)\t/* 524288: Make slave */\n#endif\n#ifndef MS_SHARED\n#define MS_SHARED\t(1<<20)\t/* 1048576: Make shared */\n#endif\n#ifndef MS_RELATIME\n#define MS_RELATIME\t(1<<21) /* 2097152: Update atime relative to mtime/ctime */\n#endif\n#ifndef MS_I_VERSION\n#define MS_I_VERSION\t(1<<23)\t/* Update the inode I_version field */\n#endif\n#ifndef MS_STRICTATIME\n#define MS_STRICTATIME\t(1<<24) /* Always perform atime updates */\n#endif\n#ifndef MS_LAZYTIME\n#define MS_LAZYTIME     (1<<25) /* Update the on-disk [acm]times lazily */\n#endif\n\n\n/*\n * Magic mount flag number. Had to be or-ed to the flag values.  Deprecated and\n * no more used since libmount v2.33; required for Linux <= 2.4.\n */\n#ifndef MS_MGC_VAL\n#define MS_MGC_VAL 0xC0ED0000\t/* magic flag number to indicate \"new\" flags */\n#endif\n#ifndef MS_MGC_MSK\n#define MS_MGC_MSK 0xffff0000\t/* magic flag number mask */\n#endif\n\n\n/* Shared-subtree options */\n#define MS_PROPAGATION  (MS_SHARED|MS_SLAVE|MS_UNBINDABLE|MS_PRIVATE)\n\n/* Options that we make ordinary users have by default.  */\n#define MS_SECURE\t(MS_NOEXEC|MS_NOSUID|MS_NODEV)\n\n/* Options that we make owner-mounted devices have by default */\n#define MS_OWNERSECURE\t(MS_NOSUID|MS_NODEV)\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* _LIBMOUNT_MOUNT_H */\n", "/*\n * SPDX-License-Identifier: LGPL-2.1-or-later\n *\n * This file is part of libmount from util-linux project.\n *\n * Copyright (C) 2011-2018 Karel Zak <kzak@redhat.com>\n *\n * libmount is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n *\n * The symbol versioning ensures that a new application requiring symbol foo,\n * can't run with old library.so not providing foo.\n *\n * Version info can't enforce this since we never change the SONAME.\n */\nMOUNT_2.19 {\nglobal:\n\tmnt_cache_device_has_tag;\n\tmnt_cache_find_tag_value;\n\tmnt_cache_read_tags;\n\tmnt_context_append_options;\n\tmnt_context_apply_fstab;\n\tmnt_context_disable_canonicalize;\n\tmnt_context_disable_helpers;\n\tmnt_context_disable_mtab;\n\tmnt_context_do_mount;\n\tmnt_context_do_umount;\n\tmnt_context_enable_fake;\n\tmnt_context_enable_force;\n\tmnt_context_enable_lazy;\n\tmnt_context_enable_loopdel;\n\tmnt_context_enable_rdonly_umount;\n\tmnt_context_enable_sloppy;\n\tmnt_context_enable_verbose;\n\tmnt_context_finalize_mount;\n\tmnt_context_finalize_umount;\n\tmnt_context_get_cache;\n\tmnt_context_get_fs;\n\tmnt_context_get_fstab;\n\tmnt_context_get_fstype;\n\tmnt_context_get_lock;\n\tmnt_context_get_mflags;\n\tmnt_context_get_mtab;\n\tmnt_context_get_optsmode;\n\tmnt_context_get_source;\n\tmnt_context_get_status;\n\tmnt_context_get_target;\n\tmnt_context_get_user_mflags;\n\tmnt_context_helper_setopt;\n\tmnt_context_init_helper;\n\tmnt_context_is_fake;\n\tmnt_context_is_force;\n\tmnt_context_is_lazy;\n\tmnt_context_is_nomtab;\n\tmnt_context_is_rdonly_umount;\n\tmnt_context_is_restricted;\n\tmnt_context_is_sloppy;\n\tmnt_context_is_verbose;\n\tmnt_context_mount;\n\tmnt_context_prepare_mount;\n\tmnt_context_prepare_umount;\n\tmnt_context_set_cache;\n\tmnt_context_set_fs;\n\tmnt_context_set_fstab;\n\tmnt_context_set_fstype;\n\tmnt_context_set_fstype_pattern;\n\tmnt_context_set_mflags;\n\tmnt_context_set_mountdata;\n\tmnt_context_set_options;\n\tmnt_context_set_options_pattern;\n\tmnt_context_set_optsmode;\n\tmnt_context_set_source;\n\tmnt_context_set_syscall_status;\n\tmnt_context_set_target;\n\tmnt_context_set_user_mflags;\n\tmnt_context_strerror;\n\tmnt_context_umount;\n\tmnt_copy_fs;\n\tmnt_free_cache;\n\tmnt_free_context;\n\tmnt_free_fs;\n\tmnt_free_iter;\n\tmnt_free_lock;\n\tmnt_free_mntent;\n\tmnt_free_table;\n\tmnt_free_update;\n\tmnt_fs_append_attributes;\n\tmnt_fs_append_options;\n\tmnt_fs_get_attribute;\n\tmnt_fs_get_attributes;\n\tmnt_fs_get_bindsrc;\n\tmnt_fs_get_devno;\n\tmnt_fs_get_freq;\n\tmnt_fs_get_fs_options;\n\tmnt_fs_get_fstype;\n\tmnt_fs_get_id;\n\tmnt_fs_get_option;\n\tmnt_fs_get_parent_id;\n\tmnt_fs_get_passno;\n\tmnt_fs_get_root;\n\tmnt_fs_get_source;\n\tmnt_fs_get_srcpath;\n\tmnt_fs_get_tag;\n\tmnt_fs_get_target;\n\tmnt_fs_get_userdata;\n\tmnt_fs_get_user_options;\n\tmnt_fs_get_vfs_options;\n\tmnt_fs_is_kernel;\n\tmnt_fs_match_fstype;\n\tmnt_fs_match_options;\n\tmnt_fs_match_source;\n\tmnt_fs_match_target;\n\tmnt_fs_prepend_attributes;\n\tmnt_fs_prepend_options;\n\tmnt_fs_print_debug;\n\tmnt_fs_set_attributes;\n\tmnt_fs_set_bindsrc;\n\tmnt_fs_set_freq;\n\tmnt_fs_set_fstype;\n\tmnt_fs_set_options;\n\tmnt_fs_set_passno;\n\tmnt_fs_set_root;\n\tmnt_fs_set_source;\n\tmnt_fs_set_target;\n\tmnt_fs_set_userdata;\n\tmnt_fs_strdup_options;\n\tmnt_fs_to_mntent;\n\tmnt_fstype_is_netfs;\n\tmnt_fstype_is_pseudofs;\n\tmnt_get_builtin_optmap;\n\tmnt_get_fstab_path;\n\tmnt_get_fstype;\n\tmnt_get_library_version;\n\tmnt_get_mtab_path;\n\tmnt_has_regular_mtab;\n\tmnt_init_debug;\n\tmnt_iter_get_direction;\n\tmnt_lock_file;\n\tmnt_mangle;\n\tmnt_match_fstype;\n\tmnt_match_options;\n\tmnt_new_cache;\n\tmnt_new_context;\n\tmnt_new_fs;\n\tmnt_new_iter;\n\tmnt_new_lock;\n\tmnt_new_table;\n\tmnt_new_table_from_dir;\n\tmnt_new_table_from_file;\n\tmnt_new_update;\n\tmnt_optstr_append_option;\n\tmnt_optstr_apply_flags;\n\tmnt_optstr_get_flags;\n\tmnt_optstr_get_option;\n\tmnt_optstr_get_options;\n\tmnt_optstr_next_option;\n\tmnt_optstr_prepend_option;\n\tmnt_optstr_remove_option;\n\tmnt_optstr_set_option;\n\tmnt_parse_version_string;\n\tmnt_reset_context;\n\tmnt_reset_fs;\n\tmnt_reset_iter;\n\tmnt_resolve_path;\n\tmnt_resolve_spec;\n\tmnt_resolve_tag;\n\tmnt_split_optstr;\n\tmnt_table_add_fs;\n\tmnt_table_find_next_fs;\n\tmnt_table_find_pair;\n\tmnt_table_find_source;\n\tmnt_table_find_srcpath;\n\tmnt_table_find_tag;\n\tmnt_table_find_target;\n\tmnt_table_get_cache;\n\tmnt_table_get_nents;\n\tmnt_table_get_root_fs;\n\tmnt_table_next_child_fs;\n\tmnt_table_next_fs;\n\tmnt_table_parse_file;\n\tmnt_table_parse_fstab;\n\tmnt_table_parse_mtab;\n\tmnt_table_parse_stream;\n\tmnt_table_remove_fs;\n\tmnt_table_set_cache;\n\tmnt_table_set_iter;\n\tmnt_table_set_parser_errcb;\n\tmnt_unlock_file;\n\tmnt_unmangle;\n\tmnt_update_force_rdonly;\n\tmnt_update_get_filename;\n\tmnt_update_get_fs;\n\tmnt_update_get_mflags;\n\tmnt_update_is_ready;\n\tmnt_update_set_fs;\n\tmnt_update_table;\nlocal:\n\t*;\n};\n\nMOUNT_2.20 {\nglobal:\n\tmnt_context_get_table;\n\tmnt_context_is_fs_mounted;\n\tmnt_context_next_mount;\n\tmnt_context_set_tables_errcb;\n\tmnt_diff_tables;\n\tmnt_free_tabdiff;\n\tmnt_fs_get_options;\n\tmnt_lock_block_signals;\n\tmnt_new_tabdiff;\n\tmnt_pretty_path;\n\tmnt_reset_table;\n\tmnt_tabdiff_next_change;\n\tmnt_table_is_fs_mounted;\n} MOUNT_2.19;\n\nMOUNT_2.21 {\nglobal:\n\tmnt_context_enable_fork;\n\tmnt_context_get_helper_status;\n\tmnt_context_get_syscall_errno;\n\tmnt_context_helper_executed;\n\tmnt_context_is_child;\n\tmnt_context_is_fork;\n\tmnt_context_is_parent;\n\tmnt_context_next_umount;\n\tmnt_context_reset_status;\n\tmnt_context_set_passwd_cb;\n\tmnt_context_syscall_called;\n\tmnt_context_wait_for_children;\n\tmnt_fs_is_netfs;\n\tmnt_fs_is_pseudofs;\n\tmnt_fs_is_swaparea;\n\tmnt_get_library_features;\n\tmnt_table_parse_dir;\n} MOUNT_2.20;\n\nMOUNT_2.22 {\nglobal:\n\tmnt_context_disable_swapmatch;\n\tmnt_context_get_options;\n\tmnt_context_is_loopdel;\n\tmnt_context_is_nocanonicalize;\n\tmnt_context_is_nohelpers;\n\tmnt_context_is_swapmatch;\n\tmnt_context_tab_applied;\n\tmnt_fs_get_priority;\n\tmnt_fs_get_size;\n\tmnt_fs_get_swaptype;\n\tmnt_fs_get_tid;\n\tmnt_fs_get_usedsize;\n\tmnt_fs_streq_srcpath;\n\tmnt_fs_streq_target;\n\tmnt_get_mountpoint;\n\tmnt_get_swaps_path;\n\tmnt_optstr_deduplicate_option;\n\tmnt_table_find_devno;\n\tmnt_table_parse_swaps;\n} MOUNT_2.21;\n\nMOUNT_2.23 {\nglobal:\n\tmnt_fs_get_optional_fields;\n\tmnt_fs_get_propagation;\n\tmnt_context_find_umount_fs;\n\tmnt_table_find_mountpoint;\n} MOUNT_2.22;\n\nMOUNT_2.24 {\nglobal:\n\tmnt_context_get_fstab_userdata;\n\tmnt_context_get_fs_userdata;\n\tmnt_context_get_mtab_userdata;\n\tmnt_fs_append_comment;\n\tmnt_fs_get_comment;\n\tmnt_fs_set_comment;\n\tmnt_ref_cache;\n\tmnt_ref_fs;\n\tmnt_ref_table;\n\tmnt_table_append_intro_comment;\n\tmnt_table_append_trailing_comment;\n\tmnt_table_enable_comments;\n\tmnt_table_first_fs;\n\tmnt_table_get_intro_comment;\n\tmnt_table_get_trailing_comment;\n\tmnt_table_get_userdata;\n\tmnt_table_is_empty;\n\tmnt_table_last_fs;\n\tmnt_table_replace_file;\n\tmnt_table_set_intro_comment;\n\tmnt_table_set_trailing_comment;\n\tmnt_table_set_userdata;\n\tmnt_table_with_comments;\n\tmnt_table_write_file;\n\tmnt_unref_cache;\n\tmnt_unref_fs;\n\tmnt_unref_table;\n} MOUNT_2.23;\n\nMOUNT_2.25 {\n\tmnt_cache_set_targets;\n\tmnt_resolve_target;\n\tmnt_table_uniq_fs;\n\tmnt_tag_is_valid;\n} MOUNT_2.24;\n\nMOUNT_2.26 {\n\tmnt_monitor_close_fd;\n\tmnt_monitor_enable_userspace;\n\tmnt_monitor_enable_kernel;\n\tmnt_monitor_event_cleanup;\n\tmnt_monitor_get_fd;\n\tmnt_monitor_next_change;\n\tmnt_monitor_wait;\n\tmnt_new_monitor;\n\tmnt_ref_monitor;\n\tmnt_unref_monitor;\n} MOUNT_2.25;\n\nMOUNT_2.28 {\n\tmnt_table_find_target_with_option;\n\tmnt_fs_set_priority;\n} MOUNT_2.26;\n\nMOUNT_2.30 {\n\tmnt_context_is_rwonly_mount;\n\tmnt_context_forced_rdonly;\n\tmnt_context_enable_rwonly_mount;\n\tmnt_context_get_excode;\n} MOUNT_2.28;\n\nMOUNT_2.33 {\n\tmnt_context_get_origin_ns;\n\tmnt_context_get_target_ns;\n\tmnt_context_set_target_ns;\n\tmnt_context_switch_ns;\n\tmnt_context_switch_origin_ns;\n\tmnt_context_switch_target_ns;\n} MOUNT_2.30;\n\nMOUNT_2.34 {\n\tmnt_context_next_remount;\n\tmnt_fs_get_table;\n\tmnt_guess_system_root;\n\tmnt_table_find_fs;\n\tmnt_table_insert_fs;\n\tmnt_table_move_fs;\n} MOUNT_2.33;\n\nMOUNT_2_35 {\n\tmnt_context_force_unrestricted;\n\tmnt_context_get_target_prefix;\n\tmnt_context_set_target_prefix;\n} MOUNT_2.34;\n\nMOUNT_2_37 {\n\tmnt_fs_get_vfs_options_all;\n\tmnt_table_over_fs;\n} MOUNT_2_35;\n\n\nMOUNT_2_38 {\n\tmnt_fs_is_regularfs;\n} MOUNT_2_37;\n", "/* SPDX-License-Identifier: LGPL-2.1-or-later */\n/*\n * mountP.h - private library header file\n *\n * This file is part of libmount from util-linux project.\n *\n * Copyright (C) 2008-2018 Karel Zak <kzak@redhat.com>\n *\n * libmount is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n */\n#ifndef _LIBMOUNT_PRIVATE_H\n#define _LIBMOUNT_PRIVATE_H\n\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/vfs.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdarg.h>\n\n#include \"c.h\"\n#include \"list.h\"\n#include \"debug.h\"\n#include \"libmount.h\"\n\n/*\n * Debug\n */\n#define MNT_DEBUG_HELP\t\t(1 << 0)\n#define MNT_DEBUG_INIT\t\t(1 << 1)\n#define MNT_DEBUG_CACHE\t\t(1 << 2)\n#define MNT_DEBUG_OPTIONS\t(1 << 3)\n#define MNT_DEBUG_LOCKS\t\t(1 << 4)\n#define MNT_DEBUG_TAB\t\t(1 << 5)\n#define MNT_DEBUG_FS\t\t(1 << 6)\n#define MNT_DEBUG_UPDATE\t(1 << 7)\n#define MNT_DEBUG_UTILS\t\t(1 << 8)\n#define MNT_DEBUG_CXT\t\t(1 << 9)\n#define MNT_DEBUG_DIFF\t\t(1 << 10)\n#define MNT_DEBUG_MONITOR\t(1 << 11)\n#define MNT_DEBUG_BTRFS\t\t(1 << 12)\n#define MNT_DEBUG_LOOP\t\t(1 << 13)\n#define MNT_DEBUG_VERITY\t(1 << 14)\n\n#define MNT_DEBUG_ALL\t\t0xFFFF\n\nUL_DEBUG_DECLARE_MASK(libmount);\n#define DBG(m, x)\t__UL_DBG(libmount, MNT_DEBUG_, m, x)\n#define ON_DBG(m, x)\t__UL_DBG_CALL(libmount, MNT_DEBUG_, m, x)\n#define DBG_FLUSH\t__UL_DBG_FLUSH(libmount, MNT_DEBUG_)\n\n#define UL_DEBUG_CURRENT_MASK\tUL_DEBUG_MASK(libmount)\n#include \"debugobj.h\"\n\n/*\n * NLS -- the library has to be independent on main program, so define\n * UL_TEXTDOMAIN_EXPLICIT before you include nls.h.\n *\n * Now we use util-linux.po (=PACKAGE), rather than maintain the texts\n * in the separate libmount.po file.\n */\n#define LIBMOUNT_TEXTDOMAIN\tPACKAGE\n#define UL_TEXTDOMAIN_EXPLICIT\tLIBMOUNT_TEXTDOMAIN\n#include \"nls.h\"\n\n\n/* extension for files in the directory */\n#define MNT_MNTTABDIR_EXT\t\".fstab\"\n\n/* library private paths */\n#define MNT_RUNTIME_TOPDIR\t\"/run\"\n/* private userspace mount table */\n#define MNT_PATH_UTAB\t\tMNT_RUNTIME_TOPDIR \"/mount/utab\"\n/* temporary mount target */\n#define MNT_PATH_TMPTGT\t\tMNT_RUNTIME_TOPDIR \"/mount/tmptgt\"\n\n#define MNT_UTAB_HEADER\t\"# libmount utab file\\n\"\n\n#ifdef TEST_PROGRAM\nstruct libmnt_test {\n\tconst char\t*name;\n\tint\t\t(*body)(struct libmnt_test *ts, int argc, char *argv[]);\n\tconst char\t*usage;\n};\n\n/* test.c */\nextern int mnt_run_test(struct libmnt_test *tests, int argc, char *argv[]);\n#endif\n\n/* utils.c */\nextern int mnt_valid_tagname(const char *tagname);\n\nextern const char *mnt_statfs_get_fstype(struct statfs *vfs);\nextern int is_file_empty(const char *name);\n\nextern int mnt_is_readonly(const char *path)\n\t\t\t__attribute__((nonnull));\n\nextern int mnt_parse_offset(const char *str, size_t len, uintmax_t *res);\n\nextern int mnt_chdir_to_parent(const char *target, char **filename);\n\nextern char *mnt_get_username(const uid_t uid);\nextern int mnt_get_uid(const char *username, uid_t *uid);\nextern int mnt_get_gid(const char *groupname, gid_t *gid);\nextern int mnt_in_group(gid_t gid);\n\nextern int mnt_open_uniq_filename(const char *filename, char **name);\n\nextern int mnt_has_regular_utab(const char **utab, int *writable);\nextern const char *mnt_get_utab_path(void);\n\nextern int mnt_get_filesystems(char ***filesystems, const char *pattern);\nextern void mnt_free_filesystems(char **filesystems);\n\nextern char *mnt_get_kernel_cmdline_option(const char *name);\nextern int mnt_stat_mountpoint(const char *target, struct stat *st);\nextern int mnt_lstat_mountpoint(const char *target, struct stat *st);\n\nextern int mnt_tmptgt_unshare(int *old_ns_fd);\nextern int mnt_tmptgt_cleanup(int old_ns_fd);\n\n/* tab.c */\nextern int is_mountinfo(struct libmnt_table *tb);\nextern int mnt_table_set_parser_fltrcb(\tstruct libmnt_table *tb,\n\t\t\t\t\tint (*cb)(struct libmnt_fs *, void *),\n\t\t\t\t\tvoid *data);\n\nextern int __mnt_table_parse_mtab(struct libmnt_table *tb,\n\t\t\t\t\tconst char *filename,\n\t\t\t\t\tstruct libmnt_table *u_tb);\n\nextern struct libmnt_fs *mnt_table_get_fs_root(struct libmnt_table *tb,\n\t\t\t\t\tstruct libmnt_fs *fs,\n\t\t\t\t\tunsigned long mountflags,\n\t\t\t\t\tchar **fsroot);\n\nextern int __mnt_table_is_fs_mounted(\tstruct libmnt_table *tb,\n\t\t\t\t\tstruct libmnt_fs *fstab_fs,\n\t\t\t\t\tconst char *tgt_prefix);\n\n/*\n * Generic iterator\n */\nstruct libmnt_iter {\n        struct list_head        *p;\t\t/* current position */\n        struct list_head        *head;\t\t/* start position */\n\tint\t\t\tdirection;\t/* MNT_ITER_{FOR,BACK}WARD */\n};\n\n#define IS_ITER_FORWARD(_i)\t((_i)->direction == MNT_ITER_FORWARD)\n#define IS_ITER_BACKWARD(_i)\t((_i)->direction == MNT_ITER_BACKWARD)\n\n#define MNT_ITER_INIT(itr, list) \\\n\tdo { \\\n\t\t(itr)->p = IS_ITER_FORWARD(itr) ? \\\n\t\t\t\t(list)->next : (list)->prev; \\\n\t\t(itr)->head = (list); \\\n\t} while(0)\n\n#define MNT_ITER_ITERATE(itr, res, restype, member) \\\n\tdo { \\\n\t\tres = list_entry((itr)->p, restype, member); \\\n\t\t(itr)->p = IS_ITER_FORWARD(itr) ? \\\n\t\t\t\t(itr)->p->next : (itr)->p->prev; \\\n\t} while(0)\n\n\n/*\n * This struct represents one entry in a mtab/fstab/mountinfo file.\n * (note that fstab[1] means the first column from fstab, and so on...)\n */\nstruct libmnt_fs {\n\tstruct list_head ents;\n\tstruct libmnt_table *tab;\n\n\tint\t\trefcount;\t/* reference counter */\n\tint\t\tid;\t\t/* mountinfo[1]: ID */\n\tint\t\tparent;\t\t/* mountinfo[2]: parent */\n\tdev_t\t\tdevno;\t\t/* mountinfo[3]: st_dev */\n\n\tchar\t\t*bindsrc;\t/* utab, full path from fstab[1] for bind mounts */\n\n\tchar\t\t*source;\t/* fstab[1], mountinfo[10], swaps[1]:\n                                         * source dev, file, dir or TAG */\n\tchar\t\t*tagname;\t/* fstab[1]: tag name - \"LABEL\", \"UUID\", ..*/\n\tchar\t\t*tagval;\t/*           tag value */\n\n\tchar\t\t*root;\t\t/* mountinfo[4]: root of the mount within the FS */\n\tchar\t\t*target;\t/* mountinfo[5], fstab[2]: mountpoint */\n\tchar\t\t*fstype;\t/* mountinfo[9], fstab[3]: filesystem type */\n\n\tchar\t\t*optstr;\t/* fstab[4], merged options */\n\tchar\t\t*vfs_optstr;\t/* mountinfo[6]: fs-independent (VFS) options */\n\tchar\t\t*opt_fields;\t/* mountinfo[7]: optional fields */\n\tchar\t\t*fs_optstr;\t/* mountinfo[11]: fs-dependent options */\n\tchar\t\t*user_optstr;\t/* userspace mount options */\n\tchar\t\t*attrs;\t\t/* mount attributes */\n\n\tint\t\tfreq;\t\t/* fstab[5]: dump frequency in days */\n\tint\t\tpassno;\t\t/* fstab[6]: pass number on parallel fsck */\n\n\t/* /proc/swaps */\n\tchar\t\t*swaptype;\t/* swaps[2]: device type (partition, file, ...) */\n\toff_t\t\tsize;\t\t/* swaps[3]: swaparea size */\n\toff_t\t\tusedsize;\t/* swaps[4]: used size */\n\tint\t\tpriority;\t/* swaps[5]: swap priority */\n\n\tint\t\tflags;\t\t/* MNT_FS_* flags */\n\tpid_t\t\ttid;\t\t/* /proc/<tid>/mountinfo otherwise zero */\n\n\tchar\t\t*comment;\t/* fstab comment */\n\n\tvoid\t\t*userdata;\t/* library independent data */\n};\n\n/*\n * fs flags\n */\n#define MNT_FS_PSEUDO\t(1 << 1) /* pseudo filesystem */\n#define MNT_FS_NET\t(1 << 2) /* network filesystem */\n#define MNT_FS_SWAP\t(1 << 3) /* swap device */\n#define MNT_FS_KERNEL\t(1 << 4) /* data from /proc/{mounts,self/mountinfo} */\n#define MNT_FS_MERGED\t(1 << 5) /* already merged data from /run/mount/utab */\n\n/*\n * mtab/fstab/mountinfo file\n */\nstruct libmnt_table {\n\tint\t\tfmt;\t\t/* MNT_FMT_* file format */\n\tint\t\tnents;\t\t/* number of entries */\n\tint\t\trefcount;\t/* reference counter */\n\tint\t\tcomms;\t\t/* enable/disable comment parsing */\n\tchar\t\t*comm_intro;\t/* First comment in file */\n\tchar\t\t*comm_tail;\t/* Last comment in file */\n\n\tstruct libmnt_cache *cache;\t\t/* canonicalized paths/tags cache */\n\n        int\t\t(*errcb)(struct libmnt_table *tb,\n\t\t\t\t const char *filename, int line);\n\n\tint\t\t(*fltrcb)(struct libmnt_fs *fs, void *data);\n\tvoid\t\t*fltrcb_data;\n\n\n\tstruct list_head\tents;\t/* list of entries (libmnt_fs) */\n\tvoid\t\t*userdata;\n};\n\nextern struct libmnt_table *__mnt_new_table_from_file(const char *filename, int fmt, int empty_for_enoent);\n\n/*\n * Tab file format\n */\nenum {\n\tMNT_FMT_GUESS,\n\tMNT_FMT_FSTAB,\t\t\t/* /etc/{fs,m}tab */\n\tMNT_FMT_MTAB = MNT_FMT_FSTAB,\t/* alias */\n\tMNT_FMT_MOUNTINFO,\t\t/* /proc/#/mountinfo */\n\tMNT_FMT_UTAB,\t\t\t/* /run/mount/utab */\n\tMNT_FMT_SWAPS\t\t\t/* /proc/swaps */\n};\n\n/*\n * Additional mounts\n */\nstruct libmnt_addmount {\n\tunsigned long mountflags;\n\n\tstruct list_head\tmounts;\n};\n\nstruct libmnt_ns {\n\tint fd;\t\t\t\t/* file descriptor of namespace, -1 when inactive */\n\tstruct libmnt_cache *cache;\t/* paths cache associated with NS */\n};\n\n/*\n * Mount context -- high-level API\n */\nstruct libmnt_context\n{\n\tint\taction;\t\t/* MNT_ACT_{MOUNT,UMOUNT} */\n\tint\trestricted;\t/* root or not? */\n\n\tchar\t*fstype_pattern;\t/* for mnt_match_fstype() */\n\tchar\t*optstr_pattern;\t/* for mnt_match_options() */\n\n\tchar\t*subdir;\t\t/* X-mount.subdir= */\n\n\tstruct libmnt_fs *fs;\t\t/* filesystem description (type, mountpoint, device, ...) */\n\tstruct libmnt_fs *fs_template;\t/* used for @fs on mnt_reset_context() */\n\n\tstruct libmnt_table *fstab;\t/* fstab (or mtab for some remounts) entries */\n\tstruct libmnt_table *mtab;\t/* mtab entries */\n\tstruct libmnt_table *utab;\t/* rarely used by umount only */\n\n\tint\t(*table_errcb)(struct libmnt_table *tb,\t/* callback for libmnt_table structs */\n\t\t\t const char *filename, int line);\n\n\tint\t(*table_fltrcb)(struct libmnt_fs *fs, void *data);\t/* callback for libmnt_table structs */\n\tvoid\t*table_fltrcb_data;\n\n\tchar\t*(*pwd_get_cb)(struct libmnt_context *);\t\t/* get encryption password */\n\tvoid\t(*pwd_release_cb)(struct libmnt_context *, char *);\t/* release password */\n\n\tint\toptsmode;\t/* fstab optstr mode MNT_OPTSMODE_{AUTO,FORCE,IGNORE} */\n\tint\tloopdev_fd;\t/* open loopdev */\n\n\tunsigned long\tmountflags;\t/* final mount(2) flags */\n\tconst void\t*mountdata;\t/* final mount(2) data, string or binary data */\n\n\tunsigned long\tuser_mountflags;\t/* MNT_MS_* (loop=, user=, ...) */\n\n\tstruct list_head\taddmounts;\t/* additional mounts */\n\n\tstruct libmnt_cache\t*cache;\t/* paths cache */\n\tstruct libmnt_lock\t*lock;\t/* mtab lock */\n\tstruct libmnt_update\t*update;/* mtab/utab update */\n\n\tconst char\t*mtab_path; /* path to mtab */\n\tint\t\tmtab_writable; /* is mtab writable */\n\n\tconst char\t*utab_path; /* path to utab */\n\tint\t\tutab_writable; /* is utab writable */\n\n\tchar\t\t*tgt_prefix;\t/* path used for all targets */\n\n\tint\tflags;\t\t/* private context flags */\n\n\tchar\t*helper;\t/* name of the used /sbin/[u]mount.<type> helper */\n\tint\thelper_status;\t/* helper wait(2) status */\n\tint\thelper_exec_status; /* 1: not called yet, 0: success, <0: -errno */\n\n\tchar\t*orig_user;\t/* original (non-fixed) user= option */\n\n\tpid_t\t*children;\t/* \"mount -a --fork\" PIDs */\n\tint\tnchildren;\t/* number of children */\n\tpid_t\tpid;\t\t/* 0=parent; PID=child */\n\n\n\tint\tsyscall_status;\t/* 1: not called yet, 0: success, <0: -errno */\n\n\tstruct libmnt_ns\tns_orig;\t/* original namespace */\n\tstruct libmnt_ns\tns_tgt;\t\t/* target namespace */\n\tstruct libmnt_ns\t*ns_cur;\t/* pointer to current namespace */\n\n\tunsigned int\tenabled_textdomain : 1;\t\t/* bindtextdomain() called */\n};\n\n/* flags */\n#define MNT_FL_NOMTAB\t\t(1 << 1)\n#define MNT_FL_FAKE\t\t(1 << 2)\n#define MNT_FL_SLOPPY\t\t(1 << 3)\n#define MNT_FL_VERBOSE\t\t(1 << 4)\n#define MNT_FL_NOHELPERS\t(1 << 5)\n#define MNT_FL_LOOPDEL\t\t(1 << 6)\n#define MNT_FL_LAZY\t\t(1 << 7)\n#define MNT_FL_FORCE\t\t(1 << 8)\n#define MNT_FL_NOCANONICALIZE\t(1 << 9)\n#define MNT_FL_RDONLY_UMOUNT\t(1 << 11)\t/* remount,ro after EBUSY umount(2) */\n#define MNT_FL_FORK\t\t(1 << 12)\n#define MNT_FL_NOSWAPMATCH\t(1 << 13)\n#define MNT_FL_RWONLY_MOUNT\t(1 << 14)\t/* explicit mount -w; never try read-only  */\n\n#define MNT_FL_MOUNTDATA\t(1 << 20)\n#define MNT_FL_TAB_APPLIED\t(1 << 21)\t/* mtab/fstab merged to cxt->fs */\n#define MNT_FL_MOUNTFLAGS_MERGED (1 << 22)\t/* MS_* flags was read from optstr */\n#define MNT_FL_SAVED_USER\t(1 << 23)\n#define MNT_FL_PREPARED\t\t(1 << 24)\n#define MNT_FL_HELPER\t\t(1 << 25)\t/* [u]mount.<type> */\n#define MNT_FL_LOOPDEV_READY\t(1 << 26)\t/* /dev/loop<N> initialized by the library */\n#define MNT_FL_MOUNTOPTS_FIXED  (1 << 27)\n#define MNT_FL_TABPATHS_CHECKED\t(1 << 28)\n#define MNT_FL_FORCED_RDONLY\t(1 << 29)\t/* mounted read-only on write-protected device */\n#define MNT_FL_VERITYDEV_READY\t(1 << 30)\t/* /dev/mapper/<FOO> initialized by the library */\n\n/* default flags */\n#define MNT_FL_DEFAULT\t\t0\n\n/* Flags usable with MS_BIND|MS_REMOUNT */\n#define MNT_BIND_SETTABLE\t(MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_NOATIME|MS_NODIRATIME|MS_RELATIME|MS_RDONLY)\n\n/* lock.c */\nextern int mnt_lock_use_simplelock(struct libmnt_lock *ml, int enable);\n\n/* optmap.c */\nextern const struct libmnt_optmap *mnt_optmap_get_entry(\n\t\t\t     struct libmnt_optmap const **maps,\n                             int nmaps,\n\t\t\t     const char *name,\n                             size_t namelen,\n\t\t\t     const struct libmnt_optmap **mapent);\n\n/* optstr.c */\nextern int mnt_optstr_remove_option_at(char **optstr, char *begin, char *end);\nextern int mnt_optstr_fix_gid(char **optstr, char *value, size_t valsz, char **next);\nextern int mnt_optstr_fix_uid(char **optstr, char *value, size_t valsz, char **next);\nextern int mnt_optstr_fix_secontext(char **optstr, char *value, size_t valsz, char **next);\nextern int mnt_optstr_fix_user(char **optstr);\n\n/* fs.c */\nextern struct libmnt_fs *mnt_copy_mtab_fs(const struct libmnt_fs *fs)\n\t\t\t__attribute__((nonnull));\nextern int __mnt_fs_set_source_ptr(struct libmnt_fs *fs, char *source)\n\t\t\t__attribute__((nonnull(1)));\nextern int __mnt_fs_set_fstype_ptr(struct libmnt_fs *fs, char *fstype)\n\t\t\t__attribute__((nonnull(1)));\n\n/* context.c */\nextern struct libmnt_context *mnt_copy_context(struct libmnt_context *o);\nextern int mnt_context_mtab_writable(struct libmnt_context *cxt);\nextern int mnt_context_utab_writable(struct libmnt_context *cxt);\nextern const char *mnt_context_get_writable_tabpath(struct libmnt_context *cxt);\n\nextern int mnt_context_get_mtab_for_target(struct libmnt_context *cxt,\n\t\t\t\t    struct libmnt_table **mtab, const char *tgt);\n\nextern int mnt_context_prepare_srcpath(struct libmnt_context *cxt);\nextern int mnt_context_prepare_target(struct libmnt_context *cxt);\nextern int mnt_context_guess_srcpath_fstype(struct libmnt_context *cxt, char **type);\nextern int mnt_context_guess_fstype(struct libmnt_context *cxt);\nextern int mnt_context_prepare_helper(struct libmnt_context *cxt,\n\t\t\t\t      const char *name, const char *type);\nextern int mnt_context_prepare_update(struct libmnt_context *cxt);\nextern int mnt_context_merge_mflags(struct libmnt_context *cxt);\nextern int mnt_context_update_tabs(struct libmnt_context *cxt);\n\nextern int mnt_context_umount_setopt(struct libmnt_context *cxt, int c, char *arg);\nextern int mnt_context_mount_setopt(struct libmnt_context *cxt, int c, char *arg);\n\nextern int mnt_context_is_loopdev(struct libmnt_context *cxt)\n\t\t\t__attribute__((nonnull));\n\nextern int mnt_context_propagation_only(struct libmnt_context *cxt)\n\t\t\t__attribute__((nonnull));\n\nextern struct libmnt_addmount *mnt_new_addmount(void);\nextern void mnt_free_addmount(struct libmnt_addmount *ad);\n\nextern int mnt_context_setup_loopdev(struct libmnt_context *cxt);\nextern int mnt_context_delete_loopdev(struct libmnt_context *cxt);\nextern int mnt_context_clear_loopdev(struct libmnt_context *cxt);\n\nextern int mnt_fork_context(struct libmnt_context *cxt);\n\nextern int mnt_context_set_tabfilter(struct libmnt_context *cxt,\n\t\t\t\t     int (*fltr)(struct libmnt_fs *, void *),\n\t\t\t\t     void *data);\n\nextern int mnt_context_get_generic_excode(int rc, char *buf, size_t bufsz, const char *fmt, ...)\n\t\t\t\t__attribute__ ((__format__ (__printf__, 4, 5)));\nextern int mnt_context_get_mount_excode(struct libmnt_context *cxt, int mntrc, char *buf, size_t bufsz);\nextern int mnt_context_get_umount_excode(struct libmnt_context *cxt, int mntrc, char *buf, size_t bufsz);\n\nextern int mnt_context_has_template(struct libmnt_context *cxt);\nextern int mnt_context_apply_template(struct libmnt_context *cxt);\nextern int mnt_context_save_template(struct libmnt_context *cxt);\n\nextern int mnt_context_apply_fs(struct libmnt_context *cxt, struct libmnt_fs *fs);\n\nextern int mnt_context_is_veritydev(struct libmnt_context *cxt)\n\t\t\t__attribute__((nonnull));\nextern int mnt_context_setup_veritydev(struct libmnt_context *cxt);\nextern int mnt_context_deferred_delete_veritydev(struct libmnt_context *cxt);\n\n/* tab_update.c */\nextern int mnt_update_set_filename(struct libmnt_update *upd,\n\t\t\t\t   const char *filename, int userspace_only);\nextern int mnt_update_already_done(struct libmnt_update *upd,\n\t\t\t\t   struct libmnt_lock *lc);\n\n#if __linux__\n/* btrfs.c */\nextern uint64_t btrfs_get_default_subvol_id(const char *path);\n#endif\n\n#endif /* _LIBMOUNT_PRIVATE_H */\n", "/* SPDX-License-Identifier: LGPL-2.1-or-later */\n/*\n * This file is part of libmount from util-linux project.\n *\n * Copyright (C) 2009-2018 Karel Zak <kzak@redhat.com>\n *\n * libmount is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n */\n#ifdef HAVE_SCANDIRAT\n#ifndef __USE_GNU\n#define __USE_GNU\n#endif\t/* !__USE_GNU */\n#endif\t/* HAVE_SCANDIRAT */\n\n#include <ctype.h>\n#include <limits.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n\n#include \"fileutils.h\"\n#include \"mangle.h\"\n#include \"mountP.h\"\n#include \"pathnames.h\"\n#include \"strutils.h\"\n\nstruct libmnt_parser {\n\tFILE\t*f;\t\t/* fstab, mtab, swaps or mountinfo ... */\n\tconst char *filename;\t/* file name or NULL */\n\tchar\t*buf;\t\t/* buffer (the current line content) */\n\tsize_t\tbufsiz;\t\t/* size of the buffer */\n\tsize_t\tline;\t\t/* current line */\n};\n\nstatic void parser_cleanup(struct libmnt_parser *pa)\n{\n\tif (!pa)\n\t\treturn;\n\tfree(pa->buf);\n\tmemset(pa, 0, sizeof(*pa));\n}\n\nstatic const char *next_s32(const char *s, int *num, int *rc)\n{\n\tchar *end = NULL;\n\n\tif (!s || !*s)\n\t\treturn s;\n\n\terrno = 0;\n\t*rc = -EINVAL;\n\t*num = strtol(s, &end, 10);\n\tif (end == NULL || s == end)\n\t       return s;\n\tif (errno == 0 && (*end == ' ' || *end == '\\t' || *end == '\\0'))\n\t\t*rc = 0;\n\treturn end;\n}\n\nstatic const char *next_u64(const char *s, uint64_t *num, int *rc)\n{\n\tchar *end = NULL;\n\n\tif (!s || !*s)\n\t\treturn s;\n\n\terrno = 0;\n\t*rc = -EINVAL;\n\t*num = (uint64_t) strtoumax(s, &end, 10);\n\tif (end == NULL || s == end)\n\t       return s;\n\tif (errno == 0 && (*end == ' ' || *end == '\\t' || *end == '\\0'))\n\t\t*rc = 0;\n\treturn end;\n}\n\nstatic inline const char *skip_separator(const char *p)\n{\n\twhile (p && (*p == ' ' || *p == '\\t'))\n\t\t++p;\n\treturn p;\n}\n\nstatic inline const char *skip_nonspearator(const char *p)\n{\n\twhile (p && *p && !(*p == ' ' || *p == '\\t'))\n\t\tp++;\n\treturn p;\n}\n\n/*\n * Parses one line from {fs,m}tab\n */\nstatic int mnt_parse_table_line(struct libmnt_fs *fs, const char *s)\n{\n\tint rc = 0;\n\tchar *p = NULL;\n\n\tfs->passno = fs->freq = 0;\n\n\t/* (1) source */\n\tp = unmangle(s, &s);\n\tif (!p || (rc = __mnt_fs_set_source_ptr(fs, p))) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [source]\"));\n\t\tfree(p);\n\t\tgoto fail;\n\t}\n\n\ts = skip_separator(s);\n\n\t/* (2) target */\n\tfs->target = unmangle(s, &s);\n\tif (!fs->target) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [target]\"));\n\t\tgoto fail;\n\t}\n\n\ts = skip_separator(s);\n\n\t/* (3) FS type */\n\tp = unmangle(s, &s);\n\tif (!p || (rc = __mnt_fs_set_fstype_ptr(fs, p))) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [fstype]\"));\n\t\tfree(p);\n\t\tgoto fail;\n\t}\n\n\ts = skip_separator(s);\n\n\t/* (4) options (optional) */\n\tp = unmangle(s, &s);\n\tif (p && (rc = mnt_fs_set_options(fs, p))) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [options]\"));\n\t\tfree(p);\n\t\tgoto fail;\n\t}\n\tif (!p)\n\t\tgoto done;\n\tfree(p);\n\n\ts = skip_separator(s);\n\tif (!s || !*s)\n\t\tgoto done;\n\n\t/* (5) freq (optional) */\n\ts = next_s32(s, &fs->freq, &rc);\n\tif (s && *s && rc) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [freq]\"));\n\t\tgoto fail;\n\t}\n\n\ts = skip_separator(s);\n\tif (!s || !*s)\n\t\tgoto done;\n\n\t/* (6) passno (optional) */\n\ts = next_s32(s, &fs->passno, &rc);\n\tif (s && *s && rc) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [passno]\"));\n\t\tgoto fail;\n\t}\n\ndone:\n\treturn 0;\nfail:\n\tif (rc == 0)\n\t\trc = -EINVAL;\n\tDBG(TAB, ul_debug(\"tab parse error on: '%s' [rc=%d]\", s, rc));\n\treturn rc;\n}\n\n\n/*\n * Parses one line from a mountinfo file\n */\nstatic int mnt_parse_mountinfo_line(struct libmnt_fs *fs, const char *s)\n{\n\tint rc = 0;\n\tunsigned int maj, min;\n\tchar *p;\n\n\tfs->flags |= MNT_FS_KERNEL;\n\n\t/* (1) id */\n\ts = next_s32(s, &fs->id, &rc);\n\tif (!s || !*s || rc) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [id]\"));\n\t\tgoto fail;\n\t}\n\n\ts = skip_separator(s);\n\n\t/* (2) parent */\n\ts = next_s32(s, &fs->parent, &rc);\n\tif (!s || !*s || rc) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [parent]\"));\n\t\tgoto fail;\n\t}\n\n\ts = skip_separator(s);\n\n\t/* (3) maj:min */\n\tif (sscanf(s, \"%u:%u\", &maj, &min) != 2) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [maj:min]\"));\n\t\tgoto fail;\n\t}\n\tfs->devno = makedev(maj, min);\n\ts = skip_nonspearator(s);\n\ts = skip_separator(s);\n\n\t/* (4) mountroot */\n\tfs->root = unmangle(s, &s);\n\tif (!fs->root) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [mountroot]\"));\n\t\tgoto fail;\n\t}\n\n\ts = skip_separator(s);\n\n\t/* (5) target */\n\tfs->target = unmangle(s, &s);\n\tif (!fs->target) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [target]\"));\n\t\tgoto fail;\n\t}\n\n\ts = skip_separator(s);\n\n\t/* (6) vfs options (fs-independent) */\n\tfs->vfs_optstr = unmangle(s, &s);\n\tif (!fs->vfs_optstr) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [VFS options]\"));\n\t\tgoto fail;\n\t}\n\n\t/* (7) optional fields, terminated by \" - \" */\n\tp = strstr(s, \" - \");\n\tif (!p) {\n\t\tDBG(TAB, ul_debug(\"mountinfo parse error: separator not found\"));\n\t\treturn -EINVAL;\n\t}\n\tif (p > s + 1)\n\t\tfs->opt_fields = strndup(s + 1, p - s - 1);\n\n\ts = skip_separator(p + 3);\n\n\t/* (8) FS type */\n\tp = unmangle(s, &s);\n\tif (!p || (rc = __mnt_fs_set_fstype_ptr(fs, p))) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [fstype]\"));\n\t\tfree(p);\n\t\tgoto fail;\n\t}\n\n\t/* (9) source -- maybe empty string */\n\tif (!s || !*s) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [source]\"));\n\t\tgoto fail;\n\t} else if (*s == ' ' && *(s+1) == ' ') {\n\t\tif ((rc = mnt_fs_set_source(fs, \"\"))) {\n\t\t\tDBG(TAB, ul_debug(\"tab parse error: [empty source]\"));\n\t\t\tgoto fail;\n\t\t}\n\t} else {\n\t\ts = skip_separator(s);\n\t\tp = unmangle(s, &s);\n\t\tif (!p || (rc = __mnt_fs_set_source_ptr(fs, p))) {\n\t\t\tDBG(TAB, ul_debug(\"tab parse error: [regular source]\"));\n\t\t\tfree(p);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\ts = skip_separator(s);\n\n\t/* (10) fs options (fs specific) */\n\tfs->fs_optstr = unmangle(s, &s);\n\tif (!fs->fs_optstr) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [FS options]\"));\n\t\tgoto fail;\n\t}\n\n\t/* merge VFS and FS options to one string */\n\tfs->optstr = mnt_fs_strdup_options(fs);\n\tif (!fs->optstr) {\n\t\trc = -ENOMEM;\n\t\tDBG(TAB, ul_debug(\"tab parse error: [merge VFS and FS options]\"));\n\t\tgoto fail;\n\t}\n\n\treturn 0;\nfail:\n\tif (rc == 0)\n\t\trc = -EINVAL;\n\tDBG(TAB, ul_debug(\"tab parse error on: '%s' [rc=%d]\", s, rc));\n\treturn rc;\n}\n\n/*\n * Parses one line from utab file\n */\nstatic int mnt_parse_utab_line(struct libmnt_fs *fs, const char *s)\n{\n\tconst char *p = s;\n\n\tassert(fs);\n\tassert(s);\n\tassert(!fs->source);\n\tassert(!fs->target);\n\n\twhile (p && *p) {\n\t\tconst char *end = NULL;\n\n\t\twhile (*p == ' ') p++;\n\t\tif (!*p)\n\t\t\tbreak;\n\n\t\tif (!fs->source && !strncmp(p, \"SRC=\", 4)) {\n\t\t\tchar *v = unmangle(p + 4, &end);\n\t\t\tif (!v)\n\t\t\t\tgoto enomem;\n\t\t\tif (__mnt_fs_set_source_ptr(fs, v))\n\t\t\t\tfree(v);\n\n\t\t} else if (!fs->target && !strncmp(p, \"TARGET=\", 7)) {\n\t\t\tfs->target = unmangle(p + 7, &end);\n\t\t\tif (!fs->target)\n\t\t\t\tgoto enomem;\n\n\t\t} else if (!fs->root && !strncmp(p, \"ROOT=\", 5)) {\n\t\t\tfs->root = unmangle(p + 5, &end);\n\t\t\tif (!fs->root)\n\t\t\t\tgoto enomem;\n\n\t\t} else if (!fs->bindsrc && !strncmp(p, \"BINDSRC=\", 8)) {\n\t\t\tfs->bindsrc = unmangle(p + 8, &end);\n\t\t\tif (!fs->bindsrc)\n\t\t\t\tgoto enomem;\n\n\t\t} else if (!fs->user_optstr && !strncmp(p, \"OPTS=\", 5)) {\n\t\t\tfs->user_optstr = unmangle(p + 5, &end);\n\t\t\tif (!fs->user_optstr)\n\t\t\t\tgoto enomem;\n\n\t\t} else if (!fs->attrs && !strncmp(p, \"ATTRS=\", 6)) {\n\t\t\tfs->attrs = unmangle(p + 6, &end);\n\t\t\tif (!fs->attrs)\n\t\t\t\tgoto enomem;\n\n\t\t} else {\n\t\t\t/* unknown variable */\n\t\t\twhile (*p && *p != ' ') p++;\n\t\t}\n\t\tif (end)\n\t\t\tp = end;\n\t}\n\n\treturn 0;\nenomem:\n\tDBG(TAB, ul_debug(\"utab parse error: ENOMEM\"));\n\treturn -ENOMEM;\n}\n\n/*\n * Parses one line from /proc/swaps\n */\nstatic int mnt_parse_swaps_line(struct libmnt_fs *fs, const char *s)\n{\n\tuint64_t num;\n\tint rc = 0;\n\tchar *p;\n\n\t/* (1) source */\n\tp = unmangle(s, &s);\n\tif (p) {\n\t\tchar *x = (char *) endswith(p, PATH_DELETED_SUFFIX);\n\t\tif (x && *x)\n\t\t\t*x = '\\0';\n\t}\n\tif (!p || (rc = __mnt_fs_set_source_ptr(fs, p))) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [source]\"));\n\t\tfree(p);\n\t\tgoto fail;\n\t}\n\n\ts = skip_separator(s);\n\n\t/* (2) type */\n\tfs->swaptype = unmangle(s, &s);\n\tif (!fs->swaptype) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [swaptype]\"));\n\t\tgoto fail;\n\t}\n\n\ts = skip_separator(s);\n\n\t/* (3) size */\n\ts = next_u64(s, &num, &rc);\n\tif (!s || !*s || rc) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [size]\"));\n\t\tgoto fail;\n\t}\n\tfs->size = num;\n\n\ts = skip_separator(s);\n\n\t/* (4) size */\n\ts = next_u64(s, &num, &rc);\n\tif (!s || !*s || rc) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [used size]\"));\n\t\tgoto fail;\n\t}\n\tfs->usedsize = num;\n\n\ts = skip_separator(s);\n\n\t/* (5) priority */\n\ts = next_s32(s, &fs->priority, &rc);\n\tif (rc) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [priority]\"));\n\t\tgoto fail;\n\t}\n\n\tmnt_fs_set_fstype(fs, \"swap\");\n\treturn 0;\nfail:\n\tif (rc == 0)\n\t\trc = -EINVAL;\n\tDBG(TAB, ul_debug(\"tab parse error on: '%s' [rc=%d]\", s, rc));\n\treturn rc;\n}\n\n\n/*\n * Returns {m,fs}tab or mountinfo file format (MNT_FMT_*)\n *\n * Note that we aren't trying to guess the utab file format, because this file\n * always has to be parsed by private libmount routines with an explicitly defined\n * format.\n *\n * mountinfo: \"<number> <number> ... \"\n */\nstatic int guess_table_format(const char *line)\n{\n\tunsigned int a, b;\n\n\tDBG(TAB, ul_debug(\"trying to guess table type\"));\n\n\tif (sscanf(line, \"%u %u\", &a, &b) == 2)\n\t\treturn MNT_FMT_MOUNTINFO;\n\n\tif (strncmp(line, \"Filename\\t\", 9) == 0)\n\t\treturn MNT_FMT_SWAPS;\n\n\treturn MNT_FMT_FSTAB;\t\t/* fstab, mtab or /proc/mounts */\n}\n\nstatic int is_comment_line(const char *line)\n{\n\tconst char *p = skip_blank(line);\n\n\tif (p && (*p == '#' || *p == '\\n'))\n\t\treturn 1;\n\treturn 0;\n}\n\n/* returns 1 if the last line in the @str is blank */\nstatic int is_terminated_by_blank(const char *str)\n{\n\tsize_t sz = str ? strlen(str) : 0;\n\tconst char *p = sz ? str + (sz - 1) : NULL;\n\n\tif (!sz || !p || *p != '\\n')\n\t\treturn 0;\t\t/* empty or not terminated by '\\n' */\n\tif (p == str)\n\t\treturn 1;\t\t/* only '\\n' */\n\tp--;\n\twhile (p > str && (*p == ' ' || *p == '\\t'))\n\t\tp--;\n\treturn *p == '\\n' ? 1 : 0;\n}\n\n/*\n * Reads the next line from the file.\n *\n * Returns 0 if the line is a comment\n *         1 if the line is not a comment\n *        <0 on error\n */\nstatic int next_comment_line(struct libmnt_parser *pa, char **last)\n{\n\tif (getline(&pa->buf, &pa->bufsiz, pa->f) < 0)\n\t\treturn feof(pa->f) ? 1 : -errno;\n\n\tpa->line++;\n\t*last = strchr(pa->buf, '\\n');\n\n\treturn is_comment_line(pa->buf) ? 0 : 1;\n}\n\nstatic int append_comment(struct libmnt_table *tb,\n\t\t\t  struct libmnt_fs *fs,\n\t\t\t  const char *comm,\n\t\t\t  int eof)\n{\n\tint rc, intro = mnt_table_get_nents(tb) == 0;\n\n\tif (intro && is_terminated_by_blank(mnt_table_get_intro_comment(tb)))\n\t\tintro = 0;\n\n\tDBG(TAB, ul_debugobj(tb, \"appending %s comment\",\n\t\t\tintro ? \"intro\" :\n\t\t\teof ? \"trailing\" : \"fs\"));\n\tif (intro)\n\t\trc = mnt_table_append_intro_comment(tb, comm);\n\telse if (eof) {\n\t\trc = mnt_table_set_trailing_comment(tb,\n\t\t\t\tmnt_fs_get_comment(fs));\n\t\tif (!rc)\n\t\t\trc = mnt_table_append_trailing_comment(tb, comm);\n\t\tif (!rc)\n\t\t\trc = mnt_fs_set_comment(fs, NULL);\n\t} else\n\t\trc = mnt_fs_append_comment(fs, comm);\n\treturn rc;\n}\n\n/*\n * Read and parse the next line from {fs,m}tab or mountinfo\n */\nstatic int mnt_table_parse_next(struct libmnt_parser *pa,\n\t\t\t\tstruct libmnt_table *tb,\n\t\t\t\tstruct libmnt_fs *fs)\n{\n\tchar *s;\n\tint rc;\n\n\tassert(tb);\n\tassert(pa);\n\tassert(fs);\n\n\t/* read the next non-blank non-comment line */\nnext_line:\n\tdo {\n\t\tif (getline(&pa->buf, &pa->bufsiz, pa->f) < 0)\n\t\t\treturn -EINVAL;\n\t\tpa->line++;\n\t\ts = strchr(pa->buf, '\\n');\n\t\tif (!s) {\n\t\t\tDBG(TAB, ul_debugobj(tb, \"%s:%zu: no final newline\",\n\t\t\t\t\t\tpa->filename, pa->line));\n\n\t\t\t/* Missing final newline?  Otherwise an extremely */\n\t\t\t/* long line - assume file was corrupted */\n\t\t\tif (feof(pa->f))\n\t\t\t\ts = memchr(pa->buf, '\\0', pa->bufsiz);\n\n\t\t/* comments parser */\n\t\t} else if (tb->comms\n\t\t    && (tb->fmt == MNT_FMT_GUESS || tb->fmt == MNT_FMT_FSTAB)\n\t\t    && is_comment_line(pa->buf)) {\n\t\t\tdo {\n\t\t\t\trc = append_comment(tb, fs, pa->buf, feof(pa->f));\n\t\t\t\tif (!rc)\n\t\t\t\t\trc = next_comment_line(pa, &s);\n\t\t\t} while (rc == 0);\n\n\t\t\tif (rc == 1 && feof(pa->f))\n\t\t\t\trc = append_comment(tb, fs, NULL, 1);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\n\t\t}\n\n\t\tif (!s)\n\t\t\tgoto err;\n\t\t*s = '\\0';\n\t\tif (s > pa->buf && *(s - 1)  == '\\r')\n\t\t\t*(--s) = '\\0';\n\t\ts = (char *) skip_blank(pa->buf);\n\t} while (*s == '\\0' || *s == '#');\n\n\tif (tb->fmt == MNT_FMT_GUESS) {\n\t\ttb->fmt = guess_table_format(s);\n\t\tif (tb->fmt == MNT_FMT_SWAPS)\n\t\t\tgoto next_line;\t\t\t/* skip swap header */\n\t}\n\n\tswitch (tb->fmt) {\n\tcase MNT_FMT_FSTAB:\n\t\trc = mnt_parse_table_line(fs, s);\n\t\tbreak;\n\tcase MNT_FMT_MOUNTINFO:\n\t\trc = mnt_parse_mountinfo_line(fs, s);\n\t\tbreak;\n\tcase MNT_FMT_UTAB:\n\t\trc = mnt_parse_utab_line(fs, s);\n\t\tbreak;\n\tcase MNT_FMT_SWAPS:\n\t\tif (strncmp(s, \"Filename\\t\", 9) == 0)\n\t\t\tgoto next_line;\t\t\t/* skip swap header */\n\t\trc = mnt_parse_swaps_line(fs, s);\n\t\tbreak;\n\tdefault:\n\t\trc = -1;\t/* unknown format */\n\t\tbreak;\n\t}\n\n\tif (rc == 0)\n\t\treturn 0;\nerr:\n\tDBG(TAB, ul_debugobj(tb, \"%s:%zu: %s parse error\", pa->filename, pa->line,\n\t\t\t\ttb->fmt == MNT_FMT_MOUNTINFO ? \"mountinfo\" :\n\t\t\t\ttb->fmt == MNT_FMT_SWAPS ? \"swaps\" :\n\t\t\t\ttb->fmt == MNT_FMT_FSTAB ? \"tab\" : \"utab\"));\n\n\t/* by default all errors are recoverable, otherwise behavior depends on\n\t * the errcb() function. See mnt_table_set_parser_errcb().\n\t */\n\treturn tb->errcb ? tb->errcb(tb, pa->filename, pa->line) : 1;\n}\n\nstatic pid_t path_to_tid(const char *filename)\n{\n\tchar *path = mnt_resolve_path(filename, NULL);\n\tchar *p, *end = NULL;\n\tpid_t tid = 0;\n\n\tif (!path)\n\t\tgoto done;\n\tp = strrchr(path, '/');\n\tif (!p)\n\t\tgoto done;\n\t*p = '\\0';\n\tp = strrchr(path, '/');\n\tif (!p)\n\t\tgoto done;\n\tp++;\n\n\terrno = 0;\n\ttid = strtol(p, &end, 10);\n\tif (errno || p == end || (end && *end)) {\n\t\ttid = 0;\n\t\tgoto done;\n\t}\n\tDBG(TAB, ul_debug(\"TID for %s is %d\", filename, tid));\ndone:\n\tfree(path);\n\treturn tid;\n}\n\nstatic int kernel_fs_postparse(struct libmnt_table *tb,\n\t\t\t       struct libmnt_fs *fs, pid_t *tid,\n\t\t\t       const char *filename)\n{\n\tint rc = 0;\n\tconst char *src = mnt_fs_get_srcpath(fs);\n\n\t/* This is a filesystem description from /proc, so we're in some process\n\t * namespace. Let's remember the process PID.\n\t */\n\tif (filename && *tid == -1)\n\t\t*tid = path_to_tid(filename);\n\n\tfs->tid = *tid;\n\n\t/*\n\t * Convert obscure /dev/root to something more usable\n\t */\n\tif (src && strcmp(src, \"/dev/root\") == 0) {\n\t\tchar *real = NULL;\n\n\t\trc = mnt_guess_system_root(fs->devno, tb->cache, &real);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tif (rc == 0 && real) {\n\t\t\tDBG(TAB, ul_debugobj(tb, \"canonical root FS: %s\", real));\n\t\t\trc = __mnt_fs_set_source_ptr(fs, real);\n\n\t\t} else if (rc == 1) {\n\t\t\t/* mnt_guess_system_root() returns 1 if not able to convert to\n\t\t\t * the real devname; ignore this problem */\n\t\t\trc = 0;\n\t\t}\n\t}\n\n\treturn rc;\n}\n\n/**\n * mnt_table_parse_stream:\n * @tb: tab pointer\n * @f: file stream\n * @filename: filename used for debug and error messages\n *\n * Returns: 0 on success, negative number in case of error.\n */\nint mnt_table_parse_stream(struct libmnt_table *tb, FILE *f, const char *filename)\n{\n\tint rc = -1;\n\tint flags = 0;\n\tpid_t tid = -1;\n\tstruct libmnt_parser pa = { .line = 0 };\n\n\tassert(tb);\n\tassert(f);\n\tassert(filename);\n\n\tDBG(TAB, ul_debugobj(tb, \"%s: start parsing [entries=%d, filter=%s]\",\n\t\t\t\tfilename, mnt_table_get_nents(tb),\n\t\t\t\ttb->fltrcb ? \"yes\" : \"not\"));\n\n\tpa.filename = filename;\n\tpa.f = f;\n\n\t/* necessary for /proc/mounts only, the /proc/self/mountinfo\n\t * parser sets the flag properly\n\t */\n\tif (tb->fmt == MNT_FMT_SWAPS)\n\t\tflags = MNT_FS_SWAP;\n\telse if (filename && strcmp(filename, _PATH_PROC_MOUNTS) == 0)\n\t\tflags = MNT_FS_KERNEL;\n\n\tdo {\n\t\tstruct libmnt_fs *fs;\n\n\t\tif (feof(f)) {\n\t\t\tDBG(TAB, ul_debugobj(tb, \"end-of-file\"));\n\t\t\tbreak;\n\t\t}\n\t\tfs = mnt_new_fs();\n\t\tif (!fs)\n\t\t\tgoto err;\n\n\t\t/* parse */\n\t\trc = mnt_table_parse_next(&pa, tb, fs);\n\n\t\tif (rc == 0 && tb->fltrcb && tb->fltrcb(fs, tb->fltrcb_data))\n\t\t\trc = 1;\t/* filtered out by callback... */\n\n\t\t/* add to the table */\n\t\tif (rc == 0) {\n\t\t\trc = mnt_table_add_fs(tb, fs);\n\t\t\tfs->flags |= flags;\n\n\t\t\tif (rc == 0 && tb->fmt == MNT_FMT_MOUNTINFO) {\n\t\t\t\trc = kernel_fs_postparse(tb, fs, &tid, filename);\n\t\t\t\tif (rc)\n\t\t\t\t\tmnt_table_remove_fs(tb, fs);\n\t\t\t}\n\t\t}\n\n\t\t/* remove reference (or deallocate on error) */\n\t\tmnt_unref_fs(fs);\n\n\t\t/* recoverable error */\n\t\tif (rc > 0) {\n\t\t\tDBG(TAB, ul_debugobj(tb, \"recoverable error (continue)\"));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* fatal errors */\n\t\tif (rc < 0 && !feof(f)) {\n\t\t\tDBG(TAB, ul_debugobj(tb, \"fatal error\"));\n\t\t\tgoto err;\n\t\t}\n\t} while (1);\n\n\tDBG(TAB, ul_debugobj(tb, \"%s: stop parsing (%d entries)\",\n\t\t\t\tfilename, mnt_table_get_nents(tb)));\n\tparser_cleanup(&pa);\n\treturn 0;\nerr:\n\tDBG(TAB, ul_debugobj(tb, \"%s: parse error (rc=%d)\", filename, rc));\n\tparser_cleanup(&pa);\n\treturn rc;\n}\n\n/**\n * mnt_table_parse_file:\n * @tb: tab pointer\n * @filename: file\n *\n * Parses the whole table (e.g. /etc/fstab) and appends new records to the @tab.\n *\n * The libmount parser ignores broken (syntax error) lines, these lines are\n * reported to the caller by the errcb() function (see mnt_table_set_parser_errcb()).\n *\n * Returns: 0 on success, negative number in case of error.\n */\nint mnt_table_parse_file(struct libmnt_table *tb, const char *filename)\n{\n\tFILE *f;\n\tint rc;\n\n\tif (!filename || !tb)\n\t\treturn -EINVAL;\n\n\tf = fopen(filename, \"r\" UL_CLOEXECSTR);\n\tif (f) {\n\t\trc = mnt_table_parse_stream(tb, f, filename);\n\t\tfclose(f);\n\t} else\n\t\trc = -errno;\n\n\tDBG(TAB, ul_debugobj(tb, \"parsing done [filename=%s, rc=%d]\", filename, rc));\n\treturn rc;\n}\n\nstatic int mnt_table_parse_dir_filter(const struct dirent *d)\n{\n\tsize_t namesz;\n\n#ifdef _DIRENT_HAVE_D_TYPE\n\tif (d->d_type != DT_UNKNOWN && d->d_type != DT_REG &&\n\t    d->d_type != DT_LNK)\n\t\treturn 0;\n#endif\n\tif (*d->d_name == '.')\n\t\treturn 0;\n\n#define MNT_MNTTABDIR_EXTSIZ\t(sizeof(MNT_MNTTABDIR_EXT) - 1)\n\n\tnamesz = strlen(d->d_name);\n\tif (!namesz || namesz < MNT_MNTTABDIR_EXTSIZ + 1 ||\n\t    strcmp(d->d_name + (namesz - MNT_MNTTABDIR_EXTSIZ),\n\t\t   MNT_MNTTABDIR_EXT) != 0)\n\t\treturn 0;\n\n\t/* Accept this */\n\treturn 1;\n}\n\n#ifdef HAVE_SCANDIRAT\nstatic int __mnt_table_parse_dir(struct libmnt_table *tb, const char *dirname)\n{\n\tint n = 0, i;\n\tint dd;\n\tstruct dirent **namelist = NULL;\n\n\tdd = open(dirname, O_RDONLY|O_CLOEXEC|O_DIRECTORY);\n\tif (dd < 0)\n\t        return -errno;\n\n\tn = scandirat(dd, \".\", &namelist, mnt_table_parse_dir_filter, versionsort);\n\tif (n <= 0) {\n\t        close(dd);\n\t        return 0;\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\t\tstruct dirent *d = namelist[i];\n\t\tstruct stat st;\n\t\tFILE *f;\n\n\t\tif (fstatat(dd, d->d_name, &st, 0) ||\n\t\t    !S_ISREG(st.st_mode))\n\t\t\tcontinue;\n\n\t\tf = fopen_at(dd, d->d_name, O_RDONLY|O_CLOEXEC, \"r\" UL_CLOEXECSTR);\n\t\tif (f) {\n\t\t\tmnt_table_parse_stream(tb, f, d->d_name);\n\t\t\tfclose(f);\n\t\t}\n\t}\n\n\tfor (i = 0; i < n; i++)\n\t\tfree(namelist[i]);\n\tfree(namelist);\n\tclose(dd);\n\treturn 0;\n}\n#else\nstatic int __mnt_table_parse_dir(struct libmnt_table *tb, const char *dirname)\n{\n\tint n = 0, i, r = 0;\n\tDIR *dir = NULL;\n\tstruct dirent **namelist = NULL;\n\n\tn = scandir(dirname, &namelist, mnt_table_parse_dir_filter, versionsort);\n\tif (n <= 0)\n\t\treturn 0;\n\n\t/* let's use \"at\" functions rather than playing crazy games with paths... */\n\tdir = opendir(dirname);\n\tif (!dir) {\n\t\tr = -errno;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\t\tstruct dirent *d = namelist[i];\n\t\tstruct stat st;\n\t\tFILE *f;\n\n\t\tif (fstatat(dirfd(dir), d->d_name, &st, 0) ||\n\t\t    !S_ISREG(st.st_mode))\n\t\t\tcontinue;\n\n\t\tf = fopen_at(dirfd(dir), d->d_name,\n\t\t\t\tO_RDONLY|O_CLOEXEC, \"r\" UL_CLOEXECSTR);\n\t\tif (f) {\n\t\t\tmnt_table_parse_stream(tb, f, d->d_name);\n\t\t\tfclose(f);\n\t\t}\n\t}\n\nout:\n\tfor (i = 0; i < n; i++)\n\t\tfree(namelist[i]);\n\tfree(namelist);\n\tif (dir)\n\t\tclosedir(dir);\n\treturn r;\n}\n#endif\n\n/**\n * mnt_table_parse_dir:\n * @tb: mount table\n * @dirname: directory\n *\n * The directory:\n *\t- files are sorted by strverscmp(3)\n *\t- files that start with \".\" are ignored (e.g. \".10foo.fstab\")\n *\t- files without the \".fstab\" extension are ignored\n *\n * Returns: 0 on success or negative number in case of error.\n */\nint mnt_table_parse_dir(struct libmnt_table *tb, const char *dirname)\n{\n\treturn __mnt_table_parse_dir(tb, dirname);\n}\n\nstruct libmnt_table *__mnt_new_table_from_file(const char *filename, int fmt, int empty_for_enoent)\n{\n\tstruct libmnt_table *tb;\n\tstruct stat st;\n\n\tif (!filename)\n\t\treturn NULL;\n\tif (stat(filename, &st))\n\t\treturn empty_for_enoent ? mnt_new_table() : NULL;\n\n\ttb = mnt_new_table();\n\tif (tb) {\n\t\tDBG(TAB, ul_debugobj(tb, \"new tab for file: %s\", filename));\n\t\ttb->fmt = fmt;\n\t\tif (mnt_table_parse_file(tb, filename) != 0) {\n\t\t\tmnt_unref_table(tb);\n\t\t\ttb = NULL;\n\t\t}\n\t}\n\treturn tb;\n}\n\n/**\n * mnt_new_table_from_file:\n * @filename: /etc/{m,fs}tab or /proc/self/mountinfo path\n *\n * Same as mnt_new_table() + mnt_table_parse_file(). Use this function for private\n * files only. This function does not allow using the error callback, so you\n * cannot provide any feedback to end-users about broken records in files (e.g.\n * fstab).\n *\n * Returns: newly allocated tab on success and NULL in case of error.\n */\nstruct libmnt_table *mnt_new_table_from_file(const char *filename)\n{\n\tif (!filename)\n\t\treturn NULL;\n\n\treturn __mnt_new_table_from_file(filename, MNT_FMT_GUESS, 0);\n}\n\n/**\n * mnt_new_table_from_dir\n * @dirname: directory with *.fstab files\n *\n * Returns: newly allocated tab on success and NULL in case of error.\n */\nstruct libmnt_table *mnt_new_table_from_dir(const char *dirname)\n{\n\tstruct libmnt_table *tb;\n\n\tif (!dirname)\n\t\treturn NULL;\n\ttb = mnt_new_table();\n\tif (tb && mnt_table_parse_dir(tb, dirname) != 0) {\n\t\tmnt_unref_table(tb);\n\t\ttb = NULL;\n\t}\n\treturn tb;\n}\n\n/**\n * mnt_table_set_parser_errcb:\n * @tb: pointer to table\n * @cb: pointer to callback function\n *\n * The error callback function is called by table parser (mnt_table_parse_file())\n * in case of a syntax error. The callback function could be used for error\n * evaluation, libmount will continue/stop parsing according to callback return\n * codes:\n *\n *   <0  : fatal error (abort parsing)\n *    0\t : success (parsing continues)\n *   >0  : recoverable error (the line is ignored, parsing continues).\n *\n * Returns: 0 on success or negative number in case of error.\n */\nint mnt_table_set_parser_errcb(struct libmnt_table *tb,\n\t\tint (*cb)(struct libmnt_table *tb, const char *filename, int line))\n{\n\tif (!tb)\n\t\treturn -EINVAL;\n\ttb->errcb = cb;\n\treturn 0;\n}\n\n/*\n * Filter out entries during tab file parsing. If @cb returns 1, then the entry\n * is ignored.\n */\nint mnt_table_set_parser_fltrcb(struct libmnt_table *tb,\n\t\tint (*cb)(struct libmnt_fs *, void *),\n\t\tvoid *data)\n{\n\tif (!tb)\n\t\treturn -EINVAL;\n\n\tDBG(TAB, ul_debugobj(tb, \"%s table parser filter\", cb ? \"set\" : \"unset\"));\n\ttb->fltrcb = cb;\n\ttb->fltrcb_data = data;\n\treturn 0;\n}\n\n/**\n * mnt_table_parse_swaps:\n * @tb: table\n * @filename: overwrites default (/proc/swaps or $LIBMOUNT_SWAPS) or NULL\n *\n * This function parses /proc/swaps and appends new lines to the @tab.\n *\n * See also mnt_table_set_parser_errcb().\n *\n * Returns: 0 on success or negative number in case of error.\n */\nint mnt_table_parse_swaps(struct libmnt_table *tb, const char *filename)\n{\n\tif (!tb)\n\t\treturn -EINVAL;\n\tif (!filename) {\n\t\tfilename = mnt_get_swaps_path();\n\t\tif (!filename)\n\t\t\treturn -EINVAL;\n\t}\n\n\ttb->fmt = MNT_FMT_SWAPS;\n\n\treturn mnt_table_parse_file(tb, filename);\n}\n\n/**\n * mnt_table_parse_fstab:\n * @tb: table\n * @filename: overwrites default (/etc/fstab or $LIBMOUNT_FSTAB) or NULL\n *\n * This function parses /etc/fstab and appends new lines to the @tab. If the\n * @filename is a directory, then mnt_table_parse_dir() is called.\n *\n * See also mnt_table_set_parser_errcb().\n *\n * Returns: 0 on success or negative number in case of error.\n */\nint mnt_table_parse_fstab(struct libmnt_table *tb, const char *filename)\n{\n\tstruct stat st;\n\tint rc = 0;\n\n\tif (!tb)\n\t\treturn -EINVAL;\n\tif (!filename)\n\t\tfilename = mnt_get_fstab_path();\n\tif (!filename)\n\t\treturn -EINVAL;\n\tif (stat(filename, &st) != 0)\n\t\treturn -errno;\n\n\ttb->fmt = MNT_FMT_FSTAB;\n\n\tif (S_ISREG(st.st_mode))\n\t\trc = mnt_table_parse_file(tb, filename);\n\telse if (S_ISDIR(st.st_mode))\n\t\trc = mnt_table_parse_dir(tb, filename);\n\telse\n\t\trc = -EINVAL;\n\n\treturn rc;\n}\n\n/*\n * This function uses @uf to find a corresponding record in @tb, then the record\n * from @tb is updated (user specific mount options are added).\n *\n * Note that @uf must contain only user specific mount options instead of\n * VFS options (note that FS options are ignored).\n *\n * Returns modified filesystem (from @tb) or NULL.\n */\nstatic struct libmnt_fs *mnt_table_merge_user_fs(struct libmnt_table *tb, struct libmnt_fs *uf)\n{\n\tstruct libmnt_fs *fs;\n\tstruct libmnt_iter itr;\n\tconst char *optstr, *src, *target, *root, *attrs;\n\n\tif (!tb || !uf)\n\t\treturn NULL;\n\n\tDBG(TAB, ul_debugobj(tb, \"merging user fs\"));\n\n\tsrc = mnt_fs_get_srcpath(uf);\n\ttarget = mnt_fs_get_target(uf);\n\toptstr = mnt_fs_get_user_options(uf);\n\tattrs = mnt_fs_get_attributes(uf);\n\troot = mnt_fs_get_root(uf);\n\n\tif (!src || !target || !root || (!attrs && !optstr))\n\t\treturn NULL;\n\n\tmnt_reset_iter(&itr, MNT_ITER_BACKWARD);\n\n\twhile(mnt_table_next_fs(tb, &itr, &fs) == 0) {\n\t\tconst char *r = mnt_fs_get_root(fs);\n\n\t\tif (fs->flags & MNT_FS_MERGED)\n\t\t\tcontinue;\n\n\t\tif (r && strcmp(r, root) == 0\n\t\t    && mnt_fs_streq_target(fs, target)\n\t\t    && mnt_fs_streq_srcpath(fs, src))\n\t\t\tbreak;\n\t}\n\n\tif (fs) {\n\t\tDBG(TAB, ul_debugobj(tb, \"found fs -- appending user optstr\"));\n\t\tmnt_fs_append_options(fs, optstr);\n\t\tmnt_fs_append_attributes(fs, attrs);\n\t\tmnt_fs_set_bindsrc(fs, mnt_fs_get_bindsrc(uf));\n\t\tfs->flags |= MNT_FS_MERGED;\n\n\t\tDBG(TAB, ul_debugobj(tb, \"found fs:\"));\n\t\tDBG(TAB, mnt_fs_print_debug(fs, stderr));\n\t}\n\treturn fs;\n}\n\n/* default filename is /proc/self/mountinfo\n */\nint __mnt_table_parse_mtab(struct libmnt_table *tb, const char *filename,\n\t\t\t   struct libmnt_table *u_tb)\n{\n\tint rc = 0, priv_utab = 0;\n\tint explicit_file = filename ? 1 : 0;\n\n\tassert(tb);\n\n\tif (filename)\n\t\tDBG(TAB, ul_debugobj(tb, \"%s requested as mtab\", filename));\n\n#ifdef USE_LIBMOUNT_SUPPORT_MTAB\n\tif (mnt_has_regular_mtab(&filename, NULL)) {\n\n\t\tDBG(TAB, ul_debugobj(tb, \"force mtab usage [filename=%s]\", filename));\n\n\t\trc = mnt_table_parse_file(tb, filename);\n\n\t\t/*\n\t\t * If @filename forces us to read from /proc then also read\n\t\t * utab file to merge userspace mount options.\n\t\t */\n\t\tif (rc == 0 && is_mountinfo(tb))\n\t\t\tgoto read_utab;\n\n\t\tif (!rc)\n\t\t\treturn 0;\n\t\tfilename = NULL;\t/* failed */\n\t} else\n\t\tfilename = NULL;\t/* mtab useless */\n#endif\n\n\tif (!filename || strcmp(filename, _PATH_PROC_MOUNTINFO) == 0) {\n\t\tfilename = _PATH_PROC_MOUNTINFO;\n\t\ttb->fmt = MNT_FMT_MOUNTINFO;\n\t\tDBG(TAB, ul_debugobj(tb, \"mtab parse: #1 read mountinfo\"));\n\t} else\n\t\ttb->fmt = MNT_FMT_GUESS;\n\n\trc = mnt_table_parse_file(tb, filename);\n\tif (rc) {\n\t\tif (explicit_file)\n\t\t\treturn rc;\n\n\t\t/* hmm, old kernel? ...try /proc/mounts */\n\t\ttb->fmt = MNT_FMT_MTAB;\n\t\treturn mnt_table_parse_file(tb, _PATH_PROC_MOUNTS);\n\t}\n\n\tif (!is_mountinfo(tb))\n\t\treturn 0;\n#ifdef USE_LIBMOUNT_SUPPORT_MTAB\nread_utab:\n#endif\n\tDBG(TAB, ul_debugobj(tb, \"mtab parse: #2 read utab\"));\n\n\tif (mnt_table_get_nents(tb) == 0)\n\t\treturn 0;\t\t\t/* empty, ignore utab */\n\t/*\n\t * try to read the user specific information from /run/mount/utabs\n\t */\n\tif (!u_tb) {\n\t\tconst char *utab = mnt_get_utab_path();\n\n\t\tif (!utab || is_file_empty(utab))\n\t\t\treturn 0;\n\n\t\tu_tb = mnt_new_table();\n\t\tif (!u_tb)\n\t\t\treturn -ENOMEM;\n\n\t\tu_tb->fmt = MNT_FMT_UTAB;\n\t\tmnt_table_set_parser_fltrcb(u_tb, tb->fltrcb, tb->fltrcb_data);\n\n\t\trc = mnt_table_parse_file(u_tb, utab);\n\t\tpriv_utab = 1;\n\t}\n\n\tDBG(TAB, ul_debugobj(tb, \"mtab parse: #3 merge utab\"));\n\n\tif (rc == 0) {\n\t\tstruct libmnt_fs *u_fs;\n\t\tstruct libmnt_iter itr;\n\n\t\tmnt_reset_iter(&itr, MNT_ITER_BACKWARD);\n\n\t\t/*  merge user options into mountinfo from the kernel */\n\t\twhile(mnt_table_next_fs(u_tb, &itr, &u_fs) == 0)\n\t\t\tmnt_table_merge_user_fs(tb, u_fs);\n\t}\n\n\n\tif (priv_utab)\n\t\tmnt_unref_table(u_tb);\n\treturn 0;\n}\n/**\n * mnt_table_parse_mtab:\n * @tb: table\n * @filename: overwrites default or NULL\n *\n * The default filename is /proc/self/mountinfo. If the mount table is a\n * mountinfo file then /run/mount/utabs is parsed too and both files are merged\n * to the one libmnt_table.\n *\n * If libmount is compiled with classic mtab file support, and the /etc/mtab is\n * a regular file then this file is parsed.\n *\n * It's strongly recommended to use NULL as a @filename to keep code portable.\n *\n * See also mnt_table_set_parser_errcb().\n *\n * Returns: 0 on success or negative number in case of error.\n */\nint mnt_table_parse_mtab(struct libmnt_table *tb, const char *filename)\n{\n\treturn __mnt_table_parse_mtab(tb, filename, NULL);\n}\n", "/*\n * findmnt(8)\n *\n * Copyright (C) 2010-2015 Red Hat, Inc. All rights reserved.\n * Written by Karel Zak <kzak@redhat.com>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it would be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <getopt.h>\n#include <string.h>\n#include <termios.h>\n#ifdef HAVE_SYS_IOCTL_H\n# include <sys/ioctl.h>\n#endif\n#include <assert.h>\n#include <poll.h>\n#include <sys/statvfs.h>\n#include <sys/types.h>\n#ifdef HAVE_LIBUDEV\n# include <libudev.h>\n#endif\n#include <blkid.h>\n#include <libmount.h>\n#include <libsmartcols.h>\n\n#include \"pathnames.h\"\n#include \"nls.h\"\n#include \"closestream.h\"\n#include \"c.h\"\n#include \"strutils.h\"\n#include \"xalloc.h\"\n#include \"optutils.h\"\n#include \"mangle.h\"\n#include \"buffer.h\"\n\n#include \"findmnt.h\"\n\n/* column IDs */\nenum {\n\tCOL_ACTION,\n\tCOL_AVAIL,\n\tCOL_FREQ,\n\tCOL_FSROOT,\n\tCOL_FSTYPE,\n\tCOL_FS_OPTIONS,\n\tCOL_ID,\n\tCOL_LABEL,\n\tCOL_MAJMIN,\n\tCOL_OLD_OPTIONS,\n\tCOL_OLD_TARGET,\n\tCOL_OPTIONS,\n\tCOL_OPT_FIELDS,\n\tCOL_PARENT,\n\tCOL_PARTLABEL,\n\tCOL_PARTUUID,\n\tCOL_PASSNO,\n\tCOL_PROPAGATION,\n\tCOL_SIZE,\n\tCOL_SOURCE,\n\tCOL_SOURCES,\n\tCOL_TARGET,\n\tCOL_TID,\n\tCOL_USED,\n\tCOL_USEPERC,\n\tCOL_UUID,\n\tCOL_VFS_OPTIONS\n};\n\nenum {\n\tTABTYPE_FSTAB = 1,\n\tTABTYPE_MTAB,\n\tTABTYPE_KERNEL\n};\n\n/* column names */\nstruct colinfo {\n\tconst char\t*name;\t\t/* header */\n\tdouble\t\twhint;\t\t/* width hint (N < 1 is in percent of termwidth) */\n\tint\t\tflags;\t\t/* libsmartcols flags */\n\tconst char      *help;\t\t/* column description */\n\tconst char\t*match;\t\t/* pattern for match_func() */\n\tvoid\t\t*match_data;\t/* match specific data */\n};\n\n/* columns descriptions (don't use const, this is writable) */\nstatic struct colinfo infos[] = {\n\t[COL_ACTION]       = { \"ACTION\",         10, SCOLS_FL_STRICTWIDTH, N_(\"action detected by --poll\") },\n\t[COL_AVAIL]        = { \"AVAIL\",           5, SCOLS_FL_RIGHT, N_(\"filesystem size available\") },\n\t[COL_FREQ]         = { \"FREQ\",            1, SCOLS_FL_RIGHT, N_(\"dump(8) period in days [fstab only]\") },\n\t[COL_FSROOT]       = { \"FSROOT\",       0.25, SCOLS_FL_NOEXTREMES, N_(\"filesystem root\") },\n\t[COL_FSTYPE]       = { \"FSTYPE\",       0.10, SCOLS_FL_TRUNC, N_(\"filesystem type\") },\n\t[COL_FS_OPTIONS]   = { \"FS-OPTIONS\",   0.10, SCOLS_FL_TRUNC, N_(\"FS specific mount options\") },\n\t[COL_ID]           = { \"ID\",              2, SCOLS_FL_RIGHT, N_(\"mount ID\") },\n\t[COL_LABEL]        = { \"LABEL\",        0.10, 0, N_(\"filesystem label\") },\n\t[COL_MAJMIN]       = { \"MAJ:MIN\",         6, 0, N_(\"major:minor device number\") },\n\t[COL_OLD_OPTIONS]  = { \"OLD-OPTIONS\",  0.10, SCOLS_FL_TRUNC, N_(\"old mount options saved by --poll\") },\n\t[COL_OLD_TARGET]   = { \"OLD-TARGET\",   0.30, 0, N_(\"old mountpoint saved by --poll\") },\n\t[COL_OPTIONS]      = { \"OPTIONS\",      0.10, SCOLS_FL_TRUNC, N_(\"all mount options\") },\n\t[COL_OPT_FIELDS]   = { \"OPT-FIELDS\",   0.10, SCOLS_FL_TRUNC, N_(\"optional mount fields\") },\n\t[COL_PARENT]       = { \"PARENT\",          2, SCOLS_FL_RIGHT, N_(\"mount parent ID\") },\n\t[COL_PARTLABEL]    = { \"PARTLABEL\",    0.10, 0, N_(\"partition label\") },\n\t[COL_PARTUUID]     = { \"PARTUUID\",       36, 0, N_(\"partition UUID\") },\n\t[COL_PASSNO]       = { \"PASSNO\",          1, SCOLS_FL_RIGHT, N_(\"pass number on parallel fsck(8) [fstab only]\") },\n\t[COL_PROPAGATION]  = { \"PROPAGATION\",  0.10, 0, N_(\"VFS propagation flags\") },\n\t[COL_SIZE]         = { \"SIZE\",            5, SCOLS_FL_RIGHT, N_(\"filesystem size\") },\n\t[COL_SOURCES]      = { \"SOURCES\",      0.25, SCOLS_FL_WRAP, N_(\"all possible source devices [fstab only]\") },\n\t[COL_SOURCE]       = { \"SOURCE\",       0.25, SCOLS_FL_NOEXTREMES, N_(\"source device\") },\n\t[COL_TARGET]       = { \"TARGET\",       0.30, SCOLS_FL_TREE| SCOLS_FL_NOEXTREMES, N_(\"mountpoint\") },\n\t[COL_TID]          = { \"TID\",             4, SCOLS_FL_RIGHT, N_(\"task ID\") },\n\t[COL_USED]         = { \"USED\",            5, SCOLS_FL_RIGHT, N_(\"filesystem size used\") },\n\t[COL_USEPERC]      = { \"USE%\",            3, SCOLS_FL_RIGHT, N_(\"filesystem use percentage\") },\n\t[COL_UUID]         = { \"UUID\",           36, 0, N_(\"filesystem UUID\") },\n\t[COL_VFS_OPTIONS]  = { \"VFS-OPTIONS\",  0.20, SCOLS_FL_TRUNC, N_(\"VFS specific mount options\") }\n};\n\n/* columns[] array specifies all currently wanted output column. The columns\n * are defined by infos[] array and you can specify (on command line) each\n * column twice. That's enough, dynamically allocated array of the columns is\n * unnecessary overkill and over-engineering in this case */\nstatic int columns[ARRAY_SIZE(infos) * 2];\nstatic size_t ncolumns;\n\nstatic inline size_t err_columns_index(size_t arysz, size_t idx)\n{\n\tif (idx >= arysz)\n\t\terrx(EXIT_FAILURE, _(\"too many columns specified, \"\n\t\t\t\t     \"the limit is %zu columns\"),\n\t\t\t\tarysz - 1);\n\treturn idx;\n}\n\n#define add_column(ary, n, id)\t\\\n\t\t((ary)[ err_columns_index(ARRAY_SIZE(ary), (n)) ] = (id))\n\n/* poll actions (parsed --poll=<list> */\n#define FINDMNT_NACTIONS\t4\t\t/* mount, umount, move, remount */\nstatic int actions[FINDMNT_NACTIONS];\nstatic int nactions;\n\n/* global (accessed from findmnt-verify.c too) */\nunsigned int flags;\nint parse_nerrors;\nstruct libmnt_cache *cache;\n\n\n#ifdef HAVE_LIBUDEV\nstatic struct udev *udev;\n#endif\n\nstatic int match_func(struct libmnt_fs *fs, void *data __attribute__ ((__unused__)));\n\n\nstatic int get_column_id(int num)\n{\n\tassert(num >= 0);\n\tassert((size_t) num < ncolumns);\n\tassert((size_t) columns[num] < ARRAY_SIZE(infos));\n\treturn columns[num];\n}\n\nstatic struct colinfo *get_column_info(int num)\n{\n\treturn &infos[ get_column_id(num) ];\n}\n\nstatic const char *column_id_to_name(int id)\n{\n\tassert((size_t) id < ARRAY_SIZE(infos));\n\treturn infos[id].name;\n}\n\nstatic const char *get_column_name(int num)\n{\n\treturn get_column_info(num)->name;\n}\n\nstatic float get_column_whint(int num)\n{\n\treturn get_column_info(num)->whint;\n}\n\nstatic int get_column_flags(int num)\n{\n\treturn get_column_info(num)->flags;\n}\n\nstatic const char *get_match(int id)\n{\n\tassert((size_t) id < ARRAY_SIZE(infos));\n\treturn infos[id].match;\n}\n\nstatic void *get_match_data(int id)\n{\n\tassert((size_t) id < ARRAY_SIZE(infos));\n\treturn infos[id].match_data;\n}\n\nstatic void set_match(int id, const char *match)\n{\n\tassert((size_t) id < ARRAY_SIZE(infos));\n\tinfos[id].match = match;\n}\n\nstatic void set_match_data(int id, void *data)\n{\n\tassert((size_t) id < ARRAY_SIZE(infos));\n\tinfos[id].match_data = data;\n}\n\n/*\n * source match means COL_SOURCE *or* COL_MAJMIN, depends on\n * data format.\n */\nstatic void set_source_match(const char *data)\n{\n\tint maj, min;\n\n\tif (sscanf(data, \"%d:%d\", &maj, &min) == 2) {\n\t\tdev_t *devno = xmalloc(sizeof(dev_t));\n\n\t\t*devno = makedev(maj, min);\n\t\tset_match(COL_MAJMIN, data);\n\t\tset_match_data(COL_MAJMIN, (void *) devno);\n\t\tflags |= FL_NOSWAPMATCH;\n\t} else\n\t\tset_match(COL_SOURCE, data);\n}\n\n/*\n * Extra functionality for --target <path>. The function mnt_table_find_mountpoint()\n * also checks parents (path elements in reverse order) to get mountpoint.\n *\n * @tb has to be from kernel (so no fstab or so)!\n */\nstatic void enable_extra_target_match(struct libmnt_table *tb)\n{\n\tchar *cn = NULL;\n\tconst char *tgt = NULL, *mnt = NULL;\n\tstruct libmnt_fs *fs;\n\n\t/*\n\t * Check if match pattern is mountpoint, if not use the\n\t * real mountpoint.\n\t */\n\tif (flags & FL_NOCACHE)\n\t\ttgt = get_match(COL_TARGET);\n\telse {\n\t\ttgt = cn = mnt_resolve_path(get_match(COL_TARGET), cache);\n\t\tif (!cn)\n\t\t\treturn;\n\t}\n\n\tfs = mnt_table_find_mountpoint(tb, tgt, MNT_ITER_BACKWARD);\n\tif (fs)\n\t\tmnt = mnt_fs_get_target(fs);\n\tif (mnt && strcmp(mnt, tgt) != 0)\n\t\tset_match(COL_TARGET, xstrdup(mnt));\t/* replace the current setting */\n\n\tif (!cache)\n\t\tfree(cn);\n}\n\n\nstatic int is_tabdiff_column(int id)\n{\n\tassert((size_t) id < ARRAY_SIZE(infos));\n\n\tswitch(id) {\n\tcase COL_ACTION:\n\tcase COL_OLD_TARGET:\n\tcase COL_OLD_OPTIONS:\n\t\treturn 1;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n/*\n * \"findmnt\" without any filter\n */\nint is_listall_mode(void)\n{\n\tif ((flags & FL_DF || flags & FL_REAL || flags & FL_PSEUDO) && !(flags & FL_ALL))\n\t\treturn 0;\n\n\treturn (!get_match(COL_SOURCE) &&\n\t\t!get_match(COL_TARGET) &&\n\t\t!get_match(COL_FSTYPE) &&\n\t\t!get_match(COL_OPTIONS) &&\n\t\t!get_match(COL_MAJMIN));\n}\n\n/*\n * Returns 1 if the @act is in the --poll=<list>\n */\nstatic int has_poll_action(int act)\n{\n\tint i;\n\n\tif (!nactions)\n\t\treturn 1;\t/* all actions enabled */\n\tfor (i = 0; i < nactions; i++)\n\t\tif (actions[i] == act)\n\t\t\treturn 1;\n\treturn 0;\n}\n\nstatic int poll_action_name_to_id(const char *name, size_t namesz)\n{\n\tint id = -1;\n\n\tif (strncasecmp(name, \"move\", namesz) == 0 && namesz == 4)\n\t\tid = MNT_TABDIFF_MOVE;\n\telse if (strncasecmp(name, \"mount\", namesz) == 0 && namesz == 5)\n\t\tid = MNT_TABDIFF_MOUNT;\n\telse if (strncasecmp(name, \"umount\", namesz) == 0 && namesz == 6)\n\t\tid = MNT_TABDIFF_UMOUNT;\n\telse if (strncasecmp(name, \"remount\", namesz) == 0 && namesz == 7)\n\t\tid = MNT_TABDIFF_REMOUNT;\n\telse\n\t\twarnx(_(\"unknown action: %s\"), name);\n\n\treturn id;\n}\n\n/*\n * findmnt --first-only <devname|TAG=|mountpoint>\n *\n * ... it works like \"mount <devname|TAG=|mountpoint>\"\n */\nstatic int is_mount_compatible_mode(void)\n{\n\tif (!get_match(COL_SOURCE))\n\t       return 0;\t\t/* <devname|TAG=|mountpoint> is required */\n\tif (get_match(COL_FSTYPE) || get_match(COL_OPTIONS))\n\t\treturn 0;\t\t/* cannot be restricted by -t or -O */\n\tif (!(flags & FL_FIRSTONLY))\n\t\treturn 0;\t\t/* we have to return the first entry only */\n\n\treturn 1;\t\t\t/* ok */\n}\n\nstatic void disable_columns_truncate(void)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < ARRAY_SIZE(infos); i++)\n\t\tinfos[i].flags &= ~SCOLS_FL_TRUNC;\n}\n\n/*\n * converts @name to column ID\n */\nstatic int column_name_to_id(const char *name, size_t namesz)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < ARRAY_SIZE(infos); i++) {\n\t\tconst char *cn = column_id_to_name(i);\n\n\t\tif (!strncasecmp(name, cn, namesz) && !*(cn + namesz))\n\t\t\treturn i;\n\t}\n\twarnx(_(\"unknown column: %s\"), name);\n\treturn -1;\n}\n\n\n#ifdef HAVE_LIBUDEV\nstatic char *get_tag_from_udev(const char *devname, int col)\n{\n\tstruct udev_device *dev;\n\tconst char *data = NULL;\n\tchar *res = NULL, *path;\n\n\tif (!udev)\n\t\tudev = udev_new();\n\tif (!udev)\n\t\treturn NULL;\n\n\t/* libudev don't like /dev/mapper/ symlinks */\n\tpath = realpath(devname, NULL);\n\tif (path)\n\t\tdevname = path;\n\n\tif (strncmp(devname, \"/dev/\", 5) == 0)\n\t\tdevname += 5;\n\n\tdev = udev_device_new_from_subsystem_sysname(udev, \"block\", devname);\n\tfree(path);\n\n\tif (!dev)\n\t\treturn NULL;\n\n\tswitch(col) {\n\tcase COL_LABEL:\n\t\tdata = udev_device_get_property_value(dev, \"ID_FS_LABEL_ENC\");\n\t\tbreak;\n\tcase COL_UUID:\n\t\tdata = udev_device_get_property_value(dev, \"ID_FS_UUID_ENC\");\n\t\tbreak;\n\tcase COL_PARTUUID:\n\t\tdata = udev_device_get_property_value(dev, \"ID_PART_ENTRY_UUID\");\n\t\tbreak;\n\tcase COL_PARTLABEL:\n\t\tdata = udev_device_get_property_value(dev, \"ID_PART_ENTRY_NAME\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (data) {\n\t\tres = xstrdup(data);\n\t\tunhexmangle_string(res);\n\t}\n\n\tudev_device_unref(dev);\n\treturn res;\n}\n#endif /* HAVE_LIBUDEV */\n\n/* Returns LABEL or UUID */\nstatic char *get_tag(struct libmnt_fs *fs, const char *tagname, int col\n#ifndef HAVE_LIBUDEV\n\t\t__attribute__((__unused__))\n#endif\n\t\t)\n{\n\tconst char *t, *v;\n\tchar *res = NULL;\n\n\tif (!mnt_fs_get_tag(fs, &t, &v) && !strcmp(t, tagname))\n\t\tres = xstrdup(v);\n\telse {\n\t\tconst char *dev = mnt_fs_get_source(fs);\n\n\t\tif (dev && !(flags & FL_NOCACHE))\n\t\t\tdev = mnt_resolve_spec(dev, cache);\n#ifdef HAVE_LIBUDEV\n\t\tif (dev)\n\t\t\tres = get_tag_from_udev(dev, col);\n#endif\n\t\tif (!res) {\n\t\t\tres = mnt_cache_find_tag_value(cache, dev, tagname);\n\t\t\tif (res && cache)\n\t\t\t\t/* don't return pointer to cache */\n\t\t\t\tres = xstrdup(res);\n\t\t}\n\t}\n\n\treturn res;\n}\n\nstatic char *get_vfs_attr(struct libmnt_fs *fs, int sizetype)\n{\n\tstruct statvfs buf;\n\tuint64_t vfs_attr = 0;\n\tchar *sizestr;\n\n\tif (statvfs(mnt_fs_get_target(fs), &buf) != 0)\n\t\treturn NULL;\n\n\tswitch(sizetype) {\n\tcase COL_SIZE:\n\t\tvfs_attr = buf.f_frsize * buf.f_blocks;\n\t\tbreak;\n\tcase COL_AVAIL:\n\t\tvfs_attr = buf.f_frsize * buf.f_bavail;\n\t\tbreak;\n\tcase COL_USED:\n\t\tvfs_attr = buf.f_frsize * (buf.f_blocks - buf.f_bfree);\n\t\tbreak;\n\tcase COL_USEPERC:\n\t\tif (buf.f_blocks == 0)\n\t\t\treturn xstrdup(\"-\");\n\n\t\txasprintf(&sizestr, \"%.0f%%\",\n\t\t\t\t(double)(buf.f_blocks - buf.f_bfree) /\n\t\t\t\tbuf.f_blocks * 100);\n\t\treturn sizestr;\n\t}\n\n\tif (!vfs_attr)\n\t\tsizestr = xstrdup(\"0\");\n\telse if (flags & FL_BYTES)\n\t\txasprintf(&sizestr, \"%ju\", vfs_attr);\n\telse\n\t\tsizestr = size_to_human_string(SIZE_SUFFIX_1LETTER, vfs_attr);\n\n\treturn sizestr;\n}\n\n/* reads FS data from libmount\n */\nstatic char *get_data(struct libmnt_fs *fs, int num)\n{\n\tchar *str = NULL;\n\tconst char *t = NULL, *v = NULL;\n\tint col_id = get_column_id(num);\n\n\tswitch (col_id) {\n\tcase COL_SOURCES:\n\t\t/* print all devices with the same tag (LABEL, UUID) */\n\t\tif ((flags & FL_EVALUATE) &&\n\t\t    mnt_fs_get_tag(fs, &t, &v) == 0) {\n\t\t\tblkid_dev_iterate iter;\n\t\t\tblkid_dev dev;\n\t\t\tblkid_cache cache = NULL;\n\t\t\tstruct ul_buffer buf = UL_INIT_BUFFER;\n\t\t\tint i = 0;\n\n\t\t\tif (blkid_get_cache(&cache, NULL) < 0)\n\t\t\t\tbreak;\n\n\t\t\tblkid_probe_all(cache);\n\n\t\t\titer = blkid_dev_iterate_begin(cache);\n\t\t\tblkid_dev_set_search(iter, t, v);\n\t\t\twhile (blkid_dev_next(iter, &dev) == 0) {\n\t\t\t\tdev = blkid_verify(cache, dev);\n\t\t\t\tif (!dev)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (i != 0)\n\t\t\t\t\tul_buffer_append_data(&buf, \"\\n\", 1);\n\t\t\t\tul_buffer_append_string(&buf, blkid_dev_devname(dev));\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tblkid_dev_iterate_end(iter);\n\t\t\tstr = ul_buffer_get_data(&buf, NULL, NULL);\n\t\t\tbreak;\n\t\t}\n\t\t/* fallthrough */\n\tcase COL_SOURCE:\n\t{\n\t\tconst char *root = mnt_fs_get_root(fs);\n\t\tconst char *spec = mnt_fs_get_srcpath(fs);\n\t\tchar *cn = NULL;\n\n\t\tif (spec && (flags & FL_CANONICALIZE))\n\t\t\tspec = cn = mnt_resolve_path(spec, cache);\n\t\tif (!spec) {\n\t\t\tspec = mnt_fs_get_source(fs);\n\n\t\t\tif (spec && (flags & FL_EVALUATE))\n\t\t\t\tspec = cn = mnt_resolve_spec(spec, cache);\n\t\t}\n\t\tif (root && spec && !(flags & FL_NOFSROOT) && strcmp(root, \"/\") != 0)\n\t\t\txasprintf(&str, \"%s[%s]\", spec, root);\n\t\telse if (spec)\n\t\t\tstr = xstrdup(spec);\n\t\tif (!cache)\n\t\t\tfree(cn);\n\t\tbreak;\n\t}\n\n\tcase COL_TARGET:\n\t\tif (mnt_fs_get_target(fs))\n\t\t\tstr = xstrdup(mnt_fs_get_target(fs));\n\t\tbreak;\n\tcase COL_FSTYPE:\n\t\tif (mnt_fs_get_fstype(fs))\n\t\t\tstr = xstrdup(mnt_fs_get_fstype(fs));\n\t\tbreak;\n\tcase COL_OPTIONS:\n\t\tif (mnt_fs_get_options(fs))\n\t\t\tstr = xstrdup(mnt_fs_get_options(fs));\n\t\tbreak;\n\tcase COL_VFS_OPTIONS:\n\t\tif (flags & FL_VFS_ALL)\n\t\t\tstr = mnt_fs_get_vfs_options_all(fs);\n\t\telse if (mnt_fs_get_vfs_options(fs))\n\t\t\tstr = xstrdup(mnt_fs_get_vfs_options(fs));\n\t\tbreak;\n\tcase COL_FS_OPTIONS:\n\t\tif (mnt_fs_get_fs_options(fs))\n\t\t\tstr = xstrdup(mnt_fs_get_fs_options(fs));\n\t\tbreak;\n\tcase COL_OPT_FIELDS:\n\t\tif (mnt_fs_get_optional_fields(fs))\n\t\t\tstr = xstrdup(mnt_fs_get_optional_fields(fs));\n\t\tbreak;\n\tcase COL_UUID:\n\t\tstr = get_tag(fs, \"UUID\", col_id);\n\t\tbreak;\n\tcase COL_PARTUUID:\n\t\tstr = get_tag(fs, \"PARTUUID\", col_id);\n\t\tbreak;\n\tcase COL_LABEL:\n\t\tstr = get_tag(fs, \"LABEL\", col_id);\n\t\tbreak;\n\tcase COL_PARTLABEL:\n\t\tstr = get_tag(fs, \"PARTLABEL\", col_id);\n\t\tbreak;\n\n\tcase COL_MAJMIN:\n\t{\n\t\tdev_t devno = mnt_fs_get_devno(fs);\n\t\tif (!devno)\n\t\t\tbreak;\n\n\t\tif ((flags & FL_RAW) || (flags & FL_EXPORT) || (flags & FL_JSON))\n\t\t\txasprintf(&str, \"%u:%u\", major(devno), minor(devno));\n\t\telse\n\t\t\txasprintf(&str, \"%3u:%-3u\", major(devno), minor(devno));\n\t\tbreak;\n\t}\n\tcase COL_SIZE:\n\tcase COL_AVAIL:\n\tcase COL_USED:\n\tcase COL_USEPERC:\n\t\tstr = get_vfs_attr(fs, col_id);\n\t\tbreak;\n\tcase COL_FSROOT:\n\t\tif (mnt_fs_get_root(fs))\n\t\t\tstr = xstrdup(mnt_fs_get_root(fs));\n\t\tbreak;\n\tcase COL_TID:\n\t\tif (mnt_fs_get_tid(fs))\n\t\t\txasprintf(&str, \"%d\", mnt_fs_get_tid(fs));\n\t\tbreak;\n\tcase COL_ID:\n\t\tif (mnt_fs_get_id(fs))\n\t\t\txasprintf(&str, \"%d\", mnt_fs_get_id(fs));\n\t\tbreak;\n\tcase COL_PARENT:\n\t\tif (mnt_fs_get_parent_id(fs))\n\t\t\txasprintf(&str, \"%d\", mnt_fs_get_parent_id(fs));\n\t\tbreak;\n\tcase COL_PROPAGATION:\n\t\tif (mnt_fs_is_kernel(fs)) {\n\t\t\tunsigned long fl = 0;\n\t\t\tchar *n = NULL;\n\n\t\t\tif (mnt_fs_get_propagation(fs, &fl) != 0)\n\t\t\t\tbreak;\n\n\t\t\tn = xstrdup((fl & MS_SHARED) ? \"shared\" : \"private\");\n\n\t\t\tif (fl & MS_SLAVE) {\n\t\t\t\txasprintf(&str, \"%s,slave\", n);\n\t\t\t\tfree(n);\n\t\t\t\tn = str;\n\t\t\t}\n\t\t\tif (fl & MS_UNBINDABLE) {\n\t\t\t\txasprintf(&str, \"%s,unbindable\", n);\n\t\t\t\tfree(n);\n\t\t\t\tn = str;\n\t\t\t}\n\t\t\tstr = n;\n\t\t}\n\t\tbreak;\n\tcase COL_FREQ:\n\t\tif (!mnt_fs_is_kernel(fs))\n\t\t\txasprintf(&str, \"%d\", mnt_fs_get_freq(fs));\n\t\tbreak;\n\tcase COL_PASSNO:\n\t\tif (!mnt_fs_is_kernel(fs))\n\t\t\txasprintf(&str, \"%d\", mnt_fs_get_passno(fs));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn str;\n}\n\nstatic char *get_tabdiff_data(struct libmnt_fs *old_fs,\n\t\t\t\t    struct libmnt_fs *new_fs,\n\t\t\t\t    int change,\n\t\t\t\t    int num)\n{\n\tchar *str = NULL;\n\n\tswitch (get_column_id(num)) {\n\tcase COL_ACTION:\n\t\tswitch (change) {\n\t\tcase MNT_TABDIFF_MOUNT:\n\t\t\tstr = _(\"mount\");\n\t\t\tbreak;\n\t\tcase MNT_TABDIFF_UMOUNT:\n\t\t\tstr = _(\"umount\");\n\t\t\tbreak;\n\t\tcase MNT_TABDIFF_REMOUNT:\n\t\t\tstr = _(\"remount\");\n\t\t\tbreak;\n\t\tcase MNT_TABDIFF_MOVE:\n\t\t\tstr = _(\"move\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstr = _(\"unknown\");\n\t\t\tbreak;\n\t\t}\n\t\tstr = xstrdup(str);\n\t\tbreak;\n\tcase COL_OLD_OPTIONS:\n\t\tif (old_fs && (change == MNT_TABDIFF_REMOUNT ||\n\t\t\t       change == MNT_TABDIFF_UMOUNT)\n\t\t           && mnt_fs_get_options(old_fs))\n\t\t\tstr = xstrdup(mnt_fs_get_options(old_fs));\n\t\tbreak;\n\tcase COL_OLD_TARGET:\n\t\tif (old_fs && (change == MNT_TABDIFF_MOVE ||\n\t\t\t       change == MNT_TABDIFF_UMOUNT)\n\t\t\t   && mnt_fs_get_target(old_fs))\n\t\t\tstr = xstrdup(mnt_fs_get_target(old_fs));\n\t\tbreak;\n\tdefault:\n\t\tif (new_fs)\n\t\t\tstr = get_data(new_fs, num);\n\t\telse\n\t\t\tstr = get_data(old_fs, num);\n\t\tbreak;\n\t}\n\treturn str;\n}\n\n/* adds one line to the output @tab */\nstatic struct libscols_line *add_line(struct libscols_table *table, struct libmnt_fs *fs,\n\t\t\t\t\tstruct libscols_line *parent)\n{\n\tsize_t i;\n\tstruct libscols_line *line = scols_table_new_line(table, parent);\n\n\tif (!line)\n\t\terr(EXIT_FAILURE, _(\"failed to allocate output line\"));\n\n\tfor (i = 0; i < ncolumns; i++) {\n\t\tif (scols_line_refer_data(line, i, get_data(fs, i)))\n\t\t\terr(EXIT_FAILURE, _(\"failed to add output data\"));\n\t}\n\n\tscols_line_set_userdata(line, fs);\n\treturn line;\n}\n\nstatic struct libscols_line *add_tabdiff_line(struct libscols_table *table, struct libmnt_fs *new_fs,\n\t\t\tstruct libmnt_fs *old_fs, int change)\n{\n\tsize_t i;\n\tstruct libscols_line *line = scols_table_new_line(table, NULL);\n\n\tif (!line)\n\t\terr(EXIT_FAILURE, _(\"failed to allocate output line\"));\n\n\tfor (i = 0; i < ncolumns; i++) {\n\t\tif (scols_line_refer_data(line, i,\n\t\t\t\tget_tabdiff_data(old_fs, new_fs, change, i)))\n\t\t\terr(EXIT_FAILURE, _(\"failed to add output data\"));\n\t}\n\n\treturn line;\n}\n\nstatic int has_line(struct libscols_table *table, struct libmnt_fs *fs)\n{\n\tstruct libscols_line *ln;\n\tstruct libscols_iter *itr;\n\tint rc = 0;\n\n\titr = scols_new_iter(SCOLS_ITER_FORWARD);\n\tif (!itr)\n\t\treturn 0;\n\n\twhile (scols_table_next_line(table, itr, &ln) == 0) {\n\t\tif ((struct libmnt_fs *) scols_line_get_userdata(ln) == fs) {\n\t\t\trc = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tscols_free_iter(itr);\n\treturn rc;\n}\n\n/* reads filesystems from @tb (libmount) and fillin @table (output table) */\nstatic int create_treenode(struct libscols_table *table, struct libmnt_table *tb,\n\t\t\t   struct libmnt_fs *fs, struct libscols_line *parent_line)\n{\n\tstruct libmnt_fs *chld = NULL;\n\tstruct libmnt_iter *itr = NULL;\n\tstruct libscols_line *line;\n\tint rc = -1, first = 0;\n\n\tif (!fs) {\n\t\t/* first call, get root FS */\n\t\tif (mnt_table_get_root_fs(tb, &fs))\n\t\t\tgoto leave;\n\t\tparent_line = NULL;\n\t\tfirst = 1;\n\n\t} else if ((flags & FL_SUBMOUNTS) && has_line(table, fs))\n\t\treturn 0;\n\n\titr = mnt_new_iter(MNT_ITER_FORWARD);\n\tif (!itr)\n\t\tgoto leave;\n\n\tif ((flags & FL_SUBMOUNTS) || match_func(fs, NULL)) {\n\t\tline = add_line(table, fs, parent_line);\n\t\tif (!line)\n\t\t\tgoto leave;\n\t} else\n\t\tline = parent_line;\n\n\t/*\n\t * add all children to the output table\n\t */\n\twhile (mnt_table_next_child_fs(tb, itr, fs, &chld) == 0) {\n\t\tif (create_treenode(table, tb, chld, line))\n\t\t\tgoto leave;\n\t}\n\trc = 0;\n\n\t/* make sure all entries are in the tree */\n\tif (first && (size_t) mnt_table_get_nents(tb) >\n\t\t     (size_t) scols_table_get_nlines(table)) {\n\t\tmnt_reset_iter(itr, MNT_ITER_FORWARD);\n\t\tfs = NULL;\n\n\t\twhile (mnt_table_next_fs(tb, itr, &fs) == 0) {\n\t\t\tif (!has_line(table, fs) && match_func(fs, NULL))\n\t\t\t\tcreate_treenode(table, tb, fs, NULL);\n\t\t}\n\t}\nleave:\n\tmnt_free_iter(itr);\n\treturn rc;\n}\n\n/* error callback */\nstatic int parser_errcb(struct libmnt_table *tb __attribute__ ((__unused__)),\n\t\t\tconst char *filename, int line)\n{\n\twarnx(_(\"%s: parse error at line %d -- ignored\"), filename, line);\n\t++parse_nerrors;\n\treturn 1;\n}\n\nstatic char **append_tabfile(char **files, int *nfiles, char *filename)\n{\n\tfiles = xrealloc(files, sizeof(char *) * (*nfiles + 1));\n\tfiles[(*nfiles)++] = filename;\n\treturn files;\n}\n\nstatic char **append_pid_tabfile(char **files, int *nfiles, pid_t pid)\n{\n\tchar *path = NULL;\n\n\txasprintf(&path, \"/proc/%d/mountinfo\", (int) pid);\n\treturn append_tabfile(files, nfiles, path);\n}\n\n/* calls libmount fstab/mtab/mountinfo parser */\nstatic struct libmnt_table *parse_tabfiles(char **files,\n\t\t\t\t\t   int nfiles,\n\t\t\t\t\t   int tabtype)\n{\n\tstruct libmnt_table *tb;\n\tint rc = 0;\n\n\ttb = mnt_new_table();\n\tif (!tb) {\n\t\twarn(_(\"failed to initialize libmount table\"));\n\t\treturn NULL;\n\t}\n\tmnt_table_set_parser_errcb(tb, parser_errcb);\n\n\tdo {\n\t\t/* NULL means that libmount will use default paths */\n\t\tconst char *path = nfiles ? *files++ : NULL;\n\n\t\tswitch (tabtype) {\n\t\tcase TABTYPE_FSTAB:\n\t\t\trc = mnt_table_parse_fstab(tb, path);\n\t\t\tbreak;\n\t\tcase TABTYPE_MTAB:\n\t\t\trc = mnt_table_parse_mtab(tb, path);\n\t\t\tbreak;\n\t\tcase TABTYPE_KERNEL:\n\t\t\tif (!path)\n\t\t\t\tpath = access(_PATH_PROC_MOUNTINFO, R_OK) == 0 ?\n\t\t\t\t\t      _PATH_PROC_MOUNTINFO :\n\t\t\t\t\t      _PATH_PROC_MOUNTS;\n\n\t\t\trc = mnt_table_parse_file(tb, path);\n\t\t\tbreak;\n\t\t}\n\t\tif (rc) {\n\t\t\tmnt_unref_table(tb);\n\t\t\twarn(_(\"can't read %s\"), path);\n\t\t\treturn NULL;\n\t\t}\n\t} while (--nfiles > 0);\n\n\treturn tb;\n}\n\n/*\n * Parses mountinfo and calls mnt_cache_set_targets(cache, mtab). Only\n * necessary if @tb in main() was read from a non-kernel source.\n */\nstatic void cache_set_targets(struct libmnt_cache *tmp)\n{\n\tstruct libmnt_table *tb;\n\tconst char *path;\n\n\ttb = mnt_new_table();\n\tif (!tb)\n\t\treturn;\n\n\tpath = access(_PATH_PROC_MOUNTINFO, R_OK) == 0 ?\n\t\t_PATH_PROC_MOUNTINFO :\n\t\t_PATH_PROC_MOUNTS;\n\n\tif (mnt_table_parse_file(tb, path) == 0)\n\t\tmnt_cache_set_targets(tmp, tb);\n\n\tmnt_unref_table(tb);\n}\n\n/* checks if @tb contains parent->child relations */\nstatic int tab_is_tree(struct libmnt_table *tb)\n{\n\tstruct libmnt_fs *fs = NULL;\n\tstruct libmnt_iter *itr;\n\tint rc = 0;\n\n\titr = mnt_new_iter(MNT_ITER_BACKWARD);\n\tif (!itr)\n\t\treturn 0;\n\n\trc = (mnt_table_next_fs(tb, itr, &fs) == 0 &&\n\t      mnt_fs_is_kernel(fs) &&\n\t      mnt_fs_get_root(fs));\n\n\tmnt_free_iter(itr);\n\treturn rc;\n}\n\n/* checks if all fs in @tb are from kernel */\nstatic int tab_is_kernel(struct libmnt_table *tb)\n{\n\tstruct libmnt_fs *fs = NULL;\n\tstruct libmnt_iter *itr;\n\n\titr = mnt_new_iter(MNT_ITER_BACKWARD);\n\tif (!itr)\n\t\treturn 0;\n\n\twhile (mnt_table_next_fs(tb, itr, &fs) == 0) {\n\t\tif (!mnt_fs_is_kernel(fs)) {\n\t\t\tmnt_free_iter(itr);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tmnt_free_iter(itr);\n\treturn 1;\n}\n\n/* filter function for libmount (mnt_table_find_next_fs()) */\nstatic int match_func(struct libmnt_fs *fs,\n\t\t      void *data __attribute__ ((__unused__)))\n{\n\tint rc = flags & FL_INVERT ? 1 : 0;\n\tconst char *m;\n\tvoid *md;\n\n\tm = get_match(COL_FSTYPE);\n\tif (m && !mnt_fs_match_fstype(fs, m))\n\t\treturn rc;\n\n\tm = get_match(COL_OPTIONS);\n\tif (m && !mnt_fs_match_options(fs, m))\n\t\treturn rc;\n\n\tmd = get_match_data(COL_MAJMIN);\n\tif (md && mnt_fs_get_devno(fs) != *((dev_t *) md))\n\t\treturn rc;\n\n\tm = get_match(COL_TARGET);\n\tif (m && !mnt_fs_match_target(fs, m, cache))\n\t\treturn rc;\n\n\tm = get_match(COL_SOURCE);\n\tif (m && !mnt_fs_match_source(fs, m, cache))\n\t\treturn rc;\n\n\tif ((flags & FL_DF) && !(flags & FL_ALL)) {\n\t\tconst char *type = mnt_fs_get_fstype(fs);\n\n\t\tif (type && strstr(type, \"tmpfs\"))\t/* tmpfs is wanted */\n\t\t\treturn !rc;\n\n\t\tif (mnt_fs_is_pseudofs(fs))\n\t\t\treturn rc;\n\t}\n\n\tif ((flags & FL_REAL) && mnt_fs_is_pseudofs(fs))\n\t    return rc;\n\n\tif ((flags & FL_PSEUDO) && !mnt_fs_is_pseudofs(fs))\n\t    return rc;\n\n\tif ((flags & FL_SHADOWED)) {\n\t\tstruct libmnt_table *tb = NULL;\n\n\t\tmnt_fs_get_table(fs, &tb);\n\t\tif (tb && mnt_table_over_fs(tb, fs, NULL) != 0)\n\t\t\treturn rc;\n\t}\n\n\treturn !rc;\n}\n\n/* iterate over filesystems in @tb */\nstruct libmnt_fs *get_next_fs(struct libmnt_table *tb,\n\t\t\t\t     struct libmnt_iter *itr)\n{\n\tstruct libmnt_fs *fs = NULL;\n\n\tif (is_listall_mode()) {\n\t\t/*\n\t\t * Print whole file\n\t\t */\n\t\tif (mnt_table_next_fs(tb, itr, &fs) != 0)\n\t\t\treturn NULL;\n\n\t} else if (is_mount_compatible_mode()) {\n\t\t/*\n\t\t * Look up for FS in the same way how mount(8) searches in fstab\n\t\t *\n\t\t *   findmnt -f <spec>\n\t\t */\n\t\tfs = mnt_table_find_source(tb, get_match(COL_SOURCE),\n\t\t\t\t\tmnt_iter_get_direction(itr));\n\n\t\tif (!fs && !(flags & FL_NOSWAPMATCH))\n\t\t\tfs = mnt_table_find_target(tb, get_match(COL_SOURCE),\n\t\t\t\t\tmnt_iter_get_direction(itr));\n\t} else {\n\t\t/*\n\t\t * Look up for all matching entries\n\t\t *\n\t\t *    findmnt [-l] <source> <target> [-O <options>] [-t <types>]\n\t\t *    findmnt [-l] <spec> [-O <options>] [-t <types>]\n\t\t */\nagain:\n\t\tif (mnt_table_find_next_fs(tb, itr, match_func,  NULL, &fs) != 0)\n\t\t\tfs = NULL;\n\n\t\tif (!fs &&\n\t\t    !(flags & FL_NOSWAPMATCH) &&\n\t\t    !get_match(COL_TARGET) && get_match(COL_SOURCE)) {\n\n\t\t\t/* swap 'spec' and target. */\n\t\t\tset_match(COL_TARGET, get_match(COL_SOURCE));\n\t\t\tset_match(COL_SOURCE, NULL);\n\t\t\tmnt_reset_iter(itr, -1);\n\n\t\t\tgoto again;\n\t\t}\n\t}\n\n\treturn fs;\n}\n\n/*\n * Filter out unwanted lines for --list output or top level lines for\n * --submounts tree output.\n */\nstatic int add_matching_lines(struct libmnt_table *tb,\n\t\t\t      struct libscols_table *table, int direction)\n{\n\tstruct libmnt_iter *itr;\n\tstruct libmnt_fs *fs;\n\tint nlines = 0, rc = -1;\n\n\titr = mnt_new_iter(direction);\n\tif (!itr) {\n\t\twarn(_(\"failed to initialize libmount iterator\"));\n\t\tgoto done;\n\t}\n\n\twhile((fs = get_next_fs(tb, itr))) {\n\t\tif ((flags & FL_TREE) || (flags & FL_SUBMOUNTS))\n\t\t\trc = create_treenode(table, tb, fs, NULL);\n\t\telse\n\t\t\trc = !add_line(table, fs, NULL);\n\t\tif (rc)\n\t\t\tgoto done;\n\t\tnlines++;\n\t\tif (flags & FL_FIRSTONLY)\n\t\t\tbreak;\n\t\tflags |= FL_NOSWAPMATCH;\n\t}\n\n\tif (nlines)\n\t\trc = 0;\ndone:\n\tmnt_free_iter(itr);\n\treturn rc;\n}\n\nstatic int poll_match(struct libmnt_fs *fs)\n{\n\tint rc = match_func(fs, NULL);\n\n\tif (rc == 0 && !(flags & FL_NOSWAPMATCH) &&\n\t    get_match(COL_SOURCE) && !get_match(COL_TARGET)) {\n\t\t/*\n\t\t * findmnt --poll /foo\n\t\t * The '/foo' maybe source as well as target.\n\t\t */\n\t\tconst char *str = get_match(COL_SOURCE);\n\n\t\tset_match(COL_TARGET, str);\t/* swap */\n\t\tset_match(COL_SOURCE, NULL);\n\n\t\trc = match_func(fs, NULL);\n\n\t\tset_match(COL_TARGET, NULL);\t/* restore */\n\t\tset_match(COL_SOURCE, str);\n\n\t}\n\treturn rc;\n}\n\nstatic int poll_table(struct libmnt_table *tb, const char *tabfile,\n\t\t  int timeout, struct libscols_table *table, int direction)\n{\n\tFILE *f = NULL;\n\tint rc = -1;\n\tstruct libmnt_iter *itr = NULL;\n\tstruct libmnt_table *tb_new;\n\tstruct libmnt_tabdiff *diff = NULL;\n\tstruct pollfd fds[1];\n\n\ttb_new = mnt_new_table();\n\tif (!tb_new) {\n\t\twarn(_(\"failed to initialize libmount table\"));\n\t\tgoto done;\n\t}\n\n\titr = mnt_new_iter(direction);\n\tif (!itr) {\n\t\twarn(_(\"failed to initialize libmount iterator\"));\n\t\tgoto done;\n\t}\n\n\tdiff = mnt_new_tabdiff();\n\tif (!diff) {\n\t\twarn(_(\"failed to initialize libmount tabdiff\"));\n\t\tgoto done;\n\t}\n\n\t/* cache is unnecessary to detect changes */\n\tmnt_table_set_cache(tb, NULL);\n\tmnt_table_set_cache(tb_new, NULL);\n\n\tf = fopen(tabfile, \"r\");\n\tif (!f) {\n\t\twarn(_(\"cannot open %s\"), tabfile);\n\t\tgoto done;\n\t}\n\n\tmnt_table_set_parser_errcb(tb_new, parser_errcb);\n\n\tfds[0].fd = fileno(f);\n\tfds[0].events = POLLPRI;\n\n\twhile (1) {\n\t\tstruct libmnt_table *tmp;\n\t\tstruct libmnt_fs *old, *new;\n\t\tint change, count;\n\n\t\tcount = poll(fds, 1, timeout);\n\t\tif (count == 0)\n\t\t\tbreak;\t/* timeout */\n\t\tif (count < 0) {\n\t\t\twarn(_(\"poll() failed\"));\n\t\t\tgoto done;\n\t\t}\n\n\t\trewind(f);\n\t\trc = mnt_table_parse_stream(tb_new, f, tabfile);\n\t\tif (!rc)\n\t\t\trc = mnt_diff_tables(diff, tb, tb_new);\n\t\tif (rc < 0)\n\t\t\tgoto done;\n\n\t\tcount = 0;\n\t\tmnt_reset_iter(itr, direction);\n\t\twhile(mnt_tabdiff_next_change(\n\t\t\t\tdiff, itr, &old, &new, &change) == 0) {\n\n\t\t\tif (!has_poll_action(change))\n\t\t\t\tcontinue;\n\t\t\tif (!poll_match(new ? new : old))\n\t\t\t\tcontinue;\n\t\t\tcount++;\n\t\t\trc = !add_tabdiff_line(table, new, old, change);\n\t\t\tif (rc)\n\t\t\t\tgoto done;\n\t\t\tif (flags & FL_FIRSTONLY)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (count) {\n\t\t\trc = scols_table_print_range(table, NULL, NULL);\n\t\t\tif (rc == 0)\n\t\t\t\tfputc('\\n', scols_table_get_stream(table));\n\t\t\tfflush(stdout);\n\t\t\tif (rc)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\t/* swap tables */\n\t\ttmp = tb;\n\t\ttb = tb_new;\n\t\ttb_new = tmp;\n\n\t\t/* remove already printed lines to reduce memory usage */\n\t\tscols_table_remove_lines(table);\n\t\tmnt_reset_table(tb_new);\n\n\t\tif (count && (flags & FL_FIRSTONLY))\n\t\t\tbreak;\n\t}\n\n\trc = 0;\ndone:\n\tmnt_unref_table(tb_new);\n\tmnt_free_tabdiff(diff);\n\tmnt_free_iter(itr);\n\tif (f)\n\t\tfclose(f);\n\treturn rc;\n}\n\nstatic int uniq_fs_target_cmp(\n\t\tstruct libmnt_table *tb __attribute__((__unused__)),\n\t\tstruct libmnt_fs *a,\n\t\tstruct libmnt_fs *b)\n{\n\treturn !mnt_fs_match_target(a, mnt_fs_get_target(b), cache);\n}\n\nstatic void __attribute__((__noreturn__)) usage(void)\n{\n\tFILE *out = stdout;\n\tsize_t i;\n\n\tfputs(USAGE_HEADER, out);\n\tfprintf(out, _(\n\t\" %1$s [options]\\n\"\n\t\" %1$s [options] <device> | <mountpoint>\\n\"\n\t\" %1$s [options] <device> <mountpoint>\\n\"\n\t\" %1$s [options] [--source <device>] [--target <path> | --mountpoint <dir>]\\n\"),\n\t\tprogram_invocation_short_name);\n\n\tfputs(USAGE_SEPARATOR, out);\n\tfputs(_(\"Find a (mounted) filesystem.\\n\"), out);\n\n\tfputs(USAGE_OPTIONS, out);\n\tfputs(_(\" -s, --fstab            search in static table of filesystems\\n\"), out);\n\tfputs(_(\" -m, --mtab             search in table of mounted filesystems\\n\"\n\t\t\"                          (includes user space mount options)\\n\"), out);\n\tfputs(_(\" -k, --kernel           search in kernel table of mounted\\n\"\n\t\t\"                          filesystems (default)\\n\"), out);\n\tfputc('\\n', out);\n\tfputs(_(\" -p, --poll[=<list>]    monitor changes in table of mounted filesystems\\n\"), out);\n\tfputs(_(\" -w, --timeout <num>    upper limit in milliseconds that --poll will block\\n\"), out);\n\tfputc('\\n', out);\n\n\tfputs(_(\" -A, --all              disable all built-in filters, print all filesystems\\n\"), out);\n\tfputs(_(\" -a, --ascii            use ASCII chars for tree formatting\\n\"), out);\n\tfputs(_(\" -b, --bytes            print sizes in bytes rather than in human readable format\\n\"), out);\n\tfputs(_(\" -C, --nocanonicalize   don't canonicalize when comparing paths\\n\"), out);\n\tfputs(_(\" -c, --canonicalize     canonicalize printed paths\\n\"), out);\n\tfputs(_(\" -D, --df               imitate the output of df(1)\\n\"), out);\n\tfputs(_(\" -d, --direction <word> direction of search, 'forward' or 'backward'\\n\"), out);\n\tfputs(_(\" -e, --evaluate         convert tags (LABEL,UUID,PARTUUID,PARTLABEL) \\n\"\n\t        \"                          to device names\\n\"), out);\n\tfputs(_(\" -F, --tab-file <path>  alternative file for -s, -m or -k options\\n\"), out);\n\tfputs(_(\" -f, --first-only       print the first found filesystem only\\n\"), out);\n\tfputs(_(\" -i, --invert           invert the sense of matching\\n\"), out);\n\tfputs(_(\" -J, --json             use JSON output format\\n\"), out);\n\tfputs(_(\" -l, --list             use list format output\\n\"), out);\n\tfputs(_(\" -N, --task <tid>       use alternative namespace (/proc/<tid>/mountinfo file)\\n\"), out);\n\tfputs(_(\" -n, --noheadings       don't print column headings\\n\"), out);\n\tfputs(_(\" -O, --options <list>   limit the set of filesystems by mount options\\n\"), out);\n\tfputs(_(\" -o, --output <list>    the output columns to be shown\\n\"), out);\n\tfputs(_(\"     --output-all       output all available columns\\n\"), out);\n\tfputs(_(\" -P, --pairs            use key=\\\"value\\\" output format\\n\"), out);\n\tfputs(_(\"     --pseudo           print only pseudo-filesystems\\n\"), out);\n\tfputs(_(\"     --shadowed         print only filesystems over-mounted by another filesystem\\n\"), out);\n\tfputs(_(\" -R, --submounts        print all submounts for the matching filesystems\\n\"), out);\n\tfputs(_(\" -r, --raw              use raw output format\\n\"), out);\n\tfputs(_(\"     --real             print only real filesystems\\n\"), out);\n\tfputs(_(\" -S, --source <string>  the device to mount (by name, maj:min, \\n\"\n\t        \"                          LABEL=, UUID=, PARTUUID=, PARTLABEL=)\\n\"), out);\n\tfputs(_(\" -T, --target <path>    the path to the filesystem to use\\n\"), out);\n\tfputs(_(\"     --tree             enable tree format output if possible\\n\"), out);\n\tfputs(_(\" -M, --mountpoint <dir> the mountpoint directory\\n\"), out);\n\tfputs(_(\" -t, --types <list>     limit the set of filesystems by FS types\\n\"), out);\n\tfputs(_(\" -U, --uniq             ignore filesystems with duplicate target\\n\"), out);\n\tfputs(_(\" -u, --notruncate       don't truncate text in columns\\n\"), out);\n\tfputs(_(\" -v, --nofsroot         don't print [/dir] for bind or btrfs mounts\\n\"), out);\n\n\tfputc('\\n', out);\n\tfputs(_(\" -x, --verify           verify mount table content (default is fstab)\\n\"), out);\n\tfputs(_(\"     --verbose          print more details\\n\"), out);\n\tfputs(_(\"     --vfs-all          print all VFS options\\n\"), out);\n\n\tfputs(USAGE_SEPARATOR, out);\n\tprintf(USAGE_HELP_OPTIONS(24));\n\n\tfputs(USAGE_COLUMNS, out);\n\tfor (i = 0; i < ARRAY_SIZE(infos); i++)\n\t\tfprintf(out, \" %11s  %s\\n\", infos[i].name, _(infos[i].help));\n\n\tprintf(USAGE_MAN_TAIL(\"findmnt(8)\"));\n\n\texit(EXIT_SUCCESS);\n}\n\nint main(int argc, char *argv[])\n{\n\tstruct libmnt_table *tb = NULL;\n\tchar **tabfiles = NULL;\n\tint direction = MNT_ITER_FORWARD;\n\tint verify = 0;\n\tint c, rc = -1, timeout = -1;\n\tint ntabfiles = 0, tabtype = 0;\n\tchar *outarg = NULL;\n\tsize_t i;\n\tint force_tree = 0, istree = 0;\n\n\tstruct libscols_table *table = NULL;\n\n\tenum {\n\t\tFINDMNT_OPT_VERBOSE = CHAR_MAX + 1,\n\t\tFINDMNT_OPT_TREE,\n\t\tFINDMNT_OPT_OUTPUT_ALL,\n\t\tFINDMNT_OPT_PSEUDO,\n\t\tFINDMNT_OPT_REAL,\n\t\tFINDMNT_OPT_VFS_ALL,\n\t\tFINDMNT_OPT_SHADOWED\n\t};\n\n\tstatic const struct option longopts[] = {\n\t\t{ \"all\",\t    no_argument,       NULL, 'A'\t\t },\n\t\t{ \"ascii\",\t    no_argument,       NULL, 'a'\t\t },\n\t\t{ \"bytes\",\t    no_argument,       NULL, 'b'\t\t },\n\t\t{ \"canonicalize\",   no_argument,       NULL, 'c'\t\t },\n\t\t{ \"direction\",\t    required_argument, NULL, 'd'\t\t },\n\t\t{ \"df\",\t\t    no_argument,       NULL, 'D'\t\t },\n\t\t{ \"evaluate\",\t    no_argument,       NULL, 'e'\t\t },\n\t\t{ \"first-only\",\t    no_argument,       NULL, 'f'\t\t },\n\t\t{ \"fstab\",\t    no_argument,       NULL, 's'\t\t },\n\t\t{ \"help\",\t    no_argument,       NULL, 'h'\t\t },\n\t\t{ \"invert\",\t    no_argument,       NULL, 'i'\t\t },\n\t\t{ \"json\",\t    no_argument,       NULL, 'J'\t\t },\n\t\t{ \"kernel\",\t    no_argument,       NULL, 'k'\t\t },\n\t\t{ \"list\",\t    no_argument,       NULL, 'l'\t\t },\n\t\t{ \"mountpoint\",\t    required_argument, NULL, 'M'\t\t },\n\t\t{ \"mtab\",\t    no_argument,       NULL, 'm'\t\t },\n\t\t{ \"noheadings\",\t    no_argument,       NULL, 'n'\t\t },\n\t\t{ \"notruncate\",\t    no_argument,       NULL, 'u'\t\t },\n\t\t{ \"options\",\t    required_argument, NULL, 'O'\t\t },\n\t\t{ \"output\",\t    required_argument, NULL, 'o'\t\t },\n\t\t{ \"output-all\",\t    no_argument,       NULL, FINDMNT_OPT_OUTPUT_ALL },\n\t\t{ \"poll\",\t    optional_argument, NULL, 'p'\t\t },\n\t\t{ \"pairs\",\t    no_argument,       NULL, 'P'\t\t },\n\t\t{ \"raw\",\t    no_argument,       NULL, 'r'\t\t },\n\t\t{ \"types\",\t    required_argument, NULL, 't'\t\t },\n\t\t{ \"nocanonicalize\", no_argument,       NULL, 'C'\t\t },\n\t\t{ \"nofsroot\",\t    no_argument,       NULL, 'v'\t\t },\n\t\t{ \"submounts\",\t    no_argument,       NULL, 'R'\t\t },\n\t\t{ \"source\",\t    required_argument, NULL, 'S'\t\t },\n\t\t{ \"tab-file\",\t    required_argument, NULL, 'F'\t\t },\n\t\t{ \"task\",\t    required_argument, NULL, 'N'\t\t },\n\t\t{ \"target\",\t    required_argument, NULL, 'T'\t\t },\n\t\t{ \"timeout\",\t    required_argument, NULL, 'w'\t\t },\n\t\t{ \"uniq\",\t    no_argument,       NULL, 'U'\t\t },\n\t\t{ \"verify\",\t    no_argument,       NULL, 'x'\t\t },\n\t\t{ \"version\",\t    no_argument,       NULL, 'V'\t\t },\n\t\t{ \"verbose\",\t    no_argument,       NULL, FINDMNT_OPT_VERBOSE },\n\t\t{ \"tree\",\t    no_argument,       NULL, FINDMNT_OPT_TREE\t },\n\t\t{ \"real\",\t    no_argument,       NULL, FINDMNT_OPT_REAL\t },\n\t\t{ \"pseudo\",\t    no_argument,       NULL, FINDMNT_OPT_PSEUDO\t },\n\t\t{ \"vfs-all\",\t    no_argument,       NULL, FINDMNT_OPT_VFS_ALL },\n\t\t{ \"shadowed\",       no_argument,       NULL, FINDMNT_OPT_SHADOWED },\n\t\t{ NULL, 0, NULL, 0 }\n\t};\n\n\tstatic const ul_excl_t excl[] = {\t/* rows and cols in ASCII order */\n\t\t{ 'C', 'c'},\t\t\t/* [no]canonicalize */\n\t\t{ 'C', 'e' },\t\t\t/* nocanonicalize, evaluate */\n\t\t{ 'J', 'P', 'r','x' },\t\t/* json,pairs,raw,verify */\n\t\t{ 'M', 'T' },\t\t\t/* mountpoint, target */\n\t\t{ 'N','k','m','s' },\t\t/* task,kernel,mtab,fstab */\n\t\t{ 'P','l','r','x' },\t\t/* pairs,list,raw,verify */\n\t\t{ 'p','x' },\t\t\t/* poll,verify */\n\t\t{ 'm','p','s' },\t\t/* mtab,poll,fstab */\n\t\t{ FINDMNT_OPT_PSEUDO, FINDMNT_OPT_REAL },\n\t\t{ 0 }\n\t};\n\tint excl_st[ARRAY_SIZE(excl)] = UL_EXCL_STATUS_INIT;\n\n\tsetlocale(LC_ALL, \"\");\n\tbindtextdomain(PACKAGE, LOCALEDIR);\n\ttextdomain(PACKAGE);\n\tclose_stdout_atexit();\n\n\t/* default output format */\n\tflags |= FL_TREE;\n\n\twhile ((c = getopt_long(argc, argv,\n\t\t\t\t\"AabCcDd:ehiJfF:o:O:p::PklmM:nN:rst:uvRS:T:Uw:Vx\",\n\t\t\t\tlongopts, NULL)) != -1) {\n\n\t\terr_exclusive_options(c, longopts, excl, excl_st);\n\n\t\tswitch(c) {\n\t\tcase 'A':\n\t\t\tflags |= FL_ALL;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tflags |= FL_ASCII;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tflags |= FL_BYTES;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tflags |= FL_NOCACHE;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tflags |= FL_CANONICALIZE;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tflags &= ~FL_TREE;\n\t\t\tflags |= FL_DF;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tif (!strcmp(optarg, \"forward\"))\n\t\t\t\tdirection = MNT_ITER_FORWARD;\n\t\t\telse if (!strcmp(optarg, \"backward\"))\n\t\t\t\tdirection = MNT_ITER_BACKWARD;\n\t\t\telse\n\t\t\t\terrx(EXIT_FAILURE,\n\t\t\t\t\t_(\"unknown direction '%s'\"), optarg);\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tflags |= FL_EVALUATE;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tflags |= FL_INVERT;\n\t\t\tbreak;\n\t\tcase 'J':\n\t\t\tflags |= FL_JSON;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tflags |= FL_FIRSTONLY;\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\ttabfiles = append_tabfile(tabfiles, &ntabfiles, optarg);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tdisable_columns_truncate();\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\toutarg = optarg;\n\t\t\tbreak;\n\t\tcase FINDMNT_OPT_OUTPUT_ALL:\n\t\t\tfor (ncolumns = 0; ncolumns < ARRAY_SIZE(infos); ncolumns++) {\n\t\t\t\tif (is_tabdiff_column(ncolumns))\n\t\t\t\t\tcontinue;\n\t\t\t\tcolumns[ncolumns] = ncolumns;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tset_match(COL_OPTIONS, optarg);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tif (optarg) {\n\t\t\t\tnactions = string_to_idarray(optarg,\n\t\t\t\t\t\tactions, ARRAY_SIZE(actions),\n\t\t\t\t\t\tpoll_action_name_to_id);\n\t\t\t\tif (nactions < 0)\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\tflags |= FL_POLL;\n\t\t\tflags &= ~FL_TREE;\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tflags |= FL_EXPORT;\n\t\t\tflags &= ~FL_TREE;\n\t\t\tbreak;\n\t\tcase 'm':\t\t/* mtab */\n\t\t\ttabtype = TABTYPE_MTAB;\n\t\t\tflags &= ~FL_TREE;\n\t\t\tbreak;\n\t\tcase 's':\t\t/* fstab */\n\t\t\ttabtype = TABTYPE_FSTAB;\n\t\t\tflags &= ~FL_TREE;\n\t\t\tbreak;\n\t\tcase 'k':\t\t/* kernel (mountinfo) */\n\t\t\ttabtype = TABTYPE_KERNEL;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tset_match(COL_FSTYPE, optarg);\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tflags &= ~FL_TREE;\t/* disable the default */\n\t\t\tflags |= FL_RAW;\t/* enable raw */\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tflags &= ~FL_TREE;\t/* disable the default */\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tflags |= FL_NOHEADINGS;\n\t\t\tbreak;\n\t\tcase 'N':\n\t\t\ttabtype = TABTYPE_KERNEL;\n\t\t\ttabfiles = append_pid_tabfile(tabfiles, &ntabfiles,\n\t\t\t\t\tstrtou32_or_err(optarg,\n\t\t\t\t\t\t_(\"invalid TID argument\")));\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tflags |= FL_NOFSROOT;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tflags |= FL_SUBMOUNTS;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tset_source_match(optarg);\n\t\t\tflags |= FL_NOSWAPMATCH;\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\tflags |= FL_STRICTTARGET;\n\t\t\t/* fallthrough */\n\t\tcase 'T':\n\t\t\tset_match(COL_TARGET, optarg);\n\t\t\tflags |= FL_NOSWAPMATCH;\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\tflags |= FL_UNIQ;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\ttimeout = strtos32_or_err(optarg, _(\"invalid timeout argument\"));\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\tverify = 1;\n\t\t\tbreak;\n\t\tcase FINDMNT_OPT_VERBOSE:\n\t\t\tflags |= FL_VERBOSE;\n\t\t\tbreak;\n\t\tcase FINDMNT_OPT_TREE:\n\t\t\tforce_tree = 1;\n\t\t\tbreak;\n\t\tcase FINDMNT_OPT_PSEUDO:\n\t\t\tflags |= FL_PSEUDO;\n\t\t\tbreak;\n\t\tcase FINDMNT_OPT_REAL:\n\t\t\tflags |= FL_REAL;\n\t\t\tbreak;\n\t\tcase FINDMNT_OPT_VFS_ALL:\n\t\t\tflags |= FL_VFS_ALL;\n\t\t\tbreak;\n\t\tcase FINDMNT_OPT_SHADOWED:\n\t\t\tflags |= FL_SHADOWED;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage();\n\t\tcase 'V':\n\t\t\tprint_version(EXIT_SUCCESS);\n\t\tdefault:\n\t\t\terrtryhelp(EXIT_FAILURE);\n\t\t}\n\t}\n\n\tif (!ncolumns && (flags & FL_DF)) {\n\t\tadd_column(columns, ncolumns++, COL_SOURCE);\n\t\tadd_column(columns, ncolumns++, COL_FSTYPE);\n\t\tadd_column(columns, ncolumns++, COL_SIZE);\n\t\tadd_column(columns, ncolumns++, COL_USED);\n\t\tadd_column(columns, ncolumns++, COL_AVAIL);\n\t\tadd_column(columns, ncolumns++, COL_USEPERC);\n\t\tadd_column(columns, ncolumns++, COL_TARGET);\n\t}\n\n\t/* default columns */\n\tif (!ncolumns) {\n\t\tif (flags & FL_POLL)\n\t\t\tadd_column(columns, ncolumns++, COL_ACTION);\n\n\t\tadd_column(columns, ncolumns++, COL_TARGET);\n\t\tadd_column(columns, ncolumns++, COL_SOURCE);\n\t\tadd_column(columns, ncolumns++, COL_FSTYPE);\n\t\tadd_column(columns, ncolumns++, COL_OPTIONS);\n\t}\n\n\tif (outarg && string_add_to_idarray(outarg, columns, ARRAY_SIZE(columns),\n\t\t\t\t\t &ncolumns, column_name_to_id) < 0)\n\t\treturn EXIT_FAILURE;\n\n\tif (!tabtype)\n\t\ttabtype = verify ? TABTYPE_FSTAB : TABTYPE_KERNEL;\n\n\tif ((flags & FL_POLL) && ntabfiles > 1)\n\t\terrx(EXIT_FAILURE, _(\"--poll accepts only one file, but more specified by --tab-file\"));\n\n\tif (optind < argc && (get_match(COL_SOURCE) || get_match(COL_TARGET)))\n\t\terrx(EXIT_FAILURE, _(\n\t\t\t\"options --target and --source can't be used together \"\n\t\t\t\"with command line element that is not an option\"));\n\n\tif (optind < argc)\n\t\tset_source_match(argv[optind++]);\t/* dev/tag/mountpoint/maj:min */\n\tif (optind < argc)\n\t\tset_match(COL_TARGET, argv[optind++]);\t/* mountpoint */\n\n\tif ((flags & FL_SUBMOUNTS) && is_listall_mode())\n\t\t/* don't care about submounts if list all mounts */\n\t\tflags &= ~FL_SUBMOUNTS;\n\n\tif (!(flags & FL_SUBMOUNTS) && ((flags & FL_FIRSTONLY)\n\t    || get_match(COL_TARGET)\n\t    || get_match(COL_SOURCE)\n\t    || get_match(COL_MAJMIN)))\n\t\tflags &= ~FL_TREE;\n\n\tif (!(flags & FL_NOSWAPMATCH) &&\n\t    !get_match(COL_TARGET) && get_match(COL_SOURCE)) {\n\t\t/*\n\t\t * Check if we can swap source and target, it's\n\t\t * not possible if the source is LABEL=/UUID=\n\t\t */\n\t\tconst char *x = get_match(COL_SOURCE);\n\n\t\tif (!strncmp(x, \"LABEL=\", 6) || !strncmp(x, \"UUID=\", 5) ||\n\t\t    !strncmp(x, \"PARTLABEL=\", 10) || !strncmp(x, \"PARTUUID=\", 9))\n\t\t\tflags |= FL_NOSWAPMATCH;\n\t}\n\n\t/*\n\t * initialize libmount\n\t */\n\tmnt_init_debug(0);\n\n\ttb = parse_tabfiles(tabfiles, ntabfiles, tabtype);\n\tif (!tb)\n\t\tgoto leave;\n\n\tif (tabtype == TABTYPE_MTAB && tab_is_kernel(tb))\n\t\ttabtype = TABTYPE_KERNEL;\n\n\tistree = tab_is_tree(tb);\n\tif (istree && force_tree)\n\t\tflags |= FL_TREE;\n\n\tif ((flags & FL_TREE) && (ntabfiles > 1 || !istree))\n\t\tflags &= ~FL_TREE;\n\n\tif (!(flags & FL_NOCACHE)) {\n\t\tcache = mnt_new_cache();\n\t\tif (!cache) {\n\t\t\twarn(_(\"failed to initialize libmount cache\"));\n\t\t\tgoto leave;\n\t\t}\n\t\tmnt_table_set_cache(tb, cache);\n\n\t\tif (tabtype != TABTYPE_KERNEL)\n\t\t\tcache_set_targets(cache);\n\t}\n\n\tif (flags & FL_UNIQ)\n\t\tmnt_table_uniq_fs(tb, MNT_UNIQ_KEEPTREE, uniq_fs_target_cmp);\n\n\tif (verify) {\n\t\trc = verify_table(tb);\n\t\tgoto leave;\n\t}\n\n\t/*\n\t * initialize libsmartcols\n\t */\n\tscols_init_debug(0);\n\ttable = scols_new_table();\n\tif (!table) {\n\t\twarn(_(\"failed to allocate output table\"));\n\t\tgoto leave;\n\t}\n\tscols_table_enable_raw(table,        !!(flags & FL_RAW));\n\tscols_table_enable_export(table,     !!(flags & FL_EXPORT));\n\tscols_table_enable_json(table,       !!(flags & FL_JSON));\n\tscols_table_enable_ascii(table,      !!(flags & FL_ASCII));\n\tscols_table_enable_noheadings(table, !!(flags & FL_NOHEADINGS));\n\n\tif (flags & FL_JSON)\n\t\tscols_table_set_name(table, \"filesystems\");\n\n\tfor (i = 0; i < ncolumns; i++) {\n\t\tstruct libscols_column *cl;\n\t\tint fl = get_column_flags(i);\n\t\tint id = get_column_id(i);\n\n\t\tif (!(flags & FL_TREE))\n\t\t\tfl &= ~SCOLS_FL_TREE;\n\n\t\tif (!(flags & FL_POLL) && is_tabdiff_column(id)) {\n\t\t\twarnx(_(\"%s column is requested, but --poll \"\n\t\t\t       \"is not enabled\"), get_column_name(i));\n\t\t\tgoto leave;\n\t\t}\n\t\tcl = scols_table_new_column(table, get_column_name(i),\n\t\t\t\t\tget_column_whint(i), fl);\n\t\tif (!cl)\t{\n\t\t\twarn(_(\"failed to allocate output column\"));\n\t\t\tgoto leave;\n\t\t}\n\t\t/* multi-line cells (now used for SOURCES) */\n\t\tif (fl & SCOLS_FL_WRAP) {\n\t\t\tscols_column_set_wrapfunc(cl,\n\t\t\t\t\t\tscols_wrapnl_chunksize,\n\t\t\t\t\t\tscols_wrapnl_nextchunk,\n\t\t\t\t\t\tNULL);\n\t\t\tscols_column_set_safechars(cl, \"\\n\");\n\t\t}\n\t\tif (flags & FL_JSON) {\n\t\t\tswitch (id) {\n\t\t\tcase COL_SIZE:\n\t\t\tcase COL_AVAIL:\n\t\t\tcase COL_USED:\n\t\t\t\tif (!(flags & FL_BYTES))\n\t\t\t\t\tbreak;\n\t\t\t\t/* fallthrough */\n\t\t\tcase COL_ID:\n\t\t\tcase COL_PARENT:\n\t\t\tcase COL_FREQ:\n\t\t\tcase COL_PASSNO:\n\t\t\tcase COL_TID:\n\t\t\t\tscols_column_set_json_type(cl, SCOLS_JSON_NUMBER);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (fl & SCOLS_FL_WRAP)\n\t\t\t\t\tscols_column_set_json_type(cl, SCOLS_JSON_ARRAY_STRING);\n\t\t\t\telse\n\t\t\t\t\tscols_column_set_json_type(cl, SCOLS_JSON_STRING);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Fill in data to the output table\n\t */\n\tif (flags & FL_POLL) {\n\t\t/* poll mode (accept the first tabfile only) */\n\t\trc = poll_table(tb, tabfiles ? *tabfiles : _PATH_PROC_MOUNTINFO, timeout, table, direction);\n\n\t} else if ((flags & FL_TREE) && !(flags & FL_SUBMOUNTS)) {\n\t\t/* whole tree */\n\t\trc = create_treenode(table, tb, NULL, NULL);\n\t} else {\n\t\t/* whole list of sub-tree */\n\t\trc = add_matching_lines(tb, table, direction);\n\n\t\tif (rc != 0\n\t\t    && tabtype == TABTYPE_KERNEL\n\t\t    && (flags & FL_NOSWAPMATCH)\n\t\t    && !(flags & FL_STRICTTARGET)\n\t\t    && get_match(COL_TARGET)) {\n\t\t\t/*\n\t\t\t * Found nothing, maybe the --target is regular file,\n\t\t\t * try it again with extra functionality for target\n\t\t\t * match\n\t\t\t */\n\t\t\tenable_extra_target_match(tb);\n\t\t\trc = add_matching_lines(tb, table, direction);\n\t\t}\n\t}\n\n\t/*\n\t * Print the output table for non-poll modes\n\t */\n\tif (!rc && !(flags & FL_POLL))\n\t\tscols_print_table(table);\nleave:\n\tscols_unref_table(table);\n\n\tmnt_unref_table(tb);\n\tmnt_unref_cache(cache);\n\n\tfree(tabfiles);\n#ifdef HAVE_LIBUDEV\n\tudev_unref(udev);\n#endif\n\treturn rc ? EXIT_FAILURE : EXIT_SUCCESS;\n}\n"], "filenames": ["libmount/docs/libmount-sections.txt", "libmount/src/fs.c", "libmount/src/libmount.h.in", "libmount/src/libmount.sym", "libmount/src/mountP.h", "libmount/src/tab_parse.c", "misc-utils/findmnt.c"], "buggy_code_start_loc": [249, 652, 515, 368, 231, 228, 58], "buggy_code_end_loc": [250, 663, 516, 369, 232, 235, 1782], "fixing_code_start_loc": [248, 651, 514, 367, 230, 227, 57], "fixing_code_end_loc": [248, 651, 514, 367, 230, 227, 1764], "type": "CWE-552", "message": "A logic error was found in the libmount library of util-linux in the function that allows an unprivileged user to unmount a FUSE filesystem. This flaw allows a local user on a vulnerable system to unmount other users' filesystems that are either world-writable themselves (like /tmp) or mounted in a world-writable directory. An attacker may use this flaw to cause a denial of service to applications that use the affected filesystems.", "other": {"cve": {"id": "CVE-2021-3996", "sourceIdentifier": "secalert@redhat.com", "published": "2022-08-23T20:15:08.560", "lastModified": "2023-01-26T20:38:54.537", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A logic error was found in the libmount library of util-linux in the function that allows an unprivileged user to unmount a FUSE filesystem. This flaw allows a local user on a vulnerable system to unmount other users' filesystems that are either world-writable themselves (like /tmp) or mounted in a world-writable directory. An attacker may use this flaw to cause a denial of service to applications that use the affected filesystems."}, {"lang": "es", "value": "Se ha encontrado un error l\u00f3gico en la biblioteca libmount de util-linux en la funci\u00f3n que permite a un usuario no privilegiado desmontar un sistema de archivos FUSE. Este fallo permite a un usuario local en un sistema vulnerable desmontar los sistemas de archivos de otros usuarios que son de escritura mundial (como /tmp) o que est\u00e1n montados en un directorio de escritura mundial. Un atacante puede usar este fallo para causar una denegaci\u00f3n de servicio a las aplicaciones que usan los sistemas de archivos afectados."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "secalert@redhat.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-552"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-552"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:kernel:util-linux:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.34", "versionEndExcluding": "2.37.3", "matchCriteriaId": "755D0AAC-24D9-4B39-BCC2-06AC9FF889E2"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/170176/snap-confine-must_mkdir_and_open_with_perms-Race-Condition.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://seclists.org/fulldisclosure/2022/Dec/4", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2022/11/30/2", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://access.redhat.com/security/cve/CVE-2021-3996", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2024628", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/util-linux/util-linux/commit/166e87368ae88bf31112a30e078cceae637f4cdb", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://mirrors.edge.kernel.org/pub/linux/utils/util-linux/v2.37/v2.37.3-ReleaseNotes", "source": "secalert@redhat.com", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20221209-0002/", "source": "secalert@redhat.com", "tags": ["Broken Link", "Third Party Advisory"]}, {"url": "https://www.openwall.com/lists/oss-security/2022/01/24/2", "source": "secalert@redhat.com", "tags": ["Exploit", "Mailing List", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/util-linux/util-linux/commit/166e87368ae88bf31112a30e078cceae637f4cdb"}}