{"buggy_code": ["/*\n *       .                             .o8                     oooo\n *    .o8                             \"888                     `888\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n *  ========================================================================\n *  Author:     Chris Brame\n *  Updated:    1/20/19 4:43 PM\n *  Copyright (c) 2014-2019. All rights reserved.\n */\n\nconst _ = require('lodash')\nconst async = require('async')\nconst winston = require('../logger')\nconst conversationSchema = require('../models/chat/conversation')\nconst messageSchema = require('../models/chat/message')\nconst messagesController = {}\n\nmessagesController.content = {}\n\nmessagesController.get = function (req, res) {\n  const content = {}\n  content.title = 'Messages'\n  content.nav = 'messages'\n  content.data = {}\n  content.data.user = req.user\n  content.data.common = req.viewdata\n  content.data.conversations = []\n  content.data.showNewConvo = req.showNewConvo\n\n  conversationSchema.getConversationsWithLimit(req.user._id, undefined, function (err, convos) {\n    if (err) {\n      winston.debug(err)\n      return handleError(res, err)\n    }\n\n    async.eachSeries(\n      convos,\n      function (convo, done) {\n        const c = convo.toObject()\n\n        const userMeta =\n          convo.userMeta[\n            _.findIndex(convo.userMeta, function (item) {\n              return item.userId.toString() === req.user._id.toString()\n            })\n          ]\n        if (!_.isUndefined(userMeta) && !_.isUndefined(userMeta.deletedAt) && userMeta.deletedAt > convo.updatedAt) {\n          return done()\n        }\n\n        messageSchema.getMostRecentMessage(c._id, function (err, rm) {\n          if (err) return done(err)\n\n          _.each(c.participants, function (p) {\n            if (p._id.toString() !== req.user._id.toString()) {\n              c.partner = p\n            }\n          })\n\n          rm = _.first(rm)\n\n          if (!_.isUndefined(rm)) {\n            if (String(c.partner._id) === String(rm.owner._id)) {\n              c.recentMessage = c.partner.fullname + ': ' + rm.body\n            } else {\n              c.recentMessage = 'You: ' + rm.body\n            }\n          } else {\n            c.recentMessage = 'New Conversation'\n          }\n\n          content.data.conversations.push(c)\n\n          return done()\n        })\n      },\n      function (err) {\n        if (err) {\n          winston.debug(err)\n          return handleError(res, err)\n        }\n\n        return res.render('messages', content)\n      }\n    )\n  })\n}\n\nmessagesController.getConversation = function (req, res) {\n  const cid = req.params.convoid\n  if (_.isUndefined(cid)) return handleError(res, 'Invalid Conversation ID!')\n\n  const content = {}\n  content.title = 'Messages'\n  content.nav = 'messages'\n  content.data = {}\n  content.data.user = req.user\n  content.data.common = req.viewdata\n  content.data.conversations = []\n\n  async.parallel(\n    [\n      function (next) {\n        conversationSchema.getConversationsWithLimit(req.user._id, undefined, function (err, convos) {\n          if (err) return next(err)\n\n          async.eachSeries(\n            convos,\n            function (convo, done) {\n              const userMeta =\n                convo.userMeta[\n                  _.findIndex(convo.userMeta, function (item) {\n                    return item.userId.toString() === req.user._id.toString()\n                  })\n                ]\n              if (\n                !_.isUndefined(userMeta) &&\n                !_.isUndefined(userMeta.deletedAt) &&\n                userMeta.deletedAt > convo.updatedAt &&\n                req.params.convoid.toString() !== convo._id.toString()\n              ) {\n                return done()\n              }\n\n              const c = convo.toObject()\n              messageSchema.getMostRecentMessage(c._id, function (err, rm) {\n                if (err) return done(err)\n\n                _.each(c.participants, function (p) {\n                  if (p._id.toString() !== req.user._id.toString()) {\n                    c.partner = p\n                  }\n                })\n\n                rm = _.first(rm)\n\n                if (!_.isUndefined(rm)) {\n                  if (String(c.partner._id) === String(rm.owner._id)) {\n                    c.recentMessage = c.partner.fullname + ': ' + rm.body\n                  } else {\n                    c.recentMessage = 'You: ' + rm.body\n                  }\n                } else {\n                  c.recentMessage = 'New Conversation'\n                }\n\n                if (\n                  !_.isUndefined(userMeta) &&\n                  !_.isUndefined(userMeta.deletedAt) &&\n                  !_.isUndefined(rm) &&\n                  rm.createdAt < userMeta.deletedAt\n                ) {\n                  c.recentMessage = 'New Conversation'\n                }\n\n                content.data.conversations.push(c)\n\n                return done()\n              })\n            },\n            function (err) {\n              if (err) return next(err)\n\n              return next()\n            }\n          )\n        })\n      },\n      function (next) {\n        content.data.page = 2\n\n        conversationSchema.getConversation(cid, function (err, convo) {\n          if (err) return next(err)\n\n          if (convo === null || convo === undefined) {\n            return res.redirect('/messages')\n          }\n\n          const c = convo.toObject()\n          messageSchema.getConversationWithObject(\n            { cid: c._id, userMeta: convo.userMeta, requestingUser: req.user },\n            function (err, messages) {\n              if (err) return next(err)\n\n              _.each(c.participants, function (p) {\n                if (p._id.toString() !== req.user._id.toString()) {\n                  c.partner = p\n                }\n              })\n\n              c.requestingUserMeta =\n                convo.userMeta[\n                  _.findIndex(convo.userMeta, function (item) {\n                    return item.userId.toString() === req.user._id.toString()\n                  })\n                ]\n\n              content.data.conversation = c\n              content.data.conversation.messages = messages.reverse()\n\n              return next()\n            }\n          )\n        })\n      }\n    ],\n    function (err) {\n      if (err) return handleError(res, err)\n      return res.render('messages', content)\n    }\n  )\n}\n\nfunction handleError (res, err) {\n  if (err) {\n    winston.warn(err)\n    if (!err.status) res.status = 500\n    else res.status = err.status\n    return res.render('error', {\n      layout: false,\n      error: err,\n      message: err.message\n    })\n  }\n}\n\nmodule.exports = messagesController\n"], "fixing_code": ["/*\n *       .                             .o8                     oooo\n *    .o8                             \"888                     `888\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n *  ========================================================================\n *  Author:     Chris Brame\n *  Updated:    1/20/19 4:43 PM\n *  Copyright (c) 2014-2019. All rights reserved.\n */\n\nconst _ = require('lodash')\nconst async = require('async')\nconst winston = require('../logger')\nconst conversationSchema = require('../models/chat/conversation')\nconst messageSchema = require('../models/chat/message')\nconst messagesController = {}\n\nmessagesController.content = {}\n\nmessagesController.get = function (req, res) {\n  const content = {}\n  content.title = 'Messages'\n  content.nav = 'messages'\n  content.data = {}\n  content.data.user = req.user\n  content.data.common = req.viewdata\n  content.data.conversations = []\n  content.data.showNewConvo = req.showNewConvo\n\n  conversationSchema.getConversationsWithLimit(req.user._id, undefined, function (err, convos) {\n    if (err) {\n      winston.debug(err)\n      return handleError(res, err)\n    }\n\n    async.eachSeries(\n      convos,\n      function (convo, done) {\n        const c = convo.toObject()\n\n        const userMeta =\n          convo.userMeta[\n            _.findIndex(convo.userMeta, function (item) {\n              return item.userId.toString() === req.user._id.toString()\n            })\n          ]\n        if (!_.isUndefined(userMeta) && !_.isUndefined(userMeta.deletedAt) && userMeta.deletedAt > convo.updatedAt) {\n          return done()\n        }\n\n        messageSchema.getMostRecentMessage(c._id, function (err, rm) {\n          if (err) return done(err)\n\n          _.each(c.participants, function (p) {\n            if (p._id.toString() !== req.user._id.toString()) {\n              c.partner = p\n            }\n          })\n\n          rm = _.first(rm)\n\n          if (!_.isUndefined(rm)) {\n            if (String(c.partner._id) === String(rm.owner._id)) {\n              c.recentMessage = c.partner.fullname + ': ' + rm.body\n            } else {\n              c.recentMessage = 'You: ' + rm.body\n            }\n          } else {\n            c.recentMessage = 'New Conversation'\n          }\n\n          content.data.conversations.push(c)\n\n          return done()\n        })\n      },\n      function (err) {\n        if (err) {\n          winston.debug(err)\n          return handleError(res, err)\n        }\n\n        return res.render('messages', content)\n      }\n    )\n  })\n}\n\nmessagesController.getConversation = async (req, res) => {\n  const cid = req.params.convoid\n  if (_.isUndefined(cid)) return handleError(res, 'Invalid Conversation ID!')\n\n  const content = {}\n  content.title = 'Messages'\n  content.nav = 'messages'\n  content.data = {}\n  content.data.user = req.user\n  content.data.common = req.viewdata\n  content.data.conversations = []\n\n  async.parallel(\n    [\n      function (next) {\n        conversationSchema.getConversationsWithLimit(req.user._id, undefined, function (err, convos) {\n          if (err) return next(err)\n\n          async.eachSeries(\n            convos,\n            function (convo, done) {\n              const userMeta =\n                convo.userMeta[\n                  _.findIndex(convo.userMeta, function (item) {\n                    return item.userId.toString() === req.user._id.toString()\n                  })\n                ]\n              if (\n                !_.isUndefined(userMeta) &&\n                !_.isUndefined(userMeta.deletedAt) &&\n                userMeta.deletedAt > convo.updatedAt &&\n                req.params.convoid.toString() !== convo._id.toString()\n              ) {\n                return done()\n              }\n\n              const c = convo.toObject()\n              messageSchema.getMostRecentMessage(c._id, function (err, rm) {\n                if (err) return done(err)\n\n                _.each(c.participants, function (p) {\n                  if (p._id.toString() !== req.user._id.toString()) {\n                    c.partner = p\n                  }\n                })\n\n                rm = _.first(rm)\n\n                if (!_.isUndefined(rm)) {\n                  if (String(c.partner._id) === String(rm.owner._id)) {\n                    c.recentMessage = c.partner.fullname + ': ' + rm.body\n                  } else {\n                    c.recentMessage = 'You: ' + rm.body\n                  }\n                } else {\n                  c.recentMessage = 'New Conversation'\n                }\n\n                if (\n                  !_.isUndefined(userMeta) &&\n                  !_.isUndefined(userMeta.deletedAt) &&\n                  !_.isUndefined(rm) &&\n                  rm.createdAt < userMeta.deletedAt\n                ) {\n                  c.recentMessage = 'New Conversation'\n                }\n\n                content.data.conversations.push(c)\n\n                return done()\n              })\n            },\n            function (err) {\n              if (err) return next(err)\n\n              return next()\n            }\n          )\n        })\n      },\n      function (next) {\n        content.data.page = 2\n\n        conversationSchema.getConversation(cid, function (err, convo) {\n          if (err) return next(err)\n\n          if (convo === null || convo === undefined) {\n            return res.redirect('/messages')\n          }\n\n          const c = convo.toObject()\n\n          let isPart = false\n          _.each(c.participants, function (p) {\n            if (p._id.toString() === req.user._id.toString()) isPart = true\n          })\n\n          if (!isPart) {\n            return res.redirect('/messages')\n          }\n\n          messageSchema.getConversationWithObject(\n            { cid: c._id, userMeta: convo.userMeta, requestingUser: req.user },\n            function (err, messages) {\n              if (err) return next(err)\n\n              _.each(c.participants, function (p) {\n                if (p._id.toString() !== req.user._id.toString()) {\n                  c.partner = p\n                }\n              })\n\n              c.requestingUserMeta =\n                convo.userMeta[\n                  _.findIndex(convo.userMeta, function (item) {\n                    return item.userId.toString() === req.user._id.toString()\n                  })\n                ]\n\n              content.data.conversation = c\n              content.data.conversation.messages = messages.reverse()\n\n              return next()\n            }\n          )\n        })\n      }\n    ],\n    function (err) {\n      if (err) return handleError(res, err)\n      return res.render('messages', content)\n    }\n  )\n}\n\nfunction handleError (res, err) {\n  if (err) {\n    winston.warn(err)\n    if (!err.status) res.status = 500\n    else res.status = err.status\n    return res.render('error', {\n      layout: false,\n      error: err,\n      message: err.message\n    })\n  }\n}\n\nmodule.exports = messagesController\n"], "filenames": ["src/controllers/messages.js"], "buggy_code_start_loc": [93], "buggy_code_end_loc": [183], "fixing_code_start_loc": [93], "fixing_code_end_loc": [194], "type": "NVD-CWE-Other", "message": "Use of Incorrect Operator in GitHub repository polonel/trudesk prior to 1.2.3.", "other": {"cve": {"id": "CVE-2022-1947", "sourceIdentifier": "security@huntr.dev", "published": "2022-05-31T23:15:07.833", "lastModified": "2022-06-14T18:24:45.627", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Use of Incorrect Operator in GitHub repository polonel/trudesk prior to 1.2.3."}, {"lang": "es", "value": "Un uso de un Operador Incorrecto en el repositorio de GitHub polonel/trudesk versiones anteriores a 1.2.3"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 2.3, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-480"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:trudesk_project:trudesk:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.2.3", "matchCriteriaId": "D498F5B4-C37B-4226-A1FF-580B69B2AB0E"}]}]}], "references": [{"url": "https://github.com/polonel/trudesk/commit/a9e38f25c2af2722dee4fdafb2fb70d30d5106c5", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/cb4d0ab3-51ba-4a42-9e38-ac0e544266f1", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/polonel/trudesk/commit/a9e38f25c2af2722dee4fdafb2fb70d30d5106c5"}}