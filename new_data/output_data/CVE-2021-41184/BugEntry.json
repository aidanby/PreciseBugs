{"buggy_code": ["define( [\n\t\"qunit\",\n\t\"jquery\",\n\t\"lib/common\",\n\t\"lib/helper\",\n\t\"ui/position\"\n], function( QUnit, $, common, helper ) {\n\nvar win = $( window ),\n\tscrollTopSupport = function() {\n\t\tvar support = win.scrollTop( 1 ).scrollTop() === 1;\n\t\twin.scrollTop( 0 );\n\t\tscrollTopSupport = function() {\n\t\t\treturn support;\n\t\t};\n\t\treturn support;\n\t};\n\nQUnit.module( \"position\", {\n\tbeforeEach: function() {\n\t\twin.scrollTop( 0 ).scrollLeft( 0 );\n\t},\n\tafterEach: helper.moduleAfterEach\n} );\n\ncommon.testJshint( \"position\" );\n\nQUnit.test( \"my, at, of\", function( assert ) {\n\tassert.expect( 4 );\n\n\t$( \"#elx\" ).position( {\n\t\tmy: \"left top\",\n\t\tat: \"left top\",\n\t\tof: \"#parentx\",\n\t\tcollision: \"none\"\n\t} );\n\tassert.deepEqual( $( \"#elx\" ).offset(), { top: 40, left: 40 }, \"left top, left top\" );\n\n\t$( \"#elx\" ).position( {\n\t\tmy: \"left top\",\n\t\tat: \"left bottom\",\n\t\tof: \"#parentx\",\n\t\tcollision: \"none\"\n\t} );\n\tassert.deepEqual( $( \"#elx\" ).offset(), { top: 60, left: 40 }, \"left top, left bottom\" );\n\n\t$( \"#elx\" ).position( {\n\t\tmy: \"left\",\n\t\tat: \"bottom\",\n\t\tof: \"#parentx\",\n\t\tcollision: \"none\"\n\t} );\n\tassert.deepEqual( $( \"#elx\" ).offset(), { top: 55, left: 50 }, \"left, bottom\" );\n\n\t$( \"#elx\" ).position( {\n\t\tmy: \"left foo\",\n\t\tat: \"bar baz\",\n\t\tof: \"#parentx\",\n\t\tcollision: \"none\"\n\t} );\n\tassert.deepEqual( $( \"#elx\" ).offset(), { top: 45, left: 50 }, \"left foo, bar baz\" );\n} );\n\nQUnit.test( \"multiple elements\", function( assert ) {\n\tassert.expect( 3 );\n\n\tvar elements = $( \"#el1, #el2\" ),\n\t\tresult = elements.position( {\n\t\t\tmy: \"left top\",\n\t\t\tat: \"left bottom\",\n\t\t\tof: \"#parent\",\n\t\t\tcollision: \"none\"\n\t\t} ),\n\t\texpected = { top: 10, left: 4 };\n\n\tassert.deepEqual( result, elements );\n\telements.each( function() {\n\t\tassert.deepEqual( $( this ).offset(), expected );\n\t} );\n} );\n\nQUnit.test( \"positions\", function( assert ) {\n\tassert.expect( 18 );\n\n\tvar offsets = {\n\t\t\tleft: 0,\n\t\t\tcenter: 3,\n\t\t\tright: 6,\n\t\t\ttop: 0,\n\t\t\tbottom: 6\n\t\t},\n\t\tstart = { left: 4, top: 4 },\n\t\tel = $( \"#el1\" );\n\n\t$.each( [ 0, 1 ], function( my ) {\n\t\t$.each( [ \"top\", \"center\", \"bottom\" ], function( vindex, vertical ) {\n\t\t\t$.each( [ \"left\", \"center\", \"right\" ], function( hindex, horizontal ) {\n\t\t\t\tvar _my = my ? horizontal + \" \" + vertical : \"left top\",\n\t\t\t\t\t_at = !my ? horizontal + \" \" + vertical : \"left top\";\n\t\t\t\tel.position( {\n\t\t\t\t\tmy: _my,\n\t\t\t\t\tat: _at,\n\t\t\t\t\tof: \"#parent\",\n\t\t\t\t\tcollision: \"none\"\n\t\t\t\t} );\n\t\t\t\tassert.deepEqual( el.offset(), {\n\t\t\t\t\ttop: start.top + offsets[ vertical ] * ( my ? -1 : 1 ),\n\t\t\t\t\tleft: start.left + offsets[ horizontal ] * ( my ? -1 : 1 )\n\t\t\t\t}, \"Position via \" + QUnit.jsDump.parse( { my: _my, at: _at } ) );\n\t\t\t} );\n\t\t} );\n\t} );\n} );\n\nQUnit.test( \"of\", function( assert ) {\n\tassert.expect( 9 + ( scrollTopSupport() ? 1 : 0 ) );\n\n\tvar event;\n\n\t$( \"#elx\" ).position( {\n\t\tmy: \"left top\",\n\t\tat: \"left top\",\n\t\tof: \"#parentx\",\n\t\tcollision: \"none\"\n\t} );\n\tassert.deepEqual( $( \"#elx\" ).offset(), { top: 40, left: 40 }, \"selector\" );\n\n\t$( \"#elx\" ).position( {\n\t\tmy: \"left top\",\n\t\tat: \"left bottom\",\n\t\tof: $( \"#parentx\" ),\n\t\tcollision: \"none\"\n\t} );\n\tassert.deepEqual( $( \"#elx\" ).offset(), { top: 60, left: 40 }, \"jQuery object\" );\n\n\t$( \"#elx\" ).position( {\n\t\tmy: \"left top\",\n\t\tat: \"left top\",\n\t\tof: $( \"#parentx\" )[ 0 ],\n\t\tcollision: \"none\"\n\t} );\n\tassert.deepEqual( $( \"#elx\" ).offset(), { top: 40, left: 40 }, \"DOM element\" );\n\n\t$( \"#elx\" ).position( {\n\t\tmy: \"right bottom\",\n\t\tat: \"right bottom\",\n\t\tof: document,\n\t\tcollision: \"none\"\n\t} );\n\tassert.deepEqual( $( \"#elx\" ).offset(), {\n\t\ttop: $( document ).height() - 10,\n\t\tleft: $( document ).width() - 10\n\t}, \"document\" );\n\n\t$( \"#elx\" ).position( {\n\t\tmy: \"right bottom\",\n\t\tat: \"right bottom\",\n\t\tof: $( document ),\n\t\tcollision: \"none\"\n\t} );\n\tassert.deepEqual( $( \"#elx\" ).offset(), {\n\t\ttop: $( document ).height() - 10,\n\t\tleft: $( document ).width() - 10\n\t}, \"document as jQuery object\" );\n\n\twin.scrollTop( 0 );\n\n\t$( \"#elx\" ).position( {\n\t\tmy: \"right bottom\",\n\t\tat: \"right bottom\",\n\t\tof: window,\n\t\tcollision: \"none\"\n\t} );\n\tassert.deepEqual( $( \"#elx\" ).offset(), {\n\t\ttop: win.height() - 10,\n\t\tleft: win.width() - 10\n\t}, \"window\" );\n\n\t$( \"#elx\" ).position( {\n\t\tmy: \"right bottom\",\n\t\tat: \"right bottom\",\n\t\tof: win,\n\t\tcollision: \"none\"\n\t} );\n\tassert.deepEqual( $( \"#elx\" ).offset(), {\n\t\ttop: win.height() - 10,\n\t\tleft: win.width() - 10\n\t}, \"window as jQuery object\" );\n\n\tif ( scrollTopSupport() ) {\n\t\twin.scrollTop( 500 ).scrollLeft( 200 );\n\t\t$( \"#elx\" ).position( {\n\t\t\tmy: \"right bottom\",\n\t\t\tat: \"right bottom\",\n\t\t\tof: window,\n\t\t\tcollision: \"none\"\n\t\t} );\n\t\tassert.deepEqual( $( \"#elx\" ).offset(), {\n\t\t\ttop: win.height() + 500 - 10,\n\t\t\tleft: win.width() + 200 - 10\n\t\t}, \"window, scrolled\" );\n\t\twin.scrollTop( 0 ).scrollLeft( 0 );\n\t}\n\n\tevent = $.extend( $.Event( \"someEvent\" ), { pageX: 200, pageY: 300 } );\n\t$( \"#elx\" ).position( {\n\t\tmy: \"left top\",\n\t\tat: \"left top\",\n\t\tof: event,\n\t\tcollision: \"none\"\n\t} );\n\tassert.deepEqual( $( \"#elx\" ).offset(), {\n\t\ttop: 300,\n\t\tleft: 200\n\t}, \"event - left top, left top\" );\n\n\tevent = $.extend( $.Event( \"someEvent\" ), { pageX: 400, pageY: 600 } );\n\t$( \"#elx\" ).position( {\n\t\tmy: \"left top\",\n\t\tat: \"right bottom\",\n\t\tof: event,\n\t\tcollision: \"none\"\n\t} );\n\tassert.deepEqual( $( \"#elx\" ).offset(), {\n\t\ttop: 600,\n\t\tleft: 400\n\t}, \"event - left top, right bottom\" );\n} );\n\nQUnit.test( \"offsets\", function( assert ) {\n\tassert.expect( 9 );\n\n\tvar offset;\n\n\t$( \"#elx\" ).position( {\n\t\tmy: \"left top\",\n\t\tat: \"left+10 bottom+10\",\n\t\tof: \"#parentx\",\n\t\tcollision: \"none\"\n\t} );\n\tassert.deepEqual( $( \"#elx\" ).offset(), { top: 70, left: 50 }, \"offsets in at\" );\n\n\t$( \"#elx\" ).position( {\n\t\tmy: \"left+10 top-10\",\n\t\tat: \"left bottom\",\n\t\tof: \"#parentx\",\n\t\tcollision: \"none\"\n\t} );\n\tassert.deepEqual( $( \"#elx\" ).offset(), { top: 50, left: 50 }, \"offsets in my\" );\n\n\t$( \"#elx\" ).position( {\n\t\tmy: \"left top\",\n\t\tat: \"left+50% bottom-10%\",\n\t\tof: \"#parentx\",\n\t\tcollision: \"none\"\n\t} );\n\tassert.deepEqual( $( \"#elx\" ).offset(), { top: 58, left: 50 }, \"percentage offsets in at\" );\n\n\t$( \"#elx\" ).position( {\n\t\tmy: \"left-30% top+50%\",\n\t\tat: \"left bottom\",\n\t\tof: \"#parentx\",\n\t\tcollision: \"none\"\n\t} );\n\tassert.deepEqual( $( \"#elx\" ).offset(), { top: 65, left: 37 }, \"percentage offsets in my\" );\n\n\t$( \"#elx\" ).position( {\n\t\tmy: \"left-30.001% top+50.0%\",\n\t\tat: \"left bottom\",\n\t\tof: \"#parentx\",\n\t\tcollision: \"none\"\n\t} );\n\toffset = $( \"#elx\" ).offset();\n\tassert.equal( Math.round( offset.top ), 65, \"decimal percentage offsets in my\" );\n\tassert.equal( Math.round( offset.left ), 37, \"decimal percentage offsets in my\" );\n\n\t$( \"#elx\" ).position( {\n\t\tmy: \"left+10.4 top-10.6\",\n\t\tat: \"left bottom\",\n\t\tof: \"#parentx\",\n\t\tcollision: \"none\"\n\t} );\n\toffset = $( \"#elx\" ).offset();\n\tassert.equal( Math.round( offset.top ), 49, \"decimal offsets in my\" );\n\tassert.equal( Math.round( offset.left ), 50, \"decimal offsets in my\" );\n\n\t$( \"#elx\" ).position( {\n\t\tmy: \"left+right top-left\",\n\t\tat: \"left-top bottom-bottom\",\n\t\tof: \"#parentx\",\n\t\tcollision: \"none\"\n\t} );\n\tassert.deepEqual( $( \"#elx\" ).offset(), { top: 60, left: 40 }, \"invalid offsets\" );\n} );\n\nQUnit.test( \"using\", function( assert ) {\n\tassert.expect( 10 );\n\n\tvar count = 0,\n\t\telems = $( \"#el1, #el2\" ),\n\t\tof = $( \"#parentx\" ),\n\t\texpectedPosition = { top: 60, left: 60 },\n\t\texpectedFeedback = {\n\t\t\ttarget: {\n\t\t\t\telement: of,\n\t\t\t\twidth: 20,\n\t\t\t\theight: 20,\n\t\t\t\tleft: 40,\n\t\t\t\ttop: 40\n\t\t\t},\n\t\t\telement: {\n\t\t\t\twidth: 6,\n\t\t\t\theight: 6,\n\t\t\t\tleft: 60,\n\t\t\t\ttop: 60\n\t\t\t},\n\t\t\thorizontal: \"left\",\n\t\t\tvertical: \"top\",\n\t\t\timportant: \"vertical\"\n\t\t},\n\t\toriginalPosition = elems.position( {\n\t\t\tmy: \"right bottom\",\n\t\t\tat: \"rigt bottom\",\n\t\t\tof: \"#parentx\",\n\t\t\tcollision: \"none\"\n\t\t} ).offset();\n\n\telems.position( {\n\t\tmy: \"left top\",\n\t\tat: \"center+10 bottom\",\n\t\tof: \"#parentx\",\n\t\tusing: function( position, feedback ) {\n\t\t\tassert.deepEqual( this, elems[ count ], \"correct context for call #\" + count );\n\t\t\tassert.deepEqual( position, expectedPosition, \"correct position for call #\" + count );\n\t\t\tassert.deepEqual( feedback.element.element[ 0 ], elems[ count ] );\n\t\t\tdelete feedback.element.element;\n\t\t\tassert.deepEqual( feedback, expectedFeedback );\n\t\t\tcount++;\n\t\t}\n\t} );\n\n\telems.each( function() {\n\t\tassert.deepEqual( $( this ).offset(), originalPosition, \"elements not moved\" );\n\t} );\n} );\n\nfunction collisionTest( assert, config, result, msg ) {\n\tvar elem = $( \"#elx\" ).position( $.extend( {\n\t\tmy: \"left top\",\n\t\tat: \"right bottom\",\n\t\tof: \"#parent\"\n\t}, config ) );\n\tassert.deepEqual( elem.offset(), result, msg );\n}\n\nfunction collisionTest2( assert, config, result, msg ) {\n\tcollisionTest( assert, $.extend( {\n\t\tmy: \"right bottom\",\n\t\tat: \"left top\"\n\t}, config ), result, msg );\n}\n\nQUnit.test( \"collision: fit, no collision\", function( assert ) {\n\tassert.expect( 2 );\n\n\tcollisionTest( assert, {\n\t\tcollision: \"fit\"\n\t}, {\n\t\ttop: 10,\n\t\tleft: 10\n\t}, \"no offset\" );\n\n\tcollisionTest( assert, {\n\t\tcollision: \"fit\",\n\t\tat: \"right+2 bottom+3\"\n\t}, {\n\t\ttop: 13,\n\t\tleft: 12\n\t}, \"with offset\" );\n} );\n\n// Currently failing in IE8 due to the iframe used by TestSwarm\nif ( !/msie [\\w.]+/.exec( navigator.userAgent.toLowerCase() ) ) {\nQUnit.test( \"collision: fit, collision\", function( assert ) {\n\tassert.expect( 2 + ( scrollTopSupport() ? 1 : 0 ) );\n\n\tcollisionTest2( assert, {\n\t\tcollision: \"fit\"\n\t}, {\n\t\ttop: 0,\n\t\tleft: 0\n\t}, \"no offset\" );\n\n\tcollisionTest2( assert, {\n\t\tcollision: \"fit\",\n\t\tat: \"left+2 top+3\"\n\t}, {\n\t\ttop: 0,\n\t\tleft: 0\n\t}, \"with offset\" );\n\n\tif ( scrollTopSupport() ) {\n\t\twin.scrollTop( 300 ).scrollLeft( 200 );\n\t\tcollisionTest( assert, {\n\t\t\tcollision: \"fit\"\n\t\t}, {\n\t\t\ttop: 300,\n\t\t\tleft: 200\n\t\t}, \"window scrolled\" );\n\n\t\twin.scrollTop( 0 ).scrollLeft( 0 );\n\t}\n} );\n}\n\nQUnit.test( \"collision: flip, no collision\", function( assert ) {\n\tassert.expect( 2 );\n\n\tcollisionTest( assert, {\n\t\tcollision: \"flip\"\n\t}, {\n\t\ttop: 10,\n\t\tleft: 10\n\t}, \"no offset\" );\n\n\tcollisionTest( assert, {\n\t\tcollision: \"flip\",\n\t\tat: \"right+2 bottom+3\"\n\t}, {\n\t\ttop: 13,\n\t\tleft: 12\n\t}, \"with offset\" );\n} );\n\nQUnit.test( \"collision: flip, collision\", function( assert ) {\n\tassert.expect( 2 );\n\n\tcollisionTest2( assert, {\n\t\tcollision: \"flip\"\n\t}, {\n\t\ttop: 10,\n\t\tleft: 10\n\t}, \"no offset\" );\n\n\tcollisionTest2( assert, {\n\t\tcollision: \"flip\",\n\t\tat: \"left+2 top+3\"\n\t}, {\n\t\ttop: 7,\n\t\tleft: 8\n\t}, \"with offset\" );\n} );\n\nQUnit.test( \"collision: flipfit, no collision\", function( assert ) {\n\tassert.expect( 2 );\n\n\tcollisionTest( assert, {\n\t\tcollision: \"flipfit\"\n\t}, {\n\t\ttop: 10,\n\t\tleft: 10\n\t}, \"no offset\" );\n\n\tcollisionTest( assert, {\n\t\tcollision: \"flipfit\",\n\t\tat: \"right+2 bottom+3\"\n\t}, {\n\t\ttop: 13,\n\t\tleft: 12\n\t}, \"with offset\" );\n} );\n\nQUnit.test( \"collision: flipfit, collision\", function( assert ) {\n\tassert.expect( 2 );\n\n\tcollisionTest2( assert, {\n\t\tcollision: \"flipfit\"\n\t}, {\n\t\ttop: 10,\n\t\tleft: 10\n\t}, \"no offset\" );\n\n\tcollisionTest2( assert, {\n\t\tcollision: \"flipfit\",\n\t\tat: \"left+2 top+3\"\n\t}, {\n\t\ttop: 7,\n\t\tleft: 8\n\t}, \"with offset\" );\n} );\n\nQUnit.test( \"collision: none, no collision\", function( assert ) {\n\tassert.expect( 2 );\n\n\tcollisionTest( assert, {\n\t\tcollision: \"none\"\n\t}, {\n\t\ttop: 10,\n\t\tleft: 10\n\t}, \"no offset\" );\n\n\tcollisionTest( assert, {\n\t\tcollision: \"none\",\n\t\tat: \"right+2 bottom+3\"\n\t}, {\n\t\ttop: 13,\n\t\tleft: 12\n\t}, \"with offset\" );\n} );\n\nQUnit.test( \"collision: none, collision\", function( assert ) {\n\tassert.expect( 2 );\n\n\tcollisionTest2( assert, {\n\t\tcollision: \"none\"\n\t}, {\n\t\ttop: -6,\n\t\tleft: -6\n\t}, \"no offset\" );\n\n\tcollisionTest2( assert, {\n\t\tcollision: \"none\",\n\t\tat: \"left+2 top+3\"\n\t}, {\n\t\ttop: -3,\n\t\tleft: -4\n\t}, \"with offset\" );\n} );\n\nQUnit.test( \"collision: fit, with margin\", function( assert ) {\n\tassert.expect( 2 );\n\n\t$( \"#elx\" ).css( {\n\t\tmarginTop: 6,\n\t\tmarginLeft: 4\n\t} );\n\n\tcollisionTest( assert, {\n\t\tcollision: \"fit\"\n\t}, {\n\t\ttop: 10,\n\t\tleft: 10\n\t}, \"right bottom\" );\n\n\tcollisionTest2( assert, {\n\t\tcollision: \"fit\"\n\t}, {\n\t\ttop: 6,\n\t\tleft: 4\n\t}, \"left top\" );\n} );\n\nQUnit.test( \"collision: flip, with margin\", function( assert ) {\n\tassert.expect( 3 );\n\n\t$( \"#elx\" ).css( {\n\t\tmarginTop: 6,\n\t\tmarginLeft: 4\n\t} );\n\n\tcollisionTest( assert, {\n\t\tcollision: \"flip\"\n\t}, {\n\t\ttop: 10,\n\t\tleft: 10\n\t}, \"left top\" );\n\n\tcollisionTest2( assert, {\n\t\tcollision: \"flip\"\n\t}, {\n\t\ttop: 10,\n\t\tleft: 10\n\t}, \"right bottom\" );\n\n\tcollisionTest2( assert, {\n\t\tcollision: \"flip\",\n\t\tmy: \"left top\"\n\t}, {\n\t\ttop: 0,\n\t\tleft: 4\n\t}, \"right bottom\" );\n} );\n\nQUnit.test( \"within\", function( assert ) {\n\tassert.expect( 7 );\n\n\tcollisionTest( assert, {\n\t\twithin: document\n\t}, {\n\t\ttop: 10,\n\t\tleft: 10\n\t}, \"within document\" );\n\n\tcollisionTest( assert, {\n\t\twithin: \"#within\",\n\t\tcollision: \"fit\"\n\t}, {\n\t\ttop: 4,\n\t\tleft: 2\n\t}, \"fit - right bottom\" );\n\n\tcollisionTest2( assert, {\n\t\twithin: \"#within\",\n\t\tcollision: \"fit\"\n\t}, {\n\t\ttop: 2,\n\t\tleft: 0\n\t}, \"fit - left top\" );\n\n\tcollisionTest( assert, {\n\t\twithin: \"#within\",\n\t\tcollision: \"flip\"\n\t}, {\n\t\ttop: 10,\n\t\tleft: -6\n\t}, \"flip - right bottom\" );\n\n\tcollisionTest2( assert, {\n\t\twithin: \"#within\",\n\t\tcollision: \"flip\"\n\t}, {\n\t\ttop: 10,\n\t\tleft: -6\n\t}, \"flip - left top\" );\n\n\tcollisionTest( assert, {\n\t\twithin: \"#within\",\n\t\tcollision: \"flipfit\"\n\t}, {\n\t\ttop: 4,\n\t\tleft: 0\n\t}, \"flipfit - right bottom\" );\n\n\tcollisionTest2( assert, {\n\t\twithin: \"#within\",\n\t\tcollision: \"flipfit\"\n\t}, {\n\t\ttop: 4,\n\t\tleft: 0\n\t}, \"flipfit - left top\" );\n} );\n\n// jQuery 3.2 incorrectly handle scrollbars in WebKit/Blink-based browsers.\n// This is fixed in version 3.3, see https://github.com/jquery/jquery/issues/3589.\n// As the data here comes from jQuery directly and the changes to fix it\n// are non-trivial: https://github.com/jquery/jquery/pull/3656, just accept\n// that scrollbar data in this jQuery version is inaccurate.\nQUnit[ jQuery.fn.jquery.substring( 0, 4 ) === \"3.2.\" ? \"skip\" : \"test\" ](\n\t\"with scrollbars\", function( assert ) {\n\tassert.expect( 4 );\n\n\t$( \"#scrollx\" ).css( {\n\t\twidth: 100,\n\t\theight: 100,\n\t\tleft: 0,\n\t\ttop: 0\n\t} );\n\n\tcollisionTest( assert, {\n\t\tof: \"#scrollx\",\n\t\tcollision: \"fit\",\n\t\twithin: \"#scrollx\"\n\t}, {\n\t\ttop: 90,\n\t\tleft: 90\n\t}, \"visible\" );\n\n\t$( \"#scrollx\" ).css( {\n\t\toverflow: \"scroll\"\n\t} );\n\n\tvar scrollbarInfo = $.position.getScrollInfo( $.position.getWithinInfo( $( \"#scrollx\" ) ) );\n\n\tcollisionTest( assert, {\n\t\tof: \"#scrollx\",\n\t\tcollision: \"fit\",\n\t\twithin: \"#scrollx\"\n\t}, {\n\t\ttop: 90 - scrollbarInfo.height,\n\t\tleft: 90 - scrollbarInfo.width\n\t}, \"scroll\" );\n\n\t$( \"#scrollx\" ).css( {\n\t\toverflow: \"auto\"\n\t} );\n\n\tcollisionTest( assert, {\n\t\tof: \"#scrollx\",\n\t\tcollision: \"fit\",\n\t\twithin: \"#scrollx\"\n\t}, {\n\t\ttop: 90,\n\t\tleft: 90\n\t}, \"auto, no scroll\" );\n\n\t$( \"#scrollx\" ).css( {\n\t\toverflow: \"auto\"\n\t} ).append( $( \"<div>\" ).height( 300 ).width( 300 ) );\n\n\tcollisionTest( assert, {\n\t\tof: \"#scrollx\",\n\t\tcollision: \"fit\",\n\t\twithin: \"#scrollx\"\n\t}, {\n\t\ttop: 90 - scrollbarInfo.height,\n\t\tleft: 90 - scrollbarInfo.width\n\t}, \"auto, with scroll\" );\n} );\n\nQUnit.test( \"fractions\", function( assert ) {\n\tassert.expect( 1 );\n\n\t$( \"#fractions-element\" ).position( {\n\t\tmy: \"left top\",\n\t\tat: \"left top\",\n\t\tof: \"#fractions-parent\",\n\t\tcollision: \"none\"\n\t} );\n\tassert.deepEqual( $( \"#fractions-element\" ).offset(), $( \"#fractions-parent\" ).offset(), \"left top, left top\" );\n} );\n\nQUnit.test( \"bug #5280: consistent results (avoid fractional values)\", function( assert ) {\n\tassert.expect( 1 );\n\n\tvar wrapper = $( \"#bug-5280\" ),\n\t\telem = wrapper.children(),\n\t\toffset1 = elem.position( {\n\t\t\tmy: \"center\",\n\t\t\tat: \"center\",\n\t\t\tof: wrapper,\n\t\t\tcollision: \"none\"\n\t\t} ).offset(),\n\t\toffset2 = elem.position( {\n\t\t\tmy: \"center\",\n\t\t\tat: \"center\",\n\t\t\tof: wrapper,\n\t\t\tcollision: \"none\"\n\t\t} ).offset();\n\tassert.deepEqual( offset1, offset2 );\n} );\n\nQUnit.test( \"bug #8710: flip if flipped position fits more\", function( assert ) {\n\tassert.expect( 3 );\n\n\t// Positions a 10px tall element within 99px height at top 90px.\n\tcollisionTest( assert, {\n\t\twithin: \"#bug-8710-within-smaller\",\n\t\tof: \"#parentx\",\n\t\tcollision: \"flip\",\n\t\tat: \"right bottom+30\"\n\t}, {\n\t\ttop: 0,\n\t\tleft: 60\n\t}, \"flip - top fits all\" );\n\n\t// Positions a 10px tall element within 99px height at top 92px.\n\tcollisionTest( assert, {\n\t\twithin: \"#bug-8710-within-smaller\",\n\t\tof: \"#parentx\",\n\t\tcollision: \"flip\",\n\t\tat: \"right bottom+32\"\n\t}, {\n\t\ttop: -2,\n\t\tleft: 60\n\t}, \"flip - top fits more\" );\n\n\t// Positions a 10px tall element within 101px height at top 92px.\n\tcollisionTest( assert, {\n\t\twithin: \"#bug-8710-within-bigger\",\n\t\tof: \"#parentx\",\n\t\tcollision: \"flip\",\n\t\tat: \"right bottom+32\"\n\t}, {\n\t\ttop: 92,\n\t\tleft: 60\n\t}, \"no flip - top fits less\" );\n} );\n\n} );\n", "/*!\n * jQuery UI Position @VERSION\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/position/\n */\n\n//>>label: Position\n//>>group: Core\n//>>description: Positions elements relative to other elements.\n//>>docs: http://api.jqueryui.com/position/\n//>>demos: http://jqueryui.com/position/\n\n( function( factory ) {\n\tif ( typeof define === \"function\" && define.amd ) {\n\n\t\t// AMD. Register as an anonymous module.\n\t\tdefine( [ \"jquery\", \"./version\" ], factory );\n\t} else {\n\n\t\t// Browser globals\n\t\tfactory( jQuery );\n\t}\n}( function( $ ) {\n( function() {\nvar cachedScrollbarWidth,\n\tmax = Math.max,\n\tabs = Math.abs,\n\trhorizontal = /left|center|right/,\n\trvertical = /top|center|bottom/,\n\troffset = /[\\+\\-]\\d+(\\.[\\d]+)?%?/,\n\trposition = /^\\w+/,\n\trpercent = /%$/,\n\t_position = $.fn.position;\n\nfunction getOffsets( offsets, width, height ) {\n\treturn [\n\t\tparseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),\n\t\tparseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )\n\t];\n}\n\nfunction parseCss( element, property ) {\n\treturn parseInt( $.css( element, property ), 10 ) || 0;\n}\n\nfunction isWindow( obj ) {\n\treturn obj != null && obj === obj.window;\n}\n\nfunction getDimensions( elem ) {\n\tvar raw = elem[ 0 ];\n\tif ( raw.nodeType === 9 ) {\n\t\treturn {\n\t\t\twidth: elem.width(),\n\t\t\theight: elem.height(),\n\t\t\toffset: { top: 0, left: 0 }\n\t\t};\n\t}\n\tif ( isWindow( raw ) ) {\n\t\treturn {\n\t\t\twidth: elem.width(),\n\t\t\theight: elem.height(),\n\t\t\toffset: { top: elem.scrollTop(), left: elem.scrollLeft() }\n\t\t};\n\t}\n\tif ( raw.preventDefault ) {\n\t\treturn {\n\t\t\twidth: 0,\n\t\t\theight: 0,\n\t\t\toffset: { top: raw.pageY, left: raw.pageX }\n\t\t};\n\t}\n\treturn {\n\t\twidth: elem.outerWidth(),\n\t\theight: elem.outerHeight(),\n\t\toffset: elem.offset()\n\t};\n}\n\n$.position = {\n\tscrollbarWidth: function() {\n\t\tif ( cachedScrollbarWidth !== undefined ) {\n\t\t\treturn cachedScrollbarWidth;\n\t\t}\n\t\tvar w1, w2,\n\t\t\tdiv = $( \"<div style=\" +\n\t\t\t\t\"'display:block;position:absolute;width:200px;height:200px;overflow:hidden;'>\" +\n\t\t\t\t\"<div style='height:300px;width:auto;'></div></div>\" ),\n\t\t\tinnerDiv = div.children()[ 0 ];\n\n\t\t$( \"body\" ).append( div );\n\t\tw1 = innerDiv.offsetWidth;\n\t\tdiv.css( \"overflow\", \"scroll\" );\n\n\t\tw2 = innerDiv.offsetWidth;\n\n\t\tif ( w1 === w2 ) {\n\t\t\tw2 = div[ 0 ].clientWidth;\n\t\t}\n\n\t\tdiv.remove();\n\n\t\treturn ( cachedScrollbarWidth = w1 - w2 );\n\t},\n\tgetScrollInfo: function( within ) {\n\t\tvar overflowX = within.isWindow || within.isDocument ? \"\" :\n\t\t\t\twithin.element.css( \"overflow-x\" ),\n\t\t\toverflowY = within.isWindow || within.isDocument ? \"\" :\n\t\t\t\twithin.element.css( \"overflow-y\" ),\n\t\t\thasOverflowX = overflowX === \"scroll\" ||\n\t\t\t\t( overflowX === \"auto\" && within.width < within.element[ 0 ].scrollWidth ),\n\t\t\thasOverflowY = overflowY === \"scroll\" ||\n\t\t\t\t( overflowY === \"auto\" && within.height < within.element[ 0 ].scrollHeight );\n\t\treturn {\n\t\t\twidth: hasOverflowY ? $.position.scrollbarWidth() : 0,\n\t\t\theight: hasOverflowX ? $.position.scrollbarWidth() : 0\n\t\t};\n\t},\n\tgetWithinInfo: function( element ) {\n\t\tvar withinElement = $( element || window ),\n\t\t\tisElemWindow = isWindow( withinElement[ 0 ] ),\n\t\t\tisDocument = !!withinElement[ 0 ] && withinElement[ 0 ].nodeType === 9,\n\t\t\thasOffset = !isElemWindow && !isDocument;\n\t\treturn {\n\t\t\telement: withinElement,\n\t\t\tisWindow: isElemWindow,\n\t\t\tisDocument: isDocument,\n\t\t\toffset: hasOffset ? $( element ).offset() : { left: 0, top: 0 },\n\t\t\tscrollLeft: withinElement.scrollLeft(),\n\t\t\tscrollTop: withinElement.scrollTop(),\n\t\t\twidth: withinElement.outerWidth(),\n\t\t\theight: withinElement.outerHeight()\n\t\t};\n\t}\n};\n\n$.fn.position = function( options ) {\n\tif ( !options || !options.of ) {\n\t\treturn _position.apply( this, arguments );\n\t}\n\n\t// Make a copy, we don't want to modify arguments\n\toptions = $.extend( {}, options );\n\n\tvar atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,\n\t\ttarget = $( options.of ),\n\t\twithin = $.position.getWithinInfo( options.within ),\n\t\tscrollInfo = $.position.getScrollInfo( within ),\n\t\tcollision = ( options.collision || \"flip\" ).split( \" \" ),\n\t\toffsets = {};\n\n\tdimensions = getDimensions( target );\n\tif ( target[ 0 ].preventDefault ) {\n\n\t\t// Force left top to allow flipping\n\t\toptions.at = \"left top\";\n\t}\n\ttargetWidth = dimensions.width;\n\ttargetHeight = dimensions.height;\n\ttargetOffset = dimensions.offset;\n\n\t// Clone to reuse original targetOffset later\n\tbasePosition = $.extend( {}, targetOffset );\n\n\t// Force my and at to have valid horizontal and vertical positions\n\t// if a value is missing or invalid, it will be converted to center\n\t$.each( [ \"my\", \"at\" ], function() {\n\t\tvar pos = ( options[ this ] || \"\" ).split( \" \" ),\n\t\t\thorizontalOffset,\n\t\t\tverticalOffset;\n\n\t\tif ( pos.length === 1 ) {\n\t\t\tpos = rhorizontal.test( pos[ 0 ] ) ?\n\t\t\t\tpos.concat( [ \"center\" ] ) :\n\t\t\t\trvertical.test( pos[ 0 ] ) ?\n\t\t\t\t\t[ \"center\" ].concat( pos ) :\n\t\t\t\t\t[ \"center\", \"center\" ];\n\t\t}\n\t\tpos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : \"center\";\n\t\tpos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : \"center\";\n\n\t\t// Calculate offsets\n\t\thorizontalOffset = roffset.exec( pos[ 0 ] );\n\t\tverticalOffset = roffset.exec( pos[ 1 ] );\n\t\toffsets[ this ] = [\n\t\t\thorizontalOffset ? horizontalOffset[ 0 ] : 0,\n\t\t\tverticalOffset ? verticalOffset[ 0 ] : 0\n\t\t];\n\n\t\t// Reduce to just the positions without the offsets\n\t\toptions[ this ] = [\n\t\t\trposition.exec( pos[ 0 ] )[ 0 ],\n\t\t\trposition.exec( pos[ 1 ] )[ 0 ]\n\t\t];\n\t} );\n\n\t// Normalize collision option\n\tif ( collision.length === 1 ) {\n\t\tcollision[ 1 ] = collision[ 0 ];\n\t}\n\n\tif ( options.at[ 0 ] === \"right\" ) {\n\t\tbasePosition.left += targetWidth;\n\t} else if ( options.at[ 0 ] === \"center\" ) {\n\t\tbasePosition.left += targetWidth / 2;\n\t}\n\n\tif ( options.at[ 1 ] === \"bottom\" ) {\n\t\tbasePosition.top += targetHeight;\n\t} else if ( options.at[ 1 ] === \"center\" ) {\n\t\tbasePosition.top += targetHeight / 2;\n\t}\n\n\tatOffset = getOffsets( offsets.at, targetWidth, targetHeight );\n\tbasePosition.left += atOffset[ 0 ];\n\tbasePosition.top += atOffset[ 1 ];\n\n\treturn this.each( function() {\n\t\tvar collisionPosition, using,\n\t\t\telem = $( this ),\n\t\t\telemWidth = elem.outerWidth(),\n\t\t\telemHeight = elem.outerHeight(),\n\t\t\tmarginLeft = parseCss( this, \"marginLeft\" ),\n\t\t\tmarginTop = parseCss( this, \"marginTop\" ),\n\t\t\tcollisionWidth = elemWidth + marginLeft + parseCss( this, \"marginRight\" ) +\n\t\t\t\tscrollInfo.width,\n\t\t\tcollisionHeight = elemHeight + marginTop + parseCss( this, \"marginBottom\" ) +\n\t\t\t\tscrollInfo.height,\n\t\t\tposition = $.extend( {}, basePosition ),\n\t\t\tmyOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );\n\n\t\tif ( options.my[ 0 ] === \"right\" ) {\n\t\t\tposition.left -= elemWidth;\n\t\t} else if ( options.my[ 0 ] === \"center\" ) {\n\t\t\tposition.left -= elemWidth / 2;\n\t\t}\n\n\t\tif ( options.my[ 1 ] === \"bottom\" ) {\n\t\t\tposition.top -= elemHeight;\n\t\t} else if ( options.my[ 1 ] === \"center\" ) {\n\t\t\tposition.top -= elemHeight / 2;\n\t\t}\n\n\t\tposition.left += myOffset[ 0 ];\n\t\tposition.top += myOffset[ 1 ];\n\n\t\tcollisionPosition = {\n\t\t\tmarginLeft: marginLeft,\n\t\t\tmarginTop: marginTop\n\t\t};\n\n\t\t$.each( [ \"left\", \"top\" ], function( i, dir ) {\n\t\t\tif ( $.ui.position[ collision[ i ] ] ) {\n\t\t\t\t$.ui.position[ collision[ i ] ][ dir ]( position, {\n\t\t\t\t\ttargetWidth: targetWidth,\n\t\t\t\t\ttargetHeight: targetHeight,\n\t\t\t\t\telemWidth: elemWidth,\n\t\t\t\t\telemHeight: elemHeight,\n\t\t\t\t\tcollisionPosition: collisionPosition,\n\t\t\t\t\tcollisionWidth: collisionWidth,\n\t\t\t\t\tcollisionHeight: collisionHeight,\n\t\t\t\t\toffset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],\n\t\t\t\t\tmy: options.my,\n\t\t\t\t\tat: options.at,\n\t\t\t\t\twithin: within,\n\t\t\t\t\telem: elem\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\n\t\tif ( options.using ) {\n\n\t\t\t// Adds feedback as second argument to using callback, if present\n\t\t\tusing = function( props ) {\n\t\t\t\tvar left = targetOffset.left - position.left,\n\t\t\t\t\tright = left + targetWidth - elemWidth,\n\t\t\t\t\ttop = targetOffset.top - position.top,\n\t\t\t\t\tbottom = top + targetHeight - elemHeight,\n\t\t\t\t\tfeedback = {\n\t\t\t\t\t\ttarget: {\n\t\t\t\t\t\t\telement: target,\n\t\t\t\t\t\t\tleft: targetOffset.left,\n\t\t\t\t\t\t\ttop: targetOffset.top,\n\t\t\t\t\t\t\twidth: targetWidth,\n\t\t\t\t\t\t\theight: targetHeight\n\t\t\t\t\t\t},\n\t\t\t\t\t\telement: {\n\t\t\t\t\t\t\telement: elem,\n\t\t\t\t\t\t\tleft: position.left,\n\t\t\t\t\t\t\ttop: position.top,\n\t\t\t\t\t\t\twidth: elemWidth,\n\t\t\t\t\t\t\theight: elemHeight\n\t\t\t\t\t\t},\n\t\t\t\t\t\thorizontal: right < 0 ? \"left\" : left > 0 ? \"right\" : \"center\",\n\t\t\t\t\t\tvertical: bottom < 0 ? \"top\" : top > 0 ? \"bottom\" : \"middle\"\n\t\t\t\t\t};\n\t\t\t\tif ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {\n\t\t\t\t\tfeedback.horizontal = \"center\";\n\t\t\t\t}\n\t\t\t\tif ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {\n\t\t\t\t\tfeedback.vertical = \"middle\";\n\t\t\t\t}\n\t\t\t\tif ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {\n\t\t\t\t\tfeedback.important = \"horizontal\";\n\t\t\t\t} else {\n\t\t\t\t\tfeedback.important = \"vertical\";\n\t\t\t\t}\n\t\t\t\toptions.using.call( this, props, feedback );\n\t\t\t};\n\t\t}\n\n\t\telem.offset( $.extend( position, { using: using } ) );\n\t} );\n};\n\n$.ui.position = {\n\tfit: {\n\t\tleft: function( position, data ) {\n\t\t\tvar within = data.within,\n\t\t\t\twithinOffset = within.isWindow ? within.scrollLeft : within.offset.left,\n\t\t\t\touterWidth = within.width,\n\t\t\t\tcollisionPosLeft = position.left - data.collisionPosition.marginLeft,\n\t\t\t\toverLeft = withinOffset - collisionPosLeft,\n\t\t\t\toverRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,\n\t\t\t\tnewOverRight;\n\n\t\t\t// Element is wider than within\n\t\t\tif ( data.collisionWidth > outerWidth ) {\n\n\t\t\t\t// Element is initially over the left side of within\n\t\t\t\tif ( overLeft > 0 && overRight <= 0 ) {\n\t\t\t\t\tnewOverRight = position.left + overLeft + data.collisionWidth - outerWidth -\n\t\t\t\t\t\twithinOffset;\n\t\t\t\t\tposition.left += overLeft - newOverRight;\n\n\t\t\t\t// Element is initially over right side of within\n\t\t\t\t} else if ( overRight > 0 && overLeft <= 0 ) {\n\t\t\t\t\tposition.left = withinOffset;\n\n\t\t\t\t// Element is initially over both left and right sides of within\n\t\t\t\t} else {\n\t\t\t\t\tif ( overLeft > overRight ) {\n\t\t\t\t\t\tposition.left = withinOffset + outerWidth - data.collisionWidth;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tposition.left = withinOffset;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Too far left -> align with left edge\n\t\t\t} else if ( overLeft > 0 ) {\n\t\t\t\tposition.left += overLeft;\n\n\t\t\t// Too far right -> align with right edge\n\t\t\t} else if ( overRight > 0 ) {\n\t\t\t\tposition.left -= overRight;\n\n\t\t\t// Adjust based on position and margin\n\t\t\t} else {\n\t\t\t\tposition.left = max( position.left - collisionPosLeft, position.left );\n\t\t\t}\n\t\t},\n\t\ttop: function( position, data ) {\n\t\t\tvar within = data.within,\n\t\t\t\twithinOffset = within.isWindow ? within.scrollTop : within.offset.top,\n\t\t\t\touterHeight = data.within.height,\n\t\t\t\tcollisionPosTop = position.top - data.collisionPosition.marginTop,\n\t\t\t\toverTop = withinOffset - collisionPosTop,\n\t\t\t\toverBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,\n\t\t\t\tnewOverBottom;\n\n\t\t\t// Element is taller than within\n\t\t\tif ( data.collisionHeight > outerHeight ) {\n\n\t\t\t\t// Element is initially over the top of within\n\t\t\t\tif ( overTop > 0 && overBottom <= 0 ) {\n\t\t\t\t\tnewOverBottom = position.top + overTop + data.collisionHeight - outerHeight -\n\t\t\t\t\t\twithinOffset;\n\t\t\t\t\tposition.top += overTop - newOverBottom;\n\n\t\t\t\t// Element is initially over bottom of within\n\t\t\t\t} else if ( overBottom > 0 && overTop <= 0 ) {\n\t\t\t\t\tposition.top = withinOffset;\n\n\t\t\t\t// Element is initially over both top and bottom of within\n\t\t\t\t} else {\n\t\t\t\t\tif ( overTop > overBottom ) {\n\t\t\t\t\t\tposition.top = withinOffset + outerHeight - data.collisionHeight;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tposition.top = withinOffset;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Too far up -> align with top\n\t\t\t} else if ( overTop > 0 ) {\n\t\t\t\tposition.top += overTop;\n\n\t\t\t// Too far down -> align with bottom edge\n\t\t\t} else if ( overBottom > 0 ) {\n\t\t\t\tposition.top -= overBottom;\n\n\t\t\t// Adjust based on position and margin\n\t\t\t} else {\n\t\t\t\tposition.top = max( position.top - collisionPosTop, position.top );\n\t\t\t}\n\t\t}\n\t},\n\tflip: {\n\t\tleft: function( position, data ) {\n\t\t\tvar within = data.within,\n\t\t\t\twithinOffset = within.offset.left + within.scrollLeft,\n\t\t\t\touterWidth = within.width,\n\t\t\t\toffsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,\n\t\t\t\tcollisionPosLeft = position.left - data.collisionPosition.marginLeft,\n\t\t\t\toverLeft = collisionPosLeft - offsetLeft,\n\t\t\t\toverRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,\n\t\t\t\tmyOffset = data.my[ 0 ] === \"left\" ?\n\t\t\t\t\t-data.elemWidth :\n\t\t\t\t\tdata.my[ 0 ] === \"right\" ?\n\t\t\t\t\t\tdata.elemWidth :\n\t\t\t\t\t\t0,\n\t\t\t\tatOffset = data.at[ 0 ] === \"left\" ?\n\t\t\t\t\tdata.targetWidth :\n\t\t\t\t\tdata.at[ 0 ] === \"right\" ?\n\t\t\t\t\t\t-data.targetWidth :\n\t\t\t\t\t\t0,\n\t\t\t\toffset = -2 * data.offset[ 0 ],\n\t\t\t\tnewOverRight,\n\t\t\t\tnewOverLeft;\n\n\t\t\tif ( overLeft < 0 ) {\n\t\t\t\tnewOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth -\n\t\t\t\t\touterWidth - withinOffset;\n\t\t\t\tif ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {\n\t\t\t\t\tposition.left += myOffset + atOffset + offset;\n\t\t\t\t}\n\t\t\t} else if ( overRight > 0 ) {\n\t\t\t\tnewOverLeft = position.left - data.collisionPosition.marginLeft + myOffset +\n\t\t\t\t\tatOffset + offset - offsetLeft;\n\t\t\t\tif ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {\n\t\t\t\t\tposition.left += myOffset + atOffset + offset;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\ttop: function( position, data ) {\n\t\t\tvar within = data.within,\n\t\t\t\twithinOffset = within.offset.top + within.scrollTop,\n\t\t\t\touterHeight = within.height,\n\t\t\t\toffsetTop = within.isWindow ? within.scrollTop : within.offset.top,\n\t\t\t\tcollisionPosTop = position.top - data.collisionPosition.marginTop,\n\t\t\t\toverTop = collisionPosTop - offsetTop,\n\t\t\t\toverBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,\n\t\t\t\ttop = data.my[ 1 ] === \"top\",\n\t\t\t\tmyOffset = top ?\n\t\t\t\t\t-data.elemHeight :\n\t\t\t\t\tdata.my[ 1 ] === \"bottom\" ?\n\t\t\t\t\t\tdata.elemHeight :\n\t\t\t\t\t\t0,\n\t\t\t\tatOffset = data.at[ 1 ] === \"top\" ?\n\t\t\t\t\tdata.targetHeight :\n\t\t\t\t\tdata.at[ 1 ] === \"bottom\" ?\n\t\t\t\t\t\t-data.targetHeight :\n\t\t\t\t\t\t0,\n\t\t\t\toffset = -2 * data.offset[ 1 ],\n\t\t\t\tnewOverTop,\n\t\t\t\tnewOverBottom;\n\t\t\tif ( overTop < 0 ) {\n\t\t\t\tnewOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight -\n\t\t\t\t\touterHeight - withinOffset;\n\t\t\t\tif ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) {\n\t\t\t\t\tposition.top += myOffset + atOffset + offset;\n\t\t\t\t}\n\t\t\t} else if ( overBottom > 0 ) {\n\t\t\t\tnewOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset +\n\t\t\t\t\toffset - offsetTop;\n\t\t\t\tif ( newOverTop > 0 || abs( newOverTop ) < overBottom ) {\n\t\t\t\t\tposition.top += myOffset + atOffset + offset;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tflipfit: {\n\t\tleft: function() {\n\t\t\t$.ui.position.flip.left.apply( this, arguments );\n\t\t\t$.ui.position.fit.left.apply( this, arguments );\n\t\t},\n\t\ttop: function() {\n\t\t\t$.ui.position.flip.top.apply( this, arguments );\n\t\t\t$.ui.position.fit.top.apply( this, arguments );\n\t\t}\n\t}\n};\n\n} )();\n\nreturn $.ui.position;\n\n} ) );\n"], "fixing_code": ["define( [\n\t\"qunit\",\n\t\"jquery\",\n\t\"lib/common\",\n\t\"lib/helper\",\n\t\"ui/position\"\n], function( QUnit, $, common, helper ) {\n\nvar win = $( window ),\n\tscrollTopSupport = function() {\n\t\tvar support = win.scrollTop( 1 ).scrollTop() === 1;\n\t\twin.scrollTop( 0 );\n\t\tscrollTopSupport = function() {\n\t\t\treturn support;\n\t\t};\n\t\treturn support;\n\t};\n\nQUnit.module( \"position\", {\n\tbeforeEach: function() {\n\t\twin.scrollTop( 0 ).scrollLeft( 0 );\n\t},\n\tafterEach: helper.moduleAfterEach\n} );\n\ncommon.testJshint( \"position\" );\n\nQUnit.test( \"my, at, of\", function( assert ) {\n\tassert.expect( 4 );\n\n\t$( \"#elx\" ).position( {\n\t\tmy: \"left top\",\n\t\tat: \"left top\",\n\t\tof: \"#parentx\",\n\t\tcollision: \"none\"\n\t} );\n\tassert.deepEqual( $( \"#elx\" ).offset(), { top: 40, left: 40 }, \"left top, left top\" );\n\n\t$( \"#elx\" ).position( {\n\t\tmy: \"left top\",\n\t\tat: \"left bottom\",\n\t\tof: \"#parentx\",\n\t\tcollision: \"none\"\n\t} );\n\tassert.deepEqual( $( \"#elx\" ).offset(), { top: 60, left: 40 }, \"left top, left bottom\" );\n\n\t$( \"#elx\" ).position( {\n\t\tmy: \"left\",\n\t\tat: \"bottom\",\n\t\tof: \"#parentx\",\n\t\tcollision: \"none\"\n\t} );\n\tassert.deepEqual( $( \"#elx\" ).offset(), { top: 55, left: 50 }, \"left, bottom\" );\n\n\t$( \"#elx\" ).position( {\n\t\tmy: \"left foo\",\n\t\tat: \"bar baz\",\n\t\tof: \"#parentx\",\n\t\tcollision: \"none\"\n\t} );\n\tassert.deepEqual( $( \"#elx\" ).offset(), { top: 45, left: 50 }, \"left foo, bar baz\" );\n} );\n\nQUnit.test( \"multiple elements\", function( assert ) {\n\tassert.expect( 3 );\n\n\tvar elements = $( \"#el1, #el2\" ),\n\t\tresult = elements.position( {\n\t\t\tmy: \"left top\",\n\t\t\tat: \"left bottom\",\n\t\t\tof: \"#parent\",\n\t\t\tcollision: \"none\"\n\t\t} ),\n\t\texpected = { top: 10, left: 4 };\n\n\tassert.deepEqual( result, elements );\n\telements.each( function() {\n\t\tassert.deepEqual( $( this ).offset(), expected );\n\t} );\n} );\n\nQUnit.test( \"positions\", function( assert ) {\n\tassert.expect( 18 );\n\n\tvar offsets = {\n\t\t\tleft: 0,\n\t\t\tcenter: 3,\n\t\t\tright: 6,\n\t\t\ttop: 0,\n\t\t\tbottom: 6\n\t\t},\n\t\tstart = { left: 4, top: 4 },\n\t\tel = $( \"#el1\" );\n\n\t$.each( [ 0, 1 ], function( my ) {\n\t\t$.each( [ \"top\", \"center\", \"bottom\" ], function( vindex, vertical ) {\n\t\t\t$.each( [ \"left\", \"center\", \"right\" ], function( hindex, horizontal ) {\n\t\t\t\tvar _my = my ? horizontal + \" \" + vertical : \"left top\",\n\t\t\t\t\t_at = !my ? horizontal + \" \" + vertical : \"left top\";\n\t\t\t\tel.position( {\n\t\t\t\t\tmy: _my,\n\t\t\t\t\tat: _at,\n\t\t\t\t\tof: \"#parent\",\n\t\t\t\t\tcollision: \"none\"\n\t\t\t\t} );\n\t\t\t\tassert.deepEqual( el.offset(), {\n\t\t\t\t\ttop: start.top + offsets[ vertical ] * ( my ? -1 : 1 ),\n\t\t\t\t\tleft: start.left + offsets[ horizontal ] * ( my ? -1 : 1 )\n\t\t\t\t}, \"Position via \" + QUnit.jsDump.parse( { my: _my, at: _at } ) );\n\t\t\t} );\n\t\t} );\n\t} );\n} );\n\nQUnit.test( \"of\", function( assert ) {\n\tassert.expect( 10 + ( scrollTopSupport() ? 1 : 0 ) );\n\n\tvar done = assert.async();\n\n\tvar event;\n\n\t$( \"#elx\" ).position( {\n\t\tmy: \"left top\",\n\t\tat: \"left top\",\n\t\tof: \"#parentx\",\n\t\tcollision: \"none\"\n\t} );\n\tassert.deepEqual( $( \"#elx\" ).offset(), { top: 40, left: 40 }, \"selector\" );\n\n\t$( \"#elx\" ).position( {\n\t\tmy: \"left top\",\n\t\tat: \"left bottom\",\n\t\tof: $( \"#parentx\" ),\n\t\tcollision: \"none\"\n\t} );\n\tassert.deepEqual( $( \"#elx\" ).offset(), { top: 60, left: 40 }, \"jQuery object\" );\n\n\t$( \"#elx\" ).position( {\n\t\tmy: \"left top\",\n\t\tat: \"left top\",\n\t\tof: $( \"#parentx\" )[ 0 ],\n\t\tcollision: \"none\"\n\t} );\n\tassert.deepEqual( $( \"#elx\" ).offset(), { top: 40, left: 40 }, \"DOM element\" );\n\n\t$( \"#elx\" ).position( {\n\t\tmy: \"right bottom\",\n\t\tat: \"right bottom\",\n\t\tof: document,\n\t\tcollision: \"none\"\n\t} );\n\tassert.deepEqual( $( \"#elx\" ).offset(), {\n\t\ttop: $( document ).height() - 10,\n\t\tleft: $( document ).width() - 10\n\t}, \"document\" );\n\n\t$( \"#elx\" ).position( {\n\t\tmy: \"right bottom\",\n\t\tat: \"right bottom\",\n\t\tof: $( document ),\n\t\tcollision: \"none\"\n\t} );\n\tassert.deepEqual( $( \"#elx\" ).offset(), {\n\t\ttop: $( document ).height() - 10,\n\t\tleft: $( document ).width() - 10\n\t}, \"document as jQuery object\" );\n\n\twin.scrollTop( 0 );\n\n\t$( \"#elx\" ).position( {\n\t\tmy: \"right bottom\",\n\t\tat: \"right bottom\",\n\t\tof: window,\n\t\tcollision: \"none\"\n\t} );\n\tassert.deepEqual( $( \"#elx\" ).offset(), {\n\t\ttop: win.height() - 10,\n\t\tleft: win.width() - 10\n\t}, \"window\" );\n\n\t$( \"#elx\" ).position( {\n\t\tmy: \"right bottom\",\n\t\tat: \"right bottom\",\n\t\tof: win,\n\t\tcollision: \"none\"\n\t} );\n\tassert.deepEqual( $( \"#elx\" ).offset(), {\n\t\ttop: win.height() - 10,\n\t\tleft: win.width() - 10\n\t}, \"window as jQuery object\" );\n\n\tif ( scrollTopSupport() ) {\n\t\twin.scrollTop( 500 ).scrollLeft( 200 );\n\t\t$( \"#elx\" ).position( {\n\t\t\tmy: \"right bottom\",\n\t\t\tat: \"right bottom\",\n\t\t\tof: window,\n\t\t\tcollision: \"none\"\n\t\t} );\n\t\tassert.deepEqual( $( \"#elx\" ).offset(), {\n\t\t\ttop: win.height() + 500 - 10,\n\t\t\tleft: win.width() + 200 - 10\n\t\t}, \"window, scrolled\" );\n\t\twin.scrollTop( 0 ).scrollLeft( 0 );\n\t}\n\n\tevent = $.extend( $.Event( \"someEvent\" ), { pageX: 200, pageY: 300 } );\n\t$( \"#elx\" ).position( {\n\t\tmy: \"left top\",\n\t\tat: \"left top\",\n\t\tof: event,\n\t\tcollision: \"none\"\n\t} );\n\tassert.deepEqual( $( \"#elx\" ).offset(), {\n\t\ttop: 300,\n\t\tleft: 200\n\t}, \"event - left top, left top\" );\n\n\tevent = $.extend( $.Event( \"someEvent\" ), { pageX: 400, pageY: 600 } );\n\t$( \"#elx\" ).position( {\n\t\tmy: \"left top\",\n\t\tat: \"right bottom\",\n\t\tof: event,\n\t\tcollision: \"none\"\n\t} );\n\tassert.deepEqual( $( \"#elx\" ).offset(), {\n\t\ttop: 600,\n\t\tleft: 400\n\t}, \"event - left top, right bottom\" );\n\n\ttry {\n\t\t$( \"#elx\" ).position( {\n\t\t\tmy: \"left top\",\n\t\t\tat: \"right bottom\",\n\t\t\tof: \"<img onerror='window.globalOf=true' src='/404' />\",\n\t\t\tcollision: \"none\"\n\t\t} );\n\t} catch ( e ) {}\n\n\tsetTimeout( function() {\n\t\tassert.equal( window.globalOf, undefined, \"of treated as a selector\" );\n\t\tdelete window.globalOf;\n\t\tdone();\n\t}, 500 );\n} );\n\nQUnit.test( \"offsets\", function( assert ) {\n\tassert.expect( 9 );\n\n\tvar offset;\n\n\t$( \"#elx\" ).position( {\n\t\tmy: \"left top\",\n\t\tat: \"left+10 bottom+10\",\n\t\tof: \"#parentx\",\n\t\tcollision: \"none\"\n\t} );\n\tassert.deepEqual( $( \"#elx\" ).offset(), { top: 70, left: 50 }, \"offsets in at\" );\n\n\t$( \"#elx\" ).position( {\n\t\tmy: \"left+10 top-10\",\n\t\tat: \"left bottom\",\n\t\tof: \"#parentx\",\n\t\tcollision: \"none\"\n\t} );\n\tassert.deepEqual( $( \"#elx\" ).offset(), { top: 50, left: 50 }, \"offsets in my\" );\n\n\t$( \"#elx\" ).position( {\n\t\tmy: \"left top\",\n\t\tat: \"left+50% bottom-10%\",\n\t\tof: \"#parentx\",\n\t\tcollision: \"none\"\n\t} );\n\tassert.deepEqual( $( \"#elx\" ).offset(), { top: 58, left: 50 }, \"percentage offsets in at\" );\n\n\t$( \"#elx\" ).position( {\n\t\tmy: \"left-30% top+50%\",\n\t\tat: \"left bottom\",\n\t\tof: \"#parentx\",\n\t\tcollision: \"none\"\n\t} );\n\tassert.deepEqual( $( \"#elx\" ).offset(), { top: 65, left: 37 }, \"percentage offsets in my\" );\n\n\t$( \"#elx\" ).position( {\n\t\tmy: \"left-30.001% top+50.0%\",\n\t\tat: \"left bottom\",\n\t\tof: \"#parentx\",\n\t\tcollision: \"none\"\n\t} );\n\toffset = $( \"#elx\" ).offset();\n\tassert.equal( Math.round( offset.top ), 65, \"decimal percentage offsets in my\" );\n\tassert.equal( Math.round( offset.left ), 37, \"decimal percentage offsets in my\" );\n\n\t$( \"#elx\" ).position( {\n\t\tmy: \"left+10.4 top-10.6\",\n\t\tat: \"left bottom\",\n\t\tof: \"#parentx\",\n\t\tcollision: \"none\"\n\t} );\n\toffset = $( \"#elx\" ).offset();\n\tassert.equal( Math.round( offset.top ), 49, \"decimal offsets in my\" );\n\tassert.equal( Math.round( offset.left ), 50, \"decimal offsets in my\" );\n\n\t$( \"#elx\" ).position( {\n\t\tmy: \"left+right top-left\",\n\t\tat: \"left-top bottom-bottom\",\n\t\tof: \"#parentx\",\n\t\tcollision: \"none\"\n\t} );\n\tassert.deepEqual( $( \"#elx\" ).offset(), { top: 60, left: 40 }, \"invalid offsets\" );\n} );\n\nQUnit.test( \"using\", function( assert ) {\n\tassert.expect( 10 );\n\n\tvar count = 0,\n\t\telems = $( \"#el1, #el2\" ),\n\t\tof = $( \"#parentx\" ),\n\t\texpectedPosition = { top: 60, left: 60 },\n\t\texpectedFeedback = {\n\t\t\ttarget: {\n\t\t\t\telement: of,\n\t\t\t\twidth: 20,\n\t\t\t\theight: 20,\n\t\t\t\tleft: 40,\n\t\t\t\ttop: 40\n\t\t\t},\n\t\t\telement: {\n\t\t\t\twidth: 6,\n\t\t\t\theight: 6,\n\t\t\t\tleft: 60,\n\t\t\t\ttop: 60\n\t\t\t},\n\t\t\thorizontal: \"left\",\n\t\t\tvertical: \"top\",\n\t\t\timportant: \"vertical\"\n\t\t},\n\t\toriginalPosition = elems.position( {\n\t\t\tmy: \"right bottom\",\n\t\t\tat: \"rigt bottom\",\n\t\t\tof: \"#parentx\",\n\t\t\tcollision: \"none\"\n\t\t} ).offset();\n\n\telems.position( {\n\t\tmy: \"left top\",\n\t\tat: \"center+10 bottom\",\n\t\tof: \"#parentx\",\n\t\tusing: function( position, feedback ) {\n\t\t\tassert.deepEqual( this, elems[ count ], \"correct context for call #\" + count );\n\t\t\tassert.deepEqual( position, expectedPosition, \"correct position for call #\" + count );\n\t\t\tassert.deepEqual( feedback.element.element[ 0 ], elems[ count ] );\n\t\t\tdelete feedback.element.element;\n\t\t\tdelete feedback.target.element.prevObject;\n\t\t\tassert.deepEqual( feedback, expectedFeedback );\n\t\t\tcount++;\n\t\t}\n\t} );\n\n\telems.each( function() {\n\t\tassert.deepEqual( $( this ).offset(), originalPosition, \"elements not moved\" );\n\t} );\n} );\n\nfunction collisionTest( assert, config, result, msg ) {\n\tvar elem = $( \"#elx\" ).position( $.extend( {\n\t\tmy: \"left top\",\n\t\tat: \"right bottom\",\n\t\tof: \"#parent\"\n\t}, config ) );\n\tassert.deepEqual( elem.offset(), result, msg );\n}\n\nfunction collisionTest2( assert, config, result, msg ) {\n\tcollisionTest( assert, $.extend( {\n\t\tmy: \"right bottom\",\n\t\tat: \"left top\"\n\t}, config ), result, msg );\n}\n\nQUnit.test( \"collision: fit, no collision\", function( assert ) {\n\tassert.expect( 2 );\n\n\tcollisionTest( assert, {\n\t\tcollision: \"fit\"\n\t}, {\n\t\ttop: 10,\n\t\tleft: 10\n\t}, \"no offset\" );\n\n\tcollisionTest( assert, {\n\t\tcollision: \"fit\",\n\t\tat: \"right+2 bottom+3\"\n\t}, {\n\t\ttop: 13,\n\t\tleft: 12\n\t}, \"with offset\" );\n} );\n\n// Currently failing in IE8 due to the iframe used by TestSwarm\nif ( !/msie [\\w.]+/.exec( navigator.userAgent.toLowerCase() ) ) {\nQUnit.test( \"collision: fit, collision\", function( assert ) {\n\tassert.expect( 2 + ( scrollTopSupport() ? 1 : 0 ) );\n\n\tcollisionTest2( assert, {\n\t\tcollision: \"fit\"\n\t}, {\n\t\ttop: 0,\n\t\tleft: 0\n\t}, \"no offset\" );\n\n\tcollisionTest2( assert, {\n\t\tcollision: \"fit\",\n\t\tat: \"left+2 top+3\"\n\t}, {\n\t\ttop: 0,\n\t\tleft: 0\n\t}, \"with offset\" );\n\n\tif ( scrollTopSupport() ) {\n\t\twin.scrollTop( 300 ).scrollLeft( 200 );\n\t\tcollisionTest( assert, {\n\t\t\tcollision: \"fit\"\n\t\t}, {\n\t\t\ttop: 300,\n\t\t\tleft: 200\n\t\t}, \"window scrolled\" );\n\n\t\twin.scrollTop( 0 ).scrollLeft( 0 );\n\t}\n} );\n}\n\nQUnit.test( \"collision: flip, no collision\", function( assert ) {\n\tassert.expect( 2 );\n\n\tcollisionTest( assert, {\n\t\tcollision: \"flip\"\n\t}, {\n\t\ttop: 10,\n\t\tleft: 10\n\t}, \"no offset\" );\n\n\tcollisionTest( assert, {\n\t\tcollision: \"flip\",\n\t\tat: \"right+2 bottom+3\"\n\t}, {\n\t\ttop: 13,\n\t\tleft: 12\n\t}, \"with offset\" );\n} );\n\nQUnit.test( \"collision: flip, collision\", function( assert ) {\n\tassert.expect( 2 );\n\n\tcollisionTest2( assert, {\n\t\tcollision: \"flip\"\n\t}, {\n\t\ttop: 10,\n\t\tleft: 10\n\t}, \"no offset\" );\n\n\tcollisionTest2( assert, {\n\t\tcollision: \"flip\",\n\t\tat: \"left+2 top+3\"\n\t}, {\n\t\ttop: 7,\n\t\tleft: 8\n\t}, \"with offset\" );\n} );\n\nQUnit.test( \"collision: flipfit, no collision\", function( assert ) {\n\tassert.expect( 2 );\n\n\tcollisionTest( assert, {\n\t\tcollision: \"flipfit\"\n\t}, {\n\t\ttop: 10,\n\t\tleft: 10\n\t}, \"no offset\" );\n\n\tcollisionTest( assert, {\n\t\tcollision: \"flipfit\",\n\t\tat: \"right+2 bottom+3\"\n\t}, {\n\t\ttop: 13,\n\t\tleft: 12\n\t}, \"with offset\" );\n} );\n\nQUnit.test( \"collision: flipfit, collision\", function( assert ) {\n\tassert.expect( 2 );\n\n\tcollisionTest2( assert, {\n\t\tcollision: \"flipfit\"\n\t}, {\n\t\ttop: 10,\n\t\tleft: 10\n\t}, \"no offset\" );\n\n\tcollisionTest2( assert, {\n\t\tcollision: \"flipfit\",\n\t\tat: \"left+2 top+3\"\n\t}, {\n\t\ttop: 7,\n\t\tleft: 8\n\t}, \"with offset\" );\n} );\n\nQUnit.test( \"collision: none, no collision\", function( assert ) {\n\tassert.expect( 2 );\n\n\tcollisionTest( assert, {\n\t\tcollision: \"none\"\n\t}, {\n\t\ttop: 10,\n\t\tleft: 10\n\t}, \"no offset\" );\n\n\tcollisionTest( assert, {\n\t\tcollision: \"none\",\n\t\tat: \"right+2 bottom+3\"\n\t}, {\n\t\ttop: 13,\n\t\tleft: 12\n\t}, \"with offset\" );\n} );\n\nQUnit.test( \"collision: none, collision\", function( assert ) {\n\tassert.expect( 2 );\n\n\tcollisionTest2( assert, {\n\t\tcollision: \"none\"\n\t}, {\n\t\ttop: -6,\n\t\tleft: -6\n\t}, \"no offset\" );\n\n\tcollisionTest2( assert, {\n\t\tcollision: \"none\",\n\t\tat: \"left+2 top+3\"\n\t}, {\n\t\ttop: -3,\n\t\tleft: -4\n\t}, \"with offset\" );\n} );\n\nQUnit.test( \"collision: fit, with margin\", function( assert ) {\n\tassert.expect( 2 );\n\n\t$( \"#elx\" ).css( {\n\t\tmarginTop: 6,\n\t\tmarginLeft: 4\n\t} );\n\n\tcollisionTest( assert, {\n\t\tcollision: \"fit\"\n\t}, {\n\t\ttop: 10,\n\t\tleft: 10\n\t}, \"right bottom\" );\n\n\tcollisionTest2( assert, {\n\t\tcollision: \"fit\"\n\t}, {\n\t\ttop: 6,\n\t\tleft: 4\n\t}, \"left top\" );\n} );\n\nQUnit.test( \"collision: flip, with margin\", function( assert ) {\n\tassert.expect( 3 );\n\n\t$( \"#elx\" ).css( {\n\t\tmarginTop: 6,\n\t\tmarginLeft: 4\n\t} );\n\n\tcollisionTest( assert, {\n\t\tcollision: \"flip\"\n\t}, {\n\t\ttop: 10,\n\t\tleft: 10\n\t}, \"left top\" );\n\n\tcollisionTest2( assert, {\n\t\tcollision: \"flip\"\n\t}, {\n\t\ttop: 10,\n\t\tleft: 10\n\t}, \"right bottom\" );\n\n\tcollisionTest2( assert, {\n\t\tcollision: \"flip\",\n\t\tmy: \"left top\"\n\t}, {\n\t\ttop: 0,\n\t\tleft: 4\n\t}, \"right bottom\" );\n} );\n\nQUnit.test( \"within\", function( assert ) {\n\tassert.expect( 7 );\n\n\tcollisionTest( assert, {\n\t\twithin: document\n\t}, {\n\t\ttop: 10,\n\t\tleft: 10\n\t}, \"within document\" );\n\n\tcollisionTest( assert, {\n\t\twithin: \"#within\",\n\t\tcollision: \"fit\"\n\t}, {\n\t\ttop: 4,\n\t\tleft: 2\n\t}, \"fit - right bottom\" );\n\n\tcollisionTest2( assert, {\n\t\twithin: \"#within\",\n\t\tcollision: \"fit\"\n\t}, {\n\t\ttop: 2,\n\t\tleft: 0\n\t}, \"fit - left top\" );\n\n\tcollisionTest( assert, {\n\t\twithin: \"#within\",\n\t\tcollision: \"flip\"\n\t}, {\n\t\ttop: 10,\n\t\tleft: -6\n\t}, \"flip - right bottom\" );\n\n\tcollisionTest2( assert, {\n\t\twithin: \"#within\",\n\t\tcollision: \"flip\"\n\t}, {\n\t\ttop: 10,\n\t\tleft: -6\n\t}, \"flip - left top\" );\n\n\tcollisionTest( assert, {\n\t\twithin: \"#within\",\n\t\tcollision: \"flipfit\"\n\t}, {\n\t\ttop: 4,\n\t\tleft: 0\n\t}, \"flipfit - right bottom\" );\n\n\tcollisionTest2( assert, {\n\t\twithin: \"#within\",\n\t\tcollision: \"flipfit\"\n\t}, {\n\t\ttop: 4,\n\t\tleft: 0\n\t}, \"flipfit - left top\" );\n} );\n\n// jQuery 3.2 incorrectly handle scrollbars in WebKit/Blink-based browsers.\n// This is fixed in version 3.3, see https://github.com/jquery/jquery/issues/3589.\n// As the data here comes from jQuery directly and the changes to fix it\n// are non-trivial: https://github.com/jquery/jquery/pull/3656, just accept\n// that scrollbar data in this jQuery version is inaccurate.\nQUnit[ jQuery.fn.jquery.substring( 0, 4 ) === \"3.2.\" ? \"skip\" : \"test\" ](\n\t\"with scrollbars\", function( assert ) {\n\tassert.expect( 4 );\n\n\t$( \"#scrollx\" ).css( {\n\t\twidth: 100,\n\t\theight: 100,\n\t\tleft: 0,\n\t\ttop: 0\n\t} );\n\n\tcollisionTest( assert, {\n\t\tof: \"#scrollx\",\n\t\tcollision: \"fit\",\n\t\twithin: \"#scrollx\"\n\t}, {\n\t\ttop: 90,\n\t\tleft: 90\n\t}, \"visible\" );\n\n\t$( \"#scrollx\" ).css( {\n\t\toverflow: \"scroll\"\n\t} );\n\n\tvar scrollbarInfo = $.position.getScrollInfo( $.position.getWithinInfo( $( \"#scrollx\" ) ) );\n\n\tcollisionTest( assert, {\n\t\tof: \"#scrollx\",\n\t\tcollision: \"fit\",\n\t\twithin: \"#scrollx\"\n\t}, {\n\t\ttop: 90 - scrollbarInfo.height,\n\t\tleft: 90 - scrollbarInfo.width\n\t}, \"scroll\" );\n\n\t$( \"#scrollx\" ).css( {\n\t\toverflow: \"auto\"\n\t} );\n\n\tcollisionTest( assert, {\n\t\tof: \"#scrollx\",\n\t\tcollision: \"fit\",\n\t\twithin: \"#scrollx\"\n\t}, {\n\t\ttop: 90,\n\t\tleft: 90\n\t}, \"auto, no scroll\" );\n\n\t$( \"#scrollx\" ).css( {\n\t\toverflow: \"auto\"\n\t} ).append( $( \"<div>\" ).height( 300 ).width( 300 ) );\n\n\tcollisionTest( assert, {\n\t\tof: \"#scrollx\",\n\t\tcollision: \"fit\",\n\t\twithin: \"#scrollx\"\n\t}, {\n\t\ttop: 90 - scrollbarInfo.height,\n\t\tleft: 90 - scrollbarInfo.width\n\t}, \"auto, with scroll\" );\n} );\n\nQUnit.test( \"fractions\", function( assert ) {\n\tassert.expect( 1 );\n\n\t$( \"#fractions-element\" ).position( {\n\t\tmy: \"left top\",\n\t\tat: \"left top\",\n\t\tof: \"#fractions-parent\",\n\t\tcollision: \"none\"\n\t} );\n\tassert.deepEqual( $( \"#fractions-element\" ).offset(), $( \"#fractions-parent\" ).offset(), \"left top, left top\" );\n} );\n\nQUnit.test( \"bug #5280: consistent results (avoid fractional values)\", function( assert ) {\n\tassert.expect( 1 );\n\n\tvar wrapper = $( \"#bug-5280\" ),\n\t\telem = wrapper.children(),\n\t\toffset1 = elem.position( {\n\t\t\tmy: \"center\",\n\t\t\tat: \"center\",\n\t\t\tof: wrapper,\n\t\t\tcollision: \"none\"\n\t\t} ).offset(),\n\t\toffset2 = elem.position( {\n\t\t\tmy: \"center\",\n\t\t\tat: \"center\",\n\t\t\tof: wrapper,\n\t\t\tcollision: \"none\"\n\t\t} ).offset();\n\tassert.deepEqual( offset1, offset2 );\n} );\n\nQUnit.test( \"bug #8710: flip if flipped position fits more\", function( assert ) {\n\tassert.expect( 3 );\n\n\t// Positions a 10px tall element within 99px height at top 90px.\n\tcollisionTest( assert, {\n\t\twithin: \"#bug-8710-within-smaller\",\n\t\tof: \"#parentx\",\n\t\tcollision: \"flip\",\n\t\tat: \"right bottom+30\"\n\t}, {\n\t\ttop: 0,\n\t\tleft: 60\n\t}, \"flip - top fits all\" );\n\n\t// Positions a 10px tall element within 99px height at top 92px.\n\tcollisionTest( assert, {\n\t\twithin: \"#bug-8710-within-smaller\",\n\t\tof: \"#parentx\",\n\t\tcollision: \"flip\",\n\t\tat: \"right bottom+32\"\n\t}, {\n\t\ttop: -2,\n\t\tleft: 60\n\t}, \"flip - top fits more\" );\n\n\t// Positions a 10px tall element within 101px height at top 92px.\n\tcollisionTest( assert, {\n\t\twithin: \"#bug-8710-within-bigger\",\n\t\tof: \"#parentx\",\n\t\tcollision: \"flip\",\n\t\tat: \"right bottom+32\"\n\t}, {\n\t\ttop: 92,\n\t\tleft: 60\n\t}, \"no flip - top fits less\" );\n} );\n\n} );\n", "/*!\n * jQuery UI Position @VERSION\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/position/\n */\n\n//>>label: Position\n//>>group: Core\n//>>description: Positions elements relative to other elements.\n//>>docs: http://api.jqueryui.com/position/\n//>>demos: http://jqueryui.com/position/\n\n( function( factory ) {\n\tif ( typeof define === \"function\" && define.amd ) {\n\n\t\t// AMD. Register as an anonymous module.\n\t\tdefine( [ \"jquery\", \"./version\" ], factory );\n\t} else {\n\n\t\t// Browser globals\n\t\tfactory( jQuery );\n\t}\n}( function( $ ) {\n( function() {\nvar cachedScrollbarWidth,\n\tmax = Math.max,\n\tabs = Math.abs,\n\trhorizontal = /left|center|right/,\n\trvertical = /top|center|bottom/,\n\troffset = /[\\+\\-]\\d+(\\.[\\d]+)?%?/,\n\trposition = /^\\w+/,\n\trpercent = /%$/,\n\t_position = $.fn.position;\n\nfunction getOffsets( offsets, width, height ) {\n\treturn [\n\t\tparseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),\n\t\tparseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )\n\t];\n}\n\nfunction parseCss( element, property ) {\n\treturn parseInt( $.css( element, property ), 10 ) || 0;\n}\n\nfunction isWindow( obj ) {\n\treturn obj != null && obj === obj.window;\n}\n\nfunction getDimensions( elem ) {\n\tvar raw = elem[ 0 ];\n\tif ( raw.nodeType === 9 ) {\n\t\treturn {\n\t\t\twidth: elem.width(),\n\t\t\theight: elem.height(),\n\t\t\toffset: { top: 0, left: 0 }\n\t\t};\n\t}\n\tif ( isWindow( raw ) ) {\n\t\treturn {\n\t\t\twidth: elem.width(),\n\t\t\theight: elem.height(),\n\t\t\toffset: { top: elem.scrollTop(), left: elem.scrollLeft() }\n\t\t};\n\t}\n\tif ( raw.preventDefault ) {\n\t\treturn {\n\t\t\twidth: 0,\n\t\t\theight: 0,\n\t\t\toffset: { top: raw.pageY, left: raw.pageX }\n\t\t};\n\t}\n\treturn {\n\t\twidth: elem.outerWidth(),\n\t\theight: elem.outerHeight(),\n\t\toffset: elem.offset()\n\t};\n}\n\n$.position = {\n\tscrollbarWidth: function() {\n\t\tif ( cachedScrollbarWidth !== undefined ) {\n\t\t\treturn cachedScrollbarWidth;\n\t\t}\n\t\tvar w1, w2,\n\t\t\tdiv = $( \"<div style=\" +\n\t\t\t\t\"'display:block;position:absolute;width:200px;height:200px;overflow:hidden;'>\" +\n\t\t\t\t\"<div style='height:300px;width:auto;'></div></div>\" ),\n\t\t\tinnerDiv = div.children()[ 0 ];\n\n\t\t$( \"body\" ).append( div );\n\t\tw1 = innerDiv.offsetWidth;\n\t\tdiv.css( \"overflow\", \"scroll\" );\n\n\t\tw2 = innerDiv.offsetWidth;\n\n\t\tif ( w1 === w2 ) {\n\t\t\tw2 = div[ 0 ].clientWidth;\n\t\t}\n\n\t\tdiv.remove();\n\n\t\treturn ( cachedScrollbarWidth = w1 - w2 );\n\t},\n\tgetScrollInfo: function( within ) {\n\t\tvar overflowX = within.isWindow || within.isDocument ? \"\" :\n\t\t\t\twithin.element.css( \"overflow-x\" ),\n\t\t\toverflowY = within.isWindow || within.isDocument ? \"\" :\n\t\t\t\twithin.element.css( \"overflow-y\" ),\n\t\t\thasOverflowX = overflowX === \"scroll\" ||\n\t\t\t\t( overflowX === \"auto\" && within.width < within.element[ 0 ].scrollWidth ),\n\t\t\thasOverflowY = overflowY === \"scroll\" ||\n\t\t\t\t( overflowY === \"auto\" && within.height < within.element[ 0 ].scrollHeight );\n\t\treturn {\n\t\t\twidth: hasOverflowY ? $.position.scrollbarWidth() : 0,\n\t\t\theight: hasOverflowX ? $.position.scrollbarWidth() : 0\n\t\t};\n\t},\n\tgetWithinInfo: function( element ) {\n\t\tvar withinElement = $( element || window ),\n\t\t\tisElemWindow = isWindow( withinElement[ 0 ] ),\n\t\t\tisDocument = !!withinElement[ 0 ] && withinElement[ 0 ].nodeType === 9,\n\t\t\thasOffset = !isElemWindow && !isDocument;\n\t\treturn {\n\t\t\telement: withinElement,\n\t\t\tisWindow: isElemWindow,\n\t\t\tisDocument: isDocument,\n\t\t\toffset: hasOffset ? $( element ).offset() : { left: 0, top: 0 },\n\t\t\tscrollLeft: withinElement.scrollLeft(),\n\t\t\tscrollTop: withinElement.scrollTop(),\n\t\t\twidth: withinElement.outerWidth(),\n\t\t\theight: withinElement.outerHeight()\n\t\t};\n\t}\n};\n\n$.fn.position = function( options ) {\n\tif ( !options || !options.of ) {\n\t\treturn _position.apply( this, arguments );\n\t}\n\n\t// Make a copy, we don't want to modify arguments\n\toptions = $.extend( {}, options );\n\n\tvar atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,\n\n\t\t// Make sure string options are treated as CSS selectors\n\t\ttarget = typeof options.of === \"string\" ?\n\t\t\t$( document ).find( options.of ) :\n\t\t\t$( options.of ),\n\n\t\twithin = $.position.getWithinInfo( options.within ),\n\t\tscrollInfo = $.position.getScrollInfo( within ),\n\t\tcollision = ( options.collision || \"flip\" ).split( \" \" ),\n\t\toffsets = {};\n\n\tdimensions = getDimensions( target );\n\tif ( target[ 0 ].preventDefault ) {\n\n\t\t// Force left top to allow flipping\n\t\toptions.at = \"left top\";\n\t}\n\ttargetWidth = dimensions.width;\n\ttargetHeight = dimensions.height;\n\ttargetOffset = dimensions.offset;\n\n\t// Clone to reuse original targetOffset later\n\tbasePosition = $.extend( {}, targetOffset );\n\n\t// Force my and at to have valid horizontal and vertical positions\n\t// if a value is missing or invalid, it will be converted to center\n\t$.each( [ \"my\", \"at\" ], function() {\n\t\tvar pos = ( options[ this ] || \"\" ).split( \" \" ),\n\t\t\thorizontalOffset,\n\t\t\tverticalOffset;\n\n\t\tif ( pos.length === 1 ) {\n\t\t\tpos = rhorizontal.test( pos[ 0 ] ) ?\n\t\t\t\tpos.concat( [ \"center\" ] ) :\n\t\t\t\trvertical.test( pos[ 0 ] ) ?\n\t\t\t\t\t[ \"center\" ].concat( pos ) :\n\t\t\t\t\t[ \"center\", \"center\" ];\n\t\t}\n\t\tpos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : \"center\";\n\t\tpos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : \"center\";\n\n\t\t// Calculate offsets\n\t\thorizontalOffset = roffset.exec( pos[ 0 ] );\n\t\tverticalOffset = roffset.exec( pos[ 1 ] );\n\t\toffsets[ this ] = [\n\t\t\thorizontalOffset ? horizontalOffset[ 0 ] : 0,\n\t\t\tverticalOffset ? verticalOffset[ 0 ] : 0\n\t\t];\n\n\t\t// Reduce to just the positions without the offsets\n\t\toptions[ this ] = [\n\t\t\trposition.exec( pos[ 0 ] )[ 0 ],\n\t\t\trposition.exec( pos[ 1 ] )[ 0 ]\n\t\t];\n\t} );\n\n\t// Normalize collision option\n\tif ( collision.length === 1 ) {\n\t\tcollision[ 1 ] = collision[ 0 ];\n\t}\n\n\tif ( options.at[ 0 ] === \"right\" ) {\n\t\tbasePosition.left += targetWidth;\n\t} else if ( options.at[ 0 ] === \"center\" ) {\n\t\tbasePosition.left += targetWidth / 2;\n\t}\n\n\tif ( options.at[ 1 ] === \"bottom\" ) {\n\t\tbasePosition.top += targetHeight;\n\t} else if ( options.at[ 1 ] === \"center\" ) {\n\t\tbasePosition.top += targetHeight / 2;\n\t}\n\n\tatOffset = getOffsets( offsets.at, targetWidth, targetHeight );\n\tbasePosition.left += atOffset[ 0 ];\n\tbasePosition.top += atOffset[ 1 ];\n\n\treturn this.each( function() {\n\t\tvar collisionPosition, using,\n\t\t\telem = $( this ),\n\t\t\telemWidth = elem.outerWidth(),\n\t\t\telemHeight = elem.outerHeight(),\n\t\t\tmarginLeft = parseCss( this, \"marginLeft\" ),\n\t\t\tmarginTop = parseCss( this, \"marginTop\" ),\n\t\t\tcollisionWidth = elemWidth + marginLeft + parseCss( this, \"marginRight\" ) +\n\t\t\t\tscrollInfo.width,\n\t\t\tcollisionHeight = elemHeight + marginTop + parseCss( this, \"marginBottom\" ) +\n\t\t\t\tscrollInfo.height,\n\t\t\tposition = $.extend( {}, basePosition ),\n\t\t\tmyOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );\n\n\t\tif ( options.my[ 0 ] === \"right\" ) {\n\t\t\tposition.left -= elemWidth;\n\t\t} else if ( options.my[ 0 ] === \"center\" ) {\n\t\t\tposition.left -= elemWidth / 2;\n\t\t}\n\n\t\tif ( options.my[ 1 ] === \"bottom\" ) {\n\t\t\tposition.top -= elemHeight;\n\t\t} else if ( options.my[ 1 ] === \"center\" ) {\n\t\t\tposition.top -= elemHeight / 2;\n\t\t}\n\n\t\tposition.left += myOffset[ 0 ];\n\t\tposition.top += myOffset[ 1 ];\n\n\t\tcollisionPosition = {\n\t\t\tmarginLeft: marginLeft,\n\t\t\tmarginTop: marginTop\n\t\t};\n\n\t\t$.each( [ \"left\", \"top\" ], function( i, dir ) {\n\t\t\tif ( $.ui.position[ collision[ i ] ] ) {\n\t\t\t\t$.ui.position[ collision[ i ] ][ dir ]( position, {\n\t\t\t\t\ttargetWidth: targetWidth,\n\t\t\t\t\ttargetHeight: targetHeight,\n\t\t\t\t\telemWidth: elemWidth,\n\t\t\t\t\telemHeight: elemHeight,\n\t\t\t\t\tcollisionPosition: collisionPosition,\n\t\t\t\t\tcollisionWidth: collisionWidth,\n\t\t\t\t\tcollisionHeight: collisionHeight,\n\t\t\t\t\toffset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],\n\t\t\t\t\tmy: options.my,\n\t\t\t\t\tat: options.at,\n\t\t\t\t\twithin: within,\n\t\t\t\t\telem: elem\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\n\t\tif ( options.using ) {\n\n\t\t\t// Adds feedback as second argument to using callback, if present\n\t\t\tusing = function( props ) {\n\t\t\t\tvar left = targetOffset.left - position.left,\n\t\t\t\t\tright = left + targetWidth - elemWidth,\n\t\t\t\t\ttop = targetOffset.top - position.top,\n\t\t\t\t\tbottom = top + targetHeight - elemHeight,\n\t\t\t\t\tfeedback = {\n\t\t\t\t\t\ttarget: {\n\t\t\t\t\t\t\telement: target,\n\t\t\t\t\t\t\tleft: targetOffset.left,\n\t\t\t\t\t\t\ttop: targetOffset.top,\n\t\t\t\t\t\t\twidth: targetWidth,\n\t\t\t\t\t\t\theight: targetHeight\n\t\t\t\t\t\t},\n\t\t\t\t\t\telement: {\n\t\t\t\t\t\t\telement: elem,\n\t\t\t\t\t\t\tleft: position.left,\n\t\t\t\t\t\t\ttop: position.top,\n\t\t\t\t\t\t\twidth: elemWidth,\n\t\t\t\t\t\t\theight: elemHeight\n\t\t\t\t\t\t},\n\t\t\t\t\t\thorizontal: right < 0 ? \"left\" : left > 0 ? \"right\" : \"center\",\n\t\t\t\t\t\tvertical: bottom < 0 ? \"top\" : top > 0 ? \"bottom\" : \"middle\"\n\t\t\t\t\t};\n\t\t\t\tif ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {\n\t\t\t\t\tfeedback.horizontal = \"center\";\n\t\t\t\t}\n\t\t\t\tif ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {\n\t\t\t\t\tfeedback.vertical = \"middle\";\n\t\t\t\t}\n\t\t\t\tif ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {\n\t\t\t\t\tfeedback.important = \"horizontal\";\n\t\t\t\t} else {\n\t\t\t\t\tfeedback.important = \"vertical\";\n\t\t\t\t}\n\t\t\t\toptions.using.call( this, props, feedback );\n\t\t\t};\n\t\t}\n\n\t\telem.offset( $.extend( position, { using: using } ) );\n\t} );\n};\n\n$.ui.position = {\n\tfit: {\n\t\tleft: function( position, data ) {\n\t\t\tvar within = data.within,\n\t\t\t\twithinOffset = within.isWindow ? within.scrollLeft : within.offset.left,\n\t\t\t\touterWidth = within.width,\n\t\t\t\tcollisionPosLeft = position.left - data.collisionPosition.marginLeft,\n\t\t\t\toverLeft = withinOffset - collisionPosLeft,\n\t\t\t\toverRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,\n\t\t\t\tnewOverRight;\n\n\t\t\t// Element is wider than within\n\t\t\tif ( data.collisionWidth > outerWidth ) {\n\n\t\t\t\t// Element is initially over the left side of within\n\t\t\t\tif ( overLeft > 0 && overRight <= 0 ) {\n\t\t\t\t\tnewOverRight = position.left + overLeft + data.collisionWidth - outerWidth -\n\t\t\t\t\t\twithinOffset;\n\t\t\t\t\tposition.left += overLeft - newOverRight;\n\n\t\t\t\t// Element is initially over right side of within\n\t\t\t\t} else if ( overRight > 0 && overLeft <= 0 ) {\n\t\t\t\t\tposition.left = withinOffset;\n\n\t\t\t\t// Element is initially over both left and right sides of within\n\t\t\t\t} else {\n\t\t\t\t\tif ( overLeft > overRight ) {\n\t\t\t\t\t\tposition.left = withinOffset + outerWidth - data.collisionWidth;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tposition.left = withinOffset;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Too far left -> align with left edge\n\t\t\t} else if ( overLeft > 0 ) {\n\t\t\t\tposition.left += overLeft;\n\n\t\t\t// Too far right -> align with right edge\n\t\t\t} else if ( overRight > 0 ) {\n\t\t\t\tposition.left -= overRight;\n\n\t\t\t// Adjust based on position and margin\n\t\t\t} else {\n\t\t\t\tposition.left = max( position.left - collisionPosLeft, position.left );\n\t\t\t}\n\t\t},\n\t\ttop: function( position, data ) {\n\t\t\tvar within = data.within,\n\t\t\t\twithinOffset = within.isWindow ? within.scrollTop : within.offset.top,\n\t\t\t\touterHeight = data.within.height,\n\t\t\t\tcollisionPosTop = position.top - data.collisionPosition.marginTop,\n\t\t\t\toverTop = withinOffset - collisionPosTop,\n\t\t\t\toverBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,\n\t\t\t\tnewOverBottom;\n\n\t\t\t// Element is taller than within\n\t\t\tif ( data.collisionHeight > outerHeight ) {\n\n\t\t\t\t// Element is initially over the top of within\n\t\t\t\tif ( overTop > 0 && overBottom <= 0 ) {\n\t\t\t\t\tnewOverBottom = position.top + overTop + data.collisionHeight - outerHeight -\n\t\t\t\t\t\twithinOffset;\n\t\t\t\t\tposition.top += overTop - newOverBottom;\n\n\t\t\t\t// Element is initially over bottom of within\n\t\t\t\t} else if ( overBottom > 0 && overTop <= 0 ) {\n\t\t\t\t\tposition.top = withinOffset;\n\n\t\t\t\t// Element is initially over both top and bottom of within\n\t\t\t\t} else {\n\t\t\t\t\tif ( overTop > overBottom ) {\n\t\t\t\t\t\tposition.top = withinOffset + outerHeight - data.collisionHeight;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tposition.top = withinOffset;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Too far up -> align with top\n\t\t\t} else if ( overTop > 0 ) {\n\t\t\t\tposition.top += overTop;\n\n\t\t\t// Too far down -> align with bottom edge\n\t\t\t} else if ( overBottom > 0 ) {\n\t\t\t\tposition.top -= overBottom;\n\n\t\t\t// Adjust based on position and margin\n\t\t\t} else {\n\t\t\t\tposition.top = max( position.top - collisionPosTop, position.top );\n\t\t\t}\n\t\t}\n\t},\n\tflip: {\n\t\tleft: function( position, data ) {\n\t\t\tvar within = data.within,\n\t\t\t\twithinOffset = within.offset.left + within.scrollLeft,\n\t\t\t\touterWidth = within.width,\n\t\t\t\toffsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,\n\t\t\t\tcollisionPosLeft = position.left - data.collisionPosition.marginLeft,\n\t\t\t\toverLeft = collisionPosLeft - offsetLeft,\n\t\t\t\toverRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,\n\t\t\t\tmyOffset = data.my[ 0 ] === \"left\" ?\n\t\t\t\t\t-data.elemWidth :\n\t\t\t\t\tdata.my[ 0 ] === \"right\" ?\n\t\t\t\t\t\tdata.elemWidth :\n\t\t\t\t\t\t0,\n\t\t\t\tatOffset = data.at[ 0 ] === \"left\" ?\n\t\t\t\t\tdata.targetWidth :\n\t\t\t\t\tdata.at[ 0 ] === \"right\" ?\n\t\t\t\t\t\t-data.targetWidth :\n\t\t\t\t\t\t0,\n\t\t\t\toffset = -2 * data.offset[ 0 ],\n\t\t\t\tnewOverRight,\n\t\t\t\tnewOverLeft;\n\n\t\t\tif ( overLeft < 0 ) {\n\t\t\t\tnewOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth -\n\t\t\t\t\touterWidth - withinOffset;\n\t\t\t\tif ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {\n\t\t\t\t\tposition.left += myOffset + atOffset + offset;\n\t\t\t\t}\n\t\t\t} else if ( overRight > 0 ) {\n\t\t\t\tnewOverLeft = position.left - data.collisionPosition.marginLeft + myOffset +\n\t\t\t\t\tatOffset + offset - offsetLeft;\n\t\t\t\tif ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {\n\t\t\t\t\tposition.left += myOffset + atOffset + offset;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\ttop: function( position, data ) {\n\t\t\tvar within = data.within,\n\t\t\t\twithinOffset = within.offset.top + within.scrollTop,\n\t\t\t\touterHeight = within.height,\n\t\t\t\toffsetTop = within.isWindow ? within.scrollTop : within.offset.top,\n\t\t\t\tcollisionPosTop = position.top - data.collisionPosition.marginTop,\n\t\t\t\toverTop = collisionPosTop - offsetTop,\n\t\t\t\toverBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,\n\t\t\t\ttop = data.my[ 1 ] === \"top\",\n\t\t\t\tmyOffset = top ?\n\t\t\t\t\t-data.elemHeight :\n\t\t\t\t\tdata.my[ 1 ] === \"bottom\" ?\n\t\t\t\t\t\tdata.elemHeight :\n\t\t\t\t\t\t0,\n\t\t\t\tatOffset = data.at[ 1 ] === \"top\" ?\n\t\t\t\t\tdata.targetHeight :\n\t\t\t\t\tdata.at[ 1 ] === \"bottom\" ?\n\t\t\t\t\t\t-data.targetHeight :\n\t\t\t\t\t\t0,\n\t\t\t\toffset = -2 * data.offset[ 1 ],\n\t\t\t\tnewOverTop,\n\t\t\t\tnewOverBottom;\n\t\t\tif ( overTop < 0 ) {\n\t\t\t\tnewOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight -\n\t\t\t\t\touterHeight - withinOffset;\n\t\t\t\tif ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) {\n\t\t\t\t\tposition.top += myOffset + atOffset + offset;\n\t\t\t\t}\n\t\t\t} else if ( overBottom > 0 ) {\n\t\t\t\tnewOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset +\n\t\t\t\t\toffset - offsetTop;\n\t\t\t\tif ( newOverTop > 0 || abs( newOverTop ) < overBottom ) {\n\t\t\t\t\tposition.top += myOffset + atOffset + offset;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tflipfit: {\n\t\tleft: function() {\n\t\t\t$.ui.position.flip.left.apply( this, arguments );\n\t\t\t$.ui.position.fit.left.apply( this, arguments );\n\t\t},\n\t\ttop: function() {\n\t\t\t$.ui.position.flip.top.apply( this, arguments );\n\t\t\t$.ui.position.fit.top.apply( this, arguments );\n\t\t}\n\t}\n};\n\n} )();\n\nreturn $.ui.position;\n\n} ) );\n"], "filenames": ["tests/unit/position/core.js", "ui/position.js"], "buggy_code_start_loc": [116, 151], "buggy_code_end_loc": [336, 152], "fixing_code_start_loc": [116, 151], "fixing_code_end_loc": [355, 157], "type": "CWE-79", "message": "jQuery-UI is the official jQuery user interface library. Prior to version 1.13.0, accepting the value of the `of` option of the `.position()` util from untrusted sources may execute untrusted code. The issue is fixed in jQuery UI 1.13.0. Any string value passed to the `of` option is now treated as a CSS selector. A workaround is to not accept the value of the `of` option from untrusted sources.", "other": {"cve": {"id": "CVE-2021-41184", "sourceIdentifier": "security-advisories@github.com", "published": "2021-10-26T15:15:10.460", "lastModified": "2022-11-07T17:20:09.440", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "jQuery-UI is the official jQuery user interface library. Prior to version 1.13.0, accepting the value of the `of` option of the `.position()` util from untrusted sources may execute untrusted code. The issue is fixed in jQuery UI 1.13.0. Any string value passed to the `of` option is now treated as a CSS selector. A workaround is to not accept the value of the `of` option from untrusted sources."}, {"lang": "es", "value": "jQuery-UI es la biblioteca oficial de interfaz de usuario de jQuery. Antes de la versi\u00f3n 1.13.0, aceptar el valor de la opci\u00f3n \"of\" de la utilidad \".position()\" de fuentes no confiables pod\u00eda ejecutar c\u00f3digo no confiable. El problema es corregido en jQuery UI versi\u00f3n 1.13.0. Cualquier valor de cadena pasado a la opci\u00f3n \"of\" se trata ahora como un selector CSS. Una soluci\u00f3n es no aceptar el valor de la opci\u00f3n \"of\" de fuentes no confiables"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jquery:jquery_ui:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.13.0", "matchCriteriaId": "CB6A3E8D-9C5E-48D3-B096-672A0FE3AE82"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h300s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "6770B6C3-732E-4E22-BF1C-2D2FD610061C"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h300s:-:*:*:*:*:*:*:*", "matchCriteriaId": "9F9C8C20-42EB-4AB5-BD97-212DEB070C43"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h500s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "7FFF7106-ED78-49BA-9EC5-B889E3685D53"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h500s:-:*:*:*:*:*:*:*", "matchCriteriaId": "E63D8B0F-006E-4801-BF9D-1C001BBFB4F9"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h700s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "56409CEC-5A1E-4450-AA42-641E459CC2AF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h700s:-:*:*:*:*:*:*:*", "matchCriteriaId": "B06F4839-D16A-4A61-9BB5-55B13F41E47F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h300e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "108A2215-50FB-4074-94CF-C130FA14566D"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h300e:-:*:*:*:*:*:*:*", "matchCriteriaId": "7AFC73CE-ABB9-42D3-9A71-3F5BC5381E0E"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h500e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "32F0B6C0-F930-480D-962B-3F4EFDCC13C7"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h500e:-:*:*:*:*:*:*:*", "matchCriteriaId": "803BC414-B250-4E3A-A478-A3881340D6B8"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h700e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "0FEB3337-BFDE-462A-908B-176F92053CEC"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h700e:-:*:*:*:*:*:*:*", "matchCriteriaId": "736AEAE9-782B-4F71-9893-DED53367E102"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "D0B4AD8A-F172-4558-AEC6-FF424BA2D912"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410s:-:*:*:*:*:*:*:*", "matchCriteriaId": "8497A4C9-8474-4A62-8331-3FE862ED4098"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410c_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "234DEFE0-5CE5-4B0A-96B8-5D227CB8ED31"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410c:-:*:*:*:*:*:*:*", "matchCriteriaId": "CDDF61B7-EC5C-467C-B710-B89F502CD04F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:drupal:drupal:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.0", "versionEndExcluding": "7.86", "matchCriteriaId": "013FAABA-8CDD-46AD-B321-9908634C880A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:drupal:drupal:*:*:*:*:*:*:*:*", "versionStartIncluding": "9.2.0", "versionEndExcluding": "9.2.11", "matchCriteriaId": "BE1268C5-DEFD-44D8-8994-D93C7839D5C2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:drupal:drupal:*:*:*:*:*:*:*:*", "versionStartIncluding": "9.3.0", "versionEndExcluding": "9.3.3", "matchCriteriaId": "7A28F55D-AEB8-454E-B1A9-163C4CB2B38D"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tenable:tenable.sc:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.21.0", "matchCriteriaId": "CAB9A41F-91F1-40DF-BF12-6ADA7229A84C"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:agile_plm:9.3.6:*:*:*:*:*:*:*", "matchCriteriaId": "C650FEDB-E903-4C2D-AD40-282AB5F2E3C2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:application_express:*:*:*:*:*:*:*:*", "versionEndExcluding": "22.1.1", "matchCriteriaId": "48B23728-0050-4AF0-B8B0-A959CBAB4505"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_platform:2.9.0:*:*:*:*:*:*:*", "matchCriteriaId": "AB9FC9AB-1070-420F-870E-A5EC43A924A4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_platform:2.12.0:*:*:*:*:*:*:*", "matchCriteriaId": "BDC6D658-09EA-4C41-869F-1C2EA163F751"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:big_data_spatial_and_graph:*:*:*:*:*:*:*:*", "versionEndExcluding": "23.1", "matchCriteriaId": "384DEDD9-CB26-4306-99D8-83068A9B23ED"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:big_data_spatial_and_graph:23.1:*:*:*:*:*:*:*", "matchCriteriaId": "BEF828F5-C666-40DA-98DD-CDF658D7090B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_interactive_session_recorder:6.4:*:*:*:*:*:*:*", "matchCriteriaId": "E812639B-EE28-4C68-9F6F-70C8BF981C86"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_operations_monitor:4.3:*:*:*:*:*:*:*", "matchCriteriaId": "CBE1A019-7BB6-4226-8AC4-9D6927ADAEFA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_operations_monitor:4.4:*:*:*:*:*:*:*", "matchCriteriaId": "B98BAEB2-A540-4E8A-A946-C4331B913AFD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_operations_monitor:5.0:*:*:*:*:*:*:*", "matchCriteriaId": "B8FBE260-E306-4215-80C0-D2D27CA43E0F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:hospitality_inventory_management:9.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "8865CE15-F9A1-4A46-AF93-B58356BDEE6F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:hospitality_materials_control:18.1:*:*:*:*:*:*:*", "matchCriteriaId": "2AC63D10-2326-4542-B345-31D45B9A7408"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:hospitality_suite8:*:*:*:*:*:*:*:*", "versionStartIncluding": "8.11.0", "versionEndIncluding": "8.14.0", "matchCriteriaId": "C7F4B5F0-6B78-4A94-AD83-6B78D484E298"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:hospitality_suite8:8.10.2:*:*:*:*:*:*:*", "matchCriteriaId": "CBDA65DE-5727-49DC-8D50-DA81DB3E8841"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:jd_edwards_enterpriseone_tools:*:*:*:*:*:*:*:*", "versionEndIncluding": "9.2.6.3", "matchCriteriaId": "C5F35B8D-6F26-4682-8541-6F10EE2ACE7E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:peoplesoft_enterprise_peopletools:8.58:*:*:*:*:*:*:*", "matchCriteriaId": "D9DB4A14-2EF5-4B54-95D2-75E6CF9AA0A9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:peoplesoft_enterprise_peopletools:8.59:*:*:*:*:*:*:*", "matchCriteriaId": "C8AF00C6-B97F-414D-A8DF-057E6BFD8597"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:policy_automation:*:*:*:*:*:*:*:*", "versionStartIncluding": "12.2.0", "versionEndIncluding": "12.2.25", "matchCriteriaId": "15C83E0F-5FA2-47E5-9FCF-CD2E90D6A9E8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:primavera_unifier:*:*:*:*:*:*:*:*", "versionStartIncluding": "17.7", "versionEndIncluding": "17.12", "matchCriteriaId": "08FA59A8-6A62-4B33-8952-D6E658F8DAC9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:primavera_unifier:18.8:*:*:*:*:*:*:*", "matchCriteriaId": "202AD518-2E9B-4062-B063-9858AE1F9CE2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:primavera_unifier:19.12:*:*:*:*:*:*:*", "matchCriteriaId": "10864586-270E-4ACF-BDCC-ECFCD299305F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:primavera_unifier:20.12:*:*:*:*:*:*:*", "matchCriteriaId": "38340E3C-C452-4370-86D4-355B6B4E0A06"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:primavera_unifier:21.12:*:*:*:*:*:*:*", "matchCriteriaId": "E9C55C69-E22E-4B80-9371-5CD821D79FE2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:rest_data_services:*:*:*:*:-:*:*:*", "versionEndExcluding": "22.1.1", "matchCriteriaId": "105BF985-2403-455E-BAA1-509245B54A1D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:rest_data_services:22.1.1:*:*:*:-:*:*:*", "matchCriteriaId": "281F1ACB-3180-422C-BADF-B0AE5F50924E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:weblogic_server:12.2.1.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "F14A818F-AA16-4438-A3E4-E64C9287AC66"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:weblogic_server:12.2.1.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "4A5BB153-68E0-4DDA-87D1-0D9AB7F0A418"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:weblogic_server:14.1.1.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "04BCDC24-4A21-473C-8733-0D9CFB38A752"}]}]}], "references": [{"url": "https://blog.jqueryui.com/2021/10/jquery-ui-1-13-0-released/", "source": "security-advisories@github.com", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/jquery/jquery-ui/commit/effa323f1505f2ce7a324e4f429fa9032c72f280", "source": "security-advisories@github.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/jquery/jquery-ui/security/advisories/GHSA-gpqq-952q-5327", "source": "security-advisories@github.com", "tags": ["Mitigation", "Patch", "Vendor Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/HVKIOWSXL2RF2ULNAP7PHESYCFSZIJE3/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/NXIUUBRVLA4E7G7MMIKCEN75YN7UFERW/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/O74SXYY7RGXREQDQUDQD4BPJ4QQTD2XQ/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/SGSY236PYSFYIEBRGDERLA7OSY6D7XL4/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/SNXA7XRKGINWSUIPIZ6ZBCTV6N3KSHES/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20211118-0004/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.drupal.org/sa-core-2022-001", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuapr2022.html", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpujul2022.html", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.tenable.com/security/tns-2022-09", "source": "security-advisories@github.com", "tags": ["Patch", "Release Notes", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/jquery/jquery-ui/commit/effa323f1505f2ce7a324e4f429fa9032c72f280"}}