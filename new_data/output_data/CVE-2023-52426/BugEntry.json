{"buggy_code": ["#                          __  __            _\n#                       ___\\ \\/ /_ __   __ _| |_\n#                      / _ \\\\  /| '_ \\ / _` | __|\n#                     |  __//  \\| |_) | (_| | |_\n#                      \\___/_/\\_\\ .__/ \\__,_|\\__|\n#                               |_| XML parser\n#\n# Copyright (c) 2010      Patrick Spendrin <ps_ml@gmx.de>\n# Copyright (c) 2012      Karl Waclawek <karl@waclawek.net>\n# Copyright (c) 2016-2022 Sebastian Pipping <sebastian@pipping.org>\n# Copyright (c) 2016      Sergei Nikulov <sergey.nikulov@gmail.com>\n# Copyright (c) 2016      Bj\u00f6rn Lindahl <bjorn.lindahl@foi.se>\n# Copyright (c) 2016      Tobias Taschner <github@tc84.de>\n# Copyright (c) 2016      Ben Boeckel <ben.boeckel@kitware.com>\n# Copyright (c) 2017      Rhodri James <rhodri@wildebeest.org.uk>\n# Copyright (c) 2017      Rolf Eike Beer <eike@sf-mail.de>\n# Copyright (c) 2017      Stephen Groat <stephen@groat.us>\n# Copyright (c) 2017      Franek Korta <fkorta@gmail.com>\n# Copyright (c) 2018      pedro-vicente <pedro.vicente@space-research.org>\n# Copyright (c) 2018      Frank Rast <frank.rast@gefeg.com>\n# Copyright (c) 2018      userwithuid <userwithuid@gmail.com>\n# Copyright (c) 2018      Yury Gribov <tetra2005@gmail.com>\n# Copyright (c) 2019      Kishore Kunche <kishore.kunche@intel.com>\n# Copyright (c) 2019      xantares <xantares09@hotmail.com>\n# Copyright (c) 2019      Mohammed Khajapasha <mohammed.khajapasha@intel.com>\n# Copyright (c) 2019      David Loffredo <loffredo@steptools.com>\n# Copyright (c) 2019      Bhargava Shastry <bhargava.shastry@ethereum.org>\n# Copyright (c) 2020      Maciej Sroczy\u0144ski <macieksroczynski@poczta.fm>\n# Copyright (c) 2020      Gulliver <gulliver@traumkristalle.net>\n# Copyright (c) 2020      Thomas Beutlich <tc@tbeu.de>\n# Copyright (c) 2021      Alex Richardson <Alexander.Richardson@cl.cam.ac.uk>\n# Copyright (c) 2022      Johnny Jazeix <jazeix@gmail.com>\n# Copyright (c) 2022      David Faure <david.faure@kdab.com>\n# Unlike most of Expat,\n# this file is copyrighted under the BSD-license for buildsystem files of KDE.\n\ncmake_minimum_required(VERSION 3.5.0)\n\nproject(expat\n    VERSION\n        2.5.0\n    LANGUAGES\n        C\n)\nset(CMAKE_C_STANDARD 99)\nset(CMAKE_C_STANDARD_REQUIRED ON)\nset(CMAKE_C_EXTENSIONS OFF)  # i.e. -std=c99 rather than default -std=gnu99\n\nset(PACKAGE_BUGREPORT \"expat-bugs@libexpat.org\")\nset(PACKAGE_NAME \"expat\")\nset(PACKAGE_VERSION \"${PROJECT_VERSION}\")\nset(PACKAGE_STRING \"${PACKAGE_NAME} ${PACKAGE_VERSION}\")\nset(PACKAGE_TARNAME \"${PACKAGE_NAME}\")\n\ninclude(CMakePackageConfigHelpers)\ninclude(GNUInstallDirs)\n\n#\n# Configuration defaults\n#\nif(WINCE)\n    set(_EXPAT_BUILD_TOOLS_DEFAULT OFF)\nelse()\n    set(_EXPAT_BUILD_TOOLS_DEFAULT ON)\nendif()\nif(MSVC OR NOT _EXPAT_BUILD_TOOLS_DEFAULT)\n    set(_EXPAT_BUILD_DOCS_DEFAULT OFF)\nelse()\n    find_program(DOCBOOK_TO_MAN NAMES docbook2x-man db2x_docbook2man docbook2man docbook-to-man)\n    if(DOCBOOK_TO_MAN)\n        set(_EXPAT_BUILD_DOCS_DEFAULT ON)\n    else()\n        set(_EXPAT_BUILD_DOCS_DEFAULT OFF)\n    endif()\nendif()\nif(MSVC)\n    set(_EXPAT_BUILD_PKGCONFIG_DEFAULT OFF)\nelse()\n    set(_EXPAT_BUILD_PKGCONFIG_DEFAULT ON)\nendif()\nif(DEFINED BUILD_SHARED_LIBS)\n    set(_EXPAT_SHARED_LIBS_DEFAULT ${BUILD_SHARED_LIBS})\nelse()\n    set(_EXPAT_SHARED_LIBS_DEFAULT ON)\nendif()\nif(NOT CMAKE_BUILD_TYPE)\n    set(CMAKE_BUILD_TYPE NoConfig)  # so that accessing EXPAT_*_POSTFIX will be waterproof\nendif()\nstring(TOUPPER \"${CMAKE_BUILD_TYPE}\" _EXPAT_BUILD_TYPE_UPPER)\n\n#\n# Configuration\n#\n\nmacro(expat_shy_set var default cache type desc)\n    # Macro expat_shy_set came into life because:\n    # - Expat was previously using an inconsistent mix of CMake's native set()\n    #   and option() to define public build time options.\n    # - option() is more friendly than set() with regard to configuring an\n    #   external project that is pulled in by means of add_subdirectory() --\n    #   see comments in issue #597 -- so we wanted to get away from set().\n    # - option() auto-converts non-bool values to bool when writing to the CMake\n    #   cache, so we needed something that supports non-bool better and hence\n    #   wanted to get away from plain option(), too.\n    #\n    # As a result, this function serves as a hybrid between CMake's regular set()\n    # and option(): from set() it takes support for non-bool types and the function\n    # name and signature whereas from option() (with policy CMP0077 mode NEW) it\n    # takes being shy when a value has previously been defined for that variable.\n    #\n    # So that resolves all need for set(.. FORCE) when pulling in Expat by means of\n    # add_subdirectory().\n    #\n    if(NOT ${cache} STREQUAL \"CACHE\")\n        message(SEND_ERROR \"Macro usage is: expat_shy_set(var default CACHE type desc)\")\n    endif()\n\n    if(DEFINED ${var})\n        # NOTE: The idea is to (ideally) only add to the cache if\n        #       there is no cache entry, yet.  \"if(DEFINED CACHE{var})\"\n        #       requires CMake >=3.14.\n        if(CMAKE_VERSION VERSION_GREATER_EQUAL \"3.14\" AND NOT DEFINED \"CACHE{${var}}\")\n            set(\"${var}\" \"${${var}}\" CACHE \"${type}\" \"${desc}\")\n        endif()\n    else()\n        set(\"${var}\" \"${default}\" CACHE \"${type}\" \"${desc}\")\n    endif()\nendmacro()\n\nexpat_shy_set(EXPAT_BUILD_TOOLS ${_EXPAT_BUILD_TOOLS_DEFAULT} CACHE BOOL \"Build the xmlwf tool for expat library\")\nexpat_shy_set(EXPAT_BUILD_EXAMPLES ON CACHE BOOL \"Build the examples for expat library\")\nexpat_shy_set(EXPAT_BUILD_TESTS ON CACHE BOOL \"Build the tests for expat library\")\nexpat_shy_set(EXPAT_SHARED_LIBS ${_EXPAT_SHARED_LIBS_DEFAULT} CACHE BOOL \"Build a shared expat library\")\nexpat_shy_set(EXPAT_BUILD_DOCS ${_EXPAT_BUILD_DOCS_DEFAULT} CACHE BOOL \"Build man page for xmlwf\")\nexpat_shy_set(EXPAT_BUILD_FUZZERS OFF CACHE BOOL \"Build fuzzers for the expat library\")\nexpat_shy_set(EXPAT_BUILD_PKGCONFIG ${_EXPAT_BUILD_PKGCONFIG_DEFAULT} CACHE BOOL \"Build pkg-config file\")\nexpat_shy_set(EXPAT_OSSFUZZ_BUILD OFF CACHE BOOL \"Build fuzzers via ossfuzz for the expat library\")\nif(UNIX OR _EXPAT_HELP)\n    expat_shy_set(EXPAT_WITH_LIBBSD OFF CACHE BOOL \"Utilize libbsd (for arc4random_buf)\")\nendif()\nexpat_shy_set(EXPAT_ENABLE_INSTALL ON CACHE BOOL \"Install expat files in cmake install target\")\nexpat_shy_set(EXPAT_CONTEXT_BYTES 1024 CACHE STRING \"Define to specify how much context to retain around the current parse point, 0 to disable\")\nmark_as_advanced(EXPAT_CONTEXT_BYTES)\nexpat_shy_set(EXPAT_DTD ON CACHE BOOL \"Define to make parameter entity parsing functionality available\")\nmark_as_advanced(EXPAT_DTD)\nexpat_shy_set(EXPAT_GE ON CACHE BOOL \"Define to make general entity parsing functionality available\")\nmark_as_advanced(EXPAT_GE)\nexpat_shy_set(EXPAT_NS ON CACHE BOOL \"Define to make XML Namespaces functionality available\")\nmark_as_advanced(EXPAT_NS)\nexpat_shy_set(EXPAT_WARNINGS_AS_ERRORS OFF CACHE BOOL \"Treat all compiler warnings as errors\")\nif(UNIX OR _EXPAT_HELP)\n    expat_shy_set(EXPAT_DEV_URANDOM ON CACHE BOOL \"Define to include code reading entropy from `/dev/urandom'.\")\n    expat_shy_set(EXPAT_WITH_GETRANDOM \"AUTO\" CACHE STRING \"Make use of getrandom function (ON|OFF|AUTO) [default=AUTO]\")\n    expat_shy_set(EXPAT_WITH_SYS_GETRANDOM \"AUTO\" CACHE STRING \"Make use of syscall SYS_getrandom (ON|OFF|AUTO) [default=AUTO]\")\n    mark_as_advanced(EXPAT_DEV_URANDOM)\nendif()\nexpat_shy_set(EXPAT_CHAR_TYPE \"char\" CACHE STRING \"Character type to use (char|ushort|wchar_t) [default=char]\")\nexpat_shy_set(EXPAT_ATTR_INFO OFF CACHE BOOL \"Define to allow retrieving the byte offsets for attribute names and values\")\nmark_as_advanced(EXPAT_ATTR_INFO)\nexpat_shy_set(EXPAT_LARGE_SIZE OFF CACHE BOOL \"Make XML_GetCurrent* functions return <(unsigned) long long> rather than <(unsigned) long>\")\nmark_as_advanced(EXPAT_LARGE_SIZE)\nexpat_shy_set(EXPAT_MIN_SIZE OFF CACHE BOOL \"Get a smaller (but slower) parser (in particular avoid multiple copies of the tokenizer)\")\nmark_as_advanced(EXPAT_MIN_SIZE)\nif(MSVC OR _EXPAT_HELP)\n    expat_shy_set(EXPAT_MSVC_STATIC_CRT OFF CACHE BOOL \"Use /MT flag (static CRT) when compiling in MSVC\")\nendif()\nif(NOT _EXPAT_HELP)\n    expat_shy_set(_EXPAT_M32 OFF CACHE BOOL \"(Unofficial!) Produce 32bit code with -m32\")\n    mark_as_advanced(_EXPAT_M32)\nendif()\n\nif(EXPAT_BUILD_TESTS)\n    # We have to call enable_language() before modifying any CMAKE_CXX_* variables\n    enable_language(CXX)\n\n    set(CMAKE_CXX_STANDARD 11)\n    set(CMAKE_CXX_STANDARD_REQUIRED ON)\n    set(CMAKE_CXX_EXTENSIONS OFF)  # i.e. -std=c++11 rather than default -std=gnu++11\nendif()\n\n#\n# Environment checks\n#\nif(EXPAT_DTD AND NOT EXPAT_GE)\n    message(SEND_ERROR \"Option EXPAT_DTD requires that EXPAT_GE is also enabled.\")\n    message(SEND_ERROR \"Please either enable option EXPAT_GE (recommended) or disable EXPAT_DTD also.\")\nendif()\n\nif(EXPAT_WITH_LIBBSD)\n    find_library(LIB_BSD NAMES bsd)\n    if(NOT LIB_BSD)\n        message(SEND_ERROR \"EXPAT_WITH_LIBBSD option is enabled, but libbsd was not found\")\n    else()\n        set(HAVE_LIBBSD TRUE)\n    endif()\nendif()\n\nif(MSVC)\n    # For the three types of MSVC version values, please see:\n    # - https://cmake.org/cmake/help/latest/variable/MSVC_VERSION.html\n    # - https://sourceforge.net/p/predef/wiki/Compilers/\n    # - https://en.wikipedia.org/wiki/Microsoft_Visual_Studio#History\n    set(_EXPAT_MSVC_REQUIRED_INT 1800)  # i.e. 12.0/2013/1800; see PR #426\n    set(_EXPAT_MSVC_SUPPORTED_INT 1910)\n    set(_EXPAT_MSVC_SUPPORTED_DISPLAY \"Visual Studio 15.0/2017/${_EXPAT_MSVC_SUPPORTED_INT}\")\n\n    if(MSVC_VERSION VERSION_LESS ${_EXPAT_MSVC_SUPPORTED_INT})\n        if(MSVC_VERSION VERSION_LESS ${_EXPAT_MSVC_REQUIRED_INT})\n            message(SEND_ERROR \"MSVC_VERSION ${MSVC_VERSION} is TOO OLD to compile Expat without errors.\")\n            message(SEND_ERROR \"Please use officially supported ${_EXPAT_MSVC_SUPPORTED_DISPLAY} or later.  Thank you!\")\n        else()\n            message(WARNING \"MSVC_VERSION ${MSVC_VERSION} is NOT OFFICIALLY SUPPORTED by Expat.\")\n            message(WARNING \"Please use ${_EXPAT_MSVC_SUPPORTED_DISPLAY} or later.  Thank you!\")\n        endif()\n    endif()\nendif()\n\nmacro(_expat_copy_bool_int source_ref dest_ref)\n    if(${source_ref})\n        set(${dest_ref} 1)\n    else()\n        set(${dest_ref} 0)\n    endif()\nendmacro()\n\nif(EXPAT_LARGE_SIZE)\n    add_definitions(-DXML_LARGE_SIZE)\nendif()\n\nif(EXPAT_MIN_SIZE)\n    add_definitions(-DXML_MIN_SIZE)\nendif()\n\nif(EXPAT_CHAR_TYPE STREQUAL \"char\")\n    set(_EXPAT_UNICODE OFF)\n    set(_EXPAT_UNICODE_WCHAR_T OFF)\nelseif(EXPAT_CHAR_TYPE STREQUAL \"ushort\")\n    set(_EXPAT_UNICODE ON)\n    set(_EXPAT_UNICODE_WCHAR_T OFF)\n    if(EXPAT_BUILD_EXAMPLES)\n        message(SEND_ERROR \"Examples can not be built with option -DEXPAT_CHAR_TYPE=ushort. Please pass -DEXPAT_CHAR_TYPE=(char|wchar_t) or -DEXPAT_BUILD_EXAMPLES=OFF.\")\n    endif()\n    if(EXPAT_BUILD_TESTS)\n        message(SEND_ERROR \"The testsuite can not be built with option -DEXPAT_CHAR_TYPE=ushort. Please pass -DEXPAT_CHAR_TYPE=(char|wchar_t) or -DEXPAT_BUILD_TESTS=OFF.\")\n    endif()\n    if(EXPAT_BUILD_TOOLS)\n        message(SEND_ERROR \"The xmlwf tool can not be built with option -DEXPAT_CHAR_TYPE=ushort. Please pass -DEXPAT_CHAR_TYPE=(char|wchar_t) or -DEXPAT_BUILD_TOOLS=OFF.\")\n    endif()\nelseif(EXPAT_CHAR_TYPE STREQUAL \"wchar_t\")\n    set(_EXPAT_UNICODE ON)\n    set(_EXPAT_UNICODE_WCHAR_T ON)\n    if(NOT WIN32)\n        string(FIND \"${CMAKE_C_FLAGS}\" \"-fshort-wchar\" _expat_short_wchar_found)\n        if(${_expat_short_wchar_found} EQUAL \"-1\")\n            message(SEND_ERROR \"Configuration -DEXPAT_CHAR_TYPE=wchar_t requires -DCMAKE_{C,CXX}_FLAGS=-fshort-wchar (which was not found) and libc compiled with -fshort-wchar, too.\")\n        endif()\n        if (EXPAT_BUILD_TOOLS)\n            message(SEND_ERROR \"The xmlwf tool can not be built with option -DEXPAT_CHAR_TYPE=wchar_t outside of Windows. Please pass -DEXPAT_CHAR_TYPE=char or -DEXPAT_BUILD_TOOLS=OFF.\")\n        endif()\n    endif()\nelse()\n    message(SEND_ERROR \"Option -DEXPAT_CHAR_TYPE=(char|ushort|wchar_t) cannot be \\\"${EXPAT_CHAR_TYPE}\\\".\")\nendif()\n\nif(_EXPAT_UNICODE)\n    add_definitions(-DXML_UNICODE)              # for unsigned short\n    if(_EXPAT_UNICODE_WCHAR_T)\n        add_definitions(-DXML_UNICODE_WCHAR_T)  # for wchar_t\n    endif()\nendif()\n\ninclude(${CMAKE_CURRENT_LIST_DIR}/ConfigureChecks.cmake)\n\nmacro(evaluate_detection_results use_ref have_ref thing_lower thing_title)\n    if(${use_ref} AND NOT (${use_ref} STREQUAL \"AUTO\") AND NOT ${have_ref})\n        message(SEND_ERROR\n                \"Use of ${thing_lower} was enforced by ${use_ref}=ON but it could not be found.\")\n    elseif(NOT ${use_ref} AND ${have_ref})\n        message(\"${thing_title} was found but it will not be used due to ${use_ref}=OFF.\")\n        set(${have_ref} 0)\n    endif()\nendmacro()\n\nif(NOT WIN32)\n    evaluate_detection_results(EXPAT_WITH_GETRANDOM HAVE_GETRANDOM \"function getrandom\" \"Function getrandom\")\n    evaluate_detection_results(EXPAT_WITH_SYS_GETRANDOM HAVE_SYSCALL_GETRANDOM \"syscall SYS_getrandom\" \"Syscall SYS_getrandom\")\nendif()\n\n_expat_copy_bool_int(EXPAT_ATTR_INFO        XML_ATTR_INFO)\n_expat_copy_bool_int(EXPAT_DTD              XML_DTD)\n_expat_copy_bool_int(EXPAT_GE               XML_GE)\n_expat_copy_bool_int(EXPAT_LARGE_SIZE       XML_LARGE_SIZE)\n_expat_copy_bool_int(EXPAT_MIN_SIZE         XML_MIN_SIZE)\n_expat_copy_bool_int(EXPAT_NS               XML_NS)\nif(NOT WIN32)\n    _expat_copy_bool_int(EXPAT_DEV_URANDOM  XML_DEV_URANDOM)\nendif()\nif(NOT EXPAT_CONTEXT_BYTES GREATER 0)  # in particular with -DEXPAT_CONTEXT_BYTES=OFF\n    set(EXPAT_CONTEXT_BYTES 0)\nendif()\nset(XML_CONTEXT_BYTES ${EXPAT_CONTEXT_BYTES})\n\nmacro(expat_install)\n    if(EXPAT_ENABLE_INSTALL)\n        install(${ARGN})\n    endif()\nendmacro()\n\nconfigure_file(expat_config.h.cmake \"${CMAKE_CURRENT_BINARY_DIR}/expat_config.h\")\nexpat_install(FILES \"${CMAKE_CURRENT_BINARY_DIR}/expat_config.h\" DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})\n\n\nset(EXTRA_COMPILE_FLAGS)\nif(FLAG_NO_STRICT_ALIASING)\n    set(EXTRA_COMPILE_FLAGS \"${EXTRA_COMPILE_FLAGS} -fno-strict-aliasing\")\nendif()\nif(FLAG_VISIBILITY)\n  if(EXPAT_SHARED_LIBS)\n     add_definitions(-DXML_ENABLE_VISIBILITY=1)\n  endif()\n  set(EXTRA_COMPILE_FLAGS \"${EXTRA_COMPILE_FLAGS} -fvisibility=hidden\")\nendif()\nif(MINGW)\n    # Without __USE_MINGW_ANSI_STDIO the compiler produces a false positive\n    set(EXTRA_COMPILE_FLAGS \"${EXTRA_COMPILE_FLAGS} -Wno-pedantic-ms-format\")\nendif()\nif (EXPAT_WARNINGS_AS_ERRORS)\n    if(MSVC)\n        add_definitions(/WX)\n    else()\n        set(EXTRA_COMPILE_FLAGS \"${EXTRA_COMPILE_FLAGS} -Werror\")\n        if(MINGW)\n            # To avoid \"error: unknown conversion type character \u2018l\u2019 in format [-Werror=format=]\"\n            set(EXTRA_COMPILE_FLAGS \"${EXTRA_COMPILE_FLAGS} -Wno-format\")\n        endif()\n    endif()\nendif()\nset(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} ${EXTRA_COMPILE_FLAGS}\")\nset(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} ${EXTRA_COMPILE_FLAGS}\")\n\nif (MSVC)\n    if (EXPAT_MSVC_STATIC_CRT)\n        message(\"-- Using static CRT ${EXPAT_MSVC_STATIC_CRT}\")\n        foreach(flag_var\n                CMAKE_CXX_FLAGS_${_EXPAT_BUILD_TYPE_UPPER}\n                CMAKE_CXX_FLAGS_DEBUG\n                CMAKE_CXX_FLAGS_RELEASE\n                CMAKE_CXX_FLAGS_MINSIZEREL\n                CMAKE_CXX_FLAGS_RELWITHDEBINFO\n                CMAKE_C_FLAGS_${_EXPAT_BUILD_TYPE_UPPER}\n                CMAKE_C_FLAGS_DEBUG\n                CMAKE_C_FLAGS_RELEASE\n                CMAKE_C_FLAGS_MINSIZEREL\n                CMAKE_C_FLAGS_RELWITHDEBINFO\n                )\n            string(REPLACE \"/MD\" \"/MT\" ${flag_var} \"${${flag_var}}\")\n        endforeach()\n    endif()\nendif()\n\nif(_EXPAT_M32 AND NOT MSVC)\n    foreach(flag_var\n            CMAKE_CXX_FLAGS_${_EXPAT_BUILD_TYPE_UPPER}\n            CMAKE_CXX_FLAGS_DEBUG\n            CMAKE_CXX_FLAGS_RELEASE\n            CMAKE_CXX_FLAGS_MINSIZEREL\n            CMAKE_CXX_FLAGS_RELWITHDEBINFO\n            CMAKE_C_FLAGS_${_EXPAT_BUILD_TYPE_UPPER}\n            CMAKE_C_FLAGS_DEBUG\n            CMAKE_C_FLAGS_RELEASE\n            CMAKE_C_FLAGS_MINSIZEREL\n            CMAKE_C_FLAGS_RELWITHDEBINFO\n            )\n        set(${flag_var} \"${${flag_var}} -m32\")\n    endforeach()\nendif()\n\ninclude_directories(${CMAKE_CURRENT_BINARY_DIR} ${CMAKE_CURRENT_SOURCE_DIR}/lib)\nif(MSVC)\n    add_definitions(-D_CRT_SECURE_NO_WARNINGS -wd4996)\nendif()\n\n#\n# C library\n#\nset(_EXPAT_C_SOURCES\n    lib/xmlparse.c\n    lib/xmlrole.c\n    lib/xmltok.c\n# NOTE: ISO C forbids an empty translation unit\n#   lib/xmltok_impl.c\n#   lib/xmltok_ns.c\n)\n\nif(EXPAT_SHARED_LIBS)\n    set(_SHARED SHARED)\n    if(WIN32)\n        macro(_expat_def_file_toggle source_var target_var)\n            if(${source_var})\n                set(${target_var} \" \")  # i.e. not commented out, a single space\n            else()\n                set(${target_var} \";\")  # i.e. commented out\n            endif()\n        endmacro()\n\n        _expat_def_file_toggle(EXPAT_DTD _EXPAT_COMMENT_DTD)\n        _expat_def_file_toggle(EXPAT_ATTR_INFO _EXPAT_COMMENT_ATTR_INFO)\n\n        configure_file(\"${CMAKE_CURRENT_SOURCE_DIR}/lib/libexpat.def.cmake\" \"${CMAKE_CURRENT_BINARY_DIR}/lib/libexpat.def\")\n        set(_EXPAT_EXTRA_SOURCES ${_EXPAT_EXTRA_SOURCES} \"${CMAKE_CURRENT_BINARY_DIR}/lib/libexpat.def\")\n\n        # Add DLL version\n        string(REPLACE \".\" \",\" _EXPAT_DLL_VERSION ${PROJECT_VERSION}.0)\n        configure_file(\"${CMAKE_CURRENT_SOURCE_DIR}/win32/version.rc.cmake\" \"${CMAKE_CURRENT_BINARY_DIR}/win32/version.rc\")\n        set(_EXPAT_EXTRA_SOURCES ${_EXPAT_EXTRA_SOURCES} \"${CMAKE_CURRENT_BINARY_DIR}/win32/version.rc\")\n    endif()\nelse()\n    set(_SHARED STATIC)\nendif()\n\nadd_library(expat ${_SHARED} ${_EXPAT_C_SOURCES} ${_EXPAT_EXTRA_SOURCES})\nif(_EXPAT_LIBM_FOUND)\n    target_link_libraries(expat m)\nendif()\nif(EXPAT_WITH_LIBBSD)\n    target_link_libraries(expat ${LIB_BSD})\nendif()\n\n#\n# Library filename postfix\n#\nif(_EXPAT_UNICODE)\n    set(_POSTFIX_WIDE \"w\")\nendif()\n\nif(MSVC AND NOT EXPAT_SHARED_LIBS)\n    if(EXPAT_MSVC_STATIC_CRT)\n        set(_POSTFIX_CRT \"MT\")\n    else()\n        set(_POSTFIX_CRT \"MD\")\n    endif()\nendif()\n\nforeach(build_type_upper\n        ${_EXPAT_BUILD_TYPE_UPPER}\n        DEBUG\n        RELEASE\n        MINSIZEREL\n        RELWITHDEBINFO\n        )\n    if(WIN32 AND build_type_upper STREQUAL \"DEBUG\")\n        set(_POSTFIX_DEBUG \"d\")\n    else()\n        set(_POSTFIX_DEBUG \"\")  # needs a reset because of being looped\n    endif()\n\n    expat_shy_set(EXPAT_${build_type_upper}_POSTFIX \"${_POSTFIX_WIDE}${_POSTFIX_DEBUG}${_POSTFIX_CRT}\" CACHE STRING \"Library filename postfix for build type ${build_type_upper}; yields filenames libexpat<postfix=[w][d][MD|MT]>.(dll|dylib|lib|so)\")\n    mark_as_advanced(EXPAT_${build_type_upper}_POSTFIX)\n    set_property(TARGET expat PROPERTY ${build_type_upper}_POSTFIX ${EXPAT_${build_type_upper}_POSTFIX})\nendforeach()\n\nset(LIBCURRENT 9)    # sync\nset(LIBREVISION 10)  # with\nset(LIBAGE 8)        # configure.ac!\nmath(EXPR LIBCURRENT_MINUS_AGE \"${LIBCURRENT} - ${LIBAGE}\")\n\nif(NOT WIN32)\n    set_property(TARGET expat PROPERTY VERSION ${LIBCURRENT_MINUS_AGE}.${LIBAGE}.${LIBREVISION})\n    set_property(TARGET expat PROPERTY SOVERSION ${LIBCURRENT_MINUS_AGE})\n    set_property(TARGET expat PROPERTY NO_SONAME ${NO_SONAME})\n\n    if(APPLE)\n        if(NOT CMAKE_VERSION VERSION_GREATER_EQUAL 3.17)\n            message(FATAL_ERROR \"Expat requires CMake >=3.17 on platform \\\"APPLE\\\".\")\n        endif()\n\n        # NOTE: This intends to talk CMake into compatibility with GNU Libtool\n        math(EXPR _EXPAT_MACHO_COMPATIBILITY_VERSION \"${LIBCURRENT} + 1\")\n        set(_EXPAT_MACHO_CURRENT_VERSION \"${_EXPAT_MACHO_COMPATIBILITY_VERSION}.${LIBREVISION}\")\n        set_property(TARGET expat PROPERTY MACHO_COMPATIBILITY_VERSION ${_EXPAT_MACHO_COMPATIBILITY_VERSION})\n        set_property(TARGET expat PROPERTY MACHO_CURRENT_VERSION ${_EXPAT_MACHO_CURRENT_VERSION})\n    endif()\nendif()\n\nif(MINGW AND EXPAT_SHARED_LIBS)\n    set_target_properties(expat PROPERTIES SUFFIX \"-${LIBCURRENT_MINUS_AGE}.dll\")\nendif()\n\nif(WIN32 AND NOT MINGW)\n    # NOTE: This avoids a name collision with Expat.dll of Perl's XML::Parser::Expat\n    #       on Windows by resorting to filename libexpat.dll since Expat 1.95.3.\n    #       Everything but MSVC is already adding prefix \"lib\", automatically.\n    # NOTE: \"set_property(TARGET expat PROPERTY PREFIX lib)\" would only affect *.dll\n    #       files but not *.lib files, so we have to rely on property OUTPUT_NAME, instead.\n    #       Target property <CONFIG>_POSTFIX still applies.\n    set(_EXPAT_OUTPUT_NAME libexpat)\n    set_property(TARGET expat PROPERTY OUTPUT_NAME ${_EXPAT_OUTPUT_NAME})\nelse()\n    set(_EXPAT_OUTPUT_NAME expat)\nendif()\n\ntarget_include_directories(expat\n    INTERFACE\n        $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/lib>\n        $<BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}>\n        $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>\n)\n\nif(WIN32 AND EXPAT_SHARED_LIBS)\n    target_compile_definitions(expat PRIVATE VER_FILEVERSION=${_EXPAT_DLL_VERSION})\nendif()\n\nexpat_install(TARGETS expat EXPORT expat\n                      RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}\n                      LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}\n                      ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR})\n\nexpat_install(FILES lib/expat.h lib/expat_external.h DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})\n\n#\n# pkg-config file\n#\nif(EXPAT_BUILD_PKGCONFIG)\n    if(CMAKE_INSTALL_LIBDIR MATCHES \"^/\")\n        set(_expat_pkgconfig_libdir \"${CMAKE_INSTALL_LIBDIR}\")\n    else()\n        set(_expat_pkgconfig_libdir \"\\${exec_prefix}/${CMAKE_INSTALL_LIBDIR}\")\n    endif()\n\n    if(CMAKE_INSTALL_INCLUDEDIR MATCHES \"^/\")\n        set(_expat_pkgconfig_includedir \"${CMAKE_INSTALL_INCLUDEDIR}\")\n    else()\n        set(_expat_pkgconfig_includedir \"\\${prefix}/${CMAKE_INSTALL_INCLUDEDIR}\")\n    endif()\n\n    set_target_properties(expat PROPERTIES\n        pkgconfig_prefix \"${CMAKE_INSTALL_PREFIX}\"\n        pkgconfig_exec_prefix \"\\${prefix}\"\n        pkgconfig_libdir \"${_expat_pkgconfig_libdir}\"\n        pkgconfig_includedir \"${_expat_pkgconfig_includedir}\"\n        pkgconfig_version \"${PACKAGE_VERSION}\")\n\n    foreach(_build_type ${CMAKE_BUILD_TYPE} Debug Release RelWithDebInfo MinSizeRel)\n        string(TOLOWER \"${_build_type}\" _build_type_lower)\n        string(TOUPPER \"${_build_type}\" _build_type_upper)\n        set_property(TARGET expat PROPERTY \"pkgconfig_${_build_type_lower}_name\" \"expat${EXPAT_${_build_type_upper}_POSTFIX}\")\n        set_property(TARGET expat PROPERTY \"pkgconfig_${_build_type_lower}_output_name\" \"${_EXPAT_OUTPUT_NAME}${EXPAT_${_build_type_upper}_POSTFIX}\")\n        if(_EXPAT_LIBM_FOUND)\n            set_property(TARGET expat PROPERTY \"pkgconfig_libm\" \"-lm\")\n        else()\n            set_property(TARGET expat PROPERTY \"pkgconfig_libm\" \"\")\n        endif()\n    endforeach()\n\n    file(GENERATE\n        OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/$<CONFIG>/expat.pc\n        INPUT ${PROJECT_SOURCE_DIR}/expat.pc.cmake)\n\n    expat_install(FILES ${CMAKE_CURRENT_BINARY_DIR}/$<CONFIG>/expat.pc DESTINATION ${CMAKE_INSTALL_LIBDIR}/pkgconfig)\nendif()\n\n#\n# C command line tool xmlwf\n#\nif(EXPAT_BUILD_TOOLS)\n    set(xmlwf_SRCS\n        xmlwf/codepage.c\n        xmlwf/readfilemap.c\n        xmlwf/xmlfile.c\n        xmlwf/xmlwf.c\n    )\n\n    add_executable(xmlwf ${xmlwf_SRCS})\n    set_property(TARGET xmlwf PROPERTY RUNTIME_OUTPUT_DIRECTORY xmlwf)\n    target_link_libraries(xmlwf expat)\n    if(_EXPAT_LIBM_FOUND)\n        target_link_libraries(xmlwf m)\n    endif()\n    expat_install(TARGETS xmlwf DESTINATION ${CMAKE_INSTALL_BINDIR})\n\n    if(MINGW AND _EXPAT_UNICODE_WCHAR_T)\n        # https://gcc.gnu.org/onlinedocs/gcc/x86-Windows-Options.html\n        set_target_properties(xmlwf PROPERTIES LINK_FLAGS -municode)\n    endif()\n\n    if(EXPAT_BUILD_DOCS)\n        file(MAKE_DIRECTORY ${PROJECT_BINARY_DIR}/doc)\n        add_custom_target(\n            xmlwf-manpage\n            COMMAND\n                \"${DOCBOOK_TO_MAN}\" \"${PROJECT_SOURCE_DIR}/doc/xmlwf.xml\" && mv \"XMLWF.1\" \"${PROJECT_BINARY_DIR}/doc/xmlwf.1\"\n            BYPRODUCTS\n                doc/xmlwf.1)\n        add_dependencies(expat xmlwf-manpage)\n        expat_install(FILES \"${PROJECT_BINARY_DIR}/doc/xmlwf.1\" DESTINATION ${CMAKE_INSTALL_MANDIR}/man1)\n    elseif(EXISTS ${PROJECT_SOURCE_DIR}/doc/xmlwf.1)\n        expat_install(FILES \"${PROJECT_SOURCE_DIR}/doc/xmlwf.1\" DESTINATION ${CMAKE_INSTALL_MANDIR}/man1)\n    endif()\nendif()\n\n#\n# C code examples\n#\nif(EXPAT_BUILD_EXAMPLES)\n    foreach(_target element_declarations elements outline)\n        add_executable(${_target} examples/${_target}.c)\n        set_property(TARGET ${_target} PROPERTY RUNTIME_OUTPUT_DIRECTORY examples)\n        target_link_libraries(${_target} expat)\n    endforeach()\nendif()\n\n#\n# C/C++ test runners\n#\nif(EXPAT_BUILD_TESTS)\n    ## these are unittests that can be run on any platform\n    enable_testing()\n\n    if(NOT MSVC)\n        if(MINGW)\n            set(host whatever-mingw32)  # for nothing but run.sh\n        endif()\n        configure_file(${CMAKE_CURRENT_SOURCE_DIR}/run.sh.in run.sh @ONLY)\n    endif()\n\n    function(expat_add_test _name _file)\n        if(MSVC)\n            add_test(NAME ${_name} COMMAND ${_file})\n        else()\n            add_test(NAME ${_name} COMMAND bash run.sh ${_file})\n        endif()\n    endfunction()\n\n    set(_EXPAT_TEST_TARGETS runtests runtests_cxx)\n\n    add_executable(runtests\n        tests/acc_tests.c\n        tests/alloc_tests.c\n        tests/basic_tests.c\n        tests/chardata.c\n        tests/common.c\n        tests/dummy.c\n        tests/handlers.c\n        tests/memcheck.c\n        tests/minicheck.c\n        tests/misc_tests.c\n        tests/ns_tests.c\n        tests/nsalloc_tests.c\n        tests/runtests.c\n        tests/structdata.c\n        ${_EXPAT_C_SOURCES}\n    )\n\n    add_executable(runtests_cxx\n        tests/acc_tests_cxx.cpp\n        tests/alloc_tests_cxx.cpp\n        tests/basic_tests_cxx.cpp\n        tests/chardata_cxx.cpp\n        tests/common_cxx.cpp\n        tests/dummy_cxx.cpp\n        tests/handlers_cxx.cpp\n        tests/memcheck_cxx.cpp\n        tests/minicheck_cxx.cpp\n        tests/misc_tests_cxx.cpp\n        tests/ns_tests_cxx.cpp\n        tests/nsalloc_tests_cxx.cpp\n        tests/runtests_cxx.cpp\n        tests/structdata_cxx.cpp\n        ${_EXPAT_C_SOURCES}\n    )\n\n    foreach(_target ${_EXPAT_TEST_TARGETS})\n        set_property(TARGET ${_target} PROPERTY RUNTIME_OUTPUT_DIRECTORY tests)\n        expat_add_test(${_target} $<TARGET_FILE:${_target}>)\n\n        if(_EXPAT_LIBM_FOUND)\n            target_link_libraries(${_target} m)\n        endif()\n\n        if(EXPAT_WITH_LIBBSD)\n            target_link_libraries(${_target} ${LIB_BSD})\n        endif()\n    endforeach()\nendif()\n\n#\n# Fuzzers\n#\nif(EXPAT_BUILD_FUZZERS)\n    if(NOT \"${CMAKE_C_COMPILER_ID}\" STREQUAL \"Clang\")\n        message(SEND_ERROR\n            \"Building fuzz targets without Clang (but ${CMAKE_C_COMPILER_ID}) \"\n            \"is not supported. Please set \"\n            \"-DCMAKE_C_COMPILER=clang -DCMAKE_CXX_COMPILER=clang++.\")\n    endif()\n\n    string(FIND \"${CMAKE_C_FLAGS}\" \"-fsanitize\" sanitizer_present)\n    if(${sanitizer_present} EQUAL \"-1\")\n        message(WARNING\n            \"There was no sanitizer present when building the fuzz targets. \"\n            \"This is likely in error - consider adding \"\n            \"-DCMAKE_C_FLAGS='-fsanitize=<sanitizer>' and \"\n            \"-DCMAKE_CXX_FLAGS='-fsanitize=<sanitizer>' and \"\n            \"-DCMAKE_EXE_LINKER_FLAGS='-fsanitize=<sanitizer>' and \"\n            \"-DCMAKE_MODULE_LINKER_FLAGS='-fsanitize=<sanitizer>' and \"\n            \"-DCMAKE_SHARED_LINKER_FLAGS='-fsanitize=<sanitizer>' to your cmake \"\n            \"execution.\")\n    endif()\n\n    if(EXPAT_OSSFUZZ_BUILD AND NOT DEFINED ENV{LIB_FUZZING_ENGINE})\n        message(SEND_ERROR\n            \"OSS-Fuzz builds require the environment variable \"\n            \"LIB_FUZZING_ENGINE to be set. If you are seeing this \"\n            \"warning, it points to a deeper problem in the ossfuzz \"\n            \"build setup.\")\n    endif()\n\n    set(encoding_types UTF-16 UTF-8 ISO-8859-1 US-ASCII UTF-16BE UTF-16LE)\n    set(fuzz_targets xml_parse_fuzzer xml_parsebuffer_fuzzer)\n\n    add_library(fuzzpat STATIC ${_EXPAT_C_SOURCES})\n    if(NOT EXPAT_OSSFUZZ_BUILD)\n        target_compile_options(fuzzpat PRIVATE -fsanitize=fuzzer-no-link)\n    endif()\n\n    foreach(fuzz_target ${fuzz_targets})\n        foreach(encoding_type ${encoding_types})\n            set(target_name ${fuzz_target}_${encoding_type})\n            add_executable(${target_name} fuzz/${fuzz_target}.c)\n            target_link_libraries(${target_name} fuzzpat)\n            target_compile_definitions(${target_name}\n                PRIVATE ENCODING_FOR_FUZZING=${encoding_type})\n            if(NOT EXPAT_OSSFUZZ_BUILD)\n                target_compile_options(${target_name} PRIVATE -fsanitize=fuzzer-no-link)\n            endif()\n            # NOTE: Avoiding target_link_options here only because it needs CMake >=3.13\n            if(EXPAT_OSSFUZZ_BUILD)\n                set_target_properties(${target_name} PROPERTIES LINK_FLAGS $ENV{LIB_FUZZING_ENGINE})\n                set_target_properties(${target_name} PROPERTIES LINKER_LANGUAGE \"CXX\")\n            else()\n                set_target_properties(${target_name} PROPERTIES LINK_FLAGS -fsanitize=fuzzer)\n            endif()\n            set_property(\n                TARGET ${target_name} PROPERTY RUNTIME_OUTPUT_DIRECTORY fuzz)\n        endforeach()\n    endforeach()\nelse()\n    if(EXPAT_OSSFUZZ_BUILD)\n        message(SEND_ERROR\n                \"Attempting to perform an ossfuzz build without turning on the fuzzer build. \"\n                \"This is likely in error - consider adding \"\n                \"-DEXPAT_BUILD_FUZZERS=ON to your cmake execution.\")\n    endif()\nendif()\n\n#\n# C/C++ config affecting multiple targets\n#\nif(WIN32)\n    set(_EXPAT_STATIC_TARGETS ${_EXPAT_TEST_TARGETS})\n    if(NOT EXPAT_SHARED_LIBS)\n        list(APPEND _EXPAT_STATIC_TARGETS expat)\n    endif()\n    if(EXPAT_BUILD_FUZZERS)\n        list(APPEND _EXPAT_STATIC_TARGETS fuzzpat)\n    endif()\n\n    foreach(_target ${_EXPAT_STATIC_TARGETS})\n        target_compile_definitions(${_target} PUBLIC -DXML_STATIC)\n    endforeach()\nendif()\n\n#\n# Custom target \"run-xmltest\"\n#\nif(EXPAT_BUILD_TOOLS AND NOT MSVC)\n    add_custom_target(\n        xmlts-zip-downloaded\n        COMMAND\n            sh -c 'test -f xmlts.zip || wget --output-document=xmlts.zip https://www.w3.org/XML/Test/xmlts20080827.zip'\n        BYPRODUCTS\n            tests/xmlts.zip\n        WORKING_DIRECTORY\n            tests/)\n\n    add_custom_target(\n        xmlts-zip-extracted\n        COMMAND\n            sh -c 'test -d xmlconf || unzip -q xmlts.zip'\n        BYPRODUCTS\n            tests/xmlconf\n        WORKING_DIRECTORY\n            tests/)\n    add_dependencies(xmlts-zip-extracted xmlts-zip-downloaded)\n\n    add_custom_target(\n        xmltest-sh-been-run\n        COMMAND\n            sh -c '${CMAKE_CURRENT_SOURCE_DIR}/tests/xmltest.sh \"bash ${CMAKE_CURRENT_BINARY_DIR}/run.sh $<TARGET_FILE:xmlwf>\" 2>&1 | tee tests/xmltest.log'\n        BYPRODUCTS\n            tests/xmltest.log)\n    add_dependencies(xmltest-sh-been-run xmlts-zip-extracted xmlwf)\n\n    add_custom_target(\n        xmltest-log-fixed\n        COMMAND\n            ${CMAKE_CURRENT_SOURCE_DIR}/fix-xmltest-log.sh tests/xmltest.log\n        DEPENDS\n            tests/xmltest.log)\n    add_dependencies(xmltest-log-fixed xmltest-sh-been-run)\n\n    add_custom_target(\n        xmltest-log-verified\n        COMMAND\n            diff -u ${CMAKE_CURRENT_SOURCE_DIR}/tests/xmltest.log.expected tests/xmltest.log)\n    add_dependencies(xmltest-log-verified xmltest-log-fixed)\n\n    add_custom_target(run-xmltest)\n    add_dependencies(run-xmltest xmltest-log-verified)\nendif()\n\n#\n# Documentation\n#\nconfigure_file(Changes changelog COPYONLY)\nexpat_install(\n    FILES\n        AUTHORS\n        ${CMAKE_CURRENT_BINARY_DIR}/changelog\n    DESTINATION\n        ${CMAKE_INSTALL_DOCDIR})\n\n#\n# CMake files for find_package(expat [..] CONFIG [..])\n#\nconfigure_package_config_file(\n        cmake/expat-config.cmake.in\n        cmake/expat-config.cmake\n    INSTALL_DESTINATION\n        ${CMAKE_INSTALL_LIBDIR}/cmake/expat-${PROJECT_VERSION}/\n)\nwrite_basic_package_version_file(\n    cmake/expat-config-version.cmake\n    COMPATIBILITY SameMajorVersion  # i.e. semver\n)\nexport(\n    TARGETS\n        expat\n    FILE\n        cmake/expat-targets.cmake  # not going to be installed\n)\nexpat_install(\n    FILES\n        ${CMAKE_CURRENT_BINARY_DIR}/cmake/expat-config.cmake\n        ${CMAKE_CURRENT_BINARY_DIR}/cmake/expat-config-version.cmake\n    DESTINATION\n        ${CMAKE_INSTALL_LIBDIR}/cmake/expat-${PROJECT_VERSION}/\n)\nexpat_install(\n    EXPORT\n        expat\n    DESTINATION\n        ${CMAKE_INSTALL_LIBDIR}/cmake/expat-${PROJECT_VERSION}/\n    NAMESPACE\n        expat::\n)\n\n#\n# CPack\n#\n\n# This effectively disables target \"package_source\".\n# That is done due to CPack's unfortunate choice of an exclusion list\n# rather than inclusion list.  An exclusion list does not protect against\n# unwanted files ending up in the resulting archive in a way that's\n# safe to run from an Expat developer's machine.\nset(CPACK_SOURCE_GENERATOR '')\n\nif(WIN32)\n    set(CPACK_GENERATOR ZIP)\nelse()\n    set(CPACK_GENERATOR TGZ)\nendif()\n\ninclude(CPack)\n\n#\n# Summary\n#\nif(EXPAT_CHAR_TYPE STREQUAL \"char\")\n    set(_EXPAT_CHAR_TYPE_SUMMARY \"char (UTF-8)\")\nelseif(EXPAT_CHAR_TYPE STREQUAL \"ushort\")\n    set(_EXPAT_CHAR_TYPE_SUMMARY \"ushort (unsigned short, UTF-16)\")\nelseif(EXPAT_CHAR_TYPE STREQUAL \"wchar_t\")\n    if(WIN32)\n        set(_EXPAT_CHAR_TYPE_SUMMARY \"wchar_t (UTF-16)\")\n    else()\n        set(_EXPAT_CHAR_TYPE_SUMMARY \"wchar_t (UTF-32)  // not implemented\")\n    endif()\nelse()\n    set(_EXPAT_CHAR_TYPE_SUMMARY \"ERROR\")\nendif()\n# NOTE: We're not accessing global property GENERATOR_IS_MULTI_CONFIG\n#       because that would require CMake >=3.9\nif(CMAKE_CONFIGURATION_TYPES)\n    set(_EXPAT_GENERATOR_IS_MULTI_CONFIG TRUE)\nelse()\n    set(_EXPAT_GENERATOR_IS_MULTI_CONFIG FALSE)\nendif()\n\nmessage(STATUS \"===========================================================================\")\nmessage(STATUS \"\")\nmessage(STATUS \"Configuration\")\nmessage(STATUS \"  Generator .................. ${CMAKE_GENERATOR}\")\nif(_EXPAT_GENERATOR_IS_MULTI_CONFIG)\n    message(STATUS \"  Build types ................ ${CMAKE_CONFIGURATION_TYPES}\")\nelse()\n    message(STATUS \"  Build type ................. ${CMAKE_BUILD_TYPE}\")\nendif()\nmessage(STATUS \"  Prefix ..................... ${CMAKE_INSTALL_PREFIX}\")\nmessage(STATUS \"  Shared libraries ........... ${EXPAT_SHARED_LIBS}\")\nif(MSVC)\n    message(STATUS \"  Static CRT ................. ${EXPAT_MSVC_STATIC_CRT}\")\nendif()\nmessage(STATUS \"  Character type ............. ${_EXPAT_CHAR_TYPE_SUMMARY}\")\nif(NOT _EXPAT_GENERATOR_IS_MULTI_CONFIG)\n    message(STATUS \"  Library name postfix ....... ${EXPAT_${_EXPAT_BUILD_TYPE_UPPER}_POSTFIX}\")\nendif()\nmessage(STATUS \"\")\nmessage(STATUS \"  Build documentation ........ ${EXPAT_BUILD_DOCS}\")\nmessage(STATUS \"  Build examples ............. ${EXPAT_BUILD_EXAMPLES}\")\nmessage(STATUS \"  Build fuzzers .............. ${EXPAT_BUILD_FUZZERS}\")\nmessage(STATUS \"  Build tests ................ ${EXPAT_BUILD_TESTS}\")\nmessage(STATUS \"  Build tools (xmlwf) ........ ${EXPAT_BUILD_TOOLS}\")\nmessage(STATUS \"  Build pkg-config file ...... ${EXPAT_BUILD_PKGCONFIG}\")\nmessage(STATUS \"  Install files .............. ${EXPAT_ENABLE_INSTALL}\")\nmessage(STATUS \"\")\nmessage(STATUS \"  Features\")\nmessage(STATUS \"    // Advanced options, changes not advised\")\nmessage(STATUS \"    Attributes info .......... ${EXPAT_ATTR_INFO}\")\nmessage(STATUS \"    Context bytes ............ ${EXPAT_CONTEXT_BYTES}\")\nmessage(STATUS \"    DTD support .............. ${EXPAT_DTD}\")\nmessage(STATUS \"    General entities ......... ${EXPAT_GE}\")\nmessage(STATUS \"    Large size ............... ${EXPAT_LARGE_SIZE}\")\nmessage(STATUS \"    Minimum size ............. ${EXPAT_MIN_SIZE}\")\nmessage(STATUS \"    Namespace support ........ ${EXPAT_NS}\")\nmessage(STATUS \"\")\nmessage(STATUS \"  Entropy sources\")\nif(WIN32)\n    message(STATUS \"    rand_s ................... ON\")\nelse()\n    message(STATUS \"    getrandom ................ ${HAVE_GETRANDOM}\")\n    message(STATUS \"    syscall SYS_getrandom .... ${HAVE_SYSCALL_GETRANDOM}\")\n    message(STATUS \"    libbsd ................... ${EXPAT_WITH_LIBBSD}\")\n    message(STATUS \"    /dev/random .............. ${EXPAT_DEV_URANDOM}\")\nendif()\nmessage(STATUS \"\")\nif(CMAKE_GENERATOR STREQUAL \"Unix Makefiles\")\n    message(STATUS \"Continue with\")\n    message(STATUS \"  make\")\n    if(EXPAT_BUILD_TESTS)\n        message(STATUS \"  make test\")\n    endif()\n    if(EXPAT_ENABLE_INSTALL)\n        message(STATUS \"  sudo make install\")\n    endif()\n    message(STATUS \"\")\nendif()\nmessage(STATUS \"===========================================================================\")\n", "/*\n                            __  __            _\n                         ___\\ \\/ /_ __   __ _| |_\n                        / _ \\\\  /| '_ \\ / _` | __|\n                       |  __//  \\| |_) | (_| | |_\n                        \\___/_/\\_\\ .__/ \\__,_|\\__|\n                                 |_| XML parser\n\n   Copyright (c) 1997-2000 Thai Open Source Software Center Ltd\n   Copyright (c) 2000      Clark Cooper <coopercc@users.sourceforge.net>\n   Copyright (c) 2000-2005 Fred L. Drake, Jr. <fdrake@users.sourceforge.net>\n   Copyright (c) 2001-2002 Greg Stein <gstein@users.sourceforge.net>\n   Copyright (c) 2002-2016 Karl Waclawek <karl@waclawek.net>\n   Copyright (c) 2016-2022 Sebastian Pipping <sebastian@pipping.org>\n   Copyright (c) 2016      Cristian Rodr\u00edguez <crrodriguez@opensuse.org>\n   Copyright (c) 2016      Thomas Beutlich <tc@tbeu.de>\n   Copyright (c) 2017      Rhodri James <rhodri@wildebeest.org.uk>\n   Copyright (c) 2022      Thijs Schreijer <thijs@thijsschreijer.nl>\n   Licensed under the MIT license:\n\n   Permission is  hereby granted,  free of charge,  to any  person obtaining\n   a  copy  of  this  software   and  associated  documentation  files  (the\n   \"Software\"),  to  deal in  the  Software  without restriction,  including\n   without  limitation the  rights  to use,  copy,  modify, merge,  publish,\n   distribute, sublicense, and/or sell copies of the Software, and to permit\n   persons  to whom  the Software  is  furnished to  do so,  subject to  the\n   following conditions:\n\n   The above copyright  notice and this permission notice  shall be included\n   in all copies or substantial portions of the Software.\n\n   THE  SOFTWARE  IS  PROVIDED  \"AS  IS\",  WITHOUT  WARRANTY  OF  ANY  KIND,\n   EXPRESS  OR IMPLIED,  INCLUDING  BUT  NOT LIMITED  TO  THE WARRANTIES  OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n   NO EVENT SHALL THE AUTHORS OR  COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n   DAMAGES OR  OTHER LIABILITY, WHETHER  IN AN  ACTION OF CONTRACT,  TORT OR\n   OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n   USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef Expat_INCLUDED\n#define Expat_INCLUDED 1\n\n#include <stdlib.h>\n#include \"expat_external.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nstruct XML_ParserStruct;\ntypedef struct XML_ParserStruct *XML_Parser;\n\ntypedef unsigned char XML_Bool;\n#define XML_TRUE ((XML_Bool)1)\n#define XML_FALSE ((XML_Bool)0)\n\n/* The XML_Status enum gives the possible return values for several\n   API functions.  The preprocessor #defines are included so this\n   stanza can be added to code that still needs to support older\n   versions of Expat 1.95.x:\n\n   #ifndef XML_STATUS_OK\n   #define XML_STATUS_OK    1\n   #define XML_STATUS_ERROR 0\n   #endif\n\n   Otherwise, the #define hackery is quite ugly and would have been\n   dropped.\n*/\nenum XML_Status {\n  XML_STATUS_ERROR = 0,\n#define XML_STATUS_ERROR XML_STATUS_ERROR\n  XML_STATUS_OK = 1,\n#define XML_STATUS_OK XML_STATUS_OK\n  XML_STATUS_SUSPENDED = 2\n#define XML_STATUS_SUSPENDED XML_STATUS_SUSPENDED\n};\n\nenum XML_Error {\n  XML_ERROR_NONE,\n  XML_ERROR_NO_MEMORY,\n  XML_ERROR_SYNTAX,\n  XML_ERROR_NO_ELEMENTS,\n  XML_ERROR_INVALID_TOKEN,\n  XML_ERROR_UNCLOSED_TOKEN,\n  XML_ERROR_PARTIAL_CHAR,\n  XML_ERROR_TAG_MISMATCH,\n  XML_ERROR_DUPLICATE_ATTRIBUTE,\n  XML_ERROR_JUNK_AFTER_DOC_ELEMENT,\n  XML_ERROR_PARAM_ENTITY_REF,\n  XML_ERROR_UNDEFINED_ENTITY,\n  XML_ERROR_RECURSIVE_ENTITY_REF,\n  XML_ERROR_ASYNC_ENTITY,\n  XML_ERROR_BAD_CHAR_REF,\n  XML_ERROR_BINARY_ENTITY_REF,\n  XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF,\n  XML_ERROR_MISPLACED_XML_PI,\n  XML_ERROR_UNKNOWN_ENCODING,\n  XML_ERROR_INCORRECT_ENCODING,\n  XML_ERROR_UNCLOSED_CDATA_SECTION,\n  XML_ERROR_EXTERNAL_ENTITY_HANDLING,\n  XML_ERROR_NOT_STANDALONE,\n  XML_ERROR_UNEXPECTED_STATE,\n  XML_ERROR_ENTITY_DECLARED_IN_PE,\n  XML_ERROR_FEATURE_REQUIRES_XML_DTD,\n  XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING,\n  /* Added in 1.95.7. */\n  XML_ERROR_UNBOUND_PREFIX,\n  /* Added in 1.95.8. */\n  XML_ERROR_UNDECLARING_PREFIX,\n  XML_ERROR_INCOMPLETE_PE,\n  XML_ERROR_XML_DECL,\n  XML_ERROR_TEXT_DECL,\n  XML_ERROR_PUBLICID,\n  XML_ERROR_SUSPENDED,\n  XML_ERROR_NOT_SUSPENDED,\n  XML_ERROR_ABORTED,\n  XML_ERROR_FINISHED,\n  XML_ERROR_SUSPEND_PE,\n  /* Added in 2.0. */\n  XML_ERROR_RESERVED_PREFIX_XML,\n  XML_ERROR_RESERVED_PREFIX_XMLNS,\n  XML_ERROR_RESERVED_NAMESPACE_URI,\n  /* Added in 2.2.1. */\n  XML_ERROR_INVALID_ARGUMENT,\n  /* Added in 2.3.0. */\n  XML_ERROR_NO_BUFFER,\n  /* Added in 2.4.0. */\n  XML_ERROR_AMPLIFICATION_LIMIT_BREACH\n};\n\nenum XML_Content_Type {\n  XML_CTYPE_EMPTY = 1,\n  XML_CTYPE_ANY,\n  XML_CTYPE_MIXED,\n  XML_CTYPE_NAME,\n  XML_CTYPE_CHOICE,\n  XML_CTYPE_SEQ\n};\n\nenum XML_Content_Quant {\n  XML_CQUANT_NONE,\n  XML_CQUANT_OPT,\n  XML_CQUANT_REP,\n  XML_CQUANT_PLUS\n};\n\n/* If type == XML_CTYPE_EMPTY or XML_CTYPE_ANY, then quant will be\n   XML_CQUANT_NONE, and the other fields will be zero or NULL.\n   If type == XML_CTYPE_MIXED, then quant will be NONE or REP and\n   numchildren will contain number of elements that may be mixed in\n   and children point to an array of XML_Content cells that will be\n   all of XML_CTYPE_NAME type with no quantification.\n\n   If type == XML_CTYPE_NAME, then the name points to the name, and\n   the numchildren field will be zero and children will be NULL. The\n   quant fields indicates any quantifiers placed on the name.\n\n   CHOICE and SEQ will have name NULL, the number of children in\n   numchildren and children will point, recursively, to an array\n   of XML_Content cells.\n\n   The EMPTY, ANY, and MIXED types will only occur at top level.\n*/\n\ntypedef struct XML_cp XML_Content;\n\nstruct XML_cp {\n  enum XML_Content_Type type;\n  enum XML_Content_Quant quant;\n  XML_Char *name;\n  unsigned int numchildren;\n  XML_Content *children;\n};\n\n/* This is called for an element declaration. See above for\n   description of the model argument. It's the user code's responsibility\n   to free model when finished with it. See XML_FreeContentModel.\n   There is no need to free the model from the handler, it can be kept\n   around and freed at a later stage.\n*/\ntypedef void(XMLCALL *XML_ElementDeclHandler)(void *userData,\n                                              const XML_Char *name,\n                                              XML_Content *model);\n\nXMLPARSEAPI(void)\nXML_SetElementDeclHandler(XML_Parser parser, XML_ElementDeclHandler eldecl);\n\n/* The Attlist declaration handler is called for *each* attribute. So\n   a single Attlist declaration with multiple attributes declared will\n   generate multiple calls to this handler. The \"default\" parameter\n   may be NULL in the case of the \"#IMPLIED\" or \"#REQUIRED\"\n   keyword. The \"isrequired\" parameter will be true and the default\n   value will be NULL in the case of \"#REQUIRED\". If \"isrequired\" is\n   true and default is non-NULL, then this is a \"#FIXED\" default.\n*/\ntypedef void(XMLCALL *XML_AttlistDeclHandler)(\n    void *userData, const XML_Char *elname, const XML_Char *attname,\n    const XML_Char *att_type, const XML_Char *dflt, int isrequired);\n\nXMLPARSEAPI(void)\nXML_SetAttlistDeclHandler(XML_Parser parser, XML_AttlistDeclHandler attdecl);\n\n/* The XML declaration handler is called for *both* XML declarations\n   and text declarations. The way to distinguish is that the version\n   parameter will be NULL for text declarations. The encoding\n   parameter may be NULL for XML declarations. The standalone\n   parameter will be -1, 0, or 1 indicating respectively that there\n   was no standalone parameter in the declaration, that it was given\n   as no, or that it was given as yes.\n*/\ntypedef void(XMLCALL *XML_XmlDeclHandler)(void *userData,\n                                          const XML_Char *version,\n                                          const XML_Char *encoding,\n                                          int standalone);\n\nXMLPARSEAPI(void)\nXML_SetXmlDeclHandler(XML_Parser parser, XML_XmlDeclHandler xmldecl);\n\ntypedef struct {\n  void *(*malloc_fcn)(size_t size);\n  void *(*realloc_fcn)(void *ptr, size_t size);\n  void (*free_fcn)(void *ptr);\n} XML_Memory_Handling_Suite;\n\n/* Constructs a new parser; encoding is the encoding specified by the\n   external protocol or NULL if there is none specified.\n*/\nXMLPARSEAPI(XML_Parser)\nXML_ParserCreate(const XML_Char *encoding);\n\n/* Constructs a new parser and namespace processor.  Element type\n   names and attribute names that belong to a namespace will be\n   expanded; unprefixed attribute names are never expanded; unprefixed\n   element type names are expanded only if there is a default\n   namespace. The expanded name is the concatenation of the namespace\n   URI, the namespace separator character, and the local part of the\n   name.  If the namespace separator is '\\0' then the namespace URI\n   and the local part will be concatenated without any separator.\n   It is a programming error to use the separator '\\0' with namespace\n   triplets (see XML_SetReturnNSTriplet).\n   If a namespace separator is chosen that can be part of a URI or\n   part of an XML name, splitting an expanded name back into its\n   1, 2 or 3 original parts on application level in the element handler\n   may end up vulnerable, so these are advised against;  sane choices for\n   a namespace separator are e.g. '\\n' (line feed) and '|' (pipe).\n\n   Note that Expat does not validate namespace URIs (beyond encoding)\n   against RFC 3986 today (and is not required to do so with regard to\n   the XML 1.0 namespaces specification) but it may start doing that\n   in future releases.  Before that, an application using Expat must\n   be ready to receive namespace URIs containing non-URI characters.\n*/\nXMLPARSEAPI(XML_Parser)\nXML_ParserCreateNS(const XML_Char *encoding, XML_Char namespaceSeparator);\n\n/* Constructs a new parser using the memory management suite referred to\n   by memsuite. If memsuite is NULL, then use the standard library memory\n   suite. If namespaceSeparator is non-NULL it creates a parser with\n   namespace processing as described above. The character pointed at\n   will serve as the namespace separator.\n\n   All further memory operations used for the created parser will come from\n   the given suite.\n*/\nXMLPARSEAPI(XML_Parser)\nXML_ParserCreate_MM(const XML_Char *encoding,\n                    const XML_Memory_Handling_Suite *memsuite,\n                    const XML_Char *namespaceSeparator);\n\n/* Prepare a parser object to be reused.  This is particularly\n   valuable when memory allocation overhead is disproportionately high,\n   such as when a large number of small documnents need to be parsed.\n   All handlers are cleared from the parser, except for the\n   unknownEncodingHandler. The parser's external state is re-initialized\n   except for the values of ns and ns_triplets.\n\n   Added in Expat 1.95.3.\n*/\nXMLPARSEAPI(XML_Bool)\nXML_ParserReset(XML_Parser parser, const XML_Char *encoding);\n\n/* atts is array of name/value pairs, terminated by 0;\n   names and values are 0 terminated.\n*/\ntypedef void(XMLCALL *XML_StartElementHandler)(void *userData,\n                                               const XML_Char *name,\n                                               const XML_Char **atts);\n\ntypedef void(XMLCALL *XML_EndElementHandler)(void *userData,\n                                             const XML_Char *name);\n\n/* s is not 0 terminated. */\ntypedef void(XMLCALL *XML_CharacterDataHandler)(void *userData,\n                                                const XML_Char *s, int len);\n\n/* target and data are 0 terminated */\ntypedef void(XMLCALL *XML_ProcessingInstructionHandler)(void *userData,\n                                                        const XML_Char *target,\n                                                        const XML_Char *data);\n\n/* data is 0 terminated */\ntypedef void(XMLCALL *XML_CommentHandler)(void *userData, const XML_Char *data);\n\ntypedef void(XMLCALL *XML_StartCdataSectionHandler)(void *userData);\ntypedef void(XMLCALL *XML_EndCdataSectionHandler)(void *userData);\n\n/* This is called for any characters in the XML document for which\n   there is no applicable handler.  This includes both characters that\n   are part of markup which is of a kind that is not reported\n   (comments, markup declarations), or characters that are part of a\n   construct which could be reported but for which no handler has been\n   supplied. The characters are passed exactly as they were in the XML\n   document except that they will be encoded in UTF-8 or UTF-16.\n   Line boundaries are not normalized. Note that a byte order mark\n   character is not passed to the default handler. There are no\n   guarantees about how characters are divided between calls to the\n   default handler: for example, a comment might be split between\n   multiple calls.\n*/\ntypedef void(XMLCALL *XML_DefaultHandler)(void *userData, const XML_Char *s,\n                                          int len);\n\n/* This is called for the start of the DOCTYPE declaration, before\n   any DTD or internal subset is parsed.\n*/\ntypedef void(XMLCALL *XML_StartDoctypeDeclHandler)(void *userData,\n                                                   const XML_Char *doctypeName,\n                                                   const XML_Char *sysid,\n                                                   const XML_Char *pubid,\n                                                   int has_internal_subset);\n\n/* This is called for the end of the DOCTYPE declaration when the\n   closing > is encountered, but after processing any external\n   subset.\n*/\ntypedef void(XMLCALL *XML_EndDoctypeDeclHandler)(void *userData);\n\n/* This is called for entity declarations. The is_parameter_entity\n   argument will be non-zero if the entity is a parameter entity, zero\n   otherwise.\n\n   For internal entities (<!ENTITY foo \"bar\">), value will\n   be non-NULL and systemId, publicID, and notationName will be NULL.\n   The value string is NOT null-terminated; the length is provided in\n   the value_length argument. Since it is legal to have zero-length\n   values, do not use this argument to test for internal entities.\n\n   For external entities, value will be NULL and systemId will be\n   non-NULL. The publicId argument will be NULL unless a public\n   identifier was provided. The notationName argument will have a\n   non-NULL value only for unparsed entity declarations.\n\n   Note that is_parameter_entity can't be changed to XML_Bool, since\n   that would break binary compatibility.\n*/\ntypedef void(XMLCALL *XML_EntityDeclHandler)(\n    void *userData, const XML_Char *entityName, int is_parameter_entity,\n    const XML_Char *value, int value_length, const XML_Char *base,\n    const XML_Char *systemId, const XML_Char *publicId,\n    const XML_Char *notationName);\n\nXMLPARSEAPI(void)\nXML_SetEntityDeclHandler(XML_Parser parser, XML_EntityDeclHandler handler);\n\n/* OBSOLETE -- OBSOLETE -- OBSOLETE\n   This handler has been superseded by the EntityDeclHandler above.\n   It is provided here for backward compatibility.\n\n   This is called for a declaration of an unparsed (NDATA) entity.\n   The base argument is whatever was set by XML_SetBase. The\n   entityName, systemId and notationName arguments will never be\n   NULL. The other arguments may be.\n*/\ntypedef void(XMLCALL *XML_UnparsedEntityDeclHandler)(\n    void *userData, const XML_Char *entityName, const XML_Char *base,\n    const XML_Char *systemId, const XML_Char *publicId,\n    const XML_Char *notationName);\n\n/* This is called for a declaration of notation.  The base argument is\n   whatever was set by XML_SetBase. The notationName will never be\n   NULL.  The other arguments can be.\n*/\ntypedef void(XMLCALL *XML_NotationDeclHandler)(void *userData,\n                                               const XML_Char *notationName,\n                                               const XML_Char *base,\n                                               const XML_Char *systemId,\n                                               const XML_Char *publicId);\n\n/* When namespace processing is enabled, these are called once for\n   each namespace declaration. The call to the start and end element\n   handlers occur between the calls to the start and end namespace\n   declaration handlers. For an xmlns attribute, prefix will be\n   NULL.  For an xmlns=\"\" attribute, uri will be NULL.\n*/\ntypedef void(XMLCALL *XML_StartNamespaceDeclHandler)(void *userData,\n                                                     const XML_Char *prefix,\n                                                     const XML_Char *uri);\n\ntypedef void(XMLCALL *XML_EndNamespaceDeclHandler)(void *userData,\n                                                   const XML_Char *prefix);\n\n/* This is called if the document is not standalone, that is, it has an\n   external subset or a reference to a parameter entity, but does not\n   have standalone=\"yes\". If this handler returns XML_STATUS_ERROR,\n   then processing will not continue, and the parser will return a\n   XML_ERROR_NOT_STANDALONE error.\n   If parameter entity parsing is enabled, then in addition to the\n   conditions above this handler will only be called if the referenced\n   entity was actually read.\n*/\ntypedef int(XMLCALL *XML_NotStandaloneHandler)(void *userData);\n\n/* This is called for a reference to an external parsed general\n   entity.  The referenced entity is not automatically parsed.  The\n   application can parse it immediately or later using\n   XML_ExternalEntityParserCreate.\n\n   The parser argument is the parser parsing the entity containing the\n   reference; it can be passed as the parser argument to\n   XML_ExternalEntityParserCreate.  The systemId argument is the\n   system identifier as specified in the entity declaration; it will\n   not be NULL.\n\n   The base argument is the system identifier that should be used as\n   the base for resolving systemId if systemId was relative; this is\n   set by XML_SetBase; it may be NULL.\n\n   The publicId argument is the public identifier as specified in the\n   entity declaration, or NULL if none was specified; the whitespace\n   in the public identifier will have been normalized as required by\n   the XML spec.\n\n   The context argument specifies the parsing context in the format\n   expected by the context argument to XML_ExternalEntityParserCreate;\n   context is valid only until the handler returns, so if the\n   referenced entity is to be parsed later, it must be copied.\n   context is NULL only when the entity is a parameter entity.\n\n   The handler should return XML_STATUS_ERROR if processing should not\n   continue because of a fatal error in the handling of the external\n   entity.  In this case the calling parser will return an\n   XML_ERROR_EXTERNAL_ENTITY_HANDLING error.\n\n   Note that unlike other handlers the first argument is the parser,\n   not userData.\n*/\ntypedef int(XMLCALL *XML_ExternalEntityRefHandler)(XML_Parser parser,\n                                                   const XML_Char *context,\n                                                   const XML_Char *base,\n                                                   const XML_Char *systemId,\n                                                   const XML_Char *publicId);\n\n/* This is called in two situations:\n   1) An entity reference is encountered for which no declaration\n      has been read *and* this is not an error.\n   2) An internal entity reference is read, but not expanded, because\n      XML_SetDefaultHandler has been called.\n   Note: skipped parameter entities in declarations and skipped general\n         entities in attribute values cannot be reported, because\n         the event would be out of sync with the reporting of the\n         declarations or attribute values\n*/\ntypedef void(XMLCALL *XML_SkippedEntityHandler)(void *userData,\n                                                const XML_Char *entityName,\n                                                int is_parameter_entity);\n\n/* This structure is filled in by the XML_UnknownEncodingHandler to\n   provide information to the parser about encodings that are unknown\n   to the parser.\n\n   The map[b] member gives information about byte sequences whose\n   first byte is b.\n\n   If map[b] is c where c is >= 0, then b by itself encodes the\n   Unicode scalar value c.\n\n   If map[b] is -1, then the byte sequence is malformed.\n\n   If map[b] is -n, where n >= 2, then b is the first byte of an\n   n-byte sequence that encodes a single Unicode scalar value.\n\n   The data member will be passed as the first argument to the convert\n   function.\n\n   The convert function is used to convert multibyte sequences; s will\n   point to a n-byte sequence where map[(unsigned char)*s] == -n.  The\n   convert function must return the Unicode scalar value represented\n   by this byte sequence or -1 if the byte sequence is malformed.\n\n   The convert function may be NULL if the encoding is a single-byte\n   encoding, that is if map[b] >= -1 for all bytes b.\n\n   When the parser is finished with the encoding, then if release is\n   not NULL, it will call release passing it the data member; once\n   release has been called, the convert function will not be called\n   again.\n\n   Expat places certain restrictions on the encodings that are supported\n   using this mechanism.\n\n   1. Every ASCII character that can appear in a well-formed XML document,\n      other than the characters\n\n      $@\\^`{}~\n\n      must be represented by a single byte, and that byte must be the\n      same byte that represents that character in ASCII.\n\n   2. No character may require more than 4 bytes to encode.\n\n   3. All characters encoded must have Unicode scalar values <=\n      0xFFFF, (i.e., characters that would be encoded by surrogates in\n      UTF-16 are  not allowed).  Note that this restriction doesn't\n      apply to the built-in support for UTF-8 and UTF-16.\n\n   4. No Unicode character may be encoded by more than one distinct\n      sequence of bytes.\n*/\ntypedef struct {\n  int map[256];\n  void *data;\n  int(XMLCALL *convert)(void *data, const char *s);\n  void(XMLCALL *release)(void *data);\n} XML_Encoding;\n\n/* This is called for an encoding that is unknown to the parser.\n\n   The encodingHandlerData argument is that which was passed as the\n   second argument to XML_SetUnknownEncodingHandler.\n\n   The name argument gives the name of the encoding as specified in\n   the encoding declaration.\n\n   If the callback can provide information about the encoding, it must\n   fill in the XML_Encoding structure, and return XML_STATUS_OK.\n   Otherwise it must return XML_STATUS_ERROR.\n\n   If info does not describe a suitable encoding, then the parser will\n   return an XML_ERROR_UNKNOWN_ENCODING error.\n*/\ntypedef int(XMLCALL *XML_UnknownEncodingHandler)(void *encodingHandlerData,\n                                                 const XML_Char *name,\n                                                 XML_Encoding *info);\n\nXMLPARSEAPI(void)\nXML_SetElementHandler(XML_Parser parser, XML_StartElementHandler start,\n                      XML_EndElementHandler end);\n\nXMLPARSEAPI(void)\nXML_SetStartElementHandler(XML_Parser parser, XML_StartElementHandler handler);\n\nXMLPARSEAPI(void)\nXML_SetEndElementHandler(XML_Parser parser, XML_EndElementHandler handler);\n\nXMLPARSEAPI(void)\nXML_SetCharacterDataHandler(XML_Parser parser,\n                            XML_CharacterDataHandler handler);\n\nXMLPARSEAPI(void)\nXML_SetProcessingInstructionHandler(XML_Parser parser,\n                                    XML_ProcessingInstructionHandler handler);\nXMLPARSEAPI(void)\nXML_SetCommentHandler(XML_Parser parser, XML_CommentHandler handler);\n\nXMLPARSEAPI(void)\nXML_SetCdataSectionHandler(XML_Parser parser,\n                           XML_StartCdataSectionHandler start,\n                           XML_EndCdataSectionHandler end);\n\nXMLPARSEAPI(void)\nXML_SetStartCdataSectionHandler(XML_Parser parser,\n                                XML_StartCdataSectionHandler start);\n\nXMLPARSEAPI(void)\nXML_SetEndCdataSectionHandler(XML_Parser parser,\n                              XML_EndCdataSectionHandler end);\n\n/* This sets the default handler and also inhibits expansion of\n   internal entities. These entity references will be passed to the\n   default handler, or to the skipped entity handler, if one is set.\n*/\nXMLPARSEAPI(void)\nXML_SetDefaultHandler(XML_Parser parser, XML_DefaultHandler handler);\n\n/* This sets the default handler but does not inhibit expansion of\n   internal entities.  The entity reference will not be passed to the\n   default handler.\n*/\nXMLPARSEAPI(void)\nXML_SetDefaultHandlerExpand(XML_Parser parser, XML_DefaultHandler handler);\n\nXMLPARSEAPI(void)\nXML_SetDoctypeDeclHandler(XML_Parser parser, XML_StartDoctypeDeclHandler start,\n                          XML_EndDoctypeDeclHandler end);\n\nXMLPARSEAPI(void)\nXML_SetStartDoctypeDeclHandler(XML_Parser parser,\n                               XML_StartDoctypeDeclHandler start);\n\nXMLPARSEAPI(void)\nXML_SetEndDoctypeDeclHandler(XML_Parser parser, XML_EndDoctypeDeclHandler end);\n\nXMLPARSEAPI(void)\nXML_SetUnparsedEntityDeclHandler(XML_Parser parser,\n                                 XML_UnparsedEntityDeclHandler handler);\n\nXMLPARSEAPI(void)\nXML_SetNotationDeclHandler(XML_Parser parser, XML_NotationDeclHandler handler);\n\nXMLPARSEAPI(void)\nXML_SetNamespaceDeclHandler(XML_Parser parser,\n                            XML_StartNamespaceDeclHandler start,\n                            XML_EndNamespaceDeclHandler end);\n\nXMLPARSEAPI(void)\nXML_SetStartNamespaceDeclHandler(XML_Parser parser,\n                                 XML_StartNamespaceDeclHandler start);\n\nXMLPARSEAPI(void)\nXML_SetEndNamespaceDeclHandler(XML_Parser parser,\n                               XML_EndNamespaceDeclHandler end);\n\nXMLPARSEAPI(void)\nXML_SetNotStandaloneHandler(XML_Parser parser,\n                            XML_NotStandaloneHandler handler);\n\nXMLPARSEAPI(void)\nXML_SetExternalEntityRefHandler(XML_Parser parser,\n                                XML_ExternalEntityRefHandler handler);\n\n/* If a non-NULL value for arg is specified here, then it will be\n   passed as the first argument to the external entity ref handler\n   instead of the parser object.\n*/\nXMLPARSEAPI(void)\nXML_SetExternalEntityRefHandlerArg(XML_Parser parser, void *arg);\n\nXMLPARSEAPI(void)\nXML_SetSkippedEntityHandler(XML_Parser parser,\n                            XML_SkippedEntityHandler handler);\n\nXMLPARSEAPI(void)\nXML_SetUnknownEncodingHandler(XML_Parser parser,\n                              XML_UnknownEncodingHandler handler,\n                              void *encodingHandlerData);\n\n/* This can be called within a handler for a start element, end\n   element, processing instruction or character data.  It causes the\n   corresponding markup to be passed to the default handler.\n*/\nXMLPARSEAPI(void)\nXML_DefaultCurrent(XML_Parser parser);\n\n/* If do_nst is non-zero, and namespace processing is in effect, and\n   a name has a prefix (i.e. an explicit namespace qualifier) then\n   that name is returned as a triplet in a single string separated by\n   the separator character specified when the parser was created: URI\n   + sep + local_name + sep + prefix.\n\n   If do_nst is zero, then namespace information is returned in the\n   default manner (URI + sep + local_name) whether or not the name\n   has a prefix.\n\n   Note: Calling XML_SetReturnNSTriplet after XML_Parse or\n     XML_ParseBuffer has no effect.\n*/\n\nXMLPARSEAPI(void)\nXML_SetReturnNSTriplet(XML_Parser parser, int do_nst);\n\n/* This value is passed as the userData argument to callbacks. */\nXMLPARSEAPI(void)\nXML_SetUserData(XML_Parser parser, void *userData);\n\n/* Returns the last value set by XML_SetUserData or NULL. */\n#define XML_GetUserData(parser) (*(void **)(parser))\n\n/* This is equivalent to supplying an encoding argument to\n   XML_ParserCreate. On success XML_SetEncoding returns non-zero,\n   zero otherwise.\n   Note: Calling XML_SetEncoding after XML_Parse or XML_ParseBuffer\n     has no effect and returns XML_STATUS_ERROR.\n*/\nXMLPARSEAPI(enum XML_Status)\nXML_SetEncoding(XML_Parser parser, const XML_Char *encoding);\n\n/* If this function is called, then the parser will be passed as the\n   first argument to callbacks instead of userData.  The userData will\n   still be accessible using XML_GetUserData.\n*/\nXMLPARSEAPI(void)\nXML_UseParserAsHandlerArg(XML_Parser parser);\n\n/* If useDTD == XML_TRUE is passed to this function, then the parser\n   will assume that there is an external subset, even if none is\n   specified in the document. In such a case the parser will call the\n   externalEntityRefHandler with a value of NULL for the systemId\n   argument (the publicId and context arguments will be NULL as well).\n   Note: For the purpose of checking WFC: Entity Declared, passing\n     useDTD == XML_TRUE will make the parser behave as if the document\n     had a DTD with an external subset.\n   Note: If this function is called, then this must be done before\n     the first call to XML_Parse or XML_ParseBuffer, since it will\n     have no effect after that.  Returns\n     XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING.\n   Note: If the document does not have a DOCTYPE declaration at all,\n     then startDoctypeDeclHandler and endDoctypeDeclHandler will not\n     be called, despite an external subset being parsed.\n   Note: If XML_DTD is not defined when Expat is compiled, returns\n     XML_ERROR_FEATURE_REQUIRES_XML_DTD.\n   Note: If parser == NULL, returns XML_ERROR_INVALID_ARGUMENT.\n*/\nXMLPARSEAPI(enum XML_Error)\nXML_UseForeignDTD(XML_Parser parser, XML_Bool useDTD);\n\n/* Sets the base to be used for resolving relative URIs in system\n   identifiers in declarations.  Resolving relative identifiers is\n   left to the application: this value will be passed through as the\n   base argument to the XML_ExternalEntityRefHandler,\n   XML_NotationDeclHandler and XML_UnparsedEntityDeclHandler. The base\n   argument will be copied.  Returns XML_STATUS_ERROR if out of memory,\n   XML_STATUS_OK otherwise.\n*/\nXMLPARSEAPI(enum XML_Status)\nXML_SetBase(XML_Parser parser, const XML_Char *base);\n\nXMLPARSEAPI(const XML_Char *)\nXML_GetBase(XML_Parser parser);\n\n/* Returns the number of the attribute/value pairs passed in last call\n   to the XML_StartElementHandler that were specified in the start-tag\n   rather than defaulted. Each attribute/value pair counts as 2; thus\n   this corresponds to an index into the atts array passed to the\n   XML_StartElementHandler.  Returns -1 if parser == NULL.\n*/\nXMLPARSEAPI(int)\nXML_GetSpecifiedAttributeCount(XML_Parser parser);\n\n/* Returns the index of the ID attribute passed in the last call to\n   XML_StartElementHandler, or -1 if there is no ID attribute or\n   parser == NULL.  Each attribute/value pair counts as 2; thus this\n   corresponds to an index into the atts array passed to the\n   XML_StartElementHandler.\n*/\nXMLPARSEAPI(int)\nXML_GetIdAttributeIndex(XML_Parser parser);\n\n#ifdef XML_ATTR_INFO\n/* Source file byte offsets for the start and end of attribute names and values.\n   The value indices are exclusive of surrounding quotes; thus in a UTF-8 source\n   file an attribute value of \"blah\" will yield:\n   info->valueEnd - info->valueStart = 4 bytes.\n*/\ntypedef struct {\n  XML_Index nameStart;  /* Offset to beginning of the attribute name. */\n  XML_Index nameEnd;    /* Offset after the attribute name's last byte. */\n  XML_Index valueStart; /* Offset to beginning of the attribute value. */\n  XML_Index valueEnd;   /* Offset after the attribute value's last byte. */\n} XML_AttrInfo;\n\n/* Returns an array of XML_AttrInfo structures for the attribute/value pairs\n   passed in last call to the XML_StartElementHandler that were specified\n   in the start-tag rather than defaulted. Each attribute/value pair counts\n   as 1; thus the number of entries in the array is\n   XML_GetSpecifiedAttributeCount(parser) / 2.\n*/\nXMLPARSEAPI(const XML_AttrInfo *)\nXML_GetAttributeInfo(XML_Parser parser);\n#endif\n\n/* Parses some input. Returns XML_STATUS_ERROR if a fatal error is\n   detected.  The last call to XML_Parse must have isFinal true; len\n   may be zero for this call (or any other).\n\n   Though the return values for these functions has always been\n   described as a Boolean value, the implementation, at least for the\n   1.95.x series, has always returned exactly one of the XML_Status\n   values.\n*/\nXMLPARSEAPI(enum XML_Status)\nXML_Parse(XML_Parser parser, const char *s, int len, int isFinal);\n\nXMLPARSEAPI(void *)\nXML_GetBuffer(XML_Parser parser, int len);\n\nXMLPARSEAPI(enum XML_Status)\nXML_ParseBuffer(XML_Parser parser, int len, int isFinal);\n\n/* Stops parsing, causing XML_Parse() or XML_ParseBuffer() to return.\n   Must be called from within a call-back handler, except when aborting\n   (resumable = 0) an already suspended parser. Some call-backs may\n   still follow because they would otherwise get lost. Examples:\n   - endElementHandler() for empty elements when stopped in\n     startElementHandler(),\n   - endNameSpaceDeclHandler() when stopped in endElementHandler(),\n   and possibly others.\n\n   Can be called from most handlers, including DTD related call-backs,\n   except when parsing an external parameter entity and resumable != 0.\n   Returns XML_STATUS_OK when successful, XML_STATUS_ERROR otherwise.\n   Possible error codes:\n   - XML_ERROR_SUSPENDED: when suspending an already suspended parser.\n   - XML_ERROR_FINISHED: when the parser has already finished.\n   - XML_ERROR_SUSPEND_PE: when suspending while parsing an external PE.\n\n   When resumable != 0 (true) then parsing is suspended, that is,\n   XML_Parse() and XML_ParseBuffer() return XML_STATUS_SUSPENDED.\n   Otherwise, parsing is aborted, that is, XML_Parse() and XML_ParseBuffer()\n   return XML_STATUS_ERROR with error code XML_ERROR_ABORTED.\n\n   *Note*:\n   This will be applied to the current parser instance only, that is, if\n   there is a parent parser then it will continue parsing when the\n   externalEntityRefHandler() returns. It is up to the implementation of\n   the externalEntityRefHandler() to call XML_StopParser() on the parent\n   parser (recursively), if one wants to stop parsing altogether.\n\n   When suspended, parsing can be resumed by calling XML_ResumeParser().\n*/\nXMLPARSEAPI(enum XML_Status)\nXML_StopParser(XML_Parser parser, XML_Bool resumable);\n\n/* Resumes parsing after it has been suspended with XML_StopParser().\n   Must not be called from within a handler call-back. Returns same\n   status codes as XML_Parse() or XML_ParseBuffer().\n   Additional error code XML_ERROR_NOT_SUSPENDED possible.\n\n   *Note*:\n   This must be called on the most deeply nested child parser instance\n   first, and on its parent parser only after the child parser has finished,\n   to be applied recursively until the document entity's parser is restarted.\n   That is, the parent parser will not resume by itself and it is up to the\n   application to call XML_ResumeParser() on it at the appropriate moment.\n*/\nXMLPARSEAPI(enum XML_Status)\nXML_ResumeParser(XML_Parser parser);\n\nenum XML_Parsing { XML_INITIALIZED, XML_PARSING, XML_FINISHED, XML_SUSPENDED };\n\ntypedef struct {\n  enum XML_Parsing parsing;\n  XML_Bool finalBuffer;\n} XML_ParsingStatus;\n\n/* Returns status of parser with respect to being initialized, parsing,\n   finished, or suspended and processing the final buffer.\n   XXX XML_Parse() and XML_ParseBuffer() should return XML_ParsingStatus,\n   XXX with XML_FINISHED_OK or XML_FINISHED_ERROR replacing XML_FINISHED\n*/\nXMLPARSEAPI(void)\nXML_GetParsingStatus(XML_Parser parser, XML_ParsingStatus *status);\n\n/* Creates an XML_Parser object that can parse an external general\n   entity; context is a '\\0'-terminated string specifying the parse\n   context; encoding is a '\\0'-terminated string giving the name of\n   the externally specified encoding, or NULL if there is no\n   externally specified encoding.  The context string consists of a\n   sequence of tokens separated by formfeeds (\\f); a token consisting\n   of a name specifies that the general entity of the name is open; a\n   token of the form prefix=uri specifies the namespace for a\n   particular prefix; a token of the form =uri specifies the default\n   namespace.  This can be called at any point after the first call to\n   an ExternalEntityRefHandler so longer as the parser has not yet\n   been freed.  The new parser is completely independent and may\n   safely be used in a separate thread.  The handlers and userData are\n   initialized from the parser argument.  Returns NULL if out of memory.\n   Otherwise returns a new XML_Parser object.\n*/\nXMLPARSEAPI(XML_Parser)\nXML_ExternalEntityParserCreate(XML_Parser parser, const XML_Char *context,\n                               const XML_Char *encoding);\n\nenum XML_ParamEntityParsing {\n  XML_PARAM_ENTITY_PARSING_NEVER,\n  XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE,\n  XML_PARAM_ENTITY_PARSING_ALWAYS\n};\n\n/* Controls parsing of parameter entities (including the external DTD\n   subset). If parsing of parameter entities is enabled, then\n   references to external parameter entities (including the external\n   DTD subset) will be passed to the handler set with\n   XML_SetExternalEntityRefHandler.  The context passed will be 0.\n\n   Unlike external general entities, external parameter entities can\n   only be parsed synchronously.  If the external parameter entity is\n   to be parsed, it must be parsed during the call to the external\n   entity ref handler: the complete sequence of\n   XML_ExternalEntityParserCreate, XML_Parse/XML_ParseBuffer and\n   XML_ParserFree calls must be made during this call.  After\n   XML_ExternalEntityParserCreate has been called to create the parser\n   for the external parameter entity (context must be 0 for this\n   call), it is illegal to make any calls on the old parser until\n   XML_ParserFree has been called on the newly created parser.\n   If the library has been compiled without support for parameter\n   entity parsing (ie without XML_DTD being defined), then\n   XML_SetParamEntityParsing will return 0 if parsing of parameter\n   entities is requested; otherwise it will return non-zero.\n   Note: If XML_SetParamEntityParsing is called after XML_Parse or\n      XML_ParseBuffer, then it has no effect and will always return 0.\n   Note: If parser == NULL, the function will do nothing and return 0.\n*/\nXMLPARSEAPI(int)\nXML_SetParamEntityParsing(XML_Parser parser,\n                          enum XML_ParamEntityParsing parsing);\n\n/* Sets the hash salt to use for internal hash calculations.\n   Helps in preventing DoS attacks based on predicting hash\n   function behavior. This must be called before parsing is started.\n   Returns 1 if successful, 0 when called after parsing has started.\n   Note: If parser == NULL, the function will do nothing and return 0.\n*/\nXMLPARSEAPI(int)\nXML_SetHashSalt(XML_Parser parser, unsigned long hash_salt);\n\n/* If XML_Parse or XML_ParseBuffer have returned XML_STATUS_ERROR, then\n   XML_GetErrorCode returns information about the error.\n*/\nXMLPARSEAPI(enum XML_Error)\nXML_GetErrorCode(XML_Parser parser);\n\n/* These functions return information about the current parse\n   location.  They may be called from any callback called to report\n   some parse event; in this case the location is the location of the\n   first of the sequence of characters that generated the event.  When\n   called from callbacks generated by declarations in the document\n   prologue, the location identified isn't as neatly defined, but will\n   be within the relevant markup.  When called outside of the callback\n   functions, the position indicated will be just past the last parse\n   event (regardless of whether there was an associated callback).\n\n   They may also be called after returning from a call to XML_Parse\n   or XML_ParseBuffer.  If the return value is XML_STATUS_ERROR then\n   the location is the location of the character at which the error\n   was detected; otherwise the location is the location of the last\n   parse event, as described above.\n\n   Note: XML_GetCurrentLineNumber and XML_GetCurrentColumnNumber\n   return 0 to indicate an error.\n   Note: XML_GetCurrentByteIndex returns -1 to indicate an error.\n*/\nXMLPARSEAPI(XML_Size) XML_GetCurrentLineNumber(XML_Parser parser);\nXMLPARSEAPI(XML_Size) XML_GetCurrentColumnNumber(XML_Parser parser);\nXMLPARSEAPI(XML_Index) XML_GetCurrentByteIndex(XML_Parser parser);\n\n/* Return the number of bytes in the current event.\n   Returns 0 if the event is in an internal entity.\n*/\nXMLPARSEAPI(int)\nXML_GetCurrentByteCount(XML_Parser parser);\n\n/* If XML_CONTEXT_BYTES is >=1, returns the input buffer, sets\n   the integer pointed to by offset to the offset within this buffer\n   of the current parse position, and sets the integer pointed to by size\n   to the size of this buffer (the number of input bytes). Otherwise\n   returns a NULL pointer. Also returns a NULL pointer if a parse isn't\n   active.\n\n   NOTE: The character pointer returned should not be used outside\n   the handler that makes the call.\n*/\nXMLPARSEAPI(const char *)\nXML_GetInputContext(XML_Parser parser, int *offset, int *size);\n\n/* For backwards compatibility with previous versions. */\n#define XML_GetErrorLineNumber XML_GetCurrentLineNumber\n#define XML_GetErrorColumnNumber XML_GetCurrentColumnNumber\n#define XML_GetErrorByteIndex XML_GetCurrentByteIndex\n\n/* Frees the content model passed to the element declaration handler */\nXMLPARSEAPI(void)\nXML_FreeContentModel(XML_Parser parser, XML_Content *model);\n\n/* Exposing the memory handling functions used in Expat */\nXMLPARSEAPI(void *)\nXML_ATTR_MALLOC\nXML_ATTR_ALLOC_SIZE(2)\nXML_MemMalloc(XML_Parser parser, size_t size);\n\nXMLPARSEAPI(void *)\nXML_ATTR_ALLOC_SIZE(3)\nXML_MemRealloc(XML_Parser parser, void *ptr, size_t size);\n\nXMLPARSEAPI(void)\nXML_MemFree(XML_Parser parser, void *ptr);\n\n/* Frees memory used by the parser. */\nXMLPARSEAPI(void)\nXML_ParserFree(XML_Parser parser);\n\n/* Returns a string describing the error. */\nXMLPARSEAPI(const XML_LChar *)\nXML_ErrorString(enum XML_Error code);\n\n/* Return a string containing the version number of this expat */\nXMLPARSEAPI(const XML_LChar *)\nXML_ExpatVersion(void);\n\ntypedef struct {\n  int major;\n  int minor;\n  int micro;\n} XML_Expat_Version;\n\n/* Return an XML_Expat_Version structure containing numeric version\n   number information for this version of expat.\n*/\nXMLPARSEAPI(XML_Expat_Version)\nXML_ExpatVersionInfo(void);\n\n/* Added in Expat 1.95.5. */\nenum XML_FeatureEnum {\n  XML_FEATURE_END = 0,\n  XML_FEATURE_UNICODE,\n  XML_FEATURE_UNICODE_WCHAR_T,\n  XML_FEATURE_DTD,\n  XML_FEATURE_CONTEXT_BYTES,\n  XML_FEATURE_MIN_SIZE,\n  XML_FEATURE_SIZEOF_XML_CHAR,\n  XML_FEATURE_SIZEOF_XML_LCHAR,\n  XML_FEATURE_NS,\n  XML_FEATURE_LARGE_SIZE,\n  XML_FEATURE_ATTR_INFO,\n  /* Added in Expat 2.4.0. */\n  XML_FEATURE_BILLION_LAUGHS_ATTACK_PROTECTION_MAXIMUM_AMPLIFICATION_DEFAULT,\n  XML_FEATURE_BILLION_LAUGHS_ATTACK_PROTECTION_ACTIVATION_THRESHOLD_DEFAULT\n  /* Additional features must be added to the end of this enum. */\n};\n\ntypedef struct {\n  enum XML_FeatureEnum feature;\n  const XML_LChar *name;\n  long int value;\n} XML_Feature;\n\nXMLPARSEAPI(const XML_Feature *)\nXML_GetFeatureList(void);\n\n#ifdef XML_DTD\n/* Added in Expat 2.4.0. */\nXMLPARSEAPI(XML_Bool)\nXML_SetBillionLaughsAttackProtectionMaximumAmplification(\n    XML_Parser parser, float maximumAmplificationFactor);\n\n/* Added in Expat 2.4.0. */\nXMLPARSEAPI(XML_Bool)\nXML_SetBillionLaughsAttackProtectionActivationThreshold(\n    XML_Parser parser, unsigned long long activationThresholdBytes);\n#endif\n\n/* Expat follows the semantic versioning convention.\n   See https://semver.org\n*/\n#define XML_MAJOR_VERSION 2\n#define XML_MINOR_VERSION 5\n#define XML_MICRO_VERSION 0\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* not Expat_INCLUDED */\n", "/* internal.h\n\n   Internal definitions used by Expat.  This is not needed to compile\n   client code.\n\n   The following calling convention macros are defined for frequently\n   called functions:\n\n   FASTCALL    - Used for those internal functions that have a simple\n                 body and a low number of arguments and local variables.\n\n   PTRCALL     - Used for functions called though function pointers.\n\n   PTRFASTCALL - Like PTRCALL, but for low number of arguments.\n\n   inline      - Used for selected internal functions for which inlining\n                 may improve performance on some platforms.\n\n   Note: Use of these macros is based on judgement, not hard rules,\n         and therefore subject to change.\n                            __  __            _\n                         ___\\ \\/ /_ __   __ _| |_\n                        / _ \\\\  /| '_ \\ / _` | __|\n                       |  __//  \\| |_) | (_| | |_\n                        \\___/_/\\_\\ .__/ \\__,_|\\__|\n                                 |_| XML parser\n\n   Copyright (c) 2002-2003 Fred L. Drake, Jr. <fdrake@users.sourceforge.net>\n   Copyright (c) 2002-2006 Karl Waclawek <karl@waclawek.net>\n   Copyright (c) 2003      Greg Stein <gstein@users.sourceforge.net>\n   Copyright (c) 2016-2022 Sebastian Pipping <sebastian@pipping.org>\n   Copyright (c) 2018      Yury Gribov <tetra2005@gmail.com>\n   Copyright (c) 2019      David Loffredo <loffredo@steptools.com>\n   Licensed under the MIT license:\n\n   Permission is  hereby granted,  free of charge,  to any  person obtaining\n   a  copy  of  this  software   and  associated  documentation  files  (the\n   \"Software\"),  to  deal in  the  Software  without restriction,  including\n   without  limitation the  rights  to use,  copy,  modify, merge,  publish,\n   distribute, sublicense, and/or sell copies of the Software, and to permit\n   persons  to whom  the Software  is  furnished to  do so,  subject to  the\n   following conditions:\n\n   The above copyright  notice and this permission notice  shall be included\n   in all copies or substantial portions of the Software.\n\n   THE  SOFTWARE  IS  PROVIDED  \"AS  IS\",  WITHOUT  WARRANTY  OF  ANY  KIND,\n   EXPRESS  OR IMPLIED,  INCLUDING  BUT  NOT LIMITED  TO  THE WARRANTIES  OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n   NO EVENT SHALL THE AUTHORS OR  COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n   DAMAGES OR  OTHER LIABILITY, WHETHER  IN AN  ACTION OF CONTRACT,  TORT OR\n   OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n   USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#if defined(__GNUC__) && defined(__i386__) && ! defined(__MINGW32__)\n/* We'll use this version by default only where we know it helps.\n\n   regparm() generates warnings on Solaris boxes.   See SF bug #692878.\n\n   Instability reported with egcs on a RedHat Linux 7.3.\n   Let's comment out:\n   #define FASTCALL __attribute__((stdcall, regparm(3)))\n   and let's try this:\n*/\n#  define FASTCALL __attribute__((regparm(3)))\n#  define PTRFASTCALL __attribute__((regparm(3)))\n#endif\n\n/* Using __fastcall seems to have an unexpected negative effect under\n   MS VC++, especially for function pointers, so we won't use it for\n   now on that platform. It may be reconsidered for a future release\n   if it can be made more effective.\n   Likely reason: __fastcall on Windows is like stdcall, therefore\n   the compiler cannot perform stack optimizations for call clusters.\n*/\n\n/* Make sure all of these are defined if they aren't already. */\n\n#ifndef FASTCALL\n#  define FASTCALL\n#endif\n\n#ifndef PTRCALL\n#  define PTRCALL\n#endif\n\n#ifndef PTRFASTCALL\n#  define PTRFASTCALL\n#endif\n\n#ifndef XML_MIN_SIZE\n#  if ! defined(__cplusplus) && ! defined(inline)\n#    ifdef __GNUC__\n#      define inline __inline\n#    endif /* __GNUC__ */\n#  endif\n#endif /* XML_MIN_SIZE */\n\n#ifdef __cplusplus\n#  define inline inline\n#else\n#  ifndef inline\n#    define inline\n#  endif\n#endif\n\n#include <limits.h> // ULONG_MAX\n\n#if defined(_WIN32)                                                            \\\n    && (! defined(__USE_MINGW_ANSI_STDIO)                                      \\\n        || (1 - __USE_MINGW_ANSI_STDIO - 1 == 0))\n#  define EXPAT_FMT_ULL(midpart) \"%\" midpart \"I64u\"\n#  if defined(_WIN64) // Note: modifiers \"td\" and \"zu\" do not work for MinGW\n#    define EXPAT_FMT_PTRDIFF_T(midpart) \"%\" midpart \"I64d\"\n#    define EXPAT_FMT_SIZE_T(midpart) \"%\" midpart \"I64u\"\n#  else\n#    define EXPAT_FMT_PTRDIFF_T(midpart) \"%\" midpart \"d\"\n#    define EXPAT_FMT_SIZE_T(midpart) \"%\" midpart \"u\"\n#  endif\n#else\n#  define EXPAT_FMT_ULL(midpart) \"%\" midpart \"llu\"\n#  if ! defined(ULONG_MAX)\n#    error Compiler did not define ULONG_MAX for us\n#  elif ULONG_MAX == 18446744073709551615u // 2^64-1\n#    define EXPAT_FMT_PTRDIFF_T(midpart) \"%\" midpart \"ld\"\n#    define EXPAT_FMT_SIZE_T(midpart) \"%\" midpart \"lu\"\n#  else\n#    define EXPAT_FMT_PTRDIFF_T(midpart) \"%\" midpart \"d\"\n#    define EXPAT_FMT_SIZE_T(midpart) \"%\" midpart \"u\"\n#  endif\n#endif\n\n#ifndef UNUSED_P\n#  define UNUSED_P(p) (void)p\n#endif\n\n/* NOTE BEGIN If you ever patch these defaults to greater values\n              for non-attack XML payload in your environment,\n              please file a bug report with libexpat.  Thank you!\n*/\n#define EXPAT_BILLION_LAUGHS_ATTACK_PROTECTION_MAXIMUM_AMPLIFICATION_DEFAULT   \\\n  100.0f\n#define EXPAT_BILLION_LAUGHS_ATTACK_PROTECTION_ACTIVATION_THRESHOLD_DEFAULT    \\\n  8388608 // 8 MiB, 2^23\n/* NOTE END */\n\n#include \"expat.h\" // so we can use type XML_Parser below\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nvoid _INTERNAL_trim_to_complete_utf8_characters(const char *from,\n                                                const char **fromLimRef);\n\n#if defined(XML_DTD)\nunsigned long long testingAccountingGetCountBytesDirect(XML_Parser parser);\nunsigned long long testingAccountingGetCountBytesIndirect(XML_Parser parser);\nconst char *unsignedCharToPrintable(unsigned char c);\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n", "; DEF file for MS VC++\n\nEXPORTS\n  XML_DefaultCurrent @1\n  XML_ErrorString @2\n  XML_ExpatVersion @3\n  XML_ExpatVersionInfo @4\n  XML_ExternalEntityParserCreate @5\n  XML_GetBase @6\n  XML_GetBuffer @7\n  XML_GetCurrentByteCount @8\n  XML_GetCurrentByteIndex @9\n  XML_GetCurrentColumnNumber @10\n  XML_GetCurrentLineNumber @11\n  XML_GetErrorCode @12\n  XML_GetIdAttributeIndex @13\n  XML_GetInputContext @14\n  XML_GetSpecifiedAttributeCount @15\n  XML_Parse @16\n  XML_ParseBuffer @17\n  XML_ParserCreate @18\n  XML_ParserCreateNS @19\n  XML_ParserCreate_MM @20\n  XML_ParserFree @21\n  XML_SetAttlistDeclHandler @22\n  XML_SetBase @23\n  XML_SetCdataSectionHandler @24\n  XML_SetCharacterDataHandler @25\n  XML_SetCommentHandler @26\n  XML_SetDefaultHandler @27\n  XML_SetDefaultHandlerExpand @28\n  XML_SetDoctypeDeclHandler @29\n  XML_SetElementDeclHandler @30\n  XML_SetElementHandler @31\n  XML_SetEncoding @32\n  XML_SetEndCdataSectionHandler @33\n  XML_SetEndDoctypeDeclHandler @34\n  XML_SetEndElementHandler @35\n  XML_SetEndNamespaceDeclHandler @36\n  XML_SetEntityDeclHandler @37\n  XML_SetExternalEntityRefHandler @38\n  XML_SetExternalEntityRefHandlerArg @39\n  XML_SetNamespaceDeclHandler @40\n  XML_SetNotStandaloneHandler @41\n  XML_SetNotationDeclHandler @42\n  XML_SetParamEntityParsing @43\n  XML_SetProcessingInstructionHandler @44\n  XML_SetReturnNSTriplet @45\n  XML_SetStartCdataSectionHandler @46\n  XML_SetStartDoctypeDeclHandler @47\n  XML_SetStartElementHandler @48\n  XML_SetStartNamespaceDeclHandler @49\n  XML_SetUnknownEncodingHandler @50\n  XML_SetUnparsedEntityDeclHandler @51\n  XML_SetUserData @52\n  XML_SetXmlDeclHandler @53\n  XML_UseParserAsHandlerArg @54\n; added with version 1.95.3\n  XML_ParserReset @55\n  XML_SetSkippedEntityHandler @56\n; added with version 1.95.5\n  XML_GetFeatureList @57\n  XML_UseForeignDTD @58\n; added with version 1.95.6\n  XML_FreeContentModel @59\n  XML_MemMalloc @60\n  XML_MemRealloc @61\n  XML_MemFree @62\n; added with version 1.95.8\n  XML_StopParser @63\n  XML_ResumeParser @64\n  XML_GetParsingStatus @65\n; added with version 2.1.1\n@_EXPAT_COMMENT_ATTR_INFO@ XML_GetAttributeInfo @66\n  XML_SetHashSalt @67\n; internal @68 removed with version 2.3.1\n; added with version 2.4.0\n@_EXPAT_COMMENT_DTD@ XML_SetBillionLaughsAttackProtectionActivationThreshold @69\n@_EXPAT_COMMENT_DTD@ XML_SetBillionLaughsAttackProtectionMaximumAmplification @70\n", "/* 5ab094ffadd6edfc94c3eee53af44a86951f9f1f0933ada3114bbce2bfb02c99 (2.5.0+)\n                            __  __            _\n                         ___\\ \\/ /_ __   __ _| |_\n                        / _ \\\\  /| '_ \\ / _` | __|\n                       |  __//  \\| |_) | (_| | |_\n                        \\___/_/\\_\\ .__/ \\__,_|\\__|\n                                 |_| XML parser\n\n   Copyright (c) 1997-2000 Thai Open Source Software Center Ltd\n   Copyright (c) 2000      Clark Cooper <coopercc@users.sourceforge.net>\n   Copyright (c) 2000-2006 Fred L. Drake, Jr. <fdrake@users.sourceforge.net>\n   Copyright (c) 2001-2002 Greg Stein <gstein@users.sourceforge.net>\n   Copyright (c) 2002-2016 Karl Waclawek <karl@waclawek.net>\n   Copyright (c) 2005-2009 Steven Solie <steven@solie.ca>\n   Copyright (c) 2016      Eric Rahm <erahm@mozilla.com>\n   Copyright (c) 2016-2022 Sebastian Pipping <sebastian@pipping.org>\n   Copyright (c) 2016      Gaurav <g.gupta@samsung.com>\n   Copyright (c) 2016      Thomas Beutlich <tc@tbeu.de>\n   Copyright (c) 2016      Gustavo Grieco <gustavo.grieco@imag.fr>\n   Copyright (c) 2016      Pascal Cuoq <cuoq@trust-in-soft.com>\n   Copyright (c) 2016      Ed Schouten <ed@nuxi.nl>\n   Copyright (c) 2017-2022 Rhodri James <rhodri@wildebeest.org.uk>\n   Copyright (c) 2017      V\u00e1clav Slav\u00edk <vaclav@slavik.io>\n   Copyright (c) 2017      Viktor Szakats <commit@vsz.me>\n   Copyright (c) 2017      Chanho Park <chanho61.park@samsung.com>\n   Copyright (c) 2017      Rolf Eike Beer <eike@sf-mail.de>\n   Copyright (c) 2017      Hans Wennborg <hans@chromium.org>\n   Copyright (c) 2018      Anton Maklakov <antmak.pub@gmail.com>\n   Copyright (c) 2018      Benjamin Peterson <benjamin@python.org>\n   Copyright (c) 2018      Marco Maggi <marco.maggi-ipsu@poste.it>\n   Copyright (c) 2018      Mariusz Zaborski <oshogbo@vexillium.org>\n   Copyright (c) 2019      David Loffredo <loffredo@steptools.com>\n   Copyright (c) 2019-2020 Ben Wagner <bungeman@chromium.org>\n   Copyright (c) 2019      Vadim Zeitlin <vadim@zeitlins.org>\n   Copyright (c) 2021      Donghee Na <donghee.na@python.org>\n   Copyright (c) 2022      Samanta Navarro <ferivoz@riseup.net>\n   Copyright (c) 2022      Jeffrey Walton <noloader@gmail.com>\n   Copyright (c) 2022      Jann Horn <jannh@google.com>\n   Copyright (c) 2023      Sony Corporation / Snild Dolkow <snild@sony.com>\n   Licensed under the MIT license:\n\n   Permission is  hereby granted,  free of charge,  to any  person obtaining\n   a  copy  of  this  software   and  associated  documentation  files  (the\n   \"Software\"),  to  deal in  the  Software  without restriction,  including\n   without  limitation the  rights  to use,  copy,  modify, merge,  publish,\n   distribute, sublicense, and/or sell copies of the Software, and to permit\n   persons  to whom  the Software  is  furnished to  do so,  subject to  the\n   following conditions:\n\n   The above copyright  notice and this permission notice  shall be included\n   in all copies or substantial portions of the Software.\n\n   THE  SOFTWARE  IS  PROVIDED  \"AS  IS\",  WITHOUT  WARRANTY  OF  ANY  KIND,\n   EXPRESS  OR IMPLIED,  INCLUDING  BUT  NOT LIMITED  TO  THE WARRANTIES  OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n   NO EVENT SHALL THE AUTHORS OR  COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n   DAMAGES OR  OTHER LIABILITY, WHETHER  IN AN  ACTION OF CONTRACT,  TORT OR\n   OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n   USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#define XML_BUILDING_EXPAT 1\n\n#include \"expat_config.h\"\n\n#if ! defined(XML_CONTEXT_BYTES) || (1 - XML_CONTEXT_BYTES - 1 == 2)           \\\n    || (XML_CONTEXT_BYTES + 0 < 0)\n#  error XML_CONTEXT_BYTES must be defined, non-empty and >=0 (0 to disable, >=1 to enable; 1024 is a common default)\n#endif\n\n#if defined(HAVE_SYSCALL_GETRANDOM)\n#  if ! defined(_GNU_SOURCE)\n#    define _GNU_SOURCE 1 /* syscall prototype */\n#  endif\n#endif\n\n#ifdef _WIN32\n/* force stdlib to define rand_s() */\n#  if ! defined(_CRT_RAND_S)\n#    define _CRT_RAND_S\n#  endif\n#endif\n\n#include <stddef.h>\n#include <string.h> /* memset(), memcpy() */\n#include <assert.h>\n#include <limits.h> /* UINT_MAX */\n#include <stdio.h>  /* fprintf */\n#include <stdlib.h> /* getenv, rand_s */\n#include <stdint.h> /* uintptr_t */\n#include <math.h>   /* isnan */\n\n#ifdef _WIN32\n#  define getpid GetCurrentProcessId\n#else\n#  include <sys/time.h>  /* gettimeofday() */\n#  include <sys/types.h> /* getpid() */\n#  include <unistd.h>    /* getpid() */\n#  include <fcntl.h>     /* O_RDONLY */\n#  include <errno.h>\n#endif\n\n#ifdef _WIN32\n#  include \"winconfig.h\"\n#endif\n\n#include \"ascii.h\"\n#include \"expat.h\"\n#include \"siphash.h\"\n\n#if defined(HAVE_GETRANDOM) || defined(HAVE_SYSCALL_GETRANDOM)\n#  if defined(HAVE_GETRANDOM)\n#    include <sys/random.h> /* getrandom */\n#  else\n#    include <unistd.h>      /* syscall */\n#    include <sys/syscall.h> /* SYS_getrandom */\n#  endif\n#  if ! defined(GRND_NONBLOCK)\n#    define GRND_NONBLOCK 0x0001\n#  endif /* defined(GRND_NONBLOCK) */\n#endif   /* defined(HAVE_GETRANDOM) || defined(HAVE_SYSCALL_GETRANDOM) */\n\n#if defined(HAVE_LIBBSD)                                                       \\\n    && (defined(HAVE_ARC4RANDOM_BUF) || defined(HAVE_ARC4RANDOM))\n#  include <bsd/stdlib.h>\n#endif\n\n#if defined(_WIN32) && ! defined(LOAD_LIBRARY_SEARCH_SYSTEM32)\n#  define LOAD_LIBRARY_SEARCH_SYSTEM32 0x00000800\n#endif\n\n#if ! defined(HAVE_GETRANDOM) && ! defined(HAVE_SYSCALL_GETRANDOM)             \\\n    && ! defined(HAVE_ARC4RANDOM_BUF) && ! defined(HAVE_ARC4RANDOM)            \\\n    && ! defined(XML_DEV_URANDOM) && ! defined(_WIN32)                         \\\n    && ! defined(XML_POOR_ENTROPY)\n#  error You do not have support for any sources of high quality entropy \\\n    enabled.  For end user security, that is probably not what you want. \\\n    \\\n    Your options include: \\\n      * Linux >=3.17 + glibc >=2.25 (getrandom): HAVE_GETRANDOM, \\\n      * Linux >=3.17 + glibc (including <2.25) (syscall SYS_getrandom): HAVE_SYSCALL_GETRANDOM, \\\n      * BSD / macOS >=10.7 / glibc >=2.36 (arc4random_buf): HAVE_ARC4RANDOM_BUF, \\\n      * BSD / macOS (including <10.7) / glibc >=2.36 (arc4random): HAVE_ARC4RANDOM, \\\n      * libbsd (arc4random_buf): HAVE_ARC4RANDOM_BUF + HAVE_LIBBSD, \\\n      * libbsd (arc4random): HAVE_ARC4RANDOM + HAVE_LIBBSD, \\\n      * Linux (including <3.17) / BSD / macOS (including <10.7) / Solaris >=8 (/dev/urandom): XML_DEV_URANDOM, \\\n      * Windows >=Vista (rand_s): _WIN32. \\\n    \\\n    If insist on not using any of these, bypass this error by defining \\\n    XML_POOR_ENTROPY; you have been warned. \\\n    \\\n    If you have reasons to patch this detection code away or need changes \\\n    to the build system, please open a bug.  Thank you!\n#endif\n\n#ifdef XML_UNICODE\n#  define XML_ENCODE_MAX XML_UTF16_ENCODE_MAX\n#  define XmlConvert XmlUtf16Convert\n#  define XmlGetInternalEncoding XmlGetUtf16InternalEncoding\n#  define XmlGetInternalEncodingNS XmlGetUtf16InternalEncodingNS\n#  define XmlEncode XmlUtf16Encode\n#  define MUST_CONVERT(enc, s) (! (enc)->isUtf16 || (((uintptr_t)(s)) & 1))\ntypedef unsigned short ICHAR;\n#else\n#  define XML_ENCODE_MAX XML_UTF8_ENCODE_MAX\n#  define XmlConvert XmlUtf8Convert\n#  define XmlGetInternalEncoding XmlGetUtf8InternalEncoding\n#  define XmlGetInternalEncodingNS XmlGetUtf8InternalEncodingNS\n#  define XmlEncode XmlUtf8Encode\n#  define MUST_CONVERT(enc, s) (! (enc)->isUtf8)\ntypedef char ICHAR;\n#endif\n\n#ifndef XML_NS\n\n#  define XmlInitEncodingNS XmlInitEncoding\n#  define XmlInitUnknownEncodingNS XmlInitUnknownEncoding\n#  undef XmlGetInternalEncodingNS\n#  define XmlGetInternalEncodingNS XmlGetInternalEncoding\n#  define XmlParseXmlDeclNS XmlParseXmlDecl\n\n#endif\n\n#ifdef XML_UNICODE\n\n#  ifdef XML_UNICODE_WCHAR_T\n#    define XML_T(x) (const wchar_t) x\n#    define XML_L(x) L##x\n#  else\n#    define XML_T(x) (const unsigned short)x\n#    define XML_L(x) x\n#  endif\n\n#else\n\n#  define XML_T(x) x\n#  define XML_L(x) x\n\n#endif\n\n/* Round up n to be a multiple of sz, where sz is a power of 2. */\n#define ROUND_UP(n, sz) (((n) + ((sz)-1)) & ~((sz)-1))\n\n/* Do safe (NULL-aware) pointer arithmetic */\n#define EXPAT_SAFE_PTR_DIFF(p, q) (((p) && (q)) ? ((p) - (q)) : 0)\n\n#include \"internal.h\"\n#include \"xmltok.h\"\n#include \"xmlrole.h\"\n\ntypedef const XML_Char *KEY;\n\ntypedef struct {\n  KEY name;\n} NAMED;\n\ntypedef struct {\n  NAMED **v;\n  unsigned char power;\n  size_t size;\n  size_t used;\n  const XML_Memory_Handling_Suite *mem;\n} HASH_TABLE;\n\nstatic size_t keylen(KEY s);\n\nstatic void copy_salt_to_sipkey(XML_Parser parser, struct sipkey *key);\n\n/* For probing (after a collision) we need a step size relative prime\n   to the hash table size, which is a power of 2. We use double-hashing,\n   since we can calculate a second hash value cheaply by taking those bits\n   of the first hash value that were discarded (masked out) when the table\n   index was calculated: index = hash & mask, where mask = table->size - 1.\n   We limit the maximum step size to table->size / 4 (mask >> 2) and make\n   it odd, since odd numbers are always relative prime to a power of 2.\n*/\n#define SECOND_HASH(hash, mask, power)                                         \\\n  ((((hash) & ~(mask)) >> ((power)-1)) & ((mask) >> 2))\n#define PROBE_STEP(hash, mask, power)                                          \\\n  ((unsigned char)((SECOND_HASH(hash, mask, power)) | 1))\n\ntypedef struct {\n  NAMED **p;\n  NAMED **end;\n} HASH_TABLE_ITER;\n\n#define INIT_TAG_BUF_SIZE 32 /* must be a multiple of sizeof(XML_Char) */\n#define INIT_DATA_BUF_SIZE 1024\n#define INIT_ATTS_SIZE 16\n#define INIT_ATTS_VERSION 0xFFFFFFFF\n#define INIT_BLOCK_SIZE 1024\n#define INIT_BUFFER_SIZE 1024\n\n#define EXPAND_SPARE 24\n\ntypedef struct binding {\n  struct prefix *prefix;\n  struct binding *nextTagBinding;\n  struct binding *prevPrefixBinding;\n  const struct attribute_id *attId;\n  XML_Char *uri;\n  int uriLen;\n  int uriAlloc;\n} BINDING;\n\ntypedef struct prefix {\n  const XML_Char *name;\n  BINDING *binding;\n} PREFIX;\n\ntypedef struct {\n  const XML_Char *str;\n  const XML_Char *localPart;\n  const XML_Char *prefix;\n  int strLen;\n  int uriLen;\n  int prefixLen;\n} TAG_NAME;\n\n/* TAG represents an open element.\n   The name of the element is stored in both the document and API\n   encodings.  The memory buffer 'buf' is a separately-allocated\n   memory area which stores the name.  During the XML_Parse()/\n   XMLParseBuffer() when the element is open, the memory for the 'raw'\n   version of the name (in the document encoding) is shared with the\n   document buffer.  If the element is open across calls to\n   XML_Parse()/XML_ParseBuffer(), the buffer is re-allocated to\n   contain the 'raw' name as well.\n\n   A parser reuses these structures, maintaining a list of allocated\n   TAG objects in a free list.\n*/\ntypedef struct tag {\n  struct tag *parent;  /* parent of this element */\n  const char *rawName; /* tagName in the original encoding */\n  int rawNameLength;\n  TAG_NAME name; /* tagName in the API encoding */\n  char *buf;     /* buffer for name components */\n  char *bufEnd;  /* end of the buffer */\n  BINDING *bindings;\n} TAG;\n\ntypedef struct {\n  const XML_Char *name;\n  const XML_Char *textPtr;\n  int textLen;   /* length in XML_Chars */\n  int processed; /* # of processed bytes - when suspended */\n  const XML_Char *systemId;\n  const XML_Char *base;\n  const XML_Char *publicId;\n  const XML_Char *notation;\n  XML_Bool open;\n  XML_Bool is_param;\n  XML_Bool is_internal; /* true if declared in internal subset outside PE */\n} ENTITY;\n\ntypedef struct {\n  enum XML_Content_Type type;\n  enum XML_Content_Quant quant;\n  const XML_Char *name;\n  int firstchild;\n  int lastchild;\n  int childcnt;\n  int nextsib;\n} CONTENT_SCAFFOLD;\n\n#define INIT_SCAFFOLD_ELEMENTS 32\n\ntypedef struct block {\n  struct block *next;\n  int size;\n  XML_Char s[1];\n} BLOCK;\n\ntypedef struct {\n  BLOCK *blocks;\n  BLOCK *freeBlocks;\n  const XML_Char *end;\n  XML_Char *ptr;\n  XML_Char *start;\n  const XML_Memory_Handling_Suite *mem;\n} STRING_POOL;\n\n/* The XML_Char before the name is used to determine whether\n   an attribute has been specified. */\ntypedef struct attribute_id {\n  XML_Char *name;\n  PREFIX *prefix;\n  XML_Bool maybeTokenized;\n  XML_Bool xmlns;\n} ATTRIBUTE_ID;\n\ntypedef struct {\n  const ATTRIBUTE_ID *id;\n  XML_Bool isCdata;\n  const XML_Char *value;\n} DEFAULT_ATTRIBUTE;\n\ntypedef struct {\n  unsigned long version;\n  unsigned long hash;\n  const XML_Char *uriName;\n} NS_ATT;\n\ntypedef struct {\n  const XML_Char *name;\n  PREFIX *prefix;\n  const ATTRIBUTE_ID *idAtt;\n  int nDefaultAtts;\n  int allocDefaultAtts;\n  DEFAULT_ATTRIBUTE *defaultAtts;\n} ELEMENT_TYPE;\n\ntypedef struct {\n  HASH_TABLE generalEntities;\n  HASH_TABLE elementTypes;\n  HASH_TABLE attributeIds;\n  HASH_TABLE prefixes;\n  STRING_POOL pool;\n  STRING_POOL entityValuePool;\n  /* false once a parameter entity reference has been skipped */\n  XML_Bool keepProcessing;\n  /* true once an internal or external PE reference has been encountered;\n     this includes the reference to an external subset */\n  XML_Bool hasParamEntityRefs;\n  XML_Bool standalone;\n#ifdef XML_DTD\n  /* indicates if external PE has been read */\n  XML_Bool paramEntityRead;\n  HASH_TABLE paramEntities;\n#endif /* XML_DTD */\n  PREFIX defaultPrefix;\n  /* === scaffolding for building content model === */\n  XML_Bool in_eldecl;\n  CONTENT_SCAFFOLD *scaffold;\n  unsigned contentStringLen;\n  unsigned scaffSize;\n  unsigned scaffCount;\n  int scaffLevel;\n  int *scaffIndex;\n} DTD;\n\ntypedef struct open_internal_entity {\n  const char *internalEventPtr;\n  const char *internalEventEndPtr;\n  struct open_internal_entity *next;\n  ENTITY *entity;\n  int startTagLevel;\n  XML_Bool betweenDecl; /* WFC: PE Between Declarations */\n} OPEN_INTERNAL_ENTITY;\n\nenum XML_Account {\n  XML_ACCOUNT_DIRECT,           /* bytes directly passed to the Expat parser */\n  XML_ACCOUNT_ENTITY_EXPANSION, /* intermediate bytes produced during entity\n                                   expansion */\n  XML_ACCOUNT_NONE              /* i.e. do not account, was accounted already */\n};\n\n#ifdef XML_DTD\ntypedef unsigned long long XmlBigCount;\ntypedef struct accounting {\n  XmlBigCount countBytesDirect;\n  XmlBigCount countBytesIndirect;\n  unsigned long debugLevel;\n  float maximumAmplificationFactor; // >=1.0\n  unsigned long long activationThresholdBytes;\n} ACCOUNTING;\n\ntypedef struct entity_stats {\n  unsigned int countEverOpened;\n  unsigned int currentDepth;\n  unsigned int maximumDepthSeen;\n  unsigned long debugLevel;\n} ENTITY_STATS;\n#endif /* XML_DTD */\n\ntypedef enum XML_Error PTRCALL Processor(XML_Parser parser, const char *start,\n                                         const char *end, const char **endPtr);\n\nstatic Processor prologProcessor;\nstatic Processor prologInitProcessor;\nstatic Processor contentProcessor;\nstatic Processor cdataSectionProcessor;\n#ifdef XML_DTD\nstatic Processor ignoreSectionProcessor;\nstatic Processor externalParEntProcessor;\nstatic Processor externalParEntInitProcessor;\nstatic Processor entityValueProcessor;\nstatic Processor entityValueInitProcessor;\n#endif /* XML_DTD */\nstatic Processor epilogProcessor;\nstatic Processor errorProcessor;\nstatic Processor externalEntityInitProcessor;\nstatic Processor externalEntityInitProcessor2;\nstatic Processor externalEntityInitProcessor3;\nstatic Processor externalEntityContentProcessor;\nstatic Processor internalEntityProcessor;\n\nstatic enum XML_Error handleUnknownEncoding(XML_Parser parser,\n                                            const XML_Char *encodingName);\nstatic enum XML_Error processXmlDecl(XML_Parser parser, int isGeneralTextEntity,\n                                     const char *s, const char *next);\nstatic enum XML_Error initializeEncoding(XML_Parser parser);\nstatic enum XML_Error doProlog(XML_Parser parser, const ENCODING *enc,\n                               const char *s, const char *end, int tok,\n                               const char *next, const char **nextPtr,\n                               XML_Bool haveMore, XML_Bool allowClosingDoctype,\n                               enum XML_Account account);\nstatic enum XML_Error processInternalEntity(XML_Parser parser, ENTITY *entity,\n                                            XML_Bool betweenDecl);\nstatic enum XML_Error doContent(XML_Parser parser, int startTagLevel,\n                                const ENCODING *enc, const char *start,\n                                const char *end, const char **endPtr,\n                                XML_Bool haveMore, enum XML_Account account);\nstatic enum XML_Error doCdataSection(XML_Parser parser, const ENCODING *,\n                                     const char **startPtr, const char *end,\n                                     const char **nextPtr, XML_Bool haveMore,\n                                     enum XML_Account account);\n#ifdef XML_DTD\nstatic enum XML_Error doIgnoreSection(XML_Parser parser, const ENCODING *,\n                                      const char **startPtr, const char *end,\n                                      const char **nextPtr, XML_Bool haveMore);\n#endif /* XML_DTD */\n\nstatic void freeBindings(XML_Parser parser, BINDING *bindings);\nstatic enum XML_Error storeAtts(XML_Parser parser, const ENCODING *,\n                                const char *s, TAG_NAME *tagNamePtr,\n                                BINDING **bindingsPtr,\n                                enum XML_Account account);\nstatic enum XML_Error addBinding(XML_Parser parser, PREFIX *prefix,\n                                 const ATTRIBUTE_ID *attId, const XML_Char *uri,\n                                 BINDING **bindingsPtr);\nstatic int defineAttribute(ELEMENT_TYPE *type, ATTRIBUTE_ID *, XML_Bool isCdata,\n                           XML_Bool isId, const XML_Char *dfltValue,\n                           XML_Parser parser);\nstatic enum XML_Error storeAttributeValue(XML_Parser parser, const ENCODING *,\n                                          XML_Bool isCdata, const char *,\n                                          const char *, STRING_POOL *,\n                                          enum XML_Account account);\nstatic enum XML_Error appendAttributeValue(XML_Parser parser, const ENCODING *,\n                                           XML_Bool isCdata, const char *,\n                                           const char *, STRING_POOL *,\n                                           enum XML_Account account);\nstatic ATTRIBUTE_ID *getAttributeId(XML_Parser parser, const ENCODING *enc,\n                                    const char *start, const char *end);\nstatic int setElementTypePrefix(XML_Parser parser, ELEMENT_TYPE *);\nstatic enum XML_Error storeEntityValue(XML_Parser parser, const ENCODING *enc,\n                                       const char *start, const char *end,\n                                       enum XML_Account account);\nstatic int reportProcessingInstruction(XML_Parser parser, const ENCODING *enc,\n                                       const char *start, const char *end);\nstatic int reportComment(XML_Parser parser, const ENCODING *enc,\n                         const char *start, const char *end);\nstatic void reportDefault(XML_Parser parser, const ENCODING *enc,\n                          const char *start, const char *end);\n\nstatic const XML_Char *getContext(XML_Parser parser);\nstatic XML_Bool setContext(XML_Parser parser, const XML_Char *context);\n\nstatic void FASTCALL normalizePublicId(XML_Char *s);\n\nstatic DTD *dtdCreate(const XML_Memory_Handling_Suite *ms);\n/* do not call if m_parentParser != NULL */\nstatic void dtdReset(DTD *p, const XML_Memory_Handling_Suite *ms);\nstatic void dtdDestroy(DTD *p, XML_Bool isDocEntity,\n                       const XML_Memory_Handling_Suite *ms);\nstatic int dtdCopy(XML_Parser oldParser, DTD *newDtd, const DTD *oldDtd,\n                   const XML_Memory_Handling_Suite *ms);\nstatic int copyEntityTable(XML_Parser oldParser, HASH_TABLE *, STRING_POOL *,\n                           const HASH_TABLE *);\nstatic NAMED *lookup(XML_Parser parser, HASH_TABLE *table, KEY name,\n                     size_t createSize);\nstatic void FASTCALL hashTableInit(HASH_TABLE *,\n                                   const XML_Memory_Handling_Suite *ms);\nstatic void FASTCALL hashTableClear(HASH_TABLE *);\nstatic void FASTCALL hashTableDestroy(HASH_TABLE *);\nstatic void FASTCALL hashTableIterInit(HASH_TABLE_ITER *, const HASH_TABLE *);\nstatic NAMED *FASTCALL hashTableIterNext(HASH_TABLE_ITER *);\n\nstatic void FASTCALL poolInit(STRING_POOL *,\n                              const XML_Memory_Handling_Suite *ms);\nstatic void FASTCALL poolClear(STRING_POOL *);\nstatic void FASTCALL poolDestroy(STRING_POOL *);\nstatic XML_Char *poolAppend(STRING_POOL *pool, const ENCODING *enc,\n                            const char *ptr, const char *end);\nstatic XML_Char *poolStoreString(STRING_POOL *pool, const ENCODING *enc,\n                                 const char *ptr, const char *end);\nstatic XML_Bool FASTCALL poolGrow(STRING_POOL *pool);\nstatic const XML_Char *FASTCALL poolCopyString(STRING_POOL *pool,\n                                               const XML_Char *s);\nstatic const XML_Char *poolCopyStringN(STRING_POOL *pool, const XML_Char *s,\n                                       int n);\nstatic const XML_Char *FASTCALL poolAppendString(STRING_POOL *pool,\n                                                 const XML_Char *s);\n\nstatic int FASTCALL nextScaffoldPart(XML_Parser parser);\nstatic XML_Content *build_model(XML_Parser parser);\nstatic ELEMENT_TYPE *getElementType(XML_Parser parser, const ENCODING *enc,\n                                    const char *ptr, const char *end);\n\nstatic XML_Char *copyString(const XML_Char *s,\n                            const XML_Memory_Handling_Suite *memsuite);\n\nstatic unsigned long generate_hash_secret_salt(XML_Parser parser);\nstatic XML_Bool startParsing(XML_Parser parser);\n\nstatic XML_Parser parserCreate(const XML_Char *encodingName,\n                               const XML_Memory_Handling_Suite *memsuite,\n                               const XML_Char *nameSep, DTD *dtd);\n\nstatic void parserInit(XML_Parser parser, const XML_Char *encodingName);\n\n#ifdef XML_DTD\nstatic float accountingGetCurrentAmplification(XML_Parser rootParser);\nstatic void accountingReportStats(XML_Parser originParser, const char *epilog);\nstatic void accountingOnAbort(XML_Parser originParser);\nstatic void accountingReportDiff(XML_Parser rootParser,\n                                 unsigned int levelsAwayFromRootParser,\n                                 const char *before, const char *after,\n                                 ptrdiff_t bytesMore, int source_line,\n                                 enum XML_Account account);\nstatic XML_Bool accountingDiffTolerated(XML_Parser originParser, int tok,\n                                        const char *before, const char *after,\n                                        int source_line,\n                                        enum XML_Account account);\n\nstatic void entityTrackingReportStats(XML_Parser parser, ENTITY *entity,\n                                      const char *action, int sourceLine);\nstatic void entityTrackingOnOpen(XML_Parser parser, ENTITY *entity,\n                                 int sourceLine);\nstatic void entityTrackingOnClose(XML_Parser parser, ENTITY *entity,\n                                  int sourceLine);\n\nstatic XML_Parser getRootParserOf(XML_Parser parser,\n                                  unsigned int *outLevelDiff);\n#endif /* XML_DTD */\n\nstatic unsigned long getDebugLevel(const char *variableName,\n                                   unsigned long defaultDebugLevel);\n\n#define poolStart(pool) ((pool)->start)\n#define poolLength(pool) ((pool)->ptr - (pool)->start)\n#define poolChop(pool) ((void)--(pool->ptr))\n#define poolLastChar(pool) (((pool)->ptr)[-1])\n#define poolDiscard(pool) ((pool)->ptr = (pool)->start)\n#define poolFinish(pool) ((pool)->start = (pool)->ptr)\n#define poolAppendChar(pool, c)                                                \\\n  (((pool)->ptr == (pool)->end && ! poolGrow(pool))                            \\\n       ? 0                                                                     \\\n       : ((*((pool)->ptr)++ = c), 1))\n\nstruct XML_ParserStruct {\n  /* The first member must be m_userData so that the XML_GetUserData\n     macro works. */\n  void *m_userData;\n  void *m_handlerArg;\n\n  // How the four parse buffer pointers below relate in time and space:\n  //\n  //   m_buffer <= m_bufferPtr <= m_bufferEnd  <= m_bufferLim\n  //   |           |              |               |\n  //   <--parsed-->|              |               |\n  //               <---parsing--->|               |\n  //                              <--unoccupied-->|\n  //   <---------total-malloced/realloced-------->|\n\n  char *m_buffer; // malloc/realloc base pointer of parse buffer\n  const XML_Memory_Handling_Suite m_mem;\n  const char *m_bufferPtr; // first character to be parsed\n  char *m_bufferEnd;       // past last character to be parsed\n  const char *m_bufferLim; // allocated end of m_buffer\n\n  XML_Index m_parseEndByteIndex;\n  const char *m_parseEndPtr;\n  XML_Char *m_dataBuf;\n  XML_Char *m_dataBufEnd;\n  XML_StartElementHandler m_startElementHandler;\n  XML_EndElementHandler m_endElementHandler;\n  XML_CharacterDataHandler m_characterDataHandler;\n  XML_ProcessingInstructionHandler m_processingInstructionHandler;\n  XML_CommentHandler m_commentHandler;\n  XML_StartCdataSectionHandler m_startCdataSectionHandler;\n  XML_EndCdataSectionHandler m_endCdataSectionHandler;\n  XML_DefaultHandler m_defaultHandler;\n  XML_StartDoctypeDeclHandler m_startDoctypeDeclHandler;\n  XML_EndDoctypeDeclHandler m_endDoctypeDeclHandler;\n  XML_UnparsedEntityDeclHandler m_unparsedEntityDeclHandler;\n  XML_NotationDeclHandler m_notationDeclHandler;\n  XML_StartNamespaceDeclHandler m_startNamespaceDeclHandler;\n  XML_EndNamespaceDeclHandler m_endNamespaceDeclHandler;\n  XML_NotStandaloneHandler m_notStandaloneHandler;\n  XML_ExternalEntityRefHandler m_externalEntityRefHandler;\n  XML_Parser m_externalEntityRefHandlerArg;\n  XML_SkippedEntityHandler m_skippedEntityHandler;\n  XML_UnknownEncodingHandler m_unknownEncodingHandler;\n  XML_ElementDeclHandler m_elementDeclHandler;\n  XML_AttlistDeclHandler m_attlistDeclHandler;\n  XML_EntityDeclHandler m_entityDeclHandler;\n  XML_XmlDeclHandler m_xmlDeclHandler;\n  const ENCODING *m_encoding;\n  INIT_ENCODING m_initEncoding;\n  const ENCODING *m_internalEncoding;\n  const XML_Char *m_protocolEncodingName;\n  XML_Bool m_ns;\n  XML_Bool m_ns_triplets;\n  void *m_unknownEncodingMem;\n  void *m_unknownEncodingData;\n  void *m_unknownEncodingHandlerData;\n  void(XMLCALL *m_unknownEncodingRelease)(void *);\n  PROLOG_STATE m_prologState;\n  Processor *m_processor;\n  enum XML_Error m_errorCode;\n  const char *m_eventPtr;\n  const char *m_eventEndPtr;\n  const char *m_positionPtr;\n  OPEN_INTERNAL_ENTITY *m_openInternalEntities;\n  OPEN_INTERNAL_ENTITY *m_freeInternalEntities;\n  XML_Bool m_defaultExpandInternalEntities;\n  int m_tagLevel;\n  ENTITY *m_declEntity;\n  const XML_Char *m_doctypeName;\n  const XML_Char *m_doctypeSysid;\n  const XML_Char *m_doctypePubid;\n  const XML_Char *m_declAttributeType;\n  const XML_Char *m_declNotationName;\n  const XML_Char *m_declNotationPublicId;\n  ELEMENT_TYPE *m_declElementType;\n  ATTRIBUTE_ID *m_declAttributeId;\n  XML_Bool m_declAttributeIsCdata;\n  XML_Bool m_declAttributeIsId;\n  DTD *m_dtd;\n  const XML_Char *m_curBase;\n  TAG *m_tagStack;\n  TAG *m_freeTagList;\n  BINDING *m_inheritedBindings;\n  BINDING *m_freeBindingList;\n  int m_attsSize;\n  int m_nSpecifiedAtts;\n  int m_idAttIndex;\n  ATTRIBUTE *m_atts;\n  NS_ATT *m_nsAtts;\n  unsigned long m_nsAttsVersion;\n  unsigned char m_nsAttsPower;\n#ifdef XML_ATTR_INFO\n  XML_AttrInfo *m_attInfo;\n#endif\n  POSITION m_position;\n  STRING_POOL m_tempPool;\n  STRING_POOL m_temp2Pool;\n  char *m_groupConnector;\n  unsigned int m_groupSize;\n  XML_Char m_namespaceSeparator;\n  XML_Parser m_parentParser;\n  XML_ParsingStatus m_parsingStatus;\n#ifdef XML_DTD\n  XML_Bool m_isParamEntity;\n  XML_Bool m_useForeignDTD;\n  enum XML_ParamEntityParsing m_paramEntityParsing;\n#endif\n  unsigned long m_hash_secret_salt;\n#ifdef XML_DTD\n  ACCOUNTING m_accounting;\n  ENTITY_STATS m_entity_stats;\n#endif\n};\n\n#define MALLOC(parser, s) (parser->m_mem.malloc_fcn((s)))\n#define REALLOC(parser, p, s) (parser->m_mem.realloc_fcn((p), (s)))\n#define FREE(parser, p) (parser->m_mem.free_fcn((p)))\n\nXML_Parser XMLCALL\nXML_ParserCreate(const XML_Char *encodingName) {\n  return XML_ParserCreate_MM(encodingName, NULL, NULL);\n}\n\nXML_Parser XMLCALL\nXML_ParserCreateNS(const XML_Char *encodingName, XML_Char nsSep) {\n  XML_Char tmp[2] = {nsSep, 0};\n  return XML_ParserCreate_MM(encodingName, NULL, tmp);\n}\n\n// \"xml=http://www.w3.org/XML/1998/namespace\"\nstatic const XML_Char implicitContext[]\n    = {ASCII_x,     ASCII_m,     ASCII_l,      ASCII_EQUALS, ASCII_h,\n       ASCII_t,     ASCII_t,     ASCII_p,      ASCII_COLON,  ASCII_SLASH,\n       ASCII_SLASH, ASCII_w,     ASCII_w,      ASCII_w,      ASCII_PERIOD,\n       ASCII_w,     ASCII_3,     ASCII_PERIOD, ASCII_o,      ASCII_r,\n       ASCII_g,     ASCII_SLASH, ASCII_X,      ASCII_M,      ASCII_L,\n       ASCII_SLASH, ASCII_1,     ASCII_9,      ASCII_9,      ASCII_8,\n       ASCII_SLASH, ASCII_n,     ASCII_a,      ASCII_m,      ASCII_e,\n       ASCII_s,     ASCII_p,     ASCII_a,      ASCII_c,      ASCII_e,\n       '\\0'};\n\n/* To avoid warnings about unused functions: */\n#if ! defined(HAVE_ARC4RANDOM_BUF) && ! defined(HAVE_ARC4RANDOM)\n\n#  if defined(HAVE_GETRANDOM) || defined(HAVE_SYSCALL_GETRANDOM)\n\n/* Obtain entropy on Linux 3.17+ */\nstatic int\nwriteRandomBytes_getrandom_nonblock(void *target, size_t count) {\n  int success = 0; /* full count bytes written? */\n  size_t bytesWrittenTotal = 0;\n  const unsigned int getrandomFlags = GRND_NONBLOCK;\n\n  do {\n    void *const currentTarget = (void *)((char *)target + bytesWrittenTotal);\n    const size_t bytesToWrite = count - bytesWrittenTotal;\n\n    const int bytesWrittenMore =\n#    if defined(HAVE_GETRANDOM)\n        getrandom(currentTarget, bytesToWrite, getrandomFlags);\n#    else\n        syscall(SYS_getrandom, currentTarget, bytesToWrite, getrandomFlags);\n#    endif\n\n    if (bytesWrittenMore > 0) {\n      bytesWrittenTotal += bytesWrittenMore;\n      if (bytesWrittenTotal >= count)\n        success = 1;\n    }\n  } while (! success && (errno == EINTR));\n\n  return success;\n}\n\n#  endif /* defined(HAVE_GETRANDOM) || defined(HAVE_SYSCALL_GETRANDOM) */\n\n#  if ! defined(_WIN32) && defined(XML_DEV_URANDOM)\n\n/* Extract entropy from /dev/urandom */\nstatic int\nwriteRandomBytes_dev_urandom(void *target, size_t count) {\n  int success = 0; /* full count bytes written? */\n  size_t bytesWrittenTotal = 0;\n\n  const int fd = open(\"/dev/urandom\", O_RDONLY);\n  if (fd < 0) {\n    return 0;\n  }\n\n  do {\n    void *const currentTarget = (void *)((char *)target + bytesWrittenTotal);\n    const size_t bytesToWrite = count - bytesWrittenTotal;\n\n    const ssize_t bytesWrittenMore = read(fd, currentTarget, bytesToWrite);\n\n    if (bytesWrittenMore > 0) {\n      bytesWrittenTotal += bytesWrittenMore;\n      if (bytesWrittenTotal >= count)\n        success = 1;\n    }\n  } while (! success && (errno == EINTR));\n\n  close(fd);\n  return success;\n}\n\n#  endif /* ! defined(_WIN32) && defined(XML_DEV_URANDOM) */\n\n#endif /* ! defined(HAVE_ARC4RANDOM_BUF) && ! defined(HAVE_ARC4RANDOM) */\n\n#if defined(HAVE_ARC4RANDOM) && ! defined(HAVE_ARC4RANDOM_BUF)\n\nstatic void\nwriteRandomBytes_arc4random(void *target, size_t count) {\n  size_t bytesWrittenTotal = 0;\n\n  while (bytesWrittenTotal < count) {\n    const uint32_t random32 = arc4random();\n    size_t i = 0;\n\n    for (; (i < sizeof(random32)) && (bytesWrittenTotal < count);\n         i++, bytesWrittenTotal++) {\n      const uint8_t random8 = (uint8_t)(random32 >> (i * 8));\n      ((uint8_t *)target)[bytesWrittenTotal] = random8;\n    }\n  }\n}\n\n#endif /* defined(HAVE_ARC4RANDOM) && ! defined(HAVE_ARC4RANDOM_BUF) */\n\n#ifdef _WIN32\n\n/* Provide declaration of rand_s() for MinGW-32 (not 64, which has it),\n   as it didn't declare it in its header prior to version 5.3.0 of its\n   runtime package (mingwrt, containing stdlib.h).  The upstream fix\n   was introduced at https://osdn.net/projects/mingw/ticket/39658 . */\n#  if defined(__MINGW32__) && defined(__MINGW32_VERSION)                       \\\n      && __MINGW32_VERSION < 5003000L && ! defined(__MINGW64_VERSION_MAJOR)\n__declspec(dllimport) int rand_s(unsigned int *);\n#  endif\n\n/* Obtain entropy on Windows using the rand_s() function which\n * generates cryptographically secure random numbers.  Internally it\n * uses RtlGenRandom API which is present in Windows XP and later.\n */\nstatic int\nwriteRandomBytes_rand_s(void *target, size_t count) {\n  size_t bytesWrittenTotal = 0;\n\n  while (bytesWrittenTotal < count) {\n    unsigned int random32 = 0;\n    size_t i = 0;\n\n    if (rand_s(&random32))\n      return 0; /* failure */\n\n    for (; (i < sizeof(random32)) && (bytesWrittenTotal < count);\n         i++, bytesWrittenTotal++) {\n      const uint8_t random8 = (uint8_t)(random32 >> (i * 8));\n      ((uint8_t *)target)[bytesWrittenTotal] = random8;\n    }\n  }\n  return 1; /* success */\n}\n\n#endif /* _WIN32 */\n\n#if ! defined(HAVE_ARC4RANDOM_BUF) && ! defined(HAVE_ARC4RANDOM)\n\nstatic unsigned long\ngather_time_entropy(void) {\n#  ifdef _WIN32\n  FILETIME ft;\n  GetSystemTimeAsFileTime(&ft); /* never fails */\n  return ft.dwHighDateTime ^ ft.dwLowDateTime;\n#  else\n  struct timeval tv;\n  int gettimeofday_res;\n\n  gettimeofday_res = gettimeofday(&tv, NULL);\n\n#    if defined(NDEBUG)\n  (void)gettimeofday_res;\n#    else\n  assert(gettimeofday_res == 0);\n#    endif /* defined(NDEBUG) */\n\n  /* Microseconds time is <20 bits entropy */\n  return tv.tv_usec;\n#  endif\n}\n\n#endif /* ! defined(HAVE_ARC4RANDOM_BUF) && ! defined(HAVE_ARC4RANDOM) */\n\nstatic unsigned long\nENTROPY_DEBUG(const char *label, unsigned long entropy) {\n  if (getDebugLevel(\"EXPAT_ENTROPY_DEBUG\", 0) >= 1u) {\n    fprintf(stderr, \"expat: Entropy: %s --> 0x%0*lx (%lu bytes)\\n\", label,\n            (int)sizeof(entropy) * 2, entropy, (unsigned long)sizeof(entropy));\n  }\n  return entropy;\n}\n\nstatic unsigned long\ngenerate_hash_secret_salt(XML_Parser parser) {\n  unsigned long entropy;\n  (void)parser;\n\n  /* \"Failproof\" high quality providers: */\n#if defined(HAVE_ARC4RANDOM_BUF)\n  arc4random_buf(&entropy, sizeof(entropy));\n  return ENTROPY_DEBUG(\"arc4random_buf\", entropy);\n#elif defined(HAVE_ARC4RANDOM)\n  writeRandomBytes_arc4random((void *)&entropy, sizeof(entropy));\n  return ENTROPY_DEBUG(\"arc4random\", entropy);\n#else\n  /* Try high quality providers first .. */\n#  ifdef _WIN32\n  if (writeRandomBytes_rand_s((void *)&entropy, sizeof(entropy))) {\n    return ENTROPY_DEBUG(\"rand_s\", entropy);\n  }\n#  elif defined(HAVE_GETRANDOM) || defined(HAVE_SYSCALL_GETRANDOM)\n  if (writeRandomBytes_getrandom_nonblock((void *)&entropy, sizeof(entropy))) {\n    return ENTROPY_DEBUG(\"getrandom\", entropy);\n  }\n#  endif\n#  if ! defined(_WIN32) && defined(XML_DEV_URANDOM)\n  if (writeRandomBytes_dev_urandom((void *)&entropy, sizeof(entropy))) {\n    return ENTROPY_DEBUG(\"/dev/urandom\", entropy);\n  }\n#  endif /* ! defined(_WIN32) && defined(XML_DEV_URANDOM) */\n  /* .. and self-made low quality for backup: */\n\n  /* Process ID is 0 bits entropy if attacker has local access */\n  entropy = gather_time_entropy() ^ getpid();\n\n  /* Factors are 2^31-1 and 2^61-1 (Mersenne primes M31 and M61) */\n  if (sizeof(unsigned long) == 4) {\n    return ENTROPY_DEBUG(\"fallback(4)\", entropy * 2147483647);\n  } else {\n    return ENTROPY_DEBUG(\"fallback(8)\",\n                         entropy * (unsigned long)2305843009213693951ULL);\n  }\n#endif\n}\n\nstatic unsigned long\nget_hash_secret_salt(XML_Parser parser) {\n  if (parser->m_parentParser != NULL)\n    return get_hash_secret_salt(parser->m_parentParser);\n  return parser->m_hash_secret_salt;\n}\n\nstatic XML_Bool /* only valid for root parser */\nstartParsing(XML_Parser parser) {\n  /* hash functions must be initialized before setContext() is called */\n  if (parser->m_hash_secret_salt == 0)\n    parser->m_hash_secret_salt = generate_hash_secret_salt(parser);\n  if (parser->m_ns) {\n    /* implicit context only set for root parser, since child\n       parsers (i.e. external entity parsers) will inherit it\n    */\n    return setContext(parser, implicitContext);\n  }\n  return XML_TRUE;\n}\n\nXML_Parser XMLCALL\nXML_ParserCreate_MM(const XML_Char *encodingName,\n                    const XML_Memory_Handling_Suite *memsuite,\n                    const XML_Char *nameSep) {\n  return parserCreate(encodingName, memsuite, nameSep, NULL);\n}\n\nstatic XML_Parser\nparserCreate(const XML_Char *encodingName,\n             const XML_Memory_Handling_Suite *memsuite, const XML_Char *nameSep,\n             DTD *dtd) {\n  XML_Parser parser;\n\n  if (memsuite) {\n    XML_Memory_Handling_Suite *mtemp;\n    parser = memsuite->malloc_fcn(sizeof(struct XML_ParserStruct));\n    if (parser != NULL) {\n      mtemp = (XML_Memory_Handling_Suite *)&(parser->m_mem);\n      mtemp->malloc_fcn = memsuite->malloc_fcn;\n      mtemp->realloc_fcn = memsuite->realloc_fcn;\n      mtemp->free_fcn = memsuite->free_fcn;\n    }\n  } else {\n    XML_Memory_Handling_Suite *mtemp;\n    parser = (XML_Parser)malloc(sizeof(struct XML_ParserStruct));\n    if (parser != NULL) {\n      mtemp = (XML_Memory_Handling_Suite *)&(parser->m_mem);\n      mtemp->malloc_fcn = malloc;\n      mtemp->realloc_fcn = realloc;\n      mtemp->free_fcn = free;\n    }\n  }\n\n  if (! parser)\n    return parser;\n\n  parser->m_buffer = NULL;\n  parser->m_bufferLim = NULL;\n\n  parser->m_attsSize = INIT_ATTS_SIZE;\n  parser->m_atts\n      = (ATTRIBUTE *)MALLOC(parser, parser->m_attsSize * sizeof(ATTRIBUTE));\n  if (parser->m_atts == NULL) {\n    FREE(parser, parser);\n    return NULL;\n  }\n#ifdef XML_ATTR_INFO\n  parser->m_attInfo = (XML_AttrInfo *)MALLOC(\n      parser, parser->m_attsSize * sizeof(XML_AttrInfo));\n  if (parser->m_attInfo == NULL) {\n    FREE(parser, parser->m_atts);\n    FREE(parser, parser);\n    return NULL;\n  }\n#endif\n  parser->m_dataBuf\n      = (XML_Char *)MALLOC(parser, INIT_DATA_BUF_SIZE * sizeof(XML_Char));\n  if (parser->m_dataBuf == NULL) {\n    FREE(parser, parser->m_atts);\n#ifdef XML_ATTR_INFO\n    FREE(parser, parser->m_attInfo);\n#endif\n    FREE(parser, parser);\n    return NULL;\n  }\n  parser->m_dataBufEnd = parser->m_dataBuf + INIT_DATA_BUF_SIZE;\n\n  if (dtd)\n    parser->m_dtd = dtd;\n  else {\n    parser->m_dtd = dtdCreate(&parser->m_mem);\n    if (parser->m_dtd == NULL) {\n      FREE(parser, parser->m_dataBuf);\n      FREE(parser, parser->m_atts);\n#ifdef XML_ATTR_INFO\n      FREE(parser, parser->m_attInfo);\n#endif\n      FREE(parser, parser);\n      return NULL;\n    }\n  }\n\n  parser->m_freeBindingList = NULL;\n  parser->m_freeTagList = NULL;\n  parser->m_freeInternalEntities = NULL;\n\n  parser->m_groupSize = 0;\n  parser->m_groupConnector = NULL;\n\n  parser->m_unknownEncodingHandler = NULL;\n  parser->m_unknownEncodingHandlerData = NULL;\n\n  parser->m_namespaceSeparator = ASCII_EXCL;\n  parser->m_ns = XML_FALSE;\n  parser->m_ns_triplets = XML_FALSE;\n\n  parser->m_nsAtts = NULL;\n  parser->m_nsAttsVersion = 0;\n  parser->m_nsAttsPower = 0;\n\n  parser->m_protocolEncodingName = NULL;\n\n  poolInit(&parser->m_tempPool, &(parser->m_mem));\n  poolInit(&parser->m_temp2Pool, &(parser->m_mem));\n  parserInit(parser, encodingName);\n\n  if (encodingName && ! parser->m_protocolEncodingName) {\n    if (dtd) {\n      // We need to stop the upcoming call to XML_ParserFree from happily\n      // destroying parser->m_dtd because the DTD is shared with the parent\n      // parser and the only guard that keeps XML_ParserFree from destroying\n      // parser->m_dtd is parser->m_isParamEntity but it will be set to\n      // XML_TRUE only later in XML_ExternalEntityParserCreate (or not at all).\n      parser->m_dtd = NULL;\n    }\n    XML_ParserFree(parser);\n    return NULL;\n  }\n\n  if (nameSep) {\n    parser->m_ns = XML_TRUE;\n    parser->m_internalEncoding = XmlGetInternalEncodingNS();\n    parser->m_namespaceSeparator = *nameSep;\n  } else {\n    parser->m_internalEncoding = XmlGetInternalEncoding();\n  }\n\n  return parser;\n}\n\nstatic void\nparserInit(XML_Parser parser, const XML_Char *encodingName) {\n  parser->m_processor = prologInitProcessor;\n  XmlPrologStateInit(&parser->m_prologState);\n  if (encodingName != NULL) {\n    parser->m_protocolEncodingName = copyString(encodingName, &(parser->m_mem));\n  }\n  parser->m_curBase = NULL;\n  XmlInitEncoding(&parser->m_initEncoding, &parser->m_encoding, 0);\n  parser->m_userData = NULL;\n  parser->m_handlerArg = NULL;\n  parser->m_startElementHandler = NULL;\n  parser->m_endElementHandler = NULL;\n  parser->m_characterDataHandler = NULL;\n  parser->m_processingInstructionHandler = NULL;\n  parser->m_commentHandler = NULL;\n  parser->m_startCdataSectionHandler = NULL;\n  parser->m_endCdataSectionHandler = NULL;\n  parser->m_defaultHandler = NULL;\n  parser->m_startDoctypeDeclHandler = NULL;\n  parser->m_endDoctypeDeclHandler = NULL;\n  parser->m_unparsedEntityDeclHandler = NULL;\n  parser->m_notationDeclHandler = NULL;\n  parser->m_startNamespaceDeclHandler = NULL;\n  parser->m_endNamespaceDeclHandler = NULL;\n  parser->m_notStandaloneHandler = NULL;\n  parser->m_externalEntityRefHandler = NULL;\n  parser->m_externalEntityRefHandlerArg = parser;\n  parser->m_skippedEntityHandler = NULL;\n  parser->m_elementDeclHandler = NULL;\n  parser->m_attlistDeclHandler = NULL;\n  parser->m_entityDeclHandler = NULL;\n  parser->m_xmlDeclHandler = NULL;\n  parser->m_bufferPtr = parser->m_buffer;\n  parser->m_bufferEnd = parser->m_buffer;\n  parser->m_parseEndByteIndex = 0;\n  parser->m_parseEndPtr = NULL;\n  parser->m_declElementType = NULL;\n  parser->m_declAttributeId = NULL;\n  parser->m_declEntity = NULL;\n  parser->m_doctypeName = NULL;\n  parser->m_doctypeSysid = NULL;\n  parser->m_doctypePubid = NULL;\n  parser->m_declAttributeType = NULL;\n  parser->m_declNotationName = NULL;\n  parser->m_declNotationPublicId = NULL;\n  parser->m_declAttributeIsCdata = XML_FALSE;\n  parser->m_declAttributeIsId = XML_FALSE;\n  memset(&parser->m_position, 0, sizeof(POSITION));\n  parser->m_errorCode = XML_ERROR_NONE;\n  parser->m_eventPtr = NULL;\n  parser->m_eventEndPtr = NULL;\n  parser->m_positionPtr = NULL;\n  parser->m_openInternalEntities = NULL;\n  parser->m_defaultExpandInternalEntities = XML_TRUE;\n  parser->m_tagLevel = 0;\n  parser->m_tagStack = NULL;\n  parser->m_inheritedBindings = NULL;\n  parser->m_nSpecifiedAtts = 0;\n  parser->m_unknownEncodingMem = NULL;\n  parser->m_unknownEncodingRelease = NULL;\n  parser->m_unknownEncodingData = NULL;\n  parser->m_parentParser = NULL;\n  parser->m_parsingStatus.parsing = XML_INITIALIZED;\n#ifdef XML_DTD\n  parser->m_isParamEntity = XML_FALSE;\n  parser->m_useForeignDTD = XML_FALSE;\n  parser->m_paramEntityParsing = XML_PARAM_ENTITY_PARSING_NEVER;\n#endif\n  parser->m_hash_secret_salt = 0;\n\n#ifdef XML_DTD\n  memset(&parser->m_accounting, 0, sizeof(ACCOUNTING));\n  parser->m_accounting.debugLevel = getDebugLevel(\"EXPAT_ACCOUNTING_DEBUG\", 0u);\n  parser->m_accounting.maximumAmplificationFactor\n      = EXPAT_BILLION_LAUGHS_ATTACK_PROTECTION_MAXIMUM_AMPLIFICATION_DEFAULT;\n  parser->m_accounting.activationThresholdBytes\n      = EXPAT_BILLION_LAUGHS_ATTACK_PROTECTION_ACTIVATION_THRESHOLD_DEFAULT;\n\n  memset(&parser->m_entity_stats, 0, sizeof(ENTITY_STATS));\n  parser->m_entity_stats.debugLevel = getDebugLevel(\"EXPAT_ENTITY_DEBUG\", 0u);\n#endif\n}\n\n/* moves list of bindings to m_freeBindingList */\nstatic void FASTCALL\nmoveToFreeBindingList(XML_Parser parser, BINDING *bindings) {\n  while (bindings) {\n    BINDING *b = bindings;\n    bindings = bindings->nextTagBinding;\n    b->nextTagBinding = parser->m_freeBindingList;\n    parser->m_freeBindingList = b;\n  }\n}\n\nXML_Bool XMLCALL\nXML_ParserReset(XML_Parser parser, const XML_Char *encodingName) {\n  TAG *tStk;\n  OPEN_INTERNAL_ENTITY *openEntityList;\n\n  if (parser == NULL)\n    return XML_FALSE;\n\n  if (parser->m_parentParser)\n    return XML_FALSE;\n  /* move m_tagStack to m_freeTagList */\n  tStk = parser->m_tagStack;\n  while (tStk) {\n    TAG *tag = tStk;\n    tStk = tStk->parent;\n    tag->parent = parser->m_freeTagList;\n    moveToFreeBindingList(parser, tag->bindings);\n    tag->bindings = NULL;\n    parser->m_freeTagList = tag;\n  }\n  /* move m_openInternalEntities to m_freeInternalEntities */\n  openEntityList = parser->m_openInternalEntities;\n  while (openEntityList) {\n    OPEN_INTERNAL_ENTITY *openEntity = openEntityList;\n    openEntityList = openEntity->next;\n    openEntity->next = parser->m_freeInternalEntities;\n    parser->m_freeInternalEntities = openEntity;\n  }\n  moveToFreeBindingList(parser, parser->m_inheritedBindings);\n  FREE(parser, parser->m_unknownEncodingMem);\n  if (parser->m_unknownEncodingRelease)\n    parser->m_unknownEncodingRelease(parser->m_unknownEncodingData);\n  poolClear(&parser->m_tempPool);\n  poolClear(&parser->m_temp2Pool);\n  FREE(parser, (void *)parser->m_protocolEncodingName);\n  parser->m_protocolEncodingName = NULL;\n  parserInit(parser, encodingName);\n  dtdReset(parser->m_dtd, &parser->m_mem);\n  return XML_TRUE;\n}\n\nenum XML_Status XMLCALL\nXML_SetEncoding(XML_Parser parser, const XML_Char *encodingName) {\n  if (parser == NULL)\n    return XML_STATUS_ERROR;\n  /* Block after XML_Parse()/XML_ParseBuffer() has been called.\n     XXX There's no way for the caller to determine which of the\n     XXX possible error cases caused the XML_STATUS_ERROR return.\n  */\n  if (parser->m_parsingStatus.parsing == XML_PARSING\n      || parser->m_parsingStatus.parsing == XML_SUSPENDED)\n    return XML_STATUS_ERROR;\n\n  /* Get rid of any previous encoding name */\n  FREE(parser, (void *)parser->m_protocolEncodingName);\n\n  if (encodingName == NULL)\n    /* No new encoding name */\n    parser->m_protocolEncodingName = NULL;\n  else {\n    /* Copy the new encoding name into allocated memory */\n    parser->m_protocolEncodingName = copyString(encodingName, &(parser->m_mem));\n    if (! parser->m_protocolEncodingName)\n      return XML_STATUS_ERROR;\n  }\n  return XML_STATUS_OK;\n}\n\nXML_Parser XMLCALL\nXML_ExternalEntityParserCreate(XML_Parser oldParser, const XML_Char *context,\n                               const XML_Char *encodingName) {\n  XML_Parser parser = oldParser;\n  DTD *newDtd = NULL;\n  DTD *oldDtd;\n  XML_StartElementHandler oldStartElementHandler;\n  XML_EndElementHandler oldEndElementHandler;\n  XML_CharacterDataHandler oldCharacterDataHandler;\n  XML_ProcessingInstructionHandler oldProcessingInstructionHandler;\n  XML_CommentHandler oldCommentHandler;\n  XML_StartCdataSectionHandler oldStartCdataSectionHandler;\n  XML_EndCdataSectionHandler oldEndCdataSectionHandler;\n  XML_DefaultHandler oldDefaultHandler;\n  XML_UnparsedEntityDeclHandler oldUnparsedEntityDeclHandler;\n  XML_NotationDeclHandler oldNotationDeclHandler;\n  XML_StartNamespaceDeclHandler oldStartNamespaceDeclHandler;\n  XML_EndNamespaceDeclHandler oldEndNamespaceDeclHandler;\n  XML_NotStandaloneHandler oldNotStandaloneHandler;\n  XML_ExternalEntityRefHandler oldExternalEntityRefHandler;\n  XML_SkippedEntityHandler oldSkippedEntityHandler;\n  XML_UnknownEncodingHandler oldUnknownEncodingHandler;\n  XML_ElementDeclHandler oldElementDeclHandler;\n  XML_AttlistDeclHandler oldAttlistDeclHandler;\n  XML_EntityDeclHandler oldEntityDeclHandler;\n  XML_XmlDeclHandler oldXmlDeclHandler;\n  ELEMENT_TYPE *oldDeclElementType;\n\n  void *oldUserData;\n  void *oldHandlerArg;\n  XML_Bool oldDefaultExpandInternalEntities;\n  XML_Parser oldExternalEntityRefHandlerArg;\n#ifdef XML_DTD\n  enum XML_ParamEntityParsing oldParamEntityParsing;\n  int oldInEntityValue;\n#endif\n  XML_Bool oldns_triplets;\n  /* Note that the new parser shares the same hash secret as the old\n     parser, so that dtdCopy and copyEntityTable can lookup values\n     from hash tables associated with either parser without us having\n     to worry which hash secrets each table has.\n  */\n  unsigned long oldhash_secret_salt;\n\n  /* Validate the oldParser parameter before we pull everything out of it */\n  if (oldParser == NULL)\n    return NULL;\n\n  /* Stash the original parser contents on the stack */\n  oldDtd = parser->m_dtd;\n  oldStartElementHandler = parser->m_startElementHandler;\n  oldEndElementHandler = parser->m_endElementHandler;\n  oldCharacterDataHandler = parser->m_characterDataHandler;\n  oldProcessingInstructionHandler = parser->m_processingInstructionHandler;\n  oldCommentHandler = parser->m_commentHandler;\n  oldStartCdataSectionHandler = parser->m_startCdataSectionHandler;\n  oldEndCdataSectionHandler = parser->m_endCdataSectionHandler;\n  oldDefaultHandler = parser->m_defaultHandler;\n  oldUnparsedEntityDeclHandler = parser->m_unparsedEntityDeclHandler;\n  oldNotationDeclHandler = parser->m_notationDeclHandler;\n  oldStartNamespaceDeclHandler = parser->m_startNamespaceDeclHandler;\n  oldEndNamespaceDeclHandler = parser->m_endNamespaceDeclHandler;\n  oldNotStandaloneHandler = parser->m_notStandaloneHandler;\n  oldExternalEntityRefHandler = parser->m_externalEntityRefHandler;\n  oldSkippedEntityHandler = parser->m_skippedEntityHandler;\n  oldUnknownEncodingHandler = parser->m_unknownEncodingHandler;\n  oldElementDeclHandler = parser->m_elementDeclHandler;\n  oldAttlistDeclHandler = parser->m_attlistDeclHandler;\n  oldEntityDeclHandler = parser->m_entityDeclHandler;\n  oldXmlDeclHandler = parser->m_xmlDeclHandler;\n  oldDeclElementType = parser->m_declElementType;\n\n  oldUserData = parser->m_userData;\n  oldHandlerArg = parser->m_handlerArg;\n  oldDefaultExpandInternalEntities = parser->m_defaultExpandInternalEntities;\n  oldExternalEntityRefHandlerArg = parser->m_externalEntityRefHandlerArg;\n#ifdef XML_DTD\n  oldParamEntityParsing = parser->m_paramEntityParsing;\n  oldInEntityValue = parser->m_prologState.inEntityValue;\n#endif\n  oldns_triplets = parser->m_ns_triplets;\n  /* Note that the new parser shares the same hash secret as the old\n     parser, so that dtdCopy and copyEntityTable can lookup values\n     from hash tables associated with either parser without us having\n     to worry which hash secrets each table has.\n  */\n  oldhash_secret_salt = parser->m_hash_secret_salt;\n\n#ifdef XML_DTD\n  if (! context)\n    newDtd = oldDtd;\n#endif /* XML_DTD */\n\n  /* Note that the magical uses of the pre-processor to make field\n     access look more like C++ require that `parser' be overwritten\n     here.  This makes this function more painful to follow than it\n     would be otherwise.\n  */\n  if (parser->m_ns) {\n    XML_Char tmp[2] = {parser->m_namespaceSeparator, 0};\n    parser = parserCreate(encodingName, &parser->m_mem, tmp, newDtd);\n  } else {\n    parser = parserCreate(encodingName, &parser->m_mem, NULL, newDtd);\n  }\n\n  if (! parser)\n    return NULL;\n\n  parser->m_startElementHandler = oldStartElementHandler;\n  parser->m_endElementHandler = oldEndElementHandler;\n  parser->m_characterDataHandler = oldCharacterDataHandler;\n  parser->m_processingInstructionHandler = oldProcessingInstructionHandler;\n  parser->m_commentHandler = oldCommentHandler;\n  parser->m_startCdataSectionHandler = oldStartCdataSectionHandler;\n  parser->m_endCdataSectionHandler = oldEndCdataSectionHandler;\n  parser->m_defaultHandler = oldDefaultHandler;\n  parser->m_unparsedEntityDeclHandler = oldUnparsedEntityDeclHandler;\n  parser->m_notationDeclHandler = oldNotationDeclHandler;\n  parser->m_startNamespaceDeclHandler = oldStartNamespaceDeclHandler;\n  parser->m_endNamespaceDeclHandler = oldEndNamespaceDeclHandler;\n  parser->m_notStandaloneHandler = oldNotStandaloneHandler;\n  parser->m_externalEntityRefHandler = oldExternalEntityRefHandler;\n  parser->m_skippedEntityHandler = oldSkippedEntityHandler;\n  parser->m_unknownEncodingHandler = oldUnknownEncodingHandler;\n  parser->m_elementDeclHandler = oldElementDeclHandler;\n  parser->m_attlistDeclHandler = oldAttlistDeclHandler;\n  parser->m_entityDeclHandler = oldEntityDeclHandler;\n  parser->m_xmlDeclHandler = oldXmlDeclHandler;\n  parser->m_declElementType = oldDeclElementType;\n  parser->m_userData = oldUserData;\n  if (oldUserData == oldHandlerArg)\n    parser->m_handlerArg = parser->m_userData;\n  else\n    parser->m_handlerArg = parser;\n  if (oldExternalEntityRefHandlerArg != oldParser)\n    parser->m_externalEntityRefHandlerArg = oldExternalEntityRefHandlerArg;\n  parser->m_defaultExpandInternalEntities = oldDefaultExpandInternalEntities;\n  parser->m_ns_triplets = oldns_triplets;\n  parser->m_hash_secret_salt = oldhash_secret_salt;\n  parser->m_parentParser = oldParser;\n#ifdef XML_DTD\n  parser->m_paramEntityParsing = oldParamEntityParsing;\n  parser->m_prologState.inEntityValue = oldInEntityValue;\n  if (context) {\n#endif /* XML_DTD */\n    if (! dtdCopy(oldParser, parser->m_dtd, oldDtd, &parser->m_mem)\n        || ! setContext(parser, context)) {\n      XML_ParserFree(parser);\n      return NULL;\n    }\n    parser->m_processor = externalEntityInitProcessor;\n#ifdef XML_DTD\n  } else {\n    /* The DTD instance referenced by parser->m_dtd is shared between the\n       document's root parser and external PE parsers, therefore one does not\n       need to call setContext. In addition, one also *must* not call\n       setContext, because this would overwrite existing prefix->binding\n       pointers in parser->m_dtd with ones that get destroyed with the external\n       PE parser. This would leave those prefixes with dangling pointers.\n    */\n    parser->m_isParamEntity = XML_TRUE;\n    XmlPrologStateInitExternalEntity(&parser->m_prologState);\n    parser->m_processor = externalParEntInitProcessor;\n  }\n#endif /* XML_DTD */\n  return parser;\n}\n\nstatic void FASTCALL\ndestroyBindings(BINDING *bindings, XML_Parser parser) {\n  for (;;) {\n    BINDING *b = bindings;\n    if (! b)\n      break;\n    bindings = b->nextTagBinding;\n    FREE(parser, b->uri);\n    FREE(parser, b);\n  }\n}\n\nvoid XMLCALL\nXML_ParserFree(XML_Parser parser) {\n  TAG *tagList;\n  OPEN_INTERNAL_ENTITY *entityList;\n  if (parser == NULL)\n    return;\n  /* free m_tagStack and m_freeTagList */\n  tagList = parser->m_tagStack;\n  for (;;) {\n    TAG *p;\n    if (tagList == NULL) {\n      if (parser->m_freeTagList == NULL)\n        break;\n      tagList = parser->m_freeTagList;\n      parser->m_freeTagList = NULL;\n    }\n    p = tagList;\n    tagList = tagList->parent;\n    FREE(parser, p->buf);\n    destroyBindings(p->bindings, parser);\n    FREE(parser, p);\n  }\n  /* free m_openInternalEntities and m_freeInternalEntities */\n  entityList = parser->m_openInternalEntities;\n  for (;;) {\n    OPEN_INTERNAL_ENTITY *openEntity;\n    if (entityList == NULL) {\n      if (parser->m_freeInternalEntities == NULL)\n        break;\n      entityList = parser->m_freeInternalEntities;\n      parser->m_freeInternalEntities = NULL;\n    }\n    openEntity = entityList;\n    entityList = entityList->next;\n    FREE(parser, openEntity);\n  }\n\n  destroyBindings(parser->m_freeBindingList, parser);\n  destroyBindings(parser->m_inheritedBindings, parser);\n  poolDestroy(&parser->m_tempPool);\n  poolDestroy(&parser->m_temp2Pool);\n  FREE(parser, (void *)parser->m_protocolEncodingName);\n#ifdef XML_DTD\n  /* external parameter entity parsers share the DTD structure\n     parser->m_dtd with the root parser, so we must not destroy it\n  */\n  if (! parser->m_isParamEntity && parser->m_dtd)\n#else\n  if (parser->m_dtd)\n#endif /* XML_DTD */\n    dtdDestroy(parser->m_dtd, (XML_Bool)! parser->m_parentParser,\n               &parser->m_mem);\n  FREE(parser, (void *)parser->m_atts);\n#ifdef XML_ATTR_INFO\n  FREE(parser, (void *)parser->m_attInfo);\n#endif\n  FREE(parser, parser->m_groupConnector);\n  FREE(parser, parser->m_buffer);\n  FREE(parser, parser->m_dataBuf);\n  FREE(parser, parser->m_nsAtts);\n  FREE(parser, parser->m_unknownEncodingMem);\n  if (parser->m_unknownEncodingRelease)\n    parser->m_unknownEncodingRelease(parser->m_unknownEncodingData);\n  FREE(parser, parser);\n}\n\nvoid XMLCALL\nXML_UseParserAsHandlerArg(XML_Parser parser) {\n  if (parser != NULL)\n    parser->m_handlerArg = parser;\n}\n\nenum XML_Error XMLCALL\nXML_UseForeignDTD(XML_Parser parser, XML_Bool useDTD) {\n  if (parser == NULL)\n    return XML_ERROR_INVALID_ARGUMENT;\n#ifdef XML_DTD\n  /* block after XML_Parse()/XML_ParseBuffer() has been called */\n  if (parser->m_parsingStatus.parsing == XML_PARSING\n      || parser->m_parsingStatus.parsing == XML_SUSPENDED)\n    return XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING;\n  parser->m_useForeignDTD = useDTD;\n  return XML_ERROR_NONE;\n#else\n  UNUSED_P(useDTD);\n  return XML_ERROR_FEATURE_REQUIRES_XML_DTD;\n#endif\n}\n\nvoid XMLCALL\nXML_SetReturnNSTriplet(XML_Parser parser, int do_nst) {\n  if (parser == NULL)\n    return;\n  /* block after XML_Parse()/XML_ParseBuffer() has been called */\n  if (parser->m_parsingStatus.parsing == XML_PARSING\n      || parser->m_parsingStatus.parsing == XML_SUSPENDED)\n    return;\n  parser->m_ns_triplets = do_nst ? XML_TRUE : XML_FALSE;\n}\n\nvoid XMLCALL\nXML_SetUserData(XML_Parser parser, void *p) {\n  if (parser == NULL)\n    return;\n  if (parser->m_handlerArg == parser->m_userData)\n    parser->m_handlerArg = parser->m_userData = p;\n  else\n    parser->m_userData = p;\n}\n\nenum XML_Status XMLCALL\nXML_SetBase(XML_Parser parser, const XML_Char *p) {\n  if (parser == NULL)\n    return XML_STATUS_ERROR;\n  if (p) {\n    p = poolCopyString(&parser->m_dtd->pool, p);\n    if (! p)\n      return XML_STATUS_ERROR;\n    parser->m_curBase = p;\n  } else\n    parser->m_curBase = NULL;\n  return XML_STATUS_OK;\n}\n\nconst XML_Char *XMLCALL\nXML_GetBase(XML_Parser parser) {\n  if (parser == NULL)\n    return NULL;\n  return parser->m_curBase;\n}\n\nint XMLCALL\nXML_GetSpecifiedAttributeCount(XML_Parser parser) {\n  if (parser == NULL)\n    return -1;\n  return parser->m_nSpecifiedAtts;\n}\n\nint XMLCALL\nXML_GetIdAttributeIndex(XML_Parser parser) {\n  if (parser == NULL)\n    return -1;\n  return parser->m_idAttIndex;\n}\n\n#ifdef XML_ATTR_INFO\nconst XML_AttrInfo *XMLCALL\nXML_GetAttributeInfo(XML_Parser parser) {\n  if (parser == NULL)\n    return NULL;\n  return parser->m_attInfo;\n}\n#endif\n\nvoid XMLCALL\nXML_SetElementHandler(XML_Parser parser, XML_StartElementHandler start,\n                      XML_EndElementHandler end) {\n  if (parser == NULL)\n    return;\n  parser->m_startElementHandler = start;\n  parser->m_endElementHandler = end;\n}\n\nvoid XMLCALL\nXML_SetStartElementHandler(XML_Parser parser, XML_StartElementHandler start) {\n  if (parser != NULL)\n    parser->m_startElementHandler = start;\n}\n\nvoid XMLCALL\nXML_SetEndElementHandler(XML_Parser parser, XML_EndElementHandler end) {\n  if (parser != NULL)\n    parser->m_endElementHandler = end;\n}\n\nvoid XMLCALL\nXML_SetCharacterDataHandler(XML_Parser parser,\n                            XML_CharacterDataHandler handler) {\n  if (parser != NULL)\n    parser->m_characterDataHandler = handler;\n}\n\nvoid XMLCALL\nXML_SetProcessingInstructionHandler(XML_Parser parser,\n                                    XML_ProcessingInstructionHandler handler) {\n  if (parser != NULL)\n    parser->m_processingInstructionHandler = handler;\n}\n\nvoid XMLCALL\nXML_SetCommentHandler(XML_Parser parser, XML_CommentHandler handler) {\n  if (parser != NULL)\n    parser->m_commentHandler = handler;\n}\n\nvoid XMLCALL\nXML_SetCdataSectionHandler(XML_Parser parser,\n                           XML_StartCdataSectionHandler start,\n                           XML_EndCdataSectionHandler end) {\n  if (parser == NULL)\n    return;\n  parser->m_startCdataSectionHandler = start;\n  parser->m_endCdataSectionHandler = end;\n}\n\nvoid XMLCALL\nXML_SetStartCdataSectionHandler(XML_Parser parser,\n                                XML_StartCdataSectionHandler start) {\n  if (parser != NULL)\n    parser->m_startCdataSectionHandler = start;\n}\n\nvoid XMLCALL\nXML_SetEndCdataSectionHandler(XML_Parser parser,\n                              XML_EndCdataSectionHandler end) {\n  if (parser != NULL)\n    parser->m_endCdataSectionHandler = end;\n}\n\nvoid XMLCALL\nXML_SetDefaultHandler(XML_Parser parser, XML_DefaultHandler handler) {\n  if (parser == NULL)\n    return;\n  parser->m_defaultHandler = handler;\n  parser->m_defaultExpandInternalEntities = XML_FALSE;\n}\n\nvoid XMLCALL\nXML_SetDefaultHandlerExpand(XML_Parser parser, XML_DefaultHandler handler) {\n  if (parser == NULL)\n    return;\n  parser->m_defaultHandler = handler;\n  parser->m_defaultExpandInternalEntities = XML_TRUE;\n}\n\nvoid XMLCALL\nXML_SetDoctypeDeclHandler(XML_Parser parser, XML_StartDoctypeDeclHandler start,\n                          XML_EndDoctypeDeclHandler end) {\n  if (parser == NULL)\n    return;\n  parser->m_startDoctypeDeclHandler = start;\n  parser->m_endDoctypeDeclHandler = end;\n}\n\nvoid XMLCALL\nXML_SetStartDoctypeDeclHandler(XML_Parser parser,\n                               XML_StartDoctypeDeclHandler start) {\n  if (parser != NULL)\n    parser->m_startDoctypeDeclHandler = start;\n}\n\nvoid XMLCALL\nXML_SetEndDoctypeDeclHandler(XML_Parser parser, XML_EndDoctypeDeclHandler end) {\n  if (parser != NULL)\n    parser->m_endDoctypeDeclHandler = end;\n}\n\nvoid XMLCALL\nXML_SetUnparsedEntityDeclHandler(XML_Parser parser,\n                                 XML_UnparsedEntityDeclHandler handler) {\n  if (parser != NULL)\n    parser->m_unparsedEntityDeclHandler = handler;\n}\n\nvoid XMLCALL\nXML_SetNotationDeclHandler(XML_Parser parser, XML_NotationDeclHandler handler) {\n  if (parser != NULL)\n    parser->m_notationDeclHandler = handler;\n}\n\nvoid XMLCALL\nXML_SetNamespaceDeclHandler(XML_Parser parser,\n                            XML_StartNamespaceDeclHandler start,\n                            XML_EndNamespaceDeclHandler end) {\n  if (parser == NULL)\n    return;\n  parser->m_startNamespaceDeclHandler = start;\n  parser->m_endNamespaceDeclHandler = end;\n}\n\nvoid XMLCALL\nXML_SetStartNamespaceDeclHandler(XML_Parser parser,\n                                 XML_StartNamespaceDeclHandler start) {\n  if (parser != NULL)\n    parser->m_startNamespaceDeclHandler = start;\n}\n\nvoid XMLCALL\nXML_SetEndNamespaceDeclHandler(XML_Parser parser,\n                               XML_EndNamespaceDeclHandler end) {\n  if (parser != NULL)\n    parser->m_endNamespaceDeclHandler = end;\n}\n\nvoid XMLCALL\nXML_SetNotStandaloneHandler(XML_Parser parser,\n                            XML_NotStandaloneHandler handler) {\n  if (parser != NULL)\n    parser->m_notStandaloneHandler = handler;\n}\n\nvoid XMLCALL\nXML_SetExternalEntityRefHandler(XML_Parser parser,\n                                XML_ExternalEntityRefHandler handler) {\n  if (parser != NULL)\n    parser->m_externalEntityRefHandler = handler;\n}\n\nvoid XMLCALL\nXML_SetExternalEntityRefHandlerArg(XML_Parser parser, void *arg) {\n  if (parser == NULL)\n    return;\n  if (arg)\n    parser->m_externalEntityRefHandlerArg = (XML_Parser)arg;\n  else\n    parser->m_externalEntityRefHandlerArg = parser;\n}\n\nvoid XMLCALL\nXML_SetSkippedEntityHandler(XML_Parser parser,\n                            XML_SkippedEntityHandler handler) {\n  if (parser != NULL)\n    parser->m_skippedEntityHandler = handler;\n}\n\nvoid XMLCALL\nXML_SetUnknownEncodingHandler(XML_Parser parser,\n                              XML_UnknownEncodingHandler handler, void *data) {\n  if (parser == NULL)\n    return;\n  parser->m_unknownEncodingHandler = handler;\n  parser->m_unknownEncodingHandlerData = data;\n}\n\nvoid XMLCALL\nXML_SetElementDeclHandler(XML_Parser parser, XML_ElementDeclHandler eldecl) {\n  if (parser != NULL)\n    parser->m_elementDeclHandler = eldecl;\n}\n\nvoid XMLCALL\nXML_SetAttlistDeclHandler(XML_Parser parser, XML_AttlistDeclHandler attdecl) {\n  if (parser != NULL)\n    parser->m_attlistDeclHandler = attdecl;\n}\n\nvoid XMLCALL\nXML_SetEntityDeclHandler(XML_Parser parser, XML_EntityDeclHandler handler) {\n  if (parser != NULL)\n    parser->m_entityDeclHandler = handler;\n}\n\nvoid XMLCALL\nXML_SetXmlDeclHandler(XML_Parser parser, XML_XmlDeclHandler handler) {\n  if (parser != NULL)\n    parser->m_xmlDeclHandler = handler;\n}\n\nint XMLCALL\nXML_SetParamEntityParsing(XML_Parser parser,\n                          enum XML_ParamEntityParsing peParsing) {\n  if (parser == NULL)\n    return 0;\n  /* block after XML_Parse()/XML_ParseBuffer() has been called */\n  if (parser->m_parsingStatus.parsing == XML_PARSING\n      || parser->m_parsingStatus.parsing == XML_SUSPENDED)\n    return 0;\n#ifdef XML_DTD\n  parser->m_paramEntityParsing = peParsing;\n  return 1;\n#else\n  return peParsing == XML_PARAM_ENTITY_PARSING_NEVER;\n#endif\n}\n\nint XMLCALL\nXML_SetHashSalt(XML_Parser parser, unsigned long hash_salt) {\n  if (parser == NULL)\n    return 0;\n  if (parser->m_parentParser)\n    return XML_SetHashSalt(parser->m_parentParser, hash_salt);\n  /* block after XML_Parse()/XML_ParseBuffer() has been called */\n  if (parser->m_parsingStatus.parsing == XML_PARSING\n      || parser->m_parsingStatus.parsing == XML_SUSPENDED)\n    return 0;\n  parser->m_hash_secret_salt = hash_salt;\n  return 1;\n}\n\nenum XML_Status XMLCALL\nXML_Parse(XML_Parser parser, const char *s, int len, int isFinal) {\n  if ((parser == NULL) || (len < 0) || ((s == NULL) && (len != 0))) {\n    if (parser != NULL)\n      parser->m_errorCode = XML_ERROR_INVALID_ARGUMENT;\n    return XML_STATUS_ERROR;\n  }\n  switch (parser->m_parsingStatus.parsing) {\n  case XML_SUSPENDED:\n    parser->m_errorCode = XML_ERROR_SUSPENDED;\n    return XML_STATUS_ERROR;\n  case XML_FINISHED:\n    parser->m_errorCode = XML_ERROR_FINISHED;\n    return XML_STATUS_ERROR;\n  case XML_INITIALIZED:\n    if (parser->m_parentParser == NULL && ! startParsing(parser)) {\n      parser->m_errorCode = XML_ERROR_NO_MEMORY;\n      return XML_STATUS_ERROR;\n    }\n    /* fall through */\n  default:\n    parser->m_parsingStatus.parsing = XML_PARSING;\n  }\n\n  if (len == 0) {\n    parser->m_parsingStatus.finalBuffer = (XML_Bool)isFinal;\n    if (! isFinal)\n      return XML_STATUS_OK;\n    parser->m_positionPtr = parser->m_bufferPtr;\n    parser->m_parseEndPtr = parser->m_bufferEnd;\n\n    /* If data are left over from last buffer, and we now know that these\n       data are the final chunk of input, then we have to check them again\n       to detect errors based on that fact.\n    */\n    parser->m_errorCode\n        = parser->m_processor(parser, parser->m_bufferPtr,\n                              parser->m_parseEndPtr, &parser->m_bufferPtr);\n\n    if (parser->m_errorCode == XML_ERROR_NONE) {\n      switch (parser->m_parsingStatus.parsing) {\n      case XML_SUSPENDED:\n        /* It is hard to be certain, but it seems that this case\n         * cannot occur.  This code is cleaning up a previous parse\n         * with no new data (since len == 0).  Changing the parsing\n         * state requires getting to execute a handler function, and\n         * there doesn't seem to be an opportunity for that while in\n         * this circumstance.\n         *\n         * Given the uncertainty, we retain the code but exclude it\n         * from coverage tests.\n         *\n         * LCOV_EXCL_START\n         */\n        XmlUpdatePosition(parser->m_encoding, parser->m_positionPtr,\n                          parser->m_bufferPtr, &parser->m_position);\n        parser->m_positionPtr = parser->m_bufferPtr;\n        return XML_STATUS_SUSPENDED;\n        /* LCOV_EXCL_STOP */\n      case XML_INITIALIZED:\n      case XML_PARSING:\n        parser->m_parsingStatus.parsing = XML_FINISHED;\n        /* fall through */\n      default:\n        return XML_STATUS_OK;\n      }\n    }\n    parser->m_eventEndPtr = parser->m_eventPtr;\n    parser->m_processor = errorProcessor;\n    return XML_STATUS_ERROR;\n  }\n#if XML_CONTEXT_BYTES == 0\n  else if (parser->m_bufferPtr == parser->m_bufferEnd) {\n    const char *end;\n    int nLeftOver;\n    enum XML_Status result;\n    /* Detect overflow (a+b > MAX <==> b > MAX-a) */\n    if ((XML_Size)len > ((XML_Size)-1) / 2 - parser->m_parseEndByteIndex) {\n      parser->m_errorCode = XML_ERROR_NO_MEMORY;\n      parser->m_eventPtr = parser->m_eventEndPtr = NULL;\n      parser->m_processor = errorProcessor;\n      return XML_STATUS_ERROR;\n    }\n    parser->m_parseEndByteIndex += len;\n    parser->m_positionPtr = s;\n    parser->m_parsingStatus.finalBuffer = (XML_Bool)isFinal;\n\n    parser->m_errorCode\n        = parser->m_processor(parser, s, parser->m_parseEndPtr = s + len, &end);\n\n    if (parser->m_errorCode != XML_ERROR_NONE) {\n      parser->m_eventEndPtr = parser->m_eventPtr;\n      parser->m_processor = errorProcessor;\n      return XML_STATUS_ERROR;\n    } else {\n      switch (parser->m_parsingStatus.parsing) {\n      case XML_SUSPENDED:\n        result = XML_STATUS_SUSPENDED;\n        break;\n      case XML_INITIALIZED:\n      case XML_PARSING:\n        if (isFinal) {\n          parser->m_parsingStatus.parsing = XML_FINISHED;\n          return XML_STATUS_OK;\n        }\n      /* fall through */\n      default:\n        result = XML_STATUS_OK;\n      }\n    }\n\n    XmlUpdatePosition(parser->m_encoding, parser->m_positionPtr, end,\n                      &parser->m_position);\n    nLeftOver = s + len - end;\n    if (nLeftOver) {\n      // Back up and restore the parsing status to avoid XML_ERROR_SUSPENDED\n      // (and XML_ERROR_FINISHED) from XML_GetBuffer.\n      const enum XML_Parsing originalStatus = parser->m_parsingStatus.parsing;\n      parser->m_parsingStatus.parsing = XML_PARSING;\n      void *const temp = XML_GetBuffer(parser, nLeftOver);\n      parser->m_parsingStatus.parsing = originalStatus;\n      if (temp == NULL) {\n        // NOTE: parser->m_errorCode has already been set by XML_GetBuffer().\n        parser->m_eventPtr = parser->m_eventEndPtr = NULL;\n        parser->m_processor = errorProcessor;\n        return XML_STATUS_ERROR;\n      }\n      // Since we know that the buffer was empty and XML_CONTEXT_BYTES is 0, we\n      // don't have any data to preserve, and can copy straight into the start\n      // of the buffer rather than the GetBuffer return pointer (which may be\n      // pointing further into the allocated buffer).\n      memcpy(parser->m_buffer, end, nLeftOver);\n    }\n    parser->m_bufferPtr = parser->m_buffer;\n    parser->m_bufferEnd = parser->m_buffer + nLeftOver;\n    parser->m_positionPtr = parser->m_bufferPtr;\n    parser->m_parseEndPtr = parser->m_bufferEnd;\n    parser->m_eventPtr = parser->m_bufferPtr;\n    parser->m_eventEndPtr = parser->m_bufferPtr;\n    return result;\n  }\n#endif /* XML_CONTEXT_BYTES == 0 */\n  else {\n    void *buff = XML_GetBuffer(parser, len);\n    if (buff == NULL)\n      return XML_STATUS_ERROR;\n    else {\n      memcpy(buff, s, len);\n      return XML_ParseBuffer(parser, len, isFinal);\n    }\n  }\n}\n\nenum XML_Status XMLCALL\nXML_ParseBuffer(XML_Parser parser, int len, int isFinal) {\n  const char *start;\n  enum XML_Status result = XML_STATUS_OK;\n\n  if (parser == NULL)\n    return XML_STATUS_ERROR;\n  switch (parser->m_parsingStatus.parsing) {\n  case XML_SUSPENDED:\n    parser->m_errorCode = XML_ERROR_SUSPENDED;\n    return XML_STATUS_ERROR;\n  case XML_FINISHED:\n    parser->m_errorCode = XML_ERROR_FINISHED;\n    return XML_STATUS_ERROR;\n  case XML_INITIALIZED:\n    /* Has someone called XML_GetBuffer successfully before? */\n    if (! parser->m_bufferPtr) {\n      parser->m_errorCode = XML_ERROR_NO_BUFFER;\n      return XML_STATUS_ERROR;\n    }\n\n    if (parser->m_parentParser == NULL && ! startParsing(parser)) {\n      parser->m_errorCode = XML_ERROR_NO_MEMORY;\n      return XML_STATUS_ERROR;\n    }\n    /* fall through */\n  default:\n    parser->m_parsingStatus.parsing = XML_PARSING;\n  }\n\n  start = parser->m_bufferPtr;\n  parser->m_positionPtr = start;\n  parser->m_bufferEnd += len;\n  parser->m_parseEndPtr = parser->m_bufferEnd;\n  parser->m_parseEndByteIndex += len;\n  parser->m_parsingStatus.finalBuffer = (XML_Bool)isFinal;\n\n  parser->m_errorCode = parser->m_processor(\n      parser, start, parser->m_parseEndPtr, &parser->m_bufferPtr);\n\n  if (parser->m_errorCode != XML_ERROR_NONE) {\n    parser->m_eventEndPtr = parser->m_eventPtr;\n    parser->m_processor = errorProcessor;\n    return XML_STATUS_ERROR;\n  } else {\n    switch (parser->m_parsingStatus.parsing) {\n    case XML_SUSPENDED:\n      result = XML_STATUS_SUSPENDED;\n      break;\n    case XML_INITIALIZED:\n    case XML_PARSING:\n      if (isFinal) {\n        parser->m_parsingStatus.parsing = XML_FINISHED;\n        return result;\n      }\n    default:; /* should not happen */\n    }\n  }\n\n  XmlUpdatePosition(parser->m_encoding, parser->m_positionPtr,\n                    parser->m_bufferPtr, &parser->m_position);\n  parser->m_positionPtr = parser->m_bufferPtr;\n  return result;\n}\n\nvoid *XMLCALL\nXML_GetBuffer(XML_Parser parser, int len) {\n  if (parser == NULL)\n    return NULL;\n  if (len < 0) {\n    parser->m_errorCode = XML_ERROR_NO_MEMORY;\n    return NULL;\n  }\n  switch (parser->m_parsingStatus.parsing) {\n  case XML_SUSPENDED:\n    parser->m_errorCode = XML_ERROR_SUSPENDED;\n    return NULL;\n  case XML_FINISHED:\n    parser->m_errorCode = XML_ERROR_FINISHED;\n    return NULL;\n  default:;\n  }\n\n  if (len > EXPAT_SAFE_PTR_DIFF(parser->m_bufferLim, parser->m_bufferEnd)) {\n#if XML_CONTEXT_BYTES > 0\n    int keep;\n#endif /* XML_CONTEXT_BYTES > 0 */\n    /* Do not invoke signed arithmetic overflow: */\n    int neededSize = (int)((unsigned)len\n                           + (unsigned)EXPAT_SAFE_PTR_DIFF(\n                               parser->m_bufferEnd, parser->m_bufferPtr));\n    if (neededSize < 0) {\n      parser->m_errorCode = XML_ERROR_NO_MEMORY;\n      return NULL;\n    }\n#if XML_CONTEXT_BYTES > 0\n    keep = (int)EXPAT_SAFE_PTR_DIFF(parser->m_bufferPtr, parser->m_buffer);\n    if (keep > XML_CONTEXT_BYTES)\n      keep = XML_CONTEXT_BYTES;\n    /* Detect and prevent integer overflow */\n    if (keep > INT_MAX - neededSize) {\n      parser->m_errorCode = XML_ERROR_NO_MEMORY;\n      return NULL;\n    }\n    neededSize += keep;\n#endif /* XML_CONTEXT_BYTES > 0 */\n    if (neededSize\n        <= EXPAT_SAFE_PTR_DIFF(parser->m_bufferLim, parser->m_buffer)) {\n#if XML_CONTEXT_BYTES > 0\n      if (keep < EXPAT_SAFE_PTR_DIFF(parser->m_bufferPtr, parser->m_buffer)) {\n        int offset\n            = (int)EXPAT_SAFE_PTR_DIFF(parser->m_bufferPtr, parser->m_buffer)\n              - keep;\n        /* The buffer pointers cannot be NULL here; we have at least some bytes\n         * in the buffer */\n        memmove(parser->m_buffer, &parser->m_buffer[offset],\n                parser->m_bufferEnd - parser->m_bufferPtr + keep);\n        parser->m_bufferEnd -= offset;\n        parser->m_bufferPtr -= offset;\n      }\n#else\n      if (parser->m_buffer && parser->m_bufferPtr) {\n        memmove(parser->m_buffer, parser->m_bufferPtr,\n                EXPAT_SAFE_PTR_DIFF(parser->m_bufferEnd, parser->m_bufferPtr));\n        parser->m_bufferEnd\n            = parser->m_buffer\n              + EXPAT_SAFE_PTR_DIFF(parser->m_bufferEnd, parser->m_bufferPtr);\n        parser->m_bufferPtr = parser->m_buffer;\n      }\n#endif /* XML_CONTEXT_BYTES > 0 */\n    } else {\n      char *newBuf;\n      int bufferSize\n          = (int)EXPAT_SAFE_PTR_DIFF(parser->m_bufferLim, parser->m_buffer);\n      if (bufferSize == 0)\n        bufferSize = INIT_BUFFER_SIZE;\n      do {\n        /* Do not invoke signed arithmetic overflow: */\n        bufferSize = (int)(2U * (unsigned)bufferSize);\n      } while (bufferSize < neededSize && bufferSize > 0);\n      if (bufferSize <= 0) {\n        parser->m_errorCode = XML_ERROR_NO_MEMORY;\n        return NULL;\n      }\n      newBuf = (char *)MALLOC(parser, bufferSize);\n      if (newBuf == 0) {\n        parser->m_errorCode = XML_ERROR_NO_MEMORY;\n        return NULL;\n      }\n      parser->m_bufferLim = newBuf + bufferSize;\n#if XML_CONTEXT_BYTES > 0\n      if (parser->m_bufferPtr) {\n        memcpy(newBuf, &parser->m_bufferPtr[-keep],\n               EXPAT_SAFE_PTR_DIFF(parser->m_bufferEnd, parser->m_bufferPtr)\n                   + keep);\n        FREE(parser, parser->m_buffer);\n        parser->m_buffer = newBuf;\n        parser->m_bufferEnd\n            = parser->m_buffer\n              + EXPAT_SAFE_PTR_DIFF(parser->m_bufferEnd, parser->m_bufferPtr)\n              + keep;\n        parser->m_bufferPtr = parser->m_buffer + keep;\n      } else {\n        /* This must be a brand new buffer with no data in it yet */\n        parser->m_bufferEnd = newBuf;\n        parser->m_bufferPtr = parser->m_buffer = newBuf;\n      }\n#else\n      if (parser->m_bufferPtr) {\n        memcpy(newBuf, parser->m_bufferPtr,\n               EXPAT_SAFE_PTR_DIFF(parser->m_bufferEnd, parser->m_bufferPtr));\n        FREE(parser, parser->m_buffer);\n        parser->m_bufferEnd\n            = newBuf\n              + EXPAT_SAFE_PTR_DIFF(parser->m_bufferEnd, parser->m_bufferPtr);\n      } else {\n        /* This must be a brand new buffer with no data in it yet */\n        parser->m_bufferEnd = newBuf;\n      }\n      parser->m_bufferPtr = parser->m_buffer = newBuf;\n#endif /* XML_CONTEXT_BYTES > 0 */\n    }\n    parser->m_eventPtr = parser->m_eventEndPtr = NULL;\n    parser->m_positionPtr = NULL;\n  }\n  return parser->m_bufferEnd;\n}\n\nenum XML_Status XMLCALL\nXML_StopParser(XML_Parser parser, XML_Bool resumable) {\n  if (parser == NULL)\n    return XML_STATUS_ERROR;\n  switch (parser->m_parsingStatus.parsing) {\n  case XML_SUSPENDED:\n    if (resumable) {\n      parser->m_errorCode = XML_ERROR_SUSPENDED;\n      return XML_STATUS_ERROR;\n    }\n    parser->m_parsingStatus.parsing = XML_FINISHED;\n    break;\n  case XML_FINISHED:\n    parser->m_errorCode = XML_ERROR_FINISHED;\n    return XML_STATUS_ERROR;\n  default:\n    if (resumable) {\n#ifdef XML_DTD\n      if (parser->m_isParamEntity) {\n        parser->m_errorCode = XML_ERROR_SUSPEND_PE;\n        return XML_STATUS_ERROR;\n      }\n#endif\n      parser->m_parsingStatus.parsing = XML_SUSPENDED;\n    } else\n      parser->m_parsingStatus.parsing = XML_FINISHED;\n  }\n  return XML_STATUS_OK;\n}\n\nenum XML_Status XMLCALL\nXML_ResumeParser(XML_Parser parser) {\n  enum XML_Status result = XML_STATUS_OK;\n\n  if (parser == NULL)\n    return XML_STATUS_ERROR;\n  if (parser->m_parsingStatus.parsing != XML_SUSPENDED) {\n    parser->m_errorCode = XML_ERROR_NOT_SUSPENDED;\n    return XML_STATUS_ERROR;\n  }\n  parser->m_parsingStatus.parsing = XML_PARSING;\n\n  parser->m_errorCode = parser->m_processor(\n      parser, parser->m_bufferPtr, parser->m_parseEndPtr, &parser->m_bufferPtr);\n\n  if (parser->m_errorCode != XML_ERROR_NONE) {\n    parser->m_eventEndPtr = parser->m_eventPtr;\n    parser->m_processor = errorProcessor;\n    return XML_STATUS_ERROR;\n  } else {\n    switch (parser->m_parsingStatus.parsing) {\n    case XML_SUSPENDED:\n      result = XML_STATUS_SUSPENDED;\n      break;\n    case XML_INITIALIZED:\n    case XML_PARSING:\n      if (parser->m_parsingStatus.finalBuffer) {\n        parser->m_parsingStatus.parsing = XML_FINISHED;\n        return result;\n      }\n    default:;\n    }\n  }\n\n  XmlUpdatePosition(parser->m_encoding, parser->m_positionPtr,\n                    parser->m_bufferPtr, &parser->m_position);\n  parser->m_positionPtr = parser->m_bufferPtr;\n  return result;\n}\n\nvoid XMLCALL\nXML_GetParsingStatus(XML_Parser parser, XML_ParsingStatus *status) {\n  if (parser == NULL)\n    return;\n  assert(status != NULL);\n  *status = parser->m_parsingStatus;\n}\n\nenum XML_Error XMLCALL\nXML_GetErrorCode(XML_Parser parser) {\n  if (parser == NULL)\n    return XML_ERROR_INVALID_ARGUMENT;\n  return parser->m_errorCode;\n}\n\nXML_Index XMLCALL\nXML_GetCurrentByteIndex(XML_Parser parser) {\n  if (parser == NULL)\n    return -1;\n  if (parser->m_eventPtr)\n    return (XML_Index)(parser->m_parseEndByteIndex\n                       - (parser->m_parseEndPtr - parser->m_eventPtr));\n  return -1;\n}\n\nint XMLCALL\nXML_GetCurrentByteCount(XML_Parser parser) {\n  if (parser == NULL)\n    return 0;\n  if (parser->m_eventEndPtr && parser->m_eventPtr)\n    return (int)(parser->m_eventEndPtr - parser->m_eventPtr);\n  return 0;\n}\n\nconst char *XMLCALL\nXML_GetInputContext(XML_Parser parser, int *offset, int *size) {\n#if XML_CONTEXT_BYTES > 0\n  if (parser == NULL)\n    return NULL;\n  if (parser->m_eventPtr && parser->m_buffer) {\n    if (offset != NULL)\n      *offset = (int)(parser->m_eventPtr - parser->m_buffer);\n    if (size != NULL)\n      *size = (int)(parser->m_bufferEnd - parser->m_buffer);\n    return parser->m_buffer;\n  }\n#else\n  (void)parser;\n  (void)offset;\n  (void)size;\n#endif /* XML_CONTEXT_BYTES > 0 */\n  return (const char *)0;\n}\n\nXML_Size XMLCALL\nXML_GetCurrentLineNumber(XML_Parser parser) {\n  if (parser == NULL)\n    return 0;\n  if (parser->m_eventPtr && parser->m_eventPtr >= parser->m_positionPtr) {\n    XmlUpdatePosition(parser->m_encoding, parser->m_positionPtr,\n                      parser->m_eventPtr, &parser->m_position);\n    parser->m_positionPtr = parser->m_eventPtr;\n  }\n  return parser->m_position.lineNumber + 1;\n}\n\nXML_Size XMLCALL\nXML_GetCurrentColumnNumber(XML_Parser parser) {\n  if (parser == NULL)\n    return 0;\n  if (parser->m_eventPtr && parser->m_eventPtr >= parser->m_positionPtr) {\n    XmlUpdatePosition(parser->m_encoding, parser->m_positionPtr,\n                      parser->m_eventPtr, &parser->m_position);\n    parser->m_positionPtr = parser->m_eventPtr;\n  }\n  return parser->m_position.columnNumber;\n}\n\nvoid XMLCALL\nXML_FreeContentModel(XML_Parser parser, XML_Content *model) {\n  if (parser != NULL)\n    FREE(parser, model);\n}\n\nvoid *XMLCALL\nXML_MemMalloc(XML_Parser parser, size_t size) {\n  if (parser == NULL)\n    return NULL;\n  return MALLOC(parser, size);\n}\n\nvoid *XMLCALL\nXML_MemRealloc(XML_Parser parser, void *ptr, size_t size) {\n  if (parser == NULL)\n    return NULL;\n  return REALLOC(parser, ptr, size);\n}\n\nvoid XMLCALL\nXML_MemFree(XML_Parser parser, void *ptr) {\n  if (parser != NULL)\n    FREE(parser, ptr);\n}\n\nvoid XMLCALL\nXML_DefaultCurrent(XML_Parser parser) {\n  if (parser == NULL)\n    return;\n  if (parser->m_defaultHandler) {\n    if (parser->m_openInternalEntities)\n      reportDefault(parser, parser->m_internalEncoding,\n                    parser->m_openInternalEntities->internalEventPtr,\n                    parser->m_openInternalEntities->internalEventEndPtr);\n    else\n      reportDefault(parser, parser->m_encoding, parser->m_eventPtr,\n                    parser->m_eventEndPtr);\n  }\n}\n\nconst XML_LChar *XMLCALL\nXML_ErrorString(enum XML_Error code) {\n  switch (code) {\n  case XML_ERROR_NONE:\n    return NULL;\n  case XML_ERROR_NO_MEMORY:\n    return XML_L(\"out of memory\");\n  case XML_ERROR_SYNTAX:\n    return XML_L(\"syntax error\");\n  case XML_ERROR_NO_ELEMENTS:\n    return XML_L(\"no element found\");\n  case XML_ERROR_INVALID_TOKEN:\n    return XML_L(\"not well-formed (invalid token)\");\n  case XML_ERROR_UNCLOSED_TOKEN:\n    return XML_L(\"unclosed token\");\n  case XML_ERROR_PARTIAL_CHAR:\n    return XML_L(\"partial character\");\n  case XML_ERROR_TAG_MISMATCH:\n    return XML_L(\"mismatched tag\");\n  case XML_ERROR_DUPLICATE_ATTRIBUTE:\n    return XML_L(\"duplicate attribute\");\n  case XML_ERROR_JUNK_AFTER_DOC_ELEMENT:\n    return XML_L(\"junk after document element\");\n  case XML_ERROR_PARAM_ENTITY_REF:\n    return XML_L(\"illegal parameter entity reference\");\n  case XML_ERROR_UNDEFINED_ENTITY:\n    return XML_L(\"undefined entity\");\n  case XML_ERROR_RECURSIVE_ENTITY_REF:\n    return XML_L(\"recursive entity reference\");\n  case XML_ERROR_ASYNC_ENTITY:\n    return XML_L(\"asynchronous entity\");\n  case XML_ERROR_BAD_CHAR_REF:\n    return XML_L(\"reference to invalid character number\");\n  case XML_ERROR_BINARY_ENTITY_REF:\n    return XML_L(\"reference to binary entity\");\n  case XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF:\n    return XML_L(\"reference to external entity in attribute\");\n  case XML_ERROR_MISPLACED_XML_PI:\n    return XML_L(\"XML or text declaration not at start of entity\");\n  case XML_ERROR_UNKNOWN_ENCODING:\n    return XML_L(\"unknown encoding\");\n  case XML_ERROR_INCORRECT_ENCODING:\n    return XML_L(\"encoding specified in XML declaration is incorrect\");\n  case XML_ERROR_UNCLOSED_CDATA_SECTION:\n    return XML_L(\"unclosed CDATA section\");\n  case XML_ERROR_EXTERNAL_ENTITY_HANDLING:\n    return XML_L(\"error in processing external entity reference\");\n  case XML_ERROR_NOT_STANDALONE:\n    return XML_L(\"document is not standalone\");\n  case XML_ERROR_UNEXPECTED_STATE:\n    return XML_L(\"unexpected parser state - please send a bug report\");\n  case XML_ERROR_ENTITY_DECLARED_IN_PE:\n    return XML_L(\"entity declared in parameter entity\");\n  case XML_ERROR_FEATURE_REQUIRES_XML_DTD:\n    return XML_L(\"requested feature requires XML_DTD support in Expat\");\n  case XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING:\n    return XML_L(\"cannot change setting once parsing has begun\");\n  /* Added in 1.95.7. */\n  case XML_ERROR_UNBOUND_PREFIX:\n    return XML_L(\"unbound prefix\");\n  /* Added in 1.95.8. */\n  case XML_ERROR_UNDECLARING_PREFIX:\n    return XML_L(\"must not undeclare prefix\");\n  case XML_ERROR_INCOMPLETE_PE:\n    return XML_L(\"incomplete markup in parameter entity\");\n  case XML_ERROR_XML_DECL:\n    return XML_L(\"XML declaration not well-formed\");\n  case XML_ERROR_TEXT_DECL:\n    return XML_L(\"text declaration not well-formed\");\n  case XML_ERROR_PUBLICID:\n    return XML_L(\"illegal character(s) in public id\");\n  case XML_ERROR_SUSPENDED:\n    return XML_L(\"parser suspended\");\n  case XML_ERROR_NOT_SUSPENDED:\n    return XML_L(\"parser not suspended\");\n  case XML_ERROR_ABORTED:\n    return XML_L(\"parsing aborted\");\n  case XML_ERROR_FINISHED:\n    return XML_L(\"parsing finished\");\n  case XML_ERROR_SUSPEND_PE:\n    return XML_L(\"cannot suspend in external parameter entity\");\n  /* Added in 2.0.0. */\n  case XML_ERROR_RESERVED_PREFIX_XML:\n    return XML_L(\n        \"reserved prefix (xml) must not be undeclared or bound to another namespace name\");\n  case XML_ERROR_RESERVED_PREFIX_XMLNS:\n    return XML_L(\"reserved prefix (xmlns) must not be declared or undeclared\");\n  case XML_ERROR_RESERVED_NAMESPACE_URI:\n    return XML_L(\n        \"prefix must not be bound to one of the reserved namespace names\");\n  /* Added in 2.2.5. */\n  case XML_ERROR_INVALID_ARGUMENT: /* Constant added in 2.2.1, already */\n    return XML_L(\"invalid argument\");\n    /* Added in 2.3.0. */\n  case XML_ERROR_NO_BUFFER:\n    return XML_L(\n        \"a successful prior call to function XML_GetBuffer is required\");\n  /* Added in 2.4.0. */\n  case XML_ERROR_AMPLIFICATION_LIMIT_BREACH:\n    return XML_L(\n        \"limit on input amplification factor (from DTD and entities) breached\");\n  }\n  return NULL;\n}\n\nconst XML_LChar *XMLCALL\nXML_ExpatVersion(void) {\n  /* V1 is used to string-ize the version number. However, it would\n     string-ize the actual version macro *names* unless we get them\n     substituted before being passed to V1. CPP is defined to expand\n     a macro, then rescan for more expansions. Thus, we use V2 to expand\n     the version macros, then CPP will expand the resulting V1() macro\n     with the correct numerals. */\n  /* ### I'm assuming cpp is portable in this respect... */\n\n#define V1(a, b, c) XML_L(#a) XML_L(\".\") XML_L(#b) XML_L(\".\") XML_L(#c)\n#define V2(a, b, c) XML_L(\"expat_\") V1(a, b, c)\n\n  return V2(XML_MAJOR_VERSION, XML_MINOR_VERSION, XML_MICRO_VERSION);\n\n#undef V1\n#undef V2\n}\n\nXML_Expat_Version XMLCALL\nXML_ExpatVersionInfo(void) {\n  XML_Expat_Version version;\n\n  version.major = XML_MAJOR_VERSION;\n  version.minor = XML_MINOR_VERSION;\n  version.micro = XML_MICRO_VERSION;\n\n  return version;\n}\n\nconst XML_Feature *XMLCALL\nXML_GetFeatureList(void) {\n  static const XML_Feature features[] = {\n    {XML_FEATURE_SIZEOF_XML_CHAR, XML_L(\"sizeof(XML_Char)\"), sizeof(XML_Char)},\n    {XML_FEATURE_SIZEOF_XML_LCHAR, XML_L(\"sizeof(XML_LChar)\"),\n     sizeof(XML_LChar)},\n#ifdef XML_UNICODE\n    {XML_FEATURE_UNICODE, XML_L(\"XML_UNICODE\"), 0},\n#endif\n#ifdef XML_UNICODE_WCHAR_T\n    {XML_FEATURE_UNICODE_WCHAR_T, XML_L(\"XML_UNICODE_WCHAR_T\"), 0},\n#endif\n#ifdef XML_DTD\n    {XML_FEATURE_DTD, XML_L(\"XML_DTD\"), 0},\n#endif\n#if XML_CONTEXT_BYTES > 0\n    {XML_FEATURE_CONTEXT_BYTES, XML_L(\"XML_CONTEXT_BYTES\"), XML_CONTEXT_BYTES},\n#endif\n#ifdef XML_MIN_SIZE\n    {XML_FEATURE_MIN_SIZE, XML_L(\"XML_MIN_SIZE\"), 0},\n#endif\n#ifdef XML_NS\n    {XML_FEATURE_NS, XML_L(\"XML_NS\"), 0},\n#endif\n#ifdef XML_LARGE_SIZE\n    {XML_FEATURE_LARGE_SIZE, XML_L(\"XML_LARGE_SIZE\"), 0},\n#endif\n#ifdef XML_ATTR_INFO\n    {XML_FEATURE_ATTR_INFO, XML_L(\"XML_ATTR_INFO\"), 0},\n#endif\n#ifdef XML_DTD\n    /* Added in Expat 2.4.0. */\n    {XML_FEATURE_BILLION_LAUGHS_ATTACK_PROTECTION_MAXIMUM_AMPLIFICATION_DEFAULT,\n     XML_L(\"XML_BLAP_MAX_AMP\"),\n     (long int)\n         EXPAT_BILLION_LAUGHS_ATTACK_PROTECTION_MAXIMUM_AMPLIFICATION_DEFAULT},\n    {XML_FEATURE_BILLION_LAUGHS_ATTACK_PROTECTION_ACTIVATION_THRESHOLD_DEFAULT,\n     XML_L(\"XML_BLAP_ACT_THRES\"),\n     EXPAT_BILLION_LAUGHS_ATTACK_PROTECTION_ACTIVATION_THRESHOLD_DEFAULT},\n#endif\n    {XML_FEATURE_END, NULL, 0}\n  };\n\n  return features;\n}\n\n#ifdef XML_DTD\nXML_Bool XMLCALL\nXML_SetBillionLaughsAttackProtectionMaximumAmplification(\n    XML_Parser parser, float maximumAmplificationFactor) {\n  if ((parser == NULL) || (parser->m_parentParser != NULL)\n      || isnan(maximumAmplificationFactor)\n      || (maximumAmplificationFactor < 1.0f)) {\n    return XML_FALSE;\n  }\n  parser->m_accounting.maximumAmplificationFactor = maximumAmplificationFactor;\n  return XML_TRUE;\n}\n\nXML_Bool XMLCALL\nXML_SetBillionLaughsAttackProtectionActivationThreshold(\n    XML_Parser parser, unsigned long long activationThresholdBytes) {\n  if ((parser == NULL) || (parser->m_parentParser != NULL)) {\n    return XML_FALSE;\n  }\n  parser->m_accounting.activationThresholdBytes = activationThresholdBytes;\n  return XML_TRUE;\n}\n#endif /* XML_DTD */\n\n/* Initially tag->rawName always points into the parse buffer;\n   for those TAG instances opened while the current parse buffer was\n   processed, and not yet closed, we need to store tag->rawName in a more\n   permanent location, since the parse buffer is about to be discarded.\n*/\nstatic XML_Bool\nstoreRawNames(XML_Parser parser) {\n  TAG *tag = parser->m_tagStack;\n  while (tag) {\n    int bufSize;\n    int nameLen = sizeof(XML_Char) * (tag->name.strLen + 1);\n    size_t rawNameLen;\n    char *rawNameBuf = tag->buf + nameLen;\n    /* Stop if already stored.  Since m_tagStack is a stack, we can stop\n       at the first entry that has already been copied; everything\n       below it in the stack is already been accounted for in a\n       previous call to this function.\n    */\n    if (tag->rawName == rawNameBuf)\n      break;\n    /* For reuse purposes we need to ensure that the\n       size of tag->buf is a multiple of sizeof(XML_Char).\n    */\n    rawNameLen = ROUND_UP(tag->rawNameLength, sizeof(XML_Char));\n    /* Detect and prevent integer overflow. */\n    if (rawNameLen > (size_t)INT_MAX - nameLen)\n      return XML_FALSE;\n    bufSize = nameLen + (int)rawNameLen;\n    if (bufSize > tag->bufEnd - tag->buf) {\n      char *temp = (char *)REALLOC(parser, tag->buf, bufSize);\n      if (temp == NULL)\n        return XML_FALSE;\n      /* if tag->name.str points to tag->buf (only when namespace\n         processing is off) then we have to update it\n      */\n      if (tag->name.str == (XML_Char *)tag->buf)\n        tag->name.str = (XML_Char *)temp;\n      /* if tag->name.localPart is set (when namespace processing is on)\n         then update it as well, since it will always point into tag->buf\n      */\n      if (tag->name.localPart)\n        tag->name.localPart\n            = (XML_Char *)temp + (tag->name.localPart - (XML_Char *)tag->buf);\n      tag->buf = temp;\n      tag->bufEnd = temp + bufSize;\n      rawNameBuf = temp + nameLen;\n    }\n    memcpy(rawNameBuf, tag->rawName, tag->rawNameLength);\n    tag->rawName = rawNameBuf;\n    tag = tag->parent;\n  }\n  return XML_TRUE;\n}\n\nstatic enum XML_Error PTRCALL\ncontentProcessor(XML_Parser parser, const char *start, const char *end,\n                 const char **endPtr) {\n  enum XML_Error result = doContent(\n      parser, 0, parser->m_encoding, start, end, endPtr,\n      (XML_Bool)! parser->m_parsingStatus.finalBuffer, XML_ACCOUNT_DIRECT);\n  if (result == XML_ERROR_NONE) {\n    if (! storeRawNames(parser))\n      return XML_ERROR_NO_MEMORY;\n  }\n  return result;\n}\n\nstatic enum XML_Error PTRCALL\nexternalEntityInitProcessor(XML_Parser parser, const char *start,\n                            const char *end, const char **endPtr) {\n  enum XML_Error result = initializeEncoding(parser);\n  if (result != XML_ERROR_NONE)\n    return result;\n  parser->m_processor = externalEntityInitProcessor2;\n  return externalEntityInitProcessor2(parser, start, end, endPtr);\n}\n\nstatic enum XML_Error PTRCALL\nexternalEntityInitProcessor2(XML_Parser parser, const char *start,\n                             const char *end, const char **endPtr) {\n  const char *next = start; /* XmlContentTok doesn't always set the last arg */\n  int tok = XmlContentTok(parser->m_encoding, start, end, &next);\n  switch (tok) {\n  case XML_TOK_BOM:\n#ifdef XML_DTD\n    if (! accountingDiffTolerated(parser, tok, start, next, __LINE__,\n                                  XML_ACCOUNT_DIRECT)) {\n      accountingOnAbort(parser);\n      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n    }\n#endif /* XML_DTD */\n\n    /* If we are at the end of the buffer, this would cause the next stage,\n       i.e. externalEntityInitProcessor3, to pass control directly to\n       doContent (by detecting XML_TOK_NONE) without processing any xml text\n       declaration - causing the error XML_ERROR_MISPLACED_XML_PI in doContent.\n    */\n    if (next == end && ! parser->m_parsingStatus.finalBuffer) {\n      *endPtr = next;\n      return XML_ERROR_NONE;\n    }\n    start = next;\n    break;\n  case XML_TOK_PARTIAL:\n    if (! parser->m_parsingStatus.finalBuffer) {\n      *endPtr = start;\n      return XML_ERROR_NONE;\n    }\n    parser->m_eventPtr = start;\n    return XML_ERROR_UNCLOSED_TOKEN;\n  case XML_TOK_PARTIAL_CHAR:\n    if (! parser->m_parsingStatus.finalBuffer) {\n      *endPtr = start;\n      return XML_ERROR_NONE;\n    }\n    parser->m_eventPtr = start;\n    return XML_ERROR_PARTIAL_CHAR;\n  }\n  parser->m_processor = externalEntityInitProcessor3;\n  return externalEntityInitProcessor3(parser, start, end, endPtr);\n}\n\nstatic enum XML_Error PTRCALL\nexternalEntityInitProcessor3(XML_Parser parser, const char *start,\n                             const char *end, const char **endPtr) {\n  int tok;\n  const char *next = start; /* XmlContentTok doesn't always set the last arg */\n  parser->m_eventPtr = start;\n  tok = XmlContentTok(parser->m_encoding, start, end, &next);\n  /* Note: These bytes are accounted later in:\n           - processXmlDecl\n           - externalEntityContentProcessor\n  */\n  parser->m_eventEndPtr = next;\n\n  switch (tok) {\n  case XML_TOK_XML_DECL: {\n    enum XML_Error result;\n    result = processXmlDecl(parser, 1, start, next);\n    if (result != XML_ERROR_NONE)\n      return result;\n    switch (parser->m_parsingStatus.parsing) {\n    case XML_SUSPENDED:\n      *endPtr = next;\n      return XML_ERROR_NONE;\n    case XML_FINISHED:\n      return XML_ERROR_ABORTED;\n    default:\n      start = next;\n    }\n  } break;\n  case XML_TOK_PARTIAL:\n    if (! parser->m_parsingStatus.finalBuffer) {\n      *endPtr = start;\n      return XML_ERROR_NONE;\n    }\n    return XML_ERROR_UNCLOSED_TOKEN;\n  case XML_TOK_PARTIAL_CHAR:\n    if (! parser->m_parsingStatus.finalBuffer) {\n      *endPtr = start;\n      return XML_ERROR_NONE;\n    }\n    return XML_ERROR_PARTIAL_CHAR;\n  }\n  parser->m_processor = externalEntityContentProcessor;\n  parser->m_tagLevel = 1;\n  return externalEntityContentProcessor(parser, start, end, endPtr);\n}\n\nstatic enum XML_Error PTRCALL\nexternalEntityContentProcessor(XML_Parser parser, const char *start,\n                               const char *end, const char **endPtr) {\n  enum XML_Error result\n      = doContent(parser, 1, parser->m_encoding, start, end, endPtr,\n                  (XML_Bool)! parser->m_parsingStatus.finalBuffer,\n                  XML_ACCOUNT_ENTITY_EXPANSION);\n  if (result == XML_ERROR_NONE) {\n    if (! storeRawNames(parser))\n      return XML_ERROR_NO_MEMORY;\n  }\n  return result;\n}\n\nstatic enum XML_Error\ndoContent(XML_Parser parser, int startTagLevel, const ENCODING *enc,\n          const char *s, const char *end, const char **nextPtr,\n          XML_Bool haveMore, enum XML_Account account) {\n  /* save one level of indirection */\n  DTD *const dtd = parser->m_dtd;\n\n  const char **eventPP;\n  const char **eventEndPP;\n  if (enc == parser->m_encoding) {\n    eventPP = &parser->m_eventPtr;\n    eventEndPP = &parser->m_eventEndPtr;\n  } else {\n    eventPP = &(parser->m_openInternalEntities->internalEventPtr);\n    eventEndPP = &(parser->m_openInternalEntities->internalEventEndPtr);\n  }\n  *eventPP = s;\n\n  for (;;) {\n    const char *next = s; /* XmlContentTok doesn't always set the last arg */\n    int tok = XmlContentTok(enc, s, end, &next);\n#ifdef XML_DTD\n    const char *accountAfter\n        = ((tok == XML_TOK_TRAILING_RSQB) || (tok == XML_TOK_TRAILING_CR))\n              ? (haveMore ? s /* i.e. 0 bytes */ : end)\n              : next;\n    if (! accountingDiffTolerated(parser, tok, s, accountAfter, __LINE__,\n                                  account)) {\n      accountingOnAbort(parser);\n      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n    }\n#endif\n    *eventEndPP = next;\n    switch (tok) {\n    case XML_TOK_TRAILING_CR:\n      if (haveMore) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      *eventEndPP = end;\n      if (parser->m_characterDataHandler) {\n        XML_Char c = 0xA;\n        parser->m_characterDataHandler(parser->m_handlerArg, &c, 1);\n      } else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, end);\n      /* We are at the end of the final buffer, should we check for\n         XML_SUSPENDED, XML_FINISHED?\n      */\n      if (startTagLevel == 0)\n        return XML_ERROR_NO_ELEMENTS;\n      if (parser->m_tagLevel != startTagLevel)\n        return XML_ERROR_ASYNC_ENTITY;\n      *nextPtr = end;\n      return XML_ERROR_NONE;\n    case XML_TOK_NONE:\n      if (haveMore) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      if (startTagLevel > 0) {\n        if (parser->m_tagLevel != startTagLevel)\n          return XML_ERROR_ASYNC_ENTITY;\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      return XML_ERROR_NO_ELEMENTS;\n    case XML_TOK_INVALID:\n      *eventPP = next;\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_PARTIAL:\n      if (haveMore) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      return XML_ERROR_UNCLOSED_TOKEN;\n    case XML_TOK_PARTIAL_CHAR:\n      if (haveMore) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      return XML_ERROR_PARTIAL_CHAR;\n    case XML_TOK_ENTITY_REF: {\n      const XML_Char *name;\n      ENTITY *entity;\n      XML_Char ch = (XML_Char)XmlPredefinedEntityName(\n          enc, s + enc->minBytesPerChar, next - enc->minBytesPerChar);\n      if (ch) {\n#ifdef XML_DTD\n        /* NOTE: We are replacing 4-6 characters original input for 1 character\n         *       so there is no amplification and hence recording without\n         *       protection. */\n        accountingDiffTolerated(parser, tok, (char *)&ch,\n                                ((char *)&ch) + sizeof(XML_Char), __LINE__,\n                                XML_ACCOUNT_ENTITY_EXPANSION);\n#endif /* XML_DTD */\n        if (parser->m_characterDataHandler)\n          parser->m_characterDataHandler(parser->m_handlerArg, &ch, 1);\n        else if (parser->m_defaultHandler)\n          reportDefault(parser, enc, s, next);\n        break;\n      }\n      name = poolStoreString(&dtd->pool, enc, s + enc->minBytesPerChar,\n                             next - enc->minBytesPerChar);\n      if (! name)\n        return XML_ERROR_NO_MEMORY;\n      entity = (ENTITY *)lookup(parser, &dtd->generalEntities, name, 0);\n      poolDiscard(&dtd->pool);\n      /* First, determine if a check for an existing declaration is needed;\n         if yes, check that the entity exists, and that it is internal,\n         otherwise call the skipped entity or default handler.\n      */\n      if (! dtd->hasParamEntityRefs || dtd->standalone) {\n        if (! entity)\n          return XML_ERROR_UNDEFINED_ENTITY;\n        else if (! entity->is_internal)\n          return XML_ERROR_ENTITY_DECLARED_IN_PE;\n      } else if (! entity) {\n        if (parser->m_skippedEntityHandler)\n          parser->m_skippedEntityHandler(parser->m_handlerArg, name, 0);\n        else if (parser->m_defaultHandler)\n          reportDefault(parser, enc, s, next);\n        break;\n      }\n      if (entity->open)\n        return XML_ERROR_RECURSIVE_ENTITY_REF;\n      if (entity->notation)\n        return XML_ERROR_BINARY_ENTITY_REF;\n      if (entity->textPtr) {\n        enum XML_Error result;\n        if (! parser->m_defaultExpandInternalEntities) {\n          if (parser->m_skippedEntityHandler)\n            parser->m_skippedEntityHandler(parser->m_handlerArg, entity->name,\n                                           0);\n          else if (parser->m_defaultHandler)\n            reportDefault(parser, enc, s, next);\n          break;\n        }\n        result = processInternalEntity(parser, entity, XML_FALSE);\n        if (result != XML_ERROR_NONE)\n          return result;\n      } else if (parser->m_externalEntityRefHandler) {\n        const XML_Char *context;\n        entity->open = XML_TRUE;\n        context = getContext(parser);\n        entity->open = XML_FALSE;\n        if (! context)\n          return XML_ERROR_NO_MEMORY;\n        if (! parser->m_externalEntityRefHandler(\n                parser->m_externalEntityRefHandlerArg, context, entity->base,\n                entity->systemId, entity->publicId))\n          return XML_ERROR_EXTERNAL_ENTITY_HANDLING;\n        poolDiscard(&parser->m_tempPool);\n      } else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n      break;\n    }\n    case XML_TOK_START_TAG_NO_ATTS:\n      /* fall through */\n    case XML_TOK_START_TAG_WITH_ATTS: {\n      TAG *tag;\n      enum XML_Error result;\n      XML_Char *toPtr;\n      if (parser->m_freeTagList) {\n        tag = parser->m_freeTagList;\n        parser->m_freeTagList = parser->m_freeTagList->parent;\n      } else {\n        tag = (TAG *)MALLOC(parser, sizeof(TAG));\n        if (! tag)\n          return XML_ERROR_NO_MEMORY;\n        tag->buf = (char *)MALLOC(parser, INIT_TAG_BUF_SIZE);\n        if (! tag->buf) {\n          FREE(parser, tag);\n          return XML_ERROR_NO_MEMORY;\n        }\n        tag->bufEnd = tag->buf + INIT_TAG_BUF_SIZE;\n      }\n      tag->bindings = NULL;\n      tag->parent = parser->m_tagStack;\n      parser->m_tagStack = tag;\n      tag->name.localPart = NULL;\n      tag->name.prefix = NULL;\n      tag->rawName = s + enc->minBytesPerChar;\n      tag->rawNameLength = XmlNameLength(enc, tag->rawName);\n      ++parser->m_tagLevel;\n      {\n        const char *rawNameEnd = tag->rawName + tag->rawNameLength;\n        const char *fromPtr = tag->rawName;\n        toPtr = (XML_Char *)tag->buf;\n        for (;;) {\n          int bufSize;\n          int convLen;\n          const enum XML_Convert_Result convert_res\n              = XmlConvert(enc, &fromPtr, rawNameEnd, (ICHAR **)&toPtr,\n                           (ICHAR *)tag->bufEnd - 1);\n          convLen = (int)(toPtr - (XML_Char *)tag->buf);\n          if ((fromPtr >= rawNameEnd)\n              || (convert_res == XML_CONVERT_INPUT_INCOMPLETE)) {\n            tag->name.strLen = convLen;\n            break;\n          }\n          bufSize = (int)(tag->bufEnd - tag->buf) << 1;\n          {\n            char *temp = (char *)REALLOC(parser, tag->buf, bufSize);\n            if (temp == NULL)\n              return XML_ERROR_NO_MEMORY;\n            tag->buf = temp;\n            tag->bufEnd = temp + bufSize;\n            toPtr = (XML_Char *)temp + convLen;\n          }\n        }\n      }\n      tag->name.str = (XML_Char *)tag->buf;\n      *toPtr = XML_T('\\0');\n      result\n          = storeAtts(parser, enc, s, &(tag->name), &(tag->bindings), account);\n      if (result)\n        return result;\n      if (parser->m_startElementHandler)\n        parser->m_startElementHandler(parser->m_handlerArg, tag->name.str,\n                                      (const XML_Char **)parser->m_atts);\n      else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n      poolClear(&parser->m_tempPool);\n      break;\n    }\n    case XML_TOK_EMPTY_ELEMENT_NO_ATTS:\n      /* fall through */\n    case XML_TOK_EMPTY_ELEMENT_WITH_ATTS: {\n      const char *rawName = s + enc->minBytesPerChar;\n      enum XML_Error result;\n      BINDING *bindings = NULL;\n      XML_Bool noElmHandlers = XML_TRUE;\n      TAG_NAME name;\n      name.str = poolStoreString(&parser->m_tempPool, enc, rawName,\n                                 rawName + XmlNameLength(enc, rawName));\n      if (! name.str)\n        return XML_ERROR_NO_MEMORY;\n      poolFinish(&parser->m_tempPool);\n      result = storeAtts(parser, enc, s, &name, &bindings,\n                         XML_ACCOUNT_NONE /* token spans whole start tag */);\n      if (result != XML_ERROR_NONE) {\n        freeBindings(parser, bindings);\n        return result;\n      }\n      poolFinish(&parser->m_tempPool);\n      if (parser->m_startElementHandler) {\n        parser->m_startElementHandler(parser->m_handlerArg, name.str,\n                                      (const XML_Char **)parser->m_atts);\n        noElmHandlers = XML_FALSE;\n      }\n      if (parser->m_endElementHandler) {\n        if (parser->m_startElementHandler)\n          *eventPP = *eventEndPP;\n        parser->m_endElementHandler(parser->m_handlerArg, name.str);\n        noElmHandlers = XML_FALSE;\n      }\n      if (noElmHandlers && parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n      poolClear(&parser->m_tempPool);\n      freeBindings(parser, bindings);\n    }\n      if ((parser->m_tagLevel == 0)\n          && (parser->m_parsingStatus.parsing != XML_FINISHED)) {\n        if (parser->m_parsingStatus.parsing == XML_SUSPENDED)\n          parser->m_processor = epilogProcessor;\n        else\n          return epilogProcessor(parser, next, end, nextPtr);\n      }\n      break;\n    case XML_TOK_END_TAG:\n      if (parser->m_tagLevel == startTagLevel)\n        return XML_ERROR_ASYNC_ENTITY;\n      else {\n        int len;\n        const char *rawName;\n        TAG *tag = parser->m_tagStack;\n        rawName = s + enc->minBytesPerChar * 2;\n        len = XmlNameLength(enc, rawName);\n        if (len != tag->rawNameLength\n            || memcmp(tag->rawName, rawName, len) != 0) {\n          *eventPP = rawName;\n          return XML_ERROR_TAG_MISMATCH;\n        }\n        parser->m_tagStack = tag->parent;\n        tag->parent = parser->m_freeTagList;\n        parser->m_freeTagList = tag;\n        --parser->m_tagLevel;\n        if (parser->m_endElementHandler) {\n          const XML_Char *localPart;\n          const XML_Char *prefix;\n          XML_Char *uri;\n          localPart = tag->name.localPart;\n          if (parser->m_ns && localPart) {\n            /* localPart and prefix may have been overwritten in\n               tag->name.str, since this points to the binding->uri\n               buffer which gets reused; so we have to add them again\n            */\n            uri = (XML_Char *)tag->name.str + tag->name.uriLen;\n            /* don't need to check for space - already done in storeAtts() */\n            while (*localPart)\n              *uri++ = *localPart++;\n            prefix = tag->name.prefix;\n            if (parser->m_ns_triplets && prefix) {\n              *uri++ = parser->m_namespaceSeparator;\n              while (*prefix)\n                *uri++ = *prefix++;\n            }\n            *uri = XML_T('\\0');\n          }\n          parser->m_endElementHandler(parser->m_handlerArg, tag->name.str);\n        } else if (parser->m_defaultHandler)\n          reportDefault(parser, enc, s, next);\n        while (tag->bindings) {\n          BINDING *b = tag->bindings;\n          if (parser->m_endNamespaceDeclHandler)\n            parser->m_endNamespaceDeclHandler(parser->m_handlerArg,\n                                              b->prefix->name);\n          tag->bindings = tag->bindings->nextTagBinding;\n          b->nextTagBinding = parser->m_freeBindingList;\n          parser->m_freeBindingList = b;\n          b->prefix->binding = b->prevPrefixBinding;\n        }\n        if ((parser->m_tagLevel == 0)\n            && (parser->m_parsingStatus.parsing != XML_FINISHED)) {\n          if (parser->m_parsingStatus.parsing == XML_SUSPENDED)\n            parser->m_processor = epilogProcessor;\n          else\n            return epilogProcessor(parser, next, end, nextPtr);\n        }\n      }\n      break;\n    case XML_TOK_CHAR_REF: {\n      int n = XmlCharRefNumber(enc, s);\n      if (n < 0)\n        return XML_ERROR_BAD_CHAR_REF;\n      if (parser->m_characterDataHandler) {\n        XML_Char buf[XML_ENCODE_MAX];\n        parser->m_characterDataHandler(parser->m_handlerArg, buf,\n                                       XmlEncode(n, (ICHAR *)buf));\n      } else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n    } break;\n    case XML_TOK_XML_DECL:\n      return XML_ERROR_MISPLACED_XML_PI;\n    case XML_TOK_DATA_NEWLINE:\n      if (parser->m_characterDataHandler) {\n        XML_Char c = 0xA;\n        parser->m_characterDataHandler(parser->m_handlerArg, &c, 1);\n      } else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n      break;\n    case XML_TOK_CDATA_SECT_OPEN: {\n      enum XML_Error result;\n      if (parser->m_startCdataSectionHandler)\n        parser->m_startCdataSectionHandler(parser->m_handlerArg);\n      /* BEGIN disabled code */\n      /* Suppose you doing a transformation on a document that involves\n         changing only the character data.  You set up a defaultHandler\n         and a characterDataHandler.  The defaultHandler simply copies\n         characters through.  The characterDataHandler does the\n         transformation and writes the characters out escaping them as\n         necessary.  This case will fail to work if we leave out the\n         following two lines (because & and < inside CDATA sections will\n         be incorrectly escaped).\n\n         However, now we have a start/endCdataSectionHandler, so it seems\n         easier to let the user deal with this.\n      */\n      else if ((0) && parser->m_characterDataHandler)\n        parser->m_characterDataHandler(parser->m_handlerArg, parser->m_dataBuf,\n                                       0);\n      /* END disabled code */\n      else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n      result\n          = doCdataSection(parser, enc, &next, end, nextPtr, haveMore, account);\n      if (result != XML_ERROR_NONE)\n        return result;\n      else if (! next) {\n        parser->m_processor = cdataSectionProcessor;\n        return result;\n      }\n    } break;\n    case XML_TOK_TRAILING_RSQB:\n      if (haveMore) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      if (parser->m_characterDataHandler) {\n        if (MUST_CONVERT(enc, s)) {\n          ICHAR *dataPtr = (ICHAR *)parser->m_dataBuf;\n          XmlConvert(enc, &s, end, &dataPtr, (ICHAR *)parser->m_dataBufEnd);\n          parser->m_characterDataHandler(\n              parser->m_handlerArg, parser->m_dataBuf,\n              (int)(dataPtr - (ICHAR *)parser->m_dataBuf));\n        } else\n          parser->m_characterDataHandler(\n              parser->m_handlerArg, (const XML_Char *)s,\n              (int)((const XML_Char *)end - (const XML_Char *)s));\n      } else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, end);\n      /* We are at the end of the final buffer, should we check for\n         XML_SUSPENDED, XML_FINISHED?\n      */\n      if (startTagLevel == 0) {\n        *eventPP = end;\n        return XML_ERROR_NO_ELEMENTS;\n      }\n      if (parser->m_tagLevel != startTagLevel) {\n        *eventPP = end;\n        return XML_ERROR_ASYNC_ENTITY;\n      }\n      *nextPtr = end;\n      return XML_ERROR_NONE;\n    case XML_TOK_DATA_CHARS: {\n      XML_CharacterDataHandler charDataHandler = parser->m_characterDataHandler;\n      if (charDataHandler) {\n        if (MUST_CONVERT(enc, s)) {\n          for (;;) {\n            ICHAR *dataPtr = (ICHAR *)parser->m_dataBuf;\n            const enum XML_Convert_Result convert_res = XmlConvert(\n                enc, &s, next, &dataPtr, (ICHAR *)parser->m_dataBufEnd);\n            *eventEndPP = s;\n            charDataHandler(parser->m_handlerArg, parser->m_dataBuf,\n                            (int)(dataPtr - (ICHAR *)parser->m_dataBuf));\n            if ((convert_res == XML_CONVERT_COMPLETED)\n                || (convert_res == XML_CONVERT_INPUT_INCOMPLETE))\n              break;\n            *eventPP = s;\n          }\n        } else\n          charDataHandler(parser->m_handlerArg, (const XML_Char *)s,\n                          (int)((const XML_Char *)next - (const XML_Char *)s));\n      } else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n    } break;\n    case XML_TOK_PI:\n      if (! reportProcessingInstruction(parser, enc, s, next))\n        return XML_ERROR_NO_MEMORY;\n      break;\n    case XML_TOK_COMMENT:\n      if (! reportComment(parser, enc, s, next))\n        return XML_ERROR_NO_MEMORY;\n      break;\n    default:\n      /* All of the tokens produced by XmlContentTok() have their own\n       * explicit cases, so this default is not strictly necessary.\n       * However it is a useful safety net, so we retain the code and\n       * simply exclude it from the coverage tests.\n       *\n       * LCOV_EXCL_START\n       */\n      if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n      break;\n      /* LCOV_EXCL_STOP */\n    }\n    *eventPP = s = next;\n    switch (parser->m_parsingStatus.parsing) {\n    case XML_SUSPENDED:\n      *nextPtr = next;\n      return XML_ERROR_NONE;\n    case XML_FINISHED:\n      return XML_ERROR_ABORTED;\n    default:;\n    }\n  }\n  /* not reached */\n}\n\n/* This function does not call free() on the allocated memory, merely\n * moving it to the parser's m_freeBindingList where it can be freed or\n * reused as appropriate.\n */\nstatic void\nfreeBindings(XML_Parser parser, BINDING *bindings) {\n  while (bindings) {\n    BINDING *b = bindings;\n\n    /* m_startNamespaceDeclHandler will have been called for this\n     * binding in addBindings(), so call the end handler now.\n     */\n    if (parser->m_endNamespaceDeclHandler)\n      parser->m_endNamespaceDeclHandler(parser->m_handlerArg, b->prefix->name);\n\n    bindings = bindings->nextTagBinding;\n    b->nextTagBinding = parser->m_freeBindingList;\n    parser->m_freeBindingList = b;\n    b->prefix->binding = b->prevPrefixBinding;\n  }\n}\n\n/* Precondition: all arguments must be non-NULL;\n   Purpose:\n   - normalize attributes\n   - check attributes for well-formedness\n   - generate namespace aware attribute names (URI, prefix)\n   - build list of attributes for startElementHandler\n   - default attributes\n   - process namespace declarations (check and report them)\n   - generate namespace aware element name (URI, prefix)\n*/\nstatic enum XML_Error\nstoreAtts(XML_Parser parser, const ENCODING *enc, const char *attStr,\n          TAG_NAME *tagNamePtr, BINDING **bindingsPtr,\n          enum XML_Account account) {\n  DTD *const dtd = parser->m_dtd; /* save one level of indirection */\n  ELEMENT_TYPE *elementType;\n  int nDefaultAtts;\n  const XML_Char **appAtts; /* the attribute list for the application */\n  int attIndex = 0;\n  int prefixLen;\n  int i;\n  int n;\n  XML_Char *uri;\n  int nPrefixes = 0;\n  BINDING *binding;\n  const XML_Char *localPart;\n\n  /* lookup the element type name */\n  elementType\n      = (ELEMENT_TYPE *)lookup(parser, &dtd->elementTypes, tagNamePtr->str, 0);\n  if (! elementType) {\n    const XML_Char *name = poolCopyString(&dtd->pool, tagNamePtr->str);\n    if (! name)\n      return XML_ERROR_NO_MEMORY;\n    elementType = (ELEMENT_TYPE *)lookup(parser, &dtd->elementTypes, name,\n                                         sizeof(ELEMENT_TYPE));\n    if (! elementType)\n      return XML_ERROR_NO_MEMORY;\n    if (parser->m_ns && ! setElementTypePrefix(parser, elementType))\n      return XML_ERROR_NO_MEMORY;\n  }\n  nDefaultAtts = elementType->nDefaultAtts;\n\n  /* get the attributes from the tokenizer */\n  n = XmlGetAttributes(enc, attStr, parser->m_attsSize, parser->m_atts);\n\n  /* Detect and prevent integer overflow */\n  if (n > INT_MAX - nDefaultAtts) {\n    return XML_ERROR_NO_MEMORY;\n  }\n\n  if (n + nDefaultAtts > parser->m_attsSize) {\n    int oldAttsSize = parser->m_attsSize;\n    ATTRIBUTE *temp;\n#ifdef XML_ATTR_INFO\n    XML_AttrInfo *temp2;\n#endif\n\n    /* Detect and prevent integer overflow */\n    if ((nDefaultAtts > INT_MAX - INIT_ATTS_SIZE)\n        || (n > INT_MAX - (nDefaultAtts + INIT_ATTS_SIZE))) {\n      return XML_ERROR_NO_MEMORY;\n    }\n\n    parser->m_attsSize = n + nDefaultAtts + INIT_ATTS_SIZE;\n\n    /* Detect and prevent integer overflow.\n     * The preprocessor guard addresses the \"always false\" warning\n     * from -Wtype-limits on platforms where\n     * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */\n#if UINT_MAX >= SIZE_MAX\n    if ((unsigned)parser->m_attsSize > (size_t)(-1) / sizeof(ATTRIBUTE)) {\n      parser->m_attsSize = oldAttsSize;\n      return XML_ERROR_NO_MEMORY;\n    }\n#endif\n\n    temp = (ATTRIBUTE *)REALLOC(parser, (void *)parser->m_atts,\n                                parser->m_attsSize * sizeof(ATTRIBUTE));\n    if (temp == NULL) {\n      parser->m_attsSize = oldAttsSize;\n      return XML_ERROR_NO_MEMORY;\n    }\n    parser->m_atts = temp;\n#ifdef XML_ATTR_INFO\n    /* Detect and prevent integer overflow.\n     * The preprocessor guard addresses the \"always false\" warning\n     * from -Wtype-limits on platforms where\n     * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */\n#  if UINT_MAX >= SIZE_MAX\n    if ((unsigned)parser->m_attsSize > (size_t)(-1) / sizeof(XML_AttrInfo)) {\n      parser->m_attsSize = oldAttsSize;\n      return XML_ERROR_NO_MEMORY;\n    }\n#  endif\n\n    temp2 = (XML_AttrInfo *)REALLOC(parser, (void *)parser->m_attInfo,\n                                    parser->m_attsSize * sizeof(XML_AttrInfo));\n    if (temp2 == NULL) {\n      parser->m_attsSize = oldAttsSize;\n      return XML_ERROR_NO_MEMORY;\n    }\n    parser->m_attInfo = temp2;\n#endif\n    if (n > oldAttsSize)\n      XmlGetAttributes(enc, attStr, n, parser->m_atts);\n  }\n\n  appAtts = (const XML_Char **)parser->m_atts;\n  for (i = 0; i < n; i++) {\n    ATTRIBUTE *currAtt = &parser->m_atts[i];\n#ifdef XML_ATTR_INFO\n    XML_AttrInfo *currAttInfo = &parser->m_attInfo[i];\n#endif\n    /* add the name and value to the attribute list */\n    ATTRIBUTE_ID *attId\n        = getAttributeId(parser, enc, currAtt->name,\n                         currAtt->name + XmlNameLength(enc, currAtt->name));\n    if (! attId)\n      return XML_ERROR_NO_MEMORY;\n#ifdef XML_ATTR_INFO\n    currAttInfo->nameStart\n        = parser->m_parseEndByteIndex - (parser->m_parseEndPtr - currAtt->name);\n    currAttInfo->nameEnd\n        = currAttInfo->nameStart + XmlNameLength(enc, currAtt->name);\n    currAttInfo->valueStart = parser->m_parseEndByteIndex\n                              - (parser->m_parseEndPtr - currAtt->valuePtr);\n    currAttInfo->valueEnd = parser->m_parseEndByteIndex\n                            - (parser->m_parseEndPtr - currAtt->valueEnd);\n#endif\n    /* Detect duplicate attributes by their QNames. This does not work when\n       namespace processing is turned on and different prefixes for the same\n       namespace are used. For this case we have a check further down.\n    */\n    if ((attId->name)[-1]) {\n      if (enc == parser->m_encoding)\n        parser->m_eventPtr = parser->m_atts[i].name;\n      return XML_ERROR_DUPLICATE_ATTRIBUTE;\n    }\n    (attId->name)[-1] = 1;\n    appAtts[attIndex++] = attId->name;\n    if (! parser->m_atts[i].normalized) {\n      enum XML_Error result;\n      XML_Bool isCdata = XML_TRUE;\n\n      /* figure out whether declared as other than CDATA */\n      if (attId->maybeTokenized) {\n        int j;\n        for (j = 0; j < nDefaultAtts; j++) {\n          if (attId == elementType->defaultAtts[j].id) {\n            isCdata = elementType->defaultAtts[j].isCdata;\n            break;\n          }\n        }\n      }\n\n      /* normalize the attribute value */\n      result = storeAttributeValue(\n          parser, enc, isCdata, parser->m_atts[i].valuePtr,\n          parser->m_atts[i].valueEnd, &parser->m_tempPool, account);\n      if (result)\n        return result;\n      appAtts[attIndex] = poolStart(&parser->m_tempPool);\n      poolFinish(&parser->m_tempPool);\n    } else {\n      /* the value did not need normalizing */\n      appAtts[attIndex] = poolStoreString(&parser->m_tempPool, enc,\n                                          parser->m_atts[i].valuePtr,\n                                          parser->m_atts[i].valueEnd);\n      if (appAtts[attIndex] == 0)\n        return XML_ERROR_NO_MEMORY;\n      poolFinish(&parser->m_tempPool);\n    }\n    /* handle prefixed attribute names */\n    if (attId->prefix) {\n      if (attId->xmlns) {\n        /* deal with namespace declarations here */\n        enum XML_Error result = addBinding(parser, attId->prefix, attId,\n                                           appAtts[attIndex], bindingsPtr);\n        if (result)\n          return result;\n        --attIndex;\n      } else {\n        /* deal with other prefixed names later */\n        attIndex++;\n        nPrefixes++;\n        (attId->name)[-1] = 2;\n      }\n    } else\n      attIndex++;\n  }\n\n  /* set-up for XML_GetSpecifiedAttributeCount and XML_GetIdAttributeIndex */\n  parser->m_nSpecifiedAtts = attIndex;\n  if (elementType->idAtt && (elementType->idAtt->name)[-1]) {\n    for (i = 0; i < attIndex; i += 2)\n      if (appAtts[i] == elementType->idAtt->name) {\n        parser->m_idAttIndex = i;\n        break;\n      }\n  } else\n    parser->m_idAttIndex = -1;\n\n  /* do attribute defaulting */\n  for (i = 0; i < nDefaultAtts; i++) {\n    const DEFAULT_ATTRIBUTE *da = elementType->defaultAtts + i;\n    if (! (da->id->name)[-1] && da->value) {\n      if (da->id->prefix) {\n        if (da->id->xmlns) {\n          enum XML_Error result = addBinding(parser, da->id->prefix, da->id,\n                                             da->value, bindingsPtr);\n          if (result)\n            return result;\n        } else {\n          (da->id->name)[-1] = 2;\n          nPrefixes++;\n          appAtts[attIndex++] = da->id->name;\n          appAtts[attIndex++] = da->value;\n        }\n      } else {\n        (da->id->name)[-1] = 1;\n        appAtts[attIndex++] = da->id->name;\n        appAtts[attIndex++] = da->value;\n      }\n    }\n  }\n  appAtts[attIndex] = 0;\n\n  /* expand prefixed attribute names, check for duplicates,\n     and clear flags that say whether attributes were specified */\n  i = 0;\n  if (nPrefixes) {\n    int j; /* hash table index */\n    unsigned long version = parser->m_nsAttsVersion;\n\n    /* Detect and prevent invalid shift */\n    if (parser->m_nsAttsPower >= sizeof(unsigned int) * 8 /* bits per byte */) {\n      return XML_ERROR_NO_MEMORY;\n    }\n\n    unsigned int nsAttsSize = 1u << parser->m_nsAttsPower;\n    unsigned char oldNsAttsPower = parser->m_nsAttsPower;\n    /* size of hash table must be at least 2 * (# of prefixed attributes) */\n    if ((nPrefixes << 1)\n        >> parser->m_nsAttsPower) { /* true for m_nsAttsPower = 0 */\n      NS_ATT *temp;\n      /* hash table size must also be a power of 2 and >= 8 */\n      while (nPrefixes >> parser->m_nsAttsPower++)\n        ;\n      if (parser->m_nsAttsPower < 3)\n        parser->m_nsAttsPower = 3;\n\n      /* Detect and prevent invalid shift */\n      if (parser->m_nsAttsPower >= sizeof(nsAttsSize) * 8 /* bits per byte */) {\n        /* Restore actual size of memory in m_nsAtts */\n        parser->m_nsAttsPower = oldNsAttsPower;\n        return XML_ERROR_NO_MEMORY;\n      }\n\n      nsAttsSize = 1u << parser->m_nsAttsPower;\n\n      /* Detect and prevent integer overflow.\n       * The preprocessor guard addresses the \"always false\" warning\n       * from -Wtype-limits on platforms where\n       * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */\n#if UINT_MAX >= SIZE_MAX\n      if (nsAttsSize > (size_t)(-1) / sizeof(NS_ATT)) {\n        /* Restore actual size of memory in m_nsAtts */\n        parser->m_nsAttsPower = oldNsAttsPower;\n        return XML_ERROR_NO_MEMORY;\n      }\n#endif\n\n      temp = (NS_ATT *)REALLOC(parser, parser->m_nsAtts,\n                               nsAttsSize * sizeof(NS_ATT));\n      if (! temp) {\n        /* Restore actual size of memory in m_nsAtts */\n        parser->m_nsAttsPower = oldNsAttsPower;\n        return XML_ERROR_NO_MEMORY;\n      }\n      parser->m_nsAtts = temp;\n      version = 0; /* force re-initialization of m_nsAtts hash table */\n    }\n    /* using a version flag saves us from initializing m_nsAtts every time */\n    if (! version) { /* initialize version flags when version wraps around */\n      version = INIT_ATTS_VERSION;\n      for (j = nsAttsSize; j != 0;)\n        parser->m_nsAtts[--j].version = version;\n    }\n    parser->m_nsAttsVersion = --version;\n\n    /* expand prefixed names and check for duplicates */\n    for (; i < attIndex; i += 2) {\n      const XML_Char *s = appAtts[i];\n      if (s[-1] == 2) { /* prefixed */\n        ATTRIBUTE_ID *id;\n        const BINDING *b;\n        unsigned long uriHash;\n        struct siphash sip_state;\n        struct sipkey sip_key;\n\n        copy_salt_to_sipkey(parser, &sip_key);\n        sip24_init(&sip_state, &sip_key);\n\n        ((XML_Char *)s)[-1] = 0; /* clear flag */\n        id = (ATTRIBUTE_ID *)lookup(parser, &dtd->attributeIds, s, 0);\n        if (! id || ! id->prefix) {\n          /* This code is walking through the appAtts array, dealing\n           * with (in this case) a prefixed attribute name.  To be in\n           * the array, the attribute must have already been bound, so\n           * has to have passed through the hash table lookup once\n           * already.  That implies that an entry for it already\n           * exists, so the lookup above will return a pointer to\n           * already allocated memory.  There is no opportunaity for\n           * the allocator to fail, so the condition above cannot be\n           * fulfilled.\n           *\n           * Since it is difficult to be certain that the above\n           * analysis is complete, we retain the test and merely\n           * remove the code from coverage tests.\n           */\n          return XML_ERROR_NO_MEMORY; /* LCOV_EXCL_LINE */\n        }\n        b = id->prefix->binding;\n        if (! b)\n          return XML_ERROR_UNBOUND_PREFIX;\n\n        for (j = 0; j < b->uriLen; j++) {\n          const XML_Char c = b->uri[j];\n          if (! poolAppendChar(&parser->m_tempPool, c))\n            return XML_ERROR_NO_MEMORY;\n        }\n\n        sip24_update(&sip_state, b->uri, b->uriLen * sizeof(XML_Char));\n\n        while (*s++ != XML_T(ASCII_COLON))\n          ;\n\n        sip24_update(&sip_state, s, keylen(s) * sizeof(XML_Char));\n\n        do { /* copies null terminator */\n          if (! poolAppendChar(&parser->m_tempPool, *s))\n            return XML_ERROR_NO_MEMORY;\n        } while (*s++);\n\n        uriHash = (unsigned long)sip24_final(&sip_state);\n\n        { /* Check hash table for duplicate of expanded name (uriName).\n             Derived from code in lookup(parser, HASH_TABLE *table, ...).\n          */\n          unsigned char step = 0;\n          unsigned long mask = nsAttsSize - 1;\n          j = uriHash & mask; /* index into hash table */\n          while (parser->m_nsAtts[j].version == version) {\n            /* for speed we compare stored hash values first */\n            if (uriHash == parser->m_nsAtts[j].hash) {\n              const XML_Char *s1 = poolStart(&parser->m_tempPool);\n              const XML_Char *s2 = parser->m_nsAtts[j].uriName;\n              /* s1 is null terminated, but not s2 */\n              for (; *s1 == *s2 && *s1 != 0; s1++, s2++)\n                ;\n              if (*s1 == 0)\n                return XML_ERROR_DUPLICATE_ATTRIBUTE;\n            }\n            if (! step)\n              step = PROBE_STEP(uriHash, mask, parser->m_nsAttsPower);\n            j < step ? (j += nsAttsSize - step) : (j -= step);\n          }\n        }\n\n        if (parser->m_ns_triplets) { /* append namespace separator and prefix */\n          parser->m_tempPool.ptr[-1] = parser->m_namespaceSeparator;\n          s = b->prefix->name;\n          do {\n            if (! poolAppendChar(&parser->m_tempPool, *s))\n              return XML_ERROR_NO_MEMORY;\n          } while (*s++);\n        }\n\n        /* store expanded name in attribute list */\n        s = poolStart(&parser->m_tempPool);\n        poolFinish(&parser->m_tempPool);\n        appAtts[i] = s;\n\n        /* fill empty slot with new version, uriName and hash value */\n        parser->m_nsAtts[j].version = version;\n        parser->m_nsAtts[j].hash = uriHash;\n        parser->m_nsAtts[j].uriName = s;\n\n        if (! --nPrefixes) {\n          i += 2;\n          break;\n        }\n      } else                     /* not prefixed */\n        ((XML_Char *)s)[-1] = 0; /* clear flag */\n    }\n  }\n  /* clear flags for the remaining attributes */\n  for (; i < attIndex; i += 2)\n    ((XML_Char *)(appAtts[i]))[-1] = 0;\n  for (binding = *bindingsPtr; binding; binding = binding->nextTagBinding)\n    binding->attId->name[-1] = 0;\n\n  if (! parser->m_ns)\n    return XML_ERROR_NONE;\n\n  /* expand the element type name */\n  if (elementType->prefix) {\n    binding = elementType->prefix->binding;\n    if (! binding)\n      return XML_ERROR_UNBOUND_PREFIX;\n    localPart = tagNamePtr->str;\n    while (*localPart++ != XML_T(ASCII_COLON))\n      ;\n  } else if (dtd->defaultPrefix.binding) {\n    binding = dtd->defaultPrefix.binding;\n    localPart = tagNamePtr->str;\n  } else\n    return XML_ERROR_NONE;\n  prefixLen = 0;\n  if (parser->m_ns_triplets && binding->prefix->name) {\n    for (; binding->prefix->name[prefixLen++];)\n      ; /* prefixLen includes null terminator */\n  }\n  tagNamePtr->localPart = localPart;\n  tagNamePtr->uriLen = binding->uriLen;\n  tagNamePtr->prefix = binding->prefix->name;\n  tagNamePtr->prefixLen = prefixLen;\n  for (i = 0; localPart[i++];)\n    ; /* i includes null terminator */\n\n  /* Detect and prevent integer overflow */\n  if (binding->uriLen > INT_MAX - prefixLen\n      || i > INT_MAX - (binding->uriLen + prefixLen)) {\n    return XML_ERROR_NO_MEMORY;\n  }\n\n  n = i + binding->uriLen + prefixLen;\n  if (n > binding->uriAlloc) {\n    TAG *p;\n\n    /* Detect and prevent integer overflow */\n    if (n > INT_MAX - EXPAND_SPARE) {\n      return XML_ERROR_NO_MEMORY;\n    }\n    /* Detect and prevent integer overflow.\n     * The preprocessor guard addresses the \"always false\" warning\n     * from -Wtype-limits on platforms where\n     * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */\n#if UINT_MAX >= SIZE_MAX\n    if ((unsigned)(n + EXPAND_SPARE) > (size_t)(-1) / sizeof(XML_Char)) {\n      return XML_ERROR_NO_MEMORY;\n    }\n#endif\n\n    uri = (XML_Char *)MALLOC(parser, (n + EXPAND_SPARE) * sizeof(XML_Char));\n    if (! uri)\n      return XML_ERROR_NO_MEMORY;\n    binding->uriAlloc = n + EXPAND_SPARE;\n    memcpy(uri, binding->uri, binding->uriLen * sizeof(XML_Char));\n    for (p = parser->m_tagStack; p; p = p->parent)\n      if (p->name.str == binding->uri)\n        p->name.str = uri;\n    FREE(parser, binding->uri);\n    binding->uri = uri;\n  }\n  /* if m_namespaceSeparator != '\\0' then uri includes it already */\n  uri = binding->uri + binding->uriLen;\n  memcpy(uri, localPart, i * sizeof(XML_Char));\n  /* we always have a namespace separator between localPart and prefix */\n  if (prefixLen) {\n    uri += i - 1;\n    *uri = parser->m_namespaceSeparator; /* replace null terminator */\n    memcpy(uri + 1, binding->prefix->name, prefixLen * sizeof(XML_Char));\n  }\n  tagNamePtr->str = binding->uri;\n  return XML_ERROR_NONE;\n}\n\nstatic XML_Bool\nis_rfc3986_uri_char(XML_Char candidate) {\n  // For the RFC 3986 ANBF grammar see\n  // https://datatracker.ietf.org/doc/html/rfc3986#appendix-A\n\n  switch (candidate) {\n  // From rule \"ALPHA\" (uppercase half)\n  case 'A':\n  case 'B':\n  case 'C':\n  case 'D':\n  case 'E':\n  case 'F':\n  case 'G':\n  case 'H':\n  case 'I':\n  case 'J':\n  case 'K':\n  case 'L':\n  case 'M':\n  case 'N':\n  case 'O':\n  case 'P':\n  case 'Q':\n  case 'R':\n  case 'S':\n  case 'T':\n  case 'U':\n  case 'V':\n  case 'W':\n  case 'X':\n  case 'Y':\n  case 'Z':\n\n  // From rule \"ALPHA\" (lowercase half)\n  case 'a':\n  case 'b':\n  case 'c':\n  case 'd':\n  case 'e':\n  case 'f':\n  case 'g':\n  case 'h':\n  case 'i':\n  case 'j':\n  case 'k':\n  case 'l':\n  case 'm':\n  case 'n':\n  case 'o':\n  case 'p':\n  case 'q':\n  case 'r':\n  case 's':\n  case 't':\n  case 'u':\n  case 'v':\n  case 'w':\n  case 'x':\n  case 'y':\n  case 'z':\n\n  // From rule \"DIGIT\"\n  case '0':\n  case '1':\n  case '2':\n  case '3':\n  case '4':\n  case '5':\n  case '6':\n  case '7':\n  case '8':\n  case '9':\n\n  // From rule \"pct-encoded\"\n  case '%':\n\n  // From rule \"unreserved\"\n  case '-':\n  case '.':\n  case '_':\n  case '~':\n\n  // From rule \"gen-delims\"\n  case ':':\n  case '/':\n  case '?':\n  case '#':\n  case '[':\n  case ']':\n  case '@':\n\n  // From rule \"sub-delims\"\n  case '!':\n  case '$':\n  case '&':\n  case '\\'':\n  case '(':\n  case ')':\n  case '*':\n  case '+':\n  case ',':\n  case ';':\n  case '=':\n    return XML_TRUE;\n\n  default:\n    return XML_FALSE;\n  }\n}\n\n/* addBinding() overwrites the value of prefix->binding without checking.\n   Therefore one must keep track of the old value outside of addBinding().\n*/\nstatic enum XML_Error\naddBinding(XML_Parser parser, PREFIX *prefix, const ATTRIBUTE_ID *attId,\n           const XML_Char *uri, BINDING **bindingsPtr) {\n  // \"http://www.w3.org/XML/1998/namespace\"\n  static const XML_Char xmlNamespace[]\n      = {ASCII_h,      ASCII_t,     ASCII_t,     ASCII_p,      ASCII_COLON,\n         ASCII_SLASH,  ASCII_SLASH, ASCII_w,     ASCII_w,      ASCII_w,\n         ASCII_PERIOD, ASCII_w,     ASCII_3,     ASCII_PERIOD, ASCII_o,\n         ASCII_r,      ASCII_g,     ASCII_SLASH, ASCII_X,      ASCII_M,\n         ASCII_L,      ASCII_SLASH, ASCII_1,     ASCII_9,      ASCII_9,\n         ASCII_8,      ASCII_SLASH, ASCII_n,     ASCII_a,      ASCII_m,\n         ASCII_e,      ASCII_s,     ASCII_p,     ASCII_a,      ASCII_c,\n         ASCII_e,      '\\0'};\n  static const int xmlLen = (int)sizeof(xmlNamespace) / sizeof(XML_Char) - 1;\n  // \"http://www.w3.org/2000/xmlns/\"\n  static const XML_Char xmlnsNamespace[]\n      = {ASCII_h,     ASCII_t,      ASCII_t, ASCII_p, ASCII_COLON,  ASCII_SLASH,\n         ASCII_SLASH, ASCII_w,      ASCII_w, ASCII_w, ASCII_PERIOD, ASCII_w,\n         ASCII_3,     ASCII_PERIOD, ASCII_o, ASCII_r, ASCII_g,      ASCII_SLASH,\n         ASCII_2,     ASCII_0,      ASCII_0, ASCII_0, ASCII_SLASH,  ASCII_x,\n         ASCII_m,     ASCII_l,      ASCII_n, ASCII_s, ASCII_SLASH,  '\\0'};\n  static const int xmlnsLen\n      = (int)sizeof(xmlnsNamespace) / sizeof(XML_Char) - 1;\n\n  XML_Bool mustBeXML = XML_FALSE;\n  XML_Bool isXML = XML_TRUE;\n  XML_Bool isXMLNS = XML_TRUE;\n\n  BINDING *b;\n  int len;\n\n  /* empty URI is only valid for default namespace per XML NS 1.0 (not 1.1) */\n  if (*uri == XML_T('\\0') && prefix->name)\n    return XML_ERROR_UNDECLARING_PREFIX;\n\n  if (prefix->name && prefix->name[0] == XML_T(ASCII_x)\n      && prefix->name[1] == XML_T(ASCII_m)\n      && prefix->name[2] == XML_T(ASCII_l)) {\n    /* Not allowed to bind xmlns */\n    if (prefix->name[3] == XML_T(ASCII_n) && prefix->name[4] == XML_T(ASCII_s)\n        && prefix->name[5] == XML_T('\\0'))\n      return XML_ERROR_RESERVED_PREFIX_XMLNS;\n\n    if (prefix->name[3] == XML_T('\\0'))\n      mustBeXML = XML_TRUE;\n  }\n\n  for (len = 0; uri[len]; len++) {\n    if (isXML && (len > xmlLen || uri[len] != xmlNamespace[len]))\n      isXML = XML_FALSE;\n\n    if (! mustBeXML && isXMLNS\n        && (len > xmlnsLen || uri[len] != xmlnsNamespace[len]))\n      isXMLNS = XML_FALSE;\n\n    // NOTE: While Expat does not validate namespace URIs against RFC 3986\n    //       today (and is not REQUIRED to do so with regard to the XML 1.0\n    //       namespaces specification) we have to at least make sure, that\n    //       the application on top of Expat (that is likely splitting expanded\n    //       element names (\"qualified names\") of form\n    //       \"[uri sep] local [sep prefix] '\\0'\" back into 1, 2 or 3 pieces\n    //       in its element handler code) cannot be confused by an attacker\n    //       putting additional namespace separator characters into namespace\n    //       declarations.  That would be ambiguous and not to be expected.\n    //\n    //       While the HTML API docs of function XML_ParserCreateNS have been\n    //       advising against use of a namespace separator character that can\n    //       appear in a URI for >20 years now, some widespread applications\n    //       are using URI characters (':' (colon) in particular) for a\n    //       namespace separator, in practice.  To keep these applications\n    //       functional, we only reject namespaces URIs containing the\n    //       application-chosen namespace separator if the chosen separator\n    //       is a non-URI character with regard to RFC 3986.\n    if (parser->m_ns && (uri[len] == parser->m_namespaceSeparator)\n        && ! is_rfc3986_uri_char(uri[len])) {\n      return XML_ERROR_SYNTAX;\n    }\n  }\n  isXML = isXML && len == xmlLen;\n  isXMLNS = isXMLNS && len == xmlnsLen;\n\n  if (mustBeXML != isXML)\n    return mustBeXML ? XML_ERROR_RESERVED_PREFIX_XML\n                     : XML_ERROR_RESERVED_NAMESPACE_URI;\n\n  if (isXMLNS)\n    return XML_ERROR_RESERVED_NAMESPACE_URI;\n\n  if (parser->m_namespaceSeparator)\n    len++;\n  if (parser->m_freeBindingList) {\n    b = parser->m_freeBindingList;\n    if (len > b->uriAlloc) {\n      /* Detect and prevent integer overflow */\n      if (len > INT_MAX - EXPAND_SPARE) {\n        return XML_ERROR_NO_MEMORY;\n      }\n\n      /* Detect and prevent integer overflow.\n       * The preprocessor guard addresses the \"always false\" warning\n       * from -Wtype-limits on platforms where\n       * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */\n#if UINT_MAX >= SIZE_MAX\n      if ((unsigned)(len + EXPAND_SPARE) > (size_t)(-1) / sizeof(XML_Char)) {\n        return XML_ERROR_NO_MEMORY;\n      }\n#endif\n\n      XML_Char *temp = (XML_Char *)REALLOC(\n          parser, b->uri, sizeof(XML_Char) * (len + EXPAND_SPARE));\n      if (temp == NULL)\n        return XML_ERROR_NO_MEMORY;\n      b->uri = temp;\n      b->uriAlloc = len + EXPAND_SPARE;\n    }\n    parser->m_freeBindingList = b->nextTagBinding;\n  } else {\n    b = (BINDING *)MALLOC(parser, sizeof(BINDING));\n    if (! b)\n      return XML_ERROR_NO_MEMORY;\n\n    /* Detect and prevent integer overflow */\n    if (len > INT_MAX - EXPAND_SPARE) {\n      return XML_ERROR_NO_MEMORY;\n    }\n    /* Detect and prevent integer overflow.\n     * The preprocessor guard addresses the \"always false\" warning\n     * from -Wtype-limits on platforms where\n     * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */\n#if UINT_MAX >= SIZE_MAX\n    if ((unsigned)(len + EXPAND_SPARE) > (size_t)(-1) / sizeof(XML_Char)) {\n      return XML_ERROR_NO_MEMORY;\n    }\n#endif\n\n    b->uri\n        = (XML_Char *)MALLOC(parser, sizeof(XML_Char) * (len + EXPAND_SPARE));\n    if (! b->uri) {\n      FREE(parser, b);\n      return XML_ERROR_NO_MEMORY;\n    }\n    b->uriAlloc = len + EXPAND_SPARE;\n  }\n  b->uriLen = len;\n  memcpy(b->uri, uri, len * sizeof(XML_Char));\n  if (parser->m_namespaceSeparator)\n    b->uri[len - 1] = parser->m_namespaceSeparator;\n  b->prefix = prefix;\n  b->attId = attId;\n  b->prevPrefixBinding = prefix->binding;\n  /* NULL binding when default namespace undeclared */\n  if (*uri == XML_T('\\0') && prefix == &parser->m_dtd->defaultPrefix)\n    prefix->binding = NULL;\n  else\n    prefix->binding = b;\n  b->nextTagBinding = *bindingsPtr;\n  *bindingsPtr = b;\n  /* if attId == NULL then we are not starting a namespace scope */\n  if (attId && parser->m_startNamespaceDeclHandler)\n    parser->m_startNamespaceDeclHandler(parser->m_handlerArg, prefix->name,\n                                        prefix->binding ? uri : 0);\n  return XML_ERROR_NONE;\n}\n\n/* The idea here is to avoid using stack for each CDATA section when\n   the whole file is parsed with one call.\n*/\nstatic enum XML_Error PTRCALL\ncdataSectionProcessor(XML_Parser parser, const char *start, const char *end,\n                      const char **endPtr) {\n  enum XML_Error result = doCdataSection(\n      parser, parser->m_encoding, &start, end, endPtr,\n      (XML_Bool)! parser->m_parsingStatus.finalBuffer, XML_ACCOUNT_DIRECT);\n  if (result != XML_ERROR_NONE)\n    return result;\n  if (start) {\n    if (parser->m_parentParser) { /* we are parsing an external entity */\n      parser->m_processor = externalEntityContentProcessor;\n      return externalEntityContentProcessor(parser, start, end, endPtr);\n    } else {\n      parser->m_processor = contentProcessor;\n      return contentProcessor(parser, start, end, endPtr);\n    }\n  }\n  return result;\n}\n\n/* startPtr gets set to non-null if the section is closed, and to null if\n   the section is not yet closed.\n*/\nstatic enum XML_Error\ndoCdataSection(XML_Parser parser, const ENCODING *enc, const char **startPtr,\n               const char *end, const char **nextPtr, XML_Bool haveMore,\n               enum XML_Account account) {\n  const char *s = *startPtr;\n  const char **eventPP;\n  const char **eventEndPP;\n  if (enc == parser->m_encoding) {\n    eventPP = &parser->m_eventPtr;\n    *eventPP = s;\n    eventEndPP = &parser->m_eventEndPtr;\n  } else {\n    eventPP = &(parser->m_openInternalEntities->internalEventPtr);\n    eventEndPP = &(parser->m_openInternalEntities->internalEventEndPtr);\n  }\n  *eventPP = s;\n  *startPtr = NULL;\n\n  for (;;) {\n    const char *next = s; /* in case of XML_TOK_NONE or XML_TOK_PARTIAL */\n    int tok = XmlCdataSectionTok(enc, s, end, &next);\n#ifdef XML_DTD\n    if (! accountingDiffTolerated(parser, tok, s, next, __LINE__, account)) {\n      accountingOnAbort(parser);\n      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n    }\n#else\n    UNUSED_P(account);\n#endif\n    *eventEndPP = next;\n    switch (tok) {\n    case XML_TOK_CDATA_SECT_CLOSE:\n      if (parser->m_endCdataSectionHandler)\n        parser->m_endCdataSectionHandler(parser->m_handlerArg);\n      /* BEGIN disabled code */\n      /* see comment under XML_TOK_CDATA_SECT_OPEN */\n      else if ((0) && parser->m_characterDataHandler)\n        parser->m_characterDataHandler(parser->m_handlerArg, parser->m_dataBuf,\n                                       0);\n      /* END disabled code */\n      else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n      *startPtr = next;\n      *nextPtr = next;\n      if (parser->m_parsingStatus.parsing == XML_FINISHED)\n        return XML_ERROR_ABORTED;\n      else\n        return XML_ERROR_NONE;\n    case XML_TOK_DATA_NEWLINE:\n      if (parser->m_characterDataHandler) {\n        XML_Char c = 0xA;\n        parser->m_characterDataHandler(parser->m_handlerArg, &c, 1);\n      } else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n      break;\n    case XML_TOK_DATA_CHARS: {\n      XML_CharacterDataHandler charDataHandler = parser->m_characterDataHandler;\n      if (charDataHandler) {\n        if (MUST_CONVERT(enc, s)) {\n          for (;;) {\n            ICHAR *dataPtr = (ICHAR *)parser->m_dataBuf;\n            const enum XML_Convert_Result convert_res = XmlConvert(\n                enc, &s, next, &dataPtr, (ICHAR *)parser->m_dataBufEnd);\n            *eventEndPP = next;\n            charDataHandler(parser->m_handlerArg, parser->m_dataBuf,\n                            (int)(dataPtr - (ICHAR *)parser->m_dataBuf));\n            if ((convert_res == XML_CONVERT_COMPLETED)\n                || (convert_res == XML_CONVERT_INPUT_INCOMPLETE))\n              break;\n            *eventPP = s;\n          }\n        } else\n          charDataHandler(parser->m_handlerArg, (const XML_Char *)s,\n                          (int)((const XML_Char *)next - (const XML_Char *)s));\n      } else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n    } break;\n    case XML_TOK_INVALID:\n      *eventPP = next;\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_PARTIAL_CHAR:\n      if (haveMore) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      return XML_ERROR_PARTIAL_CHAR;\n    case XML_TOK_PARTIAL:\n    case XML_TOK_NONE:\n      if (haveMore) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      return XML_ERROR_UNCLOSED_CDATA_SECTION;\n    default:\n      /* Every token returned by XmlCdataSectionTok() has its own\n       * explicit case, so this default case will never be executed.\n       * We retain it as a safety net and exclude it from the coverage\n       * statistics.\n       *\n       * LCOV_EXCL_START\n       */\n      *eventPP = next;\n      return XML_ERROR_UNEXPECTED_STATE;\n      /* LCOV_EXCL_STOP */\n    }\n\n    *eventPP = s = next;\n    switch (parser->m_parsingStatus.parsing) {\n    case XML_SUSPENDED:\n      *nextPtr = next;\n      return XML_ERROR_NONE;\n    case XML_FINISHED:\n      return XML_ERROR_ABORTED;\n    default:;\n    }\n  }\n  /* not reached */\n}\n\n#ifdef XML_DTD\n\n/* The idea here is to avoid using stack for each IGNORE section when\n   the whole file is parsed with one call.\n*/\nstatic enum XML_Error PTRCALL\nignoreSectionProcessor(XML_Parser parser, const char *start, const char *end,\n                       const char **endPtr) {\n  enum XML_Error result\n      = doIgnoreSection(parser, parser->m_encoding, &start, end, endPtr,\n                        (XML_Bool)! parser->m_parsingStatus.finalBuffer);\n  if (result != XML_ERROR_NONE)\n    return result;\n  if (start) {\n    parser->m_processor = prologProcessor;\n    return prologProcessor(parser, start, end, endPtr);\n  }\n  return result;\n}\n\n/* startPtr gets set to non-null is the section is closed, and to null\n   if the section is not yet closed.\n*/\nstatic enum XML_Error\ndoIgnoreSection(XML_Parser parser, const ENCODING *enc, const char **startPtr,\n                const char *end, const char **nextPtr, XML_Bool haveMore) {\n  const char *next = *startPtr; /* in case of XML_TOK_NONE or XML_TOK_PARTIAL */\n  int tok;\n  const char *s = *startPtr;\n  const char **eventPP;\n  const char **eventEndPP;\n  if (enc == parser->m_encoding) {\n    eventPP = &parser->m_eventPtr;\n    *eventPP = s;\n    eventEndPP = &parser->m_eventEndPtr;\n  } else {\n    /* It's not entirely clear, but it seems the following two lines\n     * of code cannot be executed.  The only occasions on which 'enc'\n     * is not 'encoding' are when this function is called\n     * from the internal entity processing, and IGNORE sections are an\n     * error in internal entities.\n     *\n     * Since it really isn't clear that this is true, we keep the code\n     * and just remove it from our coverage tests.\n     *\n     * LCOV_EXCL_START\n     */\n    eventPP = &(parser->m_openInternalEntities->internalEventPtr);\n    eventEndPP = &(parser->m_openInternalEntities->internalEventEndPtr);\n    /* LCOV_EXCL_STOP */\n  }\n  *eventPP = s;\n  *startPtr = NULL;\n  tok = XmlIgnoreSectionTok(enc, s, end, &next);\n#  ifdef XML_DTD\n  if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                XML_ACCOUNT_DIRECT)) {\n    accountingOnAbort(parser);\n    return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n  }\n#  endif\n  *eventEndPP = next;\n  switch (tok) {\n  case XML_TOK_IGNORE_SECT:\n    if (parser->m_defaultHandler)\n      reportDefault(parser, enc, s, next);\n    *startPtr = next;\n    *nextPtr = next;\n    if (parser->m_parsingStatus.parsing == XML_FINISHED)\n      return XML_ERROR_ABORTED;\n    else\n      return XML_ERROR_NONE;\n  case XML_TOK_INVALID:\n    *eventPP = next;\n    return XML_ERROR_INVALID_TOKEN;\n  case XML_TOK_PARTIAL_CHAR:\n    if (haveMore) {\n      *nextPtr = s;\n      return XML_ERROR_NONE;\n    }\n    return XML_ERROR_PARTIAL_CHAR;\n  case XML_TOK_PARTIAL:\n  case XML_TOK_NONE:\n    if (haveMore) {\n      *nextPtr = s;\n      return XML_ERROR_NONE;\n    }\n    return XML_ERROR_SYNTAX; /* XML_ERROR_UNCLOSED_IGNORE_SECTION */\n  default:\n    /* All of the tokens that XmlIgnoreSectionTok() returns have\n     * explicit cases to handle them, so this default case is never\n     * executed.  We keep it as a safety net anyway, and remove it\n     * from our test coverage statistics.\n     *\n     * LCOV_EXCL_START\n     */\n    *eventPP = next;\n    return XML_ERROR_UNEXPECTED_STATE;\n    /* LCOV_EXCL_STOP */\n  }\n  /* not reached */\n}\n\n#endif /* XML_DTD */\n\nstatic enum XML_Error\ninitializeEncoding(XML_Parser parser) {\n  const char *s;\n#ifdef XML_UNICODE\n  char encodingBuf[128];\n  /* See comments about `protocolEncodingName` in parserInit() */\n  if (! parser->m_protocolEncodingName)\n    s = NULL;\n  else {\n    int i;\n    for (i = 0; parser->m_protocolEncodingName[i]; i++) {\n      if (i == sizeof(encodingBuf) - 1\n          || (parser->m_protocolEncodingName[i] & ~0x7f) != 0) {\n        encodingBuf[0] = '\\0';\n        break;\n      }\n      encodingBuf[i] = (char)parser->m_protocolEncodingName[i];\n    }\n    encodingBuf[i] = '\\0';\n    s = encodingBuf;\n  }\n#else\n  s = parser->m_protocolEncodingName;\n#endif\n  if ((parser->m_ns ? XmlInitEncodingNS : XmlInitEncoding)(\n          &parser->m_initEncoding, &parser->m_encoding, s))\n    return XML_ERROR_NONE;\n  return handleUnknownEncoding(parser, parser->m_protocolEncodingName);\n}\n\nstatic enum XML_Error\nprocessXmlDecl(XML_Parser parser, int isGeneralTextEntity, const char *s,\n               const char *next) {\n  const char *encodingName = NULL;\n  const XML_Char *storedEncName = NULL;\n  const ENCODING *newEncoding = NULL;\n  const char *version = NULL;\n  const char *versionend = NULL;\n  const XML_Char *storedversion = NULL;\n  int standalone = -1;\n\n#ifdef XML_DTD\n  if (! accountingDiffTolerated(parser, XML_TOK_XML_DECL, s, next, __LINE__,\n                                XML_ACCOUNT_DIRECT)) {\n    accountingOnAbort(parser);\n    return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n  }\n#endif\n\n  if (! (parser->m_ns ? XmlParseXmlDeclNS : XmlParseXmlDecl)(\n          isGeneralTextEntity, parser->m_encoding, s, next, &parser->m_eventPtr,\n          &version, &versionend, &encodingName, &newEncoding, &standalone)) {\n    if (isGeneralTextEntity)\n      return XML_ERROR_TEXT_DECL;\n    else\n      return XML_ERROR_XML_DECL;\n  }\n  if (! isGeneralTextEntity && standalone == 1) {\n    parser->m_dtd->standalone = XML_TRUE;\n#ifdef XML_DTD\n    if (parser->m_paramEntityParsing\n        == XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE)\n      parser->m_paramEntityParsing = XML_PARAM_ENTITY_PARSING_NEVER;\n#endif /* XML_DTD */\n  }\n  if (parser->m_xmlDeclHandler) {\n    if (encodingName != NULL) {\n      storedEncName = poolStoreString(\n          &parser->m_temp2Pool, parser->m_encoding, encodingName,\n          encodingName + XmlNameLength(parser->m_encoding, encodingName));\n      if (! storedEncName)\n        return XML_ERROR_NO_MEMORY;\n      poolFinish(&parser->m_temp2Pool);\n    }\n    if (version) {\n      storedversion\n          = poolStoreString(&parser->m_temp2Pool, parser->m_encoding, version,\n                            versionend - parser->m_encoding->minBytesPerChar);\n      if (! storedversion)\n        return XML_ERROR_NO_MEMORY;\n    }\n    parser->m_xmlDeclHandler(parser->m_handlerArg, storedversion, storedEncName,\n                             standalone);\n  } else if (parser->m_defaultHandler)\n    reportDefault(parser, parser->m_encoding, s, next);\n  if (parser->m_protocolEncodingName == NULL) {\n    if (newEncoding) {\n      /* Check that the specified encoding does not conflict with what\n       * the parser has already deduced.  Do we have the same number\n       * of bytes in the smallest representation of a character?  If\n       * this is UTF-16, is it the same endianness?\n       */\n      if (newEncoding->minBytesPerChar != parser->m_encoding->minBytesPerChar\n          || (newEncoding->minBytesPerChar == 2\n              && newEncoding != parser->m_encoding)) {\n        parser->m_eventPtr = encodingName;\n        return XML_ERROR_INCORRECT_ENCODING;\n      }\n      parser->m_encoding = newEncoding;\n    } else if (encodingName) {\n      enum XML_Error result;\n      if (! storedEncName) {\n        storedEncName = poolStoreString(\n            &parser->m_temp2Pool, parser->m_encoding, encodingName,\n            encodingName + XmlNameLength(parser->m_encoding, encodingName));\n        if (! storedEncName)\n          return XML_ERROR_NO_MEMORY;\n      }\n      result = handleUnknownEncoding(parser, storedEncName);\n      poolClear(&parser->m_temp2Pool);\n      if (result == XML_ERROR_UNKNOWN_ENCODING)\n        parser->m_eventPtr = encodingName;\n      return result;\n    }\n  }\n\n  if (storedEncName || storedversion)\n    poolClear(&parser->m_temp2Pool);\n\n  return XML_ERROR_NONE;\n}\n\nstatic enum XML_Error\nhandleUnknownEncoding(XML_Parser parser, const XML_Char *encodingName) {\n  if (parser->m_unknownEncodingHandler) {\n    XML_Encoding info;\n    int i;\n    for (i = 0; i < 256; i++)\n      info.map[i] = -1;\n    info.convert = NULL;\n    info.data = NULL;\n    info.release = NULL;\n    if (parser->m_unknownEncodingHandler(parser->m_unknownEncodingHandlerData,\n                                         encodingName, &info)) {\n      ENCODING *enc;\n      parser->m_unknownEncodingMem = MALLOC(parser, XmlSizeOfUnknownEncoding());\n      if (! parser->m_unknownEncodingMem) {\n        if (info.release)\n          info.release(info.data);\n        return XML_ERROR_NO_MEMORY;\n      }\n      enc = (parser->m_ns ? XmlInitUnknownEncodingNS : XmlInitUnknownEncoding)(\n          parser->m_unknownEncodingMem, info.map, info.convert, info.data);\n      if (enc) {\n        parser->m_unknownEncodingData = info.data;\n        parser->m_unknownEncodingRelease = info.release;\n        parser->m_encoding = enc;\n        return XML_ERROR_NONE;\n      }\n    }\n    if (info.release != NULL)\n      info.release(info.data);\n  }\n  return XML_ERROR_UNKNOWN_ENCODING;\n}\n\nstatic enum XML_Error PTRCALL\nprologInitProcessor(XML_Parser parser, const char *s, const char *end,\n                    const char **nextPtr) {\n  enum XML_Error result = initializeEncoding(parser);\n  if (result != XML_ERROR_NONE)\n    return result;\n  parser->m_processor = prologProcessor;\n  return prologProcessor(parser, s, end, nextPtr);\n}\n\n#ifdef XML_DTD\n\nstatic enum XML_Error PTRCALL\nexternalParEntInitProcessor(XML_Parser parser, const char *s, const char *end,\n                            const char **nextPtr) {\n  enum XML_Error result = initializeEncoding(parser);\n  if (result != XML_ERROR_NONE)\n    return result;\n\n  /* we know now that XML_Parse(Buffer) has been called,\n     so we consider the external parameter entity read */\n  parser->m_dtd->paramEntityRead = XML_TRUE;\n\n  if (parser->m_prologState.inEntityValue) {\n    parser->m_processor = entityValueInitProcessor;\n    return entityValueInitProcessor(parser, s, end, nextPtr);\n  } else {\n    parser->m_processor = externalParEntProcessor;\n    return externalParEntProcessor(parser, s, end, nextPtr);\n  }\n}\n\nstatic enum XML_Error PTRCALL\nentityValueInitProcessor(XML_Parser parser, const char *s, const char *end,\n                         const char **nextPtr) {\n  int tok;\n  const char *start = s;\n  const char *next = start;\n  parser->m_eventPtr = start;\n\n  for (;;) {\n    tok = XmlPrologTok(parser->m_encoding, start, end, &next);\n    /* Note: Except for XML_TOK_BOM below, these bytes are accounted later in:\n             - storeEntityValue\n             - processXmlDecl\n    */\n    parser->m_eventEndPtr = next;\n    if (tok <= 0) {\n      if (! parser->m_parsingStatus.finalBuffer && tok != XML_TOK_INVALID) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      switch (tok) {\n      case XML_TOK_INVALID:\n        return XML_ERROR_INVALID_TOKEN;\n      case XML_TOK_PARTIAL:\n        return XML_ERROR_UNCLOSED_TOKEN;\n      case XML_TOK_PARTIAL_CHAR:\n        return XML_ERROR_PARTIAL_CHAR;\n      case XML_TOK_NONE: /* start == end */\n      default:\n        break;\n      }\n      /* found end of entity value - can store it now */\n      return storeEntityValue(parser, parser->m_encoding, s, end,\n                              XML_ACCOUNT_DIRECT);\n    } else if (tok == XML_TOK_XML_DECL) {\n      enum XML_Error result;\n      result = processXmlDecl(parser, 0, start, next);\n      if (result != XML_ERROR_NONE)\n        return result;\n      /* At this point, m_parsingStatus.parsing cannot be XML_SUSPENDED.  For\n       * that to happen, a parameter entity parsing handler must have attempted\n       * to suspend the parser, which fails and raises an error.  The parser can\n       * be aborted, but can't be suspended.\n       */\n      if (parser->m_parsingStatus.parsing == XML_FINISHED)\n        return XML_ERROR_ABORTED;\n      *nextPtr = next;\n      /* stop scanning for text declaration - we found one */\n      parser->m_processor = entityValueProcessor;\n      return entityValueProcessor(parser, next, end, nextPtr);\n    }\n    /* XmlPrologTok has now set the encoding based on the BOM it found, and we\n       must move s and nextPtr forward to consume the BOM.\n\n       If we didn't, and got XML_TOK_NONE from the next XmlPrologTok call, we\n       would leave the BOM in the buffer and return. On the next call to this\n       function, our XmlPrologTok call would return XML_TOK_INVALID, since it\n       is not valid to have multiple BOMs.\n    */\n    else if (tok == XML_TOK_BOM) {\n#  ifdef XML_DTD\n      if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                    XML_ACCOUNT_DIRECT)) {\n        accountingOnAbort(parser);\n        return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n      }\n#  endif\n\n      *nextPtr = next;\n      s = next;\n    }\n    /* If we get this token, we have the start of what might be a\n       normal tag, but not a declaration (i.e. it doesn't begin with\n       \"<!\").  In a DTD context, that isn't legal.\n    */\n    else if (tok == XML_TOK_INSTANCE_START) {\n      *nextPtr = next;\n      return XML_ERROR_SYNTAX;\n    }\n    start = next;\n    parser->m_eventPtr = start;\n  }\n}\n\nstatic enum XML_Error PTRCALL\nexternalParEntProcessor(XML_Parser parser, const char *s, const char *end,\n                        const char **nextPtr) {\n  const char *next = s;\n  int tok;\n\n  tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  if (tok <= 0) {\n    if (! parser->m_parsingStatus.finalBuffer && tok != XML_TOK_INVALID) {\n      *nextPtr = s;\n      return XML_ERROR_NONE;\n    }\n    switch (tok) {\n    case XML_TOK_INVALID:\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_PARTIAL:\n      return XML_ERROR_UNCLOSED_TOKEN;\n    case XML_TOK_PARTIAL_CHAR:\n      return XML_ERROR_PARTIAL_CHAR;\n    case XML_TOK_NONE: /* start == end */\n    default:\n      break;\n    }\n  }\n  /* This would cause the next stage, i.e. doProlog to be passed XML_TOK_BOM.\n     However, when parsing an external subset, doProlog will not accept a BOM\n     as valid, and report a syntax error, so we have to skip the BOM, and\n     account for the BOM bytes.\n  */\n  else if (tok == XML_TOK_BOM) {\n    if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                  XML_ACCOUNT_DIRECT)) {\n      accountingOnAbort(parser);\n      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n    }\n\n    s = next;\n    tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  }\n\n  parser->m_processor = prologProcessor;\n  return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                  (XML_Bool)! parser->m_parsingStatus.finalBuffer, XML_TRUE,\n                  XML_ACCOUNT_DIRECT);\n}\n\nstatic enum XML_Error PTRCALL\nentityValueProcessor(XML_Parser parser, const char *s, const char *end,\n                     const char **nextPtr) {\n  const char *start = s;\n  const char *next = s;\n  const ENCODING *enc = parser->m_encoding;\n  int tok;\n\n  for (;;) {\n    tok = XmlPrologTok(enc, start, end, &next);\n    /* Note: These bytes are accounted later in:\n             - storeEntityValue\n    */\n    if (tok <= 0) {\n      if (! parser->m_parsingStatus.finalBuffer && tok != XML_TOK_INVALID) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      switch (tok) {\n      case XML_TOK_INVALID:\n        return XML_ERROR_INVALID_TOKEN;\n      case XML_TOK_PARTIAL:\n        return XML_ERROR_UNCLOSED_TOKEN;\n      case XML_TOK_PARTIAL_CHAR:\n        return XML_ERROR_PARTIAL_CHAR;\n      case XML_TOK_NONE: /* start == end */\n      default:\n        break;\n      }\n      /* found end of entity value - can store it now */\n      return storeEntityValue(parser, enc, s, end, XML_ACCOUNT_DIRECT);\n    }\n    start = next;\n  }\n}\n\n#endif /* XML_DTD */\n\nstatic enum XML_Error PTRCALL\nprologProcessor(XML_Parser parser, const char *s, const char *end,\n                const char **nextPtr) {\n  const char *next = s;\n  int tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                  (XML_Bool)! parser->m_parsingStatus.finalBuffer, XML_TRUE,\n                  XML_ACCOUNT_DIRECT);\n}\n\nstatic enum XML_Error\ndoProlog(XML_Parser parser, const ENCODING *enc, const char *s, const char *end,\n         int tok, const char *next, const char **nextPtr, XML_Bool haveMore,\n         XML_Bool allowClosingDoctype, enum XML_Account account) {\n#ifdef XML_DTD\n  static const XML_Char externalSubsetName[] = {ASCII_HASH, '\\0'};\n#endif /* XML_DTD */\n  static const XML_Char atypeCDATA[]\n      = {ASCII_C, ASCII_D, ASCII_A, ASCII_T, ASCII_A, '\\0'};\n  static const XML_Char atypeID[] = {ASCII_I, ASCII_D, '\\0'};\n  static const XML_Char atypeIDREF[]\n      = {ASCII_I, ASCII_D, ASCII_R, ASCII_E, ASCII_F, '\\0'};\n  static const XML_Char atypeIDREFS[]\n      = {ASCII_I, ASCII_D, ASCII_R, ASCII_E, ASCII_F, ASCII_S, '\\0'};\n  static const XML_Char atypeENTITY[]\n      = {ASCII_E, ASCII_N, ASCII_T, ASCII_I, ASCII_T, ASCII_Y, '\\0'};\n  static const XML_Char atypeENTITIES[]\n      = {ASCII_E, ASCII_N, ASCII_T, ASCII_I, ASCII_T,\n         ASCII_I, ASCII_E, ASCII_S, '\\0'};\n  static const XML_Char atypeNMTOKEN[]\n      = {ASCII_N, ASCII_M, ASCII_T, ASCII_O, ASCII_K, ASCII_E, ASCII_N, '\\0'};\n  static const XML_Char atypeNMTOKENS[]\n      = {ASCII_N, ASCII_M, ASCII_T, ASCII_O, ASCII_K,\n         ASCII_E, ASCII_N, ASCII_S, '\\0'};\n  static const XML_Char notationPrefix[]\n      = {ASCII_N, ASCII_O, ASCII_T, ASCII_A,      ASCII_T,\n         ASCII_I, ASCII_O, ASCII_N, ASCII_LPAREN, '\\0'};\n  static const XML_Char enumValueSep[] = {ASCII_PIPE, '\\0'};\n  static const XML_Char enumValueStart[] = {ASCII_LPAREN, '\\0'};\n\n#ifndef XML_DTD\n  UNUSED_P(account);\n#endif\n\n  /* save one level of indirection */\n  DTD *const dtd = parser->m_dtd;\n\n  const char **eventPP;\n  const char **eventEndPP;\n  enum XML_Content_Quant quant;\n\n  if (enc == parser->m_encoding) {\n    eventPP = &parser->m_eventPtr;\n    eventEndPP = &parser->m_eventEndPtr;\n  } else {\n    eventPP = &(parser->m_openInternalEntities->internalEventPtr);\n    eventEndPP = &(parser->m_openInternalEntities->internalEventEndPtr);\n  }\n\n  for (;;) {\n    int role;\n    XML_Bool handleDefault = XML_TRUE;\n    *eventPP = s;\n    *eventEndPP = next;\n    if (tok <= 0) {\n      if (haveMore && tok != XML_TOK_INVALID) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      switch (tok) {\n      case XML_TOK_INVALID:\n        *eventPP = next;\n        return XML_ERROR_INVALID_TOKEN;\n      case XML_TOK_PARTIAL:\n        return XML_ERROR_UNCLOSED_TOKEN;\n      case XML_TOK_PARTIAL_CHAR:\n        return XML_ERROR_PARTIAL_CHAR;\n      case -XML_TOK_PROLOG_S:\n        tok = -tok;\n        break;\n      case XML_TOK_NONE:\n#ifdef XML_DTD\n        /* for internal PE NOT referenced between declarations */\n        if (enc != parser->m_encoding\n            && ! parser->m_openInternalEntities->betweenDecl) {\n          *nextPtr = s;\n          return XML_ERROR_NONE;\n        }\n        /* WFC: PE Between Declarations - must check that PE contains\n           complete markup, not only for external PEs, but also for\n           internal PEs if the reference occurs between declarations.\n        */\n        if (parser->m_isParamEntity || enc != parser->m_encoding) {\n          if (XmlTokenRole(&parser->m_prologState, XML_TOK_NONE, end, end, enc)\n              == XML_ROLE_ERROR)\n            return XML_ERROR_INCOMPLETE_PE;\n          *nextPtr = s;\n          return XML_ERROR_NONE;\n        }\n#endif /* XML_DTD */\n        return XML_ERROR_NO_ELEMENTS;\n      default:\n        tok = -tok;\n        next = end;\n        break;\n      }\n    }\n    role = XmlTokenRole(&parser->m_prologState, tok, s, next, enc);\n#ifdef XML_DTD\n    switch (role) {\n    case XML_ROLE_INSTANCE_START: // bytes accounted in contentProcessor\n    case XML_ROLE_XML_DECL:       // bytes accounted in processXmlDecl\n    case XML_ROLE_TEXT_DECL:      // bytes accounted in processXmlDecl\n      break;\n    default:\n      if (! accountingDiffTolerated(parser, tok, s, next, __LINE__, account)) {\n        accountingOnAbort(parser);\n        return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n      }\n    }\n#endif\n    switch (role) {\n    case XML_ROLE_XML_DECL: {\n      enum XML_Error result = processXmlDecl(parser, 0, s, next);\n      if (result != XML_ERROR_NONE)\n        return result;\n      enc = parser->m_encoding;\n      handleDefault = XML_FALSE;\n    } break;\n    case XML_ROLE_DOCTYPE_NAME:\n      if (parser->m_startDoctypeDeclHandler) {\n        parser->m_doctypeName\n            = poolStoreString(&parser->m_tempPool, enc, s, next);\n        if (! parser->m_doctypeName)\n          return XML_ERROR_NO_MEMORY;\n        poolFinish(&parser->m_tempPool);\n        parser->m_doctypePubid = NULL;\n        handleDefault = XML_FALSE;\n      }\n      parser->m_doctypeSysid = NULL; /* always initialize to NULL */\n      break;\n    case XML_ROLE_DOCTYPE_INTERNAL_SUBSET:\n      if (parser->m_startDoctypeDeclHandler) {\n        parser->m_startDoctypeDeclHandler(\n            parser->m_handlerArg, parser->m_doctypeName, parser->m_doctypeSysid,\n            parser->m_doctypePubid, 1);\n        parser->m_doctypeName = NULL;\n        poolClear(&parser->m_tempPool);\n        handleDefault = XML_FALSE;\n      }\n      break;\n#ifdef XML_DTD\n    case XML_ROLE_TEXT_DECL: {\n      enum XML_Error result = processXmlDecl(parser, 1, s, next);\n      if (result != XML_ERROR_NONE)\n        return result;\n      enc = parser->m_encoding;\n      handleDefault = XML_FALSE;\n    } break;\n#endif /* XML_DTD */\n    case XML_ROLE_DOCTYPE_PUBLIC_ID:\n#ifdef XML_DTD\n      parser->m_useForeignDTD = XML_FALSE;\n      parser->m_declEntity = (ENTITY *)lookup(\n          parser, &dtd->paramEntities, externalSubsetName, sizeof(ENTITY));\n      if (! parser->m_declEntity)\n        return XML_ERROR_NO_MEMORY;\n#endif /* XML_DTD */\n      dtd->hasParamEntityRefs = XML_TRUE;\n      if (parser->m_startDoctypeDeclHandler) {\n        XML_Char *pubId;\n        if (! XmlIsPublicId(enc, s, next, eventPP))\n          return XML_ERROR_PUBLICID;\n        pubId = poolStoreString(&parser->m_tempPool, enc,\n                                s + enc->minBytesPerChar,\n                                next - enc->minBytesPerChar);\n        if (! pubId)\n          return XML_ERROR_NO_MEMORY;\n        normalizePublicId(pubId);\n        poolFinish(&parser->m_tempPool);\n        parser->m_doctypePubid = pubId;\n        handleDefault = XML_FALSE;\n        goto alreadyChecked;\n      }\n      /* fall through */\n    case XML_ROLE_ENTITY_PUBLIC_ID:\n      if (! XmlIsPublicId(enc, s, next, eventPP))\n        return XML_ERROR_PUBLICID;\n    alreadyChecked:\n      if (dtd->keepProcessing && parser->m_declEntity) {\n        XML_Char *tem\n            = poolStoreString(&dtd->pool, enc, s + enc->minBytesPerChar,\n                              next - enc->minBytesPerChar);\n        if (! tem)\n          return XML_ERROR_NO_MEMORY;\n        normalizePublicId(tem);\n        parser->m_declEntity->publicId = tem;\n        poolFinish(&dtd->pool);\n        /* Don't suppress the default handler if we fell through from\n         * the XML_ROLE_DOCTYPE_PUBLIC_ID case.\n         */\n        if (parser->m_entityDeclHandler && role == XML_ROLE_ENTITY_PUBLIC_ID)\n          handleDefault = XML_FALSE;\n      }\n      break;\n    case XML_ROLE_DOCTYPE_CLOSE:\n      if (allowClosingDoctype != XML_TRUE) {\n        /* Must not close doctype from within expanded parameter entities */\n        return XML_ERROR_INVALID_TOKEN;\n      }\n\n      if (parser->m_doctypeName) {\n        parser->m_startDoctypeDeclHandler(\n            parser->m_handlerArg, parser->m_doctypeName, parser->m_doctypeSysid,\n            parser->m_doctypePubid, 0);\n        poolClear(&parser->m_tempPool);\n        handleDefault = XML_FALSE;\n      }\n      /* parser->m_doctypeSysid will be non-NULL in the case of a previous\n         XML_ROLE_DOCTYPE_SYSTEM_ID, even if parser->m_startDoctypeDeclHandler\n         was not set, indicating an external subset\n      */\n#ifdef XML_DTD\n      if (parser->m_doctypeSysid || parser->m_useForeignDTD) {\n        XML_Bool hadParamEntityRefs = dtd->hasParamEntityRefs;\n        dtd->hasParamEntityRefs = XML_TRUE;\n        if (parser->m_paramEntityParsing\n            && parser->m_externalEntityRefHandler) {\n          ENTITY *entity = (ENTITY *)lookup(parser, &dtd->paramEntities,\n                                            externalSubsetName, sizeof(ENTITY));\n          if (! entity) {\n            /* The external subset name \"#\" will have already been\n             * inserted into the hash table at the start of the\n             * external entity parsing, so no allocation will happen\n             * and lookup() cannot fail.\n             */\n            return XML_ERROR_NO_MEMORY; /* LCOV_EXCL_LINE */\n          }\n          if (parser->m_useForeignDTD)\n            entity->base = parser->m_curBase;\n          dtd->paramEntityRead = XML_FALSE;\n          if (! parser->m_externalEntityRefHandler(\n                  parser->m_externalEntityRefHandlerArg, 0, entity->base,\n                  entity->systemId, entity->publicId))\n            return XML_ERROR_EXTERNAL_ENTITY_HANDLING;\n          if (dtd->paramEntityRead) {\n            if (! dtd->standalone && parser->m_notStandaloneHandler\n                && ! parser->m_notStandaloneHandler(parser->m_handlerArg))\n              return XML_ERROR_NOT_STANDALONE;\n          }\n          /* if we didn't read the foreign DTD then this means that there\n             is no external subset and we must reset dtd->hasParamEntityRefs\n          */\n          else if (! parser->m_doctypeSysid)\n            dtd->hasParamEntityRefs = hadParamEntityRefs;\n          /* end of DTD - no need to update dtd->keepProcessing */\n        }\n        parser->m_useForeignDTD = XML_FALSE;\n      }\n#endif /* XML_DTD */\n      if (parser->m_endDoctypeDeclHandler) {\n        parser->m_endDoctypeDeclHandler(parser->m_handlerArg);\n        handleDefault = XML_FALSE;\n      }\n      break;\n    case XML_ROLE_INSTANCE_START:\n#ifdef XML_DTD\n      /* if there is no DOCTYPE declaration then now is the\n         last chance to read the foreign DTD\n      */\n      if (parser->m_useForeignDTD) {\n        XML_Bool hadParamEntityRefs = dtd->hasParamEntityRefs;\n        dtd->hasParamEntityRefs = XML_TRUE;\n        if (parser->m_paramEntityParsing\n            && parser->m_externalEntityRefHandler) {\n          ENTITY *entity = (ENTITY *)lookup(parser, &dtd->paramEntities,\n                                            externalSubsetName, sizeof(ENTITY));\n          if (! entity)\n            return XML_ERROR_NO_MEMORY;\n          entity->base = parser->m_curBase;\n          dtd->paramEntityRead = XML_FALSE;\n          if (! parser->m_externalEntityRefHandler(\n                  parser->m_externalEntityRefHandlerArg, 0, entity->base,\n                  entity->systemId, entity->publicId))\n            return XML_ERROR_EXTERNAL_ENTITY_HANDLING;\n          if (dtd->paramEntityRead) {\n            if (! dtd->standalone && parser->m_notStandaloneHandler\n                && ! parser->m_notStandaloneHandler(parser->m_handlerArg))\n              return XML_ERROR_NOT_STANDALONE;\n          }\n          /* if we didn't read the foreign DTD then this means that there\n             is no external subset and we must reset dtd->hasParamEntityRefs\n          */\n          else\n            dtd->hasParamEntityRefs = hadParamEntityRefs;\n          /* end of DTD - no need to update dtd->keepProcessing */\n        }\n      }\n#endif /* XML_DTD */\n      parser->m_processor = contentProcessor;\n      return contentProcessor(parser, s, end, nextPtr);\n    case XML_ROLE_ATTLIST_ELEMENT_NAME:\n      parser->m_declElementType = getElementType(parser, enc, s, next);\n      if (! parser->m_declElementType)\n        return XML_ERROR_NO_MEMORY;\n      goto checkAttListDeclHandler;\n    case XML_ROLE_ATTRIBUTE_NAME:\n      parser->m_declAttributeId = getAttributeId(parser, enc, s, next);\n      if (! parser->m_declAttributeId)\n        return XML_ERROR_NO_MEMORY;\n      parser->m_declAttributeIsCdata = XML_FALSE;\n      parser->m_declAttributeType = NULL;\n      parser->m_declAttributeIsId = XML_FALSE;\n      goto checkAttListDeclHandler;\n    case XML_ROLE_ATTRIBUTE_TYPE_CDATA:\n      parser->m_declAttributeIsCdata = XML_TRUE;\n      parser->m_declAttributeType = atypeCDATA;\n      goto checkAttListDeclHandler;\n    case XML_ROLE_ATTRIBUTE_TYPE_ID:\n      parser->m_declAttributeIsId = XML_TRUE;\n      parser->m_declAttributeType = atypeID;\n      goto checkAttListDeclHandler;\n    case XML_ROLE_ATTRIBUTE_TYPE_IDREF:\n      parser->m_declAttributeType = atypeIDREF;\n      goto checkAttListDeclHandler;\n    case XML_ROLE_ATTRIBUTE_TYPE_IDREFS:\n      parser->m_declAttributeType = atypeIDREFS;\n      goto checkAttListDeclHandler;\n    case XML_ROLE_ATTRIBUTE_TYPE_ENTITY:\n      parser->m_declAttributeType = atypeENTITY;\n      goto checkAttListDeclHandler;\n    case XML_ROLE_ATTRIBUTE_TYPE_ENTITIES:\n      parser->m_declAttributeType = atypeENTITIES;\n      goto checkAttListDeclHandler;\n    case XML_ROLE_ATTRIBUTE_TYPE_NMTOKEN:\n      parser->m_declAttributeType = atypeNMTOKEN;\n      goto checkAttListDeclHandler;\n    case XML_ROLE_ATTRIBUTE_TYPE_NMTOKENS:\n      parser->m_declAttributeType = atypeNMTOKENS;\n    checkAttListDeclHandler:\n      if (dtd->keepProcessing && parser->m_attlistDeclHandler)\n        handleDefault = XML_FALSE;\n      break;\n    case XML_ROLE_ATTRIBUTE_ENUM_VALUE:\n    case XML_ROLE_ATTRIBUTE_NOTATION_VALUE:\n      if (dtd->keepProcessing && parser->m_attlistDeclHandler) {\n        const XML_Char *prefix;\n        if (parser->m_declAttributeType) {\n          prefix = enumValueSep;\n        } else {\n          prefix = (role == XML_ROLE_ATTRIBUTE_NOTATION_VALUE ? notationPrefix\n                                                              : enumValueStart);\n        }\n        if (! poolAppendString(&parser->m_tempPool, prefix))\n          return XML_ERROR_NO_MEMORY;\n        if (! poolAppend(&parser->m_tempPool, enc, s, next))\n          return XML_ERROR_NO_MEMORY;\n        parser->m_declAttributeType = parser->m_tempPool.start;\n        handleDefault = XML_FALSE;\n      }\n      break;\n    case XML_ROLE_IMPLIED_ATTRIBUTE_VALUE:\n    case XML_ROLE_REQUIRED_ATTRIBUTE_VALUE:\n      if (dtd->keepProcessing) {\n        if (! defineAttribute(parser->m_declElementType,\n                              parser->m_declAttributeId,\n                              parser->m_declAttributeIsCdata,\n                              parser->m_declAttributeIsId, 0, parser))\n          return XML_ERROR_NO_MEMORY;\n        if (parser->m_attlistDeclHandler && parser->m_declAttributeType) {\n          if (*parser->m_declAttributeType == XML_T(ASCII_LPAREN)\n              || (*parser->m_declAttributeType == XML_T(ASCII_N)\n                  && parser->m_declAttributeType[1] == XML_T(ASCII_O))) {\n            /* Enumerated or Notation type */\n            if (! poolAppendChar(&parser->m_tempPool, XML_T(ASCII_RPAREN))\n                || ! poolAppendChar(&parser->m_tempPool, XML_T('\\0')))\n              return XML_ERROR_NO_MEMORY;\n            parser->m_declAttributeType = parser->m_tempPool.start;\n            poolFinish(&parser->m_tempPool);\n          }\n          *eventEndPP = s;\n          parser->m_attlistDeclHandler(\n              parser->m_handlerArg, parser->m_declElementType->name,\n              parser->m_declAttributeId->name, parser->m_declAttributeType, 0,\n              role == XML_ROLE_REQUIRED_ATTRIBUTE_VALUE);\n          handleDefault = XML_FALSE;\n        }\n      }\n      poolClear(&parser->m_tempPool);\n      break;\n    case XML_ROLE_DEFAULT_ATTRIBUTE_VALUE:\n    case XML_ROLE_FIXED_ATTRIBUTE_VALUE:\n      if (dtd->keepProcessing) {\n        const XML_Char *attVal;\n        enum XML_Error result = storeAttributeValue(\n            parser, enc, parser->m_declAttributeIsCdata,\n            s + enc->minBytesPerChar, next - enc->minBytesPerChar, &dtd->pool,\n            XML_ACCOUNT_NONE);\n        if (result)\n          return result;\n        attVal = poolStart(&dtd->pool);\n        poolFinish(&dtd->pool);\n        /* ID attributes aren't allowed to have a default */\n        if (! defineAttribute(\n                parser->m_declElementType, parser->m_declAttributeId,\n                parser->m_declAttributeIsCdata, XML_FALSE, attVal, parser))\n          return XML_ERROR_NO_MEMORY;\n        if (parser->m_attlistDeclHandler && parser->m_declAttributeType) {\n          if (*parser->m_declAttributeType == XML_T(ASCII_LPAREN)\n              || (*parser->m_declAttributeType == XML_T(ASCII_N)\n                  && parser->m_declAttributeType[1] == XML_T(ASCII_O))) {\n            /* Enumerated or Notation type */\n            if (! poolAppendChar(&parser->m_tempPool, XML_T(ASCII_RPAREN))\n                || ! poolAppendChar(&parser->m_tempPool, XML_T('\\0')))\n              return XML_ERROR_NO_MEMORY;\n            parser->m_declAttributeType = parser->m_tempPool.start;\n            poolFinish(&parser->m_tempPool);\n          }\n          *eventEndPP = s;\n          parser->m_attlistDeclHandler(\n              parser->m_handlerArg, parser->m_declElementType->name,\n              parser->m_declAttributeId->name, parser->m_declAttributeType,\n              attVal, role == XML_ROLE_FIXED_ATTRIBUTE_VALUE);\n          poolClear(&parser->m_tempPool);\n          handleDefault = XML_FALSE;\n        }\n      }\n      break;\n    case XML_ROLE_ENTITY_VALUE:\n      if (dtd->keepProcessing) {\n        enum XML_Error result\n            = storeEntityValue(parser, enc, s + enc->minBytesPerChar,\n                               next - enc->minBytesPerChar, XML_ACCOUNT_NONE);\n        if (parser->m_declEntity) {\n          parser->m_declEntity->textPtr = poolStart(&dtd->entityValuePool);\n          parser->m_declEntity->textLen\n              = (int)(poolLength(&dtd->entityValuePool));\n          poolFinish(&dtd->entityValuePool);\n          if (parser->m_entityDeclHandler) {\n            *eventEndPP = s;\n            parser->m_entityDeclHandler(\n                parser->m_handlerArg, parser->m_declEntity->name,\n                parser->m_declEntity->is_param, parser->m_declEntity->textPtr,\n                parser->m_declEntity->textLen, parser->m_curBase, 0, 0, 0);\n            handleDefault = XML_FALSE;\n          }\n        } else\n          poolDiscard(&dtd->entityValuePool);\n        if (result != XML_ERROR_NONE)\n          return result;\n      }\n      break;\n    case XML_ROLE_DOCTYPE_SYSTEM_ID:\n#ifdef XML_DTD\n      parser->m_useForeignDTD = XML_FALSE;\n#endif /* XML_DTD */\n      dtd->hasParamEntityRefs = XML_TRUE;\n      if (parser->m_startDoctypeDeclHandler) {\n        parser->m_doctypeSysid = poolStoreString(&parser->m_tempPool, enc,\n                                                 s + enc->minBytesPerChar,\n                                                 next - enc->minBytesPerChar);\n        if (parser->m_doctypeSysid == NULL)\n          return XML_ERROR_NO_MEMORY;\n        poolFinish(&parser->m_tempPool);\n        handleDefault = XML_FALSE;\n      }\n#ifdef XML_DTD\n      else\n        /* use externalSubsetName to make parser->m_doctypeSysid non-NULL\n           for the case where no parser->m_startDoctypeDeclHandler is set */\n        parser->m_doctypeSysid = externalSubsetName;\n#endif /* XML_DTD */\n      if (! dtd->standalone\n#ifdef XML_DTD\n          && ! parser->m_paramEntityParsing\n#endif /* XML_DTD */\n          && parser->m_notStandaloneHandler\n          && ! parser->m_notStandaloneHandler(parser->m_handlerArg))\n        return XML_ERROR_NOT_STANDALONE;\n#ifndef XML_DTD\n      break;\n#else  /* XML_DTD */\n      if (! parser->m_declEntity) {\n        parser->m_declEntity = (ENTITY *)lookup(\n            parser, &dtd->paramEntities, externalSubsetName, sizeof(ENTITY));\n        if (! parser->m_declEntity)\n          return XML_ERROR_NO_MEMORY;\n        parser->m_declEntity->publicId = NULL;\n      }\n#endif /* XML_DTD */\n      /* fall through */\n    case XML_ROLE_ENTITY_SYSTEM_ID:\n      if (dtd->keepProcessing && parser->m_declEntity) {\n        parser->m_declEntity->systemId\n            = poolStoreString(&dtd->pool, enc, s + enc->minBytesPerChar,\n                              next - enc->minBytesPerChar);\n        if (! parser->m_declEntity->systemId)\n          return XML_ERROR_NO_MEMORY;\n        parser->m_declEntity->base = parser->m_curBase;\n        poolFinish(&dtd->pool);\n        /* Don't suppress the default handler if we fell through from\n         * the XML_ROLE_DOCTYPE_SYSTEM_ID case.\n         */\n        if (parser->m_entityDeclHandler && role == XML_ROLE_ENTITY_SYSTEM_ID)\n          handleDefault = XML_FALSE;\n      }\n      break;\n    case XML_ROLE_ENTITY_COMPLETE:\n      if (dtd->keepProcessing && parser->m_declEntity\n          && parser->m_entityDeclHandler) {\n        *eventEndPP = s;\n        parser->m_entityDeclHandler(\n            parser->m_handlerArg, parser->m_declEntity->name,\n            parser->m_declEntity->is_param, 0, 0, parser->m_declEntity->base,\n            parser->m_declEntity->systemId, parser->m_declEntity->publicId, 0);\n        handleDefault = XML_FALSE;\n      }\n      break;\n    case XML_ROLE_ENTITY_NOTATION_NAME:\n      if (dtd->keepProcessing && parser->m_declEntity) {\n        parser->m_declEntity->notation\n            = poolStoreString(&dtd->pool, enc, s, next);\n        if (! parser->m_declEntity->notation)\n          return XML_ERROR_NO_MEMORY;\n        poolFinish(&dtd->pool);\n        if (parser->m_unparsedEntityDeclHandler) {\n          *eventEndPP = s;\n          parser->m_unparsedEntityDeclHandler(\n              parser->m_handlerArg, parser->m_declEntity->name,\n              parser->m_declEntity->base, parser->m_declEntity->systemId,\n              parser->m_declEntity->publicId, parser->m_declEntity->notation);\n          handleDefault = XML_FALSE;\n        } else if (parser->m_entityDeclHandler) {\n          *eventEndPP = s;\n          parser->m_entityDeclHandler(\n              parser->m_handlerArg, parser->m_declEntity->name, 0, 0, 0,\n              parser->m_declEntity->base, parser->m_declEntity->systemId,\n              parser->m_declEntity->publicId, parser->m_declEntity->notation);\n          handleDefault = XML_FALSE;\n        }\n      }\n      break;\n    case XML_ROLE_GENERAL_ENTITY_NAME: {\n      if (XmlPredefinedEntityName(enc, s, next)) {\n        parser->m_declEntity = NULL;\n        break;\n      }\n      if (dtd->keepProcessing) {\n        const XML_Char *name = poolStoreString(&dtd->pool, enc, s, next);\n        if (! name)\n          return XML_ERROR_NO_MEMORY;\n        parser->m_declEntity = (ENTITY *)lookup(parser, &dtd->generalEntities,\n                                                name, sizeof(ENTITY));\n        if (! parser->m_declEntity)\n          return XML_ERROR_NO_MEMORY;\n        if (parser->m_declEntity->name != name) {\n          poolDiscard(&dtd->pool);\n          parser->m_declEntity = NULL;\n        } else {\n          poolFinish(&dtd->pool);\n          parser->m_declEntity->publicId = NULL;\n          parser->m_declEntity->is_param = XML_FALSE;\n          /* if we have a parent parser or are reading an internal parameter\n             entity, then the entity declaration is not considered \"internal\"\n          */\n          parser->m_declEntity->is_internal\n              = ! (parser->m_parentParser || parser->m_openInternalEntities);\n          if (parser->m_entityDeclHandler)\n            handleDefault = XML_FALSE;\n        }\n      } else {\n        poolDiscard(&dtd->pool);\n        parser->m_declEntity = NULL;\n      }\n    } break;\n    case XML_ROLE_PARAM_ENTITY_NAME:\n#ifdef XML_DTD\n      if (dtd->keepProcessing) {\n        const XML_Char *name = poolStoreString(&dtd->pool, enc, s, next);\n        if (! name)\n          return XML_ERROR_NO_MEMORY;\n        parser->m_declEntity = (ENTITY *)lookup(parser, &dtd->paramEntities,\n                                                name, sizeof(ENTITY));\n        if (! parser->m_declEntity)\n          return XML_ERROR_NO_MEMORY;\n        if (parser->m_declEntity->name != name) {\n          poolDiscard(&dtd->pool);\n          parser->m_declEntity = NULL;\n        } else {\n          poolFinish(&dtd->pool);\n          parser->m_declEntity->publicId = NULL;\n          parser->m_declEntity->is_param = XML_TRUE;\n          /* if we have a parent parser or are reading an internal parameter\n             entity, then the entity declaration is not considered \"internal\"\n          */\n          parser->m_declEntity->is_internal\n              = ! (parser->m_parentParser || parser->m_openInternalEntities);\n          if (parser->m_entityDeclHandler)\n            handleDefault = XML_FALSE;\n        }\n      } else {\n        poolDiscard(&dtd->pool);\n        parser->m_declEntity = NULL;\n      }\n#else  /* not XML_DTD */\n      parser->m_declEntity = NULL;\n#endif /* XML_DTD */\n      break;\n    case XML_ROLE_NOTATION_NAME:\n      parser->m_declNotationPublicId = NULL;\n      parser->m_declNotationName = NULL;\n      if (parser->m_notationDeclHandler) {\n        parser->m_declNotationName\n            = poolStoreString(&parser->m_tempPool, enc, s, next);\n        if (! parser->m_declNotationName)\n          return XML_ERROR_NO_MEMORY;\n        poolFinish(&parser->m_tempPool);\n        handleDefault = XML_FALSE;\n      }\n      break;\n    case XML_ROLE_NOTATION_PUBLIC_ID:\n      if (! XmlIsPublicId(enc, s, next, eventPP))\n        return XML_ERROR_PUBLICID;\n      if (parser\n              ->m_declNotationName) { /* means m_notationDeclHandler != NULL */\n        XML_Char *tem = poolStoreString(&parser->m_tempPool, enc,\n                                        s + enc->minBytesPerChar,\n                                        next - enc->minBytesPerChar);\n        if (! tem)\n          return XML_ERROR_NO_MEMORY;\n        normalizePublicId(tem);\n        parser->m_declNotationPublicId = tem;\n        poolFinish(&parser->m_tempPool);\n        handleDefault = XML_FALSE;\n      }\n      break;\n    case XML_ROLE_NOTATION_SYSTEM_ID:\n      if (parser->m_declNotationName && parser->m_notationDeclHandler) {\n        const XML_Char *systemId = poolStoreString(&parser->m_tempPool, enc,\n                                                   s + enc->minBytesPerChar,\n                                                   next - enc->minBytesPerChar);\n        if (! systemId)\n          return XML_ERROR_NO_MEMORY;\n        *eventEndPP = s;\n        parser->m_notationDeclHandler(\n            parser->m_handlerArg, parser->m_declNotationName, parser->m_curBase,\n            systemId, parser->m_declNotationPublicId);\n        handleDefault = XML_FALSE;\n      }\n      poolClear(&parser->m_tempPool);\n      break;\n    case XML_ROLE_NOTATION_NO_SYSTEM_ID:\n      if (parser->m_declNotationPublicId && parser->m_notationDeclHandler) {\n        *eventEndPP = s;\n        parser->m_notationDeclHandler(\n            parser->m_handlerArg, parser->m_declNotationName, parser->m_curBase,\n            0, parser->m_declNotationPublicId);\n        handleDefault = XML_FALSE;\n      }\n      poolClear(&parser->m_tempPool);\n      break;\n    case XML_ROLE_ERROR:\n      switch (tok) {\n      case XML_TOK_PARAM_ENTITY_REF:\n        /* PE references in internal subset are\n           not allowed within declarations. */\n        return XML_ERROR_PARAM_ENTITY_REF;\n      case XML_TOK_XML_DECL:\n        return XML_ERROR_MISPLACED_XML_PI;\n      default:\n        return XML_ERROR_SYNTAX;\n      }\n#ifdef XML_DTD\n    case XML_ROLE_IGNORE_SECT: {\n      enum XML_Error result;\n      if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n      handleDefault = XML_FALSE;\n      result = doIgnoreSection(parser, enc, &next, end, nextPtr, haveMore);\n      if (result != XML_ERROR_NONE)\n        return result;\n      else if (! next) {\n        parser->m_processor = ignoreSectionProcessor;\n        return result;\n      }\n    } break;\n#endif /* XML_DTD */\n    case XML_ROLE_GROUP_OPEN:\n      if (parser->m_prologState.level >= parser->m_groupSize) {\n        if (parser->m_groupSize) {\n          {\n            /* Detect and prevent integer overflow */\n            if (parser->m_groupSize > (unsigned int)(-1) / 2u) {\n              return XML_ERROR_NO_MEMORY;\n            }\n\n            char *const new_connector = (char *)REALLOC(\n                parser, parser->m_groupConnector, parser->m_groupSize *= 2);\n            if (new_connector == NULL) {\n              parser->m_groupSize /= 2;\n              return XML_ERROR_NO_MEMORY;\n            }\n            parser->m_groupConnector = new_connector;\n          }\n\n          if (dtd->scaffIndex) {\n            /* Detect and prevent integer overflow.\n             * The preprocessor guard addresses the \"always false\" warning\n             * from -Wtype-limits on platforms where\n             * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */\n#if UINT_MAX >= SIZE_MAX\n            if (parser->m_groupSize > (size_t)(-1) / sizeof(int)) {\n              return XML_ERROR_NO_MEMORY;\n            }\n#endif\n\n            int *const new_scaff_index = (int *)REALLOC(\n                parser, dtd->scaffIndex, parser->m_groupSize * sizeof(int));\n            if (new_scaff_index == NULL)\n              return XML_ERROR_NO_MEMORY;\n            dtd->scaffIndex = new_scaff_index;\n          }\n        } else {\n          parser->m_groupConnector\n              = (char *)MALLOC(parser, parser->m_groupSize = 32);\n          if (! parser->m_groupConnector) {\n            parser->m_groupSize = 0;\n            return XML_ERROR_NO_MEMORY;\n          }\n        }\n      }\n      parser->m_groupConnector[parser->m_prologState.level] = 0;\n      if (dtd->in_eldecl) {\n        int myindex = nextScaffoldPart(parser);\n        if (myindex < 0)\n          return XML_ERROR_NO_MEMORY;\n        assert(dtd->scaffIndex != NULL);\n        dtd->scaffIndex[dtd->scaffLevel] = myindex;\n        dtd->scaffLevel++;\n        dtd->scaffold[myindex].type = XML_CTYPE_SEQ;\n        if (parser->m_elementDeclHandler)\n          handleDefault = XML_FALSE;\n      }\n      break;\n    case XML_ROLE_GROUP_SEQUENCE:\n      if (parser->m_groupConnector[parser->m_prologState.level] == ASCII_PIPE)\n        return XML_ERROR_SYNTAX;\n      parser->m_groupConnector[parser->m_prologState.level] = ASCII_COMMA;\n      if (dtd->in_eldecl && parser->m_elementDeclHandler)\n        handleDefault = XML_FALSE;\n      break;\n    case XML_ROLE_GROUP_CHOICE:\n      if (parser->m_groupConnector[parser->m_prologState.level] == ASCII_COMMA)\n        return XML_ERROR_SYNTAX;\n      if (dtd->in_eldecl\n          && ! parser->m_groupConnector[parser->m_prologState.level]\n          && (dtd->scaffold[dtd->scaffIndex[dtd->scaffLevel - 1]].type\n              != XML_CTYPE_MIXED)) {\n        dtd->scaffold[dtd->scaffIndex[dtd->scaffLevel - 1]].type\n            = XML_CTYPE_CHOICE;\n        if (parser->m_elementDeclHandler)\n          handleDefault = XML_FALSE;\n      }\n      parser->m_groupConnector[parser->m_prologState.level] = ASCII_PIPE;\n      break;\n    case XML_ROLE_PARAM_ENTITY_REF:\n#ifdef XML_DTD\n    case XML_ROLE_INNER_PARAM_ENTITY_REF:\n      dtd->hasParamEntityRefs = XML_TRUE;\n      if (! parser->m_paramEntityParsing)\n        dtd->keepProcessing = dtd->standalone;\n      else {\n        const XML_Char *name;\n        ENTITY *entity;\n        name = poolStoreString(&dtd->pool, enc, s + enc->minBytesPerChar,\n                               next - enc->minBytesPerChar);\n        if (! name)\n          return XML_ERROR_NO_MEMORY;\n        entity = (ENTITY *)lookup(parser, &dtd->paramEntities, name, 0);\n        poolDiscard(&dtd->pool);\n        /* first, determine if a check for an existing declaration is needed;\n           if yes, check that the entity exists, and that it is internal,\n           otherwise call the skipped entity handler\n        */\n        if (parser->m_prologState.documentEntity\n            && (dtd->standalone ? ! parser->m_openInternalEntities\n                                : ! dtd->hasParamEntityRefs)) {\n          if (! entity)\n            return XML_ERROR_UNDEFINED_ENTITY;\n          else if (! entity->is_internal) {\n            /* It's hard to exhaustively search the code to be sure,\n             * but there doesn't seem to be a way of executing the\n             * following line.  There are two cases:\n             *\n             * If 'standalone' is false, the DTD must have no\n             * parameter entities or we wouldn't have passed the outer\n             * 'if' statement.  That means the only entity in the hash\n             * table is the external subset name \"#\" which cannot be\n             * given as a parameter entity name in XML syntax, so the\n             * lookup must have returned NULL and we don't even reach\n             * the test for an internal entity.\n             *\n             * If 'standalone' is true, it does not seem to be\n             * possible to create entities taking this code path that\n             * are not internal entities, so fail the test above.\n             *\n             * Because this analysis is very uncertain, the code is\n             * being left in place and merely removed from the\n             * coverage test statistics.\n             */\n            return XML_ERROR_ENTITY_DECLARED_IN_PE; /* LCOV_EXCL_LINE */\n          }\n        } else if (! entity) {\n          dtd->keepProcessing = dtd->standalone;\n          /* cannot report skipped entities in declarations */\n          if ((role == XML_ROLE_PARAM_ENTITY_REF)\n              && parser->m_skippedEntityHandler) {\n            parser->m_skippedEntityHandler(parser->m_handlerArg, name, 1);\n            handleDefault = XML_FALSE;\n          }\n          break;\n        }\n        if (entity->open)\n          return XML_ERROR_RECURSIVE_ENTITY_REF;\n        if (entity->textPtr) {\n          enum XML_Error result;\n          XML_Bool betweenDecl\n              = (role == XML_ROLE_PARAM_ENTITY_REF ? XML_TRUE : XML_FALSE);\n          result = processInternalEntity(parser, entity, betweenDecl);\n          if (result != XML_ERROR_NONE)\n            return result;\n          handleDefault = XML_FALSE;\n          break;\n        }\n        if (parser->m_externalEntityRefHandler) {\n          dtd->paramEntityRead = XML_FALSE;\n          entity->open = XML_TRUE;\n          entityTrackingOnOpen(parser, entity, __LINE__);\n          if (! parser->m_externalEntityRefHandler(\n                  parser->m_externalEntityRefHandlerArg, 0, entity->base,\n                  entity->systemId, entity->publicId)) {\n            entityTrackingOnClose(parser, entity, __LINE__);\n            entity->open = XML_FALSE;\n            return XML_ERROR_EXTERNAL_ENTITY_HANDLING;\n          }\n          entityTrackingOnClose(parser, entity, __LINE__);\n          entity->open = XML_FALSE;\n          handleDefault = XML_FALSE;\n          if (! dtd->paramEntityRead) {\n            dtd->keepProcessing = dtd->standalone;\n            break;\n          }\n        } else {\n          dtd->keepProcessing = dtd->standalone;\n          break;\n        }\n      }\n#endif /* XML_DTD */\n      if (! dtd->standalone && parser->m_notStandaloneHandler\n          && ! parser->m_notStandaloneHandler(parser->m_handlerArg))\n        return XML_ERROR_NOT_STANDALONE;\n      break;\n\n      /* Element declaration stuff */\n\n    case XML_ROLE_ELEMENT_NAME:\n      if (parser->m_elementDeclHandler) {\n        parser->m_declElementType = getElementType(parser, enc, s, next);\n        if (! parser->m_declElementType)\n          return XML_ERROR_NO_MEMORY;\n        dtd->scaffLevel = 0;\n        dtd->scaffCount = 0;\n        dtd->in_eldecl = XML_TRUE;\n        handleDefault = XML_FALSE;\n      }\n      break;\n\n    case XML_ROLE_CONTENT_ANY:\n    case XML_ROLE_CONTENT_EMPTY:\n      if (dtd->in_eldecl) {\n        if (parser->m_elementDeclHandler) {\n          XML_Content *content\n              = (XML_Content *)MALLOC(parser, sizeof(XML_Content));\n          if (! content)\n            return XML_ERROR_NO_MEMORY;\n          content->quant = XML_CQUANT_NONE;\n          content->name = NULL;\n          content->numchildren = 0;\n          content->children = NULL;\n          content->type = ((role == XML_ROLE_CONTENT_ANY) ? XML_CTYPE_ANY\n                                                          : XML_CTYPE_EMPTY);\n          *eventEndPP = s;\n          parser->m_elementDeclHandler(\n              parser->m_handlerArg, parser->m_declElementType->name, content);\n          handleDefault = XML_FALSE;\n        }\n        dtd->in_eldecl = XML_FALSE;\n      }\n      break;\n\n    case XML_ROLE_CONTENT_PCDATA:\n      if (dtd->in_eldecl) {\n        dtd->scaffold[dtd->scaffIndex[dtd->scaffLevel - 1]].type\n            = XML_CTYPE_MIXED;\n        if (parser->m_elementDeclHandler)\n          handleDefault = XML_FALSE;\n      }\n      break;\n\n    case XML_ROLE_CONTENT_ELEMENT:\n      quant = XML_CQUANT_NONE;\n      goto elementContent;\n    case XML_ROLE_CONTENT_ELEMENT_OPT:\n      quant = XML_CQUANT_OPT;\n      goto elementContent;\n    case XML_ROLE_CONTENT_ELEMENT_REP:\n      quant = XML_CQUANT_REP;\n      goto elementContent;\n    case XML_ROLE_CONTENT_ELEMENT_PLUS:\n      quant = XML_CQUANT_PLUS;\n    elementContent:\n      if (dtd->in_eldecl) {\n        ELEMENT_TYPE *el;\n        const XML_Char *name;\n        size_t nameLen;\n        const char *nxt\n            = (quant == XML_CQUANT_NONE ? next : next - enc->minBytesPerChar);\n        int myindex = nextScaffoldPart(parser);\n        if (myindex < 0)\n          return XML_ERROR_NO_MEMORY;\n        dtd->scaffold[myindex].type = XML_CTYPE_NAME;\n        dtd->scaffold[myindex].quant = quant;\n        el = getElementType(parser, enc, s, nxt);\n        if (! el)\n          return XML_ERROR_NO_MEMORY;\n        name = el->name;\n        dtd->scaffold[myindex].name = name;\n        nameLen = 0;\n        for (; name[nameLen++];)\n          ;\n\n        /* Detect and prevent integer overflow */\n        if (nameLen > UINT_MAX - dtd->contentStringLen) {\n          return XML_ERROR_NO_MEMORY;\n        }\n\n        dtd->contentStringLen += (unsigned)nameLen;\n        if (parser->m_elementDeclHandler)\n          handleDefault = XML_FALSE;\n      }\n      break;\n\n    case XML_ROLE_GROUP_CLOSE:\n      quant = XML_CQUANT_NONE;\n      goto closeGroup;\n    case XML_ROLE_GROUP_CLOSE_OPT:\n      quant = XML_CQUANT_OPT;\n      goto closeGroup;\n    case XML_ROLE_GROUP_CLOSE_REP:\n      quant = XML_CQUANT_REP;\n      goto closeGroup;\n    case XML_ROLE_GROUP_CLOSE_PLUS:\n      quant = XML_CQUANT_PLUS;\n    closeGroup:\n      if (dtd->in_eldecl) {\n        if (parser->m_elementDeclHandler)\n          handleDefault = XML_FALSE;\n        dtd->scaffLevel--;\n        dtd->scaffold[dtd->scaffIndex[dtd->scaffLevel]].quant = quant;\n        if (dtd->scaffLevel == 0) {\n          if (! handleDefault) {\n            XML_Content *model = build_model(parser);\n            if (! model)\n              return XML_ERROR_NO_MEMORY;\n            *eventEndPP = s;\n            parser->m_elementDeclHandler(\n                parser->m_handlerArg, parser->m_declElementType->name, model);\n          }\n          dtd->in_eldecl = XML_FALSE;\n          dtd->contentStringLen = 0;\n        }\n      }\n      break;\n      /* End element declaration stuff */\n\n    case XML_ROLE_PI:\n      if (! reportProcessingInstruction(parser, enc, s, next))\n        return XML_ERROR_NO_MEMORY;\n      handleDefault = XML_FALSE;\n      break;\n    case XML_ROLE_COMMENT:\n      if (! reportComment(parser, enc, s, next))\n        return XML_ERROR_NO_MEMORY;\n      handleDefault = XML_FALSE;\n      break;\n    case XML_ROLE_NONE:\n      switch (tok) {\n      case XML_TOK_BOM:\n        handleDefault = XML_FALSE;\n        break;\n      }\n      break;\n    case XML_ROLE_DOCTYPE_NONE:\n      if (parser->m_startDoctypeDeclHandler)\n        handleDefault = XML_FALSE;\n      break;\n    case XML_ROLE_ENTITY_NONE:\n      if (dtd->keepProcessing && parser->m_entityDeclHandler)\n        handleDefault = XML_FALSE;\n      break;\n    case XML_ROLE_NOTATION_NONE:\n      if (parser->m_notationDeclHandler)\n        handleDefault = XML_FALSE;\n      break;\n    case XML_ROLE_ATTLIST_NONE:\n      if (dtd->keepProcessing && parser->m_attlistDeclHandler)\n        handleDefault = XML_FALSE;\n      break;\n    case XML_ROLE_ELEMENT_NONE:\n      if (parser->m_elementDeclHandler)\n        handleDefault = XML_FALSE;\n      break;\n    } /* end of big switch */\n\n    if (handleDefault && parser->m_defaultHandler)\n      reportDefault(parser, enc, s, next);\n\n    switch (parser->m_parsingStatus.parsing) {\n    case XML_SUSPENDED:\n      *nextPtr = next;\n      return XML_ERROR_NONE;\n    case XML_FINISHED:\n      return XML_ERROR_ABORTED;\n    default:\n      s = next;\n      tok = XmlPrologTok(enc, s, end, &next);\n    }\n  }\n  /* not reached */\n}\n\nstatic enum XML_Error PTRCALL\nepilogProcessor(XML_Parser parser, const char *s, const char *end,\n                const char **nextPtr) {\n  parser->m_processor = epilogProcessor;\n  parser->m_eventPtr = s;\n  for (;;) {\n    const char *next = NULL;\n    int tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n#ifdef XML_DTD\n    if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                  XML_ACCOUNT_DIRECT)) {\n      accountingOnAbort(parser);\n      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n    }\n#endif\n    parser->m_eventEndPtr = next;\n    switch (tok) {\n    /* report partial linebreak - it might be the last token */\n    case -XML_TOK_PROLOG_S:\n      if (parser->m_defaultHandler) {\n        reportDefault(parser, parser->m_encoding, s, next);\n        if (parser->m_parsingStatus.parsing == XML_FINISHED)\n          return XML_ERROR_ABORTED;\n      }\n      *nextPtr = next;\n      return XML_ERROR_NONE;\n    case XML_TOK_NONE:\n      *nextPtr = s;\n      return XML_ERROR_NONE;\n    case XML_TOK_PROLOG_S:\n      if (parser->m_defaultHandler)\n        reportDefault(parser, parser->m_encoding, s, next);\n      break;\n    case XML_TOK_PI:\n      if (! reportProcessingInstruction(parser, parser->m_encoding, s, next))\n        return XML_ERROR_NO_MEMORY;\n      break;\n    case XML_TOK_COMMENT:\n      if (! reportComment(parser, parser->m_encoding, s, next))\n        return XML_ERROR_NO_MEMORY;\n      break;\n    case XML_TOK_INVALID:\n      parser->m_eventPtr = next;\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_PARTIAL:\n      if (! parser->m_parsingStatus.finalBuffer) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      return XML_ERROR_UNCLOSED_TOKEN;\n    case XML_TOK_PARTIAL_CHAR:\n      if (! parser->m_parsingStatus.finalBuffer) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      return XML_ERROR_PARTIAL_CHAR;\n    default:\n      return XML_ERROR_JUNK_AFTER_DOC_ELEMENT;\n    }\n    parser->m_eventPtr = s = next;\n    switch (parser->m_parsingStatus.parsing) {\n    case XML_SUSPENDED:\n      *nextPtr = next;\n      return XML_ERROR_NONE;\n    case XML_FINISHED:\n      return XML_ERROR_ABORTED;\n    default:;\n    }\n  }\n}\n\nstatic enum XML_Error\nprocessInternalEntity(XML_Parser parser, ENTITY *entity, XML_Bool betweenDecl) {\n  const char *textStart, *textEnd;\n  const char *next;\n  enum XML_Error result;\n  OPEN_INTERNAL_ENTITY *openEntity;\n\n  if (parser->m_freeInternalEntities) {\n    openEntity = parser->m_freeInternalEntities;\n    parser->m_freeInternalEntities = openEntity->next;\n  } else {\n    openEntity\n        = (OPEN_INTERNAL_ENTITY *)MALLOC(parser, sizeof(OPEN_INTERNAL_ENTITY));\n    if (! openEntity)\n      return XML_ERROR_NO_MEMORY;\n  }\n  entity->open = XML_TRUE;\n#ifdef XML_DTD\n  entityTrackingOnOpen(parser, entity, __LINE__);\n#endif\n  entity->processed = 0;\n  openEntity->next = parser->m_openInternalEntities;\n  parser->m_openInternalEntities = openEntity;\n  openEntity->entity = entity;\n  openEntity->startTagLevel = parser->m_tagLevel;\n  openEntity->betweenDecl = betweenDecl;\n  openEntity->internalEventPtr = NULL;\n  openEntity->internalEventEndPtr = NULL;\n  textStart = (const char *)entity->textPtr;\n  textEnd = (const char *)(entity->textPtr + entity->textLen);\n  /* Set a safe default value in case 'next' does not get set */\n  next = textStart;\n\n#ifdef XML_DTD\n  if (entity->is_param) {\n    int tok\n        = XmlPrologTok(parser->m_internalEncoding, textStart, textEnd, &next);\n    result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd,\n                      tok, next, &next, XML_FALSE, XML_FALSE,\n                      XML_ACCOUNT_ENTITY_EXPANSION);\n  } else\n#endif /* XML_DTD */\n    result = doContent(parser, parser->m_tagLevel, parser->m_internalEncoding,\n                       textStart, textEnd, &next, XML_FALSE,\n                       XML_ACCOUNT_ENTITY_EXPANSION);\n\n  if (result == XML_ERROR_NONE) {\n    if (textEnd != next && parser->m_parsingStatus.parsing == XML_SUSPENDED) {\n      entity->processed = (int)(next - textStart);\n      parser->m_processor = internalEntityProcessor;\n    } else {\n#ifdef XML_DTD\n      entityTrackingOnClose(parser, entity, __LINE__);\n#endif /* XML_DTD */\n      entity->open = XML_FALSE;\n      parser->m_openInternalEntities = openEntity->next;\n      /* put openEntity back in list of free instances */\n      openEntity->next = parser->m_freeInternalEntities;\n      parser->m_freeInternalEntities = openEntity;\n    }\n  }\n  return result;\n}\n\nstatic enum XML_Error PTRCALL\ninternalEntityProcessor(XML_Parser parser, const char *s, const char *end,\n                        const char **nextPtr) {\n  ENTITY *entity;\n  const char *textStart, *textEnd;\n  const char *next;\n  enum XML_Error result;\n  OPEN_INTERNAL_ENTITY *openEntity = parser->m_openInternalEntities;\n  if (! openEntity)\n    return XML_ERROR_UNEXPECTED_STATE;\n\n  entity = openEntity->entity;\n  textStart = ((const char *)entity->textPtr) + entity->processed;\n  textEnd = (const char *)(entity->textPtr + entity->textLen);\n  /* Set a safe default value in case 'next' does not get set */\n  next = textStart;\n\n#ifdef XML_DTD\n  if (entity->is_param) {\n    int tok\n        = XmlPrologTok(parser->m_internalEncoding, textStart, textEnd, &next);\n    result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd,\n                      tok, next, &next, XML_FALSE, XML_TRUE,\n                      XML_ACCOUNT_ENTITY_EXPANSION);\n  } else\n#endif /* XML_DTD */\n    result = doContent(parser, openEntity->startTagLevel,\n                       parser->m_internalEncoding, textStart, textEnd, &next,\n                       XML_FALSE, XML_ACCOUNT_ENTITY_EXPANSION);\n\n  if (result != XML_ERROR_NONE)\n    return result;\n\n  if (textEnd != next && parser->m_parsingStatus.parsing == XML_SUSPENDED) {\n    entity->processed = (int)(next - (const char *)entity->textPtr);\n    return result;\n  }\n\n#ifdef XML_DTD\n  entityTrackingOnClose(parser, entity, __LINE__);\n#endif\n  entity->open = XML_FALSE;\n  parser->m_openInternalEntities = openEntity->next;\n  /* put openEntity back in list of free instances */\n  openEntity->next = parser->m_freeInternalEntities;\n  parser->m_freeInternalEntities = openEntity;\n\n  // If there are more open entities we want to stop right here and have the\n  // upcoming call to XML_ResumeParser continue with entity content, or it would\n  // be ignored altogether.\n  if (parser->m_openInternalEntities != NULL\n      && parser->m_parsingStatus.parsing == XML_SUSPENDED) {\n    return XML_ERROR_NONE;\n  }\n\n#ifdef XML_DTD\n  if (entity->is_param) {\n    int tok;\n    parser->m_processor = prologProcessor;\n    tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n    return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                    (XML_Bool)! parser->m_parsingStatus.finalBuffer, XML_TRUE,\n                    XML_ACCOUNT_DIRECT);\n  } else\n#endif /* XML_DTD */\n  {\n    parser->m_processor = contentProcessor;\n    /* see externalEntityContentProcessor vs contentProcessor */\n    result = doContent(parser, parser->m_parentParser ? 1 : 0,\n                       parser->m_encoding, s, end, nextPtr,\n                       (XML_Bool)! parser->m_parsingStatus.finalBuffer,\n                       XML_ACCOUNT_DIRECT);\n    if (result == XML_ERROR_NONE) {\n      if (! storeRawNames(parser))\n        return XML_ERROR_NO_MEMORY;\n    }\n    return result;\n  }\n}\n\nstatic enum XML_Error PTRCALL\nerrorProcessor(XML_Parser parser, const char *s, const char *end,\n               const char **nextPtr) {\n  UNUSED_P(s);\n  UNUSED_P(end);\n  UNUSED_P(nextPtr);\n  return parser->m_errorCode;\n}\n\nstatic enum XML_Error\nstoreAttributeValue(XML_Parser parser, const ENCODING *enc, XML_Bool isCdata,\n                    const char *ptr, const char *end, STRING_POOL *pool,\n                    enum XML_Account account) {\n  enum XML_Error result\n      = appendAttributeValue(parser, enc, isCdata, ptr, end, pool, account);\n  if (result)\n    return result;\n  if (! isCdata && poolLength(pool) && poolLastChar(pool) == 0x20)\n    poolChop(pool);\n  if (! poolAppendChar(pool, XML_T('\\0')))\n    return XML_ERROR_NO_MEMORY;\n  return XML_ERROR_NONE;\n}\n\nstatic enum XML_Error\nappendAttributeValue(XML_Parser parser, const ENCODING *enc, XML_Bool isCdata,\n                     const char *ptr, const char *end, STRING_POOL *pool,\n                     enum XML_Account account) {\n  DTD *const dtd = parser->m_dtd; /* save one level of indirection */\n#ifndef XML_DTD\n  UNUSED_P(account);\n#endif\n\n  for (;;) {\n    const char *next\n        = ptr; /* XmlAttributeValueTok doesn't always set the last arg */\n    int tok = XmlAttributeValueTok(enc, ptr, end, &next);\n#ifdef XML_DTD\n    if (! accountingDiffTolerated(parser, tok, ptr, next, __LINE__, account)) {\n      accountingOnAbort(parser);\n      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n    }\n#endif\n    switch (tok) {\n    case XML_TOK_NONE:\n      return XML_ERROR_NONE;\n    case XML_TOK_INVALID:\n      if (enc == parser->m_encoding)\n        parser->m_eventPtr = next;\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_PARTIAL:\n      if (enc == parser->m_encoding)\n        parser->m_eventPtr = ptr;\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_CHAR_REF: {\n      XML_Char buf[XML_ENCODE_MAX];\n      int i;\n      int n = XmlCharRefNumber(enc, ptr);\n      if (n < 0) {\n        if (enc == parser->m_encoding)\n          parser->m_eventPtr = ptr;\n        return XML_ERROR_BAD_CHAR_REF;\n      }\n      if (! isCdata && n == 0x20 /* space */\n          && (poolLength(pool) == 0 || poolLastChar(pool) == 0x20))\n        break;\n      n = XmlEncode(n, (ICHAR *)buf);\n      /* The XmlEncode() functions can never return 0 here.  That\n       * error return happens if the code point passed in is either\n       * negative or greater than or equal to 0x110000.  The\n       * XmlCharRefNumber() functions will all return a number\n       * strictly less than 0x110000 or a negative value if an error\n       * occurred.  The negative value is intercepted above, so\n       * XmlEncode() is never passed a value it might return an\n       * error for.\n       */\n      for (i = 0; i < n; i++) {\n        if (! poolAppendChar(pool, buf[i]))\n          return XML_ERROR_NO_MEMORY;\n      }\n    } break;\n    case XML_TOK_DATA_CHARS:\n      if (! poolAppend(pool, enc, ptr, next))\n        return XML_ERROR_NO_MEMORY;\n      break;\n    case XML_TOK_TRAILING_CR:\n      next = ptr + enc->minBytesPerChar;\n      /* fall through */\n    case XML_TOK_ATTRIBUTE_VALUE_S:\n    case XML_TOK_DATA_NEWLINE:\n      if (! isCdata && (poolLength(pool) == 0 || poolLastChar(pool) == 0x20))\n        break;\n      if (! poolAppendChar(pool, 0x20))\n        return XML_ERROR_NO_MEMORY;\n      break;\n    case XML_TOK_ENTITY_REF: {\n      const XML_Char *name;\n      ENTITY *entity;\n      char checkEntityDecl;\n      XML_Char ch = (XML_Char)XmlPredefinedEntityName(\n          enc, ptr + enc->minBytesPerChar, next - enc->minBytesPerChar);\n      if (ch) {\n#ifdef XML_DTD\n        /* NOTE: We are replacing 4-6 characters original input for 1 character\n         *       so there is no amplification and hence recording without\n         *       protection. */\n        accountingDiffTolerated(parser, tok, (char *)&ch,\n                                ((char *)&ch) + sizeof(XML_Char), __LINE__,\n                                XML_ACCOUNT_ENTITY_EXPANSION);\n#endif /* XML_DTD */\n        if (! poolAppendChar(pool, ch))\n          return XML_ERROR_NO_MEMORY;\n        break;\n      }\n      name = poolStoreString(&parser->m_temp2Pool, enc,\n                             ptr + enc->minBytesPerChar,\n                             next - enc->minBytesPerChar);\n      if (! name)\n        return XML_ERROR_NO_MEMORY;\n      entity = (ENTITY *)lookup(parser, &dtd->generalEntities, name, 0);\n      poolDiscard(&parser->m_temp2Pool);\n      /* First, determine if a check for an existing declaration is needed;\n         if yes, check that the entity exists, and that it is internal.\n      */\n      if (pool == &dtd->pool) /* are we called from prolog? */\n        checkEntityDecl =\n#ifdef XML_DTD\n            parser->m_prologState.documentEntity &&\n#endif /* XML_DTD */\n            (dtd->standalone ? ! parser->m_openInternalEntities\n                             : ! dtd->hasParamEntityRefs);\n      else /* if (pool == &parser->m_tempPool): we are called from content */\n        checkEntityDecl = ! dtd->hasParamEntityRefs || dtd->standalone;\n      if (checkEntityDecl) {\n        if (! entity)\n          return XML_ERROR_UNDEFINED_ENTITY;\n        else if (! entity->is_internal)\n          return XML_ERROR_ENTITY_DECLARED_IN_PE;\n      } else if (! entity) {\n        /* Cannot report skipped entity here - see comments on\n           parser->m_skippedEntityHandler.\n        if (parser->m_skippedEntityHandler)\n          parser->m_skippedEntityHandler(parser->m_handlerArg, name, 0);\n        */\n        /* Cannot call the default handler because this would be\n           out of sync with the call to the startElementHandler.\n        if ((pool == &parser->m_tempPool) && parser->m_defaultHandler)\n          reportDefault(parser, enc, ptr, next);\n        */\n        break;\n      }\n      if (entity->open) {\n        if (enc == parser->m_encoding) {\n          /* It does not appear that this line can be executed.\n           *\n           * The \"if (entity->open)\" check catches recursive entity\n           * definitions.  In order to be called with an open\n           * entity, it must have gone through this code before and\n           * been through the recursive call to\n           * appendAttributeValue() some lines below.  That call\n           * sets the local encoding (\"enc\") to the parser's\n           * internal encoding (internal_utf8 or internal_utf16),\n           * which can never be the same as the principle encoding.\n           * It doesn't appear there is another code path that gets\n           * here with entity->open being TRUE.\n           *\n           * Since it is not certain that this logic is watertight,\n           * we keep the line and merely exclude it from coverage\n           * tests.\n           */\n          parser->m_eventPtr = ptr; /* LCOV_EXCL_LINE */\n        }\n        return XML_ERROR_RECURSIVE_ENTITY_REF;\n      }\n      if (entity->notation) {\n        if (enc == parser->m_encoding)\n          parser->m_eventPtr = ptr;\n        return XML_ERROR_BINARY_ENTITY_REF;\n      }\n      if (! entity->textPtr) {\n        if (enc == parser->m_encoding)\n          parser->m_eventPtr = ptr;\n        return XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF;\n      } else {\n        enum XML_Error result;\n        const XML_Char *textEnd = entity->textPtr + entity->textLen;\n        entity->open = XML_TRUE;\n#ifdef XML_DTD\n        entityTrackingOnOpen(parser, entity, __LINE__);\n#endif\n        result = appendAttributeValue(parser, parser->m_internalEncoding,\n                                      isCdata, (const char *)entity->textPtr,\n                                      (const char *)textEnd, pool,\n                                      XML_ACCOUNT_ENTITY_EXPANSION);\n#ifdef XML_DTD\n        entityTrackingOnClose(parser, entity, __LINE__);\n#endif\n        entity->open = XML_FALSE;\n        if (result)\n          return result;\n      }\n    } break;\n    default:\n      /* The only token returned by XmlAttributeValueTok() that does\n       * not have an explicit case here is XML_TOK_PARTIAL_CHAR.\n       * Getting that would require an entity name to contain an\n       * incomplete XML character (e.g. \\xE2\\x82); however previous\n       * tokenisers will have already recognised and rejected such\n       * names before XmlAttributeValueTok() gets a look-in.  This\n       * default case should be retained as a safety net, but the code\n       * excluded from coverage tests.\n       *\n       * LCOV_EXCL_START\n       */\n      if (enc == parser->m_encoding)\n        parser->m_eventPtr = ptr;\n      return XML_ERROR_UNEXPECTED_STATE;\n      /* LCOV_EXCL_STOP */\n    }\n    ptr = next;\n  }\n  /* not reached */\n}\n\nstatic enum XML_Error\nstoreEntityValue(XML_Parser parser, const ENCODING *enc,\n                 const char *entityTextPtr, const char *entityTextEnd,\n                 enum XML_Account account) {\n  DTD *const dtd = parser->m_dtd; /* save one level of indirection */\n  STRING_POOL *pool = &(dtd->entityValuePool);\n  enum XML_Error result = XML_ERROR_NONE;\n#ifdef XML_DTD\n  int oldInEntityValue = parser->m_prologState.inEntityValue;\n  parser->m_prologState.inEntityValue = 1;\n#else\n  UNUSED_P(account);\n#endif /* XML_DTD */\n  /* never return Null for the value argument in EntityDeclHandler,\n     since this would indicate an external entity; therefore we\n     have to make sure that entityValuePool.start is not null */\n  if (! pool->blocks) {\n    if (! poolGrow(pool))\n      return XML_ERROR_NO_MEMORY;\n  }\n\n  for (;;) {\n    const char *next\n        = entityTextPtr; /* XmlEntityValueTok doesn't always set the last arg */\n    int tok = XmlEntityValueTok(enc, entityTextPtr, entityTextEnd, &next);\n\n#ifdef XML_DTD\n    if (! accountingDiffTolerated(parser, tok, entityTextPtr, next, __LINE__,\n                                  account)) {\n      accountingOnAbort(parser);\n      result = XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n      goto endEntityValue;\n    }\n#endif\n\n    switch (tok) {\n    case XML_TOK_PARAM_ENTITY_REF:\n#ifdef XML_DTD\n      if (parser->m_isParamEntity || enc != parser->m_encoding) {\n        const XML_Char *name;\n        ENTITY *entity;\n        name = poolStoreString(&parser->m_tempPool, enc,\n                               entityTextPtr + enc->minBytesPerChar,\n                               next - enc->minBytesPerChar);\n        if (! name) {\n          result = XML_ERROR_NO_MEMORY;\n          goto endEntityValue;\n        }\n        entity = (ENTITY *)lookup(parser, &dtd->paramEntities, name, 0);\n        poolDiscard(&parser->m_tempPool);\n        if (! entity) {\n          /* not a well-formedness error - see XML 1.0: WFC Entity Declared */\n          /* cannot report skipped entity here - see comments on\n             parser->m_skippedEntityHandler\n          if (parser->m_skippedEntityHandler)\n            parser->m_skippedEntityHandler(parser->m_handlerArg, name, 0);\n          */\n          dtd->keepProcessing = dtd->standalone;\n          goto endEntityValue;\n        }\n        if (entity->open) {\n          if (enc == parser->m_encoding)\n            parser->m_eventPtr = entityTextPtr;\n          result = XML_ERROR_RECURSIVE_ENTITY_REF;\n          goto endEntityValue;\n        }\n        if (entity->systemId) {\n          if (parser->m_externalEntityRefHandler) {\n            dtd->paramEntityRead = XML_FALSE;\n            entity->open = XML_TRUE;\n            entityTrackingOnOpen(parser, entity, __LINE__);\n            if (! parser->m_externalEntityRefHandler(\n                    parser->m_externalEntityRefHandlerArg, 0, entity->base,\n                    entity->systemId, entity->publicId)) {\n              entityTrackingOnClose(parser, entity, __LINE__);\n              entity->open = XML_FALSE;\n              result = XML_ERROR_EXTERNAL_ENTITY_HANDLING;\n              goto endEntityValue;\n            }\n            entityTrackingOnClose(parser, entity, __LINE__);\n            entity->open = XML_FALSE;\n            if (! dtd->paramEntityRead)\n              dtd->keepProcessing = dtd->standalone;\n          } else\n            dtd->keepProcessing = dtd->standalone;\n        } else {\n          entity->open = XML_TRUE;\n          entityTrackingOnOpen(parser, entity, __LINE__);\n          result = storeEntityValue(\n              parser, parser->m_internalEncoding, (const char *)entity->textPtr,\n              (const char *)(entity->textPtr + entity->textLen),\n              XML_ACCOUNT_ENTITY_EXPANSION);\n          entityTrackingOnClose(parser, entity, __LINE__);\n          entity->open = XML_FALSE;\n          if (result)\n            goto endEntityValue;\n        }\n        break;\n      }\n#endif /* XML_DTD */\n      /* In the internal subset, PE references are not legal\n         within markup declarations, e.g entity values in this case. */\n      parser->m_eventPtr = entityTextPtr;\n      result = XML_ERROR_PARAM_ENTITY_REF;\n      goto endEntityValue;\n    case XML_TOK_NONE:\n      result = XML_ERROR_NONE;\n      goto endEntityValue;\n    case XML_TOK_ENTITY_REF:\n    case XML_TOK_DATA_CHARS:\n      if (! poolAppend(pool, enc, entityTextPtr, next)) {\n        result = XML_ERROR_NO_MEMORY;\n        goto endEntityValue;\n      }\n      break;\n    case XML_TOK_TRAILING_CR:\n      next = entityTextPtr + enc->minBytesPerChar;\n      /* fall through */\n    case XML_TOK_DATA_NEWLINE:\n      if (pool->end == pool->ptr && ! poolGrow(pool)) {\n        result = XML_ERROR_NO_MEMORY;\n        goto endEntityValue;\n      }\n      *(pool->ptr)++ = 0xA;\n      break;\n    case XML_TOK_CHAR_REF: {\n      XML_Char buf[XML_ENCODE_MAX];\n      int i;\n      int n = XmlCharRefNumber(enc, entityTextPtr);\n      if (n < 0) {\n        if (enc == parser->m_encoding)\n          parser->m_eventPtr = entityTextPtr;\n        result = XML_ERROR_BAD_CHAR_REF;\n        goto endEntityValue;\n      }\n      n = XmlEncode(n, (ICHAR *)buf);\n      /* The XmlEncode() functions can never return 0 here.  That\n       * error return happens if the code point passed in is either\n       * negative or greater than or equal to 0x110000.  The\n       * XmlCharRefNumber() functions will all return a number\n       * strictly less than 0x110000 or a negative value if an error\n       * occurred.  The negative value is intercepted above, so\n       * XmlEncode() is never passed a value it might return an\n       * error for.\n       */\n      for (i = 0; i < n; i++) {\n        if (pool->end == pool->ptr && ! poolGrow(pool)) {\n          result = XML_ERROR_NO_MEMORY;\n          goto endEntityValue;\n        }\n        *(pool->ptr)++ = buf[i];\n      }\n    } break;\n    case XML_TOK_PARTIAL:\n      if (enc == parser->m_encoding)\n        parser->m_eventPtr = entityTextPtr;\n      result = XML_ERROR_INVALID_TOKEN;\n      goto endEntityValue;\n    case XML_TOK_INVALID:\n      if (enc == parser->m_encoding)\n        parser->m_eventPtr = next;\n      result = XML_ERROR_INVALID_TOKEN;\n      goto endEntityValue;\n    default:\n      /* This default case should be unnecessary -- all the tokens\n       * that XmlEntityValueTok() can return have their own explicit\n       * cases -- but should be retained for safety.  We do however\n       * exclude it from the coverage statistics.\n       *\n       * LCOV_EXCL_START\n       */\n      if (enc == parser->m_encoding)\n        parser->m_eventPtr = entityTextPtr;\n      result = XML_ERROR_UNEXPECTED_STATE;\n      goto endEntityValue;\n      /* LCOV_EXCL_STOP */\n    }\n    entityTextPtr = next;\n  }\nendEntityValue:\n#ifdef XML_DTD\n  parser->m_prologState.inEntityValue = oldInEntityValue;\n#endif /* XML_DTD */\n  return result;\n}\n\nstatic void FASTCALL\nnormalizeLines(XML_Char *s) {\n  XML_Char *p;\n  for (;; s++) {\n    if (*s == XML_T('\\0'))\n      return;\n    if (*s == 0xD)\n      break;\n  }\n  p = s;\n  do {\n    if (*s == 0xD) {\n      *p++ = 0xA;\n      if (*++s == 0xA)\n        s++;\n    } else\n      *p++ = *s++;\n  } while (*s);\n  *p = XML_T('\\0');\n}\n\nstatic int\nreportProcessingInstruction(XML_Parser parser, const ENCODING *enc,\n                            const char *start, const char *end) {\n  const XML_Char *target;\n  XML_Char *data;\n  const char *tem;\n  if (! parser->m_processingInstructionHandler) {\n    if (parser->m_defaultHandler)\n      reportDefault(parser, enc, start, end);\n    return 1;\n  }\n  start += enc->minBytesPerChar * 2;\n  tem = start + XmlNameLength(enc, start);\n  target = poolStoreString(&parser->m_tempPool, enc, start, tem);\n  if (! target)\n    return 0;\n  poolFinish(&parser->m_tempPool);\n  data = poolStoreString(&parser->m_tempPool, enc, XmlSkipS(enc, tem),\n                         end - enc->minBytesPerChar * 2);\n  if (! data)\n    return 0;\n  normalizeLines(data);\n  parser->m_processingInstructionHandler(parser->m_handlerArg, target, data);\n  poolClear(&parser->m_tempPool);\n  return 1;\n}\n\nstatic int\nreportComment(XML_Parser parser, const ENCODING *enc, const char *start,\n              const char *end) {\n  XML_Char *data;\n  if (! parser->m_commentHandler) {\n    if (parser->m_defaultHandler)\n      reportDefault(parser, enc, start, end);\n    return 1;\n  }\n  data = poolStoreString(&parser->m_tempPool, enc,\n                         start + enc->minBytesPerChar * 4,\n                         end - enc->minBytesPerChar * 3);\n  if (! data)\n    return 0;\n  normalizeLines(data);\n  parser->m_commentHandler(parser->m_handlerArg, data);\n  poolClear(&parser->m_tempPool);\n  return 1;\n}\n\nstatic void\nreportDefault(XML_Parser parser, const ENCODING *enc, const char *s,\n              const char *end) {\n  if (MUST_CONVERT(enc, s)) {\n    enum XML_Convert_Result convert_res;\n    const char **eventPP;\n    const char **eventEndPP;\n    if (enc == parser->m_encoding) {\n      eventPP = &parser->m_eventPtr;\n      eventEndPP = &parser->m_eventEndPtr;\n    } else {\n      /* To get here, two things must be true; the parser must be\n       * using a character encoding that is not the same as the\n       * encoding passed in, and the encoding passed in must need\n       * conversion to the internal format (UTF-8 unless XML_UNICODE\n       * is defined).  The only occasions on which the encoding passed\n       * in is not the same as the parser's encoding are when it is\n       * the internal encoding (e.g. a previously defined parameter\n       * entity, already converted to internal format).  This by\n       * definition doesn't need conversion, so the whole branch never\n       * gets executed.\n       *\n       * For safety's sake we don't delete these lines and merely\n       * exclude them from coverage statistics.\n       *\n       * LCOV_EXCL_START\n       */\n      eventPP = &(parser->m_openInternalEntities->internalEventPtr);\n      eventEndPP = &(parser->m_openInternalEntities->internalEventEndPtr);\n      /* LCOV_EXCL_STOP */\n    }\n    do {\n      ICHAR *dataPtr = (ICHAR *)parser->m_dataBuf;\n      convert_res\n          = XmlConvert(enc, &s, end, &dataPtr, (ICHAR *)parser->m_dataBufEnd);\n      *eventEndPP = s;\n      parser->m_defaultHandler(parser->m_handlerArg, parser->m_dataBuf,\n                               (int)(dataPtr - (ICHAR *)parser->m_dataBuf));\n      *eventPP = s;\n    } while ((convert_res != XML_CONVERT_COMPLETED)\n             && (convert_res != XML_CONVERT_INPUT_INCOMPLETE));\n  } else\n    parser->m_defaultHandler(\n        parser->m_handlerArg, (const XML_Char *)s,\n        (int)((const XML_Char *)end - (const XML_Char *)s));\n}\n\nstatic int\ndefineAttribute(ELEMENT_TYPE *type, ATTRIBUTE_ID *attId, XML_Bool isCdata,\n                XML_Bool isId, const XML_Char *value, XML_Parser parser) {\n  DEFAULT_ATTRIBUTE *att;\n  if (value || isId) {\n    /* The handling of default attributes gets messed up if we have\n       a default which duplicates a non-default. */\n    int i;\n    for (i = 0; i < type->nDefaultAtts; i++)\n      if (attId == type->defaultAtts[i].id)\n        return 1;\n    if (isId && ! type->idAtt && ! attId->xmlns)\n      type->idAtt = attId;\n  }\n  if (type->nDefaultAtts == type->allocDefaultAtts) {\n    if (type->allocDefaultAtts == 0) {\n      type->allocDefaultAtts = 8;\n      type->defaultAtts = (DEFAULT_ATTRIBUTE *)MALLOC(\n          parser, type->allocDefaultAtts * sizeof(DEFAULT_ATTRIBUTE));\n      if (! type->defaultAtts) {\n        type->allocDefaultAtts = 0;\n        return 0;\n      }\n    } else {\n      DEFAULT_ATTRIBUTE *temp;\n\n      /* Detect and prevent integer overflow */\n      if (type->allocDefaultAtts > INT_MAX / 2) {\n        return 0;\n      }\n\n      int count = type->allocDefaultAtts * 2;\n\n      /* Detect and prevent integer overflow.\n       * The preprocessor guard addresses the \"always false\" warning\n       * from -Wtype-limits on platforms where\n       * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */\n#if UINT_MAX >= SIZE_MAX\n      if ((unsigned)count > (size_t)(-1) / sizeof(DEFAULT_ATTRIBUTE)) {\n        return 0;\n      }\n#endif\n\n      temp = (DEFAULT_ATTRIBUTE *)REALLOC(parser, type->defaultAtts,\n                                          (count * sizeof(DEFAULT_ATTRIBUTE)));\n      if (temp == NULL)\n        return 0;\n      type->allocDefaultAtts = count;\n      type->defaultAtts = temp;\n    }\n  }\n  att = type->defaultAtts + type->nDefaultAtts;\n  att->id = attId;\n  att->value = value;\n  att->isCdata = isCdata;\n  if (! isCdata)\n    attId->maybeTokenized = XML_TRUE;\n  type->nDefaultAtts += 1;\n  return 1;\n}\n\nstatic int\nsetElementTypePrefix(XML_Parser parser, ELEMENT_TYPE *elementType) {\n  DTD *const dtd = parser->m_dtd; /* save one level of indirection */\n  const XML_Char *name;\n  for (name = elementType->name; *name; name++) {\n    if (*name == XML_T(ASCII_COLON)) {\n      PREFIX *prefix;\n      const XML_Char *s;\n      for (s = elementType->name; s != name; s++) {\n        if (! poolAppendChar(&dtd->pool, *s))\n          return 0;\n      }\n      if (! poolAppendChar(&dtd->pool, XML_T('\\0')))\n        return 0;\n      prefix = (PREFIX *)lookup(parser, &dtd->prefixes, poolStart(&dtd->pool),\n                                sizeof(PREFIX));\n      if (! prefix)\n        return 0;\n      if (prefix->name == poolStart(&dtd->pool))\n        poolFinish(&dtd->pool);\n      else\n        poolDiscard(&dtd->pool);\n      elementType->prefix = prefix;\n      break;\n    }\n  }\n  return 1;\n}\n\nstatic ATTRIBUTE_ID *\ngetAttributeId(XML_Parser parser, const ENCODING *enc, const char *start,\n               const char *end) {\n  DTD *const dtd = parser->m_dtd; /* save one level of indirection */\n  ATTRIBUTE_ID *id;\n  const XML_Char *name;\n  if (! poolAppendChar(&dtd->pool, XML_T('\\0')))\n    return NULL;\n  name = poolStoreString(&dtd->pool, enc, start, end);\n  if (! name)\n    return NULL;\n  /* skip quotation mark - its storage will be reused (like in name[-1]) */\n  ++name;\n  id = (ATTRIBUTE_ID *)lookup(parser, &dtd->attributeIds, name,\n                              sizeof(ATTRIBUTE_ID));\n  if (! id)\n    return NULL;\n  if (id->name != name)\n    poolDiscard(&dtd->pool);\n  else {\n    poolFinish(&dtd->pool);\n    if (! parser->m_ns)\n      ;\n    else if (name[0] == XML_T(ASCII_x) && name[1] == XML_T(ASCII_m)\n             && name[2] == XML_T(ASCII_l) && name[3] == XML_T(ASCII_n)\n             && name[4] == XML_T(ASCII_s)\n             && (name[5] == XML_T('\\0') || name[5] == XML_T(ASCII_COLON))) {\n      if (name[5] == XML_T('\\0'))\n        id->prefix = &dtd->defaultPrefix;\n      else\n        id->prefix = (PREFIX *)lookup(parser, &dtd->prefixes, name + 6,\n                                      sizeof(PREFIX));\n      id->xmlns = XML_TRUE;\n    } else {\n      int i;\n      for (i = 0; name[i]; i++) {\n        /* attributes without prefix are *not* in the default namespace */\n        if (name[i] == XML_T(ASCII_COLON)) {\n          int j;\n          for (j = 0; j < i; j++) {\n            if (! poolAppendChar(&dtd->pool, name[j]))\n              return NULL;\n          }\n          if (! poolAppendChar(&dtd->pool, XML_T('\\0')))\n            return NULL;\n          id->prefix = (PREFIX *)lookup(parser, &dtd->prefixes,\n                                        poolStart(&dtd->pool), sizeof(PREFIX));\n          if (! id->prefix)\n            return NULL;\n          if (id->prefix->name == poolStart(&dtd->pool))\n            poolFinish(&dtd->pool);\n          else\n            poolDiscard(&dtd->pool);\n          break;\n        }\n      }\n    }\n  }\n  return id;\n}\n\n#define CONTEXT_SEP XML_T(ASCII_FF)\n\nstatic const XML_Char *\ngetContext(XML_Parser parser) {\n  DTD *const dtd = parser->m_dtd; /* save one level of indirection */\n  HASH_TABLE_ITER iter;\n  XML_Bool needSep = XML_FALSE;\n\n  if (dtd->defaultPrefix.binding) {\n    int i;\n    int len;\n    if (! poolAppendChar(&parser->m_tempPool, XML_T(ASCII_EQUALS)))\n      return NULL;\n    len = dtd->defaultPrefix.binding->uriLen;\n    if (parser->m_namespaceSeparator)\n      len--;\n    for (i = 0; i < len; i++) {\n      if (! poolAppendChar(&parser->m_tempPool,\n                           dtd->defaultPrefix.binding->uri[i])) {\n        /* Because of memory caching, I don't believe this line can be\n         * executed.\n         *\n         * This is part of a loop copying the default prefix binding\n         * URI into the parser's temporary string pool.  Previously,\n         * that URI was copied into the same string pool, with a\n         * terminating NUL character, as part of setContext().  When\n         * the pool was cleared, that leaves a block definitely big\n         * enough to hold the URI on the free block list of the pool.\n         * The URI copy in getContext() therefore cannot run out of\n         * memory.\n         *\n         * If the pool is used between the setContext() and\n         * getContext() calls, the worst it can do is leave a bigger\n         * block on the front of the free list.  Given that this is\n         * all somewhat inobvious and program logic can be changed, we\n         * don't delete the line but we do exclude it from the test\n         * coverage statistics.\n         */\n        return NULL; /* LCOV_EXCL_LINE */\n      }\n    }\n    needSep = XML_TRUE;\n  }\n\n  hashTableIterInit(&iter, &(dtd->prefixes));\n  for (;;) {\n    int i;\n    int len;\n    const XML_Char *s;\n    PREFIX *prefix = (PREFIX *)hashTableIterNext(&iter);\n    if (! prefix)\n      break;\n    if (! prefix->binding) {\n      /* This test appears to be (justifiable) paranoia.  There does\n       * not seem to be a way of injecting a prefix without a binding\n       * that doesn't get errored long before this function is called.\n       * The test should remain for safety's sake, so we instead\n       * exclude the following line from the coverage statistics.\n       */\n      continue; /* LCOV_EXCL_LINE */\n    }\n    if (needSep && ! poolAppendChar(&parser->m_tempPool, CONTEXT_SEP))\n      return NULL;\n    for (s = prefix->name; *s; s++)\n      if (! poolAppendChar(&parser->m_tempPool, *s))\n        return NULL;\n    if (! poolAppendChar(&parser->m_tempPool, XML_T(ASCII_EQUALS)))\n      return NULL;\n    len = prefix->binding->uriLen;\n    if (parser->m_namespaceSeparator)\n      len--;\n    for (i = 0; i < len; i++)\n      if (! poolAppendChar(&parser->m_tempPool, prefix->binding->uri[i]))\n        return NULL;\n    needSep = XML_TRUE;\n  }\n\n  hashTableIterInit(&iter, &(dtd->generalEntities));\n  for (;;) {\n    const XML_Char *s;\n    ENTITY *e = (ENTITY *)hashTableIterNext(&iter);\n    if (! e)\n      break;\n    if (! e->open)\n      continue;\n    if (needSep && ! poolAppendChar(&parser->m_tempPool, CONTEXT_SEP))\n      return NULL;\n    for (s = e->name; *s; s++)\n      if (! poolAppendChar(&parser->m_tempPool, *s))\n        return 0;\n    needSep = XML_TRUE;\n  }\n\n  if (! poolAppendChar(&parser->m_tempPool, XML_T('\\0')))\n    return NULL;\n  return parser->m_tempPool.start;\n}\n\nstatic XML_Bool\nsetContext(XML_Parser parser, const XML_Char *context) {\n  if (context == NULL) {\n    return XML_FALSE;\n  }\n\n  DTD *const dtd = parser->m_dtd; /* save one level of indirection */\n  const XML_Char *s = context;\n\n  while (*context != XML_T('\\0')) {\n    if (*s == CONTEXT_SEP || *s == XML_T('\\0')) {\n      ENTITY *e;\n      if (! poolAppendChar(&parser->m_tempPool, XML_T('\\0')))\n        return XML_FALSE;\n      e = (ENTITY *)lookup(parser, &dtd->generalEntities,\n                           poolStart(&parser->m_tempPool), 0);\n      if (e)\n        e->open = XML_TRUE;\n      if (*s != XML_T('\\0'))\n        s++;\n      context = s;\n      poolDiscard(&parser->m_tempPool);\n    } else if (*s == XML_T(ASCII_EQUALS)) {\n      PREFIX *prefix;\n      if (poolLength(&parser->m_tempPool) == 0)\n        prefix = &dtd->defaultPrefix;\n      else {\n        if (! poolAppendChar(&parser->m_tempPool, XML_T('\\0')))\n          return XML_FALSE;\n        prefix\n            = (PREFIX *)lookup(parser, &dtd->prefixes,\n                               poolStart(&parser->m_tempPool), sizeof(PREFIX));\n        if (! prefix)\n          return XML_FALSE;\n        if (prefix->name == poolStart(&parser->m_tempPool)) {\n          prefix->name = poolCopyString(&dtd->pool, prefix->name);\n          if (! prefix->name)\n            return XML_FALSE;\n        }\n        poolDiscard(&parser->m_tempPool);\n      }\n      for (context = s + 1; *context != CONTEXT_SEP && *context != XML_T('\\0');\n           context++)\n        if (! poolAppendChar(&parser->m_tempPool, *context))\n          return XML_FALSE;\n      if (! poolAppendChar(&parser->m_tempPool, XML_T('\\0')))\n        return XML_FALSE;\n      if (addBinding(parser, prefix, NULL, poolStart(&parser->m_tempPool),\n                     &parser->m_inheritedBindings)\n          != XML_ERROR_NONE)\n        return XML_FALSE;\n      poolDiscard(&parser->m_tempPool);\n      if (*context != XML_T('\\0'))\n        ++context;\n      s = context;\n    } else {\n      if (! poolAppendChar(&parser->m_tempPool, *s))\n        return XML_FALSE;\n      s++;\n    }\n  }\n  return XML_TRUE;\n}\n\nstatic void FASTCALL\nnormalizePublicId(XML_Char *publicId) {\n  XML_Char *p = publicId;\n  XML_Char *s;\n  for (s = publicId; *s; s++) {\n    switch (*s) {\n    case 0x20:\n    case 0xD:\n    case 0xA:\n      if (p != publicId && p[-1] != 0x20)\n        *p++ = 0x20;\n      break;\n    default:\n      *p++ = *s;\n    }\n  }\n  if (p != publicId && p[-1] == 0x20)\n    --p;\n  *p = XML_T('\\0');\n}\n\nstatic DTD *\ndtdCreate(const XML_Memory_Handling_Suite *ms) {\n  DTD *p = ms->malloc_fcn(sizeof(DTD));\n  if (p == NULL)\n    return p;\n  poolInit(&(p->pool), ms);\n  poolInit(&(p->entityValuePool), ms);\n  hashTableInit(&(p->generalEntities), ms);\n  hashTableInit(&(p->elementTypes), ms);\n  hashTableInit(&(p->attributeIds), ms);\n  hashTableInit(&(p->prefixes), ms);\n#ifdef XML_DTD\n  p->paramEntityRead = XML_FALSE;\n  hashTableInit(&(p->paramEntities), ms);\n#endif /* XML_DTD */\n  p->defaultPrefix.name = NULL;\n  p->defaultPrefix.binding = NULL;\n\n  p->in_eldecl = XML_FALSE;\n  p->scaffIndex = NULL;\n  p->scaffold = NULL;\n  p->scaffLevel = 0;\n  p->scaffSize = 0;\n  p->scaffCount = 0;\n  p->contentStringLen = 0;\n\n  p->keepProcessing = XML_TRUE;\n  p->hasParamEntityRefs = XML_FALSE;\n  p->standalone = XML_FALSE;\n  return p;\n}\n\nstatic void\ndtdReset(DTD *p, const XML_Memory_Handling_Suite *ms) {\n  HASH_TABLE_ITER iter;\n  hashTableIterInit(&iter, &(p->elementTypes));\n  for (;;) {\n    ELEMENT_TYPE *e = (ELEMENT_TYPE *)hashTableIterNext(&iter);\n    if (! e)\n      break;\n    if (e->allocDefaultAtts != 0)\n      ms->free_fcn(e->defaultAtts);\n  }\n  hashTableClear(&(p->generalEntities));\n#ifdef XML_DTD\n  p->paramEntityRead = XML_FALSE;\n  hashTableClear(&(p->paramEntities));\n#endif /* XML_DTD */\n  hashTableClear(&(p->elementTypes));\n  hashTableClear(&(p->attributeIds));\n  hashTableClear(&(p->prefixes));\n  poolClear(&(p->pool));\n  poolClear(&(p->entityValuePool));\n  p->defaultPrefix.name = NULL;\n  p->defaultPrefix.binding = NULL;\n\n  p->in_eldecl = XML_FALSE;\n\n  ms->free_fcn(p->scaffIndex);\n  p->scaffIndex = NULL;\n  ms->free_fcn(p->scaffold);\n  p->scaffold = NULL;\n\n  p->scaffLevel = 0;\n  p->scaffSize = 0;\n  p->scaffCount = 0;\n  p->contentStringLen = 0;\n\n  p->keepProcessing = XML_TRUE;\n  p->hasParamEntityRefs = XML_FALSE;\n  p->standalone = XML_FALSE;\n}\n\nstatic void\ndtdDestroy(DTD *p, XML_Bool isDocEntity, const XML_Memory_Handling_Suite *ms) {\n  HASH_TABLE_ITER iter;\n  hashTableIterInit(&iter, &(p->elementTypes));\n  for (;;) {\n    ELEMENT_TYPE *e = (ELEMENT_TYPE *)hashTableIterNext(&iter);\n    if (! e)\n      break;\n    if (e->allocDefaultAtts != 0)\n      ms->free_fcn(e->defaultAtts);\n  }\n  hashTableDestroy(&(p->generalEntities));\n#ifdef XML_DTD\n  hashTableDestroy(&(p->paramEntities));\n#endif /* XML_DTD */\n  hashTableDestroy(&(p->elementTypes));\n  hashTableDestroy(&(p->attributeIds));\n  hashTableDestroy(&(p->prefixes));\n  poolDestroy(&(p->pool));\n  poolDestroy(&(p->entityValuePool));\n  if (isDocEntity) {\n    ms->free_fcn(p->scaffIndex);\n    ms->free_fcn(p->scaffold);\n  }\n  ms->free_fcn(p);\n}\n\n/* Do a deep copy of the DTD. Return 0 for out of memory, non-zero otherwise.\n   The new DTD has already been initialized.\n*/\nstatic int\ndtdCopy(XML_Parser oldParser, DTD *newDtd, const DTD *oldDtd,\n        const XML_Memory_Handling_Suite *ms) {\n  HASH_TABLE_ITER iter;\n\n  /* Copy the prefix table. */\n\n  hashTableIterInit(&iter, &(oldDtd->prefixes));\n  for (;;) {\n    const XML_Char *name;\n    const PREFIX *oldP = (PREFIX *)hashTableIterNext(&iter);\n    if (! oldP)\n      break;\n    name = poolCopyString(&(newDtd->pool), oldP->name);\n    if (! name)\n      return 0;\n    if (! lookup(oldParser, &(newDtd->prefixes), name, sizeof(PREFIX)))\n      return 0;\n  }\n\n  hashTableIterInit(&iter, &(oldDtd->attributeIds));\n\n  /* Copy the attribute id table. */\n\n  for (;;) {\n    ATTRIBUTE_ID *newA;\n    const XML_Char *name;\n    const ATTRIBUTE_ID *oldA = (ATTRIBUTE_ID *)hashTableIterNext(&iter);\n\n    if (! oldA)\n      break;\n    /* Remember to allocate the scratch byte before the name. */\n    if (! poolAppendChar(&(newDtd->pool), XML_T('\\0')))\n      return 0;\n    name = poolCopyString(&(newDtd->pool), oldA->name);\n    if (! name)\n      return 0;\n    ++name;\n    newA = (ATTRIBUTE_ID *)lookup(oldParser, &(newDtd->attributeIds), name,\n                                  sizeof(ATTRIBUTE_ID));\n    if (! newA)\n      return 0;\n    newA->maybeTokenized = oldA->maybeTokenized;\n    if (oldA->prefix) {\n      newA->xmlns = oldA->xmlns;\n      if (oldA->prefix == &oldDtd->defaultPrefix)\n        newA->prefix = &newDtd->defaultPrefix;\n      else\n        newA->prefix = (PREFIX *)lookup(oldParser, &(newDtd->prefixes),\n                                        oldA->prefix->name, 0);\n    }\n  }\n\n  /* Copy the element type table. */\n\n  hashTableIterInit(&iter, &(oldDtd->elementTypes));\n\n  for (;;) {\n    int i;\n    ELEMENT_TYPE *newE;\n    const XML_Char *name;\n    const ELEMENT_TYPE *oldE = (ELEMENT_TYPE *)hashTableIterNext(&iter);\n    if (! oldE)\n      break;\n    name = poolCopyString(&(newDtd->pool), oldE->name);\n    if (! name)\n      return 0;\n    newE = (ELEMENT_TYPE *)lookup(oldParser, &(newDtd->elementTypes), name,\n                                  sizeof(ELEMENT_TYPE));\n    if (! newE)\n      return 0;\n    if (oldE->nDefaultAtts) {\n      newE->defaultAtts\n          = ms->malloc_fcn(oldE->nDefaultAtts * sizeof(DEFAULT_ATTRIBUTE));\n      if (! newE->defaultAtts) {\n        return 0;\n      }\n    }\n    if (oldE->idAtt)\n      newE->idAtt = (ATTRIBUTE_ID *)lookup(oldParser, &(newDtd->attributeIds),\n                                           oldE->idAtt->name, 0);\n    newE->allocDefaultAtts = newE->nDefaultAtts = oldE->nDefaultAtts;\n    if (oldE->prefix)\n      newE->prefix = (PREFIX *)lookup(oldParser, &(newDtd->prefixes),\n                                      oldE->prefix->name, 0);\n    for (i = 0; i < newE->nDefaultAtts; i++) {\n      newE->defaultAtts[i].id = (ATTRIBUTE_ID *)lookup(\n          oldParser, &(newDtd->attributeIds), oldE->defaultAtts[i].id->name, 0);\n      newE->defaultAtts[i].isCdata = oldE->defaultAtts[i].isCdata;\n      if (oldE->defaultAtts[i].value) {\n        newE->defaultAtts[i].value\n            = poolCopyString(&(newDtd->pool), oldE->defaultAtts[i].value);\n        if (! newE->defaultAtts[i].value)\n          return 0;\n      } else\n        newE->defaultAtts[i].value = NULL;\n    }\n  }\n\n  /* Copy the entity tables. */\n  if (! copyEntityTable(oldParser, &(newDtd->generalEntities), &(newDtd->pool),\n                        &(oldDtd->generalEntities)))\n    return 0;\n\n#ifdef XML_DTD\n  if (! copyEntityTable(oldParser, &(newDtd->paramEntities), &(newDtd->pool),\n                        &(oldDtd->paramEntities)))\n    return 0;\n  newDtd->paramEntityRead = oldDtd->paramEntityRead;\n#endif /* XML_DTD */\n\n  newDtd->keepProcessing = oldDtd->keepProcessing;\n  newDtd->hasParamEntityRefs = oldDtd->hasParamEntityRefs;\n  newDtd->standalone = oldDtd->standalone;\n\n  /* Don't want deep copying for scaffolding */\n  newDtd->in_eldecl = oldDtd->in_eldecl;\n  newDtd->scaffold = oldDtd->scaffold;\n  newDtd->contentStringLen = oldDtd->contentStringLen;\n  newDtd->scaffSize = oldDtd->scaffSize;\n  newDtd->scaffLevel = oldDtd->scaffLevel;\n  newDtd->scaffIndex = oldDtd->scaffIndex;\n\n  return 1;\n} /* End dtdCopy */\n\nstatic int\ncopyEntityTable(XML_Parser oldParser, HASH_TABLE *newTable,\n                STRING_POOL *newPool, const HASH_TABLE *oldTable) {\n  HASH_TABLE_ITER iter;\n  const XML_Char *cachedOldBase = NULL;\n  const XML_Char *cachedNewBase = NULL;\n\n  hashTableIterInit(&iter, oldTable);\n\n  for (;;) {\n    ENTITY *newE;\n    const XML_Char *name;\n    const ENTITY *oldE = (ENTITY *)hashTableIterNext(&iter);\n    if (! oldE)\n      break;\n    name = poolCopyString(newPool, oldE->name);\n    if (! name)\n      return 0;\n    newE = (ENTITY *)lookup(oldParser, newTable, name, sizeof(ENTITY));\n    if (! newE)\n      return 0;\n    if (oldE->systemId) {\n      const XML_Char *tem = poolCopyString(newPool, oldE->systemId);\n      if (! tem)\n        return 0;\n      newE->systemId = tem;\n      if (oldE->base) {\n        if (oldE->base == cachedOldBase)\n          newE->base = cachedNewBase;\n        else {\n          cachedOldBase = oldE->base;\n          tem = poolCopyString(newPool, cachedOldBase);\n          if (! tem)\n            return 0;\n          cachedNewBase = newE->base = tem;\n        }\n      }\n      if (oldE->publicId) {\n        tem = poolCopyString(newPool, oldE->publicId);\n        if (! tem)\n          return 0;\n        newE->publicId = tem;\n      }\n    } else {\n      const XML_Char *tem\n          = poolCopyStringN(newPool, oldE->textPtr, oldE->textLen);\n      if (! tem)\n        return 0;\n      newE->textPtr = tem;\n      newE->textLen = oldE->textLen;\n    }\n    if (oldE->notation) {\n      const XML_Char *tem = poolCopyString(newPool, oldE->notation);\n      if (! tem)\n        return 0;\n      newE->notation = tem;\n    }\n    newE->is_param = oldE->is_param;\n    newE->is_internal = oldE->is_internal;\n  }\n  return 1;\n}\n\n#define INIT_POWER 6\n\nstatic XML_Bool FASTCALL\nkeyeq(KEY s1, KEY s2) {\n  for (; *s1 == *s2; s1++, s2++)\n    if (*s1 == 0)\n      return XML_TRUE;\n  return XML_FALSE;\n}\n\nstatic size_t\nkeylen(KEY s) {\n  size_t len = 0;\n  for (; *s; s++, len++)\n    ;\n  return len;\n}\n\nstatic void\ncopy_salt_to_sipkey(XML_Parser parser, struct sipkey *key) {\n  key->k[0] = 0;\n  key->k[1] = get_hash_secret_salt(parser);\n}\n\nstatic unsigned long FASTCALL\nhash(XML_Parser parser, KEY s) {\n  struct siphash state;\n  struct sipkey key;\n  (void)sip24_valid;\n  copy_salt_to_sipkey(parser, &key);\n  sip24_init(&state, &key);\n  sip24_update(&state, s, keylen(s) * sizeof(XML_Char));\n  return (unsigned long)sip24_final(&state);\n}\n\nstatic NAMED *\nlookup(XML_Parser parser, HASH_TABLE *table, KEY name, size_t createSize) {\n  size_t i;\n  if (table->size == 0) {\n    size_t tsize;\n    if (! createSize)\n      return NULL;\n    table->power = INIT_POWER;\n    /* table->size is a power of 2 */\n    table->size = (size_t)1 << INIT_POWER;\n    tsize = table->size * sizeof(NAMED *);\n    table->v = table->mem->malloc_fcn(tsize);\n    if (! table->v) {\n      table->size = 0;\n      return NULL;\n    }\n    memset(table->v, 0, tsize);\n    i = hash(parser, name) & ((unsigned long)table->size - 1);\n  } else {\n    unsigned long h = hash(parser, name);\n    unsigned long mask = (unsigned long)table->size - 1;\n    unsigned char step = 0;\n    i = h & mask;\n    while (table->v[i]) {\n      if (keyeq(name, table->v[i]->name))\n        return table->v[i];\n      if (! step)\n        step = PROBE_STEP(h, mask, table->power);\n      i < step ? (i += table->size - step) : (i -= step);\n    }\n    if (! createSize)\n      return NULL;\n\n    /* check for overflow (table is half full) */\n    if (table->used >> (table->power - 1)) {\n      unsigned char newPower = table->power + 1;\n\n      /* Detect and prevent invalid shift */\n      if (newPower >= sizeof(unsigned long) * 8 /* bits per byte */) {\n        return NULL;\n      }\n\n      size_t newSize = (size_t)1 << newPower;\n      unsigned long newMask = (unsigned long)newSize - 1;\n\n      /* Detect and prevent integer overflow */\n      if (newSize > (size_t)(-1) / sizeof(NAMED *)) {\n        return NULL;\n      }\n\n      size_t tsize = newSize * sizeof(NAMED *);\n      NAMED **newV = table->mem->malloc_fcn(tsize);\n      if (! newV)\n        return NULL;\n      memset(newV, 0, tsize);\n      for (i = 0; i < table->size; i++)\n        if (table->v[i]) {\n          unsigned long newHash = hash(parser, table->v[i]->name);\n          size_t j = newHash & newMask;\n          step = 0;\n          while (newV[j]) {\n            if (! step)\n              step = PROBE_STEP(newHash, newMask, newPower);\n            j < step ? (j += newSize - step) : (j -= step);\n          }\n          newV[j] = table->v[i];\n        }\n      table->mem->free_fcn(table->v);\n      table->v = newV;\n      table->power = newPower;\n      table->size = newSize;\n      i = h & newMask;\n      step = 0;\n      while (table->v[i]) {\n        if (! step)\n          step = PROBE_STEP(h, newMask, newPower);\n        i < step ? (i += newSize - step) : (i -= step);\n      }\n    }\n  }\n  table->v[i] = table->mem->malloc_fcn(createSize);\n  if (! table->v[i])\n    return NULL;\n  memset(table->v[i], 0, createSize);\n  table->v[i]->name = name;\n  (table->used)++;\n  return table->v[i];\n}\n\nstatic void FASTCALL\nhashTableClear(HASH_TABLE *table) {\n  size_t i;\n  for (i = 0; i < table->size; i++) {\n    table->mem->free_fcn(table->v[i]);\n    table->v[i] = NULL;\n  }\n  table->used = 0;\n}\n\nstatic void FASTCALL\nhashTableDestroy(HASH_TABLE *table) {\n  size_t i;\n  for (i = 0; i < table->size; i++)\n    table->mem->free_fcn(table->v[i]);\n  table->mem->free_fcn(table->v);\n}\n\nstatic void FASTCALL\nhashTableInit(HASH_TABLE *p, const XML_Memory_Handling_Suite *ms) {\n  p->power = 0;\n  p->size = 0;\n  p->used = 0;\n  p->v = NULL;\n  p->mem = ms;\n}\n\nstatic void FASTCALL\nhashTableIterInit(HASH_TABLE_ITER *iter, const HASH_TABLE *table) {\n  iter->p = table->v;\n  iter->end = iter->p ? iter->p + table->size : NULL;\n}\n\nstatic NAMED *FASTCALL\nhashTableIterNext(HASH_TABLE_ITER *iter) {\n  while (iter->p != iter->end) {\n    NAMED *tem = *(iter->p)++;\n    if (tem)\n      return tem;\n  }\n  return NULL;\n}\n\nstatic void FASTCALL\npoolInit(STRING_POOL *pool, const XML_Memory_Handling_Suite *ms) {\n  pool->blocks = NULL;\n  pool->freeBlocks = NULL;\n  pool->start = NULL;\n  pool->ptr = NULL;\n  pool->end = NULL;\n  pool->mem = ms;\n}\n\nstatic void FASTCALL\npoolClear(STRING_POOL *pool) {\n  if (! pool->freeBlocks)\n    pool->freeBlocks = pool->blocks;\n  else {\n    BLOCK *p = pool->blocks;\n    while (p) {\n      BLOCK *tem = p->next;\n      p->next = pool->freeBlocks;\n      pool->freeBlocks = p;\n      p = tem;\n    }\n  }\n  pool->blocks = NULL;\n  pool->start = NULL;\n  pool->ptr = NULL;\n  pool->end = NULL;\n}\n\nstatic void FASTCALL\npoolDestroy(STRING_POOL *pool) {\n  BLOCK *p = pool->blocks;\n  while (p) {\n    BLOCK *tem = p->next;\n    pool->mem->free_fcn(p);\n    p = tem;\n  }\n  p = pool->freeBlocks;\n  while (p) {\n    BLOCK *tem = p->next;\n    pool->mem->free_fcn(p);\n    p = tem;\n  }\n}\n\nstatic XML_Char *\npoolAppend(STRING_POOL *pool, const ENCODING *enc, const char *ptr,\n           const char *end) {\n  if (! pool->ptr && ! poolGrow(pool))\n    return NULL;\n  for (;;) {\n    const enum XML_Convert_Result convert_res = XmlConvert(\n        enc, &ptr, end, (ICHAR **)&(pool->ptr), (const ICHAR *)pool->end);\n    if ((convert_res == XML_CONVERT_COMPLETED)\n        || (convert_res == XML_CONVERT_INPUT_INCOMPLETE))\n      break;\n    if (! poolGrow(pool))\n      return NULL;\n  }\n  return pool->start;\n}\n\nstatic const XML_Char *FASTCALL\npoolCopyString(STRING_POOL *pool, const XML_Char *s) {\n  do {\n    if (! poolAppendChar(pool, *s))\n      return NULL;\n  } while (*s++);\n  s = pool->start;\n  poolFinish(pool);\n  return s;\n}\n\nstatic const XML_Char *\npoolCopyStringN(STRING_POOL *pool, const XML_Char *s, int n) {\n  if (! pool->ptr && ! poolGrow(pool)) {\n    /* The following line is unreachable given the current usage of\n     * poolCopyStringN().  Currently it is called from exactly one\n     * place to copy the text of a simple general entity.  By that\n     * point, the name of the entity is already stored in the pool, so\n     * pool->ptr cannot be NULL.\n     *\n     * If poolCopyStringN() is used elsewhere as it well might be,\n     * this line may well become executable again.  Regardless, this\n     * sort of check shouldn't be removed lightly, so we just exclude\n     * it from the coverage statistics.\n     */\n    return NULL; /* LCOV_EXCL_LINE */\n  }\n  for (; n > 0; --n, s++) {\n    if (! poolAppendChar(pool, *s))\n      return NULL;\n  }\n  s = pool->start;\n  poolFinish(pool);\n  return s;\n}\n\nstatic const XML_Char *FASTCALL\npoolAppendString(STRING_POOL *pool, const XML_Char *s) {\n  while (*s) {\n    if (! poolAppendChar(pool, *s))\n      return NULL;\n    s++;\n  }\n  return pool->start;\n}\n\nstatic XML_Char *\npoolStoreString(STRING_POOL *pool, const ENCODING *enc, const char *ptr,\n                const char *end) {\n  if (! poolAppend(pool, enc, ptr, end))\n    return NULL;\n  if (pool->ptr == pool->end && ! poolGrow(pool))\n    return NULL;\n  *(pool->ptr)++ = 0;\n  return pool->start;\n}\n\nstatic size_t\npoolBytesToAllocateFor(int blockSize) {\n  /* Unprotected math would be:\n  ** return offsetof(BLOCK, s) + blockSize * sizeof(XML_Char);\n  **\n  ** Detect overflow, avoiding _signed_ overflow undefined behavior\n  ** For a + b * c we check b * c in isolation first, so that addition of a\n  ** on top has no chance of making us accept a small non-negative number\n  */\n  const size_t stretch = sizeof(XML_Char); /* can be 4 bytes */\n\n  if (blockSize <= 0)\n    return 0;\n\n  if (blockSize > (int)(INT_MAX / stretch))\n    return 0;\n\n  {\n    const int stretchedBlockSize = blockSize * (int)stretch;\n    const int bytesToAllocate\n        = (int)(offsetof(BLOCK, s) + (unsigned)stretchedBlockSize);\n    if (bytesToAllocate < 0)\n      return 0;\n\n    return (size_t)bytesToAllocate;\n  }\n}\n\nstatic XML_Bool FASTCALL\npoolGrow(STRING_POOL *pool) {\n  if (pool->freeBlocks) {\n    if (pool->start == 0) {\n      pool->blocks = pool->freeBlocks;\n      pool->freeBlocks = pool->freeBlocks->next;\n      pool->blocks->next = NULL;\n      pool->start = pool->blocks->s;\n      pool->end = pool->start + pool->blocks->size;\n      pool->ptr = pool->start;\n      return XML_TRUE;\n    }\n    if (pool->end - pool->start < pool->freeBlocks->size) {\n      BLOCK *tem = pool->freeBlocks->next;\n      pool->freeBlocks->next = pool->blocks;\n      pool->blocks = pool->freeBlocks;\n      pool->freeBlocks = tem;\n      memcpy(pool->blocks->s, pool->start,\n             (pool->end - pool->start) * sizeof(XML_Char));\n      pool->ptr = pool->blocks->s + (pool->ptr - pool->start);\n      pool->start = pool->blocks->s;\n      pool->end = pool->start + pool->blocks->size;\n      return XML_TRUE;\n    }\n  }\n  if (pool->blocks && pool->start == pool->blocks->s) {\n    BLOCK *temp;\n    int blockSize = (int)((unsigned)(pool->end - pool->start) * 2U);\n    size_t bytesToAllocate;\n\n    /* NOTE: Needs to be calculated prior to calling `realloc`\n             to avoid dangling pointers: */\n    const ptrdiff_t offsetInsideBlock = pool->ptr - pool->start;\n\n    if (blockSize < 0) {\n      /* This condition traps a situation where either more than\n       * INT_MAX/2 bytes have already been allocated.  This isn't\n       * readily testable, since it is unlikely that an average\n       * machine will have that much memory, so we exclude it from the\n       * coverage statistics.\n       */\n      return XML_FALSE; /* LCOV_EXCL_LINE */\n    }\n\n    bytesToAllocate = poolBytesToAllocateFor(blockSize);\n    if (bytesToAllocate == 0)\n      return XML_FALSE;\n\n    temp = (BLOCK *)pool->mem->realloc_fcn(pool->blocks,\n                                           (unsigned)bytesToAllocate);\n    if (temp == NULL)\n      return XML_FALSE;\n    pool->blocks = temp;\n    pool->blocks->size = blockSize;\n    pool->ptr = pool->blocks->s + offsetInsideBlock;\n    pool->start = pool->blocks->s;\n    pool->end = pool->start + blockSize;\n  } else {\n    BLOCK *tem;\n    int blockSize = (int)(pool->end - pool->start);\n    size_t bytesToAllocate;\n\n    if (blockSize < 0) {\n      /* This condition traps a situation where either more than\n       * INT_MAX bytes have already been allocated (which is prevented\n       * by various pieces of program logic, not least this one, never\n       * mind the unlikelihood of actually having that much memory) or\n       * the pool control fields have been corrupted (which could\n       * conceivably happen in an extremely buggy user handler\n       * function).  Either way it isn't readily testable, so we\n       * exclude it from the coverage statistics.\n       */\n      return XML_FALSE; /* LCOV_EXCL_LINE */\n    }\n\n    if (blockSize < INIT_BLOCK_SIZE)\n      blockSize = INIT_BLOCK_SIZE;\n    else {\n      /* Detect overflow, avoiding _signed_ overflow undefined behavior */\n      if ((int)((unsigned)blockSize * 2U) < 0) {\n        return XML_FALSE;\n      }\n      blockSize *= 2;\n    }\n\n    bytesToAllocate = poolBytesToAllocateFor(blockSize);\n    if (bytesToAllocate == 0)\n      return XML_FALSE;\n\n    tem = pool->mem->malloc_fcn(bytesToAllocate);\n    if (! tem)\n      return XML_FALSE;\n    tem->size = blockSize;\n    tem->next = pool->blocks;\n    pool->blocks = tem;\n    if (pool->ptr != pool->start)\n      memcpy(tem->s, pool->start, (pool->ptr - pool->start) * sizeof(XML_Char));\n    pool->ptr = tem->s + (pool->ptr - pool->start);\n    pool->start = tem->s;\n    pool->end = tem->s + blockSize;\n  }\n  return XML_TRUE;\n}\n\nstatic int FASTCALL\nnextScaffoldPart(XML_Parser parser) {\n  DTD *const dtd = parser->m_dtd; /* save one level of indirection */\n  CONTENT_SCAFFOLD *me;\n  int next;\n\n  if (! dtd->scaffIndex) {\n    dtd->scaffIndex = (int *)MALLOC(parser, parser->m_groupSize * sizeof(int));\n    if (! dtd->scaffIndex)\n      return -1;\n    dtd->scaffIndex[0] = 0;\n  }\n\n  if (dtd->scaffCount >= dtd->scaffSize) {\n    CONTENT_SCAFFOLD *temp;\n    if (dtd->scaffold) {\n      /* Detect and prevent integer overflow */\n      if (dtd->scaffSize > UINT_MAX / 2u) {\n        return -1;\n      }\n      /* Detect and prevent integer overflow.\n       * The preprocessor guard addresses the \"always false\" warning\n       * from -Wtype-limits on platforms where\n       * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */\n#if UINT_MAX >= SIZE_MAX\n      if (dtd->scaffSize > (size_t)(-1) / 2u / sizeof(CONTENT_SCAFFOLD)) {\n        return -1;\n      }\n#endif\n\n      temp = (CONTENT_SCAFFOLD *)REALLOC(\n          parser, dtd->scaffold, dtd->scaffSize * 2 * sizeof(CONTENT_SCAFFOLD));\n      if (temp == NULL)\n        return -1;\n      dtd->scaffSize *= 2;\n    } else {\n      temp = (CONTENT_SCAFFOLD *)MALLOC(parser, INIT_SCAFFOLD_ELEMENTS\n                                                    * sizeof(CONTENT_SCAFFOLD));\n      if (temp == NULL)\n        return -1;\n      dtd->scaffSize = INIT_SCAFFOLD_ELEMENTS;\n    }\n    dtd->scaffold = temp;\n  }\n  next = dtd->scaffCount++;\n  me = &dtd->scaffold[next];\n  if (dtd->scaffLevel) {\n    CONTENT_SCAFFOLD *parent\n        = &dtd->scaffold[dtd->scaffIndex[dtd->scaffLevel - 1]];\n    if (parent->lastchild) {\n      dtd->scaffold[parent->lastchild].nextsib = next;\n    }\n    if (! parent->childcnt)\n      parent->firstchild = next;\n    parent->lastchild = next;\n    parent->childcnt++;\n  }\n  me->firstchild = me->lastchild = me->childcnt = me->nextsib = 0;\n  return next;\n}\n\nstatic XML_Content *\nbuild_model(XML_Parser parser) {\n  /* Function build_model transforms the existing parser->m_dtd->scaffold\n   * array of CONTENT_SCAFFOLD tree nodes into a new array of\n   * XML_Content tree nodes followed by a gapless list of zero-terminated\n   * strings. */\n  DTD *const dtd = parser->m_dtd; /* save one level of indirection */\n  XML_Content *ret;\n  XML_Char *str; /* the current string writing location */\n\n  /* Detect and prevent integer overflow.\n   * The preprocessor guard addresses the \"always false\" warning\n   * from -Wtype-limits on platforms where\n   * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */\n#if UINT_MAX >= SIZE_MAX\n  if (dtd->scaffCount > (size_t)(-1) / sizeof(XML_Content)) {\n    return NULL;\n  }\n  if (dtd->contentStringLen > (size_t)(-1) / sizeof(XML_Char)) {\n    return NULL;\n  }\n#endif\n  if (dtd->scaffCount * sizeof(XML_Content)\n      > (size_t)(-1) - dtd->contentStringLen * sizeof(XML_Char)) {\n    return NULL;\n  }\n\n  const size_t allocsize = (dtd->scaffCount * sizeof(XML_Content)\n                            + (dtd->contentStringLen * sizeof(XML_Char)));\n\n  ret = (XML_Content *)MALLOC(parser, allocsize);\n  if (! ret)\n    return NULL;\n\n  /* What follows is an iterative implementation (of what was previously done\n   * recursively in a dedicated function called \"build_node\".  The old recursive\n   * build_node could be forced into stack exhaustion from input as small as a\n   * few megabyte, and so that was a security issue.  Hence, a function call\n   * stack is avoided now by resolving recursion.)\n   *\n   * The iterative approach works as follows:\n   *\n   * - We have two writing pointers, both walking up the result array; one does\n   *   the work, the other creates \"jobs\" for its colleague to do, and leads\n   *   the way:\n   *\n   *   - The faster one, pointer jobDest, always leads and writes \"what job\n   *     to do\" by the other, once they reach that place in the\n   *     array: leader \"jobDest\" stores the source node array index (relative\n   *     to array dtd->scaffold) in field \"numchildren\".\n   *\n   *   - The slower one, pointer dest, looks at the value stored in the\n   *     \"numchildren\" field (which actually holds a source node array index\n   *     at that time) and puts the real data from dtd->scaffold in.\n   *\n   * - Before the loop starts, jobDest writes source array index 0\n   *   (where the root node is located) so that dest will have something to do\n   *   when it starts operation.\n   *\n   * - Whenever nodes with children are encountered, jobDest appends\n   *   them as new jobs, in order.  As a result, tree node siblings are\n   *   adjacent in the resulting array, for example:\n   *\n   *     [0] root, has two children\n   *       [1] first child of 0, has three children\n   *         [3] first child of 1, does not have children\n   *         [4] second child of 1, does not have children\n   *         [5] third child of 1, does not have children\n   *       [2] second child of 0, does not have children\n   *\n   *   Or (the same data) presented in flat array view:\n   *\n   *     [0] root, has two children\n   *\n   *     [1] first child of 0, has three children\n   *     [2] second child of 0, does not have children\n   *\n   *     [3] first child of 1, does not have children\n   *     [4] second child of 1, does not have children\n   *     [5] third child of 1, does not have children\n   *\n   * - The algorithm repeats until all target array indices have been processed.\n   */\n  XML_Content *dest = ret; /* tree node writing location, moves upwards */\n  XML_Content *const destLimit = &ret[dtd->scaffCount];\n  XML_Content *jobDest = ret; /* next free writing location in target array */\n  str = (XML_Char *)&ret[dtd->scaffCount];\n\n  /* Add the starting job, the root node (index 0) of the source tree  */\n  (jobDest++)->numchildren = 0;\n\n  for (; dest < destLimit; dest++) {\n    /* Retrieve source tree array index from job storage */\n    const int src_node = (int)dest->numchildren;\n\n    /* Convert item */\n    dest->type = dtd->scaffold[src_node].type;\n    dest->quant = dtd->scaffold[src_node].quant;\n    if (dest->type == XML_CTYPE_NAME) {\n      const XML_Char *src;\n      dest->name = str;\n      src = dtd->scaffold[src_node].name;\n      for (;;) {\n        *str++ = *src;\n        if (! *src)\n          break;\n        src++;\n      }\n      dest->numchildren = 0;\n      dest->children = NULL;\n    } else {\n      unsigned int i;\n      int cn;\n      dest->name = NULL;\n      dest->numchildren = dtd->scaffold[src_node].childcnt;\n      dest->children = jobDest;\n\n      /* Append scaffold indices of children to array */\n      for (i = 0, cn = dtd->scaffold[src_node].firstchild;\n           i < dest->numchildren; i++, cn = dtd->scaffold[cn].nextsib)\n        (jobDest++)->numchildren = (unsigned int)cn;\n    }\n  }\n\n  return ret;\n}\n\nstatic ELEMENT_TYPE *\ngetElementType(XML_Parser parser, const ENCODING *enc, const char *ptr,\n               const char *end) {\n  DTD *const dtd = parser->m_dtd; /* save one level of indirection */\n  const XML_Char *name = poolStoreString(&dtd->pool, enc, ptr, end);\n  ELEMENT_TYPE *ret;\n\n  if (! name)\n    return NULL;\n  ret = (ELEMENT_TYPE *)lookup(parser, &dtd->elementTypes, name,\n                               sizeof(ELEMENT_TYPE));\n  if (! ret)\n    return NULL;\n  if (ret->name != name)\n    poolDiscard(&dtd->pool);\n  else {\n    poolFinish(&dtd->pool);\n    if (! setElementTypePrefix(parser, ret))\n      return NULL;\n  }\n  return ret;\n}\n\nstatic XML_Char *\ncopyString(const XML_Char *s, const XML_Memory_Handling_Suite *memsuite) {\n  size_t charsRequired = 0;\n  XML_Char *result;\n\n  /* First determine how long the string is */\n  while (s[charsRequired] != 0) {\n    charsRequired++;\n  }\n  /* Include the terminator */\n  charsRequired++;\n\n  /* Now allocate space for the copy */\n  result = memsuite->malloc_fcn(charsRequired * sizeof(XML_Char));\n  if (result == NULL)\n    return NULL;\n  /* Copy the original into place */\n  memcpy(result, s, charsRequired * sizeof(XML_Char));\n  return result;\n}\n\n#ifdef XML_DTD\n\nstatic float\naccountingGetCurrentAmplification(XML_Parser rootParser) {\n  const XmlBigCount countBytesOutput\n      = rootParser->m_accounting.countBytesDirect\n        + rootParser->m_accounting.countBytesIndirect;\n  const float amplificationFactor\n      = rootParser->m_accounting.countBytesDirect\n            ? (countBytesOutput\n               / (float)(rootParser->m_accounting.countBytesDirect))\n            : 1.0f;\n  assert(! rootParser->m_parentParser);\n  return amplificationFactor;\n}\n\nstatic void\naccountingReportStats(XML_Parser originParser, const char *epilog) {\n  const XML_Parser rootParser = getRootParserOf(originParser, NULL);\n  assert(! rootParser->m_parentParser);\n\n  if (rootParser->m_accounting.debugLevel == 0u) {\n    return;\n  }\n\n  const float amplificationFactor\n      = accountingGetCurrentAmplification(rootParser);\n  fprintf(stderr,\n          \"expat: Accounting(%p): Direct \" EXPAT_FMT_ULL(\n              \"10\") \", indirect \" EXPAT_FMT_ULL(\"10\") \", amplification %8.2f%s\",\n          (void *)rootParser, rootParser->m_accounting.countBytesDirect,\n          rootParser->m_accounting.countBytesIndirect,\n          (double)amplificationFactor, epilog);\n}\n\nstatic void\naccountingOnAbort(XML_Parser originParser) {\n  accountingReportStats(originParser, \" ABORTING\\n\");\n}\n\nstatic void\naccountingReportDiff(XML_Parser rootParser,\n                     unsigned int levelsAwayFromRootParser, const char *before,\n                     const char *after, ptrdiff_t bytesMore, int source_line,\n                     enum XML_Account account) {\n  assert(! rootParser->m_parentParser);\n\n  fprintf(stderr,\n          \" (+\" EXPAT_FMT_PTRDIFF_T(\"6\") \" bytes %s|%d, xmlparse.c:%d) %*s\\\"\",\n          bytesMore, (account == XML_ACCOUNT_DIRECT) ? \"DIR\" : \"EXP\",\n          levelsAwayFromRootParser, source_line, 10, \"\");\n\n  const char ellipis[] = \"[..]\";\n  const size_t ellipsisLength = sizeof(ellipis) /* because compile-time */ - 1;\n  const unsigned int contextLength = 10;\n\n  /* Note: Performance is of no concern here */\n  const char *walker = before;\n  if ((rootParser->m_accounting.debugLevel >= 3u)\n      || (after - before)\n             <= (ptrdiff_t)(contextLength + ellipsisLength + contextLength)) {\n    for (; walker < after; walker++) {\n      fprintf(stderr, \"%s\", unsignedCharToPrintable(walker[0]));\n    }\n  } else {\n    for (; walker < before + contextLength; walker++) {\n      fprintf(stderr, \"%s\", unsignedCharToPrintable(walker[0]));\n    }\n    fprintf(stderr, ellipis);\n    walker = after - contextLength;\n    for (; walker < after; walker++) {\n      fprintf(stderr, \"%s\", unsignedCharToPrintable(walker[0]));\n    }\n  }\n  fprintf(stderr, \"\\\"\\n\");\n}\n\nstatic XML_Bool\naccountingDiffTolerated(XML_Parser originParser, int tok, const char *before,\n                        const char *after, int source_line,\n                        enum XML_Account account) {\n  /* Note: We need to check the token type *first* to be sure that\n   *       we can even access variable <after>, safely.\n   *       E.g. for XML_TOK_NONE <after> may hold an invalid pointer. */\n  switch (tok) {\n  case XML_TOK_INVALID:\n  case XML_TOK_PARTIAL:\n  case XML_TOK_PARTIAL_CHAR:\n  case XML_TOK_NONE:\n    return XML_TRUE;\n  }\n\n  if (account == XML_ACCOUNT_NONE)\n    return XML_TRUE; /* because these bytes have been accounted for, already */\n\n  unsigned int levelsAwayFromRootParser;\n  const XML_Parser rootParser\n      = getRootParserOf(originParser, &levelsAwayFromRootParser);\n  assert(! rootParser->m_parentParser);\n\n  const int isDirect\n      = (account == XML_ACCOUNT_DIRECT) && (originParser == rootParser);\n  const ptrdiff_t bytesMore = after - before;\n\n  XmlBigCount *const additionTarget\n      = isDirect ? &rootParser->m_accounting.countBytesDirect\n                 : &rootParser->m_accounting.countBytesIndirect;\n\n  /* Detect and avoid integer overflow */\n  if (*additionTarget > (XmlBigCount)(-1) - (XmlBigCount)bytesMore)\n    return XML_FALSE;\n  *additionTarget += bytesMore;\n\n  const XmlBigCount countBytesOutput\n      = rootParser->m_accounting.countBytesDirect\n        + rootParser->m_accounting.countBytesIndirect;\n  const float amplificationFactor\n      = accountingGetCurrentAmplification(rootParser);\n  const XML_Bool tolerated\n      = (countBytesOutput < rootParser->m_accounting.activationThresholdBytes)\n        || (amplificationFactor\n            <= rootParser->m_accounting.maximumAmplificationFactor);\n\n  if (rootParser->m_accounting.debugLevel >= 2u) {\n    accountingReportStats(rootParser, \"\");\n    accountingReportDiff(rootParser, levelsAwayFromRootParser, before, after,\n                         bytesMore, source_line, account);\n  }\n\n  return tolerated;\n}\n\nunsigned long long\ntestingAccountingGetCountBytesDirect(XML_Parser parser) {\n  if (! parser)\n    return 0;\n  return parser->m_accounting.countBytesDirect;\n}\n\nunsigned long long\ntestingAccountingGetCountBytesIndirect(XML_Parser parser) {\n  if (! parser)\n    return 0;\n  return parser->m_accounting.countBytesIndirect;\n}\n\nstatic void\nentityTrackingReportStats(XML_Parser rootParser, ENTITY *entity,\n                          const char *action, int sourceLine) {\n  assert(! rootParser->m_parentParser);\n  if (rootParser->m_entity_stats.debugLevel == 0u)\n    return;\n\n#  if defined(XML_UNICODE)\n  const char *const entityName = \"[..]\";\n#  else\n  const char *const entityName = entity->name;\n#  endif\n\n  fprintf(\n      stderr,\n      \"expat: Entities(%p): Count %9d, depth %2d/%2d %*s%s%s; %s length %d (xmlparse.c:%d)\\n\",\n      (void *)rootParser, rootParser->m_entity_stats.countEverOpened,\n      rootParser->m_entity_stats.currentDepth,\n      rootParser->m_entity_stats.maximumDepthSeen,\n      (rootParser->m_entity_stats.currentDepth - 1) * 2, \"\",\n      entity->is_param ? \"%\" : \"&\", entityName, action, entity->textLen,\n      sourceLine);\n}\n\nstatic void\nentityTrackingOnOpen(XML_Parser originParser, ENTITY *entity, int sourceLine) {\n  const XML_Parser rootParser = getRootParserOf(originParser, NULL);\n  assert(! rootParser->m_parentParser);\n\n  rootParser->m_entity_stats.countEverOpened++;\n  rootParser->m_entity_stats.currentDepth++;\n  if (rootParser->m_entity_stats.currentDepth\n      > rootParser->m_entity_stats.maximumDepthSeen) {\n    rootParser->m_entity_stats.maximumDepthSeen++;\n  }\n\n  entityTrackingReportStats(rootParser, entity, \"OPEN \", sourceLine);\n}\n\nstatic void\nentityTrackingOnClose(XML_Parser originParser, ENTITY *entity, int sourceLine) {\n  const XML_Parser rootParser = getRootParserOf(originParser, NULL);\n  assert(! rootParser->m_parentParser);\n\n  entityTrackingReportStats(rootParser, entity, \"CLOSE\", sourceLine);\n  rootParser->m_entity_stats.currentDepth--;\n}\n\nstatic XML_Parser\ngetRootParserOf(XML_Parser parser, unsigned int *outLevelDiff) {\n  XML_Parser rootParser = parser;\n  unsigned int stepsTakenUpwards = 0;\n  while (rootParser->m_parentParser) {\n    rootParser = rootParser->m_parentParser;\n    stepsTakenUpwards++;\n  }\n  assert(! rootParser->m_parentParser);\n  if (outLevelDiff != NULL) {\n    *outLevelDiff = stepsTakenUpwards;\n  }\n  return rootParser;\n}\n\nconst char *\nunsignedCharToPrintable(unsigned char c) {\n  switch (c) {\n  case 0:\n    return \"\\\\0\";\n  case 1:\n    return \"\\\\x1\";\n  case 2:\n    return \"\\\\x2\";\n  case 3:\n    return \"\\\\x3\";\n  case 4:\n    return \"\\\\x4\";\n  case 5:\n    return \"\\\\x5\";\n  case 6:\n    return \"\\\\x6\";\n  case 7:\n    return \"\\\\x7\";\n  case 8:\n    return \"\\\\x8\";\n  case 9:\n    return \"\\\\t\";\n  case 10:\n    return \"\\\\n\";\n  case 11:\n    return \"\\\\xB\";\n  case 12:\n    return \"\\\\xC\";\n  case 13:\n    return \"\\\\r\";\n  case 14:\n    return \"\\\\xE\";\n  case 15:\n    return \"\\\\xF\";\n  case 16:\n    return \"\\\\x10\";\n  case 17:\n    return \"\\\\x11\";\n  case 18:\n    return \"\\\\x12\";\n  case 19:\n    return \"\\\\x13\";\n  case 20:\n    return \"\\\\x14\";\n  case 21:\n    return \"\\\\x15\";\n  case 22:\n    return \"\\\\x16\";\n  case 23:\n    return \"\\\\x17\";\n  case 24:\n    return \"\\\\x18\";\n  case 25:\n    return \"\\\\x19\";\n  case 26:\n    return \"\\\\x1A\";\n  case 27:\n    return \"\\\\x1B\";\n  case 28:\n    return \"\\\\x1C\";\n  case 29:\n    return \"\\\\x1D\";\n  case 30:\n    return \"\\\\x1E\";\n  case 31:\n    return \"\\\\x1F\";\n  case 32:\n    return \" \";\n  case 33:\n    return \"!\";\n  case 34:\n    return \"\\\\\\\"\";\n  case 35:\n    return \"#\";\n  case 36:\n    return \"$\";\n  case 37:\n    return \"%\";\n  case 38:\n    return \"&\";\n  case 39:\n    return \"'\";\n  case 40:\n    return \"(\";\n  case 41:\n    return \")\";\n  case 42:\n    return \"*\";\n  case 43:\n    return \"+\";\n  case 44:\n    return \",\";\n  case 45:\n    return \"-\";\n  case 46:\n    return \".\";\n  case 47:\n    return \"/\";\n  case 48:\n    return \"0\";\n  case 49:\n    return \"1\";\n  case 50:\n    return \"2\";\n  case 51:\n    return \"3\";\n  case 52:\n    return \"4\";\n  case 53:\n    return \"5\";\n  case 54:\n    return \"6\";\n  case 55:\n    return \"7\";\n  case 56:\n    return \"8\";\n  case 57:\n    return \"9\";\n  case 58:\n    return \":\";\n  case 59:\n    return \";\";\n  case 60:\n    return \"<\";\n  case 61:\n    return \"=\";\n  case 62:\n    return \">\";\n  case 63:\n    return \"?\";\n  case 64:\n    return \"@\";\n  case 65:\n    return \"A\";\n  case 66:\n    return \"B\";\n  case 67:\n    return \"C\";\n  case 68:\n    return \"D\";\n  case 69:\n    return \"E\";\n  case 70:\n    return \"F\";\n  case 71:\n    return \"G\";\n  case 72:\n    return \"H\";\n  case 73:\n    return \"I\";\n  case 74:\n    return \"J\";\n  case 75:\n    return \"K\";\n  case 76:\n    return \"L\";\n  case 77:\n    return \"M\";\n  case 78:\n    return \"N\";\n  case 79:\n    return \"O\";\n  case 80:\n    return \"P\";\n  case 81:\n    return \"Q\";\n  case 82:\n    return \"R\";\n  case 83:\n    return \"S\";\n  case 84:\n    return \"T\";\n  case 85:\n    return \"U\";\n  case 86:\n    return \"V\";\n  case 87:\n    return \"W\";\n  case 88:\n    return \"X\";\n  case 89:\n    return \"Y\";\n  case 90:\n    return \"Z\";\n  case 91:\n    return \"[\";\n  case 92:\n    return \"\\\\\\\\\";\n  case 93:\n    return \"]\";\n  case 94:\n    return \"^\";\n  case 95:\n    return \"_\";\n  case 96:\n    return \"`\";\n  case 97:\n    return \"a\";\n  case 98:\n    return \"b\";\n  case 99:\n    return \"c\";\n  case 100:\n    return \"d\";\n  case 101:\n    return \"e\";\n  case 102:\n    return \"f\";\n  case 103:\n    return \"g\";\n  case 104:\n    return \"h\";\n  case 105:\n    return \"i\";\n  case 106:\n    return \"j\";\n  case 107:\n    return \"k\";\n  case 108:\n    return \"l\";\n  case 109:\n    return \"m\";\n  case 110:\n    return \"n\";\n  case 111:\n    return \"o\";\n  case 112:\n    return \"p\";\n  case 113:\n    return \"q\";\n  case 114:\n    return \"r\";\n  case 115:\n    return \"s\";\n  case 116:\n    return \"t\";\n  case 117:\n    return \"u\";\n  case 118:\n    return \"v\";\n  case 119:\n    return \"w\";\n  case 120:\n    return \"x\";\n  case 121:\n    return \"y\";\n  case 122:\n    return \"z\";\n  case 123:\n    return \"{\";\n  case 124:\n    return \"|\";\n  case 125:\n    return \"}\";\n  case 126:\n    return \"~\";\n  case 127:\n    return \"\\\\x7F\";\n  case 128:\n    return \"\\\\x80\";\n  case 129:\n    return \"\\\\x81\";\n  case 130:\n    return \"\\\\x82\";\n  case 131:\n    return \"\\\\x83\";\n  case 132:\n    return \"\\\\x84\";\n  case 133:\n    return \"\\\\x85\";\n  case 134:\n    return \"\\\\x86\";\n  case 135:\n    return \"\\\\x87\";\n  case 136:\n    return \"\\\\x88\";\n  case 137:\n    return \"\\\\x89\";\n  case 138:\n    return \"\\\\x8A\";\n  case 139:\n    return \"\\\\x8B\";\n  case 140:\n    return \"\\\\x8C\";\n  case 141:\n    return \"\\\\x8D\";\n  case 142:\n    return \"\\\\x8E\";\n  case 143:\n    return \"\\\\x8F\";\n  case 144:\n    return \"\\\\x90\";\n  case 145:\n    return \"\\\\x91\";\n  case 146:\n    return \"\\\\x92\";\n  case 147:\n    return \"\\\\x93\";\n  case 148:\n    return \"\\\\x94\";\n  case 149:\n    return \"\\\\x95\";\n  case 150:\n    return \"\\\\x96\";\n  case 151:\n    return \"\\\\x97\";\n  case 152:\n    return \"\\\\x98\";\n  case 153:\n    return \"\\\\x99\";\n  case 154:\n    return \"\\\\x9A\";\n  case 155:\n    return \"\\\\x9B\";\n  case 156:\n    return \"\\\\x9C\";\n  case 157:\n    return \"\\\\x9D\";\n  case 158:\n    return \"\\\\x9E\";\n  case 159:\n    return \"\\\\x9F\";\n  case 160:\n    return \"\\\\xA0\";\n  case 161:\n    return \"\\\\xA1\";\n  case 162:\n    return \"\\\\xA2\";\n  case 163:\n    return \"\\\\xA3\";\n  case 164:\n    return \"\\\\xA4\";\n  case 165:\n    return \"\\\\xA5\";\n  case 166:\n    return \"\\\\xA6\";\n  case 167:\n    return \"\\\\xA7\";\n  case 168:\n    return \"\\\\xA8\";\n  case 169:\n    return \"\\\\xA9\";\n  case 170:\n    return \"\\\\xAA\";\n  case 171:\n    return \"\\\\xAB\";\n  case 172:\n    return \"\\\\xAC\";\n  case 173:\n    return \"\\\\xAD\";\n  case 174:\n    return \"\\\\xAE\";\n  case 175:\n    return \"\\\\xAF\";\n  case 176:\n    return \"\\\\xB0\";\n  case 177:\n    return \"\\\\xB1\";\n  case 178:\n    return \"\\\\xB2\";\n  case 179:\n    return \"\\\\xB3\";\n  case 180:\n    return \"\\\\xB4\";\n  case 181:\n    return \"\\\\xB5\";\n  case 182:\n    return \"\\\\xB6\";\n  case 183:\n    return \"\\\\xB7\";\n  case 184:\n    return \"\\\\xB8\";\n  case 185:\n    return \"\\\\xB9\";\n  case 186:\n    return \"\\\\xBA\";\n  case 187:\n    return \"\\\\xBB\";\n  case 188:\n    return \"\\\\xBC\";\n  case 189:\n    return \"\\\\xBD\";\n  case 190:\n    return \"\\\\xBE\";\n  case 191:\n    return \"\\\\xBF\";\n  case 192:\n    return \"\\\\xC0\";\n  case 193:\n    return \"\\\\xC1\";\n  case 194:\n    return \"\\\\xC2\";\n  case 195:\n    return \"\\\\xC3\";\n  case 196:\n    return \"\\\\xC4\";\n  case 197:\n    return \"\\\\xC5\";\n  case 198:\n    return \"\\\\xC6\";\n  case 199:\n    return \"\\\\xC7\";\n  case 200:\n    return \"\\\\xC8\";\n  case 201:\n    return \"\\\\xC9\";\n  case 202:\n    return \"\\\\xCA\";\n  case 203:\n    return \"\\\\xCB\";\n  case 204:\n    return \"\\\\xCC\";\n  case 205:\n    return \"\\\\xCD\";\n  case 206:\n    return \"\\\\xCE\";\n  case 207:\n    return \"\\\\xCF\";\n  case 208:\n    return \"\\\\xD0\";\n  case 209:\n    return \"\\\\xD1\";\n  case 210:\n    return \"\\\\xD2\";\n  case 211:\n    return \"\\\\xD3\";\n  case 212:\n    return \"\\\\xD4\";\n  case 213:\n    return \"\\\\xD5\";\n  case 214:\n    return \"\\\\xD6\";\n  case 215:\n    return \"\\\\xD7\";\n  case 216:\n    return \"\\\\xD8\";\n  case 217:\n    return \"\\\\xD9\";\n  case 218:\n    return \"\\\\xDA\";\n  case 219:\n    return \"\\\\xDB\";\n  case 220:\n    return \"\\\\xDC\";\n  case 221:\n    return \"\\\\xDD\";\n  case 222:\n    return \"\\\\xDE\";\n  case 223:\n    return \"\\\\xDF\";\n  case 224:\n    return \"\\\\xE0\";\n  case 225:\n    return \"\\\\xE1\";\n  case 226:\n    return \"\\\\xE2\";\n  case 227:\n    return \"\\\\xE3\";\n  case 228:\n    return \"\\\\xE4\";\n  case 229:\n    return \"\\\\xE5\";\n  case 230:\n    return \"\\\\xE6\";\n  case 231:\n    return \"\\\\xE7\";\n  case 232:\n    return \"\\\\xE8\";\n  case 233:\n    return \"\\\\xE9\";\n  case 234:\n    return \"\\\\xEA\";\n  case 235:\n    return \"\\\\xEB\";\n  case 236:\n    return \"\\\\xEC\";\n  case 237:\n    return \"\\\\xED\";\n  case 238:\n    return \"\\\\xEE\";\n  case 239:\n    return \"\\\\xEF\";\n  case 240:\n    return \"\\\\xF0\";\n  case 241:\n    return \"\\\\xF1\";\n  case 242:\n    return \"\\\\xF2\";\n  case 243:\n    return \"\\\\xF3\";\n  case 244:\n    return \"\\\\xF4\";\n  case 245:\n    return \"\\\\xF5\";\n  case 246:\n    return \"\\\\xF6\";\n  case 247:\n    return \"\\\\xF7\";\n  case 248:\n    return \"\\\\xF8\";\n  case 249:\n    return \"\\\\xF9\";\n  case 250:\n    return \"\\\\xFA\";\n  case 251:\n    return \"\\\\xFB\";\n  case 252:\n    return \"\\\\xFC\";\n  case 253:\n    return \"\\\\xFD\";\n  case 254:\n    return \"\\\\xFE\";\n  case 255:\n    return \"\\\\xFF\";\n  default:\n    assert(0); /* never gets here */\n    return \"dead code\";\n  }\n  assert(0); /* never gets here */\n}\n\n#endif /* XML_DTD */\n\nstatic unsigned long\ngetDebugLevel(const char *variableName, unsigned long defaultDebugLevel) {\n  const char *const valueOrNull = getenv(variableName);\n  if (valueOrNull == NULL) {\n    return defaultDebugLevel;\n  }\n  const char *const value = valueOrNull;\n\n  errno = 0;\n  char *afterValue = NULL;\n  unsigned long debugLevel = strtoul(value, &afterValue, 10);\n  if ((errno != 0) || (afterValue == value) || (afterValue[0] != '\\0')) {\n    errno = 0;\n    return defaultDebugLevel;\n  }\n\n  return debugLevel;\n}\n", "/*\n                            __  __            _\n                         ___\\ \\/ /_ __   __ _| |_\n                        / _ \\\\  /| '_ \\ / _` | __|\n                       |  __//  \\| |_) | (_| | |_\n                        \\___/_/\\_\\ .__/ \\__,_|\\__|\n                                 |_| XML parser\n\n   Copyright (c) 1997-2000 Thai Open Source Software Center Ltd\n   Copyright (c) 2000      Clark Cooper <coopercc@users.sourceforge.net>\n   Copyright (c) 2001-2003 Fred L. Drake, Jr. <fdrake@users.sourceforge.net>\n   Copyright (c) 2004-2009 Karl Waclawek <karl@waclawek.net>\n   Copyright (c) 2005-2007 Steven Solie <steven@solie.ca>\n   Copyright (c) 2016-2022 Sebastian Pipping <sebastian@pipping.org>\n   Copyright (c) 2017      Rhodri James <rhodri@wildebeest.org.uk>\n   Copyright (c) 2019      David Loffredo <loffredo@steptools.com>\n   Copyright (c) 2020      Joe Orton <jorton@redhat.com>\n   Copyright (c) 2020      Kleber Tarc\u00edsio <klebertarcisio@yahoo.com.br>\n   Copyright (c) 2021      Tim Bray <tbray@textuality.com>\n   Copyright (c) 2022      Martin Ettl <ettl.martin78@googlemail.com>\n   Licensed under the MIT license:\n\n   Permission is  hereby granted,  free of charge,  to any  person obtaining\n   a  copy  of  this  software   and  associated  documentation  files  (the\n   \"Software\"),  to  deal in  the  Software  without restriction,  including\n   without  limitation the  rights  to use,  copy,  modify, merge,  publish,\n   distribute, sublicense, and/or sell copies of the Software, and to permit\n   persons  to whom  the Software  is  furnished to  do so,  subject to  the\n   following conditions:\n\n   The above copyright  notice and this permission notice  shall be included\n   in all copies or substantial portions of the Software.\n\n   THE  SOFTWARE  IS  PROVIDED  \"AS  IS\",  WITHOUT  WARRANTY  OF  ANY  KIND,\n   EXPRESS  OR IMPLIED,  INCLUDING  BUT  NOT LIMITED  TO  THE WARRANTIES  OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n   NO EVENT SHALL THE AUTHORS OR  COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n   DAMAGES OR  OTHER LIABILITY, WHETHER  IN AN  ACTION OF CONTRACT,  TORT OR\n   OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n   USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#include \"expat_config.h\"\n\n#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <string.h>\n#include <math.h> /* for isnan */\n#include <errno.h>\n\n#include \"expat.h\"\n#include \"codepage.h\"\n#include \"internal.h\" /* for UNUSED_P only */\n#include \"xmlfile.h\"\n#include \"xmltchar.h\"\n\n#ifdef _MSC_VER\n#  include <crtdbg.h>\n#endif\n\n#ifdef XML_UNICODE\n#  include <wchar.h>\n#endif\n\nenum ExitCode {\n  XMLWF_EXIT_SUCCESS = 0,\n  XMLWF_EXIT_INTERNAL_ERROR = 1,\n  XMLWF_EXIT_NOT_WELLFORMED = 2,\n  XMLWF_EXIT_OUTPUT_ERROR = 3,\n  XMLWF_EXIT_USAGE_ERROR = 4,\n};\n\n/* Structures for handler user data */\ntypedef struct NotationList {\n  struct NotationList *next;\n  const XML_Char *notationName;\n  const XML_Char *systemId;\n  const XML_Char *publicId;\n} NotationList;\n\ntypedef struct xmlwfUserData {\n  FILE *fp;\n  NotationList *notationListHead;\n  const XML_Char *currentDoctypeName;\n} XmlwfUserData;\n\n/* This ensures proper sorting. */\n\n#define NSSEP T('\\001')\n\nstatic void XMLCALL\ncharacterData(void *userData, const XML_Char *s, int len) {\n  FILE *fp = ((XmlwfUserData *)userData)->fp;\n  for (; len > 0; --len, ++s) {\n    switch (*s) {\n    case T('&'):\n      fputts(T(\"&amp;\"), fp);\n      break;\n    case T('<'):\n      fputts(T(\"&lt;\"), fp);\n      break;\n    case T('>'):\n      fputts(T(\"&gt;\"), fp);\n      break;\n#ifdef W3C14N\n    case 13:\n      fputts(T(\"&#xD;\"), fp);\n      break;\n#else\n    case T('\"'):\n      fputts(T(\"&quot;\"), fp);\n      break;\n    case 9:\n    case 10:\n    case 13:\n      ftprintf(fp, T(\"&#%d;\"), *s);\n      break;\n#endif\n    default:\n      puttc(*s, fp);\n      break;\n    }\n  }\n}\n\nstatic void\nattributeValue(FILE *fp, const XML_Char *s) {\n  puttc(T('='), fp);\n  puttc(T('\"'), fp);\n  assert(s);\n  for (;;) {\n    switch (*s) {\n    case 0:\n    case NSSEP:\n      puttc(T('\"'), fp);\n      return;\n    case T('&'):\n      fputts(T(\"&amp;\"), fp);\n      break;\n    case T('<'):\n      fputts(T(\"&lt;\"), fp);\n      break;\n    case T('\"'):\n      fputts(T(\"&quot;\"), fp);\n      break;\n#ifdef W3C14N\n    case 9:\n      fputts(T(\"&#x9;\"), fp);\n      break;\n    case 10:\n      fputts(T(\"&#xA;\"), fp);\n      break;\n    case 13:\n      fputts(T(\"&#xD;\"), fp);\n      break;\n#else\n    case T('>'):\n      fputts(T(\"&gt;\"), fp);\n      break;\n    case 9:\n    case 10:\n    case 13:\n      ftprintf(fp, T(\"&#%d;\"), *s);\n      break;\n#endif\n    default:\n      puttc(*s, fp);\n      break;\n    }\n    s++;\n  }\n}\n\n/* Lexicographically comparing UTF-8 encoded attribute values,\nis equivalent to lexicographically comparing based on the character number. */\n\nstatic int\nattcmp(const void *att1, const void *att2) {\n  return tcscmp(*(const XML_Char *const *)att1, *(const XML_Char *const *)att2);\n}\n\nstatic void XMLCALL\nstartElement(void *userData, const XML_Char *name, const XML_Char **atts) {\n  int nAtts;\n  const XML_Char **p;\n  FILE *fp = ((XmlwfUserData *)userData)->fp;\n  puttc(T('<'), fp);\n  fputts(name, fp);\n\n  p = atts;\n  while (*p)\n    ++p;\n  nAtts = (int)((p - atts) >> 1);\n  if (nAtts > 1)\n    qsort((void *)atts, nAtts, sizeof(XML_Char *) * 2, attcmp);\n  while (*atts) {\n    puttc(T(' '), fp);\n    fputts(*atts++, fp);\n    attributeValue(fp, *atts);\n    atts++;\n  }\n  puttc(T('>'), fp);\n}\n\nstatic void XMLCALL\nendElement(void *userData, const XML_Char *name) {\n  FILE *fp = ((XmlwfUserData *)userData)->fp;\n  puttc(T('<'), fp);\n  puttc(T('/'), fp);\n  fputts(name, fp);\n  puttc(T('>'), fp);\n}\n\nstatic int\nnsattcmp(const void *p1, const void *p2) {\n  const XML_Char *att1 = *(const XML_Char *const *)p1;\n  const XML_Char *att2 = *(const XML_Char *const *)p2;\n  int sep1 = (tcsrchr(att1, NSSEP) != 0);\n  int sep2 = (tcsrchr(att2, NSSEP) != 0);\n  if (sep1 != sep2)\n    return sep1 - sep2;\n  return tcscmp(att1, att2);\n}\n\nstatic void XMLCALL\nstartElementNS(void *userData, const XML_Char *name, const XML_Char **atts) {\n  int nAtts;\n  int nsi;\n  const XML_Char **p;\n  FILE *fp = ((XmlwfUserData *)userData)->fp;\n  const XML_Char *sep;\n  puttc(T('<'), fp);\n\n  sep = tcsrchr(name, NSSEP);\n  if (sep) {\n    fputts(T(\"n1:\"), fp);\n    fputts(sep + 1, fp);\n    fputts(T(\" xmlns:n1\"), fp);\n    attributeValue(fp, name);\n    nsi = 2;\n  } else {\n    fputts(name, fp);\n    nsi = 1;\n  }\n\n  p = atts;\n  while (*p)\n    ++p;\n  nAtts = (int)((p - atts) >> 1);\n  if (nAtts > 1)\n    qsort((void *)atts, nAtts, sizeof(XML_Char *) * 2, nsattcmp);\n  while (*atts) {\n    name = *atts++;\n    sep = tcsrchr(name, NSSEP);\n    puttc(T(' '), fp);\n    if (sep) {\n      ftprintf(fp, T(\"n%d:\"), nsi);\n      fputts(sep + 1, fp);\n    } else\n      fputts(name, fp);\n    attributeValue(fp, *atts);\n    if (sep) {\n      ftprintf(fp, T(\" xmlns:n%d\"), nsi++);\n      attributeValue(fp, name);\n    }\n    atts++;\n  }\n  puttc(T('>'), fp);\n}\n\nstatic void XMLCALL\nendElementNS(void *userData, const XML_Char *name) {\n  FILE *fp = ((XmlwfUserData *)userData)->fp;\n  const XML_Char *sep;\n  puttc(T('<'), fp);\n  puttc(T('/'), fp);\n  sep = tcsrchr(name, NSSEP);\n  if (sep) {\n    fputts(T(\"n1:\"), fp);\n    fputts(sep + 1, fp);\n  } else\n    fputts(name, fp);\n  puttc(T('>'), fp);\n}\n\n#ifndef W3C14N\n\nstatic void XMLCALL\nprocessingInstruction(void *userData, const XML_Char *target,\n                      const XML_Char *data) {\n  FILE *fp = ((XmlwfUserData *)userData)->fp;\n  puttc(T('<'), fp);\n  puttc(T('?'), fp);\n  fputts(target, fp);\n  puttc(T(' '), fp);\n  fputts(data, fp);\n  puttc(T('?'), fp);\n  puttc(T('>'), fp);\n}\n\nstatic XML_Char *\nxcsdup(const XML_Char *s) {\n  XML_Char *result;\n  int count = 0;\n  int numBytes;\n\n  /* Get the length of the string, including terminator */\n  while (s[count++] != 0) {\n    /* Do nothing */\n  }\n  numBytes = count * sizeof(XML_Char);\n  result = malloc(numBytes);\n  if (result == NULL)\n    return NULL;\n  memcpy(result, s, numBytes);\n  return result;\n}\n\nstatic void XMLCALL\nstartDoctypeDecl(void *userData, const XML_Char *doctypeName,\n                 const XML_Char *sysid, const XML_Char *publid,\n                 int has_internal_subset) {\n  XmlwfUserData *data = (XmlwfUserData *)userData;\n  UNUSED_P(sysid);\n  UNUSED_P(publid);\n  UNUSED_P(has_internal_subset);\n  data->currentDoctypeName = xcsdup(doctypeName);\n}\n\nstatic void\nfreeNotations(XmlwfUserData *data) {\n  NotationList *notationListHead = data->notationListHead;\n\n  while (notationListHead != NULL) {\n    NotationList *next = notationListHead->next;\n    free((void *)notationListHead->notationName);\n    free((void *)notationListHead->systemId);\n    free((void *)notationListHead->publicId);\n    free(notationListHead);\n    notationListHead = next;\n  }\n  data->notationListHead = NULL;\n}\n\nstatic void\ncleanupUserData(XmlwfUserData *userData) {\n  free((void *)userData->currentDoctypeName);\n  userData->currentDoctypeName = NULL;\n  freeNotations(userData);\n}\n\nstatic int\nxcscmp(const XML_Char *xs, const XML_Char *xt) {\n  while (*xs != 0 && *xt != 0) {\n    if (*xs < *xt)\n      return -1;\n    if (*xs > *xt)\n      return 1;\n    xs++;\n    xt++;\n  }\n  if (*xs < *xt)\n    return -1;\n  if (*xs > *xt)\n    return 1;\n  return 0;\n}\n\nstatic int\nnotationCmp(const void *a, const void *b) {\n  const NotationList *const n1 = *(const NotationList *const *)a;\n  const NotationList *const n2 = *(const NotationList *const *)b;\n\n  return xcscmp(n1->notationName, n2->notationName);\n}\n\nstatic void XMLCALL\nendDoctypeDecl(void *userData) {\n  XmlwfUserData *data = (XmlwfUserData *)userData;\n  NotationList **notations;\n  int notationCount = 0;\n  NotationList *p;\n  int i;\n\n  /* How many notations do we have? */\n  for (p = data->notationListHead; p != NULL; p = p->next)\n    notationCount++;\n  if (notationCount == 0) {\n    /* Nothing to report */\n    free((void *)data->currentDoctypeName);\n    data->currentDoctypeName = NULL;\n    return;\n  }\n\n  notations = malloc(notationCount * sizeof(NotationList *));\n  if (notations == NULL) {\n    fprintf(stderr, \"Unable to sort notations\");\n    freeNotations(data);\n    return;\n  }\n\n  for (p = data->notationListHead, i = 0; i < notationCount; p = p->next, i++) {\n    notations[i] = p;\n  }\n  qsort(notations, notationCount, sizeof(NotationList *), notationCmp);\n\n  /* Output the DOCTYPE header */\n  fputts(T(\"<!DOCTYPE \"), data->fp);\n  fputts(data->currentDoctypeName, data->fp);\n  fputts(T(\" [\\n\"), data->fp);\n\n  /* Now the NOTATIONs */\n  for (i = 0; i < notationCount; i++) {\n    fputts(T(\"<!NOTATION \"), data->fp);\n    fputts(notations[i]->notationName, data->fp);\n    if (notations[i]->publicId != NULL) {\n      fputts(T(\" PUBLIC '\"), data->fp);\n      fputts(notations[i]->publicId, data->fp);\n      puttc(T('\\''), data->fp);\n      if (notations[i]->systemId != NULL) {\n        puttc(T(' '), data->fp);\n        puttc(T('\\''), data->fp);\n        fputts(notations[i]->systemId, data->fp);\n        puttc(T('\\''), data->fp);\n      }\n    } else if (notations[i]->systemId != NULL) {\n      fputts(T(\" SYSTEM '\"), data->fp);\n      fputts(notations[i]->systemId, data->fp);\n      puttc(T('\\''), data->fp);\n    }\n    puttc(T('>'), data->fp);\n    puttc(T('\\n'), data->fp);\n  }\n\n  /* Finally end the DOCTYPE */\n  fputts(T(\"]>\\n\"), data->fp);\n\n  free(notations);\n  freeNotations(data);\n  free((void *)data->currentDoctypeName);\n  data->currentDoctypeName = NULL;\n}\n\nstatic void XMLCALL\nnotationDecl(void *userData, const XML_Char *notationName, const XML_Char *base,\n             const XML_Char *systemId, const XML_Char *publicId) {\n  XmlwfUserData *data = (XmlwfUserData *)userData;\n  NotationList *entry = malloc(sizeof(NotationList));\n  const char *errorMessage = \"Unable to store NOTATION for output\\n\";\n\n  UNUSED_P(base);\n  if (entry == NULL) {\n    fputs(errorMessage, stderr);\n    return; /* Nothing we can really do about this */\n  }\n  entry->notationName = xcsdup(notationName);\n  if (entry->notationName == NULL) {\n    fputs(errorMessage, stderr);\n    free(entry);\n    return;\n  }\n  if (systemId != NULL) {\n    entry->systemId = xcsdup(systemId);\n    if (entry->systemId == NULL) {\n      fputs(errorMessage, stderr);\n      free((void *)entry->notationName);\n      free(entry);\n      return;\n    }\n  } else {\n    entry->systemId = NULL;\n  }\n  if (publicId != NULL) {\n    entry->publicId = xcsdup(publicId);\n    if (entry->publicId == NULL) {\n      fputs(errorMessage, stderr);\n      free((void *)entry->systemId); /* Safe if it's NULL */\n      free((void *)entry->notationName);\n      free(entry);\n      return;\n    }\n  } else {\n    entry->publicId = NULL;\n  }\n\n  entry->next = data->notationListHead;\n  data->notationListHead = entry;\n}\n\n#endif /* not W3C14N */\n\nstatic void XMLCALL\ndefaultCharacterData(void *userData, const XML_Char *s, int len) {\n  UNUSED_P(s);\n  UNUSED_P(len);\n  XML_DefaultCurrent((XML_Parser)userData);\n}\n\nstatic void XMLCALL\ndefaultStartElement(void *userData, const XML_Char *name,\n                    const XML_Char **atts) {\n  UNUSED_P(name);\n  UNUSED_P(atts);\n  XML_DefaultCurrent((XML_Parser)userData);\n}\n\nstatic void XMLCALL\ndefaultEndElement(void *userData, const XML_Char *name) {\n  UNUSED_P(name);\n  XML_DefaultCurrent((XML_Parser)userData);\n}\n\nstatic void XMLCALL\ndefaultProcessingInstruction(void *userData, const XML_Char *target,\n                             const XML_Char *data) {\n  UNUSED_P(target);\n  UNUSED_P(data);\n  XML_DefaultCurrent((XML_Parser)userData);\n}\n\nstatic void XMLCALL\nnopCharacterData(void *userData, const XML_Char *s, int len) {\n  UNUSED_P(userData);\n  UNUSED_P(s);\n  UNUSED_P(len);\n}\n\nstatic void XMLCALL\nnopStartElement(void *userData, const XML_Char *name, const XML_Char **atts) {\n  UNUSED_P(userData);\n  UNUSED_P(name);\n  UNUSED_P(atts);\n}\n\nstatic void XMLCALL\nnopEndElement(void *userData, const XML_Char *name) {\n  UNUSED_P(userData);\n  UNUSED_P(name);\n}\n\nstatic void XMLCALL\nnopProcessingInstruction(void *userData, const XML_Char *target,\n                         const XML_Char *data) {\n  UNUSED_P(userData);\n  UNUSED_P(target);\n  UNUSED_P(data);\n}\n\nstatic void XMLCALL\nmarkup(void *userData, const XML_Char *s, int len) {\n  FILE *fp = ((XmlwfUserData *)XML_GetUserData((XML_Parser)userData))->fp;\n  for (; len > 0; --len, ++s)\n    puttc(*s, fp);\n}\n\nstatic void\nmetaLocation(XML_Parser parser) {\n  const XML_Char *uri = XML_GetBase(parser);\n  FILE *fp = ((XmlwfUserData *)XML_GetUserData(parser))->fp;\n  if (uri)\n    ftprintf(fp, T(\" uri=\\\"%s\\\"\"), uri);\n  ftprintf(fp,\n           T(\" byte=\\\"%\") T(XML_FMT_INT_MOD) T(\"d\\\"\") T(\" nbytes=\\\"%d\\\"\")\n               T(\" line=\\\"%\") T(XML_FMT_INT_MOD) T(\"u\\\"\") T(\" col=\\\"%\")\n                   T(XML_FMT_INT_MOD) T(\"u\\\"\"),\n           XML_GetCurrentByteIndex(parser), XML_GetCurrentByteCount(parser),\n           XML_GetCurrentLineNumber(parser),\n           XML_GetCurrentColumnNumber(parser));\n}\n\nstatic void\nmetaStartDocument(void *userData) {\n  fputts(T(\"<document>\\n\"),\n         ((XmlwfUserData *)XML_GetUserData((XML_Parser)userData))->fp);\n}\n\nstatic void\nmetaEndDocument(void *userData) {\n  fputts(T(\"</document>\\n\"),\n         ((XmlwfUserData *)XML_GetUserData((XML_Parser)userData))->fp);\n}\n\nstatic void XMLCALL\nmetaStartElement(void *userData, const XML_Char *name, const XML_Char **atts) {\n  XML_Parser parser = (XML_Parser)userData;\n  XmlwfUserData *data = (XmlwfUserData *)XML_GetUserData(parser);\n  FILE *fp = data->fp;\n  const XML_Char **specifiedAttsEnd\n      = atts + XML_GetSpecifiedAttributeCount(parser);\n  const XML_Char **idAttPtr;\n  int idAttIndex = XML_GetIdAttributeIndex(parser);\n  if (idAttIndex < 0)\n    idAttPtr = 0;\n  else\n    idAttPtr = atts + idAttIndex;\n\n  ftprintf(fp, T(\"<starttag name=\\\"%s\\\"\"), name);\n  metaLocation(parser);\n  if (*atts) {\n    fputts(T(\">\\n\"), fp);\n    do {\n      ftprintf(fp, T(\"<attribute name=\\\"%s\\\" value=\\\"\"), atts[0]);\n      characterData(data, atts[1], (int)tcslen(atts[1]));\n      if (atts >= specifiedAttsEnd)\n        fputts(T(\"\\\" defaulted=\\\"yes\\\"/>\\n\"), fp);\n      else if (atts == idAttPtr)\n        fputts(T(\"\\\" id=\\\"yes\\\"/>\\n\"), fp);\n      else\n        fputts(T(\"\\\"/>\\n\"), fp);\n    } while (*(atts += 2));\n    fputts(T(\"</starttag>\\n\"), fp);\n  } else\n    fputts(T(\"/>\\n\"), fp);\n}\n\nstatic void XMLCALL\nmetaEndElement(void *userData, const XML_Char *name) {\n  XML_Parser parser = (XML_Parser)userData;\n  XmlwfUserData *data = (XmlwfUserData *)XML_GetUserData(parser);\n  FILE *fp = data->fp;\n  ftprintf(fp, T(\"<endtag name=\\\"%s\\\"\"), name);\n  metaLocation(parser);\n  fputts(T(\"/>\\n\"), fp);\n}\n\nstatic void XMLCALL\nmetaProcessingInstruction(void *userData, const XML_Char *target,\n                          const XML_Char *data) {\n  XML_Parser parser = (XML_Parser)userData;\n  XmlwfUserData *usrData = (XmlwfUserData *)XML_GetUserData(parser);\n  FILE *fp = usrData->fp;\n  ftprintf(fp, T(\"<pi target=\\\"%s\\\" data=\\\"\"), target);\n  characterData(usrData, data, (int)tcslen(data));\n  puttc(T('\"'), fp);\n  metaLocation(parser);\n  fputts(T(\"/>\\n\"), fp);\n}\n\nstatic void XMLCALL\nmetaComment(void *userData, const XML_Char *data) {\n  XML_Parser parser = (XML_Parser)userData;\n  XmlwfUserData *usrData = (XmlwfUserData *)XML_GetUserData(parser);\n  FILE *fp = usrData->fp;\n  fputts(T(\"<comment data=\\\"\"), fp);\n  characterData(usrData, data, (int)tcslen(data));\n  puttc(T('\"'), fp);\n  metaLocation(parser);\n  fputts(T(\"/>\\n\"), fp);\n}\n\nstatic void XMLCALL\nmetaStartCdataSection(void *userData) {\n  XML_Parser parser = (XML_Parser)userData;\n  XmlwfUserData *data = (XmlwfUserData *)XML_GetUserData(parser);\n  FILE *fp = data->fp;\n  fputts(T(\"<startcdata\"), fp);\n  metaLocation(parser);\n  fputts(T(\"/>\\n\"), fp);\n}\n\nstatic void XMLCALL\nmetaEndCdataSection(void *userData) {\n  XML_Parser parser = (XML_Parser)userData;\n  XmlwfUserData *data = (XmlwfUserData *)XML_GetUserData(parser);\n  FILE *fp = data->fp;\n  fputts(T(\"<endcdata\"), fp);\n  metaLocation(parser);\n  fputts(T(\"/>\\n\"), fp);\n}\n\nstatic void XMLCALL\nmetaCharacterData(void *userData, const XML_Char *s, int len) {\n  XML_Parser parser = (XML_Parser)userData;\n  XmlwfUserData *data = (XmlwfUserData *)XML_GetUserData(parser);\n  FILE *fp = data->fp;\n  fputts(T(\"<chars str=\\\"\"), fp);\n  characterData(data, s, len);\n  puttc(T('\"'), fp);\n  metaLocation(parser);\n  fputts(T(\"/>\\n\"), fp);\n}\n\nstatic void XMLCALL\nmetaStartDoctypeDecl(void *userData, const XML_Char *doctypeName,\n                     const XML_Char *sysid, const XML_Char *pubid,\n                     int has_internal_subset) {\n  XML_Parser parser = (XML_Parser)userData;\n  XmlwfUserData *data = (XmlwfUserData *)XML_GetUserData(parser);\n  FILE *fp = data->fp;\n  UNUSED_P(sysid);\n  UNUSED_P(pubid);\n  UNUSED_P(has_internal_subset);\n  ftprintf(fp, T(\"<startdoctype name=\\\"%s\\\"\"), doctypeName);\n  metaLocation(parser);\n  fputts(T(\"/>\\n\"), fp);\n}\n\nstatic void XMLCALL\nmetaEndDoctypeDecl(void *userData) {\n  XML_Parser parser = (XML_Parser)userData;\n  XmlwfUserData *data = (XmlwfUserData *)XML_GetUserData(parser);\n  FILE *fp = data->fp;\n  fputts(T(\"<enddoctype\"), fp);\n  metaLocation(parser);\n  fputts(T(\"/>\\n\"), fp);\n}\n\nstatic void XMLCALL\nmetaNotationDecl(void *userData, const XML_Char *notationName,\n                 const XML_Char *base, const XML_Char *systemId,\n                 const XML_Char *publicId) {\n  XML_Parser parser = (XML_Parser)userData;\n  XmlwfUserData *data = (XmlwfUserData *)XML_GetUserData(parser);\n  FILE *fp = data->fp;\n  UNUSED_P(base);\n  ftprintf(fp, T(\"<notation name=\\\"%s\\\"\"), notationName);\n  if (publicId)\n    ftprintf(fp, T(\" public=\\\"%s\\\"\"), publicId);\n  if (systemId) {\n    fputts(T(\" system=\\\"\"), fp);\n    characterData(data, systemId, (int)tcslen(systemId));\n    puttc(T('\"'), fp);\n  }\n  metaLocation(parser);\n  fputts(T(\"/>\\n\"), fp);\n}\n\nstatic void XMLCALL\nmetaEntityDecl(void *userData, const XML_Char *entityName, int is_param,\n               const XML_Char *value, int value_length, const XML_Char *base,\n               const XML_Char *systemId, const XML_Char *publicId,\n               const XML_Char *notationName) {\n  XML_Parser parser = (XML_Parser)userData;\n  XmlwfUserData *data = (XmlwfUserData *)XML_GetUserData(parser);\n  FILE *fp = data->fp;\n\n  UNUSED_P(is_param);\n  UNUSED_P(base);\n  if (value) {\n    ftprintf(fp, T(\"<entity name=\\\"%s\\\"\"), entityName);\n    metaLocation(parser);\n    puttc(T('>'), fp);\n    characterData(data, value, value_length);\n    fputts(T(\"</entity/>\\n\"), fp);\n  } else if (notationName) {\n    ftprintf(fp, T(\"<entity name=\\\"%s\\\"\"), entityName);\n    if (publicId)\n      ftprintf(fp, T(\" public=\\\"%s\\\"\"), publicId);\n    fputts(T(\" system=\\\"\"), fp);\n    characterData(data, systemId, (int)tcslen(systemId));\n    puttc(T('\"'), fp);\n    ftprintf(fp, T(\" notation=\\\"%s\\\"\"), notationName);\n    metaLocation(parser);\n    fputts(T(\"/>\\n\"), fp);\n  } else {\n    ftprintf(fp, T(\"<entity name=\\\"%s\\\"\"), entityName);\n    if (publicId)\n      ftprintf(fp, T(\" public=\\\"%s\\\"\"), publicId);\n    fputts(T(\" system=\\\"\"), fp);\n    characterData(data, systemId, (int)tcslen(systemId));\n    puttc(T('\"'), fp);\n    metaLocation(parser);\n    fputts(T(\"/>\\n\"), fp);\n  }\n}\n\nstatic void XMLCALL\nmetaStartNamespaceDecl(void *userData, const XML_Char *prefix,\n                       const XML_Char *uri) {\n  XML_Parser parser = (XML_Parser)userData;\n  XmlwfUserData *data = (XmlwfUserData *)XML_GetUserData(parser);\n  FILE *fp = data->fp;\n  fputts(T(\"<startns\"), fp);\n  if (prefix)\n    ftprintf(fp, T(\" prefix=\\\"%s\\\"\"), prefix);\n  if (uri) {\n    fputts(T(\" ns=\\\"\"), fp);\n    characterData(data, uri, (int)tcslen(uri));\n    fputts(T(\"\\\"/>\\n\"), fp);\n  } else\n    fputts(T(\"/>\\n\"), fp);\n}\n\nstatic void XMLCALL\nmetaEndNamespaceDecl(void *userData, const XML_Char *prefix) {\n  XML_Parser parser = (XML_Parser)userData;\n  XmlwfUserData *data = (XmlwfUserData *)XML_GetUserData(parser);\n  FILE *fp = data->fp;\n  if (! prefix)\n    fputts(T(\"<endns/>\\n\"), fp);\n  else\n    ftprintf(fp, T(\"<endns prefix=\\\"%s\\\"/>\\n\"), prefix);\n}\n\nstatic int XMLCALL\nunknownEncodingConvert(void *data, const char *p) {\n  return codepageConvert(*(int *)data, p);\n}\n\nstatic int XMLCALL\nunknownEncoding(void *userData, const XML_Char *name, XML_Encoding *info) {\n  int cp;\n  static const XML_Char prefixL[] = T(\"windows-\");\n  static const XML_Char prefixU[] = T(\"WINDOWS-\");\n  int i;\n\n  UNUSED_P(userData);\n  for (i = 0; prefixU[i]; i++)\n    if (name[i] != prefixU[i] && name[i] != prefixL[i])\n      return 0;\n\n  cp = 0;\n  for (; name[i]; i++) {\n    static const XML_Char digits[] = T(\"0123456789\");\n    const XML_Char *s = tcschr(digits, name[i]);\n    if (! s)\n      return 0;\n    cp *= 10;\n    cp += (int)(s - digits);\n    if (cp >= 0x10000)\n      return 0;\n  }\n  if (! codepageMap(cp, info->map))\n    return 0;\n  info->convert = unknownEncodingConvert;\n  /* We could just cast the code page integer to a void *,\n  and avoid the use of release. */\n  info->release = free;\n  info->data = malloc(sizeof(int));\n  if (! info->data)\n    return 0;\n  *(int *)info->data = cp;\n  return 1;\n}\n\nstatic int XMLCALL\nnotStandalone(void *userData) {\n  UNUSED_P(userData);\n  return 0;\n}\n\nstatic void\nshowVersion(XML_Char *prog) {\n  XML_Char *s = prog;\n  XML_Char ch;\n  const XML_Feature *features = XML_GetFeatureList();\n  while ((ch = *s) != 0) {\n    if (ch == '/'\n#if defined(_WIN32)\n        || ch == '\\\\'\n#endif\n    )\n      prog = s + 1;\n    ++s;\n  }\n  ftprintf(stdout, T(\"%s using %s\\n\"), prog, XML_ExpatVersion());\n  if (features != NULL && features[0].feature != XML_FEATURE_END) {\n    int i = 1;\n    ftprintf(stdout, T(\"%s\"), features[0].name);\n    if (features[0].value)\n      ftprintf(stdout, T(\"=%ld\"), features[0].value);\n    while (features[i].feature != XML_FEATURE_END) {\n      ftprintf(stdout, T(\", %s\"), features[i].name);\n      if (features[i].value)\n        ftprintf(stdout, T(\"=%ld\"), features[i].value);\n      ++i;\n    }\n    ftprintf(stdout, T(\"\\n\"));\n  }\n}\n\n#if defined(__GNUC__)\n__attribute__((noreturn))\n#endif\nstatic void\nusage(const XML_Char *prog, int rc) {\n  ftprintf(\n      stderr,\n      /* Generated with:\n       * $ xmlwf/xmlwf_helpgen.sh\n       * To update, change xmlwf/xmlwf_helpgen.py, then paste the output of\n       * xmlwf/xmlwf_helpgen.sh in here.\n       */\n      /* clang-format off */\n      T(\"usage:\\n\")\n      T(\"  %s [OPTIONS] [FILE ...]\\n\")\n      T(\"  %s -h|--help\\n\")\n      T(\"  %s -v|--version\\n\")\n      T(\"\\n\")\n      T(\"xmlwf - Determines if an XML document is well-formed\\n\")\n      T(\"\\n\")\n      T(\"positional arguments:\\n\")\n      T(\"  FILE           file to process (default: STDIN)\\n\")\n      T(\"\\n\")\n      T(\"input control arguments:\\n\")\n      T(\"  -s             print an error if the document is not [s]tandalone\\n\")\n      T(\"  -n             enable [n]amespace processing\\n\")\n      T(\"  -p             enable processing of external DTDs and [p]arameter entities\\n\")\n      T(\"  -x             enable processing of e[x]ternal entities\\n\")\n      T(\"  -e ENCODING    override any in-document [e]ncoding declaration\\n\")\n      T(\"  -w             enable support for [W]indows code pages\\n\")\n      T(\"  -r             disable memory-mapping and use [r]ead calls instead\\n\")\n      T(\"  -g BYTES       buffer size to request per call pair to XML_[G]etBuffer and read (default: 8 KiB)\\n\")\n      T(\"  -k             when processing multiple files, [k]eep processing after first file with error\\n\")\n      T(\"\\n\")\n      T(\"output control arguments:\\n\")\n      T(\"  -d DIRECTORY   output [d]estination directory\\n\")\n      T(\"  -c             write a [c]opy of input XML, not canonical XML\\n\")\n      T(\"  -m             write [m]eta XML, not canonical XML\\n\")\n      T(\"  -t             write no XML output for [t]iming of plain parsing\\n\")\n      T(\"  -N             enable adding doctype and [n]otation declarations\\n\")\n      T(\"\\n\")\n      T(\"billion laughs attack protection:\\n\")\n      T(\"  NOTE: If you ever need to increase these values for non-attack payload, please file a bug report.\\n\")\n      T(\"\\n\")\n      T(\"  -a FACTOR      set maximum tolerated [a]mplification factor (default: 100.0)\\n\")\n      T(\"  -b BYTES       set number of output [b]ytes needed to activate (default: 8 MiB)\\n\")\n      T(\"\\n\")\n      T(\"info arguments:\\n\")\n      T(\"  -h, --help     show this [h]elp message and exit\\n\")\n      T(\"  -v, --version  show program's [v]ersion number and exit\\n\")\n      T(\"\\n\")\n      T(\"exit status:\\n\")\n      T(\"  0              the input files are well-formed and the output (if requested) was written successfully\\n\")\n      T(\"  1              could not allocate data structures, signals a serious problem with execution environment\\n\")\n      T(\"  2              one or more input files were not well-formed\\n\")\n      T(\"  3              could not create an output file\\n\")\n      T(\"  4              command-line argument error\\n\")\n      T(\"\\n\")\n      T(\"xmlwf of libexpat is software libre, licensed under the MIT license.\\n\")\n      T(\"Please report bugs at https://github.com/libexpat/libexpat/issues -- thank you!\\n\")\n      , /* clang-format on */\n      prog, prog, prog);\n  exit(rc);\n}\n\n#if defined(__MINGW32__) && defined(XML_UNICODE)\n/* Silence warning about missing prototype */\nint wmain(int argc, XML_Char **argv);\n#endif\n\n#define XMLWF_SHIFT_ARG_INTO(constCharStarTarget, argc, argv, i, j)            \\\n  {                                                                            \\\n    if (argv[i][j + 1] == T('\\0')) {                                           \\\n      if (++i == argc) {                                                       \\\n        usage(argv[0], XMLWF_EXIT_USAGE_ERROR);                                \\\n        /* usage called exit(..), never gets here */                           \\\n      }                                                                        \\\n      constCharStarTarget = argv[i];                                           \\\n    } else {                                                                   \\\n      constCharStarTarget = argv[i] + j + 1;                                   \\\n    }                                                                          \\\n    i++;                                                                       \\\n    j = 0;                                                                     \\\n  }\n\nint\ntmain(int argc, XML_Char **argv) {\n  int i, j;\n  const XML_Char *outputDir = NULL;\n  const XML_Char *encoding = NULL;\n  unsigned processFlags = XML_MAP_FILE;\n  int windowsCodePages = 0;\n  int outputType = 0;\n  int useNamespaces = 0;\n  int requireStandalone = 0;\n  int requiresNotations = 0;\n  int continueOnError = 0;\n\n  float attackMaximumAmplification = -1.0f; /* signaling \"not set\" */\n  unsigned long long attackThresholdBytes = 0;\n  XML_Bool attackThresholdGiven = XML_FALSE;\n\n  int exitCode = XMLWF_EXIT_SUCCESS;\n  enum XML_ParamEntityParsing paramEntityParsing\n      = XML_PARAM_ENTITY_PARSING_NEVER;\n  int useStdin = 0;\n  XmlwfUserData userData = {NULL, NULL, NULL};\n\n#ifdef _MSC_VER\n  _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);\n#endif\n\n  i = 1;\n  j = 0;\n  while (i < argc) {\n    if (j == 0) {\n      if (argv[i][0] != T('-'))\n        break;\n      if (argv[i][1] == T('-')) {\n        if (argv[i][2] == T('\\0')) {\n          i++;\n          break;\n        } else if (tcscmp(argv[i] + 2, T(\"help\")) == 0) {\n          usage(argv[0], XMLWF_EXIT_SUCCESS);\n          // usage called exit(..), never gets here\n        } else if (tcscmp(argv[i] + 2, T(\"version\")) == 0) {\n          showVersion(argv[0]);\n          return XMLWF_EXIT_SUCCESS;\n        }\n      }\n      j++;\n    }\n    switch (argv[i][j]) {\n    case T('r'):\n      processFlags &= ~XML_MAP_FILE;\n      j++;\n      break;\n    case T('s'):\n      requireStandalone = 1;\n      j++;\n      break;\n    case T('n'):\n      useNamespaces = 1;\n      j++;\n      break;\n    case T('p'):\n      paramEntityParsing = XML_PARAM_ENTITY_PARSING_ALWAYS;\n      /* fall through */\n    case T('x'):\n      processFlags |= XML_EXTERNAL_ENTITIES;\n      j++;\n      break;\n    case T('w'):\n      windowsCodePages = 1;\n      j++;\n      break;\n    case T('m'):\n      outputType = 'm';\n      j++;\n      break;\n    case T('c'):\n      outputType = 'c';\n      useNamespaces = 0;\n      j++;\n      break;\n    case T('t'):\n      outputType = 't';\n      j++;\n      break;\n    case T('N'):\n      requiresNotations = 1;\n      j++;\n      break;\n    case T('d'):\n      XMLWF_SHIFT_ARG_INTO(outputDir, argc, argv, i, j);\n      break;\n    case T('e'):\n      XMLWF_SHIFT_ARG_INTO(encoding, argc, argv, i, j);\n      break;\n    case T('h'):\n      usage(argv[0], XMLWF_EXIT_SUCCESS);\n      // usage called exit(..), never gets here\n    case T('v'):\n      showVersion(argv[0]);\n      return XMLWF_EXIT_SUCCESS;\n    case T('g'): {\n      const XML_Char *valueText = NULL;\n      XMLWF_SHIFT_ARG_INTO(valueText, argc, argv, i, j);\n\n      errno = 0;\n      XML_Char *afterValueText = (XML_Char *)valueText;\n      const long long read_size_bytes_candidate\n          = tcstoull(valueText, &afterValueText, 10);\n      if ((errno != 0) || (afterValueText[0] != T('\\0'))\n          || (read_size_bytes_candidate < 1)\n          || (read_size_bytes_candidate > (INT_MAX / 2 + 1))) {\n        // This prevents tperror(..) from reporting misleading \"[..]: Success\"\n        errno = ERANGE;\n        tperror(T(\"invalid buffer size\") T(\n            \" (needs an integer from 1 to INT_MAX/2+1 i.e. 1,073,741,824 on most platforms)\"));\n        exit(XMLWF_EXIT_USAGE_ERROR);\n      }\n      g_read_size_bytes = (int)read_size_bytes_candidate;\n      break;\n    }\n    case T('k'):\n      continueOnError = 1;\n      j++;\n      break;\n    case T('a'): {\n      const XML_Char *valueText = NULL;\n      XMLWF_SHIFT_ARG_INTO(valueText, argc, argv, i, j);\n\n      errno = 0;\n      XML_Char *afterValueText = NULL;\n      attackMaximumAmplification = tcstof(valueText, &afterValueText);\n      if ((errno != 0) || (afterValueText[0] != T('\\0'))\n          || isnan(attackMaximumAmplification)\n          || (attackMaximumAmplification < 1.0f)) {\n        // This prevents tperror(..) from reporting misleading \"[..]: Success\"\n        errno = ERANGE;\n        tperror(T(\"invalid amplification limit\") T(\n            \" (needs a floating point number greater or equal than 1.0)\"));\n        exit(XMLWF_EXIT_USAGE_ERROR);\n      }\n#ifndef XML_DTD\n      ftprintf(stderr, T(\"Warning: Given amplification limit ignored\") T(\n                           \", xmlwf has been compiled without DTD support.\\n\"));\n#endif\n      break;\n    }\n    case T('b'): {\n      const XML_Char *valueText = NULL;\n      XMLWF_SHIFT_ARG_INTO(valueText, argc, argv, i, j);\n\n      errno = 0;\n      XML_Char *afterValueText = (XML_Char *)valueText;\n      attackThresholdBytes = tcstoull(valueText, &afterValueText, 10);\n      if ((errno != 0) || (afterValueText[0] != T('\\0'))) {\n        // This prevents tperror(..) from reporting misleading \"[..]: Success\"\n        errno = ERANGE;\n        tperror(T(\"invalid ignore threshold\")\n                    T(\" (needs an integer from 0 to 2^64-1)\"));\n        exit(XMLWF_EXIT_USAGE_ERROR);\n      }\n      attackThresholdGiven = XML_TRUE;\n#ifndef XML_DTD\n      ftprintf(stderr, T(\"Warning: Given attack threshold ignored\") T(\n                           \", xmlwf has been compiled without DTD support.\\n\"));\n#endif\n      break;\n    }\n    case T('\\0'):\n      if (j > 1) {\n        i++;\n        j = 0;\n        break;\n      }\n      /* fall through */\n    default:\n      usage(argv[0], XMLWF_EXIT_USAGE_ERROR);\n      // usage called exit(..), never gets here\n    }\n  }\n  if (i == argc) {\n    useStdin = 1;\n    processFlags &= ~XML_MAP_FILE;\n    i--;\n  }\n  for (; i < argc; i++) {\n    XML_Char *outName = 0;\n    int result;\n    XML_Parser parser;\n    if (useNamespaces)\n      parser = XML_ParserCreateNS(encoding, NSSEP);\n    else\n      parser = XML_ParserCreate(encoding);\n\n    if (! parser) {\n      tperror(T(\"Could not instantiate parser\"));\n      exit(XMLWF_EXIT_INTERNAL_ERROR);\n    }\n\n    if (attackMaximumAmplification != -1.0f) {\n#ifdef XML_DTD\n      XML_SetBillionLaughsAttackProtectionMaximumAmplification(\n          parser, attackMaximumAmplification);\n#endif\n    }\n    if (attackThresholdGiven) {\n#ifdef XML_DTD\n      XML_SetBillionLaughsAttackProtectionActivationThreshold(\n          parser, attackThresholdBytes);\n#else\n      (void)attackThresholdBytes; // silence -Wunused-but-set-variable\n#endif\n    }\n\n    if (requireStandalone)\n      XML_SetNotStandaloneHandler(parser, notStandalone);\n    XML_SetParamEntityParsing(parser, paramEntityParsing);\n    if (outputType == 't') {\n      /* This is for doing timings; this gives a more realistic estimate of\n         the parsing time. */\n      outputDir = 0;\n      XML_SetElementHandler(parser, nopStartElement, nopEndElement);\n      XML_SetCharacterDataHandler(parser, nopCharacterData);\n      XML_SetProcessingInstructionHandler(parser, nopProcessingInstruction);\n    } else if (outputDir) {\n      const XML_Char *delim = T(\"/\");\n      const XML_Char *file = useStdin ? T(\"STDIN\") : argv[i];\n      if (! useStdin) {\n        /* Jump after last (back)slash */\n        const XML_Char *lastDelim = tcsrchr(file, delim[0]);\n        if (lastDelim)\n          file = lastDelim + 1;\n#if defined(_WIN32)\n        else {\n          const XML_Char *winDelim = T(\"\\\\\");\n          lastDelim = tcsrchr(file, winDelim[0]);\n          if (lastDelim) {\n            file = lastDelim + 1;\n            delim = winDelim;\n          }\n        }\n#endif\n      }\n      outName = (XML_Char *)malloc((tcslen(outputDir) + tcslen(file) + 2)\n                                   * sizeof(XML_Char));\n      if (! outName) {\n        tperror(T(\"Could not allocate memory\"));\n        exit(XMLWF_EXIT_INTERNAL_ERROR);\n      }\n      tcscpy(outName, outputDir);\n      tcscat(outName, delim);\n      tcscat(outName, file);\n      userData.fp = tfopen(outName, T(\"wb\"));\n      if (! userData.fp) {\n        tperror(outName);\n        exitCode = XMLWF_EXIT_OUTPUT_ERROR;\n        free(outName);\n        XML_ParserFree(parser);\n        if (continueOnError) {\n          continue;\n        } else {\n          break;\n        }\n      }\n      setvbuf(userData.fp, NULL, _IOFBF, 16384);\n#ifdef XML_UNICODE\n      puttc(0xFEFF, userData.fp);\n#endif\n      XML_SetUserData(parser, &userData);\n      switch (outputType) {\n      case 'm':\n        XML_UseParserAsHandlerArg(parser);\n        XML_SetElementHandler(parser, metaStartElement, metaEndElement);\n        XML_SetProcessingInstructionHandler(parser, metaProcessingInstruction);\n        XML_SetCommentHandler(parser, metaComment);\n        XML_SetCdataSectionHandler(parser, metaStartCdataSection,\n                                   metaEndCdataSection);\n        XML_SetCharacterDataHandler(parser, metaCharacterData);\n        XML_SetDoctypeDeclHandler(parser, metaStartDoctypeDecl,\n                                  metaEndDoctypeDecl);\n        XML_SetEntityDeclHandler(parser, metaEntityDecl);\n        XML_SetNotationDeclHandler(parser, metaNotationDecl);\n        XML_SetNamespaceDeclHandler(parser, metaStartNamespaceDecl,\n                                    metaEndNamespaceDecl);\n        metaStartDocument(parser);\n        break;\n      case 'c':\n        XML_UseParserAsHandlerArg(parser);\n        XML_SetDefaultHandler(parser, markup);\n        XML_SetElementHandler(parser, defaultStartElement, defaultEndElement);\n        XML_SetCharacterDataHandler(parser, defaultCharacterData);\n        XML_SetProcessingInstructionHandler(parser,\n                                            defaultProcessingInstruction);\n        break;\n      default:\n        if (useNamespaces)\n          XML_SetElementHandler(parser, startElementNS, endElementNS);\n        else\n          XML_SetElementHandler(parser, startElement, endElement);\n        XML_SetCharacterDataHandler(parser, characterData);\n#ifndef W3C14N\n        XML_SetProcessingInstructionHandler(parser, processingInstruction);\n        if (requiresNotations) {\n          XML_SetDoctypeDeclHandler(parser, startDoctypeDecl, endDoctypeDecl);\n          XML_SetNotationDeclHandler(parser, notationDecl);\n        }\n#endif /* not W3C14N */\n        break;\n      }\n    }\n    if (windowsCodePages)\n      XML_SetUnknownEncodingHandler(parser, unknownEncoding, 0);\n    result = XML_ProcessFile(parser, useStdin ? NULL : argv[i], processFlags);\n    if (outputDir) {\n      if (outputType == 'm')\n        metaEndDocument(parser);\n      fclose(userData.fp);\n      if (! result) {\n        tremove(outName);\n      }\n      free(outName);\n    }\n    XML_ParserFree(parser);\n    if (! result) {\n      exitCode = XMLWF_EXIT_NOT_WELLFORMED;\n      cleanupUserData(&userData);\n      if (! continueOnError) {\n        break;\n      }\n    }\n  }\n  return exitCode;\n}\n"], "fixing_code": ["#                          __  __            _\n#                       ___\\ \\/ /_ __   __ _| |_\n#                      / _ \\\\  /| '_ \\ / _` | __|\n#                     |  __//  \\| |_) | (_| | |_\n#                      \\___/_/\\_\\ .__/ \\__,_|\\__|\n#                               |_| XML parser\n#\n# Copyright (c) 2010      Patrick Spendrin <ps_ml@gmx.de>\n# Copyright (c) 2012      Karl Waclawek <karl@waclawek.net>\n# Copyright (c) 2016-2022 Sebastian Pipping <sebastian@pipping.org>\n# Copyright (c) 2016      Sergei Nikulov <sergey.nikulov@gmail.com>\n# Copyright (c) 2016      Bj\u00f6rn Lindahl <bjorn.lindahl@foi.se>\n# Copyright (c) 2016      Tobias Taschner <github@tc84.de>\n# Copyright (c) 2016      Ben Boeckel <ben.boeckel@kitware.com>\n# Copyright (c) 2017      Rhodri James <rhodri@wildebeest.org.uk>\n# Copyright (c) 2017      Rolf Eike Beer <eike@sf-mail.de>\n# Copyright (c) 2017      Stephen Groat <stephen@groat.us>\n# Copyright (c) 2017      Franek Korta <fkorta@gmail.com>\n# Copyright (c) 2018      pedro-vicente <pedro.vicente@space-research.org>\n# Copyright (c) 2018      Frank Rast <frank.rast@gefeg.com>\n# Copyright (c) 2018      userwithuid <userwithuid@gmail.com>\n# Copyright (c) 2018      Yury Gribov <tetra2005@gmail.com>\n# Copyright (c) 2019      Kishore Kunche <kishore.kunche@intel.com>\n# Copyright (c) 2019      xantares <xantares09@hotmail.com>\n# Copyright (c) 2019      Mohammed Khajapasha <mohammed.khajapasha@intel.com>\n# Copyright (c) 2019      David Loffredo <loffredo@steptools.com>\n# Copyright (c) 2019      Bhargava Shastry <bhargava.shastry@ethereum.org>\n# Copyright (c) 2020      Maciej Sroczy\u0144ski <macieksroczynski@poczta.fm>\n# Copyright (c) 2020      Gulliver <gulliver@traumkristalle.net>\n# Copyright (c) 2020      Thomas Beutlich <tc@tbeu.de>\n# Copyright (c) 2021      Alex Richardson <Alexander.Richardson@cl.cam.ac.uk>\n# Copyright (c) 2022      Johnny Jazeix <jazeix@gmail.com>\n# Copyright (c) 2022      David Faure <david.faure@kdab.com>\n# Unlike most of Expat,\n# this file is copyrighted under the BSD-license for buildsystem files of KDE.\n\ncmake_minimum_required(VERSION 3.5.0)\n\nproject(expat\n    VERSION\n        2.5.0\n    LANGUAGES\n        C\n)\nset(CMAKE_C_STANDARD 99)\nset(CMAKE_C_STANDARD_REQUIRED ON)\nset(CMAKE_C_EXTENSIONS OFF)  # i.e. -std=c99 rather than default -std=gnu99\n\nset(PACKAGE_BUGREPORT \"expat-bugs@libexpat.org\")\nset(PACKAGE_NAME \"expat\")\nset(PACKAGE_VERSION \"${PROJECT_VERSION}\")\nset(PACKAGE_STRING \"${PACKAGE_NAME} ${PACKAGE_VERSION}\")\nset(PACKAGE_TARNAME \"${PACKAGE_NAME}\")\n\ninclude(CMakePackageConfigHelpers)\ninclude(GNUInstallDirs)\n\n#\n# Configuration defaults\n#\nif(WINCE)\n    set(_EXPAT_BUILD_TOOLS_DEFAULT OFF)\nelse()\n    set(_EXPAT_BUILD_TOOLS_DEFAULT ON)\nendif()\nif(MSVC OR NOT _EXPAT_BUILD_TOOLS_DEFAULT)\n    set(_EXPAT_BUILD_DOCS_DEFAULT OFF)\nelse()\n    find_program(DOCBOOK_TO_MAN NAMES docbook2x-man db2x_docbook2man docbook2man docbook-to-man)\n    if(DOCBOOK_TO_MAN)\n        set(_EXPAT_BUILD_DOCS_DEFAULT ON)\n    else()\n        set(_EXPAT_BUILD_DOCS_DEFAULT OFF)\n    endif()\nendif()\nif(MSVC)\n    set(_EXPAT_BUILD_PKGCONFIG_DEFAULT OFF)\nelse()\n    set(_EXPAT_BUILD_PKGCONFIG_DEFAULT ON)\nendif()\nif(DEFINED BUILD_SHARED_LIBS)\n    set(_EXPAT_SHARED_LIBS_DEFAULT ${BUILD_SHARED_LIBS})\nelse()\n    set(_EXPAT_SHARED_LIBS_DEFAULT ON)\nendif()\nif(NOT CMAKE_BUILD_TYPE)\n    set(CMAKE_BUILD_TYPE NoConfig)  # so that accessing EXPAT_*_POSTFIX will be waterproof\nendif()\nstring(TOUPPER \"${CMAKE_BUILD_TYPE}\" _EXPAT_BUILD_TYPE_UPPER)\n\n#\n# Configuration\n#\n\nmacro(expat_shy_set var default cache type desc)\n    # Macro expat_shy_set came into life because:\n    # - Expat was previously using an inconsistent mix of CMake's native set()\n    #   and option() to define public build time options.\n    # - option() is more friendly than set() with regard to configuring an\n    #   external project that is pulled in by means of add_subdirectory() --\n    #   see comments in issue #597 -- so we wanted to get away from set().\n    # - option() auto-converts non-bool values to bool when writing to the CMake\n    #   cache, so we needed something that supports non-bool better and hence\n    #   wanted to get away from plain option(), too.\n    #\n    # As a result, this function serves as a hybrid between CMake's regular set()\n    # and option(): from set() it takes support for non-bool types and the function\n    # name and signature whereas from option() (with policy CMP0077 mode NEW) it\n    # takes being shy when a value has previously been defined for that variable.\n    #\n    # So that resolves all need for set(.. FORCE) when pulling in Expat by means of\n    # add_subdirectory().\n    #\n    if(NOT ${cache} STREQUAL \"CACHE\")\n        message(SEND_ERROR \"Macro usage is: expat_shy_set(var default CACHE type desc)\")\n    endif()\n\n    if(DEFINED ${var})\n        # NOTE: The idea is to (ideally) only add to the cache if\n        #       there is no cache entry, yet.  \"if(DEFINED CACHE{var})\"\n        #       requires CMake >=3.14.\n        if(CMAKE_VERSION VERSION_GREATER_EQUAL \"3.14\" AND NOT DEFINED \"CACHE{${var}}\")\n            set(\"${var}\" \"${${var}}\" CACHE \"${type}\" \"${desc}\")\n        endif()\n    else()\n        set(\"${var}\" \"${default}\" CACHE \"${type}\" \"${desc}\")\n    endif()\nendmacro()\n\nexpat_shy_set(EXPAT_BUILD_TOOLS ${_EXPAT_BUILD_TOOLS_DEFAULT} CACHE BOOL \"Build the xmlwf tool for expat library\")\nexpat_shy_set(EXPAT_BUILD_EXAMPLES ON CACHE BOOL \"Build the examples for expat library\")\nexpat_shy_set(EXPAT_BUILD_TESTS ON CACHE BOOL \"Build the tests for expat library\")\nexpat_shy_set(EXPAT_SHARED_LIBS ${_EXPAT_SHARED_LIBS_DEFAULT} CACHE BOOL \"Build a shared expat library\")\nexpat_shy_set(EXPAT_BUILD_DOCS ${_EXPAT_BUILD_DOCS_DEFAULT} CACHE BOOL \"Build man page for xmlwf\")\nexpat_shy_set(EXPAT_BUILD_FUZZERS OFF CACHE BOOL \"Build fuzzers for the expat library\")\nexpat_shy_set(EXPAT_BUILD_PKGCONFIG ${_EXPAT_BUILD_PKGCONFIG_DEFAULT} CACHE BOOL \"Build pkg-config file\")\nexpat_shy_set(EXPAT_OSSFUZZ_BUILD OFF CACHE BOOL \"Build fuzzers via ossfuzz for the expat library\")\nif(UNIX OR _EXPAT_HELP)\n    expat_shy_set(EXPAT_WITH_LIBBSD OFF CACHE BOOL \"Utilize libbsd (for arc4random_buf)\")\nendif()\nexpat_shy_set(EXPAT_ENABLE_INSTALL ON CACHE BOOL \"Install expat files in cmake install target\")\nexpat_shy_set(EXPAT_CONTEXT_BYTES 1024 CACHE STRING \"Define to specify how much context to retain around the current parse point, 0 to disable\")\nmark_as_advanced(EXPAT_CONTEXT_BYTES)\nexpat_shy_set(EXPAT_DTD ON CACHE BOOL \"Define to make parameter entity parsing functionality available\")\nmark_as_advanced(EXPAT_DTD)\nexpat_shy_set(EXPAT_GE ON CACHE BOOL \"Define to make general entity parsing functionality available\")\nmark_as_advanced(EXPAT_GE)\nexpat_shy_set(EXPAT_NS ON CACHE BOOL \"Define to make XML Namespaces functionality available\")\nmark_as_advanced(EXPAT_NS)\nexpat_shy_set(EXPAT_WARNINGS_AS_ERRORS OFF CACHE BOOL \"Treat all compiler warnings as errors\")\nif(UNIX OR _EXPAT_HELP)\n    expat_shy_set(EXPAT_DEV_URANDOM ON CACHE BOOL \"Define to include code reading entropy from `/dev/urandom'.\")\n    expat_shy_set(EXPAT_WITH_GETRANDOM \"AUTO\" CACHE STRING \"Make use of getrandom function (ON|OFF|AUTO) [default=AUTO]\")\n    expat_shy_set(EXPAT_WITH_SYS_GETRANDOM \"AUTO\" CACHE STRING \"Make use of syscall SYS_getrandom (ON|OFF|AUTO) [default=AUTO]\")\n    mark_as_advanced(EXPAT_DEV_URANDOM)\nendif()\nexpat_shy_set(EXPAT_CHAR_TYPE \"char\" CACHE STRING \"Character type to use (char|ushort|wchar_t) [default=char]\")\nexpat_shy_set(EXPAT_ATTR_INFO OFF CACHE BOOL \"Define to allow retrieving the byte offsets for attribute names and values\")\nmark_as_advanced(EXPAT_ATTR_INFO)\nexpat_shy_set(EXPAT_LARGE_SIZE OFF CACHE BOOL \"Make XML_GetCurrent* functions return <(unsigned) long long> rather than <(unsigned) long>\")\nmark_as_advanced(EXPAT_LARGE_SIZE)\nexpat_shy_set(EXPAT_MIN_SIZE OFF CACHE BOOL \"Get a smaller (but slower) parser (in particular avoid multiple copies of the tokenizer)\")\nmark_as_advanced(EXPAT_MIN_SIZE)\nif(MSVC OR _EXPAT_HELP)\n    expat_shy_set(EXPAT_MSVC_STATIC_CRT OFF CACHE BOOL \"Use /MT flag (static CRT) when compiling in MSVC\")\nendif()\nif(NOT _EXPAT_HELP)\n    expat_shy_set(_EXPAT_M32 OFF CACHE BOOL \"(Unofficial!) Produce 32bit code with -m32\")\n    mark_as_advanced(_EXPAT_M32)\nendif()\n\nif(EXPAT_BUILD_TESTS)\n    # We have to call enable_language() before modifying any CMAKE_CXX_* variables\n    enable_language(CXX)\n\n    set(CMAKE_CXX_STANDARD 11)\n    set(CMAKE_CXX_STANDARD_REQUIRED ON)\n    set(CMAKE_CXX_EXTENSIONS OFF)  # i.e. -std=c++11 rather than default -std=gnu++11\nendif()\n\n#\n# Environment checks\n#\nif(EXPAT_DTD AND NOT EXPAT_GE)\n    message(SEND_ERROR \"Option EXPAT_DTD requires that EXPAT_GE is also enabled.\")\n    message(SEND_ERROR \"Please either enable option EXPAT_GE (recommended) or disable EXPAT_DTD also.\")\nendif()\n\nif(EXPAT_WITH_LIBBSD)\n    find_library(LIB_BSD NAMES bsd)\n    if(NOT LIB_BSD)\n        message(SEND_ERROR \"EXPAT_WITH_LIBBSD option is enabled, but libbsd was not found\")\n    else()\n        set(HAVE_LIBBSD TRUE)\n    endif()\nendif()\n\nif(MSVC)\n    # For the three types of MSVC version values, please see:\n    # - https://cmake.org/cmake/help/latest/variable/MSVC_VERSION.html\n    # - https://sourceforge.net/p/predef/wiki/Compilers/\n    # - https://en.wikipedia.org/wiki/Microsoft_Visual_Studio#History\n    set(_EXPAT_MSVC_REQUIRED_INT 1800)  # i.e. 12.0/2013/1800; see PR #426\n    set(_EXPAT_MSVC_SUPPORTED_INT 1910)\n    set(_EXPAT_MSVC_SUPPORTED_DISPLAY \"Visual Studio 15.0/2017/${_EXPAT_MSVC_SUPPORTED_INT}\")\n\n    if(MSVC_VERSION VERSION_LESS ${_EXPAT_MSVC_SUPPORTED_INT})\n        if(MSVC_VERSION VERSION_LESS ${_EXPAT_MSVC_REQUIRED_INT})\n            message(SEND_ERROR \"MSVC_VERSION ${MSVC_VERSION} is TOO OLD to compile Expat without errors.\")\n            message(SEND_ERROR \"Please use officially supported ${_EXPAT_MSVC_SUPPORTED_DISPLAY} or later.  Thank you!\")\n        else()\n            message(WARNING \"MSVC_VERSION ${MSVC_VERSION} is NOT OFFICIALLY SUPPORTED by Expat.\")\n            message(WARNING \"Please use ${_EXPAT_MSVC_SUPPORTED_DISPLAY} or later.  Thank you!\")\n        endif()\n    endif()\nendif()\n\nmacro(_expat_copy_bool_int source_ref dest_ref)\n    if(${source_ref})\n        set(${dest_ref} 1)\n    else()\n        set(${dest_ref} 0)\n    endif()\nendmacro()\n\nif(EXPAT_LARGE_SIZE)\n    add_definitions(-DXML_LARGE_SIZE)\nendif()\n\nif(EXPAT_MIN_SIZE)\n    add_definitions(-DXML_MIN_SIZE)\nendif()\n\nif(EXPAT_CHAR_TYPE STREQUAL \"char\")\n    set(_EXPAT_UNICODE OFF)\n    set(_EXPAT_UNICODE_WCHAR_T OFF)\nelseif(EXPAT_CHAR_TYPE STREQUAL \"ushort\")\n    set(_EXPAT_UNICODE ON)\n    set(_EXPAT_UNICODE_WCHAR_T OFF)\n    if(EXPAT_BUILD_EXAMPLES)\n        message(SEND_ERROR \"Examples can not be built with option -DEXPAT_CHAR_TYPE=ushort. Please pass -DEXPAT_CHAR_TYPE=(char|wchar_t) or -DEXPAT_BUILD_EXAMPLES=OFF.\")\n    endif()\n    if(EXPAT_BUILD_TESTS)\n        message(SEND_ERROR \"The testsuite can not be built with option -DEXPAT_CHAR_TYPE=ushort. Please pass -DEXPAT_CHAR_TYPE=(char|wchar_t) or -DEXPAT_BUILD_TESTS=OFF.\")\n    endif()\n    if(EXPAT_BUILD_TOOLS)\n        message(SEND_ERROR \"The xmlwf tool can not be built with option -DEXPAT_CHAR_TYPE=ushort. Please pass -DEXPAT_CHAR_TYPE=(char|wchar_t) or -DEXPAT_BUILD_TOOLS=OFF.\")\n    endif()\nelseif(EXPAT_CHAR_TYPE STREQUAL \"wchar_t\")\n    set(_EXPAT_UNICODE ON)\n    set(_EXPAT_UNICODE_WCHAR_T ON)\n    if(NOT WIN32)\n        string(FIND \"${CMAKE_C_FLAGS}\" \"-fshort-wchar\" _expat_short_wchar_found)\n        if(${_expat_short_wchar_found} EQUAL \"-1\")\n            message(SEND_ERROR \"Configuration -DEXPAT_CHAR_TYPE=wchar_t requires -DCMAKE_{C,CXX}_FLAGS=-fshort-wchar (which was not found) and libc compiled with -fshort-wchar, too.\")\n        endif()\n        if (EXPAT_BUILD_TOOLS)\n            message(SEND_ERROR \"The xmlwf tool can not be built with option -DEXPAT_CHAR_TYPE=wchar_t outside of Windows. Please pass -DEXPAT_CHAR_TYPE=char or -DEXPAT_BUILD_TOOLS=OFF.\")\n        endif()\n    endif()\nelse()\n    message(SEND_ERROR \"Option -DEXPAT_CHAR_TYPE=(char|ushort|wchar_t) cannot be \\\"${EXPAT_CHAR_TYPE}\\\".\")\nendif()\n\nif(_EXPAT_UNICODE)\n    add_definitions(-DXML_UNICODE)              # for unsigned short\n    if(_EXPAT_UNICODE_WCHAR_T)\n        add_definitions(-DXML_UNICODE_WCHAR_T)  # for wchar_t\n    endif()\nendif()\n\ninclude(${CMAKE_CURRENT_LIST_DIR}/ConfigureChecks.cmake)\n\nmacro(evaluate_detection_results use_ref have_ref thing_lower thing_title)\n    if(${use_ref} AND NOT (${use_ref} STREQUAL \"AUTO\") AND NOT ${have_ref})\n        message(SEND_ERROR\n                \"Use of ${thing_lower} was enforced by ${use_ref}=ON but it could not be found.\")\n    elseif(NOT ${use_ref} AND ${have_ref})\n        message(\"${thing_title} was found but it will not be used due to ${use_ref}=OFF.\")\n        set(${have_ref} 0)\n    endif()\nendmacro()\n\nif(NOT WIN32)\n    evaluate_detection_results(EXPAT_WITH_GETRANDOM HAVE_GETRANDOM \"function getrandom\" \"Function getrandom\")\n    evaluate_detection_results(EXPAT_WITH_SYS_GETRANDOM HAVE_SYSCALL_GETRANDOM \"syscall SYS_getrandom\" \"Syscall SYS_getrandom\")\nendif()\n\n_expat_copy_bool_int(EXPAT_ATTR_INFO        XML_ATTR_INFO)\n_expat_copy_bool_int(EXPAT_DTD              XML_DTD)\n_expat_copy_bool_int(EXPAT_GE               XML_GE)\n_expat_copy_bool_int(EXPAT_LARGE_SIZE       XML_LARGE_SIZE)\n_expat_copy_bool_int(EXPAT_MIN_SIZE         XML_MIN_SIZE)\n_expat_copy_bool_int(EXPAT_NS               XML_NS)\nif(NOT WIN32)\n    _expat_copy_bool_int(EXPAT_DEV_URANDOM  XML_DEV_URANDOM)\nendif()\nif(NOT EXPAT_CONTEXT_BYTES GREATER 0)  # in particular with -DEXPAT_CONTEXT_BYTES=OFF\n    set(EXPAT_CONTEXT_BYTES 0)\nendif()\nset(XML_CONTEXT_BYTES ${EXPAT_CONTEXT_BYTES})\n\nmacro(expat_install)\n    if(EXPAT_ENABLE_INSTALL)\n        install(${ARGN})\n    endif()\nendmacro()\n\nconfigure_file(expat_config.h.cmake \"${CMAKE_CURRENT_BINARY_DIR}/expat_config.h\")\nexpat_install(FILES \"${CMAKE_CURRENT_BINARY_DIR}/expat_config.h\" DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})\n\n\nset(EXTRA_COMPILE_FLAGS)\nif(FLAG_NO_STRICT_ALIASING)\n    set(EXTRA_COMPILE_FLAGS \"${EXTRA_COMPILE_FLAGS} -fno-strict-aliasing\")\nendif()\nif(FLAG_VISIBILITY)\n  if(EXPAT_SHARED_LIBS)\n     add_definitions(-DXML_ENABLE_VISIBILITY=1)\n  endif()\n  set(EXTRA_COMPILE_FLAGS \"${EXTRA_COMPILE_FLAGS} -fvisibility=hidden\")\nendif()\nif(MINGW)\n    # Without __USE_MINGW_ANSI_STDIO the compiler produces a false positive\n    set(EXTRA_COMPILE_FLAGS \"${EXTRA_COMPILE_FLAGS} -Wno-pedantic-ms-format\")\nendif()\nif (EXPAT_WARNINGS_AS_ERRORS)\n    if(MSVC)\n        add_definitions(/WX)\n    else()\n        set(EXTRA_COMPILE_FLAGS \"${EXTRA_COMPILE_FLAGS} -Werror\")\n        if(MINGW)\n            # To avoid \"error: unknown conversion type character \u2018l\u2019 in format [-Werror=format=]\"\n            set(EXTRA_COMPILE_FLAGS \"${EXTRA_COMPILE_FLAGS} -Wno-format\")\n        endif()\n    endif()\nendif()\nset(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} ${EXTRA_COMPILE_FLAGS}\")\nset(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} ${EXTRA_COMPILE_FLAGS}\")\n\nif (MSVC)\n    if (EXPAT_MSVC_STATIC_CRT)\n        message(\"-- Using static CRT ${EXPAT_MSVC_STATIC_CRT}\")\n        foreach(flag_var\n                CMAKE_CXX_FLAGS_${_EXPAT_BUILD_TYPE_UPPER}\n                CMAKE_CXX_FLAGS_DEBUG\n                CMAKE_CXX_FLAGS_RELEASE\n                CMAKE_CXX_FLAGS_MINSIZEREL\n                CMAKE_CXX_FLAGS_RELWITHDEBINFO\n                CMAKE_C_FLAGS_${_EXPAT_BUILD_TYPE_UPPER}\n                CMAKE_C_FLAGS_DEBUG\n                CMAKE_C_FLAGS_RELEASE\n                CMAKE_C_FLAGS_MINSIZEREL\n                CMAKE_C_FLAGS_RELWITHDEBINFO\n                )\n            string(REPLACE \"/MD\" \"/MT\" ${flag_var} \"${${flag_var}}\")\n        endforeach()\n    endif()\nendif()\n\nif(_EXPAT_M32 AND NOT MSVC)\n    foreach(flag_var\n            CMAKE_CXX_FLAGS_${_EXPAT_BUILD_TYPE_UPPER}\n            CMAKE_CXX_FLAGS_DEBUG\n            CMAKE_CXX_FLAGS_RELEASE\n            CMAKE_CXX_FLAGS_MINSIZEREL\n            CMAKE_CXX_FLAGS_RELWITHDEBINFO\n            CMAKE_C_FLAGS_${_EXPAT_BUILD_TYPE_UPPER}\n            CMAKE_C_FLAGS_DEBUG\n            CMAKE_C_FLAGS_RELEASE\n            CMAKE_C_FLAGS_MINSIZEREL\n            CMAKE_C_FLAGS_RELWITHDEBINFO\n            )\n        set(${flag_var} \"${${flag_var}} -m32\")\n    endforeach()\nendif()\n\ninclude_directories(${CMAKE_CURRENT_BINARY_DIR} ${CMAKE_CURRENT_SOURCE_DIR}/lib)\nif(MSVC)\n    add_definitions(-D_CRT_SECURE_NO_WARNINGS -wd4996)\nendif()\n\n#\n# C library\n#\nset(_EXPAT_C_SOURCES\n    lib/xmlparse.c\n    lib/xmlrole.c\n    lib/xmltok.c\n# NOTE: ISO C forbids an empty translation unit\n#   lib/xmltok_impl.c\n#   lib/xmltok_ns.c\n)\n\nif(EXPAT_SHARED_LIBS)\n    set(_SHARED SHARED)\n    if(WIN32)\n        macro(_expat_def_file_toggle source_var target_var)\n            if(${source_var})\n                set(${target_var} \" \")  # i.e. not commented out, a single space\n            else()\n                set(${target_var} \";\")  # i.e. commented out\n            endif()\n        endmacro()\n\n        if(EXPAT_DTD OR EXPAT_GE)\n            set(_EXPAT_DTD_OR_GE TRUE)\n        else()\n            set(_EXPAT_DTD_OR_GE FALSE)\n        endif()\n\n        _expat_def_file_toggle(_EXPAT_DTD_OR_GE _EXPAT_COMMENT_DTD_OR_GE)\n        _expat_def_file_toggle(EXPAT_ATTR_INFO _EXPAT_COMMENT_ATTR_INFO)\n\n        configure_file(\"${CMAKE_CURRENT_SOURCE_DIR}/lib/libexpat.def.cmake\" \"${CMAKE_CURRENT_BINARY_DIR}/lib/libexpat.def\")\n        set(_EXPAT_EXTRA_SOURCES ${_EXPAT_EXTRA_SOURCES} \"${CMAKE_CURRENT_BINARY_DIR}/lib/libexpat.def\")\n\n        # Add DLL version\n        string(REPLACE \".\" \",\" _EXPAT_DLL_VERSION ${PROJECT_VERSION}.0)\n        configure_file(\"${CMAKE_CURRENT_SOURCE_DIR}/win32/version.rc.cmake\" \"${CMAKE_CURRENT_BINARY_DIR}/win32/version.rc\")\n        set(_EXPAT_EXTRA_SOURCES ${_EXPAT_EXTRA_SOURCES} \"${CMAKE_CURRENT_BINARY_DIR}/win32/version.rc\")\n    endif()\nelse()\n    set(_SHARED STATIC)\nendif()\n\nadd_library(expat ${_SHARED} ${_EXPAT_C_SOURCES} ${_EXPAT_EXTRA_SOURCES})\nif(_EXPAT_LIBM_FOUND)\n    target_link_libraries(expat m)\nendif()\nif(EXPAT_WITH_LIBBSD)\n    target_link_libraries(expat ${LIB_BSD})\nendif()\n\n#\n# Library filename postfix\n#\nif(_EXPAT_UNICODE)\n    set(_POSTFIX_WIDE \"w\")\nendif()\n\nif(MSVC AND NOT EXPAT_SHARED_LIBS)\n    if(EXPAT_MSVC_STATIC_CRT)\n        set(_POSTFIX_CRT \"MT\")\n    else()\n        set(_POSTFIX_CRT \"MD\")\n    endif()\nendif()\n\nforeach(build_type_upper\n        ${_EXPAT_BUILD_TYPE_UPPER}\n        DEBUG\n        RELEASE\n        MINSIZEREL\n        RELWITHDEBINFO\n        )\n    if(WIN32 AND build_type_upper STREQUAL \"DEBUG\")\n        set(_POSTFIX_DEBUG \"d\")\n    else()\n        set(_POSTFIX_DEBUG \"\")  # needs a reset because of being looped\n    endif()\n\n    expat_shy_set(EXPAT_${build_type_upper}_POSTFIX \"${_POSTFIX_WIDE}${_POSTFIX_DEBUG}${_POSTFIX_CRT}\" CACHE STRING \"Library filename postfix for build type ${build_type_upper}; yields filenames libexpat<postfix=[w][d][MD|MT]>.(dll|dylib|lib|so)\")\n    mark_as_advanced(EXPAT_${build_type_upper}_POSTFIX)\n    set_property(TARGET expat PROPERTY ${build_type_upper}_POSTFIX ${EXPAT_${build_type_upper}_POSTFIX})\nendforeach()\n\nset(LIBCURRENT 9)    # sync\nset(LIBREVISION 10)  # with\nset(LIBAGE 8)        # configure.ac!\nmath(EXPR LIBCURRENT_MINUS_AGE \"${LIBCURRENT} - ${LIBAGE}\")\n\nif(NOT WIN32)\n    set_property(TARGET expat PROPERTY VERSION ${LIBCURRENT_MINUS_AGE}.${LIBAGE}.${LIBREVISION})\n    set_property(TARGET expat PROPERTY SOVERSION ${LIBCURRENT_MINUS_AGE})\n    set_property(TARGET expat PROPERTY NO_SONAME ${NO_SONAME})\n\n    if(APPLE)\n        if(NOT CMAKE_VERSION VERSION_GREATER_EQUAL 3.17)\n            message(FATAL_ERROR \"Expat requires CMake >=3.17 on platform \\\"APPLE\\\".\")\n        endif()\n\n        # NOTE: This intends to talk CMake into compatibility with GNU Libtool\n        math(EXPR _EXPAT_MACHO_COMPATIBILITY_VERSION \"${LIBCURRENT} + 1\")\n        set(_EXPAT_MACHO_CURRENT_VERSION \"${_EXPAT_MACHO_COMPATIBILITY_VERSION}.${LIBREVISION}\")\n        set_property(TARGET expat PROPERTY MACHO_COMPATIBILITY_VERSION ${_EXPAT_MACHO_COMPATIBILITY_VERSION})\n        set_property(TARGET expat PROPERTY MACHO_CURRENT_VERSION ${_EXPAT_MACHO_CURRENT_VERSION})\n    endif()\nendif()\n\nif(MINGW AND EXPAT_SHARED_LIBS)\n    set_target_properties(expat PROPERTIES SUFFIX \"-${LIBCURRENT_MINUS_AGE}.dll\")\nendif()\n\nif(WIN32 AND NOT MINGW)\n    # NOTE: This avoids a name collision with Expat.dll of Perl's XML::Parser::Expat\n    #       on Windows by resorting to filename libexpat.dll since Expat 1.95.3.\n    #       Everything but MSVC is already adding prefix \"lib\", automatically.\n    # NOTE: \"set_property(TARGET expat PROPERTY PREFIX lib)\" would only affect *.dll\n    #       files but not *.lib files, so we have to rely on property OUTPUT_NAME, instead.\n    #       Target property <CONFIG>_POSTFIX still applies.\n    set(_EXPAT_OUTPUT_NAME libexpat)\n    set_property(TARGET expat PROPERTY OUTPUT_NAME ${_EXPAT_OUTPUT_NAME})\nelse()\n    set(_EXPAT_OUTPUT_NAME expat)\nendif()\n\ntarget_include_directories(expat\n    INTERFACE\n        $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/lib>\n        $<BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}>\n        $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>\n)\n\nif(WIN32 AND EXPAT_SHARED_LIBS)\n    target_compile_definitions(expat PRIVATE VER_FILEVERSION=${_EXPAT_DLL_VERSION})\nendif()\n\nexpat_install(TARGETS expat EXPORT expat\n                      RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}\n                      LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}\n                      ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR})\n\nexpat_install(FILES lib/expat.h lib/expat_external.h DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})\n\n#\n# pkg-config file\n#\nif(EXPAT_BUILD_PKGCONFIG)\n    if(CMAKE_INSTALL_LIBDIR MATCHES \"^/\")\n        set(_expat_pkgconfig_libdir \"${CMAKE_INSTALL_LIBDIR}\")\n    else()\n        set(_expat_pkgconfig_libdir \"\\${exec_prefix}/${CMAKE_INSTALL_LIBDIR}\")\n    endif()\n\n    if(CMAKE_INSTALL_INCLUDEDIR MATCHES \"^/\")\n        set(_expat_pkgconfig_includedir \"${CMAKE_INSTALL_INCLUDEDIR}\")\n    else()\n        set(_expat_pkgconfig_includedir \"\\${prefix}/${CMAKE_INSTALL_INCLUDEDIR}\")\n    endif()\n\n    set_target_properties(expat PROPERTIES\n        pkgconfig_prefix \"${CMAKE_INSTALL_PREFIX}\"\n        pkgconfig_exec_prefix \"\\${prefix}\"\n        pkgconfig_libdir \"${_expat_pkgconfig_libdir}\"\n        pkgconfig_includedir \"${_expat_pkgconfig_includedir}\"\n        pkgconfig_version \"${PACKAGE_VERSION}\")\n\n    foreach(_build_type ${CMAKE_BUILD_TYPE} Debug Release RelWithDebInfo MinSizeRel)\n        string(TOLOWER \"${_build_type}\" _build_type_lower)\n        string(TOUPPER \"${_build_type}\" _build_type_upper)\n        set_property(TARGET expat PROPERTY \"pkgconfig_${_build_type_lower}_name\" \"expat${EXPAT_${_build_type_upper}_POSTFIX}\")\n        set_property(TARGET expat PROPERTY \"pkgconfig_${_build_type_lower}_output_name\" \"${_EXPAT_OUTPUT_NAME}${EXPAT_${_build_type_upper}_POSTFIX}\")\n        if(_EXPAT_LIBM_FOUND)\n            set_property(TARGET expat PROPERTY \"pkgconfig_libm\" \"-lm\")\n        else()\n            set_property(TARGET expat PROPERTY \"pkgconfig_libm\" \"\")\n        endif()\n    endforeach()\n\n    file(GENERATE\n        OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/$<CONFIG>/expat.pc\n        INPUT ${PROJECT_SOURCE_DIR}/expat.pc.cmake)\n\n    expat_install(FILES ${CMAKE_CURRENT_BINARY_DIR}/$<CONFIG>/expat.pc DESTINATION ${CMAKE_INSTALL_LIBDIR}/pkgconfig)\nendif()\n\n#\n# C command line tool xmlwf\n#\nif(EXPAT_BUILD_TOOLS)\n    set(xmlwf_SRCS\n        xmlwf/codepage.c\n        xmlwf/readfilemap.c\n        xmlwf/xmlfile.c\n        xmlwf/xmlwf.c\n    )\n\n    add_executable(xmlwf ${xmlwf_SRCS})\n    set_property(TARGET xmlwf PROPERTY RUNTIME_OUTPUT_DIRECTORY xmlwf)\n    target_link_libraries(xmlwf expat)\n    if(_EXPAT_LIBM_FOUND)\n        target_link_libraries(xmlwf m)\n    endif()\n    expat_install(TARGETS xmlwf DESTINATION ${CMAKE_INSTALL_BINDIR})\n\n    if(MINGW AND _EXPAT_UNICODE_WCHAR_T)\n        # https://gcc.gnu.org/onlinedocs/gcc/x86-Windows-Options.html\n        set_target_properties(xmlwf PROPERTIES LINK_FLAGS -municode)\n    endif()\n\n    if(EXPAT_BUILD_DOCS)\n        file(MAKE_DIRECTORY ${PROJECT_BINARY_DIR}/doc)\n        add_custom_target(\n            xmlwf-manpage\n            COMMAND\n                \"${DOCBOOK_TO_MAN}\" \"${PROJECT_SOURCE_DIR}/doc/xmlwf.xml\" && mv \"XMLWF.1\" \"${PROJECT_BINARY_DIR}/doc/xmlwf.1\"\n            BYPRODUCTS\n                doc/xmlwf.1)\n        add_dependencies(expat xmlwf-manpage)\n        expat_install(FILES \"${PROJECT_BINARY_DIR}/doc/xmlwf.1\" DESTINATION ${CMAKE_INSTALL_MANDIR}/man1)\n    elseif(EXISTS ${PROJECT_SOURCE_DIR}/doc/xmlwf.1)\n        expat_install(FILES \"${PROJECT_SOURCE_DIR}/doc/xmlwf.1\" DESTINATION ${CMAKE_INSTALL_MANDIR}/man1)\n    endif()\nendif()\n\n#\n# C code examples\n#\nif(EXPAT_BUILD_EXAMPLES)\n    foreach(_target element_declarations elements outline)\n        add_executable(${_target} examples/${_target}.c)\n        set_property(TARGET ${_target} PROPERTY RUNTIME_OUTPUT_DIRECTORY examples)\n        target_link_libraries(${_target} expat)\n    endforeach()\nendif()\n\n#\n# C/C++ test runners\n#\nif(EXPAT_BUILD_TESTS)\n    ## these are unittests that can be run on any platform\n    enable_testing()\n\n    if(NOT MSVC)\n        if(MINGW)\n            set(host whatever-mingw32)  # for nothing but run.sh\n        endif()\n        configure_file(${CMAKE_CURRENT_SOURCE_DIR}/run.sh.in run.sh @ONLY)\n    endif()\n\n    function(expat_add_test _name _file)\n        if(MSVC)\n            add_test(NAME ${_name} COMMAND ${_file})\n        else()\n            add_test(NAME ${_name} COMMAND bash run.sh ${_file})\n        endif()\n    endfunction()\n\n    set(_EXPAT_TEST_TARGETS runtests runtests_cxx)\n\n    add_executable(runtests\n        tests/acc_tests.c\n        tests/alloc_tests.c\n        tests/basic_tests.c\n        tests/chardata.c\n        tests/common.c\n        tests/dummy.c\n        tests/handlers.c\n        tests/memcheck.c\n        tests/minicheck.c\n        tests/misc_tests.c\n        tests/ns_tests.c\n        tests/nsalloc_tests.c\n        tests/runtests.c\n        tests/structdata.c\n        ${_EXPAT_C_SOURCES}\n    )\n\n    add_executable(runtests_cxx\n        tests/acc_tests_cxx.cpp\n        tests/alloc_tests_cxx.cpp\n        tests/basic_tests_cxx.cpp\n        tests/chardata_cxx.cpp\n        tests/common_cxx.cpp\n        tests/dummy_cxx.cpp\n        tests/handlers_cxx.cpp\n        tests/memcheck_cxx.cpp\n        tests/minicheck_cxx.cpp\n        tests/misc_tests_cxx.cpp\n        tests/ns_tests_cxx.cpp\n        tests/nsalloc_tests_cxx.cpp\n        tests/runtests_cxx.cpp\n        tests/structdata_cxx.cpp\n        ${_EXPAT_C_SOURCES}\n    )\n\n    foreach(_target ${_EXPAT_TEST_TARGETS})\n        set_property(TARGET ${_target} PROPERTY RUNTIME_OUTPUT_DIRECTORY tests)\n        expat_add_test(${_target} $<TARGET_FILE:${_target}>)\n\n        if(_EXPAT_LIBM_FOUND)\n            target_link_libraries(${_target} m)\n        endif()\n\n        if(EXPAT_WITH_LIBBSD)\n            target_link_libraries(${_target} ${LIB_BSD})\n        endif()\n    endforeach()\nendif()\n\n#\n# Fuzzers\n#\nif(EXPAT_BUILD_FUZZERS)\n    if(NOT \"${CMAKE_C_COMPILER_ID}\" STREQUAL \"Clang\")\n        message(SEND_ERROR\n            \"Building fuzz targets without Clang (but ${CMAKE_C_COMPILER_ID}) \"\n            \"is not supported. Please set \"\n            \"-DCMAKE_C_COMPILER=clang -DCMAKE_CXX_COMPILER=clang++.\")\n    endif()\n\n    string(FIND \"${CMAKE_C_FLAGS}\" \"-fsanitize\" sanitizer_present)\n    if(${sanitizer_present} EQUAL \"-1\")\n        message(WARNING\n            \"There was no sanitizer present when building the fuzz targets. \"\n            \"This is likely in error - consider adding \"\n            \"-DCMAKE_C_FLAGS='-fsanitize=<sanitizer>' and \"\n            \"-DCMAKE_CXX_FLAGS='-fsanitize=<sanitizer>' and \"\n            \"-DCMAKE_EXE_LINKER_FLAGS='-fsanitize=<sanitizer>' and \"\n            \"-DCMAKE_MODULE_LINKER_FLAGS='-fsanitize=<sanitizer>' and \"\n            \"-DCMAKE_SHARED_LINKER_FLAGS='-fsanitize=<sanitizer>' to your cmake \"\n            \"execution.\")\n    endif()\n\n    if(EXPAT_OSSFUZZ_BUILD AND NOT DEFINED ENV{LIB_FUZZING_ENGINE})\n        message(SEND_ERROR\n            \"OSS-Fuzz builds require the environment variable \"\n            \"LIB_FUZZING_ENGINE to be set. If you are seeing this \"\n            \"warning, it points to a deeper problem in the ossfuzz \"\n            \"build setup.\")\n    endif()\n\n    set(encoding_types UTF-16 UTF-8 ISO-8859-1 US-ASCII UTF-16BE UTF-16LE)\n    set(fuzz_targets xml_parse_fuzzer xml_parsebuffer_fuzzer)\n\n    add_library(fuzzpat STATIC ${_EXPAT_C_SOURCES})\n    if(NOT EXPAT_OSSFUZZ_BUILD)\n        target_compile_options(fuzzpat PRIVATE -fsanitize=fuzzer-no-link)\n    endif()\n\n    foreach(fuzz_target ${fuzz_targets})\n        foreach(encoding_type ${encoding_types})\n            set(target_name ${fuzz_target}_${encoding_type})\n            add_executable(${target_name} fuzz/${fuzz_target}.c)\n            target_link_libraries(${target_name} fuzzpat)\n            target_compile_definitions(${target_name}\n                PRIVATE ENCODING_FOR_FUZZING=${encoding_type})\n            if(NOT EXPAT_OSSFUZZ_BUILD)\n                target_compile_options(${target_name} PRIVATE -fsanitize=fuzzer-no-link)\n            endif()\n            # NOTE: Avoiding target_link_options here only because it needs CMake >=3.13\n            if(EXPAT_OSSFUZZ_BUILD)\n                set_target_properties(${target_name} PROPERTIES LINK_FLAGS $ENV{LIB_FUZZING_ENGINE})\n                set_target_properties(${target_name} PROPERTIES LINKER_LANGUAGE \"CXX\")\n            else()\n                set_target_properties(${target_name} PROPERTIES LINK_FLAGS -fsanitize=fuzzer)\n            endif()\n            set_property(\n                TARGET ${target_name} PROPERTY RUNTIME_OUTPUT_DIRECTORY fuzz)\n        endforeach()\n    endforeach()\nelse()\n    if(EXPAT_OSSFUZZ_BUILD)\n        message(SEND_ERROR\n                \"Attempting to perform an ossfuzz build without turning on the fuzzer build. \"\n                \"This is likely in error - consider adding \"\n                \"-DEXPAT_BUILD_FUZZERS=ON to your cmake execution.\")\n    endif()\nendif()\n\n#\n# C/C++ config affecting multiple targets\n#\nif(WIN32)\n    set(_EXPAT_STATIC_TARGETS ${_EXPAT_TEST_TARGETS})\n    if(NOT EXPAT_SHARED_LIBS)\n        list(APPEND _EXPAT_STATIC_TARGETS expat)\n    endif()\n    if(EXPAT_BUILD_FUZZERS)\n        list(APPEND _EXPAT_STATIC_TARGETS fuzzpat)\n    endif()\n\n    foreach(_target ${_EXPAT_STATIC_TARGETS})\n        target_compile_definitions(${_target} PUBLIC -DXML_STATIC)\n    endforeach()\nendif()\n\n#\n# Custom target \"run-xmltest\"\n#\nif(EXPAT_BUILD_TOOLS AND NOT MSVC)\n    add_custom_target(\n        xmlts-zip-downloaded\n        COMMAND\n            sh -c 'test -f xmlts.zip || wget --output-document=xmlts.zip https://www.w3.org/XML/Test/xmlts20080827.zip'\n        BYPRODUCTS\n            tests/xmlts.zip\n        WORKING_DIRECTORY\n            tests/)\n\n    add_custom_target(\n        xmlts-zip-extracted\n        COMMAND\n            sh -c 'test -d xmlconf || unzip -q xmlts.zip'\n        BYPRODUCTS\n            tests/xmlconf\n        WORKING_DIRECTORY\n            tests/)\n    add_dependencies(xmlts-zip-extracted xmlts-zip-downloaded)\n\n    add_custom_target(\n        xmltest-sh-been-run\n        COMMAND\n            sh -c '${CMAKE_CURRENT_SOURCE_DIR}/tests/xmltest.sh \"bash ${CMAKE_CURRENT_BINARY_DIR}/run.sh $<TARGET_FILE:xmlwf>\" 2>&1 | tee tests/xmltest.log'\n        BYPRODUCTS\n            tests/xmltest.log)\n    add_dependencies(xmltest-sh-been-run xmlts-zip-extracted xmlwf)\n\n    add_custom_target(\n        xmltest-log-fixed\n        COMMAND\n            ${CMAKE_CURRENT_SOURCE_DIR}/fix-xmltest-log.sh tests/xmltest.log\n        DEPENDS\n            tests/xmltest.log)\n    add_dependencies(xmltest-log-fixed xmltest-sh-been-run)\n\n    add_custom_target(\n        xmltest-log-verified\n        COMMAND\n            diff -u ${CMAKE_CURRENT_SOURCE_DIR}/tests/xmltest.log.expected tests/xmltest.log)\n    add_dependencies(xmltest-log-verified xmltest-log-fixed)\n\n    add_custom_target(run-xmltest)\n    add_dependencies(run-xmltest xmltest-log-verified)\nendif()\n\n#\n# Documentation\n#\nconfigure_file(Changes changelog COPYONLY)\nexpat_install(\n    FILES\n        AUTHORS\n        ${CMAKE_CURRENT_BINARY_DIR}/changelog\n    DESTINATION\n        ${CMAKE_INSTALL_DOCDIR})\n\n#\n# CMake files for find_package(expat [..] CONFIG [..])\n#\nconfigure_package_config_file(\n        cmake/expat-config.cmake.in\n        cmake/expat-config.cmake\n    INSTALL_DESTINATION\n        ${CMAKE_INSTALL_LIBDIR}/cmake/expat-${PROJECT_VERSION}/\n)\nwrite_basic_package_version_file(\n    cmake/expat-config-version.cmake\n    COMPATIBILITY SameMajorVersion  # i.e. semver\n)\nexport(\n    TARGETS\n        expat\n    FILE\n        cmake/expat-targets.cmake  # not going to be installed\n)\nexpat_install(\n    FILES\n        ${CMAKE_CURRENT_BINARY_DIR}/cmake/expat-config.cmake\n        ${CMAKE_CURRENT_BINARY_DIR}/cmake/expat-config-version.cmake\n    DESTINATION\n        ${CMAKE_INSTALL_LIBDIR}/cmake/expat-${PROJECT_VERSION}/\n)\nexpat_install(\n    EXPORT\n        expat\n    DESTINATION\n        ${CMAKE_INSTALL_LIBDIR}/cmake/expat-${PROJECT_VERSION}/\n    NAMESPACE\n        expat::\n)\n\n#\n# CPack\n#\n\n# This effectively disables target \"package_source\".\n# That is done due to CPack's unfortunate choice of an exclusion list\n# rather than inclusion list.  An exclusion list does not protect against\n# unwanted files ending up in the resulting archive in a way that's\n# safe to run from an Expat developer's machine.\nset(CPACK_SOURCE_GENERATOR '')\n\nif(WIN32)\n    set(CPACK_GENERATOR ZIP)\nelse()\n    set(CPACK_GENERATOR TGZ)\nendif()\n\ninclude(CPack)\n\n#\n# Summary\n#\nif(EXPAT_CHAR_TYPE STREQUAL \"char\")\n    set(_EXPAT_CHAR_TYPE_SUMMARY \"char (UTF-8)\")\nelseif(EXPAT_CHAR_TYPE STREQUAL \"ushort\")\n    set(_EXPAT_CHAR_TYPE_SUMMARY \"ushort (unsigned short, UTF-16)\")\nelseif(EXPAT_CHAR_TYPE STREQUAL \"wchar_t\")\n    if(WIN32)\n        set(_EXPAT_CHAR_TYPE_SUMMARY \"wchar_t (UTF-16)\")\n    else()\n        set(_EXPAT_CHAR_TYPE_SUMMARY \"wchar_t (UTF-32)  // not implemented\")\n    endif()\nelse()\n    set(_EXPAT_CHAR_TYPE_SUMMARY \"ERROR\")\nendif()\n# NOTE: We're not accessing global property GENERATOR_IS_MULTI_CONFIG\n#       because that would require CMake >=3.9\nif(CMAKE_CONFIGURATION_TYPES)\n    set(_EXPAT_GENERATOR_IS_MULTI_CONFIG TRUE)\nelse()\n    set(_EXPAT_GENERATOR_IS_MULTI_CONFIG FALSE)\nendif()\n\nmessage(STATUS \"===========================================================================\")\nmessage(STATUS \"\")\nmessage(STATUS \"Configuration\")\nmessage(STATUS \"  Generator .................. ${CMAKE_GENERATOR}\")\nif(_EXPAT_GENERATOR_IS_MULTI_CONFIG)\n    message(STATUS \"  Build types ................ ${CMAKE_CONFIGURATION_TYPES}\")\nelse()\n    message(STATUS \"  Build type ................. ${CMAKE_BUILD_TYPE}\")\nendif()\nmessage(STATUS \"  Prefix ..................... ${CMAKE_INSTALL_PREFIX}\")\nmessage(STATUS \"  Shared libraries ........... ${EXPAT_SHARED_LIBS}\")\nif(MSVC)\n    message(STATUS \"  Static CRT ................. ${EXPAT_MSVC_STATIC_CRT}\")\nendif()\nmessage(STATUS \"  Character type ............. ${_EXPAT_CHAR_TYPE_SUMMARY}\")\nif(NOT _EXPAT_GENERATOR_IS_MULTI_CONFIG)\n    message(STATUS \"  Library name postfix ....... ${EXPAT_${_EXPAT_BUILD_TYPE_UPPER}_POSTFIX}\")\nendif()\nmessage(STATUS \"\")\nmessage(STATUS \"  Build documentation ........ ${EXPAT_BUILD_DOCS}\")\nmessage(STATUS \"  Build examples ............. ${EXPAT_BUILD_EXAMPLES}\")\nmessage(STATUS \"  Build fuzzers .............. ${EXPAT_BUILD_FUZZERS}\")\nmessage(STATUS \"  Build tests ................ ${EXPAT_BUILD_TESTS}\")\nmessage(STATUS \"  Build tools (xmlwf) ........ ${EXPAT_BUILD_TOOLS}\")\nmessage(STATUS \"  Build pkg-config file ...... ${EXPAT_BUILD_PKGCONFIG}\")\nmessage(STATUS \"  Install files .............. ${EXPAT_ENABLE_INSTALL}\")\nmessage(STATUS \"\")\nmessage(STATUS \"  Features\")\nmessage(STATUS \"    // Advanced options, changes not advised\")\nmessage(STATUS \"    Attributes info .......... ${EXPAT_ATTR_INFO}\")\nmessage(STATUS \"    Context bytes ............ ${EXPAT_CONTEXT_BYTES}\")\nmessage(STATUS \"    DTD support .............. ${EXPAT_DTD}\")\nmessage(STATUS \"    General entities ......... ${EXPAT_GE}\")\nmessage(STATUS \"    Large size ............... ${EXPAT_LARGE_SIZE}\")\nmessage(STATUS \"    Minimum size ............. ${EXPAT_MIN_SIZE}\")\nmessage(STATUS \"    Namespace support ........ ${EXPAT_NS}\")\nmessage(STATUS \"\")\nmessage(STATUS \"  Entropy sources\")\nif(WIN32)\n    message(STATUS \"    rand_s ................... ON\")\nelse()\n    message(STATUS \"    getrandom ................ ${HAVE_GETRANDOM}\")\n    message(STATUS \"    syscall SYS_getrandom .... ${HAVE_SYSCALL_GETRANDOM}\")\n    message(STATUS \"    libbsd ................... ${EXPAT_WITH_LIBBSD}\")\n    message(STATUS \"    /dev/random .............. ${EXPAT_DEV_URANDOM}\")\nendif()\nmessage(STATUS \"\")\nif(CMAKE_GENERATOR STREQUAL \"Unix Makefiles\")\n    message(STATUS \"Continue with\")\n    message(STATUS \"  make\")\n    if(EXPAT_BUILD_TESTS)\n        message(STATUS \"  make test\")\n    endif()\n    if(EXPAT_ENABLE_INSTALL)\n        message(STATUS \"  sudo make install\")\n    endif()\n    message(STATUS \"\")\nendif()\nmessage(STATUS \"===========================================================================\")\n", "/*\n                            __  __            _\n                         ___\\ \\/ /_ __   __ _| |_\n                        / _ \\\\  /| '_ \\ / _` | __|\n                       |  __//  \\| |_) | (_| | |_\n                        \\___/_/\\_\\ .__/ \\__,_|\\__|\n                                 |_| XML parser\n\n   Copyright (c) 1997-2000 Thai Open Source Software Center Ltd\n   Copyright (c) 2000      Clark Cooper <coopercc@users.sourceforge.net>\n   Copyright (c) 2000-2005 Fred L. Drake, Jr. <fdrake@users.sourceforge.net>\n   Copyright (c) 2001-2002 Greg Stein <gstein@users.sourceforge.net>\n   Copyright (c) 2002-2016 Karl Waclawek <karl@waclawek.net>\n   Copyright (c) 2016-2022 Sebastian Pipping <sebastian@pipping.org>\n   Copyright (c) 2016      Cristian Rodr\u00edguez <crrodriguez@opensuse.org>\n   Copyright (c) 2016      Thomas Beutlich <tc@tbeu.de>\n   Copyright (c) 2017      Rhodri James <rhodri@wildebeest.org.uk>\n   Copyright (c) 2022      Thijs Schreijer <thijs@thijsschreijer.nl>\n   Licensed under the MIT license:\n\n   Permission is  hereby granted,  free of charge,  to any  person obtaining\n   a  copy  of  this  software   and  associated  documentation  files  (the\n   \"Software\"),  to  deal in  the  Software  without restriction,  including\n   without  limitation the  rights  to use,  copy,  modify, merge,  publish,\n   distribute, sublicense, and/or sell copies of the Software, and to permit\n   persons  to whom  the Software  is  furnished to  do so,  subject to  the\n   following conditions:\n\n   The above copyright  notice and this permission notice  shall be included\n   in all copies or substantial portions of the Software.\n\n   THE  SOFTWARE  IS  PROVIDED  \"AS  IS\",  WITHOUT  WARRANTY  OF  ANY  KIND,\n   EXPRESS  OR IMPLIED,  INCLUDING  BUT  NOT LIMITED  TO  THE WARRANTIES  OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n   NO EVENT SHALL THE AUTHORS OR  COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n   DAMAGES OR  OTHER LIABILITY, WHETHER  IN AN  ACTION OF CONTRACT,  TORT OR\n   OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n   USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#ifndef Expat_INCLUDED\n#define Expat_INCLUDED 1\n\n#include <stdlib.h>\n#include \"expat_external.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nstruct XML_ParserStruct;\ntypedef struct XML_ParserStruct *XML_Parser;\n\ntypedef unsigned char XML_Bool;\n#define XML_TRUE ((XML_Bool)1)\n#define XML_FALSE ((XML_Bool)0)\n\n/* The XML_Status enum gives the possible return values for several\n   API functions.  The preprocessor #defines are included so this\n   stanza can be added to code that still needs to support older\n   versions of Expat 1.95.x:\n\n   #ifndef XML_STATUS_OK\n   #define XML_STATUS_OK    1\n   #define XML_STATUS_ERROR 0\n   #endif\n\n   Otherwise, the #define hackery is quite ugly and would have been\n   dropped.\n*/\nenum XML_Status {\n  XML_STATUS_ERROR = 0,\n#define XML_STATUS_ERROR XML_STATUS_ERROR\n  XML_STATUS_OK = 1,\n#define XML_STATUS_OK XML_STATUS_OK\n  XML_STATUS_SUSPENDED = 2\n#define XML_STATUS_SUSPENDED XML_STATUS_SUSPENDED\n};\n\nenum XML_Error {\n  XML_ERROR_NONE,\n  XML_ERROR_NO_MEMORY,\n  XML_ERROR_SYNTAX,\n  XML_ERROR_NO_ELEMENTS,\n  XML_ERROR_INVALID_TOKEN,\n  XML_ERROR_UNCLOSED_TOKEN,\n  XML_ERROR_PARTIAL_CHAR,\n  XML_ERROR_TAG_MISMATCH,\n  XML_ERROR_DUPLICATE_ATTRIBUTE,\n  XML_ERROR_JUNK_AFTER_DOC_ELEMENT,\n  XML_ERROR_PARAM_ENTITY_REF,\n  XML_ERROR_UNDEFINED_ENTITY,\n  XML_ERROR_RECURSIVE_ENTITY_REF,\n  XML_ERROR_ASYNC_ENTITY,\n  XML_ERROR_BAD_CHAR_REF,\n  XML_ERROR_BINARY_ENTITY_REF,\n  XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF,\n  XML_ERROR_MISPLACED_XML_PI,\n  XML_ERROR_UNKNOWN_ENCODING,\n  XML_ERROR_INCORRECT_ENCODING,\n  XML_ERROR_UNCLOSED_CDATA_SECTION,\n  XML_ERROR_EXTERNAL_ENTITY_HANDLING,\n  XML_ERROR_NOT_STANDALONE,\n  XML_ERROR_UNEXPECTED_STATE,\n  XML_ERROR_ENTITY_DECLARED_IN_PE,\n  XML_ERROR_FEATURE_REQUIRES_XML_DTD,\n  XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING,\n  /* Added in 1.95.7. */\n  XML_ERROR_UNBOUND_PREFIX,\n  /* Added in 1.95.8. */\n  XML_ERROR_UNDECLARING_PREFIX,\n  XML_ERROR_INCOMPLETE_PE,\n  XML_ERROR_XML_DECL,\n  XML_ERROR_TEXT_DECL,\n  XML_ERROR_PUBLICID,\n  XML_ERROR_SUSPENDED,\n  XML_ERROR_NOT_SUSPENDED,\n  XML_ERROR_ABORTED,\n  XML_ERROR_FINISHED,\n  XML_ERROR_SUSPEND_PE,\n  /* Added in 2.0. */\n  XML_ERROR_RESERVED_PREFIX_XML,\n  XML_ERROR_RESERVED_PREFIX_XMLNS,\n  XML_ERROR_RESERVED_NAMESPACE_URI,\n  /* Added in 2.2.1. */\n  XML_ERROR_INVALID_ARGUMENT,\n  /* Added in 2.3.0. */\n  XML_ERROR_NO_BUFFER,\n  /* Added in 2.4.0. */\n  XML_ERROR_AMPLIFICATION_LIMIT_BREACH\n};\n\nenum XML_Content_Type {\n  XML_CTYPE_EMPTY = 1,\n  XML_CTYPE_ANY,\n  XML_CTYPE_MIXED,\n  XML_CTYPE_NAME,\n  XML_CTYPE_CHOICE,\n  XML_CTYPE_SEQ\n};\n\nenum XML_Content_Quant {\n  XML_CQUANT_NONE,\n  XML_CQUANT_OPT,\n  XML_CQUANT_REP,\n  XML_CQUANT_PLUS\n};\n\n/* If type == XML_CTYPE_EMPTY or XML_CTYPE_ANY, then quant will be\n   XML_CQUANT_NONE, and the other fields will be zero or NULL.\n   If type == XML_CTYPE_MIXED, then quant will be NONE or REP and\n   numchildren will contain number of elements that may be mixed in\n   and children point to an array of XML_Content cells that will be\n   all of XML_CTYPE_NAME type with no quantification.\n\n   If type == XML_CTYPE_NAME, then the name points to the name, and\n   the numchildren field will be zero and children will be NULL. The\n   quant fields indicates any quantifiers placed on the name.\n\n   CHOICE and SEQ will have name NULL, the number of children in\n   numchildren and children will point, recursively, to an array\n   of XML_Content cells.\n\n   The EMPTY, ANY, and MIXED types will only occur at top level.\n*/\n\ntypedef struct XML_cp XML_Content;\n\nstruct XML_cp {\n  enum XML_Content_Type type;\n  enum XML_Content_Quant quant;\n  XML_Char *name;\n  unsigned int numchildren;\n  XML_Content *children;\n};\n\n/* This is called for an element declaration. See above for\n   description of the model argument. It's the user code's responsibility\n   to free model when finished with it. See XML_FreeContentModel.\n   There is no need to free the model from the handler, it can be kept\n   around and freed at a later stage.\n*/\ntypedef void(XMLCALL *XML_ElementDeclHandler)(void *userData,\n                                              const XML_Char *name,\n                                              XML_Content *model);\n\nXMLPARSEAPI(void)\nXML_SetElementDeclHandler(XML_Parser parser, XML_ElementDeclHandler eldecl);\n\n/* The Attlist declaration handler is called for *each* attribute. So\n   a single Attlist declaration with multiple attributes declared will\n   generate multiple calls to this handler. The \"default\" parameter\n   may be NULL in the case of the \"#IMPLIED\" or \"#REQUIRED\"\n   keyword. The \"isrequired\" parameter will be true and the default\n   value will be NULL in the case of \"#REQUIRED\". If \"isrequired\" is\n   true and default is non-NULL, then this is a \"#FIXED\" default.\n*/\ntypedef void(XMLCALL *XML_AttlistDeclHandler)(\n    void *userData, const XML_Char *elname, const XML_Char *attname,\n    const XML_Char *att_type, const XML_Char *dflt, int isrequired);\n\nXMLPARSEAPI(void)\nXML_SetAttlistDeclHandler(XML_Parser parser, XML_AttlistDeclHandler attdecl);\n\n/* The XML declaration handler is called for *both* XML declarations\n   and text declarations. The way to distinguish is that the version\n   parameter will be NULL for text declarations. The encoding\n   parameter may be NULL for XML declarations. The standalone\n   parameter will be -1, 0, or 1 indicating respectively that there\n   was no standalone parameter in the declaration, that it was given\n   as no, or that it was given as yes.\n*/\ntypedef void(XMLCALL *XML_XmlDeclHandler)(void *userData,\n                                          const XML_Char *version,\n                                          const XML_Char *encoding,\n                                          int standalone);\n\nXMLPARSEAPI(void)\nXML_SetXmlDeclHandler(XML_Parser parser, XML_XmlDeclHandler xmldecl);\n\ntypedef struct {\n  void *(*malloc_fcn)(size_t size);\n  void *(*realloc_fcn)(void *ptr, size_t size);\n  void (*free_fcn)(void *ptr);\n} XML_Memory_Handling_Suite;\n\n/* Constructs a new parser; encoding is the encoding specified by the\n   external protocol or NULL if there is none specified.\n*/\nXMLPARSEAPI(XML_Parser)\nXML_ParserCreate(const XML_Char *encoding);\n\n/* Constructs a new parser and namespace processor.  Element type\n   names and attribute names that belong to a namespace will be\n   expanded; unprefixed attribute names are never expanded; unprefixed\n   element type names are expanded only if there is a default\n   namespace. The expanded name is the concatenation of the namespace\n   URI, the namespace separator character, and the local part of the\n   name.  If the namespace separator is '\\0' then the namespace URI\n   and the local part will be concatenated without any separator.\n   It is a programming error to use the separator '\\0' with namespace\n   triplets (see XML_SetReturnNSTriplet).\n   If a namespace separator is chosen that can be part of a URI or\n   part of an XML name, splitting an expanded name back into its\n   1, 2 or 3 original parts on application level in the element handler\n   may end up vulnerable, so these are advised against;  sane choices for\n   a namespace separator are e.g. '\\n' (line feed) and '|' (pipe).\n\n   Note that Expat does not validate namespace URIs (beyond encoding)\n   against RFC 3986 today (and is not required to do so with regard to\n   the XML 1.0 namespaces specification) but it may start doing that\n   in future releases.  Before that, an application using Expat must\n   be ready to receive namespace URIs containing non-URI characters.\n*/\nXMLPARSEAPI(XML_Parser)\nXML_ParserCreateNS(const XML_Char *encoding, XML_Char namespaceSeparator);\n\n/* Constructs a new parser using the memory management suite referred to\n   by memsuite. If memsuite is NULL, then use the standard library memory\n   suite. If namespaceSeparator is non-NULL it creates a parser with\n   namespace processing as described above. The character pointed at\n   will serve as the namespace separator.\n\n   All further memory operations used for the created parser will come from\n   the given suite.\n*/\nXMLPARSEAPI(XML_Parser)\nXML_ParserCreate_MM(const XML_Char *encoding,\n                    const XML_Memory_Handling_Suite *memsuite,\n                    const XML_Char *namespaceSeparator);\n\n/* Prepare a parser object to be reused.  This is particularly\n   valuable when memory allocation overhead is disproportionately high,\n   such as when a large number of small documnents need to be parsed.\n   All handlers are cleared from the parser, except for the\n   unknownEncodingHandler. The parser's external state is re-initialized\n   except for the values of ns and ns_triplets.\n\n   Added in Expat 1.95.3.\n*/\nXMLPARSEAPI(XML_Bool)\nXML_ParserReset(XML_Parser parser, const XML_Char *encoding);\n\n/* atts is array of name/value pairs, terminated by 0;\n   names and values are 0 terminated.\n*/\ntypedef void(XMLCALL *XML_StartElementHandler)(void *userData,\n                                               const XML_Char *name,\n                                               const XML_Char **atts);\n\ntypedef void(XMLCALL *XML_EndElementHandler)(void *userData,\n                                             const XML_Char *name);\n\n/* s is not 0 terminated. */\ntypedef void(XMLCALL *XML_CharacterDataHandler)(void *userData,\n                                                const XML_Char *s, int len);\n\n/* target and data are 0 terminated */\ntypedef void(XMLCALL *XML_ProcessingInstructionHandler)(void *userData,\n                                                        const XML_Char *target,\n                                                        const XML_Char *data);\n\n/* data is 0 terminated */\ntypedef void(XMLCALL *XML_CommentHandler)(void *userData, const XML_Char *data);\n\ntypedef void(XMLCALL *XML_StartCdataSectionHandler)(void *userData);\ntypedef void(XMLCALL *XML_EndCdataSectionHandler)(void *userData);\n\n/* This is called for any characters in the XML document for which\n   there is no applicable handler.  This includes both characters that\n   are part of markup which is of a kind that is not reported\n   (comments, markup declarations), or characters that are part of a\n   construct which could be reported but for which no handler has been\n   supplied. The characters are passed exactly as they were in the XML\n   document except that they will be encoded in UTF-8 or UTF-16.\n   Line boundaries are not normalized. Note that a byte order mark\n   character is not passed to the default handler. There are no\n   guarantees about how characters are divided between calls to the\n   default handler: for example, a comment might be split between\n   multiple calls.\n*/\ntypedef void(XMLCALL *XML_DefaultHandler)(void *userData, const XML_Char *s,\n                                          int len);\n\n/* This is called for the start of the DOCTYPE declaration, before\n   any DTD or internal subset is parsed.\n*/\ntypedef void(XMLCALL *XML_StartDoctypeDeclHandler)(void *userData,\n                                                   const XML_Char *doctypeName,\n                                                   const XML_Char *sysid,\n                                                   const XML_Char *pubid,\n                                                   int has_internal_subset);\n\n/* This is called for the end of the DOCTYPE declaration when the\n   closing > is encountered, but after processing any external\n   subset.\n*/\ntypedef void(XMLCALL *XML_EndDoctypeDeclHandler)(void *userData);\n\n/* This is called for entity declarations. The is_parameter_entity\n   argument will be non-zero if the entity is a parameter entity, zero\n   otherwise.\n\n   For internal entities (<!ENTITY foo \"bar\">), value will\n   be non-NULL and systemId, publicID, and notationName will be NULL.\n   The value string is NOT null-terminated; the length is provided in\n   the value_length argument. Since it is legal to have zero-length\n   values, do not use this argument to test for internal entities.\n\n   For external entities, value will be NULL and systemId will be\n   non-NULL. The publicId argument will be NULL unless a public\n   identifier was provided. The notationName argument will have a\n   non-NULL value only for unparsed entity declarations.\n\n   Note that is_parameter_entity can't be changed to XML_Bool, since\n   that would break binary compatibility.\n*/\ntypedef void(XMLCALL *XML_EntityDeclHandler)(\n    void *userData, const XML_Char *entityName, int is_parameter_entity,\n    const XML_Char *value, int value_length, const XML_Char *base,\n    const XML_Char *systemId, const XML_Char *publicId,\n    const XML_Char *notationName);\n\nXMLPARSEAPI(void)\nXML_SetEntityDeclHandler(XML_Parser parser, XML_EntityDeclHandler handler);\n\n/* OBSOLETE -- OBSOLETE -- OBSOLETE\n   This handler has been superseded by the EntityDeclHandler above.\n   It is provided here for backward compatibility.\n\n   This is called for a declaration of an unparsed (NDATA) entity.\n   The base argument is whatever was set by XML_SetBase. The\n   entityName, systemId and notationName arguments will never be\n   NULL. The other arguments may be.\n*/\ntypedef void(XMLCALL *XML_UnparsedEntityDeclHandler)(\n    void *userData, const XML_Char *entityName, const XML_Char *base,\n    const XML_Char *systemId, const XML_Char *publicId,\n    const XML_Char *notationName);\n\n/* This is called for a declaration of notation.  The base argument is\n   whatever was set by XML_SetBase. The notationName will never be\n   NULL.  The other arguments can be.\n*/\ntypedef void(XMLCALL *XML_NotationDeclHandler)(void *userData,\n                                               const XML_Char *notationName,\n                                               const XML_Char *base,\n                                               const XML_Char *systemId,\n                                               const XML_Char *publicId);\n\n/* When namespace processing is enabled, these are called once for\n   each namespace declaration. The call to the start and end element\n   handlers occur between the calls to the start and end namespace\n   declaration handlers. For an xmlns attribute, prefix will be\n   NULL.  For an xmlns=\"\" attribute, uri will be NULL.\n*/\ntypedef void(XMLCALL *XML_StartNamespaceDeclHandler)(void *userData,\n                                                     const XML_Char *prefix,\n                                                     const XML_Char *uri);\n\ntypedef void(XMLCALL *XML_EndNamespaceDeclHandler)(void *userData,\n                                                   const XML_Char *prefix);\n\n/* This is called if the document is not standalone, that is, it has an\n   external subset or a reference to a parameter entity, but does not\n   have standalone=\"yes\". If this handler returns XML_STATUS_ERROR,\n   then processing will not continue, and the parser will return a\n   XML_ERROR_NOT_STANDALONE error.\n   If parameter entity parsing is enabled, then in addition to the\n   conditions above this handler will only be called if the referenced\n   entity was actually read.\n*/\ntypedef int(XMLCALL *XML_NotStandaloneHandler)(void *userData);\n\n/* This is called for a reference to an external parsed general\n   entity.  The referenced entity is not automatically parsed.  The\n   application can parse it immediately or later using\n   XML_ExternalEntityParserCreate.\n\n   The parser argument is the parser parsing the entity containing the\n   reference; it can be passed as the parser argument to\n   XML_ExternalEntityParserCreate.  The systemId argument is the\n   system identifier as specified in the entity declaration; it will\n   not be NULL.\n\n   The base argument is the system identifier that should be used as\n   the base for resolving systemId if systemId was relative; this is\n   set by XML_SetBase; it may be NULL.\n\n   The publicId argument is the public identifier as specified in the\n   entity declaration, or NULL if none was specified; the whitespace\n   in the public identifier will have been normalized as required by\n   the XML spec.\n\n   The context argument specifies the parsing context in the format\n   expected by the context argument to XML_ExternalEntityParserCreate;\n   context is valid only until the handler returns, so if the\n   referenced entity is to be parsed later, it must be copied.\n   context is NULL only when the entity is a parameter entity.\n\n   The handler should return XML_STATUS_ERROR if processing should not\n   continue because of a fatal error in the handling of the external\n   entity.  In this case the calling parser will return an\n   XML_ERROR_EXTERNAL_ENTITY_HANDLING error.\n\n   Note that unlike other handlers the first argument is the parser,\n   not userData.\n*/\ntypedef int(XMLCALL *XML_ExternalEntityRefHandler)(XML_Parser parser,\n                                                   const XML_Char *context,\n                                                   const XML_Char *base,\n                                                   const XML_Char *systemId,\n                                                   const XML_Char *publicId);\n\n/* This is called in two situations:\n   1) An entity reference is encountered for which no declaration\n      has been read *and* this is not an error.\n   2) An internal entity reference is read, but not expanded, because\n      XML_SetDefaultHandler has been called.\n   Note: skipped parameter entities in declarations and skipped general\n         entities in attribute values cannot be reported, because\n         the event would be out of sync with the reporting of the\n         declarations or attribute values\n*/\ntypedef void(XMLCALL *XML_SkippedEntityHandler)(void *userData,\n                                                const XML_Char *entityName,\n                                                int is_parameter_entity);\n\n/* This structure is filled in by the XML_UnknownEncodingHandler to\n   provide information to the parser about encodings that are unknown\n   to the parser.\n\n   The map[b] member gives information about byte sequences whose\n   first byte is b.\n\n   If map[b] is c where c is >= 0, then b by itself encodes the\n   Unicode scalar value c.\n\n   If map[b] is -1, then the byte sequence is malformed.\n\n   If map[b] is -n, where n >= 2, then b is the first byte of an\n   n-byte sequence that encodes a single Unicode scalar value.\n\n   The data member will be passed as the first argument to the convert\n   function.\n\n   The convert function is used to convert multibyte sequences; s will\n   point to a n-byte sequence where map[(unsigned char)*s] == -n.  The\n   convert function must return the Unicode scalar value represented\n   by this byte sequence or -1 if the byte sequence is malformed.\n\n   The convert function may be NULL if the encoding is a single-byte\n   encoding, that is if map[b] >= -1 for all bytes b.\n\n   When the parser is finished with the encoding, then if release is\n   not NULL, it will call release passing it the data member; once\n   release has been called, the convert function will not be called\n   again.\n\n   Expat places certain restrictions on the encodings that are supported\n   using this mechanism.\n\n   1. Every ASCII character that can appear in a well-formed XML document,\n      other than the characters\n\n      $@\\^`{}~\n\n      must be represented by a single byte, and that byte must be the\n      same byte that represents that character in ASCII.\n\n   2. No character may require more than 4 bytes to encode.\n\n   3. All characters encoded must have Unicode scalar values <=\n      0xFFFF, (i.e., characters that would be encoded by surrogates in\n      UTF-16 are  not allowed).  Note that this restriction doesn't\n      apply to the built-in support for UTF-8 and UTF-16.\n\n   4. No Unicode character may be encoded by more than one distinct\n      sequence of bytes.\n*/\ntypedef struct {\n  int map[256];\n  void *data;\n  int(XMLCALL *convert)(void *data, const char *s);\n  void(XMLCALL *release)(void *data);\n} XML_Encoding;\n\n/* This is called for an encoding that is unknown to the parser.\n\n   The encodingHandlerData argument is that which was passed as the\n   second argument to XML_SetUnknownEncodingHandler.\n\n   The name argument gives the name of the encoding as specified in\n   the encoding declaration.\n\n   If the callback can provide information about the encoding, it must\n   fill in the XML_Encoding structure, and return XML_STATUS_OK.\n   Otherwise it must return XML_STATUS_ERROR.\n\n   If info does not describe a suitable encoding, then the parser will\n   return an XML_ERROR_UNKNOWN_ENCODING error.\n*/\ntypedef int(XMLCALL *XML_UnknownEncodingHandler)(void *encodingHandlerData,\n                                                 const XML_Char *name,\n                                                 XML_Encoding *info);\n\nXMLPARSEAPI(void)\nXML_SetElementHandler(XML_Parser parser, XML_StartElementHandler start,\n                      XML_EndElementHandler end);\n\nXMLPARSEAPI(void)\nXML_SetStartElementHandler(XML_Parser parser, XML_StartElementHandler handler);\n\nXMLPARSEAPI(void)\nXML_SetEndElementHandler(XML_Parser parser, XML_EndElementHandler handler);\n\nXMLPARSEAPI(void)\nXML_SetCharacterDataHandler(XML_Parser parser,\n                            XML_CharacterDataHandler handler);\n\nXMLPARSEAPI(void)\nXML_SetProcessingInstructionHandler(XML_Parser parser,\n                                    XML_ProcessingInstructionHandler handler);\nXMLPARSEAPI(void)\nXML_SetCommentHandler(XML_Parser parser, XML_CommentHandler handler);\n\nXMLPARSEAPI(void)\nXML_SetCdataSectionHandler(XML_Parser parser,\n                           XML_StartCdataSectionHandler start,\n                           XML_EndCdataSectionHandler end);\n\nXMLPARSEAPI(void)\nXML_SetStartCdataSectionHandler(XML_Parser parser,\n                                XML_StartCdataSectionHandler start);\n\nXMLPARSEAPI(void)\nXML_SetEndCdataSectionHandler(XML_Parser parser,\n                              XML_EndCdataSectionHandler end);\n\n/* This sets the default handler and also inhibits expansion of\n   internal entities. These entity references will be passed to the\n   default handler, or to the skipped entity handler, if one is set.\n*/\nXMLPARSEAPI(void)\nXML_SetDefaultHandler(XML_Parser parser, XML_DefaultHandler handler);\n\n/* This sets the default handler but does not inhibit expansion of\n   internal entities.  The entity reference will not be passed to the\n   default handler.\n*/\nXMLPARSEAPI(void)\nXML_SetDefaultHandlerExpand(XML_Parser parser, XML_DefaultHandler handler);\n\nXMLPARSEAPI(void)\nXML_SetDoctypeDeclHandler(XML_Parser parser, XML_StartDoctypeDeclHandler start,\n                          XML_EndDoctypeDeclHandler end);\n\nXMLPARSEAPI(void)\nXML_SetStartDoctypeDeclHandler(XML_Parser parser,\n                               XML_StartDoctypeDeclHandler start);\n\nXMLPARSEAPI(void)\nXML_SetEndDoctypeDeclHandler(XML_Parser parser, XML_EndDoctypeDeclHandler end);\n\nXMLPARSEAPI(void)\nXML_SetUnparsedEntityDeclHandler(XML_Parser parser,\n                                 XML_UnparsedEntityDeclHandler handler);\n\nXMLPARSEAPI(void)\nXML_SetNotationDeclHandler(XML_Parser parser, XML_NotationDeclHandler handler);\n\nXMLPARSEAPI(void)\nXML_SetNamespaceDeclHandler(XML_Parser parser,\n                            XML_StartNamespaceDeclHandler start,\n                            XML_EndNamespaceDeclHandler end);\n\nXMLPARSEAPI(void)\nXML_SetStartNamespaceDeclHandler(XML_Parser parser,\n                                 XML_StartNamespaceDeclHandler start);\n\nXMLPARSEAPI(void)\nXML_SetEndNamespaceDeclHandler(XML_Parser parser,\n                               XML_EndNamespaceDeclHandler end);\n\nXMLPARSEAPI(void)\nXML_SetNotStandaloneHandler(XML_Parser parser,\n                            XML_NotStandaloneHandler handler);\n\nXMLPARSEAPI(void)\nXML_SetExternalEntityRefHandler(XML_Parser parser,\n                                XML_ExternalEntityRefHandler handler);\n\n/* If a non-NULL value for arg is specified here, then it will be\n   passed as the first argument to the external entity ref handler\n   instead of the parser object.\n*/\nXMLPARSEAPI(void)\nXML_SetExternalEntityRefHandlerArg(XML_Parser parser, void *arg);\n\nXMLPARSEAPI(void)\nXML_SetSkippedEntityHandler(XML_Parser parser,\n                            XML_SkippedEntityHandler handler);\n\nXMLPARSEAPI(void)\nXML_SetUnknownEncodingHandler(XML_Parser parser,\n                              XML_UnknownEncodingHandler handler,\n                              void *encodingHandlerData);\n\n/* This can be called within a handler for a start element, end\n   element, processing instruction or character data.  It causes the\n   corresponding markup to be passed to the default handler.\n*/\nXMLPARSEAPI(void)\nXML_DefaultCurrent(XML_Parser parser);\n\n/* If do_nst is non-zero, and namespace processing is in effect, and\n   a name has a prefix (i.e. an explicit namespace qualifier) then\n   that name is returned as a triplet in a single string separated by\n   the separator character specified when the parser was created: URI\n   + sep + local_name + sep + prefix.\n\n   If do_nst is zero, then namespace information is returned in the\n   default manner (URI + sep + local_name) whether or not the name\n   has a prefix.\n\n   Note: Calling XML_SetReturnNSTriplet after XML_Parse or\n     XML_ParseBuffer has no effect.\n*/\n\nXMLPARSEAPI(void)\nXML_SetReturnNSTriplet(XML_Parser parser, int do_nst);\n\n/* This value is passed as the userData argument to callbacks. */\nXMLPARSEAPI(void)\nXML_SetUserData(XML_Parser parser, void *userData);\n\n/* Returns the last value set by XML_SetUserData or NULL. */\n#define XML_GetUserData(parser) (*(void **)(parser))\n\n/* This is equivalent to supplying an encoding argument to\n   XML_ParserCreate. On success XML_SetEncoding returns non-zero,\n   zero otherwise.\n   Note: Calling XML_SetEncoding after XML_Parse or XML_ParseBuffer\n     has no effect and returns XML_STATUS_ERROR.\n*/\nXMLPARSEAPI(enum XML_Status)\nXML_SetEncoding(XML_Parser parser, const XML_Char *encoding);\n\n/* If this function is called, then the parser will be passed as the\n   first argument to callbacks instead of userData.  The userData will\n   still be accessible using XML_GetUserData.\n*/\nXMLPARSEAPI(void)\nXML_UseParserAsHandlerArg(XML_Parser parser);\n\n/* If useDTD == XML_TRUE is passed to this function, then the parser\n   will assume that there is an external subset, even if none is\n   specified in the document. In such a case the parser will call the\n   externalEntityRefHandler with a value of NULL for the systemId\n   argument (the publicId and context arguments will be NULL as well).\n   Note: For the purpose of checking WFC: Entity Declared, passing\n     useDTD == XML_TRUE will make the parser behave as if the document\n     had a DTD with an external subset.\n   Note: If this function is called, then this must be done before\n     the first call to XML_Parse or XML_ParseBuffer, since it will\n     have no effect after that.  Returns\n     XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING.\n   Note: If the document does not have a DOCTYPE declaration at all,\n     then startDoctypeDeclHandler and endDoctypeDeclHandler will not\n     be called, despite an external subset being parsed.\n   Note: If XML_DTD is not defined when Expat is compiled, returns\n     XML_ERROR_FEATURE_REQUIRES_XML_DTD.\n   Note: If parser == NULL, returns XML_ERROR_INVALID_ARGUMENT.\n*/\nXMLPARSEAPI(enum XML_Error)\nXML_UseForeignDTD(XML_Parser parser, XML_Bool useDTD);\n\n/* Sets the base to be used for resolving relative URIs in system\n   identifiers in declarations.  Resolving relative identifiers is\n   left to the application: this value will be passed through as the\n   base argument to the XML_ExternalEntityRefHandler,\n   XML_NotationDeclHandler and XML_UnparsedEntityDeclHandler. The base\n   argument will be copied.  Returns XML_STATUS_ERROR if out of memory,\n   XML_STATUS_OK otherwise.\n*/\nXMLPARSEAPI(enum XML_Status)\nXML_SetBase(XML_Parser parser, const XML_Char *base);\n\nXMLPARSEAPI(const XML_Char *)\nXML_GetBase(XML_Parser parser);\n\n/* Returns the number of the attribute/value pairs passed in last call\n   to the XML_StartElementHandler that were specified in the start-tag\n   rather than defaulted. Each attribute/value pair counts as 2; thus\n   this corresponds to an index into the atts array passed to the\n   XML_StartElementHandler.  Returns -1 if parser == NULL.\n*/\nXMLPARSEAPI(int)\nXML_GetSpecifiedAttributeCount(XML_Parser parser);\n\n/* Returns the index of the ID attribute passed in the last call to\n   XML_StartElementHandler, or -1 if there is no ID attribute or\n   parser == NULL.  Each attribute/value pair counts as 2; thus this\n   corresponds to an index into the atts array passed to the\n   XML_StartElementHandler.\n*/\nXMLPARSEAPI(int)\nXML_GetIdAttributeIndex(XML_Parser parser);\n\n#ifdef XML_ATTR_INFO\n/* Source file byte offsets for the start and end of attribute names and values.\n   The value indices are exclusive of surrounding quotes; thus in a UTF-8 source\n   file an attribute value of \"blah\" will yield:\n   info->valueEnd - info->valueStart = 4 bytes.\n*/\ntypedef struct {\n  XML_Index nameStart;  /* Offset to beginning of the attribute name. */\n  XML_Index nameEnd;    /* Offset after the attribute name's last byte. */\n  XML_Index valueStart; /* Offset to beginning of the attribute value. */\n  XML_Index valueEnd;   /* Offset after the attribute value's last byte. */\n} XML_AttrInfo;\n\n/* Returns an array of XML_AttrInfo structures for the attribute/value pairs\n   passed in last call to the XML_StartElementHandler that were specified\n   in the start-tag rather than defaulted. Each attribute/value pair counts\n   as 1; thus the number of entries in the array is\n   XML_GetSpecifiedAttributeCount(parser) / 2.\n*/\nXMLPARSEAPI(const XML_AttrInfo *)\nXML_GetAttributeInfo(XML_Parser parser);\n#endif\n\n/* Parses some input. Returns XML_STATUS_ERROR if a fatal error is\n   detected.  The last call to XML_Parse must have isFinal true; len\n   may be zero for this call (or any other).\n\n   Though the return values for these functions has always been\n   described as a Boolean value, the implementation, at least for the\n   1.95.x series, has always returned exactly one of the XML_Status\n   values.\n*/\nXMLPARSEAPI(enum XML_Status)\nXML_Parse(XML_Parser parser, const char *s, int len, int isFinal);\n\nXMLPARSEAPI(void *)\nXML_GetBuffer(XML_Parser parser, int len);\n\nXMLPARSEAPI(enum XML_Status)\nXML_ParseBuffer(XML_Parser parser, int len, int isFinal);\n\n/* Stops parsing, causing XML_Parse() or XML_ParseBuffer() to return.\n   Must be called from within a call-back handler, except when aborting\n   (resumable = 0) an already suspended parser. Some call-backs may\n   still follow because they would otherwise get lost. Examples:\n   - endElementHandler() for empty elements when stopped in\n     startElementHandler(),\n   - endNameSpaceDeclHandler() when stopped in endElementHandler(),\n   and possibly others.\n\n   Can be called from most handlers, including DTD related call-backs,\n   except when parsing an external parameter entity and resumable != 0.\n   Returns XML_STATUS_OK when successful, XML_STATUS_ERROR otherwise.\n   Possible error codes:\n   - XML_ERROR_SUSPENDED: when suspending an already suspended parser.\n   - XML_ERROR_FINISHED: when the parser has already finished.\n   - XML_ERROR_SUSPEND_PE: when suspending while parsing an external PE.\n\n   When resumable != 0 (true) then parsing is suspended, that is,\n   XML_Parse() and XML_ParseBuffer() return XML_STATUS_SUSPENDED.\n   Otherwise, parsing is aborted, that is, XML_Parse() and XML_ParseBuffer()\n   return XML_STATUS_ERROR with error code XML_ERROR_ABORTED.\n\n   *Note*:\n   This will be applied to the current parser instance only, that is, if\n   there is a parent parser then it will continue parsing when the\n   externalEntityRefHandler() returns. It is up to the implementation of\n   the externalEntityRefHandler() to call XML_StopParser() on the parent\n   parser (recursively), if one wants to stop parsing altogether.\n\n   When suspended, parsing can be resumed by calling XML_ResumeParser().\n*/\nXMLPARSEAPI(enum XML_Status)\nXML_StopParser(XML_Parser parser, XML_Bool resumable);\n\n/* Resumes parsing after it has been suspended with XML_StopParser().\n   Must not be called from within a handler call-back. Returns same\n   status codes as XML_Parse() or XML_ParseBuffer().\n   Additional error code XML_ERROR_NOT_SUSPENDED possible.\n\n   *Note*:\n   This must be called on the most deeply nested child parser instance\n   first, and on its parent parser only after the child parser has finished,\n   to be applied recursively until the document entity's parser is restarted.\n   That is, the parent parser will not resume by itself and it is up to the\n   application to call XML_ResumeParser() on it at the appropriate moment.\n*/\nXMLPARSEAPI(enum XML_Status)\nXML_ResumeParser(XML_Parser parser);\n\nenum XML_Parsing { XML_INITIALIZED, XML_PARSING, XML_FINISHED, XML_SUSPENDED };\n\ntypedef struct {\n  enum XML_Parsing parsing;\n  XML_Bool finalBuffer;\n} XML_ParsingStatus;\n\n/* Returns status of parser with respect to being initialized, parsing,\n   finished, or suspended and processing the final buffer.\n   XXX XML_Parse() and XML_ParseBuffer() should return XML_ParsingStatus,\n   XXX with XML_FINISHED_OK or XML_FINISHED_ERROR replacing XML_FINISHED\n*/\nXMLPARSEAPI(void)\nXML_GetParsingStatus(XML_Parser parser, XML_ParsingStatus *status);\n\n/* Creates an XML_Parser object that can parse an external general\n   entity; context is a '\\0'-terminated string specifying the parse\n   context; encoding is a '\\0'-terminated string giving the name of\n   the externally specified encoding, or NULL if there is no\n   externally specified encoding.  The context string consists of a\n   sequence of tokens separated by formfeeds (\\f); a token consisting\n   of a name specifies that the general entity of the name is open; a\n   token of the form prefix=uri specifies the namespace for a\n   particular prefix; a token of the form =uri specifies the default\n   namespace.  This can be called at any point after the first call to\n   an ExternalEntityRefHandler so longer as the parser has not yet\n   been freed.  The new parser is completely independent and may\n   safely be used in a separate thread.  The handlers and userData are\n   initialized from the parser argument.  Returns NULL if out of memory.\n   Otherwise returns a new XML_Parser object.\n*/\nXMLPARSEAPI(XML_Parser)\nXML_ExternalEntityParserCreate(XML_Parser parser, const XML_Char *context,\n                               const XML_Char *encoding);\n\nenum XML_ParamEntityParsing {\n  XML_PARAM_ENTITY_PARSING_NEVER,\n  XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE,\n  XML_PARAM_ENTITY_PARSING_ALWAYS\n};\n\n/* Controls parsing of parameter entities (including the external DTD\n   subset). If parsing of parameter entities is enabled, then\n   references to external parameter entities (including the external\n   DTD subset) will be passed to the handler set with\n   XML_SetExternalEntityRefHandler.  The context passed will be 0.\n\n   Unlike external general entities, external parameter entities can\n   only be parsed synchronously.  If the external parameter entity is\n   to be parsed, it must be parsed during the call to the external\n   entity ref handler: the complete sequence of\n   XML_ExternalEntityParserCreate, XML_Parse/XML_ParseBuffer and\n   XML_ParserFree calls must be made during this call.  After\n   XML_ExternalEntityParserCreate has been called to create the parser\n   for the external parameter entity (context must be 0 for this\n   call), it is illegal to make any calls on the old parser until\n   XML_ParserFree has been called on the newly created parser.\n   If the library has been compiled without support for parameter\n   entity parsing (ie without XML_DTD being defined), then\n   XML_SetParamEntityParsing will return 0 if parsing of parameter\n   entities is requested; otherwise it will return non-zero.\n   Note: If XML_SetParamEntityParsing is called after XML_Parse or\n      XML_ParseBuffer, then it has no effect and will always return 0.\n   Note: If parser == NULL, the function will do nothing and return 0.\n*/\nXMLPARSEAPI(int)\nXML_SetParamEntityParsing(XML_Parser parser,\n                          enum XML_ParamEntityParsing parsing);\n\n/* Sets the hash salt to use for internal hash calculations.\n   Helps in preventing DoS attacks based on predicting hash\n   function behavior. This must be called before parsing is started.\n   Returns 1 if successful, 0 when called after parsing has started.\n   Note: If parser == NULL, the function will do nothing and return 0.\n*/\nXMLPARSEAPI(int)\nXML_SetHashSalt(XML_Parser parser, unsigned long hash_salt);\n\n/* If XML_Parse or XML_ParseBuffer have returned XML_STATUS_ERROR, then\n   XML_GetErrorCode returns information about the error.\n*/\nXMLPARSEAPI(enum XML_Error)\nXML_GetErrorCode(XML_Parser parser);\n\n/* These functions return information about the current parse\n   location.  They may be called from any callback called to report\n   some parse event; in this case the location is the location of the\n   first of the sequence of characters that generated the event.  When\n   called from callbacks generated by declarations in the document\n   prologue, the location identified isn't as neatly defined, but will\n   be within the relevant markup.  When called outside of the callback\n   functions, the position indicated will be just past the last parse\n   event (regardless of whether there was an associated callback).\n\n   They may also be called after returning from a call to XML_Parse\n   or XML_ParseBuffer.  If the return value is XML_STATUS_ERROR then\n   the location is the location of the character at which the error\n   was detected; otherwise the location is the location of the last\n   parse event, as described above.\n\n   Note: XML_GetCurrentLineNumber and XML_GetCurrentColumnNumber\n   return 0 to indicate an error.\n   Note: XML_GetCurrentByteIndex returns -1 to indicate an error.\n*/\nXMLPARSEAPI(XML_Size) XML_GetCurrentLineNumber(XML_Parser parser);\nXMLPARSEAPI(XML_Size) XML_GetCurrentColumnNumber(XML_Parser parser);\nXMLPARSEAPI(XML_Index) XML_GetCurrentByteIndex(XML_Parser parser);\n\n/* Return the number of bytes in the current event.\n   Returns 0 if the event is in an internal entity.\n*/\nXMLPARSEAPI(int)\nXML_GetCurrentByteCount(XML_Parser parser);\n\n/* If XML_CONTEXT_BYTES is >=1, returns the input buffer, sets\n   the integer pointed to by offset to the offset within this buffer\n   of the current parse position, and sets the integer pointed to by size\n   to the size of this buffer (the number of input bytes). Otherwise\n   returns a NULL pointer. Also returns a NULL pointer if a parse isn't\n   active.\n\n   NOTE: The character pointer returned should not be used outside\n   the handler that makes the call.\n*/\nXMLPARSEAPI(const char *)\nXML_GetInputContext(XML_Parser parser, int *offset, int *size);\n\n/* For backwards compatibility with previous versions. */\n#define XML_GetErrorLineNumber XML_GetCurrentLineNumber\n#define XML_GetErrorColumnNumber XML_GetCurrentColumnNumber\n#define XML_GetErrorByteIndex XML_GetCurrentByteIndex\n\n/* Frees the content model passed to the element declaration handler */\nXMLPARSEAPI(void)\nXML_FreeContentModel(XML_Parser parser, XML_Content *model);\n\n/* Exposing the memory handling functions used in Expat */\nXMLPARSEAPI(void *)\nXML_ATTR_MALLOC\nXML_ATTR_ALLOC_SIZE(2)\nXML_MemMalloc(XML_Parser parser, size_t size);\n\nXMLPARSEAPI(void *)\nXML_ATTR_ALLOC_SIZE(3)\nXML_MemRealloc(XML_Parser parser, void *ptr, size_t size);\n\nXMLPARSEAPI(void)\nXML_MemFree(XML_Parser parser, void *ptr);\n\n/* Frees memory used by the parser. */\nXMLPARSEAPI(void)\nXML_ParserFree(XML_Parser parser);\n\n/* Returns a string describing the error. */\nXMLPARSEAPI(const XML_LChar *)\nXML_ErrorString(enum XML_Error code);\n\n/* Return a string containing the version number of this expat */\nXMLPARSEAPI(const XML_LChar *)\nXML_ExpatVersion(void);\n\ntypedef struct {\n  int major;\n  int minor;\n  int micro;\n} XML_Expat_Version;\n\n/* Return an XML_Expat_Version structure containing numeric version\n   number information for this version of expat.\n*/\nXMLPARSEAPI(XML_Expat_Version)\nXML_ExpatVersionInfo(void);\n\n/* Added in Expat 1.95.5. */\nenum XML_FeatureEnum {\n  XML_FEATURE_END = 0,\n  XML_FEATURE_UNICODE,\n  XML_FEATURE_UNICODE_WCHAR_T,\n  XML_FEATURE_DTD,\n  XML_FEATURE_CONTEXT_BYTES,\n  XML_FEATURE_MIN_SIZE,\n  XML_FEATURE_SIZEOF_XML_CHAR,\n  XML_FEATURE_SIZEOF_XML_LCHAR,\n  XML_FEATURE_NS,\n  XML_FEATURE_LARGE_SIZE,\n  XML_FEATURE_ATTR_INFO,\n  /* Added in Expat 2.4.0. */\n  XML_FEATURE_BILLION_LAUGHS_ATTACK_PROTECTION_MAXIMUM_AMPLIFICATION_DEFAULT,\n  XML_FEATURE_BILLION_LAUGHS_ATTACK_PROTECTION_ACTIVATION_THRESHOLD_DEFAULT\n  /* Additional features must be added to the end of this enum. */\n};\n\ntypedef struct {\n  enum XML_FeatureEnum feature;\n  const XML_LChar *name;\n  long int value;\n} XML_Feature;\n\nXMLPARSEAPI(const XML_Feature *)\nXML_GetFeatureList(void);\n\n#if defined(XML_DTD) || XML_GE == 1\n/* Added in Expat 2.4.0 for XML_DTD defined and\n * added in Expat 2.6.0 for XML_GE == 1. */\nXMLPARSEAPI(XML_Bool)\nXML_SetBillionLaughsAttackProtectionMaximumAmplification(\n    XML_Parser parser, float maximumAmplificationFactor);\n\n/* Added in Expat 2.4.0 for XML_DTD defined and\n * added in Expat 2.6.0 for XML_GE == 1. */\nXMLPARSEAPI(XML_Bool)\nXML_SetBillionLaughsAttackProtectionActivationThreshold(\n    XML_Parser parser, unsigned long long activationThresholdBytes);\n#endif\n\n/* Expat follows the semantic versioning convention.\n   See https://semver.org\n*/\n#define XML_MAJOR_VERSION 2\n#define XML_MINOR_VERSION 5\n#define XML_MICRO_VERSION 0\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* not Expat_INCLUDED */\n", "/* internal.h\n\n   Internal definitions used by Expat.  This is not needed to compile\n   client code.\n\n   The following calling convention macros are defined for frequently\n   called functions:\n\n   FASTCALL    - Used for those internal functions that have a simple\n                 body and a low number of arguments and local variables.\n\n   PTRCALL     - Used for functions called though function pointers.\n\n   PTRFASTCALL - Like PTRCALL, but for low number of arguments.\n\n   inline      - Used for selected internal functions for which inlining\n                 may improve performance on some platforms.\n\n   Note: Use of these macros is based on judgement, not hard rules,\n         and therefore subject to change.\n                            __  __            _\n                         ___\\ \\/ /_ __   __ _| |_\n                        / _ \\\\  /| '_ \\ / _` | __|\n                       |  __//  \\| |_) | (_| | |_\n                        \\___/_/\\_\\ .__/ \\__,_|\\__|\n                                 |_| XML parser\n\n   Copyright (c) 2002-2003 Fred L. Drake, Jr. <fdrake@users.sourceforge.net>\n   Copyright (c) 2002-2006 Karl Waclawek <karl@waclawek.net>\n   Copyright (c) 2003      Greg Stein <gstein@users.sourceforge.net>\n   Copyright (c) 2016-2022 Sebastian Pipping <sebastian@pipping.org>\n   Copyright (c) 2018      Yury Gribov <tetra2005@gmail.com>\n   Copyright (c) 2019      David Loffredo <loffredo@steptools.com>\n   Licensed under the MIT license:\n\n   Permission is  hereby granted,  free of charge,  to any  person obtaining\n   a  copy  of  this  software   and  associated  documentation  files  (the\n   \"Software\"),  to  deal in  the  Software  without restriction,  including\n   without  limitation the  rights  to use,  copy,  modify, merge,  publish,\n   distribute, sublicense, and/or sell copies of the Software, and to permit\n   persons  to whom  the Software  is  furnished to  do so,  subject to  the\n   following conditions:\n\n   The above copyright  notice and this permission notice  shall be included\n   in all copies or substantial portions of the Software.\n\n   THE  SOFTWARE  IS  PROVIDED  \"AS  IS\",  WITHOUT  WARRANTY  OF  ANY  KIND,\n   EXPRESS  OR IMPLIED,  INCLUDING  BUT  NOT LIMITED  TO  THE WARRANTIES  OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n   NO EVENT SHALL THE AUTHORS OR  COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n   DAMAGES OR  OTHER LIABILITY, WHETHER  IN AN  ACTION OF CONTRACT,  TORT OR\n   OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n   USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#if defined(__GNUC__) && defined(__i386__) && ! defined(__MINGW32__)\n/* We'll use this version by default only where we know it helps.\n\n   regparm() generates warnings on Solaris boxes.   See SF bug #692878.\n\n   Instability reported with egcs on a RedHat Linux 7.3.\n   Let's comment out:\n   #define FASTCALL __attribute__((stdcall, regparm(3)))\n   and let's try this:\n*/\n#  define FASTCALL __attribute__((regparm(3)))\n#  define PTRFASTCALL __attribute__((regparm(3)))\n#endif\n\n/* Using __fastcall seems to have an unexpected negative effect under\n   MS VC++, especially for function pointers, so we won't use it for\n   now on that platform. It may be reconsidered for a future release\n   if it can be made more effective.\n   Likely reason: __fastcall on Windows is like stdcall, therefore\n   the compiler cannot perform stack optimizations for call clusters.\n*/\n\n/* Make sure all of these are defined if they aren't already. */\n\n#ifndef FASTCALL\n#  define FASTCALL\n#endif\n\n#ifndef PTRCALL\n#  define PTRCALL\n#endif\n\n#ifndef PTRFASTCALL\n#  define PTRFASTCALL\n#endif\n\n#ifndef XML_MIN_SIZE\n#  if ! defined(__cplusplus) && ! defined(inline)\n#    ifdef __GNUC__\n#      define inline __inline\n#    endif /* __GNUC__ */\n#  endif\n#endif /* XML_MIN_SIZE */\n\n#ifdef __cplusplus\n#  define inline inline\n#else\n#  ifndef inline\n#    define inline\n#  endif\n#endif\n\n#include <limits.h> // ULONG_MAX\n\n#if defined(_WIN32)                                                            \\\n    && (! defined(__USE_MINGW_ANSI_STDIO)                                      \\\n        || (1 - __USE_MINGW_ANSI_STDIO - 1 == 0))\n#  define EXPAT_FMT_ULL(midpart) \"%\" midpart \"I64u\"\n#  if defined(_WIN64) // Note: modifiers \"td\" and \"zu\" do not work for MinGW\n#    define EXPAT_FMT_PTRDIFF_T(midpart) \"%\" midpart \"I64d\"\n#    define EXPAT_FMT_SIZE_T(midpart) \"%\" midpart \"I64u\"\n#  else\n#    define EXPAT_FMT_PTRDIFF_T(midpart) \"%\" midpart \"d\"\n#    define EXPAT_FMT_SIZE_T(midpart) \"%\" midpart \"u\"\n#  endif\n#else\n#  define EXPAT_FMT_ULL(midpart) \"%\" midpart \"llu\"\n#  if ! defined(ULONG_MAX)\n#    error Compiler did not define ULONG_MAX for us\n#  elif ULONG_MAX == 18446744073709551615u // 2^64-1\n#    define EXPAT_FMT_PTRDIFF_T(midpart) \"%\" midpart \"ld\"\n#    define EXPAT_FMT_SIZE_T(midpart) \"%\" midpart \"lu\"\n#  else\n#    define EXPAT_FMT_PTRDIFF_T(midpart) \"%\" midpart \"d\"\n#    define EXPAT_FMT_SIZE_T(midpart) \"%\" midpart \"u\"\n#  endif\n#endif\n\n#ifndef UNUSED_P\n#  define UNUSED_P(p) (void)p\n#endif\n\n/* NOTE BEGIN If you ever patch these defaults to greater values\n              for non-attack XML payload in your environment,\n              please file a bug report with libexpat.  Thank you!\n*/\n#define EXPAT_BILLION_LAUGHS_ATTACK_PROTECTION_MAXIMUM_AMPLIFICATION_DEFAULT   \\\n  100.0f\n#define EXPAT_BILLION_LAUGHS_ATTACK_PROTECTION_ACTIVATION_THRESHOLD_DEFAULT    \\\n  8388608 // 8 MiB, 2^23\n/* NOTE END */\n\n#include \"expat.h\" // so we can use type XML_Parser below\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nvoid _INTERNAL_trim_to_complete_utf8_characters(const char *from,\n                                                const char **fromLimRef);\n\n#if defined(XML_DTD) || XML_GE == 1\nunsigned long long testingAccountingGetCountBytesDirect(XML_Parser parser);\nunsigned long long testingAccountingGetCountBytesIndirect(XML_Parser parser);\nconst char *unsignedCharToPrintable(unsigned char c);\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n", "; DEF file for MS VC++\n\nEXPORTS\n  XML_DefaultCurrent @1\n  XML_ErrorString @2\n  XML_ExpatVersion @3\n  XML_ExpatVersionInfo @4\n  XML_ExternalEntityParserCreate @5\n  XML_GetBase @6\n  XML_GetBuffer @7\n  XML_GetCurrentByteCount @8\n  XML_GetCurrentByteIndex @9\n  XML_GetCurrentColumnNumber @10\n  XML_GetCurrentLineNumber @11\n  XML_GetErrorCode @12\n  XML_GetIdAttributeIndex @13\n  XML_GetInputContext @14\n  XML_GetSpecifiedAttributeCount @15\n  XML_Parse @16\n  XML_ParseBuffer @17\n  XML_ParserCreate @18\n  XML_ParserCreateNS @19\n  XML_ParserCreate_MM @20\n  XML_ParserFree @21\n  XML_SetAttlistDeclHandler @22\n  XML_SetBase @23\n  XML_SetCdataSectionHandler @24\n  XML_SetCharacterDataHandler @25\n  XML_SetCommentHandler @26\n  XML_SetDefaultHandler @27\n  XML_SetDefaultHandlerExpand @28\n  XML_SetDoctypeDeclHandler @29\n  XML_SetElementDeclHandler @30\n  XML_SetElementHandler @31\n  XML_SetEncoding @32\n  XML_SetEndCdataSectionHandler @33\n  XML_SetEndDoctypeDeclHandler @34\n  XML_SetEndElementHandler @35\n  XML_SetEndNamespaceDeclHandler @36\n  XML_SetEntityDeclHandler @37\n  XML_SetExternalEntityRefHandler @38\n  XML_SetExternalEntityRefHandlerArg @39\n  XML_SetNamespaceDeclHandler @40\n  XML_SetNotStandaloneHandler @41\n  XML_SetNotationDeclHandler @42\n  XML_SetParamEntityParsing @43\n  XML_SetProcessingInstructionHandler @44\n  XML_SetReturnNSTriplet @45\n  XML_SetStartCdataSectionHandler @46\n  XML_SetStartDoctypeDeclHandler @47\n  XML_SetStartElementHandler @48\n  XML_SetStartNamespaceDeclHandler @49\n  XML_SetUnknownEncodingHandler @50\n  XML_SetUnparsedEntityDeclHandler @51\n  XML_SetUserData @52\n  XML_SetXmlDeclHandler @53\n  XML_UseParserAsHandlerArg @54\n; added with version 1.95.3\n  XML_ParserReset @55\n  XML_SetSkippedEntityHandler @56\n; added with version 1.95.5\n  XML_GetFeatureList @57\n  XML_UseForeignDTD @58\n; added with version 1.95.6\n  XML_FreeContentModel @59\n  XML_MemMalloc @60\n  XML_MemRealloc @61\n  XML_MemFree @62\n; added with version 1.95.8\n  XML_StopParser @63\n  XML_ResumeParser @64\n  XML_GetParsingStatus @65\n; added with version 2.1.1\n@_EXPAT_COMMENT_ATTR_INFO@ XML_GetAttributeInfo @66\n  XML_SetHashSalt @67\n; internal @68 removed with version 2.3.1\n; added with version 2.4.0\n@_EXPAT_COMMENT_DTD_OR_GE@ XML_SetBillionLaughsAttackProtectionActivationThreshold @69\n@_EXPAT_COMMENT_DTD_OR_GE@ XML_SetBillionLaughsAttackProtectionMaximumAmplification @70\n", "/* 5ab094ffadd6edfc94c3eee53af44a86951f9f1f0933ada3114bbce2bfb02c99 (2.5.0+)\n                            __  __            _\n                         ___\\ \\/ /_ __   __ _| |_\n                        / _ \\\\  /| '_ \\ / _` | __|\n                       |  __//  \\| |_) | (_| | |_\n                        \\___/_/\\_\\ .__/ \\__,_|\\__|\n                                 |_| XML parser\n\n   Copyright (c) 1997-2000 Thai Open Source Software Center Ltd\n   Copyright (c) 2000      Clark Cooper <coopercc@users.sourceforge.net>\n   Copyright (c) 2000-2006 Fred L. Drake, Jr. <fdrake@users.sourceforge.net>\n   Copyright (c) 2001-2002 Greg Stein <gstein@users.sourceforge.net>\n   Copyright (c) 2002-2016 Karl Waclawek <karl@waclawek.net>\n   Copyright (c) 2005-2009 Steven Solie <steven@solie.ca>\n   Copyright (c) 2016      Eric Rahm <erahm@mozilla.com>\n   Copyright (c) 2016-2022 Sebastian Pipping <sebastian@pipping.org>\n   Copyright (c) 2016      Gaurav <g.gupta@samsung.com>\n   Copyright (c) 2016      Thomas Beutlich <tc@tbeu.de>\n   Copyright (c) 2016      Gustavo Grieco <gustavo.grieco@imag.fr>\n   Copyright (c) 2016      Pascal Cuoq <cuoq@trust-in-soft.com>\n   Copyright (c) 2016      Ed Schouten <ed@nuxi.nl>\n   Copyright (c) 2017-2022 Rhodri James <rhodri@wildebeest.org.uk>\n   Copyright (c) 2017      V\u00e1clav Slav\u00edk <vaclav@slavik.io>\n   Copyright (c) 2017      Viktor Szakats <commit@vsz.me>\n   Copyright (c) 2017      Chanho Park <chanho61.park@samsung.com>\n   Copyright (c) 2017      Rolf Eike Beer <eike@sf-mail.de>\n   Copyright (c) 2017      Hans Wennborg <hans@chromium.org>\n   Copyright (c) 2018      Anton Maklakov <antmak.pub@gmail.com>\n   Copyright (c) 2018      Benjamin Peterson <benjamin@python.org>\n   Copyright (c) 2018      Marco Maggi <marco.maggi-ipsu@poste.it>\n   Copyright (c) 2018      Mariusz Zaborski <oshogbo@vexillium.org>\n   Copyright (c) 2019      David Loffredo <loffredo@steptools.com>\n   Copyright (c) 2019-2020 Ben Wagner <bungeman@chromium.org>\n   Copyright (c) 2019      Vadim Zeitlin <vadim@zeitlins.org>\n   Copyright (c) 2021      Donghee Na <donghee.na@python.org>\n   Copyright (c) 2022      Samanta Navarro <ferivoz@riseup.net>\n   Copyright (c) 2022      Jeffrey Walton <noloader@gmail.com>\n   Copyright (c) 2022      Jann Horn <jannh@google.com>\n   Copyright (c) 2023      Sony Corporation / Snild Dolkow <snild@sony.com>\n   Licensed under the MIT license:\n\n   Permission is  hereby granted,  free of charge,  to any  person obtaining\n   a  copy  of  this  software   and  associated  documentation  files  (the\n   \"Software\"),  to  deal in  the  Software  without restriction,  including\n   without  limitation the  rights  to use,  copy,  modify, merge,  publish,\n   distribute, sublicense, and/or sell copies of the Software, and to permit\n   persons  to whom  the Software  is  furnished to  do so,  subject to  the\n   following conditions:\n\n   The above copyright  notice and this permission notice  shall be included\n   in all copies or substantial portions of the Software.\n\n   THE  SOFTWARE  IS  PROVIDED  \"AS  IS\",  WITHOUT  WARRANTY  OF  ANY  KIND,\n   EXPRESS  OR IMPLIED,  INCLUDING  BUT  NOT LIMITED  TO  THE WARRANTIES  OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n   NO EVENT SHALL THE AUTHORS OR  COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n   DAMAGES OR  OTHER LIABILITY, WHETHER  IN AN  ACTION OF CONTRACT,  TORT OR\n   OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n   USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#define XML_BUILDING_EXPAT 1\n\n#include \"expat_config.h\"\n\n#if ! defined(XML_CONTEXT_BYTES) || (1 - XML_CONTEXT_BYTES - 1 == 2)           \\\n    || (XML_CONTEXT_BYTES + 0 < 0)\n#  error XML_CONTEXT_BYTES must be defined, non-empty and >=0 (0 to disable, >=1 to enable; 1024 is a common default)\n#endif\n\n#if defined(HAVE_SYSCALL_GETRANDOM)\n#  if ! defined(_GNU_SOURCE)\n#    define _GNU_SOURCE 1 /* syscall prototype */\n#  endif\n#endif\n\n#ifdef _WIN32\n/* force stdlib to define rand_s() */\n#  if ! defined(_CRT_RAND_S)\n#    define _CRT_RAND_S\n#  endif\n#endif\n\n#include <stddef.h>\n#include <string.h> /* memset(), memcpy() */\n#include <assert.h>\n#include <limits.h> /* UINT_MAX */\n#include <stdio.h>  /* fprintf */\n#include <stdlib.h> /* getenv, rand_s */\n#include <stdint.h> /* uintptr_t */\n#include <math.h>   /* isnan */\n\n#ifdef _WIN32\n#  define getpid GetCurrentProcessId\n#else\n#  include <sys/time.h>  /* gettimeofday() */\n#  include <sys/types.h> /* getpid() */\n#  include <unistd.h>    /* getpid() */\n#  include <fcntl.h>     /* O_RDONLY */\n#  include <errno.h>\n#endif\n\n#ifdef _WIN32\n#  include \"winconfig.h\"\n#endif\n\n#include \"ascii.h\"\n#include \"expat.h\"\n#include \"siphash.h\"\n\n#if defined(HAVE_GETRANDOM) || defined(HAVE_SYSCALL_GETRANDOM)\n#  if defined(HAVE_GETRANDOM)\n#    include <sys/random.h> /* getrandom */\n#  else\n#    include <unistd.h>      /* syscall */\n#    include <sys/syscall.h> /* SYS_getrandom */\n#  endif\n#  if ! defined(GRND_NONBLOCK)\n#    define GRND_NONBLOCK 0x0001\n#  endif /* defined(GRND_NONBLOCK) */\n#endif   /* defined(HAVE_GETRANDOM) || defined(HAVE_SYSCALL_GETRANDOM) */\n\n#if defined(HAVE_LIBBSD)                                                       \\\n    && (defined(HAVE_ARC4RANDOM_BUF) || defined(HAVE_ARC4RANDOM))\n#  include <bsd/stdlib.h>\n#endif\n\n#if defined(_WIN32) && ! defined(LOAD_LIBRARY_SEARCH_SYSTEM32)\n#  define LOAD_LIBRARY_SEARCH_SYSTEM32 0x00000800\n#endif\n\n#if ! defined(HAVE_GETRANDOM) && ! defined(HAVE_SYSCALL_GETRANDOM)             \\\n    && ! defined(HAVE_ARC4RANDOM_BUF) && ! defined(HAVE_ARC4RANDOM)            \\\n    && ! defined(XML_DEV_URANDOM) && ! defined(_WIN32)                         \\\n    && ! defined(XML_POOR_ENTROPY)\n#  error You do not have support for any sources of high quality entropy \\\n    enabled.  For end user security, that is probably not what you want. \\\n    \\\n    Your options include: \\\n      * Linux >=3.17 + glibc >=2.25 (getrandom): HAVE_GETRANDOM, \\\n      * Linux >=3.17 + glibc (including <2.25) (syscall SYS_getrandom): HAVE_SYSCALL_GETRANDOM, \\\n      * BSD / macOS >=10.7 / glibc >=2.36 (arc4random_buf): HAVE_ARC4RANDOM_BUF, \\\n      * BSD / macOS (including <10.7) / glibc >=2.36 (arc4random): HAVE_ARC4RANDOM, \\\n      * libbsd (arc4random_buf): HAVE_ARC4RANDOM_BUF + HAVE_LIBBSD, \\\n      * libbsd (arc4random): HAVE_ARC4RANDOM + HAVE_LIBBSD, \\\n      * Linux (including <3.17) / BSD / macOS (including <10.7) / Solaris >=8 (/dev/urandom): XML_DEV_URANDOM, \\\n      * Windows >=Vista (rand_s): _WIN32. \\\n    \\\n    If insist on not using any of these, bypass this error by defining \\\n    XML_POOR_ENTROPY; you have been warned. \\\n    \\\n    If you have reasons to patch this detection code away or need changes \\\n    to the build system, please open a bug.  Thank you!\n#endif\n\n#ifdef XML_UNICODE\n#  define XML_ENCODE_MAX XML_UTF16_ENCODE_MAX\n#  define XmlConvert XmlUtf16Convert\n#  define XmlGetInternalEncoding XmlGetUtf16InternalEncoding\n#  define XmlGetInternalEncodingNS XmlGetUtf16InternalEncodingNS\n#  define XmlEncode XmlUtf16Encode\n#  define MUST_CONVERT(enc, s) (! (enc)->isUtf16 || (((uintptr_t)(s)) & 1))\ntypedef unsigned short ICHAR;\n#else\n#  define XML_ENCODE_MAX XML_UTF8_ENCODE_MAX\n#  define XmlConvert XmlUtf8Convert\n#  define XmlGetInternalEncoding XmlGetUtf8InternalEncoding\n#  define XmlGetInternalEncodingNS XmlGetUtf8InternalEncodingNS\n#  define XmlEncode XmlUtf8Encode\n#  define MUST_CONVERT(enc, s) (! (enc)->isUtf8)\ntypedef char ICHAR;\n#endif\n\n#ifndef XML_NS\n\n#  define XmlInitEncodingNS XmlInitEncoding\n#  define XmlInitUnknownEncodingNS XmlInitUnknownEncoding\n#  undef XmlGetInternalEncodingNS\n#  define XmlGetInternalEncodingNS XmlGetInternalEncoding\n#  define XmlParseXmlDeclNS XmlParseXmlDecl\n\n#endif\n\n#ifdef XML_UNICODE\n\n#  ifdef XML_UNICODE_WCHAR_T\n#    define XML_T(x) (const wchar_t) x\n#    define XML_L(x) L##x\n#  else\n#    define XML_T(x) (const unsigned short)x\n#    define XML_L(x) x\n#  endif\n\n#else\n\n#  define XML_T(x) x\n#  define XML_L(x) x\n\n#endif\n\n/* Round up n to be a multiple of sz, where sz is a power of 2. */\n#define ROUND_UP(n, sz) (((n) + ((sz)-1)) & ~((sz)-1))\n\n/* Do safe (NULL-aware) pointer arithmetic */\n#define EXPAT_SAFE_PTR_DIFF(p, q) (((p) && (q)) ? ((p) - (q)) : 0)\n\n#include \"internal.h\"\n#include \"xmltok.h\"\n#include \"xmlrole.h\"\n\ntypedef const XML_Char *KEY;\n\ntypedef struct {\n  KEY name;\n} NAMED;\n\ntypedef struct {\n  NAMED **v;\n  unsigned char power;\n  size_t size;\n  size_t used;\n  const XML_Memory_Handling_Suite *mem;\n} HASH_TABLE;\n\nstatic size_t keylen(KEY s);\n\nstatic void copy_salt_to_sipkey(XML_Parser parser, struct sipkey *key);\n\n/* For probing (after a collision) we need a step size relative prime\n   to the hash table size, which is a power of 2. We use double-hashing,\n   since we can calculate a second hash value cheaply by taking those bits\n   of the first hash value that were discarded (masked out) when the table\n   index was calculated: index = hash & mask, where mask = table->size - 1.\n   We limit the maximum step size to table->size / 4 (mask >> 2) and make\n   it odd, since odd numbers are always relative prime to a power of 2.\n*/\n#define SECOND_HASH(hash, mask, power)                                         \\\n  ((((hash) & ~(mask)) >> ((power)-1)) & ((mask) >> 2))\n#define PROBE_STEP(hash, mask, power)                                          \\\n  ((unsigned char)((SECOND_HASH(hash, mask, power)) | 1))\n\ntypedef struct {\n  NAMED **p;\n  NAMED **end;\n} HASH_TABLE_ITER;\n\n#define INIT_TAG_BUF_SIZE 32 /* must be a multiple of sizeof(XML_Char) */\n#define INIT_DATA_BUF_SIZE 1024\n#define INIT_ATTS_SIZE 16\n#define INIT_ATTS_VERSION 0xFFFFFFFF\n#define INIT_BLOCK_SIZE 1024\n#define INIT_BUFFER_SIZE 1024\n\n#define EXPAND_SPARE 24\n\ntypedef struct binding {\n  struct prefix *prefix;\n  struct binding *nextTagBinding;\n  struct binding *prevPrefixBinding;\n  const struct attribute_id *attId;\n  XML_Char *uri;\n  int uriLen;\n  int uriAlloc;\n} BINDING;\n\ntypedef struct prefix {\n  const XML_Char *name;\n  BINDING *binding;\n} PREFIX;\n\ntypedef struct {\n  const XML_Char *str;\n  const XML_Char *localPart;\n  const XML_Char *prefix;\n  int strLen;\n  int uriLen;\n  int prefixLen;\n} TAG_NAME;\n\n/* TAG represents an open element.\n   The name of the element is stored in both the document and API\n   encodings.  The memory buffer 'buf' is a separately-allocated\n   memory area which stores the name.  During the XML_Parse()/\n   XMLParseBuffer() when the element is open, the memory for the 'raw'\n   version of the name (in the document encoding) is shared with the\n   document buffer.  If the element is open across calls to\n   XML_Parse()/XML_ParseBuffer(), the buffer is re-allocated to\n   contain the 'raw' name as well.\n\n   A parser reuses these structures, maintaining a list of allocated\n   TAG objects in a free list.\n*/\ntypedef struct tag {\n  struct tag *parent;  /* parent of this element */\n  const char *rawName; /* tagName in the original encoding */\n  int rawNameLength;\n  TAG_NAME name; /* tagName in the API encoding */\n  char *buf;     /* buffer for name components */\n  char *bufEnd;  /* end of the buffer */\n  BINDING *bindings;\n} TAG;\n\ntypedef struct {\n  const XML_Char *name;\n  const XML_Char *textPtr;\n  int textLen;   /* length in XML_Chars */\n  int processed; /* # of processed bytes - when suspended */\n  const XML_Char *systemId;\n  const XML_Char *base;\n  const XML_Char *publicId;\n  const XML_Char *notation;\n  XML_Bool open;\n  XML_Bool is_param;\n  XML_Bool is_internal; /* true if declared in internal subset outside PE */\n} ENTITY;\n\ntypedef struct {\n  enum XML_Content_Type type;\n  enum XML_Content_Quant quant;\n  const XML_Char *name;\n  int firstchild;\n  int lastchild;\n  int childcnt;\n  int nextsib;\n} CONTENT_SCAFFOLD;\n\n#define INIT_SCAFFOLD_ELEMENTS 32\n\ntypedef struct block {\n  struct block *next;\n  int size;\n  XML_Char s[1];\n} BLOCK;\n\ntypedef struct {\n  BLOCK *blocks;\n  BLOCK *freeBlocks;\n  const XML_Char *end;\n  XML_Char *ptr;\n  XML_Char *start;\n  const XML_Memory_Handling_Suite *mem;\n} STRING_POOL;\n\n/* The XML_Char before the name is used to determine whether\n   an attribute has been specified. */\ntypedef struct attribute_id {\n  XML_Char *name;\n  PREFIX *prefix;\n  XML_Bool maybeTokenized;\n  XML_Bool xmlns;\n} ATTRIBUTE_ID;\n\ntypedef struct {\n  const ATTRIBUTE_ID *id;\n  XML_Bool isCdata;\n  const XML_Char *value;\n} DEFAULT_ATTRIBUTE;\n\ntypedef struct {\n  unsigned long version;\n  unsigned long hash;\n  const XML_Char *uriName;\n} NS_ATT;\n\ntypedef struct {\n  const XML_Char *name;\n  PREFIX *prefix;\n  const ATTRIBUTE_ID *idAtt;\n  int nDefaultAtts;\n  int allocDefaultAtts;\n  DEFAULT_ATTRIBUTE *defaultAtts;\n} ELEMENT_TYPE;\n\ntypedef struct {\n  HASH_TABLE generalEntities;\n  HASH_TABLE elementTypes;\n  HASH_TABLE attributeIds;\n  HASH_TABLE prefixes;\n  STRING_POOL pool;\n  STRING_POOL entityValuePool;\n  /* false once a parameter entity reference has been skipped */\n  XML_Bool keepProcessing;\n  /* true once an internal or external PE reference has been encountered;\n     this includes the reference to an external subset */\n  XML_Bool hasParamEntityRefs;\n  XML_Bool standalone;\n#ifdef XML_DTD\n  /* indicates if external PE has been read */\n  XML_Bool paramEntityRead;\n  HASH_TABLE paramEntities;\n#endif /* XML_DTD */\n  PREFIX defaultPrefix;\n  /* === scaffolding for building content model === */\n  XML_Bool in_eldecl;\n  CONTENT_SCAFFOLD *scaffold;\n  unsigned contentStringLen;\n  unsigned scaffSize;\n  unsigned scaffCount;\n  int scaffLevel;\n  int *scaffIndex;\n} DTD;\n\ntypedef struct open_internal_entity {\n  const char *internalEventPtr;\n  const char *internalEventEndPtr;\n  struct open_internal_entity *next;\n  ENTITY *entity;\n  int startTagLevel;\n  XML_Bool betweenDecl; /* WFC: PE Between Declarations */\n} OPEN_INTERNAL_ENTITY;\n\nenum XML_Account {\n  XML_ACCOUNT_DIRECT,           /* bytes directly passed to the Expat parser */\n  XML_ACCOUNT_ENTITY_EXPANSION, /* intermediate bytes produced during entity\n                                   expansion */\n  XML_ACCOUNT_NONE              /* i.e. do not account, was accounted already */\n};\n\n#if defined(XML_DTD) || XML_GE == 1\ntypedef unsigned long long XmlBigCount;\ntypedef struct accounting {\n  XmlBigCount countBytesDirect;\n  XmlBigCount countBytesIndirect;\n  unsigned long debugLevel;\n  float maximumAmplificationFactor; // >=1.0\n  unsigned long long activationThresholdBytes;\n} ACCOUNTING;\n\ntypedef struct entity_stats {\n  unsigned int countEverOpened;\n  unsigned int currentDepth;\n  unsigned int maximumDepthSeen;\n  unsigned long debugLevel;\n} ENTITY_STATS;\n#endif /* defined(XML_DTD) || XML_GE == 1 */\n\ntypedef enum XML_Error PTRCALL Processor(XML_Parser parser, const char *start,\n                                         const char *end, const char **endPtr);\n\nstatic Processor prologProcessor;\nstatic Processor prologInitProcessor;\nstatic Processor contentProcessor;\nstatic Processor cdataSectionProcessor;\n#ifdef XML_DTD\nstatic Processor ignoreSectionProcessor;\nstatic Processor externalParEntProcessor;\nstatic Processor externalParEntInitProcessor;\nstatic Processor entityValueProcessor;\nstatic Processor entityValueInitProcessor;\n#endif /* XML_DTD */\nstatic Processor epilogProcessor;\nstatic Processor errorProcessor;\nstatic Processor externalEntityInitProcessor;\nstatic Processor externalEntityInitProcessor2;\nstatic Processor externalEntityInitProcessor3;\nstatic Processor externalEntityContentProcessor;\nstatic Processor internalEntityProcessor;\n\nstatic enum XML_Error handleUnknownEncoding(XML_Parser parser,\n                                            const XML_Char *encodingName);\nstatic enum XML_Error processXmlDecl(XML_Parser parser, int isGeneralTextEntity,\n                                     const char *s, const char *next);\nstatic enum XML_Error initializeEncoding(XML_Parser parser);\nstatic enum XML_Error doProlog(XML_Parser parser, const ENCODING *enc,\n                               const char *s, const char *end, int tok,\n                               const char *next, const char **nextPtr,\n                               XML_Bool haveMore, XML_Bool allowClosingDoctype,\n                               enum XML_Account account);\nstatic enum XML_Error processInternalEntity(XML_Parser parser, ENTITY *entity,\n                                            XML_Bool betweenDecl);\nstatic enum XML_Error doContent(XML_Parser parser, int startTagLevel,\n                                const ENCODING *enc, const char *start,\n                                const char *end, const char **endPtr,\n                                XML_Bool haveMore, enum XML_Account account);\nstatic enum XML_Error doCdataSection(XML_Parser parser, const ENCODING *,\n                                     const char **startPtr, const char *end,\n                                     const char **nextPtr, XML_Bool haveMore,\n                                     enum XML_Account account);\n#ifdef XML_DTD\nstatic enum XML_Error doIgnoreSection(XML_Parser parser, const ENCODING *,\n                                      const char **startPtr, const char *end,\n                                      const char **nextPtr, XML_Bool haveMore);\n#endif /* XML_DTD */\n\nstatic void freeBindings(XML_Parser parser, BINDING *bindings);\nstatic enum XML_Error storeAtts(XML_Parser parser, const ENCODING *,\n                                const char *s, TAG_NAME *tagNamePtr,\n                                BINDING **bindingsPtr,\n                                enum XML_Account account);\nstatic enum XML_Error addBinding(XML_Parser parser, PREFIX *prefix,\n                                 const ATTRIBUTE_ID *attId, const XML_Char *uri,\n                                 BINDING **bindingsPtr);\nstatic int defineAttribute(ELEMENT_TYPE *type, ATTRIBUTE_ID *, XML_Bool isCdata,\n                           XML_Bool isId, const XML_Char *dfltValue,\n                           XML_Parser parser);\nstatic enum XML_Error storeAttributeValue(XML_Parser parser, const ENCODING *,\n                                          XML_Bool isCdata, const char *,\n                                          const char *, STRING_POOL *,\n                                          enum XML_Account account);\nstatic enum XML_Error appendAttributeValue(XML_Parser parser, const ENCODING *,\n                                           XML_Bool isCdata, const char *,\n                                           const char *, STRING_POOL *,\n                                           enum XML_Account account);\nstatic ATTRIBUTE_ID *getAttributeId(XML_Parser parser, const ENCODING *enc,\n                                    const char *start, const char *end);\nstatic int setElementTypePrefix(XML_Parser parser, ELEMENT_TYPE *);\nstatic enum XML_Error storeEntityValue(XML_Parser parser, const ENCODING *enc,\n                                       const char *start, const char *end,\n                                       enum XML_Account account);\nstatic int reportProcessingInstruction(XML_Parser parser, const ENCODING *enc,\n                                       const char *start, const char *end);\nstatic int reportComment(XML_Parser parser, const ENCODING *enc,\n                         const char *start, const char *end);\nstatic void reportDefault(XML_Parser parser, const ENCODING *enc,\n                          const char *start, const char *end);\n\nstatic const XML_Char *getContext(XML_Parser parser);\nstatic XML_Bool setContext(XML_Parser parser, const XML_Char *context);\n\nstatic void FASTCALL normalizePublicId(XML_Char *s);\n\nstatic DTD *dtdCreate(const XML_Memory_Handling_Suite *ms);\n/* do not call if m_parentParser != NULL */\nstatic void dtdReset(DTD *p, const XML_Memory_Handling_Suite *ms);\nstatic void dtdDestroy(DTD *p, XML_Bool isDocEntity,\n                       const XML_Memory_Handling_Suite *ms);\nstatic int dtdCopy(XML_Parser oldParser, DTD *newDtd, const DTD *oldDtd,\n                   const XML_Memory_Handling_Suite *ms);\nstatic int copyEntityTable(XML_Parser oldParser, HASH_TABLE *, STRING_POOL *,\n                           const HASH_TABLE *);\nstatic NAMED *lookup(XML_Parser parser, HASH_TABLE *table, KEY name,\n                     size_t createSize);\nstatic void FASTCALL hashTableInit(HASH_TABLE *,\n                                   const XML_Memory_Handling_Suite *ms);\nstatic void FASTCALL hashTableClear(HASH_TABLE *);\nstatic void FASTCALL hashTableDestroy(HASH_TABLE *);\nstatic void FASTCALL hashTableIterInit(HASH_TABLE_ITER *, const HASH_TABLE *);\nstatic NAMED *FASTCALL hashTableIterNext(HASH_TABLE_ITER *);\n\nstatic void FASTCALL poolInit(STRING_POOL *,\n                              const XML_Memory_Handling_Suite *ms);\nstatic void FASTCALL poolClear(STRING_POOL *);\nstatic void FASTCALL poolDestroy(STRING_POOL *);\nstatic XML_Char *poolAppend(STRING_POOL *pool, const ENCODING *enc,\n                            const char *ptr, const char *end);\nstatic XML_Char *poolStoreString(STRING_POOL *pool, const ENCODING *enc,\n                                 const char *ptr, const char *end);\nstatic XML_Bool FASTCALL poolGrow(STRING_POOL *pool);\nstatic const XML_Char *FASTCALL poolCopyString(STRING_POOL *pool,\n                                               const XML_Char *s);\nstatic const XML_Char *poolCopyStringN(STRING_POOL *pool, const XML_Char *s,\n                                       int n);\nstatic const XML_Char *FASTCALL poolAppendString(STRING_POOL *pool,\n                                                 const XML_Char *s);\n\nstatic int FASTCALL nextScaffoldPart(XML_Parser parser);\nstatic XML_Content *build_model(XML_Parser parser);\nstatic ELEMENT_TYPE *getElementType(XML_Parser parser, const ENCODING *enc,\n                                    const char *ptr, const char *end);\n\nstatic XML_Char *copyString(const XML_Char *s,\n                            const XML_Memory_Handling_Suite *memsuite);\n\nstatic unsigned long generate_hash_secret_salt(XML_Parser parser);\nstatic XML_Bool startParsing(XML_Parser parser);\n\nstatic XML_Parser parserCreate(const XML_Char *encodingName,\n                               const XML_Memory_Handling_Suite *memsuite,\n                               const XML_Char *nameSep, DTD *dtd);\n\nstatic void parserInit(XML_Parser parser, const XML_Char *encodingName);\n\n#if defined(XML_DTD) || XML_GE == 1\nstatic float accountingGetCurrentAmplification(XML_Parser rootParser);\nstatic void accountingReportStats(XML_Parser originParser, const char *epilog);\nstatic void accountingOnAbort(XML_Parser originParser);\nstatic void accountingReportDiff(XML_Parser rootParser,\n                                 unsigned int levelsAwayFromRootParser,\n                                 const char *before, const char *after,\n                                 ptrdiff_t bytesMore, int source_line,\n                                 enum XML_Account account);\nstatic XML_Bool accountingDiffTolerated(XML_Parser originParser, int tok,\n                                        const char *before, const char *after,\n                                        int source_line,\n                                        enum XML_Account account);\n\nstatic void entityTrackingReportStats(XML_Parser parser, ENTITY *entity,\n                                      const char *action, int sourceLine);\nstatic void entityTrackingOnOpen(XML_Parser parser, ENTITY *entity,\n                                 int sourceLine);\nstatic void entityTrackingOnClose(XML_Parser parser, ENTITY *entity,\n                                  int sourceLine);\n\nstatic XML_Parser getRootParserOf(XML_Parser parser,\n                                  unsigned int *outLevelDiff);\n#endif /* defined(XML_DTD) || XML_GE == 1 */\n\nstatic unsigned long getDebugLevel(const char *variableName,\n                                   unsigned long defaultDebugLevel);\n\n#define poolStart(pool) ((pool)->start)\n#define poolLength(pool) ((pool)->ptr - (pool)->start)\n#define poolChop(pool) ((void)--(pool->ptr))\n#define poolLastChar(pool) (((pool)->ptr)[-1])\n#define poolDiscard(pool) ((pool)->ptr = (pool)->start)\n#define poolFinish(pool) ((pool)->start = (pool)->ptr)\n#define poolAppendChar(pool, c)                                                \\\n  (((pool)->ptr == (pool)->end && ! poolGrow(pool))                            \\\n       ? 0                                                                     \\\n       : ((*((pool)->ptr)++ = c), 1))\n\nstruct XML_ParserStruct {\n  /* The first member must be m_userData so that the XML_GetUserData\n     macro works. */\n  void *m_userData;\n  void *m_handlerArg;\n\n  // How the four parse buffer pointers below relate in time and space:\n  //\n  //   m_buffer <= m_bufferPtr <= m_bufferEnd  <= m_bufferLim\n  //   |           |              |               |\n  //   <--parsed-->|              |               |\n  //               <---parsing--->|               |\n  //                              <--unoccupied-->|\n  //   <---------total-malloced/realloced-------->|\n\n  char *m_buffer; // malloc/realloc base pointer of parse buffer\n  const XML_Memory_Handling_Suite m_mem;\n  const char *m_bufferPtr; // first character to be parsed\n  char *m_bufferEnd;       // past last character to be parsed\n  const char *m_bufferLim; // allocated end of m_buffer\n\n  XML_Index m_parseEndByteIndex;\n  const char *m_parseEndPtr;\n  XML_Char *m_dataBuf;\n  XML_Char *m_dataBufEnd;\n  XML_StartElementHandler m_startElementHandler;\n  XML_EndElementHandler m_endElementHandler;\n  XML_CharacterDataHandler m_characterDataHandler;\n  XML_ProcessingInstructionHandler m_processingInstructionHandler;\n  XML_CommentHandler m_commentHandler;\n  XML_StartCdataSectionHandler m_startCdataSectionHandler;\n  XML_EndCdataSectionHandler m_endCdataSectionHandler;\n  XML_DefaultHandler m_defaultHandler;\n  XML_StartDoctypeDeclHandler m_startDoctypeDeclHandler;\n  XML_EndDoctypeDeclHandler m_endDoctypeDeclHandler;\n  XML_UnparsedEntityDeclHandler m_unparsedEntityDeclHandler;\n  XML_NotationDeclHandler m_notationDeclHandler;\n  XML_StartNamespaceDeclHandler m_startNamespaceDeclHandler;\n  XML_EndNamespaceDeclHandler m_endNamespaceDeclHandler;\n  XML_NotStandaloneHandler m_notStandaloneHandler;\n  XML_ExternalEntityRefHandler m_externalEntityRefHandler;\n  XML_Parser m_externalEntityRefHandlerArg;\n  XML_SkippedEntityHandler m_skippedEntityHandler;\n  XML_UnknownEncodingHandler m_unknownEncodingHandler;\n  XML_ElementDeclHandler m_elementDeclHandler;\n  XML_AttlistDeclHandler m_attlistDeclHandler;\n  XML_EntityDeclHandler m_entityDeclHandler;\n  XML_XmlDeclHandler m_xmlDeclHandler;\n  const ENCODING *m_encoding;\n  INIT_ENCODING m_initEncoding;\n  const ENCODING *m_internalEncoding;\n  const XML_Char *m_protocolEncodingName;\n  XML_Bool m_ns;\n  XML_Bool m_ns_triplets;\n  void *m_unknownEncodingMem;\n  void *m_unknownEncodingData;\n  void *m_unknownEncodingHandlerData;\n  void(XMLCALL *m_unknownEncodingRelease)(void *);\n  PROLOG_STATE m_prologState;\n  Processor *m_processor;\n  enum XML_Error m_errorCode;\n  const char *m_eventPtr;\n  const char *m_eventEndPtr;\n  const char *m_positionPtr;\n  OPEN_INTERNAL_ENTITY *m_openInternalEntities;\n  OPEN_INTERNAL_ENTITY *m_freeInternalEntities;\n  XML_Bool m_defaultExpandInternalEntities;\n  int m_tagLevel;\n  ENTITY *m_declEntity;\n  const XML_Char *m_doctypeName;\n  const XML_Char *m_doctypeSysid;\n  const XML_Char *m_doctypePubid;\n  const XML_Char *m_declAttributeType;\n  const XML_Char *m_declNotationName;\n  const XML_Char *m_declNotationPublicId;\n  ELEMENT_TYPE *m_declElementType;\n  ATTRIBUTE_ID *m_declAttributeId;\n  XML_Bool m_declAttributeIsCdata;\n  XML_Bool m_declAttributeIsId;\n  DTD *m_dtd;\n  const XML_Char *m_curBase;\n  TAG *m_tagStack;\n  TAG *m_freeTagList;\n  BINDING *m_inheritedBindings;\n  BINDING *m_freeBindingList;\n  int m_attsSize;\n  int m_nSpecifiedAtts;\n  int m_idAttIndex;\n  ATTRIBUTE *m_atts;\n  NS_ATT *m_nsAtts;\n  unsigned long m_nsAttsVersion;\n  unsigned char m_nsAttsPower;\n#ifdef XML_ATTR_INFO\n  XML_AttrInfo *m_attInfo;\n#endif\n  POSITION m_position;\n  STRING_POOL m_tempPool;\n  STRING_POOL m_temp2Pool;\n  char *m_groupConnector;\n  unsigned int m_groupSize;\n  XML_Char m_namespaceSeparator;\n  XML_Parser m_parentParser;\n  XML_ParsingStatus m_parsingStatus;\n#ifdef XML_DTD\n  XML_Bool m_isParamEntity;\n  XML_Bool m_useForeignDTD;\n  enum XML_ParamEntityParsing m_paramEntityParsing;\n#endif\n  unsigned long m_hash_secret_salt;\n#if defined(XML_DTD) || XML_GE == 1\n  ACCOUNTING m_accounting;\n  ENTITY_STATS m_entity_stats;\n#endif\n};\n\n#define MALLOC(parser, s) (parser->m_mem.malloc_fcn((s)))\n#define REALLOC(parser, p, s) (parser->m_mem.realloc_fcn((p), (s)))\n#define FREE(parser, p) (parser->m_mem.free_fcn((p)))\n\nXML_Parser XMLCALL\nXML_ParserCreate(const XML_Char *encodingName) {\n  return XML_ParserCreate_MM(encodingName, NULL, NULL);\n}\n\nXML_Parser XMLCALL\nXML_ParserCreateNS(const XML_Char *encodingName, XML_Char nsSep) {\n  XML_Char tmp[2] = {nsSep, 0};\n  return XML_ParserCreate_MM(encodingName, NULL, tmp);\n}\n\n// \"xml=http://www.w3.org/XML/1998/namespace\"\nstatic const XML_Char implicitContext[]\n    = {ASCII_x,     ASCII_m,     ASCII_l,      ASCII_EQUALS, ASCII_h,\n       ASCII_t,     ASCII_t,     ASCII_p,      ASCII_COLON,  ASCII_SLASH,\n       ASCII_SLASH, ASCII_w,     ASCII_w,      ASCII_w,      ASCII_PERIOD,\n       ASCII_w,     ASCII_3,     ASCII_PERIOD, ASCII_o,      ASCII_r,\n       ASCII_g,     ASCII_SLASH, ASCII_X,      ASCII_M,      ASCII_L,\n       ASCII_SLASH, ASCII_1,     ASCII_9,      ASCII_9,      ASCII_8,\n       ASCII_SLASH, ASCII_n,     ASCII_a,      ASCII_m,      ASCII_e,\n       ASCII_s,     ASCII_p,     ASCII_a,      ASCII_c,      ASCII_e,\n       '\\0'};\n\n/* To avoid warnings about unused functions: */\n#if ! defined(HAVE_ARC4RANDOM_BUF) && ! defined(HAVE_ARC4RANDOM)\n\n#  if defined(HAVE_GETRANDOM) || defined(HAVE_SYSCALL_GETRANDOM)\n\n/* Obtain entropy on Linux 3.17+ */\nstatic int\nwriteRandomBytes_getrandom_nonblock(void *target, size_t count) {\n  int success = 0; /* full count bytes written? */\n  size_t bytesWrittenTotal = 0;\n  const unsigned int getrandomFlags = GRND_NONBLOCK;\n\n  do {\n    void *const currentTarget = (void *)((char *)target + bytesWrittenTotal);\n    const size_t bytesToWrite = count - bytesWrittenTotal;\n\n    const int bytesWrittenMore =\n#    if defined(HAVE_GETRANDOM)\n        getrandom(currentTarget, bytesToWrite, getrandomFlags);\n#    else\n        syscall(SYS_getrandom, currentTarget, bytesToWrite, getrandomFlags);\n#    endif\n\n    if (bytesWrittenMore > 0) {\n      bytesWrittenTotal += bytesWrittenMore;\n      if (bytesWrittenTotal >= count)\n        success = 1;\n    }\n  } while (! success && (errno == EINTR));\n\n  return success;\n}\n\n#  endif /* defined(HAVE_GETRANDOM) || defined(HAVE_SYSCALL_GETRANDOM) */\n\n#  if ! defined(_WIN32) && defined(XML_DEV_URANDOM)\n\n/* Extract entropy from /dev/urandom */\nstatic int\nwriteRandomBytes_dev_urandom(void *target, size_t count) {\n  int success = 0; /* full count bytes written? */\n  size_t bytesWrittenTotal = 0;\n\n  const int fd = open(\"/dev/urandom\", O_RDONLY);\n  if (fd < 0) {\n    return 0;\n  }\n\n  do {\n    void *const currentTarget = (void *)((char *)target + bytesWrittenTotal);\n    const size_t bytesToWrite = count - bytesWrittenTotal;\n\n    const ssize_t bytesWrittenMore = read(fd, currentTarget, bytesToWrite);\n\n    if (bytesWrittenMore > 0) {\n      bytesWrittenTotal += bytesWrittenMore;\n      if (bytesWrittenTotal >= count)\n        success = 1;\n    }\n  } while (! success && (errno == EINTR));\n\n  close(fd);\n  return success;\n}\n\n#  endif /* ! defined(_WIN32) && defined(XML_DEV_URANDOM) */\n\n#endif /* ! defined(HAVE_ARC4RANDOM_BUF) && ! defined(HAVE_ARC4RANDOM) */\n\n#if defined(HAVE_ARC4RANDOM) && ! defined(HAVE_ARC4RANDOM_BUF)\n\nstatic void\nwriteRandomBytes_arc4random(void *target, size_t count) {\n  size_t bytesWrittenTotal = 0;\n\n  while (bytesWrittenTotal < count) {\n    const uint32_t random32 = arc4random();\n    size_t i = 0;\n\n    for (; (i < sizeof(random32)) && (bytesWrittenTotal < count);\n         i++, bytesWrittenTotal++) {\n      const uint8_t random8 = (uint8_t)(random32 >> (i * 8));\n      ((uint8_t *)target)[bytesWrittenTotal] = random8;\n    }\n  }\n}\n\n#endif /* defined(HAVE_ARC4RANDOM) && ! defined(HAVE_ARC4RANDOM_BUF) */\n\n#ifdef _WIN32\n\n/* Provide declaration of rand_s() for MinGW-32 (not 64, which has it),\n   as it didn't declare it in its header prior to version 5.3.0 of its\n   runtime package (mingwrt, containing stdlib.h).  The upstream fix\n   was introduced at https://osdn.net/projects/mingw/ticket/39658 . */\n#  if defined(__MINGW32__) && defined(__MINGW32_VERSION)                       \\\n      && __MINGW32_VERSION < 5003000L && ! defined(__MINGW64_VERSION_MAJOR)\n__declspec(dllimport) int rand_s(unsigned int *);\n#  endif\n\n/* Obtain entropy on Windows using the rand_s() function which\n * generates cryptographically secure random numbers.  Internally it\n * uses RtlGenRandom API which is present in Windows XP and later.\n */\nstatic int\nwriteRandomBytes_rand_s(void *target, size_t count) {\n  size_t bytesWrittenTotal = 0;\n\n  while (bytesWrittenTotal < count) {\n    unsigned int random32 = 0;\n    size_t i = 0;\n\n    if (rand_s(&random32))\n      return 0; /* failure */\n\n    for (; (i < sizeof(random32)) && (bytesWrittenTotal < count);\n         i++, bytesWrittenTotal++) {\n      const uint8_t random8 = (uint8_t)(random32 >> (i * 8));\n      ((uint8_t *)target)[bytesWrittenTotal] = random8;\n    }\n  }\n  return 1; /* success */\n}\n\n#endif /* _WIN32 */\n\n#if ! defined(HAVE_ARC4RANDOM_BUF) && ! defined(HAVE_ARC4RANDOM)\n\nstatic unsigned long\ngather_time_entropy(void) {\n#  ifdef _WIN32\n  FILETIME ft;\n  GetSystemTimeAsFileTime(&ft); /* never fails */\n  return ft.dwHighDateTime ^ ft.dwLowDateTime;\n#  else\n  struct timeval tv;\n  int gettimeofday_res;\n\n  gettimeofday_res = gettimeofday(&tv, NULL);\n\n#    if defined(NDEBUG)\n  (void)gettimeofday_res;\n#    else\n  assert(gettimeofday_res == 0);\n#    endif /* defined(NDEBUG) */\n\n  /* Microseconds time is <20 bits entropy */\n  return tv.tv_usec;\n#  endif\n}\n\n#endif /* ! defined(HAVE_ARC4RANDOM_BUF) && ! defined(HAVE_ARC4RANDOM) */\n\nstatic unsigned long\nENTROPY_DEBUG(const char *label, unsigned long entropy) {\n  if (getDebugLevel(\"EXPAT_ENTROPY_DEBUG\", 0) >= 1u) {\n    fprintf(stderr, \"expat: Entropy: %s --> 0x%0*lx (%lu bytes)\\n\", label,\n            (int)sizeof(entropy) * 2, entropy, (unsigned long)sizeof(entropy));\n  }\n  return entropy;\n}\n\nstatic unsigned long\ngenerate_hash_secret_salt(XML_Parser parser) {\n  unsigned long entropy;\n  (void)parser;\n\n  /* \"Failproof\" high quality providers: */\n#if defined(HAVE_ARC4RANDOM_BUF)\n  arc4random_buf(&entropy, sizeof(entropy));\n  return ENTROPY_DEBUG(\"arc4random_buf\", entropy);\n#elif defined(HAVE_ARC4RANDOM)\n  writeRandomBytes_arc4random((void *)&entropy, sizeof(entropy));\n  return ENTROPY_DEBUG(\"arc4random\", entropy);\n#else\n  /* Try high quality providers first .. */\n#  ifdef _WIN32\n  if (writeRandomBytes_rand_s((void *)&entropy, sizeof(entropy))) {\n    return ENTROPY_DEBUG(\"rand_s\", entropy);\n  }\n#  elif defined(HAVE_GETRANDOM) || defined(HAVE_SYSCALL_GETRANDOM)\n  if (writeRandomBytes_getrandom_nonblock((void *)&entropy, sizeof(entropy))) {\n    return ENTROPY_DEBUG(\"getrandom\", entropy);\n  }\n#  endif\n#  if ! defined(_WIN32) && defined(XML_DEV_URANDOM)\n  if (writeRandomBytes_dev_urandom((void *)&entropy, sizeof(entropy))) {\n    return ENTROPY_DEBUG(\"/dev/urandom\", entropy);\n  }\n#  endif /* ! defined(_WIN32) && defined(XML_DEV_URANDOM) */\n  /* .. and self-made low quality for backup: */\n\n  /* Process ID is 0 bits entropy if attacker has local access */\n  entropy = gather_time_entropy() ^ getpid();\n\n  /* Factors are 2^31-1 and 2^61-1 (Mersenne primes M31 and M61) */\n  if (sizeof(unsigned long) == 4) {\n    return ENTROPY_DEBUG(\"fallback(4)\", entropy * 2147483647);\n  } else {\n    return ENTROPY_DEBUG(\"fallback(8)\",\n                         entropy * (unsigned long)2305843009213693951ULL);\n  }\n#endif\n}\n\nstatic unsigned long\nget_hash_secret_salt(XML_Parser parser) {\n  if (parser->m_parentParser != NULL)\n    return get_hash_secret_salt(parser->m_parentParser);\n  return parser->m_hash_secret_salt;\n}\n\nstatic XML_Bool /* only valid for root parser */\nstartParsing(XML_Parser parser) {\n  /* hash functions must be initialized before setContext() is called */\n  if (parser->m_hash_secret_salt == 0)\n    parser->m_hash_secret_salt = generate_hash_secret_salt(parser);\n  if (parser->m_ns) {\n    /* implicit context only set for root parser, since child\n       parsers (i.e. external entity parsers) will inherit it\n    */\n    return setContext(parser, implicitContext);\n  }\n  return XML_TRUE;\n}\n\nXML_Parser XMLCALL\nXML_ParserCreate_MM(const XML_Char *encodingName,\n                    const XML_Memory_Handling_Suite *memsuite,\n                    const XML_Char *nameSep) {\n  return parserCreate(encodingName, memsuite, nameSep, NULL);\n}\n\nstatic XML_Parser\nparserCreate(const XML_Char *encodingName,\n             const XML_Memory_Handling_Suite *memsuite, const XML_Char *nameSep,\n             DTD *dtd) {\n  XML_Parser parser;\n\n  if (memsuite) {\n    XML_Memory_Handling_Suite *mtemp;\n    parser = memsuite->malloc_fcn(sizeof(struct XML_ParserStruct));\n    if (parser != NULL) {\n      mtemp = (XML_Memory_Handling_Suite *)&(parser->m_mem);\n      mtemp->malloc_fcn = memsuite->malloc_fcn;\n      mtemp->realloc_fcn = memsuite->realloc_fcn;\n      mtemp->free_fcn = memsuite->free_fcn;\n    }\n  } else {\n    XML_Memory_Handling_Suite *mtemp;\n    parser = (XML_Parser)malloc(sizeof(struct XML_ParserStruct));\n    if (parser != NULL) {\n      mtemp = (XML_Memory_Handling_Suite *)&(parser->m_mem);\n      mtemp->malloc_fcn = malloc;\n      mtemp->realloc_fcn = realloc;\n      mtemp->free_fcn = free;\n    }\n  }\n\n  if (! parser)\n    return parser;\n\n  parser->m_buffer = NULL;\n  parser->m_bufferLim = NULL;\n\n  parser->m_attsSize = INIT_ATTS_SIZE;\n  parser->m_atts\n      = (ATTRIBUTE *)MALLOC(parser, parser->m_attsSize * sizeof(ATTRIBUTE));\n  if (parser->m_atts == NULL) {\n    FREE(parser, parser);\n    return NULL;\n  }\n#ifdef XML_ATTR_INFO\n  parser->m_attInfo = (XML_AttrInfo *)MALLOC(\n      parser, parser->m_attsSize * sizeof(XML_AttrInfo));\n  if (parser->m_attInfo == NULL) {\n    FREE(parser, parser->m_atts);\n    FREE(parser, parser);\n    return NULL;\n  }\n#endif\n  parser->m_dataBuf\n      = (XML_Char *)MALLOC(parser, INIT_DATA_BUF_SIZE * sizeof(XML_Char));\n  if (parser->m_dataBuf == NULL) {\n    FREE(parser, parser->m_atts);\n#ifdef XML_ATTR_INFO\n    FREE(parser, parser->m_attInfo);\n#endif\n    FREE(parser, parser);\n    return NULL;\n  }\n  parser->m_dataBufEnd = parser->m_dataBuf + INIT_DATA_BUF_SIZE;\n\n  if (dtd)\n    parser->m_dtd = dtd;\n  else {\n    parser->m_dtd = dtdCreate(&parser->m_mem);\n    if (parser->m_dtd == NULL) {\n      FREE(parser, parser->m_dataBuf);\n      FREE(parser, parser->m_atts);\n#ifdef XML_ATTR_INFO\n      FREE(parser, parser->m_attInfo);\n#endif\n      FREE(parser, parser);\n      return NULL;\n    }\n  }\n\n  parser->m_freeBindingList = NULL;\n  parser->m_freeTagList = NULL;\n  parser->m_freeInternalEntities = NULL;\n\n  parser->m_groupSize = 0;\n  parser->m_groupConnector = NULL;\n\n  parser->m_unknownEncodingHandler = NULL;\n  parser->m_unknownEncodingHandlerData = NULL;\n\n  parser->m_namespaceSeparator = ASCII_EXCL;\n  parser->m_ns = XML_FALSE;\n  parser->m_ns_triplets = XML_FALSE;\n\n  parser->m_nsAtts = NULL;\n  parser->m_nsAttsVersion = 0;\n  parser->m_nsAttsPower = 0;\n\n  parser->m_protocolEncodingName = NULL;\n\n  poolInit(&parser->m_tempPool, &(parser->m_mem));\n  poolInit(&parser->m_temp2Pool, &(parser->m_mem));\n  parserInit(parser, encodingName);\n\n  if (encodingName && ! parser->m_protocolEncodingName) {\n    if (dtd) {\n      // We need to stop the upcoming call to XML_ParserFree from happily\n      // destroying parser->m_dtd because the DTD is shared with the parent\n      // parser and the only guard that keeps XML_ParserFree from destroying\n      // parser->m_dtd is parser->m_isParamEntity but it will be set to\n      // XML_TRUE only later in XML_ExternalEntityParserCreate (or not at all).\n      parser->m_dtd = NULL;\n    }\n    XML_ParserFree(parser);\n    return NULL;\n  }\n\n  if (nameSep) {\n    parser->m_ns = XML_TRUE;\n    parser->m_internalEncoding = XmlGetInternalEncodingNS();\n    parser->m_namespaceSeparator = *nameSep;\n  } else {\n    parser->m_internalEncoding = XmlGetInternalEncoding();\n  }\n\n  return parser;\n}\n\nstatic void\nparserInit(XML_Parser parser, const XML_Char *encodingName) {\n  parser->m_processor = prologInitProcessor;\n  XmlPrologStateInit(&parser->m_prologState);\n  if (encodingName != NULL) {\n    parser->m_protocolEncodingName = copyString(encodingName, &(parser->m_mem));\n  }\n  parser->m_curBase = NULL;\n  XmlInitEncoding(&parser->m_initEncoding, &parser->m_encoding, 0);\n  parser->m_userData = NULL;\n  parser->m_handlerArg = NULL;\n  parser->m_startElementHandler = NULL;\n  parser->m_endElementHandler = NULL;\n  parser->m_characterDataHandler = NULL;\n  parser->m_processingInstructionHandler = NULL;\n  parser->m_commentHandler = NULL;\n  parser->m_startCdataSectionHandler = NULL;\n  parser->m_endCdataSectionHandler = NULL;\n  parser->m_defaultHandler = NULL;\n  parser->m_startDoctypeDeclHandler = NULL;\n  parser->m_endDoctypeDeclHandler = NULL;\n  parser->m_unparsedEntityDeclHandler = NULL;\n  parser->m_notationDeclHandler = NULL;\n  parser->m_startNamespaceDeclHandler = NULL;\n  parser->m_endNamespaceDeclHandler = NULL;\n  parser->m_notStandaloneHandler = NULL;\n  parser->m_externalEntityRefHandler = NULL;\n  parser->m_externalEntityRefHandlerArg = parser;\n  parser->m_skippedEntityHandler = NULL;\n  parser->m_elementDeclHandler = NULL;\n  parser->m_attlistDeclHandler = NULL;\n  parser->m_entityDeclHandler = NULL;\n  parser->m_xmlDeclHandler = NULL;\n  parser->m_bufferPtr = parser->m_buffer;\n  parser->m_bufferEnd = parser->m_buffer;\n  parser->m_parseEndByteIndex = 0;\n  parser->m_parseEndPtr = NULL;\n  parser->m_declElementType = NULL;\n  parser->m_declAttributeId = NULL;\n  parser->m_declEntity = NULL;\n  parser->m_doctypeName = NULL;\n  parser->m_doctypeSysid = NULL;\n  parser->m_doctypePubid = NULL;\n  parser->m_declAttributeType = NULL;\n  parser->m_declNotationName = NULL;\n  parser->m_declNotationPublicId = NULL;\n  parser->m_declAttributeIsCdata = XML_FALSE;\n  parser->m_declAttributeIsId = XML_FALSE;\n  memset(&parser->m_position, 0, sizeof(POSITION));\n  parser->m_errorCode = XML_ERROR_NONE;\n  parser->m_eventPtr = NULL;\n  parser->m_eventEndPtr = NULL;\n  parser->m_positionPtr = NULL;\n  parser->m_openInternalEntities = NULL;\n  parser->m_defaultExpandInternalEntities = XML_TRUE;\n  parser->m_tagLevel = 0;\n  parser->m_tagStack = NULL;\n  parser->m_inheritedBindings = NULL;\n  parser->m_nSpecifiedAtts = 0;\n  parser->m_unknownEncodingMem = NULL;\n  parser->m_unknownEncodingRelease = NULL;\n  parser->m_unknownEncodingData = NULL;\n  parser->m_parentParser = NULL;\n  parser->m_parsingStatus.parsing = XML_INITIALIZED;\n#ifdef XML_DTD\n  parser->m_isParamEntity = XML_FALSE;\n  parser->m_useForeignDTD = XML_FALSE;\n  parser->m_paramEntityParsing = XML_PARAM_ENTITY_PARSING_NEVER;\n#endif\n  parser->m_hash_secret_salt = 0;\n\n#if defined(XML_DTD) || XML_GE == 1\n  memset(&parser->m_accounting, 0, sizeof(ACCOUNTING));\n  parser->m_accounting.debugLevel = getDebugLevel(\"EXPAT_ACCOUNTING_DEBUG\", 0u);\n  parser->m_accounting.maximumAmplificationFactor\n      = EXPAT_BILLION_LAUGHS_ATTACK_PROTECTION_MAXIMUM_AMPLIFICATION_DEFAULT;\n  parser->m_accounting.activationThresholdBytes\n      = EXPAT_BILLION_LAUGHS_ATTACK_PROTECTION_ACTIVATION_THRESHOLD_DEFAULT;\n\n  memset(&parser->m_entity_stats, 0, sizeof(ENTITY_STATS));\n  parser->m_entity_stats.debugLevel = getDebugLevel(\"EXPAT_ENTITY_DEBUG\", 0u);\n#endif\n}\n\n/* moves list of bindings to m_freeBindingList */\nstatic void FASTCALL\nmoveToFreeBindingList(XML_Parser parser, BINDING *bindings) {\n  while (bindings) {\n    BINDING *b = bindings;\n    bindings = bindings->nextTagBinding;\n    b->nextTagBinding = parser->m_freeBindingList;\n    parser->m_freeBindingList = b;\n  }\n}\n\nXML_Bool XMLCALL\nXML_ParserReset(XML_Parser parser, const XML_Char *encodingName) {\n  TAG *tStk;\n  OPEN_INTERNAL_ENTITY *openEntityList;\n\n  if (parser == NULL)\n    return XML_FALSE;\n\n  if (parser->m_parentParser)\n    return XML_FALSE;\n  /* move m_tagStack to m_freeTagList */\n  tStk = parser->m_tagStack;\n  while (tStk) {\n    TAG *tag = tStk;\n    tStk = tStk->parent;\n    tag->parent = parser->m_freeTagList;\n    moveToFreeBindingList(parser, tag->bindings);\n    tag->bindings = NULL;\n    parser->m_freeTagList = tag;\n  }\n  /* move m_openInternalEntities to m_freeInternalEntities */\n  openEntityList = parser->m_openInternalEntities;\n  while (openEntityList) {\n    OPEN_INTERNAL_ENTITY *openEntity = openEntityList;\n    openEntityList = openEntity->next;\n    openEntity->next = parser->m_freeInternalEntities;\n    parser->m_freeInternalEntities = openEntity;\n  }\n  moveToFreeBindingList(parser, parser->m_inheritedBindings);\n  FREE(parser, parser->m_unknownEncodingMem);\n  if (parser->m_unknownEncodingRelease)\n    parser->m_unknownEncodingRelease(parser->m_unknownEncodingData);\n  poolClear(&parser->m_tempPool);\n  poolClear(&parser->m_temp2Pool);\n  FREE(parser, (void *)parser->m_protocolEncodingName);\n  parser->m_protocolEncodingName = NULL;\n  parserInit(parser, encodingName);\n  dtdReset(parser->m_dtd, &parser->m_mem);\n  return XML_TRUE;\n}\n\nenum XML_Status XMLCALL\nXML_SetEncoding(XML_Parser parser, const XML_Char *encodingName) {\n  if (parser == NULL)\n    return XML_STATUS_ERROR;\n  /* Block after XML_Parse()/XML_ParseBuffer() has been called.\n     XXX There's no way for the caller to determine which of the\n     XXX possible error cases caused the XML_STATUS_ERROR return.\n  */\n  if (parser->m_parsingStatus.parsing == XML_PARSING\n      || parser->m_parsingStatus.parsing == XML_SUSPENDED)\n    return XML_STATUS_ERROR;\n\n  /* Get rid of any previous encoding name */\n  FREE(parser, (void *)parser->m_protocolEncodingName);\n\n  if (encodingName == NULL)\n    /* No new encoding name */\n    parser->m_protocolEncodingName = NULL;\n  else {\n    /* Copy the new encoding name into allocated memory */\n    parser->m_protocolEncodingName = copyString(encodingName, &(parser->m_mem));\n    if (! parser->m_protocolEncodingName)\n      return XML_STATUS_ERROR;\n  }\n  return XML_STATUS_OK;\n}\n\nXML_Parser XMLCALL\nXML_ExternalEntityParserCreate(XML_Parser oldParser, const XML_Char *context,\n                               const XML_Char *encodingName) {\n  XML_Parser parser = oldParser;\n  DTD *newDtd = NULL;\n  DTD *oldDtd;\n  XML_StartElementHandler oldStartElementHandler;\n  XML_EndElementHandler oldEndElementHandler;\n  XML_CharacterDataHandler oldCharacterDataHandler;\n  XML_ProcessingInstructionHandler oldProcessingInstructionHandler;\n  XML_CommentHandler oldCommentHandler;\n  XML_StartCdataSectionHandler oldStartCdataSectionHandler;\n  XML_EndCdataSectionHandler oldEndCdataSectionHandler;\n  XML_DefaultHandler oldDefaultHandler;\n  XML_UnparsedEntityDeclHandler oldUnparsedEntityDeclHandler;\n  XML_NotationDeclHandler oldNotationDeclHandler;\n  XML_StartNamespaceDeclHandler oldStartNamespaceDeclHandler;\n  XML_EndNamespaceDeclHandler oldEndNamespaceDeclHandler;\n  XML_NotStandaloneHandler oldNotStandaloneHandler;\n  XML_ExternalEntityRefHandler oldExternalEntityRefHandler;\n  XML_SkippedEntityHandler oldSkippedEntityHandler;\n  XML_UnknownEncodingHandler oldUnknownEncodingHandler;\n  XML_ElementDeclHandler oldElementDeclHandler;\n  XML_AttlistDeclHandler oldAttlistDeclHandler;\n  XML_EntityDeclHandler oldEntityDeclHandler;\n  XML_XmlDeclHandler oldXmlDeclHandler;\n  ELEMENT_TYPE *oldDeclElementType;\n\n  void *oldUserData;\n  void *oldHandlerArg;\n  XML_Bool oldDefaultExpandInternalEntities;\n  XML_Parser oldExternalEntityRefHandlerArg;\n#ifdef XML_DTD\n  enum XML_ParamEntityParsing oldParamEntityParsing;\n  int oldInEntityValue;\n#endif\n  XML_Bool oldns_triplets;\n  /* Note that the new parser shares the same hash secret as the old\n     parser, so that dtdCopy and copyEntityTable can lookup values\n     from hash tables associated with either parser without us having\n     to worry which hash secrets each table has.\n  */\n  unsigned long oldhash_secret_salt;\n\n  /* Validate the oldParser parameter before we pull everything out of it */\n  if (oldParser == NULL)\n    return NULL;\n\n  /* Stash the original parser contents on the stack */\n  oldDtd = parser->m_dtd;\n  oldStartElementHandler = parser->m_startElementHandler;\n  oldEndElementHandler = parser->m_endElementHandler;\n  oldCharacterDataHandler = parser->m_characterDataHandler;\n  oldProcessingInstructionHandler = parser->m_processingInstructionHandler;\n  oldCommentHandler = parser->m_commentHandler;\n  oldStartCdataSectionHandler = parser->m_startCdataSectionHandler;\n  oldEndCdataSectionHandler = parser->m_endCdataSectionHandler;\n  oldDefaultHandler = parser->m_defaultHandler;\n  oldUnparsedEntityDeclHandler = parser->m_unparsedEntityDeclHandler;\n  oldNotationDeclHandler = parser->m_notationDeclHandler;\n  oldStartNamespaceDeclHandler = parser->m_startNamespaceDeclHandler;\n  oldEndNamespaceDeclHandler = parser->m_endNamespaceDeclHandler;\n  oldNotStandaloneHandler = parser->m_notStandaloneHandler;\n  oldExternalEntityRefHandler = parser->m_externalEntityRefHandler;\n  oldSkippedEntityHandler = parser->m_skippedEntityHandler;\n  oldUnknownEncodingHandler = parser->m_unknownEncodingHandler;\n  oldElementDeclHandler = parser->m_elementDeclHandler;\n  oldAttlistDeclHandler = parser->m_attlistDeclHandler;\n  oldEntityDeclHandler = parser->m_entityDeclHandler;\n  oldXmlDeclHandler = parser->m_xmlDeclHandler;\n  oldDeclElementType = parser->m_declElementType;\n\n  oldUserData = parser->m_userData;\n  oldHandlerArg = parser->m_handlerArg;\n  oldDefaultExpandInternalEntities = parser->m_defaultExpandInternalEntities;\n  oldExternalEntityRefHandlerArg = parser->m_externalEntityRefHandlerArg;\n#ifdef XML_DTD\n  oldParamEntityParsing = parser->m_paramEntityParsing;\n  oldInEntityValue = parser->m_prologState.inEntityValue;\n#endif\n  oldns_triplets = parser->m_ns_triplets;\n  /* Note that the new parser shares the same hash secret as the old\n     parser, so that dtdCopy and copyEntityTable can lookup values\n     from hash tables associated with either parser without us having\n     to worry which hash secrets each table has.\n  */\n  oldhash_secret_salt = parser->m_hash_secret_salt;\n\n#ifdef XML_DTD\n  if (! context)\n    newDtd = oldDtd;\n#endif /* XML_DTD */\n\n  /* Note that the magical uses of the pre-processor to make field\n     access look more like C++ require that `parser' be overwritten\n     here.  This makes this function more painful to follow than it\n     would be otherwise.\n  */\n  if (parser->m_ns) {\n    XML_Char tmp[2] = {parser->m_namespaceSeparator, 0};\n    parser = parserCreate(encodingName, &parser->m_mem, tmp, newDtd);\n  } else {\n    parser = parserCreate(encodingName, &parser->m_mem, NULL, newDtd);\n  }\n\n  if (! parser)\n    return NULL;\n\n  parser->m_startElementHandler = oldStartElementHandler;\n  parser->m_endElementHandler = oldEndElementHandler;\n  parser->m_characterDataHandler = oldCharacterDataHandler;\n  parser->m_processingInstructionHandler = oldProcessingInstructionHandler;\n  parser->m_commentHandler = oldCommentHandler;\n  parser->m_startCdataSectionHandler = oldStartCdataSectionHandler;\n  parser->m_endCdataSectionHandler = oldEndCdataSectionHandler;\n  parser->m_defaultHandler = oldDefaultHandler;\n  parser->m_unparsedEntityDeclHandler = oldUnparsedEntityDeclHandler;\n  parser->m_notationDeclHandler = oldNotationDeclHandler;\n  parser->m_startNamespaceDeclHandler = oldStartNamespaceDeclHandler;\n  parser->m_endNamespaceDeclHandler = oldEndNamespaceDeclHandler;\n  parser->m_notStandaloneHandler = oldNotStandaloneHandler;\n  parser->m_externalEntityRefHandler = oldExternalEntityRefHandler;\n  parser->m_skippedEntityHandler = oldSkippedEntityHandler;\n  parser->m_unknownEncodingHandler = oldUnknownEncodingHandler;\n  parser->m_elementDeclHandler = oldElementDeclHandler;\n  parser->m_attlistDeclHandler = oldAttlistDeclHandler;\n  parser->m_entityDeclHandler = oldEntityDeclHandler;\n  parser->m_xmlDeclHandler = oldXmlDeclHandler;\n  parser->m_declElementType = oldDeclElementType;\n  parser->m_userData = oldUserData;\n  if (oldUserData == oldHandlerArg)\n    parser->m_handlerArg = parser->m_userData;\n  else\n    parser->m_handlerArg = parser;\n  if (oldExternalEntityRefHandlerArg != oldParser)\n    parser->m_externalEntityRefHandlerArg = oldExternalEntityRefHandlerArg;\n  parser->m_defaultExpandInternalEntities = oldDefaultExpandInternalEntities;\n  parser->m_ns_triplets = oldns_triplets;\n  parser->m_hash_secret_salt = oldhash_secret_salt;\n  parser->m_parentParser = oldParser;\n#ifdef XML_DTD\n  parser->m_paramEntityParsing = oldParamEntityParsing;\n  parser->m_prologState.inEntityValue = oldInEntityValue;\n  if (context) {\n#endif /* XML_DTD */\n    if (! dtdCopy(oldParser, parser->m_dtd, oldDtd, &parser->m_mem)\n        || ! setContext(parser, context)) {\n      XML_ParserFree(parser);\n      return NULL;\n    }\n    parser->m_processor = externalEntityInitProcessor;\n#ifdef XML_DTD\n  } else {\n    /* The DTD instance referenced by parser->m_dtd is shared between the\n       document's root parser and external PE parsers, therefore one does not\n       need to call setContext. In addition, one also *must* not call\n       setContext, because this would overwrite existing prefix->binding\n       pointers in parser->m_dtd with ones that get destroyed with the external\n       PE parser. This would leave those prefixes with dangling pointers.\n    */\n    parser->m_isParamEntity = XML_TRUE;\n    XmlPrologStateInitExternalEntity(&parser->m_prologState);\n    parser->m_processor = externalParEntInitProcessor;\n  }\n#endif /* XML_DTD */\n  return parser;\n}\n\nstatic void FASTCALL\ndestroyBindings(BINDING *bindings, XML_Parser parser) {\n  for (;;) {\n    BINDING *b = bindings;\n    if (! b)\n      break;\n    bindings = b->nextTagBinding;\n    FREE(parser, b->uri);\n    FREE(parser, b);\n  }\n}\n\nvoid XMLCALL\nXML_ParserFree(XML_Parser parser) {\n  TAG *tagList;\n  OPEN_INTERNAL_ENTITY *entityList;\n  if (parser == NULL)\n    return;\n  /* free m_tagStack and m_freeTagList */\n  tagList = parser->m_tagStack;\n  for (;;) {\n    TAG *p;\n    if (tagList == NULL) {\n      if (parser->m_freeTagList == NULL)\n        break;\n      tagList = parser->m_freeTagList;\n      parser->m_freeTagList = NULL;\n    }\n    p = tagList;\n    tagList = tagList->parent;\n    FREE(parser, p->buf);\n    destroyBindings(p->bindings, parser);\n    FREE(parser, p);\n  }\n  /* free m_openInternalEntities and m_freeInternalEntities */\n  entityList = parser->m_openInternalEntities;\n  for (;;) {\n    OPEN_INTERNAL_ENTITY *openEntity;\n    if (entityList == NULL) {\n      if (parser->m_freeInternalEntities == NULL)\n        break;\n      entityList = parser->m_freeInternalEntities;\n      parser->m_freeInternalEntities = NULL;\n    }\n    openEntity = entityList;\n    entityList = entityList->next;\n    FREE(parser, openEntity);\n  }\n\n  destroyBindings(parser->m_freeBindingList, parser);\n  destroyBindings(parser->m_inheritedBindings, parser);\n  poolDestroy(&parser->m_tempPool);\n  poolDestroy(&parser->m_temp2Pool);\n  FREE(parser, (void *)parser->m_protocolEncodingName);\n#ifdef XML_DTD\n  /* external parameter entity parsers share the DTD structure\n     parser->m_dtd with the root parser, so we must not destroy it\n  */\n  if (! parser->m_isParamEntity && parser->m_dtd)\n#else\n  if (parser->m_dtd)\n#endif /* XML_DTD */\n    dtdDestroy(parser->m_dtd, (XML_Bool)! parser->m_parentParser,\n               &parser->m_mem);\n  FREE(parser, (void *)parser->m_atts);\n#ifdef XML_ATTR_INFO\n  FREE(parser, (void *)parser->m_attInfo);\n#endif\n  FREE(parser, parser->m_groupConnector);\n  FREE(parser, parser->m_buffer);\n  FREE(parser, parser->m_dataBuf);\n  FREE(parser, parser->m_nsAtts);\n  FREE(parser, parser->m_unknownEncodingMem);\n  if (parser->m_unknownEncodingRelease)\n    parser->m_unknownEncodingRelease(parser->m_unknownEncodingData);\n  FREE(parser, parser);\n}\n\nvoid XMLCALL\nXML_UseParserAsHandlerArg(XML_Parser parser) {\n  if (parser != NULL)\n    parser->m_handlerArg = parser;\n}\n\nenum XML_Error XMLCALL\nXML_UseForeignDTD(XML_Parser parser, XML_Bool useDTD) {\n  if (parser == NULL)\n    return XML_ERROR_INVALID_ARGUMENT;\n#ifdef XML_DTD\n  /* block after XML_Parse()/XML_ParseBuffer() has been called */\n  if (parser->m_parsingStatus.parsing == XML_PARSING\n      || parser->m_parsingStatus.parsing == XML_SUSPENDED)\n    return XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING;\n  parser->m_useForeignDTD = useDTD;\n  return XML_ERROR_NONE;\n#else\n  UNUSED_P(useDTD);\n  return XML_ERROR_FEATURE_REQUIRES_XML_DTD;\n#endif\n}\n\nvoid XMLCALL\nXML_SetReturnNSTriplet(XML_Parser parser, int do_nst) {\n  if (parser == NULL)\n    return;\n  /* block after XML_Parse()/XML_ParseBuffer() has been called */\n  if (parser->m_parsingStatus.parsing == XML_PARSING\n      || parser->m_parsingStatus.parsing == XML_SUSPENDED)\n    return;\n  parser->m_ns_triplets = do_nst ? XML_TRUE : XML_FALSE;\n}\n\nvoid XMLCALL\nXML_SetUserData(XML_Parser parser, void *p) {\n  if (parser == NULL)\n    return;\n  if (parser->m_handlerArg == parser->m_userData)\n    parser->m_handlerArg = parser->m_userData = p;\n  else\n    parser->m_userData = p;\n}\n\nenum XML_Status XMLCALL\nXML_SetBase(XML_Parser parser, const XML_Char *p) {\n  if (parser == NULL)\n    return XML_STATUS_ERROR;\n  if (p) {\n    p = poolCopyString(&parser->m_dtd->pool, p);\n    if (! p)\n      return XML_STATUS_ERROR;\n    parser->m_curBase = p;\n  } else\n    parser->m_curBase = NULL;\n  return XML_STATUS_OK;\n}\n\nconst XML_Char *XMLCALL\nXML_GetBase(XML_Parser parser) {\n  if (parser == NULL)\n    return NULL;\n  return parser->m_curBase;\n}\n\nint XMLCALL\nXML_GetSpecifiedAttributeCount(XML_Parser parser) {\n  if (parser == NULL)\n    return -1;\n  return parser->m_nSpecifiedAtts;\n}\n\nint XMLCALL\nXML_GetIdAttributeIndex(XML_Parser parser) {\n  if (parser == NULL)\n    return -1;\n  return parser->m_idAttIndex;\n}\n\n#ifdef XML_ATTR_INFO\nconst XML_AttrInfo *XMLCALL\nXML_GetAttributeInfo(XML_Parser parser) {\n  if (parser == NULL)\n    return NULL;\n  return parser->m_attInfo;\n}\n#endif\n\nvoid XMLCALL\nXML_SetElementHandler(XML_Parser parser, XML_StartElementHandler start,\n                      XML_EndElementHandler end) {\n  if (parser == NULL)\n    return;\n  parser->m_startElementHandler = start;\n  parser->m_endElementHandler = end;\n}\n\nvoid XMLCALL\nXML_SetStartElementHandler(XML_Parser parser, XML_StartElementHandler start) {\n  if (parser != NULL)\n    parser->m_startElementHandler = start;\n}\n\nvoid XMLCALL\nXML_SetEndElementHandler(XML_Parser parser, XML_EndElementHandler end) {\n  if (parser != NULL)\n    parser->m_endElementHandler = end;\n}\n\nvoid XMLCALL\nXML_SetCharacterDataHandler(XML_Parser parser,\n                            XML_CharacterDataHandler handler) {\n  if (parser != NULL)\n    parser->m_characterDataHandler = handler;\n}\n\nvoid XMLCALL\nXML_SetProcessingInstructionHandler(XML_Parser parser,\n                                    XML_ProcessingInstructionHandler handler) {\n  if (parser != NULL)\n    parser->m_processingInstructionHandler = handler;\n}\n\nvoid XMLCALL\nXML_SetCommentHandler(XML_Parser parser, XML_CommentHandler handler) {\n  if (parser != NULL)\n    parser->m_commentHandler = handler;\n}\n\nvoid XMLCALL\nXML_SetCdataSectionHandler(XML_Parser parser,\n                           XML_StartCdataSectionHandler start,\n                           XML_EndCdataSectionHandler end) {\n  if (parser == NULL)\n    return;\n  parser->m_startCdataSectionHandler = start;\n  parser->m_endCdataSectionHandler = end;\n}\n\nvoid XMLCALL\nXML_SetStartCdataSectionHandler(XML_Parser parser,\n                                XML_StartCdataSectionHandler start) {\n  if (parser != NULL)\n    parser->m_startCdataSectionHandler = start;\n}\n\nvoid XMLCALL\nXML_SetEndCdataSectionHandler(XML_Parser parser,\n                              XML_EndCdataSectionHandler end) {\n  if (parser != NULL)\n    parser->m_endCdataSectionHandler = end;\n}\n\nvoid XMLCALL\nXML_SetDefaultHandler(XML_Parser parser, XML_DefaultHandler handler) {\n  if (parser == NULL)\n    return;\n  parser->m_defaultHandler = handler;\n  parser->m_defaultExpandInternalEntities = XML_FALSE;\n}\n\nvoid XMLCALL\nXML_SetDefaultHandlerExpand(XML_Parser parser, XML_DefaultHandler handler) {\n  if (parser == NULL)\n    return;\n  parser->m_defaultHandler = handler;\n  parser->m_defaultExpandInternalEntities = XML_TRUE;\n}\n\nvoid XMLCALL\nXML_SetDoctypeDeclHandler(XML_Parser parser, XML_StartDoctypeDeclHandler start,\n                          XML_EndDoctypeDeclHandler end) {\n  if (parser == NULL)\n    return;\n  parser->m_startDoctypeDeclHandler = start;\n  parser->m_endDoctypeDeclHandler = end;\n}\n\nvoid XMLCALL\nXML_SetStartDoctypeDeclHandler(XML_Parser parser,\n                               XML_StartDoctypeDeclHandler start) {\n  if (parser != NULL)\n    parser->m_startDoctypeDeclHandler = start;\n}\n\nvoid XMLCALL\nXML_SetEndDoctypeDeclHandler(XML_Parser parser, XML_EndDoctypeDeclHandler end) {\n  if (parser != NULL)\n    parser->m_endDoctypeDeclHandler = end;\n}\n\nvoid XMLCALL\nXML_SetUnparsedEntityDeclHandler(XML_Parser parser,\n                                 XML_UnparsedEntityDeclHandler handler) {\n  if (parser != NULL)\n    parser->m_unparsedEntityDeclHandler = handler;\n}\n\nvoid XMLCALL\nXML_SetNotationDeclHandler(XML_Parser parser, XML_NotationDeclHandler handler) {\n  if (parser != NULL)\n    parser->m_notationDeclHandler = handler;\n}\n\nvoid XMLCALL\nXML_SetNamespaceDeclHandler(XML_Parser parser,\n                            XML_StartNamespaceDeclHandler start,\n                            XML_EndNamespaceDeclHandler end) {\n  if (parser == NULL)\n    return;\n  parser->m_startNamespaceDeclHandler = start;\n  parser->m_endNamespaceDeclHandler = end;\n}\n\nvoid XMLCALL\nXML_SetStartNamespaceDeclHandler(XML_Parser parser,\n                                 XML_StartNamespaceDeclHandler start) {\n  if (parser != NULL)\n    parser->m_startNamespaceDeclHandler = start;\n}\n\nvoid XMLCALL\nXML_SetEndNamespaceDeclHandler(XML_Parser parser,\n                               XML_EndNamespaceDeclHandler end) {\n  if (parser != NULL)\n    parser->m_endNamespaceDeclHandler = end;\n}\n\nvoid XMLCALL\nXML_SetNotStandaloneHandler(XML_Parser parser,\n                            XML_NotStandaloneHandler handler) {\n  if (parser != NULL)\n    parser->m_notStandaloneHandler = handler;\n}\n\nvoid XMLCALL\nXML_SetExternalEntityRefHandler(XML_Parser parser,\n                                XML_ExternalEntityRefHandler handler) {\n  if (parser != NULL)\n    parser->m_externalEntityRefHandler = handler;\n}\n\nvoid XMLCALL\nXML_SetExternalEntityRefHandlerArg(XML_Parser parser, void *arg) {\n  if (parser == NULL)\n    return;\n  if (arg)\n    parser->m_externalEntityRefHandlerArg = (XML_Parser)arg;\n  else\n    parser->m_externalEntityRefHandlerArg = parser;\n}\n\nvoid XMLCALL\nXML_SetSkippedEntityHandler(XML_Parser parser,\n                            XML_SkippedEntityHandler handler) {\n  if (parser != NULL)\n    parser->m_skippedEntityHandler = handler;\n}\n\nvoid XMLCALL\nXML_SetUnknownEncodingHandler(XML_Parser parser,\n                              XML_UnknownEncodingHandler handler, void *data) {\n  if (parser == NULL)\n    return;\n  parser->m_unknownEncodingHandler = handler;\n  parser->m_unknownEncodingHandlerData = data;\n}\n\nvoid XMLCALL\nXML_SetElementDeclHandler(XML_Parser parser, XML_ElementDeclHandler eldecl) {\n  if (parser != NULL)\n    parser->m_elementDeclHandler = eldecl;\n}\n\nvoid XMLCALL\nXML_SetAttlistDeclHandler(XML_Parser parser, XML_AttlistDeclHandler attdecl) {\n  if (parser != NULL)\n    parser->m_attlistDeclHandler = attdecl;\n}\n\nvoid XMLCALL\nXML_SetEntityDeclHandler(XML_Parser parser, XML_EntityDeclHandler handler) {\n  if (parser != NULL)\n    parser->m_entityDeclHandler = handler;\n}\n\nvoid XMLCALL\nXML_SetXmlDeclHandler(XML_Parser parser, XML_XmlDeclHandler handler) {\n  if (parser != NULL)\n    parser->m_xmlDeclHandler = handler;\n}\n\nint XMLCALL\nXML_SetParamEntityParsing(XML_Parser parser,\n                          enum XML_ParamEntityParsing peParsing) {\n  if (parser == NULL)\n    return 0;\n  /* block after XML_Parse()/XML_ParseBuffer() has been called */\n  if (parser->m_parsingStatus.parsing == XML_PARSING\n      || parser->m_parsingStatus.parsing == XML_SUSPENDED)\n    return 0;\n#ifdef XML_DTD\n  parser->m_paramEntityParsing = peParsing;\n  return 1;\n#else\n  return peParsing == XML_PARAM_ENTITY_PARSING_NEVER;\n#endif\n}\n\nint XMLCALL\nXML_SetHashSalt(XML_Parser parser, unsigned long hash_salt) {\n  if (parser == NULL)\n    return 0;\n  if (parser->m_parentParser)\n    return XML_SetHashSalt(parser->m_parentParser, hash_salt);\n  /* block after XML_Parse()/XML_ParseBuffer() has been called */\n  if (parser->m_parsingStatus.parsing == XML_PARSING\n      || parser->m_parsingStatus.parsing == XML_SUSPENDED)\n    return 0;\n  parser->m_hash_secret_salt = hash_salt;\n  return 1;\n}\n\nenum XML_Status XMLCALL\nXML_Parse(XML_Parser parser, const char *s, int len, int isFinal) {\n  if ((parser == NULL) || (len < 0) || ((s == NULL) && (len != 0))) {\n    if (parser != NULL)\n      parser->m_errorCode = XML_ERROR_INVALID_ARGUMENT;\n    return XML_STATUS_ERROR;\n  }\n  switch (parser->m_parsingStatus.parsing) {\n  case XML_SUSPENDED:\n    parser->m_errorCode = XML_ERROR_SUSPENDED;\n    return XML_STATUS_ERROR;\n  case XML_FINISHED:\n    parser->m_errorCode = XML_ERROR_FINISHED;\n    return XML_STATUS_ERROR;\n  case XML_INITIALIZED:\n    if (parser->m_parentParser == NULL && ! startParsing(parser)) {\n      parser->m_errorCode = XML_ERROR_NO_MEMORY;\n      return XML_STATUS_ERROR;\n    }\n    /* fall through */\n  default:\n    parser->m_parsingStatus.parsing = XML_PARSING;\n  }\n\n  if (len == 0) {\n    parser->m_parsingStatus.finalBuffer = (XML_Bool)isFinal;\n    if (! isFinal)\n      return XML_STATUS_OK;\n    parser->m_positionPtr = parser->m_bufferPtr;\n    parser->m_parseEndPtr = parser->m_bufferEnd;\n\n    /* If data are left over from last buffer, and we now know that these\n       data are the final chunk of input, then we have to check them again\n       to detect errors based on that fact.\n    */\n    parser->m_errorCode\n        = parser->m_processor(parser, parser->m_bufferPtr,\n                              parser->m_parseEndPtr, &parser->m_bufferPtr);\n\n    if (parser->m_errorCode == XML_ERROR_NONE) {\n      switch (parser->m_parsingStatus.parsing) {\n      case XML_SUSPENDED:\n        /* It is hard to be certain, but it seems that this case\n         * cannot occur.  This code is cleaning up a previous parse\n         * with no new data (since len == 0).  Changing the parsing\n         * state requires getting to execute a handler function, and\n         * there doesn't seem to be an opportunity for that while in\n         * this circumstance.\n         *\n         * Given the uncertainty, we retain the code but exclude it\n         * from coverage tests.\n         *\n         * LCOV_EXCL_START\n         */\n        XmlUpdatePosition(parser->m_encoding, parser->m_positionPtr,\n                          parser->m_bufferPtr, &parser->m_position);\n        parser->m_positionPtr = parser->m_bufferPtr;\n        return XML_STATUS_SUSPENDED;\n        /* LCOV_EXCL_STOP */\n      case XML_INITIALIZED:\n      case XML_PARSING:\n        parser->m_parsingStatus.parsing = XML_FINISHED;\n        /* fall through */\n      default:\n        return XML_STATUS_OK;\n      }\n    }\n    parser->m_eventEndPtr = parser->m_eventPtr;\n    parser->m_processor = errorProcessor;\n    return XML_STATUS_ERROR;\n  }\n#if XML_CONTEXT_BYTES == 0\n  else if (parser->m_bufferPtr == parser->m_bufferEnd) {\n    const char *end;\n    int nLeftOver;\n    enum XML_Status result;\n    /* Detect overflow (a+b > MAX <==> b > MAX-a) */\n    if ((XML_Size)len > ((XML_Size)-1) / 2 - parser->m_parseEndByteIndex) {\n      parser->m_errorCode = XML_ERROR_NO_MEMORY;\n      parser->m_eventPtr = parser->m_eventEndPtr = NULL;\n      parser->m_processor = errorProcessor;\n      return XML_STATUS_ERROR;\n    }\n    parser->m_parseEndByteIndex += len;\n    parser->m_positionPtr = s;\n    parser->m_parsingStatus.finalBuffer = (XML_Bool)isFinal;\n\n    parser->m_errorCode\n        = parser->m_processor(parser, s, parser->m_parseEndPtr = s + len, &end);\n\n    if (parser->m_errorCode != XML_ERROR_NONE) {\n      parser->m_eventEndPtr = parser->m_eventPtr;\n      parser->m_processor = errorProcessor;\n      return XML_STATUS_ERROR;\n    } else {\n      switch (parser->m_parsingStatus.parsing) {\n      case XML_SUSPENDED:\n        result = XML_STATUS_SUSPENDED;\n        break;\n      case XML_INITIALIZED:\n      case XML_PARSING:\n        if (isFinal) {\n          parser->m_parsingStatus.parsing = XML_FINISHED;\n          return XML_STATUS_OK;\n        }\n      /* fall through */\n      default:\n        result = XML_STATUS_OK;\n      }\n    }\n\n    XmlUpdatePosition(parser->m_encoding, parser->m_positionPtr, end,\n                      &parser->m_position);\n    nLeftOver = s + len - end;\n    if (nLeftOver) {\n      // Back up and restore the parsing status to avoid XML_ERROR_SUSPENDED\n      // (and XML_ERROR_FINISHED) from XML_GetBuffer.\n      const enum XML_Parsing originalStatus = parser->m_parsingStatus.parsing;\n      parser->m_parsingStatus.parsing = XML_PARSING;\n      void *const temp = XML_GetBuffer(parser, nLeftOver);\n      parser->m_parsingStatus.parsing = originalStatus;\n      if (temp == NULL) {\n        // NOTE: parser->m_errorCode has already been set by XML_GetBuffer().\n        parser->m_eventPtr = parser->m_eventEndPtr = NULL;\n        parser->m_processor = errorProcessor;\n        return XML_STATUS_ERROR;\n      }\n      // Since we know that the buffer was empty and XML_CONTEXT_BYTES is 0, we\n      // don't have any data to preserve, and can copy straight into the start\n      // of the buffer rather than the GetBuffer return pointer (which may be\n      // pointing further into the allocated buffer).\n      memcpy(parser->m_buffer, end, nLeftOver);\n    }\n    parser->m_bufferPtr = parser->m_buffer;\n    parser->m_bufferEnd = parser->m_buffer + nLeftOver;\n    parser->m_positionPtr = parser->m_bufferPtr;\n    parser->m_parseEndPtr = parser->m_bufferEnd;\n    parser->m_eventPtr = parser->m_bufferPtr;\n    parser->m_eventEndPtr = parser->m_bufferPtr;\n    return result;\n  }\n#endif /* XML_CONTEXT_BYTES == 0 */\n  else {\n    void *buff = XML_GetBuffer(parser, len);\n    if (buff == NULL)\n      return XML_STATUS_ERROR;\n    else {\n      memcpy(buff, s, len);\n      return XML_ParseBuffer(parser, len, isFinal);\n    }\n  }\n}\n\nenum XML_Status XMLCALL\nXML_ParseBuffer(XML_Parser parser, int len, int isFinal) {\n  const char *start;\n  enum XML_Status result = XML_STATUS_OK;\n\n  if (parser == NULL)\n    return XML_STATUS_ERROR;\n  switch (parser->m_parsingStatus.parsing) {\n  case XML_SUSPENDED:\n    parser->m_errorCode = XML_ERROR_SUSPENDED;\n    return XML_STATUS_ERROR;\n  case XML_FINISHED:\n    parser->m_errorCode = XML_ERROR_FINISHED;\n    return XML_STATUS_ERROR;\n  case XML_INITIALIZED:\n    /* Has someone called XML_GetBuffer successfully before? */\n    if (! parser->m_bufferPtr) {\n      parser->m_errorCode = XML_ERROR_NO_BUFFER;\n      return XML_STATUS_ERROR;\n    }\n\n    if (parser->m_parentParser == NULL && ! startParsing(parser)) {\n      parser->m_errorCode = XML_ERROR_NO_MEMORY;\n      return XML_STATUS_ERROR;\n    }\n    /* fall through */\n  default:\n    parser->m_parsingStatus.parsing = XML_PARSING;\n  }\n\n  start = parser->m_bufferPtr;\n  parser->m_positionPtr = start;\n  parser->m_bufferEnd += len;\n  parser->m_parseEndPtr = parser->m_bufferEnd;\n  parser->m_parseEndByteIndex += len;\n  parser->m_parsingStatus.finalBuffer = (XML_Bool)isFinal;\n\n  parser->m_errorCode = parser->m_processor(\n      parser, start, parser->m_parseEndPtr, &parser->m_bufferPtr);\n\n  if (parser->m_errorCode != XML_ERROR_NONE) {\n    parser->m_eventEndPtr = parser->m_eventPtr;\n    parser->m_processor = errorProcessor;\n    return XML_STATUS_ERROR;\n  } else {\n    switch (parser->m_parsingStatus.parsing) {\n    case XML_SUSPENDED:\n      result = XML_STATUS_SUSPENDED;\n      break;\n    case XML_INITIALIZED:\n    case XML_PARSING:\n      if (isFinal) {\n        parser->m_parsingStatus.parsing = XML_FINISHED;\n        return result;\n      }\n    default:; /* should not happen */\n    }\n  }\n\n  XmlUpdatePosition(parser->m_encoding, parser->m_positionPtr,\n                    parser->m_bufferPtr, &parser->m_position);\n  parser->m_positionPtr = parser->m_bufferPtr;\n  return result;\n}\n\nvoid *XMLCALL\nXML_GetBuffer(XML_Parser parser, int len) {\n  if (parser == NULL)\n    return NULL;\n  if (len < 0) {\n    parser->m_errorCode = XML_ERROR_NO_MEMORY;\n    return NULL;\n  }\n  switch (parser->m_parsingStatus.parsing) {\n  case XML_SUSPENDED:\n    parser->m_errorCode = XML_ERROR_SUSPENDED;\n    return NULL;\n  case XML_FINISHED:\n    parser->m_errorCode = XML_ERROR_FINISHED;\n    return NULL;\n  default:;\n  }\n\n  if (len > EXPAT_SAFE_PTR_DIFF(parser->m_bufferLim, parser->m_bufferEnd)) {\n#if XML_CONTEXT_BYTES > 0\n    int keep;\n#endif /* XML_CONTEXT_BYTES > 0 */\n    /* Do not invoke signed arithmetic overflow: */\n    int neededSize = (int)((unsigned)len\n                           + (unsigned)EXPAT_SAFE_PTR_DIFF(\n                               parser->m_bufferEnd, parser->m_bufferPtr));\n    if (neededSize < 0) {\n      parser->m_errorCode = XML_ERROR_NO_MEMORY;\n      return NULL;\n    }\n#if XML_CONTEXT_BYTES > 0\n    keep = (int)EXPAT_SAFE_PTR_DIFF(parser->m_bufferPtr, parser->m_buffer);\n    if (keep > XML_CONTEXT_BYTES)\n      keep = XML_CONTEXT_BYTES;\n    /* Detect and prevent integer overflow */\n    if (keep > INT_MAX - neededSize) {\n      parser->m_errorCode = XML_ERROR_NO_MEMORY;\n      return NULL;\n    }\n    neededSize += keep;\n#endif /* XML_CONTEXT_BYTES > 0 */\n    if (neededSize\n        <= EXPAT_SAFE_PTR_DIFF(parser->m_bufferLim, parser->m_buffer)) {\n#if XML_CONTEXT_BYTES > 0\n      if (keep < EXPAT_SAFE_PTR_DIFF(parser->m_bufferPtr, parser->m_buffer)) {\n        int offset\n            = (int)EXPAT_SAFE_PTR_DIFF(parser->m_bufferPtr, parser->m_buffer)\n              - keep;\n        /* The buffer pointers cannot be NULL here; we have at least some bytes\n         * in the buffer */\n        memmove(parser->m_buffer, &parser->m_buffer[offset],\n                parser->m_bufferEnd - parser->m_bufferPtr + keep);\n        parser->m_bufferEnd -= offset;\n        parser->m_bufferPtr -= offset;\n      }\n#else\n      if (parser->m_buffer && parser->m_bufferPtr) {\n        memmove(parser->m_buffer, parser->m_bufferPtr,\n                EXPAT_SAFE_PTR_DIFF(parser->m_bufferEnd, parser->m_bufferPtr));\n        parser->m_bufferEnd\n            = parser->m_buffer\n              + EXPAT_SAFE_PTR_DIFF(parser->m_bufferEnd, parser->m_bufferPtr);\n        parser->m_bufferPtr = parser->m_buffer;\n      }\n#endif /* XML_CONTEXT_BYTES > 0 */\n    } else {\n      char *newBuf;\n      int bufferSize\n          = (int)EXPAT_SAFE_PTR_DIFF(parser->m_bufferLim, parser->m_buffer);\n      if (bufferSize == 0)\n        bufferSize = INIT_BUFFER_SIZE;\n      do {\n        /* Do not invoke signed arithmetic overflow: */\n        bufferSize = (int)(2U * (unsigned)bufferSize);\n      } while (bufferSize < neededSize && bufferSize > 0);\n      if (bufferSize <= 0) {\n        parser->m_errorCode = XML_ERROR_NO_MEMORY;\n        return NULL;\n      }\n      newBuf = (char *)MALLOC(parser, bufferSize);\n      if (newBuf == 0) {\n        parser->m_errorCode = XML_ERROR_NO_MEMORY;\n        return NULL;\n      }\n      parser->m_bufferLim = newBuf + bufferSize;\n#if XML_CONTEXT_BYTES > 0\n      if (parser->m_bufferPtr) {\n        memcpy(newBuf, &parser->m_bufferPtr[-keep],\n               EXPAT_SAFE_PTR_DIFF(parser->m_bufferEnd, parser->m_bufferPtr)\n                   + keep);\n        FREE(parser, parser->m_buffer);\n        parser->m_buffer = newBuf;\n        parser->m_bufferEnd\n            = parser->m_buffer\n              + EXPAT_SAFE_PTR_DIFF(parser->m_bufferEnd, parser->m_bufferPtr)\n              + keep;\n        parser->m_bufferPtr = parser->m_buffer + keep;\n      } else {\n        /* This must be a brand new buffer with no data in it yet */\n        parser->m_bufferEnd = newBuf;\n        parser->m_bufferPtr = parser->m_buffer = newBuf;\n      }\n#else\n      if (parser->m_bufferPtr) {\n        memcpy(newBuf, parser->m_bufferPtr,\n               EXPAT_SAFE_PTR_DIFF(parser->m_bufferEnd, parser->m_bufferPtr));\n        FREE(parser, parser->m_buffer);\n        parser->m_bufferEnd\n            = newBuf\n              + EXPAT_SAFE_PTR_DIFF(parser->m_bufferEnd, parser->m_bufferPtr);\n      } else {\n        /* This must be a brand new buffer with no data in it yet */\n        parser->m_bufferEnd = newBuf;\n      }\n      parser->m_bufferPtr = parser->m_buffer = newBuf;\n#endif /* XML_CONTEXT_BYTES > 0 */\n    }\n    parser->m_eventPtr = parser->m_eventEndPtr = NULL;\n    parser->m_positionPtr = NULL;\n  }\n  return parser->m_bufferEnd;\n}\n\nenum XML_Status XMLCALL\nXML_StopParser(XML_Parser parser, XML_Bool resumable) {\n  if (parser == NULL)\n    return XML_STATUS_ERROR;\n  switch (parser->m_parsingStatus.parsing) {\n  case XML_SUSPENDED:\n    if (resumable) {\n      parser->m_errorCode = XML_ERROR_SUSPENDED;\n      return XML_STATUS_ERROR;\n    }\n    parser->m_parsingStatus.parsing = XML_FINISHED;\n    break;\n  case XML_FINISHED:\n    parser->m_errorCode = XML_ERROR_FINISHED;\n    return XML_STATUS_ERROR;\n  default:\n    if (resumable) {\n#ifdef XML_DTD\n      if (parser->m_isParamEntity) {\n        parser->m_errorCode = XML_ERROR_SUSPEND_PE;\n        return XML_STATUS_ERROR;\n      }\n#endif\n      parser->m_parsingStatus.parsing = XML_SUSPENDED;\n    } else\n      parser->m_parsingStatus.parsing = XML_FINISHED;\n  }\n  return XML_STATUS_OK;\n}\n\nenum XML_Status XMLCALL\nXML_ResumeParser(XML_Parser parser) {\n  enum XML_Status result = XML_STATUS_OK;\n\n  if (parser == NULL)\n    return XML_STATUS_ERROR;\n  if (parser->m_parsingStatus.parsing != XML_SUSPENDED) {\n    parser->m_errorCode = XML_ERROR_NOT_SUSPENDED;\n    return XML_STATUS_ERROR;\n  }\n  parser->m_parsingStatus.parsing = XML_PARSING;\n\n  parser->m_errorCode = parser->m_processor(\n      parser, parser->m_bufferPtr, parser->m_parseEndPtr, &parser->m_bufferPtr);\n\n  if (parser->m_errorCode != XML_ERROR_NONE) {\n    parser->m_eventEndPtr = parser->m_eventPtr;\n    parser->m_processor = errorProcessor;\n    return XML_STATUS_ERROR;\n  } else {\n    switch (parser->m_parsingStatus.parsing) {\n    case XML_SUSPENDED:\n      result = XML_STATUS_SUSPENDED;\n      break;\n    case XML_INITIALIZED:\n    case XML_PARSING:\n      if (parser->m_parsingStatus.finalBuffer) {\n        parser->m_parsingStatus.parsing = XML_FINISHED;\n        return result;\n      }\n    default:;\n    }\n  }\n\n  XmlUpdatePosition(parser->m_encoding, parser->m_positionPtr,\n                    parser->m_bufferPtr, &parser->m_position);\n  parser->m_positionPtr = parser->m_bufferPtr;\n  return result;\n}\n\nvoid XMLCALL\nXML_GetParsingStatus(XML_Parser parser, XML_ParsingStatus *status) {\n  if (parser == NULL)\n    return;\n  assert(status != NULL);\n  *status = parser->m_parsingStatus;\n}\n\nenum XML_Error XMLCALL\nXML_GetErrorCode(XML_Parser parser) {\n  if (parser == NULL)\n    return XML_ERROR_INVALID_ARGUMENT;\n  return parser->m_errorCode;\n}\n\nXML_Index XMLCALL\nXML_GetCurrentByteIndex(XML_Parser parser) {\n  if (parser == NULL)\n    return -1;\n  if (parser->m_eventPtr)\n    return (XML_Index)(parser->m_parseEndByteIndex\n                       - (parser->m_parseEndPtr - parser->m_eventPtr));\n  return -1;\n}\n\nint XMLCALL\nXML_GetCurrentByteCount(XML_Parser parser) {\n  if (parser == NULL)\n    return 0;\n  if (parser->m_eventEndPtr && parser->m_eventPtr)\n    return (int)(parser->m_eventEndPtr - parser->m_eventPtr);\n  return 0;\n}\n\nconst char *XMLCALL\nXML_GetInputContext(XML_Parser parser, int *offset, int *size) {\n#if XML_CONTEXT_BYTES > 0\n  if (parser == NULL)\n    return NULL;\n  if (parser->m_eventPtr && parser->m_buffer) {\n    if (offset != NULL)\n      *offset = (int)(parser->m_eventPtr - parser->m_buffer);\n    if (size != NULL)\n      *size = (int)(parser->m_bufferEnd - parser->m_buffer);\n    return parser->m_buffer;\n  }\n#else\n  (void)parser;\n  (void)offset;\n  (void)size;\n#endif /* XML_CONTEXT_BYTES > 0 */\n  return (const char *)0;\n}\n\nXML_Size XMLCALL\nXML_GetCurrentLineNumber(XML_Parser parser) {\n  if (parser == NULL)\n    return 0;\n  if (parser->m_eventPtr && parser->m_eventPtr >= parser->m_positionPtr) {\n    XmlUpdatePosition(parser->m_encoding, parser->m_positionPtr,\n                      parser->m_eventPtr, &parser->m_position);\n    parser->m_positionPtr = parser->m_eventPtr;\n  }\n  return parser->m_position.lineNumber + 1;\n}\n\nXML_Size XMLCALL\nXML_GetCurrentColumnNumber(XML_Parser parser) {\n  if (parser == NULL)\n    return 0;\n  if (parser->m_eventPtr && parser->m_eventPtr >= parser->m_positionPtr) {\n    XmlUpdatePosition(parser->m_encoding, parser->m_positionPtr,\n                      parser->m_eventPtr, &parser->m_position);\n    parser->m_positionPtr = parser->m_eventPtr;\n  }\n  return parser->m_position.columnNumber;\n}\n\nvoid XMLCALL\nXML_FreeContentModel(XML_Parser parser, XML_Content *model) {\n  if (parser != NULL)\n    FREE(parser, model);\n}\n\nvoid *XMLCALL\nXML_MemMalloc(XML_Parser parser, size_t size) {\n  if (parser == NULL)\n    return NULL;\n  return MALLOC(parser, size);\n}\n\nvoid *XMLCALL\nXML_MemRealloc(XML_Parser parser, void *ptr, size_t size) {\n  if (parser == NULL)\n    return NULL;\n  return REALLOC(parser, ptr, size);\n}\n\nvoid XMLCALL\nXML_MemFree(XML_Parser parser, void *ptr) {\n  if (parser != NULL)\n    FREE(parser, ptr);\n}\n\nvoid XMLCALL\nXML_DefaultCurrent(XML_Parser parser) {\n  if (parser == NULL)\n    return;\n  if (parser->m_defaultHandler) {\n    if (parser->m_openInternalEntities)\n      reportDefault(parser, parser->m_internalEncoding,\n                    parser->m_openInternalEntities->internalEventPtr,\n                    parser->m_openInternalEntities->internalEventEndPtr);\n    else\n      reportDefault(parser, parser->m_encoding, parser->m_eventPtr,\n                    parser->m_eventEndPtr);\n  }\n}\n\nconst XML_LChar *XMLCALL\nXML_ErrorString(enum XML_Error code) {\n  switch (code) {\n  case XML_ERROR_NONE:\n    return NULL;\n  case XML_ERROR_NO_MEMORY:\n    return XML_L(\"out of memory\");\n  case XML_ERROR_SYNTAX:\n    return XML_L(\"syntax error\");\n  case XML_ERROR_NO_ELEMENTS:\n    return XML_L(\"no element found\");\n  case XML_ERROR_INVALID_TOKEN:\n    return XML_L(\"not well-formed (invalid token)\");\n  case XML_ERROR_UNCLOSED_TOKEN:\n    return XML_L(\"unclosed token\");\n  case XML_ERROR_PARTIAL_CHAR:\n    return XML_L(\"partial character\");\n  case XML_ERROR_TAG_MISMATCH:\n    return XML_L(\"mismatched tag\");\n  case XML_ERROR_DUPLICATE_ATTRIBUTE:\n    return XML_L(\"duplicate attribute\");\n  case XML_ERROR_JUNK_AFTER_DOC_ELEMENT:\n    return XML_L(\"junk after document element\");\n  case XML_ERROR_PARAM_ENTITY_REF:\n    return XML_L(\"illegal parameter entity reference\");\n  case XML_ERROR_UNDEFINED_ENTITY:\n    return XML_L(\"undefined entity\");\n  case XML_ERROR_RECURSIVE_ENTITY_REF:\n    return XML_L(\"recursive entity reference\");\n  case XML_ERROR_ASYNC_ENTITY:\n    return XML_L(\"asynchronous entity\");\n  case XML_ERROR_BAD_CHAR_REF:\n    return XML_L(\"reference to invalid character number\");\n  case XML_ERROR_BINARY_ENTITY_REF:\n    return XML_L(\"reference to binary entity\");\n  case XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF:\n    return XML_L(\"reference to external entity in attribute\");\n  case XML_ERROR_MISPLACED_XML_PI:\n    return XML_L(\"XML or text declaration not at start of entity\");\n  case XML_ERROR_UNKNOWN_ENCODING:\n    return XML_L(\"unknown encoding\");\n  case XML_ERROR_INCORRECT_ENCODING:\n    return XML_L(\"encoding specified in XML declaration is incorrect\");\n  case XML_ERROR_UNCLOSED_CDATA_SECTION:\n    return XML_L(\"unclosed CDATA section\");\n  case XML_ERROR_EXTERNAL_ENTITY_HANDLING:\n    return XML_L(\"error in processing external entity reference\");\n  case XML_ERROR_NOT_STANDALONE:\n    return XML_L(\"document is not standalone\");\n  case XML_ERROR_UNEXPECTED_STATE:\n    return XML_L(\"unexpected parser state - please send a bug report\");\n  case XML_ERROR_ENTITY_DECLARED_IN_PE:\n    return XML_L(\"entity declared in parameter entity\");\n  case XML_ERROR_FEATURE_REQUIRES_XML_DTD:\n    return XML_L(\"requested feature requires XML_DTD support in Expat\");\n  case XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING:\n    return XML_L(\"cannot change setting once parsing has begun\");\n  /* Added in 1.95.7. */\n  case XML_ERROR_UNBOUND_PREFIX:\n    return XML_L(\"unbound prefix\");\n  /* Added in 1.95.8. */\n  case XML_ERROR_UNDECLARING_PREFIX:\n    return XML_L(\"must not undeclare prefix\");\n  case XML_ERROR_INCOMPLETE_PE:\n    return XML_L(\"incomplete markup in parameter entity\");\n  case XML_ERROR_XML_DECL:\n    return XML_L(\"XML declaration not well-formed\");\n  case XML_ERROR_TEXT_DECL:\n    return XML_L(\"text declaration not well-formed\");\n  case XML_ERROR_PUBLICID:\n    return XML_L(\"illegal character(s) in public id\");\n  case XML_ERROR_SUSPENDED:\n    return XML_L(\"parser suspended\");\n  case XML_ERROR_NOT_SUSPENDED:\n    return XML_L(\"parser not suspended\");\n  case XML_ERROR_ABORTED:\n    return XML_L(\"parsing aborted\");\n  case XML_ERROR_FINISHED:\n    return XML_L(\"parsing finished\");\n  case XML_ERROR_SUSPEND_PE:\n    return XML_L(\"cannot suspend in external parameter entity\");\n  /* Added in 2.0.0. */\n  case XML_ERROR_RESERVED_PREFIX_XML:\n    return XML_L(\n        \"reserved prefix (xml) must not be undeclared or bound to another namespace name\");\n  case XML_ERROR_RESERVED_PREFIX_XMLNS:\n    return XML_L(\"reserved prefix (xmlns) must not be declared or undeclared\");\n  case XML_ERROR_RESERVED_NAMESPACE_URI:\n    return XML_L(\n        \"prefix must not be bound to one of the reserved namespace names\");\n  /* Added in 2.2.5. */\n  case XML_ERROR_INVALID_ARGUMENT: /* Constant added in 2.2.1, already */\n    return XML_L(\"invalid argument\");\n    /* Added in 2.3.0. */\n  case XML_ERROR_NO_BUFFER:\n    return XML_L(\n        \"a successful prior call to function XML_GetBuffer is required\");\n  /* Added in 2.4.0. */\n  case XML_ERROR_AMPLIFICATION_LIMIT_BREACH:\n    return XML_L(\n        \"limit on input amplification factor (from DTD and entities) breached\");\n  }\n  return NULL;\n}\n\nconst XML_LChar *XMLCALL\nXML_ExpatVersion(void) {\n  /* V1 is used to string-ize the version number. However, it would\n     string-ize the actual version macro *names* unless we get them\n     substituted before being passed to V1. CPP is defined to expand\n     a macro, then rescan for more expansions. Thus, we use V2 to expand\n     the version macros, then CPP will expand the resulting V1() macro\n     with the correct numerals. */\n  /* ### I'm assuming cpp is portable in this respect... */\n\n#define V1(a, b, c) XML_L(#a) XML_L(\".\") XML_L(#b) XML_L(\".\") XML_L(#c)\n#define V2(a, b, c) XML_L(\"expat_\") V1(a, b, c)\n\n  return V2(XML_MAJOR_VERSION, XML_MINOR_VERSION, XML_MICRO_VERSION);\n\n#undef V1\n#undef V2\n}\n\nXML_Expat_Version XMLCALL\nXML_ExpatVersionInfo(void) {\n  XML_Expat_Version version;\n\n  version.major = XML_MAJOR_VERSION;\n  version.minor = XML_MINOR_VERSION;\n  version.micro = XML_MICRO_VERSION;\n\n  return version;\n}\n\nconst XML_Feature *XMLCALL\nXML_GetFeatureList(void) {\n  static const XML_Feature features[] = {\n    {XML_FEATURE_SIZEOF_XML_CHAR, XML_L(\"sizeof(XML_Char)\"), sizeof(XML_Char)},\n    {XML_FEATURE_SIZEOF_XML_LCHAR, XML_L(\"sizeof(XML_LChar)\"),\n     sizeof(XML_LChar)},\n#ifdef XML_UNICODE\n    {XML_FEATURE_UNICODE, XML_L(\"XML_UNICODE\"), 0},\n#endif\n#ifdef XML_UNICODE_WCHAR_T\n    {XML_FEATURE_UNICODE_WCHAR_T, XML_L(\"XML_UNICODE_WCHAR_T\"), 0},\n#endif\n#ifdef XML_DTD\n    {XML_FEATURE_DTD, XML_L(\"XML_DTD\"), 0},\n#endif\n#if XML_CONTEXT_BYTES > 0\n    {XML_FEATURE_CONTEXT_BYTES, XML_L(\"XML_CONTEXT_BYTES\"), XML_CONTEXT_BYTES},\n#endif\n#ifdef XML_MIN_SIZE\n    {XML_FEATURE_MIN_SIZE, XML_L(\"XML_MIN_SIZE\"), 0},\n#endif\n#ifdef XML_NS\n    {XML_FEATURE_NS, XML_L(\"XML_NS\"), 0},\n#endif\n#ifdef XML_LARGE_SIZE\n    {XML_FEATURE_LARGE_SIZE, XML_L(\"XML_LARGE_SIZE\"), 0},\n#endif\n#ifdef XML_ATTR_INFO\n    {XML_FEATURE_ATTR_INFO, XML_L(\"XML_ATTR_INFO\"), 0},\n#endif\n#if defined(XML_DTD) || XML_GE == 1\n    /* Added in Expat 2.4.0 for XML_DTD defined and\n     * added in Expat 2.6.0 for XML_GE == 1. */\n    {XML_FEATURE_BILLION_LAUGHS_ATTACK_PROTECTION_MAXIMUM_AMPLIFICATION_DEFAULT,\n     XML_L(\"XML_BLAP_MAX_AMP\"),\n     (long int)\n         EXPAT_BILLION_LAUGHS_ATTACK_PROTECTION_MAXIMUM_AMPLIFICATION_DEFAULT},\n    {XML_FEATURE_BILLION_LAUGHS_ATTACK_PROTECTION_ACTIVATION_THRESHOLD_DEFAULT,\n     XML_L(\"XML_BLAP_ACT_THRES\"),\n     EXPAT_BILLION_LAUGHS_ATTACK_PROTECTION_ACTIVATION_THRESHOLD_DEFAULT},\n#endif\n    {XML_FEATURE_END, NULL, 0}\n  };\n\n  return features;\n}\n\n#if defined(XML_DTD) || XML_GE == 1\nXML_Bool XMLCALL\nXML_SetBillionLaughsAttackProtectionMaximumAmplification(\n    XML_Parser parser, float maximumAmplificationFactor) {\n  if ((parser == NULL) || (parser->m_parentParser != NULL)\n      || isnan(maximumAmplificationFactor)\n      || (maximumAmplificationFactor < 1.0f)) {\n    return XML_FALSE;\n  }\n  parser->m_accounting.maximumAmplificationFactor = maximumAmplificationFactor;\n  return XML_TRUE;\n}\n\nXML_Bool XMLCALL\nXML_SetBillionLaughsAttackProtectionActivationThreshold(\n    XML_Parser parser, unsigned long long activationThresholdBytes) {\n  if ((parser == NULL) || (parser->m_parentParser != NULL)) {\n    return XML_FALSE;\n  }\n  parser->m_accounting.activationThresholdBytes = activationThresholdBytes;\n  return XML_TRUE;\n}\n#endif /* defined(XML_DTD) || XML_GE == 1 */\n\n/* Initially tag->rawName always points into the parse buffer;\n   for those TAG instances opened while the current parse buffer was\n   processed, and not yet closed, we need to store tag->rawName in a more\n   permanent location, since the parse buffer is about to be discarded.\n*/\nstatic XML_Bool\nstoreRawNames(XML_Parser parser) {\n  TAG *tag = parser->m_tagStack;\n  while (tag) {\n    int bufSize;\n    int nameLen = sizeof(XML_Char) * (tag->name.strLen + 1);\n    size_t rawNameLen;\n    char *rawNameBuf = tag->buf + nameLen;\n    /* Stop if already stored.  Since m_tagStack is a stack, we can stop\n       at the first entry that has already been copied; everything\n       below it in the stack is already been accounted for in a\n       previous call to this function.\n    */\n    if (tag->rawName == rawNameBuf)\n      break;\n    /* For reuse purposes we need to ensure that the\n       size of tag->buf is a multiple of sizeof(XML_Char).\n    */\n    rawNameLen = ROUND_UP(tag->rawNameLength, sizeof(XML_Char));\n    /* Detect and prevent integer overflow. */\n    if (rawNameLen > (size_t)INT_MAX - nameLen)\n      return XML_FALSE;\n    bufSize = nameLen + (int)rawNameLen;\n    if (bufSize > tag->bufEnd - tag->buf) {\n      char *temp = (char *)REALLOC(parser, tag->buf, bufSize);\n      if (temp == NULL)\n        return XML_FALSE;\n      /* if tag->name.str points to tag->buf (only when namespace\n         processing is off) then we have to update it\n      */\n      if (tag->name.str == (XML_Char *)tag->buf)\n        tag->name.str = (XML_Char *)temp;\n      /* if tag->name.localPart is set (when namespace processing is on)\n         then update it as well, since it will always point into tag->buf\n      */\n      if (tag->name.localPart)\n        tag->name.localPart\n            = (XML_Char *)temp + (tag->name.localPart - (XML_Char *)tag->buf);\n      tag->buf = temp;\n      tag->bufEnd = temp + bufSize;\n      rawNameBuf = temp + nameLen;\n    }\n    memcpy(rawNameBuf, tag->rawName, tag->rawNameLength);\n    tag->rawName = rawNameBuf;\n    tag = tag->parent;\n  }\n  return XML_TRUE;\n}\n\nstatic enum XML_Error PTRCALL\ncontentProcessor(XML_Parser parser, const char *start, const char *end,\n                 const char **endPtr) {\n  enum XML_Error result = doContent(\n      parser, 0, parser->m_encoding, start, end, endPtr,\n      (XML_Bool)! parser->m_parsingStatus.finalBuffer, XML_ACCOUNT_DIRECT);\n  if (result == XML_ERROR_NONE) {\n    if (! storeRawNames(parser))\n      return XML_ERROR_NO_MEMORY;\n  }\n  return result;\n}\n\nstatic enum XML_Error PTRCALL\nexternalEntityInitProcessor(XML_Parser parser, const char *start,\n                            const char *end, const char **endPtr) {\n  enum XML_Error result = initializeEncoding(parser);\n  if (result != XML_ERROR_NONE)\n    return result;\n  parser->m_processor = externalEntityInitProcessor2;\n  return externalEntityInitProcessor2(parser, start, end, endPtr);\n}\n\nstatic enum XML_Error PTRCALL\nexternalEntityInitProcessor2(XML_Parser parser, const char *start,\n                             const char *end, const char **endPtr) {\n  const char *next = start; /* XmlContentTok doesn't always set the last arg */\n  int tok = XmlContentTok(parser->m_encoding, start, end, &next);\n  switch (tok) {\n  case XML_TOK_BOM:\n#if defined(XML_DTD) || XML_GE == 1\n    if (! accountingDiffTolerated(parser, tok, start, next, __LINE__,\n                                  XML_ACCOUNT_DIRECT)) {\n      accountingOnAbort(parser);\n      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n    }\n#endif /* defined(XML_DTD) || XML_GE == 1 */\n\n    /* If we are at the end of the buffer, this would cause the next stage,\n       i.e. externalEntityInitProcessor3, to pass control directly to\n       doContent (by detecting XML_TOK_NONE) without processing any xml text\n       declaration - causing the error XML_ERROR_MISPLACED_XML_PI in doContent.\n    */\n    if (next == end && ! parser->m_parsingStatus.finalBuffer) {\n      *endPtr = next;\n      return XML_ERROR_NONE;\n    }\n    start = next;\n    break;\n  case XML_TOK_PARTIAL:\n    if (! parser->m_parsingStatus.finalBuffer) {\n      *endPtr = start;\n      return XML_ERROR_NONE;\n    }\n    parser->m_eventPtr = start;\n    return XML_ERROR_UNCLOSED_TOKEN;\n  case XML_TOK_PARTIAL_CHAR:\n    if (! parser->m_parsingStatus.finalBuffer) {\n      *endPtr = start;\n      return XML_ERROR_NONE;\n    }\n    parser->m_eventPtr = start;\n    return XML_ERROR_PARTIAL_CHAR;\n  }\n  parser->m_processor = externalEntityInitProcessor3;\n  return externalEntityInitProcessor3(parser, start, end, endPtr);\n}\n\nstatic enum XML_Error PTRCALL\nexternalEntityInitProcessor3(XML_Parser parser, const char *start,\n                             const char *end, const char **endPtr) {\n  int tok;\n  const char *next = start; /* XmlContentTok doesn't always set the last arg */\n  parser->m_eventPtr = start;\n  tok = XmlContentTok(parser->m_encoding, start, end, &next);\n  /* Note: These bytes are accounted later in:\n           - processXmlDecl\n           - externalEntityContentProcessor\n  */\n  parser->m_eventEndPtr = next;\n\n  switch (tok) {\n  case XML_TOK_XML_DECL: {\n    enum XML_Error result;\n    result = processXmlDecl(parser, 1, start, next);\n    if (result != XML_ERROR_NONE)\n      return result;\n    switch (parser->m_parsingStatus.parsing) {\n    case XML_SUSPENDED:\n      *endPtr = next;\n      return XML_ERROR_NONE;\n    case XML_FINISHED:\n      return XML_ERROR_ABORTED;\n    default:\n      start = next;\n    }\n  } break;\n  case XML_TOK_PARTIAL:\n    if (! parser->m_parsingStatus.finalBuffer) {\n      *endPtr = start;\n      return XML_ERROR_NONE;\n    }\n    return XML_ERROR_UNCLOSED_TOKEN;\n  case XML_TOK_PARTIAL_CHAR:\n    if (! parser->m_parsingStatus.finalBuffer) {\n      *endPtr = start;\n      return XML_ERROR_NONE;\n    }\n    return XML_ERROR_PARTIAL_CHAR;\n  }\n  parser->m_processor = externalEntityContentProcessor;\n  parser->m_tagLevel = 1;\n  return externalEntityContentProcessor(parser, start, end, endPtr);\n}\n\nstatic enum XML_Error PTRCALL\nexternalEntityContentProcessor(XML_Parser parser, const char *start,\n                               const char *end, const char **endPtr) {\n  enum XML_Error result\n      = doContent(parser, 1, parser->m_encoding, start, end, endPtr,\n                  (XML_Bool)! parser->m_parsingStatus.finalBuffer,\n                  XML_ACCOUNT_ENTITY_EXPANSION);\n  if (result == XML_ERROR_NONE) {\n    if (! storeRawNames(parser))\n      return XML_ERROR_NO_MEMORY;\n  }\n  return result;\n}\n\nstatic enum XML_Error\ndoContent(XML_Parser parser, int startTagLevel, const ENCODING *enc,\n          const char *s, const char *end, const char **nextPtr,\n          XML_Bool haveMore, enum XML_Account account) {\n  /* save one level of indirection */\n  DTD *const dtd = parser->m_dtd;\n\n  const char **eventPP;\n  const char **eventEndPP;\n  if (enc == parser->m_encoding) {\n    eventPP = &parser->m_eventPtr;\n    eventEndPP = &parser->m_eventEndPtr;\n  } else {\n    eventPP = &(parser->m_openInternalEntities->internalEventPtr);\n    eventEndPP = &(parser->m_openInternalEntities->internalEventEndPtr);\n  }\n  *eventPP = s;\n\n  for (;;) {\n    const char *next = s; /* XmlContentTok doesn't always set the last arg */\n    int tok = XmlContentTok(enc, s, end, &next);\n#if defined(XML_DTD) || XML_GE == 1\n    const char *accountAfter\n        = ((tok == XML_TOK_TRAILING_RSQB) || (tok == XML_TOK_TRAILING_CR))\n              ? (haveMore ? s /* i.e. 0 bytes */ : end)\n              : next;\n    if (! accountingDiffTolerated(parser, tok, s, accountAfter, __LINE__,\n                                  account)) {\n      accountingOnAbort(parser);\n      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n    }\n#endif\n    *eventEndPP = next;\n    switch (tok) {\n    case XML_TOK_TRAILING_CR:\n      if (haveMore) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      *eventEndPP = end;\n      if (parser->m_characterDataHandler) {\n        XML_Char c = 0xA;\n        parser->m_characterDataHandler(parser->m_handlerArg, &c, 1);\n      } else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, end);\n      /* We are at the end of the final buffer, should we check for\n         XML_SUSPENDED, XML_FINISHED?\n      */\n      if (startTagLevel == 0)\n        return XML_ERROR_NO_ELEMENTS;\n      if (parser->m_tagLevel != startTagLevel)\n        return XML_ERROR_ASYNC_ENTITY;\n      *nextPtr = end;\n      return XML_ERROR_NONE;\n    case XML_TOK_NONE:\n      if (haveMore) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      if (startTagLevel > 0) {\n        if (parser->m_tagLevel != startTagLevel)\n          return XML_ERROR_ASYNC_ENTITY;\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      return XML_ERROR_NO_ELEMENTS;\n    case XML_TOK_INVALID:\n      *eventPP = next;\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_PARTIAL:\n      if (haveMore) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      return XML_ERROR_UNCLOSED_TOKEN;\n    case XML_TOK_PARTIAL_CHAR:\n      if (haveMore) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      return XML_ERROR_PARTIAL_CHAR;\n    case XML_TOK_ENTITY_REF: {\n      const XML_Char *name;\n      ENTITY *entity;\n      XML_Char ch = (XML_Char)XmlPredefinedEntityName(\n          enc, s + enc->minBytesPerChar, next - enc->minBytesPerChar);\n      if (ch) {\n#if defined(XML_DTD) || XML_GE == 1\n        /* NOTE: We are replacing 4-6 characters original input for 1 character\n         *       so there is no amplification and hence recording without\n         *       protection. */\n        accountingDiffTolerated(parser, tok, (char *)&ch,\n                                ((char *)&ch) + sizeof(XML_Char), __LINE__,\n                                XML_ACCOUNT_ENTITY_EXPANSION);\n#endif /* defined(XML_DTD) || XML_GE == 1 */\n        if (parser->m_characterDataHandler)\n          parser->m_characterDataHandler(parser->m_handlerArg, &ch, 1);\n        else if (parser->m_defaultHandler)\n          reportDefault(parser, enc, s, next);\n        break;\n      }\n      name = poolStoreString(&dtd->pool, enc, s + enc->minBytesPerChar,\n                             next - enc->minBytesPerChar);\n      if (! name)\n        return XML_ERROR_NO_MEMORY;\n      entity = (ENTITY *)lookup(parser, &dtd->generalEntities, name, 0);\n      poolDiscard(&dtd->pool);\n      /* First, determine if a check for an existing declaration is needed;\n         if yes, check that the entity exists, and that it is internal,\n         otherwise call the skipped entity or default handler.\n      */\n      if (! dtd->hasParamEntityRefs || dtd->standalone) {\n        if (! entity)\n          return XML_ERROR_UNDEFINED_ENTITY;\n        else if (! entity->is_internal)\n          return XML_ERROR_ENTITY_DECLARED_IN_PE;\n      } else if (! entity) {\n        if (parser->m_skippedEntityHandler)\n          parser->m_skippedEntityHandler(parser->m_handlerArg, name, 0);\n        else if (parser->m_defaultHandler)\n          reportDefault(parser, enc, s, next);\n        break;\n      }\n      if (entity->open)\n        return XML_ERROR_RECURSIVE_ENTITY_REF;\n      if (entity->notation)\n        return XML_ERROR_BINARY_ENTITY_REF;\n      if (entity->textPtr) {\n        enum XML_Error result;\n        if (! parser->m_defaultExpandInternalEntities) {\n          if (parser->m_skippedEntityHandler)\n            parser->m_skippedEntityHandler(parser->m_handlerArg, entity->name,\n                                           0);\n          else if (parser->m_defaultHandler)\n            reportDefault(parser, enc, s, next);\n          break;\n        }\n        result = processInternalEntity(parser, entity, XML_FALSE);\n        if (result != XML_ERROR_NONE)\n          return result;\n      } else if (parser->m_externalEntityRefHandler) {\n        const XML_Char *context;\n        entity->open = XML_TRUE;\n        context = getContext(parser);\n        entity->open = XML_FALSE;\n        if (! context)\n          return XML_ERROR_NO_MEMORY;\n        if (! parser->m_externalEntityRefHandler(\n                parser->m_externalEntityRefHandlerArg, context, entity->base,\n                entity->systemId, entity->publicId))\n          return XML_ERROR_EXTERNAL_ENTITY_HANDLING;\n        poolDiscard(&parser->m_tempPool);\n      } else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n      break;\n    }\n    case XML_TOK_START_TAG_NO_ATTS:\n      /* fall through */\n    case XML_TOK_START_TAG_WITH_ATTS: {\n      TAG *tag;\n      enum XML_Error result;\n      XML_Char *toPtr;\n      if (parser->m_freeTagList) {\n        tag = parser->m_freeTagList;\n        parser->m_freeTagList = parser->m_freeTagList->parent;\n      } else {\n        tag = (TAG *)MALLOC(parser, sizeof(TAG));\n        if (! tag)\n          return XML_ERROR_NO_MEMORY;\n        tag->buf = (char *)MALLOC(parser, INIT_TAG_BUF_SIZE);\n        if (! tag->buf) {\n          FREE(parser, tag);\n          return XML_ERROR_NO_MEMORY;\n        }\n        tag->bufEnd = tag->buf + INIT_TAG_BUF_SIZE;\n      }\n      tag->bindings = NULL;\n      tag->parent = parser->m_tagStack;\n      parser->m_tagStack = tag;\n      tag->name.localPart = NULL;\n      tag->name.prefix = NULL;\n      tag->rawName = s + enc->minBytesPerChar;\n      tag->rawNameLength = XmlNameLength(enc, tag->rawName);\n      ++parser->m_tagLevel;\n      {\n        const char *rawNameEnd = tag->rawName + tag->rawNameLength;\n        const char *fromPtr = tag->rawName;\n        toPtr = (XML_Char *)tag->buf;\n        for (;;) {\n          int bufSize;\n          int convLen;\n          const enum XML_Convert_Result convert_res\n              = XmlConvert(enc, &fromPtr, rawNameEnd, (ICHAR **)&toPtr,\n                           (ICHAR *)tag->bufEnd - 1);\n          convLen = (int)(toPtr - (XML_Char *)tag->buf);\n          if ((fromPtr >= rawNameEnd)\n              || (convert_res == XML_CONVERT_INPUT_INCOMPLETE)) {\n            tag->name.strLen = convLen;\n            break;\n          }\n          bufSize = (int)(tag->bufEnd - tag->buf) << 1;\n          {\n            char *temp = (char *)REALLOC(parser, tag->buf, bufSize);\n            if (temp == NULL)\n              return XML_ERROR_NO_MEMORY;\n            tag->buf = temp;\n            tag->bufEnd = temp + bufSize;\n            toPtr = (XML_Char *)temp + convLen;\n          }\n        }\n      }\n      tag->name.str = (XML_Char *)tag->buf;\n      *toPtr = XML_T('\\0');\n      result\n          = storeAtts(parser, enc, s, &(tag->name), &(tag->bindings), account);\n      if (result)\n        return result;\n      if (parser->m_startElementHandler)\n        parser->m_startElementHandler(parser->m_handlerArg, tag->name.str,\n                                      (const XML_Char **)parser->m_atts);\n      else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n      poolClear(&parser->m_tempPool);\n      break;\n    }\n    case XML_TOK_EMPTY_ELEMENT_NO_ATTS:\n      /* fall through */\n    case XML_TOK_EMPTY_ELEMENT_WITH_ATTS: {\n      const char *rawName = s + enc->minBytesPerChar;\n      enum XML_Error result;\n      BINDING *bindings = NULL;\n      XML_Bool noElmHandlers = XML_TRUE;\n      TAG_NAME name;\n      name.str = poolStoreString(&parser->m_tempPool, enc, rawName,\n                                 rawName + XmlNameLength(enc, rawName));\n      if (! name.str)\n        return XML_ERROR_NO_MEMORY;\n      poolFinish(&parser->m_tempPool);\n      result = storeAtts(parser, enc, s, &name, &bindings,\n                         XML_ACCOUNT_NONE /* token spans whole start tag */);\n      if (result != XML_ERROR_NONE) {\n        freeBindings(parser, bindings);\n        return result;\n      }\n      poolFinish(&parser->m_tempPool);\n      if (parser->m_startElementHandler) {\n        parser->m_startElementHandler(parser->m_handlerArg, name.str,\n                                      (const XML_Char **)parser->m_atts);\n        noElmHandlers = XML_FALSE;\n      }\n      if (parser->m_endElementHandler) {\n        if (parser->m_startElementHandler)\n          *eventPP = *eventEndPP;\n        parser->m_endElementHandler(parser->m_handlerArg, name.str);\n        noElmHandlers = XML_FALSE;\n      }\n      if (noElmHandlers && parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n      poolClear(&parser->m_tempPool);\n      freeBindings(parser, bindings);\n    }\n      if ((parser->m_tagLevel == 0)\n          && (parser->m_parsingStatus.parsing != XML_FINISHED)) {\n        if (parser->m_parsingStatus.parsing == XML_SUSPENDED)\n          parser->m_processor = epilogProcessor;\n        else\n          return epilogProcessor(parser, next, end, nextPtr);\n      }\n      break;\n    case XML_TOK_END_TAG:\n      if (parser->m_tagLevel == startTagLevel)\n        return XML_ERROR_ASYNC_ENTITY;\n      else {\n        int len;\n        const char *rawName;\n        TAG *tag = parser->m_tagStack;\n        rawName = s + enc->minBytesPerChar * 2;\n        len = XmlNameLength(enc, rawName);\n        if (len != tag->rawNameLength\n            || memcmp(tag->rawName, rawName, len) != 0) {\n          *eventPP = rawName;\n          return XML_ERROR_TAG_MISMATCH;\n        }\n        parser->m_tagStack = tag->parent;\n        tag->parent = parser->m_freeTagList;\n        parser->m_freeTagList = tag;\n        --parser->m_tagLevel;\n        if (parser->m_endElementHandler) {\n          const XML_Char *localPart;\n          const XML_Char *prefix;\n          XML_Char *uri;\n          localPart = tag->name.localPart;\n          if (parser->m_ns && localPart) {\n            /* localPart and prefix may have been overwritten in\n               tag->name.str, since this points to the binding->uri\n               buffer which gets reused; so we have to add them again\n            */\n            uri = (XML_Char *)tag->name.str + tag->name.uriLen;\n            /* don't need to check for space - already done in storeAtts() */\n            while (*localPart)\n              *uri++ = *localPart++;\n            prefix = tag->name.prefix;\n            if (parser->m_ns_triplets && prefix) {\n              *uri++ = parser->m_namespaceSeparator;\n              while (*prefix)\n                *uri++ = *prefix++;\n            }\n            *uri = XML_T('\\0');\n          }\n          parser->m_endElementHandler(parser->m_handlerArg, tag->name.str);\n        } else if (parser->m_defaultHandler)\n          reportDefault(parser, enc, s, next);\n        while (tag->bindings) {\n          BINDING *b = tag->bindings;\n          if (parser->m_endNamespaceDeclHandler)\n            parser->m_endNamespaceDeclHandler(parser->m_handlerArg,\n                                              b->prefix->name);\n          tag->bindings = tag->bindings->nextTagBinding;\n          b->nextTagBinding = parser->m_freeBindingList;\n          parser->m_freeBindingList = b;\n          b->prefix->binding = b->prevPrefixBinding;\n        }\n        if ((parser->m_tagLevel == 0)\n            && (parser->m_parsingStatus.parsing != XML_FINISHED)) {\n          if (parser->m_parsingStatus.parsing == XML_SUSPENDED)\n            parser->m_processor = epilogProcessor;\n          else\n            return epilogProcessor(parser, next, end, nextPtr);\n        }\n      }\n      break;\n    case XML_TOK_CHAR_REF: {\n      int n = XmlCharRefNumber(enc, s);\n      if (n < 0)\n        return XML_ERROR_BAD_CHAR_REF;\n      if (parser->m_characterDataHandler) {\n        XML_Char buf[XML_ENCODE_MAX];\n        parser->m_characterDataHandler(parser->m_handlerArg, buf,\n                                       XmlEncode(n, (ICHAR *)buf));\n      } else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n    } break;\n    case XML_TOK_XML_DECL:\n      return XML_ERROR_MISPLACED_XML_PI;\n    case XML_TOK_DATA_NEWLINE:\n      if (parser->m_characterDataHandler) {\n        XML_Char c = 0xA;\n        parser->m_characterDataHandler(parser->m_handlerArg, &c, 1);\n      } else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n      break;\n    case XML_TOK_CDATA_SECT_OPEN: {\n      enum XML_Error result;\n      if (parser->m_startCdataSectionHandler)\n        parser->m_startCdataSectionHandler(parser->m_handlerArg);\n      /* BEGIN disabled code */\n      /* Suppose you doing a transformation on a document that involves\n         changing only the character data.  You set up a defaultHandler\n         and a characterDataHandler.  The defaultHandler simply copies\n         characters through.  The characterDataHandler does the\n         transformation and writes the characters out escaping them as\n         necessary.  This case will fail to work if we leave out the\n         following two lines (because & and < inside CDATA sections will\n         be incorrectly escaped).\n\n         However, now we have a start/endCdataSectionHandler, so it seems\n         easier to let the user deal with this.\n      */\n      else if ((0) && parser->m_characterDataHandler)\n        parser->m_characterDataHandler(parser->m_handlerArg, parser->m_dataBuf,\n                                       0);\n      /* END disabled code */\n      else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n      result\n          = doCdataSection(parser, enc, &next, end, nextPtr, haveMore, account);\n      if (result != XML_ERROR_NONE)\n        return result;\n      else if (! next) {\n        parser->m_processor = cdataSectionProcessor;\n        return result;\n      }\n    } break;\n    case XML_TOK_TRAILING_RSQB:\n      if (haveMore) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      if (parser->m_characterDataHandler) {\n        if (MUST_CONVERT(enc, s)) {\n          ICHAR *dataPtr = (ICHAR *)parser->m_dataBuf;\n          XmlConvert(enc, &s, end, &dataPtr, (ICHAR *)parser->m_dataBufEnd);\n          parser->m_characterDataHandler(\n              parser->m_handlerArg, parser->m_dataBuf,\n              (int)(dataPtr - (ICHAR *)parser->m_dataBuf));\n        } else\n          parser->m_characterDataHandler(\n              parser->m_handlerArg, (const XML_Char *)s,\n              (int)((const XML_Char *)end - (const XML_Char *)s));\n      } else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, end);\n      /* We are at the end of the final buffer, should we check for\n         XML_SUSPENDED, XML_FINISHED?\n      */\n      if (startTagLevel == 0) {\n        *eventPP = end;\n        return XML_ERROR_NO_ELEMENTS;\n      }\n      if (parser->m_tagLevel != startTagLevel) {\n        *eventPP = end;\n        return XML_ERROR_ASYNC_ENTITY;\n      }\n      *nextPtr = end;\n      return XML_ERROR_NONE;\n    case XML_TOK_DATA_CHARS: {\n      XML_CharacterDataHandler charDataHandler = parser->m_characterDataHandler;\n      if (charDataHandler) {\n        if (MUST_CONVERT(enc, s)) {\n          for (;;) {\n            ICHAR *dataPtr = (ICHAR *)parser->m_dataBuf;\n            const enum XML_Convert_Result convert_res = XmlConvert(\n                enc, &s, next, &dataPtr, (ICHAR *)parser->m_dataBufEnd);\n            *eventEndPP = s;\n            charDataHandler(parser->m_handlerArg, parser->m_dataBuf,\n                            (int)(dataPtr - (ICHAR *)parser->m_dataBuf));\n            if ((convert_res == XML_CONVERT_COMPLETED)\n                || (convert_res == XML_CONVERT_INPUT_INCOMPLETE))\n              break;\n            *eventPP = s;\n          }\n        } else\n          charDataHandler(parser->m_handlerArg, (const XML_Char *)s,\n                          (int)((const XML_Char *)next - (const XML_Char *)s));\n      } else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n    } break;\n    case XML_TOK_PI:\n      if (! reportProcessingInstruction(parser, enc, s, next))\n        return XML_ERROR_NO_MEMORY;\n      break;\n    case XML_TOK_COMMENT:\n      if (! reportComment(parser, enc, s, next))\n        return XML_ERROR_NO_MEMORY;\n      break;\n    default:\n      /* All of the tokens produced by XmlContentTok() have their own\n       * explicit cases, so this default is not strictly necessary.\n       * However it is a useful safety net, so we retain the code and\n       * simply exclude it from the coverage tests.\n       *\n       * LCOV_EXCL_START\n       */\n      if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n      break;\n      /* LCOV_EXCL_STOP */\n    }\n    *eventPP = s = next;\n    switch (parser->m_parsingStatus.parsing) {\n    case XML_SUSPENDED:\n      *nextPtr = next;\n      return XML_ERROR_NONE;\n    case XML_FINISHED:\n      return XML_ERROR_ABORTED;\n    default:;\n    }\n  }\n  /* not reached */\n}\n\n/* This function does not call free() on the allocated memory, merely\n * moving it to the parser's m_freeBindingList where it can be freed or\n * reused as appropriate.\n */\nstatic void\nfreeBindings(XML_Parser parser, BINDING *bindings) {\n  while (bindings) {\n    BINDING *b = bindings;\n\n    /* m_startNamespaceDeclHandler will have been called for this\n     * binding in addBindings(), so call the end handler now.\n     */\n    if (parser->m_endNamespaceDeclHandler)\n      parser->m_endNamespaceDeclHandler(parser->m_handlerArg, b->prefix->name);\n\n    bindings = bindings->nextTagBinding;\n    b->nextTagBinding = parser->m_freeBindingList;\n    parser->m_freeBindingList = b;\n    b->prefix->binding = b->prevPrefixBinding;\n  }\n}\n\n/* Precondition: all arguments must be non-NULL;\n   Purpose:\n   - normalize attributes\n   - check attributes for well-formedness\n   - generate namespace aware attribute names (URI, prefix)\n   - build list of attributes for startElementHandler\n   - default attributes\n   - process namespace declarations (check and report them)\n   - generate namespace aware element name (URI, prefix)\n*/\nstatic enum XML_Error\nstoreAtts(XML_Parser parser, const ENCODING *enc, const char *attStr,\n          TAG_NAME *tagNamePtr, BINDING **bindingsPtr,\n          enum XML_Account account) {\n  DTD *const dtd = parser->m_dtd; /* save one level of indirection */\n  ELEMENT_TYPE *elementType;\n  int nDefaultAtts;\n  const XML_Char **appAtts; /* the attribute list for the application */\n  int attIndex = 0;\n  int prefixLen;\n  int i;\n  int n;\n  XML_Char *uri;\n  int nPrefixes = 0;\n  BINDING *binding;\n  const XML_Char *localPart;\n\n  /* lookup the element type name */\n  elementType\n      = (ELEMENT_TYPE *)lookup(parser, &dtd->elementTypes, tagNamePtr->str, 0);\n  if (! elementType) {\n    const XML_Char *name = poolCopyString(&dtd->pool, tagNamePtr->str);\n    if (! name)\n      return XML_ERROR_NO_MEMORY;\n    elementType = (ELEMENT_TYPE *)lookup(parser, &dtd->elementTypes, name,\n                                         sizeof(ELEMENT_TYPE));\n    if (! elementType)\n      return XML_ERROR_NO_MEMORY;\n    if (parser->m_ns && ! setElementTypePrefix(parser, elementType))\n      return XML_ERROR_NO_MEMORY;\n  }\n  nDefaultAtts = elementType->nDefaultAtts;\n\n  /* get the attributes from the tokenizer */\n  n = XmlGetAttributes(enc, attStr, parser->m_attsSize, parser->m_atts);\n\n  /* Detect and prevent integer overflow */\n  if (n > INT_MAX - nDefaultAtts) {\n    return XML_ERROR_NO_MEMORY;\n  }\n\n  if (n + nDefaultAtts > parser->m_attsSize) {\n    int oldAttsSize = parser->m_attsSize;\n    ATTRIBUTE *temp;\n#ifdef XML_ATTR_INFO\n    XML_AttrInfo *temp2;\n#endif\n\n    /* Detect and prevent integer overflow */\n    if ((nDefaultAtts > INT_MAX - INIT_ATTS_SIZE)\n        || (n > INT_MAX - (nDefaultAtts + INIT_ATTS_SIZE))) {\n      return XML_ERROR_NO_MEMORY;\n    }\n\n    parser->m_attsSize = n + nDefaultAtts + INIT_ATTS_SIZE;\n\n    /* Detect and prevent integer overflow.\n     * The preprocessor guard addresses the \"always false\" warning\n     * from -Wtype-limits on platforms where\n     * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */\n#if UINT_MAX >= SIZE_MAX\n    if ((unsigned)parser->m_attsSize > (size_t)(-1) / sizeof(ATTRIBUTE)) {\n      parser->m_attsSize = oldAttsSize;\n      return XML_ERROR_NO_MEMORY;\n    }\n#endif\n\n    temp = (ATTRIBUTE *)REALLOC(parser, (void *)parser->m_atts,\n                                parser->m_attsSize * sizeof(ATTRIBUTE));\n    if (temp == NULL) {\n      parser->m_attsSize = oldAttsSize;\n      return XML_ERROR_NO_MEMORY;\n    }\n    parser->m_atts = temp;\n#ifdef XML_ATTR_INFO\n    /* Detect and prevent integer overflow.\n     * The preprocessor guard addresses the \"always false\" warning\n     * from -Wtype-limits on platforms where\n     * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */\n#  if UINT_MAX >= SIZE_MAX\n    if ((unsigned)parser->m_attsSize > (size_t)(-1) / sizeof(XML_AttrInfo)) {\n      parser->m_attsSize = oldAttsSize;\n      return XML_ERROR_NO_MEMORY;\n    }\n#  endif\n\n    temp2 = (XML_AttrInfo *)REALLOC(parser, (void *)parser->m_attInfo,\n                                    parser->m_attsSize * sizeof(XML_AttrInfo));\n    if (temp2 == NULL) {\n      parser->m_attsSize = oldAttsSize;\n      return XML_ERROR_NO_MEMORY;\n    }\n    parser->m_attInfo = temp2;\n#endif\n    if (n > oldAttsSize)\n      XmlGetAttributes(enc, attStr, n, parser->m_atts);\n  }\n\n  appAtts = (const XML_Char **)parser->m_atts;\n  for (i = 0; i < n; i++) {\n    ATTRIBUTE *currAtt = &parser->m_atts[i];\n#ifdef XML_ATTR_INFO\n    XML_AttrInfo *currAttInfo = &parser->m_attInfo[i];\n#endif\n    /* add the name and value to the attribute list */\n    ATTRIBUTE_ID *attId\n        = getAttributeId(parser, enc, currAtt->name,\n                         currAtt->name + XmlNameLength(enc, currAtt->name));\n    if (! attId)\n      return XML_ERROR_NO_MEMORY;\n#ifdef XML_ATTR_INFO\n    currAttInfo->nameStart\n        = parser->m_parseEndByteIndex - (parser->m_parseEndPtr - currAtt->name);\n    currAttInfo->nameEnd\n        = currAttInfo->nameStart + XmlNameLength(enc, currAtt->name);\n    currAttInfo->valueStart = parser->m_parseEndByteIndex\n                              - (parser->m_parseEndPtr - currAtt->valuePtr);\n    currAttInfo->valueEnd = parser->m_parseEndByteIndex\n                            - (parser->m_parseEndPtr - currAtt->valueEnd);\n#endif\n    /* Detect duplicate attributes by their QNames. This does not work when\n       namespace processing is turned on and different prefixes for the same\n       namespace are used. For this case we have a check further down.\n    */\n    if ((attId->name)[-1]) {\n      if (enc == parser->m_encoding)\n        parser->m_eventPtr = parser->m_atts[i].name;\n      return XML_ERROR_DUPLICATE_ATTRIBUTE;\n    }\n    (attId->name)[-1] = 1;\n    appAtts[attIndex++] = attId->name;\n    if (! parser->m_atts[i].normalized) {\n      enum XML_Error result;\n      XML_Bool isCdata = XML_TRUE;\n\n      /* figure out whether declared as other than CDATA */\n      if (attId->maybeTokenized) {\n        int j;\n        for (j = 0; j < nDefaultAtts; j++) {\n          if (attId == elementType->defaultAtts[j].id) {\n            isCdata = elementType->defaultAtts[j].isCdata;\n            break;\n          }\n        }\n      }\n\n      /* normalize the attribute value */\n      result = storeAttributeValue(\n          parser, enc, isCdata, parser->m_atts[i].valuePtr,\n          parser->m_atts[i].valueEnd, &parser->m_tempPool, account);\n      if (result)\n        return result;\n      appAtts[attIndex] = poolStart(&parser->m_tempPool);\n      poolFinish(&parser->m_tempPool);\n    } else {\n      /* the value did not need normalizing */\n      appAtts[attIndex] = poolStoreString(&parser->m_tempPool, enc,\n                                          parser->m_atts[i].valuePtr,\n                                          parser->m_atts[i].valueEnd);\n      if (appAtts[attIndex] == 0)\n        return XML_ERROR_NO_MEMORY;\n      poolFinish(&parser->m_tempPool);\n    }\n    /* handle prefixed attribute names */\n    if (attId->prefix) {\n      if (attId->xmlns) {\n        /* deal with namespace declarations here */\n        enum XML_Error result = addBinding(parser, attId->prefix, attId,\n                                           appAtts[attIndex], bindingsPtr);\n        if (result)\n          return result;\n        --attIndex;\n      } else {\n        /* deal with other prefixed names later */\n        attIndex++;\n        nPrefixes++;\n        (attId->name)[-1] = 2;\n      }\n    } else\n      attIndex++;\n  }\n\n  /* set-up for XML_GetSpecifiedAttributeCount and XML_GetIdAttributeIndex */\n  parser->m_nSpecifiedAtts = attIndex;\n  if (elementType->idAtt && (elementType->idAtt->name)[-1]) {\n    for (i = 0; i < attIndex; i += 2)\n      if (appAtts[i] == elementType->idAtt->name) {\n        parser->m_idAttIndex = i;\n        break;\n      }\n  } else\n    parser->m_idAttIndex = -1;\n\n  /* do attribute defaulting */\n  for (i = 0; i < nDefaultAtts; i++) {\n    const DEFAULT_ATTRIBUTE *da = elementType->defaultAtts + i;\n    if (! (da->id->name)[-1] && da->value) {\n      if (da->id->prefix) {\n        if (da->id->xmlns) {\n          enum XML_Error result = addBinding(parser, da->id->prefix, da->id,\n                                             da->value, bindingsPtr);\n          if (result)\n            return result;\n        } else {\n          (da->id->name)[-1] = 2;\n          nPrefixes++;\n          appAtts[attIndex++] = da->id->name;\n          appAtts[attIndex++] = da->value;\n        }\n      } else {\n        (da->id->name)[-1] = 1;\n        appAtts[attIndex++] = da->id->name;\n        appAtts[attIndex++] = da->value;\n      }\n    }\n  }\n  appAtts[attIndex] = 0;\n\n  /* expand prefixed attribute names, check for duplicates,\n     and clear flags that say whether attributes were specified */\n  i = 0;\n  if (nPrefixes) {\n    int j; /* hash table index */\n    unsigned long version = parser->m_nsAttsVersion;\n\n    /* Detect and prevent invalid shift */\n    if (parser->m_nsAttsPower >= sizeof(unsigned int) * 8 /* bits per byte */) {\n      return XML_ERROR_NO_MEMORY;\n    }\n\n    unsigned int nsAttsSize = 1u << parser->m_nsAttsPower;\n    unsigned char oldNsAttsPower = parser->m_nsAttsPower;\n    /* size of hash table must be at least 2 * (# of prefixed attributes) */\n    if ((nPrefixes << 1)\n        >> parser->m_nsAttsPower) { /* true for m_nsAttsPower = 0 */\n      NS_ATT *temp;\n      /* hash table size must also be a power of 2 and >= 8 */\n      while (nPrefixes >> parser->m_nsAttsPower++)\n        ;\n      if (parser->m_nsAttsPower < 3)\n        parser->m_nsAttsPower = 3;\n\n      /* Detect and prevent invalid shift */\n      if (parser->m_nsAttsPower >= sizeof(nsAttsSize) * 8 /* bits per byte */) {\n        /* Restore actual size of memory in m_nsAtts */\n        parser->m_nsAttsPower = oldNsAttsPower;\n        return XML_ERROR_NO_MEMORY;\n      }\n\n      nsAttsSize = 1u << parser->m_nsAttsPower;\n\n      /* Detect and prevent integer overflow.\n       * The preprocessor guard addresses the \"always false\" warning\n       * from -Wtype-limits on platforms where\n       * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */\n#if UINT_MAX >= SIZE_MAX\n      if (nsAttsSize > (size_t)(-1) / sizeof(NS_ATT)) {\n        /* Restore actual size of memory in m_nsAtts */\n        parser->m_nsAttsPower = oldNsAttsPower;\n        return XML_ERROR_NO_MEMORY;\n      }\n#endif\n\n      temp = (NS_ATT *)REALLOC(parser, parser->m_nsAtts,\n                               nsAttsSize * sizeof(NS_ATT));\n      if (! temp) {\n        /* Restore actual size of memory in m_nsAtts */\n        parser->m_nsAttsPower = oldNsAttsPower;\n        return XML_ERROR_NO_MEMORY;\n      }\n      parser->m_nsAtts = temp;\n      version = 0; /* force re-initialization of m_nsAtts hash table */\n    }\n    /* using a version flag saves us from initializing m_nsAtts every time */\n    if (! version) { /* initialize version flags when version wraps around */\n      version = INIT_ATTS_VERSION;\n      for (j = nsAttsSize; j != 0;)\n        parser->m_nsAtts[--j].version = version;\n    }\n    parser->m_nsAttsVersion = --version;\n\n    /* expand prefixed names and check for duplicates */\n    for (; i < attIndex; i += 2) {\n      const XML_Char *s = appAtts[i];\n      if (s[-1] == 2) { /* prefixed */\n        ATTRIBUTE_ID *id;\n        const BINDING *b;\n        unsigned long uriHash;\n        struct siphash sip_state;\n        struct sipkey sip_key;\n\n        copy_salt_to_sipkey(parser, &sip_key);\n        sip24_init(&sip_state, &sip_key);\n\n        ((XML_Char *)s)[-1] = 0; /* clear flag */\n        id = (ATTRIBUTE_ID *)lookup(parser, &dtd->attributeIds, s, 0);\n        if (! id || ! id->prefix) {\n          /* This code is walking through the appAtts array, dealing\n           * with (in this case) a prefixed attribute name.  To be in\n           * the array, the attribute must have already been bound, so\n           * has to have passed through the hash table lookup once\n           * already.  That implies that an entry for it already\n           * exists, so the lookup above will return a pointer to\n           * already allocated memory.  There is no opportunaity for\n           * the allocator to fail, so the condition above cannot be\n           * fulfilled.\n           *\n           * Since it is difficult to be certain that the above\n           * analysis is complete, we retain the test and merely\n           * remove the code from coverage tests.\n           */\n          return XML_ERROR_NO_MEMORY; /* LCOV_EXCL_LINE */\n        }\n        b = id->prefix->binding;\n        if (! b)\n          return XML_ERROR_UNBOUND_PREFIX;\n\n        for (j = 0; j < b->uriLen; j++) {\n          const XML_Char c = b->uri[j];\n          if (! poolAppendChar(&parser->m_tempPool, c))\n            return XML_ERROR_NO_MEMORY;\n        }\n\n        sip24_update(&sip_state, b->uri, b->uriLen * sizeof(XML_Char));\n\n        while (*s++ != XML_T(ASCII_COLON))\n          ;\n\n        sip24_update(&sip_state, s, keylen(s) * sizeof(XML_Char));\n\n        do { /* copies null terminator */\n          if (! poolAppendChar(&parser->m_tempPool, *s))\n            return XML_ERROR_NO_MEMORY;\n        } while (*s++);\n\n        uriHash = (unsigned long)sip24_final(&sip_state);\n\n        { /* Check hash table for duplicate of expanded name (uriName).\n             Derived from code in lookup(parser, HASH_TABLE *table, ...).\n          */\n          unsigned char step = 0;\n          unsigned long mask = nsAttsSize - 1;\n          j = uriHash & mask; /* index into hash table */\n          while (parser->m_nsAtts[j].version == version) {\n            /* for speed we compare stored hash values first */\n            if (uriHash == parser->m_nsAtts[j].hash) {\n              const XML_Char *s1 = poolStart(&parser->m_tempPool);\n              const XML_Char *s2 = parser->m_nsAtts[j].uriName;\n              /* s1 is null terminated, but not s2 */\n              for (; *s1 == *s2 && *s1 != 0; s1++, s2++)\n                ;\n              if (*s1 == 0)\n                return XML_ERROR_DUPLICATE_ATTRIBUTE;\n            }\n            if (! step)\n              step = PROBE_STEP(uriHash, mask, parser->m_nsAttsPower);\n            j < step ? (j += nsAttsSize - step) : (j -= step);\n          }\n        }\n\n        if (parser->m_ns_triplets) { /* append namespace separator and prefix */\n          parser->m_tempPool.ptr[-1] = parser->m_namespaceSeparator;\n          s = b->prefix->name;\n          do {\n            if (! poolAppendChar(&parser->m_tempPool, *s))\n              return XML_ERROR_NO_MEMORY;\n          } while (*s++);\n        }\n\n        /* store expanded name in attribute list */\n        s = poolStart(&parser->m_tempPool);\n        poolFinish(&parser->m_tempPool);\n        appAtts[i] = s;\n\n        /* fill empty slot with new version, uriName and hash value */\n        parser->m_nsAtts[j].version = version;\n        parser->m_nsAtts[j].hash = uriHash;\n        parser->m_nsAtts[j].uriName = s;\n\n        if (! --nPrefixes) {\n          i += 2;\n          break;\n        }\n      } else                     /* not prefixed */\n        ((XML_Char *)s)[-1] = 0; /* clear flag */\n    }\n  }\n  /* clear flags for the remaining attributes */\n  for (; i < attIndex; i += 2)\n    ((XML_Char *)(appAtts[i]))[-1] = 0;\n  for (binding = *bindingsPtr; binding; binding = binding->nextTagBinding)\n    binding->attId->name[-1] = 0;\n\n  if (! parser->m_ns)\n    return XML_ERROR_NONE;\n\n  /* expand the element type name */\n  if (elementType->prefix) {\n    binding = elementType->prefix->binding;\n    if (! binding)\n      return XML_ERROR_UNBOUND_PREFIX;\n    localPart = tagNamePtr->str;\n    while (*localPart++ != XML_T(ASCII_COLON))\n      ;\n  } else if (dtd->defaultPrefix.binding) {\n    binding = dtd->defaultPrefix.binding;\n    localPart = tagNamePtr->str;\n  } else\n    return XML_ERROR_NONE;\n  prefixLen = 0;\n  if (parser->m_ns_triplets && binding->prefix->name) {\n    for (; binding->prefix->name[prefixLen++];)\n      ; /* prefixLen includes null terminator */\n  }\n  tagNamePtr->localPart = localPart;\n  tagNamePtr->uriLen = binding->uriLen;\n  tagNamePtr->prefix = binding->prefix->name;\n  tagNamePtr->prefixLen = prefixLen;\n  for (i = 0; localPart[i++];)\n    ; /* i includes null terminator */\n\n  /* Detect and prevent integer overflow */\n  if (binding->uriLen > INT_MAX - prefixLen\n      || i > INT_MAX - (binding->uriLen + prefixLen)) {\n    return XML_ERROR_NO_MEMORY;\n  }\n\n  n = i + binding->uriLen + prefixLen;\n  if (n > binding->uriAlloc) {\n    TAG *p;\n\n    /* Detect and prevent integer overflow */\n    if (n > INT_MAX - EXPAND_SPARE) {\n      return XML_ERROR_NO_MEMORY;\n    }\n    /* Detect and prevent integer overflow.\n     * The preprocessor guard addresses the \"always false\" warning\n     * from -Wtype-limits on platforms where\n     * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */\n#if UINT_MAX >= SIZE_MAX\n    if ((unsigned)(n + EXPAND_SPARE) > (size_t)(-1) / sizeof(XML_Char)) {\n      return XML_ERROR_NO_MEMORY;\n    }\n#endif\n\n    uri = (XML_Char *)MALLOC(parser, (n + EXPAND_SPARE) * sizeof(XML_Char));\n    if (! uri)\n      return XML_ERROR_NO_MEMORY;\n    binding->uriAlloc = n + EXPAND_SPARE;\n    memcpy(uri, binding->uri, binding->uriLen * sizeof(XML_Char));\n    for (p = parser->m_tagStack; p; p = p->parent)\n      if (p->name.str == binding->uri)\n        p->name.str = uri;\n    FREE(parser, binding->uri);\n    binding->uri = uri;\n  }\n  /* if m_namespaceSeparator != '\\0' then uri includes it already */\n  uri = binding->uri + binding->uriLen;\n  memcpy(uri, localPart, i * sizeof(XML_Char));\n  /* we always have a namespace separator between localPart and prefix */\n  if (prefixLen) {\n    uri += i - 1;\n    *uri = parser->m_namespaceSeparator; /* replace null terminator */\n    memcpy(uri + 1, binding->prefix->name, prefixLen * sizeof(XML_Char));\n  }\n  tagNamePtr->str = binding->uri;\n  return XML_ERROR_NONE;\n}\n\nstatic XML_Bool\nis_rfc3986_uri_char(XML_Char candidate) {\n  // For the RFC 3986 ANBF grammar see\n  // https://datatracker.ietf.org/doc/html/rfc3986#appendix-A\n\n  switch (candidate) {\n  // From rule \"ALPHA\" (uppercase half)\n  case 'A':\n  case 'B':\n  case 'C':\n  case 'D':\n  case 'E':\n  case 'F':\n  case 'G':\n  case 'H':\n  case 'I':\n  case 'J':\n  case 'K':\n  case 'L':\n  case 'M':\n  case 'N':\n  case 'O':\n  case 'P':\n  case 'Q':\n  case 'R':\n  case 'S':\n  case 'T':\n  case 'U':\n  case 'V':\n  case 'W':\n  case 'X':\n  case 'Y':\n  case 'Z':\n\n  // From rule \"ALPHA\" (lowercase half)\n  case 'a':\n  case 'b':\n  case 'c':\n  case 'd':\n  case 'e':\n  case 'f':\n  case 'g':\n  case 'h':\n  case 'i':\n  case 'j':\n  case 'k':\n  case 'l':\n  case 'm':\n  case 'n':\n  case 'o':\n  case 'p':\n  case 'q':\n  case 'r':\n  case 's':\n  case 't':\n  case 'u':\n  case 'v':\n  case 'w':\n  case 'x':\n  case 'y':\n  case 'z':\n\n  // From rule \"DIGIT\"\n  case '0':\n  case '1':\n  case '2':\n  case '3':\n  case '4':\n  case '5':\n  case '6':\n  case '7':\n  case '8':\n  case '9':\n\n  // From rule \"pct-encoded\"\n  case '%':\n\n  // From rule \"unreserved\"\n  case '-':\n  case '.':\n  case '_':\n  case '~':\n\n  // From rule \"gen-delims\"\n  case ':':\n  case '/':\n  case '?':\n  case '#':\n  case '[':\n  case ']':\n  case '@':\n\n  // From rule \"sub-delims\"\n  case '!':\n  case '$':\n  case '&':\n  case '\\'':\n  case '(':\n  case ')':\n  case '*':\n  case '+':\n  case ',':\n  case ';':\n  case '=':\n    return XML_TRUE;\n\n  default:\n    return XML_FALSE;\n  }\n}\n\n/* addBinding() overwrites the value of prefix->binding without checking.\n   Therefore one must keep track of the old value outside of addBinding().\n*/\nstatic enum XML_Error\naddBinding(XML_Parser parser, PREFIX *prefix, const ATTRIBUTE_ID *attId,\n           const XML_Char *uri, BINDING **bindingsPtr) {\n  // \"http://www.w3.org/XML/1998/namespace\"\n  static const XML_Char xmlNamespace[]\n      = {ASCII_h,      ASCII_t,     ASCII_t,     ASCII_p,      ASCII_COLON,\n         ASCII_SLASH,  ASCII_SLASH, ASCII_w,     ASCII_w,      ASCII_w,\n         ASCII_PERIOD, ASCII_w,     ASCII_3,     ASCII_PERIOD, ASCII_o,\n         ASCII_r,      ASCII_g,     ASCII_SLASH, ASCII_X,      ASCII_M,\n         ASCII_L,      ASCII_SLASH, ASCII_1,     ASCII_9,      ASCII_9,\n         ASCII_8,      ASCII_SLASH, ASCII_n,     ASCII_a,      ASCII_m,\n         ASCII_e,      ASCII_s,     ASCII_p,     ASCII_a,      ASCII_c,\n         ASCII_e,      '\\0'};\n  static const int xmlLen = (int)sizeof(xmlNamespace) / sizeof(XML_Char) - 1;\n  // \"http://www.w3.org/2000/xmlns/\"\n  static const XML_Char xmlnsNamespace[]\n      = {ASCII_h,     ASCII_t,      ASCII_t, ASCII_p, ASCII_COLON,  ASCII_SLASH,\n         ASCII_SLASH, ASCII_w,      ASCII_w, ASCII_w, ASCII_PERIOD, ASCII_w,\n         ASCII_3,     ASCII_PERIOD, ASCII_o, ASCII_r, ASCII_g,      ASCII_SLASH,\n         ASCII_2,     ASCII_0,      ASCII_0, ASCII_0, ASCII_SLASH,  ASCII_x,\n         ASCII_m,     ASCII_l,      ASCII_n, ASCII_s, ASCII_SLASH,  '\\0'};\n  static const int xmlnsLen\n      = (int)sizeof(xmlnsNamespace) / sizeof(XML_Char) - 1;\n\n  XML_Bool mustBeXML = XML_FALSE;\n  XML_Bool isXML = XML_TRUE;\n  XML_Bool isXMLNS = XML_TRUE;\n\n  BINDING *b;\n  int len;\n\n  /* empty URI is only valid for default namespace per XML NS 1.0 (not 1.1) */\n  if (*uri == XML_T('\\0') && prefix->name)\n    return XML_ERROR_UNDECLARING_PREFIX;\n\n  if (prefix->name && prefix->name[0] == XML_T(ASCII_x)\n      && prefix->name[1] == XML_T(ASCII_m)\n      && prefix->name[2] == XML_T(ASCII_l)) {\n    /* Not allowed to bind xmlns */\n    if (prefix->name[3] == XML_T(ASCII_n) && prefix->name[4] == XML_T(ASCII_s)\n        && prefix->name[5] == XML_T('\\0'))\n      return XML_ERROR_RESERVED_PREFIX_XMLNS;\n\n    if (prefix->name[3] == XML_T('\\0'))\n      mustBeXML = XML_TRUE;\n  }\n\n  for (len = 0; uri[len]; len++) {\n    if (isXML && (len > xmlLen || uri[len] != xmlNamespace[len]))\n      isXML = XML_FALSE;\n\n    if (! mustBeXML && isXMLNS\n        && (len > xmlnsLen || uri[len] != xmlnsNamespace[len]))\n      isXMLNS = XML_FALSE;\n\n    // NOTE: While Expat does not validate namespace URIs against RFC 3986\n    //       today (and is not REQUIRED to do so with regard to the XML 1.0\n    //       namespaces specification) we have to at least make sure, that\n    //       the application on top of Expat (that is likely splitting expanded\n    //       element names (\"qualified names\") of form\n    //       \"[uri sep] local [sep prefix] '\\0'\" back into 1, 2 or 3 pieces\n    //       in its element handler code) cannot be confused by an attacker\n    //       putting additional namespace separator characters into namespace\n    //       declarations.  That would be ambiguous and not to be expected.\n    //\n    //       While the HTML API docs of function XML_ParserCreateNS have been\n    //       advising against use of a namespace separator character that can\n    //       appear in a URI for >20 years now, some widespread applications\n    //       are using URI characters (':' (colon) in particular) for a\n    //       namespace separator, in practice.  To keep these applications\n    //       functional, we only reject namespaces URIs containing the\n    //       application-chosen namespace separator if the chosen separator\n    //       is a non-URI character with regard to RFC 3986.\n    if (parser->m_ns && (uri[len] == parser->m_namespaceSeparator)\n        && ! is_rfc3986_uri_char(uri[len])) {\n      return XML_ERROR_SYNTAX;\n    }\n  }\n  isXML = isXML && len == xmlLen;\n  isXMLNS = isXMLNS && len == xmlnsLen;\n\n  if (mustBeXML != isXML)\n    return mustBeXML ? XML_ERROR_RESERVED_PREFIX_XML\n                     : XML_ERROR_RESERVED_NAMESPACE_URI;\n\n  if (isXMLNS)\n    return XML_ERROR_RESERVED_NAMESPACE_URI;\n\n  if (parser->m_namespaceSeparator)\n    len++;\n  if (parser->m_freeBindingList) {\n    b = parser->m_freeBindingList;\n    if (len > b->uriAlloc) {\n      /* Detect and prevent integer overflow */\n      if (len > INT_MAX - EXPAND_SPARE) {\n        return XML_ERROR_NO_MEMORY;\n      }\n\n      /* Detect and prevent integer overflow.\n       * The preprocessor guard addresses the \"always false\" warning\n       * from -Wtype-limits on platforms where\n       * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */\n#if UINT_MAX >= SIZE_MAX\n      if ((unsigned)(len + EXPAND_SPARE) > (size_t)(-1) / sizeof(XML_Char)) {\n        return XML_ERROR_NO_MEMORY;\n      }\n#endif\n\n      XML_Char *temp = (XML_Char *)REALLOC(\n          parser, b->uri, sizeof(XML_Char) * (len + EXPAND_SPARE));\n      if (temp == NULL)\n        return XML_ERROR_NO_MEMORY;\n      b->uri = temp;\n      b->uriAlloc = len + EXPAND_SPARE;\n    }\n    parser->m_freeBindingList = b->nextTagBinding;\n  } else {\n    b = (BINDING *)MALLOC(parser, sizeof(BINDING));\n    if (! b)\n      return XML_ERROR_NO_MEMORY;\n\n    /* Detect and prevent integer overflow */\n    if (len > INT_MAX - EXPAND_SPARE) {\n      return XML_ERROR_NO_MEMORY;\n    }\n    /* Detect and prevent integer overflow.\n     * The preprocessor guard addresses the \"always false\" warning\n     * from -Wtype-limits on platforms where\n     * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */\n#if UINT_MAX >= SIZE_MAX\n    if ((unsigned)(len + EXPAND_SPARE) > (size_t)(-1) / sizeof(XML_Char)) {\n      return XML_ERROR_NO_MEMORY;\n    }\n#endif\n\n    b->uri\n        = (XML_Char *)MALLOC(parser, sizeof(XML_Char) * (len + EXPAND_SPARE));\n    if (! b->uri) {\n      FREE(parser, b);\n      return XML_ERROR_NO_MEMORY;\n    }\n    b->uriAlloc = len + EXPAND_SPARE;\n  }\n  b->uriLen = len;\n  memcpy(b->uri, uri, len * sizeof(XML_Char));\n  if (parser->m_namespaceSeparator)\n    b->uri[len - 1] = parser->m_namespaceSeparator;\n  b->prefix = prefix;\n  b->attId = attId;\n  b->prevPrefixBinding = prefix->binding;\n  /* NULL binding when default namespace undeclared */\n  if (*uri == XML_T('\\0') && prefix == &parser->m_dtd->defaultPrefix)\n    prefix->binding = NULL;\n  else\n    prefix->binding = b;\n  b->nextTagBinding = *bindingsPtr;\n  *bindingsPtr = b;\n  /* if attId == NULL then we are not starting a namespace scope */\n  if (attId && parser->m_startNamespaceDeclHandler)\n    parser->m_startNamespaceDeclHandler(parser->m_handlerArg, prefix->name,\n                                        prefix->binding ? uri : 0);\n  return XML_ERROR_NONE;\n}\n\n/* The idea here is to avoid using stack for each CDATA section when\n   the whole file is parsed with one call.\n*/\nstatic enum XML_Error PTRCALL\ncdataSectionProcessor(XML_Parser parser, const char *start, const char *end,\n                      const char **endPtr) {\n  enum XML_Error result = doCdataSection(\n      parser, parser->m_encoding, &start, end, endPtr,\n      (XML_Bool)! parser->m_parsingStatus.finalBuffer, XML_ACCOUNT_DIRECT);\n  if (result != XML_ERROR_NONE)\n    return result;\n  if (start) {\n    if (parser->m_parentParser) { /* we are parsing an external entity */\n      parser->m_processor = externalEntityContentProcessor;\n      return externalEntityContentProcessor(parser, start, end, endPtr);\n    } else {\n      parser->m_processor = contentProcessor;\n      return contentProcessor(parser, start, end, endPtr);\n    }\n  }\n  return result;\n}\n\n/* startPtr gets set to non-null if the section is closed, and to null if\n   the section is not yet closed.\n*/\nstatic enum XML_Error\ndoCdataSection(XML_Parser parser, const ENCODING *enc, const char **startPtr,\n               const char *end, const char **nextPtr, XML_Bool haveMore,\n               enum XML_Account account) {\n  const char *s = *startPtr;\n  const char **eventPP;\n  const char **eventEndPP;\n  if (enc == parser->m_encoding) {\n    eventPP = &parser->m_eventPtr;\n    *eventPP = s;\n    eventEndPP = &parser->m_eventEndPtr;\n  } else {\n    eventPP = &(parser->m_openInternalEntities->internalEventPtr);\n    eventEndPP = &(parser->m_openInternalEntities->internalEventEndPtr);\n  }\n  *eventPP = s;\n  *startPtr = NULL;\n\n  for (;;) {\n    const char *next = s; /* in case of XML_TOK_NONE or XML_TOK_PARTIAL */\n    int tok = XmlCdataSectionTok(enc, s, end, &next);\n#if defined(XML_DTD) || XML_GE == 1\n    if (! accountingDiffTolerated(parser, tok, s, next, __LINE__, account)) {\n      accountingOnAbort(parser);\n      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n    }\n#else\n    UNUSED_P(account);\n#endif\n    *eventEndPP = next;\n    switch (tok) {\n    case XML_TOK_CDATA_SECT_CLOSE:\n      if (parser->m_endCdataSectionHandler)\n        parser->m_endCdataSectionHandler(parser->m_handlerArg);\n      /* BEGIN disabled code */\n      /* see comment under XML_TOK_CDATA_SECT_OPEN */\n      else if ((0) && parser->m_characterDataHandler)\n        parser->m_characterDataHandler(parser->m_handlerArg, parser->m_dataBuf,\n                                       0);\n      /* END disabled code */\n      else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n      *startPtr = next;\n      *nextPtr = next;\n      if (parser->m_parsingStatus.parsing == XML_FINISHED)\n        return XML_ERROR_ABORTED;\n      else\n        return XML_ERROR_NONE;\n    case XML_TOK_DATA_NEWLINE:\n      if (parser->m_characterDataHandler) {\n        XML_Char c = 0xA;\n        parser->m_characterDataHandler(parser->m_handlerArg, &c, 1);\n      } else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n      break;\n    case XML_TOK_DATA_CHARS: {\n      XML_CharacterDataHandler charDataHandler = parser->m_characterDataHandler;\n      if (charDataHandler) {\n        if (MUST_CONVERT(enc, s)) {\n          for (;;) {\n            ICHAR *dataPtr = (ICHAR *)parser->m_dataBuf;\n            const enum XML_Convert_Result convert_res = XmlConvert(\n                enc, &s, next, &dataPtr, (ICHAR *)parser->m_dataBufEnd);\n            *eventEndPP = next;\n            charDataHandler(parser->m_handlerArg, parser->m_dataBuf,\n                            (int)(dataPtr - (ICHAR *)parser->m_dataBuf));\n            if ((convert_res == XML_CONVERT_COMPLETED)\n                || (convert_res == XML_CONVERT_INPUT_INCOMPLETE))\n              break;\n            *eventPP = s;\n          }\n        } else\n          charDataHandler(parser->m_handlerArg, (const XML_Char *)s,\n                          (int)((const XML_Char *)next - (const XML_Char *)s));\n      } else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n    } break;\n    case XML_TOK_INVALID:\n      *eventPP = next;\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_PARTIAL_CHAR:\n      if (haveMore) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      return XML_ERROR_PARTIAL_CHAR;\n    case XML_TOK_PARTIAL:\n    case XML_TOK_NONE:\n      if (haveMore) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      return XML_ERROR_UNCLOSED_CDATA_SECTION;\n    default:\n      /* Every token returned by XmlCdataSectionTok() has its own\n       * explicit case, so this default case will never be executed.\n       * We retain it as a safety net and exclude it from the coverage\n       * statistics.\n       *\n       * LCOV_EXCL_START\n       */\n      *eventPP = next;\n      return XML_ERROR_UNEXPECTED_STATE;\n      /* LCOV_EXCL_STOP */\n    }\n\n    *eventPP = s = next;\n    switch (parser->m_parsingStatus.parsing) {\n    case XML_SUSPENDED:\n      *nextPtr = next;\n      return XML_ERROR_NONE;\n    case XML_FINISHED:\n      return XML_ERROR_ABORTED;\n    default:;\n    }\n  }\n  /* not reached */\n}\n\n#ifdef XML_DTD\n\n/* The idea here is to avoid using stack for each IGNORE section when\n   the whole file is parsed with one call.\n*/\nstatic enum XML_Error PTRCALL\nignoreSectionProcessor(XML_Parser parser, const char *start, const char *end,\n                       const char **endPtr) {\n  enum XML_Error result\n      = doIgnoreSection(parser, parser->m_encoding, &start, end, endPtr,\n                        (XML_Bool)! parser->m_parsingStatus.finalBuffer);\n  if (result != XML_ERROR_NONE)\n    return result;\n  if (start) {\n    parser->m_processor = prologProcessor;\n    return prologProcessor(parser, start, end, endPtr);\n  }\n  return result;\n}\n\n/* startPtr gets set to non-null is the section is closed, and to null\n   if the section is not yet closed.\n*/\nstatic enum XML_Error\ndoIgnoreSection(XML_Parser parser, const ENCODING *enc, const char **startPtr,\n                const char *end, const char **nextPtr, XML_Bool haveMore) {\n  const char *next = *startPtr; /* in case of XML_TOK_NONE or XML_TOK_PARTIAL */\n  int tok;\n  const char *s = *startPtr;\n  const char **eventPP;\n  const char **eventEndPP;\n  if (enc == parser->m_encoding) {\n    eventPP = &parser->m_eventPtr;\n    *eventPP = s;\n    eventEndPP = &parser->m_eventEndPtr;\n  } else {\n    /* It's not entirely clear, but it seems the following two lines\n     * of code cannot be executed.  The only occasions on which 'enc'\n     * is not 'encoding' are when this function is called\n     * from the internal entity processing, and IGNORE sections are an\n     * error in internal entities.\n     *\n     * Since it really isn't clear that this is true, we keep the code\n     * and just remove it from our coverage tests.\n     *\n     * LCOV_EXCL_START\n     */\n    eventPP = &(parser->m_openInternalEntities->internalEventPtr);\n    eventEndPP = &(parser->m_openInternalEntities->internalEventEndPtr);\n    /* LCOV_EXCL_STOP */\n  }\n  *eventPP = s;\n  *startPtr = NULL;\n  tok = XmlIgnoreSectionTok(enc, s, end, &next);\n#  if defined(XML_DTD) || XML_GE == 1\n  if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                XML_ACCOUNT_DIRECT)) {\n    accountingOnAbort(parser);\n    return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n  }\n#  endif\n  *eventEndPP = next;\n  switch (tok) {\n  case XML_TOK_IGNORE_SECT:\n    if (parser->m_defaultHandler)\n      reportDefault(parser, enc, s, next);\n    *startPtr = next;\n    *nextPtr = next;\n    if (parser->m_parsingStatus.parsing == XML_FINISHED)\n      return XML_ERROR_ABORTED;\n    else\n      return XML_ERROR_NONE;\n  case XML_TOK_INVALID:\n    *eventPP = next;\n    return XML_ERROR_INVALID_TOKEN;\n  case XML_TOK_PARTIAL_CHAR:\n    if (haveMore) {\n      *nextPtr = s;\n      return XML_ERROR_NONE;\n    }\n    return XML_ERROR_PARTIAL_CHAR;\n  case XML_TOK_PARTIAL:\n  case XML_TOK_NONE:\n    if (haveMore) {\n      *nextPtr = s;\n      return XML_ERROR_NONE;\n    }\n    return XML_ERROR_SYNTAX; /* XML_ERROR_UNCLOSED_IGNORE_SECTION */\n  default:\n    /* All of the tokens that XmlIgnoreSectionTok() returns have\n     * explicit cases to handle them, so this default case is never\n     * executed.  We keep it as a safety net anyway, and remove it\n     * from our test coverage statistics.\n     *\n     * LCOV_EXCL_START\n     */\n    *eventPP = next;\n    return XML_ERROR_UNEXPECTED_STATE;\n    /* LCOV_EXCL_STOP */\n  }\n  /* not reached */\n}\n\n#endif /* XML_DTD */\n\nstatic enum XML_Error\ninitializeEncoding(XML_Parser parser) {\n  const char *s;\n#ifdef XML_UNICODE\n  char encodingBuf[128];\n  /* See comments about `protocolEncodingName` in parserInit() */\n  if (! parser->m_protocolEncodingName)\n    s = NULL;\n  else {\n    int i;\n    for (i = 0; parser->m_protocolEncodingName[i]; i++) {\n      if (i == sizeof(encodingBuf) - 1\n          || (parser->m_protocolEncodingName[i] & ~0x7f) != 0) {\n        encodingBuf[0] = '\\0';\n        break;\n      }\n      encodingBuf[i] = (char)parser->m_protocolEncodingName[i];\n    }\n    encodingBuf[i] = '\\0';\n    s = encodingBuf;\n  }\n#else\n  s = parser->m_protocolEncodingName;\n#endif\n  if ((parser->m_ns ? XmlInitEncodingNS : XmlInitEncoding)(\n          &parser->m_initEncoding, &parser->m_encoding, s))\n    return XML_ERROR_NONE;\n  return handleUnknownEncoding(parser, parser->m_protocolEncodingName);\n}\n\nstatic enum XML_Error\nprocessXmlDecl(XML_Parser parser, int isGeneralTextEntity, const char *s,\n               const char *next) {\n  const char *encodingName = NULL;\n  const XML_Char *storedEncName = NULL;\n  const ENCODING *newEncoding = NULL;\n  const char *version = NULL;\n  const char *versionend = NULL;\n  const XML_Char *storedversion = NULL;\n  int standalone = -1;\n\n#if defined(XML_DTD) || XML_GE == 1\n  if (! accountingDiffTolerated(parser, XML_TOK_XML_DECL, s, next, __LINE__,\n                                XML_ACCOUNT_DIRECT)) {\n    accountingOnAbort(parser);\n    return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n  }\n#endif\n\n  if (! (parser->m_ns ? XmlParseXmlDeclNS : XmlParseXmlDecl)(\n          isGeneralTextEntity, parser->m_encoding, s, next, &parser->m_eventPtr,\n          &version, &versionend, &encodingName, &newEncoding, &standalone)) {\n    if (isGeneralTextEntity)\n      return XML_ERROR_TEXT_DECL;\n    else\n      return XML_ERROR_XML_DECL;\n  }\n  if (! isGeneralTextEntity && standalone == 1) {\n    parser->m_dtd->standalone = XML_TRUE;\n#ifdef XML_DTD\n    if (parser->m_paramEntityParsing\n        == XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE)\n      parser->m_paramEntityParsing = XML_PARAM_ENTITY_PARSING_NEVER;\n#endif /* XML_DTD */\n  }\n  if (parser->m_xmlDeclHandler) {\n    if (encodingName != NULL) {\n      storedEncName = poolStoreString(\n          &parser->m_temp2Pool, parser->m_encoding, encodingName,\n          encodingName + XmlNameLength(parser->m_encoding, encodingName));\n      if (! storedEncName)\n        return XML_ERROR_NO_MEMORY;\n      poolFinish(&parser->m_temp2Pool);\n    }\n    if (version) {\n      storedversion\n          = poolStoreString(&parser->m_temp2Pool, parser->m_encoding, version,\n                            versionend - parser->m_encoding->minBytesPerChar);\n      if (! storedversion)\n        return XML_ERROR_NO_MEMORY;\n    }\n    parser->m_xmlDeclHandler(parser->m_handlerArg, storedversion, storedEncName,\n                             standalone);\n  } else if (parser->m_defaultHandler)\n    reportDefault(parser, parser->m_encoding, s, next);\n  if (parser->m_protocolEncodingName == NULL) {\n    if (newEncoding) {\n      /* Check that the specified encoding does not conflict with what\n       * the parser has already deduced.  Do we have the same number\n       * of bytes in the smallest representation of a character?  If\n       * this is UTF-16, is it the same endianness?\n       */\n      if (newEncoding->minBytesPerChar != parser->m_encoding->minBytesPerChar\n          || (newEncoding->minBytesPerChar == 2\n              && newEncoding != parser->m_encoding)) {\n        parser->m_eventPtr = encodingName;\n        return XML_ERROR_INCORRECT_ENCODING;\n      }\n      parser->m_encoding = newEncoding;\n    } else if (encodingName) {\n      enum XML_Error result;\n      if (! storedEncName) {\n        storedEncName = poolStoreString(\n            &parser->m_temp2Pool, parser->m_encoding, encodingName,\n            encodingName + XmlNameLength(parser->m_encoding, encodingName));\n        if (! storedEncName)\n          return XML_ERROR_NO_MEMORY;\n      }\n      result = handleUnknownEncoding(parser, storedEncName);\n      poolClear(&parser->m_temp2Pool);\n      if (result == XML_ERROR_UNKNOWN_ENCODING)\n        parser->m_eventPtr = encodingName;\n      return result;\n    }\n  }\n\n  if (storedEncName || storedversion)\n    poolClear(&parser->m_temp2Pool);\n\n  return XML_ERROR_NONE;\n}\n\nstatic enum XML_Error\nhandleUnknownEncoding(XML_Parser parser, const XML_Char *encodingName) {\n  if (parser->m_unknownEncodingHandler) {\n    XML_Encoding info;\n    int i;\n    for (i = 0; i < 256; i++)\n      info.map[i] = -1;\n    info.convert = NULL;\n    info.data = NULL;\n    info.release = NULL;\n    if (parser->m_unknownEncodingHandler(parser->m_unknownEncodingHandlerData,\n                                         encodingName, &info)) {\n      ENCODING *enc;\n      parser->m_unknownEncodingMem = MALLOC(parser, XmlSizeOfUnknownEncoding());\n      if (! parser->m_unknownEncodingMem) {\n        if (info.release)\n          info.release(info.data);\n        return XML_ERROR_NO_MEMORY;\n      }\n      enc = (parser->m_ns ? XmlInitUnknownEncodingNS : XmlInitUnknownEncoding)(\n          parser->m_unknownEncodingMem, info.map, info.convert, info.data);\n      if (enc) {\n        parser->m_unknownEncodingData = info.data;\n        parser->m_unknownEncodingRelease = info.release;\n        parser->m_encoding = enc;\n        return XML_ERROR_NONE;\n      }\n    }\n    if (info.release != NULL)\n      info.release(info.data);\n  }\n  return XML_ERROR_UNKNOWN_ENCODING;\n}\n\nstatic enum XML_Error PTRCALL\nprologInitProcessor(XML_Parser parser, const char *s, const char *end,\n                    const char **nextPtr) {\n  enum XML_Error result = initializeEncoding(parser);\n  if (result != XML_ERROR_NONE)\n    return result;\n  parser->m_processor = prologProcessor;\n  return prologProcessor(parser, s, end, nextPtr);\n}\n\n#ifdef XML_DTD\n\nstatic enum XML_Error PTRCALL\nexternalParEntInitProcessor(XML_Parser parser, const char *s, const char *end,\n                            const char **nextPtr) {\n  enum XML_Error result = initializeEncoding(parser);\n  if (result != XML_ERROR_NONE)\n    return result;\n\n  /* we know now that XML_Parse(Buffer) has been called,\n     so we consider the external parameter entity read */\n  parser->m_dtd->paramEntityRead = XML_TRUE;\n\n  if (parser->m_prologState.inEntityValue) {\n    parser->m_processor = entityValueInitProcessor;\n    return entityValueInitProcessor(parser, s, end, nextPtr);\n  } else {\n    parser->m_processor = externalParEntProcessor;\n    return externalParEntProcessor(parser, s, end, nextPtr);\n  }\n}\n\nstatic enum XML_Error PTRCALL\nentityValueInitProcessor(XML_Parser parser, const char *s, const char *end,\n                         const char **nextPtr) {\n  int tok;\n  const char *start = s;\n  const char *next = start;\n  parser->m_eventPtr = start;\n\n  for (;;) {\n    tok = XmlPrologTok(parser->m_encoding, start, end, &next);\n    /* Note: Except for XML_TOK_BOM below, these bytes are accounted later in:\n             - storeEntityValue\n             - processXmlDecl\n    */\n    parser->m_eventEndPtr = next;\n    if (tok <= 0) {\n      if (! parser->m_parsingStatus.finalBuffer && tok != XML_TOK_INVALID) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      switch (tok) {\n      case XML_TOK_INVALID:\n        return XML_ERROR_INVALID_TOKEN;\n      case XML_TOK_PARTIAL:\n        return XML_ERROR_UNCLOSED_TOKEN;\n      case XML_TOK_PARTIAL_CHAR:\n        return XML_ERROR_PARTIAL_CHAR;\n      case XML_TOK_NONE: /* start == end */\n      default:\n        break;\n      }\n      /* found end of entity value - can store it now */\n      return storeEntityValue(parser, parser->m_encoding, s, end,\n                              XML_ACCOUNT_DIRECT);\n    } else if (tok == XML_TOK_XML_DECL) {\n      enum XML_Error result;\n      result = processXmlDecl(parser, 0, start, next);\n      if (result != XML_ERROR_NONE)\n        return result;\n      /* At this point, m_parsingStatus.parsing cannot be XML_SUSPENDED.  For\n       * that to happen, a parameter entity parsing handler must have attempted\n       * to suspend the parser, which fails and raises an error.  The parser can\n       * be aborted, but can't be suspended.\n       */\n      if (parser->m_parsingStatus.parsing == XML_FINISHED)\n        return XML_ERROR_ABORTED;\n      *nextPtr = next;\n      /* stop scanning for text declaration - we found one */\n      parser->m_processor = entityValueProcessor;\n      return entityValueProcessor(parser, next, end, nextPtr);\n    }\n    /* XmlPrologTok has now set the encoding based on the BOM it found, and we\n       must move s and nextPtr forward to consume the BOM.\n\n       If we didn't, and got XML_TOK_NONE from the next XmlPrologTok call, we\n       would leave the BOM in the buffer and return. On the next call to this\n       function, our XmlPrologTok call would return XML_TOK_INVALID, since it\n       is not valid to have multiple BOMs.\n    */\n    else if (tok == XML_TOK_BOM) {\n#  if defined(XML_DTD) || XML_GE == 1\n      if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                    XML_ACCOUNT_DIRECT)) {\n        accountingOnAbort(parser);\n        return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n      }\n#  endif\n\n      *nextPtr = next;\n      s = next;\n    }\n    /* If we get this token, we have the start of what might be a\n       normal tag, but not a declaration (i.e. it doesn't begin with\n       \"<!\").  In a DTD context, that isn't legal.\n    */\n    else if (tok == XML_TOK_INSTANCE_START) {\n      *nextPtr = next;\n      return XML_ERROR_SYNTAX;\n    }\n    start = next;\n    parser->m_eventPtr = start;\n  }\n}\n\nstatic enum XML_Error PTRCALL\nexternalParEntProcessor(XML_Parser parser, const char *s, const char *end,\n                        const char **nextPtr) {\n  const char *next = s;\n  int tok;\n\n  tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  if (tok <= 0) {\n    if (! parser->m_parsingStatus.finalBuffer && tok != XML_TOK_INVALID) {\n      *nextPtr = s;\n      return XML_ERROR_NONE;\n    }\n    switch (tok) {\n    case XML_TOK_INVALID:\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_PARTIAL:\n      return XML_ERROR_UNCLOSED_TOKEN;\n    case XML_TOK_PARTIAL_CHAR:\n      return XML_ERROR_PARTIAL_CHAR;\n    case XML_TOK_NONE: /* start == end */\n    default:\n      break;\n    }\n  }\n  /* This would cause the next stage, i.e. doProlog to be passed XML_TOK_BOM.\n     However, when parsing an external subset, doProlog will not accept a BOM\n     as valid, and report a syntax error, so we have to skip the BOM, and\n     account for the BOM bytes.\n  */\n  else if (tok == XML_TOK_BOM) {\n    if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                  XML_ACCOUNT_DIRECT)) {\n      accountingOnAbort(parser);\n      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n    }\n\n    s = next;\n    tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  }\n\n  parser->m_processor = prologProcessor;\n  return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                  (XML_Bool)! parser->m_parsingStatus.finalBuffer, XML_TRUE,\n                  XML_ACCOUNT_DIRECT);\n}\n\nstatic enum XML_Error PTRCALL\nentityValueProcessor(XML_Parser parser, const char *s, const char *end,\n                     const char **nextPtr) {\n  const char *start = s;\n  const char *next = s;\n  const ENCODING *enc = parser->m_encoding;\n  int tok;\n\n  for (;;) {\n    tok = XmlPrologTok(enc, start, end, &next);\n    /* Note: These bytes are accounted later in:\n             - storeEntityValue\n    */\n    if (tok <= 0) {\n      if (! parser->m_parsingStatus.finalBuffer && tok != XML_TOK_INVALID) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      switch (tok) {\n      case XML_TOK_INVALID:\n        return XML_ERROR_INVALID_TOKEN;\n      case XML_TOK_PARTIAL:\n        return XML_ERROR_UNCLOSED_TOKEN;\n      case XML_TOK_PARTIAL_CHAR:\n        return XML_ERROR_PARTIAL_CHAR;\n      case XML_TOK_NONE: /* start == end */\n      default:\n        break;\n      }\n      /* found end of entity value - can store it now */\n      return storeEntityValue(parser, enc, s, end, XML_ACCOUNT_DIRECT);\n    }\n    start = next;\n  }\n}\n\n#endif /* XML_DTD */\n\nstatic enum XML_Error PTRCALL\nprologProcessor(XML_Parser parser, const char *s, const char *end,\n                const char **nextPtr) {\n  const char *next = s;\n  int tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                  (XML_Bool)! parser->m_parsingStatus.finalBuffer, XML_TRUE,\n                  XML_ACCOUNT_DIRECT);\n}\n\nstatic enum XML_Error\ndoProlog(XML_Parser parser, const ENCODING *enc, const char *s, const char *end,\n         int tok, const char *next, const char **nextPtr, XML_Bool haveMore,\n         XML_Bool allowClosingDoctype, enum XML_Account account) {\n#ifdef XML_DTD\n  static const XML_Char externalSubsetName[] = {ASCII_HASH, '\\0'};\n#endif /* XML_DTD */\n  static const XML_Char atypeCDATA[]\n      = {ASCII_C, ASCII_D, ASCII_A, ASCII_T, ASCII_A, '\\0'};\n  static const XML_Char atypeID[] = {ASCII_I, ASCII_D, '\\0'};\n  static const XML_Char atypeIDREF[]\n      = {ASCII_I, ASCII_D, ASCII_R, ASCII_E, ASCII_F, '\\0'};\n  static const XML_Char atypeIDREFS[]\n      = {ASCII_I, ASCII_D, ASCII_R, ASCII_E, ASCII_F, ASCII_S, '\\0'};\n  static const XML_Char atypeENTITY[]\n      = {ASCII_E, ASCII_N, ASCII_T, ASCII_I, ASCII_T, ASCII_Y, '\\0'};\n  static const XML_Char atypeENTITIES[]\n      = {ASCII_E, ASCII_N, ASCII_T, ASCII_I, ASCII_T,\n         ASCII_I, ASCII_E, ASCII_S, '\\0'};\n  static const XML_Char atypeNMTOKEN[]\n      = {ASCII_N, ASCII_M, ASCII_T, ASCII_O, ASCII_K, ASCII_E, ASCII_N, '\\0'};\n  static const XML_Char atypeNMTOKENS[]\n      = {ASCII_N, ASCII_M, ASCII_T, ASCII_O, ASCII_K,\n         ASCII_E, ASCII_N, ASCII_S, '\\0'};\n  static const XML_Char notationPrefix[]\n      = {ASCII_N, ASCII_O, ASCII_T, ASCII_A,      ASCII_T,\n         ASCII_I, ASCII_O, ASCII_N, ASCII_LPAREN, '\\0'};\n  static const XML_Char enumValueSep[] = {ASCII_PIPE, '\\0'};\n  static const XML_Char enumValueStart[] = {ASCII_LPAREN, '\\0'};\n\n#ifndef XML_DTD\n  UNUSED_P(account);\n#endif\n\n  /* save one level of indirection */\n  DTD *const dtd = parser->m_dtd;\n\n  const char **eventPP;\n  const char **eventEndPP;\n  enum XML_Content_Quant quant;\n\n  if (enc == parser->m_encoding) {\n    eventPP = &parser->m_eventPtr;\n    eventEndPP = &parser->m_eventEndPtr;\n  } else {\n    eventPP = &(parser->m_openInternalEntities->internalEventPtr);\n    eventEndPP = &(parser->m_openInternalEntities->internalEventEndPtr);\n  }\n\n  for (;;) {\n    int role;\n    XML_Bool handleDefault = XML_TRUE;\n    *eventPP = s;\n    *eventEndPP = next;\n    if (tok <= 0) {\n      if (haveMore && tok != XML_TOK_INVALID) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      switch (tok) {\n      case XML_TOK_INVALID:\n        *eventPP = next;\n        return XML_ERROR_INVALID_TOKEN;\n      case XML_TOK_PARTIAL:\n        return XML_ERROR_UNCLOSED_TOKEN;\n      case XML_TOK_PARTIAL_CHAR:\n        return XML_ERROR_PARTIAL_CHAR;\n      case -XML_TOK_PROLOG_S:\n        tok = -tok;\n        break;\n      case XML_TOK_NONE:\n#ifdef XML_DTD\n        /* for internal PE NOT referenced between declarations */\n        if (enc != parser->m_encoding\n            && ! parser->m_openInternalEntities->betweenDecl) {\n          *nextPtr = s;\n          return XML_ERROR_NONE;\n        }\n        /* WFC: PE Between Declarations - must check that PE contains\n           complete markup, not only for external PEs, but also for\n           internal PEs if the reference occurs between declarations.\n        */\n        if (parser->m_isParamEntity || enc != parser->m_encoding) {\n          if (XmlTokenRole(&parser->m_prologState, XML_TOK_NONE, end, end, enc)\n              == XML_ROLE_ERROR)\n            return XML_ERROR_INCOMPLETE_PE;\n          *nextPtr = s;\n          return XML_ERROR_NONE;\n        }\n#endif /* XML_DTD */\n        return XML_ERROR_NO_ELEMENTS;\n      default:\n        tok = -tok;\n        next = end;\n        break;\n      }\n    }\n    role = XmlTokenRole(&parser->m_prologState, tok, s, next, enc);\n#if defined(XML_DTD) || XML_GE == 1\n    switch (role) {\n    case XML_ROLE_INSTANCE_START: // bytes accounted in contentProcessor\n    case XML_ROLE_XML_DECL:       // bytes accounted in processXmlDecl\n#  ifdef XML_DTD\n    case XML_ROLE_TEXT_DECL: // bytes accounted in processXmlDecl\n#  endif\n      break;\n    default:\n      if (! accountingDiffTolerated(parser, tok, s, next, __LINE__, account)) {\n        accountingOnAbort(parser);\n        return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n      }\n    }\n#endif\n    switch (role) {\n    case XML_ROLE_XML_DECL: {\n      enum XML_Error result = processXmlDecl(parser, 0, s, next);\n      if (result != XML_ERROR_NONE)\n        return result;\n      enc = parser->m_encoding;\n      handleDefault = XML_FALSE;\n    } break;\n    case XML_ROLE_DOCTYPE_NAME:\n      if (parser->m_startDoctypeDeclHandler) {\n        parser->m_doctypeName\n            = poolStoreString(&parser->m_tempPool, enc, s, next);\n        if (! parser->m_doctypeName)\n          return XML_ERROR_NO_MEMORY;\n        poolFinish(&parser->m_tempPool);\n        parser->m_doctypePubid = NULL;\n        handleDefault = XML_FALSE;\n      }\n      parser->m_doctypeSysid = NULL; /* always initialize to NULL */\n      break;\n    case XML_ROLE_DOCTYPE_INTERNAL_SUBSET:\n      if (parser->m_startDoctypeDeclHandler) {\n        parser->m_startDoctypeDeclHandler(\n            parser->m_handlerArg, parser->m_doctypeName, parser->m_doctypeSysid,\n            parser->m_doctypePubid, 1);\n        parser->m_doctypeName = NULL;\n        poolClear(&parser->m_tempPool);\n        handleDefault = XML_FALSE;\n      }\n      break;\n#ifdef XML_DTD\n    case XML_ROLE_TEXT_DECL: {\n      enum XML_Error result = processXmlDecl(parser, 1, s, next);\n      if (result != XML_ERROR_NONE)\n        return result;\n      enc = parser->m_encoding;\n      handleDefault = XML_FALSE;\n    } break;\n#endif /* XML_DTD */\n    case XML_ROLE_DOCTYPE_PUBLIC_ID:\n#ifdef XML_DTD\n      parser->m_useForeignDTD = XML_FALSE;\n      parser->m_declEntity = (ENTITY *)lookup(\n          parser, &dtd->paramEntities, externalSubsetName, sizeof(ENTITY));\n      if (! parser->m_declEntity)\n        return XML_ERROR_NO_MEMORY;\n#endif /* XML_DTD */\n      dtd->hasParamEntityRefs = XML_TRUE;\n      if (parser->m_startDoctypeDeclHandler) {\n        XML_Char *pubId;\n        if (! XmlIsPublicId(enc, s, next, eventPP))\n          return XML_ERROR_PUBLICID;\n        pubId = poolStoreString(&parser->m_tempPool, enc,\n                                s + enc->minBytesPerChar,\n                                next - enc->minBytesPerChar);\n        if (! pubId)\n          return XML_ERROR_NO_MEMORY;\n        normalizePublicId(pubId);\n        poolFinish(&parser->m_tempPool);\n        parser->m_doctypePubid = pubId;\n        handleDefault = XML_FALSE;\n        goto alreadyChecked;\n      }\n      /* fall through */\n    case XML_ROLE_ENTITY_PUBLIC_ID:\n      if (! XmlIsPublicId(enc, s, next, eventPP))\n        return XML_ERROR_PUBLICID;\n    alreadyChecked:\n      if (dtd->keepProcessing && parser->m_declEntity) {\n        XML_Char *tem\n            = poolStoreString(&dtd->pool, enc, s + enc->minBytesPerChar,\n                              next - enc->minBytesPerChar);\n        if (! tem)\n          return XML_ERROR_NO_MEMORY;\n        normalizePublicId(tem);\n        parser->m_declEntity->publicId = tem;\n        poolFinish(&dtd->pool);\n        /* Don't suppress the default handler if we fell through from\n         * the XML_ROLE_DOCTYPE_PUBLIC_ID case.\n         */\n        if (parser->m_entityDeclHandler && role == XML_ROLE_ENTITY_PUBLIC_ID)\n          handleDefault = XML_FALSE;\n      }\n      break;\n    case XML_ROLE_DOCTYPE_CLOSE:\n      if (allowClosingDoctype != XML_TRUE) {\n        /* Must not close doctype from within expanded parameter entities */\n        return XML_ERROR_INVALID_TOKEN;\n      }\n\n      if (parser->m_doctypeName) {\n        parser->m_startDoctypeDeclHandler(\n            parser->m_handlerArg, parser->m_doctypeName, parser->m_doctypeSysid,\n            parser->m_doctypePubid, 0);\n        poolClear(&parser->m_tempPool);\n        handleDefault = XML_FALSE;\n      }\n      /* parser->m_doctypeSysid will be non-NULL in the case of a previous\n         XML_ROLE_DOCTYPE_SYSTEM_ID, even if parser->m_startDoctypeDeclHandler\n         was not set, indicating an external subset\n      */\n#ifdef XML_DTD\n      if (parser->m_doctypeSysid || parser->m_useForeignDTD) {\n        XML_Bool hadParamEntityRefs = dtd->hasParamEntityRefs;\n        dtd->hasParamEntityRefs = XML_TRUE;\n        if (parser->m_paramEntityParsing\n            && parser->m_externalEntityRefHandler) {\n          ENTITY *entity = (ENTITY *)lookup(parser, &dtd->paramEntities,\n                                            externalSubsetName, sizeof(ENTITY));\n          if (! entity) {\n            /* The external subset name \"#\" will have already been\n             * inserted into the hash table at the start of the\n             * external entity parsing, so no allocation will happen\n             * and lookup() cannot fail.\n             */\n            return XML_ERROR_NO_MEMORY; /* LCOV_EXCL_LINE */\n          }\n          if (parser->m_useForeignDTD)\n            entity->base = parser->m_curBase;\n          dtd->paramEntityRead = XML_FALSE;\n          if (! parser->m_externalEntityRefHandler(\n                  parser->m_externalEntityRefHandlerArg, 0, entity->base,\n                  entity->systemId, entity->publicId))\n            return XML_ERROR_EXTERNAL_ENTITY_HANDLING;\n          if (dtd->paramEntityRead) {\n            if (! dtd->standalone && parser->m_notStandaloneHandler\n                && ! parser->m_notStandaloneHandler(parser->m_handlerArg))\n              return XML_ERROR_NOT_STANDALONE;\n          }\n          /* if we didn't read the foreign DTD then this means that there\n             is no external subset and we must reset dtd->hasParamEntityRefs\n          */\n          else if (! parser->m_doctypeSysid)\n            dtd->hasParamEntityRefs = hadParamEntityRefs;\n          /* end of DTD - no need to update dtd->keepProcessing */\n        }\n        parser->m_useForeignDTD = XML_FALSE;\n      }\n#endif /* XML_DTD */\n      if (parser->m_endDoctypeDeclHandler) {\n        parser->m_endDoctypeDeclHandler(parser->m_handlerArg);\n        handleDefault = XML_FALSE;\n      }\n      break;\n    case XML_ROLE_INSTANCE_START:\n#ifdef XML_DTD\n      /* if there is no DOCTYPE declaration then now is the\n         last chance to read the foreign DTD\n      */\n      if (parser->m_useForeignDTD) {\n        XML_Bool hadParamEntityRefs = dtd->hasParamEntityRefs;\n        dtd->hasParamEntityRefs = XML_TRUE;\n        if (parser->m_paramEntityParsing\n            && parser->m_externalEntityRefHandler) {\n          ENTITY *entity = (ENTITY *)lookup(parser, &dtd->paramEntities,\n                                            externalSubsetName, sizeof(ENTITY));\n          if (! entity)\n            return XML_ERROR_NO_MEMORY;\n          entity->base = parser->m_curBase;\n          dtd->paramEntityRead = XML_FALSE;\n          if (! parser->m_externalEntityRefHandler(\n                  parser->m_externalEntityRefHandlerArg, 0, entity->base,\n                  entity->systemId, entity->publicId))\n            return XML_ERROR_EXTERNAL_ENTITY_HANDLING;\n          if (dtd->paramEntityRead) {\n            if (! dtd->standalone && parser->m_notStandaloneHandler\n                && ! parser->m_notStandaloneHandler(parser->m_handlerArg))\n              return XML_ERROR_NOT_STANDALONE;\n          }\n          /* if we didn't read the foreign DTD then this means that there\n             is no external subset and we must reset dtd->hasParamEntityRefs\n          */\n          else\n            dtd->hasParamEntityRefs = hadParamEntityRefs;\n          /* end of DTD - no need to update dtd->keepProcessing */\n        }\n      }\n#endif /* XML_DTD */\n      parser->m_processor = contentProcessor;\n      return contentProcessor(parser, s, end, nextPtr);\n    case XML_ROLE_ATTLIST_ELEMENT_NAME:\n      parser->m_declElementType = getElementType(parser, enc, s, next);\n      if (! parser->m_declElementType)\n        return XML_ERROR_NO_MEMORY;\n      goto checkAttListDeclHandler;\n    case XML_ROLE_ATTRIBUTE_NAME:\n      parser->m_declAttributeId = getAttributeId(parser, enc, s, next);\n      if (! parser->m_declAttributeId)\n        return XML_ERROR_NO_MEMORY;\n      parser->m_declAttributeIsCdata = XML_FALSE;\n      parser->m_declAttributeType = NULL;\n      parser->m_declAttributeIsId = XML_FALSE;\n      goto checkAttListDeclHandler;\n    case XML_ROLE_ATTRIBUTE_TYPE_CDATA:\n      parser->m_declAttributeIsCdata = XML_TRUE;\n      parser->m_declAttributeType = atypeCDATA;\n      goto checkAttListDeclHandler;\n    case XML_ROLE_ATTRIBUTE_TYPE_ID:\n      parser->m_declAttributeIsId = XML_TRUE;\n      parser->m_declAttributeType = atypeID;\n      goto checkAttListDeclHandler;\n    case XML_ROLE_ATTRIBUTE_TYPE_IDREF:\n      parser->m_declAttributeType = atypeIDREF;\n      goto checkAttListDeclHandler;\n    case XML_ROLE_ATTRIBUTE_TYPE_IDREFS:\n      parser->m_declAttributeType = atypeIDREFS;\n      goto checkAttListDeclHandler;\n    case XML_ROLE_ATTRIBUTE_TYPE_ENTITY:\n      parser->m_declAttributeType = atypeENTITY;\n      goto checkAttListDeclHandler;\n    case XML_ROLE_ATTRIBUTE_TYPE_ENTITIES:\n      parser->m_declAttributeType = atypeENTITIES;\n      goto checkAttListDeclHandler;\n    case XML_ROLE_ATTRIBUTE_TYPE_NMTOKEN:\n      parser->m_declAttributeType = atypeNMTOKEN;\n      goto checkAttListDeclHandler;\n    case XML_ROLE_ATTRIBUTE_TYPE_NMTOKENS:\n      parser->m_declAttributeType = atypeNMTOKENS;\n    checkAttListDeclHandler:\n      if (dtd->keepProcessing && parser->m_attlistDeclHandler)\n        handleDefault = XML_FALSE;\n      break;\n    case XML_ROLE_ATTRIBUTE_ENUM_VALUE:\n    case XML_ROLE_ATTRIBUTE_NOTATION_VALUE:\n      if (dtd->keepProcessing && parser->m_attlistDeclHandler) {\n        const XML_Char *prefix;\n        if (parser->m_declAttributeType) {\n          prefix = enumValueSep;\n        } else {\n          prefix = (role == XML_ROLE_ATTRIBUTE_NOTATION_VALUE ? notationPrefix\n                                                              : enumValueStart);\n        }\n        if (! poolAppendString(&parser->m_tempPool, prefix))\n          return XML_ERROR_NO_MEMORY;\n        if (! poolAppend(&parser->m_tempPool, enc, s, next))\n          return XML_ERROR_NO_MEMORY;\n        parser->m_declAttributeType = parser->m_tempPool.start;\n        handleDefault = XML_FALSE;\n      }\n      break;\n    case XML_ROLE_IMPLIED_ATTRIBUTE_VALUE:\n    case XML_ROLE_REQUIRED_ATTRIBUTE_VALUE:\n      if (dtd->keepProcessing) {\n        if (! defineAttribute(parser->m_declElementType,\n                              parser->m_declAttributeId,\n                              parser->m_declAttributeIsCdata,\n                              parser->m_declAttributeIsId, 0, parser))\n          return XML_ERROR_NO_MEMORY;\n        if (parser->m_attlistDeclHandler && parser->m_declAttributeType) {\n          if (*parser->m_declAttributeType == XML_T(ASCII_LPAREN)\n              || (*parser->m_declAttributeType == XML_T(ASCII_N)\n                  && parser->m_declAttributeType[1] == XML_T(ASCII_O))) {\n            /* Enumerated or Notation type */\n            if (! poolAppendChar(&parser->m_tempPool, XML_T(ASCII_RPAREN))\n                || ! poolAppendChar(&parser->m_tempPool, XML_T('\\0')))\n              return XML_ERROR_NO_MEMORY;\n            parser->m_declAttributeType = parser->m_tempPool.start;\n            poolFinish(&parser->m_tempPool);\n          }\n          *eventEndPP = s;\n          parser->m_attlistDeclHandler(\n              parser->m_handlerArg, parser->m_declElementType->name,\n              parser->m_declAttributeId->name, parser->m_declAttributeType, 0,\n              role == XML_ROLE_REQUIRED_ATTRIBUTE_VALUE);\n          handleDefault = XML_FALSE;\n        }\n      }\n      poolClear(&parser->m_tempPool);\n      break;\n    case XML_ROLE_DEFAULT_ATTRIBUTE_VALUE:\n    case XML_ROLE_FIXED_ATTRIBUTE_VALUE:\n      if (dtd->keepProcessing) {\n        const XML_Char *attVal;\n        enum XML_Error result = storeAttributeValue(\n            parser, enc, parser->m_declAttributeIsCdata,\n            s + enc->minBytesPerChar, next - enc->minBytesPerChar, &dtd->pool,\n            XML_ACCOUNT_NONE);\n        if (result)\n          return result;\n        attVal = poolStart(&dtd->pool);\n        poolFinish(&dtd->pool);\n        /* ID attributes aren't allowed to have a default */\n        if (! defineAttribute(\n                parser->m_declElementType, parser->m_declAttributeId,\n                parser->m_declAttributeIsCdata, XML_FALSE, attVal, parser))\n          return XML_ERROR_NO_MEMORY;\n        if (parser->m_attlistDeclHandler && parser->m_declAttributeType) {\n          if (*parser->m_declAttributeType == XML_T(ASCII_LPAREN)\n              || (*parser->m_declAttributeType == XML_T(ASCII_N)\n                  && parser->m_declAttributeType[1] == XML_T(ASCII_O))) {\n            /* Enumerated or Notation type */\n            if (! poolAppendChar(&parser->m_tempPool, XML_T(ASCII_RPAREN))\n                || ! poolAppendChar(&parser->m_tempPool, XML_T('\\0')))\n              return XML_ERROR_NO_MEMORY;\n            parser->m_declAttributeType = parser->m_tempPool.start;\n            poolFinish(&parser->m_tempPool);\n          }\n          *eventEndPP = s;\n          parser->m_attlistDeclHandler(\n              parser->m_handlerArg, parser->m_declElementType->name,\n              parser->m_declAttributeId->name, parser->m_declAttributeType,\n              attVal, role == XML_ROLE_FIXED_ATTRIBUTE_VALUE);\n          poolClear(&parser->m_tempPool);\n          handleDefault = XML_FALSE;\n        }\n      }\n      break;\n    case XML_ROLE_ENTITY_VALUE:\n      if (dtd->keepProcessing) {\n        enum XML_Error result\n            = storeEntityValue(parser, enc, s + enc->minBytesPerChar,\n                               next - enc->minBytesPerChar, XML_ACCOUNT_NONE);\n        if (parser->m_declEntity) {\n          parser->m_declEntity->textPtr = poolStart(&dtd->entityValuePool);\n          parser->m_declEntity->textLen\n              = (int)(poolLength(&dtd->entityValuePool));\n          poolFinish(&dtd->entityValuePool);\n          if (parser->m_entityDeclHandler) {\n            *eventEndPP = s;\n            parser->m_entityDeclHandler(\n                parser->m_handlerArg, parser->m_declEntity->name,\n                parser->m_declEntity->is_param, parser->m_declEntity->textPtr,\n                parser->m_declEntity->textLen, parser->m_curBase, 0, 0, 0);\n            handleDefault = XML_FALSE;\n          }\n        } else\n          poolDiscard(&dtd->entityValuePool);\n        if (result != XML_ERROR_NONE)\n          return result;\n      }\n      break;\n    case XML_ROLE_DOCTYPE_SYSTEM_ID:\n#ifdef XML_DTD\n      parser->m_useForeignDTD = XML_FALSE;\n#endif /* XML_DTD */\n      dtd->hasParamEntityRefs = XML_TRUE;\n      if (parser->m_startDoctypeDeclHandler) {\n        parser->m_doctypeSysid = poolStoreString(&parser->m_tempPool, enc,\n                                                 s + enc->minBytesPerChar,\n                                                 next - enc->minBytesPerChar);\n        if (parser->m_doctypeSysid == NULL)\n          return XML_ERROR_NO_MEMORY;\n        poolFinish(&parser->m_tempPool);\n        handleDefault = XML_FALSE;\n      }\n#ifdef XML_DTD\n      else\n        /* use externalSubsetName to make parser->m_doctypeSysid non-NULL\n           for the case where no parser->m_startDoctypeDeclHandler is set */\n        parser->m_doctypeSysid = externalSubsetName;\n#endif /* XML_DTD */\n      if (! dtd->standalone\n#ifdef XML_DTD\n          && ! parser->m_paramEntityParsing\n#endif /* XML_DTD */\n          && parser->m_notStandaloneHandler\n          && ! parser->m_notStandaloneHandler(parser->m_handlerArg))\n        return XML_ERROR_NOT_STANDALONE;\n#ifndef XML_DTD\n      break;\n#else  /* XML_DTD */\n      if (! parser->m_declEntity) {\n        parser->m_declEntity = (ENTITY *)lookup(\n            parser, &dtd->paramEntities, externalSubsetName, sizeof(ENTITY));\n        if (! parser->m_declEntity)\n          return XML_ERROR_NO_MEMORY;\n        parser->m_declEntity->publicId = NULL;\n      }\n#endif /* XML_DTD */\n      /* fall through */\n    case XML_ROLE_ENTITY_SYSTEM_ID:\n      if (dtd->keepProcessing && parser->m_declEntity) {\n        parser->m_declEntity->systemId\n            = poolStoreString(&dtd->pool, enc, s + enc->minBytesPerChar,\n                              next - enc->minBytesPerChar);\n        if (! parser->m_declEntity->systemId)\n          return XML_ERROR_NO_MEMORY;\n        parser->m_declEntity->base = parser->m_curBase;\n        poolFinish(&dtd->pool);\n        /* Don't suppress the default handler if we fell through from\n         * the XML_ROLE_DOCTYPE_SYSTEM_ID case.\n         */\n        if (parser->m_entityDeclHandler && role == XML_ROLE_ENTITY_SYSTEM_ID)\n          handleDefault = XML_FALSE;\n      }\n      break;\n    case XML_ROLE_ENTITY_COMPLETE:\n      if (dtd->keepProcessing && parser->m_declEntity\n          && parser->m_entityDeclHandler) {\n        *eventEndPP = s;\n        parser->m_entityDeclHandler(\n            parser->m_handlerArg, parser->m_declEntity->name,\n            parser->m_declEntity->is_param, 0, 0, parser->m_declEntity->base,\n            parser->m_declEntity->systemId, parser->m_declEntity->publicId, 0);\n        handleDefault = XML_FALSE;\n      }\n      break;\n    case XML_ROLE_ENTITY_NOTATION_NAME:\n      if (dtd->keepProcessing && parser->m_declEntity) {\n        parser->m_declEntity->notation\n            = poolStoreString(&dtd->pool, enc, s, next);\n        if (! parser->m_declEntity->notation)\n          return XML_ERROR_NO_MEMORY;\n        poolFinish(&dtd->pool);\n        if (parser->m_unparsedEntityDeclHandler) {\n          *eventEndPP = s;\n          parser->m_unparsedEntityDeclHandler(\n              parser->m_handlerArg, parser->m_declEntity->name,\n              parser->m_declEntity->base, parser->m_declEntity->systemId,\n              parser->m_declEntity->publicId, parser->m_declEntity->notation);\n          handleDefault = XML_FALSE;\n        } else if (parser->m_entityDeclHandler) {\n          *eventEndPP = s;\n          parser->m_entityDeclHandler(\n              parser->m_handlerArg, parser->m_declEntity->name, 0, 0, 0,\n              parser->m_declEntity->base, parser->m_declEntity->systemId,\n              parser->m_declEntity->publicId, parser->m_declEntity->notation);\n          handleDefault = XML_FALSE;\n        }\n      }\n      break;\n    case XML_ROLE_GENERAL_ENTITY_NAME: {\n      if (XmlPredefinedEntityName(enc, s, next)) {\n        parser->m_declEntity = NULL;\n        break;\n      }\n      if (dtd->keepProcessing) {\n        const XML_Char *name = poolStoreString(&dtd->pool, enc, s, next);\n        if (! name)\n          return XML_ERROR_NO_MEMORY;\n        parser->m_declEntity = (ENTITY *)lookup(parser, &dtd->generalEntities,\n                                                name, sizeof(ENTITY));\n        if (! parser->m_declEntity)\n          return XML_ERROR_NO_MEMORY;\n        if (parser->m_declEntity->name != name) {\n          poolDiscard(&dtd->pool);\n          parser->m_declEntity = NULL;\n        } else {\n          poolFinish(&dtd->pool);\n          parser->m_declEntity->publicId = NULL;\n          parser->m_declEntity->is_param = XML_FALSE;\n          /* if we have a parent parser or are reading an internal parameter\n             entity, then the entity declaration is not considered \"internal\"\n          */\n          parser->m_declEntity->is_internal\n              = ! (parser->m_parentParser || parser->m_openInternalEntities);\n          if (parser->m_entityDeclHandler)\n            handleDefault = XML_FALSE;\n        }\n      } else {\n        poolDiscard(&dtd->pool);\n        parser->m_declEntity = NULL;\n      }\n    } break;\n    case XML_ROLE_PARAM_ENTITY_NAME:\n#ifdef XML_DTD\n      if (dtd->keepProcessing) {\n        const XML_Char *name = poolStoreString(&dtd->pool, enc, s, next);\n        if (! name)\n          return XML_ERROR_NO_MEMORY;\n        parser->m_declEntity = (ENTITY *)lookup(parser, &dtd->paramEntities,\n                                                name, sizeof(ENTITY));\n        if (! parser->m_declEntity)\n          return XML_ERROR_NO_MEMORY;\n        if (parser->m_declEntity->name != name) {\n          poolDiscard(&dtd->pool);\n          parser->m_declEntity = NULL;\n        } else {\n          poolFinish(&dtd->pool);\n          parser->m_declEntity->publicId = NULL;\n          parser->m_declEntity->is_param = XML_TRUE;\n          /* if we have a parent parser or are reading an internal parameter\n             entity, then the entity declaration is not considered \"internal\"\n          */\n          parser->m_declEntity->is_internal\n              = ! (parser->m_parentParser || parser->m_openInternalEntities);\n          if (parser->m_entityDeclHandler)\n            handleDefault = XML_FALSE;\n        }\n      } else {\n        poolDiscard(&dtd->pool);\n        parser->m_declEntity = NULL;\n      }\n#else  /* not XML_DTD */\n      parser->m_declEntity = NULL;\n#endif /* XML_DTD */\n      break;\n    case XML_ROLE_NOTATION_NAME:\n      parser->m_declNotationPublicId = NULL;\n      parser->m_declNotationName = NULL;\n      if (parser->m_notationDeclHandler) {\n        parser->m_declNotationName\n            = poolStoreString(&parser->m_tempPool, enc, s, next);\n        if (! parser->m_declNotationName)\n          return XML_ERROR_NO_MEMORY;\n        poolFinish(&parser->m_tempPool);\n        handleDefault = XML_FALSE;\n      }\n      break;\n    case XML_ROLE_NOTATION_PUBLIC_ID:\n      if (! XmlIsPublicId(enc, s, next, eventPP))\n        return XML_ERROR_PUBLICID;\n      if (parser\n              ->m_declNotationName) { /* means m_notationDeclHandler != NULL */\n        XML_Char *tem = poolStoreString(&parser->m_tempPool, enc,\n                                        s + enc->minBytesPerChar,\n                                        next - enc->minBytesPerChar);\n        if (! tem)\n          return XML_ERROR_NO_MEMORY;\n        normalizePublicId(tem);\n        parser->m_declNotationPublicId = tem;\n        poolFinish(&parser->m_tempPool);\n        handleDefault = XML_FALSE;\n      }\n      break;\n    case XML_ROLE_NOTATION_SYSTEM_ID:\n      if (parser->m_declNotationName && parser->m_notationDeclHandler) {\n        const XML_Char *systemId = poolStoreString(&parser->m_tempPool, enc,\n                                                   s + enc->minBytesPerChar,\n                                                   next - enc->minBytesPerChar);\n        if (! systemId)\n          return XML_ERROR_NO_MEMORY;\n        *eventEndPP = s;\n        parser->m_notationDeclHandler(\n            parser->m_handlerArg, parser->m_declNotationName, parser->m_curBase,\n            systemId, parser->m_declNotationPublicId);\n        handleDefault = XML_FALSE;\n      }\n      poolClear(&parser->m_tempPool);\n      break;\n    case XML_ROLE_NOTATION_NO_SYSTEM_ID:\n      if (parser->m_declNotationPublicId && parser->m_notationDeclHandler) {\n        *eventEndPP = s;\n        parser->m_notationDeclHandler(\n            parser->m_handlerArg, parser->m_declNotationName, parser->m_curBase,\n            0, parser->m_declNotationPublicId);\n        handleDefault = XML_FALSE;\n      }\n      poolClear(&parser->m_tempPool);\n      break;\n    case XML_ROLE_ERROR:\n      switch (tok) {\n      case XML_TOK_PARAM_ENTITY_REF:\n        /* PE references in internal subset are\n           not allowed within declarations. */\n        return XML_ERROR_PARAM_ENTITY_REF;\n      case XML_TOK_XML_DECL:\n        return XML_ERROR_MISPLACED_XML_PI;\n      default:\n        return XML_ERROR_SYNTAX;\n      }\n#ifdef XML_DTD\n    case XML_ROLE_IGNORE_SECT: {\n      enum XML_Error result;\n      if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n      handleDefault = XML_FALSE;\n      result = doIgnoreSection(parser, enc, &next, end, nextPtr, haveMore);\n      if (result != XML_ERROR_NONE)\n        return result;\n      else if (! next) {\n        parser->m_processor = ignoreSectionProcessor;\n        return result;\n      }\n    } break;\n#endif /* XML_DTD */\n    case XML_ROLE_GROUP_OPEN:\n      if (parser->m_prologState.level >= parser->m_groupSize) {\n        if (parser->m_groupSize) {\n          {\n            /* Detect and prevent integer overflow */\n            if (parser->m_groupSize > (unsigned int)(-1) / 2u) {\n              return XML_ERROR_NO_MEMORY;\n            }\n\n            char *const new_connector = (char *)REALLOC(\n                parser, parser->m_groupConnector, parser->m_groupSize *= 2);\n            if (new_connector == NULL) {\n              parser->m_groupSize /= 2;\n              return XML_ERROR_NO_MEMORY;\n            }\n            parser->m_groupConnector = new_connector;\n          }\n\n          if (dtd->scaffIndex) {\n            /* Detect and prevent integer overflow.\n             * The preprocessor guard addresses the \"always false\" warning\n             * from -Wtype-limits on platforms where\n             * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */\n#if UINT_MAX >= SIZE_MAX\n            if (parser->m_groupSize > (size_t)(-1) / sizeof(int)) {\n              return XML_ERROR_NO_MEMORY;\n            }\n#endif\n\n            int *const new_scaff_index = (int *)REALLOC(\n                parser, dtd->scaffIndex, parser->m_groupSize * sizeof(int));\n            if (new_scaff_index == NULL)\n              return XML_ERROR_NO_MEMORY;\n            dtd->scaffIndex = new_scaff_index;\n          }\n        } else {\n          parser->m_groupConnector\n              = (char *)MALLOC(parser, parser->m_groupSize = 32);\n          if (! parser->m_groupConnector) {\n            parser->m_groupSize = 0;\n            return XML_ERROR_NO_MEMORY;\n          }\n        }\n      }\n      parser->m_groupConnector[parser->m_prologState.level] = 0;\n      if (dtd->in_eldecl) {\n        int myindex = nextScaffoldPart(parser);\n        if (myindex < 0)\n          return XML_ERROR_NO_MEMORY;\n        assert(dtd->scaffIndex != NULL);\n        dtd->scaffIndex[dtd->scaffLevel] = myindex;\n        dtd->scaffLevel++;\n        dtd->scaffold[myindex].type = XML_CTYPE_SEQ;\n        if (parser->m_elementDeclHandler)\n          handleDefault = XML_FALSE;\n      }\n      break;\n    case XML_ROLE_GROUP_SEQUENCE:\n      if (parser->m_groupConnector[parser->m_prologState.level] == ASCII_PIPE)\n        return XML_ERROR_SYNTAX;\n      parser->m_groupConnector[parser->m_prologState.level] = ASCII_COMMA;\n      if (dtd->in_eldecl && parser->m_elementDeclHandler)\n        handleDefault = XML_FALSE;\n      break;\n    case XML_ROLE_GROUP_CHOICE:\n      if (parser->m_groupConnector[parser->m_prologState.level] == ASCII_COMMA)\n        return XML_ERROR_SYNTAX;\n      if (dtd->in_eldecl\n          && ! parser->m_groupConnector[parser->m_prologState.level]\n          && (dtd->scaffold[dtd->scaffIndex[dtd->scaffLevel - 1]].type\n              != XML_CTYPE_MIXED)) {\n        dtd->scaffold[dtd->scaffIndex[dtd->scaffLevel - 1]].type\n            = XML_CTYPE_CHOICE;\n        if (parser->m_elementDeclHandler)\n          handleDefault = XML_FALSE;\n      }\n      parser->m_groupConnector[parser->m_prologState.level] = ASCII_PIPE;\n      break;\n    case XML_ROLE_PARAM_ENTITY_REF:\n#ifdef XML_DTD\n    case XML_ROLE_INNER_PARAM_ENTITY_REF:\n      dtd->hasParamEntityRefs = XML_TRUE;\n      if (! parser->m_paramEntityParsing)\n        dtd->keepProcessing = dtd->standalone;\n      else {\n        const XML_Char *name;\n        ENTITY *entity;\n        name = poolStoreString(&dtd->pool, enc, s + enc->minBytesPerChar,\n                               next - enc->minBytesPerChar);\n        if (! name)\n          return XML_ERROR_NO_MEMORY;\n        entity = (ENTITY *)lookup(parser, &dtd->paramEntities, name, 0);\n        poolDiscard(&dtd->pool);\n        /* first, determine if a check for an existing declaration is needed;\n           if yes, check that the entity exists, and that it is internal,\n           otherwise call the skipped entity handler\n        */\n        if (parser->m_prologState.documentEntity\n            && (dtd->standalone ? ! parser->m_openInternalEntities\n                                : ! dtd->hasParamEntityRefs)) {\n          if (! entity)\n            return XML_ERROR_UNDEFINED_ENTITY;\n          else if (! entity->is_internal) {\n            /* It's hard to exhaustively search the code to be sure,\n             * but there doesn't seem to be a way of executing the\n             * following line.  There are two cases:\n             *\n             * If 'standalone' is false, the DTD must have no\n             * parameter entities or we wouldn't have passed the outer\n             * 'if' statement.  That means the only entity in the hash\n             * table is the external subset name \"#\" which cannot be\n             * given as a parameter entity name in XML syntax, so the\n             * lookup must have returned NULL and we don't even reach\n             * the test for an internal entity.\n             *\n             * If 'standalone' is true, it does not seem to be\n             * possible to create entities taking this code path that\n             * are not internal entities, so fail the test above.\n             *\n             * Because this analysis is very uncertain, the code is\n             * being left in place and merely removed from the\n             * coverage test statistics.\n             */\n            return XML_ERROR_ENTITY_DECLARED_IN_PE; /* LCOV_EXCL_LINE */\n          }\n        } else if (! entity) {\n          dtd->keepProcessing = dtd->standalone;\n          /* cannot report skipped entities in declarations */\n          if ((role == XML_ROLE_PARAM_ENTITY_REF)\n              && parser->m_skippedEntityHandler) {\n            parser->m_skippedEntityHandler(parser->m_handlerArg, name, 1);\n            handleDefault = XML_FALSE;\n          }\n          break;\n        }\n        if (entity->open)\n          return XML_ERROR_RECURSIVE_ENTITY_REF;\n        if (entity->textPtr) {\n          enum XML_Error result;\n          XML_Bool betweenDecl\n              = (role == XML_ROLE_PARAM_ENTITY_REF ? XML_TRUE : XML_FALSE);\n          result = processInternalEntity(parser, entity, betweenDecl);\n          if (result != XML_ERROR_NONE)\n            return result;\n          handleDefault = XML_FALSE;\n          break;\n        }\n        if (parser->m_externalEntityRefHandler) {\n          dtd->paramEntityRead = XML_FALSE;\n          entity->open = XML_TRUE;\n          entityTrackingOnOpen(parser, entity, __LINE__);\n          if (! parser->m_externalEntityRefHandler(\n                  parser->m_externalEntityRefHandlerArg, 0, entity->base,\n                  entity->systemId, entity->publicId)) {\n            entityTrackingOnClose(parser, entity, __LINE__);\n            entity->open = XML_FALSE;\n            return XML_ERROR_EXTERNAL_ENTITY_HANDLING;\n          }\n          entityTrackingOnClose(parser, entity, __LINE__);\n          entity->open = XML_FALSE;\n          handleDefault = XML_FALSE;\n          if (! dtd->paramEntityRead) {\n            dtd->keepProcessing = dtd->standalone;\n            break;\n          }\n        } else {\n          dtd->keepProcessing = dtd->standalone;\n          break;\n        }\n      }\n#endif /* XML_DTD */\n      if (! dtd->standalone && parser->m_notStandaloneHandler\n          && ! parser->m_notStandaloneHandler(parser->m_handlerArg))\n        return XML_ERROR_NOT_STANDALONE;\n      break;\n\n      /* Element declaration stuff */\n\n    case XML_ROLE_ELEMENT_NAME:\n      if (parser->m_elementDeclHandler) {\n        parser->m_declElementType = getElementType(parser, enc, s, next);\n        if (! parser->m_declElementType)\n          return XML_ERROR_NO_MEMORY;\n        dtd->scaffLevel = 0;\n        dtd->scaffCount = 0;\n        dtd->in_eldecl = XML_TRUE;\n        handleDefault = XML_FALSE;\n      }\n      break;\n\n    case XML_ROLE_CONTENT_ANY:\n    case XML_ROLE_CONTENT_EMPTY:\n      if (dtd->in_eldecl) {\n        if (parser->m_elementDeclHandler) {\n          XML_Content *content\n              = (XML_Content *)MALLOC(parser, sizeof(XML_Content));\n          if (! content)\n            return XML_ERROR_NO_MEMORY;\n          content->quant = XML_CQUANT_NONE;\n          content->name = NULL;\n          content->numchildren = 0;\n          content->children = NULL;\n          content->type = ((role == XML_ROLE_CONTENT_ANY) ? XML_CTYPE_ANY\n                                                          : XML_CTYPE_EMPTY);\n          *eventEndPP = s;\n          parser->m_elementDeclHandler(\n              parser->m_handlerArg, parser->m_declElementType->name, content);\n          handleDefault = XML_FALSE;\n        }\n        dtd->in_eldecl = XML_FALSE;\n      }\n      break;\n\n    case XML_ROLE_CONTENT_PCDATA:\n      if (dtd->in_eldecl) {\n        dtd->scaffold[dtd->scaffIndex[dtd->scaffLevel - 1]].type\n            = XML_CTYPE_MIXED;\n        if (parser->m_elementDeclHandler)\n          handleDefault = XML_FALSE;\n      }\n      break;\n\n    case XML_ROLE_CONTENT_ELEMENT:\n      quant = XML_CQUANT_NONE;\n      goto elementContent;\n    case XML_ROLE_CONTENT_ELEMENT_OPT:\n      quant = XML_CQUANT_OPT;\n      goto elementContent;\n    case XML_ROLE_CONTENT_ELEMENT_REP:\n      quant = XML_CQUANT_REP;\n      goto elementContent;\n    case XML_ROLE_CONTENT_ELEMENT_PLUS:\n      quant = XML_CQUANT_PLUS;\n    elementContent:\n      if (dtd->in_eldecl) {\n        ELEMENT_TYPE *el;\n        const XML_Char *name;\n        size_t nameLen;\n        const char *nxt\n            = (quant == XML_CQUANT_NONE ? next : next - enc->minBytesPerChar);\n        int myindex = nextScaffoldPart(parser);\n        if (myindex < 0)\n          return XML_ERROR_NO_MEMORY;\n        dtd->scaffold[myindex].type = XML_CTYPE_NAME;\n        dtd->scaffold[myindex].quant = quant;\n        el = getElementType(parser, enc, s, nxt);\n        if (! el)\n          return XML_ERROR_NO_MEMORY;\n        name = el->name;\n        dtd->scaffold[myindex].name = name;\n        nameLen = 0;\n        for (; name[nameLen++];)\n          ;\n\n        /* Detect and prevent integer overflow */\n        if (nameLen > UINT_MAX - dtd->contentStringLen) {\n          return XML_ERROR_NO_MEMORY;\n        }\n\n        dtd->contentStringLen += (unsigned)nameLen;\n        if (parser->m_elementDeclHandler)\n          handleDefault = XML_FALSE;\n      }\n      break;\n\n    case XML_ROLE_GROUP_CLOSE:\n      quant = XML_CQUANT_NONE;\n      goto closeGroup;\n    case XML_ROLE_GROUP_CLOSE_OPT:\n      quant = XML_CQUANT_OPT;\n      goto closeGroup;\n    case XML_ROLE_GROUP_CLOSE_REP:\n      quant = XML_CQUANT_REP;\n      goto closeGroup;\n    case XML_ROLE_GROUP_CLOSE_PLUS:\n      quant = XML_CQUANT_PLUS;\n    closeGroup:\n      if (dtd->in_eldecl) {\n        if (parser->m_elementDeclHandler)\n          handleDefault = XML_FALSE;\n        dtd->scaffLevel--;\n        dtd->scaffold[dtd->scaffIndex[dtd->scaffLevel]].quant = quant;\n        if (dtd->scaffLevel == 0) {\n          if (! handleDefault) {\n            XML_Content *model = build_model(parser);\n            if (! model)\n              return XML_ERROR_NO_MEMORY;\n            *eventEndPP = s;\n            parser->m_elementDeclHandler(\n                parser->m_handlerArg, parser->m_declElementType->name, model);\n          }\n          dtd->in_eldecl = XML_FALSE;\n          dtd->contentStringLen = 0;\n        }\n      }\n      break;\n      /* End element declaration stuff */\n\n    case XML_ROLE_PI:\n      if (! reportProcessingInstruction(parser, enc, s, next))\n        return XML_ERROR_NO_MEMORY;\n      handleDefault = XML_FALSE;\n      break;\n    case XML_ROLE_COMMENT:\n      if (! reportComment(parser, enc, s, next))\n        return XML_ERROR_NO_MEMORY;\n      handleDefault = XML_FALSE;\n      break;\n    case XML_ROLE_NONE:\n      switch (tok) {\n      case XML_TOK_BOM:\n        handleDefault = XML_FALSE;\n        break;\n      }\n      break;\n    case XML_ROLE_DOCTYPE_NONE:\n      if (parser->m_startDoctypeDeclHandler)\n        handleDefault = XML_FALSE;\n      break;\n    case XML_ROLE_ENTITY_NONE:\n      if (dtd->keepProcessing && parser->m_entityDeclHandler)\n        handleDefault = XML_FALSE;\n      break;\n    case XML_ROLE_NOTATION_NONE:\n      if (parser->m_notationDeclHandler)\n        handleDefault = XML_FALSE;\n      break;\n    case XML_ROLE_ATTLIST_NONE:\n      if (dtd->keepProcessing && parser->m_attlistDeclHandler)\n        handleDefault = XML_FALSE;\n      break;\n    case XML_ROLE_ELEMENT_NONE:\n      if (parser->m_elementDeclHandler)\n        handleDefault = XML_FALSE;\n      break;\n    } /* end of big switch */\n\n    if (handleDefault && parser->m_defaultHandler)\n      reportDefault(parser, enc, s, next);\n\n    switch (parser->m_parsingStatus.parsing) {\n    case XML_SUSPENDED:\n      *nextPtr = next;\n      return XML_ERROR_NONE;\n    case XML_FINISHED:\n      return XML_ERROR_ABORTED;\n    default:\n      s = next;\n      tok = XmlPrologTok(enc, s, end, &next);\n    }\n  }\n  /* not reached */\n}\n\nstatic enum XML_Error PTRCALL\nepilogProcessor(XML_Parser parser, const char *s, const char *end,\n                const char **nextPtr) {\n  parser->m_processor = epilogProcessor;\n  parser->m_eventPtr = s;\n  for (;;) {\n    const char *next = NULL;\n    int tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n#if defined(XML_DTD) || XML_GE == 1\n    if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                  XML_ACCOUNT_DIRECT)) {\n      accountingOnAbort(parser);\n      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n    }\n#endif\n    parser->m_eventEndPtr = next;\n    switch (tok) {\n    /* report partial linebreak - it might be the last token */\n    case -XML_TOK_PROLOG_S:\n      if (parser->m_defaultHandler) {\n        reportDefault(parser, parser->m_encoding, s, next);\n        if (parser->m_parsingStatus.parsing == XML_FINISHED)\n          return XML_ERROR_ABORTED;\n      }\n      *nextPtr = next;\n      return XML_ERROR_NONE;\n    case XML_TOK_NONE:\n      *nextPtr = s;\n      return XML_ERROR_NONE;\n    case XML_TOK_PROLOG_S:\n      if (parser->m_defaultHandler)\n        reportDefault(parser, parser->m_encoding, s, next);\n      break;\n    case XML_TOK_PI:\n      if (! reportProcessingInstruction(parser, parser->m_encoding, s, next))\n        return XML_ERROR_NO_MEMORY;\n      break;\n    case XML_TOK_COMMENT:\n      if (! reportComment(parser, parser->m_encoding, s, next))\n        return XML_ERROR_NO_MEMORY;\n      break;\n    case XML_TOK_INVALID:\n      parser->m_eventPtr = next;\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_PARTIAL:\n      if (! parser->m_parsingStatus.finalBuffer) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      return XML_ERROR_UNCLOSED_TOKEN;\n    case XML_TOK_PARTIAL_CHAR:\n      if (! parser->m_parsingStatus.finalBuffer) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      return XML_ERROR_PARTIAL_CHAR;\n    default:\n      return XML_ERROR_JUNK_AFTER_DOC_ELEMENT;\n    }\n    parser->m_eventPtr = s = next;\n    switch (parser->m_parsingStatus.parsing) {\n    case XML_SUSPENDED:\n      *nextPtr = next;\n      return XML_ERROR_NONE;\n    case XML_FINISHED:\n      return XML_ERROR_ABORTED;\n    default:;\n    }\n  }\n}\n\nstatic enum XML_Error\nprocessInternalEntity(XML_Parser parser, ENTITY *entity, XML_Bool betweenDecl) {\n  const char *textStart, *textEnd;\n  const char *next;\n  enum XML_Error result;\n  OPEN_INTERNAL_ENTITY *openEntity;\n\n  if (parser->m_freeInternalEntities) {\n    openEntity = parser->m_freeInternalEntities;\n    parser->m_freeInternalEntities = openEntity->next;\n  } else {\n    openEntity\n        = (OPEN_INTERNAL_ENTITY *)MALLOC(parser, sizeof(OPEN_INTERNAL_ENTITY));\n    if (! openEntity)\n      return XML_ERROR_NO_MEMORY;\n  }\n  entity->open = XML_TRUE;\n#if defined(XML_DTD) || XML_GE == 1\n  entityTrackingOnOpen(parser, entity, __LINE__);\n#endif\n  entity->processed = 0;\n  openEntity->next = parser->m_openInternalEntities;\n  parser->m_openInternalEntities = openEntity;\n  openEntity->entity = entity;\n  openEntity->startTagLevel = parser->m_tagLevel;\n  openEntity->betweenDecl = betweenDecl;\n  openEntity->internalEventPtr = NULL;\n  openEntity->internalEventEndPtr = NULL;\n  textStart = (const char *)entity->textPtr;\n  textEnd = (const char *)(entity->textPtr + entity->textLen);\n  /* Set a safe default value in case 'next' does not get set */\n  next = textStart;\n\n#ifdef XML_DTD\n  if (entity->is_param) {\n    int tok\n        = XmlPrologTok(parser->m_internalEncoding, textStart, textEnd, &next);\n    result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd,\n                      tok, next, &next, XML_FALSE, XML_FALSE,\n                      XML_ACCOUNT_ENTITY_EXPANSION);\n  } else\n#endif /* XML_DTD */\n    result = doContent(parser, parser->m_tagLevel, parser->m_internalEncoding,\n                       textStart, textEnd, &next, XML_FALSE,\n                       XML_ACCOUNT_ENTITY_EXPANSION);\n\n  if (result == XML_ERROR_NONE) {\n    if (textEnd != next && parser->m_parsingStatus.parsing == XML_SUSPENDED) {\n      entity->processed = (int)(next - textStart);\n      parser->m_processor = internalEntityProcessor;\n    } else {\n#if defined(XML_DTD) || XML_GE == 1\n      entityTrackingOnClose(parser, entity, __LINE__);\n#endif /* defined(XML_DTD) || XML_GE == 1 */\n      entity->open = XML_FALSE;\n      parser->m_openInternalEntities = openEntity->next;\n      /* put openEntity back in list of free instances */\n      openEntity->next = parser->m_freeInternalEntities;\n      parser->m_freeInternalEntities = openEntity;\n    }\n  }\n  return result;\n}\n\nstatic enum XML_Error PTRCALL\ninternalEntityProcessor(XML_Parser parser, const char *s, const char *end,\n                        const char **nextPtr) {\n  ENTITY *entity;\n  const char *textStart, *textEnd;\n  const char *next;\n  enum XML_Error result;\n  OPEN_INTERNAL_ENTITY *openEntity = parser->m_openInternalEntities;\n  if (! openEntity)\n    return XML_ERROR_UNEXPECTED_STATE;\n\n  entity = openEntity->entity;\n  textStart = ((const char *)entity->textPtr) + entity->processed;\n  textEnd = (const char *)(entity->textPtr + entity->textLen);\n  /* Set a safe default value in case 'next' does not get set */\n  next = textStart;\n\n#ifdef XML_DTD\n  if (entity->is_param) {\n    int tok\n        = XmlPrologTok(parser->m_internalEncoding, textStart, textEnd, &next);\n    result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd,\n                      tok, next, &next, XML_FALSE, XML_TRUE,\n                      XML_ACCOUNT_ENTITY_EXPANSION);\n  } else\n#endif /* XML_DTD */\n    result = doContent(parser, openEntity->startTagLevel,\n                       parser->m_internalEncoding, textStart, textEnd, &next,\n                       XML_FALSE, XML_ACCOUNT_ENTITY_EXPANSION);\n\n  if (result != XML_ERROR_NONE)\n    return result;\n\n  if (textEnd != next && parser->m_parsingStatus.parsing == XML_SUSPENDED) {\n    entity->processed = (int)(next - (const char *)entity->textPtr);\n    return result;\n  }\n\n#if defined(XML_DTD) || XML_GE == 1\n  entityTrackingOnClose(parser, entity, __LINE__);\n#endif\n  entity->open = XML_FALSE;\n  parser->m_openInternalEntities = openEntity->next;\n  /* put openEntity back in list of free instances */\n  openEntity->next = parser->m_freeInternalEntities;\n  parser->m_freeInternalEntities = openEntity;\n\n  // If there are more open entities we want to stop right here and have the\n  // upcoming call to XML_ResumeParser continue with entity content, or it would\n  // be ignored altogether.\n  if (parser->m_openInternalEntities != NULL\n      && parser->m_parsingStatus.parsing == XML_SUSPENDED) {\n    return XML_ERROR_NONE;\n  }\n\n#ifdef XML_DTD\n  if (entity->is_param) {\n    int tok;\n    parser->m_processor = prologProcessor;\n    tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n    return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                    (XML_Bool)! parser->m_parsingStatus.finalBuffer, XML_TRUE,\n                    XML_ACCOUNT_DIRECT);\n  } else\n#endif /* XML_DTD */\n  {\n    parser->m_processor = contentProcessor;\n    /* see externalEntityContentProcessor vs contentProcessor */\n    result = doContent(parser, parser->m_parentParser ? 1 : 0,\n                       parser->m_encoding, s, end, nextPtr,\n                       (XML_Bool)! parser->m_parsingStatus.finalBuffer,\n                       XML_ACCOUNT_DIRECT);\n    if (result == XML_ERROR_NONE) {\n      if (! storeRawNames(parser))\n        return XML_ERROR_NO_MEMORY;\n    }\n    return result;\n  }\n}\n\nstatic enum XML_Error PTRCALL\nerrorProcessor(XML_Parser parser, const char *s, const char *end,\n               const char **nextPtr) {\n  UNUSED_P(s);\n  UNUSED_P(end);\n  UNUSED_P(nextPtr);\n  return parser->m_errorCode;\n}\n\nstatic enum XML_Error\nstoreAttributeValue(XML_Parser parser, const ENCODING *enc, XML_Bool isCdata,\n                    const char *ptr, const char *end, STRING_POOL *pool,\n                    enum XML_Account account) {\n  enum XML_Error result\n      = appendAttributeValue(parser, enc, isCdata, ptr, end, pool, account);\n  if (result)\n    return result;\n  if (! isCdata && poolLength(pool) && poolLastChar(pool) == 0x20)\n    poolChop(pool);\n  if (! poolAppendChar(pool, XML_T('\\0')))\n    return XML_ERROR_NO_MEMORY;\n  return XML_ERROR_NONE;\n}\n\nstatic enum XML_Error\nappendAttributeValue(XML_Parser parser, const ENCODING *enc, XML_Bool isCdata,\n                     const char *ptr, const char *end, STRING_POOL *pool,\n                     enum XML_Account account) {\n  DTD *const dtd = parser->m_dtd; /* save one level of indirection */\n#ifndef XML_DTD\n  UNUSED_P(account);\n#endif\n\n  for (;;) {\n    const char *next\n        = ptr; /* XmlAttributeValueTok doesn't always set the last arg */\n    int tok = XmlAttributeValueTok(enc, ptr, end, &next);\n#if defined(XML_DTD) || XML_GE == 1\n    if (! accountingDiffTolerated(parser, tok, ptr, next, __LINE__, account)) {\n      accountingOnAbort(parser);\n      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n    }\n#endif\n    switch (tok) {\n    case XML_TOK_NONE:\n      return XML_ERROR_NONE;\n    case XML_TOK_INVALID:\n      if (enc == parser->m_encoding)\n        parser->m_eventPtr = next;\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_PARTIAL:\n      if (enc == parser->m_encoding)\n        parser->m_eventPtr = ptr;\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_CHAR_REF: {\n      XML_Char buf[XML_ENCODE_MAX];\n      int i;\n      int n = XmlCharRefNumber(enc, ptr);\n      if (n < 0) {\n        if (enc == parser->m_encoding)\n          parser->m_eventPtr = ptr;\n        return XML_ERROR_BAD_CHAR_REF;\n      }\n      if (! isCdata && n == 0x20 /* space */\n          && (poolLength(pool) == 0 || poolLastChar(pool) == 0x20))\n        break;\n      n = XmlEncode(n, (ICHAR *)buf);\n      /* The XmlEncode() functions can never return 0 here.  That\n       * error return happens if the code point passed in is either\n       * negative or greater than or equal to 0x110000.  The\n       * XmlCharRefNumber() functions will all return a number\n       * strictly less than 0x110000 or a negative value if an error\n       * occurred.  The negative value is intercepted above, so\n       * XmlEncode() is never passed a value it might return an\n       * error for.\n       */\n      for (i = 0; i < n; i++) {\n        if (! poolAppendChar(pool, buf[i]))\n          return XML_ERROR_NO_MEMORY;\n      }\n    } break;\n    case XML_TOK_DATA_CHARS:\n      if (! poolAppend(pool, enc, ptr, next))\n        return XML_ERROR_NO_MEMORY;\n      break;\n    case XML_TOK_TRAILING_CR:\n      next = ptr + enc->minBytesPerChar;\n      /* fall through */\n    case XML_TOK_ATTRIBUTE_VALUE_S:\n    case XML_TOK_DATA_NEWLINE:\n      if (! isCdata && (poolLength(pool) == 0 || poolLastChar(pool) == 0x20))\n        break;\n      if (! poolAppendChar(pool, 0x20))\n        return XML_ERROR_NO_MEMORY;\n      break;\n    case XML_TOK_ENTITY_REF: {\n      const XML_Char *name;\n      ENTITY *entity;\n      char checkEntityDecl;\n      XML_Char ch = (XML_Char)XmlPredefinedEntityName(\n          enc, ptr + enc->minBytesPerChar, next - enc->minBytesPerChar);\n      if (ch) {\n#if defined(XML_DTD) || XML_GE == 1\n        /* NOTE: We are replacing 4-6 characters original input for 1 character\n         *       so there is no amplification and hence recording without\n         *       protection. */\n        accountingDiffTolerated(parser, tok, (char *)&ch,\n                                ((char *)&ch) + sizeof(XML_Char), __LINE__,\n                                XML_ACCOUNT_ENTITY_EXPANSION);\n#endif /* defined(XML_DTD) || XML_GE == 1 */\n        if (! poolAppendChar(pool, ch))\n          return XML_ERROR_NO_MEMORY;\n        break;\n      }\n      name = poolStoreString(&parser->m_temp2Pool, enc,\n                             ptr + enc->minBytesPerChar,\n                             next - enc->minBytesPerChar);\n      if (! name)\n        return XML_ERROR_NO_MEMORY;\n      entity = (ENTITY *)lookup(parser, &dtd->generalEntities, name, 0);\n      poolDiscard(&parser->m_temp2Pool);\n      /* First, determine if a check for an existing declaration is needed;\n         if yes, check that the entity exists, and that it is internal.\n      */\n      if (pool == &dtd->pool) /* are we called from prolog? */\n        checkEntityDecl =\n#ifdef XML_DTD\n            parser->m_prologState.documentEntity &&\n#endif /* XML_DTD */\n            (dtd->standalone ? ! parser->m_openInternalEntities\n                             : ! dtd->hasParamEntityRefs);\n      else /* if (pool == &parser->m_tempPool): we are called from content */\n        checkEntityDecl = ! dtd->hasParamEntityRefs || dtd->standalone;\n      if (checkEntityDecl) {\n        if (! entity)\n          return XML_ERROR_UNDEFINED_ENTITY;\n        else if (! entity->is_internal)\n          return XML_ERROR_ENTITY_DECLARED_IN_PE;\n      } else if (! entity) {\n        /* Cannot report skipped entity here - see comments on\n           parser->m_skippedEntityHandler.\n        if (parser->m_skippedEntityHandler)\n          parser->m_skippedEntityHandler(parser->m_handlerArg, name, 0);\n        */\n        /* Cannot call the default handler because this would be\n           out of sync with the call to the startElementHandler.\n        if ((pool == &parser->m_tempPool) && parser->m_defaultHandler)\n          reportDefault(parser, enc, ptr, next);\n        */\n        break;\n      }\n      if (entity->open) {\n        if (enc == parser->m_encoding) {\n          /* It does not appear that this line can be executed.\n           *\n           * The \"if (entity->open)\" check catches recursive entity\n           * definitions.  In order to be called with an open\n           * entity, it must have gone through this code before and\n           * been through the recursive call to\n           * appendAttributeValue() some lines below.  That call\n           * sets the local encoding (\"enc\") to the parser's\n           * internal encoding (internal_utf8 or internal_utf16),\n           * which can never be the same as the principle encoding.\n           * It doesn't appear there is another code path that gets\n           * here with entity->open being TRUE.\n           *\n           * Since it is not certain that this logic is watertight,\n           * we keep the line and merely exclude it from coverage\n           * tests.\n           */\n          parser->m_eventPtr = ptr; /* LCOV_EXCL_LINE */\n        }\n        return XML_ERROR_RECURSIVE_ENTITY_REF;\n      }\n      if (entity->notation) {\n        if (enc == parser->m_encoding)\n          parser->m_eventPtr = ptr;\n        return XML_ERROR_BINARY_ENTITY_REF;\n      }\n      if (! entity->textPtr) {\n        if (enc == parser->m_encoding)\n          parser->m_eventPtr = ptr;\n        return XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF;\n      } else {\n        enum XML_Error result;\n        const XML_Char *textEnd = entity->textPtr + entity->textLen;\n        entity->open = XML_TRUE;\n#if defined(XML_DTD) || XML_GE == 1\n        entityTrackingOnOpen(parser, entity, __LINE__);\n#endif\n        result = appendAttributeValue(parser, parser->m_internalEncoding,\n                                      isCdata, (const char *)entity->textPtr,\n                                      (const char *)textEnd, pool,\n                                      XML_ACCOUNT_ENTITY_EXPANSION);\n#if defined(XML_DTD) || XML_GE == 1\n        entityTrackingOnClose(parser, entity, __LINE__);\n#endif\n        entity->open = XML_FALSE;\n        if (result)\n          return result;\n      }\n    } break;\n    default:\n      /* The only token returned by XmlAttributeValueTok() that does\n       * not have an explicit case here is XML_TOK_PARTIAL_CHAR.\n       * Getting that would require an entity name to contain an\n       * incomplete XML character (e.g. \\xE2\\x82); however previous\n       * tokenisers will have already recognised and rejected such\n       * names before XmlAttributeValueTok() gets a look-in.  This\n       * default case should be retained as a safety net, but the code\n       * excluded from coverage tests.\n       *\n       * LCOV_EXCL_START\n       */\n      if (enc == parser->m_encoding)\n        parser->m_eventPtr = ptr;\n      return XML_ERROR_UNEXPECTED_STATE;\n      /* LCOV_EXCL_STOP */\n    }\n    ptr = next;\n  }\n  /* not reached */\n}\n\nstatic enum XML_Error\nstoreEntityValue(XML_Parser parser, const ENCODING *enc,\n                 const char *entityTextPtr, const char *entityTextEnd,\n                 enum XML_Account account) {\n  DTD *const dtd = parser->m_dtd; /* save one level of indirection */\n  STRING_POOL *pool = &(dtd->entityValuePool);\n  enum XML_Error result = XML_ERROR_NONE;\n#ifdef XML_DTD\n  int oldInEntityValue = parser->m_prologState.inEntityValue;\n  parser->m_prologState.inEntityValue = 1;\n#else\n  UNUSED_P(account);\n#endif /* XML_DTD */\n  /* never return Null for the value argument in EntityDeclHandler,\n     since this would indicate an external entity; therefore we\n     have to make sure that entityValuePool.start is not null */\n  if (! pool->blocks) {\n    if (! poolGrow(pool))\n      return XML_ERROR_NO_MEMORY;\n  }\n\n  for (;;) {\n    const char *next\n        = entityTextPtr; /* XmlEntityValueTok doesn't always set the last arg */\n    int tok = XmlEntityValueTok(enc, entityTextPtr, entityTextEnd, &next);\n\n#if defined(XML_DTD) || XML_GE == 1\n    if (! accountingDiffTolerated(parser, tok, entityTextPtr, next, __LINE__,\n                                  account)) {\n      accountingOnAbort(parser);\n      result = XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n      goto endEntityValue;\n    }\n#endif\n\n    switch (tok) {\n    case XML_TOK_PARAM_ENTITY_REF:\n#ifdef XML_DTD\n      if (parser->m_isParamEntity || enc != parser->m_encoding) {\n        const XML_Char *name;\n        ENTITY *entity;\n        name = poolStoreString(&parser->m_tempPool, enc,\n                               entityTextPtr + enc->minBytesPerChar,\n                               next - enc->minBytesPerChar);\n        if (! name) {\n          result = XML_ERROR_NO_MEMORY;\n          goto endEntityValue;\n        }\n        entity = (ENTITY *)lookup(parser, &dtd->paramEntities, name, 0);\n        poolDiscard(&parser->m_tempPool);\n        if (! entity) {\n          /* not a well-formedness error - see XML 1.0: WFC Entity Declared */\n          /* cannot report skipped entity here - see comments on\n             parser->m_skippedEntityHandler\n          if (parser->m_skippedEntityHandler)\n            parser->m_skippedEntityHandler(parser->m_handlerArg, name, 0);\n          */\n          dtd->keepProcessing = dtd->standalone;\n          goto endEntityValue;\n        }\n        if (entity->open) {\n          if (enc == parser->m_encoding)\n            parser->m_eventPtr = entityTextPtr;\n          result = XML_ERROR_RECURSIVE_ENTITY_REF;\n          goto endEntityValue;\n        }\n        if (entity->systemId) {\n          if (parser->m_externalEntityRefHandler) {\n            dtd->paramEntityRead = XML_FALSE;\n            entity->open = XML_TRUE;\n            entityTrackingOnOpen(parser, entity, __LINE__);\n            if (! parser->m_externalEntityRefHandler(\n                    parser->m_externalEntityRefHandlerArg, 0, entity->base,\n                    entity->systemId, entity->publicId)) {\n              entityTrackingOnClose(parser, entity, __LINE__);\n              entity->open = XML_FALSE;\n              result = XML_ERROR_EXTERNAL_ENTITY_HANDLING;\n              goto endEntityValue;\n            }\n            entityTrackingOnClose(parser, entity, __LINE__);\n            entity->open = XML_FALSE;\n            if (! dtd->paramEntityRead)\n              dtd->keepProcessing = dtd->standalone;\n          } else\n            dtd->keepProcessing = dtd->standalone;\n        } else {\n          entity->open = XML_TRUE;\n          entityTrackingOnOpen(parser, entity, __LINE__);\n          result = storeEntityValue(\n              parser, parser->m_internalEncoding, (const char *)entity->textPtr,\n              (const char *)(entity->textPtr + entity->textLen),\n              XML_ACCOUNT_ENTITY_EXPANSION);\n          entityTrackingOnClose(parser, entity, __LINE__);\n          entity->open = XML_FALSE;\n          if (result)\n            goto endEntityValue;\n        }\n        break;\n      }\n#endif /* XML_DTD */\n      /* In the internal subset, PE references are not legal\n         within markup declarations, e.g entity values in this case. */\n      parser->m_eventPtr = entityTextPtr;\n      result = XML_ERROR_PARAM_ENTITY_REF;\n      goto endEntityValue;\n    case XML_TOK_NONE:\n      result = XML_ERROR_NONE;\n      goto endEntityValue;\n    case XML_TOK_ENTITY_REF:\n    case XML_TOK_DATA_CHARS:\n      if (! poolAppend(pool, enc, entityTextPtr, next)) {\n        result = XML_ERROR_NO_MEMORY;\n        goto endEntityValue;\n      }\n      break;\n    case XML_TOK_TRAILING_CR:\n      next = entityTextPtr + enc->minBytesPerChar;\n      /* fall through */\n    case XML_TOK_DATA_NEWLINE:\n      if (pool->end == pool->ptr && ! poolGrow(pool)) {\n        result = XML_ERROR_NO_MEMORY;\n        goto endEntityValue;\n      }\n      *(pool->ptr)++ = 0xA;\n      break;\n    case XML_TOK_CHAR_REF: {\n      XML_Char buf[XML_ENCODE_MAX];\n      int i;\n      int n = XmlCharRefNumber(enc, entityTextPtr);\n      if (n < 0) {\n        if (enc == parser->m_encoding)\n          parser->m_eventPtr = entityTextPtr;\n        result = XML_ERROR_BAD_CHAR_REF;\n        goto endEntityValue;\n      }\n      n = XmlEncode(n, (ICHAR *)buf);\n      /* The XmlEncode() functions can never return 0 here.  That\n       * error return happens if the code point passed in is either\n       * negative or greater than or equal to 0x110000.  The\n       * XmlCharRefNumber() functions will all return a number\n       * strictly less than 0x110000 or a negative value if an error\n       * occurred.  The negative value is intercepted above, so\n       * XmlEncode() is never passed a value it might return an\n       * error for.\n       */\n      for (i = 0; i < n; i++) {\n        if (pool->end == pool->ptr && ! poolGrow(pool)) {\n          result = XML_ERROR_NO_MEMORY;\n          goto endEntityValue;\n        }\n        *(pool->ptr)++ = buf[i];\n      }\n    } break;\n    case XML_TOK_PARTIAL:\n      if (enc == parser->m_encoding)\n        parser->m_eventPtr = entityTextPtr;\n      result = XML_ERROR_INVALID_TOKEN;\n      goto endEntityValue;\n    case XML_TOK_INVALID:\n      if (enc == parser->m_encoding)\n        parser->m_eventPtr = next;\n      result = XML_ERROR_INVALID_TOKEN;\n      goto endEntityValue;\n    default:\n      /* This default case should be unnecessary -- all the tokens\n       * that XmlEntityValueTok() can return have their own explicit\n       * cases -- but should be retained for safety.  We do however\n       * exclude it from the coverage statistics.\n       *\n       * LCOV_EXCL_START\n       */\n      if (enc == parser->m_encoding)\n        parser->m_eventPtr = entityTextPtr;\n      result = XML_ERROR_UNEXPECTED_STATE;\n      goto endEntityValue;\n      /* LCOV_EXCL_STOP */\n    }\n    entityTextPtr = next;\n  }\nendEntityValue:\n#ifdef XML_DTD\n  parser->m_prologState.inEntityValue = oldInEntityValue;\n#endif /* XML_DTD */\n  return result;\n}\n\nstatic void FASTCALL\nnormalizeLines(XML_Char *s) {\n  XML_Char *p;\n  for (;; s++) {\n    if (*s == XML_T('\\0'))\n      return;\n    if (*s == 0xD)\n      break;\n  }\n  p = s;\n  do {\n    if (*s == 0xD) {\n      *p++ = 0xA;\n      if (*++s == 0xA)\n        s++;\n    } else\n      *p++ = *s++;\n  } while (*s);\n  *p = XML_T('\\0');\n}\n\nstatic int\nreportProcessingInstruction(XML_Parser parser, const ENCODING *enc,\n                            const char *start, const char *end) {\n  const XML_Char *target;\n  XML_Char *data;\n  const char *tem;\n  if (! parser->m_processingInstructionHandler) {\n    if (parser->m_defaultHandler)\n      reportDefault(parser, enc, start, end);\n    return 1;\n  }\n  start += enc->minBytesPerChar * 2;\n  tem = start + XmlNameLength(enc, start);\n  target = poolStoreString(&parser->m_tempPool, enc, start, tem);\n  if (! target)\n    return 0;\n  poolFinish(&parser->m_tempPool);\n  data = poolStoreString(&parser->m_tempPool, enc, XmlSkipS(enc, tem),\n                         end - enc->minBytesPerChar * 2);\n  if (! data)\n    return 0;\n  normalizeLines(data);\n  parser->m_processingInstructionHandler(parser->m_handlerArg, target, data);\n  poolClear(&parser->m_tempPool);\n  return 1;\n}\n\nstatic int\nreportComment(XML_Parser parser, const ENCODING *enc, const char *start,\n              const char *end) {\n  XML_Char *data;\n  if (! parser->m_commentHandler) {\n    if (parser->m_defaultHandler)\n      reportDefault(parser, enc, start, end);\n    return 1;\n  }\n  data = poolStoreString(&parser->m_tempPool, enc,\n                         start + enc->minBytesPerChar * 4,\n                         end - enc->minBytesPerChar * 3);\n  if (! data)\n    return 0;\n  normalizeLines(data);\n  parser->m_commentHandler(parser->m_handlerArg, data);\n  poolClear(&parser->m_tempPool);\n  return 1;\n}\n\nstatic void\nreportDefault(XML_Parser parser, const ENCODING *enc, const char *s,\n              const char *end) {\n  if (MUST_CONVERT(enc, s)) {\n    enum XML_Convert_Result convert_res;\n    const char **eventPP;\n    const char **eventEndPP;\n    if (enc == parser->m_encoding) {\n      eventPP = &parser->m_eventPtr;\n      eventEndPP = &parser->m_eventEndPtr;\n    } else {\n      /* To get here, two things must be true; the parser must be\n       * using a character encoding that is not the same as the\n       * encoding passed in, and the encoding passed in must need\n       * conversion to the internal format (UTF-8 unless XML_UNICODE\n       * is defined).  The only occasions on which the encoding passed\n       * in is not the same as the parser's encoding are when it is\n       * the internal encoding (e.g. a previously defined parameter\n       * entity, already converted to internal format).  This by\n       * definition doesn't need conversion, so the whole branch never\n       * gets executed.\n       *\n       * For safety's sake we don't delete these lines and merely\n       * exclude them from coverage statistics.\n       *\n       * LCOV_EXCL_START\n       */\n      eventPP = &(parser->m_openInternalEntities->internalEventPtr);\n      eventEndPP = &(parser->m_openInternalEntities->internalEventEndPtr);\n      /* LCOV_EXCL_STOP */\n    }\n    do {\n      ICHAR *dataPtr = (ICHAR *)parser->m_dataBuf;\n      convert_res\n          = XmlConvert(enc, &s, end, &dataPtr, (ICHAR *)parser->m_dataBufEnd);\n      *eventEndPP = s;\n      parser->m_defaultHandler(parser->m_handlerArg, parser->m_dataBuf,\n                               (int)(dataPtr - (ICHAR *)parser->m_dataBuf));\n      *eventPP = s;\n    } while ((convert_res != XML_CONVERT_COMPLETED)\n             && (convert_res != XML_CONVERT_INPUT_INCOMPLETE));\n  } else\n    parser->m_defaultHandler(\n        parser->m_handlerArg, (const XML_Char *)s,\n        (int)((const XML_Char *)end - (const XML_Char *)s));\n}\n\nstatic int\ndefineAttribute(ELEMENT_TYPE *type, ATTRIBUTE_ID *attId, XML_Bool isCdata,\n                XML_Bool isId, const XML_Char *value, XML_Parser parser) {\n  DEFAULT_ATTRIBUTE *att;\n  if (value || isId) {\n    /* The handling of default attributes gets messed up if we have\n       a default which duplicates a non-default. */\n    int i;\n    for (i = 0; i < type->nDefaultAtts; i++)\n      if (attId == type->defaultAtts[i].id)\n        return 1;\n    if (isId && ! type->idAtt && ! attId->xmlns)\n      type->idAtt = attId;\n  }\n  if (type->nDefaultAtts == type->allocDefaultAtts) {\n    if (type->allocDefaultAtts == 0) {\n      type->allocDefaultAtts = 8;\n      type->defaultAtts = (DEFAULT_ATTRIBUTE *)MALLOC(\n          parser, type->allocDefaultAtts * sizeof(DEFAULT_ATTRIBUTE));\n      if (! type->defaultAtts) {\n        type->allocDefaultAtts = 0;\n        return 0;\n      }\n    } else {\n      DEFAULT_ATTRIBUTE *temp;\n\n      /* Detect and prevent integer overflow */\n      if (type->allocDefaultAtts > INT_MAX / 2) {\n        return 0;\n      }\n\n      int count = type->allocDefaultAtts * 2;\n\n      /* Detect and prevent integer overflow.\n       * The preprocessor guard addresses the \"always false\" warning\n       * from -Wtype-limits on platforms where\n       * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */\n#if UINT_MAX >= SIZE_MAX\n      if ((unsigned)count > (size_t)(-1) / sizeof(DEFAULT_ATTRIBUTE)) {\n        return 0;\n      }\n#endif\n\n      temp = (DEFAULT_ATTRIBUTE *)REALLOC(parser, type->defaultAtts,\n                                          (count * sizeof(DEFAULT_ATTRIBUTE)));\n      if (temp == NULL)\n        return 0;\n      type->allocDefaultAtts = count;\n      type->defaultAtts = temp;\n    }\n  }\n  att = type->defaultAtts + type->nDefaultAtts;\n  att->id = attId;\n  att->value = value;\n  att->isCdata = isCdata;\n  if (! isCdata)\n    attId->maybeTokenized = XML_TRUE;\n  type->nDefaultAtts += 1;\n  return 1;\n}\n\nstatic int\nsetElementTypePrefix(XML_Parser parser, ELEMENT_TYPE *elementType) {\n  DTD *const dtd = parser->m_dtd; /* save one level of indirection */\n  const XML_Char *name;\n  for (name = elementType->name; *name; name++) {\n    if (*name == XML_T(ASCII_COLON)) {\n      PREFIX *prefix;\n      const XML_Char *s;\n      for (s = elementType->name; s != name; s++) {\n        if (! poolAppendChar(&dtd->pool, *s))\n          return 0;\n      }\n      if (! poolAppendChar(&dtd->pool, XML_T('\\0')))\n        return 0;\n      prefix = (PREFIX *)lookup(parser, &dtd->prefixes, poolStart(&dtd->pool),\n                                sizeof(PREFIX));\n      if (! prefix)\n        return 0;\n      if (prefix->name == poolStart(&dtd->pool))\n        poolFinish(&dtd->pool);\n      else\n        poolDiscard(&dtd->pool);\n      elementType->prefix = prefix;\n      break;\n    }\n  }\n  return 1;\n}\n\nstatic ATTRIBUTE_ID *\ngetAttributeId(XML_Parser parser, const ENCODING *enc, const char *start,\n               const char *end) {\n  DTD *const dtd = parser->m_dtd; /* save one level of indirection */\n  ATTRIBUTE_ID *id;\n  const XML_Char *name;\n  if (! poolAppendChar(&dtd->pool, XML_T('\\0')))\n    return NULL;\n  name = poolStoreString(&dtd->pool, enc, start, end);\n  if (! name)\n    return NULL;\n  /* skip quotation mark - its storage will be reused (like in name[-1]) */\n  ++name;\n  id = (ATTRIBUTE_ID *)lookup(parser, &dtd->attributeIds, name,\n                              sizeof(ATTRIBUTE_ID));\n  if (! id)\n    return NULL;\n  if (id->name != name)\n    poolDiscard(&dtd->pool);\n  else {\n    poolFinish(&dtd->pool);\n    if (! parser->m_ns)\n      ;\n    else if (name[0] == XML_T(ASCII_x) && name[1] == XML_T(ASCII_m)\n             && name[2] == XML_T(ASCII_l) && name[3] == XML_T(ASCII_n)\n             && name[4] == XML_T(ASCII_s)\n             && (name[5] == XML_T('\\0') || name[5] == XML_T(ASCII_COLON))) {\n      if (name[5] == XML_T('\\0'))\n        id->prefix = &dtd->defaultPrefix;\n      else\n        id->prefix = (PREFIX *)lookup(parser, &dtd->prefixes, name + 6,\n                                      sizeof(PREFIX));\n      id->xmlns = XML_TRUE;\n    } else {\n      int i;\n      for (i = 0; name[i]; i++) {\n        /* attributes without prefix are *not* in the default namespace */\n        if (name[i] == XML_T(ASCII_COLON)) {\n          int j;\n          for (j = 0; j < i; j++) {\n            if (! poolAppendChar(&dtd->pool, name[j]))\n              return NULL;\n          }\n          if (! poolAppendChar(&dtd->pool, XML_T('\\0')))\n            return NULL;\n          id->prefix = (PREFIX *)lookup(parser, &dtd->prefixes,\n                                        poolStart(&dtd->pool), sizeof(PREFIX));\n          if (! id->prefix)\n            return NULL;\n          if (id->prefix->name == poolStart(&dtd->pool))\n            poolFinish(&dtd->pool);\n          else\n            poolDiscard(&dtd->pool);\n          break;\n        }\n      }\n    }\n  }\n  return id;\n}\n\n#define CONTEXT_SEP XML_T(ASCII_FF)\n\nstatic const XML_Char *\ngetContext(XML_Parser parser) {\n  DTD *const dtd = parser->m_dtd; /* save one level of indirection */\n  HASH_TABLE_ITER iter;\n  XML_Bool needSep = XML_FALSE;\n\n  if (dtd->defaultPrefix.binding) {\n    int i;\n    int len;\n    if (! poolAppendChar(&parser->m_tempPool, XML_T(ASCII_EQUALS)))\n      return NULL;\n    len = dtd->defaultPrefix.binding->uriLen;\n    if (parser->m_namespaceSeparator)\n      len--;\n    for (i = 0; i < len; i++) {\n      if (! poolAppendChar(&parser->m_tempPool,\n                           dtd->defaultPrefix.binding->uri[i])) {\n        /* Because of memory caching, I don't believe this line can be\n         * executed.\n         *\n         * This is part of a loop copying the default prefix binding\n         * URI into the parser's temporary string pool.  Previously,\n         * that URI was copied into the same string pool, with a\n         * terminating NUL character, as part of setContext().  When\n         * the pool was cleared, that leaves a block definitely big\n         * enough to hold the URI on the free block list of the pool.\n         * The URI copy in getContext() therefore cannot run out of\n         * memory.\n         *\n         * If the pool is used between the setContext() and\n         * getContext() calls, the worst it can do is leave a bigger\n         * block on the front of the free list.  Given that this is\n         * all somewhat inobvious and program logic can be changed, we\n         * don't delete the line but we do exclude it from the test\n         * coverage statistics.\n         */\n        return NULL; /* LCOV_EXCL_LINE */\n      }\n    }\n    needSep = XML_TRUE;\n  }\n\n  hashTableIterInit(&iter, &(dtd->prefixes));\n  for (;;) {\n    int i;\n    int len;\n    const XML_Char *s;\n    PREFIX *prefix = (PREFIX *)hashTableIterNext(&iter);\n    if (! prefix)\n      break;\n    if (! prefix->binding) {\n      /* This test appears to be (justifiable) paranoia.  There does\n       * not seem to be a way of injecting a prefix without a binding\n       * that doesn't get errored long before this function is called.\n       * The test should remain for safety's sake, so we instead\n       * exclude the following line from the coverage statistics.\n       */\n      continue; /* LCOV_EXCL_LINE */\n    }\n    if (needSep && ! poolAppendChar(&parser->m_tempPool, CONTEXT_SEP))\n      return NULL;\n    for (s = prefix->name; *s; s++)\n      if (! poolAppendChar(&parser->m_tempPool, *s))\n        return NULL;\n    if (! poolAppendChar(&parser->m_tempPool, XML_T(ASCII_EQUALS)))\n      return NULL;\n    len = prefix->binding->uriLen;\n    if (parser->m_namespaceSeparator)\n      len--;\n    for (i = 0; i < len; i++)\n      if (! poolAppendChar(&parser->m_tempPool, prefix->binding->uri[i]))\n        return NULL;\n    needSep = XML_TRUE;\n  }\n\n  hashTableIterInit(&iter, &(dtd->generalEntities));\n  for (;;) {\n    const XML_Char *s;\n    ENTITY *e = (ENTITY *)hashTableIterNext(&iter);\n    if (! e)\n      break;\n    if (! e->open)\n      continue;\n    if (needSep && ! poolAppendChar(&parser->m_tempPool, CONTEXT_SEP))\n      return NULL;\n    for (s = e->name; *s; s++)\n      if (! poolAppendChar(&parser->m_tempPool, *s))\n        return 0;\n    needSep = XML_TRUE;\n  }\n\n  if (! poolAppendChar(&parser->m_tempPool, XML_T('\\0')))\n    return NULL;\n  return parser->m_tempPool.start;\n}\n\nstatic XML_Bool\nsetContext(XML_Parser parser, const XML_Char *context) {\n  if (context == NULL) {\n    return XML_FALSE;\n  }\n\n  DTD *const dtd = parser->m_dtd; /* save one level of indirection */\n  const XML_Char *s = context;\n\n  while (*context != XML_T('\\0')) {\n    if (*s == CONTEXT_SEP || *s == XML_T('\\0')) {\n      ENTITY *e;\n      if (! poolAppendChar(&parser->m_tempPool, XML_T('\\0')))\n        return XML_FALSE;\n      e = (ENTITY *)lookup(parser, &dtd->generalEntities,\n                           poolStart(&parser->m_tempPool), 0);\n      if (e)\n        e->open = XML_TRUE;\n      if (*s != XML_T('\\0'))\n        s++;\n      context = s;\n      poolDiscard(&parser->m_tempPool);\n    } else if (*s == XML_T(ASCII_EQUALS)) {\n      PREFIX *prefix;\n      if (poolLength(&parser->m_tempPool) == 0)\n        prefix = &dtd->defaultPrefix;\n      else {\n        if (! poolAppendChar(&parser->m_tempPool, XML_T('\\0')))\n          return XML_FALSE;\n        prefix\n            = (PREFIX *)lookup(parser, &dtd->prefixes,\n                               poolStart(&parser->m_tempPool), sizeof(PREFIX));\n        if (! prefix)\n          return XML_FALSE;\n        if (prefix->name == poolStart(&parser->m_tempPool)) {\n          prefix->name = poolCopyString(&dtd->pool, prefix->name);\n          if (! prefix->name)\n            return XML_FALSE;\n        }\n        poolDiscard(&parser->m_tempPool);\n      }\n      for (context = s + 1; *context != CONTEXT_SEP && *context != XML_T('\\0');\n           context++)\n        if (! poolAppendChar(&parser->m_tempPool, *context))\n          return XML_FALSE;\n      if (! poolAppendChar(&parser->m_tempPool, XML_T('\\0')))\n        return XML_FALSE;\n      if (addBinding(parser, prefix, NULL, poolStart(&parser->m_tempPool),\n                     &parser->m_inheritedBindings)\n          != XML_ERROR_NONE)\n        return XML_FALSE;\n      poolDiscard(&parser->m_tempPool);\n      if (*context != XML_T('\\0'))\n        ++context;\n      s = context;\n    } else {\n      if (! poolAppendChar(&parser->m_tempPool, *s))\n        return XML_FALSE;\n      s++;\n    }\n  }\n  return XML_TRUE;\n}\n\nstatic void FASTCALL\nnormalizePublicId(XML_Char *publicId) {\n  XML_Char *p = publicId;\n  XML_Char *s;\n  for (s = publicId; *s; s++) {\n    switch (*s) {\n    case 0x20:\n    case 0xD:\n    case 0xA:\n      if (p != publicId && p[-1] != 0x20)\n        *p++ = 0x20;\n      break;\n    default:\n      *p++ = *s;\n    }\n  }\n  if (p != publicId && p[-1] == 0x20)\n    --p;\n  *p = XML_T('\\0');\n}\n\nstatic DTD *\ndtdCreate(const XML_Memory_Handling_Suite *ms) {\n  DTD *p = ms->malloc_fcn(sizeof(DTD));\n  if (p == NULL)\n    return p;\n  poolInit(&(p->pool), ms);\n  poolInit(&(p->entityValuePool), ms);\n  hashTableInit(&(p->generalEntities), ms);\n  hashTableInit(&(p->elementTypes), ms);\n  hashTableInit(&(p->attributeIds), ms);\n  hashTableInit(&(p->prefixes), ms);\n#ifdef XML_DTD\n  p->paramEntityRead = XML_FALSE;\n  hashTableInit(&(p->paramEntities), ms);\n#endif /* XML_DTD */\n  p->defaultPrefix.name = NULL;\n  p->defaultPrefix.binding = NULL;\n\n  p->in_eldecl = XML_FALSE;\n  p->scaffIndex = NULL;\n  p->scaffold = NULL;\n  p->scaffLevel = 0;\n  p->scaffSize = 0;\n  p->scaffCount = 0;\n  p->contentStringLen = 0;\n\n  p->keepProcessing = XML_TRUE;\n  p->hasParamEntityRefs = XML_FALSE;\n  p->standalone = XML_FALSE;\n  return p;\n}\n\nstatic void\ndtdReset(DTD *p, const XML_Memory_Handling_Suite *ms) {\n  HASH_TABLE_ITER iter;\n  hashTableIterInit(&iter, &(p->elementTypes));\n  for (;;) {\n    ELEMENT_TYPE *e = (ELEMENT_TYPE *)hashTableIterNext(&iter);\n    if (! e)\n      break;\n    if (e->allocDefaultAtts != 0)\n      ms->free_fcn(e->defaultAtts);\n  }\n  hashTableClear(&(p->generalEntities));\n#ifdef XML_DTD\n  p->paramEntityRead = XML_FALSE;\n  hashTableClear(&(p->paramEntities));\n#endif /* XML_DTD */\n  hashTableClear(&(p->elementTypes));\n  hashTableClear(&(p->attributeIds));\n  hashTableClear(&(p->prefixes));\n  poolClear(&(p->pool));\n  poolClear(&(p->entityValuePool));\n  p->defaultPrefix.name = NULL;\n  p->defaultPrefix.binding = NULL;\n\n  p->in_eldecl = XML_FALSE;\n\n  ms->free_fcn(p->scaffIndex);\n  p->scaffIndex = NULL;\n  ms->free_fcn(p->scaffold);\n  p->scaffold = NULL;\n\n  p->scaffLevel = 0;\n  p->scaffSize = 0;\n  p->scaffCount = 0;\n  p->contentStringLen = 0;\n\n  p->keepProcessing = XML_TRUE;\n  p->hasParamEntityRefs = XML_FALSE;\n  p->standalone = XML_FALSE;\n}\n\nstatic void\ndtdDestroy(DTD *p, XML_Bool isDocEntity, const XML_Memory_Handling_Suite *ms) {\n  HASH_TABLE_ITER iter;\n  hashTableIterInit(&iter, &(p->elementTypes));\n  for (;;) {\n    ELEMENT_TYPE *e = (ELEMENT_TYPE *)hashTableIterNext(&iter);\n    if (! e)\n      break;\n    if (e->allocDefaultAtts != 0)\n      ms->free_fcn(e->defaultAtts);\n  }\n  hashTableDestroy(&(p->generalEntities));\n#ifdef XML_DTD\n  hashTableDestroy(&(p->paramEntities));\n#endif /* XML_DTD */\n  hashTableDestroy(&(p->elementTypes));\n  hashTableDestroy(&(p->attributeIds));\n  hashTableDestroy(&(p->prefixes));\n  poolDestroy(&(p->pool));\n  poolDestroy(&(p->entityValuePool));\n  if (isDocEntity) {\n    ms->free_fcn(p->scaffIndex);\n    ms->free_fcn(p->scaffold);\n  }\n  ms->free_fcn(p);\n}\n\n/* Do a deep copy of the DTD. Return 0 for out of memory, non-zero otherwise.\n   The new DTD has already been initialized.\n*/\nstatic int\ndtdCopy(XML_Parser oldParser, DTD *newDtd, const DTD *oldDtd,\n        const XML_Memory_Handling_Suite *ms) {\n  HASH_TABLE_ITER iter;\n\n  /* Copy the prefix table. */\n\n  hashTableIterInit(&iter, &(oldDtd->prefixes));\n  for (;;) {\n    const XML_Char *name;\n    const PREFIX *oldP = (PREFIX *)hashTableIterNext(&iter);\n    if (! oldP)\n      break;\n    name = poolCopyString(&(newDtd->pool), oldP->name);\n    if (! name)\n      return 0;\n    if (! lookup(oldParser, &(newDtd->prefixes), name, sizeof(PREFIX)))\n      return 0;\n  }\n\n  hashTableIterInit(&iter, &(oldDtd->attributeIds));\n\n  /* Copy the attribute id table. */\n\n  for (;;) {\n    ATTRIBUTE_ID *newA;\n    const XML_Char *name;\n    const ATTRIBUTE_ID *oldA = (ATTRIBUTE_ID *)hashTableIterNext(&iter);\n\n    if (! oldA)\n      break;\n    /* Remember to allocate the scratch byte before the name. */\n    if (! poolAppendChar(&(newDtd->pool), XML_T('\\0')))\n      return 0;\n    name = poolCopyString(&(newDtd->pool), oldA->name);\n    if (! name)\n      return 0;\n    ++name;\n    newA = (ATTRIBUTE_ID *)lookup(oldParser, &(newDtd->attributeIds), name,\n                                  sizeof(ATTRIBUTE_ID));\n    if (! newA)\n      return 0;\n    newA->maybeTokenized = oldA->maybeTokenized;\n    if (oldA->prefix) {\n      newA->xmlns = oldA->xmlns;\n      if (oldA->prefix == &oldDtd->defaultPrefix)\n        newA->prefix = &newDtd->defaultPrefix;\n      else\n        newA->prefix = (PREFIX *)lookup(oldParser, &(newDtd->prefixes),\n                                        oldA->prefix->name, 0);\n    }\n  }\n\n  /* Copy the element type table. */\n\n  hashTableIterInit(&iter, &(oldDtd->elementTypes));\n\n  for (;;) {\n    int i;\n    ELEMENT_TYPE *newE;\n    const XML_Char *name;\n    const ELEMENT_TYPE *oldE = (ELEMENT_TYPE *)hashTableIterNext(&iter);\n    if (! oldE)\n      break;\n    name = poolCopyString(&(newDtd->pool), oldE->name);\n    if (! name)\n      return 0;\n    newE = (ELEMENT_TYPE *)lookup(oldParser, &(newDtd->elementTypes), name,\n                                  sizeof(ELEMENT_TYPE));\n    if (! newE)\n      return 0;\n    if (oldE->nDefaultAtts) {\n      newE->defaultAtts\n          = ms->malloc_fcn(oldE->nDefaultAtts * sizeof(DEFAULT_ATTRIBUTE));\n      if (! newE->defaultAtts) {\n        return 0;\n      }\n    }\n    if (oldE->idAtt)\n      newE->idAtt = (ATTRIBUTE_ID *)lookup(oldParser, &(newDtd->attributeIds),\n                                           oldE->idAtt->name, 0);\n    newE->allocDefaultAtts = newE->nDefaultAtts = oldE->nDefaultAtts;\n    if (oldE->prefix)\n      newE->prefix = (PREFIX *)lookup(oldParser, &(newDtd->prefixes),\n                                      oldE->prefix->name, 0);\n    for (i = 0; i < newE->nDefaultAtts; i++) {\n      newE->defaultAtts[i].id = (ATTRIBUTE_ID *)lookup(\n          oldParser, &(newDtd->attributeIds), oldE->defaultAtts[i].id->name, 0);\n      newE->defaultAtts[i].isCdata = oldE->defaultAtts[i].isCdata;\n      if (oldE->defaultAtts[i].value) {\n        newE->defaultAtts[i].value\n            = poolCopyString(&(newDtd->pool), oldE->defaultAtts[i].value);\n        if (! newE->defaultAtts[i].value)\n          return 0;\n      } else\n        newE->defaultAtts[i].value = NULL;\n    }\n  }\n\n  /* Copy the entity tables. */\n  if (! copyEntityTable(oldParser, &(newDtd->generalEntities), &(newDtd->pool),\n                        &(oldDtd->generalEntities)))\n    return 0;\n\n#ifdef XML_DTD\n  if (! copyEntityTable(oldParser, &(newDtd->paramEntities), &(newDtd->pool),\n                        &(oldDtd->paramEntities)))\n    return 0;\n  newDtd->paramEntityRead = oldDtd->paramEntityRead;\n#endif /* XML_DTD */\n\n  newDtd->keepProcessing = oldDtd->keepProcessing;\n  newDtd->hasParamEntityRefs = oldDtd->hasParamEntityRefs;\n  newDtd->standalone = oldDtd->standalone;\n\n  /* Don't want deep copying for scaffolding */\n  newDtd->in_eldecl = oldDtd->in_eldecl;\n  newDtd->scaffold = oldDtd->scaffold;\n  newDtd->contentStringLen = oldDtd->contentStringLen;\n  newDtd->scaffSize = oldDtd->scaffSize;\n  newDtd->scaffLevel = oldDtd->scaffLevel;\n  newDtd->scaffIndex = oldDtd->scaffIndex;\n\n  return 1;\n} /* End dtdCopy */\n\nstatic int\ncopyEntityTable(XML_Parser oldParser, HASH_TABLE *newTable,\n                STRING_POOL *newPool, const HASH_TABLE *oldTable) {\n  HASH_TABLE_ITER iter;\n  const XML_Char *cachedOldBase = NULL;\n  const XML_Char *cachedNewBase = NULL;\n\n  hashTableIterInit(&iter, oldTable);\n\n  for (;;) {\n    ENTITY *newE;\n    const XML_Char *name;\n    const ENTITY *oldE = (ENTITY *)hashTableIterNext(&iter);\n    if (! oldE)\n      break;\n    name = poolCopyString(newPool, oldE->name);\n    if (! name)\n      return 0;\n    newE = (ENTITY *)lookup(oldParser, newTable, name, sizeof(ENTITY));\n    if (! newE)\n      return 0;\n    if (oldE->systemId) {\n      const XML_Char *tem = poolCopyString(newPool, oldE->systemId);\n      if (! tem)\n        return 0;\n      newE->systemId = tem;\n      if (oldE->base) {\n        if (oldE->base == cachedOldBase)\n          newE->base = cachedNewBase;\n        else {\n          cachedOldBase = oldE->base;\n          tem = poolCopyString(newPool, cachedOldBase);\n          if (! tem)\n            return 0;\n          cachedNewBase = newE->base = tem;\n        }\n      }\n      if (oldE->publicId) {\n        tem = poolCopyString(newPool, oldE->publicId);\n        if (! tem)\n          return 0;\n        newE->publicId = tem;\n      }\n    } else {\n      const XML_Char *tem\n          = poolCopyStringN(newPool, oldE->textPtr, oldE->textLen);\n      if (! tem)\n        return 0;\n      newE->textPtr = tem;\n      newE->textLen = oldE->textLen;\n    }\n    if (oldE->notation) {\n      const XML_Char *tem = poolCopyString(newPool, oldE->notation);\n      if (! tem)\n        return 0;\n      newE->notation = tem;\n    }\n    newE->is_param = oldE->is_param;\n    newE->is_internal = oldE->is_internal;\n  }\n  return 1;\n}\n\n#define INIT_POWER 6\n\nstatic XML_Bool FASTCALL\nkeyeq(KEY s1, KEY s2) {\n  for (; *s1 == *s2; s1++, s2++)\n    if (*s1 == 0)\n      return XML_TRUE;\n  return XML_FALSE;\n}\n\nstatic size_t\nkeylen(KEY s) {\n  size_t len = 0;\n  for (; *s; s++, len++)\n    ;\n  return len;\n}\n\nstatic void\ncopy_salt_to_sipkey(XML_Parser parser, struct sipkey *key) {\n  key->k[0] = 0;\n  key->k[1] = get_hash_secret_salt(parser);\n}\n\nstatic unsigned long FASTCALL\nhash(XML_Parser parser, KEY s) {\n  struct siphash state;\n  struct sipkey key;\n  (void)sip24_valid;\n  copy_salt_to_sipkey(parser, &key);\n  sip24_init(&state, &key);\n  sip24_update(&state, s, keylen(s) * sizeof(XML_Char));\n  return (unsigned long)sip24_final(&state);\n}\n\nstatic NAMED *\nlookup(XML_Parser parser, HASH_TABLE *table, KEY name, size_t createSize) {\n  size_t i;\n  if (table->size == 0) {\n    size_t tsize;\n    if (! createSize)\n      return NULL;\n    table->power = INIT_POWER;\n    /* table->size is a power of 2 */\n    table->size = (size_t)1 << INIT_POWER;\n    tsize = table->size * sizeof(NAMED *);\n    table->v = table->mem->malloc_fcn(tsize);\n    if (! table->v) {\n      table->size = 0;\n      return NULL;\n    }\n    memset(table->v, 0, tsize);\n    i = hash(parser, name) & ((unsigned long)table->size - 1);\n  } else {\n    unsigned long h = hash(parser, name);\n    unsigned long mask = (unsigned long)table->size - 1;\n    unsigned char step = 0;\n    i = h & mask;\n    while (table->v[i]) {\n      if (keyeq(name, table->v[i]->name))\n        return table->v[i];\n      if (! step)\n        step = PROBE_STEP(h, mask, table->power);\n      i < step ? (i += table->size - step) : (i -= step);\n    }\n    if (! createSize)\n      return NULL;\n\n    /* check for overflow (table is half full) */\n    if (table->used >> (table->power - 1)) {\n      unsigned char newPower = table->power + 1;\n\n      /* Detect and prevent invalid shift */\n      if (newPower >= sizeof(unsigned long) * 8 /* bits per byte */) {\n        return NULL;\n      }\n\n      size_t newSize = (size_t)1 << newPower;\n      unsigned long newMask = (unsigned long)newSize - 1;\n\n      /* Detect and prevent integer overflow */\n      if (newSize > (size_t)(-1) / sizeof(NAMED *)) {\n        return NULL;\n      }\n\n      size_t tsize = newSize * sizeof(NAMED *);\n      NAMED **newV = table->mem->malloc_fcn(tsize);\n      if (! newV)\n        return NULL;\n      memset(newV, 0, tsize);\n      for (i = 0; i < table->size; i++)\n        if (table->v[i]) {\n          unsigned long newHash = hash(parser, table->v[i]->name);\n          size_t j = newHash & newMask;\n          step = 0;\n          while (newV[j]) {\n            if (! step)\n              step = PROBE_STEP(newHash, newMask, newPower);\n            j < step ? (j += newSize - step) : (j -= step);\n          }\n          newV[j] = table->v[i];\n        }\n      table->mem->free_fcn(table->v);\n      table->v = newV;\n      table->power = newPower;\n      table->size = newSize;\n      i = h & newMask;\n      step = 0;\n      while (table->v[i]) {\n        if (! step)\n          step = PROBE_STEP(h, newMask, newPower);\n        i < step ? (i += newSize - step) : (i -= step);\n      }\n    }\n  }\n  table->v[i] = table->mem->malloc_fcn(createSize);\n  if (! table->v[i])\n    return NULL;\n  memset(table->v[i], 0, createSize);\n  table->v[i]->name = name;\n  (table->used)++;\n  return table->v[i];\n}\n\nstatic void FASTCALL\nhashTableClear(HASH_TABLE *table) {\n  size_t i;\n  for (i = 0; i < table->size; i++) {\n    table->mem->free_fcn(table->v[i]);\n    table->v[i] = NULL;\n  }\n  table->used = 0;\n}\n\nstatic void FASTCALL\nhashTableDestroy(HASH_TABLE *table) {\n  size_t i;\n  for (i = 0; i < table->size; i++)\n    table->mem->free_fcn(table->v[i]);\n  table->mem->free_fcn(table->v);\n}\n\nstatic void FASTCALL\nhashTableInit(HASH_TABLE *p, const XML_Memory_Handling_Suite *ms) {\n  p->power = 0;\n  p->size = 0;\n  p->used = 0;\n  p->v = NULL;\n  p->mem = ms;\n}\n\nstatic void FASTCALL\nhashTableIterInit(HASH_TABLE_ITER *iter, const HASH_TABLE *table) {\n  iter->p = table->v;\n  iter->end = iter->p ? iter->p + table->size : NULL;\n}\n\nstatic NAMED *FASTCALL\nhashTableIterNext(HASH_TABLE_ITER *iter) {\n  while (iter->p != iter->end) {\n    NAMED *tem = *(iter->p)++;\n    if (tem)\n      return tem;\n  }\n  return NULL;\n}\n\nstatic void FASTCALL\npoolInit(STRING_POOL *pool, const XML_Memory_Handling_Suite *ms) {\n  pool->blocks = NULL;\n  pool->freeBlocks = NULL;\n  pool->start = NULL;\n  pool->ptr = NULL;\n  pool->end = NULL;\n  pool->mem = ms;\n}\n\nstatic void FASTCALL\npoolClear(STRING_POOL *pool) {\n  if (! pool->freeBlocks)\n    pool->freeBlocks = pool->blocks;\n  else {\n    BLOCK *p = pool->blocks;\n    while (p) {\n      BLOCK *tem = p->next;\n      p->next = pool->freeBlocks;\n      pool->freeBlocks = p;\n      p = tem;\n    }\n  }\n  pool->blocks = NULL;\n  pool->start = NULL;\n  pool->ptr = NULL;\n  pool->end = NULL;\n}\n\nstatic void FASTCALL\npoolDestroy(STRING_POOL *pool) {\n  BLOCK *p = pool->blocks;\n  while (p) {\n    BLOCK *tem = p->next;\n    pool->mem->free_fcn(p);\n    p = tem;\n  }\n  p = pool->freeBlocks;\n  while (p) {\n    BLOCK *tem = p->next;\n    pool->mem->free_fcn(p);\n    p = tem;\n  }\n}\n\nstatic XML_Char *\npoolAppend(STRING_POOL *pool, const ENCODING *enc, const char *ptr,\n           const char *end) {\n  if (! pool->ptr && ! poolGrow(pool))\n    return NULL;\n  for (;;) {\n    const enum XML_Convert_Result convert_res = XmlConvert(\n        enc, &ptr, end, (ICHAR **)&(pool->ptr), (const ICHAR *)pool->end);\n    if ((convert_res == XML_CONVERT_COMPLETED)\n        || (convert_res == XML_CONVERT_INPUT_INCOMPLETE))\n      break;\n    if (! poolGrow(pool))\n      return NULL;\n  }\n  return pool->start;\n}\n\nstatic const XML_Char *FASTCALL\npoolCopyString(STRING_POOL *pool, const XML_Char *s) {\n  do {\n    if (! poolAppendChar(pool, *s))\n      return NULL;\n  } while (*s++);\n  s = pool->start;\n  poolFinish(pool);\n  return s;\n}\n\nstatic const XML_Char *\npoolCopyStringN(STRING_POOL *pool, const XML_Char *s, int n) {\n  if (! pool->ptr && ! poolGrow(pool)) {\n    /* The following line is unreachable given the current usage of\n     * poolCopyStringN().  Currently it is called from exactly one\n     * place to copy the text of a simple general entity.  By that\n     * point, the name of the entity is already stored in the pool, so\n     * pool->ptr cannot be NULL.\n     *\n     * If poolCopyStringN() is used elsewhere as it well might be,\n     * this line may well become executable again.  Regardless, this\n     * sort of check shouldn't be removed lightly, so we just exclude\n     * it from the coverage statistics.\n     */\n    return NULL; /* LCOV_EXCL_LINE */\n  }\n  for (; n > 0; --n, s++) {\n    if (! poolAppendChar(pool, *s))\n      return NULL;\n  }\n  s = pool->start;\n  poolFinish(pool);\n  return s;\n}\n\nstatic const XML_Char *FASTCALL\npoolAppendString(STRING_POOL *pool, const XML_Char *s) {\n  while (*s) {\n    if (! poolAppendChar(pool, *s))\n      return NULL;\n    s++;\n  }\n  return pool->start;\n}\n\nstatic XML_Char *\npoolStoreString(STRING_POOL *pool, const ENCODING *enc, const char *ptr,\n                const char *end) {\n  if (! poolAppend(pool, enc, ptr, end))\n    return NULL;\n  if (pool->ptr == pool->end && ! poolGrow(pool))\n    return NULL;\n  *(pool->ptr)++ = 0;\n  return pool->start;\n}\n\nstatic size_t\npoolBytesToAllocateFor(int blockSize) {\n  /* Unprotected math would be:\n  ** return offsetof(BLOCK, s) + blockSize * sizeof(XML_Char);\n  **\n  ** Detect overflow, avoiding _signed_ overflow undefined behavior\n  ** For a + b * c we check b * c in isolation first, so that addition of a\n  ** on top has no chance of making us accept a small non-negative number\n  */\n  const size_t stretch = sizeof(XML_Char); /* can be 4 bytes */\n\n  if (blockSize <= 0)\n    return 0;\n\n  if (blockSize > (int)(INT_MAX / stretch))\n    return 0;\n\n  {\n    const int stretchedBlockSize = blockSize * (int)stretch;\n    const int bytesToAllocate\n        = (int)(offsetof(BLOCK, s) + (unsigned)stretchedBlockSize);\n    if (bytesToAllocate < 0)\n      return 0;\n\n    return (size_t)bytesToAllocate;\n  }\n}\n\nstatic XML_Bool FASTCALL\npoolGrow(STRING_POOL *pool) {\n  if (pool->freeBlocks) {\n    if (pool->start == 0) {\n      pool->blocks = pool->freeBlocks;\n      pool->freeBlocks = pool->freeBlocks->next;\n      pool->blocks->next = NULL;\n      pool->start = pool->blocks->s;\n      pool->end = pool->start + pool->blocks->size;\n      pool->ptr = pool->start;\n      return XML_TRUE;\n    }\n    if (pool->end - pool->start < pool->freeBlocks->size) {\n      BLOCK *tem = pool->freeBlocks->next;\n      pool->freeBlocks->next = pool->blocks;\n      pool->blocks = pool->freeBlocks;\n      pool->freeBlocks = tem;\n      memcpy(pool->blocks->s, pool->start,\n             (pool->end - pool->start) * sizeof(XML_Char));\n      pool->ptr = pool->blocks->s + (pool->ptr - pool->start);\n      pool->start = pool->blocks->s;\n      pool->end = pool->start + pool->blocks->size;\n      return XML_TRUE;\n    }\n  }\n  if (pool->blocks && pool->start == pool->blocks->s) {\n    BLOCK *temp;\n    int blockSize = (int)((unsigned)(pool->end - pool->start) * 2U);\n    size_t bytesToAllocate;\n\n    /* NOTE: Needs to be calculated prior to calling `realloc`\n             to avoid dangling pointers: */\n    const ptrdiff_t offsetInsideBlock = pool->ptr - pool->start;\n\n    if (blockSize < 0) {\n      /* This condition traps a situation where either more than\n       * INT_MAX/2 bytes have already been allocated.  This isn't\n       * readily testable, since it is unlikely that an average\n       * machine will have that much memory, so we exclude it from the\n       * coverage statistics.\n       */\n      return XML_FALSE; /* LCOV_EXCL_LINE */\n    }\n\n    bytesToAllocate = poolBytesToAllocateFor(blockSize);\n    if (bytesToAllocate == 0)\n      return XML_FALSE;\n\n    temp = (BLOCK *)pool->mem->realloc_fcn(pool->blocks,\n                                           (unsigned)bytesToAllocate);\n    if (temp == NULL)\n      return XML_FALSE;\n    pool->blocks = temp;\n    pool->blocks->size = blockSize;\n    pool->ptr = pool->blocks->s + offsetInsideBlock;\n    pool->start = pool->blocks->s;\n    pool->end = pool->start + blockSize;\n  } else {\n    BLOCK *tem;\n    int blockSize = (int)(pool->end - pool->start);\n    size_t bytesToAllocate;\n\n    if (blockSize < 0) {\n      /* This condition traps a situation where either more than\n       * INT_MAX bytes have already been allocated (which is prevented\n       * by various pieces of program logic, not least this one, never\n       * mind the unlikelihood of actually having that much memory) or\n       * the pool control fields have been corrupted (which could\n       * conceivably happen in an extremely buggy user handler\n       * function).  Either way it isn't readily testable, so we\n       * exclude it from the coverage statistics.\n       */\n      return XML_FALSE; /* LCOV_EXCL_LINE */\n    }\n\n    if (blockSize < INIT_BLOCK_SIZE)\n      blockSize = INIT_BLOCK_SIZE;\n    else {\n      /* Detect overflow, avoiding _signed_ overflow undefined behavior */\n      if ((int)((unsigned)blockSize * 2U) < 0) {\n        return XML_FALSE;\n      }\n      blockSize *= 2;\n    }\n\n    bytesToAllocate = poolBytesToAllocateFor(blockSize);\n    if (bytesToAllocate == 0)\n      return XML_FALSE;\n\n    tem = pool->mem->malloc_fcn(bytesToAllocate);\n    if (! tem)\n      return XML_FALSE;\n    tem->size = blockSize;\n    tem->next = pool->blocks;\n    pool->blocks = tem;\n    if (pool->ptr != pool->start)\n      memcpy(tem->s, pool->start, (pool->ptr - pool->start) * sizeof(XML_Char));\n    pool->ptr = tem->s + (pool->ptr - pool->start);\n    pool->start = tem->s;\n    pool->end = tem->s + blockSize;\n  }\n  return XML_TRUE;\n}\n\nstatic int FASTCALL\nnextScaffoldPart(XML_Parser parser) {\n  DTD *const dtd = parser->m_dtd; /* save one level of indirection */\n  CONTENT_SCAFFOLD *me;\n  int next;\n\n  if (! dtd->scaffIndex) {\n    dtd->scaffIndex = (int *)MALLOC(parser, parser->m_groupSize * sizeof(int));\n    if (! dtd->scaffIndex)\n      return -1;\n    dtd->scaffIndex[0] = 0;\n  }\n\n  if (dtd->scaffCount >= dtd->scaffSize) {\n    CONTENT_SCAFFOLD *temp;\n    if (dtd->scaffold) {\n      /* Detect and prevent integer overflow */\n      if (dtd->scaffSize > UINT_MAX / 2u) {\n        return -1;\n      }\n      /* Detect and prevent integer overflow.\n       * The preprocessor guard addresses the \"always false\" warning\n       * from -Wtype-limits on platforms where\n       * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */\n#if UINT_MAX >= SIZE_MAX\n      if (dtd->scaffSize > (size_t)(-1) / 2u / sizeof(CONTENT_SCAFFOLD)) {\n        return -1;\n      }\n#endif\n\n      temp = (CONTENT_SCAFFOLD *)REALLOC(\n          parser, dtd->scaffold, dtd->scaffSize * 2 * sizeof(CONTENT_SCAFFOLD));\n      if (temp == NULL)\n        return -1;\n      dtd->scaffSize *= 2;\n    } else {\n      temp = (CONTENT_SCAFFOLD *)MALLOC(parser, INIT_SCAFFOLD_ELEMENTS\n                                                    * sizeof(CONTENT_SCAFFOLD));\n      if (temp == NULL)\n        return -1;\n      dtd->scaffSize = INIT_SCAFFOLD_ELEMENTS;\n    }\n    dtd->scaffold = temp;\n  }\n  next = dtd->scaffCount++;\n  me = &dtd->scaffold[next];\n  if (dtd->scaffLevel) {\n    CONTENT_SCAFFOLD *parent\n        = &dtd->scaffold[dtd->scaffIndex[dtd->scaffLevel - 1]];\n    if (parent->lastchild) {\n      dtd->scaffold[parent->lastchild].nextsib = next;\n    }\n    if (! parent->childcnt)\n      parent->firstchild = next;\n    parent->lastchild = next;\n    parent->childcnt++;\n  }\n  me->firstchild = me->lastchild = me->childcnt = me->nextsib = 0;\n  return next;\n}\n\nstatic XML_Content *\nbuild_model(XML_Parser parser) {\n  /* Function build_model transforms the existing parser->m_dtd->scaffold\n   * array of CONTENT_SCAFFOLD tree nodes into a new array of\n   * XML_Content tree nodes followed by a gapless list of zero-terminated\n   * strings. */\n  DTD *const dtd = parser->m_dtd; /* save one level of indirection */\n  XML_Content *ret;\n  XML_Char *str; /* the current string writing location */\n\n  /* Detect and prevent integer overflow.\n   * The preprocessor guard addresses the \"always false\" warning\n   * from -Wtype-limits on platforms where\n   * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */\n#if UINT_MAX >= SIZE_MAX\n  if (dtd->scaffCount > (size_t)(-1) / sizeof(XML_Content)) {\n    return NULL;\n  }\n  if (dtd->contentStringLen > (size_t)(-1) / sizeof(XML_Char)) {\n    return NULL;\n  }\n#endif\n  if (dtd->scaffCount * sizeof(XML_Content)\n      > (size_t)(-1) - dtd->contentStringLen * sizeof(XML_Char)) {\n    return NULL;\n  }\n\n  const size_t allocsize = (dtd->scaffCount * sizeof(XML_Content)\n                            + (dtd->contentStringLen * sizeof(XML_Char)));\n\n  ret = (XML_Content *)MALLOC(parser, allocsize);\n  if (! ret)\n    return NULL;\n\n  /* What follows is an iterative implementation (of what was previously done\n   * recursively in a dedicated function called \"build_node\".  The old recursive\n   * build_node could be forced into stack exhaustion from input as small as a\n   * few megabyte, and so that was a security issue.  Hence, a function call\n   * stack is avoided now by resolving recursion.)\n   *\n   * The iterative approach works as follows:\n   *\n   * - We have two writing pointers, both walking up the result array; one does\n   *   the work, the other creates \"jobs\" for its colleague to do, and leads\n   *   the way:\n   *\n   *   - The faster one, pointer jobDest, always leads and writes \"what job\n   *     to do\" by the other, once they reach that place in the\n   *     array: leader \"jobDest\" stores the source node array index (relative\n   *     to array dtd->scaffold) in field \"numchildren\".\n   *\n   *   - The slower one, pointer dest, looks at the value stored in the\n   *     \"numchildren\" field (which actually holds a source node array index\n   *     at that time) and puts the real data from dtd->scaffold in.\n   *\n   * - Before the loop starts, jobDest writes source array index 0\n   *   (where the root node is located) so that dest will have something to do\n   *   when it starts operation.\n   *\n   * - Whenever nodes with children are encountered, jobDest appends\n   *   them as new jobs, in order.  As a result, tree node siblings are\n   *   adjacent in the resulting array, for example:\n   *\n   *     [0] root, has two children\n   *       [1] first child of 0, has three children\n   *         [3] first child of 1, does not have children\n   *         [4] second child of 1, does not have children\n   *         [5] third child of 1, does not have children\n   *       [2] second child of 0, does not have children\n   *\n   *   Or (the same data) presented in flat array view:\n   *\n   *     [0] root, has two children\n   *\n   *     [1] first child of 0, has three children\n   *     [2] second child of 0, does not have children\n   *\n   *     [3] first child of 1, does not have children\n   *     [4] second child of 1, does not have children\n   *     [5] third child of 1, does not have children\n   *\n   * - The algorithm repeats until all target array indices have been processed.\n   */\n  XML_Content *dest = ret; /* tree node writing location, moves upwards */\n  XML_Content *const destLimit = &ret[dtd->scaffCount];\n  XML_Content *jobDest = ret; /* next free writing location in target array */\n  str = (XML_Char *)&ret[dtd->scaffCount];\n\n  /* Add the starting job, the root node (index 0) of the source tree  */\n  (jobDest++)->numchildren = 0;\n\n  for (; dest < destLimit; dest++) {\n    /* Retrieve source tree array index from job storage */\n    const int src_node = (int)dest->numchildren;\n\n    /* Convert item */\n    dest->type = dtd->scaffold[src_node].type;\n    dest->quant = dtd->scaffold[src_node].quant;\n    if (dest->type == XML_CTYPE_NAME) {\n      const XML_Char *src;\n      dest->name = str;\n      src = dtd->scaffold[src_node].name;\n      for (;;) {\n        *str++ = *src;\n        if (! *src)\n          break;\n        src++;\n      }\n      dest->numchildren = 0;\n      dest->children = NULL;\n    } else {\n      unsigned int i;\n      int cn;\n      dest->name = NULL;\n      dest->numchildren = dtd->scaffold[src_node].childcnt;\n      dest->children = jobDest;\n\n      /* Append scaffold indices of children to array */\n      for (i = 0, cn = dtd->scaffold[src_node].firstchild;\n           i < dest->numchildren; i++, cn = dtd->scaffold[cn].nextsib)\n        (jobDest++)->numchildren = (unsigned int)cn;\n    }\n  }\n\n  return ret;\n}\n\nstatic ELEMENT_TYPE *\ngetElementType(XML_Parser parser, const ENCODING *enc, const char *ptr,\n               const char *end) {\n  DTD *const dtd = parser->m_dtd; /* save one level of indirection */\n  const XML_Char *name = poolStoreString(&dtd->pool, enc, ptr, end);\n  ELEMENT_TYPE *ret;\n\n  if (! name)\n    return NULL;\n  ret = (ELEMENT_TYPE *)lookup(parser, &dtd->elementTypes, name,\n                               sizeof(ELEMENT_TYPE));\n  if (! ret)\n    return NULL;\n  if (ret->name != name)\n    poolDiscard(&dtd->pool);\n  else {\n    poolFinish(&dtd->pool);\n    if (! setElementTypePrefix(parser, ret))\n      return NULL;\n  }\n  return ret;\n}\n\nstatic XML_Char *\ncopyString(const XML_Char *s, const XML_Memory_Handling_Suite *memsuite) {\n  size_t charsRequired = 0;\n  XML_Char *result;\n\n  /* First determine how long the string is */\n  while (s[charsRequired] != 0) {\n    charsRequired++;\n  }\n  /* Include the terminator */\n  charsRequired++;\n\n  /* Now allocate space for the copy */\n  result = memsuite->malloc_fcn(charsRequired * sizeof(XML_Char));\n  if (result == NULL)\n    return NULL;\n  /* Copy the original into place */\n  memcpy(result, s, charsRequired * sizeof(XML_Char));\n  return result;\n}\n\n#if defined(XML_DTD) || XML_GE == 1\n\nstatic float\naccountingGetCurrentAmplification(XML_Parser rootParser) {\n  const XmlBigCount countBytesOutput\n      = rootParser->m_accounting.countBytesDirect\n        + rootParser->m_accounting.countBytesIndirect;\n  const float amplificationFactor\n      = rootParser->m_accounting.countBytesDirect\n            ? (countBytesOutput\n               / (float)(rootParser->m_accounting.countBytesDirect))\n            : 1.0f;\n  assert(! rootParser->m_parentParser);\n  return amplificationFactor;\n}\n\nstatic void\naccountingReportStats(XML_Parser originParser, const char *epilog) {\n  const XML_Parser rootParser = getRootParserOf(originParser, NULL);\n  assert(! rootParser->m_parentParser);\n\n  if (rootParser->m_accounting.debugLevel == 0u) {\n    return;\n  }\n\n  const float amplificationFactor\n      = accountingGetCurrentAmplification(rootParser);\n  fprintf(stderr,\n          \"expat: Accounting(%p): Direct \" EXPAT_FMT_ULL(\n              \"10\") \", indirect \" EXPAT_FMT_ULL(\"10\") \", amplification %8.2f%s\",\n          (void *)rootParser, rootParser->m_accounting.countBytesDirect,\n          rootParser->m_accounting.countBytesIndirect,\n          (double)amplificationFactor, epilog);\n}\n\nstatic void\naccountingOnAbort(XML_Parser originParser) {\n  accountingReportStats(originParser, \" ABORTING\\n\");\n}\n\nstatic void\naccountingReportDiff(XML_Parser rootParser,\n                     unsigned int levelsAwayFromRootParser, const char *before,\n                     const char *after, ptrdiff_t bytesMore, int source_line,\n                     enum XML_Account account) {\n  assert(! rootParser->m_parentParser);\n\n  fprintf(stderr,\n          \" (+\" EXPAT_FMT_PTRDIFF_T(\"6\") \" bytes %s|%d, xmlparse.c:%d) %*s\\\"\",\n          bytesMore, (account == XML_ACCOUNT_DIRECT) ? \"DIR\" : \"EXP\",\n          levelsAwayFromRootParser, source_line, 10, \"\");\n\n  const char ellipis[] = \"[..]\";\n  const size_t ellipsisLength = sizeof(ellipis) /* because compile-time */ - 1;\n  const unsigned int contextLength = 10;\n\n  /* Note: Performance is of no concern here */\n  const char *walker = before;\n  if ((rootParser->m_accounting.debugLevel >= 3u)\n      || (after - before)\n             <= (ptrdiff_t)(contextLength + ellipsisLength + contextLength)) {\n    for (; walker < after; walker++) {\n      fprintf(stderr, \"%s\", unsignedCharToPrintable(walker[0]));\n    }\n  } else {\n    for (; walker < before + contextLength; walker++) {\n      fprintf(stderr, \"%s\", unsignedCharToPrintable(walker[0]));\n    }\n    fprintf(stderr, ellipis);\n    walker = after - contextLength;\n    for (; walker < after; walker++) {\n      fprintf(stderr, \"%s\", unsignedCharToPrintable(walker[0]));\n    }\n  }\n  fprintf(stderr, \"\\\"\\n\");\n}\n\nstatic XML_Bool\naccountingDiffTolerated(XML_Parser originParser, int tok, const char *before,\n                        const char *after, int source_line,\n                        enum XML_Account account) {\n  /* Note: We need to check the token type *first* to be sure that\n   *       we can even access variable <after>, safely.\n   *       E.g. for XML_TOK_NONE <after> may hold an invalid pointer. */\n  switch (tok) {\n  case XML_TOK_INVALID:\n  case XML_TOK_PARTIAL:\n  case XML_TOK_PARTIAL_CHAR:\n  case XML_TOK_NONE:\n    return XML_TRUE;\n  }\n\n  if (account == XML_ACCOUNT_NONE)\n    return XML_TRUE; /* because these bytes have been accounted for, already */\n\n  unsigned int levelsAwayFromRootParser;\n  const XML_Parser rootParser\n      = getRootParserOf(originParser, &levelsAwayFromRootParser);\n  assert(! rootParser->m_parentParser);\n\n  const int isDirect\n      = (account == XML_ACCOUNT_DIRECT) && (originParser == rootParser);\n  const ptrdiff_t bytesMore = after - before;\n\n  XmlBigCount *const additionTarget\n      = isDirect ? &rootParser->m_accounting.countBytesDirect\n                 : &rootParser->m_accounting.countBytesIndirect;\n\n  /* Detect and avoid integer overflow */\n  if (*additionTarget > (XmlBigCount)(-1) - (XmlBigCount)bytesMore)\n    return XML_FALSE;\n  *additionTarget += bytesMore;\n\n  const XmlBigCount countBytesOutput\n      = rootParser->m_accounting.countBytesDirect\n        + rootParser->m_accounting.countBytesIndirect;\n  const float amplificationFactor\n      = accountingGetCurrentAmplification(rootParser);\n  const XML_Bool tolerated\n      = (countBytesOutput < rootParser->m_accounting.activationThresholdBytes)\n        || (amplificationFactor\n            <= rootParser->m_accounting.maximumAmplificationFactor);\n\n  if (rootParser->m_accounting.debugLevel >= 2u) {\n    accountingReportStats(rootParser, \"\");\n    accountingReportDiff(rootParser, levelsAwayFromRootParser, before, after,\n                         bytesMore, source_line, account);\n  }\n\n  return tolerated;\n}\n\nunsigned long long\ntestingAccountingGetCountBytesDirect(XML_Parser parser) {\n  if (! parser)\n    return 0;\n  return parser->m_accounting.countBytesDirect;\n}\n\nunsigned long long\ntestingAccountingGetCountBytesIndirect(XML_Parser parser) {\n  if (! parser)\n    return 0;\n  return parser->m_accounting.countBytesIndirect;\n}\n\nstatic void\nentityTrackingReportStats(XML_Parser rootParser, ENTITY *entity,\n                          const char *action, int sourceLine) {\n  assert(! rootParser->m_parentParser);\n  if (rootParser->m_entity_stats.debugLevel == 0u)\n    return;\n\n#  if defined(XML_UNICODE)\n  const char *const entityName = \"[..]\";\n#  else\n  const char *const entityName = entity->name;\n#  endif\n\n  fprintf(\n      stderr,\n      \"expat: Entities(%p): Count %9d, depth %2d/%2d %*s%s%s; %s length %d (xmlparse.c:%d)\\n\",\n      (void *)rootParser, rootParser->m_entity_stats.countEverOpened,\n      rootParser->m_entity_stats.currentDepth,\n      rootParser->m_entity_stats.maximumDepthSeen,\n      (rootParser->m_entity_stats.currentDepth - 1) * 2, \"\",\n      entity->is_param ? \"%\" : \"&\", entityName, action, entity->textLen,\n      sourceLine);\n}\n\nstatic void\nentityTrackingOnOpen(XML_Parser originParser, ENTITY *entity, int sourceLine) {\n  const XML_Parser rootParser = getRootParserOf(originParser, NULL);\n  assert(! rootParser->m_parentParser);\n\n  rootParser->m_entity_stats.countEverOpened++;\n  rootParser->m_entity_stats.currentDepth++;\n  if (rootParser->m_entity_stats.currentDepth\n      > rootParser->m_entity_stats.maximumDepthSeen) {\n    rootParser->m_entity_stats.maximumDepthSeen++;\n  }\n\n  entityTrackingReportStats(rootParser, entity, \"OPEN \", sourceLine);\n}\n\nstatic void\nentityTrackingOnClose(XML_Parser originParser, ENTITY *entity, int sourceLine) {\n  const XML_Parser rootParser = getRootParserOf(originParser, NULL);\n  assert(! rootParser->m_parentParser);\n\n  entityTrackingReportStats(rootParser, entity, \"CLOSE\", sourceLine);\n  rootParser->m_entity_stats.currentDepth--;\n}\n\nstatic XML_Parser\ngetRootParserOf(XML_Parser parser, unsigned int *outLevelDiff) {\n  XML_Parser rootParser = parser;\n  unsigned int stepsTakenUpwards = 0;\n  while (rootParser->m_parentParser) {\n    rootParser = rootParser->m_parentParser;\n    stepsTakenUpwards++;\n  }\n  assert(! rootParser->m_parentParser);\n  if (outLevelDiff != NULL) {\n    *outLevelDiff = stepsTakenUpwards;\n  }\n  return rootParser;\n}\n\nconst char *\nunsignedCharToPrintable(unsigned char c) {\n  switch (c) {\n  case 0:\n    return \"\\\\0\";\n  case 1:\n    return \"\\\\x1\";\n  case 2:\n    return \"\\\\x2\";\n  case 3:\n    return \"\\\\x3\";\n  case 4:\n    return \"\\\\x4\";\n  case 5:\n    return \"\\\\x5\";\n  case 6:\n    return \"\\\\x6\";\n  case 7:\n    return \"\\\\x7\";\n  case 8:\n    return \"\\\\x8\";\n  case 9:\n    return \"\\\\t\";\n  case 10:\n    return \"\\\\n\";\n  case 11:\n    return \"\\\\xB\";\n  case 12:\n    return \"\\\\xC\";\n  case 13:\n    return \"\\\\r\";\n  case 14:\n    return \"\\\\xE\";\n  case 15:\n    return \"\\\\xF\";\n  case 16:\n    return \"\\\\x10\";\n  case 17:\n    return \"\\\\x11\";\n  case 18:\n    return \"\\\\x12\";\n  case 19:\n    return \"\\\\x13\";\n  case 20:\n    return \"\\\\x14\";\n  case 21:\n    return \"\\\\x15\";\n  case 22:\n    return \"\\\\x16\";\n  case 23:\n    return \"\\\\x17\";\n  case 24:\n    return \"\\\\x18\";\n  case 25:\n    return \"\\\\x19\";\n  case 26:\n    return \"\\\\x1A\";\n  case 27:\n    return \"\\\\x1B\";\n  case 28:\n    return \"\\\\x1C\";\n  case 29:\n    return \"\\\\x1D\";\n  case 30:\n    return \"\\\\x1E\";\n  case 31:\n    return \"\\\\x1F\";\n  case 32:\n    return \" \";\n  case 33:\n    return \"!\";\n  case 34:\n    return \"\\\\\\\"\";\n  case 35:\n    return \"#\";\n  case 36:\n    return \"$\";\n  case 37:\n    return \"%\";\n  case 38:\n    return \"&\";\n  case 39:\n    return \"'\";\n  case 40:\n    return \"(\";\n  case 41:\n    return \")\";\n  case 42:\n    return \"*\";\n  case 43:\n    return \"+\";\n  case 44:\n    return \",\";\n  case 45:\n    return \"-\";\n  case 46:\n    return \".\";\n  case 47:\n    return \"/\";\n  case 48:\n    return \"0\";\n  case 49:\n    return \"1\";\n  case 50:\n    return \"2\";\n  case 51:\n    return \"3\";\n  case 52:\n    return \"4\";\n  case 53:\n    return \"5\";\n  case 54:\n    return \"6\";\n  case 55:\n    return \"7\";\n  case 56:\n    return \"8\";\n  case 57:\n    return \"9\";\n  case 58:\n    return \":\";\n  case 59:\n    return \";\";\n  case 60:\n    return \"<\";\n  case 61:\n    return \"=\";\n  case 62:\n    return \">\";\n  case 63:\n    return \"?\";\n  case 64:\n    return \"@\";\n  case 65:\n    return \"A\";\n  case 66:\n    return \"B\";\n  case 67:\n    return \"C\";\n  case 68:\n    return \"D\";\n  case 69:\n    return \"E\";\n  case 70:\n    return \"F\";\n  case 71:\n    return \"G\";\n  case 72:\n    return \"H\";\n  case 73:\n    return \"I\";\n  case 74:\n    return \"J\";\n  case 75:\n    return \"K\";\n  case 76:\n    return \"L\";\n  case 77:\n    return \"M\";\n  case 78:\n    return \"N\";\n  case 79:\n    return \"O\";\n  case 80:\n    return \"P\";\n  case 81:\n    return \"Q\";\n  case 82:\n    return \"R\";\n  case 83:\n    return \"S\";\n  case 84:\n    return \"T\";\n  case 85:\n    return \"U\";\n  case 86:\n    return \"V\";\n  case 87:\n    return \"W\";\n  case 88:\n    return \"X\";\n  case 89:\n    return \"Y\";\n  case 90:\n    return \"Z\";\n  case 91:\n    return \"[\";\n  case 92:\n    return \"\\\\\\\\\";\n  case 93:\n    return \"]\";\n  case 94:\n    return \"^\";\n  case 95:\n    return \"_\";\n  case 96:\n    return \"`\";\n  case 97:\n    return \"a\";\n  case 98:\n    return \"b\";\n  case 99:\n    return \"c\";\n  case 100:\n    return \"d\";\n  case 101:\n    return \"e\";\n  case 102:\n    return \"f\";\n  case 103:\n    return \"g\";\n  case 104:\n    return \"h\";\n  case 105:\n    return \"i\";\n  case 106:\n    return \"j\";\n  case 107:\n    return \"k\";\n  case 108:\n    return \"l\";\n  case 109:\n    return \"m\";\n  case 110:\n    return \"n\";\n  case 111:\n    return \"o\";\n  case 112:\n    return \"p\";\n  case 113:\n    return \"q\";\n  case 114:\n    return \"r\";\n  case 115:\n    return \"s\";\n  case 116:\n    return \"t\";\n  case 117:\n    return \"u\";\n  case 118:\n    return \"v\";\n  case 119:\n    return \"w\";\n  case 120:\n    return \"x\";\n  case 121:\n    return \"y\";\n  case 122:\n    return \"z\";\n  case 123:\n    return \"{\";\n  case 124:\n    return \"|\";\n  case 125:\n    return \"}\";\n  case 126:\n    return \"~\";\n  case 127:\n    return \"\\\\x7F\";\n  case 128:\n    return \"\\\\x80\";\n  case 129:\n    return \"\\\\x81\";\n  case 130:\n    return \"\\\\x82\";\n  case 131:\n    return \"\\\\x83\";\n  case 132:\n    return \"\\\\x84\";\n  case 133:\n    return \"\\\\x85\";\n  case 134:\n    return \"\\\\x86\";\n  case 135:\n    return \"\\\\x87\";\n  case 136:\n    return \"\\\\x88\";\n  case 137:\n    return \"\\\\x89\";\n  case 138:\n    return \"\\\\x8A\";\n  case 139:\n    return \"\\\\x8B\";\n  case 140:\n    return \"\\\\x8C\";\n  case 141:\n    return \"\\\\x8D\";\n  case 142:\n    return \"\\\\x8E\";\n  case 143:\n    return \"\\\\x8F\";\n  case 144:\n    return \"\\\\x90\";\n  case 145:\n    return \"\\\\x91\";\n  case 146:\n    return \"\\\\x92\";\n  case 147:\n    return \"\\\\x93\";\n  case 148:\n    return \"\\\\x94\";\n  case 149:\n    return \"\\\\x95\";\n  case 150:\n    return \"\\\\x96\";\n  case 151:\n    return \"\\\\x97\";\n  case 152:\n    return \"\\\\x98\";\n  case 153:\n    return \"\\\\x99\";\n  case 154:\n    return \"\\\\x9A\";\n  case 155:\n    return \"\\\\x9B\";\n  case 156:\n    return \"\\\\x9C\";\n  case 157:\n    return \"\\\\x9D\";\n  case 158:\n    return \"\\\\x9E\";\n  case 159:\n    return \"\\\\x9F\";\n  case 160:\n    return \"\\\\xA0\";\n  case 161:\n    return \"\\\\xA1\";\n  case 162:\n    return \"\\\\xA2\";\n  case 163:\n    return \"\\\\xA3\";\n  case 164:\n    return \"\\\\xA4\";\n  case 165:\n    return \"\\\\xA5\";\n  case 166:\n    return \"\\\\xA6\";\n  case 167:\n    return \"\\\\xA7\";\n  case 168:\n    return \"\\\\xA8\";\n  case 169:\n    return \"\\\\xA9\";\n  case 170:\n    return \"\\\\xAA\";\n  case 171:\n    return \"\\\\xAB\";\n  case 172:\n    return \"\\\\xAC\";\n  case 173:\n    return \"\\\\xAD\";\n  case 174:\n    return \"\\\\xAE\";\n  case 175:\n    return \"\\\\xAF\";\n  case 176:\n    return \"\\\\xB0\";\n  case 177:\n    return \"\\\\xB1\";\n  case 178:\n    return \"\\\\xB2\";\n  case 179:\n    return \"\\\\xB3\";\n  case 180:\n    return \"\\\\xB4\";\n  case 181:\n    return \"\\\\xB5\";\n  case 182:\n    return \"\\\\xB6\";\n  case 183:\n    return \"\\\\xB7\";\n  case 184:\n    return \"\\\\xB8\";\n  case 185:\n    return \"\\\\xB9\";\n  case 186:\n    return \"\\\\xBA\";\n  case 187:\n    return \"\\\\xBB\";\n  case 188:\n    return \"\\\\xBC\";\n  case 189:\n    return \"\\\\xBD\";\n  case 190:\n    return \"\\\\xBE\";\n  case 191:\n    return \"\\\\xBF\";\n  case 192:\n    return \"\\\\xC0\";\n  case 193:\n    return \"\\\\xC1\";\n  case 194:\n    return \"\\\\xC2\";\n  case 195:\n    return \"\\\\xC3\";\n  case 196:\n    return \"\\\\xC4\";\n  case 197:\n    return \"\\\\xC5\";\n  case 198:\n    return \"\\\\xC6\";\n  case 199:\n    return \"\\\\xC7\";\n  case 200:\n    return \"\\\\xC8\";\n  case 201:\n    return \"\\\\xC9\";\n  case 202:\n    return \"\\\\xCA\";\n  case 203:\n    return \"\\\\xCB\";\n  case 204:\n    return \"\\\\xCC\";\n  case 205:\n    return \"\\\\xCD\";\n  case 206:\n    return \"\\\\xCE\";\n  case 207:\n    return \"\\\\xCF\";\n  case 208:\n    return \"\\\\xD0\";\n  case 209:\n    return \"\\\\xD1\";\n  case 210:\n    return \"\\\\xD2\";\n  case 211:\n    return \"\\\\xD3\";\n  case 212:\n    return \"\\\\xD4\";\n  case 213:\n    return \"\\\\xD5\";\n  case 214:\n    return \"\\\\xD6\";\n  case 215:\n    return \"\\\\xD7\";\n  case 216:\n    return \"\\\\xD8\";\n  case 217:\n    return \"\\\\xD9\";\n  case 218:\n    return \"\\\\xDA\";\n  case 219:\n    return \"\\\\xDB\";\n  case 220:\n    return \"\\\\xDC\";\n  case 221:\n    return \"\\\\xDD\";\n  case 222:\n    return \"\\\\xDE\";\n  case 223:\n    return \"\\\\xDF\";\n  case 224:\n    return \"\\\\xE0\";\n  case 225:\n    return \"\\\\xE1\";\n  case 226:\n    return \"\\\\xE2\";\n  case 227:\n    return \"\\\\xE3\";\n  case 228:\n    return \"\\\\xE4\";\n  case 229:\n    return \"\\\\xE5\";\n  case 230:\n    return \"\\\\xE6\";\n  case 231:\n    return \"\\\\xE7\";\n  case 232:\n    return \"\\\\xE8\";\n  case 233:\n    return \"\\\\xE9\";\n  case 234:\n    return \"\\\\xEA\";\n  case 235:\n    return \"\\\\xEB\";\n  case 236:\n    return \"\\\\xEC\";\n  case 237:\n    return \"\\\\xED\";\n  case 238:\n    return \"\\\\xEE\";\n  case 239:\n    return \"\\\\xEF\";\n  case 240:\n    return \"\\\\xF0\";\n  case 241:\n    return \"\\\\xF1\";\n  case 242:\n    return \"\\\\xF2\";\n  case 243:\n    return \"\\\\xF3\";\n  case 244:\n    return \"\\\\xF4\";\n  case 245:\n    return \"\\\\xF5\";\n  case 246:\n    return \"\\\\xF6\";\n  case 247:\n    return \"\\\\xF7\";\n  case 248:\n    return \"\\\\xF8\";\n  case 249:\n    return \"\\\\xF9\";\n  case 250:\n    return \"\\\\xFA\";\n  case 251:\n    return \"\\\\xFB\";\n  case 252:\n    return \"\\\\xFC\";\n  case 253:\n    return \"\\\\xFD\";\n  case 254:\n    return \"\\\\xFE\";\n  case 255:\n    return \"\\\\xFF\";\n  default:\n    assert(0); /* never gets here */\n    return \"dead code\";\n  }\n  assert(0); /* never gets here */\n}\n\n#endif /* defined(XML_DTD) || XML_GE == 1 */\n\nstatic unsigned long\ngetDebugLevel(const char *variableName, unsigned long defaultDebugLevel) {\n  const char *const valueOrNull = getenv(variableName);\n  if (valueOrNull == NULL) {\n    return defaultDebugLevel;\n  }\n  const char *const value = valueOrNull;\n\n  errno = 0;\n  char *afterValue = NULL;\n  unsigned long debugLevel = strtoul(value, &afterValue, 10);\n  if ((errno != 0) || (afterValue == value) || (afterValue[0] != '\\0')) {\n    errno = 0;\n    return defaultDebugLevel;\n  }\n\n  return debugLevel;\n}\n", "/*\n                            __  __            _\n                         ___\\ \\/ /_ __   __ _| |_\n                        / _ \\\\  /| '_ \\ / _` | __|\n                       |  __//  \\| |_) | (_| | |_\n                        \\___/_/\\_\\ .__/ \\__,_|\\__|\n                                 |_| XML parser\n\n   Copyright (c) 1997-2000 Thai Open Source Software Center Ltd\n   Copyright (c) 2000      Clark Cooper <coopercc@users.sourceforge.net>\n   Copyright (c) 2001-2003 Fred L. Drake, Jr. <fdrake@users.sourceforge.net>\n   Copyright (c) 2004-2009 Karl Waclawek <karl@waclawek.net>\n   Copyright (c) 2005-2007 Steven Solie <steven@solie.ca>\n   Copyright (c) 2016-2022 Sebastian Pipping <sebastian@pipping.org>\n   Copyright (c) 2017      Rhodri James <rhodri@wildebeest.org.uk>\n   Copyright (c) 2019      David Loffredo <loffredo@steptools.com>\n   Copyright (c) 2020      Joe Orton <jorton@redhat.com>\n   Copyright (c) 2020      Kleber Tarc\u00edsio <klebertarcisio@yahoo.com.br>\n   Copyright (c) 2021      Tim Bray <tbray@textuality.com>\n   Copyright (c) 2022      Martin Ettl <ettl.martin78@googlemail.com>\n   Licensed under the MIT license:\n\n   Permission is  hereby granted,  free of charge,  to any  person obtaining\n   a  copy  of  this  software   and  associated  documentation  files  (the\n   \"Software\"),  to  deal in  the  Software  without restriction,  including\n   without  limitation the  rights  to use,  copy,  modify, merge,  publish,\n   distribute, sublicense, and/or sell copies of the Software, and to permit\n   persons  to whom  the Software  is  furnished to  do so,  subject to  the\n   following conditions:\n\n   The above copyright  notice and this permission notice  shall be included\n   in all copies or substantial portions of the Software.\n\n   THE  SOFTWARE  IS  PROVIDED  \"AS  IS\",  WITHOUT  WARRANTY  OF  ANY  KIND,\n   EXPRESS  OR IMPLIED,  INCLUDING  BUT  NOT LIMITED  TO  THE WARRANTIES  OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n   NO EVENT SHALL THE AUTHORS OR  COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n   DAMAGES OR  OTHER LIABILITY, WHETHER  IN AN  ACTION OF CONTRACT,  TORT OR\n   OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n   USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#include \"expat_config.h\"\n\n#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <string.h>\n#include <math.h> /* for isnan */\n#include <errno.h>\n\n#include \"expat.h\"\n#include \"codepage.h\"\n#include \"internal.h\" /* for UNUSED_P only */\n#include \"xmlfile.h\"\n#include \"xmltchar.h\"\n\n#ifdef _MSC_VER\n#  include <crtdbg.h>\n#endif\n\n#ifdef XML_UNICODE\n#  include <wchar.h>\n#endif\n\nenum ExitCode {\n  XMLWF_EXIT_SUCCESS = 0,\n  XMLWF_EXIT_INTERNAL_ERROR = 1,\n  XMLWF_EXIT_NOT_WELLFORMED = 2,\n  XMLWF_EXIT_OUTPUT_ERROR = 3,\n  XMLWF_EXIT_USAGE_ERROR = 4,\n};\n\n/* Structures for handler user data */\ntypedef struct NotationList {\n  struct NotationList *next;\n  const XML_Char *notationName;\n  const XML_Char *systemId;\n  const XML_Char *publicId;\n} NotationList;\n\ntypedef struct xmlwfUserData {\n  FILE *fp;\n  NotationList *notationListHead;\n  const XML_Char *currentDoctypeName;\n} XmlwfUserData;\n\n/* This ensures proper sorting. */\n\n#define NSSEP T('\\001')\n\nstatic void XMLCALL\ncharacterData(void *userData, const XML_Char *s, int len) {\n  FILE *fp = ((XmlwfUserData *)userData)->fp;\n  for (; len > 0; --len, ++s) {\n    switch (*s) {\n    case T('&'):\n      fputts(T(\"&amp;\"), fp);\n      break;\n    case T('<'):\n      fputts(T(\"&lt;\"), fp);\n      break;\n    case T('>'):\n      fputts(T(\"&gt;\"), fp);\n      break;\n#ifdef W3C14N\n    case 13:\n      fputts(T(\"&#xD;\"), fp);\n      break;\n#else\n    case T('\"'):\n      fputts(T(\"&quot;\"), fp);\n      break;\n    case 9:\n    case 10:\n    case 13:\n      ftprintf(fp, T(\"&#%d;\"), *s);\n      break;\n#endif\n    default:\n      puttc(*s, fp);\n      break;\n    }\n  }\n}\n\nstatic void\nattributeValue(FILE *fp, const XML_Char *s) {\n  puttc(T('='), fp);\n  puttc(T('\"'), fp);\n  assert(s);\n  for (;;) {\n    switch (*s) {\n    case 0:\n    case NSSEP:\n      puttc(T('\"'), fp);\n      return;\n    case T('&'):\n      fputts(T(\"&amp;\"), fp);\n      break;\n    case T('<'):\n      fputts(T(\"&lt;\"), fp);\n      break;\n    case T('\"'):\n      fputts(T(\"&quot;\"), fp);\n      break;\n#ifdef W3C14N\n    case 9:\n      fputts(T(\"&#x9;\"), fp);\n      break;\n    case 10:\n      fputts(T(\"&#xA;\"), fp);\n      break;\n    case 13:\n      fputts(T(\"&#xD;\"), fp);\n      break;\n#else\n    case T('>'):\n      fputts(T(\"&gt;\"), fp);\n      break;\n    case 9:\n    case 10:\n    case 13:\n      ftprintf(fp, T(\"&#%d;\"), *s);\n      break;\n#endif\n    default:\n      puttc(*s, fp);\n      break;\n    }\n    s++;\n  }\n}\n\n/* Lexicographically comparing UTF-8 encoded attribute values,\nis equivalent to lexicographically comparing based on the character number. */\n\nstatic int\nattcmp(const void *att1, const void *att2) {\n  return tcscmp(*(const XML_Char *const *)att1, *(const XML_Char *const *)att2);\n}\n\nstatic void XMLCALL\nstartElement(void *userData, const XML_Char *name, const XML_Char **atts) {\n  int nAtts;\n  const XML_Char **p;\n  FILE *fp = ((XmlwfUserData *)userData)->fp;\n  puttc(T('<'), fp);\n  fputts(name, fp);\n\n  p = atts;\n  while (*p)\n    ++p;\n  nAtts = (int)((p - atts) >> 1);\n  if (nAtts > 1)\n    qsort((void *)atts, nAtts, sizeof(XML_Char *) * 2, attcmp);\n  while (*atts) {\n    puttc(T(' '), fp);\n    fputts(*atts++, fp);\n    attributeValue(fp, *atts);\n    atts++;\n  }\n  puttc(T('>'), fp);\n}\n\nstatic void XMLCALL\nendElement(void *userData, const XML_Char *name) {\n  FILE *fp = ((XmlwfUserData *)userData)->fp;\n  puttc(T('<'), fp);\n  puttc(T('/'), fp);\n  fputts(name, fp);\n  puttc(T('>'), fp);\n}\n\nstatic int\nnsattcmp(const void *p1, const void *p2) {\n  const XML_Char *att1 = *(const XML_Char *const *)p1;\n  const XML_Char *att2 = *(const XML_Char *const *)p2;\n  int sep1 = (tcsrchr(att1, NSSEP) != 0);\n  int sep2 = (tcsrchr(att2, NSSEP) != 0);\n  if (sep1 != sep2)\n    return sep1 - sep2;\n  return tcscmp(att1, att2);\n}\n\nstatic void XMLCALL\nstartElementNS(void *userData, const XML_Char *name, const XML_Char **atts) {\n  int nAtts;\n  int nsi;\n  const XML_Char **p;\n  FILE *fp = ((XmlwfUserData *)userData)->fp;\n  const XML_Char *sep;\n  puttc(T('<'), fp);\n\n  sep = tcsrchr(name, NSSEP);\n  if (sep) {\n    fputts(T(\"n1:\"), fp);\n    fputts(sep + 1, fp);\n    fputts(T(\" xmlns:n1\"), fp);\n    attributeValue(fp, name);\n    nsi = 2;\n  } else {\n    fputts(name, fp);\n    nsi = 1;\n  }\n\n  p = atts;\n  while (*p)\n    ++p;\n  nAtts = (int)((p - atts) >> 1);\n  if (nAtts > 1)\n    qsort((void *)atts, nAtts, sizeof(XML_Char *) * 2, nsattcmp);\n  while (*atts) {\n    name = *atts++;\n    sep = tcsrchr(name, NSSEP);\n    puttc(T(' '), fp);\n    if (sep) {\n      ftprintf(fp, T(\"n%d:\"), nsi);\n      fputts(sep + 1, fp);\n    } else\n      fputts(name, fp);\n    attributeValue(fp, *atts);\n    if (sep) {\n      ftprintf(fp, T(\" xmlns:n%d\"), nsi++);\n      attributeValue(fp, name);\n    }\n    atts++;\n  }\n  puttc(T('>'), fp);\n}\n\nstatic void XMLCALL\nendElementNS(void *userData, const XML_Char *name) {\n  FILE *fp = ((XmlwfUserData *)userData)->fp;\n  const XML_Char *sep;\n  puttc(T('<'), fp);\n  puttc(T('/'), fp);\n  sep = tcsrchr(name, NSSEP);\n  if (sep) {\n    fputts(T(\"n1:\"), fp);\n    fputts(sep + 1, fp);\n  } else\n    fputts(name, fp);\n  puttc(T('>'), fp);\n}\n\n#ifndef W3C14N\n\nstatic void XMLCALL\nprocessingInstruction(void *userData, const XML_Char *target,\n                      const XML_Char *data) {\n  FILE *fp = ((XmlwfUserData *)userData)->fp;\n  puttc(T('<'), fp);\n  puttc(T('?'), fp);\n  fputts(target, fp);\n  puttc(T(' '), fp);\n  fputts(data, fp);\n  puttc(T('?'), fp);\n  puttc(T('>'), fp);\n}\n\nstatic XML_Char *\nxcsdup(const XML_Char *s) {\n  XML_Char *result;\n  int count = 0;\n  int numBytes;\n\n  /* Get the length of the string, including terminator */\n  while (s[count++] != 0) {\n    /* Do nothing */\n  }\n  numBytes = count * sizeof(XML_Char);\n  result = malloc(numBytes);\n  if (result == NULL)\n    return NULL;\n  memcpy(result, s, numBytes);\n  return result;\n}\n\nstatic void XMLCALL\nstartDoctypeDecl(void *userData, const XML_Char *doctypeName,\n                 const XML_Char *sysid, const XML_Char *publid,\n                 int has_internal_subset) {\n  XmlwfUserData *data = (XmlwfUserData *)userData;\n  UNUSED_P(sysid);\n  UNUSED_P(publid);\n  UNUSED_P(has_internal_subset);\n  data->currentDoctypeName = xcsdup(doctypeName);\n}\n\nstatic void\nfreeNotations(XmlwfUserData *data) {\n  NotationList *notationListHead = data->notationListHead;\n\n  while (notationListHead != NULL) {\n    NotationList *next = notationListHead->next;\n    free((void *)notationListHead->notationName);\n    free((void *)notationListHead->systemId);\n    free((void *)notationListHead->publicId);\n    free(notationListHead);\n    notationListHead = next;\n  }\n  data->notationListHead = NULL;\n}\n\nstatic void\ncleanupUserData(XmlwfUserData *userData) {\n  free((void *)userData->currentDoctypeName);\n  userData->currentDoctypeName = NULL;\n  freeNotations(userData);\n}\n\nstatic int\nxcscmp(const XML_Char *xs, const XML_Char *xt) {\n  while (*xs != 0 && *xt != 0) {\n    if (*xs < *xt)\n      return -1;\n    if (*xs > *xt)\n      return 1;\n    xs++;\n    xt++;\n  }\n  if (*xs < *xt)\n    return -1;\n  if (*xs > *xt)\n    return 1;\n  return 0;\n}\n\nstatic int\nnotationCmp(const void *a, const void *b) {\n  const NotationList *const n1 = *(const NotationList *const *)a;\n  const NotationList *const n2 = *(const NotationList *const *)b;\n\n  return xcscmp(n1->notationName, n2->notationName);\n}\n\nstatic void XMLCALL\nendDoctypeDecl(void *userData) {\n  XmlwfUserData *data = (XmlwfUserData *)userData;\n  NotationList **notations;\n  int notationCount = 0;\n  NotationList *p;\n  int i;\n\n  /* How many notations do we have? */\n  for (p = data->notationListHead; p != NULL; p = p->next)\n    notationCount++;\n  if (notationCount == 0) {\n    /* Nothing to report */\n    free((void *)data->currentDoctypeName);\n    data->currentDoctypeName = NULL;\n    return;\n  }\n\n  notations = malloc(notationCount * sizeof(NotationList *));\n  if (notations == NULL) {\n    fprintf(stderr, \"Unable to sort notations\");\n    freeNotations(data);\n    return;\n  }\n\n  for (p = data->notationListHead, i = 0; i < notationCount; p = p->next, i++) {\n    notations[i] = p;\n  }\n  qsort(notations, notationCount, sizeof(NotationList *), notationCmp);\n\n  /* Output the DOCTYPE header */\n  fputts(T(\"<!DOCTYPE \"), data->fp);\n  fputts(data->currentDoctypeName, data->fp);\n  fputts(T(\" [\\n\"), data->fp);\n\n  /* Now the NOTATIONs */\n  for (i = 0; i < notationCount; i++) {\n    fputts(T(\"<!NOTATION \"), data->fp);\n    fputts(notations[i]->notationName, data->fp);\n    if (notations[i]->publicId != NULL) {\n      fputts(T(\" PUBLIC '\"), data->fp);\n      fputts(notations[i]->publicId, data->fp);\n      puttc(T('\\''), data->fp);\n      if (notations[i]->systemId != NULL) {\n        puttc(T(' '), data->fp);\n        puttc(T('\\''), data->fp);\n        fputts(notations[i]->systemId, data->fp);\n        puttc(T('\\''), data->fp);\n      }\n    } else if (notations[i]->systemId != NULL) {\n      fputts(T(\" SYSTEM '\"), data->fp);\n      fputts(notations[i]->systemId, data->fp);\n      puttc(T('\\''), data->fp);\n    }\n    puttc(T('>'), data->fp);\n    puttc(T('\\n'), data->fp);\n  }\n\n  /* Finally end the DOCTYPE */\n  fputts(T(\"]>\\n\"), data->fp);\n\n  free(notations);\n  freeNotations(data);\n  free((void *)data->currentDoctypeName);\n  data->currentDoctypeName = NULL;\n}\n\nstatic void XMLCALL\nnotationDecl(void *userData, const XML_Char *notationName, const XML_Char *base,\n             const XML_Char *systemId, const XML_Char *publicId) {\n  XmlwfUserData *data = (XmlwfUserData *)userData;\n  NotationList *entry = malloc(sizeof(NotationList));\n  const char *errorMessage = \"Unable to store NOTATION for output\\n\";\n\n  UNUSED_P(base);\n  if (entry == NULL) {\n    fputs(errorMessage, stderr);\n    return; /* Nothing we can really do about this */\n  }\n  entry->notationName = xcsdup(notationName);\n  if (entry->notationName == NULL) {\n    fputs(errorMessage, stderr);\n    free(entry);\n    return;\n  }\n  if (systemId != NULL) {\n    entry->systemId = xcsdup(systemId);\n    if (entry->systemId == NULL) {\n      fputs(errorMessage, stderr);\n      free((void *)entry->notationName);\n      free(entry);\n      return;\n    }\n  } else {\n    entry->systemId = NULL;\n  }\n  if (publicId != NULL) {\n    entry->publicId = xcsdup(publicId);\n    if (entry->publicId == NULL) {\n      fputs(errorMessage, stderr);\n      free((void *)entry->systemId); /* Safe if it's NULL */\n      free((void *)entry->notationName);\n      free(entry);\n      return;\n    }\n  } else {\n    entry->publicId = NULL;\n  }\n\n  entry->next = data->notationListHead;\n  data->notationListHead = entry;\n}\n\n#endif /* not W3C14N */\n\nstatic void XMLCALL\ndefaultCharacterData(void *userData, const XML_Char *s, int len) {\n  UNUSED_P(s);\n  UNUSED_P(len);\n  XML_DefaultCurrent((XML_Parser)userData);\n}\n\nstatic void XMLCALL\ndefaultStartElement(void *userData, const XML_Char *name,\n                    const XML_Char **atts) {\n  UNUSED_P(name);\n  UNUSED_P(atts);\n  XML_DefaultCurrent((XML_Parser)userData);\n}\n\nstatic void XMLCALL\ndefaultEndElement(void *userData, const XML_Char *name) {\n  UNUSED_P(name);\n  XML_DefaultCurrent((XML_Parser)userData);\n}\n\nstatic void XMLCALL\ndefaultProcessingInstruction(void *userData, const XML_Char *target,\n                             const XML_Char *data) {\n  UNUSED_P(target);\n  UNUSED_P(data);\n  XML_DefaultCurrent((XML_Parser)userData);\n}\n\nstatic void XMLCALL\nnopCharacterData(void *userData, const XML_Char *s, int len) {\n  UNUSED_P(userData);\n  UNUSED_P(s);\n  UNUSED_P(len);\n}\n\nstatic void XMLCALL\nnopStartElement(void *userData, const XML_Char *name, const XML_Char **atts) {\n  UNUSED_P(userData);\n  UNUSED_P(name);\n  UNUSED_P(atts);\n}\n\nstatic void XMLCALL\nnopEndElement(void *userData, const XML_Char *name) {\n  UNUSED_P(userData);\n  UNUSED_P(name);\n}\n\nstatic void XMLCALL\nnopProcessingInstruction(void *userData, const XML_Char *target,\n                         const XML_Char *data) {\n  UNUSED_P(userData);\n  UNUSED_P(target);\n  UNUSED_P(data);\n}\n\nstatic void XMLCALL\nmarkup(void *userData, const XML_Char *s, int len) {\n  FILE *fp = ((XmlwfUserData *)XML_GetUserData((XML_Parser)userData))->fp;\n  for (; len > 0; --len, ++s)\n    puttc(*s, fp);\n}\n\nstatic void\nmetaLocation(XML_Parser parser) {\n  const XML_Char *uri = XML_GetBase(parser);\n  FILE *fp = ((XmlwfUserData *)XML_GetUserData(parser))->fp;\n  if (uri)\n    ftprintf(fp, T(\" uri=\\\"%s\\\"\"), uri);\n  ftprintf(fp,\n           T(\" byte=\\\"%\") T(XML_FMT_INT_MOD) T(\"d\\\"\") T(\" nbytes=\\\"%d\\\"\")\n               T(\" line=\\\"%\") T(XML_FMT_INT_MOD) T(\"u\\\"\") T(\" col=\\\"%\")\n                   T(XML_FMT_INT_MOD) T(\"u\\\"\"),\n           XML_GetCurrentByteIndex(parser), XML_GetCurrentByteCount(parser),\n           XML_GetCurrentLineNumber(parser),\n           XML_GetCurrentColumnNumber(parser));\n}\n\nstatic void\nmetaStartDocument(void *userData) {\n  fputts(T(\"<document>\\n\"),\n         ((XmlwfUserData *)XML_GetUserData((XML_Parser)userData))->fp);\n}\n\nstatic void\nmetaEndDocument(void *userData) {\n  fputts(T(\"</document>\\n\"),\n         ((XmlwfUserData *)XML_GetUserData((XML_Parser)userData))->fp);\n}\n\nstatic void XMLCALL\nmetaStartElement(void *userData, const XML_Char *name, const XML_Char **atts) {\n  XML_Parser parser = (XML_Parser)userData;\n  XmlwfUserData *data = (XmlwfUserData *)XML_GetUserData(parser);\n  FILE *fp = data->fp;\n  const XML_Char **specifiedAttsEnd\n      = atts + XML_GetSpecifiedAttributeCount(parser);\n  const XML_Char **idAttPtr;\n  int idAttIndex = XML_GetIdAttributeIndex(parser);\n  if (idAttIndex < 0)\n    idAttPtr = 0;\n  else\n    idAttPtr = atts + idAttIndex;\n\n  ftprintf(fp, T(\"<starttag name=\\\"%s\\\"\"), name);\n  metaLocation(parser);\n  if (*atts) {\n    fputts(T(\">\\n\"), fp);\n    do {\n      ftprintf(fp, T(\"<attribute name=\\\"%s\\\" value=\\\"\"), atts[0]);\n      characterData(data, atts[1], (int)tcslen(atts[1]));\n      if (atts >= specifiedAttsEnd)\n        fputts(T(\"\\\" defaulted=\\\"yes\\\"/>\\n\"), fp);\n      else if (atts == idAttPtr)\n        fputts(T(\"\\\" id=\\\"yes\\\"/>\\n\"), fp);\n      else\n        fputts(T(\"\\\"/>\\n\"), fp);\n    } while (*(atts += 2));\n    fputts(T(\"</starttag>\\n\"), fp);\n  } else\n    fputts(T(\"/>\\n\"), fp);\n}\n\nstatic void XMLCALL\nmetaEndElement(void *userData, const XML_Char *name) {\n  XML_Parser parser = (XML_Parser)userData;\n  XmlwfUserData *data = (XmlwfUserData *)XML_GetUserData(parser);\n  FILE *fp = data->fp;\n  ftprintf(fp, T(\"<endtag name=\\\"%s\\\"\"), name);\n  metaLocation(parser);\n  fputts(T(\"/>\\n\"), fp);\n}\n\nstatic void XMLCALL\nmetaProcessingInstruction(void *userData, const XML_Char *target,\n                          const XML_Char *data) {\n  XML_Parser parser = (XML_Parser)userData;\n  XmlwfUserData *usrData = (XmlwfUserData *)XML_GetUserData(parser);\n  FILE *fp = usrData->fp;\n  ftprintf(fp, T(\"<pi target=\\\"%s\\\" data=\\\"\"), target);\n  characterData(usrData, data, (int)tcslen(data));\n  puttc(T('\"'), fp);\n  metaLocation(parser);\n  fputts(T(\"/>\\n\"), fp);\n}\n\nstatic void XMLCALL\nmetaComment(void *userData, const XML_Char *data) {\n  XML_Parser parser = (XML_Parser)userData;\n  XmlwfUserData *usrData = (XmlwfUserData *)XML_GetUserData(parser);\n  FILE *fp = usrData->fp;\n  fputts(T(\"<comment data=\\\"\"), fp);\n  characterData(usrData, data, (int)tcslen(data));\n  puttc(T('\"'), fp);\n  metaLocation(parser);\n  fputts(T(\"/>\\n\"), fp);\n}\n\nstatic void XMLCALL\nmetaStartCdataSection(void *userData) {\n  XML_Parser parser = (XML_Parser)userData;\n  XmlwfUserData *data = (XmlwfUserData *)XML_GetUserData(parser);\n  FILE *fp = data->fp;\n  fputts(T(\"<startcdata\"), fp);\n  metaLocation(parser);\n  fputts(T(\"/>\\n\"), fp);\n}\n\nstatic void XMLCALL\nmetaEndCdataSection(void *userData) {\n  XML_Parser parser = (XML_Parser)userData;\n  XmlwfUserData *data = (XmlwfUserData *)XML_GetUserData(parser);\n  FILE *fp = data->fp;\n  fputts(T(\"<endcdata\"), fp);\n  metaLocation(parser);\n  fputts(T(\"/>\\n\"), fp);\n}\n\nstatic void XMLCALL\nmetaCharacterData(void *userData, const XML_Char *s, int len) {\n  XML_Parser parser = (XML_Parser)userData;\n  XmlwfUserData *data = (XmlwfUserData *)XML_GetUserData(parser);\n  FILE *fp = data->fp;\n  fputts(T(\"<chars str=\\\"\"), fp);\n  characterData(data, s, len);\n  puttc(T('\"'), fp);\n  metaLocation(parser);\n  fputts(T(\"/>\\n\"), fp);\n}\n\nstatic void XMLCALL\nmetaStartDoctypeDecl(void *userData, const XML_Char *doctypeName,\n                     const XML_Char *sysid, const XML_Char *pubid,\n                     int has_internal_subset) {\n  XML_Parser parser = (XML_Parser)userData;\n  XmlwfUserData *data = (XmlwfUserData *)XML_GetUserData(parser);\n  FILE *fp = data->fp;\n  UNUSED_P(sysid);\n  UNUSED_P(pubid);\n  UNUSED_P(has_internal_subset);\n  ftprintf(fp, T(\"<startdoctype name=\\\"%s\\\"\"), doctypeName);\n  metaLocation(parser);\n  fputts(T(\"/>\\n\"), fp);\n}\n\nstatic void XMLCALL\nmetaEndDoctypeDecl(void *userData) {\n  XML_Parser parser = (XML_Parser)userData;\n  XmlwfUserData *data = (XmlwfUserData *)XML_GetUserData(parser);\n  FILE *fp = data->fp;\n  fputts(T(\"<enddoctype\"), fp);\n  metaLocation(parser);\n  fputts(T(\"/>\\n\"), fp);\n}\n\nstatic void XMLCALL\nmetaNotationDecl(void *userData, const XML_Char *notationName,\n                 const XML_Char *base, const XML_Char *systemId,\n                 const XML_Char *publicId) {\n  XML_Parser parser = (XML_Parser)userData;\n  XmlwfUserData *data = (XmlwfUserData *)XML_GetUserData(parser);\n  FILE *fp = data->fp;\n  UNUSED_P(base);\n  ftprintf(fp, T(\"<notation name=\\\"%s\\\"\"), notationName);\n  if (publicId)\n    ftprintf(fp, T(\" public=\\\"%s\\\"\"), publicId);\n  if (systemId) {\n    fputts(T(\" system=\\\"\"), fp);\n    characterData(data, systemId, (int)tcslen(systemId));\n    puttc(T('\"'), fp);\n  }\n  metaLocation(parser);\n  fputts(T(\"/>\\n\"), fp);\n}\n\nstatic void XMLCALL\nmetaEntityDecl(void *userData, const XML_Char *entityName, int is_param,\n               const XML_Char *value, int value_length, const XML_Char *base,\n               const XML_Char *systemId, const XML_Char *publicId,\n               const XML_Char *notationName) {\n  XML_Parser parser = (XML_Parser)userData;\n  XmlwfUserData *data = (XmlwfUserData *)XML_GetUserData(parser);\n  FILE *fp = data->fp;\n\n  UNUSED_P(is_param);\n  UNUSED_P(base);\n  if (value) {\n    ftprintf(fp, T(\"<entity name=\\\"%s\\\"\"), entityName);\n    metaLocation(parser);\n    puttc(T('>'), fp);\n    characterData(data, value, value_length);\n    fputts(T(\"</entity/>\\n\"), fp);\n  } else if (notationName) {\n    ftprintf(fp, T(\"<entity name=\\\"%s\\\"\"), entityName);\n    if (publicId)\n      ftprintf(fp, T(\" public=\\\"%s\\\"\"), publicId);\n    fputts(T(\" system=\\\"\"), fp);\n    characterData(data, systemId, (int)tcslen(systemId));\n    puttc(T('\"'), fp);\n    ftprintf(fp, T(\" notation=\\\"%s\\\"\"), notationName);\n    metaLocation(parser);\n    fputts(T(\"/>\\n\"), fp);\n  } else {\n    ftprintf(fp, T(\"<entity name=\\\"%s\\\"\"), entityName);\n    if (publicId)\n      ftprintf(fp, T(\" public=\\\"%s\\\"\"), publicId);\n    fputts(T(\" system=\\\"\"), fp);\n    characterData(data, systemId, (int)tcslen(systemId));\n    puttc(T('\"'), fp);\n    metaLocation(parser);\n    fputts(T(\"/>\\n\"), fp);\n  }\n}\n\nstatic void XMLCALL\nmetaStartNamespaceDecl(void *userData, const XML_Char *prefix,\n                       const XML_Char *uri) {\n  XML_Parser parser = (XML_Parser)userData;\n  XmlwfUserData *data = (XmlwfUserData *)XML_GetUserData(parser);\n  FILE *fp = data->fp;\n  fputts(T(\"<startns\"), fp);\n  if (prefix)\n    ftprintf(fp, T(\" prefix=\\\"%s\\\"\"), prefix);\n  if (uri) {\n    fputts(T(\" ns=\\\"\"), fp);\n    characterData(data, uri, (int)tcslen(uri));\n    fputts(T(\"\\\"/>\\n\"), fp);\n  } else\n    fputts(T(\"/>\\n\"), fp);\n}\n\nstatic void XMLCALL\nmetaEndNamespaceDecl(void *userData, const XML_Char *prefix) {\n  XML_Parser parser = (XML_Parser)userData;\n  XmlwfUserData *data = (XmlwfUserData *)XML_GetUserData(parser);\n  FILE *fp = data->fp;\n  if (! prefix)\n    fputts(T(\"<endns/>\\n\"), fp);\n  else\n    ftprintf(fp, T(\"<endns prefix=\\\"%s\\\"/>\\n\"), prefix);\n}\n\nstatic int XMLCALL\nunknownEncodingConvert(void *data, const char *p) {\n  return codepageConvert(*(int *)data, p);\n}\n\nstatic int XMLCALL\nunknownEncoding(void *userData, const XML_Char *name, XML_Encoding *info) {\n  int cp;\n  static const XML_Char prefixL[] = T(\"windows-\");\n  static const XML_Char prefixU[] = T(\"WINDOWS-\");\n  int i;\n\n  UNUSED_P(userData);\n  for (i = 0; prefixU[i]; i++)\n    if (name[i] != prefixU[i] && name[i] != prefixL[i])\n      return 0;\n\n  cp = 0;\n  for (; name[i]; i++) {\n    static const XML_Char digits[] = T(\"0123456789\");\n    const XML_Char *s = tcschr(digits, name[i]);\n    if (! s)\n      return 0;\n    cp *= 10;\n    cp += (int)(s - digits);\n    if (cp >= 0x10000)\n      return 0;\n  }\n  if (! codepageMap(cp, info->map))\n    return 0;\n  info->convert = unknownEncodingConvert;\n  /* We could just cast the code page integer to a void *,\n  and avoid the use of release. */\n  info->release = free;\n  info->data = malloc(sizeof(int));\n  if (! info->data)\n    return 0;\n  *(int *)info->data = cp;\n  return 1;\n}\n\nstatic int XMLCALL\nnotStandalone(void *userData) {\n  UNUSED_P(userData);\n  return 0;\n}\n\nstatic void\nshowVersion(XML_Char *prog) {\n  XML_Char *s = prog;\n  XML_Char ch;\n  const XML_Feature *features = XML_GetFeatureList();\n  while ((ch = *s) != 0) {\n    if (ch == '/'\n#if defined(_WIN32)\n        || ch == '\\\\'\n#endif\n    )\n      prog = s + 1;\n    ++s;\n  }\n  ftprintf(stdout, T(\"%s using %s\\n\"), prog, XML_ExpatVersion());\n  if (features != NULL && features[0].feature != XML_FEATURE_END) {\n    int i = 1;\n    ftprintf(stdout, T(\"%s\"), features[0].name);\n    if (features[0].value)\n      ftprintf(stdout, T(\"=%ld\"), features[0].value);\n    while (features[i].feature != XML_FEATURE_END) {\n      ftprintf(stdout, T(\", %s\"), features[i].name);\n      if (features[i].value)\n        ftprintf(stdout, T(\"=%ld\"), features[i].value);\n      ++i;\n    }\n    ftprintf(stdout, T(\"\\n\"));\n  }\n}\n\n#if defined(__GNUC__)\n__attribute__((noreturn))\n#endif\nstatic void\nusage(const XML_Char *prog, int rc) {\n  ftprintf(\n      stderr,\n      /* Generated with:\n       * $ xmlwf/xmlwf_helpgen.sh\n       * To update, change xmlwf/xmlwf_helpgen.py, then paste the output of\n       * xmlwf/xmlwf_helpgen.sh in here.\n       */\n      /* clang-format off */\n      T(\"usage:\\n\")\n      T(\"  %s [OPTIONS] [FILE ...]\\n\")\n      T(\"  %s -h|--help\\n\")\n      T(\"  %s -v|--version\\n\")\n      T(\"\\n\")\n      T(\"xmlwf - Determines if an XML document is well-formed\\n\")\n      T(\"\\n\")\n      T(\"positional arguments:\\n\")\n      T(\"  FILE           file to process (default: STDIN)\\n\")\n      T(\"\\n\")\n      T(\"input control arguments:\\n\")\n      T(\"  -s             print an error if the document is not [s]tandalone\\n\")\n      T(\"  -n             enable [n]amespace processing\\n\")\n      T(\"  -p             enable processing of external DTDs and [p]arameter entities\\n\")\n      T(\"  -x             enable processing of e[x]ternal entities\\n\")\n      T(\"  -e ENCODING    override any in-document [e]ncoding declaration\\n\")\n      T(\"  -w             enable support for [W]indows code pages\\n\")\n      T(\"  -r             disable memory-mapping and use [r]ead calls instead\\n\")\n      T(\"  -g BYTES       buffer size to request per call pair to XML_[G]etBuffer and read (default: 8 KiB)\\n\")\n      T(\"  -k             when processing multiple files, [k]eep processing after first file with error\\n\")\n      T(\"\\n\")\n      T(\"output control arguments:\\n\")\n      T(\"  -d DIRECTORY   output [d]estination directory\\n\")\n      T(\"  -c             write a [c]opy of input XML, not canonical XML\\n\")\n      T(\"  -m             write [m]eta XML, not canonical XML\\n\")\n      T(\"  -t             write no XML output for [t]iming of plain parsing\\n\")\n      T(\"  -N             enable adding doctype and [n]otation declarations\\n\")\n      T(\"\\n\")\n      T(\"billion laughs attack protection:\\n\")\n      T(\"  NOTE: If you ever need to increase these values for non-attack payload, please file a bug report.\\n\")\n      T(\"\\n\")\n      T(\"  -a FACTOR      set maximum tolerated [a]mplification factor (default: 100.0)\\n\")\n      T(\"  -b BYTES       set number of output [b]ytes needed to activate (default: 8 MiB)\\n\")\n      T(\"\\n\")\n      T(\"info arguments:\\n\")\n      T(\"  -h, --help     show this [h]elp message and exit\\n\")\n      T(\"  -v, --version  show program's [v]ersion number and exit\\n\")\n      T(\"\\n\")\n      T(\"exit status:\\n\")\n      T(\"  0              the input files are well-formed and the output (if requested) was written successfully\\n\")\n      T(\"  1              could not allocate data structures, signals a serious problem with execution environment\\n\")\n      T(\"  2              one or more input files were not well-formed\\n\")\n      T(\"  3              could not create an output file\\n\")\n      T(\"  4              command-line argument error\\n\")\n      T(\"\\n\")\n      T(\"xmlwf of libexpat is software libre, licensed under the MIT license.\\n\")\n      T(\"Please report bugs at https://github.com/libexpat/libexpat/issues -- thank you!\\n\")\n      , /* clang-format on */\n      prog, prog, prog);\n  exit(rc);\n}\n\n#if defined(__MINGW32__) && defined(XML_UNICODE)\n/* Silence warning about missing prototype */\nint wmain(int argc, XML_Char **argv);\n#endif\n\n#define XMLWF_SHIFT_ARG_INTO(constCharStarTarget, argc, argv, i, j)            \\\n  {                                                                            \\\n    if (argv[i][j + 1] == T('\\0')) {                                           \\\n      if (++i == argc) {                                                       \\\n        usage(argv[0], XMLWF_EXIT_USAGE_ERROR);                                \\\n        /* usage called exit(..), never gets here */                           \\\n      }                                                                        \\\n      constCharStarTarget = argv[i];                                           \\\n    } else {                                                                   \\\n      constCharStarTarget = argv[i] + j + 1;                                   \\\n    }                                                                          \\\n    i++;                                                                       \\\n    j = 0;                                                                     \\\n  }\n\nint\ntmain(int argc, XML_Char **argv) {\n  int i, j;\n  const XML_Char *outputDir = NULL;\n  const XML_Char *encoding = NULL;\n  unsigned processFlags = XML_MAP_FILE;\n  int windowsCodePages = 0;\n  int outputType = 0;\n  int useNamespaces = 0;\n  int requireStandalone = 0;\n  int requiresNotations = 0;\n  int continueOnError = 0;\n\n  float attackMaximumAmplification = -1.0f; /* signaling \"not set\" */\n  unsigned long long attackThresholdBytes = 0;\n  XML_Bool attackThresholdGiven = XML_FALSE;\n\n  int exitCode = XMLWF_EXIT_SUCCESS;\n  enum XML_ParamEntityParsing paramEntityParsing\n      = XML_PARAM_ENTITY_PARSING_NEVER;\n  int useStdin = 0;\n  XmlwfUserData userData = {NULL, NULL, NULL};\n\n#ifdef _MSC_VER\n  _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);\n#endif\n\n  i = 1;\n  j = 0;\n  while (i < argc) {\n    if (j == 0) {\n      if (argv[i][0] != T('-'))\n        break;\n      if (argv[i][1] == T('-')) {\n        if (argv[i][2] == T('\\0')) {\n          i++;\n          break;\n        } else if (tcscmp(argv[i] + 2, T(\"help\")) == 0) {\n          usage(argv[0], XMLWF_EXIT_SUCCESS);\n          // usage called exit(..), never gets here\n        } else if (tcscmp(argv[i] + 2, T(\"version\")) == 0) {\n          showVersion(argv[0]);\n          return XMLWF_EXIT_SUCCESS;\n        }\n      }\n      j++;\n    }\n    switch (argv[i][j]) {\n    case T('r'):\n      processFlags &= ~XML_MAP_FILE;\n      j++;\n      break;\n    case T('s'):\n      requireStandalone = 1;\n      j++;\n      break;\n    case T('n'):\n      useNamespaces = 1;\n      j++;\n      break;\n    case T('p'):\n      paramEntityParsing = XML_PARAM_ENTITY_PARSING_ALWAYS;\n      /* fall through */\n    case T('x'):\n      processFlags |= XML_EXTERNAL_ENTITIES;\n      j++;\n      break;\n    case T('w'):\n      windowsCodePages = 1;\n      j++;\n      break;\n    case T('m'):\n      outputType = 'm';\n      j++;\n      break;\n    case T('c'):\n      outputType = 'c';\n      useNamespaces = 0;\n      j++;\n      break;\n    case T('t'):\n      outputType = 't';\n      j++;\n      break;\n    case T('N'):\n      requiresNotations = 1;\n      j++;\n      break;\n    case T('d'):\n      XMLWF_SHIFT_ARG_INTO(outputDir, argc, argv, i, j);\n      break;\n    case T('e'):\n      XMLWF_SHIFT_ARG_INTO(encoding, argc, argv, i, j);\n      break;\n    case T('h'):\n      usage(argv[0], XMLWF_EXIT_SUCCESS);\n      // usage called exit(..), never gets here\n    case T('v'):\n      showVersion(argv[0]);\n      return XMLWF_EXIT_SUCCESS;\n    case T('g'): {\n      const XML_Char *valueText = NULL;\n      XMLWF_SHIFT_ARG_INTO(valueText, argc, argv, i, j);\n\n      errno = 0;\n      XML_Char *afterValueText = (XML_Char *)valueText;\n      const long long read_size_bytes_candidate\n          = tcstoull(valueText, &afterValueText, 10);\n      if ((errno != 0) || (afterValueText[0] != T('\\0'))\n          || (read_size_bytes_candidate < 1)\n          || (read_size_bytes_candidate > (INT_MAX / 2 + 1))) {\n        // This prevents tperror(..) from reporting misleading \"[..]: Success\"\n        errno = ERANGE;\n        tperror(T(\"invalid buffer size\") T(\n            \" (needs an integer from 1 to INT_MAX/2+1 i.e. 1,073,741,824 on most platforms)\"));\n        exit(XMLWF_EXIT_USAGE_ERROR);\n      }\n      g_read_size_bytes = (int)read_size_bytes_candidate;\n      break;\n    }\n    case T('k'):\n      continueOnError = 1;\n      j++;\n      break;\n    case T('a'): {\n      const XML_Char *valueText = NULL;\n      XMLWF_SHIFT_ARG_INTO(valueText, argc, argv, i, j);\n\n      errno = 0;\n      XML_Char *afterValueText = NULL;\n      attackMaximumAmplification = tcstof(valueText, &afterValueText);\n      if ((errno != 0) || (afterValueText[0] != T('\\0'))\n          || isnan(attackMaximumAmplification)\n          || (attackMaximumAmplification < 1.0f)) {\n        // This prevents tperror(..) from reporting misleading \"[..]: Success\"\n        errno = ERANGE;\n        tperror(T(\"invalid amplification limit\") T(\n            \" (needs a floating point number greater or equal than 1.0)\"));\n        exit(XMLWF_EXIT_USAGE_ERROR);\n      }\n#if ! defined(XML_DTD) && XML_GE == 0\n      ftprintf(stderr,\n               T(\"Warning: Given amplification limit ignored\")\n                   T(\", xmlwf has been compiled without DTD/GE support.\\n\"));\n#endif\n      break;\n    }\n    case T('b'): {\n      const XML_Char *valueText = NULL;\n      XMLWF_SHIFT_ARG_INTO(valueText, argc, argv, i, j);\n\n      errno = 0;\n      XML_Char *afterValueText = (XML_Char *)valueText;\n      attackThresholdBytes = tcstoull(valueText, &afterValueText, 10);\n      if ((errno != 0) || (afterValueText[0] != T('\\0'))) {\n        // This prevents tperror(..) from reporting misleading \"[..]: Success\"\n        errno = ERANGE;\n        tperror(T(\"invalid ignore threshold\")\n                    T(\" (needs an integer from 0 to 2^64-1)\"));\n        exit(XMLWF_EXIT_USAGE_ERROR);\n      }\n      attackThresholdGiven = XML_TRUE;\n#if ! defined(XML_DTD) && XML_GE == 0\n      ftprintf(stderr,\n               T(\"Warning: Given attack threshold ignored\")\n                   T(\", xmlwf has been compiled without DTD/GE support.\\n\"));\n#endif\n      break;\n    }\n    case T('\\0'):\n      if (j > 1) {\n        i++;\n        j = 0;\n        break;\n      }\n      /* fall through */\n    default:\n      usage(argv[0], XMLWF_EXIT_USAGE_ERROR);\n      // usage called exit(..), never gets here\n    }\n  }\n  if (i == argc) {\n    useStdin = 1;\n    processFlags &= ~XML_MAP_FILE;\n    i--;\n  }\n  for (; i < argc; i++) {\n    XML_Char *outName = 0;\n    int result;\n    XML_Parser parser;\n    if (useNamespaces)\n      parser = XML_ParserCreateNS(encoding, NSSEP);\n    else\n      parser = XML_ParserCreate(encoding);\n\n    if (! parser) {\n      tperror(T(\"Could not instantiate parser\"));\n      exit(XMLWF_EXIT_INTERNAL_ERROR);\n    }\n\n    if (attackMaximumAmplification != -1.0f) {\n#if defined(XML_DTD) || XML_GE == 1\n      XML_SetBillionLaughsAttackProtectionMaximumAmplification(\n          parser, attackMaximumAmplification);\n#endif\n    }\n    if (attackThresholdGiven) {\n#if defined(XML_DTD) || XML_GE == 1\n      XML_SetBillionLaughsAttackProtectionActivationThreshold(\n          parser, attackThresholdBytes);\n#else\n      (void)attackThresholdBytes; // silence -Wunused-but-set-variable\n#endif\n    }\n\n    if (requireStandalone)\n      XML_SetNotStandaloneHandler(parser, notStandalone);\n    XML_SetParamEntityParsing(parser, paramEntityParsing);\n    if (outputType == 't') {\n      /* This is for doing timings; this gives a more realistic estimate of\n         the parsing time. */\n      outputDir = 0;\n      XML_SetElementHandler(parser, nopStartElement, nopEndElement);\n      XML_SetCharacterDataHandler(parser, nopCharacterData);\n      XML_SetProcessingInstructionHandler(parser, nopProcessingInstruction);\n    } else if (outputDir) {\n      const XML_Char *delim = T(\"/\");\n      const XML_Char *file = useStdin ? T(\"STDIN\") : argv[i];\n      if (! useStdin) {\n        /* Jump after last (back)slash */\n        const XML_Char *lastDelim = tcsrchr(file, delim[0]);\n        if (lastDelim)\n          file = lastDelim + 1;\n#if defined(_WIN32)\n        else {\n          const XML_Char *winDelim = T(\"\\\\\");\n          lastDelim = tcsrchr(file, winDelim[0]);\n          if (lastDelim) {\n            file = lastDelim + 1;\n            delim = winDelim;\n          }\n        }\n#endif\n      }\n      outName = (XML_Char *)malloc((tcslen(outputDir) + tcslen(file) + 2)\n                                   * sizeof(XML_Char));\n      if (! outName) {\n        tperror(T(\"Could not allocate memory\"));\n        exit(XMLWF_EXIT_INTERNAL_ERROR);\n      }\n      tcscpy(outName, outputDir);\n      tcscat(outName, delim);\n      tcscat(outName, file);\n      userData.fp = tfopen(outName, T(\"wb\"));\n      if (! userData.fp) {\n        tperror(outName);\n        exitCode = XMLWF_EXIT_OUTPUT_ERROR;\n        free(outName);\n        XML_ParserFree(parser);\n        if (continueOnError) {\n          continue;\n        } else {\n          break;\n        }\n      }\n      setvbuf(userData.fp, NULL, _IOFBF, 16384);\n#ifdef XML_UNICODE\n      puttc(0xFEFF, userData.fp);\n#endif\n      XML_SetUserData(parser, &userData);\n      switch (outputType) {\n      case 'm':\n        XML_UseParserAsHandlerArg(parser);\n        XML_SetElementHandler(parser, metaStartElement, metaEndElement);\n        XML_SetProcessingInstructionHandler(parser, metaProcessingInstruction);\n        XML_SetCommentHandler(parser, metaComment);\n        XML_SetCdataSectionHandler(parser, metaStartCdataSection,\n                                   metaEndCdataSection);\n        XML_SetCharacterDataHandler(parser, metaCharacterData);\n        XML_SetDoctypeDeclHandler(parser, metaStartDoctypeDecl,\n                                  metaEndDoctypeDecl);\n        XML_SetEntityDeclHandler(parser, metaEntityDecl);\n        XML_SetNotationDeclHandler(parser, metaNotationDecl);\n        XML_SetNamespaceDeclHandler(parser, metaStartNamespaceDecl,\n                                    metaEndNamespaceDecl);\n        metaStartDocument(parser);\n        break;\n      case 'c':\n        XML_UseParserAsHandlerArg(parser);\n        XML_SetDefaultHandler(parser, markup);\n        XML_SetElementHandler(parser, defaultStartElement, defaultEndElement);\n        XML_SetCharacterDataHandler(parser, defaultCharacterData);\n        XML_SetProcessingInstructionHandler(parser,\n                                            defaultProcessingInstruction);\n        break;\n      default:\n        if (useNamespaces)\n          XML_SetElementHandler(parser, startElementNS, endElementNS);\n        else\n          XML_SetElementHandler(parser, startElement, endElement);\n        XML_SetCharacterDataHandler(parser, characterData);\n#ifndef W3C14N\n        XML_SetProcessingInstructionHandler(parser, processingInstruction);\n        if (requiresNotations) {\n          XML_SetDoctypeDeclHandler(parser, startDoctypeDecl, endDoctypeDecl);\n          XML_SetNotationDeclHandler(parser, notationDecl);\n        }\n#endif /* not W3C14N */\n        break;\n      }\n    }\n    if (windowsCodePages)\n      XML_SetUnknownEncodingHandler(parser, unknownEncoding, 0);\n    result = XML_ProcessFile(parser, useStdin ? NULL : argv[i], processFlags);\n    if (outputDir) {\n      if (outputType == 'm')\n        metaEndDocument(parser);\n      fclose(userData.fp);\n      if (! result) {\n        tremove(outName);\n      }\n      free(outName);\n    }\n    XML_ParserFree(parser);\n    if (! result) {\n      exitCode = XMLWF_EXIT_NOT_WELLFORMED;\n      cleanupUserData(&userData);\n      if (! continueOnError) {\n        break;\n      }\n    }\n  }\n  return exitCode;\n}\n"], "filenames": ["expat/CMakeLists.txt", "expat/lib/expat.h", "expat/lib/internal.h", "expat/lib/libexpat.def.cmake", "expat/lib/xmlparse.c", "expat/xmlwf/xmlwf.c"], "buggy_code_start_loc": [406, 1041, 157, 78, 419, 1099], "buggy_code_end_loc": [407, 1048, 158, 80, 8404, 1165], "fixing_code_start_loc": [406, 1041, 157, 78, 419, 1099], "fixing_code_end_loc": [413, 1050, 158, 80, 8407, 1167], "type": "CWE-776", "message": "libexpat through 2.5.0 allows recursive XML Entity Expansion if XML_DTD is undefined at compile time.", "other": {"cve": {"id": "CVE-2023-52426", "sourceIdentifier": "cve@mitre.org", "published": "2024-02-04T20:15:46.120", "lastModified": "2024-03-07T17:15:11.893", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "libexpat through 2.5.0 allows recursive XML Entity Expansion if XML_DTD is undefined at compile time."}, {"lang": "es", "value": "libexpat hasta 2.5.0 permite la expansi\u00f3n recursiva de entidades XML si XML_DTD no est\u00e1 definido en el momento de la compilaci\u00f3n."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-776"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libexpat_project:libexpat:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.5.0", "matchCriteriaId": "1C50909D-8A18-484B-A7DB-7EF4CA67C2CB"}]}]}], "references": [{"url": "https://cwe.mitre.org/data/definitions/776.html", "source": "cve@mitre.org", "tags": ["Technical Description"]}, {"url": "https://github.com/libexpat/libexpat/commit/0f075ec8ecb5e43f8fdca5182f8cca4703da0404", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/libexpat/libexpat/pull/777", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/PNRIHC7DVVRAIWFRGV23Y6UZXFBXSQDB/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/WNUBSGZFEZOBHJFTAD42SAN4ATW2VEMV/", "source": "cve@mitre.org"}, {"url": "https://security.netapp.com/advisory/ntap-20240307-0005/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/libexpat/libexpat/commit/0f075ec8ecb5e43f8fdca5182f8cca4703da0404"}}