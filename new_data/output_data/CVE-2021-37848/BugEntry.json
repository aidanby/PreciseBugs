{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * Copyright (c) 2008-2010 Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>\n */\n\n#include <common.h>\n#include <password.h>\n#include <errno.h>\n#include <readkey.h>\n#include <fs.h>\n#include <fcntl.h>\n#include <digest.h>\n#include <malloc.h>\n#include <xfuncs.h>\n#include <command.h>\n#include <magicvar.h>\n#include <clock.h>\n#include <init.h>\n#include <stdlib.h>\n#include <globalvar.h>\n#include <generated/passwd.h>\n#include <crypto/pbkdf2.h>\n\n#if defined(CONFIG_PASSWD_SUM_MD5)\n#define PASSWD_SUM \"md5\"\n#elif defined(CONFIG_PASSWD_SUM_SHA1)\n#define PASSWD_SUM \"sha1\"\n#elif defined(CONFIG_PASSWD_SUM_SHA256)\n#define PASSWD_SUM \"sha256\"\n#elif defined(CONFIG_PASSWD_SUM_SHA512)\n#define PASSWD_SUM \"sha512\"\n#else\n#define PASSWD_SUM\tNULL\n#endif\n\n#define PBKDF2_SALT_LEN\t32\n#define PBKDF2_LENGTH\t64\n#define PBKDF2_COUNT\t10000\n\nint password(unsigned char *passwd, size_t length, int flags, int timeout)\n{\n\tunsigned char *buf = passwd;\n\tint pos = 0;\n\tunsigned char ch;\n\tuint64_t start;\n\n\tif (!passwd)\n\t\treturn -EINVAL;\n\n\tstart = get_time_ns();\n\n\tdo {\n\t\tif (tstc()) {\n\t\t\tch = getchar();\n\n\t\t\tswitch (ch) {\n\t\t\tcase '\\r':\n\t\t\tcase '\\n':\n\t\t\t\t*buf = '\\0';\n\t\t\t\tputs(\"\\r\\n\");\n\t\t\t\treturn pos;\n\t\t\tcase '\\0':\n\t\t\tcase '\\t':\n\t\t\t\tcontinue;\n\t\t\tcase CTL_CH('c'):\n\t\t\t\tpasswd[0] = '\\0';\n\t\t\t\tputs(\"\\r\\n\");\n\t\t\t\treturn -EINTR;\n\t\t\tcase CTL_CH('h'):\n\t\t\tcase BB_KEY_DEL7:\n\t\t\tcase BB_KEY_DEL:\n\t\t\t\tif (pos > 0) {\n\t\t\t\t\tif (flags & STAR)\n\t\t\t\t\t\tputs(\"\\b \\b\");\n\n\t\t\t\t\t*buf = '\\0';\n\t\t\t\t\tbuf--;\n\t\t\t\t\tpos--;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\tif (pos < length - 1) {\n\t\t\t\t\tif (flags & STAR)\n\t\t\t\t\t\tputchar('*');\n\t\t\t\t\telse if (flags & CLEAR)\n\t\t\t\t\t\tputchar(ch);\n\n\t\t\t\t\t*buf = ch;\n\t\t\t\t\tbuf++;\n\t\t\t\t\tpos++;\n\t\t\t\t} else {\n\t\t\t\t\tif (flags & STAR)\n\t\t\t\t\t\tputchar('\\a');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} while (!is_timeout(start, timeout * SECOND) || timeout == 0);\n\n\treturn -ETIMEDOUT;\n}\nEXPORT_SYMBOL(password);\n\nstatic int is_passwd_default_enable(void)\n{\n\treturn strlen(default_passwd) > 0;\n}\n\nstatic int is_passwd_env_enable(void)\n{\n\tint fd;\n\n\tfd = open(PASSWD_FILE, O_RDONLY);\n\n\tif (fd < 0)\n\t\treturn 0;\n\n\tclose(fd);\n\n\treturn 1;\n}\n\nint passwd_env_disable(void)\n{\n\treturn unlink(PASSWD_FILE);\n}\nEXPORT_SYMBOL(passwd_env_disable);\n\nstatic unsigned char to_digit(unsigned char c)\n{\n\tif (c >= '0' && c <= '9')\n\t\tc -= '0';\n\telse\n\t\tc -= 'a' - 10;\n\n\treturn c;\n}\n\nstatic unsigned char to_hexa(unsigned char c)\n{\n\tif (c < 10)\n\t\tc += '0';\n\telse\n\t\tc += 'a' - 10;\n\n\treturn c;\n}\n\nstatic int read_default_passwd(unsigned char *sum, size_t length)\n{\n\tint i = 0;\n\tint len = strlen(default_passwd);\n\tunsigned char *buf = (unsigned char *)default_passwd;\n\tunsigned char c;\n\n\tif (ARRAY_SIZE(default_passwd) == 1)\n\t\treturn -ENOSYS;\n\n\tif (!sum || length < 1)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < len && length > 0; i++) {\n\t\tc = buf[i];\n\t\ti++;\n\n\t\t*sum = to_digit(c) << 4;\n\n\t\tc = buf[i];\n\n\t\t*sum |= to_digit(c);\n\t\tsum++;\n\t\tlength--;\n\t}\n\n\treturn 0;\n}\n\nstatic int read_env_passwd(unsigned char *sum, size_t length)\n{\n\tint fd;\n\tint ret = 0;\n\tunsigned char c;\n\n\tif (!sum && length < 1)\n\t\treturn -EINVAL;\n\n\tfd = open(PASSWD_FILE, O_RDONLY);\n\n\tif (fd < 0)\n\t\treturn fd;\n\n\tdo {\n\t\tret = read(fd, &c, sizeof(char));\n\n\t\tif (ret < 0)\n\t\t\tgoto exit;\n\n\t\t*sum = to_digit(c) << 4;\n\n\t\tret = read(fd, &c, sizeof(char));\n\n\t\tif (ret < 0)\n\t\t\tgoto exit;\n\n\t\t*sum |= to_digit(c);\n\t\tsum++;\n\t\tlength--;\n\t} while(length > 0);\n\nexit:\n\n\tret = 0;\n\n\tclose(fd);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(read_env_passwd);\n\nstatic int write_env_passwd(unsigned char *sum, size_t length)\n{\n\tint fd;\n\tunsigned char c;\n\tint ret = 0;\n\n\tif (!sum && length < 1)\n\t\treturn -EINVAL;\n\n\tfd = open(PASSWD_DIR, O_RDONLY);\n\n\tif (fd < 0)\n\t\tmkdir(PASSWD_DIR, 644);\n\n\tclose(fd);\n\n\tfd = open(PASSWD_FILE, O_WRONLY | O_CREAT, 600);\n\n\tif (fd < 0)\n\t\treturn fd;\n\n\tdo {\n\t\tc = to_hexa(*sum >> 4 & 0xf);\n\n\t\tret = write(fd, &c, sizeof(unsigned char));\n\n\t\tif (ret < 0)\n\t\t\tgoto exit;\n\n\t\tc = to_hexa(*sum & 0xf);\n\n\t\tret = write(fd, &c, sizeof(unsigned char));\n\n\t\tif (ret < 0)\n\t\t\tgoto exit;\n\n\t\tsum++;\n\t\tlength--;\n\t} while(length > 0);\n\n\tret = 0;\n\nexit:\n\tclose(fd);\n\n\treturn ret;\n}\n\nstatic int check_passwd(unsigned char *passwd, size_t length)\n{\n\tstruct digest *d = NULL;\n\tunsigned char *passwd1_sum;\n\tunsigned char *passwd2_sum;\n\tint ret = 0;\n\tint hash_len;\n\n\tif (IS_ENABLED(CONFIG_PASSWD_CRYPTO_PBKDF2)) {\n\t\thash_len = PBKDF2_LENGTH;\n\t} else {\n\t\td = digest_alloc(PASSWD_SUM);\n\t\tif (!d) {\n\t\t\tpr_err(\"No such digest: %s\\n\",\n\t\t\t       PASSWD_SUM ? PASSWD_SUM : \"NULL\");\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\thash_len = digest_length(d);\n\t}\n\n\tpasswd1_sum = calloc(hash_len * 2, sizeof(unsigned char));\n\tif (!passwd1_sum)\n\t\treturn -ENOMEM;\n\n\tpasswd2_sum = passwd1_sum + hash_len;\n\n\tif (is_passwd_env_enable())\n\t\tret = read_env_passwd(passwd2_sum, hash_len);\n\telse if (is_passwd_default_enable())\n\t\tret = read_default_passwd(passwd2_sum, hash_len);\n\telse\n\t\tret = -EINVAL;\n\n\tif (ret < 0)\n\t\tgoto err;\n\n\tif (IS_ENABLED(CONFIG_PASSWD_CRYPTO_PBKDF2)) {\n\t\tchar *key = passwd2_sum + PBKDF2_SALT_LEN;\n\t\tchar *salt = passwd2_sum;\n\t\tint keylen = PBKDF2_LENGTH - PBKDF2_SALT_LEN;\n\n\t\tret = pkcs5_pbkdf2_hmac_sha1(passwd, length, salt,\n\t\t\tPBKDF2_SALT_LEN, PBKDF2_COUNT, keylen, passwd1_sum);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tif (strncmp(passwd1_sum, key, keylen) == 0)\n\t\t\tret = 1;\n\t} else {\n\t\tret = digest_digest(d, passwd, length, passwd1_sum);\n\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tif (strncmp(passwd1_sum, passwd2_sum, hash_len) == 0)\n\t\t\tret = 1;\n\t}\n\nerr:\n\tfree(passwd1_sum);\n\tdigest_free(d);\n\n\treturn ret;\n}\n\nint set_env_passwd(unsigned char* passwd, size_t length)\n{\n\tstruct digest *d = NULL;\n\tunsigned char *passwd_sum;\n\tint ret, hash_len;\n\n\tif (IS_ENABLED(CONFIG_PASSWD_CRYPTO_PBKDF2)) {\n\t\thash_len = PBKDF2_LENGTH;\n\t} else {\n\t\td = digest_alloc(PASSWD_SUM);\n\t\tif (!d)\n\t\t\treturn -EINVAL;\n\n\t\thash_len = digest_length(d);\n\t}\n\n\tpasswd_sum = calloc(hash_len, sizeof(unsigned char));\n\tif (!passwd_sum)\n\t\treturn -ENOMEM;\n\n\tif (IS_ENABLED(CONFIG_PASSWD_CRYPTO_PBKDF2)) {\n\t\tchar *key = passwd_sum + PBKDF2_SALT_LEN;\n\t\tchar *salt = passwd_sum;\n\t\tint keylen = PBKDF2_LENGTH - PBKDF2_SALT_LEN;\n\n\t\tret = get_crypto_bytes(passwd_sum, PBKDF2_SALT_LEN);\n\t\tif (ret) {\n\t\t\tpr_err(\"Can't get random numbers\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = pkcs5_pbkdf2_hmac_sha1(passwd, length, salt,\n\t\t\t\tPBKDF2_SALT_LEN, PBKDF2_COUNT, keylen, key);\n\t} else {\n\t\tret = digest_digest(d, passwd, length, passwd_sum);\n\t}\n\tif (ret)\n\t\tgoto err;\n\n\tret = write_env_passwd(passwd_sum, hash_len);\n\nerr:\n\tdigest_free(d);\n\tfree(passwd_sum);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(set_env_passwd);\n\n#define PASSWD_MAX_LENGTH\t(128 + 1)\n\n#if defined(CONFIG_PASSWD_MODE_STAR)\n#define LOGIN_MODE STAR\n#elif defined(CONFIG_PASSWD_MODE_CLEAR)\n#define LOGIN_MODE CLEAR\n#else\n#define LOGIN_MODE HIDE\n#endif\n\nstatic int logged_in;\nstatic int login_timeout = 60;\nstatic char *login_fail_command;\n\n/**\n * login() - Prompt for password\n *\n * This function only returns when the correct password has been entered or\n * no password is necessary because either no password is configured or the\n * correct password has been entered in a previous call to this function.\n */\nvoid login(void)\n{\n\tunsigned char passwd[PASSWD_MAX_LENGTH];\n\tint ret;\n\n\tif (!is_passwd_default_enable() && !is_passwd_env_enable())\n\t\treturn;\n\n\tif (logged_in)\n\t\treturn;\n\n\twhile (1) {\n\t\tprintf(\"Password: \");\n\n\t\tret = password(passwd, PASSWD_MAX_LENGTH, LOGIN_MODE, login_timeout);\n\t\tif (ret < 0)\n\t\t\trun_command(login_fail_command);\n\n\t\tif (ret < 0)\n\t\t\tcontinue;\n\n\t\tif (check_passwd(passwd, ret) != 1)\n\t\t\tcontinue;\n\n\t\tlogged_in = 1;\n\t\treturn;\n\t}\n}\n\nstatic int login_global_init(void)\n{\n\tlogin_fail_command = xstrdup(\"boot\");\n\n\tglobalvar_add_simple_int(\"login.timeout\", &login_timeout, \"%d\");\n\tglobalvar_add_simple_string(\"login.fail_command\", &login_fail_command);\n\n\treturn 0;\n}\nlate_initcall(login_global_init);\n\nBAREBOX_MAGICVAR(global.login.fail_command,\n\t\t\"command to run when password entry failed\");\nBAREBOX_MAGICVAR(global.login.timeout,\n\t\t\"timeout to type the password\");\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * Copyright (c) 2008-2010 Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>\n */\n\n#include <common.h>\n#include <password.h>\n#include <errno.h>\n#include <readkey.h>\n#include <fs.h>\n#include <fcntl.h>\n#include <digest.h>\n#include <malloc.h>\n#include <xfuncs.h>\n#include <command.h>\n#include <magicvar.h>\n#include <clock.h>\n#include <init.h>\n#include <stdlib.h>\n#include <globalvar.h>\n#include <crypto.h>\n#include <generated/passwd.h>\n#include <crypto/pbkdf2.h>\n\n#if defined(CONFIG_PASSWD_SUM_MD5)\n#define PASSWD_SUM \"md5\"\n#elif defined(CONFIG_PASSWD_SUM_SHA1)\n#define PASSWD_SUM \"sha1\"\n#elif defined(CONFIG_PASSWD_SUM_SHA256)\n#define PASSWD_SUM \"sha256\"\n#elif defined(CONFIG_PASSWD_SUM_SHA512)\n#define PASSWD_SUM \"sha512\"\n#else\n#define PASSWD_SUM\tNULL\n#endif\n\n#define PBKDF2_SALT_LEN\t32\n#define PBKDF2_LENGTH\t64\n#define PBKDF2_COUNT\t10000\n\nint password(unsigned char *passwd, size_t length, int flags, int timeout)\n{\n\tunsigned char *buf = passwd;\n\tint pos = 0;\n\tunsigned char ch;\n\tuint64_t start;\n\n\tif (!passwd)\n\t\treturn -EINVAL;\n\n\tstart = get_time_ns();\n\n\tdo {\n\t\tif (tstc()) {\n\t\t\tch = getchar();\n\n\t\t\tswitch (ch) {\n\t\t\tcase '\\r':\n\t\t\tcase '\\n':\n\t\t\t\t*buf = '\\0';\n\t\t\t\tputs(\"\\r\\n\");\n\t\t\t\treturn pos;\n\t\t\tcase '\\0':\n\t\t\tcase '\\t':\n\t\t\t\tcontinue;\n\t\t\tcase CTL_CH('c'):\n\t\t\t\tpasswd[0] = '\\0';\n\t\t\t\tputs(\"\\r\\n\");\n\t\t\t\treturn -EINTR;\n\t\t\tcase CTL_CH('h'):\n\t\t\tcase BB_KEY_DEL7:\n\t\t\tcase BB_KEY_DEL:\n\t\t\t\tif (pos > 0) {\n\t\t\t\t\tif (flags & STAR)\n\t\t\t\t\t\tputs(\"\\b \\b\");\n\n\t\t\t\t\t*buf = '\\0';\n\t\t\t\t\tbuf--;\n\t\t\t\t\tpos--;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\tif (pos < length - 1) {\n\t\t\t\t\tif (flags & STAR)\n\t\t\t\t\t\tputchar('*');\n\t\t\t\t\telse if (flags & CLEAR)\n\t\t\t\t\t\tputchar(ch);\n\n\t\t\t\t\t*buf = ch;\n\t\t\t\t\tbuf++;\n\t\t\t\t\tpos++;\n\t\t\t\t} else {\n\t\t\t\t\tif (flags & STAR)\n\t\t\t\t\t\tputchar('\\a');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} while (!is_timeout(start, timeout * SECOND) || timeout == 0);\n\n\treturn -ETIMEDOUT;\n}\nEXPORT_SYMBOL(password);\n\nstatic int is_passwd_default_enable(void)\n{\n\treturn strlen(default_passwd) > 0;\n}\n\nstatic int is_passwd_env_enable(void)\n{\n\tint fd;\n\n\tfd = open(PASSWD_FILE, O_RDONLY);\n\n\tif (fd < 0)\n\t\treturn 0;\n\n\tclose(fd);\n\n\treturn 1;\n}\n\nint passwd_env_disable(void)\n{\n\treturn unlink(PASSWD_FILE);\n}\nEXPORT_SYMBOL(passwd_env_disable);\n\nstatic unsigned char to_digit(unsigned char c)\n{\n\tif (c >= '0' && c <= '9')\n\t\tc -= '0';\n\telse\n\t\tc -= 'a' - 10;\n\n\treturn c;\n}\n\nstatic unsigned char to_hexa(unsigned char c)\n{\n\tif (c < 10)\n\t\tc += '0';\n\telse\n\t\tc += 'a' - 10;\n\n\treturn c;\n}\n\nstatic int read_default_passwd(unsigned char *sum, size_t length)\n{\n\tint i = 0;\n\tint len = strlen(default_passwd);\n\tunsigned char *buf = (unsigned char *)default_passwd;\n\tunsigned char c;\n\n\tif (ARRAY_SIZE(default_passwd) == 1)\n\t\treturn -ENOSYS;\n\n\tif (!sum || length < 1)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < len && length > 0; i++) {\n\t\tc = buf[i];\n\t\ti++;\n\n\t\t*sum = to_digit(c) << 4;\n\n\t\tc = buf[i];\n\n\t\t*sum |= to_digit(c);\n\t\tsum++;\n\t\tlength--;\n\t}\n\n\treturn 0;\n}\n\nstatic int read_env_passwd(unsigned char *sum, size_t length)\n{\n\tint fd;\n\tint ret = 0;\n\tunsigned char c;\n\n\tif (!sum && length < 1)\n\t\treturn -EINVAL;\n\n\tfd = open(PASSWD_FILE, O_RDONLY);\n\n\tif (fd < 0)\n\t\treturn fd;\n\n\tdo {\n\t\tret = read(fd, &c, sizeof(char));\n\n\t\tif (ret < 0)\n\t\t\tgoto exit;\n\n\t\t*sum = to_digit(c) << 4;\n\n\t\tret = read(fd, &c, sizeof(char));\n\n\t\tif (ret < 0)\n\t\t\tgoto exit;\n\n\t\t*sum |= to_digit(c);\n\t\tsum++;\n\t\tlength--;\n\t} while(length > 0);\n\nexit:\n\n\tret = 0;\n\n\tclose(fd);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(read_env_passwd);\n\nstatic int write_env_passwd(unsigned char *sum, size_t length)\n{\n\tint fd;\n\tunsigned char c;\n\tint ret = 0;\n\n\tif (!sum && length < 1)\n\t\treturn -EINVAL;\n\n\tfd = open(PASSWD_DIR, O_RDONLY);\n\n\tif (fd < 0)\n\t\tmkdir(PASSWD_DIR, 644);\n\n\tclose(fd);\n\n\tfd = open(PASSWD_FILE, O_WRONLY | O_CREAT, 600);\n\n\tif (fd < 0)\n\t\treturn fd;\n\n\tdo {\n\t\tc = to_hexa(*sum >> 4 & 0xf);\n\n\t\tret = write(fd, &c, sizeof(unsigned char));\n\n\t\tif (ret < 0)\n\t\t\tgoto exit;\n\n\t\tc = to_hexa(*sum & 0xf);\n\n\t\tret = write(fd, &c, sizeof(unsigned char));\n\n\t\tif (ret < 0)\n\t\t\tgoto exit;\n\n\t\tsum++;\n\t\tlength--;\n\t} while(length > 0);\n\n\tret = 0;\n\nexit:\n\tclose(fd);\n\n\treturn ret;\n}\n\nstatic int check_passwd(unsigned char *passwd, size_t length)\n{\n\tstruct digest *d = NULL;\n\tunsigned char *passwd1_sum;\n\tunsigned char *passwd2_sum;\n\tint ret = 0;\n\tint hash_len;\n\n\tif (IS_ENABLED(CONFIG_PASSWD_CRYPTO_PBKDF2)) {\n\t\thash_len = PBKDF2_LENGTH;\n\t} else {\n\t\td = digest_alloc(PASSWD_SUM);\n\t\tif (!d) {\n\t\t\tpr_err(\"No such digest: %s\\n\",\n\t\t\t       PASSWD_SUM ? PASSWD_SUM : \"NULL\");\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\thash_len = digest_length(d);\n\t}\n\n\tpasswd1_sum = calloc(hash_len * 2, sizeof(unsigned char));\n\tif (!passwd1_sum)\n\t\treturn -ENOMEM;\n\n\tpasswd2_sum = passwd1_sum + hash_len;\n\n\tif (is_passwd_env_enable())\n\t\tret = read_env_passwd(passwd2_sum, hash_len);\n\telse if (is_passwd_default_enable())\n\t\tret = read_default_passwd(passwd2_sum, hash_len);\n\telse\n\t\tret = -EINVAL;\n\n\tif (ret < 0)\n\t\tgoto err;\n\n\tif (IS_ENABLED(CONFIG_PASSWD_CRYPTO_PBKDF2)) {\n\t\tchar *key = passwd2_sum + PBKDF2_SALT_LEN;\n\t\tchar *salt = passwd2_sum;\n\t\tint keylen = PBKDF2_LENGTH - PBKDF2_SALT_LEN;\n\n\t\tret = pkcs5_pbkdf2_hmac_sha1(passwd, length, salt,\n\t\t\tPBKDF2_SALT_LEN, PBKDF2_COUNT, keylen, passwd1_sum);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tif (!crypto_memneq(passwd1_sum, key, keylen))\n\t\t\tret = 1;\n\t} else {\n\t\tret = digest_digest(d, passwd, length, passwd1_sum);\n\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tif (!crypto_memneq(passwd1_sum, passwd2_sum, hash_len))\n\t\t\tret = 1;\n\t}\n\nerr:\n\tfree(passwd1_sum);\n\tdigest_free(d);\n\n\treturn ret;\n}\n\nint set_env_passwd(unsigned char* passwd, size_t length)\n{\n\tstruct digest *d = NULL;\n\tunsigned char *passwd_sum;\n\tint ret, hash_len;\n\n\tif (IS_ENABLED(CONFIG_PASSWD_CRYPTO_PBKDF2)) {\n\t\thash_len = PBKDF2_LENGTH;\n\t} else {\n\t\td = digest_alloc(PASSWD_SUM);\n\t\tif (!d)\n\t\t\treturn -EINVAL;\n\n\t\thash_len = digest_length(d);\n\t}\n\n\tpasswd_sum = calloc(hash_len, sizeof(unsigned char));\n\tif (!passwd_sum)\n\t\treturn -ENOMEM;\n\n\tif (IS_ENABLED(CONFIG_PASSWD_CRYPTO_PBKDF2)) {\n\t\tchar *key = passwd_sum + PBKDF2_SALT_LEN;\n\t\tchar *salt = passwd_sum;\n\t\tint keylen = PBKDF2_LENGTH - PBKDF2_SALT_LEN;\n\n\t\tret = get_crypto_bytes(passwd_sum, PBKDF2_SALT_LEN);\n\t\tif (ret) {\n\t\t\tpr_err(\"Can't get random numbers\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = pkcs5_pbkdf2_hmac_sha1(passwd, length, salt,\n\t\t\t\tPBKDF2_SALT_LEN, PBKDF2_COUNT, keylen, key);\n\t} else {\n\t\tret = digest_digest(d, passwd, length, passwd_sum);\n\t}\n\tif (ret)\n\t\tgoto err;\n\n\tret = write_env_passwd(passwd_sum, hash_len);\n\nerr:\n\tdigest_free(d);\n\tfree(passwd_sum);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(set_env_passwd);\n\n#define PASSWD_MAX_LENGTH\t(128 + 1)\n\n#if defined(CONFIG_PASSWD_MODE_STAR)\n#define LOGIN_MODE STAR\n#elif defined(CONFIG_PASSWD_MODE_CLEAR)\n#define LOGIN_MODE CLEAR\n#else\n#define LOGIN_MODE HIDE\n#endif\n\nstatic int logged_in;\nstatic int login_timeout = 60;\nstatic char *login_fail_command;\n\n/**\n * login() - Prompt for password\n *\n * This function only returns when the correct password has been entered or\n * no password is necessary because either no password is configured or the\n * correct password has been entered in a previous call to this function.\n */\nvoid login(void)\n{\n\tunsigned char passwd[PASSWD_MAX_LENGTH];\n\tint ret;\n\n\tif (!is_passwd_default_enable() && !is_passwd_env_enable())\n\t\treturn;\n\n\tif (logged_in)\n\t\treturn;\n\n\twhile (1) {\n\t\tprintf(\"Password: \");\n\n\t\tret = password(passwd, PASSWD_MAX_LENGTH, LOGIN_MODE, login_timeout);\n\t\tif (ret < 0)\n\t\t\trun_command(login_fail_command);\n\n\t\tif (ret < 0)\n\t\t\tcontinue;\n\n\t\tif (check_passwd(passwd, ret) != 1)\n\t\t\tcontinue;\n\n\t\tlogged_in = 1;\n\t\treturn;\n\t}\n}\n\nstatic int login_global_init(void)\n{\n\tlogin_fail_command = xstrdup(\"boot\");\n\n\tglobalvar_add_simple_int(\"login.timeout\", &login_timeout, \"%d\");\n\tglobalvar_add_simple_string(\"login.fail_command\", &login_fail_command);\n\n\treturn 0;\n}\nlate_initcall(login_global_init);\n\nBAREBOX_MAGICVAR(global.login.fail_command,\n\t\t\"command to run when password entry failed\");\nBAREBOX_MAGICVAR(global.login.timeout,\n\t\t\"timeout to type the password\");\n"], "filenames": ["common/password.c"], "buggy_code_start_loc": [20], "buggy_code_end_loc": [323], "fixing_code_start_loc": [21], "fixing_code_end_loc": [324], "type": "CWE-203", "message": "common/password.c in Pengutronix barebox through 2021.07.0 leaks timing information because strncmp is used during hash comparison.", "other": {"cve": {"id": "CVE-2021-37848", "sourceIdentifier": "cve@mitre.org", "published": "2021-08-02T20:15:08.303", "lastModified": "2022-07-12T17:42:04.277", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "common/password.c in Pengutronix barebox through 2021.07.0 leaks timing information because strncmp is used during hash comparison."}, {"lang": "es", "value": "Un archivo common/password.c en Pengutronix barebox versiones hasta 2021.07.0 filtra informaci\u00f3n de tiempo porque strncmp es usado durante la comparaci\u00f3n del hash"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-203"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pengutronix:barebox:*:*:*:*:*:*:*:*", "versionEndIncluding": "2021.07.0", "matchCriteriaId": "B46A4C74-4467-476A-AEFB-8A31E39E605F"}]}]}], "references": [{"url": "https://gist.github.com/gquere/816dfadbad98745090034100a8a651eb", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/saschahauer/barebox/commit/a3337563c705bc8e0cf32f910b3e9e3c43d962ff", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/saschahauer/barebox/commit/a3337563c705bc8e0cf32f910b3e9e3c43d962ff"}}