{"buggy_code": ["<?php\n/*\n * Functions relative to short URLs: adding, editing, etc\n * (either proper short URLs (\"http://sho.rt/abc\") or \"keywords\" (the \"abc\" part)\n */\n\n\n/**\n * Add a new link in the DB, either with custom keyword, or find one\n *\n * The return array will contain at least the following keys:\n *    status: string, 'success' or 'fail'\n *    message: string, a descriptive localized message of what happened in any case\n *    code: string, a short descriptivish and untranslated message describing what happened\n *\n * Depending on the operation, it will contain any of the following keys:\n *    errorCode: string, a HTTP status code\n *    url: array, the short URL creation information, with the following keys: 'keyword', 'url', 'title', 'date', 'ip'\n *    title: string, the URL title\n *    shorturl: string, the proper short URL in full (eg 'http://sho.rt/abc')\n *    html: string, the HTML part used by the ajax to update the page display if any\n *\n * @param  string $url      URL to shorten\n * @param  string $keyword  optional \"keyword\"\n * @param  string $title    option title\n * @return array            array with error/success state and short URL information\n */\nfunction yourls_add_new_link( $url, $keyword = '', $title = '' ) {\n    // Allow plugins to short-circuit the whole function\n    $pre = yourls_apply_filter( 'shunt_add_new_link', false, $url, $keyword, $title );\n    if ( false !== $pre )\n        return $pre;\n\n    $url = yourls_sanitize_url( $url );\n    if ( !$url || $url == 'http://' || $url == 'https://' ) {\n        $return['status']    = 'fail';\n        $return['code']      = 'error:nourl';\n        $return['message']   = yourls__( 'Missing or malformed URL' );\n        $return['errorCode'] = '400';\n        return yourls_apply_filter( 'add_new_link_fail_nourl', $return, $url, $keyword, $title );\n    }\n\n    // Prevent DB flood\n    $ip = yourls_get_IP();\n    yourls_check_IP_flood( $ip );\n\n    // Prevent internal redirection loops: cannot shorten a shortened URL\n    if( yourls_get_relative_url( $url ) ) {\n        if( yourls_is_shorturl( $url ) ) {\n            $return['status']    = 'fail';\n            $return['code']      = 'error:noloop';\n            $return['message']   = yourls__( 'URL is a short URL' );\n            $return['errorCode'] = '400';\n            return yourls_apply_filter( 'add_new_link_fail_noloop', $return, $url, $keyword, $title );\n        }\n    }\n\n    yourls_do_action( 'pre_add_new_link', $url, $keyword, $title );\n\n    $return = array();\n\n    // duplicates allowed or new URL => store it\n    if( yourls_allow_duplicate_longurls() || !( $url_exists = yourls_long_url_exists( $url ) ) ) {\n\n        if( isset( $title ) && !empty( $title ) ) {\n            $title = yourls_sanitize_title( $title );\n        } else {\n            $title = yourls_get_remote_title( $url );\n        }\n        $title = yourls_apply_filter( 'add_new_title', $title, $url, $keyword );\n\n        // Custom keyword provided\n        if ( $keyword ) {\n\n            yourls_do_action( 'add_new_link_custom_keyword', $url, $keyword, $title );\n\n            $keyword = yourls_sanitize_keyword( $keyword, true );\n            $keyword = yourls_apply_filter( 'custom_keyword', $keyword, $url, $title );\n\n            if ( !yourls_keyword_is_free( $keyword ) ) {\n                // This shorturl either reserved or taken already\n                $return['status']  = 'fail';\n                $return['code']    = 'error:keyword';\n                $return['message'] = yourls_s( 'Short URL %s already exists in database or is reserved', $keyword );\n            } else {\n                // all clear, store !\n                yourls_insert_link_in_db( $url, $keyword, $title );\n                $return['url']      = array('keyword' => $keyword, 'url' => $url, 'title' => $title, 'date' => date('Y-m-d H:i:s'), 'ip' => $ip );\n                $return['status']   = 'success';\n                $return['message']  = /* //translators: eg \"http://someurl/ added to DB\" */ yourls_s( '%s added to database', yourls_trim_long_string( $url ) );\n                $return['title']    = $title;\n                $return['html']     = yourls_table_add_row( $keyword, $url, $title, $ip, 0, time() );\n                $return['shorturl'] = yourls_link($keyword);\n            }\n\n        // Create random keyword\n        } else {\n\n            yourls_do_action( 'add_new_link_create_keyword', $url, $keyword, $title );\n\n            $timestamp = date( 'Y-m-d H:i:s' );\n            $id = yourls_get_next_decimal();\n            $ok = false;\n            do {\n                $keyword = yourls_int2string( $id );\n                $keyword = yourls_apply_filter( 'random_keyword', $keyword, $url, $title );\n                if ( yourls_keyword_is_free($keyword) ) {\n                    if (yourls_insert_link_in_db( $url, $keyword, $title )){\n                        // everything ok, populate needed vars\n                        $return['url']      = array('keyword' => $keyword, 'url' => $url, 'title' => $title, 'date' => $timestamp, 'ip' => $ip );\n                        $return['status']   = 'success';\n                        $return['message']  = /* //translators: eg \"http://someurl/ added to DB\" */ yourls_s( '%s added to database', yourls_trim_long_string( $url ) );\n                        $return['title']    = $title;\n                        $return['html']     = yourls_table_add_row( $keyword, $url, $title, $ip, 0, time() );\n                        $return['shorturl'] = yourls_link($keyword);\n                    } else {\n                        // database error, couldnt store result\n                        $return['status']   = 'fail';\n                        $return['code']     = 'error:db';\n                        $return['message']  = yourls_s( 'Error saving url to database' );\n                    }\n                    $ok = true;\n                }\n                $id++;\n            } while ( !$ok );\n            @yourls_update_next_decimal( $id );\n        }\n\n    // URL was already stored\n    } else {\n\n        yourls_do_action( 'add_new_link_already_stored', $url, $keyword, $title );\n\n        $return['status']   = 'fail';\n        $return['code']     = 'error:url';\n        $return['url']      = array( 'keyword' => $url_exists->keyword, 'url' => $url, 'title' => $url_exists->title, 'date' => $url_exists->timestamp, 'ip' => $url_exists->ip, 'clicks' => $url_exists->clicks );\n        $return['message']  = /* //translators: eg \"http://someurl/ already exists\" */ yourls_s( '%s already exists in database', yourls_trim_long_string( $url ) );\n        $return['title']    = $url_exists->title;\n        $return['shorturl'] = yourls_link($url_exists->keyword);\n    }\n\n    yourls_do_action( 'post_add_new_link', $url, $keyword, $title, $return );\n\n    $return['statusCode'] = 200; // regardless of result, this is still a valid request\n    return yourls_apply_filter( 'add_new_link', $return, $url, $keyword, $title );\n}\n\n/**\n * Determine the allowed character set in short URLs\n *\n * @return string    Acceptable charset for short URLS keywords\n */\nfunction yourls_get_shorturl_charset() {\n    static $charset = null;\n    if ( $charset !== null ) {\n        return $charset;\n    }\n\n    if ( defined( 'YOURLS_URL_CONVERT' ) && in_array( YOURLS_URL_CONVERT, [ 62, 64 ] ) ) {\n        $charset = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n    }\n    else {\n        // defined to 36, or wrongly defined\n        $charset = '0123456789abcdefghijklmnopqrstuvwxyz';\n    }\n\n    return yourls_apply_filter( 'get_shorturl_charset', $charset );\n}\n\n/**\n * Is a URL a short URL? Accept either 'http://sho.rt/abc' or 'abc'\n *\n * @param  string $shorturl   short URL\n * @return bool               true if registered short URL, false otherwise\n */\nfunction yourls_is_shorturl( $shorturl ) {\n    // TODO: make sure this function evolves with the feature set.\n\n    $is_short = false;\n\n    // Is $shorturl a URL (http://sho.rt/abc) or a keyword (abc) ?\n    if( yourls_get_protocol( $shorturl ) ) {\n        $keyword = yourls_get_relative_url( $shorturl );\n    } else {\n        $keyword = $shorturl;\n    }\n\n    // Check if it's a valid && used keyword\n    if( $keyword && $keyword == yourls_sanitize_keyword( $keyword ) && yourls_keyword_is_taken( $keyword ) ) {\n        $is_short = true;\n    }\n\n    return yourls_apply_filter( 'is_shorturl', $is_short, $shorturl );\n}\n\n/**\n * Check to see if a given keyword is reserved (ie reserved URL or an existing page). Returns bool\n *\n * @param  string $keyword   Short URL keyword\n * @return bool              True if keyword reserved, false if free to be used\n */\nfunction yourls_keyword_is_reserved( $keyword ) {\n    global $yourls_reserved_URL;\n    $keyword = yourls_sanitize_keyword( $keyword );\n    $reserved = false;\n\n    if ( in_array( $keyword, $yourls_reserved_URL)\n        or yourls_is_page($keyword)\n        or is_dir( YOURLS_ABSPATH .\"/$keyword\" )\n    )\n        $reserved = true;\n\n    return yourls_apply_filter( 'keyword_is_reserved', $reserved, $keyword );\n}\n\n/**\n * Delete a link in the DB\n *\n */\nfunction yourls_delete_link_by_keyword( $keyword ) {\n    // Allow plugins to short-circuit the whole function\n    $pre = yourls_apply_filter( 'shunt_delete_link_by_keyword', null, $keyword );\n    if ( null !== $pre ) {\n        return $pre;\n    }\n\n    $table = YOURLS_DB_TABLE_URL;\n    $keyword = yourls_sanitize_keyword($keyword);\n    $delete = yourls_get_db()->fetchAffected(\"DELETE FROM `$table` WHERE `keyword` = :keyword\", array('keyword' => $keyword));\n    yourls_do_action( 'delete_link', $keyword, $delete );\n    return $delete;\n}\n\n/**\n * SQL query to insert a new link in the DB. Returns boolean for success or failure of the inserting\n *\n */\nfunction yourls_insert_link_in_db( $url, $keyword, $title = '' ) {\n    $url       = yourls_sanitize_url($url);\n    $keyword   = yourls_sanitize_keyword($keyword);\n    $title     = yourls_sanitize_title($title);\n    $timestamp = date('Y-m-d H:i:s');\n    $ip        = yourls_get_IP();\n\n    $table = YOURLS_DB_TABLE_URL;\n    $binds = array(\n        'keyword'   => $keyword,\n        'url'       => $url,\n        'title'     => $title,\n        'timestamp' => $timestamp,\n        'ip'        => $ip,\n    );\n    $insert = yourls_get_db()->fetchAffected(\"INSERT INTO `$table` (`keyword`, `url`, `title`, `timestamp`, `ip`, `clicks`) VALUES(:keyword, :url, :title, :timestamp, :ip, 0);\", $binds);\n\n    yourls_do_action( 'insert_link', (bool)$insert, $url, $keyword, $title, $timestamp, $ip );\n\n    return (bool)$insert;\n}\n\n/**\n * Check if a long URL already exists in the DB. Return NULL (doesn't exist) or an object with URL informations.\n *\n * This function supersedes function yourls_url_exists(), deprecated in 1.7.10, with a better naming.\n *\n * @since 1.7.10\n * @param  string $url  URL to check if already shortened\n * @return mixed        NULL if does not already exist in DB, or object with URL information as properties (eg keyword, url, title, ...)\n */\nfunction yourls_long_url_exists( $url ) {\n    // Allow plugins to short-circuit the whole function\n    $pre = yourls_apply_filter( 'shunt_url_exists', false, $url );\n    if ( false !== $pre ) {\n        return $pre;\n    }\n\n    $table = YOURLS_DB_TABLE_URL;\n    $url   = yourls_sanitize_url($url);\n    $url_exists = yourls_get_db()->fetchObject(\"SELECT * FROM `$table` WHERE `url` = :url\", array('url'=>$url));\n\n    if ($url_exists === false) {\n        $url_exists = NULL;\n    }\n\n    return yourls_apply_filter( 'url_exists', $url_exists, $url );\n}\n\n/**\n * Edit a link\n *\n */\nfunction yourls_edit_link( $url, $keyword, $newkeyword='', $title='' ) {\n    // Allow plugins to short-circuit the whole function\n    $pre = yourls_apply_filter( 'shunt_edit_link', null, $keyword, $url, $keyword, $newkeyword, $title );\n    if ( null !== $pre )\n        return $pre;\n\n    $ydb = yourls_get_db();\n\n    $table = YOURLS_DB_TABLE_URL;\n    $url = yourls_sanitize_url($url);\n    $keyword = yourls_sanitize_keyword($keyword);\n    $title = yourls_sanitize_title($title);\n    $newkeyword = yourls_sanitize_keyword($newkeyword, true);\n    $strip_url = stripslashes( $url );\n    $strip_title = stripslashes( $title );\n\n    if(!$url OR !$newkeyword) {\n        $return['status']  = 'fail';\n        $return['message'] = yourls__( 'Long URL or Short URL cannot be blank' );\n        return yourls_apply_filter( 'edit_link', $return, $url, $keyword, $newkeyword, $title );\n    }\n\n    $old_url = $ydb->fetchValue(\"SELECT `url` FROM `$table` WHERE `keyword` = :keyword\", array('keyword' => $keyword));\n\n    // Check if new URL is not here already\n    if ( $old_url != $url && !yourls_allow_duplicate_longurls() ) {\n        $new_url_already_there = intval($ydb->fetchValue(\"SELECT COUNT(keyword) FROM `$table` WHERE `url` = :url;\", array('url' => $url)));\n    } else {\n        $new_url_already_there = false;\n    }\n\n    // Check if the new keyword is not here already\n    if ( $newkeyword != $keyword ) {\n        $keyword_is_ok = yourls_keyword_is_free( $newkeyword );\n    } else {\n        $keyword_is_ok = true;\n    }\n\n    yourls_do_action( 'pre_edit_link', $url, $keyword, $newkeyword, $new_url_already_there, $keyword_is_ok );\n\n    // All clear, update\n    if ( ( !$new_url_already_there || yourls_allow_duplicate_longurls() ) && $keyword_is_ok ) {\n            $sql   = \"UPDATE `$table` SET `url` = :url, `keyword` = :newkeyword, `title` = :title WHERE `keyword` = :keyword\";\n            $binds = array('url' => $url, 'newkeyword' => $newkeyword, 'title' => $title, 'keyword' => $keyword);\n            $update_url = $ydb->fetchAffected($sql, $binds);\n        if( $update_url ) {\n            $return['url']     = array( 'keyword' => $newkeyword, 'shorturl' => yourls_link($newkeyword), 'url' => $strip_url, 'display_url' => yourls_trim_long_string( $strip_url ), 'title' => $strip_title, 'display_title' => yourls_trim_long_string( $strip_title ) );\n            $return['status']  = 'success';\n            $return['message'] = yourls__( 'Link updated in database' );\n        } else {\n            $return['status']  = 'fail';\n            $return['message'] = /* //translators: \"Error updating http://someurl/ (Shorturl: http://sho.rt/blah)\" */ yourls_s( 'Error updating %s (Short URL: %s)', yourls_trim_long_string( $strip_url ), $keyword ) ;\n        }\n\n    // Nope\n    } else {\n        $return['status']  = 'fail';\n        $return['message'] = yourls__( 'URL or keyword already exists in database' );\n    }\n\n    return yourls_apply_filter( 'edit_link', $return, $url, $keyword, $newkeyword, $title, $new_url_already_there, $keyword_is_ok );\n}\n\n/**\n * Update a title link (no checks for duplicates etc..)\n *\n */\nfunction yourls_edit_link_title( $keyword, $title ) {\n    // Allow plugins to short-circuit the whole function\n    $pre = yourls_apply_filter( 'shunt_edit_link_title', null, $keyword, $title );\n    if ( null !== $pre ) {\n        return $pre;\n    }\n\n    $keyword = yourls_sanitize_keyword( $keyword );\n    $title = yourls_sanitize_title( $title );\n\n    $table = YOURLS_DB_TABLE_URL;\n    $update = yourls_get_db()->fetchAffected(\"UPDATE `$table` SET `title` = :title WHERE `keyword` = :keyword;\", array('title' => $title, 'keyword' => $keyword));\n\n    return $update;\n}\n\n/**\n * Check if keyword id is free (ie not already taken, and not reserved). Return bool.\n *\n * @param  string $keyword    short URL keyword\n * @return bool               true if keyword is taken (ie there is a short URL for it), false otherwise\n */\nfunction yourls_keyword_is_free( $keyword  ) {\n    $free = true;\n    if ( yourls_keyword_is_reserved( $keyword ) or yourls_keyword_is_taken( $keyword, false ) ) {\n        $free = false;\n    }\n\n    return yourls_apply_filter( 'keyword_is_free', $free, $keyword );\n}\n\n/**\n * Check if a keyword matches a \"page\"\n *\n * @see https://github.com/YOURLS/YOURLS/wiki/Pages\n * @since 1.7.10\n * @param  string $keyword  Short URL $keyword\n * @return bool             true if is page, false otherwise\n */\nfunction yourls_is_page($keyword) {\n    return yourls_apply_filter( 'is_page', file_exists( YOURLS_PAGEDIR . \"/$keyword.php\" ) );\n}\n\n/**\n * Check if a keyword is taken (ie there is already a short URL with this id). Return bool.\n *\n */\n/**\n * Check if a keyword is taken (ie there is already a short URL with this id). Return bool.\n *\n * @param  string $keyword    short URL keyword\n * @param  bool   $use_cache  optional, default true: do we want to use what is cached in memory, if any, or force a new SQL query\n * @return bool               true if keyword is taken (ie there is a short URL for it), false otherwise\n */\nfunction yourls_keyword_is_taken( $keyword, $use_cache = true ) {\n    // Allow plugins to short-circuit the whole function\n    $pre = yourls_apply_filter( 'shunt_keyword_is_taken', false, $keyword );\n    if ( false !== $pre ) {\n        return $pre;\n    }\n\n    $taken = false;\n    // To check if a keyword is already associated with a short URL, we fetch all info matching that keyword. This\n    // will save a query in case of a redirection in yourls-go.php because info will be cached\n    if ( yourls_get_keyword_infos($keyword, $use_cache) ) {\n        $taken = true;\n    }\n\n    return yourls_apply_filter( 'keyword_is_taken', $taken, $keyword );\n}\n\n/**\n * Return array of all information associated with keyword. Returns false if keyword not found. Set optional $use_cache to false to force fetching from DB\n *\n * Sincere apologies to native English speakers, we are aware that the plural of 'info' is actually 'info', not 'infos'.\n * This function yourls_get_keyword_infos() returns all information, while function yourls_get_keyword_info() (no 's') return only\n * one information. Blame YOURLS contributors whose mother tongue is not English :)\n *\n * @since 1.4\n * @param  string $keyword    Short URL keyword\n * @param  bool   $use_cache  Default true, set to false to force fetching from DB\n * @return false|object       false if not found, object with URL properties if found\n */\nfunction yourls_get_keyword_infos( $keyword, $use_cache = true ) {\n    $ydb = yourls_get_db();\n    $keyword = yourls_sanitize_keyword( $keyword );\n\n    yourls_do_action( 'pre_get_keyword', $keyword, $use_cache );\n\n    if( $ydb->has_infos($keyword) && $use_cache === true ) {\n        return yourls_apply_filter( 'get_keyword_infos', $ydb->get_infos($keyword), $keyword );\n    }\n\n    yourls_do_action( 'get_keyword_not_cached', $keyword );\n\n    $table = YOURLS_DB_TABLE_URL;\n    $infos = $ydb->fetchObject(\"SELECT * FROM `$table` WHERE `keyword` = :keyword\", array('keyword' => $keyword));\n\n    if( $infos ) {\n        $infos = (array)$infos;\n        $ydb->set_infos($keyword, $infos);\n    } else {\n        // is NULL if not found\n        $infos = false;\n        $ydb->set_infos($keyword, false);\n    }\n\n    return yourls_apply_filter( 'get_keyword_infos', $infos, $keyword );\n}\n\n/**\n * Return (string) selected information associated with a keyword. Optional $notfound = string default message if nothing found\n *\n */\nfunction yourls_get_keyword_info( $keyword, $field, $notfound = false ) {\n\n    // Allow plugins to short-circuit the whole function\n    $pre = yourls_apply_filter( 'shunt_get_keyword_info', false, $keyword, $field, $notfound );\n    if ( false !== $pre )\n        return $pre;\n\n    $keyword = yourls_sanitize_keyword( $keyword );\n    $infos = yourls_get_keyword_infos( $keyword );\n\n    $return = $notfound;\n    if ( isset( $infos[ $field ] ) && $infos[ $field ] !== false )\n        $return = $infos[ $field ];\n\n    return yourls_apply_filter( 'get_keyword_info', $return, $keyword, $field, $notfound );\n}\n\n/**\n * Return title associated with keyword. Optional $notfound = string default message if nothing found\n *\n */\nfunction yourls_get_keyword_title( $keyword, $notfound = false ) {\n    return yourls_get_keyword_info( $keyword, 'title', $notfound );\n}\n\n/**\n * Return long URL associated with keyword. Optional $notfound = string default message if nothing found\n *\n */\nfunction yourls_get_keyword_longurl( $keyword, $notfound = false ) {\n    return yourls_get_keyword_info( $keyword, 'url', $notfound );\n}\n\n/**\n * Return number of clicks on a keyword. Optional $notfound = string default message if nothing found\n *\n */\nfunction yourls_get_keyword_clicks( $keyword, $notfound = false ) {\n    return yourls_get_keyword_info( $keyword, 'clicks', $notfound );\n}\n\n/**\n * Return IP that added a keyword. Optional $notfound = string default message if nothing found\n *\n */\nfunction yourls_get_keyword_IP( $keyword, $notfound = false ) {\n    return yourls_get_keyword_info( $keyword, 'ip', $notfound );\n}\n\n/**\n * Return timestamp associated with a keyword. Optional $notfound = string default message if nothing found\n *\n */\nfunction yourls_get_keyword_timestamp( $keyword, $notfound = false ) {\n    return yourls_get_keyword_info( $keyword, 'timestamp', $notfound );\n}\n\n/**\n * Return array of stats for a given keyword\n *\n * This function supersedes function yourls_get_link_stats(), deprecated in 1.7.10, with a better naming.\n *\n * @since 1.7.10\n * @param  string $shorturl short URL keyword\n * @return array            stats\n */\nfunction yourls_get_keyword_stats( $shorturl ) {\n    $table_url = YOURLS_DB_TABLE_URL;\n    $shorturl  = yourls_sanitize_keyword( $shorturl );\n\n    $res = yourls_get_db()->fetchObject(\"SELECT * FROM `$table_url` WHERE `keyword` = :keyword\", array('keyword' => $shorturl));\n    $return = array();\n\n    if( !$res ) {\n        // non existent link\n        $return = array(\n            'statusCode' => 404,\n            'message'    => 'Error: short URL not found',\n        );\n    } else {\n        $return = array(\n            'statusCode' => 200,\n            'message'    => 'success',\n            'link'       => array(\n                'shorturl' => yourls_link($res->keyword),\n                'url'      => $res->url,\n                'title'    => $res->title,\n                'timestamp'=> $res->timestamp,\n                'ip'       => $res->ip,\n                'clicks'   => $res->clicks,\n            )\n        );\n    }\n\n    return yourls_apply_filter( 'get_link_stats', $return, $shorturl );\n}\n\n/**\n * Return array of keywords that redirect to the submitted long URL\n *\n * @since 1.7\n * @param string $longurl long url\n * @param string $order Optional SORT order (can be 'ASC' or 'DESC')\n * @return array array of keywords\n */\nfunction yourls_get_longurl_keywords( $longurl, $order = 'ASC' ) {\n    $longurl = yourls_sanitize_url($longurl);\n    $table   = YOURLS_DB_TABLE_URL;\n    $sql     = \"SELECT `keyword` FROM `$table` WHERE `url` = :url\";\n\n    if (in_array($order, array('ASC','DESC'))) {\n        $sql .= \" ORDER BY `keyword` \".$order;\n    }\n\n    return yourls_apply_filter( 'get_longurl_keywords', yourls_get_db()->fetchCol($sql, array('url'=>$longurl)), $longurl );\n}\n", "<?php\n\n/**\n * Short URL tests\n *\n * @group shorturls\n * @since 0.1\n */\n\nclass ShortURL_Tests extends PHPUnit\\Framework\\TestCase {\n\n    public function test_reserved_keywords() {\n        global $yourls_reserved_URL;\n        $reserved = $yourls_reserved_URL[ array_rand( $yourls_reserved_URL, 1 )  ];\n        $this->assertTrue( yourls_keyword_is_reserved( $reserved ) );\n        $this->assertFalse( yourls_keyword_is_reserved( rand_str() ) );\n    }\n\n    public function test_free_keywords() {\n        global $yourls_reserved_URL;\n        $reserved = $yourls_reserved_URL[ array_rand( $yourls_reserved_URL, 1 )  ];\n        $this->assertFalse( yourls_keyword_is_free( $reserved ) );\n        $this->assertFalse( yourls_keyword_is_free( 'ozh' ) );\n        $this->assertTrue( yourls_keyword_is_free( rand_str() ) );\n    }\n\n    public function test_url_exists() {\n        $exists = yourls_long_url_exists( 'http://ozh.org/' );\n        $this->assertEquals( 'ozh', $exists->keyword );\n        $this->assertNull( yourls_long_url_exists( rand_str() ) );\n    }\n\n    public function test_add_url() {\n        $keyword = rand_str();\n        $title   = rand_str();\n        $url     = 'http://' . rand_str();\n\n        $newurl = yourls_add_new_link( $url, $keyword, $title );\n        $this->assertEquals( 'success', $newurl['status'] );\n\n        $fail = yourls_add_new_link( $url, $keyword, $title );\n        $this->assertEquals( 'fail', $fail['status'] );\n        $this->assertEquals( 'error:url', $fail['code'] );\n\n        $fail = yourls_add_new_link( 'http://' . rand_str(), $keyword, $title );\n        $this->assertEquals( 'fail', $fail['status'] );\n        $this->assertEquals( 'error:keyword', $fail['code'] );\n\n        $this->assertEquals( $title, yourls_get_keyword_title( $keyword ) );\n        $this->assertEquals( $url, yourls_get_keyword_longurl( $keyword ) );\n        $this->assertEquals( 0, yourls_get_keyword_clicks( $keyword ) );\n\n        return $keyword;\n    }\n\n    /**\n     * @depends test_add_url\n     */\n    public function test_edit_title( $original_keyword ) {\n        $new_keyword = rand_str();\n        $new_title   = rand_str();\n        $new_url     = 'http://' . rand_str();\n\n        $edit = yourls_edit_link_title( $original_keyword, $new_title );\n        $this->assertEquals( 1, $edit );\n        // purge cache\n        $original = yourls_get_keyword_infos( $original_keyword, false );\n        $this->assertEquals( $new_title, yourls_get_keyword_title( $original_keyword ) );\n\n        return $original_keyword;\n    }\n    /**\n     * @depends test_add_url\n     */\n    public function test_is_shorturl( $keyword ) {\n        $this->assertFalse( yourls_is_shorturl( rand_str() ) );\n        $this->assertTrue( yourls_is_shorturl( $keyword ) );\n        $this->assertTrue( yourls_is_shorturl( yourls_link( $keyword ) ) );\n    }\n\n    /**\n     * @depends test_add_url\n     */\n    public function test_update_hits( $keyword ) {\n        // purge cache\n        $cache = yourls_get_keyword_infos( $keyword, false );\n        $this->assertEquals( 0, yourls_get_keyword_clicks( $keyword ) );\n\n        $this->assertEquals( 1, yourls_update_clicks( $keyword ) );\n        // purge cache\n        yourls_get_keyword_infos( $keyword, false );\n        $this->assertEquals( 1, yourls_get_keyword_clicks( $keyword ) );\n    }\n\n    public function test_log_hits_unknown() {\n        $rand = rand_str();\n        $this->assertEquals( 0, yourls_update_clicks( $rand ) );\n        $this->assertEquals( 0, yourls_get_keyword_clicks( $rand ) );\n    }\n\n    /**\n     * @depends test_edit_title\n     */\n    public function test_edit_url( $original_keyword ) {\n        $new_keyword = rand_str();\n        $new_title   = rand_str();\n        $new_url     = 'http://' . rand_str();\n\n        // purge cache\n        $original = yourls_get_keyword_infos( $original_keyword, false );\n\n        $edit = yourls_edit_link( $original['url'], $original_keyword, $new_keyword, $new_title );\n        $this->assertEquals( $edit['url']['title'], $new_title );\n        $this->assertEquals( $edit['url']['keyword'], $new_keyword );\n\n        $edit = yourls_edit_link( $new_url, $new_keyword, $new_keyword, $new_title );\n        $this->assertEquals( $edit['url']['url'], $new_url );\n\n        return $new_keyword;\n    }\n\n    /**\n     * @depends test_edit_url\n     */\n    public function test_delete_url( $keyword ) {\n        $delete = yourls_delete_link_by_keyword( rand_str() );\n        $this->assertEquals( 0, $delete );\n        $delete = yourls_delete_link_by_keyword( $keyword );\n        $this->assertEquals( 1, $delete );\n        $this->assertFalse( yourls_is_shorturl( $keyword ) );\n    }\n\n}\n"], "fixing_code": ["<?php\n/*\n * Functions relative to short URLs: adding, editing, etc\n * (either proper short URLs (\"http://sho.rt/abc\") or \"keywords\" (the \"abc\" part)\n */\n\n\n/**\n * Add a new link in the DB, either with custom keyword, or find one\n *\n * The return array will contain at least the following keys:\n *    status: string, 'success' or 'fail'\n *    message: string, a descriptive localized message of what happened in any case\n *    code: string, a short descriptivish and untranslated message describing what happened\n *\n * Depending on the operation, it will contain any of the following keys:\n *    errorCode: string, a HTTP status code\n *    url: array, the short URL creation information, with the following keys: 'keyword', 'url', 'title', 'date', 'ip'\n *    title: string, the URL title\n *    shorturl: string, the proper short URL in full (eg 'http://sho.rt/abc')\n *    html: string, the HTML part used by the ajax to update the page display if any\n *\n * @param  string $url      URL to shorten\n * @param  string $keyword  optional \"keyword\"\n * @param  string $title    option title\n * @return array            array with error/success state and short URL information\n */\nfunction yourls_add_new_link( $url, $keyword = '', $title = '' ) {\n    // Allow plugins to short-circuit the whole function\n    $pre = yourls_apply_filter( 'shunt_add_new_link', false, $url, $keyword, $title );\n    if ( false !== $pre )\n        return $pre;\n\n    $url = yourls_sanitize_url( $url );\n    if ( !$url || $url == 'http://' || $url == 'https://' ) {\n        $return['status']    = 'fail';\n        $return['code']      = 'error:nourl';\n        $return['message']   = yourls__( 'Missing or malformed URL' );\n        $return['errorCode'] = '400';\n        return yourls_apply_filter( 'add_new_link_fail_nourl', $return, $url, $keyword, $title );\n    }\n\n    // Prevent DB flood\n    $ip = yourls_get_IP();\n    yourls_check_IP_flood( $ip );\n\n    // Prevent internal redirection loops: cannot shorten a shortened URL\n    if( yourls_get_relative_url( $url ) ) {\n        if( yourls_is_shorturl( $url ) ) {\n            $return['status']    = 'fail';\n            $return['code']      = 'error:noloop';\n            $return['message']   = yourls__( 'URL is a short URL' );\n            $return['errorCode'] = '400';\n            return yourls_apply_filter( 'add_new_link_fail_noloop', $return, $url, $keyword, $title );\n        }\n    }\n\n    yourls_do_action( 'pre_add_new_link', $url, $keyword, $title );\n\n    $return = array();\n\n    // duplicates allowed or new URL => store it\n    if( yourls_allow_duplicate_longurls() || !( $url_exists = yourls_long_url_exists( $url ) ) ) {\n\n        if( isset( $title ) && !empty( $title ) ) {\n            $title = yourls_sanitize_title( $title );\n        } else {\n            $title = yourls_get_remote_title( $url );\n        }\n        $title = yourls_apply_filter( 'add_new_title', $title, $url, $keyword );\n\n        // Custom keyword provided\n        if ( $keyword ) {\n\n            yourls_do_action( 'add_new_link_custom_keyword', $url, $keyword, $title );\n\n            $keyword = yourls_sanitize_keyword( $keyword, true );\n            $keyword = yourls_apply_filter( 'custom_keyword', $keyword, $url, $title );\n\n            if ( !yourls_keyword_is_free( $keyword ) ) {\n                // This shorturl either reserved or taken already\n                $return['status']  = 'fail';\n                $return['code']    = 'error:keyword';\n                $return['message'] = yourls_s( 'Short URL %s already exists in database or is reserved', $keyword );\n            } else {\n                // all clear, store !\n                yourls_insert_link_in_db( $url, $keyword, $title );\n                $return['url']      = array('keyword' => $keyword, 'url' => $url, 'title' => $title, 'date' => date('Y-m-d H:i:s'), 'ip' => $ip );\n                $return['status']   = 'success';\n                $return['message']  = /* //translators: eg \"http://someurl/ added to DB\" */ yourls_s( '%s added to database', yourls_trim_long_string( $url ) );\n                $return['title']    = $title;\n                $return['html']     = yourls_table_add_row( $keyword, $url, $title, $ip, 0, time() );\n                $return['shorturl'] = yourls_link($keyword);\n            }\n\n        // Create random keyword\n        } else {\n\n            yourls_do_action( 'add_new_link_create_keyword', $url, $keyword, $title );\n\n            $timestamp = date( 'Y-m-d H:i:s' );\n            $id = yourls_get_next_decimal();\n            $ok = false;\n            do {\n                $keyword = yourls_int2string( $id );\n                $keyword = yourls_apply_filter( 'random_keyword', $keyword, $url, $title );\n                if ( yourls_keyword_is_free($keyword) ) {\n                    if (yourls_insert_link_in_db( $url, $keyword, $title )){\n                        // everything ok, populate needed vars\n                        $return['url']      = array('keyword' => $keyword, 'url' => $url, 'title' => $title, 'date' => $timestamp, 'ip' => $ip );\n                        $return['status']   = 'success';\n                        $return['message']  = /* //translators: eg \"http://someurl/ added to DB\" */ yourls_s( '%s added to database', yourls_trim_long_string( $url ) );\n                        $return['title']    = $title;\n                        $return['html']     = yourls_table_add_row( $keyword, $url, $title, $ip, 0, time() );\n                        $return['shorturl'] = yourls_link($keyword);\n                    } else {\n                        // database error, couldnt store result\n                        $return['status']   = 'fail';\n                        $return['code']     = 'error:db';\n                        $return['message']  = yourls_s( 'Error saving url to database' );\n                    }\n                    $ok = true;\n                }\n                $id++;\n            } while ( !$ok );\n            @yourls_update_next_decimal( $id );\n        }\n\n    // URL was already stored\n    } else {\n\n        yourls_do_action( 'add_new_link_already_stored', $url, $keyword, $title );\n\n        $return['status']   = 'fail';\n        $return['code']     = 'error:url';\n        $return['url']      = array( 'keyword' => $url_exists->keyword, 'url' => $url, 'title' => $url_exists->title, 'date' => $url_exists->timestamp, 'ip' => $url_exists->ip, 'clicks' => $url_exists->clicks );\n        $return['message']  = /* //translators: eg \"http://someurl/ already exists\" */ yourls_s( '%s already exists in database', yourls_trim_long_string( $url ) );\n        $return['title']    = $url_exists->title;\n        $return['shorturl'] = yourls_link($url_exists->keyword);\n    }\n\n    yourls_do_action( 'post_add_new_link', $url, $keyword, $title, $return );\n\n    $return['statusCode'] = 200; // regardless of result, this is still a valid request\n    return yourls_apply_filter( 'add_new_link', $return, $url, $keyword, $title );\n}\n\n/**\n * Determine the allowed character set in short URLs\n *\n * @return string    Acceptable charset for short URLS keywords\n */\nfunction yourls_get_shorturl_charset() {\n    static $charset = null;\n    if ( $charset !== null ) {\n        return $charset;\n    }\n\n    if ( defined( 'YOURLS_URL_CONVERT' ) && in_array( YOURLS_URL_CONVERT, [ 62, 64 ] ) ) {\n        $charset = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n    }\n    else {\n        // defined to 36, or wrongly defined\n        $charset = '0123456789abcdefghijklmnopqrstuvwxyz';\n    }\n\n    return yourls_apply_filter( 'get_shorturl_charset', $charset );\n}\n\n/**\n * Is a URL a short URL? Accept either 'http://sho.rt/abc' or 'abc'\n *\n * @param  string $shorturl   short URL\n * @return bool               true if registered short URL, false otherwise\n */\nfunction yourls_is_shorturl( $shorturl ) {\n    // TODO: make sure this function evolves with the feature set.\n\n    $is_short = false;\n\n    // Is $shorturl a URL (http://sho.rt/abc) or a keyword (abc) ?\n    if( yourls_get_protocol( $shorturl ) ) {\n        $keyword = yourls_get_relative_url( $shorturl );\n    } else {\n        $keyword = $shorturl;\n    }\n\n    // Check if it's a valid && used keyword\n    if( $keyword && $keyword == yourls_sanitize_keyword( $keyword ) && yourls_keyword_is_taken( $keyword ) ) {\n        $is_short = true;\n    }\n\n    return yourls_apply_filter( 'is_shorturl', $is_short, $shorturl );\n}\n\n/**\n * Check to see if a given keyword is reserved (ie reserved URL or an existing page). Returns bool\n *\n * @param  string $keyword   Short URL keyword\n * @return bool              True if keyword reserved, false if free to be used\n */\nfunction yourls_keyword_is_reserved( $keyword ) {\n    global $yourls_reserved_URL;\n    $keyword = yourls_sanitize_keyword( $keyword );\n    $reserved = false;\n\n    if ( in_array( $keyword, $yourls_reserved_URL)\n        or yourls_is_page($keyword)\n        or is_dir( YOURLS_ABSPATH .\"/$keyword\" )\n    )\n        $reserved = true;\n\n    return yourls_apply_filter( 'keyword_is_reserved', $reserved, $keyword );\n}\n\n/**\n * Delete a link in the DB\n *\n */\nfunction yourls_delete_link_by_keyword( $keyword ) {\n    // Allow plugins to short-circuit the whole function\n    $pre = yourls_apply_filter( 'shunt_delete_link_by_keyword', null, $keyword );\n    if ( null !== $pre ) {\n        return $pre;\n    }\n\n    $table = YOURLS_DB_TABLE_URL;\n    $keyword = yourls_sanitize_keyword($keyword);\n    $delete = yourls_get_db()->fetchAffected(\"DELETE FROM `$table` WHERE `keyword` = :keyword\", array('keyword' => $keyword));\n    yourls_do_action( 'delete_link', $keyword, $delete );\n    return $delete;\n}\n\n/**\n * SQL query to insert a new link in the DB. Returns boolean for success or failure of the inserting\n *\n */\nfunction yourls_insert_link_in_db( $url, $keyword, $title = '' ) {\n    $url       = yourls_sanitize_url($url);\n    $keyword   = yourls_sanitize_keyword($keyword);\n    $title     = yourls_sanitize_title($title);\n    $timestamp = date('Y-m-d H:i:s');\n    $ip        = yourls_get_IP();\n\n    $table = YOURLS_DB_TABLE_URL;\n    $binds = array(\n        'keyword'   => $keyword,\n        'url'       => $url,\n        'title'     => $title,\n        'timestamp' => $timestamp,\n        'ip'        => $ip,\n    );\n    $insert = yourls_get_db()->fetchAffected(\"INSERT INTO `$table` (`keyword`, `url`, `title`, `timestamp`, `ip`, `clicks`) VALUES(:keyword, :url, :title, :timestamp, :ip, 0);\", $binds);\n\n    yourls_do_action( 'insert_link', (bool)$insert, $url, $keyword, $title, $timestamp, $ip );\n\n    return (bool)$insert;\n}\n\n/**\n * Check if a long URL already exists in the DB. Return NULL (doesn't exist) or an object with URL informations.\n *\n * This function supersedes function yourls_url_exists(), deprecated in 1.7.10, with a better naming.\n *\n * @since 1.7.10\n * @param  string $url  URL to check if already shortened\n * @return mixed        NULL if does not already exist in DB, or object with URL information as properties (eg keyword, url, title, ...)\n */\nfunction yourls_long_url_exists( $url ) {\n    // Allow plugins to short-circuit the whole function\n    $pre = yourls_apply_filter( 'shunt_url_exists', false, $url );\n    if ( false !== $pre ) {\n        return $pre;\n    }\n\n    $table = YOURLS_DB_TABLE_URL;\n    $url   = yourls_sanitize_url($url);\n    $url_exists = yourls_get_db()->fetchObject(\"SELECT * FROM `$table` WHERE `url` = :url\", array('url'=>$url));\n\n    if ($url_exists === false) {\n        $url_exists = NULL;\n    }\n\n    return yourls_apply_filter( 'url_exists', $url_exists, $url );\n}\n\n/**\n * Edit a link\n *\n */\nfunction yourls_edit_link( $url, $keyword, $newkeyword='', $title='' ) {\n    // Allow plugins to short-circuit the whole function\n    $pre = yourls_apply_filter( 'shunt_edit_link', null, $keyword, $url, $keyword, $newkeyword, $title );\n    if ( null !== $pre )\n        return $pre;\n\n    $ydb = yourls_get_db();\n\n    $table = YOURLS_DB_TABLE_URL;\n    $url = yourls_sanitize_url($url);\n    $keyword = yourls_sanitize_keyword($keyword);\n    $title = yourls_sanitize_title($title);\n    $newkeyword = yourls_sanitize_keyword($newkeyword, true);\n\n    if(!$url OR !$newkeyword) {\n        $return['status']  = 'fail';\n        $return['message'] = yourls__( 'Long URL or Short URL cannot be blank' );\n        return yourls_apply_filter( 'edit_link', $return, $url, $keyword, $newkeyword, $title );\n    }\n\n    $old_url = $ydb->fetchValue(\"SELECT `url` FROM `$table` WHERE `keyword` = :keyword\", array('keyword' => $keyword));\n\n    // Check if new URL is not here already\n    if ( $old_url != $url && !yourls_allow_duplicate_longurls() ) {\n        $new_url_already_there = intval($ydb->fetchValue(\"SELECT COUNT(keyword) FROM `$table` WHERE `url` = :url;\", array('url' => $url)));\n    } else {\n        $new_url_already_there = false;\n    }\n\n    // Check if the new keyword is not here already\n    if ( $newkeyword != $keyword ) {\n        $keyword_is_ok = yourls_keyword_is_free( $newkeyword );\n    } else {\n        $keyword_is_ok = true;\n    }\n\n    yourls_do_action( 'pre_edit_link', $url, $keyword, $newkeyword, $new_url_already_there, $keyword_is_ok );\n\n    // All clear, update\n    if ( ( !$new_url_already_there || yourls_allow_duplicate_longurls() ) && $keyword_is_ok ) {\n            $sql   = \"UPDATE `$table` SET `url` = :url, `keyword` = :newkeyword, `title` = :title WHERE `keyword` = :keyword\";\n            $binds = array('url' => $url, 'newkeyword' => $newkeyword, 'title' => $title, 'keyword' => $keyword);\n            $update_url = $ydb->fetchAffected($sql, $binds);\n        if( $update_url ) {\n            $return['url']     = array( 'keyword'       => $newkeyword,\n                                        'shorturl'      => yourls_link($newkeyword),\n                                        'url'           => yourls_esc_url($url),\n                                        'display_url'   => yourls_esc_html(yourls_trim_long_string($url)),\n                                        'title'         => yourls_esc_attr($title),\n                                        'display_title' => yourls_esc_html(yourls_trim_long_string( $title ))\n                                );\n            $return['status']  = 'success';\n            $return['message'] = yourls__( 'Link updated in database' );\n        } else {\n            $return['status']  = 'fail';\n            $return['message'] = /* //translators: \"Error updating http://someurl/ (Shorturl: http://sho.rt/blah)\" */ yourls_s( 'Error updating %s (Short URL: %s)', yourls_esc_html(yourls_trim_long_string($url)), $keyword ) ;\n        }\n\n    // Nope\n    } else {\n        $return['status']  = 'fail';\n        $return['message'] = yourls__( 'URL or keyword already exists in database' );\n    }\n\n    return yourls_apply_filter( 'edit_link', $return, $url, $keyword, $newkeyword, $title, $new_url_already_there, $keyword_is_ok );\n}\n\n/**\n * Update a title link (no checks for duplicates etc..)\n *\n */\nfunction yourls_edit_link_title( $keyword, $title ) {\n    // Allow plugins to short-circuit the whole function\n    $pre = yourls_apply_filter( 'shunt_edit_link_title', null, $keyword, $title );\n    if ( null !== $pre ) {\n        return $pre;\n    }\n\n    $keyword = yourls_sanitize_keyword( $keyword );\n    $title = yourls_sanitize_title( $title );\n\n    $table = YOURLS_DB_TABLE_URL;\n    $update = yourls_get_db()->fetchAffected(\"UPDATE `$table` SET `title` = :title WHERE `keyword` = :keyword;\", array('title' => $title, 'keyword' => $keyword));\n\n    return $update;\n}\n\n/**\n * Check if keyword id is free (ie not already taken, and not reserved). Return bool.\n *\n * @param  string $keyword    short URL keyword\n * @return bool               true if keyword is taken (ie there is a short URL for it), false otherwise\n */\nfunction yourls_keyword_is_free( $keyword  ) {\n    $free = true;\n    if ( yourls_keyword_is_reserved( $keyword ) or yourls_keyword_is_taken( $keyword, false ) ) {\n        $free = false;\n    }\n\n    return yourls_apply_filter( 'keyword_is_free', $free, $keyword );\n}\n\n/**\n * Check if a keyword matches a \"page\"\n *\n * @see https://github.com/YOURLS/YOURLS/wiki/Pages\n * @since 1.7.10\n * @param  string $keyword  Short URL $keyword\n * @return bool             true if is page, false otherwise\n */\nfunction yourls_is_page($keyword) {\n    return yourls_apply_filter( 'is_page', file_exists( YOURLS_PAGEDIR . \"/$keyword.php\" ) );\n}\n\n/**\n * Check if a keyword is taken (ie there is already a short URL with this id). Return bool.\n *\n */\n/**\n * Check if a keyword is taken (ie there is already a short URL with this id). Return bool.\n *\n * @param  string $keyword    short URL keyword\n * @param  bool   $use_cache  optional, default true: do we want to use what is cached in memory, if any, or force a new SQL query\n * @return bool               true if keyword is taken (ie there is a short URL for it), false otherwise\n */\nfunction yourls_keyword_is_taken( $keyword, $use_cache = true ) {\n    // Allow plugins to short-circuit the whole function\n    $pre = yourls_apply_filter( 'shunt_keyword_is_taken', false, $keyword );\n    if ( false !== $pre ) {\n        return $pre;\n    }\n\n    $taken = false;\n    // To check if a keyword is already associated with a short URL, we fetch all info matching that keyword. This\n    // will save a query in case of a redirection in yourls-go.php because info will be cached\n    if ( yourls_get_keyword_infos($keyword, $use_cache) ) {\n        $taken = true;\n    }\n\n    return yourls_apply_filter( 'keyword_is_taken', $taken, $keyword );\n}\n\n/**\n * Return array of all information associated with keyword. Returns false if keyword not found. Set optional $use_cache to false to force fetching from DB\n *\n * Sincere apologies to native English speakers, we are aware that the plural of 'info' is actually 'info', not 'infos'.\n * This function yourls_get_keyword_infos() returns all information, while function yourls_get_keyword_info() (no 's') return only\n * one information. Blame YOURLS contributors whose mother tongue is not English :)\n *\n * @since 1.4\n * @param  string $keyword    Short URL keyword\n * @param  bool   $use_cache  Default true, set to false to force fetching from DB\n * @return false|object       false if not found, object with URL properties if found\n */\nfunction yourls_get_keyword_infos( $keyword, $use_cache = true ) {\n    $ydb = yourls_get_db();\n    $keyword = yourls_sanitize_keyword( $keyword );\n\n    yourls_do_action( 'pre_get_keyword', $keyword, $use_cache );\n\n    if( $ydb->has_infos($keyword) && $use_cache === true ) {\n        return yourls_apply_filter( 'get_keyword_infos', $ydb->get_infos($keyword), $keyword );\n    }\n\n    yourls_do_action( 'get_keyword_not_cached', $keyword );\n\n    $table = YOURLS_DB_TABLE_URL;\n    $infos = $ydb->fetchObject(\"SELECT * FROM `$table` WHERE `keyword` = :keyword\", array('keyword' => $keyword));\n\n    if( $infos ) {\n        $infos = (array)$infos;\n        $ydb->set_infos($keyword, $infos);\n    } else {\n        // is NULL if not found\n        $infos = false;\n        $ydb->set_infos($keyword, false);\n    }\n\n    return yourls_apply_filter( 'get_keyword_infos', $infos, $keyword );\n}\n\n/**\n * Return (string) selected information associated with a keyword. Optional $notfound = string default message if nothing found\n *\n */\nfunction yourls_get_keyword_info( $keyword, $field, $notfound = false ) {\n\n    // Allow plugins to short-circuit the whole function\n    $pre = yourls_apply_filter( 'shunt_get_keyword_info', false, $keyword, $field, $notfound );\n    if ( false !== $pre )\n        return $pre;\n\n    $keyword = yourls_sanitize_keyword( $keyword );\n    $infos = yourls_get_keyword_infos( $keyword );\n\n    $return = $notfound;\n    if ( isset( $infos[ $field ] ) && $infos[ $field ] !== false )\n        $return = $infos[ $field ];\n\n    return yourls_apply_filter( 'get_keyword_info', $return, $keyword, $field, $notfound );\n}\n\n/**\n * Return title associated with keyword. Optional $notfound = string default message if nothing found\n *\n */\nfunction yourls_get_keyword_title( $keyword, $notfound = false ) {\n    return yourls_get_keyword_info( $keyword, 'title', $notfound );\n}\n\n/**\n * Return long URL associated with keyword. Optional $notfound = string default message if nothing found\n *\n */\nfunction yourls_get_keyword_longurl( $keyword, $notfound = false ) {\n    return yourls_get_keyword_info( $keyword, 'url', $notfound );\n}\n\n/**\n * Return number of clicks on a keyword. Optional $notfound = string default message if nothing found\n *\n */\nfunction yourls_get_keyword_clicks( $keyword, $notfound = false ) {\n    return yourls_get_keyword_info( $keyword, 'clicks', $notfound );\n}\n\n/**\n * Return IP that added a keyword. Optional $notfound = string default message if nothing found\n *\n */\nfunction yourls_get_keyword_IP( $keyword, $notfound = false ) {\n    return yourls_get_keyword_info( $keyword, 'ip', $notfound );\n}\n\n/**\n * Return timestamp associated with a keyword. Optional $notfound = string default message if nothing found\n *\n */\nfunction yourls_get_keyword_timestamp( $keyword, $notfound = false ) {\n    return yourls_get_keyword_info( $keyword, 'timestamp', $notfound );\n}\n\n/**\n * Return array of stats for a given keyword\n *\n * This function supersedes function yourls_get_link_stats(), deprecated in 1.7.10, with a better naming.\n *\n * @since 1.7.10\n * @param  string $shorturl short URL keyword\n * @return array            stats\n */\nfunction yourls_get_keyword_stats( $shorturl ) {\n    $table_url = YOURLS_DB_TABLE_URL;\n    $shorturl  = yourls_sanitize_keyword( $shorturl );\n\n    $res = yourls_get_db()->fetchObject(\"SELECT * FROM `$table_url` WHERE `keyword` = :keyword\", array('keyword' => $shorturl));\n    $return = array();\n\n    if( !$res ) {\n        // non existent link\n        $return = array(\n            'statusCode' => 404,\n            'message'    => 'Error: short URL not found',\n        );\n    } else {\n        $return = array(\n            'statusCode' => 200,\n            'message'    => 'success',\n            'link'       => array(\n                'shorturl' => yourls_link($res->keyword),\n                'url'      => $res->url,\n                'title'    => $res->title,\n                'timestamp'=> $res->timestamp,\n                'ip'       => $res->ip,\n                'clicks'   => $res->clicks,\n            )\n        );\n    }\n\n    return yourls_apply_filter( 'get_link_stats', $return, $shorturl );\n}\n\n/**\n * Return array of keywords that redirect to the submitted long URL\n *\n * @since 1.7\n * @param string $longurl long url\n * @param string $order Optional SORT order (can be 'ASC' or 'DESC')\n * @return array array of keywords\n */\nfunction yourls_get_longurl_keywords( $longurl, $order = 'ASC' ) {\n    $longurl = yourls_sanitize_url($longurl);\n    $table   = YOURLS_DB_TABLE_URL;\n    $sql     = \"SELECT `keyword` FROM `$table` WHERE `url` = :url\";\n\n    if (in_array($order, array('ASC','DESC'))) {\n        $sql .= \" ORDER BY `keyword` \".$order;\n    }\n\n    return yourls_apply_filter( 'get_longurl_keywords', yourls_get_db()->fetchCol($sql, array('url'=>$longurl)), $longurl );\n}\n", "<?php\n\n/**\n * Short URL tests\n *\n * @group shorturls\n * @since 0.1\n */\n\nclass ShortURL_Tests extends PHPUnit\\Framework\\TestCase {\n\n    public function test_reserved_keywords() {\n        global $yourls_reserved_URL;\n        $reserved = $yourls_reserved_URL[ array_rand( $yourls_reserved_URL, 1 )  ];\n        $this->assertTrue( yourls_keyword_is_reserved( $reserved ) );\n        $this->assertFalse( yourls_keyword_is_reserved( rand_str() ) );\n    }\n\n    public function test_free_keywords() {\n        global $yourls_reserved_URL;\n        $reserved = $yourls_reserved_URL[ array_rand( $yourls_reserved_URL, 1 )  ];\n        $this->assertFalse( yourls_keyword_is_free( $reserved ) );\n        $this->assertFalse( yourls_keyword_is_free( 'ozh' ) );\n        $this->assertTrue( yourls_keyword_is_free( rand_str() ) );\n    }\n\n    public function test_url_exists() {\n        $exists = yourls_long_url_exists( 'http://ozh.org/' );\n        $this->assertEquals( 'ozh', $exists->keyword );\n        $this->assertNull( yourls_long_url_exists( rand_str() ) );\n    }\n\n    public function test_add_url() {\n        $keyword = rand_str();\n        $title   = rand_str();\n        $url     = 'http://' . rand_str();\n\n        $newurl = yourls_add_new_link( $url, $keyword, $title );\n        $this->assertEquals( 'success', $newurl['status'] );\n\n        $fail = yourls_add_new_link( $url, $keyword, $title );\n        $this->assertEquals( 'fail', $fail['status'] );\n\n        $fail = yourls_add_new_link( $url, rand_str(), rand_str() );\n        $this->assertEquals( 'fail', $fail['status'] );\n        $this->assertEquals( 'error:url', $fail['code'] );\n\n        $fail = yourls_add_new_link( 'http://' . rand_str(), $keyword, $title );\n        $this->assertEquals( 'fail', $fail['status'] );\n        $this->assertEquals( 'error:keyword', $fail['code'] );\n\n        $this->assertEquals( $title, yourls_get_keyword_title( $keyword ) );\n        $this->assertEquals( $url, yourls_get_keyword_longurl( $keyword ) );\n        $this->assertEquals( 0, yourls_get_keyword_clicks( $keyword ) );\n\n        return $keyword;\n    }\n\n    /**\n     * @depends test_add_url\n     */\n    public function test_edit_title( $original_keyword ) {\n        $new_keyword = rand_str();\n        $new_title   = rand_str();\n        $new_url     = 'http://' . rand_str();\n\n        $edit = yourls_edit_link_title( $original_keyword, $new_title );\n        $this->assertEquals( 1, $edit );\n        // purge cache\n        $original = yourls_get_keyword_infos( $original_keyword, false );\n        $this->assertEquals( $new_title, yourls_get_keyword_title( $original_keyword ) );\n\n        return $original_keyword;\n    }\n    /**\n     * @depends test_add_url\n     */\n    public function test_is_shorturl( $keyword ) {\n        $this->assertFalse( yourls_is_shorturl( rand_str() ) );\n        $this->assertTrue( yourls_is_shorturl( $keyword ) );\n        $this->assertTrue( yourls_is_shorturl( yourls_link( $keyword ) ) );\n    }\n\n    /**\n     * @depends test_add_url\n     */\n    public function test_update_hits( $keyword ) {\n        // purge cache\n        $cache = yourls_get_keyword_infos( $keyword, false );\n        $this->assertEquals( 0, yourls_get_keyword_clicks( $keyword ) );\n\n        $this->assertEquals( 1, yourls_update_clicks( $keyword ) );\n        // purge cache\n        yourls_get_keyword_infos( $keyword, false );\n        $this->assertEquals( 1, yourls_get_keyword_clicks( $keyword ) );\n    }\n\n    public function test_log_hits_unknown() {\n        $rand = rand_str();\n        $this->assertEquals( 0, yourls_update_clicks( $rand ) );\n        $this->assertEquals( 0, yourls_get_keyword_clicks( $rand ) );\n    }\n\n    /**\n     * @depends test_edit_title\n     */\n    public function test_edit_url( $original_keyword ) {\n        $new_keyword = rand_str();\n        $new_title   = rand_str();\n        $new_url     = 'http://' . rand_str();\n\n        // purge cache\n        $original = yourls_get_keyword_infos( $original_keyword, false );\n\n        $edit = yourls_edit_link( $original['url'], $original_keyword, $new_keyword, $new_title );\n        $this->assertEquals( $edit['url']['title'], $new_title );\n        $this->assertEquals( $edit['url']['keyword'], $new_keyword );\n\n        $edit = yourls_edit_link( $new_url, $new_keyword, $new_keyword, $new_title );\n        $this->assertEquals( $edit['url']['url'], $new_url );\n\n        return $new_keyword;\n    }\n\n    /**\n     * @depends test_edit_url\n     */\n    public function test_delete_url( $keyword ) {\n        $delete = yourls_delete_link_by_keyword( rand_str() );\n        $this->assertEquals( 0, $delete );\n        $delete = yourls_delete_link_by_keyword( $keyword );\n        $this->assertEquals( 1, $delete );\n        $this->assertFalse( yourls_is_shorturl( $keyword ) );\n    }\n\n}\n"], "filenames": ["includes/functions-shorturls.php", "tests/tests/shorturl/shorturl.php"], "buggy_code_start_loc": [304, 41], "buggy_code_end_loc": [343, 41], "fixing_code_start_loc": [303, 42], "fixing_code_end_loc": [347, 45], "type": "CWE-79", "message": "yourls is vulnerable to Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "other": {"cve": {"id": "CVE-2021-3785", "sourceIdentifier": "security@huntr.dev", "published": "2021-09-15T12:15:16.283", "lastModified": "2021-09-23T19:31:11.840", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "yourls is vulnerable to Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"}, {"lang": "es", "value": "yourls es vulnerable a la Neutralizaci\u00f3n Inapropiada de la Entrada durante la Generaci\u00f3n de la P\u00e1gina Web (\"Cross-site Scripting\")"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:yourls:yourls:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.8.2", "matchCriteriaId": "6A2C8C7B-8D81-4333-8912-980436C67E17"}]}]}], "references": [{"url": "https://github.com/yourls/yourls/commit/1d8e224ebabb8a4c75b97f026950ed710faab0ff", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/b4085d13-54fa-4419-a2ce-1d780cc31638", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/yourls/yourls/commit/1d8e224ebabb8a4c75b97f026950ed710faab0ff"}}