{"buggy_code": ["/* radare - LGPL - Copyright 2009-2010 nibble<.ds@gmail.com> */\n\n#include <r_types.h>\n#include \"mach0_specs.h\"\n\n#ifndef _INCLUDE_R_BIN_DYLDCACHE_H_\n#define _INCLUDE_R_BIN_DYLDCACHE_H_\n\nstruct r_bin_dyldcache_obj_t {\n\tconst char *file;\n\tint size;\n\tint nlibs;\n\tstruct cache_header hdr;\n\tRBuffer* b;\n};\n\nstruct r_bin_dyldcache_lib_t {\n\tchar path[1024];\n\tint size;\n\tut64 offset;\n\tRBuffer *b;\n\tint last;\n};\n\n\nstruct dyld_cache_mapping_info {\n\tut64 address;\n\tut64 size;\n\tut64 fileOffset;\n\tut32 maxProt;\n\tut32 initProt;\n};\n\nstruct dyld_cache_image_info {\n\tut64 address;\n\tut64 modTime;\n\tut64 inode;\n\tut32 pathFileOffset;\n\tut32 pad;\n};\n\nstruct dyld_cache_slide_info {\n\tut32 version;\n\tut32 toc_offset;\n\tut32 toc_count;\n\tut32 entries_offset;\n\tut32 entries_count;\n\tut32 entries_size;\n};\n\ntypedef struct _dyld_cache_local_symbols_info {\n\tut32 nlistOffset;\n\tut32 nlistCount;\n\tut32 stringsOffset;\n\tut32 stringsSize;\n\tut32 entriesOffset;\n\tut32 entriesCount;\n} dyld_cache_local_symbols_info;\n\ntypedef struct _dyld_cache_local_symbols_entry {\n\tut32 dylibOffset;\n\tut32 nlistStartIndex;\n\tut32 nlistCount;\n} dyld_cache_local_symbols_entry;\n\nstruct r_bin_dyldcache_lib_t *r_bin_dyldcache_extract(struct r_bin_dyldcache_obj_t* bin, int idx, int *nlib);\nvoid *r_bin_dyldcache_free(struct r_bin_dyldcache_obj_t* bin);\nstruct r_bin_dyldcache_obj_t* r_bin_dyldcache_new(const char* file);\nstruct r_bin_dyldcache_obj_t* r_bin_dyldcache_from_bytes_new (const ut8* bytes, ut64 size);\nvoid r_bin_dydlcache_get_libname(struct r_bin_dyldcache_lib_t *lib, char **libname);\n\n#endif\n", "/* radare2 - LGPL - Copyright 2018-2022 - pancake, mrmacete, keegan */\n\n#include <r_types.h>\n#include <r_util.h>\n#include <r_lib.h>\n#include <r_bin.h>\n#include <r_core.h>\n#include <r_io.h>\n#include <ht_pu.h>\n// #include \"../format/mach0/mach0_defines.h\"\n#define R_BIN_MACH064 1\n#include \"../format/mach0/mach0.h\"\n#include \"objc/mach0_classes.h\"\n\n#define R_IS_PTR_AUTHENTICATED(x) B_IS_SET(x, 63)\n#define MAX_N_HDR 16\n\ntypedef struct {\n\tut8 version;\n\tut64 slide;\n\tut8 *one_page_buf;\n\tut32 page_size;\n\tut64 start_of_data;\n} RDyldRebaseInfo;\n\ntypedef struct {\n\tut64 start;\n\tut64 end;\n\tRDyldRebaseInfo *info;\n} RDyldRebaseInfosEntry;\n\ntypedef struct {\n\tRDyldRebaseInfosEntry *entries;\n\tsize_t length;\n} RDyldRebaseInfos;\n\ntypedef struct {\n\tut8 version;\n\tut64 slide;\n\tut8 *one_page_buf;\n\tut32 page_size;\n\tut64 start_of_data;\n\tut16 *page_starts;\n\tut32 page_starts_count;\n\tut64 delta_mask;\n\tut32 delta_shift;\n\tut64 auth_value_add;\n} RDyldRebaseInfo3;\n\ntypedef struct {\n\tut8 version;\n\tut64 slide;\n\tut8 *one_page_buf;\n\tut32 page_size;\n\tut64 start_of_data;\n\tut16 *page_starts;\n\tut32 page_starts_count;\n\tut16 *page_extras;\n\tut32 page_extras_count;\n\tut64 delta_mask;\n\tut64 value_mask;\n\tut32 delta_shift;\n\tut64 value_add;\n} RDyldRebaseInfo2;\n\ntypedef struct {\n\tut8 version;\n\tut64 slide;\n\tut8 *one_page_buf;\n\tut32 page_size;\n\tut64 start_of_data;\n\tut16 *toc;\n\tut32 toc_count;\n\tut8 *entries;\n\tut32 entries_size;\n} RDyldRebaseInfo1;\n\ntypedef struct {\n\tut64 local_symbols_offset;\n\tut64 nlists_offset;\n\tut64 nlists_count;\n\tut64 strings_offset;\n\tut64 strings_size;\n} RDyldLocSym;\n\ntypedef struct _r_dyldcache {\n\tut8 magic[8];\n\n\tcache_hdr_t *hdr;\n\tut64 *hdr_offset;\n\tut32 *maps_index;\n\tut32 n_hdr;\n\tcache_map_t *maps;\n\tut32 n_maps;\n\n\tRList *bins;\n\tRBuffer *buf;\n\tint (*original_io_read)(RIO *io, RIODesc *fd, ut8 *buf, int count);\n\tRDyldRebaseInfos *rebase_infos;\n\tcache_accel_t *accel;\n\tRDyldLocSym *locsym;\n\tobjc_cache_opt_info *oi;\n\tbool objc_opt_info_loaded;\n} RDyldCache;\n\ntypedef struct _r_bin_image {\n\tchar *file;\n\tut64 header_at;\n\tut64 hdr_offset;\n\tut64 symbols_off;\n\tut64 va;\n\tut32 nlist_start_index;\n\tut32 nlist_count;\n} RDyldBinImage;\n\nstatic R_TH_LOCAL RList *pending_bin_files = NULL;\n\nstatic ut64 va2pa(uint64_t addr, ut32 n_maps, cache_map_t *maps, RBuffer *cache_buf, ut64 slide, ut32 *offset, ut32 *left) {\n\tut64 res = UT64_MAX;\n\tut32 i;\n\n\taddr -= slide;\n\n\tfor (i = 0; i < n_maps; i++) {\n\t\tif (addr >= maps[i].address && addr < maps[i].address + maps[i].size) {\n\t\t\tres = maps[i].fileOffset + addr - maps[i].address;\n\t\t\tif (offset) {\n\t\t\t\t*offset = addr - maps[i].address;\n\t\t\t}\n\t\t\tif (left) {\n\t\t\t\t*left = maps[i].size - (addr - maps[i].address);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn res;\n}\n\nstatic void free_bin(RDyldBinImage *bin) {\n\tif (!bin) {\n\t\treturn;\n\t}\n\n\tR_FREE (bin->file);\n\tR_FREE (bin);\n}\n\nstatic void rebase_info3_free(RDyldRebaseInfo3 *rebase_info) {\n\tif (!rebase_info) {\n\t\treturn;\n\t}\n\n\tR_FREE (rebase_info->page_starts);\n\tR_FREE (rebase_info);\n}\n\nstatic void rebase_info2_free(RDyldRebaseInfo2 *rebase_info) {\n\tif (!rebase_info) {\n\t\treturn;\n\t}\n\n\tR_FREE (rebase_info->page_starts);\n\tR_FREE (rebase_info->page_extras);\n\tR_FREE (rebase_info);\n}\n\nstatic void rebase_info1_free(RDyldRebaseInfo1 *rebase_info) {\n\tif (!rebase_info) {\n\t\treturn;\n\t}\n\n\tR_FREE (rebase_info->toc);\n\tR_FREE (rebase_info->entries);\n\tR_FREE (rebase_info);\n}\n\nstatic void rebase_info_free(RDyldRebaseInfo *rebase_info) {\n\tif (!rebase_info) {\n\t\treturn;\n\t}\n\n\tR_FREE (rebase_info->one_page_buf);\n\n\tut8 version = rebase_info->version;\n\n\tif (version == 1) {\n\t\trebase_info1_free ((RDyldRebaseInfo1*) rebase_info);\n\t} else if (version == 2 || version == 4) {\n\t\trebase_info2_free ((RDyldRebaseInfo2*) rebase_info);\n\t} else if (version == 3) {\n\t\trebase_info3_free ((RDyldRebaseInfo3*) rebase_info);\n\t} else {\n\t\tR_FREE (rebase_info);\n\t}\n}\n\nstatic cache_img_t *read_cache_images(RBuffer *cache_buf, cache_hdr_t *hdr, ut64 hdr_offset) {\n\tif (!cache_buf || !hdr) {\n\t\treturn NULL;\n\t}\n\tif (!hdr->imagesCount || !hdr->imagesOffset || hdr->imagesOffset == UT32_MAX || hdr->imagesCount == UT32_MAX) {\n\t\treturn NULL;\n\t}\n\n\tut64 size = sizeof (cache_img_t) * hdr->imagesCount;\n\tcache_img_t *images = R_NEWS0 (cache_img_t, hdr->imagesCount);\n\tif (!images) {\n\t\treturn NULL;\n\t}\n\n\tif (r_buf_fread_at (cache_buf, hdr->imagesOffset, (ut8*) images, \"3l2i\", hdr->imagesCount) != size) {\n\t\tR_FREE (images);\n\t\treturn NULL;\n\t}\n\n\tif (hdr_offset) {\n\t\tut32 i;\n\t\tfor (i = 0; i < hdr->imagesCount; i++) {\n\t\t\tcache_img_t *img = &images[i];\n\t\t\timg->pathFileOffset += hdr_offset;\n\t\t}\n\t}\n\n\treturn images;\n}\n\nstatic void match_bin_entries(RDyldCache *cache, void *entries) {\n\tr_return_if_fail (cache && cache->bins && entries);\n\n\tcache_img_t *imgs = read_cache_images (cache->buf, cache->hdr, 0);\n\tif (!imgs) {\n\t\treturn;\n\t}\n\n\tRDyldBinImage *bin = NULL;\n\tRListIter *it = r_list_iterator (cache->bins);\n\n\tbool has_large_entries = cache->n_hdr > 1;\n\n\tut32 i;\n\tfor (i = 0; i < cache->hdr->imagesCount; i++) {\n\t\tcache_img_t *img = &imgs[i];\n\t\tif (!it) {\n\t\t\tbreak;\n\t\t}\n\t\tbin = it->data;\n\t\tif (!bin) {\n\t\t\tbreak;\n\t\t}\n\t\tif (bin && bin->va == img->address) {\n\t\t\tif (has_large_entries) {\n\t\t\t\tcache_locsym_entry_large_t *e = &((cache_locsym_entry_large_t *) entries)[i];\n\t\t\t\tbin->nlist_start_index = e->nlistStartIndex;\n\t\t\t\tbin->nlist_count = e->nlistCount;\n\t\t\t} else {\n\t\t\t\tcache_locsym_entry_t *e = &((cache_locsym_entry_t *) entries)[i];\n\t\t\t\tbin->nlist_start_index = e->nlistStartIndex;\n\t\t\t\tbin->nlist_count = e->nlistCount;\n\t\t\t}\n\t\t\tit = it->n;\n\t\t}\n\t}\n\n\tR_FREE (imgs);\n}\n\nstatic RDyldLocSym *r_dyld_locsym_new(RDyldCache *cache) {\n\tr_return_val_if_fail (cache && cache->buf, NULL);\n\n\tut32 i;\n\tfor (i = 0; i < cache->n_hdr; i++) {\n\t\tcache_hdr_t *hdr = &cache->hdr[i];\n\t\tif (!hdr || !hdr->localSymbolsSize || !hdr->localSymbolsOffset) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tcache_locsym_info_t *info = NULL;\n\t\tvoid *entries = NULL;\n\n\t\tut64 info_size = sizeof (cache_locsym_info_t);\n\t\tinfo = R_NEW0 (cache_locsym_info_t);\n\t\tif (!info) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (r_buf_fread_at (cache->buf, hdr->localSymbolsOffset, (ut8*) info, \"6i\", 1) != info_size) {\n\t\t\teprintf (\"locsym err 01\\n\");\n\t\t\tgoto beach;\n\t\t}\n\t\tif (info->entriesCount != cache->hdr->imagesCount) {\n\t\t\teprintf (\"locsym err 02\\n\");\n\t\t\tgoto beach;\n\t\t}\n\n\t\tbool has_large_entries = cache->n_hdr > 1;\n\t\tif (has_large_entries) {\n\t\t\tut64 entries_size = sizeof (cache_locsym_entry_large_t) * info->entriesCount;\n\t\t\tcache_locsym_entry_large_t *large_entries = R_NEWS0 (cache_locsym_entry_large_t, info->entriesCount);\n\t\t\tif (!large_entries) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (cache->buf, hdr->localSymbolsOffset + info->entriesOffset, (ut8*) large_entries, \"lii\",\n\t\t\t\t\tinfo->entriesCount) != entries_size) {\n\t\t\t\teprintf (\"locsym err 03\\n\");\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tentries = large_entries;\n\t\t} else {\n\t\t\tut64 entries_size = sizeof (cache_locsym_entry_t) * info->entriesCount;\n\t\t\tcache_locsym_entry_t *regular_entries = R_NEWS0 (cache_locsym_entry_t, info->entriesCount);\n\t\t\tif (!regular_entries) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (cache->buf, hdr->localSymbolsOffset + info->entriesOffset, (ut8*) regular_entries, \"iii\",\n\t\t\t\t\tinfo->entriesCount) != entries_size) {\n\t\t\t\teprintf (\"locsym err 04\\n\");\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tentries = regular_entries;\n\t\t}\n\t\tRDyldLocSym * locsym = R_NEW0 (RDyldLocSym);\n\t\tif (!locsym) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tmatch_bin_entries (cache, entries);\n\n\t\tlocsym->local_symbols_offset = hdr->localSymbolsOffset;\n\t\tlocsym->nlists_offset = info->nlistOffset;\n\t\tlocsym->nlists_count = info->nlistCount;\n\t\tlocsym->strings_offset = info->stringsOffset;\n\t\tlocsym->strings_size = info->stringsSize;\n\n\t\tfree (info);\n\t\tfree (entries);\n\n\t\treturn locsym;\n\nbeach:\n\t\tfree (info);\n\t\tfree (entries);\n\n\t\teprintf (\"dyldcache: malformed local symbols metadata\\n\");\n\t\tbreak;\n\t}\n\treturn NULL;\n}\n\nstatic ut64 rebase_infos_get_slide(RDyldCache *cache) {\n\tif (!cache->rebase_infos || !cache->rebase_infos->length) {\n\t\treturn 0;\n\t}\n\n\tsize_t i;\n\tfor (i = 0; i < cache->rebase_infos->length; i++) {\n\t\tif (cache->rebase_infos->entries[i].info) {\n\t\t\treturn cache->rebase_infos->entries[i].info->slide;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void symbols_from_locsym(RDyldCache *cache, RDyldBinImage *bin, RList *symbols, SetU *hash) {\n\tRDyldLocSym *locsym = cache->locsym;\n\tif (!locsym) {\n\t\treturn;\n\t}\n\n\tif (bin->nlist_start_index >= locsym->nlists_count ||\n\t\t\tbin->nlist_start_index + bin->nlist_count > locsym->nlists_count) {\n\t\teprintf (\"dyldcache: malformed local symbol entry\\n\");\n\t\treturn;\n\t}\n\n\tut64 nlists_size = sizeof (struct MACH0_(nlist)) * bin->nlist_count;\n\tstruct MACH0_(nlist) *nlists = R_NEWS0 (struct MACH0_(nlist), bin->nlist_count);\n\tif (!nlists) {\n\t\treturn;\n\t}\n\tut64 nlists_offset = locsym->local_symbols_offset + locsym->nlists_offset +\n\t\tbin->nlist_start_index * sizeof (struct MACH0_(nlist));\n\tif (r_buf_fread_at (cache->buf, nlists_offset, (ut8*) nlists, \"iccsl\", bin->nlist_count) != nlists_size) {\n\t\tfree (nlists);\n\t\treturn;\n\t}\n\n\tut32 j;\n\tfor (j = 0; j != bin->nlist_count; j++) {\n\t\tstruct MACH0_(nlist) *nlist = &nlists[j];\n\t\tif (set_u_contains (hash, (ut64)nlist->n_value)) {\n\t\t\tcontinue;\n\t\t}\n\t\tset_u_add (hash, (ut64)nlist->n_value);\n\t\tif (nlist->n_strx >= locsym->strings_size) {\n\t\t\tcontinue;\n\t\t}\n\t\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\t\tif (!sym) {\n\t\t\tbreak;\n\t\t}\n\t\tsym->type = \"LOCAL\";\n\t\tsym->vaddr = nlist->n_value;\n\t\tut64 slide = rebase_infos_get_slide (cache);\n\t\tsym->paddr = va2pa (nlist->n_value, cache->n_maps, cache->maps, cache->buf, slide, NULL, NULL);\n\n\t\tchar *symstr =r_buf_get_string (cache->buf, locsym->local_symbols_offset + locsym->strings_offset + nlist->n_strx);\n\t\tif (symstr) {\n\t\t\tsym->name = symstr;\n\t\t} else {\n\t\t\tstatic ut32 k = 0;\n\t\t\tsym->name = r_str_newf (\"unk_local%d\", k++);\n\t\t}\n\n\t\tr_list_append (symbols, sym);\n\t}\n\n\tfree (nlists);\n}\n\nstatic void r_dyldcache_free(RDyldCache *cache) {\n\tif (!cache) {\n\t\treturn;\n\t}\n\n\tr_list_free (cache->bins);\n\tcache->bins = NULL;\n\tr_buf_free (cache->buf);\n\tcache->buf = NULL;\n\tif (cache->rebase_infos) {\n\t\tint i;\n\t\tfor (i = 0; i < cache->rebase_infos->length; i++) {\n\t\t\trebase_info_free (cache->rebase_infos->entries[i].info);\n\t\t\tcache->rebase_infos->entries[i].info = NULL;\n\t\t}\n\t\tR_FREE (cache->rebase_infos->entries);\n\t\tR_FREE (cache->rebase_infos);\n\t}\n\tR_FREE (cache->hdr);\n\tR_FREE (cache->maps);\n\tR_FREE (cache->maps_index);\n\tR_FREE (cache->hdr_offset);\n\tR_FREE (cache->accel);\n\tR_FREE (cache->locsym);\n\tR_FREE (cache->oi);\n\tR_FREE (cache);\n}\n\nstatic ut64 bin_obj_va2pa(ut64 p, ut32 *offset, ut32 *left, RBinFile *bf) {\n\tif (!bf || !bf->o || !bf->o->bin_obj) {\n\t\treturn 0;\n\t}\n\n\tRDyldCache *cache = (RDyldCache*) ((struct MACH0_(obj_t)*)bf->o->bin_obj)->user;\n\tif (!cache) {\n\t\treturn 0;\n\t}\n\n\tut64 slide = rebase_infos_get_slide (cache);\n\tut64 res = va2pa (p, cache->n_maps, cache->maps, cache->buf, slide, offset, left);\n\tif (res == UT64_MAX) {\n\t\tres = 0;\n\t}\n\treturn res;\n}\n\nstatic struct MACH0_(obj_t) *bin_to_mach0(RBinFile *bf, RDyldBinImage *bin) {\n\tif (!bin || !bf) {\n\t\treturn NULL;\n\t}\n\n\tRDyldCache *cache = (RDyldCache*) bf->o->bin_obj;\n\tif (!cache) {\n\t\treturn NULL;\n\t}\n\n\tRBuffer *buf = r_buf_new_slice (cache->buf, bin->hdr_offset, r_buf_size (cache->buf) - bin->hdr_offset);\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\n\tstruct MACH0_(opts_t) opts;\n\tMACH0_(opts_set_default) (&opts, bf);\n\topts.header_at = bin->header_at - bin->hdr_offset;\n\topts.symbols_off = bin->symbols_off;\n\n\tstruct MACH0_(obj_t) *mach0 = MACH0_(new_buf) (buf, &opts);\n\n\tmach0->user = cache;\n\tmach0->va2pa = &bin_obj_va2pa;\n\n\tr_buf_free (buf);\n\n\treturn mach0;\n}\n\nstatic int prot2perm(int x) {\n\tint r = 0;\n\tif (x & 1) {\n\t\tr |= 4;\n\t}\n\tif (x & 2) {\n\t\tr |= 2;\n\t}\n\tif (x & 4) {\n\t\tr |= 1;\n\t}\n\treturn r;\n}\n\nstatic ut32 dumb_ctzll(ut64 x) {\n\tut64 result = 0;\n\tint i, j;\n\tfor (i = 0; i < 64; i += 8) {\n\t\tut8 byte = (x >> i) & 0xff;\n\t\tif (!byte) {\n\t\t\tresult += 8;\n\t\t} else {\n\t\t\tfor (j = 0; j < 8; j++) {\n\t\t\t\tif (!((byte >> j) & 1)) {\n\t\t\t\t\tresult++;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}\n\nstatic ut64 estimate_slide(RBinFile *bf, RDyldCache *cache, ut64 value_mask, ut64 value_add) {\n\tut64 slide = 0;\n\tif (cache->n_hdr > 1) {\n\t\treturn slide;\n\t}\n\tut64 *classlist = malloc (64);\n\tif (!classlist) {\n\t\tgoto beach;\n\t}\n\n\tRListIter *iter;\n\tRDyldBinImage *bin;\n\tr_list_foreach (cache->bins, iter, bin) {\n\t\tbool found_sample = false;\n\n\t\tstruct MACH0_(opts_t) opts = {0};\n\t\topts.verbose = bf->rbin->verbose;\n\t\topts.header_at = bin->header_at;\n\t\topts.symbols_off = 0;\n\n\t\tstruct MACH0_(obj_t) *mach0 = MACH0_(new_buf) (cache->buf, &opts);\n\t\tif (!mach0) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tstruct section_t *sections = NULL;\n\t\tif (!(sections = MACH0_(get_sections) (mach0))) {\n\t\t\tMACH0_(mach0_free) (mach0);\n\t\t\tgoto beach;\n\t\t}\n\n\t\tint i;\n\t\tint incomplete = 2;\n\t\tint classlist_idx = 0, data_idx = 0;\n\t\tfor (i = 0; !sections[i].last && incomplete; i++) {\n\t\t\tif (sections[i].size == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strstr (sections[i].name, \"__objc_classlist\")) {\n\t\t\t\tincomplete--;\n\t\t\t\tclasslist_idx = i;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strstr (sections[i].name, \"__objc_data\")) {\n\t\t\t\tincomplete--;\n\t\t\t\tdata_idx = i;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (incomplete) {\n\t\t\tgoto next_bin;\n\t\t}\n\n\t\tint classlist_sample_size = R_MIN (64, sections[classlist_idx].size);\n\t\tint n_classes = classlist_sample_size / 8;\n\t\tut64 sect_offset = sections[classlist_idx].offset + bin->hdr_offset;\n\n\t\tif (r_buf_fread_at (cache->buf, sect_offset, (ut8*) classlist, \"l\", n_classes) != classlist_sample_size) {\n\t\t\tgoto next_bin;\n\t\t}\n\n\t\tut64 data_addr = sections[data_idx].addr;\n\t\tut64 data_tail = data_addr & 0xfff;\n\t\tut64 data_tail_end = (data_addr + sections[data_idx].size) & 0xfff;\n\t\tfor (i = 0; i < n_classes; i++) {\n\t\t\tut64 cl_addr = (classlist[i] & value_mask) + value_add;\n\t\t\tut64 cl_tail = cl_addr & 0xfff;\n\t\t\tif (cl_tail >= data_tail && cl_tail < data_tail_end) {\n\t\t\t\tut64 off = cl_tail - data_tail;\n\t\t\t\tslide = ((cl_addr - off) & value_mask) - (data_addr & value_mask);\n\t\t\t\tfound_sample = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\nnext_bin:\n\t\tMACH0_(mach0_free) (mach0);\n\t\tR_FREE (sections);\n\n\t\tif (found_sample) {\n\t\t\tbreak;\n\t\t}\n\t}\n\nbeach:\n\tR_FREE (classlist);\n\treturn slide;\n}\n\nstatic RDyldRebaseInfo *get_rebase_info(RBinFile *bf, RDyldCache *cache, ut64 slideInfoOffset, ut64 slideInfoSize, ut64 start_of_data, ut64 slide) {\n\tut8 *tmp_buf_1 = NULL;\n\tut8 *tmp_buf_2 = NULL;\n\tut8 *one_page_buf = NULL;\n\tRBuffer *cache_buf = cache->buf;\n\n\tut64 offset = slideInfoOffset;\n\tut32 slide_info_version = 0;\n\tif (r_buf_read_at (cache_buf, offset, (ut8*) &slide_info_version, 4) != 4) {\n\t\treturn NULL;\n\t}\n\n\tif (slide_info_version == 3) {\n\t\tcache_slide3_t slide_info;\n\t\tut64 size = sizeof (cache_slide3_t);\n\t\tif (r_buf_fread_at (cache_buf, offset, (ut8*) &slide_info, \"4i1l\", 1) < 20) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tut64 page_starts_offset = offset + size;\n\t\tut64 page_starts_size = slide_info.page_starts_count * 2;\n\n\t\tif (page_starts_size + size > slideInfoSize) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (page_starts_size > 0) {\n\t\t\ttmp_buf_1 = malloc (page_starts_size);\n\t\t\tif (!tmp_buf_1) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (cache_buf, page_starts_offset, tmp_buf_1, \"s\", slide_info.page_starts_count) != page_starts_size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\n\t\tif (slide_info.page_size > 0) {\n\t\t\tone_page_buf = malloc (slide_info.page_size);\n\t\t\tif (!one_page_buf) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\n\t\tRDyldRebaseInfo3 *rebase_info = R_NEW0 (RDyldRebaseInfo3);\n\t\tif (!rebase_info) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\trebase_info->version = 3;\n\t\trebase_info->delta_mask = 0x3ff8000000000000ULL;\n\t\trebase_info->delta_shift = 51;\n\t\trebase_info->start_of_data = start_of_data;\n\t\trebase_info->page_starts = (ut16*) tmp_buf_1;\n\t\trebase_info->page_starts_count = slide_info.page_starts_count;\n\t\trebase_info->auth_value_add = slide_info.auth_value_add;\n\t\trebase_info->page_size = slide_info.page_size;\n\t\trebase_info->one_page_buf = one_page_buf;\n\t\tif (slide == UT64_MAX) {\n\t\t\trebase_info->slide = estimate_slide (bf, cache, 0x7ffffffffffffULL, 0);\n\t\t\tif (rebase_info->slide) {\n\t\t\t\teprintf (\"dyldcache is slid: 0x%\"PFMT64x\"\\n\", rebase_info->slide);\n\t\t\t}\n\t\t} else {\n\t\t\trebase_info->slide = slide;\n\t\t}\n\n\t\treturn (RDyldRebaseInfo*) rebase_info;\n\t} else if (slide_info_version == 2 || slide_info_version == 4) {\n\t\tcache_slide2_t slide_info;\n\t\tut64 size = sizeof (cache_slide2_t);\n\t\tif (r_buf_fread_at (cache_buf, offset, (ut8*) &slide_info, \"6i2l\", 1) != size) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (slide_info.page_starts_offset == 0 ||\n\t\t\tslide_info.page_starts_offset > slideInfoSize ||\n\t\t\tslide_info.page_starts_offset + slide_info.page_starts_count * 2 > slideInfoSize) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (slide_info.page_extras_offset == 0 ||\n\t\t\tslide_info.page_extras_offset > slideInfoSize ||\n\t\t\tslide_info.page_extras_offset + slide_info.page_extras_count * 2 > slideInfoSize) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (slide_info.page_starts_count > 0) {\n\t\t\tut64 size = slide_info.page_starts_count * 2;\n\t\t\tut64 at = slideInfoOffset + slide_info.page_starts_offset;\n\t\t\ttmp_buf_1 = malloc (size);\n\t\t\tif (!tmp_buf_1) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (cache_buf, at, tmp_buf_1, \"s\", slide_info.page_starts_count) != size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\n\t\tif (slide_info.page_extras_count > 0) {\n\t\t\tut64 size = slide_info.page_extras_count * 2;\n\t\t\tut64 at = slideInfoOffset + slide_info.page_extras_offset;\n\t\t\ttmp_buf_2 = malloc (size);\n\t\t\tif (!tmp_buf_2) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (cache_buf, at, tmp_buf_2, \"s\", slide_info.page_extras_count) != size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\n\t\tif (slide_info.page_size > 0) {\n\t\t\tone_page_buf = malloc (slide_info.page_size);\n\t\t\tif (!one_page_buf) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\n\t\tRDyldRebaseInfo2 *rebase_info = R_NEW0 (RDyldRebaseInfo2);\n\t\tif (!rebase_info) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\trebase_info->version = slide_info_version;\n\t\trebase_info->start_of_data = start_of_data;\n\t\trebase_info->page_starts = (ut16*) tmp_buf_1;\n\t\trebase_info->page_starts_count = slide_info.page_starts_count;\n\t\trebase_info->page_extras = (ut16*) tmp_buf_2;\n\t\trebase_info->page_extras_count = slide_info.page_extras_count;\n\t\trebase_info->value_add = slide_info.value_add;\n\t\trebase_info->delta_mask = slide_info.delta_mask;\n\t\trebase_info->value_mask = ~rebase_info->delta_mask;\n\t\trebase_info->delta_shift = dumb_ctzll (rebase_info->delta_mask) - 2;\n\t\trebase_info->page_size = slide_info.page_size;\n\t\trebase_info->one_page_buf = one_page_buf;\n\t\tif (slide == UT64_MAX) {\n\t\t\trebase_info->slide = estimate_slide (bf, cache, rebase_info->value_mask, rebase_info->value_add);\n\t\t\tif (rebase_info->slide) {\n\t\t\t\teprintf (\"dyldcache is slid: 0x%\"PFMT64x\"\\n\", rebase_info->slide);\n\t\t\t}\n\t\t} else {\n\t\t\trebase_info->slide = slide;\n\t\t}\n\n\t\treturn (RDyldRebaseInfo*) rebase_info;\n\t} else if (slide_info_version == 1) {\n\t\tcache_slide1_t slide_info;\n\t\tut64 size = sizeof (cache_slide1_t);\n\t\tif (r_buf_fread_at (cache_buf, offset, (ut8*) &slide_info, \"6i\", 1) != size) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (slide_info.toc_offset == 0 ||\n\t\t\tslide_info.toc_offset > slideInfoSize ||\n\t\t\tslide_info.toc_offset + slide_info.toc_count * 2 > slideInfoSize) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (slide_info.entries_offset == 0 ||\n\t\t\tslide_info.entries_offset > slideInfoSize ||\n\t\t\tslide_info.entries_offset + slide_info.entries_count * slide_info.entries_size > slideInfoSize) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (slide_info.toc_count > 0) {\n\t\t\tut64 size = slide_info.toc_count * 2;\n\t\t\tut64 at = slideInfoOffset + slide_info.toc_offset;\n\t\t\ttmp_buf_1 = malloc (size);\n\t\t\tif (!tmp_buf_1) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (cache_buf, at, tmp_buf_1, \"s\", slide_info.toc_count) != size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\n\t\tif (slide_info.entries_count > 0) {\n\t\t\tut64 size = (ut64) slide_info.entries_count * (ut64) slide_info.entries_size;\n\t\t\tut64 at = slideInfoOffset + slide_info.entries_offset;\n\t\t\ttmp_buf_2 = malloc (size);\n\t\t\tif (!tmp_buf_2) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (r_buf_read_at (cache_buf, at, tmp_buf_2, size) != size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\n\t\tone_page_buf = malloc (4096);\n\t\tif (!one_page_buf) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tRDyldRebaseInfo1 *rebase_info = R_NEW0 (RDyldRebaseInfo1);\n\t\tif (!rebase_info) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\trebase_info->version = 1;\n\t\trebase_info->start_of_data = start_of_data;\n\t\trebase_info->one_page_buf = one_page_buf;\n\t\trebase_info->page_size = 4096;\n\t\trebase_info->toc = (ut16*) tmp_buf_1;\n\t\trebase_info->toc_count = slide_info.toc_count;\n\t\trebase_info->entries = tmp_buf_2;\n\t\trebase_info->entries_size = slide_info.entries_size;\n\t\tif (slide == UT64_MAX) {\n\t\t\trebase_info->slide = estimate_slide (bf, cache, UT64_MAX, 0);\n\t\t\tif (rebase_info->slide) {\n\t\t\t\teprintf (\"dyldcache is slid: 0x%\"PFMT64x\"\\n\", rebase_info->slide);\n\t\t\t}\n\t\t} else {\n\t\t\trebase_info->slide = slide;\n\t\t}\n\n\t\treturn (RDyldRebaseInfo*) rebase_info;\n\t} else {\n\t\teprintf (\"unsupported slide info version %d\\n\", slide_info_version);\n\t\treturn NULL;\n\t}\n\nbeach:\n\tR_FREE (tmp_buf_1);\n\tR_FREE (tmp_buf_2);\n\tR_FREE (one_page_buf);\n\treturn NULL;\n}\n\nstatic RDyldRebaseInfos *get_rebase_infos(RBinFile *bf, RDyldCache *cache) {\n\tRDyldRebaseInfos *result = R_NEW0 (RDyldRebaseInfos);\n\tif (!result) {\n\t\treturn NULL;\n\t}\n\n\tif (!cache->hdr->slideInfoOffset || !cache->hdr->slideInfoSize) {\n\t\tut32 total_slide_infos = 0;\n\t\tut32 n_slide_infos[MAX_N_HDR];\n\n\t\tut32 i;\n\t\tfor (i = 0; i < cache->n_hdr && i < MAX_N_HDR; i++) {\n\t\t\tut64 hdr_offset = cache->hdr_offset[i];\n\t\t\tif ((n_slide_infos[i] = r_buf_read_le32_at (cache->buf, 0x13c + hdr_offset)) == UT32_MAX) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\ttotal_slide_infos += n_slide_infos[i];\n\t\t}\n\n\t\tif (!total_slide_infos) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tRDyldRebaseInfosEntry * infos = R_NEWS0 (RDyldRebaseInfosEntry, total_slide_infos);\n\t\tif (!infos) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tut32 k = 0;\n\t\tfor (i = 0; i < cache->n_hdr && i < MAX_N_HDR; i++) {\n\t\t\tut64 hdr_offset = cache->hdr_offset[i];\n\t\t\tut64 slide_infos_offset;\n\t\t\tif (!n_slide_infos[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ((slide_infos_offset = r_buf_read_le32_at (cache->buf, 0x138 + hdr_offset)) == UT32_MAX) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!slide_infos_offset) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tslide_infos_offset += hdr_offset;\n\n\t\t\tut32 j;\n\t\t\tRDyldRebaseInfo *prev_info = NULL;\n\t\t\tfor (j = 0; j < n_slide_infos[i]; j++) {\n\t\t\t\tut64 offset = slide_infos_offset + j * sizeof (cache_mapping_slide);\n\t\t\t\tcache_mapping_slide entry;\n\t\t\t\tif (r_buf_fread_at (cache->buf, offset, (ut8*)&entry, \"6lii\", 1) != sizeof (cache_mapping_slide)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (entry.slideInfoOffset && entry.slideInfoSize) {\n\t\t\t\t\tinfos[k].start = entry.fileOffset + hdr_offset;\n\t\t\t\t\tinfos[k].end = infos[k].start + entry.size;\n\t\t\t\t\tut64 slide = prev_info ? prev_info->slide : UT64_MAX;\n\t\t\t\t\tinfos[k].info = get_rebase_info (bf, cache, entry.slideInfoOffset + hdr_offset, entry.slideInfoSize, entry.fileOffset + hdr_offset, slide);\n\t\t\t\t\tprev_info = infos[k].info;\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!k) {\n\t\t\tfree (infos);\n\t\t\tgoto beach;\n\t\t}\n\n\t\tif (k < total_slide_infos) {\n\t\t\tRDyldRebaseInfosEntry * pruned_infos = R_NEWS0 (RDyldRebaseInfosEntry, k);\n\t\t\tif (!pruned_infos) {\n\t\t\t\tfree (infos);\n\t\t\t\tgoto beach;\n\t\t\t}\n\n\t\t\tmemcpy (pruned_infos, infos, sizeof (RDyldRebaseInfosEntry) * k);\n\t\t\tfree (infos);\n\t\t\tinfos = pruned_infos;\n\t\t}\n\n\t\tresult->entries = infos;\n\t\tresult->length = k;\n\t\treturn result;\n\t}\n\n\tif (cache->hdr->mappingCount > 1) {\n\t\tRDyldRebaseInfosEntry * infos = R_NEWS0 (RDyldRebaseInfosEntry, 1);\n\t\tif (!infos) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tinfos[0].start = cache->maps[1].fileOffset;\n\t\tinfos[0].end = infos[0].start + cache->maps[1].size;\n\t\tinfos[0].info = get_rebase_info (bf, cache, cache->hdr->slideInfoOffset, cache->hdr->slideInfoSize, infos[0].start, UT64_MAX);\n\n\t\tresult->entries = infos;\n\t\tresult->length = 1;\n\t\treturn result;\n\t}\n\nbeach:\n\tfree (result);\n\treturn NULL;\n}\n\nstatic bool check_magic(const char *magic) {\n\treturn !strcmp (magic, \"dyld_v1   arm64\")\n\t\t|| !strcmp (magic, \"dyld_v1  arm64e\")\n\t\t|| !strcmp (magic, \"dyld_v1  x86_64\")\n\t\t|| !strcmp (magic, \"dyld_v1 x86_64h\");\n}\n\nstatic bool check_buffer(RBinFile *bf, RBuffer *buf) {\n\tif (r_buf_size (buf) < 32) {\n\t\treturn false;\n\t}\n\n\tchar hdr[17] = {0};\n\tint rhdr = r_buf_read_at (buf, 0, (ut8 *)&hdr, sizeof (hdr) - 1);\n\tif (rhdr != sizeof (hdr) - 1) {\n\t\treturn false;\n\t}\n\n\treturn check_magic (hdr);\n}\n\nstatic cache_imgxtr_t *read_cache_imgextra(RBuffer *cache_buf, cache_hdr_t *hdr, cache_accel_t *accel) {\n\tif (!cache_buf || !hdr || !hdr->imagesCount || !accel || !accel->imageExtrasCount || !accel->imagesExtrasOffset) {\n\t\treturn NULL;\n\t}\n\n\tut64 size = sizeof (cache_imgxtr_t) * accel->imageExtrasCount;\n\tcache_imgxtr_t *images = R_NEWS0 (cache_imgxtr_t, accel->imageExtrasCount);\n\tif (!images) {\n\t\treturn NULL;\n\t}\n\n\tif (r_buf_fread_at (cache_buf, accel->imagesExtrasOffset, (ut8*) images, \"ll4i\", accel->imageExtrasCount) != size) {\n\t\tR_FREE (images);\n\t\treturn NULL;\n\t}\n\n\treturn images;\n}\n\nstatic char *get_lib_name(RBuffer *cache_buf, cache_img_t *img) {\n\tchar file[256];\n\tchar *lib_name = file;\n\tif (r_buf_read_at (cache_buf, img->pathFileOffset, (ut8*) &file, sizeof (file)) == sizeof (file)) {\n\t\tfile[255] = 0;\n\t\t/*char * last_slash = strrchr (file, '/');\n\t\tif (last_slash && *last_slash) {\n\t\t\tlib_name = last_slash + 1;\n\t\t}*/\n\t\treturn strdup (lib_name);\n\t}\n\treturn strdup (\"FAIL\");\n}\n\nstatic int string_contains(const void *a, const void *b) {\n\treturn !strstr ((const char*) a, (const char*) b);\n}\n\nstatic HtPU *create_path_to_index(RBuffer *cache_buf, cache_img_t *img, cache_hdr_t *hdr) {\n\tHtPU *path_to_idx = ht_pu_new0 ();\n\tif (!path_to_idx) {\n\t\treturn NULL;\n\t}\n\tsize_t i;\n\tfor (i = 0; i != hdr->imagesCount; i++) {\n\t\tchar file[256];\n\t\tif (r_buf_read_at (cache_buf, img[i].pathFileOffset, (ut8*) &file, sizeof (file)) != sizeof (file)) {\n\t\t\tcontinue;\n\t\t}\n\t\tfile[sizeof (file) - 1] = 0;\n\t\tht_pu_insert (path_to_idx, file, (ut64)i);\n\n\t\tconst char versions_pattern[] = \".framework/Versions/\";\n\t\tchar *versions = strstr (file, versions_pattern);\n\t\tif (versions) {\n\t\t\tchar *next_slash = strchr (versions + 20, '/');\n\t\t\tif (next_slash) {\n\t\t\t\tchar *tail = strdup (next_slash);\n\t\t\t\tif (!tail) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstrcpy (versions + 10, tail);\n\t\t\t\tfree (tail);\n\t\t\t\tht_pu_insert (path_to_idx, file, (ut64)i);\n\t\t\t}\n\t\t}\n\t}\n\treturn path_to_idx;\n}\n\nstatic void carve_deps_at_address(RDyldCache *cache, cache_img_t *img, HtPU *path_to_idx, ut64 address, int *deps, bool printing) {\n\tut64 pa = va2pa (address, cache->n_maps, cache->maps, cache->buf, 0, NULL, NULL);\n\tif (pa == UT64_MAX) {\n\t\treturn;\n\t}\n\tstruct MACH0_(mach_header) mh;\n\tif (r_buf_fread_at (cache->buf, pa, (ut8*) &mh, \"8i\", 1) != sizeof (struct MACH0_(mach_header))) {\n\t\treturn;\n\t}\n\tif (mh.magic != MH_MAGIC_64 || mh.sizeofcmds == 0) {\n\t\treturn;\n\t}\n\tut64 cmds_at = pa + sizeof (struct MACH0_(mach_header));\n\tut8 *cmds = malloc (mh.sizeofcmds + 1);\n\tif (!cmds || r_buf_read_at (cache->buf, cmds_at, cmds, mh.sizeofcmds) != mh.sizeofcmds) {\n\t\tgoto beach;\n\t}\n\tcmds[mh.sizeofcmds] = 0;\n\tut8 *cursor = cmds;\n\tut8 *end = cmds + mh.sizeofcmds;\n\twhile (cursor < end) {\n\t\tut32 cmd = r_read_le32 (cursor);\n\t\tut32 cmdsize = r_read_le32 (cursor + sizeof (ut32));\n\t\tif (cmd == LC_LOAD_DYLIB ||\n\t\t\t\tcmd == LC_LOAD_WEAK_DYLIB ||\n\t\t\t\tcmd == LC_REEXPORT_DYLIB ||\n\t\t\t\tcmd == LC_LOAD_UPWARD_DYLIB) {\n\t\t\tbool found;\n\t\t\tif (cursor + 24 >= end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst char *key = (const char *) cursor + 24;\n\t\t\tsize_t dep_index = (size_t)ht_pu_find (path_to_idx, key, &found);\n\t\t\tif (!found || dep_index >= cache->hdr->imagesCount) {\n\t\t\t\teprintf (\"Warning: alien dep '%s'\\n\", key);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdeps[dep_index]++;\n\t\t\tif (printing) {\n\t\t\t\teprintf (\"-> %s\\n\", key);\n\t\t\t}\n\t\t}\n\t\tcursor += cmdsize;\n\t}\n\nbeach:\n\tfree (cmds);\n}\n\nstatic ut64 resolve_symbols_off(RDyldCache *cache, ut64 pa) {\n\tstruct MACH0_(mach_header) mh;\n\tif (r_buf_fread_at (cache->buf, pa, (ut8*) &mh, \"8i\", 1) != sizeof (struct MACH0_(mach_header))) {\n\t\treturn 0;\n\t}\n\tif (mh.magic != MH_MAGIC_64 || mh.sizeofcmds == 0) {\n\t\treturn 0;\n\t}\n\tut64 cmds_at = pa + sizeof (struct MACH0_(mach_header));\n\tut64 cursor = cmds_at;\n\tut64 end = cursor + mh.sizeofcmds;\n\twhile (cursor < end) {\n\t\tut32 cmd = r_buf_read_le32_at (cache->buf, cursor);\n\t\tif (cmd == UT32_MAX) {\n\t\t\treturn 0;\n\t\t}\n\t\tut32 cmdsize = r_buf_read_le32_at (cache->buf, cursor + sizeof (ut32));\n\t\tif (cmdsize == UT32_MAX) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (cmd == LC_SEGMENT || cmd == LC_SEGMENT_64) {\n\t\t\tchar segname[17];\n\t\t\tsegname[16] = 0;\n\t\t\tif (r_buf_read_at (cache->buf, cursor + 2 * sizeof (ut32), (ut8 *)segname, 16) != 16) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!strncmp (segname, \"__LINKEDIT\", 16)) {\n\t\t\t\tut64 vmaddr = r_buf_read_le64_at (cache->buf, cursor + 2 * sizeof (ut32) + 16);\n\t\t\t\tif (vmaddr == UT64_MAX) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\tut32 i,j;\n\t\t\t\tfor (i = 0; i < cache->n_hdr; i++) {\n\t\t\t\t\tcache_hdr_t *hdr = &cache->hdr[i];\n\t\t\t\t\tut64 hdr_offset = cache->hdr_offset[i];\n\t\t\t\t\tut32 maps_index = cache->maps_index[i];\n\t\t\t\t\tfor (j = 0; j < hdr->mappingCount; j++) {\n\t\t\t\t\t\tut64 map_start = cache->maps[maps_index + j].address;\n\t\t\t\t\t\tut64 map_end = map_start + cache->maps[maps_index + j].size;\n\t\t\t\t\t\tif (vmaddr >= map_start && vmaddr < map_end) {\n\t\t\t\t\t\t\treturn hdr_offset;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcursor += cmdsize;\n\t}\n\treturn 0;\n}\n\nstatic RList *create_cache_bins(RBinFile *bf, RDyldCache *cache) {\n\tRList *bins = r_list_newf ((RListFree)free_bin);\n\tut16 *depArray = NULL;\n\tcache_imgxtr_t *extras = NULL;\n\tif (!bins) {\n\t\treturn NULL;\n\t}\n\n\tchar *target_libs = NULL;\n\tRList *target_lib_names = NULL;\n\tint *deps = NULL;\n\ttarget_libs = r_sys_getenv (\"R_DYLDCACHE_FILTER\");\n\tif (target_libs) {\n\t\ttarget_lib_names = r_str_split_list (target_libs, \":\", 0);\n\t\tif (!target_lib_names) {\n\t\t\tr_list_free (bins);\n\t\t\treturn NULL;\n\t\t}\n\t\tdeps = R_NEWS0 (int, cache->hdr->imagesCount);\n\t\tif (!deps) {\n\t\t\tr_list_free (bins);\n\t\t\tr_list_free (target_lib_names);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tut32 i;\n\tfor (i = 0; i < cache->n_hdr; i++) {\n\t\tcache_hdr_t *hdr = &cache->hdr[i];\n\t\tut64 hdr_offset = cache->hdr_offset[i];\n\t\tut32 maps_index = cache->maps_index[i];\n\t\tcache_img_t *img = read_cache_images (cache->buf, hdr, hdr_offset);\n\t\tif (!img) {\n\t\t\tgoto next;\n\t\t}\n\n\t\tut32 j;\n\t\tif (target_libs) {\n\t\t\tHtPU *path_to_idx = NULL;\n\t\t\tif (cache->accel) {\n\t\t\t\tdepArray = R_NEWS0 (ut16, cache->accel->depListCount);\n\t\t\t\tif (!depArray) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\n\t\t\t\tif (r_buf_fread_at (cache->buf, cache->accel->depListOffset, (ut8*) depArray, \"s\", cache->accel->depListCount) != cache->accel->depListCount * 2) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\n\t\t\t\textras = read_cache_imgextra (cache->buf, hdr, cache->accel);\n\t\t\t\tif (!extras) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpath_to_idx = create_path_to_index (cache->buf, img, hdr);\n\t\t\t}\n\n\t\t\tfor (j = 0; j < hdr->imagesCount; j++) {\n\t\t\t\tbool printing = !deps[j];\n\t\t\t\tchar *lib_name = get_lib_name (cache->buf, &img[j]);\n\t\t\t\tif (!lib_name) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (strstr (lib_name, \"libobjc.A.dylib\")) {\n\t\t\t\t\tdeps[j]++;\n\t\t\t\t}\n\t\t\t\tif (!r_list_find (target_lib_names, lib_name, string_contains)) {\n\t\t\t\t\tR_FREE (lib_name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (printing) {\n\t\t\t\t\teprintf (\"FILTER: %s\\n\", lib_name);\n\t\t\t\t}\n\t\t\t\tR_FREE (lib_name);\n\t\t\t\tdeps[j]++;\n\n\t\t\t\tif (extras && depArray) {\n\t\t\t\t\tut32 k;\n\t\t\t\t\tfor (k = extras[j].dependentsStartArrayIndex; depArray[k] != 0xffff; k++) {\n\t\t\t\t\t\tut16 dep_index = depArray[k] & 0x7fff;\n\t\t\t\t\t\tdeps[dep_index]++;\n\n\t\t\t\t\t\tchar *dep_name = get_lib_name (cache->buf, &img[dep_index]);\n\t\t\t\t\t\tif (!dep_name) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (printing) {\n\t\t\t\t\t\t\teprintf (\"-> %s\\n\", dep_name);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree (dep_name);\n\t\t\t\t\t}\n\t\t\t\t} else if (path_to_idx) {\n\t\t\t\t\tcarve_deps_at_address (cache, img, path_to_idx, img[j].address, deps, printing);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tht_pu_free (path_to_idx);\n\t\t\tR_FREE (depArray);\n\t\t\tR_FREE (extras);\n\t\t}\n\n\t\tfor (j = 0; j < hdr->imagesCount; j++) {\n\t\t\tif (deps && !deps[j]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tut64 pa = va2pa (img[j].address, hdr->mappingCount, &cache->maps[maps_index], cache->buf, 0, NULL, NULL);\n\t\t\tif (pa == UT64_MAX) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tut8 magicbytes[4];\n\t\t\tr_buf_read_at (cache->buf, pa, magicbytes, 4);\n\t\t\tint magic = r_read_le32 (magicbytes);\n\t\t\tswitch (magic) {\n\t\t\tcase MH_MAGIC_64:\n\t\t\t{\n\t\t\t\tchar file[256];\n\t\t\t\tRDyldBinImage *bin = R_NEW0 (RDyldBinImage);\n\t\t\t\tif (!bin) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t\tbin->header_at = pa;\n\t\t\t\tbin->hdr_offset = hdr_offset;\n\t\t\t\tbin->symbols_off = resolve_symbols_off (cache, pa);\n\t\t\t\tbin->va = img[j].address;\n\t\t\t\tif (r_buf_read_at (cache->buf, img[j].pathFileOffset, (ut8*) &file, sizeof (file)) == sizeof (file)) {\n\t\t\t\t\tfile[255] = 0;\n\t\t\t\t\tchar *last_slash = strrchr (file, '/');\n\t\t\t\t\tif (last_slash && *last_slash) {\n\t\t\t\t\t\tif (last_slash > file) {\n\t\t\t\t\t\t\tchar *scan = last_slash - 1;\n\t\t\t\t\t\t\twhile (scan > file && *scan != '/') {\n\t\t\t\t\t\t\t\tscan--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (*scan == '/') {\n\t\t\t\t\t\t\t\tbin->file = strdup (scan + 1);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbin->file = strdup (last_slash + 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbin->file = strdup (last_slash + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbin->file = strdup (file);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr_list_append (bins, bin);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\teprintf (\"Unknown sub-bin\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\nnext:\n\t\tR_FREE (depArray);\n\t\tR_FREE (extras);\n\t\tR_FREE (img);\n\t}\n\tif (r_list_empty (bins)) {\n\t\tr_list_free (bins);\n\t\tbins = NULL;\n\t}\n\tR_FREE (deps);\n\tR_FREE (target_libs);\n\tr_list_free (target_lib_names);\n\treturn bins;\n}\n\nstatic void rebase_bytes_v1(RDyldRebaseInfo1 *rebase_info, ut8 *buf, ut64 offset, int count, ut64 start_of_write) {\n\tint in_buf = 0;\n\twhile (in_buf < count) {\n\t\tut64 offset_in_data = offset - rebase_info->start_of_data;\n\t\tut64 page_index = offset_in_data / rebase_info->page_size;\n\t\tut64 page_offset = offset_in_data % rebase_info->page_size;\n\t\tut64 to_next_page = rebase_info->page_size - page_offset;\n\t\tut64 entry_index = page_offset / 32;\n\t\tut64 offset_in_entry = (page_offset % 32) / 4;\n\n\t\tif (entry_index >= rebase_info->entries_size) {\n\t\t\tin_buf += to_next_page;\n\t\t\toffset += to_next_page;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (page_index >= rebase_info->toc_count) {\n\t\t\tbreak;\n\t\t}\n\n\t\tut8 *entry = &rebase_info->entries[rebase_info->toc[page_index] * rebase_info->entries_size];\n\t\tut8 b = entry[entry_index];\n\n\t\tif (b & (1 << offset_in_entry)) {\n\t\t\tut64 value = r_read_le64 (buf + in_buf);\n\t\t\tvalue += rebase_info->slide;\n\t\t\tr_write_le64 (buf + in_buf, value);\n\t\t\tin_buf += 8;\n\t\t\toffset += 8;\n\t\t} else {\n\t\t\tin_buf += 4;\n\t\t\toffset += 4;\n\t\t}\n\t}\n}\n\nstatic void rebase_bytes_v2(RDyldRebaseInfo2 *rebase_info, ut8 *buf, ut64 offset, int count, ut64 start_of_write) {\n\tint in_buf = 0;\n\twhile (in_buf < count) {\n\t\tut64 offset_in_data = offset - rebase_info->start_of_data;\n\t\tut64 page_index = offset_in_data / rebase_info->page_size;\n\t\tut64 page_offset = offset_in_data % rebase_info->page_size;\n\t\tut64 to_next_page = rebase_info->page_size - page_offset;\n\n\t\tif (page_index >= rebase_info->page_starts_count) {\n\t\t\tgoto next_page;\n\t\t}\n\t\tut16 page_flag = rebase_info->page_starts[page_index];\n\n\t\tif (page_flag == DYLD_CACHE_SLIDE_PAGE_ATTR_NO_REBASE) {\n\t\t\tgoto next_page;\n\t\t}\n\n\t\tif (!(page_flag & DYLD_CACHE_SLIDE_PAGE_ATTR_EXTRA)) {\n\t\t\tut64 first_rebase_off = rebase_info->page_starts[page_index] * 4;\n\t\t\tif (first_rebase_off >= page_offset && first_rebase_off < page_offset + count) {\n\t\t\t\tut32 delta = 1;\n\t\t\t\twhile (delta) {\n\t\t\t\t\tut64 position = in_buf + first_rebase_off - page_offset;\n\t\t\t\t\tif (position >= count) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tut64 raw_value = r_read_le64 (buf + position);\n\t\t\t\t\tdelta = ((raw_value & rebase_info->delta_mask) >> rebase_info->delta_shift);\n\t\t\t\t\tif (position >= start_of_write) {\n\t\t\t\t\t\tut64 new_value = raw_value & rebase_info->value_mask;\n\t\t\t\t\t\tif (new_value != 0) {\n\t\t\t\t\t\t\tnew_value += rebase_info->value_add;\n\t\t\t\t\t\t\tnew_value += rebase_info->slide;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_write_le64 (buf + position, new_value);\n\t\t\t\t\t}\n\t\t\t\t\tfirst_rebase_off += delta;\n\t\t\t\t}\n\t\t\t}\n\t\t}\nnext_page:\n\t\tin_buf += to_next_page;\n\t\toffset += to_next_page;\n\t}\n}\n\nstatic void rebase_bytes_v3(RDyldRebaseInfo3 *rebase_info, ut8 *buf, ut64 offset, int count, ut64 start_of_write) {\n\tint in_buf = 0;\n\twhile (in_buf < count) {\n\t\tut64 offset_in_data = offset - rebase_info->start_of_data;\n\t\tut64 page_index = offset_in_data / rebase_info->page_size;\n\t\tut64 page_offset = offset_in_data % rebase_info->page_size;\n\t\tut64 to_next_page = rebase_info->page_size - page_offset;\n\n\t\tif (page_index >= rebase_info->page_starts_count) {\n\t\t\tgoto next_page;\n\t\t}\n\t\tut64 delta = rebase_info->page_starts[page_index];\n\n\t\tif (delta == DYLD_CACHE_SLIDE_V3_PAGE_ATTR_NO_REBASE) {\n\t\t\tgoto next_page;\n\t\t}\n\n\t\tut64 first_rebase_off = delta;\n\t\tif (first_rebase_off >= page_offset && first_rebase_off < page_offset + count) {\n\t\t\tdo {\n\t\t\t\tut64 position = in_buf + first_rebase_off - page_offset;\n\t\t\t\tif (position >= count) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tut64 raw_value = r_read_le64 (buf + position);\n\t\t\t\tdelta = ((raw_value & rebase_info->delta_mask) >> rebase_info->delta_shift) * 8;\n\t\t\t\tif (position >= start_of_write) {\n\t\t\t\t\tut64 new_value = 0;\n\t\t\t\t\tif (R_IS_PTR_AUTHENTICATED (raw_value)) {\n\t\t\t\t\t\tnew_value = (raw_value & 0xFFFFFFFFULL) + rebase_info->auth_value_add;\n\t\t\t\t\t\t// TODO: don't throw auth info away\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnew_value = ((raw_value << 13) & 0xFF00000000000000ULL) | (raw_value & 0x7ffffffffffULL);\n\t\t\t\t\t\tnew_value &= 0x00FFFFFFFFFFFFFFULL;\n\t\t\t\t\t}\n\t\t\t\t\tif (new_value != 0) {\n\t\t\t\t\t\tnew_value += rebase_info->slide;\n\t\t\t\t\t}\n\t\t\t\t\tr_write_le64 (buf + position, new_value);\n\t\t\t\t}\n\t\t\t\tfirst_rebase_off += delta;\n\t\t\t} while (delta);\n\t\t}\nnext_page:\n\t\tin_buf += to_next_page;\n\t\toffset += to_next_page;\n\t}\n}\n\nstatic RDyldRebaseInfo *rebase_info_by_range(RDyldRebaseInfos *infos, ut64 offset, int count) {\n\tint imid;\n\tint imin = 0;\n\tint imax = infos->length - 1;\n\n\twhile (imin < imax) {\n\t\timid = (imin + imax) / 2;\n\t\tRDyldRebaseInfosEntry *entry = &infos->entries[imid];\n\t\tif ((entry->end) <= offset) {\n\t\t\timin = imid + 1;\n\t\t} else {\n\t\t\timax = imid;\n\t\t}\n\t}\n\n\tRDyldRebaseInfosEntry *minEntry = &infos->entries[imin];\n\tif ((imax == imin) && (minEntry->start <= offset + count) && (minEntry->end >= offset)) {\n\t\treturn minEntry->info;\n\t}\n\treturn NULL;\n}\n\nstatic void rebase_bytes(RDyldRebaseInfo *rebase_info, ut8 *buf, ut64 offset, int count, ut64 start_of_write) {\n\tif (!rebase_info || !buf) {\n\t\treturn;\n\t}\n\n\tif (rebase_info->version == 3) {\n\t\trebase_bytes_v3 ((RDyldRebaseInfo3*) rebase_info, buf, offset, count, start_of_write);\n\t} else if (rebase_info->version == 2 || rebase_info->version == 4) {\n\t\trebase_bytes_v2 ((RDyldRebaseInfo2*) rebase_info, buf, offset, count, start_of_write);\n\t} else if (rebase_info->version == 1) {\n\t\trebase_bytes_v1 ((RDyldRebaseInfo1*) rebase_info, buf, offset, count, start_of_write);\n\t}\n}\n\nstatic int dyldcache_io_read(RIO *io, RIODesc *fd, ut8 *buf, int count) {\n\tr_return_val_if_fail (io, -1);\n\tRCore *core = (RCore*) io->corebind.core;\n\n\tif (!core || !core->bin || !core->bin->binfiles) {\n\t\treturn -1;\n\t}\n\n\tRDyldCache *cache = NULL;\n\tRListIter *iter;\n\tRBinFile *bf;\n\tr_list_foreach (core->bin->binfiles, iter, bf) {\n\t\tif (bf->fd == fd->fd ) {\n\t\t\tif (!strncmp ((char*) bf->o->bin_obj, \"dyldcac\", 7)) {\n\t\t\t\tcache = bf->o->bin_obj;\n\t\t\t} else {\n\t\t\t\tcache = ((struct MACH0_(obj_t)*) bf->o->bin_obj)->user;\n\t\t\t}\n\t\t\tif (pending_bin_files) {\n\t\t\t\tRListIter *to_remove = r_list_contains (pending_bin_files, bf);\n\t\t\t\tif (to_remove) {\n\t\t\t\t\tr_list_delete (pending_bin_files, to_remove);\n\t\t\t\t\tif (r_list_empty (pending_bin_files)) {\n\t\t\t\t\t\tr_list_free (pending_bin_files);\n\t\t\t\t\t\tpending_bin_files = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!cache) {\n\t\tr_list_foreach (pending_bin_files, iter, bf) {\n\t\t\tif (bf->fd == fd->fd && bf->o) {\n\t\t\t\tif (!strncmp ((char*) bf->o->bin_obj, \"dyldcac\", 7)) {\n\t\t\t\t\tcache = bf->o->bin_obj;\n\t\t\t\t} else {\n\t\t\t\t\tcache = ((struct MACH0_(obj_t)*) bf->o->bin_obj)->user;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (!cache || !cache->original_io_read) {\n\t\tif (fd->plugin->read == &dyldcache_io_read) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn fd->plugin->read (io, fd, buf, count);\n\t}\n\n\tRDyldRebaseInfo *rebase_info = rebase_info_by_range (cache->rebase_infos, io->off, count);\n\n\tint result = 0;\n\n\tif (rebase_info && count > 0) {\n\t\tut64 offset_in_data = io->off - rebase_info->start_of_data;\n\t\tut64 page_offset = offset_in_data % rebase_info->page_size;\n\n\t\tut64 internal_offset = io->off & ~(rebase_info->page_size - 1);\n\t\tut64 internal_end = io->off + count;\n\t\tint rounded_count = internal_end - internal_offset;\n\n\t\tut8 *internal_buf = rebase_info->one_page_buf;\n\t\tif (rounded_count > rebase_info->page_size) {\n\t\t\tinternal_buf = malloc (rounded_count);\n\t\t\tif (!internal_buf) {\n\t\t\t\teprintf (\"Cannot allocate memory for 'internal_buf'\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tut64 original_off = io->off;\n\t\tio->off = internal_offset;\n\n\t\tint internal_result = cache->original_io_read (io, fd, internal_buf, rounded_count);\n\n\t\tio->off = original_off;\n\n\t\tif (internal_result >= page_offset + count) {\n\t\t\trebase_bytes (rebase_info, internal_buf, internal_offset, internal_result, page_offset);\n\t\t\tresult = R_MIN (count, internal_result);\n\t\t\tmemcpy (buf, internal_buf + page_offset, result);\n\t\t} else {\n\t\t\teprintf (\"ERROR rebasing\\n\");\n\t\t\tresult = cache->original_io_read (io, fd, buf, count);\n\t\t}\n\n\t\tif (internal_buf != rebase_info->one_page_buf) {\n\t\t\tR_FREE (internal_buf);\n\t\t}\n\t} else {\n\t\tresult = cache->original_io_read (io, fd, buf, count);\n\t}\n\n\treturn result;\n}\n\nstatic void swizzle_io_read(RDyldCache *cache, RIO *io) {\n\tif (!io || !io->desc || !io->desc->plugin) {\n\t\treturn;\n\t}\n\n\tRIOPlugin *plugin = io->desc->plugin;\n\tcache->original_io_read = plugin->read;\n\tplugin->read = &dyldcache_io_read;\n}\n\nstatic cache_hdr_t *read_cache_header(RBuffer *cache_buf, ut64 offset) {\n\tif (!cache_buf) {\n\t\treturn NULL;\n\t}\n\n\tcache_hdr_t *hdr = R_NEW0 (cache_hdr_t);\n\tif (!hdr) {\n\t\treturn NULL;\n\t}\n\n\tut64 size = sizeof (cache_hdr_t);\n\tif (r_buf_fread_at (cache_buf, offset, (ut8*) hdr, \"16c4i7l16clii4l\", 1) != size) {\n\t\tR_FREE (hdr);\n\t\treturn NULL;\n\t}\n\tif (!check_magic (hdr->magic)) {\n\t\tR_FREE (hdr);\n\t\treturn NULL;\n\t}\n\n\tif (!hdr->imagesCount && !hdr->imagesOffset) {\n\t\thdr->imagesOffset = r_buf_read_le32_at (cache_buf, 0x1c0 + offset);\n\t\thdr->imagesCount = r_buf_read_le32_at (cache_buf, 0x1c4 + offset);\n\t}\n\treturn hdr;\n}\n\n\nstatic void populate_cache_headers(RDyldCache *cache) {\n\tcache->n_hdr = 0;\n\tRList *hdrs = r_list_newf (NULL);\n\tif (!hdrs) {\n\t\treturn;\n\t}\n\n\tcache_hdr_t *h;\n\tut64 offsets[MAX_N_HDR];\n\tut64 offset = 0;\n\tdo {\n\t\toffsets[cache->n_hdr] = offset;\n\t\th = read_cache_header (cache->buf, offset);\n\t\tif (!h) {\n\t\t\tbreak;\n\t\t}\n\t\tr_list_append (hdrs, h);\n\n\t\tut64 size = h->codeSignatureOffset + h->codeSignatureSize;\n\n#define SHIFT_MAYBE(x) \\\n\tif (x) { \\\n\t\tx += offset; \\\n\t}\n\n\t\tSHIFT_MAYBE (h->mappingOffset);\n\t\tSHIFT_MAYBE (h->imagesOffset);\n\t\tSHIFT_MAYBE (h->codeSignatureOffset);\n\t\tSHIFT_MAYBE (h->slideInfoOffset);\n\t\tSHIFT_MAYBE (h->localSymbolsOffset);\n\t\tSHIFT_MAYBE (h->branchPoolsOffset);\n\t\tSHIFT_MAYBE (h->imagesTextOffset);\n\n\t\toffset += size;\n\t\tcache->n_hdr++;\n\t} while (cache->n_hdr < MAX_N_HDR);\n\n\tif (!cache->n_hdr) {\n\t\tgoto beach;\n\t}\n\n\tcache->hdr = R_NEWS0 (cache_hdr_t, cache->n_hdr);\n\tif (!cache->hdr) {\n\t\tcache->n_hdr = 0;\n\t\tgoto beach;\n\t}\n\n\tcache->hdr_offset = R_NEWS0 (ut64, cache->n_hdr);\n\tif (!cache->hdr_offset) {\n\t\tcache->n_hdr = 0;\n\t\tR_FREE (cache->hdr);\n\t\tgoto beach;\n\t}\n\n\tmemcpy (cache->hdr_offset, offsets, cache->n_hdr * sizeof (ut64));\n\n\tut32 i = 0;\n\tRListIter *iter;\n\tcache_hdr_t *item;\n\tr_list_foreach (hdrs, iter, item) {\n\t\tif (i >= cache->n_hdr) {\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy (&cache->hdr[i++], item, sizeof (cache_hdr_t));\n\t}\n\nbeach:\n\tr_list_free (hdrs);\n}\n\nstatic void populate_cache_maps(RDyldCache *cache) {\n\tr_return_if_fail (cache && cache->buf);\n\n\tut32 i;\n\tut32 n_maps = 0;\n\tfor (i = 0; i < cache->n_hdr; i++) {\n\t\tcache_hdr_t *hdr = &cache->hdr[i];\n\t\tif (!hdr->mappingCount || !hdr->mappingOffset) {\n\t\t\tcontinue;\n\t\t}\n\t\tn_maps += hdr->mappingCount;\n\t}\n\n\tcache_map_t *maps = NULL;\n\tif (n_maps != 0) {\n\t\tcache->maps_index = R_NEWS0 (ut32, cache->n_hdr);\n\t\tif (!cache->maps_index) {\n\t\t\treturn;\n\t\t}\n\t\tmaps = R_NEWS0 (cache_map_t, n_maps);\n\t}\n\tif (!maps) {\n\t\tcache->maps = NULL;\n\t\tcache->n_maps = 0;\n\t\treturn;\n\t}\n\n\tut32 next_map = 0;\n\tfor (i = 0; i < cache->n_hdr; i++) {\n\t\tcache_hdr_t *hdr = &cache->hdr[i];\n\t\tcache->maps_index[i] = next_map;\n\n\t\tif (!hdr->mappingCount || !hdr->mappingOffset) {\n\t\t\tcontinue;\n\t\t}\n\t\tut64 size = sizeof (cache_map_t) * hdr->mappingCount;\n\t\tif (r_buf_fread_at (cache->buf, hdr->mappingOffset, (ut8*) &maps[next_map], \"3l2i\", hdr->mappingCount) != size) {\n\t\t\tcontinue;\n\t\t}\n\t\tut32 j;\n\t\tut64 hdr_offset = cache->hdr_offset[i];\n\t\tfor (j = 0; j < hdr->mappingCount; j++) {\n\t\t\tcache_map_t *map = &maps[next_map + j];\n\t\t\tmap->fileOffset += hdr_offset;\n\t\t}\n\t\tnext_map += hdr->mappingCount;\n\t}\n\n\tcache->maps = maps;\n\tcache->n_maps = next_map;\n}\n\nstatic cache_accel_t *read_cache_accel(RBuffer *cache_buf, cache_hdr_t *hdr, cache_map_t *maps, int n_maps) {\n\tif (!cache_buf || !hdr || !hdr->accelerateInfoSize || !hdr->accelerateInfoAddr) {\n\t\treturn NULL;\n\t}\n\tsize_t mc = R_MIN (hdr->mappingCount, n_maps);\n\tut64 offset = va2pa (hdr->accelerateInfoAddr, mc, maps, cache_buf, 0, NULL, NULL);\n\tif (!offset) {\n\t\treturn NULL;\n\t}\n\n\tut64 size = sizeof (cache_accel_t);\n\tcache_accel_t *accel = R_NEW0 (cache_accel_t);\n\tif (!accel) {\n\t\treturn NULL;\n\t}\n\n\tif (r_buf_fread_at (cache_buf, offset, (ut8*) accel, \"16il\", 1) != size) {\n\t\tR_FREE (accel);\n\t\treturn NULL;\n\t}\n\n\taccel->imagesExtrasOffset += offset;\n\taccel->bottomUpListOffset += offset;\n\taccel->dylibTrieOffset += offset;\n\taccel->initializersOffset += offset;\n\taccel->dofSectionsOffset += offset;\n\taccel->reExportListOffset += offset;\n\taccel->depListOffset += offset;\n\taccel->rangeTableOffset += offset;\n\n\treturn accel;\n}\n\nstatic objc_cache_opt_info *get_objc_opt_info(RBinFile *bf, RDyldCache *cache) {\n\tobjc_cache_opt_info *result = NULL;\n\tRListIter *iter;\n\tRDyldBinImage *bin;\n\tr_list_foreach (cache->bins, iter, bin) {\n\t\tif (strcmp (bin->file, \"lib/libobjc.A.dylib\")) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tstruct MACH0_(opts_t) opts = {0};\n\t\topts.verbose = bf->rbin->verbose;\n\t\topts.header_at = bin->header_at;\n\t\topts.symbols_off = 0;\n\n\t\tstruct MACH0_(obj_t) *mach0 = MACH0_(new_buf) (cache->buf, &opts);\n\t\tif (!mach0) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tstruct section_t *sections = NULL;\n\t\tif (!(sections = MACH0_(get_sections) (mach0))) {\n\t\t\tMACH0_(mach0_free) (mach0);\n\t\t\tgoto beach;\n\t\t}\n\n\t\tint i;\n\t\tut64 scoffs_offset = 0;\n\t\tut64 scoffs_size = 0;\n\t\tut64 selrefs_offset = 0;\n\t\tut64 selrefs_size = 0;\n\t\tut8 remaining = 2;\n\t\tut64 slide = rebase_infos_get_slide (cache);\n\t\tfor (i = 0; !sections[i].last; i++) {\n\t\t\tif (sections[i].size == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strstr (sections[i].name, \"__objc_scoffs\")) {\n\t\t\t\tscoffs_offset = va2pa (sections[i].addr, cache->n_maps, cache->maps, cache->buf, slide, NULL, NULL);\n\t\t\t\tscoffs_size = sections[i].size;\n\t\t\t\tremaining--;\n\t\t\t\tif (remaining == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (strstr (sections[i].name, \"__DATA.__objc_selrefs\")) {\n\t\t\t\tselrefs_offset = va2pa (sections[i].addr, cache->n_maps, cache->maps, cache->buf, slide, NULL, NULL);\n\t\t\t\tselrefs_size = sections[i].size;\n\t\t\t\tremaining--;\n\t\t\t\tif (remaining == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tMACH0_(mach0_free) (mach0);\n\t\tR_FREE (sections);\n\n\t\tut64 sel_string_base = 0;\n\t\tif (!scoffs_offset || scoffs_size < 40) {\n\t\t\tif (!selrefs_offset || !selrefs_size || cache->n_hdr == 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut64 cursor = selrefs_offset;\n\t\t\tut64 end = cursor + selrefs_size;\n\t\t\twhile (cursor < end) {\n\t\t\t\tut64 sel_ptr = r_buf_read_le64_at (cache->buf, cursor);\n\t\t\t\tif (sel_ptr == UT64_MAX) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tut64 sel_offset = va2pa (sel_ptr, cache->n_maps, cache->maps, cache->buf, slide, NULL, NULL);\n\t\t\t\tchar * selector = r_buf_get_string (cache->buf, sel_offset);\n\t\t\t\tif (!selector) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbool is_magic_selector = !strncmp (selector, \"\\xf0\\x9f\\xa4\\xaf\", 4);\n\t\t\t\tfree (selector);\n\n\t\t\t\tif (is_magic_selector) {\n\t\t\t\t\tsel_string_base = sel_ptr;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcursor += 8;\n\t\t\t}\n\t\t\tif (sel_string_base == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tut64 check = r_buf_read_le64_at (cache->buf, scoffs_offset);\n\t\t\tif (check != 2) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsel_string_base = r_buf_read_le64_at (cache->buf, scoffs_offset + 8);\n\t\t\tif (sel_string_base == UT64_MAX) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut64 sel_string_end = r_buf_read_le64_at (cache->buf, scoffs_offset + 16);\n\t\t\tif (sel_string_end == sel_string_base || sel_string_end == UT64_MAX) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tresult = R_NEW0 (objc_cache_opt_info);\n\t\tif (!result) {\n\t\t\tbreak;\n\t\t}\n\t\tresult->sel_string_base = sel_string_base;\n\t}\nbeach:\n\treturn result;\n}\n\nstatic bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {\n\tRDyldCache *cache = R_NEW0 (RDyldCache);\n\tmemcpy (cache->magic, \"dyldcac\", 7);\n\tcache->buf = r_buf_ref (buf);\n\tpopulate_cache_headers (cache);\n\tif (!cache->hdr) {\n\t\tr_dyldcache_free (cache);\n\t\treturn false;\n\t}\n\tpopulate_cache_maps (cache);\n\tif (!cache->maps) {\n\t\tr_dyldcache_free (cache);\n\t\treturn false;\n\t}\n\tcache->accel = read_cache_accel (cache->buf, cache->hdr, cache->maps, cache->n_maps);\n\tcache->bins = create_cache_bins (bf, cache);\n\tif (!cache->bins) {\n\t\tr_dyldcache_free (cache);\n\t\treturn false;\n\t}\n\tcache->locsym = r_dyld_locsym_new (cache);\n\tcache->rebase_infos = get_rebase_infos (bf, cache);\n\tif (cache->rebase_infos) {\n\t\tif (!rebase_infos_get_slide (cache)) {\n\t\t\tif (!pending_bin_files) {\n\t\t\t\tpending_bin_files = r_list_new ();\n\t\t\t\tif (!pending_bin_files) {\n\t\t\t\t\tr_dyldcache_free (cache);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_list_push (pending_bin_files, bf);\n\t\t\tswizzle_io_read (cache, bf->rbin->iob.io);\n\t\t}\n\t}\n\t*bin_obj = cache;\n\treturn true;\n}\n\nstatic RList *entries(RBinFile *bf) {\n\tRBinAddr *ptr = NULL;\n\tRList *ret = r_list_newf (free);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tif ((ptr = R_NEW0 (RBinAddr))) {\n\t\tr_list_append (ret, ptr);\n\t}\n\treturn ret;\n}\n\nstatic RBinInfo *info(RBinFile *bf) {\n\tRBinInfo *ret = NULL;\n\n\tif (!bf || !bf->o) {\n\t\treturn NULL;\n\t}\n\n\tRDyldCache *cache = (RDyldCache*) bf->o->bin_obj;\n\tif (!cache) {\n\t\treturn NULL;\n\t}\n\n\tbool big_endian = 0;\n\tif (!(ret = R_NEW0 (RBinInfo))) {\n\t\treturn NULL;\n\t}\n\tret->file = strdup (bf->file);\n\tret->bclass = strdup (\"dyldcache\");\n\tret->rclass = strdup (\"ios\");\n\tret->os = strdup (\"iOS\");\n\tif (strstr (cache->hdr->magic, \"x86_64\")) {\n\t\tret->arch = strdup (\"x86\");\n\t\tret->bits = 64;\n\t} else {\n\t\tret->arch = strdup (\"arm\");\n\t\tret->bits = strstr (cache->hdr->magic, \"arm64\")? 64: 32;\n\t}\n\tret->machine = strdup (ret->arch);\n\tret->subsystem = strdup (\"xnu\");\n\tret->type = strdup (\"library-cache\");\n\tret->has_va = true;\n\tret->big_endian = big_endian;\n\tret->dbg_info = 0;\n\treturn ret;\n}\n\n#if 0\nstatic void parse_mach0(RList *ret, ut64 paddr, RBinFile *bf) {\n\t// TODO\n}\n#endif\n\nstatic ut64 baddr(RBinFile *bf) {\n\t// XXX hardcoded\n\treturn 0x180000000;\n}\n\nvoid symbols_from_bin(RDyldCache *cache, RList *ret, RBinFile *bf, RDyldBinImage *bin, SetU *hash) {\n\tstruct MACH0_(obj_t) *mach0 = bin_to_mach0 (bf, bin);\n\tif (!mach0) {\n\t\treturn;\n\t}\n\n\t// const RList*symbols = MACH0_(get_symbols_list) (mach0);\n\tconst struct symbol_t *symbols = MACH0_(get_symbols) (mach0);\n\tif (!symbols) {\n\t\treturn;\n\t}\n\tint i;\n\tfor (i = 0; !symbols[i].last; i++) {\n\t\tif (!symbols[i].name || !symbols[i].name[0] || symbols[i].addr < 100) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strstr (symbols[i].name, \"<redacted>\")) {\n\t\t\tcontinue;\n\t\t}\n\t\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\t\tif (!sym) {\n\t\t\tbreak;\n\t\t}\n\t\tsym->name = strdup (symbols[i].name);\n\t\tsym->vaddr = symbols[i].addr;\n\t\tsym->forwarder = \"NONE\";\n\t\tsym->bind = (symbols[i].type == R_BIN_MACH0_SYMBOL_TYPE_LOCAL)? R_BIN_BIND_LOCAL_STR: R_BIN_BIND_GLOBAL_STR;\n\t\tsym->type = R_BIN_TYPE_FUNC_STR;\n\t\tsym->paddr = symbols[i].offset + bf->o->boffset;\n\t\tsym->size = symbols[i].size;\n\t\tsym->ordinal = i;\n\n\t\tset_u_add (hash, sym->vaddr);\n\t\tr_list_append (ret, sym);\n\t}\n\tMACH0_(mach0_free) (mach0);\n}\n\nstatic bool __is_data_section(const char *name) {\n\tif (strstr (name, \"_cstring\")) {\n\t\treturn true;\n\t}\n\tif (strstr (name, \"_os_log\")) {\n\t\treturn true;\n\t}\n\tif (strstr (name, \"_objc_methname\")) {\n\t\treturn true;\n\t}\n\tif (strstr (name, \"_objc_classname\")) {\n\t\treturn true;\n\t}\n\tif (strstr (name, \"_objc_methtype\")) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic void sections_from_bin(RList *ret, RBinFile *bf, RDyldBinImage *bin) {\n\tRDyldCache *cache = (RDyldCache*) bf->o->bin_obj;\n\tif (!cache) {\n\t\treturn;\n\t}\n\n\tstruct MACH0_(obj_t) *mach0 = bin_to_mach0 (bf, bin);\n\tif (!mach0) {\n\t\treturn;\n\t}\n\n\tstruct section_t *sections = NULL;\n\tif (!(sections = MACH0_(get_sections) (mach0))) {\n\t\treturn;\n\t}\n\n\tut64 slide = rebase_infos_get_slide (cache);\n\tint i;\n\tfor (i = 0; !sections[i].last; i++) {\n\t\tRBinSection *ptr = R_NEW0 (RBinSection);\n\t\tif (!ptr) {\n\t\t\tbreak;\n\t\t}\n\t\tif (bin->file) {\n\t\t\tptr->name = r_str_newf (\"%s.%s\", bin->file, (char*)sections[i].name);\n\t\t} else {\n\t\t\tptr->name = r_str_newf (\"%s\", (char*)sections[i].name);\n\t\t}\n\t\tif (strstr (ptr->name, \"la_symbol_ptr\")) {\n\t\t\tint len = sections[i].size / 8;\n\t\t\tptr->format = r_str_newf (\"Cd %d[%d]\", 8, len);\n\t\t}\n\t\tptr->is_data = __is_data_section (ptr->name);\n\t\tptr->size = sections[i].size;\n\t\tptr->vsize = sections[i].vsize;\n\t\tptr->vaddr = sections[i].addr;\n\t\tptr->paddr = va2pa (sections[i].addr, cache->n_maps, cache->maps, cache->buf, slide, NULL, NULL);\n\t\tif (!ptr->vaddr) {\n\t\t\tptr->vaddr = ptr->paddr;\n\t\t}\n\t\tptr->perm = sections[i].perm;\n\t\tr_list_append (ret, ptr);\n\t}\n\tfree (sections);\n\tMACH0_(mach0_free) (mach0);\n}\n\nstatic RList *sections(RBinFile *bf) {\n\tRDyldCache *cache = (RDyldCache*) bf->o->bin_obj;\n\tif (!cache) {\n\t\treturn NULL;\n\t}\n\n\tRList *ret = r_list_newf (free);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\n\tRListIter *iter;\n\tRDyldBinImage *bin;\n\tr_list_foreach (cache->bins, iter, bin) {\n\t\tsections_from_bin (ret, bf, bin);\n\t}\n\n\tRBinSection *ptr = NULL;\n\tint i;\n\tfor (i = 0; i < cache->n_maps; i++) {\n\t\tif (!(ptr = R_NEW0 (RBinSection))) {\n\t\t\tr_list_free (ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tptr->name = r_str_newf (\"cache_map.%d\", i);\n\t\tptr->size = cache->maps[i].size;\n\t\tptr->vsize = ptr->size;\n\t\tptr->paddr = cache->maps[i].fileOffset;\n\t\tptr->vaddr = cache->maps[i].address;\n\t\tptr->add = true;\n\t\tptr->is_segment = true;\n\t\tptr->perm = prot2perm (cache->maps[i].initProt);\n\t\tr_list_append (ret, ptr);\n\t}\n\n\tut64 slide = rebase_infos_get_slide (cache);\n\tif (slide) {\n\t\tRBinSection *section;\n\t\tr_list_foreach (ret, iter, section) {\n\t\t\tsection->vaddr += slide;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic RList *symbols(RBinFile *bf) {\n\tRDyldCache *cache = (RDyldCache*) bf->o->bin_obj;\n\tif (!cache) {\n\t\treturn NULL;\n\t}\n\n\tRList *ret = r_list_newf (free);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\n\tRListIter *iter;\n\tRDyldBinImage *bin;\n\tr_list_foreach (cache->bins, iter, bin) {\n\t\tSetU *hash = set_u_new ();\n\t\tif (!hash) {\n\t\t\tr_list_free (ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tsymbols_from_bin (cache, ret, bf, bin, hash);\n\t\tsymbols_from_locsym (cache, bin, ret, hash);\n\t\tset_u_free (hash);\n\t}\n\n\tut64 slide = rebase_infos_get_slide (cache);\n\tif (slide) {\n\t\tRBinSymbol *sym;\n\t\tr_list_foreach (ret, iter, sym) {\n\t\t\tsym->vaddr += slide;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n/* static void unswizzle_io_read(RDyldCache *cache, RIO *io) {\n\tif (!io || !io->desc || !io->desc->plugin || !cache->original_io_read) {\n\t\treturn;\n\t}\n\n\tRIOPlugin *plugin = io->desc->plugin;\n\tplugin->read = cache->original_io_read;\n\tcache->original_io_read = NULL;\n} */\n\nstatic void destroy(RBinFile *bf) {\n\tRDyldCache *cache = (RDyldCache*) bf->o->bin_obj;\n\t// unswizzle_io_read (cache, bf->rbin->iob.io); // XXX io may be dead here\n\tr_dyldcache_free (cache);\n}\n\nstatic RList *classes(RBinFile *bf) {\n\tRDyldCache *cache = (RDyldCache*) bf->o->bin_obj;\n\tif (!cache) {\n\t\treturn NULL;\n\t}\n\n\tRList *ret = r_list_newf (free);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\n\tif (!cache->objc_opt_info_loaded) {\n\t\tcache->oi = get_objc_opt_info (bf, cache);\n\t\tcache->objc_opt_info_loaded = true;\n\t}\n\n\tRListIter *iter;\n\tRDyldBinImage *bin;\n\tut64 slide = rebase_infos_get_slide (cache);\n\n\tRBuffer *orig_buf = bf->buf;\n\tut32 num_of_unnamed_class = 0;\n\tr_list_foreach (cache->bins, iter, bin) {\n\t\tstruct MACH0_(obj_t) *mach0 = bin_to_mach0 (bf, bin);\n\t\tif (!mach0) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tstruct section_t *sections = NULL;\n\t\tif (!(sections = MACH0_(get_sections) (mach0))) {\n\t\t\tMACH0_(mach0_free) (mach0);\n\t\t\tgoto beach;\n\t\t}\n\n\t\tint i;\n\t\tfor (i = 0; !sections[i].last; i++) {\n\t\t\tif (sections[i].size == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tbool is_classlist = strstr (sections[i].name, \"__objc_classlist\");\n\t\t\tbool is_catlist = strstr (sections[i].name, \"__objc_catlist\");\n\n\t\t\tif (!is_classlist && !is_catlist) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tut8 *pointers = malloc (sections[i].size);\n\t\t\tif (!pointers) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tut64 offset = va2pa (sections[i].addr, cache->n_maps, cache->maps, cache->buf, slide, NULL, NULL);\n\t\t\tif (r_buf_read_at (cache->buf, offset, pointers, sections[i].size) < sections[i].size) {\n\t\t\t\tR_FREE (pointers);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tut8 *cursor = pointers;\n\t\t\tut8 *pointers_end = pointers + sections[i].size;\n\n\t\t\tfor (; cursor < pointers_end; cursor += 8) {\n\t\t\t\tut64 pointer_to_class = r_read_le64 (cursor);\n\n\t\t\t\tRBinClass *klass;\n\t\t\t\tif (!(klass = R_NEW0 (RBinClass)) ||\n\t\t\t\t\t!(klass->methods = r_list_new ()) ||\n\t\t\t\t\t!(klass->fields = r_list_new ())) {\n\t\t\t\t\tR_FREE (klass);\n\t\t\t\t\tR_FREE (pointers);\n\t\t\t\t\tR_FREE (sections);\n\t\t\t\t\tMACH0_(mach0_free) (mach0);\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\n\t\t\t\tbf->o->bin_obj = mach0;\n\t\t\t\tbf->buf = cache->buf;\n\t\t\t\tif (is_classlist) {\n\t\t\t\t\tMACH0_(get_class_t) (pointer_to_class, bf, klass, false, NULL, cache->oi);\n\t\t\t\t} else {\n\t\t\t\t\tMACH0_(get_category_t) (pointer_to_class, bf, klass, NULL, cache->oi);\n\t\t\t\t}\n\t\t\t\tbf->o->bin_obj = cache;\n\t\t\t\tbf->buf = orig_buf;\n\n\t\t\t\tif (!klass->name) {\n\t\t\t\t\teprintf (\"KLASS ERROR AT 0x%\"PFMT64x\", is_classlist %d\\n\", pointer_to_class, is_classlist);\n\t\t\t\t\tklass->name = r_str_newf (\"UnnamedClass%u\", num_of_unnamed_class);\n\t\t\t\t\tif (!klass->name) {\n\t\t\t\t\t\tR_FREE (klass);\n\t\t\t\t\t\tR_FREE (pointers);\n\t\t\t\t\t\tR_FREE (sections);\n\t\t\t\t\t\tMACH0_(mach0_free) (mach0);\n\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t}\n\t\t\t\t\tnum_of_unnamed_class++;\n\t\t\t\t}\n\t\t\t\tr_list_append (ret, klass);\n\t\t\t}\n\n\t\t\tR_FREE (pointers);\n\t\t}\n\n\t\tR_FREE (sections);\n\t\tMACH0_(mach0_free) (mach0);\n\t}\n\n\treturn ret;\n\nbeach:\n\tr_list_free (ret);\n\treturn NULL;\n}\n\nstatic void header(RBinFile *bf) {\n\tif (!bf || !bf->o) {\n\t\treturn;\n\t}\n\n\tRDyldCache *cache = (RDyldCache*) bf->o->bin_obj;\n\tif (!cache) {\n\t\treturn;\n\t}\n\n\tRBin *bin = bf->rbin;\n\tut64 slide = rebase_infos_get_slide (cache);\n\tPrintfCallback p = bin->cb_printf;\n\n\tPJ *pj = pj_new ();\n\tif (!pj) {\n\t\treturn;\n\t}\n\n\tpj_o (pj);\n\tpj_k (pj, \"header\");\n\tpj_o (pj);\n\tpj_ks (pj, \"magic\", cache->hdr->magic);\n\tpj_kn (pj, \"mappingOffset\", cache->hdr->mappingOffset);\n\tpj_kn (pj, \"mappingCount\", cache->hdr->mappingCount);\n\tpj_kn (pj, \"imagesOffset\", cache->hdr->imagesOffset);\n\tpj_kn (pj, \"imagesCount\", cache->hdr->imagesCount);\n\tpj_kn (pj, \"dyldBaseAddress\", cache->hdr->dyldBaseAddress);\n\tpj_kn (pj, \"codeSignatureOffset\", cache->hdr->codeSignatureOffset);\n\tpj_kn (pj, \"codeSignatureSize\", cache->hdr->codeSignatureSize);\n\tpj_kn (pj, \"slideInfoOffset\", cache->hdr->slideInfoOffset);\n\tpj_kn (pj, \"slideInfoSize\", cache->hdr->slideInfoSize);\n\tpj_kn (pj, \"localSymbolsOffset\", cache->hdr->localSymbolsOffset);\n\tpj_kn (pj, \"localSymbolsSize\", cache->hdr->localSymbolsSize);\n\tchar uuidstr[128];\n\tr_hex_bin2str ((ut8*)cache->hdr->uuid, 16, uuidstr);\n\tpj_ks (pj, \"uuid\", uuidstr);\n\tpj_ks (pj, \"cacheType\", (cache->hdr->cacheType == 0) ? \"development\" : \"production\");\n\tpj_kn (pj, \"branchPoolsOffset\", cache->hdr->branchPoolsOffset);\n\tpj_kn (pj, \"branchPoolsCount\", cache->hdr->branchPoolsCount);\n\tpj_kn (pj, \"accelerateInfoAddr\", cache->hdr->accelerateInfoAddr + slide);\n\tpj_kn (pj, \"accelerateInfoSize\", cache->hdr->accelerateInfoSize);\n\tpj_kn (pj, \"imagesTextOffset\", cache->hdr->imagesTextOffset);\n\tpj_kn (pj, \"imagesTextCount\", cache->hdr->imagesTextCount);\n\tpj_end (pj);\n\n\tif (cache->accel) {\n\t\tpj_k (pj, \"accelerator\");\n\t\tpj_o (pj);\n\t\tpj_kn (pj, \"version\", cache->accel->version);\n\t\tpj_kn (pj, \"imageExtrasCount\", cache->accel->imageExtrasCount);\n\t\tpj_kn (pj, \"imagesExtrasOffset\", cache->accel->imagesExtrasOffset);\n\t\tpj_kn (pj, \"bottomUpListOffset\", cache->accel->bottomUpListOffset);\n\t\tpj_kn (pj, \"dylibTrieOffset\", cache->accel->dylibTrieOffset);\n\t\tpj_kn (pj, \"dylibTrieSize\", cache->accel->dylibTrieSize);\n\t\tpj_kn (pj, \"initializersOffset\", cache->accel->initializersOffset);\n\t\tpj_kn (pj, \"initializersCount\", cache->accel->initializersCount);\n\t\tpj_kn (pj, \"dofSectionsOffset\", cache->accel->dofSectionsOffset);\n\t\tpj_kn (pj, \"dofSectionsCount\", cache->accel->dofSectionsCount);\n\t\tpj_kn (pj, \"reExportListOffset\", cache->accel->reExportListOffset);\n\t\tpj_kn (pj, \"reExportCount\", cache->accel->reExportCount);\n\t\tpj_kn (pj, \"depListOffset\", cache->accel->depListOffset);\n\t\tpj_kn (pj, \"depListCount\", cache->accel->depListCount);\n\t\tpj_kn (pj, \"rangeTableOffset\", cache->accel->rangeTableOffset);\n\t\tpj_kn (pj, \"rangeTableCount\", cache->accel->rangeTableCount);\n\t\tpj_kn (pj, \"dyldSectionAddr\", cache->accel->dyldSectionAddr + slide);\n\t\tpj_end (pj);\n\t}\n\n\tif (cache->rebase_infos) {\n\t\tsize_t i;\n\t\tpj_k (pj, \"slideInfo\");\n\t\tpj_a (pj);\n\t\tfor (i = 0; i < cache->rebase_infos->length; i++) {\n\t\t\tRDyldRebaseInfo * rebase_info = cache->rebase_infos->entries[i].info;\n\t\t\tpj_o (pj);\n\t\t\tpj_kn (pj, \"start\", cache->rebase_infos->entries[i].start);\n\t\t\tpj_kn (pj, \"end\", cache->rebase_infos->entries[i].end);\n\t\t\tif (rebase_info) {\n\t\t\t\tut8 version = rebase_info->version;\n\t\t\t\tpj_kn (pj, \"version\", version);\n\t\t\t\tpj_kn (pj, \"slide\", slide);\n\t\t\t\tif (version == 3) {\n\t\t\t\t\tRDyldRebaseInfo3 *info3 = (RDyldRebaseInfo3*) rebase_info;\n\t\t\t\t\tpj_kn (pj, \"page_starts_count\", info3->page_starts_count);\n\t\t\t\t\tpj_kn (pj, \"page_size\", info3->page_size);\n\t\t\t\t\tpj_kn (pj, \"auth_value_add\", info3->auth_value_add);\n\t\t\t\t} else if (version == 2 || version == 4) {\n\t\t\t\t\tRDyldRebaseInfo2 *info2 = (RDyldRebaseInfo2*) rebase_info;\n\t\t\t\t\tpj_kn (pj, \"page_starts_count\", info2->page_starts_count);\n\t\t\t\t\tpj_kn (pj, \"page_extras_count\", info2->page_extras_count);\n\t\t\t\t\tpj_kn (pj, \"delta_mask\", info2->delta_mask);\n\t\t\t\t\tpj_kn (pj, \"value_mask\", info2->value_mask);\n\t\t\t\t\tpj_kn (pj, \"value_add\", info2->value_add);\n\t\t\t\t\tpj_kn (pj, \"delta_shift\", info2->delta_shift);\n\t\t\t\t\tpj_kn (pj, \"page_size\", info2->page_size);\n\t\t\t\t} else if (version == 1) {\n\t\t\t\t\tRDyldRebaseInfo1 *info1 = (RDyldRebaseInfo1*) rebase_info;\n\t\t\t\t\tpj_kn (pj, \"toc_count\", info1->toc_count);\n\t\t\t\t\tpj_kn (pj, \"entries_size\", info1->entries_size);\n\t\t\t\t\tpj_kn (pj, \"page_size\", 4096);\n\t\t\t\t}\n\t\t\t}\n\t\t\tpj_end (pj);\n\t\t}\n\t\tpj_end (pj);\n\t}\n\n\tif (cache->hdr->imagesTextCount) {\n\t\tpj_k (pj, \"images\");\n\t\tpj_a (pj);\n\t\tut64 total_size = cache->hdr->imagesTextCount * sizeof (cache_text_info_t);\n\t\tcache_text_info_t * text_infos = malloc (total_size);\n\t\tif (!text_infos) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (r_buf_fread_at (cache->buf, cache->hdr->imagesTextOffset, (ut8*)text_infos, \"16clii\", cache->hdr->imagesTextCount) != total_size) {\n\t\t\tfree (text_infos);\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tfor (i = 0; i != cache->hdr->imagesTextCount; i++) {\n\t\t\tcache_text_info_t * text_info = &text_infos[i];\n\t\t\tr_hex_bin2str ((ut8*)text_info->uuid, 16, uuidstr);\n\t\t\tpj_o (pj);\n\t\t\tpj_ks (pj, \"uuid\", uuidstr);\n\t\t\tpj_kn (pj, \"address\", text_info->loadAddress + slide);\n\t\t\tpj_kn (pj, \"textSegmentSize\", text_info->textSegmentSize);\n\t\t\tchar file[256];\n\t\t\tif (r_buf_read_at (cache->buf, text_info->pathOffset, (ut8*) &file, sizeof (file)) == sizeof (file)) {\n\t\t\t\tfile[255] = 0;\n\t\t\t\tpj_ks (pj, \"path\", file);\n\t\t\t\tchar *last_slash = strrchr (file, '/');\n\t\t\t\tif (last_slash && *last_slash) {\n\t\t\t\t\tpj_ks (pj, \"name\", last_slash + 1);\n\t\t\t\t} else {\n\t\t\t\t\tpj_ks (pj, \"name\", file);\n\t\t\t\t}\n\t\t\t}\n\t\t\tpj_end (pj);\n\t\t}\n\t\tpj_end (pj);\n\t\tfree (text_infos);\n\t}\n\n\tpj_end (pj);\n\tp (\"%s\", pj_string (pj));\n\nbeach:\n\tpj_free (pj);\n}\n\nRBinPlugin r_bin_plugin_dyldcache = {\n\t.name = \"dyldcache\",\n\t.desc = \"dyldcache bin plugin\",\n\t.license = \"LGPL3\",\n\t.load_buffer = &load_buffer,\n\t.entries = &entries,\n\t.baddr = &baddr,\n\t.symbols = &symbols,\n\t.sections = &sections,\n\t.check_buffer = &check_buffer,\n\t.destroy = &destroy,\n\t.classes = &classes,\n\t.header = &header,\n\t.info = &info,\n};\n\n#ifndef R2_PLUGIN_INCORE\nR_API RLibStruct radare_plugin = {\n\t.type = R_LIB_TYPE_BIN,\n\t.data = &r_bin_plugin_dyldcache,\n\t.version = R2_VERSION\n};\n#endif\n"], "fixing_code": ["/* radare - LGPL - Copyright 2009-2022 nibble, pancake */\n\n#include <r_types.h>\n#include \"mach0_specs.h\"\n\n#ifndef _INCLUDE_R_BIN_DYLDCACHE_H_\n#define _INCLUDE_R_BIN_DYLDCACHE_H_\n\nstruct r_bin_dyldcache_obj_t {\n\tconst char *file;\n\tint size;\n\tint nlibs;\n\tstruct cache_header hdr;\n\tRBuffer* b;\n};\n\nstruct r_bin_dyldcache_lib_t {\n\tchar path[1024];\n\tint size;\n\tut64 offset;\n\tRBuffer *b;\n\tint last;\n};\n\n\nstruct dyld_cache_mapping_info {\n\tut64 address;\n\tut64 size;\n\tut64 fileOffset;\n\tut32 maxProt;\n\tut32 initProt;\n};\n\nstruct dyld_cache_image_info {\n\tut64 address;\n\tut64 modTime;\n\tut64 inode;\n\tut32 pathFileOffset;\n\tut32 pad;\n};\n\nstruct dyld_cache_slide_info {\n\tut32 version;\n\tut32 toc_offset;\n\tut32 toc_count;\n\tut32 entries_offset;\n\tut32 entries_count;\n\tut32 entries_size;\n};\n\ntypedef struct _dyld_cache_local_symbols_info {\n\tut32 nlistOffset;\n\tut32 nlistCount;\n\tut32 stringsOffset;\n\tut32 stringsSize;\n\tut32 entriesOffset;\n\tut32 entriesCount;\n} dyld_cache_local_symbols_info;\n\ntypedef struct _dyld_cache_local_symbols_entry {\n\tut32 dylibOffset;\n\tut32 nlistStartIndex;\n\tut32 nlistCount;\n} dyld_cache_local_symbols_entry;\n\nstruct r_bin_dyldcache_lib_t *r_bin_dyldcache_extract(struct r_bin_dyldcache_obj_t* bin, int idx, int *nlib);\nvoid *r_bin_dyldcache_free(struct r_bin_dyldcache_obj_t* bin);\nstruct r_bin_dyldcache_obj_t* r_bin_dyldcache_new(const char* file);\nstruct r_bin_dyldcache_obj_t* r_bin_dyldcache_from_bytes_new (const ut8* bytes, ut64 size);\nvoid r_bin_dydlcache_get_libname(struct r_bin_dyldcache_lib_t *lib, char **libname);\n\n#endif\n", "/* radare2 - LGPL - Copyright 2018-2022 - pancake, mrmacete, keegan */\n\n#include <r_types.h>\n#include <r_util.h>\n#include <r_lib.h>\n#include <r_bin.h>\n#include <r_core.h>\n#include <r_io.h>\n#include <ht_pu.h>\n// #include \"../format/mach0/mach0_defines.h\"\n#define R_BIN_MACH064 1\n#include \"../format/mach0/mach0.h\"\n#include \"objc/mach0_classes.h\"\n\n#define R_IS_PTR_AUTHENTICATED(x) B_IS_SET(x, 63)\n#define MAX_N_HDR 16\n\ntypedef struct {\n\tut8 version;\n\tut64 slide;\n\tut8 *one_page_buf;\n\tut32 page_size;\n\tut64 start_of_data;\n} RDyldRebaseInfo;\n\ntypedef struct {\n\tut64 start;\n\tut64 end;\n\tRDyldRebaseInfo *info;\n} RDyldRebaseInfosEntry;\n\ntypedef struct {\n\tRDyldRebaseInfosEntry *entries;\n\tsize_t length;\n} RDyldRebaseInfos;\n\ntypedef struct {\n\tut8 version;\n\tut64 slide;\n\tut8 *one_page_buf;\n\tut32 page_size;\n\tut64 start_of_data;\n\tut16 *page_starts;\n\tut32 page_starts_count;\n\tut64 delta_mask;\n\tut32 delta_shift;\n\tut64 auth_value_add;\n} RDyldRebaseInfo3;\n\ntypedef struct {\n\tut8 version;\n\tut64 slide;\n\tut8 *one_page_buf;\n\tut32 page_size;\n\tut64 start_of_data;\n\tut16 *page_starts;\n\tut32 page_starts_count;\n\tut16 *page_extras;\n\tut32 page_extras_count;\n\tut64 delta_mask;\n\tut64 value_mask;\n\tut32 delta_shift;\n\tut64 value_add;\n} RDyldRebaseInfo2;\n\ntypedef struct {\n\tut8 version;\n\tut64 slide;\n\tut8 *one_page_buf;\n\tut32 page_size;\n\tut64 start_of_data;\n\tut16 *toc;\n\tut32 toc_count;\n\tut8 *entries;\n\tut32 entries_size;\n} RDyldRebaseInfo1;\n\ntypedef struct {\n\tut64 local_symbols_offset;\n\tut64 nlists_offset;\n\tut64 nlists_count;\n\tut64 strings_offset;\n\tut64 strings_size;\n} RDyldLocSym;\n\ntypedef struct _r_dyldcache {\n\tut8 magic[8];\n\n\tcache_hdr_t *hdr;\n\tut64 *hdr_offset;\n\tut32 *maps_index;\n\tut32 n_hdr;\n\tcache_map_t *maps;\n\tut32 n_maps;\n\n\tRList *bins;\n\tRBuffer *buf;\n\tint (*original_io_read)(RIO *io, RIODesc *fd, ut8 *buf, int count);\n\tRDyldRebaseInfos *rebase_infos;\n\tcache_accel_t *accel;\n\tRDyldLocSym *locsym;\n\tobjc_cache_opt_info *oi;\n\tbool objc_opt_info_loaded;\n} RDyldCache;\n\ntypedef struct _r_bin_image {\n\tchar *file;\n\tut64 header_at;\n\tut64 hdr_offset;\n\tut64 symbols_off;\n\tut64 va;\n\tut32 nlist_start_index;\n\tut32 nlist_count;\n} RDyldBinImage;\n\nstatic R_TH_LOCAL RList *pending_bin_files = NULL;\n\nstatic ut64 va2pa(uint64_t addr, ut32 n_maps, cache_map_t *maps, RBuffer *cache_buf, ut64 slide, ut32 *offset, ut32 *left) {\n\tut64 res = UT64_MAX;\n\tut32 i;\n\n\taddr -= slide;\n\n\tfor (i = 0; i < n_maps; i++) {\n\t\tif (addr >= maps[i].address && addr < maps[i].address + maps[i].size) {\n\t\t\tres = maps[i].fileOffset + addr - maps[i].address;\n\t\t\tif (offset) {\n\t\t\t\t*offset = addr - maps[i].address;\n\t\t\t}\n\t\t\tif (left) {\n\t\t\t\t*left = maps[i].size - (addr - maps[i].address);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn res;\n}\n\nstatic void free_bin(RDyldBinImage *bin) {\n\tif (!bin) {\n\t\treturn;\n\t}\n\n\tR_FREE (bin->file);\n\tR_FREE (bin);\n}\n\nstatic void rebase_info3_free(RDyldRebaseInfo3 *rebase_info) {\n\tif (!rebase_info) {\n\t\treturn;\n\t}\n\n\tR_FREE (rebase_info->page_starts);\n\tR_FREE (rebase_info);\n}\n\nstatic void rebase_info2_free(RDyldRebaseInfo2 *rebase_info) {\n\tif (!rebase_info) {\n\t\treturn;\n\t}\n\n\tR_FREE (rebase_info->page_starts);\n\tR_FREE (rebase_info->page_extras);\n\tR_FREE (rebase_info);\n}\n\nstatic void rebase_info1_free(RDyldRebaseInfo1 *rebase_info) {\n\tif (!rebase_info) {\n\t\treturn;\n\t}\n\n\tR_FREE (rebase_info->toc);\n\tR_FREE (rebase_info->entries);\n\tR_FREE (rebase_info);\n}\n\nstatic void rebase_info_free(RDyldRebaseInfo *rebase_info) {\n\tif (!rebase_info) {\n\t\treturn;\n\t}\n\n\tR_FREE (rebase_info->one_page_buf);\n\n\tut8 version = rebase_info->version;\n\n\tif (version == 1) {\n\t\trebase_info1_free ((RDyldRebaseInfo1*) rebase_info);\n\t} else if (version == 2 || version == 4) {\n\t\trebase_info2_free ((RDyldRebaseInfo2*) rebase_info);\n\t} else if (version == 3) {\n\t\trebase_info3_free ((RDyldRebaseInfo3*) rebase_info);\n\t} else {\n\t\tR_FREE (rebase_info);\n\t}\n}\n\nstatic cache_img_t *read_cache_images(RBuffer *cache_buf, cache_hdr_t *hdr, ut64 hdr_offset) {\n\tif (!cache_buf || !hdr) {\n\t\treturn NULL;\n\t}\n\tif (!hdr->imagesCount || !hdr->imagesOffset || hdr->imagesOffset == UT32_MAX || hdr->imagesCount == UT32_MAX) {\n\t\treturn NULL;\n\t}\n\n\tut64 size = sizeof (cache_img_t) * hdr->imagesCount;\n\tcache_img_t *images = R_NEWS0 (cache_img_t, hdr->imagesCount);\n\tif (!images) {\n\t\treturn NULL;\n\t}\n\n\tif (r_buf_fread_at (cache_buf, hdr->imagesOffset, (ut8*) images, \"3l2i\", hdr->imagesCount) != size) {\n\t\tR_FREE (images);\n\t\treturn NULL;\n\t}\n\n\tif (hdr_offset) {\n\t\tut32 i;\n\t\tfor (i = 0; i < hdr->imagesCount; i++) {\n\t\t\tcache_img_t *img = &images[i];\n\t\t\timg->pathFileOffset += hdr_offset;\n\t\t}\n\t}\n\n\treturn images;\n}\n\nstatic void match_bin_entries(RDyldCache *cache, void *entries) {\n\tr_return_if_fail (cache && cache->bins && entries);\n\n\tcache_img_t *imgs = read_cache_images (cache->buf, cache->hdr, 0);\n\tif (!imgs) {\n\t\treturn;\n\t}\n\n\tRDyldBinImage *bin = NULL;\n\tRListIter *it = r_list_iterator (cache->bins);\n\n\tbool has_large_entries = cache->n_hdr > 1;\n\n\tut32 i;\n\tfor (i = 0; i < cache->hdr->imagesCount; i++) {\n\t\tcache_img_t *img = &imgs[i];\n\t\tif (!it) {\n\t\t\tbreak;\n\t\t}\n\t\tbin = it->data;\n\t\tif (!bin) {\n\t\t\tbreak;\n\t\t}\n\t\tif (bin && bin->va == img->address) {\n\t\t\tif (has_large_entries) {\n\t\t\t\tcache_locsym_entry_large_t *e = &((cache_locsym_entry_large_t *) entries)[i];\n\t\t\t\tbin->nlist_start_index = e->nlistStartIndex;\n\t\t\t\tbin->nlist_count = e->nlistCount;\n\t\t\t} else {\n\t\t\t\tcache_locsym_entry_t *e = &((cache_locsym_entry_t *) entries)[i];\n\t\t\t\tbin->nlist_start_index = e->nlistStartIndex;\n\t\t\t\tbin->nlist_count = e->nlistCount;\n\t\t\t}\n\t\t\tit = it->n;\n\t\t}\n\t}\n\n\tR_FREE (imgs);\n}\n\nstatic RDyldLocSym *r_dyld_locsym_new(RDyldCache *cache) {\n\tr_return_val_if_fail (cache && cache->buf, NULL);\n\n\tut32 i;\n\tfor (i = 0; i < cache->n_hdr; i++) {\n\t\tcache_hdr_t *hdr = &cache->hdr[i];\n\t\tif (!hdr || !hdr->localSymbolsSize || !hdr->localSymbolsOffset) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tcache_locsym_info_t *info = NULL;\n\t\tvoid *entries = NULL;\n\n\t\tut64 info_size = sizeof (cache_locsym_info_t);\n\t\tinfo = R_NEW0 (cache_locsym_info_t);\n\t\tif (!info) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (r_buf_fread_at (cache->buf, hdr->localSymbolsOffset, (ut8*) info, \"6i\", 1) != info_size) {\n\t\t\teprintf (\"locsym err 01\\n\");\n\t\t\tgoto beach;\n\t\t}\n\t\tif (info->entriesCount != cache->hdr->imagesCount) {\n\t\t\teprintf (\"locsym err 02\\n\");\n\t\t\tgoto beach;\n\t\t}\n\n\t\tbool has_large_entries = cache->n_hdr > 1;\n\t\tif (has_large_entries) {\n\t\t\tut64 entries_size = sizeof (cache_locsym_entry_large_t) * info->entriesCount;\n\t\t\tcache_locsym_entry_large_t *large_entries = R_NEWS0 (cache_locsym_entry_large_t, info->entriesCount);\n\t\t\tif (!large_entries) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (cache->buf, hdr->localSymbolsOffset + info->entriesOffset, (ut8*) large_entries, \"lii\",\n\t\t\t\t\tinfo->entriesCount) != entries_size) {\n\t\t\t\teprintf (\"locsym err 03\\n\");\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tentries = large_entries;\n\t\t} else {\n\t\t\tut64 entries_size = sizeof (cache_locsym_entry_t) * info->entriesCount;\n\t\t\tcache_locsym_entry_t *regular_entries = R_NEWS0 (cache_locsym_entry_t, info->entriesCount);\n\t\t\tif (!regular_entries) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (cache->buf, hdr->localSymbolsOffset + info->entriesOffset, (ut8*) regular_entries, \"iii\",\n\t\t\t\t\tinfo->entriesCount) != entries_size) {\n\t\t\t\teprintf (\"locsym err 04\\n\");\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tentries = regular_entries;\n\t\t}\n\t\tRDyldLocSym * locsym = R_NEW0 (RDyldLocSym);\n\t\tif (!locsym) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tmatch_bin_entries (cache, entries);\n\n\t\tlocsym->local_symbols_offset = hdr->localSymbolsOffset;\n\t\tlocsym->nlists_offset = info->nlistOffset;\n\t\tlocsym->nlists_count = info->nlistCount;\n\t\tlocsym->strings_offset = info->stringsOffset;\n\t\tlocsym->strings_size = info->stringsSize;\n\n\t\tfree (info);\n\t\tfree (entries);\n\n\t\treturn locsym;\n\nbeach:\n\t\tfree (info);\n\t\tfree (entries);\n\n\t\teprintf (\"dyldcache: malformed local symbols metadata\\n\");\n\t\tbreak;\n\t}\n\treturn NULL;\n}\n\nstatic ut64 rebase_infos_get_slide(RDyldCache *cache) {\n\tif (!cache->rebase_infos || !cache->rebase_infos->length) {\n\t\treturn 0;\n\t}\n\n\tsize_t i;\n\tfor (i = 0; i < cache->rebase_infos->length; i++) {\n\t\tif (cache->rebase_infos->entries[i].info) {\n\t\t\treturn cache->rebase_infos->entries[i].info->slide;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void symbols_from_locsym(RDyldCache *cache, RDyldBinImage *bin, RList *symbols, SetU *hash) {\n\tRDyldLocSym *locsym = cache->locsym;\n\tif (!locsym) {\n\t\treturn;\n\t}\n\n\tif (bin->nlist_start_index >= locsym->nlists_count ||\n\t\t\tbin->nlist_start_index + bin->nlist_count > locsym->nlists_count) {\n\t\teprintf (\"dyldcache: malformed local symbol entry\\n\");\n\t\treturn;\n\t}\n\n\tut64 nlists_size = sizeof (struct MACH0_(nlist)) * bin->nlist_count;\n\tstruct MACH0_(nlist) *nlists = R_NEWS0 (struct MACH0_(nlist), bin->nlist_count);\n\tif (!nlists) {\n\t\treturn;\n\t}\n\tut64 nlists_offset = locsym->local_symbols_offset + locsym->nlists_offset +\n\t\tbin->nlist_start_index * sizeof (struct MACH0_(nlist));\n\tif (r_buf_fread_at (cache->buf, nlists_offset, (ut8*) nlists, \"iccsl\", bin->nlist_count) != nlists_size) {\n\t\tfree (nlists);\n\t\treturn;\n\t}\n\n\tut32 j;\n\tfor (j = 0; j != bin->nlist_count; j++) {\n\t\tstruct MACH0_(nlist) *nlist = &nlists[j];\n\t\tif (set_u_contains (hash, (ut64)nlist->n_value)) {\n\t\t\tcontinue;\n\t\t}\n\t\tset_u_add (hash, (ut64)nlist->n_value);\n\t\tif (nlist->n_strx >= locsym->strings_size) {\n\t\t\tcontinue;\n\t\t}\n\t\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\t\tif (!sym) {\n\t\t\tbreak;\n\t\t}\n\t\tsym->type = \"LOCAL\";\n\t\tsym->vaddr = nlist->n_value;\n\t\tut64 slide = rebase_infos_get_slide (cache);\n\t\tsym->paddr = va2pa (nlist->n_value, cache->n_maps, cache->maps, cache->buf, slide, NULL, NULL);\n\n\t\tchar *symstr =r_buf_get_string (cache->buf, locsym->local_symbols_offset + locsym->strings_offset + nlist->n_strx);\n\t\tif (symstr) {\n\t\t\tsym->name = symstr;\n\t\t} else {\n\t\t\tstatic ut32 k = 0;\n\t\t\tsym->name = r_str_newf (\"unk_local%d\", k++);\n\t\t}\n\n\t\tr_list_append (symbols, sym);\n\t}\n\n\tfree (nlists);\n}\n\nstatic void r_dyldcache_free(RDyldCache *cache) {\n\tif (!cache) {\n\t\treturn;\n\t}\n\n\tr_list_free (cache->bins);\n\tcache->bins = NULL;\n\tr_buf_free (cache->buf);\n\tcache->buf = NULL;\n\tif (cache->rebase_infos) {\n\t\tint i;\n\t\tfor (i = 0; i < cache->rebase_infos->length; i++) {\n\t\t\trebase_info_free (cache->rebase_infos->entries[i].info);\n\t\t\tcache->rebase_infos->entries[i].info = NULL;\n\t\t}\n\t\tR_FREE (cache->rebase_infos->entries);\n\t\tR_FREE (cache->rebase_infos);\n\t}\n\tR_FREE (cache->hdr);\n\tR_FREE (cache->maps);\n\tR_FREE (cache->maps_index);\n\tR_FREE (cache->hdr_offset);\n\tR_FREE (cache->accel);\n\tR_FREE (cache->locsym);\n\tR_FREE (cache->oi);\n\tR_FREE (cache);\n}\n\nstatic ut64 bin_obj_va2pa(ut64 p, ut32 *offset, ut32 *left, RBinFile *bf) {\n\tif (!bf || !bf->o || !bf->o->bin_obj) {\n\t\treturn 0;\n\t}\n\n\tRDyldCache *cache = (RDyldCache*) ((struct MACH0_(obj_t)*)bf->o->bin_obj)->user;\n\tif (!cache) {\n\t\treturn 0;\n\t}\n\n\tut64 slide = rebase_infos_get_slide (cache);\n\tut64 res = va2pa (p, cache->n_maps, cache->maps, cache->buf, slide, offset, left);\n\tif (res == UT64_MAX) {\n\t\tres = 0;\n\t}\n\treturn res;\n}\n\nstatic struct MACH0_(obj_t) *bin_to_mach0(RBinFile *bf, RDyldBinImage *bin) {\n\tif (!bin || !bf) {\n\t\treturn NULL;\n\t}\n\n\tRDyldCache *cache = (RDyldCache*) bf->o->bin_obj;\n\tif (!cache) {\n\t\treturn NULL;\n\t}\n\n\tRBuffer *buf = r_buf_new_slice (cache->buf, bin->hdr_offset, r_buf_size (cache->buf) - bin->hdr_offset);\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\n\tstruct MACH0_(opts_t) opts;\n\tMACH0_(opts_set_default) (&opts, bf);\n\topts.header_at = bin->header_at - bin->hdr_offset;\n\topts.symbols_off = bin->symbols_off;\n\n\tstruct MACH0_(obj_t) *mach0 = MACH0_(new_buf) (buf, &opts);\n\n\tmach0->user = cache;\n\tmach0->va2pa = &bin_obj_va2pa;\n\n\tr_buf_free (buf);\n\n\treturn mach0;\n}\n\nstatic int prot2perm(int x) {\n\tint r = 0;\n\tif (x & 1) {\n\t\tr |= 4;\n\t}\n\tif (x & 2) {\n\t\tr |= 2;\n\t}\n\tif (x & 4) {\n\t\tr |= 1;\n\t}\n\treturn r;\n}\n\nstatic ut32 dumb_ctzll(ut64 x) {\n\tut64 result = 0;\n\tint i, j;\n\tfor (i = 0; i < 64; i += 8) {\n\t\tut8 byte = (x >> i) & 0xff;\n\t\tif (!byte) {\n\t\t\tresult += 8;\n\t\t} else {\n\t\t\tfor (j = 0; j < 8; j++) {\n\t\t\t\tif (!((byte >> j) & 1)) {\n\t\t\t\t\tresult++;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}\n\nstatic ut64 estimate_slide(RBinFile *bf, RDyldCache *cache, ut64 value_mask, ut64 value_add) {\n\tut64 slide = 0;\n\tif (cache->n_hdr > 1) {\n\t\treturn slide;\n\t}\n\tut64 *classlist = malloc (64);\n\tif (!classlist) {\n\t\tgoto beach;\n\t}\n\n\tRListIter *iter;\n\tRDyldBinImage *bin;\n\tr_list_foreach (cache->bins, iter, bin) {\n\t\tbool found_sample = false;\n\n\t\tstruct MACH0_(opts_t) opts = {0};\n\t\topts.verbose = bf->rbin->verbose;\n\t\topts.header_at = bin->header_at;\n\t\topts.symbols_off = 0;\n\n\t\tstruct MACH0_(obj_t) *mach0 = MACH0_(new_buf) (cache->buf, &opts);\n\t\tif (!mach0) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tstruct section_t *sections = NULL;\n\t\tif (!(sections = MACH0_(get_sections) (mach0))) {\n\t\t\tMACH0_(mach0_free) (mach0);\n\t\t\tgoto beach;\n\t\t}\n\n\t\tint i;\n\t\tint incomplete = 2;\n\t\tint classlist_idx = 0, data_idx = 0;\n\t\tfor (i = 0; !sections[i].last && incomplete; i++) {\n\t\t\tif (sections[i].size == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strstr (sections[i].name, \"__objc_classlist\")) {\n\t\t\t\tincomplete--;\n\t\t\t\tclasslist_idx = i;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strstr (sections[i].name, \"__objc_data\")) {\n\t\t\t\tincomplete--;\n\t\t\t\tdata_idx = i;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (incomplete) {\n\t\t\tgoto next_bin;\n\t\t}\n\n\t\tint classlist_sample_size = R_MIN (64, sections[classlist_idx].size);\n\t\tint n_classes = classlist_sample_size / 8;\n\t\tut64 sect_offset = sections[classlist_idx].offset + bin->hdr_offset;\n\n\t\tif (r_buf_fread_at (cache->buf, sect_offset, (ut8*) classlist, \"l\", n_classes) != classlist_sample_size) {\n\t\t\tgoto next_bin;\n\t\t}\n\n\t\tut64 data_addr = sections[data_idx].addr;\n\t\tut64 data_tail = data_addr & 0xfff;\n\t\tut64 data_tail_end = (data_addr + sections[data_idx].size) & 0xfff;\n\t\tfor (i = 0; i < n_classes; i++) {\n\t\t\tut64 cl_addr = (classlist[i] & value_mask) + value_add;\n\t\t\tut64 cl_tail = cl_addr & 0xfff;\n\t\t\tif (cl_tail >= data_tail && cl_tail < data_tail_end) {\n\t\t\t\tut64 off = cl_tail - data_tail;\n\t\t\t\tslide = ((cl_addr - off) & value_mask) - (data_addr & value_mask);\n\t\t\t\tfound_sample = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\nnext_bin:\n\t\tMACH0_(mach0_free) (mach0);\n\t\tR_FREE (sections);\n\n\t\tif (found_sample) {\n\t\t\tbreak;\n\t\t}\n\t}\n\nbeach:\n\tR_FREE (classlist);\n\treturn slide;\n}\n\nstatic RDyldRebaseInfo *get_rebase_info(RBinFile *bf, RDyldCache *cache, ut64 slideInfoOffset, ut64 slideInfoSize, ut64 start_of_data, ut64 slide) {\n\tut8 *tmp_buf_1 = NULL;\n\tut8 *tmp_buf_2 = NULL;\n\tut8 *one_page_buf = NULL;\n\tRBuffer *cache_buf = cache->buf;\n\n\tut64 offset = slideInfoOffset;\n\tut32 slide_info_version = 0;\n\tif (r_buf_read_at (cache_buf, offset, (ut8*) &slide_info_version, 4) != 4) {\n\t\treturn NULL;\n\t}\n\n\tif (slide_info_version == 3) {\n\t\tcache_slide3_t slide_info;\n\t\tut64 size = sizeof (cache_slide3_t);\n\t\tif (r_buf_fread_at (cache_buf, offset, (ut8*) &slide_info, \"4i1l\", 1) < 20) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tut64 page_starts_offset = offset + size;\n\t\tut64 page_starts_size = slide_info.page_starts_count * 2;\n\n\t\tif (page_starts_size + size > slideInfoSize) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (page_starts_size > 0) {\n\t\t\ttmp_buf_1 = malloc (page_starts_size);\n\t\t\tif (!tmp_buf_1) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (cache_buf, page_starts_offset, tmp_buf_1, \"s\", slide_info.page_starts_count) != page_starts_size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\n\t\tif (slide_info.page_size > 0) {\n\t\t\tone_page_buf = malloc (slide_info.page_size);\n\t\t\tif (!one_page_buf) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\n\t\tRDyldRebaseInfo3 *rebase_info = R_NEW0 (RDyldRebaseInfo3);\n\t\tif (!rebase_info) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\trebase_info->version = 3;\n\t\trebase_info->delta_mask = 0x3ff8000000000000ULL;\n\t\trebase_info->delta_shift = 51;\n\t\trebase_info->start_of_data = start_of_data;\n\t\trebase_info->page_starts = (ut16*) tmp_buf_1;\n\t\trebase_info->page_starts_count = slide_info.page_starts_count;\n\t\trebase_info->auth_value_add = slide_info.auth_value_add;\n\t\trebase_info->page_size = slide_info.page_size;\n\t\trebase_info->one_page_buf = one_page_buf;\n\t\tif (slide == UT64_MAX) {\n\t\t\trebase_info->slide = estimate_slide (bf, cache, 0x7ffffffffffffULL, 0);\n\t\t\tif (rebase_info->slide) {\n\t\t\t\teprintf (\"dyldcache is slid: 0x%\"PFMT64x\"\\n\", rebase_info->slide);\n\t\t\t}\n\t\t} else {\n\t\t\trebase_info->slide = slide;\n\t\t}\n\n\t\treturn (RDyldRebaseInfo*) rebase_info;\n\t} else if (slide_info_version == 2 || slide_info_version == 4) {\n\t\tcache_slide2_t slide_info;\n\t\tut64 size = sizeof (cache_slide2_t);\n\t\tif (r_buf_fread_at (cache_buf, offset, (ut8*) &slide_info, \"6i2l\", 1) != size) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (slide_info.page_starts_offset == 0 ||\n\t\t\tslide_info.page_starts_offset > slideInfoSize ||\n\t\t\tslide_info.page_starts_offset + slide_info.page_starts_count * 2 > slideInfoSize) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (slide_info.page_extras_offset == 0 ||\n\t\t\tslide_info.page_extras_offset > slideInfoSize ||\n\t\t\tslide_info.page_extras_offset + slide_info.page_extras_count * 2 > slideInfoSize) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (slide_info.page_starts_count > 0) {\n\t\t\tut64 size = slide_info.page_starts_count * 2;\n\t\t\tut64 at = slideInfoOffset + slide_info.page_starts_offset;\n\t\t\ttmp_buf_1 = malloc (size);\n\t\t\tif (!tmp_buf_1) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (cache_buf, at, tmp_buf_1, \"s\", slide_info.page_starts_count) != size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\n\t\tif (slide_info.page_extras_count > 0) {\n\t\t\tut64 size = slide_info.page_extras_count * 2;\n\t\t\tut64 at = slideInfoOffset + slide_info.page_extras_offset;\n\t\t\ttmp_buf_2 = malloc (size);\n\t\t\tif (!tmp_buf_2) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (cache_buf, at, tmp_buf_2, \"s\", slide_info.page_extras_count) != size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\n\t\tif (slide_info.page_size > 0) {\n\t\t\tone_page_buf = malloc (slide_info.page_size);\n\t\t\tif (!one_page_buf) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\n\t\tRDyldRebaseInfo2 *rebase_info = R_NEW0 (RDyldRebaseInfo2);\n\t\tif (!rebase_info) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\trebase_info->version = slide_info_version;\n\t\trebase_info->start_of_data = start_of_data;\n\t\trebase_info->page_starts = (ut16*) tmp_buf_1;\n\t\trebase_info->page_starts_count = slide_info.page_starts_count;\n\t\trebase_info->page_extras = (ut16*) tmp_buf_2;\n\t\trebase_info->page_extras_count = slide_info.page_extras_count;\n\t\trebase_info->value_add = slide_info.value_add;\n\t\trebase_info->delta_mask = slide_info.delta_mask;\n\t\trebase_info->value_mask = ~rebase_info->delta_mask;\n\t\trebase_info->delta_shift = dumb_ctzll (rebase_info->delta_mask) - 2;\n\t\trebase_info->page_size = slide_info.page_size;\n\t\trebase_info->one_page_buf = one_page_buf;\n\t\tif (slide == UT64_MAX) {\n\t\t\trebase_info->slide = estimate_slide (bf, cache, rebase_info->value_mask, rebase_info->value_add);\n\t\t\tif (rebase_info->slide) {\n\t\t\t\teprintf (\"dyldcache is slid: 0x%\"PFMT64x\"\\n\", rebase_info->slide);\n\t\t\t}\n\t\t} else {\n\t\t\trebase_info->slide = slide;\n\t\t}\n\n\t\treturn (RDyldRebaseInfo*) rebase_info;\n\t} else if (slide_info_version == 1) {\n\t\tcache_slide1_t slide_info;\n\t\tut64 size = sizeof (cache_slide1_t);\n\t\tif (r_buf_fread_at (cache_buf, offset, (ut8*) &slide_info, \"6i\", 1) != size) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (slide_info.toc_offset == 0 ||\n\t\t\tslide_info.toc_offset > slideInfoSize ||\n\t\t\tslide_info.toc_offset + slide_info.toc_count * 2 > slideInfoSize) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (slide_info.entries_offset == 0 ||\n\t\t\tslide_info.entries_offset > slideInfoSize ||\n\t\t\tslide_info.entries_offset + slide_info.entries_count * slide_info.entries_size > slideInfoSize) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (slide_info.toc_count > 0) {\n\t\t\tut64 size = slide_info.toc_count * 2;\n\t\t\tut64 at = slideInfoOffset + slide_info.toc_offset;\n\t\t\ttmp_buf_1 = malloc (size);\n\t\t\tif (!tmp_buf_1) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (cache_buf, at, tmp_buf_1, \"s\", slide_info.toc_count) != size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\n\t\tif (slide_info.entries_count > 0) {\n\t\t\tut64 size = (ut64) slide_info.entries_count * (ut64) slide_info.entries_size;\n\t\t\tut64 at = slideInfoOffset + slide_info.entries_offset;\n\t\t\ttmp_buf_2 = malloc (size);\n\t\t\tif (!tmp_buf_2) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (r_buf_read_at (cache_buf, at, tmp_buf_2, size) != size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\n\t\tone_page_buf = malloc (4096);\n\t\tif (!one_page_buf) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tRDyldRebaseInfo1 *rebase_info = R_NEW0 (RDyldRebaseInfo1);\n\t\tif (!rebase_info) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\trebase_info->version = 1;\n\t\trebase_info->start_of_data = start_of_data;\n\t\trebase_info->one_page_buf = one_page_buf;\n\t\trebase_info->page_size = 4096;\n\t\trebase_info->toc = (ut16*) tmp_buf_1;\n\t\trebase_info->toc_count = slide_info.toc_count;\n\t\trebase_info->entries = tmp_buf_2;\n\t\trebase_info->entries_size = slide_info.entries_size;\n\t\tif (slide == UT64_MAX) {\n\t\t\trebase_info->slide = estimate_slide (bf, cache, UT64_MAX, 0);\n\t\t\tif (rebase_info->slide) {\n\t\t\t\teprintf (\"dyldcache is slid: 0x%\"PFMT64x\"\\n\", rebase_info->slide);\n\t\t\t}\n\t\t} else {\n\t\t\trebase_info->slide = slide;\n\t\t}\n\n\t\treturn (RDyldRebaseInfo*) rebase_info;\n\t} else {\n\t\teprintf (\"unsupported slide info version %d\\n\", slide_info_version);\n\t\treturn NULL;\n\t}\n\nbeach:\n\tR_FREE (tmp_buf_1);\n\tR_FREE (tmp_buf_2);\n\tR_FREE (one_page_buf);\n\treturn NULL;\n}\n\nstatic RDyldRebaseInfos *get_rebase_infos(RBinFile *bf, RDyldCache *cache) {\n\tRDyldRebaseInfos *result = R_NEW0 (RDyldRebaseInfos);\n\tif (!result) {\n\t\treturn NULL;\n\t}\n\n\tif (!cache->hdr->slideInfoOffset || !cache->hdr->slideInfoSize) {\n\t\tut32 total_slide_infos = 0;\n\t\tut32 n_slide_infos[MAX_N_HDR];\n\n\t\tut32 i;\n\t\tfor (i = 0; i < cache->n_hdr && i < MAX_N_HDR; i++) {\n\t\t\tut64 hdr_offset = cache->hdr_offset[i];\n\t\t\tif ((n_slide_infos[i] = r_buf_read_le32_at (cache->buf, 0x13c + hdr_offset)) == UT32_MAX) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\ttotal_slide_infos += n_slide_infos[i];\n\t\t}\n\n\t\tif (!total_slide_infos) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tRDyldRebaseInfosEntry * infos = R_NEWS0 (RDyldRebaseInfosEntry, total_slide_infos);\n\t\tif (!infos) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tut32 k = 0;\n\t\tfor (i = 0; i < cache->n_hdr && i < MAX_N_HDR; i++) {\n\t\t\tut64 hdr_offset = cache->hdr_offset[i];\n\t\t\tut64 slide_infos_offset;\n\t\t\tif (!n_slide_infos[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ((slide_infos_offset = r_buf_read_le32_at (cache->buf, 0x138 + hdr_offset)) == UT32_MAX) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!slide_infos_offset) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tslide_infos_offset += hdr_offset;\n\n\t\t\tut32 j;\n\t\t\tRDyldRebaseInfo *prev_info = NULL;\n\t\t\tfor (j = 0; j < n_slide_infos[i]; j++) {\n\t\t\t\tut64 offset = slide_infos_offset + j * sizeof (cache_mapping_slide);\n\t\t\t\tcache_mapping_slide entry;\n\t\t\t\tif (r_buf_fread_at (cache->buf, offset, (ut8*)&entry, \"6lii\", 1) != sizeof (cache_mapping_slide)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (entry.slideInfoOffset && entry.slideInfoSize) {\n\t\t\t\t\tinfos[k].start = entry.fileOffset + hdr_offset;\n\t\t\t\t\tinfos[k].end = infos[k].start + entry.size;\n\t\t\t\t\tut64 slide = prev_info ? prev_info->slide : UT64_MAX;\n\t\t\t\t\tinfos[k].info = get_rebase_info (bf, cache, entry.slideInfoOffset + hdr_offset, entry.slideInfoSize, entry.fileOffset + hdr_offset, slide);\n\t\t\t\t\tprev_info = infos[k].info;\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!k) {\n\t\t\tfree (infos);\n\t\t\tgoto beach;\n\t\t}\n\n\t\tif (k < total_slide_infos) {\n\t\t\tRDyldRebaseInfosEntry * pruned_infos = R_NEWS0 (RDyldRebaseInfosEntry, k);\n\t\t\tif (!pruned_infos) {\n\t\t\t\tfree (infos);\n\t\t\t\tgoto beach;\n\t\t\t}\n\n\t\t\tmemcpy (pruned_infos, infos, sizeof (RDyldRebaseInfosEntry) * k);\n\t\t\tfree (infos);\n\t\t\tinfos = pruned_infos;\n\t\t}\n\n\t\tresult->entries = infos;\n\t\tresult->length = k;\n\t\treturn result;\n\t}\n\n\tif (cache->hdr->mappingCount > 1) {\n\t\tRDyldRebaseInfosEntry * infos = R_NEWS0 (RDyldRebaseInfosEntry, 1);\n\t\tif (!infos) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tinfos[0].start = cache->maps[1].fileOffset;\n\t\tinfos[0].end = infos[0].start + cache->maps[1].size;\n\t\tinfos[0].info = get_rebase_info (bf, cache, cache->hdr->slideInfoOffset, cache->hdr->slideInfoSize, infos[0].start, UT64_MAX);\n\n\t\tresult->entries = infos;\n\t\tresult->length = 1;\n\t\treturn result;\n\t}\n\nbeach:\n\tfree (result);\n\treturn NULL;\n}\n\nstatic bool check_magic(const char *magic) {\n\treturn !strcmp (magic, \"dyld_v1   arm64\")\n\t\t|| !strcmp (magic, \"dyld_v1  arm64e\")\n\t\t|| !strcmp (magic, \"dyld_v1  x86_64\")\n\t\t|| !strcmp (magic, \"dyld_v1 x86_64h\");\n}\n\nstatic bool check_buffer(RBinFile *bf, RBuffer *buf) {\n\tif (r_buf_size (buf) < 32) {\n\t\treturn false;\n\t}\n\n\tchar hdr[17] = {0};\n\tint rhdr = r_buf_read_at (buf, 0, (ut8 *)&hdr, sizeof (hdr) - 1);\n\tif (rhdr != sizeof (hdr) - 1) {\n\t\treturn false;\n\t}\n\n\treturn check_magic (hdr);\n}\n\nstatic cache_imgxtr_t *read_cache_imgextra(RBuffer *cache_buf, cache_hdr_t *hdr, cache_accel_t *accel) {\n\tif (!cache_buf || !hdr || !hdr->imagesCount || !accel || !accel->imageExtrasCount || !accel->imagesExtrasOffset) {\n\t\treturn NULL;\n\t}\n\n\tut64 size = sizeof (cache_imgxtr_t) * accel->imageExtrasCount;\n\tcache_imgxtr_t *images = R_NEWS0 (cache_imgxtr_t, accel->imageExtrasCount);\n\tif (!images) {\n\t\treturn NULL;\n\t}\n\n\tif (r_buf_fread_at (cache_buf, accel->imagesExtrasOffset, (ut8*) images, \"ll4i\", accel->imageExtrasCount) != size) {\n\t\tR_FREE (images);\n\t\treturn NULL;\n\t}\n\n\treturn images;\n}\n\nstatic char *get_lib_name(RBuffer *cache_buf, cache_img_t *img) {\n\tchar file[256];\n\tchar *lib_name = file;\n\tif (r_buf_read_at (cache_buf, img->pathFileOffset, (ut8*) &file, sizeof (file)) == sizeof (file)) {\n\t\tfile[255] = 0;\n\t\t/*char * last_slash = strrchr (file, '/');\n\t\tif (last_slash && *last_slash) {\n\t\t\tlib_name = last_slash + 1;\n\t\t}*/\n\t\treturn strdup (lib_name);\n\t}\n\treturn strdup (\"FAIL\");\n}\n\nstatic int string_contains(const void *a, const void *b) {\n\treturn !strstr ((const char*) a, (const char*) b);\n}\n\nstatic HtPU *create_path_to_index(RBuffer *cache_buf, cache_img_t *img, cache_hdr_t *hdr) {\n\tHtPU *path_to_idx = ht_pu_new0 ();\n\tif (!path_to_idx) {\n\t\treturn NULL;\n\t}\n\tsize_t i;\n\tfor (i = 0; i != hdr->imagesCount; i++) {\n\t\tchar file[256];\n\t\tif (r_buf_read_at (cache_buf, img[i].pathFileOffset, (ut8*) &file, sizeof (file)) != sizeof (file)) {\n\t\t\tcontinue;\n\t\t}\n\t\tfile[sizeof (file) - 1] = 0;\n\t\tht_pu_insert (path_to_idx, file, (ut64)i);\n\n\t\tconst char versions_pattern[] = \".framework/Versions/\";\n\t\tchar *versions = strstr (file, versions_pattern);\n\t\tif (versions) {\n\t\t\tchar *next_slash = strchr (versions + 20, '/');\n\t\t\tif (next_slash) {\n\t\t\t\tchar *tail = strdup (next_slash);\n\t\t\t\tif (!tail) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstrcpy (versions + 10, tail);\n\t\t\t\tfree (tail);\n\t\t\t\tht_pu_insert (path_to_idx, file, (ut64)i);\n\t\t\t}\n\t\t}\n\t}\n\treturn path_to_idx;\n}\n\nstatic void carve_deps_at_address(RDyldCache *cache, cache_img_t *img, HtPU *path_to_idx, ut64 address, int *deps, bool printing) {\n\tut64 pa = va2pa (address, cache->n_maps, cache->maps, cache->buf, 0, NULL, NULL);\n\tif (pa == UT64_MAX) {\n\t\treturn;\n\t}\n\tstruct MACH0_(mach_header) mh;\n\tif (r_buf_fread_at (cache->buf, pa, (ut8*) &mh, \"8i\", 1) != sizeof (struct MACH0_(mach_header))) {\n\t\treturn;\n\t}\n\tif (mh.magic != MH_MAGIC_64 || mh.sizeofcmds == 0) {\n\t\treturn;\n\t}\n\tut64 cmds_at = pa + sizeof (struct MACH0_(mach_header));\n\tut8 *cmds = malloc (mh.sizeofcmds + 1);\n\tif (!cmds || r_buf_read_at (cache->buf, cmds_at, cmds, mh.sizeofcmds) != mh.sizeofcmds) {\n\t\tgoto beach;\n\t}\n\tcmds[mh.sizeofcmds] = 0;\n\tut8 *cursor = cmds;\n\tut8 *end = cmds + mh.sizeofcmds;\n\twhile (cursor < end) {\n\t\tut32 cmd = r_read_le32 (cursor);\n\t\tut32 cmdsize = r_read_le32 (cursor + sizeof (ut32));\n\t\tif (cmd == LC_LOAD_DYLIB ||\n\t\t\t\tcmd == LC_LOAD_WEAK_DYLIB ||\n\t\t\t\tcmd == LC_REEXPORT_DYLIB ||\n\t\t\t\tcmd == LC_LOAD_UPWARD_DYLIB) {\n\t\t\tbool found;\n\t\t\tif (cursor + 24 >= end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst char *key = (const char *) cursor + 24;\n\t\t\tsize_t dep_index = (size_t)ht_pu_find (path_to_idx, key, &found);\n\t\t\tif (!found || dep_index >= cache->hdr->imagesCount) {\n\t\t\t\teprintf (\"Warning: alien dep '%s'\\n\", key);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdeps[dep_index]++;\n\t\t\tif (printing) {\n\t\t\t\teprintf (\"-> %s\\n\", key);\n\t\t\t}\n\t\t}\n\t\tcursor += cmdsize;\n\t}\n\nbeach:\n\tfree (cmds);\n}\n\nstatic ut64 resolve_symbols_off(RDyldCache *cache, ut64 pa) {\n\tstruct MACH0_(mach_header) mh;\n\tif (r_buf_fread_at (cache->buf, pa, (ut8*) &mh, \"8i\", 1) != sizeof (struct MACH0_(mach_header))) {\n\t\treturn 0;\n\t}\n\tif (mh.magic != MH_MAGIC_64 || mh.sizeofcmds == 0) {\n\t\treturn 0;\n\t}\n\tut64 cmds_at = pa + sizeof (struct MACH0_(mach_header));\n\tut64 cursor = cmds_at;\n\tut64 end = cursor + mh.sizeofcmds;\n\twhile (cursor < end) {\n\t\tut32 cmd = r_buf_read_le32_at (cache->buf, cursor);\n\t\tif (cmd == UT32_MAX) {\n\t\t\treturn 0;\n\t\t}\n\t\tut32 cmdsize = r_buf_read_le32_at (cache->buf, cursor + sizeof (ut32));\n\t\tif (cmdsize == UT32_MAX) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (cmd == LC_SEGMENT || cmd == LC_SEGMENT_64) {\n\t\t\tchar segname[17];\n\t\t\tsegname[16] = 0;\n\t\t\tif (r_buf_read_at (cache->buf, cursor + 2 * sizeof (ut32), (ut8 *)segname, 16) != 16) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!strncmp (segname, \"__LINKEDIT\", 16)) {\n\t\t\t\tut64 vmaddr = r_buf_read_le64_at (cache->buf, cursor + 2 * sizeof (ut32) + 16);\n\t\t\t\tif (vmaddr == UT64_MAX) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\tut32 i,j;\n\t\t\t\tfor (i = 0; i < cache->n_hdr; i++) {\n\t\t\t\t\tcache_hdr_t *hdr = &cache->hdr[i];\n\t\t\t\t\tut64 hdr_offset = cache->hdr_offset[i];\n\t\t\t\t\tut32 maps_index = cache->maps_index[i];\n\t\t\t\t\tfor (j = 0; j < hdr->mappingCount; j++) {\n\t\t\t\t\t\tut64 map_start = cache->maps[maps_index + j].address;\n\t\t\t\t\t\tut64 map_end = map_start + cache->maps[maps_index + j].size;\n\t\t\t\t\t\tif (vmaddr >= map_start && vmaddr < map_end) {\n\t\t\t\t\t\t\treturn hdr_offset;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcursor += cmdsize;\n\t}\n\treturn 0;\n}\n\nstatic RList *create_cache_bins(RBinFile *bf, RDyldCache *cache) {\n\tRList *bins = r_list_newf ((RListFree)free_bin);\n\tut16 *depArray = NULL;\n\tcache_imgxtr_t *extras = NULL;\n\tif (!bins) {\n\t\treturn NULL;\n\t}\n\n\tchar *target_libs = NULL;\n\tRList *target_lib_names = NULL;\n\tint *deps = NULL;\n\ttarget_libs = r_sys_getenv (\"R_DYLDCACHE_FILTER\");\n\tif (target_libs) {\n\t\ttarget_lib_names = r_str_split_list (target_libs, \":\", 0);\n\t\tif (!target_lib_names) {\n\t\t\tr_list_free (bins);\n\t\t\treturn NULL;\n\t\t}\n\t\tdeps = R_NEWS0 (int, cache->hdr->imagesCount);\n\t\tif (!deps) {\n\t\t\tr_list_free (bins);\n\t\t\tr_list_free (target_lib_names);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tut32 i;\n\tfor (i = 0; i < cache->n_hdr; i++) {\n\t\tcache_hdr_t *hdr = &cache->hdr[i];\n\t\tut64 hdr_offset = cache->hdr_offset[i];\n\t\tut32 maps_index = cache->maps_index[i];\n\t\tcache_img_t *img = read_cache_images (cache->buf, hdr, hdr_offset);\n\t\tif (!img) {\n\t\t\tgoto next;\n\t\t}\n\n\t\tut32 j;\n\t\tif (target_libs) {\n\t\t\tHtPU *path_to_idx = NULL;\n\t\t\tif (cache->accel) {\n\t\t\t\tdepArray = R_NEWS0 (ut16, cache->accel->depListCount);\n\t\t\t\tif (!depArray) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\n\t\t\t\tif (r_buf_fread_at (cache->buf, cache->accel->depListOffset, (ut8*) depArray, \"s\", cache->accel->depListCount) != cache->accel->depListCount * 2) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\n\t\t\t\textras = read_cache_imgextra (cache->buf, hdr, cache->accel);\n\t\t\t\tif (!extras) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpath_to_idx = create_path_to_index (cache->buf, img, hdr);\n\t\t\t}\n\n\t\t\tfor (j = 0; j < hdr->imagesCount; j++) {\n\t\t\t\tbool printing = !deps[j];\n\t\t\t\tchar *lib_name = get_lib_name (cache->buf, &img[j]);\n\t\t\t\tif (!lib_name) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (strstr (lib_name, \"libobjc.A.dylib\")) {\n\t\t\t\t\tdeps[j]++;\n\t\t\t\t}\n\t\t\t\tif (!r_list_find (target_lib_names, lib_name, string_contains)) {\n\t\t\t\t\tR_FREE (lib_name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (printing) {\n\t\t\t\t\teprintf (\"FILTER: %s\\n\", lib_name);\n\t\t\t\t}\n\t\t\t\tR_FREE (lib_name);\n\t\t\t\tdeps[j]++;\n\n\t\t\t\tif (extras && depArray) {\n\t\t\t\t\tut32 k;\n\t\t\t\t\tfor (k = extras[j].dependentsStartArrayIndex; depArray[k] != 0xffff; k++) {\n\t\t\t\t\t\tut16 dep_index = depArray[k] & 0x7fff;\n\t\t\t\t\t\tdeps[dep_index]++;\n\n\t\t\t\t\t\tchar *dep_name = get_lib_name (cache->buf, &img[dep_index]);\n\t\t\t\t\t\tif (!dep_name) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (printing) {\n\t\t\t\t\t\t\teprintf (\"-> %s\\n\", dep_name);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree (dep_name);\n\t\t\t\t\t}\n\t\t\t\t} else if (path_to_idx) {\n\t\t\t\t\tcarve_deps_at_address (cache, img, path_to_idx, img[j].address, deps, printing);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tht_pu_free (path_to_idx);\n\t\t\tR_FREE (depArray);\n\t\t\tR_FREE (extras);\n\t\t}\n\n\t\tfor (j = 0; j < hdr->imagesCount; j++) {\n\t\t\tif (deps && !deps[j]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// ut64 pa = va2pa (img[j].address, hdr->mappingCount, &cache->maps[maps_index], cache->buf, 0, NULL, NULL);\n\t\t\tut64 pa = va2pa (img[j].address, cache->n_maps, &cache->maps[maps_index], cache->buf, 0, NULL, NULL);\n\t\t\tif (pa == UT64_MAX) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tut8 magicbytes[4];\n\t\t\tr_buf_read_at (cache->buf, pa, magicbytes, 4);\n\t\t\tint magic = r_read_le32 (magicbytes);\n\t\t\tswitch (magic) {\n\t\t\tcase MH_MAGIC_64:\n\t\t\t{\n\t\t\t\tchar file[256];\n\t\t\t\tRDyldBinImage *bin = R_NEW0 (RDyldBinImage);\n\t\t\t\tif (!bin) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t\tbin->header_at = pa;\n\t\t\t\tbin->hdr_offset = hdr_offset;\n\t\t\t\tbin->symbols_off = resolve_symbols_off (cache, pa);\n\t\t\t\tbin->va = img[j].address;\n\t\t\t\tif (r_buf_read_at (cache->buf, img[j].pathFileOffset, (ut8*) &file, sizeof (file)) == sizeof (file)) {\n\t\t\t\t\tfile[255] = 0;\n\t\t\t\t\tchar *last_slash = strrchr (file, '/');\n\t\t\t\t\tif (last_slash && *last_slash) {\n\t\t\t\t\t\tif (last_slash > file) {\n\t\t\t\t\t\t\tchar *scan = last_slash - 1;\n\t\t\t\t\t\t\twhile (scan > file && *scan != '/') {\n\t\t\t\t\t\t\t\tscan--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (*scan == '/') {\n\t\t\t\t\t\t\t\tbin->file = strdup (scan + 1);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbin->file = strdup (last_slash + 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbin->file = strdup (last_slash + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbin->file = strdup (file);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr_list_append (bins, bin);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\teprintf (\"Unknown sub-bin\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\nnext:\n\t\tR_FREE (depArray);\n\t\tR_FREE (extras);\n\t\tR_FREE (img);\n\t}\n\tif (r_list_empty (bins)) {\n\t\tr_list_free (bins);\n\t\tbins = NULL;\n\t}\n\tR_FREE (deps);\n\tR_FREE (target_libs);\n\tr_list_free (target_lib_names);\n\treturn bins;\n}\n\nstatic void rebase_bytes_v1(RDyldRebaseInfo1 *rebase_info, ut8 *buf, ut64 offset, int count, ut64 start_of_write) {\n\tint in_buf = 0;\n\twhile (in_buf < count) {\n\t\tut64 offset_in_data = offset - rebase_info->start_of_data;\n\t\tut64 page_index = offset_in_data / rebase_info->page_size;\n\t\tut64 page_offset = offset_in_data % rebase_info->page_size;\n\t\tut64 to_next_page = rebase_info->page_size - page_offset;\n\t\tut64 entry_index = page_offset / 32;\n\t\tut64 offset_in_entry = (page_offset % 32) / 4;\n\n\t\tif (entry_index >= rebase_info->entries_size) {\n\t\t\tin_buf += to_next_page;\n\t\t\toffset += to_next_page;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (page_index >= rebase_info->toc_count) {\n\t\t\tbreak;\n\t\t}\n\n\t\tut8 *entry = &rebase_info->entries[rebase_info->toc[page_index] * rebase_info->entries_size];\n\t\tut8 b = entry[entry_index];\n\n\t\tif (b & (1 << offset_in_entry)) {\n\t\t\tut64 value = r_read_le64 (buf + in_buf);\n\t\t\tvalue += rebase_info->slide;\n\t\t\tr_write_le64 (buf + in_buf, value);\n\t\t\tin_buf += 8;\n\t\t\toffset += 8;\n\t\t} else {\n\t\t\tin_buf += 4;\n\t\t\toffset += 4;\n\t\t}\n\t}\n}\n\nstatic void rebase_bytes_v2(RDyldRebaseInfo2 *rebase_info, ut8 *buf, ut64 offset, int count, ut64 start_of_write) {\n\tint in_buf = 0;\n\twhile (in_buf < count) {\n\t\tut64 offset_in_data = offset - rebase_info->start_of_data;\n\t\tut64 page_index = offset_in_data / rebase_info->page_size;\n\t\tut64 page_offset = offset_in_data % rebase_info->page_size;\n\t\tut64 to_next_page = rebase_info->page_size - page_offset;\n\n\t\tif (page_index >= rebase_info->page_starts_count) {\n\t\t\tgoto next_page;\n\t\t}\n\t\tut16 page_flag = rebase_info->page_starts[page_index];\n\n\t\tif (page_flag == DYLD_CACHE_SLIDE_PAGE_ATTR_NO_REBASE) {\n\t\t\tgoto next_page;\n\t\t}\n\n\t\tif (!(page_flag & DYLD_CACHE_SLIDE_PAGE_ATTR_EXTRA)) {\n\t\t\tut64 first_rebase_off = rebase_info->page_starts[page_index] * 4;\n\t\t\tif (first_rebase_off >= page_offset && first_rebase_off < page_offset + count) {\n\t\t\t\tut32 delta = 1;\n\t\t\t\twhile (delta) {\n\t\t\t\t\tut64 position = in_buf + first_rebase_off - page_offset;\n\t\t\t\t\tif (position >= count) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tut64 raw_value = r_read_le64 (buf + position);\n\t\t\t\t\tdelta = ((raw_value & rebase_info->delta_mask) >> rebase_info->delta_shift);\n\t\t\t\t\tif (position >= start_of_write) {\n\t\t\t\t\t\tut64 new_value = raw_value & rebase_info->value_mask;\n\t\t\t\t\t\tif (new_value != 0) {\n\t\t\t\t\t\t\tnew_value += rebase_info->value_add;\n\t\t\t\t\t\t\tnew_value += rebase_info->slide;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_write_le64 (buf + position, new_value);\n\t\t\t\t\t}\n\t\t\t\t\tfirst_rebase_off += delta;\n\t\t\t\t}\n\t\t\t}\n\t\t}\nnext_page:\n\t\tin_buf += to_next_page;\n\t\toffset += to_next_page;\n\t}\n}\n\nstatic void rebase_bytes_v3(RDyldRebaseInfo3 *rebase_info, ut8 *buf, ut64 offset, int count, ut64 start_of_write) {\n\tint in_buf = 0;\n\twhile (in_buf < count) {\n\t\tut64 offset_in_data = offset - rebase_info->start_of_data;\n\t\tut64 page_index = offset_in_data / rebase_info->page_size;\n\t\tut64 page_offset = offset_in_data % rebase_info->page_size;\n\t\tut64 to_next_page = rebase_info->page_size - page_offset;\n\n\t\tif (page_index >= rebase_info->page_starts_count) {\n\t\t\tgoto next_page;\n\t\t}\n\t\tut64 delta = rebase_info->page_starts[page_index];\n\n\t\tif (delta == DYLD_CACHE_SLIDE_V3_PAGE_ATTR_NO_REBASE) {\n\t\t\tgoto next_page;\n\t\t}\n\n\t\tut64 first_rebase_off = delta;\n\t\tif (first_rebase_off >= page_offset && first_rebase_off < page_offset + count) {\n\t\t\tdo {\n\t\t\t\tut64 position = in_buf + first_rebase_off - page_offset;\n\t\t\t\tif (position >= count) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tut64 raw_value = r_read_le64 (buf + position);\n\t\t\t\tdelta = ((raw_value & rebase_info->delta_mask) >> rebase_info->delta_shift) * 8;\n\t\t\t\tif (position >= start_of_write) {\n\t\t\t\t\tut64 new_value = 0;\n\t\t\t\t\tif (R_IS_PTR_AUTHENTICATED (raw_value)) {\n\t\t\t\t\t\tnew_value = (raw_value & 0xFFFFFFFFULL) + rebase_info->auth_value_add;\n\t\t\t\t\t\t// TODO: don't throw auth info away\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnew_value = ((raw_value << 13) & 0xFF00000000000000ULL) | (raw_value & 0x7ffffffffffULL);\n\t\t\t\t\t\tnew_value &= 0x00FFFFFFFFFFFFFFULL;\n\t\t\t\t\t}\n\t\t\t\t\tif (new_value != 0) {\n\t\t\t\t\t\tnew_value += rebase_info->slide;\n\t\t\t\t\t}\n\t\t\t\t\tr_write_le64 (buf + position, new_value);\n\t\t\t\t}\n\t\t\t\tfirst_rebase_off += delta;\n\t\t\t} while (delta);\n\t\t}\nnext_page:\n\t\tin_buf += to_next_page;\n\t\toffset += to_next_page;\n\t}\n}\n\nstatic RDyldRebaseInfo *rebase_info_by_range(RDyldRebaseInfos *infos, ut64 offset, int count) {\n\tint imid;\n\tint imin = 0;\n\tint imax = infos->length - 1;\n\n\twhile (imin < imax) {\n\t\timid = (imin + imax) / 2;\n\t\tRDyldRebaseInfosEntry *entry = &infos->entries[imid];\n\t\tif ((entry->end) <= offset) {\n\t\t\timin = imid + 1;\n\t\t} else {\n\t\t\timax = imid;\n\t\t}\n\t}\n\n\tRDyldRebaseInfosEntry *minEntry = &infos->entries[imin];\n\tif ((imax == imin) && (minEntry->start <= offset + count) && (minEntry->end >= offset)) {\n\t\treturn minEntry->info;\n\t}\n\treturn NULL;\n}\n\nstatic void rebase_bytes(RDyldRebaseInfo *rebase_info, ut8 *buf, ut64 offset, int count, ut64 start_of_write) {\n\tif (!rebase_info || !buf) {\n\t\treturn;\n\t}\n\n\tif (rebase_info->version == 3) {\n\t\trebase_bytes_v3 ((RDyldRebaseInfo3*) rebase_info, buf, offset, count, start_of_write);\n\t} else if (rebase_info->version == 2 || rebase_info->version == 4) {\n\t\trebase_bytes_v2 ((RDyldRebaseInfo2*) rebase_info, buf, offset, count, start_of_write);\n\t} else if (rebase_info->version == 1) {\n\t\trebase_bytes_v1 ((RDyldRebaseInfo1*) rebase_info, buf, offset, count, start_of_write);\n\t}\n}\n\nstatic int dyldcache_io_read(RIO *io, RIODesc *fd, ut8 *buf, int count) {\n\tr_return_val_if_fail (io, -1);\n\tRCore *core = (RCore*) io->corebind.core;\n\n\tif (!core || !core->bin || !core->bin->binfiles) {\n\t\treturn -1;\n\t}\n\n\tRDyldCache *cache = NULL;\n\tRListIter *iter;\n\tRBinFile *bf;\n\tr_list_foreach (core->bin->binfiles, iter, bf) {\n\t\tif (bf->fd == fd->fd ) {\n\t\t\tif (!strncmp ((char*) bf->o->bin_obj, \"dyldcac\", 7)) {\n\t\t\t\tcache = bf->o->bin_obj;\n\t\t\t} else {\n\t\t\t\tcache = ((struct MACH0_(obj_t)*) bf->o->bin_obj)->user;\n\t\t\t}\n\t\t\tif (pending_bin_files) {\n\t\t\t\tRListIter *to_remove = r_list_contains (pending_bin_files, bf);\n\t\t\t\tif (to_remove) {\n\t\t\t\t\tr_list_delete (pending_bin_files, to_remove);\n\t\t\t\t\tif (r_list_empty (pending_bin_files)) {\n\t\t\t\t\t\tr_list_free (pending_bin_files);\n\t\t\t\t\t\tpending_bin_files = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!cache) {\n\t\tr_list_foreach (pending_bin_files, iter, bf) {\n\t\t\tif (bf->fd == fd->fd && bf->o) {\n\t\t\t\tif (!strncmp ((char*) bf->o->bin_obj, \"dyldcac\", 7)) {\n\t\t\t\t\tcache = bf->o->bin_obj;\n\t\t\t\t} else {\n\t\t\t\t\tcache = ((struct MACH0_(obj_t)*) bf->o->bin_obj)->user;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (!cache || !cache->original_io_read) {\n\t\tif (fd->plugin->read == &dyldcache_io_read) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn fd->plugin->read (io, fd, buf, count);\n\t}\n\n\tRDyldRebaseInfo *rebase_info = rebase_info_by_range (cache->rebase_infos, io->off, count);\n\n\tint result = 0;\n\n\tif (rebase_info && count > 0) {\n\t\tut64 offset_in_data = io->off - rebase_info->start_of_data;\n\t\tut64 page_offset = offset_in_data % rebase_info->page_size;\n\n\t\tut64 internal_offset = io->off & ~(rebase_info->page_size - 1);\n\t\tut64 internal_end = io->off + count;\n\t\tint rounded_count = internal_end - internal_offset;\n\n\t\tut8 *internal_buf = rebase_info->one_page_buf;\n\t\tif (rounded_count > rebase_info->page_size) {\n\t\t\tinternal_buf = malloc (rounded_count);\n\t\t\tif (!internal_buf) {\n\t\t\t\teprintf (\"Cannot allocate memory for 'internal_buf'\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tut64 original_off = io->off;\n\t\tio->off = internal_offset;\n\n\t\tint internal_result = cache->original_io_read (io, fd, internal_buf, rounded_count);\n\n\t\tio->off = original_off;\n\n\t\tif (internal_result >= page_offset + count) {\n\t\t\trebase_bytes (rebase_info, internal_buf, internal_offset, internal_result, page_offset);\n\t\t\tresult = R_MIN (count, internal_result);\n\t\t\tmemcpy (buf, internal_buf + page_offset, result);\n\t\t} else {\n\t\t\teprintf (\"ERROR rebasing\\n\");\n\t\t\tresult = cache->original_io_read (io, fd, buf, count);\n\t\t}\n\n\t\tif (internal_buf != rebase_info->one_page_buf) {\n\t\t\tR_FREE (internal_buf);\n\t\t}\n\t} else {\n\t\tresult = cache->original_io_read (io, fd, buf, count);\n\t}\n\n\treturn result;\n}\n\nstatic void swizzle_io_read(RDyldCache *cache, RIO *io) {\n\tif (!io || !io->desc || !io->desc->plugin) {\n\t\treturn;\n\t}\n\n\tRIOPlugin *plugin = io->desc->plugin;\n\tcache->original_io_read = plugin->read;\n\tplugin->read = &dyldcache_io_read;\n}\n\nstatic cache_hdr_t *read_cache_header(RBuffer *cache_buf, ut64 offset) {\n\tif (!cache_buf) {\n\t\treturn NULL;\n\t}\n\n\tcache_hdr_t *hdr = R_NEW0 (cache_hdr_t);\n\tif (!hdr) {\n\t\treturn NULL;\n\t}\n\n\tut64 size = sizeof (cache_hdr_t);\n\tif (r_buf_fread_at (cache_buf, offset, (ut8*) hdr, \"16c4i7l16clii4l\", 1) != size) {\n\t\tR_FREE (hdr);\n\t\treturn NULL;\n\t}\n\tif (!check_magic (hdr->magic)) {\n\t\tR_FREE (hdr);\n\t\treturn NULL;\n\t}\n\n\tif (!hdr->imagesCount && !hdr->imagesOffset) {\n\t\thdr->imagesOffset = r_buf_read_le32_at (cache_buf, 0x1c0 + offset);\n\t\thdr->imagesCount = r_buf_read_le32_at (cache_buf, 0x1c4 + offset);\n\t}\n\treturn hdr;\n}\n\n\nstatic void populate_cache_headers(RDyldCache *cache) {\n\tcache->n_hdr = 0;\n\tRList *hdrs = r_list_newf (NULL);\n\tif (!hdrs) {\n\t\treturn;\n\t}\n\n\tcache_hdr_t *h;\n\tut64 offsets[MAX_N_HDR];\n\tut64 offset = 0;\n\tdo {\n\t\toffsets[cache->n_hdr] = offset;\n\t\th = read_cache_header (cache->buf, offset);\n\t\tif (!h) {\n\t\t\tbreak;\n\t\t}\n\t\tr_list_append (hdrs, h);\n\n\t\tut64 size = h->codeSignatureOffset + h->codeSignatureSize;\n\n#define SHIFT_MAYBE(x) \\\n\tif (x) { \\\n\t\tx += offset; \\\n\t}\n\n\t\tSHIFT_MAYBE (h->mappingOffset);\n\t\tSHIFT_MAYBE (h->imagesOffset);\n\t\tSHIFT_MAYBE (h->codeSignatureOffset);\n\t\tSHIFT_MAYBE (h->slideInfoOffset);\n\t\tSHIFT_MAYBE (h->localSymbolsOffset);\n\t\tSHIFT_MAYBE (h->branchPoolsOffset);\n\t\tSHIFT_MAYBE (h->imagesTextOffset);\n\n\t\toffset += size;\n\t\tcache->n_hdr++;\n\t} while (cache->n_hdr < MAX_N_HDR);\n\n\tif (!cache->n_hdr) {\n\t\tgoto beach;\n\t}\n\n\tcache->hdr = R_NEWS0 (cache_hdr_t, cache->n_hdr);\n\tif (!cache->hdr) {\n\t\tcache->n_hdr = 0;\n\t\tgoto beach;\n\t}\n\n\tcache->hdr_offset = R_NEWS0 (ut64, cache->n_hdr);\n\tif (!cache->hdr_offset) {\n\t\tcache->n_hdr = 0;\n\t\tR_FREE (cache->hdr);\n\t\tgoto beach;\n\t}\n\n\tmemcpy (cache->hdr_offset, offsets, cache->n_hdr * sizeof (ut64));\n\n\tut32 i = 0;\n\tRListIter *iter;\n\tcache_hdr_t *item;\n\tr_list_foreach (hdrs, iter, item) {\n\t\tif (i >= cache->n_hdr) {\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy (&cache->hdr[i++], item, sizeof (cache_hdr_t));\n\t}\n\nbeach:\n\tr_list_free (hdrs);\n}\n\nstatic void populate_cache_maps(RDyldCache *cache) {\n\tr_return_if_fail (cache && cache->buf);\n\n\tut32 i;\n\tut32 n_maps = 0;\n\tfor (i = 0; i < cache->n_hdr; i++) {\n\t\tcache_hdr_t *hdr = &cache->hdr[i];\n\t\tif (!hdr->mappingCount || !hdr->mappingOffset) {\n\t\t\tcontinue;\n\t\t}\n\t\tn_maps += hdr->mappingCount;\n\t}\n\n\tcache_map_t *maps = NULL;\n\tif (n_maps != 0) {\n\t\tcache->maps_index = R_NEWS0 (ut32, cache->n_hdr);\n\t\tif (!cache->maps_index) {\n\t\t\treturn;\n\t\t}\n\t\tmaps = R_NEWS0 (cache_map_t, n_maps);\n\t}\n\tif (!maps) {\n\t\tcache->maps = NULL;\n\t\tcache->n_maps = 0;\n\t\treturn;\n\t}\n\n\tut32 next_map = 0;\n\tfor (i = 0; i < cache->n_hdr; i++) {\n\t\tcache_hdr_t *hdr = &cache->hdr[i];\n\t\tcache->maps_index[i] = next_map;\n\n\t\tif (!hdr->mappingCount || !hdr->mappingOffset) {\n\t\t\tcontinue;\n\t\t}\n\t\tut64 size = sizeof (cache_map_t) * hdr->mappingCount;\n\t\tif (r_buf_fread_at (cache->buf, hdr->mappingOffset, (ut8*) &maps[next_map], \"3l2i\", hdr->mappingCount) != size) {\n\t\t\tcontinue;\n\t\t}\n\t\tut32 j;\n\t\tut64 hdr_offset = cache->hdr_offset[i];\n\t\tfor (j = 0; j < hdr->mappingCount; j++) {\n\t\t\tcache_map_t *map = &maps[next_map + j];\n\t\t\tmap->fileOffset += hdr_offset;\n\t\t}\n\t\tnext_map += hdr->mappingCount;\n\t}\n\n\tcache->maps = maps;\n\tcache->n_maps = next_map;\n}\n\nstatic cache_accel_t *read_cache_accel(RBuffer *cache_buf, cache_hdr_t *hdr, cache_map_t *maps, int n_maps) {\n\tif (!cache_buf || !hdr || !hdr->accelerateInfoSize || !hdr->accelerateInfoAddr) {\n\t\treturn NULL;\n\t}\n\tsize_t mc = R_MIN (hdr->mappingCount, n_maps);\n\tut64 offset = va2pa (hdr->accelerateInfoAddr, mc, maps, cache_buf, 0, NULL, NULL);\n\tif (!offset) {\n\t\treturn NULL;\n\t}\n\n\tut64 size = sizeof (cache_accel_t);\n\tcache_accel_t *accel = R_NEW0 (cache_accel_t);\n\tif (!accel) {\n\t\treturn NULL;\n\t}\n\n\tif (r_buf_fread_at (cache_buf, offset, (ut8*) accel, \"16il\", 1) != size) {\n\t\tR_FREE (accel);\n\t\treturn NULL;\n\t}\n\n\taccel->imagesExtrasOffset += offset;\n\taccel->bottomUpListOffset += offset;\n\taccel->dylibTrieOffset += offset;\n\taccel->initializersOffset += offset;\n\taccel->dofSectionsOffset += offset;\n\taccel->reExportListOffset += offset;\n\taccel->depListOffset += offset;\n\taccel->rangeTableOffset += offset;\n\n\treturn accel;\n}\n\nstatic objc_cache_opt_info *get_objc_opt_info(RBinFile *bf, RDyldCache *cache) {\n\tobjc_cache_opt_info *result = NULL;\n\tRListIter *iter;\n\tRDyldBinImage *bin;\n\tr_list_foreach (cache->bins, iter, bin) {\n\t\tif (strcmp (bin->file, \"lib/libobjc.A.dylib\")) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tstruct MACH0_(opts_t) opts = {0};\n\t\topts.verbose = bf->rbin->verbose;\n\t\topts.header_at = bin->header_at;\n\t\topts.symbols_off = 0;\n\n\t\tstruct MACH0_(obj_t) *mach0 = MACH0_(new_buf) (cache->buf, &opts);\n\t\tif (!mach0) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tstruct section_t *sections = NULL;\n\t\tif (!(sections = MACH0_(get_sections) (mach0))) {\n\t\t\tMACH0_(mach0_free) (mach0);\n\t\t\tgoto beach;\n\t\t}\n\n\t\tint i;\n\t\tut64 scoffs_offset = 0;\n\t\tut64 scoffs_size = 0;\n\t\tut64 selrefs_offset = 0;\n\t\tut64 selrefs_size = 0;\n\t\tut8 remaining = 2;\n\t\tut64 slide = rebase_infos_get_slide (cache);\n\t\tfor (i = 0; !sections[i].last; i++) {\n\t\t\tif (sections[i].size == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strstr (sections[i].name, \"__objc_scoffs\")) {\n\t\t\t\tscoffs_offset = va2pa (sections[i].addr, cache->n_maps, cache->maps, cache->buf, slide, NULL, NULL);\n\t\t\t\tscoffs_size = sections[i].size;\n\t\t\t\tremaining--;\n\t\t\t\tif (remaining == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (strstr (sections[i].name, \"__DATA.__objc_selrefs\")) {\n\t\t\t\tselrefs_offset = va2pa (sections[i].addr, cache->n_maps, cache->maps, cache->buf, slide, NULL, NULL);\n\t\t\t\tselrefs_size = sections[i].size;\n\t\t\t\tremaining--;\n\t\t\t\tif (remaining == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tMACH0_(mach0_free) (mach0);\n\t\tR_FREE (sections);\n\n\t\tut64 sel_string_base = 0;\n\t\tif (!scoffs_offset || scoffs_size < 40) {\n\t\t\tif (!selrefs_offset || !selrefs_size || cache->n_hdr == 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut64 cursor = selrefs_offset;\n\t\t\tut64 end = cursor + selrefs_size;\n\t\t\twhile (cursor < end) {\n\t\t\t\tut64 sel_ptr = r_buf_read_le64_at (cache->buf, cursor);\n\t\t\t\tif (sel_ptr == UT64_MAX) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tut64 sel_offset = va2pa (sel_ptr, cache->n_maps, cache->maps, cache->buf, slide, NULL, NULL);\n\t\t\t\tchar * selector = r_buf_get_string (cache->buf, sel_offset);\n\t\t\t\tif (!selector) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbool is_magic_selector = !strncmp (selector, \"\\xf0\\x9f\\xa4\\xaf\", 4);\n\t\t\t\tfree (selector);\n\n\t\t\t\tif (is_magic_selector) {\n\t\t\t\t\tsel_string_base = sel_ptr;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcursor += 8;\n\t\t\t}\n\t\t\tif (sel_string_base == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tut64 check = r_buf_read_le64_at (cache->buf, scoffs_offset);\n\t\t\tif (check != 2) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsel_string_base = r_buf_read_le64_at (cache->buf, scoffs_offset + 8);\n\t\t\tif (sel_string_base == UT64_MAX) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut64 sel_string_end = r_buf_read_le64_at (cache->buf, scoffs_offset + 16);\n\t\t\tif (sel_string_end == sel_string_base || sel_string_end == UT64_MAX) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tresult = R_NEW0 (objc_cache_opt_info);\n\t\tif (!result) {\n\t\t\tbreak;\n\t\t}\n\t\tresult->sel_string_base = sel_string_base;\n\t}\nbeach:\n\treturn result;\n}\n\nstatic bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {\n\tRDyldCache *cache = R_NEW0 (RDyldCache);\n\tmemcpy (cache->magic, \"dyldcac\", 7);\n\tcache->buf = r_buf_ref (buf);\n\tpopulate_cache_headers (cache);\n\tif (!cache->hdr) {\n\t\tr_dyldcache_free (cache);\n\t\treturn false;\n\t}\n\tpopulate_cache_maps (cache);\n\tif (!cache->maps) {\n\t\tr_dyldcache_free (cache);\n\t\treturn false;\n\t}\n\tcache->accel = read_cache_accel (cache->buf, cache->hdr, cache->maps, cache->n_maps);\n\tcache->bins = create_cache_bins (bf, cache);\n\tif (!cache->bins) {\n\t\tr_dyldcache_free (cache);\n\t\treturn false;\n\t}\n\tcache->locsym = r_dyld_locsym_new (cache);\n\tcache->rebase_infos = get_rebase_infos (bf, cache);\n\tif (cache->rebase_infos) {\n\t\tif (!rebase_infos_get_slide (cache)) {\n\t\t\tif (!pending_bin_files) {\n\t\t\t\tpending_bin_files = r_list_new ();\n\t\t\t\tif (!pending_bin_files) {\n\t\t\t\t\tr_dyldcache_free (cache);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_list_push (pending_bin_files, bf);\n\t\t\tswizzle_io_read (cache, bf->rbin->iob.io);\n\t\t}\n\t}\n\t*bin_obj = cache;\n\treturn true;\n}\n\nstatic RList *entries(RBinFile *bf) {\n\tRBinAddr *ptr = NULL;\n\tRList *ret = r_list_newf (free);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tif ((ptr = R_NEW0 (RBinAddr))) {\n\t\tr_list_append (ret, ptr);\n\t}\n\treturn ret;\n}\n\nstatic RBinInfo *info(RBinFile *bf) {\n\tRBinInfo *ret = NULL;\n\n\tif (!bf || !bf->o) {\n\t\treturn NULL;\n\t}\n\n\tRDyldCache *cache = (RDyldCache*) bf->o->bin_obj;\n\tif (!cache) {\n\t\treturn NULL;\n\t}\n\n\tbool big_endian = 0;\n\tif (!(ret = R_NEW0 (RBinInfo))) {\n\t\treturn NULL;\n\t}\n\tret->file = strdup (bf->file);\n\tret->bclass = strdup (\"dyldcache\");\n\tret->rclass = strdup (\"ios\");\n\tret->os = strdup (\"iOS\");\n\tif (strstr (cache->hdr->magic, \"x86_64\")) {\n\t\tret->arch = strdup (\"x86\");\n\t\tret->bits = 64;\n\t} else {\n\t\tret->arch = strdup (\"arm\");\n\t\tret->bits = strstr (cache->hdr->magic, \"arm64\")? 64: 32;\n\t}\n\tret->machine = strdup (ret->arch);\n\tret->subsystem = strdup (\"xnu\");\n\tret->type = strdup (\"library-cache\");\n\tret->has_va = true;\n\tret->big_endian = big_endian;\n\tret->dbg_info = 0;\n\treturn ret;\n}\n\n#if 0\nstatic void parse_mach0(RList *ret, ut64 paddr, RBinFile *bf) {\n\t// TODO\n}\n#endif\n\nstatic ut64 baddr(RBinFile *bf) {\n\t// XXX hardcoded\n\treturn 0x180000000;\n}\n\nvoid symbols_from_bin(RDyldCache *cache, RList *ret, RBinFile *bf, RDyldBinImage *bin, SetU *hash) {\n\tstruct MACH0_(obj_t) *mach0 = bin_to_mach0 (bf, bin);\n\tif (!mach0) {\n\t\treturn;\n\t}\n\n\t// const RList*symbols = MACH0_(get_symbols_list) (mach0);\n\tconst struct symbol_t *symbols = MACH0_(get_symbols) (mach0);\n\tif (!symbols) {\n\t\treturn;\n\t}\n\tint i;\n\tfor (i = 0; !symbols[i].last; i++) {\n\t\tif (!symbols[i].name || !symbols[i].name[0] || symbols[i].addr < 100) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strstr (symbols[i].name, \"<redacted>\")) {\n\t\t\tcontinue;\n\t\t}\n\t\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\t\tif (!sym) {\n\t\t\tbreak;\n\t\t}\n\t\tsym->name = strdup (symbols[i].name);\n\t\tsym->vaddr = symbols[i].addr;\n\t\tsym->forwarder = \"NONE\";\n\t\tsym->bind = (symbols[i].type == R_BIN_MACH0_SYMBOL_TYPE_LOCAL)? R_BIN_BIND_LOCAL_STR: R_BIN_BIND_GLOBAL_STR;\n\t\tsym->type = R_BIN_TYPE_FUNC_STR;\n\t\tsym->paddr = symbols[i].offset + bf->o->boffset;\n\t\tsym->size = symbols[i].size;\n\t\tsym->ordinal = i;\n\n\t\tset_u_add (hash, sym->vaddr);\n\t\tr_list_append (ret, sym);\n\t}\n\tMACH0_(mach0_free) (mach0);\n}\n\nstatic bool __is_data_section(const char *name) {\n\tif (strstr (name, \"_cstring\")) {\n\t\treturn true;\n\t}\n\tif (strstr (name, \"_os_log\")) {\n\t\treturn true;\n\t}\n\tif (strstr (name, \"_objc_methname\")) {\n\t\treturn true;\n\t}\n\tif (strstr (name, \"_objc_classname\")) {\n\t\treturn true;\n\t}\n\tif (strstr (name, \"_objc_methtype\")) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic void sections_from_bin(RList *ret, RBinFile *bf, RDyldBinImage *bin) {\n\tRDyldCache *cache = (RDyldCache*) bf->o->bin_obj;\n\tif (!cache) {\n\t\treturn;\n\t}\n\n\tstruct MACH0_(obj_t) *mach0 = bin_to_mach0 (bf, bin);\n\tif (!mach0) {\n\t\treturn;\n\t}\n\n\tstruct section_t *sections = NULL;\n\tif (!(sections = MACH0_(get_sections) (mach0))) {\n\t\treturn;\n\t}\n\n\tut64 slide = rebase_infos_get_slide (cache);\n\tint i;\n\tfor (i = 0; !sections[i].last; i++) {\n\t\tRBinSection *ptr = R_NEW0 (RBinSection);\n\t\tif (!ptr) {\n\t\t\tbreak;\n\t\t}\n\t\tif (bin->file) {\n\t\t\tptr->name = r_str_newf (\"%s.%s\", bin->file, (char*)sections[i].name);\n\t\t} else {\n\t\t\tptr->name = r_str_newf (\"%s\", (char*)sections[i].name);\n\t\t}\n\t\tif (strstr (ptr->name, \"la_symbol_ptr\")) {\n\t\t\tint len = sections[i].size / 8;\n\t\t\tptr->format = r_str_newf (\"Cd %d[%d]\", 8, len);\n\t\t}\n\t\tptr->is_data = __is_data_section (ptr->name);\n\t\tptr->size = sections[i].size;\n\t\tptr->vsize = sections[i].vsize;\n\t\tptr->vaddr = sections[i].addr;\n\t\tptr->paddr = va2pa (sections[i].addr, cache->n_maps, cache->maps, cache->buf, slide, NULL, NULL);\n\t\tif (!ptr->vaddr) {\n\t\t\tptr->vaddr = ptr->paddr;\n\t\t}\n\t\tptr->perm = sections[i].perm;\n\t\tr_list_append (ret, ptr);\n\t}\n\tfree (sections);\n\tMACH0_(mach0_free) (mach0);\n}\n\nstatic RList *sections(RBinFile *bf) {\n\tRDyldCache *cache = (RDyldCache*) bf->o->bin_obj;\n\tif (!cache) {\n\t\treturn NULL;\n\t}\n\n\tRList *ret = r_list_newf (free);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\n\tRListIter *iter;\n\tRDyldBinImage *bin;\n\tr_list_foreach (cache->bins, iter, bin) {\n\t\tsections_from_bin (ret, bf, bin);\n\t}\n\n\tRBinSection *ptr = NULL;\n\tint i;\n\tfor (i = 0; i < cache->n_maps; i++) {\n\t\tif (!(ptr = R_NEW0 (RBinSection))) {\n\t\t\tr_list_free (ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tptr->name = r_str_newf (\"cache_map.%d\", i);\n\t\tptr->size = cache->maps[i].size;\n\t\tptr->vsize = ptr->size;\n\t\tptr->paddr = cache->maps[i].fileOffset;\n\t\tptr->vaddr = cache->maps[i].address;\n\t\tptr->add = true;\n\t\tptr->is_segment = true;\n\t\tptr->perm = prot2perm (cache->maps[i].initProt);\n\t\tr_list_append (ret, ptr);\n\t}\n\n\tut64 slide = rebase_infos_get_slide (cache);\n\tif (slide) {\n\t\tRBinSection *section;\n\t\tr_list_foreach (ret, iter, section) {\n\t\t\tsection->vaddr += slide;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic RList *symbols(RBinFile *bf) {\n\tRDyldCache *cache = (RDyldCache*) bf->o->bin_obj;\n\tif (!cache) {\n\t\treturn NULL;\n\t}\n\n\tRList *ret = r_list_newf (free);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\n\tRListIter *iter;\n\tRDyldBinImage *bin;\n\tr_list_foreach (cache->bins, iter, bin) {\n\t\tSetU *hash = set_u_new ();\n\t\tif (!hash) {\n\t\t\tr_list_free (ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tsymbols_from_bin (cache, ret, bf, bin, hash);\n\t\tsymbols_from_locsym (cache, bin, ret, hash);\n\t\tset_u_free (hash);\n\t}\n\n\tut64 slide = rebase_infos_get_slide (cache);\n\tif (slide) {\n\t\tRBinSymbol *sym;\n\t\tr_list_foreach (ret, iter, sym) {\n\t\t\tsym->vaddr += slide;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n/* static void unswizzle_io_read(RDyldCache *cache, RIO *io) {\n\tif (!io || !io->desc || !io->desc->plugin || !cache->original_io_read) {\n\t\treturn;\n\t}\n\n\tRIOPlugin *plugin = io->desc->plugin;\n\tplugin->read = cache->original_io_read;\n\tcache->original_io_read = NULL;\n} */\n\nstatic void destroy(RBinFile *bf) {\n\tRDyldCache *cache = (RDyldCache*) bf->o->bin_obj;\n\t// unswizzle_io_read (cache, bf->rbin->iob.io); // XXX io may be dead here\n\tr_dyldcache_free (cache);\n}\n\nstatic RList *classes(RBinFile *bf) {\n\tRDyldCache *cache = (RDyldCache*) bf->o->bin_obj;\n\tif (!cache) {\n\t\treturn NULL;\n\t}\n\n\tRList *ret = r_list_newf (free);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\n\tif (!cache->objc_opt_info_loaded) {\n\t\tcache->oi = get_objc_opt_info (bf, cache);\n\t\tcache->objc_opt_info_loaded = true;\n\t}\n\n\tRListIter *iter;\n\tRDyldBinImage *bin;\n\tut64 slide = rebase_infos_get_slide (cache);\n\n\tRBuffer *orig_buf = bf->buf;\n\tut32 num_of_unnamed_class = 0;\n\tr_list_foreach (cache->bins, iter, bin) {\n\t\tstruct MACH0_(obj_t) *mach0 = bin_to_mach0 (bf, bin);\n\t\tif (!mach0) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tstruct section_t *sections = NULL;\n\t\tif (!(sections = MACH0_(get_sections) (mach0))) {\n\t\t\tMACH0_(mach0_free) (mach0);\n\t\t\tgoto beach;\n\t\t}\n\n\t\tint i;\n\t\tfor (i = 0; !sections[i].last; i++) {\n\t\t\tif (sections[i].size == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tbool is_classlist = strstr (sections[i].name, \"__objc_classlist\");\n\t\t\tbool is_catlist = strstr (sections[i].name, \"__objc_catlist\");\n\n\t\t\tif (!is_classlist && !is_catlist) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tut8 *pointers = malloc (sections[i].size);\n\t\t\tif (!pointers) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tut64 offset = va2pa (sections[i].addr, cache->n_maps, cache->maps, cache->buf, slide, NULL, NULL);\n\t\t\tif (r_buf_read_at (cache->buf, offset, pointers, sections[i].size) < sections[i].size) {\n\t\t\t\tR_FREE (pointers);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tut8 *cursor = pointers;\n\t\t\tut8 *pointers_end = pointers + sections[i].size;\n\n\t\t\tfor (; cursor < pointers_end; cursor += 8) {\n\t\t\t\tut64 pointer_to_class = r_read_le64 (cursor);\n\n\t\t\t\tRBinClass *klass;\n\t\t\t\tif (!(klass = R_NEW0 (RBinClass)) ||\n\t\t\t\t\t!(klass->methods = r_list_new ()) ||\n\t\t\t\t\t!(klass->fields = r_list_new ())) {\n\t\t\t\t\tR_FREE (klass);\n\t\t\t\t\tR_FREE (pointers);\n\t\t\t\t\tR_FREE (sections);\n\t\t\t\t\tMACH0_(mach0_free) (mach0);\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\n\t\t\t\tbf->o->bin_obj = mach0;\n\t\t\t\tbf->buf = cache->buf;\n\t\t\t\tif (is_classlist) {\n\t\t\t\t\tMACH0_(get_class_t) (pointer_to_class, bf, klass, false, NULL, cache->oi);\n\t\t\t\t} else {\n\t\t\t\t\tMACH0_(get_category_t) (pointer_to_class, bf, klass, NULL, cache->oi);\n\t\t\t\t}\n\t\t\t\tbf->o->bin_obj = cache;\n\t\t\t\tbf->buf = orig_buf;\n\n\t\t\t\tif (!klass->name) {\n\t\t\t\t\teprintf (\"KLASS ERROR AT 0x%\"PFMT64x\", is_classlist %d\\n\", pointer_to_class, is_classlist);\n\t\t\t\t\tklass->name = r_str_newf (\"UnnamedClass%u\", num_of_unnamed_class);\n\t\t\t\t\tif (!klass->name) {\n\t\t\t\t\t\tR_FREE (klass);\n\t\t\t\t\t\tR_FREE (pointers);\n\t\t\t\t\t\tR_FREE (sections);\n\t\t\t\t\t\tMACH0_(mach0_free) (mach0);\n\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t}\n\t\t\t\t\tnum_of_unnamed_class++;\n\t\t\t\t}\n\t\t\t\tr_list_append (ret, klass);\n\t\t\t}\n\n\t\t\tR_FREE (pointers);\n\t\t}\n\n\t\tR_FREE (sections);\n\t\tMACH0_(mach0_free) (mach0);\n\t}\n\n\treturn ret;\n\nbeach:\n\tr_list_free (ret);\n\treturn NULL;\n}\n\nstatic void header(RBinFile *bf) {\n\tif (!bf || !bf->o) {\n\t\treturn;\n\t}\n\n\tRDyldCache *cache = (RDyldCache*) bf->o->bin_obj;\n\tif (!cache) {\n\t\treturn;\n\t}\n\n\tRBin *bin = bf->rbin;\n\tut64 slide = rebase_infos_get_slide (cache);\n\tPrintfCallback p = bin->cb_printf;\n\n\tPJ *pj = pj_new ();\n\tif (!pj) {\n\t\treturn;\n\t}\n\n\tpj_o (pj);\n\tpj_k (pj, \"header\");\n\tpj_o (pj);\n\tpj_ks (pj, \"magic\", cache->hdr->magic);\n\tpj_kn (pj, \"mappingOffset\", cache->hdr->mappingOffset);\n\tpj_kn (pj, \"mappingCount\", cache->hdr->mappingCount);\n\tpj_kn (pj, \"imagesOffset\", cache->hdr->imagesOffset);\n\tpj_kn (pj, \"imagesCount\", cache->hdr->imagesCount);\n\tpj_kn (pj, \"dyldBaseAddress\", cache->hdr->dyldBaseAddress);\n\tpj_kn (pj, \"codeSignatureOffset\", cache->hdr->codeSignatureOffset);\n\tpj_kn (pj, \"codeSignatureSize\", cache->hdr->codeSignatureSize);\n\tpj_kn (pj, \"slideInfoOffset\", cache->hdr->slideInfoOffset);\n\tpj_kn (pj, \"slideInfoSize\", cache->hdr->slideInfoSize);\n\tpj_kn (pj, \"localSymbolsOffset\", cache->hdr->localSymbolsOffset);\n\tpj_kn (pj, \"localSymbolsSize\", cache->hdr->localSymbolsSize);\n\tchar uuidstr[128];\n\tr_hex_bin2str ((ut8*)cache->hdr->uuid, 16, uuidstr);\n\tpj_ks (pj, \"uuid\", uuidstr);\n\tpj_ks (pj, \"cacheType\", (cache->hdr->cacheType == 0) ? \"development\" : \"production\");\n\tpj_kn (pj, \"branchPoolsOffset\", cache->hdr->branchPoolsOffset);\n\tpj_kn (pj, \"branchPoolsCount\", cache->hdr->branchPoolsCount);\n\tpj_kn (pj, \"accelerateInfoAddr\", cache->hdr->accelerateInfoAddr + slide);\n\tpj_kn (pj, \"accelerateInfoSize\", cache->hdr->accelerateInfoSize);\n\tpj_kn (pj, \"imagesTextOffset\", cache->hdr->imagesTextOffset);\n\tpj_kn (pj, \"imagesTextCount\", cache->hdr->imagesTextCount);\n\tpj_end (pj);\n\n\tif (cache->accel) {\n\t\tpj_k (pj, \"accelerator\");\n\t\tpj_o (pj);\n\t\tpj_kn (pj, \"version\", cache->accel->version);\n\t\tpj_kn (pj, \"imageExtrasCount\", cache->accel->imageExtrasCount);\n\t\tpj_kn (pj, \"imagesExtrasOffset\", cache->accel->imagesExtrasOffset);\n\t\tpj_kn (pj, \"bottomUpListOffset\", cache->accel->bottomUpListOffset);\n\t\tpj_kn (pj, \"dylibTrieOffset\", cache->accel->dylibTrieOffset);\n\t\tpj_kn (pj, \"dylibTrieSize\", cache->accel->dylibTrieSize);\n\t\tpj_kn (pj, \"initializersOffset\", cache->accel->initializersOffset);\n\t\tpj_kn (pj, \"initializersCount\", cache->accel->initializersCount);\n\t\tpj_kn (pj, \"dofSectionsOffset\", cache->accel->dofSectionsOffset);\n\t\tpj_kn (pj, \"dofSectionsCount\", cache->accel->dofSectionsCount);\n\t\tpj_kn (pj, \"reExportListOffset\", cache->accel->reExportListOffset);\n\t\tpj_kn (pj, \"reExportCount\", cache->accel->reExportCount);\n\t\tpj_kn (pj, \"depListOffset\", cache->accel->depListOffset);\n\t\tpj_kn (pj, \"depListCount\", cache->accel->depListCount);\n\t\tpj_kn (pj, \"rangeTableOffset\", cache->accel->rangeTableOffset);\n\t\tpj_kn (pj, \"rangeTableCount\", cache->accel->rangeTableCount);\n\t\tpj_kn (pj, \"dyldSectionAddr\", cache->accel->dyldSectionAddr + slide);\n\t\tpj_end (pj);\n\t}\n\n\tif (cache->rebase_infos) {\n\t\tsize_t i;\n\t\tpj_k (pj, \"slideInfo\");\n\t\tpj_a (pj);\n\t\tfor (i = 0; i < cache->rebase_infos->length; i++) {\n\t\t\tRDyldRebaseInfo * rebase_info = cache->rebase_infos->entries[i].info;\n\t\t\tpj_o (pj);\n\t\t\tpj_kn (pj, \"start\", cache->rebase_infos->entries[i].start);\n\t\t\tpj_kn (pj, \"end\", cache->rebase_infos->entries[i].end);\n\t\t\tif (rebase_info) {\n\t\t\t\tut8 version = rebase_info->version;\n\t\t\t\tpj_kn (pj, \"version\", version);\n\t\t\t\tpj_kn (pj, \"slide\", slide);\n\t\t\t\tif (version == 3) {\n\t\t\t\t\tRDyldRebaseInfo3 *info3 = (RDyldRebaseInfo3*) rebase_info;\n\t\t\t\t\tpj_kn (pj, \"page_starts_count\", info3->page_starts_count);\n\t\t\t\t\tpj_kn (pj, \"page_size\", info3->page_size);\n\t\t\t\t\tpj_kn (pj, \"auth_value_add\", info3->auth_value_add);\n\t\t\t\t} else if (version == 2 || version == 4) {\n\t\t\t\t\tRDyldRebaseInfo2 *info2 = (RDyldRebaseInfo2*) rebase_info;\n\t\t\t\t\tpj_kn (pj, \"page_starts_count\", info2->page_starts_count);\n\t\t\t\t\tpj_kn (pj, \"page_extras_count\", info2->page_extras_count);\n\t\t\t\t\tpj_kn (pj, \"delta_mask\", info2->delta_mask);\n\t\t\t\t\tpj_kn (pj, \"value_mask\", info2->value_mask);\n\t\t\t\t\tpj_kn (pj, \"value_add\", info2->value_add);\n\t\t\t\t\tpj_kn (pj, \"delta_shift\", info2->delta_shift);\n\t\t\t\t\tpj_kn (pj, \"page_size\", info2->page_size);\n\t\t\t\t} else if (version == 1) {\n\t\t\t\t\tRDyldRebaseInfo1 *info1 = (RDyldRebaseInfo1*) rebase_info;\n\t\t\t\t\tpj_kn (pj, \"toc_count\", info1->toc_count);\n\t\t\t\t\tpj_kn (pj, \"entries_size\", info1->entries_size);\n\t\t\t\t\tpj_kn (pj, \"page_size\", 4096);\n\t\t\t\t}\n\t\t\t}\n\t\t\tpj_end (pj);\n\t\t}\n\t\tpj_end (pj);\n\t}\n\n\tif (cache->hdr->imagesTextCount) {\n\t\tpj_k (pj, \"images\");\n\t\tpj_a (pj);\n\t\tut64 total_size = cache->hdr->imagesTextCount * sizeof (cache_text_info_t);\n\t\tcache_text_info_t * text_infos = malloc (total_size);\n\t\tif (!text_infos) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (r_buf_fread_at (cache->buf, cache->hdr->imagesTextOffset, (ut8*)text_infos, \"16clii\", cache->hdr->imagesTextCount) != total_size) {\n\t\t\tfree (text_infos);\n\t\t\tgoto beach;\n\t\t}\n\t\tsize_t i;\n\t\tfor (i = 0; i != cache->hdr->imagesTextCount; i++) {\n\t\t\tcache_text_info_t * text_info = &text_infos[i];\n\t\t\tr_hex_bin2str ((ut8*)text_info->uuid, 16, uuidstr);\n\t\t\tpj_o (pj);\n\t\t\tpj_ks (pj, \"uuid\", uuidstr);\n\t\t\tpj_kn (pj, \"address\", text_info->loadAddress + slide);\n\t\t\tpj_kn (pj, \"textSegmentSize\", text_info->textSegmentSize);\n\t\t\tchar file[256];\n\t\t\tif (r_buf_read_at (cache->buf, text_info->pathOffset, (ut8*) &file, sizeof (file)) == sizeof (file)) {\n\t\t\t\tfile[255] = 0;\n\t\t\t\tpj_ks (pj, \"path\", file);\n\t\t\t\tchar *last_slash = strrchr (file, '/');\n\t\t\t\tif (last_slash && *last_slash) {\n\t\t\t\t\tpj_ks (pj, \"name\", last_slash + 1);\n\t\t\t\t} else {\n\t\t\t\t\tpj_ks (pj, \"name\", file);\n\t\t\t\t}\n\t\t\t}\n\t\t\tpj_end (pj);\n\t\t}\n\t\tpj_end (pj);\n\t\tfree (text_infos);\n\t}\n\n\tpj_end (pj);\n\tp (\"%s\", pj_string (pj));\n\nbeach:\n\tpj_free (pj);\n}\n\nRBinPlugin r_bin_plugin_dyldcache = {\n\t.name = \"dyldcache\",\n\t.desc = \"dyldcache bin plugin\",\n\t.license = \"LGPL3\",\n\t.load_buffer = &load_buffer,\n\t.entries = &entries,\n\t.baddr = &baddr,\n\t.symbols = &symbols,\n\t.sections = &sections,\n\t.check_buffer = &check_buffer,\n\t.destroy = &destroy,\n\t.classes = &classes,\n\t.header = &header,\n\t.info = &info,\n};\n\n#ifndef R2_PLUGIN_INCORE\nR_API RLibStruct radare_plugin = {\n\t.type = R_LIB_TYPE_BIN,\n\t.data = &r_bin_plugin_dyldcache,\n\t.version = R2_VERSION\n};\n#endif\n"], "filenames": ["libr/bin/format/mach0/dyldcache.h", "libr/bin/p/bin_dyldcache.c"], "buggy_code_start_loc": [1, 1250], "buggy_code_end_loc": [2, 1251], "fixing_code_start_loc": [1, 1250], "fixing_code_end_loc": [2, 1252], "type": "CWE-122", "message": "heap-buffer-overflow in GitHub repository radareorg/radare2 prior to 5.6.8. This vulnerability is capable of inducing denial of service.", "other": {"cve": {"id": "CVE-2022-1244", "sourceIdentifier": "security@huntr.dev", "published": "2022-04-05T19:15:07.907", "lastModified": "2022-04-15T18:28:21.277", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "heap-buffer-overflow in GitHub repository radareorg/radare2 prior to 5.6.8. This vulnerability is capable of inducing denial of service."}, {"lang": "es", "value": "Un desbordamiento del buffer de la pila en el repositorio GitHub radareorg/radare2 versiones anteriores a 5.6.8. Esta vulnerabilidad es capaz de inducir una denegaci\u00f3n de servicio"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-122"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.6.8", "matchCriteriaId": "8956009B-4EDA-4AA6-997D-B2C8C5D05CEC"}]}]}], "references": [{"url": "https://github.com/radareorg/radare2/commit/2b77b277d67ce061ee6ef839e7139ebc2103c1e3", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/8ae2c61a-2220-47a5-bfe8-fe6d41ab1f82", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/radareorg/radare2/commit/2b77b277d67ce061ee6ef839e7139ebc2103c1e3"}}