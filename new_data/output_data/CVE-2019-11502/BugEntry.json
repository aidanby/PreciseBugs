{"buggy_code": ["/*\n * Copyright (C) 2015 Canonical Ltd\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 3 as\n * published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"mount-support.h\"\n\n#include <errno.h>\n#include <fcntl.h>\n#include <libgen.h>\n#include <limits.h>\n#include <mntent.h>\n#include <sched.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/syscall.h>\n#include <sys/types.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\n#include \"../libsnap-confine-private/apparmor-support.h\"\n#include \"../libsnap-confine-private/classic.h\"\n#include \"../libsnap-confine-private/cleanup-funcs.h\"\n#include \"../libsnap-confine-private/mount-opt.h\"\n#include \"../libsnap-confine-private/mountinfo.h\"\n#include \"../libsnap-confine-private/snap.h\"\n#include \"../libsnap-confine-private/string-utils.h\"\n#include \"../libsnap-confine-private/tool.h\"\n#include \"../libsnap-confine-private/utils.h\"\n#include \"mount-support-nvidia.h\"\n\n#define MAX_BUF 1000\n\n/*!\n * The void directory.\n *\n * Snap confine moves to that directory in case it cannot retain the current\n * working directory across the pivot_root call.\n **/\n#define SC_VOID_DIR \"/var/lib/snapd/void\"\n\n// TODO: simplify this, after all it is just a tmpfs\n// TODO: fold this into bootstrap\nstatic void setup_private_mount(const char *snap_name)\n{\n\tuid_t uid = getuid();\n\tgid_t gid = getgid();\n\tchar tmpdir[MAX_BUF] = { 0 };\n\n\t// Create a 0700 base directory, this is the base dir that is\n\t// protected from other users.\n\t//\n\t// Under that basedir, we put a 1777 /tmp dir that is then bind\n\t// mounted for the applications to use\n\tsc_must_snprintf(tmpdir, sizeof(tmpdir), \"/tmp/snap.%s_XXXXXX\", snap_name);\n\tif (mkdtemp(tmpdir) == NULL) {\n\t\tdie(\"cannot create temporary directory essential for private /tmp\");\n\t}\n\t// now we create a 1777 /tmp inside our private dir\n\tmode_t old_mask = umask(0);\n\tchar *d = sc_strdup(tmpdir);\n\tsc_must_snprintf(tmpdir, sizeof(tmpdir), \"%s/tmp\", d);\n\tfree(d);\n\n\tif (mkdir(tmpdir, 01777) != 0) {\n\t\tdie(\"cannot create temporary directory for private /tmp\");\n\t}\n\tumask(old_mask);\n\n\t// chdir to '/' since the mount won't apply to the current directory\n\tchar *pwd = get_current_dir_name();\n\tif (pwd == NULL)\n\t\tdie(\"cannot get current working directory\");\n\tif (chdir(\"/\") != 0)\n\t\tdie(\"cannot change directory to '/'\");\n\n\t// MS_BIND is there from linux 2.4\n\tsc_do_mount(tmpdir, \"/tmp\", NULL, MS_BIND, NULL);\n\t// MS_PRIVATE needs linux > 2.6.11\n\tsc_do_mount(\"none\", \"/tmp\", NULL, MS_PRIVATE, NULL);\n\t// do the chown after the bind mount to avoid potential shenanigans\n\tif (chown(\"/tmp/\", uid, gid) < 0) {\n\t\tdie(\"cannot change ownership of /tmp\");\n\t}\n\t// chdir to original directory\n\tif (chdir(pwd) != 0)\n\t\tdie(\"cannot change current working directory to the original directory\");\n\tfree(pwd);\n}\n\n// TODO: fold this into bootstrap\nstatic void setup_private_pts(void)\n{\n\t// See https://www.kernel.org/doc/Documentation/filesystems/devpts.txt\n\t//\n\t// Ubuntu by default uses devpts 'single-instance' mode where\n\t// /dev/pts/ptmx is mounted with ptmxmode=0000. We don't want to change\n\t// the startup scripts though, so we follow the instructions in point\n\t// '4' of 'User-space changes' in the above doc. In other words, after\n\t// unshare(CLONE_NEWNS), we mount devpts with -o\n\t// newinstance,ptmxmode=0666 and then bind mount /dev/pts/ptmx onto\n\t// /dev/ptmx\n\n\tstruct stat st;\n\n\t// Make sure /dev/pts/ptmx exists, otherwise we are in legacy mode\n\t// which doesn't provide the isolation we require.\n\tif (stat(\"/dev/pts/ptmx\", &st) != 0) {\n\t\tdie(\"cannot stat /dev/pts/ptmx\");\n\t}\n\t// Make sure /dev/ptmx exists so we can bind mount over it\n\tif (stat(\"/dev/ptmx\", &st) != 0) {\n\t\tdie(\"cannot stat /dev/ptmx\");\n\t}\n\t// Since multi-instance, use ptmxmode=0666. The other options are\n\t// copied from /etc/default/devpts\n\tsc_do_mount(\"devpts\", \"/dev/pts\", \"devpts\", MS_MGC_VAL,\n\t\t    \"newinstance,ptmxmode=0666,mode=0620,gid=5\");\n\tsc_do_mount(\"/dev/pts/ptmx\", \"/dev/ptmx\", \"none\", MS_BIND, 0);\n}\n\nstruct sc_mount {\n\tconst char *path;\n\tbool is_bidirectional;\n\t// Alternate path defines the rbind mount \"alternative\" of path.\n\t// It exists so that we can make /media on systems that use /run/media.\n\tconst char *altpath;\n\t// Optional mount points are not processed unless the source and\n\t// destination both exist.\n\tbool is_optional;\n};\n\nstruct sc_mount_config {\n\tconst char *rootfs_dir;\n\t// The struct is terminated with an entry with NULL path.\n\tconst struct sc_mount *mounts;\n\tsc_distro distro;\n\tbool normal_mode;\n\tconst char *base_snap_name;\n};\n\n/**\n * Bootstrap mount namespace.\n *\n * This is a chunk of tricky code that lets us have full control over the\n * layout and direction of propagation of mount events. The documentation below\n * assumes knowledge of the 'sharedsubtree.txt' document from the kernel source\n * tree.\n *\n * As a reminder two definitions are quoted below:\n *\n *  A 'propagation event' is defined as event generated on a vfsmount\n *  that leads to mount or unmount actions in other vfsmounts.\n *\n *  A 'peer group' is defined as a group of vfsmounts that propagate\n *  events to each other.\n *\n * (end of quote).\n *\n * The main idea is to setup a mount namespace that has a root filesystem with\n * vfsmounts and peer groups that, depending on the location, either isolate\n * or share with the rest of the system.\n *\n * The vast majority of the filesystem is shared in one direction. Events from\n * the outside (from the main mount namespace) propagate inside (to namespaces\n * of particular snaps) so things like new snap revisions, mounted drives, etc,\n * just show up as expected but even if a snap is exploited or malicious in\n * nature it cannot affect anything in another namespace where it might cause\n * security or stability issues.\n *\n * Selected directories (today just /media) can be shared in both directions.\n * This allows snaps with sufficient privileges to either create, through the\n * mount system call, additional mount points that are visible by the rest of\n * the system (both the main mount namespace and namespaces of individual\n * snaps) or remove them, through the unmount system call.\n **/\nstatic void sc_bootstrap_mount_namespace(const struct sc_mount_config *config)\n{\n\tchar scratch_dir[] = \"/tmp/snap.rootfs_XXXXXX\";\n\tchar src[PATH_MAX] = { 0 };\n\tchar dst[PATH_MAX] = { 0 };\n\tif (mkdtemp(scratch_dir) == NULL) {\n\t\tdie(\"cannot create temporary directory for the root file system\");\n\t}\n\t// NOTE: at this stage we just called unshare(CLONE_NEWNS). We are in a new\n\t// mount namespace and have a private list of mounts.\n\tdebug(\"scratch directory for constructing namespace: %s\", scratch_dir);\n\t// Make the root filesystem recursively shared. This way propagation events\n\t// will be shared with main mount namespace.\n\tsc_do_mount(\"none\", \"/\", NULL, MS_REC | MS_SHARED, NULL);\n\t// Bind mount the temporary scratch directory for root filesystem over\n\t// itself so that it is a mount point. This is done so that it can become\n\t// unbindable as explained below.\n\tsc_do_mount(scratch_dir, scratch_dir, NULL, MS_BIND, NULL);\n\t// Make the scratch directory unbindable.\n\t//\n\t// This is necessary as otherwise a mount loop can occur and the kernel\n\t// would crash. The term unbindable simply states that it cannot be bind\n\t// mounted anywhere. When we construct recursive bind mounts below this\n\t// guarantees that this directory will not be replicated anywhere.\n\tsc_do_mount(\"none\", scratch_dir, NULL, MS_UNBINDABLE, NULL);\n\t// Recursively bind mount desired root filesystem directory over the\n\t// scratch directory. This puts the initial content into the scratch space\n\t// and serves as a foundation for all subsequent operations below.\n\t//\n\t// The mount is recursive because it can either be applied to the root\n\t// filesystem of a core system (aka all-snap) or the core snap on a classic\n\t// system. In the former case we need recursive bind mounts to accurately\n\t// replicate the state of the root filesystem into the scratch directory.\n\tsc_do_mount(config->rootfs_dir, scratch_dir, NULL, MS_REC | MS_BIND,\n\t\t    NULL);\n\t// Make the scratch directory recursively private. Nothing done there will\n\t// be shared with any peer group, This effectively detaches us from the\n\t// original namespace and coupled with pivot_root below serves as the\n\t// foundation of the mount sandbox.\n\tsc_do_mount(\"none\", scratch_dir, NULL, MS_REC | MS_SLAVE, NULL);\n\t// Bind mount certain directories from the host filesystem to the scratch\n\t// directory. By default mount events will propagate in both into and out\n\t// of the peer group. This way the running application can alter any global\n\t// state visible on the host and in other snaps. This can be restricted by\n\t// disabling the \"is_bidirectional\" flag as can be seen below.\n\tfor (const struct sc_mount * mnt = config->mounts; mnt->path != NULL;\n\t     mnt++) {\n\t\tif (mnt->is_bidirectional && mkdir(mnt->path, 0755) < 0 &&\n\t\t    errno != EEXIST) {\n\t\t\tdie(\"cannot create %s\", mnt->path);\n\t\t}\n\t\tsc_must_snprintf(dst, sizeof dst, \"%s/%s\", scratch_dir,\n\t\t\t\t mnt->path);\n\t\tif (mnt->is_optional) {\n\t\t\tbool ok = sc_do_optional_mount(mnt->path, dst, NULL,\n\t\t\t\t\t\t       MS_REC | MS_BIND, NULL);\n\t\t\tif (!ok) {\n\t\t\t\t// If we cannot mount it, just continue.\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tsc_do_mount(mnt->path, dst, NULL, MS_REC | MS_BIND,\n\t\t\t\t    NULL);\n\t\t}\n\t\tif (!mnt->is_bidirectional) {\n\t\t\t// Mount events will only propagate inwards to the namespace. This\n\t\t\t// way the running application cannot alter any global state apart\n\t\t\t// from that of its own snap.\n\t\t\tsc_do_mount(\"none\", dst, NULL, MS_REC | MS_SLAVE, NULL);\n\t\t}\n\t\tif (mnt->altpath == NULL) {\n\t\t\tcontinue;\n\t\t}\n\t\t// An alternate path of mnt->path is provided at another location.\n\t\t// It should behave exactly the same as the original.\n\t\tsc_must_snprintf(dst, sizeof dst, \"%s/%s\", scratch_dir,\n\t\t\t\t mnt->altpath);\n\t\tstruct stat stat_buf;\n\t\tif (lstat(dst, &stat_buf) < 0) {\n\t\t\tdie(\"cannot lstat %s\", dst);\n\t\t}\n\t\tif ((stat_buf.st_mode & S_IFMT) == S_IFLNK) {\n\t\t\tdie(\"cannot bind mount alternate path over a symlink: %s\", dst);\n\t\t}\n\t\tsc_do_mount(mnt->path, dst, NULL, MS_REC | MS_BIND, NULL);\n\t\tif (!mnt->is_bidirectional) {\n\t\t\tsc_do_mount(\"none\", dst, NULL, MS_REC | MS_SLAVE, NULL);\n\t\t}\n\t}\n\tif (config->normal_mode) {\n\t\t// Since we mounted /etc from the host filesystem to the scratch directory,\n\t\t// we may need to put certain directories from the desired root filesystem\n\t\t// (e.g. the core snap) back. This way the behavior of running snaps is not\n\t\t// affected by the alternatives directory from the host, if one exists.\n\t\t//\n\t\t// Fixes the following bugs:\n\t\t//  - https://bugs.launchpad.net/snap-confine/+bug/1580018\n\t\t//  - https://bugzilla.opensuse.org/show_bug.cgi?id=1028568\n\t\tconst char *dirs_from_core[] =\n\t\t    { \"/etc/alternatives\", \"/etc/ssl\", \"/etc/nsswitch.conf\",\n\t\t\tNULL\n\t\t};\n\t\tfor (const char **dirs = dirs_from_core; *dirs != NULL; dirs++) {\n\t\t\tconst char *dir = *dirs;\n\t\t\tstruct stat buf;\n\t\t\tif (access(dir, F_OK) == 0) {\n\t\t\t\tsc_must_snprintf(src, sizeof src, \"%s%s\",\n\t\t\t\t\t\t config->rootfs_dir, dir);\n\t\t\t\tsc_must_snprintf(dst, sizeof dst, \"%s%s\",\n\t\t\t\t\t\t scratch_dir, dir);\n\t\t\t\tif (lstat(src, &buf) == 0\n\t\t\t\t    && lstat(dst, &buf) == 0) {\n\t\t\t\t\tsc_do_mount(src, dst, NULL, MS_BIND,\n\t\t\t\t\t\t    NULL);\n\t\t\t\t\tsc_do_mount(\"none\", dst, NULL, MS_SLAVE,\n\t\t\t\t\t\t    NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// The \"core\" base snap is special as it contains snapd and friends.\n\t// Other base snaps do not, so whenever a base snap other than core is\n\t// in use we need extra provisions for setting up internal tooling to\n\t// be available.\n\t//\n\t// However on a core18 (and similar) system the core snap is not\n\t// a special base anymore and we should map our own tooling in.\n\tif (config->distro == SC_DISTRO_CORE_OTHER\n\t    || !sc_streq(config->base_snap_name, \"core\")) {\n\t\t// when bases are used we need to bind-mount the libexecdir\n\t\t// (that contains snap-exec) into /usr/lib/snapd of the\n\t\t// base snap so that snap-exec is available for the snaps\n\t\t// (base snaps do not ship snapd)\n\n\t\t// dst is always /usr/lib/snapd as this is where snapd\n\t\t// assumes to find snap-exec\n\t\tsc_must_snprintf(dst, sizeof dst, \"%s/usr/lib/snapd\",\n\t\t\t\t scratch_dir);\n\n\t\t// bind mount the current $ROOT/usr/lib/snapd path,\n\t\t// where $ROOT is either \"/\" or the \"/snap/{core,snapd}/current\"\n\t\t// that we are re-execing from\n\t\tchar *src = NULL;\n\t\tchar self[PATH_MAX + 1] = { 0 };\n\t\tif (readlink(\"/proc/self/exe\", self, sizeof(self) - 1) < 0) {\n\t\t\tdie(\"cannot read /proc/self/exe\");\n\t\t}\n\t\t// this cannot happen except when the kernel is buggy\n\t\tif (strstr(self, \"/snap-confine\") == NULL) {\n\t\t\tdie(\"cannot use result from readlink: %s\", self);\n\t\t}\n\t\tsrc = dirname(self);\n\t\t// dirname(path) might return '.' depending on path.\n\t\t// /proc/self/exe should always point\n\t\t// to an absolute path, but let's guarantee that.\n\t\tif (src[0] != '/') {\n\t\t\tdie(\"cannot use the result of dirname(): %s\", src);\n\t\t}\n\n\t\tsc_do_mount(src, dst, NULL, MS_BIND | MS_RDONLY, NULL);\n\t\tsc_do_mount(\"none\", dst, NULL, MS_SLAVE, NULL);\n\t}\n\t// Bind mount the directory where all snaps are mounted. The location of\n\t// the this directory on the host filesystem may not match the location in\n\t// the desired root filesystem. In the \"core\" and \"ubuntu-core\" snaps the\n\t// directory is always /snap. On the host it is a build-time configuration\n\t// option stored in SNAP_MOUNT_DIR.\n\tsc_must_snprintf(dst, sizeof dst, \"%s/snap\", scratch_dir);\n\tsc_do_mount(SNAP_MOUNT_DIR, dst, NULL, MS_BIND | MS_REC | MS_SLAVE,\n\t\t    NULL);\n\tsc_do_mount(\"none\", dst, NULL, MS_REC | MS_SLAVE, NULL);\n\t// Create the hostfs directory if one is missing. This directory is a part\n\t// of packaging now so perhaps this code can be removed later.\n\tif (access(SC_HOSTFS_DIR, F_OK) != 0) {\n\t\tdebug(\"creating missing hostfs directory\");\n\t\tif (mkdir(SC_HOSTFS_DIR, 0755) != 0) {\n\t\t\tdie(\"cannot perform operation: mkdir %s\",\n\t\t\t    SC_HOSTFS_DIR);\n\t\t}\n\t}\n\t// Ensure that hostfs isgroup owned by root. We may have (now or earlier)\n\t// created the directory as the user who first ran a snap on a given\n\t// system and the group identity of that user is visilbe on disk.\n\t// This was LP:#1665004\n\tstruct stat sb;\n\tif (stat(SC_HOSTFS_DIR, &sb) < 0) {\n\t\tdie(\"cannot stat %s\", SC_HOSTFS_DIR);\n\t}\n\tif (sb.st_uid != 0 || sb.st_gid != 0) {\n\t\tif (chown(SC_HOSTFS_DIR, 0, 0) < 0) {\n\t\t\tdie(\"cannot change user/group owner of %s to root\",\n\t\t\t    SC_HOSTFS_DIR);\n\t\t}\n\t}\n\t// Make the upcoming \"put_old\" directory for pivot_root private so that\n\t// mount events don't propagate to any peer group. In practice pivot root\n\t// has a number of undocumented requirements and one of them is that the\n\t// \"put_old\" directory (the second argument) cannot be shared in any way.\n\tsc_must_snprintf(dst, sizeof dst, \"%s/%s\", scratch_dir, SC_HOSTFS_DIR);\n\tsc_do_mount(dst, dst, NULL, MS_BIND, NULL);\n\tsc_do_mount(\"none\", dst, NULL, MS_PRIVATE, NULL);\n\t// On classic mount the nvidia driver. Ideally this would be done in an\n\t// uniform way after pivot_root but this is good enough and requires less\n\t// code changes the nvidia code assumes it has access to the existing\n\t// pre-pivot filesystem.\n\tif (config->distro == SC_DISTRO_CLASSIC) {\n\t\tsc_mount_nvidia_driver(scratch_dir);\n\t}\n\t// XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\t//                    pivot_root\n\t// XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\t// Use pivot_root to \"chroot\" into the scratch directory.\n\t//\n\t// Q: Why are we using something as esoteric as pivot_root(2)?\n\t// A: Because this makes apparmor handling easy. Using a normal chroot\n\t// makes all apparmor rules conditional.  We are either running on an\n\t// all-snap system where this would-be chroot didn't happen and all the\n\t// rules see / as the root file system _OR_ we are running on top of a\n\t// classic distribution and this chroot has now moved all paths to\n\t// /tmp/snap.rootfs_*.\n\t//\n\t// Because we are using unshare(2) with CLONE_NEWNS we can essentially use\n\t// pivot_root just like chroot but this makes apparmor unaware of the old\n\t// root so everything works okay.\n\t//\n\t// HINT: If you are debugging this and are trying to see why pivot_root\n\t// happens to return EINVAL with any changes you may be making, please\n\t// consider applying\n\t// misc/0001-Add-printk-based-debugging-to-pivot_root.patch to your tree\n\t// kernel.\n\tdebug(\"performing operation: pivot_root %s %s\", scratch_dir, dst);\n\tif (syscall(SYS_pivot_root, scratch_dir, dst) < 0) {\n\t\tdie(\"cannot perform operation: pivot_root %s %s\", scratch_dir,\n\t\t    dst);\n\t}\n\t// Unmount the self-bind mount over the scratch directory created earlier\n\t// in the original root filesystem (which is now mounted on SC_HOSTFS_DIR).\n\t// This way we can remove the temporary directory we created and \"clean up\"\n\t// after ourselves nicely.\n\tsc_must_snprintf(dst, sizeof dst, \"%s/%s\", SC_HOSTFS_DIR, scratch_dir);\n\tsc_do_umount(dst, 0);\n\t// Remove the scratch directory. Note that we are using the path that is\n\t// based on the old root filesystem as after pivot_root we cannot guarantee\n\t// what is present at the same location normally. (It is probably an empty\n\t// /tmp directory that is populated in another place).\n\tdebug(\"performing operation: rmdir %s\", dst);\n\tif (rmdir(scratch_dir) < 0) {\n\t\tdie(\"cannot perform operation: rmdir %s\", dst);\n\t};\n\t// Make the old root filesystem recursively slave. This way operations\n\t// performed in this mount namespace will not propagate to the peer group.\n\t// This is another essential part of the confinement system.\n\tsc_do_mount(\"none\", SC_HOSTFS_DIR, NULL, MS_REC | MS_SLAVE, NULL);\n\t// Detach the redundant hostfs version of sysfs since it shows up in the\n\t// mount table and software inspecting the mount table may become confused\n\t// (eg, docker and LP:# 162601).\n\tsc_must_snprintf(src, sizeof src, \"%s/sys\", SC_HOSTFS_DIR);\n\tsc_do_umount(src, UMOUNT_NOFOLLOW | MNT_DETACH);\n\t// Detach the redundant hostfs version of /dev since it shows up in the\n\t// mount table and software inspecting the mount table may become confused.\n\tsc_must_snprintf(src, sizeof src, \"%s/dev\", SC_HOSTFS_DIR);\n\tsc_do_umount(src, UMOUNT_NOFOLLOW | MNT_DETACH);\n\t// Detach the redundant hostfs version of /proc since it shows up in the\n\t// mount table and software inspecting the mount table may become confused.\n\tsc_must_snprintf(src, sizeof src, \"%s/proc\", SC_HOSTFS_DIR);\n\tsc_do_umount(src, UMOUNT_NOFOLLOW | MNT_DETACH);\n}\n\n/**\n * @path:    a pathname where / replaced with '\\0'.\n * @offsetp: pointer to int showing which path segment was last seen.\n *           Updated on return to reflect the next segment.\n * @fulllen: full original path length.\n * Returns a pointer to the next path segment, or NULL if done.\n */\nstatic char * __attribute__ ((used))\n    get_nextpath(char *path, size_t * offsetp, size_t fulllen)\n{\n\tsize_t offset = *offsetp;\n\n\tif (offset >= fulllen)\n\t\treturn NULL;\n\n\twhile (offset < fulllen && path[offset] != '\\0')\n\t\toffset++;\n\twhile (offset < fulllen && path[offset] == '\\0')\n\t\toffset++;\n\n\t*offsetp = offset;\n\treturn (offset < fulllen) ? &path[offset] : NULL;\n}\n\n/**\n * Check that @subdir is a subdir of @dir.\n**/\nstatic bool __attribute__ ((used))\n    is_subdir(const char *subdir, const char *dir)\n{\n\tsize_t dirlen = strlen(dir);\n\tsize_t subdirlen = strlen(subdir);\n\n\t// @dir has to be at least as long as @subdir\n\tif (subdirlen < dirlen)\n\t\treturn false;\n\t// @dir has to be a prefix of @subdir\n\tif (strncmp(subdir, dir, dirlen) != 0)\n\t\treturn false;\n\t// @dir can look like \"path/\" (that is, end with the directory separator).\n\t// When that is the case then given the test above we can be sure @subdir\n\t// is a real subdirectory.\n\tif (dirlen > 0 && dir[dirlen - 1] == '/')\n\t\treturn true;\n\t// @subdir can look like \"path/stuff\" and when the directory separator\n\t// is exactly at the spot where @dir ends (that is, it was not caught\n\t// by the test above) then @subdir is a real subdirectory.\n\tif (subdir[dirlen] == '/' && dirlen > 0)\n\t\treturn true;\n\t// If both @dir and @subdir have identical length then given that the\n\t// prefix check above @subdir is a real subdirectory.\n\tif (subdirlen == dirlen)\n\t\treturn true;\n\treturn false;\n}\n\nvoid sc_populate_mount_ns(struct sc_apparmor *apparmor, int snap_update_ns_fd,\n\t\t\t  const char *base_snap_name, const char *snap_name)\n{\n\t// Get the current working directory before we start fiddling with\n\t// mounts and possibly pivot_root.  At the end of the whole process, we\n\t// will try to re-locate to the same directory (if possible).\n\tchar *vanilla_cwd SC_CLEANUP(sc_cleanup_string) = NULL;\n\tvanilla_cwd = get_current_dir_name();\n\tif (vanilla_cwd == NULL) {\n\t\tdie(\"cannot get the current working directory\");\n\t}\n\t// Classify the current distribution, as claimed by /etc/os-release.\n\tsc_distro distro = sc_classify_distro();\n\t// Check which mode we should run in, normal or legacy.\n\tif (sc_should_use_normal_mode(distro, base_snap_name)) {\n\t\t// In normal mode we use the base snap as / and set up several bind mounts.\n\t\tconst struct sc_mount mounts[] = {\n\t\t\t{\"/dev\"},\t// because it contains devices on host OS\n\t\t\t{\"/etc\"},\t// because that's where /etc/resolv.conf lives, perhaps a bad idea\n\t\t\t{\"/home\"},\t// to support /home/*/snap and home interface\n\t\t\t{\"/root\"},\t// because that is $HOME for services\n\t\t\t{\"/proc\"},\t// fundamental filesystem\n\t\t\t{\"/sys\"},\t// fundamental filesystem\n\t\t\t{\"/tmp\"},\t// to get writable tmp\n\t\t\t{\"/var/snap\"},\t// to get access to global snap data\n\t\t\t{\"/var/lib/snapd\"},\t// to get access to snapd state and seccomp profiles\n\t\t\t{\"/var/tmp\"},\t// to get access to the other temporary directory\n\t\t\t{\"/run\"},\t// to get /run with sockets and what not\n\t\t\t{\"/lib/modules\",.is_optional = true},\t// access to the modules of the running kernel\n\t\t\t{\"/usr/src\"},\t// FIXME: move to SecurityMounts in system-trace interface\n\t\t\t{\"/var/log\"},\t// FIXME: move to SecurityMounts in log-observe interface\n#ifdef MERGED_USR\n\t\t\t{\"/run/media\", true, \"/media\"},\t// access to the users removable devices\n#else\n\t\t\t{\"/media\", true},\t// access to the users removable devices\n#endif\t\t\t\t// MERGED_USR\n\t\t\t{\"/run/netns\", true},\t// access to the 'ip netns' network namespaces\n\t\t\t// The /mnt directory is optional in base snaps to ensure backwards\n\t\t\t// compatibility with the first version of base snaps that was\n\t\t\t// released.\n\t\t\t{\"/mnt\",.is_optional = true},\t// to support the removable-media interface\n\t\t\t{\"/var/lib/extrausers\",.is_optional = true},\t// access to UID/GID of extrausers (if available)\n\t\t\t{},\n\t\t};\n\t\tchar rootfs_dir[PATH_MAX] = { 0 };\n\t\tsc_must_snprintf(rootfs_dir, sizeof rootfs_dir,\n\t\t\t\t \"%s/%s/current/\", SNAP_MOUNT_DIR,\n\t\t\t\t base_snap_name);\n\t\tif (access(rootfs_dir, F_OK) != 0) {\n\t\t\tif (sc_streq(base_snap_name, \"core\")) {\n\t\t\t\t// As a special fallback, allow the\n\t\t\t\t// base snap to degrade from \"core\" to\n\t\t\t\t// \"ubuntu-core\". This is needed for\n\t\t\t\t// the migration tests.\n\t\t\t\tbase_snap_name = \"ubuntu-core\";\n\t\t\t\tsc_must_snprintf(rootfs_dir, sizeof rootfs_dir,\n\t\t\t\t\t\t \"%s/%s/current/\",\n\t\t\t\t\t\t SNAP_MOUNT_DIR,\n\t\t\t\t\t\t base_snap_name);\n\t\t\t\tif (access(rootfs_dir, F_OK) != 0) {\n\t\t\t\t\tdie(\"cannot locate the core or legacy core snap (current symlink missing?)\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If after the special case handling above we are\n\t\t\t// still not ok, die\n\t\t\tif (access(rootfs_dir, F_OK) != 0)\n\t\t\t        die(\"cannot locate the base snap: %s\", base_snap_name);\n\t\t}\n\t\tstruct sc_mount_config normal_config = {\n\t\t\t.rootfs_dir = rootfs_dir,\n\t\t\t.mounts = mounts,\n\t\t\t.distro = distro,\n\t\t\t.normal_mode = true,\n\t\t\t.base_snap_name = base_snap_name,\n\t\t};\n\t\tsc_bootstrap_mount_namespace(&normal_config);\n\t} else {\n\t\t// In legacy mode we don't pivot and instead just arrange bi-\n\t\t// directional mount propagation for two directories.\n\t\tconst struct sc_mount mounts[] = {\n\t\t\t{\"/media\", true},\n\t\t\t{\"/run/netns\", true},\n\t\t\t{},\n\t\t};\n\t\tstruct sc_mount_config legacy_config = {\n\t\t\t.rootfs_dir = \"/\",\n\t\t\t.mounts = mounts,\n\t\t\t.distro = distro,\n\t\t\t.normal_mode = false,\n\t\t\t.base_snap_name = base_snap_name,\n\t\t};\n\t\tsc_bootstrap_mount_namespace(&legacy_config);\n\t}\n\n\t// set up private mounts\n\t// TODO: rename this and fold it into bootstrap\n\tsetup_private_mount(snap_name);\n\n\t// set up private /dev/pts\n\t// TODO: fold this into bootstrap\n\tsetup_private_pts();\n\n\t// setup the security backend bind mounts\n\tsc_call_snap_update_ns(snap_update_ns_fd, snap_name, apparmor);\n\n\t// Try to re-locate back to vanilla working directory. This can fail\n\t// because that directory is no longer present.\n\tif (chdir(vanilla_cwd) != 0) {\n\t\tdebug(\"cannot remain in %s, moving to the void directory\",\n\t\t      vanilla_cwd);\n\t\tif (chdir(SC_VOID_DIR) != 0) {\n\t\t\tdie(\"cannot change directory to %s\", SC_VOID_DIR);\n\t\t}\n\t\tdebug(\"successfully moved to %s\", SC_VOID_DIR);\n\t}\n}\n\nstatic bool is_mounted_with_shared_option(const char *dir)\n    __attribute__ ((nonnull(1)));\n\nstatic bool is_mounted_with_shared_option(const char *dir)\n{\n\tstruct sc_mountinfo *sm SC_CLEANUP(sc_cleanup_mountinfo) = NULL;\n\tsm = sc_parse_mountinfo(NULL);\n\tif (sm == NULL) {\n\t\tdie(\"cannot parse /proc/self/mountinfo\");\n\t}\n\tstruct sc_mountinfo_entry *entry = sc_first_mountinfo_entry(sm);\n\twhile (entry != NULL) {\n\t\tconst char *mount_dir = entry->mount_dir;\n\t\tif (sc_streq(mount_dir, dir)) {\n\t\t\tconst char *optional_fields = entry->optional_fields;\n\t\t\tif (strstr(optional_fields, \"shared:\") != NULL) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tentry = sc_next_mountinfo_entry(entry);\n\t}\n\treturn false;\n}\n\nvoid sc_ensure_shared_snap_mount(void)\n{\n\tif (!is_mounted_with_shared_option(\"/\")\n\t    && !is_mounted_with_shared_option(SNAP_MOUNT_DIR)) {\n\t\t// TODO: We could be more aggressive and refuse to function but since\n\t\t// we have no data on actual environments that happen to limp along in\n\t\t// this configuration let's not do that yet.  This code should be\n\t\t// removed once we have a measurement and feedback mechanism that lets\n\t\t// us decide based on measurable data.\n\t\tsc_do_mount(SNAP_MOUNT_DIR, SNAP_MOUNT_DIR, \"none\",\n\t\t\t    MS_BIND | MS_REC, 0);\n\t\tsc_do_mount(\"none\", SNAP_MOUNT_DIR, NULL, MS_SHARED | MS_REC,\n\t\t\t    NULL);\n\t}\n}\n\nstatic void sc_make_slave_mount_ns(void)\n{\n\tif (unshare(CLONE_NEWNS) < 0) {\n\t\tdie(\"can not unshare mount namespace\");\n\t}\n\t// In our new mount namespace, recursively change all mounts\n\t// to slave mode, so we see changes from the parent namespace\n\t// but don't propagate our own changes.\n\tsc_do_mount(\"none\", \"/\", NULL, MS_REC | MS_SLAVE, NULL);\n}\n\nvoid sc_setup_user_mounts(struct sc_apparmor *apparmor, int snap_update_ns_fd,\n\t\t\t  const char *snap_name)\n{\n\tdebug(\"%s: %s\", __FUNCTION__, snap_name);\n\n\tchar profile_path[PATH_MAX];\n\tstruct stat st;\n\n\tsc_must_snprintf(profile_path, sizeof(profile_path),\n\t\t\t \"/var/lib/snapd/mount/snap.%s.user-fstab\", snap_name);\n\tif (stat(profile_path, &st) != 0) {\n\t\t// It is ok for the user fstab to not exist.\n\t\treturn;\n\t}\n\n\tsc_make_slave_mount_ns();\n\tsc_call_snap_update_ns_as_user(snap_update_ns_fd, snap_name, apparmor);\n}\n"], "fixing_code": ["/*\n * Copyright (C) 2015 Canonical Ltd\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 3 as\n * published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"mount-support.h\"\n\n#include <errno.h>\n#include <fcntl.h>\n#include <libgen.h>\n#include <limits.h>\n#include <mntent.h>\n#include <sched.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/syscall.h>\n#include <sys/types.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\n#include \"../libsnap-confine-private/apparmor-support.h\"\n#include \"../libsnap-confine-private/classic.h\"\n#include \"../libsnap-confine-private/cleanup-funcs.h\"\n#include \"../libsnap-confine-private/mount-opt.h\"\n#include \"../libsnap-confine-private/mountinfo.h\"\n#include \"../libsnap-confine-private/snap.h\"\n#include \"../libsnap-confine-private/string-utils.h\"\n#include \"../libsnap-confine-private/tool.h\"\n#include \"../libsnap-confine-private/utils.h\"\n#include \"mount-support-nvidia.h\"\n\n#define MAX_BUF 1000\n\n/*!\n * The void directory.\n *\n * Snap confine moves to that directory in case it cannot retain the current\n * working directory across the pivot_root call.\n **/\n#define SC_VOID_DIR \"/var/lib/snapd/void\"\n\n// TODO: simplify this, after all it is just a tmpfs\n// TODO: fold this into bootstrap\nstatic void setup_private_mount(const char *snap_name)\n{\n\tchar tmpdir[MAX_BUF] = { 0 };\n\n\t// Create a 0700 base directory, this is the base dir that is\n\t// protected from other users.\n\t//\n\t// Under that basedir, we put a 1777 /tmp dir that is then bind\n\t// mounted for the applications to use\n\tsc_must_snprintf(tmpdir, sizeof(tmpdir), \"/tmp/snap.%s_XXXXXX\", snap_name);\n\tif (mkdtemp(tmpdir) == NULL) {\n\t\tdie(\"cannot create temporary directory essential for private /tmp\");\n\t}\n\t// now we create a 1777 /tmp inside our private dir\n\tmode_t old_mask = umask(0);\n\tchar *d = sc_strdup(tmpdir);\n\tsc_must_snprintf(tmpdir, sizeof(tmpdir), \"%s/tmp\", d);\n\tfree(d);\n\n\tif (mkdir(tmpdir, 01777) != 0) {\n\t\tdie(\"cannot create temporary directory for private /tmp\");\n\t}\n\tumask(old_mask);\n\n\t// chdir to '/' since the mount won't apply to the current directory\n\tchar *pwd = get_current_dir_name();\n\tif (pwd == NULL)\n\t\tdie(\"cannot get current working directory\");\n\tif (chdir(\"/\") != 0)\n\t\tdie(\"cannot change directory to '/'\");\n\n\t// MS_BIND is there from linux 2.4\n\tsc_do_mount(tmpdir, \"/tmp\", NULL, MS_BIND, NULL);\n\t// MS_PRIVATE needs linux > 2.6.11\n\tsc_do_mount(\"none\", \"/tmp\", NULL, MS_PRIVATE, NULL);\n\t// do the chown after the bind mount to avoid potential shenanigans\n\tif (chown(\"/tmp/\", 0, 0) < 0) {\n\t\tdie(\"cannot change ownership of /tmp\");\n\t}\n\t// chdir to original directory\n\tif (chdir(pwd) != 0)\n\t\tdie(\"cannot change current working directory to the original directory\");\n\tfree(pwd);\n}\n\n// TODO: fold this into bootstrap\nstatic void setup_private_pts(void)\n{\n\t// See https://www.kernel.org/doc/Documentation/filesystems/devpts.txt\n\t//\n\t// Ubuntu by default uses devpts 'single-instance' mode where\n\t// /dev/pts/ptmx is mounted with ptmxmode=0000. We don't want to change\n\t// the startup scripts though, so we follow the instructions in point\n\t// '4' of 'User-space changes' in the above doc. In other words, after\n\t// unshare(CLONE_NEWNS), we mount devpts with -o\n\t// newinstance,ptmxmode=0666 and then bind mount /dev/pts/ptmx onto\n\t// /dev/ptmx\n\n\tstruct stat st;\n\n\t// Make sure /dev/pts/ptmx exists, otherwise we are in legacy mode\n\t// which doesn't provide the isolation we require.\n\tif (stat(\"/dev/pts/ptmx\", &st) != 0) {\n\t\tdie(\"cannot stat /dev/pts/ptmx\");\n\t}\n\t// Make sure /dev/ptmx exists so we can bind mount over it\n\tif (stat(\"/dev/ptmx\", &st) != 0) {\n\t\tdie(\"cannot stat /dev/ptmx\");\n\t}\n\t// Since multi-instance, use ptmxmode=0666. The other options are\n\t// copied from /etc/default/devpts\n\tsc_do_mount(\"devpts\", \"/dev/pts\", \"devpts\", MS_MGC_VAL,\n\t\t    \"newinstance,ptmxmode=0666,mode=0620,gid=5\");\n\tsc_do_mount(\"/dev/pts/ptmx\", \"/dev/ptmx\", \"none\", MS_BIND, 0);\n}\n\nstruct sc_mount {\n\tconst char *path;\n\tbool is_bidirectional;\n\t// Alternate path defines the rbind mount \"alternative\" of path.\n\t// It exists so that we can make /media on systems that use /run/media.\n\tconst char *altpath;\n\t// Optional mount points are not processed unless the source and\n\t// destination both exist.\n\tbool is_optional;\n};\n\nstruct sc_mount_config {\n\tconst char *rootfs_dir;\n\t// The struct is terminated with an entry with NULL path.\n\tconst struct sc_mount *mounts;\n\tsc_distro distro;\n\tbool normal_mode;\n\tconst char *base_snap_name;\n};\n\n/**\n * Bootstrap mount namespace.\n *\n * This is a chunk of tricky code that lets us have full control over the\n * layout and direction of propagation of mount events. The documentation below\n * assumes knowledge of the 'sharedsubtree.txt' document from the kernel source\n * tree.\n *\n * As a reminder two definitions are quoted below:\n *\n *  A 'propagation event' is defined as event generated on a vfsmount\n *  that leads to mount or unmount actions in other vfsmounts.\n *\n *  A 'peer group' is defined as a group of vfsmounts that propagate\n *  events to each other.\n *\n * (end of quote).\n *\n * The main idea is to setup a mount namespace that has a root filesystem with\n * vfsmounts and peer groups that, depending on the location, either isolate\n * or share with the rest of the system.\n *\n * The vast majority of the filesystem is shared in one direction. Events from\n * the outside (from the main mount namespace) propagate inside (to namespaces\n * of particular snaps) so things like new snap revisions, mounted drives, etc,\n * just show up as expected but even if a snap is exploited or malicious in\n * nature it cannot affect anything in another namespace where it might cause\n * security or stability issues.\n *\n * Selected directories (today just /media) can be shared in both directions.\n * This allows snaps with sufficient privileges to either create, through the\n * mount system call, additional mount points that are visible by the rest of\n * the system (both the main mount namespace and namespaces of individual\n * snaps) or remove them, through the unmount system call.\n **/\nstatic void sc_bootstrap_mount_namespace(const struct sc_mount_config *config)\n{\n\tchar scratch_dir[] = \"/tmp/snap.rootfs_XXXXXX\";\n\tchar src[PATH_MAX] = { 0 };\n\tchar dst[PATH_MAX] = { 0 };\n\tif (mkdtemp(scratch_dir) == NULL) {\n\t\tdie(\"cannot create temporary directory for the root file system\");\n\t}\n\t// NOTE: at this stage we just called unshare(CLONE_NEWNS). We are in a new\n\t// mount namespace and have a private list of mounts.\n\tdebug(\"scratch directory for constructing namespace: %s\", scratch_dir);\n\t// Make the root filesystem recursively shared. This way propagation events\n\t// will be shared with main mount namespace.\n\tsc_do_mount(\"none\", \"/\", NULL, MS_REC | MS_SHARED, NULL);\n\t// Bind mount the temporary scratch directory for root filesystem over\n\t// itself so that it is a mount point. This is done so that it can become\n\t// unbindable as explained below.\n\tsc_do_mount(scratch_dir, scratch_dir, NULL, MS_BIND, NULL);\n\t// Make the scratch directory unbindable.\n\t//\n\t// This is necessary as otherwise a mount loop can occur and the kernel\n\t// would crash. The term unbindable simply states that it cannot be bind\n\t// mounted anywhere. When we construct recursive bind mounts below this\n\t// guarantees that this directory will not be replicated anywhere.\n\tsc_do_mount(\"none\", scratch_dir, NULL, MS_UNBINDABLE, NULL);\n\t// Recursively bind mount desired root filesystem directory over the\n\t// scratch directory. This puts the initial content into the scratch space\n\t// and serves as a foundation for all subsequent operations below.\n\t//\n\t// The mount is recursive because it can either be applied to the root\n\t// filesystem of a core system (aka all-snap) or the core snap on a classic\n\t// system. In the former case we need recursive bind mounts to accurately\n\t// replicate the state of the root filesystem into the scratch directory.\n\tsc_do_mount(config->rootfs_dir, scratch_dir, NULL, MS_REC | MS_BIND,\n\t\t    NULL);\n\t// Make the scratch directory recursively private. Nothing done there will\n\t// be shared with any peer group, This effectively detaches us from the\n\t// original namespace and coupled with pivot_root below serves as the\n\t// foundation of the mount sandbox.\n\tsc_do_mount(\"none\", scratch_dir, NULL, MS_REC | MS_SLAVE, NULL);\n\t// Bind mount certain directories from the host filesystem to the scratch\n\t// directory. By default mount events will propagate in both into and out\n\t// of the peer group. This way the running application can alter any global\n\t// state visible on the host and in other snaps. This can be restricted by\n\t// disabling the \"is_bidirectional\" flag as can be seen below.\n\tfor (const struct sc_mount * mnt = config->mounts; mnt->path != NULL;\n\t     mnt++) {\n\t\tif (mnt->is_bidirectional && mkdir(mnt->path, 0755) < 0 &&\n\t\t    errno != EEXIST) {\n\t\t\tdie(\"cannot create %s\", mnt->path);\n\t\t}\n\t\tsc_must_snprintf(dst, sizeof dst, \"%s/%s\", scratch_dir,\n\t\t\t\t mnt->path);\n\t\tif (mnt->is_optional) {\n\t\t\tbool ok = sc_do_optional_mount(mnt->path, dst, NULL,\n\t\t\t\t\t\t       MS_REC | MS_BIND, NULL);\n\t\t\tif (!ok) {\n\t\t\t\t// If we cannot mount it, just continue.\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tsc_do_mount(mnt->path, dst, NULL, MS_REC | MS_BIND,\n\t\t\t\t    NULL);\n\t\t}\n\t\tif (!mnt->is_bidirectional) {\n\t\t\t// Mount events will only propagate inwards to the namespace. This\n\t\t\t// way the running application cannot alter any global state apart\n\t\t\t// from that of its own snap.\n\t\t\tsc_do_mount(\"none\", dst, NULL, MS_REC | MS_SLAVE, NULL);\n\t\t}\n\t\tif (mnt->altpath == NULL) {\n\t\t\tcontinue;\n\t\t}\n\t\t// An alternate path of mnt->path is provided at another location.\n\t\t// It should behave exactly the same as the original.\n\t\tsc_must_snprintf(dst, sizeof dst, \"%s/%s\", scratch_dir,\n\t\t\t\t mnt->altpath);\n\t\tstruct stat stat_buf;\n\t\tif (lstat(dst, &stat_buf) < 0) {\n\t\t\tdie(\"cannot lstat %s\", dst);\n\t\t}\n\t\tif ((stat_buf.st_mode & S_IFMT) == S_IFLNK) {\n\t\t\tdie(\"cannot bind mount alternate path over a symlink: %s\", dst);\n\t\t}\n\t\tsc_do_mount(mnt->path, dst, NULL, MS_REC | MS_BIND, NULL);\n\t\tif (!mnt->is_bidirectional) {\n\t\t\tsc_do_mount(\"none\", dst, NULL, MS_REC | MS_SLAVE, NULL);\n\t\t}\n\t}\n\tif (config->normal_mode) {\n\t\t// Since we mounted /etc from the host filesystem to the scratch directory,\n\t\t// we may need to put certain directories from the desired root filesystem\n\t\t// (e.g. the core snap) back. This way the behavior of running snaps is not\n\t\t// affected by the alternatives directory from the host, if one exists.\n\t\t//\n\t\t// Fixes the following bugs:\n\t\t//  - https://bugs.launchpad.net/snap-confine/+bug/1580018\n\t\t//  - https://bugzilla.opensuse.org/show_bug.cgi?id=1028568\n\t\tconst char *dirs_from_core[] =\n\t\t    { \"/etc/alternatives\", \"/etc/ssl\", \"/etc/nsswitch.conf\",\n\t\t\tNULL\n\t\t};\n\t\tfor (const char **dirs = dirs_from_core; *dirs != NULL; dirs++) {\n\t\t\tconst char *dir = *dirs;\n\t\t\tstruct stat buf;\n\t\t\tif (access(dir, F_OK) == 0) {\n\t\t\t\tsc_must_snprintf(src, sizeof src, \"%s%s\",\n\t\t\t\t\t\t config->rootfs_dir, dir);\n\t\t\t\tsc_must_snprintf(dst, sizeof dst, \"%s%s\",\n\t\t\t\t\t\t scratch_dir, dir);\n\t\t\t\tif (lstat(src, &buf) == 0\n\t\t\t\t    && lstat(dst, &buf) == 0) {\n\t\t\t\t\tsc_do_mount(src, dst, NULL, MS_BIND,\n\t\t\t\t\t\t    NULL);\n\t\t\t\t\tsc_do_mount(\"none\", dst, NULL, MS_SLAVE,\n\t\t\t\t\t\t    NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// The \"core\" base snap is special as it contains snapd and friends.\n\t// Other base snaps do not, so whenever a base snap other than core is\n\t// in use we need extra provisions for setting up internal tooling to\n\t// be available.\n\t//\n\t// However on a core18 (and similar) system the core snap is not\n\t// a special base anymore and we should map our own tooling in.\n\tif (config->distro == SC_DISTRO_CORE_OTHER\n\t    || !sc_streq(config->base_snap_name, \"core\")) {\n\t\t// when bases are used we need to bind-mount the libexecdir\n\t\t// (that contains snap-exec) into /usr/lib/snapd of the\n\t\t// base snap so that snap-exec is available for the snaps\n\t\t// (base snaps do not ship snapd)\n\n\t\t// dst is always /usr/lib/snapd as this is where snapd\n\t\t// assumes to find snap-exec\n\t\tsc_must_snprintf(dst, sizeof dst, \"%s/usr/lib/snapd\",\n\t\t\t\t scratch_dir);\n\n\t\t// bind mount the current $ROOT/usr/lib/snapd path,\n\t\t// where $ROOT is either \"/\" or the \"/snap/{core,snapd}/current\"\n\t\t// that we are re-execing from\n\t\tchar *src = NULL;\n\t\tchar self[PATH_MAX + 1] = { 0 };\n\t\tif (readlink(\"/proc/self/exe\", self, sizeof(self) - 1) < 0) {\n\t\t\tdie(\"cannot read /proc/self/exe\");\n\t\t}\n\t\t// this cannot happen except when the kernel is buggy\n\t\tif (strstr(self, \"/snap-confine\") == NULL) {\n\t\t\tdie(\"cannot use result from readlink: %s\", self);\n\t\t}\n\t\tsrc = dirname(self);\n\t\t// dirname(path) might return '.' depending on path.\n\t\t// /proc/self/exe should always point\n\t\t// to an absolute path, but let's guarantee that.\n\t\tif (src[0] != '/') {\n\t\t\tdie(\"cannot use the result of dirname(): %s\", src);\n\t\t}\n\n\t\tsc_do_mount(src, dst, NULL, MS_BIND | MS_RDONLY, NULL);\n\t\tsc_do_mount(\"none\", dst, NULL, MS_SLAVE, NULL);\n\t}\n\t// Bind mount the directory where all snaps are mounted. The location of\n\t// the this directory on the host filesystem may not match the location in\n\t// the desired root filesystem. In the \"core\" and \"ubuntu-core\" snaps the\n\t// directory is always /snap. On the host it is a build-time configuration\n\t// option stored in SNAP_MOUNT_DIR.\n\tsc_must_snprintf(dst, sizeof dst, \"%s/snap\", scratch_dir);\n\tsc_do_mount(SNAP_MOUNT_DIR, dst, NULL, MS_BIND | MS_REC | MS_SLAVE,\n\t\t    NULL);\n\tsc_do_mount(\"none\", dst, NULL, MS_REC | MS_SLAVE, NULL);\n\t// Create the hostfs directory if one is missing. This directory is a part\n\t// of packaging now so perhaps this code can be removed later.\n\tif (access(SC_HOSTFS_DIR, F_OK) != 0) {\n\t\tdebug(\"creating missing hostfs directory\");\n\t\tif (mkdir(SC_HOSTFS_DIR, 0755) != 0) {\n\t\t\tdie(\"cannot perform operation: mkdir %s\",\n\t\t\t    SC_HOSTFS_DIR);\n\t\t}\n\t}\n\t// Ensure that hostfs isgroup owned by root. We may have (now or earlier)\n\t// created the directory as the user who first ran a snap on a given\n\t// system and the group identity of that user is visilbe on disk.\n\t// This was LP:#1665004\n\tstruct stat sb;\n\tif (stat(SC_HOSTFS_DIR, &sb) < 0) {\n\t\tdie(\"cannot stat %s\", SC_HOSTFS_DIR);\n\t}\n\tif (sb.st_uid != 0 || sb.st_gid != 0) {\n\t\tif (chown(SC_HOSTFS_DIR, 0, 0) < 0) {\n\t\t\tdie(\"cannot change user/group owner of %s to root\",\n\t\t\t    SC_HOSTFS_DIR);\n\t\t}\n\t}\n\t// Make the upcoming \"put_old\" directory for pivot_root private so that\n\t// mount events don't propagate to any peer group. In practice pivot root\n\t// has a number of undocumented requirements and one of them is that the\n\t// \"put_old\" directory (the second argument) cannot be shared in any way.\n\tsc_must_snprintf(dst, sizeof dst, \"%s/%s\", scratch_dir, SC_HOSTFS_DIR);\n\tsc_do_mount(dst, dst, NULL, MS_BIND, NULL);\n\tsc_do_mount(\"none\", dst, NULL, MS_PRIVATE, NULL);\n\t// On classic mount the nvidia driver. Ideally this would be done in an\n\t// uniform way after pivot_root but this is good enough and requires less\n\t// code changes the nvidia code assumes it has access to the existing\n\t// pre-pivot filesystem.\n\tif (config->distro == SC_DISTRO_CLASSIC) {\n\t\tsc_mount_nvidia_driver(scratch_dir);\n\t}\n\t// XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\t//                    pivot_root\n\t// XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\t// Use pivot_root to \"chroot\" into the scratch directory.\n\t//\n\t// Q: Why are we using something as esoteric as pivot_root(2)?\n\t// A: Because this makes apparmor handling easy. Using a normal chroot\n\t// makes all apparmor rules conditional.  We are either running on an\n\t// all-snap system where this would-be chroot didn't happen and all the\n\t// rules see / as the root file system _OR_ we are running on top of a\n\t// classic distribution and this chroot has now moved all paths to\n\t// /tmp/snap.rootfs_*.\n\t//\n\t// Because we are using unshare(2) with CLONE_NEWNS we can essentially use\n\t// pivot_root just like chroot but this makes apparmor unaware of the old\n\t// root so everything works okay.\n\t//\n\t// HINT: If you are debugging this and are trying to see why pivot_root\n\t// happens to return EINVAL with any changes you may be making, please\n\t// consider applying\n\t// misc/0001-Add-printk-based-debugging-to-pivot_root.patch to your tree\n\t// kernel.\n\tdebug(\"performing operation: pivot_root %s %s\", scratch_dir, dst);\n\tif (syscall(SYS_pivot_root, scratch_dir, dst) < 0) {\n\t\tdie(\"cannot perform operation: pivot_root %s %s\", scratch_dir,\n\t\t    dst);\n\t}\n\t// Unmount the self-bind mount over the scratch directory created earlier\n\t// in the original root filesystem (which is now mounted on SC_HOSTFS_DIR).\n\t// This way we can remove the temporary directory we created and \"clean up\"\n\t// after ourselves nicely.\n\tsc_must_snprintf(dst, sizeof dst, \"%s/%s\", SC_HOSTFS_DIR, scratch_dir);\n\tsc_do_umount(dst, 0);\n\t// Remove the scratch directory. Note that we are using the path that is\n\t// based on the old root filesystem as after pivot_root we cannot guarantee\n\t// what is present at the same location normally. (It is probably an empty\n\t// /tmp directory that is populated in another place).\n\tdebug(\"performing operation: rmdir %s\", dst);\n\tif (rmdir(scratch_dir) < 0) {\n\t\tdie(\"cannot perform operation: rmdir %s\", dst);\n\t};\n\t// Make the old root filesystem recursively slave. This way operations\n\t// performed in this mount namespace will not propagate to the peer group.\n\t// This is another essential part of the confinement system.\n\tsc_do_mount(\"none\", SC_HOSTFS_DIR, NULL, MS_REC | MS_SLAVE, NULL);\n\t// Detach the redundant hostfs version of sysfs since it shows up in the\n\t// mount table and software inspecting the mount table may become confused\n\t// (eg, docker and LP:# 162601).\n\tsc_must_snprintf(src, sizeof src, \"%s/sys\", SC_HOSTFS_DIR);\n\tsc_do_umount(src, UMOUNT_NOFOLLOW | MNT_DETACH);\n\t// Detach the redundant hostfs version of /dev since it shows up in the\n\t// mount table and software inspecting the mount table may become confused.\n\tsc_must_snprintf(src, sizeof src, \"%s/dev\", SC_HOSTFS_DIR);\n\tsc_do_umount(src, UMOUNT_NOFOLLOW | MNT_DETACH);\n\t// Detach the redundant hostfs version of /proc since it shows up in the\n\t// mount table and software inspecting the mount table may become confused.\n\tsc_must_snprintf(src, sizeof src, \"%s/proc\", SC_HOSTFS_DIR);\n\tsc_do_umount(src, UMOUNT_NOFOLLOW | MNT_DETACH);\n}\n\n/**\n * @path:    a pathname where / replaced with '\\0'.\n * @offsetp: pointer to int showing which path segment was last seen.\n *           Updated on return to reflect the next segment.\n * @fulllen: full original path length.\n * Returns a pointer to the next path segment, or NULL if done.\n */\nstatic char * __attribute__ ((used))\n    get_nextpath(char *path, size_t * offsetp, size_t fulllen)\n{\n\tsize_t offset = *offsetp;\n\n\tif (offset >= fulllen)\n\t\treturn NULL;\n\n\twhile (offset < fulllen && path[offset] != '\\0')\n\t\toffset++;\n\twhile (offset < fulllen && path[offset] == '\\0')\n\t\toffset++;\n\n\t*offsetp = offset;\n\treturn (offset < fulllen) ? &path[offset] : NULL;\n}\n\n/**\n * Check that @subdir is a subdir of @dir.\n**/\nstatic bool __attribute__ ((used))\n    is_subdir(const char *subdir, const char *dir)\n{\n\tsize_t dirlen = strlen(dir);\n\tsize_t subdirlen = strlen(subdir);\n\n\t// @dir has to be at least as long as @subdir\n\tif (subdirlen < dirlen)\n\t\treturn false;\n\t// @dir has to be a prefix of @subdir\n\tif (strncmp(subdir, dir, dirlen) != 0)\n\t\treturn false;\n\t// @dir can look like \"path/\" (that is, end with the directory separator).\n\t// When that is the case then given the test above we can be sure @subdir\n\t// is a real subdirectory.\n\tif (dirlen > 0 && dir[dirlen - 1] == '/')\n\t\treturn true;\n\t// @subdir can look like \"path/stuff\" and when the directory separator\n\t// is exactly at the spot where @dir ends (that is, it was not caught\n\t// by the test above) then @subdir is a real subdirectory.\n\tif (subdir[dirlen] == '/' && dirlen > 0)\n\t\treturn true;\n\t// If both @dir and @subdir have identical length then given that the\n\t// prefix check above @subdir is a real subdirectory.\n\tif (subdirlen == dirlen)\n\t\treturn true;\n\treturn false;\n}\n\nvoid sc_populate_mount_ns(struct sc_apparmor *apparmor, int snap_update_ns_fd,\n\t\t\t  const char *base_snap_name, const char *snap_name)\n{\n\t// Get the current working directory before we start fiddling with\n\t// mounts and possibly pivot_root.  At the end of the whole process, we\n\t// will try to re-locate to the same directory (if possible).\n\tchar *vanilla_cwd SC_CLEANUP(sc_cleanup_string) = NULL;\n\tvanilla_cwd = get_current_dir_name();\n\tif (vanilla_cwd == NULL) {\n\t\tdie(\"cannot get the current working directory\");\n\t}\n\t// Classify the current distribution, as claimed by /etc/os-release.\n\tsc_distro distro = sc_classify_distro();\n\t// Check which mode we should run in, normal or legacy.\n\tif (sc_should_use_normal_mode(distro, base_snap_name)) {\n\t\t// In normal mode we use the base snap as / and set up several bind mounts.\n\t\tconst struct sc_mount mounts[] = {\n\t\t\t{\"/dev\"},\t// because it contains devices on host OS\n\t\t\t{\"/etc\"},\t// because that's where /etc/resolv.conf lives, perhaps a bad idea\n\t\t\t{\"/home\"},\t// to support /home/*/snap and home interface\n\t\t\t{\"/root\"},\t// because that is $HOME for services\n\t\t\t{\"/proc\"},\t// fundamental filesystem\n\t\t\t{\"/sys\"},\t// fundamental filesystem\n\t\t\t{\"/tmp\"},\t// to get writable tmp\n\t\t\t{\"/var/snap\"},\t// to get access to global snap data\n\t\t\t{\"/var/lib/snapd\"},\t// to get access to snapd state and seccomp profiles\n\t\t\t{\"/var/tmp\"},\t// to get access to the other temporary directory\n\t\t\t{\"/run\"},\t// to get /run with sockets and what not\n\t\t\t{\"/lib/modules\",.is_optional = true},\t// access to the modules of the running kernel\n\t\t\t{\"/usr/src\"},\t// FIXME: move to SecurityMounts in system-trace interface\n\t\t\t{\"/var/log\"},\t// FIXME: move to SecurityMounts in log-observe interface\n#ifdef MERGED_USR\n\t\t\t{\"/run/media\", true, \"/media\"},\t// access to the users removable devices\n#else\n\t\t\t{\"/media\", true},\t// access to the users removable devices\n#endif\t\t\t\t// MERGED_USR\n\t\t\t{\"/run/netns\", true},\t// access to the 'ip netns' network namespaces\n\t\t\t// The /mnt directory is optional in base snaps to ensure backwards\n\t\t\t// compatibility with the first version of base snaps that was\n\t\t\t// released.\n\t\t\t{\"/mnt\",.is_optional = true},\t// to support the removable-media interface\n\t\t\t{\"/var/lib/extrausers\",.is_optional = true},\t// access to UID/GID of extrausers (if available)\n\t\t\t{},\n\t\t};\n\t\tchar rootfs_dir[PATH_MAX] = { 0 };\n\t\tsc_must_snprintf(rootfs_dir, sizeof rootfs_dir,\n\t\t\t\t \"%s/%s/current/\", SNAP_MOUNT_DIR,\n\t\t\t\t base_snap_name);\n\t\tif (access(rootfs_dir, F_OK) != 0) {\n\t\t\tif (sc_streq(base_snap_name, \"core\")) {\n\t\t\t\t// As a special fallback, allow the\n\t\t\t\t// base snap to degrade from \"core\" to\n\t\t\t\t// \"ubuntu-core\". This is needed for\n\t\t\t\t// the migration tests.\n\t\t\t\tbase_snap_name = \"ubuntu-core\";\n\t\t\t\tsc_must_snprintf(rootfs_dir, sizeof rootfs_dir,\n\t\t\t\t\t\t \"%s/%s/current/\",\n\t\t\t\t\t\t SNAP_MOUNT_DIR,\n\t\t\t\t\t\t base_snap_name);\n\t\t\t\tif (access(rootfs_dir, F_OK) != 0) {\n\t\t\t\t\tdie(\"cannot locate the core or legacy core snap (current symlink missing?)\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If after the special case handling above we are\n\t\t\t// still not ok, die\n\t\t\tif (access(rootfs_dir, F_OK) != 0)\n\t\t\t        die(\"cannot locate the base snap: %s\", base_snap_name);\n\t\t}\n\t\tstruct sc_mount_config normal_config = {\n\t\t\t.rootfs_dir = rootfs_dir,\n\t\t\t.mounts = mounts,\n\t\t\t.distro = distro,\n\t\t\t.normal_mode = true,\n\t\t\t.base_snap_name = base_snap_name,\n\t\t};\n\t\tsc_bootstrap_mount_namespace(&normal_config);\n\t} else {\n\t\t// In legacy mode we don't pivot and instead just arrange bi-\n\t\t// directional mount propagation for two directories.\n\t\tconst struct sc_mount mounts[] = {\n\t\t\t{\"/media\", true},\n\t\t\t{\"/run/netns\", true},\n\t\t\t{},\n\t\t};\n\t\tstruct sc_mount_config legacy_config = {\n\t\t\t.rootfs_dir = \"/\",\n\t\t\t.mounts = mounts,\n\t\t\t.distro = distro,\n\t\t\t.normal_mode = false,\n\t\t\t.base_snap_name = base_snap_name,\n\t\t};\n\t\tsc_bootstrap_mount_namespace(&legacy_config);\n\t}\n\n\t// set up private mounts\n\t// TODO: rename this and fold it into bootstrap\n\tsetup_private_mount(snap_name);\n\n\t// set up private /dev/pts\n\t// TODO: fold this into bootstrap\n\tsetup_private_pts();\n\n\t// setup the security backend bind mounts\n\tsc_call_snap_update_ns(snap_update_ns_fd, snap_name, apparmor);\n\n\t// Try to re-locate back to vanilla working directory. This can fail\n\t// because that directory is no longer present.\n\tif (chdir(vanilla_cwd) != 0) {\n\t\tdebug(\"cannot remain in %s, moving to the void directory\",\n\t\t      vanilla_cwd);\n\t\tif (chdir(SC_VOID_DIR) != 0) {\n\t\t\tdie(\"cannot change directory to %s\", SC_VOID_DIR);\n\t\t}\n\t\tdebug(\"successfully moved to %s\", SC_VOID_DIR);\n\t}\n}\n\nstatic bool is_mounted_with_shared_option(const char *dir)\n    __attribute__ ((nonnull(1)));\n\nstatic bool is_mounted_with_shared_option(const char *dir)\n{\n\tstruct sc_mountinfo *sm SC_CLEANUP(sc_cleanup_mountinfo) = NULL;\n\tsm = sc_parse_mountinfo(NULL);\n\tif (sm == NULL) {\n\t\tdie(\"cannot parse /proc/self/mountinfo\");\n\t}\n\tstruct sc_mountinfo_entry *entry = sc_first_mountinfo_entry(sm);\n\twhile (entry != NULL) {\n\t\tconst char *mount_dir = entry->mount_dir;\n\t\tif (sc_streq(mount_dir, dir)) {\n\t\t\tconst char *optional_fields = entry->optional_fields;\n\t\t\tif (strstr(optional_fields, \"shared:\") != NULL) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tentry = sc_next_mountinfo_entry(entry);\n\t}\n\treturn false;\n}\n\nvoid sc_ensure_shared_snap_mount(void)\n{\n\tif (!is_mounted_with_shared_option(\"/\")\n\t    && !is_mounted_with_shared_option(SNAP_MOUNT_DIR)) {\n\t\t// TODO: We could be more aggressive and refuse to function but since\n\t\t// we have no data on actual environments that happen to limp along in\n\t\t// this configuration let's not do that yet.  This code should be\n\t\t// removed once we have a measurement and feedback mechanism that lets\n\t\t// us decide based on measurable data.\n\t\tsc_do_mount(SNAP_MOUNT_DIR, SNAP_MOUNT_DIR, \"none\",\n\t\t\t    MS_BIND | MS_REC, 0);\n\t\tsc_do_mount(\"none\", SNAP_MOUNT_DIR, NULL, MS_SHARED | MS_REC,\n\t\t\t    NULL);\n\t}\n}\n\nstatic void sc_make_slave_mount_ns(void)\n{\n\tif (unshare(CLONE_NEWNS) < 0) {\n\t\tdie(\"can not unshare mount namespace\");\n\t}\n\t// In our new mount namespace, recursively change all mounts\n\t// to slave mode, so we see changes from the parent namespace\n\t// but don't propagate our own changes.\n\tsc_do_mount(\"none\", \"/\", NULL, MS_REC | MS_SLAVE, NULL);\n}\n\nvoid sc_setup_user_mounts(struct sc_apparmor *apparmor, int snap_update_ns_fd,\n\t\t\t  const char *snap_name)\n{\n\tdebug(\"%s: %s\", __FUNCTION__, snap_name);\n\n\tchar profile_path[PATH_MAX];\n\tstruct stat st;\n\n\tsc_must_snprintf(profile_path, sizeof(profile_path),\n\t\t\t \"/var/lib/snapd/mount/snap.%s.user-fstab\", snap_name);\n\tif (stat(profile_path, &st) != 0) {\n\t\t// It is ok for the user fstab to not exist.\n\t\treturn;\n\t}\n\n\tsc_make_slave_mount_ns();\n\tsc_call_snap_update_ns_as_user(snap_update_ns_fd, snap_name, apparmor);\n}\n"], "filenames": ["cmd/snap-confine/mount-support.c"], "buggy_code_start_loc": [65], "buggy_code_end_loc": [102], "fixing_code_start_loc": [64], "fixing_code_end_loc": [100], "type": "CWE-59", "message": "snap-confine in snapd before 2.38 incorrectly set the ownership of a snap application to the uid and gid of the first calling user. Consequently, that user had unintended access to a private /tmp directory.", "other": {"cve": {"id": "CVE-2019-11502", "sourceIdentifier": "cve@mitre.org", "published": "2019-04-24T21:29:00.727", "lastModified": "2019-05-02T13:35:31.683", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "snap-confine in snapd before 2.38 incorrectly set the ownership of a snap application to the uid and gid of the first calling user. Consequently, that user had unintended access to a private /tmp directory."}, {"lang": "es", "value": "snap-confine, en snap antes de la versi\u00f3n 2.38, establece incorrectamente la propiedad de una aplicaci\u00f3n snap al uid y gid del usuario que realiza la primera llamada. Consecuentemente, ese usuario tiene un acceso no intencionado a un directorio /tmp privado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-59"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:canonical:snapd:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.38", "matchCriteriaId": "102DFBEE-3825-4314-8577-DB0948C47E21"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2019/04/25/7", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/snapcore/snapd/commit/bdbfeebef03245176ae0dc323392bb0522a339b1", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.openwall.com/lists/oss-security/2019/04/18/4", "source": "cve@mitre.org", "tags": ["Mailing List", "Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/snapcore/snapd/commit/bdbfeebef03245176ae0dc323392bb0522a339b1"}}