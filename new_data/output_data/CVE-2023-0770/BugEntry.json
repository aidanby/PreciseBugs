{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2012\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / Scene Graph sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n\n#include <gpac/internal/scenegraph_dev.h>\n/*MPEG4 & X3D tags (for node tables & script handling)*/\n#include <gpac/nodes_mpeg4.h>\n#include <gpac/nodes_x3d.h>\n\n#ifndef GPAC_DISABLE_VRML\n\nGF_EXPORT\nGF_Proto *gf_sg_proto_new(GF_SceneGraph *inScene, u32 ProtoID, char *name, Bool unregistered)\n{\n\tGF_Proto *tmp;\n\tif (!inScene) return NULL;\n\n\t/*make sure we don't define a proto already defined in this scope*/\n\tif (!unregistered) {\n\t\ttmp = gf_sg_find_proto(inScene, ProtoID, name);\n\t\tif (tmp) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_SCENE, (\"[Scenegraph] PROTO %s redefined - skipping loading\\n\", name));\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tGF_SAFEALLOC(tmp, GF_Proto)\n\tif (!tmp) return NULL;\n\n\ttmp->proto_fields = gf_list_new();\n\ttmp->node_code = gf_list_new();\n\ttmp->parent_graph = inScene;\n\ttmp->sub_graph = gf_sg_new_subscene(inScene);\n\ttmp->instances = gf_list_new();\n\n\tif (name)\n\t\ttmp->Name = gf_strdup(name);\n\telse\n\t\ttmp->Name = gf_strdup(\"Unnamed Proto\");\n\ttmp->ID = ProtoID;\n\tif (!unregistered) {\n\t\tgf_list_add(inScene->protos, tmp);\n\t} else {\n\t\tgf_list_add(inScene->unregistered_protos, tmp);\n\t}\n\treturn tmp;\n}\n\n#if 0\n/*used for memory handling of scene graph only. move proto from off-graph to in-graph or reverse*/\nGF_Err gf_sg_proto_set_in_graph(GF_Proto *proto, GF_SceneGraph *inScene, Bool set_in)\n{\n\tu32 i;\n\tGF_Proto *tmp;\n\tGF_List *removeFrom;\n\tGF_List *insertIn;\n\n\tif (set_in) {\n\t\tremoveFrom = proto->parent_graph->unregistered_protos;\n\t\tinsertIn = proto->parent_graph->protos;\n\t} else {\n\t\tinsertIn = proto->parent_graph->unregistered_protos;\n\t\tremoveFrom = proto->parent_graph->protos;\n\t}\n\n\tgf_list_del_item(removeFrom, proto);\n\n\ti=0;\n\twhile ((tmp = (GF_Proto*)gf_list_enum(insertIn, &i))) {\n\t\tif (tmp==proto) return GF_OK;\n\t\tif (!set_in) continue;\n\t\t/*if registering, make sure no other proto has the same ID/name*/\n\t\tif (tmp->ID==proto->ID) return GF_BAD_PARAM;\n\t\tif (!stricmp(tmp->Name, proto->Name)) return GF_BAD_PARAM;\n\t}\n\treturn gf_list_add(insertIn, proto);\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_sg_proto_del(GF_Proto *proto)\n{\n\ts32 i;\n\n\tif (!proto) return GF_OK;\n\ti = gf_list_del_item(proto->parent_graph->protos, proto);\n\tif (i<0) {\n\t\tgf_list_del_item(proto->parent_graph->unregistered_protos, proto);\n\t}\n\tif (proto->userpriv && proto->OnDelete) proto->OnDelete(proto->userpriv);\n\n\t/*first destroy the code*/\n\twhile (gf_list_count(proto->node_code)) {\n\t\tGF_Node *node = (GF_Node*)gf_list_get(proto->node_code, 0);\n\t\tgf_node_unregister(node, NULL);\n\t\tgf_list_rem(proto->node_code, 0);\n\t}\n\tgf_list_del(proto->node_code);\n\n\t/*delete interface*/\n\twhile (gf_list_count(proto->proto_fields)) {\n\t\tGF_ProtoFieldInterface *field = (GF_ProtoFieldInterface*)gf_list_get(proto->proto_fields, 0);\n\t\tif (field->userpriv && field->OnDelete) field->OnDelete(field->userpriv);\n\n\t\tif (field->FieldType==GF_SG_VRML_SFNODE) {\n\t\t\tif (field->def_sfnode_value)\n\t\t\t\tgf_node_unregister(field->def_sfnode_value, NULL);\n\t\t}\n\t\telse if (field->FieldType==GF_SG_VRML_MFNODE) {\n\t\t\tif (field->def_mfnode_value)\n\t\t\t\tgf_node_unregister_children(NULL, field->def_mfnode_value);\n\t\t}\n\t\telse if (field->def_value)\n\t\t\tgf_sg_vrml_field_pointer_del(field->def_value, field->FieldType);\n\n\t\tif (field->FieldName) gf_free(field->FieldName);\n\n\t\t/*QP fields are SF fields, we can safely gf_free() them*/\n\t\tif (field->qp_max_value) gf_free(field->qp_max_value);\n\t\tif (field->qp_min_value) gf_free(field->qp_min_value);\n\t\tgf_free(field);\n\t\tgf_list_rem(proto->proto_fields, 0);\n\t}\n\tgf_list_del(proto->proto_fields);\n\n\twhile (gf_list_count(proto->instances)) {\n\t\tGF_ProtoInstance *p = (GF_ProtoInstance *)gf_list_get(proto->instances, 0);\n\t\tgf_list_rem(proto->instances, 0);\n\t\tp->proto_interface = NULL;\n\t}\n\n\t/*delete sub graph*/\n\tgf_sg_del(proto->sub_graph);\n\n\n\tif (proto->Name) gf_free(proto->Name);\n\tgf_sg_mfurl_del(proto->ExternProto);\n\tgf_list_del(proto->instances);\n\tgf_free(proto);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_SceneGraph *gf_sg_proto_get_graph(GF_Proto *proto)\n{\n\treturn proto ? proto->sub_graph : NULL;\n}\n\n\n#if 0\nvoid gf_sg_proto_set_private(GF_Proto *p, void *ptr, void (*OnDelete)(void *ptr) )\n{\n\tif (p) {\n\t\tp->userpriv = ptr;\n\t\tp->OnDelete = OnDelete;\n\t}\n}\n\nvoid *gf_sg_proto_get_private(GF_Proto *p)\n{\n\treturn p ? p->userpriv : NULL;\n}\n#endif\n\nGF_EXPORT\nMFURL *gf_sg_proto_get_extern_url(GF_Proto *proto)\n{\n\treturn proto ? &proto->ExternProto : NULL;\n}\n\nGF_EXPORT\nGF_Err gf_sg_proto_add_node_code(GF_Proto *proto, GF_Node *pNode)\n{\n\tif (!proto) return GF_BAD_PARAM;\n\treturn gf_list_add(proto->node_code, pNode);\n}\n\nGF_EXPORT\nGF_ProtoFieldInterface *gf_sg_proto_field_find_by_name(GF_Proto *proto, char *fieldName)\n{\n\tGF_ProtoFieldInterface *ptr;\n\tu32 i=0;\n\twhile ((ptr = (GF_ProtoFieldInterface*)gf_list_enum(proto->proto_fields, &i))) {\n\t\tif (ptr->FieldName && !strcmp(ptr->FieldName, fieldName)) return ptr;\n\t}\n\treturn NULL;\n}\n\nGF_EXPORT\nGF_ProtoFieldInterface *gf_sg_proto_field_new(GF_Proto *proto, u32 fieldType, u32 eventType, char *fieldName)\n{\n\tGF_ProtoFieldInterface *tmp;\n\n\tif (fieldName) {\n\t\ttmp = gf_sg_proto_field_find_by_name(proto, fieldName);\n\t\tif (tmp) return NULL;\n\t}\n\tGF_SAFEALLOC(tmp, GF_ProtoFieldInterface)\n\tif (!tmp) return NULL;\n\n\ttmp->FieldType = fieldType;\n\ttmp->EventType = eventType;\n\n\t/*create container - can be NULL if SF node*/\n\tif ( fieldType == GF_SG_VRML_SFNODE) {\n\t\ttmp->def_sfnode_value = NULL;\n\t\ttmp->def_value = &tmp->def_sfnode_value;\n\t} else if ( fieldType == GF_SG_VRML_MFNODE) {\n\t\ttmp->def_mfnode_value = NULL;\n\t\ttmp->def_value = &tmp->def_mfnode_value;\n\t} else {\n\t\ttmp->def_value = gf_sg_vrml_field_pointer_new(fieldType);\n\t}\n\n\tif (fieldName) tmp->FieldName = gf_strdup(fieldName);\n\n\ttmp->ALL_index = gf_list_count(proto->proto_fields);\n\ttmp->OUT_index = tmp->DEF_index = tmp->IN_index = (u32) -1;\n\n\tswitch (eventType) {\n\tcase GF_SG_EVENT_EXPOSED_FIELD:\n\t\ttmp->IN_index = proto->NumIn;\n\t\tproto->NumIn ++;\n\t\ttmp->OUT_index = proto->NumOut;\n\t\tproto->NumOut ++;\n\tcase GF_SG_EVENT_FIELD:\n\t\ttmp->DEF_index = proto->NumDef;\n\t\tproto->NumDef ++;\n\t\tbreak;\n\tcase GF_SG_EVENT_IN:\n\t\ttmp->IN_index = proto->NumIn;\n\t\tproto->NumIn ++;\n\t\tbreak;\n\tcase GF_SG_EVENT_OUT:\n\t\ttmp->OUT_index = proto->NumOut;\n\t\tproto->NumOut ++;\n\t\tbreak;\n\t}\n\n\tgf_list_add(proto->proto_fields, tmp);\n\treturn tmp;\n}\n\n#if 0 //unused\nvoid gf_sg_proto_field_set_private(GF_ProtoFieldInterface *field, void *ptr, void (*OnDelete)(void *ptr))\n{\n\tif (field) {\n\t\tfield->userpriv = ptr;\n\t\tfield->OnDelete = OnDelete;\n\t}\n}\n\nvoid *gf_sg_proto_field_get_private(GF_ProtoFieldInterface *field)\n{\n\treturn field ? field->userpriv : NULL;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_sg_proto_field_get_field(GF_ProtoFieldInterface *field, GF_FieldInfo *info)\n{\n\tif (!field || !info) return GF_BAD_PARAM;\n\tmemset(info, 0, sizeof(GF_FieldInfo));\n\tinfo->fieldIndex = field->ALL_index;\n\tinfo->fieldType = field->FieldType;\n\tinfo->eventType = field->EventType;\n\tinfo->far_ptr = field->def_value;\n\tinfo->name = field->FieldName;\n\tinfo->NDTtype = NDT_SFWorldNode;\n\treturn GF_OK;\n}\n\nGF_Err gf_sg_proto_get_field(GF_Proto *proto, GF_Node *node, GF_FieldInfo *info)\n{\n\tGF_ProtoFieldInterface *proto_field;\n\tGF_ProtoInstance *inst;\n\tGF_ProtoField *field;\n\n\tif (!proto && !node) return GF_BAD_PARAM;\n\n\tif (proto) {\n\t\tproto_field = (GF_ProtoFieldInterface*)gf_list_get(proto->proto_fields, info->fieldIndex);\n\t\tif (!proto_field) return GF_BAD_PARAM;\n\n\t\tinfo->fieldType = proto_field->FieldType;\n\t\tinfo->eventType = proto_field->EventType;\n\t\tinfo->fieldIndex = proto_field->ALL_index;\n\t\tinfo->NDTtype = NDT_SFWorldNode;\n\t\tinfo->far_ptr = proto_field->def_value;\n\t\tinfo->name = proto_field->FieldName;\n\t\treturn GF_OK;\n\t}\n\n\t/*otherwise this is an instantiated proto*/\n\tif (node->sgprivate->tag!=TAG_ProtoNode) return GF_BAD_PARAM;\n\n\tinst = (GF_ProtoInstance *) node;\n\tfield = (GF_ProtoField*)gf_list_get(inst->fields, info->fieldIndex);\n\tif (!field) return GF_BAD_PARAM;\n\n\tinfo->fieldType = field->FieldType;\n\tinfo->eventType = field->EventType;\n\tinfo->on_event_in = field->on_event_in;\n\t/*SF/MF nodes need pointers to field object - cf gf_sg_proto_create_node*/\n\tif (gf_sg_vrml_get_sf_type(field->FieldType) == GF_SG_VRML_SFNODE) {\n\t\tinfo->far_ptr = &field->field_pointer;\n\t} else {\n\t\tinfo->far_ptr = field->field_pointer;\n\t}\n\t/*set the name - watchout for deletion case*/\n\tif (inst->proto_interface) {\n\t\tproto_field = (GF_ProtoFieldInterface*)gf_list_get(inst->proto_interface->proto_fields, info->fieldIndex);\n\t\tinfo->name = proto_field->FieldName;\n\t} else {\n\t\tinfo->name = \"ProtoFieldDeleted\";\n\t}\n\tinfo->NDTtype = NDT_SFWorldNode;\n\treturn GF_OK;\n}\n\ns32 gf_sg_proto_get_field_index_by_name(GF_Proto *proto, GF_Node *node, char *name)\n{\n\tu32 i;\n\tGF_Proto *__proto=NULL;\n\n\tif (!node && !proto) return -1;\n\tif (node && (node->sgprivate->tag!=TAG_ProtoNode)) return -1;\n\n\tif (proto)\n\t\t__proto = proto;\n\telse if (node)\n\t\t__proto = ((GF_ProtoInstance *) node)->proto_interface;\n\n\tif (!__proto ) return -1;\n\n\tfor (i=0; i<gf_list_count(__proto->proto_fields); i++) {\n\t\tGF_ProtoFieldInterface *proto_field = (GF_ProtoFieldInterface*)gf_list_get(__proto->proto_fields, i);\n\t\tif (proto_field->FieldName && !strcmp(proto_field->FieldName, name)) return i;\n\t}\n\treturn -1;\n}\n\n\nGF_Node *gf_vrml_node_clone(GF_SceneGraph *inScene, GF_Node *orig, GF_Node *cloned_parent, char *inst_id_suffix)\n{\n\tu32 i, count, id;\n\tchar *szNodeName;\n\tBool is_script;\n\tGF_Node *node, *child;\n\tGF_ChildNodeItem *list, *last;\n\tGF_Route *r1;\n#ifndef GPAC_DISABLE_BIFS\n\tvoid BIFS_SetupConditionalClone(GF_Node *node, GF_Node *orig);\n#endif\n\tGF_ProtoInstance *proto;\n\tGF_FieldInfo field_orig, field;\n\n\t/*this is not a mistake*/\n\tif (!orig) return NULL;\n\n\t/*check for DEF/USE*/\n\tszNodeName = NULL;\n\tif (!inst_id_suffix) id = 0;\n\telse {\n\t\tconst char *orig_name = gf_node_get_name_and_id(orig, &id);\n\t\t/*generate clone IDs based on original one*/\n\t\tif (inst_id_suffix[0] && id) {\n\t\t\tid = gf_sg_get_next_available_node_id(inScene);\n\t\t\tif (orig_name) {\n\t\t\t\tszNodeName = gf_malloc(sizeof(char)*(strlen(orig_name)+strlen(inst_id_suffix)+1));\n\t\t\t\tstrcpy(szNodeName, orig_name);\n\t\t\t\tstrcat(szNodeName, inst_id_suffix);\n\t\t\t}\n\t\t}\n\t\telse if (orig_name) szNodeName = gf_strdup(orig_name);\n\t}\n\n\tif (id) {\n\t\tnode = szNodeName ? gf_sg_find_node_by_name(inScene, szNodeName) : gf_sg_find_node(inScene, id);\n\t\t/*node already created, USE*/\n\t\tif (node) {\n\t\t\tgf_node_register(node, cloned_parent);\n\t\t\tif (szNodeName) gf_free(szNodeName);\n\t\t\treturn node;\n\t\t}\n\t}\n\t/*create a node*/\n\tif (orig->sgprivate->tag == TAG_ProtoNode) {\n\t\tGF_Proto *proto_node = ((GF_ProtoInstance *)orig)->proto_interface;\n\t\t/*create the instance but don't load the code -c we MUST wait for ISed routes to be cloned before*/\n\t\tnode = gf_sg_proto_create_node(inScene, proto_node, (GF_ProtoInstance *) orig);\n\t} else {\n\t\tnode = gf_node_new(inScene, orig->sgprivate->tag);\n\t}\n\n\tcount = gf_node_get_field_count(orig);\n\n\tis_script = 0;\n\tif (orig->sgprivate->tag==TAG_MPEG4_Script) is_script = 1;\n#ifndef GPAC_DISABLE_X3D\n\telse if (orig->sgprivate->tag==TAG_X3D_Script) is_script = 1;\n#endif\n\n\tif (is_script) gf_sg_script_prepare_clone(node, orig);\n\n\n\t/*register node*/\n\tif (id) {\n\t\tgf_node_set_id(node, id, szNodeName);\n\t\tif (szNodeName) gf_free(szNodeName);\n\t}\n\tgf_node_register(node, cloned_parent);\n\n\t/*copy each field*/\n\tfor (i=0; i<count; i++) {\n\t\tgf_node_get_field(orig, i, &field_orig);\n\n\t\t/*get target ptr*/\n\t\tgf_node_get_field(node, i, &field);\n\n\t\tassert(field.eventType==field_orig.eventType);\n\t\tassert(field.fieldType==field_orig.fieldType);\n\n\t\t/*duplicate it*/\n\t\tswitch (field.fieldType) {\n\t\tcase GF_SG_VRML_SFNODE:\n\t\t\tchild = gf_node_clone(inScene, (* ((GF_Node **) field_orig.far_ptr)), node, inst_id_suffix, 1);\n\t\t\t*((GF_Node **) field.far_ptr) = child;\n\t\t\tbreak;\n\t\tcase GF_SG_VRML_MFNODE:\n\t\t\tlast = NULL;\n\t\t\tlist = *( (GF_ChildNodeItem **) field_orig.far_ptr);\n\t\t\twhile (list) {\n\t\t\t\tchild = gf_node_clone(inScene, list->node, node, inst_id_suffix, 1);\n\t\t\t\tgf_node_list_add_child_last((GF_ChildNodeItem **) field.far_ptr, child, &last);\n\t\t\t\tlist = list->next;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_SG_VRML_SFTIME:\n\t\t\tgf_sg_vrml_field_copy(field.far_ptr, field_orig.far_ptr, field.fieldType);\n\t\t\tif (!inScene->GetSceneTime) break;\n\t\t\t/*update SFTime that must be updated when cloning the node*/\n\t\t\tif (orig->sgprivate->tag == TAG_ProtoNode) {\n\t\t\t\tif (gf_sg_proto_field_is_sftime_offset(orig, &field_orig))\n\t\t\t\t\t*((SFTime *)field.far_ptr) += inScene->GetSceneTime(inScene->userpriv);\n\t\t\t} else if (!stricmp(field.name, \"startTime\") || !stricmp(field_orig.name, \"startTime\") ) {\n\t\t\t\t*((SFTime *)field.far_ptr) += inScene->GetSceneTime(inScene->userpriv);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgf_sg_vrml_field_clone(field.far_ptr, field_orig.far_ptr, field.fieldType, inScene);\n\t\t\tbreak;\n\t\t}\n\t}\n\n#ifndef GPAC_DISABLE_BIFS\n\t/*init node before creating ISed routes so the eventIn handler are in place*/\n\tif (node->sgprivate->tag == TAG_MPEG4_Conditional)\n\t\tBIFS_SetupConditionalClone(node, orig);\n\telse\n#endif\n\t\tif (node->sgprivate->tag != TAG_ProtoNode) gf_node_init(node);\n\n\tif (!inScene->pOwningProto) return node;\n\tproto = inScene->pOwningProto;\n\n\t/*create Routes for ISed fields*/\n\ti=0;\n\twhile ((r1 = (GF_Route*)gf_list_enum(proto->proto_interface->sub_graph->Routes, &i))) {\n\t\tGF_Route *r2 = NULL;\n\t\t/*locate only ISed routes*/\n\t\tif (!r1->IS_route) continue;\n\n\t\t/*eventOut*/\n\t\tif (r1->FromNode == orig) {\n\t\t\tr2 = gf_sg_route_new(inScene, node, r1->FromField.fieldIndex, (GF_Node *) proto, r1->ToField.fieldIndex);\n\t\t\tr2->IS_route = 1;\n\t\t}\n\t\t/*eventIn or exposedField*/\n\t\telse if (r1->ToNode == orig) {\n\t\t\tr2 = gf_sg_route_new(inScene, (GF_Node *) proto, r1->FromField.fieldIndex, node, r1->ToField.fieldIndex);\n\t\t\tr2->IS_route = 1;\n\n\t\t\t/*activate the route now so that proto instanciation works properly, otherwise we may load scripts with wrong field values\n\t\t\tNote: we don't activate eventOut routes upon instanciation since no event has been triggered yet*/\n\t\t\tgf_sg_route_activate(r2);\n\t\t}\n\t}\n\n\t/*remember scripts*/\n\tif (is_script) gf_list_add(proto->scripts_to_load, node);\n\n\t/*this is a proto node, init our internal stuff*/\n\tif (node->sgprivate->tag == TAG_ProtoNode) {\n\t\tnode->sgprivate->UserCallback = NULL;\n\t\tnode->sgprivate->UserPrivate = NULL;\n\t\t/*NO RENDER, this is filtered at the generic gf_node_traverse to cope with instanciations and externProto*/\n\t\t/*load code*/\n\t\tgf_sg_proto_instantiate((GF_ProtoInstance *)node);\n\t}\n\treturn node;\n}\n\nGF_Err gf_sg_proto_get_field_ind_static(GF_Node *Node, u32 inField, u8 IndexMode, u32 *allField)\n{\n\treturn gf_sg_proto_get_field_index((GF_ProtoInstance *)Node, inField, IndexMode, allField);\n}\n\n\nstatic Bool is_same_proto(GF_Proto *extern_proto, GF_Proto *proto)\n{\n\tu32 i, count;\n\t/*VRML allows external protos to have more fields defined that the externProto referencing them*/\n\tif (gf_list_count(extern_proto->proto_fields) > gf_list_count(proto->proto_fields)) return 0;\n\tcount = gf_list_count(extern_proto->proto_fields);\n\tfor (i=0; i<count; i++) {\n\t\tGF_ProtoFieldInterface *pf1 = (GF_ProtoFieldInterface*)gf_list_get(extern_proto->proto_fields, i);\n\t\tGF_ProtoFieldInterface *pf2 = (GF_ProtoFieldInterface*)gf_list_get(proto->proto_fields, i);\n\t\tif (pf1->EventType != pf2->EventType) return 0;\n\t\tif (pf1->FieldType != pf2->FieldType) return 0;\n\t\t/*note we don't check names since we're not sure both protos use name coding (MPEG4 only)*/\n\t}\n\treturn 1;\n}\n\nstatic GF_Proto *find_proto_by_interface(GF_SceneGraph *sg, GF_Proto *extern_proto)\n{\n\tGF_Proto *proto;\n\tu32 i, count;\n\n\tassert(sg);\n\n\t/*browse all top-level */\n\ti=0;\n\twhile ((proto = (GF_Proto*)gf_list_enum(sg->protos, &i))) {\n\t\tif (is_same_proto(proto, extern_proto)) return proto;\n\t}\n\t/*browse all top-level unregistered in reverse order*/\n\tcount = gf_list_count(sg->unregistered_protos);\n\tfor (i=count; i>0; i--) {\n\t\tproto = (GF_Proto*)gf_list_get(sg->unregistered_protos, i-1);\n\t\tif (is_same_proto(proto, extern_proto)) return proto;\n\t}\n\treturn NULL;\n}\n\n/*performs common initialization of routes ISed fields and protos once everything is loaded*/\nvoid gf_sg_proto_instantiate(GF_ProtoInstance *proto_node)\n{\n\tGF_Node *node, *orig;\n\tGF_Route *route, *r2;\n\tu32 i, count;\n\tGF_Proto *proto = proto_node->proto_interface;\n\tGF_Proto *owner = proto;\n\n\tif (!proto) return;\n\n\tif (owner->ExternProto.count) {\n\t\tGF_ProtoFieldInterface *pfi;\n\t\tGF_SceneGraph *extern_lib;\n\t\tif (!owner->parent_graph->GetExternProtoLib) return;\n\t\textern_lib = owner->parent_graph->GetExternProtoLib(proto->parent_graph->userpriv, &owner->ExternProto);\n\t\tif (!extern_lib) return;\n\n\t\t/*this is an hardcoded proto - all routes, node modifications and co are handled internally*/\n\t\tif (PTR_TO_U_CAST extern_lib == GF_SG_INTERNAL_PROTO) {\n\t\t\tproto_node->sgprivate->flags |= GF_SG_NODE_DIRTY;\n\t\t\t// take default values\n\t\t\tcount = gf_list_count(owner->proto_fields);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_ProtoField *pf = (GF_ProtoField *)gf_list_get(proto_node->fields, i);\n\t\t\t\tif (!pf->has_been_accessed) {\n\t\t\t\t\tpfi = (GF_ProtoFieldInterface*)gf_list_get(proto->proto_fields, i);\n\t\t\t\t\tgf_sg_vrml_field_copy(pf->field_pointer, pfi->def_value, pfi->FieldType);\n\t\t\t\t}\n\t\t\t}\n\t\t\towner->parent_graph->NodeCallback(owner->parent_graph->userpriv, GF_SG_CALLBACK_INIT, (GF_Node *) proto_node, NULL);\n\t\t\tproto_node->flags |= GF_SG_PROTO_LOADED | GF_SG_PROTO_HARDCODED;\n\t\t\treturn;\n\t\t}\n\t\t/*not loaded yet*/\n\t\tif (!gf_list_count(extern_lib->protos)) return;\n\n\t\t/*overwrite this proto by external one*/\n\t\tproto = NULL;\n\t\t/*start with proto v2 addressing*/\n\t\tif (owner->ExternProto.vals[0].url) {\n\t\t\tu32 ID = (u32) -1;\n\t\t\tchar *szName = strrchr(owner->ExternProto.vals[0].url, '#');\n\t\t\tif (szName) {\n\t\t\t\tszName++;\n\t\t\t\tif (sscanf(szName, \"%u\", &ID)) ID = (u32) -1;\n\t\t\t}\n\t\t\t/*if we have the proto name, use it*/\n\t\t\tif (owner->Name) szName = owner->Name;\n\t\t\tproto = gf_sg_find_proto(extern_lib, ID, szName);\n\t\t}\n\t\tif (!proto) proto = gf_sg_find_proto(extern_lib, owner->ID, owner->Name);\n\t\tif (!proto) proto = find_proto_by_interface(extern_lib, owner);\n\n\t\tif (proto && !is_same_proto(owner, proto)) {\n\t\t\tproto = NULL;\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_SCENE, (\"[Scenegraph] fields/types mismatch for PROTO %s - skipping instantiation\\n\", owner->Name));\n\t\t}\n\t\t/*couldn't find proto in the given lib, consider the proto as loaded (give up)*/\n\t\tif (!proto) {\n\t\t\tproto_node->flags |= GF_SG_PROTO_LOADED;\n\t\t\treturn;\n\t\t}\n\t\t/*cf VRML: once an external proto is loaded, copy back the default field values of the external proto*/\n\t\tcount = gf_list_count(owner->proto_fields);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_ProtoField *pf = (GF_ProtoField *)gf_list_get(proto_node->fields, i);\n\t\t\tif (!pf->has_been_accessed) {\n\t\t\t\tpfi = (GF_ProtoFieldInterface*)gf_list_get(proto->proto_fields, i);\n\t\t\t\tgf_sg_vrml_field_copy(pf->field_pointer, pfi->def_value, pfi->FieldType);\n\t\t\t} else {\n\t\t\t\t//pfi = (GF_ProtoFieldInterface*)gf_list_get(proto->proto_fields, i);\n\t\t\t}\n\t\t}\n\n\t\t/*unregister from prev and reg with real proto*/\n\t\tgf_list_del_item(owner->instances, proto_node);\n\t\tgf_list_add(proto->instances, proto_node);\n\t}\n\n\t/*OVERRIDE the proto instance (eg don't instantiate an empty externproto...)*/\n\tproto_node->proto_interface = proto;\n\n\t/*clone all nodes*/\n\ti=0;\n\twhile ((orig = (GF_Node*)gf_list_enum(proto->node_code, &i))) {\n\t\t/*node is cloned in the new scenegraph and its parent is NULL */\n\t\tnode = gf_node_clone(proto_node->sgprivate->scenegraph, orig, NULL, \"\", 1);\n\t\tassert(node);\n\n\t\t/*assign first rendering node*/\n\t\tif (i==1) proto_node->RenderingNode = node;\n\t\tgf_list_add(proto_node->node_code, node);\n\t}\n\n\t/*instantiate routes (not ISed ones)*/\n\ti=0;\n\twhile ((route = (GF_Route*)gf_list_enum(proto->sub_graph->Routes, &i))) {\n\t\tif (route->IS_route) continue;\n\n\t\tr2 = gf_sg_route_new(proto_node->sgprivate->scenegraph,\n\t\t                     gf_sg_find_node(proto_node->sgprivate->scenegraph, gf_node_get_id(route->FromNode) ),\n\t\t                     route->FromField.fieldIndex,\n\t\t                     gf_sg_find_node(proto_node->sgprivate->scenegraph, gf_node_get_id(route->ToNode) ),\n\t\t                     route->ToField.fieldIndex);\n\n\t\tif (route->ID) gf_sg_route_set_id(r2, route->ID);\n\t\tif (route->name) gf_sg_route_set_name(r2, route->name);\n\t}\n\t/*activate all ISed fields so that inits on events is properly done*/\n\ti=0;\n\twhile ((route = (GF_Route*)gf_list_enum(proto_node->sgprivate->scenegraph->Routes, &i))) {\n\t\tif (!route->IS_route) continue;\n\t\t/*do not activate eventIn to eventIn routes*/\n\t\tif (route->is_setup) {\n\t\t\tif ((route->ToField.eventType == GF_SG_EVENT_IN) && (route->FromField.eventType == GF_SG_EVENT_IN) ) continue;\n\t\t}\n\t\tgf_sg_route_activate(route);\n\t}\n\t/*and load all scripts (this must be done once all fields are routed for the \"initialize\" method)*/\n\twhile (gf_list_count(proto_node->scripts_to_load)) {\n\t\tnode = (GF_Node*)gf_list_get(proto_node->scripts_to_load, 0);\n\t\tgf_list_rem(proto_node->scripts_to_load, 0);\n\t\tgf_sg_script_load(node);\n\t}\n\t/*re-activate all ISed fields pointing to scripts once scripts are loaded (eventIns)*/\n\ti=0;\n\twhile ((route = (GF_Route*)gf_list_enum(proto_node->sgprivate->scenegraph->Routes, &i))) {\n\t\tif (!route->IS_route || !route->ToNode) continue;\n\t\t/*\t\tassert(route->is_setup);\n\t\t\t\tif ((route->FromField.eventType == GF_SG_EVENT_OUT) || (route->FromField.eventType == GF_SG_EVENT_IN) ) continue;\n\t\t*/\n\n\t\tif (route->is_setup) {\n\t\t\tif ((route->ToField.eventType == GF_SG_EVENT_IN) && (route->FromField.eventType == GF_SG_EVENT_IN) ) continue;\n\t\t}\n\n\t\tif (route->ToNode->sgprivate->tag==TAG_MPEG4_Script)\n\t\t\tgf_sg_route_activate(route);\n#ifndef GPAC_DISABLE_X3D\n\t\telse if (route->ToNode->sgprivate->tag==TAG_X3D_Script)\n\t\t\tgf_sg_route_activate(route);\n#endif\n\t}\n\n#if 0\n\t/*reset all regular route activation times - if we don't do so, creating a proto by script and then manipulating one of its\n\tISed field may not trigger the proper routes*/\n\ti=0;\n\twhile ((route = (GF_Route*)gf_list_enum(proto_node->sgprivate->scenegraph->Routes, &i))) {\n\t\tif (!route->IS_route) {\n\t\t\troute->lastActivateTime = 0;\n\t\t}\n\t}\n#endif\n\tproto_node->flags |= GF_SG_PROTO_LOADED;\n}\n\nvoid gf_sg_proto_mark_field_loaded(GF_Node *proto_inst, GF_FieldInfo *info)\n{\n\tGF_ProtoInstance *inst= (proto_inst->sgprivate->tag==TAG_ProtoNode) ? (GF_ProtoInstance *)proto_inst : NULL;\n\tGF_ProtoField *pf = inst ? (GF_ProtoField *)gf_list_get(inst->fields, info->fieldIndex) : NULL;\n\tif (pf) pf->has_been_accessed = 1;\n}\n\nGF_Node *gf_sg_proto_create_node(GF_SceneGraph *scene, GF_Proto *proto, GF_ProtoInstance *from_inst)\n{\n\tu32 i;\n\tGF_ProtoField *inst, *from_field;\n\tGF_ProtoFieldInterface *field;\n\tGF_ProtoInstance *proto_node;\n\tif (!proto) return NULL;\n\t\n\tGF_SAFEALLOC(proto_node, GF_ProtoInstance)\n\tif (!proto_node) return NULL;\n\n\tgf_node_setup((GF_Node *)proto_node, TAG_ProtoNode);\n\tproto_node->node_code = gf_list_new();\n\tproto_node->fields = gf_list_new();\n\tproto_node->scripts_to_load = gf_list_new();\n\n\tproto_node->proto_interface = proto;\n\tgf_list_add(proto->instances, proto_node);\n\n\tproto_node->proto_name = gf_strdup(proto->Name);\n\n\t/*create the namespace*/\n\tproto_node->sgprivate->scenegraph = gf_sg_new_subscene(scene);\n\t/*set this proto as owner of the new graph*/\n\tproto_node->sgprivate->scenegraph->pOwningProto = proto_node;\n\n\t/*instantiate fields*/\n\ti=0;\n\twhile ((field = (GF_ProtoFieldInterface*)gf_list_enum(proto->proto_fields, &i))) {\n\t\tGF_SAFEALLOC(inst, GF_ProtoField);\n\t\tif (!inst) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_SCENE, (\"[VRML] Failed to allocate proto instance field\\n]\"));\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tinst->EventType = field->EventType;\n\t\tinst->FieldType = field->FieldType;\n\n\t\t/*this is OK to call on GF_Node (returns NULL) and MFNode (returns gf_list_new() )*/\n\t\tinst->field_pointer = gf_sg_vrml_field_pointer_new(inst->FieldType);\n\n\t\t/*regular field, duplicate from default value or instantiated one if specified (since\n\t\ta proto may be partially instantiated when used in another proto)*/\n\t\tif (gf_sg_vrml_get_sf_type(inst->FieldType) != GF_SG_VRML_SFNODE) {\n\t\t\tif (from_inst) {\n\t\t\t\tfrom_field = (GF_ProtoField *)gf_list_get(from_inst->fields, i-1);\n\t\t\t\tgf_sg_vrml_field_copy(inst->field_pointer, from_field->field_pointer, inst->FieldType);\n\t\t\t\tinst->has_been_accessed = from_field->has_been_accessed;\n\t\t\t} else {\n\t\t\t\tgf_sg_vrml_field_copy(inst->field_pointer, field->def_value, inst->FieldType);\n\t\t\t}\n\t\t}\n\t\t/*No default values for SFNodes as interfaces ...*/\n\t\tgf_list_add(proto_node->fields, inst);\n\t}\n\treturn (GF_Node *) proto_node;\n}\n\n\nGF_EXPORT\nGF_Node *gf_sg_proto_create_instance(GF_SceneGraph *sg, GF_Proto *proto)\n{\n\treturn gf_sg_proto_create_node(sg, proto, NULL);\n}\n\nGF_EXPORT\nGF_Err gf_sg_proto_load_code(GF_Node *node)\n{\n\tGF_ProtoInstance *inst;\n\tif (node->sgprivate->tag != TAG_ProtoNode) return GF_BAD_PARAM;\n\tinst = (GF_ProtoInstance *) node;\n\tif (!inst->proto_interface) return GF_BAD_PARAM;\n\tif (inst->flags & GF_SG_PROTO_LOADED) return GF_OK;\n\tgf_sg_proto_instantiate(inst);\n\treturn GF_OK;\n}\n\n\nu32 gf_sg_proto_get_num_fields(GF_Node *node, u8 code_mode)\n{\n\tGF_ProtoInstance *proto;\n\tif (!node) return 0;\n\n\tproto = (GF_ProtoInstance *)node;\n\t/*watchout for deletion case*/\n\tswitch (code_mode) {\n\tcase GF_SG_FIELD_CODING_IN:\n\t\treturn proto->proto_interface ? proto->proto_interface->NumIn : 0;\n\tcase GF_SG_FIELD_CODING_OUT:\n\t\treturn proto->proto_interface ? proto->proto_interface->NumOut : 0;\n\tcase GF_SG_FIELD_CODING_DEF:\n\t\treturn proto->proto_interface ? proto->proto_interface->NumDef : 0;\n\tcase GF_SG_FIELD_CODING_ALL:\n\t\treturn gf_list_count(proto->proto_interface ? proto->proto_interface->proto_fields : proto->fields);\n\t/*BIFS-ANIM not supported*/\n\tcase GF_SG_FIELD_CODING_DYN:\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n\nvoid gf_sg_proto_del_instance(GF_ProtoInstance *inst)\n{\n\tGF_SceneGraph *sg;\n\n\twhile (gf_list_count(inst->fields)) {\n\t\tGF_ProtoField *field = (GF_ProtoField *)gf_list_get(inst->fields, 0);\n\t\tgf_list_rem(inst->fields, 0);\n\n\t\tif (field->field_pointer) {\n\t\t\t/*regular type*/\n\t\t\tif ( (field->FieldType!=GF_SG_VRML_SFNODE) && (field->FieldType!=GF_SG_VRML_MFNODE)) {\n\t\t\t\tgf_sg_vrml_field_pointer_del(field->field_pointer, field->FieldType);\n\t\t\t}\n\t\t\t/*node types: delete instances*/\n\t\t\telse {\n\t\t\t\tif (field->FieldType == GF_SG_VRML_SFNODE) {\n\t\t\t\t\tgf_node_unregister((GF_Node *) field->field_pointer, (GF_Node *) inst);\n\t\t\t\t} else {\n\t\t\t\t\tGF_ChildNodeItem *list = (GF_ChildNodeItem *)field->field_pointer;\n\t\t\t\t\twhile (list) {\n\t\t\t\t\t\tGF_ChildNodeItem *cur = list;\n\t\t\t\t\t\tgf_node_unregister(list->node, (GF_Node *) inst);\n\t\t\t\t\t\tlist = list->next;\n\t\t\t\t\t\tgf_free(cur);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tgf_free(field);\n\t}\n\tgf_list_del(inst->fields);\n\n\t/*destroy the code*/\n\twhile (gf_list_count(inst->node_code)) {\n\t\tGF_Node *node = (GF_Node*)gf_list_get(inst->node_code, 0);\n\t\tgf_node_unregister(node, (GF_Node*) inst);\n\t\tgf_list_rem(inst->node_code, 0);\n\t}\n\n\tsg = inst->sgprivate->scenegraph;\n\n\t/*reset the scene graph before destroying the node code list, as unregistering nodes\n\tnot destroyed in the previous phase (eg, cyclic references such as script and co) will\n\trefer to the node-code list*/\n\tgf_sg_reset(sg);\n\tsg->pOwningProto = NULL;\n\n\tgf_free((char *) inst->proto_name);\n\tgf_list_del(inst->node_code);\n\tassert(!gf_list_count(inst->scripts_to_load));\n\tgf_list_del(inst->scripts_to_load);\n\n\tif (inst->proto_interface && inst->proto_interface->instances) gf_list_del_item(inst->proto_interface->instances, inst);\n\n\tgf_node_free((GF_Node *)inst);\n\tgf_sg_del(sg);\n}\n\n/*Note on ISed fields: we cannot support fan-in on proto, eg we assume only one eventIn field can receive events\nthus situations where a proto receives eventIn from outside and the node with ISed eventIn receives event\nfrom inside the proto are undefined*/\nGF_EXPORT\nGF_Err gf_sg_proto_field_set_ised(GF_Proto *proto, u32 protoFieldIndex, GF_Node *node, u32 nodeFieldIndex)\n{\n\tGF_Err e;\n\tGF_Route *r;\n\tGF_FieldInfo field, nodeField;\n\tfield.fieldIndex = protoFieldIndex;\n\te = gf_sg_proto_get_field(proto, NULL, &field);\n\tif (e) return e;\n\te = gf_node_get_field(node, nodeFieldIndex, &nodeField);\n\tif (e) return e;\n\tif (field.fieldType != nodeField.fieldType) {\n\t\tif ((gf_sg_vrml_get_sf_type(field.fieldType)==GF_SG_VRML_SFSTRING) && (gf_sg_vrml_get_sf_type(nodeField.fieldType) == GF_SG_VRML_SFURL)) {\n//\t\t\te = GF_OK;\n\t\t} else if ((gf_sg_vrml_get_sf_type(field.fieldType)==GF_SG_VRML_SFURL) && (gf_sg_vrml_get_sf_type(nodeField.fieldType) == GF_SG_VRML_SFSTRING)) {\n//\t\t\te = GF_OK;\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_SCENE, (\"[VRML] error in IS - node field %s.%s - inType %s - outType %s\\n\", gf_node_get_class_name(node) , nodeField.name, gf_sg_vrml_get_field_type_name(field.fieldType), gf_sg_vrml_get_field_type_name(nodeField.fieldType)));\n\t\t\treturn GF_SG_INVALID_PROTO;\n\t\t}\n\t}\n\n\tGF_SAFEALLOC(r, GF_Route)\n\tif (!r) return GF_OUT_OF_MEM;\n\tr->IS_route = 1;\n\n\tif (nodeField.eventType==GF_SG_EVENT_OUT) {\n\t\tr->FromField.fieldIndex = nodeFieldIndex;\n\t\tr->FromNode = node;\n\t\tr->ToField.fieldIndex = protoFieldIndex;\n\t\tr->ToNode = NULL;\n\t\tif (!node->sgprivate->interact) {\n\t\t\tGF_SAFEALLOC(node->sgprivate->interact, struct _node_interactive_ext);\n\t\t\tif (!node->sgprivate->interact) {\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t}\n\t\tif (!node->sgprivate->interact->routes) node->sgprivate->interact->routes = gf_list_new();\n\t\tgf_list_add(node->sgprivate->interact->routes, r);\n\t} else {\n\t\tswitch (field.eventType) {\n\t\tcase GF_SG_EVENT_FIELD:\n\t\tcase GF_SG_EVENT_EXPOSED_FIELD:\n\t\tcase GF_SG_EVENT_IN:\n\t\t\tr->FromField.fieldIndex = protoFieldIndex;\n\t\t\tr->FromNode = NULL;\n\t\t\tr->ToField.fieldIndex = nodeFieldIndex;\n\t\t\tr->ToNode = node;\n\t\t\t/*create an ISed route for the eventOut part of the exposedFIeld*/\n\t\t\tif ((field.eventType==GF_SG_EVENT_EXPOSED_FIELD) && (nodeField.eventType==GF_SG_EVENT_EXPOSED_FIELD)) {\n\t\t\t\tGF_Route *r2;\n\t\t\t\tGF_SAFEALLOC(r2, GF_Route);\n\t\t\t\tif (!r2) {\n\t\t\t\t\tgf_free(r);\n\t\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t\t}\n\t\t\t\tr2->IS_route = 1;\n\t\t\t\tr2->FromField.fieldIndex = nodeFieldIndex;\n\t\t\t\tr2->FromNode = node;\n\t\t\t\tr2->ToField.fieldIndex = protoFieldIndex;\n\t\t\t\tr2->ToNode = NULL;\n\t\t\t\tr2->graph =  proto->sub_graph;\n\t\t\t\tif (!node->sgprivate->interact) {\n\t\t\t\t\tGF_SAFEALLOC(node->sgprivate->interact, struct _node_interactive_ext);\n\t\t\t\t\tif (!node->sgprivate->interact) return GF_OUT_OF_MEM;\n\t\t\t\t}\n\t\t\t\tif (!node->sgprivate->interact->routes) node->sgprivate->interact->routes = gf_list_new();\n\t\t\t\tgf_list_add(node->sgprivate->interact->routes, r2);\n\t\t\t\tgf_list_add(proto->sub_graph->Routes, r2);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_SG_EVENT_OUT:\n\t\t\tr->FromField.fieldIndex = nodeFieldIndex;\n\t\t\tr->FromNode = node;\n\t\t\tr->ToField.fieldIndex = protoFieldIndex;\n\t\t\tr->ToNode = NULL;\n\t\t\tif (!node->sgprivate->interact) {\n\t\t\t\tGF_SAFEALLOC(node->sgprivate->interact, struct _node_interactive_ext);\n\t\t\t\tif (!node->sgprivate->interact) return GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tif (!node->sgprivate->interact->routes) node->sgprivate->interact->routes = gf_list_new();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgf_free(r);\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t}\n\tr->graph = proto->sub_graph;\n\treturn gf_list_add(proto->sub_graph->Routes, r);\n}\n\nGF_EXPORT\nGF_Err gf_sg_proto_instance_set_ised(GF_Node *protoinst, u32 protoFieldIndex, GF_Node *node, u32 nodeFieldIndex)\n{\n\tGF_Err e;\n\tGF_Route *r;\n\tGF_FieldInfo field, nodeField;\n\tif (!protoinst) return GF_BAD_PARAM;\n\tif (protoinst->sgprivate->tag != TAG_ProtoNode) return GF_BAD_PARAM;\n\n\te = gf_node_get_field(protoinst, protoFieldIndex, &field);\n\tif (e) return e;\n\te = gf_node_get_field(node, nodeFieldIndex, &nodeField);\n\tif (e) return e;\n\tif (field.fieldType != nodeField.fieldType) {\n\t\tif ((gf_sg_vrml_get_sf_type(field.fieldType)==GF_SG_VRML_SFSTRING) && (gf_sg_vrml_get_sf_type(nodeField.fieldType) == GF_SG_VRML_SFURL)) {\n//\t\t\te = GF_OK;\n\t\t} else if ((gf_sg_vrml_get_sf_type(field.fieldType)==GF_SG_VRML_SFURL) && (gf_sg_vrml_get_sf_type(nodeField.fieldType) == GF_SG_VRML_SFSTRING)) {\n//\t\t\te = GF_OK;\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_SCENE, (\"[VRML] error in IS - node field %s.%s - inType %s - outType %s\\n\", gf_node_get_class_name(node) , nodeField.name, gf_sg_vrml_get_field_type_name(field.fieldType), gf_sg_vrml_get_field_type_name(nodeField.fieldType)));\n\t\t\treturn GF_SG_INVALID_PROTO;\n\t\t}\n\t}\n\n\tGF_SAFEALLOC(r, GF_Route)\n\tif (!r) return GF_OUT_OF_MEM;\n\tr->IS_route = 1;\n\n\tif (nodeField.eventType==GF_SG_EVENT_OUT) {\n\t\tr->FromField.fieldIndex = nodeFieldIndex;\n\t\tr->FromNode = node;\n\t\tr->ToField.fieldIndex = protoFieldIndex;\n\t\tr->ToNode = protoinst;\n\t\tif (!node->sgprivate->interact) {\n\t\t\tGF_SAFEALLOC(node->sgprivate->interact, struct _node_interactive_ext);\n\t\t\tif (!node->sgprivate->interact) return GF_OUT_OF_MEM;\n\t\t}\n\t\tif (!node->sgprivate->interact->routes) node->sgprivate->interact->routes = gf_list_new();\n\t\tgf_list_add(node->sgprivate->interact->routes, r);\n\t} else {\n\t\tswitch (field.eventType) {\n\t\tcase GF_SG_EVENT_FIELD:\n\t\tcase GF_SG_EVENT_EXPOSED_FIELD:\n\t\tcase GF_SG_EVENT_IN:\n\t\t\tr->FromField.fieldIndex = protoFieldIndex;\n\t\t\tr->FromNode = protoinst;\n\t\t\tr->ToField.fieldIndex = nodeFieldIndex;\n\t\t\tr->ToNode = node;\n\n\t\t\t/*create an ISed route for the eventOut part of the exposedFIeld*/\n\t\t\tif ((field.eventType==GF_SG_EVENT_EXPOSED_FIELD) && (nodeField.eventType==GF_SG_EVENT_EXPOSED_FIELD)) {\n\t\t\t\tGF_Route *r2;\n\t\t\t\tGF_SAFEALLOC(r2, GF_Route);\n\t\t\t\tif (!r2) {\n\t\t\t\t\tgf_free(r);\n\t\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t\t}\n\t\t\t\tr2->IS_route = 1;\n\t\t\t\tr2->FromField.fieldIndex = nodeFieldIndex;\n\t\t\t\tr2->FromNode = node;\n\t\t\t\tr2->ToField.fieldIndex = protoFieldIndex;\n\t\t\t\tr2->ToNode = protoinst;\n\t\t\t\tr2->graph =  node->sgprivate->scenegraph;\n\t\t\t\tif (!node->sgprivate->interact) {\n\t\t\t\t\tGF_SAFEALLOC(node->sgprivate->interact, struct _node_interactive_ext);\n\t\t\t\t\tif (!node->sgprivate->interact) return GF_OUT_OF_MEM;\n\t\t\t\t}\n\t\t\t\tif (!node->sgprivate->interact->routes) node->sgprivate->interact->routes = gf_list_new();\n\t\t\t\tgf_list_add(node->sgprivate->interact->routes, r2);\n\t\t\t\tgf_list_add(r->graph->Routes, r2);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_SG_EVENT_OUT:\n\t\t\tr->FromField.fieldIndex = nodeFieldIndex;\n\t\t\tr->FromNode = node;\n\t\t\tr->ToField.fieldIndex = protoFieldIndex;\n\t\t\tr->ToNode = protoinst;\n\t\t\tif (!node->sgprivate->interact) {\n\t\t\t\tGF_SAFEALLOC(node->sgprivate->interact, struct _node_interactive_ext);\n\t\t\t\tif (!node->sgprivate->interact) return GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tif (!node->sgprivate->interact->routes) node->sgprivate->interact->routes = gf_list_new();\n\t\t\tgf_list_add(node->sgprivate->interact->routes, r);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgf_free(r);\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t}\n\tr->graph = node->sgprivate->scenegraph;\n\tgf_sg_route_activate(r);\n\treturn gf_list_add(r->graph->Routes, r);\n}\n\n\nGF_Err gf_bifs_proto_field_set_aq_info(GF_ProtoFieldInterface *field,\n                                       u32 QP_Type,\n                                       u32 hasMinMax,\n                                       u32 QPSFType,\n                                       void *qp_min_value,\n                                       void *qp_max_value,\n                                       u32 QP13_NumBits)\n{\n\n\tif (!field) return GF_BAD_PARAM;\n\tif (!QP_Type) return GF_OK;\n\tif (!gf_sg_vrml_is_sf_field(QPSFType)) return GF_BAD_PARAM;\n\n\tfield->QP_Type = QP_Type;\n\tfield->hasMinMax = hasMinMax;\n\tif (hasMinMax) {\n\t\tif (qp_min_value) {\n\t\t\tfield->qp_min_value = gf_sg_vrml_field_pointer_new(QPSFType);\n\t\t\tgf_sg_vrml_field_copy(field->qp_min_value, qp_min_value, QPSFType);\n\t\t}\n\t\tif (qp_max_value) {\n\t\t\tfield->qp_max_value = gf_sg_vrml_field_pointer_new(QPSFType);\n\t\t\tgf_sg_vrml_field_copy(field->qp_max_value, qp_max_value, QPSFType);\n\t\t}\n\t}\n\tfield->NumBits = QP13_NumBits;\n\treturn GF_OK;\n}\n\n\nGF_Err gf_sg_proto_get_field_index(GF_ProtoInstance *proto, u32 index, u32 code_mode, u32 *all_index)\n{\n\tu32 i;\n\tGF_ProtoFieldInterface *proto_field;\n\n\ti=0;\n\twhile ((proto_field = (GF_ProtoFieldInterface*)gf_list_enum(proto->proto_interface->proto_fields, &i))) {\n\t\tassert(proto_field);\n\t\tswitch (code_mode) {\n\t\tcase GF_SG_FIELD_CODING_IN:\n\t\t\tif (proto_field->IN_index == index) {\n\t\t\t\t*all_index = proto_field->ALL_index;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_SG_FIELD_CODING_OUT:\n\t\t\tif (proto_field->OUT_index == index) {\n\t\t\t\t*all_index = proto_field->ALL_index;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_SG_FIELD_CODING_DEF:\n\t\t\tif (proto_field->DEF_index == index) {\n\t\t\t\t*all_index = proto_field->ALL_index;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_SG_FIELD_CODING_ALL:\n\t\t\tif (proto_field->ALL_index == index) {\n\t\t\t\t*all_index = proto_field->ALL_index;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tbreak;\n\t\t/*BIFS-ANIM not supported*/\n\t\tcase GF_SG_FIELD_CODING_DYN:\n\t\tdefault:\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t}\n\treturn GF_BAD_PARAM;\n}\n\nGF_EXPORT\nu32 gf_sg_proto_get_field_count(GF_Proto *proto)\n{\n\tif (!proto) return 0;\n\treturn gf_list_count(proto->proto_fields);\n}\n\nGF_EXPORT\nGF_ProtoFieldInterface *gf_sg_proto_field_find(GF_Proto *proto, u32 fieldIndex)\n{\n\tif (!proto) return NULL;\n\treturn (GF_ProtoFieldInterface*)gf_list_get(proto->proto_fields, fieldIndex);\n}\n\nvoid gf_sg_proto_propagate_event(GF_Node *node, u32 fieldIndex, GF_Node *from_node)\n{\n\tu32 i;\n\tGF_Route *r;\n\tif (!node) return;\n\t/*propagation only for proto*/\n\tif (node->sgprivate->tag != TAG_ProtoNode) return;\n\t/*with ISed fields*/\n\tif (!node->sgprivate->interact || !node->sgprivate->interact->routes) return;\n\t/*we only need to propagate ISed for eventIn/exposedField. This means that if the event comes from\n\tthe same scene graph as the proto (eg from the proto code) we don't propagate the event*/\n\tif (from_node->sgprivate->scenegraph == node->sgprivate->scenegraph) return;\n\n\t/*for all ISed routes*/\n\ti=0;\n\twhile ((r = (GF_Route*)gf_list_enum(node->sgprivate->interact->routes, &i))) {\n\t\tif (!r->IS_route) continue;\n\t\t/*connecting from this node && field to a destination node other than the event source (this will break loops due to exposedFields)*/\n\t\tif ((r->FromNode == node) && (r->FromField.fieldIndex == fieldIndex) && (r->ToNode != from_node) ) {\n\t\t\tif (gf_sg_route_activate(r))\n\t\t\t\tgf_node_changed(r->ToNode, &r->ToField);\n\t\t}\n\t}\n}\n\n\nBool gf_sg_proto_get_aq_info(GF_Node *Node, u32 FieldIndex, u8 *QType, u8 *AType, Fixed *b_min, Fixed *b_max, u32 *QT13_bits)\n{\n\tGF_Proto *proto;\n\tu32 i;\n\tGF_ProtoFieldInterface *proto_field;\n\n\tproto = ((GF_ProtoInstance *)Node)->proto_interface;\n\n\ti=0;\n\twhile ((proto_field = (GF_ProtoFieldInterface*)gf_list_enum(proto->proto_fields, &i))) {\n\t\tif (proto_field->ALL_index!=FieldIndex) continue;\n\n\t\t*QType = proto_field->QP_Type;\n\t\t*AType = proto_field->Anim_Type;\n\t\t*b_min = FIX_MIN;\n\t\t*b_max = FIX_MAX;\n\n\t\tif (proto_field->hasMinMax) {\n\n\t\t\t/*translate our bounds*/\n\t\t\tswitch (gf_sg_vrml_get_sf_type(proto_field->FieldType)) {\n\t\t\tcase GF_SG_VRML_SFINT32:\n\t\t\t\t*b_min = (SFFloat) * ( (SFInt32 *) proto_field->qp_min_value);\n\t\t\t\t*b_max = (SFFloat) * ( (SFInt32 *) proto_field->qp_max_value);\n\t\t\t\tbreak;\n\t\t\t/*TO DO EVERYWHERE: check on field translation from double to float\n\t\t\tduring quant bounds*/\n\t\t\tcase GF_SG_VRML_SFTIME:\n\t\t\t\t*b_min = (SFFloat) * ( (SFTime *) proto_field->qp_min_value);\n\t\t\t\t*b_max = (SFFloat) * ( (SFTime *) proto_field->qp_max_value);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (proto_field->qp_min_value)\n\t\t\t\t\t*b_min = (SFFloat) * ( (SFFloat *) proto_field->qp_min_value);\n\t\t\t\tif (proto_field->qp_max_value)\n\t\t\t\t\t*b_max = (SFFloat) * ( (SFFloat *) proto_field->qp_max_value);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\t\t*QT13_bits = proto_field->NumBits;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n\nGF_EXPORT\nGF_Proto *gf_node_get_proto(GF_Node *node)\n{\n\tGF_ProtoInstance *inst;\n\tif (node->sgprivate->tag != TAG_ProtoNode) return NULL;\n\tinst = (GF_ProtoInstance *) node;\n\treturn inst->proto_interface;\n}\n\n/*returns the ID of the proto*/\nGF_EXPORT\nu32 gf_sg_proto_get_id(GF_Proto *proto)\n{\n\treturn proto ? proto->ID : 0;\n}\n\nGF_EXPORT\nconst char *gf_sg_proto_get_class_name(GF_Proto *proto)\n{\n\treturn (const char *) proto->Name;\n}\n\nu32 gf_sg_proto_get_root_tag(GF_Proto *proto)\n{\n\tGF_Node *n;\n\tif (!proto) return TAG_UndefinedNode;\n\tn = (GF_Node*)gf_list_get(proto->node_code, 0);\n\tif (!n) return TAG_UndefinedNode;\n\tif (n->sgprivate->tag == TAG_ProtoNode) return gf_sg_proto_get_root_tag(((GF_ProtoInstance *)n)->proto_interface);\n\treturn n->sgprivate->tag;\n}\n\nGF_EXPORT\nBool gf_sg_proto_field_is_sftime_offset(GF_Node *node, GF_FieldInfo *field)\n{\n\tu32 i;\n\tGF_Route *r;\n\tGF_ProtoInstance *inst;\n\tGF_FieldInfo inf;\n\tif (node->sgprivate->tag != TAG_ProtoNode) return 0;\n\tif (field->fieldType != GF_SG_VRML_SFTIME) return 0;\n\n\tinst = (GF_ProtoInstance *) node;\n\t/*check in interface if this is ISed */\n\ti=0;\n\twhile ((r = (GF_Route*)gf_list_enum(inst->proto_interface->sub_graph->Routes, &i))) {\n\t\tif (!r->IS_route) continue;\n\t\t/*only check eventIn/field/exposedField*/\n\t\tif (r->FromNode || (r->FromField.fieldIndex != field->fieldIndex)) continue;\n\n\t\tgf_node_get_field(r->ToNode, r->ToField.fieldIndex, &inf);\n\t\t/*IS to another proto*/\n\t\tif (r->ToNode->sgprivate->tag == TAG_ProtoNode) return gf_sg_proto_field_is_sftime_offset(r->ToNode, &inf);\n\t\t/*IS to a startTime/stopTime field*/\n\t\tif (!stricmp(inf.name, \"startTime\") || !stricmp(inf.name, \"stopTime\")) return 1;\n\t}\n\treturn 0;\n}\n\nGF_EXPORT\nGF_Err gf_node_proto_set_grouping(GF_Node *node)\n{\n\tif (!node || (node->sgprivate->tag!=TAG_ProtoNode)) return GF_BAD_PARAM;\n\t((GF_ProtoInstance *)node)->flags |= GF_SG_PROTO_IS_GROUPING;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nBool gf_node_proto_is_grouping(GF_Node *node)\n{\n\tif (!node || (node->sgprivate->tag!=TAG_ProtoNode)) return 0;\n\tif ( ((GF_ProtoInstance *)node)->flags & GF_SG_PROTO_IS_GROUPING) return 1;\n\treturn 0;\n}\n\nGF_EXPORT\nGF_Node *gf_node_get_proto_root(GF_Node *node)\n{\n\tif (!node || (node->sgprivate->tag!=TAG_ProtoNode)) return NULL;\n\treturn ((GF_ProtoInstance *)node)->RenderingNode;\n}\n\n#if 0 //unused\nGF_Node *gf_node_get_proto_parent(GF_Node *node)\n{\n\tif (!node) return NULL;\n\tif (node->sgprivate->scenegraph->pOwningProto) {\n\t\tGF_Node *the_node = (GF_Node *) node->sgprivate->scenegraph->pOwningProto;\n\t\tif (the_node != node) return the_node;\n\t}\n\treturn NULL;\n}\n\nBool gf_node_is_proto_root(GF_Node *node)\n{\n\tif (!node) return 0;\n\tif (!node->sgprivate->scenegraph->pOwningProto) return 0;\n\n\tif (gf_list_find(node->sgprivate->scenegraph->pOwningProto->node_code, node)>=0) return 1;\n\treturn 0;\n}\n#endif\n\n\nGF_EXPORT\nGF_Err gf_node_set_proto_eventin_handler(GF_Node *node, u32 fieldIndex, void (*event_in_cbk)(GF_Node *pThis, struct _route *route) )\n{\n\tGF_ProtoInstance *inst;\n\tGF_ProtoField *field;\n\tif (!node || (node->sgprivate->tag!=TAG_ProtoNode)) return GF_BAD_PARAM;\n\n\tinst = (GF_ProtoInstance *) node;\n\tfield = (GF_ProtoField*)gf_list_get(inst->fields, fieldIndex);\n\tif (!field) return GF_BAD_PARAM;\n\n\tif (field->EventType!=GF_SG_EVENT_IN) return GF_BAD_PARAM;\n\tfield->on_event_in = event_in_cbk;\n\treturn GF_OK;\n}\n\n\n\n#endif\t/*GPAC_DISABLE_VRML*/\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2012\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / Scene Graph sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n\n#include <gpac/internal/scenegraph_dev.h>\n/*MPEG4 & X3D tags (for node tables & script handling)*/\n#include <gpac/nodes_mpeg4.h>\n#include <gpac/nodes_x3d.h>\n\n#ifndef GPAC_DISABLE_VRML\n\nGF_EXPORT\nGF_Proto *gf_sg_proto_new(GF_SceneGraph *inScene, u32 ProtoID, char *name, Bool unregistered)\n{\n\tGF_Proto *tmp;\n\tif (!inScene) return NULL;\n\n\t/*make sure we don't define a proto already defined in this scope*/\n\tif (!unregistered) {\n\t\ttmp = gf_sg_find_proto(inScene, ProtoID, name);\n\t\tif (tmp) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_SCENE, (\"[Scenegraph] PROTO %s redefined - skipping loading\\n\", name));\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tGF_SAFEALLOC(tmp, GF_Proto)\n\tif (!tmp) return NULL;\n\n\ttmp->proto_fields = gf_list_new();\n\ttmp->node_code = gf_list_new();\n\ttmp->parent_graph = inScene;\n\ttmp->sub_graph = gf_sg_new_subscene(inScene);\n\ttmp->instances = gf_list_new();\n\n\tif (name)\n\t\ttmp->Name = gf_strdup(name);\n\telse\n\t\ttmp->Name = gf_strdup(\"Unnamed Proto\");\n\ttmp->ID = ProtoID;\n\tif (!unregistered) {\n\t\tgf_list_add(inScene->protos, tmp);\n\t} else {\n\t\tgf_list_add(inScene->unregistered_protos, tmp);\n\t}\n\treturn tmp;\n}\n\n#if 0\n/*used for memory handling of scene graph only. move proto from off-graph to in-graph or reverse*/\nGF_Err gf_sg_proto_set_in_graph(GF_Proto *proto, GF_SceneGraph *inScene, Bool set_in)\n{\n\tu32 i;\n\tGF_Proto *tmp;\n\tGF_List *removeFrom;\n\tGF_List *insertIn;\n\n\tif (set_in) {\n\t\tremoveFrom = proto->parent_graph->unregistered_protos;\n\t\tinsertIn = proto->parent_graph->protos;\n\t} else {\n\t\tinsertIn = proto->parent_graph->unregistered_protos;\n\t\tremoveFrom = proto->parent_graph->protos;\n\t}\n\n\tgf_list_del_item(removeFrom, proto);\n\n\ti=0;\n\twhile ((tmp = (GF_Proto*)gf_list_enum(insertIn, &i))) {\n\t\tif (tmp==proto) return GF_OK;\n\t\tif (!set_in) continue;\n\t\t/*if registering, make sure no other proto has the same ID/name*/\n\t\tif (tmp->ID==proto->ID) return GF_BAD_PARAM;\n\t\tif (!stricmp(tmp->Name, proto->Name)) return GF_BAD_PARAM;\n\t}\n\treturn gf_list_add(insertIn, proto);\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_sg_proto_del(GF_Proto *proto)\n{\n\ts32 i;\n\n\tif (!proto) return GF_OK;\n\ti = gf_list_del_item(proto->parent_graph->protos, proto);\n\tif (i<0) {\n\t\tgf_list_del_item(proto->parent_graph->unregistered_protos, proto);\n\t}\n\tif (proto->userpriv && proto->OnDelete) proto->OnDelete(proto->userpriv);\n\n\t/*first destroy the code*/\n\twhile (gf_list_count(proto->node_code)) {\n\t\tGF_Node *node = (GF_Node*)gf_list_get(proto->node_code, 0);\n\t\tgf_node_unregister(node, NULL);\n\t\tgf_list_rem(proto->node_code, 0);\n\t}\n\tgf_list_del(proto->node_code);\n\n\t/*delete interface*/\n\twhile (gf_list_count(proto->proto_fields)) {\n\t\tGF_ProtoFieldInterface *field = (GF_ProtoFieldInterface*)gf_list_get(proto->proto_fields, 0);\n\t\tif (field->userpriv && field->OnDelete) field->OnDelete(field->userpriv);\n\n\t\tif (field->FieldType==GF_SG_VRML_SFNODE) {\n\t\t\tif (field->def_sfnode_value)\n\t\t\t\tgf_node_unregister(field->def_sfnode_value, NULL);\n\t\t}\n\t\telse if (field->FieldType==GF_SG_VRML_MFNODE) {\n\t\t\tif (field->def_mfnode_value)\n\t\t\t\tgf_node_unregister_children(NULL, field->def_mfnode_value);\n\t\t}\n\t\telse if (field->def_value)\n\t\t\tgf_sg_vrml_field_pointer_del(field->def_value, field->FieldType);\n\n\t\tif (field->FieldName) gf_free(field->FieldName);\n\n\t\t/*QP fields are SF fields, we can safely gf_free() them*/\n\t\tif (field->qp_max_value) gf_free(field->qp_max_value);\n\t\tif (field->qp_min_value) gf_free(field->qp_min_value);\n\t\tgf_free(field);\n\t\tgf_list_rem(proto->proto_fields, 0);\n\t}\n\tgf_list_del(proto->proto_fields);\n\n\twhile (gf_list_count(proto->instances)) {\n\t\tGF_ProtoInstance *p = (GF_ProtoInstance *)gf_list_get(proto->instances, 0);\n\t\tgf_list_rem(proto->instances, 0);\n\t\tp->proto_interface = NULL;\n\t}\n\n\t/*delete sub graph*/\n\tgf_sg_del(proto->sub_graph);\n\n\n\tif (proto->Name) gf_free(proto->Name);\n\tgf_sg_mfurl_del(proto->ExternProto);\n\tgf_list_del(proto->instances);\n\tgf_free(proto);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_SceneGraph *gf_sg_proto_get_graph(GF_Proto *proto)\n{\n\treturn proto ? proto->sub_graph : NULL;\n}\n\n\n#if 0\nvoid gf_sg_proto_set_private(GF_Proto *p, void *ptr, void (*OnDelete)(void *ptr) )\n{\n\tif (p) {\n\t\tp->userpriv = ptr;\n\t\tp->OnDelete = OnDelete;\n\t}\n}\n\nvoid *gf_sg_proto_get_private(GF_Proto *p)\n{\n\treturn p ? p->userpriv : NULL;\n}\n#endif\n\nGF_EXPORT\nMFURL *gf_sg_proto_get_extern_url(GF_Proto *proto)\n{\n\treturn proto ? &proto->ExternProto : NULL;\n}\n\nGF_EXPORT\nGF_Err gf_sg_proto_add_node_code(GF_Proto *proto, GF_Node *pNode)\n{\n\tif (!proto) return GF_BAD_PARAM;\n\treturn gf_list_add(proto->node_code, pNode);\n}\n\nGF_EXPORT\nGF_ProtoFieldInterface *gf_sg_proto_field_find_by_name(GF_Proto *proto, char *fieldName)\n{\n\tGF_ProtoFieldInterface *ptr;\n\tu32 i=0;\n\twhile ((ptr = (GF_ProtoFieldInterface*)gf_list_enum(proto->proto_fields, &i))) {\n\t\tif (ptr->FieldName && !strcmp(ptr->FieldName, fieldName)) return ptr;\n\t}\n\treturn NULL;\n}\n\nGF_EXPORT\nGF_ProtoFieldInterface *gf_sg_proto_field_new(GF_Proto *proto, u32 fieldType, u32 eventType, char *fieldName)\n{\n\tGF_ProtoFieldInterface *tmp;\n\n\tif (fieldName) {\n\t\ttmp = gf_sg_proto_field_find_by_name(proto, fieldName);\n\t\tif (tmp) return NULL;\n\t}\n\tGF_SAFEALLOC(tmp, GF_ProtoFieldInterface)\n\tif (!tmp) return NULL;\n\n\ttmp->FieldType = fieldType;\n\ttmp->EventType = eventType;\n\n\t/*create container - can be NULL if SF node*/\n\tif ( fieldType == GF_SG_VRML_SFNODE) {\n\t\ttmp->def_sfnode_value = NULL;\n\t\ttmp->def_value = &tmp->def_sfnode_value;\n\t} else if ( fieldType == GF_SG_VRML_MFNODE) {\n\t\ttmp->def_mfnode_value = NULL;\n\t\ttmp->def_value = &tmp->def_mfnode_value;\n\t} else {\n\t\ttmp->def_value = gf_sg_vrml_field_pointer_new(fieldType);\n\t}\n\n\tif (fieldName) tmp->FieldName = gf_strdup(fieldName);\n\n\ttmp->ALL_index = gf_list_count(proto->proto_fields);\n\ttmp->OUT_index = tmp->DEF_index = tmp->IN_index = (u32) -1;\n\n\tswitch (eventType) {\n\tcase GF_SG_EVENT_EXPOSED_FIELD:\n\t\ttmp->IN_index = proto->NumIn;\n\t\tproto->NumIn ++;\n\t\ttmp->OUT_index = proto->NumOut;\n\t\tproto->NumOut ++;\n\tcase GF_SG_EVENT_FIELD:\n\t\ttmp->DEF_index = proto->NumDef;\n\t\tproto->NumDef ++;\n\t\tbreak;\n\tcase GF_SG_EVENT_IN:\n\t\ttmp->IN_index = proto->NumIn;\n\t\tproto->NumIn ++;\n\t\tbreak;\n\tcase GF_SG_EVENT_OUT:\n\t\ttmp->OUT_index = proto->NumOut;\n\t\tproto->NumOut ++;\n\t\tbreak;\n\t}\n\n\tgf_list_add(proto->proto_fields, tmp);\n\treturn tmp;\n}\n\n#if 0 //unused\nvoid gf_sg_proto_field_set_private(GF_ProtoFieldInterface *field, void *ptr, void (*OnDelete)(void *ptr))\n{\n\tif (field) {\n\t\tfield->userpriv = ptr;\n\t\tfield->OnDelete = OnDelete;\n\t}\n}\n\nvoid *gf_sg_proto_field_get_private(GF_ProtoFieldInterface *field)\n{\n\treturn field ? field->userpriv : NULL;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_sg_proto_field_get_field(GF_ProtoFieldInterface *field, GF_FieldInfo *info)\n{\n\tif (!field || !info) return GF_BAD_PARAM;\n\tmemset(info, 0, sizeof(GF_FieldInfo));\n\tinfo->fieldIndex = field->ALL_index;\n\tinfo->fieldType = field->FieldType;\n\tinfo->eventType = field->EventType;\n\tinfo->far_ptr = field->def_value;\n\tinfo->name = field->FieldName;\n\tinfo->NDTtype = NDT_SFWorldNode;\n\treturn GF_OK;\n}\n\nGF_Err gf_sg_proto_get_field(GF_Proto *proto, GF_Node *node, GF_FieldInfo *info)\n{\n\tGF_ProtoFieldInterface *proto_field;\n\tGF_ProtoInstance *inst;\n\tGF_ProtoField *field;\n\n\tif (!proto && !node) return GF_BAD_PARAM;\n\n\tif (proto) {\n\t\tproto_field = (GF_ProtoFieldInterface*)gf_list_get(proto->proto_fields, info->fieldIndex);\n\t\tif (!proto_field) return GF_BAD_PARAM;\n\n\t\tinfo->fieldType = proto_field->FieldType;\n\t\tinfo->eventType = proto_field->EventType;\n\t\tinfo->fieldIndex = proto_field->ALL_index;\n\t\tinfo->NDTtype = NDT_SFWorldNode;\n\t\tinfo->far_ptr = proto_field->def_value;\n\t\tinfo->name = proto_field->FieldName;\n\t\treturn GF_OK;\n\t}\n\n\t/*otherwise this is an instantiated proto*/\n\tif (node->sgprivate->tag!=TAG_ProtoNode) return GF_BAD_PARAM;\n\n\tinst = (GF_ProtoInstance *) node;\n\tfield = (GF_ProtoField*)gf_list_get(inst->fields, info->fieldIndex);\n\tif (!field) return GF_BAD_PARAM;\n\n\tinfo->fieldType = field->FieldType;\n\tinfo->eventType = field->EventType;\n\tinfo->on_event_in = field->on_event_in;\n\t/*SF/MF nodes need pointers to field object - cf gf_sg_proto_create_node*/\n\tif (gf_sg_vrml_get_sf_type(field->FieldType) == GF_SG_VRML_SFNODE) {\n\t\tinfo->far_ptr = &field->field_pointer;\n\t} else {\n\t\tinfo->far_ptr = field->field_pointer;\n\t}\n\t/*set the name - watchout for deletion case*/\n\tif (inst->proto_interface) {\n\t\tproto_field = (GF_ProtoFieldInterface*)gf_list_get(inst->proto_interface->proto_fields, info->fieldIndex);\n\t\tinfo->name = proto_field->FieldName;\n\t} else {\n\t\tinfo->name = \"ProtoFieldDeleted\";\n\t}\n\tinfo->NDTtype = NDT_SFWorldNode;\n\treturn GF_OK;\n}\n\ns32 gf_sg_proto_get_field_index_by_name(GF_Proto *proto, GF_Node *node, char *name)\n{\n\tu32 i;\n\tGF_Proto *__proto=NULL;\n\n\tif (!node && !proto) return -1;\n\tif (node && (node->sgprivate->tag!=TAG_ProtoNode)) return -1;\n\n\tif (proto)\n\t\t__proto = proto;\n\telse if (node)\n\t\t__proto = ((GF_ProtoInstance *) node)->proto_interface;\n\n\tif (!__proto ) return -1;\n\n\tfor (i=0; i<gf_list_count(__proto->proto_fields); i++) {\n\t\tGF_ProtoFieldInterface *proto_field = (GF_ProtoFieldInterface*)gf_list_get(__proto->proto_fields, i);\n\t\tif (proto_field->FieldName && !strcmp(proto_field->FieldName, name)) return i;\n\t}\n\treturn -1;\n}\n\n\nGF_Node *gf_vrml_node_clone(GF_SceneGraph *inScene, GF_Node *orig, GF_Node *cloned_parent, char *inst_id_suffix)\n{\n\tu32 i, count, id;\n\tchar *szNodeName;\n\tBool is_script;\n\tGF_Node *node, *child;\n\tGF_ChildNodeItem *list, *last;\n\tGF_Route *r1;\n#ifndef GPAC_DISABLE_BIFS\n\tvoid BIFS_SetupConditionalClone(GF_Node *node, GF_Node *orig);\n#endif\n\tGF_ProtoInstance *proto;\n\tGF_FieldInfo field_orig, field;\n\n\t/*this is not a mistake*/\n\tif (!orig) return NULL;\n\n\t/*check for DEF/USE*/\n\tszNodeName = NULL;\n\tif (!inst_id_suffix) id = 0;\n\telse {\n\t\tconst char *orig_name = gf_node_get_name_and_id(orig, &id);\n\t\t/*generate clone IDs based on original one*/\n\t\tif (inst_id_suffix[0] && id) {\n\t\t\tid = gf_sg_get_next_available_node_id(inScene);\n\t\t\tif (orig_name) {\n\t\t\t\tszNodeName = gf_malloc(sizeof(char)*(strlen(orig_name)+strlen(inst_id_suffix)+1));\n\t\t\t\tstrcpy(szNodeName, orig_name);\n\t\t\t\tstrcat(szNodeName, inst_id_suffix);\n\t\t\t}\n\t\t}\n\t\telse if (orig_name) szNodeName = gf_strdup(orig_name);\n\t}\n\n\tif (id) {\n\t\tnode = szNodeName ? gf_sg_find_node_by_name(inScene, szNodeName) : gf_sg_find_node(inScene, id);\n\t\t/*node already created, USE*/\n\t\tif (node) {\n\t\t\tgf_node_register(node, cloned_parent);\n\t\t\tif (szNodeName) gf_free(szNodeName);\n\t\t\treturn node;\n\t\t}\n\t}\n\t/*create a node*/\n\tif (orig->sgprivate->tag == TAG_ProtoNode) {\n\t\tGF_Proto *proto_node = ((GF_ProtoInstance *)orig)->proto_interface;\n\t\t/*create the instance but don't load the code -c we MUST wait for ISed routes to be cloned before*/\n\t\tnode = gf_sg_proto_create_node(inScene, proto_node, (GF_ProtoInstance *) orig);\n\t} else {\n\t\tnode = gf_node_new(inScene, orig->sgprivate->tag);\n\t}\n\n\tcount = gf_node_get_field_count(orig);\n\n\tis_script = 0;\n\tif (orig->sgprivate->tag==TAG_MPEG4_Script) is_script = 1;\n#ifndef GPAC_DISABLE_X3D\n\telse if (orig->sgprivate->tag==TAG_X3D_Script) is_script = 1;\n#endif\n\n\tif (is_script) gf_sg_script_prepare_clone(node, orig);\n\n\n\t/*register node*/\n\tif (id) {\n\t\tgf_node_set_id(node, id, szNodeName);\n\t\tif (szNodeName) gf_free(szNodeName);\n\t}\n\tgf_node_register(node, cloned_parent);\n\n\t/*copy each field*/\n\tfor (i=0; i<count; i++) {\n\t\tgf_node_get_field(orig, i, &field_orig);\n\n\t\t/*get target ptr*/\n\t\tgf_node_get_field(node, i, &field);\n\n\t\tassert(field.eventType==field_orig.eventType);\n\t\tassert(field.fieldType==field_orig.fieldType);\n\n\t\t/*duplicate it*/\n\t\tswitch (field.fieldType) {\n\t\tcase GF_SG_VRML_SFNODE:\n\t\t\tchild = gf_node_clone(inScene, (* ((GF_Node **) field_orig.far_ptr)), node, inst_id_suffix, 1);\n\t\t\t*((GF_Node **) field.far_ptr) = child;\n\t\t\tbreak;\n\t\tcase GF_SG_VRML_MFNODE:\n\t\t\tlast = NULL;\n\t\t\tlist = *( (GF_ChildNodeItem **) field_orig.far_ptr);\n\t\t\twhile (list) {\n\t\t\t\tchild = gf_node_clone(inScene, list->node, node, inst_id_suffix, 1);\n\t\t\t\tgf_node_list_add_child_last((GF_ChildNodeItem **) field.far_ptr, child, &last);\n\t\t\t\tlist = list->next;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_SG_VRML_SFTIME:\n\t\t\tgf_sg_vrml_field_copy(field.far_ptr, field_orig.far_ptr, field.fieldType);\n\t\t\tif (!inScene->GetSceneTime) break;\n\t\t\t/*update SFTime that must be updated when cloning the node*/\n\t\t\tif (orig->sgprivate->tag == TAG_ProtoNode) {\n\t\t\t\tif (gf_sg_proto_field_is_sftime_offset(orig, &field_orig))\n\t\t\t\t\t*((SFTime *)field.far_ptr) += inScene->GetSceneTime(inScene->userpriv);\n\t\t\t} else if (!stricmp(field.name, \"startTime\") || !stricmp(field_orig.name, \"startTime\") ) {\n\t\t\t\t*((SFTime *)field.far_ptr) += inScene->GetSceneTime(inScene->userpriv);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgf_sg_vrml_field_clone(field.far_ptr, field_orig.far_ptr, field.fieldType, inScene);\n\t\t\tbreak;\n\t\t}\n\t}\n\n#ifndef GPAC_DISABLE_BIFS\n\t/*init node before creating ISed routes so the eventIn handler are in place*/\n\tif (node->sgprivate->tag == TAG_MPEG4_Conditional)\n\t\tBIFS_SetupConditionalClone(node, orig);\n\telse\n#endif\n\t\tif (node->sgprivate->tag != TAG_ProtoNode) gf_node_init(node);\n\n\tif (!inScene->pOwningProto) return node;\n\tproto = inScene->pOwningProto;\n\n\t/*create Routes for ISed fields*/\n\ti=0;\n\twhile ((r1 = (GF_Route*)gf_list_enum(proto->proto_interface->sub_graph->Routes, &i))) {\n\t\tGF_Route *r2 = NULL;\n\t\t/*locate only ISed routes*/\n\t\tif (!r1->IS_route) continue;\n\n\t\t/*eventOut*/\n\t\tif (r1->FromNode == orig) {\n\t\t\tr2 = gf_sg_route_new(inScene, node, r1->FromField.fieldIndex, (GF_Node *) proto, r1->ToField.fieldIndex);\n\t\t\tr2->IS_route = 1;\n\t\t}\n\t\t/*eventIn or exposedField*/\n\t\telse if (r1->ToNode == orig) {\n\t\t\tr2 = gf_sg_route_new(inScene, (GF_Node *) proto, r1->FromField.fieldIndex, node, r1->ToField.fieldIndex);\n\t\t\tr2->IS_route = 1;\n\n\t\t\t/*activate the route now so that proto instanciation works properly, otherwise we may load scripts with wrong field values\n\t\t\tNote: we don't activate eventOut routes upon instanciation since no event has been triggered yet*/\n\t\t\tgf_sg_route_activate(r2);\n\t\t}\n\t}\n\n\t/*remember scripts*/\n\tif (is_script) gf_list_add(proto->scripts_to_load, node);\n\n\t/*this is a proto node, init our internal stuff*/\n\tif (node->sgprivate->tag == TAG_ProtoNode) {\n\t\tnode->sgprivate->UserCallback = NULL;\n\t\tnode->sgprivate->UserPrivate = NULL;\n\t\t/*NO RENDER, this is filtered at the generic gf_node_traverse to cope with instanciations and externProto*/\n\t\t/*load code*/\n\t\tgf_sg_proto_instantiate((GF_ProtoInstance *)node);\n\t}\n\treturn node;\n}\n\nGF_Err gf_sg_proto_get_field_ind_static(GF_Node *Node, u32 inField, u8 IndexMode, u32 *allField)\n{\n\treturn gf_sg_proto_get_field_index((GF_ProtoInstance *)Node, inField, IndexMode, allField);\n}\n\n\nstatic Bool is_same_proto(GF_Proto *extern_proto, GF_Proto *proto)\n{\n\tu32 i, count;\n\t/*VRML allows external protos to have more fields defined that the externProto referencing them*/\n\tif (gf_list_count(extern_proto->proto_fields) > gf_list_count(proto->proto_fields)) return 0;\n\tcount = gf_list_count(extern_proto->proto_fields);\n\tfor (i=0; i<count; i++) {\n\t\tGF_ProtoFieldInterface *pf1 = (GF_ProtoFieldInterface*)gf_list_get(extern_proto->proto_fields, i);\n\t\tGF_ProtoFieldInterface *pf2 = (GF_ProtoFieldInterface*)gf_list_get(proto->proto_fields, i);\n\t\tif (pf1->EventType != pf2->EventType) return 0;\n\t\tif (pf1->FieldType != pf2->FieldType) return 0;\n\t\t/*note we don't check names since we're not sure both protos use name coding (MPEG4 only)*/\n\t}\n\treturn 1;\n}\n\nstatic GF_Proto *find_proto_by_interface(GF_SceneGraph *sg, GF_Proto *extern_proto)\n{\n\tGF_Proto *proto;\n\tu32 i, count;\n\n\tassert(sg);\n\n\t/*browse all top-level */\n\ti=0;\n\twhile ((proto = (GF_Proto*)gf_list_enum(sg->protos, &i))) {\n\t\tif (is_same_proto(proto, extern_proto)) return proto;\n\t}\n\t/*browse all top-level unregistered in reverse order*/\n\tcount = gf_list_count(sg->unregistered_protos);\n\tfor (i=count; i>0; i--) {\n\t\tproto = (GF_Proto*)gf_list_get(sg->unregistered_protos, i-1);\n\t\tif (is_same_proto(proto, extern_proto)) return proto;\n\t}\n\treturn NULL;\n}\n\n/*performs common initialization of routes ISed fields and protos once everything is loaded*/\nvoid gf_sg_proto_instantiate(GF_ProtoInstance *proto_node)\n{\n\tGF_Node *node, *orig;\n\tGF_Route *route, *r2;\n\tu32 i, count;\n\tGF_Proto *proto = proto_node->proto_interface;\n\tGF_Proto *owner = proto;\n\n\tif (!proto) return;\n\n\tif (owner->ExternProto.count) {\n\t\tGF_ProtoFieldInterface *pfi;\n\t\tGF_SceneGraph *extern_lib;\n\t\tif (!owner->parent_graph->GetExternProtoLib) return;\n\t\textern_lib = owner->parent_graph->GetExternProtoLib(proto->parent_graph->userpriv, &owner->ExternProto);\n\t\tif (!extern_lib) return;\n\n\t\t/*this is an hardcoded proto - all routes, node modifications and co are handled internally*/\n\t\tif (PTR_TO_U_CAST extern_lib == GF_SG_INTERNAL_PROTO) {\n\t\t\tproto_node->sgprivate->flags |= GF_SG_NODE_DIRTY;\n\t\t\t// take default values\n\t\t\tcount = gf_list_count(owner->proto_fields);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_ProtoField *pf = (GF_ProtoField *)gf_list_get(proto_node->fields, i);\n\t\t\t\tif (!pf->has_been_accessed) {\n\t\t\t\t\tpfi = (GF_ProtoFieldInterface*)gf_list_get(proto->proto_fields, i);\n\t\t\t\t\tgf_sg_vrml_field_copy(pf->field_pointer, pfi->def_value, pfi->FieldType);\n\t\t\t\t}\n\t\t\t}\n\t\t\towner->parent_graph->NodeCallback(owner->parent_graph->userpriv, GF_SG_CALLBACK_INIT, (GF_Node *) proto_node, NULL);\n\t\t\tproto_node->flags |= GF_SG_PROTO_LOADED | GF_SG_PROTO_HARDCODED;\n\t\t\treturn;\n\t\t}\n\t\t/*not loaded yet*/\n\t\tif (!gf_list_count(extern_lib->protos)) return;\n\n\t\t/*overwrite this proto by external one*/\n\t\tproto = NULL;\n\t\t/*start with proto v2 addressing*/\n\t\tif (owner->ExternProto.vals[0].url) {\n\t\t\tu32 ID = (u32) -1;\n\t\t\tchar *szName = strrchr(owner->ExternProto.vals[0].url, '#');\n\t\t\tif (szName) {\n\t\t\t\tszName++;\n\t\t\t\tif (sscanf(szName, \"%u\", &ID)) ID = (u32) -1;\n\t\t\t}\n\t\t\t/*if we have the proto name, use it*/\n\t\t\tif (owner->Name) szName = owner->Name;\n\t\t\tproto = gf_sg_find_proto(extern_lib, ID, szName);\n\t\t}\n\t\tif (!proto) proto = gf_sg_find_proto(extern_lib, owner->ID, owner->Name);\n\t\tif (!proto) proto = find_proto_by_interface(extern_lib, owner);\n\n\t\tif (proto && !is_same_proto(owner, proto)) {\n\t\t\tproto = NULL;\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_SCENE, (\"[Scenegraph] fields/types mismatch for PROTO %s - skipping instantiation\\n\", owner->Name));\n\t\t}\n\t\t/*couldn't find proto in the given lib, consider the proto as loaded (give up)*/\n\t\tif (!proto) {\n\t\t\tproto_node->flags |= GF_SG_PROTO_LOADED;\n\t\t\treturn;\n\t\t}\n\t\t/*cf VRML: once an external proto is loaded, copy back the default field values of the external proto*/\n\t\tcount = gf_list_count(owner->proto_fields);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_ProtoField *pf = (GF_ProtoField *)gf_list_get(proto_node->fields, i);\n\t\t\tif (!pf->has_been_accessed) {\n\t\t\t\tpfi = (GF_ProtoFieldInterface*)gf_list_get(proto->proto_fields, i);\n\t\t\t\tgf_sg_vrml_field_copy(pf->field_pointer, pfi->def_value, pfi->FieldType);\n\t\t\t} else {\n\t\t\t\t//pfi = (GF_ProtoFieldInterface*)gf_list_get(proto->proto_fields, i);\n\t\t\t}\n\t\t}\n\n\t\t/*unregister from prev and reg with real proto*/\n\t\tgf_list_del_item(owner->instances, proto_node);\n\t\tgf_list_add(proto->instances, proto_node);\n\t}\n\n\t/*OVERRIDE the proto instance (eg don't instantiate an empty externproto...)*/\n\tproto_node->proto_interface = proto;\n\n\t/*clone all nodes*/\n\ti=0;\n\twhile ((orig = (GF_Node*)gf_list_enum(proto->node_code, &i))) {\n\t\t/*node is cloned in the new scenegraph and its parent is NULL */\n\t\tnode = gf_node_clone(proto_node->sgprivate->scenegraph, orig, NULL, \"\", 1);\n\t\tassert(node);\n\n\t\t/*assign first rendering node*/\n\t\tif (i==1) proto_node->RenderingNode = node;\n\t\tgf_list_add(proto_node->node_code, node);\n\t}\n\n\t/*instantiate routes (not ISed ones)*/\n\ti=0;\n\twhile ((route = (GF_Route*)gf_list_enum(proto->sub_graph->Routes, &i))) {\n\t\tif (route->IS_route) continue;\n\n\t\tr2 = gf_sg_route_new(proto_node->sgprivate->scenegraph,\n\t\t                     gf_sg_find_node(proto_node->sgprivate->scenegraph, gf_node_get_id(route->FromNode) ),\n\t\t                     route->FromField.fieldIndex,\n\t\t                     gf_sg_find_node(proto_node->sgprivate->scenegraph, gf_node_get_id(route->ToNode) ),\n\t\t                     route->ToField.fieldIndex);\n\n\t\tif (route->ID) gf_sg_route_set_id(r2, route->ID);\n\t\tif (route->name) gf_sg_route_set_name(r2, route->name);\n\t}\n\t/*activate all ISed fields so that inits on events is properly done*/\n\ti=0;\n\twhile ((route = (GF_Route*)gf_list_enum(proto_node->sgprivate->scenegraph->Routes, &i))) {\n\t\tif (!route->IS_route) continue;\n\t\t/*do not activate eventIn to eventIn routes*/\n\t\tif (route->is_setup) {\n\t\t\tif ((route->ToField.eventType == GF_SG_EVENT_IN) && (route->FromField.eventType == GF_SG_EVENT_IN) ) continue;\n\t\t}\n\t\tgf_sg_route_activate(route);\n\t}\n\t/*and load all scripts (this must be done once all fields are routed for the \"initialize\" method)*/\n\twhile (gf_list_count(proto_node->scripts_to_load)) {\n\t\tnode = (GF_Node*)gf_list_get(proto_node->scripts_to_load, 0);\n\t\tgf_list_rem(proto_node->scripts_to_load, 0);\n\t\tgf_sg_script_load(node);\n\t}\n\t/*re-activate all ISed fields pointing to scripts once scripts are loaded (eventIns)*/\n\ti=0;\n\twhile ((route = (GF_Route*)gf_list_enum(proto_node->sgprivate->scenegraph->Routes, &i))) {\n\t\tif (!route->IS_route || !route->ToNode) continue;\n\t\t/*\t\tassert(route->is_setup);\n\t\t\t\tif ((route->FromField.eventType == GF_SG_EVENT_OUT) || (route->FromField.eventType == GF_SG_EVENT_IN) ) continue;\n\t\t*/\n\n\t\tif (route->is_setup) {\n\t\t\tif ((route->ToField.eventType == GF_SG_EVENT_IN) && (route->FromField.eventType == GF_SG_EVENT_IN) ) continue;\n\t\t}\n\n\t\tif (route->ToNode->sgprivate->tag==TAG_MPEG4_Script)\n\t\t\tgf_sg_route_activate(route);\n#ifndef GPAC_DISABLE_X3D\n\t\telse if (route->ToNode->sgprivate->tag==TAG_X3D_Script)\n\t\t\tgf_sg_route_activate(route);\n#endif\n\t}\n\n#if 0\n\t/*reset all regular route activation times - if we don't do so, creating a proto by script and then manipulating one of its\n\tISed field may not trigger the proper routes*/\n\ti=0;\n\twhile ((route = (GF_Route*)gf_list_enum(proto_node->sgprivate->scenegraph->Routes, &i))) {\n\t\tif (!route->IS_route) {\n\t\t\troute->lastActivateTime = 0;\n\t\t}\n\t}\n#endif\n\tproto_node->flags |= GF_SG_PROTO_LOADED;\n}\n\nvoid gf_sg_proto_mark_field_loaded(GF_Node *proto_inst, GF_FieldInfo *info)\n{\n\tGF_ProtoInstance *inst= (proto_inst->sgprivate->tag==TAG_ProtoNode) ? (GF_ProtoInstance *)proto_inst : NULL;\n\tGF_ProtoField *pf = inst ? (GF_ProtoField *)gf_list_get(inst->fields, info->fieldIndex) : NULL;\n\tif (pf) pf->has_been_accessed = 1;\n}\n\nGF_Node *gf_sg_proto_create_node(GF_SceneGraph *scene, GF_Proto *proto, GF_ProtoInstance *from_inst)\n{\n\tu32 i;\n\tGF_ProtoField *inst, *from_field;\n\tGF_ProtoFieldInterface *field;\n\tGF_ProtoInstance *proto_node;\n\tif (!proto) return NULL;\n\t\n\tGF_SAFEALLOC(proto_node, GF_ProtoInstance)\n\tif (!proto_node) return NULL;\n\n\tgf_node_setup((GF_Node *)proto_node, TAG_ProtoNode);\n\tproto_node->node_code = gf_list_new();\n\tproto_node->fields = gf_list_new();\n\tproto_node->scripts_to_load = gf_list_new();\n\n\tproto_node->proto_interface = proto;\n\tgf_list_add(proto->instances, proto_node);\n\n\tproto_node->proto_name = gf_strdup(proto->Name);\n\n\t/*create the namespace*/\n\tproto_node->sgprivate->scenegraph = gf_sg_new_subscene(scene);\n\t/*set this proto as owner of the new graph*/\n\tproto_node->sgprivate->scenegraph->pOwningProto = proto_node;\n\n\t/*instantiate fields*/\n\ti=0;\n\twhile ((field = (GF_ProtoFieldInterface*)gf_list_enum(proto->proto_fields, &i))) {\n\t\tGF_SAFEALLOC(inst, GF_ProtoField);\n\t\tif (!inst) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_SCENE, (\"[VRML] Failed to allocate proto instance field\\n]\"));\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tinst->EventType = field->EventType;\n\t\tinst->FieldType = field->FieldType;\n\n\t\t/*this is OK to call on GF_Node (returns NULL) and MFNode (returns gf_list_new() )*/\n\t\tinst->field_pointer = gf_sg_vrml_field_pointer_new(inst->FieldType);\n\n\t\t/*regular field, duplicate from default value or instantiated one if specified (since\n\t\ta proto may be partially instantiated when used in another proto)*/\n\t\tif (gf_sg_vrml_get_sf_type(inst->FieldType) != GF_SG_VRML_SFNODE) {\n\t\t\tif (from_inst) {\n\t\t\t\tfrom_field = (GF_ProtoField *)gf_list_get(from_inst->fields, i-1);\n\t\t\t\tgf_sg_vrml_field_copy(inst->field_pointer, from_field->field_pointer, inst->FieldType);\n\t\t\t\tinst->has_been_accessed = from_field->has_been_accessed;\n\t\t\t} else {\n\t\t\t\tgf_sg_vrml_field_copy(inst->field_pointer, field->def_value, inst->FieldType);\n\t\t\t}\n\t\t}\n\t\t/*No default values for SFNodes as interfaces ...*/\n\t\tgf_list_add(proto_node->fields, inst);\n\t}\n\treturn (GF_Node *) proto_node;\n}\n\n\nGF_EXPORT\nGF_Node *gf_sg_proto_create_instance(GF_SceneGraph *sg, GF_Proto *proto)\n{\n\treturn gf_sg_proto_create_node(sg, proto, NULL);\n}\n\nGF_EXPORT\nGF_Err gf_sg_proto_load_code(GF_Node *node)\n{\n\tGF_ProtoInstance *inst;\n\tif (node->sgprivate->tag != TAG_ProtoNode) return GF_BAD_PARAM;\n\tinst = (GF_ProtoInstance *) node;\n\tif (!inst->proto_interface) return GF_BAD_PARAM;\n\tif (inst->flags & GF_SG_PROTO_LOADED) return GF_OK;\n\tgf_sg_proto_instantiate(inst);\n\treturn GF_OK;\n}\n\n\nu32 gf_sg_proto_get_num_fields(GF_Node *node, u8 code_mode)\n{\n\tGF_ProtoInstance *proto;\n\tif (!node) return 0;\n\n\tproto = (GF_ProtoInstance *)node;\n\t/*watchout for deletion case*/\n\tswitch (code_mode) {\n\tcase GF_SG_FIELD_CODING_IN:\n\t\treturn proto->proto_interface ? proto->proto_interface->NumIn : 0;\n\tcase GF_SG_FIELD_CODING_OUT:\n\t\treturn proto->proto_interface ? proto->proto_interface->NumOut : 0;\n\tcase GF_SG_FIELD_CODING_DEF:\n\t\treturn proto->proto_interface ? proto->proto_interface->NumDef : 0;\n\tcase GF_SG_FIELD_CODING_ALL:\n\t\treturn gf_list_count(proto->proto_interface ? proto->proto_interface->proto_fields : proto->fields);\n\t/*BIFS-ANIM not supported*/\n\tcase GF_SG_FIELD_CODING_DYN:\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n\nvoid gf_sg_proto_del_instance(GF_ProtoInstance *inst)\n{\n\tGF_SceneGraph *sg;\n\n\twhile (gf_list_count(inst->fields)) {\n\t\tGF_ProtoField *field = (GF_ProtoField *)gf_list_get(inst->fields, 0);\n\t\tgf_list_rem(inst->fields, 0);\n\n\t\tif (field->field_pointer) {\n\t\t\t/*regular type*/\n\t\t\tif ( (field->FieldType!=GF_SG_VRML_SFNODE) && (field->FieldType!=GF_SG_VRML_MFNODE)) {\n\t\t\t\tgf_sg_vrml_field_pointer_del(field->field_pointer, field->FieldType);\n\t\t\t}\n\t\t\t/*node types: delete instances*/\n\t\t\telse {\n\t\t\t\tif (field->FieldType == GF_SG_VRML_SFNODE) {\n\t\t\t\t\tgf_node_unregister((GF_Node *) field->field_pointer, (GF_Node *) inst);\n\t\t\t\t} else {\n\t\t\t\t\tGF_ChildNodeItem *list = (GF_ChildNodeItem *)field->field_pointer;\n\t\t\t\t\twhile (list) {\n\t\t\t\t\t\tGF_ChildNodeItem *cur = list;\n\t\t\t\t\t\tgf_node_unregister(list->node, (GF_Node *) inst);\n\t\t\t\t\t\tlist = list->next;\n\t\t\t\t\t\tgf_free(cur);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tgf_free(field);\n\t}\n\tgf_list_del(inst->fields);\n\n\t/*destroy the code*/\n\twhile (gf_list_count(inst->node_code)) {\n\t\tGF_Node *node = (GF_Node*)gf_list_get(inst->node_code, 0);\n\t\tgf_node_unregister(node, (GF_Node*) inst);\n\t\tgf_list_rem(inst->node_code, 0);\n\t}\n\n\tsg = inst->sgprivate->scenegraph;\n\n\t/*reset the scene graph before destroying the node code list, as unregistering nodes\n\tnot destroyed in the previous phase (eg, cyclic references such as script and co) will\n\trefer to the node-code list*/\n\tgf_sg_reset(sg);\n\tsg->pOwningProto = NULL;\n\n\tgf_free((char *) inst->proto_name);\n\tgf_list_del(inst->node_code);\n\tassert(!gf_list_count(inst->scripts_to_load));\n\tgf_list_del(inst->scripts_to_load);\n\n\tif (inst->proto_interface && inst->proto_interface->instances) gf_list_del_item(inst->proto_interface->instances, inst);\n\n\tgf_node_free((GF_Node *)inst);\n\tgf_sg_del(sg);\n}\n\n/*Note on ISed fields: we cannot support fan-in on proto, eg we assume only one eventIn field can receive events\nthus situations where a proto receives eventIn from outside and the node with ISed eventIn receives event\nfrom inside the proto are undefined*/\nGF_EXPORT\nGF_Err gf_sg_proto_field_set_ised(GF_Proto *proto, u32 protoFieldIndex, GF_Node *node, u32 nodeFieldIndex)\n{\n\tGF_Err e;\n\tGF_Route *r;\n\tGF_FieldInfo field, nodeField;\n\tfield.fieldIndex = protoFieldIndex;\n\te = gf_sg_proto_get_field(proto, NULL, &field);\n\tif (e) return e;\n\te = gf_node_get_field(node, nodeFieldIndex, &nodeField);\n\tif (e) return e;\n\tif (field.fieldType != nodeField.fieldType) {\n\t\tif ((gf_sg_vrml_get_sf_type(field.fieldType)==GF_SG_VRML_SFSTRING) && (gf_sg_vrml_get_sf_type(nodeField.fieldType) == GF_SG_VRML_SFURL)) {\n//\t\t\te = GF_OK;\n\t\t} else if ((gf_sg_vrml_get_sf_type(field.fieldType)==GF_SG_VRML_SFURL) && (gf_sg_vrml_get_sf_type(nodeField.fieldType) == GF_SG_VRML_SFSTRING)) {\n//\t\t\te = GF_OK;\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_SCENE, (\"[VRML] error in IS - node field %s.%s - inType %s - outType %s\\n\", gf_node_get_class_name(node) , nodeField.name, gf_sg_vrml_get_field_type_name(field.fieldType), gf_sg_vrml_get_field_type_name(nodeField.fieldType)));\n\t\t\treturn GF_SG_INVALID_PROTO;\n\t\t}\n\t}\n\n\tGF_SAFEALLOC(r, GF_Route)\n\tif (!r) return GF_OUT_OF_MEM;\n\tr->IS_route = 1;\n\n\tif (nodeField.eventType==GF_SG_EVENT_OUT) {\n\t\tr->FromField.fieldIndex = nodeFieldIndex;\n\t\tr->FromNode = node;\n\t\tr->ToField.fieldIndex = protoFieldIndex;\n\t\tr->ToNode = NULL;\n\t\tif (!node->sgprivate->interact) {\n\t\t\tGF_SAFEALLOC(node->sgprivate->interact, struct _node_interactive_ext);\n\t\t\tif (!node->sgprivate->interact) {\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t}\n\t\tif (!node->sgprivate->interact->routes) node->sgprivate->interact->routes = gf_list_new();\n\t\tgf_list_add(node->sgprivate->interact->routes, r);\n\t} else {\n\t\tswitch (field.eventType) {\n\t\tcase GF_SG_EVENT_FIELD:\n\t\tcase GF_SG_EVENT_EXPOSED_FIELD:\n\t\tcase GF_SG_EVENT_IN:\n\t\t\tr->FromField.fieldIndex = protoFieldIndex;\n\t\t\tr->FromNode = NULL;\n\t\t\tr->ToField.fieldIndex = nodeFieldIndex;\n\t\t\tr->ToNode = node;\n\t\t\t/*create an ISed route for the eventOut part of the exposedFIeld*/\n\t\t\tif ((field.eventType==GF_SG_EVENT_EXPOSED_FIELD) && (nodeField.eventType==GF_SG_EVENT_EXPOSED_FIELD)) {\n\t\t\t\tGF_Route *r2;\n\t\t\t\tGF_SAFEALLOC(r2, GF_Route);\n\t\t\t\tif (!r2) {\n\t\t\t\t\tgf_free(r);\n\t\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t\t}\n\t\t\t\tr2->IS_route = 1;\n\t\t\t\tr2->FromField.fieldIndex = nodeFieldIndex;\n\t\t\t\tr2->FromNode = node;\n\t\t\t\tr2->ToField.fieldIndex = protoFieldIndex;\n\t\t\t\tr2->ToNode = NULL;\n\t\t\t\tr2->graph =  proto->sub_graph;\n\t\t\t\tif (!node->sgprivate->interact) {\n\t\t\t\t\tGF_SAFEALLOC(node->sgprivate->interact, struct _node_interactive_ext);\n\t\t\t\t\tif (!node->sgprivate->interact) return GF_OUT_OF_MEM;\n\t\t\t\t}\n\t\t\t\tif (!node->sgprivate->interact->routes) node->sgprivate->interact->routes = gf_list_new();\n\t\t\t\tgf_list_add(node->sgprivate->interact->routes, r2);\n\t\t\t\tgf_list_add(proto->sub_graph->Routes, r2);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_SG_EVENT_OUT:\n\t\t\tr->FromField.fieldIndex = nodeFieldIndex;\n\t\t\tr->FromNode = node;\n\t\t\tr->ToField.fieldIndex = protoFieldIndex;\n\t\t\tr->ToNode = NULL;\n\t\t\tif (!node->sgprivate->interact) {\n\t\t\t\tGF_SAFEALLOC(node->sgprivate->interact, struct _node_interactive_ext);\n\t\t\t\tif (!node->sgprivate->interact) return GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tif (!node->sgprivate->interact->routes) node->sgprivate->interact->routes = gf_list_new();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgf_free(r);\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t}\n\tr->graph = proto->sub_graph;\n\treturn gf_list_add(proto->sub_graph->Routes, r);\n}\n\nGF_EXPORT\nGF_Err gf_sg_proto_instance_set_ised(GF_Node *protoinst, u32 protoFieldIndex, GF_Node *node, u32 nodeFieldIndex)\n{\n\tGF_Err e;\n\tGF_Route *r;\n\tGF_FieldInfo field, nodeField;\n\tif (!protoinst) return GF_BAD_PARAM;\n\tif (protoinst->sgprivate->tag != TAG_ProtoNode) return GF_BAD_PARAM;\n\n\te = gf_node_get_field(protoinst, protoFieldIndex, &field);\n\tif (e) return e;\n\te = gf_node_get_field(node, nodeFieldIndex, &nodeField);\n\tif (e) return e;\n\tif (field.fieldType != nodeField.fieldType) {\n\t\tif ((gf_sg_vrml_get_sf_type(field.fieldType)==GF_SG_VRML_SFSTRING) && (gf_sg_vrml_get_sf_type(nodeField.fieldType) == GF_SG_VRML_SFURL)) {\n//\t\t\te = GF_OK;\n\t\t} else if ((gf_sg_vrml_get_sf_type(field.fieldType)==GF_SG_VRML_SFURL) && (gf_sg_vrml_get_sf_type(nodeField.fieldType) == GF_SG_VRML_SFSTRING)) {\n//\t\t\te = GF_OK;\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_SCENE, (\"[VRML] error in IS - node field %s.%s - inType %s - outType %s\\n\", gf_node_get_class_name(node) , nodeField.name, gf_sg_vrml_get_field_type_name(field.fieldType), gf_sg_vrml_get_field_type_name(nodeField.fieldType)));\n\t\t\treturn GF_SG_INVALID_PROTO;\n\t\t}\n\t}\n\n\tGF_SAFEALLOC(r, GF_Route)\n\tif (!r) return GF_OUT_OF_MEM;\n\tr->IS_route = 1;\n\n\tif (nodeField.eventType==GF_SG_EVENT_OUT) {\n\t\tr->FromField.fieldIndex = nodeFieldIndex;\n\t\tr->FromNode = node;\n\t\tr->ToField.fieldIndex = protoFieldIndex;\n\t\tr->ToNode = protoinst;\n\t\tif (!node->sgprivate->interact) {\n\t\t\tGF_SAFEALLOC(node->sgprivate->interact, struct _node_interactive_ext);\n\t\t\tif (!node->sgprivate->interact) return GF_OUT_OF_MEM;\n\t\t}\n\t\tif (!node->sgprivate->interact->routes) node->sgprivate->interact->routes = gf_list_new();\n\t\tgf_list_add(node->sgprivate->interact->routes, r);\n\t} else {\n\t\tswitch (field.eventType) {\n\t\tcase GF_SG_EVENT_FIELD:\n\t\tcase GF_SG_EVENT_EXPOSED_FIELD:\n\t\tcase GF_SG_EVENT_IN:\n\t\t\tr->FromField.fieldIndex = protoFieldIndex;\n\t\t\tr->FromNode = protoinst;\n\t\t\tr->ToField.fieldIndex = nodeFieldIndex;\n\t\t\tr->ToNode = node;\n\n\t\t\t/*create an ISed route for the eventOut part of the exposedFIeld*/\n\t\t\tif ((field.eventType==GF_SG_EVENT_EXPOSED_FIELD) && (nodeField.eventType==GF_SG_EVENT_EXPOSED_FIELD)) {\n\t\t\t\tGF_Route *r2;\n\t\t\t\tGF_SAFEALLOC(r2, GF_Route);\n\t\t\t\tif (!r2) {\n\t\t\t\t\tgf_free(r);\n\t\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t\t}\n\t\t\t\tr2->IS_route = 1;\n\t\t\t\tr2->FromField.fieldIndex = nodeFieldIndex;\n\t\t\t\tr2->FromNode = node;\n\t\t\t\tr2->ToField.fieldIndex = protoFieldIndex;\n\t\t\t\tr2->ToNode = protoinst;\n\t\t\t\tr2->graph =  node->sgprivate->scenegraph;\n\t\t\t\tif (!node->sgprivate->interact) {\n\t\t\t\t\tGF_SAFEALLOC(node->sgprivate->interact, struct _node_interactive_ext);\n\t\t\t\t\tif (!node->sgprivate->interact) return GF_OUT_OF_MEM;\n\t\t\t\t}\n\t\t\t\tif (!node->sgprivate->interact->routes) node->sgprivate->interact->routes = gf_list_new();\n\t\t\t\tgf_list_add(node->sgprivate->interact->routes, r2);\n\t\t\t\tgf_list_add(r->graph->Routes, r2);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_SG_EVENT_OUT:\n\t\t\tr->FromField.fieldIndex = nodeFieldIndex;\n\t\t\tr->FromNode = node;\n\t\t\tr->ToField.fieldIndex = protoFieldIndex;\n\t\t\tr->ToNode = protoinst;\n\t\t\tif (!node->sgprivate->interact) {\n\t\t\t\tGF_SAFEALLOC(node->sgprivate->interact, struct _node_interactive_ext);\n\t\t\t\tif (!node->sgprivate->interact) return GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tif (!node->sgprivate->interact->routes) node->sgprivate->interact->routes = gf_list_new();\n\t\t\tgf_list_add(node->sgprivate->interact->routes, r);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgf_free(r);\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t}\n\tr->graph = node->sgprivate->scenegraph;\n\tgf_sg_route_activate(r);\n\treturn gf_list_add(r->graph->Routes, r);\n}\n\n\nGF_Err gf_bifs_proto_field_set_aq_info(GF_ProtoFieldInterface *field,\n                                       u32 QP_Type,\n                                       u32 hasMinMax,\n                                       u32 QPSFType,\n                                       void *qp_min_value,\n                                       void *qp_max_value,\n                                       u32 QP13_NumBits)\n{\n\n\tif (!field) return GF_BAD_PARAM;\n\tif (!QP_Type) return GF_OK;\n\tif (!gf_sg_vrml_is_sf_field(QPSFType)) return GF_BAD_PARAM;\n\n\tfield->QP_Type = QP_Type;\n\tfield->hasMinMax = hasMinMax;\n\tif (hasMinMax) {\n\t\tif (qp_min_value) {\n\t\t\tfield->qp_min_value = gf_sg_vrml_field_pointer_new(QPSFType);\n\t\t\tgf_sg_vrml_field_copy(field->qp_min_value, qp_min_value, QPSFType);\n\t\t}\n\t\tif (qp_max_value) {\n\t\t\tfield->qp_max_value = gf_sg_vrml_field_pointer_new(QPSFType);\n\t\t\tgf_sg_vrml_field_copy(field->qp_max_value, qp_max_value, QPSFType);\n\t\t}\n\t}\n\tfield->NumBits = QP13_NumBits;\n\treturn GF_OK;\n}\n\n\nGF_Err gf_sg_proto_get_field_index(GF_ProtoInstance *proto, u32 index, u32 code_mode, u32 *all_index)\n{\n\tu32 i;\n\tGF_ProtoFieldInterface *proto_field;\n\n\ti=0;\n\twhile ((proto_field = (GF_ProtoFieldInterface*)gf_list_enum(proto->proto_interface->proto_fields, &i))) {\n\t\tassert(proto_field);\n\t\tswitch (code_mode) {\n\t\tcase GF_SG_FIELD_CODING_IN:\n\t\t\tif (proto_field->IN_index == index) {\n\t\t\t\t*all_index = proto_field->ALL_index;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_SG_FIELD_CODING_OUT:\n\t\t\tif (proto_field->OUT_index == index) {\n\t\t\t\t*all_index = proto_field->ALL_index;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_SG_FIELD_CODING_DEF:\n\t\t\tif (proto_field->DEF_index == index) {\n\t\t\t\t*all_index = proto_field->ALL_index;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_SG_FIELD_CODING_ALL:\n\t\t\tif (proto_field->ALL_index == index) {\n\t\t\t\t*all_index = proto_field->ALL_index;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tbreak;\n\t\t/*BIFS-ANIM not supported*/\n\t\tcase GF_SG_FIELD_CODING_DYN:\n\t\tdefault:\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t}\n\treturn GF_BAD_PARAM;\n}\n\nGF_EXPORT\nu32 gf_sg_proto_get_field_count(GF_Proto *proto)\n{\n\tif (!proto) return 0;\n\treturn gf_list_count(proto->proto_fields);\n}\n\nGF_EXPORT\nGF_ProtoFieldInterface *gf_sg_proto_field_find(GF_Proto *proto, u32 fieldIndex)\n{\n\tif (!proto) return NULL;\n\treturn (GF_ProtoFieldInterface*)gf_list_get(proto->proto_fields, fieldIndex);\n}\n\nvoid gf_sg_proto_propagate_event(GF_Node *node, u32 fieldIndex, GF_Node *from_node)\n{\n\tu32 i;\n\tGF_Route *r;\n\tif (!node) return;\n\t/*propagation only for proto*/\n\tif (node->sgprivate->tag != TAG_ProtoNode) return;\n\t/*with ISed fields*/\n\tif (!node->sgprivate->interact || !node->sgprivate->interact->routes) return;\n\t/*we only need to propagate ISed for eventIn/exposedField. This means that if the event comes from\n\tthe same scene graph as the proto (eg from the proto code) we don't propagate the event*/\n\tif (from_node->sgprivate->scenegraph == node->sgprivate->scenegraph) return;\n\n\t/*for all ISed routes*/\n\ti=0;\n\twhile ((r = (GF_Route*)gf_list_enum(node->sgprivate->interact->routes, &i))) {\n\t\tif (!r->IS_route) continue;\n\t\t/*connecting from this node && field to a destination node other than the event source (this will break loops due to exposedFields)*/\n\t\tif ((r->FromNode == node) && (r->FromField.fieldIndex == fieldIndex) && (r->ToNode != from_node) ) {\n\t\t\tif (gf_sg_route_activate(r))\n\t\t\t\tgf_node_changed(r->ToNode, &r->ToField);\n\t\t}\n\t}\n}\n\n\nBool gf_sg_proto_get_aq_info(GF_Node *Node, u32 FieldIndex, u8 *QType, u8 *AType, Fixed *b_min, Fixed *b_max, u32 *QT13_bits)\n{\n\tGF_Proto *proto;\n\tu32 i;\n\tGF_ProtoFieldInterface *proto_field;\n\n\tproto = ((GF_ProtoInstance *)Node)->proto_interface;\n\n\ti=0;\n\twhile ((proto_field = (GF_ProtoFieldInterface*)gf_list_enum(proto->proto_fields, &i))) {\n\t\tif (proto_field->ALL_index!=FieldIndex) continue;\n\n\t\t*QType = proto_field->QP_Type;\n\t\t*AType = proto_field->Anim_Type;\n\t\t*b_min = FIX_MIN;\n\t\t*b_max = FIX_MAX;\n\n\t\tif (proto_field->hasMinMax) {\n\n\t\t\t/*translate our bounds*/\n\t\t\tswitch (gf_sg_vrml_get_sf_type(proto_field->FieldType)) {\n\t\t\tcase GF_SG_VRML_SFINT32:\n\t\t\t\t*b_min = (SFFloat) * ( (SFInt32 *) proto_field->qp_min_value);\n\t\t\t\t*b_max = (SFFloat) * ( (SFInt32 *) proto_field->qp_max_value);\n\t\t\t\tbreak;\n\t\t\t/*TO DO EVERYWHERE: check on field translation from double to float\n\t\t\tduring quant bounds*/\n\t\t\tcase GF_SG_VRML_SFTIME:\n\t\t\t\t*b_min = (SFFloat) * ( (SFTime *) proto_field->qp_min_value);\n\t\t\t\t*b_max = (SFFloat) * ( (SFTime *) proto_field->qp_max_value);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (proto_field->qp_min_value)\n\t\t\t\t\t*b_min = (SFFloat) * ( (SFFloat *) proto_field->qp_min_value);\n\t\t\t\tif (proto_field->qp_max_value)\n\t\t\t\t\t*b_max = (SFFloat) * ( (SFFloat *) proto_field->qp_max_value);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\t\t*QT13_bits = proto_field->NumBits;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n\nGF_EXPORT\nGF_Proto *gf_node_get_proto(GF_Node *node)\n{\n\tGF_ProtoInstance *inst;\n\tif (node->sgprivate->tag != TAG_ProtoNode) return NULL;\n\tinst = (GF_ProtoInstance *) node;\n\treturn inst->proto_interface;\n}\n\n/*returns the ID of the proto*/\nGF_EXPORT\nu32 gf_sg_proto_get_id(GF_Proto *proto)\n{\n\treturn proto ? proto->ID : 0;\n}\n\nGF_EXPORT\nconst char *gf_sg_proto_get_class_name(GF_Proto *proto)\n{\n\treturn (const char *) proto->Name;\n}\n\nu32 gf_sg_proto_get_root_tag(GF_Proto *proto)\n{\n\tGF_Node *n;\n\tif (!proto) return TAG_UndefinedNode;\n\tn = (GF_Node*)gf_list_get(proto->node_code, 0);\n\tif (!n) return TAG_UndefinedNode;\n\tif (n->sgprivate->tag == TAG_ProtoNode) return gf_sg_proto_get_root_tag(((GF_ProtoInstance *)n)->proto_interface);\n\treturn n->sgprivate->tag;\n}\n\nGF_EXPORT\nBool gf_sg_proto_field_is_sftime_offset(GF_Node *node, GF_FieldInfo *field)\n{\n\tu32 i;\n\tGF_Route *r;\n\tGF_ProtoInstance *inst;\n\tGF_FieldInfo inf;\n\tif (node->sgprivate->tag != TAG_ProtoNode) return 0;\n\tif (field->fieldType != GF_SG_VRML_SFTIME) return 0;\n\n\tinst = (GF_ProtoInstance *) node;\n\t/*check in interface if this is ISed */\n\ti=0;\n\twhile ((r = (GF_Route*)gf_list_enum(inst->proto_interface->sub_graph->Routes, &i))) {\n\t\tif (!r->IS_route) continue;\n\t\t/*only check eventIn/field/exposedField*/\n\t\tif (r->FromNode || (r->FromField.fieldIndex != field->fieldIndex)) continue;\n\n\t\tgf_node_get_field(r->ToNode, r->ToField.fieldIndex, &inf);\n\t\t/*IS to another proto*/\n\t\tif (r->ToNode->sgprivate->tag == TAG_ProtoNode) {\n\t\t\tif (r->ToNode==node) continue;\n\t\t\treturn gf_sg_proto_field_is_sftime_offset(r->ToNode, &inf);\n\t\t}\n\t\t/*IS to a startTime/stopTime field*/\n\t\tif (!stricmp(inf.name, \"startTime\") || !stricmp(inf.name, \"stopTime\")) return 1;\n\t}\n\treturn 0;\n}\n\nGF_EXPORT\nGF_Err gf_node_proto_set_grouping(GF_Node *node)\n{\n\tif (!node || (node->sgprivate->tag!=TAG_ProtoNode)) return GF_BAD_PARAM;\n\t((GF_ProtoInstance *)node)->flags |= GF_SG_PROTO_IS_GROUPING;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nBool gf_node_proto_is_grouping(GF_Node *node)\n{\n\tif (!node || (node->sgprivate->tag!=TAG_ProtoNode)) return 0;\n\tif ( ((GF_ProtoInstance *)node)->flags & GF_SG_PROTO_IS_GROUPING) return 1;\n\treturn 0;\n}\n\nGF_EXPORT\nGF_Node *gf_node_get_proto_root(GF_Node *node)\n{\n\tif (!node || (node->sgprivate->tag!=TAG_ProtoNode)) return NULL;\n\treturn ((GF_ProtoInstance *)node)->RenderingNode;\n}\n\n#if 0 //unused\nGF_Node *gf_node_get_proto_parent(GF_Node *node)\n{\n\tif (!node) return NULL;\n\tif (node->sgprivate->scenegraph->pOwningProto) {\n\t\tGF_Node *the_node = (GF_Node *) node->sgprivate->scenegraph->pOwningProto;\n\t\tif (the_node != node) return the_node;\n\t}\n\treturn NULL;\n}\n\nBool gf_node_is_proto_root(GF_Node *node)\n{\n\tif (!node) return 0;\n\tif (!node->sgprivate->scenegraph->pOwningProto) return 0;\n\n\tif (gf_list_find(node->sgprivate->scenegraph->pOwningProto->node_code, node)>=0) return 1;\n\treturn 0;\n}\n#endif\n\n\nGF_EXPORT\nGF_Err gf_node_set_proto_eventin_handler(GF_Node *node, u32 fieldIndex, void (*event_in_cbk)(GF_Node *pThis, struct _route *route) )\n{\n\tGF_ProtoInstance *inst;\n\tGF_ProtoField *field;\n\tif (!node || (node->sgprivate->tag!=TAG_ProtoNode)) return GF_BAD_PARAM;\n\n\tinst = (GF_ProtoInstance *) node;\n\tfield = (GF_ProtoField*)gf_list_get(inst->fields, fieldIndex);\n\tif (!field) return GF_BAD_PARAM;\n\n\tif (field->EventType!=GF_SG_EVENT_IN) return GF_BAD_PARAM;\n\tfield->on_event_in = event_in_cbk;\n\treturn GF_OK;\n}\n\n\n\n#endif\t/*GPAC_DISABLE_VRML*/\n"], "filenames": ["src/scenegraph/vrml_proto.c"], "buggy_code_start_loc": [1295], "buggy_code_end_loc": [1296], "fixing_code_start_loc": [1295], "fixing_code_end_loc": [1299], "type": "CWE-121", "message": "Stack-based Buffer Overflow in GitHub repository gpac/gpac prior to 2.2.", "other": {"cve": {"id": "CVE-2023-0770", "sourceIdentifier": "security@huntr.dev", "published": "2023-02-09T22:15:11.170", "lastModified": "2023-05-27T04:15:23.577", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Stack-based Buffer Overflow in GitHub repository gpac/gpac prior to 2.2."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-121"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.2.0", "matchCriteriaId": "B4D3D58A-C3C9-4441-A84A-FB91FD19985C"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/c31941822ee275a35bc148382bafef1c53ec1c26", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/e0fdeee5-7909-446e-9bd0-db80fd80e8dd", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2023/dsa-5411", "source": "security@huntr.dev"}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/c31941822ee275a35bc148382bafef1c53ec1c26"}}