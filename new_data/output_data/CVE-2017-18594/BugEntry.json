{"buggy_code": ["/*\n* Binding for the libssh2 library. Note that there is not a one-to-one correspondance\n* between functions in libssh2 and the binding.\n* Currently, during the ssh2 handshake, a call to nsock.receive may result in an EOF\n* error. This appears to only occur when stressing the ssh server (ie during a brute\n* force attempt) or while behind a restrictive firewall/IDS.\n* by Devin Bjelland\n*/\n\nextern \"C\" {\n#include \"libssh2.h\"\n}\n#include \"nse_lua.h\"\n\n#include \"nse_debug.h\"\n#include \"nse_nsock.h\"\n#include \"nse_utility.h\"\n\n#include <fcntl.h>\n#include <assert.h>\n#include <errno.h>\n#include <stdio.h>\n#include <string.h>\n\n#ifdef WIN32\n#include <Windows.h>\n#include <stdio.h>\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#include <Fcntl.h>\n#include <io.h>\n#include <assert.h>\n#else\n#include <netdb.h>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#endif\n\n\nenum {\n    SSH2_UDATA = lua_upvalueindex(1)\n};\n\n#ifdef WIN32\nstruct ssh_userdata {\n    SOCKET sp[2];\n    LIBSSH2_SESSION *session;\n};\n#else\nstruct ssh_userdata {\n    int sp[2];\n    LIBSSH2_SESSION *session;\n};\n#endif\n\n\n#if defined(_MSC_VER) && _MSC_VER < 1900\n#define snprintf c99_snprintf\n#define vsnprintf c99_vsnprintf\n\n__inline int c99_vsnprintf(char *outBuf, size_t size, const char *format, va_list ap) {\n    int count = -1;\n\n    if (size != 0)\n        count = _vsnprintf_s(outBuf, size, _TRUNCATE, format, ap);\n    if (count == -1)\n        count = _vscprintf(format, ap);\n\n    return count;\n}\n\n__inline int c99_snprintf(char *outBuf, size_t size, const char *format, ...) {\n    int count;\n    va_list ap;\n\n    va_start(ap, format);\n    count = c99_vsnprintf(outBuf, size, format, ap);\n    va_end(ap);\n\n    return count;\n}\n#endif\n\n#ifdef WIN32\n/*\n*   make_socketpair:\n*   If make_overlapped is nonzero, both sockets created will be usable for\n*   \"overlapped\" operations via WSASend etc.  If make_overlapped is zero,\n*   socks[0] (only) will be usable with regular ReadFile etc., and thus\n*   suitable for use as stdin or stdout of a child process.  Note that the\n*   sockets must be closed with closesocket() regardless.\n*/\n\nint make_socketpair (SOCKET socks[2], int make_overlapped) {\n    union {\n        struct sockaddr_in inaddr;\n        struct sockaddr addr;\n    } a;\n    SOCKET listener;\n    int e;\n    socklen_t addrlen = sizeof(a.inaddr);\n    DWORD flags = (make_overlapped ? WSA_FLAG_OVERLAPPED : 0);\n    int reuse = 1;\n\n    if (socks == 0) {\n        WSASetLastError(WSAEINVAL);\n        return SOCKET_ERROR;\n    }\n    socks[0] = socks[1] = -1;\n\n    listener = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n    if (listener == -1)\n        return SOCKET_ERROR;\n\n    memset(&a, 0, sizeof(a));\n    a.inaddr.sin_family = AF_INET;\n    a.inaddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n    a.inaddr.sin_port = 0;\n\n    for (;;) {\n        if (setsockopt(listener, SOL_SOCKET, SO_REUSEADDR,\n            (char*)&reuse, (socklen_t) sizeof(reuse)) == -1)\n            break;\n        if (bind(listener, &a.addr, sizeof(a.inaddr)) == SOCKET_ERROR)\n            break;\n\n        memset(&a, 0, sizeof(a));\n        if (getsockname(listener, &a.addr, &addrlen) == SOCKET_ERROR)\n            break;\n        // win32 getsockname may only set the port number, p=0.0005.\n        // ( http://msdn.microsoft.com/library/ms738543.aspx ):\n        a.inaddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n        a.inaddr.sin_family = AF_INET;\n\n        if (listen(listener, 1) == SOCKET_ERROR)\n            break;\n\n        socks[0] = WSASocket(AF_INET, SOCK_STREAM, 0, NULL, 0, flags);\n        if (socks[0] == -1)\n            break;\n        if (connect(socks[0], &a.addr, sizeof(a.inaddr)) == SOCKET_ERROR)\n            break;\n\n        socks[1] = accept(listener, NULL, NULL);\n        if (socks[1] == -1)\n            break;\n\n        closesocket(listener);\n        return 0;\n    }\n\n    e = WSAGetLastError();\n    closesocket(listener);\n    closesocket(socks[0]);\n    closesocket(socks[1]);\n    WSASetLastError(e);\n    socks[0] = socks[1] = -1;\n    //return SOCKET_ERROR;\n\n    return -1;\n}\n#else\nint make_socketpair (int socks[2], int dummy) {\n    if (socks == 0) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    dummy = socketpair(AF_UNIX, SOCK_STREAM, 0, socks);\n\n    if (dummy) {\n        socks[0] = socks[1] = -1;\n    }\n\n    return dummy;\n}\n#endif\n\n\nstatic int ssh_error (lua_State *L, LIBSSH2_SESSION *session, const char *msg) {\n    char *errmsg;\n    libssh2_session_last_error(session, &errmsg, NULL, 0);\n\n    return nseU_safeerror(L, \"%s: %s\", msg, errmsg);\n}\n\nstatic int finish_send (lua_State *L, int status, lua_KContext ctx) {\n    if (lua_toboolean(L, -2))\n        return 0;\n    else\n        return lua_error(L); /* uses idx 6 */\n}\n\nstatic int finish_read (lua_State *L, int status, lua_KContext ctx) {\n    int rc;\n    struct ssh_userdata *sshu = NULL;\n\n    sshu = (struct ssh_userdata *) nseU_checkudata(L, 1, SSH2_UDATA, \"ssh2\");\n\n    if (lua_toboolean(L, -2)) {\n        size_t n = 0;\n        size_t l = 0;\n        lua_getuservalue(L, 1);\n        lua_getfield(L, -1, \"sp_buff\");\n        lua_pushvalue(L, 3);\n        lua_concat(L, 2);\n        const char *data = lua_tolstring(L, -1, &l);\n        lua_pushliteral(L, \"\");\n        lua_setfield(L, 4, \"sp_buff\");\n\n        while (n < l) {\n#ifdef WIN32\n            rc = send(sshu->sp[1], data + n, l - n, 0);\n#else\n            rc = write(sshu->sp[1], data + n, l - n);\n#endif\n            if (rc == -1 && errno != EAGAIN) {\n                luaL_error(L, \"Writing to socket pair: %s\", strerror(errno));\n            }\n            else if (rc == -1 && errno == EAGAIN) {\n                lua_pushlstring(L, data + n, l - n);\n                lua_setfield(L, 4, \"sp_buff\");\n                break;\n            }\n            else {\n                n += rc;\n            }\n        }\n        return 0;\n    }\n    else {\n        return lua_error(L); /* uses idx 6 */\n    }\n}\n\nstatic int filter (lua_State *L) {\n    int rc;\n    char data[4096];\n    struct ssh_userdata *sshu = NULL;\n\n    sshu = (struct ssh_userdata *) nseU_checkudata(L, 1, SSH2_UDATA, \"ssh2\");\n\n    lua_getuservalue(L, 1);\n    lua_getfield(L, -1, \"sock\");\n    lua_replace(L, -2);\n\n#ifdef WIN32\n    rc = recv(sshu->sp[1], data, sizeof(data), 0);\n\n    if (WSAGetLastError() == WSAEWOULDBLOCK)\n        rc = 0;\n#else\n    rc = read(sshu->sp[1], data, sizeof(data));\n#endif\n\n    if (rc > 0) {\n        //write data to nsock socket\n        lua_getfield(L, -1, \"send\");\n        lua_insert(L, -2); /* swap */\n        lua_pushlstring(L, data, rc);\n\n        assert(lua_status(L) == LUA_OK);\n        lua_callk(L, 2, 2, 0, finish_send);\n\n        return finish_send(L,0,0);\n    }\n    else if (rc == -1 && errno != EAGAIN)\n        return luaL_error(L, \"%s\", strerror(errno));\n\n    lua_getfield(L, -1, \"receive\");\n    lua_insert(L, -2); /* swap */\n\n    assert(lua_status(L) == LUA_OK);\n    lua_callk(L, 1, 2, 0, finish_read);\n\n    return finish_read(L, 0, 0);\n}\n\nstatic int do_session_handshake (lua_State *L, int status, lua_KContext ctx) {\n    int rc;\n    struct ssh_userdata *sshu = NULL;\n\n    assert(lua_gettop(L) == 4);\n    sshu = (struct ssh_userdata *) nseU_checkudata(L, 3, SSH2_UDATA, \"ssh2\");\n\n    while ((rc = libssh2_session_handshake(sshu->session, sshu->sp[0])) == LIBSSH2_ERROR_EAGAIN) {\n        luaL_getmetafield(L, 3, \"filter\");\n        lua_pushvalue(L, 3);\n\n        assert(lua_status(L) == LUA_OK);\n        lua_callk(L, 1, 0, 0, do_session_handshake);\n    }\n\n    if (rc) {\n        libssh2_session_free(sshu->session);\n        return luaL_error(L, \"Unable to complete libssh2 handshake.\");\n    }\n\n    // lua_pushvalue(L, 3);\n    lua_settop(L, 3);\n\n    return 1;\n}\n\nstatic int finish_session_open (lua_State *L, int status, lua_KContext ctx) {\n    assert(lua_gettop(L) == 6);\n    if (lua_toboolean(L, -2)) {\n        lua_pop(L, 2);\n        return do_session_handshake(L,0,0);\n    }\n    else {\n        struct ssh_userdata *state = NULL;\n\n        state = (struct ssh_userdata *) nseU_checkudata(L, 3, SSH2_UDATA, \"ssh2\");\n        if (state->session != NULL) {\n            libssh2_session_free(state->session);\n            state->session = NULL;\n        }\n        return lua_error(L);\n    }\n}\n\n/*\n* Creates libssh2 session, connects to hostname:port and tries to perform a\n* ssh handshake on socket. Returns ssh_state on success, nil on failure.\n*\n* session_open(hostname, port)\n*/\nstatic int l_session_open (lua_State *L) {\n    int rc;\n    ssh_userdata *state = NULL;\n\n    luaL_checkinteger(L, 2);\n    lua_settop(L, 2);\n\n    state = (ssh_userdata *)lua_newuserdata(L, sizeof(ssh_userdata)); /* index 3 */\n\n    assert(lua_gettop(L) == 3);\n    state->session = NULL;\n    state->sp[0] = -1;\n    state->sp[1] = -1;\n    lua_pushvalue(L, lua_upvalueindex(1)); /* metatable */\n    lua_setmetatable(L, 3);\n\n    lua_newtable(L);\n    lua_setuservalue(L, 3);\n    lua_getuservalue(L, 3); /* index 4 - a table associated with userdata*/\n    assert(lua_gettop(L) == 4);\n\n    state->session = libssh2_session_init();\n\n    if (state->session == NULL) {\n        // A session could not be created because of memory limit\n        return nseU_safeerror(L, \"trying to initiate session\");\n    }\n\n    libssh2_session_set_blocking(state->session, 0);\n\n    if (make_socketpair(state->sp, 1) == -1)\n        return nseU_safeerror(L, \"trying to create socketpair\");\n\n#ifdef WIN32\n    unsigned long s_mode = 1; // non-blocking\n\n    rc = ioctlsocket(state->sp[1], FIONBIO, (unsigned long *)&s_mode);\n    if (rc != NO_ERROR)\n        return nseU_safeerror(L, \"%s\", strerror(errno));\n#else\n    // get file descriptor flags\n    rc = fcntl(state->sp[1], F_GETFD);\n    if (rc == -1)\n        return nseU_safeerror(L, \"%s\", strerror(errno));\n\n    // add non-blocking flag and update file descriptor flags\n    rc |= O_NONBLOCK;\n    rc = fcntl(state->sp[1], F_SETFL, rc);\n    if (rc == -1)\n        return nseU_safeerror(L, \"%s\", strerror(errno));\n#endif\n\n    lua_getglobal(L, \"nmap\");\n    lua_getfield(L, -1, \"new_socket\");\n    lua_replace(L, -2);\n    lua_call(L, 0, 1);\n    lua_setfield(L, 4, \"sock\");\n    lua_pushliteral(L, \"\");\n    lua_setfield(L, 4, \"sp_buff\");\n    assert(lua_gettop(L) == 4);\n\n    lua_getfield(L, 4, \"sock\");\n    lua_getfield(L, -1, \"connect\");\n    lua_insert(L, -2); /* swap */\n    lua_pushvalue(L, 1);\n    lua_pushvalue(L, 2);\n    lua_callk(L, 3, 2, 3, finish_session_open);\n    return finish_session_open(L,0,0);\n}\n\n/*\n* Returns the SHA1 or MD5 hostkey hash of provided session or nil if it is not available\n*/\nstatic int l_hostkey_hash (lua_State *L) {\n    luaL_Buffer B;\n    static int hash_option[] = { LIBSSH2_HOSTKEY_HASH_MD5, LIBSSH2_HOSTKEY_HASH_SHA1 };\n    static int hash_length[] = { 16, 20 };\n    static const char *hashes[] = { \"md5\", \"sha1\", NULL };\n    int type = luaL_checkoption(L, 2, \"sha1\", hashes);\n    struct ssh_userdata *state = NULL;\n    const unsigned char *hash = NULL;\n\n    state = (struct ssh_userdata *) nseU_checkudata(L, 1, SSH2_UDATA, \"ssh2\");\n    hash = (const unsigned char *) libssh2_hostkey_hash(state->session, hash_option[type]);\n\n    if (hash == NULL)\n        return nseU_safeerror(L, \"could not get hostkey hash\");\n\n    luaL_buffinit(L, &B);\n    for (int i = 0; i < hash_length[type]; i++) {\n        char byte[3]; /* with space for NULL */\n        snprintf(byte, sizeof(byte), \"%02X\", (unsigned int)hash[i]);\n        if (i)\n            luaL_addchar(&B, ':');\n        luaL_addlstring(&B, byte, 2);\n    }\n    luaL_pushresult(&B);\n\n    return 1;\n}\n\nstatic int l_set_timeout(lua_State *L) {\n    long timeout = luaL_checkinteger(L, 2);\n    struct ssh_userdata *state = NULL;\n    state = (struct ssh_userdata *) nseU_checkudata(L, 1, SSH2_UDATA, \"ssh2\");\n\n    libssh2_session_set_timeout(state->session, timeout);\n\n    return 0;\n}\n\nstatic int userauth_list (lua_State *L, int status, lua_KContext ctx) {\n    char *auth_list = NULL;\n    struct ssh_userdata *state = NULL;\n    const char *username = luaL_checkstring(L, 2);\n\n    state = (struct ssh_userdata *) nseU_checkudata(L, 1, SSH2_UDATA, \"ssh2\");\n    assert(state->session != NULL);\n\n    while ((auth_list = libssh2_userauth_list(state->session, username, lua_rawlen(L, 2))) == NULL\n        && libssh2_session_last_errno(state->session) == LIBSSH2_ERROR_EAGAIN) {\n        luaL_getmetafield(L, 1, \"filter\");\n        lua_pushvalue(L, 1);\n\n        assert(lua_status(L) == LUA_OK);\n        lua_callk(L, 1, 0, 0, userauth_list);\n    }\n\n    if (auth_list) {\n        const char *auth = strtok(auth_list, \",\");\n        lua_newtable(L);\n        do {\n            lua_pushstring(L, auth);\n            lua_rawseti(L, -2, lua_rawlen(L, -2) + 1);\n        }\n        while ((auth = strtok(NULL, \",\")));\n\n        //libssh2_free(state->session, (void *)auth_list);\n    }\n    else if (libssh2_userauth_authenticated(state->session)) {\n        lua_pushliteral(L, \"none_auth\");\n    }\n    else {\n        return ssh_error(L, state->session, \"userauth_list\");\n    }\n\n    return 1;\n}\n\n/*\n* Returns list of supported authenication methods\n*/\nstatic int l_userauth_list (lua_State *L) {\n    return userauth_list(L, 0, 0);\n}\n\nstatic int userauth_publickey (lua_State *L, int status, lua_KContext ctx) {\n    int rc;\n    const char *username, *private_key_file, *passphrase, *public_key_file;\n    struct ssh_userdata *state = NULL;\n    state = (struct ssh_userdata *) nseU_checkudata(L, 1, SSH2_UDATA, \"ssh2\");\n\n    username = luaL_checkstring(L, 2);\n    private_key_file = luaL_checkstring(L, 3);\n\n    if (lua_isstring(L, 4))\n        passphrase = lua_tostring(L, 4);\n    else\n        passphrase = NULL;\n\n    if (lua_isstring(L, 5))\n        public_key_file = lua_tostring(L, 5);\n    else\n        public_key_file = NULL;\n\n    while ((rc = libssh2_userauth_publickey_fromfile(\n        state->session, username, public_key_file, private_key_file, passphrase\n        )) == LIBSSH2_ERROR_EAGAIN) {\n        luaL_getmetafield(L, 1, \"filter\");\n        lua_pushvalue(L, 1);\n\n        assert(lua_status(L) == LUA_OK);\n        lua_callk(L, 1, 0, 0, userauth_publickey);\n    }\n\n    if (rc == 0)\n        lua_pushboolean(L, 1);\n    else\n        lua_pushboolean(L, 0);\n\n    return 1;\n}\n\nstatic int l_userauth_publickey (lua_State *L) {\n    return userauth_publickey(L, 0, 0);\n}\n\nstatic int l_read_publickey (lua_State *L) {\n    FILE *fd;\n    char c;\n    const char* publickeyfile = luaL_checkstring(L, 1);\n    luaL_Buffer publickey_data;\n\n    fd = fopen(publickeyfile, \"r\");\n    if (!fd)\n        return luaL_error(L, \"Error reading file\");\n\n    luaL_buffinit(L, &publickey_data);\n    while (fread(&c, 1, 1, fd) && c!= '\\r' && c != '\\n' && c != ' ') {\n        continue;\n    }\n    while (fread(&c, 1, 1, fd) && c!= '\\r' && c != '\\n' && c != ' ') {\n        luaL_addchar(&publickey_data, c);\n    }\n    fclose(fd);\n\n    lua_getglobal(L, \"require\");\n    lua_pushstring(L, \"base64\");\n    lua_call(L, 1, 1);\n    lua_getfield(L, -1, \"dec\");\n\n    luaL_pushresult(&publickey_data);\n    lua_call(L, 1, 1);\n\n    return 1;\n}\n\nstatic int publickey_canauth_cb (LIBSSH2_SESSION *session, unsigned char **sig,\n    size_t *sig_len, const unsigned char *data, size_t data_len, void **abstract) {\n    return 0;\n}\n\nstatic int publickey_canauth (lua_State *L, int status, lua_KContext ctx) {\n    int rc;\n    int errlen;\n    char *errmsg;\n    const char *username;\n    unsigned const char *publickey_data;\n    size_t len = 0;\n    struct ssh_userdata *state;\n\n    state = (struct ssh_userdata *) nseU_checkudata(L, 1, SSH2_UDATA, \"ssh2\");\n    username = luaL_checkstring(L, 2);\n\n    if (lua_isstring(L, 3))\n        publickey_data = (unsigned const char*)lua_tolstring(L, 3, &len);\n    else\n        return luaL_error(L, \"Invalid public key\");\n\n    while ((rc = libssh2_userauth_publickey(state->session,\n        username, publickey_data, len, &publickey_canauth_cb, NULL)) == LIBSSH2_ERROR_EAGAIN) {\n        luaL_getmetafield(L, 1, \"filter\");\n        lua_pushvalue(L, 1);\n\n        assert(lua_status(L) == LUA_OK);\n        lua_callk(L, 1, 0, 0, publickey_canauth);\n    }\n\n    libssh2_session_last_error(state->session, &errmsg, &errlen, 0);\n\n    if (rc == LIBSSH2_ERROR_ALLOC || rc == LIBSSH2_ERROR_PUBLICKEY_UNVERIFIED)\n        lua_pushboolean(L, 1); //Username/PublicKey combination invalid\n    else if (rc == LIBSSH2_ERROR_AUTHENTICATION_FAILED)\n        lua_pushboolean(L, 0);\n    else\n        return luaL_error(L, \"Invalid Publickey\");\n\n    return 1;\n}\n\nstatic int l_publickey_canauth (lua_State *L) {\n    return publickey_canauth(L, 0, 0);\n}\n\n/*\n* Attempts to authenticate session with provided username and password\n* returns true on success and false otherwise\n*\n* userauth_password(state, username, password)\n*/\nstatic int userauth_password (lua_State *L, int status, lua_KContext ctx) {\n    int rc;\n    const char *username, *password;\n    struct ssh_userdata *state;\n\n    state = (struct ssh_userdata *) nseU_checkudata(L, 1, SSH2_UDATA, \"ssh2\");\n    username = luaL_checkstring(L, 2);\n    password = luaL_checkstring(L, 3);\n\n    assert(state->session != NULL);\n    while ((rc = libssh2_userauth_password(state->session,\n        username, password)) == LIBSSH2_ERROR_EAGAIN) {\n        luaL_getmetafield(L, 1, \"filter\");\n        lua_pushvalue(L, 1);\n\n        assert(lua_status(L) == LUA_OK);\n        lua_callk(L, 1, 0, 0, userauth_password);\n    }\n\n    if (rc == 0)\n        lua_pushboolean(L, 1);\n    else\n        lua_pushboolean(L, 0);\n\n    return 1;\n}\n\nstatic int l_userauth_password (lua_State *L) {\n    return userauth_password(L, 0, 0);\n}\n\nstatic int session_close (lua_State *L, int status, lua_KContext ctx) {\n    int rc;\n    struct ssh_userdata *state;\n\n    state = (struct ssh_userdata *) nseU_checkudata(L, 1, SSH2_UDATA, \"ssh2\");\n\n    if (state->session != NULL) {\n        while ((rc = libssh2_session_disconnect(\n            state->session, \"Normal Shutdown\")) == LIBSSH2_ERROR_EAGAIN) {\n            luaL_getmetafield(L, 1, \"filter\");\n            lua_pushvalue(L, 1);\n\n            assert(lua_status(L) == LUA_OK);\n            lua_callk(L, 1, 0, 0, session_close);\n        }\n\n        if (rc < 0)\n            return luaL_error(L, \"unable to disconnect session\");\n\n        if (libssh2_session_free(state->session) < 0)\n            return luaL_error(L, \"unable to free session\");\n\n        state->session = NULL;\n    }\n\n    return 0;\n}\n\nstatic int l_session_close (lua_State *L) {\n    return session_close(L, 0, 0);\n}\n\nstatic int channel_read (lua_State *L, int status, lua_KContext ctx) {\n    int rc;\n    char buf[2048];\n    size_t buflen = 2048;\n    LIBSSH2_CHANNEL **channel = (LIBSSH2_CHANNEL **) lua_touserdata(L, 2);\n\n    while ((rc = libssh2_channel_read(*channel, buf, buflen)) == LIBSSH2_ERROR_EAGAIN) {\n        luaL_getmetafield(L, 1, \"filter\");\n        lua_pushvalue(L, 1);\n        lua_callk(L, 1, 0, 0, channel_read);\n    }\n\n    if (rc > 0) {\n        lua_pushlstring(L, buf, rc);\n        return 1;\n    }\n    else if (rc < 0)\n        return luaL_error(L, \"Reading from channel\");\n\n    lua_pushnil(L);\n\n    return 1;\n}\n\nstatic int l_channel_read (lua_State *L) {\n    return channel_read(L, 0, 0);\n}\n\nstatic int l_channel_read_stderr(lua_State *L) {\n    int rc;\n    char buf[2048];\n    size_t buflen = 2048;\n    LIBSSH2_CHANNEL **channel = (LIBSSH2_CHANNEL **) lua_touserdata(L, 2);\n\n    while ((rc = libssh2_channel_read_stderr(*channel, buf, buflen)) == LIBSSH2_ERROR_EAGAIN) {\n        luaL_getmetafield(L, 1, \"filter\");\n        lua_pushvalue(L, 1);\n        lua_callk(L, 1, 0, 0, channel_read);\n    }\n\n    if (rc > 0) {\n        lua_pushlstring(L, buf, rc);\n        return 1;\n    }\n    else if (rc < 0)\n        return luaL_error(L, \"Reading from channel\");\n\n    lua_pushnil(L);\n    return 1;\n}\n\nstatic int channel_write (lua_State *L, int status, lua_KContext ctx) {\n    int rc;\n    const char *buf;\n    size_t buflen = 0;\n    LIBSSH2_CHANNEL **channel = (LIBSSH2_CHANNEL **) lua_touserdata(L, 2);\n\n    if (lua_isstring(L, 3))\n        buf = lua_tolstring(L, 3, &buflen);\n    else\n        return luaL_error(L, \"Invalid buffer\");\n\n    while ((rc = libssh2_channel_write(*channel, buf, buflen)) == LIBSSH2_ERROR_EAGAIN) {\n        luaL_getmetafield(L, 1, \"filter\");\n        lua_pushvalue(L, 1);\n        lua_callk(L, 1, 0, 0, channel_write);\n    }\n\n    if (rc < 0)\n        return luaL_error(L, \"Writing to channel\");\n\n    lua_pushinteger(L, rc);\n    return 1;\n}\n\nstatic int l_channel_write (lua_State *L) {\n    return channel_write(L, 0, 0);\n}\n\nstatic int channel_exec (lua_State *L, int status, lua_KContext ctx) {\n    int rc;\n    // ssh_userdata *state = (ssh_userdata *)lua_touserdata(L, 1);\n    LIBSSH2_CHANNEL **channel = (LIBSSH2_CHANNEL **) lua_touserdata(L, 2);\n    const char *cmd = luaL_checkstring(L, 3);\n\n    while ((rc = libssh2_channel_exec(*channel, cmd)) == LIBSSH2_ERROR_EAGAIN) {\n        luaL_getmetafield(L, 1, \"filter\");\n        lua_pushvalue(L, 1);\n        lua_callk(L, 1, 0, 0, channel_exec);\n    }\n    if (rc != 0)\n        return luaL_error(L, \"Error executing command\");\n\n   return 0;\n}\n\nstatic int l_channel_exec (lua_State *L) {\n    return channel_exec(L, 0, 0);\n}\n\nstatic int l_channel_eof(lua_State *L) {\n    int result;\n    LIBSSH2_CHANNEL **channel = (LIBSSH2_CHANNEL **) lua_touserdata(L, 1);\n\n    result = libssh2_channel_eof(*channel);\n    if (result >= 0)\n        lua_pushboolean(L, result);\n    else\n        return luaL_error(L, \"Error checking for EOF\");\n\n    return 1;\n}\n\nstatic int channel_send_eof(lua_State *L, int status, lua_KContext ctx) {\n    int rc;\n    // ssh_userdata *state = (ssh_userdata *)lua_touserdata(L, 1);\n    LIBSSH2_CHANNEL **channel = (LIBSSH2_CHANNEL **) lua_touserdata(L, 2);\n\n    while ((rc = libssh2_channel_send_eof(*channel)) == LIBSSH2_ERROR_EAGAIN) {\n        luaL_getmetafield(L, 1, \"filter\");\n        lua_pushvalue(L, 1);\n        lua_callk(L, 1, 0, 0, channel_send_eof);\n    }\n    if (rc != 0)\n        return luaL_error(L, \"Error sending EOF\");\n\n    return 0;\n}\n\nstatic int l_channel_send_eof(lua_State *L) {\n    return channel_send_eof(L, 0, 0);\n}\n\nstatic int setup_channel(lua_State *L, int status, lua_KContext ctx) {\n    int rc;\n    // ssh_userdata *state = (ssh_userdata *)lua_touserdata(L, 1);\n    LIBSSH2_CHANNEL **channel = (LIBSSH2_CHANNEL **) lua_touserdata(L, 2);\n\n    while ((rc = libssh2_channel_request_pty(*channel, \"vanilla\")) == LIBSSH2_ERROR_EAGAIN) {\n        luaL_getmetafield(L, 1, \"filter\");\n        lua_pushvalue(L, 1);\n        lua_callk(L, 1, 0, 0, setup_channel);\n    }\n    if (rc != 0)\n        return luaL_error(L, \"Requesting pty\");\n\n    return 1;\n}\n\nstatic int l_setup_channel (lua_State *L) {\n    return setup_channel(L, 0, 0);\n}\n\nstatic int finish_open_channel (lua_State *L, int status, lua_KContext ctx) {\n    ssh_userdata *state = (ssh_userdata *)lua_touserdata(L, 1);\n    LIBSSH2_CHANNEL **channel = (LIBSSH2_CHANNEL **) lua_touserdata(L, 2);\n\n    while ((*channel = libssh2_channel_open_session(state->session)) == NULL\n    && libssh2_session_last_errno(state->session) == LIBSSH2_ERROR_EAGAIN) {\n        luaL_getmetafield(L, 1, \"filter\");\n        lua_pushvalue(L, 1);\n        lua_callk(L, 1, 0, 0, finish_open_channel);\n    }\n    if (channel == NULL)\n        return luaL_error(L, \"Opening channel\");\n\n    return setup_channel(L, 0, 0);\n}\n\nstatic int l_open_channel (lua_State *L) {\n    ssh_userdata *state = (ssh_userdata *)lua_touserdata(L, 1);\n    LIBSSH2_CHANNEL **channel = (LIBSSH2_CHANNEL **)lua_newuserdata(L, sizeof(LIBSSH2_CHANNEL *));\n\n    while ((*channel = libssh2_channel_open_session(state->session)) == NULL\n    && libssh2_session_last_errno(state->session) == LIBSSH2_ERROR_EAGAIN) {\n        luaL_getmetafield(L, 1, \"filter\");\n        lua_pushvalue(L, 1);\n        lua_callk(L, 1, 0, 0, finish_open_channel);\n    }\n\n    return l_setup_channel(L);\n}\n\nstatic int channel_close (lua_State *L, int status, lua_KContext ctx) {\n    int rc;\n    // ssh_userdata *state = (ssh_userdata *)lua_touserdata(L, 1);\n    LIBSSH2_CHANNEL **channel = (LIBSSH2_CHANNEL **) lua_touserdata(L, 2);\n\n    while ((rc = libssh2_channel_close(*channel)) == LIBSSH2_ERROR_EAGAIN) {\n        luaL_getmetafield(L, 1, \"filter\");\n        lua_pushvalue(L, 1);\n        lua_callk(L, 1, 0, 0, channel_close);\n    }\n    if (rc != 0)\n        return luaL_error(L, \"Error closing channel\");;\n\n    return 0;\n}\n\nstatic int l_channel_close (lua_State *L) {\n    return channel_close(L, 0, 0);\n}\n\nstatic const struct luaL_Reg libssh2[] = {\n    { \"session_open\", l_session_open },\n    { \"hostkey_hash\", l_hostkey_hash },\n    { \"set_timeout\", l_set_timeout },\n    { \"userauth_list\", l_userauth_list },\n    { \"userauth_publickey\", l_userauth_publickey },\n    { \"read_publickey\", l_read_publickey },\n    { \"publickey_canauth\", l_publickey_canauth },\n    { \"userauth_password\", l_userauth_password },\n    { \"session_close\", l_session_close },\n    { \"open_channel\", l_open_channel},\n    { \"channel_read\", l_channel_read},\n    { \"channel_read_stderr\", l_channel_read_stderr},\n    { \"channel_write\", l_channel_write},\n    { \"channel_exec\", l_channel_exec},\n    { \"channel_send_eof\", l_channel_send_eof},\n    { \"channel_eof\", l_channel_eof},\n    { \"channel_close\", l_channel_close},\n    { NULL, NULL }\n};\n\nstatic int gc (lua_State *L) {\n    struct ssh_userdata *sshu = NULL;\n\n    sshu = (struct ssh_userdata *) nseU_checkudata(L, 1, SSH2_UDATA, \"ssh2\");\n    if (!sshu) { return 0; }\n    if (sshu) {\n        // lua_pushvalue(L, lua_upvalueindex(1));\n        // lua_getfield(L, -1, \"session_close\");\n        // lua_insert(L, -2); /* swap */\n        // lua_pcall(L, 1, 0, 0); /* if an error occurs, don't do anything */\n\n        if (sshu->session != NULL) {\n            if (libssh2_session_free(sshu->session) < 0) {\n                // Unable to free libssh2 session\n            }\n            sshu->session = NULL;\n        }\n    }\n\n#ifdef WIN32\n    closesocket(sshu->sp[0]);\n    closesocket(sshu->sp[1]);\n#else\n    close(sshu->sp[0]);\n    close(sshu->sp[1]);\n#endif\n\n    return 0;\n}\n\nint luaopen_libssh2 (lua_State *L) {\n    lua_settop(L, 0); /* clear the stack */\n\n    luaL_newlibtable(L, libssh2);\n\n    lua_newtable(L); /* ssh2 session metatable */\n    lua_pushvalue(L, -1);\n    lua_pushcclosure(L, gc, 1);\n    lua_setfield(L, -2, \"__gc\");\n    lua_pushvalue(L, -1);\n    lua_pushcclosure(L, filter, 1);\n    lua_setfield(L, -2, \"filter\");\n\n    luaL_setfuncs(L, libssh2, 1);\n\n    static bool libssh2_initialized = false;\n    if (!libssh2_initialized && (libssh2_init(0) != 0))\n        luaL_error(L, \"unable to open libssh2\");\n    libssh2_initialized = true;\n\n    return 1;\n}\n"], "fixing_code": ["/*\n* Binding for the libssh2 library. Note that there is not a one-to-one correspondance\n* between functions in libssh2 and the binding.\n* Currently, during the ssh2 handshake, a call to nsock.receive may result in an EOF\n* error. This appears to only occur when stressing the ssh server (ie during a brute\n* force attempt) or while behind a restrictive firewall/IDS.\n* by Devin Bjelland\n*/\n\nextern \"C\" {\n#include \"libssh2.h\"\n}\n#include \"nse_lua.h\"\n\n#include \"nse_nsock.h\"\n#include \"nse_utility.h\"\n\n#include <fcntl.h>\n#include <assert.h>\n#include <errno.h>\n#include <stdio.h>\n#include <string.h>\n\n#ifdef WIN32\n#include <Windows.h>\n#include <stdio.h>\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#include <Fcntl.h>\n#include <io.h>\n#include <assert.h>\n#else\n#include <netdb.h>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#endif\n\n\nenum {\n    SSH2_UDATA = lua_upvalueindex(1)\n};\n\n#ifdef WIN32\nstruct ssh_userdata {\n    SOCKET sp[2];\n    LIBSSH2_SESSION *session;\n};\n#else\nstruct ssh_userdata {\n    int sp[2];\n    LIBSSH2_SESSION *session;\n};\n#endif\n\n\n#if defined(_MSC_VER) && _MSC_VER < 1900\n#define snprintf c99_snprintf\n#define vsnprintf c99_vsnprintf\n\n__inline int c99_vsnprintf(char *outBuf, size_t size, const char *format, va_list ap) {\n    int count = -1;\n\n    if (size != 0)\n        count = _vsnprintf_s(outBuf, size, _TRUNCATE, format, ap);\n    if (count == -1)\n        count = _vscprintf(format, ap);\n\n    return count;\n}\n\n__inline int c99_snprintf(char *outBuf, size_t size, const char *format, ...) {\n    int count;\n    va_list ap;\n\n    va_start(ap, format);\n    count = c99_vsnprintf(outBuf, size, format, ap);\n    va_end(ap);\n\n    return count;\n}\n#endif\n\n#ifdef WIN32\n/*\n*   make_socketpair:\n*   If make_overlapped is nonzero, both sockets created will be usable for\n*   \"overlapped\" operations via WSASend etc.  If make_overlapped is zero,\n*   socks[0] (only) will be usable with regular ReadFile etc., and thus\n*   suitable for use as stdin or stdout of a child process.  Note that the\n*   sockets must be closed with closesocket() regardless.\n*/\n\nint make_socketpair (SOCKET socks[2], int make_overlapped) {\n    union {\n        struct sockaddr_in inaddr;\n        struct sockaddr addr;\n    } a;\n    SOCKET listener;\n    int e;\n    socklen_t addrlen = sizeof(a.inaddr);\n    DWORD flags = (make_overlapped ? WSA_FLAG_OVERLAPPED : 0);\n    int reuse = 1;\n\n    if (socks == 0) {\n        WSASetLastError(WSAEINVAL);\n        return SOCKET_ERROR;\n    }\n    socks[0] = socks[1] = -1;\n\n    listener = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n    if (listener == -1)\n        return SOCKET_ERROR;\n\n    memset(&a, 0, sizeof(a));\n    a.inaddr.sin_family = AF_INET;\n    a.inaddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n    a.inaddr.sin_port = 0;\n\n    for (;;) {\n        if (setsockopt(listener, SOL_SOCKET, SO_REUSEADDR,\n            (char*)&reuse, (socklen_t) sizeof(reuse)) == -1)\n            break;\n        if (bind(listener, &a.addr, sizeof(a.inaddr)) == SOCKET_ERROR)\n            break;\n\n        memset(&a, 0, sizeof(a));\n        if (getsockname(listener, &a.addr, &addrlen) == SOCKET_ERROR)\n            break;\n        // win32 getsockname may only set the port number, p=0.0005.\n        // ( http://msdn.microsoft.com/library/ms738543.aspx ):\n        a.inaddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n        a.inaddr.sin_family = AF_INET;\n\n        if (listen(listener, 1) == SOCKET_ERROR)\n            break;\n\n        socks[0] = WSASocket(AF_INET, SOCK_STREAM, 0, NULL, 0, flags);\n        if (socks[0] == -1)\n            break;\n        if (connect(socks[0], &a.addr, sizeof(a.inaddr)) == SOCKET_ERROR)\n            break;\n\n        socks[1] = accept(listener, NULL, NULL);\n        if (socks[1] == -1)\n            break;\n\n        closesocket(listener);\n        return 0;\n    }\n\n    e = WSAGetLastError();\n    closesocket(listener);\n    closesocket(socks[0]);\n    closesocket(socks[1]);\n    WSASetLastError(e);\n    socks[0] = socks[1] = -1;\n    //return SOCKET_ERROR;\n\n    return -1;\n}\n#else\nint make_socketpair (int socks[2], int dummy) {\n    if (socks == 0) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    dummy = socketpair(AF_UNIX, SOCK_STREAM, 0, socks);\n\n    if (dummy) {\n        socks[0] = socks[1] = -1;\n    }\n\n    return dummy;\n}\n#endif\n\n\nstatic int ssh_error (lua_State *L, LIBSSH2_SESSION *session, const char *msg) {\n    char *errmsg;\n    libssh2_session_last_error(session, &errmsg, NULL, 0);\n\n    return nseU_safeerror(L, \"%s: %s\", msg, errmsg);\n}\n\nstatic int finish_send (lua_State *L, int status, lua_KContext ctx) {\n    if (lua_toboolean(L, -2))\n        return 0;\n    else\n        return lua_error(L); /* uses idx 6 */\n}\n\nstatic int finish_read (lua_State *L, int status, lua_KContext ctx) {\n    int rc;\n    struct ssh_userdata *sshu = NULL;\n\n    sshu = (struct ssh_userdata *) nseU_checkudata(L, 1, SSH2_UDATA, \"ssh2\");\n\n    if (lua_toboolean(L, -2)) {\n        size_t n = 0;\n        size_t l = 0;\n        lua_getuservalue(L, 1);\n        lua_getfield(L, -1, \"sp_buff\");\n        lua_pushvalue(L, 3);\n        lua_concat(L, 2);\n        const char *data = lua_tolstring(L, -1, &l);\n        lua_pushliteral(L, \"\");\n        lua_setfield(L, 4, \"sp_buff\");\n\n        while (n < l) {\n#ifdef WIN32\n            rc = send(sshu->sp[1], data + n, l - n, 0);\n#else\n            rc = write(sshu->sp[1], data + n, l - n);\n#endif\n            if (rc == -1 && errno != EAGAIN) {\n                luaL_error(L, \"Writing to socket pair: %s\", strerror(errno));\n            }\n            else if (rc == -1 && errno == EAGAIN) {\n                lua_pushlstring(L, data + n, l - n);\n                lua_setfield(L, 4, \"sp_buff\");\n                break;\n            }\n            else {\n                n += rc;\n            }\n        }\n        return 0;\n    }\n    else {\n        return lua_error(L); /* uses idx 6 */\n    }\n}\n\nstatic int filter (lua_State *L) {\n    int rc;\n    char data[4096];\n    struct ssh_userdata *sshu = NULL;\n\n    sshu = (struct ssh_userdata *) nseU_checkudata(L, 1, SSH2_UDATA, \"ssh2\");\n\n    lua_getuservalue(L, 1);\n    lua_getfield(L, -1, \"sock\");\n    lua_replace(L, -2);\n\n#ifdef WIN32\n    rc = recv(sshu->sp[1], data, sizeof(data), 0);\n\n    if (WSAGetLastError() == WSAEWOULDBLOCK)\n        rc = 0;\n#else\n    rc = read(sshu->sp[1], data, sizeof(data));\n#endif\n\n    if (rc > 0) {\n        //write data to nsock socket\n        lua_getfield(L, -1, \"send\");\n        lua_insert(L, -2); /* swap */\n        lua_pushlstring(L, data, rc);\n\n        assert(lua_status(L) == LUA_OK);\n        lua_callk(L, 2, 2, 0, finish_send);\n\n        return finish_send(L,0,0);\n    }\n    else if (rc == -1 && errno != EAGAIN)\n        return luaL_error(L, \"%s\", strerror(errno));\n\n    lua_getfield(L, -1, \"receive\");\n    lua_insert(L, -2); /* swap */\n\n    assert(lua_status(L) == LUA_OK);\n    lua_callk(L, 1, 2, 0, finish_read);\n\n    return finish_read(L, 0, 0);\n}\n\nstatic int do_session_handshake (lua_State *L, int status, lua_KContext ctx) {\n    int rc;\n    struct ssh_userdata *sshu = NULL;\n\n    assert(lua_gettop(L) == 4);\n    sshu = (struct ssh_userdata *) nseU_checkudata(L, 3, SSH2_UDATA, \"ssh2\");\n\n    while ((rc = libssh2_session_handshake(sshu->session, sshu->sp[0])) == LIBSSH2_ERROR_EAGAIN) {\n        luaL_getmetafield(L, 3, \"filter\");\n        lua_pushvalue(L, 3);\n\n        assert(lua_status(L) == LUA_OK);\n        lua_callk(L, 1, 0, 0, do_session_handshake);\n    }\n\n    if (rc) {\n        libssh2_session_free(sshu->session);\n        sshu->session = NULL;\n        return luaL_error(L, \"Unable to complete libssh2 handshake.\");\n    }\n\n    // lua_pushvalue(L, 3);\n    lua_settop(L, 3);\n\n    return 1;\n}\n\nstatic int finish_session_open (lua_State *L, int status, lua_KContext ctx) {\n    assert(lua_gettop(L) == 6);\n    if (lua_toboolean(L, -2)) {\n        lua_pop(L, 2);\n        return do_session_handshake(L,0,0);\n    }\n    else {\n        struct ssh_userdata *state = NULL;\n\n        state = (struct ssh_userdata *) nseU_checkudata(L, 3, SSH2_UDATA, \"ssh2\");\n        if (state->session != NULL) {\n            libssh2_session_free(state->session);\n            state->session = NULL;\n        }\n        return lua_error(L);\n    }\n}\n\n/*\n* Creates libssh2 session, connects to hostname:port and tries to perform a\n* ssh handshake on socket. Returns ssh_state on success, nil on failure.\n*\n* session_open(hostname, port)\n*/\nstatic int l_session_open (lua_State *L) {\n    int rc;\n    ssh_userdata *state = NULL;\n\n    luaL_checkinteger(L, 2);\n    lua_settop(L, 2);\n\n    state = (ssh_userdata *)lua_newuserdata(L, sizeof(ssh_userdata)); /* index 3 */\n\n    assert(lua_gettop(L) == 3);\n    state->session = NULL;\n    state->sp[0] = -1;\n    state->sp[1] = -1;\n    lua_pushvalue(L, lua_upvalueindex(1)); /* metatable */\n    lua_setmetatable(L, 3);\n\n    lua_newtable(L);\n    lua_setuservalue(L, 3);\n    lua_getuservalue(L, 3); /* index 4 - a table associated with userdata*/\n    assert(lua_gettop(L) == 4);\n\n    state->session = libssh2_session_init();\n\n    if (state->session == NULL) {\n        // A session could not be created because of memory limit\n        return nseU_safeerror(L, \"trying to initiate session\");\n    }\n\n    libssh2_session_set_blocking(state->session, 0);\n\n    if (make_socketpair(state->sp, 1) == -1)\n        return nseU_safeerror(L, \"trying to create socketpair\");\n\n#ifdef WIN32\n    unsigned long s_mode = 1; // non-blocking\n\n    rc = ioctlsocket(state->sp[1], FIONBIO, (unsigned long *)&s_mode);\n    if (rc != NO_ERROR)\n        return nseU_safeerror(L, \"%s\", strerror(errno));\n#else\n    // get file descriptor flags\n    rc = fcntl(state->sp[1], F_GETFD);\n    if (rc == -1)\n        return nseU_safeerror(L, \"%s\", strerror(errno));\n\n    // add non-blocking flag and update file descriptor flags\n    rc |= O_NONBLOCK;\n    rc = fcntl(state->sp[1], F_SETFL, rc);\n    if (rc == -1)\n        return nseU_safeerror(L, \"%s\", strerror(errno));\n#endif\n\n    lua_getglobal(L, \"nmap\");\n    lua_getfield(L, -1, \"new_socket\");\n    lua_replace(L, -2);\n    lua_call(L, 0, 1);\n    lua_setfield(L, 4, \"sock\");\n    lua_pushliteral(L, \"\");\n    lua_setfield(L, 4, \"sp_buff\");\n    assert(lua_gettop(L) == 4);\n\n    lua_getfield(L, 4, \"sock\");\n    lua_getfield(L, -1, \"connect\");\n    lua_insert(L, -2); /* swap */\n    lua_pushvalue(L, 1);\n    lua_pushvalue(L, 2);\n    lua_callk(L, 3, 2, 3, finish_session_open);\n    return finish_session_open(L,0,0);\n}\n\n/*\n* Returns the SHA1 or MD5 hostkey hash of provided session or nil if it is not available\n*/\nstatic int l_hostkey_hash (lua_State *L) {\n    luaL_Buffer B;\n    static int hash_option[] = { LIBSSH2_HOSTKEY_HASH_MD5, LIBSSH2_HOSTKEY_HASH_SHA1 };\n    static int hash_length[] = { 16, 20 };\n    static const char *hashes[] = { \"md5\", \"sha1\", NULL };\n    int type = luaL_checkoption(L, 2, \"sha1\", hashes);\n    struct ssh_userdata *state = NULL;\n    const unsigned char *hash = NULL;\n\n    state = (struct ssh_userdata *) nseU_checkudata(L, 1, SSH2_UDATA, \"ssh2\");\n    hash = (const unsigned char *) libssh2_hostkey_hash(state->session, hash_option[type]);\n\n    if (hash == NULL)\n        return nseU_safeerror(L, \"could not get hostkey hash\");\n\n    luaL_buffinit(L, &B);\n    for (int i = 0; i < hash_length[type]; i++) {\n        char byte[3]; /* with space for NULL */\n        snprintf(byte, sizeof(byte), \"%02X\", (unsigned int)hash[i]);\n        if (i)\n            luaL_addchar(&B, ':');\n        luaL_addlstring(&B, byte, 2);\n    }\n    luaL_pushresult(&B);\n\n    return 1;\n}\n\nstatic int l_set_timeout(lua_State *L) {\n    long timeout = luaL_checkinteger(L, 2);\n    struct ssh_userdata *state = NULL;\n    state = (struct ssh_userdata *) nseU_checkudata(L, 1, SSH2_UDATA, \"ssh2\");\n\n    libssh2_session_set_timeout(state->session, timeout);\n\n    return 0;\n}\n\nstatic int userauth_list (lua_State *L, int status, lua_KContext ctx) {\n    char *auth_list = NULL;\n    struct ssh_userdata *state = NULL;\n    const char *username = luaL_checkstring(L, 2);\n\n    state = (struct ssh_userdata *) nseU_checkudata(L, 1, SSH2_UDATA, \"ssh2\");\n    assert(state->session != NULL);\n\n    while ((auth_list = libssh2_userauth_list(state->session, username, lua_rawlen(L, 2))) == NULL\n        && libssh2_session_last_errno(state->session) == LIBSSH2_ERROR_EAGAIN) {\n        luaL_getmetafield(L, 1, \"filter\");\n        lua_pushvalue(L, 1);\n\n        assert(lua_status(L) == LUA_OK);\n        lua_callk(L, 1, 0, 0, userauth_list);\n    }\n\n    if (auth_list) {\n        const char *auth = strtok(auth_list, \",\");\n        lua_newtable(L);\n        do {\n            lua_pushstring(L, auth);\n            lua_rawseti(L, -2, lua_rawlen(L, -2) + 1);\n        }\n        while ((auth = strtok(NULL, \",\")));\n\n        //libssh2_free(state->session, (void *)auth_list);\n    }\n    else if (libssh2_userauth_authenticated(state->session)) {\n        lua_pushliteral(L, \"none_auth\");\n    }\n    else {\n        return ssh_error(L, state->session, \"userauth_list\");\n    }\n\n    return 1;\n}\n\n/*\n* Returns list of supported authentication methods\n*/\nstatic int l_userauth_list (lua_State *L) {\n    return userauth_list(L, 0, 0);\n}\n\nstatic int userauth_publickey (lua_State *L, int status, lua_KContext ctx) {\n    int rc;\n    const char *username, *private_key_file, *passphrase, *public_key_file;\n    struct ssh_userdata *state = NULL;\n    state = (struct ssh_userdata *) nseU_checkudata(L, 1, SSH2_UDATA, \"ssh2\");\n\n    username = luaL_checkstring(L, 2);\n    private_key_file = luaL_checkstring(L, 3);\n\n    if (lua_isstring(L, 4))\n        passphrase = lua_tostring(L, 4);\n    else\n        passphrase = NULL;\n\n    if (lua_isstring(L, 5))\n        public_key_file = lua_tostring(L, 5);\n    else\n        public_key_file = NULL;\n\n    while ((rc = libssh2_userauth_publickey_fromfile(\n        state->session, username, public_key_file, private_key_file, passphrase\n        )) == LIBSSH2_ERROR_EAGAIN) {\n        luaL_getmetafield(L, 1, \"filter\");\n        lua_pushvalue(L, 1);\n\n        assert(lua_status(L) == LUA_OK);\n        lua_callk(L, 1, 0, 0, userauth_publickey);\n    }\n\n    if (rc == 0)\n        lua_pushboolean(L, 1);\n    else\n        lua_pushboolean(L, 0);\n\n    return 1;\n}\n\nstatic int l_userauth_publickey (lua_State *L) {\n    return userauth_publickey(L, 0, 0);\n}\n\nstatic int l_read_publickey (lua_State *L) {\n    FILE *fd;\n    char c;\n    const char* publickeyfile = luaL_checkstring(L, 1);\n    luaL_Buffer publickey_data;\n\n    fd = fopen(publickeyfile, \"r\");\n    if (!fd)\n        return luaL_error(L, \"Error reading file\");\n\n    luaL_buffinit(L, &publickey_data);\n    while (fread(&c, 1, 1, fd) && c!= '\\r' && c != '\\n' && c != ' ') {\n        continue;\n    }\n    while (fread(&c, 1, 1, fd) && c!= '\\r' && c != '\\n' && c != ' ') {\n        luaL_addchar(&publickey_data, c);\n    }\n    fclose(fd);\n\n    lua_getglobal(L, \"require\");\n    lua_pushstring(L, \"base64\");\n    lua_call(L, 1, 1);\n    lua_getfield(L, -1, \"dec\");\n\n    luaL_pushresult(&publickey_data);\n    lua_call(L, 1, 1);\n\n    return 1;\n}\n\nstatic int publickey_canauth_cb (LIBSSH2_SESSION *session, unsigned char **sig,\n    size_t *sig_len, const unsigned char *data, size_t data_len, void **abstract) {\n    return 0;\n}\n\nstatic int publickey_canauth (lua_State *L, int status, lua_KContext ctx) {\n    int rc;\n    int errlen;\n    char *errmsg;\n    const char *username;\n    unsigned const char *publickey_data;\n    size_t len = 0;\n    struct ssh_userdata *state;\n\n    state = (struct ssh_userdata *) nseU_checkudata(L, 1, SSH2_UDATA, \"ssh2\");\n    username = luaL_checkstring(L, 2);\n\n    if (lua_isstring(L, 3))\n        publickey_data = (unsigned const char*)lua_tolstring(L, 3, &len);\n    else\n        return luaL_error(L, \"Invalid public key\");\n\n    while ((rc = libssh2_userauth_publickey(state->session,\n        username, publickey_data, len, &publickey_canauth_cb, NULL)) == LIBSSH2_ERROR_EAGAIN) {\n        luaL_getmetafield(L, 1, \"filter\");\n        lua_pushvalue(L, 1);\n\n        assert(lua_status(L) == LUA_OK);\n        lua_callk(L, 1, 0, 0, publickey_canauth);\n    }\n\n    libssh2_session_last_error(state->session, &errmsg, &errlen, 0);\n\n    if (rc == LIBSSH2_ERROR_ALLOC || rc == LIBSSH2_ERROR_PUBLICKEY_UNVERIFIED)\n        lua_pushboolean(L, 1); //Username/PublicKey combination invalid\n    else if (rc == LIBSSH2_ERROR_AUTHENTICATION_FAILED)\n        lua_pushboolean(L, 0);\n    else\n        return luaL_error(L, \"Invalid Publickey\");\n\n    return 1;\n}\n\nstatic int l_publickey_canauth (lua_State *L) {\n    return publickey_canauth(L, 0, 0);\n}\n\n/*\n* Attempts to authenticate session with provided username and password\n* returns true on success and false otherwise\n*\n* userauth_password(state, username, password)\n*/\nstatic int userauth_password (lua_State *L, int status, lua_KContext ctx) {\n    int rc;\n    const char *username, *password;\n    struct ssh_userdata *state;\n\n    state = (struct ssh_userdata *) nseU_checkudata(L, 1, SSH2_UDATA, \"ssh2\");\n    username = luaL_checkstring(L, 2);\n    password = luaL_checkstring(L, 3);\n\n    assert(state->session != NULL);\n    while ((rc = libssh2_userauth_password(state->session,\n        username, password)) == LIBSSH2_ERROR_EAGAIN) {\n        luaL_getmetafield(L, 1, \"filter\");\n        lua_pushvalue(L, 1);\n\n        assert(lua_status(L) == LUA_OK);\n        lua_callk(L, 1, 0, 0, userauth_password);\n    }\n\n    if (rc == 0)\n        lua_pushboolean(L, 1);\n    else\n        lua_pushboolean(L, 0);\n\n    return 1;\n}\n\nstatic int l_userauth_password (lua_State *L) {\n    return userauth_password(L, 0, 0);\n}\n\nstatic int session_close (lua_State *L, int status, lua_KContext ctx) {\n    int rc;\n    struct ssh_userdata *state;\n\n    state = (struct ssh_userdata *) nseU_checkudata(L, 1, SSH2_UDATA, \"ssh2\");\n\n    if (state->session != NULL) {\n        while ((rc = libssh2_session_disconnect(\n            state->session, \"Normal Shutdown\")) == LIBSSH2_ERROR_EAGAIN) {\n            luaL_getmetafield(L, 1, \"filter\");\n            lua_pushvalue(L, 1);\n\n            assert(lua_status(L) == LUA_OK);\n            lua_callk(L, 1, 0, 0, session_close);\n        }\n\n        if (rc < 0)\n            return luaL_error(L, \"unable to disconnect session\");\n\n        if (libssh2_session_free(state->session) < 0)\n            return luaL_error(L, \"unable to free session\");\n\n        state->session = NULL;\n    }\n\n    return 0;\n}\n\nstatic int l_session_close (lua_State *L) {\n    return session_close(L, 0, 0);\n}\n\nstatic int channel_read (lua_State *L, int status, lua_KContext ctx) {\n    int rc;\n    char buf[2048];\n    size_t buflen = 2048;\n    LIBSSH2_CHANNEL **channel = (LIBSSH2_CHANNEL **) lua_touserdata(L, 2);\n\n    while ((rc = libssh2_channel_read(*channel, buf, buflen)) == LIBSSH2_ERROR_EAGAIN) {\n        luaL_getmetafield(L, 1, \"filter\");\n        lua_pushvalue(L, 1);\n        lua_callk(L, 1, 0, 0, channel_read);\n    }\n\n    if (rc > 0) {\n        lua_pushlstring(L, buf, rc);\n        return 1;\n    }\n    else if (rc < 0)\n        return luaL_error(L, \"Reading from channel\");\n\n    lua_pushnil(L);\n\n    return 1;\n}\n\nstatic int l_channel_read (lua_State *L) {\n    return channel_read(L, 0, 0);\n}\n\nstatic int l_channel_read_stderr(lua_State *L) {\n    int rc;\n    char buf[2048];\n    size_t buflen = 2048;\n    LIBSSH2_CHANNEL **channel = (LIBSSH2_CHANNEL **) lua_touserdata(L, 2);\n\n    while ((rc = libssh2_channel_read_stderr(*channel, buf, buflen)) == LIBSSH2_ERROR_EAGAIN) {\n        luaL_getmetafield(L, 1, \"filter\");\n        lua_pushvalue(L, 1);\n        lua_callk(L, 1, 0, 0, channel_read);\n    }\n\n    if (rc > 0) {\n        lua_pushlstring(L, buf, rc);\n        return 1;\n    }\n    else if (rc < 0)\n        return luaL_error(L, \"Reading from channel\");\n\n    lua_pushnil(L);\n    return 1;\n}\n\nstatic int channel_write (lua_State *L, int status, lua_KContext ctx) {\n    int rc;\n    const char *buf;\n    size_t buflen = 0;\n    LIBSSH2_CHANNEL **channel = (LIBSSH2_CHANNEL **) lua_touserdata(L, 2);\n\n    if (lua_isstring(L, 3))\n        buf = lua_tolstring(L, 3, &buflen);\n    else\n        return luaL_error(L, \"Invalid buffer\");\n\n    while ((rc = libssh2_channel_write(*channel, buf, buflen)) == LIBSSH2_ERROR_EAGAIN) {\n        luaL_getmetafield(L, 1, \"filter\");\n        lua_pushvalue(L, 1);\n        lua_callk(L, 1, 0, 0, channel_write);\n    }\n\n    if (rc < 0)\n        return luaL_error(L, \"Writing to channel\");\n\n    lua_pushinteger(L, rc);\n    return 1;\n}\n\nstatic int l_channel_write (lua_State *L) {\n    return channel_write(L, 0, 0);\n}\n\nstatic int channel_exec (lua_State *L, int status, lua_KContext ctx) {\n    int rc;\n    // ssh_userdata *state = (ssh_userdata *)lua_touserdata(L, 1);\n    LIBSSH2_CHANNEL **channel = (LIBSSH2_CHANNEL **) lua_touserdata(L, 2);\n    const char *cmd = luaL_checkstring(L, 3);\n\n    while ((rc = libssh2_channel_exec(*channel, cmd)) == LIBSSH2_ERROR_EAGAIN) {\n        luaL_getmetafield(L, 1, \"filter\");\n        lua_pushvalue(L, 1);\n        lua_callk(L, 1, 0, 0, channel_exec);\n    }\n    if (rc != 0)\n        return luaL_error(L, \"Error executing command\");\n\n   return 0;\n}\n\nstatic int l_channel_exec (lua_State *L) {\n    return channel_exec(L, 0, 0);\n}\n\nstatic int l_channel_eof(lua_State *L) {\n    int result;\n    LIBSSH2_CHANNEL **channel = (LIBSSH2_CHANNEL **) lua_touserdata(L, 1);\n\n    result = libssh2_channel_eof(*channel);\n    if (result >= 0)\n        lua_pushboolean(L, result);\n    else\n        return luaL_error(L, \"Error checking for EOF\");\n\n    return 1;\n}\n\nstatic int channel_send_eof(lua_State *L, int status, lua_KContext ctx) {\n    int rc;\n    // ssh_userdata *state = (ssh_userdata *)lua_touserdata(L, 1);\n    LIBSSH2_CHANNEL **channel = (LIBSSH2_CHANNEL **) lua_touserdata(L, 2);\n\n    while ((rc = libssh2_channel_send_eof(*channel)) == LIBSSH2_ERROR_EAGAIN) {\n        luaL_getmetafield(L, 1, \"filter\");\n        lua_pushvalue(L, 1);\n        lua_callk(L, 1, 0, 0, channel_send_eof);\n    }\n    if (rc != 0)\n        return luaL_error(L, \"Error sending EOF\");\n\n    return 0;\n}\n\nstatic int l_channel_send_eof(lua_State *L) {\n    return channel_send_eof(L, 0, 0);\n}\n\nstatic int setup_channel(lua_State *L, int status, lua_KContext ctx) {\n    int rc;\n    // ssh_userdata *state = (ssh_userdata *)lua_touserdata(L, 1);\n    LIBSSH2_CHANNEL **channel = (LIBSSH2_CHANNEL **) lua_touserdata(L, 2);\n\n    while ((rc = libssh2_channel_request_pty(*channel, \"vanilla\")) == LIBSSH2_ERROR_EAGAIN) {\n        luaL_getmetafield(L, 1, \"filter\");\n        lua_pushvalue(L, 1);\n        lua_callk(L, 1, 0, 0, setup_channel);\n    }\n    if (rc != 0)\n        return luaL_error(L, \"Requesting pty\");\n\n    return 1;\n}\n\nstatic int l_setup_channel (lua_State *L) {\n    return setup_channel(L, 0, 0);\n}\n\nstatic int finish_open_channel (lua_State *L, int status, lua_KContext ctx) {\n    ssh_userdata *state = (ssh_userdata *)lua_touserdata(L, 1);\n    LIBSSH2_CHANNEL **channel = (LIBSSH2_CHANNEL **) lua_touserdata(L, 2);\n\n    while ((*channel = libssh2_channel_open_session(state->session)) == NULL\n    && libssh2_session_last_errno(state->session) == LIBSSH2_ERROR_EAGAIN) {\n        luaL_getmetafield(L, 1, \"filter\");\n        lua_pushvalue(L, 1);\n        lua_callk(L, 1, 0, 0, finish_open_channel);\n    }\n    if (channel == NULL)\n        return luaL_error(L, \"Opening channel\");\n\n    return setup_channel(L, 0, 0);\n}\n\nstatic int l_open_channel (lua_State *L) {\n    ssh_userdata *state = (ssh_userdata *)lua_touserdata(L, 1);\n    LIBSSH2_CHANNEL **channel = (LIBSSH2_CHANNEL **)lua_newuserdata(L, sizeof(LIBSSH2_CHANNEL *));\n\n    while ((*channel = libssh2_channel_open_session(state->session)) == NULL\n    && libssh2_session_last_errno(state->session) == LIBSSH2_ERROR_EAGAIN) {\n        luaL_getmetafield(L, 1, \"filter\");\n        lua_pushvalue(L, 1);\n        lua_callk(L, 1, 0, 0, finish_open_channel);\n    }\n\n    return l_setup_channel(L);\n}\n\nstatic int channel_close (lua_State *L, int status, lua_KContext ctx) {\n    int rc;\n    // ssh_userdata *state = (ssh_userdata *)lua_touserdata(L, 1);\n    LIBSSH2_CHANNEL **channel = (LIBSSH2_CHANNEL **) lua_touserdata(L, 2);\n\n    while ((rc = libssh2_channel_close(*channel)) == LIBSSH2_ERROR_EAGAIN) {\n        luaL_getmetafield(L, 1, \"filter\");\n        lua_pushvalue(L, 1);\n        lua_callk(L, 1, 0, 0, channel_close);\n    }\n    if (rc != 0)\n        return luaL_error(L, \"Error closing channel\");;\n\n    return 0;\n}\n\nstatic int l_channel_close (lua_State *L) {\n    return channel_close(L, 0, 0);\n}\n\nstatic const struct luaL_Reg libssh2[] = {\n    { \"session_open\", l_session_open },\n    { \"hostkey_hash\", l_hostkey_hash },\n    { \"set_timeout\", l_set_timeout },\n    { \"userauth_list\", l_userauth_list },\n    { \"userauth_publickey\", l_userauth_publickey },\n    { \"read_publickey\", l_read_publickey },\n    { \"publickey_canauth\", l_publickey_canauth },\n    { \"userauth_password\", l_userauth_password },\n    { \"session_close\", l_session_close },\n    { \"open_channel\", l_open_channel},\n    { \"channel_read\", l_channel_read},\n    { \"channel_read_stderr\", l_channel_read_stderr},\n    { \"channel_write\", l_channel_write},\n    { \"channel_exec\", l_channel_exec},\n    { \"channel_send_eof\", l_channel_send_eof},\n    { \"channel_eof\", l_channel_eof},\n    { \"channel_close\", l_channel_close},\n    { NULL, NULL }\n};\n\nstatic int gc (lua_State *L) {\n    struct ssh_userdata *sshu = NULL;\n\n    sshu = (struct ssh_userdata *) nseU_checkudata(L, 1, SSH2_UDATA, \"ssh2\");\n    if (!sshu) { return 0; }\n    if (sshu) {\n        // lua_pushvalue(L, lua_upvalueindex(1));\n        // lua_getfield(L, -1, \"session_close\");\n        // lua_insert(L, -2); /* swap */\n        // lua_pcall(L, 1, 0, 0); /* if an error occurs, don't do anything */\n\n        if (sshu->session != NULL) {\n            if (libssh2_session_free(sshu->session) < 0) {\n                // Unable to free libssh2 session\n            }\n            sshu->session = NULL;\n        }\n    }\n\n#ifdef WIN32\n    closesocket(sshu->sp[0]);\n    closesocket(sshu->sp[1]);\n#else\n    close(sshu->sp[0]);\n    close(sshu->sp[1]);\n#endif\n\n    return 0;\n}\n\nint luaopen_libssh2 (lua_State *L) {\n    lua_settop(L, 0); /* clear the stack */\n\n    luaL_newlibtable(L, libssh2);\n\n    lua_newtable(L); /* ssh2 session metatable */\n    lua_pushvalue(L, -1);\n    lua_pushcclosure(L, gc, 1);\n    lua_setfield(L, -2, \"__gc\");\n    lua_pushvalue(L, -1);\n    lua_pushcclosure(L, filter, 1);\n    lua_setfield(L, -2, \"filter\");\n\n    luaL_setfuncs(L, libssh2, 1);\n\n    static bool libssh2_initialized = false;\n    if (!libssh2_initialized && (libssh2_init(0) != 0))\n        luaL_error(L, \"unable to open libssh2\");\n    libssh2_initialized = true;\n\n    return 1;\n}\n"], "filenames": ["nse_libssh2.cc"], "buggy_code_start_loc": [15], "buggy_code_end_loc": [482], "fixing_code_start_loc": [14], "fixing_code_end_loc": [482], "type": "CWE-415", "message": "nse_libssh2.cc in Nmap 7.70 is subject to a denial of service condition due to a double free when an SSH connection fails, as demonstrated by a leading \\n character to ssh-brute.nse or ssh-auth-methods.nse.", "other": {"cve": {"id": "CVE-2017-18594", "sourceIdentifier": "cve@mitre.org", "published": "2019-08-29T00:15:10.467", "lastModified": "2019-09-26T12:15:10.347", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "nse_libssh2.cc in Nmap 7.70 is subject to a denial of service condition due to a double free when an SSH connection fails, as demonstrated by a leading \\n character to ssh-brute.nse or ssh-auth-methods.nse."}, {"lang": "es", "value": "nse_libssh2.cc en Nmap 7.70 est\u00e1 sujeto a una condici\u00f3n de denegaci\u00f3n de servicio debido a una doble liberaci\u00f3n cuando se produce un error en una conexi\u00f3n SSH, como lo demuestra un car\u00e1cter principal de .n a ssh-brute.nse o ssh-auth-methods.nse."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-415"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nmap:nmap:7.70:*:*:*:*:*:*:*", "matchCriteriaId": "3F2B2815-27CD-4A22-9394-332073CF9970"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-09/msg00073.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-09/msg00075.html", "source": "cve@mitre.org"}, {"url": "https://github.com/AMatchandaHaystack/Research/blob/master/Nmap%26libsshDF", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/nmap/nmap/commit/350bbe0597d37ad67abe5fef8fba984707b4e9ad", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/nmap/nmap/issues/1077", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/nmap/nmap/issues/1227", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://seclists.org/nmap-announce/2019/0", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://seclists.org/nmap-dev/2018/q2/45", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/nmap/nmap/commit/350bbe0597d37ad67abe5fef8fba984707b4e9ad"}}