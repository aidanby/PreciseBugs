{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            X   X  PPPP   M   M                              %\n%                             X X   P   P  MM MM                              %\n%                              X    PPPP   M M M                              %\n%                             X X   P      M   M                              %\n%                            X   X  P      M   M                              %\n%                                                                             %\n%                                                                             %\n%                  Read/Write X Windows system Pixmap Format                  %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2021 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/coder-private.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/quantize.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/resize.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/splay-tree.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/threshold.h\"\n#include \"MagickCore/utility.h\"\n#include \"coders/coders-private.h\"\n\f\n/*\n  Global declarations.\n*/\nstatic SplayTreeInfo\n  *xpm_symbolic = (SplayTreeInfo *) NULL;\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WritePICONImage(const ImageInfo *,Image *,ExceptionInfo *),\n  WriteXPMImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s X P M                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsXPM() returns MagickTrue if the image format type, identified by the\n%  magick string, is XPM.\n%\n%  The format of the IsXPM method is:\n%\n%      MagickBooleanType IsXPM(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes. or\n%      blob.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsXPM(const unsigned char *magick,const size_t length)\n{\n  if (length < 9)\n    return(MagickFalse);\n  if (LocaleNCompare((char *) magick+1,\"* XPM *\",7) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d X P M I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadXPMImage() reads an X11 pixmap image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadXPMImage method is:\n%\n%      Image *ReadXPMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic int CompareXPMColor(const void *target,const void *source)\n{\n  const char\n    *p,\n    *q;\n\n  p=(const char *) target;\n  q=(const char *) source;\n  return(strcmp(p,q));\n}\n\nstatic ssize_t CopyXPMColor(char *destination,const char *source,size_t length)\n{\n  const char\n    *p;\n\n  p=source;\n  while (length-- && (*p != '\\0'))\n  {\n    if (*p == '\"')\n      break;\n    *destination++=(*p++);\n  }\n  if (length != 0)\n    *destination='\\0';\n  return((ssize_t) (p-source));\n}\n\nstatic char *NextXPMLine(char *p)\n{\n  assert(p != (char *) NULL);\n  p=strchr(p,'\\n');\n  if (p != (char *) NULL)\n    p++;\n  return(p);\n}\n\nstatic char *ParseXPMColor(char *,MagickBooleanType)\n  magick_attribute((__pure__));\n\nstatic char *ParseXPMColor(char *color,MagickBooleanType search_start)\n{\n#define NumberTargets  6\n\n  char\n    *p,\n    *r;\n\n  const char\n    *q;\n\n  ssize_t\n    i;\n\n  static const char\n    *const targets[NumberTargets] = { \"c \", \"g \", \"g4 \", \"m \", \"b \", \"s \" };\n\n  if (*color == '\\0')\n    return((char *) NULL);\n  if (search_start != MagickFalse)\n    {\n      for (i=0; i < NumberTargets; i++)\n      {\n        p=color;\n        for (q=targets[i]; *p != '\\0'; p++)\n        {\n          if (*p == '\\n')\n            break;\n          if (*p != *q)\n            continue;\n          if (isspace((int) ((unsigned char) (*(p-1)))) == 0)\n            continue;\n          r=p;\n          for ( ; ; )\n          {\n            if (*q == '\\0')\n              return(p);\n            if (*r++ != *q++)\n              break;\n          }\n          q=targets[i];\n        }\n      }\n      return((char *) NULL);\n    }\n  for (p=color+1; *p != '\\0'; p++)\n  {\n    if (*p == '\\n')\n      break;\n    if (isspace((int) ((unsigned char) (*(p-1)))) == 0)\n      continue;\n    if (isspace((int) ((unsigned char) (*p))) != 0)\n      continue;\n    for (i=0; i < NumberTargets; i++)\n    {\n      if ((*p == *targets[i]) && (*(p+1) == *(targets[i]+1)))\n        return(p);\n    }\n  }\n  return(p);\n}\n\nstatic Image *ReadXPMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    *grey,\n    key[MagickPathExtent],\n    target[MagickPathExtent],\n    *xpm_buffer;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    active,\n    status;\n\n  char\n    *next,\n    *p,\n    *q;\n\n  Quantum\n    *r;\n\n  ssize_t\n    x;\n\n  size_t\n    length;\n\n  SplayTreeInfo\n    *xpm_colors;\n\n  ssize_t\n    count,\n    j,\n    y;\n\n  unsigned long\n    colors,\n    columns,\n    rows,\n    width;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read XPM file.\n  */\n  length=MagickPathExtent;\n  xpm_buffer=(char *) AcquireQuantumMemory((size_t) length,sizeof(*xpm_buffer));\n  if (xpm_buffer == (char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  *xpm_buffer='\\0';\n  p=xpm_buffer;\n  while (ReadBlobString(image,p) != (char *) NULL)\n  {\n    if ((*p == '#') && ((p == xpm_buffer) || (*(p-1) == '\\n')))\n      continue;\n    if ((*p == '}') && (*(p+1) == ';'))\n      break;\n    p+=strlen(p);\n    if ((size_t) (p-xpm_buffer+MagickPathExtent) < length)\n      continue;\n    length<<=1;\n    xpm_buffer=(char *) ResizeQuantumMemory(xpm_buffer,length+MagickPathExtent,\n      sizeof(*xpm_buffer));\n    if (xpm_buffer == (char *) NULL)\n      break;\n    p=xpm_buffer+strlen(xpm_buffer);\n  }\n  if (xpm_buffer == (char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  /*\n    Remove comments.\n  */\n  count=0;\n  width=0;\n  for (p=xpm_buffer; *p != '\\0'; p++)\n  {\n    if (*p != '\"')\n      continue;\n    count=(ssize_t) sscanf(p+1,\"%lu %lu %lu %lu\",&columns,&rows,&colors,&width);\n    image->columns=columns;\n    image->rows=rows;\n    image->colors=colors;\n    if (count == 4)\n      break;\n  }\n  if ((count != 4) || (width == 0) || (width > 3) ||\n      (image->columns == 0) || (image->rows == 0) ||\n      (image->colors == 0) || (image->colors > MaxColormapSize))\n    {\n      xpm_buffer=DestroyString(xpm_buffer);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  /*\n    Remove unquoted characters.\n  */\n  active=MagickFalse;\n  for (q=xpm_buffer; *p != '\\0'; )\n  {\n    if (*p++ == '\"')\n      {\n        if (active != MagickFalse)\n          *q++='\\n';\n        active=active != MagickFalse ? MagickFalse : MagickTrue;\n      }\n    if (active != MagickFalse)\n      *q++=(*p);\n  }\n  *q='\\0';\n  if (active != MagickFalse)\n    {\n      xpm_buffer=DestroyString(xpm_buffer);\n      ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n    }\n  /*\n    Initialize image structure.\n  */\n  xpm_colors=NewSplayTree(CompareXPMColor,RelinquishMagickMemory,\n    (void *(*)(void *)) NULL);\n  if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n    {\n      xpm_colors=DestroySplayTree(xpm_colors);\n      xpm_buffer=DestroyString(xpm_buffer);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  /*\n    Read image colormap.\n  */\n  image->depth=1;\n  next=NextXPMLine(xpm_buffer);\n  for (j=0; (j < (ssize_t) image->colors) && (next != (char *) NULL); j++)\n  {\n    char\n      symbolic[MagickPathExtent];\n\n    p=next;\n    next=NextXPMLine(p);\n    if (next == (char *) NULL)\n      break;\n    length=MagickMin((size_t) width,MagickPathExtent-1);\n    if (CopyXPMColor(key,p,length) != (ssize_t) length)\n      break;\n    status=AddValueToSplayTree(xpm_colors,ConstantString(key),(void *) j);\n    /*\n      Parse color.\n    */\n    (void) memset(target,0,sizeof(target));\n    (void) CopyMagickString(target,\"gray\",MagickPathExtent);\n    q=(char *) NULL;\n    if (strlen(p) > width)\n      q=ParseXPMColor(p+width,MagickTrue);\n    (void) memset(symbolic,0,sizeof(symbolic));\n    *symbolic='\\0';\n    if (q != (char *) NULL)\n      {\n        while ((isspace((int) ((unsigned char) *q)) == 0) && (*q != '\\0'))\n          q++;\n        if ((next-q) < 0)\n          break;\n        (void) CopyXPMColor(target,q,MagickMin((size_t) (next-q),\n          MagickPathExtent-1));\n        q=ParseXPMColor(target,MagickFalse);\n        (void) CopyXPMColor(symbolic,q,MagickMin((size_t) (next-q),\n          MagickPathExtent-1));\n        if (q != (char *) NULL)\n          *q='\\0';\n      }\n    (void) StripMagickString(target);\n    if (*symbolic != '\\0')\n      (void) AddValueToSplayTree(xpm_symbolic,ConstantString(target),\n        ConstantString(symbolic));\n    grey=strstr(target,\"grey\");\n    if (grey != (char *) NULL)\n      grey[2]='a';\n    if (LocaleCompare(target,\"none\") == 0)\n      {\n        image->storage_class=DirectClass;\n        image->alpha_trait=BlendPixelTrait;\n      }\n    status=QueryColorCompliance(target,XPMCompliance,&image->colormap[j],\n      exception);\n    if (status == MagickFalse)\n      break;\n    if (image->depth < image->colormap[j].depth)\n      image->depth=image->colormap[j].depth;\n  }\n  if (j < (ssize_t) image->colors)\n    {\n      xpm_colors=DestroySplayTree(xpm_colors);\n      xpm_buffer=DestroyString(xpm_buffer);\n      ThrowReaderException(CorruptImageError,\"CorruptImage\");\n    }\n  j=0;\n  if (image_info->ping == MagickFalse)\n    {\n      /*\n        Read image pixels.\n      */\n      status=SetImageExtent(image,image->columns,image->rows,exception);\n      if (status == MagickFalse)\n        {\n          xpm_colors=DestroySplayTree(xpm_colors);\n          xpm_buffer=DestroyString(xpm_buffer);\n          return(DestroyImageList(image));\n        }\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        p=NextXPMLine(p);\n        if (p == (char *) NULL)\n          break;\n        r=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (r == (Quantum *) NULL)\n          break;\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          count=CopyXPMColor(key,p,MagickMin(width,MagickPathExtent-1));\n          if (count != (ssize_t) width)\n            break;\n          j=(ssize_t) GetValueFromSplayTree(xpm_colors,key);\n          if (image->storage_class == PseudoClass)\n            SetPixelIndex(image,(Quantum) j,r);\n          SetPixelViaPixelInfo(image,image->colormap+j,r);\n          p+=count;\n          r+=GetPixelChannels(image);\n        }\n        if (x < (ssize_t) image->columns)\n          break;\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n      }\n      if (y < (ssize_t) image->rows)\n        {\n          xpm_colors=DestroySplayTree(xpm_colors);\n          xpm_buffer=DestroyString(xpm_buffer);\n          ThrowReaderException(CorruptImageError,\"NotEnoughPixelData\");\n        }\n    }\n  /*\n    Relinquish resources.\n  */\n  xpm_buffer=DestroyString(xpm_buffer);\n  xpm_colors=DestroySplayTree(xpm_colors);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r X P M I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterXPMImage() adds attributes for the XPM image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterXPMImage method is:\n%\n%      size_t RegisterXPMImage(void)\n%\n*/\nModuleExport size_t RegisterXPMImage(void)\n{\n  MagickInfo\n    *entry;\n\n  if (xpm_symbolic == (SplayTreeInfo *) NULL)\n    xpm_symbolic=NewSplayTree(CompareSplayTreeString,RelinquishMagickMemory,\n      RelinquishMagickMemory);\n  entry=AcquireMagickInfo(\"XPM\",\"PICON\",\"Personal Icon\");\n  entry->decoder=(DecodeImageHandler *) ReadXPMImage;\n  entry->encoder=(EncodeImageHandler *) WritePICONImage;\n  entry->flags^=CoderAdjoinFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"XPM\",\"PM\",\"X Windows system pixmap (color)\");\n  entry->decoder=(DecodeImageHandler *) ReadXPMImage;\n  entry->encoder=(EncodeImageHandler *) WriteXPMImage;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags|=CoderStealthFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"XPM\",\"XPM\",\"X Windows system pixmap (color)\");\n  entry->decoder=(DecodeImageHandler *) ReadXPMImage;\n  entry->encoder=(EncodeImageHandler *) WriteXPMImage;\n  entry->magick=(IsImageFormatHandler *) IsXPM;\n  entry->flags^=CoderAdjoinFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r X P M I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterXPMImage() removes format registrations made by the\n%  XPM module from the list of supported formats.\n%\n%  The format of the UnregisterXPMImage method is:\n%\n%      UnregisterXPMImage(void)\n%\n*/\nModuleExport void UnregisterXPMImage(void)\n{\n  (void) UnregisterMagickInfo(\"PICON\");\n  (void) UnregisterMagickInfo(\"PM\");\n  (void) UnregisterMagickInfo(\"XPM\");\n  if (xpm_symbolic != (SplayTreeInfo *) NULL)\n    xpm_symbolic=DestroySplayTree(xpm_symbolic);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e P I C O N I m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WritePICONImage() writes an image to a file in the Personal Icon format.\n%\n%  The format of the WritePICONImage method is:\n%\n%      MagickBooleanType WritePICONImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WritePICONImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n#define ColormapExtent  155\n#define GraymapExtent  95\n#define PiconGeometry  \"48x48>\"\n\n  static unsigned char\n    Colormap[]=\n    {\n      0x47, 0x49, 0x46, 0x38, 0x37, 0x61, 0x06, 0x00, 0x05, 0x00, 0xf4, 0x05,\n      0x00, 0x00, 0x00, 0x00, 0x2f, 0x4f, 0x4f, 0x70, 0x80, 0x90, 0x7e, 0x7e,\n      0x7e, 0xdc, 0xdc, 0xdc, 0xff, 0xff, 0xff, 0x00, 0x00, 0x80, 0x00, 0x00,\n      0xff, 0x1e, 0x90, 0xff, 0x87, 0xce, 0xeb, 0xe6, 0xe6, 0xfa, 0x00, 0xff,\n      0xff, 0x80, 0x00, 0x80, 0xb2, 0x22, 0x22, 0x2e, 0x8b, 0x57, 0x32, 0xcd,\n      0x32, 0x00, 0xff, 0x00, 0x98, 0xfb, 0x98, 0xff, 0x00, 0xff, 0xff, 0x00,\n      0x00, 0xff, 0x63, 0x47, 0xff, 0xa5, 0x00, 0xff, 0xd7, 0x00, 0xff, 0xff,\n      0x00, 0xee, 0x82, 0xee, 0xa0, 0x52, 0x2d, 0xcd, 0x85, 0x3f, 0xd2, 0xb4,\n      0x8c, 0xf5, 0xde, 0xb3, 0xff, 0xfa, 0xcd, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x21, 0xf9, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x00, 0x00,\n      0x00, 0x00, 0x06, 0x00, 0x05, 0x00, 0x00, 0x05, 0x18, 0x20, 0x10, 0x08,\n      0x03, 0x51, 0x18, 0x07, 0x92, 0x28, 0x0b, 0xd3, 0x38, 0x0f, 0x14, 0x49,\n      0x13, 0x55, 0x59, 0x17, 0x96, 0x69, 0x1b, 0xd7, 0x85, 0x00, 0x3b,\n    },\n    Graymap[]=\n    {\n      0x47, 0x49, 0x46, 0x38, 0x37, 0x61, 0x04, 0x00, 0x04, 0x00, 0xf3, 0x0f,\n      0x00, 0x00, 0x00, 0x00, 0x12, 0x12, 0x12, 0x21, 0x21, 0x21, 0x33, 0x33,\n      0x33, 0x45, 0x45, 0x45, 0x54, 0x54, 0x54, 0x66, 0x66, 0x66, 0x78, 0x78,\n      0x78, 0x87, 0x87, 0x87, 0x99, 0x99, 0x99, 0xab, 0xab, 0xab, 0xba, 0xba,\n      0xba, 0xcc, 0xcc, 0xcc, 0xde, 0xde, 0xde, 0xed, 0xed, 0xed, 0xff, 0xff,\n      0xff, 0x21, 0xf9, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x00, 0x00,\n      0x00, 0x00, 0x04, 0x00, 0x04, 0x00, 0x00, 0x04, 0x0c, 0x10, 0x04, 0x31,\n      0x48, 0x31, 0x07, 0x25, 0xb5, 0x58, 0x73, 0x4f, 0x04, 0x00, 0x3b,\n    };\n\n#define MaxCixels  92\n\n  static const char\n    Cixel[MaxCixels+1] = \" .XoO+@#$%&*=-;:>,<1234567890qwertyuipasdfghjk\"\n                         \"lzxcvbnmMNBVCZASDFGHJKLPIUYTREWQ!~^/()_`'][{}|\";\n\n  char\n    buffer[MagickPathExtent],\n    basename[MagickPathExtent],\n    name[MagickPathExtent],\n    symbol[MagickPathExtent];\n\n  Image\n    *affinity_image,\n    *picon;\n\n  ImageInfo\n    *blob_info;\n\n  MagickBooleanType\n    status,\n    transparent;\n\n  PixelInfo\n    pixel;\n\n  QuantizeInfo\n    *quantize_info;\n\n  RectangleInfo\n    geometry;\n\n  const Quantum\n    *p;\n\n  ssize_t\n    i,\n    x;\n\n  Quantum\n    *q;\n\n  size_t\n    characters_per_pixel,\n    colors;\n\n  ssize_t\n    j,\n    k,\n    y;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n  SetGeometry(image,&geometry);\n  (void) ParseMetaGeometry(PiconGeometry,&geometry.x,&geometry.y,\n    &geometry.width,&geometry.height);\n  picon=ResizeImage(image,geometry.width,geometry.height,TriangleFilter,\n    exception);\n  blob_info=CloneImageInfo(image_info);\n  *blob_info->magick='\\0';\n  (void) AcquireUniqueFilename(blob_info->filename);\n  if ((image_info->type != TrueColorType) &&\n      (IdentifyImageCoderGray(image,exception) != MagickFalse))\n    affinity_image=BlobToImage(blob_info,Graymap,GraymapExtent,exception);\n  else\n    affinity_image=BlobToImage(blob_info,Colormap,ColormapExtent,exception);\n  (void) RelinquishUniqueFileResource(blob_info->filename);\n  blob_info=DestroyImageInfo(blob_info);\n  if ((picon == (Image *) NULL) || (affinity_image == (Image *) NULL))\n    {\n      if (affinity_image != (Image *) NULL)\n        affinity_image=DestroyImage(affinity_image);\n      if (picon != (Image *) NULL)\n        picon=DestroyImage(picon);\n      return(MagickFalse);\n    }\n  quantize_info=AcquireQuantizeInfo(image_info);\n  status=RemapImage(quantize_info,picon,affinity_image,exception);\n  quantize_info=DestroyQuantizeInfo(quantize_info);\n  affinity_image=DestroyImage(affinity_image);\n  transparent=MagickFalse;\n  if (picon->storage_class == PseudoClass)\n    {\n      (void) CompressImageColormap(picon,exception);\n      if (picon->alpha_trait != UndefinedPixelTrait)\n        transparent=MagickTrue;\n    }\n  else\n    {\n      /*\n        Convert DirectClass to PseudoClass picon.\n      */\n      if (picon->alpha_trait != UndefinedPixelTrait)\n        {\n          /*\n            Map all the transparent pixels.\n          */\n          for (y=0; y < (ssize_t) picon->rows; y++)\n          {\n            q=GetAuthenticPixels(picon,0,y,picon->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) picon->columns; x++)\n            {\n              if (GetPixelAlpha(image,q) == (Quantum) TransparentAlpha)\n                transparent=MagickTrue;\n              else\n                SetPixelAlpha(picon,OpaqueAlpha,q);\n              q+=GetPixelChannels(picon);\n            }\n            if (SyncAuthenticPixels(picon,exception) == MagickFalse)\n              break;\n          }\n        }\n      (void) SetImageType(picon,PaletteType,exception);\n    }\n  colors=picon->colors;\n  if (transparent != MagickFalse)\n    {\n      colors++;\n      picon->colormap=(PixelInfo *) ResizeQuantumMemory((void **)\n        picon->colormap,(size_t) colors,sizeof(*picon->colormap));\n      if (picon->colormap == (PixelInfo *) NULL)\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationError\");\n      picon->colormap[colors-1].red=0.0;\n      picon->colormap[colors-1].green=0.0;\n      picon->colormap[colors-1].blue=0.0;\n      picon->colormap[colors-1].alpha=TransparentAlpha;\n      for (y=0; y < (ssize_t) picon->rows; y++)\n      {\n        q=GetAuthenticPixels(picon,0,y,picon->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < (ssize_t) picon->columns; x++)\n        {\n          if (GetPixelAlpha(image,q) == (Quantum) TransparentAlpha)\n            SetPixelIndex(picon,(Quantum) picon->colors,q);\n          q+=GetPixelChannels(picon);\n        }\n        if (SyncAuthenticPixels(picon,exception) == MagickFalse)\n          break;\n      }\n    }\n  /*\n    Compute the character per pixel.\n  */\n  characters_per_pixel=1;\n  for (k=MaxCixels; (ssize_t) colors > k; k*=MaxCixels)\n    characters_per_pixel++;\n  /*\n    XPM header.\n  */\n  (void) WriteBlobString(image,\"/* XPM */\\n\");\n  GetPathComponent(picon->filename,BasePath,basename);\n  (void) FormatLocaleString(buffer,MagickPathExtent,\n    \"static const char *%.1024s[] = {\\n\",basename);\n  (void) WriteBlobString(image,buffer);\n  (void) WriteBlobString(image,\"/* columns rows colors chars-per-pixel */\\n\");\n  (void) FormatLocaleString(buffer,MagickPathExtent,\n    \"\\\"%.20g %.20g %.20g %.20g\\\",\\n\",(double) picon->columns,(double)\n    picon->rows,(double) colors,(double) characters_per_pixel);\n  (void) WriteBlobString(image,buffer);\n  GetPixelInfo(image,&pixel);\n  for (i=0; i < (ssize_t) colors; i++)\n  {\n    /*\n      Define XPM color.\n    */\n    pixel=picon->colormap[i];\n    pixel.colorspace=sRGBColorspace;\n    pixel.depth=8;\n    pixel.alpha=(double) OpaqueAlpha;\n    (void) QueryColorname(image,&pixel,XPMCompliance,name,exception);\n    if (transparent != MagickFalse)\n      {\n        if (i == (ssize_t) (colors-1))\n          (void) CopyMagickString(name,\"grey75\",MagickPathExtent);\n      }\n    /*\n      Write XPM color.\n    */\n    k=i % MaxCixels;\n    symbol[0]=Cixel[k];\n    for (j=1; j < (ssize_t) characters_per_pixel; j++)\n    {\n      k=((i-k)/MaxCixels) % MaxCixels;\n      symbol[j]=Cixel[k];\n    }\n    symbol[j]='\\0';\n    (void) FormatLocaleString(buffer,MagickPathExtent,\n      \"\\\"%.1024s c %.1024s\\\",\\n\",symbol,name);\n    (void) WriteBlobString(image,buffer);\n  }\n  /*\n    Define XPM pixels.\n  */\n  (void) WriteBlobString(image,\"/* pixels */\\n\");\n  for (y=0; y < (ssize_t) picon->rows; y++)\n  {\n    p=GetVirtualPixels(picon,0,y,picon->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    (void) WriteBlobString(image,\"\\\"\");\n    for (x=0; x < (ssize_t) picon->columns; x++)\n    {\n      k=((ssize_t) GetPixelIndex(picon,p) % MaxCixels);\n      symbol[0]=Cixel[k];\n      for (j=1; j < (ssize_t) characters_per_pixel; j++)\n      {\n        k=(((int) GetPixelIndex(picon,p)-k)/MaxCixels) % MaxCixels;\n        symbol[j]=Cixel[k];\n      }\n      symbol[j]='\\0';\n      (void) CopyMagickString(buffer,symbol,MagickPathExtent);\n      (void) WriteBlobString(image,buffer);\n      p+=GetPixelChannels(picon);\n    }\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"\\\"%.1024s\\n\",\n      y == (ssize_t) (picon->rows-1) ? \"\" : \",\");\n    (void) WriteBlobString(image,buffer);\n    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n      picon->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  picon=DestroyImage(picon);\n  (void) WriteBlobString(image,\"};\\n\");\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e X P M I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteXPMImage() writes an image to a file in the X pixmap format.\n%\n%  The format of the WriteXPMImage method is:\n%\n%      MagickBooleanType WriteXPMImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WriteXPMImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n#define MaxCixels  92\n\n  static const char\n    Cixel[MaxCixels+1] = \" .XoO+@#$%&*=-;:>,<1234567890qwertyuipasdfghjk\"\n                         \"lzxcvbnmMNBVCZASDFGHJKLPIUYTREWQ!~^/()_`'][{}|\";\n\n  char\n    buffer[MagickPathExtent],\n    basename[MagickPathExtent],\n    name[MagickPathExtent],\n    symbol[MagickPathExtent];\n\n  MagickBooleanType\n    status;\n\n  PixelInfo\n    pixel;\n\n  const Quantum\n    *p;\n\n  ssize_t\n    i,\n    x;\n\n  size_t\n    characters_per_pixel;\n\n  ssize_t\n    j,\n    k,\n    opacity,\n    y;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n    if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n      (void) TransformImageColorspace(image,sRGBColorspace,exception);\n  opacity=(-1);\n  if (image->alpha_trait == UndefinedPixelTrait)\n    {\n      if ((image->storage_class == DirectClass) || (image->colors > 256))\n        (void) SetImageType(image,PaletteType,exception);\n    }\n  else\n    {\n      double\n        alpha,\n        beta;\n\n      /*\n        Identify transparent colormap index.\n      */\n      if ((image->storage_class == DirectClass) || (image->colors > 256))\n        (void) SetImageType(image,PaletteBilevelAlphaType,exception);\n      for (i=0; i < (ssize_t) image->colors; i++)\n        if (image->colormap[i].alpha != OpaqueAlpha)\n          {\n            if (opacity < 0)\n              {\n                opacity=i;\n                continue;\n              }\n            alpha=(double) TransparentAlpha-(double)\n              image->colormap[i].alpha;\n            beta=(double) TransparentAlpha-(double)\n              image->colormap[opacity].alpha;\n            if (alpha < beta)\n              opacity=i;\n          }\n      if (opacity == -1)\n        {\n          (void) SetImageType(image,PaletteBilevelAlphaType,exception);\n          for (i=0; i < (ssize_t) image->colors; i++)\n            if (image->colormap[i].alpha != OpaqueAlpha)\n              {\n                if (opacity < 0)\n                  {\n                    opacity=i;\n                    continue;\n                  }\n                alpha=(Quantum) TransparentAlpha-(double)\n                  image->colormap[i].alpha;\n                beta=(Quantum) TransparentAlpha-(double)\n                  image->colormap[opacity].alpha;\n                if (alpha < beta)\n                  opacity=i;\n              }\n        }\n      if (opacity >= 0)\n        {\n          image->colormap[opacity].red=image->transparent_color.red;\n          image->colormap[opacity].green=image->transparent_color.green;\n          image->colormap[opacity].blue=image->transparent_color.blue;\n        }\n    }\n  /*\n    Compute the character per pixel.\n  */\n  characters_per_pixel=1;\n  for (k=MaxCixels; (ssize_t) image->colors > k; k*=MaxCixels)\n    characters_per_pixel++;\n  /*\n    XPM header.\n  */\n  (void) WriteBlobString(image,\"/* XPM */\\n\");\n  GetPathComponent(image->filename,BasePath,basename);\n  if (isalnum((int) ((unsigned char) *basename)) == 0)\n    {\n      (void) FormatLocaleString(buffer,MagickPathExtent,\"xpm_%.1024s\",basename);\n      (void) CopyMagickString(basename,buffer,MagickPathExtent);\n    }\n  if (isalpha((int) ((unsigned char) basename[0])) == 0)\n    basename[0]='_';\n  for (i=1; basename[i] != '\\0'; i++)\n    if (isalnum((int) ((unsigned char) basename[i])) == 0)\n      basename[i]='_';\n  (void) FormatLocaleString(buffer,MagickPathExtent,\n    \"static char *%.1024s[] = {\\n\",basename);\n  (void) WriteBlobString(image,buffer);\n  (void) WriteBlobString(image,\"/* columns rows colors chars-per-pixel */\\n\");\n  (void) FormatLocaleString(buffer,MagickPathExtent,\n    \"\\\"%.20g %.20g %.20g %.20g \\\",\\n\",(double) image->columns,(double)\n    image->rows,(double) image->colors,(double) characters_per_pixel);\n  (void) WriteBlobString(image,buffer);\n  GetPixelInfo(image,&pixel);\n  for (i=0; i < (ssize_t) image->colors; i++)\n  {\n    const char\n      *symbolic;\n\n    /*\n      Define XPM color.\n    */\n    pixel=image->colormap[i];\n    pixel.colorspace=sRGBColorspace;\n    pixel.depth=8;\n    pixel.alpha=(double) OpaqueAlpha;\n    (void) QueryColorname(image,&pixel,XPMCompliance,name,exception);\n    if (i == opacity)\n      (void) CopyMagickString(name,\"None\",MagickPathExtent);\n    /*\n      Write XPM color.\n    */\n    k=i % MaxCixels;\n    symbol[0]=Cixel[k];\n    for (j=1; j < (ssize_t) characters_per_pixel; j++)\n    {\n      k=((i-k)/MaxCixels) % MaxCixels;\n      symbol[j]=Cixel[k];\n    }\n    symbol[j]='\\0';\n    symbolic=(const char *) GetValueFromSplayTree(xpm_symbolic,name);\n    if (symbolic == (const char *) NULL)\n      (void) FormatLocaleString(buffer,MagickPathExtent,\n        \"\\\"%.1024s c %.1024s\\\",\\n\",symbol,name);\n    else\n      (void) FormatLocaleString(buffer,MagickPathExtent,\n        \"\\\"%.1024s c %.1024s %.1024s\\\",\\n\",symbol,name,symbolic);\n    (void) WriteBlobString(image,buffer);\n  }\n  /*\n    Define XPM pixels.\n  */\n  (void) WriteBlobString(image,\"/* pixels */\\n\");\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    (void) WriteBlobString(image,\"\\\"\");\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      k=((ssize_t) GetPixelIndex(image,p) % MaxCixels);\n      symbol[0]=Cixel[k];\n      for (j=1; j < (ssize_t) characters_per_pixel; j++)\n      {\n        k=(((int) GetPixelIndex(image,p)-k)/MaxCixels) % MaxCixels;\n        symbol[j]=Cixel[k];\n      }\n      symbol[j]='\\0';\n      (void) CopyMagickString(buffer,symbol,MagickPathExtent);\n      (void) WriteBlobString(image,buffer);\n      p+=GetPixelChannels(image);\n    }\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"\\\"%.1024s\\n\",\n      (y == (ssize_t) (image->rows-1) ? \"\" : \",\"));\n    (void) WriteBlobString(image,buffer);\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  (void) WriteBlobString(image,\"};\\n\");\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            X   X  PPPP   M   M                              %\n%                             X X   P   P  MM MM                              %\n%                              X    PPPP   M M M                              %\n%                             X X   P      M   M                              %\n%                            X   X  P      M   M                              %\n%                                                                             %\n%                                                                             %\n%                  Read/Write X Windows system Pixmap Format                  %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2021 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/coder-private.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/quantize.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/resize.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/splay-tree.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/threshold.h\"\n#include \"MagickCore/utility.h\"\n#include \"coders/coders-private.h\"\n\f\n/*\n  Global declarations.\n*/\nstatic SplayTreeInfo\n  *xpm_symbolic = (SplayTreeInfo *) NULL;\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WritePICONImage(const ImageInfo *,Image *,ExceptionInfo *),\n  WriteXPMImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s X P M                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsXPM() returns MagickTrue if the image format type, identified by the\n%  magick string, is XPM.\n%\n%  The format of the IsXPM method is:\n%\n%      MagickBooleanType IsXPM(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes. or\n%      blob.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsXPM(const unsigned char *magick,const size_t length)\n{\n  if (length < 9)\n    return(MagickFalse);\n  if (LocaleNCompare((char *) magick+1,\"* XPM *\",7) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d X P M I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadXPMImage() reads an X11 pixmap image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadXPMImage method is:\n%\n%      Image *ReadXPMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic int CompareXPMColor(const void *target,const void *source)\n{\n  const char\n    *p,\n    *q;\n\n  p=(const char *) target;\n  q=(const char *) source;\n  return(strcmp(p,q));\n}\n\nstatic ssize_t CopyXPMColor(char *destination,const char *source,size_t length)\n{\n  const char\n    *p;\n\n  p=source;\n  while (length-- && (*p != '\\0'))\n  {\n    if (*p == '\"')\n      break;\n    *destination++=(*p++);\n  }\n  if (length != 0)\n    *destination='\\0';\n  return((ssize_t) (p-source));\n}\n\nstatic char *NextXPMLine(char *p)\n{\n  assert(p != (char *) NULL);\n  p=strchr(p,'\\n');\n  if (p != (char *) NULL)\n    p++;\n  return(p);\n}\n\nstatic char *ParseXPMColor(char *,MagickBooleanType)\n  magick_attribute((__pure__));\n\nstatic char *ParseXPMColor(char *color,MagickBooleanType search_start)\n{\n#define NumberTargets  6\n\n  char\n    *p,\n    *r;\n\n  const char\n    *q;\n\n  ssize_t\n    i;\n\n  static const char\n    *const targets[NumberTargets] = { \"c \", \"g \", \"g4 \", \"m \", \"b \", \"s \" };\n\n  if (*color == '\\0')\n    return((char *) NULL);\n  if (search_start != MagickFalse)\n    {\n      for (i=0; i < NumberTargets; i++)\n      {\n        p=color;\n        for (q=targets[i]; *p != '\\0'; p++)\n        {\n          if (*p == '\\n')\n            break;\n          if (*p != *q)\n            continue;\n          if (isspace((int) ((unsigned char) (*(p-1)))) == 0)\n            continue;\n          r=p;\n          for ( ; ; )\n          {\n            if (*q == '\\0')\n              return(p);\n            if (*r++ != *q++)\n              break;\n          }\n          q=targets[i];\n        }\n      }\n      return((char *) NULL);\n    }\n  for (p=color+1; *p != '\\0'; p++)\n  {\n    if (*p == '\\n')\n      break;\n    if (isspace((int) ((unsigned char) (*(p-1)))) == 0)\n      continue;\n    if (isspace((int) ((unsigned char) (*p))) != 0)\n      continue;\n    for (i=0; i < NumberTargets; i++)\n    {\n      if ((*p == *targets[i]) && (*(p+1) == *(targets[i]+1)))\n        return(p);\n    }\n  }\n  return(p);\n}\n\nstatic Image *ReadXPMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    *grey,\n    key[MagickPathExtent],\n    target[MagickPathExtent],\n    *xpm_buffer;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    active,\n    status;\n\n  char\n    *next,\n    *p,\n    *q;\n\n  Quantum\n    *r;\n\n  ssize_t\n    x;\n\n  size_t\n    length;\n\n  SplayTreeInfo\n    *xpm_colors;\n\n  ssize_t\n    count,\n    j,\n    y;\n\n  unsigned long\n    colors,\n    columns,\n    rows,\n    width;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read XPM file.\n  */\n  length=MagickPathExtent;\n  xpm_buffer=(char *) AcquireQuantumMemory((size_t) length,sizeof(*xpm_buffer));\n  if (xpm_buffer == (char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  *xpm_buffer='\\0';\n  p=xpm_buffer;\n  while (ReadBlobString(image,p) != (char *) NULL)\n  {\n    if ((*p == '#') && ((p == xpm_buffer) || (*(p-1) == '\\n')))\n      continue;\n    if ((*p == '}') && (*(p+1) == ';'))\n      break;\n    p+=strlen(p);\n    if ((size_t) (p-xpm_buffer+MagickPathExtent) < length)\n      continue;\n    length<<=1;\n    xpm_buffer=(char *) ResizeQuantumMemory(xpm_buffer,length+MagickPathExtent,\n      sizeof(*xpm_buffer));\n    if (xpm_buffer == (char *) NULL)\n      break;\n    p=xpm_buffer+strlen(xpm_buffer);\n  }\n  if (xpm_buffer == (char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  /*\n    Remove comments.\n  */\n  count=0;\n  width=0;\n  for (p=xpm_buffer; *p != '\\0'; p++)\n  {\n    if (*p != '\"')\n      continue;\n    count=(ssize_t) sscanf(p+1,\"%lu %lu %lu %lu\",&columns,&rows,&colors,&width);\n    image->columns=columns;\n    image->rows=rows;\n    image->colors=colors;\n    if (count == 4)\n      break;\n  }\n  if ((count != 4) || (width == 0) || (width > 3) ||\n      (image->columns == 0) || (image->rows == 0) ||\n      (image->colors == 0) || (image->colors > MaxColormapSize))\n    {\n      xpm_buffer=DestroyString(xpm_buffer);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  /*\n    Remove unquoted characters.\n  */\n  active=MagickFalse;\n  for (q=xpm_buffer; *p != '\\0'; )\n  {\n    if (*p++ == '\"')\n      {\n        if (active != MagickFalse)\n          *q++='\\n';\n        active=active != MagickFalse ? MagickFalse : MagickTrue;\n      }\n    if (active != MagickFalse)\n      *q++=(*p);\n  }\n  *q='\\0';\n  if (active != MagickFalse)\n    {\n      xpm_buffer=DestroyString(xpm_buffer);\n      ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n    }\n  /*\n    Initialize image structure.\n  */\n  xpm_colors=NewSplayTree(CompareXPMColor,RelinquishMagickMemory,\n    (void *(*)(void *)) NULL);\n  if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n    {\n      xpm_colors=DestroySplayTree(xpm_colors);\n      xpm_buffer=DestroyString(xpm_buffer);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  /*\n    Read image colormap.\n  */\n  image->depth=1;\n  next=NextXPMLine(xpm_buffer);\n  for (j=0; (j < (ssize_t) image->colors) && (next != (char *) NULL); j++)\n  {\n    char\n      symbolic[MagickPathExtent];\n\n    p=next;\n    next=NextXPMLine(p);\n    if (next == (char *) NULL)\n      break;\n    length=MagickMin((size_t) width,MagickPathExtent-1);\n    if (CopyXPMColor(key,p,length) != (ssize_t) length)\n      break;\n    status=AddValueToSplayTree(xpm_colors,ConstantString(key),(void *) j);\n    /*\n      Parse color.\n    */\n    (void) memset(target,0,sizeof(target));\n    (void) CopyMagickString(target,\"gray\",MagickPathExtent);\n    q=(char *) NULL;\n    if (strlen(p) > width)\n      q=ParseXPMColor(p+width,MagickTrue);\n    (void) memset(symbolic,0,sizeof(symbolic));\n    *symbolic='\\0';\n    if (q != (char *) NULL)\n      {\n        while ((isspace((int) ((unsigned char) *q)) == 0) && (*q != '\\0'))\n          q++;\n        if ((next-q) < 0)\n          break;\n        (void) CopyXPMColor(target,q,MagickMin((size_t) (next-q),\n          MagickPathExtent-1));\n        q=ParseXPMColor(target,MagickFalse);\n        (void) CopyXPMColor(symbolic,q,MagickMin((size_t) (next-q),\n          MagickPathExtent-1));\n        if (q != (char *) NULL)\n          *q='\\0';\n      }\n    (void) StripMagickString(target);\n    if (*symbolic != '\\0')\n      (void) AddValueToSplayTree(xpm_symbolic,ConstantString(target),\n        ConstantString(symbolic));\n    grey=strstr(target,\"grey\");\n    if (grey != (char *) NULL)\n      grey[2]='a';\n    if (LocaleCompare(target,\"none\") == 0)\n      {\n        image->storage_class=DirectClass;\n        image->alpha_trait=BlendPixelTrait;\n      }\n    status=QueryColorCompliance(target,XPMCompliance,&image->colormap[j],\n      exception);\n    if (status == MagickFalse)\n      break;\n    if (image->depth < image->colormap[j].depth)\n      image->depth=image->colormap[j].depth;\n  }\n  if (j < (ssize_t) image->colors)\n    {\n      xpm_colors=DestroySplayTree(xpm_colors);\n      xpm_buffer=DestroyString(xpm_buffer);\n      ThrowReaderException(CorruptImageError,\"CorruptImage\");\n    }\n  j=0;\n  if (image_info->ping == MagickFalse)\n    {\n      /*\n        Read image pixels.\n      */\n      status=SetImageExtent(image,image->columns,image->rows,exception);\n      if (status == MagickFalse)\n        {\n          xpm_colors=DestroySplayTree(xpm_colors);\n          xpm_buffer=DestroyString(xpm_buffer);\n          return(DestroyImageList(image));\n        }\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        p=NextXPMLine(p);\n        if (p == (char *) NULL)\n          break;\n        r=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (r == (Quantum *) NULL)\n          break;\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          count=CopyXPMColor(key,p,MagickMin(width,MagickPathExtent-1));\n          if (count != (ssize_t) width)\n            break;\n          j=(ssize_t) GetValueFromSplayTree(xpm_colors,key);\n          if (image->storage_class == PseudoClass)\n            SetPixelIndex(image,(Quantum) j,r);\n          SetPixelViaPixelInfo(image,image->colormap+j,r);\n          p+=count;\n          r+=GetPixelChannels(image);\n        }\n        if (x < (ssize_t) image->columns)\n          break;\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n      }\n      if (y < (ssize_t) image->rows)\n        {\n          xpm_colors=DestroySplayTree(xpm_colors);\n          xpm_buffer=DestroyString(xpm_buffer);\n          ThrowReaderException(CorruptImageError,\"NotEnoughPixelData\");\n        }\n    }\n  /*\n    Relinquish resources.\n  */\n  xpm_buffer=DestroyString(xpm_buffer);\n  xpm_colors=DestroySplayTree(xpm_colors);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r X P M I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterXPMImage() adds attributes for the XPM image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterXPMImage method is:\n%\n%      size_t RegisterXPMImage(void)\n%\n*/\nModuleExport size_t RegisterXPMImage(void)\n{\n  MagickInfo\n    *entry;\n\n  if (xpm_symbolic == (SplayTreeInfo *) NULL)\n    xpm_symbolic=NewSplayTree(CompareSplayTreeString,RelinquishMagickMemory,\n      RelinquishMagickMemory);\n  entry=AcquireMagickInfo(\"XPM\",\"PICON\",\"Personal Icon\");\n  entry->decoder=(DecodeImageHandler *) ReadXPMImage;\n  entry->encoder=(EncodeImageHandler *) WritePICONImage;\n  entry->flags^=CoderAdjoinFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"XPM\",\"PM\",\"X Windows system pixmap (color)\");\n  entry->decoder=(DecodeImageHandler *) ReadXPMImage;\n  entry->encoder=(EncodeImageHandler *) WriteXPMImage;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags|=CoderStealthFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"XPM\",\"XPM\",\"X Windows system pixmap (color)\");\n  entry->decoder=(DecodeImageHandler *) ReadXPMImage;\n  entry->encoder=(EncodeImageHandler *) WriteXPMImage;\n  entry->magick=(IsImageFormatHandler *) IsXPM;\n  entry->flags^=CoderAdjoinFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r X P M I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterXPMImage() removes format registrations made by the\n%  XPM module from the list of supported formats.\n%\n%  The format of the UnregisterXPMImage method is:\n%\n%      UnregisterXPMImage(void)\n%\n*/\nModuleExport void UnregisterXPMImage(void)\n{\n  (void) UnregisterMagickInfo(\"PICON\");\n  (void) UnregisterMagickInfo(\"PM\");\n  (void) UnregisterMagickInfo(\"XPM\");\n  if (xpm_symbolic != (SplayTreeInfo *) NULL)\n    xpm_symbolic=DestroySplayTree(xpm_symbolic);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e P I C O N I m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WritePICONImage() writes an image to a file in the Personal Icon format.\n%\n%  The format of the WritePICONImage method is:\n%\n%      MagickBooleanType WritePICONImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WritePICONImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n#define ColormapExtent  155\n#define GraymapExtent  95\n#define PiconGeometry  \"48x48>\"\n\n  static unsigned char\n    Colormap[]=\n    {\n      0x47, 0x49, 0x46, 0x38, 0x37, 0x61, 0x06, 0x00, 0x05, 0x00, 0xf4, 0x05,\n      0x00, 0x00, 0x00, 0x00, 0x2f, 0x4f, 0x4f, 0x70, 0x80, 0x90, 0x7e, 0x7e,\n      0x7e, 0xdc, 0xdc, 0xdc, 0xff, 0xff, 0xff, 0x00, 0x00, 0x80, 0x00, 0x00,\n      0xff, 0x1e, 0x90, 0xff, 0x87, 0xce, 0xeb, 0xe6, 0xe6, 0xfa, 0x00, 0xff,\n      0xff, 0x80, 0x00, 0x80, 0xb2, 0x22, 0x22, 0x2e, 0x8b, 0x57, 0x32, 0xcd,\n      0x32, 0x00, 0xff, 0x00, 0x98, 0xfb, 0x98, 0xff, 0x00, 0xff, 0xff, 0x00,\n      0x00, 0xff, 0x63, 0x47, 0xff, 0xa5, 0x00, 0xff, 0xd7, 0x00, 0xff, 0xff,\n      0x00, 0xee, 0x82, 0xee, 0xa0, 0x52, 0x2d, 0xcd, 0x85, 0x3f, 0xd2, 0xb4,\n      0x8c, 0xf5, 0xde, 0xb3, 0xff, 0xfa, 0xcd, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x21, 0xf9, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x00, 0x00,\n      0x00, 0x00, 0x06, 0x00, 0x05, 0x00, 0x00, 0x05, 0x18, 0x20, 0x10, 0x08,\n      0x03, 0x51, 0x18, 0x07, 0x92, 0x28, 0x0b, 0xd3, 0x38, 0x0f, 0x14, 0x49,\n      0x13, 0x55, 0x59, 0x17, 0x96, 0x69, 0x1b, 0xd7, 0x85, 0x00, 0x3b,\n    },\n    Graymap[]=\n    {\n      0x47, 0x49, 0x46, 0x38, 0x37, 0x61, 0x04, 0x00, 0x04, 0x00, 0xf3, 0x0f,\n      0x00, 0x00, 0x00, 0x00, 0x12, 0x12, 0x12, 0x21, 0x21, 0x21, 0x33, 0x33,\n      0x33, 0x45, 0x45, 0x45, 0x54, 0x54, 0x54, 0x66, 0x66, 0x66, 0x78, 0x78,\n      0x78, 0x87, 0x87, 0x87, 0x99, 0x99, 0x99, 0xab, 0xab, 0xab, 0xba, 0xba,\n      0xba, 0xcc, 0xcc, 0xcc, 0xde, 0xde, 0xde, 0xed, 0xed, 0xed, 0xff, 0xff,\n      0xff, 0x21, 0xf9, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x00, 0x00,\n      0x00, 0x00, 0x04, 0x00, 0x04, 0x00, 0x00, 0x04, 0x0c, 0x10, 0x04, 0x31,\n      0x48, 0x31, 0x07, 0x25, 0xb5, 0x58, 0x73, 0x4f, 0x04, 0x00, 0x3b,\n    };\n\n#define MaxCixels  92\n\n  static const char\n    Cixel[MaxCixels+1] = \" .XoO+@#$%&*=-;:>,<1234567890qwertyuipasdfghjk\"\n                         \"lzxcvbnmMNBVCZASDFGHJKLPIUYTREWQ!~^/()_`'][{}|\";\n\n  char\n    buffer[MagickPathExtent],\n    basename[MagickPathExtent],\n    name[MagickPathExtent],\n    symbol[MagickPathExtent];\n\n  Image\n    *affinity_image,\n    *picon;\n\n  ImageInfo\n    *blob_info;\n\n  MagickBooleanType\n    status,\n    transparent;\n\n  PixelInfo\n    pixel;\n\n  QuantizeInfo\n    *quantize_info;\n\n  RectangleInfo\n    geometry;\n\n  const Quantum\n    *p;\n\n  ssize_t\n    i,\n    x;\n\n  Quantum\n    *q;\n\n  size_t\n    characters_per_pixel,\n    colors;\n\n  ssize_t\n    j,\n    k,\n    y;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n  SetGeometry(image,&geometry);\n  (void) ParseMetaGeometry(PiconGeometry,&geometry.x,&geometry.y,\n    &geometry.width,&geometry.height);\n  picon=ResizeImage(image,geometry.width,geometry.height,TriangleFilter,\n    exception);\n  blob_info=CloneImageInfo(image_info);\n  *blob_info->magick='\\0';\n  (void) AcquireUniqueFilename(blob_info->filename);\n  if ((image_info->type != TrueColorType) &&\n      (IdentifyImageCoderGray(image,exception) != MagickFalse))\n    affinity_image=BlobToImage(blob_info,Graymap,GraymapExtent,exception);\n  else\n    affinity_image=BlobToImage(blob_info,Colormap,ColormapExtent,exception);\n  (void) RelinquishUniqueFileResource(blob_info->filename);\n  blob_info=DestroyImageInfo(blob_info);\n  if ((picon == (Image *) NULL) || (affinity_image == (Image *) NULL))\n    {\n      if (affinity_image != (Image *) NULL)\n        affinity_image=DestroyImage(affinity_image);\n      if (picon != (Image *) NULL)\n        picon=DestroyImage(picon);\n      return(MagickFalse);\n    }\n  quantize_info=AcquireQuantizeInfo(image_info);\n  status=RemapImage(quantize_info,picon,affinity_image,exception);\n  quantize_info=DestroyQuantizeInfo(quantize_info);\n  affinity_image=DestroyImage(affinity_image);\n  transparent=MagickFalse;\n  if (picon->storage_class == PseudoClass)\n    {\n      (void) CompressImageColormap(picon,exception);\n      if (picon->alpha_trait != UndefinedPixelTrait)\n        transparent=MagickTrue;\n    }\n  else\n    {\n      /*\n        Convert DirectClass to PseudoClass picon.\n      */\n      if (picon->alpha_trait != UndefinedPixelTrait)\n        {\n          /*\n            Map all the transparent pixels.\n          */\n          for (y=0; y < (ssize_t) picon->rows; y++)\n          {\n            q=GetAuthenticPixels(picon,0,y,picon->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) picon->columns; x++)\n            {\n              if (GetPixelAlpha(picon,q) == (Quantum) TransparentAlpha)\n                transparent=MagickTrue;\n              else\n                SetPixelAlpha(picon,OpaqueAlpha,q);\n              q+=GetPixelChannels(picon);\n            }\n            if (SyncAuthenticPixels(picon,exception) == MagickFalse)\n              break;\n          }\n        }\n      (void) SetImageType(picon,PaletteType,exception);\n    }\n  colors=picon->colors;\n  if (transparent != MagickFalse)\n    {\n      colors++;\n      picon->colormap=(PixelInfo *) ResizeQuantumMemory((void **)\n        picon->colormap,(size_t) colors,sizeof(*picon->colormap));\n      if (picon->colormap == (PixelInfo *) NULL)\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationError\");\n      picon->colormap[colors-1].red=0.0;\n      picon->colormap[colors-1].green=0.0;\n      picon->colormap[colors-1].blue=0.0;\n      picon->colormap[colors-1].alpha=TransparentAlpha;\n      for (y=0; y < (ssize_t) picon->rows; y++)\n      {\n        q=GetAuthenticPixels(picon,0,y,picon->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < (ssize_t) picon->columns; x++)\n        {\n          if (GetPixelAlpha(picon,q) == (Quantum) TransparentAlpha)\n            SetPixelIndex(picon,(Quantum) picon->colors,q);\n          q+=GetPixelChannels(picon);\n        }\n        if (SyncAuthenticPixels(picon,exception) == MagickFalse)\n          break;\n      }\n    }\n  /*\n    Compute the character per pixel.\n  */\n  characters_per_pixel=1;\n  for (k=MaxCixels; (ssize_t) colors > k; k*=MaxCixels)\n    characters_per_pixel++;\n  /*\n    XPM header.\n  */\n  (void) WriteBlobString(image,\"/* XPM */\\n\");\n  GetPathComponent(picon->filename,BasePath,basename);\n  (void) FormatLocaleString(buffer,MagickPathExtent,\n    \"static const char *%.1024s[] = {\\n\",basename);\n  (void) WriteBlobString(image,buffer);\n  (void) WriteBlobString(image,\"/* columns rows colors chars-per-pixel */\\n\");\n  (void) FormatLocaleString(buffer,MagickPathExtent,\n    \"\\\"%.20g %.20g %.20g %.20g\\\",\\n\",(double) picon->columns,(double)\n    picon->rows,(double) colors,(double) characters_per_pixel);\n  (void) WriteBlobString(image,buffer);\n  GetPixelInfo(image,&pixel);\n  for (i=0; i < (ssize_t) colors; i++)\n  {\n    /*\n      Define XPM color.\n    */\n    pixel=picon->colormap[i];\n    pixel.colorspace=sRGBColorspace;\n    pixel.depth=8;\n    pixel.alpha=(double) OpaqueAlpha;\n    (void) QueryColorname(image,&pixel,XPMCompliance,name,exception);\n    if (transparent != MagickFalse)\n      {\n        if (i == (ssize_t) (colors-1))\n          (void) CopyMagickString(name,\"grey75\",MagickPathExtent);\n      }\n    /*\n      Write XPM color.\n    */\n    k=i % MaxCixels;\n    symbol[0]=Cixel[k];\n    for (j=1; j < (ssize_t) characters_per_pixel; j++)\n    {\n      k=((i-k)/MaxCixels) % MaxCixels;\n      symbol[j]=Cixel[k];\n    }\n    symbol[j]='\\0';\n    (void) FormatLocaleString(buffer,MagickPathExtent,\n      \"\\\"%.1024s c %.1024s\\\",\\n\",symbol,name);\n    (void) WriteBlobString(image,buffer);\n  }\n  /*\n    Define XPM pixels.\n  */\n  (void) WriteBlobString(image,\"/* pixels */\\n\");\n  for (y=0; y < (ssize_t) picon->rows; y++)\n  {\n    p=GetVirtualPixels(picon,0,y,picon->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    (void) WriteBlobString(image,\"\\\"\");\n    for (x=0; x < (ssize_t) picon->columns; x++)\n    {\n      k=((ssize_t) GetPixelIndex(picon,p) % MaxCixels);\n      symbol[0]=Cixel[k];\n      for (j=1; j < (ssize_t) characters_per_pixel; j++)\n      {\n        k=(((int) GetPixelIndex(picon,p)-k)/MaxCixels) % MaxCixels;\n        symbol[j]=Cixel[k];\n      }\n      symbol[j]='\\0';\n      (void) CopyMagickString(buffer,symbol,MagickPathExtent);\n      (void) WriteBlobString(image,buffer);\n      p+=GetPixelChannels(picon);\n    }\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"\\\"%.1024s\\n\",\n      y == (ssize_t) (picon->rows-1) ? \"\" : \",\");\n    (void) WriteBlobString(image,buffer);\n    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n      picon->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  picon=DestroyImage(picon);\n  (void) WriteBlobString(image,\"};\\n\");\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e X P M I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteXPMImage() writes an image to a file in the X pixmap format.\n%\n%  The format of the WriteXPMImage method is:\n%\n%      MagickBooleanType WriteXPMImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WriteXPMImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n#define MaxCixels  92\n\n  static const char\n    Cixel[MaxCixels+1] = \" .XoO+@#$%&*=-;:>,<1234567890qwertyuipasdfghjk\"\n                         \"lzxcvbnmMNBVCZASDFGHJKLPIUYTREWQ!~^/()_`'][{}|\";\n\n  char\n    buffer[MagickPathExtent],\n    basename[MagickPathExtent],\n    name[MagickPathExtent],\n    symbol[MagickPathExtent];\n\n  MagickBooleanType\n    status;\n\n  PixelInfo\n    pixel;\n\n  const Quantum\n    *p;\n\n  ssize_t\n    i,\n    x;\n\n  size_t\n    characters_per_pixel;\n\n  ssize_t\n    j,\n    k,\n    opacity,\n    y;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n    if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n      (void) TransformImageColorspace(image,sRGBColorspace,exception);\n  opacity=(-1);\n  if (image->alpha_trait == UndefinedPixelTrait)\n    {\n      if ((image->storage_class == DirectClass) || (image->colors > 256))\n        (void) SetImageType(image,PaletteType,exception);\n    }\n  else\n    {\n      double\n        alpha,\n        beta;\n\n      /*\n        Identify transparent colormap index.\n      */\n      if ((image->storage_class == DirectClass) || (image->colors > 256))\n        (void) SetImageType(image,PaletteBilevelAlphaType,exception);\n      for (i=0; i < (ssize_t) image->colors; i++)\n        if (image->colormap[i].alpha != OpaqueAlpha)\n          {\n            if (opacity < 0)\n              {\n                opacity=i;\n                continue;\n              }\n            alpha=(double) TransparentAlpha-(double)\n              image->colormap[i].alpha;\n            beta=(double) TransparentAlpha-(double)\n              image->colormap[opacity].alpha;\n            if (alpha < beta)\n              opacity=i;\n          }\n      if (opacity == -1)\n        {\n          (void) SetImageType(image,PaletteBilevelAlphaType,exception);\n          for (i=0; i < (ssize_t) image->colors; i++)\n            if (image->colormap[i].alpha != OpaqueAlpha)\n              {\n                if (opacity < 0)\n                  {\n                    opacity=i;\n                    continue;\n                  }\n                alpha=(Quantum) TransparentAlpha-(double)\n                  image->colormap[i].alpha;\n                beta=(Quantum) TransparentAlpha-(double)\n                  image->colormap[opacity].alpha;\n                if (alpha < beta)\n                  opacity=i;\n              }\n        }\n      if (opacity >= 0)\n        {\n          image->colormap[opacity].red=image->transparent_color.red;\n          image->colormap[opacity].green=image->transparent_color.green;\n          image->colormap[opacity].blue=image->transparent_color.blue;\n        }\n    }\n  /*\n    Compute the character per pixel.\n  */\n  characters_per_pixel=1;\n  for (k=MaxCixels; (ssize_t) image->colors > k; k*=MaxCixels)\n    characters_per_pixel++;\n  /*\n    XPM header.\n  */\n  (void) WriteBlobString(image,\"/* XPM */\\n\");\n  GetPathComponent(image->filename,BasePath,basename);\n  if (isalnum((int) ((unsigned char) *basename)) == 0)\n    {\n      (void) FormatLocaleString(buffer,MagickPathExtent,\"xpm_%.1024s\",basename);\n      (void) CopyMagickString(basename,buffer,MagickPathExtent);\n    }\n  if (isalpha((int) ((unsigned char) basename[0])) == 0)\n    basename[0]='_';\n  for (i=1; basename[i] != '\\0'; i++)\n    if (isalnum((int) ((unsigned char) basename[i])) == 0)\n      basename[i]='_';\n  (void) FormatLocaleString(buffer,MagickPathExtent,\n    \"static char *%.1024s[] = {\\n\",basename);\n  (void) WriteBlobString(image,buffer);\n  (void) WriteBlobString(image,\"/* columns rows colors chars-per-pixel */\\n\");\n  (void) FormatLocaleString(buffer,MagickPathExtent,\n    \"\\\"%.20g %.20g %.20g %.20g \\\",\\n\",(double) image->columns,(double)\n    image->rows,(double) image->colors,(double) characters_per_pixel);\n  (void) WriteBlobString(image,buffer);\n  GetPixelInfo(image,&pixel);\n  for (i=0; i < (ssize_t) image->colors; i++)\n  {\n    const char\n      *symbolic;\n\n    /*\n      Define XPM color.\n    */\n    pixel=image->colormap[i];\n    pixel.colorspace=sRGBColorspace;\n    pixel.depth=8;\n    pixel.alpha=(double) OpaqueAlpha;\n    (void) QueryColorname(image,&pixel,XPMCompliance,name,exception);\n    if (i == opacity)\n      (void) CopyMagickString(name,\"None\",MagickPathExtent);\n    /*\n      Write XPM color.\n    */\n    k=i % MaxCixels;\n    symbol[0]=Cixel[k];\n    for (j=1; j < (ssize_t) characters_per_pixel; j++)\n    {\n      k=((i-k)/MaxCixels) % MaxCixels;\n      symbol[j]=Cixel[k];\n    }\n    symbol[j]='\\0';\n    symbolic=(const char *) GetValueFromSplayTree(xpm_symbolic,name);\n    if (symbolic == (const char *) NULL)\n      (void) FormatLocaleString(buffer,MagickPathExtent,\n        \"\\\"%.1024s c %.1024s\\\",\\n\",symbol,name);\n    else\n      (void) FormatLocaleString(buffer,MagickPathExtent,\n        \"\\\"%.1024s c %.1024s %.1024s\\\",\\n\",symbol,name,symbolic);\n    (void) WriteBlobString(image,buffer);\n  }\n  /*\n    Define XPM pixels.\n  */\n  (void) WriteBlobString(image,\"/* pixels */\\n\");\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    (void) WriteBlobString(image,\"\\\"\");\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      k=((ssize_t) GetPixelIndex(image,p) % MaxCixels);\n      symbol[0]=Cixel[k];\n      for (j=1; j < (ssize_t) characters_per_pixel; j++)\n      {\n        k=(((int) GetPixelIndex(image,p)-k)/MaxCixels) % MaxCixels;\n        symbol[j]=Cixel[k];\n      }\n      symbol[j]='\\0';\n      (void) CopyMagickString(buffer,symbol,MagickPathExtent);\n      (void) WriteBlobString(image,buffer);\n      p+=GetPixelChannels(image);\n    }\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"\\\"%.1024s\\n\",\n      (y == (ssize_t) (image->rows-1) ? \"\" : \",\"));\n    (void) WriteBlobString(image,buffer);\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  (void) WriteBlobString(image,\"};\\n\");\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "filenames": ["coders/xpm.c"], "buggy_code_start_loc": [784], "buggy_code_end_loc": [816], "fixing_code_start_loc": [784], "fixing_code_end_loc": [816], "type": "CWE-125", "message": "A heap-based-buffer-over-read flaw was found in ImageMagick's GetPixelAlpha() function of 'pixel-accessor.h'. This vulnerability is triggered when an attacker passes a specially crafted Tagged Image File Format (TIFF) image to convert it into a PICON file format. This issue can potentially lead to a denial of service and information disclosure.", "other": {"cve": {"id": "CVE-2022-0284", "sourceIdentifier": "secalert@redhat.com", "published": "2022-08-29T15:15:09.183", "lastModified": "2022-09-01T19:58:48.510", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A heap-based-buffer-over-read flaw was found in ImageMagick's GetPixelAlpha() function of 'pixel-accessor.h'. This vulnerability is triggered when an attacker passes a specially crafted Tagged Image File Format (TIFF) image to convert it into a PICON file format. This issue can potentially lead to a denial of service and information disclosure."}, {"lang": "es", "value": "Se ha encontrado un fallo de lectura excesiva del b\u00fafer en la regi\u00f3n heap de la memoria en la funci\u00f3n GetPixelAlpha() del archivo \"pixel-accessor.h\" de ImageMagick. Esta vulnerabilidad es desencadenada cuando un atacante pasa una imagen especialmente dise\u00f1ada en formato de archivo de imagen etiquetada (TIFF) para convertirla en un formato de archivo PICON. Este problema puede conllevar a una denegaci\u00f3n de servicio y una divulgaci\u00f3n de informaci\u00f3n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.2}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionEndExcluding": "7.1.0-20", "matchCriteriaId": "90A073A6-900F-44EE-B29F-05CB65058078"}]}]}], "references": [{"url": "https://access.redhat.com/security/cve/CVE-2022-0284", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2045943", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/e50f19fd73c792ebe912df8ab83aa51a243a3da7", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/4729", "source": "secalert@redhat.com", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/e50f19fd73c792ebe912df8ab83aa51a243a3da7"}}