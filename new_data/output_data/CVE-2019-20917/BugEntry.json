{"buggy_code": ["/*\n * InspIRCd -- Internet Relay Chat Daemon\n *\n *   Copyright (C) 2009-2010 Daniel De Graaf <danieldg@inspircd.org>\n *   Copyright (C) 2006-2007, 2009 Dennis Friis <peavey@inspircd.org>\n *   Copyright (C) 2006-2009 Craig Edwards <craigedwards@brainbox.cc>\n *   Copyright (C) 2008 Robin Burchell <robin+git@viroteck.net>\n *\n * This file is part of InspIRCd.  InspIRCd is free software: you can\n * redistribute it and/or modify it under the terms of the GNU General Public\n * License as published by the Free Software Foundation, version 2.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n\n/* Stop mysql wanting to use long long */\n#define NO_CLIENT_LONG_LONG\n\n#include \"inspircd.h\"\n#include <mysql.h>\n#include \"sql.h\"\n\n#ifdef _WIN32\n# pragma comment(lib, \"libmysql.lib\")\n#endif\n\n/* VERSION 3 API: With nonblocking (threaded) requests */\n\n/* $ModDesc: SQL Service Provider module for all other m_sql* modules */\n/* $CompileFlags: exec(\"mysql_config --include\") */\n/* $LinkerFlags: exec(\"mysql_config --libs_r\") rpath(\"mysql_config --libs_r\") */\n\n/* THE NONBLOCKING MYSQL API!\n *\n * MySQL provides no nonblocking (asyncronous) API of its own, and its developers recommend\n * that instead, you should thread your program. This is what i've done here to allow for\n * asyncronous SQL requests via mysql. The way this works is as follows:\n *\n * The module spawns a thread via class Thread, and performs its mysql queries in this thread,\n * using a queue with priorities. There is a mutex on either end which prevents two threads\n * adjusting the queue at the same time, and crashing the ircd. Every 50 milliseconds, the\n * worker thread wakes up, and checks if there is a request at the head of its queue.\n * If there is, it processes this request, blocking the worker thread but leaving the ircd\n * thread to go about its business as usual. During this period, the ircd thread is able\n * to insert futher pending requests into the queue.\n *\n * Once the processing of a request is complete, it is removed from the incoming queue to\n * an outgoing queue, and initialized as a 'response'. The worker thread then signals the\n * ircd thread (via a loopback socket) of the fact a result is available, by sending the\n * connection ID through the connection.\n *\n * The ircd thread then mutexes the queue once more, reads the outbound response off the head\n * of the queue, and sends it on its way to the original calling module.\n *\n * XXX: You might be asking \"why doesnt he just send the response from within the worker thread?\"\n * The answer to this is simple. The majority of InspIRCd, and in fact most ircd's are not\n * threadsafe. This module is designed to be threadsafe and is careful with its use of threads,\n * however, if we were to call a module's OnRequest even from within a thread which was not the\n * one the module was originally instantiated upon, there is a chance of all hell breaking loose\n * if a module is ever put in a re-enterant state (stack corruption could occur, crashes, data\n * corruption, and worse, so DONT think about it until the day comes when InspIRCd is 100%\n * gauranteed threadsafe!)\n */\n\nclass SQLConnection;\nclass MySQLresult;\nclass DispatcherThread;\n\nstruct QQueueItem\n{\n\tSQLQuery* q;\n\tstd::string query;\n\tSQLConnection* c;\n\tQQueueItem(SQLQuery* Q, const std::string& S, SQLConnection* C) : q(Q), query(S), c(C) {}\n};\n\nstruct RQueueItem\n{\n\tSQLQuery* q;\n\tMySQLresult* r;\n\tRQueueItem(SQLQuery* Q, MySQLresult* R) : q(Q), r(R) {}\n};\n\ntypedef std::map<std::string, SQLConnection*> ConnMap;\ntypedef std::deque<QQueueItem> QueryQueue;\ntypedef std::deque<RQueueItem> ResultQueue;\n\n/** MySQL module\n *  */\nclass ModuleSQL : public Module\n{\n public:\n\tDispatcherThread* Dispatcher;\n\tQueryQueue qq;       // MUST HOLD MUTEX\n\tResultQueue rq;      // MUST HOLD MUTEX\n\tConnMap connections; // main thread only\n\n\tModuleSQL();\n\tvoid init();\n\t~ModuleSQL();\n\tvoid OnRehash(User* user);\n\tvoid OnUnloadModule(Module* mod);\n\tVersion GetVersion();\n};\n\nclass DispatcherThread : public SocketThread\n{\n private:\n\tModuleSQL* const Parent;\n public:\n\tDispatcherThread(ModuleSQL* CreatorModule) : Parent(CreatorModule) { }\n\t~DispatcherThread() { }\n\tvirtual void Run();\n\tvirtual void OnNotify();\n};\n\n#if !defined(MYSQL_VERSION_ID) || MYSQL_VERSION_ID<32224\n#define mysql_field_count mysql_num_fields\n#endif\n\n/** Represents a mysql result set\n */\nclass MySQLresult : public SQLResult\n{\n public:\n\tSQLerror err;\n\tint currentrow;\n\tint rows;\n\tstd::vector<std::string> colnames;\n\tstd::vector<SQLEntries> fieldlists;\n\n\tMySQLresult(MYSQL_RES* res, int affected_rows) : err(SQL_NO_ERROR), currentrow(0), rows(0)\n\t{\n\t\tif (affected_rows >= 1)\n\t\t{\n\t\t\trows = affected_rows;\n\t\t\tfieldlists.resize(rows);\n\t\t}\n\t\tunsigned int field_count = 0;\n\t\tif (res)\n\t\t{\n\t\t\tMYSQL_ROW row;\n\t\t\tint n = 0;\n\t\t\twhile ((row = mysql_fetch_row(res)))\n\t\t\t{\n\t\t\t\tif (fieldlists.size() < (unsigned int)rows+1)\n\t\t\t\t{\n\t\t\t\t\tfieldlists.resize(fieldlists.size()+1);\n\t\t\t\t}\n\t\t\t\tfield_count = 0;\n\t\t\t\tMYSQL_FIELD *fields = mysql_fetch_fields(res);\n\t\t\t\tif(mysql_num_fields(res) == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tif (fields && mysql_num_fields(res))\n\t\t\t\t{\n\t\t\t\t\tcolnames.clear();\n\t\t\t\t\twhile (field_count < mysql_num_fields(res))\n\t\t\t\t\t{\n\t\t\t\t\t\tstd::string a = (fields[field_count].name ? fields[field_count].name : \"\");\n\t\t\t\t\t\tif (row[field_count])\n\t\t\t\t\t\t\tfieldlists[n].push_back(SQLEntry(row[field_count]));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tfieldlists[n].push_back(SQLEntry());\n\t\t\t\t\t\tcolnames.push_back(a);\n\t\t\t\t\t\tfield_count++;\n\t\t\t\t\t}\n\t\t\t\t\tn++;\n\t\t\t\t}\n\t\t\t\trows++;\n\t\t\t}\n\t\t\tmysql_free_result(res);\n\t\t}\n\t}\n\n\tMySQLresult(SQLerror& e) : err(e)\n\t{\n\n\t}\n\n\t~MySQLresult()\n\t{\n\t}\n\n\tvirtual int Rows()\n\t{\n\t\treturn rows;\n\t}\n\n\tvirtual void GetCols(std::vector<std::string>& result)\n\t{\n\t\tresult.assign(colnames.begin(), colnames.end());\n\t}\n\n\tvirtual SQLEntry GetValue(int row, int column)\n\t{\n\t\tif ((row >= 0) && (row < rows) && (column >= 0) && (column < (int)fieldlists[row].size()))\n\t\t{\n\t\t\treturn fieldlists[row][column];\n\t\t}\n\t\treturn SQLEntry();\n\t}\n\n\tvirtual bool GetRow(SQLEntries& result)\n\t{\n\t\tif (currentrow < rows)\n\t\t{\n\t\t\tresult.assign(fieldlists[currentrow].begin(), fieldlists[currentrow].end());\n\t\t\tcurrentrow++;\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult.clear();\n\t\t\treturn false;\n\t\t}\n\t}\n};\n\n/** Represents a connection to a mysql database\n */\nclass SQLConnection : public SQLProvider\n{\n public:\n\treference<ConfigTag> config;\n\tMYSQL *connection;\n\tMutex lock;\n\n\t// This constructor creates an SQLConnection object with the given credentials, but does not connect yet.\n\tSQLConnection(Module* p, ConfigTag* tag) : SQLProvider(p, \"SQL/\" + tag->getString(\"id\")),\n\t\tconfig(tag), connection(NULL)\n\t{\n\t}\n\n\t~SQLConnection()\n\t{\n\t\tClose();\n\t}\n\n\t// This method connects to the database using the credentials supplied to the constructor, and returns\n\t// true upon success.\n\tbool Connect()\n\t{\n\t\tunsigned int timeout = 1;\n\t\tconnection = mysql_init(connection);\n\t\tmysql_options(connection,MYSQL_OPT_CONNECT_TIMEOUT,(char*)&timeout);\n\t\tstd::string host = config->getString(\"host\");\n\t\tstd::string user = config->getString(\"user\");\n\t\tstd::string pass = config->getString(\"pass\");\n\t\tstd::string dbname = config->getString(\"name\");\n\t\tint port = config->getInt(\"port\");\n\t\tbool rv = mysql_real_connect(connection, host.c_str(), user.c_str(), pass.c_str(), dbname.c_str(), port, NULL, 0);\n\t\tif (!rv)\n\t\t\treturn rv;\n\t\tstd::string initquery;\n\t\tif (config->readString(\"initialquery\", initquery))\n\t\t{\n\t\t\tmysql_query(connection,initquery.c_str());\n\t\t}\n\t\treturn true;\n\t}\n\n\tModuleSQL* Parent()\n\t{\n\t\treturn (ModuleSQL*)(Module*)creator;\n\t}\n\n\tMySQLresult* DoBlockingQuery(const std::string& query)\n\t{\n\n\t\t/* Parse the command string and dispatch it to mysql */\n\t\tif (CheckConnection() && !mysql_real_query(connection, query.data(), query.length()))\n\t\t{\n\t\t\t/* Successfull query */\n\t\t\tMYSQL_RES* res = mysql_use_result(connection);\n\t\t\tunsigned long rows = mysql_affected_rows(connection);\n\t\t\treturn new MySQLresult(res, rows);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* XXX: See /usr/include/mysql/mysqld_error.h for a list of\n\t\t\t * possible error numbers and error messages */\n\t\t\tSQLerror e(SQL_QREPLY_FAIL, ConvToStr(mysql_errno(connection)) + \": \" + mysql_error(connection));\n\t\t\treturn new MySQLresult(e);\n\t\t}\n\t}\n\n\tbool CheckConnection()\n\t{\n\t\tif (!connection || mysql_ping(connection) != 0)\n\t\t\treturn Connect();\n\t\treturn true;\n\t}\n\n\tstd::string GetError()\n\t{\n\t\treturn mysql_error(connection);\n\t}\n\n\tvoid Close()\n\t{\n\t\tmysql_close(connection);\n\t}\n\n\tvoid submit(SQLQuery* q, const std::string& qs)\n\t{\n\t\tParent()->Dispatcher->LockQueue();\n\t\tParent()->qq.push_back(QQueueItem(q, qs, this));\n\t\tParent()->Dispatcher->UnlockQueueWakeup();\n\t}\n\n\tvoid submit(SQLQuery* call, const std::string& q, const ParamL& p)\n\t{\n\t\tstd::string res;\n\t\tunsigned int param = 0;\n\t\tfor(std::string::size_type i = 0; i < q.length(); i++)\n\t\t{\n\t\t\tif (q[i] != '?')\n\t\t\t\tres.push_back(q[i]);\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (param < p.size())\n\t\t\t\t{\n\t\t\t\t\tstd::string parm = p[param++];\n\t\t\t\t\t// In the worst case, each character may need to be encoded as using two bytes,\n\t\t\t\t\t// and one byte is the terminating null\n\t\t\t\t\tstd::vector<char> buffer(parm.length() * 2 + 1);\n\n\t\t\t\t\t// The return value of mysql_escape_string() is the length of the encoded string,\n\t\t\t\t\t// not including the terminating null\n\t\t\t\t\tunsigned long escapedsize = mysql_escape_string(&buffer[0], parm.c_str(), parm.length());\n//\t\t\t\t\tmysql_real_escape_string(connection, queryend, paramscopy[paramnum].c_str(), paramscopy[paramnum].length());\n\t\t\t\t\tres.append(&buffer[0], escapedsize);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsubmit(call, res);\n\t}\n\n\tvoid submit(SQLQuery* call, const std::string& q, const ParamM& p)\n\t{\n\t\tstd::string res;\n\t\tfor(std::string::size_type i = 0; i < q.length(); i++)\n\t\t{\n\t\t\tif (q[i] != '$')\n\t\t\t\tres.push_back(q[i]);\n\t\t\telse\n\t\t\t{\n\t\t\t\tstd::string field;\n\t\t\t\ti++;\n\t\t\t\twhile (i < q.length() && isalnum(q[i]))\n\t\t\t\t\tfield.push_back(q[i++]);\n\t\t\t\ti--;\n\n\t\t\t\tParamM::const_iterator it = p.find(field);\n\t\t\t\tif (it != p.end())\n\t\t\t\t{\n\t\t\t\t\tstd::string parm = it->second;\n\t\t\t\t\t// NOTE: See above\n\t\t\t\t\tstd::vector<char> buffer(parm.length() * 2 + 1);\n\t\t\t\t\tunsigned long escapedsize = mysql_escape_string(&buffer[0], parm.c_str(), parm.length());\n\t\t\t\t\tres.append(&buffer[0], escapedsize);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsubmit(call, res);\n\t}\n};\n\nModuleSQL::ModuleSQL()\n{\n\tDispatcher = NULL;\n}\n\nvoid ModuleSQL::init()\n{\n\tDispatcher = new DispatcherThread(this);\n\tServerInstance->Threads->Start(Dispatcher);\n\n\tImplementation eventlist[] = { I_OnRehash, I_OnUnloadModule };\n\tServerInstance->Modules->Attach(eventlist, this, sizeof(eventlist)/sizeof(Implementation));\n\n\tOnRehash(NULL);\n}\n\nModuleSQL::~ModuleSQL()\n{\n\tif (Dispatcher)\n\t{\n\t\tDispatcher->join();\n\t\tDispatcher->OnNotify();\n\t\tdelete Dispatcher;\n\t}\n\tfor(ConnMap::iterator i = connections.begin(); i != connections.end(); i++)\n\t{\n\t\tdelete i->second;\n\t}\n}\n\nvoid ModuleSQL::OnRehash(User* user)\n{\n\tConnMap conns;\n\tConfigTagList tags = ServerInstance->Config->ConfTags(\"database\");\n\tfor(ConfigIter i = tags.first; i != tags.second; i++)\n\t{\n\t\tif (i->second->getString(\"module\", \"mysql\") != \"mysql\")\n\t\t\tcontinue;\n\t\tstd::string id = i->second->getString(\"id\");\n\t\tConnMap::iterator curr = connections.find(id);\n\t\tif (curr == connections.end())\n\t\t{\n\t\t\tSQLConnection* conn = new SQLConnection(this, i->second);\n\t\t\tconns.insert(std::make_pair(id, conn));\n\t\t\tServerInstance->Modules->AddService(*conn);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconns.insert(*curr);\n\t\t\tconnections.erase(curr);\n\t\t}\n\t}\n\n\t// now clean up the deleted databases\n\tDispatcher->LockQueue();\n\tSQLerror err(SQL_BAD_DBID);\n\tfor(ConnMap::iterator i = connections.begin(); i != connections.end(); i++)\n\t{\n\t\tServerInstance->Modules->DelService(*i->second);\n\t\t// it might be running a query on this database. Wait for that to complete\n\t\ti->second->lock.Lock();\n\t\ti->second->lock.Unlock();\n\t\t// now remove all active queries to this DB\n\t\tfor (size_t j = qq.size(); j > 0; j--)\n\t\t{\n\t\t\tsize_t k = j - 1;\n\t\t\tif (qq[k].c == i->second)\n\t\t\t{\n\t\t\t\tqq[k].q->OnError(err);\n\t\t\t\tdelete qq[k].q;\n\t\t\t\tqq.erase(qq.begin() + k);\n\t\t\t}\n\t\t}\n\t\t// finally, nuke the connection\n\t\tdelete i->second;\n\t}\n\tDispatcher->UnlockQueue();\n\tconnections.swap(conns);\n}\n\nvoid ModuleSQL::OnUnloadModule(Module* mod)\n{\n\tSQLerror err(SQL_BAD_DBID);\n\tDispatcher->LockQueue();\n\tunsigned int i = qq.size();\n\twhile (i > 0)\n\t{\n\t\ti--;\n\t\tif (qq[i].q->creator == mod)\n\t\t{\n\t\t\tif (i == 0)\n\t\t\t{\n\t\t\t\t// need to wait until the query is done\n\t\t\t\t// (the result will be discarded)\n\t\t\t\tqq[i].c->lock.Lock();\n\t\t\t\tqq[i].c->lock.Unlock();\n\t\t\t}\n\t\t\tqq[i].q->OnError(err);\n\t\t\tdelete qq[i].q;\n\t\t\tqq.erase(qq.begin() + i);\n\t\t}\n\t}\n\tDispatcher->UnlockQueue();\n\t// clean up any result queue entries\n\tDispatcher->OnNotify();\n}\n\nVersion ModuleSQL::GetVersion()\n{\n\treturn Version(\"MySQL support\", VF_VENDOR);\n}\n\nvoid DispatcherThread::Run()\n{\n\tthis->LockQueue();\n\twhile (!this->GetExitFlag())\n\t{\n\t\tif (!Parent->qq.empty())\n\t\t{\n\t\t\tQQueueItem i = Parent->qq.front();\n\t\t\ti.c->lock.Lock();\n\t\t\tthis->UnlockQueue();\n\t\t\tMySQLresult* res = i.c->DoBlockingQuery(i.query);\n\t\t\ti.c->lock.Unlock();\n\n\t\t\t/*\n\t\t\t * At this point, the main thread could be working on:\n\t\t\t *  Rehash - delete i.c out from under us. We don't care about that.\n\t\t\t *  UnloadModule - delete i.q and the qq item. Need to avoid reporting results.\n\t\t\t */\n\n\t\t\tthis->LockQueue();\n\t\t\tif (!Parent->qq.empty() && Parent->qq.front().q == i.q)\n\t\t\t{\n\t\t\t\tParent->qq.pop_front();\n\t\t\t\tParent->rq.push_back(RQueueItem(i.q, res));\n\t\t\t\tNotifyParent();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// UnloadModule ate the query\n\t\t\t\tdelete res;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* We know the queue is empty, we can safely hang this thread until\n\t\t\t * something happens\n\t\t\t */\n\t\t\tthis->WaitForQueue();\n\t\t}\n\t}\n\tthis->UnlockQueue();\n}\n\nvoid DispatcherThread::OnNotify()\n{\n\t// this could unlock during the dispatch, but OnResult isn't expected to take that long\n\tthis->LockQueue();\n\tfor(ResultQueue::iterator i = Parent->rq.begin(); i != Parent->rq.end(); i++)\n\t{\n\t\tMySQLresult* res = i->r;\n\t\tif (res->err.id == SQL_NO_ERROR)\n\t\t\ti->q->OnResult(*res);\n\t\telse\n\t\t\ti->q->OnError(res->err);\n\t\tdelete i->q;\n\t\tdelete i->r;\n\t}\n\tParent->rq.clear();\n\tthis->UnlockQueue();\n}\n\nMODULE_INIT(ModuleSQL)\n"], "fixing_code": ["/*\n * InspIRCd -- Internet Relay Chat Daemon\n *\n *   Copyright (C) 2009-2010 Daniel De Graaf <danieldg@inspircd.org>\n *   Copyright (C) 2006-2007, 2009 Dennis Friis <peavey@inspircd.org>\n *   Copyright (C) 2006-2009 Craig Edwards <craigedwards@brainbox.cc>\n *   Copyright (C) 2008 Robin Burchell <robin+git@viroteck.net>\n *\n * This file is part of InspIRCd.  InspIRCd is free software: you can\n * redistribute it and/or modify it under the terms of the GNU General Public\n * License as published by the Free Software Foundation, version 2.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n\n/* Stop mysql wanting to use long long */\n#define NO_CLIENT_LONG_LONG\n\n#include \"inspircd.h\"\n#include <mysql.h>\n#include \"sql.h\"\n\n#ifdef _WIN32\n# pragma comment(lib, \"libmysql.lib\")\n#endif\n\n/* VERSION 3 API: With nonblocking (threaded) requests */\n\n/* $ModDesc: SQL Service Provider module for all other m_sql* modules */\n/* $CompileFlags: exec(\"mysql_config --include\") */\n/* $LinkerFlags: exec(\"mysql_config --libs_r\") rpath(\"mysql_config --libs_r\") */\n\n/* THE NONBLOCKING MYSQL API!\n *\n * MySQL provides no nonblocking (asyncronous) API of its own, and its developers recommend\n * that instead, you should thread your program. This is what i've done here to allow for\n * asyncronous SQL requests via mysql. The way this works is as follows:\n *\n * The module spawns a thread via class Thread, and performs its mysql queries in this thread,\n * using a queue with priorities. There is a mutex on either end which prevents two threads\n * adjusting the queue at the same time, and crashing the ircd. Every 50 milliseconds, the\n * worker thread wakes up, and checks if there is a request at the head of its queue.\n * If there is, it processes this request, blocking the worker thread but leaving the ircd\n * thread to go about its business as usual. During this period, the ircd thread is able\n * to insert futher pending requests into the queue.\n *\n * Once the processing of a request is complete, it is removed from the incoming queue to\n * an outgoing queue, and initialized as a 'response'. The worker thread then signals the\n * ircd thread (via a loopback socket) of the fact a result is available, by sending the\n * connection ID through the connection.\n *\n * The ircd thread then mutexes the queue once more, reads the outbound response off the head\n * of the queue, and sends it on its way to the original calling module.\n *\n * XXX: You might be asking \"why doesnt he just send the response from within the worker thread?\"\n * The answer to this is simple. The majority of InspIRCd, and in fact most ircd's are not\n * threadsafe. This module is designed to be threadsafe and is careful with its use of threads,\n * however, if we were to call a module's OnRequest even from within a thread which was not the\n * one the module was originally instantiated upon, there is a chance of all hell breaking loose\n * if a module is ever put in a re-enterant state (stack corruption could occur, crashes, data\n * corruption, and worse, so DONT think about it until the day comes when InspIRCd is 100%\n * gauranteed threadsafe!)\n */\n\nclass SQLConnection;\nclass MySQLresult;\nclass DispatcherThread;\n\nstruct QQueueItem\n{\n\tSQLQuery* q;\n\tstd::string query;\n\tSQLConnection* c;\n\tQQueueItem(SQLQuery* Q, const std::string& S, SQLConnection* C) : q(Q), query(S), c(C) {}\n};\n\nstruct RQueueItem\n{\n\tSQLQuery* q;\n\tMySQLresult* r;\n\tRQueueItem(SQLQuery* Q, MySQLresult* R) : q(Q), r(R) {}\n};\n\ntypedef std::map<std::string, SQLConnection*> ConnMap;\ntypedef std::deque<QQueueItem> QueryQueue;\ntypedef std::deque<RQueueItem> ResultQueue;\n\n/** MySQL module\n *  */\nclass ModuleSQL : public Module\n{\n public:\n\tDispatcherThread* Dispatcher;\n\tQueryQueue qq;       // MUST HOLD MUTEX\n\tResultQueue rq;      // MUST HOLD MUTEX\n\tConnMap connections; // main thread only\n\n\tModuleSQL();\n\tvoid init();\n\t~ModuleSQL();\n\tvoid OnRehash(User* user);\n\tvoid OnUnloadModule(Module* mod);\n\tVersion GetVersion();\n};\n\nclass DispatcherThread : public SocketThread\n{\n private:\n\tModuleSQL* const Parent;\n public:\n\tDispatcherThread(ModuleSQL* CreatorModule) : Parent(CreatorModule) { }\n\t~DispatcherThread() { }\n\tvirtual void Run();\n\tvirtual void OnNotify();\n};\n\n#if !defined(MYSQL_VERSION_ID) || MYSQL_VERSION_ID<32224\n#define mysql_field_count mysql_num_fields\n#endif\n\n/** Represents a mysql result set\n */\nclass MySQLresult : public SQLResult\n{\n public:\n\tSQLerror err;\n\tint currentrow;\n\tint rows;\n\tstd::vector<std::string> colnames;\n\tstd::vector<SQLEntries> fieldlists;\n\n\tMySQLresult(MYSQL_RES* res, int affected_rows) : err(SQL_NO_ERROR), currentrow(0), rows(0)\n\t{\n\t\tif (affected_rows >= 1)\n\t\t{\n\t\t\trows = affected_rows;\n\t\t\tfieldlists.resize(rows);\n\t\t}\n\t\tunsigned int field_count = 0;\n\t\tif (res)\n\t\t{\n\t\t\tMYSQL_ROW row;\n\t\t\tint n = 0;\n\t\t\twhile ((row = mysql_fetch_row(res)))\n\t\t\t{\n\t\t\t\tif (fieldlists.size() < (unsigned int)rows+1)\n\t\t\t\t{\n\t\t\t\t\tfieldlists.resize(fieldlists.size()+1);\n\t\t\t\t}\n\t\t\t\tfield_count = 0;\n\t\t\t\tMYSQL_FIELD *fields = mysql_fetch_fields(res);\n\t\t\t\tif(mysql_num_fields(res) == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tif (fields && mysql_num_fields(res))\n\t\t\t\t{\n\t\t\t\t\tcolnames.clear();\n\t\t\t\t\twhile (field_count < mysql_num_fields(res))\n\t\t\t\t\t{\n\t\t\t\t\t\tstd::string a = (fields[field_count].name ? fields[field_count].name : \"\");\n\t\t\t\t\t\tif (row[field_count])\n\t\t\t\t\t\t\tfieldlists[n].push_back(SQLEntry(row[field_count]));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tfieldlists[n].push_back(SQLEntry());\n\t\t\t\t\t\tcolnames.push_back(a);\n\t\t\t\t\t\tfield_count++;\n\t\t\t\t\t}\n\t\t\t\t\tn++;\n\t\t\t\t}\n\t\t\t\trows++;\n\t\t\t}\n\t\t\tmysql_free_result(res);\n\t\t}\n\t}\n\n\tMySQLresult(SQLerror& e) : err(e)\n\t{\n\n\t}\n\n\t~MySQLresult()\n\t{\n\t}\n\n\tvirtual int Rows()\n\t{\n\t\treturn rows;\n\t}\n\n\tvirtual void GetCols(std::vector<std::string>& result)\n\t{\n\t\tresult.assign(colnames.begin(), colnames.end());\n\t}\n\n\tvirtual SQLEntry GetValue(int row, int column)\n\t{\n\t\tif ((row >= 0) && (row < rows) && (column >= 0) && (column < (int)fieldlists[row].size()))\n\t\t{\n\t\t\treturn fieldlists[row][column];\n\t\t}\n\t\treturn SQLEntry();\n\t}\n\n\tvirtual bool GetRow(SQLEntries& result)\n\t{\n\t\tif (currentrow < rows)\n\t\t{\n\t\t\tresult.assign(fieldlists[currentrow].begin(), fieldlists[currentrow].end());\n\t\t\tcurrentrow++;\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult.clear();\n\t\t\treturn false;\n\t\t}\n\t}\n};\n\n/** Represents a connection to a mysql database\n */\nclass SQLConnection : public SQLProvider\n{\n public:\n\treference<ConfigTag> config;\n\tMYSQL *connection;\n\tMutex lock;\n\n\t// This constructor creates an SQLConnection object with the given credentials, but does not connect yet.\n\tSQLConnection(Module* p, ConfigTag* tag) : SQLProvider(p, \"SQL/\" + tag->getString(\"id\")),\n\t\tconfig(tag), connection(NULL)\n\t{\n\t}\n\n\t~SQLConnection()\n\t{\n\t\tClose();\n\t}\n\n\t// This method connects to the database using the credentials supplied to the constructor, and returns\n\t// true upon success.\n\tbool Connect()\n\t{\n\t\tunsigned int timeout = 1;\n\t\tconnection = mysql_init(connection);\n\t\tmysql_options(connection,MYSQL_OPT_CONNECT_TIMEOUT,(char*)&timeout);\n\t\tstd::string host = config->getString(\"host\");\n\t\tstd::string user = config->getString(\"user\");\n\t\tstd::string pass = config->getString(\"pass\");\n\t\tstd::string dbname = config->getString(\"name\");\n\t\tint port = config->getInt(\"port\");\n\t\tbool rv = mysql_real_connect(connection, host.c_str(), user.c_str(), pass.c_str(), dbname.c_str(), port, NULL, 0);\n\t\tif (!rv)\n\t\t\treturn rv;\n\t\tstd::string initquery;\n\t\tif (config->readString(\"initialquery\", initquery))\n\t\t{\n\t\t\tmysql_query(connection,initquery.c_str());\n\t\t}\n\t\treturn true;\n\t}\n\n\tModuleSQL* Parent()\n\t{\n\t\treturn (ModuleSQL*)(Module*)creator;\n\t}\n\n\tMySQLresult* DoBlockingQuery(const std::string& query)\n\t{\n\n\t\t/* Parse the command string and dispatch it to mysql */\n\t\tif (CheckConnection() && !mysql_real_query(connection, query.data(), query.length()))\n\t\t{\n\t\t\t/* Successfull query */\n\t\t\tMYSQL_RES* res = mysql_use_result(connection);\n\t\t\tunsigned long rows = mysql_affected_rows(connection);\n\t\t\treturn new MySQLresult(res, rows);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* XXX: See /usr/include/mysql/mysqld_error.h for a list of\n\t\t\t * possible error numbers and error messages */\n\t\t\tSQLerror e(SQL_QREPLY_FAIL, ConvToStr(mysql_errno(connection)) + \": \" + mysql_error(connection));\n\t\t\treturn new MySQLresult(e);\n\t\t}\n\t}\n\n\tbool CheckConnection()\n\t{\n\t\tif (!connection || mysql_ping(connection) != 0)\n\t\t\treturn Connect();\n\t\treturn true;\n\t}\n\n\tstd::string GetError()\n\t{\n\t\treturn mysql_error(connection);\n\t}\n\n\tvoid Close()\n\t{\n\t\tmysql_close(connection);\n\t}\n\n\tvoid submit(SQLQuery* q, const std::string& qs)\n\t{\n\t\tParent()->Dispatcher->LockQueue();\n\t\tParent()->qq.push_back(QQueueItem(q, qs, this));\n\t\tParent()->Dispatcher->UnlockQueueWakeup();\n\t}\n\n\tvoid submit(SQLQuery* call, const std::string& q, const ParamL& p)\n\t{\n\t\tstd::string res;\n\t\tunsigned int param = 0;\n\t\tfor(std::string::size_type i = 0; i < q.length(); i++)\n\t\t{\n\t\t\tif (q[i] != '?')\n\t\t\t\tres.push_back(q[i]);\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (param < p.size())\n\t\t\t\t{\n\t\t\t\t\tstd::string parm = p[param++];\n\t\t\t\t\t// In the worst case, each character may need to be encoded as using two bytes,\n\t\t\t\t\t// and one byte is the terminating null\n\t\t\t\t\tstd::vector<char> buffer(parm.length() * 2 + 1);\n\n\t\t\t\t\t// The return value of mysql_escape_string() is the length of the encoded string,\n\t\t\t\t\t// not including the terminating null\n\t\t\t\t\tunsigned long escapedsize = mysql_escape_string(&buffer[0], parm.c_str(), parm.length());\n//\t\t\t\t\tmysql_real_escape_string(connection, queryend, paramscopy[paramnum].c_str(), paramscopy[paramnum].length());\n\t\t\t\t\tres.append(&buffer[0], escapedsize);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsubmit(call, res);\n\t}\n\n\tvoid submit(SQLQuery* call, const std::string& q, const ParamM& p)\n\t{\n\t\tstd::string res;\n\t\tfor(std::string::size_type i = 0; i < q.length(); i++)\n\t\t{\n\t\t\tif (q[i] != '$')\n\t\t\t\tres.push_back(q[i]);\n\t\t\telse\n\t\t\t{\n\t\t\t\tstd::string field;\n\t\t\t\ti++;\n\t\t\t\twhile (i < q.length() && isalnum(q[i]))\n\t\t\t\t\tfield.push_back(q[i++]);\n\t\t\t\ti--;\n\n\t\t\t\tParamM::const_iterator it = p.find(field);\n\t\t\t\tif (it != p.end())\n\t\t\t\t{\n\t\t\t\t\tstd::string parm = it->second;\n\t\t\t\t\t// NOTE: See above\n\t\t\t\t\tstd::vector<char> buffer(parm.length() * 2 + 1);\n\t\t\t\t\tunsigned long escapedsize = mysql_escape_string(&buffer[0], parm.c_str(), parm.length());\n\t\t\t\t\tres.append(&buffer[0], escapedsize);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsubmit(call, res);\n\t}\n};\n\nModuleSQL::ModuleSQL()\n{\n\tDispatcher = NULL;\n}\n\nvoid ModuleSQL::init()\n{\n\tif (mysql_library_init(0, NULL, NULL))\n\t\tthrow ModuleException(\"Unable to initialise the MySQL library!\");\n\n\tDispatcher = new DispatcherThread(this);\n\tServerInstance->Threads->Start(Dispatcher);\n\n\tImplementation eventlist[] = { I_OnRehash, I_OnUnloadModule };\n\tServerInstance->Modules->Attach(eventlist, this, sizeof(eventlist)/sizeof(Implementation));\n\n\tOnRehash(NULL);\n}\n\nModuleSQL::~ModuleSQL()\n{\n\tif (Dispatcher)\n\t{\n\t\tDispatcher->join();\n\t\tDispatcher->OnNotify();\n\t\tdelete Dispatcher;\n\t}\n\n\tfor(ConnMap::iterator i = connections.begin(); i != connections.end(); i++)\n\t{\n\t\tdelete i->second;\n\t}\n\n\tmysql_library_end();\n}\n\nvoid ModuleSQL::OnRehash(User* user)\n{\n\tConnMap conns;\n\tConfigTagList tags = ServerInstance->Config->ConfTags(\"database\");\n\tfor(ConfigIter i = tags.first; i != tags.second; i++)\n\t{\n\t\tif (i->second->getString(\"module\", \"mysql\") != \"mysql\")\n\t\t\tcontinue;\n\t\tstd::string id = i->second->getString(\"id\");\n\t\tConnMap::iterator curr = connections.find(id);\n\t\tif (curr == connections.end())\n\t\t{\n\t\t\tSQLConnection* conn = new SQLConnection(this, i->second);\n\t\t\tconns.insert(std::make_pair(id, conn));\n\t\t\tServerInstance->Modules->AddService(*conn);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconns.insert(*curr);\n\t\t\tconnections.erase(curr);\n\t\t}\n\t}\n\n\t// now clean up the deleted databases\n\tDispatcher->LockQueue();\n\tSQLerror err(SQL_BAD_DBID);\n\tfor(ConnMap::iterator i = connections.begin(); i != connections.end(); i++)\n\t{\n\t\tServerInstance->Modules->DelService(*i->second);\n\t\t// it might be running a query on this database. Wait for that to complete\n\t\ti->second->lock.Lock();\n\t\ti->second->lock.Unlock();\n\t\t// now remove all active queries to this DB\n\t\tfor (size_t j = qq.size(); j > 0; j--)\n\t\t{\n\t\t\tsize_t k = j - 1;\n\t\t\tif (qq[k].c == i->second)\n\t\t\t{\n\t\t\t\tqq[k].q->OnError(err);\n\t\t\t\tdelete qq[k].q;\n\t\t\t\tqq.erase(qq.begin() + k);\n\t\t\t}\n\t\t}\n\t\t// finally, nuke the connection\n\t\tdelete i->second;\n\t}\n\tDispatcher->UnlockQueue();\n\tconnections.swap(conns);\n}\n\nvoid ModuleSQL::OnUnloadModule(Module* mod)\n{\n\tSQLerror err(SQL_BAD_DBID);\n\tDispatcher->LockQueue();\n\tunsigned int i = qq.size();\n\twhile (i > 0)\n\t{\n\t\ti--;\n\t\tif (qq[i].q->creator == mod)\n\t\t{\n\t\t\tif (i == 0)\n\t\t\t{\n\t\t\t\t// need to wait until the query is done\n\t\t\t\t// (the result will be discarded)\n\t\t\t\tqq[i].c->lock.Lock();\n\t\t\t\tqq[i].c->lock.Unlock();\n\t\t\t}\n\t\t\tqq[i].q->OnError(err);\n\t\t\tdelete qq[i].q;\n\t\t\tqq.erase(qq.begin() + i);\n\t\t}\n\t}\n\tDispatcher->UnlockQueue();\n\t// clean up any result queue entries\n\tDispatcher->OnNotify();\n}\n\nVersion ModuleSQL::GetVersion()\n{\n\treturn Version(\"MySQL support\", VF_VENDOR);\n}\n\nvoid DispatcherThread::Run()\n{\n\tthis->LockQueue();\n\twhile (!this->GetExitFlag())\n\t{\n\t\tif (!Parent->qq.empty())\n\t\t{\n\t\t\tQQueueItem i = Parent->qq.front();\n\t\t\ti.c->lock.Lock();\n\t\t\tthis->UnlockQueue();\n\t\t\tMySQLresult* res = i.c->DoBlockingQuery(i.query);\n\t\t\ti.c->lock.Unlock();\n\n\t\t\t/*\n\t\t\t * At this point, the main thread could be working on:\n\t\t\t *  Rehash - delete i.c out from under us. We don't care about that.\n\t\t\t *  UnloadModule - delete i.q and the qq item. Need to avoid reporting results.\n\t\t\t */\n\n\t\t\tthis->LockQueue();\n\t\t\tif (!Parent->qq.empty() && Parent->qq.front().q == i.q)\n\t\t\t{\n\t\t\t\tParent->qq.pop_front();\n\t\t\t\tParent->rq.push_back(RQueueItem(i.q, res));\n\t\t\t\tNotifyParent();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// UnloadModule ate the query\n\t\t\t\tdelete res;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* We know the queue is empty, we can safely hang this thread until\n\t\t\t * something happens\n\t\t\t */\n\t\t\tthis->WaitForQueue();\n\t\t}\n\t}\n\tthis->UnlockQueue();\n}\n\nvoid DispatcherThread::OnNotify()\n{\n\t// this could unlock during the dispatch, but OnResult isn't expected to take that long\n\tthis->LockQueue();\n\tfor(ResultQueue::iterator i = Parent->rq.begin(); i != Parent->rq.end(); i++)\n\t{\n\t\tMySQLresult* res = i->r;\n\t\tif (res->err.id == SQL_NO_ERROR)\n\t\t\ti->q->OnResult(*res);\n\t\telse\n\t\t\ti->q->OnError(res->err);\n\t\tdelete i->q;\n\t\tdelete i->r;\n\t}\n\tParent->rq.clear();\n\tthis->UnlockQueue();\n}\n\nMODULE_INIT(ModuleSQL)\n"], "filenames": ["src/modules/extra/m_mysql.cpp"], "buggy_code_start_loc": [382], "buggy_code_end_loc": [403], "fixing_code_start_loc": [383], "fixing_code_end_loc": [410], "type": "CWE-476", "message": "An issue was discovered in InspIRCd 2 before 2.0.28 and 3 before 3.3.0. The mysql module contains a NULL pointer dereference when built against mariadb-connector-c 3.0.5 or newer. When combined with the sqlauth or sqloper modules, this vulnerability can be used for remote crashing of an InspIRCd server by any user able to connect to a server.", "other": {"cve": {"id": "CVE-2019-20917", "sourceIdentifier": "cve@mitre.org", "published": "2020-09-11T05:15:12.480", "lastModified": "2023-01-27T18:22:31.907", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in InspIRCd 2 before 2.0.28 and 3 before 3.3.0. The mysql module contains a NULL pointer dereference when built against mariadb-connector-c 3.0.5 or newer. When combined with the sqlauth or sqloper modules, this vulnerability can be used for remote crashing of an InspIRCd server by any user able to connect to a server."}, {"lang": "es", "value": "Se detect\u00f3 un problema en InspIRCd versiones 2 anteriores a 2.0.28 y versiones 3 anteriores a 3.3.0.&#xa0;El m\u00f3dulo mysql contiene una desreferencia del puntero NULL cuando se construye contra el mariadb-connector-c versi\u00f3n 3.0.5 o m\u00e1s reciente.&#xa0;Cuando es combinado con los m\u00f3dulos sqlauth o sqloper, esta vulnerabilidad puede ser usada  para el bloqueo remoto de un servidor de InspIRCd por cualquier usuario que pueda conectarse a un servidor"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:inspircd:inspircd:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.0", "versionEndExcluding": "2.0.28", "matchCriteriaId": "A3BC5E23-048D-422B-95B9-8EE839A4AA93"}, {"vulnerable": true, "criteria": "cpe:2.3:a:inspircd:inspircd:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0", "versionEndExcluding": "3.3.0", "matchCriteriaId": "F581CF4A-0F9C-42C7-A233-D78C5DF4FCC0"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://docs.inspircd.org/security/2019-02/", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://github.com/inspircd/inspircd/commit/2cc35d8625b7ea5cbd1d1ebb116aff86c5280162", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/inspircd/inspircd/commit/8745660fcdac7c1b80c94cfc0ff60928cd4dd4b7", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/09/msg00015.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2020/dsa-4764", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/inspircd/inspircd/commit/2cc35d8625b7ea5cbd1d1ebb116aff86c5280162"}}