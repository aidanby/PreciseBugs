{"buggy_code": ["from pathlib import Path\nimport sys\nimport os\n\nimport elasticsearch\nimport yaml\nfrom elasticsearch import Elasticsearch\nfrom flask import current_app, g\nfrom tinydb import TinyDB, Query, operations\n\nfrom archivy.config import BaseHooks, Config\n\n\ndef load_config(path=\"\"):\n    \"\"\"Loads `config.yml` file safely and deserializes it to a python dict.\"\"\"\n    path = path or current_app.config[\"INTERNAL_DIR\"]\n    with (Path(path) / \"config.yml\").open() as f:\n        return yaml.load(f.read(), Loader=yaml.SafeLoader)\n\n\ndef config_diff(curr_key, curr_val, parent_dict, defaults):\n    \"\"\"\n    This function diffs the user config with the defaults to only save what is actually different.\n\n    Returns 1 if the current element or its nested elements are different and have been preserved.\n    \"\"\"\n    if type(curr_val) is dict:\n        # the any call here diffs all nested children of the current dict and returns whether any have modifications\n        if not any(\n            [\n                config_diff(k, v, curr_val, defaults[curr_key])\n                for k, v in list(curr_val.items())\n            ]\n        ):\n            parent_dict.pop(curr_key)\n            return 0\n    else:\n        if defaults[curr_key] == curr_val:\n            parent_dict.pop(curr_key)\n            return 0\n    return 1\n\n\ndef write_config(config: dict):\n    \"\"\"\n    Writes a new config dict to a `config.yml` file that will override defaults.\n    Compares user config with defaults to only save changes.\n    \"\"\"\n    defaults = vars(Config())\n    for k, v in list(config.items()):\n        if k != \"SECRET_KEY\":\n            config_diff(k, v, config, defaults)\n    with (Path(current_app.config[\"INTERNAL_DIR\"]) / \"config.yml\").open(\"w\") as f:\n        yaml.dump(config, f)\n\n\ndef load_hooks():\n    try:\n        user_hooks = (Path(current_app.config[\"USER_DIR\"]) / \"hooks.py\").open()\n    except FileNotFoundError:\n        return BaseHooks()\n\n    user_locals = {}\n    exec(user_hooks.read(), globals(), user_locals)\n    user_hooks.close()\n    return user_locals.get(\"Hooks\", BaseHooks)()\n\n\ndef load_scraper():\n    try:\n        user_scraping = (Path(current_app.config[\"USER_DIR\"]) / \"scraping.py\").open()\n    except FileNotFoundError:\n        return {}\n    user_locals = {}\n    exec(user_scraping.read(), globals(), user_locals)\n    user_scraping.close()\n    return user_locals.get(\"PATTERNS\", {})\n\n\ndef get_db(force_reconnect=False):\n    \"\"\"\n    Returns the database object that you can use to\n    store data persistently\n    \"\"\"\n    if \"db\" not in g or force_reconnect:\n        g.db = TinyDB(str(Path(current_app.config[\"INTERNAL_DIR\"]) / \"db.json\"))\n\n    return g.db\n\n\ndef get_max_id():\n    \"\"\"Returns the current maximum id of dataobjs in the database.\"\"\"\n    db = get_db()\n    max_id = db.search(Query().name == \"max_id\")\n    if not max_id:\n        db.insert({\"name\": \"max_id\", \"val\": 0})\n        return 0\n    return max_id[0][\"val\"]\n\n\ndef set_max_id(val):\n    \"\"\"Sets a new max_id\"\"\"\n    db = get_db()\n    db.update(operations.set(\"val\", val), Query().name == \"max_id\")\n\n\ndef test_es_connection(es):\n    \"\"\"Tests health and presence of connection to elasticsearch.\"\"\"\n    try:\n        health = es.cluster.health()\n    except elasticsearch.exceptions.ConnectionError:\n        current_app.logger.error(\n            \"Elasticsearch does not seem to be running on \"\n            f\"{current_app.config['SEARCH_CONF']['url']}. Please start \"\n            \"it, for example with: sudo service elasticsearch restart\"\n        )\n        current_app.logger.error(\n            \"You can disable Elasticsearch by modifying the `enabled` variable \"\n            f\"in {str(Path(current_app.config['INTERNAL_DIR']) / 'config.yml')}\"\n        )\n        sys.exit(1)\n\n    if health[\"status\"] not in (\"yellow\", \"green\"):\n        current_app.logger.warning(\n            \"Elasticsearch reports that it is not working \"\n            \"properly. Search might not work. You can disable \"\n            \"Elasticsearch by setting ELASTICSEARCH_ENABLED to 0.\"\n        )\n\n\ndef get_elastic_client(error_if_invalid=True):\n    \"\"\"Returns the elasticsearch client you can use to search and insert / delete data\"\"\"\n    if (\n        not current_app.config[\"SEARCH_CONF\"][\"enabled\"]\n        or current_app.config[\"SEARCH_CONF\"][\"engine\"] != \"elasticsearch\"\n    ) and error_if_invalid:\n        return None\n\n    auth_setup = (\n        current_app.config[\"SEARCH_CONF\"][\"es_user\"]\n        and current_app.config[\"SEARCH_CONF\"][\"es_password\"]\n    )\n    if auth_setup:\n        es = Elasticsearch(\n            current_app.config[\"SEARCH_CONF\"][\"url\"],\n            http_auth=(\n                current_app.config[\"SEARCH_CONF\"][\"es_user\"],\n                current_app.config[\"SEARCH_CONF\"][\"es_password\"],\n            ),\n        )\n    else:\n        es = Elasticsearch(current_app.config[\"SEARCH_CONF\"][\"url\"])\n    if error_if_invalid:\n        test_es_connection(es)\n    else:\n        try:\n            es.cluster.health()\n        except elasticsearch.exceptions.ConnectionError:\n            return False\n    return es\n\n\ndef create_plugin_dir(name):\n    \"\"\"Creates a sample plugin directory\"\"\"\n    raw_name = name.replace(\"archivy_\", \"\").replace(\"archivy-\", \"\")\n    try:\n        os.makedirs(f\"{name}/{name}\")\n\n        # Creates requirements.txt.\n        with open(f\"{name}/requirements.txt\", \"w\") as fp:\n            fp.writelines([\"archivy\", \"\\nclick\"])\n\n        # Creates an empty readme file to be filled\n        with open(f\"{name}/README.md\", \"w+\") as fp:\n            fp.writelines(\n                [\n                    f\"# {name}\",\n                    \"\\n\\n## Install\",\n                    \"\\n\\nYou need to have `archivy` already installed.\",\n                    f\"\\n\\nRun `pip install archivy_{name}`\",\n                    \"\\n\\n## Usage\",\n                ]\n            )\n\n        # Creates a setup.py file\n        with open(f\"{name}/setup.py\", \"w\") as setup_f:\n            setup_f.writelines(\n                [\n                    \"from setuptools import setup, find_packages\",\n                    '\\n\\nwith open(\"README.md\", \"r\") as fh:',\n                    \"\\n\\tlong_description = fh.read()\",\n                    '\\n\\nwith open(\"requirements.txt\", encoding=\"utf-8\") as f:',\n                    '\\n\\tall_reqs = f.read().split(\"\\\\n\")',\n                    \"\\n\\tinstall_requires = [x.strip() for x in all_reqs]\",\n                    \"\\n\\n#Fill in the details below for distribution purposes\"\n                    f'\\nsetup(\\n\\tname=\"{name}\",',\n                    '\\n\\tversion=\"0.0.1\",',\n                    '\\n\\tauthor=\"\",',\n                    '\\n\\tauthor_email=\"\",',\n                    '\\n\\tdescription=\"\",',\n                    \"\\n\\tlong_description=long_description,\",\n                    '\\n\\tlong_description_content_type=\"text/markdown\",',\n                    '\\n\\tclassifiers=[\"Programming Language :: Python :: 3\"],'\n                    \"\\n\\tpackages=find_packages(),\",\n                    \"\\n\\tinstall_requires=install_requires,\",\n                    f'\\n\\tentry_points=\"\"\"\\n\\t\\t[archivy.plugins]'\n                    f'\\n\\t\\t{raw_name}={name}:{raw_name}\"\"\"\\n)',\n                ]\n            )\n\n        # Creating a basic __init__.py file where the main function of the plugin goes\n        with open(f\"{name}/{name}/__init__.py\", \"w\") as fp:\n            fp.writelines(\n                [\n                    \"import archivy\",\n                    \"\\nimport click\",\n                    \"\\n\\n# Fill in the functionality for the commands (see https://archivy.github.io/plugins/)\",\n                    \"\\n@click.group()\",\n                    f\"\\ndef {raw_name}():\",\n                    \"\\n\\tpass\",\n                    f\"\\n\\n@{raw_name}.command()\",\n                    \"\\ndef command1():\",\n                    \"\\n\\tpass\",\n                    f\"\\n\\n@{raw_name}.command()\",\n                    \"\\ndef command2():\",\n                    \"\\n\\tpass\",\n                ]\n            )\n\n        return True\n    except FileExistsError:\n        return False\n", "from pathlib import Path\nfrom os.path import sep\nfrom pkg_resources import require\nfrom shutil import which\n\nimport frontmatter\nfrom flask import (\n    render_template,\n    flash,\n    redirect,\n    request,\n    url_for,\n    send_file,\n    send_from_directory,\n)\nfrom flask_login import login_user, current_user, logout_user\nfrom tinydb import Query\nfrom werkzeug.security import check_password_hash, generate_password_hash\n\nfrom archivy.models import DataObj, User\nfrom archivy import data, app, forms, csrf\nfrom archivy.helpers import get_db, write_config\nfrom archivy.tags import get_all_tags\nfrom archivy.search import search, search_frontmatter_tags\nfrom archivy.config import Config\n\nimport re\n\n\n@app.context_processor\ndef pass_defaults():\n    dataobjs = data.get_items(load_content=False)\n    version = require(\"archivy\")[0].version\n    SEP = sep\n    # check windows parsing for js (https://github.com/Uzay-G/archivy/issues/115)\n    if SEP == \"\\\\\":\n        SEP += \"\\\\\"\n    return dict(dataobjs=dataobjs, SEP=SEP, version=version)\n\n\n@app.before_request\ndef check_perms():\n    allowed_path = (\n        request.path.startswith(\"/login\")\n        or request.path.startswith(\"/static\")\n        or request.path.startswith(\"/api/login\")\n    )\n    if not current_user.is_authenticated and not allowed_path:\n        return redirect(url_for(\"login\", next=request.path))\n    return\n\n\n@app.route(\"/\")\n@app.route(\"/index\")\ndef index():\n    path = request.args.get(\"path\", \"\").lstrip(\"/\")\n    try:\n        files = data.get_items(path=path)\n    except FileNotFoundError:\n        flash(\"Directory does not exist.\", \"error\")\n        return redirect(\"/\")\n\n    return render_template(\n        \"home.html\",\n        title=path or \"root\",\n        search_enabled=app.config[\"SEARCH_CONF\"][\"enabled\"],\n        dir=files,\n        current_path=path,\n        new_folder_form=forms.NewFolderForm(),\n        delete_form=forms.DeleteFolderForm(),\n        rename_form=forms.RenameDirectoryForm(),\n        view_only=0,\n        search_engine=app.config[\"SEARCH_CONF\"][\"engine\"],\n    )\n\n\n# TODO: refactor two following methods\n@app.route(\"/bookmarks/new\", methods=[\"GET\", \"POST\"])\ndef new_bookmark():\n    default_dir = app.config.get(\"DEFAULT_BOOKMARKS_DIR\", \"root directory\")\n    form = forms.NewBookmarkForm(path=default_dir)\n    form.path.choices = [(\"\", \"root directory\")] + [\n        (pathname, pathname) for pathname in data.get_dirs()\n    ]\n    if form.validate_on_submit():\n        path = form.path.data\n        tags = form.tags.data.split(\",\") if form.tags.data != \"\" else []\n        tags = [tag.strip() for tag in tags]\n        bookmark = DataObj(url=form.url.data, tags=tags, path=path, type=\"bookmark\")\n        bookmark.process_bookmark_url()\n        bookmark_id = bookmark.insert()\n        if bookmark_id:\n            flash(\"Bookmark Saved!\", \"success\")\n            return redirect(f\"/dataobj/{bookmark_id}\")\n        else:\n            flash(bookmark.error, \"error\")\n            return redirect(\"/bookmarks/new\")\n    # for bookmarklet\n    form.url.data = request.args.get(\"url\", \"\")\n    path = request.args.get(\"path\", default_dir).strip(\"/\")\n    # handle empty argument\n    form.path.data = path\n    return render_template(\"dataobjs/new.html\", title=\"New Bookmark\", form=form)\n\n\n@app.route(\"/notes/new\", methods=[\"GET\", \"POST\"])\ndef new_note():\n    form = forms.NewNoteForm()\n    default_dir = \"root directory\"\n    form.path.choices = [(\"\", default_dir)] + [\n        (pathname, pathname) for pathname in data.get_dirs()\n    ]\n    if form.validate_on_submit():\n        path = form.path.data\n        tags = form.tags.data.split(\",\") if form.tags.data != \"\" else []\n        tags = [tag.strip() for tag in tags]\n        note = DataObj(title=form.title.data, path=path, tags=tags, type=\"note\")\n        note_id = note.insert()\n        if note_id:\n            flash(\"Note Saved!\", \"success\")\n            return redirect(f\"/dataobj/{note_id}\")\n    path = request.args.get(\"path\", default_dir).strip(\"/\")\n    # handle empty argument\n    form.path.data = path\n    return render_template(\"/dataobjs/new.html\", title=\"New Note\", form=form)\n\n\n@app.route(\"/tags\")\ndef show_all_tags():\n    if not app.config[\"SEARCH_CONF\"][\"engine\"] == \"ripgrep\" and not which(\"rg\"):\n        flash(\"Ripgrep must be installed to view pages about embedded tags.\", \"error\")\n        return redirect(\"/\")\n    tags = sorted(get_all_tags(force=True))\n    return render_template(\"tags/all.html\", title=\"All Tags\", tags=tags)\n\n\n@app.route(\"/tags/<tag_name>\")\ndef show_tag(tag_name):\n    if not app.config[\"SEARCH_CONF\"][\"enabled\"] and not which(\"rg\"):\n        flash(\n            \"Search (for example ripgrep) must be installed to view pages about embedded tags.\",\n            \"error\",\n        )\n        return redirect(\"/\")\n\n    results = search(f\"#{tag_name}#\", strict=True)\n    res_ids = set(\n        [item[\"id\"] for item in results]\n    )  # avoid duplication of results between context-aware embedded tags and metadata ones\n    for res in search_frontmatter_tags(tag_name):\n        if res[\"id\"] not in res_ids:\n            results.append(res)\n\n    return render_template(\n        \"tags/show.html\",\n        title=f\"Tags - {tag_name}\",\n        tag_name=tag_name,\n        search_result=results,\n    )\n\n\n@app.route(\"/dataobj/<int:dataobj_id>\")\ndef show_dataobj(dataobj_id):\n    dataobj = data.get_item(dataobj_id)\n    get_title_id_pairs = lambda x: (x[\"title\"], x[\"id\"])\n    titles = list(\n        map(get_title_id_pairs, data.get_items(structured=False, load_content=False))\n    )\n\n    if not dataobj:\n        flash(\"Data could not be found!\", \"error\")\n        return redirect(\"/\")\n\n    if request.args.get(\"raw\") == \"1\":\n        return frontmatter.dumps(dataobj)\n\n    backlinks = []\n    if app.config[\"SEARCH_CONF\"][\"enabled\"]:\n        if app.config[\"SEARCH_CONF\"][\"engine\"] == \"ripgrep\":\n            query = f\"\\|{dataobj_id}]]\"\n        else:\n            query = f\"|{dataobj_id})]]\"\n        backlinks = search(query, strict=True)\n\n    # Form for moving data into another folder\n    move_form = forms.MoveItemForm()\n    move_form.path.choices = [(\"\", \"root directory\")] + [\n        (pathname, pathname) for pathname in data.get_dirs()\n    ]\n\n    post_title_form = forms.TitleForm()\n    post_title_form.title.data = dataobj[\"title\"]\n\n    # Get all tags\n    tag_list = get_all_tags()\n    # and the ones present in this dataobj\n    embedded_tags = set()\n    PATTERN = r\"(?:^|\\n| )#(?:[-_a-zA-Z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff0-9]+)#\"\n    for match in re.finditer(PATTERN, dataobj.content):\n        embedded_tags.add(match.group(0).replace(\"#\", \"\").lstrip())\n\n    return render_template(\n        \"dataobjs/show.html\",\n        title=dataobj[\"title\"],\n        dataobj=dataobj,\n        backlinks=backlinks,\n        current_path=dataobj[\"dir\"],\n        form=forms.DeleteDataForm(),\n        view_only=0,\n        search_enabled=app.config[\"SEARCH_CONF\"][\"enabled\"],\n        post_title_form=post_title_form,\n        move_form=move_form,\n        tag_list=tag_list,\n        embedded_tags=embedded_tags,\n        titles=titles,\n    )\n\n\n@app.route(\"/dataobj/move/<int:dataobj_id>\", methods=[\"POST\"])\ndef move_item(dataobj_id):\n    form = forms.MoveItemForm()\n    out_dir = form.path.data if form.path.data != \"\" else \"root directory\"\n    if form.path.data == None:\n        flash(\"No path specified.\")\n        return redirect(f\"/dataobj/{dataobj_id}\")\n    try:\n        if data.move_item(dataobj_id, form.path.data):\n            flash(f\"Data successfully moved to {out_dir}.\", \"success\")\n            return redirect(f\"/dataobj/{dataobj_id}\")\n        else:\n            flash(f\"Data could not be moved to {out_dir}.\", \"error\")\n            return redirect(f\"/dataobj/{dataobj_id}\")\n    except FileNotFoundError:\n        flash(\"Data not found.\", \"error\")\n        return redirect(\"/\")\n    except FileExistsError:\n        flash(\"Data already in target directory.\", \"error\")\n        return redirect(f\"/dataobj/{dataobj_id}\")\n\n\n@app.route(\"/dataobj/delete/<int:dataobj_id>\", methods=[\"POST\"])\ndef delete_data(dataobj_id):\n    try:\n        data.delete_item(dataobj_id)\n    except BaseException:\n        flash(\"Data could not be found!\", \"error\")\n        return redirect(\"/\")\n    flash(\"Data deleted!\", \"success\")\n    return redirect(\"/\")\n\n\n@app.route(\"/login\", methods=[\"GET\", \"POST\"])\ndef login():\n    form = forms.UserForm()\n    if form.validate_on_submit():\n        db = get_db()\n        user = db.search(\n            (Query().username == form.username.data) & (Query().type == \"user\")\n        )\n\n        if user and check_password_hash(user[0][\"hashed_password\"], form.password.data):\n            user = User.from_db(user[0])\n            login_user(user, remember=True)\n            flash(\"Login successful!\", \"success\")\n\n            next_url = request.args.get(\"next\")\n            return redirect(next_url or \"/\")\n\n        flash(\"Invalid credentials\", \"error\")\n        return redirect(\"/login\")\n    return render_template(\"users/login.html\", form=form, title=\"Login\")\n\n\n@app.route(\"/logout\", methods=[\"DELETE\", \"GET\"])\ndef logout():\n    logout_user()\n    flash(\"Logged out successfully\", \"success\")\n    return redirect(\"/\")\n\n\n@app.route(\"/user/edit\", methods=[\"GET\", \"POST\"])\ndef edit_user():\n    form = forms.UserForm()\n    if form.validate_on_submit():\n        db = get_db()\n        db.update(\n            {\n                \"username\": form.username.data,\n                \"hashed_password\": generate_password_hash(form.password.data),\n            },\n            doc_ids=[current_user.id],\n        )\n        flash(\"Information saved!\", \"success\")\n        return redirect(\"/\")\n    form.username.data = current_user.username\n    return render_template(\"users/edit.html\", form=form, title=\"Edit Profile\")\n\n\n@app.route(\"/folders/create\", methods=[\"POST\"])\ndef create_folder():\n    form = forms.NewFolderForm()\n    if form.validate_on_submit():\n        path = Path(form.parent_dir.data.strip(\"/\")) / form.new_dir.data\n        new_path = data.create_dir(str(path))\n        flash(\"Folder successfully created.\", \"success\")\n        return redirect(f\"/?path={new_path}\")\n    flash(\"Could not create folder.\", \"error\")\n    return redirect(request.referrer or \"/\")\n\n\n@app.route(\"/folders/delete\", methods=[\"POST\"])\ndef delete_folder():\n    form = forms.DeleteFolderForm()\n    if form.validate_on_submit():\n        if data.delete_dir(form.dir_name.data):\n            flash(\"Folder successfully deleted.\", \"success\")\n            return redirect(\"/\")\n        else:\n            flash(\"Folder not found.\", \"error\")\n            return redirect(request.referrer or \"/\", 404)\n    flash(\"Could not delete folder.\", \"error\")\n    return redirect(request.referrer or \"/\")\n\n\n@app.route(\"/folders/rename\", methods=[\"POST\"])\ndef rename_folder():\n    form = forms.RenameDirectoryForm()\n    if form.validate_on_submit():\n        try:\n            new_path = data.rename_folder(form.current_path.data, form.new_name.data)\n            if not new_path:\n                flash(\"Invalid input.\", \"error\")\n            else:\n                flash(\"Renamed successfully.\", \"success\")\n                return redirect(f\"/?path={new_path}\")\n        except FileNotFoundError:\n            flash(\"Directory not found.\", \"error\")\n        except FileExistsError:\n            flash(\"Target directory exists.\", \"error\")\n    return redirect(\"/\")\n\n\n@app.route(\"/bookmarklet\")\ndef bookmarklet():\n    return render_template(\"bookmarklet.html\", title=\"Bookmarklet\")\n\n\n@app.route(\"/images/<filename>\")\ndef serve_image(filename):\n    if filename and data.valid_image_filename(filename):\n        image_path = data.image_exists(filename)\n        if image_path:\n            return send_file(image_path)\n        else:\n            return \"Image not found\", 404\n    else:\n        return \"Invalid file request\", 413\n\n\n@app.route(\"/static/custom.css\")\ndef custom_css():\n    if not app.config[\"THEME_CONF\"].get(\"use_custom_css\", False):\n        return \"\"\n    return send_from_directory(\n        Path(app.config[\"USER_DIR\"]) / \"css\",\n        app.config[\"THEME_CONF\"][\"custom_css_file\"],\n    )\n\n\n@app.route(\"/config\", methods=[\"GET\", \"POST\"])\ndef config():\n    \"\"\"\n    Web View to edit and update configuration.\n    \"\"\"\n\n    def update_config_value(key, val, dictionary):\n        if key != \"SECRET_KEY\":\n            if type(val) is dict:\n                for k, v in val.items():\n                    update_config_value(k, v, dictionary[key])\n            else:\n                dictionary[key] = val\n\n    form = forms.config_form(app.config)\n    default = vars(Config())\n    if form.validate_on_submit():\n        changed_config = Config()\n        changed_config.override(form.data)\n        for k, v in vars(changed_config).items():\n            # propagate changes to configuration\n            update_config_value(k, v, app.config)\n        write_config(vars(changed_config))  # save to filesystem config\n        flash(\"Config successfully updated.\", \"success\")\n    elif request.method == \"POST\":\n        flash(\"Could not update config.\", \"error\")\n    return render_template(\n        \"config.html\", conf=form, default=default, title=\"Edit Config\"\n    )\n\n\n@csrf.exempt  # exempt from CSRF to be able to submit info directly from bookmarklet\n@app.route(\"/save_from_bookmarklet\", methods=[\"POST\"])\ndef save_raw_url():\n    \"\"\"\n    Used in the bookmarklet - Saves a URL by taking its raw HTML.\n\n    POST parameters:\n    - html\n    - url\n    \"\"\"\n    html = request.form.get(\"html\")\n    if not html:\n        return \"No HTML provided\", 400\n    bookmark = DataObj(url=request.form.get(\"url\"), type=\"bookmark\")\n    bookmark.process_bookmark_url(html)\n    if bookmark.insert():\n        return redirect(f\"/dataobj/{bookmark.id}\")\n    else:\n        return \"Could not save bookmark\", 500\n"], "fixing_code": ["from pathlib import Path\nimport sys\nimport os\n\nimport elasticsearch\nimport yaml\nfrom elasticsearch import Elasticsearch\nfrom flask import current_app, g, request\nfrom tinydb import TinyDB, Query, operations\nfrom urllib.parse import urlparse, urljoin\n\nfrom archivy.config import BaseHooks, Config\n\n\ndef load_config(path=\"\"):\n    \"\"\"Loads `config.yml` file safely and deserializes it to a python dict.\"\"\"\n    path = path or current_app.config[\"INTERNAL_DIR\"]\n    with (Path(path) / \"config.yml\").open() as f:\n        return yaml.load(f.read(), Loader=yaml.SafeLoader)\n\n\ndef config_diff(curr_key, curr_val, parent_dict, defaults):\n    \"\"\"\n    This function diffs the user config with the defaults to only save what is actually different.\n\n    Returns 1 if the current element or its nested elements are different and have been preserved.\n    \"\"\"\n    if type(curr_val) is dict:\n        # the any call here diffs all nested children of the current dict and returns whether any have modifications\n        if not any(\n            [\n                config_diff(k, v, curr_val, defaults[curr_key])\n                for k, v in list(curr_val.items())\n            ]\n        ):\n            parent_dict.pop(curr_key)\n            return 0\n    else:\n        if defaults[curr_key] == curr_val:\n            parent_dict.pop(curr_key)\n            return 0\n    return 1\n\n\ndef write_config(config: dict):\n    \"\"\"\n    Writes a new config dict to a `config.yml` file that will override defaults.\n    Compares user config with defaults to only save changes.\n    \"\"\"\n    defaults = vars(Config())\n    for k, v in list(config.items()):\n        if k != \"SECRET_KEY\":\n            config_diff(k, v, config, defaults)\n    with (Path(current_app.config[\"INTERNAL_DIR\"]) / \"config.yml\").open(\"w\") as f:\n        yaml.dump(config, f)\n\n\ndef load_hooks():\n    try:\n        user_hooks = (Path(current_app.config[\"USER_DIR\"]) / \"hooks.py\").open()\n    except FileNotFoundError:\n        return BaseHooks()\n\n    user_locals = {}\n    exec(user_hooks.read(), globals(), user_locals)\n    user_hooks.close()\n    return user_locals.get(\"Hooks\", BaseHooks)()\n\n\ndef load_scraper():\n    try:\n        user_scraping = (Path(current_app.config[\"USER_DIR\"]) / \"scraping.py\").open()\n    except FileNotFoundError:\n        return {}\n    user_locals = {}\n    exec(user_scraping.read(), globals(), user_locals)\n    user_scraping.close()\n    return user_locals.get(\"PATTERNS\", {})\n\n\ndef get_db(force_reconnect=False):\n    \"\"\"\n    Returns the database object that you can use to\n    store data persistently\n    \"\"\"\n    if \"db\" not in g or force_reconnect:\n        g.db = TinyDB(str(Path(current_app.config[\"INTERNAL_DIR\"]) / \"db.json\"))\n\n    return g.db\n\n\ndef get_max_id():\n    \"\"\"Returns the current maximum id of dataobjs in the database.\"\"\"\n    db = get_db()\n    max_id = db.search(Query().name == \"max_id\")\n    if not max_id:\n        db.insert({\"name\": \"max_id\", \"val\": 0})\n        return 0\n    return max_id[0][\"val\"]\n\n\ndef set_max_id(val):\n    \"\"\"Sets a new max_id\"\"\"\n    db = get_db()\n    db.update(operations.set(\"val\", val), Query().name == \"max_id\")\n\n\ndef test_es_connection(es):\n    \"\"\"Tests health and presence of connection to elasticsearch.\"\"\"\n    try:\n        health = es.cluster.health()\n    except elasticsearch.exceptions.ConnectionError:\n        current_app.logger.error(\n            \"Elasticsearch does not seem to be running on \"\n            f\"{current_app.config['SEARCH_CONF']['url']}. Please start \"\n            \"it, for example with: sudo service elasticsearch restart\"\n        )\n        current_app.logger.error(\n            \"You can disable Elasticsearch by modifying the `enabled` variable \"\n            f\"in {str(Path(current_app.config['INTERNAL_DIR']) / 'config.yml')}\"\n        )\n        sys.exit(1)\n\n    if health[\"status\"] not in (\"yellow\", \"green\"):\n        current_app.logger.warning(\n            \"Elasticsearch reports that it is not working \"\n            \"properly. Search might not work. You can disable \"\n            \"Elasticsearch by setting ELASTICSEARCH_ENABLED to 0.\"\n        )\n\n\ndef get_elastic_client(error_if_invalid=True):\n    \"\"\"Returns the elasticsearch client you can use to search and insert / delete data\"\"\"\n    if (\n        not current_app.config[\"SEARCH_CONF\"][\"enabled\"]\n        or current_app.config[\"SEARCH_CONF\"][\"engine\"] != \"elasticsearch\"\n    ) and error_if_invalid:\n        return None\n\n    auth_setup = (\n        current_app.config[\"SEARCH_CONF\"][\"es_user\"]\n        and current_app.config[\"SEARCH_CONF\"][\"es_password\"]\n    )\n    if auth_setup:\n        es = Elasticsearch(\n            current_app.config[\"SEARCH_CONF\"][\"url\"],\n            http_auth=(\n                current_app.config[\"SEARCH_CONF\"][\"es_user\"],\n                current_app.config[\"SEARCH_CONF\"][\"es_password\"],\n            ),\n        )\n    else:\n        es = Elasticsearch(current_app.config[\"SEARCH_CONF\"][\"url\"])\n    if error_if_invalid:\n        test_es_connection(es)\n    else:\n        try:\n            es.cluster.health()\n        except elasticsearch.exceptions.ConnectionError:\n            return False\n    return es\n\n\ndef create_plugin_dir(name):\n    \"\"\"Creates a sample plugin directory\"\"\"\n    raw_name = name.replace(\"archivy_\", \"\").replace(\"archivy-\", \"\")\n    try:\n        os.makedirs(f\"{name}/{name}\")\n\n        # Creates requirements.txt.\n        with open(f\"{name}/requirements.txt\", \"w\") as fp:\n            fp.writelines([\"archivy\", \"\\nclick\"])\n\n        # Creates an empty readme file to be filled\n        with open(f\"{name}/README.md\", \"w+\") as fp:\n            fp.writelines(\n                [\n                    f\"# {name}\",\n                    \"\\n\\n## Install\",\n                    \"\\n\\nYou need to have `archivy` already installed.\",\n                    f\"\\n\\nRun `pip install archivy_{name}`\",\n                    \"\\n\\n## Usage\",\n                ]\n            )\n\n        # Creates a setup.py file\n        with open(f\"{name}/setup.py\", \"w\") as setup_f:\n            setup_f.writelines(\n                [\n                    \"from setuptools import setup, find_packages\",\n                    '\\n\\nwith open(\"README.md\", \"r\") as fh:',\n                    \"\\n\\tlong_description = fh.read()\",\n                    '\\n\\nwith open(\"requirements.txt\", encoding=\"utf-8\") as f:',\n                    '\\n\\tall_reqs = f.read().split(\"\\\\n\")',\n                    \"\\n\\tinstall_requires = [x.strip() for x in all_reqs]\",\n                    \"\\n\\n#Fill in the details below for distribution purposes\"\n                    f'\\nsetup(\\n\\tname=\"{name}\",',\n                    '\\n\\tversion=\"0.0.1\",',\n                    '\\n\\tauthor=\"\",',\n                    '\\n\\tauthor_email=\"\",',\n                    '\\n\\tdescription=\"\",',\n                    \"\\n\\tlong_description=long_description,\",\n                    '\\n\\tlong_description_content_type=\"text/markdown\",',\n                    '\\n\\tclassifiers=[\"Programming Language :: Python :: 3\"],'\n                    \"\\n\\tpackages=find_packages(),\",\n                    \"\\n\\tinstall_requires=install_requires,\",\n                    f'\\n\\tentry_points=\"\"\"\\n\\t\\t[archivy.plugins]'\n                    f'\\n\\t\\t{raw_name}={name}:{raw_name}\"\"\"\\n)',\n                ]\n            )\n\n        # Creating a basic __init__.py file where the main function of the plugin goes\n        with open(f\"{name}/{name}/__init__.py\", \"w\") as fp:\n            fp.writelines(\n                [\n                    \"import archivy\",\n                    \"\\nimport click\",\n                    \"\\n\\n# Fill in the functionality for the commands (see https://archivy.github.io/plugins/)\",\n                    \"\\n@click.group()\",\n                    f\"\\ndef {raw_name}():\",\n                    \"\\n\\tpass\",\n                    f\"\\n\\n@{raw_name}.command()\",\n                    \"\\ndef command1():\",\n                    \"\\n\\tpass\",\n                    f\"\\n\\n@{raw_name}.command()\",\n                    \"\\ndef command2():\",\n                    \"\\n\\tpass\",\n                ]\n            )\n\n        return True\n    except FileExistsError:\n        return False\n\n\ndef is_safe_redirect_url(target):\n    host_url = urlparse(request.host_url)\n    redirect_url = urlparse(urljoin(request.host_url, target))\n    return (\n        redirect_url.scheme in (\"http\", \"https\")\n        and host_url.netloc == redirect_url.netloc\n    )\n", "from pathlib import Path\nfrom os.path import sep\nfrom pkg_resources import require\nfrom shutil import which\n\nimport frontmatter\nfrom flask import (\n    render_template,\n    flash,\n    redirect,\n    request,\n    url_for,\n    send_file,\n    send_from_directory,\n)\nfrom flask_login import login_user, current_user, logout_user\nfrom tinydb import Query\nfrom werkzeug.security import check_password_hash, generate_password_hash\n\nfrom archivy.models import DataObj, User\nfrom archivy import data, app, forms, csrf\nfrom archivy.helpers import get_db, write_config, is_safe_redirect_url\nfrom archivy.tags import get_all_tags\nfrom archivy.search import search, search_frontmatter_tags\nfrom archivy.config import Config\n\nimport re\n\n\n@app.context_processor\ndef pass_defaults():\n    dataobjs = data.get_items(load_content=False)\n    version = require(\"archivy\")[0].version\n    SEP = sep\n    # check windows parsing for js (https://github.com/Uzay-G/archivy/issues/115)\n    if SEP == \"\\\\\":\n        SEP += \"\\\\\"\n    return dict(dataobjs=dataobjs, SEP=SEP, version=version)\n\n\n@app.before_request\ndef check_perms():\n    allowed_path = (\n        request.path.startswith(\"/login\")\n        or request.path.startswith(\"/static\")\n        or request.path.startswith(\"/api/login\")\n    )\n    if not current_user.is_authenticated and not allowed_path:\n        return redirect(url_for(\"login\", next=request.path))\n    return\n\n\n@app.route(\"/\")\n@app.route(\"/index\")\ndef index():\n    path = request.args.get(\"path\", \"\").lstrip(\"/\")\n    try:\n        files = data.get_items(path=path)\n    except FileNotFoundError:\n        flash(\"Directory does not exist.\", \"error\")\n        return redirect(\"/\")\n\n    return render_template(\n        \"home.html\",\n        title=path or \"root\",\n        search_enabled=app.config[\"SEARCH_CONF\"][\"enabled\"],\n        dir=files,\n        current_path=path,\n        new_folder_form=forms.NewFolderForm(),\n        delete_form=forms.DeleteFolderForm(),\n        rename_form=forms.RenameDirectoryForm(),\n        view_only=0,\n        search_engine=app.config[\"SEARCH_CONF\"][\"engine\"],\n    )\n\n\n# TODO: refactor two following methods\n@app.route(\"/bookmarks/new\", methods=[\"GET\", \"POST\"])\ndef new_bookmark():\n    default_dir = app.config.get(\"DEFAULT_BOOKMARKS_DIR\", \"root directory\")\n    form = forms.NewBookmarkForm(path=default_dir)\n    form.path.choices = [(\"\", \"root directory\")] + [\n        (pathname, pathname) for pathname in data.get_dirs()\n    ]\n    if form.validate_on_submit():\n        path = form.path.data\n        tags = form.tags.data.split(\",\") if form.tags.data != \"\" else []\n        tags = [tag.strip() for tag in tags]\n        bookmark = DataObj(url=form.url.data, tags=tags, path=path, type=\"bookmark\")\n        bookmark.process_bookmark_url()\n        bookmark_id = bookmark.insert()\n        if bookmark_id:\n            flash(\"Bookmark Saved!\", \"success\")\n            return redirect(f\"/dataobj/{bookmark_id}\")\n        else:\n            flash(bookmark.error, \"error\")\n            return redirect(\"/bookmarks/new\")\n    # for bookmarklet\n    form.url.data = request.args.get(\"url\", \"\")\n    path = request.args.get(\"path\", default_dir).strip(\"/\")\n    # handle empty argument\n    form.path.data = path\n    return render_template(\"dataobjs/new.html\", title=\"New Bookmark\", form=form)\n\n\n@app.route(\"/notes/new\", methods=[\"GET\", \"POST\"])\ndef new_note():\n    form = forms.NewNoteForm()\n    default_dir = \"root directory\"\n    form.path.choices = [(\"\", default_dir)] + [\n        (pathname, pathname) for pathname in data.get_dirs()\n    ]\n    if form.validate_on_submit():\n        path = form.path.data\n        tags = form.tags.data.split(\",\") if form.tags.data != \"\" else []\n        tags = [tag.strip() for tag in tags]\n        note = DataObj(title=form.title.data, path=path, tags=tags, type=\"note\")\n        note_id = note.insert()\n        if note_id:\n            flash(\"Note Saved!\", \"success\")\n            return redirect(f\"/dataobj/{note_id}\")\n    path = request.args.get(\"path\", default_dir).strip(\"/\")\n    # handle empty argument\n    form.path.data = path\n    return render_template(\"/dataobjs/new.html\", title=\"New Note\", form=form)\n\n\n@app.route(\"/tags\")\ndef show_all_tags():\n    if not app.config[\"SEARCH_CONF\"][\"engine\"] == \"ripgrep\" and not which(\"rg\"):\n        flash(\"Ripgrep must be installed to view pages about embedded tags.\", \"error\")\n        return redirect(\"/\")\n    tags = sorted(get_all_tags(force=True))\n    return render_template(\"tags/all.html\", title=\"All Tags\", tags=tags)\n\n\n@app.route(\"/tags/<tag_name>\")\ndef show_tag(tag_name):\n    if not app.config[\"SEARCH_CONF\"][\"enabled\"] and not which(\"rg\"):\n        flash(\n            \"Search (for example ripgrep) must be installed to view pages about embedded tags.\",\n            \"error\",\n        )\n        return redirect(\"/\")\n\n    results = search(f\"#{tag_name}#\", strict=True)\n    res_ids = set(\n        [item[\"id\"] for item in results]\n    )  # avoid duplication of results between context-aware embedded tags and metadata ones\n    for res in search_frontmatter_tags(tag_name):\n        if res[\"id\"] not in res_ids:\n            results.append(res)\n\n    return render_template(\n        \"tags/show.html\",\n        title=f\"Tags - {tag_name}\",\n        tag_name=tag_name,\n        search_result=results,\n    )\n\n\n@app.route(\"/dataobj/<int:dataobj_id>\")\ndef show_dataobj(dataobj_id):\n    dataobj = data.get_item(dataobj_id)\n    get_title_id_pairs = lambda x: (x[\"title\"], x[\"id\"])\n    titles = list(\n        map(get_title_id_pairs, data.get_items(structured=False, load_content=False))\n    )\n\n    if not dataobj:\n        flash(\"Data could not be found!\", \"error\")\n        return redirect(\"/\")\n\n    if request.args.get(\"raw\") == \"1\":\n        return frontmatter.dumps(dataobj)\n\n    backlinks = []\n    if app.config[\"SEARCH_CONF\"][\"enabled\"]:\n        if app.config[\"SEARCH_CONF\"][\"engine\"] == \"ripgrep\":\n            query = f\"\\|{dataobj_id}]]\"\n        else:\n            query = f\"|{dataobj_id})]]\"\n        backlinks = search(query, strict=True)\n\n    # Form for moving data into another folder\n    move_form = forms.MoveItemForm()\n    move_form.path.choices = [(\"\", \"root directory\")] + [\n        (pathname, pathname) for pathname in data.get_dirs()\n    ]\n\n    post_title_form = forms.TitleForm()\n    post_title_form.title.data = dataobj[\"title\"]\n\n    # Get all tags\n    tag_list = get_all_tags()\n    # and the ones present in this dataobj\n    embedded_tags = set()\n    PATTERN = r\"(?:^|\\n| )#(?:[-_a-zA-Z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff0-9]+)#\"\n    for match in re.finditer(PATTERN, dataobj.content):\n        embedded_tags.add(match.group(0).replace(\"#\", \"\").lstrip())\n\n    return render_template(\n        \"dataobjs/show.html\",\n        title=dataobj[\"title\"],\n        dataobj=dataobj,\n        backlinks=backlinks,\n        current_path=dataobj[\"dir\"],\n        form=forms.DeleteDataForm(),\n        view_only=0,\n        search_enabled=app.config[\"SEARCH_CONF\"][\"enabled\"],\n        post_title_form=post_title_form,\n        move_form=move_form,\n        tag_list=tag_list,\n        embedded_tags=embedded_tags,\n        titles=titles,\n    )\n\n\n@app.route(\"/dataobj/move/<int:dataobj_id>\", methods=[\"POST\"])\ndef move_item(dataobj_id):\n    form = forms.MoveItemForm()\n    out_dir = form.path.data if form.path.data != \"\" else \"root directory\"\n    if form.path.data == None:\n        flash(\"No path specified.\")\n        return redirect(f\"/dataobj/{dataobj_id}\")\n    try:\n        if data.move_item(dataobj_id, form.path.data):\n            flash(f\"Data successfully moved to {out_dir}.\", \"success\")\n            return redirect(f\"/dataobj/{dataobj_id}\")\n        else:\n            flash(f\"Data could not be moved to {out_dir}.\", \"error\")\n            return redirect(f\"/dataobj/{dataobj_id}\")\n    except FileNotFoundError:\n        flash(\"Data not found.\", \"error\")\n        return redirect(\"/\")\n    except FileExistsError:\n        flash(\"Data already in target directory.\", \"error\")\n        return redirect(f\"/dataobj/{dataobj_id}\")\n\n\n@app.route(\"/dataobj/delete/<int:dataobj_id>\", methods=[\"POST\"])\ndef delete_data(dataobj_id):\n    try:\n        data.delete_item(dataobj_id)\n    except BaseException:\n        flash(\"Data could not be found!\", \"error\")\n        return redirect(\"/\")\n    flash(\"Data deleted!\", \"success\")\n    return redirect(\"/\")\n\n\n@app.route(\"/login\", methods=[\"GET\", \"POST\"])\ndef login():\n    form = forms.UserForm()\n    if form.validate_on_submit():\n        db = get_db()\n        user = db.search(\n            (Query().username == form.username.data) & (Query().type == \"user\")\n        )\n\n        if user and check_password_hash(user[0][\"hashed_password\"], form.password.data):\n            user = User.from_db(user[0])\n            login_user(user, remember=True)\n            flash(\"Login successful!\", \"success\")\n\n            next_url = request.args.get(\"next\")\n            if next_url and is_safe_redirect_url(next_url):\n                return redirect(next_url)\n            else:\n                return redirect(\"/\")\n\n        flash(\"Invalid credentials\", \"error\")\n        return redirect(\"/login\")\n    return render_template(\"users/login.html\", form=form, title=\"Login\")\n\n\n@app.route(\"/logout\", methods=[\"DELETE\", \"GET\"])\ndef logout():\n    logout_user()\n    flash(\"Logged out successfully\", \"success\")\n    return redirect(\"/\")\n\n\n@app.route(\"/user/edit\", methods=[\"GET\", \"POST\"])\ndef edit_user():\n    form = forms.UserForm()\n    if form.validate_on_submit():\n        db = get_db()\n        db.update(\n            {\n                \"username\": form.username.data,\n                \"hashed_password\": generate_password_hash(form.password.data),\n            },\n            doc_ids=[current_user.id],\n        )\n        flash(\"Information saved!\", \"success\")\n        return redirect(\"/\")\n    form.username.data = current_user.username\n    return render_template(\"users/edit.html\", form=form, title=\"Edit Profile\")\n\n\n@app.route(\"/folders/create\", methods=[\"POST\"])\ndef create_folder():\n    form = forms.NewFolderForm()\n    if form.validate_on_submit():\n        path = Path(form.parent_dir.data.strip(\"/\")) / form.new_dir.data\n        new_path = data.create_dir(str(path))\n        flash(\"Folder successfully created.\", \"success\")\n        return redirect(f\"/?path={new_path}\")\n    flash(\"Could not create folder.\", \"error\")\n    return redirect(request.referrer or \"/\")\n\n\n@app.route(\"/folders/delete\", methods=[\"POST\"])\ndef delete_folder():\n    form = forms.DeleteFolderForm()\n    if form.validate_on_submit():\n        if data.delete_dir(form.dir_name.data):\n            flash(\"Folder successfully deleted.\", \"success\")\n            return redirect(\"/\")\n        else:\n            flash(\"Folder not found.\", \"error\")\n            return redirect(request.referrer or \"/\", 404)\n    flash(\"Could not delete folder.\", \"error\")\n    return redirect(request.referrer or \"/\")\n\n\n@app.route(\"/folders/rename\", methods=[\"POST\"])\ndef rename_folder():\n    form = forms.RenameDirectoryForm()\n    if form.validate_on_submit():\n        try:\n            new_path = data.rename_folder(form.current_path.data, form.new_name.data)\n            if not new_path:\n                flash(\"Invalid input.\", \"error\")\n            else:\n                flash(\"Renamed successfully.\", \"success\")\n                return redirect(f\"/?path={new_path}\")\n        except FileNotFoundError:\n            flash(\"Directory not found.\", \"error\")\n        except FileExistsError:\n            flash(\"Target directory exists.\", \"error\")\n    return redirect(\"/\")\n\n\n@app.route(\"/bookmarklet\")\ndef bookmarklet():\n    return render_template(\"bookmarklet.html\", title=\"Bookmarklet\")\n\n\n@app.route(\"/images/<filename>\")\ndef serve_image(filename):\n    if filename and data.valid_image_filename(filename):\n        image_path = data.image_exists(filename)\n        if image_path:\n            return send_file(image_path)\n        else:\n            return \"Image not found\", 404\n    else:\n        return \"Invalid file request\", 413\n\n\n@app.route(\"/static/custom.css\")\ndef custom_css():\n    if not app.config[\"THEME_CONF\"].get(\"use_custom_css\", False):\n        return \"\"\n    return send_from_directory(\n        Path(app.config[\"USER_DIR\"]) / \"css\",\n        app.config[\"THEME_CONF\"][\"custom_css_file\"],\n    )\n\n\n@app.route(\"/config\", methods=[\"GET\", \"POST\"])\ndef config():\n    \"\"\"\n    Web View to edit and update configuration.\n    \"\"\"\n\n    def update_config_value(key, val, dictionary):\n        if key != \"SECRET_KEY\":\n            if type(val) is dict:\n                for k, v in val.items():\n                    update_config_value(k, v, dictionary[key])\n            else:\n                dictionary[key] = val\n\n    form = forms.config_form(app.config)\n    default = vars(Config())\n    if form.validate_on_submit():\n        changed_config = Config()\n        changed_config.override(form.data)\n        for k, v in vars(changed_config).items():\n            # propagate changes to configuration\n            update_config_value(k, v, app.config)\n        write_config(vars(changed_config))  # save to filesystem config\n        flash(\"Config successfully updated.\", \"success\")\n    elif request.method == \"POST\":\n        flash(\"Could not update config.\", \"error\")\n    return render_template(\n        \"config.html\", conf=form, default=default, title=\"Edit Config\"\n    )\n\n\n@csrf.exempt  # exempt from CSRF to be able to submit info directly from bookmarklet\n@app.route(\"/save_from_bookmarklet\", methods=[\"POST\"])\ndef save_raw_url():\n    \"\"\"\n    Used in the bookmarklet - Saves a URL by taking its raw HTML.\n\n    POST parameters:\n    - html\n    - url\n    \"\"\"\n    html = request.form.get(\"html\")\n    if not html:\n        return \"No HTML provided\", 400\n    bookmark = DataObj(url=request.form.get(\"url\"), type=\"bookmark\")\n    bookmark.process_bookmark_url(html)\n    if bookmark.insert():\n        return redirect(f\"/dataobj/{bookmark.id}\")\n    else:\n        return \"Could not save bookmark\", 500\n"], "filenames": ["archivy/helpers.py", "archivy/routes.py"], "buggy_code_start_loc": [8, 22], "buggy_code_end_loc": [232, 268], "fixing_code_start_loc": [8, 22], "fixing_code_end_loc": [243, 271], "type": "CWE-601", "message": "Open Redirect in GitHub repository archivy/archivy prior to 1.7.0.", "other": {"cve": {"id": "CVE-2022-0697", "sourceIdentifier": "security@huntr.dev", "published": "2022-03-06T23:15:09.373", "lastModified": "2022-03-11T16:24:21.250", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Open Redirect in GitHub repository archivy/archivy prior to 1.7.0."}, {"lang": "es", "value": "Un Redireccionamiento Abierto en el repositorio GitHub archivy/archivy versiones anteriores a 1.7.0"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:C/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.4, "baseSeverity": "LOW"}, "exploitabilityScore": 1.6, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-601"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-601"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:archivy_project:archivy:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.7.0", "matchCriteriaId": "D1632FA9-DFE3-49B2-BA34-EA893B66FCFA"}]}]}], "references": [{"url": "https://github.com/archivy/archivy/commit/2d8cb29853190d42572b36deb61127e68d6be574", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/2d0301a2-10ff-48f4-a346-5a0e8707835b", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/archivy/archivy/commit/2d8cb29853190d42572b36deb61127e68d6be574"}}