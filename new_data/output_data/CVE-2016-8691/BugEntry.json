{"buggy_code": ["/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2002 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * JPEG-2000 Code Stream Library\n *\n * $Id$\n */\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <stdlib.h>\n#include <assert.h>\n#include <ctype.h>\n\n#include \"jasper/jas_malloc.h\"\n#include \"jasper/jas_debug.h\"\n\n#include \"jpc_cs.h\"\n\n/******************************************************************************\\\n* Types.\n\\******************************************************************************/\n\n/* Marker segment table entry. */\ntypedef struct {\n\tint id;\n\tchar *name;\n\tjpc_msops_t ops;\n} jpc_mstabent_t;\n\n/******************************************************************************\\\n* Local prototypes.\n\\******************************************************************************/\n\nstatic jpc_mstabent_t *jpc_mstab_lookup(int id);\n\nstatic int jpc_poc_dumpparms(jpc_ms_t *ms, FILE *out);\nstatic int jpc_poc_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\nstatic int jpc_poc_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\nstatic void jpc_poc_destroyparms(jpc_ms_t *ms);\n\nstatic int jpc_unk_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\nstatic int jpc_sot_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\nstatic int jpc_siz_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\nstatic int jpc_cod_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\nstatic int jpc_coc_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\nstatic int jpc_qcd_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\nstatic int jpc_qcc_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\nstatic int jpc_rgn_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\nstatic int jpc_sop_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\nstatic int jpc_ppm_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\nstatic int jpc_ppt_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\nstatic int jpc_crg_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\nstatic int jpc_com_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\n\nstatic int jpc_sot_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\nstatic int jpc_siz_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\nstatic int jpc_cod_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\nstatic int jpc_coc_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\nstatic int jpc_qcd_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\nstatic int jpc_qcc_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\nstatic int jpc_rgn_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\nstatic int jpc_unk_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\nstatic int jpc_sop_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\nstatic int jpc_ppm_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\nstatic int jpc_ppt_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\nstatic int jpc_crg_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\nstatic int jpc_com_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\n\nstatic int jpc_sot_dumpparms(jpc_ms_t *ms, FILE *out);\nstatic int jpc_siz_dumpparms(jpc_ms_t *ms, FILE *out);\nstatic int jpc_cod_dumpparms(jpc_ms_t *ms, FILE *out);\nstatic int jpc_coc_dumpparms(jpc_ms_t *ms, FILE *out);\nstatic int jpc_qcd_dumpparms(jpc_ms_t *ms, FILE *out);\nstatic int jpc_qcc_dumpparms(jpc_ms_t *ms, FILE *out);\nstatic int jpc_rgn_dumpparms(jpc_ms_t *ms, FILE *out);\nstatic int jpc_unk_dumpparms(jpc_ms_t *ms, FILE *out);\nstatic int jpc_sop_dumpparms(jpc_ms_t *ms, FILE *out);\nstatic int jpc_ppm_dumpparms(jpc_ms_t *ms, FILE *out);\nstatic int jpc_ppt_dumpparms(jpc_ms_t *ms, FILE *out);\nstatic int jpc_crg_dumpparms(jpc_ms_t *ms, FILE *out);\nstatic int jpc_com_dumpparms(jpc_ms_t *ms, FILE *out);\n\nstatic void jpc_siz_destroyparms(jpc_ms_t *ms);\nstatic void jpc_qcd_destroyparms(jpc_ms_t *ms);\nstatic void jpc_qcc_destroyparms(jpc_ms_t *ms);\nstatic void jpc_cod_destroyparms(jpc_ms_t *ms);\nstatic void jpc_coc_destroyparms(jpc_ms_t *ms);\nstatic void jpc_unk_destroyparms(jpc_ms_t *ms);\nstatic void jpc_ppm_destroyparms(jpc_ms_t *ms);\nstatic void jpc_ppt_destroyparms(jpc_ms_t *ms);\nstatic void jpc_crg_destroyparms(jpc_ms_t *ms);\nstatic void jpc_com_destroyparms(jpc_ms_t *ms);\n\nstatic void jpc_qcx_destroycompparms(jpc_qcxcp_t *compparms);\nstatic int jpc_qcx_getcompparms(jpc_qcxcp_t *compparms, jpc_cstate_t *cstate,\n  jas_stream_t *in, uint_fast16_t len);\nstatic int jpc_qcx_putcompparms(jpc_qcxcp_t *compparms, jpc_cstate_t *cstate,\n  jas_stream_t *out);\nstatic void jpc_cox_destroycompparms(jpc_coxcp_t *compparms);\nstatic int jpc_cox_getcompparms(jpc_ms_t *ms, jpc_cstate_t *cstate,\n  jas_stream_t *in, int prtflag, jpc_coxcp_t *compparms);\nstatic int jpc_cox_putcompparms(jpc_ms_t *ms, jpc_cstate_t *cstate,\n  jas_stream_t *out, int prtflag, jpc_coxcp_t *compparms);\n\n/******************************************************************************\\\n* Global data.\n\\******************************************************************************/\n\nstatic jpc_mstabent_t jpc_mstab[] = {\n\t{JPC_MS_SOC, \"SOC\", {0, 0, 0, 0}},\n\t{JPC_MS_SOT, \"SOT\", {0, jpc_sot_getparms, jpc_sot_putparms,\n\t  jpc_sot_dumpparms}},\n\t{JPC_MS_SOD, \"SOD\", {0, 0, 0, 0}},\n\t{JPC_MS_EOC, \"EOC\", {0, 0, 0, 0}},\n\t{JPC_MS_SIZ, \"SIZ\", {jpc_siz_destroyparms, jpc_siz_getparms,\n\t  jpc_siz_putparms, jpc_siz_dumpparms}},\n\t{JPC_MS_COD, \"COD\", {jpc_cod_destroyparms, jpc_cod_getparms,\n\t  jpc_cod_putparms, jpc_cod_dumpparms}},\n\t{JPC_MS_COC, \"COC\", {jpc_coc_destroyparms, jpc_coc_getparms,\n\t  jpc_coc_putparms, jpc_coc_dumpparms}},\n\t{JPC_MS_RGN, \"RGN\", {0, jpc_rgn_getparms, jpc_rgn_putparms,\n\t  jpc_rgn_dumpparms}},\n\t{JPC_MS_QCD, \"QCD\", {jpc_qcd_destroyparms, jpc_qcd_getparms,\n\t  jpc_qcd_putparms, jpc_qcd_dumpparms}},\n\t{JPC_MS_QCC, \"QCC\", {jpc_qcc_destroyparms, jpc_qcc_getparms,\n\t  jpc_qcc_putparms, jpc_qcc_dumpparms}},\n\t{JPC_MS_POC, \"POC\", {jpc_poc_destroyparms, jpc_poc_getparms,\n\t  jpc_poc_putparms, jpc_poc_dumpparms}},\n\t{JPC_MS_TLM, \"TLM\", {0, jpc_unk_getparms, jpc_unk_putparms, 0}},\n\t{JPC_MS_PLM, \"PLM\", {0, jpc_unk_getparms, jpc_unk_putparms, 0}},\n\t{JPC_MS_PPM, \"PPM\", {jpc_ppm_destroyparms, jpc_ppm_getparms,\n\t  jpc_ppm_putparms, jpc_ppm_dumpparms}},\n\t{JPC_MS_PPT, \"PPT\", {jpc_ppt_destroyparms, jpc_ppt_getparms,\n\t  jpc_ppt_putparms, jpc_ppt_dumpparms}},\n\t{JPC_MS_SOP, \"SOP\", {0, jpc_sop_getparms, jpc_sop_putparms,\n\t  jpc_sop_dumpparms}},\n\t{JPC_MS_EPH, \"EPH\", {0, 0, 0, 0}},\n\t{JPC_MS_CRG, \"CRG\", {0, jpc_crg_getparms, jpc_crg_putparms,\n\t  jpc_crg_dumpparms}},\n\t{JPC_MS_COM, \"COM\", {jpc_com_destroyparms, jpc_com_getparms,\n\t  jpc_com_putparms, jpc_com_dumpparms}},\n\t{-1, \"UNKNOWN\",  {jpc_unk_destroyparms, jpc_unk_getparms,\n\t  jpc_unk_putparms, jpc_unk_dumpparms}}\n};\n\n/******************************************************************************\\\n* Code stream manipulation functions.\n\\******************************************************************************/\n\n/* Create a code stream state object. */\njpc_cstate_t *jpc_cstate_create()\n{\n\tjpc_cstate_t *cstate;\n\tif (!(cstate = jas_malloc(sizeof(jpc_cstate_t)))) {\n\t\treturn 0;\n\t}\n\tcstate->numcomps = 0;\n\treturn cstate;\n}\n\n/* Destroy a code stream state object. */\nvoid jpc_cstate_destroy(jpc_cstate_t *cstate)\n{\n\tjas_free(cstate);\n}\n\n/* Read a marker segment from a stream. */\njpc_ms_t *jpc_getms(jas_stream_t *in, jpc_cstate_t *cstate)\n{\n\tjpc_ms_t *ms;\n\tjpc_mstabent_t *mstabent;\n\tjas_stream_t *tmpstream;\n\n\tif (!(ms = jpc_ms_create(0))) {\n\t\treturn 0;\n\t}\n\n\t/* Get the marker type. */\n\tif (jpc_getuint16(in, &ms->id) || ms->id < JPC_MS_MIN ||\n\t  ms->id > JPC_MS_MAX) {\n\t\tjpc_ms_destroy(ms);\n\t\treturn 0;\n\t}\n\n\tmstabent = jpc_mstab_lookup(ms->id);\n\tms->ops = &mstabent->ops;\n\n\t/* Get the marker segment length and parameters if present. */\n\t/* Note: It is tacitly assumed that a marker segment cannot have\n\t  parameters unless it has a length field.  That is, there cannot\n\t  be a parameters field without a length field and vice versa. */\n\tif (JPC_MS_HASPARMS(ms->id)) {\n\t\t/* Get the length of the marker segment. */\n\t\tif (jpc_getuint16(in, &ms->len) || ms->len < 3) {\n\t\t\tjpc_ms_destroy(ms);\n\t\t\treturn 0;\n\t\t}\n\t\t/* Calculate the length of the marker segment parameters. */\n\t\tms->len -= 2;\n\t\t/* Create and prepare a temporary memory stream from which to\n\t\t  read the marker segment parameters. */\n\t\t/* Note: This approach provides a simple way of ensuring that\n\t\t  we never read beyond the end of the marker segment (even if\n\t\t  the marker segment length is errantly set too small). */\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\t\tjpc_ms_destroy(ms);\n\t\t\treturn 0;\n\t\t}\n\t\tif (jas_stream_copy(tmpstream, in, ms->len) ||\n\t\t  jas_stream_seek(tmpstream, 0, SEEK_SET) < 0) {\n\t\t\tjas_stream_close(tmpstream);\n\t\t\tjpc_ms_destroy(ms);\n\t\t\treturn 0;\n\t\t}\n\t\t/* Get the marker segment parameters. */\n\t\tif ((*ms->ops->getparms)(ms, cstate, tmpstream)) {\n\t\t\tms->ops = 0;\n\t\t\tjpc_ms_destroy(ms);\n\t\t\tjas_stream_close(tmpstream);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (jas_getdbglevel() > 0) {\n\t\t\tjpc_ms_dump(ms, stderr);\n\t\t}\n\n\t\tif (JAS_CAST(ulong, jas_stream_tell(tmpstream)) != ms->len) {\n\t\t\tjas_eprintf(\"warning: trailing garbage in marker segment (%ld bytes)\\n\",\n\t\t\t  ms->len - jas_stream_tell(tmpstream));\n\t\t}\n\n\t\t/* Close the temporary stream. */\n\t\tjas_stream_close(tmpstream);\n\n\t} else {\n\t\t/* There are no marker segment parameters. */\n\t\tms->len = 0;\n\n\t\tif (jas_getdbglevel() > 0) {\n\t\t\tjpc_ms_dump(ms, stderr);\n\t\t}\n\t}\n\n\t/* Update the code stream state information based on the type of\n\t  marker segment read. */\n\t/* Note: This is a bit of a hack, but I'm not going to define another\n\t  type of virtual function for this one special case. */\n\tif (ms->id == JPC_MS_SIZ) {\n\t\tcstate->numcomps = ms->parms.siz.numcomps;\n\t}\n\n\treturn ms;\n}\n\n/* Write a marker segment to a stream. */\nint jpc_putms(jas_stream_t *out, jpc_cstate_t *cstate, jpc_ms_t *ms)\n{\n\tjas_stream_t *tmpstream;\n\tint len;\n\n\t/* Output the marker segment type. */\n\tif (jpc_putuint16(out, ms->id)) {\n\t\treturn -1;\n\t}\n\n\t/* Output the marker segment length and parameters if necessary. */\n\tif (ms->ops->putparms) {\n\t\t/* Create a temporary stream in which to buffer the\n\t\t  parameter data. */\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif ((*ms->ops->putparms)(ms, cstate, tmpstream)) {\n\t\t\tjas_stream_close(tmpstream);\n\t\t\treturn -1;\n\t\t}\n\t\t/* Get the number of bytes of parameter data written. */\n\t\tif ((len = jas_stream_tell(tmpstream)) < 0) {\n\t\t\tjas_stream_close(tmpstream);\n\t\t\treturn -1;\n\t\t}\n\t\tms->len = len;\n\t\t/* Write the marker segment length and parameter data to\n\t\t  the output stream. */\n\t\tif (jas_stream_seek(tmpstream, 0, SEEK_SET) < 0 ||\n\t\t  jpc_putuint16(out, ms->len + 2) ||\n\t\t  jas_stream_copy(out, tmpstream, ms->len) < 0) {\n\t\t\tjas_stream_close(tmpstream);\n\t\t\treturn -1;\n\t\t}\n\t\t/* Close the temporary stream. */\n\t\tjas_stream_close(tmpstream);\n\t}\n\n\t/* This is a bit of a hack, but I'm not going to define another\n\t  type of virtual function for this one special case. */\n\tif (ms->id == JPC_MS_SIZ) {\n\t\tcstate->numcomps = ms->parms.siz.numcomps;\n\t}\n\n\tif (jas_getdbglevel() > 0) {\n\t\tjpc_ms_dump(ms, stderr);\n\t}\n\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Marker segment operations.\n\\******************************************************************************/\n\n/* Create a marker segment of the specified type. */\njpc_ms_t *jpc_ms_create(int type)\n{\n\tjpc_ms_t *ms;\n\tjpc_mstabent_t *mstabent;\n\n\tif (!(ms = jas_malloc(sizeof(jpc_ms_t)))) {\n\t\treturn 0;\n\t}\n\tms->id = type;\n\tms->len = 0;\n\tmstabent = jpc_mstab_lookup(ms->id);\n\tms->ops = &mstabent->ops;\n\tmemset(&ms->parms, 0, sizeof(jpc_msparms_t));\n\treturn ms;\n}\n\n/* Destroy a marker segment. */\nvoid jpc_ms_destroy(jpc_ms_t *ms)\n{\n\tif (ms->ops && ms->ops->destroyparms) {\n\t\t(*ms->ops->destroyparms)(ms);\n\t}\n\tjas_free(ms);\n}\n\n/* Dump a marker segment to a stream for debugging. */\nvoid jpc_ms_dump(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_mstabent_t *mstabent;\n\tmstabent = jpc_mstab_lookup(ms->id);\n\tfprintf(out, \"type = 0x%04x (%s);\", ms->id, mstabent->name);\n\tif (JPC_MS_HASPARMS(ms->id)) {\n\t\tfprintf(out, \" len = %d;\", ms->len + 2);\n\t\tif (ms->ops->dumpparms) {\n\t\t\t(*ms->ops->dumpparms)(ms, out);\n\t\t} else {\n\t\t\tfprintf(out, \"\\n\");\n\t\t}\n\t} else {\n\t\tfprintf(out, \"\\n\");\n\t}\n}\n\n/******************************************************************************\\\n* SOT marker segment operations.\n\\******************************************************************************/\n\nstatic int jpc_sot_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_sot_t *sot = &ms->parms.sot;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tif (jpc_getuint16(in, &sot->tileno) ||\n\t  jpc_getuint32(in, &sot->len) ||\n\t  jpc_getuint8(in, &sot->partno) ||\n\t  jpc_getuint8(in, &sot->numparts)) {\n\t\treturn -1;\n\t}\n\tif (jas_stream_eof(in)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_sot_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_sot_t *sot = &ms->parms.sot;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tif (jpc_putuint16(out, sot->tileno) ||\n\t  jpc_putuint32(out, sot->len) ||\n\t  jpc_putuint8(out, sot->partno) ||\n\t  jpc_putuint8(out, sot->numparts)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_sot_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_sot_t *sot = &ms->parms.sot;\n\tfprintf(out, \"tileno = %d; len = %d; partno = %d; numparts = %d\\n\",\n\t  sot->tileno, sot->len, sot->partno, sot->numparts);\n\treturn 0;\n}\n\n/******************************************************************************\\\n* SIZ marker segment operations.\n\\******************************************************************************/\n\nstatic void jpc_siz_destroyparms(jpc_ms_t *ms)\n{\n\tjpc_siz_t *siz = &ms->parms.siz;\n\tif (siz->comps) {\n\t\tjas_free(siz->comps);\n\t}\n}\n\nstatic int jpc_siz_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate,\n  jas_stream_t *in)\n{\n\tjpc_siz_t *siz = &ms->parms.siz;\n\tunsigned int i;\n\tuint_fast8_t tmp;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tif (jpc_getuint16(in, &siz->caps) ||\n\t  jpc_getuint32(in, &siz->width) ||\n\t  jpc_getuint32(in, &siz->height) ||\n\t  jpc_getuint32(in, &siz->xoff) ||\n\t  jpc_getuint32(in, &siz->yoff) ||\n\t  jpc_getuint32(in, &siz->tilewidth) ||\n\t  jpc_getuint32(in, &siz->tileheight) ||\n\t  jpc_getuint32(in, &siz->tilexoff) ||\n\t  jpc_getuint32(in, &siz->tileyoff) ||\n\t  jpc_getuint16(in, &siz->numcomps)) {\n\t\treturn -1;\n\t}\n\tif (!siz->width || !siz->height || !siz->tilewidth ||\n\t  !siz->tileheight || !siz->numcomps) {\n\t\treturn -1;\n\t}\n\tif (!(siz->comps = jas_alloc2(siz->numcomps, sizeof(jpc_sizcomp_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < siz->numcomps; ++i) {\n\t\tif (jpc_getuint8(in, &tmp) ||\n\t\t  jpc_getuint8(in, &siz->comps[i].hsamp) ||\n\t\t  jpc_getuint8(in, &siz->comps[i].vsamp)) {\n\t\t\tjas_free(siz->comps);\n\t\t\treturn -1;\n\t\t}\n\t\tsiz->comps[i].sgnd = (tmp >> 7) & 1;\n\t\tsiz->comps[i].prec = (tmp & 0x7f) + 1;\n\t}\n\tif (jas_stream_eof(in)) {\n\t\tjas_free(siz->comps);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_siz_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_siz_t *siz = &ms->parms.siz;\n\tunsigned int i;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tassert(siz->width && siz->height && siz->tilewidth &&\n\t  siz->tileheight && siz->numcomps);\n\tif (jpc_putuint16(out, siz->caps) ||\n\t  jpc_putuint32(out, siz->width) ||\n\t  jpc_putuint32(out, siz->height) ||\n\t  jpc_putuint32(out, siz->xoff) ||\n\t  jpc_putuint32(out, siz->yoff) ||\n\t  jpc_putuint32(out, siz->tilewidth) ||\n\t  jpc_putuint32(out, siz->tileheight) ||\n\t  jpc_putuint32(out, siz->tilexoff) ||\n\t  jpc_putuint32(out, siz->tileyoff) ||\n\t  jpc_putuint16(out, siz->numcomps)) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < siz->numcomps; ++i) {\n\t\tif (jpc_putuint8(out, ((siz->comps[i].sgnd & 1) << 7) |\n\t\t  ((siz->comps[i].prec - 1) & 0x7f)) ||\n\t\t  jpc_putuint8(out, siz->comps[i].hsamp) ||\n\t\t  jpc_putuint8(out, siz->comps[i].vsamp)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jpc_siz_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_siz_t *siz = &ms->parms.siz;\n\tunsigned int i;\n\tfprintf(out, \"caps = 0x%02x;\\n\", siz->caps);\n\tfprintf(out, \"width = %d; height = %d; xoff = %d; yoff = %d;\\n\",\n\t  siz->width, siz->height, siz->xoff, siz->yoff);\n\tfprintf(out, \"tilewidth = %d; tileheight = %d; tilexoff = %d; \"\n\t  \"tileyoff = %d;\\n\", siz->tilewidth, siz->tileheight, siz->tilexoff,\n\t  siz->tileyoff);\n\tfor (i = 0; i < siz->numcomps; ++i) {\n\t\tfprintf(out, \"prec[%d] = %d; sgnd[%d] = %d; hsamp[%d] = %d; \"\n\t\t  \"vsamp[%d] = %d\\n\", i, siz->comps[i].prec, i,\n\t\t  siz->comps[i].sgnd, i, siz->comps[i].hsamp, i,\n\t\t  siz->comps[i].vsamp);\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* COD marker segment operations.\n\\******************************************************************************/\n\nstatic void jpc_cod_destroyparms(jpc_ms_t *ms)\n{\n\tjpc_cod_t *cod = &ms->parms.cod;\n\tjpc_cox_destroycompparms(&cod->compparms);\n}\n\nstatic int jpc_cod_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_cod_t *cod = &ms->parms.cod;\n\tif (jpc_getuint8(in, &cod->csty)) {\n\t\treturn -1;\n\t}\n\tif (jpc_getuint8(in, &cod->prg) ||\n\t  jpc_getuint16(in, &cod->numlyrs) ||\n\t  jpc_getuint8(in, &cod->mctrans)) {\n\t\treturn -1;\n\t}\n\tif (jpc_cox_getcompparms(ms, cstate, in,\n\t  (cod->csty & JPC_COX_PRT) != 0, &cod->compparms)) {\n\t\treturn -1;\n\t}\n\tif (jas_stream_eof(in)) {\n\t\tjpc_cod_destroyparms(ms);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_cod_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_cod_t *cod = &ms->parms.cod;\n\tassert(cod->numlyrs > 0 && cod->compparms.numdlvls <= 32);\n\tassert(cod->compparms.numdlvls == cod->compparms.numrlvls - 1);\n\tif (jpc_putuint8(out, cod->compparms.csty) ||\n\t  jpc_putuint8(out, cod->prg) ||\n\t  jpc_putuint16(out, cod->numlyrs) ||\n\t  jpc_putuint8(out, cod->mctrans)) {\n\t\treturn -1;\n\t}\n\tif (jpc_cox_putcompparms(ms, cstate, out,\n\t  (cod->csty & JPC_COX_PRT) != 0, &cod->compparms)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_cod_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_cod_t *cod = &ms->parms.cod;\n\tint i;\n\tfprintf(out, \"csty = 0x%02x;\\n\", cod->compparms.csty);\n\tfprintf(out, \"numdlvls = %d; qmfbid = %d; mctrans = %d\\n\",\n\t  cod->compparms.numdlvls, cod->compparms.qmfbid, cod->mctrans);\n\tfprintf(out, \"prg = %d; numlyrs = %d;\\n\",\n\t  cod->prg, cod->numlyrs);\n\tfprintf(out, \"cblkwidthval = %d; cblkheightval = %d; \"\n\t  \"cblksty = 0x%02x;\\n\", cod->compparms.cblkwidthval, cod->compparms.cblkheightval,\n\t  cod->compparms.cblksty);\n\tif (cod->csty & JPC_COX_PRT) {\n\t\tfor (i = 0; i < cod->compparms.numrlvls; ++i) {\n\t\t\tjas_eprintf(\"prcwidth[%d] = %d, prcheight[%d] = %d\\n\",\n\t\t\t  i, cod->compparms.rlvls[i].parwidthval,\n\t\t\t  i, cod->compparms.rlvls[i].parheightval);\n\t\t}\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* COC marker segment operations.\n\\******************************************************************************/\n\nstatic void jpc_coc_destroyparms(jpc_ms_t *ms)\n{\n\tjpc_coc_t *coc = &ms->parms.coc;\n\tjpc_cox_destroycompparms(&coc->compparms);\n}\n\nstatic int jpc_coc_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_coc_t *coc = &ms->parms.coc;\n\tuint_fast8_t tmp;\n\tif (cstate->numcomps <= 256) {\n\t\tif (jpc_getuint8(in, &tmp)) {\n\t\t\treturn -1;\n\t\t}\n\t\tcoc->compno = tmp;\n\t} else {\n\t\tif (jpc_getuint16(in, &coc->compno)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (jpc_getuint8(in, &coc->compparms.csty)) {\n\t\treturn -1;\n\t}\n\tif (jpc_cox_getcompparms(ms, cstate, in,\n\t  (coc->compparms.csty & JPC_COX_PRT) != 0, &coc->compparms)) {\n\t\treturn -1;\n\t}\n\tif (jas_stream_eof(in)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_coc_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_coc_t *coc = &ms->parms.coc;\n\tassert(coc->compparms.numdlvls <= 32);\n\tif (cstate->numcomps <= 256) {\n\t\tif (jpc_putuint8(out, coc->compno)) {\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tif (jpc_putuint16(out, coc->compno)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (jpc_putuint8(out, coc->compparms.csty)) {\n\t\treturn -1;\n\t}\n\tif (jpc_cox_putcompparms(ms, cstate, out,\n\t  (coc->compparms.csty & JPC_COX_PRT) != 0, &coc->compparms)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_coc_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_coc_t *coc = &ms->parms.coc;\n\tfprintf(out, \"compno = %d; csty = 0x%02x; numdlvls = %d;\\n\",\n\t  coc->compno, coc->compparms.csty, coc->compparms.numdlvls);\n\tfprintf(out, \"cblkwidthval = %d; cblkheightval = %d; \"\n\t  \"cblksty = 0x%02x; qmfbid = %d;\\n\", coc->compparms.cblkwidthval,\n\t  coc->compparms.cblkheightval, coc->compparms.cblksty, coc->compparms.qmfbid);\n\treturn 0;\n}\n/******************************************************************************\\\n* COD/COC marker segment operation helper functions.\n\\******************************************************************************/\n\nstatic void jpc_cox_destroycompparms(jpc_coxcp_t *compparms)\n{\n\t/* Eliminate compiler warning about unused variables. */\n\tcompparms = 0;\n}\n\nstatic int jpc_cox_getcompparms(jpc_ms_t *ms, jpc_cstate_t *cstate,\n  jas_stream_t *in, int prtflag, jpc_coxcp_t *compparms)\n{\n\tuint_fast8_t tmp;\n\tint i;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tms = 0;\n\tcstate = 0;\n\n\tif (jpc_getuint8(in, &compparms->numdlvls) ||\n\t  jpc_getuint8(in, &compparms->cblkwidthval) ||\n\t  jpc_getuint8(in, &compparms->cblkheightval) ||\n\t  jpc_getuint8(in, &compparms->cblksty) ||\n\t  jpc_getuint8(in, &compparms->qmfbid)) {\n\t\treturn -1;\n\t}\n\tcompparms->numrlvls = compparms->numdlvls + 1;\n\tif (prtflag) {\n\t\tfor (i = 0; i < compparms->numrlvls; ++i) {\n\t\t\tif (jpc_getuint8(in, &tmp)) {\n\t\t\t\tjpc_cox_destroycompparms(compparms);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tcompparms->rlvls[i].parwidthval = tmp & 0xf;\n\t\t\tcompparms->rlvls[i].parheightval = (tmp >> 4) & 0xf;\n\t\t}\n/* Sigh.  This bit should be in the same field in both COC and COD mrk segs. */\ncompparms->csty |= JPC_COX_PRT;\n\t} else {\n\t}\n\tif (jas_stream_eof(in)) {\n\t\tjpc_cox_destroycompparms(compparms);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_cox_putcompparms(jpc_ms_t *ms, jpc_cstate_t *cstate,\n  jas_stream_t *out, int prtflag, jpc_coxcp_t *compparms)\n{\n\tint i;\n\tassert(compparms->numdlvls <= 32);\n\n\t/* Eliminate compiler warning about unused variables. */\n\tms = 0;\n\tcstate = 0;\n\n\tif (jpc_putuint8(out, compparms->numdlvls) ||\n\t  jpc_putuint8(out, compparms->cblkwidthval) ||\n\t  jpc_putuint8(out, compparms->cblkheightval) ||\n\t  jpc_putuint8(out, compparms->cblksty) ||\n\t  jpc_putuint8(out, compparms->qmfbid)) {\n\t\treturn -1;\n\t}\n\tif (prtflag) {\n\t\tfor (i = 0; i < compparms->numrlvls; ++i) {\n\t\t\tif (jpc_putuint8(out,\n\t\t\t  ((compparms->rlvls[i].parheightval & 0xf) << 4) |\n\t\t\t  (compparms->rlvls[i].parwidthval & 0xf))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* RGN marker segment operations.\n\\******************************************************************************/\n\nstatic int jpc_rgn_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_rgn_t *rgn = &ms->parms.rgn;\n\tuint_fast8_t tmp;\n\tif (cstate->numcomps <= 256) {\n\t\tif (jpc_getuint8(in, &tmp)) {\n\t\t\treturn -1;\n\t\t}\n\t\trgn->compno = tmp;\n\t} else {\n\t\tif (jpc_getuint16(in, &rgn->compno)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (jpc_getuint8(in, &rgn->roisty) ||\n\t  jpc_getuint8(in, &rgn->roishift)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_rgn_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_rgn_t *rgn = &ms->parms.rgn;\n\tif (cstate->numcomps <= 256) {\n\t\tif (jpc_putuint8(out, rgn->compno)) {\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tif (jpc_putuint16(out, rgn->compno)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (jpc_putuint8(out, rgn->roisty) ||\n\t  jpc_putuint8(out, rgn->roishift)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_rgn_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_rgn_t *rgn = &ms->parms.rgn;\n\tfprintf(out, \"compno = %d; roisty = %d; roishift = %d\\n\",\n\t  rgn->compno, rgn->roisty, rgn->roishift);\n\treturn 0;\n}\n\n/******************************************************************************\\\n* QCD marker segment operations.\n\\******************************************************************************/\n\nstatic void jpc_qcd_destroyparms(jpc_ms_t *ms)\n{\n\tjpc_qcd_t *qcd = &ms->parms.qcd;\n\tjpc_qcx_destroycompparms(&qcd->compparms);\n}\n\nstatic int jpc_qcd_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_qcxcp_t *compparms = &ms->parms.qcd.compparms;\n\treturn jpc_qcx_getcompparms(compparms, cstate, in, ms->len);\n}\n\nstatic int jpc_qcd_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_qcxcp_t *compparms = &ms->parms.qcd.compparms;\n\treturn jpc_qcx_putcompparms(compparms, cstate, out);\n}\n\nstatic int jpc_qcd_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_qcd_t *qcd = &ms->parms.qcd;\n\tint i;\n\tfprintf(out, \"qntsty = %d; numguard = %d; numstepsizes = %d\\n\",\n\t  (int) qcd->compparms.qntsty, qcd->compparms.numguard, qcd->compparms.numstepsizes);\n\tfor (i = 0; i < qcd->compparms.numstepsizes; ++i) {\n\t\tfprintf(out, \"expn[%d] = 0x%04x; mant[%d] = 0x%04x;\\n\",\n\t\t  i, (unsigned) JPC_QCX_GETEXPN(qcd->compparms.stepsizes[i]),\n\t\t  i, (unsigned) JPC_QCX_GETMANT(qcd->compparms.stepsizes[i]));\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* QCC marker segment operations.\n\\******************************************************************************/\n\nstatic void jpc_qcc_destroyparms(jpc_ms_t *ms)\n{\n\tjpc_qcc_t *qcc = &ms->parms.qcc;\n\tjpc_qcx_destroycompparms(&qcc->compparms);\n}\n\nstatic int jpc_qcc_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_qcc_t *qcc = &ms->parms.qcc;\n\tuint_fast8_t tmp;\n\tint len;\n\tlen = ms->len;\n\tif (cstate->numcomps <= 256) {\n\t\tif (jpc_getuint8(in, &tmp)) {\n\t\t\treturn -1;\n\t\t}\n\t\tqcc->compno = tmp;\n\t\t--len;\n\t} else {\n\t\tif (jpc_getuint16(in, &qcc->compno)) {\n\t\t\treturn -1;\n\t\t}\n\t\tlen -= 2;\n\t}\n\tif (jpc_qcx_getcompparms(&qcc->compparms, cstate, in, len)) {\n\t\treturn -1;\n\t}\n\tif (jas_stream_eof(in)) {\n\t\tjpc_qcc_destroyparms(ms);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_qcc_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_qcc_t *qcc = &ms->parms.qcc;\n\tif (cstate->numcomps <= 256) {\n\t\tif (jpc_putuint8(out, qcc->compno)) {\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tif (jpc_putuint16(out, qcc->compno)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (jpc_qcx_putcompparms(&qcc->compparms, cstate, out)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_qcc_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_qcc_t *qcc = &ms->parms.qcc;\n\tint i;\n\tfprintf(out, \"compno = %d; qntsty = %d; numguard = %d; \"\n\t  \"numstepsizes = %d\\n\", qcc->compno, qcc->compparms.qntsty, qcc->compparms.numguard,\n\t  qcc->compparms.numstepsizes);\n\tfor (i = 0; i < qcc->compparms.numstepsizes; ++i) {\n\t\tfprintf(out, \"expn[%d] = 0x%04x; mant[%d] = 0x%04x;\\n\",\n\t\t  i, (unsigned) JPC_QCX_GETEXPN(qcc->compparms.stepsizes[i]),\n\t\t  i, (unsigned) JPC_QCX_GETMANT(qcc->compparms.stepsizes[i]));\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* QCD/QCC marker segment helper functions.\n\\******************************************************************************/\n\nstatic void jpc_qcx_destroycompparms(jpc_qcxcp_t *compparms)\n{\n\tif (compparms->stepsizes) {\n\t\tjas_free(compparms->stepsizes);\n\t}\n}\n\nstatic int jpc_qcx_getcompparms(jpc_qcxcp_t *compparms, jpc_cstate_t *cstate,\n  jas_stream_t *in, uint_fast16_t len)\n{\n\tuint_fast8_t tmp;\n\tint n;\n\tint i;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tn = 0;\n\tif (jpc_getuint8(in, &tmp)) {\n\t\treturn -1;\n\t}\n\t++n;\n\tcompparms->qntsty = tmp & 0x1f;\n\tcompparms->numguard = (tmp >> 5) & 7;\n\tswitch (compparms->qntsty) {\n\tcase JPC_QCX_SIQNT:\n\t\tcompparms->numstepsizes = 1;\n\t\tbreak;\n\tcase JPC_QCX_NOQNT:\n\t\tcompparms->numstepsizes = (len - n);\n\t\tbreak;\n\tcase JPC_QCX_SEQNT:\n\t\t/* XXX - this is a hack */\n\t\tcompparms->numstepsizes = (len - n) / 2;\n\t\tbreak;\n\t}\n\tif (compparms->numstepsizes > 0) {\n\t\tcompparms->stepsizes = jas_alloc2(compparms->numstepsizes,\n\t\t  sizeof(uint_fast16_t));\n\t\tassert(compparms->stepsizes);\n\t\tfor (i = 0; i < compparms->numstepsizes; ++i) {\n\t\t\tif (compparms->qntsty == JPC_QCX_NOQNT) {\n\t\t\t\tif (jpc_getuint8(in, &tmp)) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tcompparms->stepsizes[i] = JPC_QCX_EXPN(tmp >> 3);\n\t\t\t} else {\n\t\t\t\tif (jpc_getuint16(in, &compparms->stepsizes[i])) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tcompparms->stepsizes = 0;\n\t}\n\tif (jas_stream_error(in) || jas_stream_eof(in)) {\n\t\tjpc_qcx_destroycompparms(compparms);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_qcx_putcompparms(jpc_qcxcp_t *compparms, jpc_cstate_t *cstate,\n  jas_stream_t *out)\n{\n\tint i;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tjpc_putuint8(out, ((compparms->numguard & 7) << 5) | compparms->qntsty);\n\tfor (i = 0; i < compparms->numstepsizes; ++i) {\n\t\tif (compparms->qntsty == JPC_QCX_NOQNT) {\n\t\t\tif (jpc_putuint8(out, JPC_QCX_GETEXPN(\n\t\t\t  compparms->stepsizes[i]) << 3)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (jpc_putuint16(out, compparms->stepsizes[i])) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* SOP marker segment operations.\n\\******************************************************************************/\n\nstatic int jpc_sop_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_sop_t *sop = &ms->parms.sop;\n\n\t/* Eliminate compiler warning about unused variable. */\n\tcstate = 0;\n\n\tif (jpc_getuint16(in, &sop->seqno)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_sop_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_sop_t *sop = &ms->parms.sop;\n\n\t/* Eliminate compiler warning about unused variable. */\n\tcstate = 0;\n\n\tif (jpc_putuint16(out, sop->seqno)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_sop_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_sop_t *sop = &ms->parms.sop;\n\tfprintf(out, \"seqno = %d;\\n\", sop->seqno);\n\treturn 0;\n}\n\n/******************************************************************************\\\n* PPM marker segment operations.\n\\******************************************************************************/\n\nstatic void jpc_ppm_destroyparms(jpc_ms_t *ms)\n{\n\tjpc_ppm_t *ppm = &ms->parms.ppm;\n\tif (ppm->data) {\n\t\tjas_free(ppm->data);\n\t}\n}\n\nstatic int jpc_ppm_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_ppm_t *ppm = &ms->parms.ppm;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tppm->data = 0;\n\n\tif (ms->len < 1) {\n\t\tgoto error;\n\t}\n\tif (jpc_getuint8(in, &ppm->ind)) {\n\t\tgoto error;\n\t}\n\n\tppm->len = ms->len - 1;\n\tif (ppm->len > 0) {\n\t\tif (!(ppm->data = jas_malloc(ppm->len))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (JAS_CAST(uint, jas_stream_read(in, ppm->data, ppm->len)) != ppm->len) {\n\t\t\tgoto error;\n\t\t}\n\t} else {\n\t\tppm->data = 0;\n\t}\n\treturn 0;\n\nerror:\n\tjpc_ppm_destroyparms(ms);\n\treturn -1;\n}\n\nstatic int jpc_ppm_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_ppm_t *ppm = &ms->parms.ppm;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tif (JAS_CAST(uint, jas_stream_write(out, (char *) ppm->data, ppm->len)) != ppm->len) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_ppm_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_ppm_t *ppm = &ms->parms.ppm;\n\tfprintf(out, \"ind=%d; len = %d;\\n\", ppm->ind, ppm->len);\n\tif (ppm->len > 0) {\n\t\tfprintf(out, \"data =\\n\");\n\t\tjas_memdump(out, ppm->data, ppm->len);\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* PPT marker segment operations.\n\\******************************************************************************/\n\nstatic void jpc_ppt_destroyparms(jpc_ms_t *ms)\n{\n\tjpc_ppt_t *ppt = &ms->parms.ppt;\n\tif (ppt->data) {\n\t\tjas_free(ppt->data);\n\t}\n}\n\nstatic int jpc_ppt_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_ppt_t *ppt = &ms->parms.ppt;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tppt->data = 0;\n\n\tif (ms->len < 1) {\n\t\tgoto error;\n\t}\n\tif (jpc_getuint8(in, &ppt->ind)) {\n\t\tgoto error;\n\t}\n\tppt->len = ms->len - 1;\n\tif (ppt->len > 0) {\n\t\tif (!(ppt->data = jas_malloc(ppt->len))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (jas_stream_read(in, (char *) ppt->data, ppt->len) != JAS_CAST(int, ppt->len)) {\n\t\t\tgoto error;\n\t\t}\n\t} else {\n\t\tppt->data = 0;\n\t}\n\treturn 0;\n\nerror:\n\tjpc_ppt_destroyparms(ms);\n\treturn -1;\n}\n\nstatic int jpc_ppt_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_ppt_t *ppt = &ms->parms.ppt;\n\n\t/* Eliminate compiler warning about unused variable. */\n\tcstate = 0;\n\n\tif (jpc_putuint8(out, ppt->ind)) {\n\t\treturn -1;\n\t}\n\tif (jas_stream_write(out, (char *) ppt->data, ppt->len) != JAS_CAST(int, ppt->len)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_ppt_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_ppt_t *ppt = &ms->parms.ppt;\n\tfprintf(out, \"ind=%d; len = %d;\\n\", ppt->ind, ppt->len);\n\tif (ppt->len > 0) {\n\t\tfprintf(out, \"data =\\n\");\n\t\tjas_memdump(out, ppt->data, ppt->len);\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* POC marker segment operations.\n\\******************************************************************************/\n\nstatic void jpc_poc_destroyparms(jpc_ms_t *ms)\n{\n\tjpc_poc_t *poc = &ms->parms.poc;\n\tif (poc->pchgs) {\n\t\tjas_free(poc->pchgs);\n\t}\n}\n\nstatic int jpc_poc_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_poc_t *poc = &ms->parms.poc;\n\tjpc_pocpchg_t *pchg;\n\tint pchgno;\n\tuint_fast8_t tmp;\n\tpoc->numpchgs = (cstate->numcomps > 256) ? (ms->len / 9) :\n\t  (ms->len / 7);\n\tif (!(poc->pchgs = jas_alloc2(poc->numpchgs, sizeof(jpc_pocpchg_t)))) {\n\t\tgoto error;\n\t}\n\tfor (pchgno = 0, pchg = poc->pchgs; pchgno < poc->numpchgs; ++pchgno,\n\t  ++pchg) {\n\t\tif (jpc_getuint8(in, &pchg->rlvlnostart)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (cstate->numcomps > 256) {\n\t\t\tif (jpc_getuint16(in, &pchg->compnostart)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t} else {\n\t\t\tif (jpc_getuint8(in, &tmp)) {\n\t\t\t\tgoto error;\n\t\t\t};\n\t\t\tpchg->compnostart = tmp;\n\t\t}\n\t\tif (jpc_getuint16(in, &pchg->lyrnoend) ||\n\t\t  jpc_getuint8(in, &pchg->rlvlnoend)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (cstate->numcomps > 256) {\n\t\t\tif (jpc_getuint16(in, &pchg->compnoend)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t} else {\n\t\t\tif (jpc_getuint8(in, &tmp)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tpchg->compnoend = tmp;\n\t\t}\n\t\tif (jpc_getuint8(in, &pchg->prgord)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (pchg->rlvlnostart > pchg->rlvlnoend ||\n\t\t  pchg->compnostart > pchg->compnoend) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\treturn 0;\n\nerror:\n\tjpc_poc_destroyparms(ms);\n\treturn -1;\n}\n\nstatic int jpc_poc_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_poc_t *poc = &ms->parms.poc;\n\tjpc_pocpchg_t *pchg;\n\tint pchgno;\n\tfor (pchgno = 0, pchg = poc->pchgs; pchgno < poc->numpchgs; ++pchgno,\n\t  ++pchg) {\n\t\tif (jpc_putuint8(out, pchg->rlvlnostart) ||\n\t\t  ((cstate->numcomps > 256) ?\n\t\t  jpc_putuint16(out, pchg->compnostart) :\n\t\t  jpc_putuint8(out, pchg->compnostart)) ||\n\t\t  jpc_putuint16(out, pchg->lyrnoend) ||\n\t\t  jpc_putuint8(out, pchg->rlvlnoend) ||\n\t\t  ((cstate->numcomps > 256) ?\n\t\t  jpc_putuint16(out, pchg->compnoend) :\n\t\t  jpc_putuint8(out, pchg->compnoend)) ||\n\t\t  jpc_putuint8(out, pchg->prgord)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jpc_poc_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_poc_t *poc = &ms->parms.poc;\n\tjpc_pocpchg_t *pchg;\n\tint pchgno;\n\tfor (pchgno = 0, pchg = poc->pchgs; pchgno < poc->numpchgs;\n\t  ++pchgno, ++pchg) {\n\t\tfprintf(out, \"po[%d] = %d; \", pchgno, pchg->prgord);\n\t\tfprintf(out, \"cs[%d] = %d; ce[%d] = %d; \",\n\t\t  pchgno, pchg->compnostart, pchgno, pchg->compnoend);\n\t\tfprintf(out, \"rs[%d] = %d; re[%d] = %d; \",\n\t\t  pchgno, pchg->rlvlnostart, pchgno, pchg->rlvlnoend);\n\t\tfprintf(out, \"le[%d] = %d\\n\", pchgno, pchg->lyrnoend);\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* CRG marker segment operations.\n\\******************************************************************************/\n\nstatic void jpc_crg_destroyparms(jpc_ms_t *ms)\n{\n\tjpc_crg_t *crg = &ms->parms.crg;\n\tif (crg->comps) {\n\t\tjas_free(crg->comps);\n\t}\n}\n\nstatic int jpc_crg_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_crg_t *crg = &ms->parms.crg;\n\tjpc_crgcomp_t *comp;\n\tuint_fast16_t compno;\n\tcrg->numcomps = cstate->numcomps;\n\tif (!(crg->comps = jas_alloc2(cstate->numcomps, sizeof(uint_fast16_t)))) {\n\t\treturn -1;\n\t}\n\tfor (compno = 0, comp = crg->comps; compno < cstate->numcomps;\n\t  ++compno, ++comp) {\n\t\tif (jpc_getuint16(in, &comp->hoff) ||\n\t\t  jpc_getuint16(in, &comp->voff)) {\n\t\t\tjpc_crg_destroyparms(ms);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jpc_crg_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_crg_t *crg = &ms->parms.crg;\n\tint compno;\n\tjpc_crgcomp_t *comp;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tfor (compno = 0, comp = crg->comps; compno < crg->numcomps; ++compno,\n\t  ++comp) {\n\t\tif (jpc_putuint16(out, comp->hoff) ||\n\t\t  jpc_putuint16(out, comp->voff)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jpc_crg_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_crg_t *crg = &ms->parms.crg;\n\tint compno;\n\tjpc_crgcomp_t *comp;\n\tfor (compno = 0, comp = crg->comps; compno < crg->numcomps; ++compno,\n\t  ++comp) {\n\t\tfprintf(out, \"hoff[%d] = %d; voff[%d] = %d\\n\", compno,\n\t\t  comp->hoff, compno, comp->voff);\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Operations for COM marker segment.\n\\******************************************************************************/\n\nstatic void jpc_com_destroyparms(jpc_ms_t *ms)\n{\n\tjpc_com_t *com = &ms->parms.com;\n\tif (com->data) {\n\t\tjas_free(com->data);\n\t}\n}\n\nstatic int jpc_com_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_com_t *com = &ms->parms.com;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tif (jpc_getuint16(in, &com->regid)) {\n\t\treturn -1;\n\t}\n\tcom->len = ms->len - 2;\n\tif (com->len > 0) {\n\t\tif (!(com->data = jas_malloc(com->len))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (jas_stream_read(in, com->data, com->len) != JAS_CAST(int, com->len)) {\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tcom->data = 0;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_com_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_com_t *com = &ms->parms.com;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tif (jpc_putuint16(out, com->regid)) {\n\t\treturn -1;\n\t}\n\tif (jas_stream_write(out, com->data, com->len) != JAS_CAST(int, com->len)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_com_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_com_t *com = &ms->parms.com;\n\tunsigned int i;\n\tint printable;\n\tfprintf(out, \"regid = %d;\\n\", com->regid);\n\tprintable = 1;\n\tfor (i = 0; i < com->len; ++i) {\n\t\tif (!isprint(com->data[i])) {\n\t\t\tprintable = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (printable) {\n\t\tfprintf(out, \"data = \");\n\t\tfwrite(com->data, sizeof(char), com->len, out);\n\t\tfprintf(out, \"\\n\");\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Operations for unknown types of marker segments.\n\\******************************************************************************/\n\nstatic void jpc_unk_destroyparms(jpc_ms_t *ms)\n{\n\tjpc_unk_t *unk = &ms->parms.unk;\n\tif (unk->data) {\n\t\tjas_free(unk->data);\n\t}\n}\n\nstatic int jpc_unk_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_unk_t *unk = &ms->parms.unk;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tif (ms->len > 0) {\n\t\tif (!(unk->data = jas_alloc2(ms->len, sizeof(unsigned char)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (jas_stream_read(in, (char *) unk->data, ms->len) != JAS_CAST(int, ms->len)) {\n\t\t\tjas_free(unk->data);\n\t\t\treturn -1;\n\t\t}\n\t\tunk->len = ms->len;\n\t} else {\n\t\tunk->data = 0;\n\t\tunk->len = 0;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_unk_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\tms = 0;\n\tout = 0;\n\n\t/* If this function is called, we are trying to write an unsupported\n\t  type of marker segment.  Return with an error indication.  */\n\treturn -1;\n}\n\nstatic int jpc_unk_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tunsigned int i;\n\tjpc_unk_t *unk = &ms->parms.unk;\n\tfor (i = 0; i < unk->len; ++i) {\n\t\tfprintf(out, \"%02x \", unk->data[i]);\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Primitive I/O operations.\n\\******************************************************************************/\n\nint jpc_getuint8(jas_stream_t *in, uint_fast8_t *val)\n{\n\tint c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tif (val) {\n\t\t*val = c;\n\t}\n\treturn 0;\n}\n\nint jpc_putuint8(jas_stream_t *out, uint_fast8_t val)\n{\n\tif (jas_stream_putc(out, val & 0xff) == EOF) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nint jpc_getuint16(jas_stream_t *in, uint_fast16_t *val)\n{\n\tuint_fast16_t v;\n\tint c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = (v << 8) | c;\n\tif (val) {\n\t\t*val = v;\n\t}\n\treturn 0;\n}\n\nint jpc_putuint16(jas_stream_t *out, uint_fast16_t val)\n{\n\tif (jas_stream_putc(out, (val >> 8) & 0xff) == EOF ||\n\t  jas_stream_putc(out, val & 0xff) == EOF) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nint jpc_getuint32(jas_stream_t *in, uint_fast32_t *val)\n{\n\tuint_fast32_t v;\n\tint c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = (v << 8) | c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = (v << 8) | c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = (v << 8) | c;\n\tif (val) {\n\t\t*val = v;\n\t}\n\treturn 0;\n}\n\nint jpc_putuint32(jas_stream_t *out, uint_fast32_t val)\n{\n\tif (jas_stream_putc(out, (val >> 24) & 0xff) == EOF ||\n\t  jas_stream_putc(out, (val >> 16) & 0xff) == EOF ||\n\t  jas_stream_putc(out, (val >> 8) & 0xff) == EOF ||\n\t  jas_stream_putc(out, val & 0xff) == EOF) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Miscellany\n\\******************************************************************************/\n\nstatic jpc_mstabent_t *jpc_mstab_lookup(int id)\n{\n\tjpc_mstabent_t *mstabent;\n\tfor (mstabent = jpc_mstab;; ++mstabent) {\n\t\tif (mstabent->id == id || mstabent->id < 0) {\n\t\t\treturn mstabent;\n\t\t}\n\t}\n\tassert(0);\n\treturn 0;\n}\n\nint jpc_validate(jas_stream_t *in)\n{\n\tint n;\n\tint i;\n\tunsigned char buf[2];\n\n\tassert(JAS_STREAM_MAXPUTBACK >= 2);\n\n\tif ((n = jas_stream_read(in, (char *) buf, 2)) < 0) {\n\t\treturn -1;\n\t}\n\tfor (i = n - 1; i >= 0; --i) {\n\t\tif (jas_stream_ungetc(in, buf[i]) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (n < 2) {\n\t\treturn -1;\n\t}\n\tif (buf[0] == (JPC_MS_SOC >> 8) && buf[1] == (JPC_MS_SOC & 0xff)) {\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n\nint jpc_getdata(jas_stream_t *in, jas_stream_t *out, long len)\n{\n\treturn jas_stream_copy(out, in, len);\n}\n\nint jpc_putdata(jas_stream_t *out, jas_stream_t *in, long len)\n{\n\treturn jas_stream_copy(out, in, len);\n}\n"], "fixing_code": ["/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2002 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * JPEG-2000 Code Stream Library\n *\n * $Id$\n */\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <stdlib.h>\n#include <assert.h>\n#include <ctype.h>\n\n#include \"jasper/jas_malloc.h\"\n#include \"jasper/jas_debug.h\"\n\n#include \"jpc_cs.h\"\n\n/******************************************************************************\\\n* Types.\n\\******************************************************************************/\n\n/* Marker segment table entry. */\ntypedef struct {\n\tint id;\n\tchar *name;\n\tjpc_msops_t ops;\n} jpc_mstabent_t;\n\n/******************************************************************************\\\n* Local prototypes.\n\\******************************************************************************/\n\nstatic jpc_mstabent_t *jpc_mstab_lookup(int id);\n\nstatic int jpc_poc_dumpparms(jpc_ms_t *ms, FILE *out);\nstatic int jpc_poc_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\nstatic int jpc_poc_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\nstatic void jpc_poc_destroyparms(jpc_ms_t *ms);\n\nstatic int jpc_unk_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\nstatic int jpc_sot_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\nstatic int jpc_siz_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\nstatic int jpc_cod_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\nstatic int jpc_coc_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\nstatic int jpc_qcd_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\nstatic int jpc_qcc_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\nstatic int jpc_rgn_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\nstatic int jpc_sop_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\nstatic int jpc_ppm_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\nstatic int jpc_ppt_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\nstatic int jpc_crg_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\nstatic int jpc_com_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\n\nstatic int jpc_sot_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\nstatic int jpc_siz_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\nstatic int jpc_cod_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\nstatic int jpc_coc_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\nstatic int jpc_qcd_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\nstatic int jpc_qcc_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\nstatic int jpc_rgn_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\nstatic int jpc_unk_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\nstatic int jpc_sop_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\nstatic int jpc_ppm_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\nstatic int jpc_ppt_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\nstatic int jpc_crg_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\nstatic int jpc_com_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\n\nstatic int jpc_sot_dumpparms(jpc_ms_t *ms, FILE *out);\nstatic int jpc_siz_dumpparms(jpc_ms_t *ms, FILE *out);\nstatic int jpc_cod_dumpparms(jpc_ms_t *ms, FILE *out);\nstatic int jpc_coc_dumpparms(jpc_ms_t *ms, FILE *out);\nstatic int jpc_qcd_dumpparms(jpc_ms_t *ms, FILE *out);\nstatic int jpc_qcc_dumpparms(jpc_ms_t *ms, FILE *out);\nstatic int jpc_rgn_dumpparms(jpc_ms_t *ms, FILE *out);\nstatic int jpc_unk_dumpparms(jpc_ms_t *ms, FILE *out);\nstatic int jpc_sop_dumpparms(jpc_ms_t *ms, FILE *out);\nstatic int jpc_ppm_dumpparms(jpc_ms_t *ms, FILE *out);\nstatic int jpc_ppt_dumpparms(jpc_ms_t *ms, FILE *out);\nstatic int jpc_crg_dumpparms(jpc_ms_t *ms, FILE *out);\nstatic int jpc_com_dumpparms(jpc_ms_t *ms, FILE *out);\n\nstatic void jpc_siz_destroyparms(jpc_ms_t *ms);\nstatic void jpc_qcd_destroyparms(jpc_ms_t *ms);\nstatic void jpc_qcc_destroyparms(jpc_ms_t *ms);\nstatic void jpc_cod_destroyparms(jpc_ms_t *ms);\nstatic void jpc_coc_destroyparms(jpc_ms_t *ms);\nstatic void jpc_unk_destroyparms(jpc_ms_t *ms);\nstatic void jpc_ppm_destroyparms(jpc_ms_t *ms);\nstatic void jpc_ppt_destroyparms(jpc_ms_t *ms);\nstatic void jpc_crg_destroyparms(jpc_ms_t *ms);\nstatic void jpc_com_destroyparms(jpc_ms_t *ms);\n\nstatic void jpc_qcx_destroycompparms(jpc_qcxcp_t *compparms);\nstatic int jpc_qcx_getcompparms(jpc_qcxcp_t *compparms, jpc_cstate_t *cstate,\n  jas_stream_t *in, uint_fast16_t len);\nstatic int jpc_qcx_putcompparms(jpc_qcxcp_t *compparms, jpc_cstate_t *cstate,\n  jas_stream_t *out);\nstatic void jpc_cox_destroycompparms(jpc_coxcp_t *compparms);\nstatic int jpc_cox_getcompparms(jpc_ms_t *ms, jpc_cstate_t *cstate,\n  jas_stream_t *in, int prtflag, jpc_coxcp_t *compparms);\nstatic int jpc_cox_putcompparms(jpc_ms_t *ms, jpc_cstate_t *cstate,\n  jas_stream_t *out, int prtflag, jpc_coxcp_t *compparms);\n\n/******************************************************************************\\\n* Global data.\n\\******************************************************************************/\n\nstatic jpc_mstabent_t jpc_mstab[] = {\n\t{JPC_MS_SOC, \"SOC\", {0, 0, 0, 0}},\n\t{JPC_MS_SOT, \"SOT\", {0, jpc_sot_getparms, jpc_sot_putparms,\n\t  jpc_sot_dumpparms}},\n\t{JPC_MS_SOD, \"SOD\", {0, 0, 0, 0}},\n\t{JPC_MS_EOC, \"EOC\", {0, 0, 0, 0}},\n\t{JPC_MS_SIZ, \"SIZ\", {jpc_siz_destroyparms, jpc_siz_getparms,\n\t  jpc_siz_putparms, jpc_siz_dumpparms}},\n\t{JPC_MS_COD, \"COD\", {jpc_cod_destroyparms, jpc_cod_getparms,\n\t  jpc_cod_putparms, jpc_cod_dumpparms}},\n\t{JPC_MS_COC, \"COC\", {jpc_coc_destroyparms, jpc_coc_getparms,\n\t  jpc_coc_putparms, jpc_coc_dumpparms}},\n\t{JPC_MS_RGN, \"RGN\", {0, jpc_rgn_getparms, jpc_rgn_putparms,\n\t  jpc_rgn_dumpparms}},\n\t{JPC_MS_QCD, \"QCD\", {jpc_qcd_destroyparms, jpc_qcd_getparms,\n\t  jpc_qcd_putparms, jpc_qcd_dumpparms}},\n\t{JPC_MS_QCC, \"QCC\", {jpc_qcc_destroyparms, jpc_qcc_getparms,\n\t  jpc_qcc_putparms, jpc_qcc_dumpparms}},\n\t{JPC_MS_POC, \"POC\", {jpc_poc_destroyparms, jpc_poc_getparms,\n\t  jpc_poc_putparms, jpc_poc_dumpparms}},\n\t{JPC_MS_TLM, \"TLM\", {0, jpc_unk_getparms, jpc_unk_putparms, 0}},\n\t{JPC_MS_PLM, \"PLM\", {0, jpc_unk_getparms, jpc_unk_putparms, 0}},\n\t{JPC_MS_PPM, \"PPM\", {jpc_ppm_destroyparms, jpc_ppm_getparms,\n\t  jpc_ppm_putparms, jpc_ppm_dumpparms}},\n\t{JPC_MS_PPT, \"PPT\", {jpc_ppt_destroyparms, jpc_ppt_getparms,\n\t  jpc_ppt_putparms, jpc_ppt_dumpparms}},\n\t{JPC_MS_SOP, \"SOP\", {0, jpc_sop_getparms, jpc_sop_putparms,\n\t  jpc_sop_dumpparms}},\n\t{JPC_MS_EPH, \"EPH\", {0, 0, 0, 0}},\n\t{JPC_MS_CRG, \"CRG\", {0, jpc_crg_getparms, jpc_crg_putparms,\n\t  jpc_crg_dumpparms}},\n\t{JPC_MS_COM, \"COM\", {jpc_com_destroyparms, jpc_com_getparms,\n\t  jpc_com_putparms, jpc_com_dumpparms}},\n\t{-1, \"UNKNOWN\",  {jpc_unk_destroyparms, jpc_unk_getparms,\n\t  jpc_unk_putparms, jpc_unk_dumpparms}}\n};\n\n/******************************************************************************\\\n* Code stream manipulation functions.\n\\******************************************************************************/\n\n/* Create a code stream state object. */\njpc_cstate_t *jpc_cstate_create()\n{\n\tjpc_cstate_t *cstate;\n\tif (!(cstate = jas_malloc(sizeof(jpc_cstate_t)))) {\n\t\treturn 0;\n\t}\n\tcstate->numcomps = 0;\n\treturn cstate;\n}\n\n/* Destroy a code stream state object. */\nvoid jpc_cstate_destroy(jpc_cstate_t *cstate)\n{\n\tjas_free(cstate);\n}\n\n/* Read a marker segment from a stream. */\njpc_ms_t *jpc_getms(jas_stream_t *in, jpc_cstate_t *cstate)\n{\n\tjpc_ms_t *ms;\n\tjpc_mstabent_t *mstabent;\n\tjas_stream_t *tmpstream;\n\n\tif (!(ms = jpc_ms_create(0))) {\n\t\treturn 0;\n\t}\n\n\t/* Get the marker type. */\n\tif (jpc_getuint16(in, &ms->id) || ms->id < JPC_MS_MIN ||\n\t  ms->id > JPC_MS_MAX) {\n\t\tjpc_ms_destroy(ms);\n\t\treturn 0;\n\t}\n\n\tmstabent = jpc_mstab_lookup(ms->id);\n\tms->ops = &mstabent->ops;\n\n\t/* Get the marker segment length and parameters if present. */\n\t/* Note: It is tacitly assumed that a marker segment cannot have\n\t  parameters unless it has a length field.  That is, there cannot\n\t  be a parameters field without a length field and vice versa. */\n\tif (JPC_MS_HASPARMS(ms->id)) {\n\t\t/* Get the length of the marker segment. */\n\t\tif (jpc_getuint16(in, &ms->len) || ms->len < 3) {\n\t\t\tjpc_ms_destroy(ms);\n\t\t\treturn 0;\n\t\t}\n\t\t/* Calculate the length of the marker segment parameters. */\n\t\tms->len -= 2;\n\t\t/* Create and prepare a temporary memory stream from which to\n\t\t  read the marker segment parameters. */\n\t\t/* Note: This approach provides a simple way of ensuring that\n\t\t  we never read beyond the end of the marker segment (even if\n\t\t  the marker segment length is errantly set too small). */\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\t\tjpc_ms_destroy(ms);\n\t\t\treturn 0;\n\t\t}\n\t\tif (jas_stream_copy(tmpstream, in, ms->len) ||\n\t\t  jas_stream_seek(tmpstream, 0, SEEK_SET) < 0) {\n\t\t\tjas_stream_close(tmpstream);\n\t\t\tjpc_ms_destroy(ms);\n\t\t\treturn 0;\n\t\t}\n\t\t/* Get the marker segment parameters. */\n\t\tif ((*ms->ops->getparms)(ms, cstate, tmpstream)) {\n\t\t\tms->ops = 0;\n\t\t\tjpc_ms_destroy(ms);\n\t\t\tjas_stream_close(tmpstream);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (jas_getdbglevel() > 0) {\n\t\t\tjpc_ms_dump(ms, stderr);\n\t\t}\n\n\t\tif (JAS_CAST(ulong, jas_stream_tell(tmpstream)) != ms->len) {\n\t\t\tjas_eprintf(\"warning: trailing garbage in marker segment (%ld bytes)\\n\",\n\t\t\t  ms->len - jas_stream_tell(tmpstream));\n\t\t}\n\n\t\t/* Close the temporary stream. */\n\t\tjas_stream_close(tmpstream);\n\n\t} else {\n\t\t/* There are no marker segment parameters. */\n\t\tms->len = 0;\n\n\t\tif (jas_getdbglevel() > 0) {\n\t\t\tjpc_ms_dump(ms, stderr);\n\t\t}\n\t}\n\n\t/* Update the code stream state information based on the type of\n\t  marker segment read. */\n\t/* Note: This is a bit of a hack, but I'm not going to define another\n\t  type of virtual function for this one special case. */\n\tif (ms->id == JPC_MS_SIZ) {\n\t\tcstate->numcomps = ms->parms.siz.numcomps;\n\t}\n\n\treturn ms;\n}\n\n/* Write a marker segment to a stream. */\nint jpc_putms(jas_stream_t *out, jpc_cstate_t *cstate, jpc_ms_t *ms)\n{\n\tjas_stream_t *tmpstream;\n\tint len;\n\n\t/* Output the marker segment type. */\n\tif (jpc_putuint16(out, ms->id)) {\n\t\treturn -1;\n\t}\n\n\t/* Output the marker segment length and parameters if necessary. */\n\tif (ms->ops->putparms) {\n\t\t/* Create a temporary stream in which to buffer the\n\t\t  parameter data. */\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif ((*ms->ops->putparms)(ms, cstate, tmpstream)) {\n\t\t\tjas_stream_close(tmpstream);\n\t\t\treturn -1;\n\t\t}\n\t\t/* Get the number of bytes of parameter data written. */\n\t\tif ((len = jas_stream_tell(tmpstream)) < 0) {\n\t\t\tjas_stream_close(tmpstream);\n\t\t\treturn -1;\n\t\t}\n\t\tms->len = len;\n\t\t/* Write the marker segment length and parameter data to\n\t\t  the output stream. */\n\t\tif (jas_stream_seek(tmpstream, 0, SEEK_SET) < 0 ||\n\t\t  jpc_putuint16(out, ms->len + 2) ||\n\t\t  jas_stream_copy(out, tmpstream, ms->len) < 0) {\n\t\t\tjas_stream_close(tmpstream);\n\t\t\treturn -1;\n\t\t}\n\t\t/* Close the temporary stream. */\n\t\tjas_stream_close(tmpstream);\n\t}\n\n\t/* This is a bit of a hack, but I'm not going to define another\n\t  type of virtual function for this one special case. */\n\tif (ms->id == JPC_MS_SIZ) {\n\t\tcstate->numcomps = ms->parms.siz.numcomps;\n\t}\n\n\tif (jas_getdbglevel() > 0) {\n\t\tjpc_ms_dump(ms, stderr);\n\t}\n\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Marker segment operations.\n\\******************************************************************************/\n\n/* Create a marker segment of the specified type. */\njpc_ms_t *jpc_ms_create(int type)\n{\n\tjpc_ms_t *ms;\n\tjpc_mstabent_t *mstabent;\n\n\tif (!(ms = jas_malloc(sizeof(jpc_ms_t)))) {\n\t\treturn 0;\n\t}\n\tms->id = type;\n\tms->len = 0;\n\tmstabent = jpc_mstab_lookup(ms->id);\n\tms->ops = &mstabent->ops;\n\tmemset(&ms->parms, 0, sizeof(jpc_msparms_t));\n\treturn ms;\n}\n\n/* Destroy a marker segment. */\nvoid jpc_ms_destroy(jpc_ms_t *ms)\n{\n\tif (ms->ops && ms->ops->destroyparms) {\n\t\t(*ms->ops->destroyparms)(ms);\n\t}\n\tjas_free(ms);\n}\n\n/* Dump a marker segment to a stream for debugging. */\nvoid jpc_ms_dump(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_mstabent_t *mstabent;\n\tmstabent = jpc_mstab_lookup(ms->id);\n\tfprintf(out, \"type = 0x%04x (%s);\", ms->id, mstabent->name);\n\tif (JPC_MS_HASPARMS(ms->id)) {\n\t\tfprintf(out, \" len = %d;\", ms->len + 2);\n\t\tif (ms->ops->dumpparms) {\n\t\t\t(*ms->ops->dumpparms)(ms, out);\n\t\t} else {\n\t\t\tfprintf(out, \"\\n\");\n\t\t}\n\t} else {\n\t\tfprintf(out, \"\\n\");\n\t}\n}\n\n/******************************************************************************\\\n* SOT marker segment operations.\n\\******************************************************************************/\n\nstatic int jpc_sot_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_sot_t *sot = &ms->parms.sot;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tif (jpc_getuint16(in, &sot->tileno) ||\n\t  jpc_getuint32(in, &sot->len) ||\n\t  jpc_getuint8(in, &sot->partno) ||\n\t  jpc_getuint8(in, &sot->numparts)) {\n\t\treturn -1;\n\t}\n\tif (jas_stream_eof(in)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_sot_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_sot_t *sot = &ms->parms.sot;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tif (jpc_putuint16(out, sot->tileno) ||\n\t  jpc_putuint32(out, sot->len) ||\n\t  jpc_putuint8(out, sot->partno) ||\n\t  jpc_putuint8(out, sot->numparts)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_sot_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_sot_t *sot = &ms->parms.sot;\n\tfprintf(out, \"tileno = %d; len = %d; partno = %d; numparts = %d\\n\",\n\t  sot->tileno, sot->len, sot->partno, sot->numparts);\n\treturn 0;\n}\n\n/******************************************************************************\\\n* SIZ marker segment operations.\n\\******************************************************************************/\n\nstatic void jpc_siz_destroyparms(jpc_ms_t *ms)\n{\n\tjpc_siz_t *siz = &ms->parms.siz;\n\tif (siz->comps) {\n\t\tjas_free(siz->comps);\n\t}\n}\n\nstatic int jpc_siz_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate,\n  jas_stream_t *in)\n{\n\tjpc_siz_t *siz = &ms->parms.siz;\n\tunsigned int i;\n\tuint_fast8_t tmp;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tif (jpc_getuint16(in, &siz->caps) ||\n\t  jpc_getuint32(in, &siz->width) ||\n\t  jpc_getuint32(in, &siz->height) ||\n\t  jpc_getuint32(in, &siz->xoff) ||\n\t  jpc_getuint32(in, &siz->yoff) ||\n\t  jpc_getuint32(in, &siz->tilewidth) ||\n\t  jpc_getuint32(in, &siz->tileheight) ||\n\t  jpc_getuint32(in, &siz->tilexoff) ||\n\t  jpc_getuint32(in, &siz->tileyoff) ||\n\t  jpc_getuint16(in, &siz->numcomps)) {\n\t\treturn -1;\n\t}\n\tif (!siz->width || !siz->height || !siz->tilewidth ||\n\t  !siz->tileheight || !siz->numcomps) {\n\t\treturn -1;\n\t}\n\tif (!(siz->comps = jas_alloc2(siz->numcomps, sizeof(jpc_sizcomp_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < siz->numcomps; ++i) {\n\t\tif (jpc_getuint8(in, &tmp) ||\n\t\t  jpc_getuint8(in, &siz->comps[i].hsamp) ||\n\t\t  jpc_getuint8(in, &siz->comps[i].vsamp)) {\n\t\t\tjas_free(siz->comps);\n\t\t\treturn -1;\n\t\t}\n\t\tif (siz->comps[i].hsamp == 0 || siz->comps[i].hsamp > 255) {\n\t\t\tjas_eprintf(\"invalid XRsiz value %d\\n\", siz->comps[i].hsamp);\n\t\t\tjas_free(siz->comps);\n\t\t\treturn -1;\n\t\t}\n\t\tif (siz->comps[i].vsamp == 0 || siz->comps[i].vsamp > 255) {\n\t\t\tjas_eprintf(\"invalid YRsiz value %d\\n\", siz->comps[i].vsamp);\n\t\t\tjas_free(siz->comps);\n\t\t\treturn -1;\n\t\t}\n\t\tsiz->comps[i].sgnd = (tmp >> 7) & 1;\n\t\tsiz->comps[i].prec = (tmp & 0x7f) + 1;\n\t}\n\tif (jas_stream_eof(in)) {\n\t\tjas_free(siz->comps);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_siz_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_siz_t *siz = &ms->parms.siz;\n\tunsigned int i;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tassert(siz->width && siz->height && siz->tilewidth &&\n\t  siz->tileheight && siz->numcomps);\n\tif (jpc_putuint16(out, siz->caps) ||\n\t  jpc_putuint32(out, siz->width) ||\n\t  jpc_putuint32(out, siz->height) ||\n\t  jpc_putuint32(out, siz->xoff) ||\n\t  jpc_putuint32(out, siz->yoff) ||\n\t  jpc_putuint32(out, siz->tilewidth) ||\n\t  jpc_putuint32(out, siz->tileheight) ||\n\t  jpc_putuint32(out, siz->tilexoff) ||\n\t  jpc_putuint32(out, siz->tileyoff) ||\n\t  jpc_putuint16(out, siz->numcomps)) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < siz->numcomps; ++i) {\n\t\tif (jpc_putuint8(out, ((siz->comps[i].sgnd & 1) << 7) |\n\t\t  ((siz->comps[i].prec - 1) & 0x7f)) ||\n\t\t  jpc_putuint8(out, siz->comps[i].hsamp) ||\n\t\t  jpc_putuint8(out, siz->comps[i].vsamp)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jpc_siz_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_siz_t *siz = &ms->parms.siz;\n\tunsigned int i;\n\tfprintf(out, \"caps = 0x%02x;\\n\", siz->caps);\n\tfprintf(out, \"width = %d; height = %d; xoff = %d; yoff = %d;\\n\",\n\t  siz->width, siz->height, siz->xoff, siz->yoff);\n\tfprintf(out, \"tilewidth = %d; tileheight = %d; tilexoff = %d; \"\n\t  \"tileyoff = %d;\\n\", siz->tilewidth, siz->tileheight, siz->tilexoff,\n\t  siz->tileyoff);\n\tfor (i = 0; i < siz->numcomps; ++i) {\n\t\tfprintf(out, \"prec[%d] = %d; sgnd[%d] = %d; hsamp[%d] = %d; \"\n\t\t  \"vsamp[%d] = %d\\n\", i, siz->comps[i].prec, i,\n\t\t  siz->comps[i].sgnd, i, siz->comps[i].hsamp, i,\n\t\t  siz->comps[i].vsamp);\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* COD marker segment operations.\n\\******************************************************************************/\n\nstatic void jpc_cod_destroyparms(jpc_ms_t *ms)\n{\n\tjpc_cod_t *cod = &ms->parms.cod;\n\tjpc_cox_destroycompparms(&cod->compparms);\n}\n\nstatic int jpc_cod_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_cod_t *cod = &ms->parms.cod;\n\tif (jpc_getuint8(in, &cod->csty)) {\n\t\treturn -1;\n\t}\n\tif (jpc_getuint8(in, &cod->prg) ||\n\t  jpc_getuint16(in, &cod->numlyrs) ||\n\t  jpc_getuint8(in, &cod->mctrans)) {\n\t\treturn -1;\n\t}\n\tif (jpc_cox_getcompparms(ms, cstate, in,\n\t  (cod->csty & JPC_COX_PRT) != 0, &cod->compparms)) {\n\t\treturn -1;\n\t}\n\tif (jas_stream_eof(in)) {\n\t\tjpc_cod_destroyparms(ms);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_cod_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_cod_t *cod = &ms->parms.cod;\n\tassert(cod->numlyrs > 0 && cod->compparms.numdlvls <= 32);\n\tassert(cod->compparms.numdlvls == cod->compparms.numrlvls - 1);\n\tif (jpc_putuint8(out, cod->compparms.csty) ||\n\t  jpc_putuint8(out, cod->prg) ||\n\t  jpc_putuint16(out, cod->numlyrs) ||\n\t  jpc_putuint8(out, cod->mctrans)) {\n\t\treturn -1;\n\t}\n\tif (jpc_cox_putcompparms(ms, cstate, out,\n\t  (cod->csty & JPC_COX_PRT) != 0, &cod->compparms)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_cod_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_cod_t *cod = &ms->parms.cod;\n\tint i;\n\tfprintf(out, \"csty = 0x%02x;\\n\", cod->compparms.csty);\n\tfprintf(out, \"numdlvls = %d; qmfbid = %d; mctrans = %d\\n\",\n\t  cod->compparms.numdlvls, cod->compparms.qmfbid, cod->mctrans);\n\tfprintf(out, \"prg = %d; numlyrs = %d;\\n\",\n\t  cod->prg, cod->numlyrs);\n\tfprintf(out, \"cblkwidthval = %d; cblkheightval = %d; \"\n\t  \"cblksty = 0x%02x;\\n\", cod->compparms.cblkwidthval, cod->compparms.cblkheightval,\n\t  cod->compparms.cblksty);\n\tif (cod->csty & JPC_COX_PRT) {\n\t\tfor (i = 0; i < cod->compparms.numrlvls; ++i) {\n\t\t\tjas_eprintf(\"prcwidth[%d] = %d, prcheight[%d] = %d\\n\",\n\t\t\t  i, cod->compparms.rlvls[i].parwidthval,\n\t\t\t  i, cod->compparms.rlvls[i].parheightval);\n\t\t}\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* COC marker segment operations.\n\\******************************************************************************/\n\nstatic void jpc_coc_destroyparms(jpc_ms_t *ms)\n{\n\tjpc_coc_t *coc = &ms->parms.coc;\n\tjpc_cox_destroycompparms(&coc->compparms);\n}\n\nstatic int jpc_coc_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_coc_t *coc = &ms->parms.coc;\n\tuint_fast8_t tmp;\n\tif (cstate->numcomps <= 256) {\n\t\tif (jpc_getuint8(in, &tmp)) {\n\t\t\treturn -1;\n\t\t}\n\t\tcoc->compno = tmp;\n\t} else {\n\t\tif (jpc_getuint16(in, &coc->compno)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (jpc_getuint8(in, &coc->compparms.csty)) {\n\t\treturn -1;\n\t}\n\tif (jpc_cox_getcompparms(ms, cstate, in,\n\t  (coc->compparms.csty & JPC_COX_PRT) != 0, &coc->compparms)) {\n\t\treturn -1;\n\t}\n\tif (jas_stream_eof(in)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_coc_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_coc_t *coc = &ms->parms.coc;\n\tassert(coc->compparms.numdlvls <= 32);\n\tif (cstate->numcomps <= 256) {\n\t\tif (jpc_putuint8(out, coc->compno)) {\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tif (jpc_putuint16(out, coc->compno)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (jpc_putuint8(out, coc->compparms.csty)) {\n\t\treturn -1;\n\t}\n\tif (jpc_cox_putcompparms(ms, cstate, out,\n\t  (coc->compparms.csty & JPC_COX_PRT) != 0, &coc->compparms)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_coc_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_coc_t *coc = &ms->parms.coc;\n\tfprintf(out, \"compno = %d; csty = 0x%02x; numdlvls = %d;\\n\",\n\t  coc->compno, coc->compparms.csty, coc->compparms.numdlvls);\n\tfprintf(out, \"cblkwidthval = %d; cblkheightval = %d; \"\n\t  \"cblksty = 0x%02x; qmfbid = %d;\\n\", coc->compparms.cblkwidthval,\n\t  coc->compparms.cblkheightval, coc->compparms.cblksty, coc->compparms.qmfbid);\n\treturn 0;\n}\n/******************************************************************************\\\n* COD/COC marker segment operation helper functions.\n\\******************************************************************************/\n\nstatic void jpc_cox_destroycompparms(jpc_coxcp_t *compparms)\n{\n\t/* Eliminate compiler warning about unused variables. */\n\tcompparms = 0;\n}\n\nstatic int jpc_cox_getcompparms(jpc_ms_t *ms, jpc_cstate_t *cstate,\n  jas_stream_t *in, int prtflag, jpc_coxcp_t *compparms)\n{\n\tuint_fast8_t tmp;\n\tint i;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tms = 0;\n\tcstate = 0;\n\n\tif (jpc_getuint8(in, &compparms->numdlvls) ||\n\t  jpc_getuint8(in, &compparms->cblkwidthval) ||\n\t  jpc_getuint8(in, &compparms->cblkheightval) ||\n\t  jpc_getuint8(in, &compparms->cblksty) ||\n\t  jpc_getuint8(in, &compparms->qmfbid)) {\n\t\treturn -1;\n\t}\n\tcompparms->numrlvls = compparms->numdlvls + 1;\n\tif (prtflag) {\n\t\tfor (i = 0; i < compparms->numrlvls; ++i) {\n\t\t\tif (jpc_getuint8(in, &tmp)) {\n\t\t\t\tjpc_cox_destroycompparms(compparms);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tcompparms->rlvls[i].parwidthval = tmp & 0xf;\n\t\t\tcompparms->rlvls[i].parheightval = (tmp >> 4) & 0xf;\n\t\t}\n/* Sigh.  This bit should be in the same field in both COC and COD mrk segs. */\ncompparms->csty |= JPC_COX_PRT;\n\t} else {\n\t}\n\tif (jas_stream_eof(in)) {\n\t\tjpc_cox_destroycompparms(compparms);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_cox_putcompparms(jpc_ms_t *ms, jpc_cstate_t *cstate,\n  jas_stream_t *out, int prtflag, jpc_coxcp_t *compparms)\n{\n\tint i;\n\tassert(compparms->numdlvls <= 32);\n\n\t/* Eliminate compiler warning about unused variables. */\n\tms = 0;\n\tcstate = 0;\n\n\tif (jpc_putuint8(out, compparms->numdlvls) ||\n\t  jpc_putuint8(out, compparms->cblkwidthval) ||\n\t  jpc_putuint8(out, compparms->cblkheightval) ||\n\t  jpc_putuint8(out, compparms->cblksty) ||\n\t  jpc_putuint8(out, compparms->qmfbid)) {\n\t\treturn -1;\n\t}\n\tif (prtflag) {\n\t\tfor (i = 0; i < compparms->numrlvls; ++i) {\n\t\t\tif (jpc_putuint8(out,\n\t\t\t  ((compparms->rlvls[i].parheightval & 0xf) << 4) |\n\t\t\t  (compparms->rlvls[i].parwidthval & 0xf))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* RGN marker segment operations.\n\\******************************************************************************/\n\nstatic int jpc_rgn_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_rgn_t *rgn = &ms->parms.rgn;\n\tuint_fast8_t tmp;\n\tif (cstate->numcomps <= 256) {\n\t\tif (jpc_getuint8(in, &tmp)) {\n\t\t\treturn -1;\n\t\t}\n\t\trgn->compno = tmp;\n\t} else {\n\t\tif (jpc_getuint16(in, &rgn->compno)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (jpc_getuint8(in, &rgn->roisty) ||\n\t  jpc_getuint8(in, &rgn->roishift)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_rgn_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_rgn_t *rgn = &ms->parms.rgn;\n\tif (cstate->numcomps <= 256) {\n\t\tif (jpc_putuint8(out, rgn->compno)) {\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tif (jpc_putuint16(out, rgn->compno)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (jpc_putuint8(out, rgn->roisty) ||\n\t  jpc_putuint8(out, rgn->roishift)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_rgn_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_rgn_t *rgn = &ms->parms.rgn;\n\tfprintf(out, \"compno = %d; roisty = %d; roishift = %d\\n\",\n\t  rgn->compno, rgn->roisty, rgn->roishift);\n\treturn 0;\n}\n\n/******************************************************************************\\\n* QCD marker segment operations.\n\\******************************************************************************/\n\nstatic void jpc_qcd_destroyparms(jpc_ms_t *ms)\n{\n\tjpc_qcd_t *qcd = &ms->parms.qcd;\n\tjpc_qcx_destroycompparms(&qcd->compparms);\n}\n\nstatic int jpc_qcd_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_qcxcp_t *compparms = &ms->parms.qcd.compparms;\n\treturn jpc_qcx_getcompparms(compparms, cstate, in, ms->len);\n}\n\nstatic int jpc_qcd_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_qcxcp_t *compparms = &ms->parms.qcd.compparms;\n\treturn jpc_qcx_putcompparms(compparms, cstate, out);\n}\n\nstatic int jpc_qcd_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_qcd_t *qcd = &ms->parms.qcd;\n\tint i;\n\tfprintf(out, \"qntsty = %d; numguard = %d; numstepsizes = %d\\n\",\n\t  (int) qcd->compparms.qntsty, qcd->compparms.numguard, qcd->compparms.numstepsizes);\n\tfor (i = 0; i < qcd->compparms.numstepsizes; ++i) {\n\t\tfprintf(out, \"expn[%d] = 0x%04x; mant[%d] = 0x%04x;\\n\",\n\t\t  i, (unsigned) JPC_QCX_GETEXPN(qcd->compparms.stepsizes[i]),\n\t\t  i, (unsigned) JPC_QCX_GETMANT(qcd->compparms.stepsizes[i]));\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* QCC marker segment operations.\n\\******************************************************************************/\n\nstatic void jpc_qcc_destroyparms(jpc_ms_t *ms)\n{\n\tjpc_qcc_t *qcc = &ms->parms.qcc;\n\tjpc_qcx_destroycompparms(&qcc->compparms);\n}\n\nstatic int jpc_qcc_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_qcc_t *qcc = &ms->parms.qcc;\n\tuint_fast8_t tmp;\n\tint len;\n\tlen = ms->len;\n\tif (cstate->numcomps <= 256) {\n\t\tif (jpc_getuint8(in, &tmp)) {\n\t\t\treturn -1;\n\t\t}\n\t\tqcc->compno = tmp;\n\t\t--len;\n\t} else {\n\t\tif (jpc_getuint16(in, &qcc->compno)) {\n\t\t\treturn -1;\n\t\t}\n\t\tlen -= 2;\n\t}\n\tif (jpc_qcx_getcompparms(&qcc->compparms, cstate, in, len)) {\n\t\treturn -1;\n\t}\n\tif (jas_stream_eof(in)) {\n\t\tjpc_qcc_destroyparms(ms);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_qcc_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_qcc_t *qcc = &ms->parms.qcc;\n\tif (cstate->numcomps <= 256) {\n\t\tif (jpc_putuint8(out, qcc->compno)) {\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tif (jpc_putuint16(out, qcc->compno)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (jpc_qcx_putcompparms(&qcc->compparms, cstate, out)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_qcc_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_qcc_t *qcc = &ms->parms.qcc;\n\tint i;\n\tfprintf(out, \"compno = %d; qntsty = %d; numguard = %d; \"\n\t  \"numstepsizes = %d\\n\", qcc->compno, qcc->compparms.qntsty, qcc->compparms.numguard,\n\t  qcc->compparms.numstepsizes);\n\tfor (i = 0; i < qcc->compparms.numstepsizes; ++i) {\n\t\tfprintf(out, \"expn[%d] = 0x%04x; mant[%d] = 0x%04x;\\n\",\n\t\t  i, (unsigned) JPC_QCX_GETEXPN(qcc->compparms.stepsizes[i]),\n\t\t  i, (unsigned) JPC_QCX_GETMANT(qcc->compparms.stepsizes[i]));\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* QCD/QCC marker segment helper functions.\n\\******************************************************************************/\n\nstatic void jpc_qcx_destroycompparms(jpc_qcxcp_t *compparms)\n{\n\tif (compparms->stepsizes) {\n\t\tjas_free(compparms->stepsizes);\n\t}\n}\n\nstatic int jpc_qcx_getcompparms(jpc_qcxcp_t *compparms, jpc_cstate_t *cstate,\n  jas_stream_t *in, uint_fast16_t len)\n{\n\tuint_fast8_t tmp;\n\tint n;\n\tint i;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tn = 0;\n\tif (jpc_getuint8(in, &tmp)) {\n\t\treturn -1;\n\t}\n\t++n;\n\tcompparms->qntsty = tmp & 0x1f;\n\tcompparms->numguard = (tmp >> 5) & 7;\n\tswitch (compparms->qntsty) {\n\tcase JPC_QCX_SIQNT:\n\t\tcompparms->numstepsizes = 1;\n\t\tbreak;\n\tcase JPC_QCX_NOQNT:\n\t\tcompparms->numstepsizes = (len - n);\n\t\tbreak;\n\tcase JPC_QCX_SEQNT:\n\t\t/* XXX - this is a hack */\n\t\tcompparms->numstepsizes = (len - n) / 2;\n\t\tbreak;\n\t}\n\tif (compparms->numstepsizes > 0) {\n\t\tcompparms->stepsizes = jas_alloc2(compparms->numstepsizes,\n\t\t  sizeof(uint_fast16_t));\n\t\tassert(compparms->stepsizes);\n\t\tfor (i = 0; i < compparms->numstepsizes; ++i) {\n\t\t\tif (compparms->qntsty == JPC_QCX_NOQNT) {\n\t\t\t\tif (jpc_getuint8(in, &tmp)) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tcompparms->stepsizes[i] = JPC_QCX_EXPN(tmp >> 3);\n\t\t\t} else {\n\t\t\t\tif (jpc_getuint16(in, &compparms->stepsizes[i])) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tcompparms->stepsizes = 0;\n\t}\n\tif (jas_stream_error(in) || jas_stream_eof(in)) {\n\t\tjpc_qcx_destroycompparms(compparms);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_qcx_putcompparms(jpc_qcxcp_t *compparms, jpc_cstate_t *cstate,\n  jas_stream_t *out)\n{\n\tint i;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tjpc_putuint8(out, ((compparms->numguard & 7) << 5) | compparms->qntsty);\n\tfor (i = 0; i < compparms->numstepsizes; ++i) {\n\t\tif (compparms->qntsty == JPC_QCX_NOQNT) {\n\t\t\tif (jpc_putuint8(out, JPC_QCX_GETEXPN(\n\t\t\t  compparms->stepsizes[i]) << 3)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (jpc_putuint16(out, compparms->stepsizes[i])) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* SOP marker segment operations.\n\\******************************************************************************/\n\nstatic int jpc_sop_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_sop_t *sop = &ms->parms.sop;\n\n\t/* Eliminate compiler warning about unused variable. */\n\tcstate = 0;\n\n\tif (jpc_getuint16(in, &sop->seqno)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_sop_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_sop_t *sop = &ms->parms.sop;\n\n\t/* Eliminate compiler warning about unused variable. */\n\tcstate = 0;\n\n\tif (jpc_putuint16(out, sop->seqno)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_sop_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_sop_t *sop = &ms->parms.sop;\n\tfprintf(out, \"seqno = %d;\\n\", sop->seqno);\n\treturn 0;\n}\n\n/******************************************************************************\\\n* PPM marker segment operations.\n\\******************************************************************************/\n\nstatic void jpc_ppm_destroyparms(jpc_ms_t *ms)\n{\n\tjpc_ppm_t *ppm = &ms->parms.ppm;\n\tif (ppm->data) {\n\t\tjas_free(ppm->data);\n\t}\n}\n\nstatic int jpc_ppm_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_ppm_t *ppm = &ms->parms.ppm;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tppm->data = 0;\n\n\tif (ms->len < 1) {\n\t\tgoto error;\n\t}\n\tif (jpc_getuint8(in, &ppm->ind)) {\n\t\tgoto error;\n\t}\n\n\tppm->len = ms->len - 1;\n\tif (ppm->len > 0) {\n\t\tif (!(ppm->data = jas_malloc(ppm->len))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (JAS_CAST(uint, jas_stream_read(in, ppm->data, ppm->len)) != ppm->len) {\n\t\t\tgoto error;\n\t\t}\n\t} else {\n\t\tppm->data = 0;\n\t}\n\treturn 0;\n\nerror:\n\tjpc_ppm_destroyparms(ms);\n\treturn -1;\n}\n\nstatic int jpc_ppm_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_ppm_t *ppm = &ms->parms.ppm;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tif (JAS_CAST(uint, jas_stream_write(out, (char *) ppm->data, ppm->len)) != ppm->len) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_ppm_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_ppm_t *ppm = &ms->parms.ppm;\n\tfprintf(out, \"ind=%d; len = %d;\\n\", ppm->ind, ppm->len);\n\tif (ppm->len > 0) {\n\t\tfprintf(out, \"data =\\n\");\n\t\tjas_memdump(out, ppm->data, ppm->len);\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* PPT marker segment operations.\n\\******************************************************************************/\n\nstatic void jpc_ppt_destroyparms(jpc_ms_t *ms)\n{\n\tjpc_ppt_t *ppt = &ms->parms.ppt;\n\tif (ppt->data) {\n\t\tjas_free(ppt->data);\n\t}\n}\n\nstatic int jpc_ppt_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_ppt_t *ppt = &ms->parms.ppt;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tppt->data = 0;\n\n\tif (ms->len < 1) {\n\t\tgoto error;\n\t}\n\tif (jpc_getuint8(in, &ppt->ind)) {\n\t\tgoto error;\n\t}\n\tppt->len = ms->len - 1;\n\tif (ppt->len > 0) {\n\t\tif (!(ppt->data = jas_malloc(ppt->len))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (jas_stream_read(in, (char *) ppt->data, ppt->len) != JAS_CAST(int, ppt->len)) {\n\t\t\tgoto error;\n\t\t}\n\t} else {\n\t\tppt->data = 0;\n\t}\n\treturn 0;\n\nerror:\n\tjpc_ppt_destroyparms(ms);\n\treturn -1;\n}\n\nstatic int jpc_ppt_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_ppt_t *ppt = &ms->parms.ppt;\n\n\t/* Eliminate compiler warning about unused variable. */\n\tcstate = 0;\n\n\tif (jpc_putuint8(out, ppt->ind)) {\n\t\treturn -1;\n\t}\n\tif (jas_stream_write(out, (char *) ppt->data, ppt->len) != JAS_CAST(int, ppt->len)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_ppt_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_ppt_t *ppt = &ms->parms.ppt;\n\tfprintf(out, \"ind=%d; len = %d;\\n\", ppt->ind, ppt->len);\n\tif (ppt->len > 0) {\n\t\tfprintf(out, \"data =\\n\");\n\t\tjas_memdump(out, ppt->data, ppt->len);\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* POC marker segment operations.\n\\******************************************************************************/\n\nstatic void jpc_poc_destroyparms(jpc_ms_t *ms)\n{\n\tjpc_poc_t *poc = &ms->parms.poc;\n\tif (poc->pchgs) {\n\t\tjas_free(poc->pchgs);\n\t}\n}\n\nstatic int jpc_poc_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_poc_t *poc = &ms->parms.poc;\n\tjpc_pocpchg_t *pchg;\n\tint pchgno;\n\tuint_fast8_t tmp;\n\tpoc->numpchgs = (cstate->numcomps > 256) ? (ms->len / 9) :\n\t  (ms->len / 7);\n\tif (!(poc->pchgs = jas_alloc2(poc->numpchgs, sizeof(jpc_pocpchg_t)))) {\n\t\tgoto error;\n\t}\n\tfor (pchgno = 0, pchg = poc->pchgs; pchgno < poc->numpchgs; ++pchgno,\n\t  ++pchg) {\n\t\tif (jpc_getuint8(in, &pchg->rlvlnostart)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (cstate->numcomps > 256) {\n\t\t\tif (jpc_getuint16(in, &pchg->compnostart)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t} else {\n\t\t\tif (jpc_getuint8(in, &tmp)) {\n\t\t\t\tgoto error;\n\t\t\t};\n\t\t\tpchg->compnostart = tmp;\n\t\t}\n\t\tif (jpc_getuint16(in, &pchg->lyrnoend) ||\n\t\t  jpc_getuint8(in, &pchg->rlvlnoend)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (cstate->numcomps > 256) {\n\t\t\tif (jpc_getuint16(in, &pchg->compnoend)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t} else {\n\t\t\tif (jpc_getuint8(in, &tmp)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tpchg->compnoend = tmp;\n\t\t}\n\t\tif (jpc_getuint8(in, &pchg->prgord)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (pchg->rlvlnostart > pchg->rlvlnoend ||\n\t\t  pchg->compnostart > pchg->compnoend) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\treturn 0;\n\nerror:\n\tjpc_poc_destroyparms(ms);\n\treturn -1;\n}\n\nstatic int jpc_poc_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_poc_t *poc = &ms->parms.poc;\n\tjpc_pocpchg_t *pchg;\n\tint pchgno;\n\tfor (pchgno = 0, pchg = poc->pchgs; pchgno < poc->numpchgs; ++pchgno,\n\t  ++pchg) {\n\t\tif (jpc_putuint8(out, pchg->rlvlnostart) ||\n\t\t  ((cstate->numcomps > 256) ?\n\t\t  jpc_putuint16(out, pchg->compnostart) :\n\t\t  jpc_putuint8(out, pchg->compnostart)) ||\n\t\t  jpc_putuint16(out, pchg->lyrnoend) ||\n\t\t  jpc_putuint8(out, pchg->rlvlnoend) ||\n\t\t  ((cstate->numcomps > 256) ?\n\t\t  jpc_putuint16(out, pchg->compnoend) :\n\t\t  jpc_putuint8(out, pchg->compnoend)) ||\n\t\t  jpc_putuint8(out, pchg->prgord)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jpc_poc_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_poc_t *poc = &ms->parms.poc;\n\tjpc_pocpchg_t *pchg;\n\tint pchgno;\n\tfor (pchgno = 0, pchg = poc->pchgs; pchgno < poc->numpchgs;\n\t  ++pchgno, ++pchg) {\n\t\tfprintf(out, \"po[%d] = %d; \", pchgno, pchg->prgord);\n\t\tfprintf(out, \"cs[%d] = %d; ce[%d] = %d; \",\n\t\t  pchgno, pchg->compnostart, pchgno, pchg->compnoend);\n\t\tfprintf(out, \"rs[%d] = %d; re[%d] = %d; \",\n\t\t  pchgno, pchg->rlvlnostart, pchgno, pchg->rlvlnoend);\n\t\tfprintf(out, \"le[%d] = %d\\n\", pchgno, pchg->lyrnoend);\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* CRG marker segment operations.\n\\******************************************************************************/\n\nstatic void jpc_crg_destroyparms(jpc_ms_t *ms)\n{\n\tjpc_crg_t *crg = &ms->parms.crg;\n\tif (crg->comps) {\n\t\tjas_free(crg->comps);\n\t}\n}\n\nstatic int jpc_crg_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_crg_t *crg = &ms->parms.crg;\n\tjpc_crgcomp_t *comp;\n\tuint_fast16_t compno;\n\tcrg->numcomps = cstate->numcomps;\n\tif (!(crg->comps = jas_alloc2(cstate->numcomps, sizeof(uint_fast16_t)))) {\n\t\treturn -1;\n\t}\n\tfor (compno = 0, comp = crg->comps; compno < cstate->numcomps;\n\t  ++compno, ++comp) {\n\t\tif (jpc_getuint16(in, &comp->hoff) ||\n\t\t  jpc_getuint16(in, &comp->voff)) {\n\t\t\tjpc_crg_destroyparms(ms);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jpc_crg_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_crg_t *crg = &ms->parms.crg;\n\tint compno;\n\tjpc_crgcomp_t *comp;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tfor (compno = 0, comp = crg->comps; compno < crg->numcomps; ++compno,\n\t  ++comp) {\n\t\tif (jpc_putuint16(out, comp->hoff) ||\n\t\t  jpc_putuint16(out, comp->voff)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jpc_crg_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_crg_t *crg = &ms->parms.crg;\n\tint compno;\n\tjpc_crgcomp_t *comp;\n\tfor (compno = 0, comp = crg->comps; compno < crg->numcomps; ++compno,\n\t  ++comp) {\n\t\tfprintf(out, \"hoff[%d] = %d; voff[%d] = %d\\n\", compno,\n\t\t  comp->hoff, compno, comp->voff);\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Operations for COM marker segment.\n\\******************************************************************************/\n\nstatic void jpc_com_destroyparms(jpc_ms_t *ms)\n{\n\tjpc_com_t *com = &ms->parms.com;\n\tif (com->data) {\n\t\tjas_free(com->data);\n\t}\n}\n\nstatic int jpc_com_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_com_t *com = &ms->parms.com;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tif (jpc_getuint16(in, &com->regid)) {\n\t\treturn -1;\n\t}\n\tcom->len = ms->len - 2;\n\tif (com->len > 0) {\n\t\tif (!(com->data = jas_malloc(com->len))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (jas_stream_read(in, com->data, com->len) != JAS_CAST(int, com->len)) {\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tcom->data = 0;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_com_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_com_t *com = &ms->parms.com;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tif (jpc_putuint16(out, com->regid)) {\n\t\treturn -1;\n\t}\n\tif (jas_stream_write(out, com->data, com->len) != JAS_CAST(int, com->len)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_com_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_com_t *com = &ms->parms.com;\n\tunsigned int i;\n\tint printable;\n\tfprintf(out, \"regid = %d;\\n\", com->regid);\n\tprintable = 1;\n\tfor (i = 0; i < com->len; ++i) {\n\t\tif (!isprint(com->data[i])) {\n\t\t\tprintable = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (printable) {\n\t\tfprintf(out, \"data = \");\n\t\tfwrite(com->data, sizeof(char), com->len, out);\n\t\tfprintf(out, \"\\n\");\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Operations for unknown types of marker segments.\n\\******************************************************************************/\n\nstatic void jpc_unk_destroyparms(jpc_ms_t *ms)\n{\n\tjpc_unk_t *unk = &ms->parms.unk;\n\tif (unk->data) {\n\t\tjas_free(unk->data);\n\t}\n}\n\nstatic int jpc_unk_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_unk_t *unk = &ms->parms.unk;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tif (ms->len > 0) {\n\t\tif (!(unk->data = jas_alloc2(ms->len, sizeof(unsigned char)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (jas_stream_read(in, (char *) unk->data, ms->len) != JAS_CAST(int, ms->len)) {\n\t\t\tjas_free(unk->data);\n\t\t\treturn -1;\n\t\t}\n\t\tunk->len = ms->len;\n\t} else {\n\t\tunk->data = 0;\n\t\tunk->len = 0;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_unk_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\tms = 0;\n\tout = 0;\n\n\t/* If this function is called, we are trying to write an unsupported\n\t  type of marker segment.  Return with an error indication.  */\n\treturn -1;\n}\n\nstatic int jpc_unk_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tunsigned int i;\n\tjpc_unk_t *unk = &ms->parms.unk;\n\tfor (i = 0; i < unk->len; ++i) {\n\t\tfprintf(out, \"%02x \", unk->data[i]);\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Primitive I/O operations.\n\\******************************************************************************/\n\nint jpc_getuint8(jas_stream_t *in, uint_fast8_t *val)\n{\n\tint c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tif (val) {\n\t\t*val = c;\n\t}\n\treturn 0;\n}\n\nint jpc_putuint8(jas_stream_t *out, uint_fast8_t val)\n{\n\tif (jas_stream_putc(out, val & 0xff) == EOF) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nint jpc_getuint16(jas_stream_t *in, uint_fast16_t *val)\n{\n\tuint_fast16_t v;\n\tint c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = (v << 8) | c;\n\tif (val) {\n\t\t*val = v;\n\t}\n\treturn 0;\n}\n\nint jpc_putuint16(jas_stream_t *out, uint_fast16_t val)\n{\n\tif (jas_stream_putc(out, (val >> 8) & 0xff) == EOF ||\n\t  jas_stream_putc(out, val & 0xff) == EOF) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nint jpc_getuint32(jas_stream_t *in, uint_fast32_t *val)\n{\n\tuint_fast32_t v;\n\tint c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = (v << 8) | c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = (v << 8) | c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = (v << 8) | c;\n\tif (val) {\n\t\t*val = v;\n\t}\n\treturn 0;\n}\n\nint jpc_putuint32(jas_stream_t *out, uint_fast32_t val)\n{\n\tif (jas_stream_putc(out, (val >> 24) & 0xff) == EOF ||\n\t  jas_stream_putc(out, (val >> 16) & 0xff) == EOF ||\n\t  jas_stream_putc(out, (val >> 8) & 0xff) == EOF ||\n\t  jas_stream_putc(out, val & 0xff) == EOF) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Miscellany\n\\******************************************************************************/\n\nstatic jpc_mstabent_t *jpc_mstab_lookup(int id)\n{\n\tjpc_mstabent_t *mstabent;\n\tfor (mstabent = jpc_mstab;; ++mstabent) {\n\t\tif (mstabent->id == id || mstabent->id < 0) {\n\t\t\treturn mstabent;\n\t\t}\n\t}\n\tassert(0);\n\treturn 0;\n}\n\nint jpc_validate(jas_stream_t *in)\n{\n\tint n;\n\tint i;\n\tunsigned char buf[2];\n\n\tassert(JAS_STREAM_MAXPUTBACK >= 2);\n\n\tif ((n = jas_stream_read(in, (char *) buf, 2)) < 0) {\n\t\treturn -1;\n\t}\n\tfor (i = n - 1; i >= 0; --i) {\n\t\tif (jas_stream_ungetc(in, buf[i]) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (n < 2) {\n\t\treturn -1;\n\t}\n\tif (buf[0] == (JPC_MS_SOC >> 8) && buf[1] == (JPC_MS_SOC & 0xff)) {\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n\nint jpc_getdata(jas_stream_t *in, jas_stream_t *out, long len)\n{\n\treturn jas_stream_copy(out, in, len);\n}\n\nint jpc_putdata(jas_stream_t *out, jas_stream_t *in, long len)\n{\n\treturn jas_stream_copy(out, in, len);\n}\n"], "filenames": ["src/libjasper/jpc/jpc_cs.c"], "buggy_code_start_loc": [514], "buggy_code_end_loc": [514], "fixing_code_start_loc": [515], "fixing_code_end_loc": [525], "type": "CWE-369", "message": "The jpc_dec_process_siz function in libjasper/jpc/jpc_dec.c in JasPer before 1.900.4 allows remote attackers to cause a denial of service (divide-by-zero error and application crash) via a crafted XRsiz value in a BMP image to the imginfo command.", "other": {"cve": {"id": "CVE-2016-8691", "sourceIdentifier": "cve@mitre.org", "published": "2017-02-15T19:59:00.797", "lastModified": "2018-01-05T02:31:19.137", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The jpc_dec_process_siz function in libjasper/jpc/jpc_dec.c in JasPer before 1.900.4 allows remote attackers to cause a denial of service (divide-by-zero error and application crash) via a crafted XRsiz value in a BMP image to the imginfo command."}, {"lang": "es", "value": "La funci\u00f3n jpc_dec_process_siz en libjasper/jpc/jpc_dec.c en JasPer en versiones anteriores a 1.900.4 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (error de divisi\u00f3n por cero y bloqueo de la aplicaci\u00f3n) a trav\u00e9s de un valor XRsiz manipulado en una imagen BMP al comando imginfo."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-369"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jasper_project:jasper:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.900.3", "matchCriteriaId": "E81E90E4-1DA2-4315-9433-075489847D30"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:25:*:*:*:*:*:*:*", "matchCriteriaId": "772E9557-A371-4664-AE2D-4135AAEB89AA"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-3785", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/08/23/6", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/10/16/14", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/93593", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:1208", "source": "cve@mitre.org"}, {"url": "https://blogs.gentoo.org/ago/2016/10/16/jasper-two-divide-by-zero-in-jpc_dec_process_siz-jpc_dec-c/", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1385502", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/mdadams/jasper/commit/d8c2604cd438c41ec72aff52c16ebd8183068020", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/THLEZURI4D24PRM7SMASC5I25IAWXXTM/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/mdadams/jasper/commit/d8c2604cd438c41ec72aff52c16ebd8183068020"}}