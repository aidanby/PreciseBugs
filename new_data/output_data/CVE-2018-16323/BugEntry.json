{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            X   X  BBBB   M   M                              %\n%                             X X   B   B  MM MM                              %\n%                              X    BBBB   M M M                              %\n%                             X X   B   B  M   M                              %\n%                            X   X  BBBB   M   M                              %\n%                                                                             %\n%                                                                             %\n%                  Read/Write X Windows System Bitmap Format                  %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2018 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://www.imagemagick.org/script/license.php                           %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/utility.h\"\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WriteXBMImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s X B M                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsXBM() returns MagickTrue if the image format type, identified by the\n%  magick string, is XBM.\n%\n%  The format of the IsXBM method is:\n%\n%      MagickBooleanType IsXBM(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsXBM(const unsigned char *magick,const size_t length)\n{\n  if (length < 7)\n    return(MagickFalse);\n  if (memcmp(magick,\"#define\",7) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d X B M I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadXBMImage() reads an X11 bitmap image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadXBMImage method is:\n%\n%      Image *ReadXBMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic int XBMInteger(Image *image,short int *hex_digits)\n{ \n  int\n    c;\n  \n  unsigned int\n    value;\n  \n  /*\n    Skip any leading whitespace.\n  */\n  do\n  { \n    c=ReadBlobByte(image);\n    if (c == EOF)\n      return(-1);\n  } while ((c == ' ') || (c == '\\t') || (c == '\\n') || (c == '\\r'));\n  /*\n    Evaluate number.\n  */\n  value=0;\n  do\n  { \n    if (value > (unsigned int) (INT_MAX/10))\n      break;\n    value*=16;\n    c&=0xff;\n    if (value > (unsigned int) (INT_MAX-hex_digits[c]))\n      break;\n    value+=hex_digits[c];\n    c=ReadBlobByte(image);\n    if (c == EOF)\n      return(-1);\n  } while (hex_digits[c] >= 0);\n  return((int) value);\n}\n\nstatic Image *ReadXBMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    buffer[MagickPathExtent],\n    name[MagickPathExtent];\n\n  Image\n    *image;\n\n  int\n    c;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i,\n    x;\n\n  register Quantum\n    *q;\n\n  register unsigned char\n    *p;\n\n  short int\n    hex_digits[256];\n\n  ssize_t\n    y;\n\n  unsigned char\n    *data;\n\n  unsigned int\n    bit,\n    byte,\n    bytes_per_line,\n    height,\n    length,\n    padding,\n    version,\n    width;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read X bitmap header.\n  */\n  width=0;\n  height=0;\n  *name='\\0';\n  while (ReadBlobString(image,buffer) != (char *) NULL)\n    if (sscanf(buffer,\"#define %1024s %u\",name,&width) == 2)\n      if ((strlen(name) >= 6) &&\n          (LocaleCompare(name+strlen(name)-6,\"_width\") == 0))\n        break;\n  while (ReadBlobString(image,buffer) != (char *) NULL)\n    if (sscanf(buffer,\"#define %1024s %u\",name,&height) == 2)\n      if ((strlen(name) >= 7) &&\n          (LocaleCompare(name+strlen(name)-7,\"_height\") == 0))\n        break;\n  image->columns=width;\n  image->rows=height;\n  image->depth=8;\n  image->storage_class=PseudoClass;\n  image->colors=2;\n  /*\n    Scan until hex digits.\n  */\n  version=11;\n  while (ReadBlobString(image,buffer) != (char *) NULL)\n  {\n    if (sscanf(buffer,\"static short %1024s = {\",name) == 1)\n      version=10;\n    else\n      if (sscanf(buffer,\"static unsigned char %1024s = {\",name) == 1)\n        version=11;\n      else\n        if (sscanf(buffer,\"static char %1024s = {\",name) == 1)\n          version=11;\n        else\n          continue;\n    p=(unsigned char *) strrchr(name,'_');\n    if (p == (unsigned char *) NULL)\n      p=(unsigned char *) name;\n    else\n      p++;\n    if (LocaleCompare(\"bits[]\",(char *) p) == 0)\n      break;\n  }\n  if ((image->columns == 0) || (image->rows == 0) ||\n      (EOFBlob(image) != MagickFalse))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  /*\n    Initialize image structure.\n  */\n  if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  /*\n    Initialize colormap.\n  */\n  image->colormap[0].red=(MagickRealType) QuantumRange;\n  image->colormap[0].green=(MagickRealType) QuantumRange;\n  image->colormap[0].blue=(MagickRealType) QuantumRange;\n  image->colormap[1].red=0.0;\n  image->colormap[1].green=0.0;\n  image->colormap[1].blue=0.0;\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Initialize hex values.\n  */\n  for (i=0; i < (ssize_t) (sizeof(hex_digits)/sizeof(*hex_digits)); i++)\n    hex_digits[i]=(-1);\n  hex_digits[(int) '0']=0;\n  hex_digits[(int) '1']=1;\n  hex_digits[(int) '2']=2;\n  hex_digits[(int) '3']=3;\n  hex_digits[(int) '4']=4;\n  hex_digits[(int) '5']=5;\n  hex_digits[(int) '6']=6;\n  hex_digits[(int) '7']=7;\n  hex_digits[(int) '8']=8;\n  hex_digits[(int) '9']=9;\n  hex_digits[(int) 'A']=10;\n  hex_digits[(int) 'B']=11;\n  hex_digits[(int) 'C']=12;\n  hex_digits[(int) 'D']=13;\n  hex_digits[(int) 'E']=14;\n  hex_digits[(int) 'F']=15;\n  hex_digits[(int) 'a']=10;\n  hex_digits[(int) 'b']=11;\n  hex_digits[(int) 'c']=12;\n  hex_digits[(int) 'd']=13;\n  hex_digits[(int) 'e']=14;\n  hex_digits[(int) 'f']=15;\n  hex_digits[(int) 'x']=0;\n  hex_digits[(int) ' ']=(-1);\n  hex_digits[(int) ',']=(-1);\n  hex_digits[(int) '}']=(-1);\n  hex_digits[(int) '\\n']=(-1);\n  hex_digits[(int) '\\t']=(-1);\n  /*\n    Read hex image data.\n  */\n  padding=0;\n  if (((image->columns % 16) != 0) && ((image->columns % 16) < 9) &&\n      (version == 10))\n    padding=1;\n  bytes_per_line=(unsigned int) (image->columns+7)/8+padding;\n  length=(unsigned int) image->rows;\n  data=(unsigned char *) AcquireQuantumMemory(length,bytes_per_line*\n    sizeof(*data));\n  if (data == (unsigned char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  p=data;\n  if (version == 10)\n    for (i=0; i < (ssize_t) (bytes_per_line*image->rows); (i+=2))\n    {\n      c=XBMInteger(image,hex_digits);\n      if (c < 0)\n        break;\n      *p++=(unsigned char) c;\n      if ((padding == 0) || (((i+2) % bytes_per_line) != 0))\n        *p++=(unsigned char) (c >> 8);\n    }\n  else\n    for (i=0; i < (ssize_t) (bytes_per_line*image->rows); i++)\n    {\n      c=XBMInteger(image,hex_digits);\n      if (c < 0)\n        break;\n      *p++=(unsigned char) c;\n    }\n  if (EOFBlob(image) != MagickFalse)\n    {\n      data=(unsigned char *) RelinquishMagickMemory(data);\n      ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n    }\n  /*\n    Convert X bitmap image to pixel packets.\n  */\n  p=data;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    bit=0;\n    byte=0;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if (bit == 0)\n        byte=(unsigned int) (*p++);\n      SetPixelIndex(image,(Quantum) ((byte & 0x01) != 0 ? 0x01 : 0x00),q);\n      bit++;\n      byte>>=1;\n      if (bit == 8)\n        bit=0;\n      q+=GetPixelChannels(image);\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  data=(unsigned char *) RelinquishMagickMemory(data);\n  (void) SyncImage(image,exception);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r X B M I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterXBMImage() adds attributes for the XBM image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterXBMImage method is:\n%\n%      size_t RegisterXBMImage(void)\n%\n*/\nModuleExport size_t RegisterXBMImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"XBM\",\"XBM\",\n    \"X Windows system bitmap (black and white)\");\n  entry->decoder=(DecodeImageHandler *) ReadXBMImage;\n  entry->encoder=(EncodeImageHandler *) WriteXBMImage;\n  entry->magick=(IsImageFormatHandler *) IsXBM;\n  entry->flags^=CoderAdjoinFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r X B M I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterXBMImage() removes format registrations made by the\n%  XBM module from the list of supported formats.\n%\n%  The format of the UnregisterXBMImage method is:\n%\n%      UnregisterXBMImage(void)\n%\n*/\nModuleExport void UnregisterXBMImage(void)\n{\n  (void) UnregisterMagickInfo(\"XBM\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e X B M I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteXBMImage() writes an image to a file in the X bitmap format.\n%\n%  The format of the WriteXBMImage method is:\n%\n%      MagickBooleanType WriteXBMImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WriteXBMImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  char\n    basename[MagickPathExtent],\n    buffer[MagickPathExtent];\n\n  MagickBooleanType\n    status;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    x;\n\n  size_t\n    bit,\n    byte;\n\n  ssize_t\n    count,\n    y;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) TransformImageColorspace(image,sRGBColorspace,exception);\n  /*\n    Write X bitmap header.\n  */\n  GetPathComponent(image->filename,BasePath,basename);\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"#define %s_width %.20g\\n\",\n    basename,(double) image->columns);\n  (void) WriteBlob(image,strlen(buffer),(unsigned char *) buffer);\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"#define %s_height %.20g\\n\",\n    basename,(double) image->rows);\n  (void) WriteBlob(image,strlen(buffer),(unsigned char *) buffer);\n  (void) FormatLocaleString(buffer,MagickPathExtent,\n    \"static char %s_bits[] = {\\n\",basename);\n  (void) WriteBlob(image,strlen(buffer),(unsigned char *) buffer);\n  (void) CopyMagickString(buffer,\" \",MagickPathExtent);\n  (void) WriteBlob(image,strlen(buffer),(unsigned char *) buffer);\n  /*\n    Convert MIFF to X bitmap pixels.\n  */\n  (void) SetImageType(image,BilevelType,exception);\n  bit=0;\n  byte=0;\n  count=0;\n  x=0;\n  y=0;\n  (void) CopyMagickString(buffer,\" \",MagickPathExtent);\n  (void) WriteBlob(image,strlen(buffer),(unsigned char *) buffer);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      byte>>=1;\n      if (GetPixelLuma(image,p) < (QuantumRange/2))\n        byte|=0x80;\n      bit++;\n      if (bit == 8)\n        {\n          /*\n            Write a bitmap byte to the image file.\n          */\n          (void) FormatLocaleString(buffer,MagickPathExtent,\"0x%02X, \",\n            (unsigned int) (byte & 0xff));\n          (void) WriteBlob(image,strlen(buffer),(unsigned char *) buffer);\n          count++;\n          if (count == 12)\n            {\n              (void) CopyMagickString(buffer,\"\\n  \",MagickPathExtent);\n              (void) WriteBlob(image,strlen(buffer),(unsigned char *) buffer);\n              count=0;\n            };\n          bit=0;\n          byte=0;\n        }\n        p+=GetPixelChannels(image);\n      }\n    if (bit != 0)\n      {\n        /*\n          Write a bitmap byte to the image file.\n        */\n        byte>>=(8-bit);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"0x%02X, \",\n          (unsigned int) (byte & 0xff));\n        (void) WriteBlob(image,strlen(buffer),(unsigned char *) buffer);\n        count++;\n        if (count == 12)\n          {\n            (void) CopyMagickString(buffer,\"\\n  \",MagickPathExtent);\n            (void) WriteBlob(image,strlen(buffer),(unsigned char *) buffer);\n            count=0;\n          };\n        bit=0;\n        byte=0;\n      };\n    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  (void) CopyMagickString(buffer,\"};\\n\",MagickPathExtent);\n  (void) WriteBlob(image,strlen(buffer),(unsigned char *) buffer);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            X   X  BBBB   M   M                              %\n%                             X X   B   B  MM MM                              %\n%                              X    BBBB   M M M                              %\n%                             X X   B   B  M   M                              %\n%                            X   X  BBBB   M   M                              %\n%                                                                             %\n%                                                                             %\n%                  Read/Write X Windows System Bitmap Format                  %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2018 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://www.imagemagick.org/script/license.php                           %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/utility.h\"\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WriteXBMImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s X B M                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsXBM() returns MagickTrue if the image format type, identified by the\n%  magick string, is XBM.\n%\n%  The format of the IsXBM method is:\n%\n%      MagickBooleanType IsXBM(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsXBM(const unsigned char *magick,const size_t length)\n{\n  if (length < 7)\n    return(MagickFalse);\n  if (memcmp(magick,\"#define\",7) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d X B M I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadXBMImage() reads an X11 bitmap image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadXBMImage method is:\n%\n%      Image *ReadXBMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic int XBMInteger(Image *image,short int *hex_digits)\n{ \n  int\n    c;\n  \n  unsigned int\n    value;\n  \n  /*\n    Skip any leading whitespace.\n  */\n  do\n  { \n    c=ReadBlobByte(image);\n    if (c == EOF)\n      return(-1);\n  } while ((c == ' ') || (c == '\\t') || (c == '\\n') || (c == '\\r'));\n  /*\n    Evaluate number.\n  */\n  value=0;\n  do\n  { \n    if (value > (unsigned int) (INT_MAX/10))\n      break;\n    value*=16;\n    c&=0xff;\n    if (value > (unsigned int) (INT_MAX-hex_digits[c]))\n      break;\n    value+=hex_digits[c];\n    c=ReadBlobByte(image);\n    if (c == EOF)\n      return(-1);\n  } while (hex_digits[c] >= 0);\n  return((int) value);\n}\n\nstatic Image *ReadXBMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    buffer[MagickPathExtent],\n    name[MagickPathExtent];\n\n  Image\n    *image;\n\n  int\n    c;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i,\n    x;\n\n  register Quantum\n    *q;\n\n  register unsigned char\n    *p;\n\n  short int\n    hex_digits[256];\n\n  ssize_t\n    y;\n\n  unsigned char\n    *data;\n\n  unsigned int\n    bit,\n    byte,\n    bytes_per_line,\n    height,\n    length,\n    padding,\n    version,\n    width;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read X bitmap header.\n  */\n  width=0;\n  height=0;\n  *name='\\0';\n  while (ReadBlobString(image,buffer) != (char *) NULL)\n    if (sscanf(buffer,\"#define %1024s %u\",name,&width) == 2)\n      if ((strlen(name) >= 6) &&\n          (LocaleCompare(name+strlen(name)-6,\"_width\") == 0))\n        break;\n  while (ReadBlobString(image,buffer) != (char *) NULL)\n    if (sscanf(buffer,\"#define %1024s %u\",name,&height) == 2)\n      if ((strlen(name) >= 7) &&\n          (LocaleCompare(name+strlen(name)-7,\"_height\") == 0))\n        break;\n  image->columns=width;\n  image->rows=height;\n  image->depth=8;\n  image->storage_class=PseudoClass;\n  image->colors=2;\n  /*\n    Scan until hex digits.\n  */\n  version=11;\n  while (ReadBlobString(image,buffer) != (char *) NULL)\n  {\n    if (sscanf(buffer,\"static short %1024s = {\",name) == 1)\n      version=10;\n    else\n      if (sscanf(buffer,\"static unsigned char %1024s = {\",name) == 1)\n        version=11;\n      else\n        if (sscanf(buffer,\"static char %1024s = {\",name) == 1)\n          version=11;\n        else\n          continue;\n    p=(unsigned char *) strrchr(name,'_');\n    if (p == (unsigned char *) NULL)\n      p=(unsigned char *) name;\n    else\n      p++;\n    if (LocaleCompare(\"bits[]\",(char *) p) == 0)\n      break;\n  }\n  if ((image->columns == 0) || (image->rows == 0) ||\n      (EOFBlob(image) != MagickFalse))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  /*\n    Initialize image structure.\n  */\n  if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  /*\n    Initialize colormap.\n  */\n  image->colormap[0].red=(MagickRealType) QuantumRange;\n  image->colormap[0].green=(MagickRealType) QuantumRange;\n  image->colormap[0].blue=(MagickRealType) QuantumRange;\n  image->colormap[1].red=0.0;\n  image->colormap[1].green=0.0;\n  image->colormap[1].blue=0.0;\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Initialize hex values.\n  */\n  for (i=0; i < (ssize_t) (sizeof(hex_digits)/sizeof(*hex_digits)); i++)\n    hex_digits[i]=(-1);\n  hex_digits[(int) '0']=0;\n  hex_digits[(int) '1']=1;\n  hex_digits[(int) '2']=2;\n  hex_digits[(int) '3']=3;\n  hex_digits[(int) '4']=4;\n  hex_digits[(int) '5']=5;\n  hex_digits[(int) '6']=6;\n  hex_digits[(int) '7']=7;\n  hex_digits[(int) '8']=8;\n  hex_digits[(int) '9']=9;\n  hex_digits[(int) 'A']=10;\n  hex_digits[(int) 'B']=11;\n  hex_digits[(int) 'C']=12;\n  hex_digits[(int) 'D']=13;\n  hex_digits[(int) 'E']=14;\n  hex_digits[(int) 'F']=15;\n  hex_digits[(int) 'a']=10;\n  hex_digits[(int) 'b']=11;\n  hex_digits[(int) 'c']=12;\n  hex_digits[(int) 'd']=13;\n  hex_digits[(int) 'e']=14;\n  hex_digits[(int) 'f']=15;\n  hex_digits[(int) 'x']=0;\n  hex_digits[(int) ' ']=(-1);\n  hex_digits[(int) ',']=(-1);\n  hex_digits[(int) '}']=(-1);\n  hex_digits[(int) '\\n']=(-1);\n  hex_digits[(int) '\\t']=(-1);\n  /*\n    Read hex image data.\n  */\n  padding=0;\n  if (((image->columns % 16) != 0) && ((image->columns % 16) < 9) &&\n      (version == 10))\n    padding=1;\n  bytes_per_line=(unsigned int) (image->columns+7)/8+padding;\n  length=(unsigned int) image->rows;\n  data=(unsigned char *) AcquireQuantumMemory(length,bytes_per_line*\n    sizeof(*data));\n  if (data == (unsigned char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  p=data;\n  if (version == 10)\n    for (i=0; i < (ssize_t) (bytes_per_line*image->rows); (i+=2))\n    {\n      c=XBMInteger(image,hex_digits);\n      if (c < 0)\n        {\n          data=(unsigned char *) RelinquishMagickMemory(data);\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        }\n      *p++=(unsigned char) c;\n      if ((padding == 0) || (((i+2) % bytes_per_line) != 0))\n        *p++=(unsigned char) (c >> 8);\n    }\n  else\n    for (i=0; i < (ssize_t) (bytes_per_line*image->rows); i++)\n    {\n      c=XBMInteger(image,hex_digits);\n      if (c < 0)\n        {\n          data=(unsigned char *) RelinquishMagickMemory(data);\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        }\n      *p++=(unsigned char) c;\n    }\n  if (EOFBlob(image) != MagickFalse)\n    {\n      data=(unsigned char *) RelinquishMagickMemory(data);\n      ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n    }\n  /*\n    Convert X bitmap image to pixel packets.\n  */\n  p=data;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    bit=0;\n    byte=0;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if (bit == 0)\n        byte=(unsigned int) (*p++);\n      SetPixelIndex(image,(Quantum) ((byte & 0x01) != 0 ? 0x01 : 0x00),q);\n      bit++;\n      byte>>=1;\n      if (bit == 8)\n        bit=0;\n      q+=GetPixelChannels(image);\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  data=(unsigned char *) RelinquishMagickMemory(data);\n  (void) SyncImage(image,exception);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r X B M I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterXBMImage() adds attributes for the XBM image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterXBMImage method is:\n%\n%      size_t RegisterXBMImage(void)\n%\n*/\nModuleExport size_t RegisterXBMImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"XBM\",\"XBM\",\n    \"X Windows system bitmap (black and white)\");\n  entry->decoder=(DecodeImageHandler *) ReadXBMImage;\n  entry->encoder=(EncodeImageHandler *) WriteXBMImage;\n  entry->magick=(IsImageFormatHandler *) IsXBM;\n  entry->flags^=CoderAdjoinFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r X B M I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterXBMImage() removes format registrations made by the\n%  XBM module from the list of supported formats.\n%\n%  The format of the UnregisterXBMImage method is:\n%\n%      UnregisterXBMImage(void)\n%\n*/\nModuleExport void UnregisterXBMImage(void)\n{\n  (void) UnregisterMagickInfo(\"XBM\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e X B M I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteXBMImage() writes an image to a file in the X bitmap format.\n%\n%  The format of the WriteXBMImage method is:\n%\n%      MagickBooleanType WriteXBMImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WriteXBMImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  char\n    basename[MagickPathExtent],\n    buffer[MagickPathExtent];\n\n  MagickBooleanType\n    status;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    x;\n\n  size_t\n    bit,\n    byte;\n\n  ssize_t\n    count,\n    y;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) TransformImageColorspace(image,sRGBColorspace,exception);\n  /*\n    Write X bitmap header.\n  */\n  GetPathComponent(image->filename,BasePath,basename);\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"#define %s_width %.20g\\n\",\n    basename,(double) image->columns);\n  (void) WriteBlob(image,strlen(buffer),(unsigned char *) buffer);\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"#define %s_height %.20g\\n\",\n    basename,(double) image->rows);\n  (void) WriteBlob(image,strlen(buffer),(unsigned char *) buffer);\n  (void) FormatLocaleString(buffer,MagickPathExtent,\n    \"static char %s_bits[] = {\\n\",basename);\n  (void) WriteBlob(image,strlen(buffer),(unsigned char *) buffer);\n  (void) CopyMagickString(buffer,\" \",MagickPathExtent);\n  (void) WriteBlob(image,strlen(buffer),(unsigned char *) buffer);\n  /*\n    Convert MIFF to X bitmap pixels.\n  */\n  (void) SetImageType(image,BilevelType,exception);\n  bit=0;\n  byte=0;\n  count=0;\n  x=0;\n  y=0;\n  (void) CopyMagickString(buffer,\" \",MagickPathExtent);\n  (void) WriteBlob(image,strlen(buffer),(unsigned char *) buffer);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      byte>>=1;\n      if (GetPixelLuma(image,p) < (QuantumRange/2))\n        byte|=0x80;\n      bit++;\n      if (bit == 8)\n        {\n          /*\n            Write a bitmap byte to the image file.\n          */\n          (void) FormatLocaleString(buffer,MagickPathExtent,\"0x%02X, \",\n            (unsigned int) (byte & 0xff));\n          (void) WriteBlob(image,strlen(buffer),(unsigned char *) buffer);\n          count++;\n          if (count == 12)\n            {\n              (void) CopyMagickString(buffer,\"\\n  \",MagickPathExtent);\n              (void) WriteBlob(image,strlen(buffer),(unsigned char *) buffer);\n              count=0;\n            };\n          bit=0;\n          byte=0;\n        }\n        p+=GetPixelChannels(image);\n      }\n    if (bit != 0)\n      {\n        /*\n          Write a bitmap byte to the image file.\n        */\n        byte>>=(8-bit);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"0x%02X, \",\n          (unsigned int) (byte & 0xff));\n        (void) WriteBlob(image,strlen(buffer),(unsigned char *) buffer);\n        count++;\n        if (count == 12)\n          {\n            (void) CopyMagickString(buffer,\"\\n  \",MagickPathExtent);\n            (void) WriteBlob(image,strlen(buffer),(unsigned char *) buffer);\n            count=0;\n          };\n        bit=0;\n        byte=0;\n      };\n    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  (void) CopyMagickString(buffer,\"};\\n\",MagickPathExtent);\n  (void) WriteBlob(image,strlen(buffer),(unsigned char *) buffer);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "filenames": ["coders/xbm.c"], "buggy_code_start_loc": [358], "buggy_code_end_loc": [369], "fixing_code_start_loc": [358], "fixing_code_end_loc": [375], "type": "CWE-200", "message": "ReadXBMImage in coders/xbm.c in ImageMagick before 7.0.8-9 leaves data uninitialized when processing an XBM file that has a negative pixel value. If the affected code is used as a library loaded into a process that includes sensitive information, that information sometimes can be leaked via the image data.", "other": {"cve": {"id": "CVE-2018-16323", "sourceIdentifier": "cve@mitre.org", "published": "2018-09-01T18:29:01.053", "lastModified": "2021-04-28T19:59:42.357", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ReadXBMImage in coders/xbm.c in ImageMagick before 7.0.8-9 leaves data uninitialized when processing an XBM file that has a negative pixel value. If the affected code is used as a library loaded into a process that includes sensitive information, that information sometimes can be leaked via the image data."}, {"lang": "es", "value": "ReadXBMImage en coders/xbm.c en ImageMagick en versiones anteriores a la 7.0.8-9 deja los datos sin inicializar al procesar un archivo XBM que tiene un valor de pixel negativo. Si el c\u00f3digo afectado se emplea como biblioteca cargada en un proceso que incluye informaci\u00f3n sensible, esa informaci\u00f3n a veces puede filtrarse mediante los datos de imagen."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.9.10-9", "matchCriteriaId": "176B2790-5140-4CA7-B6BA-7DAC4DCA39C3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.0.0-0", "versionEndExcluding": "7.0.8-9", "matchCriteriaId": "C48BBA9E-8F14-492B-A250-483B24E0AA75"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.10:*:*:*:*:*:*:*", "matchCriteriaId": "07C312A0-CD2C-4B9C-B064-6409B25C278F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.04:*:*:*:*:*:*:*", "matchCriteriaId": "CD783B0C-9246-47D9-A937-6144FE8BFF0F"}]}]}], "references": [{"url": "https://github.com/ImageMagick/ImageMagick/commit/216d117f05bff87b9dc4db55a1b1fadb38bcb786", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3785-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4034-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.exploit-db.com/exploits/45890/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/216d117f05bff87b9dc4db55a1b1fadb38bcb786"}}