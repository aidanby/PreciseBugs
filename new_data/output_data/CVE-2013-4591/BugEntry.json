{"buggy_code": ["/*\n *  fs/nfs/nfs4proc.c\n *\n *  Client-side procedure declarations for NFSv4.\n *\n *  Copyright (c) 2002 The Regents of the University of Michigan.\n *  All rights reserved.\n *\n *  Kendrick Smith <kmsmith@umich.edu>\n *  Andy Adamson   <andros@umich.edu>\n *\n *  Redistribution and use in source and binary forms, with or without\n *  modification, are permitted provided that the following conditions\n *  are met:\n *\n *  1. Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n *  2. Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *  3. Neither the name of the University nor the names of its\n *     contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED\n *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n *  DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n *  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <linux/mm.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/xattr.h>\n#include <linux/utsname.h>\n#include <linux/freezer.h>\n\n#include \"nfs4_fs.h\"\n#include \"delegation.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"callback.h\"\n#include \"pnfs.h\"\n#include \"netns.h\"\n\n#define NFSDBG_FACILITY\t\tNFSDBG_PROC\n\n#define NFS4_POLL_RETRY_MIN\t(HZ/10)\n#define NFS4_POLL_RETRY_MAX\t(15*HZ)\n\n#define NFS4_MAX_LOOP_ON_RECOVER (10)\n\nstruct nfs4_opendata;\nstatic int _nfs4_proc_open(struct nfs4_opendata *data);\nstatic int _nfs4_recover_proc_open(struct nfs4_opendata *data);\nstatic int nfs4_do_fsinfo(struct nfs_server *, struct nfs_fh *, struct nfs_fsinfo *);\nstatic int nfs4_async_handle_error(struct rpc_task *, const struct nfs_server *, struct nfs4_state *);\nstatic void nfs_fixup_referral_attributes(struct nfs_fattr *fattr);\nstatic int nfs4_proc_getattr(struct nfs_server *, struct nfs_fh *, struct nfs_fattr *);\nstatic int _nfs4_proc_getattr(struct nfs_server *server, struct nfs_fh *fhandle, struct nfs_fattr *fattr);\nstatic int nfs4_do_setattr(struct inode *inode, struct rpc_cred *cred,\n\t\t\t    struct nfs_fattr *fattr, struct iattr *sattr,\n\t\t\t    struct nfs4_state *state);\n#ifdef CONFIG_NFS_V4_1\nstatic int nfs41_test_stateid(struct nfs_server *, nfs4_stateid *);\nstatic int nfs41_free_stateid(struct nfs_server *, nfs4_stateid *);\n#endif\n/* Prevent leaks of NFSv4 errors into userland */\nstatic int nfs4_map_errors(int err)\n{\n\tif (err >= -1000)\n\t\treturn err;\n\tswitch (err) {\n\tcase -NFS4ERR_RESOURCE:\n\t\treturn -EREMOTEIO;\n\tcase -NFS4ERR_WRONGSEC:\n\t\treturn -EPERM;\n\tcase -NFS4ERR_BADOWNER:\n\tcase -NFS4ERR_BADNAME:\n\t\treturn -EINVAL;\n\tcase -NFS4ERR_SHARE_DENIED:\n\t\treturn -EACCES;\n\tcase -NFS4ERR_MINOR_VERS_MISMATCH:\n\t\treturn -EPROTONOSUPPORT;\n\tcase -NFS4ERR_ACCESS:\n\t\treturn -EACCES;\n\tdefault:\n\t\tdprintk(\"%s could not handle NFSv4 error %d\\n\",\n\t\t\t\t__func__, -err);\n\t\tbreak;\n\t}\n\treturn -EIO;\n}\n\n/*\n * This is our standard bitmap for GETATTR requests.\n */\nconst u32 nfs4_fattr_bitmap[3] = {\n\tFATTR4_WORD0_TYPE\n\t| FATTR4_WORD0_CHANGE\n\t| FATTR4_WORD0_SIZE\n\t| FATTR4_WORD0_FSID\n\t| FATTR4_WORD0_FILEID,\n\tFATTR4_WORD1_MODE\n\t| FATTR4_WORD1_NUMLINKS\n\t| FATTR4_WORD1_OWNER\n\t| FATTR4_WORD1_OWNER_GROUP\n\t| FATTR4_WORD1_RAWDEV\n\t| FATTR4_WORD1_SPACE_USED\n\t| FATTR4_WORD1_TIME_ACCESS\n\t| FATTR4_WORD1_TIME_METADATA\n\t| FATTR4_WORD1_TIME_MODIFY\n};\n\nstatic const u32 nfs4_pnfs_open_bitmap[3] = {\n\tFATTR4_WORD0_TYPE\n\t| FATTR4_WORD0_CHANGE\n\t| FATTR4_WORD0_SIZE\n\t| FATTR4_WORD0_FSID\n\t| FATTR4_WORD0_FILEID,\n\tFATTR4_WORD1_MODE\n\t| FATTR4_WORD1_NUMLINKS\n\t| FATTR4_WORD1_OWNER\n\t| FATTR4_WORD1_OWNER_GROUP\n\t| FATTR4_WORD1_RAWDEV\n\t| FATTR4_WORD1_SPACE_USED\n\t| FATTR4_WORD1_TIME_ACCESS\n\t| FATTR4_WORD1_TIME_METADATA\n\t| FATTR4_WORD1_TIME_MODIFY,\n\tFATTR4_WORD2_MDSTHRESHOLD\n};\n\nstatic const u32 nfs4_open_noattr_bitmap[3] = {\n\tFATTR4_WORD0_TYPE\n\t| FATTR4_WORD0_CHANGE\n\t| FATTR4_WORD0_FILEID,\n};\n\nconst u32 nfs4_statfs_bitmap[2] = {\n\tFATTR4_WORD0_FILES_AVAIL\n\t| FATTR4_WORD0_FILES_FREE\n\t| FATTR4_WORD0_FILES_TOTAL,\n\tFATTR4_WORD1_SPACE_AVAIL\n\t| FATTR4_WORD1_SPACE_FREE\n\t| FATTR4_WORD1_SPACE_TOTAL\n};\n\nconst u32 nfs4_pathconf_bitmap[2] = {\n\tFATTR4_WORD0_MAXLINK\n\t| FATTR4_WORD0_MAXNAME,\n\t0\n};\n\nconst u32 nfs4_fsinfo_bitmap[3] = { FATTR4_WORD0_MAXFILESIZE\n\t\t\t| FATTR4_WORD0_MAXREAD\n\t\t\t| FATTR4_WORD0_MAXWRITE\n\t\t\t| FATTR4_WORD0_LEASE_TIME,\n\t\t\tFATTR4_WORD1_TIME_DELTA\n\t\t\t| FATTR4_WORD1_FS_LAYOUT_TYPES,\n\t\t\tFATTR4_WORD2_LAYOUT_BLKSIZE\n};\n\nconst u32 nfs4_fs_locations_bitmap[2] = {\n\tFATTR4_WORD0_TYPE\n\t| FATTR4_WORD0_CHANGE\n\t| FATTR4_WORD0_SIZE\n\t| FATTR4_WORD0_FSID\n\t| FATTR4_WORD0_FILEID\n\t| FATTR4_WORD0_FS_LOCATIONS,\n\tFATTR4_WORD1_MODE\n\t| FATTR4_WORD1_NUMLINKS\n\t| FATTR4_WORD1_OWNER\n\t| FATTR4_WORD1_OWNER_GROUP\n\t| FATTR4_WORD1_RAWDEV\n\t| FATTR4_WORD1_SPACE_USED\n\t| FATTR4_WORD1_TIME_ACCESS\n\t| FATTR4_WORD1_TIME_METADATA\n\t| FATTR4_WORD1_TIME_MODIFY\n\t| FATTR4_WORD1_MOUNTED_ON_FILEID\n};\n\nstatic void nfs4_setup_readdir(u64 cookie, __be32 *verifier, struct dentry *dentry,\n\t\tstruct nfs4_readdir_arg *readdir)\n{\n\t__be32 *start, *p;\n\n\tBUG_ON(readdir->count < 80);\n\tif (cookie > 2) {\n\t\treaddir->cookie = cookie;\n\t\tmemcpy(&readdir->verifier, verifier, sizeof(readdir->verifier));\n\t\treturn;\n\t}\n\n\treaddir->cookie = 0;\n\tmemset(&readdir->verifier, 0, sizeof(readdir->verifier));\n\tif (cookie == 2)\n\t\treturn;\n\t\n\t/*\n\t * NFSv4 servers do not return entries for '.' and '..'\n\t * Therefore, we fake these entries here.  We let '.'\n\t * have cookie 0 and '..' have cookie 1.  Note that\n\t * when talking to the server, we always send cookie 0\n\t * instead of 1 or 2.\n\t */\n\tstart = p = kmap_atomic(*readdir->pages);\n\t\n\tif (cookie == 0) {\n\t\t*p++ = xdr_one;                                  /* next */\n\t\t*p++ = xdr_zero;                   /* cookie, first word */\n\t\t*p++ = xdr_one;                   /* cookie, second word */\n\t\t*p++ = xdr_one;                             /* entry len */\n\t\tmemcpy(p, \".\\0\\0\\0\", 4);                        /* entry */\n\t\tp++;\n\t\t*p++ = xdr_one;                         /* bitmap length */\n\t\t*p++ = htonl(FATTR4_WORD0_FILEID);             /* bitmap */\n\t\t*p++ = htonl(8);              /* attribute buffer length */\n\t\tp = xdr_encode_hyper(p, NFS_FILEID(dentry->d_inode));\n\t}\n\t\n\t*p++ = xdr_one;                                  /* next */\n\t*p++ = xdr_zero;                   /* cookie, first word */\n\t*p++ = xdr_two;                   /* cookie, second word */\n\t*p++ = xdr_two;                             /* entry len */\n\tmemcpy(p, \"..\\0\\0\", 4);                         /* entry */\n\tp++;\n\t*p++ = xdr_one;                         /* bitmap length */\n\t*p++ = htonl(FATTR4_WORD0_FILEID);             /* bitmap */\n\t*p++ = htonl(8);              /* attribute buffer length */\n\tp = xdr_encode_hyper(p, NFS_FILEID(dentry->d_parent->d_inode));\n\n\treaddir->pgbase = (char *)p - (char *)start;\n\treaddir->count -= readdir->pgbase;\n\tkunmap_atomic(start);\n}\n\nstatic int nfs4_wait_clnt_recover(struct nfs_client *clp)\n{\n\tint res;\n\n\tmight_sleep();\n\n\tres = wait_on_bit(&clp->cl_state, NFS4CLNT_MANAGER_RUNNING,\n\t\t\tnfs_wait_bit_killable, TASK_KILLABLE);\n\tif (res)\n\t\treturn res;\n\n\tif (clp->cl_cons_state < 0)\n\t\treturn clp->cl_cons_state;\n\treturn 0;\n}\n\nstatic int nfs4_delay(struct rpc_clnt *clnt, long *timeout)\n{\n\tint res = 0;\n\n\tmight_sleep();\n\n\tif (*timeout <= 0)\n\t\t*timeout = NFS4_POLL_RETRY_MIN;\n\tif (*timeout > NFS4_POLL_RETRY_MAX)\n\t\t*timeout = NFS4_POLL_RETRY_MAX;\n\tfreezable_schedule_timeout_killable(*timeout);\n\tif (fatal_signal_pending(current))\n\t\tres = -ERESTARTSYS;\n\t*timeout <<= 1;\n\treturn res;\n}\n\n/* This is the error handling routine for processes that are allowed\n * to sleep.\n */\nstatic int nfs4_handle_exception(struct nfs_server *server, int errorcode, struct nfs4_exception *exception)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs4_state *state = exception->state;\n\tstruct inode *inode = exception->inode;\n\tint ret = errorcode;\n\n\texception->retry = 0;\n\tswitch(errorcode) {\n\t\tcase 0:\n\t\t\treturn 0;\n\t\tcase -NFS4ERR_OPENMODE:\n\t\t\tif (inode && nfs4_have_delegation(inode, FMODE_READ)) {\n\t\t\t\tnfs4_inode_return_delegation(inode);\n\t\t\t\texception->retry = 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (state == NULL)\n\t\t\t\tbreak;\n\t\t\tnfs4_schedule_stateid_recovery(server, state);\n\t\t\tgoto wait_on_recovery;\n\t\tcase -NFS4ERR_DELEG_REVOKED:\n\t\tcase -NFS4ERR_ADMIN_REVOKED:\n\t\tcase -NFS4ERR_BAD_STATEID:\n\t\t\tif (state == NULL)\n\t\t\t\tbreak;\n\t\t\tnfs_remove_bad_delegation(state->inode);\n\t\t\tnfs4_schedule_stateid_recovery(server, state);\n\t\t\tgoto wait_on_recovery;\n\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tif (state != NULL)\n\t\t\t\tnfs4_schedule_stateid_recovery(server, state);\n\t\tcase -NFS4ERR_STALE_STATEID:\n\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\t\tnfs4_schedule_lease_recovery(clp);\n\t\t\tgoto wait_on_recovery;\n#if defined(CONFIG_NFS_V4_1)\n\t\tcase -NFS4ERR_BADSESSION:\n\t\tcase -NFS4ERR_BADSLOT:\n\t\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\t\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\tcase -NFS4ERR_DEADSESSION:\n\t\tcase -NFS4ERR_SEQ_FALSE_RETRY:\n\t\tcase -NFS4ERR_SEQ_MISORDERED:\n\t\t\tdprintk(\"%s ERROR: %d Reset session\\n\", __func__,\n\t\t\t\terrorcode);\n\t\t\tnfs4_schedule_session_recovery(clp->cl_session, errorcode);\n\t\t\tgoto wait_on_recovery;\n#endif /* defined(CONFIG_NFS_V4_1) */\n\t\tcase -NFS4ERR_FILE_OPEN:\n\t\t\tif (exception->timeout > HZ) {\n\t\t\t\t/* We have retried a decent amount, time to\n\t\t\t\t * fail\n\t\t\t\t */\n\t\t\t\tret = -EBUSY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase -NFS4ERR_GRACE:\n\t\tcase -NFS4ERR_DELAY:\n\t\tcase -EKEYEXPIRED:\n\t\t\tret = nfs4_delay(server->client, &exception->timeout);\n\t\t\tif (ret != 0)\n\t\t\t\tbreak;\n\t\tcase -NFS4ERR_RETRY_UNCACHED_REP:\n\t\tcase -NFS4ERR_OLD_STATEID:\n\t\t\texception->retry = 1;\n\t\t\tbreak;\n\t\tcase -NFS4ERR_BADOWNER:\n\t\t\t/* The following works around a Linux server bug! */\n\t\tcase -NFS4ERR_BADNAME:\n\t\t\tif (server->caps & NFS_CAP_UIDGID_NOMAP) {\n\t\t\t\tserver->caps &= ~NFS_CAP_UIDGID_NOMAP;\n\t\t\t\texception->retry = 1;\n\t\t\t\tprintk(KERN_WARNING \"NFS: v4 server %s \"\n\t\t\t\t\t\t\"does not accept raw \"\n\t\t\t\t\t\t\"uid/gids. \"\n\t\t\t\t\t\t\"Reenabling the idmapper.\\n\",\n\t\t\t\t\t\tserver->nfs_client->cl_hostname);\n\t\t\t}\n\t}\n\t/* We failed to handle the error */\n\treturn nfs4_map_errors(ret);\nwait_on_recovery:\n\tret = nfs4_wait_clnt_recover(clp);\n\tif (ret == 0)\n\t\texception->retry = 1;\n\treturn ret;\n}\n\n\nstatic void do_renew_lease(struct nfs_client *clp, unsigned long timestamp)\n{\n\tspin_lock(&clp->cl_lock);\n\tif (time_before(clp->cl_last_renewal,timestamp))\n\t\tclp->cl_last_renewal = timestamp;\n\tspin_unlock(&clp->cl_lock);\n}\n\nstatic void renew_lease(const struct nfs_server *server, unsigned long timestamp)\n{\n\tdo_renew_lease(server->nfs_client, timestamp);\n}\n\n#if defined(CONFIG_NFS_V4_1)\n\n/*\n * nfs4_free_slot - free a slot and efficiently update slot table.\n *\n * freeing a slot is trivially done by clearing its respective bit\n * in the bitmap.\n * If the freed slotid equals highest_used_slotid we want to update it\n * so that the server would be able to size down the slot table if needed,\n * otherwise we know that the highest_used_slotid is still in use.\n * When updating highest_used_slotid there may be \"holes\" in the bitmap\n * so we need to scan down from highest_used_slotid to 0 looking for the now\n * highest slotid in use.\n * If none found, highest_used_slotid is set to NFS4_NO_SLOT.\n *\n * Must be called while holding tbl->slot_tbl_lock\n */\nstatic void\nnfs4_free_slot(struct nfs4_slot_table *tbl, u32 slotid)\n{\n\tBUG_ON(slotid >= NFS4_MAX_SLOT_TABLE);\n\t/* clear used bit in bitmap */\n\t__clear_bit(slotid, tbl->used_slots);\n\n\t/* update highest_used_slotid when it is freed */\n\tif (slotid == tbl->highest_used_slotid) {\n\t\tslotid = find_last_bit(tbl->used_slots, tbl->max_slots);\n\t\tif (slotid < tbl->max_slots)\n\t\t\ttbl->highest_used_slotid = slotid;\n\t\telse\n\t\t\ttbl->highest_used_slotid = NFS4_NO_SLOT;\n\t}\n\tdprintk(\"%s: slotid %u highest_used_slotid %d\\n\", __func__,\n\t\tslotid, tbl->highest_used_slotid);\n}\n\nbool nfs4_set_task_privileged(struct rpc_task *task, void *dummy)\n{\n\trpc_task_set_priority(task, RPC_PRIORITY_PRIVILEGED);\n\treturn true;\n}\n\n/*\n * Signal state manager thread if session fore channel is drained\n */\nstatic void nfs4_check_drain_fc_complete(struct nfs4_session *ses)\n{\n\tif (!test_bit(NFS4_SESSION_DRAINING, &ses->session_state)) {\n\t\trpc_wake_up_first(&ses->fc_slot_table.slot_tbl_waitq,\n\t\t\t\tnfs4_set_task_privileged, NULL);\n\t\treturn;\n\t}\n\n\tif (ses->fc_slot_table.highest_used_slotid != NFS4_NO_SLOT)\n\t\treturn;\n\n\tdprintk(\"%s COMPLETE: Session Fore Channel Drained\\n\", __func__);\n\tcomplete(&ses->fc_slot_table.complete);\n}\n\n/*\n * Signal state manager thread if session back channel is drained\n */\nvoid nfs4_check_drain_bc_complete(struct nfs4_session *ses)\n{\n\tif (!test_bit(NFS4_SESSION_DRAINING, &ses->session_state) ||\n\t    ses->bc_slot_table.highest_used_slotid != NFS4_NO_SLOT)\n\t\treturn;\n\tdprintk(\"%s COMPLETE: Session Back Channel Drained\\n\", __func__);\n\tcomplete(&ses->bc_slot_table.complete);\n}\n\nstatic void nfs41_sequence_free_slot(struct nfs4_sequence_res *res)\n{\n\tstruct nfs4_slot_table *tbl;\n\n\ttbl = &res->sr_session->fc_slot_table;\n\tif (!res->sr_slot) {\n\t\t/* just wake up the next guy waiting since\n\t\t * we may have not consumed a slot after all */\n\t\tdprintk(\"%s: No slot\\n\", __func__);\n\t\treturn;\n\t}\n\n\tspin_lock(&tbl->slot_tbl_lock);\n\tnfs4_free_slot(tbl, res->sr_slot - tbl->slots);\n\tnfs4_check_drain_fc_complete(res->sr_session);\n\tspin_unlock(&tbl->slot_tbl_lock);\n\tres->sr_slot = NULL;\n}\n\nstatic int nfs41_sequence_done(struct rpc_task *task, struct nfs4_sequence_res *res)\n{\n\tunsigned long timestamp;\n\tstruct nfs_client *clp;\n\n\t/*\n\t * sr_status remains 1 if an RPC level error occurred. The server\n\t * may or may not have processed the sequence operation..\n\t * Proceed as if the server received and processed the sequence\n\t * operation.\n\t */\n\tif (res->sr_status == 1)\n\t\tres->sr_status = NFS_OK;\n\n\t/* don't increment the sequence number if the task wasn't sent */\n\tif (!RPC_WAS_SENT(task))\n\t\tgoto out;\n\n\t/* Check the SEQUENCE operation status */\n\tswitch (res->sr_status) {\n\tcase 0:\n\t\t/* Update the slot's sequence and clientid lease timer */\n\t\t++res->sr_slot->seq_nr;\n\t\ttimestamp = res->sr_renewal_time;\n\t\tclp = res->sr_session->clp;\n\t\tdo_renew_lease(clp, timestamp);\n\t\t/* Check sequence flags */\n\t\tif (res->sr_status_flags != 0)\n\t\t\tnfs4_schedule_lease_recovery(clp);\n\t\tbreak;\n\tcase -NFS4ERR_DELAY:\n\t\t/* The server detected a resend of the RPC call and\n\t\t * returned NFS4ERR_DELAY as per Section 2.10.6.2\n\t\t * of RFC5661.\n\t\t */\n\t\tdprintk(\"%s: slot=%td seq=%d: Operation in progress\\n\",\n\t\t\t__func__,\n\t\t\tres->sr_slot - res->sr_session->fc_slot_table.slots,\n\t\t\tres->sr_slot->seq_nr);\n\t\tgoto out_retry;\n\tdefault:\n\t\t/* Just update the slot sequence no. */\n\t\t++res->sr_slot->seq_nr;\n\t}\nout:\n\t/* The session may be reset by one of the error handlers. */\n\tdprintk(\"%s: Error %d free the slot \\n\", __func__, res->sr_status);\n\tnfs41_sequence_free_slot(res);\n\treturn 1;\nout_retry:\n\tif (!rpc_restart_call(task))\n\t\tgoto out;\n\trpc_delay(task, NFS4_POLL_RETRY_MAX);\n\treturn 0;\n}\n\nstatic int nfs4_sequence_done(struct rpc_task *task,\n\t\t\t       struct nfs4_sequence_res *res)\n{\n\tif (res->sr_session == NULL)\n\t\treturn 1;\n\treturn nfs41_sequence_done(task, res);\n}\n\n/*\n * nfs4_find_slot - efficiently look for a free slot\n *\n * nfs4_find_slot looks for an unset bit in the used_slots bitmap.\n * If found, we mark the slot as used, update the highest_used_slotid,\n * and respectively set up the sequence operation args.\n * The slot number is returned if found, or NFS4_NO_SLOT otherwise.\n *\n * Note: must be called with under the slot_tbl_lock.\n */\nstatic u32\nnfs4_find_slot(struct nfs4_slot_table *tbl)\n{\n\tu32 slotid;\n\tu32 ret_id = NFS4_NO_SLOT;\n\n\tdprintk(\"--> %s used_slots=%04lx highest_used=%u max_slots=%u\\n\",\n\t\t__func__, tbl->used_slots[0], tbl->highest_used_slotid,\n\t\ttbl->max_slots);\n\tslotid = find_first_zero_bit(tbl->used_slots, tbl->max_slots);\n\tif (slotid >= tbl->max_slots)\n\t\tgoto out;\n\t__set_bit(slotid, tbl->used_slots);\n\tif (slotid > tbl->highest_used_slotid ||\n\t\t\ttbl->highest_used_slotid == NFS4_NO_SLOT)\n\t\ttbl->highest_used_slotid = slotid;\n\tret_id = slotid;\nout:\n\tdprintk(\"<-- %s used_slots=%04lx highest_used=%d slotid=%d \\n\",\n\t\t__func__, tbl->used_slots[0], tbl->highest_used_slotid, ret_id);\n\treturn ret_id;\n}\n\nstatic void nfs41_init_sequence(struct nfs4_sequence_args *args,\n\t\tstruct nfs4_sequence_res *res, int cache_reply)\n{\n\targs->sa_session = NULL;\n\targs->sa_cache_this = 0;\n\tif (cache_reply)\n\t\targs->sa_cache_this = 1;\n\tres->sr_session = NULL;\n\tres->sr_slot = NULL;\n}\n\nint nfs41_setup_sequence(struct nfs4_session *session,\n\t\t\t\tstruct nfs4_sequence_args *args,\n\t\t\t\tstruct nfs4_sequence_res *res,\n\t\t\t\tstruct rpc_task *task)\n{\n\tstruct nfs4_slot *slot;\n\tstruct nfs4_slot_table *tbl;\n\tu32 slotid;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\t/* slot already allocated? */\n\tif (res->sr_slot != NULL)\n\t\treturn 0;\n\n\ttbl = &session->fc_slot_table;\n\n\tspin_lock(&tbl->slot_tbl_lock);\n\tif (test_bit(NFS4_SESSION_DRAINING, &session->session_state) &&\n\t    !rpc_task_has_priority(task, RPC_PRIORITY_PRIVILEGED)) {\n\t\t/* The state manager will wait until the slot table is empty */\n\t\trpc_sleep_on(&tbl->slot_tbl_waitq, task, NULL);\n\t\tspin_unlock(&tbl->slot_tbl_lock);\n\t\tdprintk(\"%s session is draining\\n\", __func__);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (!rpc_queue_empty(&tbl->slot_tbl_waitq) &&\n\t    !rpc_task_has_priority(task, RPC_PRIORITY_PRIVILEGED)) {\n\t\trpc_sleep_on(&tbl->slot_tbl_waitq, task, NULL);\n\t\tspin_unlock(&tbl->slot_tbl_lock);\n\t\tdprintk(\"%s enforce FIFO order\\n\", __func__);\n\t\treturn -EAGAIN;\n\t}\n\n\tslotid = nfs4_find_slot(tbl);\n\tif (slotid == NFS4_NO_SLOT) {\n\t\trpc_sleep_on(&tbl->slot_tbl_waitq, task, NULL);\n\t\tspin_unlock(&tbl->slot_tbl_lock);\n\t\tdprintk(\"<-- %s: no free slots\\n\", __func__);\n\t\treturn -EAGAIN;\n\t}\n\tspin_unlock(&tbl->slot_tbl_lock);\n\n\trpc_task_set_priority(task, RPC_PRIORITY_NORMAL);\n\tslot = tbl->slots + slotid;\n\targs->sa_session = session;\n\targs->sa_slotid = slotid;\n\n\tdprintk(\"<-- %s slotid=%d seqid=%d\\n\", __func__, slotid, slot->seq_nr);\n\n\tres->sr_session = session;\n\tres->sr_slot = slot;\n\tres->sr_renewal_time = jiffies;\n\tres->sr_status_flags = 0;\n\t/*\n\t * sr_status is only set in decode_sequence, and so will remain\n\t * set to 1 if an rpc level failure occurs.\n\t */\n\tres->sr_status = 1;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nfs41_setup_sequence);\n\nint nfs4_setup_sequence(const struct nfs_server *server,\n\t\t\tstruct nfs4_sequence_args *args,\n\t\t\tstruct nfs4_sequence_res *res,\n\t\t\tstruct rpc_task *task)\n{\n\tstruct nfs4_session *session = nfs4_get_session(server);\n\tint ret = 0;\n\n\tif (session == NULL)\n\t\tgoto out;\n\n\tdprintk(\"--> %s clp %p session %p sr_slot %td\\n\",\n\t\t__func__, session->clp, session, res->sr_slot ?\n\t\t\tres->sr_slot - session->fc_slot_table.slots : -1);\n\n\tret = nfs41_setup_sequence(session, args, res, task);\nout:\n\tdprintk(\"<-- %s status=%d\\n\", __func__, ret);\n\treturn ret;\n}\n\nstruct nfs41_call_sync_data {\n\tconst struct nfs_server *seq_server;\n\tstruct nfs4_sequence_args *seq_args;\n\tstruct nfs4_sequence_res *seq_res;\n};\n\nstatic void nfs41_call_sync_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs41_call_sync_data *data = calldata;\n\n\tdprintk(\"--> %s data->seq_server %p\\n\", __func__, data->seq_server);\n\n\tif (nfs4_setup_sequence(data->seq_server, data->seq_args,\n\t\t\t\tdata->seq_res, task))\n\t\treturn;\n\trpc_call_start(task);\n}\n\nstatic void nfs41_call_priv_sync_prepare(struct rpc_task *task, void *calldata)\n{\n\trpc_task_set_priority(task, RPC_PRIORITY_PRIVILEGED);\n\tnfs41_call_sync_prepare(task, calldata);\n}\n\nstatic void nfs41_call_sync_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs41_call_sync_data *data = calldata;\n\n\tnfs41_sequence_done(task, data->seq_res);\n}\n\nstatic const struct rpc_call_ops nfs41_call_sync_ops = {\n\t.rpc_call_prepare = nfs41_call_sync_prepare,\n\t.rpc_call_done = nfs41_call_sync_done,\n};\n\nstatic const struct rpc_call_ops nfs41_call_priv_sync_ops = {\n\t.rpc_call_prepare = nfs41_call_priv_sync_prepare,\n\t.rpc_call_done = nfs41_call_sync_done,\n};\n\nstatic int nfs4_call_sync_sequence(struct rpc_clnt *clnt,\n\t\t\t\t   struct nfs_server *server,\n\t\t\t\t   struct rpc_message *msg,\n\t\t\t\t   struct nfs4_sequence_args *args,\n\t\t\t\t   struct nfs4_sequence_res *res,\n\t\t\t\t   int privileged)\n{\n\tint ret;\n\tstruct rpc_task *task;\n\tstruct nfs41_call_sync_data data = {\n\t\t.seq_server = server,\n\t\t.seq_args = args,\n\t\t.seq_res = res,\n\t};\n\tstruct rpc_task_setup task_setup = {\n\t\t.rpc_client = clnt,\n\t\t.rpc_message = msg,\n\t\t.callback_ops = &nfs41_call_sync_ops,\n\t\t.callback_data = &data\n\t};\n\n\tif (privileged)\n\t\ttask_setup.callback_ops = &nfs41_call_priv_sync_ops;\n\ttask = rpc_run_task(&task_setup);\n\tif (IS_ERR(task))\n\t\tret = PTR_ERR(task);\n\telse {\n\t\tret = task->tk_status;\n\t\trpc_put_task(task);\n\t}\n\treturn ret;\n}\n\nint _nfs4_call_sync_session(struct rpc_clnt *clnt,\n\t\t\t    struct nfs_server *server,\n\t\t\t    struct rpc_message *msg,\n\t\t\t    struct nfs4_sequence_args *args,\n\t\t\t    struct nfs4_sequence_res *res,\n\t\t\t    int cache_reply)\n{\n\tnfs41_init_sequence(args, res, cache_reply);\n\treturn nfs4_call_sync_sequence(clnt, server, msg, args, res, 0);\n}\n\n#else\nstatic inline\nvoid nfs41_init_sequence(struct nfs4_sequence_args *args,\n\t\tstruct nfs4_sequence_res *res, int cache_reply)\n{\n}\n\nstatic int nfs4_sequence_done(struct rpc_task *task,\n\t\t\t       struct nfs4_sequence_res *res)\n{\n\treturn 1;\n}\n#endif /* CONFIG_NFS_V4_1 */\n\nint _nfs4_call_sync(struct rpc_clnt *clnt,\n\t\t    struct nfs_server *server,\n\t\t    struct rpc_message *msg,\n\t\t    struct nfs4_sequence_args *args,\n\t\t    struct nfs4_sequence_res *res,\n\t\t    int cache_reply)\n{\n\tnfs41_init_sequence(args, res, cache_reply);\n\treturn rpc_call_sync(clnt, msg, 0);\n}\n\nstatic inline\nint nfs4_call_sync(struct rpc_clnt *clnt,\n\t\t   struct nfs_server *server,\n\t\t   struct rpc_message *msg,\n\t\t   struct nfs4_sequence_args *args,\n\t\t   struct nfs4_sequence_res *res,\n\t\t   int cache_reply)\n{\n\treturn server->nfs_client->cl_mvops->call_sync(clnt, server, msg,\n\t\t\t\t\t\targs, res, cache_reply);\n}\n\nstatic void update_changeattr(struct inode *dir, struct nfs4_change_info *cinfo)\n{\n\tstruct nfs_inode *nfsi = NFS_I(dir);\n\n\tspin_lock(&dir->i_lock);\n\tnfsi->cache_validity |= NFS_INO_INVALID_ATTR|NFS_INO_INVALID_DATA;\n\tif (!cinfo->atomic || cinfo->before != dir->i_version)\n\t\tnfs_force_lookup_revalidate(dir);\n\tdir->i_version = cinfo->after;\n\tspin_unlock(&dir->i_lock);\n}\n\nstruct nfs4_opendata {\n\tstruct kref kref;\n\tstruct nfs_openargs o_arg;\n\tstruct nfs_openres o_res;\n\tstruct nfs_open_confirmargs c_arg;\n\tstruct nfs_open_confirmres c_res;\n\tstruct nfs4_string owner_name;\n\tstruct nfs4_string group_name;\n\tstruct nfs_fattr f_attr;\n\tstruct dentry *dir;\n\tstruct dentry *dentry;\n\tstruct nfs4_state_owner *owner;\n\tstruct nfs4_state *state;\n\tstruct iattr attrs;\n\tunsigned long timestamp;\n\tunsigned int rpc_done : 1;\n\tint rpc_status;\n\tint cancelled;\n};\n\n\nstatic void nfs4_init_opendata_res(struct nfs4_opendata *p)\n{\n\tp->o_res.f_attr = &p->f_attr;\n\tp->o_res.seqid = p->o_arg.seqid;\n\tp->c_res.seqid = p->c_arg.seqid;\n\tp->o_res.server = p->o_arg.server;\n\tp->o_res.access_request = p->o_arg.access;\n\tnfs_fattr_init(&p->f_attr);\n\tnfs_fattr_init_names(&p->f_attr, &p->owner_name, &p->group_name);\n}\n\nstatic struct nfs4_opendata *nfs4_opendata_alloc(struct dentry *dentry,\n\t\tstruct nfs4_state_owner *sp, fmode_t fmode, int flags,\n\t\tconst struct iattr *attrs,\n\t\tgfp_t gfp_mask)\n{\n\tstruct dentry *parent = dget_parent(dentry);\n\tstruct inode *dir = parent->d_inode;\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tstruct nfs4_opendata *p;\n\n\tp = kzalloc(sizeof(*p), gfp_mask);\n\tif (p == NULL)\n\t\tgoto err;\n\tp->o_arg.seqid = nfs_alloc_seqid(&sp->so_seqid, gfp_mask);\n\tif (p->o_arg.seqid == NULL)\n\t\tgoto err_free;\n\tnfs_sb_active(dentry->d_sb);\n\tp->dentry = dget(dentry);\n\tp->dir = parent;\n\tp->owner = sp;\n\tatomic_inc(&sp->so_count);\n\tp->o_arg.fh = NFS_FH(dir);\n\tp->o_arg.open_flags = flags;\n\tp->o_arg.fmode = fmode & (FMODE_READ|FMODE_WRITE);\n\t/* don't put an ACCESS op in OPEN compound if O_EXCL, because ACCESS\n\t * will return permission denied for all bits until close */\n\tif (!(flags & O_EXCL)) {\n\t\t/* ask server to check for all possible rights as results\n\t\t * are cached */\n\t\tp->o_arg.access = NFS4_ACCESS_READ | NFS4_ACCESS_MODIFY |\n\t\t\t\t  NFS4_ACCESS_EXTEND | NFS4_ACCESS_EXECUTE;\n\t}\n\tp->o_arg.clientid = server->nfs_client->cl_clientid;\n\tp->o_arg.id.create_time = ktime_to_ns(sp->so_seqid.create_time);\n\tp->o_arg.id.uniquifier = sp->so_seqid.owner_id;\n\tp->o_arg.name = &dentry->d_name;\n\tp->o_arg.server = server;\n\tp->o_arg.bitmask = server->attr_bitmask;\n\tp->o_arg.open_bitmap = &nfs4_fattr_bitmap[0];\n\tp->o_arg.claim = NFS4_OPEN_CLAIM_NULL;\n\tif (attrs != NULL && attrs->ia_valid != 0) {\n\t\t__be32 verf[2];\n\n\t\tp->o_arg.u.attrs = &p->attrs;\n\t\tmemcpy(&p->attrs, attrs, sizeof(p->attrs));\n\n\t\tverf[0] = jiffies;\n\t\tverf[1] = current->pid;\n\t\tmemcpy(p->o_arg.u.verifier.data, verf,\n\t\t\t\tsizeof(p->o_arg.u.verifier.data));\n\t}\n\tp->c_arg.fh = &p->o_res.fh;\n\tp->c_arg.stateid = &p->o_res.stateid;\n\tp->c_arg.seqid = p->o_arg.seqid;\n\tnfs4_init_opendata_res(p);\n\tkref_init(&p->kref);\n\treturn p;\nerr_free:\n\tkfree(p);\nerr:\n\tdput(parent);\n\treturn NULL;\n}\n\nstatic void nfs4_opendata_free(struct kref *kref)\n{\n\tstruct nfs4_opendata *p = container_of(kref,\n\t\t\tstruct nfs4_opendata, kref);\n\tstruct super_block *sb = p->dentry->d_sb;\n\n\tnfs_free_seqid(p->o_arg.seqid);\n\tif (p->state != NULL)\n\t\tnfs4_put_open_state(p->state);\n\tnfs4_put_state_owner(p->owner);\n\tdput(p->dir);\n\tdput(p->dentry);\n\tnfs_sb_deactive(sb);\n\tnfs_fattr_free_names(&p->f_attr);\n\tkfree(p);\n}\n\nstatic void nfs4_opendata_put(struct nfs4_opendata *p)\n{\n\tif (p != NULL)\n\t\tkref_put(&p->kref, nfs4_opendata_free);\n}\n\nstatic int nfs4_wait_for_completion_rpc_task(struct rpc_task *task)\n{\n\tint ret;\n\n\tret = rpc_wait_for_completion_task(task);\n\treturn ret;\n}\n\nstatic int can_open_cached(struct nfs4_state *state, fmode_t mode, int open_mode)\n{\n\tint ret = 0;\n\n\tif (open_mode & (O_EXCL|O_TRUNC))\n\t\tgoto out;\n\tswitch (mode & (FMODE_READ|FMODE_WRITE)) {\n\t\tcase FMODE_READ:\n\t\t\tret |= test_bit(NFS_O_RDONLY_STATE, &state->flags) != 0\n\t\t\t\t&& state->n_rdonly != 0;\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tret |= test_bit(NFS_O_WRONLY_STATE, &state->flags) != 0\n\t\t\t\t&& state->n_wronly != 0;\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tret |= test_bit(NFS_O_RDWR_STATE, &state->flags) != 0\n\t\t\t\t&& state->n_rdwr != 0;\n\t}\nout:\n\treturn ret;\n}\n\nstatic int can_open_delegated(struct nfs_delegation *delegation, fmode_t fmode)\n{\n\tif (delegation == NULL)\n\t\treturn 0;\n\tif ((delegation->type & fmode) != fmode)\n\t\treturn 0;\n\tif (test_bit(NFS_DELEGATION_NEED_RECLAIM, &delegation->flags))\n\t\treturn 0;\n\tnfs_mark_delegation_referenced(delegation);\n\treturn 1;\n}\n\nstatic void update_open_stateflags(struct nfs4_state *state, fmode_t fmode)\n{\n\tswitch (fmode) {\n\t\tcase FMODE_WRITE:\n\t\t\tstate->n_wronly++;\n\t\t\tbreak;\n\t\tcase FMODE_READ:\n\t\t\tstate->n_rdonly++;\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tstate->n_rdwr++;\n\t}\n\tnfs4_state_set_mode_locked(state, state->state | fmode);\n}\n\nstatic void nfs_set_open_stateid_locked(struct nfs4_state *state, nfs4_stateid *stateid, fmode_t fmode)\n{\n\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) == 0)\n\t\tnfs4_stateid_copy(&state->stateid, stateid);\n\tnfs4_stateid_copy(&state->open_stateid, stateid);\n\tswitch (fmode) {\n\t\tcase FMODE_READ:\n\t\t\tset_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tset_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tset_bit(NFS_O_RDWR_STATE, &state->flags);\n\t}\n}\n\nstatic void nfs_set_open_stateid(struct nfs4_state *state, nfs4_stateid *stateid, fmode_t fmode)\n{\n\twrite_seqlock(&state->seqlock);\n\tnfs_set_open_stateid_locked(state, stateid, fmode);\n\twrite_sequnlock(&state->seqlock);\n}\n\nstatic void __update_open_stateid(struct nfs4_state *state, nfs4_stateid *open_stateid, const nfs4_stateid *deleg_stateid, fmode_t fmode)\n{\n\t/*\n\t * Protect the call to nfs4_state_set_mode_locked and\n\t * serialise the stateid update\n\t */\n\twrite_seqlock(&state->seqlock);\n\tif (deleg_stateid != NULL) {\n\t\tnfs4_stateid_copy(&state->stateid, deleg_stateid);\n\t\tset_bit(NFS_DELEGATED_STATE, &state->flags);\n\t}\n\tif (open_stateid != NULL)\n\t\tnfs_set_open_stateid_locked(state, open_stateid, fmode);\n\twrite_sequnlock(&state->seqlock);\n\tspin_lock(&state->owner->so_lock);\n\tupdate_open_stateflags(state, fmode);\n\tspin_unlock(&state->owner->so_lock);\n}\n\nstatic int update_open_stateid(struct nfs4_state *state, nfs4_stateid *open_stateid, nfs4_stateid *delegation, fmode_t fmode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(state->inode);\n\tstruct nfs_delegation *deleg_cur;\n\tint ret = 0;\n\n\tfmode &= (FMODE_READ|FMODE_WRITE);\n\n\trcu_read_lock();\n\tdeleg_cur = rcu_dereference(nfsi->delegation);\n\tif (deleg_cur == NULL)\n\t\tgoto no_delegation;\n\n\tspin_lock(&deleg_cur->lock);\n\tif (nfsi->delegation != deleg_cur ||\n\t    (deleg_cur->type & fmode) != fmode)\n\t\tgoto no_delegation_unlock;\n\n\tif (delegation == NULL)\n\t\tdelegation = &deleg_cur->stateid;\n\telse if (!nfs4_stateid_match(&deleg_cur->stateid, delegation))\n\t\tgoto no_delegation_unlock;\n\n\tnfs_mark_delegation_referenced(deleg_cur);\n\t__update_open_stateid(state, open_stateid, &deleg_cur->stateid, fmode);\n\tret = 1;\nno_delegation_unlock:\n\tspin_unlock(&deleg_cur->lock);\nno_delegation:\n\trcu_read_unlock();\n\n\tif (!ret && open_stateid != NULL) {\n\t\t__update_open_stateid(state, open_stateid, NULL, fmode);\n\t\tret = 1;\n\t}\n\n\treturn ret;\n}\n\n\nstatic void nfs4_return_incompatible_delegation(struct inode *inode, fmode_t fmode)\n{\n\tstruct nfs_delegation *delegation;\n\n\trcu_read_lock();\n\tdelegation = rcu_dereference(NFS_I(inode)->delegation);\n\tif (delegation == NULL || (delegation->type & fmode) == fmode) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\trcu_read_unlock();\n\tnfs4_inode_return_delegation(inode);\n}\n\nstatic struct nfs4_state *nfs4_try_open_cached(struct nfs4_opendata *opendata)\n{\n\tstruct nfs4_state *state = opendata->state;\n\tstruct nfs_inode *nfsi = NFS_I(state->inode);\n\tstruct nfs_delegation *delegation;\n\tint open_mode = opendata->o_arg.open_flags & (O_EXCL|O_TRUNC);\n\tfmode_t fmode = opendata->o_arg.fmode;\n\tnfs4_stateid stateid;\n\tint ret = -EAGAIN;\n\n\tfor (;;) {\n\t\tif (can_open_cached(state, fmode, open_mode)) {\n\t\t\tspin_lock(&state->owner->so_lock);\n\t\t\tif (can_open_cached(state, fmode, open_mode)) {\n\t\t\t\tupdate_open_stateflags(state, fmode);\n\t\t\t\tspin_unlock(&state->owner->so_lock);\n\t\t\t\tgoto out_return_state;\n\t\t\t}\n\t\t\tspin_unlock(&state->owner->so_lock);\n\t\t}\n\t\trcu_read_lock();\n\t\tdelegation = rcu_dereference(nfsi->delegation);\n\t\tif (!can_open_delegated(delegation, fmode)) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\t\t/* Save the delegation */\n\t\tnfs4_stateid_copy(&stateid, &delegation->stateid);\n\t\trcu_read_unlock();\n\t\tret = nfs_may_open(state->inode, state->owner->so_cred, open_mode);\n\t\tif (ret != 0)\n\t\t\tgoto out;\n\t\tret = -EAGAIN;\n\n\t\t/* Try to update the stateid using the delegation */\n\t\tif (update_open_stateid(state, NULL, &stateid, fmode))\n\t\t\tgoto out_return_state;\n\t}\nout:\n\treturn ERR_PTR(ret);\nout_return_state:\n\tatomic_inc(&state->count);\n\treturn state;\n}\n\nstatic void\nnfs4_opendata_check_deleg(struct nfs4_opendata *data, struct nfs4_state *state)\n{\n\tstruct nfs_client *clp = NFS_SERVER(state->inode)->nfs_client;\n\tstruct nfs_delegation *delegation;\n\tint delegation_flags = 0;\n\n\trcu_read_lock();\n\tdelegation = rcu_dereference(NFS_I(state->inode)->delegation);\n\tif (delegation)\n\t\tdelegation_flags = delegation->flags;\n\trcu_read_unlock();\n\tif (data->o_arg.claim == NFS4_OPEN_CLAIM_DELEGATE_CUR) {\n\t\tpr_err_ratelimited(\"NFS: Broken NFSv4 server %s is \"\n\t\t\t\t   \"returning a delegation for \"\n\t\t\t\t   \"OPEN(CLAIM_DELEGATE_CUR)\\n\",\n\t\t\t\t   clp->cl_hostname);\n\t} else if ((delegation_flags & 1UL<<NFS_DELEGATION_NEED_RECLAIM) == 0)\n\t\tnfs_inode_set_delegation(state->inode,\n\t\t\t\t\t data->owner->so_cred,\n\t\t\t\t\t &data->o_res);\n\telse\n\t\tnfs_inode_reclaim_delegation(state->inode,\n\t\t\t\t\t     data->owner->so_cred,\n\t\t\t\t\t     &data->o_res);\n}\n\n/*\n * Check the inode attributes against the CLAIM_PREVIOUS returned attributes\n * and update the nfs4_state.\n */\nstatic struct nfs4_state *\n_nfs4_opendata_reclaim_to_nfs4_state(struct nfs4_opendata *data)\n{\n\tstruct inode *inode = data->state->inode;\n\tstruct nfs4_state *state = data->state;\n\tint ret;\n\n\tif (!data->rpc_done) {\n\t\tret = data->rpc_status;\n\t\tgoto err;\n\t}\n\n\tret = -ESTALE;\n\tif (!(data->f_attr.valid & NFS_ATTR_FATTR_TYPE) ||\n\t    !(data->f_attr.valid & NFS_ATTR_FATTR_FILEID) ||\n\t    !(data->f_attr.valid & NFS_ATTR_FATTR_CHANGE))\n\t\tgoto err;\n\n\tret = -ENOMEM;\n\tstate = nfs4_get_open_state(inode, data->owner);\n\tif (state == NULL)\n\t\tgoto err;\n\n\tret = nfs_refresh_inode(inode, &data->f_attr);\n\tif (ret)\n\t\tgoto err;\n\n\tif (data->o_res.delegation_type != 0)\n\t\tnfs4_opendata_check_deleg(data, state);\n\tupdate_open_stateid(state, &data->o_res.stateid, NULL,\n\t\t\t    data->o_arg.fmode);\n\n\treturn state;\nerr:\n\treturn ERR_PTR(ret);\n\n}\n\nstatic struct nfs4_state *\n_nfs4_opendata_to_nfs4_state(struct nfs4_opendata *data)\n{\n\tstruct inode *inode;\n\tstruct nfs4_state *state = NULL;\n\tint ret;\n\n\tif (!data->rpc_done) {\n\t\tstate = nfs4_try_open_cached(data);\n\t\tgoto out;\n\t}\n\n\tret = -EAGAIN;\n\tif (!(data->f_attr.valid & NFS_ATTR_FATTR))\n\t\tgoto err;\n\tinode = nfs_fhget(data->dir->d_sb, &data->o_res.fh, &data->f_attr);\n\tret = PTR_ERR(inode);\n\tif (IS_ERR(inode))\n\t\tgoto err;\n\tret = -ENOMEM;\n\tstate = nfs4_get_open_state(inode, data->owner);\n\tif (state == NULL)\n\t\tgoto err_put_inode;\n\tif (data->o_res.delegation_type != 0)\n\t\tnfs4_opendata_check_deleg(data, state);\n\tupdate_open_stateid(state, &data->o_res.stateid, NULL,\n\t\t\tdata->o_arg.fmode);\n\tiput(inode);\nout:\n\treturn state;\nerr_put_inode:\n\tiput(inode);\nerr:\n\treturn ERR_PTR(ret);\n}\n\nstatic struct nfs4_state *\nnfs4_opendata_to_nfs4_state(struct nfs4_opendata *data)\n{\n\tif (data->o_arg.claim == NFS4_OPEN_CLAIM_PREVIOUS)\n\t\treturn _nfs4_opendata_reclaim_to_nfs4_state(data);\n\treturn _nfs4_opendata_to_nfs4_state(data);\n}\n\nstatic struct nfs_open_context *nfs4_state_find_open_context(struct nfs4_state *state)\n{\n\tstruct nfs_inode *nfsi = NFS_I(state->inode);\n\tstruct nfs_open_context *ctx;\n\n\tspin_lock(&state->inode->i_lock);\n\tlist_for_each_entry(ctx, &nfsi->open_files, list) {\n\t\tif (ctx->state != state)\n\t\t\tcontinue;\n\t\tget_nfs_open_context(ctx);\n\t\tspin_unlock(&state->inode->i_lock);\n\t\treturn ctx;\n\t}\n\tspin_unlock(&state->inode->i_lock);\n\treturn ERR_PTR(-ENOENT);\n}\n\nstatic struct nfs4_opendata *nfs4_open_recoverdata_alloc(struct nfs_open_context *ctx, struct nfs4_state *state)\n{\n\tstruct nfs4_opendata *opendata;\n\n\topendata = nfs4_opendata_alloc(ctx->dentry, state->owner, 0, 0, NULL, GFP_NOFS);\n\tif (opendata == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\topendata->state = state;\n\tatomic_inc(&state->count);\n\treturn opendata;\n}\n\nstatic int nfs4_open_recover_helper(struct nfs4_opendata *opendata, fmode_t fmode, struct nfs4_state **res)\n{\n\tstruct nfs4_state *newstate;\n\tint ret;\n\n\topendata->o_arg.open_flags = 0;\n\topendata->o_arg.fmode = fmode;\n\tmemset(&opendata->o_res, 0, sizeof(opendata->o_res));\n\tmemset(&opendata->c_res, 0, sizeof(opendata->c_res));\n\tnfs4_init_opendata_res(opendata);\n\tret = _nfs4_recover_proc_open(opendata);\n\tif (ret != 0)\n\t\treturn ret; \n\tnewstate = nfs4_opendata_to_nfs4_state(opendata);\n\tif (IS_ERR(newstate))\n\t\treturn PTR_ERR(newstate);\n\tnfs4_close_state(newstate, fmode);\n\t*res = newstate;\n\treturn 0;\n}\n\nstatic int nfs4_open_recover(struct nfs4_opendata *opendata, struct nfs4_state *state)\n{\n\tstruct nfs4_state *newstate;\n\tint ret;\n\n\t/* memory barrier prior to reading state->n_* */\n\tclear_bit(NFS_DELEGATED_STATE, &state->flags);\n\tsmp_rmb();\n\tif (state->n_rdwr != 0) {\n\t\tclear_bit(NFS_O_RDWR_STATE, &state->flags);\n\t\tret = nfs4_open_recover_helper(opendata, FMODE_READ|FMODE_WRITE, &newstate);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t\tif (newstate != state)\n\t\t\treturn -ESTALE;\n\t}\n\tif (state->n_wronly != 0) {\n\t\tclear_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t\tret = nfs4_open_recover_helper(opendata, FMODE_WRITE, &newstate);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t\tif (newstate != state)\n\t\t\treturn -ESTALE;\n\t}\n\tif (state->n_rdonly != 0) {\n\t\tclear_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\tret = nfs4_open_recover_helper(opendata, FMODE_READ, &newstate);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t\tif (newstate != state)\n\t\t\treturn -ESTALE;\n\t}\n\t/*\n\t * We may have performed cached opens for all three recoveries.\n\t * Check if we need to update the current stateid.\n\t */\n\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) == 0 &&\n\t    !nfs4_stateid_match(&state->stateid, &state->open_stateid)) {\n\t\twrite_seqlock(&state->seqlock);\n\t\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) == 0)\n\t\t\tnfs4_stateid_copy(&state->stateid, &state->open_stateid);\n\t\twrite_sequnlock(&state->seqlock);\n\t}\n\treturn 0;\n}\n\n/*\n * OPEN_RECLAIM:\n * \treclaim state on the server after a reboot.\n */\nstatic int _nfs4_do_open_reclaim(struct nfs_open_context *ctx, struct nfs4_state *state)\n{\n\tstruct nfs_delegation *delegation;\n\tstruct nfs4_opendata *opendata;\n\tfmode_t delegation_type = 0;\n\tint status;\n\n\topendata = nfs4_open_recoverdata_alloc(ctx, state);\n\tif (IS_ERR(opendata))\n\t\treturn PTR_ERR(opendata);\n\topendata->o_arg.claim = NFS4_OPEN_CLAIM_PREVIOUS;\n\topendata->o_arg.fh = NFS_FH(state->inode);\n\trcu_read_lock();\n\tdelegation = rcu_dereference(NFS_I(state->inode)->delegation);\n\tif (delegation != NULL && test_bit(NFS_DELEGATION_NEED_RECLAIM, &delegation->flags) != 0)\n\t\tdelegation_type = delegation->type;\n\trcu_read_unlock();\n\topendata->o_arg.u.delegation_type = delegation_type;\n\tstatus = nfs4_open_recover(opendata, state);\n\tnfs4_opendata_put(opendata);\n\treturn status;\n}\n\nstatic int nfs4_do_open_reclaim(struct nfs_open_context *ctx, struct nfs4_state *state)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = _nfs4_do_open_reclaim(ctx, state);\n\t\tif (err != -NFS4ERR_DELAY)\n\t\t\tbreak;\n\t\tnfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int nfs4_open_reclaim(struct nfs4_state_owner *sp, struct nfs4_state *state)\n{\n\tstruct nfs_open_context *ctx;\n\tint ret;\n\n\tctx = nfs4_state_find_open_context(state);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\tret = nfs4_do_open_reclaim(ctx, state);\n\tput_nfs_open_context(ctx);\n\treturn ret;\n}\n\nstatic int _nfs4_open_delegation_recall(struct nfs_open_context *ctx, struct nfs4_state *state, const nfs4_stateid *stateid)\n{\n\tstruct nfs4_opendata *opendata;\n\tint ret;\n\n\topendata = nfs4_open_recoverdata_alloc(ctx, state);\n\tif (IS_ERR(opendata))\n\t\treturn PTR_ERR(opendata);\n\topendata->o_arg.claim = NFS4_OPEN_CLAIM_DELEGATE_CUR;\n\tnfs4_stateid_copy(&opendata->o_arg.u.delegation, stateid);\n\tret = nfs4_open_recover(opendata, state);\n\tnfs4_opendata_put(opendata);\n\treturn ret;\n}\n\nint nfs4_open_delegation_recall(struct nfs_open_context *ctx, struct nfs4_state *state, const nfs4_stateid *stateid)\n{\n\tstruct nfs4_exception exception = { };\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tint err;\n\tdo {\n\t\terr = _nfs4_open_delegation_recall(ctx, state, stateid);\n\t\tswitch (err) {\n\t\t\tcase 0:\n\t\t\tcase -ENOENT:\n\t\t\tcase -ESTALE:\n\t\t\t\tgoto out;\n\t\t\tcase -NFS4ERR_BADSESSION:\n\t\t\tcase -NFS4ERR_BADSLOT:\n\t\t\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\t\t\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\t\tcase -NFS4ERR_DEADSESSION:\n\t\t\t\tnfs4_schedule_session_recovery(server->nfs_client->cl_session, err);\n\t\t\t\tgoto out;\n\t\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\t\tcase -NFS4ERR_STALE_STATEID:\n\t\t\tcase -NFS4ERR_EXPIRED:\n\t\t\t\t/* Don't recall a delegation if it was lost */\n\t\t\t\tnfs4_schedule_lease_recovery(server->nfs_client);\n\t\t\t\tgoto out;\n\t\t\tcase -ERESTARTSYS:\n\t\t\t\t/*\n\t\t\t\t * The show must go on: exit, but mark the\n\t\t\t\t * stateid as needing recovery.\n\t\t\t\t */\n\t\t\tcase -NFS4ERR_DELEG_REVOKED:\n\t\t\tcase -NFS4ERR_ADMIN_REVOKED:\n\t\t\tcase -NFS4ERR_BAD_STATEID:\n\t\t\t\tnfs_inode_find_state_and_recover(state->inode,\n\t\t\t\t\t\tstateid);\n\t\t\t\tnfs4_schedule_stateid_recovery(server, state);\n\t\t\tcase -EKEYEXPIRED:\n\t\t\t\t/*\n\t\t\t\t * User RPCSEC_GSS context has expired.\n\t\t\t\t * We cannot recover this stateid now, so\n\t\t\t\t * skip it and allow recovery thread to\n\t\t\t\t * proceed.\n\t\t\t\t */\n\t\t\tcase -ENOMEM:\n\t\t\t\terr = 0;\n\t\t\t\tgoto out;\n\t\t}\n\t\terr = nfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\nout:\n\treturn err;\n}\n\nstatic void nfs4_open_confirm_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\n\tdata->rpc_status = task->tk_status;\n\tif (data->rpc_status == 0) {\n\t\tnfs4_stateid_copy(&data->o_res.stateid, &data->c_res.stateid);\n\t\tnfs_confirm_seqid(&data->owner->so_seqid, 0);\n\t\trenew_lease(data->o_res.server, data->timestamp);\n\t\tdata->rpc_done = 1;\n\t}\n}\n\nstatic void nfs4_open_confirm_release(void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\tstruct nfs4_state *state = NULL;\n\n\t/* If this request hasn't been cancelled, do nothing */\n\tif (data->cancelled == 0)\n\t\tgoto out_free;\n\t/* In case of error, no cleanup! */\n\tif (!data->rpc_done)\n\t\tgoto out_free;\n\tstate = nfs4_opendata_to_nfs4_state(data);\n\tif (!IS_ERR(state))\n\t\tnfs4_close_state(state, data->o_arg.fmode);\nout_free:\n\tnfs4_opendata_put(data);\n}\n\nstatic const struct rpc_call_ops nfs4_open_confirm_ops = {\n\t.rpc_call_done = nfs4_open_confirm_done,\n\t.rpc_release = nfs4_open_confirm_release,\n};\n\n/*\n * Note: On error, nfs4_proc_open_confirm will free the struct nfs4_opendata\n */\nstatic int _nfs4_proc_open_confirm(struct nfs4_opendata *data)\n{\n\tstruct nfs_server *server = NFS_SERVER(data->dir->d_inode);\n\tstruct rpc_task *task;\n\tstruct  rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN_CONFIRM],\n\t\t.rpc_argp = &data->c_arg,\n\t\t.rpc_resp = &data->c_res,\n\t\t.rpc_cred = data->owner->so_cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = server->client,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_open_confirm_ops,\n\t\t.callback_data = data,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\tint status;\n\n\tkref_get(&data->kref);\n\tdata->rpc_done = 0;\n\tdata->rpc_status = 0;\n\tdata->timestamp = jiffies;\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tstatus = nfs4_wait_for_completion_rpc_task(task);\n\tif (status != 0) {\n\t\tdata->cancelled = 1;\n\t\tsmp_wmb();\n\t} else\n\t\tstatus = data->rpc_status;\n\trpc_put_task(task);\n\treturn status;\n}\n\nstatic void nfs4_open_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\tstruct nfs4_state_owner *sp = data->owner;\n\n\tif (nfs_wait_on_sequence(data->o_arg.seqid, task) != 0)\n\t\treturn;\n\t/*\n\t * Check if we still need to send an OPEN call, or if we can use\n\t * a delegation instead.\n\t */\n\tif (data->state != NULL) {\n\t\tstruct nfs_delegation *delegation;\n\n\t\tif (can_open_cached(data->state, data->o_arg.fmode, data->o_arg.open_flags))\n\t\t\tgoto out_no_action;\n\t\trcu_read_lock();\n\t\tdelegation = rcu_dereference(NFS_I(data->state->inode)->delegation);\n\t\tif (data->o_arg.claim != NFS4_OPEN_CLAIM_DELEGATE_CUR &&\n\t\t    can_open_delegated(delegation, data->o_arg.fmode))\n\t\t\tgoto unlock_no_action;\n\t\trcu_read_unlock();\n\t}\n\t/* Update client id. */\n\tdata->o_arg.clientid = sp->so_server->nfs_client->cl_clientid;\n\tif (data->o_arg.claim == NFS4_OPEN_CLAIM_PREVIOUS) {\n\t\ttask->tk_msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN_NOATTR];\n\t\tdata->o_arg.open_bitmap = &nfs4_open_noattr_bitmap[0];\n\t\tnfs_copy_fh(&data->o_res.fh, data->o_arg.fh);\n\t}\n\tdata->timestamp = jiffies;\n\tif (nfs4_setup_sequence(data->o_arg.server,\n\t\t\t\t&data->o_arg.seq_args,\n\t\t\t\t&data->o_res.seq_res,\n\t\t\t\ttask) != 0)\n\t\tnfs_release_seqid(data->o_arg.seqid);\n\telse\n\t\trpc_call_start(task);\n\treturn;\nunlock_no_action:\n\trcu_read_unlock();\nout_no_action:\n\ttask->tk_action = NULL;\n\n}\n\nstatic void nfs4_recover_open_prepare(struct rpc_task *task, void *calldata)\n{\n\trpc_task_set_priority(task, RPC_PRIORITY_PRIVILEGED);\n\tnfs4_open_prepare(task, calldata);\n}\n\nstatic void nfs4_open_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\n\tdata->rpc_status = task->tk_status;\n\n\tif (!nfs4_sequence_done(task, &data->o_res.seq_res))\n\t\treturn;\n\n\tif (task->tk_status == 0) {\n\t\tif (data->o_res.f_attr->valid & NFS_ATTR_FATTR_TYPE) {\n\t\t\tswitch (data->o_res.f_attr->mode & S_IFMT) {\n\t\t\tcase S_IFREG:\n\t\t\t\tbreak;\n\t\t\tcase S_IFLNK:\n\t\t\t\tdata->rpc_status = -ELOOP;\n\t\t\t\tbreak;\n\t\t\tcase S_IFDIR:\n\t\t\t\tdata->rpc_status = -EISDIR;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdata->rpc_status = -ENOTDIR;\n\t\t\t}\n\t\t}\n\t\trenew_lease(data->o_res.server, data->timestamp);\n\t\tif (!(data->o_res.rflags & NFS4_OPEN_RESULT_CONFIRM))\n\t\t\tnfs_confirm_seqid(&data->owner->so_seqid, 0);\n\t}\n\tdata->rpc_done = 1;\n}\n\nstatic void nfs4_open_release(void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\tstruct nfs4_state *state = NULL;\n\n\t/* If this request hasn't been cancelled, do nothing */\n\tif (data->cancelled == 0)\n\t\tgoto out_free;\n\t/* In case of error, no cleanup! */\n\tif (data->rpc_status != 0 || !data->rpc_done)\n\t\tgoto out_free;\n\t/* In case we need an open_confirm, no cleanup! */\n\tif (data->o_res.rflags & NFS4_OPEN_RESULT_CONFIRM)\n\t\tgoto out_free;\n\tstate = nfs4_opendata_to_nfs4_state(data);\n\tif (!IS_ERR(state))\n\t\tnfs4_close_state(state, data->o_arg.fmode);\nout_free:\n\tnfs4_opendata_put(data);\n}\n\nstatic const struct rpc_call_ops nfs4_open_ops = {\n\t.rpc_call_prepare = nfs4_open_prepare,\n\t.rpc_call_done = nfs4_open_done,\n\t.rpc_release = nfs4_open_release,\n};\n\nstatic const struct rpc_call_ops nfs4_recover_open_ops = {\n\t.rpc_call_prepare = nfs4_recover_open_prepare,\n\t.rpc_call_done = nfs4_open_done,\n\t.rpc_release = nfs4_open_release,\n};\n\nstatic int nfs4_run_open_task(struct nfs4_opendata *data, int isrecover)\n{\n\tstruct inode *dir = data->dir->d_inode;\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tstruct nfs_openargs *o_arg = &data->o_arg;\n\tstruct nfs_openres *o_res = &data->o_res;\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN],\n\t\t.rpc_argp = o_arg,\n\t\t.rpc_resp = o_res,\n\t\t.rpc_cred = data->owner->so_cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = server->client,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_open_ops,\n\t\t.callback_data = data,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\tint status;\n\n\tnfs41_init_sequence(&o_arg->seq_args, &o_res->seq_res, 1);\n\tkref_get(&data->kref);\n\tdata->rpc_done = 0;\n\tdata->rpc_status = 0;\n\tdata->cancelled = 0;\n\tif (isrecover)\n\t\ttask_setup_data.callback_ops = &nfs4_recover_open_ops;\n\ttask = rpc_run_task(&task_setup_data);\n        if (IS_ERR(task))\n                return PTR_ERR(task);\n        status = nfs4_wait_for_completion_rpc_task(task);\n        if (status != 0) {\n                data->cancelled = 1;\n                smp_wmb();\n        } else\n                status = data->rpc_status;\n        rpc_put_task(task);\n\n\treturn status;\n}\n\nstatic int _nfs4_recover_proc_open(struct nfs4_opendata *data)\n{\n\tstruct inode *dir = data->dir->d_inode;\n\tstruct nfs_openres *o_res = &data->o_res;\n        int status;\n\n\tstatus = nfs4_run_open_task(data, 1);\n\tif (status != 0 || !data->rpc_done)\n\t\treturn status;\n\n\tnfs_fattr_map_and_free_names(NFS_SERVER(dir), &data->f_attr);\n\n\tif (o_res->rflags & NFS4_OPEN_RESULT_CONFIRM) {\n\t\tstatus = _nfs4_proc_open_confirm(data);\n\t\tif (status != 0)\n\t\t\treturn status;\n\t}\n\n\treturn status;\n}\n\nstatic int nfs4_opendata_access(struct rpc_cred *cred,\n\t\t\t\tstruct nfs4_opendata *opendata,\n\t\t\t\tstruct nfs4_state *state, fmode_t fmode)\n{\n\tstruct nfs_access_entry cache;\n\tu32 mask;\n\n\t/* access call failed or for some reason the server doesn't\n\t * support any access modes -- defer access call until later */\n\tif (opendata->o_res.access_supported == 0)\n\t\treturn 0;\n\n\tmask = 0;\n\t/* don't check MAY_WRITE - a newly created file may not have\n\t * write mode bits, but POSIX allows the creating process to write */\n\tif (fmode & FMODE_READ)\n\t\tmask |= MAY_READ;\n\tif (fmode & FMODE_EXEC)\n\t\tmask |= MAY_EXEC;\n\n\tcache.cred = cred;\n\tcache.jiffies = jiffies;\n\tnfs_access_set_mask(&cache, opendata->o_res.access_result);\n\tnfs_access_add_cache(state->inode, &cache);\n\n\tif ((mask & ~cache.mask & (MAY_READ | MAY_EXEC)) == 0)\n\t\treturn 0;\n\n\t/* even though OPEN succeeded, access is denied. Close the file */\n\tnfs4_close_state(state, fmode);\n\treturn -EACCES;\n}\n\n/*\n * Note: On error, nfs4_proc_open will free the struct nfs4_opendata\n */\nstatic int _nfs4_proc_open(struct nfs4_opendata *data)\n{\n\tstruct inode *dir = data->dir->d_inode;\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tstruct nfs_openargs *o_arg = &data->o_arg;\n\tstruct nfs_openres *o_res = &data->o_res;\n\tint status;\n\n\tstatus = nfs4_run_open_task(data, 0);\n\tif (!data->rpc_done)\n\t\treturn status;\n\tif (status != 0) {\n\t\tif (status == -NFS4ERR_BADNAME &&\n\t\t\t\t!(o_arg->open_flags & O_CREAT))\n\t\t\treturn -ENOENT;\n\t\treturn status;\n\t}\n\n\tnfs_fattr_map_and_free_names(server, &data->f_attr);\n\n\tif (o_arg->open_flags & O_CREAT)\n\t\tupdate_changeattr(dir, &o_res->cinfo);\n\tif ((o_res->rflags & NFS4_OPEN_RESULT_LOCKTYPE_POSIX) == 0)\n\t\tserver->caps &= ~NFS_CAP_POSIX_LOCK;\n\tif(o_res->rflags & NFS4_OPEN_RESULT_CONFIRM) {\n\t\tstatus = _nfs4_proc_open_confirm(data);\n\t\tif (status != 0)\n\t\t\treturn status;\n\t}\n\tif (!(o_res->f_attr->valid & NFS_ATTR_FATTR))\n\t\t_nfs4_proc_getattr(server, &o_res->fh, o_res->f_attr);\n\treturn 0;\n}\n\nstatic int nfs4_client_recover_expired_lease(struct nfs_client *clp)\n{\n\tunsigned int loop;\n\tint ret;\n\n\tfor (loop = NFS4_MAX_LOOP_ON_RECOVER; loop != 0; loop--) {\n\t\tret = nfs4_wait_clnt_recover(clp);\n\t\tif (ret != 0)\n\t\t\tbreak;\n\t\tif (!test_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state) &&\n\t\t    !test_bit(NFS4CLNT_CHECK_LEASE,&clp->cl_state))\n\t\t\tbreak;\n\t\tnfs4_schedule_state_manager(clp);\n\t\tret = -EIO;\n\t}\n\treturn ret;\n}\n\nstatic int nfs4_recover_expired_lease(struct nfs_server *server)\n{\n\treturn nfs4_client_recover_expired_lease(server->nfs_client);\n}\n\n/*\n * OPEN_EXPIRED:\n * \treclaim state on the server after a network partition.\n * \tAssumes caller holds the appropriate lock\n */\nstatic int _nfs4_open_expired(struct nfs_open_context *ctx, struct nfs4_state *state)\n{\n\tstruct nfs4_opendata *opendata;\n\tint ret;\n\n\topendata = nfs4_open_recoverdata_alloc(ctx, state);\n\tif (IS_ERR(opendata))\n\t\treturn PTR_ERR(opendata);\n\tret = nfs4_open_recover(opendata, state);\n\tif (ret == -ESTALE)\n\t\td_drop(ctx->dentry);\n\tnfs4_opendata_put(opendata);\n\treturn ret;\n}\n\nstatic int nfs4_do_open_expired(struct nfs_open_context *ctx, struct nfs4_state *state)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\tdo {\n\t\terr = _nfs4_open_expired(ctx, state);\n\t\tswitch (err) {\n\t\tdefault:\n\t\t\tgoto out;\n\t\tcase -NFS4ERR_GRACE:\n\t\tcase -NFS4ERR_DELAY:\n\t\t\tnfs4_handle_exception(server, err, &exception);\n\t\t\terr = 0;\n\t\t}\n\t} while (exception.retry);\nout:\n\treturn err;\n}\n\nstatic int nfs4_open_expired(struct nfs4_state_owner *sp, struct nfs4_state *state)\n{\n\tstruct nfs_open_context *ctx;\n\tint ret;\n\n\tctx = nfs4_state_find_open_context(state);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\tret = nfs4_do_open_expired(ctx, state);\n\tput_nfs_open_context(ctx);\n\treturn ret;\n}\n\n#if defined(CONFIG_NFS_V4_1)\nstatic void nfs41_clear_delegation_stateid(struct nfs4_state *state)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tnfs4_stateid *stateid = &state->stateid;\n\tint status;\n\n\t/* If a state reset has been done, test_stateid is unneeded */\n\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) == 0)\n\t\treturn;\n\n\tstatus = nfs41_test_stateid(server, stateid);\n\tif (status != NFS_OK) {\n\t\t/* Free the stateid unless the server explicitly\n\t\t * informs us the stateid is unrecognized. */\n\t\tif (status != -NFS4ERR_BAD_STATEID)\n\t\t\tnfs41_free_stateid(server, stateid);\n\t\tnfs_remove_bad_delegation(state->inode);\n\n\t\twrite_seqlock(&state->seqlock);\n\t\tnfs4_stateid_copy(&state->stateid, &state->open_stateid);\n\t\twrite_sequnlock(&state->seqlock);\n\t\tclear_bit(NFS_DELEGATED_STATE, &state->flags);\n\t}\n}\n\n/**\n * nfs41_check_open_stateid - possibly free an open stateid\n *\n * @state: NFSv4 state for an inode\n *\n * Returns NFS_OK if recovery for this stateid is now finished.\n * Otherwise a negative NFS4ERR value is returned.\n */\nstatic int nfs41_check_open_stateid(struct nfs4_state *state)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tnfs4_stateid *stateid = &state->open_stateid;\n\tint status;\n\n\t/* If a state reset has been done, test_stateid is unneeded */\n\tif ((test_bit(NFS_O_RDONLY_STATE, &state->flags) == 0) &&\n\t    (test_bit(NFS_O_WRONLY_STATE, &state->flags) == 0) &&\n\t    (test_bit(NFS_O_RDWR_STATE, &state->flags) == 0))\n\t\treturn -NFS4ERR_BAD_STATEID;\n\n\tstatus = nfs41_test_stateid(server, stateid);\n\tif (status != NFS_OK) {\n\t\t/* Free the stateid unless the server explicitly\n\t\t * informs us the stateid is unrecognized. */\n\t\tif (status != -NFS4ERR_BAD_STATEID)\n\t\t\tnfs41_free_stateid(server, stateid);\n\n\t\tclear_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\tclear_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t\tclear_bit(NFS_O_RDWR_STATE, &state->flags);\n\t}\n\treturn status;\n}\n\nstatic int nfs41_open_expired(struct nfs4_state_owner *sp, struct nfs4_state *state)\n{\n\tint status;\n\n\tnfs41_clear_delegation_stateid(state);\n\tstatus = nfs41_check_open_stateid(state);\n\tif (status != NFS_OK)\n\t\tstatus = nfs4_open_expired(sp, state);\n\treturn status;\n}\n#endif\n\n/*\n * on an EXCLUSIVE create, the server should send back a bitmask with FATTR4-*\n * fields corresponding to attributes that were used to store the verifier.\n * Make sure we clobber those fields in the later setattr call\n */\nstatic inline void nfs4_exclusive_attrset(struct nfs4_opendata *opendata, struct iattr *sattr)\n{\n\tif ((opendata->o_res.attrset[1] & FATTR4_WORD1_TIME_ACCESS) &&\n\t    !(sattr->ia_valid & ATTR_ATIME_SET))\n\t\tsattr->ia_valid |= ATTR_ATIME;\n\n\tif ((opendata->o_res.attrset[1] & FATTR4_WORD1_TIME_MODIFY) &&\n\t    !(sattr->ia_valid & ATTR_MTIME_SET))\n\t\tsattr->ia_valid |= ATTR_MTIME;\n}\n\n/*\n * Returns a referenced nfs4_state\n */\nstatic int _nfs4_do_open(struct inode *dir,\n\t\t\tstruct dentry *dentry,\n\t\t\tfmode_t fmode,\n\t\t\tint flags,\n\t\t\tstruct iattr *sattr,\n\t\t\tstruct rpc_cred *cred,\n\t\t\tstruct nfs4_state **res,\n\t\t\tstruct nfs4_threshold **ctx_th)\n{\n\tstruct nfs4_state_owner  *sp;\n\tstruct nfs4_state     *state = NULL;\n\tstruct nfs_server       *server = NFS_SERVER(dir);\n\tstruct nfs4_opendata *opendata;\n\tint status;\n\n\t/* Protect against reboot recovery conflicts */\n\tstatus = -ENOMEM;\n\tsp = nfs4_get_state_owner(server, cred, GFP_KERNEL);\n\tif (sp == NULL) {\n\t\tdprintk(\"nfs4_do_open: nfs4_get_state_owner failed!\\n\");\n\t\tgoto out_err;\n\t}\n\tstatus = nfs4_recover_expired_lease(server);\n\tif (status != 0)\n\t\tgoto err_put_state_owner;\n\tif (dentry->d_inode != NULL)\n\t\tnfs4_return_incompatible_delegation(dentry->d_inode, fmode);\n\tstatus = -ENOMEM;\n\topendata = nfs4_opendata_alloc(dentry, sp, fmode, flags, sattr, GFP_KERNEL);\n\tif (opendata == NULL)\n\t\tgoto err_put_state_owner;\n\n\tif (ctx_th && server->attr_bitmask[2] & FATTR4_WORD2_MDSTHRESHOLD) {\n\t\topendata->f_attr.mdsthreshold = pnfs_mdsthreshold_alloc();\n\t\tif (!opendata->f_attr.mdsthreshold)\n\t\t\tgoto err_opendata_put;\n\t\topendata->o_arg.open_bitmap = &nfs4_pnfs_open_bitmap[0];\n\t}\n\tif (dentry->d_inode != NULL)\n\t\topendata->state = nfs4_get_open_state(dentry->d_inode, sp);\n\n\tstatus = _nfs4_proc_open(opendata);\n\tif (status != 0)\n\t\tgoto err_opendata_put;\n\n\tstate = nfs4_opendata_to_nfs4_state(opendata);\n\tstatus = PTR_ERR(state);\n\tif (IS_ERR(state))\n\t\tgoto err_opendata_put;\n\tif (server->caps & NFS_CAP_POSIX_LOCK)\n\t\tset_bit(NFS_STATE_POSIX_LOCKS, &state->flags);\n\n\tstatus = nfs4_opendata_access(cred, opendata, state, fmode);\n\tif (status != 0)\n\t\tgoto err_opendata_put;\n\n\tif (opendata->o_arg.open_flags & O_EXCL) {\n\t\tnfs4_exclusive_attrset(opendata, sattr);\n\n\t\tnfs_fattr_init(opendata->o_res.f_attr);\n\t\tstatus = nfs4_do_setattr(state->inode, cred,\n\t\t\t\topendata->o_res.f_attr, sattr,\n\t\t\t\tstate);\n\t\tif (status == 0)\n\t\t\tnfs_setattr_update_inode(state->inode, sattr);\n\t\tnfs_post_op_update_inode(state->inode, opendata->o_res.f_attr);\n\t}\n\n\tif (pnfs_use_threshold(ctx_th, opendata->f_attr.mdsthreshold, server))\n\t\t*ctx_th = opendata->f_attr.mdsthreshold;\n\telse\n\t\tkfree(opendata->f_attr.mdsthreshold);\n\topendata->f_attr.mdsthreshold = NULL;\n\n\tnfs4_opendata_put(opendata);\n\tnfs4_put_state_owner(sp);\n\t*res = state;\n\treturn 0;\nerr_opendata_put:\n\tkfree(opendata->f_attr.mdsthreshold);\n\tnfs4_opendata_put(opendata);\nerr_put_state_owner:\n\tnfs4_put_state_owner(sp);\nout_err:\n\t*res = NULL;\n\treturn status;\n}\n\n\nstatic struct nfs4_state *nfs4_do_open(struct inode *dir,\n\t\t\t\t\tstruct dentry *dentry,\n\t\t\t\t\tfmode_t fmode,\n\t\t\t\t\tint flags,\n\t\t\t\t\tstruct iattr *sattr,\n\t\t\t\t\tstruct rpc_cred *cred,\n\t\t\t\t\tstruct nfs4_threshold **ctx_th)\n{\n\tstruct nfs4_exception exception = { };\n\tstruct nfs4_state *res;\n\tint status;\n\n\tfmode &= FMODE_READ|FMODE_WRITE|FMODE_EXEC;\n\tdo {\n\t\tstatus = _nfs4_do_open(dir, dentry, fmode, flags, sattr, cred,\n\t\t\t\t       &res, ctx_th);\n\t\tif (status == 0)\n\t\t\tbreak;\n\t\t/* NOTE: BAD_SEQID means the server and client disagree about the\n\t\t * book-keeping w.r.t. state-changing operations\n\t\t * (OPEN/CLOSE/LOCK/LOCKU...)\n\t\t * It is actually a sign of a bug on the client or on the server.\n\t\t *\n\t\t * If we receive a BAD_SEQID error in the particular case of\n\t\t * doing an OPEN, we assume that nfs_increment_open_seqid() will\n\t\t * have unhashed the old state_owner for us, and that we can\n\t\t * therefore safely retry using a new one. We should still warn\n\t\t * the user though...\n\t\t */\n\t\tif (status == -NFS4ERR_BAD_SEQID) {\n\t\t\tpr_warn_ratelimited(\"NFS: v4 server %s \"\n\t\t\t\t\t\" returned a bad sequence-id error!\\n\",\n\t\t\t\t\tNFS_SERVER(dir)->nfs_client->cl_hostname);\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * BAD_STATEID on OPEN means that the server cancelled our\n\t\t * state before it received the OPEN_CONFIRM.\n\t\t * Recover by retrying the request as per the discussion\n\t\t * on Page 181 of RFC3530.\n\t\t */\n\t\tif (status == -NFS4ERR_BAD_STATEID) {\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (status == -EAGAIN) {\n\t\t\t/* We must have found a delegation */\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tres = ERR_PTR(nfs4_handle_exception(NFS_SERVER(dir),\n\t\t\t\t\tstatus, &exception));\n\t} while (exception.retry);\n\treturn res;\n}\n\nstatic int _nfs4_do_setattr(struct inode *inode, struct rpc_cred *cred,\n\t\t\t    struct nfs_fattr *fattr, struct iattr *sattr,\n\t\t\t    struct nfs4_state *state)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n        struct nfs_setattrargs  arg = {\n                .fh             = NFS_FH(inode),\n                .iap            = sattr,\n\t\t.server\t\t= server,\n\t\t.bitmask = server->attr_bitmask,\n        };\n        struct nfs_setattrres  res = {\n\t\t.fattr\t\t= fattr,\n\t\t.server\t\t= server,\n        };\n        struct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_SETATTR],\n\t\t.rpc_argp\t= &arg,\n\t\t.rpc_resp\t= &res,\n\t\t.rpc_cred\t= cred,\n        };\n\tunsigned long timestamp = jiffies;\n\tint status;\n\n\tnfs_fattr_init(fattr);\n\n\tif (state != NULL) {\n\t\tstruct nfs_lockowner lockowner = {\n\t\t\t.l_owner = current->files,\n\t\t\t.l_pid = current->tgid,\n\t\t};\n\t\tnfs4_select_rw_stateid(&arg.stateid, state, FMODE_WRITE,\n\t\t\t\t&lockowner);\n\t} else if (nfs4_copy_delegation_stateid(&arg.stateid, inode,\n\t\t\t\tFMODE_WRITE)) {\n\t\t/* Use that stateid */\n\t} else\n\t\tnfs4_stateid_copy(&arg.stateid, &zero_stateid);\n\n\tstatus = nfs4_call_sync(server->client, server, &msg, &arg.seq_args, &res.seq_res, 1);\n\tif (status == 0 && state != NULL)\n\t\trenew_lease(server, timestamp);\n\treturn status;\n}\n\nstatic int nfs4_do_setattr(struct inode *inode, struct rpc_cred *cred,\n\t\t\t   struct nfs_fattr *fattr, struct iattr *sattr,\n\t\t\t   struct nfs4_state *state)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs4_exception exception = {\n\t\t.state = state,\n\t\t.inode = inode,\n\t};\n\tint err;\n\tdo {\n\t\terr = _nfs4_do_setattr(inode, cred, fattr, sattr, state);\n\t\tswitch (err) {\n\t\tcase -NFS4ERR_OPENMODE:\n\t\t\tif (state && !(state->state & FMODE_WRITE)) {\n\t\t\t\terr = -EBADF;\n\t\t\t\tif (sattr->ia_valid & ATTR_OPEN)\n\t\t\t\t\terr = -EACCES;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\terr = nfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\nout:\n\treturn err;\n}\n\nstruct nfs4_closedata {\n\tstruct inode *inode;\n\tstruct nfs4_state *state;\n\tstruct nfs_closeargs arg;\n\tstruct nfs_closeres res;\n\tstruct nfs_fattr fattr;\n\tunsigned long timestamp;\n\tbool roc;\n\tu32 roc_barrier;\n};\n\nstatic void nfs4_free_closedata(void *data)\n{\n\tstruct nfs4_closedata *calldata = data;\n\tstruct nfs4_state_owner *sp = calldata->state->owner;\n\tstruct super_block *sb = calldata->state->inode->i_sb;\n\n\tif (calldata->roc)\n\t\tpnfs_roc_release(calldata->state->inode);\n\tnfs4_put_open_state(calldata->state);\n\tnfs_free_seqid(calldata->arg.seqid);\n\tnfs4_put_state_owner(sp);\n\tnfs_sb_deactive_async(sb);\n\tkfree(calldata);\n}\n\nstatic void nfs4_close_clear_stateid_flags(struct nfs4_state *state,\n\t\tfmode_t fmode)\n{\n\tspin_lock(&state->owner->so_lock);\n\tif (!(fmode & FMODE_READ))\n\t\tclear_bit(NFS_O_RDONLY_STATE, &state->flags);\n\tif (!(fmode & FMODE_WRITE))\n\t\tclear_bit(NFS_O_WRONLY_STATE, &state->flags);\n\tclear_bit(NFS_O_RDWR_STATE, &state->flags);\n\tspin_unlock(&state->owner->so_lock);\n}\n\nstatic void nfs4_close_done(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_closedata *calldata = data;\n\tstruct nfs4_state *state = calldata->state;\n\tstruct nfs_server *server = NFS_SERVER(calldata->inode);\n\n\tdprintk(\"%s: begin!\\n\", __func__);\n\tif (!nfs4_sequence_done(task, &calldata->res.seq_res))\n\t\treturn;\n        /* hmm. we are done with the inode, and in the process of freeing\n\t * the state_owner. we keep this around to process errors\n\t */\n\tswitch (task->tk_status) {\n\t\tcase 0:\n\t\t\tif (calldata->roc)\n\t\t\t\tpnfs_roc_set_barrier(state->inode,\n\t\t\t\t\t\t     calldata->roc_barrier);\n\t\t\tnfs_set_open_stateid(state, &calldata->res.stateid, 0);\n\t\t\trenew_lease(server, calldata->timestamp);\n\t\t\tnfs4_close_clear_stateid_flags(state,\n\t\t\t\t\tcalldata->arg.fmode);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_STALE_STATEID:\n\t\tcase -NFS4ERR_OLD_STATEID:\n\t\tcase -NFS4ERR_BAD_STATEID:\n\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tif (calldata->arg.fmode == 0)\n\t\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (nfs4_async_handle_error(task, server, state) == -EAGAIN)\n\t\t\t\trpc_restart_call_prepare(task);\n\t}\n\tnfs_release_seqid(calldata->arg.seqid);\n\tnfs_refresh_inode(calldata->inode, calldata->res.fattr);\n\tdprintk(\"%s: done, ret = %d!\\n\", __func__, task->tk_status);\n}\n\nstatic void nfs4_close_prepare(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_closedata *calldata = data;\n\tstruct nfs4_state *state = calldata->state;\n\tstruct inode *inode = calldata->inode;\n\tint call_close = 0;\n\n\tdprintk(\"%s: begin!\\n\", __func__);\n\tif (nfs_wait_on_sequence(calldata->arg.seqid, task) != 0)\n\t\treturn;\n\n\ttask->tk_msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN_DOWNGRADE];\n\tcalldata->arg.fmode = FMODE_READ|FMODE_WRITE;\n\tspin_lock(&state->owner->so_lock);\n\t/* Calculate the change in open mode */\n\tif (state->n_rdwr == 0) {\n\t\tif (state->n_rdonly == 0) {\n\t\t\tcall_close |= test_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\t\tcall_close |= test_bit(NFS_O_RDWR_STATE, &state->flags);\n\t\t\tcalldata->arg.fmode &= ~FMODE_READ;\n\t\t}\n\t\tif (state->n_wronly == 0) {\n\t\t\tcall_close |= test_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t\t\tcall_close |= test_bit(NFS_O_RDWR_STATE, &state->flags);\n\t\t\tcalldata->arg.fmode &= ~FMODE_WRITE;\n\t\t}\n\t}\n\tspin_unlock(&state->owner->so_lock);\n\n\tif (!call_close) {\n\t\t/* Note: exit _without_ calling nfs4_close_done */\n\t\ttask->tk_action = NULL;\n\t\tgoto out;\n\t}\n\n\tif (calldata->arg.fmode == 0) {\n\t\ttask->tk_msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_CLOSE];\n\t\tif (calldata->roc &&\n\t\t    pnfs_roc_drain(inode, &calldata->roc_barrier, task))\n\t\t\tgoto out;\n\t}\n\n\tnfs_fattr_init(calldata->res.fattr);\n\tcalldata->timestamp = jiffies;\n\tif (nfs4_setup_sequence(NFS_SERVER(inode),\n\t\t\t\t&calldata->arg.seq_args,\n\t\t\t\t&calldata->res.seq_res,\n\t\t\t\ttask) != 0)\n\t\tnfs_release_seqid(calldata->arg.seqid);\n\telse\n\t\trpc_call_start(task);\nout:\n\tdprintk(\"%s: done!\\n\", __func__);\n}\n\nstatic const struct rpc_call_ops nfs4_close_ops = {\n\t.rpc_call_prepare = nfs4_close_prepare,\n\t.rpc_call_done = nfs4_close_done,\n\t.rpc_release = nfs4_free_closedata,\n};\n\n/* \n * It is possible for data to be read/written from a mem-mapped file \n * after the sys_close call (which hits the vfs layer as a flush).\n * This means that we can't safely call nfsv4 close on a file until \n * the inode is cleared. This in turn means that we are not good\n * NFSv4 citizens - we do not indicate to the server to update the file's \n * share state even when we are done with one of the three share \n * stateid's in the inode.\n *\n * NOTE: Caller must be holding the sp->so_owner semaphore!\n */\nint nfs4_do_close(struct nfs4_state *state, gfp_t gfp_mask, int wait)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs4_closedata *calldata;\n\tstruct nfs4_state_owner *sp = state->owner;\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_CLOSE],\n\t\t.rpc_cred = state->owner->so_cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = server->client,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_close_ops,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\tint status = -ENOMEM;\n\n\tcalldata = kzalloc(sizeof(*calldata), gfp_mask);\n\tif (calldata == NULL)\n\t\tgoto out;\n\tnfs41_init_sequence(&calldata->arg.seq_args, &calldata->res.seq_res, 1);\n\tcalldata->inode = state->inode;\n\tcalldata->state = state;\n\tcalldata->arg.fh = NFS_FH(state->inode);\n\tcalldata->arg.stateid = &state->open_stateid;\n\t/* Serialization for the sequence id */\n\tcalldata->arg.seqid = nfs_alloc_seqid(&state->owner->so_seqid, gfp_mask);\n\tif (calldata->arg.seqid == NULL)\n\t\tgoto out_free_calldata;\n\tcalldata->arg.fmode = 0;\n\tcalldata->arg.bitmask = server->cache_consistency_bitmask;\n\tcalldata->res.fattr = &calldata->fattr;\n\tcalldata->res.seqid = calldata->arg.seqid;\n\tcalldata->res.server = server;\n\tcalldata->roc = pnfs_roc(state->inode);\n\tnfs_sb_active(calldata->inode->i_sb);\n\n\tmsg.rpc_argp = &calldata->arg;\n\tmsg.rpc_resp = &calldata->res;\n\ttask_setup_data.callback_data = calldata;\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tstatus = 0;\n\tif (wait)\n\t\tstatus = rpc_wait_for_completion_task(task);\n\trpc_put_task(task);\n\treturn status;\nout_free_calldata:\n\tkfree(calldata);\nout:\n\tnfs4_put_open_state(state);\n\tnfs4_put_state_owner(sp);\n\treturn status;\n}\n\nstatic struct inode *\nnfs4_atomic_open(struct inode *dir, struct nfs_open_context *ctx, int open_flags, struct iattr *attr)\n{\n\tstruct nfs4_state *state;\n\n\t/* Protect against concurrent sillydeletes */\n\tstate = nfs4_do_open(dir, ctx->dentry, ctx->mode, open_flags, attr,\n\t\t\t     ctx->cred, &ctx->mdsthreshold);\n\tif (IS_ERR(state))\n\t\treturn ERR_CAST(state);\n\tctx->state = state;\n\treturn igrab(state->inode);\n}\n\nstatic void nfs4_close_context(struct nfs_open_context *ctx, int is_sync)\n{\n\tif (ctx->state == NULL)\n\t\treturn;\n\tif (is_sync)\n\t\tnfs4_close_sync(ctx->state, ctx->mode);\n\telse\n\t\tnfs4_close_state(ctx->state, ctx->mode);\n}\n\nstatic int _nfs4_server_capabilities(struct nfs_server *server, struct nfs_fh *fhandle)\n{\n\tstruct nfs4_server_caps_arg args = {\n\t\t.fhandle = fhandle,\n\t};\n\tstruct nfs4_server_caps_res res = {};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SERVER_CAPS],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tint status;\n\n\tstatus = nfs4_call_sync(server->client, server, &msg, &args.seq_args, &res.seq_res, 0);\n\tif (status == 0) {\n\t\tmemcpy(server->attr_bitmask, res.attr_bitmask, sizeof(server->attr_bitmask));\n\t\tserver->caps &= ~(NFS_CAP_ACLS|NFS_CAP_HARDLINKS|\n\t\t\t\tNFS_CAP_SYMLINKS|NFS_CAP_FILEID|\n\t\t\t\tNFS_CAP_MODE|NFS_CAP_NLINK|NFS_CAP_OWNER|\n\t\t\t\tNFS_CAP_OWNER_GROUP|NFS_CAP_ATIME|\n\t\t\t\tNFS_CAP_CTIME|NFS_CAP_MTIME);\n\t\tif (res.attr_bitmask[0] & FATTR4_WORD0_ACL)\n\t\t\tserver->caps |= NFS_CAP_ACLS;\n\t\tif (res.has_links != 0)\n\t\t\tserver->caps |= NFS_CAP_HARDLINKS;\n\t\tif (res.has_symlinks != 0)\n\t\t\tserver->caps |= NFS_CAP_SYMLINKS;\n\t\tif (res.attr_bitmask[0] & FATTR4_WORD0_FILEID)\n\t\t\tserver->caps |= NFS_CAP_FILEID;\n\t\tif (res.attr_bitmask[1] & FATTR4_WORD1_MODE)\n\t\t\tserver->caps |= NFS_CAP_MODE;\n\t\tif (res.attr_bitmask[1] & FATTR4_WORD1_NUMLINKS)\n\t\t\tserver->caps |= NFS_CAP_NLINK;\n\t\tif (res.attr_bitmask[1] & FATTR4_WORD1_OWNER)\n\t\t\tserver->caps |= NFS_CAP_OWNER;\n\t\tif (res.attr_bitmask[1] & FATTR4_WORD1_OWNER_GROUP)\n\t\t\tserver->caps |= NFS_CAP_OWNER_GROUP;\n\t\tif (res.attr_bitmask[1] & FATTR4_WORD1_TIME_ACCESS)\n\t\t\tserver->caps |= NFS_CAP_ATIME;\n\t\tif (res.attr_bitmask[1] & FATTR4_WORD1_TIME_METADATA)\n\t\t\tserver->caps |= NFS_CAP_CTIME;\n\t\tif (res.attr_bitmask[1] & FATTR4_WORD1_TIME_MODIFY)\n\t\t\tserver->caps |= NFS_CAP_MTIME;\n\n\t\tmemcpy(server->cache_consistency_bitmask, res.attr_bitmask, sizeof(server->cache_consistency_bitmask));\n\t\tserver->cache_consistency_bitmask[0] &= FATTR4_WORD0_CHANGE|FATTR4_WORD0_SIZE;\n\t\tserver->cache_consistency_bitmask[1] &= FATTR4_WORD1_TIME_METADATA|FATTR4_WORD1_TIME_MODIFY;\n\t\tserver->acl_bitmask = res.acl_bitmask;\n\t\tserver->fh_expire_type = res.fh_expire_type;\n\t}\n\n\treturn status;\n}\n\nint nfs4_server_capabilities(struct nfs_server *server, struct nfs_fh *fhandle)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(server,\n\t\t\t\t_nfs4_server_capabilities(server, fhandle),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int _nfs4_lookup_root(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\tstruct nfs_fsinfo *info)\n{\n\tstruct nfs4_lookup_root_arg args = {\n\t\t.bitmask = nfs4_fattr_bitmap,\n\t};\n\tstruct nfs4_lookup_res res = {\n\t\t.server = server,\n\t\t.fattr = info->fattr,\n\t\t.fh = fhandle,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LOOKUP_ROOT],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\n\tnfs_fattr_init(info->fattr);\n\treturn nfs4_call_sync(server->client, server, &msg, &args.seq_args, &res.seq_res, 0);\n}\n\nstatic int nfs4_lookup_root(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\tstruct nfs_fsinfo *info)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = _nfs4_lookup_root(server, fhandle, info);\n\t\tswitch (err) {\n\t\tcase 0:\n\t\tcase -NFS4ERR_WRONGSEC:\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\terr = nfs4_handle_exception(server, err, &exception);\n\t\t}\n\t} while (exception.retry);\nout:\n\treturn err;\n}\n\nstatic int nfs4_lookup_root_sec(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t\t\tstruct nfs_fsinfo *info, rpc_authflavor_t flavor)\n{\n\tstruct rpc_auth *auth;\n\tint ret;\n\n\tauth = rpcauth_create(flavor, server->client);\n\tif (IS_ERR(auth)) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\tret = nfs4_lookup_root(server, fhandle, info);\nout:\n\treturn ret;\n}\n\nstatic int nfs4_find_root_sec(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t\t      struct nfs_fsinfo *info)\n{\n\tint i, len, status = 0;\n\trpc_authflavor_t flav_array[NFS_MAX_SECFLAVORS];\n\n\tlen = rpcauth_list_flavors(flav_array, ARRAY_SIZE(flav_array));\n\tBUG_ON(len < 0);\n\n\tfor (i = 0; i < len; i++) {\n\t\t/* AUTH_UNIX is the default flavor if none was specified,\n\t\t * thus has already been tried. */\n\t\tif (flav_array[i] == RPC_AUTH_UNIX)\n\t\t\tcontinue;\n\n\t\tstatus = nfs4_lookup_root_sec(server, fhandle, info, flav_array[i]);\n\t\tif (status == -NFS4ERR_WRONGSEC || status == -EACCES)\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\t/*\n\t * -EACCESS could mean that the user doesn't have correct permissions\n\t * to access the mount.  It could also mean that we tried to mount\n\t * with a gss auth flavor, but rpc.gssd isn't running.  Either way,\n\t * existing mount programs don't handle -EACCES very well so it should\n\t * be mapped to -EPERM instead.\n\t */\n\tif (status == -EACCES)\n\t\tstatus = -EPERM;\n\treturn status;\n}\n\n/*\n * get the file handle for the \"/\" directory on the server\n */\nint nfs4_proc_get_rootfh(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t\t struct nfs_fsinfo *info)\n{\n\tint minor_version = server->nfs_client->cl_minorversion;\n\tint status = nfs4_lookup_root(server, fhandle, info);\n\tif ((status == -NFS4ERR_WRONGSEC) && !(server->flags & NFS_MOUNT_SECFLAVOUR))\n\t\t/*\n\t\t * A status of -NFS4ERR_WRONGSEC will be mapped to -EPERM\n\t\t * by nfs4_map_errors() as this function exits.\n\t\t */\n\t\tstatus = nfs_v4_minor_ops[minor_version]->find_root_sec(server, fhandle, info);\n\tif (status == 0)\n\t\tstatus = nfs4_server_capabilities(server, fhandle);\n\tif (status == 0)\n\t\tstatus = nfs4_do_fsinfo(server, fhandle, info);\n\treturn nfs4_map_errors(status);\n}\n\nstatic int nfs4_proc_get_root(struct nfs_server *server, struct nfs_fh *mntfh,\n\t\t\t      struct nfs_fsinfo *info)\n{\n\tint error;\n\tstruct nfs_fattr *fattr = info->fattr;\n\n\terror = nfs4_server_capabilities(server, mntfh);\n\tif (error < 0) {\n\t\tdprintk(\"nfs4_get_root: getcaps error = %d\\n\", -error);\n\t\treturn error;\n\t}\n\n\terror = nfs4_proc_getattr(server, mntfh, fattr);\n\tif (error < 0) {\n\t\tdprintk(\"nfs4_get_root: getattr error = %d\\n\", -error);\n\t\treturn error;\n\t}\n\n\tif (fattr->valid & NFS_ATTR_FATTR_FSID &&\n\t    !nfs_fsid_equal(&server->fsid, &fattr->fsid))\n\t\tmemcpy(&server->fsid, &fattr->fsid, sizeof(server->fsid));\n\n\treturn error;\n}\n\n/*\n * Get locations and (maybe) other attributes of a referral.\n * Note that we'll actually follow the referral later when\n * we detect fsid mismatch in inode revalidation\n */\nstatic int nfs4_get_referral(struct rpc_clnt *client, struct inode *dir,\n\t\t\t     const struct qstr *name, struct nfs_fattr *fattr,\n\t\t\t     struct nfs_fh *fhandle)\n{\n\tint status = -ENOMEM;\n\tstruct page *page = NULL;\n\tstruct nfs4_fs_locations *locations = NULL;\n\n\tpage = alloc_page(GFP_KERNEL);\n\tif (page == NULL)\n\t\tgoto out;\n\tlocations = kmalloc(sizeof(struct nfs4_fs_locations), GFP_KERNEL);\n\tif (locations == NULL)\n\t\tgoto out;\n\n\tstatus = nfs4_proc_fs_locations(client, dir, name, locations, page);\n\tif (status != 0)\n\t\tgoto out;\n\t/* Make sure server returned a different fsid for the referral */\n\tif (nfs_fsid_equal(&NFS_SERVER(dir)->fsid, &locations->fattr.fsid)) {\n\t\tdprintk(\"%s: server did not return a different fsid for\"\n\t\t\t\" a referral at %s\\n\", __func__, name->name);\n\t\tstatus = -EIO;\n\t\tgoto out;\n\t}\n\t/* Fixup attributes for the nfs_lookup() call to nfs_fhget() */\n\tnfs_fixup_referral_attributes(&locations->fattr);\n\n\t/* replace the lookup nfs_fattr with the locations nfs_fattr */\n\tmemcpy(fattr, &locations->fattr, sizeof(struct nfs_fattr));\n\tmemset(fhandle, 0, sizeof(struct nfs_fh));\nout:\n\tif (page)\n\t\t__free_page(page);\n\tkfree(locations);\n\treturn status;\n}\n\nstatic int _nfs4_proc_getattr(struct nfs_server *server, struct nfs_fh *fhandle, struct nfs_fattr *fattr)\n{\n\tstruct nfs4_getattr_arg args = {\n\t\t.fh = fhandle,\n\t\t.bitmask = server->attr_bitmask,\n\t};\n\tstruct nfs4_getattr_res res = {\n\t\t.fattr = fattr,\n\t\t.server = server,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETATTR],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\t\n\tnfs_fattr_init(fattr);\n\treturn nfs4_call_sync(server->client, server, &msg, &args.seq_args, &res.seq_res, 0);\n}\n\nstatic int nfs4_proc_getattr(struct nfs_server *server, struct nfs_fh *fhandle, struct nfs_fattr *fattr)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(server,\n\t\t\t\t_nfs4_proc_getattr(server, fhandle, fattr),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\n/* \n * The file is not closed if it is opened due to the a request to change\n * the size of the file. The open call will not be needed once the\n * VFS layer lookup-intents are implemented.\n *\n * Close is called when the inode is destroyed.\n * If we haven't opened the file for O_WRONLY, we\n * need to in the size_change case to obtain a stateid.\n *\n * Got race?\n * Because OPEN is always done by name in nfsv4, it is\n * possible that we opened a different file by the same\n * name.  We can recognize this race condition, but we\n * can't do anything about it besides returning an error.\n *\n * This will be fixed with VFS changes (lookup-intent).\n */\nstatic int\nnfs4_proc_setattr(struct dentry *dentry, struct nfs_fattr *fattr,\n\t\t  struct iattr *sattr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct rpc_cred *cred = NULL;\n\tstruct nfs4_state *state = NULL;\n\tint status;\n\n\tif (pnfs_ld_layoutret_on_setattr(inode))\n\t\tpnfs_return_layout(inode);\n\n\tnfs_fattr_init(fattr);\n\t\n\t/* Deal with open(O_TRUNC) */\n\tif (sattr->ia_valid & ATTR_OPEN)\n\t\tsattr->ia_valid &= ~(ATTR_MTIME|ATTR_CTIME|ATTR_OPEN);\n\n\t/* Optimization: if the end result is no change, don't RPC */\n\tif ((sattr->ia_valid & ~(ATTR_FILE)) == 0)\n\t\treturn 0;\n\n\t/* Search for an existing open(O_WRITE) file */\n\tif (sattr->ia_valid & ATTR_FILE) {\n\t\tstruct nfs_open_context *ctx;\n\n\t\tctx = nfs_file_open_context(sattr->ia_file);\n\t\tif (ctx) {\n\t\t\tcred = ctx->cred;\n\t\t\tstate = ctx->state;\n\t\t}\n\t}\n\n\tstatus = nfs4_do_setattr(inode, cred, fattr, sattr, state);\n\tif (status == 0)\n\t\tnfs_setattr_update_inode(inode, sattr);\n\treturn status;\n}\n\nstatic int _nfs4_proc_lookup(struct rpc_clnt *clnt, struct inode *dir,\n\t\tconst struct qstr *name, struct nfs_fh *fhandle,\n\t\tstruct nfs_fattr *fattr)\n{\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tint\t\t       status;\n\tstruct nfs4_lookup_arg args = {\n\t\t.bitmask = server->attr_bitmask,\n\t\t.dir_fh = NFS_FH(dir),\n\t\t.name = name,\n\t};\n\tstruct nfs4_lookup_res res = {\n\t\t.server = server,\n\t\t.fattr = fattr,\n\t\t.fh = fhandle,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LOOKUP],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\n\tnfs_fattr_init(fattr);\n\n\tdprintk(\"NFS call  lookup %s\\n\", name->name);\n\tstatus = nfs4_call_sync(clnt, server, &msg, &args.seq_args, &res.seq_res, 0);\n\tdprintk(\"NFS reply lookup: %d\\n\", status);\n\treturn status;\n}\n\nstatic void nfs_fixup_secinfo_attributes(struct nfs_fattr *fattr)\n{\n\tfattr->valid |= NFS_ATTR_FATTR_TYPE | NFS_ATTR_FATTR_MODE |\n\t\tNFS_ATTR_FATTR_NLINK | NFS_ATTR_FATTR_MOUNTPOINT;\n\tfattr->mode = S_IFDIR | S_IRUGO | S_IXUGO;\n\tfattr->nlink = 2;\n}\n\nstatic int nfs4_proc_lookup_common(struct rpc_clnt **clnt, struct inode *dir,\n\t\t\t\t   struct qstr *name, struct nfs_fh *fhandle,\n\t\t\t\t   struct nfs_fattr *fattr)\n{\n\tstruct nfs4_exception exception = { };\n\tstruct rpc_clnt *client = *clnt;\n\tint err;\n\tdo {\n\t\terr = _nfs4_proc_lookup(client, dir, name, fhandle, fattr);\n\t\tswitch (err) {\n\t\tcase -NFS4ERR_BADNAME:\n\t\t\terr = -ENOENT;\n\t\t\tgoto out;\n\t\tcase -NFS4ERR_MOVED:\n\t\t\terr = nfs4_get_referral(client, dir, name, fattr, fhandle);\n\t\t\tgoto out;\n\t\tcase -NFS4ERR_WRONGSEC:\n\t\t\terr = -EPERM;\n\t\t\tif (client != *clnt)\n\t\t\t\tgoto out;\n\n\t\t\tclient = nfs4_create_sec_client(client, dir, name);\n\t\t\tif (IS_ERR(client))\n\t\t\t\treturn PTR_ERR(client);\n\n\t\t\texception.retry = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = nfs4_handle_exception(NFS_SERVER(dir), err, &exception);\n\t\t}\n\t} while (exception.retry);\n\nout:\n\tif (err == 0)\n\t\t*clnt = client;\n\telse if (client != *clnt)\n\t\trpc_shutdown_client(client);\n\n\treturn err;\n}\n\nstatic int nfs4_proc_lookup(struct inode *dir, struct qstr *name,\n\t\t\t    struct nfs_fh *fhandle, struct nfs_fattr *fattr)\n{\n\tint status;\n\tstruct rpc_clnt *client = NFS_CLIENT(dir);\n\n\tstatus = nfs4_proc_lookup_common(&client, dir, name, fhandle, fattr);\n\tif (client != NFS_CLIENT(dir)) {\n\t\trpc_shutdown_client(client);\n\t\tnfs_fixup_secinfo_attributes(fattr);\n\t}\n\treturn status;\n}\n\nstruct rpc_clnt *\nnfs4_proc_lookup_mountpoint(struct inode *dir, struct qstr *name,\n\t\t\t    struct nfs_fh *fhandle, struct nfs_fattr *fattr)\n{\n\tint status;\n\tstruct rpc_clnt *client = rpc_clone_client(NFS_CLIENT(dir));\n\n\tstatus = nfs4_proc_lookup_common(&client, dir, name, fhandle, fattr);\n\tif (status < 0) {\n\t\trpc_shutdown_client(client);\n\t\treturn ERR_PTR(status);\n\t}\n\treturn client;\n}\n\nstatic int _nfs4_proc_access(struct inode *inode, struct nfs_access_entry *entry)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs4_accessargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.bitmask = server->cache_consistency_bitmask,\n\t};\n\tstruct nfs4_accessres res = {\n\t\t.server = server,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_ACCESS],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t\t.rpc_cred = entry->cred,\n\t};\n\tint mode = entry->mask;\n\tint status;\n\n\t/*\n\t * Determine which access bits we want to ask for...\n\t */\n\tif (mode & MAY_READ)\n\t\targs.access |= NFS4_ACCESS_READ;\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tif (mode & MAY_WRITE)\n\t\t\targs.access |= NFS4_ACCESS_MODIFY | NFS4_ACCESS_EXTEND | NFS4_ACCESS_DELETE;\n\t\tif (mode & MAY_EXEC)\n\t\t\targs.access |= NFS4_ACCESS_LOOKUP;\n\t} else {\n\t\tif (mode & MAY_WRITE)\n\t\t\targs.access |= NFS4_ACCESS_MODIFY | NFS4_ACCESS_EXTEND;\n\t\tif (mode & MAY_EXEC)\n\t\t\targs.access |= NFS4_ACCESS_EXECUTE;\n\t}\n\n\tres.fattr = nfs_alloc_fattr();\n\tif (res.fattr == NULL)\n\t\treturn -ENOMEM;\n\n\tstatus = nfs4_call_sync(server->client, server, &msg, &args.seq_args, &res.seq_res, 0);\n\tif (!status) {\n\t\tnfs_access_set_mask(entry, res.access);\n\t\tnfs_refresh_inode(inode, res.fattr);\n\t}\n\tnfs_free_fattr(res.fattr);\n\treturn status;\n}\n\nstatic int nfs4_proc_access(struct inode *inode, struct nfs_access_entry *entry)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(inode),\n\t\t\t\t_nfs4_proc_access(inode, entry),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\n/*\n * TODO: For the time being, we don't try to get any attributes\n * along with any of the zero-copy operations READ, READDIR,\n * READLINK, WRITE.\n *\n * In the case of the first three, we want to put the GETATTR\n * after the read-type operation -- this is because it is hard\n * to predict the length of a GETATTR response in v4, and thus\n * align the READ data correctly.  This means that the GETATTR\n * may end up partially falling into the page cache, and we should\n * shift it into the 'tail' of the xdr_buf before processing.\n * To do this efficiently, we need to know the total length\n * of data received, which doesn't seem to be available outside\n * of the RPC layer.\n *\n * In the case of WRITE, we also want to put the GETATTR after\n * the operation -- in this case because we want to make sure\n * we get the post-operation mtime and size.\n *\n * Both of these changes to the XDR layer would in fact be quite\n * minor, but I decided to leave them for a subsequent patch.\n */\nstatic int _nfs4_proc_readlink(struct inode *inode, struct page *page,\n\t\tunsigned int pgbase, unsigned int pglen)\n{\n\tstruct nfs4_readlink args = {\n\t\t.fh       = NFS_FH(inode),\n\t\t.pgbase\t  = pgbase,\n\t\t.pglen    = pglen,\n\t\t.pages    = &page,\n\t};\n\tstruct nfs4_readlink_res res;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_READLINK],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\n\treturn nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode), &msg, &args.seq_args, &res.seq_res, 0);\n}\n\nstatic int nfs4_proc_readlink(struct inode *inode, struct page *page,\n\t\tunsigned int pgbase, unsigned int pglen)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(inode),\n\t\t\t\t_nfs4_proc_readlink(inode, page, pgbase, pglen),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\n/*\n * This is just for mknod.  open(O_CREAT) will always do ->open_context().\n */\nstatic int\nnfs4_proc_create(struct inode *dir, struct dentry *dentry, struct iattr *sattr,\n\t\t int flags)\n{\n\tstruct nfs_open_context *ctx;\n\tstruct nfs4_state *state;\n\tint status = 0;\n\n\tctx = alloc_nfs_open_context(dentry, FMODE_READ);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tsattr->ia_mode &= ~current_umask();\n\tstate = nfs4_do_open(dir, dentry, ctx->mode,\n\t\t\tflags, sattr, ctx->cred,\n\t\t\t&ctx->mdsthreshold);\n\td_drop(dentry);\n\tif (IS_ERR(state)) {\n\t\tstatus = PTR_ERR(state);\n\t\tgoto out;\n\t}\n\td_add(dentry, igrab(state->inode));\n\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\tctx->state = state;\nout:\n\tput_nfs_open_context(ctx);\n\treturn status;\n}\n\nstatic int _nfs4_proc_remove(struct inode *dir, struct qstr *name)\n{\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tstruct nfs_removeargs args = {\n\t\t.fh = NFS_FH(dir),\n\t\t.name = *name,\n\t};\n\tstruct nfs_removeres res = {\n\t\t.server = server,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_REMOVE],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tint status;\n\n\tstatus = nfs4_call_sync(server->client, server, &msg, &args.seq_args, &res.seq_res, 1);\n\tif (status == 0)\n\t\tupdate_changeattr(dir, &res.cinfo);\n\treturn status;\n}\n\nstatic int nfs4_proc_remove(struct inode *dir, struct qstr *name)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(dir),\n\t\t\t\t_nfs4_proc_remove(dir, name),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic void nfs4_proc_unlink_setup(struct rpc_message *msg, struct inode *dir)\n{\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tstruct nfs_removeargs *args = msg->rpc_argp;\n\tstruct nfs_removeres *res = msg->rpc_resp;\n\n\tres->server = server;\n\tmsg->rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_REMOVE];\n\tnfs41_init_sequence(&args->seq_args, &res->seq_res, 1);\n}\n\nstatic void nfs4_proc_unlink_rpc_prepare(struct rpc_task *task, struct nfs_unlinkdata *data)\n{\n\tif (nfs4_setup_sequence(NFS_SERVER(data->dir),\n\t\t\t\t&data->args.seq_args,\n\t\t\t\t&data->res.seq_res,\n\t\t\t\ttask))\n\t\treturn;\n\trpc_call_start(task);\n}\n\nstatic int nfs4_proc_unlink_done(struct rpc_task *task, struct inode *dir)\n{\n\tstruct nfs_removeres *res = task->tk_msg.rpc_resp;\n\n\tif (!nfs4_sequence_done(task, &res->seq_res))\n\t\treturn 0;\n\tif (nfs4_async_handle_error(task, res->server, NULL) == -EAGAIN)\n\t\treturn 0;\n\tupdate_changeattr(dir, &res->cinfo);\n\treturn 1;\n}\n\nstatic void nfs4_proc_rename_setup(struct rpc_message *msg, struct inode *dir)\n{\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tstruct nfs_renameargs *arg = msg->rpc_argp;\n\tstruct nfs_renameres *res = msg->rpc_resp;\n\n\tmsg->rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_RENAME];\n\tres->server = server;\n\tnfs41_init_sequence(&arg->seq_args, &res->seq_res, 1);\n}\n\nstatic void nfs4_proc_rename_rpc_prepare(struct rpc_task *task, struct nfs_renamedata *data)\n{\n\tif (nfs4_setup_sequence(NFS_SERVER(data->old_dir),\n\t\t\t\t&data->args.seq_args,\n\t\t\t\t&data->res.seq_res,\n\t\t\t\ttask))\n\t\treturn;\n\trpc_call_start(task);\n}\n\nstatic int nfs4_proc_rename_done(struct rpc_task *task, struct inode *old_dir,\n\t\t\t\t struct inode *new_dir)\n{\n\tstruct nfs_renameres *res = task->tk_msg.rpc_resp;\n\n\tif (!nfs4_sequence_done(task, &res->seq_res))\n\t\treturn 0;\n\tif (nfs4_async_handle_error(task, res->server, NULL) == -EAGAIN)\n\t\treturn 0;\n\n\tupdate_changeattr(old_dir, &res->old_cinfo);\n\tupdate_changeattr(new_dir, &res->new_cinfo);\n\treturn 1;\n}\n\nstatic int _nfs4_proc_rename(struct inode *old_dir, struct qstr *old_name,\n\t\tstruct inode *new_dir, struct qstr *new_name)\n{\n\tstruct nfs_server *server = NFS_SERVER(old_dir);\n\tstruct nfs_renameargs arg = {\n\t\t.old_dir = NFS_FH(old_dir),\n\t\t.new_dir = NFS_FH(new_dir),\n\t\t.old_name = old_name,\n\t\t.new_name = new_name,\n\t};\n\tstruct nfs_renameres res = {\n\t\t.server = server,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_RENAME],\n\t\t.rpc_argp = &arg,\n\t\t.rpc_resp = &res,\n\t};\n\tint status = -ENOMEM;\n\t\n\tstatus = nfs4_call_sync(server->client, server, &msg, &arg.seq_args, &res.seq_res, 1);\n\tif (!status) {\n\t\tupdate_changeattr(old_dir, &res.old_cinfo);\n\t\tupdate_changeattr(new_dir, &res.new_cinfo);\n\t}\n\treturn status;\n}\n\nstatic int nfs4_proc_rename(struct inode *old_dir, struct qstr *old_name,\n\t\tstruct inode *new_dir, struct qstr *new_name)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(old_dir),\n\t\t\t\t_nfs4_proc_rename(old_dir, old_name,\n\t\t\t\t\tnew_dir, new_name),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int _nfs4_proc_link(struct inode *inode, struct inode *dir, struct qstr *name)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs4_link_arg arg = {\n\t\t.fh     = NFS_FH(inode),\n\t\t.dir_fh = NFS_FH(dir),\n\t\t.name   = name,\n\t\t.bitmask = server->attr_bitmask,\n\t};\n\tstruct nfs4_link_res res = {\n\t\t.server = server,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LINK],\n\t\t.rpc_argp = &arg,\n\t\t.rpc_resp = &res,\n\t};\n\tint status = -ENOMEM;\n\n\tres.fattr = nfs_alloc_fattr();\n\tif (res.fattr == NULL)\n\t\tgoto out;\n\n\tstatus = nfs4_call_sync(server->client, server, &msg, &arg.seq_args, &res.seq_res, 1);\n\tif (!status) {\n\t\tupdate_changeattr(dir, &res.cinfo);\n\t\tnfs_post_op_update_inode(inode, res.fattr);\n\t}\nout:\n\tnfs_free_fattr(res.fattr);\n\treturn status;\n}\n\nstatic int nfs4_proc_link(struct inode *inode, struct inode *dir, struct qstr *name)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(inode),\n\t\t\t\t_nfs4_proc_link(inode, dir, name),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstruct nfs4_createdata {\n\tstruct rpc_message msg;\n\tstruct nfs4_create_arg arg;\n\tstruct nfs4_create_res res;\n\tstruct nfs_fh fh;\n\tstruct nfs_fattr fattr;\n};\n\nstatic struct nfs4_createdata *nfs4_alloc_createdata(struct inode *dir,\n\t\tstruct qstr *name, struct iattr *sattr, u32 ftype)\n{\n\tstruct nfs4_createdata *data;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (data != NULL) {\n\t\tstruct nfs_server *server = NFS_SERVER(dir);\n\n\t\tdata->msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_CREATE];\n\t\tdata->msg.rpc_argp = &data->arg;\n\t\tdata->msg.rpc_resp = &data->res;\n\t\tdata->arg.dir_fh = NFS_FH(dir);\n\t\tdata->arg.server = server;\n\t\tdata->arg.name = name;\n\t\tdata->arg.attrs = sattr;\n\t\tdata->arg.ftype = ftype;\n\t\tdata->arg.bitmask = server->attr_bitmask;\n\t\tdata->res.server = server;\n\t\tdata->res.fh = &data->fh;\n\t\tdata->res.fattr = &data->fattr;\n\t\tnfs_fattr_init(data->res.fattr);\n\t}\n\treturn data;\n}\n\nstatic int nfs4_do_create(struct inode *dir, struct dentry *dentry, struct nfs4_createdata *data)\n{\n\tint status = nfs4_call_sync(NFS_SERVER(dir)->client, NFS_SERVER(dir), &data->msg,\n\t\t\t\t    &data->arg.seq_args, &data->res.seq_res, 1);\n\tif (status == 0) {\n\t\tupdate_changeattr(dir, &data->res.dir_cinfo);\n\t\tstatus = nfs_instantiate(dentry, data->res.fh, data->res.fattr);\n\t}\n\treturn status;\n}\n\nstatic void nfs4_free_createdata(struct nfs4_createdata *data)\n{\n\tkfree(data);\n}\n\nstatic int _nfs4_proc_symlink(struct inode *dir, struct dentry *dentry,\n\t\tstruct page *page, unsigned int len, struct iattr *sattr)\n{\n\tstruct nfs4_createdata *data;\n\tint status = -ENAMETOOLONG;\n\n\tif (len > NFS4_MAXPATHLEN)\n\t\tgoto out;\n\n\tstatus = -ENOMEM;\n\tdata = nfs4_alloc_createdata(dir, &dentry->d_name, sattr, NF4LNK);\n\tif (data == NULL)\n\t\tgoto out;\n\n\tdata->msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SYMLINK];\n\tdata->arg.u.symlink.pages = &page;\n\tdata->arg.u.symlink.len = len;\n\t\n\tstatus = nfs4_do_create(dir, dentry, data);\n\n\tnfs4_free_createdata(data);\nout:\n\treturn status;\n}\n\nstatic int nfs4_proc_symlink(struct inode *dir, struct dentry *dentry,\n\t\tstruct page *page, unsigned int len, struct iattr *sattr)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(dir),\n\t\t\t\t_nfs4_proc_symlink(dir, dentry, page,\n\t\t\t\t\t\t\tlen, sattr),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int _nfs4_proc_mkdir(struct inode *dir, struct dentry *dentry,\n\t\tstruct iattr *sattr)\n{\n\tstruct nfs4_createdata *data;\n\tint status = -ENOMEM;\n\n\tdata = nfs4_alloc_createdata(dir, &dentry->d_name, sattr, NF4DIR);\n\tif (data == NULL)\n\t\tgoto out;\n\n\tstatus = nfs4_do_create(dir, dentry, data);\n\n\tnfs4_free_createdata(data);\nout:\n\treturn status;\n}\n\nstatic int nfs4_proc_mkdir(struct inode *dir, struct dentry *dentry,\n\t\tstruct iattr *sattr)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\tsattr->ia_mode &= ~current_umask();\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(dir),\n\t\t\t\t_nfs4_proc_mkdir(dir, dentry, sattr),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int _nfs4_proc_readdir(struct dentry *dentry, struct rpc_cred *cred,\n\t\tu64 cookie, struct page **pages, unsigned int count, int plus)\n{\n\tstruct inode\t\t*dir = dentry->d_inode;\n\tstruct nfs4_readdir_arg args = {\n\t\t.fh = NFS_FH(dir),\n\t\t.pages = pages,\n\t\t.pgbase = 0,\n\t\t.count = count,\n\t\t.bitmask = NFS_SERVER(dentry->d_inode)->attr_bitmask,\n\t\t.plus = plus,\n\t};\n\tstruct nfs4_readdir_res res;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_READDIR],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t\t.rpc_cred = cred,\n\t};\n\tint\t\t\tstatus;\n\n\tdprintk(\"%s: dentry = %s/%s, cookie = %Lu\\n\", __func__,\n\t\t\tdentry->d_parent->d_name.name,\n\t\t\tdentry->d_name.name,\n\t\t\t(unsigned long long)cookie);\n\tnfs4_setup_readdir(cookie, NFS_I(dir)->cookieverf, dentry, &args);\n\tres.pgbase = args.pgbase;\n\tstatus = nfs4_call_sync(NFS_SERVER(dir)->client, NFS_SERVER(dir), &msg, &args.seq_args, &res.seq_res, 0);\n\tif (status >= 0) {\n\t\tmemcpy(NFS_I(dir)->cookieverf, res.verifier.data, NFS4_VERIFIER_SIZE);\n\t\tstatus += args.pgbase;\n\t}\n\n\tnfs_invalidate_atime(dir);\n\n\tdprintk(\"%s: returns %d\\n\", __func__, status);\n\treturn status;\n}\n\nstatic int nfs4_proc_readdir(struct dentry *dentry, struct rpc_cred *cred,\n\t\tu64 cookie, struct page **pages, unsigned int count, int plus)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(dentry->d_inode),\n\t\t\t\t_nfs4_proc_readdir(dentry, cred, cookie,\n\t\t\t\t\tpages, count, plus),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int _nfs4_proc_mknod(struct inode *dir, struct dentry *dentry,\n\t\tstruct iattr *sattr, dev_t rdev)\n{\n\tstruct nfs4_createdata *data;\n\tint mode = sattr->ia_mode;\n\tint status = -ENOMEM;\n\n\tBUG_ON(!(sattr->ia_valid & ATTR_MODE));\n\tBUG_ON(!S_ISFIFO(mode) && !S_ISBLK(mode) && !S_ISCHR(mode) && !S_ISSOCK(mode));\n\n\tdata = nfs4_alloc_createdata(dir, &dentry->d_name, sattr, NF4SOCK);\n\tif (data == NULL)\n\t\tgoto out;\n\n\tif (S_ISFIFO(mode))\n\t\tdata->arg.ftype = NF4FIFO;\n\telse if (S_ISBLK(mode)) {\n\t\tdata->arg.ftype = NF4BLK;\n\t\tdata->arg.u.device.specdata1 = MAJOR(rdev);\n\t\tdata->arg.u.device.specdata2 = MINOR(rdev);\n\t}\n\telse if (S_ISCHR(mode)) {\n\t\tdata->arg.ftype = NF4CHR;\n\t\tdata->arg.u.device.specdata1 = MAJOR(rdev);\n\t\tdata->arg.u.device.specdata2 = MINOR(rdev);\n\t}\n\t\n\tstatus = nfs4_do_create(dir, dentry, data);\n\n\tnfs4_free_createdata(data);\nout:\n\treturn status;\n}\n\nstatic int nfs4_proc_mknod(struct inode *dir, struct dentry *dentry,\n\t\tstruct iattr *sattr, dev_t rdev)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\tsattr->ia_mode &= ~current_umask();\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(dir),\n\t\t\t\t_nfs4_proc_mknod(dir, dentry, sattr, rdev),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int _nfs4_proc_statfs(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t struct nfs_fsstat *fsstat)\n{\n\tstruct nfs4_statfs_arg args = {\n\t\t.fh = fhandle,\n\t\t.bitmask = server->attr_bitmask,\n\t};\n\tstruct nfs4_statfs_res res = {\n\t\t.fsstat = fsstat,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_STATFS],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\n\tnfs_fattr_init(fsstat->fattr);\n\treturn  nfs4_call_sync(server->client, server, &msg, &args.seq_args, &res.seq_res, 0);\n}\n\nstatic int nfs4_proc_statfs(struct nfs_server *server, struct nfs_fh *fhandle, struct nfs_fsstat *fsstat)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(server,\n\t\t\t\t_nfs4_proc_statfs(server, fhandle, fsstat),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int _nfs4_do_fsinfo(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\tstruct nfs_fsinfo *fsinfo)\n{\n\tstruct nfs4_fsinfo_arg args = {\n\t\t.fh = fhandle,\n\t\t.bitmask = server->attr_bitmask,\n\t};\n\tstruct nfs4_fsinfo_res res = {\n\t\t.fsinfo = fsinfo,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_FSINFO],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\n\treturn nfs4_call_sync(server->client, server, &msg, &args.seq_args, &res.seq_res, 0);\n}\n\nstatic int nfs4_do_fsinfo(struct nfs_server *server, struct nfs_fh *fhandle, struct nfs_fsinfo *fsinfo)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\tdo {\n\t\terr = nfs4_handle_exception(server,\n\t\t\t\t_nfs4_do_fsinfo(server, fhandle, fsinfo),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int nfs4_proc_fsinfo(struct nfs_server *server, struct nfs_fh *fhandle, struct nfs_fsinfo *fsinfo)\n{\n\tint error;\n\n\tnfs_fattr_init(fsinfo->fattr);\n\terror = nfs4_do_fsinfo(server, fhandle, fsinfo);\n\tif (error == 0) {\n\t\t/* block layout checks this! */\n\t\tserver->pnfs_blksize = fsinfo->blksize;\n\t\tset_pnfs_layoutdriver(server, fhandle, fsinfo->layouttype);\n\t}\n\n\treturn error;\n}\n\nstatic int _nfs4_proc_pathconf(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\tstruct nfs_pathconf *pathconf)\n{\n\tstruct nfs4_pathconf_arg args = {\n\t\t.fh = fhandle,\n\t\t.bitmask = server->attr_bitmask,\n\t};\n\tstruct nfs4_pathconf_res res = {\n\t\t.pathconf = pathconf,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_PATHCONF],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\n\t/* None of the pathconf attributes are mandatory to implement */\n\tif ((args.bitmask[0] & nfs4_pathconf_bitmap[0]) == 0) {\n\t\tmemset(pathconf, 0, sizeof(*pathconf));\n\t\treturn 0;\n\t}\n\n\tnfs_fattr_init(pathconf->fattr);\n\treturn nfs4_call_sync(server->client, server, &msg, &args.seq_args, &res.seq_res, 0);\n}\n\nstatic int nfs4_proc_pathconf(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\tstruct nfs_pathconf *pathconf)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\tdo {\n\t\terr = nfs4_handle_exception(server,\n\t\t\t\t_nfs4_proc_pathconf(server, fhandle, pathconf),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nvoid __nfs4_read_done_cb(struct nfs_read_data *data)\n{\n\tnfs_invalidate_atime(data->header->inode);\n}\n\nstatic int nfs4_read_done_cb(struct rpc_task *task, struct nfs_read_data *data)\n{\n\tstruct nfs_server *server = NFS_SERVER(data->header->inode);\n\n\tif (nfs4_async_handle_error(task, server, data->args.context->state) == -EAGAIN) {\n\t\trpc_restart_call_prepare(task);\n\t\treturn -EAGAIN;\n\t}\n\n\t__nfs4_read_done_cb(data);\n\tif (task->tk_status > 0)\n\t\trenew_lease(server, data->timestamp);\n\treturn 0;\n}\n\nstatic int nfs4_read_done(struct rpc_task *task, struct nfs_read_data *data)\n{\n\n\tdprintk(\"--> %s\\n\", __func__);\n\n\tif (!nfs4_sequence_done(task, &data->res.seq_res))\n\t\treturn -EAGAIN;\n\n\treturn data->read_done_cb ? data->read_done_cb(task, data) :\n\t\t\t\t    nfs4_read_done_cb(task, data);\n}\n\nstatic void nfs4_proc_read_setup(struct nfs_read_data *data, struct rpc_message *msg)\n{\n\tdata->timestamp   = jiffies;\n\tdata->read_done_cb = nfs4_read_done_cb;\n\tmsg->rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_READ];\n\tnfs41_init_sequence(&data->args.seq_args, &data->res.seq_res, 0);\n}\n\nstatic void nfs4_proc_read_rpc_prepare(struct rpc_task *task, struct nfs_read_data *data)\n{\n\tif (nfs4_setup_sequence(NFS_SERVER(data->header->inode),\n\t\t\t\t&data->args.seq_args,\n\t\t\t\t&data->res.seq_res,\n\t\t\t\ttask))\n\t\treturn;\n\trpc_call_start(task);\n}\n\nstatic int nfs4_write_done_cb(struct rpc_task *task, struct nfs_write_data *data)\n{\n\tstruct inode *inode = data->header->inode;\n\t\n\tif (nfs4_async_handle_error(task, NFS_SERVER(inode), data->args.context->state) == -EAGAIN) {\n\t\trpc_restart_call_prepare(task);\n\t\treturn -EAGAIN;\n\t}\n\tif (task->tk_status >= 0) {\n\t\trenew_lease(NFS_SERVER(inode), data->timestamp);\n\t\tnfs_post_op_update_inode_force_wcc(inode, &data->fattr);\n\t}\n\treturn 0;\n}\n\nstatic int nfs4_write_done(struct rpc_task *task, struct nfs_write_data *data)\n{\n\tif (!nfs4_sequence_done(task, &data->res.seq_res))\n\t\treturn -EAGAIN;\n\treturn data->write_done_cb ? data->write_done_cb(task, data) :\n\t\tnfs4_write_done_cb(task, data);\n}\n\nstatic\nbool nfs4_write_need_cache_consistency_data(const struct nfs_write_data *data)\n{\n\tconst struct nfs_pgio_header *hdr = data->header;\n\n\t/* Don't request attributes for pNFS or O_DIRECT writes */\n\tif (data->ds_clp != NULL || hdr->dreq != NULL)\n\t\treturn false;\n\t/* Otherwise, request attributes if and only if we don't hold\n\t * a delegation\n\t */\n\treturn nfs4_have_delegation(hdr->inode, FMODE_READ) == 0;\n}\n\nstatic void nfs4_proc_write_setup(struct nfs_write_data *data, struct rpc_message *msg)\n{\n\tstruct nfs_server *server = NFS_SERVER(data->header->inode);\n\n\tif (!nfs4_write_need_cache_consistency_data(data)) {\n\t\tdata->args.bitmask = NULL;\n\t\tdata->res.fattr = NULL;\n\t} else\n\t\tdata->args.bitmask = server->cache_consistency_bitmask;\n\n\tif (!data->write_done_cb)\n\t\tdata->write_done_cb = nfs4_write_done_cb;\n\tdata->res.server = server;\n\tdata->timestamp   = jiffies;\n\n\tmsg->rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_WRITE];\n\tnfs41_init_sequence(&data->args.seq_args, &data->res.seq_res, 1);\n}\n\nstatic void nfs4_proc_write_rpc_prepare(struct rpc_task *task, struct nfs_write_data *data)\n{\n\tif (nfs4_setup_sequence(NFS_SERVER(data->header->inode),\n\t\t\t\t&data->args.seq_args,\n\t\t\t\t&data->res.seq_res,\n\t\t\t\ttask))\n\t\treturn;\n\trpc_call_start(task);\n}\n\nstatic void nfs4_proc_commit_rpc_prepare(struct rpc_task *task, struct nfs_commit_data *data)\n{\n\tif (nfs4_setup_sequence(NFS_SERVER(data->inode),\n\t\t\t\t&data->args.seq_args,\n\t\t\t\t&data->res.seq_res,\n\t\t\t\ttask))\n\t\treturn;\n\trpc_call_start(task);\n}\n\nstatic int nfs4_commit_done_cb(struct rpc_task *task, struct nfs_commit_data *data)\n{\n\tstruct inode *inode = data->inode;\n\n\tif (nfs4_async_handle_error(task, NFS_SERVER(inode), NULL) == -EAGAIN) {\n\t\trpc_restart_call_prepare(task);\n\t\treturn -EAGAIN;\n\t}\n\treturn 0;\n}\n\nstatic int nfs4_commit_done(struct rpc_task *task, struct nfs_commit_data *data)\n{\n\tif (!nfs4_sequence_done(task, &data->res.seq_res))\n\t\treturn -EAGAIN;\n\treturn data->commit_done_cb(task, data);\n}\n\nstatic void nfs4_proc_commit_setup(struct nfs_commit_data *data, struct rpc_message *msg)\n{\n\tstruct nfs_server *server = NFS_SERVER(data->inode);\n\n\tif (data->commit_done_cb == NULL)\n\t\tdata->commit_done_cb = nfs4_commit_done_cb;\n\tdata->res.server = server;\n\tmsg->rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_COMMIT];\n\tnfs41_init_sequence(&data->args.seq_args, &data->res.seq_res, 1);\n}\n\nstruct nfs4_renewdata {\n\tstruct nfs_client\t*client;\n\tunsigned long\t\ttimestamp;\n};\n\n/*\n * nfs4_proc_async_renew(): This is not one of the nfs_rpc_ops; it is a special\n * standalone procedure for queueing an asynchronous RENEW.\n */\nstatic void nfs4_renew_release(void *calldata)\n{\n\tstruct nfs4_renewdata *data = calldata;\n\tstruct nfs_client *clp = data->client;\n\n\tif (atomic_read(&clp->cl_count) > 1)\n\t\tnfs4_schedule_state_renewal(clp);\n\tnfs_put_client(clp);\n\tkfree(data);\n}\n\nstatic void nfs4_renew_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_renewdata *data = calldata;\n\tstruct nfs_client *clp = data->client;\n\tunsigned long timestamp = data->timestamp;\n\n\tif (task->tk_status < 0) {\n\t\t/* Unless we're shutting down, schedule state recovery! */\n\t\tif (test_bit(NFS_CS_RENEWD, &clp->cl_res_state) == 0)\n\t\t\treturn;\n\t\tif (task->tk_status != NFS4ERR_CB_PATH_DOWN) {\n\t\t\tnfs4_schedule_lease_recovery(clp);\n\t\t\treturn;\n\t\t}\n\t\tnfs4_schedule_path_down_recovery(clp);\n\t}\n\tdo_renew_lease(clp, timestamp);\n}\n\nstatic const struct rpc_call_ops nfs4_renew_ops = {\n\t.rpc_call_done = nfs4_renew_done,\n\t.rpc_release = nfs4_renew_release,\n};\n\nstatic int nfs4_proc_async_renew(struct nfs_client *clp, struct rpc_cred *cred, unsigned renew_flags)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_RENEW],\n\t\t.rpc_argp\t= clp,\n\t\t.rpc_cred\t= cred,\n\t};\n\tstruct nfs4_renewdata *data;\n\n\tif (renew_flags == 0)\n\t\treturn 0;\n\tif (!atomic_inc_not_zero(&clp->cl_count))\n\t\treturn -EIO;\n\tdata = kmalloc(sizeof(*data), GFP_NOFS);\n\tif (data == NULL)\n\t\treturn -ENOMEM;\n\tdata->client = clp;\n\tdata->timestamp = jiffies;\n\treturn rpc_call_async(clp->cl_rpcclient, &msg, RPC_TASK_SOFT,\n\t\t\t&nfs4_renew_ops, data);\n}\n\nstatic int nfs4_proc_renew(struct nfs_client *clp, struct rpc_cred *cred)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_RENEW],\n\t\t.rpc_argp\t= clp,\n\t\t.rpc_cred\t= cred,\n\t};\n\tunsigned long now = jiffies;\n\tint status;\n\n\tstatus = rpc_call_sync(clp->cl_rpcclient, &msg, 0);\n\tif (status < 0)\n\t\treturn status;\n\tdo_renew_lease(clp, now);\n\treturn 0;\n}\n\nstatic inline int nfs4_server_supports_acls(struct nfs_server *server)\n{\n\treturn (server->caps & NFS_CAP_ACLS)\n\t\t&& (server->acl_bitmask & ACL4_SUPPORT_ALLOW_ACL)\n\t\t&& (server->acl_bitmask & ACL4_SUPPORT_DENY_ACL);\n}\n\n/* Assuming that XATTR_SIZE_MAX is a multiple of PAGE_SIZE, and that\n * it's OK to put sizeof(void) * (XATTR_SIZE_MAX/PAGE_SIZE) bytes on\n * the stack.\n */\n#define NFS4ACL_MAXPAGES DIV_ROUND_UP(XATTR_SIZE_MAX, PAGE_SIZE)\n\nstatic int buf_to_pages_noslab(const void *buf, size_t buflen,\n\t\tstruct page **pages, unsigned int *pgbase)\n{\n\tstruct page *newpage, **spages;\n\tint rc = 0;\n\tsize_t len;\n\tspages = pages;\n\n\tdo {\n\t\tlen = min_t(size_t, PAGE_SIZE, buflen);\n\t\tnewpage = alloc_page(GFP_KERNEL);\n\n\t\tif (newpage == NULL)\n\t\t\tgoto unwind;\n\t\tmemcpy(page_address(newpage), buf, len);\n                buf += len;\n                buflen -= len;\n\t\t*pages++ = newpage;\n\t\trc++;\n\t} while (buflen != 0);\n\n\treturn rc;\n\nunwind:\n\tfor(; rc > 0; rc--)\n\t\t__free_page(spages[rc-1]);\n\treturn -ENOMEM;\n}\n\nstruct nfs4_cached_acl {\n\tint cached;\n\tsize_t len;\n\tchar data[0];\n};\n\nstatic void nfs4_set_cached_acl(struct inode *inode, struct nfs4_cached_acl *acl)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tspin_lock(&inode->i_lock);\n\tkfree(nfsi->nfs4_acl);\n\tnfsi->nfs4_acl = acl;\n\tspin_unlock(&inode->i_lock);\n}\n\nstatic void nfs4_zap_acl_attr(struct inode *inode)\n{\n\tnfs4_set_cached_acl(inode, NULL);\n}\n\nstatic inline ssize_t nfs4_read_cached_acl(struct inode *inode, char *buf, size_t buflen)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs4_cached_acl *acl;\n\tint ret = -ENOENT;\n\n\tspin_lock(&inode->i_lock);\n\tacl = nfsi->nfs4_acl;\n\tif (acl == NULL)\n\t\tgoto out;\n\tif (buf == NULL) /* user is just asking for length */\n\t\tgoto out_len;\n\tif (acl->cached == 0)\n\t\tgoto out;\n\tret = -ERANGE; /* see getxattr(2) man page */\n\tif (acl->len > buflen)\n\t\tgoto out;\n\tmemcpy(buf, acl->data, acl->len);\nout_len:\n\tret = acl->len;\nout:\n\tspin_unlock(&inode->i_lock);\n\treturn ret;\n}\n\nstatic void nfs4_write_cached_acl(struct inode *inode, struct page **pages, size_t pgbase, size_t acl_len)\n{\n\tstruct nfs4_cached_acl *acl;\n\tsize_t buflen = sizeof(*acl) + acl_len;\n\n\tif (buflen <= PAGE_SIZE) {\n\t\tacl = kmalloc(buflen, GFP_KERNEL);\n\t\tif (acl == NULL)\n\t\t\tgoto out;\n\t\tacl->cached = 1;\n\t\t_copy_from_pages(acl->data, pages, pgbase, acl_len);\n\t} else {\n\t\tacl = kmalloc(sizeof(*acl), GFP_KERNEL);\n\t\tif (acl == NULL)\n\t\t\tgoto out;\n\t\tacl->cached = 0;\n\t}\n\tacl->len = acl_len;\nout:\n\tnfs4_set_cached_acl(inode, acl);\n}\n\n/*\n * The getxattr API returns the required buffer length when called with a\n * NULL buf. The NFSv4 acl tool then calls getxattr again after allocating\n * the required buf.  On a NULL buf, we send a page of data to the server\n * guessing that the ACL request can be serviced by a page. If so, we cache\n * up to the page of ACL data, and the 2nd call to getxattr is serviced by\n * the cache. If not so, we throw away the page, and cache the required\n * length. The next getxattr call will then produce another round trip to\n * the server, this time with the input buf of the required size.\n */\nstatic ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf)\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}\n\nstatic ssize_t nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct nfs4_exception exception = { };\n\tssize_t ret;\n\tdo {\n\t\tret = __nfs4_get_acl_uncached(inode, buf, buflen);\n\t\tif (ret >= 0)\n\t\t\tbreak;\n\t\tret = nfs4_handle_exception(NFS_SERVER(inode), ret, &exception);\n\t} while (exception.retry);\n\treturn ret;\n}\n\nstatic ssize_t nfs4_proc_get_acl(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tint ret;\n\n\tif (!nfs4_server_supports_acls(server))\n\t\treturn -EOPNOTSUPP;\n\tret = nfs_revalidate_inode(server, inode);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (NFS_I(inode)->cache_validity & NFS_INO_INVALID_ACL)\n\t\tnfs_zap_acl_cache(inode);\n\tret = nfs4_read_cached_acl(inode, buf, buflen);\n\tif (ret != -ENOENT)\n\t\t/* -ENOENT is returned if there is no ACL or if there is an ACL\n\t\t * but no cached acl data, just the acl length */\n\t\treturn ret;\n\treturn nfs4_get_acl_uncached(inode, buf, buflen);\n}\n\nstatic int __nfs4_proc_set_acl(struct inode *inode, const void *buf, size_t buflen)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct page *pages[NFS4ACL_MAXPAGES];\n\tstruct nfs_setaclargs arg = {\n\t\t.fh\t\t= NFS_FH(inode),\n\t\t.acl_pages\t= pages,\n\t\t.acl_len\t= buflen,\n\t};\n\tstruct nfs_setaclres res;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_SETACL],\n\t\t.rpc_argp\t= &arg,\n\t\t.rpc_resp\t= &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret, i;\n\n\tif (!nfs4_server_supports_acls(server))\n\t\treturn -EOPNOTSUPP;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\ti = buf_to_pages_noslab(buf, buflen, arg.acl_pages, &arg.acl_pgbase);\n\tif (i < 0)\n\t\treturn i;\n\tnfs4_inode_return_delegation(inode);\n\tret = nfs4_call_sync(server->client, server, &msg, &arg.seq_args, &res.seq_res, 1);\n\n\t/*\n\t * Free each page after tx, so the only ref left is\n\t * held by the network stack\n\t */\n\tfor (; i > 0; i--)\n\t\tput_page(pages[i-1]);\n\n\t/*\n\t * Acl update can result in inode attribute update.\n\t * so mark the attribute cache invalid.\n\t */\n\tspin_lock(&inode->i_lock);\n\tNFS_I(inode)->cache_validity |= NFS_INO_INVALID_ATTR;\n\tspin_unlock(&inode->i_lock);\n\tnfs_access_zap_cache(inode);\n\tnfs_zap_acl_cache(inode);\n\treturn ret;\n}\n\nstatic int nfs4_proc_set_acl(struct inode *inode, const void *buf, size_t buflen)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(inode),\n\t\t\t\t__nfs4_proc_set_acl(inode, buf, buflen),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int\nnfs4_async_handle_error(struct rpc_task *task, const struct nfs_server *server, struct nfs4_state *state)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\n\tif (task->tk_status >= 0)\n\t\treturn 0;\n\tswitch(task->tk_status) {\n\t\tcase -NFS4ERR_DELEG_REVOKED:\n\t\tcase -NFS4ERR_ADMIN_REVOKED:\n\t\tcase -NFS4ERR_BAD_STATEID:\n\t\t\tif (state == NULL)\n\t\t\t\tbreak;\n\t\t\tnfs_remove_bad_delegation(state->inode);\n\t\tcase -NFS4ERR_OPENMODE:\n\t\t\tif (state == NULL)\n\t\t\t\tbreak;\n\t\t\tnfs4_schedule_stateid_recovery(server, state);\n\t\t\tgoto wait_on_recovery;\n\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tif (state != NULL)\n\t\t\t\tnfs4_schedule_stateid_recovery(server, state);\n\t\tcase -NFS4ERR_STALE_STATEID:\n\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\t\tnfs4_schedule_lease_recovery(clp);\n\t\t\tgoto wait_on_recovery;\n#if defined(CONFIG_NFS_V4_1)\n\t\tcase -NFS4ERR_BADSESSION:\n\t\tcase -NFS4ERR_BADSLOT:\n\t\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\t\tcase -NFS4ERR_DEADSESSION:\n\t\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\tcase -NFS4ERR_SEQ_FALSE_RETRY:\n\t\tcase -NFS4ERR_SEQ_MISORDERED:\n\t\t\tdprintk(\"%s ERROR %d, Reset session\\n\", __func__,\n\t\t\t\ttask->tk_status);\n\t\t\tnfs4_schedule_session_recovery(clp->cl_session, task->tk_status);\n\t\t\ttask->tk_status = 0;\n\t\t\treturn -EAGAIN;\n#endif /* CONFIG_NFS_V4_1 */\n\t\tcase -NFS4ERR_DELAY:\n\t\t\tnfs_inc_server_stats(server, NFSIOS_DELAY);\n\t\tcase -NFS4ERR_GRACE:\n\t\tcase -EKEYEXPIRED:\n\t\t\trpc_delay(task, NFS4_POLL_RETRY_MAX);\n\t\t\ttask->tk_status = 0;\n\t\t\treturn -EAGAIN;\n\t\tcase -NFS4ERR_RETRY_UNCACHED_REP:\n\t\tcase -NFS4ERR_OLD_STATEID:\n\t\t\ttask->tk_status = 0;\n\t\t\treturn -EAGAIN;\n\t}\n\ttask->tk_status = nfs4_map_errors(task->tk_status);\n\treturn 0;\nwait_on_recovery:\n\trpc_sleep_on(&clp->cl_rpcwaitq, task, NULL);\n\tif (test_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state) == 0)\n\t\trpc_wake_up_queued_task(&clp->cl_rpcwaitq, task);\n\ttask->tk_status = 0;\n\treturn -EAGAIN;\n}\n\nstatic void nfs4_init_boot_verifier(const struct nfs_client *clp,\n\t\t\t\t    nfs4_verifier *bootverf)\n{\n\t__be32 verf[2];\n\n\tif (test_bit(NFS4CLNT_PURGE_STATE, &clp->cl_state)) {\n\t\t/* An impossible timestamp guarantees this value\n\t\t * will never match a generated boot time. */\n\t\tverf[0] = 0;\n\t\tverf[1] = (__be32)(NSEC_PER_SEC + 1);\n\t} else {\n\t\tstruct nfs_net *nn = net_generic(clp->cl_net, nfs_net_id);\n\t\tverf[0] = (__be32)nn->boot_time.tv_sec;\n\t\tverf[1] = (__be32)nn->boot_time.tv_nsec;\n\t}\n\tmemcpy(bootverf->data, verf, sizeof(bootverf->data));\n}\n\nstatic unsigned int\nnfs4_init_nonuniform_client_string(const struct nfs_client *clp,\n\t\t\t\t   char *buf, size_t len)\n{\n\tunsigned int result;\n\n\trcu_read_lock();\n\tresult = scnprintf(buf, len, \"Linux NFSv4.0 %s/%s %s\",\n\t\t\t\tclp->cl_ipaddr,\n\t\t\t\trpc_peeraddr2str(clp->cl_rpcclient,\n\t\t\t\t\t\t\tRPC_DISPLAY_ADDR),\n\t\t\t\trpc_peeraddr2str(clp->cl_rpcclient,\n\t\t\t\t\t\t\tRPC_DISPLAY_PROTO));\n\trcu_read_unlock();\n\treturn result;\n}\n\nstatic unsigned int\nnfs4_init_uniform_client_string(const struct nfs_client *clp,\n\t\t\t\tchar *buf, size_t len)\n{\n\tchar *nodename = clp->cl_rpcclient->cl_nodename;\n\n\tif (nfs4_client_id_uniquifier[0] != '\\0')\n\t\tnodename = nfs4_client_id_uniquifier;\n\treturn scnprintf(buf, len, \"Linux NFSv%u.%u %s\",\n\t\t\t\tclp->rpc_ops->version, clp->cl_minorversion,\n\t\t\t\tnodename);\n}\n\n/**\n * nfs4_proc_setclientid - Negotiate client ID\n * @clp: state data structure\n * @program: RPC program for NFSv4 callback service\n * @port: IP port number for NFS4 callback service\n * @cred: RPC credential to use for this call\n * @res: where to place the result\n *\n * Returns zero, a negative errno, or a negative NFS4ERR status code.\n */\nint nfs4_proc_setclientid(struct nfs_client *clp, u32 program,\n\t\tunsigned short port, struct rpc_cred *cred,\n\t\tstruct nfs4_setclientid_res *res)\n{\n\tnfs4_verifier sc_verifier;\n\tstruct nfs4_setclientid setclientid = {\n\t\t.sc_verifier = &sc_verifier,\n\t\t.sc_prog = program,\n\t\t.sc_cb_ident = clp->cl_cb_ident,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SETCLIENTID],\n\t\t.rpc_argp = &setclientid,\n\t\t.rpc_resp = res,\n\t\t.rpc_cred = cred,\n\t};\n\tint status;\n\n\t/* nfs_client_id4 */\n\tnfs4_init_boot_verifier(clp, &sc_verifier);\n\tif (test_bit(NFS_CS_MIGRATION, &clp->cl_flags))\n\t\tsetclientid.sc_name_len =\n\t\t\t\tnfs4_init_uniform_client_string(clp,\n\t\t\t\t\t\tsetclientid.sc_name,\n\t\t\t\t\t\tsizeof(setclientid.sc_name));\n\telse\n\t\tsetclientid.sc_name_len =\n\t\t\t\tnfs4_init_nonuniform_client_string(clp,\n\t\t\t\t\t\tsetclientid.sc_name,\n\t\t\t\t\t\tsizeof(setclientid.sc_name));\n\t/* cb_client4 */\n\trcu_read_lock();\n\tsetclientid.sc_netid_len = scnprintf(setclientid.sc_netid,\n\t\t\t\tsizeof(setclientid.sc_netid),\n\t\t\t\trpc_peeraddr2str(clp->cl_rpcclient,\n\t\t\t\t\t\t\tRPC_DISPLAY_NETID));\n\trcu_read_unlock();\n\tsetclientid.sc_uaddr_len = scnprintf(setclientid.sc_uaddr,\n\t\t\t\tsizeof(setclientid.sc_uaddr), \"%s.%u.%u\",\n\t\t\t\tclp->cl_ipaddr, port >> 8, port & 255);\n\n\tdprintk(\"NFS call  setclientid auth=%s, '%.*s'\\n\",\n\t\tclp->cl_rpcclient->cl_auth->au_ops->au_name,\n\t\tsetclientid.sc_name_len, setclientid.sc_name);\n\tstatus = rpc_call_sync(clp->cl_rpcclient, &msg, RPC_TASK_TIMEOUT);\n\tdprintk(\"NFS reply setclientid: %d\\n\", status);\n\treturn status;\n}\n\n/**\n * nfs4_proc_setclientid_confirm - Confirm client ID\n * @clp: state data structure\n * @res: result of a previous SETCLIENTID\n * @cred: RPC credential to use for this call\n *\n * Returns zero, a negative errno, or a negative NFS4ERR status code.\n */\nint nfs4_proc_setclientid_confirm(struct nfs_client *clp,\n\t\tstruct nfs4_setclientid_res *arg,\n\t\tstruct rpc_cred *cred)\n{\n\tstruct nfs_fsinfo fsinfo;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SETCLIENTID_CONFIRM],\n\t\t.rpc_argp = arg,\n\t\t.rpc_resp = &fsinfo,\n\t\t.rpc_cred = cred,\n\t};\n\tunsigned long now;\n\tint status;\n\n\tdprintk(\"NFS call  setclientid_confirm auth=%s, (client ID %llx)\\n\",\n\t\tclp->cl_rpcclient->cl_auth->au_ops->au_name,\n\t\tclp->cl_clientid);\n\tnow = jiffies;\n\tstatus = rpc_call_sync(clp->cl_rpcclient, &msg, RPC_TASK_TIMEOUT);\n\tif (status == 0) {\n\t\tspin_lock(&clp->cl_lock);\n\t\tclp->cl_lease_time = fsinfo.lease_time * HZ;\n\t\tclp->cl_last_renewal = now;\n\t\tspin_unlock(&clp->cl_lock);\n\t}\n\tdprintk(\"NFS reply setclientid_confirm: %d\\n\", status);\n\treturn status;\n}\n\nstruct nfs4_delegreturndata {\n\tstruct nfs4_delegreturnargs args;\n\tstruct nfs4_delegreturnres res;\n\tstruct nfs_fh fh;\n\tnfs4_stateid stateid;\n\tunsigned long timestamp;\n\tstruct nfs_fattr fattr;\n\tint rpc_status;\n};\n\nstatic void nfs4_delegreturn_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_delegreturndata *data = calldata;\n\n\tif (!nfs4_sequence_done(task, &data->res.seq_res))\n\t\treturn;\n\n\tswitch (task->tk_status) {\n\tcase -NFS4ERR_STALE_STATEID:\n\tcase -NFS4ERR_EXPIRED:\n\tcase 0:\n\t\trenew_lease(data->res.server, data->timestamp);\n\t\tbreak;\n\tdefault:\n\t\tif (nfs4_async_handle_error(task, data->res.server, NULL) ==\n\t\t\t\t-EAGAIN) {\n\t\t\trpc_restart_call_prepare(task);\n\t\t\treturn;\n\t\t}\n\t}\n\tdata->rpc_status = task->tk_status;\n}\n\nstatic void nfs4_delegreturn_release(void *calldata)\n{\n\tkfree(calldata);\n}\n\n#if defined(CONFIG_NFS_V4_1)\nstatic void nfs4_delegreturn_prepare(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_delegreturndata *d_data;\n\n\td_data = (struct nfs4_delegreturndata *)data;\n\n\tif (nfs4_setup_sequence(d_data->res.server,\n\t\t\t\t&d_data->args.seq_args,\n\t\t\t\t&d_data->res.seq_res, task))\n\t\treturn;\n\trpc_call_start(task);\n}\n#endif /* CONFIG_NFS_V4_1 */\n\nstatic const struct rpc_call_ops nfs4_delegreturn_ops = {\n#if defined(CONFIG_NFS_V4_1)\n\t.rpc_call_prepare = nfs4_delegreturn_prepare,\n#endif /* CONFIG_NFS_V4_1 */\n\t.rpc_call_done = nfs4_delegreturn_done,\n\t.rpc_release = nfs4_delegreturn_release,\n};\n\nstatic int _nfs4_proc_delegreturn(struct inode *inode, struct rpc_cred *cred, const nfs4_stateid *stateid, int issync)\n{\n\tstruct nfs4_delegreturndata *data;\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_DELEGRETURN],\n\t\t.rpc_cred = cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = server->client,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_delegreturn_ops,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\tint status = 0;\n\n\tdata = kzalloc(sizeof(*data), GFP_NOFS);\n\tif (data == NULL)\n\t\treturn -ENOMEM;\n\tnfs41_init_sequence(&data->args.seq_args, &data->res.seq_res, 1);\n\tdata->args.fhandle = &data->fh;\n\tdata->args.stateid = &data->stateid;\n\tdata->args.bitmask = server->cache_consistency_bitmask;\n\tnfs_copy_fh(&data->fh, NFS_FH(inode));\n\tnfs4_stateid_copy(&data->stateid, stateid);\n\tdata->res.fattr = &data->fattr;\n\tdata->res.server = server;\n\tnfs_fattr_init(data->res.fattr);\n\tdata->timestamp = jiffies;\n\tdata->rpc_status = 0;\n\n\ttask_setup_data.callback_data = data;\n\tmsg.rpc_argp = &data->args;\n\tmsg.rpc_resp = &data->res;\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tif (!issync)\n\t\tgoto out;\n\tstatus = nfs4_wait_for_completion_rpc_task(task);\n\tif (status != 0)\n\t\tgoto out;\n\tstatus = data->rpc_status;\n\tif (status == 0)\n\t\tnfs_post_op_update_inode_force_wcc(inode, &data->fattr);\n\telse\n\t\tnfs_refresh_inode(inode, &data->fattr);\nout:\n\trpc_put_task(task);\n\treturn status;\n}\n\nint nfs4_proc_delegreturn(struct inode *inode, struct rpc_cred *cred, const nfs4_stateid *stateid, int issync)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = _nfs4_proc_delegreturn(inode, cred, stateid, issync);\n\t\tswitch (err) {\n\t\t\tcase -NFS4ERR_STALE_STATEID:\n\t\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tcase 0:\n\t\t\t\treturn 0;\n\t\t}\n\t\terr = nfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\n#define NFS4_LOCK_MINTIMEOUT (1 * HZ)\n#define NFS4_LOCK_MAXTIMEOUT (30 * HZ)\n\n/* \n * sleep, with exponential backoff, and retry the LOCK operation. \n */\nstatic unsigned long\nnfs4_set_lock_task_retry(unsigned long timeout)\n{\n\tfreezable_schedule_timeout_killable(timeout);\n\ttimeout <<= 1;\n\tif (timeout > NFS4_LOCK_MAXTIMEOUT)\n\t\treturn NFS4_LOCK_MAXTIMEOUT;\n\treturn timeout;\n}\n\nstatic int _nfs4_proc_getlk(struct nfs4_state *state, int cmd, struct file_lock *request)\n{\n\tstruct inode *inode = state->inode;\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs_lockt_args arg = {\n\t\t.fh = NFS_FH(inode),\n\t\t.fl = request,\n\t};\n\tstruct nfs_lockt_res res = {\n\t\t.denied = request,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_LOCKT],\n\t\t.rpc_argp       = &arg,\n\t\t.rpc_resp       = &res,\n\t\t.rpc_cred\t= state->owner->so_cred,\n\t};\n\tstruct nfs4_lock_state *lsp;\n\tint status;\n\n\targ.lock_owner.clientid = clp->cl_clientid;\n\tstatus = nfs4_set_lock_state(state, request);\n\tif (status != 0)\n\t\tgoto out;\n\tlsp = request->fl_u.nfs4_fl.owner;\n\targ.lock_owner.id = lsp->ls_seqid.owner_id;\n\targ.lock_owner.s_dev = server->s_dev;\n\tstatus = nfs4_call_sync(server->client, server, &msg, &arg.seq_args, &res.seq_res, 1);\n\tswitch (status) {\n\t\tcase 0:\n\t\t\trequest->fl_type = F_UNLCK;\n\t\t\tbreak;\n\t\tcase -NFS4ERR_DENIED:\n\t\t\tstatus = 0;\n\t}\n\trequest->fl_ops->fl_release_private(request);\nout:\n\treturn status;\n}\n\nstatic int nfs4_proc_getlk(struct nfs4_state *state, int cmd, struct file_lock *request)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(state->inode),\n\t\t\t\t_nfs4_proc_getlk(state, cmd, request),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int do_vfs_lock(struct file *file, struct file_lock *fl)\n{\n\tint res = 0;\n\tswitch (fl->fl_flags & (FL_POSIX|FL_FLOCK)) {\n\t\tcase FL_POSIX:\n\t\t\tres = posix_lock_file_wait(file, fl);\n\t\t\tbreak;\n\t\tcase FL_FLOCK:\n\t\t\tres = flock_lock_file_wait(file, fl);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t}\n\treturn res;\n}\n\nstruct nfs4_unlockdata {\n\tstruct nfs_locku_args arg;\n\tstruct nfs_locku_res res;\n\tstruct nfs4_lock_state *lsp;\n\tstruct nfs_open_context *ctx;\n\tstruct file_lock fl;\n\tconst struct nfs_server *server;\n\tunsigned long timestamp;\n};\n\nstatic struct nfs4_unlockdata *nfs4_alloc_unlockdata(struct file_lock *fl,\n\t\tstruct nfs_open_context *ctx,\n\t\tstruct nfs4_lock_state *lsp,\n\t\tstruct nfs_seqid *seqid)\n{\n\tstruct nfs4_unlockdata *p;\n\tstruct inode *inode = lsp->ls_state->inode;\n\n\tp = kzalloc(sizeof(*p), GFP_NOFS);\n\tif (p == NULL)\n\t\treturn NULL;\n\tp->arg.fh = NFS_FH(inode);\n\tp->arg.fl = &p->fl;\n\tp->arg.seqid = seqid;\n\tp->res.seqid = seqid;\n\tp->arg.stateid = &lsp->ls_stateid;\n\tp->lsp = lsp;\n\tatomic_inc(&lsp->ls_count);\n\t/* Ensure we don't close file until we're done freeing locks! */\n\tp->ctx = get_nfs_open_context(ctx);\n\tmemcpy(&p->fl, fl, sizeof(p->fl));\n\tp->server = NFS_SERVER(inode);\n\treturn p;\n}\n\nstatic void nfs4_locku_release_calldata(void *data)\n{\n\tstruct nfs4_unlockdata *calldata = data;\n\tnfs_free_seqid(calldata->arg.seqid);\n\tnfs4_put_lock_state(calldata->lsp);\n\tput_nfs_open_context(calldata->ctx);\n\tkfree(calldata);\n}\n\nstatic void nfs4_locku_done(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_unlockdata *calldata = data;\n\n\tif (!nfs4_sequence_done(task, &calldata->res.seq_res))\n\t\treturn;\n\tswitch (task->tk_status) {\n\t\tcase 0:\n\t\t\tnfs4_stateid_copy(&calldata->lsp->ls_stateid,\n\t\t\t\t\t&calldata->res.stateid);\n\t\t\trenew_lease(calldata->server, calldata->timestamp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_BAD_STATEID:\n\t\tcase -NFS4ERR_OLD_STATEID:\n\t\tcase -NFS4ERR_STALE_STATEID:\n\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (nfs4_async_handle_error(task, calldata->server, NULL) == -EAGAIN)\n\t\t\t\trpc_restart_call_prepare(task);\n\t}\n\tnfs_release_seqid(calldata->arg.seqid);\n}\n\nstatic void nfs4_locku_prepare(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_unlockdata *calldata = data;\n\n\tif (nfs_wait_on_sequence(calldata->arg.seqid, task) != 0)\n\t\treturn;\n\tif (test_bit(NFS_LOCK_INITIALIZED, &calldata->lsp->ls_flags) == 0) {\n\t\t/* Note: exit _without_ running nfs4_locku_done */\n\t\ttask->tk_action = NULL;\n\t\treturn;\n\t}\n\tcalldata->timestamp = jiffies;\n\tif (nfs4_setup_sequence(calldata->server,\n\t\t\t\t&calldata->arg.seq_args,\n\t\t\t\t&calldata->res.seq_res,\n\t\t\t\ttask) != 0)\n\t\tnfs_release_seqid(calldata->arg.seqid);\n\telse\n\t\trpc_call_start(task);\n}\n\nstatic const struct rpc_call_ops nfs4_locku_ops = {\n\t.rpc_call_prepare = nfs4_locku_prepare,\n\t.rpc_call_done = nfs4_locku_done,\n\t.rpc_release = nfs4_locku_release_calldata,\n};\n\nstatic struct rpc_task *nfs4_do_unlck(struct file_lock *fl,\n\t\tstruct nfs_open_context *ctx,\n\t\tstruct nfs4_lock_state *lsp,\n\t\tstruct nfs_seqid *seqid)\n{\n\tstruct nfs4_unlockdata *data;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LOCKU],\n\t\t.rpc_cred = ctx->cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = NFS_CLIENT(lsp->ls_state->inode),\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_locku_ops,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\n\t/* Ensure this is an unlock - when canceling a lock, the\n\t * canceled lock is passed in, and it won't be an unlock.\n\t */\n\tfl->fl_type = F_UNLCK;\n\n\tdata = nfs4_alloc_unlockdata(fl, ctx, lsp, seqid);\n\tif (data == NULL) {\n\t\tnfs_free_seqid(seqid);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tnfs41_init_sequence(&data->arg.seq_args, &data->res.seq_res, 1);\n\tmsg.rpc_argp = &data->arg;\n\tmsg.rpc_resp = &data->res;\n\ttask_setup_data.callback_data = data;\n\treturn rpc_run_task(&task_setup_data);\n}\n\nstatic int nfs4_proc_unlck(struct nfs4_state *state, int cmd, struct file_lock *request)\n{\n\tstruct nfs_inode *nfsi = NFS_I(state->inode);\n\tstruct nfs_seqid *seqid;\n\tstruct nfs4_lock_state *lsp;\n\tstruct rpc_task *task;\n\tint status = 0;\n\tunsigned char fl_flags = request->fl_flags;\n\n\tstatus = nfs4_set_lock_state(state, request);\n\t/* Unlock _before_ we do the RPC call */\n\trequest->fl_flags |= FL_EXISTS;\n\tdown_read(&nfsi->rwsem);\n\tif (do_vfs_lock(request->fl_file, request) == -ENOENT) {\n\t\tup_read(&nfsi->rwsem);\n\t\tgoto out;\n\t}\n\tup_read(&nfsi->rwsem);\n\tif (status != 0)\n\t\tgoto out;\n\t/* Is this a delegated lock? */\n\tif (test_bit(NFS_DELEGATED_STATE, &state->flags))\n\t\tgoto out;\n\tlsp = request->fl_u.nfs4_fl.owner;\n\tseqid = nfs_alloc_seqid(&lsp->ls_seqid, GFP_KERNEL);\n\tstatus = -ENOMEM;\n\tif (seqid == NULL)\n\t\tgoto out;\n\ttask = nfs4_do_unlck(request, nfs_file_open_context(request->fl_file), lsp, seqid);\n\tstatus = PTR_ERR(task);\n\tif (IS_ERR(task))\n\t\tgoto out;\n\tstatus = nfs4_wait_for_completion_rpc_task(task);\n\trpc_put_task(task);\nout:\n\trequest->fl_flags = fl_flags;\n\treturn status;\n}\n\nstruct nfs4_lockdata {\n\tstruct nfs_lock_args arg;\n\tstruct nfs_lock_res res;\n\tstruct nfs4_lock_state *lsp;\n\tstruct nfs_open_context *ctx;\n\tstruct file_lock fl;\n\tunsigned long timestamp;\n\tint rpc_status;\n\tint cancelled;\n\tstruct nfs_server *server;\n};\n\nstatic struct nfs4_lockdata *nfs4_alloc_lockdata(struct file_lock *fl,\n\t\tstruct nfs_open_context *ctx, struct nfs4_lock_state *lsp,\n\t\tgfp_t gfp_mask)\n{\n\tstruct nfs4_lockdata *p;\n\tstruct inode *inode = lsp->ls_state->inode;\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\n\tp = kzalloc(sizeof(*p), gfp_mask);\n\tif (p == NULL)\n\t\treturn NULL;\n\n\tp->arg.fh = NFS_FH(inode);\n\tp->arg.fl = &p->fl;\n\tp->arg.open_seqid = nfs_alloc_seqid(&lsp->ls_state->owner->so_seqid, gfp_mask);\n\tif (p->arg.open_seqid == NULL)\n\t\tgoto out_free;\n\tp->arg.lock_seqid = nfs_alloc_seqid(&lsp->ls_seqid, gfp_mask);\n\tif (p->arg.lock_seqid == NULL)\n\t\tgoto out_free_seqid;\n\tp->arg.lock_stateid = &lsp->ls_stateid;\n\tp->arg.lock_owner.clientid = server->nfs_client->cl_clientid;\n\tp->arg.lock_owner.id = lsp->ls_seqid.owner_id;\n\tp->arg.lock_owner.s_dev = server->s_dev;\n\tp->res.lock_seqid = p->arg.lock_seqid;\n\tp->lsp = lsp;\n\tp->server = server;\n\tatomic_inc(&lsp->ls_count);\n\tp->ctx = get_nfs_open_context(ctx);\n\tmemcpy(&p->fl, fl, sizeof(p->fl));\n\treturn p;\nout_free_seqid:\n\tnfs_free_seqid(p->arg.open_seqid);\nout_free:\n\tkfree(p);\n\treturn NULL;\n}\n\nstatic void nfs4_lock_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_lockdata *data = calldata;\n\tstruct nfs4_state *state = data->lsp->ls_state;\n\n\tdprintk(\"%s: begin!\\n\", __func__);\n\tif (nfs_wait_on_sequence(data->arg.lock_seqid, task) != 0)\n\t\treturn;\n\t/* Do we need to do an open_to_lock_owner? */\n\tif (!(data->arg.lock_seqid->sequence->flags & NFS_SEQID_CONFIRMED)) {\n\t\tif (nfs_wait_on_sequence(data->arg.open_seqid, task) != 0)\n\t\t\tgoto out_release_lock_seqid;\n\t\tdata->arg.open_stateid = &state->stateid;\n\t\tdata->arg.new_lock_owner = 1;\n\t\tdata->res.open_seqid = data->arg.open_seqid;\n\t} else\n\t\tdata->arg.new_lock_owner = 0;\n\tdata->timestamp = jiffies;\n\tif (nfs4_setup_sequence(data->server,\n\t\t\t\t&data->arg.seq_args,\n\t\t\t\t&data->res.seq_res,\n\t\t\t\ttask) == 0) {\n\t\trpc_call_start(task);\n\t\treturn;\n\t}\n\tnfs_release_seqid(data->arg.open_seqid);\nout_release_lock_seqid:\n\tnfs_release_seqid(data->arg.lock_seqid);\n\tdprintk(\"%s: done!, ret = %d\\n\", __func__, task->tk_status);\n}\n\nstatic void nfs4_recover_lock_prepare(struct rpc_task *task, void *calldata)\n{\n\trpc_task_set_priority(task, RPC_PRIORITY_PRIVILEGED);\n\tnfs4_lock_prepare(task, calldata);\n}\n\nstatic void nfs4_lock_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_lockdata *data = calldata;\n\n\tdprintk(\"%s: begin!\\n\", __func__);\n\n\tif (!nfs4_sequence_done(task, &data->res.seq_res))\n\t\treturn;\n\n\tdata->rpc_status = task->tk_status;\n\tif (data->arg.new_lock_owner != 0) {\n\t\tif (data->rpc_status == 0)\n\t\t\tnfs_confirm_seqid(&data->lsp->ls_seqid, 0);\n\t\telse\n\t\t\tgoto out;\n\t}\n\tif (data->rpc_status == 0) {\n\t\tnfs4_stateid_copy(&data->lsp->ls_stateid, &data->res.stateid);\n\t\tset_bit(NFS_LOCK_INITIALIZED, &data->lsp->ls_flags);\n\t\trenew_lease(NFS_SERVER(data->ctx->dentry->d_inode), data->timestamp);\n\t}\nout:\n\tdprintk(\"%s: done, ret = %d!\\n\", __func__, data->rpc_status);\n}\n\nstatic void nfs4_lock_release(void *calldata)\n{\n\tstruct nfs4_lockdata *data = calldata;\n\n\tdprintk(\"%s: begin!\\n\", __func__);\n\tnfs_free_seqid(data->arg.open_seqid);\n\tif (data->cancelled != 0) {\n\t\tstruct rpc_task *task;\n\t\ttask = nfs4_do_unlck(&data->fl, data->ctx, data->lsp,\n\t\t\t\tdata->arg.lock_seqid);\n\t\tif (!IS_ERR(task))\n\t\t\trpc_put_task_async(task);\n\t\tdprintk(\"%s: cancelling lock!\\n\", __func__);\n\t} else\n\t\tnfs_free_seqid(data->arg.lock_seqid);\n\tnfs4_put_lock_state(data->lsp);\n\tput_nfs_open_context(data->ctx);\n\tkfree(data);\n\tdprintk(\"%s: done!\\n\", __func__);\n}\n\nstatic const struct rpc_call_ops nfs4_lock_ops = {\n\t.rpc_call_prepare = nfs4_lock_prepare,\n\t.rpc_call_done = nfs4_lock_done,\n\t.rpc_release = nfs4_lock_release,\n};\n\nstatic const struct rpc_call_ops nfs4_recover_lock_ops = {\n\t.rpc_call_prepare = nfs4_recover_lock_prepare,\n\t.rpc_call_done = nfs4_lock_done,\n\t.rpc_release = nfs4_lock_release,\n};\n\nstatic void nfs4_handle_setlk_error(struct nfs_server *server, struct nfs4_lock_state *lsp, int new_lock_owner, int error)\n{\n\tswitch (error) {\n\tcase -NFS4ERR_ADMIN_REVOKED:\n\tcase -NFS4ERR_BAD_STATEID:\n\t\tlsp->ls_seqid.flags &= ~NFS_SEQID_CONFIRMED;\n\t\tif (new_lock_owner != 0 ||\n\t\t   test_bit(NFS_LOCK_INITIALIZED, &lsp->ls_flags) != 0)\n\t\t\tnfs4_schedule_stateid_recovery(server, lsp->ls_state);\n\t\tbreak;\n\tcase -NFS4ERR_STALE_STATEID:\n\t\tlsp->ls_seqid.flags &= ~NFS_SEQID_CONFIRMED;\n\tcase -NFS4ERR_EXPIRED:\n\t\tnfs4_schedule_lease_recovery(server->nfs_client);\n\t};\n}\n\nstatic int _nfs4_do_setlk(struct nfs4_state *state, int cmd, struct file_lock *fl, int recovery_type)\n{\n\tstruct nfs4_lockdata *data;\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LOCK],\n\t\t.rpc_cred = state->owner->so_cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = NFS_CLIENT(state->inode),\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_lock_ops,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\tint ret;\n\n\tdprintk(\"%s: begin!\\n\", __func__);\n\tdata = nfs4_alloc_lockdata(fl, nfs_file_open_context(fl->fl_file),\n\t\t\tfl->fl_u.nfs4_fl.owner,\n\t\t\trecovery_type == NFS_LOCK_NEW ? GFP_KERNEL : GFP_NOFS);\n\tif (data == NULL)\n\t\treturn -ENOMEM;\n\tif (IS_SETLKW(cmd))\n\t\tdata->arg.block = 1;\n\tif (recovery_type > NFS_LOCK_NEW) {\n\t\tif (recovery_type == NFS_LOCK_RECLAIM)\n\t\t\tdata->arg.reclaim = NFS_LOCK_RECLAIM;\n\t\ttask_setup_data.callback_ops = &nfs4_recover_lock_ops;\n\t}\n\tnfs41_init_sequence(&data->arg.seq_args, &data->res.seq_res, 1);\n\tmsg.rpc_argp = &data->arg;\n\tmsg.rpc_resp = &data->res;\n\ttask_setup_data.callback_data = data;\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tret = nfs4_wait_for_completion_rpc_task(task);\n\tif (ret == 0) {\n\t\tret = data->rpc_status;\n\t\tif (ret)\n\t\t\tnfs4_handle_setlk_error(data->server, data->lsp,\n\t\t\t\t\tdata->arg.new_lock_owner, ret);\n\t} else\n\t\tdata->cancelled = 1;\n\trpc_put_task(task);\n\tdprintk(\"%s: done, ret = %d!\\n\", __func__, ret);\n\treturn ret;\n}\n\nstatic int nfs4_lock_reclaim(struct nfs4_state *state, struct file_lock *request)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs4_exception exception = {\n\t\t.inode = state->inode,\n\t};\n\tint err;\n\n\tdo {\n\t\t/* Cache the lock if possible... */\n\t\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) != 0)\n\t\t\treturn 0;\n\t\terr = _nfs4_do_setlk(state, F_SETLK, request, NFS_LOCK_RECLAIM);\n\t\tif (err != -NFS4ERR_DELAY)\n\t\t\tbreak;\n\t\tnfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int nfs4_lock_expired(struct nfs4_state *state, struct file_lock *request)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs4_exception exception = {\n\t\t.inode = state->inode,\n\t};\n\tint err;\n\n\terr = nfs4_set_lock_state(state, request);\n\tif (err != 0)\n\t\treturn err;\n\tdo {\n\t\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) != 0)\n\t\t\treturn 0;\n\t\terr = _nfs4_do_setlk(state, F_SETLK, request, NFS_LOCK_EXPIRED);\n\t\tswitch (err) {\n\t\tdefault:\n\t\t\tgoto out;\n\t\tcase -NFS4ERR_GRACE:\n\t\tcase -NFS4ERR_DELAY:\n\t\t\tnfs4_handle_exception(server, err, &exception);\n\t\t\terr = 0;\n\t\t}\n\t} while (exception.retry);\nout:\n\treturn err;\n}\n\n#if defined(CONFIG_NFS_V4_1)\n/**\n * nfs41_check_expired_locks - possibly free a lock stateid\n *\n * @state: NFSv4 state for an inode\n *\n * Returns NFS_OK if recovery for this stateid is now finished.\n * Otherwise a negative NFS4ERR value is returned.\n */\nstatic int nfs41_check_expired_locks(struct nfs4_state *state)\n{\n\tint status, ret = -NFS4ERR_BAD_STATEID;\n\tstruct nfs4_lock_state *lsp;\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\n\tlist_for_each_entry(lsp, &state->lock_states, ls_locks) {\n\t\tif (test_bit(NFS_LOCK_INITIALIZED, &lsp->ls_flags)) {\n\t\t\tstatus = nfs41_test_stateid(server, &lsp->ls_stateid);\n\t\t\tif (status != NFS_OK) {\n\t\t\t\t/* Free the stateid unless the server\n\t\t\t\t * informs us the stateid is unrecognized. */\n\t\t\t\tif (status != -NFS4ERR_BAD_STATEID)\n\t\t\t\t\tnfs41_free_stateid(server,\n\t\t\t\t\t\t\t&lsp->ls_stateid);\n\t\t\t\tclear_bit(NFS_LOCK_INITIALIZED, &lsp->ls_flags);\n\t\t\t\tret = status;\n\t\t\t}\n\t\t}\n\t};\n\n\treturn ret;\n}\n\nstatic int nfs41_lock_expired(struct nfs4_state *state, struct file_lock *request)\n{\n\tint status = NFS_OK;\n\n\tif (test_bit(LK_STATE_IN_USE, &state->flags))\n\t\tstatus = nfs41_check_expired_locks(state);\n\tif (status != NFS_OK)\n\t\tstatus = nfs4_lock_expired(state, request);\n\treturn status;\n}\n#endif\n\nstatic int _nfs4_proc_setlk(struct nfs4_state *state, int cmd, struct file_lock *request)\n{\n\tstruct nfs_inode *nfsi = NFS_I(state->inode);\n\tunsigned char fl_flags = request->fl_flags;\n\tint status = -ENOLCK;\n\n\tif ((fl_flags & FL_POSIX) &&\n\t\t\t!test_bit(NFS_STATE_POSIX_LOCKS, &state->flags))\n\t\tgoto out;\n\t/* Is this a delegated open? */\n\tstatus = nfs4_set_lock_state(state, request);\n\tif (status != 0)\n\t\tgoto out;\n\trequest->fl_flags |= FL_ACCESS;\n\tstatus = do_vfs_lock(request->fl_file, request);\n\tif (status < 0)\n\t\tgoto out;\n\tdown_read(&nfsi->rwsem);\n\tif (test_bit(NFS_DELEGATED_STATE, &state->flags)) {\n\t\t/* Yes: cache locks! */\n\t\t/* ...but avoid races with delegation recall... */\n\t\trequest->fl_flags = fl_flags & ~FL_SLEEP;\n\t\tstatus = do_vfs_lock(request->fl_file, request);\n\t\tgoto out_unlock;\n\t}\n\tstatus = _nfs4_do_setlk(state, cmd, request, NFS_LOCK_NEW);\n\tif (status != 0)\n\t\tgoto out_unlock;\n\t/* Note: we always want to sleep here! */\n\trequest->fl_flags = fl_flags | FL_SLEEP;\n\tif (do_vfs_lock(request->fl_file, request) < 0)\n\t\tprintk(KERN_WARNING \"NFS: %s: VFS is out of sync with lock \"\n\t\t\t\"manager!\\n\", __func__);\nout_unlock:\n\tup_read(&nfsi->rwsem);\nout:\n\trequest->fl_flags = fl_flags;\n\treturn status;\n}\n\nstatic int nfs4_proc_setlk(struct nfs4_state *state, int cmd, struct file_lock *request)\n{\n\tstruct nfs4_exception exception = {\n\t\t.state = state,\n\t\t.inode = state->inode,\n\t};\n\tint err;\n\n\tdo {\n\t\terr = _nfs4_proc_setlk(state, cmd, request);\n\t\tif (err == -NFS4ERR_DENIED)\n\t\t\terr = -EAGAIN;\n\t\terr = nfs4_handle_exception(NFS_SERVER(state->inode),\n\t\t\t\terr, &exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int\nnfs4_proc_lock(struct file *filp, int cmd, struct file_lock *request)\n{\n\tstruct nfs_open_context *ctx;\n\tstruct nfs4_state *state;\n\tunsigned long timeout = NFS4_LOCK_MINTIMEOUT;\n\tint status;\n\n\t/* verify open state */\n\tctx = nfs_file_open_context(filp);\n\tstate = ctx->state;\n\n\tif (request->fl_start < 0 || request->fl_end < 0)\n\t\treturn -EINVAL;\n\n\tif (IS_GETLK(cmd)) {\n\t\tif (state != NULL)\n\t\t\treturn nfs4_proc_getlk(state, F_GETLK, request);\n\t\treturn 0;\n\t}\n\n\tif (!(IS_SETLK(cmd) || IS_SETLKW(cmd)))\n\t\treturn -EINVAL;\n\n\tif (request->fl_type == F_UNLCK) {\n\t\tif (state != NULL)\n\t\t\treturn nfs4_proc_unlck(state, cmd, request);\n\t\treturn 0;\n\t}\n\n\tif (state == NULL)\n\t\treturn -ENOLCK;\n\t/*\n\t * Don't rely on the VFS having checked the file open mode,\n\t * since it won't do this for flock() locks.\n\t */\n\tswitch (request->fl_type) {\n\tcase F_RDLCK:\n\t\tif (!(filp->f_mode & FMODE_READ))\n\t\t\treturn -EBADF;\n\t\tbreak;\n\tcase F_WRLCK:\n\t\tif (!(filp->f_mode & FMODE_WRITE))\n\t\t\treturn -EBADF;\n\t}\n\n\tdo {\n\t\tstatus = nfs4_proc_setlk(state, cmd, request);\n\t\tif ((status != -EAGAIN) || IS_SETLK(cmd))\n\t\t\tbreak;\n\t\ttimeout = nfs4_set_lock_task_retry(timeout);\n\t\tstatus = -ERESTARTSYS;\n\t\tif (signalled())\n\t\t\tbreak;\n\t} while(status < 0);\n\treturn status;\n}\n\nint nfs4_lock_delegation_recall(struct nfs4_state *state, struct file_lock *fl)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\terr = nfs4_set_lock_state(state, fl);\n\tif (err != 0)\n\t\tgoto out;\n\tdo {\n\t\terr = _nfs4_do_setlk(state, F_SETLK, fl, NFS_LOCK_NEW);\n\t\tswitch (err) {\n\t\t\tdefault:\n\t\t\t\tprintk(KERN_ERR \"NFS: %s: unhandled error \"\n\t\t\t\t\t\"%d.\\n\", __func__, err);\n\t\t\tcase 0:\n\t\t\tcase -ESTALE:\n\t\t\t\tgoto out;\n\t\t\tcase -NFS4ERR_EXPIRED:\n\t\t\t\tnfs4_schedule_stateid_recovery(server, state);\n\t\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\t\tcase -NFS4ERR_STALE_STATEID:\n\t\t\t\tnfs4_schedule_lease_recovery(server->nfs_client);\n\t\t\t\tgoto out;\n\t\t\tcase -NFS4ERR_BADSESSION:\n\t\t\tcase -NFS4ERR_BADSLOT:\n\t\t\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\t\t\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\t\tcase -NFS4ERR_DEADSESSION:\n\t\t\t\tnfs4_schedule_session_recovery(server->nfs_client->cl_session, err);\n\t\t\t\tgoto out;\n\t\t\tcase -ERESTARTSYS:\n\t\t\t\t/*\n\t\t\t\t * The show must go on: exit, but mark the\n\t\t\t\t * stateid as needing recovery.\n\t\t\t\t */\n\t\t\tcase -NFS4ERR_DELEG_REVOKED:\n\t\t\tcase -NFS4ERR_ADMIN_REVOKED:\n\t\t\tcase -NFS4ERR_BAD_STATEID:\n\t\t\tcase -NFS4ERR_OPENMODE:\n\t\t\t\tnfs4_schedule_stateid_recovery(server, state);\n\t\t\t\terr = 0;\n\t\t\t\tgoto out;\n\t\t\tcase -EKEYEXPIRED:\n\t\t\t\t/*\n\t\t\t\t * User RPCSEC_GSS context has expired.\n\t\t\t\t * We cannot recover this stateid now, so\n\t\t\t\t * skip it and allow recovery thread to\n\t\t\t\t * proceed.\n\t\t\t\t */\n\t\t\t\terr = 0;\n\t\t\t\tgoto out;\n\t\t\tcase -ENOMEM:\n\t\t\tcase -NFS4ERR_DENIED:\n\t\t\t\t/* kill_proc(fl->fl_pid, SIGLOST, 1); */\n\t\t\t\terr = 0;\n\t\t\t\tgoto out;\n\t\t\tcase -NFS4ERR_DELAY:\n\t\t\t\tbreak;\n\t\t}\n\t\terr = nfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\nout:\n\treturn err;\n}\n\nstruct nfs_release_lockowner_data {\n\tstruct nfs4_lock_state *lsp;\n\tstruct nfs_server *server;\n\tstruct nfs_release_lockowner_args args;\n};\n\nstatic void nfs4_release_lockowner_release(void *calldata)\n{\n\tstruct nfs_release_lockowner_data *data = calldata;\n\tnfs4_free_lock_state(data->server, data->lsp);\n\tkfree(calldata);\n}\n\nstatic const struct rpc_call_ops nfs4_release_lockowner_ops = {\n\t.rpc_release = nfs4_release_lockowner_release,\n};\n\nint nfs4_release_lockowner(struct nfs4_lock_state *lsp)\n{\n\tstruct nfs_server *server = lsp->ls_state->owner->so_server;\n\tstruct nfs_release_lockowner_data *data;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_RELEASE_LOCKOWNER],\n\t};\n\n\tif (server->nfs_client->cl_mvops->minor_version != 0)\n\t\treturn -EINVAL;\n\tdata = kmalloc(sizeof(*data), GFP_NOFS);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tdata->lsp = lsp;\n\tdata->server = server;\n\tdata->args.lock_owner.clientid = server->nfs_client->cl_clientid;\n\tdata->args.lock_owner.id = lsp->ls_seqid.owner_id;\n\tdata->args.lock_owner.s_dev = server->s_dev;\n\tmsg.rpc_argp = &data->args;\n\trpc_call_async(server->client, &msg, 0, &nfs4_release_lockowner_ops, data);\n\treturn 0;\n}\n\n#define XATTR_NAME_NFSV4_ACL \"system.nfs4_acl\"\n\nstatic int nfs4_xattr_set_nfs4_acl(struct dentry *dentry, const char *key,\n\t\t\t\t   const void *buf, size_t buflen,\n\t\t\t\t   int flags, int type)\n{\n\tif (strcmp(key, \"\") != 0)\n\t\treturn -EINVAL;\n\n\treturn nfs4_proc_set_acl(dentry->d_inode, buf, buflen);\n}\n\nstatic int nfs4_xattr_get_nfs4_acl(struct dentry *dentry, const char *key,\n\t\t\t\t   void *buf, size_t buflen, int type)\n{\n\tif (strcmp(key, \"\") != 0)\n\t\treturn -EINVAL;\n\n\treturn nfs4_proc_get_acl(dentry->d_inode, buf, buflen);\n}\n\nstatic size_t nfs4_xattr_list_nfs4_acl(struct dentry *dentry, char *list,\n\t\t\t\t       size_t list_len, const char *name,\n\t\t\t\t       size_t name_len, int type)\n{\n\tsize_t len = sizeof(XATTR_NAME_NFSV4_ACL);\n\n\tif (!nfs4_server_supports_acls(NFS_SERVER(dentry->d_inode)))\n\t\treturn 0;\n\n\tif (list && len <= list_len)\n\t\tmemcpy(list, XATTR_NAME_NFSV4_ACL, len);\n\treturn len;\n}\n\n/*\n * nfs_fhget will use either the mounted_on_fileid or the fileid\n */\nstatic void nfs_fixup_referral_attributes(struct nfs_fattr *fattr)\n{\n\tif (!(((fattr->valid & NFS_ATTR_FATTR_MOUNTED_ON_FILEID) ||\n\t       (fattr->valid & NFS_ATTR_FATTR_FILEID)) &&\n\t      (fattr->valid & NFS_ATTR_FATTR_FSID) &&\n\t      (fattr->valid & NFS_ATTR_FATTR_V4_LOCATIONS)))\n\t\treturn;\n\n\tfattr->valid |= NFS_ATTR_FATTR_TYPE | NFS_ATTR_FATTR_MODE |\n\t\tNFS_ATTR_FATTR_NLINK | NFS_ATTR_FATTR_V4_REFERRAL;\n\tfattr->mode = S_IFDIR | S_IRUGO | S_IXUGO;\n\tfattr->nlink = 2;\n}\n\nstatic int _nfs4_proc_fs_locations(struct rpc_clnt *client, struct inode *dir,\n\t\t\t\t   const struct qstr *name,\n\t\t\t\t   struct nfs4_fs_locations *fs_locations,\n\t\t\t\t   struct page *page)\n{\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tu32 bitmask[2] = {\n\t\t[0] = FATTR4_WORD0_FSID | FATTR4_WORD0_FS_LOCATIONS,\n\t};\n\tstruct nfs4_fs_locations_arg args = {\n\t\t.dir_fh = NFS_FH(dir),\n\t\t.name = name,\n\t\t.page = page,\n\t\t.bitmask = bitmask,\n\t};\n\tstruct nfs4_fs_locations_res res = {\n\t\t.fs_locations = fs_locations,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_FS_LOCATIONS],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tint status;\n\n\tdprintk(\"%s: start\\n\", __func__);\n\n\t/* Ask for the fileid of the absent filesystem if mounted_on_fileid\n\t * is not supported */\n\tif (NFS_SERVER(dir)->attr_bitmask[1] & FATTR4_WORD1_MOUNTED_ON_FILEID)\n\t\tbitmask[1] |= FATTR4_WORD1_MOUNTED_ON_FILEID;\n\telse\n\t\tbitmask[0] |= FATTR4_WORD0_FILEID;\n\n\tnfs_fattr_init(&fs_locations->fattr);\n\tfs_locations->server = server;\n\tfs_locations->nlocations = 0;\n\tstatus = nfs4_call_sync(client, server, &msg, &args.seq_args, &res.seq_res, 0);\n\tdprintk(\"%s: returned status = %d\\n\", __func__, status);\n\treturn status;\n}\n\nint nfs4_proc_fs_locations(struct rpc_clnt *client, struct inode *dir,\n\t\t\t   const struct qstr *name,\n\t\t\t   struct nfs4_fs_locations *fs_locations,\n\t\t\t   struct page *page)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(dir),\n\t\t\t\t_nfs4_proc_fs_locations(client, dir, name, fs_locations, page),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int _nfs4_proc_secinfo(struct inode *dir, const struct qstr *name, struct nfs4_secinfo_flavors *flavors)\n{\n\tint status;\n\tstruct nfs4_secinfo_arg args = {\n\t\t.dir_fh = NFS_FH(dir),\n\t\t.name   = name,\n\t};\n\tstruct nfs4_secinfo_res res = {\n\t\t.flavors     = flavors,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SECINFO],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\n\tdprintk(\"NFS call  secinfo %s\\n\", name->name);\n\tstatus = nfs4_call_sync(NFS_SERVER(dir)->client, NFS_SERVER(dir), &msg, &args.seq_args, &res.seq_res, 0);\n\tdprintk(\"NFS reply  secinfo: %d\\n\", status);\n\treturn status;\n}\n\nint nfs4_proc_secinfo(struct inode *dir, const struct qstr *name,\n\t\t      struct nfs4_secinfo_flavors *flavors)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(dir),\n\t\t\t\t_nfs4_proc_secinfo(dir, name, flavors),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\n#ifdef CONFIG_NFS_V4_1\n/*\n * Check the exchange flags returned by the server for invalid flags, having\n * both PNFS and NON_PNFS flags set, and not having one of NON_PNFS, PNFS, or\n * DS flags set.\n */\nstatic int nfs4_check_cl_exchange_flags(u32 flags)\n{\n\tif (flags & ~EXCHGID4_FLAG_MASK_R)\n\t\tgoto out_inval;\n\tif ((flags & EXCHGID4_FLAG_USE_PNFS_MDS) &&\n\t    (flags & EXCHGID4_FLAG_USE_NON_PNFS))\n\t\tgoto out_inval;\n\tif (!(flags & (EXCHGID4_FLAG_MASK_PNFS)))\n\t\tgoto out_inval;\n\treturn NFS_OK;\nout_inval:\n\treturn -NFS4ERR_INVAL;\n}\n\nstatic bool\nnfs41_same_server_scope(struct nfs41_server_scope *a,\n\t\t\tstruct nfs41_server_scope *b)\n{\n\tif (a->server_scope_sz == b->server_scope_sz &&\n\t    memcmp(a->server_scope, b->server_scope, a->server_scope_sz) == 0)\n\t\treturn true;\n\n\treturn false;\n}\n\n/*\n * nfs4_proc_bind_conn_to_session()\n *\n * The 4.1 client currently uses the same TCP connection for the\n * fore and backchannel.\n */\nint nfs4_proc_bind_conn_to_session(struct nfs_client *clp, struct rpc_cred *cred)\n{\n\tint status;\n\tstruct nfs41_bind_conn_to_session_res res;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc =\n\t\t\t&nfs4_procedures[NFSPROC4_CLNT_BIND_CONN_TO_SESSION],\n\t\t.rpc_argp = clp,\n\t\t.rpc_resp = &res,\n\t\t.rpc_cred = cred,\n\t};\n\n\tdprintk(\"--> %s\\n\", __func__);\n\tBUG_ON(clp == NULL);\n\n\tres.session = kzalloc(sizeof(struct nfs4_session), GFP_NOFS);\n\tif (unlikely(res.session == NULL)) {\n\t\tstatus = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tstatus = rpc_call_sync(clp->cl_rpcclient, &msg, RPC_TASK_TIMEOUT);\n\tif (status == 0) {\n\t\tif (memcmp(res.session->sess_id.data,\n\t\t    clp->cl_session->sess_id.data, NFS4_MAX_SESSIONID_LEN)) {\n\t\t\tdprintk(\"NFS: %s: Session ID mismatch\\n\", __func__);\n\t\t\tstatus = -EIO;\n\t\t\tgoto out_session;\n\t\t}\n\t\tif (res.dir != NFS4_CDFS4_BOTH) {\n\t\t\tdprintk(\"NFS: %s: Unexpected direction from server\\n\",\n\t\t\t\t__func__);\n\t\t\tstatus = -EIO;\n\t\t\tgoto out_session;\n\t\t}\n\t\tif (res.use_conn_in_rdma_mode) {\n\t\t\tdprintk(\"NFS: %s: Server returned RDMA mode = true\\n\",\n\t\t\t\t__func__);\n\t\t\tstatus = -EIO;\n\t\t\tgoto out_session;\n\t\t}\n\t}\nout_session:\n\tkfree(res.session);\nout:\n\tdprintk(\"<-- %s status= %d\\n\", __func__, status);\n\treturn status;\n}\n\n/*\n * nfs4_proc_exchange_id()\n *\n * Returns zero, a negative errno, or a negative NFS4ERR status code.\n *\n * Since the clientid has expired, all compounds using sessions\n * associated with the stale clientid will be returning\n * NFS4ERR_BADSESSION in the sequence operation, and will therefore\n * be in some phase of session reset.\n */\nint nfs4_proc_exchange_id(struct nfs_client *clp, struct rpc_cred *cred)\n{\n\tnfs4_verifier verifier;\n\tstruct nfs41_exchange_id_args args = {\n\t\t.verifier = &verifier,\n\t\t.client = clp,\n\t\t.flags = EXCHGID4_FLAG_SUPP_MOVED_REFER,\n\t};\n\tstruct nfs41_exchange_id_res res = {\n\t\t0\n\t};\n\tint status;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_EXCHANGE_ID],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t\t.rpc_cred = cred,\n\t};\n\n\tnfs4_init_boot_verifier(clp, &verifier);\n\targs.id_len = nfs4_init_uniform_client_string(clp, args.id,\n\t\t\t\t\t\t\tsizeof(args.id));\n\tdprintk(\"NFS call  exchange_id auth=%s, '%.*s'\\n\",\n\t\tclp->cl_rpcclient->cl_auth->au_ops->au_name,\n\t\targs.id_len, args.id);\n\n\tres.server_owner = kzalloc(sizeof(struct nfs41_server_owner),\n\t\t\t\t\tGFP_NOFS);\n\tif (unlikely(res.server_owner == NULL)) {\n\t\tstatus = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tres.server_scope = kzalloc(sizeof(struct nfs41_server_scope),\n\t\t\t\t\tGFP_NOFS);\n\tif (unlikely(res.server_scope == NULL)) {\n\t\tstatus = -ENOMEM;\n\t\tgoto out_server_owner;\n\t}\n\n\tres.impl_id = kzalloc(sizeof(struct nfs41_impl_id), GFP_NOFS);\n\tif (unlikely(res.impl_id == NULL)) {\n\t\tstatus = -ENOMEM;\n\t\tgoto out_server_scope;\n\t}\n\n\tstatus = rpc_call_sync(clp->cl_rpcclient, &msg, RPC_TASK_TIMEOUT);\n\tif (status == 0)\n\t\tstatus = nfs4_check_cl_exchange_flags(res.flags);\n\n\tif (status == 0) {\n\t\tclp->cl_clientid = res.clientid;\n\t\tclp->cl_exchange_flags = (res.flags & ~EXCHGID4_FLAG_CONFIRMED_R);\n\t\tif (!(res.flags & EXCHGID4_FLAG_CONFIRMED_R))\n\t\t\tclp->cl_seqid = res.seqid;\n\n\t\tkfree(clp->cl_serverowner);\n\t\tclp->cl_serverowner = res.server_owner;\n\t\tres.server_owner = NULL;\n\n\t\t/* use the most recent implementation id */\n\t\tkfree(clp->cl_implid);\n\t\tclp->cl_implid = res.impl_id;\n\n\t\tif (clp->cl_serverscope != NULL &&\n\t\t    !nfs41_same_server_scope(clp->cl_serverscope,\n\t\t\t\t\t     res.server_scope)) {\n\t\t\tdprintk(\"%s: server_scope mismatch detected\\n\",\n\t\t\t\t__func__);\n\t\t\tset_bit(NFS4CLNT_SERVER_SCOPE_MISMATCH, &clp->cl_state);\n\t\t\tkfree(clp->cl_serverscope);\n\t\t\tclp->cl_serverscope = NULL;\n\t\t}\n\n\t\tif (clp->cl_serverscope == NULL) {\n\t\t\tclp->cl_serverscope = res.server_scope;\n\t\t\tgoto out;\n\t\t}\n\t} else\n\t\tkfree(res.impl_id);\n\nout_server_owner:\n\tkfree(res.server_owner);\nout_server_scope:\n\tkfree(res.server_scope);\nout:\n\tif (clp->cl_implid != NULL)\n\t\tdprintk(\"NFS reply exchange_id: Server Implementation ID: \"\n\t\t\t\"domain: %s, name: %s, date: %llu,%u\\n\",\n\t\t\tclp->cl_implid->domain, clp->cl_implid->name,\n\t\t\tclp->cl_implid->date.seconds,\n\t\t\tclp->cl_implid->date.nseconds);\n\tdprintk(\"NFS reply exchange_id: %d\\n\", status);\n\treturn status;\n}\n\nstatic int _nfs4_proc_destroy_clientid(struct nfs_client *clp,\n\t\tstruct rpc_cred *cred)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_DESTROY_CLIENTID],\n\t\t.rpc_argp = clp,\n\t\t.rpc_cred = cred,\n\t};\n\tint status;\n\n\tstatus = rpc_call_sync(clp->cl_rpcclient, &msg, RPC_TASK_TIMEOUT);\n\tif (status)\n\t\tdprintk(\"NFS: Got error %d from the server %s on \"\n\t\t\t\"DESTROY_CLIENTID.\", status, clp->cl_hostname);\n\treturn status;\n}\n\nstatic int nfs4_proc_destroy_clientid(struct nfs_client *clp,\n\t\tstruct rpc_cred *cred)\n{\n\tunsigned int loop;\n\tint ret;\n\n\tfor (loop = NFS4_MAX_LOOP_ON_RECOVER; loop != 0; loop--) {\n\t\tret = _nfs4_proc_destroy_clientid(clp, cred);\n\t\tswitch (ret) {\n\t\tcase -NFS4ERR_DELAY:\n\t\tcase -NFS4ERR_CLIENTID_BUSY:\n\t\t\tssleep(1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint nfs4_destroy_clientid(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred;\n\tint ret = 0;\n\n\tif (clp->cl_mvops->minor_version < 1)\n\t\tgoto out;\n\tif (clp->cl_exchange_flags == 0)\n\t\tgoto out;\n\tif (clp->cl_preserve_clid)\n\t\tgoto out;\n\tcred = nfs4_get_exchange_id_cred(clp);\n\tret = nfs4_proc_destroy_clientid(clp, cred);\n\tif (cred)\n\t\tput_rpccred(cred);\n\tswitch (ret) {\n\tcase 0:\n\tcase -NFS4ERR_STALE_CLIENTID:\n\t\tclp->cl_exchange_flags = 0;\n\t}\nout:\n\treturn ret;\n}\n\nstruct nfs4_get_lease_time_data {\n\tstruct nfs4_get_lease_time_args *args;\n\tstruct nfs4_get_lease_time_res *res;\n\tstruct nfs_client *clp;\n};\n\nstatic void nfs4_get_lease_time_prepare(struct rpc_task *task,\n\t\t\t\t\tvoid *calldata)\n{\n\tint ret;\n\tstruct nfs4_get_lease_time_data *data =\n\t\t\t(struct nfs4_get_lease_time_data *)calldata;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\trpc_task_set_priority(task, RPC_PRIORITY_PRIVILEGED);\n\t/* just setup sequence, do not trigger session recovery\n\t   since we're invoked within one */\n\tret = nfs41_setup_sequence(data->clp->cl_session,\n\t\t\t\t   &data->args->la_seq_args,\n\t\t\t\t   &data->res->lr_seq_res, task);\n\n\tBUG_ON(ret == -EAGAIN);\n\trpc_call_start(task);\n\tdprintk(\"<-- %s\\n\", __func__);\n}\n\n/*\n * Called from nfs4_state_manager thread for session setup, so don't recover\n * from sequence operation or clientid errors.\n */\nstatic void nfs4_get_lease_time_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_get_lease_time_data *data =\n\t\t\t(struct nfs4_get_lease_time_data *)calldata;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\tif (!nfs41_sequence_done(task, &data->res->lr_seq_res))\n\t\treturn;\n\tswitch (task->tk_status) {\n\tcase -NFS4ERR_DELAY:\n\tcase -NFS4ERR_GRACE:\n\t\tdprintk(\"%s Retry: tk_status %d\\n\", __func__, task->tk_status);\n\t\trpc_delay(task, NFS4_POLL_RETRY_MIN);\n\t\ttask->tk_status = 0;\n\t\t/* fall through */\n\tcase -NFS4ERR_RETRY_UNCACHED_REP:\n\t\trpc_restart_call_prepare(task);\n\t\treturn;\n\t}\n\tdprintk(\"<-- %s\\n\", __func__);\n}\n\nstatic const struct rpc_call_ops nfs4_get_lease_time_ops = {\n\t.rpc_call_prepare = nfs4_get_lease_time_prepare,\n\t.rpc_call_done = nfs4_get_lease_time_done,\n};\n\nint nfs4_proc_get_lease_time(struct nfs_client *clp, struct nfs_fsinfo *fsinfo)\n{\n\tstruct rpc_task *task;\n\tstruct nfs4_get_lease_time_args args;\n\tstruct nfs4_get_lease_time_res res = {\n\t\t.lr_fsinfo = fsinfo,\n\t};\n\tstruct nfs4_get_lease_time_data data = {\n\t\t.args = &args,\n\t\t.res = &res,\n\t\t.clp = clp,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GET_LEASE_TIME],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tstruct rpc_task_setup task_setup = {\n\t\t.rpc_client = clp->cl_rpcclient,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_get_lease_time_ops,\n\t\t.callback_data = &data,\n\t\t.flags = RPC_TASK_TIMEOUT,\n\t};\n\tint status;\n\n\tnfs41_init_sequence(&args.la_seq_args, &res.lr_seq_res, 0);\n\tdprintk(\"--> %s\\n\", __func__);\n\ttask = rpc_run_task(&task_setup);\n\n\tif (IS_ERR(task))\n\t\tstatus = PTR_ERR(task);\n\telse {\n\t\tstatus = task->tk_status;\n\t\trpc_put_task(task);\n\t}\n\tdprintk(\"<-- %s return %d\\n\", __func__, status);\n\n\treturn status;\n}\n\nstatic struct nfs4_slot *nfs4_alloc_slots(u32 max_slots, gfp_t gfp_flags)\n{\n\treturn kcalloc(max_slots, sizeof(struct nfs4_slot), gfp_flags);\n}\n\nstatic void nfs4_add_and_init_slots(struct nfs4_slot_table *tbl,\n\t\tstruct nfs4_slot *new,\n\t\tu32 max_slots,\n\t\tu32 ivalue)\n{\n\tstruct nfs4_slot *old = NULL;\n\tu32 i;\n\n\tspin_lock(&tbl->slot_tbl_lock);\n\tif (new) {\n\t\told = tbl->slots;\n\t\ttbl->slots = new;\n\t\ttbl->max_slots = max_slots;\n\t}\n\ttbl->highest_used_slotid = NFS4_NO_SLOT;\n\tfor (i = 0; i < tbl->max_slots; i++)\n\t\ttbl->slots[i].seq_nr = ivalue;\n\tspin_unlock(&tbl->slot_tbl_lock);\n\tkfree(old);\n}\n\n/*\n * (re)Initialise a slot table\n */\nstatic int nfs4_realloc_slot_table(struct nfs4_slot_table *tbl, u32 max_reqs,\n\t\t\t\t u32 ivalue)\n{\n\tstruct nfs4_slot *new = NULL;\n\tint ret = -ENOMEM;\n\n\tdprintk(\"--> %s: max_reqs=%u, tbl->max_slots %d\\n\", __func__,\n\t\tmax_reqs, tbl->max_slots);\n\n\t/* Does the newly negotiated max_reqs match the existing slot table? */\n\tif (max_reqs != tbl->max_slots) {\n\t\tnew = nfs4_alloc_slots(max_reqs, GFP_NOFS);\n\t\tif (!new)\n\t\t\tgoto out;\n\t}\n\tret = 0;\n\n\tnfs4_add_and_init_slots(tbl, new, max_reqs, ivalue);\n\tdprintk(\"%s: tbl=%p slots=%p max_slots=%d\\n\", __func__,\n\t\ttbl, tbl->slots, tbl->max_slots);\nout:\n\tdprintk(\"<-- %s: return %d\\n\", __func__, ret);\n\treturn ret;\n}\n\n/* Destroy the slot table */\nstatic void nfs4_destroy_slot_tables(struct nfs4_session *session)\n{\n\tif (session->fc_slot_table.slots != NULL) {\n\t\tkfree(session->fc_slot_table.slots);\n\t\tsession->fc_slot_table.slots = NULL;\n\t}\n\tif (session->bc_slot_table.slots != NULL) {\n\t\tkfree(session->bc_slot_table.slots);\n\t\tsession->bc_slot_table.slots = NULL;\n\t}\n\treturn;\n}\n\n/*\n * Initialize or reset the forechannel and backchannel tables\n */\nstatic int nfs4_setup_session_slot_tables(struct nfs4_session *ses)\n{\n\tstruct nfs4_slot_table *tbl;\n\tint status;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\t/* Fore channel */\n\ttbl = &ses->fc_slot_table;\n\tstatus = nfs4_realloc_slot_table(tbl, ses->fc_attrs.max_reqs, 1);\n\tif (status) /* -ENOMEM */\n\t\treturn status;\n\t/* Back channel */\n\ttbl = &ses->bc_slot_table;\n\tstatus = nfs4_realloc_slot_table(tbl, ses->bc_attrs.max_reqs, 0);\n\tif (status && tbl->slots == NULL)\n\t\t/* Fore and back channel share a connection so get\n\t\t * both slot tables or neither */\n\t\tnfs4_destroy_slot_tables(ses);\n\treturn status;\n}\n\nstruct nfs4_session *nfs4_alloc_session(struct nfs_client *clp)\n{\n\tstruct nfs4_session *session;\n\tstruct nfs4_slot_table *tbl;\n\n\tsession = kzalloc(sizeof(struct nfs4_session), GFP_NOFS);\n\tif (!session)\n\t\treturn NULL;\n\n\ttbl = &session->fc_slot_table;\n\ttbl->highest_used_slotid = NFS4_NO_SLOT;\n\tspin_lock_init(&tbl->slot_tbl_lock);\n\trpc_init_priority_wait_queue(&tbl->slot_tbl_waitq, \"ForeChannel Slot table\");\n\tinit_completion(&tbl->complete);\n\n\ttbl = &session->bc_slot_table;\n\ttbl->highest_used_slotid = NFS4_NO_SLOT;\n\tspin_lock_init(&tbl->slot_tbl_lock);\n\trpc_init_wait_queue(&tbl->slot_tbl_waitq, \"BackChannel Slot table\");\n\tinit_completion(&tbl->complete);\n\n\tsession->session_state = 1<<NFS4_SESSION_INITING;\n\n\tsession->clp = clp;\n\treturn session;\n}\n\nvoid nfs4_destroy_session(struct nfs4_session *session)\n{\n\tstruct rpc_xprt *xprt;\n\tstruct rpc_cred *cred;\n\n\tcred = nfs4_get_exchange_id_cred(session->clp);\n\tnfs4_proc_destroy_session(session, cred);\n\tif (cred)\n\t\tput_rpccred(cred);\n\n\trcu_read_lock();\n\txprt = rcu_dereference(session->clp->cl_rpcclient->cl_xprt);\n\trcu_read_unlock();\n\tdprintk(\"%s Destroy backchannel for xprt %p\\n\",\n\t\t__func__, xprt);\n\txprt_destroy_backchannel(xprt, NFS41_BC_MIN_CALLBACKS);\n\tnfs4_destroy_slot_tables(session);\n\tkfree(session);\n}\n\n/*\n * Initialize the values to be used by the client in CREATE_SESSION\n * If nfs4_init_session set the fore channel request and response sizes,\n * use them.\n *\n * Set the back channel max_resp_sz_cached to zero to force the client to\n * always set csa_cachethis to FALSE because the current implementation\n * of the back channel DRC only supports caching the CB_SEQUENCE operation.\n */\nstatic void nfs4_init_channel_attrs(struct nfs41_create_session_args *args)\n{\n\tstruct nfs4_session *session = args->client->cl_session;\n\tunsigned int mxrqst_sz = session->fc_attrs.max_rqst_sz,\n\t\t     mxresp_sz = session->fc_attrs.max_resp_sz;\n\n\tif (mxrqst_sz == 0)\n\t\tmxrqst_sz = NFS_MAX_FILE_IO_SIZE;\n\tif (mxresp_sz == 0)\n\t\tmxresp_sz = NFS_MAX_FILE_IO_SIZE;\n\t/* Fore channel attributes */\n\targs->fc_attrs.max_rqst_sz = mxrqst_sz;\n\targs->fc_attrs.max_resp_sz = mxresp_sz;\n\targs->fc_attrs.max_ops = NFS4_MAX_OPS;\n\targs->fc_attrs.max_reqs = max_session_slots;\n\n\tdprintk(\"%s: Fore Channel : max_rqst_sz=%u max_resp_sz=%u \"\n\t\t\"max_ops=%u max_reqs=%u\\n\",\n\t\t__func__,\n\t\targs->fc_attrs.max_rqst_sz, args->fc_attrs.max_resp_sz,\n\t\targs->fc_attrs.max_ops, args->fc_attrs.max_reqs);\n\n\t/* Back channel attributes */\n\targs->bc_attrs.max_rqst_sz = PAGE_SIZE;\n\targs->bc_attrs.max_resp_sz = PAGE_SIZE;\n\targs->bc_attrs.max_resp_sz_cached = 0;\n\targs->bc_attrs.max_ops = NFS4_MAX_BACK_CHANNEL_OPS;\n\targs->bc_attrs.max_reqs = 1;\n\n\tdprintk(\"%s: Back Channel : max_rqst_sz=%u max_resp_sz=%u \"\n\t\t\"max_resp_sz_cached=%u max_ops=%u max_reqs=%u\\n\",\n\t\t__func__,\n\t\targs->bc_attrs.max_rqst_sz, args->bc_attrs.max_resp_sz,\n\t\targs->bc_attrs.max_resp_sz_cached, args->bc_attrs.max_ops,\n\t\targs->bc_attrs.max_reqs);\n}\n\nstatic int nfs4_verify_fore_channel_attrs(struct nfs41_create_session_args *args, struct nfs4_session *session)\n{\n\tstruct nfs4_channel_attrs *sent = &args->fc_attrs;\n\tstruct nfs4_channel_attrs *rcvd = &session->fc_attrs;\n\n\tif (rcvd->max_resp_sz > sent->max_resp_sz)\n\t\treturn -EINVAL;\n\t/*\n\t * Our requested max_ops is the minimum we need; we're not\n\t * prepared to break up compounds into smaller pieces than that.\n\t * So, no point even trying to continue if the server won't\n\t * cooperate:\n\t */\n\tif (rcvd->max_ops < sent->max_ops)\n\t\treturn -EINVAL;\n\tif (rcvd->max_reqs == 0)\n\t\treturn -EINVAL;\n\tif (rcvd->max_reqs > NFS4_MAX_SLOT_TABLE)\n\t\trcvd->max_reqs = NFS4_MAX_SLOT_TABLE;\n\treturn 0;\n}\n\nstatic int nfs4_verify_back_channel_attrs(struct nfs41_create_session_args *args, struct nfs4_session *session)\n{\n\tstruct nfs4_channel_attrs *sent = &args->bc_attrs;\n\tstruct nfs4_channel_attrs *rcvd = &session->bc_attrs;\n\n\tif (rcvd->max_rqst_sz > sent->max_rqst_sz)\n\t\treturn -EINVAL;\n\tif (rcvd->max_resp_sz < sent->max_resp_sz)\n\t\treturn -EINVAL;\n\tif (rcvd->max_resp_sz_cached > sent->max_resp_sz_cached)\n\t\treturn -EINVAL;\n\t/* These would render the backchannel useless: */\n\tif (rcvd->max_ops != sent->max_ops)\n\t\treturn -EINVAL;\n\tif (rcvd->max_reqs != sent->max_reqs)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int nfs4_verify_channel_attrs(struct nfs41_create_session_args *args,\n\t\t\t\t     struct nfs4_session *session)\n{\n\tint ret;\n\n\tret = nfs4_verify_fore_channel_attrs(args, session);\n\tif (ret)\n\t\treturn ret;\n\treturn nfs4_verify_back_channel_attrs(args, session);\n}\n\nstatic int _nfs4_proc_create_session(struct nfs_client *clp,\n\t\tstruct rpc_cred *cred)\n{\n\tstruct nfs4_session *session = clp->cl_session;\n\tstruct nfs41_create_session_args args = {\n\t\t.client = clp,\n\t\t.cb_program = NFS4_CALLBACK,\n\t};\n\tstruct nfs41_create_session_res res = {\n\t\t.client = clp,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_CREATE_SESSION],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t\t.rpc_cred = cred,\n\t};\n\tint status;\n\n\tnfs4_init_channel_attrs(&args);\n\targs.flags = (SESSION4_PERSIST | SESSION4_BACK_CHAN);\n\n\tstatus = rpc_call_sync(session->clp->cl_rpcclient, &msg, RPC_TASK_TIMEOUT);\n\n\tif (!status)\n\t\t/* Verify the session's negotiated channel_attrs values */\n\t\tstatus = nfs4_verify_channel_attrs(&args, session);\n\tif (!status) {\n\t\t/* Increment the clientid slot sequence id */\n\t\tclp->cl_seqid++;\n\t}\n\n\treturn status;\n}\n\n/*\n * Issues a CREATE_SESSION operation to the server.\n * It is the responsibility of the caller to verify the session is\n * expired before calling this routine.\n */\nint nfs4_proc_create_session(struct nfs_client *clp, struct rpc_cred *cred)\n{\n\tint status;\n\tunsigned *ptr;\n\tstruct nfs4_session *session = clp->cl_session;\n\n\tdprintk(\"--> %s clp=%p session=%p\\n\", __func__, clp, session);\n\n\tstatus = _nfs4_proc_create_session(clp, cred);\n\tif (status)\n\t\tgoto out;\n\n\t/* Init or reset the session slot tables */\n\tstatus = nfs4_setup_session_slot_tables(session);\n\tdprintk(\"slot table setup returned %d\\n\", status);\n\tif (status)\n\t\tgoto out;\n\n\tptr = (unsigned *)&session->sess_id.data[0];\n\tdprintk(\"%s client>seqid %d sessionid %u:%u:%u:%u\\n\", __func__,\n\t\tclp->cl_seqid, ptr[0], ptr[1], ptr[2], ptr[3]);\nout:\n\tdprintk(\"<-- %s\\n\", __func__);\n\treturn status;\n}\n\n/*\n * Issue the over-the-wire RPC DESTROY_SESSION.\n * The caller must serialize access to this routine.\n */\nint nfs4_proc_destroy_session(struct nfs4_session *session,\n\t\tstruct rpc_cred *cred)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_DESTROY_SESSION],\n\t\t.rpc_argp = session,\n\t\t.rpc_cred = cred,\n\t};\n\tint status = 0;\n\n\tdprintk(\"--> nfs4_proc_destroy_session\\n\");\n\n\t/* session is still being setup */\n\tif (session->clp->cl_cons_state != NFS_CS_READY)\n\t\treturn status;\n\n\tstatus = rpc_call_sync(session->clp->cl_rpcclient, &msg, RPC_TASK_TIMEOUT);\n\n\tif (status)\n\t\tdprintk(\"NFS: Got error %d from the server on DESTROY_SESSION. \"\n\t\t\t\"Session has been destroyed regardless...\\n\", status);\n\n\tdprintk(\"<-- nfs4_proc_destroy_session\\n\");\n\treturn status;\n}\n\n/*\n * With sessions, the client is not marked ready until after a\n * successful EXCHANGE_ID and CREATE_SESSION.\n *\n * Map errors cl_cons_state errors to EPROTONOSUPPORT to indicate\n * other versions of NFS can be tried.\n */\nstatic int nfs41_check_session_ready(struct nfs_client *clp)\n{\n\tint ret;\n\t\n\tif (clp->cl_cons_state == NFS_CS_SESSION_INITING) {\n\t\tret = nfs4_client_recover_expired_lease(clp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (clp->cl_cons_state < NFS_CS_READY)\n\t\treturn -EPROTONOSUPPORT;\n\tsmp_rmb();\n\treturn 0;\n}\n\nint nfs4_init_session(struct nfs_server *server)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs4_session *session;\n\tunsigned int rsize, wsize;\n\n\tif (!nfs4_has_session(clp))\n\t\treturn 0;\n\n\tsession = clp->cl_session;\n\tspin_lock(&clp->cl_lock);\n\tif (test_and_clear_bit(NFS4_SESSION_INITING, &session->session_state)) {\n\n\t\trsize = server->rsize;\n\t\tif (rsize == 0)\n\t\t\trsize = NFS_MAX_FILE_IO_SIZE;\n\t\twsize = server->wsize;\n\t\tif (wsize == 0)\n\t\t\twsize = NFS_MAX_FILE_IO_SIZE;\n\n\t\tsession->fc_attrs.max_rqst_sz = wsize + nfs41_maxwrite_overhead;\n\t\tsession->fc_attrs.max_resp_sz = rsize + nfs41_maxread_overhead;\n\t}\n\tspin_unlock(&clp->cl_lock);\n\n\treturn nfs41_check_session_ready(clp);\n}\n\nint nfs4_init_ds_session(struct nfs_client *clp, unsigned long lease_time)\n{\n\tstruct nfs4_session *session = clp->cl_session;\n\tint ret;\n\n\tspin_lock(&clp->cl_lock);\n\tif (test_and_clear_bit(NFS4_SESSION_INITING, &session->session_state)) {\n\t\t/*\n\t\t * Do not set NFS_CS_CHECK_LEASE_TIME instead set the\n\t\t * DS lease to be equal to the MDS lease.\n\t\t */\n\t\tclp->cl_lease_time = lease_time;\n\t\tclp->cl_last_renewal = jiffies;\n\t}\n\tspin_unlock(&clp->cl_lock);\n\n\tret = nfs41_check_session_ready(clp);\n\tif (ret)\n\t\treturn ret;\n\t/* Test for the DS role */\n\tif (!is_ds_client(clp))\n\t\treturn -ENODEV;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nfs4_init_ds_session);\n\n\n/*\n * Renew the cl_session lease.\n */\nstruct nfs4_sequence_data {\n\tstruct nfs_client *clp;\n\tstruct nfs4_sequence_args args;\n\tstruct nfs4_sequence_res res;\n};\n\nstatic void nfs41_sequence_release(void *data)\n{\n\tstruct nfs4_sequence_data *calldata = data;\n\tstruct nfs_client *clp = calldata->clp;\n\n\tif (atomic_read(&clp->cl_count) > 1)\n\t\tnfs4_schedule_state_renewal(clp);\n\tnfs_put_client(clp);\n\tkfree(calldata);\n}\n\nstatic int nfs41_sequence_handle_errors(struct rpc_task *task, struct nfs_client *clp)\n{\n\tswitch(task->tk_status) {\n\tcase -NFS4ERR_DELAY:\n\t\trpc_delay(task, NFS4_POLL_RETRY_MAX);\n\t\treturn -EAGAIN;\n\tdefault:\n\t\tnfs4_schedule_lease_recovery(clp);\n\t}\n\treturn 0;\n}\n\nstatic void nfs41_sequence_call_done(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_sequence_data *calldata = data;\n\tstruct nfs_client *clp = calldata->clp;\n\n\tif (!nfs41_sequence_done(task, task->tk_msg.rpc_resp))\n\t\treturn;\n\n\tif (task->tk_status < 0) {\n\t\tdprintk(\"%s ERROR %d\\n\", __func__, task->tk_status);\n\t\tif (atomic_read(&clp->cl_count) == 1)\n\t\t\tgoto out;\n\n\t\tif (nfs41_sequence_handle_errors(task, clp) == -EAGAIN) {\n\t\t\trpc_restart_call_prepare(task);\n\t\t\treturn;\n\t\t}\n\t}\n\tdprintk(\"%s rpc_cred %p\\n\", __func__, task->tk_msg.rpc_cred);\nout:\n\tdprintk(\"<-- %s\\n\", __func__);\n}\n\nstatic void nfs41_sequence_prepare(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_sequence_data *calldata = data;\n\tstruct nfs_client *clp = calldata->clp;\n\tstruct nfs4_sequence_args *args;\n\tstruct nfs4_sequence_res *res;\n\n\targs = task->tk_msg.rpc_argp;\n\tres = task->tk_msg.rpc_resp;\n\n\tif (nfs41_setup_sequence(clp->cl_session, args, res, task))\n\t\treturn;\n\trpc_call_start(task);\n}\n\nstatic const struct rpc_call_ops nfs41_sequence_ops = {\n\t.rpc_call_done = nfs41_sequence_call_done,\n\t.rpc_call_prepare = nfs41_sequence_prepare,\n\t.rpc_release = nfs41_sequence_release,\n};\n\nstatic struct rpc_task *_nfs41_proc_sequence(struct nfs_client *clp, struct rpc_cred *cred)\n{\n\tstruct nfs4_sequence_data *calldata;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SEQUENCE],\n\t\t.rpc_cred = cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = clp->cl_rpcclient,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs41_sequence_ops,\n\t\t.flags = RPC_TASK_ASYNC | RPC_TASK_SOFT,\n\t};\n\n\tif (!atomic_inc_not_zero(&clp->cl_count))\n\t\treturn ERR_PTR(-EIO);\n\tcalldata = kzalloc(sizeof(*calldata), GFP_NOFS);\n\tif (calldata == NULL) {\n\t\tnfs_put_client(clp);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tnfs41_init_sequence(&calldata->args, &calldata->res, 0);\n\tmsg.rpc_argp = &calldata->args;\n\tmsg.rpc_resp = &calldata->res;\n\tcalldata->clp = clp;\n\ttask_setup_data.callback_data = calldata;\n\n\treturn rpc_run_task(&task_setup_data);\n}\n\nstatic int nfs41_proc_async_sequence(struct nfs_client *clp, struct rpc_cred *cred, unsigned renew_flags)\n{\n\tstruct rpc_task *task;\n\tint ret = 0;\n\n\tif ((renew_flags & NFS4_RENEW_TIMEOUT) == 0)\n\t\treturn 0;\n\ttask = _nfs41_proc_sequence(clp, cred);\n\tif (IS_ERR(task))\n\t\tret = PTR_ERR(task);\n\telse\n\t\trpc_put_task_async(task);\n\tdprintk(\"<-- %s status=%d\\n\", __func__, ret);\n\treturn ret;\n}\n\nstatic int nfs4_proc_sequence(struct nfs_client *clp, struct rpc_cred *cred)\n{\n\tstruct rpc_task *task;\n\tint ret;\n\n\ttask = _nfs41_proc_sequence(clp, cred);\n\tif (IS_ERR(task)) {\n\t\tret = PTR_ERR(task);\n\t\tgoto out;\n\t}\n\tret = rpc_wait_for_completion_task(task);\n\tif (!ret) {\n\t\tstruct nfs4_sequence_res *res = task->tk_msg.rpc_resp;\n\n\t\tif (task->tk_status == 0)\n\t\t\tnfs41_handle_sequence_flag_errors(clp, res->sr_status_flags);\n\t\tret = task->tk_status;\n\t}\n\trpc_put_task(task);\nout:\n\tdprintk(\"<-- %s status=%d\\n\", __func__, ret);\n\treturn ret;\n}\n\nstruct nfs4_reclaim_complete_data {\n\tstruct nfs_client *clp;\n\tstruct nfs41_reclaim_complete_args arg;\n\tstruct nfs41_reclaim_complete_res res;\n};\n\nstatic void nfs4_reclaim_complete_prepare(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_reclaim_complete_data *calldata = data;\n\n\trpc_task_set_priority(task, RPC_PRIORITY_PRIVILEGED);\n\tif (nfs41_setup_sequence(calldata->clp->cl_session,\n\t\t\t\t&calldata->arg.seq_args,\n\t\t\t\t&calldata->res.seq_res, task))\n\t\treturn;\n\n\trpc_call_start(task);\n}\n\nstatic int nfs41_reclaim_complete_handle_errors(struct rpc_task *task, struct nfs_client *clp)\n{\n\tswitch(task->tk_status) {\n\tcase 0:\n\tcase -NFS4ERR_COMPLETE_ALREADY:\n\tcase -NFS4ERR_WRONG_CRED: /* What to do here? */\n\t\tbreak;\n\tcase -NFS4ERR_DELAY:\n\t\trpc_delay(task, NFS4_POLL_RETRY_MAX);\n\t\t/* fall through */\n\tcase -NFS4ERR_RETRY_UNCACHED_REP:\n\t\treturn -EAGAIN;\n\tdefault:\n\t\tnfs4_schedule_lease_recovery(clp);\n\t}\n\treturn 0;\n}\n\nstatic void nfs4_reclaim_complete_done(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_reclaim_complete_data *calldata = data;\n\tstruct nfs_client *clp = calldata->clp;\n\tstruct nfs4_sequence_res *res = &calldata->res.seq_res;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\tif (!nfs41_sequence_done(task, res))\n\t\treturn;\n\n\tif (nfs41_reclaim_complete_handle_errors(task, clp) == -EAGAIN) {\n\t\trpc_restart_call_prepare(task);\n\t\treturn;\n\t}\n\tdprintk(\"<-- %s\\n\", __func__);\n}\n\nstatic void nfs4_free_reclaim_complete_data(void *data)\n{\n\tstruct nfs4_reclaim_complete_data *calldata = data;\n\n\tkfree(calldata);\n}\n\nstatic const struct rpc_call_ops nfs4_reclaim_complete_call_ops = {\n\t.rpc_call_prepare = nfs4_reclaim_complete_prepare,\n\t.rpc_call_done = nfs4_reclaim_complete_done,\n\t.rpc_release = nfs4_free_reclaim_complete_data,\n};\n\n/*\n * Issue a global reclaim complete.\n */\nstatic int nfs41_proc_reclaim_complete(struct nfs_client *clp)\n{\n\tstruct nfs4_reclaim_complete_data *calldata;\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_RECLAIM_COMPLETE],\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = clp->cl_rpcclient,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_reclaim_complete_call_ops,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\tint status = -ENOMEM;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\tcalldata = kzalloc(sizeof(*calldata), GFP_NOFS);\n\tif (calldata == NULL)\n\t\tgoto out;\n\tcalldata->clp = clp;\n\tcalldata->arg.one_fs = 0;\n\n\tnfs41_init_sequence(&calldata->arg.seq_args, &calldata->res.seq_res, 0);\n\tmsg.rpc_argp = &calldata->arg;\n\tmsg.rpc_resp = &calldata->res;\n\ttask_setup_data.callback_data = calldata;\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task)) {\n\t\tstatus = PTR_ERR(task);\n\t\tgoto out;\n\t}\n\tstatus = nfs4_wait_for_completion_rpc_task(task);\n\tif (status == 0)\n\t\tstatus = task->tk_status;\n\trpc_put_task(task);\n\treturn 0;\nout:\n\tdprintk(\"<-- %s status=%d\\n\", __func__, status);\n\treturn status;\n}\n\nstatic void\nnfs4_layoutget_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_layoutget *lgp = calldata;\n\tstruct nfs_server *server = NFS_SERVER(lgp->args.inode);\n\n\tdprintk(\"--> %s\\n\", __func__);\n\t/* Note the is a race here, where a CB_LAYOUTRECALL can come in\n\t * right now covering the LAYOUTGET we are about to send.\n\t * However, that is not so catastrophic, and there seems\n\t * to be no way to prevent it completely.\n\t */\n\tif (nfs4_setup_sequence(server, &lgp->args.seq_args,\n\t\t\t\t&lgp->res.seq_res, task))\n\t\treturn;\n\tif (pnfs_choose_layoutget_stateid(&lgp->args.stateid,\n\t\t\t\t\t  NFS_I(lgp->args.inode)->layout,\n\t\t\t\t\t  lgp->args.ctx->state)) {\n\t\trpc_exit(task, NFS4_OK);\n\t\treturn;\n\t}\n\trpc_call_start(task);\n}\n\nstatic void nfs4_layoutget_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_layoutget *lgp = calldata;\n\tstruct inode *inode = lgp->args.inode;\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct pnfs_layout_hdr *lo;\n\tstruct nfs4_state *state = NULL;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\n\tif (!nfs4_sequence_done(task, &lgp->res.seq_res))\n\t\tgoto out;\n\n\tswitch (task->tk_status) {\n\tcase 0:\n\t\tgoto out;\n\tcase -NFS4ERR_LAYOUTTRYLATER:\n\tcase -NFS4ERR_RECALLCONFLICT:\n\t\ttask->tk_status = -NFS4ERR_DELAY;\n\t\tbreak;\n\tcase -NFS4ERR_EXPIRED:\n\tcase -NFS4ERR_BAD_STATEID:\n\t\tspin_lock(&inode->i_lock);\n\t\tlo = NFS_I(inode)->layout;\n\t\tif (!lo || list_empty(&lo->plh_segs)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t/* If the open stateid was bad, then recover it. */\n\t\t\tstate = lgp->args.ctx->state;\n\t\t} else {\n\t\t\tLIST_HEAD(head);\n\n\t\t\tpnfs_mark_matching_lsegs_invalid(lo, &head, NULL);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t/* Mark the bad layout state as invalid, then\n\t\t\t * retry using the open stateid. */\n\t\t\tpnfs_free_lseg_list(&head);\n\t\t}\n\t}\n\tif (nfs4_async_handle_error(task, server, state) == -EAGAIN)\n\t\trpc_restart_call_prepare(task);\nout:\n\tdprintk(\"<-- %s\\n\", __func__);\n}\n\nstatic size_t max_response_pages(struct nfs_server *server)\n{\n\tu32 max_resp_sz = server->nfs_client->cl_session->fc_attrs.max_resp_sz;\n\treturn nfs_page_array_len(0, max_resp_sz);\n}\n\nstatic void nfs4_free_pages(struct page **pages, size_t size)\n{\n\tint i;\n\n\tif (!pages)\n\t\treturn;\n\n\tfor (i = 0; i < size; i++) {\n\t\tif (!pages[i])\n\t\t\tbreak;\n\t\t__free_page(pages[i]);\n\t}\n\tkfree(pages);\n}\n\nstatic struct page **nfs4_alloc_pages(size_t size, gfp_t gfp_flags)\n{\n\tstruct page **pages;\n\tint i;\n\n\tpages = kcalloc(size, sizeof(struct page *), gfp_flags);\n\tif (!pages) {\n\t\tdprintk(\"%s: can't alloc array of %zu pages\\n\", __func__, size);\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < size; i++) {\n\t\tpages[i] = alloc_page(gfp_flags);\n\t\tif (!pages[i]) {\n\t\t\tdprintk(\"%s: failed to allocate page\\n\", __func__);\n\t\t\tnfs4_free_pages(pages, size);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn pages;\n}\n\nstatic void nfs4_layoutget_release(void *calldata)\n{\n\tstruct nfs4_layoutget *lgp = calldata;\n\tstruct nfs_server *server = NFS_SERVER(lgp->args.inode);\n\tsize_t max_pages = max_response_pages(server);\n\n\tdprintk(\"--> %s\\n\", __func__);\n\tnfs4_free_pages(lgp->args.layout.pages, max_pages);\n\tput_nfs_open_context(lgp->args.ctx);\n\tkfree(calldata);\n\tdprintk(\"<-- %s\\n\", __func__);\n}\n\nstatic const struct rpc_call_ops nfs4_layoutget_call_ops = {\n\t.rpc_call_prepare = nfs4_layoutget_prepare,\n\t.rpc_call_done = nfs4_layoutget_done,\n\t.rpc_release = nfs4_layoutget_release,\n};\n\nstruct pnfs_layout_segment *\nnfs4_proc_layoutget(struct nfs4_layoutget *lgp, gfp_t gfp_flags)\n{\n\tstruct nfs_server *server = NFS_SERVER(lgp->args.inode);\n\tsize_t max_pages = max_response_pages(server);\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LAYOUTGET],\n\t\t.rpc_argp = &lgp->args,\n\t\t.rpc_resp = &lgp->res,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = server->client,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_layoutget_call_ops,\n\t\t.callback_data = lgp,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\tstruct pnfs_layout_segment *lseg = NULL;\n\tint status = 0;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\n\tlgp->args.layout.pages = nfs4_alloc_pages(max_pages, gfp_flags);\n\tif (!lgp->args.layout.pages) {\n\t\tnfs4_layoutget_release(lgp);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tlgp->args.layout.pglen = max_pages * PAGE_SIZE;\n\n\tlgp->res.layoutp = &lgp->args.layout;\n\tlgp->res.seq_res.sr_slot = NULL;\n\tnfs41_init_sequence(&lgp->args.seq_args, &lgp->res.seq_res, 0);\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn ERR_CAST(task);\n\tstatus = nfs4_wait_for_completion_rpc_task(task);\n\tif (status == 0)\n\t\tstatus = task->tk_status;\n\tif (status == 0)\n\t\tlseg = pnfs_layout_process(lgp);\n\trpc_put_task(task);\n\tdprintk(\"<-- %s status=%d\\n\", __func__, status);\n\tif (status)\n\t\treturn ERR_PTR(status);\n\treturn lseg;\n}\n\nstatic void\nnfs4_layoutreturn_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_layoutreturn *lrp = calldata;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\tif (nfs41_setup_sequence(lrp->clp->cl_session, &lrp->args.seq_args,\n\t\t\t\t&lrp->res.seq_res, task))\n\t\treturn;\n\trpc_call_start(task);\n}\n\nstatic void nfs4_layoutreturn_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_layoutreturn *lrp = calldata;\n\tstruct nfs_server *server;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\n\tif (!nfs4_sequence_done(task, &lrp->res.seq_res))\n\t\treturn;\n\n\tserver = NFS_SERVER(lrp->args.inode);\n\tif (nfs4_async_handle_error(task, server, NULL) == -EAGAIN) {\n\t\trpc_restart_call_prepare(task);\n\t\treturn;\n\t}\n\tdprintk(\"<-- %s\\n\", __func__);\n}\n\nstatic void nfs4_layoutreturn_release(void *calldata)\n{\n\tstruct nfs4_layoutreturn *lrp = calldata;\n\tstruct pnfs_layout_hdr *lo = lrp->args.layout;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\tspin_lock(&lo->plh_inode->i_lock);\n\tif (lrp->res.lrs_present)\n\t\tpnfs_set_layout_stateid(lo, &lrp->res.stateid, true);\n\tlo->plh_block_lgets--;\n\tspin_unlock(&lo->plh_inode->i_lock);\n\tpnfs_put_layout_hdr(lrp->args.layout);\n\tkfree(calldata);\n\tdprintk(\"<-- %s\\n\", __func__);\n}\n\nstatic const struct rpc_call_ops nfs4_layoutreturn_call_ops = {\n\t.rpc_call_prepare = nfs4_layoutreturn_prepare,\n\t.rpc_call_done = nfs4_layoutreturn_done,\n\t.rpc_release = nfs4_layoutreturn_release,\n};\n\nint nfs4_proc_layoutreturn(struct nfs4_layoutreturn *lrp)\n{\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LAYOUTRETURN],\n\t\t.rpc_argp = &lrp->args,\n\t\t.rpc_resp = &lrp->res,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = lrp->clp->cl_rpcclient,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_layoutreturn_call_ops,\n\t\t.callback_data = lrp,\n\t};\n\tint status;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\tnfs41_init_sequence(&lrp->args.seq_args, &lrp->res.seq_res, 1);\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tstatus = task->tk_status;\n\tdprintk(\"<-- %s status=%d\\n\", __func__, status);\n\trpc_put_task(task);\n\treturn status;\n}\n\n/*\n * Retrieve the list of Data Server devices from the MDS.\n */\nstatic int _nfs4_getdevicelist(struct nfs_server *server,\n\t\t\t\t    const struct nfs_fh *fh,\n\t\t\t\t    struct pnfs_devicelist *devlist)\n{\n\tstruct nfs4_getdevicelist_args args = {\n\t\t.fh = fh,\n\t\t.layoutclass = server->pnfs_curr_ld->id,\n\t};\n\tstruct nfs4_getdevicelist_res res = {\n\t\t.devlist = devlist,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETDEVICELIST],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tint status;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\tstatus = nfs4_call_sync(server->client, server, &msg, &args.seq_args,\n\t\t\t\t&res.seq_res, 0);\n\tdprintk(\"<-- %s status=%d\\n\", __func__, status);\n\treturn status;\n}\n\nint nfs4_proc_getdevicelist(struct nfs_server *server,\n\t\t\t    const struct nfs_fh *fh,\n\t\t\t    struct pnfs_devicelist *devlist)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\tdo {\n\t\terr = nfs4_handle_exception(server,\n\t\t\t\t_nfs4_getdevicelist(server, fh, devlist),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\n\tdprintk(\"%s: err=%d, num_devs=%u\\n\", __func__,\n\t\terr, devlist->num_devs);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(nfs4_proc_getdevicelist);\n\nstatic int\n_nfs4_proc_getdeviceinfo(struct nfs_server *server, struct pnfs_device *pdev)\n{\n\tstruct nfs4_getdeviceinfo_args args = {\n\t\t.pdev = pdev,\n\t};\n\tstruct nfs4_getdeviceinfo_res res = {\n\t\t.pdev = pdev,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETDEVICEINFO],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tint status;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\tstatus = nfs4_call_sync(server->client, server, &msg, &args.seq_args, &res.seq_res, 0);\n\tdprintk(\"<-- %s status=%d\\n\", __func__, status);\n\n\treturn status;\n}\n\nint nfs4_proc_getdeviceinfo(struct nfs_server *server, struct pnfs_device *pdev)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\tdo {\n\t\terr = nfs4_handle_exception(server,\n\t\t\t\t\t_nfs4_proc_getdeviceinfo(server, pdev),\n\t\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(nfs4_proc_getdeviceinfo);\n\nstatic void nfs4_layoutcommit_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_layoutcommit_data *data = calldata;\n\tstruct nfs_server *server = NFS_SERVER(data->args.inode);\n\n\tif (nfs4_setup_sequence(server, &data->args.seq_args,\n\t\t\t\t&data->res.seq_res, task))\n\t\treturn;\n\trpc_call_start(task);\n}\n\nstatic void\nnfs4_layoutcommit_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_layoutcommit_data *data = calldata;\n\tstruct nfs_server *server = NFS_SERVER(data->args.inode);\n\n\tif (!nfs4_sequence_done(task, &data->res.seq_res))\n\t\treturn;\n\n\tswitch (task->tk_status) { /* Just ignore these failures */\n\tcase -NFS4ERR_DELEG_REVOKED: /* layout was recalled */\n\tcase -NFS4ERR_BADIOMODE:     /* no IOMODE_RW layout for range */\n\tcase -NFS4ERR_BADLAYOUT:     /* no layout */\n\tcase -NFS4ERR_GRACE:\t    /* loca_recalim always false */\n\t\ttask->tk_status = 0;\n\t\tbreak;\n\tcase 0:\n\t\tnfs_post_op_update_inode_force_wcc(data->args.inode,\n\t\t\t\t\t\t   data->res.fattr);\n\t\tbreak;\n\tdefault:\n\t\tif (nfs4_async_handle_error(task, server, NULL) == -EAGAIN) {\n\t\t\trpc_restart_call_prepare(task);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void nfs4_layoutcommit_release(void *calldata)\n{\n\tstruct nfs4_layoutcommit_data *data = calldata;\n\tstruct pnfs_layout_segment *lseg, *tmp;\n\tunsigned long *bitlock = &NFS_I(data->args.inode)->flags;\n\n\tpnfs_cleanup_layoutcommit(data);\n\t/* Matched by references in pnfs_set_layoutcommit */\n\tlist_for_each_entry_safe(lseg, tmp, &data->lseg_list, pls_lc_list) {\n\t\tlist_del_init(&lseg->pls_lc_list);\n\t\tif (test_and_clear_bit(NFS_LSEG_LAYOUTCOMMIT,\n\t\t\t\t       &lseg->pls_flags))\n\t\t\tpnfs_put_lseg(lseg);\n\t}\n\n\tclear_bit_unlock(NFS_INO_LAYOUTCOMMITTING, bitlock);\n\tsmp_mb__after_clear_bit();\n\twake_up_bit(bitlock, NFS_INO_LAYOUTCOMMITTING);\n\n\tput_rpccred(data->cred);\n\tkfree(data);\n}\n\nstatic const struct rpc_call_ops nfs4_layoutcommit_ops = {\n\t.rpc_call_prepare = nfs4_layoutcommit_prepare,\n\t.rpc_call_done = nfs4_layoutcommit_done,\n\t.rpc_release = nfs4_layoutcommit_release,\n};\n\nint\nnfs4_proc_layoutcommit(struct nfs4_layoutcommit_data *data, bool sync)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LAYOUTCOMMIT],\n\t\t.rpc_argp = &data->args,\n\t\t.rpc_resp = &data->res,\n\t\t.rpc_cred = data->cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.task = &data->task,\n\t\t.rpc_client = NFS_CLIENT(data->args.inode),\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_layoutcommit_ops,\n\t\t.callback_data = data,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\tstruct rpc_task *task;\n\tint status = 0;\n\n\tdprintk(\"NFS: %4d initiating layoutcommit call. sync %d \"\n\t\t\"lbw: %llu inode %lu\\n\",\n\t\tdata->task.tk_pid, sync,\n\t\tdata->args.lastbytewritten,\n\t\tdata->args.inode->i_ino);\n\n\tnfs41_init_sequence(&data->args.seq_args, &data->res.seq_res, 1);\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tif (sync == false)\n\t\tgoto out;\n\tstatus = nfs4_wait_for_completion_rpc_task(task);\n\tif (status != 0)\n\t\tgoto out;\n\tstatus = task->tk_status;\nout:\n\tdprintk(\"%s: status %d\\n\", __func__, status);\n\trpc_put_task(task);\n\treturn status;\n}\n\nstatic int\n_nfs41_proc_secinfo_no_name(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t    struct nfs_fsinfo *info, struct nfs4_secinfo_flavors *flavors)\n{\n\tstruct nfs41_secinfo_no_name_args args = {\n\t\t.style = SECINFO_STYLE_CURRENT_FH,\n\t};\n\tstruct nfs4_secinfo_res res = {\n\t\t.flavors = flavors,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SECINFO_NO_NAME],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\treturn nfs4_call_sync(server->client, server, &msg, &args.seq_args, &res.seq_res, 0);\n}\n\nstatic int\nnfs41_proc_secinfo_no_name(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t\t   struct nfs_fsinfo *info, struct nfs4_secinfo_flavors *flavors)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = _nfs41_proc_secinfo_no_name(server, fhandle, info, flavors);\n\t\tswitch (err) {\n\t\tcase 0:\n\t\tcase -NFS4ERR_WRONGSEC:\n\t\tcase -NFS4ERR_NOTSUPP:\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\terr = nfs4_handle_exception(server, err, &exception);\n\t\t}\n\t} while (exception.retry);\nout:\n\treturn err;\n}\n\nstatic int\nnfs41_find_root_sec(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t    struct nfs_fsinfo *info)\n{\n\tint err;\n\tstruct page *page;\n\trpc_authflavor_t flavor;\n\tstruct nfs4_secinfo_flavors *flavors;\n\n\tpage = alloc_page(GFP_KERNEL);\n\tif (!page) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tflavors = page_address(page);\n\terr = nfs41_proc_secinfo_no_name(server, fhandle, info, flavors);\n\n\t/*\n\t * Fall back on \"guess and check\" method if\n\t * the server doesn't support SECINFO_NO_NAME\n\t */\n\tif (err == -NFS4ERR_WRONGSEC || err == -NFS4ERR_NOTSUPP) {\n\t\terr = nfs4_find_root_sec(server, fhandle, info);\n\t\tgoto out_freepage;\n\t}\n\tif (err)\n\t\tgoto out_freepage;\n\n\tflavor = nfs_find_best_sec(flavors);\n\tif (err == 0)\n\t\terr = nfs4_lookup_root_sec(server, fhandle, info, flavor);\n\nout_freepage:\n\tput_page(page);\n\tif (err == -EACCES)\n\t\treturn -EPERM;\nout:\n\treturn err;\n}\n\nstatic int _nfs41_test_stateid(struct nfs_server *server, nfs4_stateid *stateid)\n{\n\tint status;\n\tstruct nfs41_test_stateid_args args = {\n\t\t.stateid = stateid,\n\t};\n\tstruct nfs41_test_stateid_res res;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_TEST_STATEID],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\n\tdprintk(\"NFS call  test_stateid %p\\n\", stateid);\n\tnfs41_init_sequence(&args.seq_args, &res.seq_res, 0);\n\tstatus = nfs4_call_sync_sequence(server->client, server, &msg, &args.seq_args, &res.seq_res, 1);\n\tif (status != NFS_OK) {\n\t\tdprintk(\"NFS reply test_stateid: failed, %d\\n\", status);\n\t\treturn status;\n\t}\n\tdprintk(\"NFS reply test_stateid: succeeded, %d\\n\", -res.status);\n\treturn -res.status;\n}\n\n/**\n * nfs41_test_stateid - perform a TEST_STATEID operation\n *\n * @server: server / transport on which to perform the operation\n * @stateid: state ID to test\n *\n * Returns NFS_OK if the server recognizes that \"stateid\" is valid.\n * Otherwise a negative NFS4ERR value is returned if the operation\n * failed or the state ID is not currently valid.\n */\nstatic int nfs41_test_stateid(struct nfs_server *server, nfs4_stateid *stateid)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = _nfs41_test_stateid(server, stateid);\n\t\tif (err != -NFS4ERR_DELAY)\n\t\t\tbreak;\n\t\tnfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int _nfs4_free_stateid(struct nfs_server *server, nfs4_stateid *stateid)\n{\n\tstruct nfs41_free_stateid_args args = {\n\t\t.stateid = stateid,\n\t};\n\tstruct nfs41_free_stateid_res res;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_FREE_STATEID],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tint status;\n\n\tdprintk(\"NFS call  free_stateid %p\\n\", stateid);\n\tnfs41_init_sequence(&args.seq_args, &res.seq_res, 0);\n\tstatus = nfs4_call_sync_sequence(server->client, server, &msg,\n\t\t\t\t\t &args.seq_args, &res.seq_res, 1);\n\tdprintk(\"NFS reply free_stateid: %d\\n\", status);\n\treturn status;\n}\n\n/**\n * nfs41_free_stateid - perform a FREE_STATEID operation\n *\n * @server: server / transport on which to perform the operation\n * @stateid: state ID to release\n *\n * Returns NFS_OK if the server freed \"stateid\".  Otherwise a\n * negative NFS4ERR value is returned.\n */\nstatic int nfs41_free_stateid(struct nfs_server *server, nfs4_stateid *stateid)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = _nfs4_free_stateid(server, stateid);\n\t\tif (err != -NFS4ERR_DELAY)\n\t\t\tbreak;\n\t\tnfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic bool nfs41_match_stateid(const nfs4_stateid *s1,\n\t\tconst nfs4_stateid *s2)\n{\n\tif (memcmp(s1->other, s2->other, sizeof(s1->other)) != 0)\n\t\treturn false;\n\n\tif (s1->seqid == s2->seqid)\n\t\treturn true;\n\tif (s1->seqid == 0 || s2->seqid == 0)\n\t\treturn true;\n\n\treturn false;\n}\n\n#endif /* CONFIG_NFS_V4_1 */\n\nstatic bool nfs4_match_stateid(const nfs4_stateid *s1,\n\t\tconst nfs4_stateid *s2)\n{\n\treturn nfs4_stateid_match(s1, s2);\n}\n\n\nstatic const struct nfs4_state_recovery_ops nfs40_reboot_recovery_ops = {\n\t.owner_flag_bit = NFS_OWNER_RECLAIM_REBOOT,\n\t.state_flag_bit\t= NFS_STATE_RECLAIM_REBOOT,\n\t.recover_open\t= nfs4_open_reclaim,\n\t.recover_lock\t= nfs4_lock_reclaim,\n\t.establish_clid = nfs4_init_clientid,\n\t.get_clid_cred\t= nfs4_get_setclientid_cred,\n\t.detect_trunking = nfs40_discover_server_trunking,\n};\n\n#if defined(CONFIG_NFS_V4_1)\nstatic const struct nfs4_state_recovery_ops nfs41_reboot_recovery_ops = {\n\t.owner_flag_bit = NFS_OWNER_RECLAIM_REBOOT,\n\t.state_flag_bit\t= NFS_STATE_RECLAIM_REBOOT,\n\t.recover_open\t= nfs4_open_reclaim,\n\t.recover_lock\t= nfs4_lock_reclaim,\n\t.establish_clid = nfs41_init_clientid,\n\t.get_clid_cred\t= nfs4_get_exchange_id_cred,\n\t.reclaim_complete = nfs41_proc_reclaim_complete,\n\t.detect_trunking = nfs41_discover_server_trunking,\n};\n#endif /* CONFIG_NFS_V4_1 */\n\nstatic const struct nfs4_state_recovery_ops nfs40_nograce_recovery_ops = {\n\t.owner_flag_bit = NFS_OWNER_RECLAIM_NOGRACE,\n\t.state_flag_bit\t= NFS_STATE_RECLAIM_NOGRACE,\n\t.recover_open\t= nfs4_open_expired,\n\t.recover_lock\t= nfs4_lock_expired,\n\t.establish_clid = nfs4_init_clientid,\n\t.get_clid_cred\t= nfs4_get_setclientid_cred,\n};\n\n#if defined(CONFIG_NFS_V4_1)\nstatic const struct nfs4_state_recovery_ops nfs41_nograce_recovery_ops = {\n\t.owner_flag_bit = NFS_OWNER_RECLAIM_NOGRACE,\n\t.state_flag_bit\t= NFS_STATE_RECLAIM_NOGRACE,\n\t.recover_open\t= nfs41_open_expired,\n\t.recover_lock\t= nfs41_lock_expired,\n\t.establish_clid = nfs41_init_clientid,\n\t.get_clid_cred\t= nfs4_get_exchange_id_cred,\n};\n#endif /* CONFIG_NFS_V4_1 */\n\nstatic const struct nfs4_state_maintenance_ops nfs40_state_renewal_ops = {\n\t.sched_state_renewal = nfs4_proc_async_renew,\n\t.get_state_renewal_cred_locked = nfs4_get_renew_cred_locked,\n\t.renew_lease = nfs4_proc_renew,\n};\n\n#if defined(CONFIG_NFS_V4_1)\nstatic const struct nfs4_state_maintenance_ops nfs41_state_renewal_ops = {\n\t.sched_state_renewal = nfs41_proc_async_sequence,\n\t.get_state_renewal_cred_locked = nfs4_get_machine_cred_locked,\n\t.renew_lease = nfs4_proc_sequence,\n};\n#endif\n\nstatic const struct nfs4_minor_version_ops nfs_v4_0_minor_ops = {\n\t.minor_version = 0,\n\t.call_sync = _nfs4_call_sync,\n\t.match_stateid = nfs4_match_stateid,\n\t.find_root_sec = nfs4_find_root_sec,\n\t.reboot_recovery_ops = &nfs40_reboot_recovery_ops,\n\t.nograce_recovery_ops = &nfs40_nograce_recovery_ops,\n\t.state_renewal_ops = &nfs40_state_renewal_ops,\n};\n\n#if defined(CONFIG_NFS_V4_1)\nstatic const struct nfs4_minor_version_ops nfs_v4_1_minor_ops = {\n\t.minor_version = 1,\n\t.call_sync = _nfs4_call_sync_session,\n\t.match_stateid = nfs41_match_stateid,\n\t.find_root_sec = nfs41_find_root_sec,\n\t.reboot_recovery_ops = &nfs41_reboot_recovery_ops,\n\t.nograce_recovery_ops = &nfs41_nograce_recovery_ops,\n\t.state_renewal_ops = &nfs41_state_renewal_ops,\n};\n#endif\n\nconst struct nfs4_minor_version_ops *nfs_v4_minor_ops[] = {\n\t[0] = &nfs_v4_0_minor_ops,\n#if defined(CONFIG_NFS_V4_1)\n\t[1] = &nfs_v4_1_minor_ops,\n#endif\n};\n\nconst struct inode_operations nfs4_dir_inode_operations = {\n\t.create\t\t= nfs_create,\n\t.lookup\t\t= nfs_lookup,\n\t.atomic_open\t= nfs_atomic_open,\n\t.link\t\t= nfs_link,\n\t.unlink\t\t= nfs_unlink,\n\t.symlink\t= nfs_symlink,\n\t.mkdir\t\t= nfs_mkdir,\n\t.rmdir\t\t= nfs_rmdir,\n\t.mknod\t\t= nfs_mknod,\n\t.rename\t\t= nfs_rename,\n\t.permission\t= nfs_permission,\n\t.getattr\t= nfs_getattr,\n\t.setattr\t= nfs_setattr,\n\t.getxattr\t= generic_getxattr,\n\t.setxattr\t= generic_setxattr,\n\t.listxattr\t= generic_listxattr,\n\t.removexattr\t= generic_removexattr,\n};\n\nstatic const struct inode_operations nfs4_file_inode_operations = {\n\t.permission\t= nfs_permission,\n\t.getattr\t= nfs_getattr,\n\t.setattr\t= nfs_setattr,\n\t.getxattr\t= generic_getxattr,\n\t.setxattr\t= generic_setxattr,\n\t.listxattr\t= generic_listxattr,\n\t.removexattr\t= generic_removexattr,\n};\n\nconst struct nfs_rpc_ops nfs_v4_clientops = {\n\t.version\t= 4,\t\t\t/* protocol version */\n\t.dentry_ops\t= &nfs4_dentry_operations,\n\t.dir_inode_ops\t= &nfs4_dir_inode_operations,\n\t.file_inode_ops\t= &nfs4_file_inode_operations,\n\t.file_ops\t= &nfs4_file_operations,\n\t.getroot\t= nfs4_proc_get_root,\n\t.submount\t= nfs4_submount,\n\t.try_mount\t= nfs4_try_mount,\n\t.getattr\t= nfs4_proc_getattr,\n\t.setattr\t= nfs4_proc_setattr,\n\t.lookup\t\t= nfs4_proc_lookup,\n\t.access\t\t= nfs4_proc_access,\n\t.readlink\t= nfs4_proc_readlink,\n\t.create\t\t= nfs4_proc_create,\n\t.remove\t\t= nfs4_proc_remove,\n\t.unlink_setup\t= nfs4_proc_unlink_setup,\n\t.unlink_rpc_prepare = nfs4_proc_unlink_rpc_prepare,\n\t.unlink_done\t= nfs4_proc_unlink_done,\n\t.rename\t\t= nfs4_proc_rename,\n\t.rename_setup\t= nfs4_proc_rename_setup,\n\t.rename_rpc_prepare = nfs4_proc_rename_rpc_prepare,\n\t.rename_done\t= nfs4_proc_rename_done,\n\t.link\t\t= nfs4_proc_link,\n\t.symlink\t= nfs4_proc_symlink,\n\t.mkdir\t\t= nfs4_proc_mkdir,\n\t.rmdir\t\t= nfs4_proc_remove,\n\t.readdir\t= nfs4_proc_readdir,\n\t.mknod\t\t= nfs4_proc_mknod,\n\t.statfs\t\t= nfs4_proc_statfs,\n\t.fsinfo\t\t= nfs4_proc_fsinfo,\n\t.pathconf\t= nfs4_proc_pathconf,\n\t.set_capabilities = nfs4_server_capabilities,\n\t.decode_dirent\t= nfs4_decode_dirent,\n\t.read_setup\t= nfs4_proc_read_setup,\n\t.read_pageio_init = pnfs_pageio_init_read,\n\t.read_rpc_prepare = nfs4_proc_read_rpc_prepare,\n\t.read_done\t= nfs4_read_done,\n\t.write_setup\t= nfs4_proc_write_setup,\n\t.write_pageio_init = pnfs_pageio_init_write,\n\t.write_rpc_prepare = nfs4_proc_write_rpc_prepare,\n\t.write_done\t= nfs4_write_done,\n\t.commit_setup\t= nfs4_proc_commit_setup,\n\t.commit_rpc_prepare = nfs4_proc_commit_rpc_prepare,\n\t.commit_done\t= nfs4_commit_done,\n\t.lock\t\t= nfs4_proc_lock,\n\t.clear_acl_cache = nfs4_zap_acl_attr,\n\t.close_context  = nfs4_close_context,\n\t.open_context\t= nfs4_atomic_open,\n\t.have_delegation = nfs4_have_delegation,\n\t.return_delegation = nfs4_inode_return_delegation,\n\t.alloc_client\t= nfs4_alloc_client,\n\t.init_client\t= nfs4_init_client,\n\t.free_client\t= nfs4_free_client,\n\t.create_server\t= nfs4_create_server,\n\t.clone_server\t= nfs_clone_server,\n};\n\nstatic const struct xattr_handler nfs4_xattr_nfs4_acl_handler = {\n\t.prefix\t= XATTR_NAME_NFSV4_ACL,\n\t.list\t= nfs4_xattr_list_nfs4_acl,\n\t.get\t= nfs4_xattr_get_nfs4_acl,\n\t.set\t= nfs4_xattr_set_nfs4_acl,\n};\n\nconst struct xattr_handler *nfs4_xattr_handlers[] = {\n\t&nfs4_xattr_nfs4_acl_handler,\n\tNULL\n};\n\n/*\n * Local variables:\n *  c-basic-offset: 8\n * End:\n */\n"], "fixing_code": ["/*\n *  fs/nfs/nfs4proc.c\n *\n *  Client-side procedure declarations for NFSv4.\n *\n *  Copyright (c) 2002 The Regents of the University of Michigan.\n *  All rights reserved.\n *\n *  Kendrick Smith <kmsmith@umich.edu>\n *  Andy Adamson   <andros@umich.edu>\n *\n *  Redistribution and use in source and binary forms, with or without\n *  modification, are permitted provided that the following conditions\n *  are met:\n *\n *  1. Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n *  2. Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *  3. Neither the name of the University nor the names of its\n *     contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED\n *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n *  DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n *  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <linux/mm.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/xattr.h>\n#include <linux/utsname.h>\n#include <linux/freezer.h>\n\n#include \"nfs4_fs.h\"\n#include \"delegation.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"callback.h\"\n#include \"pnfs.h\"\n#include \"netns.h\"\n\n#define NFSDBG_FACILITY\t\tNFSDBG_PROC\n\n#define NFS4_POLL_RETRY_MIN\t(HZ/10)\n#define NFS4_POLL_RETRY_MAX\t(15*HZ)\n\n#define NFS4_MAX_LOOP_ON_RECOVER (10)\n\nstruct nfs4_opendata;\nstatic int _nfs4_proc_open(struct nfs4_opendata *data);\nstatic int _nfs4_recover_proc_open(struct nfs4_opendata *data);\nstatic int nfs4_do_fsinfo(struct nfs_server *, struct nfs_fh *, struct nfs_fsinfo *);\nstatic int nfs4_async_handle_error(struct rpc_task *, const struct nfs_server *, struct nfs4_state *);\nstatic void nfs_fixup_referral_attributes(struct nfs_fattr *fattr);\nstatic int nfs4_proc_getattr(struct nfs_server *, struct nfs_fh *, struct nfs_fattr *);\nstatic int _nfs4_proc_getattr(struct nfs_server *server, struct nfs_fh *fhandle, struct nfs_fattr *fattr);\nstatic int nfs4_do_setattr(struct inode *inode, struct rpc_cred *cred,\n\t\t\t    struct nfs_fattr *fattr, struct iattr *sattr,\n\t\t\t    struct nfs4_state *state);\n#ifdef CONFIG_NFS_V4_1\nstatic int nfs41_test_stateid(struct nfs_server *, nfs4_stateid *);\nstatic int nfs41_free_stateid(struct nfs_server *, nfs4_stateid *);\n#endif\n/* Prevent leaks of NFSv4 errors into userland */\nstatic int nfs4_map_errors(int err)\n{\n\tif (err >= -1000)\n\t\treturn err;\n\tswitch (err) {\n\tcase -NFS4ERR_RESOURCE:\n\t\treturn -EREMOTEIO;\n\tcase -NFS4ERR_WRONGSEC:\n\t\treturn -EPERM;\n\tcase -NFS4ERR_BADOWNER:\n\tcase -NFS4ERR_BADNAME:\n\t\treturn -EINVAL;\n\tcase -NFS4ERR_SHARE_DENIED:\n\t\treturn -EACCES;\n\tcase -NFS4ERR_MINOR_VERS_MISMATCH:\n\t\treturn -EPROTONOSUPPORT;\n\tcase -NFS4ERR_ACCESS:\n\t\treturn -EACCES;\n\tdefault:\n\t\tdprintk(\"%s could not handle NFSv4 error %d\\n\",\n\t\t\t\t__func__, -err);\n\t\tbreak;\n\t}\n\treturn -EIO;\n}\n\n/*\n * This is our standard bitmap for GETATTR requests.\n */\nconst u32 nfs4_fattr_bitmap[3] = {\n\tFATTR4_WORD0_TYPE\n\t| FATTR4_WORD0_CHANGE\n\t| FATTR4_WORD0_SIZE\n\t| FATTR4_WORD0_FSID\n\t| FATTR4_WORD0_FILEID,\n\tFATTR4_WORD1_MODE\n\t| FATTR4_WORD1_NUMLINKS\n\t| FATTR4_WORD1_OWNER\n\t| FATTR4_WORD1_OWNER_GROUP\n\t| FATTR4_WORD1_RAWDEV\n\t| FATTR4_WORD1_SPACE_USED\n\t| FATTR4_WORD1_TIME_ACCESS\n\t| FATTR4_WORD1_TIME_METADATA\n\t| FATTR4_WORD1_TIME_MODIFY\n};\n\nstatic const u32 nfs4_pnfs_open_bitmap[3] = {\n\tFATTR4_WORD0_TYPE\n\t| FATTR4_WORD0_CHANGE\n\t| FATTR4_WORD0_SIZE\n\t| FATTR4_WORD0_FSID\n\t| FATTR4_WORD0_FILEID,\n\tFATTR4_WORD1_MODE\n\t| FATTR4_WORD1_NUMLINKS\n\t| FATTR4_WORD1_OWNER\n\t| FATTR4_WORD1_OWNER_GROUP\n\t| FATTR4_WORD1_RAWDEV\n\t| FATTR4_WORD1_SPACE_USED\n\t| FATTR4_WORD1_TIME_ACCESS\n\t| FATTR4_WORD1_TIME_METADATA\n\t| FATTR4_WORD1_TIME_MODIFY,\n\tFATTR4_WORD2_MDSTHRESHOLD\n};\n\nstatic const u32 nfs4_open_noattr_bitmap[3] = {\n\tFATTR4_WORD0_TYPE\n\t| FATTR4_WORD0_CHANGE\n\t| FATTR4_WORD0_FILEID,\n};\n\nconst u32 nfs4_statfs_bitmap[2] = {\n\tFATTR4_WORD0_FILES_AVAIL\n\t| FATTR4_WORD0_FILES_FREE\n\t| FATTR4_WORD0_FILES_TOTAL,\n\tFATTR4_WORD1_SPACE_AVAIL\n\t| FATTR4_WORD1_SPACE_FREE\n\t| FATTR4_WORD1_SPACE_TOTAL\n};\n\nconst u32 nfs4_pathconf_bitmap[2] = {\n\tFATTR4_WORD0_MAXLINK\n\t| FATTR4_WORD0_MAXNAME,\n\t0\n};\n\nconst u32 nfs4_fsinfo_bitmap[3] = { FATTR4_WORD0_MAXFILESIZE\n\t\t\t| FATTR4_WORD0_MAXREAD\n\t\t\t| FATTR4_WORD0_MAXWRITE\n\t\t\t| FATTR4_WORD0_LEASE_TIME,\n\t\t\tFATTR4_WORD1_TIME_DELTA\n\t\t\t| FATTR4_WORD1_FS_LAYOUT_TYPES,\n\t\t\tFATTR4_WORD2_LAYOUT_BLKSIZE\n};\n\nconst u32 nfs4_fs_locations_bitmap[2] = {\n\tFATTR4_WORD0_TYPE\n\t| FATTR4_WORD0_CHANGE\n\t| FATTR4_WORD0_SIZE\n\t| FATTR4_WORD0_FSID\n\t| FATTR4_WORD0_FILEID\n\t| FATTR4_WORD0_FS_LOCATIONS,\n\tFATTR4_WORD1_MODE\n\t| FATTR4_WORD1_NUMLINKS\n\t| FATTR4_WORD1_OWNER\n\t| FATTR4_WORD1_OWNER_GROUP\n\t| FATTR4_WORD1_RAWDEV\n\t| FATTR4_WORD1_SPACE_USED\n\t| FATTR4_WORD1_TIME_ACCESS\n\t| FATTR4_WORD1_TIME_METADATA\n\t| FATTR4_WORD1_TIME_MODIFY\n\t| FATTR4_WORD1_MOUNTED_ON_FILEID\n};\n\nstatic void nfs4_setup_readdir(u64 cookie, __be32 *verifier, struct dentry *dentry,\n\t\tstruct nfs4_readdir_arg *readdir)\n{\n\t__be32 *start, *p;\n\n\tBUG_ON(readdir->count < 80);\n\tif (cookie > 2) {\n\t\treaddir->cookie = cookie;\n\t\tmemcpy(&readdir->verifier, verifier, sizeof(readdir->verifier));\n\t\treturn;\n\t}\n\n\treaddir->cookie = 0;\n\tmemset(&readdir->verifier, 0, sizeof(readdir->verifier));\n\tif (cookie == 2)\n\t\treturn;\n\t\n\t/*\n\t * NFSv4 servers do not return entries for '.' and '..'\n\t * Therefore, we fake these entries here.  We let '.'\n\t * have cookie 0 and '..' have cookie 1.  Note that\n\t * when talking to the server, we always send cookie 0\n\t * instead of 1 or 2.\n\t */\n\tstart = p = kmap_atomic(*readdir->pages);\n\t\n\tif (cookie == 0) {\n\t\t*p++ = xdr_one;                                  /* next */\n\t\t*p++ = xdr_zero;                   /* cookie, first word */\n\t\t*p++ = xdr_one;                   /* cookie, second word */\n\t\t*p++ = xdr_one;                             /* entry len */\n\t\tmemcpy(p, \".\\0\\0\\0\", 4);                        /* entry */\n\t\tp++;\n\t\t*p++ = xdr_one;                         /* bitmap length */\n\t\t*p++ = htonl(FATTR4_WORD0_FILEID);             /* bitmap */\n\t\t*p++ = htonl(8);              /* attribute buffer length */\n\t\tp = xdr_encode_hyper(p, NFS_FILEID(dentry->d_inode));\n\t}\n\t\n\t*p++ = xdr_one;                                  /* next */\n\t*p++ = xdr_zero;                   /* cookie, first word */\n\t*p++ = xdr_two;                   /* cookie, second word */\n\t*p++ = xdr_two;                             /* entry len */\n\tmemcpy(p, \"..\\0\\0\", 4);                         /* entry */\n\tp++;\n\t*p++ = xdr_one;                         /* bitmap length */\n\t*p++ = htonl(FATTR4_WORD0_FILEID);             /* bitmap */\n\t*p++ = htonl(8);              /* attribute buffer length */\n\tp = xdr_encode_hyper(p, NFS_FILEID(dentry->d_parent->d_inode));\n\n\treaddir->pgbase = (char *)p - (char *)start;\n\treaddir->count -= readdir->pgbase;\n\tkunmap_atomic(start);\n}\n\nstatic int nfs4_wait_clnt_recover(struct nfs_client *clp)\n{\n\tint res;\n\n\tmight_sleep();\n\n\tres = wait_on_bit(&clp->cl_state, NFS4CLNT_MANAGER_RUNNING,\n\t\t\tnfs_wait_bit_killable, TASK_KILLABLE);\n\tif (res)\n\t\treturn res;\n\n\tif (clp->cl_cons_state < 0)\n\t\treturn clp->cl_cons_state;\n\treturn 0;\n}\n\nstatic int nfs4_delay(struct rpc_clnt *clnt, long *timeout)\n{\n\tint res = 0;\n\n\tmight_sleep();\n\n\tif (*timeout <= 0)\n\t\t*timeout = NFS4_POLL_RETRY_MIN;\n\tif (*timeout > NFS4_POLL_RETRY_MAX)\n\t\t*timeout = NFS4_POLL_RETRY_MAX;\n\tfreezable_schedule_timeout_killable(*timeout);\n\tif (fatal_signal_pending(current))\n\t\tres = -ERESTARTSYS;\n\t*timeout <<= 1;\n\treturn res;\n}\n\n/* This is the error handling routine for processes that are allowed\n * to sleep.\n */\nstatic int nfs4_handle_exception(struct nfs_server *server, int errorcode, struct nfs4_exception *exception)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs4_state *state = exception->state;\n\tstruct inode *inode = exception->inode;\n\tint ret = errorcode;\n\n\texception->retry = 0;\n\tswitch(errorcode) {\n\t\tcase 0:\n\t\t\treturn 0;\n\t\tcase -NFS4ERR_OPENMODE:\n\t\t\tif (inode && nfs4_have_delegation(inode, FMODE_READ)) {\n\t\t\t\tnfs4_inode_return_delegation(inode);\n\t\t\t\texception->retry = 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (state == NULL)\n\t\t\t\tbreak;\n\t\t\tnfs4_schedule_stateid_recovery(server, state);\n\t\t\tgoto wait_on_recovery;\n\t\tcase -NFS4ERR_DELEG_REVOKED:\n\t\tcase -NFS4ERR_ADMIN_REVOKED:\n\t\tcase -NFS4ERR_BAD_STATEID:\n\t\t\tif (state == NULL)\n\t\t\t\tbreak;\n\t\t\tnfs_remove_bad_delegation(state->inode);\n\t\t\tnfs4_schedule_stateid_recovery(server, state);\n\t\t\tgoto wait_on_recovery;\n\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tif (state != NULL)\n\t\t\t\tnfs4_schedule_stateid_recovery(server, state);\n\t\tcase -NFS4ERR_STALE_STATEID:\n\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\t\tnfs4_schedule_lease_recovery(clp);\n\t\t\tgoto wait_on_recovery;\n#if defined(CONFIG_NFS_V4_1)\n\t\tcase -NFS4ERR_BADSESSION:\n\t\tcase -NFS4ERR_BADSLOT:\n\t\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\t\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\tcase -NFS4ERR_DEADSESSION:\n\t\tcase -NFS4ERR_SEQ_FALSE_RETRY:\n\t\tcase -NFS4ERR_SEQ_MISORDERED:\n\t\t\tdprintk(\"%s ERROR: %d Reset session\\n\", __func__,\n\t\t\t\terrorcode);\n\t\t\tnfs4_schedule_session_recovery(clp->cl_session, errorcode);\n\t\t\tgoto wait_on_recovery;\n#endif /* defined(CONFIG_NFS_V4_1) */\n\t\tcase -NFS4ERR_FILE_OPEN:\n\t\t\tif (exception->timeout > HZ) {\n\t\t\t\t/* We have retried a decent amount, time to\n\t\t\t\t * fail\n\t\t\t\t */\n\t\t\t\tret = -EBUSY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase -NFS4ERR_GRACE:\n\t\tcase -NFS4ERR_DELAY:\n\t\tcase -EKEYEXPIRED:\n\t\t\tret = nfs4_delay(server->client, &exception->timeout);\n\t\t\tif (ret != 0)\n\t\t\t\tbreak;\n\t\tcase -NFS4ERR_RETRY_UNCACHED_REP:\n\t\tcase -NFS4ERR_OLD_STATEID:\n\t\t\texception->retry = 1;\n\t\t\tbreak;\n\t\tcase -NFS4ERR_BADOWNER:\n\t\t\t/* The following works around a Linux server bug! */\n\t\tcase -NFS4ERR_BADNAME:\n\t\t\tif (server->caps & NFS_CAP_UIDGID_NOMAP) {\n\t\t\t\tserver->caps &= ~NFS_CAP_UIDGID_NOMAP;\n\t\t\t\texception->retry = 1;\n\t\t\t\tprintk(KERN_WARNING \"NFS: v4 server %s \"\n\t\t\t\t\t\t\"does not accept raw \"\n\t\t\t\t\t\t\"uid/gids. \"\n\t\t\t\t\t\t\"Reenabling the idmapper.\\n\",\n\t\t\t\t\t\tserver->nfs_client->cl_hostname);\n\t\t\t}\n\t}\n\t/* We failed to handle the error */\n\treturn nfs4_map_errors(ret);\nwait_on_recovery:\n\tret = nfs4_wait_clnt_recover(clp);\n\tif (ret == 0)\n\t\texception->retry = 1;\n\treturn ret;\n}\n\n\nstatic void do_renew_lease(struct nfs_client *clp, unsigned long timestamp)\n{\n\tspin_lock(&clp->cl_lock);\n\tif (time_before(clp->cl_last_renewal,timestamp))\n\t\tclp->cl_last_renewal = timestamp;\n\tspin_unlock(&clp->cl_lock);\n}\n\nstatic void renew_lease(const struct nfs_server *server, unsigned long timestamp)\n{\n\tdo_renew_lease(server->nfs_client, timestamp);\n}\n\n#if defined(CONFIG_NFS_V4_1)\n\n/*\n * nfs4_free_slot - free a slot and efficiently update slot table.\n *\n * freeing a slot is trivially done by clearing its respective bit\n * in the bitmap.\n * If the freed slotid equals highest_used_slotid we want to update it\n * so that the server would be able to size down the slot table if needed,\n * otherwise we know that the highest_used_slotid is still in use.\n * When updating highest_used_slotid there may be \"holes\" in the bitmap\n * so we need to scan down from highest_used_slotid to 0 looking for the now\n * highest slotid in use.\n * If none found, highest_used_slotid is set to NFS4_NO_SLOT.\n *\n * Must be called while holding tbl->slot_tbl_lock\n */\nstatic void\nnfs4_free_slot(struct nfs4_slot_table *tbl, u32 slotid)\n{\n\tBUG_ON(slotid >= NFS4_MAX_SLOT_TABLE);\n\t/* clear used bit in bitmap */\n\t__clear_bit(slotid, tbl->used_slots);\n\n\t/* update highest_used_slotid when it is freed */\n\tif (slotid == tbl->highest_used_slotid) {\n\t\tslotid = find_last_bit(tbl->used_slots, tbl->max_slots);\n\t\tif (slotid < tbl->max_slots)\n\t\t\ttbl->highest_used_slotid = slotid;\n\t\telse\n\t\t\ttbl->highest_used_slotid = NFS4_NO_SLOT;\n\t}\n\tdprintk(\"%s: slotid %u highest_used_slotid %d\\n\", __func__,\n\t\tslotid, tbl->highest_used_slotid);\n}\n\nbool nfs4_set_task_privileged(struct rpc_task *task, void *dummy)\n{\n\trpc_task_set_priority(task, RPC_PRIORITY_PRIVILEGED);\n\treturn true;\n}\n\n/*\n * Signal state manager thread if session fore channel is drained\n */\nstatic void nfs4_check_drain_fc_complete(struct nfs4_session *ses)\n{\n\tif (!test_bit(NFS4_SESSION_DRAINING, &ses->session_state)) {\n\t\trpc_wake_up_first(&ses->fc_slot_table.slot_tbl_waitq,\n\t\t\t\tnfs4_set_task_privileged, NULL);\n\t\treturn;\n\t}\n\n\tif (ses->fc_slot_table.highest_used_slotid != NFS4_NO_SLOT)\n\t\treturn;\n\n\tdprintk(\"%s COMPLETE: Session Fore Channel Drained\\n\", __func__);\n\tcomplete(&ses->fc_slot_table.complete);\n}\n\n/*\n * Signal state manager thread if session back channel is drained\n */\nvoid nfs4_check_drain_bc_complete(struct nfs4_session *ses)\n{\n\tif (!test_bit(NFS4_SESSION_DRAINING, &ses->session_state) ||\n\t    ses->bc_slot_table.highest_used_slotid != NFS4_NO_SLOT)\n\t\treturn;\n\tdprintk(\"%s COMPLETE: Session Back Channel Drained\\n\", __func__);\n\tcomplete(&ses->bc_slot_table.complete);\n}\n\nstatic void nfs41_sequence_free_slot(struct nfs4_sequence_res *res)\n{\n\tstruct nfs4_slot_table *tbl;\n\n\ttbl = &res->sr_session->fc_slot_table;\n\tif (!res->sr_slot) {\n\t\t/* just wake up the next guy waiting since\n\t\t * we may have not consumed a slot after all */\n\t\tdprintk(\"%s: No slot\\n\", __func__);\n\t\treturn;\n\t}\n\n\tspin_lock(&tbl->slot_tbl_lock);\n\tnfs4_free_slot(tbl, res->sr_slot - tbl->slots);\n\tnfs4_check_drain_fc_complete(res->sr_session);\n\tspin_unlock(&tbl->slot_tbl_lock);\n\tres->sr_slot = NULL;\n}\n\nstatic int nfs41_sequence_done(struct rpc_task *task, struct nfs4_sequence_res *res)\n{\n\tunsigned long timestamp;\n\tstruct nfs_client *clp;\n\n\t/*\n\t * sr_status remains 1 if an RPC level error occurred. The server\n\t * may or may not have processed the sequence operation..\n\t * Proceed as if the server received and processed the sequence\n\t * operation.\n\t */\n\tif (res->sr_status == 1)\n\t\tres->sr_status = NFS_OK;\n\n\t/* don't increment the sequence number if the task wasn't sent */\n\tif (!RPC_WAS_SENT(task))\n\t\tgoto out;\n\n\t/* Check the SEQUENCE operation status */\n\tswitch (res->sr_status) {\n\tcase 0:\n\t\t/* Update the slot's sequence and clientid lease timer */\n\t\t++res->sr_slot->seq_nr;\n\t\ttimestamp = res->sr_renewal_time;\n\t\tclp = res->sr_session->clp;\n\t\tdo_renew_lease(clp, timestamp);\n\t\t/* Check sequence flags */\n\t\tif (res->sr_status_flags != 0)\n\t\t\tnfs4_schedule_lease_recovery(clp);\n\t\tbreak;\n\tcase -NFS4ERR_DELAY:\n\t\t/* The server detected a resend of the RPC call and\n\t\t * returned NFS4ERR_DELAY as per Section 2.10.6.2\n\t\t * of RFC5661.\n\t\t */\n\t\tdprintk(\"%s: slot=%td seq=%d: Operation in progress\\n\",\n\t\t\t__func__,\n\t\t\tres->sr_slot - res->sr_session->fc_slot_table.slots,\n\t\t\tres->sr_slot->seq_nr);\n\t\tgoto out_retry;\n\tdefault:\n\t\t/* Just update the slot sequence no. */\n\t\t++res->sr_slot->seq_nr;\n\t}\nout:\n\t/* The session may be reset by one of the error handlers. */\n\tdprintk(\"%s: Error %d free the slot \\n\", __func__, res->sr_status);\n\tnfs41_sequence_free_slot(res);\n\treturn 1;\nout_retry:\n\tif (!rpc_restart_call(task))\n\t\tgoto out;\n\trpc_delay(task, NFS4_POLL_RETRY_MAX);\n\treturn 0;\n}\n\nstatic int nfs4_sequence_done(struct rpc_task *task,\n\t\t\t       struct nfs4_sequence_res *res)\n{\n\tif (res->sr_session == NULL)\n\t\treturn 1;\n\treturn nfs41_sequence_done(task, res);\n}\n\n/*\n * nfs4_find_slot - efficiently look for a free slot\n *\n * nfs4_find_slot looks for an unset bit in the used_slots bitmap.\n * If found, we mark the slot as used, update the highest_used_slotid,\n * and respectively set up the sequence operation args.\n * The slot number is returned if found, or NFS4_NO_SLOT otherwise.\n *\n * Note: must be called with under the slot_tbl_lock.\n */\nstatic u32\nnfs4_find_slot(struct nfs4_slot_table *tbl)\n{\n\tu32 slotid;\n\tu32 ret_id = NFS4_NO_SLOT;\n\n\tdprintk(\"--> %s used_slots=%04lx highest_used=%u max_slots=%u\\n\",\n\t\t__func__, tbl->used_slots[0], tbl->highest_used_slotid,\n\t\ttbl->max_slots);\n\tslotid = find_first_zero_bit(tbl->used_slots, tbl->max_slots);\n\tif (slotid >= tbl->max_slots)\n\t\tgoto out;\n\t__set_bit(slotid, tbl->used_slots);\n\tif (slotid > tbl->highest_used_slotid ||\n\t\t\ttbl->highest_used_slotid == NFS4_NO_SLOT)\n\t\ttbl->highest_used_slotid = slotid;\n\tret_id = slotid;\nout:\n\tdprintk(\"<-- %s used_slots=%04lx highest_used=%d slotid=%d \\n\",\n\t\t__func__, tbl->used_slots[0], tbl->highest_used_slotid, ret_id);\n\treturn ret_id;\n}\n\nstatic void nfs41_init_sequence(struct nfs4_sequence_args *args,\n\t\tstruct nfs4_sequence_res *res, int cache_reply)\n{\n\targs->sa_session = NULL;\n\targs->sa_cache_this = 0;\n\tif (cache_reply)\n\t\targs->sa_cache_this = 1;\n\tres->sr_session = NULL;\n\tres->sr_slot = NULL;\n}\n\nint nfs41_setup_sequence(struct nfs4_session *session,\n\t\t\t\tstruct nfs4_sequence_args *args,\n\t\t\t\tstruct nfs4_sequence_res *res,\n\t\t\t\tstruct rpc_task *task)\n{\n\tstruct nfs4_slot *slot;\n\tstruct nfs4_slot_table *tbl;\n\tu32 slotid;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\t/* slot already allocated? */\n\tif (res->sr_slot != NULL)\n\t\treturn 0;\n\n\ttbl = &session->fc_slot_table;\n\n\tspin_lock(&tbl->slot_tbl_lock);\n\tif (test_bit(NFS4_SESSION_DRAINING, &session->session_state) &&\n\t    !rpc_task_has_priority(task, RPC_PRIORITY_PRIVILEGED)) {\n\t\t/* The state manager will wait until the slot table is empty */\n\t\trpc_sleep_on(&tbl->slot_tbl_waitq, task, NULL);\n\t\tspin_unlock(&tbl->slot_tbl_lock);\n\t\tdprintk(\"%s session is draining\\n\", __func__);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (!rpc_queue_empty(&tbl->slot_tbl_waitq) &&\n\t    !rpc_task_has_priority(task, RPC_PRIORITY_PRIVILEGED)) {\n\t\trpc_sleep_on(&tbl->slot_tbl_waitq, task, NULL);\n\t\tspin_unlock(&tbl->slot_tbl_lock);\n\t\tdprintk(\"%s enforce FIFO order\\n\", __func__);\n\t\treturn -EAGAIN;\n\t}\n\n\tslotid = nfs4_find_slot(tbl);\n\tif (slotid == NFS4_NO_SLOT) {\n\t\trpc_sleep_on(&tbl->slot_tbl_waitq, task, NULL);\n\t\tspin_unlock(&tbl->slot_tbl_lock);\n\t\tdprintk(\"<-- %s: no free slots\\n\", __func__);\n\t\treturn -EAGAIN;\n\t}\n\tspin_unlock(&tbl->slot_tbl_lock);\n\n\trpc_task_set_priority(task, RPC_PRIORITY_NORMAL);\n\tslot = tbl->slots + slotid;\n\targs->sa_session = session;\n\targs->sa_slotid = slotid;\n\n\tdprintk(\"<-- %s slotid=%d seqid=%d\\n\", __func__, slotid, slot->seq_nr);\n\n\tres->sr_session = session;\n\tres->sr_slot = slot;\n\tres->sr_renewal_time = jiffies;\n\tres->sr_status_flags = 0;\n\t/*\n\t * sr_status is only set in decode_sequence, and so will remain\n\t * set to 1 if an rpc level failure occurs.\n\t */\n\tres->sr_status = 1;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nfs41_setup_sequence);\n\nint nfs4_setup_sequence(const struct nfs_server *server,\n\t\t\tstruct nfs4_sequence_args *args,\n\t\t\tstruct nfs4_sequence_res *res,\n\t\t\tstruct rpc_task *task)\n{\n\tstruct nfs4_session *session = nfs4_get_session(server);\n\tint ret = 0;\n\n\tif (session == NULL)\n\t\tgoto out;\n\n\tdprintk(\"--> %s clp %p session %p sr_slot %td\\n\",\n\t\t__func__, session->clp, session, res->sr_slot ?\n\t\t\tres->sr_slot - session->fc_slot_table.slots : -1);\n\n\tret = nfs41_setup_sequence(session, args, res, task);\nout:\n\tdprintk(\"<-- %s status=%d\\n\", __func__, ret);\n\treturn ret;\n}\n\nstruct nfs41_call_sync_data {\n\tconst struct nfs_server *seq_server;\n\tstruct nfs4_sequence_args *seq_args;\n\tstruct nfs4_sequence_res *seq_res;\n};\n\nstatic void nfs41_call_sync_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs41_call_sync_data *data = calldata;\n\n\tdprintk(\"--> %s data->seq_server %p\\n\", __func__, data->seq_server);\n\n\tif (nfs4_setup_sequence(data->seq_server, data->seq_args,\n\t\t\t\tdata->seq_res, task))\n\t\treturn;\n\trpc_call_start(task);\n}\n\nstatic void nfs41_call_priv_sync_prepare(struct rpc_task *task, void *calldata)\n{\n\trpc_task_set_priority(task, RPC_PRIORITY_PRIVILEGED);\n\tnfs41_call_sync_prepare(task, calldata);\n}\n\nstatic void nfs41_call_sync_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs41_call_sync_data *data = calldata;\n\n\tnfs41_sequence_done(task, data->seq_res);\n}\n\nstatic const struct rpc_call_ops nfs41_call_sync_ops = {\n\t.rpc_call_prepare = nfs41_call_sync_prepare,\n\t.rpc_call_done = nfs41_call_sync_done,\n};\n\nstatic const struct rpc_call_ops nfs41_call_priv_sync_ops = {\n\t.rpc_call_prepare = nfs41_call_priv_sync_prepare,\n\t.rpc_call_done = nfs41_call_sync_done,\n};\n\nstatic int nfs4_call_sync_sequence(struct rpc_clnt *clnt,\n\t\t\t\t   struct nfs_server *server,\n\t\t\t\t   struct rpc_message *msg,\n\t\t\t\t   struct nfs4_sequence_args *args,\n\t\t\t\t   struct nfs4_sequence_res *res,\n\t\t\t\t   int privileged)\n{\n\tint ret;\n\tstruct rpc_task *task;\n\tstruct nfs41_call_sync_data data = {\n\t\t.seq_server = server,\n\t\t.seq_args = args,\n\t\t.seq_res = res,\n\t};\n\tstruct rpc_task_setup task_setup = {\n\t\t.rpc_client = clnt,\n\t\t.rpc_message = msg,\n\t\t.callback_ops = &nfs41_call_sync_ops,\n\t\t.callback_data = &data\n\t};\n\n\tif (privileged)\n\t\ttask_setup.callback_ops = &nfs41_call_priv_sync_ops;\n\ttask = rpc_run_task(&task_setup);\n\tif (IS_ERR(task))\n\t\tret = PTR_ERR(task);\n\telse {\n\t\tret = task->tk_status;\n\t\trpc_put_task(task);\n\t}\n\treturn ret;\n}\n\nint _nfs4_call_sync_session(struct rpc_clnt *clnt,\n\t\t\t    struct nfs_server *server,\n\t\t\t    struct rpc_message *msg,\n\t\t\t    struct nfs4_sequence_args *args,\n\t\t\t    struct nfs4_sequence_res *res,\n\t\t\t    int cache_reply)\n{\n\tnfs41_init_sequence(args, res, cache_reply);\n\treturn nfs4_call_sync_sequence(clnt, server, msg, args, res, 0);\n}\n\n#else\nstatic inline\nvoid nfs41_init_sequence(struct nfs4_sequence_args *args,\n\t\tstruct nfs4_sequence_res *res, int cache_reply)\n{\n}\n\nstatic int nfs4_sequence_done(struct rpc_task *task,\n\t\t\t       struct nfs4_sequence_res *res)\n{\n\treturn 1;\n}\n#endif /* CONFIG_NFS_V4_1 */\n\nint _nfs4_call_sync(struct rpc_clnt *clnt,\n\t\t    struct nfs_server *server,\n\t\t    struct rpc_message *msg,\n\t\t    struct nfs4_sequence_args *args,\n\t\t    struct nfs4_sequence_res *res,\n\t\t    int cache_reply)\n{\n\tnfs41_init_sequence(args, res, cache_reply);\n\treturn rpc_call_sync(clnt, msg, 0);\n}\n\nstatic inline\nint nfs4_call_sync(struct rpc_clnt *clnt,\n\t\t   struct nfs_server *server,\n\t\t   struct rpc_message *msg,\n\t\t   struct nfs4_sequence_args *args,\n\t\t   struct nfs4_sequence_res *res,\n\t\t   int cache_reply)\n{\n\treturn server->nfs_client->cl_mvops->call_sync(clnt, server, msg,\n\t\t\t\t\t\targs, res, cache_reply);\n}\n\nstatic void update_changeattr(struct inode *dir, struct nfs4_change_info *cinfo)\n{\n\tstruct nfs_inode *nfsi = NFS_I(dir);\n\n\tspin_lock(&dir->i_lock);\n\tnfsi->cache_validity |= NFS_INO_INVALID_ATTR|NFS_INO_INVALID_DATA;\n\tif (!cinfo->atomic || cinfo->before != dir->i_version)\n\t\tnfs_force_lookup_revalidate(dir);\n\tdir->i_version = cinfo->after;\n\tspin_unlock(&dir->i_lock);\n}\n\nstruct nfs4_opendata {\n\tstruct kref kref;\n\tstruct nfs_openargs o_arg;\n\tstruct nfs_openres o_res;\n\tstruct nfs_open_confirmargs c_arg;\n\tstruct nfs_open_confirmres c_res;\n\tstruct nfs4_string owner_name;\n\tstruct nfs4_string group_name;\n\tstruct nfs_fattr f_attr;\n\tstruct dentry *dir;\n\tstruct dentry *dentry;\n\tstruct nfs4_state_owner *owner;\n\tstruct nfs4_state *state;\n\tstruct iattr attrs;\n\tunsigned long timestamp;\n\tunsigned int rpc_done : 1;\n\tint rpc_status;\n\tint cancelled;\n};\n\n\nstatic void nfs4_init_opendata_res(struct nfs4_opendata *p)\n{\n\tp->o_res.f_attr = &p->f_attr;\n\tp->o_res.seqid = p->o_arg.seqid;\n\tp->c_res.seqid = p->c_arg.seqid;\n\tp->o_res.server = p->o_arg.server;\n\tp->o_res.access_request = p->o_arg.access;\n\tnfs_fattr_init(&p->f_attr);\n\tnfs_fattr_init_names(&p->f_attr, &p->owner_name, &p->group_name);\n}\n\nstatic struct nfs4_opendata *nfs4_opendata_alloc(struct dentry *dentry,\n\t\tstruct nfs4_state_owner *sp, fmode_t fmode, int flags,\n\t\tconst struct iattr *attrs,\n\t\tgfp_t gfp_mask)\n{\n\tstruct dentry *parent = dget_parent(dentry);\n\tstruct inode *dir = parent->d_inode;\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tstruct nfs4_opendata *p;\n\n\tp = kzalloc(sizeof(*p), gfp_mask);\n\tif (p == NULL)\n\t\tgoto err;\n\tp->o_arg.seqid = nfs_alloc_seqid(&sp->so_seqid, gfp_mask);\n\tif (p->o_arg.seqid == NULL)\n\t\tgoto err_free;\n\tnfs_sb_active(dentry->d_sb);\n\tp->dentry = dget(dentry);\n\tp->dir = parent;\n\tp->owner = sp;\n\tatomic_inc(&sp->so_count);\n\tp->o_arg.fh = NFS_FH(dir);\n\tp->o_arg.open_flags = flags;\n\tp->o_arg.fmode = fmode & (FMODE_READ|FMODE_WRITE);\n\t/* don't put an ACCESS op in OPEN compound if O_EXCL, because ACCESS\n\t * will return permission denied for all bits until close */\n\tif (!(flags & O_EXCL)) {\n\t\t/* ask server to check for all possible rights as results\n\t\t * are cached */\n\t\tp->o_arg.access = NFS4_ACCESS_READ | NFS4_ACCESS_MODIFY |\n\t\t\t\t  NFS4_ACCESS_EXTEND | NFS4_ACCESS_EXECUTE;\n\t}\n\tp->o_arg.clientid = server->nfs_client->cl_clientid;\n\tp->o_arg.id.create_time = ktime_to_ns(sp->so_seqid.create_time);\n\tp->o_arg.id.uniquifier = sp->so_seqid.owner_id;\n\tp->o_arg.name = &dentry->d_name;\n\tp->o_arg.server = server;\n\tp->o_arg.bitmask = server->attr_bitmask;\n\tp->o_arg.open_bitmap = &nfs4_fattr_bitmap[0];\n\tp->o_arg.claim = NFS4_OPEN_CLAIM_NULL;\n\tif (attrs != NULL && attrs->ia_valid != 0) {\n\t\t__be32 verf[2];\n\n\t\tp->o_arg.u.attrs = &p->attrs;\n\t\tmemcpy(&p->attrs, attrs, sizeof(p->attrs));\n\n\t\tverf[0] = jiffies;\n\t\tverf[1] = current->pid;\n\t\tmemcpy(p->o_arg.u.verifier.data, verf,\n\t\t\t\tsizeof(p->o_arg.u.verifier.data));\n\t}\n\tp->c_arg.fh = &p->o_res.fh;\n\tp->c_arg.stateid = &p->o_res.stateid;\n\tp->c_arg.seqid = p->o_arg.seqid;\n\tnfs4_init_opendata_res(p);\n\tkref_init(&p->kref);\n\treturn p;\nerr_free:\n\tkfree(p);\nerr:\n\tdput(parent);\n\treturn NULL;\n}\n\nstatic void nfs4_opendata_free(struct kref *kref)\n{\n\tstruct nfs4_opendata *p = container_of(kref,\n\t\t\tstruct nfs4_opendata, kref);\n\tstruct super_block *sb = p->dentry->d_sb;\n\n\tnfs_free_seqid(p->o_arg.seqid);\n\tif (p->state != NULL)\n\t\tnfs4_put_open_state(p->state);\n\tnfs4_put_state_owner(p->owner);\n\tdput(p->dir);\n\tdput(p->dentry);\n\tnfs_sb_deactive(sb);\n\tnfs_fattr_free_names(&p->f_attr);\n\tkfree(p);\n}\n\nstatic void nfs4_opendata_put(struct nfs4_opendata *p)\n{\n\tif (p != NULL)\n\t\tkref_put(&p->kref, nfs4_opendata_free);\n}\n\nstatic int nfs4_wait_for_completion_rpc_task(struct rpc_task *task)\n{\n\tint ret;\n\n\tret = rpc_wait_for_completion_task(task);\n\treturn ret;\n}\n\nstatic int can_open_cached(struct nfs4_state *state, fmode_t mode, int open_mode)\n{\n\tint ret = 0;\n\n\tif (open_mode & (O_EXCL|O_TRUNC))\n\t\tgoto out;\n\tswitch (mode & (FMODE_READ|FMODE_WRITE)) {\n\t\tcase FMODE_READ:\n\t\t\tret |= test_bit(NFS_O_RDONLY_STATE, &state->flags) != 0\n\t\t\t\t&& state->n_rdonly != 0;\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tret |= test_bit(NFS_O_WRONLY_STATE, &state->flags) != 0\n\t\t\t\t&& state->n_wronly != 0;\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tret |= test_bit(NFS_O_RDWR_STATE, &state->flags) != 0\n\t\t\t\t&& state->n_rdwr != 0;\n\t}\nout:\n\treturn ret;\n}\n\nstatic int can_open_delegated(struct nfs_delegation *delegation, fmode_t fmode)\n{\n\tif (delegation == NULL)\n\t\treturn 0;\n\tif ((delegation->type & fmode) != fmode)\n\t\treturn 0;\n\tif (test_bit(NFS_DELEGATION_NEED_RECLAIM, &delegation->flags))\n\t\treturn 0;\n\tnfs_mark_delegation_referenced(delegation);\n\treturn 1;\n}\n\nstatic void update_open_stateflags(struct nfs4_state *state, fmode_t fmode)\n{\n\tswitch (fmode) {\n\t\tcase FMODE_WRITE:\n\t\t\tstate->n_wronly++;\n\t\t\tbreak;\n\t\tcase FMODE_READ:\n\t\t\tstate->n_rdonly++;\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tstate->n_rdwr++;\n\t}\n\tnfs4_state_set_mode_locked(state, state->state | fmode);\n}\n\nstatic void nfs_set_open_stateid_locked(struct nfs4_state *state, nfs4_stateid *stateid, fmode_t fmode)\n{\n\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) == 0)\n\t\tnfs4_stateid_copy(&state->stateid, stateid);\n\tnfs4_stateid_copy(&state->open_stateid, stateid);\n\tswitch (fmode) {\n\t\tcase FMODE_READ:\n\t\t\tset_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tset_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tset_bit(NFS_O_RDWR_STATE, &state->flags);\n\t}\n}\n\nstatic void nfs_set_open_stateid(struct nfs4_state *state, nfs4_stateid *stateid, fmode_t fmode)\n{\n\twrite_seqlock(&state->seqlock);\n\tnfs_set_open_stateid_locked(state, stateid, fmode);\n\twrite_sequnlock(&state->seqlock);\n}\n\nstatic void __update_open_stateid(struct nfs4_state *state, nfs4_stateid *open_stateid, const nfs4_stateid *deleg_stateid, fmode_t fmode)\n{\n\t/*\n\t * Protect the call to nfs4_state_set_mode_locked and\n\t * serialise the stateid update\n\t */\n\twrite_seqlock(&state->seqlock);\n\tif (deleg_stateid != NULL) {\n\t\tnfs4_stateid_copy(&state->stateid, deleg_stateid);\n\t\tset_bit(NFS_DELEGATED_STATE, &state->flags);\n\t}\n\tif (open_stateid != NULL)\n\t\tnfs_set_open_stateid_locked(state, open_stateid, fmode);\n\twrite_sequnlock(&state->seqlock);\n\tspin_lock(&state->owner->so_lock);\n\tupdate_open_stateflags(state, fmode);\n\tspin_unlock(&state->owner->so_lock);\n}\n\nstatic int update_open_stateid(struct nfs4_state *state, nfs4_stateid *open_stateid, nfs4_stateid *delegation, fmode_t fmode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(state->inode);\n\tstruct nfs_delegation *deleg_cur;\n\tint ret = 0;\n\n\tfmode &= (FMODE_READ|FMODE_WRITE);\n\n\trcu_read_lock();\n\tdeleg_cur = rcu_dereference(nfsi->delegation);\n\tif (deleg_cur == NULL)\n\t\tgoto no_delegation;\n\n\tspin_lock(&deleg_cur->lock);\n\tif (nfsi->delegation != deleg_cur ||\n\t    (deleg_cur->type & fmode) != fmode)\n\t\tgoto no_delegation_unlock;\n\n\tif (delegation == NULL)\n\t\tdelegation = &deleg_cur->stateid;\n\telse if (!nfs4_stateid_match(&deleg_cur->stateid, delegation))\n\t\tgoto no_delegation_unlock;\n\n\tnfs_mark_delegation_referenced(deleg_cur);\n\t__update_open_stateid(state, open_stateid, &deleg_cur->stateid, fmode);\n\tret = 1;\nno_delegation_unlock:\n\tspin_unlock(&deleg_cur->lock);\nno_delegation:\n\trcu_read_unlock();\n\n\tif (!ret && open_stateid != NULL) {\n\t\t__update_open_stateid(state, open_stateid, NULL, fmode);\n\t\tret = 1;\n\t}\n\n\treturn ret;\n}\n\n\nstatic void nfs4_return_incompatible_delegation(struct inode *inode, fmode_t fmode)\n{\n\tstruct nfs_delegation *delegation;\n\n\trcu_read_lock();\n\tdelegation = rcu_dereference(NFS_I(inode)->delegation);\n\tif (delegation == NULL || (delegation->type & fmode) == fmode) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\trcu_read_unlock();\n\tnfs4_inode_return_delegation(inode);\n}\n\nstatic struct nfs4_state *nfs4_try_open_cached(struct nfs4_opendata *opendata)\n{\n\tstruct nfs4_state *state = opendata->state;\n\tstruct nfs_inode *nfsi = NFS_I(state->inode);\n\tstruct nfs_delegation *delegation;\n\tint open_mode = opendata->o_arg.open_flags & (O_EXCL|O_TRUNC);\n\tfmode_t fmode = opendata->o_arg.fmode;\n\tnfs4_stateid stateid;\n\tint ret = -EAGAIN;\n\n\tfor (;;) {\n\t\tif (can_open_cached(state, fmode, open_mode)) {\n\t\t\tspin_lock(&state->owner->so_lock);\n\t\t\tif (can_open_cached(state, fmode, open_mode)) {\n\t\t\t\tupdate_open_stateflags(state, fmode);\n\t\t\t\tspin_unlock(&state->owner->so_lock);\n\t\t\t\tgoto out_return_state;\n\t\t\t}\n\t\t\tspin_unlock(&state->owner->so_lock);\n\t\t}\n\t\trcu_read_lock();\n\t\tdelegation = rcu_dereference(nfsi->delegation);\n\t\tif (!can_open_delegated(delegation, fmode)) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\t\t/* Save the delegation */\n\t\tnfs4_stateid_copy(&stateid, &delegation->stateid);\n\t\trcu_read_unlock();\n\t\tret = nfs_may_open(state->inode, state->owner->so_cred, open_mode);\n\t\tif (ret != 0)\n\t\t\tgoto out;\n\t\tret = -EAGAIN;\n\n\t\t/* Try to update the stateid using the delegation */\n\t\tif (update_open_stateid(state, NULL, &stateid, fmode))\n\t\t\tgoto out_return_state;\n\t}\nout:\n\treturn ERR_PTR(ret);\nout_return_state:\n\tatomic_inc(&state->count);\n\treturn state;\n}\n\nstatic void\nnfs4_opendata_check_deleg(struct nfs4_opendata *data, struct nfs4_state *state)\n{\n\tstruct nfs_client *clp = NFS_SERVER(state->inode)->nfs_client;\n\tstruct nfs_delegation *delegation;\n\tint delegation_flags = 0;\n\n\trcu_read_lock();\n\tdelegation = rcu_dereference(NFS_I(state->inode)->delegation);\n\tif (delegation)\n\t\tdelegation_flags = delegation->flags;\n\trcu_read_unlock();\n\tif (data->o_arg.claim == NFS4_OPEN_CLAIM_DELEGATE_CUR) {\n\t\tpr_err_ratelimited(\"NFS: Broken NFSv4 server %s is \"\n\t\t\t\t   \"returning a delegation for \"\n\t\t\t\t   \"OPEN(CLAIM_DELEGATE_CUR)\\n\",\n\t\t\t\t   clp->cl_hostname);\n\t} else if ((delegation_flags & 1UL<<NFS_DELEGATION_NEED_RECLAIM) == 0)\n\t\tnfs_inode_set_delegation(state->inode,\n\t\t\t\t\t data->owner->so_cred,\n\t\t\t\t\t &data->o_res);\n\telse\n\t\tnfs_inode_reclaim_delegation(state->inode,\n\t\t\t\t\t     data->owner->so_cred,\n\t\t\t\t\t     &data->o_res);\n}\n\n/*\n * Check the inode attributes against the CLAIM_PREVIOUS returned attributes\n * and update the nfs4_state.\n */\nstatic struct nfs4_state *\n_nfs4_opendata_reclaim_to_nfs4_state(struct nfs4_opendata *data)\n{\n\tstruct inode *inode = data->state->inode;\n\tstruct nfs4_state *state = data->state;\n\tint ret;\n\n\tif (!data->rpc_done) {\n\t\tret = data->rpc_status;\n\t\tgoto err;\n\t}\n\n\tret = -ESTALE;\n\tif (!(data->f_attr.valid & NFS_ATTR_FATTR_TYPE) ||\n\t    !(data->f_attr.valid & NFS_ATTR_FATTR_FILEID) ||\n\t    !(data->f_attr.valid & NFS_ATTR_FATTR_CHANGE))\n\t\tgoto err;\n\n\tret = -ENOMEM;\n\tstate = nfs4_get_open_state(inode, data->owner);\n\tif (state == NULL)\n\t\tgoto err;\n\n\tret = nfs_refresh_inode(inode, &data->f_attr);\n\tif (ret)\n\t\tgoto err;\n\n\tif (data->o_res.delegation_type != 0)\n\t\tnfs4_opendata_check_deleg(data, state);\n\tupdate_open_stateid(state, &data->o_res.stateid, NULL,\n\t\t\t    data->o_arg.fmode);\n\n\treturn state;\nerr:\n\treturn ERR_PTR(ret);\n\n}\n\nstatic struct nfs4_state *\n_nfs4_opendata_to_nfs4_state(struct nfs4_opendata *data)\n{\n\tstruct inode *inode;\n\tstruct nfs4_state *state = NULL;\n\tint ret;\n\n\tif (!data->rpc_done) {\n\t\tstate = nfs4_try_open_cached(data);\n\t\tgoto out;\n\t}\n\n\tret = -EAGAIN;\n\tif (!(data->f_attr.valid & NFS_ATTR_FATTR))\n\t\tgoto err;\n\tinode = nfs_fhget(data->dir->d_sb, &data->o_res.fh, &data->f_attr);\n\tret = PTR_ERR(inode);\n\tif (IS_ERR(inode))\n\t\tgoto err;\n\tret = -ENOMEM;\n\tstate = nfs4_get_open_state(inode, data->owner);\n\tif (state == NULL)\n\t\tgoto err_put_inode;\n\tif (data->o_res.delegation_type != 0)\n\t\tnfs4_opendata_check_deleg(data, state);\n\tupdate_open_stateid(state, &data->o_res.stateid, NULL,\n\t\t\tdata->o_arg.fmode);\n\tiput(inode);\nout:\n\treturn state;\nerr_put_inode:\n\tiput(inode);\nerr:\n\treturn ERR_PTR(ret);\n}\n\nstatic struct nfs4_state *\nnfs4_opendata_to_nfs4_state(struct nfs4_opendata *data)\n{\n\tif (data->o_arg.claim == NFS4_OPEN_CLAIM_PREVIOUS)\n\t\treturn _nfs4_opendata_reclaim_to_nfs4_state(data);\n\treturn _nfs4_opendata_to_nfs4_state(data);\n}\n\nstatic struct nfs_open_context *nfs4_state_find_open_context(struct nfs4_state *state)\n{\n\tstruct nfs_inode *nfsi = NFS_I(state->inode);\n\tstruct nfs_open_context *ctx;\n\n\tspin_lock(&state->inode->i_lock);\n\tlist_for_each_entry(ctx, &nfsi->open_files, list) {\n\t\tif (ctx->state != state)\n\t\t\tcontinue;\n\t\tget_nfs_open_context(ctx);\n\t\tspin_unlock(&state->inode->i_lock);\n\t\treturn ctx;\n\t}\n\tspin_unlock(&state->inode->i_lock);\n\treturn ERR_PTR(-ENOENT);\n}\n\nstatic struct nfs4_opendata *nfs4_open_recoverdata_alloc(struct nfs_open_context *ctx, struct nfs4_state *state)\n{\n\tstruct nfs4_opendata *opendata;\n\n\topendata = nfs4_opendata_alloc(ctx->dentry, state->owner, 0, 0, NULL, GFP_NOFS);\n\tif (opendata == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\topendata->state = state;\n\tatomic_inc(&state->count);\n\treturn opendata;\n}\n\nstatic int nfs4_open_recover_helper(struct nfs4_opendata *opendata, fmode_t fmode, struct nfs4_state **res)\n{\n\tstruct nfs4_state *newstate;\n\tint ret;\n\n\topendata->o_arg.open_flags = 0;\n\topendata->o_arg.fmode = fmode;\n\tmemset(&opendata->o_res, 0, sizeof(opendata->o_res));\n\tmemset(&opendata->c_res, 0, sizeof(opendata->c_res));\n\tnfs4_init_opendata_res(opendata);\n\tret = _nfs4_recover_proc_open(opendata);\n\tif (ret != 0)\n\t\treturn ret; \n\tnewstate = nfs4_opendata_to_nfs4_state(opendata);\n\tif (IS_ERR(newstate))\n\t\treturn PTR_ERR(newstate);\n\tnfs4_close_state(newstate, fmode);\n\t*res = newstate;\n\treturn 0;\n}\n\nstatic int nfs4_open_recover(struct nfs4_opendata *opendata, struct nfs4_state *state)\n{\n\tstruct nfs4_state *newstate;\n\tint ret;\n\n\t/* memory barrier prior to reading state->n_* */\n\tclear_bit(NFS_DELEGATED_STATE, &state->flags);\n\tsmp_rmb();\n\tif (state->n_rdwr != 0) {\n\t\tclear_bit(NFS_O_RDWR_STATE, &state->flags);\n\t\tret = nfs4_open_recover_helper(opendata, FMODE_READ|FMODE_WRITE, &newstate);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t\tif (newstate != state)\n\t\t\treturn -ESTALE;\n\t}\n\tif (state->n_wronly != 0) {\n\t\tclear_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t\tret = nfs4_open_recover_helper(opendata, FMODE_WRITE, &newstate);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t\tif (newstate != state)\n\t\t\treturn -ESTALE;\n\t}\n\tif (state->n_rdonly != 0) {\n\t\tclear_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\tret = nfs4_open_recover_helper(opendata, FMODE_READ, &newstate);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t\tif (newstate != state)\n\t\t\treturn -ESTALE;\n\t}\n\t/*\n\t * We may have performed cached opens for all three recoveries.\n\t * Check if we need to update the current stateid.\n\t */\n\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) == 0 &&\n\t    !nfs4_stateid_match(&state->stateid, &state->open_stateid)) {\n\t\twrite_seqlock(&state->seqlock);\n\t\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) == 0)\n\t\t\tnfs4_stateid_copy(&state->stateid, &state->open_stateid);\n\t\twrite_sequnlock(&state->seqlock);\n\t}\n\treturn 0;\n}\n\n/*\n * OPEN_RECLAIM:\n * \treclaim state on the server after a reboot.\n */\nstatic int _nfs4_do_open_reclaim(struct nfs_open_context *ctx, struct nfs4_state *state)\n{\n\tstruct nfs_delegation *delegation;\n\tstruct nfs4_opendata *opendata;\n\tfmode_t delegation_type = 0;\n\tint status;\n\n\topendata = nfs4_open_recoverdata_alloc(ctx, state);\n\tif (IS_ERR(opendata))\n\t\treturn PTR_ERR(opendata);\n\topendata->o_arg.claim = NFS4_OPEN_CLAIM_PREVIOUS;\n\topendata->o_arg.fh = NFS_FH(state->inode);\n\trcu_read_lock();\n\tdelegation = rcu_dereference(NFS_I(state->inode)->delegation);\n\tif (delegation != NULL && test_bit(NFS_DELEGATION_NEED_RECLAIM, &delegation->flags) != 0)\n\t\tdelegation_type = delegation->type;\n\trcu_read_unlock();\n\topendata->o_arg.u.delegation_type = delegation_type;\n\tstatus = nfs4_open_recover(opendata, state);\n\tnfs4_opendata_put(opendata);\n\treturn status;\n}\n\nstatic int nfs4_do_open_reclaim(struct nfs_open_context *ctx, struct nfs4_state *state)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = _nfs4_do_open_reclaim(ctx, state);\n\t\tif (err != -NFS4ERR_DELAY)\n\t\t\tbreak;\n\t\tnfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int nfs4_open_reclaim(struct nfs4_state_owner *sp, struct nfs4_state *state)\n{\n\tstruct nfs_open_context *ctx;\n\tint ret;\n\n\tctx = nfs4_state_find_open_context(state);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\tret = nfs4_do_open_reclaim(ctx, state);\n\tput_nfs_open_context(ctx);\n\treturn ret;\n}\n\nstatic int _nfs4_open_delegation_recall(struct nfs_open_context *ctx, struct nfs4_state *state, const nfs4_stateid *stateid)\n{\n\tstruct nfs4_opendata *opendata;\n\tint ret;\n\n\topendata = nfs4_open_recoverdata_alloc(ctx, state);\n\tif (IS_ERR(opendata))\n\t\treturn PTR_ERR(opendata);\n\topendata->o_arg.claim = NFS4_OPEN_CLAIM_DELEGATE_CUR;\n\tnfs4_stateid_copy(&opendata->o_arg.u.delegation, stateid);\n\tret = nfs4_open_recover(opendata, state);\n\tnfs4_opendata_put(opendata);\n\treturn ret;\n}\n\nint nfs4_open_delegation_recall(struct nfs_open_context *ctx, struct nfs4_state *state, const nfs4_stateid *stateid)\n{\n\tstruct nfs4_exception exception = { };\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tint err;\n\tdo {\n\t\terr = _nfs4_open_delegation_recall(ctx, state, stateid);\n\t\tswitch (err) {\n\t\t\tcase 0:\n\t\t\tcase -ENOENT:\n\t\t\tcase -ESTALE:\n\t\t\t\tgoto out;\n\t\t\tcase -NFS4ERR_BADSESSION:\n\t\t\tcase -NFS4ERR_BADSLOT:\n\t\t\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\t\t\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\t\tcase -NFS4ERR_DEADSESSION:\n\t\t\t\tnfs4_schedule_session_recovery(server->nfs_client->cl_session, err);\n\t\t\t\tgoto out;\n\t\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\t\tcase -NFS4ERR_STALE_STATEID:\n\t\t\tcase -NFS4ERR_EXPIRED:\n\t\t\t\t/* Don't recall a delegation if it was lost */\n\t\t\t\tnfs4_schedule_lease_recovery(server->nfs_client);\n\t\t\t\tgoto out;\n\t\t\tcase -ERESTARTSYS:\n\t\t\t\t/*\n\t\t\t\t * The show must go on: exit, but mark the\n\t\t\t\t * stateid as needing recovery.\n\t\t\t\t */\n\t\t\tcase -NFS4ERR_DELEG_REVOKED:\n\t\t\tcase -NFS4ERR_ADMIN_REVOKED:\n\t\t\tcase -NFS4ERR_BAD_STATEID:\n\t\t\t\tnfs_inode_find_state_and_recover(state->inode,\n\t\t\t\t\t\tstateid);\n\t\t\t\tnfs4_schedule_stateid_recovery(server, state);\n\t\t\tcase -EKEYEXPIRED:\n\t\t\t\t/*\n\t\t\t\t * User RPCSEC_GSS context has expired.\n\t\t\t\t * We cannot recover this stateid now, so\n\t\t\t\t * skip it and allow recovery thread to\n\t\t\t\t * proceed.\n\t\t\t\t */\n\t\t\tcase -ENOMEM:\n\t\t\t\terr = 0;\n\t\t\t\tgoto out;\n\t\t}\n\t\terr = nfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\nout:\n\treturn err;\n}\n\nstatic void nfs4_open_confirm_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\n\tdata->rpc_status = task->tk_status;\n\tif (data->rpc_status == 0) {\n\t\tnfs4_stateid_copy(&data->o_res.stateid, &data->c_res.stateid);\n\t\tnfs_confirm_seqid(&data->owner->so_seqid, 0);\n\t\trenew_lease(data->o_res.server, data->timestamp);\n\t\tdata->rpc_done = 1;\n\t}\n}\n\nstatic void nfs4_open_confirm_release(void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\tstruct nfs4_state *state = NULL;\n\n\t/* If this request hasn't been cancelled, do nothing */\n\tif (data->cancelled == 0)\n\t\tgoto out_free;\n\t/* In case of error, no cleanup! */\n\tif (!data->rpc_done)\n\t\tgoto out_free;\n\tstate = nfs4_opendata_to_nfs4_state(data);\n\tif (!IS_ERR(state))\n\t\tnfs4_close_state(state, data->o_arg.fmode);\nout_free:\n\tnfs4_opendata_put(data);\n}\n\nstatic const struct rpc_call_ops nfs4_open_confirm_ops = {\n\t.rpc_call_done = nfs4_open_confirm_done,\n\t.rpc_release = nfs4_open_confirm_release,\n};\n\n/*\n * Note: On error, nfs4_proc_open_confirm will free the struct nfs4_opendata\n */\nstatic int _nfs4_proc_open_confirm(struct nfs4_opendata *data)\n{\n\tstruct nfs_server *server = NFS_SERVER(data->dir->d_inode);\n\tstruct rpc_task *task;\n\tstruct  rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN_CONFIRM],\n\t\t.rpc_argp = &data->c_arg,\n\t\t.rpc_resp = &data->c_res,\n\t\t.rpc_cred = data->owner->so_cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = server->client,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_open_confirm_ops,\n\t\t.callback_data = data,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\tint status;\n\n\tkref_get(&data->kref);\n\tdata->rpc_done = 0;\n\tdata->rpc_status = 0;\n\tdata->timestamp = jiffies;\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tstatus = nfs4_wait_for_completion_rpc_task(task);\n\tif (status != 0) {\n\t\tdata->cancelled = 1;\n\t\tsmp_wmb();\n\t} else\n\t\tstatus = data->rpc_status;\n\trpc_put_task(task);\n\treturn status;\n}\n\nstatic void nfs4_open_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\tstruct nfs4_state_owner *sp = data->owner;\n\n\tif (nfs_wait_on_sequence(data->o_arg.seqid, task) != 0)\n\t\treturn;\n\t/*\n\t * Check if we still need to send an OPEN call, or if we can use\n\t * a delegation instead.\n\t */\n\tif (data->state != NULL) {\n\t\tstruct nfs_delegation *delegation;\n\n\t\tif (can_open_cached(data->state, data->o_arg.fmode, data->o_arg.open_flags))\n\t\t\tgoto out_no_action;\n\t\trcu_read_lock();\n\t\tdelegation = rcu_dereference(NFS_I(data->state->inode)->delegation);\n\t\tif (data->o_arg.claim != NFS4_OPEN_CLAIM_DELEGATE_CUR &&\n\t\t    can_open_delegated(delegation, data->o_arg.fmode))\n\t\t\tgoto unlock_no_action;\n\t\trcu_read_unlock();\n\t}\n\t/* Update client id. */\n\tdata->o_arg.clientid = sp->so_server->nfs_client->cl_clientid;\n\tif (data->o_arg.claim == NFS4_OPEN_CLAIM_PREVIOUS) {\n\t\ttask->tk_msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN_NOATTR];\n\t\tdata->o_arg.open_bitmap = &nfs4_open_noattr_bitmap[0];\n\t\tnfs_copy_fh(&data->o_res.fh, data->o_arg.fh);\n\t}\n\tdata->timestamp = jiffies;\n\tif (nfs4_setup_sequence(data->o_arg.server,\n\t\t\t\t&data->o_arg.seq_args,\n\t\t\t\t&data->o_res.seq_res,\n\t\t\t\ttask) != 0)\n\t\tnfs_release_seqid(data->o_arg.seqid);\n\telse\n\t\trpc_call_start(task);\n\treturn;\nunlock_no_action:\n\trcu_read_unlock();\nout_no_action:\n\ttask->tk_action = NULL;\n\n}\n\nstatic void nfs4_recover_open_prepare(struct rpc_task *task, void *calldata)\n{\n\trpc_task_set_priority(task, RPC_PRIORITY_PRIVILEGED);\n\tnfs4_open_prepare(task, calldata);\n}\n\nstatic void nfs4_open_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\n\tdata->rpc_status = task->tk_status;\n\n\tif (!nfs4_sequence_done(task, &data->o_res.seq_res))\n\t\treturn;\n\n\tif (task->tk_status == 0) {\n\t\tif (data->o_res.f_attr->valid & NFS_ATTR_FATTR_TYPE) {\n\t\t\tswitch (data->o_res.f_attr->mode & S_IFMT) {\n\t\t\tcase S_IFREG:\n\t\t\t\tbreak;\n\t\t\tcase S_IFLNK:\n\t\t\t\tdata->rpc_status = -ELOOP;\n\t\t\t\tbreak;\n\t\t\tcase S_IFDIR:\n\t\t\t\tdata->rpc_status = -EISDIR;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdata->rpc_status = -ENOTDIR;\n\t\t\t}\n\t\t}\n\t\trenew_lease(data->o_res.server, data->timestamp);\n\t\tif (!(data->o_res.rflags & NFS4_OPEN_RESULT_CONFIRM))\n\t\t\tnfs_confirm_seqid(&data->owner->so_seqid, 0);\n\t}\n\tdata->rpc_done = 1;\n}\n\nstatic void nfs4_open_release(void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\tstruct nfs4_state *state = NULL;\n\n\t/* If this request hasn't been cancelled, do nothing */\n\tif (data->cancelled == 0)\n\t\tgoto out_free;\n\t/* In case of error, no cleanup! */\n\tif (data->rpc_status != 0 || !data->rpc_done)\n\t\tgoto out_free;\n\t/* In case we need an open_confirm, no cleanup! */\n\tif (data->o_res.rflags & NFS4_OPEN_RESULT_CONFIRM)\n\t\tgoto out_free;\n\tstate = nfs4_opendata_to_nfs4_state(data);\n\tif (!IS_ERR(state))\n\t\tnfs4_close_state(state, data->o_arg.fmode);\nout_free:\n\tnfs4_opendata_put(data);\n}\n\nstatic const struct rpc_call_ops nfs4_open_ops = {\n\t.rpc_call_prepare = nfs4_open_prepare,\n\t.rpc_call_done = nfs4_open_done,\n\t.rpc_release = nfs4_open_release,\n};\n\nstatic const struct rpc_call_ops nfs4_recover_open_ops = {\n\t.rpc_call_prepare = nfs4_recover_open_prepare,\n\t.rpc_call_done = nfs4_open_done,\n\t.rpc_release = nfs4_open_release,\n};\n\nstatic int nfs4_run_open_task(struct nfs4_opendata *data, int isrecover)\n{\n\tstruct inode *dir = data->dir->d_inode;\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tstruct nfs_openargs *o_arg = &data->o_arg;\n\tstruct nfs_openres *o_res = &data->o_res;\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN],\n\t\t.rpc_argp = o_arg,\n\t\t.rpc_resp = o_res,\n\t\t.rpc_cred = data->owner->so_cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = server->client,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_open_ops,\n\t\t.callback_data = data,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\tint status;\n\n\tnfs41_init_sequence(&o_arg->seq_args, &o_res->seq_res, 1);\n\tkref_get(&data->kref);\n\tdata->rpc_done = 0;\n\tdata->rpc_status = 0;\n\tdata->cancelled = 0;\n\tif (isrecover)\n\t\ttask_setup_data.callback_ops = &nfs4_recover_open_ops;\n\ttask = rpc_run_task(&task_setup_data);\n        if (IS_ERR(task))\n                return PTR_ERR(task);\n        status = nfs4_wait_for_completion_rpc_task(task);\n        if (status != 0) {\n                data->cancelled = 1;\n                smp_wmb();\n        } else\n                status = data->rpc_status;\n        rpc_put_task(task);\n\n\treturn status;\n}\n\nstatic int _nfs4_recover_proc_open(struct nfs4_opendata *data)\n{\n\tstruct inode *dir = data->dir->d_inode;\n\tstruct nfs_openres *o_res = &data->o_res;\n        int status;\n\n\tstatus = nfs4_run_open_task(data, 1);\n\tif (status != 0 || !data->rpc_done)\n\t\treturn status;\n\n\tnfs_fattr_map_and_free_names(NFS_SERVER(dir), &data->f_attr);\n\n\tif (o_res->rflags & NFS4_OPEN_RESULT_CONFIRM) {\n\t\tstatus = _nfs4_proc_open_confirm(data);\n\t\tif (status != 0)\n\t\t\treturn status;\n\t}\n\n\treturn status;\n}\n\nstatic int nfs4_opendata_access(struct rpc_cred *cred,\n\t\t\t\tstruct nfs4_opendata *opendata,\n\t\t\t\tstruct nfs4_state *state, fmode_t fmode)\n{\n\tstruct nfs_access_entry cache;\n\tu32 mask;\n\n\t/* access call failed or for some reason the server doesn't\n\t * support any access modes -- defer access call until later */\n\tif (opendata->o_res.access_supported == 0)\n\t\treturn 0;\n\n\tmask = 0;\n\t/* don't check MAY_WRITE - a newly created file may not have\n\t * write mode bits, but POSIX allows the creating process to write */\n\tif (fmode & FMODE_READ)\n\t\tmask |= MAY_READ;\n\tif (fmode & FMODE_EXEC)\n\t\tmask |= MAY_EXEC;\n\n\tcache.cred = cred;\n\tcache.jiffies = jiffies;\n\tnfs_access_set_mask(&cache, opendata->o_res.access_result);\n\tnfs_access_add_cache(state->inode, &cache);\n\n\tif ((mask & ~cache.mask & (MAY_READ | MAY_EXEC)) == 0)\n\t\treturn 0;\n\n\t/* even though OPEN succeeded, access is denied. Close the file */\n\tnfs4_close_state(state, fmode);\n\treturn -EACCES;\n}\n\n/*\n * Note: On error, nfs4_proc_open will free the struct nfs4_opendata\n */\nstatic int _nfs4_proc_open(struct nfs4_opendata *data)\n{\n\tstruct inode *dir = data->dir->d_inode;\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tstruct nfs_openargs *o_arg = &data->o_arg;\n\tstruct nfs_openres *o_res = &data->o_res;\n\tint status;\n\n\tstatus = nfs4_run_open_task(data, 0);\n\tif (!data->rpc_done)\n\t\treturn status;\n\tif (status != 0) {\n\t\tif (status == -NFS4ERR_BADNAME &&\n\t\t\t\t!(o_arg->open_flags & O_CREAT))\n\t\t\treturn -ENOENT;\n\t\treturn status;\n\t}\n\n\tnfs_fattr_map_and_free_names(server, &data->f_attr);\n\n\tif (o_arg->open_flags & O_CREAT)\n\t\tupdate_changeattr(dir, &o_res->cinfo);\n\tif ((o_res->rflags & NFS4_OPEN_RESULT_LOCKTYPE_POSIX) == 0)\n\t\tserver->caps &= ~NFS_CAP_POSIX_LOCK;\n\tif(o_res->rflags & NFS4_OPEN_RESULT_CONFIRM) {\n\t\tstatus = _nfs4_proc_open_confirm(data);\n\t\tif (status != 0)\n\t\t\treturn status;\n\t}\n\tif (!(o_res->f_attr->valid & NFS_ATTR_FATTR))\n\t\t_nfs4_proc_getattr(server, &o_res->fh, o_res->f_attr);\n\treturn 0;\n}\n\nstatic int nfs4_client_recover_expired_lease(struct nfs_client *clp)\n{\n\tunsigned int loop;\n\tint ret;\n\n\tfor (loop = NFS4_MAX_LOOP_ON_RECOVER; loop != 0; loop--) {\n\t\tret = nfs4_wait_clnt_recover(clp);\n\t\tif (ret != 0)\n\t\t\tbreak;\n\t\tif (!test_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state) &&\n\t\t    !test_bit(NFS4CLNT_CHECK_LEASE,&clp->cl_state))\n\t\t\tbreak;\n\t\tnfs4_schedule_state_manager(clp);\n\t\tret = -EIO;\n\t}\n\treturn ret;\n}\n\nstatic int nfs4_recover_expired_lease(struct nfs_server *server)\n{\n\treturn nfs4_client_recover_expired_lease(server->nfs_client);\n}\n\n/*\n * OPEN_EXPIRED:\n * \treclaim state on the server after a network partition.\n * \tAssumes caller holds the appropriate lock\n */\nstatic int _nfs4_open_expired(struct nfs_open_context *ctx, struct nfs4_state *state)\n{\n\tstruct nfs4_opendata *opendata;\n\tint ret;\n\n\topendata = nfs4_open_recoverdata_alloc(ctx, state);\n\tif (IS_ERR(opendata))\n\t\treturn PTR_ERR(opendata);\n\tret = nfs4_open_recover(opendata, state);\n\tif (ret == -ESTALE)\n\t\td_drop(ctx->dentry);\n\tnfs4_opendata_put(opendata);\n\treturn ret;\n}\n\nstatic int nfs4_do_open_expired(struct nfs_open_context *ctx, struct nfs4_state *state)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\tdo {\n\t\terr = _nfs4_open_expired(ctx, state);\n\t\tswitch (err) {\n\t\tdefault:\n\t\t\tgoto out;\n\t\tcase -NFS4ERR_GRACE:\n\t\tcase -NFS4ERR_DELAY:\n\t\t\tnfs4_handle_exception(server, err, &exception);\n\t\t\terr = 0;\n\t\t}\n\t} while (exception.retry);\nout:\n\treturn err;\n}\n\nstatic int nfs4_open_expired(struct nfs4_state_owner *sp, struct nfs4_state *state)\n{\n\tstruct nfs_open_context *ctx;\n\tint ret;\n\n\tctx = nfs4_state_find_open_context(state);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\tret = nfs4_do_open_expired(ctx, state);\n\tput_nfs_open_context(ctx);\n\treturn ret;\n}\n\n#if defined(CONFIG_NFS_V4_1)\nstatic void nfs41_clear_delegation_stateid(struct nfs4_state *state)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tnfs4_stateid *stateid = &state->stateid;\n\tint status;\n\n\t/* If a state reset has been done, test_stateid is unneeded */\n\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) == 0)\n\t\treturn;\n\n\tstatus = nfs41_test_stateid(server, stateid);\n\tif (status != NFS_OK) {\n\t\t/* Free the stateid unless the server explicitly\n\t\t * informs us the stateid is unrecognized. */\n\t\tif (status != -NFS4ERR_BAD_STATEID)\n\t\t\tnfs41_free_stateid(server, stateid);\n\t\tnfs_remove_bad_delegation(state->inode);\n\n\t\twrite_seqlock(&state->seqlock);\n\t\tnfs4_stateid_copy(&state->stateid, &state->open_stateid);\n\t\twrite_sequnlock(&state->seqlock);\n\t\tclear_bit(NFS_DELEGATED_STATE, &state->flags);\n\t}\n}\n\n/**\n * nfs41_check_open_stateid - possibly free an open stateid\n *\n * @state: NFSv4 state for an inode\n *\n * Returns NFS_OK if recovery for this stateid is now finished.\n * Otherwise a negative NFS4ERR value is returned.\n */\nstatic int nfs41_check_open_stateid(struct nfs4_state *state)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tnfs4_stateid *stateid = &state->open_stateid;\n\tint status;\n\n\t/* If a state reset has been done, test_stateid is unneeded */\n\tif ((test_bit(NFS_O_RDONLY_STATE, &state->flags) == 0) &&\n\t    (test_bit(NFS_O_WRONLY_STATE, &state->flags) == 0) &&\n\t    (test_bit(NFS_O_RDWR_STATE, &state->flags) == 0))\n\t\treturn -NFS4ERR_BAD_STATEID;\n\n\tstatus = nfs41_test_stateid(server, stateid);\n\tif (status != NFS_OK) {\n\t\t/* Free the stateid unless the server explicitly\n\t\t * informs us the stateid is unrecognized. */\n\t\tif (status != -NFS4ERR_BAD_STATEID)\n\t\t\tnfs41_free_stateid(server, stateid);\n\n\t\tclear_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\tclear_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t\tclear_bit(NFS_O_RDWR_STATE, &state->flags);\n\t}\n\treturn status;\n}\n\nstatic int nfs41_open_expired(struct nfs4_state_owner *sp, struct nfs4_state *state)\n{\n\tint status;\n\n\tnfs41_clear_delegation_stateid(state);\n\tstatus = nfs41_check_open_stateid(state);\n\tif (status != NFS_OK)\n\t\tstatus = nfs4_open_expired(sp, state);\n\treturn status;\n}\n#endif\n\n/*\n * on an EXCLUSIVE create, the server should send back a bitmask with FATTR4-*\n * fields corresponding to attributes that were used to store the verifier.\n * Make sure we clobber those fields in the later setattr call\n */\nstatic inline void nfs4_exclusive_attrset(struct nfs4_opendata *opendata, struct iattr *sattr)\n{\n\tif ((opendata->o_res.attrset[1] & FATTR4_WORD1_TIME_ACCESS) &&\n\t    !(sattr->ia_valid & ATTR_ATIME_SET))\n\t\tsattr->ia_valid |= ATTR_ATIME;\n\n\tif ((opendata->o_res.attrset[1] & FATTR4_WORD1_TIME_MODIFY) &&\n\t    !(sattr->ia_valid & ATTR_MTIME_SET))\n\t\tsattr->ia_valid |= ATTR_MTIME;\n}\n\n/*\n * Returns a referenced nfs4_state\n */\nstatic int _nfs4_do_open(struct inode *dir,\n\t\t\tstruct dentry *dentry,\n\t\t\tfmode_t fmode,\n\t\t\tint flags,\n\t\t\tstruct iattr *sattr,\n\t\t\tstruct rpc_cred *cred,\n\t\t\tstruct nfs4_state **res,\n\t\t\tstruct nfs4_threshold **ctx_th)\n{\n\tstruct nfs4_state_owner  *sp;\n\tstruct nfs4_state     *state = NULL;\n\tstruct nfs_server       *server = NFS_SERVER(dir);\n\tstruct nfs4_opendata *opendata;\n\tint status;\n\n\t/* Protect against reboot recovery conflicts */\n\tstatus = -ENOMEM;\n\tsp = nfs4_get_state_owner(server, cred, GFP_KERNEL);\n\tif (sp == NULL) {\n\t\tdprintk(\"nfs4_do_open: nfs4_get_state_owner failed!\\n\");\n\t\tgoto out_err;\n\t}\n\tstatus = nfs4_recover_expired_lease(server);\n\tif (status != 0)\n\t\tgoto err_put_state_owner;\n\tif (dentry->d_inode != NULL)\n\t\tnfs4_return_incompatible_delegation(dentry->d_inode, fmode);\n\tstatus = -ENOMEM;\n\topendata = nfs4_opendata_alloc(dentry, sp, fmode, flags, sattr, GFP_KERNEL);\n\tif (opendata == NULL)\n\t\tgoto err_put_state_owner;\n\n\tif (ctx_th && server->attr_bitmask[2] & FATTR4_WORD2_MDSTHRESHOLD) {\n\t\topendata->f_attr.mdsthreshold = pnfs_mdsthreshold_alloc();\n\t\tif (!opendata->f_attr.mdsthreshold)\n\t\t\tgoto err_opendata_put;\n\t\topendata->o_arg.open_bitmap = &nfs4_pnfs_open_bitmap[0];\n\t}\n\tif (dentry->d_inode != NULL)\n\t\topendata->state = nfs4_get_open_state(dentry->d_inode, sp);\n\n\tstatus = _nfs4_proc_open(opendata);\n\tif (status != 0)\n\t\tgoto err_opendata_put;\n\n\tstate = nfs4_opendata_to_nfs4_state(opendata);\n\tstatus = PTR_ERR(state);\n\tif (IS_ERR(state))\n\t\tgoto err_opendata_put;\n\tif (server->caps & NFS_CAP_POSIX_LOCK)\n\t\tset_bit(NFS_STATE_POSIX_LOCKS, &state->flags);\n\n\tstatus = nfs4_opendata_access(cred, opendata, state, fmode);\n\tif (status != 0)\n\t\tgoto err_opendata_put;\n\n\tif (opendata->o_arg.open_flags & O_EXCL) {\n\t\tnfs4_exclusive_attrset(opendata, sattr);\n\n\t\tnfs_fattr_init(opendata->o_res.f_attr);\n\t\tstatus = nfs4_do_setattr(state->inode, cred,\n\t\t\t\topendata->o_res.f_attr, sattr,\n\t\t\t\tstate);\n\t\tif (status == 0)\n\t\t\tnfs_setattr_update_inode(state->inode, sattr);\n\t\tnfs_post_op_update_inode(state->inode, opendata->o_res.f_attr);\n\t}\n\n\tif (pnfs_use_threshold(ctx_th, opendata->f_attr.mdsthreshold, server))\n\t\t*ctx_th = opendata->f_attr.mdsthreshold;\n\telse\n\t\tkfree(opendata->f_attr.mdsthreshold);\n\topendata->f_attr.mdsthreshold = NULL;\n\n\tnfs4_opendata_put(opendata);\n\tnfs4_put_state_owner(sp);\n\t*res = state;\n\treturn 0;\nerr_opendata_put:\n\tkfree(opendata->f_attr.mdsthreshold);\n\tnfs4_opendata_put(opendata);\nerr_put_state_owner:\n\tnfs4_put_state_owner(sp);\nout_err:\n\t*res = NULL;\n\treturn status;\n}\n\n\nstatic struct nfs4_state *nfs4_do_open(struct inode *dir,\n\t\t\t\t\tstruct dentry *dentry,\n\t\t\t\t\tfmode_t fmode,\n\t\t\t\t\tint flags,\n\t\t\t\t\tstruct iattr *sattr,\n\t\t\t\t\tstruct rpc_cred *cred,\n\t\t\t\t\tstruct nfs4_threshold **ctx_th)\n{\n\tstruct nfs4_exception exception = { };\n\tstruct nfs4_state *res;\n\tint status;\n\n\tfmode &= FMODE_READ|FMODE_WRITE|FMODE_EXEC;\n\tdo {\n\t\tstatus = _nfs4_do_open(dir, dentry, fmode, flags, sattr, cred,\n\t\t\t\t       &res, ctx_th);\n\t\tif (status == 0)\n\t\t\tbreak;\n\t\t/* NOTE: BAD_SEQID means the server and client disagree about the\n\t\t * book-keeping w.r.t. state-changing operations\n\t\t * (OPEN/CLOSE/LOCK/LOCKU...)\n\t\t * It is actually a sign of a bug on the client or on the server.\n\t\t *\n\t\t * If we receive a BAD_SEQID error in the particular case of\n\t\t * doing an OPEN, we assume that nfs_increment_open_seqid() will\n\t\t * have unhashed the old state_owner for us, and that we can\n\t\t * therefore safely retry using a new one. We should still warn\n\t\t * the user though...\n\t\t */\n\t\tif (status == -NFS4ERR_BAD_SEQID) {\n\t\t\tpr_warn_ratelimited(\"NFS: v4 server %s \"\n\t\t\t\t\t\" returned a bad sequence-id error!\\n\",\n\t\t\t\t\tNFS_SERVER(dir)->nfs_client->cl_hostname);\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * BAD_STATEID on OPEN means that the server cancelled our\n\t\t * state before it received the OPEN_CONFIRM.\n\t\t * Recover by retrying the request as per the discussion\n\t\t * on Page 181 of RFC3530.\n\t\t */\n\t\tif (status == -NFS4ERR_BAD_STATEID) {\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (status == -EAGAIN) {\n\t\t\t/* We must have found a delegation */\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tres = ERR_PTR(nfs4_handle_exception(NFS_SERVER(dir),\n\t\t\t\t\tstatus, &exception));\n\t} while (exception.retry);\n\treturn res;\n}\n\nstatic int _nfs4_do_setattr(struct inode *inode, struct rpc_cred *cred,\n\t\t\t    struct nfs_fattr *fattr, struct iattr *sattr,\n\t\t\t    struct nfs4_state *state)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n        struct nfs_setattrargs  arg = {\n                .fh             = NFS_FH(inode),\n                .iap            = sattr,\n\t\t.server\t\t= server,\n\t\t.bitmask = server->attr_bitmask,\n        };\n        struct nfs_setattrres  res = {\n\t\t.fattr\t\t= fattr,\n\t\t.server\t\t= server,\n        };\n        struct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_SETATTR],\n\t\t.rpc_argp\t= &arg,\n\t\t.rpc_resp\t= &res,\n\t\t.rpc_cred\t= cred,\n        };\n\tunsigned long timestamp = jiffies;\n\tint status;\n\n\tnfs_fattr_init(fattr);\n\n\tif (state != NULL) {\n\t\tstruct nfs_lockowner lockowner = {\n\t\t\t.l_owner = current->files,\n\t\t\t.l_pid = current->tgid,\n\t\t};\n\t\tnfs4_select_rw_stateid(&arg.stateid, state, FMODE_WRITE,\n\t\t\t\t&lockowner);\n\t} else if (nfs4_copy_delegation_stateid(&arg.stateid, inode,\n\t\t\t\tFMODE_WRITE)) {\n\t\t/* Use that stateid */\n\t} else\n\t\tnfs4_stateid_copy(&arg.stateid, &zero_stateid);\n\n\tstatus = nfs4_call_sync(server->client, server, &msg, &arg.seq_args, &res.seq_res, 1);\n\tif (status == 0 && state != NULL)\n\t\trenew_lease(server, timestamp);\n\treturn status;\n}\n\nstatic int nfs4_do_setattr(struct inode *inode, struct rpc_cred *cred,\n\t\t\t   struct nfs_fattr *fattr, struct iattr *sattr,\n\t\t\t   struct nfs4_state *state)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs4_exception exception = {\n\t\t.state = state,\n\t\t.inode = inode,\n\t};\n\tint err;\n\tdo {\n\t\terr = _nfs4_do_setattr(inode, cred, fattr, sattr, state);\n\t\tswitch (err) {\n\t\tcase -NFS4ERR_OPENMODE:\n\t\t\tif (state && !(state->state & FMODE_WRITE)) {\n\t\t\t\terr = -EBADF;\n\t\t\t\tif (sattr->ia_valid & ATTR_OPEN)\n\t\t\t\t\terr = -EACCES;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\terr = nfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\nout:\n\treturn err;\n}\n\nstruct nfs4_closedata {\n\tstruct inode *inode;\n\tstruct nfs4_state *state;\n\tstruct nfs_closeargs arg;\n\tstruct nfs_closeres res;\n\tstruct nfs_fattr fattr;\n\tunsigned long timestamp;\n\tbool roc;\n\tu32 roc_barrier;\n};\n\nstatic void nfs4_free_closedata(void *data)\n{\n\tstruct nfs4_closedata *calldata = data;\n\tstruct nfs4_state_owner *sp = calldata->state->owner;\n\tstruct super_block *sb = calldata->state->inode->i_sb;\n\n\tif (calldata->roc)\n\t\tpnfs_roc_release(calldata->state->inode);\n\tnfs4_put_open_state(calldata->state);\n\tnfs_free_seqid(calldata->arg.seqid);\n\tnfs4_put_state_owner(sp);\n\tnfs_sb_deactive_async(sb);\n\tkfree(calldata);\n}\n\nstatic void nfs4_close_clear_stateid_flags(struct nfs4_state *state,\n\t\tfmode_t fmode)\n{\n\tspin_lock(&state->owner->so_lock);\n\tif (!(fmode & FMODE_READ))\n\t\tclear_bit(NFS_O_RDONLY_STATE, &state->flags);\n\tif (!(fmode & FMODE_WRITE))\n\t\tclear_bit(NFS_O_WRONLY_STATE, &state->flags);\n\tclear_bit(NFS_O_RDWR_STATE, &state->flags);\n\tspin_unlock(&state->owner->so_lock);\n}\n\nstatic void nfs4_close_done(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_closedata *calldata = data;\n\tstruct nfs4_state *state = calldata->state;\n\tstruct nfs_server *server = NFS_SERVER(calldata->inode);\n\n\tdprintk(\"%s: begin!\\n\", __func__);\n\tif (!nfs4_sequence_done(task, &calldata->res.seq_res))\n\t\treturn;\n        /* hmm. we are done with the inode, and in the process of freeing\n\t * the state_owner. we keep this around to process errors\n\t */\n\tswitch (task->tk_status) {\n\t\tcase 0:\n\t\t\tif (calldata->roc)\n\t\t\t\tpnfs_roc_set_barrier(state->inode,\n\t\t\t\t\t\t     calldata->roc_barrier);\n\t\t\tnfs_set_open_stateid(state, &calldata->res.stateid, 0);\n\t\t\trenew_lease(server, calldata->timestamp);\n\t\t\tnfs4_close_clear_stateid_flags(state,\n\t\t\t\t\tcalldata->arg.fmode);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_STALE_STATEID:\n\t\tcase -NFS4ERR_OLD_STATEID:\n\t\tcase -NFS4ERR_BAD_STATEID:\n\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tif (calldata->arg.fmode == 0)\n\t\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (nfs4_async_handle_error(task, server, state) == -EAGAIN)\n\t\t\t\trpc_restart_call_prepare(task);\n\t}\n\tnfs_release_seqid(calldata->arg.seqid);\n\tnfs_refresh_inode(calldata->inode, calldata->res.fattr);\n\tdprintk(\"%s: done, ret = %d!\\n\", __func__, task->tk_status);\n}\n\nstatic void nfs4_close_prepare(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_closedata *calldata = data;\n\tstruct nfs4_state *state = calldata->state;\n\tstruct inode *inode = calldata->inode;\n\tint call_close = 0;\n\n\tdprintk(\"%s: begin!\\n\", __func__);\n\tif (nfs_wait_on_sequence(calldata->arg.seqid, task) != 0)\n\t\treturn;\n\n\ttask->tk_msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN_DOWNGRADE];\n\tcalldata->arg.fmode = FMODE_READ|FMODE_WRITE;\n\tspin_lock(&state->owner->so_lock);\n\t/* Calculate the change in open mode */\n\tif (state->n_rdwr == 0) {\n\t\tif (state->n_rdonly == 0) {\n\t\t\tcall_close |= test_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\t\tcall_close |= test_bit(NFS_O_RDWR_STATE, &state->flags);\n\t\t\tcalldata->arg.fmode &= ~FMODE_READ;\n\t\t}\n\t\tif (state->n_wronly == 0) {\n\t\t\tcall_close |= test_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t\t\tcall_close |= test_bit(NFS_O_RDWR_STATE, &state->flags);\n\t\t\tcalldata->arg.fmode &= ~FMODE_WRITE;\n\t\t}\n\t}\n\tspin_unlock(&state->owner->so_lock);\n\n\tif (!call_close) {\n\t\t/* Note: exit _without_ calling nfs4_close_done */\n\t\ttask->tk_action = NULL;\n\t\tgoto out;\n\t}\n\n\tif (calldata->arg.fmode == 0) {\n\t\ttask->tk_msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_CLOSE];\n\t\tif (calldata->roc &&\n\t\t    pnfs_roc_drain(inode, &calldata->roc_barrier, task))\n\t\t\tgoto out;\n\t}\n\n\tnfs_fattr_init(calldata->res.fattr);\n\tcalldata->timestamp = jiffies;\n\tif (nfs4_setup_sequence(NFS_SERVER(inode),\n\t\t\t\t&calldata->arg.seq_args,\n\t\t\t\t&calldata->res.seq_res,\n\t\t\t\ttask) != 0)\n\t\tnfs_release_seqid(calldata->arg.seqid);\n\telse\n\t\trpc_call_start(task);\nout:\n\tdprintk(\"%s: done!\\n\", __func__);\n}\n\nstatic const struct rpc_call_ops nfs4_close_ops = {\n\t.rpc_call_prepare = nfs4_close_prepare,\n\t.rpc_call_done = nfs4_close_done,\n\t.rpc_release = nfs4_free_closedata,\n};\n\n/* \n * It is possible for data to be read/written from a mem-mapped file \n * after the sys_close call (which hits the vfs layer as a flush).\n * This means that we can't safely call nfsv4 close on a file until \n * the inode is cleared. This in turn means that we are not good\n * NFSv4 citizens - we do not indicate to the server to update the file's \n * share state even when we are done with one of the three share \n * stateid's in the inode.\n *\n * NOTE: Caller must be holding the sp->so_owner semaphore!\n */\nint nfs4_do_close(struct nfs4_state *state, gfp_t gfp_mask, int wait)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs4_closedata *calldata;\n\tstruct nfs4_state_owner *sp = state->owner;\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_CLOSE],\n\t\t.rpc_cred = state->owner->so_cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = server->client,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_close_ops,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\tint status = -ENOMEM;\n\n\tcalldata = kzalloc(sizeof(*calldata), gfp_mask);\n\tif (calldata == NULL)\n\t\tgoto out;\n\tnfs41_init_sequence(&calldata->arg.seq_args, &calldata->res.seq_res, 1);\n\tcalldata->inode = state->inode;\n\tcalldata->state = state;\n\tcalldata->arg.fh = NFS_FH(state->inode);\n\tcalldata->arg.stateid = &state->open_stateid;\n\t/* Serialization for the sequence id */\n\tcalldata->arg.seqid = nfs_alloc_seqid(&state->owner->so_seqid, gfp_mask);\n\tif (calldata->arg.seqid == NULL)\n\t\tgoto out_free_calldata;\n\tcalldata->arg.fmode = 0;\n\tcalldata->arg.bitmask = server->cache_consistency_bitmask;\n\tcalldata->res.fattr = &calldata->fattr;\n\tcalldata->res.seqid = calldata->arg.seqid;\n\tcalldata->res.server = server;\n\tcalldata->roc = pnfs_roc(state->inode);\n\tnfs_sb_active(calldata->inode->i_sb);\n\n\tmsg.rpc_argp = &calldata->arg;\n\tmsg.rpc_resp = &calldata->res;\n\ttask_setup_data.callback_data = calldata;\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tstatus = 0;\n\tif (wait)\n\t\tstatus = rpc_wait_for_completion_task(task);\n\trpc_put_task(task);\n\treturn status;\nout_free_calldata:\n\tkfree(calldata);\nout:\n\tnfs4_put_open_state(state);\n\tnfs4_put_state_owner(sp);\n\treturn status;\n}\n\nstatic struct inode *\nnfs4_atomic_open(struct inode *dir, struct nfs_open_context *ctx, int open_flags, struct iattr *attr)\n{\n\tstruct nfs4_state *state;\n\n\t/* Protect against concurrent sillydeletes */\n\tstate = nfs4_do_open(dir, ctx->dentry, ctx->mode, open_flags, attr,\n\t\t\t     ctx->cred, &ctx->mdsthreshold);\n\tif (IS_ERR(state))\n\t\treturn ERR_CAST(state);\n\tctx->state = state;\n\treturn igrab(state->inode);\n}\n\nstatic void nfs4_close_context(struct nfs_open_context *ctx, int is_sync)\n{\n\tif (ctx->state == NULL)\n\t\treturn;\n\tif (is_sync)\n\t\tnfs4_close_sync(ctx->state, ctx->mode);\n\telse\n\t\tnfs4_close_state(ctx->state, ctx->mode);\n}\n\nstatic int _nfs4_server_capabilities(struct nfs_server *server, struct nfs_fh *fhandle)\n{\n\tstruct nfs4_server_caps_arg args = {\n\t\t.fhandle = fhandle,\n\t};\n\tstruct nfs4_server_caps_res res = {};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SERVER_CAPS],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tint status;\n\n\tstatus = nfs4_call_sync(server->client, server, &msg, &args.seq_args, &res.seq_res, 0);\n\tif (status == 0) {\n\t\tmemcpy(server->attr_bitmask, res.attr_bitmask, sizeof(server->attr_bitmask));\n\t\tserver->caps &= ~(NFS_CAP_ACLS|NFS_CAP_HARDLINKS|\n\t\t\t\tNFS_CAP_SYMLINKS|NFS_CAP_FILEID|\n\t\t\t\tNFS_CAP_MODE|NFS_CAP_NLINK|NFS_CAP_OWNER|\n\t\t\t\tNFS_CAP_OWNER_GROUP|NFS_CAP_ATIME|\n\t\t\t\tNFS_CAP_CTIME|NFS_CAP_MTIME);\n\t\tif (res.attr_bitmask[0] & FATTR4_WORD0_ACL)\n\t\t\tserver->caps |= NFS_CAP_ACLS;\n\t\tif (res.has_links != 0)\n\t\t\tserver->caps |= NFS_CAP_HARDLINKS;\n\t\tif (res.has_symlinks != 0)\n\t\t\tserver->caps |= NFS_CAP_SYMLINKS;\n\t\tif (res.attr_bitmask[0] & FATTR4_WORD0_FILEID)\n\t\t\tserver->caps |= NFS_CAP_FILEID;\n\t\tif (res.attr_bitmask[1] & FATTR4_WORD1_MODE)\n\t\t\tserver->caps |= NFS_CAP_MODE;\n\t\tif (res.attr_bitmask[1] & FATTR4_WORD1_NUMLINKS)\n\t\t\tserver->caps |= NFS_CAP_NLINK;\n\t\tif (res.attr_bitmask[1] & FATTR4_WORD1_OWNER)\n\t\t\tserver->caps |= NFS_CAP_OWNER;\n\t\tif (res.attr_bitmask[1] & FATTR4_WORD1_OWNER_GROUP)\n\t\t\tserver->caps |= NFS_CAP_OWNER_GROUP;\n\t\tif (res.attr_bitmask[1] & FATTR4_WORD1_TIME_ACCESS)\n\t\t\tserver->caps |= NFS_CAP_ATIME;\n\t\tif (res.attr_bitmask[1] & FATTR4_WORD1_TIME_METADATA)\n\t\t\tserver->caps |= NFS_CAP_CTIME;\n\t\tif (res.attr_bitmask[1] & FATTR4_WORD1_TIME_MODIFY)\n\t\t\tserver->caps |= NFS_CAP_MTIME;\n\n\t\tmemcpy(server->cache_consistency_bitmask, res.attr_bitmask, sizeof(server->cache_consistency_bitmask));\n\t\tserver->cache_consistency_bitmask[0] &= FATTR4_WORD0_CHANGE|FATTR4_WORD0_SIZE;\n\t\tserver->cache_consistency_bitmask[1] &= FATTR4_WORD1_TIME_METADATA|FATTR4_WORD1_TIME_MODIFY;\n\t\tserver->acl_bitmask = res.acl_bitmask;\n\t\tserver->fh_expire_type = res.fh_expire_type;\n\t}\n\n\treturn status;\n}\n\nint nfs4_server_capabilities(struct nfs_server *server, struct nfs_fh *fhandle)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(server,\n\t\t\t\t_nfs4_server_capabilities(server, fhandle),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int _nfs4_lookup_root(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\tstruct nfs_fsinfo *info)\n{\n\tstruct nfs4_lookup_root_arg args = {\n\t\t.bitmask = nfs4_fattr_bitmap,\n\t};\n\tstruct nfs4_lookup_res res = {\n\t\t.server = server,\n\t\t.fattr = info->fattr,\n\t\t.fh = fhandle,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LOOKUP_ROOT],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\n\tnfs_fattr_init(info->fattr);\n\treturn nfs4_call_sync(server->client, server, &msg, &args.seq_args, &res.seq_res, 0);\n}\n\nstatic int nfs4_lookup_root(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\tstruct nfs_fsinfo *info)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = _nfs4_lookup_root(server, fhandle, info);\n\t\tswitch (err) {\n\t\tcase 0:\n\t\tcase -NFS4ERR_WRONGSEC:\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\terr = nfs4_handle_exception(server, err, &exception);\n\t\t}\n\t} while (exception.retry);\nout:\n\treturn err;\n}\n\nstatic int nfs4_lookup_root_sec(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t\t\tstruct nfs_fsinfo *info, rpc_authflavor_t flavor)\n{\n\tstruct rpc_auth *auth;\n\tint ret;\n\n\tauth = rpcauth_create(flavor, server->client);\n\tif (IS_ERR(auth)) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\tret = nfs4_lookup_root(server, fhandle, info);\nout:\n\treturn ret;\n}\n\nstatic int nfs4_find_root_sec(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t\t      struct nfs_fsinfo *info)\n{\n\tint i, len, status = 0;\n\trpc_authflavor_t flav_array[NFS_MAX_SECFLAVORS];\n\n\tlen = rpcauth_list_flavors(flav_array, ARRAY_SIZE(flav_array));\n\tBUG_ON(len < 0);\n\n\tfor (i = 0; i < len; i++) {\n\t\t/* AUTH_UNIX is the default flavor if none was specified,\n\t\t * thus has already been tried. */\n\t\tif (flav_array[i] == RPC_AUTH_UNIX)\n\t\t\tcontinue;\n\n\t\tstatus = nfs4_lookup_root_sec(server, fhandle, info, flav_array[i]);\n\t\tif (status == -NFS4ERR_WRONGSEC || status == -EACCES)\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\t/*\n\t * -EACCESS could mean that the user doesn't have correct permissions\n\t * to access the mount.  It could also mean that we tried to mount\n\t * with a gss auth flavor, but rpc.gssd isn't running.  Either way,\n\t * existing mount programs don't handle -EACCES very well so it should\n\t * be mapped to -EPERM instead.\n\t */\n\tif (status == -EACCES)\n\t\tstatus = -EPERM;\n\treturn status;\n}\n\n/*\n * get the file handle for the \"/\" directory on the server\n */\nint nfs4_proc_get_rootfh(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t\t struct nfs_fsinfo *info)\n{\n\tint minor_version = server->nfs_client->cl_minorversion;\n\tint status = nfs4_lookup_root(server, fhandle, info);\n\tif ((status == -NFS4ERR_WRONGSEC) && !(server->flags & NFS_MOUNT_SECFLAVOUR))\n\t\t/*\n\t\t * A status of -NFS4ERR_WRONGSEC will be mapped to -EPERM\n\t\t * by nfs4_map_errors() as this function exits.\n\t\t */\n\t\tstatus = nfs_v4_minor_ops[minor_version]->find_root_sec(server, fhandle, info);\n\tif (status == 0)\n\t\tstatus = nfs4_server_capabilities(server, fhandle);\n\tif (status == 0)\n\t\tstatus = nfs4_do_fsinfo(server, fhandle, info);\n\treturn nfs4_map_errors(status);\n}\n\nstatic int nfs4_proc_get_root(struct nfs_server *server, struct nfs_fh *mntfh,\n\t\t\t      struct nfs_fsinfo *info)\n{\n\tint error;\n\tstruct nfs_fattr *fattr = info->fattr;\n\n\terror = nfs4_server_capabilities(server, mntfh);\n\tif (error < 0) {\n\t\tdprintk(\"nfs4_get_root: getcaps error = %d\\n\", -error);\n\t\treturn error;\n\t}\n\n\terror = nfs4_proc_getattr(server, mntfh, fattr);\n\tif (error < 0) {\n\t\tdprintk(\"nfs4_get_root: getattr error = %d\\n\", -error);\n\t\treturn error;\n\t}\n\n\tif (fattr->valid & NFS_ATTR_FATTR_FSID &&\n\t    !nfs_fsid_equal(&server->fsid, &fattr->fsid))\n\t\tmemcpy(&server->fsid, &fattr->fsid, sizeof(server->fsid));\n\n\treturn error;\n}\n\n/*\n * Get locations and (maybe) other attributes of a referral.\n * Note that we'll actually follow the referral later when\n * we detect fsid mismatch in inode revalidation\n */\nstatic int nfs4_get_referral(struct rpc_clnt *client, struct inode *dir,\n\t\t\t     const struct qstr *name, struct nfs_fattr *fattr,\n\t\t\t     struct nfs_fh *fhandle)\n{\n\tint status = -ENOMEM;\n\tstruct page *page = NULL;\n\tstruct nfs4_fs_locations *locations = NULL;\n\n\tpage = alloc_page(GFP_KERNEL);\n\tif (page == NULL)\n\t\tgoto out;\n\tlocations = kmalloc(sizeof(struct nfs4_fs_locations), GFP_KERNEL);\n\tif (locations == NULL)\n\t\tgoto out;\n\n\tstatus = nfs4_proc_fs_locations(client, dir, name, locations, page);\n\tif (status != 0)\n\t\tgoto out;\n\t/* Make sure server returned a different fsid for the referral */\n\tif (nfs_fsid_equal(&NFS_SERVER(dir)->fsid, &locations->fattr.fsid)) {\n\t\tdprintk(\"%s: server did not return a different fsid for\"\n\t\t\t\" a referral at %s\\n\", __func__, name->name);\n\t\tstatus = -EIO;\n\t\tgoto out;\n\t}\n\t/* Fixup attributes for the nfs_lookup() call to nfs_fhget() */\n\tnfs_fixup_referral_attributes(&locations->fattr);\n\n\t/* replace the lookup nfs_fattr with the locations nfs_fattr */\n\tmemcpy(fattr, &locations->fattr, sizeof(struct nfs_fattr));\n\tmemset(fhandle, 0, sizeof(struct nfs_fh));\nout:\n\tif (page)\n\t\t__free_page(page);\n\tkfree(locations);\n\treturn status;\n}\n\nstatic int _nfs4_proc_getattr(struct nfs_server *server, struct nfs_fh *fhandle, struct nfs_fattr *fattr)\n{\n\tstruct nfs4_getattr_arg args = {\n\t\t.fh = fhandle,\n\t\t.bitmask = server->attr_bitmask,\n\t};\n\tstruct nfs4_getattr_res res = {\n\t\t.fattr = fattr,\n\t\t.server = server,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETATTR],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\t\n\tnfs_fattr_init(fattr);\n\treturn nfs4_call_sync(server->client, server, &msg, &args.seq_args, &res.seq_res, 0);\n}\n\nstatic int nfs4_proc_getattr(struct nfs_server *server, struct nfs_fh *fhandle, struct nfs_fattr *fattr)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(server,\n\t\t\t\t_nfs4_proc_getattr(server, fhandle, fattr),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\n/* \n * The file is not closed if it is opened due to the a request to change\n * the size of the file. The open call will not be needed once the\n * VFS layer lookup-intents are implemented.\n *\n * Close is called when the inode is destroyed.\n * If we haven't opened the file for O_WRONLY, we\n * need to in the size_change case to obtain a stateid.\n *\n * Got race?\n * Because OPEN is always done by name in nfsv4, it is\n * possible that we opened a different file by the same\n * name.  We can recognize this race condition, but we\n * can't do anything about it besides returning an error.\n *\n * This will be fixed with VFS changes (lookup-intent).\n */\nstatic int\nnfs4_proc_setattr(struct dentry *dentry, struct nfs_fattr *fattr,\n\t\t  struct iattr *sattr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct rpc_cred *cred = NULL;\n\tstruct nfs4_state *state = NULL;\n\tint status;\n\n\tif (pnfs_ld_layoutret_on_setattr(inode))\n\t\tpnfs_return_layout(inode);\n\n\tnfs_fattr_init(fattr);\n\t\n\t/* Deal with open(O_TRUNC) */\n\tif (sattr->ia_valid & ATTR_OPEN)\n\t\tsattr->ia_valid &= ~(ATTR_MTIME|ATTR_CTIME|ATTR_OPEN);\n\n\t/* Optimization: if the end result is no change, don't RPC */\n\tif ((sattr->ia_valid & ~(ATTR_FILE)) == 0)\n\t\treturn 0;\n\n\t/* Search for an existing open(O_WRITE) file */\n\tif (sattr->ia_valid & ATTR_FILE) {\n\t\tstruct nfs_open_context *ctx;\n\n\t\tctx = nfs_file_open_context(sattr->ia_file);\n\t\tif (ctx) {\n\t\t\tcred = ctx->cred;\n\t\t\tstate = ctx->state;\n\t\t}\n\t}\n\n\tstatus = nfs4_do_setattr(inode, cred, fattr, sattr, state);\n\tif (status == 0)\n\t\tnfs_setattr_update_inode(inode, sattr);\n\treturn status;\n}\n\nstatic int _nfs4_proc_lookup(struct rpc_clnt *clnt, struct inode *dir,\n\t\tconst struct qstr *name, struct nfs_fh *fhandle,\n\t\tstruct nfs_fattr *fattr)\n{\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tint\t\t       status;\n\tstruct nfs4_lookup_arg args = {\n\t\t.bitmask = server->attr_bitmask,\n\t\t.dir_fh = NFS_FH(dir),\n\t\t.name = name,\n\t};\n\tstruct nfs4_lookup_res res = {\n\t\t.server = server,\n\t\t.fattr = fattr,\n\t\t.fh = fhandle,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LOOKUP],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\n\tnfs_fattr_init(fattr);\n\n\tdprintk(\"NFS call  lookup %s\\n\", name->name);\n\tstatus = nfs4_call_sync(clnt, server, &msg, &args.seq_args, &res.seq_res, 0);\n\tdprintk(\"NFS reply lookup: %d\\n\", status);\n\treturn status;\n}\n\nstatic void nfs_fixup_secinfo_attributes(struct nfs_fattr *fattr)\n{\n\tfattr->valid |= NFS_ATTR_FATTR_TYPE | NFS_ATTR_FATTR_MODE |\n\t\tNFS_ATTR_FATTR_NLINK | NFS_ATTR_FATTR_MOUNTPOINT;\n\tfattr->mode = S_IFDIR | S_IRUGO | S_IXUGO;\n\tfattr->nlink = 2;\n}\n\nstatic int nfs4_proc_lookup_common(struct rpc_clnt **clnt, struct inode *dir,\n\t\t\t\t   struct qstr *name, struct nfs_fh *fhandle,\n\t\t\t\t   struct nfs_fattr *fattr)\n{\n\tstruct nfs4_exception exception = { };\n\tstruct rpc_clnt *client = *clnt;\n\tint err;\n\tdo {\n\t\terr = _nfs4_proc_lookup(client, dir, name, fhandle, fattr);\n\t\tswitch (err) {\n\t\tcase -NFS4ERR_BADNAME:\n\t\t\terr = -ENOENT;\n\t\t\tgoto out;\n\t\tcase -NFS4ERR_MOVED:\n\t\t\terr = nfs4_get_referral(client, dir, name, fattr, fhandle);\n\t\t\tgoto out;\n\t\tcase -NFS4ERR_WRONGSEC:\n\t\t\terr = -EPERM;\n\t\t\tif (client != *clnt)\n\t\t\t\tgoto out;\n\n\t\t\tclient = nfs4_create_sec_client(client, dir, name);\n\t\t\tif (IS_ERR(client))\n\t\t\t\treturn PTR_ERR(client);\n\n\t\t\texception.retry = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = nfs4_handle_exception(NFS_SERVER(dir), err, &exception);\n\t\t}\n\t} while (exception.retry);\n\nout:\n\tif (err == 0)\n\t\t*clnt = client;\n\telse if (client != *clnt)\n\t\trpc_shutdown_client(client);\n\n\treturn err;\n}\n\nstatic int nfs4_proc_lookup(struct inode *dir, struct qstr *name,\n\t\t\t    struct nfs_fh *fhandle, struct nfs_fattr *fattr)\n{\n\tint status;\n\tstruct rpc_clnt *client = NFS_CLIENT(dir);\n\n\tstatus = nfs4_proc_lookup_common(&client, dir, name, fhandle, fattr);\n\tif (client != NFS_CLIENT(dir)) {\n\t\trpc_shutdown_client(client);\n\t\tnfs_fixup_secinfo_attributes(fattr);\n\t}\n\treturn status;\n}\n\nstruct rpc_clnt *\nnfs4_proc_lookup_mountpoint(struct inode *dir, struct qstr *name,\n\t\t\t    struct nfs_fh *fhandle, struct nfs_fattr *fattr)\n{\n\tint status;\n\tstruct rpc_clnt *client = rpc_clone_client(NFS_CLIENT(dir));\n\n\tstatus = nfs4_proc_lookup_common(&client, dir, name, fhandle, fattr);\n\tif (status < 0) {\n\t\trpc_shutdown_client(client);\n\t\treturn ERR_PTR(status);\n\t}\n\treturn client;\n}\n\nstatic int _nfs4_proc_access(struct inode *inode, struct nfs_access_entry *entry)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs4_accessargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.bitmask = server->cache_consistency_bitmask,\n\t};\n\tstruct nfs4_accessres res = {\n\t\t.server = server,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_ACCESS],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t\t.rpc_cred = entry->cred,\n\t};\n\tint mode = entry->mask;\n\tint status;\n\n\t/*\n\t * Determine which access bits we want to ask for...\n\t */\n\tif (mode & MAY_READ)\n\t\targs.access |= NFS4_ACCESS_READ;\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tif (mode & MAY_WRITE)\n\t\t\targs.access |= NFS4_ACCESS_MODIFY | NFS4_ACCESS_EXTEND | NFS4_ACCESS_DELETE;\n\t\tif (mode & MAY_EXEC)\n\t\t\targs.access |= NFS4_ACCESS_LOOKUP;\n\t} else {\n\t\tif (mode & MAY_WRITE)\n\t\t\targs.access |= NFS4_ACCESS_MODIFY | NFS4_ACCESS_EXTEND;\n\t\tif (mode & MAY_EXEC)\n\t\t\targs.access |= NFS4_ACCESS_EXECUTE;\n\t}\n\n\tres.fattr = nfs_alloc_fattr();\n\tif (res.fattr == NULL)\n\t\treturn -ENOMEM;\n\n\tstatus = nfs4_call_sync(server->client, server, &msg, &args.seq_args, &res.seq_res, 0);\n\tif (!status) {\n\t\tnfs_access_set_mask(entry, res.access);\n\t\tnfs_refresh_inode(inode, res.fattr);\n\t}\n\tnfs_free_fattr(res.fattr);\n\treturn status;\n}\n\nstatic int nfs4_proc_access(struct inode *inode, struct nfs_access_entry *entry)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(inode),\n\t\t\t\t_nfs4_proc_access(inode, entry),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\n/*\n * TODO: For the time being, we don't try to get any attributes\n * along with any of the zero-copy operations READ, READDIR,\n * READLINK, WRITE.\n *\n * In the case of the first three, we want to put the GETATTR\n * after the read-type operation -- this is because it is hard\n * to predict the length of a GETATTR response in v4, and thus\n * align the READ data correctly.  This means that the GETATTR\n * may end up partially falling into the page cache, and we should\n * shift it into the 'tail' of the xdr_buf before processing.\n * To do this efficiently, we need to know the total length\n * of data received, which doesn't seem to be available outside\n * of the RPC layer.\n *\n * In the case of WRITE, we also want to put the GETATTR after\n * the operation -- in this case because we want to make sure\n * we get the post-operation mtime and size.\n *\n * Both of these changes to the XDR layer would in fact be quite\n * minor, but I decided to leave them for a subsequent patch.\n */\nstatic int _nfs4_proc_readlink(struct inode *inode, struct page *page,\n\t\tunsigned int pgbase, unsigned int pglen)\n{\n\tstruct nfs4_readlink args = {\n\t\t.fh       = NFS_FH(inode),\n\t\t.pgbase\t  = pgbase,\n\t\t.pglen    = pglen,\n\t\t.pages    = &page,\n\t};\n\tstruct nfs4_readlink_res res;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_READLINK],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\n\treturn nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode), &msg, &args.seq_args, &res.seq_res, 0);\n}\n\nstatic int nfs4_proc_readlink(struct inode *inode, struct page *page,\n\t\tunsigned int pgbase, unsigned int pglen)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(inode),\n\t\t\t\t_nfs4_proc_readlink(inode, page, pgbase, pglen),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\n/*\n * This is just for mknod.  open(O_CREAT) will always do ->open_context().\n */\nstatic int\nnfs4_proc_create(struct inode *dir, struct dentry *dentry, struct iattr *sattr,\n\t\t int flags)\n{\n\tstruct nfs_open_context *ctx;\n\tstruct nfs4_state *state;\n\tint status = 0;\n\n\tctx = alloc_nfs_open_context(dentry, FMODE_READ);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tsattr->ia_mode &= ~current_umask();\n\tstate = nfs4_do_open(dir, dentry, ctx->mode,\n\t\t\tflags, sattr, ctx->cred,\n\t\t\t&ctx->mdsthreshold);\n\td_drop(dentry);\n\tif (IS_ERR(state)) {\n\t\tstatus = PTR_ERR(state);\n\t\tgoto out;\n\t}\n\td_add(dentry, igrab(state->inode));\n\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\tctx->state = state;\nout:\n\tput_nfs_open_context(ctx);\n\treturn status;\n}\n\nstatic int _nfs4_proc_remove(struct inode *dir, struct qstr *name)\n{\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tstruct nfs_removeargs args = {\n\t\t.fh = NFS_FH(dir),\n\t\t.name = *name,\n\t};\n\tstruct nfs_removeres res = {\n\t\t.server = server,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_REMOVE],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tint status;\n\n\tstatus = nfs4_call_sync(server->client, server, &msg, &args.seq_args, &res.seq_res, 1);\n\tif (status == 0)\n\t\tupdate_changeattr(dir, &res.cinfo);\n\treturn status;\n}\n\nstatic int nfs4_proc_remove(struct inode *dir, struct qstr *name)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(dir),\n\t\t\t\t_nfs4_proc_remove(dir, name),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic void nfs4_proc_unlink_setup(struct rpc_message *msg, struct inode *dir)\n{\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tstruct nfs_removeargs *args = msg->rpc_argp;\n\tstruct nfs_removeres *res = msg->rpc_resp;\n\n\tres->server = server;\n\tmsg->rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_REMOVE];\n\tnfs41_init_sequence(&args->seq_args, &res->seq_res, 1);\n}\n\nstatic void nfs4_proc_unlink_rpc_prepare(struct rpc_task *task, struct nfs_unlinkdata *data)\n{\n\tif (nfs4_setup_sequence(NFS_SERVER(data->dir),\n\t\t\t\t&data->args.seq_args,\n\t\t\t\t&data->res.seq_res,\n\t\t\t\ttask))\n\t\treturn;\n\trpc_call_start(task);\n}\n\nstatic int nfs4_proc_unlink_done(struct rpc_task *task, struct inode *dir)\n{\n\tstruct nfs_removeres *res = task->tk_msg.rpc_resp;\n\n\tif (!nfs4_sequence_done(task, &res->seq_res))\n\t\treturn 0;\n\tif (nfs4_async_handle_error(task, res->server, NULL) == -EAGAIN)\n\t\treturn 0;\n\tupdate_changeattr(dir, &res->cinfo);\n\treturn 1;\n}\n\nstatic void nfs4_proc_rename_setup(struct rpc_message *msg, struct inode *dir)\n{\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tstruct nfs_renameargs *arg = msg->rpc_argp;\n\tstruct nfs_renameres *res = msg->rpc_resp;\n\n\tmsg->rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_RENAME];\n\tres->server = server;\n\tnfs41_init_sequence(&arg->seq_args, &res->seq_res, 1);\n}\n\nstatic void nfs4_proc_rename_rpc_prepare(struct rpc_task *task, struct nfs_renamedata *data)\n{\n\tif (nfs4_setup_sequence(NFS_SERVER(data->old_dir),\n\t\t\t\t&data->args.seq_args,\n\t\t\t\t&data->res.seq_res,\n\t\t\t\ttask))\n\t\treturn;\n\trpc_call_start(task);\n}\n\nstatic int nfs4_proc_rename_done(struct rpc_task *task, struct inode *old_dir,\n\t\t\t\t struct inode *new_dir)\n{\n\tstruct nfs_renameres *res = task->tk_msg.rpc_resp;\n\n\tif (!nfs4_sequence_done(task, &res->seq_res))\n\t\treturn 0;\n\tif (nfs4_async_handle_error(task, res->server, NULL) == -EAGAIN)\n\t\treturn 0;\n\n\tupdate_changeattr(old_dir, &res->old_cinfo);\n\tupdate_changeattr(new_dir, &res->new_cinfo);\n\treturn 1;\n}\n\nstatic int _nfs4_proc_rename(struct inode *old_dir, struct qstr *old_name,\n\t\tstruct inode *new_dir, struct qstr *new_name)\n{\n\tstruct nfs_server *server = NFS_SERVER(old_dir);\n\tstruct nfs_renameargs arg = {\n\t\t.old_dir = NFS_FH(old_dir),\n\t\t.new_dir = NFS_FH(new_dir),\n\t\t.old_name = old_name,\n\t\t.new_name = new_name,\n\t};\n\tstruct nfs_renameres res = {\n\t\t.server = server,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_RENAME],\n\t\t.rpc_argp = &arg,\n\t\t.rpc_resp = &res,\n\t};\n\tint status = -ENOMEM;\n\t\n\tstatus = nfs4_call_sync(server->client, server, &msg, &arg.seq_args, &res.seq_res, 1);\n\tif (!status) {\n\t\tupdate_changeattr(old_dir, &res.old_cinfo);\n\t\tupdate_changeattr(new_dir, &res.new_cinfo);\n\t}\n\treturn status;\n}\n\nstatic int nfs4_proc_rename(struct inode *old_dir, struct qstr *old_name,\n\t\tstruct inode *new_dir, struct qstr *new_name)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(old_dir),\n\t\t\t\t_nfs4_proc_rename(old_dir, old_name,\n\t\t\t\t\tnew_dir, new_name),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int _nfs4_proc_link(struct inode *inode, struct inode *dir, struct qstr *name)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs4_link_arg arg = {\n\t\t.fh     = NFS_FH(inode),\n\t\t.dir_fh = NFS_FH(dir),\n\t\t.name   = name,\n\t\t.bitmask = server->attr_bitmask,\n\t};\n\tstruct nfs4_link_res res = {\n\t\t.server = server,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LINK],\n\t\t.rpc_argp = &arg,\n\t\t.rpc_resp = &res,\n\t};\n\tint status = -ENOMEM;\n\n\tres.fattr = nfs_alloc_fattr();\n\tif (res.fattr == NULL)\n\t\tgoto out;\n\n\tstatus = nfs4_call_sync(server->client, server, &msg, &arg.seq_args, &res.seq_res, 1);\n\tif (!status) {\n\t\tupdate_changeattr(dir, &res.cinfo);\n\t\tnfs_post_op_update_inode(inode, res.fattr);\n\t}\nout:\n\tnfs_free_fattr(res.fattr);\n\treturn status;\n}\n\nstatic int nfs4_proc_link(struct inode *inode, struct inode *dir, struct qstr *name)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(inode),\n\t\t\t\t_nfs4_proc_link(inode, dir, name),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstruct nfs4_createdata {\n\tstruct rpc_message msg;\n\tstruct nfs4_create_arg arg;\n\tstruct nfs4_create_res res;\n\tstruct nfs_fh fh;\n\tstruct nfs_fattr fattr;\n};\n\nstatic struct nfs4_createdata *nfs4_alloc_createdata(struct inode *dir,\n\t\tstruct qstr *name, struct iattr *sattr, u32 ftype)\n{\n\tstruct nfs4_createdata *data;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (data != NULL) {\n\t\tstruct nfs_server *server = NFS_SERVER(dir);\n\n\t\tdata->msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_CREATE];\n\t\tdata->msg.rpc_argp = &data->arg;\n\t\tdata->msg.rpc_resp = &data->res;\n\t\tdata->arg.dir_fh = NFS_FH(dir);\n\t\tdata->arg.server = server;\n\t\tdata->arg.name = name;\n\t\tdata->arg.attrs = sattr;\n\t\tdata->arg.ftype = ftype;\n\t\tdata->arg.bitmask = server->attr_bitmask;\n\t\tdata->res.server = server;\n\t\tdata->res.fh = &data->fh;\n\t\tdata->res.fattr = &data->fattr;\n\t\tnfs_fattr_init(data->res.fattr);\n\t}\n\treturn data;\n}\n\nstatic int nfs4_do_create(struct inode *dir, struct dentry *dentry, struct nfs4_createdata *data)\n{\n\tint status = nfs4_call_sync(NFS_SERVER(dir)->client, NFS_SERVER(dir), &data->msg,\n\t\t\t\t    &data->arg.seq_args, &data->res.seq_res, 1);\n\tif (status == 0) {\n\t\tupdate_changeattr(dir, &data->res.dir_cinfo);\n\t\tstatus = nfs_instantiate(dentry, data->res.fh, data->res.fattr);\n\t}\n\treturn status;\n}\n\nstatic void nfs4_free_createdata(struct nfs4_createdata *data)\n{\n\tkfree(data);\n}\n\nstatic int _nfs4_proc_symlink(struct inode *dir, struct dentry *dentry,\n\t\tstruct page *page, unsigned int len, struct iattr *sattr)\n{\n\tstruct nfs4_createdata *data;\n\tint status = -ENAMETOOLONG;\n\n\tif (len > NFS4_MAXPATHLEN)\n\t\tgoto out;\n\n\tstatus = -ENOMEM;\n\tdata = nfs4_alloc_createdata(dir, &dentry->d_name, sattr, NF4LNK);\n\tif (data == NULL)\n\t\tgoto out;\n\n\tdata->msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SYMLINK];\n\tdata->arg.u.symlink.pages = &page;\n\tdata->arg.u.symlink.len = len;\n\t\n\tstatus = nfs4_do_create(dir, dentry, data);\n\n\tnfs4_free_createdata(data);\nout:\n\treturn status;\n}\n\nstatic int nfs4_proc_symlink(struct inode *dir, struct dentry *dentry,\n\t\tstruct page *page, unsigned int len, struct iattr *sattr)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(dir),\n\t\t\t\t_nfs4_proc_symlink(dir, dentry, page,\n\t\t\t\t\t\t\tlen, sattr),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int _nfs4_proc_mkdir(struct inode *dir, struct dentry *dentry,\n\t\tstruct iattr *sattr)\n{\n\tstruct nfs4_createdata *data;\n\tint status = -ENOMEM;\n\n\tdata = nfs4_alloc_createdata(dir, &dentry->d_name, sattr, NF4DIR);\n\tif (data == NULL)\n\t\tgoto out;\n\n\tstatus = nfs4_do_create(dir, dentry, data);\n\n\tnfs4_free_createdata(data);\nout:\n\treturn status;\n}\n\nstatic int nfs4_proc_mkdir(struct inode *dir, struct dentry *dentry,\n\t\tstruct iattr *sattr)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\tsattr->ia_mode &= ~current_umask();\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(dir),\n\t\t\t\t_nfs4_proc_mkdir(dir, dentry, sattr),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int _nfs4_proc_readdir(struct dentry *dentry, struct rpc_cred *cred,\n\t\tu64 cookie, struct page **pages, unsigned int count, int plus)\n{\n\tstruct inode\t\t*dir = dentry->d_inode;\n\tstruct nfs4_readdir_arg args = {\n\t\t.fh = NFS_FH(dir),\n\t\t.pages = pages,\n\t\t.pgbase = 0,\n\t\t.count = count,\n\t\t.bitmask = NFS_SERVER(dentry->d_inode)->attr_bitmask,\n\t\t.plus = plus,\n\t};\n\tstruct nfs4_readdir_res res;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_READDIR],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t\t.rpc_cred = cred,\n\t};\n\tint\t\t\tstatus;\n\n\tdprintk(\"%s: dentry = %s/%s, cookie = %Lu\\n\", __func__,\n\t\t\tdentry->d_parent->d_name.name,\n\t\t\tdentry->d_name.name,\n\t\t\t(unsigned long long)cookie);\n\tnfs4_setup_readdir(cookie, NFS_I(dir)->cookieverf, dentry, &args);\n\tres.pgbase = args.pgbase;\n\tstatus = nfs4_call_sync(NFS_SERVER(dir)->client, NFS_SERVER(dir), &msg, &args.seq_args, &res.seq_res, 0);\n\tif (status >= 0) {\n\t\tmemcpy(NFS_I(dir)->cookieverf, res.verifier.data, NFS4_VERIFIER_SIZE);\n\t\tstatus += args.pgbase;\n\t}\n\n\tnfs_invalidate_atime(dir);\n\n\tdprintk(\"%s: returns %d\\n\", __func__, status);\n\treturn status;\n}\n\nstatic int nfs4_proc_readdir(struct dentry *dentry, struct rpc_cred *cred,\n\t\tu64 cookie, struct page **pages, unsigned int count, int plus)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(dentry->d_inode),\n\t\t\t\t_nfs4_proc_readdir(dentry, cred, cookie,\n\t\t\t\t\tpages, count, plus),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int _nfs4_proc_mknod(struct inode *dir, struct dentry *dentry,\n\t\tstruct iattr *sattr, dev_t rdev)\n{\n\tstruct nfs4_createdata *data;\n\tint mode = sattr->ia_mode;\n\tint status = -ENOMEM;\n\n\tBUG_ON(!(sattr->ia_valid & ATTR_MODE));\n\tBUG_ON(!S_ISFIFO(mode) && !S_ISBLK(mode) && !S_ISCHR(mode) && !S_ISSOCK(mode));\n\n\tdata = nfs4_alloc_createdata(dir, &dentry->d_name, sattr, NF4SOCK);\n\tif (data == NULL)\n\t\tgoto out;\n\n\tif (S_ISFIFO(mode))\n\t\tdata->arg.ftype = NF4FIFO;\n\telse if (S_ISBLK(mode)) {\n\t\tdata->arg.ftype = NF4BLK;\n\t\tdata->arg.u.device.specdata1 = MAJOR(rdev);\n\t\tdata->arg.u.device.specdata2 = MINOR(rdev);\n\t}\n\telse if (S_ISCHR(mode)) {\n\t\tdata->arg.ftype = NF4CHR;\n\t\tdata->arg.u.device.specdata1 = MAJOR(rdev);\n\t\tdata->arg.u.device.specdata2 = MINOR(rdev);\n\t}\n\t\n\tstatus = nfs4_do_create(dir, dentry, data);\n\n\tnfs4_free_createdata(data);\nout:\n\treturn status;\n}\n\nstatic int nfs4_proc_mknod(struct inode *dir, struct dentry *dentry,\n\t\tstruct iattr *sattr, dev_t rdev)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\tsattr->ia_mode &= ~current_umask();\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(dir),\n\t\t\t\t_nfs4_proc_mknod(dir, dentry, sattr, rdev),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int _nfs4_proc_statfs(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t struct nfs_fsstat *fsstat)\n{\n\tstruct nfs4_statfs_arg args = {\n\t\t.fh = fhandle,\n\t\t.bitmask = server->attr_bitmask,\n\t};\n\tstruct nfs4_statfs_res res = {\n\t\t.fsstat = fsstat,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_STATFS],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\n\tnfs_fattr_init(fsstat->fattr);\n\treturn  nfs4_call_sync(server->client, server, &msg, &args.seq_args, &res.seq_res, 0);\n}\n\nstatic int nfs4_proc_statfs(struct nfs_server *server, struct nfs_fh *fhandle, struct nfs_fsstat *fsstat)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(server,\n\t\t\t\t_nfs4_proc_statfs(server, fhandle, fsstat),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int _nfs4_do_fsinfo(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\tstruct nfs_fsinfo *fsinfo)\n{\n\tstruct nfs4_fsinfo_arg args = {\n\t\t.fh = fhandle,\n\t\t.bitmask = server->attr_bitmask,\n\t};\n\tstruct nfs4_fsinfo_res res = {\n\t\t.fsinfo = fsinfo,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_FSINFO],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\n\treturn nfs4_call_sync(server->client, server, &msg, &args.seq_args, &res.seq_res, 0);\n}\n\nstatic int nfs4_do_fsinfo(struct nfs_server *server, struct nfs_fh *fhandle, struct nfs_fsinfo *fsinfo)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\tdo {\n\t\terr = nfs4_handle_exception(server,\n\t\t\t\t_nfs4_do_fsinfo(server, fhandle, fsinfo),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int nfs4_proc_fsinfo(struct nfs_server *server, struct nfs_fh *fhandle, struct nfs_fsinfo *fsinfo)\n{\n\tint error;\n\n\tnfs_fattr_init(fsinfo->fattr);\n\terror = nfs4_do_fsinfo(server, fhandle, fsinfo);\n\tif (error == 0) {\n\t\t/* block layout checks this! */\n\t\tserver->pnfs_blksize = fsinfo->blksize;\n\t\tset_pnfs_layoutdriver(server, fhandle, fsinfo->layouttype);\n\t}\n\n\treturn error;\n}\n\nstatic int _nfs4_proc_pathconf(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\tstruct nfs_pathconf *pathconf)\n{\n\tstruct nfs4_pathconf_arg args = {\n\t\t.fh = fhandle,\n\t\t.bitmask = server->attr_bitmask,\n\t};\n\tstruct nfs4_pathconf_res res = {\n\t\t.pathconf = pathconf,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_PATHCONF],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\n\t/* None of the pathconf attributes are mandatory to implement */\n\tif ((args.bitmask[0] & nfs4_pathconf_bitmap[0]) == 0) {\n\t\tmemset(pathconf, 0, sizeof(*pathconf));\n\t\treturn 0;\n\t}\n\n\tnfs_fattr_init(pathconf->fattr);\n\treturn nfs4_call_sync(server->client, server, &msg, &args.seq_args, &res.seq_res, 0);\n}\n\nstatic int nfs4_proc_pathconf(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\tstruct nfs_pathconf *pathconf)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\tdo {\n\t\terr = nfs4_handle_exception(server,\n\t\t\t\t_nfs4_proc_pathconf(server, fhandle, pathconf),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nvoid __nfs4_read_done_cb(struct nfs_read_data *data)\n{\n\tnfs_invalidate_atime(data->header->inode);\n}\n\nstatic int nfs4_read_done_cb(struct rpc_task *task, struct nfs_read_data *data)\n{\n\tstruct nfs_server *server = NFS_SERVER(data->header->inode);\n\n\tif (nfs4_async_handle_error(task, server, data->args.context->state) == -EAGAIN) {\n\t\trpc_restart_call_prepare(task);\n\t\treturn -EAGAIN;\n\t}\n\n\t__nfs4_read_done_cb(data);\n\tif (task->tk_status > 0)\n\t\trenew_lease(server, data->timestamp);\n\treturn 0;\n}\n\nstatic int nfs4_read_done(struct rpc_task *task, struct nfs_read_data *data)\n{\n\n\tdprintk(\"--> %s\\n\", __func__);\n\n\tif (!nfs4_sequence_done(task, &data->res.seq_res))\n\t\treturn -EAGAIN;\n\n\treturn data->read_done_cb ? data->read_done_cb(task, data) :\n\t\t\t\t    nfs4_read_done_cb(task, data);\n}\n\nstatic void nfs4_proc_read_setup(struct nfs_read_data *data, struct rpc_message *msg)\n{\n\tdata->timestamp   = jiffies;\n\tdata->read_done_cb = nfs4_read_done_cb;\n\tmsg->rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_READ];\n\tnfs41_init_sequence(&data->args.seq_args, &data->res.seq_res, 0);\n}\n\nstatic void nfs4_proc_read_rpc_prepare(struct rpc_task *task, struct nfs_read_data *data)\n{\n\tif (nfs4_setup_sequence(NFS_SERVER(data->header->inode),\n\t\t\t\t&data->args.seq_args,\n\t\t\t\t&data->res.seq_res,\n\t\t\t\ttask))\n\t\treturn;\n\trpc_call_start(task);\n}\n\nstatic int nfs4_write_done_cb(struct rpc_task *task, struct nfs_write_data *data)\n{\n\tstruct inode *inode = data->header->inode;\n\t\n\tif (nfs4_async_handle_error(task, NFS_SERVER(inode), data->args.context->state) == -EAGAIN) {\n\t\trpc_restart_call_prepare(task);\n\t\treturn -EAGAIN;\n\t}\n\tif (task->tk_status >= 0) {\n\t\trenew_lease(NFS_SERVER(inode), data->timestamp);\n\t\tnfs_post_op_update_inode_force_wcc(inode, &data->fattr);\n\t}\n\treturn 0;\n}\n\nstatic int nfs4_write_done(struct rpc_task *task, struct nfs_write_data *data)\n{\n\tif (!nfs4_sequence_done(task, &data->res.seq_res))\n\t\treturn -EAGAIN;\n\treturn data->write_done_cb ? data->write_done_cb(task, data) :\n\t\tnfs4_write_done_cb(task, data);\n}\n\nstatic\nbool nfs4_write_need_cache_consistency_data(const struct nfs_write_data *data)\n{\n\tconst struct nfs_pgio_header *hdr = data->header;\n\n\t/* Don't request attributes for pNFS or O_DIRECT writes */\n\tif (data->ds_clp != NULL || hdr->dreq != NULL)\n\t\treturn false;\n\t/* Otherwise, request attributes if and only if we don't hold\n\t * a delegation\n\t */\n\treturn nfs4_have_delegation(hdr->inode, FMODE_READ) == 0;\n}\n\nstatic void nfs4_proc_write_setup(struct nfs_write_data *data, struct rpc_message *msg)\n{\n\tstruct nfs_server *server = NFS_SERVER(data->header->inode);\n\n\tif (!nfs4_write_need_cache_consistency_data(data)) {\n\t\tdata->args.bitmask = NULL;\n\t\tdata->res.fattr = NULL;\n\t} else\n\t\tdata->args.bitmask = server->cache_consistency_bitmask;\n\n\tif (!data->write_done_cb)\n\t\tdata->write_done_cb = nfs4_write_done_cb;\n\tdata->res.server = server;\n\tdata->timestamp   = jiffies;\n\n\tmsg->rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_WRITE];\n\tnfs41_init_sequence(&data->args.seq_args, &data->res.seq_res, 1);\n}\n\nstatic void nfs4_proc_write_rpc_prepare(struct rpc_task *task, struct nfs_write_data *data)\n{\n\tif (nfs4_setup_sequence(NFS_SERVER(data->header->inode),\n\t\t\t\t&data->args.seq_args,\n\t\t\t\t&data->res.seq_res,\n\t\t\t\ttask))\n\t\treturn;\n\trpc_call_start(task);\n}\n\nstatic void nfs4_proc_commit_rpc_prepare(struct rpc_task *task, struct nfs_commit_data *data)\n{\n\tif (nfs4_setup_sequence(NFS_SERVER(data->inode),\n\t\t\t\t&data->args.seq_args,\n\t\t\t\t&data->res.seq_res,\n\t\t\t\ttask))\n\t\treturn;\n\trpc_call_start(task);\n}\n\nstatic int nfs4_commit_done_cb(struct rpc_task *task, struct nfs_commit_data *data)\n{\n\tstruct inode *inode = data->inode;\n\n\tif (nfs4_async_handle_error(task, NFS_SERVER(inode), NULL) == -EAGAIN) {\n\t\trpc_restart_call_prepare(task);\n\t\treturn -EAGAIN;\n\t}\n\treturn 0;\n}\n\nstatic int nfs4_commit_done(struct rpc_task *task, struct nfs_commit_data *data)\n{\n\tif (!nfs4_sequence_done(task, &data->res.seq_res))\n\t\treturn -EAGAIN;\n\treturn data->commit_done_cb(task, data);\n}\n\nstatic void nfs4_proc_commit_setup(struct nfs_commit_data *data, struct rpc_message *msg)\n{\n\tstruct nfs_server *server = NFS_SERVER(data->inode);\n\n\tif (data->commit_done_cb == NULL)\n\t\tdata->commit_done_cb = nfs4_commit_done_cb;\n\tdata->res.server = server;\n\tmsg->rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_COMMIT];\n\tnfs41_init_sequence(&data->args.seq_args, &data->res.seq_res, 1);\n}\n\nstruct nfs4_renewdata {\n\tstruct nfs_client\t*client;\n\tunsigned long\t\ttimestamp;\n};\n\n/*\n * nfs4_proc_async_renew(): This is not one of the nfs_rpc_ops; it is a special\n * standalone procedure for queueing an asynchronous RENEW.\n */\nstatic void nfs4_renew_release(void *calldata)\n{\n\tstruct nfs4_renewdata *data = calldata;\n\tstruct nfs_client *clp = data->client;\n\n\tif (atomic_read(&clp->cl_count) > 1)\n\t\tnfs4_schedule_state_renewal(clp);\n\tnfs_put_client(clp);\n\tkfree(data);\n}\n\nstatic void nfs4_renew_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_renewdata *data = calldata;\n\tstruct nfs_client *clp = data->client;\n\tunsigned long timestamp = data->timestamp;\n\n\tif (task->tk_status < 0) {\n\t\t/* Unless we're shutting down, schedule state recovery! */\n\t\tif (test_bit(NFS_CS_RENEWD, &clp->cl_res_state) == 0)\n\t\t\treturn;\n\t\tif (task->tk_status != NFS4ERR_CB_PATH_DOWN) {\n\t\t\tnfs4_schedule_lease_recovery(clp);\n\t\t\treturn;\n\t\t}\n\t\tnfs4_schedule_path_down_recovery(clp);\n\t}\n\tdo_renew_lease(clp, timestamp);\n}\n\nstatic const struct rpc_call_ops nfs4_renew_ops = {\n\t.rpc_call_done = nfs4_renew_done,\n\t.rpc_release = nfs4_renew_release,\n};\n\nstatic int nfs4_proc_async_renew(struct nfs_client *clp, struct rpc_cred *cred, unsigned renew_flags)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_RENEW],\n\t\t.rpc_argp\t= clp,\n\t\t.rpc_cred\t= cred,\n\t};\n\tstruct nfs4_renewdata *data;\n\n\tif (renew_flags == 0)\n\t\treturn 0;\n\tif (!atomic_inc_not_zero(&clp->cl_count))\n\t\treturn -EIO;\n\tdata = kmalloc(sizeof(*data), GFP_NOFS);\n\tif (data == NULL)\n\t\treturn -ENOMEM;\n\tdata->client = clp;\n\tdata->timestamp = jiffies;\n\treturn rpc_call_async(clp->cl_rpcclient, &msg, RPC_TASK_SOFT,\n\t\t\t&nfs4_renew_ops, data);\n}\n\nstatic int nfs4_proc_renew(struct nfs_client *clp, struct rpc_cred *cred)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_RENEW],\n\t\t.rpc_argp\t= clp,\n\t\t.rpc_cred\t= cred,\n\t};\n\tunsigned long now = jiffies;\n\tint status;\n\n\tstatus = rpc_call_sync(clp->cl_rpcclient, &msg, 0);\n\tif (status < 0)\n\t\treturn status;\n\tdo_renew_lease(clp, now);\n\treturn 0;\n}\n\nstatic inline int nfs4_server_supports_acls(struct nfs_server *server)\n{\n\treturn (server->caps & NFS_CAP_ACLS)\n\t\t&& (server->acl_bitmask & ACL4_SUPPORT_ALLOW_ACL)\n\t\t&& (server->acl_bitmask & ACL4_SUPPORT_DENY_ACL);\n}\n\n/* Assuming that XATTR_SIZE_MAX is a multiple of PAGE_SIZE, and that\n * it's OK to put sizeof(void) * (XATTR_SIZE_MAX/PAGE_SIZE) bytes on\n * the stack.\n */\n#define NFS4ACL_MAXPAGES DIV_ROUND_UP(XATTR_SIZE_MAX, PAGE_SIZE)\n\nstatic int buf_to_pages_noslab(const void *buf, size_t buflen,\n\t\tstruct page **pages, unsigned int *pgbase)\n{\n\tstruct page *newpage, **spages;\n\tint rc = 0;\n\tsize_t len;\n\tspages = pages;\n\n\tdo {\n\t\tlen = min_t(size_t, PAGE_SIZE, buflen);\n\t\tnewpage = alloc_page(GFP_KERNEL);\n\n\t\tif (newpage == NULL)\n\t\t\tgoto unwind;\n\t\tmemcpy(page_address(newpage), buf, len);\n                buf += len;\n                buflen -= len;\n\t\t*pages++ = newpage;\n\t\trc++;\n\t} while (buflen != 0);\n\n\treturn rc;\n\nunwind:\n\tfor(; rc > 0; rc--)\n\t\t__free_page(spages[rc-1]);\n\treturn -ENOMEM;\n}\n\nstruct nfs4_cached_acl {\n\tint cached;\n\tsize_t len;\n\tchar data[0];\n};\n\nstatic void nfs4_set_cached_acl(struct inode *inode, struct nfs4_cached_acl *acl)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tspin_lock(&inode->i_lock);\n\tkfree(nfsi->nfs4_acl);\n\tnfsi->nfs4_acl = acl;\n\tspin_unlock(&inode->i_lock);\n}\n\nstatic void nfs4_zap_acl_attr(struct inode *inode)\n{\n\tnfs4_set_cached_acl(inode, NULL);\n}\n\nstatic inline ssize_t nfs4_read_cached_acl(struct inode *inode, char *buf, size_t buflen)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs4_cached_acl *acl;\n\tint ret = -ENOENT;\n\n\tspin_lock(&inode->i_lock);\n\tacl = nfsi->nfs4_acl;\n\tif (acl == NULL)\n\t\tgoto out;\n\tif (buf == NULL) /* user is just asking for length */\n\t\tgoto out_len;\n\tif (acl->cached == 0)\n\t\tgoto out;\n\tret = -ERANGE; /* see getxattr(2) man page */\n\tif (acl->len > buflen)\n\t\tgoto out;\n\tmemcpy(buf, acl->data, acl->len);\nout_len:\n\tret = acl->len;\nout:\n\tspin_unlock(&inode->i_lock);\n\treturn ret;\n}\n\nstatic void nfs4_write_cached_acl(struct inode *inode, struct page **pages, size_t pgbase, size_t acl_len)\n{\n\tstruct nfs4_cached_acl *acl;\n\tsize_t buflen = sizeof(*acl) + acl_len;\n\n\tif (buflen <= PAGE_SIZE) {\n\t\tacl = kmalloc(buflen, GFP_KERNEL);\n\t\tif (acl == NULL)\n\t\t\tgoto out;\n\t\tacl->cached = 1;\n\t\t_copy_from_pages(acl->data, pages, pgbase, acl_len);\n\t} else {\n\t\tacl = kmalloc(sizeof(*acl), GFP_KERNEL);\n\t\tif (acl == NULL)\n\t\t\tgoto out;\n\t\tacl->cached = 0;\n\t}\n\tacl->len = acl_len;\nout:\n\tnfs4_set_cached_acl(inode, acl);\n}\n\n/*\n * The getxattr API returns the required buffer length when called with a\n * NULL buf. The NFSv4 acl tool then calls getxattr again after allocating\n * the required buf.  On a NULL buf, we send a page of data to the server\n * guessing that the ACL request can be serviced by a page. If so, we cache\n * up to the page of ACL data, and the 2nd call to getxattr is serviced by\n * the cache. If not so, we throw away the page, and cache the required\n * length. The next getxattr call will then produce another round trip to\n * the server, this time with the input buf of the required size.\n */\nstatic ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf) {\n\t\tif (res.acl_len > buflen) {\n\t\t\tret = -ERANGE;\n\t\t\tgoto out_free;\n\t\t}\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\n\t}\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}\n\nstatic ssize_t nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct nfs4_exception exception = { };\n\tssize_t ret;\n\tdo {\n\t\tret = __nfs4_get_acl_uncached(inode, buf, buflen);\n\t\tif (ret >= 0)\n\t\t\tbreak;\n\t\tret = nfs4_handle_exception(NFS_SERVER(inode), ret, &exception);\n\t} while (exception.retry);\n\treturn ret;\n}\n\nstatic ssize_t nfs4_proc_get_acl(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tint ret;\n\n\tif (!nfs4_server_supports_acls(server))\n\t\treturn -EOPNOTSUPP;\n\tret = nfs_revalidate_inode(server, inode);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (NFS_I(inode)->cache_validity & NFS_INO_INVALID_ACL)\n\t\tnfs_zap_acl_cache(inode);\n\tret = nfs4_read_cached_acl(inode, buf, buflen);\n\tif (ret != -ENOENT)\n\t\t/* -ENOENT is returned if there is no ACL or if there is an ACL\n\t\t * but no cached acl data, just the acl length */\n\t\treturn ret;\n\treturn nfs4_get_acl_uncached(inode, buf, buflen);\n}\n\nstatic int __nfs4_proc_set_acl(struct inode *inode, const void *buf, size_t buflen)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct page *pages[NFS4ACL_MAXPAGES];\n\tstruct nfs_setaclargs arg = {\n\t\t.fh\t\t= NFS_FH(inode),\n\t\t.acl_pages\t= pages,\n\t\t.acl_len\t= buflen,\n\t};\n\tstruct nfs_setaclres res;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_SETACL],\n\t\t.rpc_argp\t= &arg,\n\t\t.rpc_resp\t= &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret, i;\n\n\tif (!nfs4_server_supports_acls(server))\n\t\treturn -EOPNOTSUPP;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\ti = buf_to_pages_noslab(buf, buflen, arg.acl_pages, &arg.acl_pgbase);\n\tif (i < 0)\n\t\treturn i;\n\tnfs4_inode_return_delegation(inode);\n\tret = nfs4_call_sync(server->client, server, &msg, &arg.seq_args, &res.seq_res, 1);\n\n\t/*\n\t * Free each page after tx, so the only ref left is\n\t * held by the network stack\n\t */\n\tfor (; i > 0; i--)\n\t\tput_page(pages[i-1]);\n\n\t/*\n\t * Acl update can result in inode attribute update.\n\t * so mark the attribute cache invalid.\n\t */\n\tspin_lock(&inode->i_lock);\n\tNFS_I(inode)->cache_validity |= NFS_INO_INVALID_ATTR;\n\tspin_unlock(&inode->i_lock);\n\tnfs_access_zap_cache(inode);\n\tnfs_zap_acl_cache(inode);\n\treturn ret;\n}\n\nstatic int nfs4_proc_set_acl(struct inode *inode, const void *buf, size_t buflen)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(inode),\n\t\t\t\t__nfs4_proc_set_acl(inode, buf, buflen),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int\nnfs4_async_handle_error(struct rpc_task *task, const struct nfs_server *server, struct nfs4_state *state)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\n\tif (task->tk_status >= 0)\n\t\treturn 0;\n\tswitch(task->tk_status) {\n\t\tcase -NFS4ERR_DELEG_REVOKED:\n\t\tcase -NFS4ERR_ADMIN_REVOKED:\n\t\tcase -NFS4ERR_BAD_STATEID:\n\t\t\tif (state == NULL)\n\t\t\t\tbreak;\n\t\t\tnfs_remove_bad_delegation(state->inode);\n\t\tcase -NFS4ERR_OPENMODE:\n\t\t\tif (state == NULL)\n\t\t\t\tbreak;\n\t\t\tnfs4_schedule_stateid_recovery(server, state);\n\t\t\tgoto wait_on_recovery;\n\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tif (state != NULL)\n\t\t\t\tnfs4_schedule_stateid_recovery(server, state);\n\t\tcase -NFS4ERR_STALE_STATEID:\n\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\t\tnfs4_schedule_lease_recovery(clp);\n\t\t\tgoto wait_on_recovery;\n#if defined(CONFIG_NFS_V4_1)\n\t\tcase -NFS4ERR_BADSESSION:\n\t\tcase -NFS4ERR_BADSLOT:\n\t\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\t\tcase -NFS4ERR_DEADSESSION:\n\t\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\tcase -NFS4ERR_SEQ_FALSE_RETRY:\n\t\tcase -NFS4ERR_SEQ_MISORDERED:\n\t\t\tdprintk(\"%s ERROR %d, Reset session\\n\", __func__,\n\t\t\t\ttask->tk_status);\n\t\t\tnfs4_schedule_session_recovery(clp->cl_session, task->tk_status);\n\t\t\ttask->tk_status = 0;\n\t\t\treturn -EAGAIN;\n#endif /* CONFIG_NFS_V4_1 */\n\t\tcase -NFS4ERR_DELAY:\n\t\t\tnfs_inc_server_stats(server, NFSIOS_DELAY);\n\t\tcase -NFS4ERR_GRACE:\n\t\tcase -EKEYEXPIRED:\n\t\t\trpc_delay(task, NFS4_POLL_RETRY_MAX);\n\t\t\ttask->tk_status = 0;\n\t\t\treturn -EAGAIN;\n\t\tcase -NFS4ERR_RETRY_UNCACHED_REP:\n\t\tcase -NFS4ERR_OLD_STATEID:\n\t\t\ttask->tk_status = 0;\n\t\t\treturn -EAGAIN;\n\t}\n\ttask->tk_status = nfs4_map_errors(task->tk_status);\n\treturn 0;\nwait_on_recovery:\n\trpc_sleep_on(&clp->cl_rpcwaitq, task, NULL);\n\tif (test_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state) == 0)\n\t\trpc_wake_up_queued_task(&clp->cl_rpcwaitq, task);\n\ttask->tk_status = 0;\n\treturn -EAGAIN;\n}\n\nstatic void nfs4_init_boot_verifier(const struct nfs_client *clp,\n\t\t\t\t    nfs4_verifier *bootverf)\n{\n\t__be32 verf[2];\n\n\tif (test_bit(NFS4CLNT_PURGE_STATE, &clp->cl_state)) {\n\t\t/* An impossible timestamp guarantees this value\n\t\t * will never match a generated boot time. */\n\t\tverf[0] = 0;\n\t\tverf[1] = (__be32)(NSEC_PER_SEC + 1);\n\t} else {\n\t\tstruct nfs_net *nn = net_generic(clp->cl_net, nfs_net_id);\n\t\tverf[0] = (__be32)nn->boot_time.tv_sec;\n\t\tverf[1] = (__be32)nn->boot_time.tv_nsec;\n\t}\n\tmemcpy(bootverf->data, verf, sizeof(bootverf->data));\n}\n\nstatic unsigned int\nnfs4_init_nonuniform_client_string(const struct nfs_client *clp,\n\t\t\t\t   char *buf, size_t len)\n{\n\tunsigned int result;\n\n\trcu_read_lock();\n\tresult = scnprintf(buf, len, \"Linux NFSv4.0 %s/%s %s\",\n\t\t\t\tclp->cl_ipaddr,\n\t\t\t\trpc_peeraddr2str(clp->cl_rpcclient,\n\t\t\t\t\t\t\tRPC_DISPLAY_ADDR),\n\t\t\t\trpc_peeraddr2str(clp->cl_rpcclient,\n\t\t\t\t\t\t\tRPC_DISPLAY_PROTO));\n\trcu_read_unlock();\n\treturn result;\n}\n\nstatic unsigned int\nnfs4_init_uniform_client_string(const struct nfs_client *clp,\n\t\t\t\tchar *buf, size_t len)\n{\n\tchar *nodename = clp->cl_rpcclient->cl_nodename;\n\n\tif (nfs4_client_id_uniquifier[0] != '\\0')\n\t\tnodename = nfs4_client_id_uniquifier;\n\treturn scnprintf(buf, len, \"Linux NFSv%u.%u %s\",\n\t\t\t\tclp->rpc_ops->version, clp->cl_minorversion,\n\t\t\t\tnodename);\n}\n\n/**\n * nfs4_proc_setclientid - Negotiate client ID\n * @clp: state data structure\n * @program: RPC program for NFSv4 callback service\n * @port: IP port number for NFS4 callback service\n * @cred: RPC credential to use for this call\n * @res: where to place the result\n *\n * Returns zero, a negative errno, or a negative NFS4ERR status code.\n */\nint nfs4_proc_setclientid(struct nfs_client *clp, u32 program,\n\t\tunsigned short port, struct rpc_cred *cred,\n\t\tstruct nfs4_setclientid_res *res)\n{\n\tnfs4_verifier sc_verifier;\n\tstruct nfs4_setclientid setclientid = {\n\t\t.sc_verifier = &sc_verifier,\n\t\t.sc_prog = program,\n\t\t.sc_cb_ident = clp->cl_cb_ident,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SETCLIENTID],\n\t\t.rpc_argp = &setclientid,\n\t\t.rpc_resp = res,\n\t\t.rpc_cred = cred,\n\t};\n\tint status;\n\n\t/* nfs_client_id4 */\n\tnfs4_init_boot_verifier(clp, &sc_verifier);\n\tif (test_bit(NFS_CS_MIGRATION, &clp->cl_flags))\n\t\tsetclientid.sc_name_len =\n\t\t\t\tnfs4_init_uniform_client_string(clp,\n\t\t\t\t\t\tsetclientid.sc_name,\n\t\t\t\t\t\tsizeof(setclientid.sc_name));\n\telse\n\t\tsetclientid.sc_name_len =\n\t\t\t\tnfs4_init_nonuniform_client_string(clp,\n\t\t\t\t\t\tsetclientid.sc_name,\n\t\t\t\t\t\tsizeof(setclientid.sc_name));\n\t/* cb_client4 */\n\trcu_read_lock();\n\tsetclientid.sc_netid_len = scnprintf(setclientid.sc_netid,\n\t\t\t\tsizeof(setclientid.sc_netid),\n\t\t\t\trpc_peeraddr2str(clp->cl_rpcclient,\n\t\t\t\t\t\t\tRPC_DISPLAY_NETID));\n\trcu_read_unlock();\n\tsetclientid.sc_uaddr_len = scnprintf(setclientid.sc_uaddr,\n\t\t\t\tsizeof(setclientid.sc_uaddr), \"%s.%u.%u\",\n\t\t\t\tclp->cl_ipaddr, port >> 8, port & 255);\n\n\tdprintk(\"NFS call  setclientid auth=%s, '%.*s'\\n\",\n\t\tclp->cl_rpcclient->cl_auth->au_ops->au_name,\n\t\tsetclientid.sc_name_len, setclientid.sc_name);\n\tstatus = rpc_call_sync(clp->cl_rpcclient, &msg, RPC_TASK_TIMEOUT);\n\tdprintk(\"NFS reply setclientid: %d\\n\", status);\n\treturn status;\n}\n\n/**\n * nfs4_proc_setclientid_confirm - Confirm client ID\n * @clp: state data structure\n * @res: result of a previous SETCLIENTID\n * @cred: RPC credential to use for this call\n *\n * Returns zero, a negative errno, or a negative NFS4ERR status code.\n */\nint nfs4_proc_setclientid_confirm(struct nfs_client *clp,\n\t\tstruct nfs4_setclientid_res *arg,\n\t\tstruct rpc_cred *cred)\n{\n\tstruct nfs_fsinfo fsinfo;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SETCLIENTID_CONFIRM],\n\t\t.rpc_argp = arg,\n\t\t.rpc_resp = &fsinfo,\n\t\t.rpc_cred = cred,\n\t};\n\tunsigned long now;\n\tint status;\n\n\tdprintk(\"NFS call  setclientid_confirm auth=%s, (client ID %llx)\\n\",\n\t\tclp->cl_rpcclient->cl_auth->au_ops->au_name,\n\t\tclp->cl_clientid);\n\tnow = jiffies;\n\tstatus = rpc_call_sync(clp->cl_rpcclient, &msg, RPC_TASK_TIMEOUT);\n\tif (status == 0) {\n\t\tspin_lock(&clp->cl_lock);\n\t\tclp->cl_lease_time = fsinfo.lease_time * HZ;\n\t\tclp->cl_last_renewal = now;\n\t\tspin_unlock(&clp->cl_lock);\n\t}\n\tdprintk(\"NFS reply setclientid_confirm: %d\\n\", status);\n\treturn status;\n}\n\nstruct nfs4_delegreturndata {\n\tstruct nfs4_delegreturnargs args;\n\tstruct nfs4_delegreturnres res;\n\tstruct nfs_fh fh;\n\tnfs4_stateid stateid;\n\tunsigned long timestamp;\n\tstruct nfs_fattr fattr;\n\tint rpc_status;\n};\n\nstatic void nfs4_delegreturn_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_delegreturndata *data = calldata;\n\n\tif (!nfs4_sequence_done(task, &data->res.seq_res))\n\t\treturn;\n\n\tswitch (task->tk_status) {\n\tcase -NFS4ERR_STALE_STATEID:\n\tcase -NFS4ERR_EXPIRED:\n\tcase 0:\n\t\trenew_lease(data->res.server, data->timestamp);\n\t\tbreak;\n\tdefault:\n\t\tif (nfs4_async_handle_error(task, data->res.server, NULL) ==\n\t\t\t\t-EAGAIN) {\n\t\t\trpc_restart_call_prepare(task);\n\t\t\treturn;\n\t\t}\n\t}\n\tdata->rpc_status = task->tk_status;\n}\n\nstatic void nfs4_delegreturn_release(void *calldata)\n{\n\tkfree(calldata);\n}\n\n#if defined(CONFIG_NFS_V4_1)\nstatic void nfs4_delegreturn_prepare(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_delegreturndata *d_data;\n\n\td_data = (struct nfs4_delegreturndata *)data;\n\n\tif (nfs4_setup_sequence(d_data->res.server,\n\t\t\t\t&d_data->args.seq_args,\n\t\t\t\t&d_data->res.seq_res, task))\n\t\treturn;\n\trpc_call_start(task);\n}\n#endif /* CONFIG_NFS_V4_1 */\n\nstatic const struct rpc_call_ops nfs4_delegreturn_ops = {\n#if defined(CONFIG_NFS_V4_1)\n\t.rpc_call_prepare = nfs4_delegreturn_prepare,\n#endif /* CONFIG_NFS_V4_1 */\n\t.rpc_call_done = nfs4_delegreturn_done,\n\t.rpc_release = nfs4_delegreturn_release,\n};\n\nstatic int _nfs4_proc_delegreturn(struct inode *inode, struct rpc_cred *cred, const nfs4_stateid *stateid, int issync)\n{\n\tstruct nfs4_delegreturndata *data;\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_DELEGRETURN],\n\t\t.rpc_cred = cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = server->client,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_delegreturn_ops,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\tint status = 0;\n\n\tdata = kzalloc(sizeof(*data), GFP_NOFS);\n\tif (data == NULL)\n\t\treturn -ENOMEM;\n\tnfs41_init_sequence(&data->args.seq_args, &data->res.seq_res, 1);\n\tdata->args.fhandle = &data->fh;\n\tdata->args.stateid = &data->stateid;\n\tdata->args.bitmask = server->cache_consistency_bitmask;\n\tnfs_copy_fh(&data->fh, NFS_FH(inode));\n\tnfs4_stateid_copy(&data->stateid, stateid);\n\tdata->res.fattr = &data->fattr;\n\tdata->res.server = server;\n\tnfs_fattr_init(data->res.fattr);\n\tdata->timestamp = jiffies;\n\tdata->rpc_status = 0;\n\n\ttask_setup_data.callback_data = data;\n\tmsg.rpc_argp = &data->args;\n\tmsg.rpc_resp = &data->res;\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tif (!issync)\n\t\tgoto out;\n\tstatus = nfs4_wait_for_completion_rpc_task(task);\n\tif (status != 0)\n\t\tgoto out;\n\tstatus = data->rpc_status;\n\tif (status == 0)\n\t\tnfs_post_op_update_inode_force_wcc(inode, &data->fattr);\n\telse\n\t\tnfs_refresh_inode(inode, &data->fattr);\nout:\n\trpc_put_task(task);\n\treturn status;\n}\n\nint nfs4_proc_delegreturn(struct inode *inode, struct rpc_cred *cred, const nfs4_stateid *stateid, int issync)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = _nfs4_proc_delegreturn(inode, cred, stateid, issync);\n\t\tswitch (err) {\n\t\t\tcase -NFS4ERR_STALE_STATEID:\n\t\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tcase 0:\n\t\t\t\treturn 0;\n\t\t}\n\t\terr = nfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\n#define NFS4_LOCK_MINTIMEOUT (1 * HZ)\n#define NFS4_LOCK_MAXTIMEOUT (30 * HZ)\n\n/* \n * sleep, with exponential backoff, and retry the LOCK operation. \n */\nstatic unsigned long\nnfs4_set_lock_task_retry(unsigned long timeout)\n{\n\tfreezable_schedule_timeout_killable(timeout);\n\ttimeout <<= 1;\n\tif (timeout > NFS4_LOCK_MAXTIMEOUT)\n\t\treturn NFS4_LOCK_MAXTIMEOUT;\n\treturn timeout;\n}\n\nstatic int _nfs4_proc_getlk(struct nfs4_state *state, int cmd, struct file_lock *request)\n{\n\tstruct inode *inode = state->inode;\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs_lockt_args arg = {\n\t\t.fh = NFS_FH(inode),\n\t\t.fl = request,\n\t};\n\tstruct nfs_lockt_res res = {\n\t\t.denied = request,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_LOCKT],\n\t\t.rpc_argp       = &arg,\n\t\t.rpc_resp       = &res,\n\t\t.rpc_cred\t= state->owner->so_cred,\n\t};\n\tstruct nfs4_lock_state *lsp;\n\tint status;\n\n\targ.lock_owner.clientid = clp->cl_clientid;\n\tstatus = nfs4_set_lock_state(state, request);\n\tif (status != 0)\n\t\tgoto out;\n\tlsp = request->fl_u.nfs4_fl.owner;\n\targ.lock_owner.id = lsp->ls_seqid.owner_id;\n\targ.lock_owner.s_dev = server->s_dev;\n\tstatus = nfs4_call_sync(server->client, server, &msg, &arg.seq_args, &res.seq_res, 1);\n\tswitch (status) {\n\t\tcase 0:\n\t\t\trequest->fl_type = F_UNLCK;\n\t\t\tbreak;\n\t\tcase -NFS4ERR_DENIED:\n\t\t\tstatus = 0;\n\t}\n\trequest->fl_ops->fl_release_private(request);\nout:\n\treturn status;\n}\n\nstatic int nfs4_proc_getlk(struct nfs4_state *state, int cmd, struct file_lock *request)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(state->inode),\n\t\t\t\t_nfs4_proc_getlk(state, cmd, request),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int do_vfs_lock(struct file *file, struct file_lock *fl)\n{\n\tint res = 0;\n\tswitch (fl->fl_flags & (FL_POSIX|FL_FLOCK)) {\n\t\tcase FL_POSIX:\n\t\t\tres = posix_lock_file_wait(file, fl);\n\t\t\tbreak;\n\t\tcase FL_FLOCK:\n\t\t\tres = flock_lock_file_wait(file, fl);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t}\n\treturn res;\n}\n\nstruct nfs4_unlockdata {\n\tstruct nfs_locku_args arg;\n\tstruct nfs_locku_res res;\n\tstruct nfs4_lock_state *lsp;\n\tstruct nfs_open_context *ctx;\n\tstruct file_lock fl;\n\tconst struct nfs_server *server;\n\tunsigned long timestamp;\n};\n\nstatic struct nfs4_unlockdata *nfs4_alloc_unlockdata(struct file_lock *fl,\n\t\tstruct nfs_open_context *ctx,\n\t\tstruct nfs4_lock_state *lsp,\n\t\tstruct nfs_seqid *seqid)\n{\n\tstruct nfs4_unlockdata *p;\n\tstruct inode *inode = lsp->ls_state->inode;\n\n\tp = kzalloc(sizeof(*p), GFP_NOFS);\n\tif (p == NULL)\n\t\treturn NULL;\n\tp->arg.fh = NFS_FH(inode);\n\tp->arg.fl = &p->fl;\n\tp->arg.seqid = seqid;\n\tp->res.seqid = seqid;\n\tp->arg.stateid = &lsp->ls_stateid;\n\tp->lsp = lsp;\n\tatomic_inc(&lsp->ls_count);\n\t/* Ensure we don't close file until we're done freeing locks! */\n\tp->ctx = get_nfs_open_context(ctx);\n\tmemcpy(&p->fl, fl, sizeof(p->fl));\n\tp->server = NFS_SERVER(inode);\n\treturn p;\n}\n\nstatic void nfs4_locku_release_calldata(void *data)\n{\n\tstruct nfs4_unlockdata *calldata = data;\n\tnfs_free_seqid(calldata->arg.seqid);\n\tnfs4_put_lock_state(calldata->lsp);\n\tput_nfs_open_context(calldata->ctx);\n\tkfree(calldata);\n}\n\nstatic void nfs4_locku_done(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_unlockdata *calldata = data;\n\n\tif (!nfs4_sequence_done(task, &calldata->res.seq_res))\n\t\treturn;\n\tswitch (task->tk_status) {\n\t\tcase 0:\n\t\t\tnfs4_stateid_copy(&calldata->lsp->ls_stateid,\n\t\t\t\t\t&calldata->res.stateid);\n\t\t\trenew_lease(calldata->server, calldata->timestamp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_BAD_STATEID:\n\t\tcase -NFS4ERR_OLD_STATEID:\n\t\tcase -NFS4ERR_STALE_STATEID:\n\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (nfs4_async_handle_error(task, calldata->server, NULL) == -EAGAIN)\n\t\t\t\trpc_restart_call_prepare(task);\n\t}\n\tnfs_release_seqid(calldata->arg.seqid);\n}\n\nstatic void nfs4_locku_prepare(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_unlockdata *calldata = data;\n\n\tif (nfs_wait_on_sequence(calldata->arg.seqid, task) != 0)\n\t\treturn;\n\tif (test_bit(NFS_LOCK_INITIALIZED, &calldata->lsp->ls_flags) == 0) {\n\t\t/* Note: exit _without_ running nfs4_locku_done */\n\t\ttask->tk_action = NULL;\n\t\treturn;\n\t}\n\tcalldata->timestamp = jiffies;\n\tif (nfs4_setup_sequence(calldata->server,\n\t\t\t\t&calldata->arg.seq_args,\n\t\t\t\t&calldata->res.seq_res,\n\t\t\t\ttask) != 0)\n\t\tnfs_release_seqid(calldata->arg.seqid);\n\telse\n\t\trpc_call_start(task);\n}\n\nstatic const struct rpc_call_ops nfs4_locku_ops = {\n\t.rpc_call_prepare = nfs4_locku_prepare,\n\t.rpc_call_done = nfs4_locku_done,\n\t.rpc_release = nfs4_locku_release_calldata,\n};\n\nstatic struct rpc_task *nfs4_do_unlck(struct file_lock *fl,\n\t\tstruct nfs_open_context *ctx,\n\t\tstruct nfs4_lock_state *lsp,\n\t\tstruct nfs_seqid *seqid)\n{\n\tstruct nfs4_unlockdata *data;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LOCKU],\n\t\t.rpc_cred = ctx->cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = NFS_CLIENT(lsp->ls_state->inode),\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_locku_ops,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\n\t/* Ensure this is an unlock - when canceling a lock, the\n\t * canceled lock is passed in, and it won't be an unlock.\n\t */\n\tfl->fl_type = F_UNLCK;\n\n\tdata = nfs4_alloc_unlockdata(fl, ctx, lsp, seqid);\n\tif (data == NULL) {\n\t\tnfs_free_seqid(seqid);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tnfs41_init_sequence(&data->arg.seq_args, &data->res.seq_res, 1);\n\tmsg.rpc_argp = &data->arg;\n\tmsg.rpc_resp = &data->res;\n\ttask_setup_data.callback_data = data;\n\treturn rpc_run_task(&task_setup_data);\n}\n\nstatic int nfs4_proc_unlck(struct nfs4_state *state, int cmd, struct file_lock *request)\n{\n\tstruct nfs_inode *nfsi = NFS_I(state->inode);\n\tstruct nfs_seqid *seqid;\n\tstruct nfs4_lock_state *lsp;\n\tstruct rpc_task *task;\n\tint status = 0;\n\tunsigned char fl_flags = request->fl_flags;\n\n\tstatus = nfs4_set_lock_state(state, request);\n\t/* Unlock _before_ we do the RPC call */\n\trequest->fl_flags |= FL_EXISTS;\n\tdown_read(&nfsi->rwsem);\n\tif (do_vfs_lock(request->fl_file, request) == -ENOENT) {\n\t\tup_read(&nfsi->rwsem);\n\t\tgoto out;\n\t}\n\tup_read(&nfsi->rwsem);\n\tif (status != 0)\n\t\tgoto out;\n\t/* Is this a delegated lock? */\n\tif (test_bit(NFS_DELEGATED_STATE, &state->flags))\n\t\tgoto out;\n\tlsp = request->fl_u.nfs4_fl.owner;\n\tseqid = nfs_alloc_seqid(&lsp->ls_seqid, GFP_KERNEL);\n\tstatus = -ENOMEM;\n\tif (seqid == NULL)\n\t\tgoto out;\n\ttask = nfs4_do_unlck(request, nfs_file_open_context(request->fl_file), lsp, seqid);\n\tstatus = PTR_ERR(task);\n\tif (IS_ERR(task))\n\t\tgoto out;\n\tstatus = nfs4_wait_for_completion_rpc_task(task);\n\trpc_put_task(task);\nout:\n\trequest->fl_flags = fl_flags;\n\treturn status;\n}\n\nstruct nfs4_lockdata {\n\tstruct nfs_lock_args arg;\n\tstruct nfs_lock_res res;\n\tstruct nfs4_lock_state *lsp;\n\tstruct nfs_open_context *ctx;\n\tstruct file_lock fl;\n\tunsigned long timestamp;\n\tint rpc_status;\n\tint cancelled;\n\tstruct nfs_server *server;\n};\n\nstatic struct nfs4_lockdata *nfs4_alloc_lockdata(struct file_lock *fl,\n\t\tstruct nfs_open_context *ctx, struct nfs4_lock_state *lsp,\n\t\tgfp_t gfp_mask)\n{\n\tstruct nfs4_lockdata *p;\n\tstruct inode *inode = lsp->ls_state->inode;\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\n\tp = kzalloc(sizeof(*p), gfp_mask);\n\tif (p == NULL)\n\t\treturn NULL;\n\n\tp->arg.fh = NFS_FH(inode);\n\tp->arg.fl = &p->fl;\n\tp->arg.open_seqid = nfs_alloc_seqid(&lsp->ls_state->owner->so_seqid, gfp_mask);\n\tif (p->arg.open_seqid == NULL)\n\t\tgoto out_free;\n\tp->arg.lock_seqid = nfs_alloc_seqid(&lsp->ls_seqid, gfp_mask);\n\tif (p->arg.lock_seqid == NULL)\n\t\tgoto out_free_seqid;\n\tp->arg.lock_stateid = &lsp->ls_stateid;\n\tp->arg.lock_owner.clientid = server->nfs_client->cl_clientid;\n\tp->arg.lock_owner.id = lsp->ls_seqid.owner_id;\n\tp->arg.lock_owner.s_dev = server->s_dev;\n\tp->res.lock_seqid = p->arg.lock_seqid;\n\tp->lsp = lsp;\n\tp->server = server;\n\tatomic_inc(&lsp->ls_count);\n\tp->ctx = get_nfs_open_context(ctx);\n\tmemcpy(&p->fl, fl, sizeof(p->fl));\n\treturn p;\nout_free_seqid:\n\tnfs_free_seqid(p->arg.open_seqid);\nout_free:\n\tkfree(p);\n\treturn NULL;\n}\n\nstatic void nfs4_lock_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_lockdata *data = calldata;\n\tstruct nfs4_state *state = data->lsp->ls_state;\n\n\tdprintk(\"%s: begin!\\n\", __func__);\n\tif (nfs_wait_on_sequence(data->arg.lock_seqid, task) != 0)\n\t\treturn;\n\t/* Do we need to do an open_to_lock_owner? */\n\tif (!(data->arg.lock_seqid->sequence->flags & NFS_SEQID_CONFIRMED)) {\n\t\tif (nfs_wait_on_sequence(data->arg.open_seqid, task) != 0)\n\t\t\tgoto out_release_lock_seqid;\n\t\tdata->arg.open_stateid = &state->stateid;\n\t\tdata->arg.new_lock_owner = 1;\n\t\tdata->res.open_seqid = data->arg.open_seqid;\n\t} else\n\t\tdata->arg.new_lock_owner = 0;\n\tdata->timestamp = jiffies;\n\tif (nfs4_setup_sequence(data->server,\n\t\t\t\t&data->arg.seq_args,\n\t\t\t\t&data->res.seq_res,\n\t\t\t\ttask) == 0) {\n\t\trpc_call_start(task);\n\t\treturn;\n\t}\n\tnfs_release_seqid(data->arg.open_seqid);\nout_release_lock_seqid:\n\tnfs_release_seqid(data->arg.lock_seqid);\n\tdprintk(\"%s: done!, ret = %d\\n\", __func__, task->tk_status);\n}\n\nstatic void nfs4_recover_lock_prepare(struct rpc_task *task, void *calldata)\n{\n\trpc_task_set_priority(task, RPC_PRIORITY_PRIVILEGED);\n\tnfs4_lock_prepare(task, calldata);\n}\n\nstatic void nfs4_lock_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_lockdata *data = calldata;\n\n\tdprintk(\"%s: begin!\\n\", __func__);\n\n\tif (!nfs4_sequence_done(task, &data->res.seq_res))\n\t\treturn;\n\n\tdata->rpc_status = task->tk_status;\n\tif (data->arg.new_lock_owner != 0) {\n\t\tif (data->rpc_status == 0)\n\t\t\tnfs_confirm_seqid(&data->lsp->ls_seqid, 0);\n\t\telse\n\t\t\tgoto out;\n\t}\n\tif (data->rpc_status == 0) {\n\t\tnfs4_stateid_copy(&data->lsp->ls_stateid, &data->res.stateid);\n\t\tset_bit(NFS_LOCK_INITIALIZED, &data->lsp->ls_flags);\n\t\trenew_lease(NFS_SERVER(data->ctx->dentry->d_inode), data->timestamp);\n\t}\nout:\n\tdprintk(\"%s: done, ret = %d!\\n\", __func__, data->rpc_status);\n}\n\nstatic void nfs4_lock_release(void *calldata)\n{\n\tstruct nfs4_lockdata *data = calldata;\n\n\tdprintk(\"%s: begin!\\n\", __func__);\n\tnfs_free_seqid(data->arg.open_seqid);\n\tif (data->cancelled != 0) {\n\t\tstruct rpc_task *task;\n\t\ttask = nfs4_do_unlck(&data->fl, data->ctx, data->lsp,\n\t\t\t\tdata->arg.lock_seqid);\n\t\tif (!IS_ERR(task))\n\t\t\trpc_put_task_async(task);\n\t\tdprintk(\"%s: cancelling lock!\\n\", __func__);\n\t} else\n\t\tnfs_free_seqid(data->arg.lock_seqid);\n\tnfs4_put_lock_state(data->lsp);\n\tput_nfs_open_context(data->ctx);\n\tkfree(data);\n\tdprintk(\"%s: done!\\n\", __func__);\n}\n\nstatic const struct rpc_call_ops nfs4_lock_ops = {\n\t.rpc_call_prepare = nfs4_lock_prepare,\n\t.rpc_call_done = nfs4_lock_done,\n\t.rpc_release = nfs4_lock_release,\n};\n\nstatic const struct rpc_call_ops nfs4_recover_lock_ops = {\n\t.rpc_call_prepare = nfs4_recover_lock_prepare,\n\t.rpc_call_done = nfs4_lock_done,\n\t.rpc_release = nfs4_lock_release,\n};\n\nstatic void nfs4_handle_setlk_error(struct nfs_server *server, struct nfs4_lock_state *lsp, int new_lock_owner, int error)\n{\n\tswitch (error) {\n\tcase -NFS4ERR_ADMIN_REVOKED:\n\tcase -NFS4ERR_BAD_STATEID:\n\t\tlsp->ls_seqid.flags &= ~NFS_SEQID_CONFIRMED;\n\t\tif (new_lock_owner != 0 ||\n\t\t   test_bit(NFS_LOCK_INITIALIZED, &lsp->ls_flags) != 0)\n\t\t\tnfs4_schedule_stateid_recovery(server, lsp->ls_state);\n\t\tbreak;\n\tcase -NFS4ERR_STALE_STATEID:\n\t\tlsp->ls_seqid.flags &= ~NFS_SEQID_CONFIRMED;\n\tcase -NFS4ERR_EXPIRED:\n\t\tnfs4_schedule_lease_recovery(server->nfs_client);\n\t};\n}\n\nstatic int _nfs4_do_setlk(struct nfs4_state *state, int cmd, struct file_lock *fl, int recovery_type)\n{\n\tstruct nfs4_lockdata *data;\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LOCK],\n\t\t.rpc_cred = state->owner->so_cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = NFS_CLIENT(state->inode),\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_lock_ops,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\tint ret;\n\n\tdprintk(\"%s: begin!\\n\", __func__);\n\tdata = nfs4_alloc_lockdata(fl, nfs_file_open_context(fl->fl_file),\n\t\t\tfl->fl_u.nfs4_fl.owner,\n\t\t\trecovery_type == NFS_LOCK_NEW ? GFP_KERNEL : GFP_NOFS);\n\tif (data == NULL)\n\t\treturn -ENOMEM;\n\tif (IS_SETLKW(cmd))\n\t\tdata->arg.block = 1;\n\tif (recovery_type > NFS_LOCK_NEW) {\n\t\tif (recovery_type == NFS_LOCK_RECLAIM)\n\t\t\tdata->arg.reclaim = NFS_LOCK_RECLAIM;\n\t\ttask_setup_data.callback_ops = &nfs4_recover_lock_ops;\n\t}\n\tnfs41_init_sequence(&data->arg.seq_args, &data->res.seq_res, 1);\n\tmsg.rpc_argp = &data->arg;\n\tmsg.rpc_resp = &data->res;\n\ttask_setup_data.callback_data = data;\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tret = nfs4_wait_for_completion_rpc_task(task);\n\tif (ret == 0) {\n\t\tret = data->rpc_status;\n\t\tif (ret)\n\t\t\tnfs4_handle_setlk_error(data->server, data->lsp,\n\t\t\t\t\tdata->arg.new_lock_owner, ret);\n\t} else\n\t\tdata->cancelled = 1;\n\trpc_put_task(task);\n\tdprintk(\"%s: done, ret = %d!\\n\", __func__, ret);\n\treturn ret;\n}\n\nstatic int nfs4_lock_reclaim(struct nfs4_state *state, struct file_lock *request)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs4_exception exception = {\n\t\t.inode = state->inode,\n\t};\n\tint err;\n\n\tdo {\n\t\t/* Cache the lock if possible... */\n\t\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) != 0)\n\t\t\treturn 0;\n\t\terr = _nfs4_do_setlk(state, F_SETLK, request, NFS_LOCK_RECLAIM);\n\t\tif (err != -NFS4ERR_DELAY)\n\t\t\tbreak;\n\t\tnfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int nfs4_lock_expired(struct nfs4_state *state, struct file_lock *request)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs4_exception exception = {\n\t\t.inode = state->inode,\n\t};\n\tint err;\n\n\terr = nfs4_set_lock_state(state, request);\n\tif (err != 0)\n\t\treturn err;\n\tdo {\n\t\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) != 0)\n\t\t\treturn 0;\n\t\terr = _nfs4_do_setlk(state, F_SETLK, request, NFS_LOCK_EXPIRED);\n\t\tswitch (err) {\n\t\tdefault:\n\t\t\tgoto out;\n\t\tcase -NFS4ERR_GRACE:\n\t\tcase -NFS4ERR_DELAY:\n\t\t\tnfs4_handle_exception(server, err, &exception);\n\t\t\terr = 0;\n\t\t}\n\t} while (exception.retry);\nout:\n\treturn err;\n}\n\n#if defined(CONFIG_NFS_V4_1)\n/**\n * nfs41_check_expired_locks - possibly free a lock stateid\n *\n * @state: NFSv4 state for an inode\n *\n * Returns NFS_OK if recovery for this stateid is now finished.\n * Otherwise a negative NFS4ERR value is returned.\n */\nstatic int nfs41_check_expired_locks(struct nfs4_state *state)\n{\n\tint status, ret = -NFS4ERR_BAD_STATEID;\n\tstruct nfs4_lock_state *lsp;\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\n\tlist_for_each_entry(lsp, &state->lock_states, ls_locks) {\n\t\tif (test_bit(NFS_LOCK_INITIALIZED, &lsp->ls_flags)) {\n\t\t\tstatus = nfs41_test_stateid(server, &lsp->ls_stateid);\n\t\t\tif (status != NFS_OK) {\n\t\t\t\t/* Free the stateid unless the server\n\t\t\t\t * informs us the stateid is unrecognized. */\n\t\t\t\tif (status != -NFS4ERR_BAD_STATEID)\n\t\t\t\t\tnfs41_free_stateid(server,\n\t\t\t\t\t\t\t&lsp->ls_stateid);\n\t\t\t\tclear_bit(NFS_LOCK_INITIALIZED, &lsp->ls_flags);\n\t\t\t\tret = status;\n\t\t\t}\n\t\t}\n\t};\n\n\treturn ret;\n}\n\nstatic int nfs41_lock_expired(struct nfs4_state *state, struct file_lock *request)\n{\n\tint status = NFS_OK;\n\n\tif (test_bit(LK_STATE_IN_USE, &state->flags))\n\t\tstatus = nfs41_check_expired_locks(state);\n\tif (status != NFS_OK)\n\t\tstatus = nfs4_lock_expired(state, request);\n\treturn status;\n}\n#endif\n\nstatic int _nfs4_proc_setlk(struct nfs4_state *state, int cmd, struct file_lock *request)\n{\n\tstruct nfs_inode *nfsi = NFS_I(state->inode);\n\tunsigned char fl_flags = request->fl_flags;\n\tint status = -ENOLCK;\n\n\tif ((fl_flags & FL_POSIX) &&\n\t\t\t!test_bit(NFS_STATE_POSIX_LOCKS, &state->flags))\n\t\tgoto out;\n\t/* Is this a delegated open? */\n\tstatus = nfs4_set_lock_state(state, request);\n\tif (status != 0)\n\t\tgoto out;\n\trequest->fl_flags |= FL_ACCESS;\n\tstatus = do_vfs_lock(request->fl_file, request);\n\tif (status < 0)\n\t\tgoto out;\n\tdown_read(&nfsi->rwsem);\n\tif (test_bit(NFS_DELEGATED_STATE, &state->flags)) {\n\t\t/* Yes: cache locks! */\n\t\t/* ...but avoid races with delegation recall... */\n\t\trequest->fl_flags = fl_flags & ~FL_SLEEP;\n\t\tstatus = do_vfs_lock(request->fl_file, request);\n\t\tgoto out_unlock;\n\t}\n\tstatus = _nfs4_do_setlk(state, cmd, request, NFS_LOCK_NEW);\n\tif (status != 0)\n\t\tgoto out_unlock;\n\t/* Note: we always want to sleep here! */\n\trequest->fl_flags = fl_flags | FL_SLEEP;\n\tif (do_vfs_lock(request->fl_file, request) < 0)\n\t\tprintk(KERN_WARNING \"NFS: %s: VFS is out of sync with lock \"\n\t\t\t\"manager!\\n\", __func__);\nout_unlock:\n\tup_read(&nfsi->rwsem);\nout:\n\trequest->fl_flags = fl_flags;\n\treturn status;\n}\n\nstatic int nfs4_proc_setlk(struct nfs4_state *state, int cmd, struct file_lock *request)\n{\n\tstruct nfs4_exception exception = {\n\t\t.state = state,\n\t\t.inode = state->inode,\n\t};\n\tint err;\n\n\tdo {\n\t\terr = _nfs4_proc_setlk(state, cmd, request);\n\t\tif (err == -NFS4ERR_DENIED)\n\t\t\terr = -EAGAIN;\n\t\terr = nfs4_handle_exception(NFS_SERVER(state->inode),\n\t\t\t\terr, &exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int\nnfs4_proc_lock(struct file *filp, int cmd, struct file_lock *request)\n{\n\tstruct nfs_open_context *ctx;\n\tstruct nfs4_state *state;\n\tunsigned long timeout = NFS4_LOCK_MINTIMEOUT;\n\tint status;\n\n\t/* verify open state */\n\tctx = nfs_file_open_context(filp);\n\tstate = ctx->state;\n\n\tif (request->fl_start < 0 || request->fl_end < 0)\n\t\treturn -EINVAL;\n\n\tif (IS_GETLK(cmd)) {\n\t\tif (state != NULL)\n\t\t\treturn nfs4_proc_getlk(state, F_GETLK, request);\n\t\treturn 0;\n\t}\n\n\tif (!(IS_SETLK(cmd) || IS_SETLKW(cmd)))\n\t\treturn -EINVAL;\n\n\tif (request->fl_type == F_UNLCK) {\n\t\tif (state != NULL)\n\t\t\treturn nfs4_proc_unlck(state, cmd, request);\n\t\treturn 0;\n\t}\n\n\tif (state == NULL)\n\t\treturn -ENOLCK;\n\t/*\n\t * Don't rely on the VFS having checked the file open mode,\n\t * since it won't do this for flock() locks.\n\t */\n\tswitch (request->fl_type) {\n\tcase F_RDLCK:\n\t\tif (!(filp->f_mode & FMODE_READ))\n\t\t\treturn -EBADF;\n\t\tbreak;\n\tcase F_WRLCK:\n\t\tif (!(filp->f_mode & FMODE_WRITE))\n\t\t\treturn -EBADF;\n\t}\n\n\tdo {\n\t\tstatus = nfs4_proc_setlk(state, cmd, request);\n\t\tif ((status != -EAGAIN) || IS_SETLK(cmd))\n\t\t\tbreak;\n\t\ttimeout = nfs4_set_lock_task_retry(timeout);\n\t\tstatus = -ERESTARTSYS;\n\t\tif (signalled())\n\t\t\tbreak;\n\t} while(status < 0);\n\treturn status;\n}\n\nint nfs4_lock_delegation_recall(struct nfs4_state *state, struct file_lock *fl)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\terr = nfs4_set_lock_state(state, fl);\n\tif (err != 0)\n\t\tgoto out;\n\tdo {\n\t\terr = _nfs4_do_setlk(state, F_SETLK, fl, NFS_LOCK_NEW);\n\t\tswitch (err) {\n\t\t\tdefault:\n\t\t\t\tprintk(KERN_ERR \"NFS: %s: unhandled error \"\n\t\t\t\t\t\"%d.\\n\", __func__, err);\n\t\t\tcase 0:\n\t\t\tcase -ESTALE:\n\t\t\t\tgoto out;\n\t\t\tcase -NFS4ERR_EXPIRED:\n\t\t\t\tnfs4_schedule_stateid_recovery(server, state);\n\t\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\t\tcase -NFS4ERR_STALE_STATEID:\n\t\t\t\tnfs4_schedule_lease_recovery(server->nfs_client);\n\t\t\t\tgoto out;\n\t\t\tcase -NFS4ERR_BADSESSION:\n\t\t\tcase -NFS4ERR_BADSLOT:\n\t\t\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\t\t\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\t\tcase -NFS4ERR_DEADSESSION:\n\t\t\t\tnfs4_schedule_session_recovery(server->nfs_client->cl_session, err);\n\t\t\t\tgoto out;\n\t\t\tcase -ERESTARTSYS:\n\t\t\t\t/*\n\t\t\t\t * The show must go on: exit, but mark the\n\t\t\t\t * stateid as needing recovery.\n\t\t\t\t */\n\t\t\tcase -NFS4ERR_DELEG_REVOKED:\n\t\t\tcase -NFS4ERR_ADMIN_REVOKED:\n\t\t\tcase -NFS4ERR_BAD_STATEID:\n\t\t\tcase -NFS4ERR_OPENMODE:\n\t\t\t\tnfs4_schedule_stateid_recovery(server, state);\n\t\t\t\terr = 0;\n\t\t\t\tgoto out;\n\t\t\tcase -EKEYEXPIRED:\n\t\t\t\t/*\n\t\t\t\t * User RPCSEC_GSS context has expired.\n\t\t\t\t * We cannot recover this stateid now, so\n\t\t\t\t * skip it and allow recovery thread to\n\t\t\t\t * proceed.\n\t\t\t\t */\n\t\t\t\terr = 0;\n\t\t\t\tgoto out;\n\t\t\tcase -ENOMEM:\n\t\t\tcase -NFS4ERR_DENIED:\n\t\t\t\t/* kill_proc(fl->fl_pid, SIGLOST, 1); */\n\t\t\t\terr = 0;\n\t\t\t\tgoto out;\n\t\t\tcase -NFS4ERR_DELAY:\n\t\t\t\tbreak;\n\t\t}\n\t\terr = nfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\nout:\n\treturn err;\n}\n\nstruct nfs_release_lockowner_data {\n\tstruct nfs4_lock_state *lsp;\n\tstruct nfs_server *server;\n\tstruct nfs_release_lockowner_args args;\n};\n\nstatic void nfs4_release_lockowner_release(void *calldata)\n{\n\tstruct nfs_release_lockowner_data *data = calldata;\n\tnfs4_free_lock_state(data->server, data->lsp);\n\tkfree(calldata);\n}\n\nstatic const struct rpc_call_ops nfs4_release_lockowner_ops = {\n\t.rpc_release = nfs4_release_lockowner_release,\n};\n\nint nfs4_release_lockowner(struct nfs4_lock_state *lsp)\n{\n\tstruct nfs_server *server = lsp->ls_state->owner->so_server;\n\tstruct nfs_release_lockowner_data *data;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_RELEASE_LOCKOWNER],\n\t};\n\n\tif (server->nfs_client->cl_mvops->minor_version != 0)\n\t\treturn -EINVAL;\n\tdata = kmalloc(sizeof(*data), GFP_NOFS);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tdata->lsp = lsp;\n\tdata->server = server;\n\tdata->args.lock_owner.clientid = server->nfs_client->cl_clientid;\n\tdata->args.lock_owner.id = lsp->ls_seqid.owner_id;\n\tdata->args.lock_owner.s_dev = server->s_dev;\n\tmsg.rpc_argp = &data->args;\n\trpc_call_async(server->client, &msg, 0, &nfs4_release_lockowner_ops, data);\n\treturn 0;\n}\n\n#define XATTR_NAME_NFSV4_ACL \"system.nfs4_acl\"\n\nstatic int nfs4_xattr_set_nfs4_acl(struct dentry *dentry, const char *key,\n\t\t\t\t   const void *buf, size_t buflen,\n\t\t\t\t   int flags, int type)\n{\n\tif (strcmp(key, \"\") != 0)\n\t\treturn -EINVAL;\n\n\treturn nfs4_proc_set_acl(dentry->d_inode, buf, buflen);\n}\n\nstatic int nfs4_xattr_get_nfs4_acl(struct dentry *dentry, const char *key,\n\t\t\t\t   void *buf, size_t buflen, int type)\n{\n\tif (strcmp(key, \"\") != 0)\n\t\treturn -EINVAL;\n\n\treturn nfs4_proc_get_acl(dentry->d_inode, buf, buflen);\n}\n\nstatic size_t nfs4_xattr_list_nfs4_acl(struct dentry *dentry, char *list,\n\t\t\t\t       size_t list_len, const char *name,\n\t\t\t\t       size_t name_len, int type)\n{\n\tsize_t len = sizeof(XATTR_NAME_NFSV4_ACL);\n\n\tif (!nfs4_server_supports_acls(NFS_SERVER(dentry->d_inode)))\n\t\treturn 0;\n\n\tif (list && len <= list_len)\n\t\tmemcpy(list, XATTR_NAME_NFSV4_ACL, len);\n\treturn len;\n}\n\n/*\n * nfs_fhget will use either the mounted_on_fileid or the fileid\n */\nstatic void nfs_fixup_referral_attributes(struct nfs_fattr *fattr)\n{\n\tif (!(((fattr->valid & NFS_ATTR_FATTR_MOUNTED_ON_FILEID) ||\n\t       (fattr->valid & NFS_ATTR_FATTR_FILEID)) &&\n\t      (fattr->valid & NFS_ATTR_FATTR_FSID) &&\n\t      (fattr->valid & NFS_ATTR_FATTR_V4_LOCATIONS)))\n\t\treturn;\n\n\tfattr->valid |= NFS_ATTR_FATTR_TYPE | NFS_ATTR_FATTR_MODE |\n\t\tNFS_ATTR_FATTR_NLINK | NFS_ATTR_FATTR_V4_REFERRAL;\n\tfattr->mode = S_IFDIR | S_IRUGO | S_IXUGO;\n\tfattr->nlink = 2;\n}\n\nstatic int _nfs4_proc_fs_locations(struct rpc_clnt *client, struct inode *dir,\n\t\t\t\t   const struct qstr *name,\n\t\t\t\t   struct nfs4_fs_locations *fs_locations,\n\t\t\t\t   struct page *page)\n{\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tu32 bitmask[2] = {\n\t\t[0] = FATTR4_WORD0_FSID | FATTR4_WORD0_FS_LOCATIONS,\n\t};\n\tstruct nfs4_fs_locations_arg args = {\n\t\t.dir_fh = NFS_FH(dir),\n\t\t.name = name,\n\t\t.page = page,\n\t\t.bitmask = bitmask,\n\t};\n\tstruct nfs4_fs_locations_res res = {\n\t\t.fs_locations = fs_locations,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_FS_LOCATIONS],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tint status;\n\n\tdprintk(\"%s: start\\n\", __func__);\n\n\t/* Ask for the fileid of the absent filesystem if mounted_on_fileid\n\t * is not supported */\n\tif (NFS_SERVER(dir)->attr_bitmask[1] & FATTR4_WORD1_MOUNTED_ON_FILEID)\n\t\tbitmask[1] |= FATTR4_WORD1_MOUNTED_ON_FILEID;\n\telse\n\t\tbitmask[0] |= FATTR4_WORD0_FILEID;\n\n\tnfs_fattr_init(&fs_locations->fattr);\n\tfs_locations->server = server;\n\tfs_locations->nlocations = 0;\n\tstatus = nfs4_call_sync(client, server, &msg, &args.seq_args, &res.seq_res, 0);\n\tdprintk(\"%s: returned status = %d\\n\", __func__, status);\n\treturn status;\n}\n\nint nfs4_proc_fs_locations(struct rpc_clnt *client, struct inode *dir,\n\t\t\t   const struct qstr *name,\n\t\t\t   struct nfs4_fs_locations *fs_locations,\n\t\t\t   struct page *page)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(dir),\n\t\t\t\t_nfs4_proc_fs_locations(client, dir, name, fs_locations, page),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int _nfs4_proc_secinfo(struct inode *dir, const struct qstr *name, struct nfs4_secinfo_flavors *flavors)\n{\n\tint status;\n\tstruct nfs4_secinfo_arg args = {\n\t\t.dir_fh = NFS_FH(dir),\n\t\t.name   = name,\n\t};\n\tstruct nfs4_secinfo_res res = {\n\t\t.flavors     = flavors,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SECINFO],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\n\tdprintk(\"NFS call  secinfo %s\\n\", name->name);\n\tstatus = nfs4_call_sync(NFS_SERVER(dir)->client, NFS_SERVER(dir), &msg, &args.seq_args, &res.seq_res, 0);\n\tdprintk(\"NFS reply  secinfo: %d\\n\", status);\n\treturn status;\n}\n\nint nfs4_proc_secinfo(struct inode *dir, const struct qstr *name,\n\t\t      struct nfs4_secinfo_flavors *flavors)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(dir),\n\t\t\t\t_nfs4_proc_secinfo(dir, name, flavors),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\n#ifdef CONFIG_NFS_V4_1\n/*\n * Check the exchange flags returned by the server for invalid flags, having\n * both PNFS and NON_PNFS flags set, and not having one of NON_PNFS, PNFS, or\n * DS flags set.\n */\nstatic int nfs4_check_cl_exchange_flags(u32 flags)\n{\n\tif (flags & ~EXCHGID4_FLAG_MASK_R)\n\t\tgoto out_inval;\n\tif ((flags & EXCHGID4_FLAG_USE_PNFS_MDS) &&\n\t    (flags & EXCHGID4_FLAG_USE_NON_PNFS))\n\t\tgoto out_inval;\n\tif (!(flags & (EXCHGID4_FLAG_MASK_PNFS)))\n\t\tgoto out_inval;\n\treturn NFS_OK;\nout_inval:\n\treturn -NFS4ERR_INVAL;\n}\n\nstatic bool\nnfs41_same_server_scope(struct nfs41_server_scope *a,\n\t\t\tstruct nfs41_server_scope *b)\n{\n\tif (a->server_scope_sz == b->server_scope_sz &&\n\t    memcmp(a->server_scope, b->server_scope, a->server_scope_sz) == 0)\n\t\treturn true;\n\n\treturn false;\n}\n\n/*\n * nfs4_proc_bind_conn_to_session()\n *\n * The 4.1 client currently uses the same TCP connection for the\n * fore and backchannel.\n */\nint nfs4_proc_bind_conn_to_session(struct nfs_client *clp, struct rpc_cred *cred)\n{\n\tint status;\n\tstruct nfs41_bind_conn_to_session_res res;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc =\n\t\t\t&nfs4_procedures[NFSPROC4_CLNT_BIND_CONN_TO_SESSION],\n\t\t.rpc_argp = clp,\n\t\t.rpc_resp = &res,\n\t\t.rpc_cred = cred,\n\t};\n\n\tdprintk(\"--> %s\\n\", __func__);\n\tBUG_ON(clp == NULL);\n\n\tres.session = kzalloc(sizeof(struct nfs4_session), GFP_NOFS);\n\tif (unlikely(res.session == NULL)) {\n\t\tstatus = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tstatus = rpc_call_sync(clp->cl_rpcclient, &msg, RPC_TASK_TIMEOUT);\n\tif (status == 0) {\n\t\tif (memcmp(res.session->sess_id.data,\n\t\t    clp->cl_session->sess_id.data, NFS4_MAX_SESSIONID_LEN)) {\n\t\t\tdprintk(\"NFS: %s: Session ID mismatch\\n\", __func__);\n\t\t\tstatus = -EIO;\n\t\t\tgoto out_session;\n\t\t}\n\t\tif (res.dir != NFS4_CDFS4_BOTH) {\n\t\t\tdprintk(\"NFS: %s: Unexpected direction from server\\n\",\n\t\t\t\t__func__);\n\t\t\tstatus = -EIO;\n\t\t\tgoto out_session;\n\t\t}\n\t\tif (res.use_conn_in_rdma_mode) {\n\t\t\tdprintk(\"NFS: %s: Server returned RDMA mode = true\\n\",\n\t\t\t\t__func__);\n\t\t\tstatus = -EIO;\n\t\t\tgoto out_session;\n\t\t}\n\t}\nout_session:\n\tkfree(res.session);\nout:\n\tdprintk(\"<-- %s status= %d\\n\", __func__, status);\n\treturn status;\n}\n\n/*\n * nfs4_proc_exchange_id()\n *\n * Returns zero, a negative errno, or a negative NFS4ERR status code.\n *\n * Since the clientid has expired, all compounds using sessions\n * associated with the stale clientid will be returning\n * NFS4ERR_BADSESSION in the sequence operation, and will therefore\n * be in some phase of session reset.\n */\nint nfs4_proc_exchange_id(struct nfs_client *clp, struct rpc_cred *cred)\n{\n\tnfs4_verifier verifier;\n\tstruct nfs41_exchange_id_args args = {\n\t\t.verifier = &verifier,\n\t\t.client = clp,\n\t\t.flags = EXCHGID4_FLAG_SUPP_MOVED_REFER,\n\t};\n\tstruct nfs41_exchange_id_res res = {\n\t\t0\n\t};\n\tint status;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_EXCHANGE_ID],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t\t.rpc_cred = cred,\n\t};\n\n\tnfs4_init_boot_verifier(clp, &verifier);\n\targs.id_len = nfs4_init_uniform_client_string(clp, args.id,\n\t\t\t\t\t\t\tsizeof(args.id));\n\tdprintk(\"NFS call  exchange_id auth=%s, '%.*s'\\n\",\n\t\tclp->cl_rpcclient->cl_auth->au_ops->au_name,\n\t\targs.id_len, args.id);\n\n\tres.server_owner = kzalloc(sizeof(struct nfs41_server_owner),\n\t\t\t\t\tGFP_NOFS);\n\tif (unlikely(res.server_owner == NULL)) {\n\t\tstatus = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tres.server_scope = kzalloc(sizeof(struct nfs41_server_scope),\n\t\t\t\t\tGFP_NOFS);\n\tif (unlikely(res.server_scope == NULL)) {\n\t\tstatus = -ENOMEM;\n\t\tgoto out_server_owner;\n\t}\n\n\tres.impl_id = kzalloc(sizeof(struct nfs41_impl_id), GFP_NOFS);\n\tif (unlikely(res.impl_id == NULL)) {\n\t\tstatus = -ENOMEM;\n\t\tgoto out_server_scope;\n\t}\n\n\tstatus = rpc_call_sync(clp->cl_rpcclient, &msg, RPC_TASK_TIMEOUT);\n\tif (status == 0)\n\t\tstatus = nfs4_check_cl_exchange_flags(res.flags);\n\n\tif (status == 0) {\n\t\tclp->cl_clientid = res.clientid;\n\t\tclp->cl_exchange_flags = (res.flags & ~EXCHGID4_FLAG_CONFIRMED_R);\n\t\tif (!(res.flags & EXCHGID4_FLAG_CONFIRMED_R))\n\t\t\tclp->cl_seqid = res.seqid;\n\n\t\tkfree(clp->cl_serverowner);\n\t\tclp->cl_serverowner = res.server_owner;\n\t\tres.server_owner = NULL;\n\n\t\t/* use the most recent implementation id */\n\t\tkfree(clp->cl_implid);\n\t\tclp->cl_implid = res.impl_id;\n\n\t\tif (clp->cl_serverscope != NULL &&\n\t\t    !nfs41_same_server_scope(clp->cl_serverscope,\n\t\t\t\t\t     res.server_scope)) {\n\t\t\tdprintk(\"%s: server_scope mismatch detected\\n\",\n\t\t\t\t__func__);\n\t\t\tset_bit(NFS4CLNT_SERVER_SCOPE_MISMATCH, &clp->cl_state);\n\t\t\tkfree(clp->cl_serverscope);\n\t\t\tclp->cl_serverscope = NULL;\n\t\t}\n\n\t\tif (clp->cl_serverscope == NULL) {\n\t\t\tclp->cl_serverscope = res.server_scope;\n\t\t\tgoto out;\n\t\t}\n\t} else\n\t\tkfree(res.impl_id);\n\nout_server_owner:\n\tkfree(res.server_owner);\nout_server_scope:\n\tkfree(res.server_scope);\nout:\n\tif (clp->cl_implid != NULL)\n\t\tdprintk(\"NFS reply exchange_id: Server Implementation ID: \"\n\t\t\t\"domain: %s, name: %s, date: %llu,%u\\n\",\n\t\t\tclp->cl_implid->domain, clp->cl_implid->name,\n\t\t\tclp->cl_implid->date.seconds,\n\t\t\tclp->cl_implid->date.nseconds);\n\tdprintk(\"NFS reply exchange_id: %d\\n\", status);\n\treturn status;\n}\n\nstatic int _nfs4_proc_destroy_clientid(struct nfs_client *clp,\n\t\tstruct rpc_cred *cred)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_DESTROY_CLIENTID],\n\t\t.rpc_argp = clp,\n\t\t.rpc_cred = cred,\n\t};\n\tint status;\n\n\tstatus = rpc_call_sync(clp->cl_rpcclient, &msg, RPC_TASK_TIMEOUT);\n\tif (status)\n\t\tdprintk(\"NFS: Got error %d from the server %s on \"\n\t\t\t\"DESTROY_CLIENTID.\", status, clp->cl_hostname);\n\treturn status;\n}\n\nstatic int nfs4_proc_destroy_clientid(struct nfs_client *clp,\n\t\tstruct rpc_cred *cred)\n{\n\tunsigned int loop;\n\tint ret;\n\n\tfor (loop = NFS4_MAX_LOOP_ON_RECOVER; loop != 0; loop--) {\n\t\tret = _nfs4_proc_destroy_clientid(clp, cred);\n\t\tswitch (ret) {\n\t\tcase -NFS4ERR_DELAY:\n\t\tcase -NFS4ERR_CLIENTID_BUSY:\n\t\t\tssleep(1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint nfs4_destroy_clientid(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred;\n\tint ret = 0;\n\n\tif (clp->cl_mvops->minor_version < 1)\n\t\tgoto out;\n\tif (clp->cl_exchange_flags == 0)\n\t\tgoto out;\n\tif (clp->cl_preserve_clid)\n\t\tgoto out;\n\tcred = nfs4_get_exchange_id_cred(clp);\n\tret = nfs4_proc_destroy_clientid(clp, cred);\n\tif (cred)\n\t\tput_rpccred(cred);\n\tswitch (ret) {\n\tcase 0:\n\tcase -NFS4ERR_STALE_CLIENTID:\n\t\tclp->cl_exchange_flags = 0;\n\t}\nout:\n\treturn ret;\n}\n\nstruct nfs4_get_lease_time_data {\n\tstruct nfs4_get_lease_time_args *args;\n\tstruct nfs4_get_lease_time_res *res;\n\tstruct nfs_client *clp;\n};\n\nstatic void nfs4_get_lease_time_prepare(struct rpc_task *task,\n\t\t\t\t\tvoid *calldata)\n{\n\tint ret;\n\tstruct nfs4_get_lease_time_data *data =\n\t\t\t(struct nfs4_get_lease_time_data *)calldata;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\trpc_task_set_priority(task, RPC_PRIORITY_PRIVILEGED);\n\t/* just setup sequence, do not trigger session recovery\n\t   since we're invoked within one */\n\tret = nfs41_setup_sequence(data->clp->cl_session,\n\t\t\t\t   &data->args->la_seq_args,\n\t\t\t\t   &data->res->lr_seq_res, task);\n\n\tBUG_ON(ret == -EAGAIN);\n\trpc_call_start(task);\n\tdprintk(\"<-- %s\\n\", __func__);\n}\n\n/*\n * Called from nfs4_state_manager thread for session setup, so don't recover\n * from sequence operation or clientid errors.\n */\nstatic void nfs4_get_lease_time_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_get_lease_time_data *data =\n\t\t\t(struct nfs4_get_lease_time_data *)calldata;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\tif (!nfs41_sequence_done(task, &data->res->lr_seq_res))\n\t\treturn;\n\tswitch (task->tk_status) {\n\tcase -NFS4ERR_DELAY:\n\tcase -NFS4ERR_GRACE:\n\t\tdprintk(\"%s Retry: tk_status %d\\n\", __func__, task->tk_status);\n\t\trpc_delay(task, NFS4_POLL_RETRY_MIN);\n\t\ttask->tk_status = 0;\n\t\t/* fall through */\n\tcase -NFS4ERR_RETRY_UNCACHED_REP:\n\t\trpc_restart_call_prepare(task);\n\t\treturn;\n\t}\n\tdprintk(\"<-- %s\\n\", __func__);\n}\n\nstatic const struct rpc_call_ops nfs4_get_lease_time_ops = {\n\t.rpc_call_prepare = nfs4_get_lease_time_prepare,\n\t.rpc_call_done = nfs4_get_lease_time_done,\n};\n\nint nfs4_proc_get_lease_time(struct nfs_client *clp, struct nfs_fsinfo *fsinfo)\n{\n\tstruct rpc_task *task;\n\tstruct nfs4_get_lease_time_args args;\n\tstruct nfs4_get_lease_time_res res = {\n\t\t.lr_fsinfo = fsinfo,\n\t};\n\tstruct nfs4_get_lease_time_data data = {\n\t\t.args = &args,\n\t\t.res = &res,\n\t\t.clp = clp,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GET_LEASE_TIME],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tstruct rpc_task_setup task_setup = {\n\t\t.rpc_client = clp->cl_rpcclient,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_get_lease_time_ops,\n\t\t.callback_data = &data,\n\t\t.flags = RPC_TASK_TIMEOUT,\n\t};\n\tint status;\n\n\tnfs41_init_sequence(&args.la_seq_args, &res.lr_seq_res, 0);\n\tdprintk(\"--> %s\\n\", __func__);\n\ttask = rpc_run_task(&task_setup);\n\n\tif (IS_ERR(task))\n\t\tstatus = PTR_ERR(task);\n\telse {\n\t\tstatus = task->tk_status;\n\t\trpc_put_task(task);\n\t}\n\tdprintk(\"<-- %s return %d\\n\", __func__, status);\n\n\treturn status;\n}\n\nstatic struct nfs4_slot *nfs4_alloc_slots(u32 max_slots, gfp_t gfp_flags)\n{\n\treturn kcalloc(max_slots, sizeof(struct nfs4_slot), gfp_flags);\n}\n\nstatic void nfs4_add_and_init_slots(struct nfs4_slot_table *tbl,\n\t\tstruct nfs4_slot *new,\n\t\tu32 max_slots,\n\t\tu32 ivalue)\n{\n\tstruct nfs4_slot *old = NULL;\n\tu32 i;\n\n\tspin_lock(&tbl->slot_tbl_lock);\n\tif (new) {\n\t\told = tbl->slots;\n\t\ttbl->slots = new;\n\t\ttbl->max_slots = max_slots;\n\t}\n\ttbl->highest_used_slotid = NFS4_NO_SLOT;\n\tfor (i = 0; i < tbl->max_slots; i++)\n\t\ttbl->slots[i].seq_nr = ivalue;\n\tspin_unlock(&tbl->slot_tbl_lock);\n\tkfree(old);\n}\n\n/*\n * (re)Initialise a slot table\n */\nstatic int nfs4_realloc_slot_table(struct nfs4_slot_table *tbl, u32 max_reqs,\n\t\t\t\t u32 ivalue)\n{\n\tstruct nfs4_slot *new = NULL;\n\tint ret = -ENOMEM;\n\n\tdprintk(\"--> %s: max_reqs=%u, tbl->max_slots %d\\n\", __func__,\n\t\tmax_reqs, tbl->max_slots);\n\n\t/* Does the newly negotiated max_reqs match the existing slot table? */\n\tif (max_reqs != tbl->max_slots) {\n\t\tnew = nfs4_alloc_slots(max_reqs, GFP_NOFS);\n\t\tif (!new)\n\t\t\tgoto out;\n\t}\n\tret = 0;\n\n\tnfs4_add_and_init_slots(tbl, new, max_reqs, ivalue);\n\tdprintk(\"%s: tbl=%p slots=%p max_slots=%d\\n\", __func__,\n\t\ttbl, tbl->slots, tbl->max_slots);\nout:\n\tdprintk(\"<-- %s: return %d\\n\", __func__, ret);\n\treturn ret;\n}\n\n/* Destroy the slot table */\nstatic void nfs4_destroy_slot_tables(struct nfs4_session *session)\n{\n\tif (session->fc_slot_table.slots != NULL) {\n\t\tkfree(session->fc_slot_table.slots);\n\t\tsession->fc_slot_table.slots = NULL;\n\t}\n\tif (session->bc_slot_table.slots != NULL) {\n\t\tkfree(session->bc_slot_table.slots);\n\t\tsession->bc_slot_table.slots = NULL;\n\t}\n\treturn;\n}\n\n/*\n * Initialize or reset the forechannel and backchannel tables\n */\nstatic int nfs4_setup_session_slot_tables(struct nfs4_session *ses)\n{\n\tstruct nfs4_slot_table *tbl;\n\tint status;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\t/* Fore channel */\n\ttbl = &ses->fc_slot_table;\n\tstatus = nfs4_realloc_slot_table(tbl, ses->fc_attrs.max_reqs, 1);\n\tif (status) /* -ENOMEM */\n\t\treturn status;\n\t/* Back channel */\n\ttbl = &ses->bc_slot_table;\n\tstatus = nfs4_realloc_slot_table(tbl, ses->bc_attrs.max_reqs, 0);\n\tif (status && tbl->slots == NULL)\n\t\t/* Fore and back channel share a connection so get\n\t\t * both slot tables or neither */\n\t\tnfs4_destroy_slot_tables(ses);\n\treturn status;\n}\n\nstruct nfs4_session *nfs4_alloc_session(struct nfs_client *clp)\n{\n\tstruct nfs4_session *session;\n\tstruct nfs4_slot_table *tbl;\n\n\tsession = kzalloc(sizeof(struct nfs4_session), GFP_NOFS);\n\tif (!session)\n\t\treturn NULL;\n\n\ttbl = &session->fc_slot_table;\n\ttbl->highest_used_slotid = NFS4_NO_SLOT;\n\tspin_lock_init(&tbl->slot_tbl_lock);\n\trpc_init_priority_wait_queue(&tbl->slot_tbl_waitq, \"ForeChannel Slot table\");\n\tinit_completion(&tbl->complete);\n\n\ttbl = &session->bc_slot_table;\n\ttbl->highest_used_slotid = NFS4_NO_SLOT;\n\tspin_lock_init(&tbl->slot_tbl_lock);\n\trpc_init_wait_queue(&tbl->slot_tbl_waitq, \"BackChannel Slot table\");\n\tinit_completion(&tbl->complete);\n\n\tsession->session_state = 1<<NFS4_SESSION_INITING;\n\n\tsession->clp = clp;\n\treturn session;\n}\n\nvoid nfs4_destroy_session(struct nfs4_session *session)\n{\n\tstruct rpc_xprt *xprt;\n\tstruct rpc_cred *cred;\n\n\tcred = nfs4_get_exchange_id_cred(session->clp);\n\tnfs4_proc_destroy_session(session, cred);\n\tif (cred)\n\t\tput_rpccred(cred);\n\n\trcu_read_lock();\n\txprt = rcu_dereference(session->clp->cl_rpcclient->cl_xprt);\n\trcu_read_unlock();\n\tdprintk(\"%s Destroy backchannel for xprt %p\\n\",\n\t\t__func__, xprt);\n\txprt_destroy_backchannel(xprt, NFS41_BC_MIN_CALLBACKS);\n\tnfs4_destroy_slot_tables(session);\n\tkfree(session);\n}\n\n/*\n * Initialize the values to be used by the client in CREATE_SESSION\n * If nfs4_init_session set the fore channel request and response sizes,\n * use them.\n *\n * Set the back channel max_resp_sz_cached to zero to force the client to\n * always set csa_cachethis to FALSE because the current implementation\n * of the back channel DRC only supports caching the CB_SEQUENCE operation.\n */\nstatic void nfs4_init_channel_attrs(struct nfs41_create_session_args *args)\n{\n\tstruct nfs4_session *session = args->client->cl_session;\n\tunsigned int mxrqst_sz = session->fc_attrs.max_rqst_sz,\n\t\t     mxresp_sz = session->fc_attrs.max_resp_sz;\n\n\tif (mxrqst_sz == 0)\n\t\tmxrqst_sz = NFS_MAX_FILE_IO_SIZE;\n\tif (mxresp_sz == 0)\n\t\tmxresp_sz = NFS_MAX_FILE_IO_SIZE;\n\t/* Fore channel attributes */\n\targs->fc_attrs.max_rqst_sz = mxrqst_sz;\n\targs->fc_attrs.max_resp_sz = mxresp_sz;\n\targs->fc_attrs.max_ops = NFS4_MAX_OPS;\n\targs->fc_attrs.max_reqs = max_session_slots;\n\n\tdprintk(\"%s: Fore Channel : max_rqst_sz=%u max_resp_sz=%u \"\n\t\t\"max_ops=%u max_reqs=%u\\n\",\n\t\t__func__,\n\t\targs->fc_attrs.max_rqst_sz, args->fc_attrs.max_resp_sz,\n\t\targs->fc_attrs.max_ops, args->fc_attrs.max_reqs);\n\n\t/* Back channel attributes */\n\targs->bc_attrs.max_rqst_sz = PAGE_SIZE;\n\targs->bc_attrs.max_resp_sz = PAGE_SIZE;\n\targs->bc_attrs.max_resp_sz_cached = 0;\n\targs->bc_attrs.max_ops = NFS4_MAX_BACK_CHANNEL_OPS;\n\targs->bc_attrs.max_reqs = 1;\n\n\tdprintk(\"%s: Back Channel : max_rqst_sz=%u max_resp_sz=%u \"\n\t\t\"max_resp_sz_cached=%u max_ops=%u max_reqs=%u\\n\",\n\t\t__func__,\n\t\targs->bc_attrs.max_rqst_sz, args->bc_attrs.max_resp_sz,\n\t\targs->bc_attrs.max_resp_sz_cached, args->bc_attrs.max_ops,\n\t\targs->bc_attrs.max_reqs);\n}\n\nstatic int nfs4_verify_fore_channel_attrs(struct nfs41_create_session_args *args, struct nfs4_session *session)\n{\n\tstruct nfs4_channel_attrs *sent = &args->fc_attrs;\n\tstruct nfs4_channel_attrs *rcvd = &session->fc_attrs;\n\n\tif (rcvd->max_resp_sz > sent->max_resp_sz)\n\t\treturn -EINVAL;\n\t/*\n\t * Our requested max_ops is the minimum we need; we're not\n\t * prepared to break up compounds into smaller pieces than that.\n\t * So, no point even trying to continue if the server won't\n\t * cooperate:\n\t */\n\tif (rcvd->max_ops < sent->max_ops)\n\t\treturn -EINVAL;\n\tif (rcvd->max_reqs == 0)\n\t\treturn -EINVAL;\n\tif (rcvd->max_reqs > NFS4_MAX_SLOT_TABLE)\n\t\trcvd->max_reqs = NFS4_MAX_SLOT_TABLE;\n\treturn 0;\n}\n\nstatic int nfs4_verify_back_channel_attrs(struct nfs41_create_session_args *args, struct nfs4_session *session)\n{\n\tstruct nfs4_channel_attrs *sent = &args->bc_attrs;\n\tstruct nfs4_channel_attrs *rcvd = &session->bc_attrs;\n\n\tif (rcvd->max_rqst_sz > sent->max_rqst_sz)\n\t\treturn -EINVAL;\n\tif (rcvd->max_resp_sz < sent->max_resp_sz)\n\t\treturn -EINVAL;\n\tif (rcvd->max_resp_sz_cached > sent->max_resp_sz_cached)\n\t\treturn -EINVAL;\n\t/* These would render the backchannel useless: */\n\tif (rcvd->max_ops != sent->max_ops)\n\t\treturn -EINVAL;\n\tif (rcvd->max_reqs != sent->max_reqs)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int nfs4_verify_channel_attrs(struct nfs41_create_session_args *args,\n\t\t\t\t     struct nfs4_session *session)\n{\n\tint ret;\n\n\tret = nfs4_verify_fore_channel_attrs(args, session);\n\tif (ret)\n\t\treturn ret;\n\treturn nfs4_verify_back_channel_attrs(args, session);\n}\n\nstatic int _nfs4_proc_create_session(struct nfs_client *clp,\n\t\tstruct rpc_cred *cred)\n{\n\tstruct nfs4_session *session = clp->cl_session;\n\tstruct nfs41_create_session_args args = {\n\t\t.client = clp,\n\t\t.cb_program = NFS4_CALLBACK,\n\t};\n\tstruct nfs41_create_session_res res = {\n\t\t.client = clp,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_CREATE_SESSION],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t\t.rpc_cred = cred,\n\t};\n\tint status;\n\n\tnfs4_init_channel_attrs(&args);\n\targs.flags = (SESSION4_PERSIST | SESSION4_BACK_CHAN);\n\n\tstatus = rpc_call_sync(session->clp->cl_rpcclient, &msg, RPC_TASK_TIMEOUT);\n\n\tif (!status)\n\t\t/* Verify the session's negotiated channel_attrs values */\n\t\tstatus = nfs4_verify_channel_attrs(&args, session);\n\tif (!status) {\n\t\t/* Increment the clientid slot sequence id */\n\t\tclp->cl_seqid++;\n\t}\n\n\treturn status;\n}\n\n/*\n * Issues a CREATE_SESSION operation to the server.\n * It is the responsibility of the caller to verify the session is\n * expired before calling this routine.\n */\nint nfs4_proc_create_session(struct nfs_client *clp, struct rpc_cred *cred)\n{\n\tint status;\n\tunsigned *ptr;\n\tstruct nfs4_session *session = clp->cl_session;\n\n\tdprintk(\"--> %s clp=%p session=%p\\n\", __func__, clp, session);\n\n\tstatus = _nfs4_proc_create_session(clp, cred);\n\tif (status)\n\t\tgoto out;\n\n\t/* Init or reset the session slot tables */\n\tstatus = nfs4_setup_session_slot_tables(session);\n\tdprintk(\"slot table setup returned %d\\n\", status);\n\tif (status)\n\t\tgoto out;\n\n\tptr = (unsigned *)&session->sess_id.data[0];\n\tdprintk(\"%s client>seqid %d sessionid %u:%u:%u:%u\\n\", __func__,\n\t\tclp->cl_seqid, ptr[0], ptr[1], ptr[2], ptr[3]);\nout:\n\tdprintk(\"<-- %s\\n\", __func__);\n\treturn status;\n}\n\n/*\n * Issue the over-the-wire RPC DESTROY_SESSION.\n * The caller must serialize access to this routine.\n */\nint nfs4_proc_destroy_session(struct nfs4_session *session,\n\t\tstruct rpc_cred *cred)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_DESTROY_SESSION],\n\t\t.rpc_argp = session,\n\t\t.rpc_cred = cred,\n\t};\n\tint status = 0;\n\n\tdprintk(\"--> nfs4_proc_destroy_session\\n\");\n\n\t/* session is still being setup */\n\tif (session->clp->cl_cons_state != NFS_CS_READY)\n\t\treturn status;\n\n\tstatus = rpc_call_sync(session->clp->cl_rpcclient, &msg, RPC_TASK_TIMEOUT);\n\n\tif (status)\n\t\tdprintk(\"NFS: Got error %d from the server on DESTROY_SESSION. \"\n\t\t\t\"Session has been destroyed regardless...\\n\", status);\n\n\tdprintk(\"<-- nfs4_proc_destroy_session\\n\");\n\treturn status;\n}\n\n/*\n * With sessions, the client is not marked ready until after a\n * successful EXCHANGE_ID and CREATE_SESSION.\n *\n * Map errors cl_cons_state errors to EPROTONOSUPPORT to indicate\n * other versions of NFS can be tried.\n */\nstatic int nfs41_check_session_ready(struct nfs_client *clp)\n{\n\tint ret;\n\t\n\tif (clp->cl_cons_state == NFS_CS_SESSION_INITING) {\n\t\tret = nfs4_client_recover_expired_lease(clp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (clp->cl_cons_state < NFS_CS_READY)\n\t\treturn -EPROTONOSUPPORT;\n\tsmp_rmb();\n\treturn 0;\n}\n\nint nfs4_init_session(struct nfs_server *server)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs4_session *session;\n\tunsigned int rsize, wsize;\n\n\tif (!nfs4_has_session(clp))\n\t\treturn 0;\n\n\tsession = clp->cl_session;\n\tspin_lock(&clp->cl_lock);\n\tif (test_and_clear_bit(NFS4_SESSION_INITING, &session->session_state)) {\n\n\t\trsize = server->rsize;\n\t\tif (rsize == 0)\n\t\t\trsize = NFS_MAX_FILE_IO_SIZE;\n\t\twsize = server->wsize;\n\t\tif (wsize == 0)\n\t\t\twsize = NFS_MAX_FILE_IO_SIZE;\n\n\t\tsession->fc_attrs.max_rqst_sz = wsize + nfs41_maxwrite_overhead;\n\t\tsession->fc_attrs.max_resp_sz = rsize + nfs41_maxread_overhead;\n\t}\n\tspin_unlock(&clp->cl_lock);\n\n\treturn nfs41_check_session_ready(clp);\n}\n\nint nfs4_init_ds_session(struct nfs_client *clp, unsigned long lease_time)\n{\n\tstruct nfs4_session *session = clp->cl_session;\n\tint ret;\n\n\tspin_lock(&clp->cl_lock);\n\tif (test_and_clear_bit(NFS4_SESSION_INITING, &session->session_state)) {\n\t\t/*\n\t\t * Do not set NFS_CS_CHECK_LEASE_TIME instead set the\n\t\t * DS lease to be equal to the MDS lease.\n\t\t */\n\t\tclp->cl_lease_time = lease_time;\n\t\tclp->cl_last_renewal = jiffies;\n\t}\n\tspin_unlock(&clp->cl_lock);\n\n\tret = nfs41_check_session_ready(clp);\n\tif (ret)\n\t\treturn ret;\n\t/* Test for the DS role */\n\tif (!is_ds_client(clp))\n\t\treturn -ENODEV;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nfs4_init_ds_session);\n\n\n/*\n * Renew the cl_session lease.\n */\nstruct nfs4_sequence_data {\n\tstruct nfs_client *clp;\n\tstruct nfs4_sequence_args args;\n\tstruct nfs4_sequence_res res;\n};\n\nstatic void nfs41_sequence_release(void *data)\n{\n\tstruct nfs4_sequence_data *calldata = data;\n\tstruct nfs_client *clp = calldata->clp;\n\n\tif (atomic_read(&clp->cl_count) > 1)\n\t\tnfs4_schedule_state_renewal(clp);\n\tnfs_put_client(clp);\n\tkfree(calldata);\n}\n\nstatic int nfs41_sequence_handle_errors(struct rpc_task *task, struct nfs_client *clp)\n{\n\tswitch(task->tk_status) {\n\tcase -NFS4ERR_DELAY:\n\t\trpc_delay(task, NFS4_POLL_RETRY_MAX);\n\t\treturn -EAGAIN;\n\tdefault:\n\t\tnfs4_schedule_lease_recovery(clp);\n\t}\n\treturn 0;\n}\n\nstatic void nfs41_sequence_call_done(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_sequence_data *calldata = data;\n\tstruct nfs_client *clp = calldata->clp;\n\n\tif (!nfs41_sequence_done(task, task->tk_msg.rpc_resp))\n\t\treturn;\n\n\tif (task->tk_status < 0) {\n\t\tdprintk(\"%s ERROR %d\\n\", __func__, task->tk_status);\n\t\tif (atomic_read(&clp->cl_count) == 1)\n\t\t\tgoto out;\n\n\t\tif (nfs41_sequence_handle_errors(task, clp) == -EAGAIN) {\n\t\t\trpc_restart_call_prepare(task);\n\t\t\treturn;\n\t\t}\n\t}\n\tdprintk(\"%s rpc_cred %p\\n\", __func__, task->tk_msg.rpc_cred);\nout:\n\tdprintk(\"<-- %s\\n\", __func__);\n}\n\nstatic void nfs41_sequence_prepare(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_sequence_data *calldata = data;\n\tstruct nfs_client *clp = calldata->clp;\n\tstruct nfs4_sequence_args *args;\n\tstruct nfs4_sequence_res *res;\n\n\targs = task->tk_msg.rpc_argp;\n\tres = task->tk_msg.rpc_resp;\n\n\tif (nfs41_setup_sequence(clp->cl_session, args, res, task))\n\t\treturn;\n\trpc_call_start(task);\n}\n\nstatic const struct rpc_call_ops nfs41_sequence_ops = {\n\t.rpc_call_done = nfs41_sequence_call_done,\n\t.rpc_call_prepare = nfs41_sequence_prepare,\n\t.rpc_release = nfs41_sequence_release,\n};\n\nstatic struct rpc_task *_nfs41_proc_sequence(struct nfs_client *clp, struct rpc_cred *cred)\n{\n\tstruct nfs4_sequence_data *calldata;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SEQUENCE],\n\t\t.rpc_cred = cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = clp->cl_rpcclient,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs41_sequence_ops,\n\t\t.flags = RPC_TASK_ASYNC | RPC_TASK_SOFT,\n\t};\n\n\tif (!atomic_inc_not_zero(&clp->cl_count))\n\t\treturn ERR_PTR(-EIO);\n\tcalldata = kzalloc(sizeof(*calldata), GFP_NOFS);\n\tif (calldata == NULL) {\n\t\tnfs_put_client(clp);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tnfs41_init_sequence(&calldata->args, &calldata->res, 0);\n\tmsg.rpc_argp = &calldata->args;\n\tmsg.rpc_resp = &calldata->res;\n\tcalldata->clp = clp;\n\ttask_setup_data.callback_data = calldata;\n\n\treturn rpc_run_task(&task_setup_data);\n}\n\nstatic int nfs41_proc_async_sequence(struct nfs_client *clp, struct rpc_cred *cred, unsigned renew_flags)\n{\n\tstruct rpc_task *task;\n\tint ret = 0;\n\n\tif ((renew_flags & NFS4_RENEW_TIMEOUT) == 0)\n\t\treturn 0;\n\ttask = _nfs41_proc_sequence(clp, cred);\n\tif (IS_ERR(task))\n\t\tret = PTR_ERR(task);\n\telse\n\t\trpc_put_task_async(task);\n\tdprintk(\"<-- %s status=%d\\n\", __func__, ret);\n\treturn ret;\n}\n\nstatic int nfs4_proc_sequence(struct nfs_client *clp, struct rpc_cred *cred)\n{\n\tstruct rpc_task *task;\n\tint ret;\n\n\ttask = _nfs41_proc_sequence(clp, cred);\n\tif (IS_ERR(task)) {\n\t\tret = PTR_ERR(task);\n\t\tgoto out;\n\t}\n\tret = rpc_wait_for_completion_task(task);\n\tif (!ret) {\n\t\tstruct nfs4_sequence_res *res = task->tk_msg.rpc_resp;\n\n\t\tif (task->tk_status == 0)\n\t\t\tnfs41_handle_sequence_flag_errors(clp, res->sr_status_flags);\n\t\tret = task->tk_status;\n\t}\n\trpc_put_task(task);\nout:\n\tdprintk(\"<-- %s status=%d\\n\", __func__, ret);\n\treturn ret;\n}\n\nstruct nfs4_reclaim_complete_data {\n\tstruct nfs_client *clp;\n\tstruct nfs41_reclaim_complete_args arg;\n\tstruct nfs41_reclaim_complete_res res;\n};\n\nstatic void nfs4_reclaim_complete_prepare(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_reclaim_complete_data *calldata = data;\n\n\trpc_task_set_priority(task, RPC_PRIORITY_PRIVILEGED);\n\tif (nfs41_setup_sequence(calldata->clp->cl_session,\n\t\t\t\t&calldata->arg.seq_args,\n\t\t\t\t&calldata->res.seq_res, task))\n\t\treturn;\n\n\trpc_call_start(task);\n}\n\nstatic int nfs41_reclaim_complete_handle_errors(struct rpc_task *task, struct nfs_client *clp)\n{\n\tswitch(task->tk_status) {\n\tcase 0:\n\tcase -NFS4ERR_COMPLETE_ALREADY:\n\tcase -NFS4ERR_WRONG_CRED: /* What to do here? */\n\t\tbreak;\n\tcase -NFS4ERR_DELAY:\n\t\trpc_delay(task, NFS4_POLL_RETRY_MAX);\n\t\t/* fall through */\n\tcase -NFS4ERR_RETRY_UNCACHED_REP:\n\t\treturn -EAGAIN;\n\tdefault:\n\t\tnfs4_schedule_lease_recovery(clp);\n\t}\n\treturn 0;\n}\n\nstatic void nfs4_reclaim_complete_done(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_reclaim_complete_data *calldata = data;\n\tstruct nfs_client *clp = calldata->clp;\n\tstruct nfs4_sequence_res *res = &calldata->res.seq_res;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\tif (!nfs41_sequence_done(task, res))\n\t\treturn;\n\n\tif (nfs41_reclaim_complete_handle_errors(task, clp) == -EAGAIN) {\n\t\trpc_restart_call_prepare(task);\n\t\treturn;\n\t}\n\tdprintk(\"<-- %s\\n\", __func__);\n}\n\nstatic void nfs4_free_reclaim_complete_data(void *data)\n{\n\tstruct nfs4_reclaim_complete_data *calldata = data;\n\n\tkfree(calldata);\n}\n\nstatic const struct rpc_call_ops nfs4_reclaim_complete_call_ops = {\n\t.rpc_call_prepare = nfs4_reclaim_complete_prepare,\n\t.rpc_call_done = nfs4_reclaim_complete_done,\n\t.rpc_release = nfs4_free_reclaim_complete_data,\n};\n\n/*\n * Issue a global reclaim complete.\n */\nstatic int nfs41_proc_reclaim_complete(struct nfs_client *clp)\n{\n\tstruct nfs4_reclaim_complete_data *calldata;\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_RECLAIM_COMPLETE],\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = clp->cl_rpcclient,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_reclaim_complete_call_ops,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\tint status = -ENOMEM;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\tcalldata = kzalloc(sizeof(*calldata), GFP_NOFS);\n\tif (calldata == NULL)\n\t\tgoto out;\n\tcalldata->clp = clp;\n\tcalldata->arg.one_fs = 0;\n\n\tnfs41_init_sequence(&calldata->arg.seq_args, &calldata->res.seq_res, 0);\n\tmsg.rpc_argp = &calldata->arg;\n\tmsg.rpc_resp = &calldata->res;\n\ttask_setup_data.callback_data = calldata;\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task)) {\n\t\tstatus = PTR_ERR(task);\n\t\tgoto out;\n\t}\n\tstatus = nfs4_wait_for_completion_rpc_task(task);\n\tif (status == 0)\n\t\tstatus = task->tk_status;\n\trpc_put_task(task);\n\treturn 0;\nout:\n\tdprintk(\"<-- %s status=%d\\n\", __func__, status);\n\treturn status;\n}\n\nstatic void\nnfs4_layoutget_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_layoutget *lgp = calldata;\n\tstruct nfs_server *server = NFS_SERVER(lgp->args.inode);\n\n\tdprintk(\"--> %s\\n\", __func__);\n\t/* Note the is a race here, where a CB_LAYOUTRECALL can come in\n\t * right now covering the LAYOUTGET we are about to send.\n\t * However, that is not so catastrophic, and there seems\n\t * to be no way to prevent it completely.\n\t */\n\tif (nfs4_setup_sequence(server, &lgp->args.seq_args,\n\t\t\t\t&lgp->res.seq_res, task))\n\t\treturn;\n\tif (pnfs_choose_layoutget_stateid(&lgp->args.stateid,\n\t\t\t\t\t  NFS_I(lgp->args.inode)->layout,\n\t\t\t\t\t  lgp->args.ctx->state)) {\n\t\trpc_exit(task, NFS4_OK);\n\t\treturn;\n\t}\n\trpc_call_start(task);\n}\n\nstatic void nfs4_layoutget_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_layoutget *lgp = calldata;\n\tstruct inode *inode = lgp->args.inode;\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct pnfs_layout_hdr *lo;\n\tstruct nfs4_state *state = NULL;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\n\tif (!nfs4_sequence_done(task, &lgp->res.seq_res))\n\t\tgoto out;\n\n\tswitch (task->tk_status) {\n\tcase 0:\n\t\tgoto out;\n\tcase -NFS4ERR_LAYOUTTRYLATER:\n\tcase -NFS4ERR_RECALLCONFLICT:\n\t\ttask->tk_status = -NFS4ERR_DELAY;\n\t\tbreak;\n\tcase -NFS4ERR_EXPIRED:\n\tcase -NFS4ERR_BAD_STATEID:\n\t\tspin_lock(&inode->i_lock);\n\t\tlo = NFS_I(inode)->layout;\n\t\tif (!lo || list_empty(&lo->plh_segs)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t/* If the open stateid was bad, then recover it. */\n\t\t\tstate = lgp->args.ctx->state;\n\t\t} else {\n\t\t\tLIST_HEAD(head);\n\n\t\t\tpnfs_mark_matching_lsegs_invalid(lo, &head, NULL);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t/* Mark the bad layout state as invalid, then\n\t\t\t * retry using the open stateid. */\n\t\t\tpnfs_free_lseg_list(&head);\n\t\t}\n\t}\n\tif (nfs4_async_handle_error(task, server, state) == -EAGAIN)\n\t\trpc_restart_call_prepare(task);\nout:\n\tdprintk(\"<-- %s\\n\", __func__);\n}\n\nstatic size_t max_response_pages(struct nfs_server *server)\n{\n\tu32 max_resp_sz = server->nfs_client->cl_session->fc_attrs.max_resp_sz;\n\treturn nfs_page_array_len(0, max_resp_sz);\n}\n\nstatic void nfs4_free_pages(struct page **pages, size_t size)\n{\n\tint i;\n\n\tif (!pages)\n\t\treturn;\n\n\tfor (i = 0; i < size; i++) {\n\t\tif (!pages[i])\n\t\t\tbreak;\n\t\t__free_page(pages[i]);\n\t}\n\tkfree(pages);\n}\n\nstatic struct page **nfs4_alloc_pages(size_t size, gfp_t gfp_flags)\n{\n\tstruct page **pages;\n\tint i;\n\n\tpages = kcalloc(size, sizeof(struct page *), gfp_flags);\n\tif (!pages) {\n\t\tdprintk(\"%s: can't alloc array of %zu pages\\n\", __func__, size);\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < size; i++) {\n\t\tpages[i] = alloc_page(gfp_flags);\n\t\tif (!pages[i]) {\n\t\t\tdprintk(\"%s: failed to allocate page\\n\", __func__);\n\t\t\tnfs4_free_pages(pages, size);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn pages;\n}\n\nstatic void nfs4_layoutget_release(void *calldata)\n{\n\tstruct nfs4_layoutget *lgp = calldata;\n\tstruct nfs_server *server = NFS_SERVER(lgp->args.inode);\n\tsize_t max_pages = max_response_pages(server);\n\n\tdprintk(\"--> %s\\n\", __func__);\n\tnfs4_free_pages(lgp->args.layout.pages, max_pages);\n\tput_nfs_open_context(lgp->args.ctx);\n\tkfree(calldata);\n\tdprintk(\"<-- %s\\n\", __func__);\n}\n\nstatic const struct rpc_call_ops nfs4_layoutget_call_ops = {\n\t.rpc_call_prepare = nfs4_layoutget_prepare,\n\t.rpc_call_done = nfs4_layoutget_done,\n\t.rpc_release = nfs4_layoutget_release,\n};\n\nstruct pnfs_layout_segment *\nnfs4_proc_layoutget(struct nfs4_layoutget *lgp, gfp_t gfp_flags)\n{\n\tstruct nfs_server *server = NFS_SERVER(lgp->args.inode);\n\tsize_t max_pages = max_response_pages(server);\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LAYOUTGET],\n\t\t.rpc_argp = &lgp->args,\n\t\t.rpc_resp = &lgp->res,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = server->client,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_layoutget_call_ops,\n\t\t.callback_data = lgp,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\tstruct pnfs_layout_segment *lseg = NULL;\n\tint status = 0;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\n\tlgp->args.layout.pages = nfs4_alloc_pages(max_pages, gfp_flags);\n\tif (!lgp->args.layout.pages) {\n\t\tnfs4_layoutget_release(lgp);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tlgp->args.layout.pglen = max_pages * PAGE_SIZE;\n\n\tlgp->res.layoutp = &lgp->args.layout;\n\tlgp->res.seq_res.sr_slot = NULL;\n\tnfs41_init_sequence(&lgp->args.seq_args, &lgp->res.seq_res, 0);\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn ERR_CAST(task);\n\tstatus = nfs4_wait_for_completion_rpc_task(task);\n\tif (status == 0)\n\t\tstatus = task->tk_status;\n\tif (status == 0)\n\t\tlseg = pnfs_layout_process(lgp);\n\trpc_put_task(task);\n\tdprintk(\"<-- %s status=%d\\n\", __func__, status);\n\tif (status)\n\t\treturn ERR_PTR(status);\n\treturn lseg;\n}\n\nstatic void\nnfs4_layoutreturn_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_layoutreturn *lrp = calldata;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\tif (nfs41_setup_sequence(lrp->clp->cl_session, &lrp->args.seq_args,\n\t\t\t\t&lrp->res.seq_res, task))\n\t\treturn;\n\trpc_call_start(task);\n}\n\nstatic void nfs4_layoutreturn_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_layoutreturn *lrp = calldata;\n\tstruct nfs_server *server;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\n\tif (!nfs4_sequence_done(task, &lrp->res.seq_res))\n\t\treturn;\n\n\tserver = NFS_SERVER(lrp->args.inode);\n\tif (nfs4_async_handle_error(task, server, NULL) == -EAGAIN) {\n\t\trpc_restart_call_prepare(task);\n\t\treturn;\n\t}\n\tdprintk(\"<-- %s\\n\", __func__);\n}\n\nstatic void nfs4_layoutreturn_release(void *calldata)\n{\n\tstruct nfs4_layoutreturn *lrp = calldata;\n\tstruct pnfs_layout_hdr *lo = lrp->args.layout;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\tspin_lock(&lo->plh_inode->i_lock);\n\tif (lrp->res.lrs_present)\n\t\tpnfs_set_layout_stateid(lo, &lrp->res.stateid, true);\n\tlo->plh_block_lgets--;\n\tspin_unlock(&lo->plh_inode->i_lock);\n\tpnfs_put_layout_hdr(lrp->args.layout);\n\tkfree(calldata);\n\tdprintk(\"<-- %s\\n\", __func__);\n}\n\nstatic const struct rpc_call_ops nfs4_layoutreturn_call_ops = {\n\t.rpc_call_prepare = nfs4_layoutreturn_prepare,\n\t.rpc_call_done = nfs4_layoutreturn_done,\n\t.rpc_release = nfs4_layoutreturn_release,\n};\n\nint nfs4_proc_layoutreturn(struct nfs4_layoutreturn *lrp)\n{\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LAYOUTRETURN],\n\t\t.rpc_argp = &lrp->args,\n\t\t.rpc_resp = &lrp->res,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = lrp->clp->cl_rpcclient,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_layoutreturn_call_ops,\n\t\t.callback_data = lrp,\n\t};\n\tint status;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\tnfs41_init_sequence(&lrp->args.seq_args, &lrp->res.seq_res, 1);\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tstatus = task->tk_status;\n\tdprintk(\"<-- %s status=%d\\n\", __func__, status);\n\trpc_put_task(task);\n\treturn status;\n}\n\n/*\n * Retrieve the list of Data Server devices from the MDS.\n */\nstatic int _nfs4_getdevicelist(struct nfs_server *server,\n\t\t\t\t    const struct nfs_fh *fh,\n\t\t\t\t    struct pnfs_devicelist *devlist)\n{\n\tstruct nfs4_getdevicelist_args args = {\n\t\t.fh = fh,\n\t\t.layoutclass = server->pnfs_curr_ld->id,\n\t};\n\tstruct nfs4_getdevicelist_res res = {\n\t\t.devlist = devlist,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETDEVICELIST],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tint status;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\tstatus = nfs4_call_sync(server->client, server, &msg, &args.seq_args,\n\t\t\t\t&res.seq_res, 0);\n\tdprintk(\"<-- %s status=%d\\n\", __func__, status);\n\treturn status;\n}\n\nint nfs4_proc_getdevicelist(struct nfs_server *server,\n\t\t\t    const struct nfs_fh *fh,\n\t\t\t    struct pnfs_devicelist *devlist)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\tdo {\n\t\terr = nfs4_handle_exception(server,\n\t\t\t\t_nfs4_getdevicelist(server, fh, devlist),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\n\tdprintk(\"%s: err=%d, num_devs=%u\\n\", __func__,\n\t\terr, devlist->num_devs);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(nfs4_proc_getdevicelist);\n\nstatic int\n_nfs4_proc_getdeviceinfo(struct nfs_server *server, struct pnfs_device *pdev)\n{\n\tstruct nfs4_getdeviceinfo_args args = {\n\t\t.pdev = pdev,\n\t};\n\tstruct nfs4_getdeviceinfo_res res = {\n\t\t.pdev = pdev,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETDEVICEINFO],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tint status;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\tstatus = nfs4_call_sync(server->client, server, &msg, &args.seq_args, &res.seq_res, 0);\n\tdprintk(\"<-- %s status=%d\\n\", __func__, status);\n\n\treturn status;\n}\n\nint nfs4_proc_getdeviceinfo(struct nfs_server *server, struct pnfs_device *pdev)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\tdo {\n\t\terr = nfs4_handle_exception(server,\n\t\t\t\t\t_nfs4_proc_getdeviceinfo(server, pdev),\n\t\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(nfs4_proc_getdeviceinfo);\n\nstatic void nfs4_layoutcommit_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_layoutcommit_data *data = calldata;\n\tstruct nfs_server *server = NFS_SERVER(data->args.inode);\n\n\tif (nfs4_setup_sequence(server, &data->args.seq_args,\n\t\t\t\t&data->res.seq_res, task))\n\t\treturn;\n\trpc_call_start(task);\n}\n\nstatic void\nnfs4_layoutcommit_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_layoutcommit_data *data = calldata;\n\tstruct nfs_server *server = NFS_SERVER(data->args.inode);\n\n\tif (!nfs4_sequence_done(task, &data->res.seq_res))\n\t\treturn;\n\n\tswitch (task->tk_status) { /* Just ignore these failures */\n\tcase -NFS4ERR_DELEG_REVOKED: /* layout was recalled */\n\tcase -NFS4ERR_BADIOMODE:     /* no IOMODE_RW layout for range */\n\tcase -NFS4ERR_BADLAYOUT:     /* no layout */\n\tcase -NFS4ERR_GRACE:\t    /* loca_recalim always false */\n\t\ttask->tk_status = 0;\n\t\tbreak;\n\tcase 0:\n\t\tnfs_post_op_update_inode_force_wcc(data->args.inode,\n\t\t\t\t\t\t   data->res.fattr);\n\t\tbreak;\n\tdefault:\n\t\tif (nfs4_async_handle_error(task, server, NULL) == -EAGAIN) {\n\t\t\trpc_restart_call_prepare(task);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void nfs4_layoutcommit_release(void *calldata)\n{\n\tstruct nfs4_layoutcommit_data *data = calldata;\n\tstruct pnfs_layout_segment *lseg, *tmp;\n\tunsigned long *bitlock = &NFS_I(data->args.inode)->flags;\n\n\tpnfs_cleanup_layoutcommit(data);\n\t/* Matched by references in pnfs_set_layoutcommit */\n\tlist_for_each_entry_safe(lseg, tmp, &data->lseg_list, pls_lc_list) {\n\t\tlist_del_init(&lseg->pls_lc_list);\n\t\tif (test_and_clear_bit(NFS_LSEG_LAYOUTCOMMIT,\n\t\t\t\t       &lseg->pls_flags))\n\t\t\tpnfs_put_lseg(lseg);\n\t}\n\n\tclear_bit_unlock(NFS_INO_LAYOUTCOMMITTING, bitlock);\n\tsmp_mb__after_clear_bit();\n\twake_up_bit(bitlock, NFS_INO_LAYOUTCOMMITTING);\n\n\tput_rpccred(data->cred);\n\tkfree(data);\n}\n\nstatic const struct rpc_call_ops nfs4_layoutcommit_ops = {\n\t.rpc_call_prepare = nfs4_layoutcommit_prepare,\n\t.rpc_call_done = nfs4_layoutcommit_done,\n\t.rpc_release = nfs4_layoutcommit_release,\n};\n\nint\nnfs4_proc_layoutcommit(struct nfs4_layoutcommit_data *data, bool sync)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LAYOUTCOMMIT],\n\t\t.rpc_argp = &data->args,\n\t\t.rpc_resp = &data->res,\n\t\t.rpc_cred = data->cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.task = &data->task,\n\t\t.rpc_client = NFS_CLIENT(data->args.inode),\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_layoutcommit_ops,\n\t\t.callback_data = data,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\tstruct rpc_task *task;\n\tint status = 0;\n\n\tdprintk(\"NFS: %4d initiating layoutcommit call. sync %d \"\n\t\t\"lbw: %llu inode %lu\\n\",\n\t\tdata->task.tk_pid, sync,\n\t\tdata->args.lastbytewritten,\n\t\tdata->args.inode->i_ino);\n\n\tnfs41_init_sequence(&data->args.seq_args, &data->res.seq_res, 1);\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tif (sync == false)\n\t\tgoto out;\n\tstatus = nfs4_wait_for_completion_rpc_task(task);\n\tif (status != 0)\n\t\tgoto out;\n\tstatus = task->tk_status;\nout:\n\tdprintk(\"%s: status %d\\n\", __func__, status);\n\trpc_put_task(task);\n\treturn status;\n}\n\nstatic int\n_nfs41_proc_secinfo_no_name(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t    struct nfs_fsinfo *info, struct nfs4_secinfo_flavors *flavors)\n{\n\tstruct nfs41_secinfo_no_name_args args = {\n\t\t.style = SECINFO_STYLE_CURRENT_FH,\n\t};\n\tstruct nfs4_secinfo_res res = {\n\t\t.flavors = flavors,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SECINFO_NO_NAME],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\treturn nfs4_call_sync(server->client, server, &msg, &args.seq_args, &res.seq_res, 0);\n}\n\nstatic int\nnfs41_proc_secinfo_no_name(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t\t   struct nfs_fsinfo *info, struct nfs4_secinfo_flavors *flavors)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = _nfs41_proc_secinfo_no_name(server, fhandle, info, flavors);\n\t\tswitch (err) {\n\t\tcase 0:\n\t\tcase -NFS4ERR_WRONGSEC:\n\t\tcase -NFS4ERR_NOTSUPP:\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\terr = nfs4_handle_exception(server, err, &exception);\n\t\t}\n\t} while (exception.retry);\nout:\n\treturn err;\n}\n\nstatic int\nnfs41_find_root_sec(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t    struct nfs_fsinfo *info)\n{\n\tint err;\n\tstruct page *page;\n\trpc_authflavor_t flavor;\n\tstruct nfs4_secinfo_flavors *flavors;\n\n\tpage = alloc_page(GFP_KERNEL);\n\tif (!page) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tflavors = page_address(page);\n\terr = nfs41_proc_secinfo_no_name(server, fhandle, info, flavors);\n\n\t/*\n\t * Fall back on \"guess and check\" method if\n\t * the server doesn't support SECINFO_NO_NAME\n\t */\n\tif (err == -NFS4ERR_WRONGSEC || err == -NFS4ERR_NOTSUPP) {\n\t\terr = nfs4_find_root_sec(server, fhandle, info);\n\t\tgoto out_freepage;\n\t}\n\tif (err)\n\t\tgoto out_freepage;\n\n\tflavor = nfs_find_best_sec(flavors);\n\tif (err == 0)\n\t\terr = nfs4_lookup_root_sec(server, fhandle, info, flavor);\n\nout_freepage:\n\tput_page(page);\n\tif (err == -EACCES)\n\t\treturn -EPERM;\nout:\n\treturn err;\n}\n\nstatic int _nfs41_test_stateid(struct nfs_server *server, nfs4_stateid *stateid)\n{\n\tint status;\n\tstruct nfs41_test_stateid_args args = {\n\t\t.stateid = stateid,\n\t};\n\tstruct nfs41_test_stateid_res res;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_TEST_STATEID],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\n\tdprintk(\"NFS call  test_stateid %p\\n\", stateid);\n\tnfs41_init_sequence(&args.seq_args, &res.seq_res, 0);\n\tstatus = nfs4_call_sync_sequence(server->client, server, &msg, &args.seq_args, &res.seq_res, 1);\n\tif (status != NFS_OK) {\n\t\tdprintk(\"NFS reply test_stateid: failed, %d\\n\", status);\n\t\treturn status;\n\t}\n\tdprintk(\"NFS reply test_stateid: succeeded, %d\\n\", -res.status);\n\treturn -res.status;\n}\n\n/**\n * nfs41_test_stateid - perform a TEST_STATEID operation\n *\n * @server: server / transport on which to perform the operation\n * @stateid: state ID to test\n *\n * Returns NFS_OK if the server recognizes that \"stateid\" is valid.\n * Otherwise a negative NFS4ERR value is returned if the operation\n * failed or the state ID is not currently valid.\n */\nstatic int nfs41_test_stateid(struct nfs_server *server, nfs4_stateid *stateid)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = _nfs41_test_stateid(server, stateid);\n\t\tif (err != -NFS4ERR_DELAY)\n\t\t\tbreak;\n\t\tnfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int _nfs4_free_stateid(struct nfs_server *server, nfs4_stateid *stateid)\n{\n\tstruct nfs41_free_stateid_args args = {\n\t\t.stateid = stateid,\n\t};\n\tstruct nfs41_free_stateid_res res;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_FREE_STATEID],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tint status;\n\n\tdprintk(\"NFS call  free_stateid %p\\n\", stateid);\n\tnfs41_init_sequence(&args.seq_args, &res.seq_res, 0);\n\tstatus = nfs4_call_sync_sequence(server->client, server, &msg,\n\t\t\t\t\t &args.seq_args, &res.seq_res, 1);\n\tdprintk(\"NFS reply free_stateid: %d\\n\", status);\n\treturn status;\n}\n\n/**\n * nfs41_free_stateid - perform a FREE_STATEID operation\n *\n * @server: server / transport on which to perform the operation\n * @stateid: state ID to release\n *\n * Returns NFS_OK if the server freed \"stateid\".  Otherwise a\n * negative NFS4ERR value is returned.\n */\nstatic int nfs41_free_stateid(struct nfs_server *server, nfs4_stateid *stateid)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = _nfs4_free_stateid(server, stateid);\n\t\tif (err != -NFS4ERR_DELAY)\n\t\t\tbreak;\n\t\tnfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic bool nfs41_match_stateid(const nfs4_stateid *s1,\n\t\tconst nfs4_stateid *s2)\n{\n\tif (memcmp(s1->other, s2->other, sizeof(s1->other)) != 0)\n\t\treturn false;\n\n\tif (s1->seqid == s2->seqid)\n\t\treturn true;\n\tif (s1->seqid == 0 || s2->seqid == 0)\n\t\treturn true;\n\n\treturn false;\n}\n\n#endif /* CONFIG_NFS_V4_1 */\n\nstatic bool nfs4_match_stateid(const nfs4_stateid *s1,\n\t\tconst nfs4_stateid *s2)\n{\n\treturn nfs4_stateid_match(s1, s2);\n}\n\n\nstatic const struct nfs4_state_recovery_ops nfs40_reboot_recovery_ops = {\n\t.owner_flag_bit = NFS_OWNER_RECLAIM_REBOOT,\n\t.state_flag_bit\t= NFS_STATE_RECLAIM_REBOOT,\n\t.recover_open\t= nfs4_open_reclaim,\n\t.recover_lock\t= nfs4_lock_reclaim,\n\t.establish_clid = nfs4_init_clientid,\n\t.get_clid_cred\t= nfs4_get_setclientid_cred,\n\t.detect_trunking = nfs40_discover_server_trunking,\n};\n\n#if defined(CONFIG_NFS_V4_1)\nstatic const struct nfs4_state_recovery_ops nfs41_reboot_recovery_ops = {\n\t.owner_flag_bit = NFS_OWNER_RECLAIM_REBOOT,\n\t.state_flag_bit\t= NFS_STATE_RECLAIM_REBOOT,\n\t.recover_open\t= nfs4_open_reclaim,\n\t.recover_lock\t= nfs4_lock_reclaim,\n\t.establish_clid = nfs41_init_clientid,\n\t.get_clid_cred\t= nfs4_get_exchange_id_cred,\n\t.reclaim_complete = nfs41_proc_reclaim_complete,\n\t.detect_trunking = nfs41_discover_server_trunking,\n};\n#endif /* CONFIG_NFS_V4_1 */\n\nstatic const struct nfs4_state_recovery_ops nfs40_nograce_recovery_ops = {\n\t.owner_flag_bit = NFS_OWNER_RECLAIM_NOGRACE,\n\t.state_flag_bit\t= NFS_STATE_RECLAIM_NOGRACE,\n\t.recover_open\t= nfs4_open_expired,\n\t.recover_lock\t= nfs4_lock_expired,\n\t.establish_clid = nfs4_init_clientid,\n\t.get_clid_cred\t= nfs4_get_setclientid_cred,\n};\n\n#if defined(CONFIG_NFS_V4_1)\nstatic const struct nfs4_state_recovery_ops nfs41_nograce_recovery_ops = {\n\t.owner_flag_bit = NFS_OWNER_RECLAIM_NOGRACE,\n\t.state_flag_bit\t= NFS_STATE_RECLAIM_NOGRACE,\n\t.recover_open\t= nfs41_open_expired,\n\t.recover_lock\t= nfs41_lock_expired,\n\t.establish_clid = nfs41_init_clientid,\n\t.get_clid_cred\t= nfs4_get_exchange_id_cred,\n};\n#endif /* CONFIG_NFS_V4_1 */\n\nstatic const struct nfs4_state_maintenance_ops nfs40_state_renewal_ops = {\n\t.sched_state_renewal = nfs4_proc_async_renew,\n\t.get_state_renewal_cred_locked = nfs4_get_renew_cred_locked,\n\t.renew_lease = nfs4_proc_renew,\n};\n\n#if defined(CONFIG_NFS_V4_1)\nstatic const struct nfs4_state_maintenance_ops nfs41_state_renewal_ops = {\n\t.sched_state_renewal = nfs41_proc_async_sequence,\n\t.get_state_renewal_cred_locked = nfs4_get_machine_cred_locked,\n\t.renew_lease = nfs4_proc_sequence,\n};\n#endif\n\nstatic const struct nfs4_minor_version_ops nfs_v4_0_minor_ops = {\n\t.minor_version = 0,\n\t.call_sync = _nfs4_call_sync,\n\t.match_stateid = nfs4_match_stateid,\n\t.find_root_sec = nfs4_find_root_sec,\n\t.reboot_recovery_ops = &nfs40_reboot_recovery_ops,\n\t.nograce_recovery_ops = &nfs40_nograce_recovery_ops,\n\t.state_renewal_ops = &nfs40_state_renewal_ops,\n};\n\n#if defined(CONFIG_NFS_V4_1)\nstatic const struct nfs4_minor_version_ops nfs_v4_1_minor_ops = {\n\t.minor_version = 1,\n\t.call_sync = _nfs4_call_sync_session,\n\t.match_stateid = nfs41_match_stateid,\n\t.find_root_sec = nfs41_find_root_sec,\n\t.reboot_recovery_ops = &nfs41_reboot_recovery_ops,\n\t.nograce_recovery_ops = &nfs41_nograce_recovery_ops,\n\t.state_renewal_ops = &nfs41_state_renewal_ops,\n};\n#endif\n\nconst struct nfs4_minor_version_ops *nfs_v4_minor_ops[] = {\n\t[0] = &nfs_v4_0_minor_ops,\n#if defined(CONFIG_NFS_V4_1)\n\t[1] = &nfs_v4_1_minor_ops,\n#endif\n};\n\nconst struct inode_operations nfs4_dir_inode_operations = {\n\t.create\t\t= nfs_create,\n\t.lookup\t\t= nfs_lookup,\n\t.atomic_open\t= nfs_atomic_open,\n\t.link\t\t= nfs_link,\n\t.unlink\t\t= nfs_unlink,\n\t.symlink\t= nfs_symlink,\n\t.mkdir\t\t= nfs_mkdir,\n\t.rmdir\t\t= nfs_rmdir,\n\t.mknod\t\t= nfs_mknod,\n\t.rename\t\t= nfs_rename,\n\t.permission\t= nfs_permission,\n\t.getattr\t= nfs_getattr,\n\t.setattr\t= nfs_setattr,\n\t.getxattr\t= generic_getxattr,\n\t.setxattr\t= generic_setxattr,\n\t.listxattr\t= generic_listxattr,\n\t.removexattr\t= generic_removexattr,\n};\n\nstatic const struct inode_operations nfs4_file_inode_operations = {\n\t.permission\t= nfs_permission,\n\t.getattr\t= nfs_getattr,\n\t.setattr\t= nfs_setattr,\n\t.getxattr\t= generic_getxattr,\n\t.setxattr\t= generic_setxattr,\n\t.listxattr\t= generic_listxattr,\n\t.removexattr\t= generic_removexattr,\n};\n\nconst struct nfs_rpc_ops nfs_v4_clientops = {\n\t.version\t= 4,\t\t\t/* protocol version */\n\t.dentry_ops\t= &nfs4_dentry_operations,\n\t.dir_inode_ops\t= &nfs4_dir_inode_operations,\n\t.file_inode_ops\t= &nfs4_file_inode_operations,\n\t.file_ops\t= &nfs4_file_operations,\n\t.getroot\t= nfs4_proc_get_root,\n\t.submount\t= nfs4_submount,\n\t.try_mount\t= nfs4_try_mount,\n\t.getattr\t= nfs4_proc_getattr,\n\t.setattr\t= nfs4_proc_setattr,\n\t.lookup\t\t= nfs4_proc_lookup,\n\t.access\t\t= nfs4_proc_access,\n\t.readlink\t= nfs4_proc_readlink,\n\t.create\t\t= nfs4_proc_create,\n\t.remove\t\t= nfs4_proc_remove,\n\t.unlink_setup\t= nfs4_proc_unlink_setup,\n\t.unlink_rpc_prepare = nfs4_proc_unlink_rpc_prepare,\n\t.unlink_done\t= nfs4_proc_unlink_done,\n\t.rename\t\t= nfs4_proc_rename,\n\t.rename_setup\t= nfs4_proc_rename_setup,\n\t.rename_rpc_prepare = nfs4_proc_rename_rpc_prepare,\n\t.rename_done\t= nfs4_proc_rename_done,\n\t.link\t\t= nfs4_proc_link,\n\t.symlink\t= nfs4_proc_symlink,\n\t.mkdir\t\t= nfs4_proc_mkdir,\n\t.rmdir\t\t= nfs4_proc_remove,\n\t.readdir\t= nfs4_proc_readdir,\n\t.mknod\t\t= nfs4_proc_mknod,\n\t.statfs\t\t= nfs4_proc_statfs,\n\t.fsinfo\t\t= nfs4_proc_fsinfo,\n\t.pathconf\t= nfs4_proc_pathconf,\n\t.set_capabilities = nfs4_server_capabilities,\n\t.decode_dirent\t= nfs4_decode_dirent,\n\t.read_setup\t= nfs4_proc_read_setup,\n\t.read_pageio_init = pnfs_pageio_init_read,\n\t.read_rpc_prepare = nfs4_proc_read_rpc_prepare,\n\t.read_done\t= nfs4_read_done,\n\t.write_setup\t= nfs4_proc_write_setup,\n\t.write_pageio_init = pnfs_pageio_init_write,\n\t.write_rpc_prepare = nfs4_proc_write_rpc_prepare,\n\t.write_done\t= nfs4_write_done,\n\t.commit_setup\t= nfs4_proc_commit_setup,\n\t.commit_rpc_prepare = nfs4_proc_commit_rpc_prepare,\n\t.commit_done\t= nfs4_commit_done,\n\t.lock\t\t= nfs4_proc_lock,\n\t.clear_acl_cache = nfs4_zap_acl_attr,\n\t.close_context  = nfs4_close_context,\n\t.open_context\t= nfs4_atomic_open,\n\t.have_delegation = nfs4_have_delegation,\n\t.return_delegation = nfs4_inode_return_delegation,\n\t.alloc_client\t= nfs4_alloc_client,\n\t.init_client\t= nfs4_init_client,\n\t.free_client\t= nfs4_free_client,\n\t.create_server\t= nfs4_create_server,\n\t.clone_server\t= nfs_clone_server,\n};\n\nstatic const struct xattr_handler nfs4_xattr_nfs4_acl_handler = {\n\t.prefix\t= XATTR_NAME_NFSV4_ACL,\n\t.list\t= nfs4_xattr_list_nfs4_acl,\n\t.get\t= nfs4_xattr_get_nfs4_acl,\n\t.set\t= nfs4_xattr_set_nfs4_acl,\n};\n\nconst struct xattr_handler *nfs4_xattr_handlers[] = {\n\t&nfs4_xattr_nfs4_acl_handler,\n\tNULL\n};\n\n/*\n * Local variables:\n *  c-basic-offset: 8\n * End:\n */\n"], "filenames": ["fs/nfs/nfs4proc.c"], "buggy_code_start_loc": [3940], "buggy_code_end_loc": [3941], "fixing_code_start_loc": [3940], "fixing_code_end_loc": [3947], "type": "CWE-119", "message": "Buffer overflow in the __nfs4_get_acl_uncached function in fs/nfs/nfs4proc.c in the Linux kernel before 3.7.2 allows local users to cause a denial of service (memory corruption and system crash) or possibly have unspecified other impact via a getxattr system call for the system.nfs4_acl extended attribute of a pathname on an NFSv4 filesystem.", "other": {"cve": {"id": "CVE-2013-4591", "sourceIdentifier": "secalert@redhat.com", "published": "2013-11-20T13:19:42.227", "lastModified": "2023-02-13T04:48:48.897", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Buffer overflow in the __nfs4_get_acl_uncached function in fs/nfs/nfs4proc.c in the Linux kernel before 3.7.2 allows local users to cause a denial of service (memory corruption and system crash) or possibly have unspecified other impact via a getxattr system call for the system.nfs4_acl extended attribute of a pathname on an NFSv4 filesystem."}, {"lang": "es", "value": "Desbordamiento de b\u00fafer en la funci\u00f3n __nfs4_get_acl_uncached en fs/nfs/nfs4proc.c del kernel de Linux anterior a la versi\u00f3n 3.7.2 permite a usuarios locales provocar una denegaci\u00f3n de servicio (corrupci\u00f3n de memoria y ca\u00edda del sistema) o posiblemente tener otro impacto sin especificar a trav\u00e9s de la llamada de sistema getxattr para el atributo extendido system.nfs4_acl de un nombre de ruta en un archivo de sistema NFSv4."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:H/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "HIGH", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 6.2}, "baseSeverity": "MEDIUM", "exploitabilityScore": 1.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.7.1", "matchCriteriaId": "3D4AEC3C-BF4D-4B80-8D3E-4B7696B50180"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "D30AEC07-3CBD-4F4F-9646-BEAA1D98750B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "C2AA8E68-691B-499C-AEDD-3C0BFFE70044"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "9440475B-5960-4066-A204-F30AAFC87846"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc4:*:*:*:*:*:*", "matchCriteriaId": "53BCFBFB-6AF0-4525-8623-7633CC5E17DB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc5:*:*:*:*:*:*", "matchCriteriaId": "6ED4E86A-74F0-436A-BEB4-3F4EE93A5421"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc6:*:*:*:*:*:*", "matchCriteriaId": "BF0365B0-8E16-4F30-BD92-5DD538CC8135"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc7:*:*:*:*:*:*", "matchCriteriaId": "079505E8-2942-4C33-93D1-35ADA4C39E72"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "38989541-2360-4E0A-AE5A-3D6144AA6114"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "4E51646B-7A0E-40F3-B8C9-239C1DA81DD1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "42A8A507-F8E2-491C-A144-B2448A1DB26E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "901FC6F3-2C2A-4112-AE27-AB102BBE8DEE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "203AD334-DB9F-41B0-A4D1-A6C158EF8C40"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "B3611753-E440-410F-8250-600C996A4B8E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.7:*:*:*:*:*:*:*", "matchCriteriaId": "9739BB47-EEAF-42F1-A557-2AE2EA9526A3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.8:*:*:*:*:*:*:*", "matchCriteriaId": "5A95E3BB-0AFC-4C2E-B9BE-C975E902A266"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.9:*:*:*:*:*:*:*", "matchCriteriaId": "482A6C9A-9B8E-4D1C-917A-F16370745E7C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.10:*:*:*:*:*:*:*", "matchCriteriaId": "C6D87357-63E0-41D0-9F02-1BCBF9A77E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.11:*:*:*:*:*:*:*", "matchCriteriaId": "3765A2D6-2D78-4FB1-989E-D5106BFA3F5E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.12:*:*:*:*:*:*:*", "matchCriteriaId": "F54257DB-7023-43C4-AC4D-9590B815CD92"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.13:*:*:*:*:*:*:*", "matchCriteriaId": "61FF5FCD-A4A1-4803-AC53-320A4C838AF6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.14:*:*:*:*:*:*:*", "matchCriteriaId": "9F096553-064F-46A2-877B-F32F163A0F49"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.15:*:*:*:*:*:*:*", "matchCriteriaId": "C0D762D1-E3AD-40EA-8D39-83EEB51B5E85"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.16:*:*:*:*:*:*:*", "matchCriteriaId": "A6187D19-7148-4B87-AD7E-244FF9EE0FA6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.17:*:*:*:*:*:*:*", "matchCriteriaId": "99AC64C2-E391-485C-9CD7-BA09C8FA5E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.18:*:*:*:*:*:*:*", "matchCriteriaId": "8CDA5E95-7805-441B-BEF7-4448EA45E964"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.19:*:*:*:*:*:*:*", "matchCriteriaId": "51561053-6C28-4F38-BC9B-3F7A7508EB72"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.20:*:*:*:*:*:*:*", "matchCriteriaId": "118F4A5B-C498-4FC3-BE28-50D18EBE4F22"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.21:*:*:*:*:*:*:*", "matchCriteriaId": "BD38EBE6-FE1A-4B55-9FB5-07952253B7A5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.22:*:*:*:*:*:*:*", "matchCriteriaId": "3A491E47-82AD-4055-9444-2EC0D6715326"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.23:*:*:*:*:*:*:*", "matchCriteriaId": "13C5FD16-23B6-467F-9438-5B554922F974"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.24:*:*:*:*:*:*:*", "matchCriteriaId": "9C67235F-5B51-4BF7-89EC-4810F720246F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.25:*:*:*:*:*:*:*", "matchCriteriaId": "08405DEF-05F4-45F0-AC95-DBF914A36D93"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.26:*:*:*:*:*:*:*", "matchCriteriaId": "1A7B9C4B-4A41-4175-9F07-191C1EE98C1F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.27:*:*:*:*:*:*:*", "matchCriteriaId": "B306E0A8-4D4A-4895-8128-A500D30A7E0C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.28:*:*:*:*:*:*:*", "matchCriteriaId": "295C839A-F34E-4853-A926-55EABC639412"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.29:*:*:*:*:*:*:*", "matchCriteriaId": "2AFD5F49-7EF9-4CFE-95BD-8FD19B500B0A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.30:*:*:*:*:*:*:*", "matchCriteriaId": "00B3DDDD-B2F6-4753-BA38-65A24017857D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.31:*:*:*:*:*:*:*", "matchCriteriaId": "33FCD39E-F4BF-432D-9CF9-F195CF5844F3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.32:*:*:*:*:*:*:*", "matchCriteriaId": "C7308690-CB0D-4758-B80F-D2ADCD2A9D66"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.33:*:*:*:*:*:*:*", "matchCriteriaId": "313A470B-8A2B-478A-82B5-B27D2718331C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.34:*:*:*:*:*:*:*", "matchCriteriaId": "83FF021E-07E3-41CC-AAE8-D99D7FF24B9D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.35:*:*:*:*:*:*:*", "matchCriteriaId": "F72412E3-8DA9-4CC9-A426-B534202ADBA4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.36:*:*:*:*:*:*:*", "matchCriteriaId": "FCAA9D7A-3C3E-4C0B-9D38-EA80E68C2E46"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.37:*:*:*:*:*:*:*", "matchCriteriaId": "4A9E3AE5-3FCF-4CBB-A30B-082BCFBFB0CB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.38:*:*:*:*:*:*:*", "matchCriteriaId": "CF715657-4C3A-4392-B85D-1BBF4DE45D89"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.39:*:*:*:*:*:*:*", "matchCriteriaId": "4B63C618-AC3D-4EF7-AFDF-27B9BF482B78"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.40:*:*:*:*:*:*:*", "matchCriteriaId": "C33DA5A9-5E40-4365-9602-82FB4DCD15B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.41:*:*:*:*:*:*:*", "matchCriteriaId": "EFAFDB74-40BD-46FA-89AC-617EB2C7160B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.42:*:*:*:*:*:*:*", "matchCriteriaId": "CF5F17DA-30A7-40CF-BD7C-CEDF06D64617"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.43:*:*:*:*:*:*:*", "matchCriteriaId": "71A276F5-BD9D-4C1B-90DF-9B0C15B6F7DF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.44:*:*:*:*:*:*:*", "matchCriteriaId": "F8F6EBEC-3C29-444B-BB85-6EF239B59EC1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.45:*:*:*:*:*:*:*", "matchCriteriaId": "FDB91302-FD18-44CF-A8A8-B31483328539"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.46:*:*:*:*:*:*:*", "matchCriteriaId": "9B81DC2B-46FA-4640-AD6C-2A404D94BA0B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.47:*:*:*:*:*:*:*", "matchCriteriaId": "BA6A1663-BC4C-4FC9-B5EB-A52EDED17B26"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.48:*:*:*:*:*:*:*", "matchCriteriaId": "69C33D6C-6B9F-49F4-B505-E7B589CDEC50"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.49:*:*:*:*:*:*:*", "matchCriteriaId": "C464796B-2F31-4159-A132-82A0C74137B7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.50:*:*:*:*:*:*:*", "matchCriteriaId": "1D6C6E46-FE29-4D2D-A0EC-43DA5112BCC3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.51:*:*:*:*:*:*:*", "matchCriteriaId": "1A370E91-73A1-4D62-8E7B-696B920203F8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.52:*:*:*:*:*:*:*", "matchCriteriaId": "340197CD-9645-4B7E-B976-F3F5A7D4C5BE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.53:*:*:*:*:*:*:*", "matchCriteriaId": "96030636-0C4A-4A10-B768-525D6A0E18CB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.54:*:*:*:*:*:*:*", "matchCriteriaId": "A42D8419-914F-4AD6-B0E9-C1290D514FF1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.55:*:*:*:*:*:*:*", "matchCriteriaId": "F4E2C88B-42EA-4F4F-B1F6-A9332EC6888B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.56:*:*:*:*:*:*:*", "matchCriteriaId": "2449D13B-3314-4182-832F-03F6B11AA31F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.57:*:*:*:*:*:*:*", "matchCriteriaId": "9A35B66C-F050-4462-A58E-FEE061B5582E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.58:*:*:*:*:*:*:*", "matchCriteriaId": "1B551164-0167-49BB-A3AE-4034BDA3DCB4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.59:*:*:*:*:*:*:*", "matchCriteriaId": "7244278E-49B6-4405-A14C-F3540C8F5AF8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.60:*:*:*:*:*:*:*", "matchCriteriaId": "B4C3E4B8-7274-4ABB-B7CE-6A39C183CE18"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.61:*:*:*:*:*:*:*", "matchCriteriaId": "6501EDB9-4847-47F8-90EE-B295626E4CDC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.62:*:*:*:*:*:*:*", "matchCriteriaId": "2D676D48-7521-45E2-8563-6B966FF86A35"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.63:*:*:*:*:*:*:*", "matchCriteriaId": "3B69FA17-0AB9-4986-A5A7-2A4C1DD24222"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.64:*:*:*:*:*:*:*", "matchCriteriaId": "7BC35593-96C7-41F0-B738-1568F8129121"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.65:*:*:*:*:*:*:*", "matchCriteriaId": "38D23794-0E7C-4FA5-A7A8-CF940E3FA962"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.66:*:*:*:*:*:*:*", "matchCriteriaId": "008E1E7D-4C20-4560-9288-EF532ADB0029"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.67:*:*:*:*:*:*:*", "matchCriteriaId": "3B3A7044-A92E-47A9-A7BD-35E5B575F5FD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.68:*:*:*:*:*:*:*", "matchCriteriaId": "783E2980-B6AB-489E-B157-B6A2E10A32CA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:*:*:*:*:*:*:*", "matchCriteriaId": "3DFFE5A6-6A67-4992-84A3-C0F05FACDEAD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc1:*:*:*:*:*:*", "matchCriteriaId": "13BBD2A3-AE10-48B9-8776-4FB1CAC37D44"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc2:*:*:*:*:*:*", "matchCriteriaId": "B25680CC-8918-4F27-8D7E-A6579215450B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc3:*:*:*:*:*:*", "matchCriteriaId": "92C48B4C-410C-4BA8-A28A-B2E928320FCC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc4:*:*:*:*:*:*", "matchCriteriaId": "CB447523-855B-461E-8197-95169BE86EB0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "B155BBDF-6DF6-4FF5-9C41-D8A5266DCC67"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "28476DEC-9630-4B40-9D4D-9BC151DC4CA4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.3:*:*:*:*:*:*:*", "matchCriteriaId": "5646880A-2355-4BDD-89E7-825863A0311F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.4:*:*:*:*:*:*:*", "matchCriteriaId": "7FF99148-267A-46F8-9927-A9082269BAF6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.5:*:*:*:*:*:*:*", "matchCriteriaId": "A783C083-5D9C-48F9-B5A6-A97A9604FB19"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.6:*:*:*:*:*:*:*", "matchCriteriaId": "2B817A24-03AC-46CD-BEFA-505457FD2A5D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.7:*:*:*:*:*:*:*", "matchCriteriaId": "51CF1BCE-090E-4B70-BA16-ACB74411293B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.8:*:*:*:*:*:*:*", "matchCriteriaId": "187AAD67-10D7-4B57-B4C6-00443E246AF3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.9:*:*:*:*:*:*:*", "matchCriteriaId": "F341CE88-C5BC-4CDD-9CB5-B6BAD7152E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.10:*:*:*:*:*:*:*", "matchCriteriaId": "37ACE2A6-C229-4236-8E9F-235F008F3AA0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:*:*:*:*:*:*:*", "matchCriteriaId": "D3220B70-917F-4F9F-8A3B-2BF581281E8D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc2:*:*:*:*:*:*", "matchCriteriaId": "99372D07-C06A-41FA-9843-6D57F99AB5AF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc3:*:*:*:*:*:*", "matchCriteriaId": "2B9DC110-D260-4DB4-B8B0-EF1D160ADA07"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc4:*:*:*:*:*:*", "matchCriteriaId": "6192FE84-4D53-40D4-AF61-78CE7136141A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc5:*:*:*:*:*:*", "matchCriteriaId": "42FEF3CF-1302-45EB-89CC-3786FE4BAC1F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc6:*:*:*:*:*:*", "matchCriteriaId": "AE6A6B58-2C89-4DE4-BA57-78100818095C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc7:*:*:*:*:*:*", "matchCriteriaId": "1D467F87-2F13-4D26-9A93-E0BA526FEA24"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "FE348F7B-02DE-47D5-8011-F83DA9426021"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "E91594EA-F0A3-41B3-A9C6-F7864FC2F229"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.3:*:*:*:*:*:*:*", "matchCriteriaId": "9E1ECCDB-0208-48F6-B44F-16CC0ECE3503"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.4:*:*:*:*:*:*:*", "matchCriteriaId": "FBA8B5DE-372E-47E0-A0F6-BE286D509CC3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.5:*:*:*:*:*:*:*", "matchCriteriaId": "9A1CA083-2CF8-45AE-9E15-1AA3A8352E3B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.6:*:*:*:*:*:*:*", "matchCriteriaId": "19D69A49-5290-4C5F-8157-719AD58D253D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.7:*:*:*:*:*:*:*", "matchCriteriaId": "290BD969-42E7-47B0-B21B-06DE4865432C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.8:*:*:*:*:*:*:*", "matchCriteriaId": "23A9E29E-DE78-4C73-9FBD-C2410F5FC8B8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.9:*:*:*:*:*:*:*", "matchCriteriaId": "018434C9-E75F-45CB-A169-DAB4B1D864D7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.10:*:*:*:*:*:*:*", "matchCriteriaId": "DC0AC68F-EC58-4C4F-8CBC-A59ECC00CCDE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.11:*:*:*:*:*:*:*", "matchCriteriaId": "C123C844-F6D7-471E-A62E-F756042FB1CD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.12:*:*:*:*:*:*:*", "matchCriteriaId": "A11C38BB-7FA2-49B0-AAC9-83DB387A06DB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.13:*:*:*:*:*:*:*", "matchCriteriaId": "61F3733C-E5F6-4855-B471-DF3FB823613B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.14:*:*:*:*:*:*:*", "matchCriteriaId": "1DDCA75F-9A06-4457-9A45-38A38E7F7086"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.15:*:*:*:*:*:*:*", "matchCriteriaId": "7AEA837E-7864-4003-8DB7-111ED710A7E1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.16:*:*:*:*:*:*:*", "matchCriteriaId": "B6FE471F-2D1F-4A1D-A197-7E46B75787E1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.17:*:*:*:*:*:*:*", "matchCriteriaId": "FDA9E6AB-58DC-4EC5-A25C-11F9D0B38BF7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.18:*:*:*:*:*:*:*", "matchCriteriaId": "DC6B8DB3-B05B-41A2-B091-342D66AAE8F5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.19:*:*:*:*:*:*:*", "matchCriteriaId": "958F0FF8-33EF-4A71-A0BD-572C85211DBA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.20:*:*:*:*:*:*:*", "matchCriteriaId": "FBA39F48-B02F-4C48-B304-DA9CCA055244"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.21:*:*:*:*:*:*:*", "matchCriteriaId": "1FF841F3-48A7-41D7-9C45-A8170435A5EB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.22:*:*:*:*:*:*:*", "matchCriteriaId": "EF506916-A6DC-4B1E-90E5-959492AF55F4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.23:*:*:*:*:*:*:*", "matchCriteriaId": "B3CDAD1F-2C6A-48C0-8FAB-C2659373FA25"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.24:*:*:*:*:*:*:*", "matchCriteriaId": "4FFE4B22-C96A-43D0-B993-F51EDD9C5E0E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.25:*:*:*:*:*:*:*", "matchCriteriaId": "F571CC8B-B212-4553-B463-1DB01D616E8A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.26:*:*:*:*:*:*:*", "matchCriteriaId": "84E3E151-D437-48ED-A529-731EEFF88567"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.27:*:*:*:*:*:*:*", "matchCriteriaId": "E9E3EA3C-CCA5-4433-86E0-3D02C4757A0A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.28:*:*:*:*:*:*:*", "matchCriteriaId": "F7AC4F7D-9FA6-4CF1-B2E9-70BF7D4D177C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.29:*:*:*:*:*:*:*", "matchCriteriaId": "3CE3A80D-9648-43CC-8F99-D741ED6552BF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.30:*:*:*:*:*:*:*", "matchCriteriaId": "C8A98C03-A465-41B4-A551-A26FEC7FFD94"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:*:*:*:*:*:*:*", "matchCriteriaId": "AFB76697-1C2F-48C0-9B14-517EC053D4B3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc1:*:*:*:*:*:*", "matchCriteriaId": "BED88DFD-1DC5-4505-A441-44ECDEF0252D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc2:*:*:*:*:*:*", "matchCriteriaId": "DBFD2ACD-728A-4082-BB6A-A1EF6E58E47D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc3:*:*:*:*:*:*", "matchCriteriaId": "C31B0E51-F62D-4053-B04F-FC4D5BC373D2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc4:*:*:*:*:*:*", "matchCriteriaId": "A914303E-1CB6-4AAD-9F5F-DE5433C4E814"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc5:*:*:*:*:*:*", "matchCriteriaId": "203BBA69-90B2-4C5E-8023-C14180742421"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc6:*:*:*:*:*:*", "matchCriteriaId": "0DBFAB53-B889-4028-AC0E-7E165B152A18"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc7:*:*:*:*:*:*", "matchCriteriaId": "FE409AEC-F677-4DEF-8EB7-2C35809043CE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "578EC12B-402F-4AD4-B8F8-C9B2CAB06891"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.2:*:*:*:*:*:*:*", "matchCriteriaId": "877002ED-8097-4BB4-BB88-6FC6306C38B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.3:*:*:*:*:*:*:*", "matchCriteriaId": "76294CE3-D72C-41D5-9E0F-B693D0042699"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.4:*:*:*:*:*:*:*", "matchCriteriaId": "916E97D4-1FAB-42F5-826B-653B1C0909A8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.5:*:*:*:*:*:*:*", "matchCriteriaId": "33FD2217-C5D0-48C1-AD74-3527127FEF9C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.6:*:*:*:*:*:*:*", "matchCriteriaId": "2E92971F-B629-4E0A-9A50-8B235F9704B8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.7:*:*:*:*:*:*:*", "matchCriteriaId": "EDD3A069-3829-4EE2-9D5A-29459F29D4C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.8:*:*:*:*:*:*:*", "matchCriteriaId": "A4A0964C-CEB2-41D7-A69C-1599B05B6171"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:*:*:*:*:*:*:*", "matchCriteriaId": "0F960FA6-F904-4A4E-B483-44C70090E9A1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc1:*:*:*:*:*:*", "matchCriteriaId": "261C1B41-C9E0-414F-8368-51C0C0B8AD38"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc2:*:*:*:*:*:*", "matchCriteriaId": "5CCA261D-2B97-492F-89A0-5F209A804350"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc3:*:*:*:*:*:*", "matchCriteriaId": "1B1C0C68-9194-473F-BE5E-EC7F184899FA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc4:*:*:*:*:*:*", "matchCriteriaId": "D7A6AC9E-BEA6-44B0-B3B3-F0F94E32424A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc5:*:*:*:*:*:*", "matchCriteriaId": "16038328-9399-4B85-B777-BA4757D02C9B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc6:*:*:*:*:*:*", "matchCriteriaId": "16CA2757-FA8D-43D9-96E8-D3C0EB6E1DEF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc7:*:*:*:*:*:*", "matchCriteriaId": "E8CB5481-5EAE-401E-BD7E-D3095CCA9E94"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "A0F36FAC-141D-476D-84C5-A558C199F904"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "51D64824-25F6-4761-BD6A-29038A143744"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.3:*:*:*:*:*:*:*", "matchCriteriaId": "E284C8A1-740F-454D-A774-99CD3A21B594"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.4:*:*:*:*:*:*:*", "matchCriteriaId": "C70D72AE-0CBF-4324-9935-57E28EC6279C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.5:*:*:*:*:*:*:*", "matchCriteriaId": "F674B06B-7E86-4E41-9126-8152D0DDABAE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.6:*:*:*:*:*:*:*", "matchCriteriaId": "7039B3EC-8B22-413E-B582-B4BEC6181241"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.7:*:*:*:*:*:*:*", "matchCriteriaId": "35CF1DD2-80B9-4476-8963-5C3EF52B33F4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.8:*:*:*:*:*:*:*", "matchCriteriaId": "BFB0B05B-A5CE-4B9C-AE7F-83062868D35B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.9:*:*:*:*:*:*:*", "matchCriteriaId": "D166A66E-7454-47EC-BB56-861A9AFEAFE1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.10:*:*:*:*:*:*:*", "matchCriteriaId": "7DA94F50-2A62-4300-BF4D-A342AAE35629"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.11:*:*:*:*:*:*:*", "matchCriteriaId": "252D937B-50DC-444F-AE73-5FCF6203DF27"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.12:*:*:*:*:*:*:*", "matchCriteriaId": "F6D8EE51-02C1-47BC-A92C-0A8ABEFD28FF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.13:*:*:*:*:*:*:*", "matchCriteriaId": "7F20A5D7-3B38-4911-861A-04C8310D5916"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.14:*:*:*:*:*:*:*", "matchCriteriaId": "D472DE3A-71D8-4F40-9DDE-85929A2B047D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.15:*:*:*:*:*:*:*", "matchCriteriaId": "B2AED943-65A8-4FDB-BBD0-CCEF8682A48C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.16:*:*:*:*:*:*:*", "matchCriteriaId": "D4640185-F3D8-4575-A71D-4C889A93DE2C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.17:*:*:*:*:*:*:*", "matchCriteriaId": "144CCF7C-025E-4879-B2E7-ABB8E4390BE5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.18:*:*:*:*:*:*:*", "matchCriteriaId": "B6FAA052-0B2B-40CE-8C98-919B8D08A5ED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.19:*:*:*:*:*:*:*", "matchCriteriaId": "4B5A53DE-9C83-4A6B-96F3-23C03BF445D9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.20:*:*:*:*:*:*:*", "matchCriteriaId": "063EB879-CB05-4E33-AA90-9E43516839B5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.21:*:*:*:*:*:*:*", "matchCriteriaId": "2D25764F-4B02-4C65-954E-8C7D6632DE00"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.22:*:*:*:*:*:*:*", "matchCriteriaId": "F31F5BF3-CD0A-465C-857F-273841BCD28A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.23:*:*:*:*:*:*:*", "matchCriteriaId": "FF302C8A-079B-42B9-B455-CD9083BFA067"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.24:*:*:*:*:*:*:*", "matchCriteriaId": "744999C0-33D3-4363-B3DB-E0D02CDD3918"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.25:*:*:*:*:*:*:*", "matchCriteriaId": "C2E77A76-2A60-45D8-9337-867BC22C5110"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.26:*:*:*:*:*:*:*", "matchCriteriaId": "C9F4AAE7-C870-46B7-B559-2949737BE777"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.27:*:*:*:*:*:*:*", "matchCriteriaId": "20FA2824-20B0-48B8-BB0A-4904C1D3E8AA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.28:*:*:*:*:*:*:*", "matchCriteriaId": "9F9B347E-61AC-419F-9701-B862BBFA46F2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.29:*:*:*:*:*:*:*", "matchCriteriaId": "989F351C-8B7C-4C1B-AFA2-AE9431576368"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.30:*:*:*:*:*:*:*", "matchCriteriaId": "8D22172A-9FA7-42E0-8451-165D8E47A573"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.31:*:*:*:*:*:*:*", "matchCriteriaId": "CE31624C-94F9-45D8-9B4A-D0028F10602F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.32:*:*:*:*:*:*:*", "matchCriteriaId": "70967A83-28F6-4568-9ADA-6EF232E5BBC2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.1:*:*:*:*:*:*:*", "matchCriteriaId": "962B0C45-AB29-4383-AC16-C6E8245D0FF7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.2:*:*:*:*:*:*:*", "matchCriteriaId": "A0EE126B-74B2-4F79-BFE1-3DC169F3F9B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.3:*:*:*:*:*:*:*", "matchCriteriaId": "392075E0-A9C7-4B4A-90F9-7F1ADFF5EFA7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.4:*:*:*:*:*:*:*", "matchCriteriaId": "ECC66968-06F0-4874-A95A-A292C36E45C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.5:*:*:*:*:*:*:*", "matchCriteriaId": "5FE986E6-1068-4E1B-8EAB-DF1EAF32B4E3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.6:*:*:*:*:*:*:*", "matchCriteriaId": "543E8536-1A8E-4E76-B89F-1B1F9F26FAB8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.7:*:*:*:*:*:*:*", "matchCriteriaId": "EC2B45E3-31E1-4B46-85FA-3A84E75B8F84"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6:*:*:*:*:*:*:*", "matchCriteriaId": "DDB8CC75-D3EE-417C-A83D-CB6D666FE595"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.1:*:*:*:*:*:*:*", "matchCriteriaId": "09A072F1-7BEE-4236-ACBB-55DB8FEF4A03"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.2:*:*:*:*:*:*:*", "matchCriteriaId": "E19D5A58-17D6-4502-A57A-70B2F84817A4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.3:*:*:*:*:*:*:*", "matchCriteriaId": "D58BA035-1204-4DFA-98A1-12111FB6222E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.4:*:*:*:*:*:*:*", "matchCriteriaId": "A17F2E87-8EB8-476A-B5B5-9AE5CF53D9FE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.5:*:*:*:*:*:*:*", "matchCriteriaId": "A8CCC101-5852-4299-9B67-EA1B149D58C0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.6:*:*:*:*:*:*:*", "matchCriteriaId": "B8074D32-C252-4AD3-A579-1C5EDDD7014B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.7:*:*:*:*:*:*:*", "matchCriteriaId": "962AA802-8179-4606-AAC0-9363BAEABC9F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.8:*:*:*:*:*:*:*", "matchCriteriaId": "1286C858-D5A2-45F3-86D1-E50FE53FB23C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.9:*:*:*:*:*:*:*", "matchCriteriaId": "5AC4A13E-F560-4D01-98A3-E2A2B82EB25B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.10:*:*:*:*:*:*:*", "matchCriteriaId": "942C462A-5398-4BB9-A792-598682E1FEF2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.11:*:*:*:*:*:*:*", "matchCriteriaId": "B852F7E0-0282-483D-BB4D-18CB7A4F1392"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7:*:*:*:*:*:*:*", "matchCriteriaId": "53ED9A31-99CC-41C8-8B72-5B2A9B49AA6C"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=7d3e91a89b7adbc2831334def9e494dd9892f9af", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2013-1645.html", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2014-0284.html", "source": "secalert@redhat.com"}, {"url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.7.2", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2013/11/18/2", "source": "secalert@redhat.com"}, {"url": "http://www.securityfocus.com/bid/63791", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1031678", "source": "secalert@redhat.com"}, {"url": "https://github.com/torvalds/linux/commit/7d3e91a89b7adbc2831334def9e494dd9892f9af", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/7d3e91a89b7adbc2831334def9e494dd9892f9af"}}