{"buggy_code": ["/*-\n * Copyright (c) 2018 elementary LLC.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\npublic class PairDialog : Granite.MessageDialog {\n    public enum AuthType {\n        REQUEST_CONFIRMATION,\n        REQUEST_AUTHORIZATION,\n        DISPLAY_PASSKEY,\n        DISPLAY_PIN_CODE\n    }\n\n    public ObjectPath object_path { get; construct; }\n    public AuthType auth_type { get; construct; }\n    public string passkey { get; construct; }\n\n    // Un-used default constructor\n    private PairDialog () {\n        Object (\n            buttons: Gtk.ButtonsType.CANCEL\n        );\n    }\n\n    public PairDialog.request_authorization (ObjectPath object_path, Gtk.Window? main_window) {\n        Object (\n            auth_type: AuthType.REQUEST_AUTHORIZATION,\n            buttons: Gtk.ButtonsType.CANCEL,\n            object_path: object_path,\n            primary_text: _(\"Confirm Bluetooth Pairing\"),\n            transient_for: main_window\n        );\n    }\n\n    public PairDialog.display_passkey (ObjectPath object_path, uint32 passkey, uint16 entered, Gtk.Window? main_window) {\n        Object (\n            auth_type: AuthType.DISPLAY_PASSKEY,\n            buttons: Gtk.ButtonsType.CANCEL,\n            object_path: object_path,\n            passkey: \"%u\".printf (passkey),\n            primary_text: _(\"Confirm Bluetooth Passkey\"),\n            transient_for: main_window\n        );\n    }\n\n    public PairDialog.request_confirmation (ObjectPath object_path, uint32 passkey, Gtk.Window? main_window) {\n        Object (\n            auth_type: AuthType.REQUEST_CONFIRMATION,\n            buttons: Gtk.ButtonsType.CANCEL,\n            object_path: object_path,\n            passkey: \"%u\".printf (passkey),\n            primary_text: _(\"Confirm Bluetooth Passkey\"),\n            transient_for: main_window\n        );\n    }\n\n    public PairDialog.display_pin_code (ObjectPath object_path, string pincode, Gtk.Window? main_window) {\n        Object (\n            auth_type: AuthType.DISPLAY_PIN_CODE,\n            buttons: Gtk.ButtonsType.CANCEL,\n            object_path: object_path,\n            passkey: pincode,\n            primary_text: _(\"Enter Bluetooth PIN\"),\n            transient_for: main_window\n        );\n    }\n\n    construct {\n        Bluetooth.Services.Device device;\n        string device_name = _(\"Unknown Bluetooth Device\");\n        try {\n            device = Bus.get_proxy_sync (BusType.SYSTEM, \"org.bluez\", object_path, DBusProxyFlags.GET_INVALIDATED_PROPERTIES);\n            image_icon = new ThemedIcon (device.icon ?? \"bluetooth\");\n            device_name = device.name ?? device.address;\n        } catch (IOError e) {\n            image_icon = new ThemedIcon (\"bluetooth\");\n            critical (e.message);\n        }\n\n        switch (auth_type) {\n            case AuthType.REQUEST_CONFIRMATION:\n                badge_icon = new ThemedIcon (\"dialog-password\");\n                secondary_text = _(\"Make sure the code displayed on \u201c%s\u201d matches the one below.\").printf (device_name);\n                break;\n            case AuthType.DISPLAY_PASSKEY:\n                badge_icon = new ThemedIcon (\"dialog-password\");\n                secondary_text = _(\"\u201c%s\u201d would like to pair with this device. Make sure the code displayed on \u201c%s\u201d matches the one below.\").printf (device_name, device_name);\n\n                var confirm_button = add_button (_(\"Pair\"), Gtk.ResponseType.ACCEPT);\n                confirm_button.get_style_context ().add_class (Gtk.STYLE_CLASS_SUGGESTED_ACTION);\n            case AuthType.DISPLAY_PIN_CODE:\n                badge_icon = new ThemedIcon (\"dialog-password\");\n                secondary_text = _(\"Type the code displayed below on \u201c%s\u201d, followed by Enter.\").printf (device_name);\n                break;\n            case AuthType.REQUEST_AUTHORIZATION:\n                badge_icon = new ThemedIcon (\"dialog-question\");\n                secondary_text = _(\"\u201c%s\u201d would like to pair with this device.\").printf (device_name);\n\n                var confirm_button = add_button (_(\"Pair\"), Gtk.ResponseType.ACCEPT);\n                confirm_button.get_style_context ().add_class (Gtk.STYLE_CLASS_SUGGESTED_ACTION);\n                break;\n        }\n\n        if (passkey != null && passkey != \"\") {\n            var passkey_label = new Gtk.Label (passkey);\n            passkey_label.get_style_context ().add_class (Granite.STYLE_CLASS_H1_LABEL);\n\n            custom_bin.add (passkey_label);\n            custom_bin.show_all ();\n        }\n\n        modal = true;\n\n        response.connect ((response_id) => {\n            switch (response_id) {\n                case Gtk.ResponseType.ACCEPT:\n                    device.pair.begin ();\n                    break;\n                case Gtk.ResponseType.CANCEL:\n                    destroy ();\n                    break;\n            }\n        });\n\n        ((DBusProxy)device).g_properties_changed.connect ((changed, invalid) => {\n            var paired = changed.lookup_value (\"Paired\", new VariantType (\"b\"));\n            if (paired != null && device.paired) {\n                destroy ();\n            }\n        });\n    }\n}\n", "/*-\n * Copyright (c) 2018 elementary LLC.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n * Authored by: Corentin No\u00ebl <corentin@elementary.io>\n */\n\n[DBus (name = \"org.bluez.Error\")]\npublic errordomain BluezError {\n    REJECTED,\n    CANCELED\n}\n\n[DBus (name = \"org.bluez.Agent1\")]\npublic class Bluetooth.Services.Agent : Object {\n    private const string PATH = \"/org/bluez/agent/elementary\";\n    Gtk.Window? main_window;\n\n    [DBus (visible=false)]\n    public Agent (Gtk.Window? main_window) {\n        this.main_window = main_window;\n        Bus.own_name (BusType.SYSTEM, \"org.bluez.AgentManager1\", BusNameOwnerFlags.NONE,\n            (connection, name) => {\n                try {\n                    connection.register_object (PATH, this);\n                    ready = true;\n                } catch (Error e) {\n                    critical (e.message);\n                }\n            },\n            (connection, name) => {},\n            (connection, name) => {}\n        );\n    }\n\n    [DBus (visible=false)]\n    public bool ready { get; private set; }\n\n    [DBus (visible=false)]\n    public signal void unregistered ();\n\n    [DBus (visible=false)]\n    public GLib.ObjectPath get_path () {\n        return new GLib.ObjectPath (PATH);\n    }\n\n    public void release () throws Error {\n        unregistered ();\n    }\n\n    public string request_pin_code (ObjectPath device) throws Error, BluezError {\n        return \"\";\n    }\n\n    public void display_pin_code (ObjectPath device, string pincode) throws Error, BluezError {\n        var pair_dialog = new PairDialog.display_pin_code (device, pincode, main_window);\n        pair_dialog.present ();\n    }\n\n    public uint32 request_passkey (ObjectPath device) throws Error, BluezError {\n        return 0;\n    }\n\n    public void display_passkey (ObjectPath device, uint32 passkey, uint16 entered) throws Error {\n        var pair_dialog = new PairDialog.display_passkey (device, passkey, entered, main_window);\n        pair_dialog.present ();\n    }\n\n    public void request_confirmation (ObjectPath device, uint32 passkey) throws Error, BluezError {\n        var pair_dialog = new PairDialog.request_confirmation (device, passkey, main_window);\n        pair_dialog.present ();\n    }\n\n    public void request_authorization (ObjectPath device) throws Error, BluezError {\n        var pair_dialog = new PairDialog.request_authorization (device, main_window);\n        pair_dialog.present ();\n    }\n\n    public void authorize_service (ObjectPath device, string uuid) throws Error, BluezError {\n    }\n\n    public void cancel () throws Error {\n    }\n}\n"], "fixing_code": ["/*-\n * Copyright (c) 2018 elementary LLC.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\npublic class PairDialog : Granite.MessageDialog {\n    public enum AuthType {\n        REQUEST_CONFIRMATION,\n        REQUEST_AUTHORIZATION,\n        DISPLAY_PASSKEY,\n        DISPLAY_PIN_CODE\n    }\n\n    public ObjectPath object_path { get; construct; }\n    public AuthType auth_type { get; construct; }\n    public string passkey { get; construct; }\n    public bool cancelled { get; set; }\n\n    // Un-used default constructor\n    private PairDialog () {\n        Object (\n            buttons: Gtk.ButtonsType.CANCEL\n        );\n    }\n\n    public PairDialog.request_authorization (ObjectPath object_path, Gtk.Window? main_window) {\n        Object (\n            auth_type: AuthType.REQUEST_AUTHORIZATION,\n            buttons: Gtk.ButtonsType.CANCEL,\n            object_path: object_path,\n            primary_text: _(\"Confirm Bluetooth Pairing\"),\n            transient_for: main_window\n        );\n    }\n\n    public PairDialog.display_passkey (ObjectPath object_path, uint32 passkey, uint16 entered, Gtk.Window? main_window) {\n        Object (\n            auth_type: AuthType.DISPLAY_PASSKEY,\n            buttons: Gtk.ButtonsType.CANCEL,\n            object_path: object_path,\n            passkey: \"%u\".printf (passkey),\n            primary_text: _(\"Confirm Bluetooth Passkey\"),\n            transient_for: main_window\n        );\n    }\n\n    public PairDialog.request_confirmation (ObjectPath object_path, uint32 passkey, Gtk.Window? main_window) {\n        Object (\n            auth_type: AuthType.REQUEST_CONFIRMATION,\n            buttons: Gtk.ButtonsType.CANCEL,\n            object_path: object_path,\n            passkey: \"%u\".printf (passkey),\n            primary_text: _(\"Confirm Bluetooth Passkey\"),\n            transient_for: main_window\n        );\n    }\n\n    public PairDialog.display_pin_code (ObjectPath object_path, string pincode, Gtk.Window? main_window) {\n        Object (\n            auth_type: AuthType.DISPLAY_PIN_CODE,\n            buttons: Gtk.ButtonsType.CANCEL,\n            object_path: object_path,\n            passkey: pincode,\n            primary_text: _(\"Enter Bluetooth PIN\"),\n            transient_for: main_window\n        );\n    }\n\n    construct {\n        Bluetooth.Services.Device device;\n        string device_name = _(\"Unknown Bluetooth Device\");\n        try {\n            device = Bus.get_proxy_sync (BusType.SYSTEM, \"org.bluez\", object_path, DBusProxyFlags.GET_INVALIDATED_PROPERTIES);\n            image_icon = new ThemedIcon (device.icon ?? \"bluetooth\");\n            device_name = device.name ?? device.address;\n        } catch (IOError e) {\n            image_icon = new ThemedIcon (\"bluetooth\");\n            critical (e.message);\n        }\n\n        switch (auth_type) {\n            case AuthType.REQUEST_CONFIRMATION:\n                badge_icon = new ThemedIcon (\"dialog-password\");\n                secondary_text = _(\"Make sure the code displayed on \u201c%s\u201d matches the one below.\").printf (device_name);\n\n                var confirm_button = add_button (_(\"Pair\"), Gtk.ResponseType.ACCEPT);\n                confirm_button.get_style_context ().add_class (Gtk.STYLE_CLASS_SUGGESTED_ACTION);\n                break;\n            case AuthType.DISPLAY_PASSKEY:\n                badge_icon = new ThemedIcon (\"dialog-password\");\n                secondary_text = _(\"\u201c%s\u201d would like to pair with this device. Make sure the code displayed on \u201c%s\u201d matches the one below.\").printf (device_name, device_name);\n\n                var confirm_button = add_button (_(\"Pair\"), Gtk.ResponseType.ACCEPT);\n                confirm_button.get_style_context ().add_class (Gtk.STYLE_CLASS_SUGGESTED_ACTION);\n                break;\n            case AuthType.DISPLAY_PIN_CODE:\n                badge_icon = new ThemedIcon (\"dialog-password\");\n                secondary_text = _(\"Type the code displayed below on \u201c%s\u201d, followed by Enter.\").printf (device_name);\n                break;\n            case AuthType.REQUEST_AUTHORIZATION:\n                badge_icon = new ThemedIcon (\"dialog-question\");\n                secondary_text = _(\"\u201c%s\u201d would like to pair with this device.\").printf (device_name);\n\n                var confirm_button = add_button (_(\"Pair\"), Gtk.ResponseType.ACCEPT);\n                confirm_button.get_style_context ().add_class (Gtk.STYLE_CLASS_SUGGESTED_ACTION);\n                break;\n        }\n\n        if (passkey != null && passkey != \"\") {\n            var passkey_label = new Gtk.Label (passkey);\n            passkey_label.get_style_context ().add_class (Granite.STYLE_CLASS_H1_LABEL);\n\n            custom_bin.add (passkey_label);\n            custom_bin.show_all ();\n        }\n\n        modal = true;\n    }\n}\n", "/*-\n * Copyright (c) 2018 elementary LLC.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n * Authored by: Corentin No\u00ebl <corentin@elementary.io>\n */\n\n[DBus (name = \"org.bluez.Error\")]\npublic errordomain BluezError {\n    REJECTED,\n    CANCELED\n}\n\n[DBus (name = \"org.bluez.Agent1\")]\npublic class Bluetooth.Services.Agent : Object {\n    private const string PATH = \"/org/bluez/agent/elementary\";\n    Gtk.Window? main_window;\n\n    private PairDialog pair_dialog;\n\n    [DBus (visible=false)]\n    public Agent (Gtk.Window? main_window) {\n        this.main_window = main_window;\n        Bus.own_name (BusType.SYSTEM, \"org.bluez.AgentManager1\", BusNameOwnerFlags.NONE,\n            (connection, name) => {\n                try {\n                    connection.register_object (PATH, this);\n                    ready = true;\n                } catch (Error e) {\n                    critical (e.message);\n                }\n            },\n            (connection, name) => {},\n            (connection, name) => {}\n        );\n    }\n\n    [DBus (visible=false)]\n    public bool ready { get; private set; }\n\n    [DBus (visible=false)]\n    public signal void unregistered ();\n\n    [DBus (visible=false)]\n    public GLib.ObjectPath get_path () {\n        return new GLib.ObjectPath (PATH);\n    }\n\n    public void release () throws Error {\n        unregistered ();\n    }\n\n    public async string request_pin_code (ObjectPath device) throws Error, BluezError {\n        throw new BluezError.REJECTED (\"Pairing method not supported\");\n    }\n\n    // Called to display a pin code on-screen that needs to be entered on the other device. Can return\n    // instantly\n    public async void display_pin_code (ObjectPath device, string pincode) throws Error, BluezError {\n        pair_dialog = new PairDialog.display_pin_code (device, pincode, main_window);\n        pair_dialog.present ();\n    }\n\n    public async uint32 request_passkey (ObjectPath device) throws Error, BluezError {\n        throw new BluezError.REJECTED (\"Pairing method not supported\");\n    }\n\n    // Called to display a passkey on-screen that needs to be entered on the other device. Can return\n    // instantly\n    public async void display_passkey (ObjectPath device, uint32 passkey, uint16 entered) throws Error {\n        pair_dialog = new PairDialog.display_passkey (device, passkey, entered, main_window);\n        pair_dialog.present ();\n    }\n\n    // Called to request confirmation from the user that they want to pair with the given device and that\n    // the passkey matches. **MUST** throw BluezError if pairing is to be rejected. This is handled in\n    // `check_pairing_response`. If the method returns without an error, pairing is authorized\n    public async void request_confirmation (ObjectPath device, uint32 passkey) throws Error, BluezError {\n        pair_dialog = new PairDialog.request_confirmation (device, passkey, main_window);\n        yield check_pairing_response (pair_dialog);\n    }\n\n    // Called to request confirmation from the user that they want to pair with the given device\n    // **MUST** throw BluezError if pairing is to be rejected. This is handled in `check_pairing_response`\n    // If the method returns without an error, pairing is authorized\n    public async void request_authorization (ObjectPath device) throws Error, BluezError {\n        pair_dialog = new PairDialog.request_authorization (device, main_window);\n        yield check_pairing_response (pair_dialog);\n    }\n\n    // Called to authorize the use of a specific service (Audio/HID/etc), so we restrict this to paired\n    // devices only\n    public void authorize_service (ObjectPath device_path, string uuid) throws Error, BluezError {\n        var device = get_device_from_object_path (device_path);\n\n        bool paired = device.paired;\n        bool trusted = device.trusted;\n\n        // Shouldn't really happen as trusted devices should be automatically authorized, but lets handle it anyway\n        if (paired && trusted) {\n            // allow\n            return;\n        }\n\n        // A device that has been paired, but not yet trusted, trust it and allow it to access\n        // services\n        if (paired && !trusted) {\n            device.trusted = true;\n            // allow\n            return;\n        }\n\n        // Reject everything else\n        throw new BluezError.REJECTED (\"Rejecting service auth, not paired or trusted\");\n    }\n\n    public void cancel () throws Error {\n        if (pair_dialog != null) {\n            pair_dialog.cancelled = true;\n            pair_dialog.destroy ();\n        }\n    }\n\n    private async void check_pairing_response (PairDialog dialog) throws BluezError {\n        SourceFunc callback = check_pairing_response.callback;\n        BluezError? error = null;\n\n        dialog.response.connect ((response) => {\n            if (response != Gtk.ResponseType.ACCEPT || dialog.cancelled) {\n                if (dialog.cancelled) {\n                    error = new BluezError.CANCELED (\"Pairing cancelled\");\n                } else {\n                    error = new BluezError.REJECTED (\"Pairing rejected\");\n                }\n            }\n\n            Idle.add ((owned)callback);\n            dialog.destroy ();\n        });\n\n        dialog.present ();\n\n        yield;\n\n        if (error != null) {\n            throw error;\n        }\n    }\n\n    private Device get_device_from_object_path (ObjectPath object_path) throws GLib.Error {\n        return Bus.get_proxy_sync<Device> (BusType.SYSTEM, \"org.bluez\", object_path, DBusProxyFlags.GET_INVALIDATED_PROPERTIES);\n    }\n}\n"], "filenames": ["src/PairDialog.vala", "src/Services/Agent.vala"], "buggy_code_start_loc": [28, 29], "buggy_code_end_loc": [143, 94], "fixing_code_start_loc": [29, 30], "fixing_code_end_loc": [129, 164], "type": "CWE-863", "message": "Switchboard Bluetooth Plug for elementary OS from version 2.3.0 and before version version 2.3.5 has an incorrect authorization vulnerability. When the Bluetooth plug is running (in discoverable mode), Bluetooth service requests and pairing requests are automatically accepted, allowing physically proximate attackers to pair with a device running an affected version of switchboard-plug-bluetooth without the active consent of the user. By default, elementary OS doesn't expose any services via Bluetooth that allow information to be extracted by paired Bluetooth devices. However, if such services (i.e. contact list sharing software) have been installed, it's possible that attackers have been able to extract data from such services without authorization. If no such services have been installed, attackers are only able to pair with a device running an affected version without authorization and then play audio out of the device or possibly present a HID device (keyboard, mouse, etc...) to control the device. As such, users should check the list of trusted/paired devices and remove any that are not 100% confirmed to be genuine. This is fixed in version 2.3.5. To reduce the likelihood of this vulnerability on an unpatched version, only open the Bluetooth plug for short intervals when absolutely necessary and preferably not in crowded public areas. To mitigate the risk entirely with unpatched versions, do not open the Bluetooth plug within switchboard at all, and use a different method for pairing devices if necessary (e.g. `bluetoothctl` CLI).", "other": {"cve": {"id": "CVE-2021-21367", "sourceIdentifier": "security-advisories@github.com", "published": "2021-03-12T17:15:12.753", "lastModified": "2021-03-23T17:05:16.137", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Switchboard Bluetooth Plug for elementary OS from version 2.3.0 and before version version 2.3.5 has an incorrect authorization vulnerability. When the Bluetooth plug is running (in discoverable mode), Bluetooth service requests and pairing requests are automatically accepted, allowing physically proximate attackers to pair with a device running an affected version of switchboard-plug-bluetooth without the active consent of the user. By default, elementary OS doesn't expose any services via Bluetooth that allow information to be extracted by paired Bluetooth devices. However, if such services (i.e. contact list sharing software) have been installed, it's possible that attackers have been able to extract data from such services without authorization. If no such services have been installed, attackers are only able to pair with a device running an affected version without authorization and then play audio out of the device or possibly present a HID device (keyboard, mouse, etc...) to control the device. As such, users should check the list of trusted/paired devices and remove any that are not 100% confirmed to be genuine. This is fixed in version 2.3.5. To reduce the likelihood of this vulnerability on an unpatched version, only open the Bluetooth plug for short intervals when absolutely necessary and preferably not in crowded public areas. To mitigate the risk entirely with unpatched versions, do not open the Bluetooth plug within switchboard at all, and use a different method for pairing devices if necessary (e.g. `bluetoothctl` CLI)."}, {"lang": "es", "value": "Switchboard Bluetooth Plug para el SO elementary desde la versi\u00f3n 2.3.0 y versiones anteriores a 2.3.5, presenta una vulnerabilidad de autorizaci\u00f3n incorrecta.&#xa0;Cuando Bluetooth plug se est\u00e1 ejecutando (en modo detectable), unas peticiones de servicio de Bluetooth y las peticiones de emparejamiento se aceptan autom\u00e1ticamente, lo que permite a  atacantes cercanos f\u00edsicamente emparejarse con un dispositivo que ejecuta una versi\u00f3n afectada de switchboard-plug-bluetooth sin el consentimiento activo del usuario.&#xa0;De forma predeterminada, el Sistema Operativo elementary no expone ning\u00fan servicio por medio de Bluetooth que permita que los dispositivos Bluetooth emparejados extraigan informaci\u00f3n.&#xa0;Sin embargo, si se han instalado dichos servicios (es decir, software para compartir listas de contactos), es posible que los atacantes han sido capaces de extraer datos de dichos servicios sin autorizaci\u00f3n.&#xa0;Si no se han instalado tales servicios,&#xa0;los atacantes solo pueden emparejarse con un dispositivo que ejecuta una versi\u00f3n afectada sin autorizaci\u00f3n y luego reproducir audio desde el dispositivo o posiblemente presentar un dispositivo HID (teclado, mouse, etc.) para controlar el dispositivo.&#xa0;Como tal, los usuarios deben verificar la lista de dispositivos confiables, emparejados y eliminar los que no est\u00e9n 100% confirmados como genuinos.&#xa0;Esto es corregido en la versi\u00f3n 2.3.5.&#xa0;Para reducir la probabilidad de esta vulnerabilidad en una versi\u00f3n sin parches, solo abra el plug de Bluetooth durante intervalos cortos cuando sea absolutamente necesario y preferiblemente no en \u00e1reas p\u00fablicas concurridas.&#xa0;Para mitigar el riesgo por completo con las versiones no parcheadas, no abra el plug de Bluetooth dentro de la switchboard y use un m\u00e9todo diferente para emparejar dispositivos si es necesario (por ejemplo, CLI \"bluetoothctl\")"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:A/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:A/AC:L/PR:N/UI:N/S:C/C:L/I:N/A:L", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:M/Au:N/C:P/I:P/A:N", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 5.5, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-863"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-863"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:elementary:switchboard_bluetooth_plug:*:*:*:*:*:elementary_os:*:*", "versionStartIncluding": "2.3.0", "versionEndExcluding": "2.3.5", "matchCriteriaId": "AC2A9759-1C40-4C89-AD5B-AEBEBF1931A6"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:32:*:*:*:*:*:*:*", "matchCriteriaId": "36D96259-24BD-44E2-96D9-78CE1D41F956"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}]}]}], "references": [{"url": "https://github.com/elementary/switchboard-plug-bluetooth/commit/86500e645a907538abafe5225b67cc12c03e7645", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/elementary/switchboard-plug-bluetooth/releases/tag/2.3.5", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/elementary/switchboard-plug-bluetooth/security/advisories/GHSA-5p3g-j69g-w2mq", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/AV7WKO5SZHTF3QEMX4WZ576HRECIG6VQ/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/O7TCGM4B45VLUJDCE5PHFYA5KBNHD4RA/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/SWUPPVFG76PXQA3AHSGKYPRMVZ5AYHZI/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/elementary/switchboard-plug-bluetooth/commit/86500e645a907538abafe5225b67cc12c03e7645"}}