{"buggy_code": ["/*\n * Copyright (C) 2004 Red Hat Inc.\n * Copyright (C) 2005 Martin Koegler\n * Copyright (C) 2010 TigerVNC Team\n * Copyright (C) 2010 m-privacy GmbH\n *    \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#ifndef HAVE_GNUTLS\n#error \"This header should not be compiled without HAVE_GNUTLS defined\"\n#endif\n\n#include <stdlib.h>\n#ifndef WIN32\n#include <unistd.h>\n#endif\n\n#include <rfb/CSecurityTLS.h>\n#include <rfb/SSecurityVeNCrypt.h> \n#include <rfb/CConnection.h>\n#include <rfb/LogWriter.h>\n#include <rfb/Exception.h>\n#include <rfb/UserMsgBox.h>\n#include <rdr/TLSInStream.h>\n#include <rdr/TLSOutStream.h>\n#include <os/os.h>\n\n#include <gnutls/x509.h>\n\n/*\n * GNUTLS 2.6.5 and older didn't have some variables defined so don't use them.\n * GNUTLS 1.X.X defined LIBGNUTLS_VERSION_NUMBER so treat it as \"old\" gnutls as\n * well\n */\n#if (defined(GNUTLS_VERSION_NUMBER) && GNUTLS_VERSION_NUMBER < 0x020606) || \\\n    defined(LIBGNUTLS_VERSION_NUMBER)\n#define WITHOUT_X509_TIMES\n#endif\n\n/* Ancient GNUTLS... */\n#if !defined(GNUTLS_VERSION_NUMBER) && !defined(LIBGNUTLS_VERSION_NUMBER)\n#define WITHOUT_X509_TIMES\n#endif\n\nusing namespace rfb;\n\nStringParameter CSecurityTLS::X509CA(\"X509CA\", \"X509 CA certificate\", \"\", ConfViewer);\nStringParameter CSecurityTLS::X509CRL(\"X509CRL\", \"X509 CRL file\", \"\", ConfViewer);\n\nstatic LogWriter vlog(\"TLS\");\n\nvoid CSecurityTLS::initGlobal()\n{\n  static bool globalInitDone = false;\n\n  if (!globalInitDone) {\n    gnutls_global_init();\n    globalInitDone = true;\n  }\n}\n\nCSecurityTLS::CSecurityTLS(bool _anon) : session(0), anon_cred(0),\n\t\t\t\t\t\t anon(_anon), fis(0), fos(0)\n{\n  cafile = X509CA.getData();\n  crlfile = X509CRL.getData();\n}\n\nvoid CSecurityTLS::setDefaults()\n{\n  char* homeDir = NULL;\n\n  if (getvnchomedir(&homeDir) == -1) {\n    vlog.error(\"Could not obtain VNC home directory path\");\n    return;\n  }\n\n  int len = strlen(homeDir) + 1;\n  CharArray caDefault(len + 11);\n  CharArray crlDefault(len + 12);\n  sprintf(caDefault.buf, \"%sx509_ca.pem\", homeDir);\n  sprintf(crlDefault.buf, \"%s509_crl.pem\", homeDir);\n  delete [] homeDir;\n\n if (!fileexists(caDefault.buf))\n   X509CA.setDefaultStr(strdup(caDefault.buf));\n if (!fileexists(crlDefault.buf))\n   X509CRL.setDefaultStr(strdup(crlDefault.buf));\n}\n\nvoid CSecurityTLS::shutdown(bool needbye)\n{\n  if (session && needbye)\n    if (gnutls_bye(session, GNUTLS_SHUT_RDWR) != GNUTLS_E_SUCCESS)\n      vlog.error(\"gnutls_bye failed\");\n\n  if (anon_cred) {\n    gnutls_anon_free_client_credentials(anon_cred);\n    anon_cred = 0;\n  }\n\n  if (cert_cred) {\n    gnutls_certificate_free_credentials(cert_cred);\n    cert_cred = 0;\n  }\n\n  if (session) {\n    gnutls_deinit(session);\n    session = 0;\n\n    gnutls_global_deinit();\n  }\n}\n\n\nCSecurityTLS::~CSecurityTLS()\n{\n  shutdown(true);\n\n  if (fis)\n    delete fis;\n  if (fos)\n    delete fos;\n\n  delete[] cafile;\n  delete[] crlfile;\n}\n\nbool CSecurityTLS::processMsg(CConnection* cc)\n{\n  rdr::InStream* is = cc->getInStream();\n  rdr::OutStream* os = cc->getOutStream();\n  client = cc;\n\n  initGlobal();\n\n  if (!session) {\n    if (!is->checkNoWait(1))\n      return false;\n\n    if (is->readU8() == 0) {\n      rdr::U32 result = is->readU32();\n      CharArray reason;\n      if (result == secResultFailed || result == secResultTooMany)\n        reason.buf = is->readString();\n      else\n        reason.buf = strDup(\"Authentication failure (protocol error)\");\n      throw AuthFailureException(reason.buf);\n    }\n\n    if (gnutls_init(&session, GNUTLS_CLIENT) != GNUTLS_E_SUCCESS)\n      throw AuthFailureException(\"gnutls_init failed\");\n\n    if (gnutls_set_default_priority(session) != GNUTLS_E_SUCCESS)\n      throw AuthFailureException(\"gnutls_set_default_priority failed\");\n\n    setParam();\n  }\n\n  rdr::TLSInStream *tlsis = new rdr::TLSInStream(is, session);\n  rdr::TLSOutStream *tlsos = new rdr::TLSOutStream(os, session);\n\n  int err;\n  err = gnutls_handshake(session);\n  if (err != GNUTLS_E_SUCCESS) {\n    delete tlsis;\n    delete tlsos;\n\n    if (!gnutls_error_is_fatal(err))\n      return false;\n\n    vlog.error(\"TLS Handshake failed: %s\\n\", gnutls_strerror (err));\n    shutdown(false);\n    throw AuthFailureException(\"TLS Handshake failed\");\n  }\n\n  checkSession();\n\n  cc->setStreams(fis = tlsis, fos = tlsos);\n\n  return true;\n}\n\nvoid CSecurityTLS::setParam()\n{\n  static const char kx_anon_priority[] = \":+ANON-ECDH:+ANON-DH\";\n\n  int ret;\n  char *prio;\n  const char *err;\n\n  prio = (char*)malloc(strlen(Security::GnuTLSPriority) +\n                       strlen(kx_anon_priority) + 1);\n  if (prio == NULL)\n    throw AuthFailureException(\"Not enough memory for GnuTLS priority string\");\n\n  strcpy(prio, Security::GnuTLSPriority);\n  if (anon)\n    strcat(prio, kx_anon_priority);\n\n  ret = gnutls_priority_set_direct(session, prio, &err);\n\n  free(prio);\n\n  if (ret != GNUTLS_E_SUCCESS) {\n    if (ret == GNUTLS_E_INVALID_REQUEST)\n      vlog.error(\"GnuTLS priority syntax error at: %s\", err);\n    throw AuthFailureException(\"gnutls_set_priority_direct failed\");\n  }\n\n  if (anon) {\n    if (gnutls_anon_allocate_client_credentials(&anon_cred) != GNUTLS_E_SUCCESS)\n      throw AuthFailureException(\"gnutls_anon_allocate_client_credentials failed\");\n\n    if (gnutls_credentials_set(session, GNUTLS_CRD_ANON, anon_cred) != GNUTLS_E_SUCCESS)\n      throw AuthFailureException(\"gnutls_credentials_set failed\");\n\n    vlog.debug(\"Anonymous session has been set\");\n  } else {\n    if (gnutls_certificate_allocate_credentials(&cert_cred) != GNUTLS_E_SUCCESS)\n      throw AuthFailureException(\"gnutls_certificate_allocate_credentials failed\");\n\n    if (*cafile && gnutls_certificate_set_x509_trust_file(cert_cred,cafile,GNUTLS_X509_FMT_PEM) < 0)\n      throw AuthFailureException(\"load of CA cert failed\");\n\n    /* Load previously saved certs */\n    char *homeDir = NULL;\n    int err;\n    if (getvnchomedir(&homeDir) == -1)\n      vlog.error(\"Could not obtain VNC home directory path\");\n    else {\n      CharArray caSave(strlen(homeDir) + 19 + 1);\n      sprintf(caSave.buf, \"%sx509_savedcerts.pem\", homeDir);\n      delete [] homeDir;\n\n      err = gnutls_certificate_set_x509_trust_file(cert_cred, caSave.buf,\n                                                   GNUTLS_X509_FMT_PEM);\n      if (err < 0)\n        vlog.debug(\"Failed to load saved server certificates from %s\", caSave.buf);\n    }\n\n    if (*crlfile && gnutls_certificate_set_x509_crl_file(cert_cred,crlfile,GNUTLS_X509_FMT_PEM) < 0)\n      throw AuthFailureException(\"load of CRL failed\");\n\n    if (gnutls_credentials_set(session, GNUTLS_CRD_CERTIFICATE, cert_cred) != GNUTLS_E_SUCCESS)\n      throw AuthFailureException(\"gnutls_credentials_set failed\");\n\n    vlog.debug(\"X509 session has been set\");\n  }\n}\n\nvoid CSecurityTLS::checkSession()\n{\n  const unsigned allowed_errors = GNUTLS_CERT_INVALID |\n\t\t\t\t  GNUTLS_CERT_SIGNER_NOT_FOUND |\n\t\t\t\t  GNUTLS_CERT_SIGNER_NOT_CA;\n  unsigned int status;\n  const gnutls_datum_t *cert_list;\n  unsigned int cert_list_size = 0;\n  int err;\n  gnutls_datum_t info;\n\n  if (anon)\n    return;\n\n  if (gnutls_certificate_type_get(session) != GNUTLS_CRT_X509)\n    throw AuthFailureException(\"unsupported certificate type\");\n\n  err = gnutls_certificate_verify_peers2(session, &status);\n  if (err != 0) {\n    vlog.error(\"server certificate verification failed: %s\", gnutls_strerror(err));\n    throw AuthFailureException(\"server certificate verification failed\");\n  }\n\n  if (status & GNUTLS_CERT_REVOKED)\n    throw AuthFailureException(\"server certificate has been revoked\");\n\n#ifndef WITHOUT_X509_TIMES\n  if (status & GNUTLS_CERT_NOT_ACTIVATED)\n    throw AuthFailureException(\"server certificate has not been activated\");\n\n  if (status & GNUTLS_CERT_EXPIRED) {\n    vlog.debug(\"server certificate has expired\");\n    if (!msg->showMsgBox(UserMsgBox::M_YESNO, \"certificate has expired\",\n\t\t\t \"The certificate of the server has expired, \"\n\t\t\t \"do you want to continue?\"))\n      throw AuthFailureException(\"server certificate has expired\");\n  }\n#endif\n  /* Process other errors later */\n\n  cert_list = gnutls_certificate_get_peers(session, &cert_list_size);\n  if (!cert_list_size)\n    throw AuthFailureException(\"empty certificate chain\");\n\n  /* Process only server's certificate, not issuer's certificate */\n  gnutls_x509_crt_t crt;\n  gnutls_x509_crt_init(&crt);\n\n  if (gnutls_x509_crt_import(crt, &cert_list[0], GNUTLS_X509_FMT_DER) < 0)\n    throw AuthFailureException(\"decoding of certificate failed\");\n\n  if (gnutls_x509_crt_check_hostname(crt, client->getServerName()) == 0) {\n    char buf[255];\n    vlog.debug(\"hostname mismatch\");\n    snprintf(buf, sizeof(buf), \"Hostname (%s) does not match any certificate, \"\n\t\t\t       \"do you want to continue?\", client->getServerName());\n    buf[sizeof(buf) - 1] = '\\0';\n    if (!msg->showMsgBox(UserMsgBox::M_YESNO, \"hostname mismatch\", buf))\n      throw AuthFailureException(\"hostname mismatch\");\n  }\n\n  if (status == 0) {\n    /* Everything is fine (hostname + verification) */\n    gnutls_x509_crt_deinit(crt);\n    return;\n  }\n    \n  if (status & GNUTLS_CERT_INVALID)\n    vlog.debug(\"server certificate invalid\");\n  if (status & GNUTLS_CERT_SIGNER_NOT_FOUND)\n    vlog.debug(\"server cert signer not found\");\n  if (status & GNUTLS_CERT_SIGNER_NOT_CA)\n    vlog.debug(\"server cert signer not CA\");\n\n  if ((status & (~allowed_errors)) != 0) {\n    /* No other errors are allowed */\n    vlog.debug(\"GNUTLS status of certificate verification: %u\", status);\n    throw AuthFailureException(\"Invalid status of server certificate verification\");\n  }\n\n  vlog.debug(\"Saved server certificates don't match\");\n\n  if (gnutls_x509_crt_print(crt, GNUTLS_CRT_PRINT_ONELINE, &info)) {\n    /*\n     * GNUTLS doesn't correctly export gnutls_free symbol which is\n     * a function pointer. Linking with Visual Studio 2008 Express will\n     * fail when you call gnutls_free().\n     */\n#if WIN32\n    free(info.data);\n#else\n    gnutls_free(info.data);\n#endif\n    throw AuthFailureException(\"Could not find certificate to display\");\n  }\n\n  size_t out_size = 0;\n  char *out_buf = NULL;\n  char *certinfo = NULL;\n  int len = 0;\n\n  vlog.debug(\"certificate issuer unknown\");\n\n  len = snprintf(NULL, 0, \"This certificate has been signed by an unknown \"\n                          \"authority:\\n\\n%s\\n\\nDo you want to save it and \"\n                          \"continue?\\n \", info.data);\n  if (len < 0)\n    AuthFailureException(\"certificate decoding error\");\n\n  vlog.debug(\"%s\", info.data);\n\n  certinfo = new char[len];\n  if (certinfo == NULL)\n    throw AuthFailureException(\"Out of memory\");\n\n  snprintf(certinfo, len, \"This certificate has been signed by an unknown \"\n                          \"authority:\\n\\n%s\\n\\nDo you want to save it and \"\n                          \"continue? \", info.data);\n\n  for (int i = 0; i < len - 1; i++)\n    if (certinfo[i] == ',' && certinfo[i + 1] == ' ')\n      certinfo[i] = '\\n';\n\n  if (!msg->showMsgBox(UserMsgBox::M_YESNO, \"certificate issuer unknown\",\n\t\t       certinfo)) {\n    delete [] certinfo;\n    throw AuthFailureException(\"certificate issuer unknown\");\n  }\n\n  delete [] certinfo;\n\n  if (gnutls_x509_crt_export(crt, GNUTLS_X509_FMT_PEM, NULL, &out_size)\n      == GNUTLS_E_SHORT_MEMORY_BUFFER)\n    AuthFailureException(\"Out of memory\");\n\n  // Save cert\n  out_buf =  new char[out_size];\n  if (out_buf == NULL)\n    AuthFailureException(\"Out of memory\");\n\n  if (gnutls_x509_crt_export(crt, GNUTLS_X509_FMT_PEM, out_buf, &out_size) < 0)\n    AuthFailureException(\"certificate issuer unknown, and certificate \"\n\t\t\t \"export failed\");\n\n  char *homeDir = NULL;\n  if (getvnchomedir(&homeDir) == -1)\n    vlog.error(\"Could not obtain VNC home directory path\");\n  else {\n    FILE *f;\n    CharArray caSave(strlen(homeDir) + 1 + 19);\n    sprintf(caSave.buf, \"%sx509_savedcerts.pem\", homeDir);\n    delete [] homeDir;\n    f = fopen(caSave.buf, \"a+\");\n    if (!f)\n      msg->showMsgBox(UserMsgBox::M_OK, \"certificate save failed\",\n                      \"Could not save the certificate\");\n    else {\n      fprintf(f, \"%s\\n\", out_buf);\n      fclose(f);\n    }\n  }\n\n  delete [] out_buf;\n\n  gnutls_x509_crt_deinit(crt);\n  /*\n   * GNUTLS doesn't correctly export gnutls_free symbol which is\n   * a function pointer. Linking with Visual Studio 2008 Express will\n   * fail when you call gnutls_free().\n   */\n#if WIN32\n  free(info.data);\n#else\n  gnutls_free(info.data);\n#endif\n}\n\n", "/* \n * Copyright (C) 2004 Red Hat Inc.\n * Copyright (C) 2005 Martin Koegler\n * Copyright (C) 2010 TigerVNC Team\n *    \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n#ifndef __C_SECURITY_TLS_H__\n#define __C_SECURITY_TLS_H__\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#ifndef HAVE_GNUTLS\n#error \"This header should not be compiled without HAVE_GNUTLS defined\"\n#endif\n\n#include <rfb/CSecurity.h>\n#include <rfb/SSecurityVeNCrypt.h>\n#include <rfb/Security.h>\n#include <rfb/UserMsgBox.h>\n#include <rdr/InStream.h>\n#include <rdr/OutStream.h>\n#include <gnutls/gnutls.h>\n\nnamespace rfb {\n  class UserMsgBox;\n  class CSecurityTLS : public CSecurity {\n  public:\n    CSecurityTLS(bool _anon);\n    virtual ~CSecurityTLS();\n    virtual bool processMsg(CConnection* cc);\n    virtual int getType() const { return anon ? secTypeTLSNone : secTypeX509None; }\n    virtual const char* description() const\n      { return anon ? \"TLS Encryption without VncAuth\" : \"X509 Encryption without VncAuth\"; }\n    static void setDefaults();\n\n    static StringParameter X509CA;\n    static StringParameter X509CRL;\n    static UserMsgBox *msg;\n\n  protected:\n    void shutdown(bool needbye);\n    void freeResources();\n    void setParam();\n    void checkSession();\n    CConnection *client;\n\n  private:\n    static void initGlobal();\n\n    gnutls_session_t session;\n    gnutls_anon_client_credentials_t anon_cred;\n    gnutls_certificate_credentials_t cert_cred;\n    bool anon;\n\n    char *cafile, *crlfile;\n    rdr::InStream* fis;\n    rdr::OutStream* fos;\n  };\n}\n\n#endif\n", "/* \n * Copyright (C) 2004 Red Hat Inc.\n * Copyright (C) 2005 Martin Koegler\n * Copyright (C) 2010 TigerVNC Team\n *    \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#ifndef HAVE_GNUTLS\n#error \"This source should not be compiled without HAVE_GNUTLS defined\"\n#endif\n\n#include <stdlib.h>\n\n#include <rfb/SSecurityTLS.h>\n#include <rfb/SConnection.h>\n#include <rfb/LogWriter.h>\n#include <rfb/Exception.h>\n#include <rdr/TLSInStream.h>\n#include <rdr/TLSOutStream.h>\n\n#define DH_BITS 1024 /* XXX This should be configurable! */\n\nusing namespace rfb;\n\nStringParameter SSecurityTLS::X509_CertFile\n(\"X509Cert\", \"Path to the X509 certificate in PEM format\", \"\", ConfServer);\n\nStringParameter SSecurityTLS::X509_KeyFile\n(\"X509Key\", \"Path to the key of the X509 certificate in PEM format\", \"\", ConfServer);\n\nstatic LogWriter vlog(\"TLS\");\n\nvoid SSecurityTLS::initGlobal()\n{\n  static bool globalInitDone = false;\n\n  if (!globalInitDone) {\n    if (gnutls_global_init() != GNUTLS_E_SUCCESS)\n      throw AuthFailureException(\"gnutls_global_init failed\");\n    globalInitDone = true;\n  }\n}\n\nSSecurityTLS::SSecurityTLS(bool _anon) : session(0), dh_params(0),\n\t\t\t\t\t\t anon_cred(0), cert_cred(0),\n\t\t\t\t\t\t anon(_anon), fis(0), fos(0)\n{\n  certfile = X509_CertFile.getData();\n  keyfile = X509_KeyFile.getData();\n}\n\nvoid SSecurityTLS::shutdown()\n{\n  if (session) {\n    if (gnutls_bye(session, GNUTLS_SHUT_RDWR) != GNUTLS_E_SUCCESS) {\n      /* FIXME: Treat as non-fatal error */\n      vlog.error(\"TLS session wasn't terminated gracefully\");\n    }\n  }\n\n  if (dh_params) {\n    gnutls_dh_params_deinit(dh_params);\n    dh_params = 0;\n  }\n\n  if (anon_cred) {\n    gnutls_anon_free_server_credentials(anon_cred);\n    anon_cred = 0;\n  }\n\n  if (cert_cred) {\n    gnutls_certificate_free_credentials(cert_cred);\n    cert_cred = 0;\n  }\n\n  if (session) {\n    gnutls_deinit(session);\n    session = 0;\n\n    gnutls_global_deinit();\n  }\n}\n\n\nSSecurityTLS::~SSecurityTLS()\n{\n  shutdown();\n\n  if (fis)\n    delete fis;\n  if (fos)\n    delete fos;\n\n  delete[] keyfile;\n  delete[] certfile;\n}\n\nbool SSecurityTLS::processMsg(SConnection *sc)\n{\n  rdr::InStream* is = sc->getInStream();\n  rdr::OutStream* os = sc->getOutStream();\n\n  vlog.debug(\"Process security message (session %p)\", session);\n\n  if (!session) {\n    initGlobal();\n\n    if (gnutls_init(&session, GNUTLS_SERVER) != GNUTLS_E_SUCCESS)\n      throw AuthFailureException(\"gnutls_init failed\");\n\n    if (gnutls_set_default_priority(session) != GNUTLS_E_SUCCESS)\n      throw AuthFailureException(\"gnutls_set_default_priority failed\");\n\n    try {\n      setParams(session);\n    }\n    catch(...) {\n      os->writeU8(0);\n      throw;\n    }\n\n    os->writeU8(1);\n    os->flush();\n  }\n\n  rdr::TLSInStream *tlsis = new rdr::TLSInStream(is, session);\n  rdr::TLSOutStream *tlsos = new rdr::TLSOutStream(os, session);\n\n  int err;\n  err = gnutls_handshake(session);\n  if (err != GNUTLS_E_SUCCESS) {\n    delete tlsis;\n    delete tlsos;\n\n    if (!gnutls_error_is_fatal(err)) {\n      vlog.debug(\"Deferring completion of TLS handshake: %s\", gnutls_strerror(err));\n      return false;\n    }\n    vlog.error(\"TLS Handshake failed: %s\", gnutls_strerror (err));\n    shutdown();\n    throw AuthFailureException(\"TLS Handshake failed\");\n  }\n\n  vlog.debug(\"Handshake completed\");\n\n  sc->setStreams(fis = tlsis, fos = tlsos);\n\n  return true;\n}\n\nvoid SSecurityTLS::setParams(gnutls_session_t session)\n{\n  static const char kx_anon_priority[] = \":+ANON-ECDH:+ANON-DH\";\n\n  int ret;\n  char *prio;\n  const char *err;\n\n  prio = (char*)malloc(strlen(Security::GnuTLSPriority) +\n                       strlen(kx_anon_priority) + 1);\n  if (prio == NULL)\n    throw AuthFailureException(\"Not enough memory for GnuTLS priority string\");\n\n  strcpy(prio, Security::GnuTLSPriority);\n  if (anon)\n    strcat(prio, kx_anon_priority);\n\n  ret = gnutls_priority_set_direct(session, prio, &err);\n\n  free(prio);\n\n  if (ret != GNUTLS_E_SUCCESS) {\n    if (ret == GNUTLS_E_INVALID_REQUEST)\n      vlog.error(\"GnuTLS priority syntax error at: %s\", err);\n    throw AuthFailureException(\"gnutls_set_priority_direct failed\");\n  }\n\n  if (gnutls_dh_params_init(&dh_params) != GNUTLS_E_SUCCESS)\n    throw AuthFailureException(\"gnutls_dh_params_init failed\");\n\n  if (gnutls_dh_params_generate2(dh_params, DH_BITS) != GNUTLS_E_SUCCESS)\n    throw AuthFailureException(\"gnutls_dh_params_generate2 failed\");\n\n  if (anon) {\n    if (gnutls_anon_allocate_server_credentials(&anon_cred) != GNUTLS_E_SUCCESS)\n      throw AuthFailureException(\"gnutls_anon_allocate_server_credentials failed\");\n\n    gnutls_anon_set_server_dh_params(anon_cred, dh_params);\n\n    if (gnutls_credentials_set(session, GNUTLS_CRD_ANON, anon_cred)\n        != GNUTLS_E_SUCCESS)\n      throw AuthFailureException(\"gnutls_credentials_set failed\");\n\n    vlog.debug(\"Anonymous session has been set\");\n\n  } else {\n    if (gnutls_certificate_allocate_credentials(&cert_cred) != GNUTLS_E_SUCCESS)\n      throw AuthFailureException(\"gnutls_certificate_allocate_credentials failed\");\n\n    gnutls_certificate_set_dh_params(cert_cred, dh_params);\n\n    if (gnutls_certificate_set_x509_key_file(cert_cred, certfile, keyfile,\n        GNUTLS_X509_FMT_PEM) != GNUTLS_E_SUCCESS)\n      throw AuthFailureException(\"load of key failed\");\n\n    if (gnutls_credentials_set(session, GNUTLS_CRD_CERTIFICATE, cert_cred)\n        != GNUTLS_E_SUCCESS)\n      throw AuthFailureException(\"gnutls_credentials_set failed\");\n\n    vlog.debug(\"X509 session has been set\");\n\n  }\n\n}\n", "/* \n * Copyright (C) 2004 Red Hat Inc.\n * Copyright (C) 2005 Martin Koegler\n * Copyright (C) 2010 TigerVNC Team\n *    \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n#ifndef __S_SECURITY_TLS_H__\n#define __S_SECURITY_TLS_H__\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#ifndef HAVE_GNUTLS\n#error \"This header should not be included without HAVE_GNUTLS defined\"\n#endif\n\n#include <rfb/SSecurity.h>\n#include <rfb/SSecurityVeNCrypt.h>\n#include <rdr/InStream.h>\n#include <rdr/OutStream.h>\n#include <gnutls/gnutls.h>\n\nnamespace rfb {\n\n  class SSecurityTLS : public SSecurity {\n  public:\n    SSecurityTLS(bool _anon);\n    virtual ~SSecurityTLS();\n    virtual bool processMsg(SConnection* sc);\n    virtual const char* getUserName() const {return 0;}\n    virtual int getType() const { return anon ? secTypeTLSNone : secTypeX509None;}\n\n    static StringParameter X509_CertFile;\n    static StringParameter X509_KeyFile;\n\n  protected:\n    void shutdown();\n    void setParams(gnutls_session_t session);\n\n  private:\n    static void initGlobal();\n\n    gnutls_session_t session;\n    gnutls_dh_params_t dh_params;\n    gnutls_anon_server_credentials_t anon_cred;\n    gnutls_certificate_credentials_t cert_cred;\n    char *keyfile, *certfile;\n\n    int type;\n    bool anon;\n\n    rdr::InStream* fis;\n    rdr::OutStream* fos;\n  };\n\n}\n\n#endif\n"], "fixing_code": ["/*\n * Copyright (C) 2004 Red Hat Inc.\n * Copyright (C) 2005 Martin Koegler\n * Copyright (C) 2010 TigerVNC Team\n * Copyright (C) 2010 m-privacy GmbH\n *    \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#ifndef HAVE_GNUTLS\n#error \"This header should not be compiled without HAVE_GNUTLS defined\"\n#endif\n\n#include <stdlib.h>\n#ifndef WIN32\n#include <unistd.h>\n#endif\n\n#include <rfb/CSecurityTLS.h>\n#include <rfb/SSecurityVeNCrypt.h> \n#include <rfb/CConnection.h>\n#include <rfb/LogWriter.h>\n#include <rfb/Exception.h>\n#include <rfb/UserMsgBox.h>\n#include <rdr/TLSInStream.h>\n#include <rdr/TLSOutStream.h>\n#include <os/os.h>\n\n#include <gnutls/x509.h>\n\n/*\n * GNUTLS 2.6.5 and older didn't have some variables defined so don't use them.\n * GNUTLS 1.X.X defined LIBGNUTLS_VERSION_NUMBER so treat it as \"old\" gnutls as\n * well\n */\n#if (defined(GNUTLS_VERSION_NUMBER) && GNUTLS_VERSION_NUMBER < 0x020606) || \\\n    defined(LIBGNUTLS_VERSION_NUMBER)\n#define WITHOUT_X509_TIMES\n#endif\n\n/* Ancient GNUTLS... */\n#if !defined(GNUTLS_VERSION_NUMBER) && !defined(LIBGNUTLS_VERSION_NUMBER)\n#define WITHOUT_X509_TIMES\n#endif\n\nusing namespace rfb;\n\nStringParameter CSecurityTLS::X509CA(\"X509CA\", \"X509 CA certificate\", \"\", ConfViewer);\nStringParameter CSecurityTLS::X509CRL(\"X509CRL\", \"X509 CRL file\", \"\", ConfViewer);\n\nstatic LogWriter vlog(\"TLS\");\n\nCSecurityTLS::CSecurityTLS(bool _anon) : session(0), anon_cred(0),\n\t\t\t\t\t\t anon(_anon), fis(0), fos(0)\n{\n  cafile = X509CA.getData();\n  crlfile = X509CRL.getData();\n\n  if (gnutls_global_init() != GNUTLS_E_SUCCESS)\n    throw AuthFailureException(\"gnutls_global_init failed\");\n}\n\nvoid CSecurityTLS::setDefaults()\n{\n  char* homeDir = NULL;\n\n  if (getvnchomedir(&homeDir) == -1) {\n    vlog.error(\"Could not obtain VNC home directory path\");\n    return;\n  }\n\n  int len = strlen(homeDir) + 1;\n  CharArray caDefault(len + 11);\n  CharArray crlDefault(len + 12);\n  sprintf(caDefault.buf, \"%sx509_ca.pem\", homeDir);\n  sprintf(crlDefault.buf, \"%s509_crl.pem\", homeDir);\n  delete [] homeDir;\n\n if (!fileexists(caDefault.buf))\n   X509CA.setDefaultStr(strdup(caDefault.buf));\n if (!fileexists(crlDefault.buf))\n   X509CRL.setDefaultStr(strdup(crlDefault.buf));\n}\n\nvoid CSecurityTLS::shutdown(bool needbye)\n{\n  if (session && needbye)\n    if (gnutls_bye(session, GNUTLS_SHUT_RDWR) != GNUTLS_E_SUCCESS)\n      vlog.error(\"gnutls_bye failed\");\n\n  if (anon_cred) {\n    gnutls_anon_free_client_credentials(anon_cred);\n    anon_cred = 0;\n  }\n\n  if (cert_cred) {\n    gnutls_certificate_free_credentials(cert_cred);\n    cert_cred = 0;\n  }\n\n  if (session) {\n    gnutls_deinit(session);\n    session = 0;\n  }\n}\n\n\nCSecurityTLS::~CSecurityTLS()\n{\n  shutdown(true);\n\n  if (fis)\n    delete fis;\n  if (fos)\n    delete fos;\n\n  delete[] cafile;\n  delete[] crlfile;\n\n  gnutls_global_deinit();\n}\n\nbool CSecurityTLS::processMsg(CConnection* cc)\n{\n  rdr::InStream* is = cc->getInStream();\n  rdr::OutStream* os = cc->getOutStream();\n  client = cc;\n\n  if (!session) {\n    if (!is->checkNoWait(1))\n      return false;\n\n    if (is->readU8() == 0) {\n      rdr::U32 result = is->readU32();\n      CharArray reason;\n      if (result == secResultFailed || result == secResultTooMany)\n        reason.buf = is->readString();\n      else\n        reason.buf = strDup(\"Authentication failure (protocol error)\");\n      throw AuthFailureException(reason.buf);\n    }\n\n    if (gnutls_init(&session, GNUTLS_CLIENT) != GNUTLS_E_SUCCESS)\n      throw AuthFailureException(\"gnutls_init failed\");\n\n    if (gnutls_set_default_priority(session) != GNUTLS_E_SUCCESS)\n      throw AuthFailureException(\"gnutls_set_default_priority failed\");\n\n    setParam();\n  }\n\n  rdr::TLSInStream *tlsis = new rdr::TLSInStream(is, session);\n  rdr::TLSOutStream *tlsos = new rdr::TLSOutStream(os, session);\n\n  int err;\n  err = gnutls_handshake(session);\n  if (err != GNUTLS_E_SUCCESS) {\n    delete tlsis;\n    delete tlsos;\n\n    if (!gnutls_error_is_fatal(err))\n      return false;\n\n    vlog.error(\"TLS Handshake failed: %s\\n\", gnutls_strerror (err));\n    shutdown(false);\n    throw AuthFailureException(\"TLS Handshake failed\");\n  }\n\n  checkSession();\n\n  cc->setStreams(fis = tlsis, fos = tlsos);\n\n  return true;\n}\n\nvoid CSecurityTLS::setParam()\n{\n  static const char kx_anon_priority[] = \":+ANON-ECDH:+ANON-DH\";\n\n  int ret;\n  char *prio;\n  const char *err;\n\n  prio = (char*)malloc(strlen(Security::GnuTLSPriority) +\n                       strlen(kx_anon_priority) + 1);\n  if (prio == NULL)\n    throw AuthFailureException(\"Not enough memory for GnuTLS priority string\");\n\n  strcpy(prio, Security::GnuTLSPriority);\n  if (anon)\n    strcat(prio, kx_anon_priority);\n\n  ret = gnutls_priority_set_direct(session, prio, &err);\n\n  free(prio);\n\n  if (ret != GNUTLS_E_SUCCESS) {\n    if (ret == GNUTLS_E_INVALID_REQUEST)\n      vlog.error(\"GnuTLS priority syntax error at: %s\", err);\n    throw AuthFailureException(\"gnutls_set_priority_direct failed\");\n  }\n\n  if (anon) {\n    if (gnutls_anon_allocate_client_credentials(&anon_cred) != GNUTLS_E_SUCCESS)\n      throw AuthFailureException(\"gnutls_anon_allocate_client_credentials failed\");\n\n    if (gnutls_credentials_set(session, GNUTLS_CRD_ANON, anon_cred) != GNUTLS_E_SUCCESS)\n      throw AuthFailureException(\"gnutls_credentials_set failed\");\n\n    vlog.debug(\"Anonymous session has been set\");\n  } else {\n    if (gnutls_certificate_allocate_credentials(&cert_cred) != GNUTLS_E_SUCCESS)\n      throw AuthFailureException(\"gnutls_certificate_allocate_credentials failed\");\n\n    if (*cafile && gnutls_certificate_set_x509_trust_file(cert_cred,cafile,GNUTLS_X509_FMT_PEM) < 0)\n      throw AuthFailureException(\"load of CA cert failed\");\n\n    /* Load previously saved certs */\n    char *homeDir = NULL;\n    int err;\n    if (getvnchomedir(&homeDir) == -1)\n      vlog.error(\"Could not obtain VNC home directory path\");\n    else {\n      CharArray caSave(strlen(homeDir) + 19 + 1);\n      sprintf(caSave.buf, \"%sx509_savedcerts.pem\", homeDir);\n      delete [] homeDir;\n\n      err = gnutls_certificate_set_x509_trust_file(cert_cred, caSave.buf,\n                                                   GNUTLS_X509_FMT_PEM);\n      if (err < 0)\n        vlog.debug(\"Failed to load saved server certificates from %s\", caSave.buf);\n    }\n\n    if (*crlfile && gnutls_certificate_set_x509_crl_file(cert_cred,crlfile,GNUTLS_X509_FMT_PEM) < 0)\n      throw AuthFailureException(\"load of CRL failed\");\n\n    if (gnutls_credentials_set(session, GNUTLS_CRD_CERTIFICATE, cert_cred) != GNUTLS_E_SUCCESS)\n      throw AuthFailureException(\"gnutls_credentials_set failed\");\n\n    vlog.debug(\"X509 session has been set\");\n  }\n}\n\nvoid CSecurityTLS::checkSession()\n{\n  const unsigned allowed_errors = GNUTLS_CERT_INVALID |\n\t\t\t\t  GNUTLS_CERT_SIGNER_NOT_FOUND |\n\t\t\t\t  GNUTLS_CERT_SIGNER_NOT_CA;\n  unsigned int status;\n  const gnutls_datum_t *cert_list;\n  unsigned int cert_list_size = 0;\n  int err;\n  gnutls_datum_t info;\n\n  if (anon)\n    return;\n\n  if (gnutls_certificate_type_get(session) != GNUTLS_CRT_X509)\n    throw AuthFailureException(\"unsupported certificate type\");\n\n  err = gnutls_certificate_verify_peers2(session, &status);\n  if (err != 0) {\n    vlog.error(\"server certificate verification failed: %s\", gnutls_strerror(err));\n    throw AuthFailureException(\"server certificate verification failed\");\n  }\n\n  if (status & GNUTLS_CERT_REVOKED)\n    throw AuthFailureException(\"server certificate has been revoked\");\n\n#ifndef WITHOUT_X509_TIMES\n  if (status & GNUTLS_CERT_NOT_ACTIVATED)\n    throw AuthFailureException(\"server certificate has not been activated\");\n\n  if (status & GNUTLS_CERT_EXPIRED) {\n    vlog.debug(\"server certificate has expired\");\n    if (!msg->showMsgBox(UserMsgBox::M_YESNO, \"certificate has expired\",\n\t\t\t \"The certificate of the server has expired, \"\n\t\t\t \"do you want to continue?\"))\n      throw AuthFailureException(\"server certificate has expired\");\n  }\n#endif\n  /* Process other errors later */\n\n  cert_list = gnutls_certificate_get_peers(session, &cert_list_size);\n  if (!cert_list_size)\n    throw AuthFailureException(\"empty certificate chain\");\n\n  /* Process only server's certificate, not issuer's certificate */\n  gnutls_x509_crt_t crt;\n  gnutls_x509_crt_init(&crt);\n\n  if (gnutls_x509_crt_import(crt, &cert_list[0], GNUTLS_X509_FMT_DER) < 0)\n    throw AuthFailureException(\"decoding of certificate failed\");\n\n  if (gnutls_x509_crt_check_hostname(crt, client->getServerName()) == 0) {\n    char buf[255];\n    vlog.debug(\"hostname mismatch\");\n    snprintf(buf, sizeof(buf), \"Hostname (%s) does not match any certificate, \"\n\t\t\t       \"do you want to continue?\", client->getServerName());\n    buf[sizeof(buf) - 1] = '\\0';\n    if (!msg->showMsgBox(UserMsgBox::M_YESNO, \"hostname mismatch\", buf))\n      throw AuthFailureException(\"hostname mismatch\");\n  }\n\n  if (status == 0) {\n    /* Everything is fine (hostname + verification) */\n    gnutls_x509_crt_deinit(crt);\n    return;\n  }\n    \n  if (status & GNUTLS_CERT_INVALID)\n    vlog.debug(\"server certificate invalid\");\n  if (status & GNUTLS_CERT_SIGNER_NOT_FOUND)\n    vlog.debug(\"server cert signer not found\");\n  if (status & GNUTLS_CERT_SIGNER_NOT_CA)\n    vlog.debug(\"server cert signer not CA\");\n\n  if ((status & (~allowed_errors)) != 0) {\n    /* No other errors are allowed */\n    vlog.debug(\"GNUTLS status of certificate verification: %u\", status);\n    throw AuthFailureException(\"Invalid status of server certificate verification\");\n  }\n\n  vlog.debug(\"Saved server certificates don't match\");\n\n  if (gnutls_x509_crt_print(crt, GNUTLS_CRT_PRINT_ONELINE, &info)) {\n    /*\n     * GNUTLS doesn't correctly export gnutls_free symbol which is\n     * a function pointer. Linking with Visual Studio 2008 Express will\n     * fail when you call gnutls_free().\n     */\n#if WIN32\n    free(info.data);\n#else\n    gnutls_free(info.data);\n#endif\n    throw AuthFailureException(\"Could not find certificate to display\");\n  }\n\n  size_t out_size = 0;\n  char *out_buf = NULL;\n  char *certinfo = NULL;\n  int len = 0;\n\n  vlog.debug(\"certificate issuer unknown\");\n\n  len = snprintf(NULL, 0, \"This certificate has been signed by an unknown \"\n                          \"authority:\\n\\n%s\\n\\nDo you want to save it and \"\n                          \"continue?\\n \", info.data);\n  if (len < 0)\n    AuthFailureException(\"certificate decoding error\");\n\n  vlog.debug(\"%s\", info.data);\n\n  certinfo = new char[len];\n  if (certinfo == NULL)\n    throw AuthFailureException(\"Out of memory\");\n\n  snprintf(certinfo, len, \"This certificate has been signed by an unknown \"\n                          \"authority:\\n\\n%s\\n\\nDo you want to save it and \"\n                          \"continue? \", info.data);\n\n  for (int i = 0; i < len - 1; i++)\n    if (certinfo[i] == ',' && certinfo[i + 1] == ' ')\n      certinfo[i] = '\\n';\n\n  if (!msg->showMsgBox(UserMsgBox::M_YESNO, \"certificate issuer unknown\",\n\t\t       certinfo)) {\n    delete [] certinfo;\n    throw AuthFailureException(\"certificate issuer unknown\");\n  }\n\n  delete [] certinfo;\n\n  if (gnutls_x509_crt_export(crt, GNUTLS_X509_FMT_PEM, NULL, &out_size)\n      == GNUTLS_E_SHORT_MEMORY_BUFFER)\n    AuthFailureException(\"Out of memory\");\n\n  // Save cert\n  out_buf =  new char[out_size];\n  if (out_buf == NULL)\n    AuthFailureException(\"Out of memory\");\n\n  if (gnutls_x509_crt_export(crt, GNUTLS_X509_FMT_PEM, out_buf, &out_size) < 0)\n    AuthFailureException(\"certificate issuer unknown, and certificate \"\n\t\t\t \"export failed\");\n\n  char *homeDir = NULL;\n  if (getvnchomedir(&homeDir) == -1)\n    vlog.error(\"Could not obtain VNC home directory path\");\n  else {\n    FILE *f;\n    CharArray caSave(strlen(homeDir) + 1 + 19);\n    sprintf(caSave.buf, \"%sx509_savedcerts.pem\", homeDir);\n    delete [] homeDir;\n    f = fopen(caSave.buf, \"a+\");\n    if (!f)\n      msg->showMsgBox(UserMsgBox::M_OK, \"certificate save failed\",\n                      \"Could not save the certificate\");\n    else {\n      fprintf(f, \"%s\\n\", out_buf);\n      fclose(f);\n    }\n  }\n\n  delete [] out_buf;\n\n  gnutls_x509_crt_deinit(crt);\n  /*\n   * GNUTLS doesn't correctly export gnutls_free symbol which is\n   * a function pointer. Linking with Visual Studio 2008 Express will\n   * fail when you call gnutls_free().\n   */\n#if WIN32\n  free(info.data);\n#else\n  gnutls_free(info.data);\n#endif\n}\n\n", "/* \n * Copyright (C) 2004 Red Hat Inc.\n * Copyright (C) 2005 Martin Koegler\n * Copyright (C) 2010 TigerVNC Team\n *    \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n#ifndef __C_SECURITY_TLS_H__\n#define __C_SECURITY_TLS_H__\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#ifndef HAVE_GNUTLS\n#error \"This header should not be compiled without HAVE_GNUTLS defined\"\n#endif\n\n#include <rfb/CSecurity.h>\n#include <rfb/SSecurityVeNCrypt.h>\n#include <rfb/Security.h>\n#include <rfb/UserMsgBox.h>\n#include <rdr/InStream.h>\n#include <rdr/OutStream.h>\n#include <gnutls/gnutls.h>\n\nnamespace rfb {\n  class UserMsgBox;\n  class CSecurityTLS : public CSecurity {\n  public:\n    CSecurityTLS(bool _anon);\n    virtual ~CSecurityTLS();\n    virtual bool processMsg(CConnection* cc);\n    virtual int getType() const { return anon ? secTypeTLSNone : secTypeX509None; }\n    virtual const char* description() const\n      { return anon ? \"TLS Encryption without VncAuth\" : \"X509 Encryption without VncAuth\"; }\n    static void setDefaults();\n\n    static StringParameter X509CA;\n    static StringParameter X509CRL;\n    static UserMsgBox *msg;\n\n  protected:\n    void shutdown(bool needbye);\n    void freeResources();\n    void setParam();\n    void checkSession();\n    CConnection *client;\n\n  private:\n    gnutls_session_t session;\n    gnutls_anon_client_credentials_t anon_cred;\n    gnutls_certificate_credentials_t cert_cred;\n    bool anon;\n\n    char *cafile, *crlfile;\n    rdr::InStream* fis;\n    rdr::OutStream* fos;\n  };\n}\n\n#endif\n", "/* \n * Copyright (C) 2004 Red Hat Inc.\n * Copyright (C) 2005 Martin Koegler\n * Copyright (C) 2010 TigerVNC Team\n *    \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#ifndef HAVE_GNUTLS\n#error \"This source should not be compiled without HAVE_GNUTLS defined\"\n#endif\n\n#include <stdlib.h>\n\n#include <rfb/SSecurityTLS.h>\n#include <rfb/SConnection.h>\n#include <rfb/LogWriter.h>\n#include <rfb/Exception.h>\n#include <rdr/TLSInStream.h>\n#include <rdr/TLSOutStream.h>\n\n#define DH_BITS 1024 /* XXX This should be configurable! */\n\nusing namespace rfb;\n\nStringParameter SSecurityTLS::X509_CertFile\n(\"X509Cert\", \"Path to the X509 certificate in PEM format\", \"\", ConfServer);\n\nStringParameter SSecurityTLS::X509_KeyFile\n(\"X509Key\", \"Path to the key of the X509 certificate in PEM format\", \"\", ConfServer);\n\nstatic LogWriter vlog(\"TLS\");\n\nSSecurityTLS::SSecurityTLS(bool _anon) : session(0), dh_params(0),\n\t\t\t\t\t\t anon_cred(0), cert_cred(0),\n\t\t\t\t\t\t anon(_anon), fis(0), fos(0)\n{\n  certfile = X509_CertFile.getData();\n  keyfile = X509_KeyFile.getData();\n\n  if (gnutls_global_init() != GNUTLS_E_SUCCESS)\n    throw AuthFailureException(\"gnutls_global_init failed\");\n}\n\nvoid SSecurityTLS::shutdown()\n{\n  if (session) {\n    if (gnutls_bye(session, GNUTLS_SHUT_RDWR) != GNUTLS_E_SUCCESS) {\n      /* FIXME: Treat as non-fatal error */\n      vlog.error(\"TLS session wasn't terminated gracefully\");\n    }\n  }\n\n  if (dh_params) {\n    gnutls_dh_params_deinit(dh_params);\n    dh_params = 0;\n  }\n\n  if (anon_cred) {\n    gnutls_anon_free_server_credentials(anon_cred);\n    anon_cred = 0;\n  }\n\n  if (cert_cred) {\n    gnutls_certificate_free_credentials(cert_cred);\n    cert_cred = 0;\n  }\n\n  if (session) {\n    gnutls_deinit(session);\n    session = 0;\n  }\n}\n\n\nSSecurityTLS::~SSecurityTLS()\n{\n  shutdown();\n\n  if (fis)\n    delete fis;\n  if (fos)\n    delete fos;\n\n  delete[] keyfile;\n  delete[] certfile;\n\n  gnutls_global_deinit();\n}\n\nbool SSecurityTLS::processMsg(SConnection *sc)\n{\n  rdr::InStream* is = sc->getInStream();\n  rdr::OutStream* os = sc->getOutStream();\n\n  vlog.debug(\"Process security message (session %p)\", session);\n\n  if (!session) {\n    if (gnutls_init(&session, GNUTLS_SERVER) != GNUTLS_E_SUCCESS)\n      throw AuthFailureException(\"gnutls_init failed\");\n\n    if (gnutls_set_default_priority(session) != GNUTLS_E_SUCCESS)\n      throw AuthFailureException(\"gnutls_set_default_priority failed\");\n\n    try {\n      setParams(session);\n    }\n    catch(...) {\n      os->writeU8(0);\n      throw;\n    }\n\n    os->writeU8(1);\n    os->flush();\n  }\n\n  rdr::TLSInStream *tlsis = new rdr::TLSInStream(is, session);\n  rdr::TLSOutStream *tlsos = new rdr::TLSOutStream(os, session);\n\n  int err;\n  err = gnutls_handshake(session);\n  if (err != GNUTLS_E_SUCCESS) {\n    delete tlsis;\n    delete tlsos;\n\n    if (!gnutls_error_is_fatal(err)) {\n      vlog.debug(\"Deferring completion of TLS handshake: %s\", gnutls_strerror(err));\n      return false;\n    }\n    vlog.error(\"TLS Handshake failed: %s\", gnutls_strerror (err));\n    shutdown();\n    throw AuthFailureException(\"TLS Handshake failed\");\n  }\n\n  vlog.debug(\"Handshake completed\");\n\n  sc->setStreams(fis = tlsis, fos = tlsos);\n\n  return true;\n}\n\nvoid SSecurityTLS::setParams(gnutls_session_t session)\n{\n  static const char kx_anon_priority[] = \":+ANON-ECDH:+ANON-DH\";\n\n  int ret;\n  char *prio;\n  const char *err;\n\n  prio = (char*)malloc(strlen(Security::GnuTLSPriority) +\n                       strlen(kx_anon_priority) + 1);\n  if (prio == NULL)\n    throw AuthFailureException(\"Not enough memory for GnuTLS priority string\");\n\n  strcpy(prio, Security::GnuTLSPriority);\n  if (anon)\n    strcat(prio, kx_anon_priority);\n\n  ret = gnutls_priority_set_direct(session, prio, &err);\n\n  free(prio);\n\n  if (ret != GNUTLS_E_SUCCESS) {\n    if (ret == GNUTLS_E_INVALID_REQUEST)\n      vlog.error(\"GnuTLS priority syntax error at: %s\", err);\n    throw AuthFailureException(\"gnutls_set_priority_direct failed\");\n  }\n\n  if (gnutls_dh_params_init(&dh_params) != GNUTLS_E_SUCCESS)\n    throw AuthFailureException(\"gnutls_dh_params_init failed\");\n\n  if (gnutls_dh_params_generate2(dh_params, DH_BITS) != GNUTLS_E_SUCCESS)\n    throw AuthFailureException(\"gnutls_dh_params_generate2 failed\");\n\n  if (anon) {\n    if (gnutls_anon_allocate_server_credentials(&anon_cred) != GNUTLS_E_SUCCESS)\n      throw AuthFailureException(\"gnutls_anon_allocate_server_credentials failed\");\n\n    gnutls_anon_set_server_dh_params(anon_cred, dh_params);\n\n    if (gnutls_credentials_set(session, GNUTLS_CRD_ANON, anon_cred)\n        != GNUTLS_E_SUCCESS)\n      throw AuthFailureException(\"gnutls_credentials_set failed\");\n\n    vlog.debug(\"Anonymous session has been set\");\n\n  } else {\n    if (gnutls_certificate_allocate_credentials(&cert_cred) != GNUTLS_E_SUCCESS)\n      throw AuthFailureException(\"gnutls_certificate_allocate_credentials failed\");\n\n    gnutls_certificate_set_dh_params(cert_cred, dh_params);\n\n    if (gnutls_certificate_set_x509_key_file(cert_cred, certfile, keyfile,\n        GNUTLS_X509_FMT_PEM) != GNUTLS_E_SUCCESS)\n      throw AuthFailureException(\"load of key failed\");\n\n    if (gnutls_credentials_set(session, GNUTLS_CRD_CERTIFICATE, cert_cred)\n        != GNUTLS_E_SUCCESS)\n      throw AuthFailureException(\"gnutls_credentials_set failed\");\n\n    vlog.debug(\"X509 session has been set\");\n\n  }\n\n}\n", "/* \n * Copyright (C) 2004 Red Hat Inc.\n * Copyright (C) 2005 Martin Koegler\n * Copyright (C) 2010 TigerVNC Team\n *    \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n#ifndef __S_SECURITY_TLS_H__\n#define __S_SECURITY_TLS_H__\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#ifndef HAVE_GNUTLS\n#error \"This header should not be included without HAVE_GNUTLS defined\"\n#endif\n\n#include <rfb/SSecurity.h>\n#include <rfb/SSecurityVeNCrypt.h>\n#include <rdr/InStream.h>\n#include <rdr/OutStream.h>\n#include <gnutls/gnutls.h>\n\nnamespace rfb {\n\n  class SSecurityTLS : public SSecurity {\n  public:\n    SSecurityTLS(bool _anon);\n    virtual ~SSecurityTLS();\n    virtual bool processMsg(SConnection* sc);\n    virtual const char* getUserName() const {return 0;}\n    virtual int getType() const { return anon ? secTypeTLSNone : secTypeX509None;}\n\n    static StringParameter X509_CertFile;\n    static StringParameter X509_KeyFile;\n\n  protected:\n    void shutdown();\n    void setParams(gnutls_session_t session);\n\n  private:\n    gnutls_session_t session;\n    gnutls_dh_params_t dh_params;\n    gnutls_anon_server_credentials_t anon_cred;\n    gnutls_certificate_credentials_t cert_cred;\n    char *keyfile, *certfile;\n\n    int type;\n    bool anon;\n\n    rdr::InStream* fis;\n    rdr::OutStream* fos;\n  };\n\n}\n\n#endif\n"], "filenames": ["common/rfb/CSecurityTLS.cxx", "common/rfb/CSecurityTLS.h", "common/rfb/SSecurityTLS.cxx", "common/rfb/SSecurityTLS.h"], "buggy_code_start_loc": [70, 65, 51, 57], "buggy_code_end_loc": [154, 67, 126, 59], "fixing_code_start_loc": [69, 64, 50, 56], "fixing_code_end_loc": [144, 64, 115, 56], "type": "CWE-119", "message": "The Xvnc server in TigerVNC allows remote attackers to cause a denial of service (invalid memory access and crash) by terminating a TLS handshake early.", "other": {"cve": {"id": "CVE-2016-10207", "sourceIdentifier": "cve@mitre.org", "published": "2017-02-28T18:59:00.170", "lastModified": "2018-02-01T17:05:56.367", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The Xvnc server in TigerVNC allows remote attackers to cause a denial of service (invalid memory access and crash) by terminating a TLS handshake early."}, {"lang": "es", "value": "El servidor Xvnc en TigerVNC permite a atacantes remotos provocar una denegaci\u00f3n de servicio (acceso a memoria no v\u00e1lida y ca\u00edda) terminando un apret\u00f3n de manos TLS temprano."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:42.1:*:*:*:*:*:*:*", "matchCriteriaId": "4863BE36-D16A-4D75-90D9-FD76DB5B48B7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:42.2:*:*:*:*:*:*:*", "matchCriteriaId": "1EA337A3-B9A3-4962-B8BD-8E0C7C5B28EB"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tigervnc:tigervnc:0.0.90:*:*:*:*:*:*:*", "matchCriteriaId": "7A2445F5-A664-47E6-B3D0-4F9E30348A6D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tigervnc:tigervnc:0.0.91:*:*:*:*:*:*:*", "matchCriteriaId": "BD402007-3C2E-4889-93B0-3A74C104E868"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tigervnc:tigervnc:1.0:*:*:*:*:*:*:*", "matchCriteriaId": "BC267495-63B6-4A6E-9185-F6B395738C64"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tigervnc:tigervnc:1.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "9B633044-EA51-4A5A-845D-06064CFBCA40"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tigervnc:tigervnc:1.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "64D27895-7CD8-4AF4-A392-04B4D8EDFA87"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tigervnc:tigervnc:1.3:*:*:*:*:*:*:*", "matchCriteriaId": "BABA188F-30E2-4C86-BF38-DC3BC383B822"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tigervnc:tigervnc:1.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "8D19A4F7-747B-45B8-8AEE-69A937D537B7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tigervnc:tigervnc:1.7:*:*:*:*:*:*:*", "matchCriteriaId": "5045D13B-9A2E-420C-A3BF-CA28C721FD9C"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2017-02/msg00020.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2017-0630.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2017/02/02/22", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2017/02/05/2", "source": "cve@mitre.org", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/96012", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:2000", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.suse.com/show_bug.cgi?id=1023012", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/TigerVNC/tigervnc/commit/8aa4bc53206c2430bbf0c8f4b642f59a379ee649", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://security.gentoo.org/glsa/201801-13", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/TigerVNC/tigervnc/commit/8aa4bc53206c2430bbf0c8f4b642f59a379ee649"}}