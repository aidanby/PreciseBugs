{"buggy_code": ["/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * Bitmap Cache V2\n *\n * Copyright 2011 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <stdio.h>\n\n#include <winpr/crt.h>\n\n#include <freerdp/freerdp.h>\n#include <freerdp/constants.h>\n#include <winpr/stream.h>\n\n#include <freerdp/log.h>\n#include <freerdp/cache/bitmap.h>\n#include <freerdp/gdi/bitmap.h>\n\n#include \"../gdi/gdi.h\"\n#include \"../core/graphics.h\"\n\n#include \"bitmap.h\"\n\n#define TAG FREERDP_TAG(\"cache.bitmap\")\n\nstatic rdpBitmap* bitmap_cache_get(rdpBitmapCache* bitmapCache, UINT32 id, UINT32 index);\nstatic BOOL bitmap_cache_put(rdpBitmapCache* bitmap_cache, UINT32 id, UINT32 index,\n                             rdpBitmap* bitmap);\n\nstatic BOOL update_gdi_memblt(rdpContext* context, MEMBLT_ORDER* memblt)\n{\n\trdpBitmap* bitmap;\n\trdpCache* cache = context->cache;\n\n\tif (memblt->cacheId == 0xFF)\n\t\tbitmap = offscreen_cache_get(cache->offscreen, memblt->cacheIndex);\n\telse\n\t\tbitmap = bitmap_cache_get(cache->bitmap, (BYTE)memblt->cacheId, memblt->cacheIndex);\n\n\t/* XP-SP2 servers sometimes ask for cached bitmaps they've never defined. */\n\tif (bitmap == NULL)\n\t\treturn TRUE;\n\n\tmemblt->bitmap = bitmap;\n\treturn IFCALLRESULT(TRUE, cache->bitmap->MemBlt, context, memblt);\n}\n\nstatic BOOL update_gdi_mem3blt(rdpContext* context, MEM3BLT_ORDER* mem3blt)\n{\n\tBYTE style;\n\trdpBitmap* bitmap;\n\trdpCache* cache = context->cache;\n\trdpBrush* brush = &mem3blt->brush;\n\tBOOL ret = TRUE;\n\n\tif (mem3blt->cacheId == 0xFF)\n\t\tbitmap = offscreen_cache_get(cache->offscreen, mem3blt->cacheIndex);\n\telse\n\t\tbitmap = bitmap_cache_get(cache->bitmap, (BYTE)mem3blt->cacheId, mem3blt->cacheIndex);\n\n\t/* XP-SP2 servers sometimes ask for cached bitmaps they've never defined. */\n\tif (!bitmap)\n\t\treturn TRUE;\n\n\tstyle = brush->style;\n\n\tif (brush->style & CACHED_BRUSH)\n\t{\n\t\tbrush->data = brush_cache_get(cache->brush, brush->index, &brush->bpp);\n\n\t\tif (!brush->data)\n\t\t\treturn FALSE;\n\n\t\tbrush->style = 0x03;\n\t}\n\n\tmem3blt->bitmap = bitmap;\n\tIFCALLRET(cache->bitmap->Mem3Blt, ret, context, mem3blt);\n\tbrush->style = style;\n\treturn ret;\n}\n\nstatic BOOL update_gdi_cache_bitmap(rdpContext* context, const CACHE_BITMAP_ORDER* cacheBitmap)\n{\n\trdpBitmap* bitmap;\n\trdpBitmap* prevBitmap;\n\trdpCache* cache = context->cache;\n\tbitmap = Bitmap_Alloc(context);\n\n\tif (!bitmap)\n\t\treturn FALSE;\n\n\tBitmap_SetDimensions(bitmap, cacheBitmap->bitmapWidth, cacheBitmap->bitmapHeight);\n\n\tif (!bitmap->Decompress(context, bitmap, cacheBitmap->bitmapDataStream,\n\t                        cacheBitmap->bitmapWidth, cacheBitmap->bitmapHeight,\n\t                        cacheBitmap->bitmapBpp, cacheBitmap->bitmapLength,\n\t                        cacheBitmap->compressed, RDP_CODEC_ID_NONE))\n\t{\n\t\tBitmap_Free(context, bitmap);\n\t\treturn FALSE;\n\t}\n\n\tif (!bitmap->New(context, bitmap))\n\t{\n\t\tBitmap_Free(context, bitmap);\n\t\treturn FALSE;\n\t}\n\n\tprevBitmap = bitmap_cache_get(cache->bitmap, cacheBitmap->cacheId, cacheBitmap->cacheIndex);\n\tBitmap_Free(context, prevBitmap);\n\treturn bitmap_cache_put(cache->bitmap, cacheBitmap->cacheId, cacheBitmap->cacheIndex, bitmap);\n}\n\nstatic BOOL update_gdi_cache_bitmap_v2(rdpContext* context, CACHE_BITMAP_V2_ORDER* cacheBitmapV2)\n\n{\n\trdpBitmap* bitmap;\n\trdpBitmap* prevBitmap;\n\trdpCache* cache = context->cache;\n\trdpSettings* settings = context->settings;\n\tbitmap = Bitmap_Alloc(context);\n\n\tif (!bitmap)\n\t\treturn FALSE;\n\n\tif (!cacheBitmapV2->bitmapBpp)\n\t\tcacheBitmapV2->bitmapBpp = settings->ColorDepth;\n\n\tif ((settings->ColorDepth == 15) && (cacheBitmapV2->bitmapBpp == 16))\n\t\tcacheBitmapV2->bitmapBpp = settings->ColorDepth;\n\n\tBitmap_SetDimensions(bitmap, cacheBitmapV2->bitmapWidth, cacheBitmapV2->bitmapHeight);\n\n\tif (!bitmap->Decompress(context, bitmap, cacheBitmapV2->bitmapDataStream,\n\t                        cacheBitmapV2->bitmapWidth, cacheBitmapV2->bitmapHeight,\n\t                        cacheBitmapV2->bitmapBpp, cacheBitmapV2->bitmapLength,\n\t                        cacheBitmapV2->compressed, RDP_CODEC_ID_NONE))\n\t{\n\t\tBitmap_Free(context, bitmap);\n\t\treturn FALSE;\n\t}\n\n\tprevBitmap = bitmap_cache_get(cache->bitmap, cacheBitmapV2->cacheId, cacheBitmapV2->cacheIndex);\n\n\tif (!bitmap->New(context, bitmap))\n\t{\n\t\tBitmap_Free(context, bitmap);\n\t\treturn FALSE;\n\t}\n\n\tBitmap_Free(context, prevBitmap);\n\treturn bitmap_cache_put(cache->bitmap, cacheBitmapV2->cacheId, cacheBitmapV2->cacheIndex,\n\t                        bitmap);\n}\n\nstatic BOOL update_gdi_cache_bitmap_v3(rdpContext* context, CACHE_BITMAP_V3_ORDER* cacheBitmapV3)\n{\n\trdpBitmap* bitmap;\n\trdpBitmap* prevBitmap;\n\tBOOL compressed = TRUE;\n\trdpCache* cache = context->cache;\n\trdpSettings* settings = context->settings;\n\tBITMAP_DATA_EX* bitmapData = &cacheBitmapV3->bitmapData;\n\tbitmap = Bitmap_Alloc(context);\n\n\tif (!bitmap)\n\t\treturn FALSE;\n\n\tif (!cacheBitmapV3->bpp)\n\t\tcacheBitmapV3->bpp = settings->ColorDepth;\n\n\tcompressed = (bitmapData->codecID != RDP_CODEC_ID_NONE);\n\tBitmap_SetDimensions(bitmap, bitmapData->width, bitmapData->height);\n\n\tif (!bitmap->Decompress(context, bitmap, bitmapData->data, bitmapData->width,\n\t                        bitmapData->height, bitmapData->bpp, bitmapData->length, compressed,\n\t                        bitmapData->codecID))\n\t{\n\t\tBitmap_Free(context, bitmap);\n\t\treturn FALSE;\n\t}\n\n\tif (!bitmap->New(context, bitmap))\n\t{\n\t\tBitmap_Free(context, bitmap);\n\t\treturn FALSE;\n\t}\n\n\tprevBitmap = bitmap_cache_get(cache->bitmap, cacheBitmapV3->cacheId, cacheBitmapV3->cacheIndex);\n\tBitmap_Free(context, prevBitmap);\n\treturn bitmap_cache_put(cache->bitmap, cacheBitmapV3->cacheId, cacheBitmapV3->cacheIndex,\n\t                        bitmap);\n}\n\nrdpBitmap* bitmap_cache_get(rdpBitmapCache* bitmapCache, UINT32 id, UINT32 index)\n{\n\trdpBitmap* bitmap;\n\n\tif (id > bitmapCache->maxCells)\n\t{\n\t\tWLog_ERR(TAG, \"get invalid bitmap cell id: %\" PRIu32 \"\", id);\n\t\treturn NULL;\n\t}\n\n\tif (index == BITMAP_CACHE_WAITING_LIST_INDEX)\n\t{\n\t\tindex = bitmapCache->cells[id].number;\n\t}\n\telse if (index > bitmapCache->cells[id].number)\n\t{\n\t\tWLog_ERR(TAG, \"get invalid bitmap index %\" PRIu32 \" in cell id: %\" PRIu32 \"\", index, id);\n\t\treturn NULL;\n\t}\n\n\tbitmap = bitmapCache->cells[id].entries[index];\n\treturn bitmap;\n}\n\nBOOL bitmap_cache_put(rdpBitmapCache* bitmapCache, UINT32 id, UINT32 index, rdpBitmap* bitmap)\n{\n\tif (id > bitmapCache->maxCells)\n\t{\n\t\tWLog_ERR(TAG, \"put invalid bitmap cell id: %\" PRIu32 \"\", id);\n\t\treturn FALSE;\n\t}\n\n\tif (index == BITMAP_CACHE_WAITING_LIST_INDEX)\n\t{\n\t\tindex = bitmapCache->cells[id].number;\n\t}\n\telse if (index > bitmapCache->cells[id].number)\n\t{\n\t\tWLog_ERR(TAG, \"put invalid bitmap index %\" PRIu32 \" in cell id: %\" PRIu32 \"\", index, id);\n\t\treturn FALSE;\n\t}\n\n\tbitmapCache->cells[id].entries[index] = bitmap;\n\treturn TRUE;\n}\n\nvoid bitmap_cache_register_callbacks(rdpUpdate* update)\n{\n\trdpCache* cache = update->context->cache;\n\tcache->bitmap->MemBlt = update->primary->MemBlt;\n\tcache->bitmap->Mem3Blt = update->primary->Mem3Blt;\n\tupdate->primary->MemBlt = update_gdi_memblt;\n\tupdate->primary->Mem3Blt = update_gdi_mem3blt;\n\tupdate->secondary->CacheBitmap = update_gdi_cache_bitmap;\n\tupdate->secondary->CacheBitmapV2 = update_gdi_cache_bitmap_v2;\n\tupdate->secondary->CacheBitmapV3 = update_gdi_cache_bitmap_v3;\n\tupdate->BitmapUpdate = gdi_bitmap_update;\n}\n\nrdpBitmapCache* bitmap_cache_new(rdpSettings* settings)\n{\n\tint i;\n\trdpBitmapCache* bitmapCache;\n\tbitmapCache = (rdpBitmapCache*)calloc(1, sizeof(rdpBitmapCache));\n\n\tif (!bitmapCache)\n\t\treturn NULL;\n\n\tbitmapCache->settings = settings;\n\tbitmapCache->update = ((freerdp*)settings->instance)->update;\n\tbitmapCache->context = bitmapCache->update->context;\n\tbitmapCache->maxCells = settings->BitmapCacheV2NumCells;\n\tbitmapCache->cells = (BITMAP_V2_CELL*)calloc(bitmapCache->maxCells, sizeof(BITMAP_V2_CELL));\n\n\tif (!bitmapCache->cells)\n\t\tgoto fail;\n\n\tfor (i = 0; i < (int)bitmapCache->maxCells; i++)\n\t{\n\t\tbitmapCache->cells[i].number = settings->BitmapCacheV2CellInfo[i].numEntries;\n\t\t/* allocate an extra entry for BITMAP_CACHE_WAITING_LIST_INDEX */\n\t\tbitmapCache->cells[i].entries =\n\t\t    (rdpBitmap**)calloc((bitmapCache->cells[i].number + 1), sizeof(rdpBitmap*));\n\n\t\tif (!bitmapCache->cells[i].entries)\n\t\t\tgoto fail;\n\t}\n\n\treturn bitmapCache;\nfail:\n\n\tif (bitmapCache->cells)\n\t{\n\t\tfor (i = 0; i < (int)bitmapCache->maxCells; i++)\n\t\t\tfree(bitmapCache->cells[i].entries);\n\t}\n\n\tfree(bitmapCache);\n\treturn NULL;\n}\n\nvoid bitmap_cache_free(rdpBitmapCache* bitmapCache)\n{\n\tint i, j;\n\trdpBitmap* bitmap;\n\n\tif (bitmapCache)\n\t{\n\t\tfor (i = 0; i < (int)bitmapCache->maxCells; i++)\n\t\t{\n\t\t\tfor (j = 0; j < (int)bitmapCache->cells[i].number + 1; j++)\n\t\t\t{\n\t\t\t\tbitmap = bitmapCache->cells[i].entries[j];\n\t\t\t\tBitmap_Free(bitmapCache->context, bitmap);\n\t\t\t}\n\n\t\t\tfree(bitmapCache->cells[i].entries);\n\t\t}\n\n\t\tfree(bitmapCache->cells);\n\t\tfree(bitmapCache);\n\t}\n}\n\nstatic void free_bitmap_data(BITMAP_DATA* data, size_t count)\n{\n\tsize_t x;\n\n\tif (!data)\n\t\treturn;\n\n\tfor (x = 0; x < count; x++)\n\t\tfree(data[x].bitmapDataStream);\n\n\tfree(data);\n}\n\nstatic BITMAP_DATA* copy_bitmap_data(const BITMAP_DATA* data, size_t count)\n{\n\tsize_t x;\n\tBITMAP_DATA* dst = (BITMAP_DATA*)calloc(count, sizeof(BITMAP_DATA));\n\n\tif (!dst)\n\t\tgoto fail;\n\n\tfor (x = 0; x < count; x++)\n\t{\n\t\tdst[x] = data[x];\n\n\t\tif (data[x].bitmapLength > 0)\n\t\t{\n\t\t\tdst[x].bitmapDataStream = malloc(data[x].bitmapLength);\n\n\t\t\tif (!dst[x].bitmapDataStream)\n\t\t\t\tgoto fail;\n\n\t\t\tmemcpy(dst[x].bitmapDataStream, data[x].bitmapDataStream, data[x].bitmapLength);\n\t\t}\n\t}\n\n\treturn dst;\nfail:\n\tfree_bitmap_data(dst, count);\n\treturn NULL;\n}\n\nvoid free_bitmap_update(rdpContext* context, BITMAP_UPDATE* pointer)\n{\n\tif (!pointer)\n\t\treturn;\n\n\tfree_bitmap_data(pointer->rectangles, pointer->number);\n\tfree(pointer);\n}\n\nBITMAP_UPDATE* copy_bitmap_update(rdpContext* context, const BITMAP_UPDATE* pointer)\n{\n\tBITMAP_UPDATE* dst = calloc(1, sizeof(BITMAP_UPDATE));\n\n\tif (!dst || !pointer)\n\t\tgoto fail;\n\n\t*dst = *pointer;\n\tdst->rectangles = copy_bitmap_data(pointer->rectangles, pointer->number);\n\n\tif (!dst->rectangles)\n\t\tgoto fail;\n\n\treturn dst;\nfail:\n\tfree_bitmap_update(context, dst);\n\treturn NULL;\n}\n\nCACHE_BITMAP_ORDER* copy_cache_bitmap_order(rdpContext* context, const CACHE_BITMAP_ORDER* order)\n{\n\tCACHE_BITMAP_ORDER* dst = calloc(1, sizeof(CACHE_BITMAP_ORDER));\n\n\tif (!dst || !order)\n\t\tgoto fail;\n\n\t*dst = *order;\n\n\tif (order->bitmapLength > 0)\n\t{\n\t\tdst->bitmapDataStream = malloc(order->bitmapLength);\n\n\t\tif (!dst->bitmapDataStream)\n\t\t\tgoto fail;\n\n\t\tmemcpy(dst->bitmapDataStream, order->bitmapDataStream, order->bitmapLength);\n\t}\n\n\treturn dst;\nfail:\n\tfree_cache_bitmap_order(context, dst);\n\treturn NULL;\n}\n\nvoid free_cache_bitmap_order(rdpContext* context, CACHE_BITMAP_ORDER* order)\n{\n\tif (order)\n\t\tfree(order->bitmapDataStream);\n\n\tfree(order);\n}\n\nCACHE_BITMAP_V2_ORDER* copy_cache_bitmap_v2_order(rdpContext* context,\n                                                  const CACHE_BITMAP_V2_ORDER* order)\n{\n\tCACHE_BITMAP_V2_ORDER* dst = calloc(1, sizeof(CACHE_BITMAP_V2_ORDER));\n\n\tif (!dst || !order)\n\t\tgoto fail;\n\n\t*dst = *order;\n\n\tif (order->bitmapLength > 0)\n\t{\n\t\tdst->bitmapDataStream = malloc(order->bitmapLength);\n\n\t\tif (!dst->bitmapDataStream)\n\t\t\tgoto fail;\n\n\t\tmemcpy(dst->bitmapDataStream, order->bitmapDataStream, order->bitmapLength);\n\t}\n\n\treturn dst;\nfail:\n\tfree_cache_bitmap_v2_order(context, dst);\n\treturn NULL;\n}\n\nvoid free_cache_bitmap_v2_order(rdpContext* context, CACHE_BITMAP_V2_ORDER* order)\n{\n\tif (order)\n\t\tfree(order->bitmapDataStream);\n\n\tfree(order);\n}\n\nCACHE_BITMAP_V3_ORDER* copy_cache_bitmap_v3_order(rdpContext* context,\n                                                  const CACHE_BITMAP_V3_ORDER* order)\n{\n\tCACHE_BITMAP_V3_ORDER* dst = calloc(1, sizeof(CACHE_BITMAP_V3_ORDER));\n\n\tif (!dst || !order)\n\t\tgoto fail;\n\n\t*dst = *order;\n\n\tif (order->bitmapData.length > 0)\n\t{\n\t\tdst->bitmapData.data = malloc(order->bitmapData.length);\n\n\t\tif (!dst->bitmapData.data)\n\t\t\tgoto fail;\n\n\t\tmemcpy(dst->bitmapData.data, order->bitmapData.data, order->bitmapData.length);\n\t}\n\n\treturn dst;\nfail:\n\tfree_cache_bitmap_v3_order(context, dst);\n\treturn NULL;\n}\n\nvoid free_cache_bitmap_v3_order(rdpContext* context, CACHE_BITMAP_V3_ORDER* order)\n{\n\tif (order)\n\t\tfree(order->bitmapData.data);\n\n\tfree(order);\n}\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * Auto-Detect PDUs\n *\n * Copyright 2014 Dell Software <Mike.McDonald@software.dell.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <winpr/crypto.h>\n\n#include \"autodetect.h\"\n\n#define RDP_RTT_REQUEST_TYPE_CONTINUOUS 0x0001\n#define RDP_RTT_REQUEST_TYPE_CONNECTTIME 0x1001\n\n#define RDP_RTT_RESPONSE_TYPE 0x0000\n\n#define RDP_BW_START_REQUEST_TYPE_CONTINUOUS 0x0014\n#define RDP_BW_START_REQUEST_TYPE_TUNNEL 0x0114\n#define RDP_BW_START_REQUEST_TYPE_CONNECTTIME 0x1014\n#define RDP_BW_PAYLOAD_REQUEST_TYPE 0x0002\n#define RDP_BW_STOP_REQUEST_TYPE_CONNECTTIME 0x002B\n#define RDP_BW_STOP_REQUEST_TYPE_CONTINUOUS 0x0429\n#define RDP_BW_STOP_REQUEST_TYPE_TUNNEL 0x0629\n\n#define RDP_BW_RESULTS_RESPONSE_TYPE_CONNECTTIME 0x0003\n#define RDP_BW_RESULTS_RESPONSE_TYPE_CONTINUOUS 0x000B\n\n#define RDP_NETCHAR_SYNC_RESPONSE_TYPE 0x0018\n\ntypedef struct\n{\n\tUINT8 headerLength;\n\tUINT8 headerTypeId;\n\tUINT16 sequenceNumber;\n\tUINT16 requestType;\n} AUTODETECT_REQ_PDU;\n\ntypedef struct\n{\n\tUINT8 headerLength;\n\tUINT8 headerTypeId;\n\tUINT16 sequenceNumber;\n\tUINT16 responseType;\n} AUTODETECT_RSP_PDU;\n\nstatic BOOL autodetect_send_rtt_measure_request(rdpContext* context, UINT16 sequenceNumber,\n                                                UINT16 requestType)\n{\n\twStream* s;\n\ts = rdp_message_channel_pdu_init(context->rdp);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tWLog_VRB(AUTODETECT_TAG, \"sending RTT Measure Request PDU\");\n\tStream_Write_UINT8(s, 0x06);                       /* headerLength (1 byte) */\n\tStream_Write_UINT8(s, TYPE_ID_AUTODETECT_REQUEST); /* headerTypeId (1 byte) */\n\tStream_Write_UINT16(s, sequenceNumber);            /* sequenceNumber (2 bytes) */\n\tStream_Write_UINT16(s, requestType);               /* requestType (2 bytes) */\n\tcontext->rdp->autodetect->rttMeasureStartTime = GetTickCount64();\n\treturn rdp_send_message_channel_pdu(context->rdp, s, SEC_AUTODETECT_REQ);\n}\n\nstatic BOOL autodetect_send_continuous_rtt_measure_request(rdpContext* context,\n                                                           UINT16 sequenceNumber)\n{\n\treturn autodetect_send_rtt_measure_request(context, sequenceNumber,\n\t                                           RDP_RTT_REQUEST_TYPE_CONTINUOUS);\n}\n\nBOOL autodetect_send_connecttime_rtt_measure_request(rdpContext* context, UINT16 sequenceNumber)\n{\n\treturn autodetect_send_rtt_measure_request(context, sequenceNumber,\n\t                                           RDP_RTT_REQUEST_TYPE_CONNECTTIME);\n}\n\nstatic BOOL autodetect_send_rtt_measure_response(rdpRdp* rdp, UINT16 sequenceNumber)\n{\n\twStream* s;\n\t/* Send the response PDU to the server */\n\ts = rdp_message_channel_pdu_init(rdp);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tWLog_VRB(AUTODETECT_TAG, \"sending RTT Measure Response PDU\");\n\tStream_Write_UINT8(s, 0x06);                        /* headerLength (1 byte) */\n\tStream_Write_UINT8(s, TYPE_ID_AUTODETECT_RESPONSE); /* headerTypeId (1 byte) */\n\tStream_Write_UINT16(s, sequenceNumber);             /* sequenceNumber (2 bytes) */\n\tStream_Write_UINT16(s, RDP_RTT_RESPONSE_TYPE);      /* responseType (1 byte) */\n\treturn rdp_send_message_channel_pdu(rdp, s, SEC_AUTODETECT_RSP);\n}\n\nstatic BOOL autodetect_send_bandwidth_measure_start(rdpContext* context, UINT16 sequenceNumber,\n                                                    UINT16 requestType)\n{\n\twStream* s;\n\ts = rdp_message_channel_pdu_init(context->rdp);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tWLog_VRB(AUTODETECT_TAG, \"sending Bandwidth Measure Start PDU\");\n\tStream_Write_UINT8(s, 0x06);                       /* headerLength (1 byte) */\n\tStream_Write_UINT8(s, TYPE_ID_AUTODETECT_REQUEST); /* headerTypeId (1 byte) */\n\tStream_Write_UINT16(s, sequenceNumber);            /* sequenceNumber (2 bytes) */\n\tStream_Write_UINT16(s, requestType);               /* requestType (2 bytes) */\n\treturn rdp_send_message_channel_pdu(context->rdp, s, SEC_AUTODETECT_REQ);\n}\n\nstatic BOOL autodetect_send_continuous_bandwidth_measure_start(rdpContext* context,\n                                                               UINT16 sequenceNumber)\n{\n\treturn autodetect_send_bandwidth_measure_start(context, sequenceNumber,\n\t                                               RDP_BW_START_REQUEST_TYPE_CONTINUOUS);\n}\n\nBOOL autodetect_send_connecttime_bandwidth_measure_start(rdpContext* context, UINT16 sequenceNumber)\n{\n\treturn autodetect_send_bandwidth_measure_start(context, sequenceNumber,\n\t                                               RDP_BW_START_REQUEST_TYPE_CONNECTTIME);\n}\n\nBOOL autodetect_send_bandwidth_measure_payload(rdpContext* context, UINT16 payloadLength,\n                                               UINT16 sequenceNumber)\n{\n\twStream* s;\n\tUCHAR* buffer = NULL;\n\tBOOL bResult = FALSE;\n\ts = rdp_message_channel_pdu_init(context->rdp);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tWLog_VRB(AUTODETECT_TAG, \"sending Bandwidth Measure Payload PDU -> payloadLength=%\" PRIu16 \"\",\n\t         payloadLength);\n\t/* 4-bytes aligned */\n\tpayloadLength &= ~3;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 8 + payloadLength))\n\t{\n\t\tStream_Release(s);\n\t\treturn FALSE;\n\t}\n\n\tStream_Write_UINT8(s, 0x08);                         /* headerLength (1 byte) */\n\tStream_Write_UINT8(s, TYPE_ID_AUTODETECT_REQUEST);   /* headerTypeId (1 byte) */\n\tStream_Write_UINT16(s, sequenceNumber);              /* sequenceNumber (2 bytes) */\n\tStream_Write_UINT16(s, RDP_BW_PAYLOAD_REQUEST_TYPE); /* requestType (2 bytes) */\n\tStream_Write_UINT16(s, payloadLength);               /* payloadLength (2 bytes) */\n\t/* Random data (better measurement in case the line is compressed) */\n\tbuffer = (UCHAR*)malloc(payloadLength);\n\n\tif (NULL == buffer)\n\t{\n\t\tStream_Release(s);\n\t\treturn FALSE;\n\t}\n\n\twinpr_RAND(buffer, payloadLength);\n\tStream_Write(s, buffer, payloadLength);\n\tbResult = rdp_send_message_channel_pdu(context->rdp, s, SEC_AUTODETECT_REQ);\n\tfree(buffer);\n\treturn bResult;\n}\n\nstatic BOOL autodetect_send_bandwidth_measure_stop(rdpContext* context, UINT16 payloadLength,\n                                                   UINT16 sequenceNumber, UINT16 requestType)\n{\n\twStream* s;\n\tUCHAR* buffer = NULL;\n\tBOOL bResult = FALSE;\n\ts = rdp_message_channel_pdu_init(context->rdp);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tWLog_VRB(AUTODETECT_TAG, \"sending Bandwidth Measure Stop PDU -> payloadLength=%\" PRIu16 \"\",\n\t         payloadLength);\n\t/* 4-bytes aligned */\n\tpayloadLength &= ~3;\n\tStream_Write_UINT8(s, requestType == RDP_BW_STOP_REQUEST_TYPE_CONNECTTIME\n\t                          ? 0x08\n\t                          : 0x06);                 /* headerLength (1 byte) */\n\tStream_Write_UINT8(s, TYPE_ID_AUTODETECT_REQUEST); /* headerTypeId (1 byte) */\n\tStream_Write_UINT16(s, sequenceNumber);            /* sequenceNumber (2 bytes) */\n\tStream_Write_UINT16(s, requestType);               /* requestType (2 bytes) */\n\n\tif (requestType == RDP_BW_STOP_REQUEST_TYPE_CONNECTTIME)\n\t{\n\t\tStream_Write_UINT16(s, payloadLength); /* payloadLength (2 bytes) */\n\n\t\tif (payloadLength > 0)\n\t\t{\n\t\t\tif (!Stream_EnsureRemainingCapacity(s, payloadLength))\n\t\t\t{\n\t\t\t\tStream_Release(s);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\t/* Random data (better measurement in case the line is compressed) */\n\t\t\tbuffer = malloc(payloadLength);\n\n\t\t\tif (NULL == buffer)\n\t\t\t{\n\t\t\t\tStream_Release(s);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\twinpr_RAND(buffer, payloadLength);\n\t\t\tStream_Write(s, buffer, payloadLength);\n\t\t}\n\t}\n\n\tbResult = rdp_send_message_channel_pdu(context->rdp, s, SEC_AUTODETECT_REQ);\n\tfree(buffer);\n\treturn bResult;\n}\n\nstatic BOOL autodetect_send_continuous_bandwidth_measure_stop(rdpContext* context,\n                                                              UINT16 sequenceNumber)\n{\n\treturn autodetect_send_bandwidth_measure_stop(context, 0, sequenceNumber,\n\t                                              RDP_BW_STOP_REQUEST_TYPE_CONTINUOUS);\n}\n\nBOOL autodetect_send_connecttime_bandwidth_measure_stop(rdpContext* context, UINT16 payloadLength,\n                                                        UINT16 sequenceNumber)\n{\n\treturn autodetect_send_bandwidth_measure_stop(context, payloadLength, sequenceNumber,\n\t                                              RDP_BW_STOP_REQUEST_TYPE_CONNECTTIME);\n}\n\nstatic BOOL autodetect_send_bandwidth_measure_results(rdpRdp* rdp, UINT16 responseType,\n                                                      UINT16 sequenceNumber)\n{\n\tBOOL success = TRUE;\n\twStream* s;\n\tUINT64 timeDelta;\n\t/* Compute the total time */\n\ttimeDelta = GetTickCount64() - rdp->autodetect->bandwidthMeasureStartTime;\n\t/* Send the result PDU to the server */\n\ts = rdp_message_channel_pdu_init(rdp);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tWLog_VRB(AUTODETECT_TAG,\n\t         \"sending Bandwidth Measure Results PDU -> timeDelta=%\" PRIu32 \", byteCount=%\" PRIu32\n\t         \"\",\n\t         timeDelta, rdp->autodetect->bandwidthMeasureByteCount);\n\tStream_Write_UINT8(s, 0x0E);                        /* headerLength (1 byte) */\n\tStream_Write_UINT8(s, TYPE_ID_AUTODETECT_RESPONSE); /* headerTypeId (1 byte) */\n\tStream_Write_UINT16(s, sequenceNumber);             /* sequenceNumber (2 bytes) */\n\tStream_Write_UINT16(s, responseType);               /* responseType (1 byte) */\n\tStream_Write_UINT32(s, timeDelta);                  /* timeDelta (4 bytes) */\n\tStream_Write_UINT32(s, rdp->autodetect->bandwidthMeasureByteCount); /* byteCount (4 bytes) */\n\tIFCALLRET(rdp->autodetect->ClientBandwidthMeasureResult, success, rdp->context,\n\t          rdp->autodetect);\n\n\tif (!success)\n\t\treturn FALSE;\n\n\treturn rdp_send_message_channel_pdu(rdp, s, SEC_AUTODETECT_RSP);\n}\n\nstatic BOOL autodetect_send_netchar_result(rdpContext* context, UINT16 sequenceNumber)\n{\n\twStream* s;\n\ts = rdp_message_channel_pdu_init(context->rdp);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tWLog_VRB(AUTODETECT_TAG, \"sending Bandwidth Network Characteristics Result PDU\");\n\n\tif (context->rdp->autodetect->netCharBandwidth > 0)\n\t{\n\t\tStream_Write_UINT8(s, 0x12);                       /* headerLength (1 byte) */\n\t\tStream_Write_UINT8(s, TYPE_ID_AUTODETECT_REQUEST); /* headerTypeId (1 byte) */\n\t\tStream_Write_UINT16(s, sequenceNumber);            /* sequenceNumber (2 bytes) */\n\t\tStream_Write_UINT16(s, 0x08C0);                    /* requestType (2 bytes) */\n\t\tStream_Write_UINT32(s, context->rdp->autodetect->netCharBaseRTT); /* baseRTT (4 bytes) */\n\t\tStream_Write_UINT32(s,\n\t\t                    context->rdp->autodetect->netCharBandwidth); /* bandwidth (4 bytes) */\n\t\tStream_Write_UINT32(s,\n\t\t                    context->rdp->autodetect->netCharAverageRTT); /* averageRTT (4 bytes) */\n\t}\n\telse\n\t{\n\t\tStream_Write_UINT8(s, 0x0E);                       /* headerLength (1 byte) */\n\t\tStream_Write_UINT8(s, TYPE_ID_AUTODETECT_REQUEST); /* headerTypeId (1 byte) */\n\t\tStream_Write_UINT16(s, sequenceNumber);            /* sequenceNumber (2 bytes) */\n\t\tStream_Write_UINT16(s, 0x0840);                    /* requestType (2 bytes) */\n\t\tStream_Write_UINT32(s, context->rdp->autodetect->netCharBaseRTT); /* baseRTT (4 bytes) */\n\t\tStream_Write_UINT32(s,\n\t\t                    context->rdp->autodetect->netCharAverageRTT); /* averageRTT (4 bytes) */\n\t}\n\n\treturn rdp_send_message_channel_pdu(context->rdp, s, SEC_AUTODETECT_REQ);\n}\n\nstatic BOOL autodetect_send_netchar_sync(rdpRdp* rdp, UINT16 sequenceNumber)\n{\n\twStream* s;\n\t/* Send the response PDU to the server */\n\ts = rdp_message_channel_pdu_init(rdp);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tWLog_VRB(AUTODETECT_TAG,\n\t         \"sending Network Characteristics Sync PDU -> bandwidth=%\" PRIu32 \", rtt=%\" PRIu32 \"\",\n\t         rdp->autodetect->netCharBandwidth, rdp->autodetect->netCharAverageRTT);\n\tStream_Write_UINT8(s, 0x0E);                                /* headerLength (1 byte) */\n\tStream_Write_UINT8(s, TYPE_ID_AUTODETECT_RESPONSE);         /* headerTypeId (1 byte) */\n\tStream_Write_UINT16(s, sequenceNumber);                     /* sequenceNumber (2 bytes) */\n\tStream_Write_UINT16(s, RDP_NETCHAR_SYNC_RESPONSE_TYPE);     /* responseType (1 byte) */\n\tStream_Write_UINT32(s, rdp->autodetect->netCharBandwidth);  /* bandwidth (4 bytes) */\n\tStream_Write_UINT32(s, rdp->autodetect->netCharAverageRTT); /* rtt (4 bytes) */\n\treturn rdp_send_message_channel_pdu(rdp, s, SEC_AUTODETECT_RSP);\n}\n\nstatic BOOL autodetect_recv_rtt_measure_request(rdpRdp* rdp, wStream* s,\n                                                AUTODETECT_REQ_PDU* autodetectReqPdu)\n{\n\tif (autodetectReqPdu->headerLength != 0x06)\n\t\treturn FALSE;\n\n\tWLog_VRB(AUTODETECT_TAG, \"received RTT Measure Request PDU\");\n\t/* Send a response to the server */\n\treturn autodetect_send_rtt_measure_response(rdp, autodetectReqPdu->sequenceNumber);\n}\n\nstatic BOOL autodetect_recv_rtt_measure_response(rdpRdp* rdp, wStream* s,\n                                                 AUTODETECT_RSP_PDU* autodetectRspPdu)\n{\n\tBOOL success = TRUE;\n\n\tif (autodetectRspPdu->headerLength != 0x06)\n\t\treturn FALSE;\n\n\tWLog_VRB(AUTODETECT_TAG, \"received RTT Measure Response PDU\");\n\trdp->autodetect->netCharAverageRTT = GetTickCount64() - rdp->autodetect->rttMeasureStartTime;\n\n\tif (rdp->autodetect->netCharBaseRTT == 0 ||\n\t    rdp->autodetect->netCharBaseRTT > rdp->autodetect->netCharAverageRTT)\n\t\trdp->autodetect->netCharBaseRTT = rdp->autodetect->netCharAverageRTT;\n\n\tIFCALLRET(rdp->autodetect->RTTMeasureResponse, success, rdp->context,\n\t          autodetectRspPdu->sequenceNumber);\n\treturn success;\n}\n\nstatic BOOL autodetect_recv_bandwidth_measure_start(rdpRdp* rdp, wStream* s,\n                                                    AUTODETECT_REQ_PDU* autodetectReqPdu)\n{\n\tif (autodetectReqPdu->headerLength != 0x06)\n\t\treturn FALSE;\n\n\tWLog_VRB(AUTODETECT_TAG, \"received Bandwidth Measure Start PDU - time=%\" PRIu64 \"\",\n\t         GetTickCount64());\n\t/* Initialize bandwidth measurement parameters */\n\trdp->autodetect->bandwidthMeasureStartTime = GetTickCount64();\n\trdp->autodetect->bandwidthMeasureByteCount = 0;\n\n\t/* Continuous Auto-Detection: mark the start of the measurement */\n\tif (autodetectReqPdu->requestType == RDP_BW_START_REQUEST_TYPE_CONTINUOUS)\n\t{\n\t\trdp->autodetect->bandwidthMeasureStarted = TRUE;\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL autodetect_recv_bandwidth_measure_payload(rdpRdp* rdp, wStream* s,\n                                                      AUTODETECT_REQ_PDU* autodetectReqPdu)\n{\n\tUINT16 payloadLength;\n\n\tif (autodetectReqPdu->headerLength != 0x08)\n\t\treturn FALSE;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, payloadLength); /* payloadLength (2 bytes) */\n\tif (!Stream_SafeSeek(s, payloadLength))\n\t\treturn FALSE;\n\tWLog_DBG(AUTODETECT_TAG, \"received Bandwidth Measure Payload PDU -> payloadLength=%\" PRIu16 \"\",\n\t         payloadLength);\n\t/* Add the payload length to the bandwidth measurement parameters */\n\trdp->autodetect->bandwidthMeasureByteCount += payloadLength;\n\treturn TRUE;\n}\n\nstatic BOOL autodetect_recv_bandwidth_measure_stop(rdpRdp* rdp, wStream* s,\n                                                   AUTODETECT_REQ_PDU* autodetectReqPdu)\n{\n\tUINT16 payloadLength;\n\tUINT16 responseType;\n\n\tif (autodetectReqPdu->requestType == RDP_BW_STOP_REQUEST_TYPE_CONNECTTIME)\n\t{\n\t\tif (autodetectReqPdu->headerLength != 0x08)\n\t\t\treturn FALSE;\n\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, payloadLength); /* payloadLength (2 bytes) */\n\t}\n\telse\n\t{\n\t\tif (autodetectReqPdu->headerLength != 0x06)\n\t\t\treturn FALSE;\n\n\t\tpayloadLength = 0;\n\t}\n\n\tif (!Stream_SafeSeek(s, payloadLength))\n\t\treturn FALSE;\n\n\tWLog_VRB(AUTODETECT_TAG, \"received Bandwidth Measure Stop PDU -> payloadLength=%\" PRIu16 \"\",\n\t         payloadLength);\n\t/* Add the payload length to the bandwidth measurement parameters */\n\trdp->autodetect->bandwidthMeasureByteCount += payloadLength;\n\n\t/* Continuous Auto-Detection: mark the stop of the measurement */\n\tif (autodetectReqPdu->requestType == RDP_BW_STOP_REQUEST_TYPE_CONTINUOUS)\n\t{\n\t\trdp->autodetect->bandwidthMeasureStarted = FALSE;\n\t}\n\n\t/* Send a response the server */\n\tresponseType = autodetectReqPdu->requestType == RDP_BW_STOP_REQUEST_TYPE_CONNECTTIME\n\t                   ? RDP_BW_RESULTS_RESPONSE_TYPE_CONNECTTIME\n\t                   : RDP_BW_RESULTS_RESPONSE_TYPE_CONTINUOUS;\n\treturn autodetect_send_bandwidth_measure_results(rdp, responseType,\n\t                                                 autodetectReqPdu->sequenceNumber);\n}\n\nstatic BOOL autodetect_recv_bandwidth_measure_results(rdpRdp* rdp, wStream* s,\n                                                      AUTODETECT_RSP_PDU* autodetectRspPdu)\n{\n\tBOOL success = TRUE;\n\n\tif (autodetectRspPdu->headerLength != 0x0E)\n\t\treturn FALSE;\n\n\tWLog_VRB(AUTODETECT_TAG, \"received Bandwidth Measure Results PDU\");\n\tStream_Read_UINT32(s, rdp->autodetect->bandwidthMeasureTimeDelta); /* timeDelta (4 bytes) */\n\tStream_Read_UINT32(s, rdp->autodetect->bandwidthMeasureByteCount); /* byteCount (4 bytes) */\n\n\tif (rdp->autodetect->bandwidthMeasureTimeDelta > 0)\n\t\trdp->autodetect->netCharBandwidth = rdp->autodetect->bandwidthMeasureByteCount * 8 /\n\t\t                                    rdp->autodetect->bandwidthMeasureTimeDelta;\n\telse\n\t\trdp->autodetect->netCharBandwidth = 0;\n\n\tIFCALLRET(rdp->autodetect->BandwidthMeasureResults, success, rdp->context,\n\t          autodetectRspPdu->sequenceNumber);\n\treturn success;\n}\n\nstatic BOOL autodetect_recv_netchar_result(rdpRdp* rdp, wStream* s,\n                                           AUTODETECT_REQ_PDU* autodetectReqPdu)\n{\n\tBOOL success = TRUE;\n\n\tswitch (autodetectReqPdu->requestType)\n\t{\n\t\tcase 0x0840:\n\n\t\t\t/* baseRTT and averageRTT fields are present (bandwidth field is not) */\n\t\t\tif ((autodetectReqPdu->headerLength != 0x0E) || (Stream_GetRemainingLength(s) < 8))\n\t\t\t\treturn FALSE;\n\n\t\t\tStream_Read_UINT32(s, rdp->autodetect->netCharBaseRTT);    /* baseRTT (4 bytes) */\n\t\t\tStream_Read_UINT32(s, rdp->autodetect->netCharAverageRTT); /* averageRTT (4 bytes) */\n\t\t\tbreak;\n\n\t\tcase 0x0880:\n\n\t\t\t/* bandwidth and averageRTT fields are present (baseRTT field is not) */\n\t\t\tif ((autodetectReqPdu->headerLength != 0x0E) || (Stream_GetRemainingLength(s) < 8))\n\t\t\t\treturn FALSE;\n\n\t\t\tStream_Read_UINT32(s, rdp->autodetect->netCharBandwidth);  /* bandwidth (4 bytes) */\n\t\t\tStream_Read_UINT32(s, rdp->autodetect->netCharAverageRTT); /* averageRTT (4 bytes) */\n\t\t\tbreak;\n\n\t\tcase 0x08C0:\n\n\t\t\t/* baseRTT, bandwidth, and averageRTT fields are present */\n\t\t\tif ((autodetectReqPdu->headerLength != 0x12) || (Stream_GetRemainingLength(s) < 12))\n\t\t\t\treturn FALSE;\n\n\t\t\tStream_Read_UINT32(s, rdp->autodetect->netCharBaseRTT);    /* baseRTT (4 bytes) */\n\t\t\tStream_Read_UINT32(s, rdp->autodetect->netCharBandwidth);  /* bandwidth (4 bytes) */\n\t\t\tStream_Read_UINT32(s, rdp->autodetect->netCharAverageRTT); /* averageRTT (4 bytes) */\n\t\t\tbreak;\n\t}\n\n\tWLog_VRB(AUTODETECT_TAG,\n\t         \"received Network Characteristics Result PDU -> baseRTT=%\" PRIu32\n\t         \", bandwidth=%\" PRIu32 \", averageRTT=%\" PRIu32 \"\",\n\t         rdp->autodetect->netCharBaseRTT, rdp->autodetect->netCharBandwidth,\n\t         rdp->autodetect->netCharAverageRTT);\n\tIFCALLRET(rdp->autodetect->NetworkCharacteristicsResult, success, rdp->context,\n\t          autodetectReqPdu->sequenceNumber);\n\treturn success;\n}\n\nint rdp_recv_autodetect_request_packet(rdpRdp* rdp, wStream* s)\n{\n\tAUTODETECT_REQ_PDU autodetectReqPdu;\n\tBOOL success = FALSE;\n\n\tif (Stream_GetRemainingLength(s) < 6)\n\t\treturn -1;\n\n\tStream_Read_UINT8(s, autodetectReqPdu.headerLength);    /* headerLength (1 byte) */\n\tStream_Read_UINT8(s, autodetectReqPdu.headerTypeId);    /* headerTypeId (1 byte) */\n\tStream_Read_UINT16(s, autodetectReqPdu.sequenceNumber); /* sequenceNumber (2 bytes) */\n\tStream_Read_UINT16(s, autodetectReqPdu.requestType);    /* requestType (2 bytes) */\n\tWLog_VRB(AUTODETECT_TAG,\n\t         \"rdp_recv_autodetect_request_packet: headerLength=%\" PRIu8 \", headerTypeId=%\" PRIu8\n\t         \", sequenceNumber=%\" PRIu16 \", requestType=%04\" PRIx16 \"\",\n\t         autodetectReqPdu.headerLength, autodetectReqPdu.headerTypeId,\n\t         autodetectReqPdu.sequenceNumber, autodetectReqPdu.requestType);\n\n\tif (autodetectReqPdu.headerTypeId != TYPE_ID_AUTODETECT_REQUEST)\n\t\treturn -1;\n\n\tswitch (autodetectReqPdu.requestType)\n\t{\n\t\tcase RDP_RTT_REQUEST_TYPE_CONTINUOUS:\n\t\tcase RDP_RTT_REQUEST_TYPE_CONNECTTIME:\n\t\t\t/* RTT Measure Request (RDP_RTT_REQUEST) - MS-RDPBCGR 2.2.14.1.1 */\n\t\t\tsuccess = autodetect_recv_rtt_measure_request(rdp, s, &autodetectReqPdu);\n\t\t\tbreak;\n\n\t\tcase RDP_BW_START_REQUEST_TYPE_CONTINUOUS:\n\t\tcase RDP_BW_START_REQUEST_TYPE_TUNNEL:\n\t\tcase RDP_BW_START_REQUEST_TYPE_CONNECTTIME:\n\t\t\t/* Bandwidth Measure Start (RDP_BW_START) - MS-RDPBCGR 2.2.14.1.2 */\n\t\t\tsuccess = autodetect_recv_bandwidth_measure_start(rdp, s, &autodetectReqPdu);\n\t\t\tbreak;\n\n\t\tcase RDP_BW_PAYLOAD_REQUEST_TYPE:\n\t\t\t/* Bandwidth Measure Payload (RDP_BW_PAYLOAD) - MS-RDPBCGR 2.2.14.1.3 */\n\t\t\tsuccess = autodetect_recv_bandwidth_measure_payload(rdp, s, &autodetectReqPdu);\n\t\t\tbreak;\n\n\t\tcase RDP_BW_STOP_REQUEST_TYPE_CONNECTTIME:\n\t\tcase RDP_BW_STOP_REQUEST_TYPE_CONTINUOUS:\n\t\tcase RDP_BW_STOP_REQUEST_TYPE_TUNNEL:\n\t\t\t/* Bandwidth Measure Stop (RDP_BW_STOP) - MS-RDPBCGR 2.2.14.1.4 */\n\t\t\tsuccess = autodetect_recv_bandwidth_measure_stop(rdp, s, &autodetectReqPdu);\n\t\t\tbreak;\n\n\t\tcase 0x0840:\n\t\tcase 0x0880:\n\t\tcase 0x08C0:\n\t\t\t/* Network Characteristics Result (RDP_NETCHAR_RESULT) - MS-RDPBCGR 2.2.14.1.5 */\n\t\t\tsuccess = autodetect_recv_netchar_result(rdp, s, &autodetectReqPdu);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\treturn success ? 0 : -1;\n}\n\nint rdp_recv_autodetect_response_packet(rdpRdp* rdp, wStream* s)\n{\n\tAUTODETECT_RSP_PDU autodetectRspPdu;\n\tBOOL success = FALSE;\n\n\tif (Stream_GetRemainingLength(s) < 6)\n\t\treturn -1;\n\n\tStream_Read_UINT8(s, autodetectRspPdu.headerLength);    /* headerLength (1 byte) */\n\tStream_Read_UINT8(s, autodetectRspPdu.headerTypeId);    /* headerTypeId (1 byte) */\n\tStream_Read_UINT16(s, autodetectRspPdu.sequenceNumber); /* sequenceNumber (2 bytes) */\n\tStream_Read_UINT16(s, autodetectRspPdu.responseType);   /* responseType (2 bytes) */\n\tWLog_VRB(AUTODETECT_TAG,\n\t         \"rdp_recv_autodetect_response_packet: headerLength=%\" PRIu8 \", headerTypeId=%\" PRIu8\n\t         \", sequenceNumber=%\" PRIu16 \", requestType=%04\" PRIx16 \"\",\n\t         autodetectRspPdu.headerLength, autodetectRspPdu.headerTypeId,\n\t         autodetectRspPdu.sequenceNumber, autodetectRspPdu.responseType);\n\n\tif (autodetectRspPdu.headerTypeId != TYPE_ID_AUTODETECT_RESPONSE)\n\t\treturn -1;\n\n\tswitch (autodetectRspPdu.responseType)\n\t{\n\t\tcase RDP_RTT_RESPONSE_TYPE:\n\t\t\t/* RTT Measure Response (RDP_RTT_RESPONSE) - MS-RDPBCGR 2.2.14.2.1 */\n\t\t\tsuccess = autodetect_recv_rtt_measure_response(rdp, s, &autodetectRspPdu);\n\t\t\tbreak;\n\n\t\tcase RDP_BW_RESULTS_RESPONSE_TYPE_CONNECTTIME:\n\t\tcase RDP_BW_RESULTS_RESPONSE_TYPE_CONTINUOUS:\n\t\t\t/* Bandwidth Measure Results (RDP_BW_RESULTS) - MS-RDPBCGR 2.2.14.2.2 */\n\t\t\tsuccess = autodetect_recv_bandwidth_measure_results(rdp, s, &autodetectRspPdu);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn success ? 0 : -1;\n}\n\nrdpAutoDetect* autodetect_new(void)\n{\n\trdpAutoDetect* autoDetect = (rdpAutoDetect*)calloc(1, sizeof(rdpAutoDetect));\n\n\tif (autoDetect)\n\t{\n\t}\n\n\treturn autoDetect;\n}\n\nvoid autodetect_free(rdpAutoDetect* autoDetect)\n{\n\tfree(autoDetect);\n}\n\nvoid autodetect_register_server_callbacks(rdpAutoDetect* autodetect)\n{\n\tautodetect->RTTMeasureRequest = autodetect_send_continuous_rtt_measure_request;\n\tautodetect->BandwidthMeasureStart = autodetect_send_continuous_bandwidth_measure_start;\n\tautodetect->BandwidthMeasureStop = autodetect_send_continuous_bandwidth_measure_stop;\n\tautodetect->NetworkCharacteristicsResult = autodetect_send_netchar_result;\n}\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * RDP Capability Sets\n *\n * Copyright 2011 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *\t http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"capabilities.h\"\n#include \"fastpath.h\"\n\n#include <winpr/crt.h>\n#include <winpr/rpc.h>\n\n#include <freerdp/log.h>\n\n#define TAG FREERDP_TAG(\"core.capabilities\")\n\nstatic const char* const CAPSET_TYPE_STRINGS[] = { \"Unknown\",\n\t                                               \"General\",\n\t                                               \"Bitmap\",\n\t                                               \"Order\",\n\t                                               \"Bitmap Cache\",\n\t                                               \"Control\",\n\t                                               \"Unknown\",\n\t                                               \"Window Activation\",\n\t                                               \"Pointer\",\n\t                                               \"Share\",\n\t                                               \"Color Cache\",\n\t                                               \"Unknown\",\n\t                                               \"Sound\",\n\t                                               \"Input\",\n\t                                               \"Font\",\n\t                                               \"Brush\",\n\t                                               \"Glyph Cache\",\n\t                                               \"Offscreen Bitmap Cache\",\n\t                                               \"Bitmap Cache Host Support\",\n\t                                               \"Bitmap Cache v2\",\n\t                                               \"Virtual Channel\",\n\t                                               \"DrawNineGrid Cache\",\n\t                                               \"Draw GDI+ Cache\",\n\t                                               \"Remote Programs\",\n\t                                               \"Window List\",\n\t                                               \"Desktop Composition\",\n\t                                               \"Multifragment Update\",\n\t                                               \"Large Pointer\",\n\t                                               \"Surface Commands\",\n\t                                               \"Bitmap Codecs\",\n\t                                               \"Frame Acknowledge\" };\n\nstatic const char* get_capability_name(UINT16 type)\n{\n\tif (type > CAPSET_TYPE_FRAME_ACKNOWLEDGE)\n\t\treturn \"<unknown>\";\n\n\treturn CAPSET_TYPE_STRINGS[type];\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_capability_sets(wStream* s, UINT16 numberCapabilities, BOOL receiving);\n#endif\n\n/* CODEC_GUID_REMOTEFX: 0x76772F12BD724463AFB3B73C9C6F7886 */\n\nstatic const GUID CODEC_GUID_REMOTEFX = {\n\t0x76772F12, 0xBD72, 0x4463, { 0xAF, 0xB3, 0xB7, 0x3C, 0x9C, 0x6F, 0x78, 0x86 }\n};\n\n/* CODEC_GUID_NSCODEC 0xCA8D1BB9000F154F589FAE2D1A87E2D6 */\n\nstatic const GUID CODEC_GUID_NSCODEC = {\n\t0xCA8D1BB9, 0x000F, 0x154F, { 0x58, 0x9F, 0xAE, 0x2D, 0x1A, 0x87, 0xE2, 0xD6 }\n};\n\n/* CODEC_GUID_IGNORE 0x9C4351A6353542AE910CCDFCE5760B58 */\n\nstatic const GUID CODEC_GUID_IGNORE = {\n\t0x9C4351A6, 0x3535, 0x42AE, { 0x91, 0x0C, 0xCD, 0xFC, 0xE5, 0x76, 0x0B, 0x58 }\n};\n\n/* CODEC_GUID_IMAGE_REMOTEFX 0x2744CCD49D8A4E74803C0ECBEEA19C54 */\n\nstatic const GUID CODEC_GUID_IMAGE_REMOTEFX = {\n\t0x2744CCD4, 0x9D8A, 0x4E74, { 0x80, 0x3C, 0x0E, 0xCB, 0xEE, 0xA1, 0x9C, 0x54 }\n};\n\n#if defined(WITH_JPEG)\n/* CODEC_GUID_JPEG 0x430C9EED1BAF4CE6869ACB8B37B66237 */\n\nstatic const GUID CODEC_GUID_JPEG = {\n\t0x430C9EED, 0x1BAF, 0x4CE6, { 0x86, 0x9A, 0xCB, 0x8B, 0x37, 0xB6, 0x62, 0x37 }\n};\n#endif\n\nstatic void rdp_read_capability_set_header(wStream* s, UINT16* length, UINT16* type)\n{\n\tStream_Read_UINT16(s, *type);   /* capabilitySetType */\n\tStream_Read_UINT16(s, *length); /* lengthCapability */\n}\n\nstatic void rdp_write_capability_set_header(wStream* s, UINT16 length, UINT16 type)\n{\n\tStream_Write_UINT16(s, type);   /* capabilitySetType */\n\tStream_Write_UINT16(s, length); /* lengthCapability */\n}\n\nstatic size_t rdp_capability_set_start(wStream* s)\n{\n\tsize_t header = Stream_GetPosition(s);\n\tStream_Zero(s, CAPSET_HEADER_LENGTH);\n\treturn header;\n}\n\nstatic void rdp_capability_set_finish(wStream* s, UINT16 header, UINT16 type)\n{\n\tsize_t footer;\n\tsize_t length;\n\tfooter = Stream_GetPosition(s);\n\tlength = footer - header;\n\tStream_SetPosition(s, header);\n\trdp_write_capability_set_header(s, (UINT16)length, type);\n\tStream_SetPosition(s, footer);\n}\n\n/**\n * Read general capability set.\\n\n * @msdn{cc240549}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_general_capability_set(wStream* s, UINT16 length, rdpSettings* settings)\n{\n\tUINT16 extraFlags;\n\tBYTE refreshRectSupport;\n\tBYTE suppressOutputSupport;\n\n\tif (length < 24)\n\t\treturn FALSE;\n\n\tif (settings->ServerMode)\n\t{\n\t\tStream_Read_UINT16(s, settings->OsMajorType); /* osMajorType (2 bytes) */\n\t\tStream_Read_UINT16(s, settings->OsMinorType); /* osMinorType (2 bytes) */\n\t}\n\telse\n\t{\n\t\tStream_Seek_UINT16(s); /* osMajorType (2 bytes) */\n\t\tStream_Seek_UINT16(s); /* osMinorType (2 bytes) */\n\t}\n\n\tStream_Seek_UINT16(s);                       /* protocolVersion (2 bytes) */\n\tStream_Seek_UINT16(s);                       /* pad2OctetsA (2 bytes) */\n\tStream_Seek_UINT16(s);                       /* generalCompressionTypes (2 bytes) */\n\tStream_Read_UINT16(s, extraFlags);           /* extraFlags (2 bytes) */\n\tStream_Seek_UINT16(s);                       /* updateCapabilityFlag (2 bytes) */\n\tStream_Seek_UINT16(s);                       /* remoteUnshareFlag (2 bytes) */\n\tStream_Seek_UINT16(s);                       /* generalCompressionLevel (2 bytes) */\n\tStream_Read_UINT8(s, refreshRectSupport);    /* refreshRectSupport (1 byte) */\n\tStream_Read_UINT8(s, suppressOutputSupport); /* suppressOutputSupport (1 byte) */\n\tsettings->NoBitmapCompressionHeader = (extraFlags & NO_BITMAP_COMPRESSION_HDR) ? TRUE : FALSE;\n\tsettings->LongCredentialsSupported = (extraFlags & LONG_CREDENTIALS_SUPPORTED) ? TRUE : FALSE;\n\n\tif (!(extraFlags & FASTPATH_OUTPUT_SUPPORTED))\n\t\tsettings->FastPathOutput = FALSE;\n\n\tif (!(extraFlags & ENC_SALTED_CHECKSUM))\n\t\tsettings->SaltedChecksum = FALSE;\n\n\tif (!settings->ServerMode)\n\t{\n\t\t/**\n\t\t * Note: refreshRectSupport and suppressOutputSupport are\n\t\t * server-only flags indicating to the client weather the\n\t\t * respective PDUs are supported. See MS-RDPBCGR 2.2.7.1.1\n\t\t */\n\t\tif (!refreshRectSupport)\n\t\t\tsettings->RefreshRect = FALSE;\n\n\t\tif (!suppressOutputSupport)\n\t\t\tsettings->SuppressOutput = FALSE;\n\t}\n\n\treturn TRUE;\n}\n\n/**\n * Write general capability set.\\n\n * @msdn{cc240549}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_general_capability_set(wStream* s, const rdpSettings* settings)\n{\n\tsize_t header;\n\tUINT16 extraFlags;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 64))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tif (header > UINT16_MAX)\n\t\treturn FALSE;\n\textraFlags = 0;\n\n\tif (settings->LongCredentialsSupported)\n\t\textraFlags |= LONG_CREDENTIALS_SUPPORTED;\n\n\tif (settings->NoBitmapCompressionHeader)\n\t\textraFlags |= NO_BITMAP_COMPRESSION_HDR;\n\n\tif (settings->AutoReconnectionEnabled)\n\t\textraFlags |= AUTORECONNECT_SUPPORTED;\n\n\tif (settings->FastPathOutput)\n\t\textraFlags |= FASTPATH_OUTPUT_SUPPORTED;\n\n\tif (settings->SaltedChecksum)\n\t\textraFlags |= ENC_SALTED_CHECKSUM;\n\n\tif ((settings->OsMajorType > UINT16_MAX) || (settings->OsMinorType > UINT16_MAX))\n\t{\n\t\tWLog_ERR(TAG,\n\t\t         \"OsMajorType=%08\" PRIx32 \", OsMinorType=%08\" PRIx32\n\t\t         \" they need to be smaller %04\" PRIx16,\n\t\t         settings->OsMajorType, settings->OsMinorType, UINT16_MAX);\n\t\treturn FALSE;\n\t}\n\tStream_Write_UINT16(s, (UINT16)settings->OsMajorType); /* osMajorType (2 bytes) */\n\tStream_Write_UINT16(s, (UINT16)settings->OsMinorType); /* osMinorType (2 bytes) */\n\tStream_Write_UINT16(s, CAPS_PROTOCOL_VERSION);   /* protocolVersion (2 bytes) */\n\tStream_Write_UINT16(s, 0);                       /* pad2OctetsA (2 bytes) */\n\tStream_Write_UINT16(s, 0);                       /* generalCompressionTypes (2 bytes) */\n\tStream_Write_UINT16(s, extraFlags);              /* extraFlags (2 bytes) */\n\tStream_Write_UINT16(s, 0);                       /* updateCapabilityFlag (2 bytes) */\n\tStream_Write_UINT16(s, 0);                       /* remoteUnshareFlag (2 bytes) */\n\tStream_Write_UINT16(s, 0);                       /* generalCompressionLevel (2 bytes) */\n\tStream_Write_UINT8(s, settings->RefreshRect ? 1 : 0);    /* refreshRectSupport (1 byte) */\n\tStream_Write_UINT8(s, settings->SuppressOutput ? 1 : 0); /* suppressOutputSupport (1 byte) */\n\trdp_capability_set_finish(s, (UINT16)header, CAPSET_TYPE_GENERAL);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_general_capability_set(wStream* s, UINT16 length)\n{\n\tUINT16 osMajorType;\n\tUINT16 osMinorType;\n\tUINT16 protocolVersion;\n\tUINT16 pad2OctetsA;\n\tUINT16 generalCompressionTypes;\n\tUINT16 extraFlags;\n\tUINT16 updateCapabilityFlag;\n\tUINT16 remoteUnshareFlag;\n\tUINT16 generalCompressionLevel;\n\tBYTE refreshRectSupport;\n\tBYTE suppressOutputSupport;\n\n\tif (length < 24)\n\t\treturn FALSE;\n\n\tWLog_INFO(TAG, \"GeneralCapabilitySet (length %\" PRIu16 \"):\", length);\n\tStream_Read_UINT16(s, osMajorType);             /* osMajorType (2 bytes) */\n\tStream_Read_UINT16(s, osMinorType);             /* osMinorType (2 bytes) */\n\tStream_Read_UINT16(s, protocolVersion);         /* protocolVersion (2 bytes) */\n\tStream_Read_UINT16(s, pad2OctetsA);             /* pad2OctetsA (2 bytes) */\n\tStream_Read_UINT16(s, generalCompressionTypes); /* generalCompressionTypes (2 bytes) */\n\tStream_Read_UINT16(s, extraFlags);              /* extraFlags (2 bytes) */\n\tStream_Read_UINT16(s, updateCapabilityFlag);    /* updateCapabilityFlag (2 bytes) */\n\tStream_Read_UINT16(s, remoteUnshareFlag);       /* remoteUnshareFlag (2 bytes) */\n\tStream_Read_UINT16(s, generalCompressionLevel); /* generalCompressionLevel (2 bytes) */\n\tStream_Read_UINT8(s, refreshRectSupport);       /* refreshRectSupport (1 byte) */\n\tStream_Read_UINT8(s, suppressOutputSupport);    /* suppressOutputSupport (1 byte) */\n\tWLog_INFO(TAG, \"\\tosMajorType: 0x%04\" PRIX16 \"\", osMajorType);\n\tWLog_INFO(TAG, \"\\tosMinorType: 0x%04\" PRIX16 \"\", osMinorType);\n\tWLog_INFO(TAG, \"\\tprotocolVersion: 0x%04\" PRIX16 \"\", protocolVersion);\n\tWLog_INFO(TAG, \"\\tpad2OctetsA: 0x%04\" PRIX16 \"\", pad2OctetsA);\n\tWLog_INFO(TAG, \"\\tgeneralCompressionTypes: 0x%04\" PRIX16 \"\", generalCompressionTypes);\n\tWLog_INFO(TAG, \"\\textraFlags: 0x%04\" PRIX16 \"\", extraFlags);\n\tWLog_INFO(TAG, \"\\tupdateCapabilityFlag: 0x%04\" PRIX16 \"\", updateCapabilityFlag);\n\tWLog_INFO(TAG, \"\\tremoteUnshareFlag: 0x%04\" PRIX16 \"\", remoteUnshareFlag);\n\tWLog_INFO(TAG, \"\\tgeneralCompressionLevel: 0x%04\" PRIX16 \"\", generalCompressionLevel);\n\tWLog_INFO(TAG, \"\\trefreshRectSupport: 0x%02\" PRIX8 \"\", refreshRectSupport);\n\tWLog_INFO(TAG, \"\\tsuppressOutputSupport: 0x%02\" PRIX8 \"\", suppressOutputSupport);\n\treturn TRUE;\n}\n#endif\n\n/**\n * Read bitmap capability set.\\n\n * @msdn{cc240554}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_bitmap_capability_set(wStream* s, UINT16 length, rdpSettings* settings)\n{\n\tBYTE drawingFlags;\n\tUINT16 desktopWidth;\n\tUINT16 desktopHeight;\n\tUINT16 desktopResizeFlag;\n\tUINT16 preferredBitsPerPixel;\n\n\tif (length < 28)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, preferredBitsPerPixel); /* preferredBitsPerPixel (2 bytes) */\n\tStream_Seek_UINT16(s);                        /* receive1BitPerPixel (2 bytes) */\n\tStream_Seek_UINT16(s);                        /* receive4BitsPerPixel (2 bytes) */\n\tStream_Seek_UINT16(s);                        /* receive8BitsPerPixel (2 bytes) */\n\tStream_Read_UINT16(s, desktopWidth);          /* desktopWidth (2 bytes) */\n\tStream_Read_UINT16(s, desktopHeight);         /* desktopHeight (2 bytes) */\n\tStream_Seek_UINT16(s);                        /* pad2Octets (2 bytes) */\n\tStream_Read_UINT16(s, desktopResizeFlag);     /* desktopResizeFlag (2 bytes) */\n\tStream_Seek_UINT16(s);                        /* bitmapCompressionFlag (2 bytes) */\n\tStream_Seek_UINT8(s);                         /* highColorFlags (1 byte) */\n\tStream_Read_UINT8(s, drawingFlags);           /* drawingFlags (1 byte) */\n\tStream_Seek_UINT16(s);                        /* multipleRectangleSupport (2 bytes) */\n\tStream_Seek_UINT16(s);                        /* pad2OctetsB (2 bytes) */\n\n\tif (!settings->ServerMode && (preferredBitsPerPixel != settings->ColorDepth))\n\t{\n\t\t/* The client must respect the actual color depth used by the server */\n\t\tsettings->ColorDepth = preferredBitsPerPixel;\n\t}\n\n\tif (desktopResizeFlag == FALSE)\n\t\tsettings->DesktopResize = FALSE;\n\n\tif (!settings->ServerMode && settings->DesktopResize)\n\t{\n\t\t/* The server may request a different desktop size during Deactivation-Reactivation sequence\n\t\t */\n\t\tsettings->DesktopWidth = desktopWidth;\n\t\tsettings->DesktopHeight = desktopHeight;\n\t}\n\n\tif (settings->DrawAllowSkipAlpha)\n\t\tsettings->DrawAllowSkipAlpha = (drawingFlags & DRAW_ALLOW_SKIP_ALPHA) ? TRUE : FALSE;\n\n\tif (settings->DrawAllowDynamicColorFidelity)\n\t\tsettings->DrawAllowDynamicColorFidelity =\n\t\t    (drawingFlags & DRAW_ALLOW_DYNAMIC_COLOR_FIDELITY) ? TRUE : FALSE;\n\n\tif (settings->DrawAllowColorSubsampling)\n\t\tsettings->DrawAllowColorSubsampling =\n\t\t    (drawingFlags & DRAW_ALLOW_COLOR_SUBSAMPLING) ? TRUE : FALSE;\n\n\treturn TRUE;\n}\n\n/**\n * Write bitmap capability set.\\n\n * @msdn{cc240554}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_bitmap_capability_set(wStream* s, const rdpSettings* settings)\n{\n\tsize_t header;\n\tBYTE drawingFlags = 0;\n\tUINT16 preferredBitsPerPixel;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 64))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tif (header > UINT16_MAX)\n\t\treturn FALSE;\n\tif (settings->DrawAllowSkipAlpha)\n\t\tdrawingFlags |= DRAW_ALLOW_SKIP_ALPHA;\n\n\tif (settings->DrawAllowDynamicColorFidelity)\n\t\tdrawingFlags |= DRAW_ALLOW_DYNAMIC_COLOR_FIDELITY;\n\n\tif (settings->DrawAllowColorSubsampling)\n\t\tdrawingFlags |= DRAW_ALLOW_COLOR_SUBSAMPLING; /* currently unimplemented */\n\n\t/* While bitmap_decode.c now implements YCoCg, in turning it\n\t * on we have found Microsoft is inconsistent on whether to invert R & B.\n\t * And it's not only from one server to another; on Win7/2008R2, it appears\n\t * to send the main content with a different inversion than the Windows\n\t * button!  So... don't advertise that we support YCoCg and the server\n\t * will not send it.  YCoCg is still needed for EGFX, but it at least\n\t * appears consistent in its use.\n\t */\n\n\tif ((settings->ColorDepth > UINT16_MAX) || (settings->DesktopWidth > UINT16_MAX) ||\n\t    (settings->DesktopHeight > UINT16_MAX) || (settings->DesktopResize > UINT16_MAX))\n\t\treturn FALSE;\n\n\tif (settings->RdpVersion >= RDP_VERSION_5_PLUS)\n\t\tpreferredBitsPerPixel = (UINT16)settings->ColorDepth;\n\telse\n\t\tpreferredBitsPerPixel = 8;\n\n\tStream_Write_UINT16(s, preferredBitsPerPixel);   /* preferredBitsPerPixel (2 bytes) */\n\tStream_Write_UINT16(s, 1);                       /* receive1BitPerPixel (2 bytes) */\n\tStream_Write_UINT16(s, 1);                       /* receive4BitsPerPixel (2 bytes) */\n\tStream_Write_UINT16(s, 1);                       /* receive8BitsPerPixel (2 bytes) */\n\tStream_Write_UINT16(s, (UINT16)settings->DesktopWidth);  /* desktopWidth (2 bytes) */\n\tStream_Write_UINT16(s, (UINT16)settings->DesktopHeight); /* desktopHeight (2 bytes) */\n\tStream_Write_UINT16(s, 0);                       /* pad2Octets (2 bytes) */\n\tStream_Write_UINT16(s, (UINT16)settings->DesktopResize); /* desktopResizeFlag (2 bytes) */\n\tStream_Write_UINT16(s, 1);                       /* bitmapCompressionFlag (2 bytes) */\n\tStream_Write_UINT8(s, 0);                        /* highColorFlags (1 byte) */\n\tStream_Write_UINT8(s, drawingFlags);             /* drawingFlags (1 byte) */\n\tStream_Write_UINT16(s, 1);                       /* multipleRectangleSupport (2 bytes) */\n\tStream_Write_UINT16(s, 0);                       /* pad2OctetsB (2 bytes) */\n\trdp_capability_set_finish(s, (UINT16)header, CAPSET_TYPE_BITMAP);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_bitmap_capability_set(wStream* s, UINT16 length)\n{\n\tUINT16 preferredBitsPerPixel;\n\tUINT16 receive1BitPerPixel;\n\tUINT16 receive4BitsPerPixel;\n\tUINT16 receive8BitsPerPixel;\n\tUINT16 desktopWidth;\n\tUINT16 desktopHeight;\n\tUINT16 pad2Octets;\n\tUINT16 desktopResizeFlag;\n\tUINT16 bitmapCompressionFlag;\n\tBYTE highColorFlags;\n\tBYTE drawingFlags;\n\tUINT16 multipleRectangleSupport;\n\tUINT16 pad2OctetsB;\n\tWLog_INFO(TAG, \"BitmapCapabilitySet (length %\" PRIu16 \"):\", length);\n\n\tif (length < 28)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, preferredBitsPerPixel);    /* preferredBitsPerPixel (2 bytes) */\n\tStream_Read_UINT16(s, receive1BitPerPixel);      /* receive1BitPerPixel (2 bytes) */\n\tStream_Read_UINT16(s, receive4BitsPerPixel);     /* receive4BitsPerPixel (2 bytes) */\n\tStream_Read_UINT16(s, receive8BitsPerPixel);     /* receive8BitsPerPixel (2 bytes) */\n\tStream_Read_UINT16(s, desktopWidth);             /* desktopWidth (2 bytes) */\n\tStream_Read_UINT16(s, desktopHeight);            /* desktopHeight (2 bytes) */\n\tStream_Read_UINT16(s, pad2Octets);               /* pad2Octets (2 bytes) */\n\tStream_Read_UINT16(s, desktopResizeFlag);        /* desktopResizeFlag (2 bytes) */\n\tStream_Read_UINT16(s, bitmapCompressionFlag);    /* bitmapCompressionFlag (2 bytes) */\n\tStream_Read_UINT8(s, highColorFlags);            /* highColorFlags (1 byte) */\n\tStream_Read_UINT8(s, drawingFlags);              /* drawingFlags (1 byte) */\n\tStream_Read_UINT16(s, multipleRectangleSupport); /* multipleRectangleSupport (2 bytes) */\n\tStream_Read_UINT16(s, pad2OctetsB);              /* pad2OctetsB (2 bytes) */\n\tWLog_INFO(TAG, \"\\tpreferredBitsPerPixel: 0x%04\" PRIX16 \"\", preferredBitsPerPixel);\n\tWLog_INFO(TAG, \"\\treceive1BitPerPixel: 0x%04\" PRIX16 \"\", receive1BitPerPixel);\n\tWLog_INFO(TAG, \"\\treceive4BitsPerPixel: 0x%04\" PRIX16 \"\", receive4BitsPerPixel);\n\tWLog_INFO(TAG, \"\\treceive8BitsPerPixel: 0x%04\" PRIX16 \"\", receive8BitsPerPixel);\n\tWLog_INFO(TAG, \"\\tdesktopWidth: 0x%04\" PRIX16 \"\", desktopWidth);\n\tWLog_INFO(TAG, \"\\tdesktopHeight: 0x%04\" PRIX16 \"\", desktopHeight);\n\tWLog_INFO(TAG, \"\\tpad2Octets: 0x%04\" PRIX16 \"\", pad2Octets);\n\tWLog_INFO(TAG, \"\\tdesktopResizeFlag: 0x%04\" PRIX16 \"\", desktopResizeFlag);\n\tWLog_INFO(TAG, \"\\tbitmapCompressionFlag: 0x%04\" PRIX16 \"\", bitmapCompressionFlag);\n\tWLog_INFO(TAG, \"\\thighColorFlags: 0x%02\" PRIX8 \"\", highColorFlags);\n\tWLog_INFO(TAG, \"\\tdrawingFlags: 0x%02\" PRIX8 \"\", drawingFlags);\n\tWLog_INFO(TAG, \"\\tmultipleRectangleSupport: 0x%04\" PRIX16 \"\", multipleRectangleSupport);\n\tWLog_INFO(TAG, \"\\tpad2OctetsB: 0x%04\" PRIX16 \"\", pad2OctetsB);\n\treturn TRUE;\n}\n#endif\n\n/**\n * Read order capability set.\\n\n * @msdn{cc240556}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_order_capability_set(wStream* s, UINT16 length, rdpSettings* settings)\n{\n\tint i;\n\tUINT16 orderFlags;\n\tBYTE orderSupport[32];\n\tUINT16 orderSupportExFlags;\n\tBOOL BitmapCacheV3Enabled = FALSE;\n\tBOOL FrameMarkerCommandEnabled = FALSE;\n\n\tif (length < 88)\n\t\treturn FALSE;\n\n\tStream_Seek(s, 16);                         /* terminalDescriptor (16 bytes) */\n\tStream_Seek_UINT32(s);                      /* pad4OctetsA (4 bytes) */\n\tStream_Seek_UINT16(s);                      /* desktopSaveXGranularity (2 bytes) */\n\tStream_Seek_UINT16(s);                      /* desktopSaveYGranularity (2 bytes) */\n\tStream_Seek_UINT16(s);                      /* pad2OctetsA (2 bytes) */\n\tStream_Seek_UINT16(s);                      /* maximumOrderLevel (2 bytes) */\n\tStream_Seek_UINT16(s);                      /* numberFonts (2 bytes) */\n\tStream_Read_UINT16(s, orderFlags);          /* orderFlags (2 bytes) */\n\tStream_Read(s, orderSupport, 32);           /* orderSupport (32 bytes) */\n\tStream_Seek_UINT16(s);                      /* textFlags (2 bytes) */\n\tStream_Read_UINT16(s, orderSupportExFlags); /* orderSupportExFlags (2 bytes) */\n\tStream_Seek_UINT32(s);                      /* pad4OctetsB (4 bytes) */\n\tStream_Seek_UINT32(s);                      /* desktopSaveSize (4 bytes) */\n\tStream_Seek_UINT16(s);                      /* pad2OctetsC (2 bytes) */\n\tStream_Seek_UINT16(s);                      /* pad2OctetsD (2 bytes) */\n\tStream_Seek_UINT16(s);                      /* textANSICodePage (2 bytes) */\n\tStream_Seek_UINT16(s);                      /* pad2OctetsE (2 bytes) */\n\n\tfor (i = 0; i < 32; i++)\n\t{\n\t\tif (orderSupport[i] == FALSE)\n\t\t\tsettings->OrderSupport[i] = FALSE;\n\t}\n\n\tif (orderFlags & ORDER_FLAGS_EXTRA_SUPPORT)\n\t{\n\t\tif (orderSupportExFlags & CACHE_BITMAP_V3_SUPPORT)\n\t\t\tBitmapCacheV3Enabled = TRUE;\n\n\t\tif (orderSupportExFlags & ALTSEC_FRAME_MARKER_SUPPORT)\n\t\t\tFrameMarkerCommandEnabled = TRUE;\n\t}\n\n\tif (settings->BitmapCacheV3Enabled && BitmapCacheV3Enabled)\n\t\tsettings->BitmapCacheVersion = 3;\n\telse\n\t\tsettings->BitmapCacheV3Enabled = FALSE;\n\n\tif (settings->FrameMarkerCommandEnabled && !FrameMarkerCommandEnabled)\n\t\tsettings->FrameMarkerCommandEnabled = FALSE;\n\n\treturn TRUE;\n}\n\n/**\n * Write order capability set.\\n\n * @msdn{cc240556}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_order_capability_set(wStream* s, const rdpSettings* settings)\n{\n\tsize_t header;\n\tUINT16 orderFlags;\n\tUINT16 orderSupportExFlags;\n\tUINT16 textANSICodePage = 0;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 64))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tif (header > UINT16_MAX)\n\t\treturn FALSE;\n\t/* see [MSDN-CP]: http://msdn.microsoft.com/en-us/library/dd317756 */\n\tif (!settings->ServerMode)\n\t\ttextANSICodePage = CP_UTF8; /* Unicode (UTF-8) */\n\n\torderSupportExFlags = 0;\n\torderFlags = NEGOTIATE_ORDER_SUPPORT | ZERO_BOUNDS_DELTA_SUPPORT | COLOR_INDEX_SUPPORT;\n\n\tif (settings->BitmapCacheV3Enabled)\n\t{\n\t\torderSupportExFlags |= CACHE_BITMAP_V3_SUPPORT;\n\t\torderFlags |= ORDER_FLAGS_EXTRA_SUPPORT;\n\t}\n\n\tif (settings->FrameMarkerCommandEnabled)\n\t{\n\t\torderSupportExFlags |= ALTSEC_FRAME_MARKER_SUPPORT;\n\t\torderFlags |= ORDER_FLAGS_EXTRA_SUPPORT;\n\t}\n\n\tStream_Zero(s, 16);                          /* terminalDescriptor (16 bytes) */\n\tStream_Write_UINT32(s, 0);                   /* pad4OctetsA (4 bytes) */\n\tStream_Write_UINT16(s, 1);                   /* desktopSaveXGranularity (2 bytes) */\n\tStream_Write_UINT16(s, 20);                  /* desktopSaveYGranularity (2 bytes) */\n\tStream_Write_UINT16(s, 0);                   /* pad2OctetsA (2 bytes) */\n\tStream_Write_UINT16(s, 1);                   /* maximumOrderLevel (2 bytes) */\n\tStream_Write_UINT16(s, 0);                   /* numberFonts (2 bytes) */\n\tStream_Write_UINT16(s, orderFlags);          /* orderFlags (2 bytes) */\n\tStream_Write(s, settings->OrderSupport, 32); /* orderSupport (32 bytes) */\n\tStream_Write_UINT16(s, 0);                   /* textFlags (2 bytes) */\n\tStream_Write_UINT16(s, orderSupportExFlags); /* orderSupportExFlags (2 bytes) */\n\tStream_Write_UINT32(s, 0);                   /* pad4OctetsB (4 bytes) */\n\tStream_Write_UINT32(s, 230400);              /* desktopSaveSize (4 bytes) */\n\tStream_Write_UINT16(s, 0);                   /* pad2OctetsC (2 bytes) */\n\tStream_Write_UINT16(s, 0);                   /* pad2OctetsD (2 bytes) */\n\tStream_Write_UINT16(s, textANSICodePage);    /* textANSICodePage (2 bytes) */\n\tStream_Write_UINT16(s, 0);                   /* pad2OctetsE (2 bytes) */\n\trdp_capability_set_finish(s, (UINT16)header, CAPSET_TYPE_ORDER);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_order_capability_set(wStream* s, UINT16 length)\n{\n\tBYTE terminalDescriptor[16];\n\tUINT32 pad4OctetsA;\n\tUINT16 desktopSaveXGranularity;\n\tUINT16 desktopSaveYGranularity;\n\tUINT16 pad2OctetsA;\n\tUINT16 maximumOrderLevel;\n\tUINT16 numberFonts;\n\tUINT16 orderFlags;\n\tBYTE orderSupport[32];\n\tUINT16 textFlags;\n\tUINT16 orderSupportExFlags;\n\tUINT32 pad4OctetsB;\n\tUINT32 desktopSaveSize;\n\tUINT16 pad2OctetsC;\n\tUINT16 pad2OctetsD;\n\tUINT16 textANSICodePage;\n\tUINT16 pad2OctetsE;\n\tWLog_INFO(TAG, \"OrderCapabilitySet (length %\" PRIu16 \"):\", length);\n\n\tif (length < 88)\n\t\treturn FALSE;\n\n\tStream_Read(s, terminalDescriptor, 16);         /* terminalDescriptor (16 bytes) */\n\tStream_Read_UINT32(s, pad4OctetsA);             /* pad4OctetsA (4 bytes) */\n\tStream_Read_UINT16(s, desktopSaveXGranularity); /* desktopSaveXGranularity (2 bytes) */\n\tStream_Read_UINT16(s, desktopSaveYGranularity); /* desktopSaveYGranularity (2 bytes) */\n\tStream_Read_UINT16(s, pad2OctetsA);             /* pad2OctetsA (2 bytes) */\n\tStream_Read_UINT16(s, maximumOrderLevel);       /* maximumOrderLevel (2 bytes) */\n\tStream_Read_UINT16(s, numberFonts);             /* numberFonts (2 bytes) */\n\tStream_Read_UINT16(s, orderFlags);              /* orderFlags (2 bytes) */\n\tStream_Read(s, orderSupport, 32);               /* orderSupport (32 bytes) */\n\tStream_Read_UINT16(s, textFlags);               /* textFlags (2 bytes) */\n\tStream_Read_UINT16(s, orderSupportExFlags);     /* orderSupportExFlags (2 bytes) */\n\tStream_Read_UINT32(s, pad4OctetsB);             /* pad4OctetsB (4 bytes) */\n\tStream_Read_UINT32(s, desktopSaveSize);         /* desktopSaveSize (4 bytes) */\n\tStream_Read_UINT16(s, pad2OctetsC);             /* pad2OctetsC (2 bytes) */\n\tStream_Read_UINT16(s, pad2OctetsD);             /* pad2OctetsD (2 bytes) */\n\tStream_Read_UINT16(s, textANSICodePage);        /* textANSICodePage (2 bytes) */\n\tStream_Read_UINT16(s, pad2OctetsE);             /* pad2OctetsE (2 bytes) */\n\tWLog_INFO(TAG, \"\\tpad4OctetsA: 0x%08\" PRIX32 \"\", pad4OctetsA);\n\tWLog_INFO(TAG, \"\\tdesktopSaveXGranularity: 0x%04\" PRIX16 \"\", desktopSaveXGranularity);\n\tWLog_INFO(TAG, \"\\tdesktopSaveYGranularity: 0x%04\" PRIX16 \"\", desktopSaveYGranularity);\n\tWLog_INFO(TAG, \"\\tpad2OctetsA: 0x%04\" PRIX16 \"\", pad2OctetsA);\n\tWLog_INFO(TAG, \"\\tmaximumOrderLevel: 0x%04\" PRIX16 \"\", maximumOrderLevel);\n\tWLog_INFO(TAG, \"\\tnumberFonts: 0x%04\" PRIX16 \"\", numberFonts);\n\tWLog_INFO(TAG, \"\\torderFlags: 0x%04\" PRIX16 \"\", orderFlags);\n\tWLog_INFO(TAG, \"\\torderSupport:\");\n\tWLog_INFO(TAG, \"\\t\\tDSTBLT: %\" PRIu8 \"\", orderSupport[NEG_DSTBLT_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tPATBLT: %\" PRIu8 \"\", orderSupport[NEG_PATBLT_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tSCRBLT: %\" PRIu8 \"\", orderSupport[NEG_SCRBLT_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tMEMBLT: %\" PRIu8 \"\", orderSupport[NEG_MEMBLT_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tMEM3BLT: %\" PRIu8 \"\", orderSupport[NEG_MEM3BLT_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tATEXTOUT: %\" PRIu8 \"\", orderSupport[NEG_ATEXTOUT_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tAEXTTEXTOUT: %\" PRIu8 \"\", orderSupport[NEG_AEXTTEXTOUT_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tDRAWNINEGRID: %\" PRIu8 \"\", orderSupport[NEG_DRAWNINEGRID_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tLINETO: %\" PRIu8 \"\", orderSupport[NEG_LINETO_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tMULTI_DRAWNINEGRID: %\" PRIu8 \"\",\n\t          orderSupport[NEG_MULTI_DRAWNINEGRID_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tOPAQUE_RECT: %\" PRIu8 \"\", orderSupport[NEG_OPAQUE_RECT_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tSAVEBITMAP: %\" PRIu8 \"\", orderSupport[NEG_SAVEBITMAP_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tWTEXTOUT: %\" PRIu8 \"\", orderSupport[NEG_WTEXTOUT_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tMEMBLT_V2: %\" PRIu8 \"\", orderSupport[NEG_MEMBLT_V2_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tMEM3BLT_V2: %\" PRIu8 \"\", orderSupport[NEG_MEM3BLT_V2_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tMULTIDSTBLT: %\" PRIu8 \"\", orderSupport[NEG_MULTIDSTBLT_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tMULTIPATBLT: %\" PRIu8 \"\", orderSupport[NEG_MULTIPATBLT_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tMULTISCRBLT: %\" PRIu8 \"\", orderSupport[NEG_MULTISCRBLT_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tMULTIOPAQUERECT: %\" PRIu8 \"\", orderSupport[NEG_MULTIOPAQUERECT_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tFAST_INDEX: %\" PRIu8 \"\", orderSupport[NEG_FAST_INDEX_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tPOLYGON_SC: %\" PRIu8 \"\", orderSupport[NEG_POLYGON_SC_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tPOLYGON_CB: %\" PRIu8 \"\", orderSupport[NEG_POLYGON_CB_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tPOLYLINE: %\" PRIu8 \"\", orderSupport[NEG_POLYLINE_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tUNUSED23: %\" PRIu8 \"\", orderSupport[NEG_UNUSED23_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tFAST_GLYPH: %\" PRIu8 \"\", orderSupport[NEG_FAST_GLYPH_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tELLIPSE_SC: %\" PRIu8 \"\", orderSupport[NEG_ELLIPSE_SC_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tELLIPSE_CB: %\" PRIu8 \"\", orderSupport[NEG_ELLIPSE_CB_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tGLYPH_INDEX: %\" PRIu8 \"\", orderSupport[NEG_GLYPH_INDEX_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tGLYPH_WEXTTEXTOUT: %\" PRIu8 \"\", orderSupport[NEG_GLYPH_WEXTTEXTOUT_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tGLYPH_WLONGTEXTOUT: %\" PRIu8 \"\",\n\t          orderSupport[NEG_GLYPH_WLONGTEXTOUT_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tGLYPH_WLONGEXTTEXTOUT: %\" PRIu8 \"\",\n\t          orderSupport[NEG_GLYPH_WLONGEXTTEXTOUT_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tUNUSED31: %\" PRIu8 \"\", orderSupport[NEG_UNUSED31_INDEX]);\n\tWLog_INFO(TAG, \"\\ttextFlags: 0x%04\" PRIX16 \"\", textFlags);\n\tWLog_INFO(TAG, \"\\torderSupportExFlags: 0x%04\" PRIX16 \"\", orderSupportExFlags);\n\tWLog_INFO(TAG, \"\\tpad4OctetsB: 0x%08\" PRIX32 \"\", pad4OctetsB);\n\tWLog_INFO(TAG, \"\\tdesktopSaveSize: 0x%08\" PRIX32 \"\", desktopSaveSize);\n\tWLog_INFO(TAG, \"\\tpad2OctetsC: 0x%04\" PRIX16 \"\", pad2OctetsC);\n\tWLog_INFO(TAG, \"\\tpad2OctetsD: 0x%04\" PRIX16 \"\", pad2OctetsD);\n\tWLog_INFO(TAG, \"\\ttextANSICodePage: 0x%04\" PRIX16 \"\", textANSICodePage);\n\tWLog_INFO(TAG, \"\\tpad2OctetsE: 0x%04\" PRIX16 \"\", pad2OctetsE);\n\treturn TRUE;\n}\n#endif\n\n/**\n * Read bitmap cache capability set.\\n\n * @msdn{cc240559}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_bitmap_cache_capability_set(wStream* s, UINT16 length, rdpSettings* settings)\n{\n\tWINPR_UNUSED(settings);\n\tif (length < 40)\n\t\treturn FALSE;\n\n\tStream_Seek_UINT32(s); /* pad1 (4 bytes) */\n\tStream_Seek_UINT32(s); /* pad2 (4 bytes) */\n\tStream_Seek_UINT32(s); /* pad3 (4 bytes) */\n\tStream_Seek_UINT32(s); /* pad4 (4 bytes) */\n\tStream_Seek_UINT32(s); /* pad5 (4 bytes) */\n\tStream_Seek_UINT32(s); /* pad6 (4 bytes) */\n\tStream_Seek_UINT16(s); /* Cache0Entries (2 bytes) */\n\tStream_Seek_UINT16(s); /* Cache0MaximumCellSize (2 bytes) */\n\tStream_Seek_UINT16(s); /* Cache1Entries (2 bytes) */\n\tStream_Seek_UINT16(s); /* Cache1MaximumCellSize (2 bytes) */\n\tStream_Seek_UINT16(s); /* Cache2Entries (2 bytes) */\n\tStream_Seek_UINT16(s); /* Cache2MaximumCellSize (2 bytes) */\n\treturn TRUE;\n}\n\n/**\n * Write bitmap cache capability set.\\n\n * @msdn{cc240559}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_bitmap_cache_capability_set(wStream* s, const rdpSettings* settings)\n{\n\tUINT32 bpp;\n\tsize_t header;\n\tUINT32 size;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 64))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tif (header > UINT16_MAX)\n\t\treturn FALSE;\n\tbpp = (settings->ColorDepth + 7) / 8;\n\tif (bpp > UINT16_MAX)\n\t\treturn FALSE;\n\tStream_Write_UINT32(s, 0); /* pad1 (4 bytes) */\n\tStream_Write_UINT32(s, 0); /* pad2 (4 bytes) */\n\tStream_Write_UINT32(s, 0); /* pad3 (4 bytes) */\n\tStream_Write_UINT32(s, 0); /* pad4 (4 bytes) */\n\tStream_Write_UINT32(s, 0); /* pad5 (4 bytes) */\n\tStream_Write_UINT32(s, 0); /* pad6 (4 bytes) */\n\tsize = bpp * 256;\n\tif (size > UINT16_MAX)\n\t\treturn FALSE;\n\tStream_Write_UINT16(s, 200);  /* Cache0Entries (2 bytes) */\n\tStream_Write_UINT16(s, (UINT16)size); /* Cache0MaximumCellSize (2 bytes) */\n\tsize = bpp * 1024;\n\tif (size > UINT16_MAX)\n\t\treturn FALSE;\n\tStream_Write_UINT16(s, 600);  /* Cache1Entries (2 bytes) */\n\tStream_Write_UINT16(s, (UINT16)size); /* Cache1MaximumCellSize (2 bytes) */\n\tsize = bpp * 4096;\n\tif (size > UINT16_MAX)\n\t\treturn FALSE;\n\tStream_Write_UINT16(s, 1000); /* Cache2Entries (2 bytes) */\n\tStream_Write_UINT16(s, (UINT16)size); /* Cache2MaximumCellSize (2 bytes) */\n\trdp_capability_set_finish(s, (UINT16)header, CAPSET_TYPE_BITMAP_CACHE);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_bitmap_cache_capability_set(wStream* s, UINT16 length)\n{\n\tUINT32 pad1, pad2, pad3;\n\tUINT32 pad4, pad5, pad6;\n\tUINT16 Cache0Entries;\n\tUINT16 Cache0MaximumCellSize;\n\tUINT16 Cache1Entries;\n\tUINT16 Cache1MaximumCellSize;\n\tUINT16 Cache2Entries;\n\tUINT16 Cache2MaximumCellSize;\n\tWLog_INFO(TAG, \"BitmapCacheCapabilitySet (length %\" PRIu16 \"):\", length);\n\n\tif (length < 40)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, pad1);                  /* pad1 (4 bytes) */\n\tStream_Read_UINT32(s, pad2);                  /* pad2 (4 bytes) */\n\tStream_Read_UINT32(s, pad3);                  /* pad3 (4 bytes) */\n\tStream_Read_UINT32(s, pad4);                  /* pad4 (4 bytes) */\n\tStream_Read_UINT32(s, pad5);                  /* pad5 (4 bytes) */\n\tStream_Read_UINT32(s, pad6);                  /* pad6 (4 bytes) */\n\tStream_Read_UINT16(s, Cache0Entries);         /* Cache0Entries (2 bytes) */\n\tStream_Read_UINT16(s, Cache0MaximumCellSize); /* Cache0MaximumCellSize (2 bytes) */\n\tStream_Read_UINT16(s, Cache1Entries);         /* Cache1Entries (2 bytes) */\n\tStream_Read_UINT16(s, Cache1MaximumCellSize); /* Cache1MaximumCellSize (2 bytes) */\n\tStream_Read_UINT16(s, Cache2Entries);         /* Cache2Entries (2 bytes) */\n\tStream_Read_UINT16(s, Cache2MaximumCellSize); /* Cache2MaximumCellSize (2 bytes) */\n\tWLog_INFO(TAG, \"\\tpad1: 0x%08\" PRIX32 \"\", pad1);\n\tWLog_INFO(TAG, \"\\tpad2: 0x%08\" PRIX32 \"\", pad2);\n\tWLog_INFO(TAG, \"\\tpad3: 0x%08\" PRIX32 \"\", pad3);\n\tWLog_INFO(TAG, \"\\tpad4: 0x%08\" PRIX32 \"\", pad4);\n\tWLog_INFO(TAG, \"\\tpad5: 0x%08\" PRIX32 \"\", pad5);\n\tWLog_INFO(TAG, \"\\tpad6: 0x%08\" PRIX32 \"\", pad6);\n\tWLog_INFO(TAG, \"\\tCache0Entries: 0x%04\" PRIX16 \"\", Cache0Entries);\n\tWLog_INFO(TAG, \"\\tCache0MaximumCellSize: 0x%04\" PRIX16 \"\", Cache0MaximumCellSize);\n\tWLog_INFO(TAG, \"\\tCache1Entries: 0x%04\" PRIX16 \"\", Cache1Entries);\n\tWLog_INFO(TAG, \"\\tCache1MaximumCellSize: 0x%04\" PRIX16 \"\", Cache1MaximumCellSize);\n\tWLog_INFO(TAG, \"\\tCache2Entries: 0x%04\" PRIX16 \"\", Cache2Entries);\n\tWLog_INFO(TAG, \"\\tCache2MaximumCellSize: 0x%04\" PRIX16 \"\", Cache2MaximumCellSize);\n\treturn TRUE;\n}\n#endif\n\n/**\n * Read control capability set.\\n\n * @msdn{cc240568}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_control_capability_set(wStream* s, UINT16 length, rdpSettings* settings)\n{\n\tWINPR_UNUSED(settings);\n\tif (length < 12)\n\t\treturn FALSE;\n\n\tStream_Seek_UINT16(s); /* controlFlags (2 bytes) */\n\tStream_Seek_UINT16(s); /* remoteDetachFlag (2 bytes) */\n\tStream_Seek_UINT16(s); /* controlInterest (2 bytes) */\n\tStream_Seek_UINT16(s); /* detachInterest (2 bytes) */\n\treturn TRUE;\n}\n\n/**\n * Write control capability set.\\n\n * @msdn{cc240568}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_control_capability_set(wStream* s, const rdpSettings* settings)\n{\n\tsize_t header;\n\n\tWINPR_UNUSED(settings);\n\tif (!Stream_EnsureRemainingCapacity(s, 32))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tif (header > UINT16_MAX)\n\t\treturn FALSE;\n\tStream_Write_UINT16(s, 0); /* controlFlags (2 bytes) */\n\tStream_Write_UINT16(s, 0); /* remoteDetachFlag (2 bytes) */\n\tStream_Write_UINT16(s, 2); /* controlInterest (2 bytes) */\n\tStream_Write_UINT16(s, 2); /* detachInterest (2 bytes) */\n\trdp_capability_set_finish(s, (UINT16)header, CAPSET_TYPE_CONTROL);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_control_capability_set(wStream* s, UINT16 length)\n{\n\tUINT16 controlFlags;\n\tUINT16 remoteDetachFlag;\n\tUINT16 controlInterest;\n\tUINT16 detachInterest;\n\tWLog_INFO(TAG, \"ControlCapabilitySet (length %\" PRIu16 \"):\", length);\n\n\tif (length < 12)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, controlFlags);     /* controlFlags (2 bytes) */\n\tStream_Read_UINT16(s, remoteDetachFlag); /* remoteDetachFlag (2 bytes) */\n\tStream_Read_UINT16(s, controlInterest);  /* controlInterest (2 bytes) */\n\tStream_Read_UINT16(s, detachInterest);   /* detachInterest (2 bytes) */\n\tWLog_INFO(TAG, \"\\tcontrolFlags: 0x%04\" PRIX16 \"\", controlFlags);\n\tWLog_INFO(TAG, \"\\tremoteDetachFlag: 0x%04\" PRIX16 \"\", remoteDetachFlag);\n\tWLog_INFO(TAG, \"\\tcontrolInterest: 0x%04\" PRIX16 \"\", controlInterest);\n\tWLog_INFO(TAG, \"\\tdetachInterest: 0x%04\" PRIX16 \"\", detachInterest);\n\treturn TRUE;\n}\n#endif\n\n/**\n * Read window activation capability set.\\n\n * @msdn{cc240569}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_window_activation_capability_set(wStream* s, UINT16 length,\n                                                      rdpSettings* settings)\n{\n\tWINPR_UNUSED(settings);\n\tif (length < 12)\n\t\treturn FALSE;\n\n\tStream_Seek_UINT16(s); /* helpKeyFlag (2 bytes) */\n\tStream_Seek_UINT16(s); /* helpKeyIndexFlag (2 bytes) */\n\tStream_Seek_UINT16(s); /* helpExtendedKeyFlag (2 bytes) */\n\tStream_Seek_UINT16(s); /* windowManagerKeyFlag (2 bytes) */\n\treturn TRUE;\n}\n\n/**\n * Write window activation capability set.\\n\n * @msdn{cc240569}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_window_activation_capability_set(wStream* s, const rdpSettings* settings)\n{\n\tsize_t header;\n\n\tWINPR_UNUSED(settings);\n\tif (!Stream_EnsureRemainingCapacity(s, 32))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tif (header > UINT16_MAX)\n\t\treturn FALSE;\n\tStream_Write_UINT16(s, 0); /* helpKeyFlag (2 bytes) */\n\tStream_Write_UINT16(s, 0); /* helpKeyIndexFlag (2 bytes) */\n\tStream_Write_UINT16(s, 0); /* helpExtendedKeyFlag (2 bytes) */\n\tStream_Write_UINT16(s, 0); /* windowManagerKeyFlag (2 bytes) */\n\trdp_capability_set_finish(s, (UINT16)header, CAPSET_TYPE_ACTIVATION);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_window_activation_capability_set(wStream* s, UINT16 length)\n{\n\tUINT16 helpKeyFlag;\n\tUINT16 helpKeyIndexFlag;\n\tUINT16 helpExtendedKeyFlag;\n\tUINT16 windowManagerKeyFlag;\n\tWLog_INFO(TAG, \"WindowActivationCapabilitySet (length %\" PRIu16 \"):\", length);\n\n\tif (length < 12)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, helpKeyFlag);          /* helpKeyFlag (2 bytes) */\n\tStream_Read_UINT16(s, helpKeyIndexFlag);     /* helpKeyIndexFlag (2 bytes) */\n\tStream_Read_UINT16(s, helpExtendedKeyFlag);  /* helpExtendedKeyFlag (2 bytes) */\n\tStream_Read_UINT16(s, windowManagerKeyFlag); /* windowManagerKeyFlag (2 bytes) */\n\tWLog_INFO(TAG, \"\\thelpKeyFlag: 0x%04\" PRIX16 \"\", helpKeyFlag);\n\tWLog_INFO(TAG, \"\\thelpKeyIndexFlag: 0x%04\" PRIX16 \"\", helpKeyIndexFlag);\n\tWLog_INFO(TAG, \"\\thelpExtendedKeyFlag: 0x%04\" PRIX16 \"\", helpExtendedKeyFlag);\n\tWLog_INFO(TAG, \"\\twindowManagerKeyFlag: 0x%04\" PRIX16 \"\", windowManagerKeyFlag);\n\treturn TRUE;\n}\n#endif\n\n/**\n * Read pointer capability set.\\n\n * @msdn{cc240562}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_pointer_capability_set(wStream* s, UINT16 length, rdpSettings* settings)\n{\n\tUINT16 colorPointerFlag;\n\tUINT16 colorPointerCacheSize;\n\tUINT16 pointerCacheSize;\n\n\tif (length < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, colorPointerFlag);      /* colorPointerFlag (2 bytes) */\n\tStream_Read_UINT16(s, colorPointerCacheSize); /* colorPointerCacheSize (2 bytes) */\n\n\t/* pointerCacheSize is optional */\n\tif (length >= 10)\n\t\tStream_Read_UINT16(s, pointerCacheSize); /* pointerCacheSize (2 bytes) */\n\telse\n\t\tpointerCacheSize = 0;\n\n\tif (colorPointerFlag == FALSE)\n\t\tsettings->ColorPointerFlag = FALSE;\n\n\tif (settings->ServerMode)\n\t{\n\t\tsettings->PointerCacheSize = pointerCacheSize;\n\t}\n\n\treturn TRUE;\n}\n\n/**\n * Write pointer capability set.\\n\n * @msdn{cc240562}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_pointer_capability_set(wStream* s, const rdpSettings* settings)\n{\n\tsize_t header;\n\tUINT16 colorPointerFlag;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 32))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tif (header > UINT16_MAX)\n\t\treturn FALSE;\n\tif (settings->PointerCacheSize > UINT16_MAX)\n\t\treturn FALSE;\n\n\tcolorPointerFlag = (settings->ColorPointerFlag) ? 1 : 0;\n\tStream_Write_UINT16(s, colorPointerFlag);           /* colorPointerFlag (2 bytes) */\n\tStream_Write_UINT16(s,\n\t                    (UINT16)settings->PointerCacheSize); /* colorPointerCacheSize (2 bytes) */\n\n\tif (settings->LargePointerFlag)\n\t{\n\t\tStream_Write_UINT16(s, (UINT16)settings->PointerCacheSize); /* pointerCacheSize (2 bytes) */\n\t}\n\n\trdp_capability_set_finish(s, (UINT16)header, CAPSET_TYPE_POINTER);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_pointer_capability_set(wStream* s, UINT16 length)\n{\n\tUINT16 colorPointerFlag;\n\tUINT16 colorPointerCacheSize;\n\tUINT16 pointerCacheSize;\n\n\tif (length < 10)\n\t\treturn FALSE;\n\n\tWLog_INFO(TAG, \"PointerCapabilitySet (length %\" PRIu16 \"):\", length);\n\tStream_Read_UINT16(s, colorPointerFlag);      /* colorPointerFlag (2 bytes) */\n\tStream_Read_UINT16(s, colorPointerCacheSize); /* colorPointerCacheSize (2 bytes) */\n\tStream_Read_UINT16(s, pointerCacheSize);      /* pointerCacheSize (2 bytes) */\n\tWLog_INFO(TAG, \"\\tcolorPointerFlag: 0x%04\" PRIX16 \"\", colorPointerFlag);\n\tWLog_INFO(TAG, \"\\tcolorPointerCacheSize: 0x%04\" PRIX16 \"\", colorPointerCacheSize);\n\tWLog_INFO(TAG, \"\\tpointerCacheSize: 0x%04\" PRIX16 \"\", pointerCacheSize);\n\treturn TRUE;\n}\n#endif\n\n/**\n * Read share capability set.\\n\n * @msdn{cc240570}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_share_capability_set(wStream* s, UINT16 length, rdpSettings* settings)\n{\n\tWINPR_UNUSED(settings);\n\tif (length < 8)\n\t\treturn FALSE;\n\n\tStream_Seek_UINT16(s); /* nodeId (2 bytes) */\n\tStream_Seek_UINT16(s); /* pad2Octets (2 bytes) */\n\treturn TRUE;\n}\n\n/**\n * Write share capability set.\\n\n * @msdn{cc240570}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_share_capability_set(wStream* s, const rdpSettings* settings)\n{\n\tsize_t header;\n\tUINT16 nodeId;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 32))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tif (header > UINT16_MAX)\n\t\treturn FALSE;\n\tnodeId = (settings->ServerMode) ? 0x03EA : 0;\n\tStream_Write_UINT16(s, nodeId); /* nodeId (2 bytes) */\n\tStream_Write_UINT16(s, 0);      /* pad2Octets (2 bytes) */\n\trdp_capability_set_finish(s, (UINT16)header, CAPSET_TYPE_SHARE);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_share_capability_set(wStream* s, UINT16 length)\n{\n\tUINT16 nodeId;\n\tUINT16 pad2Octets;\n\tWLog_INFO(TAG, \"ShareCapabilitySet (length %\" PRIu16 \"):\", length);\n\n\tif (length < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, nodeId);     /* nodeId (2 bytes) */\n\tStream_Read_UINT16(s, pad2Octets); /* pad2Octets (2 bytes) */\n\tWLog_INFO(TAG, \"\\tnodeId: 0x%04\" PRIX16 \"\", nodeId);\n\tWLog_INFO(TAG, \"\\tpad2Octets: 0x%04\" PRIX16 \"\", pad2Octets);\n\treturn TRUE;\n}\n#endif\n\n/**\n * Read color cache capability set.\\n\n * @msdn{cc241564}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_color_cache_capability_set(wStream* s, UINT16 length, rdpSettings* settings)\n{\n\tWINPR_UNUSED(settings);\n\tif (length < 8)\n\t\treturn FALSE;\n\n\tStream_Seek_UINT16(s); /* colorTableCacheSize (2 bytes) */\n\tStream_Seek_UINT16(s); /* pad2Octets (2 bytes) */\n\treturn TRUE;\n}\n\n/**\n * Write color cache capability set.\\n\n * @msdn{cc241564}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_color_cache_capability_set(wStream* s, const rdpSettings* settings)\n{\n\tsize_t header;\n\n\tWINPR_UNUSED(settings);\n\tif (!Stream_EnsureRemainingCapacity(s, 32))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tif (header > UINT16_MAX)\n\t\treturn FALSE;\n\tStream_Write_UINT16(s, 6); /* colorTableCacheSize (2 bytes) */\n\tStream_Write_UINT16(s, 0); /* pad2Octets (2 bytes) */\n\trdp_capability_set_finish(s, (UINT16)header, CAPSET_TYPE_COLOR_CACHE);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_color_cache_capability_set(wStream* s, UINT16 length)\n{\n\tUINT16 colorTableCacheSize;\n\tUINT16 pad2Octets;\n\tWLog_INFO(TAG, \"ColorCacheCapabilitySet (length %\" PRIu16 \"):\", length);\n\n\tif (length < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, colorTableCacheSize); /* colorTableCacheSize (2 bytes) */\n\tStream_Read_UINT16(s, pad2Octets);          /* pad2Octets (2 bytes) */\n\tWLog_INFO(TAG, \"\\tcolorTableCacheSize: 0x%04\" PRIX16 \"\", colorTableCacheSize);\n\tWLog_INFO(TAG, \"\\tpad2Octets: 0x%04\" PRIX16 \"\", pad2Octets);\n\treturn TRUE;\n}\n#endif\n\n/**\n * Read sound capability set.\\n\n * @msdn{cc240552}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_sound_capability_set(wStream* s, UINT16 length, rdpSettings* settings)\n{\n\tUINT16 soundFlags;\n\n\tif (length < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, soundFlags); /* soundFlags (2 bytes) */\n\tStream_Seek_UINT16(s);             /* pad2OctetsA (2 bytes) */\n\tsettings->SoundBeepsEnabled = (soundFlags & SOUND_BEEPS_FLAG) ? TRUE : FALSE;\n\treturn TRUE;\n}\n\n/**\n * Write sound capability set.\\n\n * @msdn{cc240552}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_sound_capability_set(wStream* s, const rdpSettings* settings)\n{\n\tsize_t header;\n\tUINT16 soundFlags;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 32))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tif (header > UINT16_MAX)\n\t\treturn FALSE;\n\tsoundFlags = (settings->SoundBeepsEnabled) ? SOUND_BEEPS_FLAG : 0;\n\tStream_Write_UINT16(s, soundFlags); /* soundFlags (2 bytes) */\n\tStream_Write_UINT16(s, 0);          /* pad2OctetsA (2 bytes) */\n\trdp_capability_set_finish(s, (UINT16)header, CAPSET_TYPE_SOUND);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_sound_capability_set(wStream* s, UINT16 length)\n{\n\tUINT16 soundFlags;\n\tUINT16 pad2OctetsA;\n\tWLog_INFO(TAG, \"SoundCapabilitySet (length %\" PRIu16 \"):\", length);\n\n\tif (length < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, soundFlags);  /* soundFlags (2 bytes) */\n\tStream_Read_UINT16(s, pad2OctetsA); /* pad2OctetsA (2 bytes) */\n\tWLog_INFO(TAG, \"\\tsoundFlags: 0x%04\" PRIX16 \"\", soundFlags);\n\tWLog_INFO(TAG, \"\\tpad2OctetsA: 0x%04\" PRIX16 \"\", pad2OctetsA);\n\treturn TRUE;\n}\n#endif\n\n/**\n * Read input capability set.\\n\n * @msdn{cc240563}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_input_capability_set(wStream* s, UINT16 length, rdpSettings* settings)\n{\n\tUINT16 inputFlags;\n\n\tif (length < 88)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, inputFlags); /* inputFlags (2 bytes) */\n\tStream_Seek_UINT16(s);             /* pad2OctetsA (2 bytes) */\n\n\tif (settings->ServerMode)\n\t{\n\t\tStream_Read_UINT32(s, settings->KeyboardLayout);      /* keyboardLayout (4 bytes) */\n\t\tStream_Read_UINT32(s, settings->KeyboardType);        /* keyboardType (4 bytes) */\n\t\tStream_Read_UINT32(s, settings->KeyboardSubType);     /* keyboardSubType (4 bytes) */\n\t\tStream_Read_UINT32(s, settings->KeyboardFunctionKey); /* keyboardFunctionKeys (4 bytes) */\n\t}\n\telse\n\t{\n\t\tStream_Seek_UINT32(s); /* keyboardLayout (4 bytes) */\n\t\tStream_Seek_UINT32(s); /* keyboardType (4 bytes) */\n\t\tStream_Seek_UINT32(s); /* keyboardSubType (4 bytes) */\n\t\tStream_Seek_UINT32(s); /* keyboardFunctionKeys (4 bytes) */\n\t}\n\n\tStream_Seek(s, 64); /* imeFileName (64 bytes) */\n\n\tif (!settings->ServerMode)\n\t{\n\t\tif (inputFlags & INPUT_FLAG_FASTPATH_INPUT)\n\t\t{\n\t\t\t/* advertised by RDP 5.0 and 5.1 servers */\n\t\t}\n\t\telse if (inputFlags & INPUT_FLAG_FASTPATH_INPUT2)\n\t\t{\n\t\t\t/* advertised by RDP 5.2, 6.0, 6.1 and 7.0 servers */\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* server does not support fastpath input */\n\t\t\tsettings->FastPathInput = FALSE;\n\t\t}\n\n\t\tif (inputFlags & TS_INPUT_FLAG_MOUSE_HWHEEL)\n\t\t\tsettings->HasHorizontalWheel = TRUE;\n\n\t\tif (inputFlags & INPUT_FLAG_UNICODE)\n\t\t\tsettings->UnicodeInput = TRUE;\n\n\t\tif (inputFlags & INPUT_FLAG_MOUSEX)\n\t\t\tsettings->HasExtendedMouseEvent = TRUE;\n\t}\n\n\treturn TRUE;\n}\n\n/**\n * Write input capability set.\\n\n * @msdn{cc240563}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_input_capability_set(wStream* s, const rdpSettings* settings)\n{\n\tsize_t header;\n\tUINT16 inputFlags;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 128))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tif (header > UINT16_MAX)\n\t\treturn FALSE;\n\tinputFlags = INPUT_FLAG_SCANCODES;\n\n\tif (settings->FastPathInput)\n\t{\n\t\tinputFlags |= INPUT_FLAG_FASTPATH_INPUT;\n\t\tinputFlags |= INPUT_FLAG_FASTPATH_INPUT2;\n\t}\n\n\tif (settings->HasHorizontalWheel)\n\t\tinputFlags |= TS_INPUT_FLAG_MOUSE_HWHEEL;\n\n\tif (settings->UnicodeInput)\n\t\tinputFlags |= INPUT_FLAG_UNICODE;\n\n\tif (settings->HasExtendedMouseEvent)\n\t\tinputFlags |= INPUT_FLAG_MOUSEX;\n\n\tStream_Write_UINT16(s, inputFlags);                    /* inputFlags (2 bytes) */\n\tStream_Write_UINT16(s, 0);                             /* pad2OctetsA (2 bytes) */\n\tStream_Write_UINT32(s, settings->KeyboardLayout);      /* keyboardLayout (4 bytes) */\n\tStream_Write_UINT32(s, settings->KeyboardType);        /* keyboardType (4 bytes) */\n\tStream_Write_UINT32(s, settings->KeyboardSubType);     /* keyboardSubType (4 bytes) */\n\tStream_Write_UINT32(s, settings->KeyboardFunctionKey); /* keyboardFunctionKeys (4 bytes) */\n\tStream_Zero(s, 64);                                    /* imeFileName (64 bytes) */\n\trdp_capability_set_finish(s, (UINT16)header, CAPSET_TYPE_INPUT);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_input_capability_set(wStream* s, UINT16 length)\n{\n\tUINT16 inputFlags;\n\tUINT16 pad2OctetsA;\n\tUINT32 keyboardLayout;\n\tUINT32 keyboardType;\n\tUINT32 keyboardSubType;\n\tUINT32 keyboardFunctionKey;\n\tWLog_INFO(TAG, \"InputCapabilitySet (length %\" PRIu16 \")\", length);\n\n\tif (length < 88)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, inputFlags);          /* inputFlags (2 bytes) */\n\tStream_Read_UINT16(s, pad2OctetsA);         /* pad2OctetsA (2 bytes) */\n\tStream_Read_UINT32(s, keyboardLayout);      /* keyboardLayout (4 bytes) */\n\tStream_Read_UINT32(s, keyboardType);        /* keyboardType (4 bytes) */\n\tStream_Read_UINT32(s, keyboardSubType);     /* keyboardSubType (4 bytes) */\n\tStream_Read_UINT32(s, keyboardFunctionKey); /* keyboardFunctionKeys (4 bytes) */\n\tStream_Seek(s, 64);                         /* imeFileName (64 bytes) */\n\tWLog_INFO(TAG, \"\\tinputFlags: 0x%04\" PRIX16 \"\", inputFlags);\n\tWLog_INFO(TAG, \"\\tpad2OctetsA: 0x%04\" PRIX16 \"\", pad2OctetsA);\n\tWLog_INFO(TAG, \"\\tkeyboardLayout: 0x%08\" PRIX32 \"\", keyboardLayout);\n\tWLog_INFO(TAG, \"\\tkeyboardType: 0x%08\" PRIX32 \"\", keyboardType);\n\tWLog_INFO(TAG, \"\\tkeyboardSubType: 0x%08\" PRIX32 \"\", keyboardSubType);\n\tWLog_INFO(TAG, \"\\tkeyboardFunctionKey: 0x%08\" PRIX32 \"\", keyboardFunctionKey);\n\treturn TRUE;\n}\n#endif\n\n/**\n * Read font capability set.\\n\n * @msdn{cc240571}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_font_capability_set(wStream* s, UINT16 length, rdpSettings* settings)\n{\n\tWINPR_UNUSED(settings);\n\tif (length > 4)\n\t\tStream_Seek_UINT16(s); /* fontSupportFlags (2 bytes) */\n\n\tif (length > 6)\n\t\tStream_Seek_UINT16(s); /* pad2Octets (2 bytes) */\n\n\treturn TRUE;\n}\n\n/**\n * Write font capability set.\\n\n * @msdn{cc240571}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_font_capability_set(wStream* s, const rdpSettings* settings)\n{\n\tsize_t header;\n\n\tWINPR_UNUSED(settings);\n\tif (!Stream_EnsureRemainingCapacity(s, 32))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tif (header > UINT16_MAX)\n\t\treturn FALSE;\n\tStream_Write_UINT16(s, FONTSUPPORT_FONTLIST); /* fontSupportFlags (2 bytes) */\n\tStream_Write_UINT16(s, 0);                    /* pad2Octets (2 bytes) */\n\trdp_capability_set_finish(s, (UINT16)header, CAPSET_TYPE_FONT);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_font_capability_set(wStream* s, UINT16 length)\n{\n\tUINT16 fontSupportFlags = 0;\n\tUINT16 pad2Octets = 0;\n\tWLog_INFO(TAG, \"FontCapabilitySet (length %\" PRIu16 \"):\", length);\n\n\tif (length > 4)\n\t\tStream_Read_UINT16(s, fontSupportFlags); /* fontSupportFlags (2 bytes) */\n\n\tif (length > 6)\n\t\tStream_Read_UINT16(s, pad2Octets); /* pad2Octets (2 bytes) */\n\n\tWLog_INFO(TAG, \"\\tfontSupportFlags: 0x%04\" PRIX16 \"\", fontSupportFlags);\n\tWLog_INFO(TAG, \"\\tpad2Octets: 0x%04\" PRIX16 \"\", pad2Octets);\n\treturn TRUE;\n}\n#endif\n\n/**\n * Read brush capability set.\n * @msdn{cc240564}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_brush_capability_set(wStream* s, UINT16 length, rdpSettings* settings)\n{\n\tWINPR_UNUSED(settings);\n\tif (length < 8)\n\t\treturn FALSE;\n\n\tStream_Seek_UINT32(s); /* brushSupportLevel (4 bytes) */\n\treturn TRUE;\n}\n\n/**\n * Write brush capability set.\\n\n * @msdn{cc240564}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_brush_capability_set(wStream* s, const rdpSettings* settings)\n{\n\tsize_t header;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 32))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tif (header > UINT16_MAX)\n\t\treturn FALSE;\n\tStream_Write_UINT32(s, settings->BrushSupportLevel); /* brushSupportLevel (4 bytes) */\n\trdp_capability_set_finish(s, (UINT16)header, CAPSET_TYPE_BRUSH);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_brush_capability_set(wStream* s, UINT16 length)\n{\n\tUINT32 brushSupportLevel;\n\tWLog_INFO(TAG, \"BrushCapabilitySet (length %\" PRIu16 \"):\", length);\n\n\tif (length < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, brushSupportLevel); /* brushSupportLevel (4 bytes) */\n\tWLog_INFO(TAG, \"\\tbrushSupportLevel: 0x%08\" PRIX32 \"\", brushSupportLevel);\n\treturn TRUE;\n}\n#endif\n\n/**\n * Read cache definition (glyph).\\n\n * @msdn{cc240566}\n * @param s stream\n */\nstatic void rdp_read_cache_definition(wStream* s, GLYPH_CACHE_DEFINITION* cache_definition)\n{\n\tStream_Read_UINT16(s, cache_definition->cacheEntries); /* cacheEntries (2 bytes) */\n\tStream_Read_UINT16(s,\n\t                   cache_definition->cacheMaximumCellSize); /* cacheMaximumCellSize (2 bytes) */\n}\n\n/**\n * Write cache definition (glyph).\\n\n * @msdn{cc240566}\n * @param s stream\n */\nstatic void rdp_write_cache_definition(wStream* s, GLYPH_CACHE_DEFINITION* cache_definition)\n{\n\tStream_Write_UINT16(s, cache_definition->cacheEntries); /* cacheEntries (2 bytes) */\n\tStream_Write_UINT16(\n\t    s, cache_definition->cacheMaximumCellSize); /* cacheMaximumCellSize (2 bytes) */\n}\n\n/**\n * Read glyph cache capability set.\\n\n * @msdn{cc240565}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_glyph_cache_capability_set(wStream* s, UINT16 length, rdpSettings* settings)\n{\n\tif (length < 52)\n\t\treturn FALSE;\n\n\t/* glyphCache (40 bytes) */\n\trdp_read_cache_definition(s, &(settings->GlyphCache[0])); /* glyphCache0 (4 bytes) */\n\trdp_read_cache_definition(s, &(settings->GlyphCache[1])); /* glyphCache1 (4 bytes) */\n\trdp_read_cache_definition(s, &(settings->GlyphCache[2])); /* glyphCache2 (4 bytes) */\n\trdp_read_cache_definition(s, &(settings->GlyphCache[3])); /* glyphCache3 (4 bytes) */\n\trdp_read_cache_definition(s, &(settings->GlyphCache[4])); /* glyphCache4 (4 bytes) */\n\trdp_read_cache_definition(s, &(settings->GlyphCache[5])); /* glyphCache5 (4 bytes) */\n\trdp_read_cache_definition(s, &(settings->GlyphCache[6])); /* glyphCache6 (4 bytes) */\n\trdp_read_cache_definition(s, &(settings->GlyphCache[7])); /* glyphCache7 (4 bytes) */\n\trdp_read_cache_definition(s, &(settings->GlyphCache[8])); /* glyphCache8 (4 bytes) */\n\trdp_read_cache_definition(s, &(settings->GlyphCache[9])); /* glyphCache9 (4 bytes) */\n\trdp_read_cache_definition(s, settings->FragCache);        /* fragCache (4 bytes) */\n\tStream_Read_UINT16(s, settings->GlyphSupportLevel);       /* glyphSupportLevel (2 bytes) */\n\tStream_Seek_UINT16(s);                                    /* pad2Octets (2 bytes) */\n\treturn TRUE;\n}\n\n/**\n * Write glyph cache capability set.\\n\n * @msdn{cc240565}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_glyph_cache_capability_set(wStream* s, const rdpSettings* settings)\n{\n\tsize_t header;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 64))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tif (header > UINT16_MAX)\n\t\treturn FALSE;\n\tif (settings->GlyphSupportLevel > UINT16_MAX)\n\t\treturn FALSE;\n\t/* glyphCache (40 bytes) */\n\trdp_write_cache_definition(s, &(settings->GlyphCache[0])); /* glyphCache0 (4 bytes) */\n\trdp_write_cache_definition(s, &(settings->GlyphCache[1])); /* glyphCache1 (4 bytes) */\n\trdp_write_cache_definition(s, &(settings->GlyphCache[2])); /* glyphCache2 (4 bytes) */\n\trdp_write_cache_definition(s, &(settings->GlyphCache[3])); /* glyphCache3 (4 bytes) */\n\trdp_write_cache_definition(s, &(settings->GlyphCache[4])); /* glyphCache4 (4 bytes) */\n\trdp_write_cache_definition(s, &(settings->GlyphCache[5])); /* glyphCache5 (4 bytes) */\n\trdp_write_cache_definition(s, &(settings->GlyphCache[6])); /* glyphCache6 (4 bytes) */\n\trdp_write_cache_definition(s, &(settings->GlyphCache[7])); /* glyphCache7 (4 bytes) */\n\trdp_write_cache_definition(s, &(settings->GlyphCache[8])); /* glyphCache8 (4 bytes) */\n\trdp_write_cache_definition(s, &(settings->GlyphCache[9])); /* glyphCache9 (4 bytes) */\n\trdp_write_cache_definition(s, settings->FragCache);        /* fragCache (4 bytes) */\n\tStream_Write_UINT16(s, (UINT16)settings->GlyphSupportLevel); /* glyphSupportLevel (2 bytes) */\n\tStream_Write_UINT16(s, 0);                                 /* pad2Octets (2 bytes) */\n\trdp_capability_set_finish(s, (UINT16)header, CAPSET_TYPE_GLYPH_CACHE);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_glyph_cache_capability_set(wStream* s, UINT16 length)\n{\n\tGLYPH_CACHE_DEFINITION glyphCache[10];\n\tGLYPH_CACHE_DEFINITION fragCache;\n\tUINT16 glyphSupportLevel;\n\tUINT16 pad2Octets;\n\tWLog_INFO(TAG, \"GlyphCacheCapabilitySet (length %\" PRIu16 \"):\", length);\n\n\tif (length < 52)\n\t\treturn FALSE;\n\n\t/* glyphCache (40 bytes) */\n\trdp_read_cache_definition(s, &glyphCache[0]); /* glyphCache0 (4 bytes) */\n\trdp_read_cache_definition(s, &glyphCache[1]); /* glyphCache1 (4 bytes) */\n\trdp_read_cache_definition(s, &glyphCache[2]); /* glyphCache2 (4 bytes) */\n\trdp_read_cache_definition(s, &glyphCache[3]); /* glyphCache3 (4 bytes) */\n\trdp_read_cache_definition(s, &glyphCache[4]); /* glyphCache4 (4 bytes) */\n\trdp_read_cache_definition(s, &glyphCache[5]); /* glyphCache5 (4 bytes) */\n\trdp_read_cache_definition(s, &glyphCache[6]); /* glyphCache6 (4 bytes) */\n\trdp_read_cache_definition(s, &glyphCache[7]); /* glyphCache7 (4 bytes) */\n\trdp_read_cache_definition(s, &glyphCache[8]); /* glyphCache8 (4 bytes) */\n\trdp_read_cache_definition(s, &glyphCache[9]); /* glyphCache9 (4 bytes) */\n\trdp_read_cache_definition(s, &fragCache);     /* fragCache (4 bytes) */\n\tStream_Read_UINT16(s, glyphSupportLevel);     /* glyphSupportLevel (2 bytes) */\n\tStream_Read_UINT16(s, pad2Octets);            /* pad2Octets (2 bytes) */\n\tWLog_INFO(TAG, \"\\tglyphCache0: Entries: %\" PRIu16 \" MaximumCellSize: %\" PRIu16 \"\",\n\t          glyphCache[0].cacheEntries, glyphCache[0].cacheMaximumCellSize);\n\tWLog_INFO(TAG, \"\\tglyphCache1: Entries: %\" PRIu16 \" MaximumCellSize: %\" PRIu16 \"\",\n\t          glyphCache[1].cacheEntries, glyphCache[1].cacheMaximumCellSize);\n\tWLog_INFO(TAG, \"\\tglyphCache2: Entries: %\" PRIu16 \" MaximumCellSize: %\" PRIu16 \"\",\n\t          glyphCache[2].cacheEntries, glyphCache[2].cacheMaximumCellSize);\n\tWLog_INFO(TAG, \"\\tglyphCache3: Entries: %\" PRIu16 \" MaximumCellSize: %\" PRIu16 \"\",\n\t          glyphCache[3].cacheEntries, glyphCache[3].cacheMaximumCellSize);\n\tWLog_INFO(TAG, \"\\tglyphCache4: Entries: %\" PRIu16 \" MaximumCellSize: %\" PRIu16 \"\",\n\t          glyphCache[4].cacheEntries, glyphCache[4].cacheMaximumCellSize);\n\tWLog_INFO(TAG, \"\\tglyphCache5: Entries: %\" PRIu16 \" MaximumCellSize: %\" PRIu16 \"\",\n\t          glyphCache[5].cacheEntries, glyphCache[5].cacheMaximumCellSize);\n\tWLog_INFO(TAG, \"\\tglyphCache6: Entries: %\" PRIu16 \" MaximumCellSize: %\" PRIu16 \"\",\n\t          glyphCache[6].cacheEntries, glyphCache[6].cacheMaximumCellSize);\n\tWLog_INFO(TAG, \"\\tglyphCache7: Entries: %\" PRIu16 \" MaximumCellSize: %\" PRIu16 \"\",\n\t          glyphCache[7].cacheEntries, glyphCache[7].cacheMaximumCellSize);\n\tWLog_INFO(TAG, \"\\tglyphCache8: Entries: %\" PRIu16 \" MaximumCellSize: %\" PRIu16 \"\",\n\t          glyphCache[8].cacheEntries, glyphCache[8].cacheMaximumCellSize);\n\tWLog_INFO(TAG, \"\\tglyphCache9: Entries: %\" PRIu16 \" MaximumCellSize: %\" PRIu16 \"\",\n\t          glyphCache[9].cacheEntries, glyphCache[9].cacheMaximumCellSize);\n\tWLog_INFO(TAG, \"\\tfragCache: Entries: %\" PRIu16 \" MaximumCellSize: %\" PRIu16 \"\",\n\t          fragCache.cacheEntries, fragCache.cacheMaximumCellSize);\n\tWLog_INFO(TAG, \"\\tglyphSupportLevel: 0x%04\" PRIX16 \"\", glyphSupportLevel);\n\tWLog_INFO(TAG, \"\\tpad2Octets: 0x%04\" PRIX16 \"\", pad2Octets);\n\treturn TRUE;\n}\n#endif\n\n/**\n * Read offscreen bitmap cache capability set.\\n\n * @msdn{cc240550}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_offscreen_bitmap_cache_capability_set(wStream* s, UINT16 length,\n                                                           rdpSettings* settings)\n{\n\tUINT32 offscreenSupportLevel;\n\n\tif (length < 12)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, offscreenSupportLevel);           /* offscreenSupportLevel (4 bytes) */\n\tStream_Read_UINT16(s, settings->OffscreenCacheSize);    /* offscreenCacheSize (2 bytes) */\n\tStream_Read_UINT16(s, settings->OffscreenCacheEntries); /* offscreenCacheEntries (2 bytes) */\n\n\tif (offscreenSupportLevel & TRUE)\n\t\tsettings->OffscreenSupportLevel = TRUE;\n\n\treturn TRUE;\n}\n\n/**\n * Write offscreen bitmap cache capability set.\\n\n * @msdn{cc240550}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_offscreen_bitmap_cache_capability_set(wStream* s, const rdpSettings* settings)\n{\n\tsize_t header;\n\tUINT32 offscreenSupportLevel = 0x00;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 32))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tif (header > UINT16_MAX)\n\t\treturn FALSE;\n\tif (settings->OffscreenSupportLevel)\n\t{\n\t\toffscreenSupportLevel = 0x01;\n\t\tStream_Write_UINT32(s, offscreenSupportLevel);        /* offscreenSupportLevel (4 bytes) */\n\t\tStream_Write_UINT16(s, settings->OffscreenCacheSize); /* offscreenCacheSize (2 bytes) */\n\t\tStream_Write_UINT16(s,\n\t\t                    settings->OffscreenCacheEntries); /* offscreenCacheEntries (2 bytes) */\n\t}\n\telse\n\t\tStream_Zero(s, 8);\n\n\trdp_capability_set_finish(s, (UINT16)header, CAPSET_TYPE_OFFSCREEN_CACHE);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_offscreen_bitmap_cache_capability_set(wStream* s, UINT16 length)\n{\n\tUINT32 offscreenSupportLevel;\n\tUINT16 offscreenCacheSize;\n\tUINT16 offscreenCacheEntries;\n\tWLog_INFO(TAG, \"OffscreenBitmapCacheCapabilitySet (length %\" PRIu16 \"):\", length);\n\n\tif (length < 12)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, offscreenSupportLevel); /* offscreenSupportLevel (4 bytes) */\n\tStream_Read_UINT16(s, offscreenCacheSize);    /* offscreenCacheSize (2 bytes) */\n\tStream_Read_UINT16(s, offscreenCacheEntries); /* offscreenCacheEntries (2 bytes) */\n\tWLog_INFO(TAG, \"\\toffscreenSupportLevel: 0x%08\" PRIX32 \"\", offscreenSupportLevel);\n\tWLog_INFO(TAG, \"\\toffscreenCacheSize: 0x%04\" PRIX16 \"\", offscreenCacheSize);\n\tWLog_INFO(TAG, \"\\toffscreenCacheEntries: 0x%04\" PRIX16 \"\", offscreenCacheEntries);\n\treturn TRUE;\n}\n#endif\n\n/**\n * Read bitmap cache host support capability set.\\n\n * @msdn{cc240557}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_bitmap_cache_host_support_capability_set(wStream* s, UINT16 length,\n                                                              rdpSettings* settings)\n{\n\tBYTE cacheVersion;\n\n\tif (length < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, cacheVersion); /* cacheVersion (1 byte) */\n\tStream_Seek_UINT8(s);               /* pad1 (1 byte) */\n\tStream_Seek_UINT16(s);              /* pad2 (2 bytes) */\n\n\tif (cacheVersion & BITMAP_CACHE_V2)\n\t\tsettings->BitmapCachePersistEnabled = TRUE;\n\n\treturn TRUE;\n}\n\n/**\n * Write bitmap cache host support capability set.\\n\n * @msdn{cc240557}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_bitmap_cache_host_support_capability_set(wStream* s,\n                                                               const rdpSettings* settings)\n{\n\tsize_t header;\n\n\tWINPR_UNUSED(settings);\n\tif (!Stream_EnsureRemainingCapacity(s, 32))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tif (header > UINT16_MAX)\n\t\treturn FALSE;\n\tStream_Write_UINT8(s, BITMAP_CACHE_V2); /* cacheVersion (1 byte) */\n\tStream_Write_UINT8(s, 0);               /* pad1 (1 byte) */\n\tStream_Write_UINT16(s, 0);              /* pad2 (2 bytes) */\n\trdp_capability_set_finish(s, (UINT16)header, CAPSET_TYPE_BITMAP_CACHE_HOST_SUPPORT);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_bitmap_cache_host_support_capability_set(wStream* s, UINT16 length)\n{\n\tBYTE cacheVersion;\n\tBYTE pad1;\n\tUINT16 pad2;\n\tWLog_INFO(TAG, \"BitmapCacheHostSupportCapabilitySet (length %\" PRIu16 \"):\", length);\n\n\tif (length < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, cacheVersion); /* cacheVersion (1 byte) */\n\tStream_Read_UINT8(s, pad1);         /* pad1 (1 byte) */\n\tStream_Read_UINT16(s, pad2);        /* pad2 (2 bytes) */\n\tWLog_INFO(TAG, \"\\tcacheVersion: 0x%02\" PRIX8 \"\", cacheVersion);\n\tWLog_INFO(TAG, \"\\tpad1: 0x%02\" PRIX8 \"\", pad1);\n\tWLog_INFO(TAG, \"\\tpad2: 0x%04\" PRIX16 \"\", pad2);\n\treturn TRUE;\n}\n\nstatic void rdp_read_bitmap_cache_cell_info(wStream* s, BITMAP_CACHE_V2_CELL_INFO* cellInfo)\n{\n\tUINT32 info;\n\t/**\n\t * numEntries is in the first 31 bits, while the last bit (k)\n\t * is used to indicate a persistent bitmap cache.\n\t */\n\tStream_Read_UINT32(s, info);\n\tcellInfo->numEntries = (info & 0x7FFFFFFF);\n\tcellInfo->persistent = (info & 0x80000000) ? 1 : 0;\n}\n#endif\n\nstatic void rdp_write_bitmap_cache_cell_info(wStream* s, BITMAP_CACHE_V2_CELL_INFO* cellInfo)\n{\n\tUINT32 info;\n\t/**\n\t * numEntries is in the first 31 bits, while the last bit (k)\n\t * is used to indicate a persistent bitmap cache.\n\t */\n\tinfo = (cellInfo->numEntries | (cellInfo->persistent << 31));\n\tStream_Write_UINT32(s, info);\n}\n\n/**\n * Read bitmap cache v2 capability set.\\n\n * @msdn{cc240560}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_bitmap_cache_v2_capability_set(wStream* s, UINT16 length,\n                                                    rdpSettings* settings)\n{\n\tWINPR_UNUSED(settings);\n\tif (length < 40)\n\t\treturn FALSE;\n\n\tStream_Seek_UINT16(s); /* cacheFlags (2 bytes) */\n\tStream_Seek_UINT8(s);  /* pad2 (1 byte) */\n\tStream_Seek_UINT8(s);  /* numCellCaches (1 byte) */\n\tStream_Seek(s, 4);     /* bitmapCache0CellInfo (4 bytes) */\n\tStream_Seek(s, 4);     /* bitmapCache1CellInfo (4 bytes) */\n\tStream_Seek(s, 4);     /* bitmapCache2CellInfo (4 bytes) */\n\tStream_Seek(s, 4);     /* bitmapCache3CellInfo (4 bytes) */\n\tStream_Seek(s, 4);     /* bitmapCache4CellInfo (4 bytes) */\n\tStream_Seek(s, 12);    /* pad3 (12 bytes) */\n\treturn TRUE;\n}\n\n/**\n * Write bitmap cache v2 capability set.\\n\n * @msdn{cc240560}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_bitmap_cache_v2_capability_set(wStream* s, const rdpSettings* settings)\n{\n\tsize_t header;\n\tUINT16 cacheFlags;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 64))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tcacheFlags = ALLOW_CACHE_WAITING_LIST_FLAG;\n\n\tif (settings->BitmapCachePersistEnabled)\n\t\tcacheFlags |= PERSISTENT_KEYS_EXPECTED_FLAG;\n\n\tStream_Write_UINT16(s, cacheFlags);                     /* cacheFlags (2 bytes) */\n\tStream_Write_UINT8(s, 0);                               /* pad2 (1 byte) */\n\tStream_Write_UINT8(s, settings->BitmapCacheV2NumCells); /* numCellCaches (1 byte) */\n\trdp_write_bitmap_cache_cell_info(\n\t    s, &settings->BitmapCacheV2CellInfo[0]); /* bitmapCache0CellInfo (4 bytes) */\n\trdp_write_bitmap_cache_cell_info(\n\t    s, &settings->BitmapCacheV2CellInfo[1]); /* bitmapCache1CellInfo (4 bytes) */\n\trdp_write_bitmap_cache_cell_info(\n\t    s, &settings->BitmapCacheV2CellInfo[2]); /* bitmapCache2CellInfo (4 bytes) */\n\trdp_write_bitmap_cache_cell_info(\n\t    s, &settings->BitmapCacheV2CellInfo[3]); /* bitmapCache3CellInfo (4 bytes) */\n\trdp_write_bitmap_cache_cell_info(\n\t    s, &settings->BitmapCacheV2CellInfo[4]); /* bitmapCache4CellInfo (4 bytes) */\n\tStream_Zero(s, 12);                          /* pad3 (12 bytes) */\n\trdp_capability_set_finish(s, header, CAPSET_TYPE_BITMAP_CACHE_V2);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_bitmap_cache_v2_capability_set(wStream* s, UINT16 length)\n{\n\tUINT16 cacheFlags;\n\tBYTE pad2;\n\tBYTE numCellCaches;\n\tBITMAP_CACHE_V2_CELL_INFO bitmapCacheV2CellInfo[5];\n\tWLog_INFO(TAG, \"BitmapCacheV2CapabilitySet (length %\" PRIu16 \"):\", length);\n\n\tif (length < 40)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, cacheFlags);   /* cacheFlags (2 bytes) */\n\tStream_Read_UINT8(s, pad2);          /* pad2 (1 byte) */\n\tStream_Read_UINT8(s, numCellCaches); /* numCellCaches (1 byte) */\n\trdp_read_bitmap_cache_cell_info(s,\n\t                                &bitmapCacheV2CellInfo[0]); /* bitmapCache0CellInfo (4 bytes) */\n\trdp_read_bitmap_cache_cell_info(s,\n\t                                &bitmapCacheV2CellInfo[1]); /* bitmapCache1CellInfo (4 bytes) */\n\trdp_read_bitmap_cache_cell_info(s,\n\t                                &bitmapCacheV2CellInfo[2]); /* bitmapCache2CellInfo (4 bytes) */\n\trdp_read_bitmap_cache_cell_info(s,\n\t                                &bitmapCacheV2CellInfo[3]); /* bitmapCache3CellInfo (4 bytes) */\n\trdp_read_bitmap_cache_cell_info(s,\n\t                                &bitmapCacheV2CellInfo[4]); /* bitmapCache4CellInfo (4 bytes) */\n\tStream_Seek(s, 12);                                         /* pad3 (12 bytes) */\n\tWLog_INFO(TAG, \"\\tcacheFlags: 0x%04\" PRIX16 \"\", cacheFlags);\n\tWLog_INFO(TAG, \"\\tpad2: 0x%02\" PRIX8 \"\", pad2);\n\tWLog_INFO(TAG, \"\\tnumCellCaches: 0x%02\" PRIX8 \"\", numCellCaches);\n\tWLog_INFO(TAG, \"\\tbitmapCache0CellInfo: numEntries: %\" PRIu32 \" persistent: %\" PRId32 \"\",\n\t          bitmapCacheV2CellInfo[0].numEntries, bitmapCacheV2CellInfo[0].persistent);\n\tWLog_INFO(TAG, \"\\tbitmapCache1CellInfo: numEntries: %\" PRIu32 \" persistent: %\" PRId32 \"\",\n\t          bitmapCacheV2CellInfo[1].numEntries, bitmapCacheV2CellInfo[1].persistent);\n\tWLog_INFO(TAG, \"\\tbitmapCache2CellInfo: numEntries: %\" PRIu32 \" persistent: %\" PRId32 \"\",\n\t          bitmapCacheV2CellInfo[2].numEntries, bitmapCacheV2CellInfo[2].persistent);\n\tWLog_INFO(TAG, \"\\tbitmapCache3CellInfo: numEntries: %\" PRIu32 \" persistent: %\" PRId32 \"\",\n\t          bitmapCacheV2CellInfo[3].numEntries, bitmapCacheV2CellInfo[3].persistent);\n\tWLog_INFO(TAG, \"\\tbitmapCache4CellInfo: numEntries: %\" PRIu32 \" persistent: %\" PRId32 \"\",\n\t          bitmapCacheV2CellInfo[4].numEntries, bitmapCacheV2CellInfo[4].persistent);\n\treturn TRUE;\n}\n#endif\n\n/**\n * Read virtual channel capability set.\\n\n * @msdn{cc240551}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_virtual_channel_capability_set(wStream* s, UINT16 length,\n                                                    rdpSettings* settings)\n{\n\tUINT32 flags;\n\tUINT32 VCChunkSize;\n\n\tif (length < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, flags); /* flags (4 bytes) */\n\n\tif (length > 8)\n\t\tStream_Read_UINT32(s, VCChunkSize); /* VCChunkSize (4 bytes) */\n\telse\n\t\tVCChunkSize = 1600;\n\n\tif (settings->ServerMode != TRUE)\n\t\tsettings->VirtualChannelChunkSize = VCChunkSize;\n\n\treturn TRUE;\n}\n\n/**\n * Write virtual channel capability set.\\n\n * @msdn{cc240551}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_virtual_channel_capability_set(wStream* s, const rdpSettings* settings)\n{\n\tsize_t header;\n\tUINT32 flags;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 32))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tflags = VCCAPS_NO_COMPR;\n\tStream_Write_UINT32(s, flags);                             /* flags (4 bytes) */\n\tStream_Write_UINT32(s, settings->VirtualChannelChunkSize); /* VCChunkSize (4 bytes) */\n\trdp_capability_set_finish(s, header, CAPSET_TYPE_VIRTUAL_CHANNEL);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_virtual_channel_capability_set(wStream* s, UINT16 length)\n{\n\tUINT32 flags;\n\tUINT32 VCChunkSize;\n\tWLog_INFO(TAG, \"VirtualChannelCapabilitySet (length %\" PRIu16 \"):\", length);\n\n\tif (length < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, flags); /* flags (4 bytes) */\n\n\tif (length > 8)\n\t\tStream_Read_UINT32(s, VCChunkSize); /* VCChunkSize (4 bytes) */\n\telse\n\t\tVCChunkSize = 1600;\n\n\tWLog_INFO(TAG, \"\\tflags: 0x%08\" PRIX32 \"\", flags);\n\tWLog_INFO(TAG, \"\\tVCChunkSize: 0x%08\" PRIX32 \"\", VCChunkSize);\n\treturn TRUE;\n}\n#endif\n\n/**\n * Read drawn nine grid cache capability set.\\n\n * @msdn{cc241565}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_draw_nine_grid_cache_capability_set(wStream* s, UINT16 length,\n                                                         rdpSettings* settings)\n{\n\tUINT32 drawNineGridSupportLevel;\n\n\tif (length < 12)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, drawNineGridSupportLevel);        /* drawNineGridSupportLevel (4 bytes) */\n\tStream_Read_UINT16(s, settings->DrawNineGridCacheSize); /* drawNineGridCacheSize (2 bytes) */\n\tStream_Read_UINT16(s,\n\t                   settings->DrawNineGridCacheEntries); /* drawNineGridCacheEntries (2 bytes) */\n\n\tif ((drawNineGridSupportLevel & DRAW_NINEGRID_SUPPORTED) ||\n\t    (drawNineGridSupportLevel & DRAW_NINEGRID_SUPPORTED_V2))\n\t\tsettings->DrawNineGridEnabled = TRUE;\n\n\treturn TRUE;\n}\n\n/**\n * Write drawn nine grid cache capability set.\\n\n * @msdn{cc241565}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_draw_nine_grid_cache_capability_set(wStream* s, const rdpSettings* settings)\n{\n\tsize_t header;\n\tUINT32 drawNineGridSupportLevel;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 32))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tdrawNineGridSupportLevel =\n\t    (settings->DrawNineGridEnabled) ? DRAW_NINEGRID_SUPPORTED_V2 : DRAW_NINEGRID_NO_SUPPORT;\n\tStream_Write_UINT32(s, drawNineGridSupportLevel); /* drawNineGridSupportLevel (4 bytes) */\n\tStream_Write_UINT16(s, settings->DrawNineGridCacheSize); /* drawNineGridCacheSize (2 bytes) */\n\tStream_Write_UINT16(\n\t    s, settings->DrawNineGridCacheEntries); /* drawNineGridCacheEntries (2 bytes) */\n\trdp_capability_set_finish(s, header, CAPSET_TYPE_DRAW_NINE_GRID_CACHE);\n\treturn TRUE;\n}\n\nstatic void rdp_write_gdiplus_cache_entries(wStream* s, UINT16 gce, UINT16 bce, UINT16 pce,\n                                            UINT16 ice, UINT16 ace)\n{\n\tStream_Write_UINT16(s, gce); /* gdipGraphicsCacheEntries (2 bytes) */\n\tStream_Write_UINT16(s, bce); /* gdipBrushCacheEntries (2 bytes) */\n\tStream_Write_UINT16(s, pce); /* gdipPenCacheEntries (2 bytes) */\n\tStream_Write_UINT16(s, ice); /* gdipImageCacheEntries (2 bytes) */\n\tStream_Write_UINT16(s, ace); /* gdipImageAttributesCacheEntries (2 bytes) */\n}\n\nstatic void rdp_write_gdiplus_cache_chunk_size(wStream* s, UINT16 gccs, UINT16 obccs, UINT16 opccs,\n                                               UINT16 oiaccs)\n{\n\tStream_Write_UINT16(s, gccs);   /* gdipGraphicsCacheChunkSize (2 bytes) */\n\tStream_Write_UINT16(s, obccs);  /* gdipObjectBrushCacheChunkSize (2 bytes) */\n\tStream_Write_UINT16(s, opccs);  /* gdipObjectPenCacheChunkSize (2 bytes) */\n\tStream_Write_UINT16(s, oiaccs); /* gdipObjectImageAttributesCacheChunkSize (2 bytes) */\n}\n\nstatic void rdp_write_gdiplus_image_cache_properties(wStream* s, UINT16 oiccs, UINT16 oicts,\n                                                     UINT16 oicms)\n{\n\tStream_Write_UINT16(s, oiccs); /* gdipObjectImageCacheChunkSize (2 bytes) */\n\tStream_Write_UINT16(s, oicts); /* gdipObjectImageCacheTotalSize (2 bytes) */\n\tStream_Write_UINT16(s, oicms); /* gdipObjectImageCacheMaxSize (2 bytes) */\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_draw_nine_grid_cache_capability_set(wStream* s, UINT16 length)\n{\n\tUINT32 drawNineGridSupportLevel;\n\tUINT16 DrawNineGridCacheSize;\n\tUINT16 DrawNineGridCacheEntries;\n\tWLog_INFO(TAG, \"DrawNineGridCacheCapabilitySet (length %\" PRIu16 \"):\", length);\n\n\tif (length < 12)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, drawNineGridSupportLevel); /* drawNineGridSupportLevel (4 bytes) */\n\tStream_Read_UINT16(s, DrawNineGridCacheSize);    /* drawNineGridCacheSize (2 bytes) */\n\tStream_Read_UINT16(s, DrawNineGridCacheEntries); /* drawNineGridCacheEntries (2 bytes) */\n\treturn TRUE;\n}\n#endif\n\n/**\n * Read GDI+ cache capability set.\\n\n * @msdn{cc241566}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_draw_gdiplus_cache_capability_set(wStream* s, UINT16 length,\n                                                       rdpSettings* settings)\n{\n\tUINT32 drawGDIPlusSupportLevel;\n\tUINT32 drawGdiplusCacheLevel;\n\n\tif (length < 40)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, drawGDIPlusSupportLevel); /* drawGDIPlusSupportLevel (4 bytes) */\n\tStream_Seek_UINT32(s);                          /* GdipVersion (4 bytes) */\n\tStream_Read_UINT32(s, drawGdiplusCacheLevel);   /* drawGdiplusCacheLevel (4 bytes) */\n\tStream_Seek(s, 10);                             /* GdipCacheEntries (10 bytes) */\n\tStream_Seek(s, 8);                              /* GdipCacheChunkSize (8 bytes) */\n\tStream_Seek(s, 6);                              /* GdipImageCacheProperties (6 bytes) */\n\n\tif (drawGDIPlusSupportLevel & DRAW_GDIPLUS_SUPPORTED)\n\t\tsettings->DrawGdiPlusEnabled = TRUE;\n\n\tif (drawGdiplusCacheLevel & DRAW_GDIPLUS_CACHE_LEVEL_ONE)\n\t\tsettings->DrawGdiPlusCacheEnabled = TRUE;\n\n\treturn TRUE;\n}\n\n/**\n * Write GDI+ cache capability set.\\n\n * @msdn{cc241566}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_draw_gdiplus_cache_capability_set(wStream* s, const rdpSettings* settings)\n{\n\tsize_t header;\n\tUINT32 drawGDIPlusSupportLevel;\n\tUINT32 drawGdiplusCacheLevel;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 64))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tdrawGDIPlusSupportLevel =\n\t    (settings->DrawGdiPlusEnabled) ? DRAW_GDIPLUS_SUPPORTED : DRAW_GDIPLUS_DEFAULT;\n\tdrawGdiplusCacheLevel = (settings->DrawGdiPlusEnabled) ? DRAW_GDIPLUS_CACHE_LEVEL_ONE\n\t                                                       : DRAW_GDIPLUS_CACHE_LEVEL_DEFAULT;\n\tStream_Write_UINT32(s, drawGDIPlusSupportLevel);     /* drawGDIPlusSupportLevel (4 bytes) */\n\tStream_Write_UINT32(s, 0);                           /* GdipVersion (4 bytes) */\n\tStream_Write_UINT32(s, drawGdiplusCacheLevel);       /* drawGdiplusCacheLevel (4 bytes) */\n\trdp_write_gdiplus_cache_entries(s, 10, 5, 5, 10, 2); /* GdipCacheEntries (10 bytes) */\n\trdp_write_gdiplus_cache_chunk_size(s, 512, 2048, 1024, 64); /* GdipCacheChunkSize (8 bytes) */\n\trdp_write_gdiplus_image_cache_properties(s, 4096, 256,\n\t                                         128); /* GdipImageCacheProperties (6 bytes) */\n\trdp_capability_set_finish(s, header, CAPSET_TYPE_DRAW_GDI_PLUS);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_draw_gdiplus_cache_capability_set(wStream* s, UINT16 length)\n{\n\tUINT32 drawGdiPlusSupportLevel;\n\tUINT32 GdipVersion;\n\tUINT32 drawGdiplusCacheLevel;\n\tWLog_INFO(TAG, \"DrawGdiPlusCacheCapabilitySet (length %\" PRIu16 \"):\", length);\n\n\tif (length < 40)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, drawGdiPlusSupportLevel); /* drawGdiPlusSupportLevel (4 bytes) */\n\tStream_Read_UINT32(s, GdipVersion);             /* GdipVersion (4 bytes) */\n\tStream_Read_UINT32(s, drawGdiplusCacheLevel);   /* drawGdiPlusCacheLevel (4 bytes) */\n\tStream_Seek(s, 10);                             /* GdipCacheEntries (10 bytes) */\n\tStream_Seek(s, 8);                              /* GdipCacheChunkSize (8 bytes) */\n\tStream_Seek(s, 6);                              /* GdipImageCacheProperties (6 bytes) */\n\treturn TRUE;\n}\n#endif\n\n/**\n * Read remote programs capability set.\\n\n * @msdn{cc242518}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_remote_programs_capability_set(wStream* s, UINT16 length,\n                                                    rdpSettings* settings)\n{\n\tUINT32 railSupportLevel;\n\n\tif (length < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, railSupportLevel); /* railSupportLevel (4 bytes) */\n\n\tif ((railSupportLevel & RAIL_LEVEL_SUPPORTED) == 0)\n\t{\n\t\tif (settings->RemoteApplicationMode == TRUE)\n\t\t{\n\t\t\t/* RemoteApp Failure! */\n\t\t\tsettings->RemoteApplicationMode = FALSE;\n\t\t}\n\t}\n\n\t/* 2.2.2.2.3 HandshakeEx PDU (TS_RAIL_ORDER_HANDSHAKE_EX)\n\t * the handshake ex pdu is supported when both, client and server announce\n\t * it OR if we are ready to begin enhanced remoteAPP mode. */\n\tif (settings->RemoteApplicationMode)\n\t\trailSupportLevel |= RAIL_LEVEL_HANDSHAKE_EX_SUPPORTED;\n\n\tsettings->RemoteApplicationSupportLevel =\n\t    railSupportLevel & settings->RemoteApplicationSupportMask;\n\treturn TRUE;\n}\n\n/**\n * Write remote programs capability set.\\n\n * @msdn{cc242518}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_remote_programs_capability_set(wStream* s, const rdpSettings* settings)\n{\n\tsize_t header;\n\tUINT32 railSupportLevel;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 64))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\trailSupportLevel = RAIL_LEVEL_SUPPORTED;\n\n\tif (settings->RemoteApplicationSupportLevel & RAIL_LEVEL_DOCKED_LANGBAR_SUPPORTED)\n\t{\n\t\tif (settings->RemoteAppLanguageBarSupported)\n\t\t\trailSupportLevel |= RAIL_LEVEL_DOCKED_LANGBAR_SUPPORTED;\n\t}\n\n\trailSupportLevel |= RAIL_LEVEL_SHELL_INTEGRATION_SUPPORTED;\n\trailSupportLevel |= RAIL_LEVEL_LANGUAGE_IME_SYNC_SUPPORTED;\n\trailSupportLevel |= RAIL_LEVEL_SERVER_TO_CLIENT_IME_SYNC_SUPPORTED;\n\trailSupportLevel |= RAIL_LEVEL_HIDE_MINIMIZED_APPS_SUPPORTED;\n\trailSupportLevel |= RAIL_LEVEL_WINDOW_CLOAKING_SUPPORTED;\n\trailSupportLevel |= RAIL_LEVEL_HANDSHAKE_EX_SUPPORTED;\n\t/* Mask out everything the server does not support. */\n\trailSupportLevel &= settings->RemoteApplicationSupportLevel;\n\tStream_Write_UINT32(s, railSupportLevel); /* railSupportLevel (4 bytes) */\n\trdp_capability_set_finish(s, header, CAPSET_TYPE_RAIL);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_remote_programs_capability_set(wStream* s, UINT16 length)\n{\n\tUINT32 railSupportLevel;\n\tWLog_INFO(TAG, \"RemoteProgramsCapabilitySet (length %\" PRIu16 \"):\", length);\n\n\tif (length < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, railSupportLevel); /* railSupportLevel (4 bytes) */\n\tWLog_INFO(TAG, \"\\trailSupportLevel: 0x%08\" PRIX32 \"\", railSupportLevel);\n\treturn TRUE;\n}\n#endif\n\n/**\n * Read window list capability set.\\n\n * @msdn{cc242564}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_window_list_capability_set(wStream* s, UINT16 length, rdpSettings* settings)\n{\n\tif (length < 11)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, settings->RemoteWndSupportLevel); /* wndSupportLevel (4 bytes) */\n\tStream_Read_UINT8(s, settings->RemoteAppNumIconCaches); /* numIconCaches (1 byte) */\n\tStream_Read_UINT16(s,\n\t                   settings->RemoteAppNumIconCacheEntries); /* numIconCacheEntries (2 bytes) */\n\treturn TRUE;\n}\n\n/**\n * Write window list capability set.\\n\n * @msdn{cc242564}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_window_list_capability_set(wStream* s, const rdpSettings* settings)\n{\n\tsize_t header;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 32))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tStream_Write_UINT32(s, settings->RemoteWndSupportLevel); /* wndSupportLevel (4 bytes) */\n\tStream_Write_UINT8(s, settings->RemoteAppNumIconCaches); /* numIconCaches (1 byte) */\n\tStream_Write_UINT16(s,\n\t                    settings->RemoteAppNumIconCacheEntries); /* numIconCacheEntries (2 bytes) */\n\trdp_capability_set_finish(s, header, CAPSET_TYPE_WINDOW);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_window_list_capability_set(wStream* s, UINT16 length)\n{\n\tUINT32 wndSupportLevel;\n\tBYTE numIconCaches;\n\tUINT16 numIconCacheEntries;\n\tWLog_INFO(TAG, \"WindowListCapabilitySet (length %\" PRIu16 \"):\", length);\n\n\tif (length < 11)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, wndSupportLevel);     /* wndSupportLevel (4 bytes) */\n\tStream_Read_UINT8(s, numIconCaches);        /* numIconCaches (1 byte) */\n\tStream_Read_UINT16(s, numIconCacheEntries); /* numIconCacheEntries (2 bytes) */\n\tWLog_INFO(TAG, \"\\twndSupportLevel: 0x%08\" PRIX32 \"\", wndSupportLevel);\n\tWLog_INFO(TAG, \"\\tnumIconCaches: 0x%02\" PRIX8 \"\", numIconCaches);\n\tWLog_INFO(TAG, \"\\tnumIconCacheEntries: 0x%04\" PRIX16 \"\", numIconCacheEntries);\n\treturn TRUE;\n}\n#endif\n\n/**\n * Read desktop composition capability set.\\n\n * @msdn{cc240855}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_desktop_composition_capability_set(wStream* s, UINT16 length,\n                                                        rdpSettings* settings)\n{\n\tif (length < 6)\n\t\treturn FALSE;\n\n\tStream_Seek_UINT16(s); /* compDeskSupportLevel (2 bytes) */\n\treturn TRUE;\n}\n\n/**\n * Write desktop composition capability set.\\n\n * @msdn{cc240855}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_desktop_composition_capability_set(wStream* s, const rdpSettings* settings)\n{\n\tsize_t header;\n\tUINT16 compDeskSupportLevel;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 32))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tcompDeskSupportLevel =\n\t    (settings->AllowDesktopComposition) ? COMPDESK_SUPPORTED : COMPDESK_NOT_SUPPORTED;\n\tStream_Write_UINT16(s, compDeskSupportLevel); /* compDeskSupportLevel (2 bytes) */\n\trdp_capability_set_finish(s, header, CAPSET_TYPE_COMP_DESK);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_desktop_composition_capability_set(wStream* s, UINT16 length)\n{\n\tUINT16 compDeskSupportLevel;\n\tWLog_INFO(TAG, \"DesktopCompositionCapabilitySet (length %\" PRIu16 \"):\", length);\n\n\tif (length < 6)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, compDeskSupportLevel); /* compDeskSupportLevel (2 bytes) */\n\tWLog_INFO(TAG, \"\\tcompDeskSupportLevel: 0x%04\" PRIX16 \"\", compDeskSupportLevel);\n\treturn TRUE;\n}\n#endif\n\n/**\n * Read multifragment update capability set.\\n\n * @msdn{cc240649}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_multifragment_update_capability_set(wStream* s, UINT16 length,\n                                                         rdpSettings* settings)\n{\n\tUINT32 multifragMaxRequestSize;\n\n\tif (length < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, multifragMaxRequestSize); /* MaxRequestSize (4 bytes) */\n\n\tif (settings->ServerMode)\n\t{\n\t\t/*\n\t\t * Special case: The client announces multifragment update support but sets the maximum\n\t\t * request size to something smaller than maximum size for *one* fast-path PDU. In this case\n\t\t * behave like no multifragment updates were supported and make sure no fragmentation\n\t\t * happens by setting FASTPATH_FRAGMENT_SAFE_SIZE.\n\t\t *\n\t\t * This behaviour was observed with some windows ce rdp clients.\n\t\t */\n\t\tif (multifragMaxRequestSize < FASTPATH_MAX_PACKET_SIZE)\n\t\t\tmultifragMaxRequestSize = FASTPATH_FRAGMENT_SAFE_SIZE;\n\n\t\tif (settings->RemoteFxCodec)\n\t\t{\n\t\t\t/**\n\t\t\t * If we are using RemoteFX the client MUST use a value greater\n\t\t\t * than or equal to the value we've previously sent in the server to\n\t\t\t * client multi-fragment update capability set (MS-RDPRFX 1.5)\n\t\t\t */\n\t\t\tif (multifragMaxRequestSize < settings->MultifragMaxRequestSize)\n\t\t\t{\n\t\t\t\t/**\n\t\t\t\t * If it happens to be smaller we honor the client's value but\n\t\t\t\t * have to disable RemoteFX\n\t\t\t\t */\n\t\t\t\tsettings->RemoteFxCodec = FALSE;\n\t\t\t\tsettings->MultifragMaxRequestSize = multifragMaxRequestSize;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* no need to increase server's max request size setting here */\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsettings->MultifragMaxRequestSize = multifragMaxRequestSize;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/**\n\t\t * In client mode we keep up with the server's capabilites.\n\t\t * In RemoteFX mode we MUST do this but it might also be useful to\n\t\t * receive larger related bitmap updates.\n\t\t */\n\t\tif (multifragMaxRequestSize > settings->MultifragMaxRequestSize)\n\t\t\tsettings->MultifragMaxRequestSize = multifragMaxRequestSize;\n\t}\n\n\treturn TRUE;\n}\n\n/**\n * Write multifragment update capability set.\\n\n * @msdn{cc240649}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_multifragment_update_capability_set(wStream* s, rdpSettings* settings)\n{\n\tsize_t header;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 32))\n\t\treturn FALSE;\n\n\tif (settings->ServerMode && settings->MultifragMaxRequestSize == 0)\n\t{\n\t\t/**\n\t\t * In server mode we prefer to use the highest useful request size that\n\t\t * will allow us to pack a complete screen update into a single fast\n\t\t * path PDU using any of the supported codecs.\n\t\t * However, the client is completely free to accept our proposed\n\t\t * max request size or send a different value in the client-to-server\n\t\t * multi-fragment update capability set and we have to accept that,\n\t\t * unless we are using RemoteFX where the client MUST announce a value\n\t\t * greater than or equal to the value we're sending here.\n\t\t * See [MS-RDPRFX 1.5 capability #2]\n\t\t */\n\t\tUINT32 tileNumX = (settings->DesktopWidth + 63) / 64;\n\t\tUINT32 tileNumY = (settings->DesktopHeight + 63) / 64;\n\t\tsettings->MultifragMaxRequestSize = tileNumX * tileNumY * 16384;\n\t\t/* and add room for headers, regions, frame markers, etc. */\n\t\tsettings->MultifragMaxRequestSize += 16384;\n\t}\n\n\theader = rdp_capability_set_start(s);\n\tStream_Write_UINT32(s, settings->MultifragMaxRequestSize); /* MaxRequestSize (4 bytes) */\n\trdp_capability_set_finish(s, header, CAPSET_TYPE_MULTI_FRAGMENT_UPDATE);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_multifragment_update_capability_set(wStream* s, UINT16 length)\n{\n\tUINT32 maxRequestSize;\n\tWLog_INFO(TAG, \"MultifragmentUpdateCapabilitySet (length %\" PRIu16 \"):\", length);\n\n\tif (length < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, maxRequestSize); /* maxRequestSize (4 bytes) */\n\tWLog_INFO(TAG, \"\\tmaxRequestSize: 0x%08\" PRIX32 \"\", maxRequestSize);\n\treturn TRUE;\n}\n#endif\n\n/**\n * Read large pointer capability set.\\n\n * @msdn{cc240650}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_large_pointer_capability_set(wStream* s, UINT16 length, rdpSettings* settings)\n{\n\tUINT16 largePointerSupportFlags;\n\n\tif (length < 6)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, largePointerSupportFlags); /* largePointerSupportFlags (2 bytes) */\n\tsettings->LargePointerFlag =\n\t    largePointerSupportFlags & (LARGE_POINTER_FLAG_96x96 | LARGE_POINTER_FLAG_384x384);\n\tif ((largePointerSupportFlags & ~(LARGE_POINTER_FLAG_96x96 | LARGE_POINTER_FLAG_384x384)) != 0)\n\t{\n\t\tWLog_WARN(\n\t\t    TAG,\n\t\t    \"TS_LARGE_POINTER_CAPABILITYSET with unsupported flags %04X (all flags %04X) received\",\n\t\t    largePointerSupportFlags & ~(LARGE_POINTER_FLAG_96x96 | LARGE_POINTER_FLAG_384x384),\n\t\t    largePointerSupportFlags);\n\t}\n\treturn TRUE;\n}\n\n/**\n * Write large pointer capability set.\\n\n * @msdn{cc240650}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_large_pointer_capability_set(wStream* s, const rdpSettings* settings)\n{\n\tsize_t header;\n\tUINT16 largePointerSupportFlags;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 32))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tlargePointerSupportFlags =\n\t    settings->LargePointerFlag & (LARGE_POINTER_FLAG_96x96 | LARGE_POINTER_FLAG_384x384);\n\tStream_Write_UINT16(s, largePointerSupportFlags); /* largePointerSupportFlags (2 bytes) */\n\trdp_capability_set_finish(s, header, CAPSET_TYPE_LARGE_POINTER);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_large_pointer_capability_set(wStream* s, UINT16 length)\n{\n\tUINT16 largePointerSupportFlags;\n\tWLog_INFO(TAG, \"LargePointerCapabilitySet (length %\" PRIu16 \"):\", length);\n\n\tif (length < 6)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, largePointerSupportFlags); /* largePointerSupportFlags (2 bytes) */\n\tWLog_INFO(TAG, \"\\tlargePointerSupportFlags: 0x%04\" PRIX16 \"\", largePointerSupportFlags);\n\treturn TRUE;\n}\n#endif\n\n/**\n * Read surface commands capability set.\\n\n * @msdn{dd871563}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_surface_commands_capability_set(wStream* s, UINT16 length,\n                                                     rdpSettings* settings)\n{\n\tUINT32 cmdFlags;\n\n\tif (length < 12)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, cmdFlags); /* cmdFlags (4 bytes) */\n\tStream_Seek_UINT32(s);           /* reserved (4 bytes) */\n\tsettings->SurfaceCommandsEnabled = TRUE;\n\tsettings->SurfaceFrameMarkerEnabled = (cmdFlags & SURFCMDS_FRAME_MARKER) ? TRUE : FALSE;\n\treturn TRUE;\n}\n\n/**\n * Write surface commands capability set.\\n\n * @msdn{dd871563}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_surface_commands_capability_set(wStream* s, const rdpSettings* settings)\n{\n\tsize_t header;\n\tUINT32 cmdFlags;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 32))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tcmdFlags = SURFCMDS_SET_SURFACE_BITS | SURFCMDS_STREAM_SURFACE_BITS;\n\n\tif (settings->SurfaceFrameMarkerEnabled)\n\t\tcmdFlags |= SURFCMDS_FRAME_MARKER;\n\n\tStream_Write_UINT32(s, cmdFlags); /* cmdFlags (4 bytes) */\n\tStream_Write_UINT32(s, 0);        /* reserved (4 bytes) */\n\trdp_capability_set_finish(s, header, CAPSET_TYPE_SURFACE_COMMANDS);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_surface_commands_capability_set(wStream* s, UINT16 length)\n{\n\tUINT32 cmdFlags;\n\tUINT32 reserved;\n\tWLog_INFO(TAG, \"SurfaceCommandsCapabilitySet (length %\" PRIu16 \"):\", length);\n\n\tif (length < 12)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, cmdFlags); /* cmdFlags (4 bytes) */\n\tStream_Read_UINT32(s, reserved); /* reserved (4 bytes) */\n\tWLog_INFO(TAG, \"\\tcmdFlags: 0x%08\" PRIX32 \"\", cmdFlags);\n\tWLog_INFO(TAG, \"\\treserved: 0x%08\" PRIX32 \"\", reserved);\n\treturn TRUE;\n}\n\nstatic void rdp_print_bitmap_codec_guid(const GUID* guid)\n{\n\tWLog_INFO(TAG,\n\t          \"%08\" PRIX32 \"%04\" PRIX16 \"%04\" PRIX16 \"%02\" PRIX8 \"%02\" PRIX8 \"%02\" PRIX8 \"%02\" PRIX8\n\t          \"%02\" PRIX8 \"%02\" PRIX8 \"%02\" PRIX8 \"%02\" PRIX8 \"\",\n\t          guid->Data1, guid->Data2, guid->Data3, guid->Data4[0], guid->Data4[1], guid->Data4[2],\n\t          guid->Data4[3], guid->Data4[4], guid->Data4[5], guid->Data4[6], guid->Data4[7]);\n}\n\nstatic char* rdp_get_bitmap_codec_guid_name(const GUID* guid)\n{\n\tRPC_STATUS rpc_status;\n\n\tif (UuidEqual(guid, &CODEC_GUID_REMOTEFX, &rpc_status))\n\t\treturn \"CODEC_GUID_REMOTEFX\";\n\telse if (UuidEqual(guid, &CODEC_GUID_NSCODEC, &rpc_status))\n\t\treturn \"CODEC_GUID_NSCODEC\";\n\telse if (UuidEqual(guid, &CODEC_GUID_IGNORE, &rpc_status))\n\t\treturn \"CODEC_GUID_IGNORE\";\n\telse if (UuidEqual(guid, &CODEC_GUID_IMAGE_REMOTEFX, &rpc_status))\n\t\treturn \"CODEC_GUID_IMAGE_REMOTEFX\";\n\n#if defined(WITH_JPEG)\n\telse if (UuidEqual(guid, &CODEC_GUID_JPEG, &rpc_status))\n\t\treturn \"CODEC_GUID_JPEG\";\n\n#endif\n\treturn \"CODEC_GUID_UNKNOWN\";\n}\n#endif\n\nstatic void rdp_read_bitmap_codec_guid(wStream* s, GUID* guid)\n{\n\tBYTE g[16];\n\tStream_Read(s, g, 16);\n\tguid->Data1 = (g[3] << 24) | (g[2] << 16) | (g[1] << 8) | g[0];\n\tguid->Data2 = (g[5] << 8) | g[4];\n\tguid->Data3 = (g[7] << 8) | g[6];\n\tguid->Data4[0] = g[8];\n\tguid->Data4[1] = g[9];\n\tguid->Data4[2] = g[10];\n\tguid->Data4[3] = g[11];\n\tguid->Data4[4] = g[12];\n\tguid->Data4[5] = g[13];\n\tguid->Data4[6] = g[14];\n\tguid->Data4[7] = g[15];\n}\n\nstatic void rdp_write_bitmap_codec_guid(wStream* s, const GUID* guid)\n{\n\tBYTE g[16];\n\tg[0] = guid->Data1 & 0xFF;\n\tg[1] = (guid->Data1 >> 8) & 0xFF;\n\tg[2] = (guid->Data1 >> 16) & 0xFF;\n\tg[3] = (guid->Data1 >> 24) & 0xFF;\n\tg[4] = (guid->Data2) & 0xFF;\n\tg[5] = (guid->Data2 >> 8) & 0xFF;\n\tg[6] = (guid->Data3) & 0xFF;\n\tg[7] = (guid->Data3 >> 8) & 0xFF;\n\tg[8] = guid->Data4[0];\n\tg[9] = guid->Data4[1];\n\tg[10] = guid->Data4[2];\n\tg[11] = guid->Data4[3];\n\tg[12] = guid->Data4[4];\n\tg[13] = guid->Data4[5];\n\tg[14] = guid->Data4[6];\n\tg[15] = guid->Data4[7];\n\tStream_Write(s, g, 16);\n}\n\n/**\n * Read bitmap codecs capability set.\\n\n * @msdn{dd891377}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_bitmap_codecs_capability_set(wStream* s, UINT16 length, rdpSettings* settings)\n{\n\tBYTE codecId;\n\tGUID codecGuid;\n\tRPC_STATUS rpc_status;\n\tBYTE bitmapCodecCount;\n\tUINT16 codecPropertiesLength;\n\tUINT16 remainingLength;\n\tBOOL guidNSCodec = FALSE;\n\tBOOL guidRemoteFx = FALSE;\n\tBOOL guidRemoteFxImage = FALSE;\n\n\tif (length < 5)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, bitmapCodecCount); /* bitmapCodecCount (1 byte) */\n\tremainingLength = length - 5;\n\n\twhile (bitmapCodecCount > 0)\n\t{\n\t\tif (remainingLength < 19)\n\t\t\treturn FALSE;\n\n\t\trdp_read_bitmap_codec_guid(s, &codecGuid);    /* codecGuid (16 bytes) */\n\t\tStream_Read_UINT8(s, codecId);                /* codecId (1 byte) */\n\t\tStream_Read_UINT16(s, codecPropertiesLength); /* codecPropertiesLength (2 bytes) */\n\t\tremainingLength -= 19;\n\n\t\tif (remainingLength < codecPropertiesLength)\n\t\t\treturn FALSE;\n\n\t\tif (settings->ServerMode)\n\t\t{\n\t\t\tUINT32 beg;\n\t\t\tUINT32 end;\n\t\t\tbeg = (UINT32)Stream_GetPosition(s);\n\t\t\tend = beg + codecPropertiesLength;\n\n\t\t\tif (UuidEqual(&codecGuid, &CODEC_GUID_REMOTEFX, &rpc_status))\n\t\t\t{\n\t\t\t\tUINT32 rfxCapsLength;\n\t\t\t\tUINT32 rfxPropsLength;\n\t\t\t\tUINT32 captureFlags;\n\t\t\t\tguidRemoteFx = TRUE;\n\t\t\t\tsettings->RemoteFxCodecId = codecId;\n\t\t\t\tStream_Read_UINT32(s, rfxPropsLength); /* length (4 bytes) */\n\t\t\t\tStream_Read_UINT32(s, captureFlags);   /* captureFlags (4 bytes) */\n\t\t\t\tStream_Read_UINT32(s, rfxCapsLength);  /* capsLength (4 bytes) */\n\t\t\t\tsettings->RemoteFxCaptureFlags = captureFlags;\n\t\t\t\tsettings->RemoteFxOnly = (captureFlags & CARDP_CAPS_CAPTURE_NON_CAC) ? TRUE : FALSE;\n\n\t\t\t\tif (rfxCapsLength)\n\t\t\t\t{\n\t\t\t\t\tUINT16 blockType;\n\t\t\t\t\tUINT32 blockLen;\n\t\t\t\t\tUINT16 numCapsets;\n\t\t\t\t\tBYTE rfxCodecId;\n\t\t\t\t\tUINT16 capsetType;\n\t\t\t\t\tUINT16 numIcaps;\n\t\t\t\t\tUINT16 icapLen;\n\t\t\t\t\t/* TS_RFX_CAPS */\n\t\t\t\t\tStream_Read_UINT16(s, blockType);  /* blockType (2 bytes) */\n\t\t\t\t\tStream_Read_UINT32(s, blockLen);   /* blockLen (4 bytes) */\n\t\t\t\t\tStream_Read_UINT16(s, numCapsets); /* numCapsets (2 bytes) */\n\n\t\t\t\t\tif (blockType != 0xCBC0)\n\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\tif (blockLen != 8)\n\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\tif (numCapsets != 1)\n\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\t/* TS_RFX_CAPSET */\n\t\t\t\t\tStream_Read_UINT16(s, blockType);  /* blockType (2 bytes) */\n\t\t\t\t\tStream_Read_UINT32(s, blockLen);   /* blockLen (4 bytes) */\n\t\t\t\t\tStream_Read_UINT8(s, rfxCodecId);  /* codecId (1 byte) */\n\t\t\t\t\tStream_Read_UINT16(s, capsetType); /* capsetType (2 bytes) */\n\t\t\t\t\tStream_Read_UINT16(s, numIcaps);   /* numIcaps (2 bytes) */\n\t\t\t\t\tStream_Read_UINT16(s, icapLen);    /* icapLen (2 bytes) */\n\n\t\t\t\t\tif (blockType != 0xCBC1)\n\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\tif (rfxCodecId != 1)\n\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\tif (capsetType != 0xCFC0)\n\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\twhile (numIcaps--)\n\t\t\t\t\t{\n\t\t\t\t\t\tUINT16 version;\n\t\t\t\t\t\tUINT16 tileSize;\n\t\t\t\t\t\tBYTE codecFlags;\n\t\t\t\t\t\tBYTE colConvBits;\n\t\t\t\t\t\tBYTE transformBits;\n\t\t\t\t\t\tBYTE entropyBits;\n\t\t\t\t\t\t/* TS_RFX_ICAP */\n\t\t\t\t\t\tStream_Read_UINT16(s, version);      /* version (2 bytes) */\n\t\t\t\t\t\tStream_Read_UINT16(s, tileSize);     /* tileSize (2 bytes) */\n\t\t\t\t\t\tStream_Read_UINT8(s, codecFlags);    /* flags (1 byte) */\n\t\t\t\t\t\tStream_Read_UINT8(s, colConvBits);   /* colConvBits (1 byte) */\n\t\t\t\t\t\tStream_Read_UINT8(s, transformBits); /* transformBits (1 byte) */\n\t\t\t\t\t\tStream_Read_UINT8(s, entropyBits);   /* entropyBits (1 byte) */\n\n\t\t\t\t\t\tif (version == 0x0009)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* Version 0.9 */\n\t\t\t\t\t\t\tif (tileSize != 0x0080)\n\t\t\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (version == 0x0100)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* Version 1.0 */\n\t\t\t\t\t\t\tif (tileSize != 0x0040)\n\t\t\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\t\tif (colConvBits != 1)\n\t\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\t\tif (transformBits != 1)\n\t\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (UuidEqual(&codecGuid, &CODEC_GUID_IMAGE_REMOTEFX, &rpc_status))\n\t\t\t{\n\t\t\t\t/* Microsoft RDP servers ignore CODEC_GUID_IMAGE_REMOTEFX codec properties */\n\t\t\t\tguidRemoteFxImage = TRUE;\n\t\t\t\tStream_Seek(s, codecPropertiesLength); /* codecProperties */\n\t\t\t}\n\t\t\telse if (UuidEqual(&codecGuid, &CODEC_GUID_NSCODEC, &rpc_status))\n\t\t\t{\n\t\t\t\tBYTE colorLossLevel;\n\t\t\t\tBYTE fAllowSubsampling;\n\t\t\t\tBYTE fAllowDynamicFidelity;\n\t\t\t\tguidNSCodec = TRUE;\n\t\t\t\tsettings->NSCodecId = codecId;\n\t\t\t\tStream_Read_UINT8(s, fAllowDynamicFidelity); /* fAllowDynamicFidelity (1 byte) */\n\t\t\t\tStream_Read_UINT8(s, fAllowSubsampling);     /* fAllowSubsampling (1 byte) */\n\t\t\t\tStream_Read_UINT8(s, colorLossLevel);        /* colorLossLevel (1 byte) */\n\n\t\t\t\tif (colorLossLevel < 1)\n\t\t\t\t\tcolorLossLevel = 1;\n\n\t\t\t\tif (colorLossLevel > 7)\n\t\t\t\t\tcolorLossLevel = 7;\n\n\t\t\t\tsettings->NSCodecAllowDynamicColorFidelity = fAllowDynamicFidelity;\n\t\t\t\tsettings->NSCodecAllowSubsampling = fAllowSubsampling;\n\t\t\t\tsettings->NSCodecColorLossLevel = colorLossLevel;\n\t\t\t}\n\t\t\telse if (UuidEqual(&codecGuid, &CODEC_GUID_IGNORE, &rpc_status))\n\t\t\t{\n\t\t\t\tStream_Seek(s, codecPropertiesLength); /* codecProperties */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tStream_Seek(s, codecPropertiesLength); /* codecProperties */\n\t\t\t}\n\n\t\t\tif (Stream_GetPosition(s) != end)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG,\n\t\t\t\t         \"error while reading codec properties: actual offset: %\" PRIuz\n\t\t\t\t         \" expected offset: %\" PRIu32 \"\",\n\t\t\t\t         Stream_GetPosition(s), end);\n\t\t\t\tStream_SetPosition(s, end);\n\t\t\t}\n\n\t\t\tremainingLength -= codecPropertiesLength;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tStream_Seek(s, codecPropertiesLength); /* codecProperties */\n\t\t\tremainingLength -= codecPropertiesLength;\n\t\t}\n\n\t\tbitmapCodecCount--;\n\t}\n\n\tif (settings->ServerMode)\n\t{\n\t\t/* only enable a codec if we've announced/enabled it before */\n\t\tsettings->RemoteFxCodec = settings->RemoteFxCodec && guidRemoteFx;\n\t\tsettings->RemoteFxImageCodec = settings->RemoteFxImageCodec && guidRemoteFxImage;\n\t\tsettings->NSCodec = settings->NSCodec && guidNSCodec;\n\t\tsettings->JpegCodec = FALSE;\n\t}\n\n\treturn TRUE;\n}\n\n/**\n * Write RemoteFX Client Capability Container.\\n\n * @param s stream\n * @param settings settings\n */\nstatic BOOL rdp_write_rfx_client_capability_container(wStream* s, const rdpSettings* settings)\n{\n\tUINT32 captureFlags;\n\tBYTE codecMode;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 64))\n\t\treturn FALSE;\n\n\tcaptureFlags = settings->RemoteFxOnly ? 0 : CARDP_CAPS_CAPTURE_NON_CAC;\n\tcodecMode = settings->RemoteFxCodecMode;\n\tStream_Write_UINT16(s, 49); /* codecPropertiesLength */\n\t/* TS_RFX_CLNT_CAPS_CONTAINER */\n\tStream_Write_UINT32(s, 49);           /* length */\n\tStream_Write_UINT32(s, captureFlags); /* captureFlags */\n\tStream_Write_UINT32(s, 37);           /* capsLength */\n\t/* TS_RFX_CAPS */\n\tStream_Write_UINT16(s, CBY_CAPS); /* blockType */\n\tStream_Write_UINT32(s, 8);        /* blockLen */\n\tStream_Write_UINT16(s, 1);        /* numCapsets */\n\t/* TS_RFX_CAPSET */\n\tStream_Write_UINT16(s, CBY_CAPSET); /* blockType */\n\tStream_Write_UINT32(s, 29);         /* blockLen */\n\tStream_Write_UINT8(s, 0x01);        /* codecId (MUST be set to 0x01) */\n\tStream_Write_UINT16(s, CLY_CAPSET); /* capsetType */\n\tStream_Write_UINT16(s, 2);          /* numIcaps */\n\tStream_Write_UINT16(s, 8);          /* icapLen */\n\t/* TS_RFX_ICAP (RLGR1) */\n\tStream_Write_UINT16(s, CLW_VERSION_1_0);   /* version */\n\tStream_Write_UINT16(s, CT_TILE_64x64);     /* tileSize */\n\tStream_Write_UINT8(s, codecMode);          /* flags */\n\tStream_Write_UINT8(s, CLW_COL_CONV_ICT);   /* colConvBits */\n\tStream_Write_UINT8(s, CLW_XFORM_DWT_53_A); /* transformBits */\n\tStream_Write_UINT8(s, CLW_ENTROPY_RLGR1);  /* entropyBits */\n\t/* TS_RFX_ICAP (RLGR3) */\n\tStream_Write_UINT16(s, CLW_VERSION_1_0);   /* version */\n\tStream_Write_UINT16(s, CT_TILE_64x64);     /* tileSize */\n\tStream_Write_UINT8(s, codecMode);          /* flags */\n\tStream_Write_UINT8(s, CLW_COL_CONV_ICT);   /* colConvBits */\n\tStream_Write_UINT8(s, CLW_XFORM_DWT_53_A); /* transformBits */\n\tStream_Write_UINT8(s, CLW_ENTROPY_RLGR3);  /* entropyBits */\n\treturn TRUE;\n}\n\n/**\n * Write NSCODEC Client Capability Container.\\n\n * @param s stream\n * @param settings settings\n */\nstatic BOOL rdp_write_nsc_client_capability_container(wStream* s, const rdpSettings* settings)\n{\n\tBYTE colorLossLevel;\n\tBYTE fAllowSubsampling;\n\tBYTE fAllowDynamicFidelity;\n\tfAllowDynamicFidelity = settings->NSCodecAllowDynamicColorFidelity;\n\tfAllowSubsampling = settings->NSCodecAllowSubsampling;\n\tcolorLossLevel = settings->NSCodecColorLossLevel;\n\n\tif (colorLossLevel < 1)\n\t\tcolorLossLevel = 1;\n\n\tif (colorLossLevel > 7)\n\t\tcolorLossLevel = 7;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 8))\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, 3); /* codecPropertiesLength */\n\t/* TS_NSCODEC_CAPABILITYSET */\n\tStream_Write_UINT8(s, fAllowDynamicFidelity); /* fAllowDynamicFidelity (1 byte) */\n\tStream_Write_UINT8(s, fAllowSubsampling);     /* fAllowSubsampling (1 byte) */\n\tStream_Write_UINT8(s, colorLossLevel);        /* colorLossLevel (1 byte) */\n\treturn TRUE;\n}\n\n#if defined(WITH_JPEG)\nstatic BOOL rdp_write_jpeg_client_capability_container(wStream* s, const rdpSettings* settings)\n{\n\tif (!Stream_EnsureRemainingCapacity(s, 8))\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, 1); /* codecPropertiesLength */\n\tStream_Write_UINT8(s, settings->JpegQuality);\n\treturn TRUE;\n}\n#endif\n\n/**\n * Write RemoteFX Server Capability Container.\\n\n * @param s stream\n * @param settings settings\n */\nstatic BOOL rdp_write_rfx_server_capability_container(wStream* s, const rdpSettings* settings)\n{\n\tWINPR_UNUSED(settings);\n\tif (!Stream_EnsureRemainingCapacity(s, 8))\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, 4); /* codecPropertiesLength */\n\tStream_Write_UINT32(s, 0); /* reserved */\n\treturn TRUE;\n}\n\nstatic BOOL rdp_write_jpeg_server_capability_container(wStream* s, const rdpSettings* settings)\n{\n\tWINPR_UNUSED(settings);\n\tif (!Stream_EnsureRemainingCapacity(s, 8))\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, 1); /* codecPropertiesLength */\n\tStream_Write_UINT8(s, 75);\n\treturn TRUE;\n}\n\n/**\n * Write NSCODEC Server Capability Container.\\n\n * @param s stream\n * @param settings settings\n */\nstatic BOOL rdp_write_nsc_server_capability_container(wStream* s, const rdpSettings* settings)\n{\n\tWINPR_UNUSED(settings);\n\tif (!Stream_EnsureRemainingCapacity(s, 8))\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, 4); /* codecPropertiesLength */\n\tStream_Write_UINT32(s, 0); /* reserved */\n\treturn TRUE;\n}\n\n/**\n * Write bitmap codecs capability set.\\n\n * @msdn{dd891377}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_bitmap_codecs_capability_set(wStream* s, const rdpSettings* settings)\n{\n\tsize_t header;\n\tBYTE bitmapCodecCount;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 64))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tbitmapCodecCount = 0;\n\n\tif (settings->RemoteFxCodec)\n\t\tbitmapCodecCount++;\n\n\tif (settings->NSCodec)\n\t\tbitmapCodecCount++;\n\n#if defined(WITH_JPEG)\n\n\tif (settings->JpegCodec)\n\t\tbitmapCodecCount++;\n\n#endif\n\n\tif (settings->RemoteFxImageCodec)\n\t\tbitmapCodecCount++;\n\n\tStream_Write_UINT8(s, bitmapCodecCount);\n\n\tif (settings->RemoteFxCodec)\n\t{\n\t\trdp_write_bitmap_codec_guid(s, &CODEC_GUID_REMOTEFX); /* codecGUID */\n\n\t\tif (settings->ServerMode)\n\t\t{\n\t\t\tStream_Write_UINT8(s, 0); /* codecID is defined by the client */\n\n\t\t\tif (!rdp_write_rfx_server_capability_container(s, settings))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tStream_Write_UINT8(s, RDP_CODEC_ID_REMOTEFX); /* codecID */\n\n\t\t\tif (!rdp_write_rfx_client_capability_container(s, settings))\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\tif (settings->NSCodec)\n\t{\n\t\trdp_write_bitmap_codec_guid(s, &CODEC_GUID_NSCODEC); /* codecGUID */\n\n\t\tif (settings->ServerMode)\n\t\t{\n\t\t\tStream_Write_UINT8(s, 0); /* codecID is defined by the client */\n\n\t\t\tif (!rdp_write_nsc_server_capability_container(s, settings))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tStream_Write_UINT8(s, RDP_CODEC_ID_NSCODEC); /* codecID */\n\n\t\t\tif (!rdp_write_nsc_client_capability_container(s, settings))\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\n#if defined(WITH_JPEG)\n\n\tif (settings->JpegCodec)\n\t{\n\t\trdp_write_bitmap_codec_guid(s, &CODEC_GUID_JPEG); /* codecGUID */\n\n\t\tif (settings->ServerMode)\n\t\t{\n\t\t\tStream_Write_UINT8(s, 0); /* codecID is defined by the client */\n\n\t\t\tif (!rdp_write_jpeg_server_capability_container(s, settings))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tStream_Write_UINT8(s, RDP_CODEC_ID_JPEG); /* codecID */\n\n\t\t\tif (!rdp_write_jpeg_client_capability_container(s, settings))\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\n#endif\n\n\tif (settings->RemoteFxImageCodec)\n\t{\n\t\trdp_write_bitmap_codec_guid(s, &CODEC_GUID_IMAGE_REMOTEFX); /* codecGUID */\n\n\t\tif (settings->ServerMode)\n\t\t{\n\t\t\tStream_Write_UINT8(s, 0); /* codecID is defined by the client */\n\n\t\t\tif (!rdp_write_rfx_server_capability_container(s, settings))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tStream_Write_UINT8(s, RDP_CODEC_ID_IMAGE_REMOTEFX); /* codecID */\n\n\t\t\tif (!rdp_write_rfx_client_capability_container(s, settings))\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\trdp_capability_set_finish(s, header, CAPSET_TYPE_BITMAP_CODECS);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_bitmap_codecs_capability_set(wStream* s, UINT16 length)\n{\n\tGUID codecGuid;\n\tBYTE bitmapCodecCount;\n\tBYTE codecId;\n\tUINT16 codecPropertiesLength;\n\tUINT16 remainingLength;\n\tWLog_INFO(TAG, \"BitmapCodecsCapabilitySet (length %\" PRIu16 \"):\", length);\n\n\tif (length < 5)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, bitmapCodecCount); /* bitmapCodecCount (1 byte) */\n\tremainingLength = length - 5;\n\tWLog_INFO(TAG, \"\\tbitmapCodecCount: %\" PRIu8 \"\", bitmapCodecCount);\n\n\twhile (bitmapCodecCount > 0)\n\t{\n\t\tif (remainingLength < 19)\n\t\t\treturn FALSE;\n\n\t\trdp_read_bitmap_codec_guid(s, &codecGuid); /* codecGuid (16 bytes) */\n\t\tStream_Read_UINT8(s, codecId);             /* codecId (1 byte) */\n\t\tWLog_INFO(TAG, \"\\tcodecGuid: 0x\");\n\t\trdp_print_bitmap_codec_guid(&codecGuid);\n\t\tWLog_INFO(TAG, \" (%s)\", rdp_get_bitmap_codec_guid_name(&codecGuid));\n\t\tWLog_INFO(TAG, \"\\tcodecId: %\" PRIu8 \"\", codecId);\n\t\tStream_Read_UINT16(s, codecPropertiesLength); /* codecPropertiesLength (2 bytes) */\n\t\tWLog_INFO(TAG, \"\\tcodecPropertiesLength: %\" PRIu16 \"\", codecPropertiesLength);\n\t\tremainingLength -= 19;\n\n\t\tif (remainingLength < codecPropertiesLength)\n\t\t\treturn FALSE;\n\n\t\tStream_Seek(s, codecPropertiesLength); /* codecProperties */\n\t\tremainingLength -= codecPropertiesLength;\n\t\tbitmapCodecCount--;\n\t}\n\n\treturn TRUE;\n}\n#endif\n\n/**\n * Read frame acknowledge capability set.\\n\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_frame_acknowledge_capability_set(wStream* s, UINT16 length,\n                                                      rdpSettings* settings)\n{\n\tif (length < 8)\n\t\treturn FALSE;\n\n\tif (settings->ServerMode)\n\t{\n\t\tStream_Read_UINT32(s, settings->FrameAcknowledge); /* (4 bytes) */\n\t}\n\telse\n\t{\n\t\tStream_Seek_UINT32(s); /* (4 bytes) */\n\t}\n\n\treturn TRUE;\n}\n\n/**\n * Write frame acknowledge capability set.\\n\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_frame_acknowledge_capability_set(wStream* s, const rdpSettings* settings)\n{\n\tsize_t header;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 32))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tif (header > UINT16_MAX)\n\t\treturn FALSE;\n\tStream_Write_UINT32(s, settings->FrameAcknowledge); /* (4 bytes) */\n\trdp_capability_set_finish(s, (UINT16)header, CAPSET_TYPE_FRAME_ACKNOWLEDGE);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_frame_acknowledge_capability_set(wStream* s, UINT16 length)\n{\n\tUINT32 frameAcknowledge;\n\tWLog_INFO(TAG, \"FrameAcknowledgeCapabilitySet (length %\" PRIu16 \"):\", length);\n\n\tif (length < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, frameAcknowledge); /* frameAcknowledge (4 bytes) */\n\tWLog_INFO(TAG, \"\\tframeAcknowledge: 0x%08\" PRIX32 \"\", frameAcknowledge);\n\treturn TRUE;\n}\n#endif\n\nstatic BOOL rdp_read_bitmap_cache_v3_codec_id_capability_set(wStream* s, UINT16 length,\n                                                             rdpSettings* settings)\n{\n\tBYTE bitmapCacheV3CodecId;\n\n\tWINPR_UNUSED(settings);\n\tif (length < 5)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, bitmapCacheV3CodecId); /* bitmapCacheV3CodecId (1 byte) */\n\treturn TRUE;\n}\n\nstatic BOOL rdp_write_bitmap_cache_v3_codec_id_capability_set(wStream* s,\n                                                              const rdpSettings* settings)\n{\n\tsize_t header;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 32))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tif (header > UINT16_MAX)\n\t\treturn FALSE;\n\tif (settings->BitmapCacheV3CodecId > UINT8_MAX)\n\t\treturn FALSE;\n\tStream_Write_UINT8(s, (UINT8)settings->BitmapCacheV3CodecId);\n\trdp_capability_set_finish(s, (UINT16)header, CAPSET_TYPE_BITMAP_CACHE_V3_CODEC_ID);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_bitmap_cache_v3_codec_id_capability_set(wStream* s, UINT16 length)\n{\n\tBYTE bitmapCacheV3CodecId;\n\tWLog_INFO(TAG, \"BitmapCacheV3CodecIdCapabilitySet (length %\" PRIu16 \"):\", length);\n\n\tif (length < 5)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, bitmapCacheV3CodecId); /* bitmapCacheV3CodecId (1 byte) */\n\tWLog_INFO(TAG, \"\\tbitmapCacheV3CodecId: 0x%02\" PRIX8 \"\", bitmapCacheV3CodecId);\n\treturn TRUE;\n}\n\nstatic BOOL rdp_print_capability_sets(wStream* s, UINT16 numberCapabilities, BOOL receiving)\n{\n\tUINT16 type;\n\tUINT16 length;\n\tBYTE *bm, *em;\n\n\twhile (numberCapabilities > 0)\n\t{\n\t\tStream_GetPointer(s, bm);\n\t\trdp_read_capability_set_header(s, &length, &type);\n\t\tWLog_INFO(TAG, \"%s \", receiving ? \"Receiving\" : \"Sending\");\n\t\tem = bm + length;\n\n\t\tif (Stream_GetRemainingLength(s) < (size_t)(length - 4))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"error processing stream\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tswitch (type)\n\t\t{\n\t\t\tcase CAPSET_TYPE_GENERAL:\n\t\t\t\tif (!rdp_print_general_capability_set(s, length))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_BITMAP:\n\t\t\t\tif (!rdp_print_bitmap_capability_set(s, length))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_ORDER:\n\t\t\t\tif (!rdp_print_order_capability_set(s, length))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_BITMAP_CACHE:\n\t\t\t\tif (!rdp_print_bitmap_cache_capability_set(s, length))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_CONTROL:\n\t\t\t\tif (!rdp_print_control_capability_set(s, length))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_ACTIVATION:\n\t\t\t\tif (!rdp_print_window_activation_capability_set(s, length))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_POINTER:\n\t\t\t\tif (!rdp_print_pointer_capability_set(s, length))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_SHARE:\n\t\t\t\tif (!rdp_print_share_capability_set(s, length))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_COLOR_CACHE:\n\t\t\t\tif (!rdp_print_color_cache_capability_set(s, length))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_SOUND:\n\t\t\t\tif (!rdp_print_sound_capability_set(s, length))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_INPUT:\n\t\t\t\tif (!rdp_print_input_capability_set(s, length))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_FONT:\n\t\t\t\tif (!rdp_print_font_capability_set(s, length))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_BRUSH:\n\t\t\t\tif (!rdp_print_brush_capability_set(s, length))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_GLYPH_CACHE:\n\t\t\t\tif (!rdp_print_glyph_cache_capability_set(s, length))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_OFFSCREEN_CACHE:\n\t\t\t\tif (!rdp_print_offscreen_bitmap_cache_capability_set(s, length))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_BITMAP_CACHE_HOST_SUPPORT:\n\t\t\t\tif (!rdp_print_bitmap_cache_host_support_capability_set(s, length))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_BITMAP_CACHE_V2:\n\t\t\t\tif (!rdp_print_bitmap_cache_v2_capability_set(s, length))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_VIRTUAL_CHANNEL:\n\t\t\t\tif (!rdp_print_virtual_channel_capability_set(s, length))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_DRAW_NINE_GRID_CACHE:\n\t\t\t\tif (!rdp_print_draw_nine_grid_cache_capability_set(s, length))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_DRAW_GDI_PLUS:\n\t\t\t\tif (!rdp_print_draw_gdiplus_cache_capability_set(s, length))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_RAIL:\n\t\t\t\tif (!rdp_print_remote_programs_capability_set(s, length))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_WINDOW:\n\t\t\t\tif (!rdp_print_window_list_capability_set(s, length))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_COMP_DESK:\n\t\t\t\tif (!rdp_print_desktop_composition_capability_set(s, length))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_MULTI_FRAGMENT_UPDATE:\n\t\t\t\tif (!rdp_print_multifragment_update_capability_set(s, length))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_LARGE_POINTER:\n\t\t\t\tif (!rdp_print_large_pointer_capability_set(s, length))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_SURFACE_COMMANDS:\n\t\t\t\tif (!rdp_print_surface_commands_capability_set(s, length))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_BITMAP_CODECS:\n\t\t\t\tif (!rdp_print_bitmap_codecs_capability_set(s, length))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_FRAME_ACKNOWLEDGE:\n\t\t\t\tif (!rdp_print_frame_acknowledge_capability_set(s, length))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_BITMAP_CACHE_V3_CODEC_ID:\n\t\t\t\tif (!rdp_print_bitmap_cache_v3_codec_id_capability_set(s, length))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tWLog_ERR(TAG, \"unknown capability type %\" PRIu16 \"\", type);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (Stream_Pointer(s) != em)\n\t\t{\n\t\t\tWLog_ERR(TAG,\n\t\t\t         \"incorrect offset, type:0x%04\" PRIX16 \" actual:%\" PRIuz \" expected:%\" PRIuz \"\",\n\t\t\t         type, Stream_Pointer(s) - bm, em - bm);\n\t\t}\n\n\t\tStream_SetPointer(s, em);\n\t\tnumberCapabilities--;\n\t}\n\n\treturn TRUE;\n}\n#endif\n\nstatic BOOL rdp_read_capability_sets(wStream* s, rdpSettings* settings, UINT16 numberCapabilities,\n                                     UINT16 totalLength)\n{\n\tBOOL treated;\n\tsize_t start, end, len;\n\tUINT16 count = numberCapabilities;\n\n\tstart = Stream_GetPosition(s);\n\twhile (numberCapabilities > 0 && Stream_GetRemainingLength(s) >= 4)\n\t{\n\t\tUINT16 type;\n\t\tUINT16 length;\n\t\tBYTE* em;\n\t\tBYTE* bm = Stream_Pointer(s);\n\t\trdp_read_capability_set_header(s, &length, &type);\n\n\t\tif (type < 32)\n\t\t{\n\t\t\tsettings->ReceivedCapabilities[type] = TRUE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tWLog_WARN(TAG, \"not handling capability type %\" PRIu16 \" yet\", type);\n\t\t}\n\n\t\tem = bm + length;\n\n\t\tif (Stream_GetRemainingLength(s) + 4 < ((size_t)length))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"error processing stream\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\ttreated = TRUE;\n\n\t\tswitch (type)\n\t\t{\n\t\t\tcase CAPSET_TYPE_GENERAL:\n\t\t\t\tif (!rdp_read_general_capability_set(s, length, settings))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_BITMAP:\n\t\t\t\tif (!rdp_read_bitmap_capability_set(s, length, settings))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_ORDER:\n\t\t\t\tif (!rdp_read_order_capability_set(s, length, settings))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_POINTER:\n\t\t\t\tif (!rdp_read_pointer_capability_set(s, length, settings))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_INPUT:\n\t\t\t\tif (!rdp_read_input_capability_set(s, length, settings))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_VIRTUAL_CHANNEL:\n\t\t\t\tif (!rdp_read_virtual_channel_capability_set(s, length, settings))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_SHARE:\n\t\t\t\tif (!rdp_read_share_capability_set(s, length, settings))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_COLOR_CACHE:\n\t\t\t\tif (!rdp_read_color_cache_capability_set(s, length, settings))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_FONT:\n\t\t\t\tif (!rdp_read_font_capability_set(s, length, settings))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_DRAW_GDI_PLUS:\n\t\t\t\tif (!rdp_read_draw_gdiplus_cache_capability_set(s, length, settings))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_RAIL:\n\t\t\t\tif (!rdp_read_remote_programs_capability_set(s, length, settings))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_WINDOW:\n\t\t\t\tif (!rdp_read_window_list_capability_set(s, length, settings))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_MULTI_FRAGMENT_UPDATE:\n\t\t\t\tif (!rdp_read_multifragment_update_capability_set(s, length, settings))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_LARGE_POINTER:\n\t\t\t\tif (!rdp_read_large_pointer_capability_set(s, length, settings))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_COMP_DESK:\n\t\t\t\tif (!rdp_read_desktop_composition_capability_set(s, length, settings))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_SURFACE_COMMANDS:\n\t\t\t\tif (!rdp_read_surface_commands_capability_set(s, length, settings))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_BITMAP_CODECS:\n\t\t\t\tif (!rdp_read_bitmap_codecs_capability_set(s, length, settings))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_FRAME_ACKNOWLEDGE:\n\t\t\t\tif (!rdp_read_frame_acknowledge_capability_set(s, length, settings))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_BITMAP_CACHE_V3_CODEC_ID:\n\t\t\t\tif (!rdp_read_bitmap_cache_v3_codec_id_capability_set(s, length, settings))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\ttreated = FALSE;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!treated)\n\t\t{\n\t\t\tif (settings->ServerMode)\n\t\t\t{\n\t\t\t\t/* treating capabilities that are supposed to be send only from the client */\n\t\t\t\tswitch (type)\n\t\t\t\t{\n\t\t\t\t\tcase CAPSET_TYPE_BITMAP_CACHE:\n\t\t\t\t\t\tif (!rdp_read_bitmap_cache_capability_set(s, length, settings))\n\t\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase CAPSET_TYPE_BITMAP_CACHE_V2:\n\t\t\t\t\t\tif (!rdp_read_bitmap_cache_v2_capability_set(s, length, settings))\n\t\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase CAPSET_TYPE_BRUSH:\n\t\t\t\t\t\tif (!rdp_read_brush_capability_set(s, length, settings))\n\t\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase CAPSET_TYPE_GLYPH_CACHE:\n\t\t\t\t\t\tif (!rdp_read_glyph_cache_capability_set(s, length, settings))\n\t\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase CAPSET_TYPE_OFFSCREEN_CACHE:\n\t\t\t\t\t\tif (!rdp_read_offscreen_bitmap_cache_capability_set(s, length, settings))\n\t\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase CAPSET_TYPE_SOUND:\n\t\t\t\t\t\tif (!rdp_read_sound_capability_set(s, length, settings))\n\t\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase CAPSET_TYPE_CONTROL:\n\t\t\t\t\t\tif (!rdp_read_control_capability_set(s, length, settings))\n\t\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase CAPSET_TYPE_ACTIVATION:\n\t\t\t\t\t\tif (!rdp_read_window_activation_capability_set(s, length, settings))\n\t\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase CAPSET_TYPE_DRAW_NINE_GRID_CACHE:\n\t\t\t\t\t\tif (!rdp_read_draw_nine_grid_cache_capability_set(s, length, settings))\n\t\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tWLog_ERR(TAG, \"capability %s(%\" PRIu16 \") not expected from client\",\n\t\t\t\t\t\t         get_capability_name(type), type);\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* treating capabilities that are supposed to be send only from the server */\n\t\t\t\tswitch (type)\n\t\t\t\t{\n\t\t\t\t\tcase CAPSET_TYPE_BITMAP_CACHE_HOST_SUPPORT:\n\t\t\t\t\t\tif (!rdp_read_bitmap_cache_host_support_capability_set(s, length, settings))\n\t\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tWLog_ERR(TAG, \"capability %s(%\" PRIu16 \") not expected from server\",\n\t\t\t\t\t\t         get_capability_name(type), type);\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (Stream_Pointer(s) != em)\n\t\t{\n\t\t\tWLog_ERR(TAG,\n\t\t\t         \"incorrect offset, type:0x%04\" PRIX16 \" actual:%\" PRIuz \" expected:%\" PRIuz \"\",\n\t\t\t         type, Stream_Pointer(s) - bm, em - bm);\n\t\t\tStream_SetPointer(s, em);\n\t\t}\n\n\t\tnumberCapabilities--;\n\t}\n\n\tend = Stream_GetPosition(s);\n\tlen = end - start;\n\n\tif (numberCapabilities)\n\t{\n\t\tWLog_ERR(TAG,\n\t\t         \"strange we haven't read the number of announced capacity sets, read=%d \"\n\t\t         \"expected=%\" PRIu16 \"\",\n\t\t         count - numberCapabilities, count);\n\t}\n\n#ifdef WITH_DEBUG_CAPABILITIES\n\t{\n\t\tStream_SetPosition(s, start);\n\t\tnumberCapabilities = count;\n\t\trdp_print_capability_sets(s, numberCapabilities, TRUE);\n\t\tStream_SetPosition(s, end);\n\t}\n#endif\n\n\tif (len > totalLength)\n\t{\n\t\tWLog_ERR(TAG, \"Capability length expected %\" PRIu16 \", actual %\" PRIdz, totalLength, len);\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nBOOL rdp_recv_get_active_header(rdpRdp* rdp, wStream* s, UINT16* pChannelId, UINT16* length)\n{\n\tUINT16 securityFlags = 0;\n\n\tif (!rdp_read_header(rdp, s, length, pChannelId))\n\t\treturn FALSE;\n\n\tif (freerdp_shall_disconnect(rdp->instance))\n\t\treturn TRUE;\n\n\tif (rdp->settings->UseRdpSecurityLayer)\n\t{\n\t\tif (!rdp_read_security_header(s, &securityFlags, length))\n\t\t\treturn FALSE;\n\n\t\tif (securityFlags & SEC_ENCRYPT)\n\t\t{\n\t\t\tif (!rdp_decrypt(rdp, s, length, securityFlags))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdp_decrypt failed\");\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (*pChannelId != MCS_GLOBAL_CHANNEL_ID)\n\t{\n\t\tUINT16 mcsMessageChannelId = rdp->mcs->messageChannelId;\n\n\t\tif ((mcsMessageChannelId == 0) || (*pChannelId != mcsMessageChannelId))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"unexpected MCS channel id %04\" PRIx16 \" received\", *pChannelId);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\nBOOL rdp_recv_demand_active(rdpRdp* rdp, wStream* s)\n{\n\tUINT16 channelId;\n\tUINT16 pduType;\n\tUINT16 pduLength;\n\tUINT16 pduSource;\n\tUINT16 length;\n\tUINT16 numberCapabilities;\n\tUINT16 lengthSourceDescriptor;\n\tUINT16 lengthCombinedCapabilities;\n\n\tif (!rdp_recv_get_active_header(rdp, s, &channelId, &length))\n\t\treturn FALSE;\n\n\tif (freerdp_shall_disconnect(rdp->instance))\n\t\treturn TRUE;\n\n\tif (!rdp_read_share_control_header(s, &pduLength, &pduType, &pduSource))\n\t{\n\t\tWLog_ERR(TAG, \"rdp_read_share_control_header failed\");\n\t\treturn FALSE;\n\t}\n\n\tif (pduType == PDU_TYPE_DATA)\n\t{\n\t\t/**\n\t\t * We can receive a Save Session Info Data PDU containing a LogonErrorInfo\n\t\t * structure at this point from the server to indicate a connection error.\n\t\t */\n\t\tif (rdp_recv_data_pdu(rdp, s) < 0)\n\t\t\treturn FALSE;\n\n\t\treturn FALSE;\n\t}\n\n\tif (pduType != PDU_TYPE_DEMAND_ACTIVE)\n\t{\n\t\tif (pduType != PDU_TYPE_SERVER_REDIRECTION)\n\t\t\tWLog_ERR(TAG, \"expected PDU_TYPE_DEMAND_ACTIVE %04x, got %04\" PRIx16 \"\",\n\t\t\t         PDU_TYPE_DEMAND_ACTIVE, pduType);\n\n\t\treturn FALSE;\n\t}\n\n\trdp->settings->PduSource = pduSource;\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, rdp->settings->ShareId);     /* shareId (4 bytes) */\n\tStream_Read_UINT16(s, lengthSourceDescriptor);     /* lengthSourceDescriptor (2 bytes) */\n\tStream_Read_UINT16(s, lengthCombinedCapabilities); /* lengthCombinedCapabilities (2 bytes) */\n\n\tif (!Stream_SafeSeek(s, lengthSourceDescriptor) ||\n\t    Stream_GetRemainingLength(s) < 4) /* sourceDescriptor */\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, numberCapabilities); /* numberCapabilities (2 bytes) */\n\tStream_Seek(s, 2);                         /* pad2Octets (2 bytes) */\n\n\t/* capabilitySets */\n\tif (!rdp_read_capability_sets(s, rdp->settings, numberCapabilities, lengthCombinedCapabilities))\n\t{\n\t\tWLog_ERR(TAG, \"rdp_read_capability_sets failed\");\n\t\treturn FALSE;\n\t}\n\n\tif (!Stream_SafeSeek(s, 4)) /* SessionId */\n\t\treturn FALSE;\n\n\trdp->update->secondary->glyph_v2 = (rdp->settings->GlyphSupportLevel > GLYPH_SUPPORT_FULL);\n\treturn tpkt_ensure_stream_consumed(s, length);\n}\n\nstatic BOOL rdp_write_demand_active(wStream* s, rdpSettings* settings)\n{\n\tsize_t bm, em, lm;\n\tUINT16 numberCapabilities;\n\tsize_t lengthCombinedCapabilities;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 64))\n\t\treturn FALSE;\n\n\tStream_Write_UINT32(s, settings->ShareId); /* shareId (4 bytes) */\n\tStream_Write_UINT16(s, 4);                 /* lengthSourceDescriptor (2 bytes) */\n\tlm = Stream_GetPosition(s);\n\tStream_Seek_UINT16(s);     /* lengthCombinedCapabilities (2 bytes) */\n\tStream_Write(s, \"RDP\", 4); /* sourceDescriptor */\n\tbm = Stream_GetPosition(s);\n\tStream_Seek_UINT16(s);     /* numberCapabilities (2 bytes) */\n\tStream_Write_UINT16(s, 0); /* pad2Octets (2 bytes) */\n\tnumberCapabilities = 14;\n\n\tif (!rdp_write_general_capability_set(s, settings) ||\n\t    !rdp_write_bitmap_capability_set(s, settings) ||\n\t    !rdp_write_order_capability_set(s, settings) ||\n\t    !rdp_write_pointer_capability_set(s, settings) ||\n\t    !rdp_write_input_capability_set(s, settings) ||\n\t    !rdp_write_virtual_channel_capability_set(s, settings) ||\n\t    !rdp_write_share_capability_set(s, settings) ||\n\t    !rdp_write_font_capability_set(s, settings) ||\n\t    !rdp_write_multifragment_update_capability_set(s, settings) ||\n\t    !rdp_write_large_pointer_capability_set(s, settings) ||\n\t    !rdp_write_desktop_composition_capability_set(s, settings) ||\n\t    !rdp_write_surface_commands_capability_set(s, settings) ||\n\t    !rdp_write_bitmap_codecs_capability_set(s, settings) ||\n\t    !rdp_write_frame_acknowledge_capability_set(s, settings))\n\t{\n\t\treturn FALSE;\n\t}\n\n\tif (settings->BitmapCachePersistEnabled)\n\t{\n\t\tnumberCapabilities++;\n\n\t\tif (!rdp_write_bitmap_cache_host_support_capability_set(s, settings))\n\t\t\treturn FALSE;\n\t}\n\n\tif (settings->RemoteApplicationMode)\n\t{\n\t\tnumberCapabilities += 2;\n\n\t\tif (!rdp_write_remote_programs_capability_set(s, settings) ||\n\t\t    !rdp_write_window_list_capability_set(s, settings))\n\t\t\treturn FALSE;\n\t}\n\n\tem = Stream_GetPosition(s);\n\tStream_SetPosition(s, lm); /* go back to lengthCombinedCapabilities */\n\tlengthCombinedCapabilities = (em - bm);\n\tif (lengthCombinedCapabilities > UINT16_MAX)\n\t\treturn FALSE;\n\tStream_Write_UINT16(\n\t    s, (UINT16)lengthCombinedCapabilities);         /* lengthCombinedCapabilities (2 bytes) */\n\tStream_SetPosition(s, bm);                          /* go back to numberCapabilities */\n\tStream_Write_UINT16(s, numberCapabilities);         /* numberCapabilities (2 bytes) */\n#ifdef WITH_DEBUG_CAPABILITIES\n\tStream_Seek_UINT16(s);\n\trdp_print_capability_sets(s, numberCapabilities, FALSE);\n\tStream_SetPosition(s, bm);\n\tStream_Seek_UINT16(s);\n#endif\n\tStream_SetPosition(s, em);\n\tStream_Write_UINT32(s, 0); /* sessionId */\n\treturn TRUE;\n}\n\nBOOL rdp_send_demand_active(rdpRdp* rdp)\n{\n\twStream* s = rdp_send_stream_pdu_init(rdp);\n\tBOOL status;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\trdp->settings->ShareId = 0x10000 + rdp->mcs->userId;\n\tstatus = rdp_write_demand_active(s, rdp->settings) &&\n\t         rdp_send_pdu(rdp, s, PDU_TYPE_DEMAND_ACTIVE, rdp->mcs->userId);\n\tStream_Release(s);\n\treturn status;\n}\n\nBOOL rdp_recv_confirm_active(rdpRdp* rdp, wStream* s, UINT16 pduLength)\n{\n\trdpSettings* settings;\n\tUINT16 lengthSourceDescriptor;\n\tUINT16 lengthCombinedCapabilities;\n\tUINT16 numberCapabilities;\n\tsettings = rdp->settings;\n\n\tif (Stream_GetRemainingLength(s) < 10)\n\t\treturn FALSE;\n\n\tStream_Seek_UINT32(s);                             /* shareId (4 bytes) */\n\tStream_Seek_UINT16(s);                             /* originatorId (2 bytes) */\n\tStream_Read_UINT16(s, lengthSourceDescriptor);     /* lengthSourceDescriptor (2 bytes) */\n\tStream_Read_UINT16(s, lengthCombinedCapabilities); /* lengthCombinedCapabilities (2 bytes) */\n\n\tif (Stream_GetRemainingLength(s) < lengthSourceDescriptor + 4U)\n\t\treturn FALSE;\n\n\tStream_Seek(s, lengthSourceDescriptor);    /* sourceDescriptor */\n\tStream_Read_UINT16(s, numberCapabilities); /* numberCapabilities (2 bytes) */\n\tStream_Seek(s, 2);                         /* pad2Octets (2 bytes) */\n\tif (!rdp_read_capability_sets(s, rdp->settings, numberCapabilities, lengthCombinedCapabilities))\n\t\treturn FALSE;\n\n\tif (!settings->ReceivedCapabilities[CAPSET_TYPE_SURFACE_COMMANDS])\n\t{\n\t\t/* client does not support surface commands */\n\t\tsettings->SurfaceCommandsEnabled = FALSE;\n\t\tsettings->SurfaceFrameMarkerEnabled = FALSE;\n\t}\n\n\tif (!settings->ReceivedCapabilities[CAPSET_TYPE_FRAME_ACKNOWLEDGE])\n\t{\n\t\t/* client does not support frame acks */\n\t\tsettings->FrameAcknowledge = 0;\n\t}\n\n\tif (!settings->ReceivedCapabilities[CAPSET_TYPE_BITMAP_CACHE_V3_CODEC_ID])\n\t{\n\t\t/* client does not support bitmap cache v3 */\n\t\tsettings->BitmapCacheV3Enabled = FALSE;\n\t}\n\n\tif (!settings->ReceivedCapabilities[CAPSET_TYPE_BITMAP_CODECS])\n\t{\n\t\t/* client does not support bitmap codecs */\n\t\tsettings->RemoteFxCodec = FALSE;\n\t\tsettings->NSCodec = FALSE;\n\t\tsettings->JpegCodec = FALSE;\n\t}\n\n\tif (!settings->ReceivedCapabilities[CAPSET_TYPE_MULTI_FRAGMENT_UPDATE])\n\t{\n\t\t/* client does not support multi fragment updates - make sure packages are not fragmented */\n\t\tsettings->MultifragMaxRequestSize = FASTPATH_FRAGMENT_SAFE_SIZE;\n\t}\n\n\tif (!settings->ReceivedCapabilities[CAPSET_TYPE_LARGE_POINTER])\n\t{\n\t\t/* client does not support large pointers */\n\t\tsettings->LargePointerFlag = 0;\n\t}\n\n\treturn tpkt_ensure_stream_consumed(s, pduLength);\n}\n\nstatic BOOL rdp_write_confirm_active(wStream* s, rdpSettings* settings)\n{\n\tsize_t bm, em, lm;\n\tUINT16 numberCapabilities;\n\tUINT16 lengthSourceDescriptor;\n\tsize_t lengthCombinedCapabilities;\n\tBOOL ret;\n\tlengthSourceDescriptor = sizeof(SOURCE_DESCRIPTOR);\n\tStream_Write_UINT32(s, settings->ShareId);      /* shareId (4 bytes) */\n\tStream_Write_UINT16(s, 0x03EA);                 /* originatorId (2 bytes) */\n\tStream_Write_UINT16(s, lengthSourceDescriptor); /* lengthSourceDescriptor (2 bytes) */\n\tlm = Stream_GetPosition(s);\n\tStream_Seek_UINT16(s); /* lengthCombinedCapabilities (2 bytes) */\n\tStream_Write(s, SOURCE_DESCRIPTOR, lengthSourceDescriptor); /* sourceDescriptor */\n\tbm = Stream_GetPosition(s);\n\tStream_Seek_UINT16(s);     /* numberCapabilities (2 bytes) */\n\tStream_Write_UINT16(s, 0); /* pad2Octets (2 bytes) */\n\t/* Capability Sets */\n\tnumberCapabilities = 15;\n\n\tif (!rdp_write_general_capability_set(s, settings) ||\n\t    !rdp_write_bitmap_capability_set(s, settings) ||\n\t    !rdp_write_order_capability_set(s, settings))\n\t\treturn FALSE;\n\n\tif (settings->RdpVersion >= RDP_VERSION_5_PLUS)\n\t\tret = rdp_write_bitmap_cache_v2_capability_set(s, settings);\n\telse\n\t\tret = rdp_write_bitmap_cache_capability_set(s, settings);\n\n\tif (!ret)\n\t\treturn FALSE;\n\n\tif (!rdp_write_pointer_capability_set(s, settings) ||\n\t    !rdp_write_input_capability_set(s, settings) ||\n\t    !rdp_write_brush_capability_set(s, settings) ||\n\t    !rdp_write_glyph_cache_capability_set(s, settings) ||\n\t    !rdp_write_virtual_channel_capability_set(s, settings) ||\n\t    !rdp_write_sound_capability_set(s, settings) ||\n\t    !rdp_write_share_capability_set(s, settings) ||\n\t    !rdp_write_font_capability_set(s, settings) ||\n\t    !rdp_write_control_capability_set(s, settings) ||\n\t    !rdp_write_color_cache_capability_set(s, settings) ||\n\t    !rdp_write_window_activation_capability_set(s, settings))\n\t{\n\t\treturn FALSE;\n\t}\n\n\tif (settings->OffscreenSupportLevel)\n\t{\n\t\tnumberCapabilities++;\n\n\t\tif (!rdp_write_offscreen_bitmap_cache_capability_set(s, settings))\n\t\t\treturn FALSE;\n\t}\n\n\tif (settings->DrawNineGridEnabled)\n\t{\n\t\tnumberCapabilities++;\n\n\t\tif (!rdp_write_draw_nine_grid_cache_capability_set(s, settings))\n\t\t\treturn FALSE;\n\t}\n\n\tif (settings->ReceivedCapabilities[CAPSET_TYPE_LARGE_POINTER])\n\t{\n\t\tif (settings->LargePointerFlag)\n\t\t{\n\t\t\tnumberCapabilities++;\n\n\t\t\tif (!rdp_write_large_pointer_capability_set(s, settings))\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\tif (settings->RemoteApplicationMode)\n\t{\n\t\tnumberCapabilities += 2;\n\n\t\tif (!rdp_write_remote_programs_capability_set(s, settings) ||\n\t\t    !rdp_write_window_list_capability_set(s, settings))\n\t\t\treturn FALSE;\n\t}\n\n\tif (settings->ReceivedCapabilities[CAPSET_TYPE_MULTI_FRAGMENT_UPDATE])\n\t{\n\t\tnumberCapabilities++;\n\n\t\tif (!rdp_write_multifragment_update_capability_set(s, settings))\n\t\t\treturn FALSE;\n\t}\n\n\tif (settings->ReceivedCapabilities[CAPSET_TYPE_SURFACE_COMMANDS])\n\t{\n\t\tnumberCapabilities++;\n\n\t\tif (!rdp_write_surface_commands_capability_set(s, settings))\n\t\t\treturn FALSE;\n\t}\n\n\tif (settings->ReceivedCapabilities[CAPSET_TYPE_BITMAP_CODECS])\n\t{\n\t\tnumberCapabilities++;\n\n\t\tif (!rdp_write_bitmap_codecs_capability_set(s, settings))\n\t\t\treturn FALSE;\n\t}\n\n\tif (!settings->ReceivedCapabilities[CAPSET_TYPE_FRAME_ACKNOWLEDGE])\n\t\tsettings->FrameAcknowledge = 0;\n\n\tif (settings->FrameAcknowledge)\n\t{\n\t\tnumberCapabilities++;\n\n\t\tif (!rdp_write_frame_acknowledge_capability_set(s, settings))\n\t\t\treturn FALSE;\n\t}\n\n\tif (settings->ReceivedCapabilities[CAPSET_TYPE_BITMAP_CACHE_V3_CODEC_ID])\n\t{\n\t\tif (settings->BitmapCacheV3CodecId != 0)\n\t\t{\n\t\t\tnumberCapabilities++;\n\n\t\t\tif (!rdp_write_bitmap_cache_v3_codec_id_capability_set(s, settings))\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\tem = Stream_GetPosition(s);\n\tStream_SetPosition(s, lm); /* go back to lengthCombinedCapabilities */\n\tlengthCombinedCapabilities = (em - bm);\n\tif (lengthCombinedCapabilities > UINT16_MAX)\n\t\treturn FALSE;\n\tStream_Write_UINT16(\n\t    s, (UINT16)lengthCombinedCapabilities);         /* lengthCombinedCapabilities (2 bytes) */\n\tStream_SetPosition(s, bm);                          /* go back to numberCapabilities */\n\tStream_Write_UINT16(s, numberCapabilities);         /* numberCapabilities (2 bytes) */\n#ifdef WITH_DEBUG_CAPABILITIES\n\tStream_Seek_UINT16(s);\n\trdp_print_capability_sets(s, numberCapabilities, FALSE);\n\tStream_SetPosition(s, bm);\n\tStream_Seek_UINT16(s);\n#endif\n\tStream_SetPosition(s, em);\n\n\treturn TRUE;\n}\n\nBOOL rdp_send_confirm_active(rdpRdp* rdp)\n{\n\twStream* s = rdp_send_stream_pdu_init(rdp);\n\tBOOL status;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tstatus = rdp_write_confirm_active(s, rdp->settings) &&\n\t         rdp_send_pdu(rdp, s, PDU_TYPE_CONFIRM_ACTIVE, rdp->mcs->userId);\n\tStream_Release(s);\n\treturn status;\n}\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * T.124 Generic Conference Control (GCC)\n *\n * Copyright 2011 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2014 Norbert Federa <norbert.federa@thincast.com>\n * Copyright 2014 DI (FH) Martin Haimberger <martin.haimberger@thincast.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <winpr/crt.h>\n#include <winpr/crypto.h>\n\n#include <freerdp/log.h>\n\n#include \"gcc.h\"\n#include \"certificate.h\"\n\n#define TAG FREERDP_TAG(\"core.gcc\")\n\nstatic BOOL gcc_read_client_cluster_data(wStream* s, rdpMcs* mcs, UINT16 blockLength);\nstatic BOOL gcc_read_client_core_data(wStream* s, rdpMcs* mcs, UINT16 blockLength);\nstatic BOOL gcc_read_client_data_blocks(wStream* s, rdpMcs* mcs, int length);\nstatic BOOL gcc_read_server_data_blocks(wStream* s, rdpMcs* mcs, int length);\nstatic BOOL gcc_read_user_data_header(wStream* s, UINT16* type, UINT16* length);\nstatic void gcc_write_user_data_header(wStream* s, UINT16 type, UINT16 length);\n\nstatic void gcc_write_client_core_data(wStream* s, rdpMcs* mcs);\nstatic BOOL gcc_read_server_core_data(wStream* s, rdpMcs* mcs);\nstatic BOOL gcc_write_server_core_data(wStream* s, rdpMcs* mcs);\nstatic BOOL gcc_read_client_security_data(wStream* s, rdpMcs* mcs, UINT16 blockLength);\nstatic void gcc_write_client_security_data(wStream* s, rdpMcs* mcs);\nstatic BOOL gcc_read_server_security_data(wStream* s, rdpMcs* mcs);\nstatic BOOL gcc_write_server_security_data(wStream* s, rdpMcs* mcs);\nstatic BOOL gcc_read_client_network_data(wStream* s, rdpMcs* mcs, UINT16 blockLength);\nstatic void gcc_write_client_network_data(wStream* s, rdpMcs* mcs);\nstatic BOOL gcc_read_server_network_data(wStream* s, rdpMcs* mcs);\nstatic BOOL gcc_write_server_network_data(wStream* s, rdpMcs* mcs);\nstatic void gcc_write_client_cluster_data(wStream* s, rdpMcs* mcs);\nstatic BOOL gcc_read_client_monitor_data(wStream* s, rdpMcs* mcs, UINT16 blockLength);\nstatic void gcc_write_client_monitor_data(wStream* s, rdpMcs* mcs);\nstatic BOOL gcc_read_client_monitor_extended_data(wStream* s, rdpMcs* mcs, UINT16 blockLength);\nstatic void gcc_write_client_monitor_extended_data(wStream* s, rdpMcs* mcs);\nstatic BOOL gcc_read_client_message_channel_data(wStream* s, rdpMcs* mcs, UINT16 blockLength);\nstatic void gcc_write_client_message_channel_data(wStream* s, rdpMcs* mcs);\nstatic BOOL gcc_read_server_message_channel_data(wStream* s, rdpMcs* mcs);\nstatic BOOL gcc_write_server_message_channel_data(wStream* s, rdpMcs* mcs);\nstatic BOOL gcc_read_client_multitransport_channel_data(wStream* s, rdpMcs* mcs,\n                                                        UINT16 blockLength);\nstatic void gcc_write_client_multitransport_channel_data(wStream* s, rdpMcs* mcs);\nstatic BOOL gcc_read_server_multitransport_channel_data(wStream* s, rdpMcs* mcs);\nstatic void gcc_write_server_multitransport_channel_data(wStream* s, rdpMcs* mcs);\n\nstatic DWORD rdp_version_common(DWORD serverVersion, DWORD clientVersion)\n{\n\tDWORD version = MIN(serverVersion, clientVersion);\n\n\tswitch (version)\n\t{\n\t\tcase RDP_VERSION_4:\n\t\tcase RDP_VERSION_5_PLUS:\n\t\tcase RDP_VERSION_10_0:\n\t\tcase RDP_VERSION_10_1:\n\t\tcase RDP_VERSION_10_2:\n\t\tcase RDP_VERSION_10_3:\n\t\tcase RDP_VERSION_10_4:\n\t\tcase RDP_VERSION_10_5:\n\t\tcase RDP_VERSION_10_6:\n\t\tcase RDP_VERSION_10_7:\n\t\t\treturn version;\n\n\t\tdefault:\n\t\t\tWLog_ERR(TAG, \"Invalid client [%\" PRId32 \"] and server [%\" PRId32 \"] versions\",\n\t\t\t         serverVersion, clientVersion);\n\t\t\treturn version;\n\t}\n}\n\n/**\n * T.124 GCC is defined in:\n *\n * http://www.itu.int/rec/T-REC-T.124-199802-S/en\n * ITU-T T.124 (02/98): Generic Conference Control\n */\n\n/**\n * ConnectData ::= SEQUENCE\n * {\n * \tt124Identifier\tKey,\n * \tconnectPDU\tOCTET_STRING\n * }\n *\n * Key ::= CHOICE\n * {\n * \tobject\t\t\t\tOBJECT_IDENTIFIER,\n * \th221NonStandard\t\t\tH221NonStandardIdentifier\n * }\n *\n * ConnectGCCPDU ::= CHOICE\n * {\n * \tconferenceCreateRequest\t\tConferenceCreateRequest,\n * \tconferenceCreateResponse\tConferenceCreateResponse,\n * \tconferenceQueryRequest\t\tConferenceQueryRequest,\n * \tconferenceQueryResponse\t\tConferenceQueryResponse,\n * \tconferenceJoinRequest\t\tConferenceJoinRequest,\n *\tconferenceJoinResponse\t\tConferenceJoinResponse,\n *\tconferenceInviteRequest\t\tConferenceInviteRequest,\n *\tconferenceInviteResponse\tConferenceInviteResponse,\n *\t...\n * }\n *\n * ConferenceCreateRequest ::= SEQUENCE\n * {\n * \tconferenceName\t\t\tConferenceName,\n * \tconvenerPassword\t\tPassword OPTIONAL,\n * \tpassword\t\t\tPassword OPTIONAL,\n * \tlockedConference\t\tBOOLEAN,\n * \tlistedConference\t\tBOOLEAN,\n * \tconductibleConference\t\tBOOLEAN,\n * \tterminationMethod\t\tTerminationMethod,\n * \tconductorPrivileges\t\tSET OF Privilege OPTIONAL,\n * \tconductedPrivileges\t\tSET OF Privilege OPTIONAL,\n * \tnonConductedPrivileges\t\tSET OF Privilege OPTIONAL,\n * \tconferenceDescription\t\tTextString OPTIONAL,\n * \tcallerIdentifier\t\tTextString OPTIONAL,\n * \tuserData\t\t\tUserData OPTIONAL,\n * \t...,\n * \tconferencePriority\t\tConferencePriority OPTIONAL,\n * \tconferenceMode\t\t\tConferenceMode OPTIONAL\n * }\n *\n * ConferenceCreateResponse ::= SEQUENCE\n * {\n * \tnodeID\t\t\t\tUserID,\n * \ttag\t\t\t\tINTEGER,\n * \tresult\t\t\t\tENUMERATED\n * \t{\n * \t\tsuccess\t\t\t\t(0),\n * \t\tuserRejected\t\t\t(1),\n * \t\tresourcesNotAvailable\t\t(2),\n * \t\trejectedForSymmetryBreaking\t(3),\n * \t\tlockedConferenceNotSupported\t(4)\n * \t},\n * \tuserData\t\t\tUserData OPTIONAL,\n * \t...\n * }\n *\n * ConferenceName ::= SEQUENCE\n * {\n * \tnumeric\t\t\t\tSimpleNumericString\n * \ttext\t\t\t\tSimpleTextString OPTIONAL,\n * \t...\n * }\n *\n * SimpleNumericString ::= NumericString (SIZE (1..255)) (FROM (\"0123456789\"))\n *\n * UserData ::= SET OF SEQUENCE\n * {\n * \tkey\t\t\t\tKey,\n * \tvalue\t\t\t\tOCTET_STRING OPTIONAL\n * }\n *\n * H221NonStandardIdentifier ::= OCTET STRING (SIZE (4..255))\n *\n * UserID ::= DynamicChannelID\n *\n * ChannelID ::= INTEGER (1..65535)\n * StaticChannelID ::= INTEGER (1..1000)\n * DynamicChannelID ::= INTEGER (1001..65535)\n *\n */\n\n/*\n * OID = 0.0.20.124.0.1\n * { itu-t(0) recommendation(0) t(20) t124(124) version(0) 1 }\n * v.1 of ITU-T Recommendation T.124 (Feb 1998): \"Generic Conference Control\"\n */\nBYTE t124_02_98_oid[6] = { 0, 0, 20, 124, 0, 1 };\n\nBYTE h221_cs_key[4] = \"Duca\";\nBYTE h221_sc_key[4] = \"McDn\";\n\n/**\n * Read a GCC Conference Create Request.\\n\n * @msdn{cc240836}\n * @param s stream\n * @param settings rdp settings\n */\n\nBOOL gcc_read_conference_create_request(wStream* s, rdpMcs* mcs)\n{\n\tUINT16 length;\n\tBYTE choice;\n\tBYTE number;\n\tBYTE selection;\n\n\t/* ConnectData */\n\tif (!per_read_choice(s, &choice))\n\t\treturn FALSE;\n\n\tif (!per_read_object_identifier(s, t124_02_98_oid))\n\t\treturn FALSE;\n\n\t/* ConnectData::connectPDU (OCTET_STRING) */\n\tif (!per_read_length(s, &length))\n\t\treturn FALSE;\n\n\t/* ConnectGCCPDU */\n\tif (!per_read_choice(s, &choice))\n\t\treturn FALSE;\n\n\tif (!per_read_selection(s, &selection))\n\t\treturn FALSE;\n\n\t/* ConferenceCreateRequest::conferenceName */\n\tif (!per_read_numeric_string(s, 1)) /* ConferenceName::numeric */\n\t\treturn FALSE;\n\n\tif (!per_read_padding(s, 1)) /* padding */\n\t\treturn FALSE;\n\n\t/* UserData (SET OF SEQUENCE) */\n\tif (!per_read_number_of_sets(s, &number) || number != 1) /* one set of UserData */\n\t\treturn FALSE;\n\n\tif (!per_read_choice(s, &choice) ||\n\t    choice != 0xC0) /* UserData::value present + select h221NonStandard (1) */\n\t\treturn FALSE;\n\n\t/* h221NonStandard */\n\tif (!per_read_octet_string(s, h221_cs_key, 4,\n\t                           4)) /* h221NonStandard, client-to-server H.221 key, \"Duca\" */\n\t\treturn FALSE;\n\n\t/* userData::value (OCTET_STRING) */\n\tif (!per_read_length(s, &length))\n\t\treturn FALSE;\n\n\tif (Stream_GetRemainingLength(s) < length)\n\t\treturn FALSE;\n\n\tif (!gcc_read_client_data_blocks(s, mcs, length))\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\n/**\n * Write a GCC Conference Create Request.\\n\n * @msdn{cc240836}\n * @param s stream\n * @param user_data client data blocks\n */\n\nvoid gcc_write_conference_create_request(wStream* s, wStream* userData)\n{\n\t/* ConnectData */\n\tper_write_choice(s, 0); /* From Key select object (0) of type OBJECT_IDENTIFIER */\n\tper_write_object_identifier(s, t124_02_98_oid); /* ITU-T T.124 (02/98) OBJECT_IDENTIFIER */\n\t/* ConnectData::connectPDU (OCTET_STRING) */\n\tper_write_length(s, Stream_GetPosition(userData) + 14); /* connectPDU length */\n\t/* ConnectGCCPDU */\n\tper_write_choice(s, 0);       /* From ConnectGCCPDU select conferenceCreateRequest (0) of type\n\t                                 ConferenceCreateRequest */\n\tper_write_selection(s, 0x08); /* select optional userData from ConferenceCreateRequest */\n\t/* ConferenceCreateRequest::conferenceName */\n\tper_write_numeric_string(s, (BYTE*)\"1\", 1, 1); /* ConferenceName::numeric */\n\tper_write_padding(s, 1);                       /* padding */\n\t/* UserData (SET OF SEQUENCE) */\n\tper_write_number_of_sets(s, 1); /* one set of UserData */\n\tper_write_choice(s, 0xC0);      /* UserData::value present + select h221NonStandard (1) */\n\t/* h221NonStandard */\n\tper_write_octet_string(s, h221_cs_key, 4,\n\t                       4); /* h221NonStandard, client-to-server H.221 key, \"Duca\" */\n\t/* userData::value (OCTET_STRING) */\n\tper_write_octet_string(s, Stream_Buffer(userData), Stream_GetPosition(userData),\n\t                       0); /* array of client data blocks */\n}\n\nBOOL gcc_read_conference_create_response(wStream* s, rdpMcs* mcs)\n{\n\tUINT16 length;\n\tUINT32 tag;\n\tUINT16 nodeID;\n\tBYTE result;\n\tBYTE choice;\n\tBYTE number;\n\n\t/* ConnectData */\n\tif (!per_read_choice(s, &choice) || !per_read_object_identifier(s, t124_02_98_oid))\n\t\treturn FALSE;\n\n\t/* ConnectData::connectPDU (OCTET_STRING) */\n\tif (!per_read_length(s, &length))\n\t\treturn FALSE;\n\n\t/* ConnectGCCPDU */\n\tif (!per_read_choice(s, &choice))\n\t\treturn FALSE;\n\n\t/* ConferenceCreateResponse::nodeID (UserID) */\n\tif (!per_read_integer16(s, &nodeID, 1001))\n\t\treturn FALSE;\n\n\t/* ConferenceCreateResponse::tag (INTEGER) */\n\tif (!per_read_integer(s, &tag))\n\t\treturn FALSE;\n\n\t/* ConferenceCreateResponse::result (ENUMERATED) */\n\tif (!per_read_enumerated(s, &result, MCS_Result_enum_length))\n\t\treturn FALSE;\n\n\t/* number of UserData sets */\n\tif (!per_read_number_of_sets(s, &number))\n\t\treturn FALSE;\n\n\t/* UserData::value present + select h221NonStandard (1) */\n\tif (!per_read_choice(s, &choice))\n\t\treturn FALSE;\n\n\t/* h221NonStandard */\n\tif (!per_read_octet_string(s, h221_sc_key, 4,\n\t                           4)) /* h221NonStandard, server-to-client H.221 key, \"McDn\" */\n\t\treturn FALSE;\n\n\t/* userData (OCTET_STRING) */\n\tif (!per_read_length(s, &length))\n\t\treturn FALSE;\n\n\tif (!gcc_read_server_data_blocks(s, mcs, length))\n\t{\n\t\tWLog_ERR(TAG, \"gcc_read_conference_create_response: gcc_read_server_data_blocks failed\");\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nvoid gcc_write_conference_create_response(wStream* s, wStream* userData)\n{\n\t/* ConnectData */\n\tper_write_choice(s, 0);\n\tper_write_object_identifier(s, t124_02_98_oid);\n\t/* ConnectData::connectPDU (OCTET_STRING) */\n\t/* This length MUST be ignored by the client according to [MS-RDPBCGR] */\n\tper_write_length(s, 0x2A);\n\t/* ConnectGCCPDU */\n\tper_write_choice(s, 0x14);\n\t/* ConferenceCreateResponse::nodeID (UserID) */\n\tper_write_integer16(s, 0x79F3, 1001);\n\t/* ConferenceCreateResponse::tag (INTEGER) */\n\tper_write_integer(s, 1);\n\t/* ConferenceCreateResponse::result (ENUMERATED) */\n\tper_write_enumerated(s, 0, MCS_Result_enum_length);\n\t/* number of UserData sets */\n\tper_write_number_of_sets(s, 1);\n\t/* UserData::value present + select h221NonStandard (1) */\n\tper_write_choice(s, 0xC0);\n\t/* h221NonStandard */\n\tper_write_octet_string(s, h221_sc_key, 4,\n\t                       4); /* h221NonStandard, server-to-client H.221 key, \"McDn\" */\n\t/* userData (OCTET_STRING) */\n\tper_write_octet_string(s, Stream_Buffer(userData), Stream_GetPosition(userData),\n\t                       0); /* array of server data blocks */\n}\n\nBOOL gcc_read_client_data_blocks(wStream* s, rdpMcs* mcs, int length)\n{\n\tUINT16 type;\n\tUINT16 blockLength;\n\tsize_t begPos, endPos;\n\n\twhile (length > 0)\n\t{\n\t\tbegPos = Stream_GetPosition(s);\n\n\t\tif (!gcc_read_user_data_header(s, &type, &blockLength))\n\t\t\treturn FALSE;\n\n\t\tif (Stream_GetRemainingLength(s) < (size_t)(blockLength - 4))\n\t\t\treturn FALSE;\n\n\t\tswitch (type)\n\t\t{\n\t\t\tcase CS_CORE:\n\t\t\t\tif (!gcc_read_client_core_data(s, mcs, blockLength - 4))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CS_SECURITY:\n\t\t\t\tif (!gcc_read_client_security_data(s, mcs, blockLength - 4))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CS_NET:\n\t\t\t\tif (!gcc_read_client_network_data(s, mcs, blockLength - 4))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CS_CLUSTER:\n\t\t\t\tif (!gcc_read_client_cluster_data(s, mcs, blockLength - 4))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CS_MONITOR:\n\t\t\t\tif (!gcc_read_client_monitor_data(s, mcs, blockLength - 4))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CS_MCS_MSGCHANNEL:\n\t\t\t\tif (!gcc_read_client_message_channel_data(s, mcs, blockLength - 4))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CS_MONITOR_EX:\n\t\t\t\tif (!gcc_read_client_monitor_extended_data(s, mcs, blockLength - 4))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase 0xC009:\n\t\t\tcase CS_MULTITRANSPORT:\n\t\t\t\tif (!gcc_read_client_multitransport_channel_data(s, mcs, blockLength - 4))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tWLog_ERR(TAG, \"Unknown GCC client data block: 0x%04\" PRIX16 \"\", type);\n\t\t\t\tStream_Seek(s, blockLength - 4);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tendPos = Stream_GetPosition(s);\n\n\t\tif (endPos != (begPos + blockLength))\n\t\t{\n\t\t\tWLog_ERR(TAG,\n\t\t\t         \"Error parsing GCC client data block 0x%04\" PRIX16\n\t\t\t         \": Actual Offset: %d Expected Offset: %d\",\n\t\t\t         type, endPos, begPos + blockLength);\n\t\t}\n\n\t\tlength -= blockLength;\n\t\tStream_SetPosition(s, begPos + blockLength);\n\t}\n\n\treturn TRUE;\n}\n\nvoid gcc_write_client_data_blocks(wStream* s, rdpMcs* mcs)\n{\n\trdpSettings* settings = mcs->settings;\n\tgcc_write_client_core_data(s, mcs);\n\tgcc_write_client_cluster_data(s, mcs);\n\tgcc_write_client_security_data(s, mcs);\n\tgcc_write_client_network_data(s, mcs);\n\n\t/* extended client data supported */\n\n\tif (settings->NegotiationFlags & EXTENDED_CLIENT_DATA_SUPPORTED)\n\t{\n\t\tif (settings->UseMultimon && !settings->SpanMonitors)\n\t\t{\n\t\t\tgcc_write_client_monitor_data(s, mcs);\n\t\t\tgcc_write_client_monitor_extended_data(s, mcs);\n\t\t}\n\n\t\tgcc_write_client_message_channel_data(s, mcs);\n\t\tgcc_write_client_multitransport_channel_data(s, mcs);\n\t}\n\telse\n\t{\n\t\tif (settings->UseMultimon && !settings->SpanMonitors)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"WARNING: true multi monitor support was not advertised by server!\");\n\n\t\t\tif (settings->ForceMultimon)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Sending multi monitor information anyway (may break connectivity!)\");\n\t\t\t\tgcc_write_client_monitor_data(s, mcs);\n\t\t\t\tgcc_write_client_monitor_extended_data(s, mcs);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Use /multimon:force to force sending multi monitor information\");\n\t\t\t}\n\t\t}\n\t}\n}\n\nBOOL gcc_read_server_data_blocks(wStream* s, rdpMcs* mcs, int length)\n{\n\tUINT16 type;\n\tUINT16 offset = 0;\n\tUINT16 blockLength;\n\tBYTE* holdp;\n\n\twhile (offset < length)\n\t{\n\t\tholdp = Stream_Pointer(s);\n\n\t\tif (!gcc_read_user_data_header(s, &type, &blockLength))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"gcc_read_server_data_blocks: gcc_read_user_data_header failed\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tswitch (type)\n\t\t{\n\t\t\tcase SC_CORE:\n\t\t\t\tif (!gcc_read_server_core_data(s, mcs))\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG, \"gcc_read_server_data_blocks: gcc_read_server_core_data failed\");\n\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase SC_SECURITY:\n\t\t\t\tif (!gcc_read_server_security_data(s, mcs))\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG,\n\t\t\t\t\t         \"gcc_read_server_data_blocks: gcc_read_server_security_data failed\");\n\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase SC_NET:\n\t\t\t\tif (!gcc_read_server_network_data(s, mcs))\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG,\n\t\t\t\t\t         \"gcc_read_server_data_blocks: gcc_read_server_network_data failed\");\n\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase SC_MCS_MSGCHANNEL:\n\t\t\t\tif (!gcc_read_server_message_channel_data(s, mcs))\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(\n\t\t\t\t\t    TAG,\n\t\t\t\t\t    \"gcc_read_server_data_blocks: gcc_read_server_message_channel_data failed\");\n\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase SC_MULTITRANSPORT:\n\t\t\t\tif (!gcc_read_server_multitransport_channel_data(s, mcs))\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG, \"gcc_read_server_data_blocks: \"\n\t\t\t\t\t              \"gcc_read_server_multitransport_channel_data failed\");\n\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tWLog_ERR(TAG, \"gcc_read_server_data_blocks: ignoring type=%\" PRIu16 \"\", type);\n\t\t\t\tbreak;\n\t\t}\n\n\t\toffset += blockLength;\n\t\tStream_SetPointer(s, holdp + blockLength);\n\t}\n\n\treturn TRUE;\n}\n\nBOOL gcc_write_server_data_blocks(wStream* s, rdpMcs* mcs)\n{\n\treturn gcc_write_server_core_data(s, mcs) &&          /* serverCoreData */\n\t       gcc_write_server_network_data(s, mcs) &&       /* serverNetworkData */\n\t       gcc_write_server_security_data(s, mcs) &&      /* serverSecurityData */\n\t       gcc_write_server_message_channel_data(s, mcs); /* serverMessageChannelData */\n\t/* TODO: Send these GCC data blocks only when the client sent them */\n\t// gcc_write_server_multitransport_channel_data(s, settings); /* serverMultitransportChannelData\n\t// */\n}\n\nBOOL gcc_read_user_data_header(wStream* s, UINT16* type, UINT16* length)\n{\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, *type);   /* type */\n\tStream_Read_UINT16(s, *length); /* length */\n\n\tif (Stream_GetRemainingLength(s) < (size_t)(*length - 4))\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\n/**\n * Write a user data header (TS_UD_HEADER).\\n\n * @msdn{cc240509}\n * @param s stream\n * @param type data block type\n * @param length data block length\n */\n\nvoid gcc_write_user_data_header(wStream* s, UINT16 type, UINT16 length)\n{\n\tStream_Write_UINT16(s, type);   /* type */\n\tStream_Write_UINT16(s, length); /* length */\n}\n\n/**\n * Read a client core data block (TS_UD_CS_CORE).\\n\n * @msdn{cc240510}\n * @param s stream\n * @param settings rdp settings\n */\n\nBOOL gcc_read_client_core_data(wStream* s, rdpMcs* mcs, UINT16 blockLength)\n{\n\tchar* str = NULL;\n\tUINT32 version;\n\tBYTE connectionType = 0;\n\tUINT32 clientColorDepth;\n\tUINT16 colorDepth = 0;\n\tUINT16 postBeta2ColorDepth = 0;\n\tUINT16 highColorDepth = 0;\n\tUINT16 supportedColorDepths = 0;\n\tUINT32 serverSelectedProtocol = 0;\n\tUINT16 earlyCapabilityFlags = 0;\n\trdpSettings* settings = mcs->settings;\n\n\t/* Length of all required fields, until imeFileName */\n\tif (blockLength < 128)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, version); /* version (4 bytes) */\n\tsettings->RdpVersion = rdp_version_common(version, settings->RdpVersion);\n\tStream_Read_UINT16(s, settings->DesktopWidth);  /* DesktopWidth (2 bytes) */\n\tStream_Read_UINT16(s, settings->DesktopHeight); /* DesktopHeight (2 bytes) */\n\tStream_Read_UINT16(s, colorDepth);              /* ColorDepth (2 bytes) */\n\tStream_Seek_UINT16(s); /* SASSequence (Secure Access Sequence) (2 bytes) */\n\tStream_Read_UINT32(s, settings->KeyboardLayout); /* KeyboardLayout (4 bytes) */\n\tStream_Read_UINT32(s, settings->ClientBuild);    /* ClientBuild (4 bytes) */\n\n\t/* clientName (32 bytes, null-terminated unicode, truncated to 15 characters) */\n\tif (ConvertFromUnicode(CP_UTF8, 0, (WCHAR*)Stream_Pointer(s), 32 / 2, &str, 0, NULL, NULL) < 1)\n\t{\n\t\tWLog_ERR(TAG, \"failed to convert client host name\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Seek(s, 32);\n\tfree(settings->ClientHostname);\n\tsettings->ClientHostname = str;\n\tstr = NULL;\n\tStream_Read_UINT32(s, settings->KeyboardType);        /* KeyboardType (4 bytes) */\n\tStream_Read_UINT32(s, settings->KeyboardSubType);     /* KeyboardSubType (4 bytes) */\n\tStream_Read_UINT32(s, settings->KeyboardFunctionKey); /* KeyboardFunctionKey (4 bytes) */\n\tStream_Seek(s, 64);                                   /* imeFileName (64 bytes) */\n\tblockLength -= 128;\n\n\t/**\n\t * The following fields are all optional. If one field is present, all of the preceding\n\t * fields MUST also be present. If one field is not present, all of the subsequent fields\n\t * MUST NOT be present.\n\t * We must check the bytes left before reading each field.\n\t */\n\n\tdo\n\t{\n\t\tif (blockLength < 2)\n\t\t\tbreak;\n\n\t\tStream_Read_UINT16(s, postBeta2ColorDepth); /* postBeta2ColorDepth (2 bytes) */\n\t\tblockLength -= 2;\n\n\t\tif (blockLength < 2)\n\t\t\tbreak;\n\n\t\tStream_Seek_UINT16(s); /* clientProductID (2 bytes) */\n\t\tblockLength -= 2;\n\n\t\tif (blockLength < 4)\n\t\t\tbreak;\n\n\t\tStream_Seek_UINT32(s); /* serialNumber (4 bytes) */\n\t\tblockLength -= 4;\n\n\t\tif (blockLength < 2)\n\t\t\tbreak;\n\n\t\tStream_Read_UINT16(s, highColorDepth); /* highColorDepth (2 bytes) */\n\t\tblockLength -= 2;\n\n\t\tif (blockLength < 2)\n\t\t\tbreak;\n\n\t\tStream_Read_UINT16(s, supportedColorDepths); /* supportedColorDepths (2 bytes) */\n\t\tblockLength -= 2;\n\n\t\tif (blockLength < 2)\n\t\t\tbreak;\n\n\t\tStream_Read_UINT16(s, earlyCapabilityFlags); /* earlyCapabilityFlags (2 bytes) */\n\t\tsettings->EarlyCapabilityFlags = (UINT32)earlyCapabilityFlags;\n\t\tblockLength -= 2;\n\n\t\t/* clientDigProductId (64 bytes): Contains a value that uniquely identifies the client */\n\n\t\tif (blockLength < 64)\n\t\t\tbreak;\n\n\t\tif (ConvertFromUnicode(CP_UTF8, 0, (WCHAR*)Stream_Pointer(s), 64 / 2, &str, 0, NULL, NULL) <\n\t\t    1)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"failed to convert the client product identifier\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tStream_Seek(s, 64); /* clientDigProductId (64 bytes) */\n\t\tfree(settings->ClientProductId);\n\t\tsettings->ClientProductId = str;\n\t\tblockLength -= 64;\n\n\t\tif (blockLength < 1)\n\t\t\tbreak;\n\n\t\tStream_Read_UINT8(s, connectionType); /* connectionType (1 byte) */\n\t\tblockLength -= 1;\n\n\t\tif (blockLength < 1)\n\t\t\tbreak;\n\n\t\tStream_Seek_UINT8(s); /* pad1octet (1 byte) */\n\t\tblockLength -= 1;\n\n\t\tif (blockLength < 4)\n\t\t\tbreak;\n\n\t\tStream_Read_UINT32(s, serverSelectedProtocol); /* serverSelectedProtocol (4 bytes) */\n\t\tblockLength -= 4;\n\n\t\tif (blockLength < 4)\n\t\t\tbreak;\n\n\t\tStream_Read_UINT32(s, settings->DesktopPhysicalWidth); /* desktopPhysicalWidth (4 bytes) */\n\t\tblockLength -= 4;\n\n\t\tif (blockLength < 4)\n\t\t\tbreak;\n\n\t\tStream_Read_UINT32(s,\n\t\t                   settings->DesktopPhysicalHeight); /* desktopPhysicalHeight (4 bytes) */\n\t\tblockLength -= 4;\n\n\t\tif (blockLength < 2)\n\t\t\tbreak;\n\n\t\tStream_Read_UINT16(s, settings->DesktopOrientation); /* desktopOrientation (2 bytes) */\n\t\tblockLength -= 2;\n\n\t\tif (blockLength < 4)\n\t\t\tbreak;\n\n\t\tStream_Read_UINT32(s, settings->DesktopScaleFactor); /* desktopScaleFactor (4 bytes) */\n\t\tblockLength -= 4;\n\n\t\tif (blockLength < 4)\n\t\t\tbreak;\n\n\t\tStream_Read_UINT32(s, settings->DeviceScaleFactor); /* deviceScaleFactor (4 bytes) */\n\n\t\tif (settings->SelectedProtocol != serverSelectedProtocol)\n\t\t\treturn FALSE;\n\t} while (0);\n\n\tif (highColorDepth > 0)\n\t{\n\t\tif (earlyCapabilityFlags & RNS_UD_CS_WANT_32BPP_SESSION)\n\t\t\tclientColorDepth = 32;\n\t\telse\n\t\t\tclientColorDepth = highColorDepth;\n\t}\n\telse if (postBeta2ColorDepth > 0)\n\t{\n\t\tswitch (postBeta2ColorDepth)\n\t\t{\n\t\t\tcase RNS_UD_COLOR_4BPP:\n\t\t\t\tclientColorDepth = 4;\n\t\t\t\tbreak;\n\n\t\t\tcase RNS_UD_COLOR_8BPP:\n\t\t\t\tclientColorDepth = 8;\n\t\t\t\tbreak;\n\n\t\t\tcase RNS_UD_COLOR_16BPP_555:\n\t\t\t\tclientColorDepth = 15;\n\t\t\t\tbreak;\n\n\t\t\tcase RNS_UD_COLOR_16BPP_565:\n\t\t\t\tclientColorDepth = 16;\n\t\t\t\tbreak;\n\n\t\t\tcase RNS_UD_COLOR_24BPP:\n\t\t\t\tclientColorDepth = 24;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tswitch (colorDepth)\n\t\t{\n\t\t\tcase RNS_UD_COLOR_4BPP:\n\t\t\t\tclientColorDepth = 4;\n\t\t\t\tbreak;\n\n\t\t\tcase RNS_UD_COLOR_8BPP:\n\t\t\t\tclientColorDepth = 8;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\t/*\n\t * If we are in server mode, accept client's color depth only if\n\t * it is smaller than ours. This is what Windows server does.\n\t */\n\tif ((clientColorDepth < settings->ColorDepth) || !settings->ServerMode)\n\t\tsettings->ColorDepth = clientColorDepth;\n\n\tif (settings->NetworkAutoDetect)\n\t\tsettings->NetworkAutoDetect =\n\t\t    (earlyCapabilityFlags & RNS_UD_CS_SUPPORT_NETWORK_AUTODETECT) ? TRUE : FALSE;\n\n\tif (settings->SupportHeartbeatPdu)\n\t\tsettings->SupportHeartbeatPdu =\n\t\t    (earlyCapabilityFlags & RNS_UD_CS_SUPPORT_HEARTBEAT_PDU) ? TRUE : FALSE;\n\n\tif (settings->SupportGraphicsPipeline)\n\t\tsettings->SupportGraphicsPipeline =\n\t\t    (earlyCapabilityFlags & RNS_UD_CS_SUPPORT_DYNVC_GFX_PROTOCOL) ? TRUE : FALSE;\n\n\tif (settings->SupportDynamicTimeZone)\n\t\tsettings->SupportDynamicTimeZone =\n\t\t    (earlyCapabilityFlags & RNS_UD_CS_SUPPORT_DYNAMIC_TIME_ZONE) ? TRUE : FALSE;\n\n\tif (settings->SupportMonitorLayoutPdu)\n\t\tsettings->SupportMonitorLayoutPdu =\n\t\t    (earlyCapabilityFlags & RNS_UD_CS_SUPPORT_MONITOR_LAYOUT_PDU) ? TRUE : FALSE;\n\n\tif (settings->SupportStatusInfoPdu)\n\t\tsettings->SupportStatusInfoPdu =\n\t\t    (earlyCapabilityFlags & RNS_UD_CS_SUPPORT_STATUSINFO_PDU) ? TRUE : FALSE;\n\n\tif (!(earlyCapabilityFlags & RNS_UD_CS_VALID_CONNECTION_TYPE))\n\t\tconnectionType = 0;\n\n\tsettings->SupportErrorInfoPdu = earlyCapabilityFlags & RNS_UD_CS_SUPPORT_ERRINFO_PDU;\n\tsettings->ConnectionType = connectionType;\n\treturn TRUE;\n}\n\n/**\n * Write a client core data block (TS_UD_CS_CORE).\\n\n * @msdn{cc240510}\n * @param s stream\n * @param settings rdp settings\n */\n\nvoid gcc_write_client_core_data(wStream* s, rdpMcs* mcs)\n{\n\tWCHAR* clientName = NULL;\n\tint clientNameLength;\n\tBYTE connectionType;\n\tUINT16 highColorDepth;\n\tUINT16 supportedColorDepths;\n\tUINT16 earlyCapabilityFlags;\n\tWCHAR* clientDigProductId = NULL;\n\tint clientDigProductIdLength;\n\trdpSettings* settings = mcs->settings;\n\tgcc_write_user_data_header(s, CS_CORE, 234);\n\tclientNameLength = ConvertToUnicode(CP_UTF8, 0, settings->ClientHostname, -1, &clientName, 0);\n\tclientDigProductIdLength =\n\t    ConvertToUnicode(CP_UTF8, 0, settings->ClientProductId, -1, &clientDigProductId, 0);\n\tStream_Write_UINT32(s, settings->RdpVersion);    /* Version */\n\tStream_Write_UINT16(s, settings->DesktopWidth);  /* DesktopWidth */\n\tStream_Write_UINT16(s, settings->DesktopHeight); /* DesktopHeight */\n\tStream_Write_UINT16(s,\n\t                    RNS_UD_COLOR_8BPP); /* ColorDepth, ignored because of postBeta2ColorDepth */\n\tStream_Write_UINT16(s, RNS_UD_SAS_DEL); /* SASSequence (Secure Access Sequence) */\n\tStream_Write_UINT32(s, settings->KeyboardLayout); /* KeyboardLayout */\n\tStream_Write_UINT32(s, settings->ClientBuild);    /* ClientBuild */\n\n\t/* clientName (32 bytes, null-terminated unicode, truncated to 15 characters) */\n\n\tif (clientNameLength >= 16)\n\t{\n\t\tclientNameLength = 16;\n\t\tclientName[clientNameLength - 1] = 0;\n\t}\n\n\tStream_Write(s, clientName, (clientNameLength * 2));\n\tStream_Zero(s, 32 - (clientNameLength * 2));\n\tfree(clientName);\n\tStream_Write_UINT32(s, settings->KeyboardType);        /* KeyboardType */\n\tStream_Write_UINT32(s, settings->KeyboardSubType);     /* KeyboardSubType */\n\tStream_Write_UINT32(s, settings->KeyboardFunctionKey); /* KeyboardFunctionKey */\n\tStream_Zero(s, 64);                                    /* imeFileName */\n\tStream_Write_UINT16(s, RNS_UD_COLOR_8BPP);             /* postBeta2ColorDepth */\n\tStream_Write_UINT16(s, 1);                             /* clientProductID */\n\tStream_Write_UINT32(s, 0); /* serialNumber (should be initialized to 0) */\n\thighColorDepth = MIN(settings->ColorDepth, 24);\n\tsupportedColorDepths = RNS_UD_24BPP_SUPPORT | RNS_UD_16BPP_SUPPORT | RNS_UD_15BPP_SUPPORT;\n\tearlyCapabilityFlags = RNS_UD_CS_SUPPORT_ERRINFO_PDU;\n\n\tif (settings->NetworkAutoDetect)\n\t\tsettings->ConnectionType = CONNECTION_TYPE_AUTODETECT;\n\n\tif (settings->RemoteFxCodec && !settings->NetworkAutoDetect)\n\t\tsettings->ConnectionType = CONNECTION_TYPE_LAN;\n\n\tconnectionType = settings->ConnectionType;\n\n\tif (connectionType)\n\t\tearlyCapabilityFlags |= RNS_UD_CS_VALID_CONNECTION_TYPE;\n\n\tif (settings->ColorDepth == 32)\n\t{\n\t\tsupportedColorDepths |= RNS_UD_32BPP_SUPPORT;\n\t\tearlyCapabilityFlags |= RNS_UD_CS_WANT_32BPP_SESSION;\n\t}\n\n\tif (settings->NetworkAutoDetect)\n\t\tearlyCapabilityFlags |= RNS_UD_CS_SUPPORT_NETWORK_AUTODETECT;\n\n\tif (settings->SupportHeartbeatPdu)\n\t\tearlyCapabilityFlags |= RNS_UD_CS_SUPPORT_HEARTBEAT_PDU;\n\n\tif (settings->SupportGraphicsPipeline)\n\t\tearlyCapabilityFlags |= RNS_UD_CS_SUPPORT_DYNVC_GFX_PROTOCOL;\n\n\tif (settings->SupportDynamicTimeZone)\n\t\tearlyCapabilityFlags |= RNS_UD_CS_SUPPORT_DYNAMIC_TIME_ZONE;\n\n\tif (settings->SupportMonitorLayoutPdu)\n\t\tearlyCapabilityFlags |= RNS_UD_CS_SUPPORT_MONITOR_LAYOUT_PDU;\n\n\tif (settings->SupportStatusInfoPdu)\n\t\tearlyCapabilityFlags |= RNS_UD_CS_SUPPORT_STATUSINFO_PDU;\n\n\tStream_Write_UINT16(s, highColorDepth);       /* highColorDepth */\n\tStream_Write_UINT16(s, supportedColorDepths); /* supportedColorDepths */\n\tStream_Write_UINT16(s, earlyCapabilityFlags); /* earlyCapabilityFlags */\n\n\t/* clientDigProductId (64 bytes, null-terminated unicode, truncated to 31 characters) */\n\tif (clientDigProductIdLength >= 32)\n\t{\n\t\tclientDigProductIdLength = 32;\n\t\tclientDigProductId[clientDigProductIdLength - 1] = 0;\n\t}\n\n\tStream_Write(s, clientDigProductId, (clientDigProductIdLength * 2));\n\tStream_Zero(s, 64 - (clientDigProductIdLength * 2));\n\tfree(clientDigProductId);\n\tStream_Write_UINT8(s, connectionType);                   /* connectionType */\n\tStream_Write_UINT8(s, 0);                                /* pad1octet */\n\tStream_Write_UINT32(s, settings->SelectedProtocol);      /* serverSelectedProtocol */\n\tStream_Write_UINT32(s, settings->DesktopPhysicalWidth);  /* desktopPhysicalWidth */\n\tStream_Write_UINT32(s, settings->DesktopPhysicalHeight); /* desktopPhysicalHeight */\n\tStream_Write_UINT16(s, settings->DesktopOrientation);    /* desktopOrientation */\n\tStream_Write_UINT32(s, settings->DesktopScaleFactor);    /* desktopScaleFactor */\n\tStream_Write_UINT32(s, settings->DeviceScaleFactor);     /* deviceScaleFactor */\n}\n\nBOOL gcc_read_server_core_data(wStream* s, rdpMcs* mcs)\n{\n\tUINT32 serverVersion;\n\tUINT32 clientRequestedProtocols;\n\tUINT32 earlyCapabilityFlags;\n\trdpSettings* settings = mcs->settings;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, serverVersion); /* version */\n\tsettings->RdpVersion = rdp_version_common(serverVersion, settings->RdpVersion);\n\n\tif (Stream_GetRemainingLength(s) >= 4)\n\t{\n\t\tStream_Read_UINT32(s, clientRequestedProtocols); /* clientRequestedProtocols */\n\t}\n\n\tif (Stream_GetRemainingLength(s) >= 4)\n\t{\n\t\tStream_Read_UINT32(s, earlyCapabilityFlags); /* earlyCapabilityFlags */\n\t}\n\n\treturn TRUE;\n}\n\nBOOL gcc_write_server_core_data(wStream* s, rdpMcs* mcs)\n{\n\tUINT32 earlyCapabilityFlags = 0;\n\trdpSettings* settings = mcs->settings;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 20))\n\t\treturn FALSE;\n\n\tgcc_write_user_data_header(s, SC_CORE, 16);\n\n\tif (settings->SupportDynamicTimeZone)\n\t\tearlyCapabilityFlags |= RNS_UD_SC_DYNAMIC_DST_SUPPORTED;\n\n\tStream_Write_UINT32(s, settings->RdpVersion);         /* version (4 bytes) */\n\tStream_Write_UINT32(s, settings->RequestedProtocols); /* clientRequestedProtocols (4 bytes) */\n\tStream_Write_UINT32(s, earlyCapabilityFlags);         /* earlyCapabilityFlags (4 bytes) */\n\treturn TRUE;\n}\n\n/**\n * Read a client security data block (TS_UD_CS_SEC).\\n\n * @msdn{cc240511}\n * @param s stream\n * @param settings rdp settings\n */\n\nBOOL gcc_read_client_security_data(wStream* s, rdpMcs* mcs, UINT16 blockLength)\n{\n\trdpSettings* settings = mcs->settings;\n\n\tif (blockLength < 8)\n\t\treturn FALSE;\n\n\tif (settings->UseRdpSecurityLayer)\n\t{\n\t\tStream_Read_UINT32(s, settings->EncryptionMethods); /* encryptionMethods */\n\n\t\tif (settings->EncryptionMethods == 0)\n\t\t\tStream_Read_UINT32(s, settings->EncryptionMethods); /* extEncryptionMethods */\n\t\telse\n\t\t\tStream_Seek(s, 4);\n\t}\n\telse\n\t{\n\t\tStream_Seek(s, 8);\n\t}\n\n\treturn TRUE;\n}\n\n/**\n * Write a client security data block (TS_UD_CS_SEC).\\n\n * @msdn{cc240511}\n * @param s stream\n * @param settings rdp settings\n */\n\nvoid gcc_write_client_security_data(wStream* s, rdpMcs* mcs)\n{\n\trdpSettings* settings = mcs->settings;\n\tgcc_write_user_data_header(s, CS_SECURITY, 12);\n\n\tif (settings->UseRdpSecurityLayer)\n\t{\n\t\tStream_Write_UINT32(s, settings->EncryptionMethods); /* encryptionMethods */\n\t\tStream_Write_UINT32(s, 0);                           /* extEncryptionMethods */\n\t}\n\telse\n\t{\n\t\t/* French locale, disable encryption */\n\t\tStream_Write_UINT32(s, 0);                           /* encryptionMethods */\n\t\tStream_Write_UINT32(s, settings->EncryptionMethods); /* extEncryptionMethods */\n\t}\n}\n\nBOOL gcc_read_server_security_data(wStream* s, rdpMcs* mcs)\n{\n\tBYTE* data;\n\tUINT32 length;\n\trdpSettings* settings = mcs->settings;\n\tBOOL validCryptoConfig = FALSE;\n\tUINT32 serverEncryptionMethod;\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, serverEncryptionMethod);    /* encryptionMethod */\n\tStream_Read_UINT32(s, settings->EncryptionLevel); /* encryptionLevel */\n\n\t/* Only accept valid/known encryption methods */\n\tswitch (serverEncryptionMethod)\n\t{\n\t\tcase ENCRYPTION_METHOD_NONE:\n\t\t\tWLog_DBG(TAG, \"Server rdp encryption method: NONE\");\n\t\t\tbreak;\n\n\t\tcase ENCRYPTION_METHOD_40BIT:\n\t\t\tWLog_DBG(TAG, \"Server rdp encryption method: 40BIT\");\n\t\t\tbreak;\n\n\t\tcase ENCRYPTION_METHOD_56BIT:\n\t\t\tWLog_DBG(TAG, \"Server rdp encryption method: 56BIT\");\n\t\t\tbreak;\n\n\t\tcase ENCRYPTION_METHOD_128BIT:\n\t\t\tWLog_DBG(TAG, \"Server rdp encryption method: 128BIT\");\n\t\t\tbreak;\n\n\t\tcase ENCRYPTION_METHOD_FIPS:\n\t\t\tWLog_DBG(TAG, \"Server rdp encryption method: FIPS\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_ERR(TAG, \"Received unknown encryption method %08\" PRIX32 \"\",\n\t\t\t         serverEncryptionMethod);\n\t\t\treturn FALSE;\n\t}\n\n\tif (settings->UseRdpSecurityLayer && !(settings->EncryptionMethods & serverEncryptionMethod))\n\t{\n\t\tWLog_WARN(TAG, \"Server uses non-advertised encryption method 0x%08\" PRIX32 \"\",\n\t\t          serverEncryptionMethod);\n\t\t/* FIXME: Should we return FALSE; in this case ?? */\n\t}\n\n\tsettings->EncryptionMethods = serverEncryptionMethod;\n\n\t/* Verify encryption level/method combinations according to MS-RDPBCGR Section 5.3.2 */\n\tswitch (settings->EncryptionLevel)\n\t{\n\t\tcase ENCRYPTION_LEVEL_NONE:\n\t\t\tif (settings->EncryptionMethods == ENCRYPTION_METHOD_NONE)\n\t\t\t{\n\t\t\t\tvalidCryptoConfig = TRUE;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase ENCRYPTION_LEVEL_FIPS:\n\t\t\tif (settings->EncryptionMethods == ENCRYPTION_METHOD_FIPS)\n\t\t\t{\n\t\t\t\tvalidCryptoConfig = TRUE;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase ENCRYPTION_LEVEL_LOW:\n\t\tcase ENCRYPTION_LEVEL_HIGH:\n\t\tcase ENCRYPTION_LEVEL_CLIENT_COMPATIBLE:\n\t\t\tif (settings->EncryptionMethods == ENCRYPTION_METHOD_40BIT ||\n\t\t\t    settings->EncryptionMethods == ENCRYPTION_METHOD_56BIT ||\n\t\t\t    settings->EncryptionMethods == ENCRYPTION_METHOD_128BIT ||\n\t\t\t    settings->EncryptionMethods == ENCRYPTION_METHOD_FIPS)\n\t\t\t{\n\t\t\t\tvalidCryptoConfig = TRUE;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_ERR(TAG, \"Received unknown encryption level 0x%08\" PRIX32 \"\",\n\t\t\t         settings->EncryptionLevel);\n\t}\n\n\tif (!validCryptoConfig)\n\t{\n\t\tWLog_ERR(TAG,\n\t\t         \"Received invalid cryptographic configuration (level=0x%08\" PRIX32\n\t\t         \" method=0x%08\" PRIX32 \")\",\n\t\t         settings->EncryptionLevel, settings->EncryptionMethods);\n\t\treturn FALSE;\n\t}\n\n\tif (settings->EncryptionLevel == ENCRYPTION_LEVEL_NONE)\n\t{\n\t\t/* serverRandomLen and serverCertLen must not be present */\n\t\tsettings->UseRdpSecurityLayer = FALSE;\n\t\treturn TRUE;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, settings->ServerRandomLength);      /* serverRandomLen */\n\tStream_Read_UINT32(s, settings->ServerCertificateLength); /* serverCertLen */\n\n\tif ((settings->ServerRandomLength == 0) || (settings->ServerCertificateLength == 0))\n\t\treturn FALSE;\n\n\tif (Stream_GetRemainingLength(s) < settings->ServerRandomLength)\n\t\treturn FALSE;\n\n\t/* serverRandom */\n\tsettings->ServerRandom = (BYTE*)malloc(settings->ServerRandomLength);\n\n\tif (!settings->ServerRandom)\n\t\tgoto fail;\n\n\tStream_Read(s, settings->ServerRandom, settings->ServerRandomLength);\n\n\tif (Stream_GetRemainingLength(s) < settings->ServerCertificateLength)\n\t\tgoto fail;\n\n\t/* serverCertificate */\n\tsettings->ServerCertificate = (BYTE*)malloc(settings->ServerCertificateLength);\n\n\tif (!settings->ServerCertificate)\n\t\tgoto fail;\n\n\tStream_Read(s, settings->ServerCertificate, settings->ServerCertificateLength);\n\tcertificate_free(settings->RdpServerCertificate);\n\tsettings->RdpServerCertificate = certificate_new();\n\n\tif (!settings->RdpServerCertificate)\n\t\tgoto fail;\n\n\tdata = settings->ServerCertificate;\n\tlength = settings->ServerCertificateLength;\n\n\tif (!certificate_read_server_certificate(settings->RdpServerCertificate, data, length))\n\t\tgoto fail;\n\n\treturn TRUE;\nfail:\n\tfree(settings->ServerRandom);\n\tfree(settings->ServerCertificate);\n\tsettings->ServerRandom = NULL;\n\tsettings->ServerCertificate = NULL;\n\treturn FALSE;\n}\n\nstatic const BYTE initial_signature[] = {\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01\n};\n\n/*\n * Terminal Services Signing Keys.\n * Yes, Terminal Services Private Key is publicly available.\n */\n\nconst BYTE tssk_modulus[] = { 0x3d, 0x3a, 0x5e, 0xbd, 0x72, 0x43, 0x3e, 0xc9, 0x4d, 0xbb, 0xc1,\n\t                          0x1e, 0x4a, 0xba, 0x5f, 0xcb, 0x3e, 0x88, 0x20, 0x87, 0xef, 0xf5,\n\t                          0xc1, 0xe2, 0xd7, 0xb7, 0x6b, 0x9a, 0xf2, 0x52, 0x45, 0x95, 0xce,\n\t                          0x63, 0x65, 0x6b, 0x58, 0x3a, 0xfe, 0xef, 0x7c, 0xe7, 0xbf, 0xfe,\n\t                          0x3d, 0xf6, 0x5c, 0x7d, 0x6c, 0x5e, 0x06, 0x09, 0x1a, 0xf5, 0x61,\n\t                          0xbb, 0x20, 0x93, 0x09, 0x5f, 0x05, 0x6d, 0xea, 0x87 };\n\nconst BYTE tssk_privateExponent[] = {\n\t0x87, 0xa7, 0x19, 0x32, 0xda, 0x11, 0x87, 0x55, 0x58, 0x00, 0x16, 0x16, 0x25, 0x65, 0x68, 0xf8,\n\t0x24, 0x3e, 0xe6, 0xfa, 0xe9, 0x67, 0x49, 0x94, 0xcf, 0x92, 0xcc, 0x33, 0x99, 0xe8, 0x08, 0x60,\n\t0x17, 0x9a, 0x12, 0x9f, 0x24, 0xdd, 0xb1, 0x24, 0x99, 0xc7, 0x3a, 0xb8, 0x0a, 0x7b, 0x0d, 0xdd,\n\t0x35, 0x07, 0x79, 0x17, 0x0b, 0x51, 0x9b, 0xb3, 0xc7, 0x10, 0x01, 0x13, 0xe7, 0x3f, 0xf3, 0x5f\n};\n\nconst BYTE tssk_exponent[] = { 0x5b, 0x7b, 0x88, 0xc0 };\n\nBOOL gcc_write_server_security_data(wStream* s, rdpMcs* mcs)\n{\n\tBYTE* sigData;\n\tint expLen, keyLen, sigDataLen;\n\tBYTE encryptedSignature[TSSK_KEY_LENGTH];\n\tBYTE signature[sizeof(initial_signature)];\n\tUINT32 headerLen, serverRandomLen, serverCertLen, wPublicKeyBlobLen;\n\trdpSettings* settings = mcs->settings;\n\n\t/**\n\t * Re: settings->EncryptionLevel:\n\t * This is configured/set by the server implementation and serves the same\n\t * purpose as the \"Encryption Level\" setting in the RDP-Tcp configuration\n\t * dialog of Microsoft's Remote Desktop Session Host Configuration.\n\t * Re: settings->EncryptionMethods:\n\t * at this point this setting contains the client's supported encryption\n\t * methods we've received in gcc_read_client_security_data()\n\t */\n\n\tif (!settings->UseRdpSecurityLayer)\n\t{\n\t\t/* TLS/NLA is used: disable rdp style encryption */\n\t\tsettings->EncryptionLevel = ENCRYPTION_LEVEL_NONE;\n\t}\n\n\t/* verify server encryption level value */\n\tswitch (settings->EncryptionLevel)\n\t{\n\t\tcase ENCRYPTION_LEVEL_NONE:\n\t\t\tWLog_INFO(TAG, \"Active rdp encryption level: NONE\");\n\t\t\tbreak;\n\n\t\tcase ENCRYPTION_LEVEL_FIPS:\n\t\t\tWLog_INFO(TAG, \"Active rdp encryption level: FIPS Compliant\");\n\t\t\tbreak;\n\n\t\tcase ENCRYPTION_LEVEL_HIGH:\n\t\t\tWLog_INFO(TAG, \"Active rdp encryption level: HIGH\");\n\t\t\tbreak;\n\n\t\tcase ENCRYPTION_LEVEL_LOW:\n\t\t\tWLog_INFO(TAG, \"Active rdp encryption level: LOW\");\n\t\t\tbreak;\n\n\t\tcase ENCRYPTION_LEVEL_CLIENT_COMPATIBLE:\n\t\t\tWLog_INFO(TAG, \"Active rdp encryption level: CLIENT-COMPATIBLE\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_ERR(TAG, \"Invalid server encryption level 0x%08\" PRIX32 \"\",\n\t\t\t         settings->EncryptionLevel);\n\t\t\tWLog_ERR(TAG, \"Switching to encryption level CLIENT-COMPATIBLE\");\n\t\t\tsettings->EncryptionLevel = ENCRYPTION_LEVEL_CLIENT_COMPATIBLE;\n\t}\n\n\t/* choose rdp encryption method based on server level and client methods */\n\tswitch (settings->EncryptionLevel)\n\t{\n\t\tcase ENCRYPTION_LEVEL_NONE:\n\t\t\t/* The only valid method is NONE in this case */\n\t\t\tsettings->EncryptionMethods = ENCRYPTION_METHOD_NONE;\n\t\t\tbreak;\n\n\t\tcase ENCRYPTION_LEVEL_FIPS:\n\n\t\t\t/* The only valid method is FIPS in this case */\n\t\t\tif (!(settings->EncryptionMethods & ENCRYPTION_METHOD_FIPS))\n\t\t\t{\n\t\t\t\tWLog_WARN(TAG, \"client does not support FIPS as required by server configuration\");\n\t\t\t}\n\n\t\t\tsettings->EncryptionMethods = ENCRYPTION_METHOD_FIPS;\n\t\t\tbreak;\n\n\t\tcase ENCRYPTION_LEVEL_HIGH:\n\n\t\t\t/* Maximum key strength supported by the server must be used (128 bit)*/\n\t\t\tif (!(settings->EncryptionMethods & ENCRYPTION_METHOD_128BIT))\n\t\t\t{\n\t\t\t\tWLog_WARN(TAG, \"client does not support 128 bit encryption method as required by \"\n\t\t\t\t               \"server configuration\");\n\t\t\t}\n\n\t\t\tsettings->EncryptionMethods = ENCRYPTION_METHOD_128BIT;\n\t\t\tbreak;\n\n\t\tcase ENCRYPTION_LEVEL_LOW:\n\t\tcase ENCRYPTION_LEVEL_CLIENT_COMPATIBLE:\n\n\t\t\t/* Maximum key strength supported by the client must be used */\n\t\t\tif (settings->EncryptionMethods & ENCRYPTION_METHOD_128BIT)\n\t\t\t\tsettings->EncryptionMethods = ENCRYPTION_METHOD_128BIT;\n\t\t\telse if (settings->EncryptionMethods & ENCRYPTION_METHOD_56BIT)\n\t\t\t\tsettings->EncryptionMethods = ENCRYPTION_METHOD_56BIT;\n\t\t\telse if (settings->EncryptionMethods & ENCRYPTION_METHOD_40BIT)\n\t\t\t\tsettings->EncryptionMethods = ENCRYPTION_METHOD_40BIT;\n\t\t\telse if (settings->EncryptionMethods & ENCRYPTION_METHOD_FIPS)\n\t\t\t\tsettings->EncryptionMethods = ENCRYPTION_METHOD_FIPS;\n\t\t\telse\n\t\t\t{\n\t\t\t\tWLog_WARN(TAG, \"client has not announced any supported encryption methods\");\n\t\t\t\tsettings->EncryptionMethods = ENCRYPTION_METHOD_128BIT;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_ERR(TAG, \"internal error: unknown encryption level\");\n\t\t\treturn FALSE;\n\t}\n\n\t/* log selected encryption method */\n\tswitch (settings->EncryptionMethods)\n\t{\n\t\tcase ENCRYPTION_METHOD_NONE:\n\t\t\tWLog_INFO(TAG, \"Selected rdp encryption method: NONE\");\n\t\t\tbreak;\n\n\t\tcase ENCRYPTION_METHOD_40BIT:\n\t\t\tWLog_INFO(TAG, \"Selected rdp encryption method: 40BIT\");\n\t\t\tbreak;\n\n\t\tcase ENCRYPTION_METHOD_56BIT:\n\t\t\tWLog_INFO(TAG, \"Selected rdp encryption method: 56BIT\");\n\t\t\tbreak;\n\n\t\tcase ENCRYPTION_METHOD_128BIT:\n\t\t\tWLog_INFO(TAG, \"Selected rdp encryption method: 128BIT\");\n\t\t\tbreak;\n\n\t\tcase ENCRYPTION_METHOD_FIPS:\n\t\t\tWLog_INFO(TAG, \"Selected rdp encryption method: FIPS\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_ERR(TAG, \"internal error: unknown encryption method\");\n\t\t\treturn FALSE;\n\t}\n\n\theaderLen = 12;\n\tkeyLen = 0;\n\twPublicKeyBlobLen = 0;\n\tserverRandomLen = 0;\n\tserverCertLen = 0;\n\n\tif (settings->EncryptionMethods != ENCRYPTION_METHOD_NONE)\n\t{\n\t\tserverRandomLen = 32;\n\t\tkeyLen = settings->RdpServerRsaKey->ModulusLength;\n\t\texpLen = sizeof(settings->RdpServerRsaKey->exponent);\n\t\twPublicKeyBlobLen = 4;  /* magic (RSA1) */\n\t\twPublicKeyBlobLen += 4; /* keylen */\n\t\twPublicKeyBlobLen += 4; /* bitlen */\n\t\twPublicKeyBlobLen += 4; /* datalen */\n\t\twPublicKeyBlobLen += expLen;\n\t\twPublicKeyBlobLen += keyLen;\n\t\twPublicKeyBlobLen += 8; /* 8 bytes of zero padding */\n\t\tserverCertLen = 4;      /* dwVersion */\n\t\tserverCertLen += 4;     /* dwSigAlgId */\n\t\tserverCertLen += 4;     /* dwKeyAlgId */\n\t\tserverCertLen += 2;     /* wPublicKeyBlobType */\n\t\tserverCertLen += 2;     /* wPublicKeyBlobLen */\n\t\tserverCertLen += wPublicKeyBlobLen;\n\t\tserverCertLen += 2;                          /* wSignatureBlobType */\n\t\tserverCertLen += 2;                          /* wSignatureBlobLen */\n\t\tserverCertLen += sizeof(encryptedSignature); /* SignatureBlob */\n\t\tserverCertLen += 8;                          /* 8 bytes of zero padding */\n\t\theaderLen += sizeof(serverRandomLen);\n\t\theaderLen += sizeof(serverCertLen);\n\t\theaderLen += serverRandomLen;\n\t\theaderLen += serverCertLen;\n\t}\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLen + 4))\n\t\treturn FALSE;\n\n\tgcc_write_user_data_header(s, SC_SECURITY, headerLen);\n\tStream_Write_UINT32(s, settings->EncryptionMethods); /* encryptionMethod */\n\tStream_Write_UINT32(s, settings->EncryptionLevel);   /* encryptionLevel */\n\n\tif (settings->EncryptionMethods == ENCRYPTION_METHOD_NONE)\n\t{\n\t\treturn TRUE;\n\t}\n\n\tStream_Write_UINT32(s, serverRandomLen); /* serverRandomLen */\n\tStream_Write_UINT32(s, serverCertLen);   /* serverCertLen */\n\tsettings->ServerRandomLength = serverRandomLen;\n\tsettings->ServerRandom = (BYTE*)malloc(serverRandomLen);\n\n\tif (!settings->ServerRandom)\n\t{\n\t\treturn FALSE;\n\t}\n\n\twinpr_RAND(settings->ServerRandom, serverRandomLen);\n\tStream_Write(s, settings->ServerRandom, serverRandomLen);\n\tsigData = Stream_Pointer(s);\n\tStream_Write_UINT32(s, CERT_CHAIN_VERSION_1); /* dwVersion (4 bytes) */\n\tStream_Write_UINT32(s, SIGNATURE_ALG_RSA);    /* dwSigAlgId */\n\tStream_Write_UINT32(s, KEY_EXCHANGE_ALG_RSA); /* dwKeyAlgId */\n\tStream_Write_UINT16(s, BB_RSA_KEY_BLOB);      /* wPublicKeyBlobType */\n\tStream_Write_UINT16(s, wPublicKeyBlobLen);    /* wPublicKeyBlobLen */\n\tStream_Write(s, \"RSA1\", 4);                   /* magic */\n\tStream_Write_UINT32(s, keyLen + 8);           /* keylen */\n\tStream_Write_UINT32(s, keyLen * 8);           /* bitlen */\n\tStream_Write_UINT32(s, keyLen - 1);           /* datalen */\n\tStream_Write(s, settings->RdpServerRsaKey->exponent, expLen);\n\tStream_Write(s, settings->RdpServerRsaKey->Modulus, keyLen);\n\tStream_Zero(s, 8);\n\tsigDataLen = Stream_Pointer(s) - sigData;\n\tStream_Write_UINT16(s, BB_RSA_SIGNATURE_BLOB);          /* wSignatureBlobType */\n\tStream_Write_UINT16(s, sizeof(encryptedSignature) + 8); /* wSignatureBlobLen */\n\tmemcpy(signature, initial_signature, sizeof(initial_signature));\n\n\tif (!winpr_Digest(WINPR_MD_MD5, sigData, sigDataLen, signature, sizeof(signature)))\n\t\treturn FALSE;\n\n\tcrypto_rsa_private_encrypt(signature, sizeof(signature), TSSK_KEY_LENGTH, tssk_modulus,\n\t                           tssk_privateExponent, encryptedSignature);\n\tStream_Write(s, encryptedSignature, sizeof(encryptedSignature));\n\tStream_Zero(s, 8);\n\treturn TRUE;\n}\n\n/**\n * Read a client network data block (TS_UD_CS_NET).\\n\n * @msdn{cc240512}\n * @param s stream\n * @param settings rdp settings\n */\n\nBOOL gcc_read_client_network_data(wStream* s, rdpMcs* mcs, UINT16 blockLength)\n{\n\tUINT32 i;\n\n\tif (blockLength < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, mcs->channelCount); /* channelCount */\n\n\tif (blockLength < 4 + mcs->channelCount * 12)\n\t\treturn FALSE;\n\n\tif (mcs->channelCount > CHANNEL_MAX_COUNT)\n\t\treturn FALSE;\n\n\t/* channelDefArray */\n\tfor (i = 0; i < mcs->channelCount; i++)\n\t{\n\t\t/**\n\t\t * CHANNEL_DEF\n\t\t * - name: an 8-byte array containing a null-terminated collection\n\t\t *   of seven ANSI characters that uniquely identify the channel.\n\t\t * - options: a 32-bit, unsigned integer. Channel option flags\n\t\t */\n\t\tStream_Read(s, mcs->channels[i].Name, 8); /* name (8 bytes) */\n\n\t\tif (!memchr(mcs->channels[i].Name, 0, 8))\n\t\t{\n\t\t\tWLog_ERR(\n\t\t\t    TAG,\n\t\t\t    \"protocol violation: received a static channel name with missing null-termination\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tStream_Read_UINT32(s, mcs->channels[i].options); /* options (4 bytes) */\n\t\tmcs->channels[i].ChannelId = mcs->baseChannelId++;\n\t}\n\n\treturn TRUE;\n}\n\n/**\n * Write a client network data block (TS_UD_CS_NET).\\n\n * @msdn{cc240512}\n * @param s stream\n * @param settings rdp settings\n */\n\nvoid gcc_write_client_network_data(wStream* s, rdpMcs* mcs)\n{\n\tUINT32 i;\n\tUINT16 length;\n\n\tif (mcs->channelCount > 0)\n\t{\n\t\tlength = mcs->channelCount * 12 + 8;\n\t\tgcc_write_user_data_header(s, CS_NET, length);\n\t\tStream_Write_UINT32(s, mcs->channelCount); /* channelCount */\n\n\t\t/* channelDefArray */\n\t\tfor (i = 0; i < mcs->channelCount; i++)\n\t\t{\n\t\t\t/* CHANNEL_DEF */\n\t\t\tStream_Write(s, mcs->channels[i].Name, 8);        /* name (8 bytes) */\n\t\t\tStream_Write_UINT32(s, mcs->channels[i].options); /* options (4 bytes) */\n\t\t}\n\t}\n}\n\nBOOL gcc_read_server_network_data(wStream* s, rdpMcs* mcs)\n{\n\tint i;\n\tUINT16 channelId;\n\tUINT16 MCSChannelId;\n\tUINT16 channelCount;\n\tUINT16 parsedChannelCount;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, MCSChannelId); /* MCSChannelId */\n\tStream_Read_UINT16(s, channelCount); /* channelCount */\n\tparsedChannelCount = channelCount;\n\n\tif (channelCount != mcs->channelCount)\n\t{\n\t\tWLog_ERR(TAG, \"requested %\" PRIu32 \" channels, got %\" PRIu16 \" instead\", mcs->channelCount,\n\t\t         channelCount);\n\n\t\t/* we ensure that the response is not bigger than the request */\n\n\t\tif (channelCount > mcs->channelCount)\n\t\t\tparsedChannelCount = mcs->channelCount;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < (size_t)channelCount * 2)\n\t\treturn FALSE;\n\n\tfor (i = 0; i < parsedChannelCount; i++)\n\t{\n\t\tStream_Read_UINT16(s, channelId); /* channelId */\n\t\tmcs->channels[i].ChannelId = channelId;\n\t}\n\n\tif (channelCount % 2 == 1)\n\t\treturn Stream_SafeSeek(s, 2); /* padding */\n\n\treturn TRUE;\n}\n\nBOOL gcc_write_server_network_data(wStream* s, rdpMcs* mcs)\n{\n\tUINT32 i;\n\tint payloadLen = 8 + mcs->channelCount * 2 + (mcs->channelCount % 2 == 1 ? 2 : 0);\n\n\tif (!Stream_EnsureRemainingCapacity(s, payloadLen + 4))\n\t\treturn FALSE;\n\n\tgcc_write_user_data_header(s, SC_NET, payloadLen);\n\tStream_Write_UINT16(s, MCS_GLOBAL_CHANNEL_ID); /* MCSChannelId */\n\tStream_Write_UINT16(s, mcs->channelCount);     /* channelCount */\n\n\tfor (i = 0; i < mcs->channelCount; i++)\n\t{\n\t\tStream_Write_UINT16(s, mcs->channels[i].ChannelId);\n\t}\n\n\tif (mcs->channelCount % 2 == 1)\n\t\tStream_Write_UINT16(s, 0);\n\n\treturn TRUE;\n}\n\n/**\n * Read a client cluster data block (TS_UD_CS_CLUSTER).\\n\n * @msdn{cc240514}\n * @param s stream\n * @param settings rdp settings\n */\n\nBOOL gcc_read_client_cluster_data(wStream* s, rdpMcs* mcs, UINT16 blockLength)\n{\n\tUINT32 flags;\n\tUINT32 redirectedSessionId;\n\trdpSettings* settings = mcs->settings;\n\n\tif (blockLength < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, flags);               /* flags */\n\tStream_Read_UINT32(s, redirectedSessionId); /* redirectedSessionId */\n\n\tif (flags & REDIRECTED_SESSIONID_FIELD_VALID)\n\t\tsettings->RedirectedSessionId = redirectedSessionId;\n\n\tif (blockLength != 8)\n\t{\n\t\tif (Stream_GetRemainingLength(s) >= (size_t)(blockLength - 8))\n\t\t{\n\t\t\t/* The old Microsoft Mac RDP client can send a pad here */\n\t\t\tStream_Seek(s, (blockLength - 8));\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\n/**\n * Write a client cluster data block (TS_UD_CS_CLUSTER).\\n\n * @msdn{cc240514}\n * @param s stream\n * @param settings rdp settings\n */\n\nvoid gcc_write_client_cluster_data(wStream* s, rdpMcs* mcs)\n{\n\tUINT32 flags;\n\trdpSettings* settings = mcs->settings;\n\tgcc_write_user_data_header(s, CS_CLUSTER, 12);\n\tflags = REDIRECTION_SUPPORTED | (REDIRECTION_VERSION4 << 2);\n\n\tif (settings->ConsoleSession || settings->RedirectedSessionId)\n\t\tflags |= REDIRECTED_SESSIONID_FIELD_VALID;\n\n\tif (settings->RedirectSmartCards)\n\t\tflags |= REDIRECTED_SMARTCARD;\n\n\tStream_Write_UINT32(s, flags);                         /* flags */\n\tStream_Write_UINT32(s, settings->RedirectedSessionId); /* redirectedSessionID */\n}\n\n/**\n * Read a client monitor data block (TS_UD_CS_MONITOR).\\n\n * @msdn{dd305336}\n * @param s stream\n * @param settings rdp settings\n */\n\nBOOL gcc_read_client_monitor_data(wStream* s, rdpMcs* mcs, UINT16 blockLength)\n{\n\tUINT32 index;\n\tUINT32 flags;\n\tUINT32 monitorCount;\n\tUINT32 left, top, right, bottom;\n\trdpSettings* settings = mcs->settings;\n\n\tif (blockLength < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, flags);        /* flags */\n\tStream_Read_UINT32(s, monitorCount); /* monitorCount */\n\n\t/* 2.2.1.3.6 Client Monitor Data -\n\t * monitorCount (4 bytes): A 32-bit, unsigned integer. The number of display\n\t * monitor definitions in the monitorDefArray field (the maximum allowed is 16).\n\t */\n\tif (monitorCount > 16)\n\t{\n\t\tWLog_ERR(TAG, \"announced monitors(%\" PRIu32 \") exceed the 16 limit\", monitorCount);\n\t\treturn FALSE;\n\t}\n\n\tif (monitorCount > settings->MonitorDefArraySize)\n\t{\n\t\tWLog_ERR(TAG, \"too many announced monitors(%\" PRIu32 \"), clamping to %\" PRIu32 \"\",\n\t\t         monitorCount, settings->MonitorDefArraySize);\n\t\tmonitorCount = settings->MonitorDefArraySize;\n\t}\n\n\tif ((UINT32)((blockLength - 8) / 20) < monitorCount)\n\t\treturn FALSE;\n\n\tsettings->MonitorCount = monitorCount;\n\n\tfor (index = 0; index < monitorCount; index++)\n\t{\n\t\tStream_Read_UINT32(s, left);   /* left */\n\t\tStream_Read_UINT32(s, top);    /* top */\n\t\tStream_Read_UINT32(s, right);  /* right */\n\t\tStream_Read_UINT32(s, bottom); /* bottom */\n\t\tStream_Read_UINT32(s, flags);  /* flags */\n\t\tsettings->MonitorDefArray[index].x = left;\n\t\tsettings->MonitorDefArray[index].y = top;\n\t\tsettings->MonitorDefArray[index].width = right - left + 1;\n\t\tsettings->MonitorDefArray[index].height = bottom - top + 1;\n\t\tsettings->MonitorDefArray[index].is_primary = (flags & MONITOR_PRIMARY);\n\t}\n\n\treturn TRUE;\n}\n\n/**\n * Write a client monitor data block (TS_UD_CS_MONITOR).\\n\n * @msdn{dd305336}\n * @param s stream\n * @param settings rdp settings\n */\n\nvoid gcc_write_client_monitor_data(wStream* s, rdpMcs* mcs)\n{\n\tUINT32 i;\n\tUINT16 length;\n\tUINT32 left, top, right, bottom, flags;\n\tINT32 baseX = 0, baseY = 0;\n\trdpSettings* settings = mcs->settings;\n\n\tif (settings->MonitorCount > 1)\n\t{\n\t\tlength = (20 * settings->MonitorCount) + 12;\n\t\tgcc_write_user_data_header(s, CS_MONITOR, length);\n\t\tStream_Write_UINT32(s, 0);                      /* flags */\n\t\tStream_Write_UINT32(s, settings->MonitorCount); /* monitorCount */\n\n\t\t/* first pass to get the primary monitor coordinates (it is supposed to be\n\t\t * in (0,0) */\n\t\tfor (i = 0; i < settings->MonitorCount; i++)\n\t\t{\n\t\t\tif (settings->MonitorDefArray[i].is_primary)\n\t\t\t{\n\t\t\t\tbaseX = settings->MonitorDefArray[i].x;\n\t\t\t\tbaseY = settings->MonitorDefArray[i].y;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < settings->MonitorCount; i++)\n\t\t{\n\t\t\tleft = settings->MonitorDefArray[i].x - baseX;\n\t\t\ttop = settings->MonitorDefArray[i].y - baseY;\n\t\t\tright = left + settings->MonitorDefArray[i].width - 1;\n\t\t\tbottom = top + settings->MonitorDefArray[i].height - 1;\n\t\t\tflags = settings->MonitorDefArray[i].is_primary ? MONITOR_PRIMARY : 0;\n\t\t\tStream_Write_UINT32(s, left);   /* left */\n\t\t\tStream_Write_UINT32(s, top);    /* top */\n\t\t\tStream_Write_UINT32(s, right);  /* right */\n\t\t\tStream_Write_UINT32(s, bottom); /* bottom */\n\t\t\tStream_Write_UINT32(s, flags);  /* flags */\n\t\t}\n\t}\n}\n\nBOOL gcc_read_client_monitor_extended_data(wStream* s, rdpMcs* mcs, UINT16 blockLength)\n{\n\tUINT32 index;\n\tUINT32 flags;\n\tUINT32 monitorCount;\n\tUINT32 monitorAttributeSize;\n\trdpSettings* settings = mcs->settings;\n\n\tif (blockLength < 12)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, flags);                /* flags */\n\tStream_Read_UINT32(s, monitorAttributeSize); /* monitorAttributeSize */\n\tStream_Read_UINT32(s, monitorCount);         /* monitorCount */\n\n\tif (monitorAttributeSize != 20)\n\t\treturn FALSE;\n\n\tif ((blockLength - 12) / monitorAttributeSize < monitorCount)\n\t\treturn FALSE;\n\n\tif (settings->MonitorCount != monitorCount)\n\t\treturn FALSE;\n\n\tsettings->HasMonitorAttributes = TRUE;\n\n\tfor (index = 0; index < monitorCount; index++)\n\t{\n\t\tStream_Read_UINT32(\n\t\t    s, settings->MonitorDefArray[index].attributes.physicalWidth); /* physicalWidth */\n\t\tStream_Read_UINT32(\n\t\t    s, settings->MonitorDefArray[index].attributes.physicalHeight); /* physicalHeight */\n\t\tStream_Read_UINT32(\n\t\t    s, settings->MonitorDefArray[index].attributes.orientation); /* orientation */\n\t\tStream_Read_UINT32(s, settings->MonitorDefArray[index]\n\t\t                          .attributes.desktopScaleFactor); /* desktopScaleFactor */\n\t\tStream_Read_UINT32(\n\t\t    s,\n\t\t    settings->MonitorDefArray[index].attributes.deviceScaleFactor); /* deviceScaleFactor */\n\t}\n\n\treturn TRUE;\n}\n\nvoid gcc_write_client_monitor_extended_data(wStream* s, rdpMcs* mcs)\n{\n\tUINT32 i;\n\tUINT16 length;\n\trdpSettings* settings = mcs->settings;\n\n\tif (settings->HasMonitorAttributes)\n\t{\n\t\tlength = (20 * settings->MonitorCount) + 16;\n\t\tgcc_write_user_data_header(s, CS_MONITOR_EX, length);\n\t\tStream_Write_UINT32(s, 0);                      /* flags */\n\t\tStream_Write_UINT32(s, 20);                     /* monitorAttributeSize */\n\t\tStream_Write_UINT32(s, settings->MonitorCount); /* monitorCount */\n\n\t\tfor (i = 0; i < settings->MonitorCount; i++)\n\t\t{\n\t\t\tStream_Write_UINT32(\n\t\t\t    s, settings->MonitorDefArray[i].attributes.physicalWidth); /* physicalWidth */\n\t\t\tStream_Write_UINT32(\n\t\t\t    s, settings->MonitorDefArray[i].attributes.physicalHeight); /* physicalHeight */\n\t\t\tStream_Write_UINT32(\n\t\t\t    s, settings->MonitorDefArray[i].attributes.orientation); /* orientation */\n\t\t\tStream_Write_UINT32(s, settings->MonitorDefArray[i]\n\t\t\t                           .attributes.desktopScaleFactor); /* desktopScaleFactor */\n\t\t\tStream_Write_UINT32(\n\t\t\t    s,\n\t\t\t    settings->MonitorDefArray[i].attributes.deviceScaleFactor); /* deviceScaleFactor */\n\t\t}\n\t}\n}\n\n/**\n * Read a client message channel data block (TS_UD_CS_MCS_MSGCHANNEL).\\n\n * @msdn{jj217627}\n * @param s stream\n * @param settings rdp settings\n */\n\nBOOL gcc_read_client_message_channel_data(wStream* s, rdpMcs* mcs, UINT16 blockLength)\n{\n\tUINT32 flags;\n\n\tif (blockLength < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, flags);\n\tmcs->messageChannelId = mcs->baseChannelId++;\n\treturn TRUE;\n}\n\n/**\n * Write a client message channel data block (TS_UD_CS_MCS_MSGCHANNEL).\\n\n * @msdn{jj217627}\n * @param s stream\n * @param settings rdp settings\n */\n\nvoid gcc_write_client_message_channel_data(wStream* s, rdpMcs* mcs)\n{\n\trdpSettings* settings = mcs->settings;\n\n\tif (settings->NetworkAutoDetect || settings->SupportHeartbeatPdu ||\n\t    settings->SupportMultitransport)\n\t{\n\t\tgcc_write_user_data_header(s, CS_MCS_MSGCHANNEL, 8);\n\t\tStream_Write_UINT32(s, 0); /* flags */\n\t}\n}\n\nBOOL gcc_read_server_message_channel_data(wStream* s, rdpMcs* mcs)\n{\n\tUINT16 MCSChannelId;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, MCSChannelId); /* MCSChannelId */\n\t/* Save the MCS message channel id */\n\tmcs->messageChannelId = MCSChannelId;\n\treturn TRUE;\n}\n\nBOOL gcc_write_server_message_channel_data(wStream* s, rdpMcs* mcs)\n{\n\tif (mcs->messageChannelId == 0)\n\t\treturn TRUE;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 2 + 4))\n\t\treturn FALSE;\n\n\tgcc_write_user_data_header(s, SC_MCS_MSGCHANNEL, 6);\n\tStream_Write_UINT16(s, mcs->messageChannelId); /* mcsChannelId (2 bytes) */\n\treturn TRUE;\n}\n\n/**\n * Read a client multitransport channel data block (TS_UD_CS_MULTITRANSPORT).\\n\n * @msdn{jj217498}\n * @param s stream\n * @param settings rdp settings\n */\n\nBOOL gcc_read_client_multitransport_channel_data(wStream* s, rdpMcs* mcs, UINT16 blockLength)\n{\n\tUINT32 flags;\n\n\tif (blockLength < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, flags);\n\treturn TRUE;\n}\n\n/**\n * Write a client multitransport channel data block (TS_UD_CS_MULTITRANSPORT).\\n\n * @msdn{jj217498}\n * @param s stream\n * @param settings rdp settings\n */\n\nvoid gcc_write_client_multitransport_channel_data(wStream* s, rdpMcs* mcs)\n{\n\trdpSettings* settings = mcs->settings;\n\n\tgcc_write_user_data_header(s, CS_MULTITRANSPORT, 8);\n\tStream_Write_UINT32(s, settings->MultitransportFlags); /* flags */\n}\n\nBOOL gcc_read_server_multitransport_channel_data(wStream* s, rdpMcs* mcs)\n{\n\tUINT32 flags;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, flags); /* flags */\n\treturn TRUE;\n}\n\nvoid gcc_write_server_multitransport_channel_data(wStream* s, rdpMcs* mcs)\n{\n\tUINT32 flags = 0;\n\tgcc_write_user_data_header(s, SC_MULTITRANSPORT, 8);\n\tStream_Write_UINT32(s, flags); /* flags (4 bytes) */\n}\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * Drawing Orders\n *\n * Copyright 2011 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2016 Armin Novak <armin.novak@thincast.com>\n * Copyright 2016 Thincast Technologies GmbH\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"window.h\"\n\n#include <winpr/wtypes.h>\n#include <winpr/crt.h>\n\n#include <freerdp/api.h>\n#include <freerdp/log.h>\n#include <freerdp/graphics.h>\n#include <freerdp/codec/bitmap.h>\n#include <freerdp/gdi/gdi.h>\n\n#include \"orders.h\"\n\n#include \"../cache/glyph.h\"\n#include \"../cache/bitmap.h\"\n#include \"../cache/brush.h\"\n#include \"../cache/cache.h\"\n\n#define TAG FREERDP_TAG(\"core.orders\")\n\nconst BYTE PRIMARY_DRAWING_ORDER_FIELD_BYTES[] = { DSTBLT_ORDER_FIELD_BYTES,\n\t                                               PATBLT_ORDER_FIELD_BYTES,\n\t                                               SCRBLT_ORDER_FIELD_BYTES,\n\t                                               0,\n\t                                               0,\n\t                                               0,\n\t                                               0,\n\t                                               DRAW_NINE_GRID_ORDER_FIELD_BYTES,\n\t                                               MULTI_DRAW_NINE_GRID_ORDER_FIELD_BYTES,\n\t                                               LINE_TO_ORDER_FIELD_BYTES,\n\t                                               OPAQUE_RECT_ORDER_FIELD_BYTES,\n\t                                               SAVE_BITMAP_ORDER_FIELD_BYTES,\n\t                                               0,\n\t                                               MEMBLT_ORDER_FIELD_BYTES,\n\t                                               MEM3BLT_ORDER_FIELD_BYTES,\n\t                                               MULTI_DSTBLT_ORDER_FIELD_BYTES,\n\t                                               MULTI_PATBLT_ORDER_FIELD_BYTES,\n\t                                               MULTI_SCRBLT_ORDER_FIELD_BYTES,\n\t                                               MULTI_OPAQUE_RECT_ORDER_FIELD_BYTES,\n\t                                               FAST_INDEX_ORDER_FIELD_BYTES,\n\t                                               POLYGON_SC_ORDER_FIELD_BYTES,\n\t                                               POLYGON_CB_ORDER_FIELD_BYTES,\n\t                                               POLYLINE_ORDER_FIELD_BYTES,\n\t                                               0,\n\t                                               FAST_GLYPH_ORDER_FIELD_BYTES,\n\t                                               ELLIPSE_SC_ORDER_FIELD_BYTES,\n\t                                               ELLIPSE_CB_ORDER_FIELD_BYTES,\n\t                                               GLYPH_INDEX_ORDER_FIELD_BYTES };\n\n#define PRIMARY_DRAWING_ORDER_COUNT (ARRAYSIZE(PRIMARY_DRAWING_ORDER_FIELD_BYTES))\n\nstatic const BYTE CBR2_BPP[] = { 0, 0, 0, 8, 16, 24, 32 };\n\nstatic const BYTE BPP_CBR2[] = { 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,\n\t                             0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0 };\n\nstatic const BYTE CBR23_BPP[] = { 0, 0, 0, 8, 16, 24, 32 };\n\nstatic const BYTE BPP_CBR23[] = { 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,\n\t                              0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0 };\n\nstatic const BYTE BMF_BPP[] = { 0, 1, 0, 8, 16, 24, 32, 0 };\n\nstatic const BYTE BPP_BMF[] = { 0, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,\n\t                            0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0 };\n\nstatic BOOL check_order_activated(wLog* log, rdpSettings* settings, const char* orderName,\n                                  BOOL condition)\n{\n\tif (!condition)\n\t{\n\t\tif (settings->AllowUnanouncedOrdersFromServer)\n\t\t{\n\t\t\tWLog_Print(log, WLOG_WARN,\n\t\t\t           \"%s - SERVER BUG: The support for this feature was not announced!\",\n\t\t\t           orderName);\n\t\t\treturn TRUE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tWLog_Print(log, WLOG_ERROR,\n\t\t\t           \"%s - SERVER BUG: The support for this feature was not announced! Use \"\n\t\t\t           \"/relax-order-checks to ignore\",\n\t\t\t           orderName);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL check_alt_order_supported(wLog* log, rdpSettings* settings, BYTE orderType,\n                                      const char* orderName)\n{\n\tBOOL condition = FALSE;\n\n\tswitch (orderType)\n\t{\n\t\tcase ORDER_TYPE_CREATE_OFFSCREEN_BITMAP:\n\t\tcase ORDER_TYPE_SWITCH_SURFACE:\n\t\t\tcondition = settings->OffscreenSupportLevel != 0;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_CREATE_NINE_GRID_BITMAP:\n\t\t\tcondition = settings->DrawNineGridEnabled;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_FRAME_MARKER:\n\t\t\tcondition = settings->FrameMarkerCommandEnabled;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_FIRST:\n\t\tcase ORDER_TYPE_GDIPLUS_NEXT:\n\t\tcase ORDER_TYPE_GDIPLUS_END:\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_FIRST:\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_NEXT:\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_END:\n\t\t\tcondition = settings->DrawGdiPlusCacheEnabled;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_WINDOW:\n\t\t\tcondition = settings->RemoteWndSupportLevel != WINDOW_LEVEL_NOT_SUPPORTED;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_STREAM_BITMAP_FIRST:\n\t\tcase ORDER_TYPE_STREAM_BITMAP_NEXT:\n\t\tcase ORDER_TYPE_COMPDESK_FIRST:\n\t\t\tcondition = TRUE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(log, WLOG_WARN, \"%s - Alternate Secondary Drawing Order UNKNOWN\", orderName);\n\t\t\tcondition = FALSE;\n\t\t\tbreak;\n\t}\n\n\treturn check_order_activated(log, settings, orderName, condition);\n}\n\nstatic BOOL check_secondary_order_supported(wLog* log, rdpSettings* settings, BYTE orderType,\n                                            const char* orderName)\n{\n\tBOOL condition = FALSE;\n\n\tswitch (orderType)\n\t{\n\t\tcase ORDER_TYPE_BITMAP_UNCOMPRESSED:\n\t\tcase ORDER_TYPE_CACHE_BITMAP_COMPRESSED:\n\t\t\tcondition = settings->BitmapCacheEnabled;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_BITMAP_UNCOMPRESSED_V2:\n\t\tcase ORDER_TYPE_BITMAP_COMPRESSED_V2:\n\t\t\tcondition = settings->BitmapCacheEnabled;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_BITMAP_COMPRESSED_V3:\n\t\t\tcondition = settings->BitmapCacheV3Enabled;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_COLOR_TABLE:\n\t\t\tcondition = (settings->OrderSupport[NEG_MEMBLT_INDEX] ||\n\t\t\t             settings->OrderSupport[NEG_MEM3BLT_INDEX]);\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_GLYPH:\n\t\t{\n\t\t\tswitch (settings->GlyphSupportLevel)\n\t\t\t{\n\t\t\t\tcase GLYPH_SUPPORT_PARTIAL:\n\t\t\t\tcase GLYPH_SUPPORT_FULL:\n\t\t\t\tcase GLYPH_SUPPORT_ENCODE:\n\t\t\t\t\tcondition = TRUE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase GLYPH_SUPPORT_NONE:\n\t\t\t\tdefault:\n\t\t\t\t\tcondition = FALSE;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_BRUSH:\n\t\t\tcondition = TRUE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(log, WLOG_WARN, \"SECONDARY ORDER %s not supported\", orderName);\n\t\t\tbreak;\n\t}\n\n\treturn check_order_activated(log, settings, orderName, condition);\n}\n\nstatic BOOL check_primary_order_supported(wLog* log, rdpSettings* settings, UINT32 orderType,\n                                          const char* orderName)\n{\n\tBOOL condition = FALSE;\n\n\tswitch (orderType)\n\t{\n\t\tcase ORDER_TYPE_DSTBLT:\n\t\t\tcondition = settings->OrderSupport[NEG_DSTBLT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_SCRBLT:\n\t\t\tcondition = settings->OrderSupport[NEG_SCRBLT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_DRAW_NINE_GRID:\n\t\t\tcondition = settings->OrderSupport[NEG_DRAWNINEGRID_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_DRAW_NINE_GRID:\n\t\t\tcondition = settings->OrderSupport[NEG_MULTI_DRAWNINEGRID_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_LINE_TO:\n\t\t\tcondition = settings->OrderSupport[NEG_LINETO_INDEX];\n\t\t\tbreak;\n\n\t\t/* [MS-RDPEGDI] 2.2.2.2.1.1.2.5 OpaqueRect (OPAQUERECT_ORDER)\n\t\t * suggests that PatBlt and OpaqueRect imply each other. */\n\t\tcase ORDER_TYPE_PATBLT:\n\t\tcase ORDER_TYPE_OPAQUE_RECT:\n\t\t\tcondition = settings->OrderSupport[NEG_OPAQUE_RECT_INDEX] ||\n\t\t\t            settings->OrderSupport[NEG_PATBLT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_SAVE_BITMAP:\n\t\t\tcondition = settings->OrderSupport[NEG_SAVEBITMAP_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MEMBLT:\n\t\t\tcondition = settings->OrderSupport[NEG_MEMBLT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MEM3BLT:\n\t\t\tcondition = settings->OrderSupport[NEG_MEM3BLT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_DSTBLT:\n\t\t\tcondition = settings->OrderSupport[NEG_MULTIDSTBLT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_PATBLT:\n\t\t\tcondition = settings->OrderSupport[NEG_MULTIPATBLT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_SCRBLT:\n\t\t\tcondition = settings->OrderSupport[NEG_MULTIDSTBLT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_OPAQUE_RECT:\n\t\t\tcondition = settings->OrderSupport[NEG_MULTIOPAQUERECT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_FAST_INDEX:\n\t\t\tcondition = settings->OrderSupport[NEG_FAST_INDEX_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYGON_SC:\n\t\t\tcondition = settings->OrderSupport[NEG_POLYGON_SC_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYGON_CB:\n\t\t\tcondition = settings->OrderSupport[NEG_POLYGON_CB_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYLINE:\n\t\t\tcondition = settings->OrderSupport[NEG_POLYLINE_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_FAST_GLYPH:\n\t\t\tcondition = settings->OrderSupport[NEG_FAST_GLYPH_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_ELLIPSE_SC:\n\t\t\tcondition = settings->OrderSupport[NEG_ELLIPSE_SC_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_ELLIPSE_CB:\n\t\t\tcondition = settings->OrderSupport[NEG_ELLIPSE_CB_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GLYPH_INDEX:\n\t\t\tcondition = settings->OrderSupport[NEG_GLYPH_INDEX_INDEX];\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(log, WLOG_WARN, \"%s Primary Drawing Order not supported\", orderName);\n\t\t\tbreak;\n\t}\n\n\treturn check_order_activated(log, settings, orderName, condition);\n}\n\nstatic const char* primary_order_string(UINT32 orderType)\n{\n\tconst char* orders[] = { \"[0x%02\" PRIx8 \"] DstBlt\",\n\t\t                     \"[0x%02\" PRIx8 \"] PatBlt\",\n\t\t                     \"[0x%02\" PRIx8 \"] ScrBlt\",\n\t\t                     \"[0x%02\" PRIx8 \"] UNUSED\",\n\t\t                     \"[0x%02\" PRIx8 \"] UNUSED\",\n\t\t                     \"[0x%02\" PRIx8 \"] UNUSED\",\n\t\t                     \"[0x%02\" PRIx8 \"] UNUSED\",\n\t\t                     \"[0x%02\" PRIx8 \"] DrawNineGrid\",\n\t\t                     \"[0x%02\" PRIx8 \"] MultiDrawNineGrid\",\n\t\t                     \"[0x%02\" PRIx8 \"] LineTo\",\n\t\t                     \"[0x%02\" PRIx8 \"] OpaqueRect\",\n\t\t                     \"[0x%02\" PRIx8 \"] SaveBitmap\",\n\t\t                     \"[0x%02\" PRIx8 \"] UNUSED\",\n\t\t                     \"[0x%02\" PRIx8 \"] MemBlt\",\n\t\t                     \"[0x%02\" PRIx8 \"] Mem3Blt\",\n\t\t                     \"[0x%02\" PRIx8 \"] MultiDstBlt\",\n\t\t                     \"[0x%02\" PRIx8 \"] MultiPatBlt\",\n\t\t                     \"[0x%02\" PRIx8 \"] MultiScrBlt\",\n\t\t                     \"[0x%02\" PRIx8 \"] MultiOpaqueRect\",\n\t\t                     \"[0x%02\" PRIx8 \"] FastIndex\",\n\t\t                     \"[0x%02\" PRIx8 \"] PolygonSC\",\n\t\t                     \"[0x%02\" PRIx8 \"] PolygonCB\",\n\t\t                     \"[0x%02\" PRIx8 \"] Polyline\",\n\t\t                     \"[0x%02\" PRIx8 \"] UNUSED\",\n\t\t                     \"[0x%02\" PRIx8 \"] FastGlyph\",\n\t\t                     \"[0x%02\" PRIx8 \"] EllipseSC\",\n\t\t                     \"[0x%02\" PRIx8 \"] EllipseCB\",\n\t\t                     \"[0x%02\" PRIx8 \"] GlyphIndex\" };\n\tconst char* fmt = \"[0x%02\" PRIx8 \"] UNKNOWN\";\n\tstatic char buffer[64] = { 0 };\n\n\tif (orderType < ARRAYSIZE(orders))\n\t\tfmt = orders[orderType];\n\n\tsprintf_s(buffer, ARRAYSIZE(buffer), fmt, orderType);\n\treturn buffer;\n}\nstatic const char* secondary_order_string(UINT32 orderType)\n{\n\tconst char* orders[] = { \"[0x%02\" PRIx8 \"] Cache Bitmap\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Color Table\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Bitmap (Compressed)\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Glyph\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Bitmap V2\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Bitmap V2 (Compressed)\",\n\t\t                     \"[0x%02\" PRIx8 \"] UNUSED\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Brush\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Bitmap V3\" };\n\tconst char* fmt = \"[0x%02\" PRIx8 \"] UNKNOWN\";\n\tstatic char buffer[64] = { 0 };\n\n\tif (orderType < ARRAYSIZE(orders))\n\t\tfmt = orders[orderType];\n\n\tsprintf_s(buffer, ARRAYSIZE(buffer), fmt, orderType);\n\treturn buffer;\n}\nstatic const char* altsec_order_string(BYTE orderType)\n{\n\tconst char* orders[] = {\n\t\t\"[0x%02\" PRIx8 \"] Switch Surface\",         \"[0x%02\" PRIx8 \"] Create Offscreen Bitmap\",\n\t\t\"[0x%02\" PRIx8 \"] Stream Bitmap First\",    \"[0x%02\" PRIx8 \"] Stream Bitmap Next\",\n\t\t\"[0x%02\" PRIx8 \"] Create NineGrid Bitmap\", \"[0x%02\" PRIx8 \"] Draw GDI+ First\",\n\t\t\"[0x%02\" PRIx8 \"] Draw GDI+ Next\",         \"[0x%02\" PRIx8 \"] Draw GDI+ End\",\n\t\t\"[0x%02\" PRIx8 \"] Draw GDI+ Cache First\",  \"[0x%02\" PRIx8 \"] Draw GDI+ Cache Next\",\n\t\t\"[0x%02\" PRIx8 \"] Draw GDI+ Cache End\",    \"[0x%02\" PRIx8 \"] Windowing\",\n\t\t\"[0x%02\" PRIx8 \"] Desktop Composition\",    \"[0x%02\" PRIx8 \"] Frame Marker\"\n\t};\n\tconst char* fmt = \"[0x%02\" PRIx8 \"] UNKNOWN\";\n\tstatic char buffer[64] = { 0 };\n\n\tif (orderType < ARRAYSIZE(orders))\n\t\tfmt = orders[orderType];\n\n\tsprintf_s(buffer, ARRAYSIZE(buffer), fmt, orderType);\n\treturn buffer;\n}\n\nstatic INLINE BOOL update_read_coord(wStream* s, INT32* coord, BOOL delta)\n{\n\tINT8 lsi8;\n\tINT16 lsi16;\n\n\tif (delta)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_INT8(s, lsi8);\n\t\t*coord += lsi8;\n\t}\n\telse\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_INT16(s, lsi16);\n\t\t*coord = lsi16;\n\t}\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_write_coord(wStream* s, INT32 coord)\n{\n\tStream_Write_UINT16(s, coord);\n\treturn TRUE;\n}\nstatic INLINE BOOL update_read_color(wStream* s, UINT32* color)\n{\n\tBYTE byte;\n\n\tif (Stream_GetRemainingLength(s) < 3)\n\t\treturn FALSE;\n\n\t*color = 0;\n\tStream_Read_UINT8(s, byte);\n\t*color = (UINT32)byte;\n\tStream_Read_UINT8(s, byte);\n\t*color |= ((UINT32)byte << 8) & 0xFF00;\n\tStream_Read_UINT8(s, byte);\n\t*color |= ((UINT32)byte << 16) & 0xFF0000;\n\treturn TRUE;\n}\nstatic INLINE BOOL update_write_color(wStream* s, UINT32 color)\n{\n\tBYTE byte;\n\tbyte = (color & 0xFF);\n\tStream_Write_UINT8(s, byte);\n\tbyte = ((color >> 8) & 0xFF);\n\tStream_Write_UINT8(s, byte);\n\tbyte = ((color >> 16) & 0xFF);\n\tStream_Write_UINT8(s, byte);\n\treturn TRUE;\n}\nstatic INLINE BOOL update_read_colorref(wStream* s, UINT32* color)\n{\n\tBYTE byte;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\t*color = 0;\n\tStream_Read_UINT8(s, byte);\n\t*color = byte;\n\tStream_Read_UINT8(s, byte);\n\t*color |= ((UINT32)byte << 8);\n\tStream_Read_UINT8(s, byte);\n\t*color |= ((UINT32)byte << 16);\n\tStream_Seek_UINT8(s);\n\treturn TRUE;\n}\nstatic INLINE BOOL update_read_color_quad(wStream* s, UINT32* color)\n{\n\treturn update_read_colorref(s, color);\n}\nstatic INLINE void update_write_color_quad(wStream* s, UINT32 color)\n{\n\tBYTE byte;\n\tbyte = (color >> 16) & 0xFF;\n\tStream_Write_UINT8(s, byte);\n\tbyte = (color >> 8) & 0xFF;\n\tStream_Write_UINT8(s, byte);\n\tbyte = color & 0xFF;\n\tStream_Write_UINT8(s, byte);\n}\nstatic INLINE BOOL update_read_2byte_unsigned(wStream* s, UINT32* value)\n{\n\tBYTE byte;\n\n\tif (Stream_GetRemainingLength(s) < 1)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, byte);\n\n\tif (byte & 0x80)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\t*value = (byte & 0x7F) << 8;\n\t\tStream_Read_UINT8(s, byte);\n\t\t*value |= byte;\n\t}\n\telse\n\t{\n\t\t*value = (byte & 0x7F);\n\t}\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_write_2byte_unsigned(wStream* s, UINT32 value)\n{\n\tBYTE byte;\n\n\tif (value > 0x7FFF)\n\t\treturn FALSE;\n\n\tif (value >= 0x7F)\n\t{\n\t\tbyte = ((value & 0x7F00) >> 8);\n\t\tStream_Write_UINT8(s, byte | 0x80);\n\t\tbyte = (value & 0xFF);\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\telse\n\t{\n\t\tbyte = (value & 0x7F);\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_read_2byte_signed(wStream* s, INT32* value)\n{\n\tBYTE byte;\n\tBOOL negative;\n\n\tif (Stream_GetRemainingLength(s) < 1)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, byte);\n\tnegative = (byte & 0x40) ? TRUE : FALSE;\n\t*value = (byte & 0x3F);\n\n\tif (byte & 0x80)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, byte);\n\t\t*value = (*value << 8) | byte;\n\t}\n\n\tif (negative)\n\t\t*value *= -1;\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_write_2byte_signed(wStream* s, INT32 value)\n{\n\tBYTE byte;\n\tBOOL negative = FALSE;\n\n\tif (value < 0)\n\t{\n\t\tnegative = TRUE;\n\t\tvalue *= -1;\n\t}\n\n\tif (value > 0x3FFF)\n\t\treturn FALSE;\n\n\tif (value >= 0x3F)\n\t{\n\t\tbyte = ((value & 0x3F00) >> 8);\n\n\t\tif (negative)\n\t\t\tbyte |= 0x40;\n\n\t\tStream_Write_UINT8(s, byte | 0x80);\n\t\tbyte = (value & 0xFF);\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\telse\n\t{\n\t\tbyte = (value & 0x3F);\n\n\t\tif (negative)\n\t\t\tbyte |= 0x40;\n\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_read_4byte_unsigned(wStream* s, UINT32* value)\n{\n\tBYTE byte;\n\tBYTE count;\n\n\tif (Stream_GetRemainingLength(s) < 1)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, byte);\n\tcount = (byte & 0xC0) >> 6;\n\n\tif (Stream_GetRemainingLength(s) < count)\n\t\treturn FALSE;\n\n\tswitch (count)\n\t{\n\t\tcase 0:\n\t\t\t*value = (byte & 0x3F);\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\t*value = (byte & 0x3F) << 8;\n\t\t\tStream_Read_UINT8(s, byte);\n\t\t\t*value |= byte;\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\t*value = (byte & 0x3F) << 16;\n\t\t\tStream_Read_UINT8(s, byte);\n\t\t\t*value |= (byte << 8);\n\t\t\tStream_Read_UINT8(s, byte);\n\t\t\t*value |= byte;\n\t\t\tbreak;\n\n\t\tcase 3:\n\t\t\t*value = (byte & 0x3F) << 24;\n\t\t\tStream_Read_UINT8(s, byte);\n\t\t\t*value |= (byte << 16);\n\t\t\tStream_Read_UINT8(s, byte);\n\t\t\t*value |= (byte << 8);\n\t\t\tStream_Read_UINT8(s, byte);\n\t\t\t*value |= byte;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_write_4byte_unsigned(wStream* s, UINT32 value)\n{\n\tBYTE byte;\n\n\tif (value <= 0x3F)\n\t{\n\t\tStream_Write_UINT8(s, value);\n\t}\n\telse if (value <= 0x3FFF)\n\t{\n\t\tbyte = (value >> 8) & 0x3F;\n\t\tStream_Write_UINT8(s, byte | 0x40);\n\t\tbyte = (value & 0xFF);\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\telse if (value <= 0x3FFFFF)\n\t{\n\t\tbyte = (value >> 16) & 0x3F;\n\t\tStream_Write_UINT8(s, byte | 0x80);\n\t\tbyte = (value >> 8) & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t\tbyte = (value & 0xFF);\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\telse if (value <= 0x3FFFFFFF)\n\t{\n\t\tbyte = (value >> 24) & 0x3F;\n\t\tStream_Write_UINT8(s, byte | 0xC0);\n\t\tbyte = (value >> 16) & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t\tbyte = (value >> 8) & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t\tbyte = (value & 0xFF);\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\telse\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_read_delta(wStream* s, INT32* value)\n{\n\tBYTE byte;\n\n\tif (Stream_GetRemainingLength(s) < 1)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < 1\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT8(s, byte);\n\n\tif (byte & 0x40)\n\t\t*value = (byte | ~0x3F);\n\telse\n\t\t*value = (byte & 0x3F);\n\n\tif (byte & 0x80)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < 1\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tStream_Read_UINT8(s, byte);\n\t\t*value = (*value << 8) | byte;\n\t}\n\n\treturn TRUE;\n}\n#if 0\nstatic INLINE void update_read_glyph_delta(wStream* s, UINT16* value)\n{\n\tBYTE byte;\n\tStream_Read_UINT8(s, byte);\n\n\tif (byte == 0x80)\n\t\tStream_Read_UINT16(s, *value);\n\telse\n\t\t*value = (byte & 0x3F);\n}\nstatic INLINE void update_seek_glyph_delta(wStream* s)\n{\n\tBYTE byte;\n\tStream_Read_UINT8(s, byte);\n\n\tif (byte & 0x80)\n\t\tStream_Seek_UINT8(s);\n}\n#endif\nstatic INLINE BOOL update_read_brush(wStream* s, rdpBrush* brush, BYTE fieldFlags)\n{\n\tif (fieldFlags & ORDER_FIELD_01)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, brush->x);\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_02)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, brush->y);\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_03)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, brush->style);\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_04)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, brush->hatch);\n\t}\n\n\tif (brush->style & CACHED_BRUSH)\n\t{\n\t\tbrush->index = brush->hatch;\n\t\tbrush->bpp = BMF_BPP[brush->style & 0x07];\n\n\t\tif (brush->bpp == 0)\n\t\t\tbrush->bpp = 1;\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_05)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 7)\n\t\t\treturn FALSE;\n\n\t\tbrush->data = (BYTE*)brush->p8x8;\n\t\tStream_Read_UINT8(s, brush->data[7]);\n\t\tStream_Read_UINT8(s, brush->data[6]);\n\t\tStream_Read_UINT8(s, brush->data[5]);\n\t\tStream_Read_UINT8(s, brush->data[4]);\n\t\tStream_Read_UINT8(s, brush->data[3]);\n\t\tStream_Read_UINT8(s, brush->data[2]);\n\t\tStream_Read_UINT8(s, brush->data[1]);\n\t\tbrush->data[0] = brush->hatch;\n\t}\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_write_brush(wStream* s, rdpBrush* brush, BYTE fieldFlags)\n{\n\tif (fieldFlags & ORDER_FIELD_01)\n\t{\n\t\tStream_Write_UINT8(s, brush->x);\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_02)\n\t{\n\t\tStream_Write_UINT8(s, brush->y);\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_03)\n\t{\n\t\tStream_Write_UINT8(s, brush->style);\n\t}\n\n\tif (brush->style & CACHED_BRUSH)\n\t{\n\t\tbrush->hatch = brush->index;\n\t\tbrush->bpp = BMF_BPP[brush->style & 0x07];\n\n\t\tif (brush->bpp == 0)\n\t\t\tbrush->bpp = 1;\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_04)\n\t{\n\t\tStream_Write_UINT8(s, brush->hatch);\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_05)\n\t{\n\t\tbrush->data = (BYTE*)brush->p8x8;\n\t\tStream_Write_UINT8(s, brush->data[7]);\n\t\tStream_Write_UINT8(s, brush->data[6]);\n\t\tStream_Write_UINT8(s, brush->data[5]);\n\t\tStream_Write_UINT8(s, brush->data[4]);\n\t\tStream_Write_UINT8(s, brush->data[3]);\n\t\tStream_Write_UINT8(s, brush->data[2]);\n\t\tStream_Write_UINT8(s, brush->data[1]);\n\t\tbrush->data[0] = brush->hatch;\n\t}\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_read_delta_rects(wStream* s, DELTA_RECT* rectangles, UINT32 number)\n{\n\tUINT32 i;\n\tBYTE flags = 0;\n\tBYTE* zeroBits;\n\tUINT32 zeroBitsSize;\n\n\tif (number > 45)\n\t\tnumber = 45;\n\n\tzeroBitsSize = ((number + 1) / 2);\n\n\tif (Stream_GetRemainingLength(s) < zeroBitsSize)\n\t\treturn FALSE;\n\n\tStream_GetPointer(s, zeroBits);\n\tStream_Seek(s, zeroBitsSize);\n\tZeroMemory(rectangles, sizeof(DELTA_RECT) * number);\n\n\tfor (i = 0; i < number; i++)\n\t{\n\t\tif (i % 2 == 0)\n\t\t\tflags = zeroBits[i / 2];\n\n\t\tif ((~flags & 0x80) && !update_read_delta(s, &rectangles[i].left))\n\t\t\treturn FALSE;\n\n\t\tif ((~flags & 0x40) && !update_read_delta(s, &rectangles[i].top))\n\t\t\treturn FALSE;\n\n\t\tif (~flags & 0x20)\n\t\t{\n\t\t\tif (!update_read_delta(s, &rectangles[i].width))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse if (i > 0)\n\t\t\trectangles[i].width = rectangles[i - 1].width;\n\t\telse\n\t\t\trectangles[i].width = 0;\n\n\t\tif (~flags & 0x10)\n\t\t{\n\t\t\tif (!update_read_delta(s, &rectangles[i].height))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse if (i > 0)\n\t\t\trectangles[i].height = rectangles[i - 1].height;\n\t\telse\n\t\t\trectangles[i].height = 0;\n\n\t\tif (i > 0)\n\t\t{\n\t\t\trectangles[i].left += rectangles[i - 1].left;\n\t\t\trectangles[i].top += rectangles[i - 1].top;\n\t\t}\n\n\t\tflags <<= 4;\n\t}\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_read_delta_points(wStream* s, DELTA_POINT* points, int number, INT16 x,\n                                            INT16 y)\n{\n\tint i;\n\tBYTE flags = 0;\n\tBYTE* zeroBits;\n\tUINT32 zeroBitsSize;\n\tzeroBitsSize = ((number + 3) / 4);\n\n\tif (Stream_GetRemainingLength(s) < zeroBitsSize)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < %\" PRIu32 \"\", zeroBitsSize);\n\t\treturn FALSE;\n\t}\n\n\tStream_GetPointer(s, zeroBits);\n\tStream_Seek(s, zeroBitsSize);\n\tZeroMemory(points, sizeof(DELTA_POINT) * number);\n\n\tfor (i = 0; i < number; i++)\n\t{\n\t\tif (i % 4 == 0)\n\t\t\tflags = zeroBits[i / 4];\n\n\t\tif ((~flags & 0x80) && !update_read_delta(s, &points[i].x))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"update_read_delta(x) failed\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tif ((~flags & 0x40) && !update_read_delta(s, &points[i].y))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"update_read_delta(y) failed\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tflags <<= 2;\n\t}\n\n\treturn TRUE;\n}\n#define ORDER_FIELD_BYTE(NO, TARGET)                        \\\n\tdo                                                      \\\n\t{                                                       \\\n\t\tif (orderInfo->fieldFlags & (1 << (NO - 1)))        \\\n\t\t{                                                   \\\n\t\t\tif (Stream_GetRemainingLength(s) < 1)           \\\n\t\t\t{                                               \\\n\t\t\t\tWLog_ERR(TAG, \"error reading %s\", #TARGET); \\\n\t\t\t\treturn FALSE;                               \\\n\t\t\t}                                               \\\n\t\t\tStream_Read_UINT8(s, TARGET);                   \\\n\t\t}                                                   \\\n\t} while (0)\n#define ORDER_FIELD_2BYTE(NO, TARGET1, TARGET2)                              \\\n\tdo                                                                       \\\n\t{                                                                        \\\n\t\tif (orderInfo->fieldFlags & (1 << (NO - 1)))                         \\\n\t\t{                                                                    \\\n\t\t\tif (Stream_GetRemainingLength(s) < 2)                            \\\n\t\t\t{                                                                \\\n\t\t\t\tWLog_ERR(TAG, \"error reading %s or %s\", #TARGET1, #TARGET2); \\\n\t\t\t\treturn FALSE;                                                \\\n\t\t\t}                                                                \\\n\t\t\tStream_Read_UINT8(s, TARGET1);                                   \\\n\t\t\tStream_Read_UINT8(s, TARGET2);                                   \\\n\t\t}                                                                    \\\n\t} while (0)\n#define ORDER_FIELD_UINT16(NO, TARGET)                      \\\n\tdo                                                      \\\n\t{                                                       \\\n\t\tif (orderInfo->fieldFlags & (1 << (NO - 1)))        \\\n\t\t{                                                   \\\n\t\t\tif (Stream_GetRemainingLength(s) < 2)           \\\n\t\t\t{                                               \\\n\t\t\t\tWLog_ERR(TAG, \"error reading %s\", #TARGET); \\\n\t\t\t\treturn FALSE;                               \\\n\t\t\t}                                               \\\n\t\t\tStream_Read_UINT16(s, TARGET);                  \\\n\t\t}                                                   \\\n\t} while (0)\n#define ORDER_FIELD_UINT32(NO, TARGET)                      \\\n\tdo                                                      \\\n\t{                                                       \\\n\t\tif (orderInfo->fieldFlags & (1 << (NO - 1)))        \\\n\t\t{                                                   \\\n\t\t\tif (Stream_GetRemainingLength(s) < 4)           \\\n\t\t\t{                                               \\\n\t\t\t\tWLog_ERR(TAG, \"error reading %s\", #TARGET); \\\n\t\t\t\treturn FALSE;                               \\\n\t\t\t}                                               \\\n\t\t\tStream_Read_UINT32(s, TARGET);                  \\\n\t\t}                                                   \\\n\t} while (0)\n#define ORDER_FIELD_COORD(NO, TARGET)                                    \\\n\tdo                                                                   \\\n\t{                                                                    \\\n\t\tif ((orderInfo->fieldFlags & (1 << (NO - 1))) &&                 \\\n\t\t    !update_read_coord(s, &TARGET, orderInfo->deltaCoordinates)) \\\n\t\t{                                                                \\\n\t\t\tWLog_ERR(TAG, \"error reading %s\", #TARGET);                  \\\n\t\t\treturn FALSE;                                                \\\n\t\t}                                                                \\\n\t} while (0)\nstatic INLINE BOOL ORDER_FIELD_COLOR(const ORDER_INFO* orderInfo, wStream* s, UINT32 NO,\n                                     UINT32* TARGET)\n{\n\tif (!TARGET || !orderInfo)\n\t\treturn FALSE;\n\n\tif ((orderInfo->fieldFlags & (1 << (NO - 1))) && !update_read_color(s, TARGET))\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\nstatic INLINE BOOL FIELD_SKIP_BUFFER16(wStream* s, UINT32 TARGET_LEN)\n{\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, TARGET_LEN);\n\n\tif (!Stream_SafeSeek(s, TARGET_LEN))\n\t{\n\t\tWLog_ERR(TAG, \"error skipping %\" PRIu32 \" bytes\", TARGET_LEN);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n/* Primary Drawing Orders */\nstatic BOOL update_read_dstblt_order(wStream* s, const ORDER_INFO* orderInfo, DSTBLT_ORDER* dstblt)\n{\n\tORDER_FIELD_COORD(1, dstblt->nLeftRect);\n\tORDER_FIELD_COORD(2, dstblt->nTopRect);\n\tORDER_FIELD_COORD(3, dstblt->nWidth);\n\tORDER_FIELD_COORD(4, dstblt->nHeight);\n\tORDER_FIELD_BYTE(5, dstblt->bRop);\n\treturn TRUE;\n}\nint update_approximate_dstblt_order(ORDER_INFO* orderInfo, const DSTBLT_ORDER* dstblt)\n{\n\treturn 32;\n}\nBOOL update_write_dstblt_order(wStream* s, ORDER_INFO* orderInfo, const DSTBLT_ORDER* dstblt)\n{\n\tif (!Stream_EnsureRemainingCapacity(s, update_approximate_dstblt_order(orderInfo, dstblt)))\n\t\treturn FALSE;\n\n\torderInfo->fieldFlags = 0;\n\torderInfo->fieldFlags |= ORDER_FIELD_01;\n\tupdate_write_coord(s, dstblt->nLeftRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_02;\n\tupdate_write_coord(s, dstblt->nTopRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_03;\n\tupdate_write_coord(s, dstblt->nWidth);\n\torderInfo->fieldFlags |= ORDER_FIELD_04;\n\tupdate_write_coord(s, dstblt->nHeight);\n\torderInfo->fieldFlags |= ORDER_FIELD_05;\n\tStream_Write_UINT8(s, dstblt->bRop);\n\treturn TRUE;\n}\nstatic BOOL update_read_patblt_order(wStream* s, const ORDER_INFO* orderInfo, PATBLT_ORDER* patblt)\n{\n\tORDER_FIELD_COORD(1, patblt->nLeftRect);\n\tORDER_FIELD_COORD(2, patblt->nTopRect);\n\tORDER_FIELD_COORD(3, patblt->nWidth);\n\tORDER_FIELD_COORD(4, patblt->nHeight);\n\tORDER_FIELD_BYTE(5, patblt->bRop);\n\tORDER_FIELD_COLOR(orderInfo, s, 6, &patblt->backColor);\n\tORDER_FIELD_COLOR(orderInfo, s, 7, &patblt->foreColor);\n\treturn update_read_brush(s, &patblt->brush, orderInfo->fieldFlags >> 7);\n}\nint update_approximate_patblt_order(ORDER_INFO* orderInfo, PATBLT_ORDER* patblt)\n{\n\treturn 32;\n}\nBOOL update_write_patblt_order(wStream* s, ORDER_INFO* orderInfo, PATBLT_ORDER* patblt)\n{\n\tif (!Stream_EnsureRemainingCapacity(s, update_approximate_patblt_order(orderInfo, patblt)))\n\t\treturn FALSE;\n\n\torderInfo->fieldFlags = 0;\n\torderInfo->fieldFlags |= ORDER_FIELD_01;\n\tupdate_write_coord(s, patblt->nLeftRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_02;\n\tupdate_write_coord(s, patblt->nTopRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_03;\n\tupdate_write_coord(s, patblt->nWidth);\n\torderInfo->fieldFlags |= ORDER_FIELD_04;\n\tupdate_write_coord(s, patblt->nHeight);\n\torderInfo->fieldFlags |= ORDER_FIELD_05;\n\tStream_Write_UINT8(s, patblt->bRop);\n\torderInfo->fieldFlags |= ORDER_FIELD_06;\n\tupdate_write_color(s, patblt->backColor);\n\torderInfo->fieldFlags |= ORDER_FIELD_07;\n\tupdate_write_color(s, patblt->foreColor);\n\torderInfo->fieldFlags |= ORDER_FIELD_08;\n\torderInfo->fieldFlags |= ORDER_FIELD_09;\n\torderInfo->fieldFlags |= ORDER_FIELD_10;\n\torderInfo->fieldFlags |= ORDER_FIELD_11;\n\torderInfo->fieldFlags |= ORDER_FIELD_12;\n\tupdate_write_brush(s, &patblt->brush, orderInfo->fieldFlags >> 7);\n\treturn TRUE;\n}\nstatic BOOL update_read_scrblt_order(wStream* s, const ORDER_INFO* orderInfo, SCRBLT_ORDER* scrblt)\n{\n\tORDER_FIELD_COORD(1, scrblt->nLeftRect);\n\tORDER_FIELD_COORD(2, scrblt->nTopRect);\n\tORDER_FIELD_COORD(3, scrblt->nWidth);\n\tORDER_FIELD_COORD(4, scrblt->nHeight);\n\tORDER_FIELD_BYTE(5, scrblt->bRop);\n\tORDER_FIELD_COORD(6, scrblt->nXSrc);\n\tORDER_FIELD_COORD(7, scrblt->nYSrc);\n\treturn TRUE;\n}\nint update_approximate_scrblt_order(ORDER_INFO* orderInfo, const SCRBLT_ORDER* scrblt)\n{\n\treturn 32;\n}\nBOOL update_write_scrblt_order(wStream* s, ORDER_INFO* orderInfo, const SCRBLT_ORDER* scrblt)\n{\n\tif (!Stream_EnsureRemainingCapacity(s, update_approximate_scrblt_order(orderInfo, scrblt)))\n\t\treturn FALSE;\n\n\torderInfo->fieldFlags = 0;\n\torderInfo->fieldFlags |= ORDER_FIELD_01;\n\tupdate_write_coord(s, scrblt->nLeftRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_02;\n\tupdate_write_coord(s, scrblt->nTopRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_03;\n\tupdate_write_coord(s, scrblt->nWidth);\n\torderInfo->fieldFlags |= ORDER_FIELD_04;\n\tupdate_write_coord(s, scrblt->nHeight);\n\torderInfo->fieldFlags |= ORDER_FIELD_05;\n\tStream_Write_UINT8(s, scrblt->bRop);\n\torderInfo->fieldFlags |= ORDER_FIELD_06;\n\tupdate_write_coord(s, scrblt->nXSrc);\n\torderInfo->fieldFlags |= ORDER_FIELD_07;\n\tupdate_write_coord(s, scrblt->nYSrc);\n\treturn TRUE;\n}\nstatic BOOL update_read_opaque_rect_order(wStream* s, const ORDER_INFO* orderInfo,\n                                          OPAQUE_RECT_ORDER* opaque_rect)\n{\n\tBYTE byte;\n\tORDER_FIELD_COORD(1, opaque_rect->nLeftRect);\n\tORDER_FIELD_COORD(2, opaque_rect->nTopRect);\n\tORDER_FIELD_COORD(3, opaque_rect->nWidth);\n\tORDER_FIELD_COORD(4, opaque_rect->nHeight);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_05)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, byte);\n\t\topaque_rect->color = (opaque_rect->color & 0x00FFFF00) | ((UINT32)byte);\n\t}\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_06)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, byte);\n\t\topaque_rect->color = (opaque_rect->color & 0x00FF00FF) | ((UINT32)byte << 8);\n\t}\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_07)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, byte);\n\t\topaque_rect->color = (opaque_rect->color & 0x0000FFFF) | ((UINT32)byte << 16);\n\t}\n\n\treturn TRUE;\n}\nint update_approximate_opaque_rect_order(ORDER_INFO* orderInfo,\n                                         const OPAQUE_RECT_ORDER* opaque_rect)\n{\n\treturn 32;\n}\nBOOL update_write_opaque_rect_order(wStream* s, ORDER_INFO* orderInfo,\n                                    const OPAQUE_RECT_ORDER* opaque_rect)\n{\n\tBYTE byte;\n\tint inf = update_approximate_opaque_rect_order(orderInfo, opaque_rect);\n\n\tif (!Stream_EnsureRemainingCapacity(s, inf))\n\t\treturn FALSE;\n\n\t// TODO: Color format conversion\n\torderInfo->fieldFlags = 0;\n\torderInfo->fieldFlags |= ORDER_FIELD_01;\n\tupdate_write_coord(s, opaque_rect->nLeftRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_02;\n\tupdate_write_coord(s, opaque_rect->nTopRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_03;\n\tupdate_write_coord(s, opaque_rect->nWidth);\n\torderInfo->fieldFlags |= ORDER_FIELD_04;\n\tupdate_write_coord(s, opaque_rect->nHeight);\n\torderInfo->fieldFlags |= ORDER_FIELD_05;\n\tbyte = opaque_rect->color & 0x000000FF;\n\tStream_Write_UINT8(s, byte);\n\torderInfo->fieldFlags |= ORDER_FIELD_06;\n\tbyte = (opaque_rect->color & 0x0000FF00) >> 8;\n\tStream_Write_UINT8(s, byte);\n\torderInfo->fieldFlags |= ORDER_FIELD_07;\n\tbyte = (opaque_rect->color & 0x00FF0000) >> 16;\n\tStream_Write_UINT8(s, byte);\n\treturn TRUE;\n}\nstatic BOOL update_read_draw_nine_grid_order(wStream* s, const ORDER_INFO* orderInfo,\n                                             DRAW_NINE_GRID_ORDER* draw_nine_grid)\n{\n\tORDER_FIELD_COORD(1, draw_nine_grid->srcLeft);\n\tORDER_FIELD_COORD(2, draw_nine_grid->srcTop);\n\tORDER_FIELD_COORD(3, draw_nine_grid->srcRight);\n\tORDER_FIELD_COORD(4, draw_nine_grid->srcBottom);\n\tORDER_FIELD_UINT16(5, draw_nine_grid->bitmapId);\n\treturn TRUE;\n}\nstatic BOOL update_read_multi_dstblt_order(wStream* s, const ORDER_INFO* orderInfo,\n                                           MULTI_DSTBLT_ORDER* multi_dstblt)\n{\n\tORDER_FIELD_COORD(1, multi_dstblt->nLeftRect);\n\tORDER_FIELD_COORD(2, multi_dstblt->nTopRect);\n\tORDER_FIELD_COORD(3, multi_dstblt->nWidth);\n\tORDER_FIELD_COORD(4, multi_dstblt->nHeight);\n\tORDER_FIELD_BYTE(5, multi_dstblt->bRop);\n\tORDER_FIELD_BYTE(6, multi_dstblt->numRectangles);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_07)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, multi_dstblt->cbData);\n\t\treturn update_read_delta_rects(s, multi_dstblt->rectangles, multi_dstblt->numRectangles);\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_multi_patblt_order(wStream* s, const ORDER_INFO* orderInfo,\n                                           MULTI_PATBLT_ORDER* multi_patblt)\n{\n\tORDER_FIELD_COORD(1, multi_patblt->nLeftRect);\n\tORDER_FIELD_COORD(2, multi_patblt->nTopRect);\n\tORDER_FIELD_COORD(3, multi_patblt->nWidth);\n\tORDER_FIELD_COORD(4, multi_patblt->nHeight);\n\tORDER_FIELD_BYTE(5, multi_patblt->bRop);\n\tORDER_FIELD_COLOR(orderInfo, s, 6, &multi_patblt->backColor);\n\tORDER_FIELD_COLOR(orderInfo, s, 7, &multi_patblt->foreColor);\n\n\tif (!update_read_brush(s, &multi_patblt->brush, orderInfo->fieldFlags >> 7))\n\t\treturn FALSE;\n\n\tORDER_FIELD_BYTE(13, multi_patblt->numRectangles);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_14)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, multi_patblt->cbData);\n\n\t\tif (!update_read_delta_rects(s, multi_patblt->rectangles, multi_patblt->numRectangles))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_multi_scrblt_order(wStream* s, const ORDER_INFO* orderInfo,\n                                           MULTI_SCRBLT_ORDER* multi_scrblt)\n{\n\tORDER_FIELD_COORD(1, multi_scrblt->nLeftRect);\n\tORDER_FIELD_COORD(2, multi_scrblt->nTopRect);\n\tORDER_FIELD_COORD(3, multi_scrblt->nWidth);\n\tORDER_FIELD_COORD(4, multi_scrblt->nHeight);\n\tORDER_FIELD_BYTE(5, multi_scrblt->bRop);\n\tORDER_FIELD_COORD(6, multi_scrblt->nXSrc);\n\tORDER_FIELD_COORD(7, multi_scrblt->nYSrc);\n\tORDER_FIELD_BYTE(8, multi_scrblt->numRectangles);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_09)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, multi_scrblt->cbData);\n\t\treturn update_read_delta_rects(s, multi_scrblt->rectangles, multi_scrblt->numRectangles);\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_multi_opaque_rect_order(wStream* s, const ORDER_INFO* orderInfo,\n                                                MULTI_OPAQUE_RECT_ORDER* multi_opaque_rect)\n{\n\tBYTE byte;\n\tORDER_FIELD_COORD(1, multi_opaque_rect->nLeftRect);\n\tORDER_FIELD_COORD(2, multi_opaque_rect->nTopRect);\n\tORDER_FIELD_COORD(3, multi_opaque_rect->nWidth);\n\tORDER_FIELD_COORD(4, multi_opaque_rect->nHeight);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_05)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, byte);\n\t\tmulti_opaque_rect->color = (multi_opaque_rect->color & 0x00FFFF00) | ((UINT32)byte);\n\t}\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_06)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, byte);\n\t\tmulti_opaque_rect->color = (multi_opaque_rect->color & 0x00FF00FF) | ((UINT32)byte << 8);\n\t}\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_07)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, byte);\n\t\tmulti_opaque_rect->color = (multi_opaque_rect->color & 0x0000FFFF) | ((UINT32)byte << 16);\n\t}\n\n\tORDER_FIELD_BYTE(8, multi_opaque_rect->numRectangles);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_09)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, multi_opaque_rect->cbData);\n\t\treturn update_read_delta_rects(s, multi_opaque_rect->rectangles,\n\t\t                               multi_opaque_rect->numRectangles);\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_multi_draw_nine_grid_order(wStream* s, const ORDER_INFO* orderInfo,\n                                                   MULTI_DRAW_NINE_GRID_ORDER* multi_draw_nine_grid)\n{\n\tORDER_FIELD_COORD(1, multi_draw_nine_grid->srcLeft);\n\tORDER_FIELD_COORD(2, multi_draw_nine_grid->srcTop);\n\tORDER_FIELD_COORD(3, multi_draw_nine_grid->srcRight);\n\tORDER_FIELD_COORD(4, multi_draw_nine_grid->srcBottom);\n\tORDER_FIELD_UINT16(5, multi_draw_nine_grid->bitmapId);\n\tORDER_FIELD_BYTE(6, multi_draw_nine_grid->nDeltaEntries);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_07)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, multi_draw_nine_grid->cbData);\n\t\treturn update_read_delta_rects(s, multi_draw_nine_grid->rectangles,\n\t\t                               multi_draw_nine_grid->nDeltaEntries);\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_line_to_order(wStream* s, const ORDER_INFO* orderInfo,\n                                      LINE_TO_ORDER* line_to)\n{\n\tORDER_FIELD_UINT16(1, line_to->backMode);\n\tORDER_FIELD_COORD(2, line_to->nXStart);\n\tORDER_FIELD_COORD(3, line_to->nYStart);\n\tORDER_FIELD_COORD(4, line_to->nXEnd);\n\tORDER_FIELD_COORD(5, line_to->nYEnd);\n\tORDER_FIELD_COLOR(orderInfo, s, 6, &line_to->backColor);\n\tORDER_FIELD_BYTE(7, line_to->bRop2);\n\tORDER_FIELD_BYTE(8, line_to->penStyle);\n\tORDER_FIELD_BYTE(9, line_to->penWidth);\n\tORDER_FIELD_COLOR(orderInfo, s, 10, &line_to->penColor);\n\treturn TRUE;\n}\nint update_approximate_line_to_order(ORDER_INFO* orderInfo, const LINE_TO_ORDER* line_to)\n{\n\treturn 32;\n}\nBOOL update_write_line_to_order(wStream* s, ORDER_INFO* orderInfo, const LINE_TO_ORDER* line_to)\n{\n\tif (!Stream_EnsureRemainingCapacity(s, update_approximate_line_to_order(orderInfo, line_to)))\n\t\treturn FALSE;\n\n\torderInfo->fieldFlags = 0;\n\torderInfo->fieldFlags |= ORDER_FIELD_01;\n\tStream_Write_UINT16(s, line_to->backMode);\n\torderInfo->fieldFlags |= ORDER_FIELD_02;\n\tupdate_write_coord(s, line_to->nXStart);\n\torderInfo->fieldFlags |= ORDER_FIELD_03;\n\tupdate_write_coord(s, line_to->nYStart);\n\torderInfo->fieldFlags |= ORDER_FIELD_04;\n\tupdate_write_coord(s, line_to->nXEnd);\n\torderInfo->fieldFlags |= ORDER_FIELD_05;\n\tupdate_write_coord(s, line_to->nYEnd);\n\torderInfo->fieldFlags |= ORDER_FIELD_06;\n\tupdate_write_color(s, line_to->backColor);\n\torderInfo->fieldFlags |= ORDER_FIELD_07;\n\tStream_Write_UINT8(s, line_to->bRop2);\n\torderInfo->fieldFlags |= ORDER_FIELD_08;\n\tStream_Write_UINT8(s, line_to->penStyle);\n\torderInfo->fieldFlags |= ORDER_FIELD_09;\n\tStream_Write_UINT8(s, line_to->penWidth);\n\torderInfo->fieldFlags |= ORDER_FIELD_10;\n\tupdate_write_color(s, line_to->penColor);\n\treturn TRUE;\n}\nstatic BOOL update_read_polyline_order(wStream* s, const ORDER_INFO* orderInfo,\n                                       POLYLINE_ORDER* polyline)\n{\n\tUINT16 word;\n\tUINT32 new_num = polyline->numDeltaEntries;\n\tORDER_FIELD_COORD(1, polyline->xStart);\n\tORDER_FIELD_COORD(2, polyline->yStart);\n\tORDER_FIELD_BYTE(3, polyline->bRop2);\n\tORDER_FIELD_UINT16(4, word);\n\tORDER_FIELD_COLOR(orderInfo, s, 5, &polyline->penColor);\n\tORDER_FIELD_BYTE(6, new_num);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_07)\n\t{\n\t\tDELTA_POINT* new_points;\n\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < 1\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tStream_Read_UINT8(s, polyline->cbData);\n\t\tnew_points = (DELTA_POINT*)realloc(polyline->points, sizeof(DELTA_POINT) * new_num);\n\n\t\tif (!new_points)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"realloc(%\" PRIu32 \") failed\", new_num);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tpolyline->points = new_points;\n\t\tpolyline->numDeltaEntries = new_num;\n\t\treturn update_read_delta_points(s, polyline->points, polyline->numDeltaEntries,\n\t\t                                polyline->xStart, polyline->yStart);\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_memblt_order(wStream* s, const ORDER_INFO* orderInfo, MEMBLT_ORDER* memblt)\n{\n\tif (!s || !orderInfo || !memblt)\n\t\treturn FALSE;\n\n\tORDER_FIELD_UINT16(1, memblt->cacheId);\n\tORDER_FIELD_COORD(2, memblt->nLeftRect);\n\tORDER_FIELD_COORD(3, memblt->nTopRect);\n\tORDER_FIELD_COORD(4, memblt->nWidth);\n\tORDER_FIELD_COORD(5, memblt->nHeight);\n\tORDER_FIELD_BYTE(6, memblt->bRop);\n\tORDER_FIELD_COORD(7, memblt->nXSrc);\n\tORDER_FIELD_COORD(8, memblt->nYSrc);\n\tORDER_FIELD_UINT16(9, memblt->cacheIndex);\n\tmemblt->colorIndex = (memblt->cacheId >> 8);\n\tmemblt->cacheId = (memblt->cacheId & 0xFF);\n\tmemblt->bitmap = NULL;\n\treturn TRUE;\n}\nint update_approximate_memblt_order(ORDER_INFO* orderInfo, const MEMBLT_ORDER* memblt)\n{\n\treturn 64;\n}\nBOOL update_write_memblt_order(wStream* s, ORDER_INFO* orderInfo, const MEMBLT_ORDER* memblt)\n{\n\tUINT16 cacheId;\n\n\tif (!Stream_EnsureRemainingCapacity(s, update_approximate_memblt_order(orderInfo, memblt)))\n\t\treturn FALSE;\n\n\tcacheId = (memblt->cacheId & 0xFF) | ((memblt->colorIndex & 0xFF) << 8);\n\torderInfo->fieldFlags |= ORDER_FIELD_01;\n\tStream_Write_UINT16(s, cacheId);\n\torderInfo->fieldFlags |= ORDER_FIELD_02;\n\tupdate_write_coord(s, memblt->nLeftRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_03;\n\tupdate_write_coord(s, memblt->nTopRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_04;\n\tupdate_write_coord(s, memblt->nWidth);\n\torderInfo->fieldFlags |= ORDER_FIELD_05;\n\tupdate_write_coord(s, memblt->nHeight);\n\torderInfo->fieldFlags |= ORDER_FIELD_06;\n\tStream_Write_UINT8(s, memblt->bRop);\n\torderInfo->fieldFlags |= ORDER_FIELD_07;\n\tupdate_write_coord(s, memblt->nXSrc);\n\torderInfo->fieldFlags |= ORDER_FIELD_08;\n\tupdate_write_coord(s, memblt->nYSrc);\n\torderInfo->fieldFlags |= ORDER_FIELD_09;\n\tStream_Write_UINT16(s, memblt->cacheIndex);\n\treturn TRUE;\n}\nstatic BOOL update_read_mem3blt_order(wStream* s, const ORDER_INFO* orderInfo,\n                                      MEM3BLT_ORDER* mem3blt)\n{\n\tORDER_FIELD_UINT16(1, mem3blt->cacheId);\n\tORDER_FIELD_COORD(2, mem3blt->nLeftRect);\n\tORDER_FIELD_COORD(3, mem3blt->nTopRect);\n\tORDER_FIELD_COORD(4, mem3blt->nWidth);\n\tORDER_FIELD_COORD(5, mem3blt->nHeight);\n\tORDER_FIELD_BYTE(6, mem3blt->bRop);\n\tORDER_FIELD_COORD(7, mem3blt->nXSrc);\n\tORDER_FIELD_COORD(8, mem3blt->nYSrc);\n\tORDER_FIELD_COLOR(orderInfo, s, 9, &mem3blt->backColor);\n\tORDER_FIELD_COLOR(orderInfo, s, 10, &mem3blt->foreColor);\n\n\tif (!update_read_brush(s, &mem3blt->brush, orderInfo->fieldFlags >> 10))\n\t\treturn FALSE;\n\n\tORDER_FIELD_UINT16(16, mem3blt->cacheIndex);\n\tmem3blt->colorIndex = (mem3blt->cacheId >> 8);\n\tmem3blt->cacheId = (mem3blt->cacheId & 0xFF);\n\tmem3blt->bitmap = NULL;\n\treturn TRUE;\n}\nstatic BOOL update_read_save_bitmap_order(wStream* s, const ORDER_INFO* orderInfo,\n                                          SAVE_BITMAP_ORDER* save_bitmap)\n{\n\tORDER_FIELD_UINT32(1, save_bitmap->savedBitmapPosition);\n\tORDER_FIELD_COORD(2, save_bitmap->nLeftRect);\n\tORDER_FIELD_COORD(3, save_bitmap->nTopRect);\n\tORDER_FIELD_COORD(4, save_bitmap->nRightRect);\n\tORDER_FIELD_COORD(5, save_bitmap->nBottomRect);\n\tORDER_FIELD_BYTE(6, save_bitmap->operation);\n\treturn TRUE;\n}\nstatic BOOL update_read_glyph_index_order(wStream* s, const ORDER_INFO* orderInfo,\n                                          GLYPH_INDEX_ORDER* glyph_index)\n{\n\tORDER_FIELD_BYTE(1, glyph_index->cacheId);\n\tORDER_FIELD_BYTE(2, glyph_index->flAccel);\n\tORDER_FIELD_BYTE(3, glyph_index->ulCharInc);\n\tORDER_FIELD_BYTE(4, glyph_index->fOpRedundant);\n\tORDER_FIELD_COLOR(orderInfo, s, 5, &glyph_index->backColor);\n\tORDER_FIELD_COLOR(orderInfo, s, 6, &glyph_index->foreColor);\n\tORDER_FIELD_UINT16(7, glyph_index->bkLeft);\n\tORDER_FIELD_UINT16(8, glyph_index->bkTop);\n\tORDER_FIELD_UINT16(9, glyph_index->bkRight);\n\tORDER_FIELD_UINT16(10, glyph_index->bkBottom);\n\tORDER_FIELD_UINT16(11, glyph_index->opLeft);\n\tORDER_FIELD_UINT16(12, glyph_index->opTop);\n\tORDER_FIELD_UINT16(13, glyph_index->opRight);\n\tORDER_FIELD_UINT16(14, glyph_index->opBottom);\n\n\tif (!update_read_brush(s, &glyph_index->brush, orderInfo->fieldFlags >> 14))\n\t\treturn FALSE;\n\n\tORDER_FIELD_UINT16(20, glyph_index->x);\n\tORDER_FIELD_UINT16(21, glyph_index->y);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_22)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, glyph_index->cbData);\n\n\t\tif (Stream_GetRemainingLength(s) < glyph_index->cbData)\n\t\t\treturn FALSE;\n\n\t\tCopyMemory(glyph_index->data, Stream_Pointer(s), glyph_index->cbData);\n\t\tStream_Seek(s, glyph_index->cbData);\n\t}\n\n\treturn TRUE;\n}\nint update_approximate_glyph_index_order(ORDER_INFO* orderInfo,\n                                         const GLYPH_INDEX_ORDER* glyph_index)\n{\n\treturn 64;\n}\nBOOL update_write_glyph_index_order(wStream* s, ORDER_INFO* orderInfo,\n                                    GLYPH_INDEX_ORDER* glyph_index)\n{\n\tint inf = update_approximate_glyph_index_order(orderInfo, glyph_index);\n\n\tif (!Stream_EnsureRemainingCapacity(s, inf))\n\t\treturn FALSE;\n\n\torderInfo->fieldFlags = 0;\n\torderInfo->fieldFlags |= ORDER_FIELD_01;\n\tStream_Write_UINT8(s, glyph_index->cacheId);\n\torderInfo->fieldFlags |= ORDER_FIELD_02;\n\tStream_Write_UINT8(s, glyph_index->flAccel);\n\torderInfo->fieldFlags |= ORDER_FIELD_03;\n\tStream_Write_UINT8(s, glyph_index->ulCharInc);\n\torderInfo->fieldFlags |= ORDER_FIELD_04;\n\tStream_Write_UINT8(s, glyph_index->fOpRedundant);\n\torderInfo->fieldFlags |= ORDER_FIELD_05;\n\tupdate_write_color(s, glyph_index->backColor);\n\torderInfo->fieldFlags |= ORDER_FIELD_06;\n\tupdate_write_color(s, glyph_index->foreColor);\n\torderInfo->fieldFlags |= ORDER_FIELD_07;\n\tStream_Write_UINT16(s, glyph_index->bkLeft);\n\torderInfo->fieldFlags |= ORDER_FIELD_08;\n\tStream_Write_UINT16(s, glyph_index->bkTop);\n\torderInfo->fieldFlags |= ORDER_FIELD_09;\n\tStream_Write_UINT16(s, glyph_index->bkRight);\n\torderInfo->fieldFlags |= ORDER_FIELD_10;\n\tStream_Write_UINT16(s, glyph_index->bkBottom);\n\torderInfo->fieldFlags |= ORDER_FIELD_11;\n\tStream_Write_UINT16(s, glyph_index->opLeft);\n\torderInfo->fieldFlags |= ORDER_FIELD_12;\n\tStream_Write_UINT16(s, glyph_index->opTop);\n\torderInfo->fieldFlags |= ORDER_FIELD_13;\n\tStream_Write_UINT16(s, glyph_index->opRight);\n\torderInfo->fieldFlags |= ORDER_FIELD_14;\n\tStream_Write_UINT16(s, glyph_index->opBottom);\n\torderInfo->fieldFlags |= ORDER_FIELD_15;\n\torderInfo->fieldFlags |= ORDER_FIELD_16;\n\torderInfo->fieldFlags |= ORDER_FIELD_17;\n\torderInfo->fieldFlags |= ORDER_FIELD_18;\n\torderInfo->fieldFlags |= ORDER_FIELD_19;\n\tupdate_write_brush(s, &glyph_index->brush, orderInfo->fieldFlags >> 14);\n\torderInfo->fieldFlags |= ORDER_FIELD_20;\n\tStream_Write_UINT16(s, glyph_index->x);\n\torderInfo->fieldFlags |= ORDER_FIELD_21;\n\tStream_Write_UINT16(s, glyph_index->y);\n\torderInfo->fieldFlags |= ORDER_FIELD_22;\n\tStream_Write_UINT8(s, glyph_index->cbData);\n\tStream_Write(s, glyph_index->data, glyph_index->cbData);\n\treturn TRUE;\n}\nstatic BOOL update_read_fast_index_order(wStream* s, const ORDER_INFO* orderInfo,\n                                         FAST_INDEX_ORDER* fast_index)\n{\n\tORDER_FIELD_BYTE(1, fast_index->cacheId);\n\tORDER_FIELD_2BYTE(2, fast_index->ulCharInc, fast_index->flAccel);\n\tORDER_FIELD_COLOR(orderInfo, s, 3, &fast_index->backColor);\n\tORDER_FIELD_COLOR(orderInfo, s, 4, &fast_index->foreColor);\n\tORDER_FIELD_COORD(5, fast_index->bkLeft);\n\tORDER_FIELD_COORD(6, fast_index->bkTop);\n\tORDER_FIELD_COORD(7, fast_index->bkRight);\n\tORDER_FIELD_COORD(8, fast_index->bkBottom);\n\tORDER_FIELD_COORD(9, fast_index->opLeft);\n\tORDER_FIELD_COORD(10, fast_index->opTop);\n\tORDER_FIELD_COORD(11, fast_index->opRight);\n\tORDER_FIELD_COORD(12, fast_index->opBottom);\n\tORDER_FIELD_COORD(13, fast_index->x);\n\tORDER_FIELD_COORD(14, fast_index->y);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_15)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, fast_index->cbData);\n\n\t\tif (Stream_GetRemainingLength(s) < fast_index->cbData)\n\t\t\treturn FALSE;\n\n\t\tCopyMemory(fast_index->data, Stream_Pointer(s), fast_index->cbData);\n\t\tStream_Seek(s, fast_index->cbData);\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_fast_glyph_order(wStream* s, const ORDER_INFO* orderInfo,\n                                         FAST_GLYPH_ORDER* fastGlyph)\n{\n\tBYTE* phold;\n\tGLYPH_DATA_V2* glyph = &fastGlyph->glyphData;\n\tORDER_FIELD_BYTE(1, fastGlyph->cacheId);\n\tORDER_FIELD_2BYTE(2, fastGlyph->ulCharInc, fastGlyph->flAccel);\n\tORDER_FIELD_COLOR(orderInfo, s, 3, &fastGlyph->backColor);\n\tORDER_FIELD_COLOR(orderInfo, s, 4, &fastGlyph->foreColor);\n\tORDER_FIELD_COORD(5, fastGlyph->bkLeft);\n\tORDER_FIELD_COORD(6, fastGlyph->bkTop);\n\tORDER_FIELD_COORD(7, fastGlyph->bkRight);\n\tORDER_FIELD_COORD(8, fastGlyph->bkBottom);\n\tORDER_FIELD_COORD(9, fastGlyph->opLeft);\n\tORDER_FIELD_COORD(10, fastGlyph->opTop);\n\tORDER_FIELD_COORD(11, fastGlyph->opRight);\n\tORDER_FIELD_COORD(12, fastGlyph->opBottom);\n\tORDER_FIELD_COORD(13, fastGlyph->x);\n\tORDER_FIELD_COORD(14, fastGlyph->y);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_15)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, fastGlyph->cbData);\n\n\t\tif (Stream_GetRemainingLength(s) < fastGlyph->cbData)\n\t\t\treturn FALSE;\n\n\t\tCopyMemory(fastGlyph->data, Stream_Pointer(s), fastGlyph->cbData);\n\t\tphold = Stream_Pointer(s);\n\n\t\tif (!Stream_SafeSeek(s, 1))\n\t\t\treturn FALSE;\n\n\t\tif (fastGlyph->cbData > 1)\n\t\t{\n\t\t\tUINT32 new_cb;\n\t\t\t/* parse optional glyph data */\n\t\t\tglyph->cacheIndex = fastGlyph->data[0];\n\n\t\t\tif (!update_read_2byte_signed(s, &glyph->x) ||\n\t\t\t    !update_read_2byte_signed(s, &glyph->y) ||\n\t\t\t    !update_read_2byte_unsigned(s, &glyph->cx) ||\n\t\t\t    !update_read_2byte_unsigned(s, &glyph->cy))\n\t\t\t\treturn FALSE;\n\n\t\t\tglyph->cb = ((glyph->cx + 7) / 8) * glyph->cy;\n\t\t\tglyph->cb += ((glyph->cb % 4) > 0) ? 4 - (glyph->cb % 4) : 0;\n\t\t\tnew_cb = ((glyph->cx + 7) / 8) * glyph->cy;\n\t\t\tnew_cb += ((new_cb % 4) > 0) ? 4 - (new_cb % 4) : 0;\n\n\t\t\tif (Stream_GetRemainingLength(s) < new_cb)\n\t\t\t\treturn FALSE;\n\n\t\t\tif (new_cb)\n\t\t\t{\n\t\t\t\tBYTE* new_aj;\n\t\t\t\tnew_aj = (BYTE*)realloc(glyph->aj, new_cb);\n\n\t\t\t\tif (!new_aj)\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tglyph->aj = new_aj;\n\t\t\t\tglyph->cb = new_cb;\n\t\t\t\tStream_Read(s, glyph->aj, glyph->cb);\n\t\t\t}\n\t\t}\n\n\t\tStream_SetPointer(s, phold + fastGlyph->cbData);\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_polygon_sc_order(wStream* s, const ORDER_INFO* orderInfo,\n                                         POLYGON_SC_ORDER* polygon_sc)\n{\n\tUINT32 num = polygon_sc->numPoints;\n\tORDER_FIELD_COORD(1, polygon_sc->xStart);\n\tORDER_FIELD_COORD(2, polygon_sc->yStart);\n\tORDER_FIELD_BYTE(3, polygon_sc->bRop2);\n\tORDER_FIELD_BYTE(4, polygon_sc->fillMode);\n\tORDER_FIELD_COLOR(orderInfo, s, 5, &polygon_sc->brushColor);\n\tORDER_FIELD_BYTE(6, num);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_07)\n\t{\n\t\tDELTA_POINT* newpoints;\n\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, polygon_sc->cbData);\n\t\tnewpoints = (DELTA_POINT*)realloc(polygon_sc->points, sizeof(DELTA_POINT) * num);\n\n\t\tif (!newpoints)\n\t\t\treturn FALSE;\n\n\t\tpolygon_sc->points = newpoints;\n\t\tpolygon_sc->numPoints = num;\n\t\treturn update_read_delta_points(s, polygon_sc->points, polygon_sc->numPoints,\n\t\t                                polygon_sc->xStart, polygon_sc->yStart);\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_polygon_cb_order(wStream* s, const ORDER_INFO* orderInfo,\n                                         POLYGON_CB_ORDER* polygon_cb)\n{\n\tUINT32 num = polygon_cb->numPoints;\n\tORDER_FIELD_COORD(1, polygon_cb->xStart);\n\tORDER_FIELD_COORD(2, polygon_cb->yStart);\n\tORDER_FIELD_BYTE(3, polygon_cb->bRop2);\n\tORDER_FIELD_BYTE(4, polygon_cb->fillMode);\n\tORDER_FIELD_COLOR(orderInfo, s, 5, &polygon_cb->backColor);\n\tORDER_FIELD_COLOR(orderInfo, s, 6, &polygon_cb->foreColor);\n\n\tif (!update_read_brush(s, &polygon_cb->brush, orderInfo->fieldFlags >> 6))\n\t\treturn FALSE;\n\n\tORDER_FIELD_BYTE(12, num);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_13)\n\t{\n\t\tDELTA_POINT* newpoints;\n\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, polygon_cb->cbData);\n\t\tnewpoints = (DELTA_POINT*)realloc(polygon_cb->points, sizeof(DELTA_POINT) * num);\n\n\t\tif (!newpoints)\n\t\t\treturn FALSE;\n\n\t\tpolygon_cb->points = newpoints;\n\t\tpolygon_cb->numPoints = num;\n\n\t\tif (!update_read_delta_points(s, polygon_cb->points, polygon_cb->numPoints,\n\t\t                              polygon_cb->xStart, polygon_cb->yStart))\n\t\t\treturn FALSE;\n\t}\n\n\tpolygon_cb->backMode = (polygon_cb->bRop2 & 0x80) ? BACKMODE_TRANSPARENT : BACKMODE_OPAQUE;\n\tpolygon_cb->bRop2 = (polygon_cb->bRop2 & 0x1F);\n\treturn TRUE;\n}\nstatic BOOL update_read_ellipse_sc_order(wStream* s, const ORDER_INFO* orderInfo,\n                                         ELLIPSE_SC_ORDER* ellipse_sc)\n{\n\tORDER_FIELD_COORD(1, ellipse_sc->leftRect);\n\tORDER_FIELD_COORD(2, ellipse_sc->topRect);\n\tORDER_FIELD_COORD(3, ellipse_sc->rightRect);\n\tORDER_FIELD_COORD(4, ellipse_sc->bottomRect);\n\tORDER_FIELD_BYTE(5, ellipse_sc->bRop2);\n\tORDER_FIELD_BYTE(6, ellipse_sc->fillMode);\n\tORDER_FIELD_COLOR(orderInfo, s, 7, &ellipse_sc->color);\n\treturn TRUE;\n}\nstatic BOOL update_read_ellipse_cb_order(wStream* s, const ORDER_INFO* orderInfo,\n                                         ELLIPSE_CB_ORDER* ellipse_cb)\n{\n\tORDER_FIELD_COORD(1, ellipse_cb->leftRect);\n\tORDER_FIELD_COORD(2, ellipse_cb->topRect);\n\tORDER_FIELD_COORD(3, ellipse_cb->rightRect);\n\tORDER_FIELD_COORD(4, ellipse_cb->bottomRect);\n\tORDER_FIELD_BYTE(5, ellipse_cb->bRop2);\n\tORDER_FIELD_BYTE(6, ellipse_cb->fillMode);\n\tORDER_FIELD_COLOR(orderInfo, s, 7, &ellipse_cb->backColor);\n\tORDER_FIELD_COLOR(orderInfo, s, 8, &ellipse_cb->foreColor);\n\treturn update_read_brush(s, &ellipse_cb->brush, orderInfo->fieldFlags >> 8);\n}\n/* Secondary Drawing Orders */\nstatic CACHE_BITMAP_ORDER* update_read_cache_bitmap_order(rdpUpdate* update, wStream* s,\n                                                          BOOL compressed, UINT16 flags)\n{\n\tCACHE_BITMAP_ORDER* cache_bitmap;\n\n\tif (!update || !s)\n\t\treturn NULL;\n\n\tcache_bitmap = calloc(1, sizeof(CACHE_BITMAP_ORDER));\n\n\tif (!cache_bitmap)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 9)\n\t\tgoto fail;\n\n\tStream_Read_UINT8(s, cache_bitmap->cacheId);      /* cacheId (1 byte) */\n\tStream_Seek_UINT8(s);                             /* pad1Octet (1 byte) */\n\tStream_Read_UINT8(s, cache_bitmap->bitmapWidth);  /* bitmapWidth (1 byte) */\n\tStream_Read_UINT8(s, cache_bitmap->bitmapHeight); /* bitmapHeight (1 byte) */\n\tStream_Read_UINT8(s, cache_bitmap->bitmapBpp);    /* bitmapBpp (1 byte) */\n\n\tif ((cache_bitmap->bitmapBpp < 1) || (cache_bitmap->bitmapBpp > 32))\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"invalid bitmap bpp %\" PRIu32 \"\",\n\t\t           cache_bitmap->bitmapBpp);\n\t\tgoto fail;\n\t}\n\n\tStream_Read_UINT16(s, cache_bitmap->bitmapLength); /* bitmapLength (2 bytes) */\n\tStream_Read_UINT16(s, cache_bitmap->cacheIndex);   /* cacheIndex (2 bytes) */\n\n\tif (compressed)\n\t{\n\t\tif ((flags & NO_BITMAP_COMPRESSION_HDR) == 0)\n\t\t{\n\t\t\tBYTE* bitmapComprHdr = (BYTE*)&(cache_bitmap->bitmapComprHdr);\n\n\t\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\t\tgoto fail;\n\n\t\t\tStream_Read(s, bitmapComprHdr, 8); /* bitmapComprHdr (8 bytes) */\n\t\t\tcache_bitmap->bitmapLength -= 8;\n\t\t}\n\t}\n\n\tif (Stream_GetRemainingLength(s) < cache_bitmap->bitmapLength)\n\t\tgoto fail;\n\n\tcache_bitmap->bitmapDataStream = malloc(cache_bitmap->bitmapLength);\n\n\tif (!cache_bitmap->bitmapDataStream)\n\t\tgoto fail;\n\n\tStream_Read(s, cache_bitmap->bitmapDataStream, cache_bitmap->bitmapLength);\n\tcache_bitmap->compressed = compressed;\n\treturn cache_bitmap;\nfail:\n\tfree_cache_bitmap_order(update->context, cache_bitmap);\n\treturn NULL;\n}\nint update_approximate_cache_bitmap_order(const CACHE_BITMAP_ORDER* cache_bitmap, BOOL compressed,\n                                          UINT16* flags)\n{\n\treturn 64 + cache_bitmap->bitmapLength;\n}\nBOOL update_write_cache_bitmap_order(wStream* s, const CACHE_BITMAP_ORDER* cache_bitmap,\n                                     BOOL compressed, UINT16* flags)\n{\n\tUINT32 bitmapLength = cache_bitmap->bitmapLength;\n\tint inf = update_approximate_cache_bitmap_order(cache_bitmap, compressed, flags);\n\n\tif (!Stream_EnsureRemainingCapacity(s, inf))\n\t\treturn FALSE;\n\n\t*flags = NO_BITMAP_COMPRESSION_HDR;\n\n\tif ((*flags & NO_BITMAP_COMPRESSION_HDR) == 0)\n\t\tbitmapLength += 8;\n\n\tStream_Write_UINT8(s, cache_bitmap->cacheId);      /* cacheId (1 byte) */\n\tStream_Write_UINT8(s, 0);                          /* pad1Octet (1 byte) */\n\tStream_Write_UINT8(s, cache_bitmap->bitmapWidth);  /* bitmapWidth (1 byte) */\n\tStream_Write_UINT8(s, cache_bitmap->bitmapHeight); /* bitmapHeight (1 byte) */\n\tStream_Write_UINT8(s, cache_bitmap->bitmapBpp);    /* bitmapBpp (1 byte) */\n\tStream_Write_UINT16(s, bitmapLength);              /* bitmapLength (2 bytes) */\n\tStream_Write_UINT16(s, cache_bitmap->cacheIndex);  /* cacheIndex (2 bytes) */\n\n\tif (compressed)\n\t{\n\t\tif ((*flags & NO_BITMAP_COMPRESSION_HDR) == 0)\n\t\t{\n\t\t\tBYTE* bitmapComprHdr = (BYTE*)&(cache_bitmap->bitmapComprHdr);\n\t\t\tStream_Write(s, bitmapComprHdr, 8); /* bitmapComprHdr (8 bytes) */\n\t\t\tbitmapLength -= 8;\n\t\t}\n\n\t\tStream_Write(s, cache_bitmap->bitmapDataStream, bitmapLength);\n\t}\n\telse\n\t{\n\t\tStream_Write(s, cache_bitmap->bitmapDataStream, bitmapLength);\n\t}\n\n\treturn TRUE;\n}\nstatic CACHE_BITMAP_V2_ORDER* update_read_cache_bitmap_v2_order(rdpUpdate* update, wStream* s,\n                                                                BOOL compressed, UINT16 flags)\n{\n\tBYTE bitsPerPixelId;\n\tCACHE_BITMAP_V2_ORDER* cache_bitmap_v2;\n\n\tif (!update || !s)\n\t\treturn NULL;\n\n\tcache_bitmap_v2 = calloc(1, sizeof(CACHE_BITMAP_V2_ORDER));\n\n\tif (!cache_bitmap_v2)\n\t\tgoto fail;\n\n\tcache_bitmap_v2->cacheId = flags & 0x0003;\n\tcache_bitmap_v2->flags = (flags & 0xFF80) >> 7;\n\tbitsPerPixelId = (flags & 0x0078) >> 3;\n\tcache_bitmap_v2->bitmapBpp = CBR2_BPP[bitsPerPixelId];\n\n\tif (cache_bitmap_v2->flags & CBR2_PERSISTENT_KEY_PRESENT)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\tgoto fail;\n\n\t\tStream_Read_UINT32(s, cache_bitmap_v2->key1); /* key1 (4 bytes) */\n\t\tStream_Read_UINT32(s, cache_bitmap_v2->key2); /* key2 (4 bytes) */\n\t}\n\n\tif (cache_bitmap_v2->flags & CBR2_HEIGHT_SAME_AS_WIDTH)\n\t{\n\t\tif (!update_read_2byte_unsigned(s, &cache_bitmap_v2->bitmapWidth)) /* bitmapWidth */\n\t\t\tgoto fail;\n\n\t\tcache_bitmap_v2->bitmapHeight = cache_bitmap_v2->bitmapWidth;\n\t}\n\telse\n\t{\n\t\tif (!update_read_2byte_unsigned(s, &cache_bitmap_v2->bitmapWidth) || /* bitmapWidth */\n\t\t    !update_read_2byte_unsigned(s, &cache_bitmap_v2->bitmapHeight))  /* bitmapHeight */\n\t\t\tgoto fail;\n\t}\n\n\tif (!update_read_4byte_unsigned(s, &cache_bitmap_v2->bitmapLength) || /* bitmapLength */\n\t    !update_read_2byte_unsigned(s, &cache_bitmap_v2->cacheIndex))     /* cacheIndex */\n\t\tgoto fail;\n\n\tif (cache_bitmap_v2->flags & CBR2_DO_NOT_CACHE)\n\t\tcache_bitmap_v2->cacheIndex = BITMAP_CACHE_WAITING_LIST_INDEX;\n\n\tif (compressed)\n\t{\n\t\tif (!(cache_bitmap_v2->flags & CBR2_NO_BITMAP_COMPRESSION_HDR))\n\t\t{\n\t\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\t\tgoto fail;\n\n\t\t\tStream_Read_UINT16(\n\t\t\t    s, cache_bitmap_v2->cbCompFirstRowSize); /* cbCompFirstRowSize (2 bytes) */\n\t\t\tStream_Read_UINT16(\n\t\t\t    s, cache_bitmap_v2->cbCompMainBodySize);         /* cbCompMainBodySize (2 bytes) */\n\t\t\tStream_Read_UINT16(s, cache_bitmap_v2->cbScanWidth); /* cbScanWidth (2 bytes) */\n\t\t\tStream_Read_UINT16(\n\t\t\t    s, cache_bitmap_v2->cbUncompressedSize); /* cbUncompressedSize (2 bytes) */\n\t\t\tcache_bitmap_v2->bitmapLength = cache_bitmap_v2->cbCompMainBodySize;\n\t\t}\n\t}\n\n\tif (Stream_GetRemainingLength(s) < cache_bitmap_v2->bitmapLength)\n\t\tgoto fail;\n\n\tif (cache_bitmap_v2->bitmapLength == 0)\n\t\tgoto fail;\n\n\tcache_bitmap_v2->bitmapDataStream = malloc(cache_bitmap_v2->bitmapLength);\n\n\tif (!cache_bitmap_v2->bitmapDataStream)\n\t\tgoto fail;\n\n\tStream_Read(s, cache_bitmap_v2->bitmapDataStream, cache_bitmap_v2->bitmapLength);\n\tcache_bitmap_v2->compressed = compressed;\n\treturn cache_bitmap_v2;\nfail:\n\tfree_cache_bitmap_v2_order(update->context, cache_bitmap_v2);\n\treturn NULL;\n}\nint update_approximate_cache_bitmap_v2_order(CACHE_BITMAP_V2_ORDER* cache_bitmap_v2,\n                                             BOOL compressed, UINT16* flags)\n{\n\treturn 64 + cache_bitmap_v2->bitmapLength;\n}\nBOOL update_write_cache_bitmap_v2_order(wStream* s, CACHE_BITMAP_V2_ORDER* cache_bitmap_v2,\n                                        BOOL compressed, UINT16* flags)\n{\n\tBYTE bitsPerPixelId;\n\n\tif (!Stream_EnsureRemainingCapacity(\n\t        s, update_approximate_cache_bitmap_v2_order(cache_bitmap_v2, compressed, flags)))\n\t\treturn FALSE;\n\n\tbitsPerPixelId = BPP_CBR2[cache_bitmap_v2->bitmapBpp];\n\t*flags = (cache_bitmap_v2->cacheId & 0x0003) | (bitsPerPixelId << 3) |\n\t         ((cache_bitmap_v2->flags << 7) & 0xFF80);\n\n\tif (cache_bitmap_v2->flags & CBR2_PERSISTENT_KEY_PRESENT)\n\t{\n\t\tStream_Write_UINT32(s, cache_bitmap_v2->key1); /* key1 (4 bytes) */\n\t\tStream_Write_UINT32(s, cache_bitmap_v2->key2); /* key2 (4 bytes) */\n\t}\n\n\tif (cache_bitmap_v2->flags & CBR2_HEIGHT_SAME_AS_WIDTH)\n\t{\n\t\tif (!update_write_2byte_unsigned(s, cache_bitmap_v2->bitmapWidth)) /* bitmapWidth */\n\t\t\treturn FALSE;\n\t}\n\telse\n\t{\n\t\tif (!update_write_2byte_unsigned(s, cache_bitmap_v2->bitmapWidth) || /* bitmapWidth */\n\t\t    !update_write_2byte_unsigned(s, cache_bitmap_v2->bitmapHeight))  /* bitmapHeight */\n\t\t\treturn FALSE;\n\t}\n\n\tif (cache_bitmap_v2->flags & CBR2_DO_NOT_CACHE)\n\t\tcache_bitmap_v2->cacheIndex = BITMAP_CACHE_WAITING_LIST_INDEX;\n\n\tif (!update_write_4byte_unsigned(s, cache_bitmap_v2->bitmapLength) || /* bitmapLength */\n\t    !update_write_2byte_unsigned(s, cache_bitmap_v2->cacheIndex))     /* cacheIndex */\n\t\treturn FALSE;\n\n\tif (compressed)\n\t{\n\t\tif (!(cache_bitmap_v2->flags & CBR2_NO_BITMAP_COMPRESSION_HDR))\n\t\t{\n\t\t\tStream_Write_UINT16(\n\t\t\t    s, cache_bitmap_v2->cbCompFirstRowSize); /* cbCompFirstRowSize (2 bytes) */\n\t\t\tStream_Write_UINT16(\n\t\t\t    s, cache_bitmap_v2->cbCompMainBodySize);          /* cbCompMainBodySize (2 bytes) */\n\t\t\tStream_Write_UINT16(s, cache_bitmap_v2->cbScanWidth); /* cbScanWidth (2 bytes) */\n\t\t\tStream_Write_UINT16(\n\t\t\t    s, cache_bitmap_v2->cbUncompressedSize); /* cbUncompressedSize (2 bytes) */\n\t\t\tcache_bitmap_v2->bitmapLength = cache_bitmap_v2->cbCompMainBodySize;\n\t\t}\n\n\t\tif (!Stream_EnsureRemainingCapacity(s, cache_bitmap_v2->bitmapLength))\n\t\t\treturn FALSE;\n\n\t\tStream_Write(s, cache_bitmap_v2->bitmapDataStream, cache_bitmap_v2->bitmapLength);\n\t}\n\telse\n\t{\n\t\tif (!Stream_EnsureRemainingCapacity(s, cache_bitmap_v2->bitmapLength))\n\t\t\treturn FALSE;\n\n\t\tStream_Write(s, cache_bitmap_v2->bitmapDataStream, cache_bitmap_v2->bitmapLength);\n\t}\n\n\tcache_bitmap_v2->compressed = compressed;\n\treturn TRUE;\n}\nstatic CACHE_BITMAP_V3_ORDER* update_read_cache_bitmap_v3_order(rdpUpdate* update, wStream* s,\n                                                                UINT16 flags)\n{\n\tBYTE bitsPerPixelId;\n\tBITMAP_DATA_EX* bitmapData;\n\tUINT32 new_len;\n\tBYTE* new_data;\n\tCACHE_BITMAP_V3_ORDER* cache_bitmap_v3;\n\n\tif (!update || !s)\n\t\treturn NULL;\n\n\tcache_bitmap_v3 = calloc(1, sizeof(CACHE_BITMAP_V3_ORDER));\n\n\tif (!cache_bitmap_v3)\n\t\tgoto fail;\n\n\tcache_bitmap_v3->cacheId = flags & 0x00000003;\n\tcache_bitmap_v3->flags = (flags & 0x0000FF80) >> 7;\n\tbitsPerPixelId = (flags & 0x00000078) >> 3;\n\tcache_bitmap_v3->bpp = CBR23_BPP[bitsPerPixelId];\n\n\tif (Stream_GetRemainingLength(s) < 21)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, cache_bitmap_v3->cacheIndex); /* cacheIndex (2 bytes) */\n\tStream_Read_UINT32(s, cache_bitmap_v3->key1);       /* key1 (4 bytes) */\n\tStream_Read_UINT32(s, cache_bitmap_v3->key2);       /* key2 (4 bytes) */\n\tbitmapData = &cache_bitmap_v3->bitmapData;\n\tStream_Read_UINT8(s, bitmapData->bpp);\n\n\tif ((bitmapData->bpp < 1) || (bitmapData->bpp > 32))\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"invalid bpp value %\" PRIu32 \"\", bitmapData->bpp);\n\t\tgoto fail;\n\t}\n\n\tStream_Seek_UINT8(s);                      /* reserved1 (1 byte) */\n\tStream_Seek_UINT8(s);                      /* reserved2 (1 byte) */\n\tStream_Read_UINT8(s, bitmapData->codecID); /* codecID (1 byte) */\n\tStream_Read_UINT16(s, bitmapData->width);  /* width (2 bytes) */\n\tStream_Read_UINT16(s, bitmapData->height); /* height (2 bytes) */\n\tStream_Read_UINT32(s, new_len);            /* length (4 bytes) */\n\n\tif (Stream_GetRemainingLength(s) < new_len)\n\t\tgoto fail;\n\n\tnew_data = (BYTE*)realloc(bitmapData->data, new_len);\n\n\tif (!new_data)\n\t\tgoto fail;\n\n\tbitmapData->data = new_data;\n\tbitmapData->length = new_len;\n\tStream_Read(s, bitmapData->data, bitmapData->length);\n\treturn cache_bitmap_v3;\nfail:\n\tfree_cache_bitmap_v3_order(update->context, cache_bitmap_v3);\n\treturn NULL;\n}\nint update_approximate_cache_bitmap_v3_order(CACHE_BITMAP_V3_ORDER* cache_bitmap_v3, UINT16* flags)\n{\n\tBITMAP_DATA_EX* bitmapData = &cache_bitmap_v3->bitmapData;\n\treturn 64 + bitmapData->length;\n}\nBOOL update_write_cache_bitmap_v3_order(wStream* s, CACHE_BITMAP_V3_ORDER* cache_bitmap_v3,\n                                        UINT16* flags)\n{\n\tBYTE bitsPerPixelId;\n\tBITMAP_DATA_EX* bitmapData;\n\n\tif (!Stream_EnsureRemainingCapacity(\n\t        s, update_approximate_cache_bitmap_v3_order(cache_bitmap_v3, flags)))\n\t\treturn FALSE;\n\n\tbitmapData = &cache_bitmap_v3->bitmapData;\n\tbitsPerPixelId = BPP_CBR23[cache_bitmap_v3->bpp];\n\t*flags = (cache_bitmap_v3->cacheId & 0x00000003) |\n\t         ((cache_bitmap_v3->flags << 7) & 0x0000FF80) | ((bitsPerPixelId << 3) & 0x00000078);\n\tStream_Write_UINT16(s, cache_bitmap_v3->cacheIndex); /* cacheIndex (2 bytes) */\n\tStream_Write_UINT32(s, cache_bitmap_v3->key1);       /* key1 (4 bytes) */\n\tStream_Write_UINT32(s, cache_bitmap_v3->key2);       /* key2 (4 bytes) */\n\tStream_Write_UINT8(s, bitmapData->bpp);\n\tStream_Write_UINT8(s, 0);                   /* reserved1 (1 byte) */\n\tStream_Write_UINT8(s, 0);                   /* reserved2 (1 byte) */\n\tStream_Write_UINT8(s, bitmapData->codecID); /* codecID (1 byte) */\n\tStream_Write_UINT16(s, bitmapData->width);  /* width (2 bytes) */\n\tStream_Write_UINT16(s, bitmapData->height); /* height (2 bytes) */\n\tStream_Write_UINT32(s, bitmapData->length); /* length (4 bytes) */\n\tStream_Write(s, bitmapData->data, bitmapData->length);\n\treturn TRUE;\n}\nstatic CACHE_COLOR_TABLE_ORDER* update_read_cache_color_table_order(rdpUpdate* update, wStream* s,\n                                                                    UINT16 flags)\n{\n\tint i;\n\tUINT32* colorTable;\n\tCACHE_COLOR_TABLE_ORDER* cache_color_table = calloc(1, sizeof(CACHE_COLOR_TABLE_ORDER));\n\n\tif (!cache_color_table)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 3)\n\t\tgoto fail;\n\n\tStream_Read_UINT8(s, cache_color_table->cacheIndex);    /* cacheIndex (1 byte) */\n\tStream_Read_UINT16(s, cache_color_table->numberColors); /* numberColors (2 bytes) */\n\n\tif (cache_color_table->numberColors != 256)\n\t{\n\t\t/* This field MUST be set to 256 */\n\t\tgoto fail;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < cache_color_table->numberColors * 4)\n\t\tgoto fail;\n\n\tcolorTable = (UINT32*)&cache_color_table->colorTable;\n\n\tfor (i = 0; i < (int)cache_color_table->numberColors; i++)\n\t\tupdate_read_color_quad(s, &colorTable[i]);\n\n\treturn cache_color_table;\nfail:\n\tfree_cache_color_table_order(update->context, cache_color_table);\n\treturn NULL;\n}\nint update_approximate_cache_color_table_order(const CACHE_COLOR_TABLE_ORDER* cache_color_table,\n                                               UINT16* flags)\n{\n\treturn 16 + (256 * 4);\n}\nBOOL update_write_cache_color_table_order(wStream* s,\n                                          const CACHE_COLOR_TABLE_ORDER* cache_color_table,\n                                          UINT16* flags)\n{\n\tint i, inf;\n\tUINT32* colorTable;\n\n\tif (cache_color_table->numberColors != 256)\n\t\treturn FALSE;\n\n\tinf = update_approximate_cache_color_table_order(cache_color_table, flags);\n\n\tif (!Stream_EnsureRemainingCapacity(s, inf))\n\t\treturn FALSE;\n\n\tStream_Write_UINT8(s, cache_color_table->cacheIndex);    /* cacheIndex (1 byte) */\n\tStream_Write_UINT16(s, cache_color_table->numberColors); /* numberColors (2 bytes) */\n\tcolorTable = (UINT32*)&cache_color_table->colorTable;\n\n\tfor (i = 0; i < (int)cache_color_table->numberColors; i++)\n\t{\n\t\tupdate_write_color_quad(s, colorTable[i]);\n\t}\n\n\treturn TRUE;\n}\nstatic CACHE_GLYPH_ORDER* update_read_cache_glyph_order(rdpUpdate* update, wStream* s, UINT16 flags)\n{\n\tUINT32 i;\n\tCACHE_GLYPH_ORDER* cache_glyph_order = calloc(1, sizeof(CACHE_GLYPH_ORDER));\n\n\tif (!cache_glyph_order || !update || !s)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\tgoto fail;\n\n\tStream_Read_UINT8(s, cache_glyph_order->cacheId); /* cacheId (1 byte) */\n\tStream_Read_UINT8(s, cache_glyph_order->cGlyphs); /* cGlyphs (1 byte) */\n\n\tfor (i = 0; i < cache_glyph_order->cGlyphs; i++)\n\t{\n\t\tGLYPH_DATA* glyph = &cache_glyph_order->glyphData[i];\n\n\t\tif (Stream_GetRemainingLength(s) < 10)\n\t\t\tgoto fail;\n\n\t\tStream_Read_UINT16(s, glyph->cacheIndex);\n\t\tStream_Read_INT16(s, glyph->x);\n\t\tStream_Read_INT16(s, glyph->y);\n\t\tStream_Read_UINT16(s, glyph->cx);\n\t\tStream_Read_UINT16(s, glyph->cy);\n\t\tglyph->cb = ((glyph->cx + 7) / 8) * glyph->cy;\n\t\tglyph->cb += ((glyph->cb % 4) > 0) ? 4 - (glyph->cb % 4) : 0;\n\n\t\tif (Stream_GetRemainingLength(s) < glyph->cb)\n\t\t\tgoto fail;\n\n\t\tglyph->aj = (BYTE*)malloc(glyph->cb);\n\n\t\tif (!glyph->aj)\n\t\t\tgoto fail;\n\n\t\tStream_Read(s, glyph->aj, glyph->cb);\n\t}\n\n\tif ((flags & CG_GLYPH_UNICODE_PRESENT) && (cache_glyph_order->cGlyphs > 0))\n\t{\n\t\tcache_glyph_order->unicodeCharacters = calloc(cache_glyph_order->cGlyphs, sizeof(WCHAR));\n\n\t\tif (!cache_glyph_order->unicodeCharacters)\n\t\t\tgoto fail;\n\n\t\tif (Stream_GetRemainingLength(s) < sizeof(WCHAR) * cache_glyph_order->cGlyphs)\n\t\t\tgoto fail;\n\n\t\tStream_Read_UTF16_String(s, cache_glyph_order->unicodeCharacters,\n\t\t                         cache_glyph_order->cGlyphs);\n\t}\n\n\treturn cache_glyph_order;\nfail:\n\tfree_cache_glyph_order(update->context, cache_glyph_order);\n\treturn NULL;\n}\nint update_approximate_cache_glyph_order(const CACHE_GLYPH_ORDER* cache_glyph, UINT16* flags)\n{\n\treturn 2 + cache_glyph->cGlyphs * 32;\n}\nBOOL update_write_cache_glyph_order(wStream* s, const CACHE_GLYPH_ORDER* cache_glyph, UINT16* flags)\n{\n\tint i, inf;\n\tINT16 lsi16;\n\tconst GLYPH_DATA* glyph;\n\tinf = update_approximate_cache_glyph_order(cache_glyph, flags);\n\n\tif (!Stream_EnsureRemainingCapacity(s, inf))\n\t\treturn FALSE;\n\n\tStream_Write_UINT8(s, cache_glyph->cacheId); /* cacheId (1 byte) */\n\tStream_Write_UINT8(s, cache_glyph->cGlyphs); /* cGlyphs (1 byte) */\n\n\tfor (i = 0; i < (int)cache_glyph->cGlyphs; i++)\n\t{\n\t\tUINT32 cb;\n\t\tglyph = &cache_glyph->glyphData[i];\n\t\tStream_Write_UINT16(s, glyph->cacheIndex); /* cacheIndex (2 bytes) */\n\t\tlsi16 = glyph->x;\n\t\tStream_Write_UINT16(s, lsi16); /* x (2 bytes) */\n\t\tlsi16 = glyph->y;\n\t\tStream_Write_UINT16(s, lsi16);     /* y (2 bytes) */\n\t\tStream_Write_UINT16(s, glyph->cx); /* cx (2 bytes) */\n\t\tStream_Write_UINT16(s, glyph->cy); /* cy (2 bytes) */\n\t\tcb = ((glyph->cx + 7) / 8) * glyph->cy;\n\t\tcb += ((cb % 4) > 0) ? 4 - (cb % 4) : 0;\n\t\tStream_Write(s, glyph->aj, cb);\n\t}\n\n\tif (*flags & CG_GLYPH_UNICODE_PRESENT)\n\t{\n\t\tStream_Zero(s, cache_glyph->cGlyphs * 2);\n\t}\n\n\treturn TRUE;\n}\nstatic CACHE_GLYPH_V2_ORDER* update_read_cache_glyph_v2_order(rdpUpdate* update, wStream* s,\n                                                              UINT16 flags)\n{\n\tUINT32 i;\n\tCACHE_GLYPH_V2_ORDER* cache_glyph_v2 = calloc(1, sizeof(CACHE_GLYPH_V2_ORDER));\n\n\tif (!cache_glyph_v2)\n\t\tgoto fail;\n\n\tcache_glyph_v2->cacheId = (flags & 0x000F);\n\tcache_glyph_v2->flags = (flags & 0x00F0) >> 4;\n\tcache_glyph_v2->cGlyphs = (flags & 0xFF00) >> 8;\n\n\tfor (i = 0; i < cache_glyph_v2->cGlyphs; i++)\n\t{\n\t\tGLYPH_DATA_V2* glyph = &cache_glyph_v2->glyphData[i];\n\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\tgoto fail;\n\n\t\tStream_Read_UINT8(s, glyph->cacheIndex);\n\n\t\tif (!update_read_2byte_signed(s, &glyph->x) || !update_read_2byte_signed(s, &glyph->y) ||\n\t\t    !update_read_2byte_unsigned(s, &glyph->cx) ||\n\t\t    !update_read_2byte_unsigned(s, &glyph->cy))\n\t\t{\n\t\t\tgoto fail;\n\t\t}\n\n\t\tglyph->cb = ((glyph->cx + 7) / 8) * glyph->cy;\n\t\tglyph->cb += ((glyph->cb % 4) > 0) ? 4 - (glyph->cb % 4) : 0;\n\n\t\tif (Stream_GetRemainingLength(s) < glyph->cb)\n\t\t\tgoto fail;\n\n\t\tglyph->aj = (BYTE*)malloc(glyph->cb);\n\n\t\tif (!glyph->aj)\n\t\t\tgoto fail;\n\n\t\tStream_Read(s, glyph->aj, glyph->cb);\n\t}\n\n\tif ((flags & CG_GLYPH_UNICODE_PRESENT) && (cache_glyph_v2->cGlyphs > 0))\n\t{\n\t\tcache_glyph_v2->unicodeCharacters = calloc(cache_glyph_v2->cGlyphs, sizeof(WCHAR));\n\n\t\tif (!cache_glyph_v2->unicodeCharacters)\n\t\t\tgoto fail;\n\n\t\tif (Stream_GetRemainingLength(s) < sizeof(WCHAR) * cache_glyph_v2->cGlyphs)\n\t\t\tgoto fail;\n\n\t\tStream_Read_UTF16_String(s, cache_glyph_v2->unicodeCharacters, cache_glyph_v2->cGlyphs);\n\t}\n\n\treturn cache_glyph_v2;\nfail:\n\tfree_cache_glyph_v2_order(update->context, cache_glyph_v2);\n\treturn NULL;\n}\nint update_approximate_cache_glyph_v2_order(const CACHE_GLYPH_V2_ORDER* cache_glyph_v2,\n                                            UINT16* flags)\n{\n\treturn 8 + cache_glyph_v2->cGlyphs * 32;\n}\nBOOL update_write_cache_glyph_v2_order(wStream* s, const CACHE_GLYPH_V2_ORDER* cache_glyph_v2,\n                                       UINT16* flags)\n{\n\tUINT32 i, inf;\n\tinf = update_approximate_cache_glyph_v2_order(cache_glyph_v2, flags);\n\n\tif (!Stream_EnsureRemainingCapacity(s, inf))\n\t\treturn FALSE;\n\n\t*flags = (cache_glyph_v2->cacheId & 0x000F) | ((cache_glyph_v2->flags & 0x000F) << 4) |\n\t         ((cache_glyph_v2->cGlyphs & 0x00FF) << 8);\n\n\tfor (i = 0; i < cache_glyph_v2->cGlyphs; i++)\n\t{\n\t\tUINT32 cb;\n\t\tconst GLYPH_DATA_V2* glyph = &cache_glyph_v2->glyphData[i];\n\t\tStream_Write_UINT8(s, glyph->cacheIndex);\n\n\t\tif (!update_write_2byte_signed(s, glyph->x) || !update_write_2byte_signed(s, glyph->y) ||\n\t\t    !update_write_2byte_unsigned(s, glyph->cx) ||\n\t\t    !update_write_2byte_unsigned(s, glyph->cy))\n\t\t{\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tcb = ((glyph->cx + 7) / 8) * glyph->cy;\n\t\tcb += ((cb % 4) > 0) ? 4 - (cb % 4) : 0;\n\t\tStream_Write(s, glyph->aj, cb);\n\t}\n\n\tif (*flags & CG_GLYPH_UNICODE_PRESENT)\n\t{\n\t\tStream_Zero(s, cache_glyph_v2->cGlyphs * 2);\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_decompress_brush(wStream* s, BYTE* output, BYTE bpp)\n{\n\tint index;\n\tint x, y, k;\n\tBYTE byte = 0;\n\tBYTE* palette;\n\tint bytesPerPixel;\n\tpalette = Stream_Pointer(s) + 16;\n\tbytesPerPixel = ((bpp + 1) / 8);\n\n\tif (Stream_GetRemainingLength(s) < 16) // 64 / 4\n\t\treturn FALSE;\n\n\tfor (y = 7; y >= 0; y--)\n\t{\n\t\tfor (x = 0; x < 8; x++)\n\t\t{\n\t\t\tif ((x % 4) == 0)\n\t\t\t\tStream_Read_UINT8(s, byte);\n\n\t\t\tindex = ((byte >> ((3 - (x % 4)) * 2)) & 0x03);\n\n\t\t\tfor (k = 0; k < bytesPerPixel; k++)\n\t\t\t{\n\t\t\t\toutput[((y * 8 + x) * bytesPerPixel) + k] = palette[(index * bytesPerPixel) + k];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_compress_brush(wStream* s, const BYTE* input, BYTE bpp)\n{\n\treturn FALSE;\n}\nstatic CACHE_BRUSH_ORDER* update_read_cache_brush_order(rdpUpdate* update, wStream* s, UINT16 flags)\n{\n\tint i;\n\tBYTE iBitmapFormat;\n\tBOOL compressed = FALSE;\n\tCACHE_BRUSH_ORDER* cache_brush = calloc(1, sizeof(CACHE_BRUSH_ORDER));\n\n\tif (!cache_brush)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 6)\n\t\tgoto fail;\n\n\tStream_Read_UINT8(s, cache_brush->index); /* cacheEntry (1 byte) */\n\tStream_Read_UINT8(s, iBitmapFormat);      /* iBitmapFormat (1 byte) */\n\n\tif (iBitmapFormat > ARRAYSIZE(BMF_BPP))\n\t\tgoto fail;\n\n\tcache_brush->bpp = BMF_BPP[iBitmapFormat];\n\tStream_Read_UINT8(s, cache_brush->cx);     /* cx (1 byte) */\n\tStream_Read_UINT8(s, cache_brush->cy);     /* cy (1 byte) */\n\tStream_Read_UINT8(s, cache_brush->style);  /* style (1 byte) */\n\tStream_Read_UINT8(s, cache_brush->length); /* iBytes (1 byte) */\n\n\tif ((cache_brush->cx == 8) && (cache_brush->cy == 8))\n\t{\n\t\tif (cache_brush->bpp == 1)\n\t\t{\n\t\t\tif (cache_brush->length != 8)\n\t\t\t{\n\t\t\t\tWLog_Print(update->log, WLOG_ERROR, \"incompatible 1bpp brush of length:%\" PRIu32 \"\",\n\t\t\t\t           cache_brush->length);\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\t/* rows are encoded in reverse order */\n\t\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\t\tgoto fail;\n\n\t\t\tfor (i = 7; i >= 0; i--)\n\t\t\t{\n\t\t\t\tStream_Read_UINT8(s, cache_brush->data[i]);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ((iBitmapFormat == BMF_8BPP) && (cache_brush->length == 20))\n\t\t\t\tcompressed = TRUE;\n\t\t\telse if ((iBitmapFormat == BMF_16BPP) && (cache_brush->length == 24))\n\t\t\t\tcompressed = TRUE;\n\t\t\telse if ((iBitmapFormat == BMF_32BPP) && (cache_brush->length == 32))\n\t\t\t\tcompressed = TRUE;\n\n\t\t\tif (compressed != FALSE)\n\t\t\t{\n\t\t\t\t/* compressed brush */\n\t\t\t\tif (!update_decompress_brush(s, cache_brush->data, cache_brush->bpp))\n\t\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* uncompressed brush */\n\t\t\t\tUINT32 scanline = (cache_brush->bpp / 8) * 8;\n\n\t\t\t\tif (Stream_GetRemainingLength(s) < scanline * 8)\n\t\t\t\t\tgoto fail;\n\n\t\t\t\tfor (i = 7; i >= 0; i--)\n\t\t\t\t{\n\t\t\t\t\tStream_Read(s, &cache_brush->data[i * scanline], scanline);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cache_brush;\nfail:\n\tfree_cache_brush_order(update->context, cache_brush);\n\treturn NULL;\n}\nint update_approximate_cache_brush_order(const CACHE_BRUSH_ORDER* cache_brush, UINT16* flags)\n{\n\treturn 64;\n}\nBOOL update_write_cache_brush_order(wStream* s, const CACHE_BRUSH_ORDER* cache_brush, UINT16* flags)\n{\n\tint i;\n\tBYTE iBitmapFormat;\n\tBOOL compressed = FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s,\n\t                                    update_approximate_cache_brush_order(cache_brush, flags)))\n\t\treturn FALSE;\n\n\tiBitmapFormat = BPP_BMF[cache_brush->bpp];\n\tStream_Write_UINT8(s, cache_brush->index);  /* cacheEntry (1 byte) */\n\tStream_Write_UINT8(s, iBitmapFormat);       /* iBitmapFormat (1 byte) */\n\tStream_Write_UINT8(s, cache_brush->cx);     /* cx (1 byte) */\n\tStream_Write_UINT8(s, cache_brush->cy);     /* cy (1 byte) */\n\tStream_Write_UINT8(s, cache_brush->style);  /* style (1 byte) */\n\tStream_Write_UINT8(s, cache_brush->length); /* iBytes (1 byte) */\n\n\tif ((cache_brush->cx == 8) && (cache_brush->cy == 8))\n\t{\n\t\tif (cache_brush->bpp == 1)\n\t\t{\n\t\t\tif (cache_brush->length != 8)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"incompatible 1bpp brush of length:%\" PRIu32 \"\", cache_brush->length);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tfor (i = 7; i >= 0; i--)\n\t\t\t{\n\t\t\t\tStream_Write_UINT8(s, cache_brush->data[i]);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ((iBitmapFormat == BMF_8BPP) && (cache_brush->length == 20))\n\t\t\t\tcompressed = TRUE;\n\t\t\telse if ((iBitmapFormat == BMF_16BPP) && (cache_brush->length == 24))\n\t\t\t\tcompressed = TRUE;\n\t\t\telse if ((iBitmapFormat == BMF_32BPP) && (cache_brush->length == 32))\n\t\t\t\tcompressed = TRUE;\n\n\t\t\tif (compressed != FALSE)\n\t\t\t{\n\t\t\t\t/* compressed brush */\n\t\t\t\tif (!update_compress_brush(s, cache_brush->data, cache_brush->bpp))\n\t\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* uncompressed brush */\n\t\t\t\tint scanline = (cache_brush->bpp / 8) * 8;\n\n\t\t\t\tfor (i = 7; i >= 0; i--)\n\t\t\t\t{\n\t\t\t\t\tStream_Write(s, &cache_brush->data[i * scanline], scanline);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n/* Alternate Secondary Drawing Orders */\nstatic BOOL\nupdate_read_create_offscreen_bitmap_order(wStream* s,\n                                          CREATE_OFFSCREEN_BITMAP_ORDER* create_offscreen_bitmap)\n{\n\tUINT16 flags;\n\tBOOL deleteListPresent;\n\tOFFSCREEN_DELETE_LIST* deleteList;\n\n\tif (Stream_GetRemainingLength(s) < 6)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, flags); /* flags (2 bytes) */\n\tcreate_offscreen_bitmap->id = flags & 0x7FFF;\n\tdeleteListPresent = (flags & 0x8000) ? TRUE : FALSE;\n\tStream_Read_UINT16(s, create_offscreen_bitmap->cx); /* cx (2 bytes) */\n\tStream_Read_UINT16(s, create_offscreen_bitmap->cy); /* cy (2 bytes) */\n\tdeleteList = &(create_offscreen_bitmap->deleteList);\n\n\tif (deleteListPresent)\n\t{\n\t\tUINT32 i;\n\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, deleteList->cIndices);\n\n\t\tif (deleteList->cIndices > deleteList->sIndices)\n\t\t{\n\t\t\tUINT16* new_indices;\n\t\t\tnew_indices = (UINT16*)realloc(deleteList->indices, deleteList->cIndices * 2);\n\n\t\t\tif (!new_indices)\n\t\t\t\treturn FALSE;\n\n\t\t\tdeleteList->sIndices = deleteList->cIndices;\n\t\t\tdeleteList->indices = new_indices;\n\t\t}\n\n\t\tif (Stream_GetRemainingLength(s) < 2 * deleteList->cIndices)\n\t\t\treturn FALSE;\n\n\t\tfor (i = 0; i < deleteList->cIndices; i++)\n\t\t{\n\t\t\tStream_Read_UINT16(s, deleteList->indices[i]);\n\t\t}\n\t}\n\telse\n\t{\n\t\tdeleteList->cIndices = 0;\n\t}\n\n\treturn TRUE;\n}\nint update_approximate_create_offscreen_bitmap_order(\n    const CREATE_OFFSCREEN_BITMAP_ORDER* create_offscreen_bitmap)\n{\n\tconst OFFSCREEN_DELETE_LIST* deleteList = &(create_offscreen_bitmap->deleteList);\n\treturn 32 + deleteList->cIndices * 2;\n}\nBOOL update_write_create_offscreen_bitmap_order(\n    wStream* s, const CREATE_OFFSCREEN_BITMAP_ORDER* create_offscreen_bitmap)\n{\n\tUINT16 flags;\n\tBOOL deleteListPresent;\n\tconst OFFSCREEN_DELETE_LIST* deleteList;\n\n\tif (!Stream_EnsureRemainingCapacity(\n\t        s, update_approximate_create_offscreen_bitmap_order(create_offscreen_bitmap)))\n\t\treturn FALSE;\n\n\tdeleteList = &(create_offscreen_bitmap->deleteList);\n\tflags = create_offscreen_bitmap->id & 0x7FFF;\n\tdeleteListPresent = (deleteList->cIndices > 0) ? TRUE : FALSE;\n\n\tif (deleteListPresent)\n\t\tflags |= 0x8000;\n\n\tStream_Write_UINT16(s, flags);                       /* flags (2 bytes) */\n\tStream_Write_UINT16(s, create_offscreen_bitmap->cx); /* cx (2 bytes) */\n\tStream_Write_UINT16(s, create_offscreen_bitmap->cy); /* cy (2 bytes) */\n\n\tif (deleteListPresent)\n\t{\n\t\tint i;\n\t\tStream_Write_UINT16(s, deleteList->cIndices);\n\n\t\tfor (i = 0; i < (int)deleteList->cIndices; i++)\n\t\t{\n\t\t\tStream_Write_UINT16(s, deleteList->indices[i]);\n\t\t}\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_switch_surface_order(wStream* s, SWITCH_SURFACE_ORDER* switch_surface)\n{\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, switch_surface->bitmapId); /* bitmapId (2 bytes) */\n\treturn TRUE;\n}\nint update_approximate_switch_surface_order(const SWITCH_SURFACE_ORDER* switch_surface)\n{\n\treturn 2;\n}\nBOOL update_write_switch_surface_order(wStream* s, const SWITCH_SURFACE_ORDER* switch_surface)\n{\n\tint inf = update_approximate_switch_surface_order(switch_surface);\n\n\tif (!Stream_EnsureRemainingCapacity(s, inf))\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, switch_surface->bitmapId); /* bitmapId (2 bytes) */\n\treturn TRUE;\n}\nstatic BOOL\nupdate_read_create_nine_grid_bitmap_order(wStream* s,\n                                          CREATE_NINE_GRID_BITMAP_ORDER* create_nine_grid_bitmap)\n{\n\tNINE_GRID_BITMAP_INFO* nineGridInfo;\n\n\tif (Stream_GetRemainingLength(s) < 19)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, create_nine_grid_bitmap->bitmapBpp); /* bitmapBpp (1 byte) */\n\n\tif ((create_nine_grid_bitmap->bitmapBpp < 1) || (create_nine_grid_bitmap->bitmapBpp > 32))\n\t{\n\t\tWLog_ERR(TAG, \"invalid bpp value %\" PRIu32 \"\", create_nine_grid_bitmap->bitmapBpp);\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, create_nine_grid_bitmap->bitmapId); /* bitmapId (2 bytes) */\n\tnineGridInfo = &(create_nine_grid_bitmap->nineGridInfo);\n\tStream_Read_UINT32(s, nineGridInfo->flFlags);          /* flFlags (4 bytes) */\n\tStream_Read_UINT16(s, nineGridInfo->ulLeftWidth);      /* ulLeftWidth (2 bytes) */\n\tStream_Read_UINT16(s, nineGridInfo->ulRightWidth);     /* ulRightWidth (2 bytes) */\n\tStream_Read_UINT16(s, nineGridInfo->ulTopHeight);      /* ulTopHeight (2 bytes) */\n\tStream_Read_UINT16(s, nineGridInfo->ulBottomHeight);   /* ulBottomHeight (2 bytes) */\n\tupdate_read_colorref(s, &nineGridInfo->crTransparent); /* crTransparent (4 bytes) */\n\treturn TRUE;\n}\nstatic BOOL update_read_frame_marker_order(wStream* s, FRAME_MARKER_ORDER* frame_marker)\n{\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, frame_marker->action); /* action (4 bytes) */\n\treturn TRUE;\n}\nstatic BOOL update_read_stream_bitmap_first_order(wStream* s,\n                                                  STREAM_BITMAP_FIRST_ORDER* stream_bitmap_first)\n{\n\tif (Stream_GetRemainingLength(s) < 10) // 8 + 2 at least\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, stream_bitmap_first->bitmapFlags); /* bitmapFlags (1 byte) */\n\tStream_Read_UINT8(s, stream_bitmap_first->bitmapBpp);   /* bitmapBpp (1 byte) */\n\n\tif ((stream_bitmap_first->bitmapBpp < 1) || (stream_bitmap_first->bitmapBpp > 32))\n\t{\n\t\tWLog_ERR(TAG, \"invalid bpp value %\" PRIu32 \"\", stream_bitmap_first->bitmapBpp);\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, stream_bitmap_first->bitmapType);   /* bitmapType (2 bytes) */\n\tStream_Read_UINT16(s, stream_bitmap_first->bitmapWidth);  /* bitmapWidth (2 bytes) */\n\tStream_Read_UINT16(s, stream_bitmap_first->bitmapHeight); /* bitmapHeigth (2 bytes) */\n\n\tif (stream_bitmap_first->bitmapFlags & STREAM_BITMAP_V2)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 4)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT32(s, stream_bitmap_first->bitmapSize); /* bitmapSize (4 bytes) */\n\t}\n\telse\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, stream_bitmap_first->bitmapSize); /* bitmapSize (2 bytes) */\n\t}\n\n\tFIELD_SKIP_BUFFER16(\n\t    s, stream_bitmap_first->bitmapBlockSize); /* bitmapBlockSize(2 bytes) + bitmapBlock */\n\treturn TRUE;\n}\nstatic BOOL update_read_stream_bitmap_next_order(wStream* s,\n                                                 STREAM_BITMAP_NEXT_ORDER* stream_bitmap_next)\n{\n\tif (Stream_GetRemainingLength(s) < 5)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, stream_bitmap_next->bitmapFlags); /* bitmapFlags (1 byte) */\n\tStream_Read_UINT16(s, stream_bitmap_next->bitmapType); /* bitmapType (2 bytes) */\n\tFIELD_SKIP_BUFFER16(\n\t    s, stream_bitmap_next->bitmapBlockSize); /* bitmapBlockSize(2 bytes) + bitmapBlock */\n\treturn TRUE;\n}\nstatic BOOL update_read_draw_gdiplus_first_order(wStream* s,\n                                                 DRAW_GDIPLUS_FIRST_ORDER* draw_gdiplus_first)\n{\n\tif (Stream_GetRemainingLength(s) < 11)\n\t\treturn FALSE;\n\n\tStream_Seek_UINT8(s);                                      /* pad1Octet (1 byte) */\n\tStream_Read_UINT16(s, draw_gdiplus_first->cbSize);         /* cbSize (2 bytes) */\n\tStream_Read_UINT32(s, draw_gdiplus_first->cbTotalSize);    /* cbTotalSize (4 bytes) */\n\tStream_Read_UINT32(s, draw_gdiplus_first->cbTotalEmfSize); /* cbTotalEmfSize (4 bytes) */\n\treturn Stream_SafeSeek(s, draw_gdiplus_first->cbSize);     /* emfRecords */\n}\nstatic BOOL update_read_draw_gdiplus_next_order(wStream* s,\n                                                DRAW_GDIPLUS_NEXT_ORDER* draw_gdiplus_next)\n{\n\tif (Stream_GetRemainingLength(s) < 3)\n\t\treturn FALSE;\n\n\tStream_Seek_UINT8(s);                              /* pad1Octet (1 byte) */\n\tFIELD_SKIP_BUFFER16(s, draw_gdiplus_next->cbSize); /* cbSize(2 bytes) + emfRecords */\n\treturn TRUE;\n}\nstatic BOOL update_read_draw_gdiplus_end_order(wStream* s, DRAW_GDIPLUS_END_ORDER* draw_gdiplus_end)\n{\n\tif (Stream_GetRemainingLength(s) < 11)\n\t\treturn FALSE;\n\n\tStream_Seek_UINT8(s);                                    /* pad1Octet (1 byte) */\n\tStream_Read_UINT16(s, draw_gdiplus_end->cbSize);         /* cbSize (2 bytes) */\n\tStream_Read_UINT32(s, draw_gdiplus_end->cbTotalSize);    /* cbTotalSize (4 bytes) */\n\tStream_Read_UINT32(s, draw_gdiplus_end->cbTotalEmfSize); /* cbTotalEmfSize (4 bytes) */\n\treturn Stream_SafeSeek(s, draw_gdiplus_end->cbSize);     /* emfRecords */\n}\nstatic BOOL\nupdate_read_draw_gdiplus_cache_first_order(wStream* s,\n                                           DRAW_GDIPLUS_CACHE_FIRST_ORDER* draw_gdiplus_cache_first)\n{\n\tif (Stream_GetRemainingLength(s) < 11)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, draw_gdiplus_cache_first->flags);        /* flags (1 byte) */\n\tStream_Read_UINT16(s, draw_gdiplus_cache_first->cacheType);   /* cacheType (2 bytes) */\n\tStream_Read_UINT16(s, draw_gdiplus_cache_first->cacheIndex);  /* cacheIndex (2 bytes) */\n\tStream_Read_UINT16(s, draw_gdiplus_cache_first->cbSize);      /* cbSize (2 bytes) */\n\tStream_Read_UINT32(s, draw_gdiplus_cache_first->cbTotalSize); /* cbTotalSize (4 bytes) */\n\treturn Stream_SafeSeek(s, draw_gdiplus_cache_first->cbSize);  /* emfRecords */\n}\nstatic BOOL\nupdate_read_draw_gdiplus_cache_next_order(wStream* s,\n                                          DRAW_GDIPLUS_CACHE_NEXT_ORDER* draw_gdiplus_cache_next)\n{\n\tif (Stream_GetRemainingLength(s) < 7)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, draw_gdiplus_cache_next->flags);       /* flags (1 byte) */\n\tStream_Read_UINT16(s, draw_gdiplus_cache_next->cacheType);  /* cacheType (2 bytes) */\n\tStream_Read_UINT16(s, draw_gdiplus_cache_next->cacheIndex); /* cacheIndex (2 bytes) */\n\tFIELD_SKIP_BUFFER16(s, draw_gdiplus_cache_next->cbSize);    /* cbSize(2 bytes) + emfRecords */\n\treturn TRUE;\n}\nstatic BOOL\nupdate_read_draw_gdiplus_cache_end_order(wStream* s,\n                                         DRAW_GDIPLUS_CACHE_END_ORDER* draw_gdiplus_cache_end)\n{\n\tif (Stream_GetRemainingLength(s) < 11)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, draw_gdiplus_cache_end->flags);        /* flags (1 byte) */\n\tStream_Read_UINT16(s, draw_gdiplus_cache_end->cacheType);   /* cacheType (2 bytes) */\n\tStream_Read_UINT16(s, draw_gdiplus_cache_end->cacheIndex);  /* cacheIndex (2 bytes) */\n\tStream_Read_UINT16(s, draw_gdiplus_cache_end->cbSize);      /* cbSize (2 bytes) */\n\tStream_Read_UINT32(s, draw_gdiplus_cache_end->cbTotalSize); /* cbTotalSize (4 bytes) */\n\treturn Stream_SafeSeek(s, draw_gdiplus_cache_end->cbSize);  /* emfRecords */\n}\nstatic BOOL update_read_field_flags(wStream* s, UINT32* fieldFlags, BYTE flags, BYTE fieldBytes)\n{\n\tint i;\n\tBYTE byte;\n\n\tif (flags & ORDER_ZERO_FIELD_BYTE_BIT0)\n\t\tfieldBytes--;\n\n\tif (flags & ORDER_ZERO_FIELD_BYTE_BIT1)\n\t{\n\t\tif (fieldBytes > 1)\n\t\t\tfieldBytes -= 2;\n\t\telse\n\t\t\tfieldBytes = 0;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < fieldBytes)\n\t\treturn FALSE;\n\n\t*fieldFlags = 0;\n\n\tfor (i = 0; i < fieldBytes; i++)\n\t{\n\t\tStream_Read_UINT8(s, byte);\n\t\t*fieldFlags |= byte << (i * 8);\n\t}\n\n\treturn TRUE;\n}\nBOOL update_write_field_flags(wStream* s, UINT32 fieldFlags, BYTE flags, BYTE fieldBytes)\n{\n\tBYTE byte;\n\n\tif (fieldBytes == 1)\n\t{\n\t\tbyte = fieldFlags & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\telse if (fieldBytes == 2)\n\t{\n\t\tbyte = fieldFlags & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t\tbyte = (fieldFlags >> 8) & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\telse if (fieldBytes == 3)\n\t{\n\t\tbyte = fieldFlags & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t\tbyte = (fieldFlags >> 8) & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t\tbyte = (fieldFlags >> 16) & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\telse\n\t{\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_bounds(wStream* s, rdpBounds* bounds)\n{\n\tBYTE flags;\n\n\tif (Stream_GetRemainingLength(s) < 1)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, flags); /* field flags */\n\n\tif (flags & BOUND_LEFT)\n\t{\n\t\tif (!update_read_coord(s, &bounds->left, FALSE))\n\t\t\treturn FALSE;\n\t}\n\telse if (flags & BOUND_DELTA_LEFT)\n\t{\n\t\tif (!update_read_coord(s, &bounds->left, TRUE))\n\t\t\treturn FALSE;\n\t}\n\n\tif (flags & BOUND_TOP)\n\t{\n\t\tif (!update_read_coord(s, &bounds->top, FALSE))\n\t\t\treturn FALSE;\n\t}\n\telse if (flags & BOUND_DELTA_TOP)\n\t{\n\t\tif (!update_read_coord(s, &bounds->top, TRUE))\n\t\t\treturn FALSE;\n\t}\n\n\tif (flags & BOUND_RIGHT)\n\t{\n\t\tif (!update_read_coord(s, &bounds->right, FALSE))\n\t\t\treturn FALSE;\n\t}\n\telse if (flags & BOUND_DELTA_RIGHT)\n\t{\n\t\tif (!update_read_coord(s, &bounds->right, TRUE))\n\t\t\treturn FALSE;\n\t}\n\n\tif (flags & BOUND_BOTTOM)\n\t{\n\t\tif (!update_read_coord(s, &bounds->bottom, FALSE))\n\t\t\treturn FALSE;\n\t}\n\telse if (flags & BOUND_DELTA_BOTTOM)\n\t{\n\t\tif (!update_read_coord(s, &bounds->bottom, TRUE))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\nBOOL update_write_bounds(wStream* s, ORDER_INFO* orderInfo)\n{\n\tif (!(orderInfo->controlFlags & ORDER_BOUNDS))\n\t\treturn TRUE;\n\n\tif (orderInfo->controlFlags & ORDER_ZERO_BOUNDS_DELTAS)\n\t\treturn TRUE;\n\n\tStream_Write_UINT8(s, orderInfo->boundsFlags); /* field flags */\n\n\tif (orderInfo->boundsFlags & BOUND_LEFT)\n\t{\n\t\tif (!update_write_coord(s, orderInfo->bounds.left))\n\t\t\treturn FALSE;\n\t}\n\telse if (orderInfo->boundsFlags & BOUND_DELTA_LEFT)\n\t{\n\t}\n\n\tif (orderInfo->boundsFlags & BOUND_TOP)\n\t{\n\t\tif (!update_write_coord(s, orderInfo->bounds.top))\n\t\t\treturn FALSE;\n\t}\n\telse if (orderInfo->boundsFlags & BOUND_DELTA_TOP)\n\t{\n\t}\n\n\tif (orderInfo->boundsFlags & BOUND_RIGHT)\n\t{\n\t\tif (!update_write_coord(s, orderInfo->bounds.right))\n\t\t\treturn FALSE;\n\t}\n\telse if (orderInfo->boundsFlags & BOUND_DELTA_RIGHT)\n\t{\n\t}\n\n\tif (orderInfo->boundsFlags & BOUND_BOTTOM)\n\t{\n\t\tif (!update_write_coord(s, orderInfo->bounds.bottom))\n\t\t\treturn FALSE;\n\t}\n\telse if (orderInfo->boundsFlags & BOUND_DELTA_BOTTOM)\n\t{\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL read_primary_order(wLog* log, const char* orderName, wStream* s,\n                               const ORDER_INFO* orderInfo, rdpPrimaryUpdate* primary)\n{\n\tBOOL rc = FALSE;\n\n\tif (!s || !orderInfo || !primary || !orderName)\n\t\treturn FALSE;\n\n\tswitch (orderInfo->orderType)\n\t{\n\t\tcase ORDER_TYPE_DSTBLT:\n\t\t\trc = update_read_dstblt_order(s, orderInfo, &(primary->dstblt));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_PATBLT:\n\t\t\trc = update_read_patblt_order(s, orderInfo, &(primary->patblt));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_SCRBLT:\n\t\t\trc = update_read_scrblt_order(s, orderInfo, &(primary->scrblt));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_OPAQUE_RECT:\n\t\t\trc = update_read_opaque_rect_order(s, orderInfo, &(primary->opaque_rect));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_DRAW_NINE_GRID:\n\t\t\trc = update_read_draw_nine_grid_order(s, orderInfo, &(primary->draw_nine_grid));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_DSTBLT:\n\t\t\trc = update_read_multi_dstblt_order(s, orderInfo, &(primary->multi_dstblt));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_PATBLT:\n\t\t\trc = update_read_multi_patblt_order(s, orderInfo, &(primary->multi_patblt));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_SCRBLT:\n\t\t\trc = update_read_multi_scrblt_order(s, orderInfo, &(primary->multi_scrblt));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_OPAQUE_RECT:\n\t\t\trc = update_read_multi_opaque_rect_order(s, orderInfo, &(primary->multi_opaque_rect));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_DRAW_NINE_GRID:\n\t\t\trc = update_read_multi_draw_nine_grid_order(s, orderInfo,\n\t\t\t                                            &(primary->multi_draw_nine_grid));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_LINE_TO:\n\t\t\trc = update_read_line_to_order(s, orderInfo, &(primary->line_to));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYLINE:\n\t\t\trc = update_read_polyline_order(s, orderInfo, &(primary->polyline));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MEMBLT:\n\t\t\trc = update_read_memblt_order(s, orderInfo, &(primary->memblt));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MEM3BLT:\n\t\t\trc = update_read_mem3blt_order(s, orderInfo, &(primary->mem3blt));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_SAVE_BITMAP:\n\t\t\trc = update_read_save_bitmap_order(s, orderInfo, &(primary->save_bitmap));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GLYPH_INDEX:\n\t\t\trc = update_read_glyph_index_order(s, orderInfo, &(primary->glyph_index));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_FAST_INDEX:\n\t\t\trc = update_read_fast_index_order(s, orderInfo, &(primary->fast_index));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_FAST_GLYPH:\n\t\t\trc = update_read_fast_glyph_order(s, orderInfo, &(primary->fast_glyph));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYGON_SC:\n\t\t\trc = update_read_polygon_sc_order(s, orderInfo, &(primary->polygon_sc));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYGON_CB:\n\t\t\trc = update_read_polygon_cb_order(s, orderInfo, &(primary->polygon_cb));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_ELLIPSE_SC:\n\t\t\trc = update_read_ellipse_sc_order(s, orderInfo, &(primary->ellipse_sc));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_ELLIPSE_CB:\n\t\t\trc = update_read_ellipse_cb_order(s, orderInfo, &(primary->ellipse_cb));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(log, WLOG_WARN, \"Primary Drawing Order %s not supported, ignoring\",\n\t\t\t           orderName);\n\t\t\trc = TRUE;\n\t\t\tbreak;\n\t}\n\n\tif (!rc)\n\t{\n\t\tWLog_Print(log, WLOG_ERROR, \"%s - update_read_dstblt_order() failed\", orderName);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL update_recv_primary_order(rdpUpdate* update, wStream* s, BYTE flags)\n{\n\tBOOL rc = FALSE;\n\trdpContext* context = update->context;\n\trdpPrimaryUpdate* primary = update->primary;\n\tORDER_INFO* orderInfo = &(primary->order_info);\n\trdpSettings* settings = context->settings;\n\tconst char* orderName;\n\n\tif (flags & ORDER_TYPE_CHANGE)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_ERROR, \"Stream_GetRemainingLength(s) < 1\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tStream_Read_UINT8(s, orderInfo->orderType); /* orderType (1 byte) */\n\t}\n\n\torderName = primary_order_string(orderInfo->orderType);\n\n\tif (!check_primary_order_supported(update->log, settings, orderInfo->orderType, orderName))\n\t\treturn FALSE;\n\n\tif (!update_read_field_flags(s, &(orderInfo->fieldFlags), flags,\n\t                             PRIMARY_DRAWING_ORDER_FIELD_BYTES[orderInfo->orderType]))\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"update_read_field_flags() failed\");\n\t\treturn FALSE;\n\t}\n\n\tif (flags & ORDER_BOUNDS)\n\t{\n\t\tif (!(flags & ORDER_ZERO_BOUNDS_DELTAS))\n\t\t{\n\t\t\tif (!update_read_bounds(s, &orderInfo->bounds))\n\t\t\t{\n\t\t\t\tWLog_Print(update->log, WLOG_ERROR, \"update_read_bounds() failed\");\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\n\t\trc = IFCALLRESULT(FALSE, update->SetBounds, context, &orderInfo->bounds);\n\n\t\tif (!rc)\n\t\t\treturn FALSE;\n\t}\n\n\torderInfo->deltaCoordinates = (flags & ORDER_DELTA_COORDINATES) ? TRUE : FALSE;\n\n\tif (!read_primary_order(update->log, orderName, s, orderInfo, primary))\n\t\treturn FALSE;\n\n\tswitch (orderInfo->orderType)\n\t{\n\t\tcase ORDER_TYPE_DSTBLT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s rop=%s [0x%08\" PRIx32 \"]\",\n\t\t\t           orderName, gdi_rop3_code_string(primary->dstblt.bRop),\n\t\t\t           gdi_rop3_code(primary->dstblt.bRop));\n\t\t\trc = IFCALLRESULT(FALSE, primary->DstBlt, context, &primary->dstblt);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_PATBLT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s rop=%s [0x%08\" PRIx32 \"]\",\n\t\t\t           orderName, gdi_rop3_code_string(primary->patblt.bRop),\n\t\t\t           gdi_rop3_code(primary->patblt.bRop));\n\t\t\trc = IFCALLRESULT(FALSE, primary->PatBlt, context, &primary->patblt);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_SCRBLT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s rop=%s [0x%08\" PRIx32 \"]\",\n\t\t\t           orderName, gdi_rop3_code_string(primary->scrblt.bRop),\n\t\t\t           gdi_rop3_code(primary->scrblt.bRop));\n\t\t\trc = IFCALLRESULT(FALSE, primary->ScrBlt, context, &primary->scrblt);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_OPAQUE_RECT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->OpaqueRect, context, &primary->opaque_rect);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_DRAW_NINE_GRID:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->DrawNineGrid, context, &primary->draw_nine_grid);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_DSTBLT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s rop=%s [0x%08\" PRIx32 \"]\",\n\t\t\t           orderName, gdi_rop3_code_string(primary->multi_dstblt.bRop),\n\t\t\t           gdi_rop3_code(primary->multi_dstblt.bRop));\n\t\t\trc = IFCALLRESULT(FALSE, primary->MultiDstBlt, context, &primary->multi_dstblt);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_PATBLT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s rop=%s [0x%08\" PRIx32 \"]\",\n\t\t\t           orderName, gdi_rop3_code_string(primary->multi_patblt.bRop),\n\t\t\t           gdi_rop3_code(primary->multi_patblt.bRop));\n\t\t\trc = IFCALLRESULT(FALSE, primary->MultiPatBlt, context, &primary->multi_patblt);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_SCRBLT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s rop=%s [0x%08\" PRIx32 \"]\",\n\t\t\t           orderName, gdi_rop3_code_string(primary->multi_scrblt.bRop),\n\t\t\t           gdi_rop3_code(primary->multi_scrblt.bRop));\n\t\t\trc = IFCALLRESULT(FALSE, primary->MultiScrBlt, context, &primary->multi_scrblt);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_OPAQUE_RECT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc =\n\t\t\t    IFCALLRESULT(FALSE, primary->MultiOpaqueRect, context, &primary->multi_opaque_rect);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_DRAW_NINE_GRID:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->MultiDrawNineGrid, context,\n\t\t\t                  &primary->multi_draw_nine_grid);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_LINE_TO:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->LineTo, context, &primary->line_to);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYLINE:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->Polyline, context, &primary->polyline);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_MEMBLT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s rop=%s [0x%08\" PRIx32 \"]\",\n\t\t\t           orderName, gdi_rop3_code_string(primary->memblt.bRop),\n\t\t\t           gdi_rop3_code(primary->memblt.bRop));\n\t\t\trc = IFCALLRESULT(FALSE, primary->MemBlt, context, &primary->memblt);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_MEM3BLT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s rop=%s [0x%08\" PRIx32 \"]\",\n\t\t\t           orderName, gdi_rop3_code_string(primary->mem3blt.bRop),\n\t\t\t           gdi_rop3_code(primary->mem3blt.bRop));\n\t\t\trc = IFCALLRESULT(FALSE, primary->Mem3Blt, context, &primary->mem3blt);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_SAVE_BITMAP:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->SaveBitmap, context, &primary->save_bitmap);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_GLYPH_INDEX:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->GlyphIndex, context, &primary->glyph_index);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_FAST_INDEX:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->FastIndex, context, &primary->fast_index);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_FAST_GLYPH:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->FastGlyph, context, &primary->fast_glyph);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYGON_SC:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->PolygonSC, context, &primary->polygon_sc);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYGON_CB:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->PolygonCB, context, &primary->polygon_cb);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_ELLIPSE_SC:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->EllipseSC, context, &primary->ellipse_sc);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_ELLIPSE_CB:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->EllipseCB, context, &primary->ellipse_cb);\n\t\t}\n\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(update->log, WLOG_WARN, \"Primary Drawing Order %s not supported\", orderName);\n\t\t\tbreak;\n\t}\n\n\tif (!rc)\n\t{\n\t\tWLog_Print(update->log, WLOG_WARN, \"Primary Drawing Order %s failed\", orderName);\n\t\treturn FALSE;\n\t}\n\n\tif (flags & ORDER_BOUNDS)\n\t{\n\t\trc = IFCALLRESULT(FALSE, update->SetBounds, context, NULL);\n\t}\n\n\treturn rc;\n}\n\nstatic BOOL update_recv_secondary_order(rdpUpdate* update, wStream* s, BYTE flags)\n{\n\tBOOL rc = FALSE;\n\tBYTE* next;\n\tBYTE orderType;\n\tUINT16 extraFlags;\n\tUINT16 orderLength;\n\trdpContext* context = update->context;\n\trdpSettings* settings = context->settings;\n\trdpSecondaryUpdate* secondary = update->secondary;\n\tconst char* name;\n\n\tif (Stream_GetRemainingLength(s) < 5)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"Stream_GetRemainingLength(s) < 5\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, orderLength); /* orderLength (2 bytes) */\n\tStream_Read_UINT16(s, extraFlags);  /* extraFlags (2 bytes) */\n\tStream_Read_UINT8(s, orderType);    /* orderType (1 byte) */\n\tnext = Stream_Pointer(s) + ((INT16)orderLength) + 7;\n\tname = secondary_order_string(orderType);\n\tWLog_Print(update->log, WLOG_DEBUG, \"Secondary Drawing Order %s\", name);\n\n\tif (!check_secondary_order_supported(update->log, settings, orderType, name))\n\t\treturn FALSE;\n\n\tswitch (orderType)\n\t{\n\t\tcase ORDER_TYPE_BITMAP_UNCOMPRESSED:\n\t\tcase ORDER_TYPE_CACHE_BITMAP_COMPRESSED:\n\t\t{\n\t\t\tconst BOOL compressed = (orderType == ORDER_TYPE_CACHE_BITMAP_COMPRESSED);\n\t\t\tCACHE_BITMAP_ORDER* order =\n\t\t\t    update_read_cache_bitmap_order(update, s, compressed, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBitmap, context, order);\n\t\t\t\tfree_cache_bitmap_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_BITMAP_UNCOMPRESSED_V2:\n\t\tcase ORDER_TYPE_BITMAP_COMPRESSED_V2:\n\t\t{\n\t\t\tconst BOOL compressed = (orderType == ORDER_TYPE_BITMAP_COMPRESSED_V2);\n\t\t\tCACHE_BITMAP_V2_ORDER* order =\n\t\t\t    update_read_cache_bitmap_v2_order(update, s, compressed, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBitmapV2, context, order);\n\t\t\t\tfree_cache_bitmap_v2_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_BITMAP_COMPRESSED_V3:\n\t\t{\n\t\t\tCACHE_BITMAP_V3_ORDER* order = update_read_cache_bitmap_v3_order(update, s, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBitmapV3, context, order);\n\t\t\t\tfree_cache_bitmap_v3_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_COLOR_TABLE:\n\t\t{\n\t\t\tCACHE_COLOR_TABLE_ORDER* order =\n\t\t\t    update_read_cache_color_table_order(update, s, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheColorTable, context, order);\n\t\t\t\tfree_cache_color_table_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_GLYPH:\n\t\t{\n\t\t\tswitch (settings->GlyphSupportLevel)\n\t\t\t{\n\t\t\t\tcase GLYPH_SUPPORT_PARTIAL:\n\t\t\t\tcase GLYPH_SUPPORT_FULL:\n\t\t\t\t{\n\t\t\t\t\tCACHE_GLYPH_ORDER* order = update_read_cache_glyph_order(update, s, extraFlags);\n\n\t\t\t\t\tif (order)\n\t\t\t\t\t{\n\t\t\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheGlyph, context, order);\n\t\t\t\t\t\tfree_cache_glyph_order(context, order);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\tcase GLYPH_SUPPORT_ENCODE:\n\t\t\t\t{\n\t\t\t\t\tCACHE_GLYPH_V2_ORDER* order =\n\t\t\t\t\t    update_read_cache_glyph_v2_order(update, s, extraFlags);\n\n\t\t\t\t\tif (order)\n\t\t\t\t\t{\n\t\t\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheGlyphV2, context, order);\n\t\t\t\t\t\tfree_cache_glyph_v2_order(context, order);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\tcase GLYPH_SUPPORT_NONE:\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_BRUSH:\n\t\t\t/* [MS-RDPEGDI] 2.2.2.2.1.2.7 Cache Brush (CACHE_BRUSH_ORDER) */\n\t\t\t{\n\t\t\t\tCACHE_BRUSH_ORDER* order = update_read_cache_brush_order(update, s, extraFlags);\n\n\t\t\t\tif (order)\n\t\t\t\t{\n\t\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBrush, context, order);\n\t\t\t\t\tfree_cache_brush_order(context, order);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(update->log, WLOG_WARN, \"SECONDARY ORDER %s not supported\", name);\n\t\t\tbreak;\n\t}\n\n\tif (!rc)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"SECONDARY ORDER %s failed\", name);\n\t}\n\n\tStream_SetPointer(s, next);\n\treturn rc;\n}\n\nstatic BOOL read_altsec_order(wStream* s, BYTE orderType, rdpAltSecUpdate* altsec)\n{\n\tBOOL rc = FALSE;\n\n\tswitch (orderType)\n\t{\n\t\tcase ORDER_TYPE_CREATE_OFFSCREEN_BITMAP:\n\t\t\trc = update_read_create_offscreen_bitmap_order(s, &(altsec->create_offscreen_bitmap));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_SWITCH_SURFACE:\n\t\t\trc = update_read_switch_surface_order(s, &(altsec->switch_surface));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_CREATE_NINE_GRID_BITMAP:\n\t\t\trc = update_read_create_nine_grid_bitmap_order(s, &(altsec->create_nine_grid_bitmap));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_FRAME_MARKER:\n\t\t\trc = update_read_frame_marker_order(s, &(altsec->frame_marker));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_STREAM_BITMAP_FIRST:\n\t\t\trc = update_read_stream_bitmap_first_order(s, &(altsec->stream_bitmap_first));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_STREAM_BITMAP_NEXT:\n\t\t\trc = update_read_stream_bitmap_next_order(s, &(altsec->stream_bitmap_next));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_FIRST:\n\t\t\trc = update_read_draw_gdiplus_first_order(s, &(altsec->draw_gdiplus_first));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_NEXT:\n\t\t\trc = update_read_draw_gdiplus_next_order(s, &(altsec->draw_gdiplus_next));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_END:\n\t\t\trc = update_read_draw_gdiplus_end_order(s, &(altsec->draw_gdiplus_end));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_FIRST:\n\t\t\trc = update_read_draw_gdiplus_cache_first_order(s, &(altsec->draw_gdiplus_cache_first));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_NEXT:\n\t\t\trc = update_read_draw_gdiplus_cache_next_order(s, &(altsec->draw_gdiplus_cache_next));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_END:\n\t\t\trc = update_read_draw_gdiplus_cache_end_order(s, &(altsec->draw_gdiplus_cache_end));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_WINDOW:\n\t\t\t/* This order is handled elsewhere. */\n\t\t\trc = TRUE;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_COMPDESK_FIRST:\n\t\t\trc = TRUE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic BOOL update_recv_altsec_order(rdpUpdate* update, wStream* s, BYTE flags)\n{\n\tBYTE orderType = flags >>= 2; /* orderType is in higher 6 bits of flags field */\n\tBOOL rc = FALSE;\n\trdpContext* context = update->context;\n\trdpSettings* settings = context->settings;\n\trdpAltSecUpdate* altsec = update->altsec;\n\tconst char* orderName = altsec_order_string(orderType);\n\tWLog_Print(update->log, WLOG_DEBUG, \"Alternate Secondary Drawing Order %s\", orderName);\n\n\tif (!check_alt_order_supported(update->log, settings, orderType, orderName))\n\t\treturn FALSE;\n\n\tif (!read_altsec_order(s, orderType, altsec))\n\t\treturn FALSE;\n\n\tswitch (orderType)\n\t{\n\t\tcase ORDER_TYPE_CREATE_OFFSCREEN_BITMAP:\n\t\t\tIFCALLRET(altsec->CreateOffscreenBitmap, rc, context,\n\t\t\t          &(altsec->create_offscreen_bitmap));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_SWITCH_SURFACE:\n\t\t\tIFCALLRET(altsec->SwitchSurface, rc, context, &(altsec->switch_surface));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_CREATE_NINE_GRID_BITMAP:\n\t\t\tIFCALLRET(altsec->CreateNineGridBitmap, rc, context,\n\t\t\t          &(altsec->create_nine_grid_bitmap));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_FRAME_MARKER:\n\t\t\tIFCALLRET(altsec->FrameMarker, rc, context, &(altsec->frame_marker));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_STREAM_BITMAP_FIRST:\n\t\t\tIFCALLRET(altsec->StreamBitmapFirst, rc, context, &(altsec->stream_bitmap_first));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_STREAM_BITMAP_NEXT:\n\t\t\tIFCALLRET(altsec->StreamBitmapNext, rc, context, &(altsec->stream_bitmap_next));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_FIRST:\n\t\t\tIFCALLRET(altsec->DrawGdiPlusFirst, rc, context, &(altsec->draw_gdiplus_first));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_NEXT:\n\t\t\tIFCALLRET(altsec->DrawGdiPlusNext, rc, context, &(altsec->draw_gdiplus_next));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_END:\n\t\t\tIFCALLRET(altsec->DrawGdiPlusEnd, rc, context, &(altsec->draw_gdiplus_end));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_FIRST:\n\t\t\tIFCALLRET(altsec->DrawGdiPlusCacheFirst, rc, context,\n\t\t\t          &(altsec->draw_gdiplus_cache_first));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_NEXT:\n\t\t\tIFCALLRET(altsec->DrawGdiPlusCacheNext, rc, context,\n\t\t\t          &(altsec->draw_gdiplus_cache_next));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_END:\n\t\t\tIFCALLRET(altsec->DrawGdiPlusCacheEnd, rc, context, &(altsec->draw_gdiplus_cache_end));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_WINDOW:\n\t\t\trc = update_recv_altsec_window_order(update, s);\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_COMPDESK_FIRST:\n\t\t\trc = TRUE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\tif (!rc)\n\t{\n\t\tWLog_Print(update->log, WLOG_WARN, \"Alternate Secondary Drawing Order %s failed\",\n\t\t           orderName);\n\t}\n\n\treturn rc;\n}\nBOOL update_recv_order(rdpUpdate* update, wStream* s)\n{\n\tBOOL rc;\n\tBYTE controlFlags;\n\n\tif (Stream_GetRemainingLength(s) < 1)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"Stream_GetRemainingLength(s) < 1\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT8(s, controlFlags); /* controlFlags (1 byte) */\n\n\tif (!(controlFlags & ORDER_STANDARD))\n\t\trc = update_recv_altsec_order(update, s, controlFlags);\n\telse if (controlFlags & ORDER_SECONDARY)\n\t\trc = update_recv_secondary_order(update, s, controlFlags);\n\telse\n\t\trc = update_recv_primary_order(update, s, controlFlags);\n\n\tif (!rc)\n\t\tWLog_Print(update->log, WLOG_ERROR, \"order flags %02\" PRIx8 \" failed\", controlFlags);\n\n\treturn rc;\n}\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * RDP Server Peer\n *\n * Copyright 2011 Vic Lee\n * Copyright 2014 DI (FH) Martin Haimberger <martin.haimberger@thincast.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <winpr/crt.h>\n#include <winpr/winsock.h>\n\n#include \"info.h\"\n#include \"certificate.h\"\n\n#include <freerdp/log.h>\n\n#include \"rdp.h\"\n#include \"peer.h\"\n\n#define TAG FREERDP_TAG(\"core.peer\")\n\nstatic HANDLE freerdp_peer_virtual_channel_open(freerdp_peer* client, const char* name,\n                                                UINT32 flags)\n{\n\tint length;\n\tUINT32 index;\n\tBOOL joined = FALSE;\n\trdpMcsChannel* mcsChannel = NULL;\n\trdpPeerChannel* peerChannel = NULL;\n\trdpMcs* mcs = client->context->rdp->mcs;\n\n\tif (flags & WTS_CHANNEL_OPTION_DYNAMIC)\n\t\treturn NULL; /* not yet supported */\n\n\tlength = strnlen(name, 9);\n\n\tif (length > 8)\n\t\treturn NULL; /* SVC maximum name length is 8 */\n\n\tfor (index = 0; index < mcs->channelCount; index++)\n\t{\n\t\tmcsChannel = &(mcs->channels[index]);\n\n\t\tif (!mcsChannel->joined)\n\t\t\tcontinue;\n\n\t\tif (_strnicmp(name, mcsChannel->Name, length) == 0)\n\t\t{\n\t\t\tjoined = TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!joined)\n\t\treturn NULL; /* channel is not joined */\n\n\tpeerChannel = (rdpPeerChannel*)mcsChannel->handle;\n\n\tif (peerChannel)\n\t{\n\t\t/* channel is already open */\n\t\treturn (HANDLE)peerChannel;\n\t}\n\n\tpeerChannel = (rdpPeerChannel*)calloc(1, sizeof(rdpPeerChannel));\n\n\tif (peerChannel)\n\t{\n\t\tpeerChannel->index = index;\n\t\tpeerChannel->client = client;\n\t\tpeerChannel->channelFlags = flags;\n\t\tpeerChannel->channelId = mcsChannel->ChannelId;\n\t\tpeerChannel->mcsChannel = mcsChannel;\n\t\tmcsChannel->handle = (void*)peerChannel;\n\t}\n\n\treturn (HANDLE)peerChannel;\n}\n\nstatic BOOL freerdp_peer_virtual_channel_close(freerdp_peer* client, HANDLE hChannel)\n{\n\trdpMcsChannel* mcsChannel = NULL;\n\trdpPeerChannel* peerChannel = NULL;\n\n\tif (!hChannel)\n\t\treturn FALSE;\n\n\tpeerChannel = (rdpPeerChannel*)hChannel;\n\tmcsChannel = peerChannel->mcsChannel;\n\tmcsChannel->handle = NULL;\n\tfree(peerChannel);\n\treturn TRUE;\n}\n\nstatic int freerdp_peer_virtual_channel_write(freerdp_peer* client, HANDLE hChannel,\n                                              const BYTE* buffer, UINT32 length)\n{\n\twStream* s;\n\tUINT32 flags;\n\tUINT32 chunkSize;\n\tUINT32 maxChunkSize;\n\tUINT32 totalLength;\n\trdpPeerChannel* peerChannel;\n\trdpMcsChannel* mcsChannel;\n\trdpRdp* rdp = client->context->rdp;\n\n\tif (!hChannel)\n\t\treturn -1;\n\n\tpeerChannel = (rdpPeerChannel*)hChannel;\n\tmcsChannel = peerChannel->mcsChannel;\n\n\tif (peerChannel->channelFlags & WTS_CHANNEL_OPTION_DYNAMIC)\n\t\treturn -1; /* not yet supported */\n\n\tmaxChunkSize = rdp->settings->VirtualChannelChunkSize;\n\ttotalLength = length;\n\tflags = CHANNEL_FLAG_FIRST;\n\n\twhile (length > 0)\n\t{\n\t\ts = rdp_send_stream_init(rdp);\n\n\t\tif (!s)\n\t\t\treturn -1;\n\n\t\tif (length > maxChunkSize)\n\t\t{\n\t\t\tchunkSize = rdp->settings->VirtualChannelChunkSize;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tchunkSize = length;\n\t\t\tflags |= CHANNEL_FLAG_LAST;\n\t\t}\n\n\t\tif (mcsChannel->options & CHANNEL_OPTION_SHOW_PROTOCOL)\n\t\t\tflags |= CHANNEL_FLAG_SHOW_PROTOCOL;\n\n\t\tStream_Write_UINT32(s, totalLength);\n\t\tStream_Write_UINT32(s, flags);\n\n\t\tif (!Stream_EnsureRemainingCapacity(s, chunkSize))\n\t\t{\n\t\t\tStream_Release(s);\n\t\t\treturn -1;\n\t\t}\n\n\t\tStream_Write(s, buffer, chunkSize);\n\n\t\tif (!rdp_send(rdp, s, peerChannel->channelId))\n\t\t\treturn -1;\n\n\t\tbuffer += chunkSize;\n\t\tlength -= chunkSize;\n\t\tflags = 0;\n\t}\n\n\treturn 1;\n}\n\nstatic void* freerdp_peer_virtual_channel_get_data(freerdp_peer* client, HANDLE hChannel)\n{\n\trdpPeerChannel* peerChannel = (rdpPeerChannel*)hChannel;\n\n\tif (!hChannel)\n\t\treturn NULL;\n\n\treturn peerChannel->extra;\n}\n\nstatic int freerdp_peer_virtual_channel_set_data(freerdp_peer* client, HANDLE hChannel, void* data)\n{\n\trdpPeerChannel* peerChannel = (rdpPeerChannel*)hChannel;\n\n\tif (!hChannel)\n\t\treturn -1;\n\n\tpeerChannel->extra = data;\n\treturn 1;\n}\n\nstatic BOOL freerdp_peer_initialize(freerdp_peer* client)\n{\n\trdpRdp* rdp = client->context->rdp;\n\trdpSettings* settings = rdp->settings;\n\tsettings->ServerMode = TRUE;\n\tsettings->FrameAcknowledge = 0;\n\tsettings->LocalConnection = client->local;\n\trdp->state = CONNECTION_STATE_INITIAL;\n\n\tif (settings->RdpKeyFile)\n\t{\n\t\tsettings->RdpServerRsaKey = key_new(settings->RdpKeyFile);\n\n\t\tif (!settings->RdpServerRsaKey)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"invalid RDP key file %s\", settings->RdpKeyFile);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\telse if (settings->RdpKeyContent)\n\t{\n\t\tsettings->RdpServerRsaKey = key_new_from_content(settings->RdpKeyContent, NULL);\n\n\t\tif (!settings->RdpServerRsaKey)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"invalid RDP key content\");\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL freerdp_peer_get_fds(freerdp_peer* client, void** rfds, int* rcount)\n{\n\trdpTransport* transport = client->context->rdp->transport;\n\ttransport_get_fds(transport, rfds, rcount);\n\treturn TRUE;\n}\n\nstatic HANDLE freerdp_peer_get_event_handle(freerdp_peer* client)\n{\n\tHANDLE hEvent = NULL;\n\trdpTransport* transport = client->context->rdp->transport;\n\tBIO_get_event(transport->frontBio, &hEvent);\n\treturn hEvent;\n}\n\nstatic DWORD freerdp_peer_get_event_handles(freerdp_peer* client, HANDLE* events, DWORD count)\n{\n\treturn transport_get_event_handles(client->context->rdp->transport, events, count);\n}\n\nstatic BOOL freerdp_peer_check_fds(freerdp_peer* peer)\n{\n\tint status;\n\trdpRdp* rdp;\n\trdp = peer->context->rdp;\n\tstatus = rdp_check_fds(rdp);\n\n\tif (status < 0)\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\nstatic BOOL peer_recv_data_pdu(freerdp_peer* client, wStream* s, UINT16 totalLength)\n{\n\tBYTE type;\n\tUINT16 length;\n\tUINT32 share_id;\n\tBYTE compressed_type;\n\tUINT16 compressed_len;\n\n\tif (!rdp_read_share_data_header(s, &length, &type, &share_id, &compressed_type,\n\t                                &compressed_len))\n\t\treturn FALSE;\n\n#ifdef WITH_DEBUG_RDP\n\tWLog_DBG(TAG, \"recv %s Data PDU (0x%02\" PRIX8 \"), length: %\" PRIu16 \"\",\n\t         type < ARRAYSIZE(DATA_PDU_TYPE_STRINGS) ? DATA_PDU_TYPE_STRINGS[type] : \"???\", type,\n\t         length);\n#endif\n\n\tswitch (type)\n\t{\n\t\tcase DATA_PDU_TYPE_SYNCHRONIZE:\n\t\t\tif (!rdp_recv_client_synchronize_pdu(client->context->rdp, s))\n\t\t\t\treturn FALSE;\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_CONTROL:\n\t\t\tif (!rdp_server_accept_client_control_pdu(client->context->rdp, s))\n\t\t\t\treturn FALSE;\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_INPUT:\n\t\t\tif (!input_recv(client->context->rdp->input, s))\n\t\t\t\treturn FALSE;\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_BITMAP_CACHE_PERSISTENT_LIST:\n\t\t\t/* TODO: notify server bitmap cache data */\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_FONT_LIST:\n\t\t\tif (!rdp_server_accept_client_font_list_pdu(client->context->rdp, s))\n\t\t\t\treturn FALSE;\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_SHUTDOWN_REQUEST:\n\t\t\tmcs_send_disconnect_provider_ultimatum(client->context->rdp->mcs);\n\t\t\treturn FALSE;\n\n\t\tcase DATA_PDU_TYPE_FRAME_ACKNOWLEDGE:\n\t\t\tif (Stream_GetRemainingLength(s) < 4)\n\t\t\t\treturn FALSE;\n\n\t\t\tStream_Read_UINT32(s, client->ack_frame_id);\n\t\t\tIFCALL(client->update->SurfaceFrameAcknowledge, client->update->context,\n\t\t\t       client->ack_frame_id);\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_REFRESH_RECT:\n\t\t\tif (!update_read_refresh_rect(client->update, s))\n\t\t\t\treturn FALSE;\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_SUPPRESS_OUTPUT:\n\t\t\tif (!update_read_suppress_output(client->update, s))\n\t\t\t\treturn FALSE;\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_ERR(TAG, \"Data PDU type %\" PRIu8 \"\", type);\n\t\t\tbreak;\n\t}\n\n\treturn TRUE;\n}\n\nstatic int peer_recv_tpkt_pdu(freerdp_peer* client, wStream* s)\n{\n\trdpRdp* rdp;\n\tUINT16 length;\n\tUINT16 pduType;\n\tUINT16 pduLength;\n\tUINT16 pduSource;\n\tUINT16 channelId;\n\tUINT16 securityFlags = 0;\n\trdp = client->context->rdp;\n\n\tif (!rdp_read_header(rdp, s, &length, &channelId))\n\t{\n\t\tWLog_ERR(TAG, \"Incorrect RDP header.\");\n\t\treturn -1;\n\t}\n\n\trdp->inPackets++;\n\tif (freerdp_shall_disconnect(rdp->instance))\n\t\treturn 0;\n\n\tif (rdp->settings->UseRdpSecurityLayer)\n\t{\n\t\tif (!rdp_read_security_header(s, &securityFlags, &length))\n\t\t\treturn -1;\n\n\t\tif (securityFlags & SEC_ENCRYPT)\n\t\t{\n\t\t\tif (!rdp_decrypt(rdp, s, &length, securityFlags))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdp_decrypt failed\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (channelId == MCS_GLOBAL_CHANNEL_ID)\n\t{\n\t\tif (!rdp_read_share_control_header(s, &pduLength, &pduType, &pduSource))\n\t\t\treturn -1;\n\n\t\tclient->settings->PduSource = pduSource;\n\n\t\tswitch (pduType)\n\t\t{\n\t\t\tcase PDU_TYPE_DATA:\n\t\t\t\tif (!peer_recv_data_pdu(client, s, pduLength))\n\t\t\t\t\treturn -1;\n\n\t\t\t\tbreak;\n\n\t\t\tcase PDU_TYPE_CONFIRM_ACTIVE:\n\t\t\t\tif (!rdp_server_accept_confirm_active(rdp, s, pduLength))\n\t\t\t\t\treturn -1;\n\n\t\t\t\tbreak;\n\n\t\t\tcase PDU_TYPE_FLOW_RESPONSE:\n\t\t\tcase PDU_TYPE_FLOW_STOP:\n\t\t\tcase PDU_TYPE_FLOW_TEST:\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tWLog_ERR(TAG, \"Client sent pduType %\" PRIu16 \"\", pduType);\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\telse if ((rdp->mcs->messageChannelId > 0) && (channelId == rdp->mcs->messageChannelId))\n\t{\n\t\tif (!rdp->settings->UseRdpSecurityLayer)\n\t\t\tif (!rdp_read_security_header(s, &securityFlags, NULL))\n\t\t\t\treturn -1;\n\n\t\treturn rdp_recv_message_channel_pdu(rdp, s, securityFlags);\n\t}\n\telse\n\t{\n\t\tif (!freerdp_channel_peer_process(client, s, channelId))\n\t\t\treturn -1;\n\t}\n\n\tif (!tpkt_ensure_stream_consumed(s, length))\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int peer_recv_fastpath_pdu(freerdp_peer* client, wStream* s)\n{\n\trdpRdp* rdp;\n\tUINT16 length;\n\trdpFastPath* fastpath;\n\trdp = client->context->rdp;\n\tfastpath = rdp->fastpath;\n\tfastpath_read_header_rdp(fastpath, s, &length);\n\n\tif ((length == 0) || (length > Stream_GetRemainingLength(s)))\n\t{\n\t\tWLog_ERR(TAG, \"incorrect FastPath PDU header length %\" PRIu16 \"\", length);\n\t\treturn -1;\n\t}\n\n\tif (fastpath->encryptionFlags & FASTPATH_OUTPUT_ENCRYPTED)\n\t{\n\t\tif (!rdp_decrypt(rdp, s, &length,\n\t\t                 (fastpath->encryptionFlags & FASTPATH_OUTPUT_SECURE_CHECKSUM)\n\t\t                     ? SEC_SECURE_CHECKSUM\n\t\t                     : 0))\n\t\t\treturn -1;\n\t}\n\n\trdp->inPackets++;\n\n\treturn fastpath_recv_inputs(fastpath, s);\n}\n\nstatic int peer_recv_pdu(freerdp_peer* client, wStream* s)\n{\n\tif (tpkt_verify_header(s))\n\t\treturn peer_recv_tpkt_pdu(client, s);\n\telse\n\t\treturn peer_recv_fastpath_pdu(client, s);\n}\n\nstatic int peer_recv_callback(rdpTransport* transport, wStream* s, void* extra)\n{\n\tUINT32 SelectedProtocol;\n\tfreerdp_peer* client = (freerdp_peer*)extra;\n\trdpRdp* rdp = client->context->rdp;\n\n\tswitch (rdp->state)\n\t{\n\t\tcase CONNECTION_STATE_INITIAL:\n\t\t\tif (!rdp_server_accept_nego(rdp, s))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"%s: %s - rdp_server_accept_nego() fail\", __FUNCTION__,\n\t\t\t\t         rdp_server_connection_state_string(rdp->state));\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tSelectedProtocol = nego_get_selected_protocol(rdp->nego);\n\t\t\tclient->settings->NlaSecurity = (SelectedProtocol & PROTOCOL_HYBRID) ? TRUE : FALSE;\n\t\t\tclient->settings->TlsSecurity = (SelectedProtocol & PROTOCOL_SSL) ? TRUE : FALSE;\n\t\t\tclient->settings->RdpSecurity = (SelectedProtocol == PROTOCOL_RDP) ? TRUE : FALSE;\n\n\t\t\tif (SelectedProtocol & PROTOCOL_HYBRID)\n\t\t\t{\n\t\t\t\tSEC_WINNT_AUTH_IDENTITY* identity = nego_get_identity(rdp->nego);\n\t\t\t\tsspi_CopyAuthIdentity(&client->identity, identity);\n\t\t\t\tIFCALLRET(client->Logon, client->authenticated, client, &client->identity, TRUE);\n\t\t\t\tnego_free_nla(rdp->nego);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tIFCALLRET(client->Logon, client->authenticated, client, &client->identity, FALSE);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_NEGO:\n\t\t\tif (!rdp_server_accept_mcs_connect_initial(rdp, s))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG,\n\t\t\t\t         \"%s: %s - \"\n\t\t\t\t         \"rdp_server_accept_mcs_connect_initial() fail\",\n\t\t\t\t         __FUNCTION__, rdp_server_connection_state_string(rdp->state));\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_CONNECT:\n\t\t\tif (!rdp_server_accept_mcs_erect_domain_request(rdp, s))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG,\n\t\t\t\t         \"%s: %s - \"\n\t\t\t\t         \"rdp_server_accept_mcs_erect_domain_request() fail\",\n\t\t\t\t         __FUNCTION__, rdp_server_connection_state_string(rdp->state));\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_ERECT_DOMAIN:\n\t\t\tif (!rdp_server_accept_mcs_attach_user_request(rdp, s))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG,\n\t\t\t\t         \"%s: %s - \"\n\t\t\t\t         \"rdp_server_accept_mcs_attach_user_request() fail\",\n\t\t\t\t         __FUNCTION__, rdp_server_connection_state_string(rdp->state));\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_ATTACH_USER:\n\t\t\tif (!rdp_server_accept_mcs_channel_join_request(rdp, s))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG,\n\t\t\t\t         \"%s: %s - \"\n\t\t\t\t         \"rdp_server_accept_mcs_channel_join_request() fail\",\n\t\t\t\t         __FUNCTION__, rdp_server_connection_state_string(rdp->state));\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_RDP_SECURITY_COMMENCEMENT:\n\t\t\tif (rdp->settings->UseRdpSecurityLayer)\n\t\t\t{\n\t\t\t\tif (!rdp_server_establish_keys(rdp, s))\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG,\n\t\t\t\t\t         \"%s: %s - \"\n\t\t\t\t\t         \"rdp_server_establish_keys() fail\",\n\t\t\t\t\t         __FUNCTION__, rdp_server_connection_state_string(rdp->state));\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trdp_server_transition_to_state(rdp, CONNECTION_STATE_SECURE_SETTINGS_EXCHANGE);\n\n\t\t\tif (Stream_GetRemainingLength(s) > 0)\n\t\t\t\treturn peer_recv_callback(transport, s, extra);\n\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_SECURE_SETTINGS_EXCHANGE:\n\t\t\tif (!rdp_recv_client_info(rdp, s))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG,\n\t\t\t\t         \"%s: %s - \"\n\t\t\t\t         \"rdp_recv_client_info() fail\",\n\t\t\t\t         __FUNCTION__, rdp_server_connection_state_string(rdp->state));\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\trdp_server_transition_to_state(rdp, CONNECTION_STATE_LICENSING);\n\t\t\treturn peer_recv_callback(transport, NULL, extra);\n\n\t\tcase CONNECTION_STATE_LICENSING:\n\t\t{\n\t\t\tLicenseCallbackResult res;\n\n\t\t\tif (!client->LicenseCallback)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG,\n\t\t\t\t         \"%s: LicenseCallback has been removed, assuming \"\n\t\t\t\t         \"licensing is ok (please fix your app)\",\n\t\t\t\t         __FUNCTION__);\n\t\t\t\tres = LICENSE_CB_COMPLETED;\n\t\t\t}\n\t\t\telse\n\t\t\t\tres = client->LicenseCallback(client, s);\n\n\t\t\tswitch (res)\n\t\t\t{\n\t\t\t\tcase LICENSE_CB_INTERNAL_ERROR:\n\t\t\t\t\tWLog_ERR(TAG,\n\t\t\t\t\t         \"%s: %s - callback internal \"\n\t\t\t\t\t         \"error, aborting\",\n\t\t\t\t\t         __FUNCTION__, rdp_server_connection_state_string(rdp->state));\n\t\t\t\t\treturn -1;\n\n\t\t\t\tcase LICENSE_CB_ABORT:\n\t\t\t\t\treturn -1;\n\n\t\t\t\tcase LICENSE_CB_IN_PROGRESS:\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase LICENSE_CB_COMPLETED:\n\t\t\t\t\trdp_server_transition_to_state(rdp, CONNECTION_STATE_CAPABILITIES_EXCHANGE);\n\t\t\t\t\treturn peer_recv_callback(transport, NULL, extra);\n\n\t\t\t\tdefault:\n\t\t\t\t\tWLog_ERR(TAG,\n\t\t\t\t\t         \"%s: CONNECTION_STATE_LICENSING - unknown license callback \"\n\t\t\t\t\t         \"result %d\",\n\t\t\t\t\t         __FUNCTION__, res);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase CONNECTION_STATE_CAPABILITIES_EXCHANGE:\n\t\t\tif (!rdp->AwaitCapabilities)\n\t\t\t{\n\t\t\t\tif (client->Capabilities && !client->Capabilities(client))\n\t\t\t\t\treturn -1;\n\n\t\t\t\tif (!rdp_send_demand_active(rdp))\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG,\n\t\t\t\t\t         \"%s: %s - \"\n\t\t\t\t\t         \"rdp_send_demand_active() fail\",\n\t\t\t\t\t         __FUNCTION__, rdp_server_connection_state_string(rdp->state));\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\trdp->AwaitCapabilities = TRUE;\n\n\t\t\t\tif (s)\n\t\t\t\t{\n\t\t\t\t\tif (peer_recv_pdu(client, s) < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tWLog_ERR(TAG,\n\t\t\t\t\t\t         \"%s: %s - \"\n\t\t\t\t\t\t         \"peer_recv_pdu() fail\",\n\t\t\t\t\t\t         __FUNCTION__, rdp_server_connection_state_string(rdp->state));\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/**\n\t\t\t\t * During reactivation sequence the client might sent some input or channel data\n\t\t\t\t * before receiving the Deactivate All PDU. We need to process them as usual.\n\t\t\t\t */\n\t\t\t\tif (peer_recv_pdu(client, s) < 0)\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG,\n\t\t\t\t\t         \"%s: %s - \"\n\t\t\t\t\t         \"peer_recv_pdu() fail\",\n\t\t\t\t\t         __FUNCTION__, rdp_server_connection_state_string(rdp->state));\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_FINALIZATION:\n\t\t\tif (peer_recv_pdu(client, s) < 0)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"%s: %s - peer_recv_pdu() fail\", __FUNCTION__,\n\t\t\t\t         rdp_server_connection_state_string(rdp->state));\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_ACTIVE:\n\t\t\tif (peer_recv_pdu(client, s) < 0)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"%s: %s - peer_recv_pdu() fail\", __FUNCTION__,\n\t\t\t\t         rdp_server_connection_state_string(rdp->state));\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_ERR(TAG, \"%s state %d\", rdp_server_connection_state_string(rdp->state),\n\t\t\t         rdp->state);\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic BOOL freerdp_peer_close(freerdp_peer* client)\n{\n\tUINT32 SelectedProtocol;\n\t/** if negotiation has failed, we're not MCS connected. So don't\n\t * \tsend anything else, or some mstsc will consider that as an error\n\t */\n\tSelectedProtocol = nego_get_selected_protocol(client->context->rdp->nego);\n\n\tif (SelectedProtocol & PROTOCOL_FAILED_NEGO)\n\t\treturn TRUE;\n\n\t/**\n\t * [MS-RDPBCGR] 1.3.1.4.2 User-Initiated Disconnection Sequence on Server\n\t * The server first sends the client a Deactivate All PDU followed by an\n\t * optional MCS Disconnect Provider Ultimatum PDU.\n\t */\n\tif (!rdp_send_deactivate_all(client->context->rdp))\n\t\treturn FALSE;\n\n\tif (freerdp_settings_get_bool(client->settings, FreeRDP_SupportErrorInfoPdu))\n\t{\n\t\trdp_send_error_info(client->context->rdp);\n\t}\n\n\treturn mcs_send_disconnect_provider_ultimatum(client->context->rdp->mcs);\n}\n\nstatic void freerdp_peer_disconnect(freerdp_peer* client)\n{\n\trdpTransport* transport = client->context->rdp->transport;\n\ttransport_disconnect(transport);\n}\n\nstatic BOOL freerdp_peer_send_channel_data(freerdp_peer* client, UINT16 channelId, const BYTE* data,\n                                           size_t size)\n{\n\treturn rdp_send_channel_data(client->context->rdp, channelId, data, size);\n}\n\nstatic BOOL freerdp_peer_is_write_blocked(freerdp_peer* peer)\n{\n\trdpTransport* transport = peer->context->rdp->transport;\n\treturn transport_is_write_blocked(transport);\n}\n\nstatic int freerdp_peer_drain_output_buffer(freerdp_peer* peer)\n{\n\trdpTransport* transport = peer->context->rdp->transport;\n\treturn transport_drain_output_buffer(transport);\n}\n\nstatic BOOL freerdp_peer_has_more_to_read(freerdp_peer* peer)\n{\n\treturn peer->context->rdp->transport->haveMoreBytesToRead;\n}\n\nstatic LicenseCallbackResult freerdp_peer_nolicense(freerdp_peer* peer, wStream* s)\n{\n\trdpRdp* rdp = peer->context->rdp;\n\n\tif (!license_send_valid_client_error_packet(rdp))\n\t{\n\t\tWLog_ERR(TAG, \"freerdp_peer_nolicense: license_send_valid_client_error_packet() failed\");\n\t\treturn LICENSE_CB_ABORT;\n\t}\n\n\treturn LICENSE_CB_COMPLETED;\n}\n\nBOOL freerdp_peer_context_new(freerdp_peer* client)\n{\n\trdpRdp* rdp;\n\trdpContext* context;\n\tBOOL ret = TRUE;\n\n\tif (!client)\n\t\treturn FALSE;\n\n\tif (!(context = (rdpContext*)calloc(1, client->ContextSize)))\n\t\tgoto fail_context;\n\n\tclient->context = context;\n\tcontext->peer = client;\n\tcontext->ServerMode = TRUE;\n\tcontext->settings = client->settings;\n\n\tif (!(context->metrics = metrics_new(context)))\n\t\tgoto fail_metrics;\n\n\tif (!(rdp = rdp_new(context)))\n\t\tgoto fail_rdp;\n\n\tclient->input = rdp->input;\n\tclient->update = rdp->update;\n\tclient->settings = rdp->settings;\n\tclient->autodetect = rdp->autodetect;\n\tcontext->rdp = rdp;\n\tcontext->input = client->input;\n\tcontext->update = client->update;\n\tcontext->settings = client->settings;\n\tcontext->autodetect = client->autodetect;\n\tclient->update->context = context;\n\tclient->input->context = context;\n\tclient->autodetect->context = context;\n\tupdate_register_server_callbacks(client->update);\n\tautodetect_register_server_callbacks(client->autodetect);\n\n\tif (!(context->errorDescription = calloc(1, 500)))\n\t{\n\t\tWLog_ERR(TAG, \"calloc failed!\");\n\t\tgoto fail_error_description;\n\t}\n\n\tif (!transport_attach(rdp->transport, client->sockfd))\n\t\tgoto fail_transport_attach;\n\n\trdp->transport->ReceiveCallback = peer_recv_callback;\n\trdp->transport->ReceiveExtra = client;\n\ttransport_set_blocking_mode(rdp->transport, FALSE);\n\tclient->IsWriteBlocked = freerdp_peer_is_write_blocked;\n\tclient->DrainOutputBuffer = freerdp_peer_drain_output_buffer;\n\tclient->HasMoreToRead = freerdp_peer_has_more_to_read;\n\tclient->LicenseCallback = freerdp_peer_nolicense;\n\tIFCALLRET(client->ContextNew, ret, client, client->context);\n\n\tif (ret)\n\t\treturn TRUE;\n\n\tWLog_ERR(TAG, \"ContextNew callback failed\");\nfail_transport_attach:\n\tfree(context->errorDescription);\nfail_error_description:\n\trdp_free(client->context->rdp);\nfail_rdp:\n\tmetrics_free(context->metrics);\nfail_metrics:\n\tfree(client->context);\nfail_context:\n\tclient->context = NULL;\n\tWLog_ERR(TAG, \"Failed to create new peer context\");\n\treturn FALSE;\n}\n\nvoid freerdp_peer_context_free(freerdp_peer* client)\n{\n\tIFCALL(client->ContextFree, client, client->context);\n\n\tif (client->context)\n\t{\n\t\tfree(client->context->errorDescription);\n\t\tclient->context->errorDescription = NULL;\n\t\trdp_free(client->context->rdp);\n\t\tclient->context->rdp = NULL;\n\t\tmetrics_free(client->context->metrics);\n\t\tclient->context->metrics = NULL;\n\t\tfree(client->context);\n\t\tclient->context = NULL;\n\t}\n}\n\nfreerdp_peer* freerdp_peer_new(int sockfd)\n{\n\tUINT32 option_value;\n\tsocklen_t option_len;\n\tfreerdp_peer* client;\n\tclient = (freerdp_peer*)calloc(1, sizeof(freerdp_peer));\n\n\tif (!client)\n\t\treturn NULL;\n\n\toption_value = TRUE;\n\toption_len = sizeof(option_value);\n\tsetsockopt(sockfd, IPPROTO_TCP, TCP_NODELAY, (void*)&option_value, option_len);\n\n\tif (client)\n\t{\n\t\tclient->sockfd = sockfd;\n\t\tclient->ContextSize = sizeof(rdpContext);\n\t\tclient->Initialize = freerdp_peer_initialize;\n\t\tclient->GetFileDescriptor = freerdp_peer_get_fds;\n\t\tclient->GetEventHandle = freerdp_peer_get_event_handle;\n\t\tclient->GetEventHandles = freerdp_peer_get_event_handles;\n\t\tclient->CheckFileDescriptor = freerdp_peer_check_fds;\n\t\tclient->Close = freerdp_peer_close;\n\t\tclient->Disconnect = freerdp_peer_disconnect;\n\t\tclient->SendChannelData = freerdp_peer_send_channel_data;\n\t\tclient->IsWriteBlocked = freerdp_peer_is_write_blocked;\n\t\tclient->DrainOutputBuffer = freerdp_peer_drain_output_buffer;\n\t\tclient->HasMoreToRead = freerdp_peer_has_more_to_read;\n\t\tclient->VirtualChannelOpen = freerdp_peer_virtual_channel_open;\n\t\tclient->VirtualChannelClose = freerdp_peer_virtual_channel_close;\n\t\tclient->VirtualChannelWrite = freerdp_peer_virtual_channel_write;\n\t\tclient->VirtualChannelRead = NULL; /* must be defined by server application */\n\t\tclient->VirtualChannelGetData = freerdp_peer_virtual_channel_get_data;\n\t\tclient->VirtualChannelSetData = freerdp_peer_virtual_channel_set_data;\n\t}\n\n\treturn client;\n}\n\nvoid freerdp_peer_free(freerdp_peer* client)\n{\n\tif (!client)\n\t\treturn;\n\n\tfree(client);\n}\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * RDP Core\n *\n * Copyright 2011 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2014 DI (FH) Martin Haimberger <martin.haimberger@thincast.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <winpr/crt.h>\n\n#include \"rdp.h\"\n\n#include \"info.h\"\n#include \"redirection.h\"\n\n#include <freerdp/crypto/per.h>\n#include <freerdp/log.h>\n\n#define TAG FREERDP_TAG(\"core.rdp\")\n\nconst char* DATA_PDU_TYPE_STRINGS[80] = {\n\t\"?\",\n\t\"?\",      /* 0x00 - 0x01 */\n\t\"Update\", /* 0x02 */\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\", /* 0x03 - 0x0A */\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",       /* 0x0B - 0x13 */\n\t\"Control\", /* 0x14 */\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",       /* 0x15 - 0x1A */\n\t\"Pointer\", /* 0x1B */\n\t\"Input\",   /* 0x1C */\n\t\"?\",\n\t\"?\",                            /* 0x1D - 0x1E */\n\t\"Synchronize\",                  /* 0x1F */\n\t\"?\",                            /* 0x20 */\n\t\"Refresh Rect\",                 /* 0x21 */\n\t\"Play Sound\",                   /* 0x22 */\n\t\"Suppress Output\",              /* 0x23 */\n\t\"Shutdown Request\",             /* 0x24 */\n\t\"Shutdown Denied\",              /* 0x25 */\n\t\"Save Session Info\",            /* 0x26 */\n\t\"Font List\",                    /* 0x27 */\n\t\"Font Map\",                     /* 0x28 */\n\t\"Set Keyboard Indicators\",      /* 0x29 */\n\t\"?\",                            /* 0x2A */\n\t\"Bitmap Cache Persistent List\", /* 0x2B */\n\t\"Bitmap Cache Error\",           /* 0x2C */\n\t\"Set Keyboard IME Status\",      /* 0x2D */\n\t\"Offscreen Cache Error\",        /* 0x2E */\n\t\"Set Error Info\",               /* 0x2F */\n\t\"Draw Nine Grid Error\",         /* 0x30 */\n\t\"Draw GDI+ Error\",              /* 0x31 */\n\t\"ARC Status\",                   /* 0x32 */\n\t\"?\",\n\t\"?\",\n\t\"?\",              /* 0x33 - 0x35 */\n\t\"Status Info\",    /* 0x36 */\n\t\"Monitor Layout\", /* 0x37 */\n\t\"FrameAcknowledge\",\n\t\"?\",\n\t\"?\", /* 0x38 - 0x40 */\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\" /* 0x41 - 0x46 */\n};\n\nstatic void rdp_read_flow_control_pdu(wStream* s, UINT16* type);\nstatic void rdp_write_share_control_header(wStream* s, UINT16 length, UINT16 type,\n                                           UINT16 channel_id);\nstatic void rdp_write_share_data_header(wStream* s, UINT16 length, BYTE type, UINT32 share_id);\n\n/**\n * Read RDP Security Header.\\n\n * @msdn{cc240579}\n * @param s stream\n * @param flags security flags\n */\n\nBOOL rdp_read_security_header(wStream* s, UINT16* flags, UINT16* length)\n{\n\t/* Basic Security Header */\n\tif ((Stream_GetRemainingLength(s) < 4) || (length && (*length < 4)))\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, *flags); /* flags */\n\tStream_Seek(s, 2);             /* flagsHi (unused) */\n\n\tif (length)\n\t\t*length -= 4;\n\n\treturn TRUE;\n}\n\n/**\n * Write RDP Security Header.\\n\n * @msdn{cc240579}\n * @param s stream\n * @param flags security flags\n */\n\nvoid rdp_write_security_header(wStream* s, UINT16 flags)\n{\n\t/* Basic Security Header */\n\tStream_Write_UINT16(s, flags); /* flags */\n\tStream_Write_UINT16(s, 0);     /* flagsHi (unused) */\n}\n\nBOOL rdp_read_share_control_header(wStream* s, UINT16* length, UINT16* type, UINT16* channel_id)\n{\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\treturn FALSE;\n\n\t/* Share Control Header */\n\tStream_Read_UINT16(s, *length); /* totalLength */\n\n\t/* If length is 0x8000 then we actually got a flow control PDU that we should ignore\n\t http://msdn.microsoft.com/en-us/library/cc240576.aspx */\n\tif (*length == 0x8000)\n\t{\n\t\trdp_read_flow_control_pdu(s, type);\n\t\t*channel_id = 0;\n\t\t*length = 8; /* Flow control PDU is 8 bytes */\n\t\treturn TRUE;\n\t}\n\n\tif (((size_t)*length - 2) > Stream_GetRemainingLength(s))\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, *type); /* pduType */\n\t*type &= 0x0F;                /* type is in the 4 least significant bits */\n\n\tif (*length > 4)\n\t\tStream_Read_UINT16(s, *channel_id); /* pduSource */\n\telse\n\t\t*channel_id = 0; /* Windows XP can send such short DEACTIVATE_ALL PDUs. */\n\n\treturn TRUE;\n}\n\nvoid rdp_write_share_control_header(wStream* s, UINT16 length, UINT16 type, UINT16 channel_id)\n{\n\tlength -= RDP_PACKET_HEADER_MAX_LENGTH;\n\t/* Share Control Header */\n\tStream_Write_UINT16(s, length);      /* totalLength */\n\tStream_Write_UINT16(s, type | 0x10); /* pduType */\n\tStream_Write_UINT16(s, channel_id);  /* pduSource */\n}\n\nBOOL rdp_read_share_data_header(wStream* s, UINT16* length, BYTE* type, UINT32* shareId,\n                                BYTE* compressedType, UINT16* compressedLength)\n{\n\tif (Stream_GetRemainingLength(s) < 12)\n\t\treturn FALSE;\n\n\t/* Share Data Header */\n\tStream_Read_UINT32(s, *shareId);          /* shareId (4 bytes) */\n\tStream_Seek_UINT8(s);                     /* pad1 (1 byte) */\n\tStream_Seek_UINT8(s);                     /* streamId (1 byte) */\n\tStream_Read_UINT16(s, *length);           /* uncompressedLength (2 bytes) */\n\tStream_Read_UINT8(s, *type);              /* pduType2, Data PDU Type (1 byte) */\n\tStream_Read_UINT8(s, *compressedType);    /* compressedType (1 byte) */\n\tStream_Read_UINT16(s, *compressedLength); /* compressedLength (2 bytes) */\n\treturn TRUE;\n}\n\nvoid rdp_write_share_data_header(wStream* s, UINT16 length, BYTE type, UINT32 share_id)\n{\n\tlength -= RDP_PACKET_HEADER_MAX_LENGTH;\n\tlength -= RDP_SHARE_CONTROL_HEADER_LENGTH;\n\tlength -= RDP_SHARE_DATA_HEADER_LENGTH;\n\t/* Share Data Header */\n\tStream_Write_UINT32(s, share_id);  /* shareId (4 bytes) */\n\tStream_Write_UINT8(s, 0);          /* pad1 (1 byte) */\n\tStream_Write_UINT8(s, STREAM_LOW); /* streamId (1 byte) */\n\tStream_Write_UINT16(s, length);    /* uncompressedLength (2 bytes) */\n\tStream_Write_UINT8(s, type);       /* pduType2, Data PDU Type (1 byte) */\n\tStream_Write_UINT8(s, 0);          /* compressedType (1 byte) */\n\tStream_Write_UINT16(s, 0);         /* compressedLength (2 bytes) */\n}\n\nstatic BOOL rdp_security_stream_init(rdpRdp* rdp, wStream* s, BOOL sec_header)\n{\n\tif (!rdp || !s)\n\t\treturn FALSE;\n\n\tif (rdp->do_crypt)\n\t{\n\t\tif (!Stream_SafeSeek(s, 12))\n\t\t\treturn FALSE;\n\n\t\tif (rdp->settings->EncryptionMethods == ENCRYPTION_METHOD_FIPS)\n\t\t{\n\t\t\tif (!Stream_SafeSeek(s, 4))\n\t\t\t\treturn FALSE;\n\t\t}\n\n\t\trdp->sec_flags |= SEC_ENCRYPT;\n\n\t\tif (rdp->do_secure_checksum)\n\t\t\trdp->sec_flags |= SEC_SECURE_CHECKSUM;\n\t}\n\telse if (rdp->sec_flags != 0 || sec_header)\n\t{\n\t\tif (!Stream_SafeSeek(s, 4))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nwStream* rdp_send_stream_init(rdpRdp* rdp)\n{\n\twStream* s = transport_send_stream_init(rdp->transport, 4096);\n\n\tif (!s)\n\t\treturn NULL;\n\n\tif (!Stream_SafeSeek(s, RDP_PACKET_HEADER_MAX_LENGTH))\n\t\tgoto fail;\n\n\tif (!rdp_security_stream_init(rdp, s, FALSE))\n\t\tgoto fail;\n\n\treturn s;\nfail:\n\tStream_Release(s);\n\treturn NULL;\n}\n\nwStream* rdp_send_stream_pdu_init(rdpRdp* rdp)\n{\n\twStream* s = rdp_send_stream_init(rdp);\n\n\tif (!s)\n\t\treturn NULL;\n\n\tif (!Stream_SafeSeek(s, RDP_SHARE_CONTROL_HEADER_LENGTH))\n\t\tgoto fail;\n\n\treturn s;\nfail:\n\tStream_Release(s);\n\treturn NULL;\n}\n\nwStream* rdp_data_pdu_init(rdpRdp* rdp)\n{\n\twStream* s = rdp_send_stream_pdu_init(rdp);\n\n\tif (!s)\n\t\treturn NULL;\n\n\tif (!Stream_SafeSeek(s, RDP_SHARE_DATA_HEADER_LENGTH))\n\t\tgoto fail;\n\n\treturn s;\nfail:\n\tStream_Release(s);\n\treturn NULL;\n}\n\nBOOL rdp_set_error_info(rdpRdp* rdp, UINT32 errorInfo)\n{\n\trdp->errorInfo = errorInfo;\n\n\tif (rdp->errorInfo != ERRINFO_SUCCESS)\n\t{\n\t\trdpContext* context = rdp->context;\n\t\trdp_print_errinfo(rdp->errorInfo);\n\n\t\tif (context)\n\t\t{\n\t\t\tfreerdp_set_last_error_log(context, MAKE_FREERDP_ERROR(ERRINFO, errorInfo));\n\n\t\t\tif (context->pubSub)\n\t\t\t{\n\t\t\t\tErrorInfoEventArgs e;\n\t\t\t\tEventArgsInit(&e, \"freerdp\");\n\t\t\t\te.code = rdp->errorInfo;\n\t\t\t\tPubSub_OnErrorInfo(context->pubSub, context, &e);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tWLog_ERR(TAG, \"%s missing context=%p\", __FUNCTION__, context);\n\t}\n\telse\n\t{\n\t\tfreerdp_set_last_error_log(rdp->context, FREERDP_ERROR_SUCCESS);\n\t}\n\n\treturn TRUE;\n}\n\nwStream* rdp_message_channel_pdu_init(rdpRdp* rdp)\n{\n\twStream* s = transport_send_stream_init(rdp->transport, 4096);\n\n\tif (!s)\n\t\treturn NULL;\n\n\tif (!Stream_SafeSeek(s, RDP_PACKET_HEADER_MAX_LENGTH))\n\t\tgoto fail;\n\n\tif (!rdp_security_stream_init(rdp, s, TRUE))\n\t\tgoto fail;\n\n\treturn s;\nfail:\n\tStream_Release(s);\n\treturn NULL;\n}\n\n/**\n * Read an RDP packet header.\\n\n * @param rdp rdp module\n * @param s stream\n * @param length RDP packet length\n * @param channel_id channel id\n */\n\nBOOL rdp_read_header(rdpRdp* rdp, wStream* s, UINT16* length, UINT16* channelId)\n{\n\tBYTE li;\n\tBYTE byte;\n\tBYTE code;\n\tBYTE choice;\n\tUINT16 initiator;\n\tenum DomainMCSPDU MCSPDU;\n\tenum DomainMCSPDU domainMCSPDU;\n\tMCSPDU = (rdp->settings->ServerMode) ? DomainMCSPDU_SendDataRequest\n\t                                     : DomainMCSPDU_SendDataIndication;\n\n\tif (!tpkt_read_header(s, length))\n\t\treturn FALSE;\n\n\tif (!tpdu_read_header(s, &code, &li, *length))\n\t\treturn FALSE;\n\n\tif (code != X224_TPDU_DATA)\n\t{\n\t\tif (code == X224_TPDU_DISCONNECT_REQUEST)\n\t\t{\n\t\t\tfreerdp_abort_connect(rdp->instance);\n\t\t\treturn TRUE;\n\t\t}\n\n\t\treturn FALSE;\n\t}\n\n\tif (!per_read_choice(s, &choice))\n\t\treturn FALSE;\n\n\tdomainMCSPDU = (enum DomainMCSPDU)(choice >> 2);\n\n\tif (domainMCSPDU != MCSPDU)\n\t{\n\t\tif (domainMCSPDU != DomainMCSPDU_DisconnectProviderUltimatum)\n\t\t\treturn FALSE;\n\t}\n\n\tMCSPDU = domainMCSPDU;\n\n\tif (*length < 8U)\n\t\treturn FALSE;\n\n\tif ((*length - 8U) > Stream_GetRemainingLength(s))\n\t\treturn FALSE;\n\n\tif (MCSPDU == DomainMCSPDU_DisconnectProviderUltimatum)\n\t{\n\t\tint reason = 0;\n\t\tTerminateEventArgs e;\n\t\trdpContext* context;\n\n\t\tif (!mcs_recv_disconnect_provider_ultimatum(rdp->mcs, s, &reason))\n\t\t\treturn FALSE;\n\n\t\tif (!rdp->instance)\n\t\t\treturn FALSE;\n\n\t\tcontext = rdp->instance->context;\n\t\tcontext->disconnectUltimatum = reason;\n\n\t\tif (rdp->errorInfo == ERRINFO_SUCCESS)\n\t\t{\n\t\t\t/**\n\t\t\t * Some servers like Windows Server 2008 R2 do not send the error info pdu\n\t\t\t * when the user logs off like they should. Map DisconnectProviderUltimatum\n\t\t\t * to a ERRINFO_LOGOFF_BY_USER when the errinfo code is ERRINFO_SUCCESS.\n\t\t\t */\n\t\t\tif (reason == Disconnect_Ultimatum_provider_initiated)\n\t\t\t\trdp_set_error_info(rdp, ERRINFO_RPC_INITIATED_DISCONNECT);\n\t\t\telse if (reason == Disconnect_Ultimatum_user_requested)\n\t\t\t\trdp_set_error_info(rdp, ERRINFO_LOGOFF_BY_USER);\n\t\t\telse\n\t\t\t\trdp_set_error_info(rdp, ERRINFO_RPC_INITIATED_DISCONNECT);\n\t\t}\n\n\t\tWLog_DBG(TAG, \"DisconnectProviderUltimatum: reason: %d\", reason);\n\t\tfreerdp_abort_connect(rdp->instance);\n\t\tEventArgsInit(&e, \"freerdp\");\n\t\te.code = 0;\n\t\tPubSub_OnTerminate(context->pubSub, context, &e);\n\t\treturn TRUE;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < 5)\n\t\treturn FALSE;\n\n\tif (!per_read_integer16(s, &initiator, MCS_BASE_CHANNEL_ID)) /* initiator (UserId) */\n\t\treturn FALSE;\n\n\tif (!per_read_integer16(s, channelId, 0)) /* channelId */\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, byte); /* dataPriority + Segmentation (0x70) */\n\n\tif (!per_read_length(s, length)) /* userData (OCTET_STRING) */\n\t\treturn FALSE;\n\n\tif (*length > Stream_GetRemainingLength(s))\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\n/**\n * Write an RDP packet header.\\n\n * @param rdp rdp module\n * @param s stream\n * @param length RDP packet length\n * @param channel_id channel id\n */\n\nvoid rdp_write_header(rdpRdp* rdp, wStream* s, UINT16 length, UINT16 channelId)\n{\n\tint body_length;\n\tenum DomainMCSPDU MCSPDU;\n\tMCSPDU = (rdp->settings->ServerMode) ? DomainMCSPDU_SendDataIndication\n\t                                     : DomainMCSPDU_SendDataRequest;\n\n\tif ((rdp->sec_flags & SEC_ENCRYPT) &&\n\t    (rdp->settings->EncryptionMethods == ENCRYPTION_METHOD_FIPS))\n\t{\n\t\tint pad;\n\t\tbody_length = length - RDP_PACKET_HEADER_MAX_LENGTH - 16;\n\t\tpad = 8 - (body_length % 8);\n\n\t\tif (pad != 8)\n\t\t\tlength += pad;\n\t}\n\n\tmcs_write_domain_mcspdu_header(s, MCSPDU, length, 0);\n\tper_write_integer16(s, rdp->mcs->userId, MCS_BASE_CHANNEL_ID); /* initiator */\n\tper_write_integer16(s, channelId, 0);                          /* channelId */\n\tStream_Write_UINT8(s, 0x70);                                   /* dataPriority + segmentation */\n\t/*\n\t * We always encode length in two bytes, even though we could use\n\t * only one byte if length <= 0x7F. It is just easier that way,\n\t * because we can leave room for fixed-length header, store all\n\t * the data first and then store the header.\n\t */\n\tlength = (length - RDP_PACKET_HEADER_MAX_LENGTH) | 0x8000;\n\tStream_Write_UINT16_BE(s, length); /* userData (OCTET_STRING) */\n}\n\nstatic BOOL rdp_security_stream_out(rdpRdp* rdp, wStream* s, int length, UINT32 sec_flags,\n                                    UINT32* pad)\n{\n\tBYTE* data;\n\tBOOL status;\n\tsec_flags |= rdp->sec_flags;\n\t*pad = 0;\n\n\tif (sec_flags != 0)\n\t{\n\t\trdp_write_security_header(s, sec_flags);\n\n\t\tif (sec_flags & SEC_ENCRYPT)\n\t\t{\n\t\t\tif (rdp->settings->EncryptionMethods == ENCRYPTION_METHOD_FIPS)\n\t\t\t{\n\t\t\t\tdata = Stream_Pointer(s) + 12;\n\t\t\t\tlength = length - (data - Stream_Buffer(s));\n\t\t\t\tStream_Write_UINT16(s, 0x10); /* length */\n\t\t\t\tStream_Write_UINT8(s, 0x1);   /* TSFIPS_VERSION 1*/\n\t\t\t\t/* handle padding */\n\t\t\t\t*pad = 8 - (length % 8);\n\n\t\t\t\tif (*pad == 8)\n\t\t\t\t\t*pad = 0;\n\n\t\t\t\tif (*pad)\n\t\t\t\t\tmemset(data + length, 0, *pad);\n\n\t\t\t\tStream_Write_UINT8(s, *pad);\n\n\t\t\t\tif (!security_hmac_signature(data, length, Stream_Pointer(s), rdp))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tStream_Seek(s, 8);\n\t\t\t\tsecurity_fips_encrypt(data, length + *pad, rdp);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdata = Stream_Pointer(s) + 8;\n\t\t\t\tlength = length - (data - Stream_Buffer(s));\n\n\t\t\t\tif (sec_flags & SEC_SECURE_CHECKSUM)\n\t\t\t\t\tstatus =\n\t\t\t\t\t    security_salted_mac_signature(rdp, data, length, TRUE, Stream_Pointer(s));\n\t\t\t\telse\n\t\t\t\t\tstatus = security_mac_signature(rdp, data, length, Stream_Pointer(s));\n\n\t\t\t\tif (!status)\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tStream_Seek(s, 8);\n\n\t\t\t\tif (!security_encrypt(Stream_Pointer(s), length, rdp))\n\t\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\n\t\trdp->sec_flags = 0;\n\t}\n\n\treturn TRUE;\n}\n\nstatic UINT32 rdp_get_sec_bytes(rdpRdp* rdp, UINT16 sec_flags)\n{\n\tUINT32 sec_bytes;\n\n\tif (rdp->sec_flags & SEC_ENCRYPT)\n\t{\n\t\tsec_bytes = 12;\n\n\t\tif (rdp->settings->EncryptionMethods == ENCRYPTION_METHOD_FIPS)\n\t\t\tsec_bytes += 4;\n\t}\n\telse if (rdp->sec_flags != 0 || sec_flags != 0)\n\t{\n\t\tsec_bytes = 4;\n\t}\n\telse\n\t{\n\t\tsec_bytes = 0;\n\t}\n\n\treturn sec_bytes;\n}\n\n/**\n * Send an RDP packet.\n * @param rdp RDP module\n * @param s stream\n * @param channel_id channel id\n */\n\nBOOL rdp_send(rdpRdp* rdp, wStream* s, UINT16 channel_id)\n{\n\tBOOL rc = FALSE;\n\tUINT32 pad;\n\tUINT16 length;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!rdp)\n\t\tgoto fail;\n\n\tlength = Stream_GetPosition(s);\n\tStream_SetPosition(s, 0);\n\trdp_write_header(rdp, s, length, channel_id);\n\n\tif (!rdp_security_stream_out(rdp, s, length, 0, &pad))\n\t\tgoto fail;\n\n\tlength += pad;\n\tStream_SetPosition(s, length);\n\tStream_SealLength(s);\n\n\tif (transport_write(rdp->transport, s) < 0)\n\t\tgoto fail;\n\n\trc = TRUE;\nfail:\n\tStream_Release(s);\n\treturn rc;\n}\n\nBOOL rdp_send_pdu(rdpRdp* rdp, wStream* s, UINT16 type, UINT16 channel_id)\n{\n\tUINT16 length;\n\tUINT32 sec_bytes;\n\tsize_t sec_hold;\n\tUINT32 pad;\n\n\tif (!rdp || !s)\n\t\treturn FALSE;\n\n\tlength = Stream_GetPosition(s);\n\tStream_SetPosition(s, 0);\n\trdp_write_header(rdp, s, length, MCS_GLOBAL_CHANNEL_ID);\n\tsec_bytes = rdp_get_sec_bytes(rdp, 0);\n\tsec_hold = Stream_GetPosition(s);\n\tStream_Seek(s, sec_bytes);\n\trdp_write_share_control_header(s, length - sec_bytes, type, channel_id);\n\tStream_SetPosition(s, sec_hold);\n\n\tif (!rdp_security_stream_out(rdp, s, length, 0, &pad))\n\t\treturn FALSE;\n\n\tlength += pad;\n\tStream_SetPosition(s, length);\n\tStream_SealLength(s);\n\n\tif (transport_write(rdp->transport, s) < 0)\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\nBOOL rdp_send_data_pdu(rdpRdp* rdp, wStream* s, BYTE type, UINT16 channel_id)\n{\n\tBOOL rc = FALSE;\n\tsize_t length;\n\tUINT32 sec_bytes;\n\tsize_t sec_hold;\n\tUINT32 pad;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!rdp)\n\t\tgoto fail;\n\n\tlength = Stream_GetPosition(s);\n\tStream_SetPosition(s, 0);\n\trdp_write_header(rdp, s, length, MCS_GLOBAL_CHANNEL_ID);\n\tsec_bytes = rdp_get_sec_bytes(rdp, 0);\n\tsec_hold = Stream_GetPosition(s);\n\tStream_Seek(s, sec_bytes);\n\trdp_write_share_control_header(s, length - sec_bytes, PDU_TYPE_DATA, channel_id);\n\trdp_write_share_data_header(s, length - sec_bytes, type, rdp->settings->ShareId);\n\tStream_SetPosition(s, sec_hold);\n\n\tif (!rdp_security_stream_out(rdp, s, length, 0, &pad))\n\t\tgoto fail;\n\n\tlength += pad;\n\tStream_SetPosition(s, length);\n\tStream_SealLength(s);\n\tWLog_DBG(TAG, \"%s: sending data (type=0x%x size=%\" PRIuz \" channelId=%\" PRIu16 \")\",\n\t         __FUNCTION__, type, Stream_Length(s), channel_id);\n\n\trdp->outPackets++;\n\tif (transport_write(rdp->transport, s) < 0)\n\t\tgoto fail;\n\n\trc = TRUE;\nfail:\n\tStream_Release(s);\n\treturn rc;\n}\n\nBOOL rdp_send_message_channel_pdu(rdpRdp* rdp, wStream* s, UINT16 sec_flags)\n{\n\tBOOL rc = FALSE;\n\tUINT16 length;\n\tUINT32 pad;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!rdp)\n\t\tgoto fail;\n\n\tlength = Stream_GetPosition(s);\n\tStream_SetPosition(s, 0);\n\trdp_write_header(rdp, s, length, rdp->mcs->messageChannelId);\n\n\tif (!rdp_security_stream_out(rdp, s, length, sec_flags, &pad))\n\t\tgoto fail;\n\n\tlength += pad;\n\tStream_SetPosition(s, length);\n\tStream_SealLength(s);\n\n\tif (transport_write(rdp->transport, s) < 0)\n\t\tgoto fail;\n\n\trc = TRUE;\nfail:\n\tStream_Release(s);\n\treturn rc;\n}\n\nstatic BOOL rdp_recv_server_shutdown_denied_pdu(rdpRdp* rdp, wStream* s)\n{\n\treturn TRUE;\n}\n\nstatic BOOL rdp_recv_server_set_keyboard_indicators_pdu(rdpRdp* rdp, wStream* s)\n{\n\tUINT16 unitId;\n\tUINT16 ledFlags;\n\trdpContext* context = rdp->instance->context;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, unitId);   /* unitId (2 bytes) */\n\tStream_Read_UINT16(s, ledFlags); /* ledFlags (2 bytes) */\n\tIFCALL(context->update->SetKeyboardIndicators, context, ledFlags);\n\treturn TRUE;\n}\n\nstatic BOOL rdp_recv_server_set_keyboard_ime_status_pdu(rdpRdp* rdp, wStream* s)\n{\n\tUINT16 unitId;\n\tUINT32 imeState;\n\tUINT32 imeConvMode;\n\n\tif (!rdp || !rdp->input)\n\t\treturn FALSE;\n\n\tif (Stream_GetRemainingLength(s) < 10)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, unitId);      /* unitId (2 bytes) */\n\tStream_Read_UINT32(s, imeState);    /* imeState (4 bytes) */\n\tStream_Read_UINT32(s, imeConvMode); /* imeConvMode (4 bytes) */\n\tIFCALL(rdp->update->SetKeyboardImeStatus, rdp->context, unitId, imeState, imeConvMode);\n\treturn TRUE;\n}\n\nstatic BOOL rdp_recv_set_error_info_data_pdu(rdpRdp* rdp, wStream* s)\n{\n\tUINT32 errorInfo;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, errorInfo); /* errorInfo (4 bytes) */\n\treturn rdp_set_error_info(rdp, errorInfo);\n}\n\nstatic BOOL rdp_recv_server_auto_reconnect_status_pdu(rdpRdp* rdp, wStream* s)\n{\n\tUINT32 arcStatus;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, arcStatus); /* arcStatus (4 bytes) */\n\tWLog_WARN(TAG, \"AutoReconnectStatus: 0x%08\" PRIX32 \"\", arcStatus);\n\treturn TRUE;\n}\n\nstatic BOOL rdp_recv_server_status_info_pdu(rdpRdp* rdp, wStream* s)\n{\n\tUINT32 statusCode;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, statusCode); /* statusCode (4 bytes) */\n\n\tif (rdp->update->ServerStatusInfo)\n\t\treturn rdp->update->ServerStatusInfo(rdp->context, statusCode);\n\n\treturn TRUE;\n}\n\nstatic BOOL rdp_recv_monitor_layout_pdu(rdpRdp* rdp, wStream* s)\n{\n\tUINT32 index;\n\tUINT32 monitorCount;\n\tMONITOR_DEF* monitor;\n\tMONITOR_DEF* monitorDefArray;\n\tBOOL ret = TRUE;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, monitorCount); /* monitorCount (4 bytes) */\n\n\tif ((Stream_GetRemainingLength(s) / 20) < monitorCount)\n\t\treturn FALSE;\n\n\tmonitorDefArray = (MONITOR_DEF*)calloc(monitorCount, sizeof(MONITOR_DEF));\n\n\tif (!monitorDefArray)\n\t\treturn FALSE;\n\n\tfor (monitor = monitorDefArray, index = 0; index < monitorCount; index++, monitor++)\n\t{\n\t\tStream_Read_UINT32(s, monitor->left);   /* left (4 bytes) */\n\t\tStream_Read_UINT32(s, monitor->top);    /* top (4 bytes) */\n\t\tStream_Read_UINT32(s, monitor->right);  /* right (4 bytes) */\n\t\tStream_Read_UINT32(s, monitor->bottom); /* bottom (4 bytes) */\n\t\tStream_Read_UINT32(s, monitor->flags);  /* flags (4 bytes) */\n\t}\n\n\tIFCALLRET(rdp->update->RemoteMonitors, ret, rdp->context, monitorCount, monitorDefArray);\n\tfree(monitorDefArray);\n\treturn ret;\n}\n\nint rdp_recv_data_pdu(rdpRdp* rdp, wStream* s)\n{\n\tBYTE type;\n\twStream* cs;\n\tUINT16 length;\n\tUINT32 shareId;\n\tBYTE compressedType;\n\tUINT16 compressedLength;\n\n\tif (!rdp_read_share_data_header(s, &length, &type, &shareId, &compressedType,\n\t                                &compressedLength))\n\t{\n\t\tWLog_ERR(TAG, \"rdp_read_share_data_header() failed\");\n\t\treturn -1;\n\t}\n\n\tcs = s;\n\n\tif (compressedType & PACKET_COMPRESSED)\n\t{\n\t\tUINT32 DstSize = 0;\n\t\tBYTE* pDstData = NULL;\n\t\tUINT16 SrcSize = compressedLength - 18;\n\n\t\tif ((compressedLength < 18) || (Stream_GetRemainingLength(s) < SrcSize))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"bulk_decompress: not enough bytes for compressedLength %\" PRIu16 \"\",\n\t\t\t         compressedLength);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (bulk_decompress(rdp->bulk, Stream_Pointer(s), SrcSize, &pDstData, &DstSize,\n\t\t                    compressedType))\n\t\t{\n\t\t\tif (!(cs = StreamPool_Take(rdp->transport->ReceivePool, DstSize)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Couldn't take stream from pool\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tStream_SetPosition(cs, 0);\n\t\t\tStream_Write(cs, pDstData, DstSize);\n\t\t\tStream_SealLength(cs);\n\t\t\tStream_SetPosition(cs, 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tWLog_ERR(TAG, \"bulk_decompress() failed\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tStream_Seek(s, SrcSize);\n\t}\n\n\tWLog_DBG(TAG, \"recv %s Data PDU (0x%02\" PRIX8 \"), length: %\" PRIu16 \"\",\n\t         type < ARRAYSIZE(DATA_PDU_TYPE_STRINGS) ? DATA_PDU_TYPE_STRINGS[type] : \"???\", type,\n\t         length);\n\n\tswitch (type)\n\t{\n\t\tcase DATA_PDU_TYPE_UPDATE:\n\t\t\tif (!update_recv(rdp->update, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"DATA_PDU_TYPE_UPDATE - update_recv() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_CONTROL:\n\t\t\tif (!rdp_recv_server_control_pdu(rdp, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"DATA_PDU_TYPE_CONTROL - rdp_recv_server_control_pdu() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_POINTER:\n\t\t\tif (!update_recv_pointer(rdp->update, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"DATA_PDU_TYPE_POINTER - update_recv_pointer() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_SYNCHRONIZE:\n\t\t\tif (!rdp_recv_synchronize_pdu(rdp, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"DATA_PDU_TYPE_SYNCHRONIZE - rdp_recv_synchronize_pdu() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_PLAY_SOUND:\n\t\t\tif (!update_recv_play_sound(rdp->update, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"DATA_PDU_TYPE_PLAY_SOUND - update_recv_play_sound() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_SHUTDOWN_DENIED:\n\t\t\tif (!rdp_recv_server_shutdown_denied_pdu(rdp, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(\n\t\t\t\t    TAG,\n\t\t\t\t    \"DATA_PDU_TYPE_SHUTDOWN_DENIED - rdp_recv_server_shutdown_denied_pdu() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_SAVE_SESSION_INFO:\n\t\t\tif (!rdp_recv_save_session_info(rdp, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG,\n\t\t\t\t         \"DATA_PDU_TYPE_SAVE_SESSION_INFO - rdp_recv_save_session_info() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_FONT_MAP:\n\t\t\tif (!rdp_recv_font_map_pdu(rdp, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"DATA_PDU_TYPE_FONT_MAP - rdp_recv_font_map_pdu() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_SET_KEYBOARD_INDICATORS:\n\t\t\tif (!rdp_recv_server_set_keyboard_indicators_pdu(rdp, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"DATA_PDU_TYPE_SET_KEYBOARD_INDICATORS - \"\n\t\t\t\t              \"rdp_recv_server_set_keyboard_indicators_pdu() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_SET_KEYBOARD_IME_STATUS:\n\t\t\tif (!rdp_recv_server_set_keyboard_ime_status_pdu(rdp, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"DATA_PDU_TYPE_SET_KEYBOARD_IME_STATUS - \"\n\t\t\t\t              \"rdp_recv_server_set_keyboard_ime_status_pdu() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_SET_ERROR_INFO:\n\t\t\tif (!rdp_recv_set_error_info_data_pdu(rdp, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(\n\t\t\t\t    TAG,\n\t\t\t\t    \"DATA_PDU_TYPE_SET_ERROR_INFO - rdp_recv_set_error_info_data_pdu() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_ARC_STATUS:\n\t\t\tif (!rdp_recv_server_auto_reconnect_status_pdu(rdp, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"DATA_PDU_TYPE_ARC_STATUS - \"\n\t\t\t\t              \"rdp_recv_server_auto_reconnect_status_pdu() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_STATUS_INFO:\n\t\t\tif (!rdp_recv_server_status_info_pdu(rdp, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG,\n\t\t\t\t         \"DATA_PDU_TYPE_STATUS_INFO - rdp_recv_server_status_info_pdu() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_MONITOR_LAYOUT:\n\t\t\tif (!rdp_recv_monitor_layout_pdu(rdp, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG,\n\t\t\t\t         \"DATA_PDU_TYPE_MONITOR_LAYOUT - rdp_recv_monitor_layout_pdu() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\tif (cs != s)\n\t\tStream_Release(cs);\n\n\treturn 0;\nout_fail:\n\n\tif (cs != s)\n\t\tStream_Release(cs);\n\n\treturn -1;\n}\n\nint rdp_recv_message_channel_pdu(rdpRdp* rdp, wStream* s, UINT16 securityFlags)\n{\n\tif (securityFlags & SEC_AUTODETECT_REQ)\n\t{\n\t\t/* Server Auto-Detect Request PDU */\n\t\treturn rdp_recv_autodetect_request_packet(rdp, s);\n\t}\n\n\tif (securityFlags & SEC_AUTODETECT_RSP)\n\t{\n\t\t/* Client Auto-Detect Response PDU */\n\t\treturn rdp_recv_autodetect_response_packet(rdp, s);\n\t}\n\n\tif (securityFlags & SEC_HEARTBEAT)\n\t{\n\t\t/* Heartbeat PDU */\n\t\treturn rdp_recv_heartbeat_packet(rdp, s);\n\t}\n\n\tif (securityFlags & SEC_TRANSPORT_REQ)\n\t{\n\t\t/* Initiate Multitransport Request PDU */\n\t\treturn rdp_recv_multitransport_packet(rdp, s);\n\t}\n\n\treturn -1;\n}\n\nint rdp_recv_out_of_sequence_pdu(rdpRdp* rdp, wStream* s)\n{\n\tUINT16 type;\n\tUINT16 length;\n\tUINT16 channelId;\n\n\tif (!rdp_read_share_control_header(s, &length, &type, &channelId))\n\t\treturn -1;\n\n\tif (type == PDU_TYPE_DATA)\n\t{\n\t\treturn rdp_recv_data_pdu(rdp, s);\n\t}\n\telse if (type == PDU_TYPE_SERVER_REDIRECTION)\n\t{\n\t\treturn rdp_recv_enhanced_security_redirection_packet(rdp, s);\n\t}\n\telse if (type == PDU_TYPE_FLOW_RESPONSE || type == PDU_TYPE_FLOW_STOP ||\n\t         type == PDU_TYPE_FLOW_TEST)\n\t{\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\treturn -1;\n\t}\n}\n\nvoid rdp_read_flow_control_pdu(wStream* s, UINT16* type)\n{\n\t/*\n\t * Read flow control PDU - documented in FlowPDU section in T.128\n\t * http://www.itu.int/rec/T-REC-T.128-199802-S/en\n\t * The specification for the PDU has pad8bits listed BEFORE pduTypeFlow.\n\t * However, so far pad8bits has always been observed to arrive AFTER pduTypeFlow.\n\t * Switched the order of these two fields to match this observation.\n\t */\n\tUINT8 pduType;\n\tStream_Read_UINT8(s, pduType); /* pduTypeFlow */\n\t*type = pduType;\n\tStream_Seek_UINT8(s);  /* pad8bits */\n\tStream_Seek_UINT8(s);  /* flowIdentifier */\n\tStream_Seek_UINT8(s);  /* flowNumber */\n\tStream_Seek_UINT16(s); /* pduSource */\n}\n\n/**\n * Decrypt an RDP packet.\\n\n * @param rdp RDP module\n * @param s stream\n * @param length int\n */\n\nBOOL rdp_decrypt(rdpRdp* rdp, wStream* s, UINT16* pLength, UINT16 securityFlags)\n{\n\tBYTE cmac[8];\n\tBYTE wmac[8];\n\tBOOL status;\n\tINT32 length;\n\n\tif (!rdp || !s || !pLength)\n\t\treturn FALSE;\n\n\tlength = *pLength;\n\tif (rdp->settings->EncryptionMethods == ENCRYPTION_METHOD_FIPS)\n\t{\n\t\tUINT16 len;\n\t\tBYTE version, pad;\n\t\tBYTE* sig;\n\t\tINT64 padLength;\n\n\t\tif (Stream_GetRemainingLength(s) < 12)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, len);    /* 0x10 */\n\t\tStream_Read_UINT8(s, version); /* 0x1 */\n\t\tStream_Read_UINT8(s, pad);\n\t\tsig = Stream_Pointer(s);\n\t\tStream_Seek(s, 8); /* signature */\n\t\tlength -= 12;\n\t\tpadLength = length - pad;\n\n\t\tif ((length <= 0) || (padLength <= 0))\n\t\t\treturn FALSE;\n\n\t\tif (!security_fips_decrypt(Stream_Pointer(s), length, rdp))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"FATAL: cannot decrypt\");\n\t\t\treturn FALSE; /* TODO */\n\t\t}\n\n\t\tif (!security_fips_check_signature(Stream_Pointer(s), length - pad, sig, rdp))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"FATAL: invalid packet signature\");\n\t\t\treturn FALSE; /* TODO */\n\t\t}\n\n\t\tStream_SetLength(s, Stream_Length(s) - pad);\n\t\t*pLength = padLength;\n\t\treturn TRUE;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < sizeof(wmac))\n\t\treturn FALSE;\n\n\tStream_Read(s, wmac, sizeof(wmac));\n\tlength -= sizeof(wmac);\n\n\tif (length <= 0)\n\t\treturn FALSE;\n\n\tif (!security_decrypt(Stream_Pointer(s), length, rdp))\n\t\treturn FALSE;\n\n\tif (securityFlags & SEC_SECURE_CHECKSUM)\n\t\tstatus = security_salted_mac_signature(rdp, Stream_Pointer(s), length, FALSE, cmac);\n\telse\n\t\tstatus = security_mac_signature(rdp, Stream_Pointer(s), length, cmac);\n\n\tif (!status)\n\t\treturn FALSE;\n\n\tif (memcmp(wmac, cmac, sizeof(wmac)) != 0)\n\t{\n\t\tWLog_ERR(TAG, \"WARNING: invalid packet signature\");\n\t\t/*\n\t\t * Because Standard RDP Security is totally broken,\n\t\t * and cannot protect against MITM, don't treat signature\n\t\t * verification failure as critical. This at least enables\n\t\t * us to work with broken RDP clients and servers that\n\t\t * generate invalid signatures.\n\t\t */\n\t\t// return FALSE;\n\t}\n\n\t*pLength = length;\n\treturn TRUE;\n}\n\nstatic const char* pdu_type_to_str(UINT16 pduType)\n{\n\tstatic char buffer[1024] = { 0 };\n\tswitch (pduType)\n\t{\n\t\tcase PDU_TYPE_DEMAND_ACTIVE:\n\t\t\treturn \"PDU_TYPE_DEMAND_ACTIVE\";\n\t\tcase PDU_TYPE_CONFIRM_ACTIVE:\n\t\t\treturn \"PDU_TYPE_CONFIRM_ACTIVE\";\n\t\tcase PDU_TYPE_DEACTIVATE_ALL:\n\t\t\treturn \"PDU_TYPE_DEACTIVATE_ALL\";\n\t\tcase PDU_TYPE_DATA:\n\t\t\treturn \"PDU_TYPE_DATA\";\n\t\tcase PDU_TYPE_SERVER_REDIRECTION:\n\t\t\treturn \"PDU_TYPE_SERVER_REDIRECTION\";\n\t\tcase PDU_TYPE_FLOW_TEST:\n\t\t\treturn \"PDU_TYPE_FLOW_TEST\";\n\t\tcase PDU_TYPE_FLOW_RESPONSE:\n\t\t\treturn \"PDU_TYPE_FLOW_RESPONSE\";\n\t\tcase PDU_TYPE_FLOW_STOP:\n\t\t\treturn \"PDU_TYPE_FLOW_STOP\";\n\t\tdefault:\n\t\t\t_snprintf(buffer, sizeof(buffer), \"UNKNOWN %04\" PRIx16, pduType);\n\t\t\treturn buffer;\n\t}\n}\n\n/**\n * Process an RDP packet.\\n\n * @param rdp RDP module\n * @param s stream\n */\n\nstatic int rdp_recv_tpkt_pdu(rdpRdp* rdp, wStream* s)\n{\n\tint rc = 0;\n\tUINT16 length;\n\tUINT16 pduType;\n\tUINT16 pduLength;\n\tUINT16 pduSource;\n\tUINT16 channelId = 0;\n\tUINT16 securityFlags = 0;\n\n\tif (!rdp_read_header(rdp, s, &length, &channelId))\n\t{\n\t\tWLog_ERR(TAG, \"Incorrect RDP header.\");\n\t\treturn -1;\n\t}\n\n\tif (freerdp_shall_disconnect(rdp->instance))\n\t\treturn 0;\n\n\tif (rdp->autodetect->bandwidthMeasureStarted)\n\t{\n\t\trdp->autodetect->bandwidthMeasureByteCount += length;\n\t}\n\n\tif (rdp->settings->UseRdpSecurityLayer)\n\t{\n\t\tif (!rdp_read_security_header(s, &securityFlags, &length))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"rdp_recv_tpkt_pdu: rdp_read_security_header() fail\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (securityFlags & (SEC_ENCRYPT | SEC_REDIRECTION_PKT))\n\t\t{\n\t\t\tif (!rdp_decrypt(rdp, s, &length, securityFlags))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdp_decrypt failed\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tif (securityFlags & SEC_REDIRECTION_PKT)\n\t\t{\n\t\t\t/*\n\t\t\t * [MS-RDPBCGR] 2.2.13.2.1\n\t\t\t *  - no share control header, nor the 2 byte pad\n\t\t\t */\n\t\t\tStream_Rewind(s, 2);\n\t\t\trdp->inPackets++;\n\n\t\t\trc = rdp_recv_enhanced_security_redirection_packet(rdp, s);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (channelId == MCS_GLOBAL_CHANNEL_ID)\n\t{\n\t\twhile (Stream_GetRemainingLength(s) > 3)\n\t\t{\n\t\t\tsize_t startheader, endheader, start, end, diff, headerdiff;\n\n\t\t\tstartheader = Stream_GetPosition(s);\n\t\t\tif (!rdp_read_share_control_header(s, &pduLength, &pduType, &pduSource))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdp_recv_tpkt_pdu: rdp_read_share_control_header() fail\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tstart = endheader = Stream_GetPosition(s);\n\t\t\theaderdiff = endheader - startheader;\n\t\t\tif (pduLength < headerdiff)\n\t\t\t{\n\t\t\t\tWLog_ERR(\n\t\t\t\t    TAG,\n\t\t\t\t    \"rdp_recv_tpkt_pdu: rdp_read_share_control_header() invalid pduLength %\" PRIu16,\n\t\t\t\t    pduLength);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tpduLength -= headerdiff;\n\n\t\t\trdp->settings->PduSource = pduSource;\n\t\t\trdp->inPackets++;\n\n\t\t\tswitch (pduType)\n\t\t\t{\n\t\t\t\tcase PDU_TYPE_DATA:\n\t\t\t\t\trc = rdp_recv_data_pdu(rdp, s);\n\t\t\t\t\tif (rc < 0)\n\t\t\t\t\t\treturn rc;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDU_TYPE_DEACTIVATE_ALL:\n\t\t\t\t\tif (!rdp_recv_deactivate_all(rdp, s))\n\t\t\t\t\t{\n\t\t\t\t\t\tWLog_ERR(TAG, \"rdp_recv_tpkt_pdu: rdp_recv_deactivate_all() fail\");\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDU_TYPE_SERVER_REDIRECTION:\n\t\t\t\t\treturn rdp_recv_enhanced_security_redirection_packet(rdp, s);\n\n\t\t\t\tcase PDU_TYPE_FLOW_RESPONSE:\n\t\t\t\tcase PDU_TYPE_FLOW_STOP:\n\t\t\t\tcase PDU_TYPE_FLOW_TEST:\n\t\t\t\t\tWLog_DBG(TAG, \"flow message 0x%04\" PRIX16 \"\", pduType);\n\t\t\t\t\t/* http://msdn.microsoft.com/en-us/library/cc240576.aspx */\n\t\t\t\t\tif (!Stream_SafeSeek(s, pduLength))\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tWLog_ERR(TAG, \"incorrect PDU type: 0x%04\" PRIX16 \"\", pduType);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tend = Stream_GetPosition(s);\n\t\t\tdiff = end - start;\n\t\t\tif (diff != pduLength)\n\t\t\t{\n\t\t\t\tWLog_WARN(TAG,\n\t\t\t\t          \"pduType %s not properly parsed, %\" PRIdz\n\t\t\t\t          \" bytes remaining unhandled. Skipping.\",\n\t\t\t\t          pdu_type_to_str(pduType), diff);\n\t\t\t\tif (!Stream_SafeSeek(s, pduLength))\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\telse if (rdp->mcs->messageChannelId && (channelId == rdp->mcs->messageChannelId))\n\t{\n\t\tif (!rdp->settings->UseRdpSecurityLayer)\n\t\t\tif (!rdp_read_security_header(s, &securityFlags, NULL))\n\t\t\t\treturn -1;\n\t\trdp->inPackets++;\n\t\trc = rdp_recv_message_channel_pdu(rdp, s, securityFlags);\n\t}\n\telse\n\t{\n\t\trdp->inPackets++;\n\n\t\tif (!freerdp_channel_process(rdp->instance, s, channelId, length))\n\t\t\treturn -1;\n\t}\n\nout:\n\tif (!tpkt_ensure_stream_consumed(s, length))\n\t\treturn -1;\n\treturn rc;\n}\n\nstatic int rdp_recv_fastpath_pdu(rdpRdp* rdp, wStream* s)\n{\n\tUINT16 length;\n\trdpFastPath* fastpath;\n\tfastpath = rdp->fastpath;\n\n\tif (!fastpath_read_header_rdp(fastpath, s, &length))\n\t{\n\t\tWLog_ERR(TAG, \"rdp_recv_fastpath_pdu: fastpath_read_header_rdp() fail\");\n\t\treturn -1;\n\t}\n\n\tif ((length == 0) || (length > Stream_GetRemainingLength(s)))\n\t{\n\t\tWLog_ERR(TAG, \"incorrect FastPath PDU header length %\" PRIu16 \"\", length);\n\t\treturn -1;\n\t}\n\n\tif (rdp->autodetect->bandwidthMeasureStarted)\n\t{\n\t\trdp->autodetect->bandwidthMeasureByteCount += length;\n\t}\n\n\tif (fastpath->encryptionFlags & FASTPATH_OUTPUT_ENCRYPTED)\n\t{\n\t\tUINT16 flags =\n\t\t    (fastpath->encryptionFlags & FASTPATH_OUTPUT_SECURE_CHECKSUM) ? SEC_SECURE_CHECKSUM : 0;\n\n\t\tif (!rdp_decrypt(rdp, s, &length, flags))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"rdp_recv_fastpath_pdu: rdp_decrypt() fail\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn fastpath_recv_updates(rdp->fastpath, s);\n}\n\nstatic int rdp_recv_pdu(rdpRdp* rdp, wStream* s)\n{\n\tif (tpkt_verify_header(s))\n\t\treturn rdp_recv_tpkt_pdu(rdp, s);\n\telse\n\t\treturn rdp_recv_fastpath_pdu(rdp, s);\n}\n\nint rdp_recv_callback(rdpTransport* transport, wStream* s, void* extra)\n{\n\tint status = 0;\n\trdpRdp* rdp = (rdpRdp*)extra;\n\n\t/*\n\t * At any point in the connection sequence between when all\n\t * MCS channels have been joined and when the RDP connection\n\t * enters the active state, an auto-detect PDU can be received\n\t * on the MCS message channel.\n\t */\n\tif ((rdp->state > CONNECTION_STATE_MCS_CHANNEL_JOIN) && (rdp->state < CONNECTION_STATE_ACTIVE))\n\t{\n\t\tif (rdp_client_connect_auto_detect(rdp, s))\n\t\t\treturn 0;\n\t}\n\n\tswitch (rdp->state)\n\t{\n\t\tcase CONNECTION_STATE_NLA:\n\t\t\tif (nla_get_state(rdp->nla) < NLA_STATE_AUTH_INFO)\n\t\t\t{\n\t\t\t\tif (nla_recv_pdu(rdp->nla, s) < 1)\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG, \"%s: %s - nla_recv_pdu() fail\", __FUNCTION__,\n\t\t\t\t\t         rdp_server_connection_state_string(rdp->state));\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (nla_get_state(rdp->nla) == NLA_STATE_POST_NEGO)\n\t\t\t{\n\t\t\t\tnego_recv(rdp->transport, s, (void*)rdp->nego);\n\n\t\t\t\tif (nego_get_state(rdp->nego) != NEGO_STATE_FINAL)\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG, \"%s: %s - nego_recv() fail\", __FUNCTION__,\n\t\t\t\t\t         rdp_server_connection_state_string(rdp->state));\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tif (!nla_set_state(rdp->nla, NLA_STATE_FINAL))\n\t\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (nla_get_state(rdp->nla) == NLA_STATE_AUTH_INFO)\n\t\t\t{\n\t\t\t\ttransport_set_nla_mode(rdp->transport, FALSE);\n\n\t\t\t\tif (rdp->settings->VmConnectMode)\n\t\t\t\t{\n\t\t\t\t\tif (!nego_set_state(rdp->nego, NEGO_STATE_NLA))\n\t\t\t\t\t\treturn -1;\n\n\t\t\t\t\tif (!nego_set_requested_protocols(rdp->nego, PROTOCOL_HYBRID | PROTOCOL_SSL))\n\t\t\t\t\t\treturn -1;\n\n\t\t\t\t\tnego_send_negotiation_request(rdp->nego);\n\n\t\t\t\t\tif (!nla_set_state(rdp->nla, NLA_STATE_POST_NEGO))\n\t\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!nla_set_state(rdp->nla, NLA_STATE_FINAL))\n\t\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (nla_get_state(rdp->nla) == NLA_STATE_FINAL)\n\t\t\t{\n\t\t\t\tnla_free(rdp->nla);\n\t\t\t\trdp->nla = NULL;\n\n\t\t\t\tif (!mcs_client_begin(rdp->mcs))\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG, \"%s: %s - mcs_client_begin() fail\", __FUNCTION__,\n\t\t\t\t\t         rdp_server_connection_state_string(rdp->state));\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_CONNECT:\n\t\t\tif (!mcs_recv_connect_response(rdp->mcs, s))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"mcs_recv_connect_response failure\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (!mcs_send_erect_domain_request(rdp->mcs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"mcs_send_erect_domain_request failure\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (!mcs_send_attach_user_request(rdp->mcs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"mcs_send_attach_user_request failure\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\trdp_client_transition_to_state(rdp, CONNECTION_STATE_MCS_ATTACH_USER);\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_ATTACH_USER:\n\t\t\tif (!mcs_recv_attach_user_confirm(rdp->mcs, s))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"mcs_recv_attach_user_confirm failure\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (!mcs_send_channel_join_request(rdp->mcs, rdp->mcs->userId))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"mcs_send_channel_join_request failure\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\trdp_client_transition_to_state(rdp, CONNECTION_STATE_MCS_CHANNEL_JOIN);\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_CHANNEL_JOIN:\n\t\t\tif (!rdp_client_connect_mcs_channel_join_confirm(rdp, s))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG,\n\t\t\t\t         \"%s: %s - \"\n\t\t\t\t         \"rdp_client_connect_mcs_channel_join_confirm() fail\",\n\t\t\t\t         __FUNCTION__, rdp_server_connection_state_string(rdp->state));\n\t\t\t\tstatus = -1;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_LICENSING:\n\t\t\tstatus = rdp_client_connect_license(rdp, s);\n\n\t\t\tif (status < 0)\n\t\t\t\tWLog_DBG(TAG, \"%s: %s - rdp_client_connect_license() - %i\", __FUNCTION__,\n\t\t\t\t         rdp_server_connection_state_string(rdp->state), status);\n\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_CAPABILITIES_EXCHANGE:\n\t\t\tstatus = rdp_client_connect_demand_active(rdp, s);\n\n\t\t\tif (status < 0)\n\t\t\t\tWLog_DBG(TAG,\n\t\t\t\t         \"%s: %s - \"\n\t\t\t\t         \"rdp_client_connect_demand_active() - %i\",\n\t\t\t\t         __FUNCTION__, rdp_server_connection_state_string(rdp->state), status);\n\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_FINALIZATION:\n\t\t\tstatus = rdp_recv_pdu(rdp, s);\n\n\t\t\tif ((status >= 0) && (rdp->finalize_sc_pdus == FINALIZE_SC_COMPLETE))\n\t\t\t{\n\t\t\t\tActivatedEventArgs activatedEvent;\n\t\t\t\trdpContext* context = rdp->context;\n\t\t\t\trdp_client_transition_to_state(rdp, CONNECTION_STATE_ACTIVE);\n\t\t\t\tEventArgsInit(&activatedEvent, \"libfreerdp\");\n\t\t\t\tactivatedEvent.firstActivation = !rdp->deactivation_reactivation;\n\t\t\t\tPubSub_OnActivated(context->pubSub, context, &activatedEvent);\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\tif (status < 0)\n\t\t\t\tWLog_DBG(TAG, \"%s: %s - rdp_recv_pdu() - %i\", __FUNCTION__,\n\t\t\t\t         rdp_server_connection_state_string(rdp->state), status);\n\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_ACTIVE:\n\t\t\tstatus = rdp_recv_pdu(rdp, s);\n\n\t\t\tif (status < 0)\n\t\t\t\tWLog_DBG(TAG, \"%s: %s - rdp_recv_pdu() - %i\", __FUNCTION__,\n\t\t\t\t         rdp_server_connection_state_string(rdp->state), status);\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_ERR(TAG, \"%s: %s state %d\", __FUNCTION__,\n\t\t\t         rdp_server_connection_state_string(rdp->state), rdp->state);\n\t\t\tstatus = -1;\n\t\t\tbreak;\n\t}\n\n\treturn status;\n}\n\nBOOL rdp_send_channel_data(rdpRdp* rdp, UINT16 channelId, const BYTE* data, size_t size)\n{\n\treturn freerdp_channel_send(rdp, channelId, data, size);\n}\n\nBOOL rdp_send_error_info(rdpRdp* rdp)\n{\n\twStream* s;\n\tBOOL status;\n\n\tif (rdp->errorInfo == ERRINFO_SUCCESS)\n\t\treturn TRUE;\n\n\ts = rdp_data_pdu_init(rdp);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_Write_UINT32(s, rdp->errorInfo); /* error id (4 bytes) */\n\tstatus = rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_SET_ERROR_INFO, 0);\n\treturn status;\n}\n\nint rdp_check_fds(rdpRdp* rdp)\n{\n\tint status;\n\trdpTransport* transport = rdp->transport;\n\n\tif (transport->tsg)\n\t{\n\t\trdpTsg* tsg = transport->tsg;\n\n\t\tif (!tsg_check_event_handles(tsg))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"rdp_check_fds: tsg_check_event_handles()\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (tsg_get_state(tsg) != TSG_STATE_PIPE_CREATED)\n\t\t\treturn 1;\n\t}\n\n\tstatus = transport_check_fds(transport);\n\n\tif (status == 1)\n\t{\n\t\tif (!rdp_client_redirect(rdp)) /* session redirection */\n\t\t\treturn -1;\n\t}\n\n\tif (status < 0)\n\t\tWLog_DBG(TAG, \"transport_check_fds() - %i\", status);\n\n\treturn status;\n}\n\nBOOL freerdp_get_stats(rdpRdp* rdp, UINT64* inBytes, UINT64* outBytes, UINT64* inPackets,\n                       UINT64* outPackets)\n{\n\tif (!rdp)\n\t\treturn FALSE;\n\n\tif (inBytes)\n\t\t*inBytes = rdp->inBytes;\n\tif (outBytes)\n\t\t*outBytes = rdp->outBytes;\n\tif (inPackets)\n\t\t*inPackets = rdp->inPackets;\n\tif (outPackets)\n\t\t*outPackets = rdp->outPackets;\n\n\treturn TRUE;\n}\n\n/**\n * Instantiate new RDP module.\n * @return new RDP module\n */\n\nrdpRdp* rdp_new(rdpContext* context)\n{\n\trdpRdp* rdp;\n\tDWORD flags;\n\tBOOL newSettings = FALSE;\n\trdp = (rdpRdp*)calloc(1, sizeof(rdpRdp));\n\n\tif (!rdp)\n\t\treturn NULL;\n\n\trdp->context = context;\n\trdp->instance = context->instance;\n\tflags = 0;\n\n\tif (context->ServerMode)\n\t\tflags |= FREERDP_SETTINGS_SERVER_MODE;\n\n\tif (!context->settings)\n\t{\n\t\tcontext->settings = freerdp_settings_new(flags);\n\n\t\tif (!context->settings)\n\t\t\tgoto out_free;\n\n\t\tnewSettings = TRUE;\n\t}\n\n\trdp->settings = context->settings;\n\n\tif (context->instance)\n\t{\n\t\trdp->settings->instance = context->instance;\n\t\tcontext->instance->settings = rdp->settings;\n\t}\n\telse if (context->peer)\n\t{\n\t\trdp->settings->instance = context->peer;\n\t\tcontext->peer->settings = rdp->settings;\n\t}\n\n\trdp->transport = transport_new(context);\n\n\tif (!rdp->transport)\n\t\tgoto out_free_settings;\n\n\trdp->license = license_new(rdp);\n\n\tif (!rdp->license)\n\t\tgoto out_free_transport;\n\n\trdp->input = input_new(rdp);\n\n\tif (!rdp->input)\n\t\tgoto out_free_license;\n\n\trdp->update = update_new(rdp);\n\n\tif (!rdp->update)\n\t\tgoto out_free_input;\n\n\trdp->fastpath = fastpath_new(rdp);\n\n\tif (!rdp->fastpath)\n\t\tgoto out_free_update;\n\n\trdp->nego = nego_new(rdp->transport);\n\n\tif (!rdp->nego)\n\t\tgoto out_free_fastpath;\n\n\trdp->mcs = mcs_new(rdp->transport);\n\n\tif (!rdp->mcs)\n\t\tgoto out_free_nego;\n\n\trdp->redirection = redirection_new();\n\n\tif (!rdp->redirection)\n\t\tgoto out_free_mcs;\n\n\trdp->autodetect = autodetect_new();\n\n\tif (!rdp->autodetect)\n\t\tgoto out_free_redirection;\n\n\trdp->heartbeat = heartbeat_new();\n\n\tif (!rdp->heartbeat)\n\t\tgoto out_free_autodetect;\n\n\trdp->multitransport = multitransport_new();\n\n\tif (!rdp->multitransport)\n\t\tgoto out_free_heartbeat;\n\n\trdp->bulk = bulk_new(context);\n\n\tif (!rdp->bulk)\n\t\tgoto out_free_multitransport;\n\n\treturn rdp;\nout_free_multitransport:\n\tmultitransport_free(rdp->multitransport);\nout_free_heartbeat:\n\theartbeat_free(rdp->heartbeat);\nout_free_autodetect:\n\tautodetect_free(rdp->autodetect);\nout_free_redirection:\n\tredirection_free(rdp->redirection);\nout_free_mcs:\n\tmcs_free(rdp->mcs);\nout_free_nego:\n\tnego_free(rdp->nego);\nout_free_fastpath:\n\tfastpath_free(rdp->fastpath);\nout_free_update:\n\tupdate_free(rdp->update);\nout_free_input:\n\tinput_free(rdp->input);\nout_free_license:\n\tlicense_free(rdp->license);\nout_free_transport:\n\ttransport_free(rdp->transport);\nout_free_settings:\n\n\tif (newSettings)\n\t\tfreerdp_settings_free(rdp->settings);\n\nout_free:\n\tfree(rdp);\n\treturn NULL;\n}\n\nvoid rdp_reset(rdpRdp* rdp)\n{\n\trdpContext* context;\n\trdpSettings* settings;\n\tcontext = rdp->context;\n\tsettings = rdp->settings;\n\tbulk_reset(rdp->bulk);\n\n\tif (rdp->rc4_decrypt_key)\n\t{\n\t\twinpr_RC4_Free(rdp->rc4_decrypt_key);\n\t\trdp->rc4_decrypt_key = NULL;\n\t}\n\n\tif (rdp->rc4_encrypt_key)\n\t{\n\t\twinpr_RC4_Free(rdp->rc4_encrypt_key);\n\t\trdp->rc4_encrypt_key = NULL;\n\t}\n\n\tif (rdp->fips_encrypt)\n\t{\n\t\twinpr_Cipher_Free(rdp->fips_encrypt);\n\t\trdp->fips_encrypt = NULL;\n\t}\n\n\tif (rdp->fips_decrypt)\n\t{\n\t\twinpr_Cipher_Free(rdp->fips_decrypt);\n\t\trdp->fips_decrypt = NULL;\n\t}\n\n\tif (settings->ServerRandom)\n\t{\n\t\tfree(settings->ServerRandom);\n\t\tsettings->ServerRandom = NULL;\n\t\tsettings->ServerRandomLength = 0;\n\t}\n\n\tif (settings->ServerCertificate)\n\t{\n\t\tfree(settings->ServerCertificate);\n\t\tsettings->ServerCertificate = NULL;\n\t}\n\n\tif (settings->ClientAddress)\n\t{\n\t\tfree(settings->ClientAddress);\n\t\tsettings->ClientAddress = NULL;\n\t}\n\n\tmcs_free(rdp->mcs);\n\tnego_free(rdp->nego);\n\tlicense_free(rdp->license);\n\ttransport_free(rdp->transport);\n\tfastpath_free(rdp->fastpath);\n\trdp->transport = transport_new(context);\n\trdp->license = license_new(rdp);\n\trdp->nego = nego_new(rdp->transport);\n\trdp->mcs = mcs_new(rdp->transport);\n\trdp->fastpath = fastpath_new(rdp);\n\trdp->transport->layer = TRANSPORT_LAYER_TCP;\n\trdp->errorInfo = 0;\n\trdp->deactivation_reactivation = 0;\n\trdp->finalize_sc_pdus = 0;\n}\n\n/**\n * Free RDP module.\n * @param rdp RDP module to be freed\n */\n\nvoid rdp_free(rdpRdp* rdp)\n{\n\tif (rdp)\n\t{\n\t\twinpr_RC4_Free(rdp->rc4_decrypt_key);\n\t\twinpr_RC4_Free(rdp->rc4_encrypt_key);\n\t\twinpr_Cipher_Free(rdp->fips_encrypt);\n\t\twinpr_Cipher_Free(rdp->fips_decrypt);\n\t\tfreerdp_settings_free(rdp->settings);\n\t\ttransport_free(rdp->transport);\n\t\tlicense_free(rdp->license);\n\t\tinput_free(rdp->input);\n\t\tupdate_free(rdp->update);\n\t\tfastpath_free(rdp->fastpath);\n\t\tnego_free(rdp->nego);\n\t\tmcs_free(rdp->mcs);\n\t\tnla_free(rdp->nla);\n\t\tredirection_free(rdp->redirection);\n\t\tautodetect_free(rdp->autodetect);\n\t\theartbeat_free(rdp->heartbeat);\n\t\tmultitransport_free(rdp->multitransport);\n\t\tbulk_free(rdp->bulk);\n\t\tfree(rdp);\n\t}\n}\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * RDP Core\n *\n * Copyright 2011 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2014 DI (FH) Martin Haimberger <martin.haimberger@thincast.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef FREERDP_LIB_CORE_RDP_H\n#define FREERDP_LIB_CORE_RDP_H\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"nla.h\"\n#include \"mcs.h\"\n#include \"tpkt.h\"\n#include \"bulk.h\"\n#include \"fastpath.h\"\n#include \"tpdu.h\"\n#include \"nego.h\"\n#include \"input.h\"\n#include \"update.h\"\n#include \"license.h\"\n#include \"errinfo.h\"\n#include \"autodetect.h\"\n#include \"heartbeat.h\"\n#include \"multitransport.h\"\n#include \"security.h\"\n#include \"transport.h\"\n#include \"connection.h\"\n#include \"redirection.h\"\n#include \"capabilities.h\"\n#include \"channels.h\"\n\n#include <freerdp/freerdp.h>\n#include <freerdp/settings.h>\n#include <freerdp/log.h>\n#include <freerdp/api.h>\n\n#include <winpr/stream.h>\n#include <winpr/crypto.h>\n\n/* Security Header Flags */\n#define SEC_EXCHANGE_PKT 0x0001\n#define SEC_TRANSPORT_REQ 0x0002\n#define SEC_TRANSPORT_RSP 0x0004\n#define SEC_ENCRYPT 0x0008\n#define SEC_RESET_SEQNO 0x0010\n#define SEC_IGNORE_SEQNO 0x0020\n#define SEC_INFO_PKT 0x0040\n#define SEC_LICENSE_PKT 0x0080\n#define SEC_LICENSE_ENCRYPT_CS 0x0200\n#define SEC_LICENSE_ENCRYPT_SC 0x0200\n#define SEC_REDIRECTION_PKT 0x0400\n#define SEC_SECURE_CHECKSUM 0x0800\n#define SEC_AUTODETECT_REQ 0x1000\n#define SEC_AUTODETECT_RSP 0x2000\n#define SEC_HEARTBEAT 0x4000\n#define SEC_FLAGSHI_VALID 0x8000\n\n#define SEC_PKT_CS_MASK (SEC_EXCHANGE_PKT | SEC_INFO_PKT)\n#define SEC_PKT_SC_MASK (SEC_LICENSE_PKT | SEC_REDIRECTION_PKT)\n#define SEC_PKT_MASK (SEC_PKT_CS_MASK | SEC_PKT_SC_MASK)\n\n#define RDP_SECURITY_HEADER_LENGTH 4\n#define RDP_SHARE_CONTROL_HEADER_LENGTH 6\n#define RDP_SHARE_DATA_HEADER_LENGTH 12\n#define RDP_PACKET_HEADER_MAX_LENGTH (TPDU_DATA_LENGTH + MCS_SEND_DATA_HEADER_MAX_LENGTH)\n\n#define PDU_TYPE_DEMAND_ACTIVE 0x1\n#define PDU_TYPE_CONFIRM_ACTIVE 0x3\n#define PDU_TYPE_DEACTIVATE_ALL 0x6\n#define PDU_TYPE_DATA 0x7\n#define PDU_TYPE_SERVER_REDIRECTION 0xA\n\n#define PDU_TYPE_FLOW_TEST 0x41\n#define PDU_TYPE_FLOW_RESPONSE 0x42\n#define PDU_TYPE_FLOW_STOP 0x43\n\n#define FINALIZE_SC_SYNCHRONIZE_PDU 0x01\n#define FINALIZE_SC_CONTROL_COOPERATE_PDU 0x02\n#define FINALIZE_SC_CONTROL_GRANTED_PDU 0x04\n#define FINALIZE_SC_FONT_MAP_PDU 0x08\n#define FINALIZE_SC_COMPLETE 0x0F\n\n/* Data PDU Types */\n#define DATA_PDU_TYPE_UPDATE 0x02\n#define DATA_PDU_TYPE_CONTROL 0x14\n#define DATA_PDU_TYPE_POINTER 0x1B\n#define DATA_PDU_TYPE_INPUT 0x1C\n#define DATA_PDU_TYPE_SYNCHRONIZE 0x1F\n#define DATA_PDU_TYPE_REFRESH_RECT 0x21\n#define DATA_PDU_TYPE_PLAY_SOUND 0x22\n#define DATA_PDU_TYPE_SUPPRESS_OUTPUT 0x23\n#define DATA_PDU_TYPE_SHUTDOWN_REQUEST 0x24\n#define DATA_PDU_TYPE_SHUTDOWN_DENIED 0x25\n#define DATA_PDU_TYPE_SAVE_SESSION_INFO 0x26\n#define DATA_PDU_TYPE_FONT_LIST 0x27\n#define DATA_PDU_TYPE_FONT_MAP 0x28\n#define DATA_PDU_TYPE_SET_KEYBOARD_INDICATORS 0x29\n#define DATA_PDU_TYPE_BITMAP_CACHE_PERSISTENT_LIST 0x2B\n#define DATA_PDU_TYPE_BITMAP_CACHE_ERROR 0x2C\n#define DATA_PDU_TYPE_SET_KEYBOARD_IME_STATUS 0x2D\n#define DATA_PDU_TYPE_OFFSCREEN_CACHE_ERROR 0x2E\n#define DATA_PDU_TYPE_SET_ERROR_INFO 0x2F\n#define DATA_PDU_TYPE_DRAW_NINEGRID_ERROR 0x30\n#define DATA_PDU_TYPE_DRAW_GDIPLUS_ERROR 0x31\n#define DATA_PDU_TYPE_ARC_STATUS 0x32\n#define DATA_PDU_TYPE_STATUS_INFO 0x36\n#define DATA_PDU_TYPE_MONITOR_LAYOUT 0x37\n#define DATA_PDU_TYPE_FRAME_ACKNOWLEDGE 0x38\n\n/* Stream Identifiers */\n#define STREAM_UNDEFINED 0x00\n#define STREAM_LOW 0x01\n#define STREAM_MED 0x02\n#define STREAM_HI 0x04\n\nstruct rdp_rdp\n{\n\tint state;\n\tfreerdp* instance;\n\trdpContext* context;\n\trdpNla* nla;\n\trdpMcs* mcs;\n\trdpNego* nego;\n\trdpBulk* bulk;\n\trdpInput* input;\n\trdpUpdate* update;\n\trdpFastPath* fastpath;\n\trdpLicense* license;\n\trdpRedirection* redirection;\n\trdpSettings* settings;\n\trdpTransport* transport;\n\trdpAutoDetect* autodetect;\n\trdpHeartbeat* heartbeat;\n\trdpMultitransport* multitransport;\n\tWINPR_RC4_CTX* rc4_decrypt_key;\n\tint decrypt_use_count;\n\tint decrypt_checksum_use_count;\n\tWINPR_RC4_CTX* rc4_encrypt_key;\n\tint encrypt_use_count;\n\tint encrypt_checksum_use_count;\n\tWINPR_CIPHER_CTX* fips_encrypt;\n\tWINPR_CIPHER_CTX* fips_decrypt;\n\tUINT32 sec_flags;\n\tBOOL do_crypt;\n\tBOOL do_crypt_license;\n\tBOOL do_secure_checksum;\n\tBYTE sign_key[16];\n\tBYTE decrypt_key[16];\n\tBYTE encrypt_key[16];\n\tBYTE decrypt_update_key[16];\n\tBYTE encrypt_update_key[16];\n\tint rc4_key_len;\n\tBYTE fips_sign_key[20];\n\tBYTE fips_encrypt_key[24];\n\tBYTE fips_decrypt_key[24];\n\tUINT32 errorInfo;\n\tUINT32 finalize_sc_pdus;\n\tBOOL resendFocus;\n\tBOOL deactivation_reactivation;\n\tBOOL AwaitCapabilities;\n\tUINT64 inBytes;\n\tUINT64 inPackets;\n\tUINT64 outBytes;\n\tUINT64 outPackets;\n};\n\nFREERDP_LOCAL BOOL rdp_read_security_header(wStream* s, UINT16* flags, UINT16* length);\nFREERDP_LOCAL void rdp_write_security_header(wStream* s, UINT16 flags);\n\nFREERDP_LOCAL BOOL rdp_read_share_control_header(wStream* s, UINT16* length, UINT16* type,\n                                                 UINT16* channel_id);\n\nFREERDP_LOCAL BOOL rdp_read_share_data_header(wStream* s, UINT16* length, BYTE* type,\n                                              UINT32* share_id, BYTE* compressed_type,\n                                              UINT16* compressed_len);\n\nFREERDP_LOCAL wStream* rdp_send_stream_init(rdpRdp* rdp);\nFREERDP_LOCAL wStream* rdp_send_stream_pdu_init(rdpRdp* rdp);\n\nFREERDP_LOCAL BOOL rdp_read_header(rdpRdp* rdp, wStream* s, UINT16* length, UINT16* channel_id);\nFREERDP_LOCAL void rdp_write_header(rdpRdp* rdp, wStream* s, UINT16 length, UINT16 channel_id);\n\nFREERDP_LOCAL BOOL rdp_send_pdu(rdpRdp* rdp, wStream* s, UINT16 type, UINT16 channel_id);\n\nFREERDP_LOCAL wStream* rdp_data_pdu_init(rdpRdp* rdp);\nFREERDP_LOCAL BOOL rdp_send_data_pdu(rdpRdp* rdp, wStream* s, BYTE type, UINT16 channel_id);\nFREERDP_LOCAL int rdp_recv_data_pdu(rdpRdp* rdp, wStream* s);\n\nFREERDP_LOCAL BOOL rdp_send(rdpRdp* rdp, wStream* s, UINT16 channelId);\n\nFREERDP_LOCAL BOOL rdp_send_channel_data(rdpRdp* rdp, UINT16 channelId, const BYTE* data,\n                                         size_t size);\n\nFREERDP_LOCAL wStream* rdp_message_channel_pdu_init(rdpRdp* rdp);\nFREERDP_LOCAL BOOL rdp_send_message_channel_pdu(rdpRdp* rdp, wStream* s, UINT16 sec_flags);\nFREERDP_LOCAL int rdp_recv_message_channel_pdu(rdpRdp* rdp, wStream* s, UINT16 securityFlags);\n\nFREERDP_LOCAL int rdp_recv_out_of_sequence_pdu(rdpRdp* rdp, wStream* s);\n\nFREERDP_LOCAL int rdp_recv_callback(rdpTransport* transport, wStream* s, void* extra);\n\nFREERDP_LOCAL int rdp_check_fds(rdpRdp* rdp);\n\nFREERDP_LOCAL rdpRdp* rdp_new(rdpContext* context);\nFREERDP_LOCAL void rdp_reset(rdpRdp* rdp);\nFREERDP_LOCAL void rdp_free(rdpRdp* rdp);\n\n#define RDP_TAG FREERDP_TAG(\"core.rdp\")\n#ifdef WITH_DEBUG_RDP\n#define DEBUG_RDP(...) WLog_DBG(RDP_TAG, __VA_ARGS__)\nextern const char* DATA_PDU_TYPE_STRINGS[80];\n#else\n#define DEBUG_RDP(...) \\\n\tdo                 \\\n\t{                  \\\n\t} while (0)\n#endif\n\nBOOL rdp_decrypt(rdpRdp* rdp, wStream* s, UINT16* pLength, UINT16 securityFlags);\n\nBOOL rdp_set_error_info(rdpRdp* rdp, UINT32 errorInfo);\nBOOL rdp_send_error_info(rdpRdp* rdp);\n\n#endif /* FREERDP_LIB_CORE_RDP_H */\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * Update Data PDUs\n *\n * Copyright 2011 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2016 Armin Novak <armin.novak@thincast.com>\n * Copyright 2016 Thincast Technologies GmbH\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <winpr/crt.h>\n#include <winpr/print.h>\n#include <winpr/synch.h>\n#include <winpr/thread.h>\n#include <winpr/collections.h>\n\n#include \"update.h\"\n#include \"surface.h\"\n#include \"message.h\"\n#include \"info.h\"\n#include \"window.h\"\n\n#include <freerdp/log.h>\n#include <freerdp/peer.h>\n#include <freerdp/codec/bitmap.h>\n\n#include \"../cache/pointer.h\"\n#include \"../cache/palette.h\"\n#include \"../cache/bitmap.h\"\n\n#define TAG FREERDP_TAG(\"core.update\")\n\nstatic const char* const UPDATE_TYPE_STRINGS[] = { \"Orders\", \"Bitmap\", \"Palette\", \"Synchronize\" };\n\nstatic const char* update_type_to_string(UINT16 updateType)\n{\n\tif (updateType >= ARRAYSIZE(UPDATE_TYPE_STRINGS))\n\t\treturn \"UNKNOWN\";\n\n\treturn UPDATE_TYPE_STRINGS[updateType];\n}\n\nstatic BOOL update_recv_orders(rdpUpdate* update, wStream* s)\n{\n\tUINT16 numberOrders;\n\n\tif (Stream_GetRemainingLength(s) < 6)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < 6\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Seek_UINT16(s);               /* pad2OctetsA (2 bytes) */\n\tStream_Read_UINT16(s, numberOrders); /* numberOrders (2 bytes) */\n\tStream_Seek_UINT16(s);               /* pad2OctetsB (2 bytes) */\n\n\twhile (numberOrders > 0)\n\t{\n\t\tif (!update_recv_order(update, s))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"update_recv_order() failed\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tnumberOrders--;\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL update_read_bitmap_data(rdpUpdate* update, wStream* s, BITMAP_DATA* bitmapData)\n{\n\tWINPR_UNUSED(update);\n\tif (Stream_GetRemainingLength(s) < 18)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, bitmapData->destLeft);\n\tStream_Read_UINT16(s, bitmapData->destTop);\n\tStream_Read_UINT16(s, bitmapData->destRight);\n\tStream_Read_UINT16(s, bitmapData->destBottom);\n\tStream_Read_UINT16(s, bitmapData->width);\n\tStream_Read_UINT16(s, bitmapData->height);\n\tStream_Read_UINT16(s, bitmapData->bitsPerPixel);\n\tStream_Read_UINT16(s, bitmapData->flags);\n\tStream_Read_UINT16(s, bitmapData->bitmapLength);\n\n\tif (bitmapData->flags & BITMAP_COMPRESSION)\n\t{\n\t\tif (!(bitmapData->flags & NO_BITMAP_COMPRESSION_HDR))\n\t\t{\n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbCompFirstRowSize); /* cbCompFirstRowSize (2 bytes) */\n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbCompMainBodySize); /* cbCompMainBodySize (2 bytes) */\n\t\t\tStream_Read_UINT16(s, bitmapData->cbScanWidth);     /* cbScanWidth (2 bytes) */\n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbUncompressedSize); /* cbUncompressedSize (2 bytes) */\n\t\t\tbitmapData->bitmapLength = bitmapData->cbCompMainBodySize;\n\t\t}\n\n\t\tbitmapData->compressed = TRUE;\n\t}\n\telse\n\t\tbitmapData->compressed = FALSE;\n\n\tif (Stream_GetRemainingLength(s) < bitmapData->bitmapLength)\n\t\treturn FALSE;\n\n\tif (bitmapData->bitmapLength > 0)\n\t{\n\t\tbitmapData->bitmapDataStream = malloc(bitmapData->bitmapLength);\n\n\t\tif (!bitmapData->bitmapDataStream)\n\t\t\treturn FALSE;\n\n\t\tmemcpy(bitmapData->bitmapDataStream, Stream_Pointer(s), bitmapData->bitmapLength);\n\t\tStream_Seek(s, bitmapData->bitmapLength);\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL update_write_bitmap_data(rdpUpdate* update, wStream* s, BITMAP_DATA* bitmapData)\n{\n\tif (!Stream_EnsureRemainingCapacity(s, 64 + bitmapData->bitmapLength))\n\t\treturn FALSE;\n\n\tif (update->autoCalculateBitmapData)\n\t{\n\t\tbitmapData->flags = 0;\n\t\tbitmapData->cbCompFirstRowSize = 0;\n\n\t\tif (bitmapData->compressed)\n\t\t\tbitmapData->flags |= BITMAP_COMPRESSION;\n\n\t\tif (update->context->settings->NoBitmapCompressionHeader)\n\t\t{\n\t\t\tbitmapData->flags |= NO_BITMAP_COMPRESSION_HDR;\n\t\t\tbitmapData->cbCompMainBodySize = bitmapData->bitmapLength;\n\t\t}\n\t}\n\n\tStream_Write_UINT16(s, bitmapData->destLeft);\n\tStream_Write_UINT16(s, bitmapData->destTop);\n\tStream_Write_UINT16(s, bitmapData->destRight);\n\tStream_Write_UINT16(s, bitmapData->destBottom);\n\tStream_Write_UINT16(s, bitmapData->width);\n\tStream_Write_UINT16(s, bitmapData->height);\n\tStream_Write_UINT16(s, bitmapData->bitsPerPixel);\n\tStream_Write_UINT16(s, bitmapData->flags);\n\tStream_Write_UINT16(s, bitmapData->bitmapLength);\n\n\tif (bitmapData->flags & BITMAP_COMPRESSION)\n\t{\n\t\tif (!(bitmapData->flags & NO_BITMAP_COMPRESSION_HDR))\n\t\t{\n\t\t\tStream_Write_UINT16(s,\n\t\t\t                    bitmapData->cbCompFirstRowSize); /* cbCompFirstRowSize (2 bytes) */\n\t\t\tStream_Write_UINT16(s,\n\t\t\t                    bitmapData->cbCompMainBodySize); /* cbCompMainBodySize (2 bytes) */\n\t\t\tStream_Write_UINT16(s, bitmapData->cbScanWidth);     /* cbScanWidth (2 bytes) */\n\t\t\tStream_Write_UINT16(s,\n\t\t\t                    bitmapData->cbUncompressedSize); /* cbUncompressedSize (2 bytes) */\n\t\t}\n\n\t\tStream_Write(s, bitmapData->bitmapDataStream, bitmapData->bitmapLength);\n\t}\n\telse\n\t{\n\t\tStream_Write(s, bitmapData->bitmapDataStream, bitmapData->bitmapLength);\n\t}\n\n\treturn TRUE;\n}\n\nBITMAP_UPDATE* update_read_bitmap_update(rdpUpdate* update, wStream* s)\n{\n\tUINT32 i;\n\tBITMAP_UPDATE* bitmapUpdate = calloc(1, sizeof(BITMAP_UPDATE));\n\n\tif (!bitmapUpdate)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, bitmapUpdate->number); /* numberRectangles (2 bytes) */\n\tWLog_Print(update->log, WLOG_TRACE, \"BitmapUpdate: %\" PRIu32 \"\", bitmapUpdate->number);\n\n\tif (bitmapUpdate->number > bitmapUpdate->count)\n\t{\n\t\tUINT32 count = bitmapUpdate->number * 2;\n\t\tBITMAP_DATA* newdata =\n\t\t    (BITMAP_DATA*)realloc(bitmapUpdate->rectangles, sizeof(BITMAP_DATA) * count);\n\n\t\tif (!newdata)\n\t\t\tgoto fail;\n\n\t\tbitmapUpdate->rectangles = newdata;\n\t\tZeroMemory(&bitmapUpdate->rectangles[bitmapUpdate->count],\n\t\t           sizeof(BITMAP_DATA) * (count - bitmapUpdate->count));\n\t\tbitmapUpdate->count = count;\n\t}\n\n\t/* rectangles */\n\tfor (i = 0; i < bitmapUpdate->number; i++)\n\t{\n\t\tif (!update_read_bitmap_data(update, s, &bitmapUpdate->rectangles[i]))\n\t\t\tgoto fail;\n\t}\n\n\treturn bitmapUpdate;\nfail:\n\tfree_bitmap_update(update->context, bitmapUpdate);\n\treturn NULL;\n}\n\nstatic BOOL update_write_bitmap_update(rdpUpdate* update, wStream* s,\n                                       const BITMAP_UPDATE* bitmapUpdate)\n{\n\tint i;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 32))\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, UPDATE_TYPE_BITMAP);   /* updateType */\n\tStream_Write_UINT16(s, bitmapUpdate->number); /* numberRectangles (2 bytes) */\n\n\t/* rectangles */\n\tfor (i = 0; i < (int)bitmapUpdate->number; i++)\n\t{\n\t\tif (!update_write_bitmap_data(update, s, &bitmapUpdate->rectangles[i]))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nPALETTE_UPDATE* update_read_palette(rdpUpdate* update, wStream* s)\n{\n\tint i;\n\tPALETTE_ENTRY* entry;\n\tPALETTE_UPDATE* palette_update = calloc(1, sizeof(PALETTE_UPDATE));\n\n\tif (!palette_update)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 6)\n\t\tgoto fail;\n\n\tStream_Seek_UINT16(s);                         /* pad2Octets (2 bytes) */\n\tStream_Read_UINT32(s, palette_update->number); /* numberColors (4 bytes), must be set to 256 */\n\n\tif (palette_update->number > 256)\n\t\tpalette_update->number = 256;\n\n\tif (Stream_GetRemainingLength(s) < palette_update->number * 3)\n\t\tgoto fail;\n\n\t/* paletteEntries */\n\tfor (i = 0; i < (int)palette_update->number; i++)\n\t{\n\t\tentry = &palette_update->entries[i];\n\t\tStream_Read_UINT8(s, entry->red);\n\t\tStream_Read_UINT8(s, entry->green);\n\t\tStream_Read_UINT8(s, entry->blue);\n\t}\n\n\treturn palette_update;\nfail:\n\tfree_palette_update(update->context, palette_update);\n\treturn NULL;\n}\n\nstatic void update_read_synchronize(rdpUpdate* update, wStream* s)\n{\n\tWINPR_UNUSED(update);\n\tStream_Seek_UINT16(s); /* pad2Octets (2 bytes) */\n\t                       /**\n\t                        * The Synchronize Update is an artifact from the\n\t                        * T.128 protocol and should be ignored.\n\t                        */\n}\n\nstatic BOOL update_read_play_sound(wStream* s, PLAY_SOUND_UPDATE* play_sound)\n{\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, play_sound->duration);  /* duration (4 bytes) */\n\tStream_Read_UINT32(s, play_sound->frequency); /* frequency (4 bytes) */\n\treturn TRUE;\n}\n\nBOOL update_recv_play_sound(rdpUpdate* update, wStream* s)\n{\n\tPLAY_SOUND_UPDATE play_sound;\n\n\tif (!update_read_play_sound(s, &play_sound))\n\t\treturn FALSE;\n\n\treturn IFCALLRESULT(FALSE, update->PlaySound, update->context, &play_sound);\n}\n\nPOINTER_POSITION_UPDATE* update_read_pointer_position(rdpUpdate* update, wStream* s)\n{\n\tPOINTER_POSITION_UPDATE* pointer_position = calloc(1, sizeof(POINTER_POSITION_UPDATE));\n\n\tif (!pointer_position)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, pointer_position->xPos); /* xPos (2 bytes) */\n\tStream_Read_UINT16(s, pointer_position->yPos); /* yPos (2 bytes) */\n\treturn pointer_position;\nfail:\n\tfree_pointer_position_update(update->context, pointer_position);\n\treturn NULL;\n}\n\nPOINTER_SYSTEM_UPDATE* update_read_pointer_system(rdpUpdate* update, wStream* s)\n{\n\tPOINTER_SYSTEM_UPDATE* pointer_system = calloc(1, sizeof(POINTER_SYSTEM_UPDATE));\n\n\tif (!pointer_system)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\tgoto fail;\n\n\tStream_Read_UINT32(s, pointer_system->type); /* systemPointerType (4 bytes) */\n\treturn pointer_system;\nfail:\n\tfree_pointer_system_update(update->context, pointer_system);\n\treturn NULL;\n}\n\nstatic BOOL _update_read_pointer_color(wStream* s, POINTER_COLOR_UPDATE* pointer_color, BYTE xorBpp)\n{\n\tBYTE* newMask;\n\tUINT32 scanlineSize;\n\n\tif (!pointer_color)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 14)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, pointer_color->cacheIndex); /* cacheIndex (2 bytes) */\n\tStream_Read_UINT16(s, pointer_color->xPos);       /* xPos (2 bytes) */\n\tStream_Read_UINT16(s, pointer_color->yPos);       /* yPos (2 bytes) */\n\t/**\n\t *  As stated in 2.2.9.1.1.4.4 Color Pointer Update:\n\t *  The maximum allowed pointer width/height is 96 pixels if the client indicated support\n\t *  for large pointers by setting the LARGE_POINTER_FLAG (0x00000001) in the Large\n\t *  Pointer Capability Set (section 2.2.7.2.7). If the LARGE_POINTER_FLAG was not\n\t *  set, the maximum allowed pointer width/height is 32 pixels.\n\t *\n\t *  So we check for a maximum of 96 for CVE-2014-0250.\n\t */\n\tStream_Read_UINT16(s, pointer_color->width);  /* width (2 bytes) */\n\tStream_Read_UINT16(s, pointer_color->height); /* height (2 bytes) */\n\n\tif ((pointer_color->width > 96) || (pointer_color->height > 96))\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, pointer_color->lengthAndMask); /* lengthAndMask (2 bytes) */\n\tStream_Read_UINT16(s, pointer_color->lengthXorMask); /* lengthXorMask (2 bytes) */\n\n\t/**\n\t * There does not seem to be any documentation on why\n\t * xPos / yPos can be larger than width / height\n\t * so it is missing in documentation or a bug in implementation\n\t * 2.2.9.1.1.4.4 Color Pointer Update (TS_COLORPOINTERATTRIBUTE)\n\t */\n\tif (pointer_color->xPos >= pointer_color->width)\n\t\tpointer_color->xPos = 0;\n\n\tif (pointer_color->yPos >= pointer_color->height)\n\t\tpointer_color->yPos = 0;\n\n\tif (pointer_color->lengthXorMask > 0)\n\t{\n\t\t/**\n\t\t * Spec states that:\n\t\t *\n\t\t * xorMaskData (variable): A variable-length array of bytes. Contains the 24-bpp, bottom-up\n\t\t * XOR mask scan-line data. The XOR mask is padded to a 2-byte boundary for each encoded\n\t\t * scan-line. For example, if a 3x3 pixel cursor is being sent, then each scan-line will\n\t\t * consume 10 bytes (3 pixels per scan-line multiplied by 3 bytes per pixel, rounded up to\n\t\t * the next even number of bytes).\n\t\t *\n\t\t * In fact instead of 24-bpp, the bpp parameter is given by the containing packet.\n\t\t */\n\t\tif (Stream_GetRemainingLength(s) < pointer_color->lengthXorMask)\n\t\t\tgoto fail;\n\n\t\tscanlineSize = (7 + xorBpp * pointer_color->width) / 8;\n\t\tscanlineSize = ((scanlineSize + 1) / 2) * 2;\n\n\t\tif (scanlineSize * pointer_color->height != pointer_color->lengthXorMask)\n\t\t{\n\t\t\tWLog_ERR(TAG,\n\t\t\t         \"invalid lengthXorMask: width=%\" PRIu32 \" height=%\" PRIu32 \", %\" PRIu32\n\t\t\t         \" instead of %\" PRIu32 \"\",\n\t\t\t         pointer_color->width, pointer_color->height, pointer_color->lengthXorMask,\n\t\t\t         scanlineSize * pointer_color->height);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tnewMask = realloc(pointer_color->xorMaskData, pointer_color->lengthXorMask);\n\n\t\tif (!newMask)\n\t\t\tgoto fail;\n\n\t\tpointer_color->xorMaskData = newMask;\n\t\tStream_Read(s, pointer_color->xorMaskData, pointer_color->lengthXorMask);\n\t}\n\n\tif (pointer_color->lengthAndMask > 0)\n\t{\n\t\t/**\n\t\t * andMaskData (variable): A variable-length array of bytes. Contains the 1-bpp, bottom-up\n\t\t * AND mask scan-line data. The AND mask is padded to a 2-byte boundary for each encoded\n\t\t * scan-line. For example, if a 7x7 pixel cursor is being sent, then each scan-line will\n\t\t * consume 2 bytes (7 pixels per scan-line multiplied by 1 bpp, rounded up to the next even\n\t\t * number of bytes).\n\t\t */\n\t\tif (Stream_GetRemainingLength(s) < pointer_color->lengthAndMask)\n\t\t\tgoto fail;\n\n\t\tscanlineSize = ((7 + pointer_color->width) / 8);\n\t\tscanlineSize = ((1 + scanlineSize) / 2) * 2;\n\n\t\tif (scanlineSize * pointer_color->height != pointer_color->lengthAndMask)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"invalid lengthAndMask: %\" PRIu32 \" instead of %\" PRIu32 \"\",\n\t\t\t         pointer_color->lengthAndMask, scanlineSize * pointer_color->height);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tnewMask = realloc(pointer_color->andMaskData, pointer_color->lengthAndMask);\n\n\t\tif (!newMask)\n\t\t\tgoto fail;\n\n\t\tpointer_color->andMaskData = newMask;\n\t\tStream_Read(s, pointer_color->andMaskData, pointer_color->lengthAndMask);\n\t}\n\n\tif (Stream_GetRemainingLength(s) > 0)\n\t\tStream_Seek_UINT8(s); /* pad (1 byte) */\n\n\treturn TRUE;\nfail:\n\treturn FALSE;\n}\n\nPOINTER_COLOR_UPDATE* update_read_pointer_color(rdpUpdate* update, wStream* s, BYTE xorBpp)\n{\n\tPOINTER_COLOR_UPDATE* pointer_color = calloc(1, sizeof(POINTER_COLOR_UPDATE));\n\n\tif (!pointer_color)\n\t\tgoto fail;\n\n\tif (!_update_read_pointer_color(s, pointer_color, xorBpp))\n\t\tgoto fail;\n\n\treturn pointer_color;\nfail:\n\tfree_pointer_color_update(update->context, pointer_color);\n\treturn NULL;\n}\n\nstatic BOOL _update_read_pointer_large(wStream* s, POINTER_LARGE_UPDATE* pointer)\n{\n\tBYTE* newMask;\n\tUINT32 scanlineSize;\n\n\tif (!pointer)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 14)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, pointer->xorBpp);\n\tStream_Read_UINT16(s, pointer->cacheIndex); /* cacheIndex (2 bytes) */\n\tStream_Read_UINT16(s, pointer->hotSpotX);   /* xPos (2 bytes) */\n\tStream_Read_UINT16(s, pointer->hotSpotY);   /* yPos (2 bytes) */\n\n\tStream_Read_UINT16(s, pointer->width);  /* width (2 bytes) */\n\tStream_Read_UINT16(s, pointer->height); /* height (2 bytes) */\n\n\tif ((pointer->width > 384) || (pointer->height > 384))\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, pointer->lengthAndMask); /* lengthAndMask (2 bytes) */\n\tStream_Read_UINT16(s, pointer->lengthXorMask); /* lengthXorMask (2 bytes) */\n\n\tif (pointer->hotSpotX >= pointer->width)\n\t\tpointer->hotSpotX = 0;\n\n\tif (pointer->hotSpotY >= pointer->height)\n\t\tpointer->hotSpotY = 0;\n\n\tif (pointer->lengthXorMask > 0)\n\t{\n\t\t/**\n\t\t * Spec states that:\n\t\t *\n\t\t * xorMaskData (variable): A variable-length array of bytes. Contains the 24-bpp, bottom-up\n\t\t * XOR mask scan-line data. The XOR mask is padded to a 2-byte boundary for each encoded\n\t\t * scan-line. For example, if a 3x3 pixel cursor is being sent, then each scan-line will\n\t\t * consume 10 bytes (3 pixels per scan-line multiplied by 3 bytes per pixel, rounded up to\n\t\t * the next even number of bytes).\n\t\t *\n\t\t * In fact instead of 24-bpp, the bpp parameter is given by the containing packet.\n\t\t */\n\t\tif (Stream_GetRemainingLength(s) < pointer->lengthXorMask)\n\t\t\tgoto fail;\n\n\t\tscanlineSize = (7 + pointer->xorBpp * pointer->width) / 8;\n\t\tscanlineSize = ((scanlineSize + 1) / 2) * 2;\n\n\t\tif (scanlineSize * pointer->height != pointer->lengthXorMask)\n\t\t{\n\t\t\tWLog_ERR(TAG,\n\t\t\t         \"invalid lengthXorMask: width=%\" PRIu32 \" height=%\" PRIu32 \", %\" PRIu32\n\t\t\t         \" instead of %\" PRIu32 \"\",\n\t\t\t         pointer->width, pointer->height, pointer->lengthXorMask,\n\t\t\t         scanlineSize * pointer->height);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tnewMask = realloc(pointer->xorMaskData, pointer->lengthXorMask);\n\n\t\tif (!newMask)\n\t\t\tgoto fail;\n\n\t\tpointer->xorMaskData = newMask;\n\t\tStream_Read(s, pointer->xorMaskData, pointer->lengthXorMask);\n\t}\n\n\tif (pointer->lengthAndMask > 0)\n\t{\n\t\t/**\n\t\t * andMaskData (variable): A variable-length array of bytes. Contains the 1-bpp, bottom-up\n\t\t * AND mask scan-line data. The AND mask is padded to a 2-byte boundary for each encoded\n\t\t * scan-line. For example, if a 7x7 pixel cursor is being sent, then each scan-line will\n\t\t * consume 2 bytes (7 pixels per scan-line multiplied by 1 bpp, rounded up to the next even\n\t\t * number of bytes).\n\t\t */\n\t\tif (Stream_GetRemainingLength(s) < pointer->lengthAndMask)\n\t\t\tgoto fail;\n\n\t\tscanlineSize = ((7 + pointer->width) / 8);\n\t\tscanlineSize = ((1 + scanlineSize) / 2) * 2;\n\n\t\tif (scanlineSize * pointer->height != pointer->lengthAndMask)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"invalid lengthAndMask: %\" PRIu32 \" instead of %\" PRIu32 \"\",\n\t\t\t         pointer->lengthAndMask, scanlineSize * pointer->height);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tnewMask = realloc(pointer->andMaskData, pointer->lengthAndMask);\n\n\t\tif (!newMask)\n\t\t\tgoto fail;\n\n\t\tpointer->andMaskData = newMask;\n\t\tStream_Read(s, pointer->andMaskData, pointer->lengthAndMask);\n\t}\n\n\tif (Stream_GetRemainingLength(s) > 0)\n\t\tStream_Seek_UINT8(s); /* pad (1 byte) */\n\n\treturn TRUE;\nfail:\n\treturn FALSE;\n}\n\nPOINTER_LARGE_UPDATE* update_read_pointer_large(rdpUpdate* update, wStream* s)\n{\n\tPOINTER_LARGE_UPDATE* pointer = calloc(1, sizeof(POINTER_LARGE_UPDATE));\n\n\tif (!pointer)\n\t\tgoto fail;\n\n\tif (!_update_read_pointer_large(s, pointer))\n\t\tgoto fail;\n\n\treturn pointer;\nfail:\n\tfree_pointer_large_update(update->context, pointer);\n\treturn NULL;\n}\n\nPOINTER_NEW_UPDATE* update_read_pointer_new(rdpUpdate* update, wStream* s)\n{\n\tPOINTER_NEW_UPDATE* pointer_new = calloc(1, sizeof(POINTER_NEW_UPDATE));\n\n\tif (!pointer_new)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, pointer_new->xorBpp); /* xorBpp (2 bytes) */\n\n\tif ((pointer_new->xorBpp < 1) || (pointer_new->xorBpp > 32))\n\t{\n\t\tWLog_ERR(TAG, \"invalid xorBpp %\" PRIu32 \"\", pointer_new->xorBpp);\n\t\tgoto fail;\n\t}\n\n\tif (!_update_read_pointer_color(s, &pointer_new->colorPtrAttr,\n\t                                pointer_new->xorBpp)) /* colorPtrAttr */\n\t\tgoto fail;\n\n\treturn pointer_new;\nfail:\n\tfree_pointer_new_update(update->context, pointer_new);\n\treturn NULL;\n}\n\nPOINTER_CACHED_UPDATE* update_read_pointer_cached(rdpUpdate* update, wStream* s)\n{\n\tPOINTER_CACHED_UPDATE* pointer = calloc(1, sizeof(POINTER_CACHED_UPDATE));\n\n\tif (!pointer)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, pointer->cacheIndex); /* cacheIndex (2 bytes) */\n\treturn pointer;\nfail:\n\tfree_pointer_cached_update(update->context, pointer);\n\treturn NULL;\n}\n\nBOOL update_recv_pointer(rdpUpdate* update, wStream* s)\n{\n\tBOOL rc = FALSE;\n\tUINT16 messageType;\n\trdpContext* context = update->context;\n\trdpPointerUpdate* pointer = update->pointer;\n\n\tif (Stream_GetRemainingLength(s) < 2 + 2)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, messageType); /* messageType (2 bytes) */\n\tStream_Seek_UINT16(s);              /* pad2Octets (2 bytes) */\n\n\tswitch (messageType)\n\t{\n\t\tcase PTR_MSG_TYPE_POSITION:\n\t\t{\n\t\t\tPOINTER_POSITION_UPDATE* pointer_position = update_read_pointer_position(update, s);\n\n\t\t\tif (pointer_position)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, pointer->PointerPosition, context, pointer_position);\n\t\t\t\tfree_pointer_position_update(context, pointer_position);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase PTR_MSG_TYPE_SYSTEM:\n\t\t{\n\t\t\tPOINTER_SYSTEM_UPDATE* pointer_system = update_read_pointer_system(update, s);\n\n\t\t\tif (pointer_system)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, pointer->PointerSystem, context, pointer_system);\n\t\t\t\tfree_pointer_system_update(context, pointer_system);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase PTR_MSG_TYPE_COLOR:\n\t\t{\n\t\t\tPOINTER_COLOR_UPDATE* pointer_color = update_read_pointer_color(update, s, 24);\n\n\t\t\tif (pointer_color)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, pointer->PointerColor, context, pointer_color);\n\t\t\t\tfree_pointer_color_update(context, pointer_color);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase PTR_MSG_TYPE_POINTER_LARGE:\n\t\t{\n\t\t\tPOINTER_LARGE_UPDATE* pointer_large = update_read_pointer_large(update, s);\n\n\t\t\tif (pointer_large)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, pointer->PointerLarge, context, pointer_large);\n\t\t\t\tfree_pointer_large_update(context, pointer_large);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase PTR_MSG_TYPE_POINTER:\n\t\t{\n\t\t\tPOINTER_NEW_UPDATE* pointer_new = update_read_pointer_new(update, s);\n\n\t\t\tif (pointer_new)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, pointer->PointerNew, context, pointer_new);\n\t\t\t\tfree_pointer_new_update(context, pointer_new);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase PTR_MSG_TYPE_CACHED:\n\t\t{\n\t\t\tPOINTER_CACHED_UPDATE* pointer_cached = update_read_pointer_cached(update, s);\n\n\t\t\tif (pointer_cached)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, pointer->PointerCached, context, pointer_cached);\n\t\t\t\tfree_pointer_cached_update(context, pointer_cached);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nBOOL update_recv(rdpUpdate* update, wStream* s)\n{\n\tBOOL rc = FALSE;\n\tUINT16 updateType;\n\trdpContext* context = update->context;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < 2\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, updateType); /* updateType (2 bytes) */\n\tWLog_Print(update->log, WLOG_TRACE, \"%s Update Data PDU\", UPDATE_TYPE_STRINGS[updateType]);\n\n\tif (!update_begin_paint(update))\n\t\tgoto fail;\n\n\tswitch (updateType)\n\t{\n\t\tcase UPDATE_TYPE_ORDERS:\n\t\t\trc = update_recv_orders(update, s);\n\t\t\tbreak;\n\n\t\tcase UPDATE_TYPE_BITMAP:\n\t\t{\n\t\t\tBITMAP_UPDATE* bitmap_update = update_read_bitmap_update(update, s);\n\n\t\t\tif (!bitmap_update)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_BITMAP - update_read_bitmap_update() failed\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\trc = IFCALLRESULT(FALSE, update->BitmapUpdate, context, bitmap_update);\n\t\t\tfree_bitmap_update(update->context, bitmap_update);\n\t\t}\n\t\tbreak;\n\n\t\tcase UPDATE_TYPE_PALETTE:\n\t\t{\n\t\t\tPALETTE_UPDATE* palette_update = update_read_palette(update, s);\n\n\t\t\tif (!palette_update)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_PALETTE - update_read_palette() failed\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\trc = IFCALLRESULT(FALSE, update->Palette, context, palette_update);\n\t\t\tfree_palette_update(context, palette_update);\n\t\t}\n\t\tbreak;\n\n\t\tcase UPDATE_TYPE_SYNCHRONIZE:\n\t\t\tupdate_read_synchronize(update, s);\n\t\t\trc = IFCALLRESULT(TRUE, update->Synchronize, context);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\nfail:\n\n\tif (!update_end_paint(update))\n\t\trc = FALSE;\n\n\tif (!rc)\n\t{\n\t\tWLog_ERR(TAG, \"UPDATE_TYPE %s [%\" PRIu16 \"] failed\", update_type_to_string(updateType),\n\t\t         updateType);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nvoid update_reset_state(rdpUpdate* update)\n{\n\trdpPrimaryUpdate* primary = update->primary;\n\trdpAltSecUpdate* altsec = update->altsec;\n\n\tif (primary->fast_glyph.glyphData.aj)\n\t{\n\t\tfree(primary->fast_glyph.glyphData.aj);\n\t\tprimary->fast_glyph.glyphData.aj = NULL;\n\t}\n\n\tZeroMemory(&primary->order_info, sizeof(ORDER_INFO));\n\tZeroMemory(&primary->dstblt, sizeof(DSTBLT_ORDER));\n\tZeroMemory(&primary->patblt, sizeof(PATBLT_ORDER));\n\tZeroMemory(&primary->scrblt, sizeof(SCRBLT_ORDER));\n\tZeroMemory(&primary->opaque_rect, sizeof(OPAQUE_RECT_ORDER));\n\tZeroMemory(&primary->draw_nine_grid, sizeof(DRAW_NINE_GRID_ORDER));\n\tZeroMemory(&primary->multi_dstblt, sizeof(MULTI_DSTBLT_ORDER));\n\tZeroMemory(&primary->multi_patblt, sizeof(MULTI_PATBLT_ORDER));\n\tZeroMemory(&primary->multi_scrblt, sizeof(MULTI_SCRBLT_ORDER));\n\tZeroMemory(&primary->multi_opaque_rect, sizeof(MULTI_OPAQUE_RECT_ORDER));\n\tZeroMemory(&primary->multi_draw_nine_grid, sizeof(MULTI_DRAW_NINE_GRID_ORDER));\n\tZeroMemory(&primary->line_to, sizeof(LINE_TO_ORDER));\n\tZeroMemory(&primary->polyline, sizeof(POLYLINE_ORDER));\n\tZeroMemory(&primary->memblt, sizeof(MEMBLT_ORDER));\n\tZeroMemory(&primary->mem3blt, sizeof(MEM3BLT_ORDER));\n\tZeroMemory(&primary->save_bitmap, sizeof(SAVE_BITMAP_ORDER));\n\tZeroMemory(&primary->glyph_index, sizeof(GLYPH_INDEX_ORDER));\n\tZeroMemory(&primary->fast_index, sizeof(FAST_INDEX_ORDER));\n\tZeroMemory(&primary->fast_glyph, sizeof(FAST_GLYPH_ORDER));\n\tZeroMemory(&primary->polygon_sc, sizeof(POLYGON_SC_ORDER));\n\tZeroMemory(&primary->polygon_cb, sizeof(POLYGON_CB_ORDER));\n\tZeroMemory(&primary->ellipse_sc, sizeof(ELLIPSE_SC_ORDER));\n\tZeroMemory(&primary->ellipse_cb, sizeof(ELLIPSE_CB_ORDER));\n\tprimary->order_info.orderType = ORDER_TYPE_PATBLT;\n\n\tif (!update->initialState)\n\t{\n\t\taltsec->switch_surface.bitmapId = SCREEN_BITMAP_SURFACE;\n\t\tIFCALL(altsec->SwitchSurface, update->context, &(altsec->switch_surface));\n\t}\n}\n\nBOOL update_post_connect(rdpUpdate* update)\n{\n\tupdate->asynchronous = update->context->settings->AsyncUpdate;\n\n\tif (update->asynchronous)\n\t\tif (!(update->proxy = update_message_proxy_new(update)))\n\t\t\treturn FALSE;\n\n\tupdate->altsec->switch_surface.bitmapId = SCREEN_BITMAP_SURFACE;\n\tIFCALL(update->altsec->SwitchSurface, update->context, &(update->altsec->switch_surface));\n\tupdate->initialState = FALSE;\n\treturn TRUE;\n}\n\nvoid update_post_disconnect(rdpUpdate* update)\n{\n\tupdate->asynchronous = update->context->settings->AsyncUpdate;\n\n\tif (update->asynchronous)\n\t\tupdate_message_proxy_free(update->proxy);\n\n\tupdate->initialState = TRUE;\n}\n\nstatic BOOL _update_begin_paint(rdpContext* context)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\n\tif (update->us)\n\t{\n\t\tif (!update_end_paint(update))\n\t\t\treturn FALSE;\n\t}\n\n\ts = fastpath_update_pdu_init_new(context->rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_SealLength(s);\n\tStream_Seek(s, 2); /* numberOrders (2 bytes) */\n\tupdate->combineUpdates = TRUE;\n\tupdate->numberOrders = 0;\n\tupdate->us = s;\n\treturn TRUE;\n}\n\nstatic BOOL _update_end_paint(rdpContext* context)\n{\n\twStream* s;\n\tint headerLength;\n\trdpUpdate* update = context->update;\n\n\tif (!update->us)\n\t\treturn FALSE;\n\n\ts = update->us;\n\theaderLength = Stream_Length(s);\n\tStream_SealLength(s);\n\tStream_SetPosition(s, headerLength);\n\tStream_Write_UINT16(s, update->numberOrders); /* numberOrders (2 bytes) */\n\tStream_SetPosition(s, Stream_Length(s));\n\n\tif (update->numberOrders > 0)\n\t{\n\t\tWLog_DBG(TAG, \"sending %\" PRIu16 \" orders\", update->numberOrders);\n\t\tfastpath_send_update_pdu(context->rdp->fastpath, FASTPATH_UPDATETYPE_ORDERS, s, FALSE);\n\t}\n\n\tupdate->combineUpdates = FALSE;\n\tupdate->numberOrders = 0;\n\tupdate->us = NULL;\n\tStream_Free(s, TRUE);\n\treturn TRUE;\n}\n\nstatic void update_flush(rdpContext* context)\n{\n\trdpUpdate* update = context->update;\n\n\tif (update->numberOrders > 0)\n\t{\n\t\tupdate_end_paint(update);\n\t\tupdate_begin_paint(update);\n\t}\n}\n\nstatic void update_force_flush(rdpContext* context)\n{\n\tupdate_flush(context);\n}\n\nstatic BOOL update_check_flush(rdpContext* context, int size)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\ts = update->us;\n\n\tif (!update->us)\n\t{\n\t\tupdate_begin_paint(update);\n\t\treturn FALSE;\n\t}\n\n\tif (Stream_GetPosition(s) + size + 64 >= 0x3FFF)\n\t{\n\t\tupdate_flush(context);\n\t\treturn TRUE;\n\t}\n\n\treturn FALSE;\n}\n\nstatic BOOL update_set_bounds(rdpContext* context, const rdpBounds* bounds)\n{\n\trdpUpdate* update = context->update;\n\tCopyMemory(&update->previousBounds, &update->currentBounds, sizeof(rdpBounds));\n\n\tif (!bounds)\n\t\tZeroMemory(&update->currentBounds, sizeof(rdpBounds));\n\telse\n\t\tCopyMemory(&update->currentBounds, bounds, sizeof(rdpBounds));\n\n\treturn TRUE;\n}\n\nstatic BOOL update_bounds_is_null(rdpBounds* bounds)\n{\n\tif ((bounds->left == 0) && (bounds->top == 0) && (bounds->right == 0) && (bounds->bottom == 0))\n\t\treturn TRUE;\n\n\treturn FALSE;\n}\n\nstatic BOOL update_bounds_equals(rdpBounds* bounds1, rdpBounds* bounds2)\n{\n\tif ((bounds1->left == bounds2->left) && (bounds1->top == bounds2->top) &&\n\t    (bounds1->right == bounds2->right) && (bounds1->bottom == bounds2->bottom))\n\t\treturn TRUE;\n\n\treturn FALSE;\n}\n\nstatic int update_prepare_bounds(rdpContext* context, ORDER_INFO* orderInfo)\n{\n\tint length = 0;\n\trdpUpdate* update = context->update;\n\torderInfo->boundsFlags = 0;\n\n\tif (update_bounds_is_null(&update->currentBounds))\n\t\treturn 0;\n\n\torderInfo->controlFlags |= ORDER_BOUNDS;\n\n\tif (update_bounds_equals(&update->previousBounds, &update->currentBounds))\n\t{\n\t\torderInfo->controlFlags |= ORDER_ZERO_BOUNDS_DELTAS;\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tlength += 1;\n\n\t\tif (update->previousBounds.left != update->currentBounds.left)\n\t\t{\n\t\t\torderInfo->bounds.left = update->currentBounds.left;\n\t\t\torderInfo->boundsFlags |= BOUND_LEFT;\n\t\t\tlength += 2;\n\t\t}\n\n\t\tif (update->previousBounds.top != update->currentBounds.top)\n\t\t{\n\t\t\torderInfo->bounds.top = update->currentBounds.top;\n\t\t\torderInfo->boundsFlags |= BOUND_TOP;\n\t\t\tlength += 2;\n\t\t}\n\n\t\tif (update->previousBounds.right != update->currentBounds.right)\n\t\t{\n\t\t\torderInfo->bounds.right = update->currentBounds.right;\n\t\t\torderInfo->boundsFlags |= BOUND_RIGHT;\n\t\t\tlength += 2;\n\t\t}\n\n\t\tif (update->previousBounds.bottom != update->currentBounds.bottom)\n\t\t{\n\t\t\torderInfo->bounds.bottom = update->currentBounds.bottom;\n\t\t\torderInfo->boundsFlags |= BOUND_BOTTOM;\n\t\t\tlength += 2;\n\t\t}\n\t}\n\n\treturn length;\n}\n\nstatic int update_prepare_order_info(rdpContext* context, ORDER_INFO* orderInfo, UINT32 orderType)\n{\n\tint length = 1;\n\torderInfo->fieldFlags = 0;\n\torderInfo->orderType = orderType;\n\torderInfo->controlFlags = ORDER_STANDARD;\n\torderInfo->controlFlags |= ORDER_TYPE_CHANGE;\n\tlength += 1;\n\tlength += PRIMARY_DRAWING_ORDER_FIELD_BYTES[orderInfo->orderType];\n\tlength += update_prepare_bounds(context, orderInfo);\n\treturn length;\n}\n\nstatic int update_write_order_info(rdpContext* context, wStream* s, ORDER_INFO* orderInfo,\n                                   size_t offset)\n{\n\tsize_t position;\n\tWINPR_UNUSED(context);\n\tposition = Stream_GetPosition(s);\n\tStream_SetPosition(s, offset);\n\tStream_Write_UINT8(s, orderInfo->controlFlags); /* controlFlags (1 byte) */\n\n\tif (orderInfo->controlFlags & ORDER_TYPE_CHANGE)\n\t\tStream_Write_UINT8(s, orderInfo->orderType); /* orderType (1 byte) */\n\n\tupdate_write_field_flags(s, orderInfo->fieldFlags, orderInfo->controlFlags,\n\t                         PRIMARY_DRAWING_ORDER_FIELD_BYTES[orderInfo->orderType]);\n\tupdate_write_bounds(s, orderInfo);\n\tStream_SetPosition(s, position);\n\treturn 0;\n}\n\nstatic void update_write_refresh_rect(wStream* s, BYTE count, const RECTANGLE_16* areas)\n{\n\tint i;\n\tStream_Write_UINT8(s, count); /* numberOfAreas (1 byte) */\n\tStream_Seek(s, 3);            /* pad3Octets (3 bytes) */\n\n\tfor (i = 0; i < count; i++)\n\t{\n\t\tStream_Write_UINT16(s, areas[i].left);   /* left (2 bytes) */\n\t\tStream_Write_UINT16(s, areas[i].top);    /* top (2 bytes) */\n\t\tStream_Write_UINT16(s, areas[i].right);  /* right (2 bytes) */\n\t\tStream_Write_UINT16(s, areas[i].bottom); /* bottom (2 bytes) */\n\t}\n}\n\nstatic BOOL update_send_refresh_rect(rdpContext* context, BYTE count, const RECTANGLE_16* areas)\n{\n\trdpRdp* rdp = context->rdp;\n\n\tif (rdp->settings->RefreshRect)\n\t{\n\t\twStream* s = rdp_data_pdu_init(rdp);\n\n\t\tif (!s)\n\t\t\treturn FALSE;\n\n\t\tupdate_write_refresh_rect(s, count, areas);\n\t\treturn rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_REFRESH_RECT, rdp->mcs->userId);\n\t}\n\n\treturn TRUE;\n}\n\nstatic void update_write_suppress_output(wStream* s, BYTE allow, const RECTANGLE_16* area)\n{\n\tStream_Write_UINT8(s, allow); /* allowDisplayUpdates (1 byte) */\n\t/* Use zeros for padding (like mstsc) for compatibility with legacy servers */\n\tStream_Zero(s, 3); /* pad3Octets (3 bytes) */\n\n\tif (allow > 0)\n\t{\n\t\tStream_Write_UINT16(s, area->left);   /* left (2 bytes) */\n\t\tStream_Write_UINT16(s, area->top);    /* top (2 bytes) */\n\t\tStream_Write_UINT16(s, area->right);  /* right (2 bytes) */\n\t\tStream_Write_UINT16(s, area->bottom); /* bottom (2 bytes) */\n\t}\n}\n\nstatic BOOL update_send_suppress_output(rdpContext* context, BYTE allow, const RECTANGLE_16* area)\n{\n\trdpRdp* rdp = context->rdp;\n\n\tif (rdp->settings->SuppressOutput)\n\t{\n\t\twStream* s = rdp_data_pdu_init(rdp);\n\n\t\tif (!s)\n\t\t\treturn FALSE;\n\n\t\tupdate_write_suppress_output(s, allow, area);\n\t\treturn rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_SUPPRESS_OUTPUT, rdp->mcs->userId);\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL update_send_surface_command(rdpContext* context, wStream* s)\n{\n\twStream* update;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret;\n\tupdate = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!update)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(update, Stream_GetPosition(s)))\n\t{\n\t\tret = FALSE;\n\t\tgoto out;\n\t}\n\n\tStream_Write(update, Stream_Buffer(s), Stream_GetPosition(s));\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_SURFCMDS, update, FALSE);\nout:\n\tStream_Release(update);\n\treturn ret;\n}\n\nstatic BOOL update_send_surface_bits(rdpContext* context,\n                                     const SURFACE_BITS_COMMAND* surfaceBitsCommand)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\tupdate_force_flush(context);\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!update_write_surfcmd_surface_bits(s, surfaceBitsCommand))\n\t\tgoto out_fail;\n\n\tif (!fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_SURFCMDS, s,\n\t                              surfaceBitsCommand->skipCompression))\n\t\tgoto out_fail;\n\n\tupdate_force_flush(context);\n\tret = TRUE;\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_surface_frame_marker(rdpContext* context,\n                                             const SURFACE_FRAME_MARKER* surfaceFrameMarker)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\tupdate_force_flush(context);\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!update_write_surfcmd_frame_marker(s, surfaceFrameMarker->frameAction,\n\t                                       surfaceFrameMarker->frameId) ||\n\t    !fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_SURFCMDS, s, FALSE))\n\t\tgoto out_fail;\n\n\tupdate_force_flush(context);\n\tret = TRUE;\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_surface_frame_bits(rdpContext* context, const SURFACE_BITS_COMMAND* cmd,\n                                           BOOL first, BOOL last, UINT32 frameId)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\tupdate_force_flush(context);\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (first)\n\t{\n\t\tif (!update_write_surfcmd_frame_marker(s, SURFACECMD_FRAMEACTION_BEGIN, frameId))\n\t\t\tgoto out_fail;\n\t}\n\n\tif (!update_write_surfcmd_surface_bits(s, cmd))\n\t\tgoto out_fail;\n\n\tif (last)\n\t{\n\t\tif (!update_write_surfcmd_frame_marker(s, SURFACECMD_FRAMEACTION_END, frameId))\n\t\t\tgoto out_fail;\n\t}\n\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_SURFCMDS, s,\n\t                               cmd->skipCompression);\n\tupdate_force_flush(context);\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_frame_acknowledge(rdpContext* context, UINT32 frameId)\n{\n\trdpRdp* rdp = context->rdp;\n\n\tif (rdp->settings->ReceivedCapabilities[CAPSET_TYPE_FRAME_ACKNOWLEDGE])\n\t{\n\t\twStream* s = rdp_data_pdu_init(rdp);\n\n\t\tif (!s)\n\t\t\treturn FALSE;\n\n\t\tStream_Write_UINT32(s, frameId);\n\t\treturn rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_FRAME_ACKNOWLEDGE, rdp->mcs->userId);\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL update_send_synchronize(rdpContext* context)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_Zero(s, 2); /* pad2Octets (2 bytes) */\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_SYNCHRONIZE, s, FALSE);\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_desktop_resize(rdpContext* context)\n{\n\treturn rdp_server_reactivate(context->rdp);\n}\n\nstatic BOOL update_send_bitmap_update(rdpContext* context, const BITMAP_UPDATE* bitmapUpdate)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\trdpUpdate* update = context->update;\n\tBOOL ret = TRUE;\n\tupdate_force_flush(context);\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!update_write_bitmap_update(update, s, bitmapUpdate) ||\n\t    !fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_BITMAP, s,\n\t                              bitmapUpdate->skipCompression))\n\t{\n\t\tret = FALSE;\n\t\tgoto out_fail;\n\t}\n\n\tupdate_force_flush(context);\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_play_sound(rdpContext* context, const PLAY_SOUND_UPDATE* play_sound)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\n\tif (!rdp->settings->ReceivedCapabilities[CAPSET_TYPE_SOUND])\n\t{\n\t\treturn TRUE;\n\t}\n\n\ts = rdp_data_pdu_init(rdp);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_Write_UINT32(s, play_sound->duration);\n\tStream_Write_UINT32(s, play_sound->frequency);\n\treturn rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_PLAY_SOUND, rdp->mcs->userId);\n}\n\n/**\n * Primary Drawing Orders\n */\n\nstatic BOOL update_send_dstblt(rdpContext* context, const DSTBLT_ORDER* dstblt)\n{\n\twStream* s;\n\tUINT32 offset;\n\tUINT32 headerLength;\n\tORDER_INFO orderInfo;\n\tint inf;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo, ORDER_TYPE_DSTBLT);\n\tinf = update_approximate_dstblt_order(&orderInfo, dstblt);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_dstblt_order(s, &orderInfo, dstblt))\n\t\treturn FALSE;\n\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_patblt(rdpContext* context, PATBLT_ORDER* patblt)\n{\n\twStream* s;\n\tsize_t offset;\n\tint headerLength;\n\tORDER_INFO orderInfo;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo, ORDER_TYPE_PATBLT);\n\tupdate_check_flush(context, headerLength + update_approximate_patblt_order(&orderInfo, patblt));\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\tupdate_write_patblt_order(s, &orderInfo, patblt);\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_scrblt(rdpContext* context, const SCRBLT_ORDER* scrblt)\n{\n\twStream* s;\n\tUINT32 offset;\n\tUINT32 headerLength;\n\tORDER_INFO orderInfo;\n\tint inf;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo, ORDER_TYPE_SCRBLT);\n\tinf = update_approximate_scrblt_order(&orderInfo, scrblt);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn TRUE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\tupdate_write_scrblt_order(s, &orderInfo, scrblt);\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_opaque_rect(rdpContext* context, const OPAQUE_RECT_ORDER* opaque_rect)\n{\n\twStream* s;\n\tsize_t offset;\n\tint headerLength;\n\tORDER_INFO orderInfo;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo, ORDER_TYPE_OPAQUE_RECT);\n\tupdate_check_flush(context, headerLength +\n\t                                update_approximate_opaque_rect_order(&orderInfo, opaque_rect));\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\tupdate_write_opaque_rect_order(s, &orderInfo, opaque_rect);\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_line_to(rdpContext* context, const LINE_TO_ORDER* line_to)\n{\n\twStream* s;\n\tint offset;\n\tint headerLength;\n\tORDER_INFO orderInfo;\n\tint inf;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo, ORDER_TYPE_LINE_TO);\n\tinf = update_approximate_line_to_order(&orderInfo, line_to);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\tupdate_write_line_to_order(s, &orderInfo, line_to);\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_memblt(rdpContext* context, MEMBLT_ORDER* memblt)\n{\n\twStream* s;\n\tsize_t offset;\n\tint headerLength;\n\tORDER_INFO orderInfo;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo, ORDER_TYPE_MEMBLT);\n\tupdate_check_flush(context, headerLength + update_approximate_memblt_order(&orderInfo, memblt));\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\tupdate_write_memblt_order(s, &orderInfo, memblt);\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_glyph_index(rdpContext* context, GLYPH_INDEX_ORDER* glyph_index)\n{\n\twStream* s;\n\tsize_t offset;\n\tint headerLength;\n\tint inf;\n\tORDER_INFO orderInfo;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo, ORDER_TYPE_GLYPH_INDEX);\n\tinf = update_approximate_glyph_index_order(&orderInfo, glyph_index);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\tupdate_write_glyph_index_order(s, &orderInfo, glyph_index);\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\n/*\n * Secondary Drawing Orders\n */\n\nstatic BOOL update_send_cache_bitmap(rdpContext* context, const CACHE_BITMAP_ORDER* cache_bitmap)\n{\n\twStream* s;\n\tsize_t bm, em;\n\tBYTE orderType;\n\tint headerLength;\n\tint inf;\n\tUINT16 extraFlags;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\textraFlags = 0;\n\theaderLength = 6;\n\torderType = cache_bitmap->compressed ? ORDER_TYPE_CACHE_BITMAP_COMPRESSED\n\t                                     : ORDER_TYPE_BITMAP_UNCOMPRESSED;\n\tinf =\n\t    update_approximate_cache_bitmap_order(cache_bitmap, cache_bitmap->compressed, &extraFlags);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_bitmap_order(s, cache_bitmap, cache_bitmap->compressed, &extraFlags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD | ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength);                     /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, extraFlags);                      /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, orderType);                        /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_cache_bitmap_v2(rdpContext* context, CACHE_BITMAP_V2_ORDER* cache_bitmap_v2)\n{\n\twStream* s;\n\tsize_t bm, em;\n\tBYTE orderType;\n\tint headerLength;\n\tUINT16 extraFlags;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\textraFlags = 0;\n\theaderLength = 6;\n\torderType = cache_bitmap_v2->compressed ? ORDER_TYPE_BITMAP_COMPRESSED_V2\n\t                                        : ORDER_TYPE_BITMAP_UNCOMPRESSED_V2;\n\n\tif (context->settings->NoBitmapCompressionHeader)\n\t\tcache_bitmap_v2->flags |= CBR2_NO_BITMAP_COMPRESSION_HDR;\n\n\tupdate_check_flush(context, headerLength +\n\t                                update_approximate_cache_bitmap_v2_order(\n\t                                    cache_bitmap_v2, cache_bitmap_v2->compressed, &extraFlags));\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_bitmap_v2_order(s, cache_bitmap_v2, cache_bitmap_v2->compressed,\n\t                                        &extraFlags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD | ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength);                     /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, extraFlags);                      /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, orderType);                        /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_cache_bitmap_v3(rdpContext* context, CACHE_BITMAP_V3_ORDER* cache_bitmap_v3)\n{\n\twStream* s;\n\tsize_t bm, em;\n\tBYTE orderType;\n\tint headerLength;\n\tUINT16 extraFlags;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\textraFlags = 0;\n\theaderLength = 6;\n\torderType = ORDER_TYPE_BITMAP_COMPRESSED_V3;\n\tupdate_check_flush(context, headerLength + update_approximate_cache_bitmap_v3_order(\n\t                                               cache_bitmap_v3, &extraFlags));\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_bitmap_v3_order(s, cache_bitmap_v3, &extraFlags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD | ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength);                     /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, extraFlags);                      /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, orderType);                        /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_cache_color_table(rdpContext* context,\n                                          const CACHE_COLOR_TABLE_ORDER* cache_color_table)\n{\n\twStream* s;\n\tUINT16 flags;\n\tsize_t bm, em, inf;\n\tint headerLength;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\tflags = 0;\n\theaderLength = 6;\n\tinf = update_approximate_cache_color_table_order(cache_color_table, &flags);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_color_table_order(s, cache_color_table, &flags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD | ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength);                     /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, flags);                           /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, ORDER_TYPE_CACHE_COLOR_TABLE);     /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_cache_glyph(rdpContext* context, const CACHE_GLYPH_ORDER* cache_glyph)\n{\n\twStream* s;\n\tUINT16 flags;\n\tsize_t bm, em, inf;\n\tint headerLength;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\tflags = 0;\n\theaderLength = 6;\n\tinf = update_approximate_cache_glyph_order(cache_glyph, &flags);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_glyph_order(s, cache_glyph, &flags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD | ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength);                     /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, flags);                           /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, ORDER_TYPE_CACHE_GLYPH);           /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_cache_glyph_v2(rdpContext* context,\n                                       const CACHE_GLYPH_V2_ORDER* cache_glyph_v2)\n{\n\twStream* s;\n\tUINT16 flags;\n\tsize_t bm, em, inf;\n\tint headerLength;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\tflags = 0;\n\theaderLength = 6;\n\tinf = update_approximate_cache_glyph_v2_order(cache_glyph_v2, &flags);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_glyph_v2_order(s, cache_glyph_v2, &flags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD | ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength);                     /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, flags);                           /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, ORDER_TYPE_CACHE_GLYPH);           /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_cache_brush(rdpContext* context, const CACHE_BRUSH_ORDER* cache_brush)\n{\n\twStream* s;\n\tUINT16 flags;\n\tsize_t bm, em, inf;\n\tint headerLength;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\tflags = 0;\n\theaderLength = 6;\n\tinf = update_approximate_cache_brush_order(cache_brush, &flags);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_brush_order(s, cache_brush, &flags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD | ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength);                     /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, flags);                           /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, ORDER_TYPE_CACHE_BRUSH);           /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\n/**\n * Alternate Secondary Drawing Orders\n */\n\nstatic BOOL update_send_create_offscreen_bitmap_order(\n    rdpContext* context, const CREATE_OFFSCREEN_BITMAP_ORDER* create_offscreen_bitmap)\n{\n\twStream* s;\n\tsize_t bm, em, inf;\n\tBYTE orderType;\n\tBYTE controlFlags;\n\tint headerLength;\n\trdpUpdate* update = context->update;\n\theaderLength = 1;\n\torderType = ORDER_TYPE_CREATE_OFFSCREEN_BITMAP;\n\tcontrolFlags = ORDER_SECONDARY | (orderType << 2);\n\tinf = update_approximate_create_offscreen_bitmap_order(create_offscreen_bitmap);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_create_offscreen_bitmap_order(s, create_offscreen_bitmap))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, controlFlags); /* controlFlags (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_switch_surface_order(rdpContext* context,\n                                             const SWITCH_SURFACE_ORDER* switch_surface)\n{\n\twStream* s;\n\tsize_t bm, em, inf;\n\tBYTE orderType;\n\tBYTE controlFlags;\n\tint headerLength;\n\trdpUpdate* update;\n\n\tif (!context || !switch_surface || !context->update)\n\t\treturn FALSE;\n\n\tupdate = context->update;\n\theaderLength = 1;\n\torderType = ORDER_TYPE_SWITCH_SURFACE;\n\tcontrolFlags = ORDER_SECONDARY | (orderType << 2);\n\tinf = update_approximate_switch_surface_order(switch_surface);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_switch_surface_order(s, switch_surface))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, controlFlags); /* controlFlags (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_pointer_system(rdpContext* context,\n                                       const POINTER_SYSTEM_UPDATE* pointer_system)\n{\n\twStream* s;\n\tBYTE updateCode;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (pointer_system->type == SYSPTR_NULL)\n\t\tupdateCode = FASTPATH_UPDATETYPE_PTR_NULL;\n\telse\n\t\tupdateCode = FASTPATH_UPDATETYPE_PTR_DEFAULT;\n\n\tret = fastpath_send_update_pdu(rdp->fastpath, updateCode, s, FALSE);\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_pointer_position(rdpContext* context,\n                                         const POINTER_POSITION_UPDATE* pointerPosition)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 16))\n\t\tgoto out_fail;\n\n\tStream_Write_UINT16(s, pointerPosition->xPos); /* xPos (2 bytes) */\n\tStream_Write_UINT16(s, pointerPosition->yPos); /* yPos (2 bytes) */\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_PTR_POSITION, s, FALSE);\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_write_pointer_color(wStream* s, const POINTER_COLOR_UPDATE* pointer_color)\n{\n\tif (!Stream_EnsureRemainingCapacity(s, 32 + pointer_color->lengthAndMask +\n\t                                           pointer_color->lengthXorMask))\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, pointer_color->cacheIndex);\n\tStream_Write_UINT16(s, pointer_color->xPos);\n\tStream_Write_UINT16(s, pointer_color->yPos);\n\tStream_Write_UINT16(s, pointer_color->width);\n\tStream_Write_UINT16(s, pointer_color->height);\n\tStream_Write_UINT16(s, pointer_color->lengthAndMask);\n\tStream_Write_UINT16(s, pointer_color->lengthXorMask);\n\n\tif (pointer_color->lengthXorMask > 0)\n\t\tStream_Write(s, pointer_color->xorMaskData, pointer_color->lengthXorMask);\n\n\tif (pointer_color->lengthAndMask > 0)\n\t\tStream_Write(s, pointer_color->andMaskData, pointer_color->lengthAndMask);\n\n\tStream_Write_UINT8(s, 0); /* pad (1 byte) */\n\treturn TRUE;\n}\n\nstatic BOOL update_send_pointer_color(rdpContext* context,\n                                      const POINTER_COLOR_UPDATE* pointer_color)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!update_write_pointer_color(s, pointer_color))\n\t\tgoto out_fail;\n\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_COLOR, s, FALSE);\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_write_pointer_large(wStream* s, const POINTER_LARGE_UPDATE* pointer)\n{\n\tif (!Stream_EnsureRemainingCapacity(s, 32 + pointer->lengthAndMask + pointer->lengthXorMask))\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, pointer->xorBpp);\n\tStream_Write_UINT16(s, pointer->cacheIndex);\n\tStream_Write_UINT16(s, pointer->hotSpotX);\n\tStream_Write_UINT16(s, pointer->hotSpotY);\n\tStream_Write_UINT16(s, pointer->width);\n\tStream_Write_UINT16(s, pointer->height);\n\tStream_Write_UINT32(s, pointer->lengthAndMask);\n\tStream_Write_UINT32(s, pointer->lengthXorMask);\n\tStream_Write(s, pointer->xorMaskData, pointer->lengthXorMask);\n\tStream_Write(s, pointer->andMaskData, pointer->lengthAndMask);\n\tStream_Write_UINT8(s, 0); /* pad (1 byte) */\n\treturn TRUE;\n}\n\nstatic BOOL update_send_pointer_large(rdpContext* context, const POINTER_LARGE_UPDATE* pointer)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!update_write_pointer_large(s, pointer))\n\t\tgoto out_fail;\n\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_LARGE_POINTER, s, FALSE);\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_pointer_new(rdpContext* context, const POINTER_NEW_UPDATE* pointer_new)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 16))\n\t\tgoto out_fail;\n\n\tStream_Write_UINT16(s, pointer_new->xorBpp); /* xorBpp (2 bytes) */\n\tupdate_write_pointer_color(s, &pointer_new->colorPtrAttr);\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_POINTER, s, FALSE);\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_pointer_cached(rdpContext* context,\n                                       const POINTER_CACHED_UPDATE* pointer_cached)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, pointer_cached->cacheIndex); /* cacheIndex (2 bytes) */\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_CACHED, s, FALSE);\n\tStream_Release(s);\n\treturn ret;\n}\n\nBOOL update_read_refresh_rect(rdpUpdate* update, wStream* s)\n{\n\tint index;\n\tBYTE numberOfAreas;\n\tRECTANGLE_16* areas;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, numberOfAreas);\n\tStream_Seek(s, 3); /* pad3Octects */\n\n\tif (Stream_GetRemainingLength(s) < ((size_t)numberOfAreas * 4 * 2))\n\t\treturn FALSE;\n\n\tareas = (RECTANGLE_16*)calloc(numberOfAreas, sizeof(RECTANGLE_16));\n\n\tif (!areas)\n\t\treturn FALSE;\n\n\tfor (index = 0; index < numberOfAreas; index++)\n\t{\n\t\tStream_Read_UINT16(s, areas[index].left);\n\t\tStream_Read_UINT16(s, areas[index].top);\n\t\tStream_Read_UINT16(s, areas[index].right);\n\t\tStream_Read_UINT16(s, areas[index].bottom);\n\t}\n\n\tif (update->context->settings->RefreshRect)\n\t\tIFCALL(update->RefreshRect, update->context, numberOfAreas, areas);\n\telse\n\t\tWLog_Print(update->log, WLOG_WARN, \"ignoring refresh rect request from client\");\n\n\tfree(areas);\n\treturn TRUE;\n}\n\nBOOL update_read_suppress_output(rdpUpdate* update, wStream* s)\n{\n\tRECTANGLE_16* prect = NULL;\n\tRECTANGLE_16 rect = { 0 };\n\tBYTE allowDisplayUpdates;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, allowDisplayUpdates);\n\tStream_Seek(s, 3); /* pad3Octects */\n\n\tif (allowDisplayUpdates > 0)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < sizeof(RECTANGLE_16))\n\t\t\treturn FALSE;\n\t\tStream_Read_UINT16(s, rect.left);\n\t\tStream_Read_UINT16(s, rect.top);\n\t\tStream_Read_UINT16(s, rect.right);\n\t\tStream_Read_UINT16(s, rect.bottom);\n\n\t\tprect = &rect;\n\t}\n\n\tif (update->context->settings->SuppressOutput)\n\t\tIFCALL(update->SuppressOutput, update->context, allowDisplayUpdates, prect);\n\telse\n\t\tWLog_Print(update->log, WLOG_WARN, \"ignoring suppress output request from client\");\n\n\treturn TRUE;\n}\n\nstatic BOOL update_send_set_keyboard_indicators(rdpContext* context, UINT16 led_flags)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\ts = rdp_data_pdu_init(rdp);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, 0);         /* unitId should be 0 according to MS-RDPBCGR 2.2.8.2.1.1 */\n\tStream_Write_UINT16(s, led_flags); /* ledFlags (2 bytes) */\n\treturn rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_SET_KEYBOARD_INDICATORS, rdp->mcs->userId);\n}\n\nstatic BOOL update_send_set_keyboard_ime_status(rdpContext* context, UINT16 imeId, UINT32 imeState,\n                                                UINT32 imeConvMode)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\ts = rdp_data_pdu_init(rdp);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\t/* unitId should be 0 according to MS-RDPBCGR 2.2.8.2.2.1 */\n\tStream_Write_UINT16(s, imeId);\n\tStream_Write_UINT32(s, imeState);\n\tStream_Write_UINT32(s, imeConvMode);\n\treturn rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_SET_KEYBOARD_IME_STATUS, rdp->mcs->userId);\n}\n\nstatic UINT16 update_calculate_new_or_existing_window(const WINDOW_ORDER_INFO* orderInfo,\n                                                      const WINDOW_STATE_ORDER* stateOrder)\n{\n\tUINT16 orderSize = 11;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_OWNER) != 0)\n\t\torderSize += 4;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_STYLE) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_SHOW) != 0)\n\t\torderSize += 1;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_TITLE) != 0)\n\t\torderSize += 2 + stateOrder->titleInfo.length;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_CLIENT_AREA_OFFSET) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_CLIENT_AREA_SIZE) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RESIZE_MARGIN_X) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RESIZE_MARGIN_Y) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RP_CONTENT) != 0)\n\t\torderSize += 1;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_ROOT_PARENT) != 0)\n\t\torderSize += 4;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_OFFSET) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_CLIENT_DELTA) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_SIZE) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_RECTS) != 0)\n\t\torderSize += 2 + stateOrder->numWindowRects * sizeof(RECTANGLE_16);\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_VIS_OFFSET) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_VISIBILITY) != 0)\n\t\torderSize += 2 + stateOrder->numVisibilityRects * sizeof(RECTANGLE_16);\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_OVERLAY_DESCRIPTION) != 0)\n\t\torderSize += 2 + stateOrder->OverlayDescription.length;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_TASKBAR_BUTTON) != 0)\n\t\torderSize += 1;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_ENFORCE_SERVER_ZORDER) != 0)\n\t\torderSize += 1;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_APPBAR_STATE) != 0)\n\t\torderSize += 1;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_APPBAR_EDGE) != 0)\n\t\torderSize += 1;\n\n\treturn orderSize;\n}\n\nstatic BOOL update_send_new_or_existing_window(rdpContext* context,\n                                               const WINDOW_ORDER_INFO* orderInfo,\n                                               const WINDOW_STATE_ORDER* stateOrder)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\tBYTE controlFlags = ORDER_SECONDARY | (ORDER_TYPE_WINDOW << 2);\n\tUINT16 orderSize = update_calculate_new_or_existing_window(orderInfo, stateOrder);\n\n\tupdate_check_flush(context, orderSize);\n\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s, orderSize))\n\t\treturn FALSE;\n\n\tStream_Write_UINT8(s, controlFlags);           /* Header (1 byte) */\n\tStream_Write_UINT16(s, orderSize);             /* OrderSize (2 bytes) */\n\tStream_Write_UINT32(s, orderInfo->fieldFlags); /* FieldsPresentFlags (4 bytes) */\n\tStream_Write_UINT32(s, orderInfo->windowId);   /* WindowID (4 bytes) */\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_OWNER) != 0)\n\t\tStream_Write_UINT32(s, stateOrder->ownerWindowId);\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_STYLE) != 0)\n\t{\n\t\tStream_Write_UINT32(s, stateOrder->style);\n\t\tStream_Write_UINT32(s, stateOrder->extendedStyle);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_SHOW) != 0)\n\t{\n\t\tStream_Write_UINT8(s, stateOrder->showState);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_TITLE) != 0)\n\t{\n\t\tStream_Write_UINT16(s, stateOrder->titleInfo.length);\n\t\tStream_Write(s, stateOrder->titleInfo.string, stateOrder->titleInfo.length);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_CLIENT_AREA_OFFSET) != 0)\n\t{\n\t\tStream_Write_INT32(s, stateOrder->clientOffsetX);\n\t\tStream_Write_INT32(s, stateOrder->clientOffsetY);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_CLIENT_AREA_SIZE) != 0)\n\t{\n\t\tStream_Write_UINT32(s, stateOrder->clientAreaWidth);\n\t\tStream_Write_UINT32(s, stateOrder->clientAreaHeight);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RESIZE_MARGIN_X) != 0)\n\t{\n\t\tStream_Write_UINT32(s, stateOrder->resizeMarginLeft);\n\t\tStream_Write_UINT32(s, stateOrder->resizeMarginRight);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RESIZE_MARGIN_Y) != 0)\n\t{\n\t\tStream_Write_UINT32(s, stateOrder->resizeMarginTop);\n\t\tStream_Write_UINT32(s, stateOrder->resizeMarginBottom);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RP_CONTENT) != 0)\n\t{\n\t\tStream_Write_UINT8(s, stateOrder->RPContent);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_ROOT_PARENT) != 0)\n\t{\n\t\tStream_Write_UINT32(s, stateOrder->rootParentHandle);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_OFFSET) != 0)\n\t{\n\t\tStream_Write_INT32(s, stateOrder->windowOffsetX);\n\t\tStream_Write_INT32(s, stateOrder->windowOffsetY);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_CLIENT_DELTA) != 0)\n\t{\n\t\tStream_Write_INT32(s, stateOrder->windowClientDeltaX);\n\t\tStream_Write_INT32(s, stateOrder->windowClientDeltaY);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_SIZE) != 0)\n\t{\n\t\tStream_Write_UINT32(s, stateOrder->windowWidth);\n\t\tStream_Write_UINT32(s, stateOrder->windowHeight);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_RECTS) != 0)\n\t{\n\t\tStream_Write_UINT16(s, stateOrder->numWindowRects);\n\t\tStream_Write(s, stateOrder->windowRects, stateOrder->numWindowRects * sizeof(RECTANGLE_16));\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_VIS_OFFSET) != 0)\n\t{\n\t\tStream_Write_UINT32(s, stateOrder->visibleOffsetX);\n\t\tStream_Write_UINT32(s, stateOrder->visibleOffsetY);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_VISIBILITY) != 0)\n\t{\n\t\tStream_Write_UINT16(s, stateOrder->numVisibilityRects);\n\t\tStream_Write(s, stateOrder->visibilityRects,\n\t\t             stateOrder->numVisibilityRects * sizeof(RECTANGLE_16));\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_OVERLAY_DESCRIPTION) != 0)\n\t{\n\t\tStream_Write_UINT16(s, stateOrder->OverlayDescription.length);\n\t\tStream_Write(s, stateOrder->OverlayDescription.string,\n\t\t             stateOrder->OverlayDescription.length);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_TASKBAR_BUTTON) != 0)\n\t{\n\t\tStream_Write_UINT8(s, stateOrder->TaskbarButton);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_ENFORCE_SERVER_ZORDER) != 0)\n\t{\n\t\tStream_Write_UINT8(s, stateOrder->EnforceServerZOrder);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_APPBAR_STATE) != 0)\n\t{\n\t\tStream_Write_UINT8(s, stateOrder->AppBarState);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_APPBAR_EDGE) != 0)\n\t{\n\t\tStream_Write_UINT8(s, stateOrder->AppBarEdge);\n\t}\n\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_window_create(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,\n                                      const WINDOW_STATE_ORDER* stateOrder)\n{\n\treturn update_send_new_or_existing_window(context, orderInfo, stateOrder);\n}\n\nstatic BOOL update_send_window_update(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,\n                                      const WINDOW_STATE_ORDER* stateOrder)\n{\n\treturn update_send_new_or_existing_window(context, orderInfo, stateOrder);\n}\n\nstatic UINT16 update_calculate_window_icon_order(const WINDOW_ORDER_INFO* orderInfo,\n                                                 const WINDOW_ICON_ORDER* iconOrder)\n{\n\tUINT16 orderSize = 23;\n\tICON_INFO* iconInfo = iconOrder->iconInfo;\n\n\torderSize += iconInfo->cbBitsColor + iconInfo->cbBitsMask;\n\n\tif (iconInfo->bpp <= 8)\n\t\torderSize += 2 + iconInfo->cbColorTable;\n\n\treturn orderSize;\n}\n\nstatic BOOL update_send_window_icon(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,\n                                    const WINDOW_ICON_ORDER* iconOrder)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\tBYTE controlFlags = ORDER_SECONDARY | (ORDER_TYPE_WINDOW << 2);\n\tICON_INFO* iconInfo = iconOrder->iconInfo;\n\tUINT16 orderSize = update_calculate_window_icon_order(orderInfo, iconOrder);\n\n\tupdate_check_flush(context, orderSize);\n\n\ts = update->us;\n\n\tif (!s || !iconInfo)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s, orderSize))\n\t\treturn FALSE;\n\n\t/* Write Hdr */\n\tStream_Write_UINT8(s, controlFlags);           /* Header (1 byte) */\n\tStream_Write_UINT16(s, orderSize);             /* OrderSize (2 bytes) */\n\tStream_Write_UINT32(s, orderInfo->fieldFlags); /* FieldsPresentFlags (4 bytes) */\n\tStream_Write_UINT32(s, orderInfo->windowId);   /* WindowID (4 bytes) */\n\t/* Write body */\n\tStream_Write_UINT16(s, iconInfo->cacheEntry); /* CacheEntry (2 bytes) */\n\tStream_Write_UINT8(s, iconInfo->cacheId);     /* CacheId (1 byte) */\n\tStream_Write_UINT8(s, iconInfo->bpp);         /* Bpp (1 byte) */\n\tStream_Write_UINT16(s, iconInfo->width);      /* Width (2 bytes) */\n\tStream_Write_UINT16(s, iconInfo->height);     /* Height (2 bytes) */\n\n\tif (iconInfo->bpp <= 8)\n\t{\n\t\tStream_Write_UINT16(s, iconInfo->cbColorTable); /* CbColorTable (2 bytes) */\n\t}\n\n\tStream_Write_UINT16(s, iconInfo->cbBitsMask);              /* CbBitsMask (2 bytes) */\n\tStream_Write_UINT16(s, iconInfo->cbBitsColor);             /* CbBitsColor (2 bytes) */\n\tStream_Write(s, iconInfo->bitsMask, iconInfo->cbBitsMask); /* BitsMask (variable) */\n\n\tif (iconInfo->bpp <= 8)\n\t{\n\t\tStream_Write(s, iconInfo->colorTable, iconInfo->cbColorTable); /* ColorTable (variable) */\n\t}\n\n\tStream_Write(s, iconInfo->bitsColor, iconInfo->cbBitsColor); /* BitsColor (variable) */\n\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_window_cached_icon(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,\n                                           const WINDOW_CACHED_ICON_ORDER* cachedIconOrder)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\tBYTE controlFlags = ORDER_SECONDARY | (ORDER_TYPE_WINDOW << 2);\n\tUINT16 orderSize = 14;\n\tCACHED_ICON_INFO cachedIcon = cachedIconOrder->cachedIcon;\n\n\tupdate_check_flush(context, orderSize);\n\n\ts = update->us;\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s, orderSize))\n\t\treturn FALSE;\n\n\t/* Write Hdr */\n\tStream_Write_UINT8(s, controlFlags);           /* Header (1 byte) */\n\tStream_Write_UINT16(s, orderSize);             /* OrderSize (2 bytes) */\n\tStream_Write_UINT32(s, orderInfo->fieldFlags); /* FieldsPresentFlags (4 bytes) */\n\tStream_Write_UINT32(s, orderInfo->windowId);   /* WindowID (4 bytes) */\n\t/* Write body */\n\tStream_Write_UINT16(s, cachedIcon.cacheEntry); /* CacheEntry (2 bytes) */\n\tStream_Write_UINT8(s, cachedIcon.cacheId);     /* CacheId (1 byte) */\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_window_delete(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\tBYTE controlFlags = ORDER_SECONDARY | (ORDER_TYPE_WINDOW << 2);\n\tUINT16 orderSize = 11;\n\tupdate_check_flush(context, orderSize);\n\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s, orderSize))\n\t\treturn FALSE;\n\n\t/* Write Hdr */\n\tStream_Write_UINT8(s, controlFlags);           /* Header (1 byte) */\n\tStream_Write_UINT16(s, orderSize);             /* OrderSize (2 bytes) */\n\tStream_Write_UINT32(s, orderInfo->fieldFlags); /* FieldsPresentFlags (4 bytes) */\n\tStream_Write_UINT32(s, orderInfo->windowId);   /* WindowID (4 bytes) */\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic UINT16 update_calculate_new_or_existing_notification_icons_order(\n    const WINDOW_ORDER_INFO* orderInfo, const NOTIFY_ICON_STATE_ORDER* iconStateOrder)\n{\n\tUINT16 orderSize = 15;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_VERSION) != 0)\n\t\torderSize += 4;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_TIP) != 0)\n\t{\n\t\torderSize += 2 + iconStateOrder->toolTip.length;\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_INFO_TIP) != 0)\n\t{\n\t\tNOTIFY_ICON_INFOTIP infoTip = iconStateOrder->infoTip;\n\t\torderSize += 12 + infoTip.text.length + infoTip.title.length;\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_STATE) != 0)\n\t{\n\t\torderSize += 4;\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_ICON) != 0)\n\t{\n\t\tICON_INFO iconInfo = iconStateOrder->icon;\n\t\torderSize += 12;\n\n\t\tif (iconInfo.bpp <= 8)\n\t\t\torderSize += 2 + iconInfo.cbColorTable;\n\n\t\torderSize += iconInfo.cbBitsMask + iconInfo.cbBitsColor;\n\t}\n\telse if ((orderInfo->fieldFlags & WINDOW_ORDER_CACHED_ICON) != 0)\n\t{\n\t\torderSize += 3;\n\t}\n\n\treturn orderSize;\n}\n\nstatic BOOL\nupdate_send_new_or_existing_notification_icons(rdpContext* context,\n                                               const WINDOW_ORDER_INFO* orderInfo,\n                                               const NOTIFY_ICON_STATE_ORDER* iconStateOrder)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\tBYTE controlFlags = ORDER_SECONDARY | (ORDER_TYPE_WINDOW << 2);\n\tBOOL versionFieldPresent = FALSE;\n\tUINT16 orderSize =\n\t    update_calculate_new_or_existing_notification_icons_order(orderInfo, iconStateOrder);\n\n\tupdate_check_flush(context, orderSize);\n\n\ts = update->us;\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s, orderSize))\n\t\treturn FALSE;\n\n\t/* Write Hdr */\n\tStream_Write_UINT8(s, controlFlags);             /* Header (1 byte) */\n\tStream_Write_INT16(s, orderSize);                /* OrderSize (2 bytes) */\n\tStream_Write_UINT32(s, orderInfo->fieldFlags);   /* FieldsPresentFlags (4 bytes) */\n\tStream_Write_UINT32(s, orderInfo->windowId);     /* WindowID (4 bytes) */\n\tStream_Write_UINT32(s, orderInfo->notifyIconId); /* NotifyIconId (4 bytes) */\n\n\t/* Write body */\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_VERSION) != 0)\n\t{\n\t\tversionFieldPresent = TRUE;\n\t\tStream_Write_UINT32(s, iconStateOrder->version);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_TIP) != 0)\n\t{\n\t\tStream_Write_UINT16(s, iconStateOrder->toolTip.length);\n\t\tStream_Write(s, iconStateOrder->toolTip.string, iconStateOrder->toolTip.length);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_INFO_TIP) != 0)\n\t{\n\t\tNOTIFY_ICON_INFOTIP infoTip = iconStateOrder->infoTip;\n\n\t\t/* info tip should not be sent when version is 0 */\n\t\tif (versionFieldPresent && iconStateOrder->version == 0)\n\t\t\treturn FALSE;\n\n\t\tStream_Write_UINT32(s, infoTip.timeout);     /* Timeout (4 bytes) */\n\t\tStream_Write_UINT32(s, infoTip.flags);       /* InfoFlags (4 bytes) */\n\t\tStream_Write_UINT16(s, infoTip.text.length); /* InfoTipText (variable) */\n\t\tStream_Write(s, infoTip.text.string, infoTip.text.length);\n\t\tStream_Write_UINT16(s, infoTip.title.length); /* Title (variable) */\n\t\tStream_Write(s, infoTip.title.string, infoTip.title.length);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_STATE) != 0)\n\t{\n\t\t/* notify state should not be sent when version is 0 */\n\t\tif (versionFieldPresent && iconStateOrder->version == 0)\n\t\t\treturn FALSE;\n\n\t\tStream_Write_UINT32(s, iconStateOrder->state);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_ICON) != 0)\n\t{\n\t\tICON_INFO iconInfo = iconStateOrder->icon;\n\t\tStream_Write_UINT16(s, iconInfo.cacheEntry); /* CacheEntry (2 bytes) */\n\t\tStream_Write_UINT8(s, iconInfo.cacheId);     /* CacheId (1 byte) */\n\t\tStream_Write_UINT8(s, iconInfo.bpp);         /* Bpp (1 byte) */\n\t\tStream_Write_UINT16(s, iconInfo.width);      /* Width (2 bytes) */\n\t\tStream_Write_UINT16(s, iconInfo.height);     /* Height (2 bytes) */\n\n\t\tif (iconInfo.bpp <= 8)\n\t\t{\n\t\t\tStream_Write_UINT16(s, iconInfo.cbColorTable); /* CbColorTable (2 bytes) */\n\t\t}\n\n\t\tStream_Write_UINT16(s, iconInfo.cbBitsMask);             /* CbBitsMask (2 bytes) */\n\t\tStream_Write_UINT16(s, iconInfo.cbBitsColor);            /* CbBitsColor (2 bytes) */\n\t\tStream_Write(s, iconInfo.bitsMask, iconInfo.cbBitsMask); /* BitsMask (variable) */\n\t\torderSize += iconInfo.cbBitsMask;\n\n\t\tif (iconInfo.bpp <= 8)\n\t\t{\n\t\t\tStream_Write(s, iconInfo.colorTable, iconInfo.cbColorTable); /* ColorTable (variable) */\n\t\t}\n\n\t\tStream_Write(s, iconInfo.bitsColor, iconInfo.cbBitsColor); /* BitsColor (variable) */\n\t}\n\telse if ((orderInfo->fieldFlags & WINDOW_ORDER_CACHED_ICON) != 0)\n\t{\n\t\tCACHED_ICON_INFO cachedIcon = iconStateOrder->cachedIcon;\n\t\tStream_Write_UINT16(s, cachedIcon.cacheEntry); /* CacheEntry (2 bytes) */\n\t\tStream_Write_UINT8(s, cachedIcon.cacheId);     /* CacheId (1 byte) */\n\t}\n\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_notify_icon_create(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,\n                                           const NOTIFY_ICON_STATE_ORDER* iconStateOrder)\n{\n\treturn update_send_new_or_existing_notification_icons(context, orderInfo, iconStateOrder);\n}\n\nstatic BOOL update_send_notify_icon_update(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,\n                                           const NOTIFY_ICON_STATE_ORDER* iconStateOrder)\n{\n\treturn update_send_new_or_existing_notification_icons(context, orderInfo, iconStateOrder);\n}\n\nstatic BOOL update_send_notify_icon_delete(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\tBYTE controlFlags = ORDER_SECONDARY | (ORDER_TYPE_WINDOW << 2);\n\tUINT16 orderSize = 15;\n\tupdate_check_flush(context, orderSize);\n\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\t/* Write Hdr */\n\tStream_Write_UINT8(s, controlFlags);             /* Header (1 byte) */\n\tStream_Write_UINT16(s, orderSize);               /* OrderSize (2 bytes) */\n\tStream_Write_UINT32(s, orderInfo->fieldFlags);   /* FieldsPresentFlags (4 bytes) */\n\tStream_Write_UINT32(s, orderInfo->windowId);     /* WindowID (4 bytes) */\n\tStream_Write_UINT32(s, orderInfo->notifyIconId); /* NotifyIconId (4 bytes) */\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic UINT16 update_calculate_monitored_desktop(const WINDOW_ORDER_INFO* orderInfo,\n                                                 const MONITORED_DESKTOP_ORDER* monitoredDesktop)\n{\n\tUINT16 orderSize = 7;\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_DESKTOP_ACTIVE_WND)\n\t{\n\t\torderSize += 4;\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_DESKTOP_ZORDER)\n\t{\n\t\torderSize += 1 + (4 * monitoredDesktop->numWindowIds);\n\t}\n\n\treturn orderSize;\n}\n\nstatic BOOL update_send_monitored_desktop(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,\n                                          const MONITORED_DESKTOP_ORDER* monitoredDesktop)\n{\n\tUINT32 i;\n\twStream* s;\n\trdpUpdate* update = context->update;\n\tBYTE controlFlags = ORDER_SECONDARY | (ORDER_TYPE_WINDOW << 2);\n\tUINT16 orderSize = update_calculate_monitored_desktop(orderInfo, monitoredDesktop);\n\tupdate_check_flush(context, orderSize);\n\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_Write_UINT8(s, controlFlags);           /* Header (1 byte) */\n\tStream_Write_UINT16(s, orderSize);             /* OrderSize (2 bytes) */\n\tStream_Write_UINT32(s, orderInfo->fieldFlags); /* FieldsPresentFlags (4 bytes) */\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_DESKTOP_ACTIVE_WND)\n\t{\n\t\tStream_Write_UINT32(s, monitoredDesktop->activeWindowId); /* activeWindowId (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_DESKTOP_ZORDER)\n\t{\n\t\tStream_Write_UINT8(s, monitoredDesktop->numWindowIds); /* numWindowIds (1 byte) */\n\n\t\t/* windowIds */\n\t\tfor (i = 0; i < monitoredDesktop->numWindowIds; i++)\n\t\t{\n\t\t\tStream_Write_UINT32(s, monitoredDesktop->windowIds[i]);\n\t\t}\n\t}\n\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_non_monitored_desktop(rdpContext* context,\n                                              const WINDOW_ORDER_INFO* orderInfo)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\tBYTE controlFlags = ORDER_SECONDARY | (ORDER_TYPE_WINDOW << 2);\n\tUINT16 orderSize = 7;\n\tupdate_check_flush(context, orderSize);\n\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_Write_UINT8(s, controlFlags);           /* Header (1 byte) */\n\tStream_Write_UINT16(s, orderSize);             /* OrderSize (2 bytes) */\n\tStream_Write_UINT32(s, orderInfo->fieldFlags); /* FieldsPresentFlags (4 bytes) */\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nvoid update_register_server_callbacks(rdpUpdate* update)\n{\n\tupdate->BeginPaint = _update_begin_paint;\n\tupdate->EndPaint = _update_end_paint;\n\tupdate->SetBounds = update_set_bounds;\n\tupdate->Synchronize = update_send_synchronize;\n\tupdate->DesktopResize = update_send_desktop_resize;\n\tupdate->BitmapUpdate = update_send_bitmap_update;\n\tupdate->SurfaceBits = update_send_surface_bits;\n\tupdate->SurfaceFrameMarker = update_send_surface_frame_marker;\n\tupdate->SurfaceCommand = update_send_surface_command;\n\tupdate->SurfaceFrameBits = update_send_surface_frame_bits;\n\tupdate->PlaySound = update_send_play_sound;\n\tupdate->SetKeyboardIndicators = update_send_set_keyboard_indicators;\n\tupdate->SetKeyboardImeStatus = update_send_set_keyboard_ime_status;\n\tupdate->SaveSessionInfo = rdp_send_save_session_info;\n\tupdate->ServerStatusInfo = rdp_send_server_status_info;\n\tupdate->primary->DstBlt = update_send_dstblt;\n\tupdate->primary->PatBlt = update_send_patblt;\n\tupdate->primary->ScrBlt = update_send_scrblt;\n\tupdate->primary->OpaqueRect = update_send_opaque_rect;\n\tupdate->primary->LineTo = update_send_line_to;\n\tupdate->primary->MemBlt = update_send_memblt;\n\tupdate->primary->GlyphIndex = update_send_glyph_index;\n\tupdate->secondary->CacheBitmap = update_send_cache_bitmap;\n\tupdate->secondary->CacheBitmapV2 = update_send_cache_bitmap_v2;\n\tupdate->secondary->CacheBitmapV3 = update_send_cache_bitmap_v3;\n\tupdate->secondary->CacheColorTable = update_send_cache_color_table;\n\tupdate->secondary->CacheGlyph = update_send_cache_glyph;\n\tupdate->secondary->CacheGlyphV2 = update_send_cache_glyph_v2;\n\tupdate->secondary->CacheBrush = update_send_cache_brush;\n\tupdate->altsec->CreateOffscreenBitmap = update_send_create_offscreen_bitmap_order;\n\tupdate->altsec->SwitchSurface = update_send_switch_surface_order;\n\tupdate->pointer->PointerSystem = update_send_pointer_system;\n\tupdate->pointer->PointerPosition = update_send_pointer_position;\n\tupdate->pointer->PointerColor = update_send_pointer_color;\n\tupdate->pointer->PointerLarge = update_send_pointer_large;\n\tupdate->pointer->PointerNew = update_send_pointer_new;\n\tupdate->pointer->PointerCached = update_send_pointer_cached;\n\tupdate->window->WindowCreate = update_send_window_create;\n\tupdate->window->WindowUpdate = update_send_window_update;\n\tupdate->window->WindowIcon = update_send_window_icon;\n\tupdate->window->WindowCachedIcon = update_send_window_cached_icon;\n\tupdate->window->WindowDelete = update_send_window_delete;\n\tupdate->window->NotifyIconCreate = update_send_notify_icon_create;\n\tupdate->window->NotifyIconUpdate = update_send_notify_icon_update;\n\tupdate->window->NotifyIconDelete = update_send_notify_icon_delete;\n\tupdate->window->MonitoredDesktop = update_send_monitored_desktop;\n\tupdate->window->NonMonitoredDesktop = update_send_non_monitored_desktop;\n}\n\nvoid update_register_client_callbacks(rdpUpdate* update)\n{\n\tupdate->RefreshRect = update_send_refresh_rect;\n\tupdate->SuppressOutput = update_send_suppress_output;\n\tupdate->SurfaceFrameAcknowledge = update_send_frame_acknowledge;\n}\n\nint update_process_messages(rdpUpdate* update)\n{\n\treturn update_message_queue_process_pending_messages(update);\n}\n\nstatic void update_free_queued_message(void* obj)\n{\n\twMessage* msg = (wMessage*)obj;\n\tupdate_message_queue_free_message(msg);\n}\n\nvoid update_free_window_state(WINDOW_STATE_ORDER* window_state)\n{\n\tif (!window_state)\n\t\treturn;\n\n\tfree(window_state->OverlayDescription.string);\n\tfree(window_state->titleInfo.string);\n\tfree(window_state->windowRects);\n\tfree(window_state->visibilityRects);\n\tmemset(window_state, 0, sizeof(WINDOW_STATE_ORDER));\n}\n\nrdpUpdate* update_new(rdpRdp* rdp)\n{\n\tconst wObject cb = { NULL, NULL, NULL, update_free_queued_message, NULL };\n\trdpUpdate* update;\n\tOFFSCREEN_DELETE_LIST* deleteList;\n\tWINPR_UNUSED(rdp);\n\tupdate = (rdpUpdate*)calloc(1, sizeof(rdpUpdate));\n\n\tif (!update)\n\t\treturn NULL;\n\n\tupdate->log = WLog_Get(\"com.freerdp.core.update\");\n\tInitializeCriticalSection(&(update->mux));\n\tupdate->pointer = (rdpPointerUpdate*)calloc(1, sizeof(rdpPointerUpdate));\n\n\tif (!update->pointer)\n\t\tgoto fail;\n\n\tupdate->primary = (rdpPrimaryUpdate*)calloc(1, sizeof(rdpPrimaryUpdate));\n\n\tif (!update->primary)\n\t\tgoto fail;\n\n\tupdate->secondary = (rdpSecondaryUpdate*)calloc(1, sizeof(rdpSecondaryUpdate));\n\n\tif (!update->secondary)\n\t\tgoto fail;\n\n\tupdate->altsec = (rdpAltSecUpdate*)calloc(1, sizeof(rdpAltSecUpdate));\n\n\tif (!update->altsec)\n\t\tgoto fail;\n\n\tupdate->window = (rdpWindowUpdate*)calloc(1, sizeof(rdpWindowUpdate));\n\n\tif (!update->window)\n\t\tgoto fail;\n\n\tdeleteList = &(update->altsec->create_offscreen_bitmap.deleteList);\n\tdeleteList->sIndices = 64;\n\tdeleteList->indices = calloc(deleteList->sIndices, 2);\n\n\tif (!deleteList->indices)\n\t\tgoto fail;\n\n\tdeleteList->cIndices = 0;\n\tupdate->SuppressOutput = update_send_suppress_output;\n\tupdate->initialState = TRUE;\n\tupdate->autoCalculateBitmapData = TRUE;\n\tupdate->queue = MessageQueue_New(&cb);\n\n\tif (!update->queue)\n\t\tgoto fail;\n\n\treturn update;\nfail:\n\tupdate_free(update);\n\treturn NULL;\n}\n\nvoid update_free(rdpUpdate* update)\n{\n\tif (update != NULL)\n\t{\n\t\tOFFSCREEN_DELETE_LIST* deleteList = &(update->altsec->create_offscreen_bitmap.deleteList);\n\n\t\tif (deleteList)\n\t\t\tfree(deleteList->indices);\n\n\t\tfree(update->pointer);\n\n\t\tif (update->primary)\n\t\t{\n\t\t\tfree(update->primary->polyline.points);\n\t\t\tfree(update->primary->polygon_sc.points);\n\t\t\tfree(update->primary->fast_glyph.glyphData.aj);\n\t\t\tfree(update->primary);\n\t\t}\n\n\t\tfree(update->secondary);\n\t\tfree(update->altsec);\n\n\t\tif (update->window)\n\t\t{\n\t\t\tfree(update->window);\n\t\t}\n\n\t\tMessageQueue_Free(update->queue);\n\t\tDeleteCriticalSection(&update->mux);\n\t\tfree(update);\n\t}\n}\n\nBOOL update_begin_paint(rdpUpdate* update)\n{\n\tif (!update)\n\t\treturn FALSE;\n\n\tEnterCriticalSection(&update->mux);\n\n\tif (!update->BeginPaint)\n\t\treturn TRUE;\n\n\treturn update->BeginPaint(update->context);\n}\n\nBOOL update_end_paint(rdpUpdate* update)\n{\n\tBOOL rc = FALSE;\n\n\tif (!update)\n\t\treturn FALSE;\n\n\tif (update->EndPaint)\n\t\trc = update->EndPaint(update->context);\n\n\tLeaveCriticalSection(&update->mux);\n\treturn rc;\n}\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * Windowing Alternate Secondary Orders\n *\n * Copyright 2011 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2011 Roman Barabanov <romanbarabanov@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <winpr/crt.h>\n\n#include <freerdp/log.h>\n\n#include \"window.h\"\n\n#define TAG FREERDP_TAG(\"core.window\")\n\nstatic void update_free_window_icon_info(ICON_INFO* iconInfo);\n\nBOOL rail_read_unicode_string(wStream* s, RAIL_UNICODE_STRING* unicode_string)\n{\n\tUINT16 new_len;\n\tBYTE* new_str;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, new_len); /* cbString (2 bytes) */\n\n\tif (Stream_GetRemainingLength(s) < new_len)\n\t\treturn FALSE;\n\n\tif (!new_len)\n\t{\n\t\tfree(unicode_string->string);\n\t\tunicode_string->string = NULL;\n\t\tunicode_string->length = 0;\n\t\treturn TRUE;\n\t}\n\n\tnew_str = (BYTE*)realloc(unicode_string->string, new_len);\n\n\tif (!new_str)\n\t{\n\t\tfree(unicode_string->string);\n\t\tunicode_string->string = NULL;\n\t\treturn FALSE;\n\t}\n\n\tunicode_string->string = new_str;\n\tunicode_string->length = new_len;\n\tStream_Read(s, unicode_string->string, unicode_string->length);\n\treturn TRUE;\n}\n\nBOOL utf8_string_to_rail_string(const char* string, RAIL_UNICODE_STRING* unicode_string)\n{\n\tWCHAR* buffer = NULL;\n\tint length = 0;\n\tfree(unicode_string->string);\n\tunicode_string->string = NULL;\n\tunicode_string->length = 0;\n\n\tif (!string || strlen(string) < 1)\n\t\treturn TRUE;\n\n\tlength = ConvertToUnicode(CP_UTF8, 0, string, -1, &buffer, 0);\n\n\tif ((length < 0) || ((size_t)length * sizeof(WCHAR) > UINT16_MAX))\n\t{\n\t\tfree(buffer);\n\t\treturn FALSE;\n\t}\n\n\tunicode_string->string = (BYTE*)buffer;\n\tunicode_string->length = (UINT16)length * sizeof(WCHAR);\n\treturn TRUE;\n}\n\n/* See [MS-RDPERP] 2.2.1.2.3 Icon Info (TS_ICON_INFO) */\nstatic BOOL update_read_icon_info(wStream* s, ICON_INFO* iconInfo)\n{\n\tBYTE* newBitMask;\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, iconInfo->cacheEntry); /* cacheEntry (2 bytes) */\n\tStream_Read_UINT8(s, iconInfo->cacheId);     /* cacheId (1 byte) */\n\tStream_Read_UINT8(s, iconInfo->bpp);         /* bpp (1 byte) */\n\n\tif ((iconInfo->bpp < 1) || (iconInfo->bpp > 32))\n\t{\n\t\tWLog_ERR(TAG, \"invalid bpp value %\" PRIu32 \"\", iconInfo->bpp);\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, iconInfo->width);  /* width (2 bytes) */\n\tStream_Read_UINT16(s, iconInfo->height); /* height (2 bytes) */\n\n\t/* cbColorTable is only present when bpp is 1, 4 or 8 */\n\tswitch (iconInfo->bpp)\n\t{\n\t\tcase 1:\n\t\tcase 4:\n\t\tcase 8:\n\t\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\t\treturn FALSE;\n\n\t\t\tStream_Read_UINT16(s, iconInfo->cbColorTable); /* cbColorTable (2 bytes) */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\ticonInfo->cbColorTable = 0;\n\t\t\tbreak;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, iconInfo->cbBitsMask);  /* cbBitsMask (2 bytes) */\n\tStream_Read_UINT16(s, iconInfo->cbBitsColor); /* cbBitsColor (2 bytes) */\n\n\tif (Stream_GetRemainingLength(s) < iconInfo->cbBitsMask + iconInfo->cbBitsColor)\n\t\treturn FALSE;\n\n\t/* bitsMask */\n\tnewBitMask = (BYTE*)realloc(iconInfo->bitsMask, iconInfo->cbBitsMask);\n\n\tif (!newBitMask)\n\t{\n\t\tfree(iconInfo->bitsMask);\n\t\ticonInfo->bitsMask = NULL;\n\t\treturn FALSE;\n\t}\n\n\ticonInfo->bitsMask = newBitMask;\n\tStream_Read(s, iconInfo->bitsMask, iconInfo->cbBitsMask);\n\n\t/* colorTable */\n\tif (iconInfo->colorTable == NULL)\n\t{\n\t\tif (iconInfo->cbColorTable)\n\t\t{\n\t\t\ticonInfo->colorTable = (BYTE*)malloc(iconInfo->cbColorTable);\n\n\t\t\tif (!iconInfo->colorTable)\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\telse if (iconInfo->cbColorTable)\n\t{\n\t\tBYTE* new_tab;\n\t\tnew_tab = (BYTE*)realloc(iconInfo->colorTable, iconInfo->cbColorTable);\n\n\t\tif (!new_tab)\n\t\t{\n\t\t\tfree(iconInfo->colorTable);\n\t\t\ticonInfo->colorTable = NULL;\n\t\t\treturn FALSE;\n\t\t}\n\n\t\ticonInfo->colorTable = new_tab;\n\t}\n\telse\n\t{\n\t\tfree(iconInfo->colorTable);\n\t\ticonInfo->colorTable = NULL;\n\t}\n\n\tif (iconInfo->colorTable)\n\t\tStream_Read(s, iconInfo->colorTable, iconInfo->cbColorTable);\n\n\t/* bitsColor */\n\tnewBitMask = (BYTE*)realloc(iconInfo->bitsColor, iconInfo->cbBitsColor);\n\n\tif (!newBitMask)\n\t{\n\t\tfree(iconInfo->bitsColor);\n\t\ticonInfo->bitsColor = NULL;\n\t\treturn FALSE;\n\t}\n\n\ticonInfo->bitsColor = newBitMask;\n\tStream_Read(s, iconInfo->bitsColor, iconInfo->cbBitsColor);\n\treturn TRUE;\n}\n\nstatic BOOL update_read_cached_icon_info(wStream* s, CACHED_ICON_INFO* cachedIconInfo)\n{\n\tif (Stream_GetRemainingLength(s) < 3)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, cachedIconInfo->cacheEntry); /* cacheEntry (2 bytes) */\n\tStream_Read_UINT8(s, cachedIconInfo->cacheId);     /* cacheId (1 byte) */\n\treturn TRUE;\n}\n\nstatic BOOL update_read_notify_icon_infotip(wStream* s, NOTIFY_ICON_INFOTIP* notifyIconInfoTip)\n{\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, notifyIconInfoTip->timeout);              /* timeout (4 bytes) */\n\tStream_Read_UINT32(s, notifyIconInfoTip->flags);                /* infoFlags (4 bytes) */\n\treturn rail_read_unicode_string(s, &notifyIconInfoTip->text) && /* infoTipText */\n\t       rail_read_unicode_string(s, &notifyIconInfoTip->title);  /* title */\n}\n\nstatic BOOL update_read_window_state_order(wStream* s, WINDOW_ORDER_INFO* orderInfo,\n                                           WINDOW_STATE_ORDER* windowState)\n{\n\tUINT32 i;\n\tsize_t size;\n\tRECTANGLE_16* newRect;\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_OWNER)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 4)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT32(s, windowState->ownerWindowId); /* ownerWindowId (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_STYLE)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT32(s, windowState->style);         /* style (4 bytes) */\n\t\tStream_Read_UINT32(s, windowState->extendedStyle); /* extendedStyle (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_SHOW)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, windowState->showState); /* showState (1 byte) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_TITLE)\n\t{\n\t\tif (!rail_read_unicode_string(s, &windowState->titleInfo)) /* titleInfo */\n\t\t\treturn FALSE;\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_CLIENT_AREA_OFFSET)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_INT32(s, windowState->clientOffsetX); /* clientOffsetX (4 bytes) */\n\t\tStream_Read_INT32(s, windowState->clientOffsetY); /* clientOffsetY (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_CLIENT_AREA_SIZE)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT32(s, windowState->clientAreaWidth);  /* clientAreaWidth (4 bytes) */\n\t\tStream_Read_UINT32(s, windowState->clientAreaHeight); /* clientAreaHeight (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RESIZE_MARGIN_X)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT32(s, windowState->resizeMarginLeft);\n\t\tStream_Read_UINT32(s, windowState->resizeMarginRight);\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RESIZE_MARGIN_Y)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT32(s, windowState->resizeMarginTop);\n\t\tStream_Read_UINT32(s, windowState->resizeMarginBottom);\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RP_CONTENT)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, windowState->RPContent); /* RPContent (1 byte) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_ROOT_PARENT)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 4)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT32(s, windowState->rootParentHandle); /* rootParentHandle (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_OFFSET)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_INT32(s, windowState->windowOffsetX); /* windowOffsetX (4 bytes) */\n\t\tStream_Read_INT32(s, windowState->windowOffsetY); /* windowOffsetY (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_CLIENT_DELTA)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_INT32(s, windowState->windowClientDeltaX); /* windowClientDeltaX (4 bytes) */\n\t\tStream_Read_INT32(s, windowState->windowClientDeltaY); /* windowClientDeltaY (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_SIZE)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT32(s, windowState->windowWidth);  /* windowWidth (4 bytes) */\n\t\tStream_Read_UINT32(s, windowState->windowHeight); /* windowHeight (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_RECTS)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, windowState->numWindowRects); /* numWindowRects (2 bytes) */\n\n\t\tif (windowState->numWindowRects == 0)\n\t\t{\n\t\t\treturn TRUE;\n\t\t}\n\n\t\tsize = sizeof(RECTANGLE_16) * windowState->numWindowRects;\n\t\tnewRect = (RECTANGLE_16*)realloc(windowState->windowRects, size);\n\n\t\tif (!newRect)\n\t\t{\n\t\t\tfree(windowState->windowRects);\n\t\t\twindowState->windowRects = NULL;\n\t\t\treturn FALSE;\n\t\t}\n\n\t\twindowState->windowRects = newRect;\n\n\t\tif (Stream_GetRemainingLength(s) < 8 * windowState->numWindowRects)\n\t\t\treturn FALSE;\n\n\t\t/* windowRects */\n\t\tfor (i = 0; i < windowState->numWindowRects; i++)\n\t\t{\n\t\t\tStream_Read_UINT16(s, windowState->windowRects[i].left);   /* left (2 bytes) */\n\t\t\tStream_Read_UINT16(s, windowState->windowRects[i].top);    /* top (2 bytes) */\n\t\t\tStream_Read_UINT16(s, windowState->windowRects[i].right);  /* right (2 bytes) */\n\t\t\tStream_Read_UINT16(s, windowState->windowRects[i].bottom); /* bottom (2 bytes) */\n\t\t}\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_VIS_OFFSET)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT32(s, windowState->visibleOffsetX); /* visibleOffsetX (4 bytes) */\n\t\tStream_Read_UINT32(s, windowState->visibleOffsetY); /* visibleOffsetY (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_VISIBILITY)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, windowState->numVisibilityRects); /* numVisibilityRects (2 bytes) */\n\n\t\tif (windowState->numVisibilityRects != 0)\n\t\t{\n\t\t\tsize = sizeof(RECTANGLE_16) * windowState->numVisibilityRects;\n\t\t\tnewRect = (RECTANGLE_16*)realloc(windowState->visibilityRects, size);\n\n\t\t\tif (!newRect)\n\t\t\t{\n\t\t\t\tfree(windowState->visibilityRects);\n\t\t\t\twindowState->visibilityRects = NULL;\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\twindowState->visibilityRects = newRect;\n\n\t\t\tif (Stream_GetRemainingLength(s) < windowState->numVisibilityRects * 8)\n\t\t\t\treturn FALSE;\n\n\t\t\t/* visibilityRects */\n\t\t\tfor (i = 0; i < windowState->numVisibilityRects; i++)\n\t\t\t{\n\t\t\t\tStream_Read_UINT16(s, windowState->visibilityRects[i].left);  /* left (2 bytes) */\n\t\t\t\tStream_Read_UINT16(s, windowState->visibilityRects[i].top);   /* top (2 bytes) */\n\t\t\t\tStream_Read_UINT16(s, windowState->visibilityRects[i].right); /* right (2 bytes) */\n\t\t\t\tStream_Read_UINT16(s,\n\t\t\t\t                   windowState->visibilityRects[i].bottom); /* bottom (2 bytes) */\n\t\t\t}\n\t\t}\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_OVERLAY_DESCRIPTION)\n\t{\n\t\tif (!rail_read_unicode_string(s, &windowState->OverlayDescription))\n\t\t\treturn FALSE;\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_ICON_OVERLAY_NULL)\n\t{\n\t\t/* no data to be read here */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_TASKBAR_BUTTON)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, windowState->TaskbarButton);\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_ENFORCE_SERVER_ZORDER)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, windowState->EnforceServerZOrder);\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_APPBAR_STATE)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, windowState->AppBarState);\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_APPBAR_EDGE)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, windowState->AppBarEdge);\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL update_read_window_icon_order(wStream* s, WINDOW_ORDER_INFO* orderInfo,\n                                          WINDOW_ICON_ORDER* window_icon)\n{\n\tWINPR_UNUSED(orderInfo);\n\twindow_icon->iconInfo = (ICON_INFO*)calloc(1, sizeof(ICON_INFO));\n\n\tif (!window_icon->iconInfo)\n\t\treturn FALSE;\n\n\treturn update_read_icon_info(s, window_icon->iconInfo); /* iconInfo (ICON_INFO) */\n}\n\nstatic BOOL update_read_window_cached_icon_order(wStream* s, WINDOW_ORDER_INFO* orderInfo,\n                                                 WINDOW_CACHED_ICON_ORDER* window_cached_icon)\n{\n\tWINPR_UNUSED(orderInfo);\n\treturn update_read_cached_icon_info(\n\t    s, &window_cached_icon->cachedIcon); /* cachedIcon (CACHED_ICON_INFO) */\n}\n\nstatic void update_read_window_delete_order(wStream* s, WINDOW_ORDER_INFO* orderInfo)\n{\n\t/* window deletion event */\n}\n\nstatic BOOL window_order_supported(const rdpSettings* settings, UINT32 fieldFlags)\n{\n\tconst UINT32 mask = (WINDOW_ORDER_FIELD_CLIENT_AREA_SIZE | WINDOW_ORDER_FIELD_RP_CONTENT |\n\t                     WINDOW_ORDER_FIELD_ROOT_PARENT);\n\tBOOL dresult;\n\n\tif (!settings)\n\t\treturn FALSE;\n\n\t/* See [MS-RDPERP] 2.2.1.1.2 Window List Capability Set */\n\tdresult = settings->AllowUnanouncedOrdersFromServer;\n\n\tswitch (settings->RemoteWndSupportLevel)\n\t{\n\t\tcase WINDOW_LEVEL_SUPPORTED_EX:\n\t\t\treturn TRUE;\n\n\t\tcase WINDOW_LEVEL_SUPPORTED:\n\t\t\treturn ((fieldFlags & mask) == 0) || dresult;\n\n\t\tcase WINDOW_LEVEL_NOT_SUPPORTED:\n\t\t\treturn dresult;\n\n\t\tdefault:\n\t\t\treturn dresult;\n\t}\n}\n\n#define DUMP_APPEND(buffer, size, ...)            \\\n\tdo                                            \\\n\t{                                             \\\n\t\tchar* b = (buffer);                       \\\n\t\tsize_t s = (size);                        \\\n\t\tsize_t pos = strnlen(b, s);               \\\n\t\t_snprintf(&b[pos], s - pos, __VA_ARGS__); \\\n\t} while (0)\n\nstatic void dump_window_state_order(wLog* log, const char* msg, const WINDOW_ORDER_INFO* order,\n                                    const WINDOW_STATE_ORDER* state)\n{\n\tchar buffer[3000] = { 0 };\n\tconst size_t bufferSize = sizeof(buffer) - 1;\n\n\t_snprintf(buffer, bufferSize, \"%s windowId=0x%\" PRIu32 \"\", msg, order->windowId);\n\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_OWNER)\n\t\tDUMP_APPEND(buffer, bufferSize, \" owner=0x%\" PRIx32 \"\", state->ownerWindowId);\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_STYLE)\n\t{\n\t\tDUMP_APPEND(buffer, bufferSize, \" [ex]style=<0x%\" PRIx32 \", 0x%\" PRIx32 \"\", state->style,\n\t\t            state->extendedStyle);\n\t\tif (state->style & WS_POPUP)\n\t\t\tDUMP_APPEND(buffer, bufferSize, \" popup\");\n\t\tif (state->style & WS_VISIBLE)\n\t\t\tDUMP_APPEND(buffer, bufferSize, \" visible\");\n\t\tif (state->style & WS_THICKFRAME)\n\t\t\tDUMP_APPEND(buffer, bufferSize, \" thickframe\");\n\t\tif (state->style & WS_BORDER)\n\t\t\tDUMP_APPEND(buffer, bufferSize, \" border\");\n\t\tif (state->style & WS_CAPTION)\n\t\t\tDUMP_APPEND(buffer, bufferSize, \" caption\");\n\n\t\tif (state->extendedStyle & WS_EX_NOACTIVATE)\n\t\t\tDUMP_APPEND(buffer, bufferSize, \" noactivate\");\n\t\tif (state->extendedStyle & WS_EX_TOOLWINDOW)\n\t\t\tDUMP_APPEND(buffer, bufferSize, \" toolWindow\");\n\t\tif (state->extendedStyle & WS_EX_TOPMOST)\n\t\t\tDUMP_APPEND(buffer, bufferSize, \" topMost\");\n\n\t\tDUMP_APPEND(buffer, bufferSize, \">\");\n\t}\n\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_SHOW)\n\t{\n\t\tconst char* showStr;\n\t\tswitch (state->showState)\n\t\t{\n\t\t\tcase 0:\n\t\t\t\tshowStr = \"hidden\";\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tshowStr = \"minimized\";\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tshowStr = \"maximized\";\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tshowStr = \"current\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tshowStr = \"<unknown>\";\n\t\t\t\tbreak;\n\t\t}\n\t\tDUMP_APPEND(buffer, bufferSize, \" show=%s\", showStr);\n\t}\n\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_TITLE)\n\t\tDUMP_APPEND(buffer, bufferSize, \" title\");\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_CLIENT_AREA_OFFSET)\n\t\tDUMP_APPEND(buffer, bufferSize, \" clientOffset=(%\" PRId32 \",%\" PRId32 \")\",\n\t\t            state->clientOffsetX, state->clientOffsetY);\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_CLIENT_AREA_SIZE)\n\t\tDUMP_APPEND(buffer, bufferSize, \" clientAreaWidth=%\" PRIu32 \" clientAreaHeight=%\" PRIu32 \"\",\n\t\t            state->clientAreaWidth, state->clientAreaHeight);\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_RESIZE_MARGIN_X)\n\t\tDUMP_APPEND(buffer, bufferSize,\n\t\t            \" resizeMarginLeft=%\" PRIu32 \" resizeMarginRight=%\" PRIu32 \"\",\n\t\t            state->resizeMarginLeft, state->resizeMarginRight);\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_RESIZE_MARGIN_Y)\n\t\tDUMP_APPEND(buffer, bufferSize,\n\t\t            \" resizeMarginTop=%\" PRIu32 \" resizeMarginBottom=%\" PRIu32 \"\",\n\t\t            state->resizeMarginTop, state->resizeMarginBottom);\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_RP_CONTENT)\n\t\tDUMP_APPEND(buffer, bufferSize, \" rpContent=0x%\" PRIx32 \"\", state->RPContent);\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_ROOT_PARENT)\n\t\tDUMP_APPEND(buffer, bufferSize, \" rootParent=0x%\" PRIx32 \"\", state->rootParentHandle);\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_WND_OFFSET)\n\t\tDUMP_APPEND(buffer, bufferSize, \" windowOffset=(%\" PRId32 \",%\" PRId32 \")\",\n\t\t            state->windowOffsetX, state->windowOffsetY);\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_WND_CLIENT_DELTA)\n\t\tDUMP_APPEND(buffer, bufferSize, \" windowClientDelta=(%\" PRId32 \",%\" PRId32 \")\",\n\t\t            state->windowClientDeltaX, state->windowClientDeltaY);\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_WND_SIZE)\n\t\tDUMP_APPEND(buffer, bufferSize, \" windowWidth=%\" PRIu32 \" windowHeight=%\" PRIu32 \"\",\n\t\t            state->windowWidth, state->windowHeight);\n\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_WND_RECTS)\n\t{\n\t\tUINT32 i;\n\t\tDUMP_APPEND(buffer, bufferSize, \" windowRects=(\");\n\t\tfor (i = 0; i < state->numWindowRects; i++)\n\t\t{\n\t\t\tDUMP_APPEND(buffer, bufferSize, \"(%\" PRIu16 \",%\" PRIu16 \",%\" PRIu16 \",%\" PRIu16 \")\",\n\t\t\t            state->windowRects[i].left, state->windowRects[i].top,\n\t\t\t            state->windowRects[i].right, state->windowRects[i].bottom);\n\t\t}\n\t\tDUMP_APPEND(buffer, bufferSize, \")\");\n\t}\n\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_VIS_OFFSET)\n\t\tDUMP_APPEND(buffer, bufferSize, \" visibleOffset=(%\" PRId32 \",%\" PRId32 \")\",\n\t\t            state->visibleOffsetX, state->visibleOffsetY);\n\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_VISIBILITY)\n\t{\n\t\tUINT32 i;\n\t\tDUMP_APPEND(buffer, bufferSize, \" visibilityRects=(\");\n\t\tfor (i = 0; i < state->numVisibilityRects; i++)\n\t\t{\n\t\t\tDUMP_APPEND(buffer, bufferSize, \"(%\" PRIu16 \",%\" PRIu16 \",%\" PRIu16 \",%\" PRIu16 \")\",\n\t\t\t            state->visibilityRects[i].left, state->visibilityRects[i].top,\n\t\t\t            state->visibilityRects[i].right, state->visibilityRects[i].bottom);\n\t\t}\n\t\tDUMP_APPEND(buffer, bufferSize, \")\");\n\t}\n\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_OVERLAY_DESCRIPTION)\n\t\tDUMP_APPEND(buffer, bufferSize, \" overlayDescr\");\n\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_ICON_OVERLAY_NULL)\n\t\tDUMP_APPEND(buffer, bufferSize, \" iconOverlayNull\");\n\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_TASKBAR_BUTTON)\n\t\tDUMP_APPEND(buffer, bufferSize, \" taskBarButton=0x%\" PRIx8 \"\", state->TaskbarButton);\n\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_ENFORCE_SERVER_ZORDER)\n\t\tDUMP_APPEND(buffer, bufferSize, \" enforceServerZOrder=0x%\" PRIx8 \"\",\n\t\t            state->EnforceServerZOrder);\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_APPBAR_STATE)\n\t\tDUMP_APPEND(buffer, bufferSize, \" appBarState=0x%\" PRIx8 \"\", state->AppBarState);\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_APPBAR_EDGE)\n\t{\n\t\tconst char* appBarEdgeStr;\n\t\tswitch (state->AppBarEdge)\n\t\t{\n\t\t\tcase 0:\n\t\t\t\tappBarEdgeStr = \"left\";\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tappBarEdgeStr = \"top\";\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tappBarEdgeStr = \"right\";\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tappBarEdgeStr = \"bottom\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tappBarEdgeStr = \"<unknown>\";\n\t\t\t\tbreak;\n\t\t}\n\t\tDUMP_APPEND(buffer, bufferSize, \" appBarEdge=%s\", appBarEdgeStr);\n\t}\n\n\tWLog_Print(log, WLOG_DEBUG, buffer);\n}\n\nstatic BOOL update_recv_window_info_order(rdpUpdate* update, wStream* s,\n                                          WINDOW_ORDER_INFO* orderInfo)\n{\n\trdpContext* context = update->context;\n\trdpWindowUpdate* window = update->window;\n\tBOOL result = TRUE;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, orderInfo->windowId); /* windowId (4 bytes) */\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_ICON)\n\t{\n\t\tWINDOW_ICON_ORDER window_icon = { 0 };\n\t\tresult = update_read_window_icon_order(s, orderInfo, &window_icon);\n\n\t\tif (result)\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"WindowIcon windowId=0x%\" PRIx32 \"\",\n\t\t\t           orderInfo->windowId);\n\t\t\tIFCALLRET(window->WindowIcon, result, context, orderInfo, &window_icon);\n\t\t}\n\n\t\tupdate_free_window_icon_info(window_icon.iconInfo);\n\t\tfree(window_icon.iconInfo);\n\t}\n\telse if (orderInfo->fieldFlags & WINDOW_ORDER_CACHED_ICON)\n\t{\n\t\tWINDOW_CACHED_ICON_ORDER window_cached_icon = { 0 };\n\t\tresult = update_read_window_cached_icon_order(s, orderInfo, &window_cached_icon);\n\n\t\tif (result)\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"WindowCachedIcon windowId=0x%\" PRIx32 \"\",\n\t\t\t           orderInfo->windowId);\n\t\t\tIFCALLRET(window->WindowCachedIcon, result, context, orderInfo, &window_cached_icon);\n\t\t}\n\t}\n\telse if (orderInfo->fieldFlags & WINDOW_ORDER_STATE_DELETED)\n\t{\n\t\tupdate_read_window_delete_order(s, orderInfo);\n\t\tWLog_Print(update->log, WLOG_DEBUG, \"WindowDelete windowId=0x%\" PRIx32 \"\",\n\t\t           orderInfo->windowId);\n\t\tIFCALLRET(window->WindowDelete, result, context, orderInfo);\n\t}\n\telse\n\t{\n\t\tWINDOW_STATE_ORDER windowState = { 0 };\n\t\tresult = update_read_window_state_order(s, orderInfo, &windowState);\n\n\t\tif (result)\n\t\t{\n\t\t\tif (orderInfo->fieldFlags & WINDOW_ORDER_STATE_NEW)\n\t\t\t{\n\t\t\t\tdump_window_state_order(update->log, \"WindowCreate\", orderInfo, &windowState);\n\t\t\t\tIFCALLRET(window->WindowCreate, result, context, orderInfo, &windowState);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdump_window_state_order(update->log, \"WindowUpdate\", orderInfo, &windowState);\n\t\t\t\tIFCALLRET(window->WindowUpdate, result, context, orderInfo, &windowState);\n\t\t\t}\n\n\t\t\tupdate_free_window_state(&windowState);\n\t\t}\n\t}\n\n\treturn result;\n}\n\nstatic void update_notify_icon_state_order_free(NOTIFY_ICON_STATE_ORDER* notify)\n{\n\tfree(notify->toolTip.string);\n\tfree(notify->infoTip.text.string);\n\tfree(notify->infoTip.title.string);\n\tupdate_free_window_icon_info(&notify->icon);\n\tmemset(notify, 0, sizeof(NOTIFY_ICON_STATE_ORDER));\n}\n\nstatic BOOL update_read_notification_icon_state_order(wStream* s, WINDOW_ORDER_INFO* orderInfo,\n                                                      NOTIFY_ICON_STATE_ORDER* notify_icon_state)\n{\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_VERSION)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 4)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT32(s, notify_icon_state->version); /* version (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_TIP)\n\t{\n\t\tif (!rail_read_unicode_string(s,\n\t\t                              &notify_icon_state->toolTip)) /* toolTip (UNICODE_STRING) */\n\t\t\treturn FALSE;\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_INFO_TIP)\n\t{\n\t\tif (!update_read_notify_icon_infotip(\n\t\t        s, &notify_icon_state->infoTip)) /* infoTip (NOTIFY_ICON_INFOTIP) */\n\t\t\treturn FALSE;\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_STATE)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 4)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT32(s, notify_icon_state->state); /* state (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_ICON)\n\t{\n\t\tif (!update_read_icon_info(s, &notify_icon_state->icon)) /* icon (ICON_INFO) */\n\t\t\treturn FALSE;\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_CACHED_ICON)\n\t{\n\t\tif (!update_read_cached_icon_info(\n\t\t        s, &notify_icon_state->cachedIcon)) /* cachedIcon (CACHED_ICON_INFO) */\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nstatic void update_read_notification_icon_delete_order(wStream* s, WINDOW_ORDER_INFO* orderInfo)\n{\n\t/* notification icon deletion event */\n}\n\nstatic BOOL update_recv_notification_icon_info_order(rdpUpdate* update, wStream* s,\n                                                     WINDOW_ORDER_INFO* orderInfo)\n{\n\trdpContext* context = update->context;\n\trdpWindowUpdate* window = update->window;\n\tBOOL result = TRUE;\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, orderInfo->windowId);     /* windowId (4 bytes) */\n\tStream_Read_UINT32(s, orderInfo->notifyIconId); /* notifyIconId (4 bytes) */\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_STATE_DELETED)\n\t{\n\t\tupdate_read_notification_icon_delete_order(s, orderInfo);\n\t\tWLog_Print(update->log, WLOG_DEBUG, \"NotifyIconDelete\");\n\t\tIFCALLRET(window->NotifyIconDelete, result, context, orderInfo);\n\t}\n\telse\n\t{\n\t\tNOTIFY_ICON_STATE_ORDER notify_icon_state = { 0 };\n\t\tresult = update_read_notification_icon_state_order(s, orderInfo, &notify_icon_state);\n\n\t\tif (!result)\n\t\t\tgoto fail;\n\n\t\tif (orderInfo->fieldFlags & WINDOW_ORDER_STATE_NEW)\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"NotifyIconCreate\");\n\t\t\tIFCALLRET(window->NotifyIconCreate, result, context, orderInfo, &notify_icon_state);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"NotifyIconUpdate\");\n\t\t\tIFCALLRET(window->NotifyIconUpdate, result, context, orderInfo, &notify_icon_state);\n\t\t}\n\tfail:\n\t\tupdate_notify_icon_state_order_free(&notify_icon_state);\n\t}\n\n\treturn result;\n}\n\nstatic BOOL update_read_desktop_actively_monitored_order(wStream* s, WINDOW_ORDER_INFO* orderInfo,\n                                                         MONITORED_DESKTOP_ORDER* monitored_desktop)\n{\n\tint i;\n\tint size;\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_DESKTOP_ACTIVE_WND)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 4)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT32(s, monitored_desktop->activeWindowId); /* activeWindowId (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_DESKTOP_ZORDER)\n\t{\n\t\tUINT32* newid;\n\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, monitored_desktop->numWindowIds); /* numWindowIds (1 byte) */\n\n\t\tif (Stream_GetRemainingLength(s) < 4 * monitored_desktop->numWindowIds)\n\t\t\treturn FALSE;\n\n\t\tif (monitored_desktop->numWindowIds > 0)\n\t\t{\n\t\t\tsize = sizeof(UINT32) * monitored_desktop->numWindowIds;\n\t\t\tnewid = (UINT32*)realloc(monitored_desktop->windowIds, size);\n\n\t\t\tif (!newid)\n\t\t\t{\n\t\t\t\tfree(monitored_desktop->windowIds);\n\t\t\t\tmonitored_desktop->windowIds = NULL;\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tmonitored_desktop->windowIds = newid;\n\n\t\t\t/* windowIds */\n\t\t\tfor (i = 0; i < (int)monitored_desktop->numWindowIds; i++)\n\t\t\t{\n\t\t\t\tStream_Read_UINT32(s, monitored_desktop->windowIds[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\nstatic void update_read_desktop_non_monitored_order(wStream* s, WINDOW_ORDER_INFO* orderInfo)\n{\n\t/* non-monitored desktop notification event */\n}\n\nstatic void dump_monitored_desktop(wLog* log, const char* msg, const WINDOW_ORDER_INFO* orderInfo,\n                                   const MONITORED_DESKTOP_ORDER* monitored)\n{\n\tchar buffer[1000] = { 0 };\n\tconst size_t bufferSize = sizeof(buffer) - 1;\n\n\tDUMP_APPEND(buffer, bufferSize, \"%s\", msg);\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_DESKTOP_ACTIVE_WND)\n\t\tDUMP_APPEND(buffer, bufferSize, \" activeWindowId=0x%\" PRIx32 \"\", monitored->activeWindowId);\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_DESKTOP_ZORDER)\n\t{\n\t\tUINT32 i;\n\n\t\tDUMP_APPEND(buffer, bufferSize, \" windows=(\");\n\t\tfor (i = 0; i < monitored->numWindowIds; i++)\n\t\t{\n\t\t\tDUMP_APPEND(buffer, bufferSize, \"0x%\" PRIx32 \",\", monitored->windowIds[i]);\n\t\t}\n\t\tDUMP_APPEND(buffer, bufferSize, \")\");\n\t}\n\tWLog_Print(log, WLOG_DEBUG, buffer);\n}\n\nstatic BOOL update_recv_desktop_info_order(rdpUpdate* update, wStream* s,\n                                           WINDOW_ORDER_INFO* orderInfo)\n{\n\trdpContext* context = update->context;\n\trdpWindowUpdate* window = update->window;\n\tBOOL result = TRUE;\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_DESKTOP_NONE)\n\t{\n\t\tupdate_read_desktop_non_monitored_order(s, orderInfo);\n\t\tWLog_Print(update->log, WLOG_DEBUG, \"NonMonitoredDesktop, windowId=0x%\" PRIx32 \"\",\n\t\t           orderInfo->windowId);\n\t\tIFCALLRET(window->NonMonitoredDesktop, result, context, orderInfo);\n\t}\n\telse\n\t{\n\t\tMONITORED_DESKTOP_ORDER monitored_desktop = { 0 };\n\t\tresult = update_read_desktop_actively_monitored_order(s, orderInfo, &monitored_desktop);\n\n\t\tif (result)\n\t\t{\n\t\t\tdump_monitored_desktop(update->log, \"ActivelyMonitoredDesktop\", orderInfo,\n\t\t\t                       &monitored_desktop);\n\t\t\tIFCALLRET(window->MonitoredDesktop, result, context, orderInfo, &monitored_desktop);\n\t\t}\n\n\t\tfree(monitored_desktop.windowIds);\n\t}\n\n\treturn result;\n}\n\nvoid update_free_window_icon_info(ICON_INFO* iconInfo)\n{\n\tif (!iconInfo)\n\t\treturn;\n\n\tfree(iconInfo->bitsColor);\n\ticonInfo->bitsColor = NULL;\n\tfree(iconInfo->bitsMask);\n\ticonInfo->bitsMask = NULL;\n\tfree(iconInfo->colorTable);\n\ticonInfo->colorTable = NULL;\n}\n\nBOOL update_recv_altsec_window_order(rdpUpdate* update, wStream* s)\n{\n\tBOOL rc = TRUE;\n\tsize_t remaining;\n\tUINT16 orderSize;\n\tWINDOW_ORDER_INFO orderInfo = { 0 };\n\tremaining = Stream_GetRemainingLength(s);\n\n\tif (remaining < 6)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"Stream short\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, orderSize);            /* orderSize (2 bytes) */\n\tStream_Read_UINT32(s, orderInfo.fieldFlags); /* FieldsPresentFlags (4 bytes) */\n\n\tif (remaining + 1 < orderSize)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"Stream short orderSize\");\n\t\treturn FALSE;\n\t}\n\n\tif (!window_order_supported(update->context->settings, orderInfo.fieldFlags))\n\t{\n\t\tWLog_INFO(TAG, \"Window order %08\" PRIx32 \" not supported!\", orderInfo.fieldFlags);\n\t\treturn FALSE;\n\t}\n\n\tif (orderInfo.fieldFlags & WINDOW_ORDER_TYPE_WINDOW)\n\t\trc = update_recv_window_info_order(update, s, &orderInfo);\n\telse if (orderInfo.fieldFlags & WINDOW_ORDER_TYPE_NOTIFY)\n\t\trc = update_recv_notification_icon_info_order(update, s, &orderInfo);\n\telse if (orderInfo.fieldFlags & WINDOW_ORDER_TYPE_DESKTOP)\n\t\trc = update_recv_desktop_info_order(update, s, &orderInfo);\n\n\tif (!rc)\n\t\tWLog_Print(update->log, WLOG_ERROR, \"windoworder flags %08\" PRIx32 \" failed\",\n\t\t           orderInfo.fieldFlags);\n\n\treturn rc;\n}\n"], "fixing_code": ["/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * Bitmap Cache V2\n *\n * Copyright 2011 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <stdio.h>\n\n#include <winpr/crt.h>\n\n#include <freerdp/freerdp.h>\n#include <freerdp/constants.h>\n#include <winpr/stream.h>\n\n#include <freerdp/log.h>\n#include <freerdp/cache/bitmap.h>\n#include <freerdp/gdi/bitmap.h>\n\n#include \"../gdi/gdi.h\"\n#include \"../core/graphics.h\"\n\n#include \"bitmap.h\"\n\n#define TAG FREERDP_TAG(\"cache.bitmap\")\n\nstatic rdpBitmap* bitmap_cache_get(rdpBitmapCache* bitmapCache, UINT32 id, UINT32 index);\nstatic BOOL bitmap_cache_put(rdpBitmapCache* bitmap_cache, UINT32 id, UINT32 index,\n                             rdpBitmap* bitmap);\n\nstatic BOOL update_gdi_memblt(rdpContext* context, MEMBLT_ORDER* memblt)\n{\n\trdpBitmap* bitmap;\n\trdpCache* cache = context->cache;\n\n\tif (memblt->cacheId == 0xFF)\n\t\tbitmap = offscreen_cache_get(cache->offscreen, memblt->cacheIndex);\n\telse\n\t\tbitmap = bitmap_cache_get(cache->bitmap, (BYTE)memblt->cacheId, memblt->cacheIndex);\n\n\t/* XP-SP2 servers sometimes ask for cached bitmaps they've never defined. */\n\tif (bitmap == NULL)\n\t\treturn TRUE;\n\n\tmemblt->bitmap = bitmap;\n\treturn IFCALLRESULT(TRUE, cache->bitmap->MemBlt, context, memblt);\n}\n\nstatic BOOL update_gdi_mem3blt(rdpContext* context, MEM3BLT_ORDER* mem3blt)\n{\n\tBYTE style;\n\trdpBitmap* bitmap;\n\trdpCache* cache = context->cache;\n\trdpBrush* brush = &mem3blt->brush;\n\tBOOL ret = TRUE;\n\n\tif (mem3blt->cacheId == 0xFF)\n\t\tbitmap = offscreen_cache_get(cache->offscreen, mem3blt->cacheIndex);\n\telse\n\t\tbitmap = bitmap_cache_get(cache->bitmap, (BYTE)mem3blt->cacheId, mem3blt->cacheIndex);\n\n\t/* XP-SP2 servers sometimes ask for cached bitmaps they've never defined. */\n\tif (!bitmap)\n\t\treturn TRUE;\n\n\tstyle = brush->style;\n\n\tif (brush->style & CACHED_BRUSH)\n\t{\n\t\tbrush->data = brush_cache_get(cache->brush, brush->index, &brush->bpp);\n\n\t\tif (!brush->data)\n\t\t\treturn FALSE;\n\n\t\tbrush->style = 0x03;\n\t}\n\n\tmem3blt->bitmap = bitmap;\n\tIFCALLRET(cache->bitmap->Mem3Blt, ret, context, mem3blt);\n\tbrush->style = style;\n\treturn ret;\n}\n\nstatic BOOL update_gdi_cache_bitmap(rdpContext* context, const CACHE_BITMAP_ORDER* cacheBitmap)\n{\n\trdpBitmap* bitmap;\n\trdpBitmap* prevBitmap;\n\trdpCache* cache = context->cache;\n\tbitmap = Bitmap_Alloc(context);\n\n\tif (!bitmap)\n\t\treturn FALSE;\n\n\tBitmap_SetDimensions(bitmap, cacheBitmap->bitmapWidth, cacheBitmap->bitmapHeight);\n\n\tif (!bitmap->Decompress(context, bitmap, cacheBitmap->bitmapDataStream,\n\t                        cacheBitmap->bitmapWidth, cacheBitmap->bitmapHeight,\n\t                        cacheBitmap->bitmapBpp, cacheBitmap->bitmapLength,\n\t                        cacheBitmap->compressed, RDP_CODEC_ID_NONE))\n\t{\n\t\tBitmap_Free(context, bitmap);\n\t\treturn FALSE;\n\t}\n\n\tif (!bitmap->New(context, bitmap))\n\t{\n\t\tBitmap_Free(context, bitmap);\n\t\treturn FALSE;\n\t}\n\n\tprevBitmap = bitmap_cache_get(cache->bitmap, cacheBitmap->cacheId, cacheBitmap->cacheIndex);\n\tBitmap_Free(context, prevBitmap);\n\treturn bitmap_cache_put(cache->bitmap, cacheBitmap->cacheId, cacheBitmap->cacheIndex, bitmap);\n}\n\nstatic BOOL update_gdi_cache_bitmap_v2(rdpContext* context, CACHE_BITMAP_V2_ORDER* cacheBitmapV2)\n\n{\n\trdpBitmap* bitmap;\n\trdpBitmap* prevBitmap;\n\trdpCache* cache = context->cache;\n\trdpSettings* settings = context->settings;\n\tbitmap = Bitmap_Alloc(context);\n\n\tif (!bitmap)\n\t\treturn FALSE;\n\n\tif (!cacheBitmapV2->bitmapBpp)\n\t\tcacheBitmapV2->bitmapBpp = settings->ColorDepth;\n\n\tif ((settings->ColorDepth == 15) && (cacheBitmapV2->bitmapBpp == 16))\n\t\tcacheBitmapV2->bitmapBpp = settings->ColorDepth;\n\n\tBitmap_SetDimensions(bitmap, cacheBitmapV2->bitmapWidth, cacheBitmapV2->bitmapHeight);\n\n\tif (!bitmap->Decompress(context, bitmap, cacheBitmapV2->bitmapDataStream,\n\t                        cacheBitmapV2->bitmapWidth, cacheBitmapV2->bitmapHeight,\n\t                        cacheBitmapV2->bitmapBpp, cacheBitmapV2->bitmapLength,\n\t                        cacheBitmapV2->compressed, RDP_CODEC_ID_NONE))\n\t{\n\t\tBitmap_Free(context, bitmap);\n\t\treturn FALSE;\n\t}\n\n\tprevBitmap = bitmap_cache_get(cache->bitmap, cacheBitmapV2->cacheId, cacheBitmapV2->cacheIndex);\n\n\tif (!bitmap->New(context, bitmap))\n\t{\n\t\tBitmap_Free(context, bitmap);\n\t\treturn FALSE;\n\t}\n\n\tBitmap_Free(context, prevBitmap);\n\treturn bitmap_cache_put(cache->bitmap, cacheBitmapV2->cacheId, cacheBitmapV2->cacheIndex,\n\t                        bitmap);\n}\n\nstatic BOOL update_gdi_cache_bitmap_v3(rdpContext* context, CACHE_BITMAP_V3_ORDER* cacheBitmapV3)\n{\n\trdpBitmap* bitmap;\n\trdpBitmap* prevBitmap;\n\tBOOL compressed = TRUE;\n\trdpCache* cache = context->cache;\n\trdpSettings* settings = context->settings;\n\tBITMAP_DATA_EX* bitmapData = &cacheBitmapV3->bitmapData;\n\tbitmap = Bitmap_Alloc(context);\n\n\tif (!bitmap)\n\t\treturn FALSE;\n\n\tif (!cacheBitmapV3->bpp)\n\t\tcacheBitmapV3->bpp = settings->ColorDepth;\n\n\tcompressed = (bitmapData->codecID != RDP_CODEC_ID_NONE);\n\tBitmap_SetDimensions(bitmap, bitmapData->width, bitmapData->height);\n\n\tif (!bitmap->Decompress(context, bitmap, bitmapData->data, bitmapData->width,\n\t                        bitmapData->height, bitmapData->bpp, bitmapData->length, compressed,\n\t                        bitmapData->codecID))\n\t{\n\t\tBitmap_Free(context, bitmap);\n\t\treturn FALSE;\n\t}\n\n\tif (!bitmap->New(context, bitmap))\n\t{\n\t\tBitmap_Free(context, bitmap);\n\t\treturn FALSE;\n\t}\n\n\tprevBitmap = bitmap_cache_get(cache->bitmap, cacheBitmapV3->cacheId, cacheBitmapV3->cacheIndex);\n\tBitmap_Free(context, prevBitmap);\n\treturn bitmap_cache_put(cache->bitmap, cacheBitmapV3->cacheId, cacheBitmapV3->cacheIndex,\n\t                        bitmap);\n}\n\nrdpBitmap* bitmap_cache_get(rdpBitmapCache* bitmapCache, UINT32 id, UINT32 index)\n{\n\trdpBitmap* bitmap;\n\n\tif (id > bitmapCache->maxCells)\n\t{\n\t\tWLog_ERR(TAG, \"get invalid bitmap cell id: %\" PRIu32 \"\", id);\n\t\treturn NULL;\n\t}\n\n\tif (index == BITMAP_CACHE_WAITING_LIST_INDEX)\n\t{\n\t\tindex = bitmapCache->cells[id].number;\n\t}\n\telse if (index > bitmapCache->cells[id].number)\n\t{\n\t\tWLog_ERR(TAG, \"get invalid bitmap index %\" PRIu32 \" in cell id: %\" PRIu32 \"\", index, id);\n\t\treturn NULL;\n\t}\n\n\tbitmap = bitmapCache->cells[id].entries[index];\n\treturn bitmap;\n}\n\nBOOL bitmap_cache_put(rdpBitmapCache* bitmapCache, UINT32 id, UINT32 index, rdpBitmap* bitmap)\n{\n\tif (id > bitmapCache->maxCells)\n\t{\n\t\tWLog_ERR(TAG, \"put invalid bitmap cell id: %\" PRIu32 \"\", id);\n\t\treturn FALSE;\n\t}\n\n\tif (index == BITMAP_CACHE_WAITING_LIST_INDEX)\n\t{\n\t\tindex = bitmapCache->cells[id].number;\n\t}\n\telse if (index > bitmapCache->cells[id].number)\n\t{\n\t\tWLog_ERR(TAG, \"put invalid bitmap index %\" PRIu32 \" in cell id: %\" PRIu32 \"\", index, id);\n\t\treturn FALSE;\n\t}\n\n\tbitmapCache->cells[id].entries[index] = bitmap;\n\treturn TRUE;\n}\n\nvoid bitmap_cache_register_callbacks(rdpUpdate* update)\n{\n\trdpCache* cache = update->context->cache;\n\tcache->bitmap->MemBlt = update->primary->MemBlt;\n\tcache->bitmap->Mem3Blt = update->primary->Mem3Blt;\n\tupdate->primary->MemBlt = update_gdi_memblt;\n\tupdate->primary->Mem3Blt = update_gdi_mem3blt;\n\tupdate->secondary->CacheBitmap = update_gdi_cache_bitmap;\n\tupdate->secondary->CacheBitmapV2 = update_gdi_cache_bitmap_v2;\n\tupdate->secondary->CacheBitmapV3 = update_gdi_cache_bitmap_v3;\n\tupdate->BitmapUpdate = gdi_bitmap_update;\n}\n\nrdpBitmapCache* bitmap_cache_new(rdpSettings* settings)\n{\n\tint i;\n\trdpBitmapCache* bitmapCache;\n\tbitmapCache = (rdpBitmapCache*)calloc(1, sizeof(rdpBitmapCache));\n\n\tif (!bitmapCache)\n\t\treturn NULL;\n\n\tbitmapCache->settings = settings;\n\tbitmapCache->update = ((freerdp*)settings->instance)->update;\n\tbitmapCache->context = bitmapCache->update->context;\n\tbitmapCache->cells =\n\t    (BITMAP_V2_CELL*)calloc(settings->BitmapCacheV2NumCells, sizeof(BITMAP_V2_CELL));\n\n\tif (!bitmapCache->cells)\n\t\tgoto fail;\n\tbitmapCache->maxCells = settings->BitmapCacheV2NumCells;\n\n\tfor (i = 0; i < (int)bitmapCache->maxCells; i++)\n\t{\n\t\tbitmapCache->cells[i].number = settings->BitmapCacheV2CellInfo[i].numEntries;\n\t\t/* allocate an extra entry for BITMAP_CACHE_WAITING_LIST_INDEX */\n\t\tbitmapCache->cells[i].entries =\n\t\t    (rdpBitmap**)calloc((bitmapCache->cells[i].number + 1), sizeof(rdpBitmap*));\n\n\t\tif (!bitmapCache->cells[i].entries)\n\t\t\tgoto fail;\n\t}\n\n\treturn bitmapCache;\nfail:\n\n\tif (bitmapCache->cells)\n\t{\n\t\tfor (i = 0; i < (int)bitmapCache->maxCells; i++)\n\t\t\tfree(bitmapCache->cells[i].entries);\n\t}\n\n\tfree(bitmapCache);\n\treturn NULL;\n}\n\nvoid bitmap_cache_free(rdpBitmapCache* bitmapCache)\n{\n\tint i, j;\n\trdpBitmap* bitmap;\n\n\tif (bitmapCache)\n\t{\n\t\tfor (i = 0; i < (int)bitmapCache->maxCells; i++)\n\t\t{\n\t\t\tfor (j = 0; j < (int)bitmapCache->cells[i].number + 1; j++)\n\t\t\t{\n\t\t\t\tbitmap = bitmapCache->cells[i].entries[j];\n\t\t\t\tBitmap_Free(bitmapCache->context, bitmap);\n\t\t\t}\n\n\t\t\tfree(bitmapCache->cells[i].entries);\n\t\t}\n\n\t\tfree(bitmapCache->cells);\n\t\tfree(bitmapCache);\n\t}\n}\n\nstatic void free_bitmap_data(BITMAP_DATA* data, size_t count)\n{\n\tsize_t x;\n\n\tif (!data)\n\t\treturn;\n\n\tfor (x = 0; x < count; x++)\n\t\tfree(data[x].bitmapDataStream);\n\n\tfree(data);\n}\n\nstatic BITMAP_DATA* copy_bitmap_data(const BITMAP_DATA* data, size_t count)\n{\n\tsize_t x;\n\tBITMAP_DATA* dst = (BITMAP_DATA*)calloc(count, sizeof(BITMAP_DATA));\n\n\tif (!dst)\n\t\tgoto fail;\n\n\tfor (x = 0; x < count; x++)\n\t{\n\t\tdst[x] = data[x];\n\n\t\tif (data[x].bitmapLength > 0)\n\t\t{\n\t\t\tdst[x].bitmapDataStream = malloc(data[x].bitmapLength);\n\n\t\t\tif (!dst[x].bitmapDataStream)\n\t\t\t\tgoto fail;\n\n\t\t\tmemcpy(dst[x].bitmapDataStream, data[x].bitmapDataStream, data[x].bitmapLength);\n\t\t}\n\t}\n\n\treturn dst;\nfail:\n\tfree_bitmap_data(dst, count);\n\treturn NULL;\n}\n\nvoid free_bitmap_update(rdpContext* context, BITMAP_UPDATE* pointer)\n{\n\tif (!pointer)\n\t\treturn;\n\n\tfree_bitmap_data(pointer->rectangles, pointer->number);\n\tfree(pointer);\n}\n\nBITMAP_UPDATE* copy_bitmap_update(rdpContext* context, const BITMAP_UPDATE* pointer)\n{\n\tBITMAP_UPDATE* dst = calloc(1, sizeof(BITMAP_UPDATE));\n\n\tif (!dst || !pointer)\n\t\tgoto fail;\n\n\t*dst = *pointer;\n\tdst->rectangles = copy_bitmap_data(pointer->rectangles, pointer->number);\n\n\tif (!dst->rectangles)\n\t\tgoto fail;\n\n\treturn dst;\nfail:\n\tfree_bitmap_update(context, dst);\n\treturn NULL;\n}\n\nCACHE_BITMAP_ORDER* copy_cache_bitmap_order(rdpContext* context, const CACHE_BITMAP_ORDER* order)\n{\n\tCACHE_BITMAP_ORDER* dst = calloc(1, sizeof(CACHE_BITMAP_ORDER));\n\n\tif (!dst || !order)\n\t\tgoto fail;\n\n\t*dst = *order;\n\n\tif (order->bitmapLength > 0)\n\t{\n\t\tdst->bitmapDataStream = malloc(order->bitmapLength);\n\n\t\tif (!dst->bitmapDataStream)\n\t\t\tgoto fail;\n\n\t\tmemcpy(dst->bitmapDataStream, order->bitmapDataStream, order->bitmapLength);\n\t}\n\n\treturn dst;\nfail:\n\tfree_cache_bitmap_order(context, dst);\n\treturn NULL;\n}\n\nvoid free_cache_bitmap_order(rdpContext* context, CACHE_BITMAP_ORDER* order)\n{\n\tif (order)\n\t\tfree(order->bitmapDataStream);\n\n\tfree(order);\n}\n\nCACHE_BITMAP_V2_ORDER* copy_cache_bitmap_v2_order(rdpContext* context,\n                                                  const CACHE_BITMAP_V2_ORDER* order)\n{\n\tCACHE_BITMAP_V2_ORDER* dst = calloc(1, sizeof(CACHE_BITMAP_V2_ORDER));\n\n\tif (!dst || !order)\n\t\tgoto fail;\n\n\t*dst = *order;\n\n\tif (order->bitmapLength > 0)\n\t{\n\t\tdst->bitmapDataStream = malloc(order->bitmapLength);\n\n\t\tif (!dst->bitmapDataStream)\n\t\t\tgoto fail;\n\n\t\tmemcpy(dst->bitmapDataStream, order->bitmapDataStream, order->bitmapLength);\n\t}\n\n\treturn dst;\nfail:\n\tfree_cache_bitmap_v2_order(context, dst);\n\treturn NULL;\n}\n\nvoid free_cache_bitmap_v2_order(rdpContext* context, CACHE_BITMAP_V2_ORDER* order)\n{\n\tif (order)\n\t\tfree(order->bitmapDataStream);\n\n\tfree(order);\n}\n\nCACHE_BITMAP_V3_ORDER* copy_cache_bitmap_v3_order(rdpContext* context,\n                                                  const CACHE_BITMAP_V3_ORDER* order)\n{\n\tCACHE_BITMAP_V3_ORDER* dst = calloc(1, sizeof(CACHE_BITMAP_V3_ORDER));\n\n\tif (!dst || !order)\n\t\tgoto fail;\n\n\t*dst = *order;\n\n\tif (order->bitmapData.length > 0)\n\t{\n\t\tdst->bitmapData.data = malloc(order->bitmapData.length);\n\n\t\tif (!dst->bitmapData.data)\n\t\t\tgoto fail;\n\n\t\tmemcpy(dst->bitmapData.data, order->bitmapData.data, order->bitmapData.length);\n\t}\n\n\treturn dst;\nfail:\n\tfree_cache_bitmap_v3_order(context, dst);\n\treturn NULL;\n}\n\nvoid free_cache_bitmap_v3_order(rdpContext* context, CACHE_BITMAP_V3_ORDER* order)\n{\n\tif (order)\n\t\tfree(order->bitmapData.data);\n\n\tfree(order);\n}\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * Auto-Detect PDUs\n *\n * Copyright 2014 Dell Software <Mike.McDonald@software.dell.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <winpr/crypto.h>\n\n#include \"autodetect.h\"\n\n#define RDP_RTT_REQUEST_TYPE_CONTINUOUS 0x0001\n#define RDP_RTT_REQUEST_TYPE_CONNECTTIME 0x1001\n\n#define RDP_RTT_RESPONSE_TYPE 0x0000\n\n#define RDP_BW_START_REQUEST_TYPE_CONTINUOUS 0x0014\n#define RDP_BW_START_REQUEST_TYPE_TUNNEL 0x0114\n#define RDP_BW_START_REQUEST_TYPE_CONNECTTIME 0x1014\n#define RDP_BW_PAYLOAD_REQUEST_TYPE 0x0002\n#define RDP_BW_STOP_REQUEST_TYPE_CONNECTTIME 0x002B\n#define RDP_BW_STOP_REQUEST_TYPE_CONTINUOUS 0x0429\n#define RDP_BW_STOP_REQUEST_TYPE_TUNNEL 0x0629\n\n#define RDP_BW_RESULTS_RESPONSE_TYPE_CONNECTTIME 0x0003\n#define RDP_BW_RESULTS_RESPONSE_TYPE_CONTINUOUS 0x000B\n\n#define RDP_NETCHAR_SYNC_RESPONSE_TYPE 0x0018\n\ntypedef struct\n{\n\tUINT8 headerLength;\n\tUINT8 headerTypeId;\n\tUINT16 sequenceNumber;\n\tUINT16 requestType;\n} AUTODETECT_REQ_PDU;\n\ntypedef struct\n{\n\tUINT8 headerLength;\n\tUINT8 headerTypeId;\n\tUINT16 sequenceNumber;\n\tUINT16 responseType;\n} AUTODETECT_RSP_PDU;\n\nstatic BOOL autodetect_send_rtt_measure_request(rdpContext* context, UINT16 sequenceNumber,\n                                                UINT16 requestType)\n{\n\twStream* s;\n\ts = rdp_message_channel_pdu_init(context->rdp);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tWLog_VRB(AUTODETECT_TAG, \"sending RTT Measure Request PDU\");\n\tStream_Write_UINT8(s, 0x06);                       /* headerLength (1 byte) */\n\tStream_Write_UINT8(s, TYPE_ID_AUTODETECT_REQUEST); /* headerTypeId (1 byte) */\n\tStream_Write_UINT16(s, sequenceNumber);            /* sequenceNumber (2 bytes) */\n\tStream_Write_UINT16(s, requestType);               /* requestType (2 bytes) */\n\tcontext->rdp->autodetect->rttMeasureStartTime = GetTickCount64();\n\treturn rdp_send_message_channel_pdu(context->rdp, s, SEC_AUTODETECT_REQ);\n}\n\nstatic BOOL autodetect_send_continuous_rtt_measure_request(rdpContext* context,\n                                                           UINT16 sequenceNumber)\n{\n\treturn autodetect_send_rtt_measure_request(context, sequenceNumber,\n\t                                           RDP_RTT_REQUEST_TYPE_CONTINUOUS);\n}\n\nBOOL autodetect_send_connecttime_rtt_measure_request(rdpContext* context, UINT16 sequenceNumber)\n{\n\treturn autodetect_send_rtt_measure_request(context, sequenceNumber,\n\t                                           RDP_RTT_REQUEST_TYPE_CONNECTTIME);\n}\n\nstatic BOOL autodetect_send_rtt_measure_response(rdpRdp* rdp, UINT16 sequenceNumber)\n{\n\twStream* s;\n\t/* Send the response PDU to the server */\n\ts = rdp_message_channel_pdu_init(rdp);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tWLog_VRB(AUTODETECT_TAG, \"sending RTT Measure Response PDU\");\n\tStream_Write_UINT8(s, 0x06);                        /* headerLength (1 byte) */\n\tStream_Write_UINT8(s, TYPE_ID_AUTODETECT_RESPONSE); /* headerTypeId (1 byte) */\n\tStream_Write_UINT16(s, sequenceNumber);             /* sequenceNumber (2 bytes) */\n\tStream_Write_UINT16(s, RDP_RTT_RESPONSE_TYPE);      /* responseType (1 byte) */\n\treturn rdp_send_message_channel_pdu(rdp, s, SEC_AUTODETECT_RSP);\n}\n\nstatic BOOL autodetect_send_bandwidth_measure_start(rdpContext* context, UINT16 sequenceNumber,\n                                                    UINT16 requestType)\n{\n\twStream* s;\n\ts = rdp_message_channel_pdu_init(context->rdp);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tWLog_VRB(AUTODETECT_TAG, \"sending Bandwidth Measure Start PDU\");\n\tStream_Write_UINT8(s, 0x06);                       /* headerLength (1 byte) */\n\tStream_Write_UINT8(s, TYPE_ID_AUTODETECT_REQUEST); /* headerTypeId (1 byte) */\n\tStream_Write_UINT16(s, sequenceNumber);            /* sequenceNumber (2 bytes) */\n\tStream_Write_UINT16(s, requestType);               /* requestType (2 bytes) */\n\treturn rdp_send_message_channel_pdu(context->rdp, s, SEC_AUTODETECT_REQ);\n}\n\nstatic BOOL autodetect_send_continuous_bandwidth_measure_start(rdpContext* context,\n                                                               UINT16 sequenceNumber)\n{\n\treturn autodetect_send_bandwidth_measure_start(context, sequenceNumber,\n\t                                               RDP_BW_START_REQUEST_TYPE_CONTINUOUS);\n}\n\nBOOL autodetect_send_connecttime_bandwidth_measure_start(rdpContext* context, UINT16 sequenceNumber)\n{\n\treturn autodetect_send_bandwidth_measure_start(context, sequenceNumber,\n\t                                               RDP_BW_START_REQUEST_TYPE_CONNECTTIME);\n}\n\nBOOL autodetect_send_bandwidth_measure_payload(rdpContext* context, UINT16 payloadLength,\n                                               UINT16 sequenceNumber)\n{\n\twStream* s;\n\tUCHAR* buffer = NULL;\n\tBOOL bResult = FALSE;\n\ts = rdp_message_channel_pdu_init(context->rdp);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tWLog_VRB(AUTODETECT_TAG, \"sending Bandwidth Measure Payload PDU -> payloadLength=%\" PRIu16 \"\",\n\t         payloadLength);\n\t/* 4-bytes aligned */\n\tpayloadLength &= ~3;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 8 + payloadLength))\n\t{\n\t\tStream_Release(s);\n\t\treturn FALSE;\n\t}\n\n\tStream_Write_UINT8(s, 0x08);                         /* headerLength (1 byte) */\n\tStream_Write_UINT8(s, TYPE_ID_AUTODETECT_REQUEST);   /* headerTypeId (1 byte) */\n\tStream_Write_UINT16(s, sequenceNumber);              /* sequenceNumber (2 bytes) */\n\tStream_Write_UINT16(s, RDP_BW_PAYLOAD_REQUEST_TYPE); /* requestType (2 bytes) */\n\tStream_Write_UINT16(s, payloadLength);               /* payloadLength (2 bytes) */\n\t/* Random data (better measurement in case the line is compressed) */\n\tbuffer = (UCHAR*)malloc(payloadLength);\n\n\tif (NULL == buffer)\n\t{\n\t\tStream_Release(s);\n\t\treturn FALSE;\n\t}\n\n\twinpr_RAND(buffer, payloadLength);\n\tStream_Write(s, buffer, payloadLength);\n\tbResult = rdp_send_message_channel_pdu(context->rdp, s, SEC_AUTODETECT_REQ);\n\tfree(buffer);\n\treturn bResult;\n}\n\nstatic BOOL autodetect_send_bandwidth_measure_stop(rdpContext* context, UINT16 payloadLength,\n                                                   UINT16 sequenceNumber, UINT16 requestType)\n{\n\twStream* s;\n\tUCHAR* buffer = NULL;\n\tBOOL bResult = FALSE;\n\ts = rdp_message_channel_pdu_init(context->rdp);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tWLog_VRB(AUTODETECT_TAG, \"sending Bandwidth Measure Stop PDU -> payloadLength=%\" PRIu16 \"\",\n\t         payloadLength);\n\t/* 4-bytes aligned */\n\tpayloadLength &= ~3;\n\tStream_Write_UINT8(s, requestType == RDP_BW_STOP_REQUEST_TYPE_CONNECTTIME\n\t                          ? 0x08\n\t                          : 0x06);                 /* headerLength (1 byte) */\n\tStream_Write_UINT8(s, TYPE_ID_AUTODETECT_REQUEST); /* headerTypeId (1 byte) */\n\tStream_Write_UINT16(s, sequenceNumber);            /* sequenceNumber (2 bytes) */\n\tStream_Write_UINT16(s, requestType);               /* requestType (2 bytes) */\n\n\tif (requestType == RDP_BW_STOP_REQUEST_TYPE_CONNECTTIME)\n\t{\n\t\tStream_Write_UINT16(s, payloadLength); /* payloadLength (2 bytes) */\n\n\t\tif (payloadLength > 0)\n\t\t{\n\t\t\tif (!Stream_EnsureRemainingCapacity(s, payloadLength))\n\t\t\t{\n\t\t\t\tStream_Release(s);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\t/* Random data (better measurement in case the line is compressed) */\n\t\t\tbuffer = malloc(payloadLength);\n\n\t\t\tif (NULL == buffer)\n\t\t\t{\n\t\t\t\tStream_Release(s);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\twinpr_RAND(buffer, payloadLength);\n\t\t\tStream_Write(s, buffer, payloadLength);\n\t\t}\n\t}\n\n\tbResult = rdp_send_message_channel_pdu(context->rdp, s, SEC_AUTODETECT_REQ);\n\tfree(buffer);\n\treturn bResult;\n}\n\nstatic BOOL autodetect_send_continuous_bandwidth_measure_stop(rdpContext* context,\n                                                              UINT16 sequenceNumber)\n{\n\treturn autodetect_send_bandwidth_measure_stop(context, 0, sequenceNumber,\n\t                                              RDP_BW_STOP_REQUEST_TYPE_CONTINUOUS);\n}\n\nBOOL autodetect_send_connecttime_bandwidth_measure_stop(rdpContext* context, UINT16 payloadLength,\n                                                        UINT16 sequenceNumber)\n{\n\treturn autodetect_send_bandwidth_measure_stop(context, payloadLength, sequenceNumber,\n\t                                              RDP_BW_STOP_REQUEST_TYPE_CONNECTTIME);\n}\n\nstatic BOOL autodetect_send_bandwidth_measure_results(rdpRdp* rdp, UINT16 responseType,\n                                                      UINT16 sequenceNumber)\n{\n\tBOOL success = TRUE;\n\twStream* s;\n\tUINT64 timeDelta;\n\t/* Compute the total time */\n\ttimeDelta = GetTickCount64() - rdp->autodetect->bandwidthMeasureStartTime;\n\t/* Send the result PDU to the server */\n\ts = rdp_message_channel_pdu_init(rdp);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tWLog_VRB(AUTODETECT_TAG,\n\t         \"sending Bandwidth Measure Results PDU -> timeDelta=%\" PRIu32 \", byteCount=%\" PRIu32\n\t         \"\",\n\t         timeDelta, rdp->autodetect->bandwidthMeasureByteCount);\n\tStream_Write_UINT8(s, 0x0E);                        /* headerLength (1 byte) */\n\tStream_Write_UINT8(s, TYPE_ID_AUTODETECT_RESPONSE); /* headerTypeId (1 byte) */\n\tStream_Write_UINT16(s, sequenceNumber);             /* sequenceNumber (2 bytes) */\n\tStream_Write_UINT16(s, responseType);               /* responseType (1 byte) */\n\tStream_Write_UINT32(s, timeDelta);                  /* timeDelta (4 bytes) */\n\tStream_Write_UINT32(s, rdp->autodetect->bandwidthMeasureByteCount); /* byteCount (4 bytes) */\n\tIFCALLRET(rdp->autodetect->ClientBandwidthMeasureResult, success, rdp->context,\n\t          rdp->autodetect);\n\n\tif (!success)\n\t\treturn FALSE;\n\n\treturn rdp_send_message_channel_pdu(rdp, s, SEC_AUTODETECT_RSP);\n}\n\nstatic BOOL autodetect_send_netchar_result(rdpContext* context, UINT16 sequenceNumber)\n{\n\twStream* s;\n\ts = rdp_message_channel_pdu_init(context->rdp);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tWLog_VRB(AUTODETECT_TAG, \"sending Bandwidth Network Characteristics Result PDU\");\n\n\tif (context->rdp->autodetect->netCharBandwidth > 0)\n\t{\n\t\tStream_Write_UINT8(s, 0x12);                       /* headerLength (1 byte) */\n\t\tStream_Write_UINT8(s, TYPE_ID_AUTODETECT_REQUEST); /* headerTypeId (1 byte) */\n\t\tStream_Write_UINT16(s, sequenceNumber);            /* sequenceNumber (2 bytes) */\n\t\tStream_Write_UINT16(s, 0x08C0);                    /* requestType (2 bytes) */\n\t\tStream_Write_UINT32(s, context->rdp->autodetect->netCharBaseRTT); /* baseRTT (4 bytes) */\n\t\tStream_Write_UINT32(s,\n\t\t                    context->rdp->autodetect->netCharBandwidth); /* bandwidth (4 bytes) */\n\t\tStream_Write_UINT32(s,\n\t\t                    context->rdp->autodetect->netCharAverageRTT); /* averageRTT (4 bytes) */\n\t}\n\telse\n\t{\n\t\tStream_Write_UINT8(s, 0x0E);                       /* headerLength (1 byte) */\n\t\tStream_Write_UINT8(s, TYPE_ID_AUTODETECT_REQUEST); /* headerTypeId (1 byte) */\n\t\tStream_Write_UINT16(s, sequenceNumber);            /* sequenceNumber (2 bytes) */\n\t\tStream_Write_UINT16(s, 0x0840);                    /* requestType (2 bytes) */\n\t\tStream_Write_UINT32(s, context->rdp->autodetect->netCharBaseRTT); /* baseRTT (4 bytes) */\n\t\tStream_Write_UINT32(s,\n\t\t                    context->rdp->autodetect->netCharAverageRTT); /* averageRTT (4 bytes) */\n\t}\n\n\treturn rdp_send_message_channel_pdu(context->rdp, s, SEC_AUTODETECT_REQ);\n}\n\nstatic BOOL autodetect_send_netchar_sync(rdpRdp* rdp, UINT16 sequenceNumber)\n{\n\twStream* s;\n\t/* Send the response PDU to the server */\n\ts = rdp_message_channel_pdu_init(rdp);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tWLog_VRB(AUTODETECT_TAG,\n\t         \"sending Network Characteristics Sync PDU -> bandwidth=%\" PRIu32 \", rtt=%\" PRIu32 \"\",\n\t         rdp->autodetect->netCharBandwidth, rdp->autodetect->netCharAverageRTT);\n\tStream_Write_UINT8(s, 0x0E);                                /* headerLength (1 byte) */\n\tStream_Write_UINT8(s, TYPE_ID_AUTODETECT_RESPONSE);         /* headerTypeId (1 byte) */\n\tStream_Write_UINT16(s, sequenceNumber);                     /* sequenceNumber (2 bytes) */\n\tStream_Write_UINT16(s, RDP_NETCHAR_SYNC_RESPONSE_TYPE);     /* responseType (1 byte) */\n\tStream_Write_UINT32(s, rdp->autodetect->netCharBandwidth);  /* bandwidth (4 bytes) */\n\tStream_Write_UINT32(s, rdp->autodetect->netCharAverageRTT); /* rtt (4 bytes) */\n\treturn rdp_send_message_channel_pdu(rdp, s, SEC_AUTODETECT_RSP);\n}\n\nstatic BOOL autodetect_recv_rtt_measure_request(rdpRdp* rdp, wStream* s,\n                                                AUTODETECT_REQ_PDU* autodetectReqPdu)\n{\n\tif (autodetectReqPdu->headerLength != 0x06)\n\t\treturn FALSE;\n\n\tWLog_VRB(AUTODETECT_TAG, \"received RTT Measure Request PDU\");\n\t/* Send a response to the server */\n\treturn autodetect_send_rtt_measure_response(rdp, autodetectReqPdu->sequenceNumber);\n}\n\nstatic BOOL autodetect_recv_rtt_measure_response(rdpRdp* rdp, wStream* s,\n                                                 AUTODETECT_RSP_PDU* autodetectRspPdu)\n{\n\tBOOL success = TRUE;\n\n\tif (autodetectRspPdu->headerLength != 0x06)\n\t\treturn FALSE;\n\n\tWLog_VRB(AUTODETECT_TAG, \"received RTT Measure Response PDU\");\n\trdp->autodetect->netCharAverageRTT = GetTickCount64() - rdp->autodetect->rttMeasureStartTime;\n\n\tif (rdp->autodetect->netCharBaseRTT == 0 ||\n\t    rdp->autodetect->netCharBaseRTT > rdp->autodetect->netCharAverageRTT)\n\t\trdp->autodetect->netCharBaseRTT = rdp->autodetect->netCharAverageRTT;\n\n\tIFCALLRET(rdp->autodetect->RTTMeasureResponse, success, rdp->context,\n\t          autodetectRspPdu->sequenceNumber);\n\treturn success;\n}\n\nstatic BOOL autodetect_recv_bandwidth_measure_start(rdpRdp* rdp, wStream* s,\n                                                    AUTODETECT_REQ_PDU* autodetectReqPdu)\n{\n\tif (autodetectReqPdu->headerLength != 0x06)\n\t\treturn FALSE;\n\n\tWLog_VRB(AUTODETECT_TAG, \"received Bandwidth Measure Start PDU - time=%\" PRIu64 \"\",\n\t         GetTickCount64());\n\t/* Initialize bandwidth measurement parameters */\n\trdp->autodetect->bandwidthMeasureStartTime = GetTickCount64();\n\trdp->autodetect->bandwidthMeasureByteCount = 0;\n\n\t/* Continuous Auto-Detection: mark the start of the measurement */\n\tif (autodetectReqPdu->requestType == RDP_BW_START_REQUEST_TYPE_CONTINUOUS)\n\t{\n\t\trdp->autodetect->bandwidthMeasureStarted = TRUE;\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL autodetect_recv_bandwidth_measure_payload(rdpRdp* rdp, wStream* s,\n                                                      AUTODETECT_REQ_PDU* autodetectReqPdu)\n{\n\tUINT16 payloadLength;\n\n\tif (autodetectReqPdu->headerLength != 0x08)\n\t\treturn FALSE;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, payloadLength); /* payloadLength (2 bytes) */\n\tif (!Stream_SafeSeek(s, payloadLength))\n\t\treturn FALSE;\n\tWLog_DBG(AUTODETECT_TAG, \"received Bandwidth Measure Payload PDU -> payloadLength=%\" PRIu16 \"\",\n\t         payloadLength);\n\t/* Add the payload length to the bandwidth measurement parameters */\n\trdp->autodetect->bandwidthMeasureByteCount += payloadLength;\n\treturn TRUE;\n}\n\nstatic BOOL autodetect_recv_bandwidth_measure_stop(rdpRdp* rdp, wStream* s,\n                                                   AUTODETECT_REQ_PDU* autodetectReqPdu)\n{\n\tUINT16 payloadLength;\n\tUINT16 responseType;\n\n\tif (autodetectReqPdu->requestType == RDP_BW_STOP_REQUEST_TYPE_CONNECTTIME)\n\t{\n\t\tif (autodetectReqPdu->headerLength != 0x08)\n\t\t\treturn FALSE;\n\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, payloadLength); /* payloadLength (2 bytes) */\n\t}\n\telse\n\t{\n\t\tif (autodetectReqPdu->headerLength != 0x06)\n\t\t\treturn FALSE;\n\n\t\tpayloadLength = 0;\n\t}\n\n\tif (!Stream_SafeSeek(s, payloadLength))\n\t\treturn FALSE;\n\n\tWLog_VRB(AUTODETECT_TAG, \"received Bandwidth Measure Stop PDU -> payloadLength=%\" PRIu16 \"\",\n\t         payloadLength);\n\t/* Add the payload length to the bandwidth measurement parameters */\n\trdp->autodetect->bandwidthMeasureByteCount += payloadLength;\n\n\t/* Continuous Auto-Detection: mark the stop of the measurement */\n\tif (autodetectReqPdu->requestType == RDP_BW_STOP_REQUEST_TYPE_CONTINUOUS)\n\t{\n\t\trdp->autodetect->bandwidthMeasureStarted = FALSE;\n\t}\n\n\t/* Send a response the server */\n\tresponseType = autodetectReqPdu->requestType == RDP_BW_STOP_REQUEST_TYPE_CONNECTTIME\n\t                   ? RDP_BW_RESULTS_RESPONSE_TYPE_CONNECTTIME\n\t                   : RDP_BW_RESULTS_RESPONSE_TYPE_CONTINUOUS;\n\treturn autodetect_send_bandwidth_measure_results(rdp, responseType,\n\t                                                 autodetectReqPdu->sequenceNumber);\n}\n\nstatic BOOL autodetect_recv_bandwidth_measure_results(rdpRdp* rdp, wStream* s,\n                                                      AUTODETECT_RSP_PDU* autodetectRspPdu)\n{\n\tBOOL success = TRUE;\n\n\tif (autodetectRspPdu->headerLength != 0x0E)\n\t\treturn FALSE;\n\n\tWLog_VRB(AUTODETECT_TAG, \"received Bandwidth Measure Results PDU\");\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn -1;\n\tStream_Read_UINT32(s, rdp->autodetect->bandwidthMeasureTimeDelta); /* timeDelta (4 bytes) */\n\tStream_Read_UINT32(s, rdp->autodetect->bandwidthMeasureByteCount); /* byteCount (4 bytes) */\n\n\tif (rdp->autodetect->bandwidthMeasureTimeDelta > 0)\n\t\trdp->autodetect->netCharBandwidth = rdp->autodetect->bandwidthMeasureByteCount * 8 /\n\t\t                                    rdp->autodetect->bandwidthMeasureTimeDelta;\n\telse\n\t\trdp->autodetect->netCharBandwidth = 0;\n\n\tIFCALLRET(rdp->autodetect->BandwidthMeasureResults, success, rdp->context,\n\t          autodetectRspPdu->sequenceNumber);\n\treturn success;\n}\n\nstatic BOOL autodetect_recv_netchar_result(rdpRdp* rdp, wStream* s,\n                                           AUTODETECT_REQ_PDU* autodetectReqPdu)\n{\n\tBOOL success = TRUE;\n\n\tswitch (autodetectReqPdu->requestType)\n\t{\n\t\tcase 0x0840:\n\n\t\t\t/* baseRTT and averageRTT fields are present (bandwidth field is not) */\n\t\t\tif ((autodetectReqPdu->headerLength != 0x0E) || (Stream_GetRemainingLength(s) < 8))\n\t\t\t\treturn FALSE;\n\n\t\t\tStream_Read_UINT32(s, rdp->autodetect->netCharBaseRTT);    /* baseRTT (4 bytes) */\n\t\t\tStream_Read_UINT32(s, rdp->autodetect->netCharAverageRTT); /* averageRTT (4 bytes) */\n\t\t\tbreak;\n\n\t\tcase 0x0880:\n\n\t\t\t/* bandwidth and averageRTT fields are present (baseRTT field is not) */\n\t\t\tif ((autodetectReqPdu->headerLength != 0x0E) || (Stream_GetRemainingLength(s) < 8))\n\t\t\t\treturn FALSE;\n\n\t\t\tStream_Read_UINT32(s, rdp->autodetect->netCharBandwidth);  /* bandwidth (4 bytes) */\n\t\t\tStream_Read_UINT32(s, rdp->autodetect->netCharAverageRTT); /* averageRTT (4 bytes) */\n\t\t\tbreak;\n\n\t\tcase 0x08C0:\n\n\t\t\t/* baseRTT, bandwidth, and averageRTT fields are present */\n\t\t\tif ((autodetectReqPdu->headerLength != 0x12) || (Stream_GetRemainingLength(s) < 12))\n\t\t\t\treturn FALSE;\n\n\t\t\tStream_Read_UINT32(s, rdp->autodetect->netCharBaseRTT);    /* baseRTT (4 bytes) */\n\t\t\tStream_Read_UINT32(s, rdp->autodetect->netCharBandwidth);  /* bandwidth (4 bytes) */\n\t\t\tStream_Read_UINT32(s, rdp->autodetect->netCharAverageRTT); /* averageRTT (4 bytes) */\n\t\t\tbreak;\n\t}\n\n\tWLog_VRB(AUTODETECT_TAG,\n\t         \"received Network Characteristics Result PDU -> baseRTT=%\" PRIu32\n\t         \", bandwidth=%\" PRIu32 \", averageRTT=%\" PRIu32 \"\",\n\t         rdp->autodetect->netCharBaseRTT, rdp->autodetect->netCharBandwidth,\n\t         rdp->autodetect->netCharAverageRTT);\n\tIFCALLRET(rdp->autodetect->NetworkCharacteristicsResult, success, rdp->context,\n\t          autodetectReqPdu->sequenceNumber);\n\treturn success;\n}\n\nint rdp_recv_autodetect_request_packet(rdpRdp* rdp, wStream* s)\n{\n\tAUTODETECT_REQ_PDU autodetectReqPdu;\n\tBOOL success = FALSE;\n\n\tif (Stream_GetRemainingLength(s) < 6)\n\t\treturn -1;\n\n\tStream_Read_UINT8(s, autodetectReqPdu.headerLength);    /* headerLength (1 byte) */\n\tStream_Read_UINT8(s, autodetectReqPdu.headerTypeId);    /* headerTypeId (1 byte) */\n\tStream_Read_UINT16(s, autodetectReqPdu.sequenceNumber); /* sequenceNumber (2 bytes) */\n\tStream_Read_UINT16(s, autodetectReqPdu.requestType);    /* requestType (2 bytes) */\n\tWLog_VRB(AUTODETECT_TAG,\n\t         \"rdp_recv_autodetect_request_packet: headerLength=%\" PRIu8 \", headerTypeId=%\" PRIu8\n\t         \", sequenceNumber=%\" PRIu16 \", requestType=%04\" PRIx16 \"\",\n\t         autodetectReqPdu.headerLength, autodetectReqPdu.headerTypeId,\n\t         autodetectReqPdu.sequenceNumber, autodetectReqPdu.requestType);\n\n\tif (autodetectReqPdu.headerTypeId != TYPE_ID_AUTODETECT_REQUEST)\n\t\treturn -1;\n\n\tswitch (autodetectReqPdu.requestType)\n\t{\n\t\tcase RDP_RTT_REQUEST_TYPE_CONTINUOUS:\n\t\tcase RDP_RTT_REQUEST_TYPE_CONNECTTIME:\n\t\t\t/* RTT Measure Request (RDP_RTT_REQUEST) - MS-RDPBCGR 2.2.14.1.1 */\n\t\t\tsuccess = autodetect_recv_rtt_measure_request(rdp, s, &autodetectReqPdu);\n\t\t\tbreak;\n\n\t\tcase RDP_BW_START_REQUEST_TYPE_CONTINUOUS:\n\t\tcase RDP_BW_START_REQUEST_TYPE_TUNNEL:\n\t\tcase RDP_BW_START_REQUEST_TYPE_CONNECTTIME:\n\t\t\t/* Bandwidth Measure Start (RDP_BW_START) - MS-RDPBCGR 2.2.14.1.2 */\n\t\t\tsuccess = autodetect_recv_bandwidth_measure_start(rdp, s, &autodetectReqPdu);\n\t\t\tbreak;\n\n\t\tcase RDP_BW_PAYLOAD_REQUEST_TYPE:\n\t\t\t/* Bandwidth Measure Payload (RDP_BW_PAYLOAD) - MS-RDPBCGR 2.2.14.1.3 */\n\t\t\tsuccess = autodetect_recv_bandwidth_measure_payload(rdp, s, &autodetectReqPdu);\n\t\t\tbreak;\n\n\t\tcase RDP_BW_STOP_REQUEST_TYPE_CONNECTTIME:\n\t\tcase RDP_BW_STOP_REQUEST_TYPE_CONTINUOUS:\n\t\tcase RDP_BW_STOP_REQUEST_TYPE_TUNNEL:\n\t\t\t/* Bandwidth Measure Stop (RDP_BW_STOP) - MS-RDPBCGR 2.2.14.1.4 */\n\t\t\tsuccess = autodetect_recv_bandwidth_measure_stop(rdp, s, &autodetectReqPdu);\n\t\t\tbreak;\n\n\t\tcase 0x0840:\n\t\tcase 0x0880:\n\t\tcase 0x08C0:\n\t\t\t/* Network Characteristics Result (RDP_NETCHAR_RESULT) - MS-RDPBCGR 2.2.14.1.5 */\n\t\t\tsuccess = autodetect_recv_netchar_result(rdp, s, &autodetectReqPdu);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\treturn success ? 0 : -1;\n}\n\nint rdp_recv_autodetect_response_packet(rdpRdp* rdp, wStream* s)\n{\n\tAUTODETECT_RSP_PDU autodetectRspPdu;\n\tBOOL success = FALSE;\n\n\tif (Stream_GetRemainingLength(s) < 6)\n\t\treturn -1;\n\n\tStream_Read_UINT8(s, autodetectRspPdu.headerLength);    /* headerLength (1 byte) */\n\tStream_Read_UINT8(s, autodetectRspPdu.headerTypeId);    /* headerTypeId (1 byte) */\n\tStream_Read_UINT16(s, autodetectRspPdu.sequenceNumber); /* sequenceNumber (2 bytes) */\n\tStream_Read_UINT16(s, autodetectRspPdu.responseType);   /* responseType (2 bytes) */\n\tWLog_VRB(AUTODETECT_TAG,\n\t         \"rdp_recv_autodetect_response_packet: headerLength=%\" PRIu8 \", headerTypeId=%\" PRIu8\n\t         \", sequenceNumber=%\" PRIu16 \", requestType=%04\" PRIx16 \"\",\n\t         autodetectRspPdu.headerLength, autodetectRspPdu.headerTypeId,\n\t         autodetectRspPdu.sequenceNumber, autodetectRspPdu.responseType);\n\n\tif (autodetectRspPdu.headerTypeId != TYPE_ID_AUTODETECT_RESPONSE)\n\t\treturn -1;\n\n\tswitch (autodetectRspPdu.responseType)\n\t{\n\t\tcase RDP_RTT_RESPONSE_TYPE:\n\t\t\t/* RTT Measure Response (RDP_RTT_RESPONSE) - MS-RDPBCGR 2.2.14.2.1 */\n\t\t\tsuccess = autodetect_recv_rtt_measure_response(rdp, s, &autodetectRspPdu);\n\t\t\tbreak;\n\n\t\tcase RDP_BW_RESULTS_RESPONSE_TYPE_CONNECTTIME:\n\t\tcase RDP_BW_RESULTS_RESPONSE_TYPE_CONTINUOUS:\n\t\t\t/* Bandwidth Measure Results (RDP_BW_RESULTS) - MS-RDPBCGR 2.2.14.2.2 */\n\t\t\tsuccess = autodetect_recv_bandwidth_measure_results(rdp, s, &autodetectRspPdu);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn success ? 0 : -1;\n}\n\nrdpAutoDetect* autodetect_new(void)\n{\n\trdpAutoDetect* autoDetect = (rdpAutoDetect*)calloc(1, sizeof(rdpAutoDetect));\n\n\tif (autoDetect)\n\t{\n\t}\n\n\treturn autoDetect;\n}\n\nvoid autodetect_free(rdpAutoDetect* autoDetect)\n{\n\tfree(autoDetect);\n}\n\nvoid autodetect_register_server_callbacks(rdpAutoDetect* autodetect)\n{\n\tautodetect->RTTMeasureRequest = autodetect_send_continuous_rtt_measure_request;\n\tautodetect->BandwidthMeasureStart = autodetect_send_continuous_bandwidth_measure_start;\n\tautodetect->BandwidthMeasureStop = autodetect_send_continuous_bandwidth_measure_stop;\n\tautodetect->NetworkCharacteristicsResult = autodetect_send_netchar_result;\n}\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * RDP Capability Sets\n *\n * Copyright 2011 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *\t http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"capabilities.h\"\n#include \"fastpath.h\"\n\n#include <winpr/crt.h>\n#include <winpr/rpc.h>\n\n#include <freerdp/log.h>\n\n#define TAG FREERDP_TAG(\"core.capabilities\")\n\nstatic const char* const CAPSET_TYPE_STRINGS[] = { \"Unknown\",\n\t                                               \"General\",\n\t                                               \"Bitmap\",\n\t                                               \"Order\",\n\t                                               \"Bitmap Cache\",\n\t                                               \"Control\",\n\t                                               \"Unknown\",\n\t                                               \"Window Activation\",\n\t                                               \"Pointer\",\n\t                                               \"Share\",\n\t                                               \"Color Cache\",\n\t                                               \"Unknown\",\n\t                                               \"Sound\",\n\t                                               \"Input\",\n\t                                               \"Font\",\n\t                                               \"Brush\",\n\t                                               \"Glyph Cache\",\n\t                                               \"Offscreen Bitmap Cache\",\n\t                                               \"Bitmap Cache Host Support\",\n\t                                               \"Bitmap Cache v2\",\n\t                                               \"Virtual Channel\",\n\t                                               \"DrawNineGrid Cache\",\n\t                                               \"Draw GDI+ Cache\",\n\t                                               \"Remote Programs\",\n\t                                               \"Window List\",\n\t                                               \"Desktop Composition\",\n\t                                               \"Multifragment Update\",\n\t                                               \"Large Pointer\",\n\t                                               \"Surface Commands\",\n\t                                               \"Bitmap Codecs\",\n\t                                               \"Frame Acknowledge\" };\n\nstatic const char* get_capability_name(UINT16 type)\n{\n\tif (type > CAPSET_TYPE_FRAME_ACKNOWLEDGE)\n\t\treturn \"<unknown>\";\n\n\treturn CAPSET_TYPE_STRINGS[type];\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_capability_sets(wStream* s, UINT16 numberCapabilities, BOOL receiving);\n#endif\n\n/* CODEC_GUID_REMOTEFX: 0x76772F12BD724463AFB3B73C9C6F7886 */\n\nstatic const GUID CODEC_GUID_REMOTEFX = {\n\t0x76772F12, 0xBD72, 0x4463, { 0xAF, 0xB3, 0xB7, 0x3C, 0x9C, 0x6F, 0x78, 0x86 }\n};\n\n/* CODEC_GUID_NSCODEC 0xCA8D1BB9000F154F589FAE2D1A87E2D6 */\n\nstatic const GUID CODEC_GUID_NSCODEC = {\n\t0xCA8D1BB9, 0x000F, 0x154F, { 0x58, 0x9F, 0xAE, 0x2D, 0x1A, 0x87, 0xE2, 0xD6 }\n};\n\n/* CODEC_GUID_IGNORE 0x9C4351A6353542AE910CCDFCE5760B58 */\n\nstatic const GUID CODEC_GUID_IGNORE = {\n\t0x9C4351A6, 0x3535, 0x42AE, { 0x91, 0x0C, 0xCD, 0xFC, 0xE5, 0x76, 0x0B, 0x58 }\n};\n\n/* CODEC_GUID_IMAGE_REMOTEFX 0x2744CCD49D8A4E74803C0ECBEEA19C54 */\n\nstatic const GUID CODEC_GUID_IMAGE_REMOTEFX = {\n\t0x2744CCD4, 0x9D8A, 0x4E74, { 0x80, 0x3C, 0x0E, 0xCB, 0xEE, 0xA1, 0x9C, 0x54 }\n};\n\n#if defined(WITH_JPEG)\n/* CODEC_GUID_JPEG 0x430C9EED1BAF4CE6869ACB8B37B66237 */\n\nstatic const GUID CODEC_GUID_JPEG = {\n\t0x430C9EED, 0x1BAF, 0x4CE6, { 0x86, 0x9A, 0xCB, 0x8B, 0x37, 0xB6, 0x62, 0x37 }\n};\n#endif\n\nstatic BOOL rdp_read_capability_set_header(wStream* s, UINT16* length, UINT16* type)\n{\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\tStream_Read_UINT16(s, *type);   /* capabilitySetType */\n\tStream_Read_UINT16(s, *length); /* lengthCapability */\n\tif (*length < 4)\n\t\treturn FALSE;\n\treturn TRUE;\n}\n\nstatic void rdp_write_capability_set_header(wStream* s, UINT16 length, UINT16 type)\n{\n\tStream_Write_UINT16(s, type);   /* capabilitySetType */\n\tStream_Write_UINT16(s, length); /* lengthCapability */\n}\n\nstatic size_t rdp_capability_set_start(wStream* s)\n{\n\tsize_t header = Stream_GetPosition(s);\n\tStream_Zero(s, CAPSET_HEADER_LENGTH);\n\treturn header;\n}\n\nstatic void rdp_capability_set_finish(wStream* s, UINT16 header, UINT16 type)\n{\n\tsize_t footer;\n\tsize_t length;\n\tfooter = Stream_GetPosition(s);\n\tlength = footer - header;\n\tStream_SetPosition(s, header);\n\trdp_write_capability_set_header(s, (UINT16)length, type);\n\tStream_SetPosition(s, footer);\n}\n\n/**\n * Read general capability set.\\n\n * @msdn{cc240549}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_general_capability_set(wStream* s, rdpSettings* settings)\n{\n\tUINT16 extraFlags;\n\tBYTE refreshRectSupport;\n\tBYTE suppressOutputSupport;\n\n\tif (Stream_GetRemainingLength(s) < 20)\n\t\treturn FALSE;\n\n\tif (settings->ServerMode)\n\t{\n\t\tStream_Read_UINT16(s, settings->OsMajorType); /* osMajorType (2 bytes) */\n\t\tStream_Read_UINT16(s, settings->OsMinorType); /* osMinorType (2 bytes) */\n\t}\n\telse\n\t{\n\t\tStream_Seek_UINT16(s); /* osMajorType (2 bytes) */\n\t\tStream_Seek_UINT16(s); /* osMinorType (2 bytes) */\n\t}\n\n\tStream_Seek_UINT16(s);                       /* protocolVersion (2 bytes) */\n\tStream_Seek_UINT16(s);                       /* pad2OctetsA (2 bytes) */\n\tStream_Seek_UINT16(s);                       /* generalCompressionTypes (2 bytes) */\n\tStream_Read_UINT16(s, extraFlags);           /* extraFlags (2 bytes) */\n\tStream_Seek_UINT16(s);                       /* updateCapabilityFlag (2 bytes) */\n\tStream_Seek_UINT16(s);                       /* remoteUnshareFlag (2 bytes) */\n\tStream_Seek_UINT16(s);                       /* generalCompressionLevel (2 bytes) */\n\tStream_Read_UINT8(s, refreshRectSupport);    /* refreshRectSupport (1 byte) */\n\tStream_Read_UINT8(s, suppressOutputSupport); /* suppressOutputSupport (1 byte) */\n\tsettings->NoBitmapCompressionHeader = (extraFlags & NO_BITMAP_COMPRESSION_HDR) ? TRUE : FALSE;\n\tsettings->LongCredentialsSupported = (extraFlags & LONG_CREDENTIALS_SUPPORTED) ? TRUE : FALSE;\n\n\tif (!(extraFlags & FASTPATH_OUTPUT_SUPPORTED))\n\t\tsettings->FastPathOutput = FALSE;\n\n\tif (!(extraFlags & ENC_SALTED_CHECKSUM))\n\t\tsettings->SaltedChecksum = FALSE;\n\n\tif (!settings->ServerMode)\n\t{\n\t\t/**\n\t\t * Note: refreshRectSupport and suppressOutputSupport are\n\t\t * server-only flags indicating to the client weather the\n\t\t * respective PDUs are supported. See MS-RDPBCGR 2.2.7.1.1\n\t\t */\n\t\tif (!refreshRectSupport)\n\t\t\tsettings->RefreshRect = FALSE;\n\n\t\tif (!suppressOutputSupport)\n\t\t\tsettings->SuppressOutput = FALSE;\n\t}\n\n\treturn TRUE;\n}\n\n/**\n * Write general capability set.\\n\n * @msdn{cc240549}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_general_capability_set(wStream* s, const rdpSettings* settings)\n{\n\tsize_t header;\n\tUINT16 extraFlags;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 64))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tif (header > UINT16_MAX)\n\t\treturn FALSE;\n\textraFlags = 0;\n\n\tif (settings->LongCredentialsSupported)\n\t\textraFlags |= LONG_CREDENTIALS_SUPPORTED;\n\n\tif (settings->NoBitmapCompressionHeader)\n\t\textraFlags |= NO_BITMAP_COMPRESSION_HDR;\n\n\tif (settings->AutoReconnectionEnabled)\n\t\textraFlags |= AUTORECONNECT_SUPPORTED;\n\n\tif (settings->FastPathOutput)\n\t\textraFlags |= FASTPATH_OUTPUT_SUPPORTED;\n\n\tif (settings->SaltedChecksum)\n\t\textraFlags |= ENC_SALTED_CHECKSUM;\n\n\tif ((settings->OsMajorType > UINT16_MAX) || (settings->OsMinorType > UINT16_MAX))\n\t{\n\t\tWLog_ERR(TAG,\n\t\t         \"OsMajorType=%08\" PRIx32 \", OsMinorType=%08\" PRIx32\n\t\t         \" they need to be smaller %04\" PRIx16,\n\t\t         settings->OsMajorType, settings->OsMinorType, UINT16_MAX);\n\t\treturn FALSE;\n\t}\n\tStream_Write_UINT16(s, (UINT16)settings->OsMajorType); /* osMajorType (2 bytes) */\n\tStream_Write_UINT16(s, (UINT16)settings->OsMinorType); /* osMinorType (2 bytes) */\n\tStream_Write_UINT16(s, CAPS_PROTOCOL_VERSION);   /* protocolVersion (2 bytes) */\n\tStream_Write_UINT16(s, 0);                       /* pad2OctetsA (2 bytes) */\n\tStream_Write_UINT16(s, 0);                       /* generalCompressionTypes (2 bytes) */\n\tStream_Write_UINT16(s, extraFlags);              /* extraFlags (2 bytes) */\n\tStream_Write_UINT16(s, 0);                       /* updateCapabilityFlag (2 bytes) */\n\tStream_Write_UINT16(s, 0);                       /* remoteUnshareFlag (2 bytes) */\n\tStream_Write_UINT16(s, 0);                       /* generalCompressionLevel (2 bytes) */\n\tStream_Write_UINT8(s, settings->RefreshRect ? 1 : 0);    /* refreshRectSupport (1 byte) */\n\tStream_Write_UINT8(s, settings->SuppressOutput ? 1 : 0); /* suppressOutputSupport (1 byte) */\n\trdp_capability_set_finish(s, (UINT16)header, CAPSET_TYPE_GENERAL);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_general_capability_set(wStream* s)\n{\n\tUINT16 osMajorType;\n\tUINT16 osMinorType;\n\tUINT16 protocolVersion;\n\tUINT16 pad2OctetsA;\n\tUINT16 generalCompressionTypes;\n\tUINT16 extraFlags;\n\tUINT16 updateCapabilityFlag;\n\tUINT16 remoteUnshareFlag;\n\tUINT16 generalCompressionLevel;\n\tBYTE refreshRectSupport;\n\tBYTE suppressOutputSupport;\n\n\tif (Stream_GetRemainingLength(s) < 20)\n\t\treturn FALSE;\n\n\tWLog_INFO(TAG, \"GeneralCapabilitySet (length %\" PRIuz \"):\", Stream_GetRemainingLength(s));\n\tStream_Read_UINT16(s, osMajorType);             /* osMajorType (2 bytes) */\n\tStream_Read_UINT16(s, osMinorType);             /* osMinorType (2 bytes) */\n\tStream_Read_UINT16(s, protocolVersion);         /* protocolVersion (2 bytes) */\n\tStream_Read_UINT16(s, pad2OctetsA);             /* pad2OctetsA (2 bytes) */\n\tStream_Read_UINT16(s, generalCompressionTypes); /* generalCompressionTypes (2 bytes) */\n\tStream_Read_UINT16(s, extraFlags);              /* extraFlags (2 bytes) */\n\tStream_Read_UINT16(s, updateCapabilityFlag);    /* updateCapabilityFlag (2 bytes) */\n\tStream_Read_UINT16(s, remoteUnshareFlag);       /* remoteUnshareFlag (2 bytes) */\n\tStream_Read_UINT16(s, generalCompressionLevel); /* generalCompressionLevel (2 bytes) */\n\tStream_Read_UINT8(s, refreshRectSupport);       /* refreshRectSupport (1 byte) */\n\tStream_Read_UINT8(s, suppressOutputSupport);    /* suppressOutputSupport (1 byte) */\n\tWLog_INFO(TAG, \"\\tosMajorType: 0x%04\" PRIX16 \"\", osMajorType);\n\tWLog_INFO(TAG, \"\\tosMinorType: 0x%04\" PRIX16 \"\", osMinorType);\n\tWLog_INFO(TAG, \"\\tprotocolVersion: 0x%04\" PRIX16 \"\", protocolVersion);\n\tWLog_INFO(TAG, \"\\tpad2OctetsA: 0x%04\" PRIX16 \"\", pad2OctetsA);\n\tWLog_INFO(TAG, \"\\tgeneralCompressionTypes: 0x%04\" PRIX16 \"\", generalCompressionTypes);\n\tWLog_INFO(TAG, \"\\textraFlags: 0x%04\" PRIX16 \"\", extraFlags);\n\tWLog_INFO(TAG, \"\\tupdateCapabilityFlag: 0x%04\" PRIX16 \"\", updateCapabilityFlag);\n\tWLog_INFO(TAG, \"\\tremoteUnshareFlag: 0x%04\" PRIX16 \"\", remoteUnshareFlag);\n\tWLog_INFO(TAG, \"\\tgeneralCompressionLevel: 0x%04\" PRIX16 \"\", generalCompressionLevel);\n\tWLog_INFO(TAG, \"\\trefreshRectSupport: 0x%02\" PRIX8 \"\", refreshRectSupport);\n\tWLog_INFO(TAG, \"\\tsuppressOutputSupport: 0x%02\" PRIX8 \"\", suppressOutputSupport);\n\treturn TRUE;\n}\n#endif\n\n/**\n * Read bitmap capability set.\\n\n * @msdn{cc240554}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_bitmap_capability_set(wStream* s, rdpSettings* settings)\n{\n\tBYTE drawingFlags;\n\tUINT16 desktopWidth;\n\tUINT16 desktopHeight;\n\tUINT16 desktopResizeFlag;\n\tUINT16 preferredBitsPerPixel;\n\n\tif (Stream_GetRemainingLength(s) < 24)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, preferredBitsPerPixel); /* preferredBitsPerPixel (2 bytes) */\n\tStream_Seek_UINT16(s);                        /* receive1BitPerPixel (2 bytes) */\n\tStream_Seek_UINT16(s);                        /* receive4BitsPerPixel (2 bytes) */\n\tStream_Seek_UINT16(s);                        /* receive8BitsPerPixel (2 bytes) */\n\tStream_Read_UINT16(s, desktopWidth);          /* desktopWidth (2 bytes) */\n\tStream_Read_UINT16(s, desktopHeight);         /* desktopHeight (2 bytes) */\n\tStream_Seek_UINT16(s);                        /* pad2Octets (2 bytes) */\n\tStream_Read_UINT16(s, desktopResizeFlag);     /* desktopResizeFlag (2 bytes) */\n\tStream_Seek_UINT16(s);                        /* bitmapCompressionFlag (2 bytes) */\n\tStream_Seek_UINT8(s);                         /* highColorFlags (1 byte) */\n\tStream_Read_UINT8(s, drawingFlags);           /* drawingFlags (1 byte) */\n\tStream_Seek_UINT16(s);                        /* multipleRectangleSupport (2 bytes) */\n\tStream_Seek_UINT16(s);                        /* pad2OctetsB (2 bytes) */\n\n\tif (!settings->ServerMode && (preferredBitsPerPixel != settings->ColorDepth))\n\t{\n\t\t/* The client must respect the actual color depth used by the server */\n\t\tsettings->ColorDepth = preferredBitsPerPixel;\n\t}\n\n\tif (desktopResizeFlag == FALSE)\n\t\tsettings->DesktopResize = FALSE;\n\n\tif (!settings->ServerMode && settings->DesktopResize)\n\t{\n\t\t/* The server may request a different desktop size during Deactivation-Reactivation sequence\n\t\t */\n\t\tsettings->DesktopWidth = desktopWidth;\n\t\tsettings->DesktopHeight = desktopHeight;\n\t}\n\n\tif (settings->DrawAllowSkipAlpha)\n\t\tsettings->DrawAllowSkipAlpha = (drawingFlags & DRAW_ALLOW_SKIP_ALPHA) ? TRUE : FALSE;\n\n\tif (settings->DrawAllowDynamicColorFidelity)\n\t\tsettings->DrawAllowDynamicColorFidelity =\n\t\t    (drawingFlags & DRAW_ALLOW_DYNAMIC_COLOR_FIDELITY) ? TRUE : FALSE;\n\n\tif (settings->DrawAllowColorSubsampling)\n\t\tsettings->DrawAllowColorSubsampling =\n\t\t    (drawingFlags & DRAW_ALLOW_COLOR_SUBSAMPLING) ? TRUE : FALSE;\n\n\treturn TRUE;\n}\n\n/**\n * Write bitmap capability set.\\n\n * @msdn{cc240554}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_bitmap_capability_set(wStream* s, const rdpSettings* settings)\n{\n\tsize_t header;\n\tBYTE drawingFlags = 0;\n\tUINT16 preferredBitsPerPixel;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 64))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tif (header > UINT16_MAX)\n\t\treturn FALSE;\n\tif (settings->DrawAllowSkipAlpha)\n\t\tdrawingFlags |= DRAW_ALLOW_SKIP_ALPHA;\n\n\tif (settings->DrawAllowDynamicColorFidelity)\n\t\tdrawingFlags |= DRAW_ALLOW_DYNAMIC_COLOR_FIDELITY;\n\n\tif (settings->DrawAllowColorSubsampling)\n\t\tdrawingFlags |= DRAW_ALLOW_COLOR_SUBSAMPLING; /* currently unimplemented */\n\n\t/* While bitmap_decode.c now implements YCoCg, in turning it\n\t * on we have found Microsoft is inconsistent on whether to invert R & B.\n\t * And it's not only from one server to another; on Win7/2008R2, it appears\n\t * to send the main content with a different inversion than the Windows\n\t * button!  So... don't advertise that we support YCoCg and the server\n\t * will not send it.  YCoCg is still needed for EGFX, but it at least\n\t * appears consistent in its use.\n\t */\n\n\tif ((settings->ColorDepth > UINT16_MAX) || (settings->DesktopWidth > UINT16_MAX) ||\n\t    (settings->DesktopHeight > UINT16_MAX) || (settings->DesktopResize > UINT16_MAX))\n\t\treturn FALSE;\n\n\tif (settings->RdpVersion >= RDP_VERSION_5_PLUS)\n\t\tpreferredBitsPerPixel = (UINT16)settings->ColorDepth;\n\telse\n\t\tpreferredBitsPerPixel = 8;\n\n\tStream_Write_UINT16(s, preferredBitsPerPixel);   /* preferredBitsPerPixel (2 bytes) */\n\tStream_Write_UINT16(s, 1);                       /* receive1BitPerPixel (2 bytes) */\n\tStream_Write_UINT16(s, 1);                       /* receive4BitsPerPixel (2 bytes) */\n\tStream_Write_UINT16(s, 1);                       /* receive8BitsPerPixel (2 bytes) */\n\tStream_Write_UINT16(s, (UINT16)settings->DesktopWidth);  /* desktopWidth (2 bytes) */\n\tStream_Write_UINT16(s, (UINT16)settings->DesktopHeight); /* desktopHeight (2 bytes) */\n\tStream_Write_UINT16(s, 0);                       /* pad2Octets (2 bytes) */\n\tStream_Write_UINT16(s, (UINT16)settings->DesktopResize); /* desktopResizeFlag (2 bytes) */\n\tStream_Write_UINT16(s, 1);                       /* bitmapCompressionFlag (2 bytes) */\n\tStream_Write_UINT8(s, 0);                        /* highColorFlags (1 byte) */\n\tStream_Write_UINT8(s, drawingFlags);             /* drawingFlags (1 byte) */\n\tStream_Write_UINT16(s, 1);                       /* multipleRectangleSupport (2 bytes) */\n\tStream_Write_UINT16(s, 0);                       /* pad2OctetsB (2 bytes) */\n\trdp_capability_set_finish(s, (UINT16)header, CAPSET_TYPE_BITMAP);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_bitmap_capability_set(wStream* s)\n{\n\tUINT16 preferredBitsPerPixel;\n\tUINT16 receive1BitPerPixel;\n\tUINT16 receive4BitsPerPixel;\n\tUINT16 receive8BitsPerPixel;\n\tUINT16 desktopWidth;\n\tUINT16 desktopHeight;\n\tUINT16 pad2Octets;\n\tUINT16 desktopResizeFlag;\n\tUINT16 bitmapCompressionFlag;\n\tBYTE highColorFlags;\n\tBYTE drawingFlags;\n\tUINT16 multipleRectangleSupport;\n\tUINT16 pad2OctetsB;\n\tWLog_INFO(TAG, \"BitmapCapabilitySet (length %\" PRIuz \"):\", Stream_GetRemainingLength(s));\n\n\tif (Stream_GetRemainingLength(s) < 24)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, preferredBitsPerPixel);    /* preferredBitsPerPixel (2 bytes) */\n\tStream_Read_UINT16(s, receive1BitPerPixel);      /* receive1BitPerPixel (2 bytes) */\n\tStream_Read_UINT16(s, receive4BitsPerPixel);     /* receive4BitsPerPixel (2 bytes) */\n\tStream_Read_UINT16(s, receive8BitsPerPixel);     /* receive8BitsPerPixel (2 bytes) */\n\tStream_Read_UINT16(s, desktopWidth);             /* desktopWidth (2 bytes) */\n\tStream_Read_UINT16(s, desktopHeight);            /* desktopHeight (2 bytes) */\n\tStream_Read_UINT16(s, pad2Octets);               /* pad2Octets (2 bytes) */\n\tStream_Read_UINT16(s, desktopResizeFlag);        /* desktopResizeFlag (2 bytes) */\n\tStream_Read_UINT16(s, bitmapCompressionFlag);    /* bitmapCompressionFlag (2 bytes) */\n\tStream_Read_UINT8(s, highColorFlags);            /* highColorFlags (1 byte) */\n\tStream_Read_UINT8(s, drawingFlags);              /* drawingFlags (1 byte) */\n\tStream_Read_UINT16(s, multipleRectangleSupport); /* multipleRectangleSupport (2 bytes) */\n\tStream_Read_UINT16(s, pad2OctetsB);              /* pad2OctetsB (2 bytes) */\n\tWLog_INFO(TAG, \"\\tpreferredBitsPerPixel: 0x%04\" PRIX16 \"\", preferredBitsPerPixel);\n\tWLog_INFO(TAG, \"\\treceive1BitPerPixel: 0x%04\" PRIX16 \"\", receive1BitPerPixel);\n\tWLog_INFO(TAG, \"\\treceive4BitsPerPixel: 0x%04\" PRIX16 \"\", receive4BitsPerPixel);\n\tWLog_INFO(TAG, \"\\treceive8BitsPerPixel: 0x%04\" PRIX16 \"\", receive8BitsPerPixel);\n\tWLog_INFO(TAG, \"\\tdesktopWidth: 0x%04\" PRIX16 \"\", desktopWidth);\n\tWLog_INFO(TAG, \"\\tdesktopHeight: 0x%04\" PRIX16 \"\", desktopHeight);\n\tWLog_INFO(TAG, \"\\tpad2Octets: 0x%04\" PRIX16 \"\", pad2Octets);\n\tWLog_INFO(TAG, \"\\tdesktopResizeFlag: 0x%04\" PRIX16 \"\", desktopResizeFlag);\n\tWLog_INFO(TAG, \"\\tbitmapCompressionFlag: 0x%04\" PRIX16 \"\", bitmapCompressionFlag);\n\tWLog_INFO(TAG, \"\\thighColorFlags: 0x%02\" PRIX8 \"\", highColorFlags);\n\tWLog_INFO(TAG, \"\\tdrawingFlags: 0x%02\" PRIX8 \"\", drawingFlags);\n\tWLog_INFO(TAG, \"\\tmultipleRectangleSupport: 0x%04\" PRIX16 \"\", multipleRectangleSupport);\n\tWLog_INFO(TAG, \"\\tpad2OctetsB: 0x%04\" PRIX16 \"\", pad2OctetsB);\n\treturn TRUE;\n}\n#endif\n\n/**\n * Read order capability set.\\n\n * @msdn{cc240556}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_order_capability_set(wStream* s, rdpSettings* settings)\n{\n\tint i;\n\tUINT16 orderFlags;\n\tBYTE orderSupport[32];\n\tUINT16 orderSupportExFlags;\n\tBOOL BitmapCacheV3Enabled = FALSE;\n\tBOOL FrameMarkerCommandEnabled = FALSE;\n\n\tif (Stream_GetRemainingLength(s) < 84)\n\t\treturn FALSE;\n\n\tStream_Seek(s, 16);                         /* terminalDescriptor (16 bytes) */\n\tStream_Seek_UINT32(s);                      /* pad4OctetsA (4 bytes) */\n\tStream_Seek_UINT16(s);                      /* desktopSaveXGranularity (2 bytes) */\n\tStream_Seek_UINT16(s);                      /* desktopSaveYGranularity (2 bytes) */\n\tStream_Seek_UINT16(s);                      /* pad2OctetsA (2 bytes) */\n\tStream_Seek_UINT16(s);                      /* maximumOrderLevel (2 bytes) */\n\tStream_Seek_UINT16(s);                      /* numberFonts (2 bytes) */\n\tStream_Read_UINT16(s, orderFlags);          /* orderFlags (2 bytes) */\n\tStream_Read(s, orderSupport, 32);           /* orderSupport (32 bytes) */\n\tStream_Seek_UINT16(s);                      /* textFlags (2 bytes) */\n\tStream_Read_UINT16(s, orderSupportExFlags); /* orderSupportExFlags (2 bytes) */\n\tStream_Seek_UINT32(s);                      /* pad4OctetsB (4 bytes) */\n\tStream_Seek_UINT32(s);                      /* desktopSaveSize (4 bytes) */\n\tStream_Seek_UINT16(s);                      /* pad2OctetsC (2 bytes) */\n\tStream_Seek_UINT16(s);                      /* pad2OctetsD (2 bytes) */\n\tStream_Seek_UINT16(s);                      /* textANSICodePage (2 bytes) */\n\tStream_Seek_UINT16(s);                      /* pad2OctetsE (2 bytes) */\n\n\tfor (i = 0; i < 32; i++)\n\t{\n\t\tif (orderSupport[i] == FALSE)\n\t\t\tsettings->OrderSupport[i] = FALSE;\n\t}\n\n\tif (orderFlags & ORDER_FLAGS_EXTRA_SUPPORT)\n\t{\n\t\tif (orderSupportExFlags & CACHE_BITMAP_V3_SUPPORT)\n\t\t\tBitmapCacheV3Enabled = TRUE;\n\n\t\tif (orderSupportExFlags & ALTSEC_FRAME_MARKER_SUPPORT)\n\t\t\tFrameMarkerCommandEnabled = TRUE;\n\t}\n\n\tif (settings->BitmapCacheV3Enabled && BitmapCacheV3Enabled)\n\t\tsettings->BitmapCacheVersion = 3;\n\telse\n\t\tsettings->BitmapCacheV3Enabled = FALSE;\n\n\tif (settings->FrameMarkerCommandEnabled && !FrameMarkerCommandEnabled)\n\t\tsettings->FrameMarkerCommandEnabled = FALSE;\n\n\treturn TRUE;\n}\n\n/**\n * Write order capability set.\\n\n * @msdn{cc240556}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_order_capability_set(wStream* s, const rdpSettings* settings)\n{\n\tsize_t header;\n\tUINT16 orderFlags;\n\tUINT16 orderSupportExFlags;\n\tUINT16 textANSICodePage = 0;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 64))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tif (header > UINT16_MAX)\n\t\treturn FALSE;\n\t/* see [MSDN-CP]: http://msdn.microsoft.com/en-us/library/dd317756 */\n\tif (!settings->ServerMode)\n\t\ttextANSICodePage = CP_UTF8; /* Unicode (UTF-8) */\n\n\torderSupportExFlags = 0;\n\torderFlags = NEGOTIATE_ORDER_SUPPORT | ZERO_BOUNDS_DELTA_SUPPORT | COLOR_INDEX_SUPPORT;\n\n\tif (settings->BitmapCacheV3Enabled)\n\t{\n\t\torderSupportExFlags |= CACHE_BITMAP_V3_SUPPORT;\n\t\torderFlags |= ORDER_FLAGS_EXTRA_SUPPORT;\n\t}\n\n\tif (settings->FrameMarkerCommandEnabled)\n\t{\n\t\torderSupportExFlags |= ALTSEC_FRAME_MARKER_SUPPORT;\n\t\torderFlags |= ORDER_FLAGS_EXTRA_SUPPORT;\n\t}\n\n\tStream_Zero(s, 16);                          /* terminalDescriptor (16 bytes) */\n\tStream_Write_UINT32(s, 0);                   /* pad4OctetsA (4 bytes) */\n\tStream_Write_UINT16(s, 1);                   /* desktopSaveXGranularity (2 bytes) */\n\tStream_Write_UINT16(s, 20);                  /* desktopSaveYGranularity (2 bytes) */\n\tStream_Write_UINT16(s, 0);                   /* pad2OctetsA (2 bytes) */\n\tStream_Write_UINT16(s, 1);                   /* maximumOrderLevel (2 bytes) */\n\tStream_Write_UINT16(s, 0);                   /* numberFonts (2 bytes) */\n\tStream_Write_UINT16(s, orderFlags);          /* orderFlags (2 bytes) */\n\tStream_Write(s, settings->OrderSupport, 32); /* orderSupport (32 bytes) */\n\tStream_Write_UINT16(s, 0);                   /* textFlags (2 bytes) */\n\tStream_Write_UINT16(s, orderSupportExFlags); /* orderSupportExFlags (2 bytes) */\n\tStream_Write_UINT32(s, 0);                   /* pad4OctetsB (4 bytes) */\n\tStream_Write_UINT32(s, 230400);              /* desktopSaveSize (4 bytes) */\n\tStream_Write_UINT16(s, 0);                   /* pad2OctetsC (2 bytes) */\n\tStream_Write_UINT16(s, 0);                   /* pad2OctetsD (2 bytes) */\n\tStream_Write_UINT16(s, textANSICodePage);    /* textANSICodePage (2 bytes) */\n\tStream_Write_UINT16(s, 0);                   /* pad2OctetsE (2 bytes) */\n\trdp_capability_set_finish(s, (UINT16)header, CAPSET_TYPE_ORDER);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_order_capability_set(wStream* s)\n{\n\tBYTE terminalDescriptor[16];\n\tUINT32 pad4OctetsA;\n\tUINT16 desktopSaveXGranularity;\n\tUINT16 desktopSaveYGranularity;\n\tUINT16 pad2OctetsA;\n\tUINT16 maximumOrderLevel;\n\tUINT16 numberFonts;\n\tUINT16 orderFlags;\n\tBYTE orderSupport[32];\n\tUINT16 textFlags;\n\tUINT16 orderSupportExFlags;\n\tUINT32 pad4OctetsB;\n\tUINT32 desktopSaveSize;\n\tUINT16 pad2OctetsC;\n\tUINT16 pad2OctetsD;\n\tUINT16 textANSICodePage;\n\tUINT16 pad2OctetsE;\n\tWLog_INFO(TAG, \"OrderCapabilitySet (length %\" PRIuz \"):\", Stream_GetRemainingLength(s));\n\n\tif (Stream_GetRemainingLength(s) < 84)\n\t\treturn FALSE;\n\n\tStream_Read(s, terminalDescriptor, 16);         /* terminalDescriptor (16 bytes) */\n\tStream_Read_UINT32(s, pad4OctetsA);             /* pad4OctetsA (4 bytes) */\n\tStream_Read_UINT16(s, desktopSaveXGranularity); /* desktopSaveXGranularity (2 bytes) */\n\tStream_Read_UINT16(s, desktopSaveYGranularity); /* desktopSaveYGranularity (2 bytes) */\n\tStream_Read_UINT16(s, pad2OctetsA);             /* pad2OctetsA (2 bytes) */\n\tStream_Read_UINT16(s, maximumOrderLevel);       /* maximumOrderLevel (2 bytes) */\n\tStream_Read_UINT16(s, numberFonts);             /* numberFonts (2 bytes) */\n\tStream_Read_UINT16(s, orderFlags);              /* orderFlags (2 bytes) */\n\tStream_Read(s, orderSupport, 32);               /* orderSupport (32 bytes) */\n\tStream_Read_UINT16(s, textFlags);               /* textFlags (2 bytes) */\n\tStream_Read_UINT16(s, orderSupportExFlags);     /* orderSupportExFlags (2 bytes) */\n\tStream_Read_UINT32(s, pad4OctetsB);             /* pad4OctetsB (4 bytes) */\n\tStream_Read_UINT32(s, desktopSaveSize);         /* desktopSaveSize (4 bytes) */\n\tStream_Read_UINT16(s, pad2OctetsC);             /* pad2OctetsC (2 bytes) */\n\tStream_Read_UINT16(s, pad2OctetsD);             /* pad2OctetsD (2 bytes) */\n\tStream_Read_UINT16(s, textANSICodePage);        /* textANSICodePage (2 bytes) */\n\tStream_Read_UINT16(s, pad2OctetsE);             /* pad2OctetsE (2 bytes) */\n\tWLog_INFO(TAG, \"\\tpad4OctetsA: 0x%08\" PRIX32 \"\", pad4OctetsA);\n\tWLog_INFO(TAG, \"\\tdesktopSaveXGranularity: 0x%04\" PRIX16 \"\", desktopSaveXGranularity);\n\tWLog_INFO(TAG, \"\\tdesktopSaveYGranularity: 0x%04\" PRIX16 \"\", desktopSaveYGranularity);\n\tWLog_INFO(TAG, \"\\tpad2OctetsA: 0x%04\" PRIX16 \"\", pad2OctetsA);\n\tWLog_INFO(TAG, \"\\tmaximumOrderLevel: 0x%04\" PRIX16 \"\", maximumOrderLevel);\n\tWLog_INFO(TAG, \"\\tnumberFonts: 0x%04\" PRIX16 \"\", numberFonts);\n\tWLog_INFO(TAG, \"\\torderFlags: 0x%04\" PRIX16 \"\", orderFlags);\n\tWLog_INFO(TAG, \"\\torderSupport:\");\n\tWLog_INFO(TAG, \"\\t\\tDSTBLT: %\" PRIu8 \"\", orderSupport[NEG_DSTBLT_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tPATBLT: %\" PRIu8 \"\", orderSupport[NEG_PATBLT_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tSCRBLT: %\" PRIu8 \"\", orderSupport[NEG_SCRBLT_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tMEMBLT: %\" PRIu8 \"\", orderSupport[NEG_MEMBLT_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tMEM3BLT: %\" PRIu8 \"\", orderSupport[NEG_MEM3BLT_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tATEXTOUT: %\" PRIu8 \"\", orderSupport[NEG_ATEXTOUT_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tAEXTTEXTOUT: %\" PRIu8 \"\", orderSupport[NEG_AEXTTEXTOUT_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tDRAWNINEGRID: %\" PRIu8 \"\", orderSupport[NEG_DRAWNINEGRID_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tLINETO: %\" PRIu8 \"\", orderSupport[NEG_LINETO_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tMULTI_DRAWNINEGRID: %\" PRIu8 \"\",\n\t          orderSupport[NEG_MULTI_DRAWNINEGRID_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tOPAQUE_RECT: %\" PRIu8 \"\", orderSupport[NEG_OPAQUE_RECT_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tSAVEBITMAP: %\" PRIu8 \"\", orderSupport[NEG_SAVEBITMAP_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tWTEXTOUT: %\" PRIu8 \"\", orderSupport[NEG_WTEXTOUT_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tMEMBLT_V2: %\" PRIu8 \"\", orderSupport[NEG_MEMBLT_V2_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tMEM3BLT_V2: %\" PRIu8 \"\", orderSupport[NEG_MEM3BLT_V2_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tMULTIDSTBLT: %\" PRIu8 \"\", orderSupport[NEG_MULTIDSTBLT_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tMULTIPATBLT: %\" PRIu8 \"\", orderSupport[NEG_MULTIPATBLT_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tMULTISCRBLT: %\" PRIu8 \"\", orderSupport[NEG_MULTISCRBLT_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tMULTIOPAQUERECT: %\" PRIu8 \"\", orderSupport[NEG_MULTIOPAQUERECT_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tFAST_INDEX: %\" PRIu8 \"\", orderSupport[NEG_FAST_INDEX_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tPOLYGON_SC: %\" PRIu8 \"\", orderSupport[NEG_POLYGON_SC_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tPOLYGON_CB: %\" PRIu8 \"\", orderSupport[NEG_POLYGON_CB_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tPOLYLINE: %\" PRIu8 \"\", orderSupport[NEG_POLYLINE_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tUNUSED23: %\" PRIu8 \"\", orderSupport[NEG_UNUSED23_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tFAST_GLYPH: %\" PRIu8 \"\", orderSupport[NEG_FAST_GLYPH_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tELLIPSE_SC: %\" PRIu8 \"\", orderSupport[NEG_ELLIPSE_SC_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tELLIPSE_CB: %\" PRIu8 \"\", orderSupport[NEG_ELLIPSE_CB_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tGLYPH_INDEX: %\" PRIu8 \"\", orderSupport[NEG_GLYPH_INDEX_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tGLYPH_WEXTTEXTOUT: %\" PRIu8 \"\", orderSupport[NEG_GLYPH_WEXTTEXTOUT_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tGLYPH_WLONGTEXTOUT: %\" PRIu8 \"\",\n\t          orderSupport[NEG_GLYPH_WLONGTEXTOUT_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tGLYPH_WLONGEXTTEXTOUT: %\" PRIu8 \"\",\n\t          orderSupport[NEG_GLYPH_WLONGEXTTEXTOUT_INDEX]);\n\tWLog_INFO(TAG, \"\\t\\tUNUSED31: %\" PRIu8 \"\", orderSupport[NEG_UNUSED31_INDEX]);\n\tWLog_INFO(TAG, \"\\ttextFlags: 0x%04\" PRIX16 \"\", textFlags);\n\tWLog_INFO(TAG, \"\\torderSupportExFlags: 0x%04\" PRIX16 \"\", orderSupportExFlags);\n\tWLog_INFO(TAG, \"\\tpad4OctetsB: 0x%08\" PRIX32 \"\", pad4OctetsB);\n\tWLog_INFO(TAG, \"\\tdesktopSaveSize: 0x%08\" PRIX32 \"\", desktopSaveSize);\n\tWLog_INFO(TAG, \"\\tpad2OctetsC: 0x%04\" PRIX16 \"\", pad2OctetsC);\n\tWLog_INFO(TAG, \"\\tpad2OctetsD: 0x%04\" PRIX16 \"\", pad2OctetsD);\n\tWLog_INFO(TAG, \"\\ttextANSICodePage: 0x%04\" PRIX16 \"\", textANSICodePage);\n\tWLog_INFO(TAG, \"\\tpad2OctetsE: 0x%04\" PRIX16 \"\", pad2OctetsE);\n\treturn TRUE;\n}\n#endif\n\n/**\n * Read bitmap cache capability set.\\n\n * @msdn{cc240559}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_bitmap_cache_capability_set(wStream* s, rdpSettings* settings)\n{\n\tWINPR_UNUSED(settings);\n\tif (Stream_GetRemainingLength(s) < 36)\n\t\treturn FALSE;\n\n\tStream_Seek_UINT32(s); /* pad1 (4 bytes) */\n\tStream_Seek_UINT32(s); /* pad2 (4 bytes) */\n\tStream_Seek_UINT32(s); /* pad3 (4 bytes) */\n\tStream_Seek_UINT32(s); /* pad4 (4 bytes) */\n\tStream_Seek_UINT32(s); /* pad5 (4 bytes) */\n\tStream_Seek_UINT32(s); /* pad6 (4 bytes) */\n\tStream_Seek_UINT16(s); /* Cache0Entries (2 bytes) */\n\tStream_Seek_UINT16(s); /* Cache0MaximumCellSize (2 bytes) */\n\tStream_Seek_UINT16(s); /* Cache1Entries (2 bytes) */\n\tStream_Seek_UINT16(s); /* Cache1MaximumCellSize (2 bytes) */\n\tStream_Seek_UINT16(s); /* Cache2Entries (2 bytes) */\n\tStream_Seek_UINT16(s); /* Cache2MaximumCellSize (2 bytes) */\n\treturn TRUE;\n}\n\n/**\n * Write bitmap cache capability set.\\n\n * @msdn{cc240559}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_bitmap_cache_capability_set(wStream* s, const rdpSettings* settings)\n{\n\tUINT32 bpp;\n\tsize_t header;\n\tUINT32 size;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 64))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tif (header > UINT16_MAX)\n\t\treturn FALSE;\n\tbpp = (settings->ColorDepth + 7) / 8;\n\tif (bpp > UINT16_MAX)\n\t\treturn FALSE;\n\tStream_Write_UINT32(s, 0); /* pad1 (4 bytes) */\n\tStream_Write_UINT32(s, 0); /* pad2 (4 bytes) */\n\tStream_Write_UINT32(s, 0); /* pad3 (4 bytes) */\n\tStream_Write_UINT32(s, 0); /* pad4 (4 bytes) */\n\tStream_Write_UINT32(s, 0); /* pad5 (4 bytes) */\n\tStream_Write_UINT32(s, 0); /* pad6 (4 bytes) */\n\tsize = bpp * 256;\n\tif (size > UINT16_MAX)\n\t\treturn FALSE;\n\tStream_Write_UINT16(s, 200);  /* Cache0Entries (2 bytes) */\n\tStream_Write_UINT16(s, (UINT16)size); /* Cache0MaximumCellSize (2 bytes) */\n\tsize = bpp * 1024;\n\tif (size > UINT16_MAX)\n\t\treturn FALSE;\n\tStream_Write_UINT16(s, 600);  /* Cache1Entries (2 bytes) */\n\tStream_Write_UINT16(s, (UINT16)size); /* Cache1MaximumCellSize (2 bytes) */\n\tsize = bpp * 4096;\n\tif (size > UINT16_MAX)\n\t\treturn FALSE;\n\tStream_Write_UINT16(s, 1000); /* Cache2Entries (2 bytes) */\n\tStream_Write_UINT16(s, (UINT16)size); /* Cache2MaximumCellSize (2 bytes) */\n\trdp_capability_set_finish(s, (UINT16)header, CAPSET_TYPE_BITMAP_CACHE);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_bitmap_cache_capability_set(wStream* s)\n{\n\tUINT32 pad1, pad2, pad3;\n\tUINT32 pad4, pad5, pad6;\n\tUINT16 Cache0Entries;\n\tUINT16 Cache0MaximumCellSize;\n\tUINT16 Cache1Entries;\n\tUINT16 Cache1MaximumCellSize;\n\tUINT16 Cache2Entries;\n\tUINT16 Cache2MaximumCellSize;\n\tWLog_INFO(TAG, \"BitmapCacheCapabilitySet (length %\" PRIuz \"):\", Stream_GetRemainingLength(s));\n\n\tif (Stream_GetRemainingLength(s) < 36)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, pad1);                  /* pad1 (4 bytes) */\n\tStream_Read_UINT32(s, pad2);                  /* pad2 (4 bytes) */\n\tStream_Read_UINT32(s, pad3);                  /* pad3 (4 bytes) */\n\tStream_Read_UINT32(s, pad4);                  /* pad4 (4 bytes) */\n\tStream_Read_UINT32(s, pad5);                  /* pad5 (4 bytes) */\n\tStream_Read_UINT32(s, pad6);                  /* pad6 (4 bytes) */\n\tStream_Read_UINT16(s, Cache0Entries);         /* Cache0Entries (2 bytes) */\n\tStream_Read_UINT16(s, Cache0MaximumCellSize); /* Cache0MaximumCellSize (2 bytes) */\n\tStream_Read_UINT16(s, Cache1Entries);         /* Cache1Entries (2 bytes) */\n\tStream_Read_UINT16(s, Cache1MaximumCellSize); /* Cache1MaximumCellSize (2 bytes) */\n\tStream_Read_UINT16(s, Cache2Entries);         /* Cache2Entries (2 bytes) */\n\tStream_Read_UINT16(s, Cache2MaximumCellSize); /* Cache2MaximumCellSize (2 bytes) */\n\tWLog_INFO(TAG, \"\\tpad1: 0x%08\" PRIX32 \"\", pad1);\n\tWLog_INFO(TAG, \"\\tpad2: 0x%08\" PRIX32 \"\", pad2);\n\tWLog_INFO(TAG, \"\\tpad3: 0x%08\" PRIX32 \"\", pad3);\n\tWLog_INFO(TAG, \"\\tpad4: 0x%08\" PRIX32 \"\", pad4);\n\tWLog_INFO(TAG, \"\\tpad5: 0x%08\" PRIX32 \"\", pad5);\n\tWLog_INFO(TAG, \"\\tpad6: 0x%08\" PRIX32 \"\", pad6);\n\tWLog_INFO(TAG, \"\\tCache0Entries: 0x%04\" PRIX16 \"\", Cache0Entries);\n\tWLog_INFO(TAG, \"\\tCache0MaximumCellSize: 0x%04\" PRIX16 \"\", Cache0MaximumCellSize);\n\tWLog_INFO(TAG, \"\\tCache1Entries: 0x%04\" PRIX16 \"\", Cache1Entries);\n\tWLog_INFO(TAG, \"\\tCache1MaximumCellSize: 0x%04\" PRIX16 \"\", Cache1MaximumCellSize);\n\tWLog_INFO(TAG, \"\\tCache2Entries: 0x%04\" PRIX16 \"\", Cache2Entries);\n\tWLog_INFO(TAG, \"\\tCache2MaximumCellSize: 0x%04\" PRIX16 \"\", Cache2MaximumCellSize);\n\treturn TRUE;\n}\n#endif\n\n/**\n * Read control capability set.\\n\n * @msdn{cc240568}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_control_capability_set(wStream* s, rdpSettings* settings)\n{\n\tWINPR_UNUSED(settings);\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn FALSE;\n\n\tStream_Seek_UINT16(s); /* controlFlags (2 bytes) */\n\tStream_Seek_UINT16(s); /* remoteDetachFlag (2 bytes) */\n\tStream_Seek_UINT16(s); /* controlInterest (2 bytes) */\n\tStream_Seek_UINT16(s); /* detachInterest (2 bytes) */\n\treturn TRUE;\n}\n\n/**\n * Write control capability set.\\n\n * @msdn{cc240568}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_control_capability_set(wStream* s, const rdpSettings* settings)\n{\n\tsize_t header;\n\n\tWINPR_UNUSED(settings);\n\tif (!Stream_EnsureRemainingCapacity(s, 32))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tif (header > UINT16_MAX)\n\t\treturn FALSE;\n\tStream_Write_UINT16(s, 0); /* controlFlags (2 bytes) */\n\tStream_Write_UINT16(s, 0); /* remoteDetachFlag (2 bytes) */\n\tStream_Write_UINT16(s, 2); /* controlInterest (2 bytes) */\n\tStream_Write_UINT16(s, 2); /* detachInterest (2 bytes) */\n\trdp_capability_set_finish(s, (UINT16)header, CAPSET_TYPE_CONTROL);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_control_capability_set(wStream* s)\n{\n\tUINT16 controlFlags;\n\tUINT16 remoteDetachFlag;\n\tUINT16 controlInterest;\n\tUINT16 detachInterest;\n\tWLog_INFO(TAG, \"ControlCapabilitySet (length %\" PRIuz \"):\", Stream_GetRemainingLength(s));\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, controlFlags);     /* controlFlags (2 bytes) */\n\tStream_Read_UINT16(s, remoteDetachFlag); /* remoteDetachFlag (2 bytes) */\n\tStream_Read_UINT16(s, controlInterest);  /* controlInterest (2 bytes) */\n\tStream_Read_UINT16(s, detachInterest);   /* detachInterest (2 bytes) */\n\tWLog_INFO(TAG, \"\\tcontrolFlags: 0x%04\" PRIX16 \"\", controlFlags);\n\tWLog_INFO(TAG, \"\\tremoteDetachFlag: 0x%04\" PRIX16 \"\", remoteDetachFlag);\n\tWLog_INFO(TAG, \"\\tcontrolInterest: 0x%04\" PRIX16 \"\", controlInterest);\n\tWLog_INFO(TAG, \"\\tdetachInterest: 0x%04\" PRIX16 \"\", detachInterest);\n\treturn TRUE;\n}\n#endif\n\n/**\n * Read window activation capability set.\\n\n * @msdn{cc240569}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_window_activation_capability_set(wStream* s, rdpSettings* settings)\n{\n\tWINPR_UNUSED(settings);\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn FALSE;\n\n\tStream_Seek_UINT16(s); /* helpKeyFlag (2 bytes) */\n\tStream_Seek_UINT16(s); /* helpKeyIndexFlag (2 bytes) */\n\tStream_Seek_UINT16(s); /* helpExtendedKeyFlag (2 bytes) */\n\tStream_Seek_UINT16(s); /* windowManagerKeyFlag (2 bytes) */\n\treturn TRUE;\n}\n\n/**\n * Write window activation capability set.\\n\n * @msdn{cc240569}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_window_activation_capability_set(wStream* s, const rdpSettings* settings)\n{\n\tsize_t header;\n\n\tWINPR_UNUSED(settings);\n\tif (!Stream_EnsureRemainingCapacity(s, 32))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tif (header > UINT16_MAX)\n\t\treturn FALSE;\n\tStream_Write_UINT16(s, 0); /* helpKeyFlag (2 bytes) */\n\tStream_Write_UINT16(s, 0); /* helpKeyIndexFlag (2 bytes) */\n\tStream_Write_UINT16(s, 0); /* helpExtendedKeyFlag (2 bytes) */\n\tStream_Write_UINT16(s, 0); /* windowManagerKeyFlag (2 bytes) */\n\trdp_capability_set_finish(s, (UINT16)header, CAPSET_TYPE_ACTIVATION);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_window_activation_capability_set(wStream* s)\n{\n\tUINT16 helpKeyFlag;\n\tUINT16 helpKeyIndexFlag;\n\tUINT16 helpExtendedKeyFlag;\n\tUINT16 windowManagerKeyFlag;\n\tWLog_INFO(TAG,\n\t          \"WindowActivationCapabilitySet (length %\" PRIuz \"):\", Stream_GetRemainingLength(s));\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, helpKeyFlag);          /* helpKeyFlag (2 bytes) */\n\tStream_Read_UINT16(s, helpKeyIndexFlag);     /* helpKeyIndexFlag (2 bytes) */\n\tStream_Read_UINT16(s, helpExtendedKeyFlag);  /* helpExtendedKeyFlag (2 bytes) */\n\tStream_Read_UINT16(s, windowManagerKeyFlag); /* windowManagerKeyFlag (2 bytes) */\n\tWLog_INFO(TAG, \"\\thelpKeyFlag: 0x%04\" PRIX16 \"\", helpKeyFlag);\n\tWLog_INFO(TAG, \"\\thelpKeyIndexFlag: 0x%04\" PRIX16 \"\", helpKeyIndexFlag);\n\tWLog_INFO(TAG, \"\\thelpExtendedKeyFlag: 0x%04\" PRIX16 \"\", helpExtendedKeyFlag);\n\tWLog_INFO(TAG, \"\\twindowManagerKeyFlag: 0x%04\" PRIX16 \"\", windowManagerKeyFlag);\n\treturn TRUE;\n}\n#endif\n\n/**\n * Read pointer capability set.\\n\n * @msdn{cc240562}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_pointer_capability_set(wStream* s, rdpSettings* settings)\n{\n\tUINT16 colorPointerFlag;\n\tUINT16 colorPointerCacheSize;\n\tUINT16 pointerCacheSize;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, colorPointerFlag);      /* colorPointerFlag (2 bytes) */\n\tStream_Read_UINT16(s, colorPointerCacheSize); /* colorPointerCacheSize (2 bytes) */\n\n\t/* pointerCacheSize is optional */\n\tif (Stream_GetRemainingLength(s) >= 2)\n\t\tStream_Read_UINT16(s, pointerCacheSize); /* pointerCacheSize (2 bytes) */\n\telse\n\t\tpointerCacheSize = 0;\n\n\tif (colorPointerFlag == FALSE)\n\t\tsettings->ColorPointerFlag = FALSE;\n\n\tif (settings->ServerMode)\n\t{\n\t\tsettings->PointerCacheSize = pointerCacheSize;\n\t}\n\n\treturn TRUE;\n}\n\n/**\n * Write pointer capability set.\\n\n * @msdn{cc240562}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_pointer_capability_set(wStream* s, const rdpSettings* settings)\n{\n\tsize_t header;\n\tUINT16 colorPointerFlag;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 32))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tif (header > UINT16_MAX)\n\t\treturn FALSE;\n\tif (settings->PointerCacheSize > UINT16_MAX)\n\t\treturn FALSE;\n\n\tcolorPointerFlag = (settings->ColorPointerFlag) ? 1 : 0;\n\tStream_Write_UINT16(s, colorPointerFlag);           /* colorPointerFlag (2 bytes) */\n\tStream_Write_UINT16(s,\n\t                    (UINT16)settings->PointerCacheSize); /* colorPointerCacheSize (2 bytes) */\n\n\tif (settings->LargePointerFlag)\n\t{\n\t\tStream_Write_UINT16(s, (UINT16)settings->PointerCacheSize); /* pointerCacheSize (2 bytes) */\n\t}\n\n\trdp_capability_set_finish(s, (UINT16)header, CAPSET_TYPE_POINTER);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_pointer_capability_set(wStream* s)\n{\n\tUINT16 colorPointerFlag;\n\tUINT16 colorPointerCacheSize;\n\tUINT16 pointerCacheSize;\n\n\tif (Stream_GetRemainingLength(s) < 6)\n\t\treturn FALSE;\n\n\tWLog_INFO(TAG, \"PointerCapabilitySet (length %\" PRIuz \"):\", Stream_GetRemainingLength(s));\n\tStream_Read_UINT16(s, colorPointerFlag);      /* colorPointerFlag (2 bytes) */\n\tStream_Read_UINT16(s, colorPointerCacheSize); /* colorPointerCacheSize (2 bytes) */\n\tStream_Read_UINT16(s, pointerCacheSize);      /* pointerCacheSize (2 bytes) */\n\tWLog_INFO(TAG, \"\\tcolorPointerFlag: 0x%04\" PRIX16 \"\", colorPointerFlag);\n\tWLog_INFO(TAG, \"\\tcolorPointerCacheSize: 0x%04\" PRIX16 \"\", colorPointerCacheSize);\n\tWLog_INFO(TAG, \"\\tpointerCacheSize: 0x%04\" PRIX16 \"\", pointerCacheSize);\n\treturn TRUE;\n}\n#endif\n\n/**\n * Read share capability set.\\n\n * @msdn{cc240570}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_share_capability_set(wStream* s, rdpSettings* settings)\n{\n\tWINPR_UNUSED(settings);\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Seek_UINT16(s); /* nodeId (2 bytes) */\n\tStream_Seek_UINT16(s); /* pad2Octets (2 bytes) */\n\treturn TRUE;\n}\n\n/**\n * Write share capability set.\\n\n * @msdn{cc240570}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_share_capability_set(wStream* s, const rdpSettings* settings)\n{\n\tsize_t header;\n\tUINT16 nodeId;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 32))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tif (header > UINT16_MAX)\n\t\treturn FALSE;\n\tnodeId = (settings->ServerMode) ? 0x03EA : 0;\n\tStream_Write_UINT16(s, nodeId); /* nodeId (2 bytes) */\n\tStream_Write_UINT16(s, 0);      /* pad2Octets (2 bytes) */\n\trdp_capability_set_finish(s, (UINT16)header, CAPSET_TYPE_SHARE);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_share_capability_set(wStream* s)\n{\n\tUINT16 nodeId;\n\tUINT16 pad2Octets;\n\tWLog_INFO(TAG, \"ShareCapabilitySet (length %\" PRIuz \"):\", Stream_GetRemainingLength(s));\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, nodeId);     /* nodeId (2 bytes) */\n\tStream_Read_UINT16(s, pad2Octets); /* pad2Octets (2 bytes) */\n\tWLog_INFO(TAG, \"\\tnodeId: 0x%04\" PRIX16 \"\", nodeId);\n\tWLog_INFO(TAG, \"\\tpad2Octets: 0x%04\" PRIX16 \"\", pad2Octets);\n\treturn TRUE;\n}\n#endif\n\n/**\n * Read color cache capability set.\\n\n * @msdn{cc241564}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_color_cache_capability_set(wStream* s, rdpSettings* settings)\n{\n\tWINPR_UNUSED(settings);\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Seek_UINT16(s); /* colorTableCacheSize (2 bytes) */\n\tStream_Seek_UINT16(s); /* pad2Octets (2 bytes) */\n\treturn TRUE;\n}\n\n/**\n * Write color cache capability set.\\n\n * @msdn{cc241564}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_color_cache_capability_set(wStream* s, const rdpSettings* settings)\n{\n\tsize_t header;\n\n\tWINPR_UNUSED(settings);\n\tif (!Stream_EnsureRemainingCapacity(s, 32))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tif (header > UINT16_MAX)\n\t\treturn FALSE;\n\tStream_Write_UINT16(s, 6); /* colorTableCacheSize (2 bytes) */\n\tStream_Write_UINT16(s, 0); /* pad2Octets (2 bytes) */\n\trdp_capability_set_finish(s, (UINT16)header, CAPSET_TYPE_COLOR_CACHE);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_color_cache_capability_set(wStream* s)\n{\n\tUINT16 colorTableCacheSize;\n\tUINT16 pad2Octets;\n\tWLog_INFO(TAG, \"ColorCacheCapabilitySet (length %\" PRIuz \"):\", Stream_GetRemainingLength(s));\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, colorTableCacheSize); /* colorTableCacheSize (2 bytes) */\n\tStream_Read_UINT16(s, pad2Octets);          /* pad2Octets (2 bytes) */\n\tWLog_INFO(TAG, \"\\tcolorTableCacheSize: 0x%04\" PRIX16 \"\", colorTableCacheSize);\n\tWLog_INFO(TAG, \"\\tpad2Octets: 0x%04\" PRIX16 \"\", pad2Octets);\n\treturn TRUE;\n}\n#endif\n\n/**\n * Read sound capability set.\\n\n * @msdn{cc240552}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_sound_capability_set(wStream* s, rdpSettings* settings)\n{\n\tUINT16 soundFlags;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, soundFlags); /* soundFlags (2 bytes) */\n\tStream_Seek_UINT16(s);             /* pad2OctetsA (2 bytes) */\n\tsettings->SoundBeepsEnabled = (soundFlags & SOUND_BEEPS_FLAG) ? TRUE : FALSE;\n\treturn TRUE;\n}\n\n/**\n * Write sound capability set.\\n\n * @msdn{cc240552}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_sound_capability_set(wStream* s, const rdpSettings* settings)\n{\n\tsize_t header;\n\tUINT16 soundFlags;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 32))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tif (header > UINT16_MAX)\n\t\treturn FALSE;\n\tsoundFlags = (settings->SoundBeepsEnabled) ? SOUND_BEEPS_FLAG : 0;\n\tStream_Write_UINT16(s, soundFlags); /* soundFlags (2 bytes) */\n\tStream_Write_UINT16(s, 0);          /* pad2OctetsA (2 bytes) */\n\trdp_capability_set_finish(s, (UINT16)header, CAPSET_TYPE_SOUND);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_sound_capability_set(wStream* s)\n{\n\tUINT16 soundFlags;\n\tUINT16 pad2OctetsA;\n\tWLog_INFO(TAG, \"SoundCapabilitySet (length %\" PRIuz \"):\", Stream_GetRemainingLength(s));\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, soundFlags);  /* soundFlags (2 bytes) */\n\tStream_Read_UINT16(s, pad2OctetsA); /* pad2OctetsA (2 bytes) */\n\tWLog_INFO(TAG, \"\\tsoundFlags: 0x%04\" PRIX16 \"\", soundFlags);\n\tWLog_INFO(TAG, \"\\tpad2OctetsA: 0x%04\" PRIX16 \"\", pad2OctetsA);\n\treturn TRUE;\n}\n#endif\n\n/**\n * Read input capability set.\\n\n * @msdn{cc240563}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_input_capability_set(wStream* s, rdpSettings* settings)\n{\n\tUINT16 inputFlags;\n\n\tif (Stream_GetRemainingLength(s) < 84)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, inputFlags); /* inputFlags (2 bytes) */\n\tStream_Seek_UINT16(s);             /* pad2OctetsA (2 bytes) */\n\n\tif (settings->ServerMode)\n\t{\n\t\tStream_Read_UINT32(s, settings->KeyboardLayout);      /* keyboardLayout (4 bytes) */\n\t\tStream_Read_UINT32(s, settings->KeyboardType);        /* keyboardType (4 bytes) */\n\t\tStream_Read_UINT32(s, settings->KeyboardSubType);     /* keyboardSubType (4 bytes) */\n\t\tStream_Read_UINT32(s, settings->KeyboardFunctionKey); /* keyboardFunctionKeys (4 bytes) */\n\t}\n\telse\n\t{\n\t\tStream_Seek_UINT32(s); /* keyboardLayout (4 bytes) */\n\t\tStream_Seek_UINT32(s); /* keyboardType (4 bytes) */\n\t\tStream_Seek_UINT32(s); /* keyboardSubType (4 bytes) */\n\t\tStream_Seek_UINT32(s); /* keyboardFunctionKeys (4 bytes) */\n\t}\n\n\tStream_Seek(s, 64); /* imeFileName (64 bytes) */\n\n\tif (!settings->ServerMode)\n\t{\n\t\tif (inputFlags & INPUT_FLAG_FASTPATH_INPUT)\n\t\t{\n\t\t\t/* advertised by RDP 5.0 and 5.1 servers */\n\t\t}\n\t\telse if (inputFlags & INPUT_FLAG_FASTPATH_INPUT2)\n\t\t{\n\t\t\t/* advertised by RDP 5.2, 6.0, 6.1 and 7.0 servers */\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* server does not support fastpath input */\n\t\t\tsettings->FastPathInput = FALSE;\n\t\t}\n\n\t\tif (inputFlags & TS_INPUT_FLAG_MOUSE_HWHEEL)\n\t\t\tsettings->HasHorizontalWheel = TRUE;\n\n\t\tif (inputFlags & INPUT_FLAG_UNICODE)\n\t\t\tsettings->UnicodeInput = TRUE;\n\n\t\tif (inputFlags & INPUT_FLAG_MOUSEX)\n\t\t\tsettings->HasExtendedMouseEvent = TRUE;\n\t}\n\n\treturn TRUE;\n}\n\n/**\n * Write input capability set.\\n\n * @msdn{cc240563}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_input_capability_set(wStream* s, const rdpSettings* settings)\n{\n\tsize_t header;\n\tUINT16 inputFlags;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 128))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tif (header > UINT16_MAX)\n\t\treturn FALSE;\n\tinputFlags = INPUT_FLAG_SCANCODES;\n\n\tif (settings->FastPathInput)\n\t{\n\t\tinputFlags |= INPUT_FLAG_FASTPATH_INPUT;\n\t\tinputFlags |= INPUT_FLAG_FASTPATH_INPUT2;\n\t}\n\n\tif (settings->HasHorizontalWheel)\n\t\tinputFlags |= TS_INPUT_FLAG_MOUSE_HWHEEL;\n\n\tif (settings->UnicodeInput)\n\t\tinputFlags |= INPUT_FLAG_UNICODE;\n\n\tif (settings->HasExtendedMouseEvent)\n\t\tinputFlags |= INPUT_FLAG_MOUSEX;\n\n\tStream_Write_UINT16(s, inputFlags);                    /* inputFlags (2 bytes) */\n\tStream_Write_UINT16(s, 0);                             /* pad2OctetsA (2 bytes) */\n\tStream_Write_UINT32(s, settings->KeyboardLayout);      /* keyboardLayout (4 bytes) */\n\tStream_Write_UINT32(s, settings->KeyboardType);        /* keyboardType (4 bytes) */\n\tStream_Write_UINT32(s, settings->KeyboardSubType);     /* keyboardSubType (4 bytes) */\n\tStream_Write_UINT32(s, settings->KeyboardFunctionKey); /* keyboardFunctionKeys (4 bytes) */\n\tStream_Zero(s, 64);                                    /* imeFileName (64 bytes) */\n\trdp_capability_set_finish(s, (UINT16)header, CAPSET_TYPE_INPUT);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_input_capability_set(wStream* s)\n{\n\tUINT16 inputFlags;\n\tUINT16 pad2OctetsA;\n\tUINT32 keyboardLayout;\n\tUINT32 keyboardType;\n\tUINT32 keyboardSubType;\n\tUINT32 keyboardFunctionKey;\n\tWLog_INFO(TAG, \"InputCapabilitySet (length %\" PRIuz \")\", Stream_GetRemainingLength(s));\n\n\tif (Stream_GetRemainingLength(s) < 84)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, inputFlags);          /* inputFlags (2 bytes) */\n\tStream_Read_UINT16(s, pad2OctetsA);         /* pad2OctetsA (2 bytes) */\n\tStream_Read_UINT32(s, keyboardLayout);      /* keyboardLayout (4 bytes) */\n\tStream_Read_UINT32(s, keyboardType);        /* keyboardType (4 bytes) */\n\tStream_Read_UINT32(s, keyboardSubType);     /* keyboardSubType (4 bytes) */\n\tStream_Read_UINT32(s, keyboardFunctionKey); /* keyboardFunctionKeys (4 bytes) */\n\tStream_Seek(s, 64);                         /* imeFileName (64 bytes) */\n\tWLog_INFO(TAG, \"\\tinputFlags: 0x%04\" PRIX16 \"\", inputFlags);\n\tWLog_INFO(TAG, \"\\tpad2OctetsA: 0x%04\" PRIX16 \"\", pad2OctetsA);\n\tWLog_INFO(TAG, \"\\tkeyboardLayout: 0x%08\" PRIX32 \"\", keyboardLayout);\n\tWLog_INFO(TAG, \"\\tkeyboardType: 0x%08\" PRIX32 \"\", keyboardType);\n\tWLog_INFO(TAG, \"\\tkeyboardSubType: 0x%08\" PRIX32 \"\", keyboardSubType);\n\tWLog_INFO(TAG, \"\\tkeyboardFunctionKey: 0x%08\" PRIX32 \"\", keyboardFunctionKey);\n\treturn TRUE;\n}\n#endif\n\n/**\n * Read font capability set.\\n\n * @msdn{cc240571}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_font_capability_set(wStream* s, rdpSettings* settings)\n{\n\tWINPR_UNUSED(settings);\n\tif (Stream_GetRemainingLength(s) >= 2)\n\t\tStream_Seek_UINT16(s); /* fontSupportFlags (2 bytes) */\n\n\tif (Stream_GetRemainingLength(s) >= 2)\n\t\tStream_Seek_UINT16(s); /* pad2Octets (2 bytes) */\n\n\treturn TRUE;\n}\n\n/**\n * Write font capability set.\\n\n * @msdn{cc240571}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_font_capability_set(wStream* s, const rdpSettings* settings)\n{\n\tsize_t header;\n\n\tWINPR_UNUSED(settings);\n\tif (!Stream_EnsureRemainingCapacity(s, 32))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tif (header > UINT16_MAX)\n\t\treturn FALSE;\n\tStream_Write_UINT16(s, FONTSUPPORT_FONTLIST); /* fontSupportFlags (2 bytes) */\n\tStream_Write_UINT16(s, 0);                    /* pad2Octets (2 bytes) */\n\trdp_capability_set_finish(s, (UINT16)header, CAPSET_TYPE_FONT);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_font_capability_set(wStream* s)\n{\n\tUINT16 fontSupportFlags = 0;\n\tUINT16 pad2Octets = 0;\n\tWLog_INFO(TAG, \"FontCapabilitySet (length %\" PRIuz \"):\", Stream_GetRemainingLength(s));\n\n\tif (Stream_GetRemainingLength(s) >= 2)\n\t\tStream_Read_UINT16(s, fontSupportFlags); /* fontSupportFlags (2 bytes) */\n\n\tif (Stream_GetRemainingLength(s) >= 2)\n\t\tStream_Read_UINT16(s, pad2Octets); /* pad2Octets (2 bytes) */\n\n\tWLog_INFO(TAG, \"\\tfontSupportFlags: 0x%04\" PRIX16 \"\", fontSupportFlags);\n\tWLog_INFO(TAG, \"\\tpad2Octets: 0x%04\" PRIX16 \"\", pad2Octets);\n\treturn TRUE;\n}\n#endif\n\n/**\n * Read brush capability set.\n * @msdn{cc240564}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_brush_capability_set(wStream* s, rdpSettings* settings)\n{\n\tWINPR_UNUSED(settings);\n\treturn Stream_SafeSeek(s, 4); /* brushSupportLevel (4 bytes) */\n}\n\n/**\n * Write brush capability set.\\n\n * @msdn{cc240564}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_brush_capability_set(wStream* s, const rdpSettings* settings)\n{\n\tsize_t header;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 32))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tif (header > UINT16_MAX)\n\t\treturn FALSE;\n\tStream_Write_UINT32(s, settings->BrushSupportLevel); /* brushSupportLevel (4 bytes) */\n\trdp_capability_set_finish(s, (UINT16)header, CAPSET_TYPE_BRUSH);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_brush_capability_set(wStream* s)\n{\n\tUINT32 brushSupportLevel;\n\tWLog_INFO(TAG, \"BrushCapabilitySet (length %\" PRIuz \"):\", Stream_GetRemainingLength(s));\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, brushSupportLevel); /* brushSupportLevel (4 bytes) */\n\tWLog_INFO(TAG, \"\\tbrushSupportLevel: 0x%08\" PRIX32 \"\", brushSupportLevel);\n\treturn TRUE;\n}\n#endif\n\n/**\n * Read cache definition (glyph).\\n\n * @msdn{cc240566}\n * @param s stream\n */\nstatic void rdp_read_cache_definition(wStream* s, GLYPH_CACHE_DEFINITION* cache_definition)\n{\n\tStream_Read_UINT16(s, cache_definition->cacheEntries); /* cacheEntries (2 bytes) */\n\tStream_Read_UINT16(s,\n\t                   cache_definition->cacheMaximumCellSize); /* cacheMaximumCellSize (2 bytes) */\n}\n\n/**\n * Write cache definition (glyph).\\n\n * @msdn{cc240566}\n * @param s stream\n */\nstatic void rdp_write_cache_definition(wStream* s, GLYPH_CACHE_DEFINITION* cache_definition)\n{\n\tStream_Write_UINT16(s, cache_definition->cacheEntries); /* cacheEntries (2 bytes) */\n\tStream_Write_UINT16(\n\t    s, cache_definition->cacheMaximumCellSize); /* cacheMaximumCellSize (2 bytes) */\n}\n\n/**\n * Read glyph cache capability set.\\n\n * @msdn{cc240565}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_glyph_cache_capability_set(wStream* s, rdpSettings* settings)\n{\n\tif (Stream_GetRemainingLength(s) < 48)\n\t\treturn FALSE;\n\n\t/* glyphCache (40 bytes) */\n\trdp_read_cache_definition(s, &(settings->GlyphCache[0])); /* glyphCache0 (4 bytes) */\n\trdp_read_cache_definition(s, &(settings->GlyphCache[1])); /* glyphCache1 (4 bytes) */\n\trdp_read_cache_definition(s, &(settings->GlyphCache[2])); /* glyphCache2 (4 bytes) */\n\trdp_read_cache_definition(s, &(settings->GlyphCache[3])); /* glyphCache3 (4 bytes) */\n\trdp_read_cache_definition(s, &(settings->GlyphCache[4])); /* glyphCache4 (4 bytes) */\n\trdp_read_cache_definition(s, &(settings->GlyphCache[5])); /* glyphCache5 (4 bytes) */\n\trdp_read_cache_definition(s, &(settings->GlyphCache[6])); /* glyphCache6 (4 bytes) */\n\trdp_read_cache_definition(s, &(settings->GlyphCache[7])); /* glyphCache7 (4 bytes) */\n\trdp_read_cache_definition(s, &(settings->GlyphCache[8])); /* glyphCache8 (4 bytes) */\n\trdp_read_cache_definition(s, &(settings->GlyphCache[9])); /* glyphCache9 (4 bytes) */\n\trdp_read_cache_definition(s, settings->FragCache);        /* fragCache (4 bytes) */\n\tStream_Read_UINT16(s, settings->GlyphSupportLevel);       /* glyphSupportLevel (2 bytes) */\n\tStream_Seek_UINT16(s);                                    /* pad2Octets (2 bytes) */\n\treturn TRUE;\n}\n\n/**\n * Write glyph cache capability set.\\n\n * @msdn{cc240565}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_glyph_cache_capability_set(wStream* s, const rdpSettings* settings)\n{\n\tsize_t header;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 64))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tif (header > UINT16_MAX)\n\t\treturn FALSE;\n\tif (settings->GlyphSupportLevel > UINT16_MAX)\n\t\treturn FALSE;\n\t/* glyphCache (40 bytes) */\n\trdp_write_cache_definition(s, &(settings->GlyphCache[0])); /* glyphCache0 (4 bytes) */\n\trdp_write_cache_definition(s, &(settings->GlyphCache[1])); /* glyphCache1 (4 bytes) */\n\trdp_write_cache_definition(s, &(settings->GlyphCache[2])); /* glyphCache2 (4 bytes) */\n\trdp_write_cache_definition(s, &(settings->GlyphCache[3])); /* glyphCache3 (4 bytes) */\n\trdp_write_cache_definition(s, &(settings->GlyphCache[4])); /* glyphCache4 (4 bytes) */\n\trdp_write_cache_definition(s, &(settings->GlyphCache[5])); /* glyphCache5 (4 bytes) */\n\trdp_write_cache_definition(s, &(settings->GlyphCache[6])); /* glyphCache6 (4 bytes) */\n\trdp_write_cache_definition(s, &(settings->GlyphCache[7])); /* glyphCache7 (4 bytes) */\n\trdp_write_cache_definition(s, &(settings->GlyphCache[8])); /* glyphCache8 (4 bytes) */\n\trdp_write_cache_definition(s, &(settings->GlyphCache[9])); /* glyphCache9 (4 bytes) */\n\trdp_write_cache_definition(s, settings->FragCache);        /* fragCache (4 bytes) */\n\tStream_Write_UINT16(s, (UINT16)settings->GlyphSupportLevel); /* glyphSupportLevel (2 bytes) */\n\tStream_Write_UINT16(s, 0);                                 /* pad2Octets (2 bytes) */\n\trdp_capability_set_finish(s, (UINT16)header, CAPSET_TYPE_GLYPH_CACHE);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_glyph_cache_capability_set(wStream* s)\n{\n\tGLYPH_CACHE_DEFINITION glyphCache[10];\n\tGLYPH_CACHE_DEFINITION fragCache;\n\tUINT16 glyphSupportLevel;\n\tUINT16 pad2Octets;\n\tWLog_INFO(TAG, \"GlyphCacheCapabilitySet (length %\" PRIuz \"):\", Stream_GetRemainingLength(s));\n\n\tif (Stream_GetRemainingLength(s) < 48)\n\t\treturn FALSE;\n\n\t/* glyphCache (40 bytes) */\n\trdp_read_cache_definition(s, &glyphCache[0]); /* glyphCache0 (4 bytes) */\n\trdp_read_cache_definition(s, &glyphCache[1]); /* glyphCache1 (4 bytes) */\n\trdp_read_cache_definition(s, &glyphCache[2]); /* glyphCache2 (4 bytes) */\n\trdp_read_cache_definition(s, &glyphCache[3]); /* glyphCache3 (4 bytes) */\n\trdp_read_cache_definition(s, &glyphCache[4]); /* glyphCache4 (4 bytes) */\n\trdp_read_cache_definition(s, &glyphCache[5]); /* glyphCache5 (4 bytes) */\n\trdp_read_cache_definition(s, &glyphCache[6]); /* glyphCache6 (4 bytes) */\n\trdp_read_cache_definition(s, &glyphCache[7]); /* glyphCache7 (4 bytes) */\n\trdp_read_cache_definition(s, &glyphCache[8]); /* glyphCache8 (4 bytes) */\n\trdp_read_cache_definition(s, &glyphCache[9]); /* glyphCache9 (4 bytes) */\n\trdp_read_cache_definition(s, &fragCache);     /* fragCache (4 bytes) */\n\tStream_Read_UINT16(s, glyphSupportLevel);     /* glyphSupportLevel (2 bytes) */\n\tStream_Read_UINT16(s, pad2Octets);            /* pad2Octets (2 bytes) */\n\tWLog_INFO(TAG, \"\\tglyphCache0: Entries: %\" PRIu16 \" MaximumCellSize: %\" PRIu16 \"\",\n\t          glyphCache[0].cacheEntries, glyphCache[0].cacheMaximumCellSize);\n\tWLog_INFO(TAG, \"\\tglyphCache1: Entries: %\" PRIu16 \" MaximumCellSize: %\" PRIu16 \"\",\n\t          glyphCache[1].cacheEntries, glyphCache[1].cacheMaximumCellSize);\n\tWLog_INFO(TAG, \"\\tglyphCache2: Entries: %\" PRIu16 \" MaximumCellSize: %\" PRIu16 \"\",\n\t          glyphCache[2].cacheEntries, glyphCache[2].cacheMaximumCellSize);\n\tWLog_INFO(TAG, \"\\tglyphCache3: Entries: %\" PRIu16 \" MaximumCellSize: %\" PRIu16 \"\",\n\t          glyphCache[3].cacheEntries, glyphCache[3].cacheMaximumCellSize);\n\tWLog_INFO(TAG, \"\\tglyphCache4: Entries: %\" PRIu16 \" MaximumCellSize: %\" PRIu16 \"\",\n\t          glyphCache[4].cacheEntries, glyphCache[4].cacheMaximumCellSize);\n\tWLog_INFO(TAG, \"\\tglyphCache5: Entries: %\" PRIu16 \" MaximumCellSize: %\" PRIu16 \"\",\n\t          glyphCache[5].cacheEntries, glyphCache[5].cacheMaximumCellSize);\n\tWLog_INFO(TAG, \"\\tglyphCache6: Entries: %\" PRIu16 \" MaximumCellSize: %\" PRIu16 \"\",\n\t          glyphCache[6].cacheEntries, glyphCache[6].cacheMaximumCellSize);\n\tWLog_INFO(TAG, \"\\tglyphCache7: Entries: %\" PRIu16 \" MaximumCellSize: %\" PRIu16 \"\",\n\t          glyphCache[7].cacheEntries, glyphCache[7].cacheMaximumCellSize);\n\tWLog_INFO(TAG, \"\\tglyphCache8: Entries: %\" PRIu16 \" MaximumCellSize: %\" PRIu16 \"\",\n\t          glyphCache[8].cacheEntries, glyphCache[8].cacheMaximumCellSize);\n\tWLog_INFO(TAG, \"\\tglyphCache9: Entries: %\" PRIu16 \" MaximumCellSize: %\" PRIu16 \"\",\n\t          glyphCache[9].cacheEntries, glyphCache[9].cacheMaximumCellSize);\n\tWLog_INFO(TAG, \"\\tfragCache: Entries: %\" PRIu16 \" MaximumCellSize: %\" PRIu16 \"\",\n\t          fragCache.cacheEntries, fragCache.cacheMaximumCellSize);\n\tWLog_INFO(TAG, \"\\tglyphSupportLevel: 0x%04\" PRIX16 \"\", glyphSupportLevel);\n\tWLog_INFO(TAG, \"\\tpad2Octets: 0x%04\" PRIX16 \"\", pad2Octets);\n\treturn TRUE;\n}\n#endif\n\n/**\n * Read offscreen bitmap cache capability set.\\n\n * @msdn{cc240550}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_offscreen_bitmap_cache_capability_set(wStream* s, rdpSettings* settings)\n{\n\tUINT32 offscreenSupportLevel;\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, offscreenSupportLevel);           /* offscreenSupportLevel (4 bytes) */\n\tStream_Read_UINT16(s, settings->OffscreenCacheSize);    /* offscreenCacheSize (2 bytes) */\n\tStream_Read_UINT16(s, settings->OffscreenCacheEntries); /* offscreenCacheEntries (2 bytes) */\n\n\tif (offscreenSupportLevel & TRUE)\n\t\tsettings->OffscreenSupportLevel = TRUE;\n\n\treturn TRUE;\n}\n\n/**\n * Write offscreen bitmap cache capability set.\\n\n * @msdn{cc240550}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_offscreen_bitmap_cache_capability_set(wStream* s, const rdpSettings* settings)\n{\n\tsize_t header;\n\tUINT32 offscreenSupportLevel = 0x00;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 32))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tif (header > UINT16_MAX)\n\t\treturn FALSE;\n\tif (settings->OffscreenSupportLevel)\n\t{\n\t\toffscreenSupportLevel = 0x01;\n\t\tStream_Write_UINT32(s, offscreenSupportLevel);        /* offscreenSupportLevel (4 bytes) */\n\t\tStream_Write_UINT16(s, settings->OffscreenCacheSize); /* offscreenCacheSize (2 bytes) */\n\t\tStream_Write_UINT16(s,\n\t\t                    settings->OffscreenCacheEntries); /* offscreenCacheEntries (2 bytes) */\n\t}\n\telse\n\t\tStream_Zero(s, 8);\n\n\trdp_capability_set_finish(s, (UINT16)header, CAPSET_TYPE_OFFSCREEN_CACHE);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_offscreen_bitmap_cache_capability_set(wStream* s)\n{\n\tUINT32 offscreenSupportLevel;\n\tUINT16 offscreenCacheSize;\n\tUINT16 offscreenCacheEntries;\n\tWLog_INFO(TAG, \"OffscreenBitmapCacheCapabilitySet (length %\" PRIuz \"):\",\n\t          Stream_GetRemainingLength(s));\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, offscreenSupportLevel); /* offscreenSupportLevel (4 bytes) */\n\tStream_Read_UINT16(s, offscreenCacheSize);    /* offscreenCacheSize (2 bytes) */\n\tStream_Read_UINT16(s, offscreenCacheEntries); /* offscreenCacheEntries (2 bytes) */\n\tWLog_INFO(TAG, \"\\toffscreenSupportLevel: 0x%08\" PRIX32 \"\", offscreenSupportLevel);\n\tWLog_INFO(TAG, \"\\toffscreenCacheSize: 0x%04\" PRIX16 \"\", offscreenCacheSize);\n\tWLog_INFO(TAG, \"\\toffscreenCacheEntries: 0x%04\" PRIX16 \"\", offscreenCacheEntries);\n\treturn TRUE;\n}\n#endif\n\n/**\n * Read bitmap cache host support capability set.\\n\n * @msdn{cc240557}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_bitmap_cache_host_support_capability_set(wStream* s, rdpSettings* settings)\n{\n\tBYTE cacheVersion;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, cacheVersion); /* cacheVersion (1 byte) */\n\tStream_Seek_UINT8(s);               /* pad1 (1 byte) */\n\tStream_Seek_UINT16(s);              /* pad2 (2 bytes) */\n\n\tif (cacheVersion & BITMAP_CACHE_V2)\n\t\tsettings->BitmapCachePersistEnabled = TRUE;\n\n\treturn TRUE;\n}\n\n/**\n * Write bitmap cache host support capability set.\\n\n * @msdn{cc240557}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_bitmap_cache_host_support_capability_set(wStream* s,\n                                                               const rdpSettings* settings)\n{\n\tsize_t header;\n\n\tWINPR_UNUSED(settings);\n\tif (!Stream_EnsureRemainingCapacity(s, 32))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tif (header > UINT16_MAX)\n\t\treturn FALSE;\n\tStream_Write_UINT8(s, BITMAP_CACHE_V2); /* cacheVersion (1 byte) */\n\tStream_Write_UINT8(s, 0);               /* pad1 (1 byte) */\n\tStream_Write_UINT16(s, 0);              /* pad2 (2 bytes) */\n\trdp_capability_set_finish(s, (UINT16)header, CAPSET_TYPE_BITMAP_CACHE_HOST_SUPPORT);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_bitmap_cache_host_support_capability_set(wStream* s)\n{\n\tBYTE cacheVersion;\n\tBYTE pad1;\n\tUINT16 pad2;\n\tWLog_INFO(TAG, \"BitmapCacheHostSupportCapabilitySet (length %\" PRIuz \"):\",\n\t          Stream_GetRemainingLength(s));\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, cacheVersion); /* cacheVersion (1 byte) */\n\tStream_Read_UINT8(s, pad1);         /* pad1 (1 byte) */\n\tStream_Read_UINT16(s, pad2);        /* pad2 (2 bytes) */\n\tWLog_INFO(TAG, \"\\tcacheVersion: 0x%02\" PRIX8 \"\", cacheVersion);\n\tWLog_INFO(TAG, \"\\tpad1: 0x%02\" PRIX8 \"\", pad1);\n\tWLog_INFO(TAG, \"\\tpad2: 0x%04\" PRIX16 \"\", pad2);\n\treturn TRUE;\n}\n\nstatic void rdp_read_bitmap_cache_cell_info(wStream* s, BITMAP_CACHE_V2_CELL_INFO* cellInfo)\n{\n\tUINT32 info;\n\t/**\n\t * numEntries is in the first 31 bits, while the last bit (k)\n\t * is used to indicate a persistent bitmap cache.\n\t */\n\tStream_Read_UINT32(s, info);\n\tcellInfo->numEntries = (info & 0x7FFFFFFF);\n\tcellInfo->persistent = (info & 0x80000000) ? 1 : 0;\n}\n#endif\n\nstatic void rdp_write_bitmap_cache_cell_info(wStream* s, BITMAP_CACHE_V2_CELL_INFO* cellInfo)\n{\n\tUINT32 info;\n\t/**\n\t * numEntries is in the first 31 bits, while the last bit (k)\n\t * is used to indicate a persistent bitmap cache.\n\t */\n\tinfo = (cellInfo->numEntries | (cellInfo->persistent << 31));\n\tStream_Write_UINT32(s, info);\n}\n\n/**\n * Read bitmap cache v2 capability set.\\n\n * @msdn{cc240560}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_bitmap_cache_v2_capability_set(wStream* s, rdpSettings* settings)\n{\n\tWINPR_UNUSED(settings);\n\tif (Stream_GetRemainingLength(s) < 36)\n\t\treturn FALSE;\n\n\tStream_Seek_UINT16(s); /* cacheFlags (2 bytes) */\n\tStream_Seek_UINT8(s);  /* pad2 (1 byte) */\n\tStream_Seek_UINT8(s);  /* numCellCaches (1 byte) */\n\tStream_Seek(s, 4);     /* bitmapCache0CellInfo (4 bytes) */\n\tStream_Seek(s, 4);     /* bitmapCache1CellInfo (4 bytes) */\n\tStream_Seek(s, 4);     /* bitmapCache2CellInfo (4 bytes) */\n\tStream_Seek(s, 4);     /* bitmapCache3CellInfo (4 bytes) */\n\tStream_Seek(s, 4);     /* bitmapCache4CellInfo (4 bytes) */\n\tStream_Seek(s, 12);    /* pad3 (12 bytes) */\n\treturn TRUE;\n}\n\n/**\n * Write bitmap cache v2 capability set.\\n\n * @msdn{cc240560}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_bitmap_cache_v2_capability_set(wStream* s, const rdpSettings* settings)\n{\n\tsize_t header;\n\tUINT16 cacheFlags;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 64))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tcacheFlags = ALLOW_CACHE_WAITING_LIST_FLAG;\n\n\tif (settings->BitmapCachePersistEnabled)\n\t\tcacheFlags |= PERSISTENT_KEYS_EXPECTED_FLAG;\n\n\tStream_Write_UINT16(s, cacheFlags);                     /* cacheFlags (2 bytes) */\n\tStream_Write_UINT8(s, 0);                               /* pad2 (1 byte) */\n\tStream_Write_UINT8(s, settings->BitmapCacheV2NumCells); /* numCellCaches (1 byte) */\n\trdp_write_bitmap_cache_cell_info(\n\t    s, &settings->BitmapCacheV2CellInfo[0]); /* bitmapCache0CellInfo (4 bytes) */\n\trdp_write_bitmap_cache_cell_info(\n\t    s, &settings->BitmapCacheV2CellInfo[1]); /* bitmapCache1CellInfo (4 bytes) */\n\trdp_write_bitmap_cache_cell_info(\n\t    s, &settings->BitmapCacheV2CellInfo[2]); /* bitmapCache2CellInfo (4 bytes) */\n\trdp_write_bitmap_cache_cell_info(\n\t    s, &settings->BitmapCacheV2CellInfo[3]); /* bitmapCache3CellInfo (4 bytes) */\n\trdp_write_bitmap_cache_cell_info(\n\t    s, &settings->BitmapCacheV2CellInfo[4]); /* bitmapCache4CellInfo (4 bytes) */\n\tStream_Zero(s, 12);                          /* pad3 (12 bytes) */\n\trdp_capability_set_finish(s, header, CAPSET_TYPE_BITMAP_CACHE_V2);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_bitmap_cache_v2_capability_set(wStream* s)\n{\n\tUINT16 cacheFlags;\n\tBYTE pad2;\n\tBYTE numCellCaches;\n\tBITMAP_CACHE_V2_CELL_INFO bitmapCacheV2CellInfo[5];\n\tWLog_INFO(TAG, \"BitmapCacheV2CapabilitySet (length %\" PRIuz \"):\", Stream_GetRemainingLength(s));\n\n\tif (Stream_GetRemainingLength(s) < 36)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, cacheFlags);   /* cacheFlags (2 bytes) */\n\tStream_Read_UINT8(s, pad2);          /* pad2 (1 byte) */\n\tStream_Read_UINT8(s, numCellCaches); /* numCellCaches (1 byte) */\n\trdp_read_bitmap_cache_cell_info(s,\n\t                                &bitmapCacheV2CellInfo[0]); /* bitmapCache0CellInfo (4 bytes) */\n\trdp_read_bitmap_cache_cell_info(s,\n\t                                &bitmapCacheV2CellInfo[1]); /* bitmapCache1CellInfo (4 bytes) */\n\trdp_read_bitmap_cache_cell_info(s,\n\t                                &bitmapCacheV2CellInfo[2]); /* bitmapCache2CellInfo (4 bytes) */\n\trdp_read_bitmap_cache_cell_info(s,\n\t                                &bitmapCacheV2CellInfo[3]); /* bitmapCache3CellInfo (4 bytes) */\n\trdp_read_bitmap_cache_cell_info(s,\n\t                                &bitmapCacheV2CellInfo[4]); /* bitmapCache4CellInfo (4 bytes) */\n\tStream_Seek(s, 12);                                         /* pad3 (12 bytes) */\n\tWLog_INFO(TAG, \"\\tcacheFlags: 0x%04\" PRIX16 \"\", cacheFlags);\n\tWLog_INFO(TAG, \"\\tpad2: 0x%02\" PRIX8 \"\", pad2);\n\tWLog_INFO(TAG, \"\\tnumCellCaches: 0x%02\" PRIX8 \"\", numCellCaches);\n\tWLog_INFO(TAG, \"\\tbitmapCache0CellInfo: numEntries: %\" PRIu32 \" persistent: %\" PRId32 \"\",\n\t          bitmapCacheV2CellInfo[0].numEntries, bitmapCacheV2CellInfo[0].persistent);\n\tWLog_INFO(TAG, \"\\tbitmapCache1CellInfo: numEntries: %\" PRIu32 \" persistent: %\" PRId32 \"\",\n\t          bitmapCacheV2CellInfo[1].numEntries, bitmapCacheV2CellInfo[1].persistent);\n\tWLog_INFO(TAG, \"\\tbitmapCache2CellInfo: numEntries: %\" PRIu32 \" persistent: %\" PRId32 \"\",\n\t          bitmapCacheV2CellInfo[2].numEntries, bitmapCacheV2CellInfo[2].persistent);\n\tWLog_INFO(TAG, \"\\tbitmapCache3CellInfo: numEntries: %\" PRIu32 \" persistent: %\" PRId32 \"\",\n\t          bitmapCacheV2CellInfo[3].numEntries, bitmapCacheV2CellInfo[3].persistent);\n\tWLog_INFO(TAG, \"\\tbitmapCache4CellInfo: numEntries: %\" PRIu32 \" persistent: %\" PRId32 \"\",\n\t          bitmapCacheV2CellInfo[4].numEntries, bitmapCacheV2CellInfo[4].persistent);\n\treturn TRUE;\n}\n#endif\n\n/**\n * Read virtual channel capability set.\\n\n * @msdn{cc240551}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_virtual_channel_capability_set(wStream* s, rdpSettings* settings)\n{\n\tUINT32 flags;\n\tUINT32 VCChunkSize;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, flags); /* flags (4 bytes) */\n\n\tif (Stream_GetRemainingLength(s) >= 4)\n\t\tStream_Read_UINT32(s, VCChunkSize); /* VCChunkSize (4 bytes) */\n\telse\n\t\tVCChunkSize = 1600;\n\n\tif (settings->ServerMode != TRUE)\n\t\tsettings->VirtualChannelChunkSize = VCChunkSize;\n\n\treturn TRUE;\n}\n\n/**\n * Write virtual channel capability set.\\n\n * @msdn{cc240551}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_virtual_channel_capability_set(wStream* s, const rdpSettings* settings)\n{\n\tsize_t header;\n\tUINT32 flags;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 32))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tflags = VCCAPS_NO_COMPR;\n\tStream_Write_UINT32(s, flags);                             /* flags (4 bytes) */\n\tStream_Write_UINT32(s, settings->VirtualChannelChunkSize); /* VCChunkSize (4 bytes) */\n\trdp_capability_set_finish(s, header, CAPSET_TYPE_VIRTUAL_CHANNEL);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_virtual_channel_capability_set(wStream* s)\n{\n\tUINT32 flags;\n\tUINT32 VCChunkSize;\n\tWLog_INFO(TAG,\n\t          \"VirtualChannelCapabilitySet (length %\" PRIuz \"):\", Stream_GetRemainingLength(s));\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, flags); /* flags (4 bytes) */\n\n\tif (Stream_GetRemainingLength(s) >= 4)\n\t\tStream_Read_UINT32(s, VCChunkSize); /* VCChunkSize (4 bytes) */\n\telse\n\t\tVCChunkSize = 1600;\n\n\tWLog_INFO(TAG, \"\\tflags: 0x%08\" PRIX32 \"\", flags);\n\tWLog_INFO(TAG, \"\\tVCChunkSize: 0x%08\" PRIX32 \"\", VCChunkSize);\n\treturn TRUE;\n}\n#endif\n\n/**\n * Read drawn nine grid cache capability set.\\n\n * @msdn{cc241565}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_draw_nine_grid_cache_capability_set(wStream* s, rdpSettings* settings)\n{\n\tUINT32 drawNineGridSupportLevel;\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, drawNineGridSupportLevel);        /* drawNineGridSupportLevel (4 bytes) */\n\tStream_Read_UINT16(s, settings->DrawNineGridCacheSize); /* drawNineGridCacheSize (2 bytes) */\n\tStream_Read_UINT16(s,\n\t                   settings->DrawNineGridCacheEntries); /* drawNineGridCacheEntries (2 bytes) */\n\n\tif ((drawNineGridSupportLevel & DRAW_NINEGRID_SUPPORTED) ||\n\t    (drawNineGridSupportLevel & DRAW_NINEGRID_SUPPORTED_V2))\n\t\tsettings->DrawNineGridEnabled = TRUE;\n\n\treturn TRUE;\n}\n\n/**\n * Write drawn nine grid cache capability set.\\n\n * @msdn{cc241565}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_draw_nine_grid_cache_capability_set(wStream* s, const rdpSettings* settings)\n{\n\tsize_t header;\n\tUINT32 drawNineGridSupportLevel;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 32))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tdrawNineGridSupportLevel =\n\t    (settings->DrawNineGridEnabled) ? DRAW_NINEGRID_SUPPORTED_V2 : DRAW_NINEGRID_NO_SUPPORT;\n\tStream_Write_UINT32(s, drawNineGridSupportLevel); /* drawNineGridSupportLevel (4 bytes) */\n\tStream_Write_UINT16(s, settings->DrawNineGridCacheSize); /* drawNineGridCacheSize (2 bytes) */\n\tStream_Write_UINT16(\n\t    s, settings->DrawNineGridCacheEntries); /* drawNineGridCacheEntries (2 bytes) */\n\trdp_capability_set_finish(s, header, CAPSET_TYPE_DRAW_NINE_GRID_CACHE);\n\treturn TRUE;\n}\n\nstatic void rdp_write_gdiplus_cache_entries(wStream* s, UINT16 gce, UINT16 bce, UINT16 pce,\n                                            UINT16 ice, UINT16 ace)\n{\n\tStream_Write_UINT16(s, gce); /* gdipGraphicsCacheEntries (2 bytes) */\n\tStream_Write_UINT16(s, bce); /* gdipBrushCacheEntries (2 bytes) */\n\tStream_Write_UINT16(s, pce); /* gdipPenCacheEntries (2 bytes) */\n\tStream_Write_UINT16(s, ice); /* gdipImageCacheEntries (2 bytes) */\n\tStream_Write_UINT16(s, ace); /* gdipImageAttributesCacheEntries (2 bytes) */\n}\n\nstatic void rdp_write_gdiplus_cache_chunk_size(wStream* s, UINT16 gccs, UINT16 obccs, UINT16 opccs,\n                                               UINT16 oiaccs)\n{\n\tStream_Write_UINT16(s, gccs);   /* gdipGraphicsCacheChunkSize (2 bytes) */\n\tStream_Write_UINT16(s, obccs);  /* gdipObjectBrushCacheChunkSize (2 bytes) */\n\tStream_Write_UINT16(s, opccs);  /* gdipObjectPenCacheChunkSize (2 bytes) */\n\tStream_Write_UINT16(s, oiaccs); /* gdipObjectImageAttributesCacheChunkSize (2 bytes) */\n}\n\nstatic void rdp_write_gdiplus_image_cache_properties(wStream* s, UINT16 oiccs, UINT16 oicts,\n                                                     UINT16 oicms)\n{\n\tStream_Write_UINT16(s, oiccs); /* gdipObjectImageCacheChunkSize (2 bytes) */\n\tStream_Write_UINT16(s, oicts); /* gdipObjectImageCacheTotalSize (2 bytes) */\n\tStream_Write_UINT16(s, oicms); /* gdipObjectImageCacheMaxSize (2 bytes) */\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_draw_nine_grid_cache_capability_set(wStream* s)\n{\n\tUINT32 drawNineGridSupportLevel;\n\tUINT16 DrawNineGridCacheSize;\n\tUINT16 DrawNineGridCacheEntries;\n\tWLog_INFO(TAG,\n\t          \"DrawNineGridCacheCapabilitySet (length %\" PRIuz \"):\", Stream_GetRemainingLength(s));\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, drawNineGridSupportLevel); /* drawNineGridSupportLevel (4 bytes) */\n\tStream_Read_UINT16(s, DrawNineGridCacheSize);    /* drawNineGridCacheSize (2 bytes) */\n\tStream_Read_UINT16(s, DrawNineGridCacheEntries); /* drawNineGridCacheEntries (2 bytes) */\n\treturn TRUE;\n}\n#endif\n\n/**\n * Read GDI+ cache capability set.\\n\n * @msdn{cc241566}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_draw_gdiplus_cache_capability_set(wStream* s, rdpSettings* settings)\n{\n\tUINT32 drawGDIPlusSupportLevel;\n\tUINT32 drawGdiplusCacheLevel;\n\n\tif (Stream_GetRemainingLength(s) < 36)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, drawGDIPlusSupportLevel); /* drawGDIPlusSupportLevel (4 bytes) */\n\tStream_Seek_UINT32(s);                          /* GdipVersion (4 bytes) */\n\tStream_Read_UINT32(s, drawGdiplusCacheLevel);   /* drawGdiplusCacheLevel (4 bytes) */\n\tStream_Seek(s, 10);                             /* GdipCacheEntries (10 bytes) */\n\tStream_Seek(s, 8);                              /* GdipCacheChunkSize (8 bytes) */\n\tStream_Seek(s, 6);                              /* GdipImageCacheProperties (6 bytes) */\n\n\tif (drawGDIPlusSupportLevel & DRAW_GDIPLUS_SUPPORTED)\n\t\tsettings->DrawGdiPlusEnabled = TRUE;\n\n\tif (drawGdiplusCacheLevel & DRAW_GDIPLUS_CACHE_LEVEL_ONE)\n\t\tsettings->DrawGdiPlusCacheEnabled = TRUE;\n\n\treturn TRUE;\n}\n\n/**\n * Write GDI+ cache capability set.\\n\n * @msdn{cc241566}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_draw_gdiplus_cache_capability_set(wStream* s, const rdpSettings* settings)\n{\n\tsize_t header;\n\tUINT32 drawGDIPlusSupportLevel;\n\tUINT32 drawGdiplusCacheLevel;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 64))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tdrawGDIPlusSupportLevel =\n\t    (settings->DrawGdiPlusEnabled) ? DRAW_GDIPLUS_SUPPORTED : DRAW_GDIPLUS_DEFAULT;\n\tdrawGdiplusCacheLevel = (settings->DrawGdiPlusEnabled) ? DRAW_GDIPLUS_CACHE_LEVEL_ONE\n\t                                                       : DRAW_GDIPLUS_CACHE_LEVEL_DEFAULT;\n\tStream_Write_UINT32(s, drawGDIPlusSupportLevel);     /* drawGDIPlusSupportLevel (4 bytes) */\n\tStream_Write_UINT32(s, 0);                           /* GdipVersion (4 bytes) */\n\tStream_Write_UINT32(s, drawGdiplusCacheLevel);       /* drawGdiplusCacheLevel (4 bytes) */\n\trdp_write_gdiplus_cache_entries(s, 10, 5, 5, 10, 2); /* GdipCacheEntries (10 bytes) */\n\trdp_write_gdiplus_cache_chunk_size(s, 512, 2048, 1024, 64); /* GdipCacheChunkSize (8 bytes) */\n\trdp_write_gdiplus_image_cache_properties(s, 4096, 256,\n\t                                         128); /* GdipImageCacheProperties (6 bytes) */\n\trdp_capability_set_finish(s, header, CAPSET_TYPE_DRAW_GDI_PLUS);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_draw_gdiplus_cache_capability_set(wStream* s)\n{\n\tUINT32 drawGdiPlusSupportLevel;\n\tUINT32 GdipVersion;\n\tUINT32 drawGdiplusCacheLevel;\n\tWLog_INFO(TAG,\n\t          \"DrawGdiPlusCacheCapabilitySet (length %\" PRIuz \"):\", Stream_GetRemainingLength(s));\n\n\tif (Stream_GetRemainingLength(s) < 36)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, drawGdiPlusSupportLevel); /* drawGdiPlusSupportLevel (4 bytes) */\n\tStream_Read_UINT32(s, GdipVersion);             /* GdipVersion (4 bytes) */\n\tStream_Read_UINT32(s, drawGdiplusCacheLevel);   /* drawGdiPlusCacheLevel (4 bytes) */\n\tStream_Seek(s, 10);                             /* GdipCacheEntries (10 bytes) */\n\tStream_Seek(s, 8);                              /* GdipCacheChunkSize (8 bytes) */\n\tStream_Seek(s, 6);                              /* GdipImageCacheProperties (6 bytes) */\n\treturn TRUE;\n}\n#endif\n\n/**\n * Read remote programs capability set.\\n\n * @msdn{cc242518}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_remote_programs_capability_set(wStream* s, rdpSettings* settings)\n{\n\tUINT32 railSupportLevel;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, railSupportLevel); /* railSupportLevel (4 bytes) */\n\n\tif ((railSupportLevel & RAIL_LEVEL_SUPPORTED) == 0)\n\t{\n\t\tif (settings->RemoteApplicationMode == TRUE)\n\t\t{\n\t\t\t/* RemoteApp Failure! */\n\t\t\tsettings->RemoteApplicationMode = FALSE;\n\t\t}\n\t}\n\n\t/* 2.2.2.2.3 HandshakeEx PDU (TS_RAIL_ORDER_HANDSHAKE_EX)\n\t * the handshake ex pdu is supported when both, client and server announce\n\t * it OR if we are ready to begin enhanced remoteAPP mode. */\n\tif (settings->RemoteApplicationMode)\n\t\trailSupportLevel |= RAIL_LEVEL_HANDSHAKE_EX_SUPPORTED;\n\n\tsettings->RemoteApplicationSupportLevel =\n\t    railSupportLevel & settings->RemoteApplicationSupportMask;\n\treturn TRUE;\n}\n\n/**\n * Write remote programs capability set.\\n\n * @msdn{cc242518}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_remote_programs_capability_set(wStream* s, const rdpSettings* settings)\n{\n\tsize_t header;\n\tUINT32 railSupportLevel;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 64))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\trailSupportLevel = RAIL_LEVEL_SUPPORTED;\n\n\tif (settings->RemoteApplicationSupportLevel & RAIL_LEVEL_DOCKED_LANGBAR_SUPPORTED)\n\t{\n\t\tif (settings->RemoteAppLanguageBarSupported)\n\t\t\trailSupportLevel |= RAIL_LEVEL_DOCKED_LANGBAR_SUPPORTED;\n\t}\n\n\trailSupportLevel |= RAIL_LEVEL_SHELL_INTEGRATION_SUPPORTED;\n\trailSupportLevel |= RAIL_LEVEL_LANGUAGE_IME_SYNC_SUPPORTED;\n\trailSupportLevel |= RAIL_LEVEL_SERVER_TO_CLIENT_IME_SYNC_SUPPORTED;\n\trailSupportLevel |= RAIL_LEVEL_HIDE_MINIMIZED_APPS_SUPPORTED;\n\trailSupportLevel |= RAIL_LEVEL_WINDOW_CLOAKING_SUPPORTED;\n\trailSupportLevel |= RAIL_LEVEL_HANDSHAKE_EX_SUPPORTED;\n\t/* Mask out everything the server does not support. */\n\trailSupportLevel &= settings->RemoteApplicationSupportLevel;\n\tStream_Write_UINT32(s, railSupportLevel); /* railSupportLevel (4 bytes) */\n\trdp_capability_set_finish(s, header, CAPSET_TYPE_RAIL);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_remote_programs_capability_set(wStream* s)\n{\n\tUINT32 railSupportLevel;\n\tWLog_INFO(TAG,\n\t          \"RemoteProgramsCapabilitySet (length %\" PRIuz \"):\", Stream_GetRemainingLength(s));\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, railSupportLevel); /* railSupportLevel (4 bytes) */\n\tWLog_INFO(TAG, \"\\trailSupportLevel: 0x%08\" PRIX32 \"\", railSupportLevel);\n\treturn TRUE;\n}\n#endif\n\n/**\n * Read window list capability set.\\n\n * @msdn{cc242564}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_window_list_capability_set(wStream* s, rdpSettings* settings)\n{\n\tif (Stream_GetRemainingLength(s) < 7)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, settings->RemoteWndSupportLevel); /* wndSupportLevel (4 bytes) */\n\tStream_Read_UINT8(s, settings->RemoteAppNumIconCaches); /* numIconCaches (1 byte) */\n\tStream_Read_UINT16(s,\n\t                   settings->RemoteAppNumIconCacheEntries); /* numIconCacheEntries (2 bytes) */\n\treturn TRUE;\n}\n\n/**\n * Write window list capability set.\\n\n * @msdn{cc242564}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_window_list_capability_set(wStream* s, const rdpSettings* settings)\n{\n\tsize_t header;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 32))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tStream_Write_UINT32(s, settings->RemoteWndSupportLevel); /* wndSupportLevel (4 bytes) */\n\tStream_Write_UINT8(s, settings->RemoteAppNumIconCaches); /* numIconCaches (1 byte) */\n\tStream_Write_UINT16(s,\n\t                    settings->RemoteAppNumIconCacheEntries); /* numIconCacheEntries (2 bytes) */\n\trdp_capability_set_finish(s, header, CAPSET_TYPE_WINDOW);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_window_list_capability_set(wStream* s)\n{\n\tUINT32 wndSupportLevel;\n\tBYTE numIconCaches;\n\tUINT16 numIconCacheEntries;\n\tWLog_INFO(TAG, \"WindowListCapabilitySet (length %\" PRIuz \"):\", Stream_GetRemainingLength(s));\n\n\tif (Stream_GetRemainingLength(s) < 7)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, wndSupportLevel);     /* wndSupportLevel (4 bytes) */\n\tStream_Read_UINT8(s, numIconCaches);        /* numIconCaches (1 byte) */\n\tStream_Read_UINT16(s, numIconCacheEntries); /* numIconCacheEntries (2 bytes) */\n\tWLog_INFO(TAG, \"\\twndSupportLevel: 0x%08\" PRIX32 \"\", wndSupportLevel);\n\tWLog_INFO(TAG, \"\\tnumIconCaches: 0x%02\" PRIX8 \"\", numIconCaches);\n\tWLog_INFO(TAG, \"\\tnumIconCacheEntries: 0x%04\" PRIX16 \"\", numIconCacheEntries);\n\treturn TRUE;\n}\n#endif\n\n/**\n * Read desktop composition capability set.\\n\n * @msdn{cc240855}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_desktop_composition_capability_set(wStream* s, rdpSettings* settings)\n{\n\tWINPR_UNUSED(settings);\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\treturn FALSE;\n\n\tStream_Seek_UINT16(s); /* compDeskSupportLevel (2 bytes) */\n\treturn TRUE;\n}\n\n/**\n * Write desktop composition capability set.\\n\n * @msdn{cc240855}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_desktop_composition_capability_set(wStream* s, const rdpSettings* settings)\n{\n\tsize_t header;\n\tUINT16 compDeskSupportLevel;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 32))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tcompDeskSupportLevel =\n\t    (settings->AllowDesktopComposition) ? COMPDESK_SUPPORTED : COMPDESK_NOT_SUPPORTED;\n\tStream_Write_UINT16(s, compDeskSupportLevel); /* compDeskSupportLevel (2 bytes) */\n\trdp_capability_set_finish(s, header, CAPSET_TYPE_COMP_DESK);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_desktop_composition_capability_set(wStream* s)\n{\n\tUINT16 compDeskSupportLevel;\n\tWLog_INFO(TAG,\n\t          \"DesktopCompositionCapabilitySet (length %\" PRIuz \"):\", Stream_GetRemainingLength(s));\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, compDeskSupportLevel); /* compDeskSupportLevel (2 bytes) */\n\tWLog_INFO(TAG, \"\\tcompDeskSupportLevel: 0x%04\" PRIX16 \"\", compDeskSupportLevel);\n\treturn TRUE;\n}\n#endif\n\n/**\n * Read multifragment update capability set.\\n\n * @msdn{cc240649}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_multifragment_update_capability_set(wStream* s, rdpSettings* settings)\n{\n\tUINT32 multifragMaxRequestSize;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, multifragMaxRequestSize); /* MaxRequestSize (4 bytes) */\n\n\tif (settings->ServerMode)\n\t{\n\t\t/*\n\t\t * Special case: The client announces multifragment update support but sets the maximum\n\t\t * request size to something smaller than maximum size for *one* fast-path PDU. In this case\n\t\t * behave like no multifragment updates were supported and make sure no fragmentation\n\t\t * happens by setting FASTPATH_FRAGMENT_SAFE_SIZE.\n\t\t *\n\t\t * This behaviour was observed with some windows ce rdp clients.\n\t\t */\n\t\tif (multifragMaxRequestSize < FASTPATH_MAX_PACKET_SIZE)\n\t\t\tmultifragMaxRequestSize = FASTPATH_FRAGMENT_SAFE_SIZE;\n\n\t\tif (settings->RemoteFxCodec)\n\t\t{\n\t\t\t/**\n\t\t\t * If we are using RemoteFX the client MUST use a value greater\n\t\t\t * than or equal to the value we've previously sent in the server to\n\t\t\t * client multi-fragment update capability set (MS-RDPRFX 1.5)\n\t\t\t */\n\t\t\tif (multifragMaxRequestSize < settings->MultifragMaxRequestSize)\n\t\t\t{\n\t\t\t\t/**\n\t\t\t\t * If it happens to be smaller we honor the client's value but\n\t\t\t\t * have to disable RemoteFX\n\t\t\t\t */\n\t\t\t\tsettings->RemoteFxCodec = FALSE;\n\t\t\t\tsettings->MultifragMaxRequestSize = multifragMaxRequestSize;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* no need to increase server's max request size setting here */\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsettings->MultifragMaxRequestSize = multifragMaxRequestSize;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/**\n\t\t * In client mode we keep up with the server's capabilites.\n\t\t * In RemoteFX mode we MUST do this but it might also be useful to\n\t\t * receive larger related bitmap updates.\n\t\t */\n\t\tif (multifragMaxRequestSize > settings->MultifragMaxRequestSize)\n\t\t\tsettings->MultifragMaxRequestSize = multifragMaxRequestSize;\n\t}\n\n\treturn TRUE;\n}\n\n/**\n * Write multifragment update capability set.\\n\n * @msdn{cc240649}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_multifragment_update_capability_set(wStream* s, rdpSettings* settings)\n{\n\tsize_t header;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 32))\n\t\treturn FALSE;\n\n\tif (settings->ServerMode && settings->MultifragMaxRequestSize == 0)\n\t{\n\t\t/**\n\t\t * In server mode we prefer to use the highest useful request size that\n\t\t * will allow us to pack a complete screen update into a single fast\n\t\t * path PDU using any of the supported codecs.\n\t\t * However, the client is completely free to accept our proposed\n\t\t * max request size or send a different value in the client-to-server\n\t\t * multi-fragment update capability set and we have to accept that,\n\t\t * unless we are using RemoteFX where the client MUST announce a value\n\t\t * greater than or equal to the value we're sending here.\n\t\t * See [MS-RDPRFX 1.5 capability #2]\n\t\t */\n\t\tUINT32 tileNumX = (settings->DesktopWidth + 63) / 64;\n\t\tUINT32 tileNumY = (settings->DesktopHeight + 63) / 64;\n\t\tsettings->MultifragMaxRequestSize = tileNumX * tileNumY * 16384;\n\t\t/* and add room for headers, regions, frame markers, etc. */\n\t\tsettings->MultifragMaxRequestSize += 16384;\n\t}\n\n\theader = rdp_capability_set_start(s);\n\tStream_Write_UINT32(s, settings->MultifragMaxRequestSize); /* MaxRequestSize (4 bytes) */\n\trdp_capability_set_finish(s, header, CAPSET_TYPE_MULTI_FRAGMENT_UPDATE);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_multifragment_update_capability_set(wStream* s)\n{\n\tUINT32 maxRequestSize;\n\tWLog_INFO(\n\t    TAG, \"MultifragmentUpdateCapabilitySet (length %\" PRIuz \"):\", Stream_GetRemainingLength(s));\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, maxRequestSize); /* maxRequestSize (4 bytes) */\n\tWLog_INFO(TAG, \"\\tmaxRequestSize: 0x%08\" PRIX32 \"\", maxRequestSize);\n\treturn TRUE;\n}\n#endif\n\n/**\n * Read large pointer capability set.\\n\n * @msdn{cc240650}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_large_pointer_capability_set(wStream* s, rdpSettings* settings)\n{\n\tUINT16 largePointerSupportFlags;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, largePointerSupportFlags); /* largePointerSupportFlags (2 bytes) */\n\tsettings->LargePointerFlag =\n\t    largePointerSupportFlags & (LARGE_POINTER_FLAG_96x96 | LARGE_POINTER_FLAG_384x384);\n\tif ((largePointerSupportFlags & ~(LARGE_POINTER_FLAG_96x96 | LARGE_POINTER_FLAG_384x384)) != 0)\n\t{\n\t\tWLog_WARN(\n\t\t    TAG,\n\t\t    \"TS_LARGE_POINTER_CAPABILITYSET with unsupported flags %04X (all flags %04X) received\",\n\t\t    largePointerSupportFlags & ~(LARGE_POINTER_FLAG_96x96 | LARGE_POINTER_FLAG_384x384),\n\t\t    largePointerSupportFlags);\n\t}\n\treturn TRUE;\n}\n\n/**\n * Write large pointer capability set.\\n\n * @msdn{cc240650}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_large_pointer_capability_set(wStream* s, const rdpSettings* settings)\n{\n\tsize_t header;\n\tUINT16 largePointerSupportFlags;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 32))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tlargePointerSupportFlags =\n\t    settings->LargePointerFlag & (LARGE_POINTER_FLAG_96x96 | LARGE_POINTER_FLAG_384x384);\n\tStream_Write_UINT16(s, largePointerSupportFlags); /* largePointerSupportFlags (2 bytes) */\n\trdp_capability_set_finish(s, header, CAPSET_TYPE_LARGE_POINTER);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_large_pointer_capability_set(wStream* s)\n{\n\tUINT16 largePointerSupportFlags;\n\tWLog_INFO(TAG, \"LargePointerCapabilitySet (length %\" PRIuz \"):\", Stream_GetRemainingLength(s));\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, largePointerSupportFlags); /* largePointerSupportFlags (2 bytes) */\n\tWLog_INFO(TAG, \"\\tlargePointerSupportFlags: 0x%04\" PRIX16 \"\", largePointerSupportFlags);\n\treturn TRUE;\n}\n#endif\n\n/**\n * Read surface commands capability set.\\n\n * @msdn{dd871563}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_surface_commands_capability_set(wStream* s, rdpSettings* settings)\n{\n\tUINT32 cmdFlags;\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, cmdFlags); /* cmdFlags (4 bytes) */\n\tStream_Seek_UINT32(s);           /* reserved (4 bytes) */\n\tsettings->SurfaceCommandsEnabled = TRUE;\n\tsettings->SurfaceFrameMarkerEnabled = (cmdFlags & SURFCMDS_FRAME_MARKER) ? TRUE : FALSE;\n\treturn TRUE;\n}\n\n/**\n * Write surface commands capability set.\\n\n * @msdn{dd871563}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_surface_commands_capability_set(wStream* s, const rdpSettings* settings)\n{\n\tsize_t header;\n\tUINT32 cmdFlags;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 32))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tcmdFlags = SURFCMDS_SET_SURFACE_BITS | SURFCMDS_STREAM_SURFACE_BITS;\n\n\tif (settings->SurfaceFrameMarkerEnabled)\n\t\tcmdFlags |= SURFCMDS_FRAME_MARKER;\n\n\tStream_Write_UINT32(s, cmdFlags); /* cmdFlags (4 bytes) */\n\tStream_Write_UINT32(s, 0);        /* reserved (4 bytes) */\n\trdp_capability_set_finish(s, header, CAPSET_TYPE_SURFACE_COMMANDS);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_surface_commands_capability_set(wStream* s)\n{\n\tUINT32 cmdFlags;\n\tUINT32 reserved;\n\tWLog_INFO(TAG,\n\t          \"SurfaceCommandsCapabilitySet (length %\" PRIuz \"):\", Stream_GetRemainingLength(s));\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, cmdFlags); /* cmdFlags (4 bytes) */\n\tStream_Read_UINT32(s, reserved); /* reserved (4 bytes) */\n\tWLog_INFO(TAG, \"\\tcmdFlags: 0x%08\" PRIX32 \"\", cmdFlags);\n\tWLog_INFO(TAG, \"\\treserved: 0x%08\" PRIX32 \"\", reserved);\n\treturn TRUE;\n}\n\nstatic void rdp_print_bitmap_codec_guid(const GUID* guid)\n{\n\tWLog_INFO(TAG,\n\t          \"%08\" PRIX32 \"%04\" PRIX16 \"%04\" PRIX16 \"%02\" PRIX8 \"%02\" PRIX8 \"%02\" PRIX8 \"%02\" PRIX8\n\t          \"%02\" PRIX8 \"%02\" PRIX8 \"%02\" PRIX8 \"%02\" PRIX8 \"\",\n\t          guid->Data1, guid->Data2, guid->Data3, guid->Data4[0], guid->Data4[1], guid->Data4[2],\n\t          guid->Data4[3], guid->Data4[4], guid->Data4[5], guid->Data4[6], guid->Data4[7]);\n}\n\nstatic char* rdp_get_bitmap_codec_guid_name(const GUID* guid)\n{\n\tRPC_STATUS rpc_status;\n\n\tif (UuidEqual(guid, &CODEC_GUID_REMOTEFX, &rpc_status))\n\t\treturn \"CODEC_GUID_REMOTEFX\";\n\telse if (UuidEqual(guid, &CODEC_GUID_NSCODEC, &rpc_status))\n\t\treturn \"CODEC_GUID_NSCODEC\";\n\telse if (UuidEqual(guid, &CODEC_GUID_IGNORE, &rpc_status))\n\t\treturn \"CODEC_GUID_IGNORE\";\n\telse if (UuidEqual(guid, &CODEC_GUID_IMAGE_REMOTEFX, &rpc_status))\n\t\treturn \"CODEC_GUID_IMAGE_REMOTEFX\";\n\n#if defined(WITH_JPEG)\n\telse if (UuidEqual(guid, &CODEC_GUID_JPEG, &rpc_status))\n\t\treturn \"CODEC_GUID_JPEG\";\n\n#endif\n\treturn \"CODEC_GUID_UNKNOWN\";\n}\n#endif\n\nstatic BOOL rdp_read_bitmap_codec_guid(wStream* s, GUID* guid)\n{\n\tBYTE g[16];\n\tif (Stream_GetRemainingLength(s) < 16)\n\t\treturn FALSE;\n\tStream_Read(s, g, 16);\n\tguid->Data1 = (g[3] << 24) | (g[2] << 16) | (g[1] << 8) | g[0];\n\tguid->Data2 = (g[5] << 8) | g[4];\n\tguid->Data3 = (g[7] << 8) | g[6];\n\tguid->Data4[0] = g[8];\n\tguid->Data4[1] = g[9];\n\tguid->Data4[2] = g[10];\n\tguid->Data4[3] = g[11];\n\tguid->Data4[4] = g[12];\n\tguid->Data4[5] = g[13];\n\tguid->Data4[6] = g[14];\n\tguid->Data4[7] = g[15];\n\treturn TRUE;\n}\n\nstatic void rdp_write_bitmap_codec_guid(wStream* s, const GUID* guid)\n{\n\tBYTE g[16];\n\tg[0] = guid->Data1 & 0xFF;\n\tg[1] = (guid->Data1 >> 8) & 0xFF;\n\tg[2] = (guid->Data1 >> 16) & 0xFF;\n\tg[3] = (guid->Data1 >> 24) & 0xFF;\n\tg[4] = (guid->Data2) & 0xFF;\n\tg[5] = (guid->Data2 >> 8) & 0xFF;\n\tg[6] = (guid->Data3) & 0xFF;\n\tg[7] = (guid->Data3 >> 8) & 0xFF;\n\tg[8] = guid->Data4[0];\n\tg[9] = guid->Data4[1];\n\tg[10] = guid->Data4[2];\n\tg[11] = guid->Data4[3];\n\tg[12] = guid->Data4[4];\n\tg[13] = guid->Data4[5];\n\tg[14] = guid->Data4[6];\n\tg[15] = guid->Data4[7];\n\tStream_Write(s, g, 16);\n}\n\n/**\n * Read bitmap codecs capability set.\\n\n * @msdn{dd891377}\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_bitmap_codecs_capability_set(wStream* s, rdpSettings* settings)\n{\n\tBYTE codecId;\n\tGUID codecGuid;\n\tRPC_STATUS rpc_status;\n\tBYTE bitmapCodecCount;\n\tUINT16 codecPropertiesLength;\n\n\tBOOL guidNSCodec = FALSE;\n\tBOOL guidRemoteFx = FALSE;\n\tBOOL guidRemoteFxImage = FALSE;\n\n\tif (Stream_GetRemainingLength(s) < 1)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, bitmapCodecCount); /* bitmapCodecCount (1 byte) */\n\n\twhile (bitmapCodecCount > 0)\n\t{\n\t\tsize_t rest;\n\t\twStream sub;\n\t\tif (!rdp_read_bitmap_codec_guid(s, &codecGuid)) /* codecGuid (16 bytes) */\n\t\t\treturn FALSE;\n\t\tif (Stream_GetRemainingLength(s) < 3)\n\t\t\treturn FALSE;\n\t\tStream_Read_UINT8(s, codecId);                /* codecId (1 byte) */\n\t\tStream_Read_UINT16(s, codecPropertiesLength); /* codecPropertiesLength (2 bytes) */\n\n\t\tStream_StaticInit(&sub, Stream_Pointer(s), codecPropertiesLength);\n\t\tif (!Stream_SafeSeek(s, codecPropertiesLength))\n\t\t\treturn FALSE;\n\n\t\tif (settings->ServerMode)\n\t\t{\n\t\t\tif (UuidEqual(&codecGuid, &CODEC_GUID_REMOTEFX, &rpc_status))\n\t\t\t{\n\t\t\t\tUINT32 rfxCapsLength;\n\t\t\t\tUINT32 rfxPropsLength;\n\t\t\t\tUINT32 captureFlags;\n\t\t\t\tguidRemoteFx = TRUE;\n\t\t\t\tsettings->RemoteFxCodecId = codecId;\n\t\t\t\tif (Stream_GetRemainingLength(&sub) < 12)\n\t\t\t\t\treturn FALSE;\n\t\t\t\tStream_Read_UINT32(&sub, rfxPropsLength); /* length (4 bytes) */\n\t\t\t\tStream_Read_UINT32(&sub, captureFlags);   /* captureFlags (4 bytes) */\n\t\t\t\tStream_Read_UINT32(&sub, rfxCapsLength);  /* capsLength (4 bytes) */\n\t\t\t\tsettings->RemoteFxCaptureFlags = captureFlags;\n\t\t\t\tsettings->RemoteFxOnly = (captureFlags & CARDP_CAPS_CAPTURE_NON_CAC) ? TRUE : FALSE;\n\n\t\t\t\tif (rfxCapsLength)\n\t\t\t\t{\n\t\t\t\t\tUINT16 blockType;\n\t\t\t\t\tUINT32 blockLen;\n\t\t\t\t\tUINT16 numCapsets;\n\t\t\t\t\tBYTE rfxCodecId;\n\t\t\t\t\tUINT16 capsetType;\n\t\t\t\t\tUINT16 numIcaps;\n\t\t\t\t\tUINT16 icapLen;\n\t\t\t\t\t/* TS_RFX_CAPS */\n\t\t\t\t\tif (Stream_GetRemainingLength(&sub) < 21)\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\tStream_Read_UINT16(&sub, blockType);  /* blockType (2 bytes) */\n\t\t\t\t\tStream_Read_UINT32(&sub, blockLen);   /* blockLen (4 bytes) */\n\t\t\t\t\tStream_Read_UINT16(&sub, numCapsets); /* numCapsets (2 bytes) */\n\n\t\t\t\t\tif (blockType != 0xCBC0)\n\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\tif (blockLen != 8)\n\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\tif (numCapsets != 1)\n\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\t/* TS_RFX_CAPSET */\n\t\t\t\t\tStream_Read_UINT16(&sub, blockType);  /* blockType (2 bytes) */\n\t\t\t\t\tStream_Read_UINT32(&sub, blockLen);   /* blockLen (4 bytes) */\n\t\t\t\t\tStream_Read_UINT8(&sub, rfxCodecId);  /* codecId (1 byte) */\n\t\t\t\t\tStream_Read_UINT16(&sub, capsetType); /* capsetType (2 bytes) */\n\t\t\t\t\tStream_Read_UINT16(&sub, numIcaps);   /* numIcaps (2 bytes) */\n\t\t\t\t\tStream_Read_UINT16(&sub, icapLen);    /* icapLen (2 bytes) */\n\n\t\t\t\t\tif (blockType != 0xCBC1)\n\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\tif (rfxCodecId != 1)\n\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\tif (capsetType != 0xCFC0)\n\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\twhile (numIcaps--)\n\t\t\t\t\t{\n\t\t\t\t\t\tUINT16 version;\n\t\t\t\t\t\tUINT16 tileSize;\n\t\t\t\t\t\tBYTE codecFlags;\n\t\t\t\t\t\tBYTE colConvBits;\n\t\t\t\t\t\tBYTE transformBits;\n\t\t\t\t\t\tBYTE entropyBits;\n\t\t\t\t\t\t/* TS_RFX_ICAP */\n\t\t\t\t\t\tif (Stream_GetRemainingLength(&sub) < 8)\n\t\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\t\tStream_Read_UINT16(&sub, version);      /* version (2 bytes) */\n\t\t\t\t\t\tStream_Read_UINT16(&sub, tileSize);     /* tileSize (2 bytes) */\n\t\t\t\t\t\tStream_Read_UINT8(&sub, codecFlags);    /* flags (1 byte) */\n\t\t\t\t\t\tStream_Read_UINT8(&sub, colConvBits);   /* colConvBits (1 byte) */\n\t\t\t\t\t\tStream_Read_UINT8(&sub, transformBits); /* transformBits (1 byte) */\n\t\t\t\t\t\tStream_Read_UINT8(&sub, entropyBits);   /* entropyBits (1 byte) */\n\n\t\t\t\t\t\tif (version == 0x0009)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* Version 0.9 */\n\t\t\t\t\t\t\tif (tileSize != 0x0080)\n\t\t\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (version == 0x0100)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* Version 1.0 */\n\t\t\t\t\t\t\tif (tileSize != 0x0040)\n\t\t\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\t\tif (colConvBits != 1)\n\t\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\t\tif (transformBits != 1)\n\t\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (UuidEqual(&codecGuid, &CODEC_GUID_IMAGE_REMOTEFX, &rpc_status))\n\t\t\t{\n\t\t\t\t/* Microsoft RDP servers ignore CODEC_GUID_IMAGE_REMOTEFX codec properties */\n\t\t\t\tguidRemoteFxImage = TRUE;\n\t\t\t\tif (!Stream_SafeSeek(&sub, codecPropertiesLength)) /* codecProperties */\n\t\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\telse if (UuidEqual(&codecGuid, &CODEC_GUID_NSCODEC, &rpc_status))\n\t\t\t{\n\t\t\t\tBYTE colorLossLevel;\n\t\t\t\tBYTE fAllowSubsampling;\n\t\t\t\tBYTE fAllowDynamicFidelity;\n\t\t\t\tguidNSCodec = TRUE;\n\t\t\t\tsettings->NSCodecId = codecId;\n\t\t\t\tif (Stream_GetRemainingLength(&sub) < 3)\n\t\t\t\t\treturn FALSE;\n\t\t\t\tStream_Read_UINT8(&sub, fAllowDynamicFidelity); /* fAllowDynamicFidelity (1 byte) */\n\t\t\t\tStream_Read_UINT8(&sub, fAllowSubsampling);     /* fAllowSubsampling (1 byte) */\n\t\t\t\tStream_Read_UINT8(&sub, colorLossLevel);        /* colorLossLevel (1 byte) */\n\n\t\t\t\tif (colorLossLevel < 1)\n\t\t\t\t\tcolorLossLevel = 1;\n\n\t\t\t\tif (colorLossLevel > 7)\n\t\t\t\t\tcolorLossLevel = 7;\n\n\t\t\t\tsettings->NSCodecAllowDynamicColorFidelity = fAllowDynamicFidelity;\n\t\t\t\tsettings->NSCodecAllowSubsampling = fAllowSubsampling;\n\t\t\t\tsettings->NSCodecColorLossLevel = colorLossLevel;\n\t\t\t}\n\t\t\telse if (UuidEqual(&codecGuid, &CODEC_GUID_IGNORE, &rpc_status))\n\t\t\t{\n\t\t\t\tif (!Stream_SafeSeek(&sub, codecPropertiesLength)) /* codecProperties */\n\t\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!Stream_SafeSeek(&sub, codecPropertiesLength)) /* codecProperties */\n\t\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!Stream_SafeSeek(&sub, codecPropertiesLength)) /* codecProperties */\n\t\t\t\treturn FALSE;\n\t\t}\n\n\t\trest = Stream_GetRemainingLength(&sub);\n\t\tif (rest > 0)\n\t\t{\n\t\t\tWLog_ERR(TAG,\n\t\t\t         \"error while reading codec properties: actual size: %\" PRIuz\n\t\t\t         \" expected size: %\" PRIu32 \"\",\n\t\t\t         rest + codecPropertiesLength, codecPropertiesLength);\n\t\t}\n\t\tbitmapCodecCount--;\n\t}\n\n\tif (settings->ServerMode)\n\t{\n\t\t/* only enable a codec if we've announced/enabled it before */\n\t\tsettings->RemoteFxCodec = settings->RemoteFxCodec && guidRemoteFx;\n\t\tsettings->RemoteFxImageCodec = settings->RemoteFxImageCodec && guidRemoteFxImage;\n\t\tsettings->NSCodec = settings->NSCodec && guidNSCodec;\n\t\tsettings->JpegCodec = FALSE;\n\t}\n\n\treturn TRUE;\n}\n\n/**\n * Write RemoteFX Client Capability Container.\\n\n * @param s stream\n * @param settings settings\n */\nstatic BOOL rdp_write_rfx_client_capability_container(wStream* s, const rdpSettings* settings)\n{\n\tUINT32 captureFlags;\n\tBYTE codecMode;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 64))\n\t\treturn FALSE;\n\n\tcaptureFlags = settings->RemoteFxOnly ? 0 : CARDP_CAPS_CAPTURE_NON_CAC;\n\tcodecMode = settings->RemoteFxCodecMode;\n\tStream_Write_UINT16(s, 49); /* codecPropertiesLength */\n\t/* TS_RFX_CLNT_CAPS_CONTAINER */\n\tStream_Write_UINT32(s, 49);           /* length */\n\tStream_Write_UINT32(s, captureFlags); /* captureFlags */\n\tStream_Write_UINT32(s, 37);           /* capsLength */\n\t/* TS_RFX_CAPS */\n\tStream_Write_UINT16(s, CBY_CAPS); /* blockType */\n\tStream_Write_UINT32(s, 8);        /* blockLen */\n\tStream_Write_UINT16(s, 1);        /* numCapsets */\n\t/* TS_RFX_CAPSET */\n\tStream_Write_UINT16(s, CBY_CAPSET); /* blockType */\n\tStream_Write_UINT32(s, 29);         /* blockLen */\n\tStream_Write_UINT8(s, 0x01);        /* codecId (MUST be set to 0x01) */\n\tStream_Write_UINT16(s, CLY_CAPSET); /* capsetType */\n\tStream_Write_UINT16(s, 2);          /* numIcaps */\n\tStream_Write_UINT16(s, 8);          /* icapLen */\n\t/* TS_RFX_ICAP (RLGR1) */\n\tStream_Write_UINT16(s, CLW_VERSION_1_0);   /* version */\n\tStream_Write_UINT16(s, CT_TILE_64x64);     /* tileSize */\n\tStream_Write_UINT8(s, codecMode);          /* flags */\n\tStream_Write_UINT8(s, CLW_COL_CONV_ICT);   /* colConvBits */\n\tStream_Write_UINT8(s, CLW_XFORM_DWT_53_A); /* transformBits */\n\tStream_Write_UINT8(s, CLW_ENTROPY_RLGR1);  /* entropyBits */\n\t/* TS_RFX_ICAP (RLGR3) */\n\tStream_Write_UINT16(s, CLW_VERSION_1_0);   /* version */\n\tStream_Write_UINT16(s, CT_TILE_64x64);     /* tileSize */\n\tStream_Write_UINT8(s, codecMode);          /* flags */\n\tStream_Write_UINT8(s, CLW_COL_CONV_ICT);   /* colConvBits */\n\tStream_Write_UINT8(s, CLW_XFORM_DWT_53_A); /* transformBits */\n\tStream_Write_UINT8(s, CLW_ENTROPY_RLGR3);  /* entropyBits */\n\treturn TRUE;\n}\n\n/**\n * Write NSCODEC Client Capability Container.\\n\n * @param s stream\n * @param settings settings\n */\nstatic BOOL rdp_write_nsc_client_capability_container(wStream* s, const rdpSettings* settings)\n{\n\tBYTE colorLossLevel;\n\tBYTE fAllowSubsampling;\n\tBYTE fAllowDynamicFidelity;\n\tfAllowDynamicFidelity = settings->NSCodecAllowDynamicColorFidelity;\n\tfAllowSubsampling = settings->NSCodecAllowSubsampling;\n\tcolorLossLevel = settings->NSCodecColorLossLevel;\n\n\tif (colorLossLevel < 1)\n\t\tcolorLossLevel = 1;\n\n\tif (colorLossLevel > 7)\n\t\tcolorLossLevel = 7;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 8))\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, 3); /* codecPropertiesLength */\n\t/* TS_NSCODEC_CAPABILITYSET */\n\tStream_Write_UINT8(s, fAllowDynamicFidelity); /* fAllowDynamicFidelity (1 byte) */\n\tStream_Write_UINT8(s, fAllowSubsampling);     /* fAllowSubsampling (1 byte) */\n\tStream_Write_UINT8(s, colorLossLevel);        /* colorLossLevel (1 byte) */\n\treturn TRUE;\n}\n\n#if defined(WITH_JPEG)\nstatic BOOL rdp_write_jpeg_client_capability_container(wStream* s, const rdpSettings* settings)\n{\n\tif (!Stream_EnsureRemainingCapacity(s, 8))\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, 1); /* codecPropertiesLength */\n\tStream_Write_UINT8(s, settings->JpegQuality);\n\treturn TRUE;\n}\n#endif\n\n/**\n * Write RemoteFX Server Capability Container.\\n\n * @param s stream\n * @param settings settings\n */\nstatic BOOL rdp_write_rfx_server_capability_container(wStream* s, const rdpSettings* settings)\n{\n\tWINPR_UNUSED(settings);\n\tif (!Stream_EnsureRemainingCapacity(s, 8))\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, 4); /* codecPropertiesLength */\n\tStream_Write_UINT32(s, 0); /* reserved */\n\treturn TRUE;\n}\n\nstatic BOOL rdp_write_jpeg_server_capability_container(wStream* s, const rdpSettings* settings)\n{\n\tWINPR_UNUSED(settings);\n\tif (!Stream_EnsureRemainingCapacity(s, 8))\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, 1); /* codecPropertiesLength */\n\tStream_Write_UINT8(s, 75);\n\treturn TRUE;\n}\n\n/**\n * Write NSCODEC Server Capability Container.\\n\n * @param s stream\n * @param settings settings\n */\nstatic BOOL rdp_write_nsc_server_capability_container(wStream* s, const rdpSettings* settings)\n{\n\tWINPR_UNUSED(settings);\n\tif (!Stream_EnsureRemainingCapacity(s, 8))\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, 4); /* codecPropertiesLength */\n\tStream_Write_UINT32(s, 0); /* reserved */\n\treturn TRUE;\n}\n\n/**\n * Write bitmap codecs capability set.\\n\n * @msdn{dd891377}\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_bitmap_codecs_capability_set(wStream* s, const rdpSettings* settings)\n{\n\tsize_t header;\n\tBYTE bitmapCodecCount;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 64))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tbitmapCodecCount = 0;\n\n\tif (settings->RemoteFxCodec)\n\t\tbitmapCodecCount++;\n\n\tif (settings->NSCodec)\n\t\tbitmapCodecCount++;\n\n#if defined(WITH_JPEG)\n\n\tif (settings->JpegCodec)\n\t\tbitmapCodecCount++;\n\n#endif\n\n\tif (settings->RemoteFxImageCodec)\n\t\tbitmapCodecCount++;\n\n\tStream_Write_UINT8(s, bitmapCodecCount);\n\n\tif (settings->RemoteFxCodec)\n\t{\n\t\trdp_write_bitmap_codec_guid(s, &CODEC_GUID_REMOTEFX); /* codecGUID */\n\n\t\tif (settings->ServerMode)\n\t\t{\n\t\t\tStream_Write_UINT8(s, 0); /* codecID is defined by the client */\n\n\t\t\tif (!rdp_write_rfx_server_capability_container(s, settings))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tStream_Write_UINT8(s, RDP_CODEC_ID_REMOTEFX); /* codecID */\n\n\t\t\tif (!rdp_write_rfx_client_capability_container(s, settings))\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\tif (settings->NSCodec)\n\t{\n\t\trdp_write_bitmap_codec_guid(s, &CODEC_GUID_NSCODEC); /* codecGUID */\n\n\t\tif (settings->ServerMode)\n\t\t{\n\t\t\tStream_Write_UINT8(s, 0); /* codecID is defined by the client */\n\n\t\t\tif (!rdp_write_nsc_server_capability_container(s, settings))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tStream_Write_UINT8(s, RDP_CODEC_ID_NSCODEC); /* codecID */\n\n\t\t\tif (!rdp_write_nsc_client_capability_container(s, settings))\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\n#if defined(WITH_JPEG)\n\n\tif (settings->JpegCodec)\n\t{\n\t\trdp_write_bitmap_codec_guid(s, &CODEC_GUID_JPEG); /* codecGUID */\n\n\t\tif (settings->ServerMode)\n\t\t{\n\t\t\tStream_Write_UINT8(s, 0); /* codecID is defined by the client */\n\n\t\t\tif (!rdp_write_jpeg_server_capability_container(s, settings))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tStream_Write_UINT8(s, RDP_CODEC_ID_JPEG); /* codecID */\n\n\t\t\tif (!rdp_write_jpeg_client_capability_container(s, settings))\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\n#endif\n\n\tif (settings->RemoteFxImageCodec)\n\t{\n\t\trdp_write_bitmap_codec_guid(s, &CODEC_GUID_IMAGE_REMOTEFX); /* codecGUID */\n\n\t\tif (settings->ServerMode)\n\t\t{\n\t\t\tStream_Write_UINT8(s, 0); /* codecID is defined by the client */\n\n\t\t\tif (!rdp_write_rfx_server_capability_container(s, settings))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tStream_Write_UINT8(s, RDP_CODEC_ID_IMAGE_REMOTEFX); /* codecID */\n\n\t\t\tif (!rdp_write_rfx_client_capability_container(s, settings))\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\trdp_capability_set_finish(s, header, CAPSET_TYPE_BITMAP_CODECS);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_bitmap_codecs_capability_set(wStream* s)\n{\n\tGUID codecGuid;\n\tBYTE bitmapCodecCount;\n\tBYTE codecId;\n\tUINT16 codecPropertiesLength;\n\n\tWLog_INFO(TAG, \"BitmapCodecsCapabilitySet (length %\" PRIuz \"):\", Stream_GetRemainingLength(s));\n\n\tif (Stream_GetRemainingLength(s) < 1)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, bitmapCodecCount); /* bitmapCodecCount (1 byte) */\n\tWLog_INFO(TAG, \"\\tbitmapCodecCount: %\" PRIu8 \"\", bitmapCodecCount);\n\n\twhile (bitmapCodecCount > 0)\n\t{\n\t\tif (!rdp_read_bitmap_codec_guid(s, &codecGuid)) /* codecGuid (16 bytes) */\n\t\t\treturn FALSE;\n\t\tif (Stream_GetRemainingLength(s) < 3)\n\t\t\treturn FALSE;\n\t\tStream_Read_UINT8(s, codecId);             /* codecId (1 byte) */\n\t\tWLog_INFO(TAG, \"\\tcodecGuid: 0x\");\n\t\trdp_print_bitmap_codec_guid(&codecGuid);\n\t\tWLog_INFO(TAG, \" (%s)\", rdp_get_bitmap_codec_guid_name(&codecGuid));\n\t\tWLog_INFO(TAG, \"\\tcodecId: %\" PRIu8 \"\", codecId);\n\t\tStream_Read_UINT16(s, codecPropertiesLength); /* codecPropertiesLength (2 bytes) */\n\t\tWLog_INFO(TAG, \"\\tcodecPropertiesLength: %\" PRIu16 \"\", codecPropertiesLength);\n\n\t\tif (!Stream_SafeSeek(s, codecPropertiesLength)) /* codecProperties */\n\t\t\treturn FALSE;\n\t\tbitmapCodecCount--;\n\t}\n\n\treturn TRUE;\n}\n#endif\n\n/**\n * Read frame acknowledge capability set.\\n\n * @param s stream\n * @param settings settings\n * @return if the operation completed successfully\n */\n\nstatic BOOL rdp_read_frame_acknowledge_capability_set(wStream* s, rdpSettings* settings)\n{\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tif (settings->ServerMode)\n\t{\n\t\tStream_Read_UINT32(s, settings->FrameAcknowledge); /* (4 bytes) */\n\t}\n\telse\n\t{\n\t\tStream_Seek_UINT32(s); /* (4 bytes) */\n\t}\n\n\treturn TRUE;\n}\n\n/**\n * Write frame acknowledge capability set.\\n\n * @param s stream\n * @param settings settings\n */\n\nstatic BOOL rdp_write_frame_acknowledge_capability_set(wStream* s, const rdpSettings* settings)\n{\n\tsize_t header;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 32))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tif (header > UINT16_MAX)\n\t\treturn FALSE;\n\tStream_Write_UINT32(s, settings->FrameAcknowledge); /* (4 bytes) */\n\trdp_capability_set_finish(s, (UINT16)header, CAPSET_TYPE_FRAME_ACKNOWLEDGE);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_frame_acknowledge_capability_set(wStream* s)\n{\n\tUINT32 frameAcknowledge;\n\tWLog_INFO(TAG,\n\t          \"FrameAcknowledgeCapabilitySet (length %\" PRIuz \"):\", Stream_GetRemainingLength(s));\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, frameAcknowledge); /* frameAcknowledge (4 bytes) */\n\tWLog_INFO(TAG, \"\\tframeAcknowledge: 0x%08\" PRIX32 \"\", frameAcknowledge);\n\treturn TRUE;\n}\n#endif\n\nstatic BOOL rdp_read_bitmap_cache_v3_codec_id_capability_set(wStream* s, rdpSettings* settings)\n{\n\tBYTE bitmapCacheV3CodecId;\n\n\tWINPR_UNUSED(settings);\n\tif (Stream_GetRemainingLength(s) < 1)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, bitmapCacheV3CodecId); /* bitmapCacheV3CodecId (1 byte) */\n\treturn TRUE;\n}\n\nstatic BOOL rdp_write_bitmap_cache_v3_codec_id_capability_set(wStream* s,\n                                                              const rdpSettings* settings)\n{\n\tsize_t header;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 32))\n\t\treturn FALSE;\n\n\theader = rdp_capability_set_start(s);\n\tif (header > UINT16_MAX)\n\t\treturn FALSE;\n\tif (settings->BitmapCacheV3CodecId > UINT8_MAX)\n\t\treturn FALSE;\n\tStream_Write_UINT8(s, (UINT8)settings->BitmapCacheV3CodecId);\n\trdp_capability_set_finish(s, (UINT16)header, CAPSET_TYPE_BITMAP_CACHE_V3_CODEC_ID);\n\treturn TRUE;\n}\n\n#ifdef WITH_DEBUG_CAPABILITIES\nstatic BOOL rdp_print_bitmap_cache_v3_codec_id_capability_set(wStream* s)\n{\n\tBYTE bitmapCacheV3CodecId;\n\tWLog_INFO(TAG, \"BitmapCacheV3CodecIdCapabilitySet (length %\" PRIuz \"):\",\n\t          Stream_GetRemainingLength(s));\n\n\tif (Stream_GetRemainingLength(s) < 1)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, bitmapCacheV3CodecId); /* bitmapCacheV3CodecId (1 byte) */\n\tWLog_INFO(TAG, \"\\tbitmapCacheV3CodecId: 0x%02\" PRIX8 \"\", bitmapCacheV3CodecId);\n\treturn TRUE;\n}\n\nstatic BOOL rdp_print_capability_sets(wStream* s, UINT16 numberCapabilities, BOOL receiving)\n{\n\tUINT16 type;\n\tUINT16 length;\n\n\twhile (numberCapabilities > 0)\n\t{\n\t\tsize_t rest;\n\t\twStream sub;\n\t\tif (!rdp_read_capability_set_header(s, &length, &type))\n\t\t\treturn FALSE;\n\n\t\tWLog_INFO(TAG, \"%s \", receiving ? \"Receiving\" : \"Sending\");\n\t\tStream_StaticInit(&sub, Stream_Pointer(s), length - 4);\n\t\tif (!Stream_SafeSeek(s, length - 4))\n\t\t\treturn FALSE;\n\n\t\tswitch (type)\n\t\t{\n\t\t\tcase CAPSET_TYPE_GENERAL:\n\t\t\t\tif (!rdp_print_general_capability_set(&sub))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_BITMAP:\n\t\t\t\tif (!rdp_print_bitmap_capability_set(&sub))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_ORDER:\n\t\t\t\tif (!rdp_print_order_capability_set(&sub))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_BITMAP_CACHE:\n\t\t\t\tif (!rdp_print_bitmap_cache_capability_set(&sub))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_CONTROL:\n\t\t\t\tif (!rdp_print_control_capability_set(&sub))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_ACTIVATION:\n\t\t\t\tif (!rdp_print_window_activation_capability_set(&sub))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_POINTER:\n\t\t\t\tif (!rdp_print_pointer_capability_set(&sub))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_SHARE:\n\t\t\t\tif (!rdp_print_share_capability_set(&sub))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_COLOR_CACHE:\n\t\t\t\tif (!rdp_print_color_cache_capability_set(&sub))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_SOUND:\n\t\t\t\tif (!rdp_print_sound_capability_set(&sub))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_INPUT:\n\t\t\t\tif (!rdp_print_input_capability_set(&sub))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_FONT:\n\t\t\t\tif (!rdp_print_font_capability_set(&sub))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_BRUSH:\n\t\t\t\tif (!rdp_print_brush_capability_set(&sub))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_GLYPH_CACHE:\n\t\t\t\tif (!rdp_print_glyph_cache_capability_set(&sub))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_OFFSCREEN_CACHE:\n\t\t\t\tif (!rdp_print_offscreen_bitmap_cache_capability_set(&sub))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_BITMAP_CACHE_HOST_SUPPORT:\n\t\t\t\tif (!rdp_print_bitmap_cache_host_support_capability_set(&sub))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_BITMAP_CACHE_V2:\n\t\t\t\tif (!rdp_print_bitmap_cache_v2_capability_set(&sub))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_VIRTUAL_CHANNEL:\n\t\t\t\tif (!rdp_print_virtual_channel_capability_set(&sub))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_DRAW_NINE_GRID_CACHE:\n\t\t\t\tif (!rdp_print_draw_nine_grid_cache_capability_set(&sub))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_DRAW_GDI_PLUS:\n\t\t\t\tif (!rdp_print_draw_gdiplus_cache_capability_set(&sub))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_RAIL:\n\t\t\t\tif (!rdp_print_remote_programs_capability_set(&sub))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_WINDOW:\n\t\t\t\tif (!rdp_print_window_list_capability_set(&sub))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_COMP_DESK:\n\t\t\t\tif (!rdp_print_desktop_composition_capability_set(&sub))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_MULTI_FRAGMENT_UPDATE:\n\t\t\t\tif (!rdp_print_multifragment_update_capability_set(&sub))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_LARGE_POINTER:\n\t\t\t\tif (!rdp_print_large_pointer_capability_set(&sub))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_SURFACE_COMMANDS:\n\t\t\t\tif (!rdp_print_surface_commands_capability_set(&sub))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_BITMAP_CODECS:\n\t\t\t\tif (!rdp_print_bitmap_codecs_capability_set(&sub))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_FRAME_ACKNOWLEDGE:\n\t\t\t\tif (!rdp_print_frame_acknowledge_capability_set(&sub))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_BITMAP_CACHE_V3_CODEC_ID:\n\t\t\t\tif (!rdp_print_bitmap_cache_v3_codec_id_capability_set(&sub))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tWLog_ERR(TAG, \"unknown capability type %\" PRIu16 \"\", type);\n\t\t\t\tbreak;\n\t\t}\n\n\t\trest = Stream_GetRemainingLength(&sub);\n\t\tif (rest > 0)\n\t\t{\n\t\t\tWLog_WARN(TAG,\n\t\t\t          \"incorrect capability offset, type:0x%04\" PRIX16 \" %\" PRIu16\n\t\t\t          \" bytes expected, %\" PRIuz \"bytes remaining\",\n\t\t\t          type, length, rest);\n\t\t}\n\n\t\tnumberCapabilities--;\n\t}\n\n\treturn TRUE;\n}\n#endif\n\nstatic BOOL rdp_read_capability_sets(wStream* s, rdpSettings* settings, UINT16 numberCapabilities,\n                                     UINT16 totalLength)\n{\n\tBOOL treated;\n\tsize_t start, end, len;\n\tUINT16 count = numberCapabilities;\n\n\tstart = Stream_GetPosition(s);\n\twhile (numberCapabilities > 0 && Stream_GetRemainingLength(s) >= 4)\n\t{\n\t\tsize_t rest;\n\t\tUINT16 type;\n\t\tUINT16 length;\n\t\twStream sub;\n\n\t\tif (!rdp_read_capability_set_header(s, &length, &type))\n\t\t\treturn FALSE;\n\t\tStream_StaticInit(&sub, Stream_Pointer(s), length - 4);\n\t\tif (!Stream_SafeSeek(s, length - 4))\n\t\t\treturn FALSE;\n\n\t\tif (type < 32)\n\t\t{\n\t\t\tsettings->ReceivedCapabilities[type] = TRUE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tWLog_WARN(TAG, \"not handling capability type %\" PRIu16 \" yet\", type);\n\t\t}\n\n\t\ttreated = TRUE;\n\n\t\tswitch (type)\n\t\t{\n\t\t\tcase CAPSET_TYPE_GENERAL:\n\t\t\t\tif (!rdp_read_general_capability_set(&sub, settings))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_BITMAP:\n\t\t\t\tif (!rdp_read_bitmap_capability_set(&sub, settings))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_ORDER:\n\t\t\t\tif (!rdp_read_order_capability_set(&sub, settings))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_POINTER:\n\t\t\t\tif (!rdp_read_pointer_capability_set(&sub, settings))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_INPUT:\n\t\t\t\tif (!rdp_read_input_capability_set(&sub, settings))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_VIRTUAL_CHANNEL:\n\t\t\t\tif (!rdp_read_virtual_channel_capability_set(&sub, settings))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_SHARE:\n\t\t\t\tif (!rdp_read_share_capability_set(&sub, settings))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_COLOR_CACHE:\n\t\t\t\tif (!rdp_read_color_cache_capability_set(&sub, settings))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_FONT:\n\t\t\t\tif (!rdp_read_font_capability_set(&sub, settings))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_DRAW_GDI_PLUS:\n\t\t\t\tif (!rdp_read_draw_gdiplus_cache_capability_set(&sub, settings))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_RAIL:\n\t\t\t\tif (!rdp_read_remote_programs_capability_set(&sub, settings))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_WINDOW:\n\t\t\t\tif (!rdp_read_window_list_capability_set(&sub, settings))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_MULTI_FRAGMENT_UPDATE:\n\t\t\t\tif (!rdp_read_multifragment_update_capability_set(&sub, settings))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_LARGE_POINTER:\n\t\t\t\tif (!rdp_read_large_pointer_capability_set(&sub, settings))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_COMP_DESK:\n\t\t\t\tif (!rdp_read_desktop_composition_capability_set(&sub, settings))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_SURFACE_COMMANDS:\n\t\t\t\tif (!rdp_read_surface_commands_capability_set(&sub, settings))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_BITMAP_CODECS:\n\t\t\t\tif (!rdp_read_bitmap_codecs_capability_set(&sub, settings))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_FRAME_ACKNOWLEDGE:\n\t\t\t\tif (!rdp_read_frame_acknowledge_capability_set(&sub, settings))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CAPSET_TYPE_BITMAP_CACHE_V3_CODEC_ID:\n\t\t\t\tif (!rdp_read_bitmap_cache_v3_codec_id_capability_set(&sub, settings))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\ttreated = FALSE;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!treated)\n\t\t{\n\t\t\tif (settings->ServerMode)\n\t\t\t{\n\t\t\t\t/* treating capabilities that are supposed to be send only from the client */\n\t\t\t\tswitch (type)\n\t\t\t\t{\n\t\t\t\t\tcase CAPSET_TYPE_BITMAP_CACHE:\n\t\t\t\t\t\tif (!rdp_read_bitmap_cache_capability_set(&sub, settings))\n\t\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase CAPSET_TYPE_BITMAP_CACHE_V2:\n\t\t\t\t\t\tif (!rdp_read_bitmap_cache_v2_capability_set(&sub, settings))\n\t\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase CAPSET_TYPE_BRUSH:\n\t\t\t\t\t\tif (!rdp_read_brush_capability_set(&sub, settings))\n\t\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase CAPSET_TYPE_GLYPH_CACHE:\n\t\t\t\t\t\tif (!rdp_read_glyph_cache_capability_set(&sub, settings))\n\t\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase CAPSET_TYPE_OFFSCREEN_CACHE:\n\t\t\t\t\t\tif (!rdp_read_offscreen_bitmap_cache_capability_set(&sub, settings))\n\t\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase CAPSET_TYPE_SOUND:\n\t\t\t\t\t\tif (!rdp_read_sound_capability_set(&sub, settings))\n\t\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase CAPSET_TYPE_CONTROL:\n\t\t\t\t\t\tif (!rdp_read_control_capability_set(&sub, settings))\n\t\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase CAPSET_TYPE_ACTIVATION:\n\t\t\t\t\t\tif (!rdp_read_window_activation_capability_set(&sub, settings))\n\t\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase CAPSET_TYPE_DRAW_NINE_GRID_CACHE:\n\t\t\t\t\t\tif (!rdp_read_draw_nine_grid_cache_capability_set(&sub, settings))\n\t\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tWLog_ERR(TAG, \"capability %s(%\" PRIu16 \") not expected from client\",\n\t\t\t\t\t\t         get_capability_name(type), type);\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* treating capabilities that are supposed to be send only from the server */\n\t\t\t\tswitch (type)\n\t\t\t\t{\n\t\t\t\t\tcase CAPSET_TYPE_BITMAP_CACHE_HOST_SUPPORT:\n\t\t\t\t\t\tif (!rdp_read_bitmap_cache_host_support_capability_set(&sub, settings))\n\t\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tWLog_ERR(TAG, \"capability %s(%\" PRIu16 \") not expected from server\",\n\t\t\t\t\t\t         get_capability_name(type), type);\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\trest = Stream_GetRemainingLength(&sub);\n\t\tif (rest > 0)\n\t\t{\n\t\t\tWLog_ERR(TAG,\n\t\t\t         \"incorrect offset, type:0x%04\" PRIX16 \" actual:%\" PRIuz \" expected:%\" PRIu16\n\t\t\t         \"\",\n\t\t\t         type, length - rest, length);\n\t\t}\n\n\t\tnumberCapabilities--;\n\t}\n\n\tend = Stream_GetPosition(s);\n\tlen = end - start;\n\n\tif (numberCapabilities)\n\t{\n\t\tWLog_ERR(TAG,\n\t\t         \"strange we haven't read the number of announced capacity sets, read=%d \"\n\t\t         \"expected=%\" PRIu16 \"\",\n\t\t         count - numberCapabilities, count);\n\t}\n\n#ifdef WITH_DEBUG_CAPABILITIES\n\t{\n\t\tStream_SetPosition(s, start);\n\t\tnumberCapabilities = count;\n\t\trdp_print_capability_sets(s, numberCapabilities, TRUE);\n\t\tStream_SetPosition(s, end);\n\t}\n#endif\n\n\tif (len > totalLength)\n\t{\n\t\tWLog_ERR(TAG, \"Capability length expected %\" PRIu16 \", actual %\" PRIdz, totalLength, len);\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nBOOL rdp_recv_get_active_header(rdpRdp* rdp, wStream* s, UINT16* pChannelId, UINT16* length)\n{\n\tUINT16 securityFlags = 0;\n\n\tif (!rdp_read_header(rdp, s, length, pChannelId))\n\t\treturn FALSE;\n\n\tif (freerdp_shall_disconnect(rdp->instance))\n\t\treturn TRUE;\n\n\tif (rdp->settings->UseRdpSecurityLayer)\n\t{\n\t\tif (!rdp_read_security_header(s, &securityFlags, length))\n\t\t\treturn FALSE;\n\n\t\tif (securityFlags & SEC_ENCRYPT)\n\t\t{\n\t\t\tif (!rdp_decrypt(rdp, s, length, securityFlags))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdp_decrypt failed\");\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (*pChannelId != MCS_GLOBAL_CHANNEL_ID)\n\t{\n\t\tUINT16 mcsMessageChannelId = rdp->mcs->messageChannelId;\n\n\t\tif ((mcsMessageChannelId == 0) || (*pChannelId != mcsMessageChannelId))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"unexpected MCS channel id %04\" PRIx16 \" received\", *pChannelId);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\nBOOL rdp_recv_demand_active(rdpRdp* rdp, wStream* s)\n{\n\tUINT16 channelId;\n\tUINT16 pduType;\n\tUINT16 pduSource;\n\tUINT16 length;\n\tUINT16 numberCapabilities;\n\tUINT16 lengthSourceDescriptor;\n\tUINT16 lengthCombinedCapabilities;\n\n\tif (!rdp_recv_get_active_header(rdp, s, &channelId, &length))\n\t\treturn FALSE;\n\n\tif (freerdp_shall_disconnect(rdp->instance))\n\t\treturn TRUE;\n\n\tif (!rdp_read_share_control_header(s, NULL, NULL, &pduType, &pduSource))\n\t{\n\t\tWLog_ERR(TAG, \"rdp_read_share_control_header failed\");\n\t\treturn FALSE;\n\t}\n\n\tif (pduType == PDU_TYPE_DATA)\n\t{\n\t\t/**\n\t\t * We can receive a Save Session Info Data PDU containing a LogonErrorInfo\n\t\t * structure at this point from the server to indicate a connection error.\n\t\t */\n\t\tif (rdp_recv_data_pdu(rdp, s) < 0)\n\t\t\treturn FALSE;\n\n\t\treturn FALSE;\n\t}\n\n\tif (pduType != PDU_TYPE_DEMAND_ACTIVE)\n\t{\n\t\tif (pduType != PDU_TYPE_SERVER_REDIRECTION)\n\t\t\tWLog_ERR(TAG, \"expected PDU_TYPE_DEMAND_ACTIVE %04x, got %04\" PRIx16 \"\",\n\t\t\t         PDU_TYPE_DEMAND_ACTIVE, pduType);\n\n\t\treturn FALSE;\n\t}\n\n\trdp->settings->PduSource = pduSource;\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, rdp->settings->ShareId);     /* shareId (4 bytes) */\n\tStream_Read_UINT16(s, lengthSourceDescriptor);     /* lengthSourceDescriptor (2 bytes) */\n\tStream_Read_UINT16(s, lengthCombinedCapabilities); /* lengthCombinedCapabilities (2 bytes) */\n\n\tif (!Stream_SafeSeek(s, lengthSourceDescriptor) ||\n\t    Stream_GetRemainingLength(s) < 4) /* sourceDescriptor */\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, numberCapabilities); /* numberCapabilities (2 bytes) */\n\tStream_Seek(s, 2);                         /* pad2Octets (2 bytes) */\n\n\t/* capabilitySets */\n\tif (!rdp_read_capability_sets(s, rdp->settings, numberCapabilities, lengthCombinedCapabilities))\n\t{\n\t\tWLog_ERR(TAG, \"rdp_read_capability_sets failed\");\n\t\treturn FALSE;\n\t}\n\n\tif (!Stream_SafeSeek(s, 4)) /* SessionId */\n\t\treturn FALSE;\n\n\trdp->update->secondary->glyph_v2 = (rdp->settings->GlyphSupportLevel > GLYPH_SUPPORT_FULL);\n\treturn tpkt_ensure_stream_consumed(s, length);\n}\n\nstatic BOOL rdp_write_demand_active(wStream* s, rdpSettings* settings)\n{\n\tsize_t bm, em, lm;\n\tUINT16 numberCapabilities;\n\tsize_t lengthCombinedCapabilities;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 64))\n\t\treturn FALSE;\n\n\tStream_Write_UINT32(s, settings->ShareId); /* shareId (4 bytes) */\n\tStream_Write_UINT16(s, 4);                 /* lengthSourceDescriptor (2 bytes) */\n\tlm = Stream_GetPosition(s);\n\tStream_Seek_UINT16(s);     /* lengthCombinedCapabilities (2 bytes) */\n\tStream_Write(s, \"RDP\", 4); /* sourceDescriptor */\n\tbm = Stream_GetPosition(s);\n\tStream_Seek_UINT16(s);     /* numberCapabilities (2 bytes) */\n\tStream_Write_UINT16(s, 0); /* pad2Octets (2 bytes) */\n\tnumberCapabilities = 14;\n\n\tif (!rdp_write_general_capability_set(s, settings) ||\n\t    !rdp_write_bitmap_capability_set(s, settings) ||\n\t    !rdp_write_order_capability_set(s, settings) ||\n\t    !rdp_write_pointer_capability_set(s, settings) ||\n\t    !rdp_write_input_capability_set(s, settings) ||\n\t    !rdp_write_virtual_channel_capability_set(s, settings) ||\n\t    !rdp_write_share_capability_set(s, settings) ||\n\t    !rdp_write_font_capability_set(s, settings) ||\n\t    !rdp_write_multifragment_update_capability_set(s, settings) ||\n\t    !rdp_write_large_pointer_capability_set(s, settings) ||\n\t    !rdp_write_desktop_composition_capability_set(s, settings) ||\n\t    !rdp_write_surface_commands_capability_set(s, settings) ||\n\t    !rdp_write_bitmap_codecs_capability_set(s, settings) ||\n\t    !rdp_write_frame_acknowledge_capability_set(s, settings))\n\t{\n\t\treturn FALSE;\n\t}\n\n\tif (settings->BitmapCachePersistEnabled)\n\t{\n\t\tnumberCapabilities++;\n\n\t\tif (!rdp_write_bitmap_cache_host_support_capability_set(s, settings))\n\t\t\treturn FALSE;\n\t}\n\n\tif (settings->RemoteApplicationMode)\n\t{\n\t\tnumberCapabilities += 2;\n\n\t\tif (!rdp_write_remote_programs_capability_set(s, settings) ||\n\t\t    !rdp_write_window_list_capability_set(s, settings))\n\t\t\treturn FALSE;\n\t}\n\n\tem = Stream_GetPosition(s);\n\tStream_SetPosition(s, lm); /* go back to lengthCombinedCapabilities */\n\tlengthCombinedCapabilities = (em - bm);\n\tif (lengthCombinedCapabilities > UINT16_MAX)\n\t\treturn FALSE;\n\tStream_Write_UINT16(\n\t    s, (UINT16)lengthCombinedCapabilities);         /* lengthCombinedCapabilities (2 bytes) */\n\tStream_SetPosition(s, bm);                          /* go back to numberCapabilities */\n\tStream_Write_UINT16(s, numberCapabilities);         /* numberCapabilities (2 bytes) */\n#ifdef WITH_DEBUG_CAPABILITIES\n\tStream_Seek_UINT16(s);\n\trdp_print_capability_sets(s, numberCapabilities, FALSE);\n\tStream_SetPosition(s, bm);\n\tStream_Seek_UINT16(s);\n#endif\n\tStream_SetPosition(s, em);\n\tStream_Write_UINT32(s, 0); /* sessionId */\n\treturn TRUE;\n}\n\nBOOL rdp_send_demand_active(rdpRdp* rdp)\n{\n\twStream* s = rdp_send_stream_pdu_init(rdp);\n\tBOOL status;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\trdp->settings->ShareId = 0x10000 + rdp->mcs->userId;\n\tstatus = rdp_write_demand_active(s, rdp->settings) &&\n\t         rdp_send_pdu(rdp, s, PDU_TYPE_DEMAND_ACTIVE, rdp->mcs->userId);\n\tStream_Release(s);\n\treturn status;\n}\n\nBOOL rdp_recv_confirm_active(rdpRdp* rdp, wStream* s, UINT16 pduLength)\n{\n\trdpSettings* settings;\n\tUINT16 lengthSourceDescriptor;\n\tUINT16 lengthCombinedCapabilities;\n\tUINT16 numberCapabilities;\n\tsettings = rdp->settings;\n\n\tif (Stream_GetRemainingLength(s) < 10)\n\t\treturn FALSE;\n\n\tStream_Seek_UINT32(s);                             /* shareId (4 bytes) */\n\tStream_Seek_UINT16(s);                             /* originatorId (2 bytes) */\n\tStream_Read_UINT16(s, lengthSourceDescriptor);     /* lengthSourceDescriptor (2 bytes) */\n\tStream_Read_UINT16(s, lengthCombinedCapabilities); /* lengthCombinedCapabilities (2 bytes) */\n\n\tif (Stream_GetRemainingLength(s) < lengthSourceDescriptor + 4U)\n\t\treturn FALSE;\n\n\tStream_Seek(s, lengthSourceDescriptor);    /* sourceDescriptor */\n\tStream_Read_UINT16(s, numberCapabilities); /* numberCapabilities (2 bytes) */\n\tStream_Seek(s, 2);                         /* pad2Octets (2 bytes) */\n\tif (!rdp_read_capability_sets(s, rdp->settings, numberCapabilities, lengthCombinedCapabilities))\n\t\treturn FALSE;\n\n\tif (!settings->ReceivedCapabilities[CAPSET_TYPE_SURFACE_COMMANDS])\n\t{\n\t\t/* client does not support surface commands */\n\t\tsettings->SurfaceCommandsEnabled = FALSE;\n\t\tsettings->SurfaceFrameMarkerEnabled = FALSE;\n\t}\n\n\tif (!settings->ReceivedCapabilities[CAPSET_TYPE_FRAME_ACKNOWLEDGE])\n\t{\n\t\t/* client does not support frame acks */\n\t\tsettings->FrameAcknowledge = 0;\n\t}\n\n\tif (!settings->ReceivedCapabilities[CAPSET_TYPE_BITMAP_CACHE_V3_CODEC_ID])\n\t{\n\t\t/* client does not support bitmap cache v3 */\n\t\tsettings->BitmapCacheV3Enabled = FALSE;\n\t}\n\n\tif (!settings->ReceivedCapabilities[CAPSET_TYPE_BITMAP_CODECS])\n\t{\n\t\t/* client does not support bitmap codecs */\n\t\tsettings->RemoteFxCodec = FALSE;\n\t\tsettings->NSCodec = FALSE;\n\t\tsettings->JpegCodec = FALSE;\n\t}\n\n\tif (!settings->ReceivedCapabilities[CAPSET_TYPE_MULTI_FRAGMENT_UPDATE])\n\t{\n\t\t/* client does not support multi fragment updates - make sure packages are not fragmented */\n\t\tsettings->MultifragMaxRequestSize = FASTPATH_FRAGMENT_SAFE_SIZE;\n\t}\n\n\tif (!settings->ReceivedCapabilities[CAPSET_TYPE_LARGE_POINTER])\n\t{\n\t\t/* client does not support large pointers */\n\t\tsettings->LargePointerFlag = 0;\n\t}\n\n\treturn tpkt_ensure_stream_consumed(s, pduLength);\n}\n\nstatic BOOL rdp_write_confirm_active(wStream* s, rdpSettings* settings)\n{\n\tsize_t bm, em, lm;\n\tUINT16 numberCapabilities;\n\tUINT16 lengthSourceDescriptor;\n\tsize_t lengthCombinedCapabilities;\n\tBOOL ret;\n\tlengthSourceDescriptor = sizeof(SOURCE_DESCRIPTOR);\n\tStream_Write_UINT32(s, settings->ShareId);      /* shareId (4 bytes) */\n\tStream_Write_UINT16(s, 0x03EA);                 /* originatorId (2 bytes) */\n\tStream_Write_UINT16(s, lengthSourceDescriptor); /* lengthSourceDescriptor (2 bytes) */\n\tlm = Stream_GetPosition(s);\n\tStream_Seek_UINT16(s); /* lengthCombinedCapabilities (2 bytes) */\n\tStream_Write(s, SOURCE_DESCRIPTOR, lengthSourceDescriptor); /* sourceDescriptor */\n\tbm = Stream_GetPosition(s);\n\tStream_Seek_UINT16(s);     /* numberCapabilities (2 bytes) */\n\tStream_Write_UINT16(s, 0); /* pad2Octets (2 bytes) */\n\t/* Capability Sets */\n\tnumberCapabilities = 15;\n\n\tif (!rdp_write_general_capability_set(s, settings) ||\n\t    !rdp_write_bitmap_capability_set(s, settings) ||\n\t    !rdp_write_order_capability_set(s, settings))\n\t\treturn FALSE;\n\n\tif (settings->RdpVersion >= RDP_VERSION_5_PLUS)\n\t\tret = rdp_write_bitmap_cache_v2_capability_set(s, settings);\n\telse\n\t\tret = rdp_write_bitmap_cache_capability_set(s, settings);\n\n\tif (!ret)\n\t\treturn FALSE;\n\n\tif (!rdp_write_pointer_capability_set(s, settings) ||\n\t    !rdp_write_input_capability_set(s, settings) ||\n\t    !rdp_write_brush_capability_set(s, settings) ||\n\t    !rdp_write_glyph_cache_capability_set(s, settings) ||\n\t    !rdp_write_virtual_channel_capability_set(s, settings) ||\n\t    !rdp_write_sound_capability_set(s, settings) ||\n\t    !rdp_write_share_capability_set(s, settings) ||\n\t    !rdp_write_font_capability_set(s, settings) ||\n\t    !rdp_write_control_capability_set(s, settings) ||\n\t    !rdp_write_color_cache_capability_set(s, settings) ||\n\t    !rdp_write_window_activation_capability_set(s, settings))\n\t{\n\t\treturn FALSE;\n\t}\n\n\tif (settings->OffscreenSupportLevel)\n\t{\n\t\tnumberCapabilities++;\n\n\t\tif (!rdp_write_offscreen_bitmap_cache_capability_set(s, settings))\n\t\t\treturn FALSE;\n\t}\n\n\tif (settings->DrawNineGridEnabled)\n\t{\n\t\tnumberCapabilities++;\n\n\t\tif (!rdp_write_draw_nine_grid_cache_capability_set(s, settings))\n\t\t\treturn FALSE;\n\t}\n\n\tif (settings->ReceivedCapabilities[CAPSET_TYPE_LARGE_POINTER])\n\t{\n\t\tif (settings->LargePointerFlag)\n\t\t{\n\t\t\tnumberCapabilities++;\n\n\t\t\tif (!rdp_write_large_pointer_capability_set(s, settings))\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\tif (settings->RemoteApplicationMode)\n\t{\n\t\tnumberCapabilities += 2;\n\n\t\tif (!rdp_write_remote_programs_capability_set(s, settings) ||\n\t\t    !rdp_write_window_list_capability_set(s, settings))\n\t\t\treturn FALSE;\n\t}\n\n\tif (settings->ReceivedCapabilities[CAPSET_TYPE_MULTI_FRAGMENT_UPDATE])\n\t{\n\t\tnumberCapabilities++;\n\n\t\tif (!rdp_write_multifragment_update_capability_set(s, settings))\n\t\t\treturn FALSE;\n\t}\n\n\tif (settings->ReceivedCapabilities[CAPSET_TYPE_SURFACE_COMMANDS])\n\t{\n\t\tnumberCapabilities++;\n\n\t\tif (!rdp_write_surface_commands_capability_set(s, settings))\n\t\t\treturn FALSE;\n\t}\n\n\tif (settings->ReceivedCapabilities[CAPSET_TYPE_BITMAP_CODECS])\n\t{\n\t\tnumberCapabilities++;\n\n\t\tif (!rdp_write_bitmap_codecs_capability_set(s, settings))\n\t\t\treturn FALSE;\n\t}\n\n\tif (!settings->ReceivedCapabilities[CAPSET_TYPE_FRAME_ACKNOWLEDGE])\n\t\tsettings->FrameAcknowledge = 0;\n\n\tif (settings->FrameAcknowledge)\n\t{\n\t\tnumberCapabilities++;\n\n\t\tif (!rdp_write_frame_acknowledge_capability_set(s, settings))\n\t\t\treturn FALSE;\n\t}\n\n\tif (settings->ReceivedCapabilities[CAPSET_TYPE_BITMAP_CACHE_V3_CODEC_ID])\n\t{\n\t\tif (settings->BitmapCacheV3CodecId != 0)\n\t\t{\n\t\t\tnumberCapabilities++;\n\n\t\t\tif (!rdp_write_bitmap_cache_v3_codec_id_capability_set(s, settings))\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\tem = Stream_GetPosition(s);\n\tStream_SetPosition(s, lm); /* go back to lengthCombinedCapabilities */\n\tlengthCombinedCapabilities = (em - bm);\n\tif (lengthCombinedCapabilities > UINT16_MAX)\n\t\treturn FALSE;\n\tStream_Write_UINT16(\n\t    s, (UINT16)lengthCombinedCapabilities);         /* lengthCombinedCapabilities (2 bytes) */\n\tStream_SetPosition(s, bm);                          /* go back to numberCapabilities */\n\tStream_Write_UINT16(s, numberCapabilities);         /* numberCapabilities (2 bytes) */\n#ifdef WITH_DEBUG_CAPABILITIES\n\tStream_Seek_UINT16(s);\n\trdp_print_capability_sets(s, numberCapabilities, FALSE);\n\tStream_SetPosition(s, bm);\n\tStream_Seek_UINT16(s);\n#endif\n\tStream_SetPosition(s, em);\n\n\treturn TRUE;\n}\n\nBOOL rdp_send_confirm_active(rdpRdp* rdp)\n{\n\twStream* s = rdp_send_stream_pdu_init(rdp);\n\tBOOL status;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tstatus = rdp_write_confirm_active(s, rdp->settings) &&\n\t         rdp_send_pdu(rdp, s, PDU_TYPE_CONFIRM_ACTIVE, rdp->mcs->userId);\n\tStream_Release(s);\n\treturn status;\n}\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * T.124 Generic Conference Control (GCC)\n *\n * Copyright 2011 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2014 Norbert Federa <norbert.federa@thincast.com>\n * Copyright 2014 DI (FH) Martin Haimberger <martin.haimberger@thincast.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <winpr/crt.h>\n#include <winpr/crypto.h>\n\n#include <freerdp/log.h>\n\n#include \"gcc.h\"\n#include \"certificate.h\"\n\n#define TAG FREERDP_TAG(\"core.gcc\")\n\nstatic BOOL gcc_read_client_cluster_data(wStream* s, rdpMcs* mcs, UINT16 blockLength);\nstatic BOOL gcc_read_client_core_data(wStream* s, rdpMcs* mcs, UINT16 blockLength);\nstatic BOOL gcc_read_client_data_blocks(wStream* s, rdpMcs* mcs, int length);\nstatic BOOL gcc_read_server_data_blocks(wStream* s, rdpMcs* mcs, int length);\nstatic BOOL gcc_read_user_data_header(wStream* s, UINT16* type, UINT16* length);\nstatic void gcc_write_user_data_header(wStream* s, UINT16 type, UINT16 length);\n\nstatic void gcc_write_client_core_data(wStream* s, rdpMcs* mcs);\nstatic BOOL gcc_read_server_core_data(wStream* s, rdpMcs* mcs);\nstatic BOOL gcc_write_server_core_data(wStream* s, rdpMcs* mcs);\nstatic BOOL gcc_read_client_security_data(wStream* s, rdpMcs* mcs, UINT16 blockLength);\nstatic void gcc_write_client_security_data(wStream* s, rdpMcs* mcs);\nstatic BOOL gcc_read_server_security_data(wStream* s, rdpMcs* mcs);\nstatic BOOL gcc_write_server_security_data(wStream* s, rdpMcs* mcs);\nstatic BOOL gcc_read_client_network_data(wStream* s, rdpMcs* mcs, UINT16 blockLength);\nstatic void gcc_write_client_network_data(wStream* s, rdpMcs* mcs);\nstatic BOOL gcc_read_server_network_data(wStream* s, rdpMcs* mcs);\nstatic BOOL gcc_write_server_network_data(wStream* s, rdpMcs* mcs);\nstatic void gcc_write_client_cluster_data(wStream* s, rdpMcs* mcs);\nstatic BOOL gcc_read_client_monitor_data(wStream* s, rdpMcs* mcs, UINT16 blockLength);\nstatic void gcc_write_client_monitor_data(wStream* s, rdpMcs* mcs);\nstatic BOOL gcc_read_client_monitor_extended_data(wStream* s, rdpMcs* mcs, UINT16 blockLength);\nstatic void gcc_write_client_monitor_extended_data(wStream* s, rdpMcs* mcs);\nstatic BOOL gcc_read_client_message_channel_data(wStream* s, rdpMcs* mcs, UINT16 blockLength);\nstatic void gcc_write_client_message_channel_data(wStream* s, rdpMcs* mcs);\nstatic BOOL gcc_read_server_message_channel_data(wStream* s, rdpMcs* mcs);\nstatic BOOL gcc_write_server_message_channel_data(wStream* s, rdpMcs* mcs);\nstatic BOOL gcc_read_client_multitransport_channel_data(wStream* s, rdpMcs* mcs,\n                                                        UINT16 blockLength);\nstatic void gcc_write_client_multitransport_channel_data(wStream* s, rdpMcs* mcs);\nstatic BOOL gcc_read_server_multitransport_channel_data(wStream* s, rdpMcs* mcs);\nstatic void gcc_write_server_multitransport_channel_data(wStream* s, rdpMcs* mcs);\n\nstatic DWORD rdp_version_common(DWORD serverVersion, DWORD clientVersion)\n{\n\tDWORD version = MIN(serverVersion, clientVersion);\n\n\tswitch (version)\n\t{\n\t\tcase RDP_VERSION_4:\n\t\tcase RDP_VERSION_5_PLUS:\n\t\tcase RDP_VERSION_10_0:\n\t\tcase RDP_VERSION_10_1:\n\t\tcase RDP_VERSION_10_2:\n\t\tcase RDP_VERSION_10_3:\n\t\tcase RDP_VERSION_10_4:\n\t\tcase RDP_VERSION_10_5:\n\t\tcase RDP_VERSION_10_6:\n\t\tcase RDP_VERSION_10_7:\n\t\t\treturn version;\n\n\t\tdefault:\n\t\t\tWLog_ERR(TAG, \"Invalid client [%\" PRId32 \"] and server [%\" PRId32 \"] versions\",\n\t\t\t         serverVersion, clientVersion);\n\t\t\treturn version;\n\t}\n}\n\n/**\n * T.124 GCC is defined in:\n *\n * http://www.itu.int/rec/T-REC-T.124-199802-S/en\n * ITU-T T.124 (02/98): Generic Conference Control\n */\n\n/**\n * ConnectData ::= SEQUENCE\n * {\n * \tt124Identifier\tKey,\n * \tconnectPDU\tOCTET_STRING\n * }\n *\n * Key ::= CHOICE\n * {\n * \tobject\t\t\t\tOBJECT_IDENTIFIER,\n * \th221NonStandard\t\t\tH221NonStandardIdentifier\n * }\n *\n * ConnectGCCPDU ::= CHOICE\n * {\n * \tconferenceCreateRequest\t\tConferenceCreateRequest,\n * \tconferenceCreateResponse\tConferenceCreateResponse,\n * \tconferenceQueryRequest\t\tConferenceQueryRequest,\n * \tconferenceQueryResponse\t\tConferenceQueryResponse,\n * \tconferenceJoinRequest\t\tConferenceJoinRequest,\n *\tconferenceJoinResponse\t\tConferenceJoinResponse,\n *\tconferenceInviteRequest\t\tConferenceInviteRequest,\n *\tconferenceInviteResponse\tConferenceInviteResponse,\n *\t...\n * }\n *\n * ConferenceCreateRequest ::= SEQUENCE\n * {\n * \tconferenceName\t\t\tConferenceName,\n * \tconvenerPassword\t\tPassword OPTIONAL,\n * \tpassword\t\t\tPassword OPTIONAL,\n * \tlockedConference\t\tBOOLEAN,\n * \tlistedConference\t\tBOOLEAN,\n * \tconductibleConference\t\tBOOLEAN,\n * \tterminationMethod\t\tTerminationMethod,\n * \tconductorPrivileges\t\tSET OF Privilege OPTIONAL,\n * \tconductedPrivileges\t\tSET OF Privilege OPTIONAL,\n * \tnonConductedPrivileges\t\tSET OF Privilege OPTIONAL,\n * \tconferenceDescription\t\tTextString OPTIONAL,\n * \tcallerIdentifier\t\tTextString OPTIONAL,\n * \tuserData\t\t\tUserData OPTIONAL,\n * \t...,\n * \tconferencePriority\t\tConferencePriority OPTIONAL,\n * \tconferenceMode\t\t\tConferenceMode OPTIONAL\n * }\n *\n * ConferenceCreateResponse ::= SEQUENCE\n * {\n * \tnodeID\t\t\t\tUserID,\n * \ttag\t\t\t\tINTEGER,\n * \tresult\t\t\t\tENUMERATED\n * \t{\n * \t\tsuccess\t\t\t\t(0),\n * \t\tuserRejected\t\t\t(1),\n * \t\tresourcesNotAvailable\t\t(2),\n * \t\trejectedForSymmetryBreaking\t(3),\n * \t\tlockedConferenceNotSupported\t(4)\n * \t},\n * \tuserData\t\t\tUserData OPTIONAL,\n * \t...\n * }\n *\n * ConferenceName ::= SEQUENCE\n * {\n * \tnumeric\t\t\t\tSimpleNumericString\n * \ttext\t\t\t\tSimpleTextString OPTIONAL,\n * \t...\n * }\n *\n * SimpleNumericString ::= NumericString (SIZE (1..255)) (FROM (\"0123456789\"))\n *\n * UserData ::= SET OF SEQUENCE\n * {\n * \tkey\t\t\t\tKey,\n * \tvalue\t\t\t\tOCTET_STRING OPTIONAL\n * }\n *\n * H221NonStandardIdentifier ::= OCTET STRING (SIZE (4..255))\n *\n * UserID ::= DynamicChannelID\n *\n * ChannelID ::= INTEGER (1..65535)\n * StaticChannelID ::= INTEGER (1..1000)\n * DynamicChannelID ::= INTEGER (1001..65535)\n *\n */\n\n/*\n * OID = 0.0.20.124.0.1\n * { itu-t(0) recommendation(0) t(20) t124(124) version(0) 1 }\n * v.1 of ITU-T Recommendation T.124 (Feb 1998): \"Generic Conference Control\"\n */\nBYTE t124_02_98_oid[6] = { 0, 0, 20, 124, 0, 1 };\n\nBYTE h221_cs_key[4] = \"Duca\";\nBYTE h221_sc_key[4] = \"McDn\";\n\n/**\n * Read a GCC Conference Create Request.\\n\n * @msdn{cc240836}\n * @param s stream\n * @param settings rdp settings\n */\n\nBOOL gcc_read_conference_create_request(wStream* s, rdpMcs* mcs)\n{\n\tUINT16 length;\n\tBYTE choice;\n\tBYTE number;\n\tBYTE selection;\n\n\t/* ConnectData */\n\tif (!per_read_choice(s, &choice))\n\t\treturn FALSE;\n\n\tif (!per_read_object_identifier(s, t124_02_98_oid))\n\t\treturn FALSE;\n\n\t/* ConnectData::connectPDU (OCTET_STRING) */\n\tif (!per_read_length(s, &length))\n\t\treturn FALSE;\n\n\t/* ConnectGCCPDU */\n\tif (!per_read_choice(s, &choice))\n\t\treturn FALSE;\n\n\tif (!per_read_selection(s, &selection))\n\t\treturn FALSE;\n\n\t/* ConferenceCreateRequest::conferenceName */\n\tif (!per_read_numeric_string(s, 1)) /* ConferenceName::numeric */\n\t\treturn FALSE;\n\n\tif (!per_read_padding(s, 1)) /* padding */\n\t\treturn FALSE;\n\n\t/* UserData (SET OF SEQUENCE) */\n\tif (!per_read_number_of_sets(s, &number) || number != 1) /* one set of UserData */\n\t\treturn FALSE;\n\n\tif (!per_read_choice(s, &choice) ||\n\t    choice != 0xC0) /* UserData::value present + select h221NonStandard (1) */\n\t\treturn FALSE;\n\n\t/* h221NonStandard */\n\tif (!per_read_octet_string(s, h221_cs_key, 4,\n\t                           4)) /* h221NonStandard, client-to-server H.221 key, \"Duca\" */\n\t\treturn FALSE;\n\n\t/* userData::value (OCTET_STRING) */\n\tif (!per_read_length(s, &length))\n\t\treturn FALSE;\n\n\tif (Stream_GetRemainingLength(s) < length)\n\t\treturn FALSE;\n\n\tif (!gcc_read_client_data_blocks(s, mcs, length))\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\n/**\n * Write a GCC Conference Create Request.\\n\n * @msdn{cc240836}\n * @param s stream\n * @param user_data client data blocks\n */\n\nvoid gcc_write_conference_create_request(wStream* s, wStream* userData)\n{\n\t/* ConnectData */\n\tper_write_choice(s, 0); /* From Key select object (0) of type OBJECT_IDENTIFIER */\n\tper_write_object_identifier(s, t124_02_98_oid); /* ITU-T T.124 (02/98) OBJECT_IDENTIFIER */\n\t/* ConnectData::connectPDU (OCTET_STRING) */\n\tper_write_length(s, Stream_GetPosition(userData) + 14); /* connectPDU length */\n\t/* ConnectGCCPDU */\n\tper_write_choice(s, 0);       /* From ConnectGCCPDU select conferenceCreateRequest (0) of type\n\t                                 ConferenceCreateRequest */\n\tper_write_selection(s, 0x08); /* select optional userData from ConferenceCreateRequest */\n\t/* ConferenceCreateRequest::conferenceName */\n\tper_write_numeric_string(s, (BYTE*)\"1\", 1, 1); /* ConferenceName::numeric */\n\tper_write_padding(s, 1);                       /* padding */\n\t/* UserData (SET OF SEQUENCE) */\n\tper_write_number_of_sets(s, 1); /* one set of UserData */\n\tper_write_choice(s, 0xC0);      /* UserData::value present + select h221NonStandard (1) */\n\t/* h221NonStandard */\n\tper_write_octet_string(s, h221_cs_key, 4,\n\t                       4); /* h221NonStandard, client-to-server H.221 key, \"Duca\" */\n\t/* userData::value (OCTET_STRING) */\n\tper_write_octet_string(s, Stream_Buffer(userData), Stream_GetPosition(userData),\n\t                       0); /* array of client data blocks */\n}\n\nBOOL gcc_read_conference_create_response(wStream* s, rdpMcs* mcs)\n{\n\tUINT16 length;\n\tUINT32 tag;\n\tUINT16 nodeID;\n\tBYTE result;\n\tBYTE choice;\n\tBYTE number;\n\n\t/* ConnectData */\n\tif (!per_read_choice(s, &choice) || !per_read_object_identifier(s, t124_02_98_oid))\n\t\treturn FALSE;\n\n\t/* ConnectData::connectPDU (OCTET_STRING) */\n\tif (!per_read_length(s, &length))\n\t\treturn FALSE;\n\n\t/* ConnectGCCPDU */\n\tif (!per_read_choice(s, &choice))\n\t\treturn FALSE;\n\n\t/* ConferenceCreateResponse::nodeID (UserID) */\n\tif (!per_read_integer16(s, &nodeID, 1001))\n\t\treturn FALSE;\n\n\t/* ConferenceCreateResponse::tag (INTEGER) */\n\tif (!per_read_integer(s, &tag))\n\t\treturn FALSE;\n\n\t/* ConferenceCreateResponse::result (ENUMERATED) */\n\tif (!per_read_enumerated(s, &result, MCS_Result_enum_length))\n\t\treturn FALSE;\n\n\t/* number of UserData sets */\n\tif (!per_read_number_of_sets(s, &number))\n\t\treturn FALSE;\n\n\t/* UserData::value present + select h221NonStandard (1) */\n\tif (!per_read_choice(s, &choice))\n\t\treturn FALSE;\n\n\t/* h221NonStandard */\n\tif (!per_read_octet_string(s, h221_sc_key, 4,\n\t                           4)) /* h221NonStandard, server-to-client H.221 key, \"McDn\" */\n\t\treturn FALSE;\n\n\t/* userData (OCTET_STRING) */\n\tif (!per_read_length(s, &length))\n\t\treturn FALSE;\n\n\tif (!gcc_read_server_data_blocks(s, mcs, length))\n\t{\n\t\tWLog_ERR(TAG, \"gcc_read_conference_create_response: gcc_read_server_data_blocks failed\");\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nvoid gcc_write_conference_create_response(wStream* s, wStream* userData)\n{\n\t/* ConnectData */\n\tper_write_choice(s, 0);\n\tper_write_object_identifier(s, t124_02_98_oid);\n\t/* ConnectData::connectPDU (OCTET_STRING) */\n\t/* This length MUST be ignored by the client according to [MS-RDPBCGR] */\n\tper_write_length(s, 0x2A);\n\t/* ConnectGCCPDU */\n\tper_write_choice(s, 0x14);\n\t/* ConferenceCreateResponse::nodeID (UserID) */\n\tper_write_integer16(s, 0x79F3, 1001);\n\t/* ConferenceCreateResponse::tag (INTEGER) */\n\tper_write_integer(s, 1);\n\t/* ConferenceCreateResponse::result (ENUMERATED) */\n\tper_write_enumerated(s, 0, MCS_Result_enum_length);\n\t/* number of UserData sets */\n\tper_write_number_of_sets(s, 1);\n\t/* UserData::value present + select h221NonStandard (1) */\n\tper_write_choice(s, 0xC0);\n\t/* h221NonStandard */\n\tper_write_octet_string(s, h221_sc_key, 4,\n\t                       4); /* h221NonStandard, server-to-client H.221 key, \"McDn\" */\n\t/* userData (OCTET_STRING) */\n\tper_write_octet_string(s, Stream_Buffer(userData), Stream_GetPosition(userData),\n\t                       0); /* array of server data blocks */\n}\n\nBOOL gcc_read_client_data_blocks(wStream* s, rdpMcs* mcs, int length)\n{\n\tUINT16 type;\n\tUINT16 blockLength;\n\tsize_t begPos, endPos;\n\n\twhile (length > 0)\n\t{\n\t\tbegPos = Stream_GetPosition(s);\n\n\t\tif (!gcc_read_user_data_header(s, &type, &blockLength))\n\t\t\treturn FALSE;\n\n\t\tif (Stream_GetRemainingLength(s) < (size_t)(blockLength - 4))\n\t\t\treturn FALSE;\n\n\t\tswitch (type)\n\t\t{\n\t\t\tcase CS_CORE:\n\t\t\t\tif (!gcc_read_client_core_data(s, mcs, blockLength - 4))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CS_SECURITY:\n\t\t\t\tif (!gcc_read_client_security_data(s, mcs, blockLength - 4))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CS_NET:\n\t\t\t\tif (!gcc_read_client_network_data(s, mcs, blockLength - 4))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CS_CLUSTER:\n\t\t\t\tif (!gcc_read_client_cluster_data(s, mcs, blockLength - 4))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CS_MONITOR:\n\t\t\t\tif (!gcc_read_client_monitor_data(s, mcs, blockLength - 4))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CS_MCS_MSGCHANNEL:\n\t\t\t\tif (!gcc_read_client_message_channel_data(s, mcs, blockLength - 4))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase CS_MONITOR_EX:\n\t\t\t\tif (!gcc_read_client_monitor_extended_data(s, mcs, blockLength - 4))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase 0xC009:\n\t\t\tcase CS_MULTITRANSPORT:\n\t\t\t\tif (!gcc_read_client_multitransport_channel_data(s, mcs, blockLength - 4))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tWLog_ERR(TAG, \"Unknown GCC client data block: 0x%04\" PRIX16 \"\", type);\n\t\t\t\tStream_Seek(s, blockLength - 4);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tendPos = Stream_GetPosition(s);\n\n\t\tif (endPos != (begPos + blockLength))\n\t\t{\n\t\t\tWLog_ERR(TAG,\n\t\t\t         \"Error parsing GCC client data block 0x%04\" PRIX16\n\t\t\t         \": Actual Offset: %d Expected Offset: %d\",\n\t\t\t         type, endPos, begPos + blockLength);\n\t\t}\n\n\t\tlength -= blockLength;\n\t\tStream_SetPosition(s, begPos + blockLength);\n\t}\n\n\treturn TRUE;\n}\n\nvoid gcc_write_client_data_blocks(wStream* s, rdpMcs* mcs)\n{\n\trdpSettings* settings = mcs->settings;\n\tgcc_write_client_core_data(s, mcs);\n\tgcc_write_client_cluster_data(s, mcs);\n\tgcc_write_client_security_data(s, mcs);\n\tgcc_write_client_network_data(s, mcs);\n\n\t/* extended client data supported */\n\n\tif (settings->NegotiationFlags & EXTENDED_CLIENT_DATA_SUPPORTED)\n\t{\n\t\tif (settings->UseMultimon && !settings->SpanMonitors)\n\t\t{\n\t\t\tgcc_write_client_monitor_data(s, mcs);\n\t\t\tgcc_write_client_monitor_extended_data(s, mcs);\n\t\t}\n\n\t\tgcc_write_client_message_channel_data(s, mcs);\n\t\tgcc_write_client_multitransport_channel_data(s, mcs);\n\t}\n\telse\n\t{\n\t\tif (settings->UseMultimon && !settings->SpanMonitors)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"WARNING: true multi monitor support was not advertised by server!\");\n\n\t\t\tif (settings->ForceMultimon)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Sending multi monitor information anyway (may break connectivity!)\");\n\t\t\t\tgcc_write_client_monitor_data(s, mcs);\n\t\t\t\tgcc_write_client_monitor_extended_data(s, mcs);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Use /multimon:force to force sending multi monitor information\");\n\t\t\t}\n\t\t}\n\t}\n}\n\nBOOL gcc_read_server_data_blocks(wStream* s, rdpMcs* mcs, int length)\n{\n\tUINT16 type;\n\tUINT16 offset = 0;\n\tUINT16 blockLength;\n\tBYTE* holdp;\n\n\twhile (offset < length)\n\t{\n\t\tsize_t rest;\n\t\twStream sub;\n\n\t\tif (!gcc_read_user_data_header(s, &type, &blockLength))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"gcc_read_server_data_blocks: gcc_read_user_data_header failed\");\n\t\t\treturn FALSE;\n\t\t}\n\t\tholdp = Stream_Pointer(s);\n\t\tStream_StaticInit(&sub, holdp, blockLength - 4);\n\t\tif (!Stream_SafeSeek(s, blockLength - 4))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"gcc_read_server_data_blocks: stream too short\");\n\t\t\treturn FALSE;\n\t\t}\n\t\toffset += blockLength;\n\n\t\tswitch (type)\n\t\t{\n\t\t\tcase SC_CORE:\n\t\t\t\tif (!gcc_read_server_core_data(&sub, mcs))\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG, \"gcc_read_server_data_blocks: gcc_read_server_core_data failed\");\n\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase SC_SECURITY:\n\t\t\t\tif (!gcc_read_server_security_data(&sub, mcs))\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG,\n\t\t\t\t\t         \"gcc_read_server_data_blocks: gcc_read_server_security_data failed\");\n\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase SC_NET:\n\t\t\t\tif (!gcc_read_server_network_data(&sub, mcs))\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG,\n\t\t\t\t\t         \"gcc_read_server_data_blocks: gcc_read_server_network_data failed\");\n\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase SC_MCS_MSGCHANNEL:\n\t\t\t\tif (!gcc_read_server_message_channel_data(&sub, mcs))\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(\n\t\t\t\t\t    TAG,\n\t\t\t\t\t    \"gcc_read_server_data_blocks: gcc_read_server_message_channel_data failed\");\n\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase SC_MULTITRANSPORT:\n\t\t\t\tif (!gcc_read_server_multitransport_channel_data(&sub, mcs))\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG, \"gcc_read_server_data_blocks: \"\n\t\t\t\t\t              \"gcc_read_server_multitransport_channel_data failed\");\n\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tWLog_ERR(TAG, \"gcc_read_server_data_blocks: ignoring type=%\" PRIu16 \"\", type);\n\t\t\t\tbreak;\n\t\t}\n\n\t\trest = Stream_GetRemainingLength(&sub);\n\t\tif (rest > 0)\n\t\t{\n\t\t\tWLog_WARN(\n\t\t\t    TAG, \"gcc_read_server_data_blocks: ignoring %\" PRIuz \" bytes with type=%\" PRIu16 \"\",\n\t\t\t    rest, type);\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\nBOOL gcc_write_server_data_blocks(wStream* s, rdpMcs* mcs)\n{\n\treturn gcc_write_server_core_data(s, mcs) &&          /* serverCoreData */\n\t       gcc_write_server_network_data(s, mcs) &&       /* serverNetworkData */\n\t       gcc_write_server_security_data(s, mcs) &&      /* serverSecurityData */\n\t       gcc_write_server_message_channel_data(s, mcs); /* serverMessageChannelData */\n\t/* TODO: Send these GCC data blocks only when the client sent them */\n\t// gcc_write_server_multitransport_channel_data(s, settings); /* serverMultitransportChannelData\n\t// */\n}\n\nBOOL gcc_read_user_data_header(wStream* s, UINT16* type, UINT16* length)\n{\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, *type);   /* type */\n\tStream_Read_UINT16(s, *length); /* length */\n\n\tif ((*length < 4) || (Stream_GetRemainingLength(s) < (size_t)(*length - 4)))\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\n/**\n * Write a user data header (TS_UD_HEADER).\\n\n * @msdn{cc240509}\n * @param s stream\n * @param type data block type\n * @param length data block length\n */\n\nvoid gcc_write_user_data_header(wStream* s, UINT16 type, UINT16 length)\n{\n\tStream_Write_UINT16(s, type);   /* type */\n\tStream_Write_UINT16(s, length); /* length */\n}\n\n/**\n * Read a client core data block (TS_UD_CS_CORE).\\n\n * @msdn{cc240510}\n * @param s stream\n * @param settings rdp settings\n */\n\nBOOL gcc_read_client_core_data(wStream* s, rdpMcs* mcs, UINT16 blockLength)\n{\n\tchar* str = NULL;\n\tUINT32 version;\n\tBYTE connectionType = 0;\n\tUINT32 clientColorDepth;\n\tUINT16 colorDepth = 0;\n\tUINT16 postBeta2ColorDepth = 0;\n\tUINT16 highColorDepth = 0;\n\tUINT16 supportedColorDepths = 0;\n\tUINT32 serverSelectedProtocol = 0;\n\tUINT16 earlyCapabilityFlags = 0;\n\trdpSettings* settings = mcs->settings;\n\n\t/* Length of all required fields, until imeFileName */\n\tif (blockLength < 128)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, version); /* version (4 bytes) */\n\tsettings->RdpVersion = rdp_version_common(version, settings->RdpVersion);\n\tStream_Read_UINT16(s, settings->DesktopWidth);  /* DesktopWidth (2 bytes) */\n\tStream_Read_UINT16(s, settings->DesktopHeight); /* DesktopHeight (2 bytes) */\n\tStream_Read_UINT16(s, colorDepth);              /* ColorDepth (2 bytes) */\n\tStream_Seek_UINT16(s); /* SASSequence (Secure Access Sequence) (2 bytes) */\n\tStream_Read_UINT32(s, settings->KeyboardLayout); /* KeyboardLayout (4 bytes) */\n\tStream_Read_UINT32(s, settings->ClientBuild);    /* ClientBuild (4 bytes) */\n\n\t/* clientName (32 bytes, null-terminated unicode, truncated to 15 characters) */\n\tif (ConvertFromUnicode(CP_UTF8, 0, (WCHAR*)Stream_Pointer(s), 32 / 2, &str, 0, NULL, NULL) < 1)\n\t{\n\t\tWLog_ERR(TAG, \"failed to convert client host name\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Seek(s, 32);\n\tfree(settings->ClientHostname);\n\tsettings->ClientHostname = str;\n\tstr = NULL;\n\tStream_Read_UINT32(s, settings->KeyboardType);        /* KeyboardType (4 bytes) */\n\tStream_Read_UINT32(s, settings->KeyboardSubType);     /* KeyboardSubType (4 bytes) */\n\tStream_Read_UINT32(s, settings->KeyboardFunctionKey); /* KeyboardFunctionKey (4 bytes) */\n\tStream_Seek(s, 64);                                   /* imeFileName (64 bytes) */\n\tblockLength -= 128;\n\n\t/**\n\t * The following fields are all optional. If one field is present, all of the preceding\n\t * fields MUST also be present. If one field is not present, all of the subsequent fields\n\t * MUST NOT be present.\n\t * We must check the bytes left before reading each field.\n\t */\n\n\tdo\n\t{\n\t\tif (blockLength < 2)\n\t\t\tbreak;\n\n\t\tStream_Read_UINT16(s, postBeta2ColorDepth); /* postBeta2ColorDepth (2 bytes) */\n\t\tblockLength -= 2;\n\n\t\tif (blockLength < 2)\n\t\t\tbreak;\n\n\t\tStream_Seek_UINT16(s); /* clientProductID (2 bytes) */\n\t\tblockLength -= 2;\n\n\t\tif (blockLength < 4)\n\t\t\tbreak;\n\n\t\tStream_Seek_UINT32(s); /* serialNumber (4 bytes) */\n\t\tblockLength -= 4;\n\n\t\tif (blockLength < 2)\n\t\t\tbreak;\n\n\t\tStream_Read_UINT16(s, highColorDepth); /* highColorDepth (2 bytes) */\n\t\tblockLength -= 2;\n\n\t\tif (blockLength < 2)\n\t\t\tbreak;\n\n\t\tStream_Read_UINT16(s, supportedColorDepths); /* supportedColorDepths (2 bytes) */\n\t\tblockLength -= 2;\n\n\t\tif (blockLength < 2)\n\t\t\tbreak;\n\n\t\tStream_Read_UINT16(s, earlyCapabilityFlags); /* earlyCapabilityFlags (2 bytes) */\n\t\tsettings->EarlyCapabilityFlags = (UINT32)earlyCapabilityFlags;\n\t\tblockLength -= 2;\n\n\t\t/* clientDigProductId (64 bytes): Contains a value that uniquely identifies the client */\n\n\t\tif (blockLength < 64)\n\t\t\tbreak;\n\n\t\tif (ConvertFromUnicode(CP_UTF8, 0, (WCHAR*)Stream_Pointer(s), 64 / 2, &str, 0, NULL, NULL) <\n\t\t    1)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"failed to convert the client product identifier\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tStream_Seek(s, 64); /* clientDigProductId (64 bytes) */\n\t\tfree(settings->ClientProductId);\n\t\tsettings->ClientProductId = str;\n\t\tblockLength -= 64;\n\n\t\tif (blockLength < 1)\n\t\t\tbreak;\n\n\t\tStream_Read_UINT8(s, connectionType); /* connectionType (1 byte) */\n\t\tblockLength -= 1;\n\n\t\tif (blockLength < 1)\n\t\t\tbreak;\n\n\t\tStream_Seek_UINT8(s); /* pad1octet (1 byte) */\n\t\tblockLength -= 1;\n\n\t\tif (blockLength < 4)\n\t\t\tbreak;\n\n\t\tStream_Read_UINT32(s, serverSelectedProtocol); /* serverSelectedProtocol (4 bytes) */\n\t\tblockLength -= 4;\n\n\t\tif (blockLength < 4)\n\t\t\tbreak;\n\n\t\tStream_Read_UINT32(s, settings->DesktopPhysicalWidth); /* desktopPhysicalWidth (4 bytes) */\n\t\tblockLength -= 4;\n\n\t\tif (blockLength < 4)\n\t\t\tbreak;\n\n\t\tStream_Read_UINT32(s,\n\t\t                   settings->DesktopPhysicalHeight); /* desktopPhysicalHeight (4 bytes) */\n\t\tblockLength -= 4;\n\n\t\tif (blockLength < 2)\n\t\t\tbreak;\n\n\t\tStream_Read_UINT16(s, settings->DesktopOrientation); /* desktopOrientation (2 bytes) */\n\t\tblockLength -= 2;\n\n\t\tif (blockLength < 4)\n\t\t\tbreak;\n\n\t\tStream_Read_UINT32(s, settings->DesktopScaleFactor); /* desktopScaleFactor (4 bytes) */\n\t\tblockLength -= 4;\n\n\t\tif (blockLength < 4)\n\t\t\tbreak;\n\n\t\tStream_Read_UINT32(s, settings->DeviceScaleFactor); /* deviceScaleFactor (4 bytes) */\n\n\t\tif (settings->SelectedProtocol != serverSelectedProtocol)\n\t\t\treturn FALSE;\n\t} while (0);\n\n\tif (highColorDepth > 0)\n\t{\n\t\tif (earlyCapabilityFlags & RNS_UD_CS_WANT_32BPP_SESSION)\n\t\t\tclientColorDepth = 32;\n\t\telse\n\t\t\tclientColorDepth = highColorDepth;\n\t}\n\telse if (postBeta2ColorDepth > 0)\n\t{\n\t\tswitch (postBeta2ColorDepth)\n\t\t{\n\t\t\tcase RNS_UD_COLOR_4BPP:\n\t\t\t\tclientColorDepth = 4;\n\t\t\t\tbreak;\n\n\t\t\tcase RNS_UD_COLOR_8BPP:\n\t\t\t\tclientColorDepth = 8;\n\t\t\t\tbreak;\n\n\t\t\tcase RNS_UD_COLOR_16BPP_555:\n\t\t\t\tclientColorDepth = 15;\n\t\t\t\tbreak;\n\n\t\t\tcase RNS_UD_COLOR_16BPP_565:\n\t\t\t\tclientColorDepth = 16;\n\t\t\t\tbreak;\n\n\t\t\tcase RNS_UD_COLOR_24BPP:\n\t\t\t\tclientColorDepth = 24;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tswitch (colorDepth)\n\t\t{\n\t\t\tcase RNS_UD_COLOR_4BPP:\n\t\t\t\tclientColorDepth = 4;\n\t\t\t\tbreak;\n\n\t\t\tcase RNS_UD_COLOR_8BPP:\n\t\t\t\tclientColorDepth = 8;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\t/*\n\t * If we are in server mode, accept client's color depth only if\n\t * it is smaller than ours. This is what Windows server does.\n\t */\n\tif ((clientColorDepth < settings->ColorDepth) || !settings->ServerMode)\n\t\tsettings->ColorDepth = clientColorDepth;\n\n\tif (settings->NetworkAutoDetect)\n\t\tsettings->NetworkAutoDetect =\n\t\t    (earlyCapabilityFlags & RNS_UD_CS_SUPPORT_NETWORK_AUTODETECT) ? TRUE : FALSE;\n\n\tif (settings->SupportHeartbeatPdu)\n\t\tsettings->SupportHeartbeatPdu =\n\t\t    (earlyCapabilityFlags & RNS_UD_CS_SUPPORT_HEARTBEAT_PDU) ? TRUE : FALSE;\n\n\tif (settings->SupportGraphicsPipeline)\n\t\tsettings->SupportGraphicsPipeline =\n\t\t    (earlyCapabilityFlags & RNS_UD_CS_SUPPORT_DYNVC_GFX_PROTOCOL) ? TRUE : FALSE;\n\n\tif (settings->SupportDynamicTimeZone)\n\t\tsettings->SupportDynamicTimeZone =\n\t\t    (earlyCapabilityFlags & RNS_UD_CS_SUPPORT_DYNAMIC_TIME_ZONE) ? TRUE : FALSE;\n\n\tif (settings->SupportMonitorLayoutPdu)\n\t\tsettings->SupportMonitorLayoutPdu =\n\t\t    (earlyCapabilityFlags & RNS_UD_CS_SUPPORT_MONITOR_LAYOUT_PDU) ? TRUE : FALSE;\n\n\tif (settings->SupportStatusInfoPdu)\n\t\tsettings->SupportStatusInfoPdu =\n\t\t    (earlyCapabilityFlags & RNS_UD_CS_SUPPORT_STATUSINFO_PDU) ? TRUE : FALSE;\n\n\tif (!(earlyCapabilityFlags & RNS_UD_CS_VALID_CONNECTION_TYPE))\n\t\tconnectionType = 0;\n\n\tsettings->SupportErrorInfoPdu = earlyCapabilityFlags & RNS_UD_CS_SUPPORT_ERRINFO_PDU;\n\tsettings->ConnectionType = connectionType;\n\treturn TRUE;\n}\n\n/**\n * Write a client core data block (TS_UD_CS_CORE).\\n\n * @msdn{cc240510}\n * @param s stream\n * @param settings rdp settings\n */\n\nvoid gcc_write_client_core_data(wStream* s, rdpMcs* mcs)\n{\n\tWCHAR* clientName = NULL;\n\tint clientNameLength;\n\tBYTE connectionType;\n\tUINT16 highColorDepth;\n\tUINT16 supportedColorDepths;\n\tUINT16 earlyCapabilityFlags;\n\tWCHAR* clientDigProductId = NULL;\n\tint clientDigProductIdLength;\n\trdpSettings* settings = mcs->settings;\n\tgcc_write_user_data_header(s, CS_CORE, 234);\n\tclientNameLength = ConvertToUnicode(CP_UTF8, 0, settings->ClientHostname, -1, &clientName, 0);\n\tclientDigProductIdLength =\n\t    ConvertToUnicode(CP_UTF8, 0, settings->ClientProductId, -1, &clientDigProductId, 0);\n\tStream_Write_UINT32(s, settings->RdpVersion);    /* Version */\n\tStream_Write_UINT16(s, settings->DesktopWidth);  /* DesktopWidth */\n\tStream_Write_UINT16(s, settings->DesktopHeight); /* DesktopHeight */\n\tStream_Write_UINT16(s,\n\t                    RNS_UD_COLOR_8BPP); /* ColorDepth, ignored because of postBeta2ColorDepth */\n\tStream_Write_UINT16(s, RNS_UD_SAS_DEL); /* SASSequence (Secure Access Sequence) */\n\tStream_Write_UINT32(s, settings->KeyboardLayout); /* KeyboardLayout */\n\tStream_Write_UINT32(s, settings->ClientBuild);    /* ClientBuild */\n\n\t/* clientName (32 bytes, null-terminated unicode, truncated to 15 characters) */\n\n\tif (clientNameLength >= 16)\n\t{\n\t\tclientNameLength = 16;\n\t\tclientName[clientNameLength - 1] = 0;\n\t}\n\n\tStream_Write(s, clientName, (clientNameLength * 2));\n\tStream_Zero(s, 32 - (clientNameLength * 2));\n\tfree(clientName);\n\tStream_Write_UINT32(s, settings->KeyboardType);        /* KeyboardType */\n\tStream_Write_UINT32(s, settings->KeyboardSubType);     /* KeyboardSubType */\n\tStream_Write_UINT32(s, settings->KeyboardFunctionKey); /* KeyboardFunctionKey */\n\tStream_Zero(s, 64);                                    /* imeFileName */\n\tStream_Write_UINT16(s, RNS_UD_COLOR_8BPP);             /* postBeta2ColorDepth */\n\tStream_Write_UINT16(s, 1);                             /* clientProductID */\n\tStream_Write_UINT32(s, 0); /* serialNumber (should be initialized to 0) */\n\thighColorDepth = MIN(settings->ColorDepth, 24);\n\tsupportedColorDepths = RNS_UD_24BPP_SUPPORT | RNS_UD_16BPP_SUPPORT | RNS_UD_15BPP_SUPPORT;\n\tearlyCapabilityFlags = RNS_UD_CS_SUPPORT_ERRINFO_PDU;\n\n\tif (settings->NetworkAutoDetect)\n\t\tsettings->ConnectionType = CONNECTION_TYPE_AUTODETECT;\n\n\tif (settings->RemoteFxCodec && !settings->NetworkAutoDetect)\n\t\tsettings->ConnectionType = CONNECTION_TYPE_LAN;\n\n\tconnectionType = settings->ConnectionType;\n\n\tif (connectionType)\n\t\tearlyCapabilityFlags |= RNS_UD_CS_VALID_CONNECTION_TYPE;\n\n\tif (settings->ColorDepth == 32)\n\t{\n\t\tsupportedColorDepths |= RNS_UD_32BPP_SUPPORT;\n\t\tearlyCapabilityFlags |= RNS_UD_CS_WANT_32BPP_SESSION;\n\t}\n\n\tif (settings->NetworkAutoDetect)\n\t\tearlyCapabilityFlags |= RNS_UD_CS_SUPPORT_NETWORK_AUTODETECT;\n\n\tif (settings->SupportHeartbeatPdu)\n\t\tearlyCapabilityFlags |= RNS_UD_CS_SUPPORT_HEARTBEAT_PDU;\n\n\tif (settings->SupportGraphicsPipeline)\n\t\tearlyCapabilityFlags |= RNS_UD_CS_SUPPORT_DYNVC_GFX_PROTOCOL;\n\n\tif (settings->SupportDynamicTimeZone)\n\t\tearlyCapabilityFlags |= RNS_UD_CS_SUPPORT_DYNAMIC_TIME_ZONE;\n\n\tif (settings->SupportMonitorLayoutPdu)\n\t\tearlyCapabilityFlags |= RNS_UD_CS_SUPPORT_MONITOR_LAYOUT_PDU;\n\n\tif (settings->SupportStatusInfoPdu)\n\t\tearlyCapabilityFlags |= RNS_UD_CS_SUPPORT_STATUSINFO_PDU;\n\n\tStream_Write_UINT16(s, highColorDepth);       /* highColorDepth */\n\tStream_Write_UINT16(s, supportedColorDepths); /* supportedColorDepths */\n\tStream_Write_UINT16(s, earlyCapabilityFlags); /* earlyCapabilityFlags */\n\n\t/* clientDigProductId (64 bytes, null-terminated unicode, truncated to 31 characters) */\n\tif (clientDigProductIdLength >= 32)\n\t{\n\t\tclientDigProductIdLength = 32;\n\t\tclientDigProductId[clientDigProductIdLength - 1] = 0;\n\t}\n\n\tStream_Write(s, clientDigProductId, (clientDigProductIdLength * 2));\n\tStream_Zero(s, 64 - (clientDigProductIdLength * 2));\n\tfree(clientDigProductId);\n\tStream_Write_UINT8(s, connectionType);                   /* connectionType */\n\tStream_Write_UINT8(s, 0);                                /* pad1octet */\n\tStream_Write_UINT32(s, settings->SelectedProtocol);      /* serverSelectedProtocol */\n\tStream_Write_UINT32(s, settings->DesktopPhysicalWidth);  /* desktopPhysicalWidth */\n\tStream_Write_UINT32(s, settings->DesktopPhysicalHeight); /* desktopPhysicalHeight */\n\tStream_Write_UINT16(s, settings->DesktopOrientation);    /* desktopOrientation */\n\tStream_Write_UINT32(s, settings->DesktopScaleFactor);    /* desktopScaleFactor */\n\tStream_Write_UINT32(s, settings->DeviceScaleFactor);     /* deviceScaleFactor */\n}\n\nBOOL gcc_read_server_core_data(wStream* s, rdpMcs* mcs)\n{\n\tUINT32 serverVersion;\n\tUINT32 clientRequestedProtocols;\n\tUINT32 earlyCapabilityFlags;\n\trdpSettings* settings = mcs->settings;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, serverVersion); /* version */\n\tsettings->RdpVersion = rdp_version_common(serverVersion, settings->RdpVersion);\n\n\tif (Stream_GetRemainingLength(s) >= 4)\n\t{\n\t\tStream_Read_UINT32(s, clientRequestedProtocols); /* clientRequestedProtocols */\n\t}\n\n\tif (Stream_GetRemainingLength(s) >= 4)\n\t{\n\t\tStream_Read_UINT32(s, earlyCapabilityFlags); /* earlyCapabilityFlags */\n\t}\n\n\treturn TRUE;\n}\n\nBOOL gcc_write_server_core_data(wStream* s, rdpMcs* mcs)\n{\n\tUINT32 earlyCapabilityFlags = 0;\n\trdpSettings* settings = mcs->settings;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 20))\n\t\treturn FALSE;\n\n\tgcc_write_user_data_header(s, SC_CORE, 16);\n\n\tif (settings->SupportDynamicTimeZone)\n\t\tearlyCapabilityFlags |= RNS_UD_SC_DYNAMIC_DST_SUPPORTED;\n\n\tStream_Write_UINT32(s, settings->RdpVersion);         /* version (4 bytes) */\n\tStream_Write_UINT32(s, settings->RequestedProtocols); /* clientRequestedProtocols (4 bytes) */\n\tStream_Write_UINT32(s, earlyCapabilityFlags);         /* earlyCapabilityFlags (4 bytes) */\n\treturn TRUE;\n}\n\n/**\n * Read a client security data block (TS_UD_CS_SEC).\\n\n * @msdn{cc240511}\n * @param s stream\n * @param settings rdp settings\n */\n\nBOOL gcc_read_client_security_data(wStream* s, rdpMcs* mcs, UINT16 blockLength)\n{\n\trdpSettings* settings = mcs->settings;\n\n\tif (blockLength < 8)\n\t\treturn FALSE;\n\n\tif (settings->UseRdpSecurityLayer)\n\t{\n\t\tStream_Read_UINT32(s, settings->EncryptionMethods); /* encryptionMethods */\n\n\t\tif (settings->EncryptionMethods == 0)\n\t\t\tStream_Read_UINT32(s, settings->EncryptionMethods); /* extEncryptionMethods */\n\t\telse\n\t\t\tStream_Seek(s, 4);\n\t}\n\telse\n\t{\n\t\tStream_Seek(s, 8);\n\t}\n\n\treturn TRUE;\n}\n\n/**\n * Write a client security data block (TS_UD_CS_SEC).\\n\n * @msdn{cc240511}\n * @param s stream\n * @param settings rdp settings\n */\n\nvoid gcc_write_client_security_data(wStream* s, rdpMcs* mcs)\n{\n\trdpSettings* settings = mcs->settings;\n\tgcc_write_user_data_header(s, CS_SECURITY, 12);\n\n\tif (settings->UseRdpSecurityLayer)\n\t{\n\t\tStream_Write_UINT32(s, settings->EncryptionMethods); /* encryptionMethods */\n\t\tStream_Write_UINT32(s, 0);                           /* extEncryptionMethods */\n\t}\n\telse\n\t{\n\t\t/* French locale, disable encryption */\n\t\tStream_Write_UINT32(s, 0);                           /* encryptionMethods */\n\t\tStream_Write_UINT32(s, settings->EncryptionMethods); /* extEncryptionMethods */\n\t}\n}\n\nBOOL gcc_read_server_security_data(wStream* s, rdpMcs* mcs)\n{\n\tBYTE* data;\n\tUINT32 length;\n\trdpSettings* settings = mcs->settings;\n\tBOOL validCryptoConfig = FALSE;\n\tUINT32 serverEncryptionMethod;\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, serverEncryptionMethod);    /* encryptionMethod */\n\tStream_Read_UINT32(s, settings->EncryptionLevel); /* encryptionLevel */\n\n\t/* Only accept valid/known encryption methods */\n\tswitch (serverEncryptionMethod)\n\t{\n\t\tcase ENCRYPTION_METHOD_NONE:\n\t\t\tWLog_DBG(TAG, \"Server rdp encryption method: NONE\");\n\t\t\tbreak;\n\n\t\tcase ENCRYPTION_METHOD_40BIT:\n\t\t\tWLog_DBG(TAG, \"Server rdp encryption method: 40BIT\");\n\t\t\tbreak;\n\n\t\tcase ENCRYPTION_METHOD_56BIT:\n\t\t\tWLog_DBG(TAG, \"Server rdp encryption method: 56BIT\");\n\t\t\tbreak;\n\n\t\tcase ENCRYPTION_METHOD_128BIT:\n\t\t\tWLog_DBG(TAG, \"Server rdp encryption method: 128BIT\");\n\t\t\tbreak;\n\n\t\tcase ENCRYPTION_METHOD_FIPS:\n\t\t\tWLog_DBG(TAG, \"Server rdp encryption method: FIPS\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_ERR(TAG, \"Received unknown encryption method %08\" PRIX32 \"\",\n\t\t\t         serverEncryptionMethod);\n\t\t\treturn FALSE;\n\t}\n\n\tif (settings->UseRdpSecurityLayer && !(settings->EncryptionMethods & serverEncryptionMethod))\n\t{\n\t\tWLog_WARN(TAG, \"Server uses non-advertised encryption method 0x%08\" PRIX32 \"\",\n\t\t          serverEncryptionMethod);\n\t\t/* FIXME: Should we return FALSE; in this case ?? */\n\t}\n\n\tsettings->EncryptionMethods = serverEncryptionMethod;\n\n\t/* Verify encryption level/method combinations according to MS-RDPBCGR Section 5.3.2 */\n\tswitch (settings->EncryptionLevel)\n\t{\n\t\tcase ENCRYPTION_LEVEL_NONE:\n\t\t\tif (settings->EncryptionMethods == ENCRYPTION_METHOD_NONE)\n\t\t\t{\n\t\t\t\tvalidCryptoConfig = TRUE;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase ENCRYPTION_LEVEL_FIPS:\n\t\t\tif (settings->EncryptionMethods == ENCRYPTION_METHOD_FIPS)\n\t\t\t{\n\t\t\t\tvalidCryptoConfig = TRUE;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase ENCRYPTION_LEVEL_LOW:\n\t\tcase ENCRYPTION_LEVEL_HIGH:\n\t\tcase ENCRYPTION_LEVEL_CLIENT_COMPATIBLE:\n\t\t\tif (settings->EncryptionMethods == ENCRYPTION_METHOD_40BIT ||\n\t\t\t    settings->EncryptionMethods == ENCRYPTION_METHOD_56BIT ||\n\t\t\t    settings->EncryptionMethods == ENCRYPTION_METHOD_128BIT ||\n\t\t\t    settings->EncryptionMethods == ENCRYPTION_METHOD_FIPS)\n\t\t\t{\n\t\t\t\tvalidCryptoConfig = TRUE;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_ERR(TAG, \"Received unknown encryption level 0x%08\" PRIX32 \"\",\n\t\t\t         settings->EncryptionLevel);\n\t}\n\n\tif (!validCryptoConfig)\n\t{\n\t\tWLog_ERR(TAG,\n\t\t         \"Received invalid cryptographic configuration (level=0x%08\" PRIX32\n\t\t         \" method=0x%08\" PRIX32 \")\",\n\t\t         settings->EncryptionLevel, settings->EncryptionMethods);\n\t\treturn FALSE;\n\t}\n\n\tif (settings->EncryptionLevel == ENCRYPTION_LEVEL_NONE)\n\t{\n\t\t/* serverRandomLen and serverCertLen must not be present */\n\t\tsettings->UseRdpSecurityLayer = FALSE;\n\t\treturn TRUE;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, settings->ServerRandomLength);      /* serverRandomLen */\n\tStream_Read_UINT32(s, settings->ServerCertificateLength); /* serverCertLen */\n\n\tif ((settings->ServerRandomLength == 0) || (settings->ServerCertificateLength == 0))\n\t\treturn FALSE;\n\n\tif (Stream_GetRemainingLength(s) < settings->ServerRandomLength)\n\t\treturn FALSE;\n\n\t/* serverRandom */\n\tsettings->ServerRandom = (BYTE*)malloc(settings->ServerRandomLength);\n\n\tif (!settings->ServerRandom)\n\t\tgoto fail;\n\n\tStream_Read(s, settings->ServerRandom, settings->ServerRandomLength);\n\n\tif (Stream_GetRemainingLength(s) < settings->ServerCertificateLength)\n\t\tgoto fail;\n\n\t/* serverCertificate */\n\tsettings->ServerCertificate = (BYTE*)malloc(settings->ServerCertificateLength);\n\n\tif (!settings->ServerCertificate)\n\t\tgoto fail;\n\n\tStream_Read(s, settings->ServerCertificate, settings->ServerCertificateLength);\n\tcertificate_free(settings->RdpServerCertificate);\n\tsettings->RdpServerCertificate = certificate_new();\n\n\tif (!settings->RdpServerCertificate)\n\t\tgoto fail;\n\n\tdata = settings->ServerCertificate;\n\tlength = settings->ServerCertificateLength;\n\n\tif (!certificate_read_server_certificate(settings->RdpServerCertificate, data, length))\n\t\tgoto fail;\n\n\treturn TRUE;\nfail:\n\tfree(settings->ServerRandom);\n\tfree(settings->ServerCertificate);\n\tsettings->ServerRandom = NULL;\n\tsettings->ServerCertificate = NULL;\n\treturn FALSE;\n}\n\nstatic const BYTE initial_signature[] = {\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01\n};\n\n/*\n * Terminal Services Signing Keys.\n * Yes, Terminal Services Private Key is publicly available.\n */\n\nconst BYTE tssk_modulus[] = { 0x3d, 0x3a, 0x5e, 0xbd, 0x72, 0x43, 0x3e, 0xc9, 0x4d, 0xbb, 0xc1,\n\t                          0x1e, 0x4a, 0xba, 0x5f, 0xcb, 0x3e, 0x88, 0x20, 0x87, 0xef, 0xf5,\n\t                          0xc1, 0xe2, 0xd7, 0xb7, 0x6b, 0x9a, 0xf2, 0x52, 0x45, 0x95, 0xce,\n\t                          0x63, 0x65, 0x6b, 0x58, 0x3a, 0xfe, 0xef, 0x7c, 0xe7, 0xbf, 0xfe,\n\t                          0x3d, 0xf6, 0x5c, 0x7d, 0x6c, 0x5e, 0x06, 0x09, 0x1a, 0xf5, 0x61,\n\t                          0xbb, 0x20, 0x93, 0x09, 0x5f, 0x05, 0x6d, 0xea, 0x87 };\n\nconst BYTE tssk_privateExponent[] = {\n\t0x87, 0xa7, 0x19, 0x32, 0xda, 0x11, 0x87, 0x55, 0x58, 0x00, 0x16, 0x16, 0x25, 0x65, 0x68, 0xf8,\n\t0x24, 0x3e, 0xe6, 0xfa, 0xe9, 0x67, 0x49, 0x94, 0xcf, 0x92, 0xcc, 0x33, 0x99, 0xe8, 0x08, 0x60,\n\t0x17, 0x9a, 0x12, 0x9f, 0x24, 0xdd, 0xb1, 0x24, 0x99, 0xc7, 0x3a, 0xb8, 0x0a, 0x7b, 0x0d, 0xdd,\n\t0x35, 0x07, 0x79, 0x17, 0x0b, 0x51, 0x9b, 0xb3, 0xc7, 0x10, 0x01, 0x13, 0xe7, 0x3f, 0xf3, 0x5f\n};\n\nconst BYTE tssk_exponent[] = { 0x5b, 0x7b, 0x88, 0xc0 };\n\nBOOL gcc_write_server_security_data(wStream* s, rdpMcs* mcs)\n{\n\tBYTE* sigData;\n\tint expLen, keyLen, sigDataLen;\n\tBYTE encryptedSignature[TSSK_KEY_LENGTH];\n\tBYTE signature[sizeof(initial_signature)];\n\tUINT32 headerLen, serverRandomLen, serverCertLen, wPublicKeyBlobLen;\n\trdpSettings* settings = mcs->settings;\n\n\t/**\n\t * Re: settings->EncryptionLevel:\n\t * This is configured/set by the server implementation and serves the same\n\t * purpose as the \"Encryption Level\" setting in the RDP-Tcp configuration\n\t * dialog of Microsoft's Remote Desktop Session Host Configuration.\n\t * Re: settings->EncryptionMethods:\n\t * at this point this setting contains the client's supported encryption\n\t * methods we've received in gcc_read_client_security_data()\n\t */\n\n\tif (!settings->UseRdpSecurityLayer)\n\t{\n\t\t/* TLS/NLA is used: disable rdp style encryption */\n\t\tsettings->EncryptionLevel = ENCRYPTION_LEVEL_NONE;\n\t}\n\n\t/* verify server encryption level value */\n\tswitch (settings->EncryptionLevel)\n\t{\n\t\tcase ENCRYPTION_LEVEL_NONE:\n\t\t\tWLog_INFO(TAG, \"Active rdp encryption level: NONE\");\n\t\t\tbreak;\n\n\t\tcase ENCRYPTION_LEVEL_FIPS:\n\t\t\tWLog_INFO(TAG, \"Active rdp encryption level: FIPS Compliant\");\n\t\t\tbreak;\n\n\t\tcase ENCRYPTION_LEVEL_HIGH:\n\t\t\tWLog_INFO(TAG, \"Active rdp encryption level: HIGH\");\n\t\t\tbreak;\n\n\t\tcase ENCRYPTION_LEVEL_LOW:\n\t\t\tWLog_INFO(TAG, \"Active rdp encryption level: LOW\");\n\t\t\tbreak;\n\n\t\tcase ENCRYPTION_LEVEL_CLIENT_COMPATIBLE:\n\t\t\tWLog_INFO(TAG, \"Active rdp encryption level: CLIENT-COMPATIBLE\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_ERR(TAG, \"Invalid server encryption level 0x%08\" PRIX32 \"\",\n\t\t\t         settings->EncryptionLevel);\n\t\t\tWLog_ERR(TAG, \"Switching to encryption level CLIENT-COMPATIBLE\");\n\t\t\tsettings->EncryptionLevel = ENCRYPTION_LEVEL_CLIENT_COMPATIBLE;\n\t}\n\n\t/* choose rdp encryption method based on server level and client methods */\n\tswitch (settings->EncryptionLevel)\n\t{\n\t\tcase ENCRYPTION_LEVEL_NONE:\n\t\t\t/* The only valid method is NONE in this case */\n\t\t\tsettings->EncryptionMethods = ENCRYPTION_METHOD_NONE;\n\t\t\tbreak;\n\n\t\tcase ENCRYPTION_LEVEL_FIPS:\n\n\t\t\t/* The only valid method is FIPS in this case */\n\t\t\tif (!(settings->EncryptionMethods & ENCRYPTION_METHOD_FIPS))\n\t\t\t{\n\t\t\t\tWLog_WARN(TAG, \"client does not support FIPS as required by server configuration\");\n\t\t\t}\n\n\t\t\tsettings->EncryptionMethods = ENCRYPTION_METHOD_FIPS;\n\t\t\tbreak;\n\n\t\tcase ENCRYPTION_LEVEL_HIGH:\n\n\t\t\t/* Maximum key strength supported by the server must be used (128 bit)*/\n\t\t\tif (!(settings->EncryptionMethods & ENCRYPTION_METHOD_128BIT))\n\t\t\t{\n\t\t\t\tWLog_WARN(TAG, \"client does not support 128 bit encryption method as required by \"\n\t\t\t\t               \"server configuration\");\n\t\t\t}\n\n\t\t\tsettings->EncryptionMethods = ENCRYPTION_METHOD_128BIT;\n\t\t\tbreak;\n\n\t\tcase ENCRYPTION_LEVEL_LOW:\n\t\tcase ENCRYPTION_LEVEL_CLIENT_COMPATIBLE:\n\n\t\t\t/* Maximum key strength supported by the client must be used */\n\t\t\tif (settings->EncryptionMethods & ENCRYPTION_METHOD_128BIT)\n\t\t\t\tsettings->EncryptionMethods = ENCRYPTION_METHOD_128BIT;\n\t\t\telse if (settings->EncryptionMethods & ENCRYPTION_METHOD_56BIT)\n\t\t\t\tsettings->EncryptionMethods = ENCRYPTION_METHOD_56BIT;\n\t\t\telse if (settings->EncryptionMethods & ENCRYPTION_METHOD_40BIT)\n\t\t\t\tsettings->EncryptionMethods = ENCRYPTION_METHOD_40BIT;\n\t\t\telse if (settings->EncryptionMethods & ENCRYPTION_METHOD_FIPS)\n\t\t\t\tsettings->EncryptionMethods = ENCRYPTION_METHOD_FIPS;\n\t\t\telse\n\t\t\t{\n\t\t\t\tWLog_WARN(TAG, \"client has not announced any supported encryption methods\");\n\t\t\t\tsettings->EncryptionMethods = ENCRYPTION_METHOD_128BIT;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_ERR(TAG, \"internal error: unknown encryption level\");\n\t\t\treturn FALSE;\n\t}\n\n\t/* log selected encryption method */\n\tswitch (settings->EncryptionMethods)\n\t{\n\t\tcase ENCRYPTION_METHOD_NONE:\n\t\t\tWLog_INFO(TAG, \"Selected rdp encryption method: NONE\");\n\t\t\tbreak;\n\n\t\tcase ENCRYPTION_METHOD_40BIT:\n\t\t\tWLog_INFO(TAG, \"Selected rdp encryption method: 40BIT\");\n\t\t\tbreak;\n\n\t\tcase ENCRYPTION_METHOD_56BIT:\n\t\t\tWLog_INFO(TAG, \"Selected rdp encryption method: 56BIT\");\n\t\t\tbreak;\n\n\t\tcase ENCRYPTION_METHOD_128BIT:\n\t\t\tWLog_INFO(TAG, \"Selected rdp encryption method: 128BIT\");\n\t\t\tbreak;\n\n\t\tcase ENCRYPTION_METHOD_FIPS:\n\t\t\tWLog_INFO(TAG, \"Selected rdp encryption method: FIPS\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_ERR(TAG, \"internal error: unknown encryption method\");\n\t\t\treturn FALSE;\n\t}\n\n\theaderLen = 12;\n\tkeyLen = 0;\n\twPublicKeyBlobLen = 0;\n\tserverRandomLen = 0;\n\tserverCertLen = 0;\n\n\tif (settings->EncryptionMethods != ENCRYPTION_METHOD_NONE)\n\t{\n\t\tserverRandomLen = 32;\n\t\tkeyLen = settings->RdpServerRsaKey->ModulusLength;\n\t\texpLen = sizeof(settings->RdpServerRsaKey->exponent);\n\t\twPublicKeyBlobLen = 4;  /* magic (RSA1) */\n\t\twPublicKeyBlobLen += 4; /* keylen */\n\t\twPublicKeyBlobLen += 4; /* bitlen */\n\t\twPublicKeyBlobLen += 4; /* datalen */\n\t\twPublicKeyBlobLen += expLen;\n\t\twPublicKeyBlobLen += keyLen;\n\t\twPublicKeyBlobLen += 8; /* 8 bytes of zero padding */\n\t\tserverCertLen = 4;      /* dwVersion */\n\t\tserverCertLen += 4;     /* dwSigAlgId */\n\t\tserverCertLen += 4;     /* dwKeyAlgId */\n\t\tserverCertLen += 2;     /* wPublicKeyBlobType */\n\t\tserverCertLen += 2;     /* wPublicKeyBlobLen */\n\t\tserverCertLen += wPublicKeyBlobLen;\n\t\tserverCertLen += 2;                          /* wSignatureBlobType */\n\t\tserverCertLen += 2;                          /* wSignatureBlobLen */\n\t\tserverCertLen += sizeof(encryptedSignature); /* SignatureBlob */\n\t\tserverCertLen += 8;                          /* 8 bytes of zero padding */\n\t\theaderLen += sizeof(serverRandomLen);\n\t\theaderLen += sizeof(serverCertLen);\n\t\theaderLen += serverRandomLen;\n\t\theaderLen += serverCertLen;\n\t}\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLen + 4))\n\t\treturn FALSE;\n\n\tgcc_write_user_data_header(s, SC_SECURITY, headerLen);\n\tStream_Write_UINT32(s, settings->EncryptionMethods); /* encryptionMethod */\n\tStream_Write_UINT32(s, settings->EncryptionLevel);   /* encryptionLevel */\n\n\tif (settings->EncryptionMethods == ENCRYPTION_METHOD_NONE)\n\t{\n\t\treturn TRUE;\n\t}\n\n\tStream_Write_UINT32(s, serverRandomLen); /* serverRandomLen */\n\tStream_Write_UINT32(s, serverCertLen);   /* serverCertLen */\n\tsettings->ServerRandomLength = serverRandomLen;\n\tsettings->ServerRandom = (BYTE*)malloc(serverRandomLen);\n\n\tif (!settings->ServerRandom)\n\t{\n\t\treturn FALSE;\n\t}\n\n\twinpr_RAND(settings->ServerRandom, serverRandomLen);\n\tStream_Write(s, settings->ServerRandom, serverRandomLen);\n\tsigData = Stream_Pointer(s);\n\tStream_Write_UINT32(s, CERT_CHAIN_VERSION_1); /* dwVersion (4 bytes) */\n\tStream_Write_UINT32(s, SIGNATURE_ALG_RSA);    /* dwSigAlgId */\n\tStream_Write_UINT32(s, KEY_EXCHANGE_ALG_RSA); /* dwKeyAlgId */\n\tStream_Write_UINT16(s, BB_RSA_KEY_BLOB);      /* wPublicKeyBlobType */\n\tStream_Write_UINT16(s, wPublicKeyBlobLen);    /* wPublicKeyBlobLen */\n\tStream_Write(s, \"RSA1\", 4);                   /* magic */\n\tStream_Write_UINT32(s, keyLen + 8);           /* keylen */\n\tStream_Write_UINT32(s, keyLen * 8);           /* bitlen */\n\tStream_Write_UINT32(s, keyLen - 1);           /* datalen */\n\tStream_Write(s, settings->RdpServerRsaKey->exponent, expLen);\n\tStream_Write(s, settings->RdpServerRsaKey->Modulus, keyLen);\n\tStream_Zero(s, 8);\n\tsigDataLen = Stream_Pointer(s) - sigData;\n\tStream_Write_UINT16(s, BB_RSA_SIGNATURE_BLOB);          /* wSignatureBlobType */\n\tStream_Write_UINT16(s, sizeof(encryptedSignature) + 8); /* wSignatureBlobLen */\n\tmemcpy(signature, initial_signature, sizeof(initial_signature));\n\n\tif (!winpr_Digest(WINPR_MD_MD5, sigData, sigDataLen, signature, sizeof(signature)))\n\t\treturn FALSE;\n\n\tcrypto_rsa_private_encrypt(signature, sizeof(signature), TSSK_KEY_LENGTH, tssk_modulus,\n\t                           tssk_privateExponent, encryptedSignature);\n\tStream_Write(s, encryptedSignature, sizeof(encryptedSignature));\n\tStream_Zero(s, 8);\n\treturn TRUE;\n}\n\n/**\n * Read a client network data block (TS_UD_CS_NET).\\n\n * @msdn{cc240512}\n * @param s stream\n * @param settings rdp settings\n */\n\nBOOL gcc_read_client_network_data(wStream* s, rdpMcs* mcs, UINT16 blockLength)\n{\n\tUINT32 i;\n\n\tif (blockLength < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, mcs->channelCount); /* channelCount */\n\n\tif (blockLength < 4 + mcs->channelCount * 12)\n\t\treturn FALSE;\n\n\tif (mcs->channelCount > CHANNEL_MAX_COUNT)\n\t\treturn FALSE;\n\n\t/* channelDefArray */\n\tfor (i = 0; i < mcs->channelCount; i++)\n\t{\n\t\t/**\n\t\t * CHANNEL_DEF\n\t\t * - name: an 8-byte array containing a null-terminated collection\n\t\t *   of seven ANSI characters that uniquely identify the channel.\n\t\t * - options: a 32-bit, unsigned integer. Channel option flags\n\t\t */\n\t\tStream_Read(s, mcs->channels[i].Name, 8); /* name (8 bytes) */\n\n\t\tif (!memchr(mcs->channels[i].Name, 0, 8))\n\t\t{\n\t\t\tWLog_ERR(\n\t\t\t    TAG,\n\t\t\t    \"protocol violation: received a static channel name with missing null-termination\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tStream_Read_UINT32(s, mcs->channels[i].options); /* options (4 bytes) */\n\t\tmcs->channels[i].ChannelId = mcs->baseChannelId++;\n\t}\n\n\treturn TRUE;\n}\n\n/**\n * Write a client network data block (TS_UD_CS_NET).\\n\n * @msdn{cc240512}\n * @param s stream\n * @param settings rdp settings\n */\n\nvoid gcc_write_client_network_data(wStream* s, rdpMcs* mcs)\n{\n\tUINT32 i;\n\tUINT16 length;\n\n\tif (mcs->channelCount > 0)\n\t{\n\t\tlength = mcs->channelCount * 12 + 8;\n\t\tgcc_write_user_data_header(s, CS_NET, length);\n\t\tStream_Write_UINT32(s, mcs->channelCount); /* channelCount */\n\n\t\t/* channelDefArray */\n\t\tfor (i = 0; i < mcs->channelCount; i++)\n\t\t{\n\t\t\t/* CHANNEL_DEF */\n\t\t\tStream_Write(s, mcs->channels[i].Name, 8);        /* name (8 bytes) */\n\t\t\tStream_Write_UINT32(s, mcs->channels[i].options); /* options (4 bytes) */\n\t\t}\n\t}\n}\n\nBOOL gcc_read_server_network_data(wStream* s, rdpMcs* mcs)\n{\n\tint i;\n\tUINT16 channelId;\n\tUINT16 MCSChannelId;\n\tUINT16 channelCount;\n\tUINT16 parsedChannelCount;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, MCSChannelId); /* MCSChannelId */\n\tStream_Read_UINT16(s, channelCount); /* channelCount */\n\tparsedChannelCount = channelCount;\n\n\tif (channelCount != mcs->channelCount)\n\t{\n\t\tWLog_ERR(TAG, \"requested %\" PRIu32 \" channels, got %\" PRIu16 \" instead\", mcs->channelCount,\n\t\t         channelCount);\n\n\t\t/* we ensure that the response is not bigger than the request */\n\n\t\tif (channelCount > mcs->channelCount)\n\t\t\tparsedChannelCount = mcs->channelCount;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < (size_t)channelCount * 2)\n\t\treturn FALSE;\n\n\tfor (i = 0; i < parsedChannelCount; i++)\n\t{\n\t\tStream_Read_UINT16(s, channelId); /* channelId */\n\t\tmcs->channels[i].ChannelId = channelId;\n\t}\n\n\tif (channelCount % 2 == 1)\n\t\treturn Stream_SafeSeek(s, 2); /* padding */\n\n\treturn TRUE;\n}\n\nBOOL gcc_write_server_network_data(wStream* s, rdpMcs* mcs)\n{\n\tUINT32 i;\n\tint payloadLen = 8 + mcs->channelCount * 2 + (mcs->channelCount % 2 == 1 ? 2 : 0);\n\n\tif (!Stream_EnsureRemainingCapacity(s, payloadLen + 4))\n\t\treturn FALSE;\n\n\tgcc_write_user_data_header(s, SC_NET, payloadLen);\n\tStream_Write_UINT16(s, MCS_GLOBAL_CHANNEL_ID); /* MCSChannelId */\n\tStream_Write_UINT16(s, mcs->channelCount);     /* channelCount */\n\n\tfor (i = 0; i < mcs->channelCount; i++)\n\t{\n\t\tStream_Write_UINT16(s, mcs->channels[i].ChannelId);\n\t}\n\n\tif (mcs->channelCount % 2 == 1)\n\t\tStream_Write_UINT16(s, 0);\n\n\treturn TRUE;\n}\n\n/**\n * Read a client cluster data block (TS_UD_CS_CLUSTER).\\n\n * @msdn{cc240514}\n * @param s stream\n * @param settings rdp settings\n */\n\nBOOL gcc_read_client_cluster_data(wStream* s, rdpMcs* mcs, UINT16 blockLength)\n{\n\tUINT32 flags;\n\tUINT32 redirectedSessionId;\n\trdpSettings* settings = mcs->settings;\n\n\tif (blockLength < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, flags);               /* flags */\n\tStream_Read_UINT32(s, redirectedSessionId); /* redirectedSessionId */\n\n\tif (flags & REDIRECTED_SESSIONID_FIELD_VALID)\n\t\tsettings->RedirectedSessionId = redirectedSessionId;\n\n\tif (blockLength != 8)\n\t{\n\t\tif (Stream_GetRemainingLength(s) >= (size_t)(blockLength - 8))\n\t\t{\n\t\t\t/* The old Microsoft Mac RDP client can send a pad here */\n\t\t\tStream_Seek(s, (blockLength - 8));\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\n/**\n * Write a client cluster data block (TS_UD_CS_CLUSTER).\\n\n * @msdn{cc240514}\n * @param s stream\n * @param settings rdp settings\n */\n\nvoid gcc_write_client_cluster_data(wStream* s, rdpMcs* mcs)\n{\n\tUINT32 flags;\n\trdpSettings* settings = mcs->settings;\n\tgcc_write_user_data_header(s, CS_CLUSTER, 12);\n\tflags = REDIRECTION_SUPPORTED | (REDIRECTION_VERSION4 << 2);\n\n\tif (settings->ConsoleSession || settings->RedirectedSessionId)\n\t\tflags |= REDIRECTED_SESSIONID_FIELD_VALID;\n\n\tif (settings->RedirectSmartCards)\n\t\tflags |= REDIRECTED_SMARTCARD;\n\n\tStream_Write_UINT32(s, flags);                         /* flags */\n\tStream_Write_UINT32(s, settings->RedirectedSessionId); /* redirectedSessionID */\n}\n\n/**\n * Read a client monitor data block (TS_UD_CS_MONITOR).\\n\n * @msdn{dd305336}\n * @param s stream\n * @param settings rdp settings\n */\n\nBOOL gcc_read_client_monitor_data(wStream* s, rdpMcs* mcs, UINT16 blockLength)\n{\n\tUINT32 index;\n\tUINT32 flags;\n\tUINT32 monitorCount;\n\tUINT32 left, top, right, bottom;\n\trdpSettings* settings = mcs->settings;\n\n\tif (blockLength < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, flags);        /* flags */\n\tStream_Read_UINT32(s, monitorCount); /* monitorCount */\n\n\t/* 2.2.1.3.6 Client Monitor Data -\n\t * monitorCount (4 bytes): A 32-bit, unsigned integer. The number of display\n\t * monitor definitions in the monitorDefArray field (the maximum allowed is 16).\n\t */\n\tif (monitorCount > 16)\n\t{\n\t\tWLog_ERR(TAG, \"announced monitors(%\" PRIu32 \") exceed the 16 limit\", monitorCount);\n\t\treturn FALSE;\n\t}\n\n\tif (monitorCount > settings->MonitorDefArraySize)\n\t{\n\t\tWLog_ERR(TAG, \"too many announced monitors(%\" PRIu32 \"), clamping to %\" PRIu32 \"\",\n\t\t         monitorCount, settings->MonitorDefArraySize);\n\t\tmonitorCount = settings->MonitorDefArraySize;\n\t}\n\n\tif ((UINT32)((blockLength - 8) / 20) < monitorCount)\n\t\treturn FALSE;\n\n\tsettings->MonitorCount = monitorCount;\n\n\tfor (index = 0; index < monitorCount; index++)\n\t{\n\t\tStream_Read_UINT32(s, left);   /* left */\n\t\tStream_Read_UINT32(s, top);    /* top */\n\t\tStream_Read_UINT32(s, right);  /* right */\n\t\tStream_Read_UINT32(s, bottom); /* bottom */\n\t\tStream_Read_UINT32(s, flags);  /* flags */\n\t\tsettings->MonitorDefArray[index].x = left;\n\t\tsettings->MonitorDefArray[index].y = top;\n\t\tsettings->MonitorDefArray[index].width = right - left + 1;\n\t\tsettings->MonitorDefArray[index].height = bottom - top + 1;\n\t\tsettings->MonitorDefArray[index].is_primary = (flags & MONITOR_PRIMARY);\n\t}\n\n\treturn TRUE;\n}\n\n/**\n * Write a client monitor data block (TS_UD_CS_MONITOR).\\n\n * @msdn{dd305336}\n * @param s stream\n * @param settings rdp settings\n */\n\nvoid gcc_write_client_monitor_data(wStream* s, rdpMcs* mcs)\n{\n\tUINT32 i;\n\tUINT16 length;\n\tUINT32 left, top, right, bottom, flags;\n\tINT32 baseX = 0, baseY = 0;\n\trdpSettings* settings = mcs->settings;\n\n\tif (settings->MonitorCount > 1)\n\t{\n\t\tlength = (20 * settings->MonitorCount) + 12;\n\t\tgcc_write_user_data_header(s, CS_MONITOR, length);\n\t\tStream_Write_UINT32(s, 0);                      /* flags */\n\t\tStream_Write_UINT32(s, settings->MonitorCount); /* monitorCount */\n\n\t\t/* first pass to get the primary monitor coordinates (it is supposed to be\n\t\t * in (0,0) */\n\t\tfor (i = 0; i < settings->MonitorCount; i++)\n\t\t{\n\t\t\tif (settings->MonitorDefArray[i].is_primary)\n\t\t\t{\n\t\t\t\tbaseX = settings->MonitorDefArray[i].x;\n\t\t\t\tbaseY = settings->MonitorDefArray[i].y;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < settings->MonitorCount; i++)\n\t\t{\n\t\t\tleft = settings->MonitorDefArray[i].x - baseX;\n\t\t\ttop = settings->MonitorDefArray[i].y - baseY;\n\t\t\tright = left + settings->MonitorDefArray[i].width - 1;\n\t\t\tbottom = top + settings->MonitorDefArray[i].height - 1;\n\t\t\tflags = settings->MonitorDefArray[i].is_primary ? MONITOR_PRIMARY : 0;\n\t\t\tStream_Write_UINT32(s, left);   /* left */\n\t\t\tStream_Write_UINT32(s, top);    /* top */\n\t\t\tStream_Write_UINT32(s, right);  /* right */\n\t\t\tStream_Write_UINT32(s, bottom); /* bottom */\n\t\t\tStream_Write_UINT32(s, flags);  /* flags */\n\t\t}\n\t}\n}\n\nBOOL gcc_read_client_monitor_extended_data(wStream* s, rdpMcs* mcs, UINT16 blockLength)\n{\n\tUINT32 index;\n\tUINT32 flags;\n\tUINT32 monitorCount;\n\tUINT32 monitorAttributeSize;\n\trdpSettings* settings = mcs->settings;\n\n\tif (blockLength < 12)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, flags);                /* flags */\n\tStream_Read_UINT32(s, monitorAttributeSize); /* monitorAttributeSize */\n\tStream_Read_UINT32(s, monitorCount);         /* monitorCount */\n\n\tif (monitorAttributeSize != 20)\n\t\treturn FALSE;\n\n\tif ((blockLength - 12) / monitorAttributeSize < monitorCount)\n\t\treturn FALSE;\n\n\tif (settings->MonitorCount != monitorCount)\n\t\treturn FALSE;\n\n\tsettings->HasMonitorAttributes = TRUE;\n\n\tfor (index = 0; index < monitorCount; index++)\n\t{\n\t\tStream_Read_UINT32(\n\t\t    s, settings->MonitorDefArray[index].attributes.physicalWidth); /* physicalWidth */\n\t\tStream_Read_UINT32(\n\t\t    s, settings->MonitorDefArray[index].attributes.physicalHeight); /* physicalHeight */\n\t\tStream_Read_UINT32(\n\t\t    s, settings->MonitorDefArray[index].attributes.orientation); /* orientation */\n\t\tStream_Read_UINT32(s, settings->MonitorDefArray[index]\n\t\t                          .attributes.desktopScaleFactor); /* desktopScaleFactor */\n\t\tStream_Read_UINT32(\n\t\t    s,\n\t\t    settings->MonitorDefArray[index].attributes.deviceScaleFactor); /* deviceScaleFactor */\n\t}\n\n\treturn TRUE;\n}\n\nvoid gcc_write_client_monitor_extended_data(wStream* s, rdpMcs* mcs)\n{\n\tUINT32 i;\n\tUINT16 length;\n\trdpSettings* settings = mcs->settings;\n\n\tif (settings->HasMonitorAttributes)\n\t{\n\t\tlength = (20 * settings->MonitorCount) + 16;\n\t\tgcc_write_user_data_header(s, CS_MONITOR_EX, length);\n\t\tStream_Write_UINT32(s, 0);                      /* flags */\n\t\tStream_Write_UINT32(s, 20);                     /* monitorAttributeSize */\n\t\tStream_Write_UINT32(s, settings->MonitorCount); /* monitorCount */\n\n\t\tfor (i = 0; i < settings->MonitorCount; i++)\n\t\t{\n\t\t\tStream_Write_UINT32(\n\t\t\t    s, settings->MonitorDefArray[i].attributes.physicalWidth); /* physicalWidth */\n\t\t\tStream_Write_UINT32(\n\t\t\t    s, settings->MonitorDefArray[i].attributes.physicalHeight); /* physicalHeight */\n\t\t\tStream_Write_UINT32(\n\t\t\t    s, settings->MonitorDefArray[i].attributes.orientation); /* orientation */\n\t\t\tStream_Write_UINT32(s, settings->MonitorDefArray[i]\n\t\t\t                           .attributes.desktopScaleFactor); /* desktopScaleFactor */\n\t\t\tStream_Write_UINT32(\n\t\t\t    s,\n\t\t\t    settings->MonitorDefArray[i].attributes.deviceScaleFactor); /* deviceScaleFactor */\n\t\t}\n\t}\n}\n\n/**\n * Read a client message channel data block (TS_UD_CS_MCS_MSGCHANNEL).\\n\n * @msdn{jj217627}\n * @param s stream\n * @param settings rdp settings\n */\n\nBOOL gcc_read_client_message_channel_data(wStream* s, rdpMcs* mcs, UINT16 blockLength)\n{\n\tUINT32 flags;\n\n\tif (blockLength < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, flags);\n\tmcs->messageChannelId = mcs->baseChannelId++;\n\treturn TRUE;\n}\n\n/**\n * Write a client message channel data block (TS_UD_CS_MCS_MSGCHANNEL).\\n\n * @msdn{jj217627}\n * @param s stream\n * @param settings rdp settings\n */\n\nvoid gcc_write_client_message_channel_data(wStream* s, rdpMcs* mcs)\n{\n\trdpSettings* settings = mcs->settings;\n\n\tif (settings->NetworkAutoDetect || settings->SupportHeartbeatPdu ||\n\t    settings->SupportMultitransport)\n\t{\n\t\tgcc_write_user_data_header(s, CS_MCS_MSGCHANNEL, 8);\n\t\tStream_Write_UINT32(s, 0); /* flags */\n\t}\n}\n\nBOOL gcc_read_server_message_channel_data(wStream* s, rdpMcs* mcs)\n{\n\tUINT16 MCSChannelId;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, MCSChannelId); /* MCSChannelId */\n\t/* Save the MCS message channel id */\n\tmcs->messageChannelId = MCSChannelId;\n\treturn TRUE;\n}\n\nBOOL gcc_write_server_message_channel_data(wStream* s, rdpMcs* mcs)\n{\n\tif (mcs->messageChannelId == 0)\n\t\treturn TRUE;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 2 + 4))\n\t\treturn FALSE;\n\n\tgcc_write_user_data_header(s, SC_MCS_MSGCHANNEL, 6);\n\tStream_Write_UINT16(s, mcs->messageChannelId); /* mcsChannelId (2 bytes) */\n\treturn TRUE;\n}\n\n/**\n * Read a client multitransport channel data block (TS_UD_CS_MULTITRANSPORT).\\n\n * @msdn{jj217498}\n * @param s stream\n * @param settings rdp settings\n */\n\nBOOL gcc_read_client_multitransport_channel_data(wStream* s, rdpMcs* mcs, UINT16 blockLength)\n{\n\tUINT32 flags;\n\n\tif (blockLength < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, flags);\n\treturn TRUE;\n}\n\n/**\n * Write a client multitransport channel data block (TS_UD_CS_MULTITRANSPORT).\\n\n * @msdn{jj217498}\n * @param s stream\n * @param settings rdp settings\n */\n\nvoid gcc_write_client_multitransport_channel_data(wStream* s, rdpMcs* mcs)\n{\n\trdpSettings* settings = mcs->settings;\n\n\tgcc_write_user_data_header(s, CS_MULTITRANSPORT, 8);\n\tStream_Write_UINT32(s, settings->MultitransportFlags); /* flags */\n}\n\nBOOL gcc_read_server_multitransport_channel_data(wStream* s, rdpMcs* mcs)\n{\n\tUINT32 flags;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, flags); /* flags */\n\treturn TRUE;\n}\n\nvoid gcc_write_server_multitransport_channel_data(wStream* s, rdpMcs* mcs)\n{\n\tUINT32 flags = 0;\n\tgcc_write_user_data_header(s, SC_MULTITRANSPORT, 8);\n\tStream_Write_UINT32(s, flags); /* flags (4 bytes) */\n}\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * Drawing Orders\n *\n * Copyright 2011 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2016 Armin Novak <armin.novak@thincast.com>\n * Copyright 2016 Thincast Technologies GmbH\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"window.h\"\n\n#include <winpr/wtypes.h>\n#include <winpr/crt.h>\n\n#include <freerdp/api.h>\n#include <freerdp/log.h>\n#include <freerdp/graphics.h>\n#include <freerdp/codec/bitmap.h>\n#include <freerdp/gdi/gdi.h>\n\n#include \"orders.h\"\n\n#include \"../cache/glyph.h\"\n#include \"../cache/bitmap.h\"\n#include \"../cache/brush.h\"\n#include \"../cache/cache.h\"\n\n#define TAG FREERDP_TAG(\"core.orders\")\n\nconst BYTE PRIMARY_DRAWING_ORDER_FIELD_BYTES[] = { DSTBLT_ORDER_FIELD_BYTES,\n\t                                               PATBLT_ORDER_FIELD_BYTES,\n\t                                               SCRBLT_ORDER_FIELD_BYTES,\n\t                                               0,\n\t                                               0,\n\t                                               0,\n\t                                               0,\n\t                                               DRAW_NINE_GRID_ORDER_FIELD_BYTES,\n\t                                               MULTI_DRAW_NINE_GRID_ORDER_FIELD_BYTES,\n\t                                               LINE_TO_ORDER_FIELD_BYTES,\n\t                                               OPAQUE_RECT_ORDER_FIELD_BYTES,\n\t                                               SAVE_BITMAP_ORDER_FIELD_BYTES,\n\t                                               0,\n\t                                               MEMBLT_ORDER_FIELD_BYTES,\n\t                                               MEM3BLT_ORDER_FIELD_BYTES,\n\t                                               MULTI_DSTBLT_ORDER_FIELD_BYTES,\n\t                                               MULTI_PATBLT_ORDER_FIELD_BYTES,\n\t                                               MULTI_SCRBLT_ORDER_FIELD_BYTES,\n\t                                               MULTI_OPAQUE_RECT_ORDER_FIELD_BYTES,\n\t                                               FAST_INDEX_ORDER_FIELD_BYTES,\n\t                                               POLYGON_SC_ORDER_FIELD_BYTES,\n\t                                               POLYGON_CB_ORDER_FIELD_BYTES,\n\t                                               POLYLINE_ORDER_FIELD_BYTES,\n\t                                               0,\n\t                                               FAST_GLYPH_ORDER_FIELD_BYTES,\n\t                                               ELLIPSE_SC_ORDER_FIELD_BYTES,\n\t                                               ELLIPSE_CB_ORDER_FIELD_BYTES,\n\t                                               GLYPH_INDEX_ORDER_FIELD_BYTES };\n\n#define PRIMARY_DRAWING_ORDER_COUNT (ARRAYSIZE(PRIMARY_DRAWING_ORDER_FIELD_BYTES))\n\nstatic const BYTE CBR2_BPP[] = { 0, 0, 0, 8, 16, 24, 32 };\n\nstatic const BYTE BPP_CBR2[] = { 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,\n\t                             0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0 };\n\nstatic const BYTE CBR23_BPP[] = { 0, 0, 0, 8, 16, 24, 32 };\n\nstatic const BYTE BPP_CBR23[] = { 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,\n\t                              0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0 };\n\nstatic const BYTE BMF_BPP[] = { 0, 1, 0, 8, 16, 24, 32, 0 };\n\nstatic const BYTE BPP_BMF[] = { 0, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,\n\t                            0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0 };\n\nstatic BOOL check_order_activated(wLog* log, rdpSettings* settings, const char* orderName,\n                                  BOOL condition)\n{\n\tif (!condition)\n\t{\n\t\tif (settings->AllowUnanouncedOrdersFromServer)\n\t\t{\n\t\t\tWLog_Print(log, WLOG_WARN,\n\t\t\t           \"%s - SERVER BUG: The support for this feature was not announced!\",\n\t\t\t           orderName);\n\t\t\treturn TRUE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tWLog_Print(log, WLOG_ERROR,\n\t\t\t           \"%s - SERVER BUG: The support for this feature was not announced! Use \"\n\t\t\t           \"/relax-order-checks to ignore\",\n\t\t\t           orderName);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL check_alt_order_supported(wLog* log, rdpSettings* settings, BYTE orderType,\n                                      const char* orderName)\n{\n\tBOOL condition = FALSE;\n\n\tswitch (orderType)\n\t{\n\t\tcase ORDER_TYPE_CREATE_OFFSCREEN_BITMAP:\n\t\tcase ORDER_TYPE_SWITCH_SURFACE:\n\t\t\tcondition = settings->OffscreenSupportLevel != 0;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_CREATE_NINE_GRID_BITMAP:\n\t\t\tcondition = settings->DrawNineGridEnabled;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_FRAME_MARKER:\n\t\t\tcondition = settings->FrameMarkerCommandEnabled;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_FIRST:\n\t\tcase ORDER_TYPE_GDIPLUS_NEXT:\n\t\tcase ORDER_TYPE_GDIPLUS_END:\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_FIRST:\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_NEXT:\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_END:\n\t\t\tcondition = settings->DrawGdiPlusCacheEnabled;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_WINDOW:\n\t\t\tcondition = settings->RemoteWndSupportLevel != WINDOW_LEVEL_NOT_SUPPORTED;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_STREAM_BITMAP_FIRST:\n\t\tcase ORDER_TYPE_STREAM_BITMAP_NEXT:\n\t\tcase ORDER_TYPE_COMPDESK_FIRST:\n\t\t\tcondition = TRUE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(log, WLOG_WARN, \"%s - Alternate Secondary Drawing Order UNKNOWN\", orderName);\n\t\t\tcondition = FALSE;\n\t\t\tbreak;\n\t}\n\n\treturn check_order_activated(log, settings, orderName, condition);\n}\n\nstatic BOOL check_secondary_order_supported(wLog* log, rdpSettings* settings, BYTE orderType,\n                                            const char* orderName)\n{\n\tBOOL condition = FALSE;\n\n\tswitch (orderType)\n\t{\n\t\tcase ORDER_TYPE_BITMAP_UNCOMPRESSED:\n\t\tcase ORDER_TYPE_CACHE_BITMAP_COMPRESSED:\n\t\t\tcondition = settings->BitmapCacheEnabled;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_BITMAP_UNCOMPRESSED_V2:\n\t\tcase ORDER_TYPE_BITMAP_COMPRESSED_V2:\n\t\t\tcondition = settings->BitmapCacheEnabled;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_BITMAP_COMPRESSED_V3:\n\t\t\tcondition = settings->BitmapCacheV3Enabled;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_COLOR_TABLE:\n\t\t\tcondition = (settings->OrderSupport[NEG_MEMBLT_INDEX] ||\n\t\t\t             settings->OrderSupport[NEG_MEM3BLT_INDEX]);\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_GLYPH:\n\t\t{\n\t\t\tswitch (settings->GlyphSupportLevel)\n\t\t\t{\n\t\t\t\tcase GLYPH_SUPPORT_PARTIAL:\n\t\t\t\tcase GLYPH_SUPPORT_FULL:\n\t\t\t\tcase GLYPH_SUPPORT_ENCODE:\n\t\t\t\t\tcondition = TRUE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase GLYPH_SUPPORT_NONE:\n\t\t\t\tdefault:\n\t\t\t\t\tcondition = FALSE;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_BRUSH:\n\t\t\tcondition = TRUE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(log, WLOG_WARN, \"SECONDARY ORDER %s not supported\", orderName);\n\t\t\tbreak;\n\t}\n\n\treturn check_order_activated(log, settings, orderName, condition);\n}\n\nstatic BOOL check_primary_order_supported(wLog* log, rdpSettings* settings, UINT32 orderType,\n                                          const char* orderName)\n{\n\tBOOL condition = FALSE;\n\n\tswitch (orderType)\n\t{\n\t\tcase ORDER_TYPE_DSTBLT:\n\t\t\tcondition = settings->OrderSupport[NEG_DSTBLT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_SCRBLT:\n\t\t\tcondition = settings->OrderSupport[NEG_SCRBLT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_DRAW_NINE_GRID:\n\t\t\tcondition = settings->OrderSupport[NEG_DRAWNINEGRID_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_DRAW_NINE_GRID:\n\t\t\tcondition = settings->OrderSupport[NEG_MULTI_DRAWNINEGRID_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_LINE_TO:\n\t\t\tcondition = settings->OrderSupport[NEG_LINETO_INDEX];\n\t\t\tbreak;\n\n\t\t/* [MS-RDPEGDI] 2.2.2.2.1.1.2.5 OpaqueRect (OPAQUERECT_ORDER)\n\t\t * suggests that PatBlt and OpaqueRect imply each other. */\n\t\tcase ORDER_TYPE_PATBLT:\n\t\tcase ORDER_TYPE_OPAQUE_RECT:\n\t\t\tcondition = settings->OrderSupport[NEG_OPAQUE_RECT_INDEX] ||\n\t\t\t            settings->OrderSupport[NEG_PATBLT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_SAVE_BITMAP:\n\t\t\tcondition = settings->OrderSupport[NEG_SAVEBITMAP_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MEMBLT:\n\t\t\tcondition = settings->OrderSupport[NEG_MEMBLT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MEM3BLT:\n\t\t\tcondition = settings->OrderSupport[NEG_MEM3BLT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_DSTBLT:\n\t\t\tcondition = settings->OrderSupport[NEG_MULTIDSTBLT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_PATBLT:\n\t\t\tcondition = settings->OrderSupport[NEG_MULTIPATBLT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_SCRBLT:\n\t\t\tcondition = settings->OrderSupport[NEG_MULTIDSTBLT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_OPAQUE_RECT:\n\t\t\tcondition = settings->OrderSupport[NEG_MULTIOPAQUERECT_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_FAST_INDEX:\n\t\t\tcondition = settings->OrderSupport[NEG_FAST_INDEX_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYGON_SC:\n\t\t\tcondition = settings->OrderSupport[NEG_POLYGON_SC_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYGON_CB:\n\t\t\tcondition = settings->OrderSupport[NEG_POLYGON_CB_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYLINE:\n\t\t\tcondition = settings->OrderSupport[NEG_POLYLINE_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_FAST_GLYPH:\n\t\t\tcondition = settings->OrderSupport[NEG_FAST_GLYPH_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_ELLIPSE_SC:\n\t\t\tcondition = settings->OrderSupport[NEG_ELLIPSE_SC_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_ELLIPSE_CB:\n\t\t\tcondition = settings->OrderSupport[NEG_ELLIPSE_CB_INDEX];\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GLYPH_INDEX:\n\t\t\tcondition = settings->OrderSupport[NEG_GLYPH_INDEX_INDEX];\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(log, WLOG_WARN, \"%s Primary Drawing Order not supported\", orderName);\n\t\t\tbreak;\n\t}\n\n\treturn check_order_activated(log, settings, orderName, condition);\n}\n\nstatic const char* primary_order_string(UINT32 orderType)\n{\n\tconst char* orders[] = { \"[0x%02\" PRIx8 \"] DstBlt\",\n\t\t                     \"[0x%02\" PRIx8 \"] PatBlt\",\n\t\t                     \"[0x%02\" PRIx8 \"] ScrBlt\",\n\t\t                     \"[0x%02\" PRIx8 \"] UNUSED\",\n\t\t                     \"[0x%02\" PRIx8 \"] UNUSED\",\n\t\t                     \"[0x%02\" PRIx8 \"] UNUSED\",\n\t\t                     \"[0x%02\" PRIx8 \"] UNUSED\",\n\t\t                     \"[0x%02\" PRIx8 \"] DrawNineGrid\",\n\t\t                     \"[0x%02\" PRIx8 \"] MultiDrawNineGrid\",\n\t\t                     \"[0x%02\" PRIx8 \"] LineTo\",\n\t\t                     \"[0x%02\" PRIx8 \"] OpaqueRect\",\n\t\t                     \"[0x%02\" PRIx8 \"] SaveBitmap\",\n\t\t                     \"[0x%02\" PRIx8 \"] UNUSED\",\n\t\t                     \"[0x%02\" PRIx8 \"] MemBlt\",\n\t\t                     \"[0x%02\" PRIx8 \"] Mem3Blt\",\n\t\t                     \"[0x%02\" PRIx8 \"] MultiDstBlt\",\n\t\t                     \"[0x%02\" PRIx8 \"] MultiPatBlt\",\n\t\t                     \"[0x%02\" PRIx8 \"] MultiScrBlt\",\n\t\t                     \"[0x%02\" PRIx8 \"] MultiOpaqueRect\",\n\t\t                     \"[0x%02\" PRIx8 \"] FastIndex\",\n\t\t                     \"[0x%02\" PRIx8 \"] PolygonSC\",\n\t\t                     \"[0x%02\" PRIx8 \"] PolygonCB\",\n\t\t                     \"[0x%02\" PRIx8 \"] Polyline\",\n\t\t                     \"[0x%02\" PRIx8 \"] UNUSED\",\n\t\t                     \"[0x%02\" PRIx8 \"] FastGlyph\",\n\t\t                     \"[0x%02\" PRIx8 \"] EllipseSC\",\n\t\t                     \"[0x%02\" PRIx8 \"] EllipseCB\",\n\t\t                     \"[0x%02\" PRIx8 \"] GlyphIndex\" };\n\tconst char* fmt = \"[0x%02\" PRIx8 \"] UNKNOWN\";\n\tstatic char buffer[64] = { 0 };\n\n\tif (orderType < ARRAYSIZE(orders))\n\t\tfmt = orders[orderType];\n\n\tsprintf_s(buffer, ARRAYSIZE(buffer), fmt, orderType);\n\treturn buffer;\n}\nstatic const char* secondary_order_string(UINT32 orderType)\n{\n\tconst char* orders[] = { \"[0x%02\" PRIx8 \"] Cache Bitmap\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Color Table\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Bitmap (Compressed)\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Glyph\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Bitmap V2\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Bitmap V2 (Compressed)\",\n\t\t                     \"[0x%02\" PRIx8 \"] UNUSED\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Brush\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Bitmap V3\" };\n\tconst char* fmt = \"[0x%02\" PRIx8 \"] UNKNOWN\";\n\tstatic char buffer[64] = { 0 };\n\n\tif (orderType < ARRAYSIZE(orders))\n\t\tfmt = orders[orderType];\n\n\tsprintf_s(buffer, ARRAYSIZE(buffer), fmt, orderType);\n\treturn buffer;\n}\nstatic const char* altsec_order_string(BYTE orderType)\n{\n\tconst char* orders[] = {\n\t\t\"[0x%02\" PRIx8 \"] Switch Surface\",         \"[0x%02\" PRIx8 \"] Create Offscreen Bitmap\",\n\t\t\"[0x%02\" PRIx8 \"] Stream Bitmap First\",    \"[0x%02\" PRIx8 \"] Stream Bitmap Next\",\n\t\t\"[0x%02\" PRIx8 \"] Create NineGrid Bitmap\", \"[0x%02\" PRIx8 \"] Draw GDI+ First\",\n\t\t\"[0x%02\" PRIx8 \"] Draw GDI+ Next\",         \"[0x%02\" PRIx8 \"] Draw GDI+ End\",\n\t\t\"[0x%02\" PRIx8 \"] Draw GDI+ Cache First\",  \"[0x%02\" PRIx8 \"] Draw GDI+ Cache Next\",\n\t\t\"[0x%02\" PRIx8 \"] Draw GDI+ Cache End\",    \"[0x%02\" PRIx8 \"] Windowing\",\n\t\t\"[0x%02\" PRIx8 \"] Desktop Composition\",    \"[0x%02\" PRIx8 \"] Frame Marker\"\n\t};\n\tconst char* fmt = \"[0x%02\" PRIx8 \"] UNKNOWN\";\n\tstatic char buffer[64] = { 0 };\n\n\tif (orderType < ARRAYSIZE(orders))\n\t\tfmt = orders[orderType];\n\n\tsprintf_s(buffer, ARRAYSIZE(buffer), fmt, orderType);\n\treturn buffer;\n}\n\nstatic INLINE BOOL update_read_coord(wStream* s, INT32* coord, BOOL delta)\n{\n\tINT8 lsi8;\n\tINT16 lsi16;\n\n\tif (delta)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_INT8(s, lsi8);\n\t\t*coord += lsi8;\n\t}\n\telse\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_INT16(s, lsi16);\n\t\t*coord = lsi16;\n\t}\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_write_coord(wStream* s, INT32 coord)\n{\n\tStream_Write_UINT16(s, coord);\n\treturn TRUE;\n}\nstatic INLINE BOOL update_read_color(wStream* s, UINT32* color)\n{\n\tBYTE byte;\n\n\tif (Stream_GetRemainingLength(s) < 3)\n\t\treturn FALSE;\n\n\t*color = 0;\n\tStream_Read_UINT8(s, byte);\n\t*color = (UINT32)byte;\n\tStream_Read_UINT8(s, byte);\n\t*color |= ((UINT32)byte << 8) & 0xFF00;\n\tStream_Read_UINT8(s, byte);\n\t*color |= ((UINT32)byte << 16) & 0xFF0000;\n\treturn TRUE;\n}\nstatic INLINE BOOL update_write_color(wStream* s, UINT32 color)\n{\n\tBYTE byte;\n\tbyte = (color & 0xFF);\n\tStream_Write_UINT8(s, byte);\n\tbyte = ((color >> 8) & 0xFF);\n\tStream_Write_UINT8(s, byte);\n\tbyte = ((color >> 16) & 0xFF);\n\tStream_Write_UINT8(s, byte);\n\treturn TRUE;\n}\nstatic INLINE BOOL update_read_colorref(wStream* s, UINT32* color)\n{\n\tBYTE byte;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\t*color = 0;\n\tStream_Read_UINT8(s, byte);\n\t*color = byte;\n\tStream_Read_UINT8(s, byte);\n\t*color |= ((UINT32)byte << 8);\n\tStream_Read_UINT8(s, byte);\n\t*color |= ((UINT32)byte << 16);\n\tStream_Seek_UINT8(s);\n\treturn TRUE;\n}\nstatic INLINE BOOL update_read_color_quad(wStream* s, UINT32* color)\n{\n\treturn update_read_colorref(s, color);\n}\nstatic INLINE void update_write_color_quad(wStream* s, UINT32 color)\n{\n\tBYTE byte;\n\tbyte = (color >> 16) & 0xFF;\n\tStream_Write_UINT8(s, byte);\n\tbyte = (color >> 8) & 0xFF;\n\tStream_Write_UINT8(s, byte);\n\tbyte = color & 0xFF;\n\tStream_Write_UINT8(s, byte);\n}\nstatic INLINE BOOL update_read_2byte_unsigned(wStream* s, UINT32* value)\n{\n\tBYTE byte;\n\n\tif (Stream_GetRemainingLength(s) < 1)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, byte);\n\n\tif (byte & 0x80)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\t*value = (byte & 0x7F) << 8;\n\t\tStream_Read_UINT8(s, byte);\n\t\t*value |= byte;\n\t}\n\telse\n\t{\n\t\t*value = (byte & 0x7F);\n\t}\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_write_2byte_unsigned(wStream* s, UINT32 value)\n{\n\tBYTE byte;\n\n\tif (value > 0x7FFF)\n\t\treturn FALSE;\n\n\tif (value >= 0x7F)\n\t{\n\t\tbyte = ((value & 0x7F00) >> 8);\n\t\tStream_Write_UINT8(s, byte | 0x80);\n\t\tbyte = (value & 0xFF);\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\telse\n\t{\n\t\tbyte = (value & 0x7F);\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_read_2byte_signed(wStream* s, INT32* value)\n{\n\tBYTE byte;\n\tBOOL negative;\n\n\tif (Stream_GetRemainingLength(s) < 1)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, byte);\n\tnegative = (byte & 0x40) ? TRUE : FALSE;\n\t*value = (byte & 0x3F);\n\n\tif (byte & 0x80)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, byte);\n\t\t*value = (*value << 8) | byte;\n\t}\n\n\tif (negative)\n\t\t*value *= -1;\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_write_2byte_signed(wStream* s, INT32 value)\n{\n\tBYTE byte;\n\tBOOL negative = FALSE;\n\n\tif (value < 0)\n\t{\n\t\tnegative = TRUE;\n\t\tvalue *= -1;\n\t}\n\n\tif (value > 0x3FFF)\n\t\treturn FALSE;\n\n\tif (value >= 0x3F)\n\t{\n\t\tbyte = ((value & 0x3F00) >> 8);\n\n\t\tif (negative)\n\t\t\tbyte |= 0x40;\n\n\t\tStream_Write_UINT8(s, byte | 0x80);\n\t\tbyte = (value & 0xFF);\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\telse\n\t{\n\t\tbyte = (value & 0x3F);\n\n\t\tif (negative)\n\t\t\tbyte |= 0x40;\n\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_read_4byte_unsigned(wStream* s, UINT32* value)\n{\n\tBYTE byte;\n\tBYTE count;\n\n\tif (Stream_GetRemainingLength(s) < 1)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, byte);\n\tcount = (byte & 0xC0) >> 6;\n\n\tif (Stream_GetRemainingLength(s) < count)\n\t\treturn FALSE;\n\n\tswitch (count)\n\t{\n\t\tcase 0:\n\t\t\t*value = (byte & 0x3F);\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\t*value = (byte & 0x3F) << 8;\n\t\t\tStream_Read_UINT8(s, byte);\n\t\t\t*value |= byte;\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\t*value = (byte & 0x3F) << 16;\n\t\t\tStream_Read_UINT8(s, byte);\n\t\t\t*value |= (byte << 8);\n\t\t\tStream_Read_UINT8(s, byte);\n\t\t\t*value |= byte;\n\t\t\tbreak;\n\n\t\tcase 3:\n\t\t\t*value = (byte & 0x3F) << 24;\n\t\t\tStream_Read_UINT8(s, byte);\n\t\t\t*value |= (byte << 16);\n\t\t\tStream_Read_UINT8(s, byte);\n\t\t\t*value |= (byte << 8);\n\t\t\tStream_Read_UINT8(s, byte);\n\t\t\t*value |= byte;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_write_4byte_unsigned(wStream* s, UINT32 value)\n{\n\tBYTE byte;\n\n\tif (value <= 0x3F)\n\t{\n\t\tStream_Write_UINT8(s, value);\n\t}\n\telse if (value <= 0x3FFF)\n\t{\n\t\tbyte = (value >> 8) & 0x3F;\n\t\tStream_Write_UINT8(s, byte | 0x40);\n\t\tbyte = (value & 0xFF);\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\telse if (value <= 0x3FFFFF)\n\t{\n\t\tbyte = (value >> 16) & 0x3F;\n\t\tStream_Write_UINT8(s, byte | 0x80);\n\t\tbyte = (value >> 8) & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t\tbyte = (value & 0xFF);\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\telse if (value <= 0x3FFFFFFF)\n\t{\n\t\tbyte = (value >> 24) & 0x3F;\n\t\tStream_Write_UINT8(s, byte | 0xC0);\n\t\tbyte = (value >> 16) & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t\tbyte = (value >> 8) & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t\tbyte = (value & 0xFF);\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\telse\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_read_delta(wStream* s, INT32* value)\n{\n\tBYTE byte;\n\n\tif (Stream_GetRemainingLength(s) < 1)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < 1\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT8(s, byte);\n\n\tif (byte & 0x40)\n\t\t*value = (byte | ~0x3F);\n\telse\n\t\t*value = (byte & 0x3F);\n\n\tif (byte & 0x80)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < 1\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tStream_Read_UINT8(s, byte);\n\t\t*value = (*value << 8) | byte;\n\t}\n\n\treturn TRUE;\n}\n#if 0\nstatic INLINE void update_read_glyph_delta(wStream* s, UINT16* value)\n{\n\tBYTE byte;\n\tStream_Read_UINT8(s, byte);\n\n\tif (byte == 0x80)\n\t\tStream_Read_UINT16(s, *value);\n\telse\n\t\t*value = (byte & 0x3F);\n}\nstatic INLINE void update_seek_glyph_delta(wStream* s)\n{\n\tBYTE byte;\n\tStream_Read_UINT8(s, byte);\n\n\tif (byte & 0x80)\n\t\tStream_Seek_UINT8(s);\n}\n#endif\nstatic INLINE BOOL update_read_brush(wStream* s, rdpBrush* brush, BYTE fieldFlags)\n{\n\tif (fieldFlags & ORDER_FIELD_01)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, brush->x);\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_02)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, brush->y);\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_03)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, brush->style);\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_04)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, brush->hatch);\n\t}\n\n\tif (brush->style & CACHED_BRUSH)\n\t{\n\t\tbrush->index = brush->hatch;\n\t\tbrush->bpp = BMF_BPP[brush->style & 0x07];\n\n\t\tif (brush->bpp == 0)\n\t\t\tbrush->bpp = 1;\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_05)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 7)\n\t\t\treturn FALSE;\n\n\t\tbrush->data = (BYTE*)brush->p8x8;\n\t\tStream_Read_UINT8(s, brush->data[7]);\n\t\tStream_Read_UINT8(s, brush->data[6]);\n\t\tStream_Read_UINT8(s, brush->data[5]);\n\t\tStream_Read_UINT8(s, brush->data[4]);\n\t\tStream_Read_UINT8(s, brush->data[3]);\n\t\tStream_Read_UINT8(s, brush->data[2]);\n\t\tStream_Read_UINT8(s, brush->data[1]);\n\t\tbrush->data[0] = brush->hatch;\n\t}\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_write_brush(wStream* s, rdpBrush* brush, BYTE fieldFlags)\n{\n\tif (fieldFlags & ORDER_FIELD_01)\n\t{\n\t\tStream_Write_UINT8(s, brush->x);\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_02)\n\t{\n\t\tStream_Write_UINT8(s, brush->y);\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_03)\n\t{\n\t\tStream_Write_UINT8(s, brush->style);\n\t}\n\n\tif (brush->style & CACHED_BRUSH)\n\t{\n\t\tbrush->hatch = brush->index;\n\t\tbrush->bpp = BMF_BPP[brush->style & 0x07];\n\n\t\tif (brush->bpp == 0)\n\t\t\tbrush->bpp = 1;\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_04)\n\t{\n\t\tStream_Write_UINT8(s, brush->hatch);\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_05)\n\t{\n\t\tbrush->data = (BYTE*)brush->p8x8;\n\t\tStream_Write_UINT8(s, brush->data[7]);\n\t\tStream_Write_UINT8(s, brush->data[6]);\n\t\tStream_Write_UINT8(s, brush->data[5]);\n\t\tStream_Write_UINT8(s, brush->data[4]);\n\t\tStream_Write_UINT8(s, brush->data[3]);\n\t\tStream_Write_UINT8(s, brush->data[2]);\n\t\tStream_Write_UINT8(s, brush->data[1]);\n\t\tbrush->data[0] = brush->hatch;\n\t}\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_read_delta_rects(wStream* s, DELTA_RECT* rectangles, UINT32 number)\n{\n\tUINT32 i;\n\tBYTE flags = 0;\n\tBYTE* zeroBits;\n\tUINT32 zeroBitsSize;\n\n\tif (number > 45)\n\t\tnumber = 45;\n\n\tzeroBitsSize = ((number + 1) / 2);\n\n\tif (Stream_GetRemainingLength(s) < zeroBitsSize)\n\t\treturn FALSE;\n\n\tStream_GetPointer(s, zeroBits);\n\tStream_Seek(s, zeroBitsSize);\n\tZeroMemory(rectangles, sizeof(DELTA_RECT) * number);\n\n\tfor (i = 0; i < number; i++)\n\t{\n\t\tif (i % 2 == 0)\n\t\t\tflags = zeroBits[i / 2];\n\n\t\tif ((~flags & 0x80) && !update_read_delta(s, &rectangles[i].left))\n\t\t\treturn FALSE;\n\n\t\tif ((~flags & 0x40) && !update_read_delta(s, &rectangles[i].top))\n\t\t\treturn FALSE;\n\n\t\tif (~flags & 0x20)\n\t\t{\n\t\t\tif (!update_read_delta(s, &rectangles[i].width))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse if (i > 0)\n\t\t\trectangles[i].width = rectangles[i - 1].width;\n\t\telse\n\t\t\trectangles[i].width = 0;\n\n\t\tif (~flags & 0x10)\n\t\t{\n\t\t\tif (!update_read_delta(s, &rectangles[i].height))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse if (i > 0)\n\t\t\trectangles[i].height = rectangles[i - 1].height;\n\t\telse\n\t\t\trectangles[i].height = 0;\n\n\t\tif (i > 0)\n\t\t{\n\t\t\trectangles[i].left += rectangles[i - 1].left;\n\t\t\trectangles[i].top += rectangles[i - 1].top;\n\t\t}\n\n\t\tflags <<= 4;\n\t}\n\n\treturn TRUE;\n}\nstatic INLINE BOOL update_read_delta_points(wStream* s, DELTA_POINT* points, int number, INT16 x,\n                                            INT16 y)\n{\n\tint i;\n\tBYTE flags = 0;\n\tBYTE* zeroBits;\n\tUINT32 zeroBitsSize;\n\tzeroBitsSize = ((number + 3) / 4);\n\n\tif (Stream_GetRemainingLength(s) < zeroBitsSize)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < %\" PRIu32 \"\", zeroBitsSize);\n\t\treturn FALSE;\n\t}\n\n\tStream_GetPointer(s, zeroBits);\n\tStream_Seek(s, zeroBitsSize);\n\tZeroMemory(points, sizeof(DELTA_POINT) * number);\n\n\tfor (i = 0; i < number; i++)\n\t{\n\t\tif (i % 4 == 0)\n\t\t\tflags = zeroBits[i / 4];\n\n\t\tif ((~flags & 0x80) && !update_read_delta(s, &points[i].x))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"update_read_delta(x) failed\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tif ((~flags & 0x40) && !update_read_delta(s, &points[i].y))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"update_read_delta(y) failed\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tflags <<= 2;\n\t}\n\n\treturn TRUE;\n}\n#define ORDER_FIELD_BYTE(NO, TARGET)                        \\\n\tdo                                                      \\\n\t{                                                       \\\n\t\tif (orderInfo->fieldFlags & (1 << (NO - 1)))        \\\n\t\t{                                                   \\\n\t\t\tif (Stream_GetRemainingLength(s) < 1)           \\\n\t\t\t{                                               \\\n\t\t\t\tWLog_ERR(TAG, \"error reading %s\", #TARGET); \\\n\t\t\t\treturn FALSE;                               \\\n\t\t\t}                                               \\\n\t\t\tStream_Read_UINT8(s, TARGET);                   \\\n\t\t}                                                   \\\n\t} while (0)\n#define ORDER_FIELD_2BYTE(NO, TARGET1, TARGET2)                              \\\n\tdo                                                                       \\\n\t{                                                                        \\\n\t\tif (orderInfo->fieldFlags & (1 << (NO - 1)))                         \\\n\t\t{                                                                    \\\n\t\t\tif (Stream_GetRemainingLength(s) < 2)                            \\\n\t\t\t{                                                                \\\n\t\t\t\tWLog_ERR(TAG, \"error reading %s or %s\", #TARGET1, #TARGET2); \\\n\t\t\t\treturn FALSE;                                                \\\n\t\t\t}                                                                \\\n\t\t\tStream_Read_UINT8(s, TARGET1);                                   \\\n\t\t\tStream_Read_UINT8(s, TARGET2);                                   \\\n\t\t}                                                                    \\\n\t} while (0)\n#define ORDER_FIELD_UINT16(NO, TARGET)                      \\\n\tdo                                                      \\\n\t{                                                       \\\n\t\tif (orderInfo->fieldFlags & (1 << (NO - 1)))        \\\n\t\t{                                                   \\\n\t\t\tif (Stream_GetRemainingLength(s) < 2)           \\\n\t\t\t{                                               \\\n\t\t\t\tWLog_ERR(TAG, \"error reading %s\", #TARGET); \\\n\t\t\t\treturn FALSE;                               \\\n\t\t\t}                                               \\\n\t\t\tStream_Read_UINT16(s, TARGET);                  \\\n\t\t}                                                   \\\n\t} while (0)\n#define ORDER_FIELD_UINT32(NO, TARGET)                      \\\n\tdo                                                      \\\n\t{                                                       \\\n\t\tif (orderInfo->fieldFlags & (1 << (NO - 1)))        \\\n\t\t{                                                   \\\n\t\t\tif (Stream_GetRemainingLength(s) < 4)           \\\n\t\t\t{                                               \\\n\t\t\t\tWLog_ERR(TAG, \"error reading %s\", #TARGET); \\\n\t\t\t\treturn FALSE;                               \\\n\t\t\t}                                               \\\n\t\t\tStream_Read_UINT32(s, TARGET);                  \\\n\t\t}                                                   \\\n\t} while (0)\n#define ORDER_FIELD_COORD(NO, TARGET)                                    \\\n\tdo                                                                   \\\n\t{                                                                    \\\n\t\tif ((orderInfo->fieldFlags & (1 << (NO - 1))) &&                 \\\n\t\t    !update_read_coord(s, &TARGET, orderInfo->deltaCoordinates)) \\\n\t\t{                                                                \\\n\t\t\tWLog_ERR(TAG, \"error reading %s\", #TARGET);                  \\\n\t\t\treturn FALSE;                                                \\\n\t\t}                                                                \\\n\t} while (0)\nstatic INLINE BOOL ORDER_FIELD_COLOR(const ORDER_INFO* orderInfo, wStream* s, UINT32 NO,\n                                     UINT32* TARGET)\n{\n\tif (!TARGET || !orderInfo)\n\t\treturn FALSE;\n\n\tif ((orderInfo->fieldFlags & (1 << (NO - 1))) && !update_read_color(s, TARGET))\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\nstatic INLINE BOOL FIELD_SKIP_BUFFER16(wStream* s, UINT32 TARGET_LEN)\n{\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, TARGET_LEN);\n\n\tif (!Stream_SafeSeek(s, TARGET_LEN))\n\t{\n\t\tWLog_ERR(TAG, \"error skipping %\" PRIu32 \" bytes\", TARGET_LEN);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n/* Primary Drawing Orders */\nstatic BOOL update_read_dstblt_order(wStream* s, const ORDER_INFO* orderInfo, DSTBLT_ORDER* dstblt)\n{\n\tORDER_FIELD_COORD(1, dstblt->nLeftRect);\n\tORDER_FIELD_COORD(2, dstblt->nTopRect);\n\tORDER_FIELD_COORD(3, dstblt->nWidth);\n\tORDER_FIELD_COORD(4, dstblt->nHeight);\n\tORDER_FIELD_BYTE(5, dstblt->bRop);\n\treturn TRUE;\n}\nint update_approximate_dstblt_order(ORDER_INFO* orderInfo, const DSTBLT_ORDER* dstblt)\n{\n\treturn 32;\n}\nBOOL update_write_dstblt_order(wStream* s, ORDER_INFO* orderInfo, const DSTBLT_ORDER* dstblt)\n{\n\tif (!Stream_EnsureRemainingCapacity(s, update_approximate_dstblt_order(orderInfo, dstblt)))\n\t\treturn FALSE;\n\n\torderInfo->fieldFlags = 0;\n\torderInfo->fieldFlags |= ORDER_FIELD_01;\n\tupdate_write_coord(s, dstblt->nLeftRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_02;\n\tupdate_write_coord(s, dstblt->nTopRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_03;\n\tupdate_write_coord(s, dstblt->nWidth);\n\torderInfo->fieldFlags |= ORDER_FIELD_04;\n\tupdate_write_coord(s, dstblt->nHeight);\n\torderInfo->fieldFlags |= ORDER_FIELD_05;\n\tStream_Write_UINT8(s, dstblt->bRop);\n\treturn TRUE;\n}\nstatic BOOL update_read_patblt_order(wStream* s, const ORDER_INFO* orderInfo, PATBLT_ORDER* patblt)\n{\n\tORDER_FIELD_COORD(1, patblt->nLeftRect);\n\tORDER_FIELD_COORD(2, patblt->nTopRect);\n\tORDER_FIELD_COORD(3, patblt->nWidth);\n\tORDER_FIELD_COORD(4, patblt->nHeight);\n\tORDER_FIELD_BYTE(5, patblt->bRop);\n\tORDER_FIELD_COLOR(orderInfo, s, 6, &patblt->backColor);\n\tORDER_FIELD_COLOR(orderInfo, s, 7, &patblt->foreColor);\n\treturn update_read_brush(s, &patblt->brush, orderInfo->fieldFlags >> 7);\n}\nint update_approximate_patblt_order(ORDER_INFO* orderInfo, PATBLT_ORDER* patblt)\n{\n\treturn 32;\n}\nBOOL update_write_patblt_order(wStream* s, ORDER_INFO* orderInfo, PATBLT_ORDER* patblt)\n{\n\tif (!Stream_EnsureRemainingCapacity(s, update_approximate_patblt_order(orderInfo, patblt)))\n\t\treturn FALSE;\n\n\torderInfo->fieldFlags = 0;\n\torderInfo->fieldFlags |= ORDER_FIELD_01;\n\tupdate_write_coord(s, patblt->nLeftRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_02;\n\tupdate_write_coord(s, patblt->nTopRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_03;\n\tupdate_write_coord(s, patblt->nWidth);\n\torderInfo->fieldFlags |= ORDER_FIELD_04;\n\tupdate_write_coord(s, patblt->nHeight);\n\torderInfo->fieldFlags |= ORDER_FIELD_05;\n\tStream_Write_UINT8(s, patblt->bRop);\n\torderInfo->fieldFlags |= ORDER_FIELD_06;\n\tupdate_write_color(s, patblt->backColor);\n\torderInfo->fieldFlags |= ORDER_FIELD_07;\n\tupdate_write_color(s, patblt->foreColor);\n\torderInfo->fieldFlags |= ORDER_FIELD_08;\n\torderInfo->fieldFlags |= ORDER_FIELD_09;\n\torderInfo->fieldFlags |= ORDER_FIELD_10;\n\torderInfo->fieldFlags |= ORDER_FIELD_11;\n\torderInfo->fieldFlags |= ORDER_FIELD_12;\n\tupdate_write_brush(s, &patblt->brush, orderInfo->fieldFlags >> 7);\n\treturn TRUE;\n}\nstatic BOOL update_read_scrblt_order(wStream* s, const ORDER_INFO* orderInfo, SCRBLT_ORDER* scrblt)\n{\n\tORDER_FIELD_COORD(1, scrblt->nLeftRect);\n\tORDER_FIELD_COORD(2, scrblt->nTopRect);\n\tORDER_FIELD_COORD(3, scrblt->nWidth);\n\tORDER_FIELD_COORD(4, scrblt->nHeight);\n\tORDER_FIELD_BYTE(5, scrblt->bRop);\n\tORDER_FIELD_COORD(6, scrblt->nXSrc);\n\tORDER_FIELD_COORD(7, scrblt->nYSrc);\n\treturn TRUE;\n}\nint update_approximate_scrblt_order(ORDER_INFO* orderInfo, const SCRBLT_ORDER* scrblt)\n{\n\treturn 32;\n}\nBOOL update_write_scrblt_order(wStream* s, ORDER_INFO* orderInfo, const SCRBLT_ORDER* scrblt)\n{\n\tif (!Stream_EnsureRemainingCapacity(s, update_approximate_scrblt_order(orderInfo, scrblt)))\n\t\treturn FALSE;\n\n\torderInfo->fieldFlags = 0;\n\torderInfo->fieldFlags |= ORDER_FIELD_01;\n\tupdate_write_coord(s, scrblt->nLeftRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_02;\n\tupdate_write_coord(s, scrblt->nTopRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_03;\n\tupdate_write_coord(s, scrblt->nWidth);\n\torderInfo->fieldFlags |= ORDER_FIELD_04;\n\tupdate_write_coord(s, scrblt->nHeight);\n\torderInfo->fieldFlags |= ORDER_FIELD_05;\n\tStream_Write_UINT8(s, scrblt->bRop);\n\torderInfo->fieldFlags |= ORDER_FIELD_06;\n\tupdate_write_coord(s, scrblt->nXSrc);\n\torderInfo->fieldFlags |= ORDER_FIELD_07;\n\tupdate_write_coord(s, scrblt->nYSrc);\n\treturn TRUE;\n}\nstatic BOOL update_read_opaque_rect_order(wStream* s, const ORDER_INFO* orderInfo,\n                                          OPAQUE_RECT_ORDER* opaque_rect)\n{\n\tBYTE byte;\n\tORDER_FIELD_COORD(1, opaque_rect->nLeftRect);\n\tORDER_FIELD_COORD(2, opaque_rect->nTopRect);\n\tORDER_FIELD_COORD(3, opaque_rect->nWidth);\n\tORDER_FIELD_COORD(4, opaque_rect->nHeight);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_05)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, byte);\n\t\topaque_rect->color = (opaque_rect->color & 0x00FFFF00) | ((UINT32)byte);\n\t}\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_06)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, byte);\n\t\topaque_rect->color = (opaque_rect->color & 0x00FF00FF) | ((UINT32)byte << 8);\n\t}\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_07)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, byte);\n\t\topaque_rect->color = (opaque_rect->color & 0x0000FFFF) | ((UINT32)byte << 16);\n\t}\n\n\treturn TRUE;\n}\nint update_approximate_opaque_rect_order(ORDER_INFO* orderInfo,\n                                         const OPAQUE_RECT_ORDER* opaque_rect)\n{\n\treturn 32;\n}\nBOOL update_write_opaque_rect_order(wStream* s, ORDER_INFO* orderInfo,\n                                    const OPAQUE_RECT_ORDER* opaque_rect)\n{\n\tBYTE byte;\n\tint inf = update_approximate_opaque_rect_order(orderInfo, opaque_rect);\n\n\tif (!Stream_EnsureRemainingCapacity(s, inf))\n\t\treturn FALSE;\n\n\t// TODO: Color format conversion\n\torderInfo->fieldFlags = 0;\n\torderInfo->fieldFlags |= ORDER_FIELD_01;\n\tupdate_write_coord(s, opaque_rect->nLeftRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_02;\n\tupdate_write_coord(s, opaque_rect->nTopRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_03;\n\tupdate_write_coord(s, opaque_rect->nWidth);\n\torderInfo->fieldFlags |= ORDER_FIELD_04;\n\tupdate_write_coord(s, opaque_rect->nHeight);\n\torderInfo->fieldFlags |= ORDER_FIELD_05;\n\tbyte = opaque_rect->color & 0x000000FF;\n\tStream_Write_UINT8(s, byte);\n\torderInfo->fieldFlags |= ORDER_FIELD_06;\n\tbyte = (opaque_rect->color & 0x0000FF00) >> 8;\n\tStream_Write_UINT8(s, byte);\n\torderInfo->fieldFlags |= ORDER_FIELD_07;\n\tbyte = (opaque_rect->color & 0x00FF0000) >> 16;\n\tStream_Write_UINT8(s, byte);\n\treturn TRUE;\n}\nstatic BOOL update_read_draw_nine_grid_order(wStream* s, const ORDER_INFO* orderInfo,\n                                             DRAW_NINE_GRID_ORDER* draw_nine_grid)\n{\n\tORDER_FIELD_COORD(1, draw_nine_grid->srcLeft);\n\tORDER_FIELD_COORD(2, draw_nine_grid->srcTop);\n\tORDER_FIELD_COORD(3, draw_nine_grid->srcRight);\n\tORDER_FIELD_COORD(4, draw_nine_grid->srcBottom);\n\tORDER_FIELD_UINT16(5, draw_nine_grid->bitmapId);\n\treturn TRUE;\n}\nstatic BOOL update_read_multi_dstblt_order(wStream* s, const ORDER_INFO* orderInfo,\n                                           MULTI_DSTBLT_ORDER* multi_dstblt)\n{\n\tORDER_FIELD_COORD(1, multi_dstblt->nLeftRect);\n\tORDER_FIELD_COORD(2, multi_dstblt->nTopRect);\n\tORDER_FIELD_COORD(3, multi_dstblt->nWidth);\n\tORDER_FIELD_COORD(4, multi_dstblt->nHeight);\n\tORDER_FIELD_BYTE(5, multi_dstblt->bRop);\n\tORDER_FIELD_BYTE(6, multi_dstblt->numRectangles);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_07)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, multi_dstblt->cbData);\n\t\treturn update_read_delta_rects(s, multi_dstblt->rectangles, multi_dstblt->numRectangles);\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_multi_patblt_order(wStream* s, const ORDER_INFO* orderInfo,\n                                           MULTI_PATBLT_ORDER* multi_patblt)\n{\n\tORDER_FIELD_COORD(1, multi_patblt->nLeftRect);\n\tORDER_FIELD_COORD(2, multi_patblt->nTopRect);\n\tORDER_FIELD_COORD(3, multi_patblt->nWidth);\n\tORDER_FIELD_COORD(4, multi_patblt->nHeight);\n\tORDER_FIELD_BYTE(5, multi_patblt->bRop);\n\tORDER_FIELD_COLOR(orderInfo, s, 6, &multi_patblt->backColor);\n\tORDER_FIELD_COLOR(orderInfo, s, 7, &multi_patblt->foreColor);\n\n\tif (!update_read_brush(s, &multi_patblt->brush, orderInfo->fieldFlags >> 7))\n\t\treturn FALSE;\n\n\tORDER_FIELD_BYTE(13, multi_patblt->numRectangles);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_14)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, multi_patblt->cbData);\n\n\t\tif (!update_read_delta_rects(s, multi_patblt->rectangles, multi_patblt->numRectangles))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_multi_scrblt_order(wStream* s, const ORDER_INFO* orderInfo,\n                                           MULTI_SCRBLT_ORDER* multi_scrblt)\n{\n\tORDER_FIELD_COORD(1, multi_scrblt->nLeftRect);\n\tORDER_FIELD_COORD(2, multi_scrblt->nTopRect);\n\tORDER_FIELD_COORD(3, multi_scrblt->nWidth);\n\tORDER_FIELD_COORD(4, multi_scrblt->nHeight);\n\tORDER_FIELD_BYTE(5, multi_scrblt->bRop);\n\tORDER_FIELD_COORD(6, multi_scrblt->nXSrc);\n\tORDER_FIELD_COORD(7, multi_scrblt->nYSrc);\n\tORDER_FIELD_BYTE(8, multi_scrblt->numRectangles);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_09)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, multi_scrblt->cbData);\n\t\treturn update_read_delta_rects(s, multi_scrblt->rectangles, multi_scrblt->numRectangles);\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_multi_opaque_rect_order(wStream* s, const ORDER_INFO* orderInfo,\n                                                MULTI_OPAQUE_RECT_ORDER* multi_opaque_rect)\n{\n\tBYTE byte;\n\tORDER_FIELD_COORD(1, multi_opaque_rect->nLeftRect);\n\tORDER_FIELD_COORD(2, multi_opaque_rect->nTopRect);\n\tORDER_FIELD_COORD(3, multi_opaque_rect->nWidth);\n\tORDER_FIELD_COORD(4, multi_opaque_rect->nHeight);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_05)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, byte);\n\t\tmulti_opaque_rect->color = (multi_opaque_rect->color & 0x00FFFF00) | ((UINT32)byte);\n\t}\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_06)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, byte);\n\t\tmulti_opaque_rect->color = (multi_opaque_rect->color & 0x00FF00FF) | ((UINT32)byte << 8);\n\t}\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_07)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, byte);\n\t\tmulti_opaque_rect->color = (multi_opaque_rect->color & 0x0000FFFF) | ((UINT32)byte << 16);\n\t}\n\n\tORDER_FIELD_BYTE(8, multi_opaque_rect->numRectangles);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_09)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, multi_opaque_rect->cbData);\n\t\treturn update_read_delta_rects(s, multi_opaque_rect->rectangles,\n\t\t                               multi_opaque_rect->numRectangles);\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_multi_draw_nine_grid_order(wStream* s, const ORDER_INFO* orderInfo,\n                                                   MULTI_DRAW_NINE_GRID_ORDER* multi_draw_nine_grid)\n{\n\tORDER_FIELD_COORD(1, multi_draw_nine_grid->srcLeft);\n\tORDER_FIELD_COORD(2, multi_draw_nine_grid->srcTop);\n\tORDER_FIELD_COORD(3, multi_draw_nine_grid->srcRight);\n\tORDER_FIELD_COORD(4, multi_draw_nine_grid->srcBottom);\n\tORDER_FIELD_UINT16(5, multi_draw_nine_grid->bitmapId);\n\tORDER_FIELD_BYTE(6, multi_draw_nine_grid->nDeltaEntries);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_07)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, multi_draw_nine_grid->cbData);\n\t\treturn update_read_delta_rects(s, multi_draw_nine_grid->rectangles,\n\t\t                               multi_draw_nine_grid->nDeltaEntries);\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_line_to_order(wStream* s, const ORDER_INFO* orderInfo,\n                                      LINE_TO_ORDER* line_to)\n{\n\tORDER_FIELD_UINT16(1, line_to->backMode);\n\tORDER_FIELD_COORD(2, line_to->nXStart);\n\tORDER_FIELD_COORD(3, line_to->nYStart);\n\tORDER_FIELD_COORD(4, line_to->nXEnd);\n\tORDER_FIELD_COORD(5, line_to->nYEnd);\n\tORDER_FIELD_COLOR(orderInfo, s, 6, &line_to->backColor);\n\tORDER_FIELD_BYTE(7, line_to->bRop2);\n\tORDER_FIELD_BYTE(8, line_to->penStyle);\n\tORDER_FIELD_BYTE(9, line_to->penWidth);\n\tORDER_FIELD_COLOR(orderInfo, s, 10, &line_to->penColor);\n\treturn TRUE;\n}\nint update_approximate_line_to_order(ORDER_INFO* orderInfo, const LINE_TO_ORDER* line_to)\n{\n\treturn 32;\n}\nBOOL update_write_line_to_order(wStream* s, ORDER_INFO* orderInfo, const LINE_TO_ORDER* line_to)\n{\n\tif (!Stream_EnsureRemainingCapacity(s, update_approximate_line_to_order(orderInfo, line_to)))\n\t\treturn FALSE;\n\n\torderInfo->fieldFlags = 0;\n\torderInfo->fieldFlags |= ORDER_FIELD_01;\n\tStream_Write_UINT16(s, line_to->backMode);\n\torderInfo->fieldFlags |= ORDER_FIELD_02;\n\tupdate_write_coord(s, line_to->nXStart);\n\torderInfo->fieldFlags |= ORDER_FIELD_03;\n\tupdate_write_coord(s, line_to->nYStart);\n\torderInfo->fieldFlags |= ORDER_FIELD_04;\n\tupdate_write_coord(s, line_to->nXEnd);\n\torderInfo->fieldFlags |= ORDER_FIELD_05;\n\tupdate_write_coord(s, line_to->nYEnd);\n\torderInfo->fieldFlags |= ORDER_FIELD_06;\n\tupdate_write_color(s, line_to->backColor);\n\torderInfo->fieldFlags |= ORDER_FIELD_07;\n\tStream_Write_UINT8(s, line_to->bRop2);\n\torderInfo->fieldFlags |= ORDER_FIELD_08;\n\tStream_Write_UINT8(s, line_to->penStyle);\n\torderInfo->fieldFlags |= ORDER_FIELD_09;\n\tStream_Write_UINT8(s, line_to->penWidth);\n\torderInfo->fieldFlags |= ORDER_FIELD_10;\n\tupdate_write_color(s, line_to->penColor);\n\treturn TRUE;\n}\nstatic BOOL update_read_polyline_order(wStream* s, const ORDER_INFO* orderInfo,\n                                       POLYLINE_ORDER* polyline)\n{\n\tUINT16 word;\n\tUINT32 new_num = polyline->numDeltaEntries;\n\tORDER_FIELD_COORD(1, polyline->xStart);\n\tORDER_FIELD_COORD(2, polyline->yStart);\n\tORDER_FIELD_BYTE(3, polyline->bRop2);\n\tORDER_FIELD_UINT16(4, word);\n\tORDER_FIELD_COLOR(orderInfo, s, 5, &polyline->penColor);\n\tORDER_FIELD_BYTE(6, new_num);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_07)\n\t{\n\t\tDELTA_POINT* new_points;\n\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < 1\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tStream_Read_UINT8(s, polyline->cbData);\n\t\tnew_points = (DELTA_POINT*)realloc(polyline->points, sizeof(DELTA_POINT) * new_num);\n\n\t\tif (!new_points)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"realloc(%\" PRIu32 \") failed\", new_num);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tpolyline->points = new_points;\n\t\tpolyline->numDeltaEntries = new_num;\n\t\treturn update_read_delta_points(s, polyline->points, polyline->numDeltaEntries,\n\t\t                                polyline->xStart, polyline->yStart);\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_memblt_order(wStream* s, const ORDER_INFO* orderInfo, MEMBLT_ORDER* memblt)\n{\n\tif (!s || !orderInfo || !memblt)\n\t\treturn FALSE;\n\n\tORDER_FIELD_UINT16(1, memblt->cacheId);\n\tORDER_FIELD_COORD(2, memblt->nLeftRect);\n\tORDER_FIELD_COORD(3, memblt->nTopRect);\n\tORDER_FIELD_COORD(4, memblt->nWidth);\n\tORDER_FIELD_COORD(5, memblt->nHeight);\n\tORDER_FIELD_BYTE(6, memblt->bRop);\n\tORDER_FIELD_COORD(7, memblt->nXSrc);\n\tORDER_FIELD_COORD(8, memblt->nYSrc);\n\tORDER_FIELD_UINT16(9, memblt->cacheIndex);\n\tmemblt->colorIndex = (memblt->cacheId >> 8);\n\tmemblt->cacheId = (memblt->cacheId & 0xFF);\n\tmemblt->bitmap = NULL;\n\treturn TRUE;\n}\nint update_approximate_memblt_order(ORDER_INFO* orderInfo, const MEMBLT_ORDER* memblt)\n{\n\treturn 64;\n}\nBOOL update_write_memblt_order(wStream* s, ORDER_INFO* orderInfo, const MEMBLT_ORDER* memblt)\n{\n\tUINT16 cacheId;\n\n\tif (!Stream_EnsureRemainingCapacity(s, update_approximate_memblt_order(orderInfo, memblt)))\n\t\treturn FALSE;\n\n\tcacheId = (memblt->cacheId & 0xFF) | ((memblt->colorIndex & 0xFF) << 8);\n\torderInfo->fieldFlags |= ORDER_FIELD_01;\n\tStream_Write_UINT16(s, cacheId);\n\torderInfo->fieldFlags |= ORDER_FIELD_02;\n\tupdate_write_coord(s, memblt->nLeftRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_03;\n\tupdate_write_coord(s, memblt->nTopRect);\n\torderInfo->fieldFlags |= ORDER_FIELD_04;\n\tupdate_write_coord(s, memblt->nWidth);\n\torderInfo->fieldFlags |= ORDER_FIELD_05;\n\tupdate_write_coord(s, memblt->nHeight);\n\torderInfo->fieldFlags |= ORDER_FIELD_06;\n\tStream_Write_UINT8(s, memblt->bRop);\n\torderInfo->fieldFlags |= ORDER_FIELD_07;\n\tupdate_write_coord(s, memblt->nXSrc);\n\torderInfo->fieldFlags |= ORDER_FIELD_08;\n\tupdate_write_coord(s, memblt->nYSrc);\n\torderInfo->fieldFlags |= ORDER_FIELD_09;\n\tStream_Write_UINT16(s, memblt->cacheIndex);\n\treturn TRUE;\n}\nstatic BOOL update_read_mem3blt_order(wStream* s, const ORDER_INFO* orderInfo,\n                                      MEM3BLT_ORDER* mem3blt)\n{\n\tORDER_FIELD_UINT16(1, mem3blt->cacheId);\n\tORDER_FIELD_COORD(2, mem3blt->nLeftRect);\n\tORDER_FIELD_COORD(3, mem3blt->nTopRect);\n\tORDER_FIELD_COORD(4, mem3blt->nWidth);\n\tORDER_FIELD_COORD(5, mem3blt->nHeight);\n\tORDER_FIELD_BYTE(6, mem3blt->bRop);\n\tORDER_FIELD_COORD(7, mem3blt->nXSrc);\n\tORDER_FIELD_COORD(8, mem3blt->nYSrc);\n\tORDER_FIELD_COLOR(orderInfo, s, 9, &mem3blt->backColor);\n\tORDER_FIELD_COLOR(orderInfo, s, 10, &mem3blt->foreColor);\n\n\tif (!update_read_brush(s, &mem3blt->brush, orderInfo->fieldFlags >> 10))\n\t\treturn FALSE;\n\n\tORDER_FIELD_UINT16(16, mem3blt->cacheIndex);\n\tmem3blt->colorIndex = (mem3blt->cacheId >> 8);\n\tmem3blt->cacheId = (mem3blt->cacheId & 0xFF);\n\tmem3blt->bitmap = NULL;\n\treturn TRUE;\n}\nstatic BOOL update_read_save_bitmap_order(wStream* s, const ORDER_INFO* orderInfo,\n                                          SAVE_BITMAP_ORDER* save_bitmap)\n{\n\tORDER_FIELD_UINT32(1, save_bitmap->savedBitmapPosition);\n\tORDER_FIELD_COORD(2, save_bitmap->nLeftRect);\n\tORDER_FIELD_COORD(3, save_bitmap->nTopRect);\n\tORDER_FIELD_COORD(4, save_bitmap->nRightRect);\n\tORDER_FIELD_COORD(5, save_bitmap->nBottomRect);\n\tORDER_FIELD_BYTE(6, save_bitmap->operation);\n\treturn TRUE;\n}\nstatic BOOL update_read_glyph_index_order(wStream* s, const ORDER_INFO* orderInfo,\n                                          GLYPH_INDEX_ORDER* glyph_index)\n{\n\tORDER_FIELD_BYTE(1, glyph_index->cacheId);\n\tORDER_FIELD_BYTE(2, glyph_index->flAccel);\n\tORDER_FIELD_BYTE(3, glyph_index->ulCharInc);\n\tORDER_FIELD_BYTE(4, glyph_index->fOpRedundant);\n\tORDER_FIELD_COLOR(orderInfo, s, 5, &glyph_index->backColor);\n\tORDER_FIELD_COLOR(orderInfo, s, 6, &glyph_index->foreColor);\n\tORDER_FIELD_UINT16(7, glyph_index->bkLeft);\n\tORDER_FIELD_UINT16(8, glyph_index->bkTop);\n\tORDER_FIELD_UINT16(9, glyph_index->bkRight);\n\tORDER_FIELD_UINT16(10, glyph_index->bkBottom);\n\tORDER_FIELD_UINT16(11, glyph_index->opLeft);\n\tORDER_FIELD_UINT16(12, glyph_index->opTop);\n\tORDER_FIELD_UINT16(13, glyph_index->opRight);\n\tORDER_FIELD_UINT16(14, glyph_index->opBottom);\n\n\tif (!update_read_brush(s, &glyph_index->brush, orderInfo->fieldFlags >> 14))\n\t\treturn FALSE;\n\n\tORDER_FIELD_UINT16(20, glyph_index->x);\n\tORDER_FIELD_UINT16(21, glyph_index->y);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_22)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, glyph_index->cbData);\n\n\t\tif (Stream_GetRemainingLength(s) < glyph_index->cbData)\n\t\t\treturn FALSE;\n\n\t\tCopyMemory(glyph_index->data, Stream_Pointer(s), glyph_index->cbData);\n\t\tStream_Seek(s, glyph_index->cbData);\n\t}\n\n\treturn TRUE;\n}\nint update_approximate_glyph_index_order(ORDER_INFO* orderInfo,\n                                         const GLYPH_INDEX_ORDER* glyph_index)\n{\n\treturn 64;\n}\nBOOL update_write_glyph_index_order(wStream* s, ORDER_INFO* orderInfo,\n                                    GLYPH_INDEX_ORDER* glyph_index)\n{\n\tint inf = update_approximate_glyph_index_order(orderInfo, glyph_index);\n\n\tif (!Stream_EnsureRemainingCapacity(s, inf))\n\t\treturn FALSE;\n\n\torderInfo->fieldFlags = 0;\n\torderInfo->fieldFlags |= ORDER_FIELD_01;\n\tStream_Write_UINT8(s, glyph_index->cacheId);\n\torderInfo->fieldFlags |= ORDER_FIELD_02;\n\tStream_Write_UINT8(s, glyph_index->flAccel);\n\torderInfo->fieldFlags |= ORDER_FIELD_03;\n\tStream_Write_UINT8(s, glyph_index->ulCharInc);\n\torderInfo->fieldFlags |= ORDER_FIELD_04;\n\tStream_Write_UINT8(s, glyph_index->fOpRedundant);\n\torderInfo->fieldFlags |= ORDER_FIELD_05;\n\tupdate_write_color(s, glyph_index->backColor);\n\torderInfo->fieldFlags |= ORDER_FIELD_06;\n\tupdate_write_color(s, glyph_index->foreColor);\n\torderInfo->fieldFlags |= ORDER_FIELD_07;\n\tStream_Write_UINT16(s, glyph_index->bkLeft);\n\torderInfo->fieldFlags |= ORDER_FIELD_08;\n\tStream_Write_UINT16(s, glyph_index->bkTop);\n\torderInfo->fieldFlags |= ORDER_FIELD_09;\n\tStream_Write_UINT16(s, glyph_index->bkRight);\n\torderInfo->fieldFlags |= ORDER_FIELD_10;\n\tStream_Write_UINT16(s, glyph_index->bkBottom);\n\torderInfo->fieldFlags |= ORDER_FIELD_11;\n\tStream_Write_UINT16(s, glyph_index->opLeft);\n\torderInfo->fieldFlags |= ORDER_FIELD_12;\n\tStream_Write_UINT16(s, glyph_index->opTop);\n\torderInfo->fieldFlags |= ORDER_FIELD_13;\n\tStream_Write_UINT16(s, glyph_index->opRight);\n\torderInfo->fieldFlags |= ORDER_FIELD_14;\n\tStream_Write_UINT16(s, glyph_index->opBottom);\n\torderInfo->fieldFlags |= ORDER_FIELD_15;\n\torderInfo->fieldFlags |= ORDER_FIELD_16;\n\torderInfo->fieldFlags |= ORDER_FIELD_17;\n\torderInfo->fieldFlags |= ORDER_FIELD_18;\n\torderInfo->fieldFlags |= ORDER_FIELD_19;\n\tupdate_write_brush(s, &glyph_index->brush, orderInfo->fieldFlags >> 14);\n\torderInfo->fieldFlags |= ORDER_FIELD_20;\n\tStream_Write_UINT16(s, glyph_index->x);\n\torderInfo->fieldFlags |= ORDER_FIELD_21;\n\tStream_Write_UINT16(s, glyph_index->y);\n\torderInfo->fieldFlags |= ORDER_FIELD_22;\n\tStream_Write_UINT8(s, glyph_index->cbData);\n\tStream_Write(s, glyph_index->data, glyph_index->cbData);\n\treturn TRUE;\n}\nstatic BOOL update_read_fast_index_order(wStream* s, const ORDER_INFO* orderInfo,\n                                         FAST_INDEX_ORDER* fast_index)\n{\n\tORDER_FIELD_BYTE(1, fast_index->cacheId);\n\tORDER_FIELD_2BYTE(2, fast_index->ulCharInc, fast_index->flAccel);\n\tORDER_FIELD_COLOR(orderInfo, s, 3, &fast_index->backColor);\n\tORDER_FIELD_COLOR(orderInfo, s, 4, &fast_index->foreColor);\n\tORDER_FIELD_COORD(5, fast_index->bkLeft);\n\tORDER_FIELD_COORD(6, fast_index->bkTop);\n\tORDER_FIELD_COORD(7, fast_index->bkRight);\n\tORDER_FIELD_COORD(8, fast_index->bkBottom);\n\tORDER_FIELD_COORD(9, fast_index->opLeft);\n\tORDER_FIELD_COORD(10, fast_index->opTop);\n\tORDER_FIELD_COORD(11, fast_index->opRight);\n\tORDER_FIELD_COORD(12, fast_index->opBottom);\n\tORDER_FIELD_COORD(13, fast_index->x);\n\tORDER_FIELD_COORD(14, fast_index->y);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_15)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, fast_index->cbData);\n\n\t\tif (Stream_GetRemainingLength(s) < fast_index->cbData)\n\t\t\treturn FALSE;\n\n\t\tCopyMemory(fast_index->data, Stream_Pointer(s), fast_index->cbData);\n\t\tStream_Seek(s, fast_index->cbData);\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_fast_glyph_order(wStream* s, const ORDER_INFO* orderInfo,\n                                         FAST_GLYPH_ORDER* fastGlyph)\n{\n\tBYTE* phold;\n\tGLYPH_DATA_V2* glyph = &fastGlyph->glyphData;\n\tORDER_FIELD_BYTE(1, fastGlyph->cacheId);\n\tORDER_FIELD_2BYTE(2, fastGlyph->ulCharInc, fastGlyph->flAccel);\n\tORDER_FIELD_COLOR(orderInfo, s, 3, &fastGlyph->backColor);\n\tORDER_FIELD_COLOR(orderInfo, s, 4, &fastGlyph->foreColor);\n\tORDER_FIELD_COORD(5, fastGlyph->bkLeft);\n\tORDER_FIELD_COORD(6, fastGlyph->bkTop);\n\tORDER_FIELD_COORD(7, fastGlyph->bkRight);\n\tORDER_FIELD_COORD(8, fastGlyph->bkBottom);\n\tORDER_FIELD_COORD(9, fastGlyph->opLeft);\n\tORDER_FIELD_COORD(10, fastGlyph->opTop);\n\tORDER_FIELD_COORD(11, fastGlyph->opRight);\n\tORDER_FIELD_COORD(12, fastGlyph->opBottom);\n\tORDER_FIELD_COORD(13, fastGlyph->x);\n\tORDER_FIELD_COORD(14, fastGlyph->y);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_15)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, fastGlyph->cbData);\n\n\t\tif (Stream_GetRemainingLength(s) < fastGlyph->cbData)\n\t\t\treturn FALSE;\n\n\t\tCopyMemory(fastGlyph->data, Stream_Pointer(s), fastGlyph->cbData);\n\t\tphold = Stream_Pointer(s);\n\n\t\tif (!Stream_SafeSeek(s, 1))\n\t\t\treturn FALSE;\n\n\t\tif (fastGlyph->cbData > 1)\n\t\t{\n\t\t\tUINT32 new_cb;\n\t\t\t/* parse optional glyph data */\n\t\t\tglyph->cacheIndex = fastGlyph->data[0];\n\n\t\t\tif (!update_read_2byte_signed(s, &glyph->x) ||\n\t\t\t    !update_read_2byte_signed(s, &glyph->y) ||\n\t\t\t    !update_read_2byte_unsigned(s, &glyph->cx) ||\n\t\t\t    !update_read_2byte_unsigned(s, &glyph->cy))\n\t\t\t\treturn FALSE;\n\n\t\t\tglyph->cb = ((glyph->cx + 7) / 8) * glyph->cy;\n\t\t\tglyph->cb += ((glyph->cb % 4) > 0) ? 4 - (glyph->cb % 4) : 0;\n\t\t\tnew_cb = ((glyph->cx + 7) / 8) * glyph->cy;\n\t\t\tnew_cb += ((new_cb % 4) > 0) ? 4 - (new_cb % 4) : 0;\n\n\t\t\tif (Stream_GetRemainingLength(s) < new_cb)\n\t\t\t\treturn FALSE;\n\n\t\t\tif (new_cb)\n\t\t\t{\n\t\t\t\tBYTE* new_aj;\n\t\t\t\tnew_aj = (BYTE*)realloc(glyph->aj, new_cb);\n\n\t\t\t\tif (!new_aj)\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tglyph->aj = new_aj;\n\t\t\t\tglyph->cb = new_cb;\n\t\t\t\tStream_Read(s, glyph->aj, glyph->cb);\n\t\t\t}\n\t\t}\n\n\t\tStream_SetPointer(s, phold + fastGlyph->cbData);\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_polygon_sc_order(wStream* s, const ORDER_INFO* orderInfo,\n                                         POLYGON_SC_ORDER* polygon_sc)\n{\n\tUINT32 num = polygon_sc->numPoints;\n\tORDER_FIELD_COORD(1, polygon_sc->xStart);\n\tORDER_FIELD_COORD(2, polygon_sc->yStart);\n\tORDER_FIELD_BYTE(3, polygon_sc->bRop2);\n\tORDER_FIELD_BYTE(4, polygon_sc->fillMode);\n\tORDER_FIELD_COLOR(orderInfo, s, 5, &polygon_sc->brushColor);\n\tORDER_FIELD_BYTE(6, num);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_07)\n\t{\n\t\tDELTA_POINT* newpoints;\n\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, polygon_sc->cbData);\n\t\tnewpoints = (DELTA_POINT*)realloc(polygon_sc->points, sizeof(DELTA_POINT) * num);\n\n\t\tif (!newpoints)\n\t\t\treturn FALSE;\n\n\t\tpolygon_sc->points = newpoints;\n\t\tpolygon_sc->numPoints = num;\n\t\treturn update_read_delta_points(s, polygon_sc->points, polygon_sc->numPoints,\n\t\t                                polygon_sc->xStart, polygon_sc->yStart);\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_polygon_cb_order(wStream* s, const ORDER_INFO* orderInfo,\n                                         POLYGON_CB_ORDER* polygon_cb)\n{\n\tUINT32 num = polygon_cb->numPoints;\n\tORDER_FIELD_COORD(1, polygon_cb->xStart);\n\tORDER_FIELD_COORD(2, polygon_cb->yStart);\n\tORDER_FIELD_BYTE(3, polygon_cb->bRop2);\n\tORDER_FIELD_BYTE(4, polygon_cb->fillMode);\n\tORDER_FIELD_COLOR(orderInfo, s, 5, &polygon_cb->backColor);\n\tORDER_FIELD_COLOR(orderInfo, s, 6, &polygon_cb->foreColor);\n\n\tif (!update_read_brush(s, &polygon_cb->brush, orderInfo->fieldFlags >> 6))\n\t\treturn FALSE;\n\n\tORDER_FIELD_BYTE(12, num);\n\n\tif (orderInfo->fieldFlags & ORDER_FIELD_13)\n\t{\n\t\tDELTA_POINT* newpoints;\n\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, polygon_cb->cbData);\n\t\tnewpoints = (DELTA_POINT*)realloc(polygon_cb->points, sizeof(DELTA_POINT) * num);\n\n\t\tif (!newpoints)\n\t\t\treturn FALSE;\n\n\t\tpolygon_cb->points = newpoints;\n\t\tpolygon_cb->numPoints = num;\n\n\t\tif (!update_read_delta_points(s, polygon_cb->points, polygon_cb->numPoints,\n\t\t                              polygon_cb->xStart, polygon_cb->yStart))\n\t\t\treturn FALSE;\n\t}\n\n\tpolygon_cb->backMode = (polygon_cb->bRop2 & 0x80) ? BACKMODE_TRANSPARENT : BACKMODE_OPAQUE;\n\tpolygon_cb->bRop2 = (polygon_cb->bRop2 & 0x1F);\n\treturn TRUE;\n}\nstatic BOOL update_read_ellipse_sc_order(wStream* s, const ORDER_INFO* orderInfo,\n                                         ELLIPSE_SC_ORDER* ellipse_sc)\n{\n\tORDER_FIELD_COORD(1, ellipse_sc->leftRect);\n\tORDER_FIELD_COORD(2, ellipse_sc->topRect);\n\tORDER_FIELD_COORD(3, ellipse_sc->rightRect);\n\tORDER_FIELD_COORD(4, ellipse_sc->bottomRect);\n\tORDER_FIELD_BYTE(5, ellipse_sc->bRop2);\n\tORDER_FIELD_BYTE(6, ellipse_sc->fillMode);\n\tORDER_FIELD_COLOR(orderInfo, s, 7, &ellipse_sc->color);\n\treturn TRUE;\n}\nstatic BOOL update_read_ellipse_cb_order(wStream* s, const ORDER_INFO* orderInfo,\n                                         ELLIPSE_CB_ORDER* ellipse_cb)\n{\n\tORDER_FIELD_COORD(1, ellipse_cb->leftRect);\n\tORDER_FIELD_COORD(2, ellipse_cb->topRect);\n\tORDER_FIELD_COORD(3, ellipse_cb->rightRect);\n\tORDER_FIELD_COORD(4, ellipse_cb->bottomRect);\n\tORDER_FIELD_BYTE(5, ellipse_cb->bRop2);\n\tORDER_FIELD_BYTE(6, ellipse_cb->fillMode);\n\tORDER_FIELD_COLOR(orderInfo, s, 7, &ellipse_cb->backColor);\n\tORDER_FIELD_COLOR(orderInfo, s, 8, &ellipse_cb->foreColor);\n\treturn update_read_brush(s, &ellipse_cb->brush, orderInfo->fieldFlags >> 8);\n}\n/* Secondary Drawing Orders */\nstatic CACHE_BITMAP_ORDER* update_read_cache_bitmap_order(rdpUpdate* update, wStream* s,\n                                                          BOOL compressed, UINT16 flags)\n{\n\tCACHE_BITMAP_ORDER* cache_bitmap;\n\n\tif (!update || !s)\n\t\treturn NULL;\n\n\tcache_bitmap = calloc(1, sizeof(CACHE_BITMAP_ORDER));\n\n\tif (!cache_bitmap)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 9)\n\t\tgoto fail;\n\n\tStream_Read_UINT8(s, cache_bitmap->cacheId);      /* cacheId (1 byte) */\n\tStream_Seek_UINT8(s);                             /* pad1Octet (1 byte) */\n\tStream_Read_UINT8(s, cache_bitmap->bitmapWidth);  /* bitmapWidth (1 byte) */\n\tStream_Read_UINT8(s, cache_bitmap->bitmapHeight); /* bitmapHeight (1 byte) */\n\tStream_Read_UINT8(s, cache_bitmap->bitmapBpp);    /* bitmapBpp (1 byte) */\n\n\tif ((cache_bitmap->bitmapBpp < 1) || (cache_bitmap->bitmapBpp > 32))\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"invalid bitmap bpp %\" PRIu32 \"\",\n\t\t           cache_bitmap->bitmapBpp);\n\t\tgoto fail;\n\t}\n\n\tStream_Read_UINT16(s, cache_bitmap->bitmapLength); /* bitmapLength (2 bytes) */\n\tStream_Read_UINT16(s, cache_bitmap->cacheIndex);   /* cacheIndex (2 bytes) */\n\n\tif (compressed)\n\t{\n\t\tif ((flags & NO_BITMAP_COMPRESSION_HDR) == 0)\n\t\t{\n\t\t\tBYTE* bitmapComprHdr = (BYTE*)&(cache_bitmap->bitmapComprHdr);\n\n\t\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\t\tgoto fail;\n\n\t\t\tStream_Read(s, bitmapComprHdr, 8); /* bitmapComprHdr (8 bytes) */\n\t\t\tcache_bitmap->bitmapLength -= 8;\n\t\t}\n\t}\n\n\tif (Stream_GetRemainingLength(s) < cache_bitmap->bitmapLength)\n\t\tgoto fail;\n\n\tcache_bitmap->bitmapDataStream = malloc(cache_bitmap->bitmapLength);\n\n\tif (!cache_bitmap->bitmapDataStream)\n\t\tgoto fail;\n\n\tStream_Read(s, cache_bitmap->bitmapDataStream, cache_bitmap->bitmapLength);\n\tcache_bitmap->compressed = compressed;\n\treturn cache_bitmap;\nfail:\n\tfree_cache_bitmap_order(update->context, cache_bitmap);\n\treturn NULL;\n}\nint update_approximate_cache_bitmap_order(const CACHE_BITMAP_ORDER* cache_bitmap, BOOL compressed,\n                                          UINT16* flags)\n{\n\treturn 64 + cache_bitmap->bitmapLength;\n}\nBOOL update_write_cache_bitmap_order(wStream* s, const CACHE_BITMAP_ORDER* cache_bitmap,\n                                     BOOL compressed, UINT16* flags)\n{\n\tUINT32 bitmapLength = cache_bitmap->bitmapLength;\n\tint inf = update_approximate_cache_bitmap_order(cache_bitmap, compressed, flags);\n\n\tif (!Stream_EnsureRemainingCapacity(s, inf))\n\t\treturn FALSE;\n\n\t*flags = NO_BITMAP_COMPRESSION_HDR;\n\n\tif ((*flags & NO_BITMAP_COMPRESSION_HDR) == 0)\n\t\tbitmapLength += 8;\n\n\tStream_Write_UINT8(s, cache_bitmap->cacheId);      /* cacheId (1 byte) */\n\tStream_Write_UINT8(s, 0);                          /* pad1Octet (1 byte) */\n\tStream_Write_UINT8(s, cache_bitmap->bitmapWidth);  /* bitmapWidth (1 byte) */\n\tStream_Write_UINT8(s, cache_bitmap->bitmapHeight); /* bitmapHeight (1 byte) */\n\tStream_Write_UINT8(s, cache_bitmap->bitmapBpp);    /* bitmapBpp (1 byte) */\n\tStream_Write_UINT16(s, bitmapLength);              /* bitmapLength (2 bytes) */\n\tStream_Write_UINT16(s, cache_bitmap->cacheIndex);  /* cacheIndex (2 bytes) */\n\n\tif (compressed)\n\t{\n\t\tif ((*flags & NO_BITMAP_COMPRESSION_HDR) == 0)\n\t\t{\n\t\t\tBYTE* bitmapComprHdr = (BYTE*)&(cache_bitmap->bitmapComprHdr);\n\t\t\tStream_Write(s, bitmapComprHdr, 8); /* bitmapComprHdr (8 bytes) */\n\t\t\tbitmapLength -= 8;\n\t\t}\n\n\t\tStream_Write(s, cache_bitmap->bitmapDataStream, bitmapLength);\n\t}\n\telse\n\t{\n\t\tStream_Write(s, cache_bitmap->bitmapDataStream, bitmapLength);\n\t}\n\n\treturn TRUE;\n}\nstatic CACHE_BITMAP_V2_ORDER* update_read_cache_bitmap_v2_order(rdpUpdate* update, wStream* s,\n                                                                BOOL compressed, UINT16 flags)\n{\n\tBYTE bitsPerPixelId;\n\tCACHE_BITMAP_V2_ORDER* cache_bitmap_v2;\n\n\tif (!update || !s)\n\t\treturn NULL;\n\n\tcache_bitmap_v2 = calloc(1, sizeof(CACHE_BITMAP_V2_ORDER));\n\n\tif (!cache_bitmap_v2)\n\t\tgoto fail;\n\n\tcache_bitmap_v2->cacheId = flags & 0x0003;\n\tcache_bitmap_v2->flags = (flags & 0xFF80) >> 7;\n\tbitsPerPixelId = (flags & 0x0078) >> 3;\n\tcache_bitmap_v2->bitmapBpp = CBR2_BPP[bitsPerPixelId];\n\n\tif (cache_bitmap_v2->flags & CBR2_PERSISTENT_KEY_PRESENT)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\tgoto fail;\n\n\t\tStream_Read_UINT32(s, cache_bitmap_v2->key1); /* key1 (4 bytes) */\n\t\tStream_Read_UINT32(s, cache_bitmap_v2->key2); /* key2 (4 bytes) */\n\t}\n\n\tif (cache_bitmap_v2->flags & CBR2_HEIGHT_SAME_AS_WIDTH)\n\t{\n\t\tif (!update_read_2byte_unsigned(s, &cache_bitmap_v2->bitmapWidth)) /* bitmapWidth */\n\t\t\tgoto fail;\n\n\t\tcache_bitmap_v2->bitmapHeight = cache_bitmap_v2->bitmapWidth;\n\t}\n\telse\n\t{\n\t\tif (!update_read_2byte_unsigned(s, &cache_bitmap_v2->bitmapWidth) || /* bitmapWidth */\n\t\t    !update_read_2byte_unsigned(s, &cache_bitmap_v2->bitmapHeight))  /* bitmapHeight */\n\t\t\tgoto fail;\n\t}\n\n\tif (!update_read_4byte_unsigned(s, &cache_bitmap_v2->bitmapLength) || /* bitmapLength */\n\t    !update_read_2byte_unsigned(s, &cache_bitmap_v2->cacheIndex))     /* cacheIndex */\n\t\tgoto fail;\n\n\tif (cache_bitmap_v2->flags & CBR2_DO_NOT_CACHE)\n\t\tcache_bitmap_v2->cacheIndex = BITMAP_CACHE_WAITING_LIST_INDEX;\n\n\tif (compressed)\n\t{\n\t\tif (!(cache_bitmap_v2->flags & CBR2_NO_BITMAP_COMPRESSION_HDR))\n\t\t{\n\t\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\t\tgoto fail;\n\n\t\t\tStream_Read_UINT16(\n\t\t\t    s, cache_bitmap_v2->cbCompFirstRowSize); /* cbCompFirstRowSize (2 bytes) */\n\t\t\tStream_Read_UINT16(\n\t\t\t    s, cache_bitmap_v2->cbCompMainBodySize);         /* cbCompMainBodySize (2 bytes) */\n\t\t\tStream_Read_UINT16(s, cache_bitmap_v2->cbScanWidth); /* cbScanWidth (2 bytes) */\n\t\t\tStream_Read_UINT16(\n\t\t\t    s, cache_bitmap_v2->cbUncompressedSize); /* cbUncompressedSize (2 bytes) */\n\t\t\tcache_bitmap_v2->bitmapLength = cache_bitmap_v2->cbCompMainBodySize;\n\t\t}\n\t}\n\n\tif (Stream_GetRemainingLength(s) < cache_bitmap_v2->bitmapLength)\n\t\tgoto fail;\n\n\tif (cache_bitmap_v2->bitmapLength == 0)\n\t\tgoto fail;\n\n\tcache_bitmap_v2->bitmapDataStream = malloc(cache_bitmap_v2->bitmapLength);\n\n\tif (!cache_bitmap_v2->bitmapDataStream)\n\t\tgoto fail;\n\n\tStream_Read(s, cache_bitmap_v2->bitmapDataStream, cache_bitmap_v2->bitmapLength);\n\tcache_bitmap_v2->compressed = compressed;\n\treturn cache_bitmap_v2;\nfail:\n\tfree_cache_bitmap_v2_order(update->context, cache_bitmap_v2);\n\treturn NULL;\n}\nint update_approximate_cache_bitmap_v2_order(CACHE_BITMAP_V2_ORDER* cache_bitmap_v2,\n                                             BOOL compressed, UINT16* flags)\n{\n\treturn 64 + cache_bitmap_v2->bitmapLength;\n}\nBOOL update_write_cache_bitmap_v2_order(wStream* s, CACHE_BITMAP_V2_ORDER* cache_bitmap_v2,\n                                        BOOL compressed, UINT16* flags)\n{\n\tBYTE bitsPerPixelId;\n\n\tif (!Stream_EnsureRemainingCapacity(\n\t        s, update_approximate_cache_bitmap_v2_order(cache_bitmap_v2, compressed, flags)))\n\t\treturn FALSE;\n\n\tbitsPerPixelId = BPP_CBR2[cache_bitmap_v2->bitmapBpp];\n\t*flags = (cache_bitmap_v2->cacheId & 0x0003) | (bitsPerPixelId << 3) |\n\t         ((cache_bitmap_v2->flags << 7) & 0xFF80);\n\n\tif (cache_bitmap_v2->flags & CBR2_PERSISTENT_KEY_PRESENT)\n\t{\n\t\tStream_Write_UINT32(s, cache_bitmap_v2->key1); /* key1 (4 bytes) */\n\t\tStream_Write_UINT32(s, cache_bitmap_v2->key2); /* key2 (4 bytes) */\n\t}\n\n\tif (cache_bitmap_v2->flags & CBR2_HEIGHT_SAME_AS_WIDTH)\n\t{\n\t\tif (!update_write_2byte_unsigned(s, cache_bitmap_v2->bitmapWidth)) /* bitmapWidth */\n\t\t\treturn FALSE;\n\t}\n\telse\n\t{\n\t\tif (!update_write_2byte_unsigned(s, cache_bitmap_v2->bitmapWidth) || /* bitmapWidth */\n\t\t    !update_write_2byte_unsigned(s, cache_bitmap_v2->bitmapHeight))  /* bitmapHeight */\n\t\t\treturn FALSE;\n\t}\n\n\tif (cache_bitmap_v2->flags & CBR2_DO_NOT_CACHE)\n\t\tcache_bitmap_v2->cacheIndex = BITMAP_CACHE_WAITING_LIST_INDEX;\n\n\tif (!update_write_4byte_unsigned(s, cache_bitmap_v2->bitmapLength) || /* bitmapLength */\n\t    !update_write_2byte_unsigned(s, cache_bitmap_v2->cacheIndex))     /* cacheIndex */\n\t\treturn FALSE;\n\n\tif (compressed)\n\t{\n\t\tif (!(cache_bitmap_v2->flags & CBR2_NO_BITMAP_COMPRESSION_HDR))\n\t\t{\n\t\t\tStream_Write_UINT16(\n\t\t\t    s, cache_bitmap_v2->cbCompFirstRowSize); /* cbCompFirstRowSize (2 bytes) */\n\t\t\tStream_Write_UINT16(\n\t\t\t    s, cache_bitmap_v2->cbCompMainBodySize);          /* cbCompMainBodySize (2 bytes) */\n\t\t\tStream_Write_UINT16(s, cache_bitmap_v2->cbScanWidth); /* cbScanWidth (2 bytes) */\n\t\t\tStream_Write_UINT16(\n\t\t\t    s, cache_bitmap_v2->cbUncompressedSize); /* cbUncompressedSize (2 bytes) */\n\t\t\tcache_bitmap_v2->bitmapLength = cache_bitmap_v2->cbCompMainBodySize;\n\t\t}\n\n\t\tif (!Stream_EnsureRemainingCapacity(s, cache_bitmap_v2->bitmapLength))\n\t\t\treturn FALSE;\n\n\t\tStream_Write(s, cache_bitmap_v2->bitmapDataStream, cache_bitmap_v2->bitmapLength);\n\t}\n\telse\n\t{\n\t\tif (!Stream_EnsureRemainingCapacity(s, cache_bitmap_v2->bitmapLength))\n\t\t\treturn FALSE;\n\n\t\tStream_Write(s, cache_bitmap_v2->bitmapDataStream, cache_bitmap_v2->bitmapLength);\n\t}\n\n\tcache_bitmap_v2->compressed = compressed;\n\treturn TRUE;\n}\nstatic CACHE_BITMAP_V3_ORDER* update_read_cache_bitmap_v3_order(rdpUpdate* update, wStream* s,\n                                                                UINT16 flags)\n{\n\tBYTE bitsPerPixelId;\n\tBITMAP_DATA_EX* bitmapData;\n\tUINT32 new_len;\n\tBYTE* new_data;\n\tCACHE_BITMAP_V3_ORDER* cache_bitmap_v3;\n\n\tif (!update || !s)\n\t\treturn NULL;\n\n\tcache_bitmap_v3 = calloc(1, sizeof(CACHE_BITMAP_V3_ORDER));\n\n\tif (!cache_bitmap_v3)\n\t\tgoto fail;\n\n\tcache_bitmap_v3->cacheId = flags & 0x00000003;\n\tcache_bitmap_v3->flags = (flags & 0x0000FF80) >> 7;\n\tbitsPerPixelId = (flags & 0x00000078) >> 3;\n\tcache_bitmap_v3->bpp = CBR23_BPP[bitsPerPixelId];\n\n\tif (Stream_GetRemainingLength(s) < 21)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, cache_bitmap_v3->cacheIndex); /* cacheIndex (2 bytes) */\n\tStream_Read_UINT32(s, cache_bitmap_v3->key1);       /* key1 (4 bytes) */\n\tStream_Read_UINT32(s, cache_bitmap_v3->key2);       /* key2 (4 bytes) */\n\tbitmapData = &cache_bitmap_v3->bitmapData;\n\tStream_Read_UINT8(s, bitmapData->bpp);\n\n\tif ((bitmapData->bpp < 1) || (bitmapData->bpp > 32))\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"invalid bpp value %\" PRIu32 \"\", bitmapData->bpp);\n\t\tgoto fail;\n\t}\n\n\tStream_Seek_UINT8(s);                      /* reserved1 (1 byte) */\n\tStream_Seek_UINT8(s);                      /* reserved2 (1 byte) */\n\tStream_Read_UINT8(s, bitmapData->codecID); /* codecID (1 byte) */\n\tStream_Read_UINT16(s, bitmapData->width);  /* width (2 bytes) */\n\tStream_Read_UINT16(s, bitmapData->height); /* height (2 bytes) */\n\tStream_Read_UINT32(s, new_len);            /* length (4 bytes) */\n\n\tif ((new_len == 0) || (Stream_GetRemainingLength(s) < new_len))\n\t\tgoto fail;\n\n\tnew_data = (BYTE*)realloc(bitmapData->data, new_len);\n\n\tif (!new_data)\n\t\tgoto fail;\n\n\tbitmapData->data = new_data;\n\tbitmapData->length = new_len;\n\tStream_Read(s, bitmapData->data, bitmapData->length);\n\treturn cache_bitmap_v3;\nfail:\n\tfree_cache_bitmap_v3_order(update->context, cache_bitmap_v3);\n\treturn NULL;\n}\nint update_approximate_cache_bitmap_v3_order(CACHE_BITMAP_V3_ORDER* cache_bitmap_v3, UINT16* flags)\n{\n\tBITMAP_DATA_EX* bitmapData = &cache_bitmap_v3->bitmapData;\n\treturn 64 + bitmapData->length;\n}\nBOOL update_write_cache_bitmap_v3_order(wStream* s, CACHE_BITMAP_V3_ORDER* cache_bitmap_v3,\n                                        UINT16* flags)\n{\n\tBYTE bitsPerPixelId;\n\tBITMAP_DATA_EX* bitmapData;\n\n\tif (!Stream_EnsureRemainingCapacity(\n\t        s, update_approximate_cache_bitmap_v3_order(cache_bitmap_v3, flags)))\n\t\treturn FALSE;\n\n\tbitmapData = &cache_bitmap_v3->bitmapData;\n\tbitsPerPixelId = BPP_CBR23[cache_bitmap_v3->bpp];\n\t*flags = (cache_bitmap_v3->cacheId & 0x00000003) |\n\t         ((cache_bitmap_v3->flags << 7) & 0x0000FF80) | ((bitsPerPixelId << 3) & 0x00000078);\n\tStream_Write_UINT16(s, cache_bitmap_v3->cacheIndex); /* cacheIndex (2 bytes) */\n\tStream_Write_UINT32(s, cache_bitmap_v3->key1);       /* key1 (4 bytes) */\n\tStream_Write_UINT32(s, cache_bitmap_v3->key2);       /* key2 (4 bytes) */\n\tStream_Write_UINT8(s, bitmapData->bpp);\n\tStream_Write_UINT8(s, 0);                   /* reserved1 (1 byte) */\n\tStream_Write_UINT8(s, 0);                   /* reserved2 (1 byte) */\n\tStream_Write_UINT8(s, bitmapData->codecID); /* codecID (1 byte) */\n\tStream_Write_UINT16(s, bitmapData->width);  /* width (2 bytes) */\n\tStream_Write_UINT16(s, bitmapData->height); /* height (2 bytes) */\n\tStream_Write_UINT32(s, bitmapData->length); /* length (4 bytes) */\n\tStream_Write(s, bitmapData->data, bitmapData->length);\n\treturn TRUE;\n}\nstatic CACHE_COLOR_TABLE_ORDER* update_read_cache_color_table_order(rdpUpdate* update, wStream* s,\n                                                                    UINT16 flags)\n{\n\tint i;\n\tUINT32* colorTable;\n\tCACHE_COLOR_TABLE_ORDER* cache_color_table = calloc(1, sizeof(CACHE_COLOR_TABLE_ORDER));\n\n\tif (!cache_color_table)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 3)\n\t\tgoto fail;\n\n\tStream_Read_UINT8(s, cache_color_table->cacheIndex);    /* cacheIndex (1 byte) */\n\tStream_Read_UINT16(s, cache_color_table->numberColors); /* numberColors (2 bytes) */\n\n\tif (cache_color_table->numberColors != 256)\n\t{\n\t\t/* This field MUST be set to 256 */\n\t\tgoto fail;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < cache_color_table->numberColors * 4)\n\t\tgoto fail;\n\n\tcolorTable = (UINT32*)&cache_color_table->colorTable;\n\n\tfor (i = 0; i < (int)cache_color_table->numberColors; i++)\n\t\tupdate_read_color_quad(s, &colorTable[i]);\n\n\treturn cache_color_table;\nfail:\n\tfree_cache_color_table_order(update->context, cache_color_table);\n\treturn NULL;\n}\nint update_approximate_cache_color_table_order(const CACHE_COLOR_TABLE_ORDER* cache_color_table,\n                                               UINT16* flags)\n{\n\treturn 16 + (256 * 4);\n}\nBOOL update_write_cache_color_table_order(wStream* s,\n                                          const CACHE_COLOR_TABLE_ORDER* cache_color_table,\n                                          UINT16* flags)\n{\n\tint i, inf;\n\tUINT32* colorTable;\n\n\tif (cache_color_table->numberColors != 256)\n\t\treturn FALSE;\n\n\tinf = update_approximate_cache_color_table_order(cache_color_table, flags);\n\n\tif (!Stream_EnsureRemainingCapacity(s, inf))\n\t\treturn FALSE;\n\n\tStream_Write_UINT8(s, cache_color_table->cacheIndex);    /* cacheIndex (1 byte) */\n\tStream_Write_UINT16(s, cache_color_table->numberColors); /* numberColors (2 bytes) */\n\tcolorTable = (UINT32*)&cache_color_table->colorTable;\n\n\tfor (i = 0; i < (int)cache_color_table->numberColors; i++)\n\t{\n\t\tupdate_write_color_quad(s, colorTable[i]);\n\t}\n\n\treturn TRUE;\n}\nstatic CACHE_GLYPH_ORDER* update_read_cache_glyph_order(rdpUpdate* update, wStream* s, UINT16 flags)\n{\n\tUINT32 i;\n\tCACHE_GLYPH_ORDER* cache_glyph_order = calloc(1, sizeof(CACHE_GLYPH_ORDER));\n\n\tif (!cache_glyph_order || !update || !s)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\tgoto fail;\n\n\tStream_Read_UINT8(s, cache_glyph_order->cacheId); /* cacheId (1 byte) */\n\tStream_Read_UINT8(s, cache_glyph_order->cGlyphs); /* cGlyphs (1 byte) */\n\n\tfor (i = 0; i < cache_glyph_order->cGlyphs; i++)\n\t{\n\t\tGLYPH_DATA* glyph = &cache_glyph_order->glyphData[i];\n\n\t\tif (Stream_GetRemainingLength(s) < 10)\n\t\t\tgoto fail;\n\n\t\tStream_Read_UINT16(s, glyph->cacheIndex);\n\t\tStream_Read_INT16(s, glyph->x);\n\t\tStream_Read_INT16(s, glyph->y);\n\t\tStream_Read_UINT16(s, glyph->cx);\n\t\tStream_Read_UINT16(s, glyph->cy);\n\t\tglyph->cb = ((glyph->cx + 7) / 8) * glyph->cy;\n\t\tglyph->cb += ((glyph->cb % 4) > 0) ? 4 - (glyph->cb % 4) : 0;\n\n\t\tif (Stream_GetRemainingLength(s) < glyph->cb)\n\t\t\tgoto fail;\n\n\t\tglyph->aj = (BYTE*)malloc(glyph->cb);\n\n\t\tif (!glyph->aj)\n\t\t\tgoto fail;\n\n\t\tStream_Read(s, glyph->aj, glyph->cb);\n\t}\n\n\tif ((flags & CG_GLYPH_UNICODE_PRESENT) && (cache_glyph_order->cGlyphs > 0))\n\t{\n\t\tcache_glyph_order->unicodeCharacters = calloc(cache_glyph_order->cGlyphs, sizeof(WCHAR));\n\n\t\tif (!cache_glyph_order->unicodeCharacters)\n\t\t\tgoto fail;\n\n\t\tif (Stream_GetRemainingLength(s) < sizeof(WCHAR) * cache_glyph_order->cGlyphs)\n\t\t\tgoto fail;\n\n\t\tStream_Read_UTF16_String(s, cache_glyph_order->unicodeCharacters,\n\t\t                         cache_glyph_order->cGlyphs);\n\t}\n\n\treturn cache_glyph_order;\nfail:\n\tfree_cache_glyph_order(update->context, cache_glyph_order);\n\treturn NULL;\n}\nint update_approximate_cache_glyph_order(const CACHE_GLYPH_ORDER* cache_glyph, UINT16* flags)\n{\n\treturn 2 + cache_glyph->cGlyphs * 32;\n}\nBOOL update_write_cache_glyph_order(wStream* s, const CACHE_GLYPH_ORDER* cache_glyph, UINT16* flags)\n{\n\tint i, inf;\n\tINT16 lsi16;\n\tconst GLYPH_DATA* glyph;\n\tinf = update_approximate_cache_glyph_order(cache_glyph, flags);\n\n\tif (!Stream_EnsureRemainingCapacity(s, inf))\n\t\treturn FALSE;\n\n\tStream_Write_UINT8(s, cache_glyph->cacheId); /* cacheId (1 byte) */\n\tStream_Write_UINT8(s, cache_glyph->cGlyphs); /* cGlyphs (1 byte) */\n\n\tfor (i = 0; i < (int)cache_glyph->cGlyphs; i++)\n\t{\n\t\tUINT32 cb;\n\t\tglyph = &cache_glyph->glyphData[i];\n\t\tStream_Write_UINT16(s, glyph->cacheIndex); /* cacheIndex (2 bytes) */\n\t\tlsi16 = glyph->x;\n\t\tStream_Write_UINT16(s, lsi16); /* x (2 bytes) */\n\t\tlsi16 = glyph->y;\n\t\tStream_Write_UINT16(s, lsi16);     /* y (2 bytes) */\n\t\tStream_Write_UINT16(s, glyph->cx); /* cx (2 bytes) */\n\t\tStream_Write_UINT16(s, glyph->cy); /* cy (2 bytes) */\n\t\tcb = ((glyph->cx + 7) / 8) * glyph->cy;\n\t\tcb += ((cb % 4) > 0) ? 4 - (cb % 4) : 0;\n\t\tStream_Write(s, glyph->aj, cb);\n\t}\n\n\tif (*flags & CG_GLYPH_UNICODE_PRESENT)\n\t{\n\t\tStream_Zero(s, cache_glyph->cGlyphs * 2);\n\t}\n\n\treturn TRUE;\n}\nstatic CACHE_GLYPH_V2_ORDER* update_read_cache_glyph_v2_order(rdpUpdate* update, wStream* s,\n                                                              UINT16 flags)\n{\n\tUINT32 i;\n\tCACHE_GLYPH_V2_ORDER* cache_glyph_v2 = calloc(1, sizeof(CACHE_GLYPH_V2_ORDER));\n\n\tif (!cache_glyph_v2)\n\t\tgoto fail;\n\n\tcache_glyph_v2->cacheId = (flags & 0x000F);\n\tcache_glyph_v2->flags = (flags & 0x00F0) >> 4;\n\tcache_glyph_v2->cGlyphs = (flags & 0xFF00) >> 8;\n\n\tfor (i = 0; i < cache_glyph_v2->cGlyphs; i++)\n\t{\n\t\tGLYPH_DATA_V2* glyph = &cache_glyph_v2->glyphData[i];\n\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\tgoto fail;\n\n\t\tStream_Read_UINT8(s, glyph->cacheIndex);\n\n\t\tif (!update_read_2byte_signed(s, &glyph->x) || !update_read_2byte_signed(s, &glyph->y) ||\n\t\t    !update_read_2byte_unsigned(s, &glyph->cx) ||\n\t\t    !update_read_2byte_unsigned(s, &glyph->cy))\n\t\t{\n\t\t\tgoto fail;\n\t\t}\n\n\t\tglyph->cb = ((glyph->cx + 7) / 8) * glyph->cy;\n\t\tglyph->cb += ((glyph->cb % 4) > 0) ? 4 - (glyph->cb % 4) : 0;\n\n\t\tif (Stream_GetRemainingLength(s) < glyph->cb)\n\t\t\tgoto fail;\n\n\t\tglyph->aj = (BYTE*)malloc(glyph->cb);\n\n\t\tif (!glyph->aj)\n\t\t\tgoto fail;\n\n\t\tStream_Read(s, glyph->aj, glyph->cb);\n\t}\n\n\tif ((flags & CG_GLYPH_UNICODE_PRESENT) && (cache_glyph_v2->cGlyphs > 0))\n\t{\n\t\tcache_glyph_v2->unicodeCharacters = calloc(cache_glyph_v2->cGlyphs, sizeof(WCHAR));\n\n\t\tif (!cache_glyph_v2->unicodeCharacters)\n\t\t\tgoto fail;\n\n\t\tif (Stream_GetRemainingLength(s) < sizeof(WCHAR) * cache_glyph_v2->cGlyphs)\n\t\t\tgoto fail;\n\n\t\tStream_Read_UTF16_String(s, cache_glyph_v2->unicodeCharacters, cache_glyph_v2->cGlyphs);\n\t}\n\n\treturn cache_glyph_v2;\nfail:\n\tfree_cache_glyph_v2_order(update->context, cache_glyph_v2);\n\treturn NULL;\n}\nint update_approximate_cache_glyph_v2_order(const CACHE_GLYPH_V2_ORDER* cache_glyph_v2,\n                                            UINT16* flags)\n{\n\treturn 8 + cache_glyph_v2->cGlyphs * 32;\n}\nBOOL update_write_cache_glyph_v2_order(wStream* s, const CACHE_GLYPH_V2_ORDER* cache_glyph_v2,\n                                       UINT16* flags)\n{\n\tUINT32 i, inf;\n\tinf = update_approximate_cache_glyph_v2_order(cache_glyph_v2, flags);\n\n\tif (!Stream_EnsureRemainingCapacity(s, inf))\n\t\treturn FALSE;\n\n\t*flags = (cache_glyph_v2->cacheId & 0x000F) | ((cache_glyph_v2->flags & 0x000F) << 4) |\n\t         ((cache_glyph_v2->cGlyphs & 0x00FF) << 8);\n\n\tfor (i = 0; i < cache_glyph_v2->cGlyphs; i++)\n\t{\n\t\tUINT32 cb;\n\t\tconst GLYPH_DATA_V2* glyph = &cache_glyph_v2->glyphData[i];\n\t\tStream_Write_UINT8(s, glyph->cacheIndex);\n\n\t\tif (!update_write_2byte_signed(s, glyph->x) || !update_write_2byte_signed(s, glyph->y) ||\n\t\t    !update_write_2byte_unsigned(s, glyph->cx) ||\n\t\t    !update_write_2byte_unsigned(s, glyph->cy))\n\t\t{\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tcb = ((glyph->cx + 7) / 8) * glyph->cy;\n\t\tcb += ((cb % 4) > 0) ? 4 - (cb % 4) : 0;\n\t\tStream_Write(s, glyph->aj, cb);\n\t}\n\n\tif (*flags & CG_GLYPH_UNICODE_PRESENT)\n\t{\n\t\tStream_Zero(s, cache_glyph_v2->cGlyphs * 2);\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_decompress_brush(wStream* s, BYTE* output, BYTE bpp)\n{\n\tint index;\n\tint x, y, k;\n\tBYTE byte = 0;\n\tBYTE* palette;\n\tint bytesPerPixel;\n\tpalette = Stream_Pointer(s) + 16;\n\tbytesPerPixel = ((bpp + 1) / 8);\n\n\tif (Stream_GetRemainingLength(s) < 16) // 64 / 4\n\t\treturn FALSE;\n\n\tfor (y = 7; y >= 0; y--)\n\t{\n\t\tfor (x = 0; x < 8; x++)\n\t\t{\n\t\t\tif ((x % 4) == 0)\n\t\t\t\tStream_Read_UINT8(s, byte);\n\n\t\t\tindex = ((byte >> ((3 - (x % 4)) * 2)) & 0x03);\n\n\t\t\tfor (k = 0; k < bytesPerPixel; k++)\n\t\t\t{\n\t\t\t\toutput[((y * 8 + x) * bytesPerPixel) + k] = palette[(index * bytesPerPixel) + k];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_compress_brush(wStream* s, const BYTE* input, BYTE bpp)\n{\n\treturn FALSE;\n}\nstatic CACHE_BRUSH_ORDER* update_read_cache_brush_order(rdpUpdate* update, wStream* s, UINT16 flags)\n{\n\tint i;\n\tBYTE iBitmapFormat;\n\tBOOL compressed = FALSE;\n\tCACHE_BRUSH_ORDER* cache_brush = calloc(1, sizeof(CACHE_BRUSH_ORDER));\n\n\tif (!cache_brush)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 6)\n\t\tgoto fail;\n\n\tStream_Read_UINT8(s, cache_brush->index); /* cacheEntry (1 byte) */\n\tStream_Read_UINT8(s, iBitmapFormat);      /* iBitmapFormat (1 byte) */\n\n\tif (iBitmapFormat > ARRAYSIZE(BMF_BPP))\n\t\tgoto fail;\n\n\tcache_brush->bpp = BMF_BPP[iBitmapFormat];\n\tStream_Read_UINT8(s, cache_brush->cx);     /* cx (1 byte) */\n\tStream_Read_UINT8(s, cache_brush->cy);     /* cy (1 byte) */\n\tStream_Read_UINT8(s, cache_brush->style);  /* style (1 byte) */\n\tStream_Read_UINT8(s, cache_brush->length); /* iBytes (1 byte) */\n\n\tif ((cache_brush->cx == 8) && (cache_brush->cy == 8))\n\t{\n\t\tif (cache_brush->bpp == 1)\n\t\t{\n\t\t\tif (cache_brush->length != 8)\n\t\t\t{\n\t\t\t\tWLog_Print(update->log, WLOG_ERROR, \"incompatible 1bpp brush of length:%\" PRIu32 \"\",\n\t\t\t\t           cache_brush->length);\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\t/* rows are encoded in reverse order */\n\t\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\t\tgoto fail;\n\n\t\t\tfor (i = 7; i >= 0; i--)\n\t\t\t{\n\t\t\t\tStream_Read_UINT8(s, cache_brush->data[i]);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ((iBitmapFormat == BMF_8BPP) && (cache_brush->length == 20))\n\t\t\t\tcompressed = TRUE;\n\t\t\telse if ((iBitmapFormat == BMF_16BPP) && (cache_brush->length == 24))\n\t\t\t\tcompressed = TRUE;\n\t\t\telse if ((iBitmapFormat == BMF_32BPP) && (cache_brush->length == 32))\n\t\t\t\tcompressed = TRUE;\n\n\t\t\tif (compressed != FALSE)\n\t\t\t{\n\t\t\t\t/* compressed brush */\n\t\t\t\tif (!update_decompress_brush(s, cache_brush->data, cache_brush->bpp))\n\t\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* uncompressed brush */\n\t\t\t\tUINT32 scanline = (cache_brush->bpp / 8) * 8;\n\n\t\t\t\tif (Stream_GetRemainingLength(s) < scanline * 8)\n\t\t\t\t\tgoto fail;\n\n\t\t\t\tfor (i = 7; i >= 0; i--)\n\t\t\t\t{\n\t\t\t\t\tStream_Read(s, &cache_brush->data[i * scanline], scanline);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cache_brush;\nfail:\n\tfree_cache_brush_order(update->context, cache_brush);\n\treturn NULL;\n}\nint update_approximate_cache_brush_order(const CACHE_BRUSH_ORDER* cache_brush, UINT16* flags)\n{\n\treturn 64;\n}\nBOOL update_write_cache_brush_order(wStream* s, const CACHE_BRUSH_ORDER* cache_brush, UINT16* flags)\n{\n\tint i;\n\tBYTE iBitmapFormat;\n\tBOOL compressed = FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s,\n\t                                    update_approximate_cache_brush_order(cache_brush, flags)))\n\t\treturn FALSE;\n\n\tiBitmapFormat = BPP_BMF[cache_brush->bpp];\n\tStream_Write_UINT8(s, cache_brush->index);  /* cacheEntry (1 byte) */\n\tStream_Write_UINT8(s, iBitmapFormat);       /* iBitmapFormat (1 byte) */\n\tStream_Write_UINT8(s, cache_brush->cx);     /* cx (1 byte) */\n\tStream_Write_UINT8(s, cache_brush->cy);     /* cy (1 byte) */\n\tStream_Write_UINT8(s, cache_brush->style);  /* style (1 byte) */\n\tStream_Write_UINT8(s, cache_brush->length); /* iBytes (1 byte) */\n\n\tif ((cache_brush->cx == 8) && (cache_brush->cy == 8))\n\t{\n\t\tif (cache_brush->bpp == 1)\n\t\t{\n\t\t\tif (cache_brush->length != 8)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"incompatible 1bpp brush of length:%\" PRIu32 \"\", cache_brush->length);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tfor (i = 7; i >= 0; i--)\n\t\t\t{\n\t\t\t\tStream_Write_UINT8(s, cache_brush->data[i]);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ((iBitmapFormat == BMF_8BPP) && (cache_brush->length == 20))\n\t\t\t\tcompressed = TRUE;\n\t\t\telse if ((iBitmapFormat == BMF_16BPP) && (cache_brush->length == 24))\n\t\t\t\tcompressed = TRUE;\n\t\t\telse if ((iBitmapFormat == BMF_32BPP) && (cache_brush->length == 32))\n\t\t\t\tcompressed = TRUE;\n\n\t\t\tif (compressed != FALSE)\n\t\t\t{\n\t\t\t\t/* compressed brush */\n\t\t\t\tif (!update_compress_brush(s, cache_brush->data, cache_brush->bpp))\n\t\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* uncompressed brush */\n\t\t\t\tint scanline = (cache_brush->bpp / 8) * 8;\n\n\t\t\t\tfor (i = 7; i >= 0; i--)\n\t\t\t\t{\n\t\t\t\t\tStream_Write(s, &cache_brush->data[i * scanline], scanline);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n/* Alternate Secondary Drawing Orders */\nstatic BOOL\nupdate_read_create_offscreen_bitmap_order(wStream* s,\n                                          CREATE_OFFSCREEN_BITMAP_ORDER* create_offscreen_bitmap)\n{\n\tUINT16 flags;\n\tBOOL deleteListPresent;\n\tOFFSCREEN_DELETE_LIST* deleteList;\n\n\tif (Stream_GetRemainingLength(s) < 6)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, flags); /* flags (2 bytes) */\n\tcreate_offscreen_bitmap->id = flags & 0x7FFF;\n\tdeleteListPresent = (flags & 0x8000) ? TRUE : FALSE;\n\tStream_Read_UINT16(s, create_offscreen_bitmap->cx); /* cx (2 bytes) */\n\tStream_Read_UINT16(s, create_offscreen_bitmap->cy); /* cy (2 bytes) */\n\tdeleteList = &(create_offscreen_bitmap->deleteList);\n\n\tif (deleteListPresent)\n\t{\n\t\tUINT32 i;\n\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, deleteList->cIndices);\n\n\t\tif (deleteList->cIndices > deleteList->sIndices)\n\t\t{\n\t\t\tUINT16* new_indices;\n\t\t\tnew_indices = (UINT16*)realloc(deleteList->indices, deleteList->cIndices * 2);\n\n\t\t\tif (!new_indices)\n\t\t\t\treturn FALSE;\n\n\t\t\tdeleteList->sIndices = deleteList->cIndices;\n\t\t\tdeleteList->indices = new_indices;\n\t\t}\n\n\t\tif (Stream_GetRemainingLength(s) < 2 * deleteList->cIndices)\n\t\t\treturn FALSE;\n\n\t\tfor (i = 0; i < deleteList->cIndices; i++)\n\t\t{\n\t\t\tStream_Read_UINT16(s, deleteList->indices[i]);\n\t\t}\n\t}\n\telse\n\t{\n\t\tdeleteList->cIndices = 0;\n\t}\n\n\treturn TRUE;\n}\nint update_approximate_create_offscreen_bitmap_order(\n    const CREATE_OFFSCREEN_BITMAP_ORDER* create_offscreen_bitmap)\n{\n\tconst OFFSCREEN_DELETE_LIST* deleteList = &(create_offscreen_bitmap->deleteList);\n\treturn 32 + deleteList->cIndices * 2;\n}\nBOOL update_write_create_offscreen_bitmap_order(\n    wStream* s, const CREATE_OFFSCREEN_BITMAP_ORDER* create_offscreen_bitmap)\n{\n\tUINT16 flags;\n\tBOOL deleteListPresent;\n\tconst OFFSCREEN_DELETE_LIST* deleteList;\n\n\tif (!Stream_EnsureRemainingCapacity(\n\t        s, update_approximate_create_offscreen_bitmap_order(create_offscreen_bitmap)))\n\t\treturn FALSE;\n\n\tdeleteList = &(create_offscreen_bitmap->deleteList);\n\tflags = create_offscreen_bitmap->id & 0x7FFF;\n\tdeleteListPresent = (deleteList->cIndices > 0) ? TRUE : FALSE;\n\n\tif (deleteListPresent)\n\t\tflags |= 0x8000;\n\n\tStream_Write_UINT16(s, flags);                       /* flags (2 bytes) */\n\tStream_Write_UINT16(s, create_offscreen_bitmap->cx); /* cx (2 bytes) */\n\tStream_Write_UINT16(s, create_offscreen_bitmap->cy); /* cy (2 bytes) */\n\n\tif (deleteListPresent)\n\t{\n\t\tint i;\n\t\tStream_Write_UINT16(s, deleteList->cIndices);\n\n\t\tfor (i = 0; i < (int)deleteList->cIndices; i++)\n\t\t{\n\t\t\tStream_Write_UINT16(s, deleteList->indices[i]);\n\t\t}\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_switch_surface_order(wStream* s, SWITCH_SURFACE_ORDER* switch_surface)\n{\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, switch_surface->bitmapId); /* bitmapId (2 bytes) */\n\treturn TRUE;\n}\nint update_approximate_switch_surface_order(const SWITCH_SURFACE_ORDER* switch_surface)\n{\n\treturn 2;\n}\nBOOL update_write_switch_surface_order(wStream* s, const SWITCH_SURFACE_ORDER* switch_surface)\n{\n\tint inf = update_approximate_switch_surface_order(switch_surface);\n\n\tif (!Stream_EnsureRemainingCapacity(s, inf))\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, switch_surface->bitmapId); /* bitmapId (2 bytes) */\n\treturn TRUE;\n}\nstatic BOOL\nupdate_read_create_nine_grid_bitmap_order(wStream* s,\n                                          CREATE_NINE_GRID_BITMAP_ORDER* create_nine_grid_bitmap)\n{\n\tNINE_GRID_BITMAP_INFO* nineGridInfo;\n\n\tif (Stream_GetRemainingLength(s) < 19)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, create_nine_grid_bitmap->bitmapBpp); /* bitmapBpp (1 byte) */\n\n\tif ((create_nine_grid_bitmap->bitmapBpp < 1) || (create_nine_grid_bitmap->bitmapBpp > 32))\n\t{\n\t\tWLog_ERR(TAG, \"invalid bpp value %\" PRIu32 \"\", create_nine_grid_bitmap->bitmapBpp);\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, create_nine_grid_bitmap->bitmapId); /* bitmapId (2 bytes) */\n\tnineGridInfo = &(create_nine_grid_bitmap->nineGridInfo);\n\tStream_Read_UINT32(s, nineGridInfo->flFlags);          /* flFlags (4 bytes) */\n\tStream_Read_UINT16(s, nineGridInfo->ulLeftWidth);      /* ulLeftWidth (2 bytes) */\n\tStream_Read_UINT16(s, nineGridInfo->ulRightWidth);     /* ulRightWidth (2 bytes) */\n\tStream_Read_UINT16(s, nineGridInfo->ulTopHeight);      /* ulTopHeight (2 bytes) */\n\tStream_Read_UINT16(s, nineGridInfo->ulBottomHeight);   /* ulBottomHeight (2 bytes) */\n\tupdate_read_colorref(s, &nineGridInfo->crTransparent); /* crTransparent (4 bytes) */\n\treturn TRUE;\n}\nstatic BOOL update_read_frame_marker_order(wStream* s, FRAME_MARKER_ORDER* frame_marker)\n{\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, frame_marker->action); /* action (4 bytes) */\n\treturn TRUE;\n}\nstatic BOOL update_read_stream_bitmap_first_order(wStream* s,\n                                                  STREAM_BITMAP_FIRST_ORDER* stream_bitmap_first)\n{\n\tif (Stream_GetRemainingLength(s) < 10) // 8 + 2 at least\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, stream_bitmap_first->bitmapFlags); /* bitmapFlags (1 byte) */\n\tStream_Read_UINT8(s, stream_bitmap_first->bitmapBpp);   /* bitmapBpp (1 byte) */\n\n\tif ((stream_bitmap_first->bitmapBpp < 1) || (stream_bitmap_first->bitmapBpp > 32))\n\t{\n\t\tWLog_ERR(TAG, \"invalid bpp value %\" PRIu32 \"\", stream_bitmap_first->bitmapBpp);\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, stream_bitmap_first->bitmapType);   /* bitmapType (2 bytes) */\n\tStream_Read_UINT16(s, stream_bitmap_first->bitmapWidth);  /* bitmapWidth (2 bytes) */\n\tStream_Read_UINT16(s, stream_bitmap_first->bitmapHeight); /* bitmapHeigth (2 bytes) */\n\n\tif (stream_bitmap_first->bitmapFlags & STREAM_BITMAP_V2)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 4)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT32(s, stream_bitmap_first->bitmapSize); /* bitmapSize (4 bytes) */\n\t}\n\telse\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, stream_bitmap_first->bitmapSize); /* bitmapSize (2 bytes) */\n\t}\n\n\tFIELD_SKIP_BUFFER16(\n\t    s, stream_bitmap_first->bitmapBlockSize); /* bitmapBlockSize(2 bytes) + bitmapBlock */\n\treturn TRUE;\n}\nstatic BOOL update_read_stream_bitmap_next_order(wStream* s,\n                                                 STREAM_BITMAP_NEXT_ORDER* stream_bitmap_next)\n{\n\tif (Stream_GetRemainingLength(s) < 5)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, stream_bitmap_next->bitmapFlags); /* bitmapFlags (1 byte) */\n\tStream_Read_UINT16(s, stream_bitmap_next->bitmapType); /* bitmapType (2 bytes) */\n\tFIELD_SKIP_BUFFER16(\n\t    s, stream_bitmap_next->bitmapBlockSize); /* bitmapBlockSize(2 bytes) + bitmapBlock */\n\treturn TRUE;\n}\nstatic BOOL update_read_draw_gdiplus_first_order(wStream* s,\n                                                 DRAW_GDIPLUS_FIRST_ORDER* draw_gdiplus_first)\n{\n\tif (Stream_GetRemainingLength(s) < 11)\n\t\treturn FALSE;\n\n\tStream_Seek_UINT8(s);                                      /* pad1Octet (1 byte) */\n\tStream_Read_UINT16(s, draw_gdiplus_first->cbSize);         /* cbSize (2 bytes) */\n\tStream_Read_UINT32(s, draw_gdiplus_first->cbTotalSize);    /* cbTotalSize (4 bytes) */\n\tStream_Read_UINT32(s, draw_gdiplus_first->cbTotalEmfSize); /* cbTotalEmfSize (4 bytes) */\n\treturn Stream_SafeSeek(s, draw_gdiplus_first->cbSize);     /* emfRecords */\n}\nstatic BOOL update_read_draw_gdiplus_next_order(wStream* s,\n                                                DRAW_GDIPLUS_NEXT_ORDER* draw_gdiplus_next)\n{\n\tif (Stream_GetRemainingLength(s) < 3)\n\t\treturn FALSE;\n\n\tStream_Seek_UINT8(s);                              /* pad1Octet (1 byte) */\n\tFIELD_SKIP_BUFFER16(s, draw_gdiplus_next->cbSize); /* cbSize(2 bytes) + emfRecords */\n\treturn TRUE;\n}\nstatic BOOL update_read_draw_gdiplus_end_order(wStream* s, DRAW_GDIPLUS_END_ORDER* draw_gdiplus_end)\n{\n\tif (Stream_GetRemainingLength(s) < 11)\n\t\treturn FALSE;\n\n\tStream_Seek_UINT8(s);                                    /* pad1Octet (1 byte) */\n\tStream_Read_UINT16(s, draw_gdiplus_end->cbSize);         /* cbSize (2 bytes) */\n\tStream_Read_UINT32(s, draw_gdiplus_end->cbTotalSize);    /* cbTotalSize (4 bytes) */\n\tStream_Read_UINT32(s, draw_gdiplus_end->cbTotalEmfSize); /* cbTotalEmfSize (4 bytes) */\n\treturn Stream_SafeSeek(s, draw_gdiplus_end->cbSize);     /* emfRecords */\n}\nstatic BOOL\nupdate_read_draw_gdiplus_cache_first_order(wStream* s,\n                                           DRAW_GDIPLUS_CACHE_FIRST_ORDER* draw_gdiplus_cache_first)\n{\n\tif (Stream_GetRemainingLength(s) < 11)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, draw_gdiplus_cache_first->flags);        /* flags (1 byte) */\n\tStream_Read_UINT16(s, draw_gdiplus_cache_first->cacheType);   /* cacheType (2 bytes) */\n\tStream_Read_UINT16(s, draw_gdiplus_cache_first->cacheIndex);  /* cacheIndex (2 bytes) */\n\tStream_Read_UINT16(s, draw_gdiplus_cache_first->cbSize);      /* cbSize (2 bytes) */\n\tStream_Read_UINT32(s, draw_gdiplus_cache_first->cbTotalSize); /* cbTotalSize (4 bytes) */\n\treturn Stream_SafeSeek(s, draw_gdiplus_cache_first->cbSize);  /* emfRecords */\n}\nstatic BOOL\nupdate_read_draw_gdiplus_cache_next_order(wStream* s,\n                                          DRAW_GDIPLUS_CACHE_NEXT_ORDER* draw_gdiplus_cache_next)\n{\n\tif (Stream_GetRemainingLength(s) < 7)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, draw_gdiplus_cache_next->flags);       /* flags (1 byte) */\n\tStream_Read_UINT16(s, draw_gdiplus_cache_next->cacheType);  /* cacheType (2 bytes) */\n\tStream_Read_UINT16(s, draw_gdiplus_cache_next->cacheIndex); /* cacheIndex (2 bytes) */\n\tFIELD_SKIP_BUFFER16(s, draw_gdiplus_cache_next->cbSize);    /* cbSize(2 bytes) + emfRecords */\n\treturn TRUE;\n}\nstatic BOOL\nupdate_read_draw_gdiplus_cache_end_order(wStream* s,\n                                         DRAW_GDIPLUS_CACHE_END_ORDER* draw_gdiplus_cache_end)\n{\n\tif (Stream_GetRemainingLength(s) < 11)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, draw_gdiplus_cache_end->flags);        /* flags (1 byte) */\n\tStream_Read_UINT16(s, draw_gdiplus_cache_end->cacheType);   /* cacheType (2 bytes) */\n\tStream_Read_UINT16(s, draw_gdiplus_cache_end->cacheIndex);  /* cacheIndex (2 bytes) */\n\tStream_Read_UINT16(s, draw_gdiplus_cache_end->cbSize);      /* cbSize (2 bytes) */\n\tStream_Read_UINT32(s, draw_gdiplus_cache_end->cbTotalSize); /* cbTotalSize (4 bytes) */\n\treturn Stream_SafeSeek(s, draw_gdiplus_cache_end->cbSize);  /* emfRecords */\n}\nstatic BOOL update_read_field_flags(wStream* s, UINT32* fieldFlags, BYTE flags, BYTE fieldBytes)\n{\n\tint i;\n\tBYTE byte;\n\n\tif (flags & ORDER_ZERO_FIELD_BYTE_BIT0)\n\t\tfieldBytes--;\n\n\tif (flags & ORDER_ZERO_FIELD_BYTE_BIT1)\n\t{\n\t\tif (fieldBytes > 1)\n\t\t\tfieldBytes -= 2;\n\t\telse\n\t\t\tfieldBytes = 0;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < fieldBytes)\n\t\treturn FALSE;\n\n\t*fieldFlags = 0;\n\n\tfor (i = 0; i < fieldBytes; i++)\n\t{\n\t\tStream_Read_UINT8(s, byte);\n\t\t*fieldFlags |= byte << (i * 8);\n\t}\n\n\treturn TRUE;\n}\nBOOL update_write_field_flags(wStream* s, UINT32 fieldFlags, BYTE flags, BYTE fieldBytes)\n{\n\tBYTE byte;\n\n\tif (fieldBytes == 1)\n\t{\n\t\tbyte = fieldFlags & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\telse if (fieldBytes == 2)\n\t{\n\t\tbyte = fieldFlags & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t\tbyte = (fieldFlags >> 8) & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\telse if (fieldBytes == 3)\n\t{\n\t\tbyte = fieldFlags & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t\tbyte = (fieldFlags >> 8) & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t\tbyte = (fieldFlags >> 16) & 0xFF;\n\t\tStream_Write_UINT8(s, byte);\n\t}\n\telse\n\t{\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\nstatic BOOL update_read_bounds(wStream* s, rdpBounds* bounds)\n{\n\tBYTE flags;\n\n\tif (Stream_GetRemainingLength(s) < 1)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, flags); /* field flags */\n\n\tif (flags & BOUND_LEFT)\n\t{\n\t\tif (!update_read_coord(s, &bounds->left, FALSE))\n\t\t\treturn FALSE;\n\t}\n\telse if (flags & BOUND_DELTA_LEFT)\n\t{\n\t\tif (!update_read_coord(s, &bounds->left, TRUE))\n\t\t\treturn FALSE;\n\t}\n\n\tif (flags & BOUND_TOP)\n\t{\n\t\tif (!update_read_coord(s, &bounds->top, FALSE))\n\t\t\treturn FALSE;\n\t}\n\telse if (flags & BOUND_DELTA_TOP)\n\t{\n\t\tif (!update_read_coord(s, &bounds->top, TRUE))\n\t\t\treturn FALSE;\n\t}\n\n\tif (flags & BOUND_RIGHT)\n\t{\n\t\tif (!update_read_coord(s, &bounds->right, FALSE))\n\t\t\treturn FALSE;\n\t}\n\telse if (flags & BOUND_DELTA_RIGHT)\n\t{\n\t\tif (!update_read_coord(s, &bounds->right, TRUE))\n\t\t\treturn FALSE;\n\t}\n\n\tif (flags & BOUND_BOTTOM)\n\t{\n\t\tif (!update_read_coord(s, &bounds->bottom, FALSE))\n\t\t\treturn FALSE;\n\t}\n\telse if (flags & BOUND_DELTA_BOTTOM)\n\t{\n\t\tif (!update_read_coord(s, &bounds->bottom, TRUE))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\nBOOL update_write_bounds(wStream* s, ORDER_INFO* orderInfo)\n{\n\tif (!(orderInfo->controlFlags & ORDER_BOUNDS))\n\t\treturn TRUE;\n\n\tif (orderInfo->controlFlags & ORDER_ZERO_BOUNDS_DELTAS)\n\t\treturn TRUE;\n\n\tStream_Write_UINT8(s, orderInfo->boundsFlags); /* field flags */\n\n\tif (orderInfo->boundsFlags & BOUND_LEFT)\n\t{\n\t\tif (!update_write_coord(s, orderInfo->bounds.left))\n\t\t\treturn FALSE;\n\t}\n\telse if (orderInfo->boundsFlags & BOUND_DELTA_LEFT)\n\t{\n\t}\n\n\tif (orderInfo->boundsFlags & BOUND_TOP)\n\t{\n\t\tif (!update_write_coord(s, orderInfo->bounds.top))\n\t\t\treturn FALSE;\n\t}\n\telse if (orderInfo->boundsFlags & BOUND_DELTA_TOP)\n\t{\n\t}\n\n\tif (orderInfo->boundsFlags & BOUND_RIGHT)\n\t{\n\t\tif (!update_write_coord(s, orderInfo->bounds.right))\n\t\t\treturn FALSE;\n\t}\n\telse if (orderInfo->boundsFlags & BOUND_DELTA_RIGHT)\n\t{\n\t}\n\n\tif (orderInfo->boundsFlags & BOUND_BOTTOM)\n\t{\n\t\tif (!update_write_coord(s, orderInfo->bounds.bottom))\n\t\t\treturn FALSE;\n\t}\n\telse if (orderInfo->boundsFlags & BOUND_DELTA_BOTTOM)\n\t{\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL read_primary_order(wLog* log, const char* orderName, wStream* s,\n                               const ORDER_INFO* orderInfo, rdpPrimaryUpdate* primary)\n{\n\tBOOL rc = FALSE;\n\n\tif (!s || !orderInfo || !primary || !orderName)\n\t\treturn FALSE;\n\n\tswitch (orderInfo->orderType)\n\t{\n\t\tcase ORDER_TYPE_DSTBLT:\n\t\t\trc = update_read_dstblt_order(s, orderInfo, &(primary->dstblt));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_PATBLT:\n\t\t\trc = update_read_patblt_order(s, orderInfo, &(primary->patblt));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_SCRBLT:\n\t\t\trc = update_read_scrblt_order(s, orderInfo, &(primary->scrblt));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_OPAQUE_RECT:\n\t\t\trc = update_read_opaque_rect_order(s, orderInfo, &(primary->opaque_rect));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_DRAW_NINE_GRID:\n\t\t\trc = update_read_draw_nine_grid_order(s, orderInfo, &(primary->draw_nine_grid));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_DSTBLT:\n\t\t\trc = update_read_multi_dstblt_order(s, orderInfo, &(primary->multi_dstblt));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_PATBLT:\n\t\t\trc = update_read_multi_patblt_order(s, orderInfo, &(primary->multi_patblt));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_SCRBLT:\n\t\t\trc = update_read_multi_scrblt_order(s, orderInfo, &(primary->multi_scrblt));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_OPAQUE_RECT:\n\t\t\trc = update_read_multi_opaque_rect_order(s, orderInfo, &(primary->multi_opaque_rect));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_DRAW_NINE_GRID:\n\t\t\trc = update_read_multi_draw_nine_grid_order(s, orderInfo,\n\t\t\t                                            &(primary->multi_draw_nine_grid));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_LINE_TO:\n\t\t\trc = update_read_line_to_order(s, orderInfo, &(primary->line_to));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYLINE:\n\t\t\trc = update_read_polyline_order(s, orderInfo, &(primary->polyline));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MEMBLT:\n\t\t\trc = update_read_memblt_order(s, orderInfo, &(primary->memblt));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_MEM3BLT:\n\t\t\trc = update_read_mem3blt_order(s, orderInfo, &(primary->mem3blt));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_SAVE_BITMAP:\n\t\t\trc = update_read_save_bitmap_order(s, orderInfo, &(primary->save_bitmap));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GLYPH_INDEX:\n\t\t\trc = update_read_glyph_index_order(s, orderInfo, &(primary->glyph_index));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_FAST_INDEX:\n\t\t\trc = update_read_fast_index_order(s, orderInfo, &(primary->fast_index));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_FAST_GLYPH:\n\t\t\trc = update_read_fast_glyph_order(s, orderInfo, &(primary->fast_glyph));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYGON_SC:\n\t\t\trc = update_read_polygon_sc_order(s, orderInfo, &(primary->polygon_sc));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYGON_CB:\n\t\t\trc = update_read_polygon_cb_order(s, orderInfo, &(primary->polygon_cb));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_ELLIPSE_SC:\n\t\t\trc = update_read_ellipse_sc_order(s, orderInfo, &(primary->ellipse_sc));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_ELLIPSE_CB:\n\t\t\trc = update_read_ellipse_cb_order(s, orderInfo, &(primary->ellipse_cb));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(log, WLOG_WARN, \"Primary Drawing Order %s not supported, ignoring\",\n\t\t\t           orderName);\n\t\t\trc = TRUE;\n\t\t\tbreak;\n\t}\n\n\tif (!rc)\n\t{\n\t\tWLog_Print(log, WLOG_ERROR, \"%s - update_read_dstblt_order() failed\", orderName);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL update_recv_primary_order(rdpUpdate* update, wStream* s, BYTE flags)\n{\n\tBOOL rc = FALSE;\n\trdpContext* context = update->context;\n\trdpPrimaryUpdate* primary = update->primary;\n\tORDER_INFO* orderInfo = &(primary->order_info);\n\trdpSettings* settings = context->settings;\n\tconst char* orderName;\n\n\tif (flags & ORDER_TYPE_CHANGE)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_ERROR, \"Stream_GetRemainingLength(s) < 1\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tStream_Read_UINT8(s, orderInfo->orderType); /* orderType (1 byte) */\n\t}\n\n\torderName = primary_order_string(orderInfo->orderType);\n\n\tif (!check_primary_order_supported(update->log, settings, orderInfo->orderType, orderName))\n\t\treturn FALSE;\n\n\tif (!update_read_field_flags(s, &(orderInfo->fieldFlags), flags,\n\t                             PRIMARY_DRAWING_ORDER_FIELD_BYTES[orderInfo->orderType]))\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"update_read_field_flags() failed\");\n\t\treturn FALSE;\n\t}\n\n\tif (flags & ORDER_BOUNDS)\n\t{\n\t\tif (!(flags & ORDER_ZERO_BOUNDS_DELTAS))\n\t\t{\n\t\t\tif (!update_read_bounds(s, &orderInfo->bounds))\n\t\t\t{\n\t\t\t\tWLog_Print(update->log, WLOG_ERROR, \"update_read_bounds() failed\");\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\n\t\trc = IFCALLRESULT(FALSE, update->SetBounds, context, &orderInfo->bounds);\n\n\t\tif (!rc)\n\t\t\treturn FALSE;\n\t}\n\n\torderInfo->deltaCoordinates = (flags & ORDER_DELTA_COORDINATES) ? TRUE : FALSE;\n\n\tif (!read_primary_order(update->log, orderName, s, orderInfo, primary))\n\t\treturn FALSE;\n\n\tswitch (orderInfo->orderType)\n\t{\n\t\tcase ORDER_TYPE_DSTBLT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s rop=%s [0x%08\" PRIx32 \"]\",\n\t\t\t           orderName, gdi_rop3_code_string(primary->dstblt.bRop),\n\t\t\t           gdi_rop3_code(primary->dstblt.bRop));\n\t\t\trc = IFCALLRESULT(FALSE, primary->DstBlt, context, &primary->dstblt);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_PATBLT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s rop=%s [0x%08\" PRIx32 \"]\",\n\t\t\t           orderName, gdi_rop3_code_string(primary->patblt.bRop),\n\t\t\t           gdi_rop3_code(primary->patblt.bRop));\n\t\t\trc = IFCALLRESULT(FALSE, primary->PatBlt, context, &primary->patblt);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_SCRBLT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s rop=%s [0x%08\" PRIx32 \"]\",\n\t\t\t           orderName, gdi_rop3_code_string(primary->scrblt.bRop),\n\t\t\t           gdi_rop3_code(primary->scrblt.bRop));\n\t\t\trc = IFCALLRESULT(FALSE, primary->ScrBlt, context, &primary->scrblt);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_OPAQUE_RECT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->OpaqueRect, context, &primary->opaque_rect);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_DRAW_NINE_GRID:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->DrawNineGrid, context, &primary->draw_nine_grid);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_DSTBLT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s rop=%s [0x%08\" PRIx32 \"]\",\n\t\t\t           orderName, gdi_rop3_code_string(primary->multi_dstblt.bRop),\n\t\t\t           gdi_rop3_code(primary->multi_dstblt.bRop));\n\t\t\trc = IFCALLRESULT(FALSE, primary->MultiDstBlt, context, &primary->multi_dstblt);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_PATBLT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s rop=%s [0x%08\" PRIx32 \"]\",\n\t\t\t           orderName, gdi_rop3_code_string(primary->multi_patblt.bRop),\n\t\t\t           gdi_rop3_code(primary->multi_patblt.bRop));\n\t\t\trc = IFCALLRESULT(FALSE, primary->MultiPatBlt, context, &primary->multi_patblt);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_SCRBLT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s rop=%s [0x%08\" PRIx32 \"]\",\n\t\t\t           orderName, gdi_rop3_code_string(primary->multi_scrblt.bRop),\n\t\t\t           gdi_rop3_code(primary->multi_scrblt.bRop));\n\t\t\trc = IFCALLRESULT(FALSE, primary->MultiScrBlt, context, &primary->multi_scrblt);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_OPAQUE_RECT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc =\n\t\t\t    IFCALLRESULT(FALSE, primary->MultiOpaqueRect, context, &primary->multi_opaque_rect);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_MULTI_DRAW_NINE_GRID:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->MultiDrawNineGrid, context,\n\t\t\t                  &primary->multi_draw_nine_grid);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_LINE_TO:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->LineTo, context, &primary->line_to);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYLINE:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->Polyline, context, &primary->polyline);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_MEMBLT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s rop=%s [0x%08\" PRIx32 \"]\",\n\t\t\t           orderName, gdi_rop3_code_string(primary->memblt.bRop),\n\t\t\t           gdi_rop3_code(primary->memblt.bRop));\n\t\t\trc = IFCALLRESULT(FALSE, primary->MemBlt, context, &primary->memblt);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_MEM3BLT:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s rop=%s [0x%08\" PRIx32 \"]\",\n\t\t\t           orderName, gdi_rop3_code_string(primary->mem3blt.bRop),\n\t\t\t           gdi_rop3_code(primary->mem3blt.bRop));\n\t\t\trc = IFCALLRESULT(FALSE, primary->Mem3Blt, context, &primary->mem3blt);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_SAVE_BITMAP:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->SaveBitmap, context, &primary->save_bitmap);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_GLYPH_INDEX:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->GlyphIndex, context, &primary->glyph_index);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_FAST_INDEX:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->FastIndex, context, &primary->fast_index);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_FAST_GLYPH:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->FastGlyph, context, &primary->fast_glyph);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYGON_SC:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->PolygonSC, context, &primary->polygon_sc);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_POLYGON_CB:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->PolygonCB, context, &primary->polygon_cb);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_ELLIPSE_SC:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->EllipseSC, context, &primary->ellipse_sc);\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_ELLIPSE_CB:\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"Primary Drawing Order %s\", orderName);\n\t\t\trc = IFCALLRESULT(FALSE, primary->EllipseCB, context, &primary->ellipse_cb);\n\t\t}\n\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(update->log, WLOG_WARN, \"Primary Drawing Order %s not supported\", orderName);\n\t\t\tbreak;\n\t}\n\n\tif (!rc)\n\t{\n\t\tWLog_Print(update->log, WLOG_WARN, \"Primary Drawing Order %s failed\", orderName);\n\t\treturn FALSE;\n\t}\n\n\tif (flags & ORDER_BOUNDS)\n\t{\n\t\trc = IFCALLRESULT(FALSE, update->SetBounds, context, NULL);\n\t}\n\n\treturn rc;\n}\n\nstatic BOOL update_recv_secondary_order(rdpUpdate* update, wStream* s, BYTE flags)\n{\n\tBOOL rc = FALSE;\n\tBYTE* next;\n\tBYTE orderType;\n\tUINT16 extraFlags;\n\tUINT16 orderLength;\n\trdpContext* context = update->context;\n\trdpSettings* settings = context->settings;\n\trdpSecondaryUpdate* secondary = update->secondary;\n\tconst char* name;\n\n\tif (Stream_GetRemainingLength(s) < 5)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"Stream_GetRemainingLength(s) < 5\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, orderLength); /* orderLength (2 bytes) */\n\tStream_Read_UINT16(s, extraFlags);  /* extraFlags (2 bytes) */\n\tStream_Read_UINT8(s, orderType);    /* orderType (1 byte) */\n\tnext = Stream_Pointer(s) + ((INT16)orderLength) + 7;\n\tname = secondary_order_string(orderType);\n\tWLog_Print(update->log, WLOG_DEBUG, \"Secondary Drawing Order %s\", name);\n\n\tif (!check_secondary_order_supported(update->log, settings, orderType, name))\n\t\treturn FALSE;\n\n\tswitch (orderType)\n\t{\n\t\tcase ORDER_TYPE_BITMAP_UNCOMPRESSED:\n\t\tcase ORDER_TYPE_CACHE_BITMAP_COMPRESSED:\n\t\t{\n\t\t\tconst BOOL compressed = (orderType == ORDER_TYPE_CACHE_BITMAP_COMPRESSED);\n\t\t\tCACHE_BITMAP_ORDER* order =\n\t\t\t    update_read_cache_bitmap_order(update, s, compressed, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBitmap, context, order);\n\t\t\t\tfree_cache_bitmap_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_BITMAP_UNCOMPRESSED_V2:\n\t\tcase ORDER_TYPE_BITMAP_COMPRESSED_V2:\n\t\t{\n\t\t\tconst BOOL compressed = (orderType == ORDER_TYPE_BITMAP_COMPRESSED_V2);\n\t\t\tCACHE_BITMAP_V2_ORDER* order =\n\t\t\t    update_read_cache_bitmap_v2_order(update, s, compressed, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBitmapV2, context, order);\n\t\t\t\tfree_cache_bitmap_v2_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_BITMAP_COMPRESSED_V3:\n\t\t{\n\t\t\tCACHE_BITMAP_V3_ORDER* order = update_read_cache_bitmap_v3_order(update, s, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBitmapV3, context, order);\n\t\t\t\tfree_cache_bitmap_v3_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_COLOR_TABLE:\n\t\t{\n\t\t\tCACHE_COLOR_TABLE_ORDER* order =\n\t\t\t    update_read_cache_color_table_order(update, s, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheColorTable, context, order);\n\t\t\t\tfree_cache_color_table_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_GLYPH:\n\t\t{\n\t\t\tswitch (settings->GlyphSupportLevel)\n\t\t\t{\n\t\t\t\tcase GLYPH_SUPPORT_PARTIAL:\n\t\t\t\tcase GLYPH_SUPPORT_FULL:\n\t\t\t\t{\n\t\t\t\t\tCACHE_GLYPH_ORDER* order = update_read_cache_glyph_order(update, s, extraFlags);\n\n\t\t\t\t\tif (order)\n\t\t\t\t\t{\n\t\t\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheGlyph, context, order);\n\t\t\t\t\t\tfree_cache_glyph_order(context, order);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\tcase GLYPH_SUPPORT_ENCODE:\n\t\t\t\t{\n\t\t\t\t\tCACHE_GLYPH_V2_ORDER* order =\n\t\t\t\t\t    update_read_cache_glyph_v2_order(update, s, extraFlags);\n\n\t\t\t\t\tif (order)\n\t\t\t\t\t{\n\t\t\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheGlyphV2, context, order);\n\t\t\t\t\t\tfree_cache_glyph_v2_order(context, order);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\tcase GLYPH_SUPPORT_NONE:\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_BRUSH:\n\t\t\t/* [MS-RDPEGDI] 2.2.2.2.1.2.7 Cache Brush (CACHE_BRUSH_ORDER) */\n\t\t\t{\n\t\t\t\tCACHE_BRUSH_ORDER* order = update_read_cache_brush_order(update, s, extraFlags);\n\n\t\t\t\tif (order)\n\t\t\t\t{\n\t\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBrush, context, order);\n\t\t\t\t\tfree_cache_brush_order(context, order);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(update->log, WLOG_WARN, \"SECONDARY ORDER %s not supported\", name);\n\t\t\tbreak;\n\t}\n\n\tif (!rc)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"SECONDARY ORDER %s failed\", name);\n\t}\n\n\tStream_SetPointer(s, next);\n\treturn rc;\n}\n\nstatic BOOL read_altsec_order(wStream* s, BYTE orderType, rdpAltSecUpdate* altsec)\n{\n\tBOOL rc = FALSE;\n\n\tswitch (orderType)\n\t{\n\t\tcase ORDER_TYPE_CREATE_OFFSCREEN_BITMAP:\n\t\t\trc = update_read_create_offscreen_bitmap_order(s, &(altsec->create_offscreen_bitmap));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_SWITCH_SURFACE:\n\t\t\trc = update_read_switch_surface_order(s, &(altsec->switch_surface));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_CREATE_NINE_GRID_BITMAP:\n\t\t\trc = update_read_create_nine_grid_bitmap_order(s, &(altsec->create_nine_grid_bitmap));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_FRAME_MARKER:\n\t\t\trc = update_read_frame_marker_order(s, &(altsec->frame_marker));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_STREAM_BITMAP_FIRST:\n\t\t\trc = update_read_stream_bitmap_first_order(s, &(altsec->stream_bitmap_first));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_STREAM_BITMAP_NEXT:\n\t\t\trc = update_read_stream_bitmap_next_order(s, &(altsec->stream_bitmap_next));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_FIRST:\n\t\t\trc = update_read_draw_gdiplus_first_order(s, &(altsec->draw_gdiplus_first));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_NEXT:\n\t\t\trc = update_read_draw_gdiplus_next_order(s, &(altsec->draw_gdiplus_next));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_END:\n\t\t\trc = update_read_draw_gdiplus_end_order(s, &(altsec->draw_gdiplus_end));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_FIRST:\n\t\t\trc = update_read_draw_gdiplus_cache_first_order(s, &(altsec->draw_gdiplus_cache_first));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_NEXT:\n\t\t\trc = update_read_draw_gdiplus_cache_next_order(s, &(altsec->draw_gdiplus_cache_next));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_END:\n\t\t\trc = update_read_draw_gdiplus_cache_end_order(s, &(altsec->draw_gdiplus_cache_end));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_WINDOW:\n\t\t\t/* This order is handled elsewhere. */\n\t\t\trc = TRUE;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_COMPDESK_FIRST:\n\t\t\trc = TRUE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic BOOL update_recv_altsec_order(rdpUpdate* update, wStream* s, BYTE flags)\n{\n\tBYTE orderType = flags >>= 2; /* orderType is in higher 6 bits of flags field */\n\tBOOL rc = FALSE;\n\trdpContext* context = update->context;\n\trdpSettings* settings = context->settings;\n\trdpAltSecUpdate* altsec = update->altsec;\n\tconst char* orderName = altsec_order_string(orderType);\n\tWLog_Print(update->log, WLOG_DEBUG, \"Alternate Secondary Drawing Order %s\", orderName);\n\n\tif (!check_alt_order_supported(update->log, settings, orderType, orderName))\n\t\treturn FALSE;\n\n\tif (!read_altsec_order(s, orderType, altsec))\n\t\treturn FALSE;\n\n\tswitch (orderType)\n\t{\n\t\tcase ORDER_TYPE_CREATE_OFFSCREEN_BITMAP:\n\t\t\tIFCALLRET(altsec->CreateOffscreenBitmap, rc, context,\n\t\t\t          &(altsec->create_offscreen_bitmap));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_SWITCH_SURFACE:\n\t\t\tIFCALLRET(altsec->SwitchSurface, rc, context, &(altsec->switch_surface));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_CREATE_NINE_GRID_BITMAP:\n\t\t\tIFCALLRET(altsec->CreateNineGridBitmap, rc, context,\n\t\t\t          &(altsec->create_nine_grid_bitmap));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_FRAME_MARKER:\n\t\t\tIFCALLRET(altsec->FrameMarker, rc, context, &(altsec->frame_marker));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_STREAM_BITMAP_FIRST:\n\t\t\tIFCALLRET(altsec->StreamBitmapFirst, rc, context, &(altsec->stream_bitmap_first));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_STREAM_BITMAP_NEXT:\n\t\t\tIFCALLRET(altsec->StreamBitmapNext, rc, context, &(altsec->stream_bitmap_next));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_FIRST:\n\t\t\tIFCALLRET(altsec->DrawGdiPlusFirst, rc, context, &(altsec->draw_gdiplus_first));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_NEXT:\n\t\t\tIFCALLRET(altsec->DrawGdiPlusNext, rc, context, &(altsec->draw_gdiplus_next));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_END:\n\t\t\tIFCALLRET(altsec->DrawGdiPlusEnd, rc, context, &(altsec->draw_gdiplus_end));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_FIRST:\n\t\t\tIFCALLRET(altsec->DrawGdiPlusCacheFirst, rc, context,\n\t\t\t          &(altsec->draw_gdiplus_cache_first));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_NEXT:\n\t\t\tIFCALLRET(altsec->DrawGdiPlusCacheNext, rc, context,\n\t\t\t          &(altsec->draw_gdiplus_cache_next));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_GDIPLUS_CACHE_END:\n\t\t\tIFCALLRET(altsec->DrawGdiPlusCacheEnd, rc, context, &(altsec->draw_gdiplus_cache_end));\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_WINDOW:\n\t\t\trc = update_recv_altsec_window_order(update, s);\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_COMPDESK_FIRST:\n\t\t\trc = TRUE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\tif (!rc)\n\t{\n\t\tWLog_Print(update->log, WLOG_WARN, \"Alternate Secondary Drawing Order %s failed\",\n\t\t           orderName);\n\t}\n\n\treturn rc;\n}\nBOOL update_recv_order(rdpUpdate* update, wStream* s)\n{\n\tBOOL rc;\n\tBYTE controlFlags;\n\n\tif (Stream_GetRemainingLength(s) < 1)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"Stream_GetRemainingLength(s) < 1\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT8(s, controlFlags); /* controlFlags (1 byte) */\n\n\tif (!(controlFlags & ORDER_STANDARD))\n\t\trc = update_recv_altsec_order(update, s, controlFlags);\n\telse if (controlFlags & ORDER_SECONDARY)\n\t\trc = update_recv_secondary_order(update, s, controlFlags);\n\telse\n\t\trc = update_recv_primary_order(update, s, controlFlags);\n\n\tif (!rc)\n\t\tWLog_Print(update->log, WLOG_ERROR, \"order flags %02\" PRIx8 \" failed\", controlFlags);\n\n\treturn rc;\n}\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * RDP Server Peer\n *\n * Copyright 2011 Vic Lee\n * Copyright 2014 DI (FH) Martin Haimberger <martin.haimberger@thincast.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <winpr/crt.h>\n#include <winpr/winsock.h>\n\n#include \"info.h\"\n#include \"certificate.h\"\n\n#include <freerdp/log.h>\n\n#include \"rdp.h\"\n#include \"peer.h\"\n\n#define TAG FREERDP_TAG(\"core.peer\")\n\nstatic HANDLE freerdp_peer_virtual_channel_open(freerdp_peer* client, const char* name,\n                                                UINT32 flags)\n{\n\tint length;\n\tUINT32 index;\n\tBOOL joined = FALSE;\n\trdpMcsChannel* mcsChannel = NULL;\n\trdpPeerChannel* peerChannel = NULL;\n\trdpMcs* mcs = client->context->rdp->mcs;\n\n\tif (flags & WTS_CHANNEL_OPTION_DYNAMIC)\n\t\treturn NULL; /* not yet supported */\n\n\tlength = strnlen(name, 9);\n\n\tif (length > 8)\n\t\treturn NULL; /* SVC maximum name length is 8 */\n\n\tfor (index = 0; index < mcs->channelCount; index++)\n\t{\n\t\tmcsChannel = &(mcs->channels[index]);\n\n\t\tif (!mcsChannel->joined)\n\t\t\tcontinue;\n\n\t\tif (_strnicmp(name, mcsChannel->Name, length) == 0)\n\t\t{\n\t\t\tjoined = TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!joined)\n\t\treturn NULL; /* channel is not joined */\n\n\tpeerChannel = (rdpPeerChannel*)mcsChannel->handle;\n\n\tif (peerChannel)\n\t{\n\t\t/* channel is already open */\n\t\treturn (HANDLE)peerChannel;\n\t}\n\n\tpeerChannel = (rdpPeerChannel*)calloc(1, sizeof(rdpPeerChannel));\n\n\tif (peerChannel)\n\t{\n\t\tpeerChannel->index = index;\n\t\tpeerChannel->client = client;\n\t\tpeerChannel->channelFlags = flags;\n\t\tpeerChannel->channelId = mcsChannel->ChannelId;\n\t\tpeerChannel->mcsChannel = mcsChannel;\n\t\tmcsChannel->handle = (void*)peerChannel;\n\t}\n\n\treturn (HANDLE)peerChannel;\n}\n\nstatic BOOL freerdp_peer_virtual_channel_close(freerdp_peer* client, HANDLE hChannel)\n{\n\trdpMcsChannel* mcsChannel = NULL;\n\trdpPeerChannel* peerChannel = NULL;\n\n\tif (!hChannel)\n\t\treturn FALSE;\n\n\tpeerChannel = (rdpPeerChannel*)hChannel;\n\tmcsChannel = peerChannel->mcsChannel;\n\tmcsChannel->handle = NULL;\n\tfree(peerChannel);\n\treturn TRUE;\n}\n\nstatic int freerdp_peer_virtual_channel_write(freerdp_peer* client, HANDLE hChannel,\n                                              const BYTE* buffer, UINT32 length)\n{\n\twStream* s;\n\tUINT32 flags;\n\tUINT32 chunkSize;\n\tUINT32 maxChunkSize;\n\tUINT32 totalLength;\n\trdpPeerChannel* peerChannel;\n\trdpMcsChannel* mcsChannel;\n\trdpRdp* rdp = client->context->rdp;\n\n\tif (!hChannel)\n\t\treturn -1;\n\n\tpeerChannel = (rdpPeerChannel*)hChannel;\n\tmcsChannel = peerChannel->mcsChannel;\n\n\tif (peerChannel->channelFlags & WTS_CHANNEL_OPTION_DYNAMIC)\n\t\treturn -1; /* not yet supported */\n\n\tmaxChunkSize = rdp->settings->VirtualChannelChunkSize;\n\ttotalLength = length;\n\tflags = CHANNEL_FLAG_FIRST;\n\n\twhile (length > 0)\n\t{\n\t\ts = rdp_send_stream_init(rdp);\n\n\t\tif (!s)\n\t\t\treturn -1;\n\n\t\tif (length > maxChunkSize)\n\t\t{\n\t\t\tchunkSize = rdp->settings->VirtualChannelChunkSize;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tchunkSize = length;\n\t\t\tflags |= CHANNEL_FLAG_LAST;\n\t\t}\n\n\t\tif (mcsChannel->options & CHANNEL_OPTION_SHOW_PROTOCOL)\n\t\t\tflags |= CHANNEL_FLAG_SHOW_PROTOCOL;\n\n\t\tStream_Write_UINT32(s, totalLength);\n\t\tStream_Write_UINT32(s, flags);\n\n\t\tif (!Stream_EnsureRemainingCapacity(s, chunkSize))\n\t\t{\n\t\t\tStream_Release(s);\n\t\t\treturn -1;\n\t\t}\n\n\t\tStream_Write(s, buffer, chunkSize);\n\n\t\tif (!rdp_send(rdp, s, peerChannel->channelId))\n\t\t\treturn -1;\n\n\t\tbuffer += chunkSize;\n\t\tlength -= chunkSize;\n\t\tflags = 0;\n\t}\n\n\treturn 1;\n}\n\nstatic void* freerdp_peer_virtual_channel_get_data(freerdp_peer* client, HANDLE hChannel)\n{\n\trdpPeerChannel* peerChannel = (rdpPeerChannel*)hChannel;\n\n\tif (!hChannel)\n\t\treturn NULL;\n\n\treturn peerChannel->extra;\n}\n\nstatic int freerdp_peer_virtual_channel_set_data(freerdp_peer* client, HANDLE hChannel, void* data)\n{\n\trdpPeerChannel* peerChannel = (rdpPeerChannel*)hChannel;\n\n\tif (!hChannel)\n\t\treturn -1;\n\n\tpeerChannel->extra = data;\n\treturn 1;\n}\n\nstatic BOOL freerdp_peer_initialize(freerdp_peer* client)\n{\n\trdpRdp* rdp = client->context->rdp;\n\trdpSettings* settings = rdp->settings;\n\tsettings->ServerMode = TRUE;\n\tsettings->FrameAcknowledge = 0;\n\tsettings->LocalConnection = client->local;\n\trdp->state = CONNECTION_STATE_INITIAL;\n\n\tif (settings->RdpKeyFile)\n\t{\n\t\tsettings->RdpServerRsaKey = key_new(settings->RdpKeyFile);\n\n\t\tif (!settings->RdpServerRsaKey)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"invalid RDP key file %s\", settings->RdpKeyFile);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\telse if (settings->RdpKeyContent)\n\t{\n\t\tsettings->RdpServerRsaKey = key_new_from_content(settings->RdpKeyContent, NULL);\n\n\t\tif (!settings->RdpServerRsaKey)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"invalid RDP key content\");\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL freerdp_peer_get_fds(freerdp_peer* client, void** rfds, int* rcount)\n{\n\trdpTransport* transport = client->context->rdp->transport;\n\ttransport_get_fds(transport, rfds, rcount);\n\treturn TRUE;\n}\n\nstatic HANDLE freerdp_peer_get_event_handle(freerdp_peer* client)\n{\n\tHANDLE hEvent = NULL;\n\trdpTransport* transport = client->context->rdp->transport;\n\tBIO_get_event(transport->frontBio, &hEvent);\n\treturn hEvent;\n}\n\nstatic DWORD freerdp_peer_get_event_handles(freerdp_peer* client, HANDLE* events, DWORD count)\n{\n\treturn transport_get_event_handles(client->context->rdp->transport, events, count);\n}\n\nstatic BOOL freerdp_peer_check_fds(freerdp_peer* peer)\n{\n\tint status;\n\trdpRdp* rdp;\n\trdp = peer->context->rdp;\n\tstatus = rdp_check_fds(rdp);\n\n\tif (status < 0)\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\nstatic BOOL peer_recv_data_pdu(freerdp_peer* client, wStream* s, UINT16 totalLength)\n{\n\tBYTE type;\n\tUINT16 length;\n\tUINT32 share_id;\n\tBYTE compressed_type;\n\tUINT16 compressed_len;\n\n\tif (!rdp_read_share_data_header(s, &length, &type, &share_id, &compressed_type,\n\t                                &compressed_len))\n\t\treturn FALSE;\n\n#ifdef WITH_DEBUG_RDP\n\tWLog_DBG(TAG, \"recv %s Data PDU (0x%02\" PRIX8 \"), length: %\" PRIu16 \"\",\n\t         type < ARRAYSIZE(DATA_PDU_TYPE_STRINGS) ? DATA_PDU_TYPE_STRINGS[type] : \"???\", type,\n\t         length);\n#endif\n\n\tswitch (type)\n\t{\n\t\tcase DATA_PDU_TYPE_SYNCHRONIZE:\n\t\t\tif (!rdp_recv_client_synchronize_pdu(client->context->rdp, s))\n\t\t\t\treturn FALSE;\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_CONTROL:\n\t\t\tif (!rdp_server_accept_client_control_pdu(client->context->rdp, s))\n\t\t\t\treturn FALSE;\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_INPUT:\n\t\t\tif (!input_recv(client->context->rdp->input, s))\n\t\t\t\treturn FALSE;\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_BITMAP_CACHE_PERSISTENT_LIST:\n\t\t\t/* TODO: notify server bitmap cache data */\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_FONT_LIST:\n\t\t\tif (!rdp_server_accept_client_font_list_pdu(client->context->rdp, s))\n\t\t\t\treturn FALSE;\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_SHUTDOWN_REQUEST:\n\t\t\tmcs_send_disconnect_provider_ultimatum(client->context->rdp->mcs);\n\t\t\treturn FALSE;\n\n\t\tcase DATA_PDU_TYPE_FRAME_ACKNOWLEDGE:\n\t\t\tif (Stream_GetRemainingLength(s) < 4)\n\t\t\t\treturn FALSE;\n\n\t\t\tStream_Read_UINT32(s, client->ack_frame_id);\n\t\t\tIFCALL(client->update->SurfaceFrameAcknowledge, client->update->context,\n\t\t\t       client->ack_frame_id);\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_REFRESH_RECT:\n\t\t\tif (!update_read_refresh_rect(client->update, s))\n\t\t\t\treturn FALSE;\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_SUPPRESS_OUTPUT:\n\t\t\tif (!update_read_suppress_output(client->update, s))\n\t\t\t\treturn FALSE;\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_ERR(TAG, \"Data PDU type %\" PRIu8 \"\", type);\n\t\t\tbreak;\n\t}\n\n\treturn TRUE;\n}\n\nstatic int peer_recv_tpkt_pdu(freerdp_peer* client, wStream* s)\n{\n\trdpRdp* rdp;\n\tUINT16 length;\n\tUINT16 pduType;\n\tUINT16 pduSource;\n\tUINT16 channelId;\n\tUINT16 securityFlags = 0;\n\trdp = client->context->rdp;\n\n\tif (!rdp_read_header(rdp, s, &length, &channelId))\n\t{\n\t\tWLog_ERR(TAG, \"Incorrect RDP header.\");\n\t\treturn -1;\n\t}\n\n\trdp->inPackets++;\n\tif (freerdp_shall_disconnect(rdp->instance))\n\t\treturn 0;\n\n\tif (rdp->settings->UseRdpSecurityLayer)\n\t{\n\t\tif (!rdp_read_security_header(s, &securityFlags, &length))\n\t\t\treturn -1;\n\n\t\tif (securityFlags & SEC_ENCRYPT)\n\t\t{\n\t\t\tif (!rdp_decrypt(rdp, s, &length, securityFlags))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdp_decrypt failed\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (channelId == MCS_GLOBAL_CHANNEL_ID)\n\t{\n\t\tUINT16 pduLength, remain;\n\t\tif (!rdp_read_share_control_header(s, &pduLength, &remain, &pduType, &pduSource))\n\t\t\treturn -1;\n\n\t\tclient->settings->PduSource = pduSource;\n\n\t\tswitch (pduType)\n\t\t{\n\t\t\tcase PDU_TYPE_DATA:\n\t\t\t\tif (!peer_recv_data_pdu(client, s, pduLength))\n\t\t\t\t\treturn -1;\n\n\t\t\t\tbreak;\n\n\t\t\tcase PDU_TYPE_CONFIRM_ACTIVE:\n\t\t\t\tif (!rdp_server_accept_confirm_active(rdp, s, pduLength))\n\t\t\t\t\treturn -1;\n\n\t\t\t\tbreak;\n\n\t\t\tcase PDU_TYPE_FLOW_RESPONSE:\n\t\t\tcase PDU_TYPE_FLOW_STOP:\n\t\t\tcase PDU_TYPE_FLOW_TEST:\n\t\t\t\tif (!Stream_SafeSeek(s, remain))\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tWLog_ERR(TAG, \"Client sent pduType %\" PRIu16 \"\", pduType);\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\telse if ((rdp->mcs->messageChannelId > 0) && (channelId == rdp->mcs->messageChannelId))\n\t{\n\t\tif (!rdp->settings->UseRdpSecurityLayer)\n\t\t\tif (!rdp_read_security_header(s, &securityFlags, NULL))\n\t\t\t\treturn -1;\n\n\t\treturn rdp_recv_message_channel_pdu(rdp, s, securityFlags);\n\t}\n\telse\n\t{\n\t\tif (!freerdp_channel_peer_process(client, s, channelId))\n\t\t\treturn -1;\n\t}\n\n\tif (!tpkt_ensure_stream_consumed(s, length))\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int peer_recv_fastpath_pdu(freerdp_peer* client, wStream* s)\n{\n\trdpRdp* rdp;\n\tUINT16 length;\n\trdpFastPath* fastpath;\n\trdp = client->context->rdp;\n\tfastpath = rdp->fastpath;\n\tfastpath_read_header_rdp(fastpath, s, &length);\n\n\tif ((length == 0) || (length > Stream_GetRemainingLength(s)))\n\t{\n\t\tWLog_ERR(TAG, \"incorrect FastPath PDU header length %\" PRIu16 \"\", length);\n\t\treturn -1;\n\t}\n\n\tif (fastpath->encryptionFlags & FASTPATH_OUTPUT_ENCRYPTED)\n\t{\n\t\tif (!rdp_decrypt(rdp, s, &length,\n\t\t                 (fastpath->encryptionFlags & FASTPATH_OUTPUT_SECURE_CHECKSUM)\n\t\t                     ? SEC_SECURE_CHECKSUM\n\t\t                     : 0))\n\t\t\treturn -1;\n\t}\n\n\trdp->inPackets++;\n\n\treturn fastpath_recv_inputs(fastpath, s);\n}\n\nstatic int peer_recv_pdu(freerdp_peer* client, wStream* s)\n{\n\tif (tpkt_verify_header(s))\n\t\treturn peer_recv_tpkt_pdu(client, s);\n\telse\n\t\treturn peer_recv_fastpath_pdu(client, s);\n}\n\nstatic int peer_recv_callback(rdpTransport* transport, wStream* s, void* extra)\n{\n\tUINT32 SelectedProtocol;\n\tfreerdp_peer* client = (freerdp_peer*)extra;\n\trdpRdp* rdp = client->context->rdp;\n\n\tswitch (rdp->state)\n\t{\n\t\tcase CONNECTION_STATE_INITIAL:\n\t\t\tif (!rdp_server_accept_nego(rdp, s))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"%s: %s - rdp_server_accept_nego() fail\", __FUNCTION__,\n\t\t\t\t         rdp_server_connection_state_string(rdp->state));\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tSelectedProtocol = nego_get_selected_protocol(rdp->nego);\n\t\t\tclient->settings->NlaSecurity = (SelectedProtocol & PROTOCOL_HYBRID) ? TRUE : FALSE;\n\t\t\tclient->settings->TlsSecurity = (SelectedProtocol & PROTOCOL_SSL) ? TRUE : FALSE;\n\t\t\tclient->settings->RdpSecurity = (SelectedProtocol == PROTOCOL_RDP) ? TRUE : FALSE;\n\n\t\t\tif (SelectedProtocol & PROTOCOL_HYBRID)\n\t\t\t{\n\t\t\t\tSEC_WINNT_AUTH_IDENTITY* identity = nego_get_identity(rdp->nego);\n\t\t\t\tsspi_CopyAuthIdentity(&client->identity, identity);\n\t\t\t\tIFCALLRET(client->Logon, client->authenticated, client, &client->identity, TRUE);\n\t\t\t\tnego_free_nla(rdp->nego);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tIFCALLRET(client->Logon, client->authenticated, client, &client->identity, FALSE);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_NEGO:\n\t\t\tif (!rdp_server_accept_mcs_connect_initial(rdp, s))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG,\n\t\t\t\t         \"%s: %s - \"\n\t\t\t\t         \"rdp_server_accept_mcs_connect_initial() fail\",\n\t\t\t\t         __FUNCTION__, rdp_server_connection_state_string(rdp->state));\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_CONNECT:\n\t\t\tif (!rdp_server_accept_mcs_erect_domain_request(rdp, s))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG,\n\t\t\t\t         \"%s: %s - \"\n\t\t\t\t         \"rdp_server_accept_mcs_erect_domain_request() fail\",\n\t\t\t\t         __FUNCTION__, rdp_server_connection_state_string(rdp->state));\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_ERECT_DOMAIN:\n\t\t\tif (!rdp_server_accept_mcs_attach_user_request(rdp, s))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG,\n\t\t\t\t         \"%s: %s - \"\n\t\t\t\t         \"rdp_server_accept_mcs_attach_user_request() fail\",\n\t\t\t\t         __FUNCTION__, rdp_server_connection_state_string(rdp->state));\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_ATTACH_USER:\n\t\t\tif (!rdp_server_accept_mcs_channel_join_request(rdp, s))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG,\n\t\t\t\t         \"%s: %s - \"\n\t\t\t\t         \"rdp_server_accept_mcs_channel_join_request() fail\",\n\t\t\t\t         __FUNCTION__, rdp_server_connection_state_string(rdp->state));\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_RDP_SECURITY_COMMENCEMENT:\n\t\t\tif (rdp->settings->UseRdpSecurityLayer)\n\t\t\t{\n\t\t\t\tif (!rdp_server_establish_keys(rdp, s))\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG,\n\t\t\t\t\t         \"%s: %s - \"\n\t\t\t\t\t         \"rdp_server_establish_keys() fail\",\n\t\t\t\t\t         __FUNCTION__, rdp_server_connection_state_string(rdp->state));\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trdp_server_transition_to_state(rdp, CONNECTION_STATE_SECURE_SETTINGS_EXCHANGE);\n\n\t\t\tif (Stream_GetRemainingLength(s) > 0)\n\t\t\t\treturn peer_recv_callback(transport, s, extra);\n\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_SECURE_SETTINGS_EXCHANGE:\n\t\t\tif (!rdp_recv_client_info(rdp, s))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG,\n\t\t\t\t         \"%s: %s - \"\n\t\t\t\t         \"rdp_recv_client_info() fail\",\n\t\t\t\t         __FUNCTION__, rdp_server_connection_state_string(rdp->state));\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\trdp_server_transition_to_state(rdp, CONNECTION_STATE_LICENSING);\n\t\t\treturn peer_recv_callback(transport, NULL, extra);\n\n\t\tcase CONNECTION_STATE_LICENSING:\n\t\t{\n\t\t\tLicenseCallbackResult res;\n\n\t\t\tif (!client->LicenseCallback)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG,\n\t\t\t\t         \"%s: LicenseCallback has been removed, assuming \"\n\t\t\t\t         \"licensing is ok (please fix your app)\",\n\t\t\t\t         __FUNCTION__);\n\t\t\t\tres = LICENSE_CB_COMPLETED;\n\t\t\t}\n\t\t\telse\n\t\t\t\tres = client->LicenseCallback(client, s);\n\n\t\t\tswitch (res)\n\t\t\t{\n\t\t\t\tcase LICENSE_CB_INTERNAL_ERROR:\n\t\t\t\t\tWLog_ERR(TAG,\n\t\t\t\t\t         \"%s: %s - callback internal \"\n\t\t\t\t\t         \"error, aborting\",\n\t\t\t\t\t         __FUNCTION__, rdp_server_connection_state_string(rdp->state));\n\t\t\t\t\treturn -1;\n\n\t\t\t\tcase LICENSE_CB_ABORT:\n\t\t\t\t\treturn -1;\n\n\t\t\t\tcase LICENSE_CB_IN_PROGRESS:\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase LICENSE_CB_COMPLETED:\n\t\t\t\t\trdp_server_transition_to_state(rdp, CONNECTION_STATE_CAPABILITIES_EXCHANGE);\n\t\t\t\t\treturn peer_recv_callback(transport, NULL, extra);\n\n\t\t\t\tdefault:\n\t\t\t\t\tWLog_ERR(TAG,\n\t\t\t\t\t         \"%s: CONNECTION_STATE_LICENSING - unknown license callback \"\n\t\t\t\t\t         \"result %d\",\n\t\t\t\t\t         __FUNCTION__, res);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase CONNECTION_STATE_CAPABILITIES_EXCHANGE:\n\t\t\tif (!rdp->AwaitCapabilities)\n\t\t\t{\n\t\t\t\tif (client->Capabilities && !client->Capabilities(client))\n\t\t\t\t\treturn -1;\n\n\t\t\t\tif (!rdp_send_demand_active(rdp))\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG,\n\t\t\t\t\t         \"%s: %s - \"\n\t\t\t\t\t         \"rdp_send_demand_active() fail\",\n\t\t\t\t\t         __FUNCTION__, rdp_server_connection_state_string(rdp->state));\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\trdp->AwaitCapabilities = TRUE;\n\n\t\t\t\tif (s)\n\t\t\t\t{\n\t\t\t\t\tif (peer_recv_pdu(client, s) < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tWLog_ERR(TAG,\n\t\t\t\t\t\t         \"%s: %s - \"\n\t\t\t\t\t\t         \"peer_recv_pdu() fail\",\n\t\t\t\t\t\t         __FUNCTION__, rdp_server_connection_state_string(rdp->state));\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/**\n\t\t\t\t * During reactivation sequence the client might sent some input or channel data\n\t\t\t\t * before receiving the Deactivate All PDU. We need to process them as usual.\n\t\t\t\t */\n\t\t\t\tif (peer_recv_pdu(client, s) < 0)\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG,\n\t\t\t\t\t         \"%s: %s - \"\n\t\t\t\t\t         \"peer_recv_pdu() fail\",\n\t\t\t\t\t         __FUNCTION__, rdp_server_connection_state_string(rdp->state));\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_FINALIZATION:\n\t\t\tif (peer_recv_pdu(client, s) < 0)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"%s: %s - peer_recv_pdu() fail\", __FUNCTION__,\n\t\t\t\t         rdp_server_connection_state_string(rdp->state));\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_ACTIVE:\n\t\t\tif (peer_recv_pdu(client, s) < 0)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"%s: %s - peer_recv_pdu() fail\", __FUNCTION__,\n\t\t\t\t         rdp_server_connection_state_string(rdp->state));\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_ERR(TAG, \"%s state %d\", rdp_server_connection_state_string(rdp->state),\n\t\t\t         rdp->state);\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic BOOL freerdp_peer_close(freerdp_peer* client)\n{\n\tUINT32 SelectedProtocol;\n\t/** if negotiation has failed, we're not MCS connected. So don't\n\t * \tsend anything else, or some mstsc will consider that as an error\n\t */\n\tSelectedProtocol = nego_get_selected_protocol(client->context->rdp->nego);\n\n\tif (SelectedProtocol & PROTOCOL_FAILED_NEGO)\n\t\treturn TRUE;\n\n\t/**\n\t * [MS-RDPBCGR] 1.3.1.4.2 User-Initiated Disconnection Sequence on Server\n\t * The server first sends the client a Deactivate All PDU followed by an\n\t * optional MCS Disconnect Provider Ultimatum PDU.\n\t */\n\tif (!rdp_send_deactivate_all(client->context->rdp))\n\t\treturn FALSE;\n\n\tif (freerdp_settings_get_bool(client->settings, FreeRDP_SupportErrorInfoPdu))\n\t{\n\t\trdp_send_error_info(client->context->rdp);\n\t}\n\n\treturn mcs_send_disconnect_provider_ultimatum(client->context->rdp->mcs);\n}\n\nstatic void freerdp_peer_disconnect(freerdp_peer* client)\n{\n\trdpTransport* transport = client->context->rdp->transport;\n\ttransport_disconnect(transport);\n}\n\nstatic BOOL freerdp_peer_send_channel_data(freerdp_peer* client, UINT16 channelId, const BYTE* data,\n                                           size_t size)\n{\n\treturn rdp_send_channel_data(client->context->rdp, channelId, data, size);\n}\n\nstatic BOOL freerdp_peer_is_write_blocked(freerdp_peer* peer)\n{\n\trdpTransport* transport = peer->context->rdp->transport;\n\treturn transport_is_write_blocked(transport);\n}\n\nstatic int freerdp_peer_drain_output_buffer(freerdp_peer* peer)\n{\n\trdpTransport* transport = peer->context->rdp->transport;\n\treturn transport_drain_output_buffer(transport);\n}\n\nstatic BOOL freerdp_peer_has_more_to_read(freerdp_peer* peer)\n{\n\treturn peer->context->rdp->transport->haveMoreBytesToRead;\n}\n\nstatic LicenseCallbackResult freerdp_peer_nolicense(freerdp_peer* peer, wStream* s)\n{\n\trdpRdp* rdp = peer->context->rdp;\n\n\tif (!license_send_valid_client_error_packet(rdp))\n\t{\n\t\tWLog_ERR(TAG, \"freerdp_peer_nolicense: license_send_valid_client_error_packet() failed\");\n\t\treturn LICENSE_CB_ABORT;\n\t}\n\n\treturn LICENSE_CB_COMPLETED;\n}\n\nBOOL freerdp_peer_context_new(freerdp_peer* client)\n{\n\trdpRdp* rdp;\n\trdpContext* context;\n\tBOOL ret = TRUE;\n\n\tif (!client)\n\t\treturn FALSE;\n\n\tif (!(context = (rdpContext*)calloc(1, client->ContextSize)))\n\t\tgoto fail_context;\n\n\tclient->context = context;\n\tcontext->peer = client;\n\tcontext->ServerMode = TRUE;\n\tcontext->settings = client->settings;\n\n\tif (!(context->metrics = metrics_new(context)))\n\t\tgoto fail_metrics;\n\n\tif (!(rdp = rdp_new(context)))\n\t\tgoto fail_rdp;\n\n\tclient->input = rdp->input;\n\tclient->update = rdp->update;\n\tclient->settings = rdp->settings;\n\tclient->autodetect = rdp->autodetect;\n\tcontext->rdp = rdp;\n\tcontext->input = client->input;\n\tcontext->update = client->update;\n\tcontext->settings = client->settings;\n\tcontext->autodetect = client->autodetect;\n\tclient->update->context = context;\n\tclient->input->context = context;\n\tclient->autodetect->context = context;\n\tupdate_register_server_callbacks(client->update);\n\tautodetect_register_server_callbacks(client->autodetect);\n\n\tif (!(context->errorDescription = calloc(1, 500)))\n\t{\n\t\tWLog_ERR(TAG, \"calloc failed!\");\n\t\tgoto fail_error_description;\n\t}\n\n\tif (!transport_attach(rdp->transport, client->sockfd))\n\t\tgoto fail_transport_attach;\n\n\trdp->transport->ReceiveCallback = peer_recv_callback;\n\trdp->transport->ReceiveExtra = client;\n\ttransport_set_blocking_mode(rdp->transport, FALSE);\n\tclient->IsWriteBlocked = freerdp_peer_is_write_blocked;\n\tclient->DrainOutputBuffer = freerdp_peer_drain_output_buffer;\n\tclient->HasMoreToRead = freerdp_peer_has_more_to_read;\n\tclient->LicenseCallback = freerdp_peer_nolicense;\n\tIFCALLRET(client->ContextNew, ret, client, client->context);\n\n\tif (ret)\n\t\treturn TRUE;\n\n\tWLog_ERR(TAG, \"ContextNew callback failed\");\nfail_transport_attach:\n\tfree(context->errorDescription);\nfail_error_description:\n\trdp_free(client->context->rdp);\nfail_rdp:\n\tmetrics_free(context->metrics);\nfail_metrics:\n\tfree(client->context);\nfail_context:\n\tclient->context = NULL;\n\tWLog_ERR(TAG, \"Failed to create new peer context\");\n\treturn FALSE;\n}\n\nvoid freerdp_peer_context_free(freerdp_peer* client)\n{\n\tIFCALL(client->ContextFree, client, client->context);\n\n\tif (client->context)\n\t{\n\t\tfree(client->context->errorDescription);\n\t\tclient->context->errorDescription = NULL;\n\t\trdp_free(client->context->rdp);\n\t\tclient->context->rdp = NULL;\n\t\tmetrics_free(client->context->metrics);\n\t\tclient->context->metrics = NULL;\n\t\tfree(client->context);\n\t\tclient->context = NULL;\n\t}\n}\n\nfreerdp_peer* freerdp_peer_new(int sockfd)\n{\n\tUINT32 option_value;\n\tsocklen_t option_len;\n\tfreerdp_peer* client;\n\tclient = (freerdp_peer*)calloc(1, sizeof(freerdp_peer));\n\n\tif (!client)\n\t\treturn NULL;\n\n\toption_value = TRUE;\n\toption_len = sizeof(option_value);\n\tsetsockopt(sockfd, IPPROTO_TCP, TCP_NODELAY, (void*)&option_value, option_len);\n\n\tif (client)\n\t{\n\t\tclient->sockfd = sockfd;\n\t\tclient->ContextSize = sizeof(rdpContext);\n\t\tclient->Initialize = freerdp_peer_initialize;\n\t\tclient->GetFileDescriptor = freerdp_peer_get_fds;\n\t\tclient->GetEventHandle = freerdp_peer_get_event_handle;\n\t\tclient->GetEventHandles = freerdp_peer_get_event_handles;\n\t\tclient->CheckFileDescriptor = freerdp_peer_check_fds;\n\t\tclient->Close = freerdp_peer_close;\n\t\tclient->Disconnect = freerdp_peer_disconnect;\n\t\tclient->SendChannelData = freerdp_peer_send_channel_data;\n\t\tclient->IsWriteBlocked = freerdp_peer_is_write_blocked;\n\t\tclient->DrainOutputBuffer = freerdp_peer_drain_output_buffer;\n\t\tclient->HasMoreToRead = freerdp_peer_has_more_to_read;\n\t\tclient->VirtualChannelOpen = freerdp_peer_virtual_channel_open;\n\t\tclient->VirtualChannelClose = freerdp_peer_virtual_channel_close;\n\t\tclient->VirtualChannelWrite = freerdp_peer_virtual_channel_write;\n\t\tclient->VirtualChannelRead = NULL; /* must be defined by server application */\n\t\tclient->VirtualChannelGetData = freerdp_peer_virtual_channel_get_data;\n\t\tclient->VirtualChannelSetData = freerdp_peer_virtual_channel_set_data;\n\t}\n\n\treturn client;\n}\n\nvoid freerdp_peer_free(freerdp_peer* client)\n{\n\tif (!client)\n\t\treturn;\n\n\tfree(client);\n}\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * RDP Core\n *\n * Copyright 2011 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2014 DI (FH) Martin Haimberger <martin.haimberger@thincast.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <winpr/crt.h>\n\n#include \"rdp.h\"\n\n#include \"info.h\"\n#include \"redirection.h\"\n\n#include <freerdp/crypto/per.h>\n#include <freerdp/log.h>\n\n#define TAG FREERDP_TAG(\"core.rdp\")\n\nconst char* DATA_PDU_TYPE_STRINGS[80] = {\n\t\"?\",\n\t\"?\",      /* 0x00 - 0x01 */\n\t\"Update\", /* 0x02 */\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\", /* 0x03 - 0x0A */\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",       /* 0x0B - 0x13 */\n\t\"Control\", /* 0x14 */\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",       /* 0x15 - 0x1A */\n\t\"Pointer\", /* 0x1B */\n\t\"Input\",   /* 0x1C */\n\t\"?\",\n\t\"?\",                            /* 0x1D - 0x1E */\n\t\"Synchronize\",                  /* 0x1F */\n\t\"?\",                            /* 0x20 */\n\t\"Refresh Rect\",                 /* 0x21 */\n\t\"Play Sound\",                   /* 0x22 */\n\t\"Suppress Output\",              /* 0x23 */\n\t\"Shutdown Request\",             /* 0x24 */\n\t\"Shutdown Denied\",              /* 0x25 */\n\t\"Save Session Info\",            /* 0x26 */\n\t\"Font List\",                    /* 0x27 */\n\t\"Font Map\",                     /* 0x28 */\n\t\"Set Keyboard Indicators\",      /* 0x29 */\n\t\"?\",                            /* 0x2A */\n\t\"Bitmap Cache Persistent List\", /* 0x2B */\n\t\"Bitmap Cache Error\",           /* 0x2C */\n\t\"Set Keyboard IME Status\",      /* 0x2D */\n\t\"Offscreen Cache Error\",        /* 0x2E */\n\t\"Set Error Info\",               /* 0x2F */\n\t\"Draw Nine Grid Error\",         /* 0x30 */\n\t\"Draw GDI+ Error\",              /* 0x31 */\n\t\"ARC Status\",                   /* 0x32 */\n\t\"?\",\n\t\"?\",\n\t\"?\",              /* 0x33 - 0x35 */\n\t\"Status Info\",    /* 0x36 */\n\t\"Monitor Layout\", /* 0x37 */\n\t\"FrameAcknowledge\",\n\t\"?\",\n\t\"?\", /* 0x38 - 0x40 */\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\",\n\t\"?\" /* 0x41 - 0x46 */\n};\n\nstatic BOOL rdp_read_flow_control_pdu(wStream* s, UINT16* type, UINT16* channel_id);\nstatic void rdp_write_share_control_header(wStream* s, UINT16 length, UINT16 type,\n                                           UINT16 channel_id);\nstatic void rdp_write_share_data_header(wStream* s, UINT16 length, BYTE type, UINT32 share_id);\n\n/**\n * Read RDP Security Header.\\n\n * @msdn{cc240579}\n * @param s stream\n * @param flags security flags\n */\n\nBOOL rdp_read_security_header(wStream* s, UINT16* flags, UINT16* length)\n{\n\t/* Basic Security Header */\n\tif ((Stream_GetRemainingLength(s) < 4) || (length && (*length < 4)))\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, *flags); /* flags */\n\tStream_Seek(s, 2);             /* flagsHi (unused) */\n\n\tif (length)\n\t\t*length -= 4;\n\n\treturn TRUE;\n}\n\n/**\n * Write RDP Security Header.\\n\n * @msdn{cc240579}\n * @param s stream\n * @param flags security flags\n */\n\nvoid rdp_write_security_header(wStream* s, UINT16 flags)\n{\n\t/* Basic Security Header */\n\tStream_Write_UINT16(s, flags); /* flags */\n\tStream_Write_UINT16(s, 0);     /* flagsHi (unused) */\n}\n\nBOOL rdp_read_share_control_header(wStream* s, UINT16* tpktLength, UINT16* remainingLength,\n                                   UINT16* type, UINT16* channel_id)\n{\n\tUINT16 len;\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\treturn FALSE;\n\n\t/* Share Control Header */\n\tStream_Read_UINT16(s, len); /* totalLength */\n\n\t/* If length is 0x8000 then we actually got a flow control PDU that we should ignore\n\t http://msdn.microsoft.com/en-us/library/cc240576.aspx */\n\tif (len == 0x8000)\n\t{\n\t\tif (!rdp_read_flow_control_pdu(s, type, channel_id))\n\t\t\treturn FALSE;\n\t\t*channel_id = 0;\n\t\tif (tpktLength)\n\t\t\t*tpktLength = 8; /* Flow control PDU is 8 bytes */\n\t\tif (remainingLength)\n\t\t\t*remainingLength = 0;\n\t\treturn TRUE;\n\t}\n\n\tif ((len < 4) || ((len - 2) > Stream_GetRemainingLength(s)))\n\t\treturn FALSE;\n\n\tif (tpktLength)\n\t\t*tpktLength = len;\n\n\tStream_Read_UINT16(s, *type); /* pduType */\n\t*type &= 0x0F;                /* type is in the 4 least significant bits */\n\n\tif (len > 5)\n\t{\n\t\tStream_Read_UINT16(s, *channel_id); /* pduSource */\n\t\tif (remainingLength)\n\t\t\t*remainingLength = len - 6;\n\t}\n\telse\n\t{\n\t\t*channel_id = 0; /* Windows XP can send such short DEACTIVATE_ALL PDUs. */\n\t\tif (remainingLength)\n\t\t\t*remainingLength = len - 4;\n\t}\n\n\treturn TRUE;\n}\n\nvoid rdp_write_share_control_header(wStream* s, UINT16 length, UINT16 type, UINT16 channel_id)\n{\n\tlength -= RDP_PACKET_HEADER_MAX_LENGTH;\n\t/* Share Control Header */\n\tStream_Write_UINT16(s, length);      /* totalLength */\n\tStream_Write_UINT16(s, type | 0x10); /* pduType */\n\tStream_Write_UINT16(s, channel_id);  /* pduSource */\n}\n\nBOOL rdp_read_share_data_header(wStream* s, UINT16* length, BYTE* type, UINT32* shareId,\n                                BYTE* compressedType, UINT16* compressedLength)\n{\n\tif (Stream_GetRemainingLength(s) < 12)\n\t\treturn FALSE;\n\n\t/* Share Data Header */\n\tStream_Read_UINT32(s, *shareId);          /* shareId (4 bytes) */\n\tStream_Seek_UINT8(s);                     /* pad1 (1 byte) */\n\tStream_Seek_UINT8(s);                     /* streamId (1 byte) */\n\tStream_Read_UINT16(s, *length);           /* uncompressedLength (2 bytes) */\n\tStream_Read_UINT8(s, *type);              /* pduType2, Data PDU Type (1 byte) */\n\tStream_Read_UINT8(s, *compressedType);    /* compressedType (1 byte) */\n\tStream_Read_UINT16(s, *compressedLength); /* compressedLength (2 bytes) */\n\treturn TRUE;\n}\n\nvoid rdp_write_share_data_header(wStream* s, UINT16 length, BYTE type, UINT32 share_id)\n{\n\tlength -= RDP_PACKET_HEADER_MAX_LENGTH;\n\tlength -= RDP_SHARE_CONTROL_HEADER_LENGTH;\n\tlength -= RDP_SHARE_DATA_HEADER_LENGTH;\n\t/* Share Data Header */\n\tStream_Write_UINT32(s, share_id);  /* shareId (4 bytes) */\n\tStream_Write_UINT8(s, 0);          /* pad1 (1 byte) */\n\tStream_Write_UINT8(s, STREAM_LOW); /* streamId (1 byte) */\n\tStream_Write_UINT16(s, length);    /* uncompressedLength (2 bytes) */\n\tStream_Write_UINT8(s, type);       /* pduType2, Data PDU Type (1 byte) */\n\tStream_Write_UINT8(s, 0);          /* compressedType (1 byte) */\n\tStream_Write_UINT16(s, 0);         /* compressedLength (2 bytes) */\n}\n\nstatic BOOL rdp_security_stream_init(rdpRdp* rdp, wStream* s, BOOL sec_header)\n{\n\tif (!rdp || !s)\n\t\treturn FALSE;\n\n\tif (rdp->do_crypt)\n\t{\n\t\tif (!Stream_SafeSeek(s, 12))\n\t\t\treturn FALSE;\n\n\t\tif (rdp->settings->EncryptionMethods == ENCRYPTION_METHOD_FIPS)\n\t\t{\n\t\t\tif (!Stream_SafeSeek(s, 4))\n\t\t\t\treturn FALSE;\n\t\t}\n\n\t\trdp->sec_flags |= SEC_ENCRYPT;\n\n\t\tif (rdp->do_secure_checksum)\n\t\t\trdp->sec_flags |= SEC_SECURE_CHECKSUM;\n\t}\n\telse if (rdp->sec_flags != 0 || sec_header)\n\t{\n\t\tif (!Stream_SafeSeek(s, 4))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nwStream* rdp_send_stream_init(rdpRdp* rdp)\n{\n\twStream* s = transport_send_stream_init(rdp->transport, 4096);\n\n\tif (!s)\n\t\treturn NULL;\n\n\tif (!Stream_SafeSeek(s, RDP_PACKET_HEADER_MAX_LENGTH))\n\t\tgoto fail;\n\n\tif (!rdp_security_stream_init(rdp, s, FALSE))\n\t\tgoto fail;\n\n\treturn s;\nfail:\n\tStream_Release(s);\n\treturn NULL;\n}\n\nwStream* rdp_send_stream_pdu_init(rdpRdp* rdp)\n{\n\twStream* s = rdp_send_stream_init(rdp);\n\n\tif (!s)\n\t\treturn NULL;\n\n\tif (!Stream_SafeSeek(s, RDP_SHARE_CONTROL_HEADER_LENGTH))\n\t\tgoto fail;\n\n\treturn s;\nfail:\n\tStream_Release(s);\n\treturn NULL;\n}\n\nwStream* rdp_data_pdu_init(rdpRdp* rdp)\n{\n\twStream* s = rdp_send_stream_pdu_init(rdp);\n\n\tif (!s)\n\t\treturn NULL;\n\n\tif (!Stream_SafeSeek(s, RDP_SHARE_DATA_HEADER_LENGTH))\n\t\tgoto fail;\n\n\treturn s;\nfail:\n\tStream_Release(s);\n\treturn NULL;\n}\n\nBOOL rdp_set_error_info(rdpRdp* rdp, UINT32 errorInfo)\n{\n\trdp->errorInfo = errorInfo;\n\n\tif (rdp->errorInfo != ERRINFO_SUCCESS)\n\t{\n\t\trdpContext* context = rdp->context;\n\t\trdp_print_errinfo(rdp->errorInfo);\n\n\t\tif (context)\n\t\t{\n\t\t\tfreerdp_set_last_error_log(context, MAKE_FREERDP_ERROR(ERRINFO, errorInfo));\n\n\t\t\tif (context->pubSub)\n\t\t\t{\n\t\t\t\tErrorInfoEventArgs e;\n\t\t\t\tEventArgsInit(&e, \"freerdp\");\n\t\t\t\te.code = rdp->errorInfo;\n\t\t\t\tPubSub_OnErrorInfo(context->pubSub, context, &e);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tWLog_ERR(TAG, \"%s missing context=%p\", __FUNCTION__, context);\n\t}\n\telse\n\t{\n\t\tfreerdp_set_last_error_log(rdp->context, FREERDP_ERROR_SUCCESS);\n\t}\n\n\treturn TRUE;\n}\n\nwStream* rdp_message_channel_pdu_init(rdpRdp* rdp)\n{\n\twStream* s = transport_send_stream_init(rdp->transport, 4096);\n\n\tif (!s)\n\t\treturn NULL;\n\n\tif (!Stream_SafeSeek(s, RDP_PACKET_HEADER_MAX_LENGTH))\n\t\tgoto fail;\n\n\tif (!rdp_security_stream_init(rdp, s, TRUE))\n\t\tgoto fail;\n\n\treturn s;\nfail:\n\tStream_Release(s);\n\treturn NULL;\n}\n\n/**\n * Read an RDP packet header.\\n\n * @param rdp rdp module\n * @param s stream\n * @param length RDP packet length\n * @param channel_id channel id\n */\n\nBOOL rdp_read_header(rdpRdp* rdp, wStream* s, UINT16* length, UINT16* channelId)\n{\n\tBYTE li;\n\tBYTE byte;\n\tBYTE code;\n\tBYTE choice;\n\tUINT16 initiator;\n\tenum DomainMCSPDU MCSPDU;\n\tenum DomainMCSPDU domainMCSPDU;\n\tMCSPDU = (rdp->settings->ServerMode) ? DomainMCSPDU_SendDataRequest\n\t                                     : DomainMCSPDU_SendDataIndication;\n\n\tif (!tpkt_read_header(s, length))\n\t\treturn FALSE;\n\n\tif (!tpdu_read_header(s, &code, &li, *length))\n\t\treturn FALSE;\n\n\tif (code != X224_TPDU_DATA)\n\t{\n\t\tif (code == X224_TPDU_DISCONNECT_REQUEST)\n\t\t{\n\t\t\tfreerdp_abort_connect(rdp->instance);\n\t\t\treturn TRUE;\n\t\t}\n\n\t\treturn FALSE;\n\t}\n\n\tif (!per_read_choice(s, &choice))\n\t\treturn FALSE;\n\n\tdomainMCSPDU = (enum DomainMCSPDU)(choice >> 2);\n\n\tif (domainMCSPDU != MCSPDU)\n\t{\n\t\tif (domainMCSPDU != DomainMCSPDU_DisconnectProviderUltimatum)\n\t\t\treturn FALSE;\n\t}\n\n\tMCSPDU = domainMCSPDU;\n\n\tif (*length < 8U)\n\t\treturn FALSE;\n\n\tif ((*length - 8U) > Stream_GetRemainingLength(s))\n\t\treturn FALSE;\n\n\tif (MCSPDU == DomainMCSPDU_DisconnectProviderUltimatum)\n\t{\n\t\tint reason = 0;\n\t\tTerminateEventArgs e;\n\t\trdpContext* context;\n\n\t\tif (!mcs_recv_disconnect_provider_ultimatum(rdp->mcs, s, &reason))\n\t\t\treturn FALSE;\n\n\t\tif (!rdp->instance)\n\t\t\treturn FALSE;\n\n\t\tcontext = rdp->instance->context;\n\t\tcontext->disconnectUltimatum = reason;\n\n\t\tif (rdp->errorInfo == ERRINFO_SUCCESS)\n\t\t{\n\t\t\t/**\n\t\t\t * Some servers like Windows Server 2008 R2 do not send the error info pdu\n\t\t\t * when the user logs off like they should. Map DisconnectProviderUltimatum\n\t\t\t * to a ERRINFO_LOGOFF_BY_USER when the errinfo code is ERRINFO_SUCCESS.\n\t\t\t */\n\t\t\tif (reason == Disconnect_Ultimatum_provider_initiated)\n\t\t\t\trdp_set_error_info(rdp, ERRINFO_RPC_INITIATED_DISCONNECT);\n\t\t\telse if (reason == Disconnect_Ultimatum_user_requested)\n\t\t\t\trdp_set_error_info(rdp, ERRINFO_LOGOFF_BY_USER);\n\t\t\telse\n\t\t\t\trdp_set_error_info(rdp, ERRINFO_RPC_INITIATED_DISCONNECT);\n\t\t}\n\n\t\tWLog_DBG(TAG, \"DisconnectProviderUltimatum: reason: %d\", reason);\n\t\tfreerdp_abort_connect(rdp->instance);\n\t\tEventArgsInit(&e, \"freerdp\");\n\t\te.code = 0;\n\t\tPubSub_OnTerminate(context->pubSub, context, &e);\n\t\treturn TRUE;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < 5)\n\t\treturn FALSE;\n\n\tif (!per_read_integer16(s, &initiator, MCS_BASE_CHANNEL_ID)) /* initiator (UserId) */\n\t\treturn FALSE;\n\n\tif (!per_read_integer16(s, channelId, 0)) /* channelId */\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, byte); /* dataPriority + Segmentation (0x70) */\n\n\tif (!per_read_length(s, length)) /* userData (OCTET_STRING) */\n\t\treturn FALSE;\n\n\tif (*length > Stream_GetRemainingLength(s))\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\n/**\n * Write an RDP packet header.\\n\n * @param rdp rdp module\n * @param s stream\n * @param length RDP packet length\n * @param channel_id channel id\n */\n\nvoid rdp_write_header(rdpRdp* rdp, wStream* s, UINT16 length, UINT16 channelId)\n{\n\tint body_length;\n\tenum DomainMCSPDU MCSPDU;\n\tMCSPDU = (rdp->settings->ServerMode) ? DomainMCSPDU_SendDataIndication\n\t                                     : DomainMCSPDU_SendDataRequest;\n\n\tif ((rdp->sec_flags & SEC_ENCRYPT) &&\n\t    (rdp->settings->EncryptionMethods == ENCRYPTION_METHOD_FIPS))\n\t{\n\t\tint pad;\n\t\tbody_length = length - RDP_PACKET_HEADER_MAX_LENGTH - 16;\n\t\tpad = 8 - (body_length % 8);\n\n\t\tif (pad != 8)\n\t\t\tlength += pad;\n\t}\n\n\tmcs_write_domain_mcspdu_header(s, MCSPDU, length, 0);\n\tper_write_integer16(s, rdp->mcs->userId, MCS_BASE_CHANNEL_ID); /* initiator */\n\tper_write_integer16(s, channelId, 0);                          /* channelId */\n\tStream_Write_UINT8(s, 0x70);                                   /* dataPriority + segmentation */\n\t/*\n\t * We always encode length in two bytes, even though we could use\n\t * only one byte if length <= 0x7F. It is just easier that way,\n\t * because we can leave room for fixed-length header, store all\n\t * the data first and then store the header.\n\t */\n\tlength = (length - RDP_PACKET_HEADER_MAX_LENGTH) | 0x8000;\n\tStream_Write_UINT16_BE(s, length); /* userData (OCTET_STRING) */\n}\n\nstatic BOOL rdp_security_stream_out(rdpRdp* rdp, wStream* s, int length, UINT32 sec_flags,\n                                    UINT32* pad)\n{\n\tBYTE* data;\n\tBOOL status;\n\tsec_flags |= rdp->sec_flags;\n\t*pad = 0;\n\n\tif (sec_flags != 0)\n\t{\n\t\trdp_write_security_header(s, sec_flags);\n\n\t\tif (sec_flags & SEC_ENCRYPT)\n\t\t{\n\t\t\tif (rdp->settings->EncryptionMethods == ENCRYPTION_METHOD_FIPS)\n\t\t\t{\n\t\t\t\tdata = Stream_Pointer(s) + 12;\n\t\t\t\tlength = length - (data - Stream_Buffer(s));\n\t\t\t\tStream_Write_UINT16(s, 0x10); /* length */\n\t\t\t\tStream_Write_UINT8(s, 0x1);   /* TSFIPS_VERSION 1*/\n\t\t\t\t/* handle padding */\n\t\t\t\t*pad = 8 - (length % 8);\n\n\t\t\t\tif (*pad == 8)\n\t\t\t\t\t*pad = 0;\n\n\t\t\t\tif (*pad)\n\t\t\t\t\tmemset(data + length, 0, *pad);\n\n\t\t\t\tStream_Write_UINT8(s, *pad);\n\n\t\t\t\tif (!security_hmac_signature(data, length, Stream_Pointer(s), rdp))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tStream_Seek(s, 8);\n\t\t\t\tsecurity_fips_encrypt(data, length + *pad, rdp);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdata = Stream_Pointer(s) + 8;\n\t\t\t\tlength = length - (data - Stream_Buffer(s));\n\n\t\t\t\tif (sec_flags & SEC_SECURE_CHECKSUM)\n\t\t\t\t\tstatus =\n\t\t\t\t\t    security_salted_mac_signature(rdp, data, length, TRUE, Stream_Pointer(s));\n\t\t\t\telse\n\t\t\t\t\tstatus = security_mac_signature(rdp, data, length, Stream_Pointer(s));\n\n\t\t\t\tif (!status)\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tStream_Seek(s, 8);\n\n\t\t\t\tif (!security_encrypt(Stream_Pointer(s), length, rdp))\n\t\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\n\t\trdp->sec_flags = 0;\n\t}\n\n\treturn TRUE;\n}\n\nstatic UINT32 rdp_get_sec_bytes(rdpRdp* rdp, UINT16 sec_flags)\n{\n\tUINT32 sec_bytes;\n\n\tif (rdp->sec_flags & SEC_ENCRYPT)\n\t{\n\t\tsec_bytes = 12;\n\n\t\tif (rdp->settings->EncryptionMethods == ENCRYPTION_METHOD_FIPS)\n\t\t\tsec_bytes += 4;\n\t}\n\telse if (rdp->sec_flags != 0 || sec_flags != 0)\n\t{\n\t\tsec_bytes = 4;\n\t}\n\telse\n\t{\n\t\tsec_bytes = 0;\n\t}\n\n\treturn sec_bytes;\n}\n\n/**\n * Send an RDP packet.\n * @param rdp RDP module\n * @param s stream\n * @param channel_id channel id\n */\n\nBOOL rdp_send(rdpRdp* rdp, wStream* s, UINT16 channel_id)\n{\n\tBOOL rc = FALSE;\n\tUINT32 pad;\n\tUINT16 length;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!rdp)\n\t\tgoto fail;\n\n\tlength = Stream_GetPosition(s);\n\tStream_SetPosition(s, 0);\n\trdp_write_header(rdp, s, length, channel_id);\n\n\tif (!rdp_security_stream_out(rdp, s, length, 0, &pad))\n\t\tgoto fail;\n\n\tlength += pad;\n\tStream_SetPosition(s, length);\n\tStream_SealLength(s);\n\n\tif (transport_write(rdp->transport, s) < 0)\n\t\tgoto fail;\n\n\trc = TRUE;\nfail:\n\tStream_Release(s);\n\treturn rc;\n}\n\nBOOL rdp_send_pdu(rdpRdp* rdp, wStream* s, UINT16 type, UINT16 channel_id)\n{\n\tUINT16 length;\n\tUINT32 sec_bytes;\n\tsize_t sec_hold;\n\tUINT32 pad;\n\n\tif (!rdp || !s)\n\t\treturn FALSE;\n\n\tlength = Stream_GetPosition(s);\n\tStream_SetPosition(s, 0);\n\trdp_write_header(rdp, s, length, MCS_GLOBAL_CHANNEL_ID);\n\tsec_bytes = rdp_get_sec_bytes(rdp, 0);\n\tsec_hold = Stream_GetPosition(s);\n\tStream_Seek(s, sec_bytes);\n\trdp_write_share_control_header(s, length - sec_bytes, type, channel_id);\n\tStream_SetPosition(s, sec_hold);\n\n\tif (!rdp_security_stream_out(rdp, s, length, 0, &pad))\n\t\treturn FALSE;\n\n\tlength += pad;\n\tStream_SetPosition(s, length);\n\tStream_SealLength(s);\n\n\tif (transport_write(rdp->transport, s) < 0)\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\nBOOL rdp_send_data_pdu(rdpRdp* rdp, wStream* s, BYTE type, UINT16 channel_id)\n{\n\tBOOL rc = FALSE;\n\tsize_t length;\n\tUINT32 sec_bytes;\n\tsize_t sec_hold;\n\tUINT32 pad;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!rdp)\n\t\tgoto fail;\n\n\tlength = Stream_GetPosition(s);\n\tStream_SetPosition(s, 0);\n\trdp_write_header(rdp, s, length, MCS_GLOBAL_CHANNEL_ID);\n\tsec_bytes = rdp_get_sec_bytes(rdp, 0);\n\tsec_hold = Stream_GetPosition(s);\n\tStream_Seek(s, sec_bytes);\n\trdp_write_share_control_header(s, length - sec_bytes, PDU_TYPE_DATA, channel_id);\n\trdp_write_share_data_header(s, length - sec_bytes, type, rdp->settings->ShareId);\n\tStream_SetPosition(s, sec_hold);\n\n\tif (!rdp_security_stream_out(rdp, s, length, 0, &pad))\n\t\tgoto fail;\n\n\tlength += pad;\n\tStream_SetPosition(s, length);\n\tStream_SealLength(s);\n\tWLog_DBG(TAG, \"%s: sending data (type=0x%x size=%\" PRIuz \" channelId=%\" PRIu16 \")\",\n\t         __FUNCTION__, type, Stream_Length(s), channel_id);\n\n\trdp->outPackets++;\n\tif (transport_write(rdp->transport, s) < 0)\n\t\tgoto fail;\n\n\trc = TRUE;\nfail:\n\tStream_Release(s);\n\treturn rc;\n}\n\nBOOL rdp_send_message_channel_pdu(rdpRdp* rdp, wStream* s, UINT16 sec_flags)\n{\n\tBOOL rc = FALSE;\n\tUINT16 length;\n\tUINT32 pad;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!rdp)\n\t\tgoto fail;\n\n\tlength = Stream_GetPosition(s);\n\tStream_SetPosition(s, 0);\n\trdp_write_header(rdp, s, length, rdp->mcs->messageChannelId);\n\n\tif (!rdp_security_stream_out(rdp, s, length, sec_flags, &pad))\n\t\tgoto fail;\n\n\tlength += pad;\n\tStream_SetPosition(s, length);\n\tStream_SealLength(s);\n\n\tif (transport_write(rdp->transport, s) < 0)\n\t\tgoto fail;\n\n\trc = TRUE;\nfail:\n\tStream_Release(s);\n\treturn rc;\n}\n\nstatic BOOL rdp_recv_server_shutdown_denied_pdu(rdpRdp* rdp, wStream* s)\n{\n\treturn TRUE;\n}\n\nstatic BOOL rdp_recv_server_set_keyboard_indicators_pdu(rdpRdp* rdp, wStream* s)\n{\n\tUINT16 unitId;\n\tUINT16 ledFlags;\n\trdpContext* context = rdp->instance->context;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, unitId);   /* unitId (2 bytes) */\n\tStream_Read_UINT16(s, ledFlags); /* ledFlags (2 bytes) */\n\tIFCALL(context->update->SetKeyboardIndicators, context, ledFlags);\n\treturn TRUE;\n}\n\nstatic BOOL rdp_recv_server_set_keyboard_ime_status_pdu(rdpRdp* rdp, wStream* s)\n{\n\tUINT16 unitId;\n\tUINT32 imeState;\n\tUINT32 imeConvMode;\n\n\tif (!rdp || !rdp->input)\n\t\treturn FALSE;\n\n\tif (Stream_GetRemainingLength(s) < 10)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, unitId);      /* unitId (2 bytes) */\n\tStream_Read_UINT32(s, imeState);    /* imeState (4 bytes) */\n\tStream_Read_UINT32(s, imeConvMode); /* imeConvMode (4 bytes) */\n\tIFCALL(rdp->update->SetKeyboardImeStatus, rdp->context, unitId, imeState, imeConvMode);\n\treturn TRUE;\n}\n\nstatic BOOL rdp_recv_set_error_info_data_pdu(rdpRdp* rdp, wStream* s)\n{\n\tUINT32 errorInfo;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, errorInfo); /* errorInfo (4 bytes) */\n\treturn rdp_set_error_info(rdp, errorInfo);\n}\n\nstatic BOOL rdp_recv_server_auto_reconnect_status_pdu(rdpRdp* rdp, wStream* s)\n{\n\tUINT32 arcStatus;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, arcStatus); /* arcStatus (4 bytes) */\n\tWLog_WARN(TAG, \"AutoReconnectStatus: 0x%08\" PRIX32 \"\", arcStatus);\n\treturn TRUE;\n}\n\nstatic BOOL rdp_recv_server_status_info_pdu(rdpRdp* rdp, wStream* s)\n{\n\tUINT32 statusCode;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, statusCode); /* statusCode (4 bytes) */\n\n\tif (rdp->update->ServerStatusInfo)\n\t\treturn rdp->update->ServerStatusInfo(rdp->context, statusCode);\n\n\treturn TRUE;\n}\n\nstatic BOOL rdp_recv_monitor_layout_pdu(rdpRdp* rdp, wStream* s)\n{\n\tUINT32 index;\n\tUINT32 monitorCount;\n\tMONITOR_DEF* monitor;\n\tMONITOR_DEF* monitorDefArray;\n\tBOOL ret = TRUE;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, monitorCount); /* monitorCount (4 bytes) */\n\n\tif ((Stream_GetRemainingLength(s) / 20) < monitorCount)\n\t\treturn FALSE;\n\n\tmonitorDefArray = (MONITOR_DEF*)calloc(monitorCount, sizeof(MONITOR_DEF));\n\n\tif (!monitorDefArray)\n\t\treturn FALSE;\n\n\tfor (monitor = monitorDefArray, index = 0; index < monitorCount; index++, monitor++)\n\t{\n\t\tStream_Read_UINT32(s, monitor->left);   /* left (4 bytes) */\n\t\tStream_Read_UINT32(s, monitor->top);    /* top (4 bytes) */\n\t\tStream_Read_UINT32(s, monitor->right);  /* right (4 bytes) */\n\t\tStream_Read_UINT32(s, monitor->bottom); /* bottom (4 bytes) */\n\t\tStream_Read_UINT32(s, monitor->flags);  /* flags (4 bytes) */\n\t}\n\n\tIFCALLRET(rdp->update->RemoteMonitors, ret, rdp->context, monitorCount, monitorDefArray);\n\tfree(monitorDefArray);\n\treturn ret;\n}\n\nint rdp_recv_data_pdu(rdpRdp* rdp, wStream* s)\n{\n\tBYTE type;\n\twStream* cs;\n\tUINT16 length;\n\tUINT32 shareId;\n\tBYTE compressedType;\n\tUINT16 compressedLength;\n\n\tif (!rdp_read_share_data_header(s, &length, &type, &shareId, &compressedType,\n\t                                &compressedLength))\n\t{\n\t\tWLog_ERR(TAG, \"rdp_read_share_data_header() failed\");\n\t\treturn -1;\n\t}\n\n\tcs = s;\n\n\tif (compressedType & PACKET_COMPRESSED)\n\t{\n\t\tUINT32 DstSize = 0;\n\t\tBYTE* pDstData = NULL;\n\t\tUINT16 SrcSize = compressedLength - 18;\n\n\t\tif ((compressedLength < 18) || (Stream_GetRemainingLength(s) < SrcSize))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"bulk_decompress: not enough bytes for compressedLength %\" PRIu16 \"\",\n\t\t\t         compressedLength);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (bulk_decompress(rdp->bulk, Stream_Pointer(s), SrcSize, &pDstData, &DstSize,\n\t\t                    compressedType))\n\t\t{\n\t\t\tif (!(cs = StreamPool_Take(rdp->transport->ReceivePool, DstSize)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Couldn't take stream from pool\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tStream_SetPosition(cs, 0);\n\t\t\tStream_Write(cs, pDstData, DstSize);\n\t\t\tStream_SealLength(cs);\n\t\t\tStream_SetPosition(cs, 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tWLog_ERR(TAG, \"bulk_decompress() failed\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tStream_Seek(s, SrcSize);\n\t}\n\n\tWLog_DBG(TAG, \"recv %s Data PDU (0x%02\" PRIX8 \"), length: %\" PRIu16 \"\",\n\t         type < ARRAYSIZE(DATA_PDU_TYPE_STRINGS) ? DATA_PDU_TYPE_STRINGS[type] : \"???\", type,\n\t         length);\n\n\tswitch (type)\n\t{\n\t\tcase DATA_PDU_TYPE_UPDATE:\n\t\t\tif (!update_recv(rdp->update, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"DATA_PDU_TYPE_UPDATE - update_recv() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_CONTROL:\n\t\t\tif (!rdp_recv_server_control_pdu(rdp, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"DATA_PDU_TYPE_CONTROL - rdp_recv_server_control_pdu() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_POINTER:\n\t\t\tif (!update_recv_pointer(rdp->update, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"DATA_PDU_TYPE_POINTER - update_recv_pointer() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_SYNCHRONIZE:\n\t\t\tif (!rdp_recv_synchronize_pdu(rdp, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"DATA_PDU_TYPE_SYNCHRONIZE - rdp_recv_synchronize_pdu() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_PLAY_SOUND:\n\t\t\tif (!update_recv_play_sound(rdp->update, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"DATA_PDU_TYPE_PLAY_SOUND - update_recv_play_sound() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_SHUTDOWN_DENIED:\n\t\t\tif (!rdp_recv_server_shutdown_denied_pdu(rdp, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(\n\t\t\t\t    TAG,\n\t\t\t\t    \"DATA_PDU_TYPE_SHUTDOWN_DENIED - rdp_recv_server_shutdown_denied_pdu() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_SAVE_SESSION_INFO:\n\t\t\tif (!rdp_recv_save_session_info(rdp, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG,\n\t\t\t\t         \"DATA_PDU_TYPE_SAVE_SESSION_INFO - rdp_recv_save_session_info() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_FONT_MAP:\n\t\t\tif (!rdp_recv_font_map_pdu(rdp, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"DATA_PDU_TYPE_FONT_MAP - rdp_recv_font_map_pdu() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_SET_KEYBOARD_INDICATORS:\n\t\t\tif (!rdp_recv_server_set_keyboard_indicators_pdu(rdp, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"DATA_PDU_TYPE_SET_KEYBOARD_INDICATORS - \"\n\t\t\t\t              \"rdp_recv_server_set_keyboard_indicators_pdu() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_SET_KEYBOARD_IME_STATUS:\n\t\t\tif (!rdp_recv_server_set_keyboard_ime_status_pdu(rdp, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"DATA_PDU_TYPE_SET_KEYBOARD_IME_STATUS - \"\n\t\t\t\t              \"rdp_recv_server_set_keyboard_ime_status_pdu() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_SET_ERROR_INFO:\n\t\t\tif (!rdp_recv_set_error_info_data_pdu(rdp, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(\n\t\t\t\t    TAG,\n\t\t\t\t    \"DATA_PDU_TYPE_SET_ERROR_INFO - rdp_recv_set_error_info_data_pdu() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_ARC_STATUS:\n\t\t\tif (!rdp_recv_server_auto_reconnect_status_pdu(rdp, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"DATA_PDU_TYPE_ARC_STATUS - \"\n\t\t\t\t              \"rdp_recv_server_auto_reconnect_status_pdu() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_STATUS_INFO:\n\t\t\tif (!rdp_recv_server_status_info_pdu(rdp, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG,\n\t\t\t\t         \"DATA_PDU_TYPE_STATUS_INFO - rdp_recv_server_status_info_pdu() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_MONITOR_LAYOUT:\n\t\t\tif (!rdp_recv_monitor_layout_pdu(rdp, cs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG,\n\t\t\t\t         \"DATA_PDU_TYPE_MONITOR_LAYOUT - rdp_recv_monitor_layout_pdu() failed\");\n\t\t\t\tgoto out_fail;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\tif (cs != s)\n\t\tStream_Release(cs);\n\n\treturn 0;\nout_fail:\n\n\tif (cs != s)\n\t\tStream_Release(cs);\n\n\treturn -1;\n}\n\nint rdp_recv_message_channel_pdu(rdpRdp* rdp, wStream* s, UINT16 securityFlags)\n{\n\tif (securityFlags & SEC_AUTODETECT_REQ)\n\t{\n\t\t/* Server Auto-Detect Request PDU */\n\t\treturn rdp_recv_autodetect_request_packet(rdp, s);\n\t}\n\n\tif (securityFlags & SEC_AUTODETECT_RSP)\n\t{\n\t\t/* Client Auto-Detect Response PDU */\n\t\treturn rdp_recv_autodetect_response_packet(rdp, s);\n\t}\n\n\tif (securityFlags & SEC_HEARTBEAT)\n\t{\n\t\t/* Heartbeat PDU */\n\t\treturn rdp_recv_heartbeat_packet(rdp, s);\n\t}\n\n\tif (securityFlags & SEC_TRANSPORT_REQ)\n\t{\n\t\t/* Initiate Multitransport Request PDU */\n\t\treturn rdp_recv_multitransport_packet(rdp, s);\n\t}\n\n\treturn -1;\n}\n\nint rdp_recv_out_of_sequence_pdu(rdpRdp* rdp, wStream* s)\n{\n\tUINT16 type;\n\tUINT16 length;\n\tUINT16 channelId;\n\n\tif (!rdp_read_share_control_header(s, &length, NULL, &type, &channelId))\n\t\treturn -1;\n\n\tif (type == PDU_TYPE_DATA)\n\t{\n\t\treturn rdp_recv_data_pdu(rdp, s);\n\t}\n\telse if (type == PDU_TYPE_SERVER_REDIRECTION)\n\t{\n\t\treturn rdp_recv_enhanced_security_redirection_packet(rdp, s);\n\t}\n\telse if (type == PDU_TYPE_FLOW_RESPONSE || type == PDU_TYPE_FLOW_STOP ||\n\t         type == PDU_TYPE_FLOW_TEST)\n\t{\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\treturn -1;\n\t}\n}\n\nBOOL rdp_read_flow_control_pdu(wStream* s, UINT16* type, UINT16* channel_id)\n{\n\t/*\n\t * Read flow control PDU - documented in FlowPDU section in T.128\n\t * http://www.itu.int/rec/T-REC-T.128-199802-S/en\n\t * The specification for the PDU has pad8bits listed BEFORE pduTypeFlow.\n\t * However, so far pad8bits has always been observed to arrive AFTER pduTypeFlow.\n\t * Switched the order of these two fields to match this observation.\n\t */\n\tUINT8 pduType;\n\tif (!type)\n\t\treturn FALSE;\n\tif (Stream_GetRemainingLength(s) < 6)\n\t\treturn FALSE;\n\tStream_Read_UINT8(s, pduType); /* pduTypeFlow */\n\t*type = pduType;\n\tStream_Seek_UINT8(s);               /* pad8bits */\n\tStream_Seek_UINT8(s);               /* flowIdentifier */\n\tStream_Seek_UINT8(s);               /* flowNumber */\n\tStream_Read_UINT16(s, *channel_id); /* pduSource */\n\treturn TRUE;\n}\n\n/**\n * Decrypt an RDP packet.\\n\n * @param rdp RDP module\n * @param s stream\n * @param length int\n */\n\nBOOL rdp_decrypt(rdpRdp* rdp, wStream* s, UINT16* pLength, UINT16 securityFlags)\n{\n\tBYTE cmac[8];\n\tBYTE wmac[8];\n\tBOOL status;\n\tINT32 length;\n\n\tif (!rdp || !s || !pLength)\n\t\treturn FALSE;\n\n\tlength = *pLength;\n\tif (rdp->settings->EncryptionMethods == ENCRYPTION_METHOD_FIPS)\n\t{\n\t\tUINT16 len;\n\t\tBYTE version, pad;\n\t\tBYTE* sig;\n\t\tINT64 padLength;\n\n\t\tif (Stream_GetRemainingLength(s) < 12)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, len);    /* 0x10 */\n\t\tStream_Read_UINT8(s, version); /* 0x1 */\n\t\tStream_Read_UINT8(s, pad);\n\t\tsig = Stream_Pointer(s);\n\t\tStream_Seek(s, 8); /* signature */\n\t\tlength -= 12;\n\t\tpadLength = length - pad;\n\n\t\tif ((length <= 0) || (padLength <= 0))\n\t\t\treturn FALSE;\n\n\t\tif (!security_fips_decrypt(Stream_Pointer(s), length, rdp))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"FATAL: cannot decrypt\");\n\t\t\treturn FALSE; /* TODO */\n\t\t}\n\n\t\tif (!security_fips_check_signature(Stream_Pointer(s), length - pad, sig, rdp))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"FATAL: invalid packet signature\");\n\t\t\treturn FALSE; /* TODO */\n\t\t}\n\n\t\tStream_SetLength(s, Stream_Length(s) - pad);\n\t\t*pLength = padLength;\n\t\treturn TRUE;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < sizeof(wmac))\n\t\treturn FALSE;\n\n\tStream_Read(s, wmac, sizeof(wmac));\n\tlength -= sizeof(wmac);\n\n\tif (length <= 0)\n\t\treturn FALSE;\n\n\tif (!security_decrypt(Stream_Pointer(s), length, rdp))\n\t\treturn FALSE;\n\n\tif (securityFlags & SEC_SECURE_CHECKSUM)\n\t\tstatus = security_salted_mac_signature(rdp, Stream_Pointer(s), length, FALSE, cmac);\n\telse\n\t\tstatus = security_mac_signature(rdp, Stream_Pointer(s), length, cmac);\n\n\tif (!status)\n\t\treturn FALSE;\n\n\tif (memcmp(wmac, cmac, sizeof(wmac)) != 0)\n\t{\n\t\tWLog_ERR(TAG, \"WARNING: invalid packet signature\");\n\t\t/*\n\t\t * Because Standard RDP Security is totally broken,\n\t\t * and cannot protect against MITM, don't treat signature\n\t\t * verification failure as critical. This at least enables\n\t\t * us to work with broken RDP clients and servers that\n\t\t * generate invalid signatures.\n\t\t */\n\t\t// return FALSE;\n\t}\n\n\t*pLength = length;\n\treturn TRUE;\n}\n\nstatic const char* pdu_type_to_str(UINT16 pduType)\n{\n\tstatic char buffer[1024] = { 0 };\n\tswitch (pduType)\n\t{\n\t\tcase PDU_TYPE_DEMAND_ACTIVE:\n\t\t\treturn \"PDU_TYPE_DEMAND_ACTIVE\";\n\t\tcase PDU_TYPE_CONFIRM_ACTIVE:\n\t\t\treturn \"PDU_TYPE_CONFIRM_ACTIVE\";\n\t\tcase PDU_TYPE_DEACTIVATE_ALL:\n\t\t\treturn \"PDU_TYPE_DEACTIVATE_ALL\";\n\t\tcase PDU_TYPE_DATA:\n\t\t\treturn \"PDU_TYPE_DATA\";\n\t\tcase PDU_TYPE_SERVER_REDIRECTION:\n\t\t\treturn \"PDU_TYPE_SERVER_REDIRECTION\";\n\t\tcase PDU_TYPE_FLOW_TEST:\n\t\t\treturn \"PDU_TYPE_FLOW_TEST\";\n\t\tcase PDU_TYPE_FLOW_RESPONSE:\n\t\t\treturn \"PDU_TYPE_FLOW_RESPONSE\";\n\t\tcase PDU_TYPE_FLOW_STOP:\n\t\t\treturn \"PDU_TYPE_FLOW_STOP\";\n\t\tdefault:\n\t\t\t_snprintf(buffer, sizeof(buffer), \"UNKNOWN %04\" PRIx16, pduType);\n\t\t\treturn buffer;\n\t}\n}\n\n/**\n * Process an RDP packet.\\n\n * @param rdp RDP module\n * @param s stream\n */\n\nstatic int rdp_recv_tpkt_pdu(rdpRdp* rdp, wStream* s)\n{\n\tint rc = 0;\n\tUINT16 length;\n\tUINT16 pduType;\n\tUINT16 pduSource;\n\tUINT16 channelId = 0;\n\tUINT16 securityFlags = 0;\n\n\tif (!rdp_read_header(rdp, s, &length, &channelId))\n\t{\n\t\tWLog_ERR(TAG, \"Incorrect RDP header.\");\n\t\treturn -1;\n\t}\n\n\tif (freerdp_shall_disconnect(rdp->instance))\n\t\treturn 0;\n\n\tif (rdp->autodetect->bandwidthMeasureStarted)\n\t{\n\t\trdp->autodetect->bandwidthMeasureByteCount += length;\n\t}\n\n\tif (rdp->settings->UseRdpSecurityLayer)\n\t{\n\t\tif (!rdp_read_security_header(s, &securityFlags, &length))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"rdp_recv_tpkt_pdu: rdp_read_security_header() fail\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (securityFlags & (SEC_ENCRYPT | SEC_REDIRECTION_PKT))\n\t\t{\n\t\t\tif (!rdp_decrypt(rdp, s, &length, securityFlags))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdp_decrypt failed\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tif (securityFlags & SEC_REDIRECTION_PKT)\n\t\t{\n\t\t\t/*\n\t\t\t * [MS-RDPBCGR] 2.2.13.2.1\n\t\t\t *  - no share control header, nor the 2 byte pad\n\t\t\t */\n\t\t\tStream_Rewind(s, 2);\n\t\t\trdp->inPackets++;\n\n\t\t\trc = rdp_recv_enhanced_security_redirection_packet(rdp, s);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (channelId == MCS_GLOBAL_CHANNEL_ID)\n\t{\n\t\twhile (Stream_GetRemainingLength(s) > 3)\n\t\t{\n\t\t\twStream sub;\n\t\t\tsize_t diff;\n\t\t\tUINT16 remain;\n\n\t\t\tif (!rdp_read_share_control_header(s, NULL, &remain, &pduType, &pduSource))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdp_recv_tpkt_pdu: rdp_read_share_control_header() fail\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tStream_StaticInit(&sub, Stream_Pointer(s), remain);\n\t\t\tif (!Stream_SafeSeek(s, remain))\n\t\t\t\treturn -1;\n\n\t\t\trdp->settings->PduSource = pduSource;\n\t\t\trdp->inPackets++;\n\n\t\t\tswitch (pduType)\n\t\t\t{\n\t\t\t\tcase PDU_TYPE_DATA:\n\t\t\t\t\trc = rdp_recv_data_pdu(rdp, &sub);\n\t\t\t\t\tif (rc < 0)\n\t\t\t\t\t\treturn rc;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDU_TYPE_DEACTIVATE_ALL:\n\t\t\t\t\tif (!rdp_recv_deactivate_all(rdp, &sub))\n\t\t\t\t\t{\n\t\t\t\t\t\tWLog_ERR(TAG, \"rdp_recv_tpkt_pdu: rdp_recv_deactivate_all() fail\");\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDU_TYPE_SERVER_REDIRECTION:\n\t\t\t\t\treturn rdp_recv_enhanced_security_redirection_packet(rdp, &sub);\n\n\t\t\t\tcase PDU_TYPE_FLOW_RESPONSE:\n\t\t\t\tcase PDU_TYPE_FLOW_STOP:\n\t\t\t\tcase PDU_TYPE_FLOW_TEST:\n\t\t\t\t\tWLog_DBG(TAG, \"flow message 0x%04\" PRIX16 \"\", pduType);\n\t\t\t\t\t/* http://msdn.microsoft.com/en-us/library/cc240576.aspx */\n\t\t\t\t\tif (!Stream_SafeSeek(&sub, remain))\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tWLog_ERR(TAG, \"incorrect PDU type: 0x%04\" PRIX16 \"\", pduType);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdiff = Stream_GetRemainingLength(&sub);\n\t\t\tif (diff > 0)\n\t\t\t{\n\t\t\t\tWLog_WARN(TAG,\n\t\t\t\t          \"pduType %s not properly parsed, %\" PRIdz\n\t\t\t\t          \" bytes remaining unhandled. Skipping.\",\n\t\t\t\t          pdu_type_to_str(pduType), diff);\n\t\t\t}\n\t\t}\n\t}\n\telse if (rdp->mcs->messageChannelId && (channelId == rdp->mcs->messageChannelId))\n\t{\n\t\tif (!rdp->settings->UseRdpSecurityLayer)\n\t\t\tif (!rdp_read_security_header(s, &securityFlags, NULL))\n\t\t\t\treturn -1;\n\t\trdp->inPackets++;\n\t\trc = rdp_recv_message_channel_pdu(rdp, s, securityFlags);\n\t}\n\telse\n\t{\n\t\trdp->inPackets++;\n\n\t\tif (!freerdp_channel_process(rdp->instance, s, channelId, length))\n\t\t\treturn -1;\n\t}\n\nout:\n\tif (!tpkt_ensure_stream_consumed(s, length))\n\t\treturn -1;\n\treturn rc;\n}\n\nstatic int rdp_recv_fastpath_pdu(rdpRdp* rdp, wStream* s)\n{\n\tUINT16 length;\n\trdpFastPath* fastpath;\n\tfastpath = rdp->fastpath;\n\n\tif (!fastpath_read_header_rdp(fastpath, s, &length))\n\t{\n\t\tWLog_ERR(TAG, \"rdp_recv_fastpath_pdu: fastpath_read_header_rdp() fail\");\n\t\treturn -1;\n\t}\n\n\tif ((length == 0) || (length > Stream_GetRemainingLength(s)))\n\t{\n\t\tWLog_ERR(TAG, \"incorrect FastPath PDU header length %\" PRIu16 \"\", length);\n\t\treturn -1;\n\t}\n\n\tif (rdp->autodetect->bandwidthMeasureStarted)\n\t{\n\t\trdp->autodetect->bandwidthMeasureByteCount += length;\n\t}\n\n\tif (fastpath->encryptionFlags & FASTPATH_OUTPUT_ENCRYPTED)\n\t{\n\t\tUINT16 flags =\n\t\t    (fastpath->encryptionFlags & FASTPATH_OUTPUT_SECURE_CHECKSUM) ? SEC_SECURE_CHECKSUM : 0;\n\n\t\tif (!rdp_decrypt(rdp, s, &length, flags))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"rdp_recv_fastpath_pdu: rdp_decrypt() fail\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn fastpath_recv_updates(rdp->fastpath, s);\n}\n\nstatic int rdp_recv_pdu(rdpRdp* rdp, wStream* s)\n{\n\tif (tpkt_verify_header(s))\n\t\treturn rdp_recv_tpkt_pdu(rdp, s);\n\telse\n\t\treturn rdp_recv_fastpath_pdu(rdp, s);\n}\n\nint rdp_recv_callback(rdpTransport* transport, wStream* s, void* extra)\n{\n\tint status = 0;\n\trdpRdp* rdp = (rdpRdp*)extra;\n\n\t/*\n\t * At any point in the connection sequence between when all\n\t * MCS channels have been joined and when the RDP connection\n\t * enters the active state, an auto-detect PDU can be received\n\t * on the MCS message channel.\n\t */\n\tif ((rdp->state > CONNECTION_STATE_MCS_CHANNEL_JOIN) && (rdp->state < CONNECTION_STATE_ACTIVE))\n\t{\n\t\tif (rdp_client_connect_auto_detect(rdp, s))\n\t\t\treturn 0;\n\t}\n\n\tswitch (rdp->state)\n\t{\n\t\tcase CONNECTION_STATE_NLA:\n\t\t\tif (nla_get_state(rdp->nla) < NLA_STATE_AUTH_INFO)\n\t\t\t{\n\t\t\t\tif (nla_recv_pdu(rdp->nla, s) < 1)\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG, \"%s: %s - nla_recv_pdu() fail\", __FUNCTION__,\n\t\t\t\t\t         rdp_server_connection_state_string(rdp->state));\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (nla_get_state(rdp->nla) == NLA_STATE_POST_NEGO)\n\t\t\t{\n\t\t\t\tnego_recv(rdp->transport, s, (void*)rdp->nego);\n\n\t\t\t\tif (nego_get_state(rdp->nego) != NEGO_STATE_FINAL)\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG, \"%s: %s - nego_recv() fail\", __FUNCTION__,\n\t\t\t\t\t         rdp_server_connection_state_string(rdp->state));\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tif (!nla_set_state(rdp->nla, NLA_STATE_FINAL))\n\t\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (nla_get_state(rdp->nla) == NLA_STATE_AUTH_INFO)\n\t\t\t{\n\t\t\t\ttransport_set_nla_mode(rdp->transport, FALSE);\n\n\t\t\t\tif (rdp->settings->VmConnectMode)\n\t\t\t\t{\n\t\t\t\t\tif (!nego_set_state(rdp->nego, NEGO_STATE_NLA))\n\t\t\t\t\t\treturn -1;\n\n\t\t\t\t\tif (!nego_set_requested_protocols(rdp->nego, PROTOCOL_HYBRID | PROTOCOL_SSL))\n\t\t\t\t\t\treturn -1;\n\n\t\t\t\t\tnego_send_negotiation_request(rdp->nego);\n\n\t\t\t\t\tif (!nla_set_state(rdp->nla, NLA_STATE_POST_NEGO))\n\t\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!nla_set_state(rdp->nla, NLA_STATE_FINAL))\n\t\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (nla_get_state(rdp->nla) == NLA_STATE_FINAL)\n\t\t\t{\n\t\t\t\tnla_free(rdp->nla);\n\t\t\t\trdp->nla = NULL;\n\n\t\t\t\tif (!mcs_client_begin(rdp->mcs))\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG, \"%s: %s - mcs_client_begin() fail\", __FUNCTION__,\n\t\t\t\t\t         rdp_server_connection_state_string(rdp->state));\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_CONNECT:\n\t\t\tif (!mcs_recv_connect_response(rdp->mcs, s))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"mcs_recv_connect_response failure\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (!mcs_send_erect_domain_request(rdp->mcs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"mcs_send_erect_domain_request failure\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (!mcs_send_attach_user_request(rdp->mcs))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"mcs_send_attach_user_request failure\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\trdp_client_transition_to_state(rdp, CONNECTION_STATE_MCS_ATTACH_USER);\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_ATTACH_USER:\n\t\t\tif (!mcs_recv_attach_user_confirm(rdp->mcs, s))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"mcs_recv_attach_user_confirm failure\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (!mcs_send_channel_join_request(rdp->mcs, rdp->mcs->userId))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"mcs_send_channel_join_request failure\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\trdp_client_transition_to_state(rdp, CONNECTION_STATE_MCS_CHANNEL_JOIN);\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_CHANNEL_JOIN:\n\t\t\tif (!rdp_client_connect_mcs_channel_join_confirm(rdp, s))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG,\n\t\t\t\t         \"%s: %s - \"\n\t\t\t\t         \"rdp_client_connect_mcs_channel_join_confirm() fail\",\n\t\t\t\t         __FUNCTION__, rdp_server_connection_state_string(rdp->state));\n\t\t\t\tstatus = -1;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_LICENSING:\n\t\t\tstatus = rdp_client_connect_license(rdp, s);\n\n\t\t\tif (status < 0)\n\t\t\t\tWLog_DBG(TAG, \"%s: %s - rdp_client_connect_license() - %i\", __FUNCTION__,\n\t\t\t\t         rdp_server_connection_state_string(rdp->state), status);\n\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_CAPABILITIES_EXCHANGE:\n\t\t\tstatus = rdp_client_connect_demand_active(rdp, s);\n\n\t\t\tif (status < 0)\n\t\t\t\tWLog_DBG(TAG,\n\t\t\t\t         \"%s: %s - \"\n\t\t\t\t         \"rdp_client_connect_demand_active() - %i\",\n\t\t\t\t         __FUNCTION__, rdp_server_connection_state_string(rdp->state), status);\n\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_FINALIZATION:\n\t\t\tstatus = rdp_recv_pdu(rdp, s);\n\n\t\t\tif ((status >= 0) && (rdp->finalize_sc_pdus == FINALIZE_SC_COMPLETE))\n\t\t\t{\n\t\t\t\tActivatedEventArgs activatedEvent;\n\t\t\t\trdpContext* context = rdp->context;\n\t\t\t\trdp_client_transition_to_state(rdp, CONNECTION_STATE_ACTIVE);\n\t\t\t\tEventArgsInit(&activatedEvent, \"libfreerdp\");\n\t\t\t\tactivatedEvent.firstActivation = !rdp->deactivation_reactivation;\n\t\t\t\tPubSub_OnActivated(context->pubSub, context, &activatedEvent);\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\tif (status < 0)\n\t\t\t\tWLog_DBG(TAG, \"%s: %s - rdp_recv_pdu() - %i\", __FUNCTION__,\n\t\t\t\t         rdp_server_connection_state_string(rdp->state), status);\n\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_ACTIVE:\n\t\t\tstatus = rdp_recv_pdu(rdp, s);\n\n\t\t\tif (status < 0)\n\t\t\t\tWLog_DBG(TAG, \"%s: %s - rdp_recv_pdu() - %i\", __FUNCTION__,\n\t\t\t\t         rdp_server_connection_state_string(rdp->state), status);\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_ERR(TAG, \"%s: %s state %d\", __FUNCTION__,\n\t\t\t         rdp_server_connection_state_string(rdp->state), rdp->state);\n\t\t\tstatus = -1;\n\t\t\tbreak;\n\t}\n\n\treturn status;\n}\n\nBOOL rdp_send_channel_data(rdpRdp* rdp, UINT16 channelId, const BYTE* data, size_t size)\n{\n\treturn freerdp_channel_send(rdp, channelId, data, size);\n}\n\nBOOL rdp_send_error_info(rdpRdp* rdp)\n{\n\twStream* s;\n\tBOOL status;\n\n\tif (rdp->errorInfo == ERRINFO_SUCCESS)\n\t\treturn TRUE;\n\n\ts = rdp_data_pdu_init(rdp);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_Write_UINT32(s, rdp->errorInfo); /* error id (4 bytes) */\n\tstatus = rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_SET_ERROR_INFO, 0);\n\treturn status;\n}\n\nint rdp_check_fds(rdpRdp* rdp)\n{\n\tint status;\n\trdpTransport* transport = rdp->transport;\n\n\tif (transport->tsg)\n\t{\n\t\trdpTsg* tsg = transport->tsg;\n\n\t\tif (!tsg_check_event_handles(tsg))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"rdp_check_fds: tsg_check_event_handles()\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (tsg_get_state(tsg) != TSG_STATE_PIPE_CREATED)\n\t\t\treturn 1;\n\t}\n\n\tstatus = transport_check_fds(transport);\n\n\tif (status == 1)\n\t{\n\t\tif (!rdp_client_redirect(rdp)) /* session redirection */\n\t\t\treturn -1;\n\t}\n\n\tif (status < 0)\n\t\tWLog_DBG(TAG, \"transport_check_fds() - %i\", status);\n\n\treturn status;\n}\n\nBOOL freerdp_get_stats(rdpRdp* rdp, UINT64* inBytes, UINT64* outBytes, UINT64* inPackets,\n                       UINT64* outPackets)\n{\n\tif (!rdp)\n\t\treturn FALSE;\n\n\tif (inBytes)\n\t\t*inBytes = rdp->inBytes;\n\tif (outBytes)\n\t\t*outBytes = rdp->outBytes;\n\tif (inPackets)\n\t\t*inPackets = rdp->inPackets;\n\tif (outPackets)\n\t\t*outPackets = rdp->outPackets;\n\n\treturn TRUE;\n}\n\n/**\n * Instantiate new RDP module.\n * @return new RDP module\n */\n\nrdpRdp* rdp_new(rdpContext* context)\n{\n\trdpRdp* rdp;\n\tDWORD flags;\n\tBOOL newSettings = FALSE;\n\trdp = (rdpRdp*)calloc(1, sizeof(rdpRdp));\n\n\tif (!rdp)\n\t\treturn NULL;\n\n\trdp->context = context;\n\trdp->instance = context->instance;\n\tflags = 0;\n\n\tif (context->ServerMode)\n\t\tflags |= FREERDP_SETTINGS_SERVER_MODE;\n\n\tif (!context->settings)\n\t{\n\t\tcontext->settings = freerdp_settings_new(flags);\n\n\t\tif (!context->settings)\n\t\t\tgoto out_free;\n\n\t\tnewSettings = TRUE;\n\t}\n\n\trdp->settings = context->settings;\n\n\tif (context->instance)\n\t{\n\t\trdp->settings->instance = context->instance;\n\t\tcontext->instance->settings = rdp->settings;\n\t}\n\telse if (context->peer)\n\t{\n\t\trdp->settings->instance = context->peer;\n\t\tcontext->peer->settings = rdp->settings;\n\t}\n\n\trdp->transport = transport_new(context);\n\n\tif (!rdp->transport)\n\t\tgoto out_free_settings;\n\n\trdp->license = license_new(rdp);\n\n\tif (!rdp->license)\n\t\tgoto out_free_transport;\n\n\trdp->input = input_new(rdp);\n\n\tif (!rdp->input)\n\t\tgoto out_free_license;\n\n\trdp->update = update_new(rdp);\n\n\tif (!rdp->update)\n\t\tgoto out_free_input;\n\n\trdp->fastpath = fastpath_new(rdp);\n\n\tif (!rdp->fastpath)\n\t\tgoto out_free_update;\n\n\trdp->nego = nego_new(rdp->transport);\n\n\tif (!rdp->nego)\n\t\tgoto out_free_fastpath;\n\n\trdp->mcs = mcs_new(rdp->transport);\n\n\tif (!rdp->mcs)\n\t\tgoto out_free_nego;\n\n\trdp->redirection = redirection_new();\n\n\tif (!rdp->redirection)\n\t\tgoto out_free_mcs;\n\n\trdp->autodetect = autodetect_new();\n\n\tif (!rdp->autodetect)\n\t\tgoto out_free_redirection;\n\n\trdp->heartbeat = heartbeat_new();\n\n\tif (!rdp->heartbeat)\n\t\tgoto out_free_autodetect;\n\n\trdp->multitransport = multitransport_new();\n\n\tif (!rdp->multitransport)\n\t\tgoto out_free_heartbeat;\n\n\trdp->bulk = bulk_new(context);\n\n\tif (!rdp->bulk)\n\t\tgoto out_free_multitransport;\n\n\treturn rdp;\nout_free_multitransport:\n\tmultitransport_free(rdp->multitransport);\nout_free_heartbeat:\n\theartbeat_free(rdp->heartbeat);\nout_free_autodetect:\n\tautodetect_free(rdp->autodetect);\nout_free_redirection:\n\tredirection_free(rdp->redirection);\nout_free_mcs:\n\tmcs_free(rdp->mcs);\nout_free_nego:\n\tnego_free(rdp->nego);\nout_free_fastpath:\n\tfastpath_free(rdp->fastpath);\nout_free_update:\n\tupdate_free(rdp->update);\nout_free_input:\n\tinput_free(rdp->input);\nout_free_license:\n\tlicense_free(rdp->license);\nout_free_transport:\n\ttransport_free(rdp->transport);\nout_free_settings:\n\n\tif (newSettings)\n\t\tfreerdp_settings_free(rdp->settings);\n\nout_free:\n\tfree(rdp);\n\treturn NULL;\n}\n\nvoid rdp_reset(rdpRdp* rdp)\n{\n\trdpContext* context;\n\trdpSettings* settings;\n\tcontext = rdp->context;\n\tsettings = rdp->settings;\n\tbulk_reset(rdp->bulk);\n\n\tif (rdp->rc4_decrypt_key)\n\t{\n\t\twinpr_RC4_Free(rdp->rc4_decrypt_key);\n\t\trdp->rc4_decrypt_key = NULL;\n\t}\n\n\tif (rdp->rc4_encrypt_key)\n\t{\n\t\twinpr_RC4_Free(rdp->rc4_encrypt_key);\n\t\trdp->rc4_encrypt_key = NULL;\n\t}\n\n\tif (rdp->fips_encrypt)\n\t{\n\t\twinpr_Cipher_Free(rdp->fips_encrypt);\n\t\trdp->fips_encrypt = NULL;\n\t}\n\n\tif (rdp->fips_decrypt)\n\t{\n\t\twinpr_Cipher_Free(rdp->fips_decrypt);\n\t\trdp->fips_decrypt = NULL;\n\t}\n\n\tif (settings->ServerRandom)\n\t{\n\t\tfree(settings->ServerRandom);\n\t\tsettings->ServerRandom = NULL;\n\t\tsettings->ServerRandomLength = 0;\n\t}\n\n\tif (settings->ServerCertificate)\n\t{\n\t\tfree(settings->ServerCertificate);\n\t\tsettings->ServerCertificate = NULL;\n\t}\n\n\tif (settings->ClientAddress)\n\t{\n\t\tfree(settings->ClientAddress);\n\t\tsettings->ClientAddress = NULL;\n\t}\n\n\tmcs_free(rdp->mcs);\n\tnego_free(rdp->nego);\n\tlicense_free(rdp->license);\n\ttransport_free(rdp->transport);\n\tfastpath_free(rdp->fastpath);\n\trdp->transport = transport_new(context);\n\trdp->license = license_new(rdp);\n\trdp->nego = nego_new(rdp->transport);\n\trdp->mcs = mcs_new(rdp->transport);\n\trdp->fastpath = fastpath_new(rdp);\n\trdp->transport->layer = TRANSPORT_LAYER_TCP;\n\trdp->errorInfo = 0;\n\trdp->deactivation_reactivation = 0;\n\trdp->finalize_sc_pdus = 0;\n}\n\n/**\n * Free RDP module.\n * @param rdp RDP module to be freed\n */\n\nvoid rdp_free(rdpRdp* rdp)\n{\n\tif (rdp)\n\t{\n\t\twinpr_RC4_Free(rdp->rc4_decrypt_key);\n\t\twinpr_RC4_Free(rdp->rc4_encrypt_key);\n\t\twinpr_Cipher_Free(rdp->fips_encrypt);\n\t\twinpr_Cipher_Free(rdp->fips_decrypt);\n\t\tfreerdp_settings_free(rdp->settings);\n\t\ttransport_free(rdp->transport);\n\t\tlicense_free(rdp->license);\n\t\tinput_free(rdp->input);\n\t\tupdate_free(rdp->update);\n\t\tfastpath_free(rdp->fastpath);\n\t\tnego_free(rdp->nego);\n\t\tmcs_free(rdp->mcs);\n\t\tnla_free(rdp->nla);\n\t\tredirection_free(rdp->redirection);\n\t\tautodetect_free(rdp->autodetect);\n\t\theartbeat_free(rdp->heartbeat);\n\t\tmultitransport_free(rdp->multitransport);\n\t\tbulk_free(rdp->bulk);\n\t\tfree(rdp);\n\t}\n}\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * RDP Core\n *\n * Copyright 2011 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2014 DI (FH) Martin Haimberger <martin.haimberger@thincast.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef FREERDP_LIB_CORE_RDP_H\n#define FREERDP_LIB_CORE_RDP_H\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"nla.h\"\n#include \"mcs.h\"\n#include \"tpkt.h\"\n#include \"bulk.h\"\n#include \"fastpath.h\"\n#include \"tpdu.h\"\n#include \"nego.h\"\n#include \"input.h\"\n#include \"update.h\"\n#include \"license.h\"\n#include \"errinfo.h\"\n#include \"autodetect.h\"\n#include \"heartbeat.h\"\n#include \"multitransport.h\"\n#include \"security.h\"\n#include \"transport.h\"\n#include \"connection.h\"\n#include \"redirection.h\"\n#include \"capabilities.h\"\n#include \"channels.h\"\n\n#include <freerdp/freerdp.h>\n#include <freerdp/settings.h>\n#include <freerdp/log.h>\n#include <freerdp/api.h>\n\n#include <winpr/stream.h>\n#include <winpr/crypto.h>\n\n/* Security Header Flags */\n#define SEC_EXCHANGE_PKT 0x0001\n#define SEC_TRANSPORT_REQ 0x0002\n#define SEC_TRANSPORT_RSP 0x0004\n#define SEC_ENCRYPT 0x0008\n#define SEC_RESET_SEQNO 0x0010\n#define SEC_IGNORE_SEQNO 0x0020\n#define SEC_INFO_PKT 0x0040\n#define SEC_LICENSE_PKT 0x0080\n#define SEC_LICENSE_ENCRYPT_CS 0x0200\n#define SEC_LICENSE_ENCRYPT_SC 0x0200\n#define SEC_REDIRECTION_PKT 0x0400\n#define SEC_SECURE_CHECKSUM 0x0800\n#define SEC_AUTODETECT_REQ 0x1000\n#define SEC_AUTODETECT_RSP 0x2000\n#define SEC_HEARTBEAT 0x4000\n#define SEC_FLAGSHI_VALID 0x8000\n\n#define SEC_PKT_CS_MASK (SEC_EXCHANGE_PKT | SEC_INFO_PKT)\n#define SEC_PKT_SC_MASK (SEC_LICENSE_PKT | SEC_REDIRECTION_PKT)\n#define SEC_PKT_MASK (SEC_PKT_CS_MASK | SEC_PKT_SC_MASK)\n\n#define RDP_SECURITY_HEADER_LENGTH 4\n#define RDP_SHARE_CONTROL_HEADER_LENGTH 6\n#define RDP_SHARE_DATA_HEADER_LENGTH 12\n#define RDP_PACKET_HEADER_MAX_LENGTH (TPDU_DATA_LENGTH + MCS_SEND_DATA_HEADER_MAX_LENGTH)\n\n#define PDU_TYPE_DEMAND_ACTIVE 0x1\n#define PDU_TYPE_CONFIRM_ACTIVE 0x3\n#define PDU_TYPE_DEACTIVATE_ALL 0x6\n#define PDU_TYPE_DATA 0x7\n#define PDU_TYPE_SERVER_REDIRECTION 0xA\n\n#define PDU_TYPE_FLOW_TEST 0x41\n#define PDU_TYPE_FLOW_RESPONSE 0x42\n#define PDU_TYPE_FLOW_STOP 0x43\n\n#define FINALIZE_SC_SYNCHRONIZE_PDU 0x01\n#define FINALIZE_SC_CONTROL_COOPERATE_PDU 0x02\n#define FINALIZE_SC_CONTROL_GRANTED_PDU 0x04\n#define FINALIZE_SC_FONT_MAP_PDU 0x08\n#define FINALIZE_SC_COMPLETE 0x0F\n\n/* Data PDU Types */\n#define DATA_PDU_TYPE_UPDATE 0x02\n#define DATA_PDU_TYPE_CONTROL 0x14\n#define DATA_PDU_TYPE_POINTER 0x1B\n#define DATA_PDU_TYPE_INPUT 0x1C\n#define DATA_PDU_TYPE_SYNCHRONIZE 0x1F\n#define DATA_PDU_TYPE_REFRESH_RECT 0x21\n#define DATA_PDU_TYPE_PLAY_SOUND 0x22\n#define DATA_PDU_TYPE_SUPPRESS_OUTPUT 0x23\n#define DATA_PDU_TYPE_SHUTDOWN_REQUEST 0x24\n#define DATA_PDU_TYPE_SHUTDOWN_DENIED 0x25\n#define DATA_PDU_TYPE_SAVE_SESSION_INFO 0x26\n#define DATA_PDU_TYPE_FONT_LIST 0x27\n#define DATA_PDU_TYPE_FONT_MAP 0x28\n#define DATA_PDU_TYPE_SET_KEYBOARD_INDICATORS 0x29\n#define DATA_PDU_TYPE_BITMAP_CACHE_PERSISTENT_LIST 0x2B\n#define DATA_PDU_TYPE_BITMAP_CACHE_ERROR 0x2C\n#define DATA_PDU_TYPE_SET_KEYBOARD_IME_STATUS 0x2D\n#define DATA_PDU_TYPE_OFFSCREEN_CACHE_ERROR 0x2E\n#define DATA_PDU_TYPE_SET_ERROR_INFO 0x2F\n#define DATA_PDU_TYPE_DRAW_NINEGRID_ERROR 0x30\n#define DATA_PDU_TYPE_DRAW_GDIPLUS_ERROR 0x31\n#define DATA_PDU_TYPE_ARC_STATUS 0x32\n#define DATA_PDU_TYPE_STATUS_INFO 0x36\n#define DATA_PDU_TYPE_MONITOR_LAYOUT 0x37\n#define DATA_PDU_TYPE_FRAME_ACKNOWLEDGE 0x38\n\n/* Stream Identifiers */\n#define STREAM_UNDEFINED 0x00\n#define STREAM_LOW 0x01\n#define STREAM_MED 0x02\n#define STREAM_HI 0x04\n\nstruct rdp_rdp\n{\n\tint state;\n\tfreerdp* instance;\n\trdpContext* context;\n\trdpNla* nla;\n\trdpMcs* mcs;\n\trdpNego* nego;\n\trdpBulk* bulk;\n\trdpInput* input;\n\trdpUpdate* update;\n\trdpFastPath* fastpath;\n\trdpLicense* license;\n\trdpRedirection* redirection;\n\trdpSettings* settings;\n\trdpTransport* transport;\n\trdpAutoDetect* autodetect;\n\trdpHeartbeat* heartbeat;\n\trdpMultitransport* multitransport;\n\tWINPR_RC4_CTX* rc4_decrypt_key;\n\tint decrypt_use_count;\n\tint decrypt_checksum_use_count;\n\tWINPR_RC4_CTX* rc4_encrypt_key;\n\tint encrypt_use_count;\n\tint encrypt_checksum_use_count;\n\tWINPR_CIPHER_CTX* fips_encrypt;\n\tWINPR_CIPHER_CTX* fips_decrypt;\n\tUINT32 sec_flags;\n\tBOOL do_crypt;\n\tBOOL do_crypt_license;\n\tBOOL do_secure_checksum;\n\tBYTE sign_key[16];\n\tBYTE decrypt_key[16];\n\tBYTE encrypt_key[16];\n\tBYTE decrypt_update_key[16];\n\tBYTE encrypt_update_key[16];\n\tint rc4_key_len;\n\tBYTE fips_sign_key[20];\n\tBYTE fips_encrypt_key[24];\n\tBYTE fips_decrypt_key[24];\n\tUINT32 errorInfo;\n\tUINT32 finalize_sc_pdus;\n\tBOOL resendFocus;\n\tBOOL deactivation_reactivation;\n\tBOOL AwaitCapabilities;\n\tUINT64 inBytes;\n\tUINT64 inPackets;\n\tUINT64 outBytes;\n\tUINT64 outPackets;\n};\n\nFREERDP_LOCAL BOOL rdp_read_security_header(wStream* s, UINT16* flags, UINT16* length);\nFREERDP_LOCAL void rdp_write_security_header(wStream* s, UINT16 flags);\n\nFREERDP_LOCAL BOOL rdp_read_share_control_header(wStream* s, UINT16* tpktLength,\n                                                 UINT16* remainingLength, UINT16* type,\n                                                 UINT16* channel_id);\n\nFREERDP_LOCAL BOOL rdp_read_share_data_header(wStream* s, UINT16* length, BYTE* type,\n                                              UINT32* share_id, BYTE* compressed_type,\n                                              UINT16* compressed_len);\n\nFREERDP_LOCAL wStream* rdp_send_stream_init(rdpRdp* rdp);\nFREERDP_LOCAL wStream* rdp_send_stream_pdu_init(rdpRdp* rdp);\n\nFREERDP_LOCAL BOOL rdp_read_header(rdpRdp* rdp, wStream* s, UINT16* length, UINT16* channel_id);\nFREERDP_LOCAL void rdp_write_header(rdpRdp* rdp, wStream* s, UINT16 length, UINT16 channel_id);\n\nFREERDP_LOCAL BOOL rdp_send_pdu(rdpRdp* rdp, wStream* s, UINT16 type, UINT16 channel_id);\n\nFREERDP_LOCAL wStream* rdp_data_pdu_init(rdpRdp* rdp);\nFREERDP_LOCAL BOOL rdp_send_data_pdu(rdpRdp* rdp, wStream* s, BYTE type, UINT16 channel_id);\nFREERDP_LOCAL int rdp_recv_data_pdu(rdpRdp* rdp, wStream* s);\n\nFREERDP_LOCAL BOOL rdp_send(rdpRdp* rdp, wStream* s, UINT16 channelId);\n\nFREERDP_LOCAL BOOL rdp_send_channel_data(rdpRdp* rdp, UINT16 channelId, const BYTE* data,\n                                         size_t size);\n\nFREERDP_LOCAL wStream* rdp_message_channel_pdu_init(rdpRdp* rdp);\nFREERDP_LOCAL BOOL rdp_send_message_channel_pdu(rdpRdp* rdp, wStream* s, UINT16 sec_flags);\nFREERDP_LOCAL int rdp_recv_message_channel_pdu(rdpRdp* rdp, wStream* s, UINT16 securityFlags);\n\nFREERDP_LOCAL int rdp_recv_out_of_sequence_pdu(rdpRdp* rdp, wStream* s);\n\nFREERDP_LOCAL int rdp_recv_callback(rdpTransport* transport, wStream* s, void* extra);\n\nFREERDP_LOCAL int rdp_check_fds(rdpRdp* rdp);\n\nFREERDP_LOCAL rdpRdp* rdp_new(rdpContext* context);\nFREERDP_LOCAL void rdp_reset(rdpRdp* rdp);\nFREERDP_LOCAL void rdp_free(rdpRdp* rdp);\n\n#define RDP_TAG FREERDP_TAG(\"core.rdp\")\n#ifdef WITH_DEBUG_RDP\n#define DEBUG_RDP(...) WLog_DBG(RDP_TAG, __VA_ARGS__)\nextern const char* DATA_PDU_TYPE_STRINGS[80];\n#else\n#define DEBUG_RDP(...) \\\n\tdo                 \\\n\t{                  \\\n\t} while (0)\n#endif\n\nBOOL rdp_decrypt(rdpRdp* rdp, wStream* s, UINT16* pLength, UINT16 securityFlags);\n\nBOOL rdp_set_error_info(rdpRdp* rdp, UINT32 errorInfo);\nBOOL rdp_send_error_info(rdpRdp* rdp);\n\n#endif /* FREERDP_LIB_CORE_RDP_H */\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * Update Data PDUs\n *\n * Copyright 2011 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2016 Armin Novak <armin.novak@thincast.com>\n * Copyright 2016 Thincast Technologies GmbH\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <winpr/crt.h>\n#include <winpr/print.h>\n#include <winpr/synch.h>\n#include <winpr/thread.h>\n#include <winpr/collections.h>\n\n#include \"update.h\"\n#include \"surface.h\"\n#include \"message.h\"\n#include \"info.h\"\n#include \"window.h\"\n\n#include <freerdp/log.h>\n#include <freerdp/peer.h>\n#include <freerdp/codec/bitmap.h>\n\n#include \"../cache/pointer.h\"\n#include \"../cache/palette.h\"\n#include \"../cache/bitmap.h\"\n\n#define TAG FREERDP_TAG(\"core.update\")\n\nstatic const char* const UPDATE_TYPE_STRINGS[] = { \"Orders\", \"Bitmap\", \"Palette\", \"Synchronize\" };\n\nstatic const char* update_type_to_string(UINT16 updateType)\n{\n\tif (updateType >= ARRAYSIZE(UPDATE_TYPE_STRINGS))\n\t\treturn \"UNKNOWN\";\n\n\treturn UPDATE_TYPE_STRINGS[updateType];\n}\n\nstatic BOOL update_recv_orders(rdpUpdate* update, wStream* s)\n{\n\tUINT16 numberOrders;\n\n\tif (Stream_GetRemainingLength(s) < 6)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < 6\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Seek_UINT16(s);               /* pad2OctetsA (2 bytes) */\n\tStream_Read_UINT16(s, numberOrders); /* numberOrders (2 bytes) */\n\tStream_Seek_UINT16(s);               /* pad2OctetsB (2 bytes) */\n\n\twhile (numberOrders > 0)\n\t{\n\t\tif (!update_recv_order(update, s))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"update_recv_order() failed\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tnumberOrders--;\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL update_read_bitmap_data(rdpUpdate* update, wStream* s, BITMAP_DATA* bitmapData)\n{\n\tWINPR_UNUSED(update);\n\tif (Stream_GetRemainingLength(s) < 18)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, bitmapData->destLeft);\n\tStream_Read_UINT16(s, bitmapData->destTop);\n\tStream_Read_UINT16(s, bitmapData->destRight);\n\tStream_Read_UINT16(s, bitmapData->destBottom);\n\tStream_Read_UINT16(s, bitmapData->width);\n\tStream_Read_UINT16(s, bitmapData->height);\n\tStream_Read_UINT16(s, bitmapData->bitsPerPixel);\n\tStream_Read_UINT16(s, bitmapData->flags);\n\tStream_Read_UINT16(s, bitmapData->bitmapLength);\n\n\tif (bitmapData->flags & BITMAP_COMPRESSION)\n\t{\n\t\tif (!(bitmapData->flags & NO_BITMAP_COMPRESSION_HDR))\n\t\t{\n\t\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\t\treturn FALSE;\n\n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbCompFirstRowSize); /* cbCompFirstRowSize (2 bytes) */\n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbCompMainBodySize); /* cbCompMainBodySize (2 bytes) */\n\t\t\tStream_Read_UINT16(s, bitmapData->cbScanWidth);     /* cbScanWidth (2 bytes) */\n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbUncompressedSize); /* cbUncompressedSize (2 bytes) */\n\t\t\tbitmapData->bitmapLength = bitmapData->cbCompMainBodySize;\n\t\t}\n\n\t\tbitmapData->compressed = TRUE;\n\t}\n\telse\n\t\tbitmapData->compressed = FALSE;\n\n\tif (Stream_GetRemainingLength(s) < bitmapData->bitmapLength)\n\t\treturn FALSE;\n\n\tif (bitmapData->bitmapLength > 0)\n\t{\n\t\tbitmapData->bitmapDataStream = malloc(bitmapData->bitmapLength);\n\n\t\tif (!bitmapData->bitmapDataStream)\n\t\t\treturn FALSE;\n\n\t\tmemcpy(bitmapData->bitmapDataStream, Stream_Pointer(s), bitmapData->bitmapLength);\n\t\tStream_Seek(s, bitmapData->bitmapLength);\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL update_write_bitmap_data(rdpUpdate* update, wStream* s, BITMAP_DATA* bitmapData)\n{\n\tif (!Stream_EnsureRemainingCapacity(s, 64 + bitmapData->bitmapLength))\n\t\treturn FALSE;\n\n\tif (update->autoCalculateBitmapData)\n\t{\n\t\tbitmapData->flags = 0;\n\t\tbitmapData->cbCompFirstRowSize = 0;\n\n\t\tif (bitmapData->compressed)\n\t\t\tbitmapData->flags |= BITMAP_COMPRESSION;\n\n\t\tif (update->context->settings->NoBitmapCompressionHeader)\n\t\t{\n\t\t\tbitmapData->flags |= NO_BITMAP_COMPRESSION_HDR;\n\t\t\tbitmapData->cbCompMainBodySize = bitmapData->bitmapLength;\n\t\t}\n\t}\n\n\tStream_Write_UINT16(s, bitmapData->destLeft);\n\tStream_Write_UINT16(s, bitmapData->destTop);\n\tStream_Write_UINT16(s, bitmapData->destRight);\n\tStream_Write_UINT16(s, bitmapData->destBottom);\n\tStream_Write_UINT16(s, bitmapData->width);\n\tStream_Write_UINT16(s, bitmapData->height);\n\tStream_Write_UINT16(s, bitmapData->bitsPerPixel);\n\tStream_Write_UINT16(s, bitmapData->flags);\n\tStream_Write_UINT16(s, bitmapData->bitmapLength);\n\n\tif (bitmapData->flags & BITMAP_COMPRESSION)\n\t{\n\t\tif (!(bitmapData->flags & NO_BITMAP_COMPRESSION_HDR))\n\t\t{\n\t\t\tStream_Write_UINT16(s,\n\t\t\t                    bitmapData->cbCompFirstRowSize); /* cbCompFirstRowSize (2 bytes) */\n\t\t\tStream_Write_UINT16(s,\n\t\t\t                    bitmapData->cbCompMainBodySize); /* cbCompMainBodySize (2 bytes) */\n\t\t\tStream_Write_UINT16(s, bitmapData->cbScanWidth);     /* cbScanWidth (2 bytes) */\n\t\t\tStream_Write_UINT16(s,\n\t\t\t                    bitmapData->cbUncompressedSize); /* cbUncompressedSize (2 bytes) */\n\t\t}\n\n\t\tStream_Write(s, bitmapData->bitmapDataStream, bitmapData->bitmapLength);\n\t}\n\telse\n\t{\n\t\tStream_Write(s, bitmapData->bitmapDataStream, bitmapData->bitmapLength);\n\t}\n\n\treturn TRUE;\n}\n\nBITMAP_UPDATE* update_read_bitmap_update(rdpUpdate* update, wStream* s)\n{\n\tUINT32 i;\n\tBITMAP_UPDATE* bitmapUpdate = calloc(1, sizeof(BITMAP_UPDATE));\n\n\tif (!bitmapUpdate)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, bitmapUpdate->number); /* numberRectangles (2 bytes) */\n\tWLog_Print(update->log, WLOG_TRACE, \"BitmapUpdate: %\" PRIu32 \"\", bitmapUpdate->number);\n\n\tif (bitmapUpdate->number > bitmapUpdate->count)\n\t{\n\t\tUINT32 count = bitmapUpdate->number * 2;\n\t\tBITMAP_DATA* newdata =\n\t\t    (BITMAP_DATA*)realloc(bitmapUpdate->rectangles, sizeof(BITMAP_DATA) * count);\n\n\t\tif (!newdata)\n\t\t\tgoto fail;\n\n\t\tbitmapUpdate->rectangles = newdata;\n\t\tZeroMemory(&bitmapUpdate->rectangles[bitmapUpdate->count],\n\t\t           sizeof(BITMAP_DATA) * (count - bitmapUpdate->count));\n\t\tbitmapUpdate->count = count;\n\t}\n\n\t/* rectangles */\n\tfor (i = 0; i < bitmapUpdate->number; i++)\n\t{\n\t\tif (!update_read_bitmap_data(update, s, &bitmapUpdate->rectangles[i]))\n\t\t\tgoto fail;\n\t}\n\n\treturn bitmapUpdate;\nfail:\n\tfree_bitmap_update(update->context, bitmapUpdate);\n\treturn NULL;\n}\n\nstatic BOOL update_write_bitmap_update(rdpUpdate* update, wStream* s,\n                                       const BITMAP_UPDATE* bitmapUpdate)\n{\n\tint i;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 32))\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, UPDATE_TYPE_BITMAP);   /* updateType */\n\tStream_Write_UINT16(s, bitmapUpdate->number); /* numberRectangles (2 bytes) */\n\n\t/* rectangles */\n\tfor (i = 0; i < (int)bitmapUpdate->number; i++)\n\t{\n\t\tif (!update_write_bitmap_data(update, s, &bitmapUpdate->rectangles[i]))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nPALETTE_UPDATE* update_read_palette(rdpUpdate* update, wStream* s)\n{\n\tint i;\n\tPALETTE_ENTRY* entry;\n\tPALETTE_UPDATE* palette_update = calloc(1, sizeof(PALETTE_UPDATE));\n\n\tif (!palette_update)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 6)\n\t\tgoto fail;\n\n\tStream_Seek_UINT16(s);                         /* pad2Octets (2 bytes) */\n\tStream_Read_UINT32(s, palette_update->number); /* numberColors (4 bytes), must be set to 256 */\n\n\tif (palette_update->number > 256)\n\t\tpalette_update->number = 256;\n\n\tif (Stream_GetRemainingLength(s) < palette_update->number * 3)\n\t\tgoto fail;\n\n\t/* paletteEntries */\n\tfor (i = 0; i < (int)palette_update->number; i++)\n\t{\n\t\tentry = &palette_update->entries[i];\n\t\tStream_Read_UINT8(s, entry->red);\n\t\tStream_Read_UINT8(s, entry->green);\n\t\tStream_Read_UINT8(s, entry->blue);\n\t}\n\n\treturn palette_update;\nfail:\n\tfree_palette_update(update->context, palette_update);\n\treturn NULL;\n}\n\nstatic BOOL update_read_synchronize(rdpUpdate* update, wStream* s)\n{\n\tWINPR_UNUSED(update);\n\treturn Stream_SafeSeek(s, 2); /* pad2Octets (2 bytes) */\n\t                              /**\n\t                               * The Synchronize Update is an artifact from the\n\t                               * T.128 protocol and should be ignored.\n\t                               */\n}\n\nstatic BOOL update_read_play_sound(wStream* s, PLAY_SOUND_UPDATE* play_sound)\n{\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, play_sound->duration);  /* duration (4 bytes) */\n\tStream_Read_UINT32(s, play_sound->frequency); /* frequency (4 bytes) */\n\treturn TRUE;\n}\n\nBOOL update_recv_play_sound(rdpUpdate* update, wStream* s)\n{\n\tPLAY_SOUND_UPDATE play_sound;\n\n\tif (!update_read_play_sound(s, &play_sound))\n\t\treturn FALSE;\n\n\treturn IFCALLRESULT(FALSE, update->PlaySound, update->context, &play_sound);\n}\n\nPOINTER_POSITION_UPDATE* update_read_pointer_position(rdpUpdate* update, wStream* s)\n{\n\tPOINTER_POSITION_UPDATE* pointer_position = calloc(1, sizeof(POINTER_POSITION_UPDATE));\n\n\tif (!pointer_position)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, pointer_position->xPos); /* xPos (2 bytes) */\n\tStream_Read_UINT16(s, pointer_position->yPos); /* yPos (2 bytes) */\n\treturn pointer_position;\nfail:\n\tfree_pointer_position_update(update->context, pointer_position);\n\treturn NULL;\n}\n\nPOINTER_SYSTEM_UPDATE* update_read_pointer_system(rdpUpdate* update, wStream* s)\n{\n\tPOINTER_SYSTEM_UPDATE* pointer_system = calloc(1, sizeof(POINTER_SYSTEM_UPDATE));\n\n\tif (!pointer_system)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\tgoto fail;\n\n\tStream_Read_UINT32(s, pointer_system->type); /* systemPointerType (4 bytes) */\n\treturn pointer_system;\nfail:\n\tfree_pointer_system_update(update->context, pointer_system);\n\treturn NULL;\n}\n\nstatic BOOL _update_read_pointer_color(wStream* s, POINTER_COLOR_UPDATE* pointer_color, BYTE xorBpp)\n{\n\tBYTE* newMask;\n\tUINT32 scanlineSize;\n\n\tif (!pointer_color)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 14)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, pointer_color->cacheIndex); /* cacheIndex (2 bytes) */\n\tStream_Read_UINT16(s, pointer_color->xPos);       /* xPos (2 bytes) */\n\tStream_Read_UINT16(s, pointer_color->yPos);       /* yPos (2 bytes) */\n\t/**\n\t *  As stated in 2.2.9.1.1.4.4 Color Pointer Update:\n\t *  The maximum allowed pointer width/height is 96 pixels if the client indicated support\n\t *  for large pointers by setting the LARGE_POINTER_FLAG (0x00000001) in the Large\n\t *  Pointer Capability Set (section 2.2.7.2.7). If the LARGE_POINTER_FLAG was not\n\t *  set, the maximum allowed pointer width/height is 32 pixels.\n\t *\n\t *  So we check for a maximum of 96 for CVE-2014-0250.\n\t */\n\tStream_Read_UINT16(s, pointer_color->width);  /* width (2 bytes) */\n\tStream_Read_UINT16(s, pointer_color->height); /* height (2 bytes) */\n\n\tif ((pointer_color->width > 96) || (pointer_color->height > 96))\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, pointer_color->lengthAndMask); /* lengthAndMask (2 bytes) */\n\tStream_Read_UINT16(s, pointer_color->lengthXorMask); /* lengthXorMask (2 bytes) */\n\n\t/**\n\t * There does not seem to be any documentation on why\n\t * xPos / yPos can be larger than width / height\n\t * so it is missing in documentation or a bug in implementation\n\t * 2.2.9.1.1.4.4 Color Pointer Update (TS_COLORPOINTERATTRIBUTE)\n\t */\n\tif (pointer_color->xPos >= pointer_color->width)\n\t\tpointer_color->xPos = 0;\n\n\tif (pointer_color->yPos >= pointer_color->height)\n\t\tpointer_color->yPos = 0;\n\n\tif (pointer_color->lengthXorMask > 0)\n\t{\n\t\t/**\n\t\t * Spec states that:\n\t\t *\n\t\t * xorMaskData (variable): A variable-length array of bytes. Contains the 24-bpp, bottom-up\n\t\t * XOR mask scan-line data. The XOR mask is padded to a 2-byte boundary for each encoded\n\t\t * scan-line. For example, if a 3x3 pixel cursor is being sent, then each scan-line will\n\t\t * consume 10 bytes (3 pixels per scan-line multiplied by 3 bytes per pixel, rounded up to\n\t\t * the next even number of bytes).\n\t\t *\n\t\t * In fact instead of 24-bpp, the bpp parameter is given by the containing packet.\n\t\t */\n\t\tif (Stream_GetRemainingLength(s) < pointer_color->lengthXorMask)\n\t\t\tgoto fail;\n\n\t\tscanlineSize = (7 + xorBpp * pointer_color->width) / 8;\n\t\tscanlineSize = ((scanlineSize + 1) / 2) * 2;\n\n\t\tif (scanlineSize * pointer_color->height != pointer_color->lengthXorMask)\n\t\t{\n\t\t\tWLog_ERR(TAG,\n\t\t\t         \"invalid lengthXorMask: width=%\" PRIu32 \" height=%\" PRIu32 \", %\" PRIu32\n\t\t\t         \" instead of %\" PRIu32 \"\",\n\t\t\t         pointer_color->width, pointer_color->height, pointer_color->lengthXorMask,\n\t\t\t         scanlineSize * pointer_color->height);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tnewMask = realloc(pointer_color->xorMaskData, pointer_color->lengthXorMask);\n\n\t\tif (!newMask)\n\t\t\tgoto fail;\n\n\t\tpointer_color->xorMaskData = newMask;\n\t\tStream_Read(s, pointer_color->xorMaskData, pointer_color->lengthXorMask);\n\t}\n\n\tif (pointer_color->lengthAndMask > 0)\n\t{\n\t\t/**\n\t\t * andMaskData (variable): A variable-length array of bytes. Contains the 1-bpp, bottom-up\n\t\t * AND mask scan-line data. The AND mask is padded to a 2-byte boundary for each encoded\n\t\t * scan-line. For example, if a 7x7 pixel cursor is being sent, then each scan-line will\n\t\t * consume 2 bytes (7 pixels per scan-line multiplied by 1 bpp, rounded up to the next even\n\t\t * number of bytes).\n\t\t */\n\t\tif (Stream_GetRemainingLength(s) < pointer_color->lengthAndMask)\n\t\t\tgoto fail;\n\n\t\tscanlineSize = ((7 + pointer_color->width) / 8);\n\t\tscanlineSize = ((1 + scanlineSize) / 2) * 2;\n\n\t\tif (scanlineSize * pointer_color->height != pointer_color->lengthAndMask)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"invalid lengthAndMask: %\" PRIu32 \" instead of %\" PRIu32 \"\",\n\t\t\t         pointer_color->lengthAndMask, scanlineSize * pointer_color->height);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tnewMask = realloc(pointer_color->andMaskData, pointer_color->lengthAndMask);\n\n\t\tif (!newMask)\n\t\t\tgoto fail;\n\n\t\tpointer_color->andMaskData = newMask;\n\t\tStream_Read(s, pointer_color->andMaskData, pointer_color->lengthAndMask);\n\t}\n\n\tif (Stream_GetRemainingLength(s) > 0)\n\t\tStream_Seek_UINT8(s); /* pad (1 byte) */\n\n\treturn TRUE;\nfail:\n\treturn FALSE;\n}\n\nPOINTER_COLOR_UPDATE* update_read_pointer_color(rdpUpdate* update, wStream* s, BYTE xorBpp)\n{\n\tPOINTER_COLOR_UPDATE* pointer_color = calloc(1, sizeof(POINTER_COLOR_UPDATE));\n\n\tif (!pointer_color)\n\t\tgoto fail;\n\n\tif (!_update_read_pointer_color(s, pointer_color, xorBpp))\n\t\tgoto fail;\n\n\treturn pointer_color;\nfail:\n\tfree_pointer_color_update(update->context, pointer_color);\n\treturn NULL;\n}\n\nstatic BOOL _update_read_pointer_large(wStream* s, POINTER_LARGE_UPDATE* pointer)\n{\n\tBYTE* newMask;\n\tUINT32 scanlineSize;\n\n\tif (!pointer)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 14)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, pointer->xorBpp);\n\tStream_Read_UINT16(s, pointer->cacheIndex); /* cacheIndex (2 bytes) */\n\tStream_Read_UINT16(s, pointer->hotSpotX);   /* xPos (2 bytes) */\n\tStream_Read_UINT16(s, pointer->hotSpotY);   /* yPos (2 bytes) */\n\n\tStream_Read_UINT16(s, pointer->width);  /* width (2 bytes) */\n\tStream_Read_UINT16(s, pointer->height); /* height (2 bytes) */\n\n\tif ((pointer->width > 384) || (pointer->height > 384))\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, pointer->lengthAndMask); /* lengthAndMask (2 bytes) */\n\tStream_Read_UINT16(s, pointer->lengthXorMask); /* lengthXorMask (2 bytes) */\n\n\tif (pointer->hotSpotX >= pointer->width)\n\t\tpointer->hotSpotX = 0;\n\n\tif (pointer->hotSpotY >= pointer->height)\n\t\tpointer->hotSpotY = 0;\n\n\tif (pointer->lengthXorMask > 0)\n\t{\n\t\t/**\n\t\t * Spec states that:\n\t\t *\n\t\t * xorMaskData (variable): A variable-length array of bytes. Contains the 24-bpp, bottom-up\n\t\t * XOR mask scan-line data. The XOR mask is padded to a 2-byte boundary for each encoded\n\t\t * scan-line. For example, if a 3x3 pixel cursor is being sent, then each scan-line will\n\t\t * consume 10 bytes (3 pixels per scan-line multiplied by 3 bytes per pixel, rounded up to\n\t\t * the next even number of bytes).\n\t\t *\n\t\t * In fact instead of 24-bpp, the bpp parameter is given by the containing packet.\n\t\t */\n\t\tif (Stream_GetRemainingLength(s) < pointer->lengthXorMask)\n\t\t\tgoto fail;\n\n\t\tscanlineSize = (7 + pointer->xorBpp * pointer->width) / 8;\n\t\tscanlineSize = ((scanlineSize + 1) / 2) * 2;\n\n\t\tif (scanlineSize * pointer->height != pointer->lengthXorMask)\n\t\t{\n\t\t\tWLog_ERR(TAG,\n\t\t\t         \"invalid lengthXorMask: width=%\" PRIu32 \" height=%\" PRIu32 \", %\" PRIu32\n\t\t\t         \" instead of %\" PRIu32 \"\",\n\t\t\t         pointer->width, pointer->height, pointer->lengthXorMask,\n\t\t\t         scanlineSize * pointer->height);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tnewMask = realloc(pointer->xorMaskData, pointer->lengthXorMask);\n\n\t\tif (!newMask)\n\t\t\tgoto fail;\n\n\t\tpointer->xorMaskData = newMask;\n\t\tStream_Read(s, pointer->xorMaskData, pointer->lengthXorMask);\n\t}\n\n\tif (pointer->lengthAndMask > 0)\n\t{\n\t\t/**\n\t\t * andMaskData (variable): A variable-length array of bytes. Contains the 1-bpp, bottom-up\n\t\t * AND mask scan-line data. The AND mask is padded to a 2-byte boundary for each encoded\n\t\t * scan-line. For example, if a 7x7 pixel cursor is being sent, then each scan-line will\n\t\t * consume 2 bytes (7 pixels per scan-line multiplied by 1 bpp, rounded up to the next even\n\t\t * number of bytes).\n\t\t */\n\t\tif (Stream_GetRemainingLength(s) < pointer->lengthAndMask)\n\t\t\tgoto fail;\n\n\t\tscanlineSize = ((7 + pointer->width) / 8);\n\t\tscanlineSize = ((1 + scanlineSize) / 2) * 2;\n\n\t\tif (scanlineSize * pointer->height != pointer->lengthAndMask)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"invalid lengthAndMask: %\" PRIu32 \" instead of %\" PRIu32 \"\",\n\t\t\t         pointer->lengthAndMask, scanlineSize * pointer->height);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tnewMask = realloc(pointer->andMaskData, pointer->lengthAndMask);\n\n\t\tif (!newMask)\n\t\t\tgoto fail;\n\n\t\tpointer->andMaskData = newMask;\n\t\tStream_Read(s, pointer->andMaskData, pointer->lengthAndMask);\n\t}\n\n\tif (Stream_GetRemainingLength(s) > 0)\n\t\tStream_Seek_UINT8(s); /* pad (1 byte) */\n\n\treturn TRUE;\nfail:\n\treturn FALSE;\n}\n\nPOINTER_LARGE_UPDATE* update_read_pointer_large(rdpUpdate* update, wStream* s)\n{\n\tPOINTER_LARGE_UPDATE* pointer = calloc(1, sizeof(POINTER_LARGE_UPDATE));\n\n\tif (!pointer)\n\t\tgoto fail;\n\n\tif (!_update_read_pointer_large(s, pointer))\n\t\tgoto fail;\n\n\treturn pointer;\nfail:\n\tfree_pointer_large_update(update->context, pointer);\n\treturn NULL;\n}\n\nPOINTER_NEW_UPDATE* update_read_pointer_new(rdpUpdate* update, wStream* s)\n{\n\tPOINTER_NEW_UPDATE* pointer_new = calloc(1, sizeof(POINTER_NEW_UPDATE));\n\n\tif (!pointer_new)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, pointer_new->xorBpp); /* xorBpp (2 bytes) */\n\n\tif ((pointer_new->xorBpp < 1) || (pointer_new->xorBpp > 32))\n\t{\n\t\tWLog_ERR(TAG, \"invalid xorBpp %\" PRIu32 \"\", pointer_new->xorBpp);\n\t\tgoto fail;\n\t}\n\n\tif (!_update_read_pointer_color(s, &pointer_new->colorPtrAttr,\n\t                                pointer_new->xorBpp)) /* colorPtrAttr */\n\t\tgoto fail;\n\n\treturn pointer_new;\nfail:\n\tfree_pointer_new_update(update->context, pointer_new);\n\treturn NULL;\n}\n\nPOINTER_CACHED_UPDATE* update_read_pointer_cached(rdpUpdate* update, wStream* s)\n{\n\tPOINTER_CACHED_UPDATE* pointer = calloc(1, sizeof(POINTER_CACHED_UPDATE));\n\n\tif (!pointer)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, pointer->cacheIndex); /* cacheIndex (2 bytes) */\n\treturn pointer;\nfail:\n\tfree_pointer_cached_update(update->context, pointer);\n\treturn NULL;\n}\n\nBOOL update_recv_pointer(rdpUpdate* update, wStream* s)\n{\n\tBOOL rc = FALSE;\n\tUINT16 messageType;\n\trdpContext* context = update->context;\n\trdpPointerUpdate* pointer = update->pointer;\n\n\tif (Stream_GetRemainingLength(s) < 2 + 2)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, messageType); /* messageType (2 bytes) */\n\tStream_Seek_UINT16(s);              /* pad2Octets (2 bytes) */\n\n\tswitch (messageType)\n\t{\n\t\tcase PTR_MSG_TYPE_POSITION:\n\t\t{\n\t\t\tPOINTER_POSITION_UPDATE* pointer_position = update_read_pointer_position(update, s);\n\n\t\t\tif (pointer_position)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, pointer->PointerPosition, context, pointer_position);\n\t\t\t\tfree_pointer_position_update(context, pointer_position);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase PTR_MSG_TYPE_SYSTEM:\n\t\t{\n\t\t\tPOINTER_SYSTEM_UPDATE* pointer_system = update_read_pointer_system(update, s);\n\n\t\t\tif (pointer_system)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, pointer->PointerSystem, context, pointer_system);\n\t\t\t\tfree_pointer_system_update(context, pointer_system);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase PTR_MSG_TYPE_COLOR:\n\t\t{\n\t\t\tPOINTER_COLOR_UPDATE* pointer_color = update_read_pointer_color(update, s, 24);\n\n\t\t\tif (pointer_color)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, pointer->PointerColor, context, pointer_color);\n\t\t\t\tfree_pointer_color_update(context, pointer_color);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase PTR_MSG_TYPE_POINTER_LARGE:\n\t\t{\n\t\t\tPOINTER_LARGE_UPDATE* pointer_large = update_read_pointer_large(update, s);\n\n\t\t\tif (pointer_large)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, pointer->PointerLarge, context, pointer_large);\n\t\t\t\tfree_pointer_large_update(context, pointer_large);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase PTR_MSG_TYPE_POINTER:\n\t\t{\n\t\t\tPOINTER_NEW_UPDATE* pointer_new = update_read_pointer_new(update, s);\n\n\t\t\tif (pointer_new)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, pointer->PointerNew, context, pointer_new);\n\t\t\t\tfree_pointer_new_update(context, pointer_new);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase PTR_MSG_TYPE_CACHED:\n\t\t{\n\t\t\tPOINTER_CACHED_UPDATE* pointer_cached = update_read_pointer_cached(update, s);\n\n\t\t\tif (pointer_cached)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, pointer->PointerCached, context, pointer_cached);\n\t\t\t\tfree_pointer_cached_update(context, pointer_cached);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nBOOL update_recv(rdpUpdate* update, wStream* s)\n{\n\tBOOL rc = FALSE;\n\tUINT16 updateType;\n\trdpContext* context = update->context;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < 2\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, updateType); /* updateType (2 bytes) */\n\tWLog_Print(update->log, WLOG_TRACE, \"%s Update Data PDU\", UPDATE_TYPE_STRINGS[updateType]);\n\n\tif (!update_begin_paint(update))\n\t\tgoto fail;\n\n\tswitch (updateType)\n\t{\n\t\tcase UPDATE_TYPE_ORDERS:\n\t\t\trc = update_recv_orders(update, s);\n\t\t\tbreak;\n\n\t\tcase UPDATE_TYPE_BITMAP:\n\t\t{\n\t\t\tBITMAP_UPDATE* bitmap_update = update_read_bitmap_update(update, s);\n\n\t\t\tif (!bitmap_update)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_BITMAP - update_read_bitmap_update() failed\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\trc = IFCALLRESULT(FALSE, update->BitmapUpdate, context, bitmap_update);\n\t\t\tfree_bitmap_update(update->context, bitmap_update);\n\t\t}\n\t\tbreak;\n\n\t\tcase UPDATE_TYPE_PALETTE:\n\t\t{\n\t\t\tPALETTE_UPDATE* palette_update = update_read_palette(update, s);\n\n\t\t\tif (!palette_update)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_PALETTE - update_read_palette() failed\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\trc = IFCALLRESULT(FALSE, update->Palette, context, palette_update);\n\t\t\tfree_palette_update(context, palette_update);\n\t\t}\n\t\tbreak;\n\n\t\tcase UPDATE_TYPE_SYNCHRONIZE:\n\t\t\tif (!update_read_synchronize(update, s))\n\t\t\t\tgoto fail;\n\t\t\trc = IFCALLRESULT(TRUE, update->Synchronize, context);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\nfail:\n\n\tif (!update_end_paint(update))\n\t\trc = FALSE;\n\n\tif (!rc)\n\t{\n\t\tWLog_ERR(TAG, \"UPDATE_TYPE %s [%\" PRIu16 \"] failed\", update_type_to_string(updateType),\n\t\t         updateType);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nvoid update_reset_state(rdpUpdate* update)\n{\n\trdpPrimaryUpdate* primary = update->primary;\n\trdpAltSecUpdate* altsec = update->altsec;\n\n\tif (primary->fast_glyph.glyphData.aj)\n\t{\n\t\tfree(primary->fast_glyph.glyphData.aj);\n\t\tprimary->fast_glyph.glyphData.aj = NULL;\n\t}\n\n\tZeroMemory(&primary->order_info, sizeof(ORDER_INFO));\n\tZeroMemory(&primary->dstblt, sizeof(DSTBLT_ORDER));\n\tZeroMemory(&primary->patblt, sizeof(PATBLT_ORDER));\n\tZeroMemory(&primary->scrblt, sizeof(SCRBLT_ORDER));\n\tZeroMemory(&primary->opaque_rect, sizeof(OPAQUE_RECT_ORDER));\n\tZeroMemory(&primary->draw_nine_grid, sizeof(DRAW_NINE_GRID_ORDER));\n\tZeroMemory(&primary->multi_dstblt, sizeof(MULTI_DSTBLT_ORDER));\n\tZeroMemory(&primary->multi_patblt, sizeof(MULTI_PATBLT_ORDER));\n\tZeroMemory(&primary->multi_scrblt, sizeof(MULTI_SCRBLT_ORDER));\n\tZeroMemory(&primary->multi_opaque_rect, sizeof(MULTI_OPAQUE_RECT_ORDER));\n\tZeroMemory(&primary->multi_draw_nine_grid, sizeof(MULTI_DRAW_NINE_GRID_ORDER));\n\tZeroMemory(&primary->line_to, sizeof(LINE_TO_ORDER));\n\tZeroMemory(&primary->polyline, sizeof(POLYLINE_ORDER));\n\tZeroMemory(&primary->memblt, sizeof(MEMBLT_ORDER));\n\tZeroMemory(&primary->mem3blt, sizeof(MEM3BLT_ORDER));\n\tZeroMemory(&primary->save_bitmap, sizeof(SAVE_BITMAP_ORDER));\n\tZeroMemory(&primary->glyph_index, sizeof(GLYPH_INDEX_ORDER));\n\tZeroMemory(&primary->fast_index, sizeof(FAST_INDEX_ORDER));\n\tZeroMemory(&primary->fast_glyph, sizeof(FAST_GLYPH_ORDER));\n\tZeroMemory(&primary->polygon_sc, sizeof(POLYGON_SC_ORDER));\n\tZeroMemory(&primary->polygon_cb, sizeof(POLYGON_CB_ORDER));\n\tZeroMemory(&primary->ellipse_sc, sizeof(ELLIPSE_SC_ORDER));\n\tZeroMemory(&primary->ellipse_cb, sizeof(ELLIPSE_CB_ORDER));\n\tprimary->order_info.orderType = ORDER_TYPE_PATBLT;\n\n\tif (!update->initialState)\n\t{\n\t\taltsec->switch_surface.bitmapId = SCREEN_BITMAP_SURFACE;\n\t\tIFCALL(altsec->SwitchSurface, update->context, &(altsec->switch_surface));\n\t}\n}\n\nBOOL update_post_connect(rdpUpdate* update)\n{\n\tupdate->asynchronous = update->context->settings->AsyncUpdate;\n\n\tif (update->asynchronous)\n\t\tif (!(update->proxy = update_message_proxy_new(update)))\n\t\t\treturn FALSE;\n\n\tupdate->altsec->switch_surface.bitmapId = SCREEN_BITMAP_SURFACE;\n\tIFCALL(update->altsec->SwitchSurface, update->context, &(update->altsec->switch_surface));\n\tupdate->initialState = FALSE;\n\treturn TRUE;\n}\n\nvoid update_post_disconnect(rdpUpdate* update)\n{\n\tupdate->asynchronous = update->context->settings->AsyncUpdate;\n\n\tif (update->asynchronous)\n\t\tupdate_message_proxy_free(update->proxy);\n\n\tupdate->initialState = TRUE;\n}\n\nstatic BOOL _update_begin_paint(rdpContext* context)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\n\tif (update->us)\n\t{\n\t\tif (!update_end_paint(update))\n\t\t\treturn FALSE;\n\t}\n\n\ts = fastpath_update_pdu_init_new(context->rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_SealLength(s);\n\tStream_Seek(s, 2); /* numberOrders (2 bytes) */\n\tupdate->combineUpdates = TRUE;\n\tupdate->numberOrders = 0;\n\tupdate->us = s;\n\treturn TRUE;\n}\n\nstatic BOOL _update_end_paint(rdpContext* context)\n{\n\twStream* s;\n\tint headerLength;\n\trdpUpdate* update = context->update;\n\n\tif (!update->us)\n\t\treturn FALSE;\n\n\ts = update->us;\n\theaderLength = Stream_Length(s);\n\tStream_SealLength(s);\n\tStream_SetPosition(s, headerLength);\n\tStream_Write_UINT16(s, update->numberOrders); /* numberOrders (2 bytes) */\n\tStream_SetPosition(s, Stream_Length(s));\n\n\tif (update->numberOrders > 0)\n\t{\n\t\tWLog_DBG(TAG, \"sending %\" PRIu16 \" orders\", update->numberOrders);\n\t\tfastpath_send_update_pdu(context->rdp->fastpath, FASTPATH_UPDATETYPE_ORDERS, s, FALSE);\n\t}\n\n\tupdate->combineUpdates = FALSE;\n\tupdate->numberOrders = 0;\n\tupdate->us = NULL;\n\tStream_Free(s, TRUE);\n\treturn TRUE;\n}\n\nstatic void update_flush(rdpContext* context)\n{\n\trdpUpdate* update = context->update;\n\n\tif (update->numberOrders > 0)\n\t{\n\t\tupdate_end_paint(update);\n\t\tupdate_begin_paint(update);\n\t}\n}\n\nstatic void update_force_flush(rdpContext* context)\n{\n\tupdate_flush(context);\n}\n\nstatic BOOL update_check_flush(rdpContext* context, int size)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\ts = update->us;\n\n\tif (!update->us)\n\t{\n\t\tupdate_begin_paint(update);\n\t\treturn FALSE;\n\t}\n\n\tif (Stream_GetPosition(s) + size + 64 >= 0x3FFF)\n\t{\n\t\tupdate_flush(context);\n\t\treturn TRUE;\n\t}\n\n\treturn FALSE;\n}\n\nstatic BOOL update_set_bounds(rdpContext* context, const rdpBounds* bounds)\n{\n\trdpUpdate* update = context->update;\n\tCopyMemory(&update->previousBounds, &update->currentBounds, sizeof(rdpBounds));\n\n\tif (!bounds)\n\t\tZeroMemory(&update->currentBounds, sizeof(rdpBounds));\n\telse\n\t\tCopyMemory(&update->currentBounds, bounds, sizeof(rdpBounds));\n\n\treturn TRUE;\n}\n\nstatic BOOL update_bounds_is_null(rdpBounds* bounds)\n{\n\tif ((bounds->left == 0) && (bounds->top == 0) && (bounds->right == 0) && (bounds->bottom == 0))\n\t\treturn TRUE;\n\n\treturn FALSE;\n}\n\nstatic BOOL update_bounds_equals(rdpBounds* bounds1, rdpBounds* bounds2)\n{\n\tif ((bounds1->left == bounds2->left) && (bounds1->top == bounds2->top) &&\n\t    (bounds1->right == bounds2->right) && (bounds1->bottom == bounds2->bottom))\n\t\treturn TRUE;\n\n\treturn FALSE;\n}\n\nstatic int update_prepare_bounds(rdpContext* context, ORDER_INFO* orderInfo)\n{\n\tint length = 0;\n\trdpUpdate* update = context->update;\n\torderInfo->boundsFlags = 0;\n\n\tif (update_bounds_is_null(&update->currentBounds))\n\t\treturn 0;\n\n\torderInfo->controlFlags |= ORDER_BOUNDS;\n\n\tif (update_bounds_equals(&update->previousBounds, &update->currentBounds))\n\t{\n\t\torderInfo->controlFlags |= ORDER_ZERO_BOUNDS_DELTAS;\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tlength += 1;\n\n\t\tif (update->previousBounds.left != update->currentBounds.left)\n\t\t{\n\t\t\torderInfo->bounds.left = update->currentBounds.left;\n\t\t\torderInfo->boundsFlags |= BOUND_LEFT;\n\t\t\tlength += 2;\n\t\t}\n\n\t\tif (update->previousBounds.top != update->currentBounds.top)\n\t\t{\n\t\t\torderInfo->bounds.top = update->currentBounds.top;\n\t\t\torderInfo->boundsFlags |= BOUND_TOP;\n\t\t\tlength += 2;\n\t\t}\n\n\t\tif (update->previousBounds.right != update->currentBounds.right)\n\t\t{\n\t\t\torderInfo->bounds.right = update->currentBounds.right;\n\t\t\torderInfo->boundsFlags |= BOUND_RIGHT;\n\t\t\tlength += 2;\n\t\t}\n\n\t\tif (update->previousBounds.bottom != update->currentBounds.bottom)\n\t\t{\n\t\t\torderInfo->bounds.bottom = update->currentBounds.bottom;\n\t\t\torderInfo->boundsFlags |= BOUND_BOTTOM;\n\t\t\tlength += 2;\n\t\t}\n\t}\n\n\treturn length;\n}\n\nstatic int update_prepare_order_info(rdpContext* context, ORDER_INFO* orderInfo, UINT32 orderType)\n{\n\tint length = 1;\n\torderInfo->fieldFlags = 0;\n\torderInfo->orderType = orderType;\n\torderInfo->controlFlags = ORDER_STANDARD;\n\torderInfo->controlFlags |= ORDER_TYPE_CHANGE;\n\tlength += 1;\n\tlength += PRIMARY_DRAWING_ORDER_FIELD_BYTES[orderInfo->orderType];\n\tlength += update_prepare_bounds(context, orderInfo);\n\treturn length;\n}\n\nstatic int update_write_order_info(rdpContext* context, wStream* s, ORDER_INFO* orderInfo,\n                                   size_t offset)\n{\n\tsize_t position;\n\tWINPR_UNUSED(context);\n\tposition = Stream_GetPosition(s);\n\tStream_SetPosition(s, offset);\n\tStream_Write_UINT8(s, orderInfo->controlFlags); /* controlFlags (1 byte) */\n\n\tif (orderInfo->controlFlags & ORDER_TYPE_CHANGE)\n\t\tStream_Write_UINT8(s, orderInfo->orderType); /* orderType (1 byte) */\n\n\tupdate_write_field_flags(s, orderInfo->fieldFlags, orderInfo->controlFlags,\n\t                         PRIMARY_DRAWING_ORDER_FIELD_BYTES[orderInfo->orderType]);\n\tupdate_write_bounds(s, orderInfo);\n\tStream_SetPosition(s, position);\n\treturn 0;\n}\n\nstatic void update_write_refresh_rect(wStream* s, BYTE count, const RECTANGLE_16* areas)\n{\n\tint i;\n\tStream_Write_UINT8(s, count); /* numberOfAreas (1 byte) */\n\tStream_Seek(s, 3);            /* pad3Octets (3 bytes) */\n\n\tfor (i = 0; i < count; i++)\n\t{\n\t\tStream_Write_UINT16(s, areas[i].left);   /* left (2 bytes) */\n\t\tStream_Write_UINT16(s, areas[i].top);    /* top (2 bytes) */\n\t\tStream_Write_UINT16(s, areas[i].right);  /* right (2 bytes) */\n\t\tStream_Write_UINT16(s, areas[i].bottom); /* bottom (2 bytes) */\n\t}\n}\n\nstatic BOOL update_send_refresh_rect(rdpContext* context, BYTE count, const RECTANGLE_16* areas)\n{\n\trdpRdp* rdp = context->rdp;\n\n\tif (rdp->settings->RefreshRect)\n\t{\n\t\twStream* s = rdp_data_pdu_init(rdp);\n\n\t\tif (!s)\n\t\t\treturn FALSE;\n\n\t\tupdate_write_refresh_rect(s, count, areas);\n\t\treturn rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_REFRESH_RECT, rdp->mcs->userId);\n\t}\n\n\treturn TRUE;\n}\n\nstatic void update_write_suppress_output(wStream* s, BYTE allow, const RECTANGLE_16* area)\n{\n\tStream_Write_UINT8(s, allow); /* allowDisplayUpdates (1 byte) */\n\t/* Use zeros for padding (like mstsc) for compatibility with legacy servers */\n\tStream_Zero(s, 3); /* pad3Octets (3 bytes) */\n\n\tif (allow > 0)\n\t{\n\t\tStream_Write_UINT16(s, area->left);   /* left (2 bytes) */\n\t\tStream_Write_UINT16(s, area->top);    /* top (2 bytes) */\n\t\tStream_Write_UINT16(s, area->right);  /* right (2 bytes) */\n\t\tStream_Write_UINT16(s, area->bottom); /* bottom (2 bytes) */\n\t}\n}\n\nstatic BOOL update_send_suppress_output(rdpContext* context, BYTE allow, const RECTANGLE_16* area)\n{\n\trdpRdp* rdp = context->rdp;\n\n\tif (rdp->settings->SuppressOutput)\n\t{\n\t\twStream* s = rdp_data_pdu_init(rdp);\n\n\t\tif (!s)\n\t\t\treturn FALSE;\n\n\t\tupdate_write_suppress_output(s, allow, area);\n\t\treturn rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_SUPPRESS_OUTPUT, rdp->mcs->userId);\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL update_send_surface_command(rdpContext* context, wStream* s)\n{\n\twStream* update;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret;\n\tupdate = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!update)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(update, Stream_GetPosition(s)))\n\t{\n\t\tret = FALSE;\n\t\tgoto out;\n\t}\n\n\tStream_Write(update, Stream_Buffer(s), Stream_GetPosition(s));\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_SURFCMDS, update, FALSE);\nout:\n\tStream_Release(update);\n\treturn ret;\n}\n\nstatic BOOL update_send_surface_bits(rdpContext* context,\n                                     const SURFACE_BITS_COMMAND* surfaceBitsCommand)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\tupdate_force_flush(context);\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!update_write_surfcmd_surface_bits(s, surfaceBitsCommand))\n\t\tgoto out_fail;\n\n\tif (!fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_SURFCMDS, s,\n\t                              surfaceBitsCommand->skipCompression))\n\t\tgoto out_fail;\n\n\tupdate_force_flush(context);\n\tret = TRUE;\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_surface_frame_marker(rdpContext* context,\n                                             const SURFACE_FRAME_MARKER* surfaceFrameMarker)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\tupdate_force_flush(context);\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!update_write_surfcmd_frame_marker(s, surfaceFrameMarker->frameAction,\n\t                                       surfaceFrameMarker->frameId) ||\n\t    !fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_SURFCMDS, s, FALSE))\n\t\tgoto out_fail;\n\n\tupdate_force_flush(context);\n\tret = TRUE;\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_surface_frame_bits(rdpContext* context, const SURFACE_BITS_COMMAND* cmd,\n                                           BOOL first, BOOL last, UINT32 frameId)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\tupdate_force_flush(context);\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (first)\n\t{\n\t\tif (!update_write_surfcmd_frame_marker(s, SURFACECMD_FRAMEACTION_BEGIN, frameId))\n\t\t\tgoto out_fail;\n\t}\n\n\tif (!update_write_surfcmd_surface_bits(s, cmd))\n\t\tgoto out_fail;\n\n\tif (last)\n\t{\n\t\tif (!update_write_surfcmd_frame_marker(s, SURFACECMD_FRAMEACTION_END, frameId))\n\t\t\tgoto out_fail;\n\t}\n\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_SURFCMDS, s,\n\t                               cmd->skipCompression);\n\tupdate_force_flush(context);\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_frame_acknowledge(rdpContext* context, UINT32 frameId)\n{\n\trdpRdp* rdp = context->rdp;\n\n\tif (rdp->settings->ReceivedCapabilities[CAPSET_TYPE_FRAME_ACKNOWLEDGE])\n\t{\n\t\twStream* s = rdp_data_pdu_init(rdp);\n\n\t\tif (!s)\n\t\t\treturn FALSE;\n\n\t\tStream_Write_UINT32(s, frameId);\n\t\treturn rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_FRAME_ACKNOWLEDGE, rdp->mcs->userId);\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL update_send_synchronize(rdpContext* context)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_Zero(s, 2); /* pad2Octets (2 bytes) */\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_SYNCHRONIZE, s, FALSE);\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_desktop_resize(rdpContext* context)\n{\n\treturn rdp_server_reactivate(context->rdp);\n}\n\nstatic BOOL update_send_bitmap_update(rdpContext* context, const BITMAP_UPDATE* bitmapUpdate)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\trdpUpdate* update = context->update;\n\tBOOL ret = TRUE;\n\tupdate_force_flush(context);\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!update_write_bitmap_update(update, s, bitmapUpdate) ||\n\t    !fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_BITMAP, s,\n\t                              bitmapUpdate->skipCompression))\n\t{\n\t\tret = FALSE;\n\t\tgoto out_fail;\n\t}\n\n\tupdate_force_flush(context);\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_play_sound(rdpContext* context, const PLAY_SOUND_UPDATE* play_sound)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\n\tif (!rdp->settings->ReceivedCapabilities[CAPSET_TYPE_SOUND])\n\t{\n\t\treturn TRUE;\n\t}\n\n\ts = rdp_data_pdu_init(rdp);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_Write_UINT32(s, play_sound->duration);\n\tStream_Write_UINT32(s, play_sound->frequency);\n\treturn rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_PLAY_SOUND, rdp->mcs->userId);\n}\n\n/**\n * Primary Drawing Orders\n */\n\nstatic BOOL update_send_dstblt(rdpContext* context, const DSTBLT_ORDER* dstblt)\n{\n\twStream* s;\n\tUINT32 offset;\n\tUINT32 headerLength;\n\tORDER_INFO orderInfo;\n\tint inf;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo, ORDER_TYPE_DSTBLT);\n\tinf = update_approximate_dstblt_order(&orderInfo, dstblt);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_dstblt_order(s, &orderInfo, dstblt))\n\t\treturn FALSE;\n\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_patblt(rdpContext* context, PATBLT_ORDER* patblt)\n{\n\twStream* s;\n\tsize_t offset;\n\tint headerLength;\n\tORDER_INFO orderInfo;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo, ORDER_TYPE_PATBLT);\n\tupdate_check_flush(context, headerLength + update_approximate_patblt_order(&orderInfo, patblt));\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\tupdate_write_patblt_order(s, &orderInfo, patblt);\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_scrblt(rdpContext* context, const SCRBLT_ORDER* scrblt)\n{\n\twStream* s;\n\tUINT32 offset;\n\tUINT32 headerLength;\n\tORDER_INFO orderInfo;\n\tint inf;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo, ORDER_TYPE_SCRBLT);\n\tinf = update_approximate_scrblt_order(&orderInfo, scrblt);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn TRUE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\tupdate_write_scrblt_order(s, &orderInfo, scrblt);\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_opaque_rect(rdpContext* context, const OPAQUE_RECT_ORDER* opaque_rect)\n{\n\twStream* s;\n\tsize_t offset;\n\tint headerLength;\n\tORDER_INFO orderInfo;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo, ORDER_TYPE_OPAQUE_RECT);\n\tupdate_check_flush(context, headerLength +\n\t                                update_approximate_opaque_rect_order(&orderInfo, opaque_rect));\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\tupdate_write_opaque_rect_order(s, &orderInfo, opaque_rect);\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_line_to(rdpContext* context, const LINE_TO_ORDER* line_to)\n{\n\twStream* s;\n\tint offset;\n\tint headerLength;\n\tORDER_INFO orderInfo;\n\tint inf;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo, ORDER_TYPE_LINE_TO);\n\tinf = update_approximate_line_to_order(&orderInfo, line_to);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\tupdate_write_line_to_order(s, &orderInfo, line_to);\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_memblt(rdpContext* context, MEMBLT_ORDER* memblt)\n{\n\twStream* s;\n\tsize_t offset;\n\tint headerLength;\n\tORDER_INFO orderInfo;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo, ORDER_TYPE_MEMBLT);\n\tupdate_check_flush(context, headerLength + update_approximate_memblt_order(&orderInfo, memblt));\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\tupdate_write_memblt_order(s, &orderInfo, memblt);\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_glyph_index(rdpContext* context, GLYPH_INDEX_ORDER* glyph_index)\n{\n\twStream* s;\n\tsize_t offset;\n\tint headerLength;\n\tint inf;\n\tORDER_INFO orderInfo;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo, ORDER_TYPE_GLYPH_INDEX);\n\tinf = update_approximate_glyph_index_order(&orderInfo, glyph_index);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\tupdate_write_glyph_index_order(s, &orderInfo, glyph_index);\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\n/*\n * Secondary Drawing Orders\n */\n\nstatic BOOL update_send_cache_bitmap(rdpContext* context, const CACHE_BITMAP_ORDER* cache_bitmap)\n{\n\twStream* s;\n\tsize_t bm, em;\n\tBYTE orderType;\n\tint headerLength;\n\tint inf;\n\tUINT16 extraFlags;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\textraFlags = 0;\n\theaderLength = 6;\n\torderType = cache_bitmap->compressed ? ORDER_TYPE_CACHE_BITMAP_COMPRESSED\n\t                                     : ORDER_TYPE_BITMAP_UNCOMPRESSED;\n\tinf =\n\t    update_approximate_cache_bitmap_order(cache_bitmap, cache_bitmap->compressed, &extraFlags);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_bitmap_order(s, cache_bitmap, cache_bitmap->compressed, &extraFlags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD | ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength);                     /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, extraFlags);                      /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, orderType);                        /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_cache_bitmap_v2(rdpContext* context, CACHE_BITMAP_V2_ORDER* cache_bitmap_v2)\n{\n\twStream* s;\n\tsize_t bm, em;\n\tBYTE orderType;\n\tint headerLength;\n\tUINT16 extraFlags;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\textraFlags = 0;\n\theaderLength = 6;\n\torderType = cache_bitmap_v2->compressed ? ORDER_TYPE_BITMAP_COMPRESSED_V2\n\t                                        : ORDER_TYPE_BITMAP_UNCOMPRESSED_V2;\n\n\tif (context->settings->NoBitmapCompressionHeader)\n\t\tcache_bitmap_v2->flags |= CBR2_NO_BITMAP_COMPRESSION_HDR;\n\n\tupdate_check_flush(context, headerLength +\n\t                                update_approximate_cache_bitmap_v2_order(\n\t                                    cache_bitmap_v2, cache_bitmap_v2->compressed, &extraFlags));\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_bitmap_v2_order(s, cache_bitmap_v2, cache_bitmap_v2->compressed,\n\t                                        &extraFlags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD | ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength);                     /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, extraFlags);                      /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, orderType);                        /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_cache_bitmap_v3(rdpContext* context, CACHE_BITMAP_V3_ORDER* cache_bitmap_v3)\n{\n\twStream* s;\n\tsize_t bm, em;\n\tBYTE orderType;\n\tint headerLength;\n\tUINT16 extraFlags;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\textraFlags = 0;\n\theaderLength = 6;\n\torderType = ORDER_TYPE_BITMAP_COMPRESSED_V3;\n\tupdate_check_flush(context, headerLength + update_approximate_cache_bitmap_v3_order(\n\t                                               cache_bitmap_v3, &extraFlags));\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_bitmap_v3_order(s, cache_bitmap_v3, &extraFlags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD | ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength);                     /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, extraFlags);                      /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, orderType);                        /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_cache_color_table(rdpContext* context,\n                                          const CACHE_COLOR_TABLE_ORDER* cache_color_table)\n{\n\twStream* s;\n\tUINT16 flags;\n\tsize_t bm, em, inf;\n\tint headerLength;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\tflags = 0;\n\theaderLength = 6;\n\tinf = update_approximate_cache_color_table_order(cache_color_table, &flags);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_color_table_order(s, cache_color_table, &flags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD | ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength);                     /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, flags);                           /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, ORDER_TYPE_CACHE_COLOR_TABLE);     /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_cache_glyph(rdpContext* context, const CACHE_GLYPH_ORDER* cache_glyph)\n{\n\twStream* s;\n\tUINT16 flags;\n\tsize_t bm, em, inf;\n\tint headerLength;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\tflags = 0;\n\theaderLength = 6;\n\tinf = update_approximate_cache_glyph_order(cache_glyph, &flags);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_glyph_order(s, cache_glyph, &flags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD | ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength);                     /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, flags);                           /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, ORDER_TYPE_CACHE_GLYPH);           /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_cache_glyph_v2(rdpContext* context,\n                                       const CACHE_GLYPH_V2_ORDER* cache_glyph_v2)\n{\n\twStream* s;\n\tUINT16 flags;\n\tsize_t bm, em, inf;\n\tint headerLength;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\tflags = 0;\n\theaderLength = 6;\n\tinf = update_approximate_cache_glyph_v2_order(cache_glyph_v2, &flags);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_glyph_v2_order(s, cache_glyph_v2, &flags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD | ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength);                     /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, flags);                           /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, ORDER_TYPE_CACHE_GLYPH);           /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_cache_brush(rdpContext* context, const CACHE_BRUSH_ORDER* cache_brush)\n{\n\twStream* s;\n\tUINT16 flags;\n\tsize_t bm, em, inf;\n\tint headerLength;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\tflags = 0;\n\theaderLength = 6;\n\tinf = update_approximate_cache_brush_order(cache_brush, &flags);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_brush_order(s, cache_brush, &flags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD | ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength);                     /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, flags);                           /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, ORDER_TYPE_CACHE_BRUSH);           /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\n/**\n * Alternate Secondary Drawing Orders\n */\n\nstatic BOOL update_send_create_offscreen_bitmap_order(\n    rdpContext* context, const CREATE_OFFSCREEN_BITMAP_ORDER* create_offscreen_bitmap)\n{\n\twStream* s;\n\tsize_t bm, em, inf;\n\tBYTE orderType;\n\tBYTE controlFlags;\n\tint headerLength;\n\trdpUpdate* update = context->update;\n\theaderLength = 1;\n\torderType = ORDER_TYPE_CREATE_OFFSCREEN_BITMAP;\n\tcontrolFlags = ORDER_SECONDARY | (orderType << 2);\n\tinf = update_approximate_create_offscreen_bitmap_order(create_offscreen_bitmap);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_create_offscreen_bitmap_order(s, create_offscreen_bitmap))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, controlFlags); /* controlFlags (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_switch_surface_order(rdpContext* context,\n                                             const SWITCH_SURFACE_ORDER* switch_surface)\n{\n\twStream* s;\n\tsize_t bm, em, inf;\n\tBYTE orderType;\n\tBYTE controlFlags;\n\tint headerLength;\n\trdpUpdate* update;\n\n\tif (!context || !switch_surface || !context->update)\n\t\treturn FALSE;\n\n\tupdate = context->update;\n\theaderLength = 1;\n\torderType = ORDER_TYPE_SWITCH_SURFACE;\n\tcontrolFlags = ORDER_SECONDARY | (orderType << 2);\n\tinf = update_approximate_switch_surface_order(switch_surface);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_switch_surface_order(s, switch_surface))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, controlFlags); /* controlFlags (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_pointer_system(rdpContext* context,\n                                       const POINTER_SYSTEM_UPDATE* pointer_system)\n{\n\twStream* s;\n\tBYTE updateCode;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (pointer_system->type == SYSPTR_NULL)\n\t\tupdateCode = FASTPATH_UPDATETYPE_PTR_NULL;\n\telse\n\t\tupdateCode = FASTPATH_UPDATETYPE_PTR_DEFAULT;\n\n\tret = fastpath_send_update_pdu(rdp->fastpath, updateCode, s, FALSE);\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_pointer_position(rdpContext* context,\n                                         const POINTER_POSITION_UPDATE* pointerPosition)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 16))\n\t\tgoto out_fail;\n\n\tStream_Write_UINT16(s, pointerPosition->xPos); /* xPos (2 bytes) */\n\tStream_Write_UINT16(s, pointerPosition->yPos); /* yPos (2 bytes) */\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_PTR_POSITION, s, FALSE);\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_write_pointer_color(wStream* s, const POINTER_COLOR_UPDATE* pointer_color)\n{\n\tif (!Stream_EnsureRemainingCapacity(s, 32 + pointer_color->lengthAndMask +\n\t                                           pointer_color->lengthXorMask))\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, pointer_color->cacheIndex);\n\tStream_Write_UINT16(s, pointer_color->xPos);\n\tStream_Write_UINT16(s, pointer_color->yPos);\n\tStream_Write_UINT16(s, pointer_color->width);\n\tStream_Write_UINT16(s, pointer_color->height);\n\tStream_Write_UINT16(s, pointer_color->lengthAndMask);\n\tStream_Write_UINT16(s, pointer_color->lengthXorMask);\n\n\tif (pointer_color->lengthXorMask > 0)\n\t\tStream_Write(s, pointer_color->xorMaskData, pointer_color->lengthXorMask);\n\n\tif (pointer_color->lengthAndMask > 0)\n\t\tStream_Write(s, pointer_color->andMaskData, pointer_color->lengthAndMask);\n\n\tStream_Write_UINT8(s, 0); /* pad (1 byte) */\n\treturn TRUE;\n}\n\nstatic BOOL update_send_pointer_color(rdpContext* context,\n                                      const POINTER_COLOR_UPDATE* pointer_color)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!update_write_pointer_color(s, pointer_color))\n\t\tgoto out_fail;\n\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_COLOR, s, FALSE);\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_write_pointer_large(wStream* s, const POINTER_LARGE_UPDATE* pointer)\n{\n\tif (!Stream_EnsureRemainingCapacity(s, 32 + pointer->lengthAndMask + pointer->lengthXorMask))\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, pointer->xorBpp);\n\tStream_Write_UINT16(s, pointer->cacheIndex);\n\tStream_Write_UINT16(s, pointer->hotSpotX);\n\tStream_Write_UINT16(s, pointer->hotSpotY);\n\tStream_Write_UINT16(s, pointer->width);\n\tStream_Write_UINT16(s, pointer->height);\n\tStream_Write_UINT32(s, pointer->lengthAndMask);\n\tStream_Write_UINT32(s, pointer->lengthXorMask);\n\tStream_Write(s, pointer->xorMaskData, pointer->lengthXorMask);\n\tStream_Write(s, pointer->andMaskData, pointer->lengthAndMask);\n\tStream_Write_UINT8(s, 0); /* pad (1 byte) */\n\treturn TRUE;\n}\n\nstatic BOOL update_send_pointer_large(rdpContext* context, const POINTER_LARGE_UPDATE* pointer)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!update_write_pointer_large(s, pointer))\n\t\tgoto out_fail;\n\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_LARGE_POINTER, s, FALSE);\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_pointer_new(rdpContext* context, const POINTER_NEW_UPDATE* pointer_new)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 16))\n\t\tgoto out_fail;\n\n\tStream_Write_UINT16(s, pointer_new->xorBpp); /* xorBpp (2 bytes) */\n\tupdate_write_pointer_color(s, &pointer_new->colorPtrAttr);\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_POINTER, s, FALSE);\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_pointer_cached(rdpContext* context,\n                                       const POINTER_CACHED_UPDATE* pointer_cached)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, pointer_cached->cacheIndex); /* cacheIndex (2 bytes) */\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_CACHED, s, FALSE);\n\tStream_Release(s);\n\treturn ret;\n}\n\nBOOL update_read_refresh_rect(rdpUpdate* update, wStream* s)\n{\n\tint index;\n\tBYTE numberOfAreas;\n\tRECTANGLE_16* areas;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, numberOfAreas);\n\tStream_Seek(s, 3); /* pad3Octects */\n\n\tif (Stream_GetRemainingLength(s) < ((size_t)numberOfAreas * 4 * 2))\n\t\treturn FALSE;\n\n\tareas = (RECTANGLE_16*)calloc(numberOfAreas, sizeof(RECTANGLE_16));\n\n\tif (!areas)\n\t\treturn FALSE;\n\n\tfor (index = 0; index < numberOfAreas; index++)\n\t{\n\t\tStream_Read_UINT16(s, areas[index].left);\n\t\tStream_Read_UINT16(s, areas[index].top);\n\t\tStream_Read_UINT16(s, areas[index].right);\n\t\tStream_Read_UINT16(s, areas[index].bottom);\n\t}\n\n\tif (update->context->settings->RefreshRect)\n\t\tIFCALL(update->RefreshRect, update->context, numberOfAreas, areas);\n\telse\n\t\tWLog_Print(update->log, WLOG_WARN, \"ignoring refresh rect request from client\");\n\n\tfree(areas);\n\treturn TRUE;\n}\n\nBOOL update_read_suppress_output(rdpUpdate* update, wStream* s)\n{\n\tRECTANGLE_16* prect = NULL;\n\tRECTANGLE_16 rect = { 0 };\n\tBYTE allowDisplayUpdates;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, allowDisplayUpdates);\n\tStream_Seek(s, 3); /* pad3Octects */\n\n\tif (allowDisplayUpdates > 0)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < sizeof(RECTANGLE_16))\n\t\t\treturn FALSE;\n\t\tStream_Read_UINT16(s, rect.left);\n\t\tStream_Read_UINT16(s, rect.top);\n\t\tStream_Read_UINT16(s, rect.right);\n\t\tStream_Read_UINT16(s, rect.bottom);\n\n\t\tprect = &rect;\n\t}\n\n\tif (update->context->settings->SuppressOutput)\n\t\tIFCALL(update->SuppressOutput, update->context, allowDisplayUpdates, prect);\n\telse\n\t\tWLog_Print(update->log, WLOG_WARN, \"ignoring suppress output request from client\");\n\n\treturn TRUE;\n}\n\nstatic BOOL update_send_set_keyboard_indicators(rdpContext* context, UINT16 led_flags)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\ts = rdp_data_pdu_init(rdp);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, 0);         /* unitId should be 0 according to MS-RDPBCGR 2.2.8.2.1.1 */\n\tStream_Write_UINT16(s, led_flags); /* ledFlags (2 bytes) */\n\treturn rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_SET_KEYBOARD_INDICATORS, rdp->mcs->userId);\n}\n\nstatic BOOL update_send_set_keyboard_ime_status(rdpContext* context, UINT16 imeId, UINT32 imeState,\n                                                UINT32 imeConvMode)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\ts = rdp_data_pdu_init(rdp);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\t/* unitId should be 0 according to MS-RDPBCGR 2.2.8.2.2.1 */\n\tStream_Write_UINT16(s, imeId);\n\tStream_Write_UINT32(s, imeState);\n\tStream_Write_UINT32(s, imeConvMode);\n\treturn rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_SET_KEYBOARD_IME_STATUS, rdp->mcs->userId);\n}\n\nstatic UINT16 update_calculate_new_or_existing_window(const WINDOW_ORDER_INFO* orderInfo,\n                                                      const WINDOW_STATE_ORDER* stateOrder)\n{\n\tUINT16 orderSize = 11;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_OWNER) != 0)\n\t\torderSize += 4;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_STYLE) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_SHOW) != 0)\n\t\torderSize += 1;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_TITLE) != 0)\n\t\torderSize += 2 + stateOrder->titleInfo.length;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_CLIENT_AREA_OFFSET) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_CLIENT_AREA_SIZE) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RESIZE_MARGIN_X) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RESIZE_MARGIN_Y) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RP_CONTENT) != 0)\n\t\torderSize += 1;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_ROOT_PARENT) != 0)\n\t\torderSize += 4;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_OFFSET) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_CLIENT_DELTA) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_SIZE) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_RECTS) != 0)\n\t\torderSize += 2 + stateOrder->numWindowRects * sizeof(RECTANGLE_16);\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_VIS_OFFSET) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_VISIBILITY) != 0)\n\t\torderSize += 2 + stateOrder->numVisibilityRects * sizeof(RECTANGLE_16);\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_OVERLAY_DESCRIPTION) != 0)\n\t\torderSize += 2 + stateOrder->OverlayDescription.length;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_TASKBAR_BUTTON) != 0)\n\t\torderSize += 1;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_ENFORCE_SERVER_ZORDER) != 0)\n\t\torderSize += 1;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_APPBAR_STATE) != 0)\n\t\torderSize += 1;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_APPBAR_EDGE) != 0)\n\t\torderSize += 1;\n\n\treturn orderSize;\n}\n\nstatic BOOL update_send_new_or_existing_window(rdpContext* context,\n                                               const WINDOW_ORDER_INFO* orderInfo,\n                                               const WINDOW_STATE_ORDER* stateOrder)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\tBYTE controlFlags = ORDER_SECONDARY | (ORDER_TYPE_WINDOW << 2);\n\tUINT16 orderSize = update_calculate_new_or_existing_window(orderInfo, stateOrder);\n\n\tupdate_check_flush(context, orderSize);\n\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s, orderSize))\n\t\treturn FALSE;\n\n\tStream_Write_UINT8(s, controlFlags);           /* Header (1 byte) */\n\tStream_Write_UINT16(s, orderSize);             /* OrderSize (2 bytes) */\n\tStream_Write_UINT32(s, orderInfo->fieldFlags); /* FieldsPresentFlags (4 bytes) */\n\tStream_Write_UINT32(s, orderInfo->windowId);   /* WindowID (4 bytes) */\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_OWNER) != 0)\n\t\tStream_Write_UINT32(s, stateOrder->ownerWindowId);\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_STYLE) != 0)\n\t{\n\t\tStream_Write_UINT32(s, stateOrder->style);\n\t\tStream_Write_UINT32(s, stateOrder->extendedStyle);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_SHOW) != 0)\n\t{\n\t\tStream_Write_UINT8(s, stateOrder->showState);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_TITLE) != 0)\n\t{\n\t\tStream_Write_UINT16(s, stateOrder->titleInfo.length);\n\t\tStream_Write(s, stateOrder->titleInfo.string, stateOrder->titleInfo.length);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_CLIENT_AREA_OFFSET) != 0)\n\t{\n\t\tStream_Write_INT32(s, stateOrder->clientOffsetX);\n\t\tStream_Write_INT32(s, stateOrder->clientOffsetY);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_CLIENT_AREA_SIZE) != 0)\n\t{\n\t\tStream_Write_UINT32(s, stateOrder->clientAreaWidth);\n\t\tStream_Write_UINT32(s, stateOrder->clientAreaHeight);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RESIZE_MARGIN_X) != 0)\n\t{\n\t\tStream_Write_UINT32(s, stateOrder->resizeMarginLeft);\n\t\tStream_Write_UINT32(s, stateOrder->resizeMarginRight);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RESIZE_MARGIN_Y) != 0)\n\t{\n\t\tStream_Write_UINT32(s, stateOrder->resizeMarginTop);\n\t\tStream_Write_UINT32(s, stateOrder->resizeMarginBottom);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RP_CONTENT) != 0)\n\t{\n\t\tStream_Write_UINT8(s, stateOrder->RPContent);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_ROOT_PARENT) != 0)\n\t{\n\t\tStream_Write_UINT32(s, stateOrder->rootParentHandle);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_OFFSET) != 0)\n\t{\n\t\tStream_Write_INT32(s, stateOrder->windowOffsetX);\n\t\tStream_Write_INT32(s, stateOrder->windowOffsetY);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_CLIENT_DELTA) != 0)\n\t{\n\t\tStream_Write_INT32(s, stateOrder->windowClientDeltaX);\n\t\tStream_Write_INT32(s, stateOrder->windowClientDeltaY);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_SIZE) != 0)\n\t{\n\t\tStream_Write_UINT32(s, stateOrder->windowWidth);\n\t\tStream_Write_UINT32(s, stateOrder->windowHeight);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_RECTS) != 0)\n\t{\n\t\tStream_Write_UINT16(s, stateOrder->numWindowRects);\n\t\tStream_Write(s, stateOrder->windowRects, stateOrder->numWindowRects * sizeof(RECTANGLE_16));\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_VIS_OFFSET) != 0)\n\t{\n\t\tStream_Write_UINT32(s, stateOrder->visibleOffsetX);\n\t\tStream_Write_UINT32(s, stateOrder->visibleOffsetY);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_VISIBILITY) != 0)\n\t{\n\t\tStream_Write_UINT16(s, stateOrder->numVisibilityRects);\n\t\tStream_Write(s, stateOrder->visibilityRects,\n\t\t             stateOrder->numVisibilityRects * sizeof(RECTANGLE_16));\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_OVERLAY_DESCRIPTION) != 0)\n\t{\n\t\tStream_Write_UINT16(s, stateOrder->OverlayDescription.length);\n\t\tStream_Write(s, stateOrder->OverlayDescription.string,\n\t\t             stateOrder->OverlayDescription.length);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_TASKBAR_BUTTON) != 0)\n\t{\n\t\tStream_Write_UINT8(s, stateOrder->TaskbarButton);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_ENFORCE_SERVER_ZORDER) != 0)\n\t{\n\t\tStream_Write_UINT8(s, stateOrder->EnforceServerZOrder);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_APPBAR_STATE) != 0)\n\t{\n\t\tStream_Write_UINT8(s, stateOrder->AppBarState);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_APPBAR_EDGE) != 0)\n\t{\n\t\tStream_Write_UINT8(s, stateOrder->AppBarEdge);\n\t}\n\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_window_create(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,\n                                      const WINDOW_STATE_ORDER* stateOrder)\n{\n\treturn update_send_new_or_existing_window(context, orderInfo, stateOrder);\n}\n\nstatic BOOL update_send_window_update(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,\n                                      const WINDOW_STATE_ORDER* stateOrder)\n{\n\treturn update_send_new_or_existing_window(context, orderInfo, stateOrder);\n}\n\nstatic UINT16 update_calculate_window_icon_order(const WINDOW_ORDER_INFO* orderInfo,\n                                                 const WINDOW_ICON_ORDER* iconOrder)\n{\n\tUINT16 orderSize = 23;\n\tICON_INFO* iconInfo = iconOrder->iconInfo;\n\n\torderSize += iconInfo->cbBitsColor + iconInfo->cbBitsMask;\n\n\tif (iconInfo->bpp <= 8)\n\t\torderSize += 2 + iconInfo->cbColorTable;\n\n\treturn orderSize;\n}\n\nstatic BOOL update_send_window_icon(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,\n                                    const WINDOW_ICON_ORDER* iconOrder)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\tBYTE controlFlags = ORDER_SECONDARY | (ORDER_TYPE_WINDOW << 2);\n\tICON_INFO* iconInfo = iconOrder->iconInfo;\n\tUINT16 orderSize = update_calculate_window_icon_order(orderInfo, iconOrder);\n\n\tupdate_check_flush(context, orderSize);\n\n\ts = update->us;\n\n\tif (!s || !iconInfo)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s, orderSize))\n\t\treturn FALSE;\n\n\t/* Write Hdr */\n\tStream_Write_UINT8(s, controlFlags);           /* Header (1 byte) */\n\tStream_Write_UINT16(s, orderSize);             /* OrderSize (2 bytes) */\n\tStream_Write_UINT32(s, orderInfo->fieldFlags); /* FieldsPresentFlags (4 bytes) */\n\tStream_Write_UINT32(s, orderInfo->windowId);   /* WindowID (4 bytes) */\n\t/* Write body */\n\tStream_Write_UINT16(s, iconInfo->cacheEntry); /* CacheEntry (2 bytes) */\n\tStream_Write_UINT8(s, iconInfo->cacheId);     /* CacheId (1 byte) */\n\tStream_Write_UINT8(s, iconInfo->bpp);         /* Bpp (1 byte) */\n\tStream_Write_UINT16(s, iconInfo->width);      /* Width (2 bytes) */\n\tStream_Write_UINT16(s, iconInfo->height);     /* Height (2 bytes) */\n\n\tif (iconInfo->bpp <= 8)\n\t{\n\t\tStream_Write_UINT16(s, iconInfo->cbColorTable); /* CbColorTable (2 bytes) */\n\t}\n\n\tStream_Write_UINT16(s, iconInfo->cbBitsMask);              /* CbBitsMask (2 bytes) */\n\tStream_Write_UINT16(s, iconInfo->cbBitsColor);             /* CbBitsColor (2 bytes) */\n\tStream_Write(s, iconInfo->bitsMask, iconInfo->cbBitsMask); /* BitsMask (variable) */\n\n\tif (iconInfo->bpp <= 8)\n\t{\n\t\tStream_Write(s, iconInfo->colorTable, iconInfo->cbColorTable); /* ColorTable (variable) */\n\t}\n\n\tStream_Write(s, iconInfo->bitsColor, iconInfo->cbBitsColor); /* BitsColor (variable) */\n\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_window_cached_icon(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,\n                                           const WINDOW_CACHED_ICON_ORDER* cachedIconOrder)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\tBYTE controlFlags = ORDER_SECONDARY | (ORDER_TYPE_WINDOW << 2);\n\tUINT16 orderSize = 14;\n\tCACHED_ICON_INFO cachedIcon = cachedIconOrder->cachedIcon;\n\n\tupdate_check_flush(context, orderSize);\n\n\ts = update->us;\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s, orderSize))\n\t\treturn FALSE;\n\n\t/* Write Hdr */\n\tStream_Write_UINT8(s, controlFlags);           /* Header (1 byte) */\n\tStream_Write_UINT16(s, orderSize);             /* OrderSize (2 bytes) */\n\tStream_Write_UINT32(s, orderInfo->fieldFlags); /* FieldsPresentFlags (4 bytes) */\n\tStream_Write_UINT32(s, orderInfo->windowId);   /* WindowID (4 bytes) */\n\t/* Write body */\n\tStream_Write_UINT16(s, cachedIcon.cacheEntry); /* CacheEntry (2 bytes) */\n\tStream_Write_UINT8(s, cachedIcon.cacheId);     /* CacheId (1 byte) */\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_window_delete(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\tBYTE controlFlags = ORDER_SECONDARY | (ORDER_TYPE_WINDOW << 2);\n\tUINT16 orderSize = 11;\n\tupdate_check_flush(context, orderSize);\n\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s, orderSize))\n\t\treturn FALSE;\n\n\t/* Write Hdr */\n\tStream_Write_UINT8(s, controlFlags);           /* Header (1 byte) */\n\tStream_Write_UINT16(s, orderSize);             /* OrderSize (2 bytes) */\n\tStream_Write_UINT32(s, orderInfo->fieldFlags); /* FieldsPresentFlags (4 bytes) */\n\tStream_Write_UINT32(s, orderInfo->windowId);   /* WindowID (4 bytes) */\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic UINT16 update_calculate_new_or_existing_notification_icons_order(\n    const WINDOW_ORDER_INFO* orderInfo, const NOTIFY_ICON_STATE_ORDER* iconStateOrder)\n{\n\tUINT16 orderSize = 15;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_VERSION) != 0)\n\t\torderSize += 4;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_TIP) != 0)\n\t{\n\t\torderSize += 2 + iconStateOrder->toolTip.length;\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_INFO_TIP) != 0)\n\t{\n\t\tNOTIFY_ICON_INFOTIP infoTip = iconStateOrder->infoTip;\n\t\torderSize += 12 + infoTip.text.length + infoTip.title.length;\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_STATE) != 0)\n\t{\n\t\torderSize += 4;\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_ICON) != 0)\n\t{\n\t\tICON_INFO iconInfo = iconStateOrder->icon;\n\t\torderSize += 12;\n\n\t\tif (iconInfo.bpp <= 8)\n\t\t\torderSize += 2 + iconInfo.cbColorTable;\n\n\t\torderSize += iconInfo.cbBitsMask + iconInfo.cbBitsColor;\n\t}\n\telse if ((orderInfo->fieldFlags & WINDOW_ORDER_CACHED_ICON) != 0)\n\t{\n\t\torderSize += 3;\n\t}\n\n\treturn orderSize;\n}\n\nstatic BOOL\nupdate_send_new_or_existing_notification_icons(rdpContext* context,\n                                               const WINDOW_ORDER_INFO* orderInfo,\n                                               const NOTIFY_ICON_STATE_ORDER* iconStateOrder)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\tBYTE controlFlags = ORDER_SECONDARY | (ORDER_TYPE_WINDOW << 2);\n\tBOOL versionFieldPresent = FALSE;\n\tUINT16 orderSize =\n\t    update_calculate_new_or_existing_notification_icons_order(orderInfo, iconStateOrder);\n\n\tupdate_check_flush(context, orderSize);\n\n\ts = update->us;\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s, orderSize))\n\t\treturn FALSE;\n\n\t/* Write Hdr */\n\tStream_Write_UINT8(s, controlFlags);             /* Header (1 byte) */\n\tStream_Write_INT16(s, orderSize);                /* OrderSize (2 bytes) */\n\tStream_Write_UINT32(s, orderInfo->fieldFlags);   /* FieldsPresentFlags (4 bytes) */\n\tStream_Write_UINT32(s, orderInfo->windowId);     /* WindowID (4 bytes) */\n\tStream_Write_UINT32(s, orderInfo->notifyIconId); /* NotifyIconId (4 bytes) */\n\n\t/* Write body */\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_VERSION) != 0)\n\t{\n\t\tversionFieldPresent = TRUE;\n\t\tStream_Write_UINT32(s, iconStateOrder->version);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_TIP) != 0)\n\t{\n\t\tStream_Write_UINT16(s, iconStateOrder->toolTip.length);\n\t\tStream_Write(s, iconStateOrder->toolTip.string, iconStateOrder->toolTip.length);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_INFO_TIP) != 0)\n\t{\n\t\tNOTIFY_ICON_INFOTIP infoTip = iconStateOrder->infoTip;\n\n\t\t/* info tip should not be sent when version is 0 */\n\t\tif (versionFieldPresent && iconStateOrder->version == 0)\n\t\t\treturn FALSE;\n\n\t\tStream_Write_UINT32(s, infoTip.timeout);     /* Timeout (4 bytes) */\n\t\tStream_Write_UINT32(s, infoTip.flags);       /* InfoFlags (4 bytes) */\n\t\tStream_Write_UINT16(s, infoTip.text.length); /* InfoTipText (variable) */\n\t\tStream_Write(s, infoTip.text.string, infoTip.text.length);\n\t\tStream_Write_UINT16(s, infoTip.title.length); /* Title (variable) */\n\t\tStream_Write(s, infoTip.title.string, infoTip.title.length);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_STATE) != 0)\n\t{\n\t\t/* notify state should not be sent when version is 0 */\n\t\tif (versionFieldPresent && iconStateOrder->version == 0)\n\t\t\treturn FALSE;\n\n\t\tStream_Write_UINT32(s, iconStateOrder->state);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_ICON) != 0)\n\t{\n\t\tICON_INFO iconInfo = iconStateOrder->icon;\n\t\tStream_Write_UINT16(s, iconInfo.cacheEntry); /* CacheEntry (2 bytes) */\n\t\tStream_Write_UINT8(s, iconInfo.cacheId);     /* CacheId (1 byte) */\n\t\tStream_Write_UINT8(s, iconInfo.bpp);         /* Bpp (1 byte) */\n\t\tStream_Write_UINT16(s, iconInfo.width);      /* Width (2 bytes) */\n\t\tStream_Write_UINT16(s, iconInfo.height);     /* Height (2 bytes) */\n\n\t\tif (iconInfo.bpp <= 8)\n\t\t{\n\t\t\tStream_Write_UINT16(s, iconInfo.cbColorTable); /* CbColorTable (2 bytes) */\n\t\t}\n\n\t\tStream_Write_UINT16(s, iconInfo.cbBitsMask);             /* CbBitsMask (2 bytes) */\n\t\tStream_Write_UINT16(s, iconInfo.cbBitsColor);            /* CbBitsColor (2 bytes) */\n\t\tStream_Write(s, iconInfo.bitsMask, iconInfo.cbBitsMask); /* BitsMask (variable) */\n\t\torderSize += iconInfo.cbBitsMask;\n\n\t\tif (iconInfo.bpp <= 8)\n\t\t{\n\t\t\tStream_Write(s, iconInfo.colorTable, iconInfo.cbColorTable); /* ColorTable (variable) */\n\t\t}\n\n\t\tStream_Write(s, iconInfo.bitsColor, iconInfo.cbBitsColor); /* BitsColor (variable) */\n\t}\n\telse if ((orderInfo->fieldFlags & WINDOW_ORDER_CACHED_ICON) != 0)\n\t{\n\t\tCACHED_ICON_INFO cachedIcon = iconStateOrder->cachedIcon;\n\t\tStream_Write_UINT16(s, cachedIcon.cacheEntry); /* CacheEntry (2 bytes) */\n\t\tStream_Write_UINT8(s, cachedIcon.cacheId);     /* CacheId (1 byte) */\n\t}\n\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_notify_icon_create(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,\n                                           const NOTIFY_ICON_STATE_ORDER* iconStateOrder)\n{\n\treturn update_send_new_or_existing_notification_icons(context, orderInfo, iconStateOrder);\n}\n\nstatic BOOL update_send_notify_icon_update(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,\n                                           const NOTIFY_ICON_STATE_ORDER* iconStateOrder)\n{\n\treturn update_send_new_or_existing_notification_icons(context, orderInfo, iconStateOrder);\n}\n\nstatic BOOL update_send_notify_icon_delete(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\tBYTE controlFlags = ORDER_SECONDARY | (ORDER_TYPE_WINDOW << 2);\n\tUINT16 orderSize = 15;\n\tupdate_check_flush(context, orderSize);\n\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\t/* Write Hdr */\n\tStream_Write_UINT8(s, controlFlags);             /* Header (1 byte) */\n\tStream_Write_UINT16(s, orderSize);               /* OrderSize (2 bytes) */\n\tStream_Write_UINT32(s, orderInfo->fieldFlags);   /* FieldsPresentFlags (4 bytes) */\n\tStream_Write_UINT32(s, orderInfo->windowId);     /* WindowID (4 bytes) */\n\tStream_Write_UINT32(s, orderInfo->notifyIconId); /* NotifyIconId (4 bytes) */\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic UINT16 update_calculate_monitored_desktop(const WINDOW_ORDER_INFO* orderInfo,\n                                                 const MONITORED_DESKTOP_ORDER* monitoredDesktop)\n{\n\tUINT16 orderSize = 7;\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_DESKTOP_ACTIVE_WND)\n\t{\n\t\torderSize += 4;\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_DESKTOP_ZORDER)\n\t{\n\t\torderSize += 1 + (4 * monitoredDesktop->numWindowIds);\n\t}\n\n\treturn orderSize;\n}\n\nstatic BOOL update_send_monitored_desktop(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,\n                                          const MONITORED_DESKTOP_ORDER* monitoredDesktop)\n{\n\tUINT32 i;\n\twStream* s;\n\trdpUpdate* update = context->update;\n\tBYTE controlFlags = ORDER_SECONDARY | (ORDER_TYPE_WINDOW << 2);\n\tUINT16 orderSize = update_calculate_monitored_desktop(orderInfo, monitoredDesktop);\n\tupdate_check_flush(context, orderSize);\n\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_Write_UINT8(s, controlFlags);           /* Header (1 byte) */\n\tStream_Write_UINT16(s, orderSize);             /* OrderSize (2 bytes) */\n\tStream_Write_UINT32(s, orderInfo->fieldFlags); /* FieldsPresentFlags (4 bytes) */\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_DESKTOP_ACTIVE_WND)\n\t{\n\t\tStream_Write_UINT32(s, monitoredDesktop->activeWindowId); /* activeWindowId (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_DESKTOP_ZORDER)\n\t{\n\t\tStream_Write_UINT8(s, monitoredDesktop->numWindowIds); /* numWindowIds (1 byte) */\n\n\t\t/* windowIds */\n\t\tfor (i = 0; i < monitoredDesktop->numWindowIds; i++)\n\t\t{\n\t\t\tStream_Write_UINT32(s, monitoredDesktop->windowIds[i]);\n\t\t}\n\t}\n\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_non_monitored_desktop(rdpContext* context,\n                                              const WINDOW_ORDER_INFO* orderInfo)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\tBYTE controlFlags = ORDER_SECONDARY | (ORDER_TYPE_WINDOW << 2);\n\tUINT16 orderSize = 7;\n\tupdate_check_flush(context, orderSize);\n\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_Write_UINT8(s, controlFlags);           /* Header (1 byte) */\n\tStream_Write_UINT16(s, orderSize);             /* OrderSize (2 bytes) */\n\tStream_Write_UINT32(s, orderInfo->fieldFlags); /* FieldsPresentFlags (4 bytes) */\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nvoid update_register_server_callbacks(rdpUpdate* update)\n{\n\tupdate->BeginPaint = _update_begin_paint;\n\tupdate->EndPaint = _update_end_paint;\n\tupdate->SetBounds = update_set_bounds;\n\tupdate->Synchronize = update_send_synchronize;\n\tupdate->DesktopResize = update_send_desktop_resize;\n\tupdate->BitmapUpdate = update_send_bitmap_update;\n\tupdate->SurfaceBits = update_send_surface_bits;\n\tupdate->SurfaceFrameMarker = update_send_surface_frame_marker;\n\tupdate->SurfaceCommand = update_send_surface_command;\n\tupdate->SurfaceFrameBits = update_send_surface_frame_bits;\n\tupdate->PlaySound = update_send_play_sound;\n\tupdate->SetKeyboardIndicators = update_send_set_keyboard_indicators;\n\tupdate->SetKeyboardImeStatus = update_send_set_keyboard_ime_status;\n\tupdate->SaveSessionInfo = rdp_send_save_session_info;\n\tupdate->ServerStatusInfo = rdp_send_server_status_info;\n\tupdate->primary->DstBlt = update_send_dstblt;\n\tupdate->primary->PatBlt = update_send_patblt;\n\tupdate->primary->ScrBlt = update_send_scrblt;\n\tupdate->primary->OpaqueRect = update_send_opaque_rect;\n\tupdate->primary->LineTo = update_send_line_to;\n\tupdate->primary->MemBlt = update_send_memblt;\n\tupdate->primary->GlyphIndex = update_send_glyph_index;\n\tupdate->secondary->CacheBitmap = update_send_cache_bitmap;\n\tupdate->secondary->CacheBitmapV2 = update_send_cache_bitmap_v2;\n\tupdate->secondary->CacheBitmapV3 = update_send_cache_bitmap_v3;\n\tupdate->secondary->CacheColorTable = update_send_cache_color_table;\n\tupdate->secondary->CacheGlyph = update_send_cache_glyph;\n\tupdate->secondary->CacheGlyphV2 = update_send_cache_glyph_v2;\n\tupdate->secondary->CacheBrush = update_send_cache_brush;\n\tupdate->altsec->CreateOffscreenBitmap = update_send_create_offscreen_bitmap_order;\n\tupdate->altsec->SwitchSurface = update_send_switch_surface_order;\n\tupdate->pointer->PointerSystem = update_send_pointer_system;\n\tupdate->pointer->PointerPosition = update_send_pointer_position;\n\tupdate->pointer->PointerColor = update_send_pointer_color;\n\tupdate->pointer->PointerLarge = update_send_pointer_large;\n\tupdate->pointer->PointerNew = update_send_pointer_new;\n\tupdate->pointer->PointerCached = update_send_pointer_cached;\n\tupdate->window->WindowCreate = update_send_window_create;\n\tupdate->window->WindowUpdate = update_send_window_update;\n\tupdate->window->WindowIcon = update_send_window_icon;\n\tupdate->window->WindowCachedIcon = update_send_window_cached_icon;\n\tupdate->window->WindowDelete = update_send_window_delete;\n\tupdate->window->NotifyIconCreate = update_send_notify_icon_create;\n\tupdate->window->NotifyIconUpdate = update_send_notify_icon_update;\n\tupdate->window->NotifyIconDelete = update_send_notify_icon_delete;\n\tupdate->window->MonitoredDesktop = update_send_monitored_desktop;\n\tupdate->window->NonMonitoredDesktop = update_send_non_monitored_desktop;\n}\n\nvoid update_register_client_callbacks(rdpUpdate* update)\n{\n\tupdate->RefreshRect = update_send_refresh_rect;\n\tupdate->SuppressOutput = update_send_suppress_output;\n\tupdate->SurfaceFrameAcknowledge = update_send_frame_acknowledge;\n}\n\nint update_process_messages(rdpUpdate* update)\n{\n\treturn update_message_queue_process_pending_messages(update);\n}\n\nstatic void update_free_queued_message(void* obj)\n{\n\twMessage* msg = (wMessage*)obj;\n\tupdate_message_queue_free_message(msg);\n}\n\nvoid update_free_window_state(WINDOW_STATE_ORDER* window_state)\n{\n\tif (!window_state)\n\t\treturn;\n\n\tfree(window_state->OverlayDescription.string);\n\tfree(window_state->titleInfo.string);\n\tfree(window_state->windowRects);\n\tfree(window_state->visibilityRects);\n\tmemset(window_state, 0, sizeof(WINDOW_STATE_ORDER));\n}\n\nrdpUpdate* update_new(rdpRdp* rdp)\n{\n\tconst wObject cb = { NULL, NULL, NULL, update_free_queued_message, NULL };\n\trdpUpdate* update;\n\tOFFSCREEN_DELETE_LIST* deleteList;\n\tWINPR_UNUSED(rdp);\n\tupdate = (rdpUpdate*)calloc(1, sizeof(rdpUpdate));\n\n\tif (!update)\n\t\treturn NULL;\n\n\tupdate->log = WLog_Get(\"com.freerdp.core.update\");\n\tInitializeCriticalSection(&(update->mux));\n\tupdate->pointer = (rdpPointerUpdate*)calloc(1, sizeof(rdpPointerUpdate));\n\n\tif (!update->pointer)\n\t\tgoto fail;\n\n\tupdate->primary = (rdpPrimaryUpdate*)calloc(1, sizeof(rdpPrimaryUpdate));\n\n\tif (!update->primary)\n\t\tgoto fail;\n\n\tupdate->secondary = (rdpSecondaryUpdate*)calloc(1, sizeof(rdpSecondaryUpdate));\n\n\tif (!update->secondary)\n\t\tgoto fail;\n\n\tupdate->altsec = (rdpAltSecUpdate*)calloc(1, sizeof(rdpAltSecUpdate));\n\n\tif (!update->altsec)\n\t\tgoto fail;\n\n\tupdate->window = (rdpWindowUpdate*)calloc(1, sizeof(rdpWindowUpdate));\n\n\tif (!update->window)\n\t\tgoto fail;\n\n\tdeleteList = &(update->altsec->create_offscreen_bitmap.deleteList);\n\tdeleteList->sIndices = 64;\n\tdeleteList->indices = calloc(deleteList->sIndices, 2);\n\n\tif (!deleteList->indices)\n\t\tgoto fail;\n\n\tdeleteList->cIndices = 0;\n\tupdate->SuppressOutput = update_send_suppress_output;\n\tupdate->initialState = TRUE;\n\tupdate->autoCalculateBitmapData = TRUE;\n\tupdate->queue = MessageQueue_New(&cb);\n\n\tif (!update->queue)\n\t\tgoto fail;\n\n\treturn update;\nfail:\n\tupdate_free(update);\n\treturn NULL;\n}\n\nvoid update_free(rdpUpdate* update)\n{\n\tif (update != NULL)\n\t{\n\t\tOFFSCREEN_DELETE_LIST* deleteList = &(update->altsec->create_offscreen_bitmap.deleteList);\n\n\t\tif (deleteList)\n\t\t\tfree(deleteList->indices);\n\n\t\tfree(update->pointer);\n\n\t\tif (update->primary)\n\t\t{\n\t\t\tfree(update->primary->polyline.points);\n\t\t\tfree(update->primary->polygon_sc.points);\n\t\t\tfree(update->primary->fast_glyph.glyphData.aj);\n\t\t\tfree(update->primary);\n\t\t}\n\n\t\tfree(update->secondary);\n\t\tfree(update->altsec);\n\n\t\tif (update->window)\n\t\t{\n\t\t\tfree(update->window);\n\t\t}\n\n\t\tMessageQueue_Free(update->queue);\n\t\tDeleteCriticalSection(&update->mux);\n\t\tfree(update);\n\t}\n}\n\nBOOL update_begin_paint(rdpUpdate* update)\n{\n\tif (!update)\n\t\treturn FALSE;\n\n\tEnterCriticalSection(&update->mux);\n\n\tif (!update->BeginPaint)\n\t\treturn TRUE;\n\n\treturn update->BeginPaint(update->context);\n}\n\nBOOL update_end_paint(rdpUpdate* update)\n{\n\tBOOL rc = FALSE;\n\n\tif (!update)\n\t\treturn FALSE;\n\n\tif (update->EndPaint)\n\t\trc = update->EndPaint(update->context);\n\n\tLeaveCriticalSection(&update->mux);\n\treturn rc;\n}\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * Windowing Alternate Secondary Orders\n *\n * Copyright 2011 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2011 Roman Barabanov <romanbarabanov@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <winpr/crt.h>\n\n#include <freerdp/log.h>\n\n#include \"window.h\"\n\n#define TAG FREERDP_TAG(\"core.window\")\n\nstatic void update_free_window_icon_info(ICON_INFO* iconInfo);\n\nBOOL rail_read_unicode_string(wStream* s, RAIL_UNICODE_STRING* unicode_string)\n{\n\tUINT16 new_len;\n\tBYTE* new_str;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, new_len); /* cbString (2 bytes) */\n\n\tif (Stream_GetRemainingLength(s) < new_len)\n\t\treturn FALSE;\n\n\tif (!new_len)\n\t{\n\t\tfree(unicode_string->string);\n\t\tunicode_string->string = NULL;\n\t\tunicode_string->length = 0;\n\t\treturn TRUE;\n\t}\n\n\tnew_str = (BYTE*)realloc(unicode_string->string, new_len);\n\n\tif (!new_str)\n\t{\n\t\tfree(unicode_string->string);\n\t\tunicode_string->string = NULL;\n\t\treturn FALSE;\n\t}\n\n\tunicode_string->string = new_str;\n\tunicode_string->length = new_len;\n\tStream_Read(s, unicode_string->string, unicode_string->length);\n\treturn TRUE;\n}\n\nBOOL utf8_string_to_rail_string(const char* string, RAIL_UNICODE_STRING* unicode_string)\n{\n\tWCHAR* buffer = NULL;\n\tint length = 0;\n\tfree(unicode_string->string);\n\tunicode_string->string = NULL;\n\tunicode_string->length = 0;\n\n\tif (!string || strlen(string) < 1)\n\t\treturn TRUE;\n\n\tlength = ConvertToUnicode(CP_UTF8, 0, string, -1, &buffer, 0);\n\n\tif ((length < 0) || ((size_t)length * sizeof(WCHAR) > UINT16_MAX))\n\t{\n\t\tfree(buffer);\n\t\treturn FALSE;\n\t}\n\n\tunicode_string->string = (BYTE*)buffer;\n\tunicode_string->length = (UINT16)length * sizeof(WCHAR);\n\treturn TRUE;\n}\n\n/* See [MS-RDPERP] 2.2.1.2.3 Icon Info (TS_ICON_INFO) */\nstatic BOOL update_read_icon_info(wStream* s, ICON_INFO* iconInfo)\n{\n\tBYTE* newBitMask;\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, iconInfo->cacheEntry); /* cacheEntry (2 bytes) */\n\tStream_Read_UINT8(s, iconInfo->cacheId);     /* cacheId (1 byte) */\n\tStream_Read_UINT8(s, iconInfo->bpp);         /* bpp (1 byte) */\n\n\tif ((iconInfo->bpp < 1) || (iconInfo->bpp > 32))\n\t{\n\t\tWLog_ERR(TAG, \"invalid bpp value %\" PRIu32 \"\", iconInfo->bpp);\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, iconInfo->width);  /* width (2 bytes) */\n\tStream_Read_UINT16(s, iconInfo->height); /* height (2 bytes) */\n\n\t/* cbColorTable is only present when bpp is 1, 4 or 8 */\n\tswitch (iconInfo->bpp)\n\t{\n\t\tcase 1:\n\t\tcase 4:\n\t\tcase 8:\n\t\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\t\treturn FALSE;\n\n\t\t\tStream_Read_UINT16(s, iconInfo->cbColorTable); /* cbColorTable (2 bytes) */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\ticonInfo->cbColorTable = 0;\n\t\t\tbreak;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, iconInfo->cbBitsMask);  /* cbBitsMask (2 bytes) */\n\tStream_Read_UINT16(s, iconInfo->cbBitsColor); /* cbBitsColor (2 bytes) */\n\n\t/* bitsMask */\n\tnewBitMask = (BYTE*)realloc(iconInfo->bitsMask, iconInfo->cbBitsMask);\n\n\tif (!newBitMask)\n\t{\n\t\tfree(iconInfo->bitsMask);\n\t\ticonInfo->bitsMask = NULL;\n\t\treturn FALSE;\n\t}\n\n\ticonInfo->bitsMask = newBitMask;\n\tif (Stream_GetRemainingLength(s) < iconInfo->cbBitsMask)\n\t\treturn FALSE;\n\tStream_Read(s, iconInfo->bitsMask, iconInfo->cbBitsMask);\n\n\t/* colorTable */\n\tif (iconInfo->colorTable == NULL)\n\t{\n\t\tif (iconInfo->cbColorTable)\n\t\t{\n\t\t\ticonInfo->colorTable = (BYTE*)malloc(iconInfo->cbColorTable);\n\n\t\t\tif (!iconInfo->colorTable)\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\telse if (iconInfo->cbColorTable)\n\t{\n\t\tBYTE* new_tab;\n\t\tnew_tab = (BYTE*)realloc(iconInfo->colorTable, iconInfo->cbColorTable);\n\n\t\tif (!new_tab)\n\t\t{\n\t\t\tfree(iconInfo->colorTable);\n\t\t\ticonInfo->colorTable = NULL;\n\t\t\treturn FALSE;\n\t\t}\n\n\t\ticonInfo->colorTable = new_tab;\n\t}\n\telse\n\t{\n\t\tfree(iconInfo->colorTable);\n\t\ticonInfo->colorTable = NULL;\n\t}\n\n\tif (iconInfo->colorTable)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < iconInfo->cbColorTable)\n\t\t\treturn FALSE;\n\t\tStream_Read(s, iconInfo->colorTable, iconInfo->cbColorTable);\n\t}\n\n\t/* bitsColor */\n\tnewBitMask = (BYTE*)realloc(iconInfo->bitsColor, iconInfo->cbBitsColor);\n\n\tif (!newBitMask)\n\t{\n\t\tfree(iconInfo->bitsColor);\n\t\ticonInfo->bitsColor = NULL;\n\t\treturn FALSE;\n\t}\n\n\ticonInfo->bitsColor = newBitMask;\n\tif (Stream_GetRemainingLength(s) < iconInfo->cbBitsColor)\n\t\treturn FALSE;\n\tStream_Read(s, iconInfo->bitsColor, iconInfo->cbBitsColor);\n\treturn TRUE;\n}\n\nstatic BOOL update_read_cached_icon_info(wStream* s, CACHED_ICON_INFO* cachedIconInfo)\n{\n\tif (Stream_GetRemainingLength(s) < 3)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, cachedIconInfo->cacheEntry); /* cacheEntry (2 bytes) */\n\tStream_Read_UINT8(s, cachedIconInfo->cacheId);     /* cacheId (1 byte) */\n\treturn TRUE;\n}\n\nstatic BOOL update_read_notify_icon_infotip(wStream* s, NOTIFY_ICON_INFOTIP* notifyIconInfoTip)\n{\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, notifyIconInfoTip->timeout);              /* timeout (4 bytes) */\n\tStream_Read_UINT32(s, notifyIconInfoTip->flags);                /* infoFlags (4 bytes) */\n\treturn rail_read_unicode_string(s, &notifyIconInfoTip->text) && /* infoTipText */\n\t       rail_read_unicode_string(s, &notifyIconInfoTip->title);  /* title */\n}\n\nstatic BOOL update_read_window_state_order(wStream* s, WINDOW_ORDER_INFO* orderInfo,\n                                           WINDOW_STATE_ORDER* windowState)\n{\n\tUINT32 i;\n\tsize_t size;\n\tRECTANGLE_16* newRect;\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_OWNER)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 4)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT32(s, windowState->ownerWindowId); /* ownerWindowId (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_STYLE)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT32(s, windowState->style);         /* style (4 bytes) */\n\t\tStream_Read_UINT32(s, windowState->extendedStyle); /* extendedStyle (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_SHOW)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, windowState->showState); /* showState (1 byte) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_TITLE)\n\t{\n\t\tif (!rail_read_unicode_string(s, &windowState->titleInfo)) /* titleInfo */\n\t\t\treturn FALSE;\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_CLIENT_AREA_OFFSET)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_INT32(s, windowState->clientOffsetX); /* clientOffsetX (4 bytes) */\n\t\tStream_Read_INT32(s, windowState->clientOffsetY); /* clientOffsetY (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_CLIENT_AREA_SIZE)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT32(s, windowState->clientAreaWidth);  /* clientAreaWidth (4 bytes) */\n\t\tStream_Read_UINT32(s, windowState->clientAreaHeight); /* clientAreaHeight (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RESIZE_MARGIN_X)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT32(s, windowState->resizeMarginLeft);\n\t\tStream_Read_UINT32(s, windowState->resizeMarginRight);\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RESIZE_MARGIN_Y)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT32(s, windowState->resizeMarginTop);\n\t\tStream_Read_UINT32(s, windowState->resizeMarginBottom);\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RP_CONTENT)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, windowState->RPContent); /* RPContent (1 byte) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_ROOT_PARENT)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 4)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT32(s, windowState->rootParentHandle); /* rootParentHandle (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_OFFSET)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_INT32(s, windowState->windowOffsetX); /* windowOffsetX (4 bytes) */\n\t\tStream_Read_INT32(s, windowState->windowOffsetY); /* windowOffsetY (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_CLIENT_DELTA)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_INT32(s, windowState->windowClientDeltaX); /* windowClientDeltaX (4 bytes) */\n\t\tStream_Read_INT32(s, windowState->windowClientDeltaY); /* windowClientDeltaY (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_SIZE)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT32(s, windowState->windowWidth);  /* windowWidth (4 bytes) */\n\t\tStream_Read_UINT32(s, windowState->windowHeight); /* windowHeight (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_RECTS)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, windowState->numWindowRects); /* numWindowRects (2 bytes) */\n\n\t\tif (windowState->numWindowRects == 0)\n\t\t{\n\t\t\treturn TRUE;\n\t\t}\n\n\t\tsize = sizeof(RECTANGLE_16) * windowState->numWindowRects;\n\t\tnewRect = (RECTANGLE_16*)realloc(windowState->windowRects, size);\n\n\t\tif (!newRect)\n\t\t{\n\t\t\tfree(windowState->windowRects);\n\t\t\twindowState->windowRects = NULL;\n\t\t\treturn FALSE;\n\t\t}\n\n\t\twindowState->windowRects = newRect;\n\n\t\tif (Stream_GetRemainingLength(s) < 8 * windowState->numWindowRects)\n\t\t\treturn FALSE;\n\n\t\t/* windowRects */\n\t\tfor (i = 0; i < windowState->numWindowRects; i++)\n\t\t{\n\t\t\tStream_Read_UINT16(s, windowState->windowRects[i].left);   /* left (2 bytes) */\n\t\t\tStream_Read_UINT16(s, windowState->windowRects[i].top);    /* top (2 bytes) */\n\t\t\tStream_Read_UINT16(s, windowState->windowRects[i].right);  /* right (2 bytes) */\n\t\t\tStream_Read_UINT16(s, windowState->windowRects[i].bottom); /* bottom (2 bytes) */\n\t\t}\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_VIS_OFFSET)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT32(s, windowState->visibleOffsetX); /* visibleOffsetX (4 bytes) */\n\t\tStream_Read_UINT32(s, windowState->visibleOffsetY); /* visibleOffsetY (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_VISIBILITY)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, windowState->numVisibilityRects); /* numVisibilityRects (2 bytes) */\n\n\t\tif (windowState->numVisibilityRects != 0)\n\t\t{\n\t\t\tsize = sizeof(RECTANGLE_16) * windowState->numVisibilityRects;\n\t\t\tnewRect = (RECTANGLE_16*)realloc(windowState->visibilityRects, size);\n\n\t\t\tif (!newRect)\n\t\t\t{\n\t\t\t\tfree(windowState->visibilityRects);\n\t\t\t\twindowState->visibilityRects = NULL;\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\twindowState->visibilityRects = newRect;\n\n\t\t\tif (Stream_GetRemainingLength(s) < windowState->numVisibilityRects * 8)\n\t\t\t\treturn FALSE;\n\n\t\t\t/* visibilityRects */\n\t\t\tfor (i = 0; i < windowState->numVisibilityRects; i++)\n\t\t\t{\n\t\t\t\tStream_Read_UINT16(s, windowState->visibilityRects[i].left);  /* left (2 bytes) */\n\t\t\t\tStream_Read_UINT16(s, windowState->visibilityRects[i].top);   /* top (2 bytes) */\n\t\t\t\tStream_Read_UINT16(s, windowState->visibilityRects[i].right); /* right (2 bytes) */\n\t\t\t\tStream_Read_UINT16(s,\n\t\t\t\t                   windowState->visibilityRects[i].bottom); /* bottom (2 bytes) */\n\t\t\t}\n\t\t}\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_OVERLAY_DESCRIPTION)\n\t{\n\t\tif (!rail_read_unicode_string(s, &windowState->OverlayDescription))\n\t\t\treturn FALSE;\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_ICON_OVERLAY_NULL)\n\t{\n\t\t/* no data to be read here */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_TASKBAR_BUTTON)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, windowState->TaskbarButton);\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_ENFORCE_SERVER_ZORDER)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, windowState->EnforceServerZOrder);\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_APPBAR_STATE)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, windowState->AppBarState);\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_APPBAR_EDGE)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, windowState->AppBarEdge);\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL update_read_window_icon_order(wStream* s, WINDOW_ORDER_INFO* orderInfo,\n                                          WINDOW_ICON_ORDER* window_icon)\n{\n\tWINPR_UNUSED(orderInfo);\n\twindow_icon->iconInfo = (ICON_INFO*)calloc(1, sizeof(ICON_INFO));\n\n\tif (!window_icon->iconInfo)\n\t\treturn FALSE;\n\n\treturn update_read_icon_info(s, window_icon->iconInfo); /* iconInfo (ICON_INFO) */\n}\n\nstatic BOOL update_read_window_cached_icon_order(wStream* s, WINDOW_ORDER_INFO* orderInfo,\n                                                 WINDOW_CACHED_ICON_ORDER* window_cached_icon)\n{\n\tWINPR_UNUSED(orderInfo);\n\treturn update_read_cached_icon_info(\n\t    s, &window_cached_icon->cachedIcon); /* cachedIcon (CACHED_ICON_INFO) */\n}\n\nstatic void update_read_window_delete_order(wStream* s, WINDOW_ORDER_INFO* orderInfo)\n{\n\t/* window deletion event */\n}\n\nstatic BOOL window_order_supported(const rdpSettings* settings, UINT32 fieldFlags)\n{\n\tconst UINT32 mask = (WINDOW_ORDER_FIELD_CLIENT_AREA_SIZE | WINDOW_ORDER_FIELD_RP_CONTENT |\n\t                     WINDOW_ORDER_FIELD_ROOT_PARENT);\n\tBOOL dresult;\n\n\tif (!settings)\n\t\treturn FALSE;\n\n\t/* See [MS-RDPERP] 2.2.1.1.2 Window List Capability Set */\n\tdresult = settings->AllowUnanouncedOrdersFromServer;\n\n\tswitch (settings->RemoteWndSupportLevel)\n\t{\n\t\tcase WINDOW_LEVEL_SUPPORTED_EX:\n\t\t\treturn TRUE;\n\n\t\tcase WINDOW_LEVEL_SUPPORTED:\n\t\t\treturn ((fieldFlags & mask) == 0) || dresult;\n\n\t\tcase WINDOW_LEVEL_NOT_SUPPORTED:\n\t\t\treturn dresult;\n\n\t\tdefault:\n\t\t\treturn dresult;\n\t}\n}\n\n#define DUMP_APPEND(buffer, size, ...)            \\\n\tdo                                            \\\n\t{                                             \\\n\t\tchar* b = (buffer);                       \\\n\t\tsize_t s = (size);                        \\\n\t\tsize_t pos = strnlen(b, s);               \\\n\t\t_snprintf(&b[pos], s - pos, __VA_ARGS__); \\\n\t} while (0)\n\nstatic void dump_window_state_order(wLog* log, const char* msg, const WINDOW_ORDER_INFO* order,\n                                    const WINDOW_STATE_ORDER* state)\n{\n\tchar buffer[3000] = { 0 };\n\tconst size_t bufferSize = sizeof(buffer) - 1;\n\n\t_snprintf(buffer, bufferSize, \"%s windowId=0x%\" PRIu32 \"\", msg, order->windowId);\n\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_OWNER)\n\t\tDUMP_APPEND(buffer, bufferSize, \" owner=0x%\" PRIx32 \"\", state->ownerWindowId);\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_STYLE)\n\t{\n\t\tDUMP_APPEND(buffer, bufferSize, \" [ex]style=<0x%\" PRIx32 \", 0x%\" PRIx32 \"\", state->style,\n\t\t            state->extendedStyle);\n\t\tif (state->style & WS_POPUP)\n\t\t\tDUMP_APPEND(buffer, bufferSize, \" popup\");\n\t\tif (state->style & WS_VISIBLE)\n\t\t\tDUMP_APPEND(buffer, bufferSize, \" visible\");\n\t\tif (state->style & WS_THICKFRAME)\n\t\t\tDUMP_APPEND(buffer, bufferSize, \" thickframe\");\n\t\tif (state->style & WS_BORDER)\n\t\t\tDUMP_APPEND(buffer, bufferSize, \" border\");\n\t\tif (state->style & WS_CAPTION)\n\t\t\tDUMP_APPEND(buffer, bufferSize, \" caption\");\n\n\t\tif (state->extendedStyle & WS_EX_NOACTIVATE)\n\t\t\tDUMP_APPEND(buffer, bufferSize, \" noactivate\");\n\t\tif (state->extendedStyle & WS_EX_TOOLWINDOW)\n\t\t\tDUMP_APPEND(buffer, bufferSize, \" toolWindow\");\n\t\tif (state->extendedStyle & WS_EX_TOPMOST)\n\t\t\tDUMP_APPEND(buffer, bufferSize, \" topMost\");\n\n\t\tDUMP_APPEND(buffer, bufferSize, \">\");\n\t}\n\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_SHOW)\n\t{\n\t\tconst char* showStr;\n\t\tswitch (state->showState)\n\t\t{\n\t\t\tcase 0:\n\t\t\t\tshowStr = \"hidden\";\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tshowStr = \"minimized\";\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tshowStr = \"maximized\";\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tshowStr = \"current\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tshowStr = \"<unknown>\";\n\t\t\t\tbreak;\n\t\t}\n\t\tDUMP_APPEND(buffer, bufferSize, \" show=%s\", showStr);\n\t}\n\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_TITLE)\n\t\tDUMP_APPEND(buffer, bufferSize, \" title\");\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_CLIENT_AREA_OFFSET)\n\t\tDUMP_APPEND(buffer, bufferSize, \" clientOffset=(%\" PRId32 \",%\" PRId32 \")\",\n\t\t            state->clientOffsetX, state->clientOffsetY);\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_CLIENT_AREA_SIZE)\n\t\tDUMP_APPEND(buffer, bufferSize, \" clientAreaWidth=%\" PRIu32 \" clientAreaHeight=%\" PRIu32 \"\",\n\t\t            state->clientAreaWidth, state->clientAreaHeight);\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_RESIZE_MARGIN_X)\n\t\tDUMP_APPEND(buffer, bufferSize,\n\t\t            \" resizeMarginLeft=%\" PRIu32 \" resizeMarginRight=%\" PRIu32 \"\",\n\t\t            state->resizeMarginLeft, state->resizeMarginRight);\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_RESIZE_MARGIN_Y)\n\t\tDUMP_APPEND(buffer, bufferSize,\n\t\t            \" resizeMarginTop=%\" PRIu32 \" resizeMarginBottom=%\" PRIu32 \"\",\n\t\t            state->resizeMarginTop, state->resizeMarginBottom);\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_RP_CONTENT)\n\t\tDUMP_APPEND(buffer, bufferSize, \" rpContent=0x%\" PRIx32 \"\", state->RPContent);\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_ROOT_PARENT)\n\t\tDUMP_APPEND(buffer, bufferSize, \" rootParent=0x%\" PRIx32 \"\", state->rootParentHandle);\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_WND_OFFSET)\n\t\tDUMP_APPEND(buffer, bufferSize, \" windowOffset=(%\" PRId32 \",%\" PRId32 \")\",\n\t\t            state->windowOffsetX, state->windowOffsetY);\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_WND_CLIENT_DELTA)\n\t\tDUMP_APPEND(buffer, bufferSize, \" windowClientDelta=(%\" PRId32 \",%\" PRId32 \")\",\n\t\t            state->windowClientDeltaX, state->windowClientDeltaY);\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_WND_SIZE)\n\t\tDUMP_APPEND(buffer, bufferSize, \" windowWidth=%\" PRIu32 \" windowHeight=%\" PRIu32 \"\",\n\t\t            state->windowWidth, state->windowHeight);\n\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_WND_RECTS)\n\t{\n\t\tUINT32 i;\n\t\tDUMP_APPEND(buffer, bufferSize, \" windowRects=(\");\n\t\tfor (i = 0; i < state->numWindowRects; i++)\n\t\t{\n\t\t\tDUMP_APPEND(buffer, bufferSize, \"(%\" PRIu16 \",%\" PRIu16 \",%\" PRIu16 \",%\" PRIu16 \")\",\n\t\t\t            state->windowRects[i].left, state->windowRects[i].top,\n\t\t\t            state->windowRects[i].right, state->windowRects[i].bottom);\n\t\t}\n\t\tDUMP_APPEND(buffer, bufferSize, \")\");\n\t}\n\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_VIS_OFFSET)\n\t\tDUMP_APPEND(buffer, bufferSize, \" visibleOffset=(%\" PRId32 \",%\" PRId32 \")\",\n\t\t            state->visibleOffsetX, state->visibleOffsetY);\n\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_VISIBILITY)\n\t{\n\t\tUINT32 i;\n\t\tDUMP_APPEND(buffer, bufferSize, \" visibilityRects=(\");\n\t\tfor (i = 0; i < state->numVisibilityRects; i++)\n\t\t{\n\t\t\tDUMP_APPEND(buffer, bufferSize, \"(%\" PRIu16 \",%\" PRIu16 \",%\" PRIu16 \",%\" PRIu16 \")\",\n\t\t\t            state->visibilityRects[i].left, state->visibilityRects[i].top,\n\t\t\t            state->visibilityRects[i].right, state->visibilityRects[i].bottom);\n\t\t}\n\t\tDUMP_APPEND(buffer, bufferSize, \")\");\n\t}\n\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_OVERLAY_DESCRIPTION)\n\t\tDUMP_APPEND(buffer, bufferSize, \" overlayDescr\");\n\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_ICON_OVERLAY_NULL)\n\t\tDUMP_APPEND(buffer, bufferSize, \" iconOverlayNull\");\n\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_TASKBAR_BUTTON)\n\t\tDUMP_APPEND(buffer, bufferSize, \" taskBarButton=0x%\" PRIx8 \"\", state->TaskbarButton);\n\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_ENFORCE_SERVER_ZORDER)\n\t\tDUMP_APPEND(buffer, bufferSize, \" enforceServerZOrder=0x%\" PRIx8 \"\",\n\t\t            state->EnforceServerZOrder);\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_APPBAR_STATE)\n\t\tDUMP_APPEND(buffer, bufferSize, \" appBarState=0x%\" PRIx8 \"\", state->AppBarState);\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_APPBAR_EDGE)\n\t{\n\t\tconst char* appBarEdgeStr;\n\t\tswitch (state->AppBarEdge)\n\t\t{\n\t\t\tcase 0:\n\t\t\t\tappBarEdgeStr = \"left\";\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tappBarEdgeStr = \"top\";\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tappBarEdgeStr = \"right\";\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tappBarEdgeStr = \"bottom\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tappBarEdgeStr = \"<unknown>\";\n\t\t\t\tbreak;\n\t\t}\n\t\tDUMP_APPEND(buffer, bufferSize, \" appBarEdge=%s\", appBarEdgeStr);\n\t}\n\n\tWLog_Print(log, WLOG_DEBUG, buffer);\n}\n\nstatic BOOL update_recv_window_info_order(rdpUpdate* update, wStream* s,\n                                          WINDOW_ORDER_INFO* orderInfo)\n{\n\trdpContext* context = update->context;\n\trdpWindowUpdate* window = update->window;\n\tBOOL result = TRUE;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, orderInfo->windowId); /* windowId (4 bytes) */\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_ICON)\n\t{\n\t\tWINDOW_ICON_ORDER window_icon = { 0 };\n\t\tresult = update_read_window_icon_order(s, orderInfo, &window_icon);\n\n\t\tif (result)\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"WindowIcon windowId=0x%\" PRIx32 \"\",\n\t\t\t           orderInfo->windowId);\n\t\t\tIFCALLRET(window->WindowIcon, result, context, orderInfo, &window_icon);\n\t\t}\n\n\t\tupdate_free_window_icon_info(window_icon.iconInfo);\n\t\tfree(window_icon.iconInfo);\n\t}\n\telse if (orderInfo->fieldFlags & WINDOW_ORDER_CACHED_ICON)\n\t{\n\t\tWINDOW_CACHED_ICON_ORDER window_cached_icon = { 0 };\n\t\tresult = update_read_window_cached_icon_order(s, orderInfo, &window_cached_icon);\n\n\t\tif (result)\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"WindowCachedIcon windowId=0x%\" PRIx32 \"\",\n\t\t\t           orderInfo->windowId);\n\t\t\tIFCALLRET(window->WindowCachedIcon, result, context, orderInfo, &window_cached_icon);\n\t\t}\n\t}\n\telse if (orderInfo->fieldFlags & WINDOW_ORDER_STATE_DELETED)\n\t{\n\t\tupdate_read_window_delete_order(s, orderInfo);\n\t\tWLog_Print(update->log, WLOG_DEBUG, \"WindowDelete windowId=0x%\" PRIx32 \"\",\n\t\t           orderInfo->windowId);\n\t\tIFCALLRET(window->WindowDelete, result, context, orderInfo);\n\t}\n\telse\n\t{\n\t\tWINDOW_STATE_ORDER windowState = { 0 };\n\t\tresult = update_read_window_state_order(s, orderInfo, &windowState);\n\n\t\tif (result)\n\t\t{\n\t\t\tif (orderInfo->fieldFlags & WINDOW_ORDER_STATE_NEW)\n\t\t\t{\n\t\t\t\tdump_window_state_order(update->log, \"WindowCreate\", orderInfo, &windowState);\n\t\t\t\tIFCALLRET(window->WindowCreate, result, context, orderInfo, &windowState);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdump_window_state_order(update->log, \"WindowUpdate\", orderInfo, &windowState);\n\t\t\t\tIFCALLRET(window->WindowUpdate, result, context, orderInfo, &windowState);\n\t\t\t}\n\n\t\t\tupdate_free_window_state(&windowState);\n\t\t}\n\t}\n\n\treturn result;\n}\n\nstatic void update_notify_icon_state_order_free(NOTIFY_ICON_STATE_ORDER* notify)\n{\n\tfree(notify->toolTip.string);\n\tfree(notify->infoTip.text.string);\n\tfree(notify->infoTip.title.string);\n\tupdate_free_window_icon_info(&notify->icon);\n\tmemset(notify, 0, sizeof(NOTIFY_ICON_STATE_ORDER));\n}\n\nstatic BOOL update_read_notification_icon_state_order(wStream* s, WINDOW_ORDER_INFO* orderInfo,\n                                                      NOTIFY_ICON_STATE_ORDER* notify_icon_state)\n{\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_VERSION)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 4)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT32(s, notify_icon_state->version); /* version (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_TIP)\n\t{\n\t\tif (!rail_read_unicode_string(s,\n\t\t                              &notify_icon_state->toolTip)) /* toolTip (UNICODE_STRING) */\n\t\t\treturn FALSE;\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_INFO_TIP)\n\t{\n\t\tif (!update_read_notify_icon_infotip(\n\t\t        s, &notify_icon_state->infoTip)) /* infoTip (NOTIFY_ICON_INFOTIP) */\n\t\t\treturn FALSE;\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_STATE)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 4)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT32(s, notify_icon_state->state); /* state (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_ICON)\n\t{\n\t\tif (!update_read_icon_info(s, &notify_icon_state->icon)) /* icon (ICON_INFO) */\n\t\t\treturn FALSE;\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_CACHED_ICON)\n\t{\n\t\tif (!update_read_cached_icon_info(\n\t\t        s, &notify_icon_state->cachedIcon)) /* cachedIcon (CACHED_ICON_INFO) */\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nstatic void update_read_notification_icon_delete_order(wStream* s, WINDOW_ORDER_INFO* orderInfo)\n{\n\t/* notification icon deletion event */\n}\n\nstatic BOOL update_recv_notification_icon_info_order(rdpUpdate* update, wStream* s,\n                                                     WINDOW_ORDER_INFO* orderInfo)\n{\n\trdpContext* context = update->context;\n\trdpWindowUpdate* window = update->window;\n\tBOOL result = TRUE;\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, orderInfo->windowId);     /* windowId (4 bytes) */\n\tStream_Read_UINT32(s, orderInfo->notifyIconId); /* notifyIconId (4 bytes) */\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_STATE_DELETED)\n\t{\n\t\tupdate_read_notification_icon_delete_order(s, orderInfo);\n\t\tWLog_Print(update->log, WLOG_DEBUG, \"NotifyIconDelete\");\n\t\tIFCALLRET(window->NotifyIconDelete, result, context, orderInfo);\n\t}\n\telse\n\t{\n\t\tNOTIFY_ICON_STATE_ORDER notify_icon_state = { 0 };\n\t\tresult = update_read_notification_icon_state_order(s, orderInfo, &notify_icon_state);\n\n\t\tif (!result)\n\t\t\tgoto fail;\n\n\t\tif (orderInfo->fieldFlags & WINDOW_ORDER_STATE_NEW)\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"NotifyIconCreate\");\n\t\t\tIFCALLRET(window->NotifyIconCreate, result, context, orderInfo, &notify_icon_state);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"NotifyIconUpdate\");\n\t\t\tIFCALLRET(window->NotifyIconUpdate, result, context, orderInfo, &notify_icon_state);\n\t\t}\n\tfail:\n\t\tupdate_notify_icon_state_order_free(&notify_icon_state);\n\t}\n\n\treturn result;\n}\n\nstatic BOOL update_read_desktop_actively_monitored_order(wStream* s, WINDOW_ORDER_INFO* orderInfo,\n                                                         MONITORED_DESKTOP_ORDER* monitored_desktop)\n{\n\tint i;\n\tint size;\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_DESKTOP_ACTIVE_WND)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 4)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT32(s, monitored_desktop->activeWindowId); /* activeWindowId (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_DESKTOP_ZORDER)\n\t{\n\t\tUINT32* newid;\n\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, monitored_desktop->numWindowIds); /* numWindowIds (1 byte) */\n\n\t\tif (Stream_GetRemainingLength(s) < 4 * monitored_desktop->numWindowIds)\n\t\t\treturn FALSE;\n\n\t\tif (monitored_desktop->numWindowIds > 0)\n\t\t{\n\t\t\tsize = sizeof(UINT32) * monitored_desktop->numWindowIds;\n\t\t\tnewid = (UINT32*)realloc(monitored_desktop->windowIds, size);\n\n\t\t\tif (!newid)\n\t\t\t{\n\t\t\t\tfree(monitored_desktop->windowIds);\n\t\t\t\tmonitored_desktop->windowIds = NULL;\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tmonitored_desktop->windowIds = newid;\n\n\t\t\t/* windowIds */\n\t\t\tfor (i = 0; i < (int)monitored_desktop->numWindowIds; i++)\n\t\t\t{\n\t\t\t\tStream_Read_UINT32(s, monitored_desktop->windowIds[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\nstatic void update_read_desktop_non_monitored_order(wStream* s, WINDOW_ORDER_INFO* orderInfo)\n{\n\t/* non-monitored desktop notification event */\n}\n\nstatic void dump_monitored_desktop(wLog* log, const char* msg, const WINDOW_ORDER_INFO* orderInfo,\n                                   const MONITORED_DESKTOP_ORDER* monitored)\n{\n\tchar buffer[1000] = { 0 };\n\tconst size_t bufferSize = sizeof(buffer) - 1;\n\n\tDUMP_APPEND(buffer, bufferSize, \"%s\", msg);\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_DESKTOP_ACTIVE_WND)\n\t\tDUMP_APPEND(buffer, bufferSize, \" activeWindowId=0x%\" PRIx32 \"\", monitored->activeWindowId);\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_DESKTOP_ZORDER)\n\t{\n\t\tUINT32 i;\n\n\t\tDUMP_APPEND(buffer, bufferSize, \" windows=(\");\n\t\tfor (i = 0; i < monitored->numWindowIds; i++)\n\t\t{\n\t\t\tDUMP_APPEND(buffer, bufferSize, \"0x%\" PRIx32 \",\", monitored->windowIds[i]);\n\t\t}\n\t\tDUMP_APPEND(buffer, bufferSize, \")\");\n\t}\n\tWLog_Print(log, WLOG_DEBUG, buffer);\n}\n\nstatic BOOL update_recv_desktop_info_order(rdpUpdate* update, wStream* s,\n                                           WINDOW_ORDER_INFO* orderInfo)\n{\n\trdpContext* context = update->context;\n\trdpWindowUpdate* window = update->window;\n\tBOOL result = TRUE;\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_DESKTOP_NONE)\n\t{\n\t\tupdate_read_desktop_non_monitored_order(s, orderInfo);\n\t\tWLog_Print(update->log, WLOG_DEBUG, \"NonMonitoredDesktop, windowId=0x%\" PRIx32 \"\",\n\t\t           orderInfo->windowId);\n\t\tIFCALLRET(window->NonMonitoredDesktop, result, context, orderInfo);\n\t}\n\telse\n\t{\n\t\tMONITORED_DESKTOP_ORDER monitored_desktop = { 0 };\n\t\tresult = update_read_desktop_actively_monitored_order(s, orderInfo, &monitored_desktop);\n\n\t\tif (result)\n\t\t{\n\t\t\tdump_monitored_desktop(update->log, \"ActivelyMonitoredDesktop\", orderInfo,\n\t\t\t                       &monitored_desktop);\n\t\t\tIFCALLRET(window->MonitoredDesktop, result, context, orderInfo, &monitored_desktop);\n\t\t}\n\n\t\tfree(monitored_desktop.windowIds);\n\t}\n\n\treturn result;\n}\n\nvoid update_free_window_icon_info(ICON_INFO* iconInfo)\n{\n\tif (!iconInfo)\n\t\treturn;\n\n\tfree(iconInfo->bitsColor);\n\ticonInfo->bitsColor = NULL;\n\tfree(iconInfo->bitsMask);\n\ticonInfo->bitsMask = NULL;\n\tfree(iconInfo->colorTable);\n\ticonInfo->colorTable = NULL;\n}\n\nBOOL update_recv_altsec_window_order(rdpUpdate* update, wStream* s)\n{\n\tBOOL rc = TRUE;\n\tsize_t remaining;\n\tUINT16 orderSize;\n\tWINDOW_ORDER_INFO orderInfo = { 0 };\n\tremaining = Stream_GetRemainingLength(s);\n\n\tif (remaining < 6)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"Stream short\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, orderSize);            /* orderSize (2 bytes) */\n\tStream_Read_UINT32(s, orderInfo.fieldFlags); /* FieldsPresentFlags (4 bytes) */\n\n\tif (remaining + 1 < orderSize)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"Stream short orderSize\");\n\t\treturn FALSE;\n\t}\n\n\tif (!window_order_supported(update->context->settings, orderInfo.fieldFlags))\n\t{\n\t\tWLog_INFO(TAG, \"Window order %08\" PRIx32 \" not supported!\", orderInfo.fieldFlags);\n\t\treturn FALSE;\n\t}\n\n\tif (orderInfo.fieldFlags & WINDOW_ORDER_TYPE_WINDOW)\n\t\trc = update_recv_window_info_order(update, s, &orderInfo);\n\telse if (orderInfo.fieldFlags & WINDOW_ORDER_TYPE_NOTIFY)\n\t\trc = update_recv_notification_icon_info_order(update, s, &orderInfo);\n\telse if (orderInfo.fieldFlags & WINDOW_ORDER_TYPE_DESKTOP)\n\t\trc = update_recv_desktop_info_order(update, s, &orderInfo);\n\n\tif (!rc)\n\t\tWLog_Print(update->log, WLOG_ERROR, \"windoworder flags %08\" PRIx32 \" failed\",\n\t\t           orderInfo.fieldFlags);\n\n\treturn rc;\n}\n"], "filenames": ["libfreerdp/cache/bitmap.c", "libfreerdp/core/autodetect.c", "libfreerdp/core/capabilities.c", "libfreerdp/core/gcc.c", "libfreerdp/core/orders.c", "libfreerdp/core/peer.c", "libfreerdp/core/rdp.c", "libfreerdp/core/rdp.h", "libfreerdp/core/update.c", "libfreerdp/core/window.c"], "buggy_code_start_loc": [283, 467, 110, 522, 2164, 351, 105, 187, 105, 139], "buggy_code_end_loc": [289, 467, 3905, 614, 2165, 405, 1389, 188, 811, 199], "fixing_code_start_loc": [284, 468, 110, 522, 2164, 350, 105, 187, 106, 138], "fixing_code_end_loc": [289, 470, 3904, 628, 2165, 408, 1400, 189, 815, 205], "type": "CWE-125", "message": "In FreeRDP after 1.1 and before 2.0.0, there is an out-of-bound read of client memory that is then passed on to the protocol parser. This has been patched in 2.0.0.", "other": {"cve": {"id": "CVE-2020-11049", "sourceIdentifier": "security-advisories@github.com", "published": "2020-05-07T20:15:12.237", "lastModified": "2022-07-01T17:19:25.897", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In FreeRDP after 1.1 and before 2.0.0, there is an out-of-bound read of client memory that is then passed on to the protocol parser. This has been patched in 2.0.0."}, {"lang": "es", "value": "En FreeRDP versiones posteriores a 1.1 y versiones anteriores a 2.0.0, se presenta una lectura fuera de l\u00edmite de la memoria del cliente que es pasada luego en el analizador de protocolo. Esto ha sido parcheado en la versi\u00f3n 2.0.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:H/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 2.2, "baseSeverity": "LOW"}, "exploitabilityScore": 0.7, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:H/UI:N/S:C/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.3, "impactScore": 3.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:freerdp:freerdp:*:*:*:*:*:*:*:*", "versionStartExcluding": "1.1.0", "versionEndExcluding": "2.0.0", "matchCriteriaId": "F953BF38-4A6C-41EE-B646-37702989F524"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:20.04:*:*:*:lts:*:*:*", "matchCriteriaId": "902B8056-9E37-443B-8905-8AA93E2447FB"}]}]}], "references": [{"url": "https://github.com/FreeRDP/FreeRDP/commit/c367f65d42e0d2e1ca248998175180aa9c2eacd0", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/FreeRDP/FreeRDP/issues/6008", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/FreeRDP/FreeRDP/pull/6019", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/FreeRDP/FreeRDP/security/advisories/GHSA-wwh7-r2r8-xjpr", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4379-1/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4382-1/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FreeRDP/FreeRDP/commit/c367f65d42e0d2e1ca248998175180aa9c2eacd0"}}