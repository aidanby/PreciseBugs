{"buggy_code": ["/* $OpenBSD: scp.c,v 1.209 2020/05/01 06:31:42 djm Exp $ */\n/*\n * scp - secure remote copy.  This is basically patched BSD rcp which\n * uses ssh to do the data transfer (instead of using rcmd).\n *\n * NOTE: This version should NOT be suid root.  (This uses ssh to\n * do the transfer and ssh has the necessary privileges.)\n *\n * 1995 Timo Rinne <tri@iki.fi>, Tatu Ylonen <ylo@cs.hut.fi>\n *\n * As far as I am concerned, the code I have written for this software\n * can be used freely for any purpose.  Any derived versions of this\n * software must be clearly marked as such, and if the derived work is\n * incompatible with the protocol description in the RFC file, it must be\n * called by a name other than \"ssh\" or \"Secure Shell\".\n */\n/*\n * Copyright (c) 1999 Theo de Raadt.  All rights reserved.\n * Copyright (c) 1999 Aaron Campbell.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*\n * Parts from:\n *\n * Copyright (c) 1983, 1990, 1992, 1993, 1995\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the University nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n *\n */\n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#ifdef HAVE_SYS_STAT_H\n# include <sys/stat.h>\n#endif\n#ifdef HAVE_POLL_H\n#include <poll.h>\n#else\n# ifdef HAVE_SYS_POLL_H\n#  include <sys/poll.h>\n# endif\n#endif\n#ifdef HAVE_SYS_TIME_H\n# include <sys/time.h>\n#endif\n#include <sys/wait.h>\n#include <sys/uio.h>\n\n#include <ctype.h>\n#include <dirent.h>\n#include <errno.h>\n#include <fcntl.h>\n#ifdef HAVE_FNMATCH_H\n#include <fnmatch.h>\n#endif\n#include <limits.h>\n#include <locale.h>\n#include <pwd.h>\n#include <signal.h>\n#include <stdarg.h>\n#ifdef HAVE_STDINT_H\n# include <stdint.h>\n#endif\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n#if defined(HAVE_STRNVIS) && defined(HAVE_VIS_H) && !defined(BROKEN_STRNVIS)\n#include <vis.h>\n#endif\n\n#include \"xmalloc.h\"\n#include \"ssh.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"utf8.h\"\n\nextern char *__progname;\n\n#define COPY_BUFLEN\t16384\n\nint do_cmd(char *host, char *remuser, int port, char *cmd, int *fdin, int *fdout);\nint do_cmd2(char *host, char *remuser, int port, char *cmd, int fdin, int fdout);\n\n/* Struct for addargs */\narglist args;\narglist remote_remote_args;\n\n/* Bandwidth limit */\nlong long limit_kbps = 0;\nstruct bwlimit bwlimit;\n\n/* Name of current file being transferred. */\nchar *curfile;\n\n/* This is set to non-zero to enable verbose mode. */\nint verbose_mode = 0;\n\n/* This is set to zero if the progressmeter is not desired. */\nint showprogress = 1;\n\n/*\n * This is set to non-zero if remote-remote copy should be piped\n * through this process.\n */\nint throughlocal = 0;\n\n/* Non-standard port to use for the ssh connection or -1. */\nint sshport = -1;\n\n/* This is the program to execute for the secured connection. (\"ssh\" or -S) */\nchar *ssh_program = _PATH_SSH_PROGRAM;\n\n/* This is used to store the pid of ssh_program */\npid_t do_cmd_pid = -1;\n\nstatic void\nkillchild(int signo)\n{\n\tif (do_cmd_pid > 1) {\n\t\tkill(do_cmd_pid, signo ? signo : SIGTERM);\n\t\twaitpid(do_cmd_pid, NULL, 0);\n\t}\n\n\tif (signo)\n\t\t_exit(1);\n\texit(1);\n}\n\nstatic void\nsuspchild(int signo)\n{\n\tint status;\n\n\tif (do_cmd_pid > 1) {\n\t\tkill(do_cmd_pid, signo);\n\t\twhile (waitpid(do_cmd_pid, &status, WUNTRACED) == -1 &&\n\t\t    errno == EINTR)\n\t\t\t;\n\t\tkill(getpid(), SIGSTOP);\n\t}\n}\n\nstatic int\ndo_local_cmd(arglist *a)\n{\n\tu_int i;\n\tint status;\n\tpid_t pid;\n\n\tif (a->num == 0)\n\t\tfatal(\"do_local_cmd: no arguments\");\n\n\tif (verbose_mode) {\n\t\tfprintf(stderr, \"Executing:\");\n\t\tfor (i = 0; i < a->num; i++)\n\t\t\tfmprintf(stderr, \" %s\", a->list[i]);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n\tif ((pid = fork()) == -1)\n\t\tfatal(\"do_local_cmd: fork: %s\", strerror(errno));\n\n\tif (pid == 0) {\n\t\texecvp(a->list[0], a->list);\n\t\tperror(a->list[0]);\n\t\texit(1);\n\t}\n\n\tdo_cmd_pid = pid;\n\tssh_signal(SIGTERM, killchild);\n\tssh_signal(SIGINT, killchild);\n\tssh_signal(SIGHUP, killchild);\n\n\twhile (waitpid(pid, &status, 0) == -1)\n\t\tif (errno != EINTR)\n\t\t\tfatal(\"do_local_cmd: waitpid: %s\", strerror(errno));\n\n\tdo_cmd_pid = -1;\n\n\tif (!WIFEXITED(status) || WEXITSTATUS(status) != 0)\n\t\treturn (-1);\n\n\treturn (0);\n}\n\n/*\n * This function executes the given command as the specified user on the\n * given host.  This returns < 0 if execution fails, and >= 0 otherwise. This\n * assigns the input and output file descriptors on success.\n */\n\nint\ndo_cmd(char *host, char *remuser, int port, char *cmd, int *fdin, int *fdout)\n{\n\tint pin[2], pout[2], reserved[2];\n\n\tif (verbose_mode)\n\t\tfmprintf(stderr,\n\t\t    \"Executing: program %s host %s, user %s, command %s\\n\",\n\t\t    ssh_program, host,\n\t\t    remuser ? remuser : \"(unspecified)\", cmd);\n\n\tif (port == -1)\n\t\tport = sshport;\n\n\t/*\n\t * Reserve two descriptors so that the real pipes won't get\n\t * descriptors 0 and 1 because that will screw up dup2 below.\n\t */\n\tif (pipe(reserved) == -1)\n\t\tfatal(\"pipe: %s\", strerror(errno));\n\n\t/* Create a socket pair for communicating with ssh. */\n\tif (pipe(pin) == -1)\n\t\tfatal(\"pipe: %s\", strerror(errno));\n\tif (pipe(pout) == -1)\n\t\tfatal(\"pipe: %s\", strerror(errno));\n\n\t/* Free the reserved descriptors. */\n\tclose(reserved[0]);\n\tclose(reserved[1]);\n\n\tssh_signal(SIGTSTP, suspchild);\n\tssh_signal(SIGTTIN, suspchild);\n\tssh_signal(SIGTTOU, suspchild);\n\n\t/* Fork a child to execute the command on the remote host using ssh. */\n\tdo_cmd_pid = fork();\n\tif (do_cmd_pid == 0) {\n\t\t/* Child. */\n\t\tclose(pin[1]);\n\t\tclose(pout[0]);\n\t\tdup2(pin[0], 0);\n\t\tdup2(pout[1], 1);\n\t\tclose(pin[0]);\n\t\tclose(pout[1]);\n\n\t\treplacearg(&args, 0, \"%s\", ssh_program);\n\t\tif (port != -1) {\n\t\t\taddargs(&args, \"-p\");\n\t\t\taddargs(&args, \"%d\", port);\n\t\t}\n\t\tif (remuser != NULL) {\n\t\t\taddargs(&args, \"-l\");\n\t\t\taddargs(&args, \"%s\", remuser);\n\t\t}\n\t\taddargs(&args, \"--\");\n\t\taddargs(&args, \"%s\", host);\n\t\taddargs(&args, \"%s\", cmd);\n\n\t\texecvp(ssh_program, args.list);\n\t\tperror(ssh_program);\n\t\texit(1);\n\t} else if (do_cmd_pid == -1) {\n\t\tfatal(\"fork: %s\", strerror(errno));\n\t}\n\t/* Parent.  Close the other side, and return the local side. */\n\tclose(pin[0]);\n\t*fdout = pin[1];\n\tclose(pout[1]);\n\t*fdin = pout[0];\n\tssh_signal(SIGTERM, killchild);\n\tssh_signal(SIGINT, killchild);\n\tssh_signal(SIGHUP, killchild);\n\treturn 0;\n}\n\n/*\n * This function executes a command similar to do_cmd(), but expects the\n * input and output descriptors to be setup by a previous call to do_cmd().\n * This way the input and output of two commands can be connected.\n */\nint\ndo_cmd2(char *host, char *remuser, int port, char *cmd, int fdin, int fdout)\n{\n\tpid_t pid;\n\tint status;\n\n\tif (verbose_mode)\n\t\tfmprintf(stderr,\n\t\t    \"Executing: 2nd program %s host %s, user %s, command %s\\n\",\n\t\t    ssh_program, host,\n\t\t    remuser ? remuser : \"(unspecified)\", cmd);\n\n\tif (port == -1)\n\t\tport = sshport;\n\n\t/* Fork a child to execute the command on the remote host using ssh. */\n\tpid = fork();\n\tif (pid == 0) {\n\t\tdup2(fdin, 0);\n\t\tdup2(fdout, 1);\n\n\t\treplacearg(&args, 0, \"%s\", ssh_program);\n\t\tif (port != -1) {\n\t\t\taddargs(&args, \"-p\");\n\t\t\taddargs(&args, \"%d\", port);\n\t\t}\n\t\tif (remuser != NULL) {\n\t\t\taddargs(&args, \"-l\");\n\t\t\taddargs(&args, \"%s\", remuser);\n\t\t}\n\t\taddargs(&args, \"-oBatchMode=yes\");\n\t\taddargs(&args, \"--\");\n\t\taddargs(&args, \"%s\", host);\n\t\taddargs(&args, \"%s\", cmd);\n\n\t\texecvp(ssh_program, args.list);\n\t\tperror(ssh_program);\n\t\texit(1);\n\t} else if (pid == -1) {\n\t\tfatal(\"fork: %s\", strerror(errno));\n\t}\n\twhile (waitpid(pid, &status, 0) == -1)\n\t\tif (errno != EINTR)\n\t\t\tfatal(\"do_cmd2: waitpid: %s\", strerror(errno));\n\treturn 0;\n}\n\ntypedef struct {\n\tsize_t cnt;\n\tchar *buf;\n} BUF;\n\nBUF *allocbuf(BUF *, int, int);\nvoid lostconn(int);\nint okname(char *);\nvoid run_err(const char *,...);\nint note_err(const char *,...);\nvoid verifydir(char *);\n\nstruct passwd *pwd;\nuid_t userid;\nint errs, remin, remout;\nint Tflag, pflag, iamremote, iamrecursive, targetshouldbedirectory;\n\n#define\tCMDNEEDS\t64\nchar cmd[CMDNEEDS];\t\t/* must hold \"rcp -r -p -d\\0\" */\n\nint response(void);\nvoid rsource(char *, struct stat *);\nvoid sink(int, char *[], const char *);\nvoid source(int, char *[]);\nvoid tolocal(int, char *[]);\nvoid toremote(int, char *[]);\nvoid usage(void);\n\nint\nmain(int argc, char **argv)\n{\n\tint ch, fflag, tflag, status, n;\n\tchar **newargv;\n\tconst char *errstr;\n\textern char *optarg;\n\textern int optind;\n\n\t/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */\n\tsanitise_stdfd();\n\n\tseed_rng();\n\n\tmsetlocale();\n\n\t/* Copy argv, because we modify it */\n\tnewargv = xcalloc(MAXIMUM(argc + 1, 1), sizeof(*newargv));\n\tfor (n = 0; n < argc; n++)\n\t\tnewargv[n] = xstrdup(argv[n]);\n\targv = newargv;\n\n\t__progname = ssh_get_progname(argv[0]);\n\n\tmemset(&args, '\\0', sizeof(args));\n\tmemset(&remote_remote_args, '\\0', sizeof(remote_remote_args));\n\targs.list = remote_remote_args.list = NULL;\n\taddargs(&args, \"%s\", ssh_program);\n\taddargs(&args, \"-x\");\n\taddargs(&args, \"-oForwardAgent=no\");\n\taddargs(&args, \"-oPermitLocalCommand=no\");\n\taddargs(&args, \"-oClearAllForwardings=yes\");\n\taddargs(&args, \"-oRemoteCommand=none\");\n\taddargs(&args, \"-oRequestTTY=no\");\n\n\tfflag = Tflag = tflag = 0;\n\twhile ((ch = getopt(argc, argv,\n\t    \"dfl:prtTvBCc:i:P:q12346S:o:F:J:\")) != -1) {\n\t\tswitch (ch) {\n\t\t/* User-visible flags. */\n\t\tcase '1':\n\t\t\tfatal(\"SSH protocol v.1 is no longer supported\");\n\t\t\tbreak;\n\t\tcase '2':\n\t\t\t/* Ignored */\n\t\t\tbreak;\n\t\tcase '4':\n\t\tcase '6':\n\t\tcase 'C':\n\t\t\taddargs(&args, \"-%c\", ch);\n\t\t\taddargs(&remote_remote_args, \"-%c\", ch);\n\t\t\tbreak;\n\t\tcase '3':\n\t\t\tthroughlocal = 1;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\tcase 'c':\n\t\tcase 'i':\n\t\tcase 'F':\n\t\tcase 'J':\n\t\t\taddargs(&remote_remote_args, \"-%c\", ch);\n\t\t\taddargs(&remote_remote_args, \"%s\", optarg);\n\t\t\taddargs(&args, \"-%c\", ch);\n\t\t\taddargs(&args, \"%s\", optarg);\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tsshport = a2port(optarg);\n\t\t\tif (sshport <= 0)\n\t\t\t\tfatal(\"bad port \\\"%s\\\"\\n\", optarg);\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\taddargs(&remote_remote_args, \"-oBatchmode=yes\");\n\t\t\taddargs(&args, \"-oBatchmode=yes\");\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tlimit_kbps = strtonum(optarg, 1, 100 * 1024 * 1024,\n\t\t\t    &errstr);\n\t\t\tif (errstr != NULL)\n\t\t\t\tusage();\n\t\t\tlimit_kbps *= 1024; /* kbps */\n\t\t\tbandwidth_limit_init(&bwlimit, limit_kbps, COPY_BUFLEN);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tpflag = 1;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tiamrecursive = 1;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tssh_program = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\taddargs(&args, \"-v\");\n\t\t\taddargs(&remote_remote_args, \"-v\");\n\t\t\tverbose_mode = 1;\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\taddargs(&args, \"-q\");\n\t\t\taddargs(&remote_remote_args, \"-q\");\n\t\t\tshowprogress = 0;\n\t\t\tbreak;\n\n\t\t/* Server options. */\n\t\tcase 'd':\n\t\t\ttargetshouldbedirectory = 1;\n\t\t\tbreak;\n\t\tcase 'f':\t/* \"from\" */\n\t\t\tiamremote = 1;\n\t\t\tfflag = 1;\n\t\t\tbreak;\n\t\tcase 't':\t/* \"to\" */\n\t\t\tiamremote = 1;\n\t\t\ttflag = 1;\n#ifdef HAVE_CYGWIN\n\t\t\tsetmode(0, O_BINARY);\n#endif\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tTflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\t}\n\targc -= optind;\n\targv += optind;\n\n\tif ((pwd = getpwuid(userid = getuid())) == NULL)\n\t\tfatal(\"unknown user %u\", (u_int) userid);\n\n\tif (!isatty(STDOUT_FILENO))\n\t\tshowprogress = 0;\n\n\tif (pflag) {\n\t\t/* Cannot pledge: -p allows setuid/setgid files... */\n\t} else {\n\t\tif (pledge(\"stdio rpath wpath cpath fattr tty proc exec\",\n\t\t    NULL) == -1) {\n\t\t\tperror(\"pledge\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tremin = STDIN_FILENO;\n\tremout = STDOUT_FILENO;\n\n\tif (fflag) {\n\t\t/* Follow \"protocol\", send data. */\n\t\t(void) response();\n\t\tsource(argc, argv);\n\t\texit(errs != 0);\n\t}\n\tif (tflag) {\n\t\t/* Receive data. */\n\t\tsink(argc, argv, NULL);\n\t\texit(errs != 0);\n\t}\n\tif (argc < 2)\n\t\tusage();\n\tif (argc > 2)\n\t\ttargetshouldbedirectory = 1;\n\n\tremin = remout = -1;\n\tdo_cmd_pid = -1;\n\t/* Command to be executed on remote system using \"ssh\". */\n\t(void) snprintf(cmd, sizeof cmd, \"scp%s%s%s%s\",\n\t    verbose_mode ? \" -v\" : \"\",\n\t    iamrecursive ? \" -r\" : \"\", pflag ? \" -p\" : \"\",\n\t    targetshouldbedirectory ? \" -d\" : \"\");\n\n\t(void) ssh_signal(SIGPIPE, lostconn);\n\n\tif (colon(argv[argc - 1]))\t/* Dest is remote host. */\n\t\ttoremote(argc, argv);\n\telse {\n\t\tif (targetshouldbedirectory)\n\t\t\tverifydir(argv[argc - 1]);\n\t\ttolocal(argc, argv);\t/* Dest is local host. */\n\t}\n\t/*\n\t * Finally check the exit status of the ssh process, if one was forked\n\t * and no error has occurred yet\n\t */\n\tif (do_cmd_pid != -1 && errs == 0) {\n\t\tif (remin != -1)\n\t\t    (void) close(remin);\n\t\tif (remout != -1)\n\t\t    (void) close(remout);\n\t\tif (waitpid(do_cmd_pid, &status, 0) == -1)\n\t\t\terrs = 1;\n\t\telse {\n\t\t\tif (!WIFEXITED(status) || WEXITSTATUS(status) != 0)\n\t\t\t\terrs = 1;\n\t\t}\n\t}\n\texit(errs != 0);\n}\n\n/* Callback from atomicio6 to update progress meter and limit bandwidth */\nstatic int\nscpio(void *_cnt, size_t s)\n{\n\toff_t *cnt = (off_t *)_cnt;\n\n\t*cnt += s;\n\trefresh_progress_meter(0);\n\tif (limit_kbps > 0)\n\t\tbandwidth_limit(&bwlimit, s);\n\treturn 0;\n}\n\nstatic int\ndo_times(int fd, int verb, const struct stat *sb)\n{\n\t/* strlen(2^64) == 20; strlen(10^6) == 7 */\n\tchar buf[(20 + 7 + 2) * 2 + 2];\n\n\t(void)snprintf(buf, sizeof(buf), \"T%llu 0 %llu 0\\n\",\n\t    (unsigned long long) (sb->st_mtime < 0 ? 0 : sb->st_mtime),\n\t    (unsigned long long) (sb->st_atime < 0 ? 0 : sb->st_atime));\n\tif (verb) {\n\t\tfprintf(stderr, \"File mtime %lld atime %lld\\n\",\n\t\t    (long long)sb->st_mtime, (long long)sb->st_atime);\n\t\tfprintf(stderr, \"Sending file timestamps: %s\", buf);\n\t}\n\t(void) atomicio(vwrite, fd, buf, strlen(buf));\n\treturn (response());\n}\n\nstatic int\nparse_scp_uri(const char *uri, char **userp, char **hostp, int *portp,\n     char **pathp)\n{\n\tint r;\n\n\tr = parse_uri(\"scp\", uri, userp, hostp, portp, pathp);\n\tif (r == 0 && *pathp == NULL)\n\t\t*pathp = xstrdup(\".\");\n\treturn r;\n}\n\n/* Appends a string to an array; returns 0 on success, -1 on alloc failure */\nstatic int\nappend(char *cp, char ***ap, size_t *np)\n{\n\tchar **tmp;\n\n\tif ((tmp = reallocarray(*ap, *np + 1, sizeof(*tmp))) == NULL)\n\t\treturn -1;\n\ttmp[(*np)] = cp;\n\t(*np)++;\n\t*ap = tmp;\n\treturn 0;\n}\n\n/*\n * Finds the start and end of the first brace pair in the pattern.\n * returns 0 on success or -1 for invalid patterns.\n */\nstatic int\nfind_brace(const char *pattern, int *startp, int *endp)\n{\n\tint i;\n\tint in_bracket, brace_level;\n\n\t*startp = *endp = -1;\n\tin_bracket = brace_level = 0;\n\tfor (i = 0; i < INT_MAX && *endp < 0 && pattern[i] != '\\0'; i++) {\n\t\tswitch (pattern[i]) {\n\t\tcase '\\\\':\n\t\t\t/* skip next character */\n\t\t\tif (pattern[i + 1] != '\\0')\n\t\t\t\ti++;\n\t\t\tbreak;\n\t\tcase '[':\n\t\t\tin_bracket = 1;\n\t\t\tbreak;\n\t\tcase ']':\n\t\t\tin_bracket = 0;\n\t\t\tbreak;\n\t\tcase '{':\n\t\t\tif (in_bracket)\n\t\t\t\tbreak;\n\t\t\tif (pattern[i + 1] == '}') {\n\t\t\t\t/* Protect a single {}, for find(1), like csh */\n\t\t\t\ti++; /* skip */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (*startp == -1)\n\t\t\t\t*startp = i;\n\t\t\tbrace_level++;\n\t\t\tbreak;\n\t\tcase '}':\n\t\t\tif (in_bracket)\n\t\t\t\tbreak;\n\t\t\tif (*startp < 0) {\n\t\t\t\t/* Unbalanced brace */\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (--brace_level <= 0)\n\t\t\t\t*endp = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* unbalanced brackets/braces */\n\tif (*endp < 0 && (*startp >= 0 || in_bracket))\n\t\treturn -1;\n\treturn 0;\n}\n\n/*\n * Assembles and records a successfully-expanded pattern, returns -1 on\n * alloc failure.\n */\nstatic int\nemit_expansion(const char *pattern, int brace_start, int brace_end,\n    int sel_start, int sel_end, char ***patternsp, size_t *npatternsp)\n{\n\tchar *cp;\n\tint o = 0, tail_len = strlen(pattern + brace_end + 1);\n\n\tif ((cp = malloc(brace_start + (sel_end - sel_start) +\n\t    tail_len + 1)) == NULL)\n\t\treturn -1;\n\n\t/* Pattern before initial brace */\n\tif (brace_start > 0) {\n\t\tmemcpy(cp, pattern, brace_start);\n\t\to = brace_start;\n\t}\n\t/* Current braced selection */\n\tif (sel_end - sel_start > 0) {\n\t\tmemcpy(cp + o, pattern + sel_start,\n\t\t    sel_end - sel_start);\n\t\to += sel_end - sel_start;\n\t}\n\t/* Remainder of pattern after closing brace */\n\tif (tail_len > 0) {\n\t\tmemcpy(cp + o, pattern + brace_end + 1, tail_len);\n\t\to += tail_len;\n\t}\n\tcp[o] = '\\0';\n\tif (append(cp, patternsp, npatternsp) != 0) {\n\t\tfree(cp);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/*\n * Expand the first encountered brace in pattern, appending the expanded\n * patterns it yielded to the *patternsp array.\n *\n * Returns 0 on success or -1 on allocation failure.\n *\n * Signals whether expansion was performed via *expanded and whether\n * pattern was invalid via *invalid.\n */\nstatic int\nbrace_expand_one(const char *pattern, char ***patternsp, size_t *npatternsp,\n    int *expanded, int *invalid)\n{\n\tint i;\n\tint in_bracket, brace_start, brace_end, brace_level;\n\tint sel_start, sel_end;\n\n\t*invalid = *expanded = 0;\n\n\tif (find_brace(pattern, &brace_start, &brace_end) != 0) {\n\t\t*invalid = 1;\n\t\treturn 0;\n\t} else if (brace_start == -1)\n\t\treturn 0;\n\n\tin_bracket = brace_level = 0;\n\tfor (i = sel_start = brace_start + 1; i < brace_end; i++) {\n\t\tswitch (pattern[i]) {\n\t\tcase '{':\n\t\t\tif (in_bracket)\n\t\t\t\tbreak;\n\t\t\tbrace_level++;\n\t\t\tbreak;\n\t\tcase '}':\n\t\t\tif (in_bracket)\n\t\t\t\tbreak;\n\t\t\tbrace_level--;\n\t\t\tbreak;\n\t\tcase '[':\n\t\t\tin_bracket = 1;\n\t\t\tbreak;\n\t\tcase ']':\n\t\t\tin_bracket = 0;\n\t\t\tbreak;\n\t\tcase '\\\\':\n\t\t\tif (i < brace_end - 1)\n\t\t\t\ti++; /* skip */\n\t\t\tbreak;\n\t\t}\n\t\tif (pattern[i] == ',' || i == brace_end - 1) {\n\t\t\tif (in_bracket || brace_level > 0)\n\t\t\t\tcontinue;\n\t\t\t/* End of a selection, emit an expanded pattern */\n\n\t\t\t/* Adjust end index for last selection */\n\t\t\tsel_end = (i == brace_end - 1) ? brace_end : i;\n\t\t\tif (emit_expansion(pattern, brace_start, brace_end,\n\t\t\t    sel_start, sel_end, patternsp, npatternsp) != 0)\n\t\t\t\treturn -1;\n\t\t\t/* move on to the next selection */\n\t\t\tsel_start = i + 1;\n\t\t\tcontinue;\n\t\t}\n\t}\n\tif (in_bracket || brace_level > 0) {\n\t\t*invalid = 1;\n\t\treturn 0;\n\t}\n\t/* success */\n\t*expanded = 1;\n\treturn 0;\n}\n\n/* Expand braces from pattern. Returns 0 on success, -1 on failure */\nstatic int\nbrace_expand(const char *pattern, char ***patternsp, size_t *npatternsp)\n{\n\tchar *cp, *cp2, **active = NULL, **done = NULL;\n\tsize_t i, nactive = 0, ndone = 0;\n\tint ret = -1, invalid = 0, expanded = 0;\n\n\t*patternsp = NULL;\n\t*npatternsp = 0;\n\n\t/* Start the worklist with the original pattern */\n\tif ((cp = strdup(pattern)) == NULL)\n\t\treturn -1;\n\tif (append(cp, &active, &nactive) != 0) {\n\t\tfree(cp);\n\t\treturn -1;\n\t}\n\twhile (nactive > 0) {\n\t\tcp = active[nactive - 1];\n\t\tnactive--;\n\t\tif (brace_expand_one(cp, &active, &nactive,\n\t\t    &expanded, &invalid) == -1) {\n\t\t\tfree(cp);\n\t\t\tgoto fail;\n\t\t}\n\t\tif (invalid)\n\t\t\tfatal(\"%s: invalid brace pattern \\\"%s\\\"\", __func__, cp);\n\t\tif (expanded) {\n\t\t\t/*\n\t\t\t * Current entry expanded to new entries on the\n\t\t\t * active list; discard the progenitor pattern.\n\t\t\t */\n\t\t\tfree(cp);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Pattern did not expand; append the finename component to\n\t\t * the completed list\n\t\t */\n\t\tif ((cp2 = strrchr(cp, '/')) != NULL)\n\t\t\t*cp2++ = '\\0';\n\t\telse\n\t\t\tcp2 = cp;\n\t\tif (append(xstrdup(cp2), &done, &ndone) != 0) {\n\t\t\tfree(cp);\n\t\t\tgoto fail;\n\t\t}\n\t\tfree(cp);\n\t}\n\t/* success */\n\t*patternsp = done;\n\t*npatternsp = ndone;\n\tdone = NULL;\n\tndone = 0;\n\tret = 0;\n fail:\n\tfor (i = 0; i < nactive; i++)\n\t\tfree(active[i]);\n\tfree(active);\n\tfor (i = 0; i < ndone; i++)\n\t\tfree(done[i]);\n\tfree(done);\n\treturn ret;\n}\n\nvoid\ntoremote(int argc, char **argv)\n{\n\tchar *suser = NULL, *host = NULL, *src = NULL;\n\tchar *bp, *tuser, *thost, *targ;\n\tint sport = -1, tport = -1;\n\targlist alist;\n\tint i, r;\n\tu_int j;\n\n\tmemset(&alist, '\\0', sizeof(alist));\n\talist.list = NULL;\n\n\t/* Parse target */\n\tr = parse_scp_uri(argv[argc - 1], &tuser, &thost, &tport, &targ);\n\tif (r == -1) {\n\t\tfmprintf(stderr, \"%s: invalid uri\\n\", argv[argc - 1]);\n\t\t++errs;\n\t\tgoto out;\n\t}\n\tif (r != 0) {\n\t\tif (parse_user_host_path(argv[argc - 1], &tuser, &thost,\n\t\t    &targ) == -1) {\n\t\t\tfmprintf(stderr, \"%s: invalid target\\n\", argv[argc - 1]);\n\t\t\t++errs;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (tuser != NULL && !okname(tuser)) {\n\t\t++errs;\n\t\tgoto out;\n\t}\n\n\t/* Parse source files */\n\tfor (i = 0; i < argc - 1; i++) {\n\t\tfree(suser);\n\t\tfree(host);\n\t\tfree(src);\n\t\tr = parse_scp_uri(argv[i], &suser, &host, &sport, &src);\n\t\tif (r == -1) {\n\t\t\tfmprintf(stderr, \"%s: invalid uri\\n\", argv[i]);\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tif (r != 0) {\n\t\t\tparse_user_host_path(argv[i], &suser, &host, &src);\n\t\t}\n\t\tif (suser != NULL && !okname(suser)) {\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tif (host && throughlocal) {\t/* extended remote to remote */\n\t\t\txasprintf(&bp, \"%s -f %s%s\", cmd,\n\t\t\t    *src == '-' ? \"-- \" : \"\", src);\n\t\t\tif (do_cmd(host, suser, sport, bp, &remin, &remout) < 0)\n\t\t\t\texit(1);\n\t\t\tfree(bp);\n\t\t\txasprintf(&bp, \"%s -t %s%s\", cmd,\n\t\t\t    *targ == '-' ? \"-- \" : \"\", targ);\n\t\t\tif (do_cmd2(thost, tuser, tport, bp, remin, remout) < 0)\n\t\t\t\texit(1);\n\t\t\tfree(bp);\n\t\t\t(void) close(remin);\n\t\t\t(void) close(remout);\n\t\t\tremin = remout = -1;\n\t\t} else if (host) {\t/* standard remote to remote */\n\t\t\tif (tport != -1 && tport != SSH_DEFAULT_PORT) {\n\t\t\t\t/* This would require the remote support URIs */\n\t\t\t\tfatal(\"target port not supported with two \"\n\t\t\t\t    \"remote hosts without the -3 option\");\n\t\t\t}\n\n\t\t\tfreeargs(&alist);\n\t\t\taddargs(&alist, \"%s\", ssh_program);\n\t\t\taddargs(&alist, \"-x\");\n\t\t\taddargs(&alist, \"-oClearAllForwardings=yes\");\n\t\t\taddargs(&alist, \"-n\");\n\t\t\tfor (j = 0; j < remote_remote_args.num; j++) {\n\t\t\t\taddargs(&alist, \"%s\",\n\t\t\t\t    remote_remote_args.list[j]);\n\t\t\t}\n\n\t\t\tif (sport != -1) {\n\t\t\t\taddargs(&alist, \"-p\");\n\t\t\t\taddargs(&alist, \"%d\", sport);\n\t\t\t}\n\t\t\tif (suser) {\n\t\t\t\taddargs(&alist, \"-l\");\n\t\t\t\taddargs(&alist, \"%s\", suser);\n\t\t\t}\n\t\t\taddargs(&alist, \"--\");\n\t\t\taddargs(&alist, \"%s\", host);\n\t\t\taddargs(&alist, \"%s\", cmd);\n\t\t\taddargs(&alist, \"%s\", src);\n\t\t\taddargs(&alist, \"%s%s%s:%s\",\n\t\t\t    tuser ? tuser : \"\", tuser ? \"@\" : \"\",\n\t\t\t    thost, targ);\n\t\t\tif (do_local_cmd(&alist) != 0)\n\t\t\t\terrs = 1;\n\t\t} else {\t/* local to remote */\n\t\t\tif (remin == -1) {\n\t\t\t\txasprintf(&bp, \"%s -t %s%s\", cmd,\n\t\t\t\t    *targ == '-' ? \"-- \" : \"\", targ);\n\t\t\t\tif (do_cmd(thost, tuser, tport, bp, &remin,\n\t\t\t\t    &remout) < 0)\n\t\t\t\t\texit(1);\n\t\t\t\tif (response() < 0)\n\t\t\t\t\texit(1);\n\t\t\t\tfree(bp);\n\t\t\t}\n\t\t\tsource(1, argv + i);\n\t\t}\n\t}\nout:\n\tfree(tuser);\n\tfree(thost);\n\tfree(targ);\n\tfree(suser);\n\tfree(host);\n\tfree(src);\n}\n\nvoid\ntolocal(int argc, char **argv)\n{\n\tchar *bp, *host = NULL, *src = NULL, *suser = NULL;\n\targlist alist;\n\tint i, r, sport = -1;\n\n\tmemset(&alist, '\\0', sizeof(alist));\n\talist.list = NULL;\n\n\tfor (i = 0; i < argc - 1; i++) {\n\t\tfree(suser);\n\t\tfree(host);\n\t\tfree(src);\n\t\tr = parse_scp_uri(argv[i], &suser, &host, &sport, &src);\n\t\tif (r == -1) {\n\t\t\tfmprintf(stderr, \"%s: invalid uri\\n\", argv[i]);\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tif (r != 0)\n\t\t\tparse_user_host_path(argv[i], &suser, &host, &src);\n\t\tif (suser != NULL && !okname(suser)) {\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!host) {\t/* Local to local. */\n\t\t\tfreeargs(&alist);\n\t\t\taddargs(&alist, \"%s\", _PATH_CP);\n\t\t\tif (iamrecursive)\n\t\t\t\taddargs(&alist, \"-r\");\n\t\t\tif (pflag)\n\t\t\t\taddargs(&alist, \"-p\");\n\t\t\taddargs(&alist, \"--\");\n\t\t\taddargs(&alist, \"%s\", argv[i]);\n\t\t\taddargs(&alist, \"%s\", argv[argc-1]);\n\t\t\tif (do_local_cmd(&alist))\n\t\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Remote to local. */\n\t\txasprintf(&bp, \"%s -f %s%s\",\n\t\t    cmd, *src == '-' ? \"-- \" : \"\", src);\n\t\tif (do_cmd(host, suser, sport, bp, &remin, &remout) < 0) {\n\t\t\tfree(bp);\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tfree(bp);\n\t\tsink(1, argv + argc - 1, src);\n\t\t(void) close(remin);\n\t\tremin = remout = -1;\n\t}\n\tfree(suser);\n\tfree(host);\n\tfree(src);\n}\n\nvoid\nsource(int argc, char **argv)\n{\n\tstruct stat stb;\n\tstatic BUF buffer;\n\tBUF *bp;\n\toff_t i, statbytes;\n\tsize_t amt, nr;\n\tint fd = -1, haderr, indx;\n\tchar *last, *name, buf[PATH_MAX + 128], encname[PATH_MAX];\n\tint len;\n\n\tfor (indx = 0; indx < argc; ++indx) {\n\t\tname = argv[indx];\n\t\tstatbytes = 0;\n\t\tlen = strlen(name);\n\t\twhile (len > 1 && name[len-1] == '/')\n\t\t\tname[--len] = '\\0';\n\t\tif ((fd = open(name, O_RDONLY|O_NONBLOCK, 0)) == -1)\n\t\t\tgoto syserr;\n\t\tif (strchr(name, '\\n') != NULL) {\n\t\t\tstrnvis(encname, name, sizeof(encname), VIS_NL);\n\t\t\tname = encname;\n\t\t}\n\t\tif (fstat(fd, &stb) == -1) {\nsyserr:\t\t\trun_err(\"%s: %s\", name, strerror(errno));\n\t\t\tgoto next;\n\t\t}\n\t\tif (stb.st_size < 0) {\n\t\t\trun_err(\"%s: %s\", name, \"Negative file size\");\n\t\t\tgoto next;\n\t\t}\n\t\tunset_nonblock(fd);\n\t\tswitch (stb.st_mode & S_IFMT) {\n\t\tcase S_IFREG:\n\t\t\tbreak;\n\t\tcase S_IFDIR:\n\t\t\tif (iamrecursive) {\n\t\t\t\trsource(name, &stb);\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\t/* FALLTHROUGH */\n\t\tdefault:\n\t\t\trun_err(\"%s: not a regular file\", name);\n\t\t\tgoto next;\n\t\t}\n\t\tif ((last = strrchr(name, '/')) == NULL)\n\t\t\tlast = name;\n\t\telse\n\t\t\t++last;\n\t\tcurfile = last;\n\t\tif (pflag) {\n\t\t\tif (do_times(remout, verbose_mode, &stb) < 0)\n\t\t\t\tgoto next;\n\t\t}\n#define\tFILEMODEMASK\t(S_ISUID|S_ISGID|S_IRWXU|S_IRWXG|S_IRWXO)\n\t\tsnprintf(buf, sizeof buf, \"C%04o %lld %s\\n\",\n\t\t    (u_int) (stb.st_mode & FILEMODEMASK),\n\t\t    (long long)stb.st_size, last);\n\t\tif (verbose_mode)\n\t\t\tfmprintf(stderr, \"Sending file modes: %s\", buf);\n\t\t(void) atomicio(vwrite, remout, buf, strlen(buf));\n\t\tif (response() < 0)\n\t\t\tgoto next;\n\t\tif ((bp = allocbuf(&buffer, fd, COPY_BUFLEN)) == NULL) {\nnext:\t\t\tif (fd != -1) {\n\t\t\t\t(void) close(fd);\n\t\t\t\tfd = -1;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (showprogress)\n\t\t\tstart_progress_meter(curfile, stb.st_size, &statbytes);\n\t\tset_nonblock(remout);\n\t\tfor (haderr = i = 0; i < stb.st_size; i += bp->cnt) {\n\t\t\tamt = bp->cnt;\n\t\t\tif (i + (off_t)amt > stb.st_size)\n\t\t\t\tamt = stb.st_size - i;\n\t\t\tif (!haderr) {\n\t\t\t\tif ((nr = atomicio(read, fd,\n\t\t\t\t    bp->buf, amt)) != amt) {\n\t\t\t\t\thaderr = errno;\n\t\t\t\t\tmemset(bp->buf + nr, 0, amt - nr);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Keep writing after error to retain sync */\n\t\t\tif (haderr) {\n\t\t\t\t(void)atomicio(vwrite, remout, bp->buf, amt);\n\t\t\t\tmemset(bp->buf, 0, amt);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (atomicio6(vwrite, remout, bp->buf, amt, scpio,\n\t\t\t    &statbytes) != amt)\n\t\t\t\thaderr = errno;\n\t\t}\n\t\tunset_nonblock(remout);\n\n\t\tif (fd != -1) {\n\t\t\tif (close(fd) == -1 && !haderr)\n\t\t\t\thaderr = errno;\n\t\t\tfd = -1;\n\t\t}\n\t\tif (!haderr)\n\t\t\t(void) atomicio(vwrite, remout, \"\", 1);\n\t\telse\n\t\t\trun_err(\"%s: %s\", name, strerror(haderr));\n\t\t(void) response();\n\t\tif (showprogress)\n\t\t\tstop_progress_meter();\n\t}\n}\n\nvoid\nrsource(char *name, struct stat *statp)\n{\n\tDIR *dirp;\n\tstruct dirent *dp;\n\tchar *last, *vect[1], path[PATH_MAX];\n\n\tif (!(dirp = opendir(name))) {\n\t\trun_err(\"%s: %s\", name, strerror(errno));\n\t\treturn;\n\t}\n\tlast = strrchr(name, '/');\n\tif (last == NULL)\n\t\tlast = name;\n\telse\n\t\tlast++;\n\tif (pflag) {\n\t\tif (do_times(remout, verbose_mode, statp) < 0) {\n\t\t\tclosedir(dirp);\n\t\t\treturn;\n\t\t}\n\t}\n\t(void) snprintf(path, sizeof path, \"D%04o %d %.1024s\\n\",\n\t    (u_int) (statp->st_mode & FILEMODEMASK), 0, last);\n\tif (verbose_mode)\n\t\tfmprintf(stderr, \"Entering directory: %s\", path);\n\t(void) atomicio(vwrite, remout, path, strlen(path));\n\tif (response() < 0) {\n\t\tclosedir(dirp);\n\t\treturn;\n\t}\n\twhile ((dp = readdir(dirp)) != NULL) {\n\t\tif (dp->d_ino == 0)\n\t\t\tcontinue;\n\t\tif (!strcmp(dp->d_name, \".\") || !strcmp(dp->d_name, \"..\"))\n\t\t\tcontinue;\n\t\tif (strlen(name) + 1 + strlen(dp->d_name) >= sizeof(path) - 1) {\n\t\t\trun_err(\"%s/%s: name too long\", name, dp->d_name);\n\t\t\tcontinue;\n\t\t}\n\t\t(void) snprintf(path, sizeof path, \"%s/%s\", name, dp->d_name);\n\t\tvect[0] = path;\n\t\tsource(1, vect);\n\t}\n\t(void) closedir(dirp);\n\t(void) atomicio(vwrite, remout, \"E\\n\", 2);\n\t(void) response();\n}\n\n#define TYPE_OVERFLOW(type, val) \\\n\t((sizeof(type) == 4 && (val) > INT32_MAX) || \\\n\t (sizeof(type) == 8 && (val) > INT64_MAX) || \\\n\t (sizeof(type) != 4 && sizeof(type) != 8))\n\nvoid\nsink(int argc, char **argv, const char *src)\n{\n\tstatic BUF buffer;\n\tstruct stat stb;\n\tBUF *bp;\n\toff_t i;\n\tsize_t j, count;\n\tint amt, exists, first, ofd;\n\tmode_t mode, omode, mask;\n\toff_t size, statbytes;\n\tunsigned long long ull;\n\tint setimes, targisdir, wrerr;\n\tchar ch, *cp, *np, *targ, *why, *vect[1], buf[2048], visbuf[2048];\n\tchar **patterns = NULL;\n\tsize_t n, npatterns = 0;\n\tstruct timeval tv[2];\n\n#define\tatime\ttv[0]\n#define\tmtime\ttv[1]\n#define\tSCREWUP(str)\t{ why = str; goto screwup; }\n\n\tif (TYPE_OVERFLOW(time_t, 0) || TYPE_OVERFLOW(off_t, 0))\n\t\tSCREWUP(\"Unexpected off_t/time_t size\");\n\n\tsetimes = targisdir = 0;\n\tmask = umask(0);\n\tif (!pflag)\n\t\t(void) umask(mask);\n\tif (argc != 1) {\n\t\trun_err(\"ambiguous target\");\n\t\texit(1);\n\t}\n\ttarg = *argv;\n\tif (targetshouldbedirectory)\n\t\tverifydir(targ);\n\n\t(void) atomicio(vwrite, remout, \"\", 1);\n\tif (stat(targ, &stb) == 0 && S_ISDIR(stb.st_mode))\n\t\ttargisdir = 1;\n\tif (src != NULL && !iamrecursive && !Tflag) {\n\t\t/*\n\t\t * Prepare to try to restrict incoming filenames to match\n\t\t * the requested destination file glob.\n\t\t */\n\t\tif (brace_expand(src, &patterns, &npatterns) != 0)\n\t\t\tfatal(\"%s: could not expand pattern\", __func__);\n\t}\n\tfor (first = 1;; first = 0) {\n\t\tcp = buf;\n\t\tif (atomicio(read, remin, cp, 1) != 1)\n\t\t\tgoto done;\n\t\tif (*cp++ == '\\n')\n\t\t\tSCREWUP(\"unexpected <newline>\");\n\t\tdo {\n\t\t\tif (atomicio(read, remin, &ch, sizeof(ch)) != sizeof(ch))\n\t\t\t\tSCREWUP(\"lost connection\");\n\t\t\t*cp++ = ch;\n\t\t} while (cp < &buf[sizeof(buf) - 1] && ch != '\\n');\n\t\t*cp = 0;\n\t\tif (verbose_mode)\n\t\t\tfmprintf(stderr, \"Sink: %s\", buf);\n\n\t\tif (buf[0] == '\\01' || buf[0] == '\\02') {\n\t\t\tif (iamremote == 0) {\n\t\t\t\t(void) snmprintf(visbuf, sizeof(visbuf),\n\t\t\t\t    NULL, \"%s\", buf + 1);\n\t\t\t\t(void) atomicio(vwrite, STDERR_FILENO,\n\t\t\t\t    visbuf, strlen(visbuf));\n\t\t\t}\n\t\t\tif (buf[0] == '\\02')\n\t\t\t\texit(1);\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tif (buf[0] == 'E') {\n\t\t\t(void) atomicio(vwrite, remout, \"\", 1);\n\t\t\tgoto done;\n\t\t}\n\t\tif (ch == '\\n')\n\t\t\t*--cp = 0;\n\n\t\tcp = buf;\n\t\tif (*cp == 'T') {\n\t\t\tsetimes++;\n\t\t\tcp++;\n\t\t\tif (!isdigit((unsigned char)*cp))\n\t\t\t\tSCREWUP(\"mtime.sec not present\");\n\t\t\tull = strtoull(cp, &cp, 10);\n\t\t\tif (!cp || *cp++ != ' ')\n\t\t\t\tSCREWUP(\"mtime.sec not delimited\");\n\t\t\tif (TYPE_OVERFLOW(time_t, ull))\n\t\t\t\tsetimes = 0;\t/* out of range */\n\t\t\tmtime.tv_sec = ull;\n\t\t\tmtime.tv_usec = strtol(cp, &cp, 10);\n\t\t\tif (!cp || *cp++ != ' ' || mtime.tv_usec < 0 ||\n\t\t\t    mtime.tv_usec > 999999)\n\t\t\t\tSCREWUP(\"mtime.usec not delimited\");\n\t\t\tif (!isdigit((unsigned char)*cp))\n\t\t\t\tSCREWUP(\"atime.sec not present\");\n\t\t\tull = strtoull(cp, &cp, 10);\n\t\t\tif (!cp || *cp++ != ' ')\n\t\t\t\tSCREWUP(\"atime.sec not delimited\");\n\t\t\tif (TYPE_OVERFLOW(time_t, ull))\n\t\t\t\tsetimes = 0;\t/* out of range */\n\t\t\tatime.tv_sec = ull;\n\t\t\tatime.tv_usec = strtol(cp, &cp, 10);\n\t\t\tif (!cp || *cp++ != '\\0' || atime.tv_usec < 0 ||\n\t\t\t    atime.tv_usec > 999999)\n\t\t\t\tSCREWUP(\"atime.usec not delimited\");\n\t\t\t(void) atomicio(vwrite, remout, \"\", 1);\n\t\t\tcontinue;\n\t\t}\n\t\tif (*cp != 'C' && *cp != 'D') {\n\t\t\t/*\n\t\t\t * Check for the case \"rcp remote:foo\\* local:bar\".\n\t\t\t * In this case, the line \"No match.\" can be returned\n\t\t\t * by the shell before the rcp command on the remote is\n\t\t\t * executed so the ^Aerror_message convention isn't\n\t\t\t * followed.\n\t\t\t */\n\t\t\tif (first) {\n\t\t\t\trun_err(\"%s\", cp);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tSCREWUP(\"expected control record\");\n\t\t}\n\t\tmode = 0;\n\t\tfor (++cp; cp < buf + 5; cp++) {\n\t\t\tif (*cp < '0' || *cp > '7')\n\t\t\t\tSCREWUP(\"bad mode\");\n\t\t\tmode = (mode << 3) | (*cp - '0');\n\t\t}\n\t\tif (!pflag)\n\t\t\tmode &= ~mask;\n\t\tif (*cp++ != ' ')\n\t\t\tSCREWUP(\"mode not delimited\");\n\n\t\tif (!isdigit((unsigned char)*cp))\n\t\t\tSCREWUP(\"size not present\");\n\t\tull = strtoull(cp, &cp, 10);\n\t\tif (!cp || *cp++ != ' ')\n\t\t\tSCREWUP(\"size not delimited\");\n\t\tif (TYPE_OVERFLOW(off_t, ull))\n\t\t\tSCREWUP(\"size out of range\");\n\t\tsize = (off_t)ull;\n\n\t\tif (*cp == '\\0' || strchr(cp, '/') != NULL ||\n\t\t    strcmp(cp, \".\") == 0 || strcmp(cp, \"..\") == 0) {\n\t\t\trun_err(\"error: unexpected filename: %s\", cp);\n\t\t\texit(1);\n\t\t}\n\t\tif (npatterns > 0) {\n\t\t\tfor (n = 0; n < npatterns; n++) {\n\t\t\t\tif (fnmatch(patterns[n], cp, 0) == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (n >= npatterns)\n\t\t\t\tSCREWUP(\"filename does not match request\");\n\t\t}\n\t\tif (targisdir) {\n\t\t\tstatic char *namebuf;\n\t\t\tstatic size_t cursize;\n\t\t\tsize_t need;\n\n\t\t\tneed = strlen(targ) + strlen(cp) + 250;\n\t\t\tif (need > cursize) {\n\t\t\t\tfree(namebuf);\n\t\t\t\tnamebuf = xmalloc(need);\n\t\t\t\tcursize = need;\n\t\t\t}\n\t\t\t(void) snprintf(namebuf, need, \"%s%s%s\", targ,\n\t\t\t    strcmp(targ, \"/\") ? \"/\" : \"\", cp);\n\t\t\tnp = namebuf;\n\t\t} else\n\t\t\tnp = targ;\n\t\tcurfile = cp;\n\t\texists = stat(np, &stb) == 0;\n\t\tif (buf[0] == 'D') {\n\t\t\tint mod_flag = pflag;\n\t\t\tif (!iamrecursive)\n\t\t\t\tSCREWUP(\"received directory without -r\");\n\t\t\tif (exists) {\n\t\t\t\tif (!S_ISDIR(stb.st_mode)) {\n\t\t\t\t\terrno = ENOTDIR;\n\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t\tif (pflag)\n\t\t\t\t\t(void) chmod(np, mode);\n\t\t\t} else {\n\t\t\t\t/* Handle copying from a read-only\n\t\t\t\t   directory */\n\t\t\t\tmod_flag = 1;\n\t\t\t\tif (mkdir(np, mode | S_IRWXU) == -1)\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tvect[0] = xstrdup(np);\n\t\t\tsink(1, vect, src);\n\t\t\tif (setimes) {\n\t\t\t\tsetimes = 0;\n\t\t\t\tif (utimes(vect[0], tv) == -1)\n\t\t\t\t\trun_err(\"%s: set times: %s\",\n\t\t\t\t\t    vect[0], strerror(errno));\n\t\t\t}\n\t\t\tif (mod_flag)\n\t\t\t\t(void) chmod(vect[0], mode);\n\t\t\tfree(vect[0]);\n\t\t\tcontinue;\n\t\t}\n\t\tomode = mode;\n\t\tmode |= S_IWUSR;\n\t\tif ((ofd = open(np, O_WRONLY|O_CREAT, mode)) == -1) {\nbad:\t\t\trun_err(\"%s: %s\", np, strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\t\t(void) atomicio(vwrite, remout, \"\", 1);\n\t\tif ((bp = allocbuf(&buffer, ofd, COPY_BUFLEN)) == NULL) {\n\t\t\t(void) close(ofd);\n\t\t\tcontinue;\n\t\t}\n\t\tcp = bp->buf;\n\t\twrerr = 0;\n\n\t\t/*\n\t\t * NB. do not use run_err() unless immediately followed by\n\t\t * exit() below as it may send a spurious reply that might\n\t\t * desyncronise us from the peer. Use note_err() instead.\n\t\t */\n\t\tstatbytes = 0;\n\t\tif (showprogress)\n\t\t\tstart_progress_meter(curfile, size, &statbytes);\n\t\tset_nonblock(remin);\n\t\tfor (count = i = 0; i < size; i += bp->cnt) {\n\t\t\tamt = bp->cnt;\n\t\t\tif (i + amt > size)\n\t\t\t\tamt = size - i;\n\t\t\tcount += amt;\n\t\t\tdo {\n\t\t\t\tj = atomicio6(read, remin, cp, amt,\n\t\t\t\t    scpio, &statbytes);\n\t\t\t\tif (j == 0) {\n\t\t\t\t\trun_err(\"%s\", j != EPIPE ?\n\t\t\t\t\t    strerror(errno) :\n\t\t\t\t\t    \"dropped connection\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tamt -= j;\n\t\t\t\tcp += j;\n\t\t\t} while (amt > 0);\n\n\t\t\tif (count == bp->cnt) {\n\t\t\t\t/* Keep reading so we stay sync'd up. */\n\t\t\t\tif (!wrerr) {\n\t\t\t\t\tif (atomicio(vwrite, ofd, bp->buf,\n\t\t\t\t\t    count) != count) {\n\t\t\t\t\t\tnote_err(\"%s: %s\", np,\n\t\t\t\t\t\t    strerror(errno));\n\t\t\t\t\t\twrerr = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcount = 0;\n\t\t\t\tcp = bp->buf;\n\t\t\t}\n\t\t}\n\t\tunset_nonblock(remin);\n\t\tif (count != 0 && !wrerr &&\n\t\t    atomicio(vwrite, ofd, bp->buf, count) != count) {\n\t\t\tnote_err(\"%s: %s\", np, strerror(errno));\n\t\t\twrerr = 1;\n\t\t}\n\t\tif (!wrerr && (!exists || S_ISREG(stb.st_mode)) &&\n\t\t    ftruncate(ofd, size) != 0)\n\t\t\tnote_err(\"%s: truncate: %s\", np, strerror(errno));\n\t\tif (pflag) {\n\t\t\tif (exists || omode != mode)\n#ifdef HAVE_FCHMOD\n\t\t\t\tif (fchmod(ofd, omode)) {\n#else /* HAVE_FCHMOD */\n\t\t\t\tif (chmod(np, omode)) {\n#endif /* HAVE_FCHMOD */\n\t\t\t\t\tnote_err(\"%s: set mode: %s\",\n\t\t\t\t\t    np, strerror(errno));\n\t\t\t\t}\n\t\t} else {\n\t\t\tif (!exists && omode != mode)\n#ifdef HAVE_FCHMOD\n\t\t\t\tif (fchmod(ofd, omode & ~mask)) {\n#else /* HAVE_FCHMOD */\n\t\t\t\tif (chmod(np, omode & ~mask)) {\n#endif /* HAVE_FCHMOD */\n\t\t\t\t\tnote_err(\"%s: set mode: %s\",\n\t\t\t\t\t    np, strerror(errno));\n\t\t\t\t}\n\t\t}\n\t\tif (close(ofd) == -1)\n\t\t\tnote_err(np, \"%s: close: %s\", np, strerror(errno));\n\t\t(void) response();\n\t\tif (showprogress)\n\t\t\tstop_progress_meter();\n\t\tif (setimes && !wrerr) {\n\t\t\tsetimes = 0;\n\t\t\tif (utimes(np, tv) == -1) {\n\t\t\t\tnote_err(\"%s: set times: %s\",\n\t\t\t\t    np, strerror(errno));\n\t\t\t}\n\t\t}\n\t\t/* If no error was noted then signal success for this file */\n\t\tif (note_err(NULL) == 0)\n\t\t\t(void) atomicio(vwrite, remout, \"\", 1);\n\t}\ndone:\n\tfor (n = 0; n < npatterns; n++)\n\t\tfree(patterns[n]);\n\tfree(patterns);\n\treturn;\nscrewup:\n\tfor (n = 0; n < npatterns; n++)\n\t\tfree(patterns[n]);\n\tfree(patterns);\n\trun_err(\"protocol error: %s\", why);\n\texit(1);\n}\n\nint\nresponse(void)\n{\n\tchar ch, *cp, resp, rbuf[2048], visbuf[2048];\n\n\tif (atomicio(read, remin, &resp, sizeof(resp)) != sizeof(resp))\n\t\tlostconn(0);\n\n\tcp = rbuf;\n\tswitch (resp) {\n\tcase 0:\t\t/* ok */\n\t\treturn (0);\n\tdefault:\n\t\t*cp++ = resp;\n\t\t/* FALLTHROUGH */\n\tcase 1:\t\t/* error, followed by error msg */\n\tcase 2:\t\t/* fatal error, \"\" */\n\t\tdo {\n\t\t\tif (atomicio(read, remin, &ch, sizeof(ch)) != sizeof(ch))\n\t\t\t\tlostconn(0);\n\t\t\t*cp++ = ch;\n\t\t} while (cp < &rbuf[sizeof(rbuf) - 1] && ch != '\\n');\n\n\t\tif (!iamremote) {\n\t\t\tcp[-1] = '\\0';\n\t\t\t(void) snmprintf(visbuf, sizeof(visbuf),\n\t\t\t    NULL, \"%s\\n\", rbuf);\n\t\t\t(void) atomicio(vwrite, STDERR_FILENO,\n\t\t\t    visbuf, strlen(visbuf));\n\t\t}\n\t\t++errs;\n\t\tif (resp == 1)\n\t\t\treturn (-1);\n\t\texit(1);\n\t}\n\t/* NOTREACHED */\n}\n\nvoid\nusage(void)\n{\n\t(void) fprintf(stderr,\n\t    \"usage: scp [-346BCpqrTv] [-c cipher] [-F ssh_config] [-i identity_file]\\n\"\n\t    \"            [-J destination] [-l limit] [-o ssh_option] [-P port]\\n\"\n\t    \"            [-S program] source ... target\\n\");\n\texit(1);\n}\n\nvoid\nrun_err(const char *fmt,...)\n{\n\tstatic FILE *fp;\n\tva_list ap;\n\n\t++errs;\n\tif (fp != NULL || (remout != -1 && (fp = fdopen(remout, \"w\")))) {\n\t\t(void) fprintf(fp, \"%c\", 0x01);\n\t\t(void) fprintf(fp, \"scp: \");\n\t\tva_start(ap, fmt);\n\t\t(void) vfprintf(fp, fmt, ap);\n\t\tva_end(ap);\n\t\t(void) fprintf(fp, \"\\n\");\n\t\t(void) fflush(fp);\n\t}\n\n\tif (!iamremote) {\n\t\tva_start(ap, fmt);\n\t\tvfmprintf(stderr, fmt, ap);\n\t\tva_end(ap);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}\n\n/*\n * Notes a sink error for sending at the end of a file transfer. Returns 0 if\n * no error has been noted or -1 otherwise. Use note_err(NULL) to flush\n * any active error at the end of the transfer.\n */\nint\nnote_err(const char *fmt, ...)\n{\n\tstatic char *emsg;\n\tva_list ap;\n\n\t/* Replay any previously-noted error */\n\tif (fmt == NULL) {\n\t\tif (emsg == NULL)\n\t\t\treturn 0;\n\t\trun_err(\"%s\", emsg);\n\t\tfree(emsg);\n\t\temsg = NULL;\n\t\treturn -1;\n\t}\n\n\terrs++;\n\t/* Prefer first-noted error */\n\tif (emsg != NULL)\n\t\treturn -1;\n\n\tva_start(ap, fmt);\n\tvasnmprintf(&emsg, INT_MAX, NULL, fmt, ap);\n\tva_end(ap);\n\treturn -1;\n}\n\nvoid\nverifydir(char *cp)\n{\n\tstruct stat stb;\n\n\tif (!stat(cp, &stb)) {\n\t\tif (S_ISDIR(stb.st_mode))\n\t\t\treturn;\n\t\terrno = ENOTDIR;\n\t}\n\trun_err(\"%s: %s\", cp, strerror(errno));\n\tkillchild(0);\n}\n\nint\nokname(char *cp0)\n{\n\tint c;\n\tchar *cp;\n\n\tcp = cp0;\n\tdo {\n\t\tc = (int)*cp;\n\t\tif (c & 0200)\n\t\t\tgoto bad;\n\t\tif (!isalpha(c) && !isdigit((unsigned char)c)) {\n\t\t\tswitch (c) {\n\t\t\tcase '\\'':\n\t\t\tcase '\"':\n\t\t\tcase '`':\n\t\t\tcase ' ':\n\t\t\tcase '#':\n\t\t\t\tgoto bad;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} while (*++cp);\n\treturn (1);\n\nbad:\tfmprintf(stderr, \"%s: invalid user name\\n\", cp0);\n\treturn (0);\n}\n\nBUF *\nallocbuf(BUF *bp, int fd, int blksize)\n{\n\tsize_t size;\n#ifdef HAVE_STRUCT_STAT_ST_BLKSIZE\n\tstruct stat stb;\n\n\tif (fstat(fd, &stb) == -1) {\n\t\trun_err(\"fstat: %s\", strerror(errno));\n\t\treturn (0);\n\t}\n\tsize = ROUNDUP(stb.st_blksize, blksize);\n\tif (size == 0)\n\t\tsize = blksize;\n#else /* HAVE_STRUCT_STAT_ST_BLKSIZE */\n\tsize = blksize;\n#endif /* HAVE_STRUCT_STAT_ST_BLKSIZE */\n\tif (bp->cnt >= size)\n\t\treturn (bp);\n\tbp->buf = xrecallocarray(bp->buf, bp->cnt, size, 1);\n\tbp->cnt = size;\n\treturn (bp);\n}\n\nvoid\nlostconn(int signo)\n{\n\tif (!iamremote)\n\t\t(void)write(STDERR_FILENO, \"lost connection\\n\", 16);\n\tif (signo)\n\t\t_exit(1);\n\telse\n\t\texit(1);\n}\n"], "fixing_code": ["/* $OpenBSD: scp.c,v 1.210 2020/05/06 20:57:38 djm Exp $ */\n/*\n * scp - secure remote copy.  This is basically patched BSD rcp which\n * uses ssh to do the data transfer (instead of using rcmd).\n *\n * NOTE: This version should NOT be suid root.  (This uses ssh to\n * do the transfer and ssh has the necessary privileges.)\n *\n * 1995 Timo Rinne <tri@iki.fi>, Tatu Ylonen <ylo@cs.hut.fi>\n *\n * As far as I am concerned, the code I have written for this software\n * can be used freely for any purpose.  Any derived versions of this\n * software must be clearly marked as such, and if the derived work is\n * incompatible with the protocol description in the RFC file, it must be\n * called by a name other than \"ssh\" or \"Secure Shell\".\n */\n/*\n * Copyright (c) 1999 Theo de Raadt.  All rights reserved.\n * Copyright (c) 1999 Aaron Campbell.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*\n * Parts from:\n *\n * Copyright (c) 1983, 1990, 1992, 1993, 1995\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the University nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n *\n */\n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#ifdef HAVE_SYS_STAT_H\n# include <sys/stat.h>\n#endif\n#ifdef HAVE_POLL_H\n#include <poll.h>\n#else\n# ifdef HAVE_SYS_POLL_H\n#  include <sys/poll.h>\n# endif\n#endif\n#ifdef HAVE_SYS_TIME_H\n# include <sys/time.h>\n#endif\n#include <sys/wait.h>\n#include <sys/uio.h>\n\n#include <ctype.h>\n#include <dirent.h>\n#include <errno.h>\n#include <fcntl.h>\n#ifdef HAVE_FNMATCH_H\n#include <fnmatch.h>\n#endif\n#include <limits.h>\n#include <locale.h>\n#include <pwd.h>\n#include <signal.h>\n#include <stdarg.h>\n#ifdef HAVE_STDINT_H\n# include <stdint.h>\n#endif\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n#if defined(HAVE_STRNVIS) && defined(HAVE_VIS_H) && !defined(BROKEN_STRNVIS)\n#include <vis.h>\n#endif\n\n#include \"xmalloc.h\"\n#include \"ssh.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"utf8.h\"\n\nextern char *__progname;\n\n#define COPY_BUFLEN\t16384\n\nint do_cmd(char *host, char *remuser, int port, char *cmd, int *fdin, int *fdout);\nint do_cmd2(char *host, char *remuser, int port, char *cmd, int fdin, int fdout);\n\n/* Struct for addargs */\narglist args;\narglist remote_remote_args;\n\n/* Bandwidth limit */\nlong long limit_kbps = 0;\nstruct bwlimit bwlimit;\n\n/* Name of current file being transferred. */\nchar *curfile;\n\n/* This is set to non-zero to enable verbose mode. */\nint verbose_mode = 0;\n\n/* This is set to zero if the progressmeter is not desired. */\nint showprogress = 1;\n\n/*\n * This is set to non-zero if remote-remote copy should be piped\n * through this process.\n */\nint throughlocal = 0;\n\n/* Non-standard port to use for the ssh connection or -1. */\nint sshport = -1;\n\n/* This is the program to execute for the secured connection. (\"ssh\" or -S) */\nchar *ssh_program = _PATH_SSH_PROGRAM;\n\n/* This is used to store the pid of ssh_program */\npid_t do_cmd_pid = -1;\n\nstatic void\nkillchild(int signo)\n{\n\tif (do_cmd_pid > 1) {\n\t\tkill(do_cmd_pid, signo ? signo : SIGTERM);\n\t\twaitpid(do_cmd_pid, NULL, 0);\n\t}\n\n\tif (signo)\n\t\t_exit(1);\n\texit(1);\n}\n\nstatic void\nsuspchild(int signo)\n{\n\tint status;\n\n\tif (do_cmd_pid > 1) {\n\t\tkill(do_cmd_pid, signo);\n\t\twhile (waitpid(do_cmd_pid, &status, WUNTRACED) == -1 &&\n\t\t    errno == EINTR)\n\t\t\t;\n\t\tkill(getpid(), SIGSTOP);\n\t}\n}\n\nstatic int\ndo_local_cmd(arglist *a)\n{\n\tu_int i;\n\tint status;\n\tpid_t pid;\n\n\tif (a->num == 0)\n\t\tfatal(\"do_local_cmd: no arguments\");\n\n\tif (verbose_mode) {\n\t\tfprintf(stderr, \"Executing:\");\n\t\tfor (i = 0; i < a->num; i++)\n\t\t\tfmprintf(stderr, \" %s\", a->list[i]);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n\tif ((pid = fork()) == -1)\n\t\tfatal(\"do_local_cmd: fork: %s\", strerror(errno));\n\n\tif (pid == 0) {\n\t\texecvp(a->list[0], a->list);\n\t\tperror(a->list[0]);\n\t\texit(1);\n\t}\n\n\tdo_cmd_pid = pid;\n\tssh_signal(SIGTERM, killchild);\n\tssh_signal(SIGINT, killchild);\n\tssh_signal(SIGHUP, killchild);\n\n\twhile (waitpid(pid, &status, 0) == -1)\n\t\tif (errno != EINTR)\n\t\t\tfatal(\"do_local_cmd: waitpid: %s\", strerror(errno));\n\n\tdo_cmd_pid = -1;\n\n\tif (!WIFEXITED(status) || WEXITSTATUS(status) != 0)\n\t\treturn (-1);\n\n\treturn (0);\n}\n\n/*\n * This function executes the given command as the specified user on the\n * given host.  This returns < 0 if execution fails, and >= 0 otherwise. This\n * assigns the input and output file descriptors on success.\n */\n\nint\ndo_cmd(char *host, char *remuser, int port, char *cmd, int *fdin, int *fdout)\n{\n\tint pin[2], pout[2], reserved[2];\n\n\tif (verbose_mode)\n\t\tfmprintf(stderr,\n\t\t    \"Executing: program %s host %s, user %s, command %s\\n\",\n\t\t    ssh_program, host,\n\t\t    remuser ? remuser : \"(unspecified)\", cmd);\n\n\tif (port == -1)\n\t\tport = sshport;\n\n\t/*\n\t * Reserve two descriptors so that the real pipes won't get\n\t * descriptors 0 and 1 because that will screw up dup2 below.\n\t */\n\tif (pipe(reserved) == -1)\n\t\tfatal(\"pipe: %s\", strerror(errno));\n\n\t/* Create a socket pair for communicating with ssh. */\n\tif (pipe(pin) == -1)\n\t\tfatal(\"pipe: %s\", strerror(errno));\n\tif (pipe(pout) == -1)\n\t\tfatal(\"pipe: %s\", strerror(errno));\n\n\t/* Free the reserved descriptors. */\n\tclose(reserved[0]);\n\tclose(reserved[1]);\n\n\tssh_signal(SIGTSTP, suspchild);\n\tssh_signal(SIGTTIN, suspchild);\n\tssh_signal(SIGTTOU, suspchild);\n\n\t/* Fork a child to execute the command on the remote host using ssh. */\n\tdo_cmd_pid = fork();\n\tif (do_cmd_pid == 0) {\n\t\t/* Child. */\n\t\tclose(pin[1]);\n\t\tclose(pout[0]);\n\t\tdup2(pin[0], 0);\n\t\tdup2(pout[1], 1);\n\t\tclose(pin[0]);\n\t\tclose(pout[1]);\n\n\t\treplacearg(&args, 0, \"%s\", ssh_program);\n\t\tif (port != -1) {\n\t\t\taddargs(&args, \"-p\");\n\t\t\taddargs(&args, \"%d\", port);\n\t\t}\n\t\tif (remuser != NULL) {\n\t\t\taddargs(&args, \"-l\");\n\t\t\taddargs(&args, \"%s\", remuser);\n\t\t}\n\t\taddargs(&args, \"--\");\n\t\taddargs(&args, \"%s\", host);\n\t\taddargs(&args, \"%s\", cmd);\n\n\t\texecvp(ssh_program, args.list);\n\t\tperror(ssh_program);\n\t\texit(1);\n\t} else if (do_cmd_pid == -1) {\n\t\tfatal(\"fork: %s\", strerror(errno));\n\t}\n\t/* Parent.  Close the other side, and return the local side. */\n\tclose(pin[0]);\n\t*fdout = pin[1];\n\tclose(pout[1]);\n\t*fdin = pout[0];\n\tssh_signal(SIGTERM, killchild);\n\tssh_signal(SIGINT, killchild);\n\tssh_signal(SIGHUP, killchild);\n\treturn 0;\n}\n\n/*\n * This function executes a command similar to do_cmd(), but expects the\n * input and output descriptors to be setup by a previous call to do_cmd().\n * This way the input and output of two commands can be connected.\n */\nint\ndo_cmd2(char *host, char *remuser, int port, char *cmd, int fdin, int fdout)\n{\n\tpid_t pid;\n\tint status;\n\n\tif (verbose_mode)\n\t\tfmprintf(stderr,\n\t\t    \"Executing: 2nd program %s host %s, user %s, command %s\\n\",\n\t\t    ssh_program, host,\n\t\t    remuser ? remuser : \"(unspecified)\", cmd);\n\n\tif (port == -1)\n\t\tport = sshport;\n\n\t/* Fork a child to execute the command on the remote host using ssh. */\n\tpid = fork();\n\tif (pid == 0) {\n\t\tdup2(fdin, 0);\n\t\tdup2(fdout, 1);\n\n\t\treplacearg(&args, 0, \"%s\", ssh_program);\n\t\tif (port != -1) {\n\t\t\taddargs(&args, \"-p\");\n\t\t\taddargs(&args, \"%d\", port);\n\t\t}\n\t\tif (remuser != NULL) {\n\t\t\taddargs(&args, \"-l\");\n\t\t\taddargs(&args, \"%s\", remuser);\n\t\t}\n\t\taddargs(&args, \"-oBatchMode=yes\");\n\t\taddargs(&args, \"--\");\n\t\taddargs(&args, \"%s\", host);\n\t\taddargs(&args, \"%s\", cmd);\n\n\t\texecvp(ssh_program, args.list);\n\t\tperror(ssh_program);\n\t\texit(1);\n\t} else if (pid == -1) {\n\t\tfatal(\"fork: %s\", strerror(errno));\n\t}\n\twhile (waitpid(pid, &status, 0) == -1)\n\t\tif (errno != EINTR)\n\t\t\tfatal(\"do_cmd2: waitpid: %s\", strerror(errno));\n\treturn 0;\n}\n\ntypedef struct {\n\tsize_t cnt;\n\tchar *buf;\n} BUF;\n\nBUF *allocbuf(BUF *, int, int);\nvoid lostconn(int);\nint okname(char *);\nvoid run_err(const char *,...);\nint note_err(const char *,...);\nvoid verifydir(char *);\n\nstruct passwd *pwd;\nuid_t userid;\nint errs, remin, remout;\nint Tflag, pflag, iamremote, iamrecursive, targetshouldbedirectory;\n\n#define\tCMDNEEDS\t64\nchar cmd[CMDNEEDS];\t\t/* must hold \"rcp -r -p -d\\0\" */\n\nint response(void);\nvoid rsource(char *, struct stat *);\nvoid sink(int, char *[], const char *);\nvoid source(int, char *[]);\nvoid tolocal(int, char *[]);\nvoid toremote(int, char *[]);\nvoid usage(void);\n\nint\nmain(int argc, char **argv)\n{\n\tint ch, fflag, tflag, status, n;\n\tchar **newargv;\n\tconst char *errstr;\n\textern char *optarg;\n\textern int optind;\n\n\t/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */\n\tsanitise_stdfd();\n\n\tseed_rng();\n\n\tmsetlocale();\n\n\t/* Copy argv, because we modify it */\n\tnewargv = xcalloc(MAXIMUM(argc + 1, 1), sizeof(*newargv));\n\tfor (n = 0; n < argc; n++)\n\t\tnewargv[n] = xstrdup(argv[n]);\n\targv = newargv;\n\n\t__progname = ssh_get_progname(argv[0]);\n\n\tmemset(&args, '\\0', sizeof(args));\n\tmemset(&remote_remote_args, '\\0', sizeof(remote_remote_args));\n\targs.list = remote_remote_args.list = NULL;\n\taddargs(&args, \"%s\", ssh_program);\n\taddargs(&args, \"-x\");\n\taddargs(&args, \"-oForwardAgent=no\");\n\taddargs(&args, \"-oPermitLocalCommand=no\");\n\taddargs(&args, \"-oClearAllForwardings=yes\");\n\taddargs(&args, \"-oRemoteCommand=none\");\n\taddargs(&args, \"-oRequestTTY=no\");\n\n\tfflag = Tflag = tflag = 0;\n\twhile ((ch = getopt(argc, argv,\n\t    \"dfl:prtTvBCc:i:P:q12346S:o:F:J:\")) != -1) {\n\t\tswitch (ch) {\n\t\t/* User-visible flags. */\n\t\tcase '1':\n\t\t\tfatal(\"SSH protocol v.1 is no longer supported\");\n\t\t\tbreak;\n\t\tcase '2':\n\t\t\t/* Ignored */\n\t\t\tbreak;\n\t\tcase '4':\n\t\tcase '6':\n\t\tcase 'C':\n\t\t\taddargs(&args, \"-%c\", ch);\n\t\t\taddargs(&remote_remote_args, \"-%c\", ch);\n\t\t\tbreak;\n\t\tcase '3':\n\t\t\tthroughlocal = 1;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\tcase 'c':\n\t\tcase 'i':\n\t\tcase 'F':\n\t\tcase 'J':\n\t\t\taddargs(&remote_remote_args, \"-%c\", ch);\n\t\t\taddargs(&remote_remote_args, \"%s\", optarg);\n\t\t\taddargs(&args, \"-%c\", ch);\n\t\t\taddargs(&args, \"%s\", optarg);\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tsshport = a2port(optarg);\n\t\t\tif (sshport <= 0)\n\t\t\t\tfatal(\"bad port \\\"%s\\\"\\n\", optarg);\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\taddargs(&remote_remote_args, \"-oBatchmode=yes\");\n\t\t\taddargs(&args, \"-oBatchmode=yes\");\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tlimit_kbps = strtonum(optarg, 1, 100 * 1024 * 1024,\n\t\t\t    &errstr);\n\t\t\tif (errstr != NULL)\n\t\t\t\tusage();\n\t\t\tlimit_kbps *= 1024; /* kbps */\n\t\t\tbandwidth_limit_init(&bwlimit, limit_kbps, COPY_BUFLEN);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tpflag = 1;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tiamrecursive = 1;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tssh_program = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\taddargs(&args, \"-v\");\n\t\t\taddargs(&remote_remote_args, \"-v\");\n\t\t\tverbose_mode = 1;\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\taddargs(&args, \"-q\");\n\t\t\taddargs(&remote_remote_args, \"-q\");\n\t\t\tshowprogress = 0;\n\t\t\tbreak;\n\n\t\t/* Server options. */\n\t\tcase 'd':\n\t\t\ttargetshouldbedirectory = 1;\n\t\t\tbreak;\n\t\tcase 'f':\t/* \"from\" */\n\t\t\tiamremote = 1;\n\t\t\tfflag = 1;\n\t\t\tbreak;\n\t\tcase 't':\t/* \"to\" */\n\t\t\tiamremote = 1;\n\t\t\ttflag = 1;\n#ifdef HAVE_CYGWIN\n\t\t\tsetmode(0, O_BINARY);\n#endif\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tTflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\t}\n\targc -= optind;\n\targv += optind;\n\n\tif ((pwd = getpwuid(userid = getuid())) == NULL)\n\t\tfatal(\"unknown user %u\", (u_int) userid);\n\n\tif (!isatty(STDOUT_FILENO))\n\t\tshowprogress = 0;\n\n\tif (pflag) {\n\t\t/* Cannot pledge: -p allows setuid/setgid files... */\n\t} else {\n\t\tif (pledge(\"stdio rpath wpath cpath fattr tty proc exec\",\n\t\t    NULL) == -1) {\n\t\t\tperror(\"pledge\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tremin = STDIN_FILENO;\n\tremout = STDOUT_FILENO;\n\n\tif (fflag) {\n\t\t/* Follow \"protocol\", send data. */\n\t\t(void) response();\n\t\tsource(argc, argv);\n\t\texit(errs != 0);\n\t}\n\tif (tflag) {\n\t\t/* Receive data. */\n\t\tsink(argc, argv, NULL);\n\t\texit(errs != 0);\n\t}\n\tif (argc < 2)\n\t\tusage();\n\tif (argc > 2)\n\t\ttargetshouldbedirectory = 1;\n\n\tremin = remout = -1;\n\tdo_cmd_pid = -1;\n\t/* Command to be executed on remote system using \"ssh\". */\n\t(void) snprintf(cmd, sizeof cmd, \"scp%s%s%s%s\",\n\t    verbose_mode ? \" -v\" : \"\",\n\t    iamrecursive ? \" -r\" : \"\", pflag ? \" -p\" : \"\",\n\t    targetshouldbedirectory ? \" -d\" : \"\");\n\n\t(void) ssh_signal(SIGPIPE, lostconn);\n\n\tif (colon(argv[argc - 1]))\t/* Dest is remote host. */\n\t\ttoremote(argc, argv);\n\telse {\n\t\tif (targetshouldbedirectory)\n\t\t\tverifydir(argv[argc - 1]);\n\t\ttolocal(argc, argv);\t/* Dest is local host. */\n\t}\n\t/*\n\t * Finally check the exit status of the ssh process, if one was forked\n\t * and no error has occurred yet\n\t */\n\tif (do_cmd_pid != -1 && errs == 0) {\n\t\tif (remin != -1)\n\t\t    (void) close(remin);\n\t\tif (remout != -1)\n\t\t    (void) close(remout);\n\t\tif (waitpid(do_cmd_pid, &status, 0) == -1)\n\t\t\terrs = 1;\n\t\telse {\n\t\t\tif (!WIFEXITED(status) || WEXITSTATUS(status) != 0)\n\t\t\t\terrs = 1;\n\t\t}\n\t}\n\texit(errs != 0);\n}\n\n/* Callback from atomicio6 to update progress meter and limit bandwidth */\nstatic int\nscpio(void *_cnt, size_t s)\n{\n\toff_t *cnt = (off_t *)_cnt;\n\n\t*cnt += s;\n\trefresh_progress_meter(0);\n\tif (limit_kbps > 0)\n\t\tbandwidth_limit(&bwlimit, s);\n\treturn 0;\n}\n\nstatic int\ndo_times(int fd, int verb, const struct stat *sb)\n{\n\t/* strlen(2^64) == 20; strlen(10^6) == 7 */\n\tchar buf[(20 + 7 + 2) * 2 + 2];\n\n\t(void)snprintf(buf, sizeof(buf), \"T%llu 0 %llu 0\\n\",\n\t    (unsigned long long) (sb->st_mtime < 0 ? 0 : sb->st_mtime),\n\t    (unsigned long long) (sb->st_atime < 0 ? 0 : sb->st_atime));\n\tif (verb) {\n\t\tfprintf(stderr, \"File mtime %lld atime %lld\\n\",\n\t\t    (long long)sb->st_mtime, (long long)sb->st_atime);\n\t\tfprintf(stderr, \"Sending file timestamps: %s\", buf);\n\t}\n\t(void) atomicio(vwrite, fd, buf, strlen(buf));\n\treturn (response());\n}\n\nstatic int\nparse_scp_uri(const char *uri, char **userp, char **hostp, int *portp,\n     char **pathp)\n{\n\tint r;\n\n\tr = parse_uri(\"scp\", uri, userp, hostp, portp, pathp);\n\tif (r == 0 && *pathp == NULL)\n\t\t*pathp = xstrdup(\".\");\n\treturn r;\n}\n\n/* Appends a string to an array; returns 0 on success, -1 on alloc failure */\nstatic int\nappend(char *cp, char ***ap, size_t *np)\n{\n\tchar **tmp;\n\n\tif ((tmp = reallocarray(*ap, *np + 1, sizeof(*tmp))) == NULL)\n\t\treturn -1;\n\ttmp[(*np)] = cp;\n\t(*np)++;\n\t*ap = tmp;\n\treturn 0;\n}\n\n/*\n * Finds the start and end of the first brace pair in the pattern.\n * returns 0 on success or -1 for invalid patterns.\n */\nstatic int\nfind_brace(const char *pattern, int *startp, int *endp)\n{\n\tint i;\n\tint in_bracket, brace_level;\n\n\t*startp = *endp = -1;\n\tin_bracket = brace_level = 0;\n\tfor (i = 0; i < INT_MAX && *endp < 0 && pattern[i] != '\\0'; i++) {\n\t\tswitch (pattern[i]) {\n\t\tcase '\\\\':\n\t\t\t/* skip next character */\n\t\t\tif (pattern[i + 1] != '\\0')\n\t\t\t\ti++;\n\t\t\tbreak;\n\t\tcase '[':\n\t\t\tin_bracket = 1;\n\t\t\tbreak;\n\t\tcase ']':\n\t\t\tin_bracket = 0;\n\t\t\tbreak;\n\t\tcase '{':\n\t\t\tif (in_bracket)\n\t\t\t\tbreak;\n\t\t\tif (pattern[i + 1] == '}') {\n\t\t\t\t/* Protect a single {}, for find(1), like csh */\n\t\t\t\ti++; /* skip */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (*startp == -1)\n\t\t\t\t*startp = i;\n\t\t\tbrace_level++;\n\t\t\tbreak;\n\t\tcase '}':\n\t\t\tif (in_bracket)\n\t\t\t\tbreak;\n\t\t\tif (*startp < 0) {\n\t\t\t\t/* Unbalanced brace */\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (--brace_level <= 0)\n\t\t\t\t*endp = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* unbalanced brackets/braces */\n\tif (*endp < 0 && (*startp >= 0 || in_bracket))\n\t\treturn -1;\n\treturn 0;\n}\n\n/*\n * Assembles and records a successfully-expanded pattern, returns -1 on\n * alloc failure.\n */\nstatic int\nemit_expansion(const char *pattern, int brace_start, int brace_end,\n    int sel_start, int sel_end, char ***patternsp, size_t *npatternsp)\n{\n\tchar *cp;\n\tint o = 0, tail_len = strlen(pattern + brace_end + 1);\n\n\tif ((cp = malloc(brace_start + (sel_end - sel_start) +\n\t    tail_len + 1)) == NULL)\n\t\treturn -1;\n\n\t/* Pattern before initial brace */\n\tif (brace_start > 0) {\n\t\tmemcpy(cp, pattern, brace_start);\n\t\to = brace_start;\n\t}\n\t/* Current braced selection */\n\tif (sel_end - sel_start > 0) {\n\t\tmemcpy(cp + o, pattern + sel_start,\n\t\t    sel_end - sel_start);\n\t\to += sel_end - sel_start;\n\t}\n\t/* Remainder of pattern after closing brace */\n\tif (tail_len > 0) {\n\t\tmemcpy(cp + o, pattern + brace_end + 1, tail_len);\n\t\to += tail_len;\n\t}\n\tcp[o] = '\\0';\n\tif (append(cp, patternsp, npatternsp) != 0) {\n\t\tfree(cp);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/*\n * Expand the first encountered brace in pattern, appending the expanded\n * patterns it yielded to the *patternsp array.\n *\n * Returns 0 on success or -1 on allocation failure.\n *\n * Signals whether expansion was performed via *expanded and whether\n * pattern was invalid via *invalid.\n */\nstatic int\nbrace_expand_one(const char *pattern, char ***patternsp, size_t *npatternsp,\n    int *expanded, int *invalid)\n{\n\tint i;\n\tint in_bracket, brace_start, brace_end, brace_level;\n\tint sel_start, sel_end;\n\n\t*invalid = *expanded = 0;\n\n\tif (find_brace(pattern, &brace_start, &brace_end) != 0) {\n\t\t*invalid = 1;\n\t\treturn 0;\n\t} else if (brace_start == -1)\n\t\treturn 0;\n\n\tin_bracket = brace_level = 0;\n\tfor (i = sel_start = brace_start + 1; i < brace_end; i++) {\n\t\tswitch (pattern[i]) {\n\t\tcase '{':\n\t\t\tif (in_bracket)\n\t\t\t\tbreak;\n\t\t\tbrace_level++;\n\t\t\tbreak;\n\t\tcase '}':\n\t\t\tif (in_bracket)\n\t\t\t\tbreak;\n\t\t\tbrace_level--;\n\t\t\tbreak;\n\t\tcase '[':\n\t\t\tin_bracket = 1;\n\t\t\tbreak;\n\t\tcase ']':\n\t\t\tin_bracket = 0;\n\t\t\tbreak;\n\t\tcase '\\\\':\n\t\t\tif (i < brace_end - 1)\n\t\t\t\ti++; /* skip */\n\t\t\tbreak;\n\t\t}\n\t\tif (pattern[i] == ',' || i == brace_end - 1) {\n\t\t\tif (in_bracket || brace_level > 0)\n\t\t\t\tcontinue;\n\t\t\t/* End of a selection, emit an expanded pattern */\n\n\t\t\t/* Adjust end index for last selection */\n\t\t\tsel_end = (i == brace_end - 1) ? brace_end : i;\n\t\t\tif (emit_expansion(pattern, brace_start, brace_end,\n\t\t\t    sel_start, sel_end, patternsp, npatternsp) != 0)\n\t\t\t\treturn -1;\n\t\t\t/* move on to the next selection */\n\t\t\tsel_start = i + 1;\n\t\t\tcontinue;\n\t\t}\n\t}\n\tif (in_bracket || brace_level > 0) {\n\t\t*invalid = 1;\n\t\treturn 0;\n\t}\n\t/* success */\n\t*expanded = 1;\n\treturn 0;\n}\n\n/* Expand braces from pattern. Returns 0 on success, -1 on failure */\nstatic int\nbrace_expand(const char *pattern, char ***patternsp, size_t *npatternsp)\n{\n\tchar *cp, *cp2, **active = NULL, **done = NULL;\n\tsize_t i, nactive = 0, ndone = 0;\n\tint ret = -1, invalid = 0, expanded = 0;\n\n\t*patternsp = NULL;\n\t*npatternsp = 0;\n\n\t/* Start the worklist with the original pattern */\n\tif ((cp = strdup(pattern)) == NULL)\n\t\treturn -1;\n\tif (append(cp, &active, &nactive) != 0) {\n\t\tfree(cp);\n\t\treturn -1;\n\t}\n\twhile (nactive > 0) {\n\t\tcp = active[nactive - 1];\n\t\tnactive--;\n\t\tif (brace_expand_one(cp, &active, &nactive,\n\t\t    &expanded, &invalid) == -1) {\n\t\t\tfree(cp);\n\t\t\tgoto fail;\n\t\t}\n\t\tif (invalid)\n\t\t\tfatal(\"%s: invalid brace pattern \\\"%s\\\"\", __func__, cp);\n\t\tif (expanded) {\n\t\t\t/*\n\t\t\t * Current entry expanded to new entries on the\n\t\t\t * active list; discard the progenitor pattern.\n\t\t\t */\n\t\t\tfree(cp);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Pattern did not expand; append the finename component to\n\t\t * the completed list\n\t\t */\n\t\tif ((cp2 = strrchr(cp, '/')) != NULL)\n\t\t\t*cp2++ = '\\0';\n\t\telse\n\t\t\tcp2 = cp;\n\t\tif (append(xstrdup(cp2), &done, &ndone) != 0) {\n\t\t\tfree(cp);\n\t\t\tgoto fail;\n\t\t}\n\t\tfree(cp);\n\t}\n\t/* success */\n\t*patternsp = done;\n\t*npatternsp = ndone;\n\tdone = NULL;\n\tndone = 0;\n\tret = 0;\n fail:\n\tfor (i = 0; i < nactive; i++)\n\t\tfree(active[i]);\n\tfree(active);\n\tfor (i = 0; i < ndone; i++)\n\t\tfree(done[i]);\n\tfree(done);\n\treturn ret;\n}\n\nvoid\ntoremote(int argc, char **argv)\n{\n\tchar *suser = NULL, *host = NULL, *src = NULL;\n\tchar *bp, *tuser, *thost, *targ;\n\tint sport = -1, tport = -1;\n\targlist alist;\n\tint i, r;\n\tu_int j;\n\n\tmemset(&alist, '\\0', sizeof(alist));\n\talist.list = NULL;\n\n\t/* Parse target */\n\tr = parse_scp_uri(argv[argc - 1], &tuser, &thost, &tport, &targ);\n\tif (r == -1) {\n\t\tfmprintf(stderr, \"%s: invalid uri\\n\", argv[argc - 1]);\n\t\t++errs;\n\t\tgoto out;\n\t}\n\tif (r != 0) {\n\t\tif (parse_user_host_path(argv[argc - 1], &tuser, &thost,\n\t\t    &targ) == -1) {\n\t\t\tfmprintf(stderr, \"%s: invalid target\\n\", argv[argc - 1]);\n\t\t\t++errs;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (tuser != NULL && !okname(tuser)) {\n\t\t++errs;\n\t\tgoto out;\n\t}\n\n\t/* Parse source files */\n\tfor (i = 0; i < argc - 1; i++) {\n\t\tfree(suser);\n\t\tfree(host);\n\t\tfree(src);\n\t\tr = parse_scp_uri(argv[i], &suser, &host, &sport, &src);\n\t\tif (r == -1) {\n\t\t\tfmprintf(stderr, \"%s: invalid uri\\n\", argv[i]);\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tif (r != 0) {\n\t\t\tparse_user_host_path(argv[i], &suser, &host, &src);\n\t\t}\n\t\tif (suser != NULL && !okname(suser)) {\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tif (host && throughlocal) {\t/* extended remote to remote */\n\t\t\txasprintf(&bp, \"%s -f %s%s\", cmd,\n\t\t\t    *src == '-' ? \"-- \" : \"\", src);\n\t\t\tif (do_cmd(host, suser, sport, bp, &remin, &remout) < 0)\n\t\t\t\texit(1);\n\t\t\tfree(bp);\n\t\t\txasprintf(&bp, \"%s -t %s%s\", cmd,\n\t\t\t    *targ == '-' ? \"-- \" : \"\", targ);\n\t\t\tif (do_cmd2(thost, tuser, tport, bp, remin, remout) < 0)\n\t\t\t\texit(1);\n\t\t\tfree(bp);\n\t\t\t(void) close(remin);\n\t\t\t(void) close(remout);\n\t\t\tremin = remout = -1;\n\t\t} else if (host) {\t/* standard remote to remote */\n\t\t\tif (tport != -1 && tport != SSH_DEFAULT_PORT) {\n\t\t\t\t/* This would require the remote support URIs */\n\t\t\t\tfatal(\"target port not supported with two \"\n\t\t\t\t    \"remote hosts without the -3 option\");\n\t\t\t}\n\n\t\t\tfreeargs(&alist);\n\t\t\taddargs(&alist, \"%s\", ssh_program);\n\t\t\taddargs(&alist, \"-x\");\n\t\t\taddargs(&alist, \"-oClearAllForwardings=yes\");\n\t\t\taddargs(&alist, \"-n\");\n\t\t\tfor (j = 0; j < remote_remote_args.num; j++) {\n\t\t\t\taddargs(&alist, \"%s\",\n\t\t\t\t    remote_remote_args.list[j]);\n\t\t\t}\n\n\t\t\tif (sport != -1) {\n\t\t\t\taddargs(&alist, \"-p\");\n\t\t\t\taddargs(&alist, \"%d\", sport);\n\t\t\t}\n\t\t\tif (suser) {\n\t\t\t\taddargs(&alist, \"-l\");\n\t\t\t\taddargs(&alist, \"%s\", suser);\n\t\t\t}\n\t\t\taddargs(&alist, \"--\");\n\t\t\taddargs(&alist, \"%s\", host);\n\t\t\taddargs(&alist, \"%s\", cmd);\n\t\t\taddargs(&alist, \"%s\", src);\n\t\t\taddargs(&alist, \"%s%s%s:%s\",\n\t\t\t    tuser ? tuser : \"\", tuser ? \"@\" : \"\",\n\t\t\t    thost, targ);\n\t\t\tif (do_local_cmd(&alist) != 0)\n\t\t\t\terrs = 1;\n\t\t} else {\t/* local to remote */\n\t\t\tif (remin == -1) {\n\t\t\t\txasprintf(&bp, \"%s -t %s%s\", cmd,\n\t\t\t\t    *targ == '-' ? \"-- \" : \"\", targ);\n\t\t\t\tif (do_cmd(thost, tuser, tport, bp, &remin,\n\t\t\t\t    &remout) < 0)\n\t\t\t\t\texit(1);\n\t\t\t\tif (response() < 0)\n\t\t\t\t\texit(1);\n\t\t\t\tfree(bp);\n\t\t\t}\n\t\t\tsource(1, argv + i);\n\t\t}\n\t}\nout:\n\tfree(tuser);\n\tfree(thost);\n\tfree(targ);\n\tfree(suser);\n\tfree(host);\n\tfree(src);\n}\n\nvoid\ntolocal(int argc, char **argv)\n{\n\tchar *bp, *host = NULL, *src = NULL, *suser = NULL;\n\targlist alist;\n\tint i, r, sport = -1;\n\n\tmemset(&alist, '\\0', sizeof(alist));\n\talist.list = NULL;\n\n\tfor (i = 0; i < argc - 1; i++) {\n\t\tfree(suser);\n\t\tfree(host);\n\t\tfree(src);\n\t\tr = parse_scp_uri(argv[i], &suser, &host, &sport, &src);\n\t\tif (r == -1) {\n\t\t\tfmprintf(stderr, \"%s: invalid uri\\n\", argv[i]);\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tif (r != 0)\n\t\t\tparse_user_host_path(argv[i], &suser, &host, &src);\n\t\tif (suser != NULL && !okname(suser)) {\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!host) {\t/* Local to local. */\n\t\t\tfreeargs(&alist);\n\t\t\taddargs(&alist, \"%s\", _PATH_CP);\n\t\t\tif (iamrecursive)\n\t\t\t\taddargs(&alist, \"-r\");\n\t\t\tif (pflag)\n\t\t\t\taddargs(&alist, \"-p\");\n\t\t\taddargs(&alist, \"--\");\n\t\t\taddargs(&alist, \"%s\", argv[i]);\n\t\t\taddargs(&alist, \"%s\", argv[argc-1]);\n\t\t\tif (do_local_cmd(&alist))\n\t\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Remote to local. */\n\t\txasprintf(&bp, \"%s -f %s%s\",\n\t\t    cmd, *src == '-' ? \"-- \" : \"\", src);\n\t\tif (do_cmd(host, suser, sport, bp, &remin, &remout) < 0) {\n\t\t\tfree(bp);\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tfree(bp);\n\t\tsink(1, argv + argc - 1, src);\n\t\t(void) close(remin);\n\t\tremin = remout = -1;\n\t}\n\tfree(suser);\n\tfree(host);\n\tfree(src);\n}\n\nvoid\nsource(int argc, char **argv)\n{\n\tstruct stat stb;\n\tstatic BUF buffer;\n\tBUF *bp;\n\toff_t i, statbytes;\n\tsize_t amt, nr;\n\tint fd = -1, haderr, indx;\n\tchar *last, *name, buf[PATH_MAX + 128], encname[PATH_MAX];\n\tint len;\n\n\tfor (indx = 0; indx < argc; ++indx) {\n\t\tname = argv[indx];\n\t\tstatbytes = 0;\n\t\tlen = strlen(name);\n\t\twhile (len > 1 && name[len-1] == '/')\n\t\t\tname[--len] = '\\0';\n\t\tif ((fd = open(name, O_RDONLY|O_NONBLOCK, 0)) == -1)\n\t\t\tgoto syserr;\n\t\tif (strchr(name, '\\n') != NULL) {\n\t\t\tstrnvis(encname, name, sizeof(encname), VIS_NL);\n\t\t\tname = encname;\n\t\t}\n\t\tif (fstat(fd, &stb) == -1) {\nsyserr:\t\t\trun_err(\"%s: %s\", name, strerror(errno));\n\t\t\tgoto next;\n\t\t}\n\t\tif (stb.st_size < 0) {\n\t\t\trun_err(\"%s: %s\", name, \"Negative file size\");\n\t\t\tgoto next;\n\t\t}\n\t\tunset_nonblock(fd);\n\t\tswitch (stb.st_mode & S_IFMT) {\n\t\tcase S_IFREG:\n\t\t\tbreak;\n\t\tcase S_IFDIR:\n\t\t\tif (iamrecursive) {\n\t\t\t\trsource(name, &stb);\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\t/* FALLTHROUGH */\n\t\tdefault:\n\t\t\trun_err(\"%s: not a regular file\", name);\n\t\t\tgoto next;\n\t\t}\n\t\tif ((last = strrchr(name, '/')) == NULL)\n\t\t\tlast = name;\n\t\telse\n\t\t\t++last;\n\t\tcurfile = last;\n\t\tif (pflag) {\n\t\t\tif (do_times(remout, verbose_mode, &stb) < 0)\n\t\t\t\tgoto next;\n\t\t}\n#define\tFILEMODEMASK\t(S_ISUID|S_ISGID|S_IRWXU|S_IRWXG|S_IRWXO)\n\t\tsnprintf(buf, sizeof buf, \"C%04o %lld %s\\n\",\n\t\t    (u_int) (stb.st_mode & FILEMODEMASK),\n\t\t    (long long)stb.st_size, last);\n\t\tif (verbose_mode)\n\t\t\tfmprintf(stderr, \"Sending file modes: %s\", buf);\n\t\t(void) atomicio(vwrite, remout, buf, strlen(buf));\n\t\tif (response() < 0)\n\t\t\tgoto next;\n\t\tif ((bp = allocbuf(&buffer, fd, COPY_BUFLEN)) == NULL) {\nnext:\t\t\tif (fd != -1) {\n\t\t\t\t(void) close(fd);\n\t\t\t\tfd = -1;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (showprogress)\n\t\t\tstart_progress_meter(curfile, stb.st_size, &statbytes);\n\t\tset_nonblock(remout);\n\t\tfor (haderr = i = 0; i < stb.st_size; i += bp->cnt) {\n\t\t\tamt = bp->cnt;\n\t\t\tif (i + (off_t)amt > stb.st_size)\n\t\t\t\tamt = stb.st_size - i;\n\t\t\tif (!haderr) {\n\t\t\t\tif ((nr = atomicio(read, fd,\n\t\t\t\t    bp->buf, amt)) != amt) {\n\t\t\t\t\thaderr = errno;\n\t\t\t\t\tmemset(bp->buf + nr, 0, amt - nr);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Keep writing after error to retain sync */\n\t\t\tif (haderr) {\n\t\t\t\t(void)atomicio(vwrite, remout, bp->buf, amt);\n\t\t\t\tmemset(bp->buf, 0, amt);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (atomicio6(vwrite, remout, bp->buf, amt, scpio,\n\t\t\t    &statbytes) != amt)\n\t\t\t\thaderr = errno;\n\t\t}\n\t\tunset_nonblock(remout);\n\n\t\tif (fd != -1) {\n\t\t\tif (close(fd) == -1 && !haderr)\n\t\t\t\thaderr = errno;\n\t\t\tfd = -1;\n\t\t}\n\t\tif (!haderr)\n\t\t\t(void) atomicio(vwrite, remout, \"\", 1);\n\t\telse\n\t\t\trun_err(\"%s: %s\", name, strerror(haderr));\n\t\t(void) response();\n\t\tif (showprogress)\n\t\t\tstop_progress_meter();\n\t}\n}\n\nvoid\nrsource(char *name, struct stat *statp)\n{\n\tDIR *dirp;\n\tstruct dirent *dp;\n\tchar *last, *vect[1], path[PATH_MAX];\n\n\tif (!(dirp = opendir(name))) {\n\t\trun_err(\"%s: %s\", name, strerror(errno));\n\t\treturn;\n\t}\n\tlast = strrchr(name, '/');\n\tif (last == NULL)\n\t\tlast = name;\n\telse\n\t\tlast++;\n\tif (pflag) {\n\t\tif (do_times(remout, verbose_mode, statp) < 0) {\n\t\t\tclosedir(dirp);\n\t\t\treturn;\n\t\t}\n\t}\n\t(void) snprintf(path, sizeof path, \"D%04o %d %.1024s\\n\",\n\t    (u_int) (statp->st_mode & FILEMODEMASK), 0, last);\n\tif (verbose_mode)\n\t\tfmprintf(stderr, \"Entering directory: %s\", path);\n\t(void) atomicio(vwrite, remout, path, strlen(path));\n\tif (response() < 0) {\n\t\tclosedir(dirp);\n\t\treturn;\n\t}\n\twhile ((dp = readdir(dirp)) != NULL) {\n\t\tif (dp->d_ino == 0)\n\t\t\tcontinue;\n\t\tif (!strcmp(dp->d_name, \".\") || !strcmp(dp->d_name, \"..\"))\n\t\t\tcontinue;\n\t\tif (strlen(name) + 1 + strlen(dp->d_name) >= sizeof(path) - 1) {\n\t\t\trun_err(\"%s/%s: name too long\", name, dp->d_name);\n\t\t\tcontinue;\n\t\t}\n\t\t(void) snprintf(path, sizeof path, \"%s/%s\", name, dp->d_name);\n\t\tvect[0] = path;\n\t\tsource(1, vect);\n\t}\n\t(void) closedir(dirp);\n\t(void) atomicio(vwrite, remout, \"E\\n\", 2);\n\t(void) response();\n}\n\n#define TYPE_OVERFLOW(type, val) \\\n\t((sizeof(type) == 4 && (val) > INT32_MAX) || \\\n\t (sizeof(type) == 8 && (val) > INT64_MAX) || \\\n\t (sizeof(type) != 4 && sizeof(type) != 8))\n\nvoid\nsink(int argc, char **argv, const char *src)\n{\n\tstatic BUF buffer;\n\tstruct stat stb;\n\tBUF *bp;\n\toff_t i;\n\tsize_t j, count;\n\tint amt, exists, first, ofd;\n\tmode_t mode, omode, mask;\n\toff_t size, statbytes;\n\tunsigned long long ull;\n\tint setimes, targisdir, wrerr;\n\tchar ch, *cp, *np, *targ, *why, *vect[1], buf[2048], visbuf[2048];\n\tchar **patterns = NULL;\n\tsize_t n, npatterns = 0;\n\tstruct timeval tv[2];\n\n#define\tatime\ttv[0]\n#define\tmtime\ttv[1]\n#define\tSCREWUP(str)\t{ why = str; goto screwup; }\n\n\tif (TYPE_OVERFLOW(time_t, 0) || TYPE_OVERFLOW(off_t, 0))\n\t\tSCREWUP(\"Unexpected off_t/time_t size\");\n\n\tsetimes = targisdir = 0;\n\tmask = umask(0);\n\tif (!pflag)\n\t\t(void) umask(mask);\n\tif (argc != 1) {\n\t\trun_err(\"ambiguous target\");\n\t\texit(1);\n\t}\n\ttarg = *argv;\n\tif (targetshouldbedirectory)\n\t\tverifydir(targ);\n\n\t(void) atomicio(vwrite, remout, \"\", 1);\n\tif (stat(targ, &stb) == 0 && S_ISDIR(stb.st_mode))\n\t\ttargisdir = 1;\n\tif (src != NULL && !iamrecursive && !Tflag) {\n\t\t/*\n\t\t * Prepare to try to restrict incoming filenames to match\n\t\t * the requested destination file glob.\n\t\t */\n\t\tif (brace_expand(src, &patterns, &npatterns) != 0)\n\t\t\tfatal(\"%s: could not expand pattern\", __func__);\n\t}\n\tfor (first = 1;; first = 0) {\n\t\tcp = buf;\n\t\tif (atomicio(read, remin, cp, 1) != 1)\n\t\t\tgoto done;\n\t\tif (*cp++ == '\\n')\n\t\t\tSCREWUP(\"unexpected <newline>\");\n\t\tdo {\n\t\t\tif (atomicio(read, remin, &ch, sizeof(ch)) != sizeof(ch))\n\t\t\t\tSCREWUP(\"lost connection\");\n\t\t\t*cp++ = ch;\n\t\t} while (cp < &buf[sizeof(buf) - 1] && ch != '\\n');\n\t\t*cp = 0;\n\t\tif (verbose_mode)\n\t\t\tfmprintf(stderr, \"Sink: %s\", buf);\n\n\t\tif (buf[0] == '\\01' || buf[0] == '\\02') {\n\t\t\tif (iamremote == 0) {\n\t\t\t\t(void) snmprintf(visbuf, sizeof(visbuf),\n\t\t\t\t    NULL, \"%s\", buf + 1);\n\t\t\t\t(void) atomicio(vwrite, STDERR_FILENO,\n\t\t\t\t    visbuf, strlen(visbuf));\n\t\t\t}\n\t\t\tif (buf[0] == '\\02')\n\t\t\t\texit(1);\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tif (buf[0] == 'E') {\n\t\t\t(void) atomicio(vwrite, remout, \"\", 1);\n\t\t\tgoto done;\n\t\t}\n\t\tif (ch == '\\n')\n\t\t\t*--cp = 0;\n\n\t\tcp = buf;\n\t\tif (*cp == 'T') {\n\t\t\tsetimes++;\n\t\t\tcp++;\n\t\t\tif (!isdigit((unsigned char)*cp))\n\t\t\t\tSCREWUP(\"mtime.sec not present\");\n\t\t\tull = strtoull(cp, &cp, 10);\n\t\t\tif (!cp || *cp++ != ' ')\n\t\t\t\tSCREWUP(\"mtime.sec not delimited\");\n\t\t\tif (TYPE_OVERFLOW(time_t, ull))\n\t\t\t\tsetimes = 0;\t/* out of range */\n\t\t\tmtime.tv_sec = ull;\n\t\t\tmtime.tv_usec = strtol(cp, &cp, 10);\n\t\t\tif (!cp || *cp++ != ' ' || mtime.tv_usec < 0 ||\n\t\t\t    mtime.tv_usec > 999999)\n\t\t\t\tSCREWUP(\"mtime.usec not delimited\");\n\t\t\tif (!isdigit((unsigned char)*cp))\n\t\t\t\tSCREWUP(\"atime.sec not present\");\n\t\t\tull = strtoull(cp, &cp, 10);\n\t\t\tif (!cp || *cp++ != ' ')\n\t\t\t\tSCREWUP(\"atime.sec not delimited\");\n\t\t\tif (TYPE_OVERFLOW(time_t, ull))\n\t\t\t\tsetimes = 0;\t/* out of range */\n\t\t\tatime.tv_sec = ull;\n\t\t\tatime.tv_usec = strtol(cp, &cp, 10);\n\t\t\tif (!cp || *cp++ != '\\0' || atime.tv_usec < 0 ||\n\t\t\t    atime.tv_usec > 999999)\n\t\t\t\tSCREWUP(\"atime.usec not delimited\");\n\t\t\t(void) atomicio(vwrite, remout, \"\", 1);\n\t\t\tcontinue;\n\t\t}\n\t\tif (*cp != 'C' && *cp != 'D') {\n\t\t\t/*\n\t\t\t * Check for the case \"rcp remote:foo\\* local:bar\".\n\t\t\t * In this case, the line \"No match.\" can be returned\n\t\t\t * by the shell before the rcp command on the remote is\n\t\t\t * executed so the ^Aerror_message convention isn't\n\t\t\t * followed.\n\t\t\t */\n\t\t\tif (first) {\n\t\t\t\trun_err(\"%s\", cp);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tSCREWUP(\"expected control record\");\n\t\t}\n\t\tmode = 0;\n\t\tfor (++cp; cp < buf + 5; cp++) {\n\t\t\tif (*cp < '0' || *cp > '7')\n\t\t\t\tSCREWUP(\"bad mode\");\n\t\t\tmode = (mode << 3) | (*cp - '0');\n\t\t}\n\t\tif (!pflag)\n\t\t\tmode &= ~mask;\n\t\tif (*cp++ != ' ')\n\t\t\tSCREWUP(\"mode not delimited\");\n\n\t\tif (!isdigit((unsigned char)*cp))\n\t\t\tSCREWUP(\"size not present\");\n\t\tull = strtoull(cp, &cp, 10);\n\t\tif (!cp || *cp++ != ' ')\n\t\t\tSCREWUP(\"size not delimited\");\n\t\tif (TYPE_OVERFLOW(off_t, ull))\n\t\t\tSCREWUP(\"size out of range\");\n\t\tsize = (off_t)ull;\n\n\t\tif (*cp == '\\0' || strchr(cp, '/') != NULL ||\n\t\t    strcmp(cp, \".\") == 0 || strcmp(cp, \"..\") == 0) {\n\t\t\trun_err(\"error: unexpected filename: %s\", cp);\n\t\t\texit(1);\n\t\t}\n\t\tif (npatterns > 0) {\n\t\t\tfor (n = 0; n < npatterns; n++) {\n\t\t\t\tif (fnmatch(patterns[n], cp, 0) == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (n >= npatterns)\n\t\t\t\tSCREWUP(\"filename does not match request\");\n\t\t}\n\t\tif (targisdir) {\n\t\t\tstatic char *namebuf;\n\t\t\tstatic size_t cursize;\n\t\t\tsize_t need;\n\n\t\t\tneed = strlen(targ) + strlen(cp) + 250;\n\t\t\tif (need > cursize) {\n\t\t\t\tfree(namebuf);\n\t\t\t\tnamebuf = xmalloc(need);\n\t\t\t\tcursize = need;\n\t\t\t}\n\t\t\t(void) snprintf(namebuf, need, \"%s%s%s\", targ,\n\t\t\t    strcmp(targ, \"/\") ? \"/\" : \"\", cp);\n\t\t\tnp = namebuf;\n\t\t} else\n\t\t\tnp = targ;\n\t\tcurfile = cp;\n\t\texists = stat(np, &stb) == 0;\n\t\tif (buf[0] == 'D') {\n\t\t\tint mod_flag = pflag;\n\t\t\tif (!iamrecursive)\n\t\t\t\tSCREWUP(\"received directory without -r\");\n\t\t\tif (exists) {\n\t\t\t\tif (!S_ISDIR(stb.st_mode)) {\n\t\t\t\t\terrno = ENOTDIR;\n\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t\tif (pflag)\n\t\t\t\t\t(void) chmod(np, mode);\n\t\t\t} else {\n\t\t\t\t/* Handle copying from a read-only\n\t\t\t\t   directory */\n\t\t\t\tmod_flag = 1;\n\t\t\t\tif (mkdir(np, mode | S_IRWXU) == -1)\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tvect[0] = xstrdup(np);\n\t\t\tsink(1, vect, src);\n\t\t\tif (setimes) {\n\t\t\t\tsetimes = 0;\n\t\t\t\t(void) utimes(vect[0], tv);\n\t\t\t}\n\t\t\tif (mod_flag)\n\t\t\t\t(void) chmod(vect[0], mode);\n\t\t\tfree(vect[0]);\n\t\t\tcontinue;\n\t\t}\n\t\tomode = mode;\n\t\tmode |= S_IWUSR;\n\t\tif ((ofd = open(np, O_WRONLY|O_CREAT, mode)) == -1) {\nbad:\t\t\trun_err(\"%s: %s\", np, strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\t\t(void) atomicio(vwrite, remout, \"\", 1);\n\t\tif ((bp = allocbuf(&buffer, ofd, COPY_BUFLEN)) == NULL) {\n\t\t\t(void) close(ofd);\n\t\t\tcontinue;\n\t\t}\n\t\tcp = bp->buf;\n\t\twrerr = 0;\n\n\t\t/*\n\t\t * NB. do not use run_err() unless immediately followed by\n\t\t * exit() below as it may send a spurious reply that might\n\t\t * desyncronise us from the peer. Use note_err() instead.\n\t\t */\n\t\tstatbytes = 0;\n\t\tif (showprogress)\n\t\t\tstart_progress_meter(curfile, size, &statbytes);\n\t\tset_nonblock(remin);\n\t\tfor (count = i = 0; i < size; i += bp->cnt) {\n\t\t\tamt = bp->cnt;\n\t\t\tif (i + amt > size)\n\t\t\t\tamt = size - i;\n\t\t\tcount += amt;\n\t\t\tdo {\n\t\t\t\tj = atomicio6(read, remin, cp, amt,\n\t\t\t\t    scpio, &statbytes);\n\t\t\t\tif (j == 0) {\n\t\t\t\t\trun_err(\"%s\", j != EPIPE ?\n\t\t\t\t\t    strerror(errno) :\n\t\t\t\t\t    \"dropped connection\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tamt -= j;\n\t\t\t\tcp += j;\n\t\t\t} while (amt > 0);\n\n\t\t\tif (count == bp->cnt) {\n\t\t\t\t/* Keep reading so we stay sync'd up. */\n\t\t\t\tif (!wrerr) {\n\t\t\t\t\tif (atomicio(vwrite, ofd, bp->buf,\n\t\t\t\t\t    count) != count) {\n\t\t\t\t\t\tnote_err(\"%s: %s\", np,\n\t\t\t\t\t\t    strerror(errno));\n\t\t\t\t\t\twrerr = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcount = 0;\n\t\t\t\tcp = bp->buf;\n\t\t\t}\n\t\t}\n\t\tunset_nonblock(remin);\n\t\tif (count != 0 && !wrerr &&\n\t\t    atomicio(vwrite, ofd, bp->buf, count) != count) {\n\t\t\tnote_err(\"%s: %s\", np, strerror(errno));\n\t\t\twrerr = 1;\n\t\t}\n\t\tif (!wrerr && (!exists || S_ISREG(stb.st_mode)) &&\n\t\t    ftruncate(ofd, size) != 0)\n\t\t\tnote_err(\"%s: truncate: %s\", np, strerror(errno));\n\t\tif (pflag) {\n\t\t\tif (exists || omode != mode)\n#ifdef HAVE_FCHMOD\n\t\t\t\tif (fchmod(ofd, omode)) {\n#else /* HAVE_FCHMOD */\n\t\t\t\tif (chmod(np, omode)) {\n#endif /* HAVE_FCHMOD */\n\t\t\t\t\tnote_err(\"%s: set mode: %s\",\n\t\t\t\t\t    np, strerror(errno));\n\t\t\t\t}\n\t\t} else {\n\t\t\tif (!exists && omode != mode)\n#ifdef HAVE_FCHMOD\n\t\t\t\tif (fchmod(ofd, omode & ~mask)) {\n#else /* HAVE_FCHMOD */\n\t\t\t\tif (chmod(np, omode & ~mask)) {\n#endif /* HAVE_FCHMOD */\n\t\t\t\t\tnote_err(\"%s: set mode: %s\",\n\t\t\t\t\t    np, strerror(errno));\n\t\t\t\t}\n\t\t}\n\t\tif (close(ofd) == -1)\n\t\t\tnote_err(np, \"%s: close: %s\", np, strerror(errno));\n\t\t(void) response();\n\t\tif (showprogress)\n\t\t\tstop_progress_meter();\n\t\tif (setimes && !wrerr) {\n\t\t\tsetimes = 0;\n\t\t\tif (utimes(np, tv) == -1) {\n\t\t\t\tnote_err(\"%s: set times: %s\",\n\t\t\t\t    np, strerror(errno));\n\t\t\t}\n\t\t}\n\t\t/* If no error was noted then signal success for this file */\n\t\tif (note_err(NULL) == 0)\n\t\t\t(void) atomicio(vwrite, remout, \"\", 1);\n\t}\ndone:\n\tfor (n = 0; n < npatterns; n++)\n\t\tfree(patterns[n]);\n\tfree(patterns);\n\treturn;\nscrewup:\n\tfor (n = 0; n < npatterns; n++)\n\t\tfree(patterns[n]);\n\tfree(patterns);\n\trun_err(\"protocol error: %s\", why);\n\texit(1);\n}\n\nint\nresponse(void)\n{\n\tchar ch, *cp, resp, rbuf[2048], visbuf[2048];\n\n\tif (atomicio(read, remin, &resp, sizeof(resp)) != sizeof(resp))\n\t\tlostconn(0);\n\n\tcp = rbuf;\n\tswitch (resp) {\n\tcase 0:\t\t/* ok */\n\t\treturn (0);\n\tdefault:\n\t\t*cp++ = resp;\n\t\t/* FALLTHROUGH */\n\tcase 1:\t\t/* error, followed by error msg */\n\tcase 2:\t\t/* fatal error, \"\" */\n\t\tdo {\n\t\t\tif (atomicio(read, remin, &ch, sizeof(ch)) != sizeof(ch))\n\t\t\t\tlostconn(0);\n\t\t\t*cp++ = ch;\n\t\t} while (cp < &rbuf[sizeof(rbuf) - 1] && ch != '\\n');\n\n\t\tif (!iamremote) {\n\t\t\tcp[-1] = '\\0';\n\t\t\t(void) snmprintf(visbuf, sizeof(visbuf),\n\t\t\t    NULL, \"%s\\n\", rbuf);\n\t\t\t(void) atomicio(vwrite, STDERR_FILENO,\n\t\t\t    visbuf, strlen(visbuf));\n\t\t}\n\t\t++errs;\n\t\tif (resp == 1)\n\t\t\treturn (-1);\n\t\texit(1);\n\t}\n\t/* NOTREACHED */\n}\n\nvoid\nusage(void)\n{\n\t(void) fprintf(stderr,\n\t    \"usage: scp [-346BCpqrTv] [-c cipher] [-F ssh_config] [-i identity_file]\\n\"\n\t    \"            [-J destination] [-l limit] [-o ssh_option] [-P port]\\n\"\n\t    \"            [-S program] source ... target\\n\");\n\texit(1);\n}\n\nvoid\nrun_err(const char *fmt,...)\n{\n\tstatic FILE *fp;\n\tva_list ap;\n\n\t++errs;\n\tif (fp != NULL || (remout != -1 && (fp = fdopen(remout, \"w\")))) {\n\t\t(void) fprintf(fp, \"%c\", 0x01);\n\t\t(void) fprintf(fp, \"scp: \");\n\t\tva_start(ap, fmt);\n\t\t(void) vfprintf(fp, fmt, ap);\n\t\tva_end(ap);\n\t\t(void) fprintf(fp, \"\\n\");\n\t\t(void) fflush(fp);\n\t}\n\n\tif (!iamremote) {\n\t\tva_start(ap, fmt);\n\t\tvfmprintf(stderr, fmt, ap);\n\t\tva_end(ap);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}\n\n/*\n * Notes a sink error for sending at the end of a file transfer. Returns 0 if\n * no error has been noted or -1 otherwise. Use note_err(NULL) to flush\n * any active error at the end of the transfer.\n */\nint\nnote_err(const char *fmt, ...)\n{\n\tstatic char *emsg;\n\tva_list ap;\n\n\t/* Replay any previously-noted error */\n\tif (fmt == NULL) {\n\t\tif (emsg == NULL)\n\t\t\treturn 0;\n\t\trun_err(\"%s\", emsg);\n\t\tfree(emsg);\n\t\temsg = NULL;\n\t\treturn -1;\n\t}\n\n\terrs++;\n\t/* Prefer first-noted error */\n\tif (emsg != NULL)\n\t\treturn -1;\n\n\tva_start(ap, fmt);\n\tvasnmprintf(&emsg, INT_MAX, NULL, fmt, ap);\n\tva_end(ap);\n\treturn -1;\n}\n\nvoid\nverifydir(char *cp)\n{\n\tstruct stat stb;\n\n\tif (!stat(cp, &stb)) {\n\t\tif (S_ISDIR(stb.st_mode))\n\t\t\treturn;\n\t\terrno = ENOTDIR;\n\t}\n\trun_err(\"%s: %s\", cp, strerror(errno));\n\tkillchild(0);\n}\n\nint\nokname(char *cp0)\n{\n\tint c;\n\tchar *cp;\n\n\tcp = cp0;\n\tdo {\n\t\tc = (int)*cp;\n\t\tif (c & 0200)\n\t\t\tgoto bad;\n\t\tif (!isalpha(c) && !isdigit((unsigned char)c)) {\n\t\t\tswitch (c) {\n\t\t\tcase '\\'':\n\t\t\tcase '\"':\n\t\t\tcase '`':\n\t\t\tcase ' ':\n\t\t\tcase '#':\n\t\t\t\tgoto bad;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} while (*++cp);\n\treturn (1);\n\nbad:\tfmprintf(stderr, \"%s: invalid user name\\n\", cp0);\n\treturn (0);\n}\n\nBUF *\nallocbuf(BUF *bp, int fd, int blksize)\n{\n\tsize_t size;\n#ifdef HAVE_STRUCT_STAT_ST_BLKSIZE\n\tstruct stat stb;\n\n\tif (fstat(fd, &stb) == -1) {\n\t\trun_err(\"fstat: %s\", strerror(errno));\n\t\treturn (0);\n\t}\n\tsize = ROUNDUP(stb.st_blksize, blksize);\n\tif (size == 0)\n\t\tsize = blksize;\n#else /* HAVE_STRUCT_STAT_ST_BLKSIZE */\n\tsize = blksize;\n#endif /* HAVE_STRUCT_STAT_ST_BLKSIZE */\n\tif (bp->cnt >= size)\n\t\treturn (bp);\n\tbp->buf = xrecallocarray(bp->buf, bp->cnt, size, 1);\n\tbp->cnt = size;\n\treturn (bp);\n}\n\nvoid\nlostconn(int signo)\n{\n\tif (!iamremote)\n\t\t(void)write(STDERR_FILENO, \"lost connection\\n\", 16);\n\tif (signo)\n\t\t_exit(1);\n\telse\n\t\texit(1);\n}\n"], "filenames": ["scp.c"], "buggy_code_start_loc": [1], "buggy_code_end_loc": [1433], "fixing_code_start_loc": [1], "fixing_code_end_loc": [1431], "type": "CWE-20", "message": "** DISPUTED ** The scp client in OpenSSH 8.2 incorrectly sends duplicate responses to the server upon a utimes system call failure, which allows a malicious unprivileged user on the remote server to overwrite arbitrary files in the client's download directory by creating a crafted subdirectory anywhere on the remote server. The victim must use the command scp -rp to download a file hierarchy containing, anywhere inside, this crafted subdirectory. NOTE: the vendor points out that \"this attack can achieve no more than a hostile peer is already able to achieve within the scp protocol\" and \"utimes does not fail under normal circumstances.\"", "other": {"cve": {"id": "CVE-2020-12062", "sourceIdentifier": "cve@mitre.org", "published": "2020-06-01T16:15:14.260", "lastModified": "2020-06-04T16:18:31.457", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "** DISPUTED ** The scp client in OpenSSH 8.2 incorrectly sends duplicate responses to the server upon a utimes system call failure, which allows a malicious unprivileged user on the remote server to overwrite arbitrary files in the client's download directory by creating a crafted subdirectory anywhere on the remote server. The victim must use the command scp -rp to download a file hierarchy containing, anywhere inside, this crafted subdirectory. NOTE: the vendor points out that \"this attack can achieve no more than a hostile peer is already able to achieve within the scp protocol\" and \"utimes does not fail under normal circumstances.\""}, {"lang": "es", "value": "** EN DISPUTA** El cliente scp en OpenSSH versi\u00f3n 8.2 env\u00eda incorrectamente respuestas duplicadas al servidor tras un fallo en la llamada de sistema utimes, lo que permite a un usuario malicioso sin privilegios en el servidor remoto sobrescribir archivos arbitrarios en el directorio de descarga del cliente mediante la creaci\u00f3n de un subdirectorio dise\u00f1ado en cualquier lugar del servidor remoto. La v\u00edctima debe usar el comando scp -rp para descargar una jerarqu\u00eda de archivos que contenga, en cualquier lugar de su interior, este subdirectorio creado. NOTA: el vendedor se\u00f1ala que \"este ataque no puede lograr m\u00e1s de lo que un peer hostil ya se puede lograr dentro del protocolo scp\" y \"utimes no presenta un fallo bajo circunstancias normales\"."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openbsd:openssh:8.2:*:*:*:*:*:*:*", "matchCriteriaId": "FD5093B8-4D79-4892-A614-5F6D4009BD72"}]}]}], "references": [{"url": "https://github.com/openssh/openssh-portable/commit/955854cafca88e0cdcd3d09ca1ad4ada465364a1", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/openssh/openssh-portable/commit/aad87b88fc2536b1ea023213729aaf4eaabe1894", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.openssh.com/txt/release-8.3", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://www.openwall.com/lists/oss-security/2020/05/27/1", "source": "cve@mitre.org", "tags": ["Mailing List", "Release Notes", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/openssh/openssh-portable/commit/955854cafca88e0cdcd3d09ca1ad4ada465364a1"}}