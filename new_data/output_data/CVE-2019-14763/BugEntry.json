{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0+\n/*\n * f_hid.c -- USB HID function driver\n *\n * Copyright (C) 2010 Fabien Chouteau <fabien.chouteau@barco.com>\n */\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/hid.h>\n#include <linux/idr.h>\n#include <linux/cdev.h>\n#include <linux/mutex.h>\n#include <linux/poll.h>\n#include <linux/uaccess.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/usb/g_hid.h>\n\n#include \"u_f.h\"\n#include \"u_hid.h\"\n\n#define HIDG_MINORS\t4\n\nstatic int major, minors;\nstatic struct class *hidg_class;\nstatic DEFINE_IDA(hidg_ida);\nstatic DEFINE_MUTEX(hidg_ida_lock); /* protects access to hidg_ida */\n\n/*-------------------------------------------------------------------------*/\n/*                            HID gadget struct                            */\n\nstruct f_hidg_req_list {\n\tstruct usb_request\t*req;\n\tunsigned int\t\tpos;\n\tstruct list_head \tlist;\n};\n\nstruct f_hidg {\n\t/* configuration */\n\tunsigned char\t\t\tbInterfaceSubClass;\n\tunsigned char\t\t\tbInterfaceProtocol;\n\tunsigned char\t\t\tprotocol;\n\tunsigned short\t\t\treport_desc_length;\n\tchar\t\t\t\t*report_desc;\n\tunsigned short\t\t\treport_length;\n\n\t/* recv report */\n\tstruct list_head\t\tcompleted_out_req;\n\tspinlock_t\t\t\tread_spinlock;\n\twait_queue_head_t\t\tread_queue;\n\tunsigned int\t\t\tqlen;\n\n\t/* send report */\n\tspinlock_t\t\t\twrite_spinlock;\n\tbool\t\t\t\twrite_pending;\n\twait_queue_head_t\t\twrite_queue;\n\tstruct usb_request\t\t*req;\n\n\tint\t\t\t\tminor;\n\tstruct cdev\t\t\tcdev;\n\tstruct usb_function\t\tfunc;\n\n\tstruct usb_ep\t\t\t*in_ep;\n\tstruct usb_ep\t\t\t*out_ep;\n};\n\nstatic inline struct f_hidg *func_to_hidg(struct usb_function *f)\n{\n\treturn container_of(f, struct f_hidg, func);\n}\n\n/*-------------------------------------------------------------------------*/\n/*                           Static descriptors                            */\n\nstatic struct usb_interface_descriptor hidg_interface_desc = {\n\t.bLength\t\t= sizeof hidg_interface_desc,\n\t.bDescriptorType\t= USB_DT_INTERFACE,\n\t/* .bInterfaceNumber\t= DYNAMIC */\n\t.bAlternateSetting\t= 0,\n\t.bNumEndpoints\t\t= 2,\n\t.bInterfaceClass\t= USB_CLASS_HID,\n\t/* .bInterfaceSubClass\t= DYNAMIC */\n\t/* .bInterfaceProtocol\t= DYNAMIC */\n\t/* .iInterface\t\t= DYNAMIC */\n};\n\nstatic struct hid_descriptor hidg_desc = {\n\t.bLength\t\t\t= sizeof hidg_desc,\n\t.bDescriptorType\t\t= HID_DT_HID,\n\t.bcdHID\t\t\t\t= 0x0101,\n\t.bCountryCode\t\t\t= 0x00,\n\t.bNumDescriptors\t\t= 0x1,\n\t/*.desc[0].bDescriptorType\t= DYNAMIC */\n\t/*.desc[0].wDescriptorLenght\t= DYNAMIC */\n};\n\n/* Super-Speed Support */\n\nstatic struct usb_endpoint_descriptor hidg_ss_in_ep_desc = {\n\t.bLength\t\t= USB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType\t= USB_DT_ENDPOINT,\n\t.bEndpointAddress\t= USB_DIR_IN,\n\t.bmAttributes\t\t= USB_ENDPOINT_XFER_INT,\n\t/*.wMaxPacketSize\t= DYNAMIC */\n\t.bInterval\t\t= 4, /* FIXME: Add this field in the\n\t\t\t\t      * HID gadget configuration?\n\t\t\t\t      * (struct hidg_func_descriptor)\n\t\t\t\t      */\n};\n\nstatic struct usb_ss_ep_comp_descriptor hidg_ss_in_comp_desc = {\n\t.bLength                = sizeof(hidg_ss_in_comp_desc),\n\t.bDescriptorType        = USB_DT_SS_ENDPOINT_COMP,\n\n\t/* .bMaxBurst           = 0, */\n\t/* .bmAttributes        = 0, */\n\t/* .wBytesPerInterval   = DYNAMIC */\n};\n\nstatic struct usb_endpoint_descriptor hidg_ss_out_ep_desc = {\n\t.bLength\t\t= USB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType\t= USB_DT_ENDPOINT,\n\t.bEndpointAddress\t= USB_DIR_OUT,\n\t.bmAttributes\t\t= USB_ENDPOINT_XFER_INT,\n\t/*.wMaxPacketSize\t= DYNAMIC */\n\t.bInterval\t\t= 4, /* FIXME: Add this field in the\n\t\t\t\t      * HID gadget configuration?\n\t\t\t\t      * (struct hidg_func_descriptor)\n\t\t\t\t      */\n};\n\nstatic struct usb_ss_ep_comp_descriptor hidg_ss_out_comp_desc = {\n\t.bLength                = sizeof(hidg_ss_out_comp_desc),\n\t.bDescriptorType        = USB_DT_SS_ENDPOINT_COMP,\n\n\t/* .bMaxBurst           = 0, */\n\t/* .bmAttributes        = 0, */\n\t/* .wBytesPerInterval   = DYNAMIC */\n};\n\nstatic struct usb_descriptor_header *hidg_ss_descriptors[] = {\n\t(struct usb_descriptor_header *)&hidg_interface_desc,\n\t(struct usb_descriptor_header *)&hidg_desc,\n\t(struct usb_descriptor_header *)&hidg_ss_in_ep_desc,\n\t(struct usb_descriptor_header *)&hidg_ss_in_comp_desc,\n\t(struct usb_descriptor_header *)&hidg_ss_out_ep_desc,\n\t(struct usb_descriptor_header *)&hidg_ss_out_comp_desc,\n\tNULL,\n};\n\n/* High-Speed Support */\n\nstatic struct usb_endpoint_descriptor hidg_hs_in_ep_desc = {\n\t.bLength\t\t= USB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType\t= USB_DT_ENDPOINT,\n\t.bEndpointAddress\t= USB_DIR_IN,\n\t.bmAttributes\t\t= USB_ENDPOINT_XFER_INT,\n\t/*.wMaxPacketSize\t= DYNAMIC */\n\t.bInterval\t\t= 4, /* FIXME: Add this field in the\n\t\t\t\t      * HID gadget configuration?\n\t\t\t\t      * (struct hidg_func_descriptor)\n\t\t\t\t      */\n};\n\nstatic struct usb_endpoint_descriptor hidg_hs_out_ep_desc = {\n\t.bLength\t\t= USB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType\t= USB_DT_ENDPOINT,\n\t.bEndpointAddress\t= USB_DIR_OUT,\n\t.bmAttributes\t\t= USB_ENDPOINT_XFER_INT,\n\t/*.wMaxPacketSize\t= DYNAMIC */\n\t.bInterval\t\t= 4, /* FIXME: Add this field in the\n\t\t\t\t      * HID gadget configuration?\n\t\t\t\t      * (struct hidg_func_descriptor)\n\t\t\t\t      */\n};\n\nstatic struct usb_descriptor_header *hidg_hs_descriptors[] = {\n\t(struct usb_descriptor_header *)&hidg_interface_desc,\n\t(struct usb_descriptor_header *)&hidg_desc,\n\t(struct usb_descriptor_header *)&hidg_hs_in_ep_desc,\n\t(struct usb_descriptor_header *)&hidg_hs_out_ep_desc,\n\tNULL,\n};\n\n/* Full-Speed Support */\n\nstatic struct usb_endpoint_descriptor hidg_fs_in_ep_desc = {\n\t.bLength\t\t= USB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType\t= USB_DT_ENDPOINT,\n\t.bEndpointAddress\t= USB_DIR_IN,\n\t.bmAttributes\t\t= USB_ENDPOINT_XFER_INT,\n\t/*.wMaxPacketSize\t= DYNAMIC */\n\t.bInterval\t\t= 10, /* FIXME: Add this field in the\n\t\t\t\t       * HID gadget configuration?\n\t\t\t\t       * (struct hidg_func_descriptor)\n\t\t\t\t       */\n};\n\nstatic struct usb_endpoint_descriptor hidg_fs_out_ep_desc = {\n\t.bLength\t\t= USB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType\t= USB_DT_ENDPOINT,\n\t.bEndpointAddress\t= USB_DIR_OUT,\n\t.bmAttributes\t\t= USB_ENDPOINT_XFER_INT,\n\t/*.wMaxPacketSize\t= DYNAMIC */\n\t.bInterval\t\t= 10, /* FIXME: Add this field in the\n\t\t\t\t       * HID gadget configuration?\n\t\t\t\t       * (struct hidg_func_descriptor)\n\t\t\t\t       */\n};\n\nstatic struct usb_descriptor_header *hidg_fs_descriptors[] = {\n\t(struct usb_descriptor_header *)&hidg_interface_desc,\n\t(struct usb_descriptor_header *)&hidg_desc,\n\t(struct usb_descriptor_header *)&hidg_fs_in_ep_desc,\n\t(struct usb_descriptor_header *)&hidg_fs_out_ep_desc,\n\tNULL,\n};\n\n/*-------------------------------------------------------------------------*/\n/*                                 Strings                                 */\n\n#define CT_FUNC_HID_IDX\t0\n\nstatic struct usb_string ct_func_string_defs[] = {\n\t[CT_FUNC_HID_IDX].s\t= \"HID Interface\",\n\t{},\t\t\t/* end of list */\n};\n\nstatic struct usb_gadget_strings ct_func_string_table = {\n\t.language\t= 0x0409,\t/* en-US */\n\t.strings\t= ct_func_string_defs,\n};\n\nstatic struct usb_gadget_strings *ct_func_strings[] = {\n\t&ct_func_string_table,\n\tNULL,\n};\n\n/*-------------------------------------------------------------------------*/\n/*                              Char Device                                */\n\nstatic ssize_t f_hidg_read(struct file *file, char __user *buffer,\n\t\t\tsize_t count, loff_t *ptr)\n{\n\tstruct f_hidg *hidg = file->private_data;\n\tstruct f_hidg_req_list *list;\n\tstruct usb_request *req;\n\tunsigned long flags;\n\tint ret;\n\n\tif (!count)\n\t\treturn 0;\n\n\tif (!access_ok(buffer, count))\n\t\treturn -EFAULT;\n\n\tspin_lock_irqsave(&hidg->read_spinlock, flags);\n\n#define READ_COND (!list_empty(&hidg->completed_out_req))\n\n\t/* wait for at least one buffer to complete */\n\twhile (!READ_COND) {\n\t\tspin_unlock_irqrestore(&hidg->read_spinlock, flags);\n\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\n\t\tif (wait_event_interruptible(hidg->read_queue, READ_COND))\n\t\t\treturn -ERESTARTSYS;\n\n\t\tspin_lock_irqsave(&hidg->read_spinlock, flags);\n\t}\n\n\t/* pick the first one */\n\tlist = list_first_entry(&hidg->completed_out_req,\n\t\t\t\tstruct f_hidg_req_list, list);\n\n\t/*\n\t * Remove this from list to protect it from beign free()\n\t * while host disables our function\n\t */\n\tlist_del(&list->list);\n\n\treq = list->req;\n\tcount = min_t(unsigned int, count, req->actual - list->pos);\n\tspin_unlock_irqrestore(&hidg->read_spinlock, flags);\n\n\t/* copy to user outside spinlock */\n\tcount -= copy_to_user(buffer, req->buf + list->pos, count);\n\tlist->pos += count;\n\n\t/*\n\t * if this request is completely handled and transfered to\n\t * userspace, remove its entry from the list and requeue it\n\t * again. Otherwise, we will revisit it again upon the next\n\t * call, taking into account its current read position.\n\t */\n\tif (list->pos == req->actual) {\n\t\tkfree(list);\n\n\t\treq->length = hidg->report_length;\n\t\tret = usb_ep_queue(hidg->out_ep, req, GFP_KERNEL);\n\t\tif (ret < 0) {\n\t\t\tfree_ep_req(hidg->out_ep, req);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tspin_lock_irqsave(&hidg->read_spinlock, flags);\n\t\tlist_add(&list->list, &hidg->completed_out_req);\n\t\tspin_unlock_irqrestore(&hidg->read_spinlock, flags);\n\n\t\twake_up(&hidg->read_queue);\n\t}\n\n\treturn count;\n}\n\nstatic void f_hidg_req_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct f_hidg *hidg = (struct f_hidg *)ep->driver_data;\n\tunsigned long flags;\n\n\tif (req->status != 0) {\n\t\tERROR(hidg->func.config->cdev,\n\t\t\t\"End Point Request ERROR: %d\\n\", req->status);\n\t}\n\n\tspin_lock_irqsave(&hidg->write_spinlock, flags);\n\thidg->write_pending = 0;\n\tspin_unlock_irqrestore(&hidg->write_spinlock, flags);\n\twake_up(&hidg->write_queue);\n}\n\nstatic ssize_t f_hidg_write(struct file *file, const char __user *buffer,\n\t\t\t    size_t count, loff_t *offp)\n{\n\tstruct f_hidg *hidg  = file->private_data;\n\tstruct usb_request *req;\n\tunsigned long flags;\n\tssize_t status = -ENOMEM;\n\n\tif (!access_ok(buffer, count))\n\t\treturn -EFAULT;\n\n\tspin_lock_irqsave(&hidg->write_spinlock, flags);\n\n#define WRITE_COND (!hidg->write_pending)\ntry_again:\n\t/* write queue */\n\twhile (!WRITE_COND) {\n\t\tspin_unlock_irqrestore(&hidg->write_spinlock, flags);\n\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\n\t\tif (wait_event_interruptible_exclusive(\n\t\t\t\thidg->write_queue, WRITE_COND))\n\t\t\treturn -ERESTARTSYS;\n\n\t\tspin_lock_irqsave(&hidg->write_spinlock, flags);\n\t}\n\n\thidg->write_pending = 1;\n\treq = hidg->req;\n\tcount  = min_t(unsigned, count, hidg->report_length);\n\n\tspin_unlock_irqrestore(&hidg->write_spinlock, flags);\n\tstatus = copy_from_user(req->buf, buffer, count);\n\n\tif (status != 0) {\n\t\tERROR(hidg->func.config->cdev,\n\t\t\t\"copy_from_user error\\n\");\n\t\tstatus = -EINVAL;\n\t\tgoto release_write_pending;\n\t}\n\n\tspin_lock_irqsave(&hidg->write_spinlock, flags);\n\n\t/* when our function has been disabled by host */\n\tif (!hidg->req) {\n\t\tfree_ep_req(hidg->in_ep, req);\n\t\t/*\n\t\t * TODO\n\t\t * Should we fail with error here?\n\t\t */\n\t\tgoto try_again;\n\t}\n\n\treq->status   = 0;\n\treq->zero     = 0;\n\treq->length   = count;\n\treq->complete = f_hidg_req_complete;\n\treq->context  = hidg;\n\n\tstatus = usb_ep_queue(hidg->in_ep, req, GFP_ATOMIC);\n\tif (status < 0) {\n\t\tERROR(hidg->func.config->cdev,\n\t\t\t\"usb_ep_queue error on int endpoint %zd\\n\", status);\n\t\tgoto release_write_pending_unlocked;\n\t} else {\n\t\tstatus = count;\n\t}\n\tspin_unlock_irqrestore(&hidg->write_spinlock, flags);\n\n\treturn status;\nrelease_write_pending:\n\tspin_lock_irqsave(&hidg->write_spinlock, flags);\nrelease_write_pending_unlocked:\n\thidg->write_pending = 0;\n\tspin_unlock_irqrestore(&hidg->write_spinlock, flags);\n\n\twake_up(&hidg->write_queue);\n\n\treturn status;\n}\n\nstatic __poll_t f_hidg_poll(struct file *file, poll_table *wait)\n{\n\tstruct f_hidg\t*hidg  = file->private_data;\n\t__poll_t\tret = 0;\n\n\tpoll_wait(file, &hidg->read_queue, wait);\n\tpoll_wait(file, &hidg->write_queue, wait);\n\n\tif (WRITE_COND)\n\t\tret |= EPOLLOUT | EPOLLWRNORM;\n\n\tif (READ_COND)\n\t\tret |= EPOLLIN | EPOLLRDNORM;\n\n\treturn ret;\n}\n\n#undef WRITE_COND\n#undef READ_COND\n\nstatic int f_hidg_release(struct inode *inode, struct file *fd)\n{\n\tfd->private_data = NULL;\n\treturn 0;\n}\n\nstatic int f_hidg_open(struct inode *inode, struct file *fd)\n{\n\tstruct f_hidg *hidg =\n\t\tcontainer_of(inode->i_cdev, struct f_hidg, cdev);\n\n\tfd->private_data = hidg;\n\n\treturn 0;\n}\n\n/*-------------------------------------------------------------------------*/\n/*                                usb_function                             */\n\nstatic inline struct usb_request *hidg_alloc_ep_req(struct usb_ep *ep,\n\t\t\t\t\t\t    unsigned length)\n{\n\treturn alloc_ep_req(ep, length);\n}\n\nstatic void hidg_set_report_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct f_hidg *hidg = (struct f_hidg *) req->context;\n\tstruct usb_composite_dev *cdev = hidg->func.config->cdev;\n\tstruct f_hidg_req_list *req_list;\n\tunsigned long flags;\n\n\tswitch (req->status) {\n\tcase 0:\n\t\treq_list = kzalloc(sizeof(*req_list), GFP_ATOMIC);\n\t\tif (!req_list) {\n\t\t\tERROR(cdev, \"Unable to allocate mem for req_list\\n\");\n\t\t\tgoto free_req;\n\t\t}\n\n\t\treq_list->req = req;\n\n\t\tspin_lock_irqsave(&hidg->read_spinlock, flags);\n\t\tlist_add_tail(&req_list->list, &hidg->completed_out_req);\n\t\tspin_unlock_irqrestore(&hidg->read_spinlock, flags);\n\n\t\twake_up(&hidg->read_queue);\n\t\tbreak;\n\tdefault:\n\t\tERROR(cdev, \"Set report failed %d\\n\", req->status);\n\t\t/* FALLTHROUGH */\n\tcase -ECONNABORTED:\t\t/* hardware forced ep reset */\n\tcase -ECONNRESET:\t\t/* request dequeued */\n\tcase -ESHUTDOWN:\t\t/* disconnect from host */\nfree_req:\n\t\tfree_ep_req(ep, req);\n\t\treturn;\n\t}\n}\n\nstatic int hidg_setup(struct usb_function *f,\n\t\tconst struct usb_ctrlrequest *ctrl)\n{\n\tstruct f_hidg\t\t\t*hidg = func_to_hidg(f);\n\tstruct usb_composite_dev\t*cdev = f->config->cdev;\n\tstruct usb_request\t\t*req  = cdev->req;\n\tint status = 0;\n\t__u16 value, length;\n\n\tvalue\t= __le16_to_cpu(ctrl->wValue);\n\tlength\t= __le16_to_cpu(ctrl->wLength);\n\n\tVDBG(cdev,\n\t     \"%s crtl_request : bRequestType:0x%x bRequest:0x%x Value:0x%x\\n\",\n\t     __func__, ctrl->bRequestType, ctrl->bRequest, value);\n\n\tswitch ((ctrl->bRequestType << 8) | ctrl->bRequest) {\n\tcase ((USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8\n\t\t  | HID_REQ_GET_REPORT):\n\t\tVDBG(cdev, \"get_report\\n\");\n\n\t\t/* send an empty report */\n\t\tlength = min_t(unsigned, length, hidg->report_length);\n\t\tmemset(req->buf, 0x0, length);\n\n\t\tgoto respond;\n\t\tbreak;\n\n\tcase ((USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8\n\t\t  | HID_REQ_GET_PROTOCOL):\n\t\tVDBG(cdev, \"get_protocol\\n\");\n\t\tlength = min_t(unsigned int, length, 1);\n\t\t((u8 *) req->buf)[0] = hidg->protocol;\n\t\tgoto respond;\n\t\tbreak;\n\n\tcase ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8\n\t\t  | HID_REQ_SET_REPORT):\n\t\tVDBG(cdev, \"set_report | wLength=%d\\n\", ctrl->wLength);\n\t\tgoto stall;\n\t\tbreak;\n\n\tcase ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8\n\t\t  | HID_REQ_SET_PROTOCOL):\n\t\tVDBG(cdev, \"set_protocol\\n\");\n\t\tif (value > HID_REPORT_PROTOCOL)\n\t\t\tgoto stall;\n\t\tlength = 0;\n\t\t/*\n\t\t * We assume that programs implementing the Boot protocol\n\t\t * are also compatible with the Report Protocol\n\t\t */\n\t\tif (hidg->bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT) {\n\t\t\thidg->protocol = value;\n\t\t\tgoto respond;\n\t\t}\n\t\tgoto stall;\n\t\tbreak;\n\n\tcase ((USB_DIR_IN | USB_TYPE_STANDARD | USB_RECIP_INTERFACE) << 8\n\t\t  | USB_REQ_GET_DESCRIPTOR):\n\t\tswitch (value >> 8) {\n\t\tcase HID_DT_HID:\n\t\t{\n\t\t\tstruct hid_descriptor hidg_desc_copy = hidg_desc;\n\n\t\t\tVDBG(cdev, \"USB_REQ_GET_DESCRIPTOR: HID\\n\");\n\t\t\thidg_desc_copy.desc[0].bDescriptorType = HID_DT_REPORT;\n\t\t\thidg_desc_copy.desc[0].wDescriptorLength =\n\t\t\t\tcpu_to_le16(hidg->report_desc_length);\n\n\t\t\tlength = min_t(unsigned short, length,\n\t\t\t\t\t\t   hidg_desc_copy.bLength);\n\t\t\tmemcpy(req->buf, &hidg_desc_copy, length);\n\t\t\tgoto respond;\n\t\t\tbreak;\n\t\t}\n\t\tcase HID_DT_REPORT:\n\t\t\tVDBG(cdev, \"USB_REQ_GET_DESCRIPTOR: REPORT\\n\");\n\t\t\tlength = min_t(unsigned short, length,\n\t\t\t\t\t\t   hidg->report_desc_length);\n\t\t\tmemcpy(req->buf, hidg->report_desc, length);\n\t\t\tgoto respond;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tVDBG(cdev, \"Unknown descriptor request 0x%x\\n\",\n\t\t\t\t value >> 8);\n\t\t\tgoto stall;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tVDBG(cdev, \"Unknown request 0x%x\\n\",\n\t\t\t ctrl->bRequest);\n\t\tgoto stall;\n\t\tbreak;\n\t}\n\nstall:\n\treturn -EOPNOTSUPP;\n\nrespond:\n\treq->zero = 0;\n\treq->length = length;\n\tstatus = usb_ep_queue(cdev->gadget->ep0, req, GFP_ATOMIC);\n\tif (status < 0)\n\t\tERROR(cdev, \"usb_ep_queue error on ep0 %d\\n\", value);\n\treturn status;\n}\n\nstatic void hidg_disable(struct usb_function *f)\n{\n\tstruct f_hidg *hidg = func_to_hidg(f);\n\tstruct f_hidg_req_list *list, *next;\n\tunsigned long flags;\n\n\tusb_ep_disable(hidg->in_ep);\n\tusb_ep_disable(hidg->out_ep);\n\n\tspin_lock_irqsave(&hidg->read_spinlock, flags);\n\tlist_for_each_entry_safe(list, next, &hidg->completed_out_req, list) {\n\t\tfree_ep_req(hidg->out_ep, list->req);\n\t\tlist_del(&list->list);\n\t\tkfree(list);\n\t}\n\tspin_unlock_irqrestore(&hidg->read_spinlock, flags);\n\n\tspin_lock_irqsave(&hidg->write_spinlock, flags);\n\tif (!hidg->write_pending) {\n\t\tfree_ep_req(hidg->in_ep, hidg->req);\n\t\thidg->write_pending = 1;\n\t}\n\n\thidg->req = NULL;\n\tspin_unlock_irqrestore(&hidg->write_spinlock, flags);\n}\n\nstatic int hidg_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\n{\n\tstruct usb_composite_dev\t\t*cdev = f->config->cdev;\n\tstruct f_hidg\t\t\t\t*hidg = func_to_hidg(f);\n\tstruct usb_request\t\t\t*req_in = NULL;\n\tunsigned long\t\t\t\tflags;\n\tint i, status = 0;\n\n\tVDBG(cdev, \"hidg_set_alt intf:%d alt:%d\\n\", intf, alt);\n\n\tif (hidg->in_ep != NULL) {\n\t\t/* restart endpoint */\n\t\tusb_ep_disable(hidg->in_ep);\n\n\t\tstatus = config_ep_by_speed(f->config->cdev->gadget, f,\n\t\t\t\t\t    hidg->in_ep);\n\t\tif (status) {\n\t\t\tERROR(cdev, \"config_ep_by_speed FAILED!\\n\");\n\t\t\tgoto fail;\n\t\t}\n\t\tstatus = usb_ep_enable(hidg->in_ep);\n\t\tif (status < 0) {\n\t\t\tERROR(cdev, \"Enable IN endpoint FAILED!\\n\");\n\t\t\tgoto fail;\n\t\t}\n\t\thidg->in_ep->driver_data = hidg;\n\n\t\treq_in = hidg_alloc_ep_req(hidg->in_ep, hidg->report_length);\n\t\tif (!req_in) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tgoto disable_ep_in;\n\t\t}\n\t}\n\n\n\tif (hidg->out_ep != NULL) {\n\t\t/* restart endpoint */\n\t\tusb_ep_disable(hidg->out_ep);\n\n\t\tstatus = config_ep_by_speed(f->config->cdev->gadget, f,\n\t\t\t\t\t    hidg->out_ep);\n\t\tif (status) {\n\t\t\tERROR(cdev, \"config_ep_by_speed FAILED!\\n\");\n\t\t\tgoto free_req_in;\n\t\t}\n\t\tstatus = usb_ep_enable(hidg->out_ep);\n\t\tif (status < 0) {\n\t\t\tERROR(cdev, \"Enable OUT endpoint FAILED!\\n\");\n\t\t\tgoto free_req_in;\n\t\t}\n\t\thidg->out_ep->driver_data = hidg;\n\n\t\t/*\n\t\t * allocate a bunch of read buffers and queue them all at once.\n\t\t */\n\t\tfor (i = 0; i < hidg->qlen && status == 0; i++) {\n\t\t\tstruct usb_request *req =\n\t\t\t\t\thidg_alloc_ep_req(hidg->out_ep,\n\t\t\t\t\t\t\t  hidg->report_length);\n\t\t\tif (req) {\n\t\t\t\treq->complete = hidg_set_report_complete;\n\t\t\t\treq->context  = hidg;\n\t\t\t\tstatus = usb_ep_queue(hidg->out_ep, req,\n\t\t\t\t\t\t      GFP_ATOMIC);\n\t\t\t\tif (status) {\n\t\t\t\t\tERROR(cdev, \"%s queue req --> %d\\n\",\n\t\t\t\t\t\thidg->out_ep->name, status);\n\t\t\t\t\tfree_ep_req(hidg->out_ep, req);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tgoto disable_out_ep;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (hidg->in_ep != NULL) {\n\t\tspin_lock_irqsave(&hidg->write_spinlock, flags);\n\t\thidg->req = req_in;\n\t\thidg->write_pending = 0;\n\t\tspin_unlock_irqrestore(&hidg->write_spinlock, flags);\n\n\t\twake_up(&hidg->write_queue);\n\t}\n\treturn 0;\ndisable_out_ep:\n\tusb_ep_disable(hidg->out_ep);\nfree_req_in:\n\tif (req_in)\n\t\tfree_ep_req(hidg->in_ep, req_in);\n\ndisable_ep_in:\n\tif (hidg->in_ep)\n\t\tusb_ep_disable(hidg->in_ep);\n\nfail:\n\treturn status;\n}\n\nstatic const struct file_operations f_hidg_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= f_hidg_open,\n\t.release\t= f_hidg_release,\n\t.write\t\t= f_hidg_write,\n\t.read\t\t= f_hidg_read,\n\t.poll\t\t= f_hidg_poll,\n\t.llseek\t\t= noop_llseek,\n};\n\nstatic int hidg_bind(struct usb_configuration *c, struct usb_function *f)\n{\n\tstruct usb_ep\t\t*ep;\n\tstruct f_hidg\t\t*hidg = func_to_hidg(f);\n\tstruct usb_string\t*us;\n\tstruct device\t\t*device;\n\tint\t\t\tstatus;\n\tdev_t\t\t\tdev;\n\n\t/* maybe allocate device-global string IDs, and patch descriptors */\n\tus = usb_gstrings_attach(c->cdev, ct_func_strings,\n\t\t\t\t ARRAY_SIZE(ct_func_string_defs));\n\tif (IS_ERR(us))\n\t\treturn PTR_ERR(us);\n\thidg_interface_desc.iInterface = us[CT_FUNC_HID_IDX].id;\n\n\t/* allocate instance-specific interface IDs, and patch descriptors */\n\tstatus = usb_interface_id(c, f);\n\tif (status < 0)\n\t\tgoto fail;\n\thidg_interface_desc.bInterfaceNumber = status;\n\n\t/* allocate instance-specific endpoints */\n\tstatus = -ENODEV;\n\tep = usb_ep_autoconfig(c->cdev->gadget, &hidg_fs_in_ep_desc);\n\tif (!ep)\n\t\tgoto fail;\n\thidg->in_ep = ep;\n\n\tep = usb_ep_autoconfig(c->cdev->gadget, &hidg_fs_out_ep_desc);\n\tif (!ep)\n\t\tgoto fail;\n\thidg->out_ep = ep;\n\n\t/* set descriptor dynamic values */\n\thidg_interface_desc.bInterfaceSubClass = hidg->bInterfaceSubClass;\n\thidg_interface_desc.bInterfaceProtocol = hidg->bInterfaceProtocol;\n\thidg->protocol = HID_REPORT_PROTOCOL;\n\thidg_ss_in_ep_desc.wMaxPacketSize = cpu_to_le16(hidg->report_length);\n\thidg_ss_in_comp_desc.wBytesPerInterval =\n\t\t\t\tcpu_to_le16(hidg->report_length);\n\thidg_hs_in_ep_desc.wMaxPacketSize = cpu_to_le16(hidg->report_length);\n\thidg_fs_in_ep_desc.wMaxPacketSize = cpu_to_le16(hidg->report_length);\n\thidg_ss_out_ep_desc.wMaxPacketSize = cpu_to_le16(hidg->report_length);\n\thidg_ss_out_comp_desc.wBytesPerInterval =\n\t\t\t\tcpu_to_le16(hidg->report_length);\n\thidg_hs_out_ep_desc.wMaxPacketSize = cpu_to_le16(hidg->report_length);\n\thidg_fs_out_ep_desc.wMaxPacketSize = cpu_to_le16(hidg->report_length);\n\t/*\n\t * We can use hidg_desc struct here but we should not relay\n\t * that its content won't change after returning from this function.\n\t */\n\thidg_desc.desc[0].bDescriptorType = HID_DT_REPORT;\n\thidg_desc.desc[0].wDescriptorLength =\n\t\tcpu_to_le16(hidg->report_desc_length);\n\n\thidg_hs_in_ep_desc.bEndpointAddress =\n\t\thidg_fs_in_ep_desc.bEndpointAddress;\n\thidg_hs_out_ep_desc.bEndpointAddress =\n\t\thidg_fs_out_ep_desc.bEndpointAddress;\n\n\thidg_ss_in_ep_desc.bEndpointAddress =\n\t\thidg_fs_in_ep_desc.bEndpointAddress;\n\thidg_ss_out_ep_desc.bEndpointAddress =\n\t\thidg_fs_out_ep_desc.bEndpointAddress;\n\n\tstatus = usb_assign_descriptors(f, hidg_fs_descriptors,\n\t\t\thidg_hs_descriptors, hidg_ss_descriptors, NULL);\n\tif (status)\n\t\tgoto fail;\n\n\tspin_lock_init(&hidg->write_spinlock);\n\thidg->write_pending = 1;\n\thidg->req = NULL;\n\tspin_lock_init(&hidg->read_spinlock);\n\tinit_waitqueue_head(&hidg->write_queue);\n\tinit_waitqueue_head(&hidg->read_queue);\n\tINIT_LIST_HEAD(&hidg->completed_out_req);\n\n\t/* create char device */\n\tcdev_init(&hidg->cdev, &f_hidg_fops);\n\tdev = MKDEV(major, hidg->minor);\n\tstatus = cdev_add(&hidg->cdev, dev, 1);\n\tif (status)\n\t\tgoto fail_free_descs;\n\n\tdevice = device_create(hidg_class, NULL, dev, NULL,\n\t\t\t       \"%s%d\", \"hidg\", hidg->minor);\n\tif (IS_ERR(device)) {\n\t\tstatus = PTR_ERR(device);\n\t\tgoto del;\n\t}\n\n\treturn 0;\ndel:\n\tcdev_del(&hidg->cdev);\nfail_free_descs:\n\tusb_free_all_descriptors(f);\nfail:\n\tERROR(f->config->cdev, \"hidg_bind FAILED\\n\");\n\tif (hidg->req != NULL)\n\t\tfree_ep_req(hidg->in_ep, hidg->req);\n\n\treturn status;\n}\n\nstatic inline int hidg_get_minor(void)\n{\n\tint ret;\n\n\tret = ida_simple_get(&hidg_ida, 0, 0, GFP_KERNEL);\n\tif (ret >= HIDG_MINORS) {\n\t\tida_simple_remove(&hidg_ida, ret);\n\t\tret = -ENODEV;\n\t}\n\n\treturn ret;\n}\n\nstatic inline struct f_hid_opts *to_f_hid_opts(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct f_hid_opts,\n\t\t\t    func_inst.group);\n}\n\nstatic void hid_attr_release(struct config_item *item)\n{\n\tstruct f_hid_opts *opts = to_f_hid_opts(item);\n\n\tusb_put_function_instance(&opts->func_inst);\n}\n\nstatic struct configfs_item_operations hidg_item_ops = {\n\t.release\t= hid_attr_release,\n};\n\n#define F_HID_OPT(name, prec, limit)\t\t\t\t\t\\\nstatic ssize_t f_hid_opts_##name##_show(struct config_item *item, char *page)\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct f_hid_opts *opts = to_f_hid_opts(item);\t\t\t\\\n\tint result;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&opts->lock);\t\t\t\t\t\\\n\tresult = sprintf(page, \"%d\\n\", opts->name);\t\t\t\\\n\tmutex_unlock(&opts->lock);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn result;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t f_hid_opts_##name##_store(struct config_item *item,\t\\\n\t\t\t\t\t const char *page, size_t len)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct f_hid_opts *opts = to_f_hid_opts(item);\t\t\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\tu##prec num;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&opts->lock);\t\t\t\t\t\\\n\tif (opts->refcnt) {\t\t\t\t\t\t\\\n\t\tret = -EBUSY;\t\t\t\t\t\t\\\n\t\tgoto end;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = kstrtou##prec(page, 0, &num);\t\t\t\t\\\n\tif (ret)\t\t\t\t\t\t\t\\\n\t\tgoto end;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (num > limit) {\t\t\t\t\t\t\\\n\t\tret = -EINVAL;\t\t\t\t\t\t\\\n\t\tgoto end;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\topts->name = num;\t\t\t\t\t\t\\\n\tret = len;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nend:\t\t\t\t\t\t\t\t\t\\\n\tmutex_unlock(&opts->lock);\t\t\t\t\t\\\n\treturn ret;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nCONFIGFS_ATTR(f_hid_opts_, name)\n\nF_HID_OPT(subclass, 8, 255);\nF_HID_OPT(protocol, 8, 255);\nF_HID_OPT(report_length, 16, 65535);\n\nstatic ssize_t f_hid_opts_report_desc_show(struct config_item *item, char *page)\n{\n\tstruct f_hid_opts *opts = to_f_hid_opts(item);\n\tint result;\n\n\tmutex_lock(&opts->lock);\n\tresult = opts->report_desc_length;\n\tmemcpy(page, opts->report_desc, opts->report_desc_length);\n\tmutex_unlock(&opts->lock);\n\n\treturn result;\n}\n\nstatic ssize_t f_hid_opts_report_desc_store(struct config_item *item,\n\t\t\t\t\t    const char *page, size_t len)\n{\n\tstruct f_hid_opts *opts = to_f_hid_opts(item);\n\tint ret = -EBUSY;\n\tchar *d;\n\n\tmutex_lock(&opts->lock);\n\n\tif (opts->refcnt)\n\t\tgoto end;\n\tif (len > PAGE_SIZE) {\n\t\tret = -ENOSPC;\n\t\tgoto end;\n\t}\n\td = kmemdup(page, len, GFP_KERNEL);\n\tif (!d) {\n\t\tret = -ENOMEM;\n\t\tgoto end;\n\t}\n\tkfree(opts->report_desc);\n\topts->report_desc = d;\n\topts->report_desc_length = len;\n\topts->report_desc_alloc = true;\n\tret = len;\nend:\n\tmutex_unlock(&opts->lock);\n\treturn ret;\n}\n\nCONFIGFS_ATTR(f_hid_opts_, report_desc);\n\nstatic ssize_t f_hid_opts_dev_show(struct config_item *item, char *page)\n{\n\tstruct f_hid_opts *opts = to_f_hid_opts(item);\n\n\treturn sprintf(page, \"%d:%d\\n\", major, opts->minor);\n}\n\nCONFIGFS_ATTR_RO(f_hid_opts_, dev);\n\nstatic struct configfs_attribute *hid_attrs[] = {\n\t&f_hid_opts_attr_subclass,\n\t&f_hid_opts_attr_protocol,\n\t&f_hid_opts_attr_report_length,\n\t&f_hid_opts_attr_report_desc,\n\t&f_hid_opts_attr_dev,\n\tNULL,\n};\n\nstatic const struct config_item_type hid_func_type = {\n\t.ct_item_ops\t= &hidg_item_ops,\n\t.ct_attrs\t= hid_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic inline void hidg_put_minor(int minor)\n{\n\tida_simple_remove(&hidg_ida, minor);\n}\n\nstatic void hidg_free_inst(struct usb_function_instance *f)\n{\n\tstruct f_hid_opts *opts;\n\n\topts = container_of(f, struct f_hid_opts, func_inst);\n\n\tmutex_lock(&hidg_ida_lock);\n\n\thidg_put_minor(opts->minor);\n\tif (ida_is_empty(&hidg_ida))\n\t\tghid_cleanup();\n\n\tmutex_unlock(&hidg_ida_lock);\n\n\tif (opts->report_desc_alloc)\n\t\tkfree(opts->report_desc);\n\n\tkfree(opts);\n}\n\nstatic struct usb_function_instance *hidg_alloc_inst(void)\n{\n\tstruct f_hid_opts *opts;\n\tstruct usb_function_instance *ret;\n\tint status = 0;\n\n\topts = kzalloc(sizeof(*opts), GFP_KERNEL);\n\tif (!opts)\n\t\treturn ERR_PTR(-ENOMEM);\n\tmutex_init(&opts->lock);\n\topts->func_inst.free_func_inst = hidg_free_inst;\n\tret = &opts->func_inst;\n\n\tmutex_lock(&hidg_ida_lock);\n\n\tif (ida_is_empty(&hidg_ida)) {\n\t\tstatus = ghid_setup(NULL, HIDG_MINORS);\n\t\tif (status)  {\n\t\t\tret = ERR_PTR(status);\n\t\t\tkfree(opts);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\topts->minor = hidg_get_minor();\n\tif (opts->minor < 0) {\n\t\tret = ERR_PTR(opts->minor);\n\t\tkfree(opts);\n\t\tif (ida_is_empty(&hidg_ida))\n\t\t\tghid_cleanup();\n\t\tgoto unlock;\n\t}\n\tconfig_group_init_type_name(&opts->func_inst.group, \"\", &hid_func_type);\n\nunlock:\n\tmutex_unlock(&hidg_ida_lock);\n\treturn ret;\n}\n\nstatic void hidg_free(struct usb_function *f)\n{\n\tstruct f_hidg *hidg;\n\tstruct f_hid_opts *opts;\n\n\thidg = func_to_hidg(f);\n\topts = container_of(f->fi, struct f_hid_opts, func_inst);\n\tkfree(hidg->report_desc);\n\tkfree(hidg);\n\tmutex_lock(&opts->lock);\n\t--opts->refcnt;\n\tmutex_unlock(&opts->lock);\n}\n\nstatic void hidg_unbind(struct usb_configuration *c, struct usb_function *f)\n{\n\tstruct f_hidg *hidg = func_to_hidg(f);\n\n\tdevice_destroy(hidg_class, MKDEV(major, hidg->minor));\n\tcdev_del(&hidg->cdev);\n\n\tusb_free_all_descriptors(f);\n}\n\nstatic struct usb_function *hidg_alloc(struct usb_function_instance *fi)\n{\n\tstruct f_hidg *hidg;\n\tstruct f_hid_opts *opts;\n\n\t/* allocate and initialize one new instance */\n\thidg = kzalloc(sizeof(*hidg), GFP_KERNEL);\n\tif (!hidg)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\topts = container_of(fi, struct f_hid_opts, func_inst);\n\n\tmutex_lock(&opts->lock);\n\t++opts->refcnt;\n\n\thidg->minor = opts->minor;\n\thidg->bInterfaceSubClass = opts->subclass;\n\thidg->bInterfaceProtocol = opts->protocol;\n\thidg->report_length = opts->report_length;\n\thidg->report_desc_length = opts->report_desc_length;\n\tif (opts->report_desc) {\n\t\thidg->report_desc = kmemdup(opts->report_desc,\n\t\t\t\t\t    opts->report_desc_length,\n\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!hidg->report_desc) {\n\t\t\tkfree(hidg);\n\t\t\tmutex_unlock(&opts->lock);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t}\n\n\tmutex_unlock(&opts->lock);\n\n\thidg->func.name    = \"hid\";\n\thidg->func.bind    = hidg_bind;\n\thidg->func.unbind  = hidg_unbind;\n\thidg->func.set_alt = hidg_set_alt;\n\thidg->func.disable = hidg_disable;\n\thidg->func.setup   = hidg_setup;\n\thidg->func.free_func = hidg_free;\n\n\t/* this could me made configurable at some point */\n\thidg->qlen\t   = 4;\n\n\treturn &hidg->func;\n}\n\nDECLARE_USB_FUNCTION_INIT(hid, hidg_alloc_inst, hidg_alloc);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Fabien Chouteau\");\n\nint ghid_setup(struct usb_gadget *g, int count)\n{\n\tint status;\n\tdev_t dev;\n\n\thidg_class = class_create(THIS_MODULE, \"hidg\");\n\tif (IS_ERR(hidg_class)) {\n\t\tstatus = PTR_ERR(hidg_class);\n\t\thidg_class = NULL;\n\t\treturn status;\n\t}\n\n\tstatus = alloc_chrdev_region(&dev, 0, count, \"hidg\");\n\tif (status) {\n\t\tclass_destroy(hidg_class);\n\t\thidg_class = NULL;\n\t\treturn status;\n\t}\n\n\tmajor = MAJOR(dev);\n\tminors = count;\n\n\treturn 0;\n}\n\nvoid ghid_cleanup(void)\n{\n\tif (major) {\n\t\tunregister_chrdev_region(MKDEV(major, 0), minors);\n\t\tmajor = minors = 0;\n\t}\n\n\tclass_destroy(hidg_class);\n\thidg_class = NULL;\n}\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0+\n/*\n * f_hid.c -- USB HID function driver\n *\n * Copyright (C) 2010 Fabien Chouteau <fabien.chouteau@barco.com>\n */\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/hid.h>\n#include <linux/idr.h>\n#include <linux/cdev.h>\n#include <linux/mutex.h>\n#include <linux/poll.h>\n#include <linux/uaccess.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/usb/g_hid.h>\n\n#include \"u_f.h\"\n#include \"u_hid.h\"\n\n#define HIDG_MINORS\t4\n\nstatic int major, minors;\nstatic struct class *hidg_class;\nstatic DEFINE_IDA(hidg_ida);\nstatic DEFINE_MUTEX(hidg_ida_lock); /* protects access to hidg_ida */\n\n/*-------------------------------------------------------------------------*/\n/*                            HID gadget struct                            */\n\nstruct f_hidg_req_list {\n\tstruct usb_request\t*req;\n\tunsigned int\t\tpos;\n\tstruct list_head \tlist;\n};\n\nstruct f_hidg {\n\t/* configuration */\n\tunsigned char\t\t\tbInterfaceSubClass;\n\tunsigned char\t\t\tbInterfaceProtocol;\n\tunsigned char\t\t\tprotocol;\n\tunsigned short\t\t\treport_desc_length;\n\tchar\t\t\t\t*report_desc;\n\tunsigned short\t\t\treport_length;\n\n\t/* recv report */\n\tstruct list_head\t\tcompleted_out_req;\n\tspinlock_t\t\t\tread_spinlock;\n\twait_queue_head_t\t\tread_queue;\n\tunsigned int\t\t\tqlen;\n\n\t/* send report */\n\tspinlock_t\t\t\twrite_spinlock;\n\tbool\t\t\t\twrite_pending;\n\twait_queue_head_t\t\twrite_queue;\n\tstruct usb_request\t\t*req;\n\n\tint\t\t\t\tminor;\n\tstruct cdev\t\t\tcdev;\n\tstruct usb_function\t\tfunc;\n\n\tstruct usb_ep\t\t\t*in_ep;\n\tstruct usb_ep\t\t\t*out_ep;\n};\n\nstatic inline struct f_hidg *func_to_hidg(struct usb_function *f)\n{\n\treturn container_of(f, struct f_hidg, func);\n}\n\n/*-------------------------------------------------------------------------*/\n/*                           Static descriptors                            */\n\nstatic struct usb_interface_descriptor hidg_interface_desc = {\n\t.bLength\t\t= sizeof hidg_interface_desc,\n\t.bDescriptorType\t= USB_DT_INTERFACE,\n\t/* .bInterfaceNumber\t= DYNAMIC */\n\t.bAlternateSetting\t= 0,\n\t.bNumEndpoints\t\t= 2,\n\t.bInterfaceClass\t= USB_CLASS_HID,\n\t/* .bInterfaceSubClass\t= DYNAMIC */\n\t/* .bInterfaceProtocol\t= DYNAMIC */\n\t/* .iInterface\t\t= DYNAMIC */\n};\n\nstatic struct hid_descriptor hidg_desc = {\n\t.bLength\t\t\t= sizeof hidg_desc,\n\t.bDescriptorType\t\t= HID_DT_HID,\n\t.bcdHID\t\t\t\t= 0x0101,\n\t.bCountryCode\t\t\t= 0x00,\n\t.bNumDescriptors\t\t= 0x1,\n\t/*.desc[0].bDescriptorType\t= DYNAMIC */\n\t/*.desc[0].wDescriptorLenght\t= DYNAMIC */\n};\n\n/* Super-Speed Support */\n\nstatic struct usb_endpoint_descriptor hidg_ss_in_ep_desc = {\n\t.bLength\t\t= USB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType\t= USB_DT_ENDPOINT,\n\t.bEndpointAddress\t= USB_DIR_IN,\n\t.bmAttributes\t\t= USB_ENDPOINT_XFER_INT,\n\t/*.wMaxPacketSize\t= DYNAMIC */\n\t.bInterval\t\t= 4, /* FIXME: Add this field in the\n\t\t\t\t      * HID gadget configuration?\n\t\t\t\t      * (struct hidg_func_descriptor)\n\t\t\t\t      */\n};\n\nstatic struct usb_ss_ep_comp_descriptor hidg_ss_in_comp_desc = {\n\t.bLength                = sizeof(hidg_ss_in_comp_desc),\n\t.bDescriptorType        = USB_DT_SS_ENDPOINT_COMP,\n\n\t/* .bMaxBurst           = 0, */\n\t/* .bmAttributes        = 0, */\n\t/* .wBytesPerInterval   = DYNAMIC */\n};\n\nstatic struct usb_endpoint_descriptor hidg_ss_out_ep_desc = {\n\t.bLength\t\t= USB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType\t= USB_DT_ENDPOINT,\n\t.bEndpointAddress\t= USB_DIR_OUT,\n\t.bmAttributes\t\t= USB_ENDPOINT_XFER_INT,\n\t/*.wMaxPacketSize\t= DYNAMIC */\n\t.bInterval\t\t= 4, /* FIXME: Add this field in the\n\t\t\t\t      * HID gadget configuration?\n\t\t\t\t      * (struct hidg_func_descriptor)\n\t\t\t\t      */\n};\n\nstatic struct usb_ss_ep_comp_descriptor hidg_ss_out_comp_desc = {\n\t.bLength                = sizeof(hidg_ss_out_comp_desc),\n\t.bDescriptorType        = USB_DT_SS_ENDPOINT_COMP,\n\n\t/* .bMaxBurst           = 0, */\n\t/* .bmAttributes        = 0, */\n\t/* .wBytesPerInterval   = DYNAMIC */\n};\n\nstatic struct usb_descriptor_header *hidg_ss_descriptors[] = {\n\t(struct usb_descriptor_header *)&hidg_interface_desc,\n\t(struct usb_descriptor_header *)&hidg_desc,\n\t(struct usb_descriptor_header *)&hidg_ss_in_ep_desc,\n\t(struct usb_descriptor_header *)&hidg_ss_in_comp_desc,\n\t(struct usb_descriptor_header *)&hidg_ss_out_ep_desc,\n\t(struct usb_descriptor_header *)&hidg_ss_out_comp_desc,\n\tNULL,\n};\n\n/* High-Speed Support */\n\nstatic struct usb_endpoint_descriptor hidg_hs_in_ep_desc = {\n\t.bLength\t\t= USB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType\t= USB_DT_ENDPOINT,\n\t.bEndpointAddress\t= USB_DIR_IN,\n\t.bmAttributes\t\t= USB_ENDPOINT_XFER_INT,\n\t/*.wMaxPacketSize\t= DYNAMIC */\n\t.bInterval\t\t= 4, /* FIXME: Add this field in the\n\t\t\t\t      * HID gadget configuration?\n\t\t\t\t      * (struct hidg_func_descriptor)\n\t\t\t\t      */\n};\n\nstatic struct usb_endpoint_descriptor hidg_hs_out_ep_desc = {\n\t.bLength\t\t= USB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType\t= USB_DT_ENDPOINT,\n\t.bEndpointAddress\t= USB_DIR_OUT,\n\t.bmAttributes\t\t= USB_ENDPOINT_XFER_INT,\n\t/*.wMaxPacketSize\t= DYNAMIC */\n\t.bInterval\t\t= 4, /* FIXME: Add this field in the\n\t\t\t\t      * HID gadget configuration?\n\t\t\t\t      * (struct hidg_func_descriptor)\n\t\t\t\t      */\n};\n\nstatic struct usb_descriptor_header *hidg_hs_descriptors[] = {\n\t(struct usb_descriptor_header *)&hidg_interface_desc,\n\t(struct usb_descriptor_header *)&hidg_desc,\n\t(struct usb_descriptor_header *)&hidg_hs_in_ep_desc,\n\t(struct usb_descriptor_header *)&hidg_hs_out_ep_desc,\n\tNULL,\n};\n\n/* Full-Speed Support */\n\nstatic struct usb_endpoint_descriptor hidg_fs_in_ep_desc = {\n\t.bLength\t\t= USB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType\t= USB_DT_ENDPOINT,\n\t.bEndpointAddress\t= USB_DIR_IN,\n\t.bmAttributes\t\t= USB_ENDPOINT_XFER_INT,\n\t/*.wMaxPacketSize\t= DYNAMIC */\n\t.bInterval\t\t= 10, /* FIXME: Add this field in the\n\t\t\t\t       * HID gadget configuration?\n\t\t\t\t       * (struct hidg_func_descriptor)\n\t\t\t\t       */\n};\n\nstatic struct usb_endpoint_descriptor hidg_fs_out_ep_desc = {\n\t.bLength\t\t= USB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType\t= USB_DT_ENDPOINT,\n\t.bEndpointAddress\t= USB_DIR_OUT,\n\t.bmAttributes\t\t= USB_ENDPOINT_XFER_INT,\n\t/*.wMaxPacketSize\t= DYNAMIC */\n\t.bInterval\t\t= 10, /* FIXME: Add this field in the\n\t\t\t\t       * HID gadget configuration?\n\t\t\t\t       * (struct hidg_func_descriptor)\n\t\t\t\t       */\n};\n\nstatic struct usb_descriptor_header *hidg_fs_descriptors[] = {\n\t(struct usb_descriptor_header *)&hidg_interface_desc,\n\t(struct usb_descriptor_header *)&hidg_desc,\n\t(struct usb_descriptor_header *)&hidg_fs_in_ep_desc,\n\t(struct usb_descriptor_header *)&hidg_fs_out_ep_desc,\n\tNULL,\n};\n\n/*-------------------------------------------------------------------------*/\n/*                                 Strings                                 */\n\n#define CT_FUNC_HID_IDX\t0\n\nstatic struct usb_string ct_func_string_defs[] = {\n\t[CT_FUNC_HID_IDX].s\t= \"HID Interface\",\n\t{},\t\t\t/* end of list */\n};\n\nstatic struct usb_gadget_strings ct_func_string_table = {\n\t.language\t= 0x0409,\t/* en-US */\n\t.strings\t= ct_func_string_defs,\n};\n\nstatic struct usb_gadget_strings *ct_func_strings[] = {\n\t&ct_func_string_table,\n\tNULL,\n};\n\n/*-------------------------------------------------------------------------*/\n/*                              Char Device                                */\n\nstatic ssize_t f_hidg_read(struct file *file, char __user *buffer,\n\t\t\tsize_t count, loff_t *ptr)\n{\n\tstruct f_hidg *hidg = file->private_data;\n\tstruct f_hidg_req_list *list;\n\tstruct usb_request *req;\n\tunsigned long flags;\n\tint ret;\n\n\tif (!count)\n\t\treturn 0;\n\n\tif (!access_ok(buffer, count))\n\t\treturn -EFAULT;\n\n\tspin_lock_irqsave(&hidg->read_spinlock, flags);\n\n#define READ_COND (!list_empty(&hidg->completed_out_req))\n\n\t/* wait for at least one buffer to complete */\n\twhile (!READ_COND) {\n\t\tspin_unlock_irqrestore(&hidg->read_spinlock, flags);\n\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\n\t\tif (wait_event_interruptible(hidg->read_queue, READ_COND))\n\t\t\treturn -ERESTARTSYS;\n\n\t\tspin_lock_irqsave(&hidg->read_spinlock, flags);\n\t}\n\n\t/* pick the first one */\n\tlist = list_first_entry(&hidg->completed_out_req,\n\t\t\t\tstruct f_hidg_req_list, list);\n\n\t/*\n\t * Remove this from list to protect it from beign free()\n\t * while host disables our function\n\t */\n\tlist_del(&list->list);\n\n\treq = list->req;\n\tcount = min_t(unsigned int, count, req->actual - list->pos);\n\tspin_unlock_irqrestore(&hidg->read_spinlock, flags);\n\n\t/* copy to user outside spinlock */\n\tcount -= copy_to_user(buffer, req->buf + list->pos, count);\n\tlist->pos += count;\n\n\t/*\n\t * if this request is completely handled and transfered to\n\t * userspace, remove its entry from the list and requeue it\n\t * again. Otherwise, we will revisit it again upon the next\n\t * call, taking into account its current read position.\n\t */\n\tif (list->pos == req->actual) {\n\t\tkfree(list);\n\n\t\treq->length = hidg->report_length;\n\t\tret = usb_ep_queue(hidg->out_ep, req, GFP_KERNEL);\n\t\tif (ret < 0) {\n\t\t\tfree_ep_req(hidg->out_ep, req);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tspin_lock_irqsave(&hidg->read_spinlock, flags);\n\t\tlist_add(&list->list, &hidg->completed_out_req);\n\t\tspin_unlock_irqrestore(&hidg->read_spinlock, flags);\n\n\t\twake_up(&hidg->read_queue);\n\t}\n\n\treturn count;\n}\n\nstatic void f_hidg_req_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct f_hidg *hidg = (struct f_hidg *)ep->driver_data;\n\tunsigned long flags;\n\n\tif (req->status != 0) {\n\t\tERROR(hidg->func.config->cdev,\n\t\t\t\"End Point Request ERROR: %d\\n\", req->status);\n\t}\n\n\tspin_lock_irqsave(&hidg->write_spinlock, flags);\n\thidg->write_pending = 0;\n\tspin_unlock_irqrestore(&hidg->write_spinlock, flags);\n\twake_up(&hidg->write_queue);\n}\n\nstatic ssize_t f_hidg_write(struct file *file, const char __user *buffer,\n\t\t\t    size_t count, loff_t *offp)\n{\n\tstruct f_hidg *hidg  = file->private_data;\n\tstruct usb_request *req;\n\tunsigned long flags;\n\tssize_t status = -ENOMEM;\n\n\tif (!access_ok(buffer, count))\n\t\treturn -EFAULT;\n\n\tspin_lock_irqsave(&hidg->write_spinlock, flags);\n\n#define WRITE_COND (!hidg->write_pending)\ntry_again:\n\t/* write queue */\n\twhile (!WRITE_COND) {\n\t\tspin_unlock_irqrestore(&hidg->write_spinlock, flags);\n\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\n\t\tif (wait_event_interruptible_exclusive(\n\t\t\t\thidg->write_queue, WRITE_COND))\n\t\t\treturn -ERESTARTSYS;\n\n\t\tspin_lock_irqsave(&hidg->write_spinlock, flags);\n\t}\n\n\thidg->write_pending = 1;\n\treq = hidg->req;\n\tcount  = min_t(unsigned, count, hidg->report_length);\n\n\tspin_unlock_irqrestore(&hidg->write_spinlock, flags);\n\tstatus = copy_from_user(req->buf, buffer, count);\n\n\tif (status != 0) {\n\t\tERROR(hidg->func.config->cdev,\n\t\t\t\"copy_from_user error\\n\");\n\t\tstatus = -EINVAL;\n\t\tgoto release_write_pending;\n\t}\n\n\tspin_lock_irqsave(&hidg->write_spinlock, flags);\n\n\t/* when our function has been disabled by host */\n\tif (!hidg->req) {\n\t\tfree_ep_req(hidg->in_ep, req);\n\t\t/*\n\t\t * TODO\n\t\t * Should we fail with error here?\n\t\t */\n\t\tgoto try_again;\n\t}\n\n\treq->status   = 0;\n\treq->zero     = 0;\n\treq->length   = count;\n\treq->complete = f_hidg_req_complete;\n\treq->context  = hidg;\n\n\tspin_unlock_irqrestore(&hidg->write_spinlock, flags);\n\n\tstatus = usb_ep_queue(hidg->in_ep, req, GFP_ATOMIC);\n\tif (status < 0) {\n\t\tERROR(hidg->func.config->cdev,\n\t\t\t\"usb_ep_queue error on int endpoint %zd\\n\", status);\n\t\tgoto release_write_pending;\n\t} else {\n\t\tstatus = count;\n\t}\n\n\treturn status;\nrelease_write_pending:\n\tspin_lock_irqsave(&hidg->write_spinlock, flags);\n\thidg->write_pending = 0;\n\tspin_unlock_irqrestore(&hidg->write_spinlock, flags);\n\n\twake_up(&hidg->write_queue);\n\n\treturn status;\n}\n\nstatic __poll_t f_hidg_poll(struct file *file, poll_table *wait)\n{\n\tstruct f_hidg\t*hidg  = file->private_data;\n\t__poll_t\tret = 0;\n\n\tpoll_wait(file, &hidg->read_queue, wait);\n\tpoll_wait(file, &hidg->write_queue, wait);\n\n\tif (WRITE_COND)\n\t\tret |= EPOLLOUT | EPOLLWRNORM;\n\n\tif (READ_COND)\n\t\tret |= EPOLLIN | EPOLLRDNORM;\n\n\treturn ret;\n}\n\n#undef WRITE_COND\n#undef READ_COND\n\nstatic int f_hidg_release(struct inode *inode, struct file *fd)\n{\n\tfd->private_data = NULL;\n\treturn 0;\n}\n\nstatic int f_hidg_open(struct inode *inode, struct file *fd)\n{\n\tstruct f_hidg *hidg =\n\t\tcontainer_of(inode->i_cdev, struct f_hidg, cdev);\n\n\tfd->private_data = hidg;\n\n\treturn 0;\n}\n\n/*-------------------------------------------------------------------------*/\n/*                                usb_function                             */\n\nstatic inline struct usb_request *hidg_alloc_ep_req(struct usb_ep *ep,\n\t\t\t\t\t\t    unsigned length)\n{\n\treturn alloc_ep_req(ep, length);\n}\n\nstatic void hidg_set_report_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct f_hidg *hidg = (struct f_hidg *) req->context;\n\tstruct usb_composite_dev *cdev = hidg->func.config->cdev;\n\tstruct f_hidg_req_list *req_list;\n\tunsigned long flags;\n\n\tswitch (req->status) {\n\tcase 0:\n\t\treq_list = kzalloc(sizeof(*req_list), GFP_ATOMIC);\n\t\tif (!req_list) {\n\t\t\tERROR(cdev, \"Unable to allocate mem for req_list\\n\");\n\t\t\tgoto free_req;\n\t\t}\n\n\t\treq_list->req = req;\n\n\t\tspin_lock_irqsave(&hidg->read_spinlock, flags);\n\t\tlist_add_tail(&req_list->list, &hidg->completed_out_req);\n\t\tspin_unlock_irqrestore(&hidg->read_spinlock, flags);\n\n\t\twake_up(&hidg->read_queue);\n\t\tbreak;\n\tdefault:\n\t\tERROR(cdev, \"Set report failed %d\\n\", req->status);\n\t\t/* FALLTHROUGH */\n\tcase -ECONNABORTED:\t\t/* hardware forced ep reset */\n\tcase -ECONNRESET:\t\t/* request dequeued */\n\tcase -ESHUTDOWN:\t\t/* disconnect from host */\nfree_req:\n\t\tfree_ep_req(ep, req);\n\t\treturn;\n\t}\n}\n\nstatic int hidg_setup(struct usb_function *f,\n\t\tconst struct usb_ctrlrequest *ctrl)\n{\n\tstruct f_hidg\t\t\t*hidg = func_to_hidg(f);\n\tstruct usb_composite_dev\t*cdev = f->config->cdev;\n\tstruct usb_request\t\t*req  = cdev->req;\n\tint status = 0;\n\t__u16 value, length;\n\n\tvalue\t= __le16_to_cpu(ctrl->wValue);\n\tlength\t= __le16_to_cpu(ctrl->wLength);\n\n\tVDBG(cdev,\n\t     \"%s crtl_request : bRequestType:0x%x bRequest:0x%x Value:0x%x\\n\",\n\t     __func__, ctrl->bRequestType, ctrl->bRequest, value);\n\n\tswitch ((ctrl->bRequestType << 8) | ctrl->bRequest) {\n\tcase ((USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8\n\t\t  | HID_REQ_GET_REPORT):\n\t\tVDBG(cdev, \"get_report\\n\");\n\n\t\t/* send an empty report */\n\t\tlength = min_t(unsigned, length, hidg->report_length);\n\t\tmemset(req->buf, 0x0, length);\n\n\t\tgoto respond;\n\t\tbreak;\n\n\tcase ((USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8\n\t\t  | HID_REQ_GET_PROTOCOL):\n\t\tVDBG(cdev, \"get_protocol\\n\");\n\t\tlength = min_t(unsigned int, length, 1);\n\t\t((u8 *) req->buf)[0] = hidg->protocol;\n\t\tgoto respond;\n\t\tbreak;\n\n\tcase ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8\n\t\t  | HID_REQ_SET_REPORT):\n\t\tVDBG(cdev, \"set_report | wLength=%d\\n\", ctrl->wLength);\n\t\tgoto stall;\n\t\tbreak;\n\n\tcase ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8\n\t\t  | HID_REQ_SET_PROTOCOL):\n\t\tVDBG(cdev, \"set_protocol\\n\");\n\t\tif (value > HID_REPORT_PROTOCOL)\n\t\t\tgoto stall;\n\t\tlength = 0;\n\t\t/*\n\t\t * We assume that programs implementing the Boot protocol\n\t\t * are also compatible with the Report Protocol\n\t\t */\n\t\tif (hidg->bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT) {\n\t\t\thidg->protocol = value;\n\t\t\tgoto respond;\n\t\t}\n\t\tgoto stall;\n\t\tbreak;\n\n\tcase ((USB_DIR_IN | USB_TYPE_STANDARD | USB_RECIP_INTERFACE) << 8\n\t\t  | USB_REQ_GET_DESCRIPTOR):\n\t\tswitch (value >> 8) {\n\t\tcase HID_DT_HID:\n\t\t{\n\t\t\tstruct hid_descriptor hidg_desc_copy = hidg_desc;\n\n\t\t\tVDBG(cdev, \"USB_REQ_GET_DESCRIPTOR: HID\\n\");\n\t\t\thidg_desc_copy.desc[0].bDescriptorType = HID_DT_REPORT;\n\t\t\thidg_desc_copy.desc[0].wDescriptorLength =\n\t\t\t\tcpu_to_le16(hidg->report_desc_length);\n\n\t\t\tlength = min_t(unsigned short, length,\n\t\t\t\t\t\t   hidg_desc_copy.bLength);\n\t\t\tmemcpy(req->buf, &hidg_desc_copy, length);\n\t\t\tgoto respond;\n\t\t\tbreak;\n\t\t}\n\t\tcase HID_DT_REPORT:\n\t\t\tVDBG(cdev, \"USB_REQ_GET_DESCRIPTOR: REPORT\\n\");\n\t\t\tlength = min_t(unsigned short, length,\n\t\t\t\t\t\t   hidg->report_desc_length);\n\t\t\tmemcpy(req->buf, hidg->report_desc, length);\n\t\t\tgoto respond;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tVDBG(cdev, \"Unknown descriptor request 0x%x\\n\",\n\t\t\t\t value >> 8);\n\t\t\tgoto stall;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tVDBG(cdev, \"Unknown request 0x%x\\n\",\n\t\t\t ctrl->bRequest);\n\t\tgoto stall;\n\t\tbreak;\n\t}\n\nstall:\n\treturn -EOPNOTSUPP;\n\nrespond:\n\treq->zero = 0;\n\treq->length = length;\n\tstatus = usb_ep_queue(cdev->gadget->ep0, req, GFP_ATOMIC);\n\tif (status < 0)\n\t\tERROR(cdev, \"usb_ep_queue error on ep0 %d\\n\", value);\n\treturn status;\n}\n\nstatic void hidg_disable(struct usb_function *f)\n{\n\tstruct f_hidg *hidg = func_to_hidg(f);\n\tstruct f_hidg_req_list *list, *next;\n\tunsigned long flags;\n\n\tusb_ep_disable(hidg->in_ep);\n\tusb_ep_disable(hidg->out_ep);\n\n\tspin_lock_irqsave(&hidg->read_spinlock, flags);\n\tlist_for_each_entry_safe(list, next, &hidg->completed_out_req, list) {\n\t\tfree_ep_req(hidg->out_ep, list->req);\n\t\tlist_del(&list->list);\n\t\tkfree(list);\n\t}\n\tspin_unlock_irqrestore(&hidg->read_spinlock, flags);\n\n\tspin_lock_irqsave(&hidg->write_spinlock, flags);\n\tif (!hidg->write_pending) {\n\t\tfree_ep_req(hidg->in_ep, hidg->req);\n\t\thidg->write_pending = 1;\n\t}\n\n\thidg->req = NULL;\n\tspin_unlock_irqrestore(&hidg->write_spinlock, flags);\n}\n\nstatic int hidg_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\n{\n\tstruct usb_composite_dev\t\t*cdev = f->config->cdev;\n\tstruct f_hidg\t\t\t\t*hidg = func_to_hidg(f);\n\tstruct usb_request\t\t\t*req_in = NULL;\n\tunsigned long\t\t\t\tflags;\n\tint i, status = 0;\n\n\tVDBG(cdev, \"hidg_set_alt intf:%d alt:%d\\n\", intf, alt);\n\n\tif (hidg->in_ep != NULL) {\n\t\t/* restart endpoint */\n\t\tusb_ep_disable(hidg->in_ep);\n\n\t\tstatus = config_ep_by_speed(f->config->cdev->gadget, f,\n\t\t\t\t\t    hidg->in_ep);\n\t\tif (status) {\n\t\t\tERROR(cdev, \"config_ep_by_speed FAILED!\\n\");\n\t\t\tgoto fail;\n\t\t}\n\t\tstatus = usb_ep_enable(hidg->in_ep);\n\t\tif (status < 0) {\n\t\t\tERROR(cdev, \"Enable IN endpoint FAILED!\\n\");\n\t\t\tgoto fail;\n\t\t}\n\t\thidg->in_ep->driver_data = hidg;\n\n\t\treq_in = hidg_alloc_ep_req(hidg->in_ep, hidg->report_length);\n\t\tif (!req_in) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tgoto disable_ep_in;\n\t\t}\n\t}\n\n\n\tif (hidg->out_ep != NULL) {\n\t\t/* restart endpoint */\n\t\tusb_ep_disable(hidg->out_ep);\n\n\t\tstatus = config_ep_by_speed(f->config->cdev->gadget, f,\n\t\t\t\t\t    hidg->out_ep);\n\t\tif (status) {\n\t\t\tERROR(cdev, \"config_ep_by_speed FAILED!\\n\");\n\t\t\tgoto free_req_in;\n\t\t}\n\t\tstatus = usb_ep_enable(hidg->out_ep);\n\t\tif (status < 0) {\n\t\t\tERROR(cdev, \"Enable OUT endpoint FAILED!\\n\");\n\t\t\tgoto free_req_in;\n\t\t}\n\t\thidg->out_ep->driver_data = hidg;\n\n\t\t/*\n\t\t * allocate a bunch of read buffers and queue them all at once.\n\t\t */\n\t\tfor (i = 0; i < hidg->qlen && status == 0; i++) {\n\t\t\tstruct usb_request *req =\n\t\t\t\t\thidg_alloc_ep_req(hidg->out_ep,\n\t\t\t\t\t\t\t  hidg->report_length);\n\t\t\tif (req) {\n\t\t\t\treq->complete = hidg_set_report_complete;\n\t\t\t\treq->context  = hidg;\n\t\t\t\tstatus = usb_ep_queue(hidg->out_ep, req,\n\t\t\t\t\t\t      GFP_ATOMIC);\n\t\t\t\tif (status) {\n\t\t\t\t\tERROR(cdev, \"%s queue req --> %d\\n\",\n\t\t\t\t\t\thidg->out_ep->name, status);\n\t\t\t\t\tfree_ep_req(hidg->out_ep, req);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tgoto disable_out_ep;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (hidg->in_ep != NULL) {\n\t\tspin_lock_irqsave(&hidg->write_spinlock, flags);\n\t\thidg->req = req_in;\n\t\thidg->write_pending = 0;\n\t\tspin_unlock_irqrestore(&hidg->write_spinlock, flags);\n\n\t\twake_up(&hidg->write_queue);\n\t}\n\treturn 0;\ndisable_out_ep:\n\tusb_ep_disable(hidg->out_ep);\nfree_req_in:\n\tif (req_in)\n\t\tfree_ep_req(hidg->in_ep, req_in);\n\ndisable_ep_in:\n\tif (hidg->in_ep)\n\t\tusb_ep_disable(hidg->in_ep);\n\nfail:\n\treturn status;\n}\n\nstatic const struct file_operations f_hidg_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= f_hidg_open,\n\t.release\t= f_hidg_release,\n\t.write\t\t= f_hidg_write,\n\t.read\t\t= f_hidg_read,\n\t.poll\t\t= f_hidg_poll,\n\t.llseek\t\t= noop_llseek,\n};\n\nstatic int hidg_bind(struct usb_configuration *c, struct usb_function *f)\n{\n\tstruct usb_ep\t\t*ep;\n\tstruct f_hidg\t\t*hidg = func_to_hidg(f);\n\tstruct usb_string\t*us;\n\tstruct device\t\t*device;\n\tint\t\t\tstatus;\n\tdev_t\t\t\tdev;\n\n\t/* maybe allocate device-global string IDs, and patch descriptors */\n\tus = usb_gstrings_attach(c->cdev, ct_func_strings,\n\t\t\t\t ARRAY_SIZE(ct_func_string_defs));\n\tif (IS_ERR(us))\n\t\treturn PTR_ERR(us);\n\thidg_interface_desc.iInterface = us[CT_FUNC_HID_IDX].id;\n\n\t/* allocate instance-specific interface IDs, and patch descriptors */\n\tstatus = usb_interface_id(c, f);\n\tif (status < 0)\n\t\tgoto fail;\n\thidg_interface_desc.bInterfaceNumber = status;\n\n\t/* allocate instance-specific endpoints */\n\tstatus = -ENODEV;\n\tep = usb_ep_autoconfig(c->cdev->gadget, &hidg_fs_in_ep_desc);\n\tif (!ep)\n\t\tgoto fail;\n\thidg->in_ep = ep;\n\n\tep = usb_ep_autoconfig(c->cdev->gadget, &hidg_fs_out_ep_desc);\n\tif (!ep)\n\t\tgoto fail;\n\thidg->out_ep = ep;\n\n\t/* set descriptor dynamic values */\n\thidg_interface_desc.bInterfaceSubClass = hidg->bInterfaceSubClass;\n\thidg_interface_desc.bInterfaceProtocol = hidg->bInterfaceProtocol;\n\thidg->protocol = HID_REPORT_PROTOCOL;\n\thidg_ss_in_ep_desc.wMaxPacketSize = cpu_to_le16(hidg->report_length);\n\thidg_ss_in_comp_desc.wBytesPerInterval =\n\t\t\t\tcpu_to_le16(hidg->report_length);\n\thidg_hs_in_ep_desc.wMaxPacketSize = cpu_to_le16(hidg->report_length);\n\thidg_fs_in_ep_desc.wMaxPacketSize = cpu_to_le16(hidg->report_length);\n\thidg_ss_out_ep_desc.wMaxPacketSize = cpu_to_le16(hidg->report_length);\n\thidg_ss_out_comp_desc.wBytesPerInterval =\n\t\t\t\tcpu_to_le16(hidg->report_length);\n\thidg_hs_out_ep_desc.wMaxPacketSize = cpu_to_le16(hidg->report_length);\n\thidg_fs_out_ep_desc.wMaxPacketSize = cpu_to_le16(hidg->report_length);\n\t/*\n\t * We can use hidg_desc struct here but we should not relay\n\t * that its content won't change after returning from this function.\n\t */\n\thidg_desc.desc[0].bDescriptorType = HID_DT_REPORT;\n\thidg_desc.desc[0].wDescriptorLength =\n\t\tcpu_to_le16(hidg->report_desc_length);\n\n\thidg_hs_in_ep_desc.bEndpointAddress =\n\t\thidg_fs_in_ep_desc.bEndpointAddress;\n\thidg_hs_out_ep_desc.bEndpointAddress =\n\t\thidg_fs_out_ep_desc.bEndpointAddress;\n\n\thidg_ss_in_ep_desc.bEndpointAddress =\n\t\thidg_fs_in_ep_desc.bEndpointAddress;\n\thidg_ss_out_ep_desc.bEndpointAddress =\n\t\thidg_fs_out_ep_desc.bEndpointAddress;\n\n\tstatus = usb_assign_descriptors(f, hidg_fs_descriptors,\n\t\t\thidg_hs_descriptors, hidg_ss_descriptors, NULL);\n\tif (status)\n\t\tgoto fail;\n\n\tspin_lock_init(&hidg->write_spinlock);\n\thidg->write_pending = 1;\n\thidg->req = NULL;\n\tspin_lock_init(&hidg->read_spinlock);\n\tinit_waitqueue_head(&hidg->write_queue);\n\tinit_waitqueue_head(&hidg->read_queue);\n\tINIT_LIST_HEAD(&hidg->completed_out_req);\n\n\t/* create char device */\n\tcdev_init(&hidg->cdev, &f_hidg_fops);\n\tdev = MKDEV(major, hidg->minor);\n\tstatus = cdev_add(&hidg->cdev, dev, 1);\n\tif (status)\n\t\tgoto fail_free_descs;\n\n\tdevice = device_create(hidg_class, NULL, dev, NULL,\n\t\t\t       \"%s%d\", \"hidg\", hidg->minor);\n\tif (IS_ERR(device)) {\n\t\tstatus = PTR_ERR(device);\n\t\tgoto del;\n\t}\n\n\treturn 0;\ndel:\n\tcdev_del(&hidg->cdev);\nfail_free_descs:\n\tusb_free_all_descriptors(f);\nfail:\n\tERROR(f->config->cdev, \"hidg_bind FAILED\\n\");\n\tif (hidg->req != NULL)\n\t\tfree_ep_req(hidg->in_ep, hidg->req);\n\n\treturn status;\n}\n\nstatic inline int hidg_get_minor(void)\n{\n\tint ret;\n\n\tret = ida_simple_get(&hidg_ida, 0, 0, GFP_KERNEL);\n\tif (ret >= HIDG_MINORS) {\n\t\tida_simple_remove(&hidg_ida, ret);\n\t\tret = -ENODEV;\n\t}\n\n\treturn ret;\n}\n\nstatic inline struct f_hid_opts *to_f_hid_opts(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct f_hid_opts,\n\t\t\t    func_inst.group);\n}\n\nstatic void hid_attr_release(struct config_item *item)\n{\n\tstruct f_hid_opts *opts = to_f_hid_opts(item);\n\n\tusb_put_function_instance(&opts->func_inst);\n}\n\nstatic struct configfs_item_operations hidg_item_ops = {\n\t.release\t= hid_attr_release,\n};\n\n#define F_HID_OPT(name, prec, limit)\t\t\t\t\t\\\nstatic ssize_t f_hid_opts_##name##_show(struct config_item *item, char *page)\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct f_hid_opts *opts = to_f_hid_opts(item);\t\t\t\\\n\tint result;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&opts->lock);\t\t\t\t\t\\\n\tresult = sprintf(page, \"%d\\n\", opts->name);\t\t\t\\\n\tmutex_unlock(&opts->lock);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn result;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t f_hid_opts_##name##_store(struct config_item *item,\t\\\n\t\t\t\t\t const char *page, size_t len)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct f_hid_opts *opts = to_f_hid_opts(item);\t\t\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\tu##prec num;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&opts->lock);\t\t\t\t\t\\\n\tif (opts->refcnt) {\t\t\t\t\t\t\\\n\t\tret = -EBUSY;\t\t\t\t\t\t\\\n\t\tgoto end;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = kstrtou##prec(page, 0, &num);\t\t\t\t\\\n\tif (ret)\t\t\t\t\t\t\t\\\n\t\tgoto end;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (num > limit) {\t\t\t\t\t\t\\\n\t\tret = -EINVAL;\t\t\t\t\t\t\\\n\t\tgoto end;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\topts->name = num;\t\t\t\t\t\t\\\n\tret = len;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nend:\t\t\t\t\t\t\t\t\t\\\n\tmutex_unlock(&opts->lock);\t\t\t\t\t\\\n\treturn ret;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nCONFIGFS_ATTR(f_hid_opts_, name)\n\nF_HID_OPT(subclass, 8, 255);\nF_HID_OPT(protocol, 8, 255);\nF_HID_OPT(report_length, 16, 65535);\n\nstatic ssize_t f_hid_opts_report_desc_show(struct config_item *item, char *page)\n{\n\tstruct f_hid_opts *opts = to_f_hid_opts(item);\n\tint result;\n\n\tmutex_lock(&opts->lock);\n\tresult = opts->report_desc_length;\n\tmemcpy(page, opts->report_desc, opts->report_desc_length);\n\tmutex_unlock(&opts->lock);\n\n\treturn result;\n}\n\nstatic ssize_t f_hid_opts_report_desc_store(struct config_item *item,\n\t\t\t\t\t    const char *page, size_t len)\n{\n\tstruct f_hid_opts *opts = to_f_hid_opts(item);\n\tint ret = -EBUSY;\n\tchar *d;\n\n\tmutex_lock(&opts->lock);\n\n\tif (opts->refcnt)\n\t\tgoto end;\n\tif (len > PAGE_SIZE) {\n\t\tret = -ENOSPC;\n\t\tgoto end;\n\t}\n\td = kmemdup(page, len, GFP_KERNEL);\n\tif (!d) {\n\t\tret = -ENOMEM;\n\t\tgoto end;\n\t}\n\tkfree(opts->report_desc);\n\topts->report_desc = d;\n\topts->report_desc_length = len;\n\topts->report_desc_alloc = true;\n\tret = len;\nend:\n\tmutex_unlock(&opts->lock);\n\treturn ret;\n}\n\nCONFIGFS_ATTR(f_hid_opts_, report_desc);\n\nstatic ssize_t f_hid_opts_dev_show(struct config_item *item, char *page)\n{\n\tstruct f_hid_opts *opts = to_f_hid_opts(item);\n\n\treturn sprintf(page, \"%d:%d\\n\", major, opts->minor);\n}\n\nCONFIGFS_ATTR_RO(f_hid_opts_, dev);\n\nstatic struct configfs_attribute *hid_attrs[] = {\n\t&f_hid_opts_attr_subclass,\n\t&f_hid_opts_attr_protocol,\n\t&f_hid_opts_attr_report_length,\n\t&f_hid_opts_attr_report_desc,\n\t&f_hid_opts_attr_dev,\n\tNULL,\n};\n\nstatic const struct config_item_type hid_func_type = {\n\t.ct_item_ops\t= &hidg_item_ops,\n\t.ct_attrs\t= hid_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic inline void hidg_put_minor(int minor)\n{\n\tida_simple_remove(&hidg_ida, minor);\n}\n\nstatic void hidg_free_inst(struct usb_function_instance *f)\n{\n\tstruct f_hid_opts *opts;\n\n\topts = container_of(f, struct f_hid_opts, func_inst);\n\n\tmutex_lock(&hidg_ida_lock);\n\n\thidg_put_minor(opts->minor);\n\tif (ida_is_empty(&hidg_ida))\n\t\tghid_cleanup();\n\n\tmutex_unlock(&hidg_ida_lock);\n\n\tif (opts->report_desc_alloc)\n\t\tkfree(opts->report_desc);\n\n\tkfree(opts);\n}\n\nstatic struct usb_function_instance *hidg_alloc_inst(void)\n{\n\tstruct f_hid_opts *opts;\n\tstruct usb_function_instance *ret;\n\tint status = 0;\n\n\topts = kzalloc(sizeof(*opts), GFP_KERNEL);\n\tif (!opts)\n\t\treturn ERR_PTR(-ENOMEM);\n\tmutex_init(&opts->lock);\n\topts->func_inst.free_func_inst = hidg_free_inst;\n\tret = &opts->func_inst;\n\n\tmutex_lock(&hidg_ida_lock);\n\n\tif (ida_is_empty(&hidg_ida)) {\n\t\tstatus = ghid_setup(NULL, HIDG_MINORS);\n\t\tif (status)  {\n\t\t\tret = ERR_PTR(status);\n\t\t\tkfree(opts);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\topts->minor = hidg_get_minor();\n\tif (opts->minor < 0) {\n\t\tret = ERR_PTR(opts->minor);\n\t\tkfree(opts);\n\t\tif (ida_is_empty(&hidg_ida))\n\t\t\tghid_cleanup();\n\t\tgoto unlock;\n\t}\n\tconfig_group_init_type_name(&opts->func_inst.group, \"\", &hid_func_type);\n\nunlock:\n\tmutex_unlock(&hidg_ida_lock);\n\treturn ret;\n}\n\nstatic void hidg_free(struct usb_function *f)\n{\n\tstruct f_hidg *hidg;\n\tstruct f_hid_opts *opts;\n\n\thidg = func_to_hidg(f);\n\topts = container_of(f->fi, struct f_hid_opts, func_inst);\n\tkfree(hidg->report_desc);\n\tkfree(hidg);\n\tmutex_lock(&opts->lock);\n\t--opts->refcnt;\n\tmutex_unlock(&opts->lock);\n}\n\nstatic void hidg_unbind(struct usb_configuration *c, struct usb_function *f)\n{\n\tstruct f_hidg *hidg = func_to_hidg(f);\n\n\tdevice_destroy(hidg_class, MKDEV(major, hidg->minor));\n\tcdev_del(&hidg->cdev);\n\n\tusb_free_all_descriptors(f);\n}\n\nstatic struct usb_function *hidg_alloc(struct usb_function_instance *fi)\n{\n\tstruct f_hidg *hidg;\n\tstruct f_hid_opts *opts;\n\n\t/* allocate and initialize one new instance */\n\thidg = kzalloc(sizeof(*hidg), GFP_KERNEL);\n\tif (!hidg)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\topts = container_of(fi, struct f_hid_opts, func_inst);\n\n\tmutex_lock(&opts->lock);\n\t++opts->refcnt;\n\n\thidg->minor = opts->minor;\n\thidg->bInterfaceSubClass = opts->subclass;\n\thidg->bInterfaceProtocol = opts->protocol;\n\thidg->report_length = opts->report_length;\n\thidg->report_desc_length = opts->report_desc_length;\n\tif (opts->report_desc) {\n\t\thidg->report_desc = kmemdup(opts->report_desc,\n\t\t\t\t\t    opts->report_desc_length,\n\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!hidg->report_desc) {\n\t\t\tkfree(hidg);\n\t\t\tmutex_unlock(&opts->lock);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t}\n\n\tmutex_unlock(&opts->lock);\n\n\thidg->func.name    = \"hid\";\n\thidg->func.bind    = hidg_bind;\n\thidg->func.unbind  = hidg_unbind;\n\thidg->func.set_alt = hidg_set_alt;\n\thidg->func.disable = hidg_disable;\n\thidg->func.setup   = hidg_setup;\n\thidg->func.free_func = hidg_free;\n\n\t/* this could me made configurable at some point */\n\thidg->qlen\t   = 4;\n\n\treturn &hidg->func;\n}\n\nDECLARE_USB_FUNCTION_INIT(hid, hidg_alloc_inst, hidg_alloc);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Fabien Chouteau\");\n\nint ghid_setup(struct usb_gadget *g, int count)\n{\n\tint status;\n\tdev_t dev;\n\n\thidg_class = class_create(THIS_MODULE, \"hidg\");\n\tif (IS_ERR(hidg_class)) {\n\t\tstatus = PTR_ERR(hidg_class);\n\t\thidg_class = NULL;\n\t\treturn status;\n\t}\n\n\tstatus = alloc_chrdev_region(&dev, 0, count, \"hidg\");\n\tif (status) {\n\t\tclass_destroy(hidg_class);\n\t\thidg_class = NULL;\n\t\treturn status;\n\t}\n\n\tmajor = MAJOR(dev);\n\tminors = count;\n\n\treturn 0;\n}\n\nvoid ghid_cleanup(void)\n{\n\tif (major) {\n\t\tunregister_chrdev_region(MKDEV(major, 0), minors);\n\t\tmajor = minors = 0;\n\t}\n\n\tclass_destroy(hidg_class);\n\thidg_class = NULL;\n}\n"], "filenames": ["drivers/usb/gadget/function/f_hid.c"], "buggy_code_start_loc": [393], "buggy_code_end_loc": [408], "fixing_code_start_loc": [394], "fixing_code_end_loc": [407], "type": "CWE-667", "message": "In the Linux kernel before 4.16.4, a double-locking error in drivers/usb/dwc3/gadget.c may potentially cause a deadlock with f_hid.", "other": {"cve": {"id": "CVE-2019-14763", "sourceIdentifier": "cve@mitre.org", "published": "2019-08-07T22:15:15.353", "lastModified": "2022-04-18T16:04:28.903", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In the Linux kernel before 4.16.4, a double-locking error in drivers/usb/dwc3/gadget.c may potentially cause a deadlock with f_hid."}, {"lang": "es", "value": "En el kernel de Linux anterior a versi\u00f3n 4.16.4, un error de doble bloqueo en el archivo drivers/usb/dwc3/gadget.c puede causar un punto muerto con f_hid."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-667"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.16.4", "matchCriteriaId": "066EF9C9-7F0D-4BD5-85E9-EE1EFCEDBF64"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}]}]}], "references": [{"url": "https://cdn.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.16.4", "source": "cve@mitre.org", "tags": ["Mailing List", "Vendor Advisory"]}, {"url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=072684e8c58d17e853f8e8b9f6d9ce2e58d2b036", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=c91815b596245fd7da349ecc43c8def670d2269e", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/072684e8c58d17e853f8e8b9f6d9ce2e58d2b036", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/c91815b596245fd7da349ecc43c8def670d2269e", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4115-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4118-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.spinics.net/lists/linux-usb/msg167355.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://www.spinics.net/lists/linux-usb/msg167393.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/072684e8c58d17e853f8e8b9f6d9ce2e58d2b036"}}