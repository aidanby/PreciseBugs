{"buggy_code": ["=head1 NAME\n\nDBI::Changes - List of significant changes to the DBI\n\n=encoding ISO8859-1\n\n=cut\n\n=head2 Changes in DBI 1.632\n\n    Fixed DBD::PurePerl to not set $sth->{Active} true by default\n        drivers are expected to set it true as needed.\n    Fixed DBI::DBD::SqlEngine to complain loudly when prerequite\n        driver_prefix is not fulfilled (RT#93204) [Jens Rehsack]\n    Fixed redundant sprintf argument warning RT#97062 [Reini Urban]\n\n    Changed delete $h->{$key} to work for keys with 'private_' prefix\n        per request in RT#83156. local $h->{$key} works as before.\n\n    Added security notice to DBD::Proxy and DBI::ProxyServer because they\n        use Storable which is insecure. Thanks to ppisar@redhat.com RT#90475\n\n=head2 Changes in DBI 1.631 - 20th Jan 2014\n\nNOTE: This release changes the handle passed to Callbacks from being an 'inner'\nhandle to being an 'outer' handle. If you have code that makes use of Callbacks,\nensure that you understand what this change means and review your callback code.\n\n    Fixed err_hash handling of integer err RT#92172 [Dagfinn Ilmari]\n    Fixed use of \\Q vs \\E in t/70callbacks.t\n\n    Changed the handle passed to Callbacks from being an 'inner'\n        handle to being an 'outer' handle.\n\n    Improved reliability of concurrent testing\n        PR#8 [Peter Rabbitson]\n    Changed optional dependencies to \"suggest\"\n        PR#9 [Karen Etheridge]\n    Changed to avoid mg_get in neatsvpv during global destruction\n        PR#10 [Matt Phillips]\n\n=head2 Changes in DBI 1.630 - 28th Oct 2013\n\nNOTE: This release enables PrintWarn by default regardless of $^W.\nYour applications may generate more log messages than before.\n\n    Fixed err for new drh to be undef not to 0 [Martin J. Evans]\n    Fixed RT#83132 - moved DBIstcf* constants to util\n        export tag [Martin J. Evans]\n    PrintWarn is now triggered by warnings recorded in methods like STORE\n        that don't clear err RT#89015 [Tim Bunce]\n\n    Changed tracing to no longer show quote and quote_identifier calls\n        at trace level 1.\n    Changed DBD::Gofer ping while disconnected set_err from warn to info.\n    Clarified wording of log message when err is cleared.\n    Changed bootstrap to use $XS_VERSION RT#89618 [Andreas Koenig]\n\n    Added connect_cached.connected Callback PR#3 [David E. Wheeler]\n\n    Clarified effect of refs in connect_cached attributes [David E. Wheeler]\n    Extended ReadOnly attribute docs for when the driver cannot\n      ensure read only [Martin J. Evans]\n    Corrected SQL_BIGINT docs to say ODBC value is used PR#5 [ilmari]\n\nThere was no DBI 1.629 release.\n\n=head2 Changes in DBI 1.628 - 22nd July 2013\n\n    Fixed missing fields on partial insert via DBI::DBD::SqlEngine\n        engines (DBD::CSV, DBD::DBM etc.) [H.Merijn Brand, Jens Rehsack]\n    Fixed stack corruption on callbacks RT#85562 RT#84974 [Aaron Schweiger]\n    Fixed DBI::SQL::Nano_::Statement handling of \"0\" [Jens Rehsack]\n    Fixed exit op precedence in test RT#87029 [Reni Urban]\n\n    Added support for finding tables in multiple directories\n        via new DBD::File f_dir_search attribute [H.Merijn Brand]\n    Enable compiling by C++ RT#84285 [Kurt Jaeger]\n\n    Typo fixes in pod and comment [David Steinbrunner]\n    Change DBI's docs to refer to git not svn [H.Merijn Brand]\n    Clarify bind_col TYPE attribute is sticky [Martin J. Evans]\n    Fixed reference to $sth in selectall_arrayref docs RT#84873\n    Spelling fixes [Ville Skytt\u00e4]\n    Changed $VERSIONs to hardcoded strings [H.Merijn Brand]\n\n=head2 Changes in DBI 1.627 - 16th May 2013\n\n    Fixed VERSION regression in DBI::SQL::Nano [Tim Bunce]\n\n=head2 Changes in DBI 1.626 - 15th May 2013\n\n    Fixed pod text/link was reversed in a few cases RT#85168\n        [H.Merijn Brand]\n\n    Handle aliasing of STORE'd attributes in DBI::DBD::SqlEngine\n        [Jens Rehsack]\n\n    Updated repository URI to git [Jens Rehsack]\n\n    Fixed skip() count arg in t/48dbi_dbd_sqlengine.t [Tim Bunce]\n\n=head2 Changes in DBI 1.625 (svn r15595) 28th March 2013\n\n  Fixed heap-use-after-free during global destruction RT#75614\n    thanks to Reini Urban.\n  Fixed ignoring RootClass attribute during connect() by\n    DBI::DBD::SqlEngine reported in RT#84260 by Michael Schout\n\n=head2 Changes in DBI 1.624 (svn r15576) 22nd March 2013\n\n  Fixed Gofer for hash randomization in perl 5.17.10+ RT#84146\n\n  Clarify docs for can() re RT#83207\n\n=head2 Changes in DBI 1.623 (svn r15547) 2nd Jan 2013\n\n  Fixed RT#64330 - ping wipes out errstr (Martin J. Evans).\n  Fixed RT#75868 - DBD::Proxy shouldn't call connected() on the server.\n  Fixed RT#80474 - segfault in DESTROY with threads.\n  Fixed RT#81516 - Test failures due to hash randomisation in perl 5.17.6\n    thanks to Jens Rehsack and H.Merijn Brand and feedback on IRC\n  Fixed RT#81724 - Handle copy-on-write scalars (sprout)\n  Fixed unused variable / self-assignment compiler warnings.\n  Fixed default table_info in DBI::DBD::SqlEngine which passed NAMES\n    attribute instead of NAME to DBD::Sponge RT72343 (Martin J. Evans)\n\n  Corrected a spelling error thanks to Chris Sanders.\n  Corrected typo in DBI->installed_versions docs RT#78825\n    thanks to Jan Dubois.\n\n  Refactored table meta information management from DBD::File into\n    DBI::DBD::SqlEngine (H.Merijn Brand, Jens Rehsack)\n  Prevent undefined f_dir being used in opendir (H.Merijn Brand)\n\n  Added logic to force destruction of children before parents\n    during global destruction. See RT#75614.\n  Added DBD::File Plugin-Support for table names and data sources\n    (Jens Rehsack, #dbi Team)\n  Added new tests to 08keeperr for RT#64330\n    thanks to Kenichi Ishigaki.\n  Added extra internal handle type check, RT#79952\n    thanks to Reini Urban.\n  Added cubrid_ registered prefix for DBD::cubrid, RT#78453\n\n  Removed internal _not_impl method (Martin J. Evans).\n\n  NOTE: The \"old-style\" DBD::DBM attributes 'dbm_ext' and 'dbm_lockfile'\n    have been deprecated for several years and their use will now generate\n    a warning.\n\n=head2 Changes in DBI 1.622 (svn r15327) 6th June 2012\n\n  Fixed lack of =encoding in non-ASCII pod docs. RT#77588\n\n  Corrected typo in DBI::ProfileDumper thanks to Finn Hakansson.\n\n=head2 Changes in DBI 1.621 (svn r15315) 21st May 2012\n\n  Fixed segmentation fault when a thread is created from\n    within another thread RT#77137, thanks to Dave Mitchell.\n  Updated previous Changes to credit Booking.com for sponsoring\n    Dave Mitchell's recent DBI optimization work.\n\n=head2 Changes in DBI 1.620 (svn r15300) 25th April 2012\n\n  Modified column renaming in fetchall_arrayref, added in 1.619,\n    to work on column index numbers not names (an incompatible change).\n  Reworked the fetchall_arrayref documentation.\n  Hash slices in fetchall_arrayref now detect invalid column names.\n\n=head2 Changes in DBI 1.619 (svn r15294) 23rd April 2012\n\n  Fixed the connected method to stop showing the password in\n    trace file (Martin J. Evans).\n  Fixed _install_method to set CvFILE correctly\n    thanks to sprout RT#76296\n  Fixed SqlEngine \"list_tables\" thanks to David McMath\n    and Norbert Gruener. RT#67223 RT#69260\n\n  Optimized DBI method dispatch thanks to Dave Mitchell.\n  Optimized driver access to DBI internal state thanks to Dave Mitchell.\n  Optimized driver access to handle data thanks to Dave Mitchell.\n    Dave's work on these optimizations was sponsored by Booking.com.\n  Optimized fetchall_arrayref with hash slice thanks\n    to Dagfinn Ilmari Manns\u00e5ker. RT#76520\n  Allow renaming columns in fetchall_arrayref hash slices\n    thanks to Dagfinn Ilmari Manns\u00e5ker. RT#76572\n  Reserved snmp_ and tree_ for DBD::SNMP and DBD::TreeData\n\n=head2 Changes in DBI 1.618 (svn r15170) 25rd February 2012\n\n  Fixed compiler warnings in Driver_xst.h (Martin J. Evans)\n  Fixed compiler warning in DBI.xs (H.Merijn Brand)\n  Fixed Gofer tests failing on Windows RT74975 (Manoj Kumar)\n  Fixed my_ctx compile errors on Windows (Dave Mitchell)\n\n  Significantly optimized method dispatch via cache (Dave Mitchell)\n  Significantly optimized DBI internals for threads (Dave Mitchell)\n    Dave's work on these optimizations was sponsored by Booking.com.\n  Xsub to xsub calling optimization now enabled for threaded perls.\n  Corrected typo in example in docs (David Precious)\n  Added note that calling clone() without an arg may warn in future.\n  Minor changes to the install_method() docs in DBI::DBD.\n  Updated dbipport.h from Devel::PPPort 3.20\n\n=head2 Changes in DBI 1.617 (svn r15107) 30th January 2012\n\n  NOTE: The officially supported minimum perl version will change\n  from perl 5.8.1 (2003) to perl 5.8.3 (2004) in a future release.\n  (The last change, from perl 5.6 to 5.8.1, was announced\n  in July 2008 and implemented in DBI 1.611 in April 2010.)\n\n  Fixed ParamTypes example in the pod (Martin J. Evans)\n  Fixed the definition of ArrayTupleStatus and remove confusion over\n    rows affected in list context of execute_array (Martin J. Evans)\n  Fixed sql_type_cast example and typo in errors (Martin J. Evans)\n  Fixed Gofer error handling for keeperr methods like ping (Tim Bunce)\n  Fixed $dbh->clone({}) RT73250 (Tim Bunce)\n  Fixed is_nested_call logic error RT73118 (Reini Urban)\n\n  Enhanced performance for threaded perls (Dave Mitchell, Tim Bunce)\n    Dave's work on this optimization was sponsored by Booking.com.\n  Enhanced and standardized driver trace level mechanism (Tim Bunce)\n  Removed old code that was an inneffective attempt to detect\n    people doing DBI->{Attrib}.\n  Clear ParamValues on bind_param param count error RT66127 (Tim Bunce)\n  Changed DBI::ProxyServer to require DBI at compile-time RT62672 (Tim Bunce)\n\n  Added pod for default_user to DBI::DBD (Martin J. Evans)\n  Added CON, ENC and DBD trace flags and extended 09trace.t (Martin J. Evans)\n  Added TXN trace flags and applied CON and TXN to relevant methods (Tim Bunce)\n  Added some more fetchall_arrayref(..., $maxrows) tests (Tim Bunce)\n  Clarified docs for fetchall_arrayref called on an inactive handle.\n  Clarified docs for clone method (Tim Bunce)\n  Added note to DBI::Profile about async queries (Marcel Gr\u00fcnauer).\n  Reserved spatialite_ as a driver prefix for DBD::Spatialite\n  Reserved mo_ as a driver prefix for DBD::MO\n  Updated link to the SQL Reunion 95 docs, RT69577 (Ash Daminato)\n  Changed links for DBI recipes. RT73286 (Martin J. Evans)\n\n=head2 Changes in DBI 1.616 (svn r14616) 30th December 2010\n\n  Fixed spurious dbi_profile lines written to the log when\n    profiling is enabled and a trace flag, like SQL, is used.\n  Fixed to recognize SQL::Statement errors even if instantiated\n    with RaiseError=0 (Jens Rehsack)\n  Fixed RT#61513 by catching attribute assignment to tied table access\n    interface (Jens Rehsack)\n  Fixing some misbehavior of DBD::File when running within the Gofer\n    server.\n  Fixed compiler warnings RT#62640\n\n  Optimized connect() to remove redundant FETCH of \\%attrib values.\n  Improved initialization phases in DBI::DBD::SqlEngine (Jens Rehsack)\n\n  Added DBD::Gofer::Transport::corostream. An experimental proof-of-concept\n    transport that enables asynchronous database calls with few code changes.\n    It enables asynchronous use of DBI frameworks like DBIx::Class.\n\n  Added additional notes on DBDs which avoid creating a statement in\n    the do() method and the effects on error handlers (Martin J. Evans)\n  Adding new attribute \"sql_dialect\" to DBI::DBD::SqlEngine to allow\n    users control used SQL dialect (ANSI, CSV or AnyData), defaults to\n    CSV (Jens Rehsack)\n  Add documentation for DBI::DBD::SqlEngine attributes (Jens Rehsack)\n  Documented dbd_st_execute return (Martin J. Evans)\n  Fixed typo in InactiveDestroy thanks to Emmanuel Rodriguez.\n\n=head2 Changes in DBI 1.615 (svn r14438) 21st September 2010\n\n  Fixed t/51dbm_file for file/directory names with whitespaces in them\n    RT#61445 (Jens Rehsack)\n  Fixed compiler warnings from ignored hv_store result (Martin J. Evans)\n  Fixed portability to VMS (Craig A. Berry)\n\n=head2 Changes in DBI 1.614 (svn r14408) 17th September 2010\n\n  Fixed bind_param () in DBI::DBD::SqlEngine (rt#61281)\n  Fixed internals to not refer to old perl symbols that\n    will no longer be visible in perl >5.13.3 (Andreas Koenig)\n    Many compiled drivers are likely to need updating.\n  Fixed issue in DBD::File when absolute filename is used as table name\n    (Jens Rehsack)\n  Croak manually when file after tie doesn't exists in DBD::DBM\n    when it have to exists (Jens Rehsack)\n  Fixed issue in DBD::File when users set individual file name for tables\n    via f_meta compatibility interface - reported by H.Merijn Brand while\n    working on RT#61168 (Jens Rehsack)\n\n  Changed 50dbm_simple to simplify and fix problems (Martin J. Evans)\n  Changed 50dbm_simple to skip aggregation tests when not using\n    SQL::Statement (Jens Rehsack)\n  Minor speed improvements in DBD::File (Jens Rehsack)\n\n  Added $h->{AutoInactiveDestroy} as simpler safer form of\n    $h->{InactiveDestroy} (David E. Wheeler)\n  Added ability for parallel testing \"prove -j4 ...\" (Jens Rehsack)\n  Added tests for delete in DBM (H.Merijn Brand)\n  Added test for absolute filename as table to 51dbm_file (Jens Rehsack)\n  Added two initialization phases to DBI::DBD::SqlEngine (Jens Rehsack)\n  Added improved developers documentation for DBI::DBD::SqlEngine\n    (Jens Rehsack)\n  Added guides how to write DBI drivers using DBI::DBD::SqlEngine\n    or DBD::File (Jens Rehsack)\n  Added register_compat_map() and table_meta_attr_changed() to\n    DBD::File::Table to support clean fix of RT#61168 (Jens Rehsack)\n\n=head2 Changes in DBI 1.613 (svn r14271) 22nd July 2010\n\n  Fixed Win32 prerequisite module from PathTools to File::Spec.\n\n  Changed attribute headings and fixed references in DBI pod (Martin J. Evans)\n  Corrected typos in DBI::FAQ and DBI::ProxyServer (Ansgar Burchardt)\n\n=head2 Changes in DBI 1.612 (svn r14254) 16th July 2010\n\nNOTE: This is a minor release for the DBI core but a major release for\nDBD::File and drivers that depend on it, like DBD::DBM and DBD::CSV.\n\nThis is also the first release where the bulk of the development work\nhas been done by other people. I'd like to thank (in no particular order)\nJens Rehsack, Martin J. Evans, and H.Merijn Brand for all their contributions.\n\n  Fixed DBD::File's {ChopBlank} handling (it stripped \\s instead of space\n    only as documented in DBI) (H.Merijn Brand)\n  Fixed DBD::DBM breakage with SQL::Statement (Jens Rehsack, fixes RT#56561)\n  Fixed DBD::File file handle leak (Jens Rehsack)\n  Fixed problems in 50dbm.t when running tests with multiple\n    dbms (Martin J. Evans)\n  Fixed DBD::DBM bugs found during tests (Jens Rehsack)\n  Fixed DBD::File doesn't find files without extensions under some\n    circumstances (Jens Rehsack, H.Merijn Brand, fixes RT#59038)\n\n  Changed Makefile.PL to modernize with CONFLICTS, recommended dependencies\n    and resources (Jens Rehsack)\n  Changed DBI::ProfileDumper to rename any existing profile file by\n    appending .prev, instead of overwriting it.\n  Changed DBI::ProfileDumper::Apache to work in more configurations\n    including vhosts using PerlOptions +Parent.\n  Add driver_prefix method to DBI (Jens Rehsack)\n\n  Added more tests to 50dbm_simple.t to prove optimizations in\n    DBI::SQL::Nano and SQL::Statement (Jens Rehsack)\n  Updated tests to cover optional installed SQL::Statement (Jens Rehsack)\n  Synchronize API between SQL::Statement and DBI::SQL::Nano (Jens Rehsack)\n  Merged some optimizations from SQL::Statement into DBI::SQL::Nano\n    (Jens Rehsack)\n  Added basic test for DBD::File (H.Merijn Brand, Jens Rehsack)\n  Extract dealing with Perl SQL engines from DBD::File into\n    DBI::DBD::SqlEngine for better subclassing of 3rd party non-db DBDs\n    (Jens Rehsack)\n\n  Updated and clarified documentation for finish method (Tim Bunce).\n  Changes to DBD::File for better English and hopefully better\n    explanation (Martin J. Evans)\n  Update documentation of DBD::DBM to cover current implementation,\n    tried to explain some things better and changes most examples to\n    preferred style of Merijn and myself (Jens Rehsack)\n  Added developer documentation (including a roadmap of future plans)\n    for DBD::File\n\n=head2 Changes in DBI 1.611 (svn r13935) 29th April 2010\n\n  NOTE: minimum perl version is now 5.8.1 (as announced in DBI 1.607)\n\n  Fixed selectcol_arrayref MaxRows attribute to count rows not values\n    thanks to Vernon Lyon.\n  Fixed DBI->trace(0, *STDERR); (H.Merijn Brand)\n    which tried to open a file named \"*main::STDERR\" in perl-5.10.x\n  Fixes in DBD::DBM for use under threads (Jens Rehsack)\n\n  Changed \"Issuing rollback() due to DESTROY without explicit disconnect\"\n    warning to not be issued if ReadOnly set for that dbh.\n\n  Added f_lock and f_encoding support to DBD::File (H.Merijn Brand)\n  Added ChildCallbacks => { ... } to Callbacks as a way to\n    specify Callbacks for child handles.\n    With tests added by David E. Wheeler.\n  Added DBI::sql_type_cast($value, $type, $flags) to cast a string value\n    to an SQL type. e.g. SQL_INTEGER effectively does $value += 0;\n    Has other options plus an internal interface for drivers.\n\n  Documentation changes:\n  Small fixes in the documentation of DBD::DBM (H.Merijn Brand)\n  Documented specification of type casting behaviour for bind_col()\n    based on DBI::sql_type_cast() and two new bind_col attributes\n    StrictlyTyped and DiscardString. Thanks to Martin Evans.\n  Document fetchrow_hashref() behaviour for functions,\n    aliases and duplicate names (H.Merijn Brand)\n  Updated DBI::Profile and DBD::File docs to fix pod nits\n    thanks to Frank Wiegand.\n  Corrected typos in Gopher documentation reported by Jan Krynicky.\n  Documented the Callbacks attribute thanks to David E. Wheeler.\n  Corrected the Timeout examples as per rt 50621 (Martin J. Evans).\n  Removed some internal broken links in the pod (Martin J. Evans)\n  Added Note to column_info for drivers which do not\n    support it (Martin J. Evans)\n  Updated dbipport.h to Devel::PPPort 3.19 (H.Merijn Brand)\n\n=head2 Changes in DBI 1.609 (svn r12816) 8th June 2009\n\n  Fixes to DBD::File (H.Merijn Brand)\n    added f_schema attribute\n    table names case sensitive when quoted, insensitive when unquoted\n    workaround a bug in SQL::Statement (temporary fix) related\n      to the \"You passed x parameters where y required\" error\n\n  Added ImplementorClass and Name info to the \"Issuing rollback() due to\n    DESTROY without explicit disconnect\" warning to identify the handle.\n    Applies to compiled drivers when they are recompiled.\n  Added DBI->visit_handles($coderef) method.\n  Added $h->visit_child_handles($coderef) method.\n  Added docs for column_info()'s COLUMN_DEF value.\n  Clarified docs on stickyness of data type via bind_param().\n  Clarified docs on stickyness of data type via bind_col().\n\n=head2 Changes in DBI 1.608 (svn r12742) 5th May 2009\n\n  Fixes to DBD::File (H.Merijn Brand)\n    bind_param () now honors the attribute argument\n    added f_ext attribute\n    File::Spec is always required. (CORE since 5.00405)\n    Fail and set errstr on parameter count mismatch in execute ()\n  Fixed two small memory leaks when running in mod_perl\n    one in DBI->connect and one in DBI::Gofer::Execute.\n    Both due to \"local $ENV{...};\" leaking memory.\n  Fixed DBD_ATTRIB_DELETE macro for driver authors\n    and updated DBI::DBD docs thanks to Martin J. Evans.\n  Fixed 64bit issues in trace messages thanks to Charles Jardine.\n  Fixed FETCH_many() method to work with drivers that incorrectly return\n    an empty list from $h->FETCH. Affected gofer.\n\n  Added 'sqlite_' as registered prefix for DBD::SQLite.\n  Corrected many typos in DBI docs thanks to Martin J. Evans.\n  Improved DBI::DBD docs thanks to H.Merijn Brand.\n\n=head2 Changes in DBI 1.607 (svn r11571) 22nd July 2008\n\n  NOTE: Perl 5.8.1 is now the minimum supported version.\n  If you need support for earlier versions send me a patch.\n\n  Fixed missing import of carp in DBI::Gofer::Execute.\n\n  Added note to docs about effect of execute(@empty_array).\n  Clarified docs for ReadOnly thanks to Martin Evans.\n\n=head2 Changes in DBI 1.605 (svn r11434) 16th June 2008\n\n  Fixed broken DBIS macro with threads on big-endian machines\n    with 64bit ints but 32bit pointers. Ticket #32309.\n  Fixed the selectall_arrayref, selectrow_arrayref, and selectrow_array\n    methods that get embedded into compiled drivers to use the\n    inner sth handle when passed a $sth instead of an sql string.\n    Drivers will need to be recompiled to pick up this change.\n  Fixed leak in neat() for some kinds of values thanks to Rudolf Lippan.\n  Fixed DBI::PurePerl neat() to behave more like XS neat().\n\n  Increased default $DBI::neat_maxlen from 400 to 1000.\n  Increased timeout on tests to accommodate very slow systems.\n  Changed behaviour of trace levels 1..4 to show less information\n    at lower levels.\n  Changed the format of the key used for $h->{CachedKids}\n    (which is undocumented so you shouldn't depend on it anyway)\n  Changed gofer error handling to avoid duplicate error text in errstr.\n  Clarified docs re \":N\" style placeholders.\n  Improved gofer retry-on-error logic and refactored to aid subclassing.\n  Improved gofer trace output in assorted ways.\n\n  Removed the beeps \"\\a\" from Makefile.PL warnings.\n  Removed check for PlRPC-modules from Makefile.PL\n\n  Added sorting of ParamValues reported by ShowErrorStatement\n    thanks to to Rudolf Lippan.\n  Added cache miss trace message to DBD::Gofer transport class.\n  Added $drh->dbixs_revision method.\n  Added explicit LICENSE specification (perl) to META.yaml\n\n=head2 Changes in DBI 1.604 (svn rev 10994) 24th March 2008\n\n  Fixed fetchall_arrayref with $max_rows argument broken in 1.603,\n    thanks to Greg Sabino Mullane.\n  Fixed a few harmless compiler warnings on cygwin.\n\n=head2 Changes in DBI 1.603\n\n  Fixed pure-perl fetchall_arrayref with $max_rows argument\n    to not error when fetching after all rows already fetched.\n    (Was fixed for compiled drivers back in DBI 1.31.)\n    Thanks to Mark Overmeer.\n  Fixed C sprintf formats and casts, fixing compiler warnings.\n\n  Changed dbi_profile() to accept a hash of profiles and apply to all.\n  Changed gofer stream transport to improve error reporting.\n  Changed gofer test timeout to avoid spurious failures on slow systems.\n\n  Added options to t/85gofer.t so it's more useful for manual testing.\n\n=head2 Changes in DBI 1.602 (svn rev 10706)  8th February 2008\n\n  Fixed potential coredump if stack reallocated while calling back\n    into perl from XS code. Thanks to John Gardiner Myers.\n  Fixed DBI::Util::CacheMemory->new to not clear the cache.\n  Fixed avg in DBI::Profile as_text() thanks to Abe Ingersoll.\n  Fixed DBD::DBM bug in push_names thanks to J M Davitt.\n  Fixed take_imp_data for some platforms thanks to Jeffrey Klein.\n  Fixed docs tie'ing CacheKids (ie LRU cache) thanks to Peter John Edwards.\n\n  Expanded DBI::DBD docs for driver authors thanks to Martin Evans.\n  Enhanced t/80proxy.t test script.\n  Enhanced t/85gofer.t test script thanks to Stig.\n  Enhanced t/10examp.t test script thanks to David Cantrell.\n  Documented $DBI::stderr as the default value of err for internal errors.\n\n  Gofer changes:\n    track_recent now also keeps track of N most recent errors.\n    The connect method is now also counted in stats.\n\n=head2 Changes in DBI 1.601 (svn rev 10103),  21st October 2007\n\n  Fixed t/05thrclone.t to work with Test::More >= 0.71\n    thanks to Jerry D. Hedden and Michael G Schwern.\n  Fixed DBI for VMS thanks to Peter (Stig) Edwards.\n\n  Added client-side caching to DBD::Gofer. Can use any cache with\n    get($k)/set($k,$v) methods, including all the Cache and Cache::Cache\n    distribution modules plus Cache::Memcached, Cache::FastMmap etc.\n    Works for all transports. Overridable per handle.\n\n  Added DBI::Util::CacheMemory for use with DBD::Gofer caching.\n    It's a very fast and small strict subset of Cache::Memory.\n\n=head2 Changes in DBI 1.59 (svn rev 9874),  23rd August 2007\n\n  Fixed DBI::ProfileData to unescape headers lines read from data file.\n  Fixed DBI::ProfileData to not clobber $_, thanks to Alexey Tourbin.\n  Fixed DBI::SQL::Nano to not clobber $_, thanks to Alexey Tourbin.\n  Fixed DBI::PurePerl to return undef for ChildHandles if weaken not available.\n  Fixed DBD::Proxy disconnect error thanks to Philip Dye.\n  Fixed DBD::Gofer::Transport::Base bug (typo) in timeout code.\n  Fixed DBD::Proxy rows method thanks to Philip Dye.\n  Fixed dbiprof compile errors, thanks to Alexey Tourbin.\n  Fixed t/03handle.t to skip some tests if ChildHandles not available.\n\n  Added check_response_sub to DBI::Gofer::Execute\n\n=head2 Changes in DBI 1.58 (svn rev 9678),  25th June 2007\n\n  Fixed code triggering fatal error in bleadperl, thanks to Steve Hay.\n  Fixed compiler warning thanks to Jerry D. Hedden.\n  Fixed t/40profile.t to use int(dbi_time()) for systems like Cygwin where\n    time() seems to be rounded not truncated from the high resolution time.\n  Removed dump_results() test from t/80proxy.t.\n\n=head2 Changes in DBI 1.57 (svn rev 9639),  13th June 2007\n\n  Note: this release includes a change to the DBI::hash() function which will\n  now produce different values than before *if* your perl was built with 64-bit\n  'int' type (i.e. \"perl -V:intsize\" says intsize='8').  It's relatively rare\n  for perl to be configured that way, even on 64-bit systems.\n\n  Fixed XS versions of select*_*() methods to call execute()\n    fetch() etc., with inner handle instead of outer.\n  Fixed execute_for_fetch() to not cache errstr values\n    thanks to Bart Degryse.\n  Fixed unused var compiler warning thanks to JDHEDDEN.\n  Fixed t/86gofer_fail tests to be less likely to fail falsely.\n\n  Changed DBI::hash to return 'I32' type instead of 'int' so results are\n    portable/consistent regardless of size of the int type.\n  Corrected timeout example in docs thanks to Egmont Koblinger.\n  Changed t/01basic.t to warn instead of failing when it detects\n    a problem with Math::BigInt (some recent versions had problems).\n\n  Added support for !Time and !Time~N to DBI::Profile Path. See docs.\n  Added extra trace info to connect_cached thanks to Walery Studennikov.\n  Added non-random (deterministic) mode to DBI_GOFER_RANDOM mechanism.\n  Added DBIXS_REVISION macro that drivers can use.\n  Added more docs for private_attribute_info() method.\n\n  DBI::Profile changes:\n    dbi_profile() now returns ref to relevant leaf node.\n    Don't profile DESTROY during global destruction.\n    Added as_node_path_list() and as_text() methods.\n  DBI::ProfileDumper changes:\n    Don't write file if there's no profile data.\n    Uses full natural precision when saving data (was using %.6f)\n    Optimized flush_to_disk().\n    Locks the data file while writing.\n    Enabled filename to be a code ref for dynamic names.\n  DBI::ProfileDumper::Apache changes:\n    Added Quiet=>1 to avoid write to STDERR in flush_to_disk().\n    Added Dir=>... to specify a writable destination directory.\n    Enabled DBI_PROFILE_APACHE_LOG_DIR for mod_perl 1 as well as 2.\n    Added parent pid to default data file name.\n  DBI::ProfileData changes:\n    Added DeleteFiles option to rename & delete files once read.\n    Locks the data files while reading.\n    Added ability to sort by Path elements.\n  dbiprof changes:\n    Added --dumpnodes and --delete options.\n  Added/updated docs for both DBI::ProfileDumper && ::Apache.\n\n=head2 Changes in DBI 1.56 (svn rev 9660),  18th June 2007\n\n  Fixed printf arg warnings thanks to JDHEDDEN.\n  Fixed returning driver-private sth attributes via gofer.\n\n  Changed pod docs docs to use =head3 instead of =item\n    so now in html you get links to individual methods etc.\n  Changed default gofer retry_limit from 2 to 0.\n  Changed tests to workaround Math::BigInt broken versions.\n  Changed dbi_profile_merge() to dbi_profile_merge_nodes()\n    old name still works as an alias for the new one.\n  Removed old DBI internal sanity check that's no longer valid\n    causing \"panic: DESTROY (dbih_clearcom)\" when tracing enabled\n\n  Added DBI_GOFER_RANDOM env var that can be use to trigger random\n    failures and delays when executing gofer requests. Designed to help\n    test automatic retry on failures and timeout handling.\n  Added lots more docs to all the DBD::Gofer and DBI::Gofer classes.\n\n=head2 Changes in DBI 1.55 (svn rev 9504),  4th May 2007\n\n  Fixed set_err() so HandleSetErr hook is executed reliably, if set.\n  Fixed accuracy of profiling when perl configured to use long doubles.\n  Fixed 42prof_data.t on fast systems with poor timers thanks to Malcolm Nooning.\n  Fixed potential corruption in selectall_arrayref and selectrow_arrayref\n    for compiled drivers, thanks to Rob Davies.\n    Rebuild your compiled drivers after installing DBI.\n\n  Changed some handle creation code from perl to C code,\n    to reduce handle creation cost by ~20%.\n  Changed internal implementation of the CachedKids attribute\n    so it's a normal handle attribute (and initially undef).\n  Changed connect_cached and prepare_cached to avoid a FETCH method call,\n    and thereby reduced cost by ~5% and ~30% respectively.\n  Changed _set_fbav to not croak when given a wrongly sized array,\n    it now warns and adjusts the row buffer to match.\n  Changed some internals to improve performance with threaded perls.\n  Changed DBD::NullP to be slightly more useful for testing.\n  Changed File::Spec prerequisite to not require a minimum version.\n  Changed tests to work with other DBMs thanks to ZMAN.\n  Changed ex/perl_dbi_nulls_test.pl to be more descriptive.\n\n  Added more functionality to the (undocumented) Callback mechanism.\n    Callbacks can now elect to provide a value to be returned, in which case\n    the method won't be called. A callback for \"*\" is applied to all methods\n    that don't have their own callback.\n  Added $h->{ReadOnly} attribute.\n  Added support for DBI Profile Path to contain refs to scalars\n    which will be de-ref'd for each profile sample.\n  Added dbilogstrip utility to edit DBI logs for diff'ing (gets installed)\n  Added details for SQLite 3.3 to NULL handling docs thanks to Alex Teslik.\n  Added take_imp_data() to DBI::PurePerl.\n\n  Gofer related changes:\n    Fixed gofer pipeone & stream transports to avoid risk of hanging.\n    Improved error handling and tracing significantly.\n    Added way to generate random 1-in-N failures for methods.\n    Added automatic retry-on-error mechanism to gofer transport base class.\n    Added tests to show automatic retry mechanism works a treat!\n    Added go_retry_hook callback hook so apps can fine-tune retry behaviour.\n    Added header to request and response packets for sanity checking\n      and to enable version skew between client and server.\n    Added forced_single_resultset, max_cached_sth_per_dbh and max_cached_dbh_per_drh\n      to gofer executor config.\n    Driver-private methods installed with install_method are now proxied.\n    No longer does a round-trip to the server for methods it knows\n      have not been overridden by the remote driver.\n    Most significant aspects of gofer behaviour are controlled by policy mechanism.\n    Added policy-controlled caching of results for some methods, such as schema metadata.\n    The connect_cached and prepare_cached methods cache on client and server.\n    The bind_param_array and execute_array methods are now supported.\n    Worked around a DBD::Sybase bind_param bug (which is fixed in DBD::Sybase 1.07)\n    Added goferperf.pl utility (doesn't get installed).\n    Many other assorted Gofer related bug fixes, enhancements and docs.\n    The http and mod_perl transports have been remove to their own distribution.\n    Client and server will need upgrading together for this release.\n\n=head2 Changes in DBI 1.54 (svn rev 9157),  23rd February 2007\n\n  NOTE: This release includes the 'next big thing': DBD::Gofer.\n  Take a look!\n\n  WARNING: This version has some subtle changes in DBI internals.\n  It's possible, though doubtful, that some may affect your code.\n  I recommend some extra testing before using this release.\n  Or perhaps I'm just being over cautious...\n\n  Fixed type_info when called for multiple dbh thanks to Cosimo Streppone.\n  Fixed compile warnings in bleadperl on freebsd-6.1-release\n    and solaris 10g thanks to Philip M. Gollucci.\n  Fixed to compile for perl built with -DNO_MATHOMS thanks to Jerry D. Hedden.\n  Fixed to work for bleadperl (r29544) thanks to Nicholas Clark.\n    Users of Perl >= 5.9.5 will require DBI >= 1.54.\n  Fixed rare error when profiling access to $DBI::err etc tied variables.\n  Fixed DBI::ProfileDumper to not be affected by changes to $/ and $,\n    thanks to Michael Schwern.\n\n  Changed t/40profile.t to skip tests for perl < 5.8.0.\n  Changed setting trace file to no longer write \"Trace file set\" to new file.\n  Changed 'handle cleared whilst still active' warning for dbh\n    to only be given for dbh that have active sth or are not AutoCommit.\n  Changed take_imp_data to call finish on all Active child sth.\n  Changed DBI::PurePerl trace() method to be more consistent.\n  Changed set_err method to effectively not append to errstr if the new errstr\n    is the same as the current one.\n  Changed handle factory methods, like connect, prepare, and table_info,\n    to copy any error/warn/info state of the handle being returned\n    up into the handle the method was called on.\n  Changed row buffer handling to not alter NUM_OF_FIELDS if it's\n    inconsistent with number of elements in row buffer array.\n  Updated DBI::DBD docs re handling multiple result sets.\n  Updated DBI::DBD docs for driver authors thanks to Ammon Riley\n    and Dean Arnold.\n  Updated column_info docs to note that if a table doesn't exist\n    you get an sth for an empty result set and not an error.\n\n  Added new DBD::Gofer 'stateless proxy' driver and framework,\n    and the DBI test suite is now also executed via DBD::Gofer,\n    and DBD::Gofer+DBI::PurePerl, in addition to DBI::PurePerl.\n  Added ability for trace() to support filehandle argument,\n    including tracing into a string, thanks to Dean Arnold.\n  Added ability for drivers to implement func() method\n    so proxy drivers can proxy the func method itself.\n  Added SQL_BIGINT type code (resolved to the ODBC/JDBC value (-5))\n  Added $h->private_attribute_info method.\n\n=head2 Changes in DBI 1.53 (svn rev 7995),   31st October 2006\n\n  Fixed checks for weaken to work with early 5.8.x versions\n  Fixed DBD::Proxy handling of some methods, including commit and rollback.\n  Fixed t/40profile.t to be more insensitive to long double precision.\n  Fixed t/40profile.t to be insensitive to small negative shifts in time\n    thanks to Jamie McCarthy.\n  Fixed t/40profile.t to skip tests for perl < 5.8.0.\n  Fixed to work with current 'bleadperl' (~5.9.5) thanks to Steve Peters.\n    Users of Perl >= 5.9.5 will require DBI >= 1.53.\n  Fixed to be more robust against drivers not handling multiple result\n    sets properly, thanks to Gisle Aas.\n\n  Added array context support to execute_array and execute_for_fetch\n    methods which returns executed tuples and rows affected.\n  Added Tie::Cache::LRU example to docs thanks to Brandon Black.\n\n=head2 Changes in DBI 1.52 (svn rev 6840),   30th July 2006\n\n  Fixed memory leak (per handle) thanks to Nicholas Clark and Ephraim Dan.\n  Fixed memory leak (16 bytes per sth) thanks to Doru Theodor Petrescu.\n  Fixed execute_for_fetch/execute_array to RaiseError thanks to Martin J. Evans.\n  Fixed for perl 5.9.4. Users of Perl >= 5.9.4 will require DBI >= 1.52.\n\n  Updated DBD::File to 0.35 to match the latest release on CPAN.\n\n  Added $dbh->statistics_info specification thanks to Brandon Black.\n\n  Many changes and additions to profiling:\n    Profile Path can now uses sane strings instead of obscure numbers,\n    can refer to attributes, assorted magical values, and even code refs!\n    Parsing of non-numeric DBI_PROFILE env var values has changed.\n    Changed DBI::Profile docs extensively - many new features.\n    See DBI::Profile docs for more information.\n\n=head2 Changes in DBI 1.51 (svn rev 6475),   6th June 2006\n\n  Fixed $dbh->clone method 'signature' thanks to Jeffrey Klein.\n  Fixed default ping() method to return false if !$dbh->{Active}.\n  Fixed t/40profile.t to be insensitive to long double precision.\n  Fixed for perl 5.8.0's more limited weaken() function.\n  Fixed DBD::Proxy to not alter $@ in disconnect or AUTOLOADd methods.\n  Fixed bind_columns() to use return set_err(...) instead of die()\n    to report incorrect number of parameters, thanks to Ben Thul.\n  Fixed bind_col() to ignore undef as bind location, thanks to David Wheeler.\n  Fixed for perl 5.9.x for non-threaded builds thanks to Nicholas Clark.\n    Users of Perl >= 5.9.x will require DBI >= 1.51.\n  Fixed fetching of rows as hash refs to preserve utf8 on field names\n    from $sth->{NAME} thanks to Alexey Gaidukov.\n  Fixed build on Win32 (dbd_postamble) thanks to David Golden.\n\n  Improved performance for thread-enabled perls thanks to Gisle Aas.\n  Drivers can now use PERL_NO_GET_CONTEXT thanks to Gisle Aas.\n    Driver authors please read the notes in the DBI::DBD docs.\n  Changed DBI::Profile format to always include a percentage,\n    if not exiting then uses time between the first and last DBI call.\n  Changed DBI::ProfileData to be more forgiving of systems with\n    unstable clocks (where time may go backwards occasionally).\n  Clarified the 'Subclassing the DBI' docs.\n  Assorted minor changes to docs from comments on annocpan.org.\n  Changed Makefile.PL to avoid incompatible options for old gcc.\n\n  Added 'fetch array of hash refs' example to selectall_arrayref\n    docs thanks to Tom Schindl.\n  Added docs for $sth->{ParamArrays} thanks to Martin J. Evans.\n  Added reference to $DBI::neat_maxlen in TRACING section of docs.\n  Added ability for DBI::Profile Path to include attributes\n    and a summary of where the code was called from.\n\n=head2 Changes in DBI 1.50 (svn rev 2307),   13 December 2005\n\n  Fixed Makefile.PL options for gcc bug introduced in 1.49.\n  Fixed handle magic order to keep DBD::Oracle happy.\n  Fixed selectrow_array to return empty list on error.\n\n  Changed dbi_profile_merge() to be able to recurse and merge\n    sub-trees of profile data.\n\n  Added documentation for dbi_profile_merge(), including how to\n    measure the time spent inside the DBI for an http request.\n\n=head2 Changes in DBI 1.49 (svn rev 2287),   29th November 2005\n\n  Fixed assorted attribute handling bugs in DBD::Proxy.\n  Fixed croak() in DBD::NullP thanks to Sergey Skvortsov.\n  Fixed handling of take_imp_data() and dbi_imp_data attribute.\n  Fixed bugs in DBD::DBM thanks to Jeff Zucker.\n  Fixed bug in DBI::ProfileDumper thanks to Sam Tregar.\n  Fixed ping in DBD::Proxy thanks to George Campbell.\n  Fixed dangling ref in $sth after parent $dbh destroyed\n    with thanks to il@rol.ru for the bug report #13151\n  Fixed prerequisites to include Storable thanks to Michael Schwern.\n  Fixed take_imp_data to be more practical.\n\n  Change to require perl 5.6.1 (as advertised in 2003) not 5.6.0.\n  Changed internals to be more strictly coded thanks to Andy Lester.\n  Changed warning about multiple copies of Driver.xst found in @INC\n    to ignore duplicated directories thanks to Ed Avis.\n  Changed Driver.xst to enable drivers to define an dbd_st_prepare_sv\n    function where the statement parameter is an SV. That enables\n    compiled drivers to support SQL strings that are UTF-8.\n  Changed \"use DBI\" to only set $DBI::connect_via if not already set.\n  Changed docs to clarify pre-method clearing of err values.\n\n  Added ability for DBI::ProfileData to edit profile path on loading.\n    This enables aggregation of different SQL statements into the same\n    profile node - very handy when not using placeholders or when working\n    multiple separate tables for the same thing (ie logtable_2005_11_28)\n  Added $sth->{ParamTypes} specification thanks to Dean Arnold.\n  Added $h->{Callbacks} attribute to enable code hooks to be invoked\n    when certain methods are called. For example:\n    $dbh->{Callbacks}->{prepare} = sub { ... };\n    With thanks to David Wheeler for the kick start.\n  Added $h->{ChildHandles} (using weakrefs) thanks to Sam Tregar\n    I've recoded it in C so there's no significant performance impact.\n  Added $h->{Type} docs (returns 'dr', 'db', or 'st')\n  Adding trace message in DESTROY if InactiveDestroy enabled.\n  Added %drhs = DBI->installed_drivers();\n\n  Ported DBI::ProfileDumper::Apache to mod_perl2 RC5+\n    thanks to Philip M. Golluci\n\n=head2 Changes in DBI 1.48 (svn rev 928),    14th March 2005\n\n  Fixed DBI::DBD::Metadata generation of type_info_all thanks to Steffen Goeldner\n    (driver authors who have used it should rerun it).\n\n  Updated docs for NULL Value placeholders thanks to Brian Campbell.\n\n  Added multi-keyfield nested hash fetching to fetchall_hashref()\n    thanks to Zhuang (John) Li for polishing up my draft.\n  Added registered driver prefixes: amzn_ for DBD::Amazon and yaswi_ for DBD::Yaswi.\n\n\n=head2 Changes in DBI 1.47 (svn rev 854),    2nd February 2005\n\n  Fixed DBI::ProxyServer to not create pid files by default.\n    References: Ubuntu Security Notice USN-70-1, CAN-2005-0077\n    Thanks to Javier Fern\u00e1ndez-Sanguino Pe\u00f1a from the\n    Debian Security Audit Project, and Jonathan Leffler.\n  Fixed some tests to work with older Test::More versions.\n  Fixed setting $DBI::err/errstr in DBI::PurePerl.\n  Fixed potential undef warning from connect_cached().\n  Fixed $DBI::lasth handling for DESTROY so lasth points to\n    parent even if DESTROY called other methods.\n  Fixed DBD::Proxy method calls to not alter $@.\n  Fixed DBD::File problem with encoding pragma thanks to Erik Rijkers.\n\n  Changed error handling so undef errstr doesn't cause warning.\n  Changed DBI::DBD docs to use =head3/=head4 pod thanks to\n    Jonathan Leffler. This may generate warnings for perl 5.6.\n  Changed DBI::PurePerl to set autoflush on trace filehandle.\n  Changed DBD::Proxy to treat Username as a local attribute\n    so recent DBI version can be used with old DBI::ProxyServer.\n  Changed driver handle caching in DBD::File.\n  Added $GetInfoType{SQL_DATABASE_NAME} thanks to Steffen Goeldner.\n\n  Updated docs to recommend some common DSN string attributes.\n  Updated connect_cached() docs with issues and suggestions.\n  Updated docs for NULL Value placeholders thanks to Brian Campbell.\n  Updated docs for primary_key_info and primary_keys.\n  Updated docs to clarify that the default fetchrow_hashref behaviour,\n    of returning a ref to a new hash for each row, will not change.\n  Updated err/errstr/state docs for DBD authors thanks to Steffen Goeldner.\n  Updated handle/attribute docs for DBD authors thanks to Steffen Goeldner.\n  Corrected and updated LongReadLen docs thanks to Bart Lateur.\n  Added DBD::JDBC as a registered driver.\n\n=head2 Changes in DBI 1.46 (svn rev 584),    16th November 2004\n\n  Fixed parsing bugs in DBI::SQL::Nano thanks to Jeff Zucker.\n  Fixed a couple of bad links in docs thanks to Graham Barr.\n  Fixed test.pl Win32 undef warning thanks to H.Merijn Brand & David Repko.\n  Fixed minor issues in DBI::DBD::Metadata thanks to Steffen Goeldner.\n  Fixed DBI::PurePerl neat() to use double quotes for utf8.\n\n  Changed execute_array() definition, and default implementation,\n    to not consider scalar values for execute tuple count. See docs.\n  Changed DBD::File to enable ShowErrorStatement by default,\n    which affects DBD::File subclasses such as DBD::CSV and DBD::DBM.\n  Changed use DBI qw(:utils) tag to include $neat_maxlen.\n  Updated Roadmap and ToDo.\n\n  Added data_string_diff() data_string_desc() and data_diff()\n    utility functions to help diagnose Unicode issues.\n    All can be imported via the use DBI qw(:utils) tag.\n\n=head2 Changes in DBI 1.45 (svn rev 480),    6th October 2004\n\n  Fixed DBI::DBD code for drivers broken in 1.44.\n  Fixed \"Free to wrong pool\"/\"Attempt to free unreferenced scalar\" in FETCH.\n\n=head2 Changes in DBI 1.44 (svn rev 478),    5th October 2004\n\n  Fixed build issues on VMS thanks to Jakob Snoer.\n  Fixed DBD::File finish() method to return 1 thanks to Jan Dubois.\n  Fixed rare core dump during global destruction thanks to Mark Jason Dominus.\n  Fixed risk of utf8 flag persisting from one row to the next.\n\n  Changed bind_param_array() so it doesn't require all bind arrays\n    to have the same number of elements.\n  Changed bind_param_array() to error if placeholder number <= 0.\n  Changed execute_array() definition, and default implementation,\n    to effectively NULL-pad shorter bind arrays.\n  Changed execute_array() to return \"0E0\" for 0 as per the docs.\n  Changed execute_for_fetch() definition, and default implementation,\n    to return \"0E0\" for 0 like execute() and execute_array().\n  Changed Test::More prerequisite to Test::Simple (which is also the name\n    of the distribution both are packaged in) to work around ppm behaviour.\n\n  Corrected docs to say that get/set of unknown attribute generates\n    a warning and is no longer fatal. Thanks to Vadim.\n  Corrected fetchall_arrayref() docs example thanks to Drew Broadley.\n\n  Added $h1->swap_inner_handle($h2) sponsored by BizRate.com\n\n\n=head2 Changes in DBI 1.43 (svn rev 377),    2nd July 2004\n\n  Fixed connect() and connect_cached() RaiseError/PrintError\n    which would sometimes show \"(no error string)\" as the error.\n  Fixed compiler warning thanks to Paul Marquess.\n  Fixed \"trace level set to\" trace message thanks to H.Merijn Brand.\n  Fixed DBD::DBM $dbh->{dbm_tables}->{...} to be keyed by the\n    table name not the file name thanks to Jeff Zucker.\n  Fixed last_insert_id(...) thanks to Rudy Lippan.\n  Fixed propagation of scalar/list context into proxied methods.\n  Fixed DBI::Profile::DESTROY to not alter $@.\n  Fixed DBI::ProfileDumper new() docs thanks to Michael Schwern.\n  Fixed _load_class to propagate $@ thanks to Drew Taylor.\n  Fixed compile warnings on Win32 thanks to Robert Baron.\n  Fixed problem building with recent versions of MakeMaker.\n  Fixed DBD::Sponge not to generate warning with threads.\n  Fixed DBI_AUTOPROXY to work more than once thanks to Steven Hirsch.\n\n  Changed TraceLevel 1 to not show recursive/nested calls.\n  Changed getting or setting an invalid attribute to no longer be\n    a fatal error but generate a warning instead.\n  Changed selectall_arrayref() to call finish() if\n    $attr->{MaxRows} is defined.\n  Changed all tests to use Test::More and enhanced the tests thanks\n    to Stevan Little and Andy Lester. See http://qa.perl.org/phalanx/\n  Changed Test::More minimum prerequisite version to 0.40 (2001).\n  Changed DBI::Profile header to include the date and time.\n\n  Added DBI->parse_dsn($dsn) method.\n  Added warning if build directory path contains white space.\n  Added docs for parse_trace_flags() and parse_trace_flag().\n  Removed \"may change\" warnings from the docs for table_info(),\n    primary_key_info(), and foreign_key_info() methods.\n\n=head2 Changes in DBI 1.42 (svn rev 222),    12th March 2004\n\n  Fixed $sth->{NUM_OF_FIELDS} of non-executed statement handle\n    to be undef as per the docs (it was 0).\n  Fixed t/41prof_dump.t to work with perl5.9.1.\n  Fixed DBD_ATTRIB_DELETE macro thanks to Marco Paskamp.\n  Fixed DBI::PurePerl looks_like_number() and $DBI::rows.\n  Fixed ref($h)->can(\"foo\") to not croak.\n\n  Changed attributes (NAME, TYPE etc) of non-executed statement\n    handle to be undef instead of triggering an error.\n  Changed ShowErrorStatement to apply to more $dbh methods.\n  Changed DBI_TRACE env var so just does this at load time:\n    DBI->trace(split '=', $ENV{DBI_TRACE}, 2);\n  Improved \"invalid number of parameters\" error message.\n  Added DBI::common as base class for DBI::db, DBD::st etc.\n  Moved methods common to all handles into DBI::common.\n\n  Major tracing enhancement:\n\n  Added $h->parse_trace_flags(\"foo|SQL|7\") to map a group of\n    trace flags into the corresponding trace flag bits.\n  Added automatic calling of parse_trace_flags() if\n    setting the trace level to a non-numeric value:\n    $h->{TraceLevel}=\"foo|SQL|7\"; $h->trace(\"foo|SQL|7\");\n    DBI->connect(\"dbi:Driver(TraceLevel=SQL|foo):...\", ...);\n    Currently no trace flags have been defined.\n  Added to, and reworked, the trace documentation.\n  Added dbivport.h for driver authors to use.\n\n  Major driver additions that Jeff Zucker and I have been working on:\n\n  Added DBI::SQL::Nano a 'smaller than micro' SQL parser\n    with an SQL::Statement compatible API. If SQL::Statement\n    is installed then DBI::SQL::Nano becomes an empty subclass\n    of SQL::Statement, unless the DBI_SQL_NANO env var is true.\n  Added DBD::File, modified to use DBI::SQL::Nano.\n  Added DBD::DBM, an SQL interface to DBM files using DBD::File.\n\n  Documentation changes:\n\n  Corrected typos in docs thanks to Steffen Goeldner.\n  Corrected execute_for_fetch example thanks to Dean Arnold.\n\n=head2 Changes in DBI 1.41 (svn rev 130),    22nd February 2004\n\n  Fixed execute_for_array() so tuple_status parameter is optional\n    as per docs, thanks to Ed Avis.\n  Fixed execute_for_array() docs to say that it returns undef if\n    any of the execute() calls fail.\n  Fixed take_imp_data() test on m68k reported by Christian Hammers.\n  Fixed write_typeinfo_pm inconsistencies in DBI::DBD::Metadata\n    thanks to Andy Hassall.\n  Fixed $h->{TraceLevel} to not return DBI->trace trace level\n    which it used to if DBI->trace trace level was higher.\n\n  Changed set_err() to append to errstr, with a leading \"\\n\" if it's\n    not empty, so that multiple error/warning messages are recorded.\n  Changed trace to limit elements dumped when an array reference is\n    returned from a method to the max(40, $DBI::neat_maxlen/10)\n    so that fetchall_arrayref(), for example, doesn't flood the trace.\n  Changed trace level to be a four bit integer (levels 0 thru 15)\n    and a set of topic flags (no topics have been assigned yet).\n  Changed column_info() to check argument count.\n  Extended bind_param() TYPE attribute specification to imply\n    standard formating of value, eg SQL_DATE implies 'YYYY-MM-DD'.\n\n  Added way for drivers to indicate 'success with info' or 'warning'\n    by setting err to \"0\" for warning and \"\" for information.\n    Both values are false and so don't trigger RaiseError etc.\n    Thanks to Steffen Goeldner for the original idea.\n  Added $h->{HandleSetErr} = sub { ... } to be called at the\n    point that an error, warn, or info state is recorded.\n    The code can alter the err, errstr, and state values\n    (e.g., to promote an error to a warning, or the reverse).\n  Added $h->{PrintWarn} attribute to enable printing of warnings\n    recorded by the driver. Defaults to same value as $^W (perl -w).\n  Added $h->{ErrCount} attribute, incremented whenever an error is\n    recorded by the driver via set_err().\n  Added $h->{Executed} attribute, set if do()/execute() called.\n  Added \\%attr parameter to foreign_key_info() method.\n  Added ref count of inner handle to \"DESTROY ignored for outer\" msg.\n  Added Win32 build config checks to DBI::DBD thanks to Andy Hassall.\n  Added bind_col to Driver.xst so drivers can define their own.\n  Added TYPE attribute to bind_col and specified the expected\n    driver behaviour.\n\n  Major update to signal handling docs thanks to Lincoln Baxter.\n  Corrected dbiproxy usage doc thanks to Christian Hammers.\n  Corrected type_info_all index hash docs thanks to Steffen Goeldner.\n  Corrected type_info COLUMN_SIZE to chars not bytes thanks to Dean Arnold.\n  Corrected get_info() docs to include details of DBI::Const::GetInfoType.\n  Clarified that $sth->{PRECISION} is OCTET_LENGTH for char types.\n\n=head2 Changes in DBI 1.40,    7th January 2004\n\n  Fixed handling of CachedKids when DESTROYing threaded handles.\n  Fixed sql_user_name() in DBI::DBD::Metadata (used by write_getinfo_pm)\n    to use $dbh->{Username}. Driver authors please update your code.\n\n  Changed connect_cached() when running under Apache::DBI\n    to route calls to Apache::DBI::connect().\n\n  Added CLONE() to DBD::Sponge and DBD::ExampleP.\n  Added warning when starting a new thread about any loaded driver\n    which does not have a CLONE() function.\n  Added new prepare_cache($sql, \\%attr, 3) option to manage Active handles.\n  Added SCALE and NULLABLE support to DBD::Sponge.\n  Added missing execute() in fetchall_hashref docs thanks to Iain Truskett.\n  Added a CONTRIBUTING section to the docs with notes on creating patches.\n\n=head2 Changes in DBI 1.39,    27th November 2003\n\n  Fixed STORE to not clear error during nested DBI call, again/better,\n    thanks to Tony Bowden for the report and helpful test case.\n  Fixed DBI dispatch to not try to use AUTOLOAD for driver methods unless\n    the method has been declared (as methods should be when using AUTOLOAD).\n    This fixes a problem when the Attribute::Handlers module is loaded.\n  Fixed cwd check code to use $Config{path_sep} thanks to Steve Hay.\n  Fixed unqualified croak() calls thanks to Steffen Goeldner.\n  Fixed DBD::ExampleP TYPE and PRECISION attributes thanks to Tom Lowery.\n  Fixed tracing of methods that only get traced at high trace levels.\n\n  The level 1 trace no longer includes nested method calls so it generally\n    just shows the methods the application explicitly calls.\n  Added line to trace log (level>=4) when err/errstr is cleared.\n  Updated docs for InactiveDestroy and point out where and when the\n    trace includes the process id.\n  Update DBI::DBD docs thanks to Steffen Goeldner.\n  Removed docs saying that the DBI->data_sources method could be\n    passed a $dbh. The $dbh->data_sources method should be used instead.\n  Added link to 'DBI recipes' thanks to Giuseppe Maxia:\n    http://gmax.oltrelinux.com/dbirecipes.html (note that this\n    is not an endorsement that the recipies are 'optimal')\n\n  Note: There is a bug in perl 5.8.2 when configured with threads\n  and debugging enabled (bug #24463) which causes a DBI test to fail.\n\n=head2 Changes in DBI 1.38,    21th August 2003\n\n  NOTE: The DBI now requires perl version 5.6.0 or later.\n  (As per notice in DBI 1.33 released 27th February 2003)\n\n  Fixed spurious t/03handles failure on 64bit perls reported by H.Merijn Brand.\n  Fixed spurious t/15array failure on some perl versions thanks to Ed Avis.\n  Fixed build using dmake on windows thanks to Steffen Goeldner.\n  Fixed build on using some shells thanks to Gurusamy Sarathy.\n  Fixed ParamValues to only be appended to ShowErrorStatement if not empty.\n  Fixed $dbh->{Statement} not being writable by drivers in some cases.\n  Fixed occasional undef warnings on connect failures thanks to Ed Avis.\n  Fixed small memory leak when using $sth->{NAME..._hash}.\n  Fixed 64bit warnings thanks to Marian Jancar.\n  Fixed DBD::Proxy::db::DESTROY to not alter $@ thanks to Keith Chapman.\n  Fixed Makefile.PL status from WriteMakefile() thanks to Leon Brocard.\n\n  Changed \"Can't set ...->{Foo}: unrecognised attribute\" from an error to a\n    warning when running with DBI::ProxyServer to simplify upgrades.\n  Changed execute_array() to no longer require ArrayTupleStatus attribute.\n  Changed DBI->available_drivers to not hide DBD::Sponge.\n  Updated/moved placeholder docs to a better place thanks to Johan Vromans.\n  Changed dbd_db_do4 api in Driver.xst to match dbd_st_execute (return int,\n    not bool), relevant only to driver authors.\n  Changed neat(), and thus trace(), so strings marked as utf8 are presented\n    in double quotes instead of single quotes and are not sanitized.\n\n  Added $dbh->data_sources method.\n  Added $dbh->last_insert_id method.\n  Added $sth->execute_for_fetch($fetch_tuple_sub, \\@tuple_status) method.\n  Added DBI->installed_versions thanks to Jeff Zucker.\n  Added $DBI::Profile::ON_DESTROY_DUMP variable.\n  Added docs for DBD::Sponge thanks to Mark Stosberg.\n\n=head2 Changes in DBI 1.37,    15th May 2003\n\n  Fixed \"Can't get dbh->{Statement}: unrecognised attribute\" error in test\n    caused by change to perl internals in 5.8.0\n  Fixed to build with latest development perl (5.8.1@19525).\n  Fixed C code to use all ANSI declarations thanks to Steven Lembark.\n\n=head2 Changes in DBI 1.36,    11th May 2003\n\n  Fixed DBI->connect to carp instead of croak on 'old-style' usage.\n  Fixed connect(,,, { RootClass => $foo }) to not croak if module not found.\n  Fixed code generated by DBI::DBD::Metadata thanks to DARREN@cpan.org (#2270)\n  Fixed DBI::PurePerl to not reset $@ during method dispatch.\n  Fixed VMS build thanks to Michael Schwern.\n  Fixed Proxy disconnect thanks to Steven Hirsch.\n  Fixed error in DBI::DBD docs thanks to Andy Hassall.\n\n  Changed t/40profile.t to not require Time::HiRes.\n  Changed DBI::ProxyServer to load DBI only on first request, which\n    helps threaded server mode, thanks to Bob Showalter.\n  Changed execute_array() return value from row count to executed\n    tuple count, and now the ArrayTupleStatus attribute is mandatory.\n    NOTE: That is an API definition change that may affect your code.\n  Changed CompatMode attribute to also disable attribute 'quick FETCH'.\n  Changed attribute FETCH to be slightly faster thanks to Stas Bekman.\n\n  Added workaround for perl bug #17575 tied hash nested FETCH\n    thanks to Silvio Wanka.\n  Added Username and Password attributes to connect(..., \\%attr) and so\n    also embedded in DSN like \"dbi:Driver(Username=user,Password=pass):...\"\n    Username and Password can't contain \")\", \",\", or \"=\" characters.\n    The predence is DSN first, then \\%attr, then $user & $pass parameters,\n    and finally the DBI_USER & DBI_PASS environment variables.\n    The Username attribute is stored in the $dbh but the Password is not.\n  Added ProxyServer HOWTO configure restrictions docs thanks to Jochen Wiedmann.\n  Added MaxRows attribute to selectcol_arrayref prompted by Wojciech Pietron.\n  Added dump_handle as a method not just a DBI:: utility function.\n  Added on-demand by-row data feed into execute_array() using code ref,\n    or statement handle. For example, to insert from a select:\n    $insert_sth->execute_array( { ArrayTupleFetch => $select_sth, ... } )\n  Added warning to trace log when $h->{foo}=... is ignored due to\n    invalid prefix (e.g., not 'private_').\n\n=head2 Changes in DBI 1.35,    7th March 2003\n\n  Fixed memory leak in fetchrow_hashref introduced in DBI 1.33.\n  Fixed various DBD::Proxy errors introduced in DBI 1.33.\n  Fixed to ANSI C in dbd_dr_data_sources thanks to Jonathan Leffler.\n  Fixed $h->can($method_name) to return correct code ref.\n  Removed DBI::Format from distribution as it's now part of the\n    separate DBI::Shell distribution by Tom Lowery.\n  Updated DBI::DBD docs with a note about the CLONE method.\n  Updated DBI::DBD docs thanks to Jonathan Leffler.\n  Updated DBI::DBD::Metadata for perl 5.5.3 thanks to Jonathan Leffler.\n  Added note to install_method docs about setup_driver() method.\n\n=head2 Changes in DBI 1.34,    28th February 2003\n\n  Fixed DBI::DBD docs to refer to DBI::DBD::Metadata thanks to Jonathan Leffler.\n  Fixed dbi_time() compile using BorlandC on Windows thanks to Steffen Goeldner.\n  Fixed profile tests to do enough work to measure on Windows.\n  Fixed disconnect_all() to not be required by drivers.\n\n  Added $okay = $h->can($method_name) to check if a method exists.\n  Added DBD::*::*->install_method($method_name, \\%attr) so driver private\n    methods can be 'installed' into the DBI dispatcher and no longer\n    need to be called using $h->func(..., $method_name).\n\n  Enhanced $dbh->clone() and documentation.\n  Enhanced docs to note that dbi_time(), and thus profiling, is limited\n    to only millisecond (seconds/1000) resolution on Windows.\n  Removed old DBI::Shell from distribution and added Tom Lowery's improved\n    version to the Bundle::DBI file.\n  Updated minimum version numbers for modules in Bundle::DBI.\n\n=head2 Changes in DBI 1.33,    27th February 2003\n\n  NOTE: Future versions of the DBI *will not* support perl 5.6.0 or earlier.\n  : Perl 5.6.1 will be the minimum supported version.\n\n  NOTE: The \"old-style\" connect: DBI->connect($database, $user, $pass, $driver);\n  : has been deprecated for several years and will now generate a warning.\n  : It will be removed in a later release. Please change any old connect() calls.\n\n  Added $dbh2 = $dbh1->clone to make a new connection to the database\n    that is identical to the original one. clone() can be called even after\n    the original handle has been disconnected. See the docs for more details.\n\n  Fixed merging of profile data to not sum DBIprof_FIRST_TIME values.\n  Fixed unescaping of newlines in DBI::ProfileData thanks to Sam Tregar.\n  Fixed Taint bug with fetchrow_hashref with help from Bradley Baetz.\n  Fixed $dbh->{Active} for DBD::Proxy, reported by Bob Showalter.\n  Fixed STORE to not clear error during nested DBI call,\n    thanks to Tony Bowden for the report and helpful test case.\n  Fixed DBI::PurePerl error clearing behaviour.\n  Fixed dbi_time() and thus DBI::Profile on Windows thanks to Smejkal Petr.\n  Fixed problem that meant ShowErrorStatement could show wrong statement,\n   thanks to Ron Savage for the report and test case.\n  Changed Apache::DBI hook to check for $ENV{MOD_PERL} instead of\n    $ENV{GATEWAY_INTERFACE} thanks to Ask Bjoern Hansen.\n  No longer tries to dup trace logfp when an interpreter is being cloned.\n  Database handles no longer inherit shared $h->err/errstr/state storage\n    from their drivers, so each $dbh has it's own $h->err etc. values\n    and is no longer affected by calls made on other dbh's.\n    Now when a dbh is destroyed it's err/errstr/state values are copied\n    up to the driver so checking $DBI::errstr still works as expected.\n\n  Build / portability fixes:\n    Fixed t/40profile.t to not use Time::HiRes.\n    Fixed t/06attrs.t to not be locale sensitive, reported by Christian Hammers.\n    Fixed sgi compiler warnings, reported by Paul Blake.\n    Fixed build using make -j4, reported by Jonathan Leffler.\n    Fixed build and tests under VMS thanks to Craig A. Berry.\n\n  Documentation changes:\n    Documented $high_resolution_time = dbi_time() function.\n    Documented that bind_col() can take an attribute hash.\n    Clarified documentation for ParamValues attribute hash keys.\n    Many good DBI documentation tweaks from Jonathan Leffler,\n      including a major update to the DBI::DBD driver author guide.\n    Clarified that execute() should itself call finish() if it's\n      called on a statement handle that's still active.\n    Clarified $sth->{ParamValues}. Driver authors please note.\n    Removed \"NEW\" markers on some methods and attributes and\n      added text to each giving the DBI version it was added in,\n      if it was added after DBI 1.21 (Feb 2002).\n\n  Changes of note for authors of all drivers:\n    Added SQL_DATA_TYPE, SQL_DATETIME_SUB, NUM_PREC_RADIX, and\n      INTERVAL_PRECISION fields to docs for type_info_all. There were\n      already in type_info(), but type_info_all() didn't specify the\n      index values.  Please check and update your type_info_all() code.\n    Added DBI::DBD::Metadata module that auto-generates your drivers\n      get_info and type_info_all data and code, thanks mainly to\n      Jonathan Leffler and Steffen Goeldner. If you've not implemented\n      get_info and type_info_all methods and your database has an ODBC\n      driver available then this will do all the hard work for you!\n    Drivers should no longer pass Err, Errstr, or State to _new_drh\n      or _new_dbh functions.\n    Please check that you support the slightly modified behaviour of\n      $sth->{ParamValues}, e.g., always return hash with keys if possible.\n\n  Changes of note for authors of compiled drivers:\n    Added dbd_db_login6 & dbd_st_finish3 prototypes thanks to Jonathan Leffler.\n    All dbd_*_*() functions implemented by drivers must have a\n      corresponding #define dbd_*_* <driver_prefix>_*_* otherwise\n      the driver may not work with a future release of the DBI.\n\n  Changes of note for authors of drivers which use Driver.xst:\n    Some new method hooks have been added are are enabled by\n      defining corresponding macros:\n          $drh->data_sources()      - dbd_dr_data_sources\n          $dbh->do()                - dbd_db_do4\n    The following methods won't be compiled into the driver unless\n      the corresponding macro has been #defined:\n          $drh->disconnect_all()    - dbd_discon_all\n\n\n=head2 Changes in DBI 1.32,    1st December 2002\n\n  Fixed to work with 5.005_03 thanks to Tatsuhiko Miyagawa (I've not tested it).\n  Reenabled taint tests (accidentally left disabled) spotted by Bradley Baetz.\n  Improved docs for FetchHashKeyName attribute thanks to Ian Barwick.\n  Fixed core dump if fetchrow_hashref given bad argument (name of attribute\n    with a value that wasn't an array reference), spotted by Ian Barwick.\n  Fixed some compiler warnings thanks to David Wheeler.\n  Updated Steven Hirsch's enhanced proxy work (seems I left out a bit).\n  Made t/40profile.t tests more reliable, reported by Randy, who is part of\n    the excellent CPAN testers team: http://testers.cpan.org/\n    (Please visit, see the valuable work they do and, ideally, join in!)\n\n=head2 Changes in DBI 1.31,    29th November 2002\n\n  The fetchall_arrayref method, when called with a $maxrows parameter,\n    no longer gives an error if called again after all rows have been\n    fetched. This simplifies application logic when fetching in batches.\n    Also added batch-fetch while() loop example to the docs.\n  The proxy now supports non-lazy (synchronous) prepare, positioned\n    updates (for selects containing 'for update'), PlRPC config set\n    via attributes, and accurate propagation of errors, all thanks\n    to Steven Hirsch (plus a minor fix from Sean McMurray and doc\n    tweaks from Michael A Chase).\n  The DBI_AUTOPROXY env var can now hold the full dsn of the proxy driver\n    plus attributes, like \"dbi:Proxy(proxy_foo=>1):host=...\".\n  Added TaintIn & TaintOut attributes to give finer control over\n    tainting thanks to Bradley Baetz.\n  The RootClass attribute no longer ignores failure to load a module,\n    but also doesn't try to load a module if the class already exists,\n    with thanks to James FitzGibbon.\n  HandleError attribute works for connect failures thanks to David Wheeler.\n  The connect() RaiseError/PrintError message now includes the username.\n  Changed \"last handle unknown or destroyed\" warning to be a trace message.\n  Removed undocumented $h->event() method.\n  Further enhancements to DBD::PurePerl accuracy.\n  The CursorName attribute now defaults to undef and not an error.\n\n  DBI::Profile changes:\n    New DBI::ProfileDumper, DBI::ProfileDumper::Apache, and\n    DBI::ProfileData modules (to manage the storage and processing\n    of profile data), plus dbiprof program for analyzing profile\n    data - with many thanks to Sam Tregar.\n    Added $DBI::err (etc) tied variable lookup time to profile.\n    Added time for DESTROY method into parent handles profile (used to be ignored).\n\n  Documentation changes:\n    Documented $dbh = $sth->{Database} attribute.\n    Documented $dbh->connected(...) post-connection call when subclassing.\n    Updated some minor doc issues thanks to H.Merijn Brand.\n    Updated Makefile.PL example in DBI::DBD thanks to KAWAI,Takanori.\n    Fixed execute_array() example thanks to Peter van Hardenberg.\n\n  Changes for driver authors, not required but strongly recommended:\n    Change DBIS to DBIc_DBISTATE(imp_xxh)   [or imp_dbh, imp_sth etc]\n    Change DBILOGFP to DBIc_LOGPIO(imp_xxh) [or imp_dbh, imp_sth etc]\n    Any function from which all instances of DBIS and DBILOGFP are\n    removed can also have dPERLINTERP removed (a good thing).\n    All use of the DBIh_EVENT* macros should be removed.\n    Major update to DBI::DBD docs thanks largely to Jonathan Leffler.\n    Add these key values: 'Err' => \\my $err, 'Errstr' => \\my $errstr,\n    to the hash passed to DBI::_new_dbh() in your driver source code.\n    That will make each $dbh have it's own $h->err and $h->errstr\n    values separate from other $dbh belonging to the same driver.\n    If you have a ::db or ::st DESTROY methods that do nothing\n    you can now remove them - which speeds up handle destruction.\n\n\n=head2 Changes in DBI 1.30,    18th July 2002\n\n  Fixed problems with selectrow_array, selectrow_arrayref, and\n    selectall_arrayref introduced in DBI 1.29.\n  Fixed FETCHing a handle attribute to not clear $DBI::err etc (broken in 1.29).\n  Fixed core dump at trace level 9 or above.\n  Fixed compilation with perl 5.6.1 + ithreads (i.e. Windows).\n  Changed definition of behaviour of selectrow_array when called in a scalar\n    context to match fetchrow_array.\n  Corrected selectrow_arrayref docs which showed selectrow_array thanks to Paul DuBois.\n\n=head2 Changes in DBI 1.29,    15th July 2002\n\n  NOTE: This release changes the specified behaviour for the\n  : fetchrow_array method when called in a scalar context:\n  : The DBI spec used to say that it would return the FIRST field.\n  : Which field it returns (i.e., the first or the last) is now undefined.\n  : This does not affect statements that only select one column, which is\n  : usually the case when fetchrow_array is called in a scalar context.\n  : FYI, this change was triggered by discovering that the fetchrow_array\n  : implementation in Driver.xst (used by most compiled drivers)\n  : didn't match the DBI specification. Rather than change the code\n  : to match, and risk breaking existing applications, I've changed the\n  : specification (that part was always of dubious value anyway).\n\n  NOTE: Future versions of the DBI may not support for perl 5.5 much longer.\n  : If you are still using perl 5.005_03 you should be making plans to\n  : upgrade to at least perl 5.6.1, or 5.8.0. Perl 5.8.0 is due to be\n  : released in the next week or so.  (Although it's a \"point 0\" release,\n  : it is the most thoroughly tested release ever.)\n\n  Added XS/C implementations of selectrow_array, selectrow_arrayref, and\n    selectall_arrayref to Driver.xst. See DBI 1.26 Changes for more info.\n  Removed support for the old (fatally flawed) \"5005\" threading model.\n  Added support for new perl 5.8 iThreads thanks to Gerald Richter.\n    (Threading support and safety should still be regarded as beta\n    quality until further notice. But it's much better than it was.)\n  Updated the \"Threads and Thread Safety\" section of the docs.\n  The trace output can be sent to STDOUT instead of STDERR by using\n    \"STDOUT\" as the name of the file, i.e., $h->trace(..., \"STDOUT\")\n  Added pointer to perlreftut, perldsc, perllol, and perlboot manuals\n    into the intro section of the docs, suggested by Brian McCain.\n  Fixed DBI::Const::GetInfo::* pod docs thanks to Zack Weinberg.\n  Some changes to how $dbh method calls are treated by DBI::Profile:\n    Meta-data methods now clear $dbh->{Statement} on entry.\n    Some $dbh methods are now profiled as if $dbh->{Statement} was empty\n    (because thet're unlikely to actually relate to its contents).\n  Updated dbiport.h to ppport.h from perl 5.8.0.\n  Tested with perl 5.5.3 (vanilla, Solaris), 5.6.1 (vanilla, Solaris), and\n    perl 5.8.0 (RC3@17527 with iThreads & Multiplicity on Solaris and FreeBSD).\n\n=head2 Changes in DBI 1.28,    14th June 2002\n\n  Added $sth->{ParamValues} to return a hash of the most recent\n    values bound to placeholders via bind_param() or execute().\n    Individual drivers need to be updated to support it.\n  Enhanced ShowErrorStatement to include ParamValues if available:\n    \"DBD::foo::st execute failed: errstr [for statement ``...'' with params: 1='foo']\"\n  Further enhancements to DBD::PurePerl accuracy.\n\n=head2 Changes in DBI 1.27,    13th June 2002\n\n  Fixed missing column in C implementation of fetchall_arrayref()\n    thanks to Philip Molter for the prompt reporting of the problem.\n\n=head2 Changes in DBI 1.26,    13th June 2002\n\n  Fixed t/40profile.t to work on Windows thanks to Smejkal Petr.\n  Fixed $h->{Profile} to return undef, not error, if not set.\n  Fixed DBI->available_drivers in scalar context thanks to Michael Schwern.\n\n  Added C implementations of selectrow_arrayref() and fetchall_arrayref()\n    in Driver.xst.  All compiled drivers using Driver.xst will now be\n    faster making those calls. Most noticeable with fetchall_arrayref for\n    many rows or selectrow_arrayref with a fast query. For example, using\n    DBD::mysql a selectrow_arrayref for a single row using a primary key\n    is ~20% faster, and fetchall_arrayref for 20000 rows is twice as fast!\n    Drivers just need to be recompiled and reinstalled to enable it.\n    The fetchall_arrayref speed up only applies if $slice parameter is not used.\n  Added $max_rows parameter to fetchall_arrayref() to optionally limit\n    the number of rows returned. Can now fetch batches of rows.\n  Added MaxRows attribute to selectall_arrayref()\n    which then passes it to fetchall_arrayref().\n  Changed selectrow_array to make use of selectrow_arrayref.\n  Trace level 1 now shows first two parameters of all methods\n    (used to only for that for some, like prepare,execute,do etc)\n  Trace indicator for recursive calls (first char on trace lines)\n    now starts at 1 not 2.\n\n  Documented that $h->func() does not trigger RaiseError etc\n    so applications must explicitly check for errors.\n  DBI::Profile with DBI_PROFILE now shows percentage time inside DBI.\n  HandleError docs updated to show that handler can edit error message.\n  HandleError subroutine interface is now regarded as stable.\n\n=head2 Changes in DBI 1.25,    5th June 2002\n\n  Fixed build problem on Windows and some compiler warnings.\n  Fixed $dbh->{Driver} and $sth->{Statement} for driver internals\n    These are 'inner' handles as per behaviour prior to DBI 1.16.\n  Further minor improvements to DBI::PurePerl accuracy.\n\n=head2 Changes in DBI 1.24,    4th June 2002\n\n  Fixed reference loop causing a handle/memory leak\n    that was introduced in DBI 1.16.\n  Fixed DBI::Format to work with 'filehandles' from IO::Scalar\n    and similar modules thanks to report by Jeff Boes.\n  Fixed $h->func for DBI::PurePerl thanks to Jeff Zucker.\n  Fixed $dbh->{Name} for DBI::PurePerl thanks to Dean Arnold.\n\n  Added DBI method call profiling and benchmarking.\n    This is a major new addition to the DBI.\n    See $h->{Profile} attribute and DBI::Profile module.\n    For a quick trial, set the DBI_PROFILE environment variable and\n    run your favourite DBI script. Try it with DBI_PROFILE set to 1,\n    then try 2, 4, 8, 10, and -10. Have fun!\n\n  Added execute_array() and bind_param_array() documentation\n    with thanks to Dean Arnold.\n  Added notes about the DBI having not yet been tested with iThreads\n    (testing and patches for SvLOCK etc welcome).\n  Removed undocumented Handlers attribute (replaced by HandleError).\n  Tested with 5.5.3 and 5.8.0 RC1.\n\n=head2 Changes in DBI 1.23,    25th May 2002\n\n  Greatly improved DBI::PurePerl in performance and accuracy.\n  Added more detail to DBI::PurePerl docs about what's not supported.\n  Fixed undef warnings from t/15array.t and DBD::Sponge.\n\n=head2 Changes in DBI 1.22,    22nd May 2002\n\n  Added execute_array() and bind_param_array() with special thanks\n    to Dean Arnold. Not yet documented. See t/15array.t for examples.\n    All drivers now automatically support these methods.\n  Added DBI::PurePerl, a transparent DBI emulation for pure-perl drivers\n    with special thanks to Jeff Zucker. Perldoc DBI::PurePerl for details.\n  Added DBI::Const::GetInfo* modules thanks to Steffen Goeldner.\n  Added write_getinfo_pm utility to DBI::DBD thanks to Steffen Goeldner.\n  Added $allow_active==2 mode for prepare_cached() thanks to Stephen Clouse.\n\n  Updated DBI::Format to Revision 11.4 thanks to Tom Lowery.\n  Use File::Spec in Makefile.PL (helps VMS etc) thanks to Craig Berry.\n  Extend $h->{Warn} to commit/rollback ineffective warning thanks to Jeff Baker.\n  Extended t/preparse.t and removed \"use Devel::Peek\" thanks to Scott Hildreth.\n  Only copy Changes to blib/lib/Changes.pm once thanks to Jonathan Leffler.\n  Updated internals for modern perls thanks to Jonathan Leffler and Jeff Urlwin.\n  Tested with perl 5.7.3 (just using default perl config).\n\n  Documentation changes:\n\n  Added 'Catalog Methods' section to docs thanks to Steffen Goeldner.\n  Updated README thanks to Michael Schwern.\n  Clarified that driver may choose not to start new transaction until\n    next use of $dbh after commit/rollback.\n  Clarified docs for finish method.\n  Clarified potentials problems with prepare_cached() thanks to Stephen Clouse.\n\n\n=head2 Changes in DBI 1.21,    7th February 2002\n\n  The minimum supported perl version is now 5.005_03.\n\n  Fixed DBD::Proxy support for AutoCommit thanks to Jochen Wiedmann.\n  Fixed DBI::ProxyServer bind_param(_inout) handing thanks to Oleg Mechtcheriakov.\n  Fixed DBI::ProxyServer fetch loop thanks to nobull@mail.com.\n  Fixed install_driver do-the-right-thing with $@ on error. It, and connect(),\n    will leave $@ empty on success and holding the error message on error.\n    Thanks to Jay Lawrence, Gavin Sherlock and others for the bug report.\n  Fixed fetchrow_hashref to assign columns to the hash left-to-right\n    so later fields with the same name overwrite earlier ones\n    as per DBI < 1.15, thanks to Kay Roepke.\n\n  Changed tables() to use quote_indentifier() if the driver returns a\n    true value for $dbh->get_info(29) # SQL_IDENTIFIER_QUOTE_CHAR\n  Changed ping() so it no longer triggers RaiseError/PrintError.\n  Changed connect() to not call $class->install_driver unless needed.\n  Changed DESTROY to catch fatal exceptions and append to $@.\n\n  Added ISO SQL/CLI & ODBCv3 data type definitions thanks to Steffen Goeldner.\n  Removed the definition of SQL_BIGINT data type constant as the value is\n    inconsistent between standards (ODBC=-5, SQL/CLI=25).\n  Added $dbh->column_info(...) thanks to Steffen Goeldner.\n  Added $dbh->foreign_key_info(...) thanks to Steffen Goeldner.\n  Added $dbh->quote_identifier(...) insipred by Simon Oliver.\n  Added $dbh->set_err(...) for DBD authors and DBI subclasses\n    (actually been there for a while, now expanded and documented).\n  Added $h->{HandleError} = sub { ... } addition and/or alternative\n    to RaiseError/PrintError. See the docs for more info.\n  Added $h->{TraceLevel} = N attribute to set/get trace level of handle\n    thus can set trace level via an (eg externally specified) DSN\n    using the embedded attribute syntax:\n      $dsn = 'dbi:DB2(PrintError=1,TraceLevel=2):dbname';\n    Plus, you can also now do: local($h->{TraceLevel}) = N;\n    (but that leaks a little memory in some versions of perl).\n  Added some call tree information to trace output if trace level >= 3\n    With thanks to Graham Barr for the stack walking code.\n  Added experimental undocumented $dbh->preparse(), see t/preparse.t\n    With thanks to Scott T. Hildreth for much of the work.\n  Added Fowler/Noll/Vo hash type as an option to DBI::hash().\n\n  Documentation changes:\n\n  Added DBI::Changes so now you can \"perldoc DBI::Changes\", yeah!\n  Added selectrow_arrayref & selectrow_hashref docs thanks to Doug Wilson.\n  Added 'Standards Reference Information' section to docs to gather\n    together all references to relevant on-line standards.\n  Added link to poop.sourceforge.net into the docs thanks to Dave Rolsky.\n  Added link to hyperlinked BNF for SQL92 thanks to Jeff Zucker.\n  Added 'Subclassing the DBI' docs thanks to Stephen Clouse, and\n    then changed some of them to reflect the new approach to subclassing.\n  Added stronger wording to description of $h->{private_*} attributes.\n  Added docs for DBI::hash.\n\n  Driver API changes:\n\n  Now a COPY of the DBI->connect() attributes is passed to the driver\n    connect() method, so it can process and delete any elements it wants.\n    Deleting elements reduces/avoids the explicit\n      $dbh->{$_} = $attr->{$_} foreach keys %$attr;\n    that DBI->connect does after the driver connect() method returns.\n\n\n=head2 Changes in DBI 1.20,    24th August 2001\n\n  WARNING: This release contains two changes that may affect your code.\n  : Any code using selectall_hashref(), which was added in March 2001, WILL\n  : need to be changed. Any code using fetchall_arrayref() with a non-empty\n  : hash slice parameter may, in a few rare cases, need to be changed.\n  : See the change list below for more information about the changes.\n  : See the DBI documentation for a description of current behaviour.\n\n  Fixed memory leak thanks to Toni Andjelkovic.\n  Changed fetchall_arrayref({ foo=>1, ...}) specification again (sorry):\n    The key names of the returned hashes is identical to the letter case of\n    the names in the parameter hash, regardless of the L</FetchHashKeyName>\n    attribute. The letter case is ignored for matching.\n  Changed fetchall_arrayref([...]) array slice syntax specification to\n    clarify that the numbers in the array slice are perl index numbers\n    (which start at 0) and not column numbers (which start at 1).\n  Added { Columns=>... } and { Slice =>... } attributes to selectall_arrayref()\n    which is passed to fetchall_arrayref() so it can fetch hashes now.\n  Added a { Columns => [...] } attribute to selectcol_arrayref() so that\n    the list it returns can be built from more than one column per row.\n    Why? Consider my %hash = @{$dbh->selectcol_arrayref($sql,{ Columns=>[1,2]})}\n    to return id-value pairs which can be used directly to build a hash.\n  Added $hash_ref = $sth->fetchall_hashref( $key_field )\n    which returns a ref to a hash with, typically, one element per row.\n    $key_field is the name of the field to get the key for each row from.\n    The value of the hash for each row is a hash returned by fetchrow_hashref.\n  Changed selectall_hashref to return a hash ref (from fetchall_hashref)\n    and not an array of hashes as it has since DBI 1.15 (end March 2001).\n    WARNING: THIS CHANGE WILL BREAK ANY CODE USING selectall_hashref()!\n    Sorry, but I think this is an important regularization of the API.\n    To get previous selectall_hashref() behaviour (an array of hash refs)\n    change $ary_ref = $dbh->selectall_hashref( $statement, undef, @bind);\n\tto $ary_ref = $dbh->selectall_arrayref($statement, { Columns=>{} }, @bind);\n  Added NAME_lc_hash, NAME_uc_hash, NAME_hash statement handle attributes.\n    which return a ref to a hash of field_name => field_index (0..n-1) pairs.\n  Fixed select_hash() example thanks to Doug Wilson.\n  Removed (unbundled) DBD::ADO and DBD::Multiplex from the DBI distribution.\n    The latest versions of those modules are available from CPAN sites.\n  Added $dbh->begin_work. This method causes AutoCommit to be turned\n    off just until the next commit() or rollback().\n    Driver authors: if the DBIcf_BegunWork flag is set when your commit or\n    rollback method is called then please turn AutoCommit on and clear the\n    DBIcf_BegunWork flag. If you don't then the DBI will but it'll be much\n    less efficient and won't handle error conditions very cleanly.\n  Retested on perl 5.4.4, but the DBI won't support 5.4.x much longer.\n  Added text to SUPPORT section of the docs:\n    For direct DBI and DBD::Oracle support, enhancement, and related work\n    I am available for consultancy on standard commercial terms.\n  Added text to ACKNOWLEDGEMENTS section of the docs:\n    Much of the DBI and DBD::Oracle was developed while I was Technical\n    Director (CTO) of the Paul Ingram Group (www.ig.co.uk).  So I'd\n    especially like to thank Paul for his generosity and vision in\n    supporting this work for many years.\n\n=head2 Changes in DBI 1.19,    20th July 2001\n\n  Made fetchall_arrayref({ foo=>1, ...}) be more strict to the specification\n    in relation to wanting hash slice keys to be lowercase names.\n    WARNING: If you've used fetchall_arrayref({...}) with a hash slice\n    that contains keys with uppercase letters then your code will break.\n    (As far as I recall the spec has always said don't do that.)\n  Fixed $sth->execute() to update $dbh->{Statement} to $sth->{Statement}.\n  Added row number to trace output for fetch method calls.\n  Trace level 1 no longer shows fetches with row>1 (to reduce output volume).\n  Added $h->{FetchHashKeyName} = 'NAME_lc' or 'NAME_uc' to alter\n    behaviour of fetchrow_hashref() method. See docs.\n  Added type_info quote caching to quote() method thanks to Dean Kopesky.\n    Makes using quote() with second data type param much much faster.\n  Added type_into_all() caching to type_info(), spotted by Dean Kopesky.\n  Added new API definition for table_info() and tables(),\n    driver authors please note!\n  Added primary_key_info() to DBI API thanks to Steffen Goeldner.\n  Added primary_key() to DBI API as simpler interface to primary_key_info().\n  Indent and other fixes for DBI::DBD doc thanks to H.Merijn Brand.\n  Added prepare_cached() insert_hash() example thanks to Doug Wilson.\n  Removed false docs for fetchall_hashref(), use fetchall_arrayref({}).\n\n=head2 Changes in DBI 1.18,    4th June 2001\n\n  Fixed that altering ShowErrorStatement also altered AutoCommit!\n    Thanks to Jeff Boes for spotting that clanger.\n  Fixed DBD::Proxy to handle commit() and rollback(). Long overdue, sorry.\n  Fixed incompatibility with perl 5.004 (but no one's using that right? :)\n  Fixed connect_cached and prepare_cached to not be affected by the order\n    of elements in the attribute hash. Spotted by Mitch Helle-Morrissey.\n  Fixed version number of DBI::Shell\n    reported by Stuhlpfarrer Gerhard and others.\n  Defined and documented table_info() attribute semantics (ODBC compatible)\n    thanks to Olga Voronova, who also implemented then in DBD::Oracle.\n  Updated Win32::DBIODBC (Win32::ODBC emulation) thanks to Roy Lee.\n\n=head2 Changes in DBI 1.16,    30th May 2001\n\n  Reimplemented fetchrow_hashref in C, now fetches about 25% faster!\n  Changed behaviour if both PrintError and RaiseError are enabled\n    to simply do both (in that order, obviously :)\n  Slight reduction in DBI handle creation overhead.\n  Fixed $dbh->{Driver} & $sth->{Database} to return 'outer' handles.\n  Fixed execute param count check to honour RaiseError spotted by Belinda Giardie.\n  Fixed build for perl5.6.1 with PERLIO thanks to H.Merijn Brand.\n  Fixed client sql restrictions in ProxyServer.pm thanks to Jochen Wiedmann.\n  Fixed batch mode command parsing in Shell thanks to Christian Lemburg.\n  Fixed typo in selectcol_arrayref docs thanks to Jonathan Leffler.\n  Fixed selectrow_hashref to be available to callers thanks to T.J.Mather.\n  Fixed core dump if statement handle didn't define Statement attribute.\n  Added bind_param_inout docs to DBI::DBD thanks to Jonathan Leffler.\n  Added note to data_sources() method docs that some drivers may\n    require a connected database handle to be supplied as an attribute.\n  Trace of install_driver method now shows path of driver file loaded.\n  Changed many '||' to 'or' in the docs thanks to H.Merijn Brand.\n  Updated DBD::ADO again (improvements in error handling) from Tom Lowery.\n  Updated Win32::DBIODBC (Win32::ODBC emulation) thanks to Roy Lee.\n  Updated email and web addresses in DBI::FAQ thanks to Michael A Chase.\n\n=head2 Changes in DBI 1.15,    28th March 2001\n\n  Added selectrow_arrayref\n  Added selectrow_hashref\n  Added selectall_hashref thanks to Leon Brocard.\n  Added DBI->connect(..., { dbi_connect_method => 'method' })\n  Added $dbh->{Statement} aliased to most recent child $sth->{Statement}.\n  Added $h->{ShowErrorStatement}=1 to cause the appending of the\n    relevant Statement text to the RaiseError/PrintError text.\n  Modified type_info to always return hash keys in uppercase and\n    to not require uppercase 'DATA_TYPE' key from type_info_all.\n    Thanks to Jennifer Tong and Rob Douglas.\n  Added \\%attr param to tables() and table_info() methods.\n  Trace method uses warn() if it can't open the new file.\n  Trace shows source line and filename during global destruction.\n  Updated packages:\n    Updated Win32::DBIODBC (Win32::ODBC emulation) thanks to Roy Lee.\n    Updated DBD::ADO to much improved version 0.4 from Tom Lowery.\n    Updated DBD::Sponge to include $sth->{PRECISION} thanks to Tom Lowery.\n    Changed DBD::ExampleP to use lstat() instead of stat().\n  Documentation:\n    Documented $DBI::lasth (which has been there since day 1).\n    Documented SQL_* names.\n    Clarified and extended docs for $h->state thanks to Masaaki Hirose.\n    Clarified fetchall_arrayref({}) docs (thanks to, er, someone!).\n    Clarified type_info_all re lettercase and index values.\n    Updated DBI::FAQ to 0.38 thanks to Alligator Descartes.\n    Added cute bind_columns example thanks to H.Merijn Brand.\n    Extended docs on \\%attr arg to data_sources method.\n  Makefile.PL\n    Removed obscure potential 'rm -rf /' (thanks to Ulrich Pfeifer).\n    Removed use of glob and find (thanks to Michael A. Chase).\n  Proxy:\n    Removed debug messages from DBD::Proxy AUTOLOAD thanks to Brian McCauley.\n    Added fix for problem using table_info thanks to Tom Lowery.\n    Added better determination of where to put the pid file, and...\n    Added KNOWN ISSUES section to DBD::Proxy docs thanks to Jochen Wiedmann.\n  Shell:\n    Updated DBI::Format to include DBI::Format::String thanks to Tom Lowery.\n    Added describe command thanks to Tom Lowery.\n    Added columnseparator option thanks to Tom Lowery (I think).\n    Added 'raw' format thanks to, er, someone, maybe Tom again.\n  Known issues:\n    Perl 5.005 and 5.006 both leak memory doing local($handle->{Foo}).\n    Perl 5.004 doesn't. The leak is not a DBI or driver bug.\n\n=head2 Changes in DBI 1.14,\t14th June 2000\n\n  NOTE: This version is the one the DBI book is based on.\n  NOTE: This version requires at least Perl 5.004.\n  Perl 5.6 ithreads changes with thanks to Doug MacEachern.\n  Changed trace output to use PerlIO thanks to Paul Moore.\n  Fixed bug in RaiseError/PrintError handling.\n    (% chars in the error string could cause a core dump.)\n  Fixed Win32 PerlEx IIS concurrency bugs thanks to Murray Nesbitt.\n  Major documentation polishing thanks to Linda Mui at O'Reilly.\n  Password parameter now shown as **** in trace output.\n  Added two fields to type_info and type_info_all.\n  Added $dsn to PrintError/RaiseError message from DBI->connect().\n  Changed prepare_cached() croak to carp if sth still Active.\n  Added prepare_cached() example to the docs.\n  Added further DBD::ADO enhancements from Thomas Lowery.\n\n=head2 Changes in DBI 1.13,\t11th July 1999\n\n  Fixed Win32 PerlEx IIS concurrency bugs thanks to Murray Nesbitt.\n  Fixed problems with DBD::ExampleP long_list test mode.\n  Added SQL_WCHAR SQL_WVARCHAR SQL_WLONGVARCHAR and SQL_BIT\n    to list of known and exportable SQL types.\n  Improved data fetch performance of DBD::ADO.\n  Added GetTypeInfo to DBD::ADO thanks to Thomas Lowery.\n  Actually documented connect_cached thanks to Michael Schwern.\n  Fixed user/key/cipher bug in ProxyServer thanks to Joshua Pincus.\n\n=head2 Changes in DBI 1.12,\t29th June 1999\n\n  Fixed significant DBD::ADO bug (fetch skipped first row).\n  Fixed ProxyServer bug handling non-select statements.\n  Fixed VMS problem with t/examp.t thanks to Craig Berry.\n  Trace only shows calls to trace_msg and _set_fbav at high levels.\n  Modified t/examp.t to workaround Cygwin buffering bug.\n\n=head2 Changes in DBI 1.11,\t17th June 1999\n\n  Fixed bind_columns argument checking to allow a single arg.\n  Fixed problems with internal default_user method.\n  Fixed broken DBD::ADO.\n  Made default $DBI::rows more robust for some obscure cases.\n\n=head2 Changes in DBI 1.10,\t14th June 1999\n\n  Fixed trace_msg.al error when using Apache.\n  Fixed dbd_st_finish enhancement in Driver.xst (internals).\n  Enable drivers to define default username and password\n    and temporarily disabled warning added in 1.09.\n  Thread safety optimised for single thread case.\n\n=head2 Changes in DBI 1.09,\t9th June 1999\n\n  Added optional minimum trace level parameter to trace_msg().\n  Added warning in Makefile.PL that DBI will require 5.004 soon.\n  Added $dbh->selectcol_arrayref($statement) method.\n  Fixed fetchall_arrayref hash-slice mode undef NAME problem.\n  Fixed problem with tainted parameter checking and t/examp.t.\n  Fixed problem with thread safety code, including 64 bit machines.\n  Thread safety now enabled by default for threaded perls.\n  Enhanced code for MULTIPLICITY/PERL_OBJECT from ActiveState.\n  Enhanced prepare_cached() method.\n  Minor changes to trace levels (less internal info at level 2).\n  Trace log now shows \"!! ERROR...\" before the \"<- method\" line.\n  DBI->connect() now warn's if user / password is undefined and\n    DBI_USER / DBI_PASS environment variables are not defined.\n  The t/proxy.t test now ignores any /etc/dbiproxy.conf file.\n  Added portability fixes for MacOS from Chris Nandor.\n  Updated mailing list address from fugue.com to isc.org.\n\n=head2 Changes in DBI 1.08,\t12th May 1999\n\n  Much improved DBD::ADO driver thanks to Phlip Plumlee and others.\n  Connect now allows you to specify attribute settings within the DSN\n    E.g., \"dbi:Driver(RaiseError=>1,Taint=>1,AutoCommit=>0):dbname\"\n  The $h->{Taint} attribute now also enables taint checking of\n    arguments to almost all DBI methods.\n  Improved trace output in various ways.\n  Fixed bug where $sth->{NAME_xx} was undef in some situations.\n  Fixed code for MULTIPLICITY/PERL_OBJECT thanks to Alex Smishlajev.\n  Fixed and documented DBI->connect_cached.\n  Workaround for Cygwin32 build problem with help from Jong-Pork Park.\n  bind_columns no longer needs undef or hash ref as first parameter.\n\n=head2 Changes in DBI 1.07,\t6th May 1999\n\n  Trace output now shows contents of array refs returned by DBI.\n  Changed names of some result columns from type_info, type_info_all,\n    tables and table_info to match ODBC 3.5 / ISO/IEC standards.\n  Many fixes for DBD::Proxy and ProxyServer.\n  Fixed error reporting in install_driver.\n  Major enhancement to DBI::W32ODBC from Patrick Hollins.\n  Added $h->{Taint} to taint fetched data if tainting (perl -T).\n  Added code for MULTIPLICITY/PERL_OBJECT contributed by ActiveState.\n  Added $sth->more_results (undocumented for now).\n\n=head2 Changes in DBI 1.06,\t6th January 1999\n\n  Fixed Win32 Makefile.PL problem in 1.04 and 1.05.\n  Significant DBD::Proxy enhancements and fixes\n    including support for bind_param_inout (Jochen and I)\n  Added experimental DBI->connect_cached method.\n  Added $sth->{NAME_uc} and $sth->{NAME_lc} attributes.\n  Enhanced fetchrow_hashref to take an attribute name arg.\n\n=head2 Changes in DBI 1.05,\t4th January 1999\n\n  Improved DBD::ADO connect (thanks to Phlip Plumlee).\n  Improved thread safety (thanks to Jochen Wiedmann).\n  [Quick release prompted by truncation of copies on CPAN]\n\n=head2 Changes in DBI 1.04,\t3rd January 1999\n\n  Fixed error in Driver.xst. DBI build now tests Driver.xst.\n  Removed unused variable compiler warnings in Driver.xst.\n  DBI::DBD module now tested during DBI build.\n  Further clarification in the DBI::DBD driver writers manual.\n  Added optional name parameter to $sth->fetchrow_hashref.\n\n=head2 Changes in DBI 1.03,\t1st January 1999\n\n  Now builds with Perl>=5.005_54 (PERL_POLLUTE in DBIXS.h)\n  DBI trace trims path from \"at yourfile.pl line nnn\".\n  Trace level 1 now shows statement passed to prepare.\n  Assorted improvements to the DBI manual.\n  Assorted improvements to the DBI::DBD driver writers manual.\n  Fixed $dbh->quote prototype to include optional $data_type.\n  Fixed $dbh->prepare_cached problems.\n  $dbh->selectrow_array behaves better in scalar context.\n  Added a (very) experimental DBD::ADO driver for Win32 ADO.\n  Added experimental thread support (perl Makefile.PL -thread).\n  Updated the DBI::FAQ - thanks to Alligator Descartes.\n  The following changes were implemented and/or packaged\n    by Jochen Wiedmann - thanks Jochen:\n  Added a Bundle for CPAN installation of DBI, the DBI proxy\n    server and prerequisites (lib/Bundle/DBI.pm).\n  DBI->available_drivers uses File::Spec, if available.\n    This makes it work on MacOS. (DBI.pm)\n  Modified type_info to work with read-only values returned\n    by type_info_all. (DBI.pm)\n  Added handling of magic values in $sth->execute,\n    $sth->bind_param and other methods (Driver.xst)\n  Added Perl's CORE directory to the linkers path on Win32,\n    required by recent versions of ActiveState Perl.\n  Fixed DBD::Sponge to work with empty result sets.\n  Complete rewrite of DBI::ProxyServer and DBD::Proxy.\n\n=head2 Changes in DBI 1.02,\t2nd September 1998\n\n  Fixed DBI::Shell including @ARGV and /current.\n  Added basic DBI::Shell test.\n  Renamed DBI::Shell /display to /format.\n\n=head2 Changes in DBI 1.01,\t2nd September 1998\n\n  Many enhancements to Shell (with many contributions from\n  Jochen Wiedmann, Tom Lowery and Adam Marks).\n  Assorted fixes to DBD::Proxy and DBI::ProxyServer.\n  Tidied up trace messages - trace(2) much cleaner now.\n  Added $dbh->{RowCacheSize} and $sth->{RowsInCache}.\n  Added experimental DBI::Format (mainly for DBI::Shell).\n  Fixed fetchall_arrayref($slice_hash).\n  DBI->connect now honours PrintError=1 if connect fails.\n  Assorted clarifications to the docs.\n\n=head2 Changes in DBI 1.00,\t14th August 1998\n\n  The DBI is no longer 'alpha' software!\n  Added $dbh->tables and $dbh->table_info.\n  Documented \\%attr arg to data_sources method.\n  Added $sth->{TYPE}, $sth->{PRECISION} and $sth->{SCALE}.\n  Added $sth->{Statement}.\n  DBI::Shell now uses neat_list to print results\n  It also escapes \"'\" chars and converts newlines to spaces.\n\n=head2 Changes in DBI 0.95,\t10th August 1998\n\n  WARNING: THIS IS AN EXPERIMENTAL RELEASE!\n\n  Fixed 0.94 slip so it will build on pre-5.005 again.\n  Added DBI_AUTOPROXY environment variable.\n  Array ref returned from fetch/fetchrow_arrayref now readonly.\n  Improved connect error reporting by DBD::Proxy.\n  All trace/debug messages from DBI now go to trace file.\n\n=head2 Changes in DBI 0.94,\t9th August 1998\n\n  WARNING: THIS IS AN EXPERIMENTAL RELEASE!\n\n  Added DBD::Shell and dbish interactive DBI shell. Try it!\n  Any database attribs can be set via DBI->connect(,,, \\%attr).\n  Added _get_fbav and _set_fbav methods for Perl driver developers\n    (see ExampleP driver for perl usage). Drivers which don't use\n    one of these methods (either via XS or Perl) are not compliant.\n  DBI trace now shows adds \" at yourfile.pl line nnn\"!\n  PrintError and RaiseError now prepend driver and method name.\n  The available_drivers method no longer returns NullP or Sponge.\n  Added $dbh->{Name}.\n  Added $dbh->quote($value, $data_type).\n  Added more hints to install_driver failure message.\n  Added DBD::Proxy and DBI::ProxyServer (from Jochen Wiedmann).\n  Added $DBI::neat_maxlen to control truncation of trace output.\n  Added $dbh->selectall_arrayref and $dbh->selectrow_array methods.\n  Added $dbh->tables.\n  Added $dbh->type_info and $dbh->type_info_all.\n  Added $h->trace_msg($msg) to write to trace log.\n  Added @bool = DBI::looks_like_number(@ary).\n  Many assorted improvements to the DBI docs.\n\n=head2 Changes in DBI 0.93,\t13th February 1998\n\n  Fixed DBI::DBD::dbd_postamble bug causing 'Driver.xsi not found' errors.\n  Changes to handling of 'magic' values in neatsvpv (used by trace).\n  execute (in Driver.xst) stops binding after first bind error.\n  This release requires drivers to be rebuilt.\n\n=head2 Changes in DBI 0.92,\t3rd February 1998\n\n  Fixed per-handle memory leak (with many thanks to Irving Reid).\n  Added $dbh->prepare_cached() caching variant of $dbh->prepare.\n  Added some attributes:\n    $h->{Active}       is the handle 'Active' (vague concept) (boolean)\n    $h->{Kids}         e.g. number of sth's associated with a dbh\n    $h->{ActiveKids}   number of the above which are 'Active'\n    $dbh->{CachedKids} ref to prepare_cached sth cache\n  Added support for general-purpose 'private_' attributes.\n  Added experimental support for subclassing the DBI: see t/subclass.t\n  Added SQL_ALL_TYPES to exported :sql_types.\n  Added dbd_dbi_dir() and dbd_dbi_arch_dir() to DBI::DBD module so that\n  DBD Makefile.PLs can work with the DBI installed in non-standard locations.\n  Fixed 'Undefined value' warning and &sv_no output from neatsvpv/trace.\n  Fixed small 'once per interpreter' leak.\n  Assorted minor documentation fixes.\n\n=head2 Changes in DBI 0.91,\t10th December 1997\n\n  NOTE: This fix may break some existing scripts:\n  DBI->connect(\"dbi:...\",$user,$pass) was not setting AutoCommit and PrintError!\n  DBI->connect(..., { ... }) no longer sets AutoCommit or PrintError twice.\n  DBI->connect(..., { RaiseError=>1 }) now croaks if connect fails.\n  Fixed $fh parameter of $sth->dump_results;\n  Added default statement DESTROY method which carps.\n  Added default driver DESTROY method to silence AUTOLOAD/__DIE__/CGI::Carp\n  Added more SQL_* types to %EXPORT_TAGS and @EXPORT_OK.\n  Assorted documentation updates (mainly clarifications).\n  Added workaround for perl's 'sticky lvalue' bug.\n  Added better warning for bind_col(umns) where fields==0.\n  Fixed to build okay with 5.004_54 with or without USE_THREADS.\n  Note that the DBI has not been tested for thread safety yet.\n\n=head2 Changes in DBI 0.90,\t6th September 1997\n\n  Can once again be built with Perl 5.003.\n  The DBI class can be subclassed more easily now.\n  InactiveDestroy fixed for drivers using the *.xst template.\n  Slightly faster handle creation.\n  Changed prototype for dbd_*_*_attrib() to add extra param.\n  Note: 0.90, 0.89 and possibly some other recent versions have\n  a small memory leak. This will be fixed in the next release.\n\n=head2 Changes in DBI 0.89,\t25th July 1997\n\n  Minor fix to neatsvpv (mainly used for debug trace) to workaround\n  bug in perl where SvPV removes IOK flag from an SV.\n  Minor updates to the docs.\n\n=head2 Changes in DBI 0.88,\t22nd July 1997\n\n  Fixed build for perl5.003 and Win32 with Borland.\n  Fixed documentation formatting.\n  Fixed DBI_DSN ignored for old-style connect (with explicit driver).\n  Fixed AutoCommit in DBD::ExampleP\n  Fixed $h->trace.\n  The DBI can now export SQL type values: use DBI ':sql_types';\n  Modified Driver.xst and renamed DBDI.h to dbd_xsh.h\n\n=head2 Changes in DBI 0.87,\t18th July 1997\n\n  Fixed minor type clashes.\n  Added more docs about placeholders and bind values.\n\n=head2 Changes in DBI 0.86,\t16th July 1997\n\n  Fixed failed connect causing 'unblessed ref' and other errors.\n  Drivers must handle AutoCommit FETCH and STORE else DBI croaks.\n  Added $h->{LongReadLen} and $h->{LongTruncOk} attributes for BLOBS.\n  Added DBI_USER and DBI_PASS env vars. See connect docs for usage.\n  Added DBI->trace() to set global trace level (like per-handle $h->trace).\n  PERL_DBI_DEBUG env var renamed DBI_DEBUG (old name still works for now).\n  Updated docs, including commit, rollback, AutoCommit and Transactions sections.\n  Added bind_param method and execute(@bind_values) to docs.\n  Fixed fetchall_arrayref.\n\n  Since the DBIS structure has change the internal version numbers have also\n  changed (DBIXS_VERSION == 9 and DBISTATE_VERSION == 9) so drivers will have\n  to be recompiled. The test is also now more sensitive and the version\n  mismatch error message now more clear about what to do. Old drivers are\n  likely to core dump (this time) until recompiled for this DBI. In future\n  DBI/DBD version mismatch will always produce a clear error message.\n\n  Note that this DBI release contains and documents many new features\n  that won't appear in drivers for some time. Driver writers might like\n  to read perldoc DBI::DBD and comment on or apply the information given.\n\n=head2 Changes in DBI 0.85,\t25th June 1997\n\n  NOTE: New-style connect now defaults to AutoCommit mode unless\n  { AutoCommit => 0 } specified in connect attributes. See the docs.\n  AutoCommit attribute now defined and tracked by DBI core.\n  Drivers should use/honour this and not implement their own.\n  Added pod doc changes from Andreas and Jonathan.\n  New DBI_DSN env var default for connect method. See docs.\n  Documented the func method.\n  Fixed \"Usage: DBD::_::common::DESTROY\" error.\n  Fixed bug which set some attributes true when there value was fetched.\n  Added new internal DBIc_set() macro for drivers to use.\n\n=head2 Changes in DBI 0.84,\t20th June 1997\n\n  Added $h->{PrintError} attribute which, if set true, causes all errors to\n  trigger a warn().\n  New-style DBI->connect call now automatically sets PrintError=1 unless\n  { PrintError => 0 } specified in the connect attributes. See the docs.\n  The old-style connect with a separate driver parameter is deprecated.\n  Fixed fetchrow_hashref.\n  Renamed $h->debug to $h->trace() and added a trace filename arg.\n  Assorted other minor tidy-ups.\n\n=head2 Changes in DBI 0.83,\t11th June 1997\n\n  Added driver specification syntax to DBI->connect data_source\n  parameter: DBI->connect('dbi:driver:...', $user, $passwd);\n  The DBI->data_sources method should return data_source\n  names with the appropriate 'dbi:driver:' prefix.\n  DBI->connect will warn if \\%attr is true but not a hash ref.\n  Added the new fetchrow methods:\n    @row_ary  = $sth->fetchrow_array;\n    $ary_ref  = $sth->fetchrow_arrayref;\n    $hash_ref = $sth->fetchrow_hashref;\n  The old fetch and fetchrow methods still work.\n  Driver implementors should implement the new names for\n  fetchrow_array and fetchrow_arrayref ASAP (use the xs ALIAS:\n  directive to define aliases for fetch and fetchrow).\n  Fixed occasional problems with t/examp.t test.\n  Added automatic errstr reporting to the debug trace output.\n  Added the DBI FAQ from Alligator Descartes in module form for\n  easy reading via \"perldoc DBI::FAQ\". Needs reformatting.\n  Unknown driver specific attribute names no longer croak.\n  Fixed problem with internal neatsvpv macro.\n\n=head2 Changes in DBI 0.82,\t23rd May 1997\n\n  Added $h->{RaiseError} attribute which, if set true, causes all errors to\n  trigger a die(). This makes it much easier to implement robust applications\n  in terms of higher level eval { ... } blocks and rollbacks.\n  Added DBI->data_sources($driver) method for implementation by drivers.\n  The quote method now returns the string NULL (without quotes) for undef.\n  Added VMS support thanks to Dan Sugalski.\n  Added a 'quick start guide' to the README.\n  Added neatsvpv function pointer to DBIS structure to make it available for\n  use by drivers. A macro defines neatsvpv(sv,len) as (DBIS->neatsvpv(sv,len)).\n  Old XS macro SV_YES_NO changes to standard boolSV.\n  Since the DBIS structure has change the internal version numbers have also\n  changed (DBIXS_VERSION == 8 and DBISTATE_VERSION == 8) so drivers will have\n  to be recompiled.\n\n=head2 Changes in DBI 0.81,\t7th May 1997\n\n  Minor fix to let DBI build using less modern perls.\n  Fixed a suprious typo warning.\n\n=head2 Changes in DBI 0.80,\t6th May 1997\n\n  Builds with no changes on NT using perl5.003_99 (with thanks to Jeffrey Urlwin).\n  Automatically supports Apache::DBI (with thanks to Edmund Mergl).\n    DBI scripts no longer need to be modified to make use of Apache::DBI.\n  Added a ping method and an experimental connect_test_perf method.\n  Added a fetchhash and fetch_all methods.\n  The func method no longer pre-clears err and errstr.\n  Added ChopBlanks attribute (currently defaults to off, that may change).\n    Support for the attribute needs to be implemented by individual drivers.\n  Reworked tests into standard t/*.t form.\n  Added more pod text.  Fixed assorted bugs.\n\n\n=head2 Changes in DBI 0.79,\t7th Apr 1997\n\n  Minor release. Tidied up pod text and added some more descriptions\n  (especially disconnect). Minor changes to DBI.xs to remove compiler\n  warnings.\n\n=head2 Changes in DBI 0.78,\t28th Mar 1997\n\n  Greatly extended the pod documentation in DBI.pm, including the under\n  used bind_columns method. Use 'perldoc DBI' to read after installing.\n  Fixed $h->err. Fetching an attribute value no longer resets err.\n  Added $h->{InactiveDestroy}, see documentation for details.\n  Improved debugging of cached ('quick') attribute fetches.\n  errstr will return err code value if there is no string value.\n  Added DBI/W32ODBC to the distribution. This is a pure-perl experimental\n  DBI emulation layer for Win32::ODBC. Note that it's unsupported, your\n  mileage will vary, and bug reports without fixes will probably be ignored.\n\n=head2 Changes in DBI 0.77,\t21st Feb 1997\n\n  Removed erroneous $h->errstate and $h->errmsg methods from DBI.pm.\n  Added $h->err, $h->errstr and $h->state default methods in DBI.xs.\n  Updated informal DBI API notes in DBI.pm. Updated README slightly.\n  DBIXS.h now correctly installed into INST_ARCHAUTODIR.\n  (DBD authors will need to edit their Makefile.PL's to use\n  -I$(INSTALLSITEARCH)/auto/DBI -I$(INSTALLSITEARCH)/DBI)\n\n\n=head2 Changes in DBI 0.76,\t3rd Feb 1997\n\n  Fixed a compiler type warnings (pedantic IRIX again).\n\n=head2 Changes in DBI 0.75,\t27th Jan 1997\n\n  Fix problem introduced by a change in Perl5.003_XX.\n  Updated README and DBI.pm docs.\n\n=head2 Changes in DBI 0.74,\t14th Jan 1997\n\n  Dispatch now sets dbi_debug to the level of the current handle\n  (this makes tracing/debugging individual handles much easier).\n  The '>> DISPATCH' log line now only logged at debug >= 3 (was 2).\n  The $csr->NUM_OF_FIELDS attribute can be set if not >0 already.\n  You can log to a file using the env var PERL_DBI_DEBUG=/tmp/dbi.log.\n  Added a type cast needed by IRIX.\n  No longer sets perl_destruct_level unless debug set >= 4.\n  Make compatible with PerlIO and sfio.\n\n=head2 Changes in DBI 0.73,\t10th Oct 1996\n\n  Fixed some compiler type warnings (IRIX).\n  Fixed DBI->internal->{DebugLog} = $filename.\n  Made debug log file unbuffered.\n  Added experimental bind_param_inout method to interface.\n  Usage: $dbh->bind_param_inout($param, \\$value, $maxlen [, \\%attribs ])\n  (only currently used by DBD::Oracle at this time.)\n\n=head2 Changes in DBI 0.72,\t23 Sep 1996\n\n  Using an undefined value as a handle now gives a better\n  error message (mainly useful for emulators like Oraperl).\n  $dbh->do($sql, @params) now works for binding placeholders.\n\n=head2 Changes in DBI 0.71,\t10 July 1996\n\n  Removed spurious abort() from invalid handle check.\n  Added quote method to DBI interface and added test.\n\n=head2 Changes in DBI 0.70,\t16 June 1996\n\n  Added extra invalid handle check (dbih_getcom)\n  Fixed broken $dbh->quote method.\n  Added check for old GCC in Makefile.PL\n\n=head2 Changes in DBI 0.69\n\n  Fixed small memory leak.\n  Clarified the behaviour of DBI->connect.\n  $dbh->do now returns '0E0' instead of 'OK'.\n  Fixed \"Can't read $DBI::errstr, lost last handle\" problem.\n\n\n=head2 Changes in DBI 0.68,\t2 Mar 1996\n\n  Changes to suit perl5.002 and site_lib directories.\n  Detects old versions ahead of new in @INC.\n\n\n=head2 Changes in DBI 0.67,\t15 Feb 1996\n\n  Trivial change to test suite to fix a problem shown up by the\n  Perl5.002gamma release Test::Harness.\n\n\n=head2 Changes in DBI 0.66,\t29 Jan 1996\n\n  Minor changes to bring the DBI into line with 5.002 mechanisms,\n  specifically the xs/pm VERSION checking mechanism.\n  No functionality changes. One no-last-handle bug fix (rare problem).\n  Requires 5.002 (beta2 or later).\n\n\n=head2 Changes in DBI 0.65,\t23 Oct 1995\n\n  Added $DBI::state to hold SQL CLI / ODBC SQLSTATE value.\n  SQLSTATE \"00000\" (success) is returned as \"\" (false), all else is true.\n  If a driver does not explicitly initialise it (via $h->{State} or\n  DBIc_STATE(imp_xxh) then $DBI::state will automatically return \"\" if\n  $DBI::err is false otherwise \"S1000\" (general error).\n  As always, this is a new feature and liable to change.\n\n  The is *no longer* a default error handler!\n  You can add your own using push(@{$h->{Handlers}}, sub { ... })\n  but be aware that this interface may change (or go away).\n\n  The DBI now automatically clears $DBI::err, errstr and state before\n  calling most DBI methods. Previously error conditions would persist.\n  Added DBIh_CLEAR_ERROR(imp_xxh) macro.\n\n  DBI now EXPORT_OK's some utility functions, neat($value),\n  neat_list(@values) and dump_results($sth).\n\n  Slightly enhanced t/min.t minimal test script in an effort to help\n  narrow down the few stray core dumps that some porters still report.\n\n  Renamed readblob to blob_read (old name still works but warns).\n  Added default blob_copy_to_file method.\n\n  Added $sth = $dbh->tables method. This returns an $sth for a query\n  which has these columns: TABLE_CATALOGUE, TABLE_OWNER, TABLE_NAME,\n  TABLE_TYPE, REMARKS in that order. The TABLE_CATALOGUE column\n  should be ignored for now.\n\n\n=head2 Changes in DBI 0.64,\t23 Oct 1995\n\n  Fixed 'disconnect invalidates 1 associated cursor(s)' problem.\n  Drivers using DBIc_ACTIVE_on/off() macros should not need any changes\n  other than to test for DBIc_ACTIVE_KIDS() instead of DBIc_KIDS().\n  Fixed possible core dump in dbih_clearcom during global destruction.\n\n\n=head2 Changes in DBI 0.63,\t1 Sep 1995\n\n  Minor update. Fixed uninitialised memory bug in method\n  attribute handling and streamlined processing and debugging.\n  Revised usage definitions for bind_* methods and readblob.\n\n\n=head2 Changes in DBI 0.62,\t26 Aug 1995\n\n  Added method redirection method $h->func(..., $method_name).\n  This is now the official way to call private driver methods\n  that are not part of the DBI standard.  E.g.:\n      @ary = $sth->func('ora_types');\n  It can also be used to call existing methods. Has very low cost.\n\n  $sth->bind_col columns now start from 1 (not 0) to match SQL.\n  $sth->bind_columns now takes a leading attribute parameter (or undef),\n  e.g., $sth->bind_columns($attribs, \\$col1 [, \\$col2 , ...]);\n\n  Added handy DBD_ATTRIBS_CHECK macro to vet attribs in XS.\n  Added handy DBD_ATTRIB_GET_SVP, DBD_ATTRIB_GET_BOOL and\n  DBD_ATTRIB_GET_IV macros for handling attributes.\n\n  Fixed STORE for NUM_OF_FIELDS and NUM_OF_PARAMS.\n  Added FETCH for NUM_OF_FIELDS and NUM_OF_PARAMS.\n\n  Dispatch no longer bothers to call _untie().\n  Faster startup via install_method/_add_dispatch changes.\n\n\n=head2 Changes in DBI 0.61,\t22 Aug 1995\n\n  Added $sth->bind_col($column, \\$var [, \\%attribs ]);\n\n  This method enables perl variable to be directly and automatically\n  updated when a row is fetched. It requires no driver support\n  (if the driver has been written to use DBIS->get_fbav).\n  Currently \\%attribs is unused.\n\n  Added $sth->bind_columns(\\$var [, \\$var , ...]);\n\n  This method is a short-cut for bind_col which binds all the\n  columns of a query in one go (with no attributes). It also\n  requires no driver support.\n\n  Added $sth->bind_param($parameter, $var [, \\%attribs ]);\n\n  This method enables attributes to be specified when values are\n  bound to placeholders. It also enables binding to occur away\n  from the execute method to improve execute efficiency.\n  The DBI does not provide a default implementation of this.\n  See the DBD::Oracle module for a detailed example.\n\n  The DBI now provides default implementations of both fetch and\n  fetchrow.  Each is written in terms of the other. A driver is\n  expected to implement at least one of them.\n\n  More macro and assorted structure changes in DBDXS.h. Sorry!\n  The old dbihcom definitions have gone. All fields have macros.\n  The imp_xxh_t type is now used within the DBI as well as drivers.\n  Drivers must set DBIc_NUM_FIELDS(imp_sth) and DBIc_NUM_PARAMS(imp_sth).\n\n  test.pl includes a trivial test of bind_param and bind_columns.\n\n\n=head2 Changes in DBI 0.60,\t17 Aug 1995\n\n  This release has significant code changes but much less\n  dramatic than the previous release. The new implementors data\n  handling mechanism has matured significantly (don't be put off\n  by all the struct typedefs in DBIXS.h, there's just to make it\n  easier for drivers while keeping things type-safe).\n\n  The DBI now includes two new methods:\n\n  do\t\t$dbh->do($statement)\n\n  This method prepares, executes and finishes a statement. It is\n  designed to be used for executing one-off non-select statements\n  where there is no benefit in reusing a prepared statement handle.\n\n  fetch\t\t$array_ref = $sth->fetch;\n\n  This method is the new 'lowest-level' row fetching method. The\n  previous @row = $sth->fetchrow method now defaults to calling\n  the fetch method and expanding the returned array reference.\n\n  The DBI now provides fallback attribute FETCH and STORE functions\n  which drivers should call if they don't recognise an attribute.\n\n  THIS RELEASE IS A GOOD STARTING POINT FOR DRIVER DEVELOPERS!\n  Study DBIXS.h from the DBI and Oracle.xs etc from DBD::Oracle.\n  There will be further changes in the interface but nothing\n  as dramatic as these last two releases! (I hope :-)\n\n\n=head2 Changes in DBI 0.59\t15 Aug 1995\n\n  NOTE: THIS IS AN UNSTABLE RELEASE!\n\n  Major reworking of internal data management!\n  Performance improvements and memory leaks fixed.\n  Added a new NullP (empty) driver and a -m flag\n  to test.pl to help check for memory leaks.\n  Study DBD::Oracle version 0.21 for more details.\n  (Comparing parts of v0.21 with v0.20 may be useful.)\n\n\n=head2 Changes in DBI 0.58\t21 June 1995\n\n  Added DBI->internal->{DebugLog} = $filename;\n  Reworked internal logging.\n  Added $VERSION.\n  Made disconnect_all a compulsory method for drivers.\n\n\n=head1 ANCIENT HISTORY\n\n12th Oct 1994: First public release of the DBI module.\n               (for Perl 5.000-beta-3h)\n\n19th Sep 1994: DBperl project renamed to DBI.\n\n29th Sep 1992: DBperl project started.\n\n=cut\n", "/* vim: ts=8:sw=4:expandtab\n *\n * $Id$\n *\n * Copyright (c) 1994-2012  Tim Bunce  Ireland.\n *\n * See COPYRIGHT section in DBI.pm for usage and distribution rights.\n */\n#define NEED_grok_number\n#define NEED_grok_numeric_radix\n#define NEED_newRV_noinc\n#define NEED_sv_2pv_flags\n\n#define IN_DBI_XS 1     /* see DBIXS.h */\n#define PERL_NO_GET_CONTEXT\n\n#include \"DBIXS.h\"      /* DBI public interface for DBD's written in C  */\n\n# if (defined(_WIN32) && (! defined(HAS_GETTIMEOFDAY)))\n#include <sys/timeb.h>\n# endif\n\n/* The XS dispatcher code can optimize calls to XS driver methods,\n * bypassing the usual call_sv() and argument handling overheads.\n * Just-in-case it causes problems there's an (undocumented) way\n * to disable it by setting an env var.\n */\nstatic int use_xsbypass = 1; /* set in dbi_bootinit() */\n\n#ifndef CvISXSUB\n#define CvISXSUB(sv) CvXSUB(sv)\n#endif\n\n#define DBI_MAGIC '~'\n\n/* HvMROMETA introduced in 5.9.5, but mro_meta_init not exported in 5.10.0 */\n#if (PERL_VERSION < 10)\n#  define MY_cache_gen(stash) 0\n#else\n#  if ((PERL_VERSION == 10) && (PERL_SUBVERSION == 0))\n#    define MY_cache_gen(stash) \\\n        (HvAUX(stash)->xhv_mro_meta \\\n        ? HvAUX(stash)->xhv_mro_meta->cache_gen \\\n        : 0)\n#  else\n#    define MY_cache_gen(stash) HvMROMETA(stash)->cache_gen\n#  endif\n#endif\n\n/* If the tests fail with errors about 'setlinebuf' then try    */\n/* deleting the lines in the block below except the setvbuf one */\n#ifndef PerlIO_setlinebuf\n#ifdef HAS_SETLINEBUF\n#define PerlIO_setlinebuf(f)        setlinebuf(f)\n#else\n#ifndef USE_PERLIO\n#define PerlIO_setlinebuf(f)        setvbuf(f, Nullch, _IOLBF, 0)\n#endif\n#endif\n#endif\n\n#ifndef CopFILEGV\n#  define CopFILEGV(cop) cop->cop_filegv\n#  define CopLINE(cop)   cop->cop_line\n#  define CopSTASH(cop)           cop->cop_stash\n#  define CopSTASHPV(cop)           (CopSTASH(cop) ? HvNAME(CopSTASH(cop)) : Nullch)\n#endif\n#ifndef PERL_GET_THX\n#define PERL_GET_THX ((void*)0)\n#endif\n#ifndef PerlProc_getpid\n#define PerlProc_getpid() getpid()\nextern Pid_t getpid (void);\n#endif\n#ifndef aTHXo_\n#define aTHXo_\n#endif\n\n#if (PERL_VERSION < 8) || ((PERL_VERSION == 8) && (PERL_SUBVERSION == 0))\n#define DBI_save_hv_fetch_ent\n#endif\n\n/* prior to 5.8.9: when a CV is duped, the mg dup method is called,\n * then *afterwards*, any_ptr is copied from the old CV to the new CV.\n * This wipes out anything which the dup method did to any_ptr.\n * This needs working around */\n#if defined(USE_ITHREADS) && (PERL_VERSION == 8) && (PERL_SUBVERSION < 9)\n#  define BROKEN_DUP_ANY_PTR\n#endif\n\n/* types of method name */\n\ntypedef enum {\n    methtype_ordinary, /* nothing special about this method name */\n    methtype_DESTROY,\n    methtype_FETCH,\n    methtype_can,\n    methtype_fetch_star, /* fetch*, i.e. fetch() or fetch_...() */\n    methtype_set_err\n} meth_types;\n\n\nstatic imp_xxh_t *dbih_getcom      _((SV *h));\nstatic imp_xxh_t *dbih_getcom2     _((pTHX_ SV *h, MAGIC **mgp));\nstatic void       dbih_clearcom    _((imp_xxh_t *imp_xxh));\nstatic int        dbih_logmsg      _((imp_xxh_t *imp_xxh, const char *fmt, ...));\nstatic SV        *dbih_make_com    _((SV *parent_h, imp_xxh_t *p_imp_xxh, const char *imp_class, STRLEN imp_size, STRLEN extra, SV *copy));\nstatic SV        *dbih_make_fdsv   _((SV *sth, const char *imp_class, STRLEN imp_size, const char *col_name));\nstatic AV        *dbih_get_fbav    _((imp_sth_t *imp_sth));\nstatic SV        *dbih_event       _((SV *h, const char *name, SV*, SV*));\nstatic int        dbih_set_attr_k  _((SV *h, SV *keysv, int dbikey, SV *valuesv));\nstatic SV        *dbih_get_attr_k  _((SV *h, SV *keysv, int dbikey));\nstatic int       dbih_sth_bind_col _((SV *sth, SV *col, SV *ref, SV *attribs));\n\nstatic int      set_err_char _((SV *h, imp_xxh_t *imp_xxh, const char *err_c, IV err_i, const char *errstr, const char *state, const char *method));\nstatic int      set_err_sv   _((SV *h, imp_xxh_t *imp_xxh, SV *err, SV *errstr, SV *state, SV *method));\nstatic int      quote_type _((int sql_type, int p, int s, int *base_type, void *v));\nstatic int      sql_type_cast_svpv _((pTHX_ SV *sv, int sql_type, U32 flags, void *v));\nstatic I32      dbi_hash _((const char *string, long i));\nstatic void     dbih_dumphandle _((pTHX_ SV *h, const char *msg, int level));\nstatic int      dbih_dumpcom _((pTHX_ imp_xxh_t *imp_xxh, const char *msg, int level));\nstatic int      dbi_ima_free(pTHX_ SV* sv, MAGIC* mg);\n#if defined(USE_ITHREADS) && !defined(BROKEN_DUP_ANY_PTR)\nstatic int      dbi_ima_dup(pTHX_ MAGIC* mg, CLONE_PARAMS *param);\n#endif\nchar *neatsvpv _((SV *sv, STRLEN maxlen));\nSV * preparse(SV *dbh, const char *statement, IV ps_return, IV ps_accept, void *foo);\nstatic meth_types get_meth_type(const char * const name);\n\nstruct imp_drh_st { dbih_drc_t com; };\nstruct imp_dbh_st { dbih_dbc_t com; };\nstruct imp_sth_st { dbih_stc_t com; };\nstruct imp_fdh_st { dbih_fdc_t com; };\n\n/* identify the type of a method name for dispatch behaviour */\n/* (should probably be folded into the IMA flags mechanism)  */\n\nstatic meth_types\nget_meth_type(const char * const name)\n{\n    switch (name[0]) {\n    case 'D':\n        if strEQ(name,\"DESTROY\")\n            return methtype_DESTROY;\n        break;\n    case 'F':\n        if strEQ(name,\"FETCH\")\n            return methtype_FETCH;\n        break;\n    case 'c':\n        if strEQ(name,\"can\")\n            return methtype_can;\n        break;\n    case 'f':\n        if strnEQ(name,\"fetch\", 5) /* fetch* */\n            return methtype_fetch_star;\n        break;\n    case 's':\n        if strEQ(name,\"set_err\")\n            return methtype_set_err;\n        break;\n    }\n    return methtype_ordinary;\n}\n\n\n/* Internal Method Attributes (attached to dispatch methods when installed) */\n/* NOTE: when adding SVs to dbi_ima_t, update dbi_ima_dup() dbi_ima_free()\n * to ensure that they are duped and correctly ref-counted */\n\ntypedef struct dbi_ima_st {\n    U8 minargs;\n    U8 maxargs;\n    IV hidearg;\n    /* method_trace controls tracing of method calls in the dispatcher:\n    - if the current trace flags include a trace flag in method_trace\n    then set trace_level to min(2,trace_level) for duration of the call.\n    - else, if trace_level < (method_trace & DBIc_TRACE_LEVEL_MASK)\n    then don't trace the call\n    */\n    U32 method_trace;\n    const char *usage_msg;\n    U32 flags;\n    meth_types meth_type;\n\n    /* cached outer to inner method mapping */\n    HV *stash;          /* the stash we found the GV in */\n    GV *gv;             /* the GV containing the inner sub */\n    U32 generation;     /* cache invalidation */\n#ifdef BROKEN_DUP_ANY_PTR\n    PerlInterpreter *my_perl; /* who owns this struct */\n#endif\n\n} dbi_ima_t;\n\n/* These values are embedded in the data passed to install_method       */\n#define IMA_HAS_USAGE             0x00000001  /* check parameter usage        */\n#define IMA_FUNC_REDIRECT         0x00000002  /* is $h->func(..., \"method\")   */\n#define IMA_KEEP_ERR              0x00000004  /* don't reset err & errstr     */\n#define IMA_KEEP_ERR_SUB          0x00000008  /*  '' if in a nested call      */\n#define IMA_NO_TAINT_IN           0x00000010  /* don't check for tainted args */\n#define IMA_NO_TAINT_OUT          0x00000020  /* don't taint results          */\n#define IMA_COPY_UP_STMT          0x00000040  /* copy sth Statement to dbh    */\n#define IMA_END_WORK              0x00000080  /* method is commit or rollback */\n#define IMA_STUB                  0x00000100  /* donothing eg $dbh->connected */\n#define IMA_CLEAR_STMT            0x00000200  /* clear Statement before call  */\n#define IMA_UNRELATED_TO_STMT     0x00000400  /* profile as empty Statement   */\n#define IMA_NOT_FOUND_OKAY        0x00000800  /* no error if not found        */\n#define IMA_EXECUTE               0x00001000  /* do/execute: DBIcf_Executed   */\n#define IMA_SHOW_ERR_STMT         0x00002000  /* dbh meth relates to Statement*/\n#define IMA_HIDE_ERR_PARAMVALUES  0x00004000  /* ParamValues are not relevant */\n#define IMA_IS_FACTORY            0x00008000  /* new h ie connect and prepare */\n#define IMA_CLEAR_CACHED_KIDS     0x00010000  /* clear CachedKids before call */\n\n#define DBIc_STATE_adjust(imp_xxh, state)                                \\\n    (SvOK(state)        /* SQLSTATE is implemented by driver   */        \\\n        ? (strEQ(SvPV_nolen(state),\"00000\") ? &PL_sv_no : sv_mortalcopy(state))\\\n        : (SvTRUE(DBIc_ERR(imp_xxh))                                     \\\n            ? sv_2mortal(newSVpv(\"S1000\",5)) /* General error   */       \\\n            : &PL_sv_no)                /* Success (\"00000\")    */       \\\n    )\n\n#define DBI_LAST_HANDLE         g_dbi_last_h /* special fake inner handle */\n#define DBI_IS_LAST_HANDLE(h)   ((DBI_LAST_HANDLE) == SvRV(h))\n#define DBI_SET_LAST_HANDLE(h)  ((DBI_LAST_HANDLE) =  SvRV(h))\n#define DBI_UNSET_LAST_HANDLE   ((DBI_LAST_HANDLE) =  &PL_sv_undef)\n#define DBI_LAST_HANDLE_OK      ((DBI_LAST_HANDLE) != &PL_sv_undef)\n\n#define DBIS_TRACE_LEVEL        (DBIS->debug & DBIc_TRACE_LEVEL_MASK)\n#define DBIS_TRACE_FLAGS        (DBIS->debug)   /* includes level */\n\n#ifdef PERL_LONG_MAX\n#define MAX_LongReadLen PERL_LONG_MAX\n#else\n#define MAX_LongReadLen 2147483647L\n#endif\n\n#ifdef DBI_USE_THREADS\nstatic char *dbi_build_opt = \"-ithread\";\n#else\nstatic char *dbi_build_opt = \"-nothread\";\n#endif\n\n/* 32 bit magic FNV-0 and FNV-1 prime */\n#define FNV_32_PRIME ((UV)0x01000193)\n\n\n/* perl doesn't know anything about the dbi_ima_t struct attached to the\n * CvXSUBANY(cv).any_ptr slot, so add some magic to the CV to handle\n * duping and freeing.\n */\n\nstatic MGVTBL dbi_ima_vtbl = { 0, 0, 0, 0, dbi_ima_free,\n                                    0,\n#if defined(USE_ITHREADS) && !defined(BROKEN_DUP_ANY_PTR)\n                                    dbi_ima_dup\n#else\n                                    0\n#endif\n#if (PERL_VERSION > 8) || ((PERL_VERSION == 8) && (PERL_SUBVERSION >= 9))\n                                    , 0\n#endif\n                                    };\n\nstatic int dbi_ima_free(pTHX_ SV* sv, MAGIC* mg)\n{\n    dbi_ima_t *ima = (dbi_ima_t *)(CvXSUBANY((CV*)sv).any_ptr);\n#ifdef BROKEN_DUP_ANY_PTR\n    if (ima->my_perl != my_perl)\n        return 0;\n#endif\n    SvREFCNT_dec(ima->stash);\n    SvREFCNT_dec(ima->gv);\n    Safefree(ima);\n    return 0;\n}\n\n#if defined(USE_ITHREADS) && !defined(BROKEN_DUP_ANY_PTR)\nstatic int dbi_ima_dup(pTHX_ MAGIC* mg, CLONE_PARAMS *param)\n{\n    dbi_ima_t *ima, *nima;\n    CV *cv  = (CV*) mg->mg_ptr;\n    CV *ncv = (CV*)ptr_table_fetch(PL_ptr_table, (cv));\n\n    PERL_UNUSED_VAR(param);\n    mg->mg_ptr = (char *)ncv;\n    ima = (dbi_ima_t*) CvXSUBANY(cv).any_ptr;\n    Newx(nima, 1, dbi_ima_t);\n    *nima = *ima; /* structure copy */\n    CvXSUBANY(ncv).any_ptr = nima;\n    nima->stash = NULL;\n    nima->gv    = NULL;\n    return 0;\n}\n#endif\n\n\n\n/* --- make DBI safe for multiple perl interpreters --- */\n/*     Originally contributed by Murray Nesbitt of ActiveState, */\n/*     but later updated to use MY_CTX */\n\n#define MY_CXT_KEY \"DBI::_guts\" XS_VERSION\n\ntypedef struct {\n    SV   *dbi_last_h;  /* maybe better moved into dbistate_t? */\n    dbistate_t* dbi_state;\n} my_cxt_t;\n\nSTART_MY_CXT\n\n#undef DBIS\n#define DBIS                   (MY_CXT.dbi_state)\n\n#define g_dbi_last_h            (MY_CXT.dbi_last_h)\n\n/* allow the 'static' dbi_state struct to be accessed from other files */\ndbistate_t**\n_dbi_state_lval(pTHX)\n{\n    dMY_CXT;\n    return &(MY_CXT.dbi_state);\n}\n\n\n/* --- */\n\nstatic void *\nmalloc_using_sv(STRLEN len)\n{\n    dTHX;\n    SV *sv = newSV(len);\n    void *p = SvPVX(sv);\n    memzero(p, len);\n    return p;\n}\n\nstatic char *\nsavepv_using_sv(char *str)\n{\n    char *buf = malloc_using_sv(strlen(str));\n    strcpy(buf, str);\n    return buf;\n}\n\n\n/* --- support functions for concat_hash_sorted --- */\n\ntypedef struct str_uv_sort_pair_st {\n    char *key;\n    UV numeric;\n} str_uv_sort_pair_t;\n\nstatic int\n_cmp_number(const void *val1, const void *val2)\n{\n    UV first  = ((str_uv_sort_pair_t *)val1)->numeric;\n    UV second = ((str_uv_sort_pair_t *)val2)->numeric;\n\n    if (first > second)\n        return 1;\n    if (first < second)\n        return -1;\n    /* only likely to reach here if numeric sort forced for non-numeric keys */\n    /* fallback to comparing the key strings */\n    return strcmp(\n        ((str_uv_sort_pair_t *)val1)->key,\n        ((str_uv_sort_pair_t *)val2)->key\n    );\n}\n\nstatic int \n_cmp_str (const void *val1, const void *val2)\n{\n    return strcmp( *(char **)val1, *(char **)val2);\n}\n\nstatic char **\n_sort_hash_keys (HV *hash, int num_sort, STRLEN *total_length)\n{\n    dTHX;\n    I32 hv_len, key_len;\n    HE *entry;\n    char **keys;\n    unsigned int idx = 0;\n    STRLEN tot_len = 0;\n    bool has_non_numerics = 0;\n    str_uv_sort_pair_t *numbers;\n\n    hv_len = hv_iterinit(hash);\n    if (!hv_len)\n        return 0;\n\n    Newz(0, keys,    hv_len, char *);\n    Newz(0, numbers, hv_len, str_uv_sort_pair_t);\n\n    while ((entry = hv_iternext(hash))) {\n        *(keys+idx) = hv_iterkey(entry, &key_len);\n        tot_len += key_len;\n        \n        if (grok_number(*(keys+idx), key_len, &(numbers+idx)->numeric) != IS_NUMBER_IN_UV) {\n            has_non_numerics = 1;\n            (numbers+idx)->numeric = 0;\n        }\n\n        (numbers+idx)->key = *(keys+idx);\n        ++idx;\n    }\n\n    if (total_length)\n        *total_length = tot_len;\n\n    if (num_sort < 0)\n        num_sort = (has_non_numerics) ? 0 : 1;\n\n    if (!num_sort) {\n        qsort(keys, hv_len, sizeof(char*), _cmp_str);\n    }\n    else {\n        qsort(numbers, hv_len, sizeof(str_uv_sort_pair_t), _cmp_number);\n        for (idx = 0; idx < hv_len; ++idx)\n            *(keys+idx) = (numbers+idx)->key;\n    }\n\n    Safefree(numbers);\n    return keys;\n}\n\n\nstatic SV *\n_join_hash_sorted(HV *hash, char *kv_sep, STRLEN kv_sep_len, char *pair_sep, STRLEN pair_sep_len, int use_neat, int num_sort)\n{\n        dTHX;\n        I32 hv_len;\n        STRLEN total_len = 0;\n        char **keys;\n        unsigned int i = 0;\n        SV *return_sv;\n\n        keys = _sort_hash_keys(hash, num_sort, &total_len);\n        if (!keys)\n            return newSVpv(\"\", 0);\n\n        if (!kv_sep_len)\n            kv_sep_len = strlen(kv_sep);\n        if (!pair_sep_len)\n            pair_sep_len = strlen(pair_sep);\n\n        hv_len = hv_iterinit(hash);\n        /* total_len += Separators + quotes + term null */\n        total_len += kv_sep_len*hv_len + pair_sep_len*hv_len+2*hv_len+1;\n        return_sv = newSV(total_len);\n        sv_setpv(return_sv, \"\"); /* quell undef warnings */\n\n        for (i=0; i<hv_len; ++i) {\n            SV **hash_svp = hv_fetch(hash, keys[i], strlen(keys[i]), 0);\n\n            sv_catpv(return_sv, keys[i]); /* XXX keys can't contain nul chars */\n            sv_catpvn(return_sv, kv_sep, kv_sep_len);\n\n            if (!hash_svp) {    /* should never happen */\n                warn(\"No hash entry with key '%s'\", keys[i]);\n                sv_catpvn(return_sv, \"???\", 3);\n                continue;\n            }\n\n            if (use_neat) {\n                sv_catpv(return_sv, neatsvpv(*hash_svp,0));\n            }\n            else {\n                if (SvOK(*hash_svp)) {\n                     STRLEN hv_val_len;\n                     char *hv_val = SvPV(*hash_svp, hv_val_len);\n                     sv_catpvn(return_sv, \"'\", 1);\n                     sv_catpvn(return_sv, hv_val, hv_val_len);\n                     sv_catpvn(return_sv, \"'\", 1);\n                }\n                else sv_catpvn(return_sv, \"undef\", 5);\n            }\n\n            if (i < hv_len-1)\n                sv_catpvn(return_sv, pair_sep, pair_sep_len);\n        }\n\n        Safefree(keys);\n\n        return return_sv;\n}\n\n\n\n/* handy for embedding into condition expression for debugging */\n/*\nstatic int warn1(char *s) { warn(s); return 1; }\nstatic int dump1(SV *sv)  { dTHX; sv_dump(sv); return 1; }\n*/\n\n\n/* --- */\n\nstatic void\ncheck_version(const char *name, int dbis_cv, int dbis_cs, int need_dbixs_cv, int drc_s,\n        int dbc_s, int stc_s, int fdc_s)\n{\n    dTHX;\n    dMY_CXT;\n    static const char msg[] = \"you probably need to rebuild the DBD driver (or possibly the DBI)\";\n    (void)need_dbixs_cv;\n    if (dbis_cv != DBISTATE_VERSION || dbis_cs != sizeof(*DBIS))\n        croak(\"DBI/DBD internal version mismatch (DBI is v%d/s%lu, DBD %s expected v%d/s%d) %s.\\n\",\n            DBISTATE_VERSION, (long unsigned int)sizeof(*DBIS), name, dbis_cv, dbis_cs, msg);\n    /* Catch structure size changes - We should probably force a recompile if the DBI   */\n    /* runtime version is different from the build time. That would be harsh but safe.  */\n    if (drc_s != sizeof(dbih_drc_t) || dbc_s != sizeof(dbih_dbc_t) ||\n        stc_s != sizeof(dbih_stc_t) || fdc_s != sizeof(dbih_fdc_t) )\n            croak(\"%s (dr:%d/%ld, db:%d/%ld, st:%d/%ld, fd:%d/%ld), %s.\\n\",\n                \"DBI/DBD internal structure mismatch\",\n                drc_s, (long)sizeof(dbih_drc_t), dbc_s, (long)sizeof(dbih_dbc_t),\n                stc_s, (long)sizeof(dbih_stc_t), fdc_s, (long)sizeof(dbih_fdc_t), msg);\n}\n\nstatic void\ndbi_bootinit(dbistate_t * parent_dbis)\n{\n    dTHX;\n    dMY_CXT;\n    dbistate_t* DBISx;\n\n    DBISx = (struct dbistate_st*)malloc_using_sv(sizeof(struct dbistate_st));\n    DBIS = DBISx;\n\n    /* make DBIS available to DBD modules the \"old\" (<= 1.618) way,\n     * so that unrecompiled DBD's will still work against a newer DBI */\n    sv_setiv(get_sv(\"DBI::_dbistate\", GV_ADDMULTI),\n            PTR2IV(MY_CXT.dbi_state));\n\n    /* store version and size so we can spot DBI/DBD version mismatch   */\n    DBIS->check_version = check_version;\n    DBIS->version = DBISTATE_VERSION;\n    DBIS->size    = sizeof(*DBIS);\n    DBIS->xs_version = DBIXS_VERSION;\n\n    DBIS->logmsg      = dbih_logmsg;\n    DBIS->logfp       = PerlIO_stderr();\n    DBIS->debug       = (parent_dbis) ? parent_dbis->debug\n                            : SvIV(get_sv(\"DBI::dbi_debug\",0x5));\n    DBIS->neatsvpvlen = (parent_dbis) ? parent_dbis->neatsvpvlen\n                                      : get_sv(\"DBI::neat_maxlen\", GV_ADDMULTI);\n#ifdef DBI_USE_THREADS\n    DBIS->thr_owner   = PERL_GET_THX;\n#endif\n\n    /* store some function pointers so DBD's can call our functions     */\n    DBIS->getcom      = dbih_getcom;\n    DBIS->clearcom    = dbih_clearcom;\n    DBIS->event       = dbih_event;\n    DBIS->set_attr_k  = dbih_set_attr_k;\n    DBIS->get_attr_k  = dbih_get_attr_k;\n    DBIS->get_fbav    = dbih_get_fbav;\n    DBIS->make_fdsv   = dbih_make_fdsv;\n    DBIS->neat_svpv   = neatsvpv;\n    DBIS->bind_as_num = quote_type; /* XXX deprecated */\n    DBIS->hash        = dbi_hash;\n    DBIS->set_err_sv  = set_err_sv;\n    DBIS->set_err_char= set_err_char;\n    DBIS->bind_col    = dbih_sth_bind_col;\n    DBIS->sql_type_cast_svpv = sql_type_cast_svpv;\n\n\n    /* Remember the last handle used. BEWARE! Sneaky stuff here!        */\n    /* We want a handle reference but we don't want to increment        */\n    /* the handle's reference count and we don't want perl to try       */\n    /* to destroy it during global destruction. Take care!              */\n    DBI_UNSET_LAST_HANDLE;      /* ensure setup the correct way         */\n\n    /* trick to avoid 'possible typo' warnings  */\n    gv_fetchpv(\"DBI::state\",  GV_ADDMULTI, SVt_PV);\n    gv_fetchpv(\"DBI::err\",    GV_ADDMULTI, SVt_PV);\n    gv_fetchpv(\"DBI::errstr\", GV_ADDMULTI, SVt_PV);\n    gv_fetchpv(\"DBI::lasth\",  GV_ADDMULTI, SVt_PV);\n    gv_fetchpv(\"DBI::rows\",   GV_ADDMULTI, SVt_PV);\n\n    /* we only need to check the env var on the initial boot\n     * which is handy because it can core dump during CLONE on windows\n     */\n    if (!parent_dbis && getenv(\"PERL_DBI_XSBYPASS\"))\n        use_xsbypass = atoi(getenv(\"PERL_DBI_XSBYPASS\"));\n}\n\n\n/* ----------------------------------------------------------------- */\n/* Utility functions                                                 */\n\n\nstatic char *\ndbih_htype_name(int htype)\n{\n    switch(htype) {\n    case DBIt_DR: return \"dr\";\n    case DBIt_DB: return \"db\";\n    case DBIt_ST: return \"st\";\n    case DBIt_FD: return \"fd\";\n    default:      return \"??\";\n    }\n}\n\n\nchar *\nneatsvpv(SV *sv, STRLEN maxlen) /* return a tidy ascii value, for debugging only */\n{\n    dTHX;\n    dMY_CXT;\n    STRLEN len;\n    SV *nsv = Nullsv;\n    SV *infosv = Nullsv;\n    char *v, *quote;\n\n    /* We take care not to alter the supplied sv in any way at all.      */\n    /* (but if it is SvGMAGICAL we have to call mg_get and that can      */\n    /* have side effects, especially as it may be called twice overall.) */\n\n    if (!sv)\n        return \"Null!\";                         /* should never happen  */\n\n    /* try to do the right thing with magical values                    */\n    if (SvMAGICAL(sv)) {\n        if (DBIS_TRACE_LEVEL >= 5) {    /* add magic details to help debugging  */\n            MAGIC* mg;\n            infosv = sv_2mortal(newSVpv(\" (magic-\",0));\n            if (SvSMAGICAL(sv)) sv_catpvn(infosv,\"s\",1);\n            if (SvGMAGICAL(sv)) sv_catpvn(infosv,\"g\",1);\n            if (SvRMAGICAL(sv)) sv_catpvn(infosv,\"r\",1);\n            sv_catpvn(infosv,\":\",1);\n            for (mg = SvMAGIC(sv); mg; mg = mg->mg_moremagic)\n                sv_catpvn(infosv, &mg->mg_type, 1);\n            sv_catpvn(infosv, \")\", 1);\n        }\n        if (SvGMAGICAL(sv) && !PL_dirty)\n            mg_get(sv);         /* trigger magic to FETCH the value     */\n    }\n\n    if (!SvOK(sv)) {\n        if (SvTYPE(sv) >= SVt_PVAV)\n            return (char *)sv_reftype(sv,0);    /* raw AV/HV etc, not via a ref */\n        if (!infosv)\n            return \"undef\";\n        sv_insert(infosv, 0,0, \"undef\",5);\n        return SvPVX(infosv);\n    }\n\n    if (SvNIOK(sv)) {     /* is a numeric value - so no surrounding quotes      */\n        if (SvPOK(sv)) {  /* already has string version of the value, so use it */\n            v = SvPV(sv,len);\n            if (len == 0) { v=\"''\"; len=2; } /* catch &sv_no style special case */\n            if (!infosv)\n                return v;\n            sv_insert(infosv, 0,0, v, len);\n            return SvPVX(infosv);\n        }\n        /* we don't use SvPV here since we don't want to alter sv in _any_ way  */\n        if (SvUOK(sv))\n             nsv = newSVpvf(\"%\"UVuf, SvUVX(sv));\n        else if (SvIOK(sv))\n             nsv = newSVpvf(\"%\"IVdf, SvIVX(sv));\n        else nsv = newSVpvf(\"%\"NVgf, SvNVX(sv));\n        if (infosv)\n            sv_catsv(nsv, infosv);\n        return SvPVX(sv_2mortal(nsv));\n    }\n\n    nsv = sv_newmortal();\n    sv_upgrade(nsv, SVt_PV);\n\n    if (SvROK(sv)) {\n        if (!SvAMAGIC(sv))      /* (un-amagic'd) refs get no special treatment  */\n            v = SvPV(sv,len);\n        else {\n            /* handle Overload magic refs */\n            (void)SvAMAGIC_off(sv);   /* should really be done via local scoping */\n            v = SvPV(sv,len);   /* XXX how does this relate to SvGMAGIC?   */\n            SvAMAGIC_on(sv);\n        }\n        sv_setpvn(nsv, v, len);\n        if (infosv)\n            sv_catsv(nsv, infosv);\n        return SvPV(nsv, len);\n    }\n\n    if (SvPOK(sv))              /* usual simple string case                */\n        v = SvPV(sv,len);\n    else                        /* handles all else via sv_2pv()           */\n        v = SvPV(sv,len);       /* XXX how does this relate to SvGMAGIC?   */\n\n    /* for strings we limit the length and translate codes      */\n    if (maxlen == 0)\n        maxlen = SvIV(DBIS->neatsvpvlen);\n    if (maxlen < 6)                     /* handle daft values   */\n        maxlen = 6;\n    maxlen -= 2;                        /* account for quotes   */\n\n    quote = (SvUTF8(sv)) ? \"\\\"\" : \"'\";\n    if (len > maxlen) {\n        SvGROW(nsv, (1+maxlen+1+1));\n        sv_setpvn(nsv, quote, 1);\n        sv_catpvn(nsv, v, maxlen-3);    /* account for three dots */\n        sv_catpvn(nsv, \"...\", 3);\n    } else {\n        SvGROW(nsv, (1+len+1+1));\n        sv_setpvn(nsv, quote, 1);\n        sv_catpvn(nsv, v, len);\n    }\n    sv_catpvn(nsv, quote, 1);\n    if (infosv)\n        sv_catsv(nsv, infosv);\n    v = SvPV(nsv, len);\n    if (!SvUTF8(sv)) {\n        while(len-- > 0) { /* cleanup string (map control chars to ascii etc) */\n            const char c = v[len] & 0x7F;       /* ignore top bit for multinational chars */\n            if (!isPRINT(c) && !isSPACE(c))\n                v[len] = '.';\n        }\n    }\n    return v;\n}\n\n\nstatic int\nset_err_char(SV *h, imp_xxh_t *imp_xxh, const char *err_c, IV err_i, const char *errstr, const char *state, const char *method)\n{\n    dTHX;\n    char err_buf[28];\n    SV *err_sv, *errstr_sv, *state_sv, *method_sv;\n    if (!err_c) {\n        sprintf(err_buf, \"%ld\", (long)err_i);\n        err_c = &err_buf[0];\n    }\n    err_sv    = (strEQ(err_c,\"1\")) ? &PL_sv_yes : sv_2mortal(newSVpvn(err_c, strlen(err_c)));\n    errstr_sv = sv_2mortal(newSVpvn(errstr, strlen(errstr)));\n    state_sv  = (state  && *state)  ? sv_2mortal(newSVpvn(state,  strlen(state)))  : &PL_sv_undef;\n    method_sv = (method && *method) ? sv_2mortal(newSVpvn(method, strlen(method))) : &PL_sv_undef;\n    return set_err_sv(h, imp_xxh, err_sv, errstr_sv, state_sv, method_sv);\n}\n\nstatic int\nset_err_sv(SV *h, imp_xxh_t *imp_xxh, SV *err, SV *errstr, SV *state, SV *method)\n{\n    dTHX;\n    SV *h_err;\n    SV *h_errstr;\n    SV *h_state;\n    SV **hook_svp;\n    int err_changed = 0;\n\n    if (    DBIc_has(imp_xxh, DBIcf_HandleSetErr)\n        && (hook_svp = hv_fetch((HV*)SvRV(h),\"HandleSetErr\",12,0))\n        &&  hook_svp\n        &&  ((void)(SvGMAGICAL(*hook_svp) && mg_get(*hook_svp)), SvOK(*hook_svp))\n    ) {\n        dSP;\n        IV items;\n        SV *response_sv;\n        if (SvREADONLY(err))    err    = sv_mortalcopy(err);\n        if (SvREADONLY(errstr)) errstr = sv_mortalcopy(errstr);\n        if (SvREADONLY(state))  state  = sv_mortalcopy(state);\n        if (SvREADONLY(method)) method = sv_mortalcopy(method);\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"    -> HandleSetErr(%s, err=%s, errstr=%s, state=%s, %s)\\n\",\n                neatsvpv(h,0), neatsvpv(err,0), neatsvpv(errstr,0), neatsvpv(state,0),\n                neatsvpv(method,0)\n            );\n        PUSHMARK(SP);\n        XPUSHs(sv_2mortal(newRV_inc((SV*)DBIc_MY_H(imp_xxh))));\n        XPUSHs(err);\n        XPUSHs(errstr);\n        XPUSHs(state);\n        XPUSHs(method);\n        PUTBACK;\n        items = call_sv(*hook_svp, G_SCALAR);\n        SPAGAIN;\n        response_sv = (items) ? POPs : &PL_sv_undef;\n        PUTBACK;\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 1)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"    <- HandleSetErr= %s (err=%s, errstr=%s, state=%s, %s)\\n\",\n                neatsvpv(response_sv,0), neatsvpv(err,0), neatsvpv(errstr,0), neatsvpv(state,0),\n                neatsvpv(method,0)\n            );\n        if (SvTRUE(response_sv))        /* handler says it has handled it, so... */\n            return 0;\n    }\n\n    if (!SvOK(err)) {   /* clear err / errstr / state */\n        DBIh_CLEAR_ERROR(imp_xxh);\n        return 1;\n    }\n\n    /* fetch these after calling HandleSetErr */\n    h_err    = DBIc_ERR(imp_xxh);\n    h_errstr = DBIc_ERRSTR(imp_xxh);\n    h_state  = DBIc_STATE(imp_xxh);\n\n    if (SvTRUE(h_errstr)) {\n        /* append current err, if any, to errstr if it's going to change */\n        if (SvTRUE(h_err) && SvTRUE(err) && strNE(SvPV_nolen(h_err), SvPV_nolen(err)))\n            sv_catpvf(h_errstr, \" [err was %s now %s]\", SvPV_nolen(h_err), SvPV_nolen(err));\n        if (SvTRUE(h_state) && SvTRUE(state) && strNE(SvPV_nolen(h_state), SvPV_nolen(state)))\n            sv_catpvf(h_errstr, \" [state was %s now %s]\", SvPV_nolen(h_state), SvPV_nolen(state));\n        if (strNE(SvPV_nolen(h_errstr), SvPV_nolen(errstr))) {\n            sv_catpvn(h_errstr, \"\\n\", 1);\n            sv_catsv(h_errstr, errstr);\n        }\n    }\n    else\n        sv_setsv(h_errstr, errstr);\n\n    /* SvTRUE(err) > \"0\" > \"\" > undef */\n    if (SvTRUE(err)             /* new error: so assign                 */\n        || !SvOK(h_err) /* no existing warn/info: so assign     */\n           /* new warn (\"0\" len 1) > info (\"\" len 0): so assign         */\n        || (SvOK(err) && strlen(SvPV_nolen(err)) > strlen(SvPV_nolen(h_err)))\n    ) {\n        sv_setsv(h_err, err);\n        err_changed = 1;\n        if (SvTRUE(h_err))      /* new error */\n            ++DBIc_ErrCount(imp_xxh);\n    }\n\n    if (err_changed) {\n        if (SvTRUE(state)) {\n            if (strlen(SvPV_nolen(state)) != 5) {\n                warn(\"set_err: state (%s) is not a 5 character string, using 'S1000' instead\", neatsvpv(state,0));\n                sv_setpv(h_state, \"S1000\");\n            }\n            else\n                sv_setsv(h_state, state);\n        }\n        else\n            (void)SvOK_off(h_state);    /* see DBIc_STATE_adjust */\n    }\n\n    return 1;\n}\n\n\n/* err_hash returns a U32 'hash' value representing the current err 'level'\n * (err/warn/info) and errstr. It's used by the dispatcher as a way to detect\n * a new or changed warning during a 'keep err' method like STORE. Always returns >0.\n * The value is 1 for no err/warn/info and guarantees that err > warn > info.\n * (It's a bit of a hack but the original approach in 70fe6bd76 using a new\n * ErrChangeCount attribute would break binary compatibility with drivers.)\n * The chance that two realistic errstr values would hash the same, even with\n * only 30 bits, is deemed to small to even bother documenting.\n */\nstatic U32\nerr_hash(pTHX_ imp_xxh_t *imp_xxh)\n{\n    SV *err_sv = DBIc_ERR(imp_xxh);\n    SV *errstr_sv;\n    I32 hash = 1;\n    if (SvOK(err_sv)) {\n        errstr_sv = DBIc_ERRSTR(imp_xxh);\n        if (SvOK(errstr_sv))\n             hash = -dbi_hash(SvPV_nolen(errstr_sv), 0); /* make positive */\n        else hash = 0;\n        hash >>= 1; /* free up extra bit (top bit is already free) */\n        hash |= (SvTRUE(err_sv))                  ? 0x80000000 /* err */\n              : (SvPOK(err_sv) && !SvCUR(err_sv)) ? 0x20000000 /* '' = info */\n                                                  : 0x40000000;/* 0 or '0' = warn */\n    }\n    return hash;\n}\n\n\nstatic char *\nmkvname(pTHX_ HV *stash, const char *item, int uplevel) /* construct a variable name    */\n{\n    SV *sv = sv_newmortal();\n    sv_setpv(sv, HvNAME(stash));\n    if(uplevel) {\n        while(SvCUR(sv) && *SvEND(sv)!=':')\n            --SvCUR(sv);\n        if (SvCUR(sv))\n            --SvCUR(sv);\n    }\n    sv_catpv(sv, \"::\");\n    sv_catpv(sv, item);\n    return SvPV_nolen(sv);\n}\n\n/* 32 bit magic FNV-0 and FNV-1 prime */\n#define FNV_32_PRIME ((UV)0x01000193)\n\nstatic I32\ndbi_hash(const char *key, long type)\n{\n    if (type == 0) {\n        STRLEN klen = strlen(key);\n        U32 hash = 0;\n        while (klen--)\n            hash = hash * 33 + *key++;\n        hash &= 0x7FFFFFFF;     /* limit to 31 bits             */\n        hash |= 0x40000000;     /* set bit 31                   */\n        return -(I32)hash;      /* return negative int  */\n    }\n    else if (type == 1) {       /* Fowler/Noll/Vo hash  */\n        /* see http://www.isthe.com/chongo/tech/comp/fnv/ */\n        U32 hash = 0x811c9dc5;\n        const unsigned char *s = (unsigned char *)key;    /* unsigned string */\n        while (*s) {\n            /* multiply by the 32 bit FNV magic prime mod 2^32 */\n            hash *= FNV_32_PRIME;\n            /* xor the bottom with the current octet */\n            hash ^= (U32)*s++;\n        }\n        return hash;\n    }\n    croak(\"DBI::hash(%ld): invalid type\", type);\n    return 0; /* NOT REACHED */\n}\n\n\nstatic int\ndbih_logmsg(imp_xxh_t *imp_xxh, const char *fmt, ...)\n{\n    dTHX;\n    va_list args;\n#ifdef I_STDARG\n    va_start(args, fmt);\n#else\n    va_start(args);\n#endif\n    (void) PerlIO_vprintf(DBIc_DBISTATE(imp_xxh)->logfp, fmt, args);\n    va_end(args);\n    (void)imp_xxh;\n    return 1;\n}\n\nstatic void\nclose_trace_file(pTHX)\n{\n    dMY_CXT;\n    if (DBILOGFP == PerlIO_stderr() || DBILOGFP == PerlIO_stdout())\n        return;\n\n    if (DBIS->logfp_ref == NULL)\n        PerlIO_close(DBILOGFP);\n    else {\n    /* DAA dec refcount and discard */\n        SvREFCNT_dec(DBIS->logfp_ref);\n        DBIS->logfp_ref = NULL;\n    }\n}\n\nstatic int\nset_trace_file(SV *file)\n{\n    dTHX;\n    dMY_CXT;\n    const char *filename;\n    PerlIO *fp = Nullfp;\n    IO *io;\n\n    if (!file)          /* no arg == no change */\n        return 0;\n\n    /* DAA check for a filehandle */\n    if (SvROK(file)) {\n        io = sv_2io(file);\n        if (!io || !(fp = IoOFP(io))) {\n            warn(\"DBI trace filehandle is not valid\");\n            return 0;\n        }\n        close_trace_file(aTHX);\n        (void)SvREFCNT_inc(io);\n        DBIS->logfp_ref = io;\n    }\n    else if (isGV_with_GP(file)) {\n        io = GvIO(file);\n        if (!io || !(fp = IoOFP(io))) {\n            warn(\"DBI trace filehandle from GLOB is not valid\");\n            return 0;\n        }\n        close_trace_file(aTHX);\n        (void)SvREFCNT_inc(io);\n        DBIS->logfp_ref = io;\n    }\n    else {\n        filename = (SvOK(file)) ? SvPV_nolen(file) : Nullch;\n        /* undef arg == reset back to stderr */\n        if (!filename || strEQ(filename,\"STDERR\")\n                      || strEQ(filename,\"*main::STDERR\")) {\n            close_trace_file(aTHX);\n            DBILOGFP = PerlIO_stderr();\n            return 1;\n        }\n        if (strEQ(filename,\"STDOUT\")) {\n            close_trace_file(aTHX);\n            DBILOGFP = PerlIO_stdout();\n            return 1;\n        }\n        fp = PerlIO_open(filename, \"a+\");\n        if (fp == Nullfp) {\n            warn(\"Can't open trace file %s: %s\", filename, Strerror(errno));\n            return 0;\n        }\n        close_trace_file(aTHX);\n    }\n    DBILOGFP = fp;\n    /* if this line causes your compiler or linker to choke     */\n    /* then just comment it out, it's not essential.    */\n    PerlIO_setlinebuf(fp);      /* force line buffered output */\n    return 1;\n}\n\nstatic IV\nparse_trace_flags(SV *h, SV *level_sv, IV old_level)\n{\n    dTHX;\n    IV level;\n    if (!level_sv || !SvOK(level_sv))\n        level = old_level;              /* undef: no change     */\n    else\n    if (SvTRUE(level_sv)) {\n        if (looks_like_number(level_sv))\n            level = SvIV(level_sv);     /* number: number       */\n        else {                          /* string: parse it     */\n            dSP;\n            PUSHMARK(sp);\n            XPUSHs(h);\n            XPUSHs(level_sv);\n            PUTBACK;\n            if (call_method(\"parse_trace_flags\", G_SCALAR) != 1)\n                croak(\"panic: parse_trace_flags\");/* should never happen */\n            SPAGAIN;\n            level = POPi;\n            PUTBACK;\n        }\n    }\n    else                                /* defined but false: 0 */\n        level = 0;\n    return level;\n}\n\n\nstatic int\nset_trace(SV *h, SV *level_sv, SV *file)\n{\n    dTHX;\n    D_imp_xxh(h);\n    int RETVAL = DBIc_DBISTATE(imp_xxh)->debug; /* Return trace level in effect now */\n    IV level = parse_trace_flags(h, level_sv, RETVAL);\n    set_trace_file(file);\n    if (level != RETVAL) { /* set value */\n        if ((level & DBIc_TRACE_LEVEL_MASK) > 0) {\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                \"    %s trace level set to 0x%lx/%ld (DBI @ 0x%lx/%ld) in DBI %s%s (pid %d)\\n\",\n                neatsvpv(h,0),\n                (long)(level & DBIc_TRACE_FLAGS_MASK),\n                (long)(level & DBIc_TRACE_LEVEL_MASK),\n                (long)DBIc_TRACE_FLAGS(imp_xxh), (long)DBIc_TRACE_LEVEL(imp_xxh),\n                XS_VERSION, dbi_build_opt, (int)PerlProc_getpid());\n            if (!PL_dowarn)\n                PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"    Note: perl is running without the recommended perl -w option\\n\");\n            PerlIO_flush(DBIc_LOGPIO(imp_xxh));\n        }\n        sv_setiv(DBIc_DEBUG(imp_xxh), level);\n    }\n    return RETVAL;\n}\n\n\nstatic SV *\ndbih_inner(pTHX_ SV *orv, const char *what)\n{   /* convert outer to inner handle else croak(what) if what is not NULL */\n    /* if what is NULL then return NULL for invalid handles */\n    MAGIC *mg;\n    SV *ohv;            /* outer HV after derefing the RV       */\n    SV *hrv;            /* dbi inner handle RV-to-HV            */\n\n    /* enable a raw HV (not ref-to-HV) to be passed in, eg DBIc_MY_H */\n    ohv = SvROK(orv) ? SvRV(orv) : orv;\n\n    if (!ohv || SvTYPE(ohv) != SVt_PVHV) {\n        if (!what)\n            return NULL;\n        if (1) {\n            dMY_CXT;\n            if (DBIS_TRACE_LEVEL)\n                sv_dump(orv);\n        }\n        if (!SvOK(orv))\n            croak(\"%s given an undefined handle %s\",\n                what, \"(perhaps returned from a previous call which failed)\");\n        croak(\"%s handle %s is not a DBI handle\", what, neatsvpv(orv,0));\n    }\n    if (!SvMAGICAL(ohv)) {\n        if (!what)\n            return NULL;\n        sv_dump(orv);\n        croak(\"%s handle %s is not a DBI handle (has no magic)\",\n                what, neatsvpv(orv,0));\n    }\n\n    if ( (mg=mg_find(ohv,'P')) == NULL) {       /* hash tie magic       */\n        /* not tied, maybe it's already an inner handle... */\n        if (mg_find(ohv, DBI_MAGIC) == NULL) {\n            if (!what)\n                return NULL;\n            sv_dump(orv);\n            croak(\"%s handle %s is not a valid DBI handle\",\n                what, neatsvpv(orv,0));\n        }\n        hrv = orv; /* was already a DBI handle inner hash */\n    }\n    else {\n        hrv = mg->mg_obj;  /* inner hash of tie */\n    }\n\n    return hrv;\n}\n\n\n\n/* -------------------------------------------------------------------- */\n/* Functions to manage a DBI handle (magic and attributes etc).         */\n\nstatic imp_xxh_t *\ndbih_getcom(SV *hrv) /* used by drivers via DBIS func ptr */\n{\n    MAGIC *mg;\n    SV *sv;\n\n    /* short-cut common case */\n    if (   SvROK(hrv)\n        && (sv = SvRV(hrv))\n        && SvRMAGICAL(sv)\n        && (mg = SvMAGIC(sv))\n        && mg->mg_type == DBI_MAGIC\n        && mg->mg_ptr\n    )\n        return (imp_xxh_t *) mg->mg_ptr;\n\n    {\n        dTHX;\n        imp_xxh_t *imp_xxh = dbih_getcom2(aTHX_ hrv, 0);\n        if (!imp_xxh)       /* eg after take_imp_data */\n            croak(\"Invalid DBI handle %s, has no dbi_imp_data\", neatsvpv(hrv,0));\n        return imp_xxh;\n    }\n}\n\nstatic imp_xxh_t *\ndbih_getcom2(pTHX_ SV *hrv, MAGIC **mgp) /* Get com struct for handle. Must be fast.    */\n{\n    MAGIC *mg;\n    SV *sv;\n\n    /* important and quick sanity check (esp non-'safe' Oraperl)        */\n    if (SvROK(hrv))                     /* must at least be a ref */\n        sv = SvRV(hrv);\n    else {\n        dMY_CXT;\n        if (hrv == DBI_LAST_HANDLE)    /* special for var::FETCH */\n            sv = DBI_LAST_HANDLE;\n        else if (sv_derived_from(hrv, \"DBI::common\")) {\n            /* probably a class name, if ref($h)->foo() */\n            return 0;\n        }\n        else {\n            sv_dump(hrv);\n            croak(\"Invalid DBI handle %s\", neatsvpv(hrv,0));\n            sv = &PL_sv_undef; /* avoid \"might be used uninitialized\" warning       */\n        }\n    }\n\n    /* Short cut for common case. We assume that a magic var always     */\n    /* has magic and that DBI_MAGIC, if present, will be the first.     */\n    if (SvRMAGICAL(sv) && (mg=SvMAGIC(sv))->mg_type == DBI_MAGIC) {\n        /* nothing to do here */\n    }\n    else {\n        /* Validate handle (convert outer to inner if required) */\n        hrv = dbih_inner(aTHX_ hrv, \"dbih_getcom\");\n        mg  = mg_find(SvRV(hrv), DBI_MAGIC);\n    }\n    if (mgp)    /* let caller pickup magic struct for this handle */\n        *mgp = mg;\n\n    if (!mg)    /* may happen during global destruction */\n        return (imp_xxh_t *) 0;\n\n    return (imp_xxh_t *) mg->mg_ptr;\n}\n\n\nstatic SV *\ndbih_setup_attrib(pTHX_ SV *h, imp_xxh_t *imp_xxh, char *attrib, SV *parent, int read_only, int optional)\n{\n    STRLEN len = strlen(attrib);\n    SV **asvp;\n\n    asvp = hv_fetch((HV*)SvRV(h), attrib, len, !optional);\n    /* we assume that we won't have any existing 'undef' attributes here */\n    /* (or, alternately, we take undef to mean 'copy from parent')       */\n    if (!(asvp && SvOK(*asvp))) { /* attribute doesn't already exists (the common case) */\n        SV **psvp;\n        if ((!parent || !SvROK(parent)) && !optional) {\n            croak(\"dbih_setup_attrib(%s): %s not set and no parent supplied\",\n                    neatsvpv(h,0), attrib);\n        }\n        psvp = hv_fetch((HV*)SvRV(parent), attrib, len, 0);\n        if (psvp) {\n            if (!asvp)\n                asvp = hv_fetch((HV*)SvRV(h), attrib, len, 1);\n            sv_setsv(*asvp, *psvp); /* copy attribute from parent to handle */\n        }\n        else {\n            if (!optional)\n                croak(\"dbih_setup_attrib(%s): %s not set and not in parent\",\n                    neatsvpv(h,0), attrib);\n        }\n    }\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 5) {\n        PerlIO *logfp = DBIc_LOGPIO(imp_xxh);\n        PerlIO_printf(logfp,\"    dbih_setup_attrib(%s, %s, %s)\",\n            neatsvpv(h,0), attrib, neatsvpv(parent,0));\n        if (!asvp)\n             PerlIO_printf(logfp,\" undef (not defined)\\n\");\n        else\n        if (SvOK(*asvp))\n             PerlIO_printf(logfp,\" %s (already defined)\\n\", neatsvpv(*asvp,0));\n        else PerlIO_printf(logfp,\" %s (copied from parent)\\n\", neatsvpv(*asvp,0));\n    }\n    if (read_only && asvp)\n        SvREADONLY_on(*asvp);\n    return asvp ? *asvp : &PL_sv_undef;\n}\n\n\nstatic SV *\ndbih_make_fdsv(SV *sth, const char *imp_class, STRLEN imp_size, const char *col_name)\n{\n    dTHX;\n    D_imp_sth(sth);\n    const STRLEN cn_len = strlen(col_name);\n    imp_fdh_t *imp_fdh;\n    SV *fdsv;\n    if (imp_size < sizeof(imp_fdh_t) || cn_len<10 || strNE(\"::fd\",&col_name[cn_len-4]))\n        croak(\"panic: dbih_makefdsv %s '%s' imp_size %ld invalid\",\n                imp_class, col_name, (long)imp_size);\n    if (DBIc_TRACE_LEVEL(imp_sth) >= 5)\n        PerlIO_printf(DBIc_LOGPIO(imp_sth),\"    dbih_make_fdsv(%s, %s, %ld, '%s')\\n\",\n                neatsvpv(sth,0), imp_class, (long)imp_size, col_name);\n    fdsv = dbih_make_com(sth, (imp_xxh_t*)imp_sth, imp_class, imp_size, cn_len+2, 0);\n    imp_fdh = (imp_fdh_t*)(void*)SvPVX(fdsv);\n    imp_fdh->com.col_name = ((char*)imp_fdh) + imp_size;\n    strcpy(imp_fdh->com.col_name, col_name);\n    return fdsv;\n}\n\n\nstatic SV *\ndbih_make_com(SV *p_h, imp_xxh_t *p_imp_xxh, const char *imp_class, STRLEN imp_size, STRLEN extra, SV* imp_templ)\n{\n    dTHX;\n    static const char *errmsg = \"Can't make DBI com handle for %s: %s\";\n    HV *imp_stash;\n    SV *dbih_imp_sv;\n    imp_xxh_t *imp;\n    int trace_level;\n    PERL_UNUSED_VAR(extra);\n\n    if ( (imp_stash = gv_stashpv(imp_class, FALSE)) == NULL)\n        croak(errmsg, imp_class, \"unknown package\");\n\n    if (imp_size == 0) {\n        /* get size of structure to allocate for common and imp specific data   */\n        const char *imp_size_name = mkvname(aTHX_ imp_stash, \"imp_data_size\", 0);\n        imp_size = SvIV(get_sv(imp_size_name, 0x05));\n        if (imp_size == 0) {\n            imp_size = sizeof(imp_sth_t);\n            if (sizeof(imp_dbh_t) > imp_size)\n                imp_size = sizeof(imp_dbh_t);\n            if (sizeof(imp_drh_t) > imp_size)\n                imp_size = sizeof(imp_drh_t);\n            imp_size += 4;\n        }\n    }\n\n    if (p_imp_xxh) {\n        trace_level = DBIc_TRACE_LEVEL(p_imp_xxh);\n    }\n    else {\n        dMY_CXT;\n        trace_level = DBIS_TRACE_LEVEL;\n    }\n    if (trace_level >= 5) {\n        dMY_CXT;\n        PerlIO_printf(DBILOGFP,\"    dbih_make_com(%s, %p, %s, %ld, %p) thr#%p\\n\",\n            neatsvpv(p_h,0), (void*)p_imp_xxh, imp_class, (long)imp_size, (void*)imp_templ, (void*)PERL_GET_THX);\n    }\n\n    if (imp_templ && SvOK(imp_templ)) {\n        U32  imp_templ_flags;\n        /* validate the supplied dbi_imp_data looks reasonable, */\n        if (SvCUR(imp_templ) != imp_size)\n            croak(\"Can't use dbi_imp_data of wrong size (%ld not %ld)\",\n                (long)SvCUR(imp_templ), (long)imp_size);\n\n        /* copy the whole template */\n        dbih_imp_sv = newSVsv(imp_templ);\n        imp = (imp_xxh_t*)(void*)SvPVX(dbih_imp_sv);\n\n        /* sanity checks on the supplied imp_data */\n        if (DBIc_TYPE(imp) != ((p_imp_xxh) ? DBIc_TYPE(p_imp_xxh)+1 :1) )\n            croak(\"Can't use dbi_imp_data from different type of handle\");\n        if (!DBIc_has(imp, DBIcf_IMPSET))\n            croak(\"Can't use dbi_imp_data that not from a setup handle\");\n\n        /* copy flags, zero out our imp_xxh struct, restore some flags */\n        imp_templ_flags = DBIc_FLAGS(imp);\n        switch ( (p_imp_xxh) ? DBIc_TYPE(p_imp_xxh)+1 : DBIt_DR ) {\n        case DBIt_DR: memzero((char*)imp, sizeof(imp_drh_t)); break;\n        case DBIt_DB: memzero((char*)imp, sizeof(imp_dbh_t)); break;\n        case DBIt_ST: memzero((char*)imp, sizeof(imp_sth_t)); break;\n        default:      croak(\"dbih_make_com dbi_imp_data bad h type\");\n        }\n        /* Only pass on DBIcf_IMPSET to indicate to driver that the imp */\n        /* structure has been copied and it doesn't need to reconnect.  */\n        /* Similarly DBIcf_ACTIVE is also passed along but isn't key.   */\n        DBIc_FLAGS(imp) = imp_templ_flags & (DBIcf_IMPSET|DBIcf_ACTIVE);\n    }\n    else {\n        dbih_imp_sv = newSV(imp_size); /* is grown to at least imp_size+1 */\n        imp = (imp_xxh_t*)(void*)SvPVX(dbih_imp_sv);\n        memzero((char*)imp, imp_size);\n        /* set up SV with SvCUR set ready for take_imp_data */\n        SvCUR_set(dbih_imp_sv, imp_size);\n        *SvEND(dbih_imp_sv) = '\\0';\n    }\n\n    if (p_imp_xxh) {\n        DBIc_DBISTATE(imp)  = DBIc_DBISTATE(p_imp_xxh);\n    }\n    else {\n        dMY_CXT;\n        DBIc_DBISTATE(imp)  = DBIS;\n    }\n    DBIc_IMP_STASH(imp) = imp_stash;\n\n    if (!p_h) {         /* only a driver (drh) has no parent    */\n        DBIc_PARENT_H(imp)    = &PL_sv_undef;\n        DBIc_PARENT_COM(imp)  = NULL;\n        DBIc_TYPE(imp)        = DBIt_DR;\n        DBIc_on(imp,DBIcf_WARN          /* set only here, children inherit      */\n                   |DBIcf_ACTIVE        /* drivers are 'Active' by default      */\n                   |DBIcf_AutoCommit    /* advisory, driver must manage this    */\n        );\n        DBIc_set(imp, DBIcf_PrintWarn, 1);\n    }\n    else {\n        DBIc_PARENT_H(imp)    = (SV*)SvREFCNT_inc(p_h); /* ensure it lives      */\n        DBIc_PARENT_COM(imp)  = p_imp_xxh;              /* shortcut for speed   */\n        DBIc_TYPE(imp)        = DBIc_TYPE(p_imp_xxh) + 1;\n        /* inherit some flags from parent and carry forward some from template  */\n        DBIc_FLAGS(imp)       = (DBIc_FLAGS(p_imp_xxh) & ~DBIcf_INHERITMASK)\n                              | (DBIc_FLAGS(imp) & (DBIcf_IMPSET|DBIcf_ACTIVE));\n        ++DBIc_KIDS(p_imp_xxh);\n    }\n#ifdef DBI_USE_THREADS\n    DBIc_THR_USER(imp) = PERL_GET_THX ;\n#endif\n\n    if (DBIc_TYPE(imp) == DBIt_ST) {\n        imp_sth_t *imp_sth = (imp_sth_t*)imp;\n        DBIc_ROW_COUNT(imp_sth)  = -1;\n    }\n\n    DBIc_COMSET_on(imp);        /* common data now set up               */\n\n    /* The implementor should DBIc_IMPSET_on(imp) when setting up       */\n    /* any private data which will need clearing/freeing later.         */\n\n    return dbih_imp_sv;\n}\n\n\nstatic void\ndbih_setup_handle(pTHX_ SV *orv, char *imp_class, SV *parent, SV *imp_datasv)\n{\n    SV *h;\n    char *errmsg = \"Can't setup DBI handle of %s to %s: %s\";\n    SV *dbih_imp_sv;\n    SV *dbih_imp_rv;\n    SV *dbi_imp_data = Nullsv;\n    SV **svp;\n    char imp_mem_name[300];\n    HV  *imp_mem_stash;\n    imp_xxh_t *imp;\n    imp_xxh_t *parent_imp;\n    int trace_level;\n\n    h      = dbih_inner(aTHX_ orv, \"dbih_setup_handle\");\n    parent = dbih_inner(aTHX_ parent, NULL);    /* check parent valid (& inner) */\n    if (parent) {\n        parent_imp = DBIh_COM(parent);\n        trace_level = DBIc_TRACE_LEVEL(parent_imp);\n    }\n    else {\n        dMY_CXT;\n        parent_imp = NULL;\n        trace_level = DBIS_TRACE_LEVEL;\n    }\n\n    if (trace_level >= 5) {\n        dMY_CXT;\n        PerlIO_printf(DBILOGFP,\"    dbih_setup_handle(%s=>%s, %s, %lx, %s)\\n\",\n            neatsvpv(orv,0), neatsvpv(h,0), imp_class, (long)parent, neatsvpv(imp_datasv,0));\n    }\n\n    if (mg_find(SvRV(h), DBI_MAGIC) != NULL)\n        croak(errmsg, neatsvpv(orv,0), imp_class, \"already a DBI (or ~magic) handle\");\n\n    strcpy(imp_mem_name, imp_class);\n    strcat(imp_mem_name, \"_mem\");\n    if ( (imp_mem_stash = gv_stashpv(imp_mem_name, FALSE)) == NULL)\n        croak(errmsg, neatsvpv(orv,0), imp_mem_name, \"unknown _mem package\");\n\n    if ((svp = hv_fetch((HV*)SvRV(h), \"dbi_imp_data\", 12, 0))) {\n        dbi_imp_data = *svp;\n        if (SvGMAGICAL(dbi_imp_data))  /* call FETCH via magic */\n            mg_get(dbi_imp_data);\n    }\n\n    DBI_LOCK;\n\n    dbih_imp_sv = dbih_make_com(parent, parent_imp, imp_class, 0, 0, dbi_imp_data);\n    imp = (imp_xxh_t*)(void*)SvPVX(dbih_imp_sv);\n\n    dbih_imp_rv = newRV_inc(dbih_imp_sv);       /* just needed for sv_bless */\n    sv_bless(dbih_imp_rv, imp_mem_stash);\n    sv_free(dbih_imp_rv);\n\n    DBIc_MY_H(imp) = (HV*)SvRV(orv);    /* take _copy_ of pointer, not new ref  */\n    DBIc_IMP_DATA(imp) = (imp_datasv) ? newSVsv(imp_datasv) : &PL_sv_undef;\n    _imp2com(imp, std.pid) = (U32)PerlProc_getpid();\n\n    if (DBIc_TYPE(imp) <= DBIt_ST) {\n        SV **tmp_svp;\n        /* Copy some attributes from parent if not defined locally and  */\n        /* also take address of attributes for speed of direct access.  */\n        /* parent is null for drh, in which case h must hold the values */\n#define COPY_PARENT(name,ro,opt) SvREFCNT_inc(dbih_setup_attrib(aTHX_ h,imp,(name),parent,ro,opt))\n#define DBIc_ATTR(imp, f) _imp2com(imp, attr.f)\n        /* XXX we should validate that these are the right type (refs etc)      */\n        DBIc_ATTR(imp, Err)      = COPY_PARENT(\"Err\",1,0);      /* scalar ref   */\n        DBIc_ATTR(imp, State)    = COPY_PARENT(\"State\",1,0);    /* scalar ref   */\n        DBIc_ATTR(imp, Errstr)   = COPY_PARENT(\"Errstr\",1,0);   /* scalar ref   */\n        DBIc_ATTR(imp, TraceLevel)=COPY_PARENT(\"TraceLevel\",0,0);/* scalar (int)*/\n        DBIc_ATTR(imp, FetchHashKeyName) = COPY_PARENT(\"FetchHashKeyName\",0,0); /* scalar ref */\n\n        if (parent) {\n            dbih_setup_attrib(aTHX_ h,imp,\"HandleSetErr\",parent,0,1);\n            dbih_setup_attrib(aTHX_ h,imp,\"HandleError\",parent,0,1);\n            dbih_setup_attrib(aTHX_ h,imp,\"ReadOnly\",parent,0,1);\n            dbih_setup_attrib(aTHX_ h,imp,\"Profile\",parent,0,1);\n\n            /* setup Callbacks from parents' ChildCallbacks */\n            if (DBIc_has(parent_imp, DBIcf_Callbacks)\n            && (tmp_svp = hv_fetch((HV*)SvRV(parent), \"Callbacks\", 9, 0))\n            && SvROK(*tmp_svp) && SvTYPE(SvRV(*tmp_svp)) == SVt_PVHV\n            && (tmp_svp = hv_fetch((HV*)SvRV(*tmp_svp), \"ChildCallbacks\", 14, 0))\n            && SvROK(*tmp_svp) && SvTYPE(SvRV(*tmp_svp)) == SVt_PVHV\n            ) {\n                /* XXX mirrors behaviour of dbih_set_attr_k() of Callbacks */\n                (void)hv_store((HV*)SvRV(h), \"Callbacks\", 9, newRV_inc(SvRV(*tmp_svp)), 0);\n                DBIc_set(imp, DBIcf_Callbacks, 1);\n            }\n\n            DBIc_LongReadLen(imp) = DBIc_LongReadLen(parent_imp);\n#ifdef sv_rvweaken\n            if (1) {\n                AV *av;\n                /* add weakref to new (outer) handle into parents ChildHandles array */\n                tmp_svp = hv_fetch((HV*)SvRV(parent), \"ChildHandles\", 12, 1);\n                if (!SvROK(*tmp_svp)) {\n                    SV *ChildHandles_rvav = newRV_noinc((SV*)newAV());\n                    sv_setsv(*tmp_svp, ChildHandles_rvav);\n                    sv_free(ChildHandles_rvav);\n                }\n                av = (AV*)SvRV(*tmp_svp);\n                av_push(av, (SV*)sv_rvweaken(newRV_inc((SV*)SvRV(orv))));\n                if (av_len(av) % 120 == 0) {\n                    /* time to do some housekeeping to remove dead handles */\n                    I32 i = av_len(av); /* 0 = 1 element */\n                    while (i-- >= 0) {\n                        SV *sv = av_shift(av);\n                        if (SvOK(sv))\n                            av_push(av, sv);\n                        else\n                           sv_free(sv);         /* keep it leak-free by Doru Petrescu pdoru.dbi@from.ro */\n                    }\n                }\n            }\n#endif\n        }\n        else {\n            DBIc_LongReadLen(imp) = DBIc_LongReadLen_init;\n        }\n\n        switch (DBIc_TYPE(imp)) {\n        case DBIt_DB:\n            /* cache _inner_ handle, but also see quick_FETCH */\n            (void)hv_store((HV*)SvRV(h), \"Driver\", 6, newRV_inc(SvRV(parent)), 0);\n            (void)hv_fetch((HV*)SvRV(h), \"Statement\", 9, 1); /* store writable undef */\n            break;\n        case DBIt_ST:\n            DBIc_NUM_FIELDS((imp_sth_t*)imp) = -1;\n            /* cache _inner_ handle, but also see quick_FETCH */\n            (void)hv_store((HV*)SvRV(h), \"Database\", 8, newRV_inc(SvRV(parent)), 0);\n            /* copy (alias) Statement from the sth up into the dbh      */\n            tmp_svp = hv_fetch((HV*)SvRV(h), \"Statement\", 9, 1);\n            (void)hv_store((HV*)SvRV(parent), \"Statement\", 9, SvREFCNT_inc(*tmp_svp), 0);\n            break;\n        }\n    }\n    else \n        die(\"panic: invalid DBIc_TYPE\");\n\n    /* Use DBI magic on inner handle to carry handle attributes         */\n    /* Note that we store the imp_sv in mg_obj, but as a shortcut,      */\n    /* also store a direct pointer to imp, aka PVX(dbih_imp_sv),        */\n    /* in mg_ptr (with mg_len set to null, so it wont be freed)         */\n    sv_magic(SvRV(h), dbih_imp_sv, DBI_MAGIC, (char*)imp, 0);\n    SvREFCNT_dec(dbih_imp_sv);  /* since sv_magic() incremented it      */\n    SvRMAGICAL_on(SvRV(h));     /* so DBI magic gets sv_clear'd ok      */\n\n    {\n    dMY_CXT; /* XXX would be nice to get rid of this */\n    DBI_SET_LAST_HANDLE(h);\n    }\n\n    if (1) {\n        /* This is a hack to work-around the fast but poor way old versions of\n         * DBD::Oracle (and possibly other drivers) check for a valid handle\n         * using (SvMAGIC(SvRV(h)))->mg_type == 'P'). That doesn't work now\n         * because the weakref magic is inserted ahead of the tie magic.\n         * So here we swap the tie and weakref magic so the tie comes first.\n         */\n        MAGIC *tie_mg = mg_find(SvRV(orv),'P');\n        MAGIC *first  = SvMAGIC(SvRV(orv));\n        if (tie_mg && first->mg_moremagic == tie_mg && !tie_mg->mg_moremagic) {\n            MAGIC *next = tie_mg->mg_moremagic;\n            SvMAGIC(SvRV(orv)) = tie_mg;\n            tie_mg->mg_moremagic = first;\n            first->mg_moremagic = next;\n        }\n    }\n\n    DBI_UNLOCK;\n}\n\n\nstatic void\ndbih_dumphandle(pTHX_ SV *h, const char *msg, int level)\n{\n    D_imp_xxh(h);\n    if (level >= 9) {\n        sv_dump(h);\n    }\n    dbih_dumpcom(aTHX_ imp_xxh, msg, level);\n}\n\nstatic int\ndbih_dumpcom(pTHX_ imp_xxh_t *imp_xxh, const char *msg, int level)\n{\n    dMY_CXT;\n    SV *flags = sv_2mortal(newSVpv(\"\",0));\n    SV *inner;\n    static const char pad[] = \"      \";\n    if (!msg)\n        msg = \"dbih_dumpcom\";\n    PerlIO_printf(DBILOGFP,\"    %s (%sh 0x%lx, com 0x%lx, imp %s):\\n\",\n        msg, dbih_htype_name(DBIc_TYPE(imp_xxh)),\n        (long)DBIc_MY_H(imp_xxh), (long)imp_xxh,\n        (PL_dirty) ? \"global destruction\" : HvNAME(DBIc_IMP_STASH(imp_xxh)));\n    if (DBIc_COMSET(imp_xxh))                   sv_catpv(flags,\"COMSET \");\n    if (DBIc_IMPSET(imp_xxh))                   sv_catpv(flags,\"IMPSET \");\n    if (DBIc_ACTIVE(imp_xxh))                   sv_catpv(flags,\"Active \");\n    if (DBIc_WARN(imp_xxh))                     sv_catpv(flags,\"Warn \");\n    if (DBIc_COMPAT(imp_xxh))                   sv_catpv(flags,\"CompatMode \");\n    if (DBIc_is(imp_xxh, DBIcf_ChopBlanks))     sv_catpv(flags,\"ChopBlanks \");\n    if (DBIc_is(imp_xxh, DBIcf_HandleSetErr))   sv_catpv(flags,\"HandleSetErr \");\n    if (DBIc_is(imp_xxh, DBIcf_HandleError))    sv_catpv(flags,\"HandleError \");\n    if (DBIc_is(imp_xxh, DBIcf_RaiseError))     sv_catpv(flags,\"RaiseError \");\n    if (DBIc_is(imp_xxh, DBIcf_PrintError))     sv_catpv(flags,\"PrintError \");\n    if (DBIc_is(imp_xxh, DBIcf_PrintWarn))      sv_catpv(flags,\"PrintWarn \");\n    if (DBIc_is(imp_xxh, DBIcf_ShowErrorStatement))     sv_catpv(flags,\"ShowErrorStatement \");\n    if (DBIc_is(imp_xxh, DBIcf_AutoCommit))     sv_catpv(flags,\"AutoCommit \");\n    if (DBIc_is(imp_xxh, DBIcf_BegunWork))      sv_catpv(flags,\"BegunWork \");\n    if (DBIc_is(imp_xxh, DBIcf_LongTruncOk))    sv_catpv(flags,\"LongTruncOk \");\n    if (DBIc_is(imp_xxh, DBIcf_MultiThread))    sv_catpv(flags,\"MultiThread \");\n    if (DBIc_is(imp_xxh, DBIcf_TaintIn))        sv_catpv(flags,\"TaintIn \");\n    if (DBIc_is(imp_xxh, DBIcf_TaintOut))       sv_catpv(flags,\"TaintOut \");\n    if (DBIc_is(imp_xxh, DBIcf_Profile))        sv_catpv(flags,\"Profile \");\n    if (DBIc_is(imp_xxh, DBIcf_Callbacks))      sv_catpv(flags,\"Callbacks \");\n    PerlIO_printf(DBILOGFP,\"%s FLAGS 0x%lx: %s\\n\", pad, (long)DBIc_FLAGS(imp_xxh), SvPV_nolen(flags));\n    if (SvOK(DBIc_ERR(imp_xxh)))\n        PerlIO_printf(DBILOGFP,\"%s ERR %s\\n\",   pad, neatsvpv((SV*)DBIc_ERR(imp_xxh),0));\n    if (SvOK(DBIc_ERR(imp_xxh)))\n        PerlIO_printf(DBILOGFP,\"%s ERRSTR %s\\n\",        pad, neatsvpv((SV*)DBIc_ERRSTR(imp_xxh),0));\n    PerlIO_printf(DBILOGFP,\"%s PARENT %s\\n\",    pad, neatsvpv((SV*)DBIc_PARENT_H(imp_xxh),0));\n    PerlIO_printf(DBILOGFP,\"%s KIDS %ld (%ld Active)\\n\", pad,\n                    (long)DBIc_KIDS(imp_xxh), (long)DBIc_ACTIVE_KIDS(imp_xxh));\n    if (DBIc_IMP_DATA(imp_xxh) && SvOK(DBIc_IMP_DATA(imp_xxh)))\n        PerlIO_printf(DBILOGFP,\"%s IMP_DATA %s\\n\", pad, neatsvpv(DBIc_IMP_DATA(imp_xxh),0));\n    if (DBIc_LongReadLen(imp_xxh) != DBIc_LongReadLen_init)\n        PerlIO_printf(DBILOGFP,\"%s LongReadLen %ld\\n\", pad, (long)DBIc_LongReadLen(imp_xxh));\n\n    if (DBIc_TYPE(imp_xxh) == DBIt_ST) {\n        const imp_sth_t *imp_sth = (imp_sth_t*)imp_xxh;\n        PerlIO_printf(DBILOGFP,\"%s NUM_OF_FIELDS %d\\n\", pad, DBIc_NUM_FIELDS(imp_sth));\n        PerlIO_printf(DBILOGFP,\"%s NUM_OF_PARAMS %d\\n\", pad, DBIc_NUM_PARAMS(imp_sth));\n    }\n    inner = dbih_inner(aTHX_ (SV*)DBIc_MY_H(imp_xxh), msg);\n    if (!inner || !SvROK(inner))\n        return 1;\n    if (DBIc_TYPE(imp_xxh) <= DBIt_DB) {\n        SV **svp = hv_fetch((HV*)SvRV(inner), \"CachedKids\", 10, 0);\n        if (svp && SvROK(*svp) && SvTYPE(SvRV(*svp)) == SVt_PVHV) {\n            HV *hv = (HV*)SvRV(*svp);\n            PerlIO_printf(DBILOGFP,\"%s CachedKids %d\\n\", pad, (int)HvKEYS(hv));\n        }\n    }\n    if (level > 0) {\n        SV* value;\n        char *key;\n        I32   keylen;\n        PerlIO_printf(DBILOGFP,\"%s cached attributes:\\n\", pad);\n        while ( (value = hv_iternextsv((HV*)SvRV(inner), &key, &keylen)) ) {\n            PerlIO_printf(DBILOGFP,\"%s   '%s' => %s\\n\", pad, key, neatsvpv(value,0));\n        }\n    }\n    else if (DBIc_TYPE(imp_xxh) == DBIt_DB) {\n        SV **svp = hv_fetch((HV*)SvRV(inner), \"Name\", 4, 0);\n        if (svp && SvOK(*svp))\n            PerlIO_printf(DBILOGFP,\"%s Name %s\\n\", pad, neatsvpv(*svp,0));\n    }\n    else if (DBIc_TYPE(imp_xxh) == DBIt_ST) {\n        SV **svp = hv_fetch((HV*)SvRV(inner), \"Statement\", 9, 0);\n        if (svp && SvOK(*svp))\n            PerlIO_printf(DBILOGFP,\"%s Statement %s\\n\", pad, neatsvpv(*svp,0));\n    }\n    return 1;\n}\n\n\nstatic void\ndbih_clearcom(imp_xxh_t *imp_xxh)\n{\n    dTHX;\n    dTHR;\n    int dump = FALSE;\n    int debug = DBIc_TRACE_LEVEL(imp_xxh);\n    int auto_dump = (debug >= 6);\n    imp_xxh_t * const parent_xxh = DBIc_PARENT_COM(imp_xxh);\n    /* Note that we're very much on our own here. DBIc_MY_H(imp_xxh) almost     */\n    /* certainly points to memory which has been freed. Don't use it!           */\n\n    /* --- pre-clearing sanity checks --- */\n\n#ifdef DBI_USE_THREADS\n    if (DBIc_THR_USER(imp_xxh) != my_perl) { /* don't clear handle that belongs to another thread */\n        if (debug >= 3) {\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"    skipped dbih_clearcom: DBI handle (type=%d, %s) is owned by thread %p not current thread %p\\n\",\n                  DBIc_TYPE(imp_xxh), HvNAME(DBIc_IMP_STASH(imp_xxh)), (void*)DBIc_THR_USER(imp_xxh), (void*)my_perl) ;\n            PerlIO_flush(DBIc_LOGPIO(imp_xxh));\n        }\n        return;\n    }\n#endif\n\n    if (!DBIc_COMSET(imp_xxh)) {        /* should never happen  */\n        dbih_dumpcom(aTHX_ imp_xxh, \"dbih_clearcom: DBI handle already cleared\", 0);\n        return;\n    }\n\n    if (auto_dump)\n        dbih_dumpcom(aTHX_ imp_xxh,\"DESTROY (dbih_clearcom)\", 0);\n\n    if (!PL_dirty) {\n\n        if (DBIc_ACTIVE(imp_xxh)) {     /* bad news, potentially        */\n            /* warn for sth, warn for dbh only if it has active sth or isn't AutoCommit */\n            if (DBIc_TYPE(imp_xxh) >= DBIt_ST\n            || (DBIc_ACTIVE_KIDS(imp_xxh) || !DBIc_has(imp_xxh, DBIcf_AutoCommit))\n            ) {\n                warn(\"DBI %s handle 0x%lx cleared whilst still active\",\n                        dbih_htype_name(DBIc_TYPE(imp_xxh)), (unsigned long)DBIc_MY_H(imp_xxh));\n                dump = TRUE;\n            }\n        }\n\n        /* check that the implementor has done its own housekeeping     */\n        if (DBIc_IMPSET(imp_xxh)) {\n            warn(\"DBI %s handle 0x%lx has uncleared implementors data\",\n                    dbih_htype_name(DBIc_TYPE(imp_xxh)), (unsigned long)DBIc_MY_H(imp_xxh));\n            dump = TRUE;\n        }\n\n        if (DBIc_KIDS(imp_xxh)) {\n            warn(\"DBI %s handle 0x%lx has %d uncleared child handles\",\n                    dbih_htype_name(DBIc_TYPE(imp_xxh)),\n                    (unsigned long)DBIc_MY_H(imp_xxh), (int)DBIc_KIDS(imp_xxh));\n            dump = TRUE;\n        }\n    }\n\n    if (dump && !auto_dump) /* else was already dumped above */\n        dbih_dumpcom(aTHX_ imp_xxh, \"dbih_clearcom\", 0);\n\n    /* --- pre-clearing adjustments --- */\n\n    if (!PL_dirty) {\n        if (parent_xxh) {\n            if (DBIc_ACTIVE(imp_xxh)) /* see also DBIc_ACTIVE_off */\n                --DBIc_ACTIVE_KIDS(parent_xxh);\n            --DBIc_KIDS(parent_xxh);\n        }\n    }\n\n    /* --- clear fields (may invoke object destructors) ---     */\n\n    if (DBIc_TYPE(imp_xxh) == DBIt_ST) {\n        imp_sth_t *imp_sth = (imp_sth_t*)imp_xxh;\n        sv_free((SV*)DBIc_FIELDS_AV(imp_sth));\n    }\n\n    sv_free(DBIc_IMP_DATA(imp_xxh));    /* do this first        */\n    if (DBIc_TYPE(imp_xxh) <= DBIt_ST) {        /* DBIt_FD doesn't have attr */\n        sv_free(_imp2com(imp_xxh, attr.TraceLevel));\n        sv_free(_imp2com(imp_xxh, attr.State));\n        sv_free(_imp2com(imp_xxh, attr.Err));\n        sv_free(_imp2com(imp_xxh, attr.Errstr));\n        sv_free(_imp2com(imp_xxh, attr.FetchHashKeyName));\n    }\n\n\n    sv_free((SV*)DBIc_PARENT_H(imp_xxh));       /* do this last         */\n\n    DBIc_COMSET_off(imp_xxh);\n\n    if (debug >= 4)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"    dbih_clearcom 0x%lx (com 0x%lx, type %d) done.\\n\\n\",\n                (long)DBIc_MY_H(imp_xxh), (long)imp_xxh, DBIc_TYPE(imp_xxh));\n}\n\n\n/* --- Functions for handling field buffer arrays ---           */\n\nstatic AV *\ndbih_setup_fbav(imp_sth_t *imp_sth)\n{\n    /*  Usually called to setup the row buffer for new sth.\n     *  Also called if the value of NUM_OF_FIELDS is altered,\n     *  in which case it adjusts the row buffer to match NUM_OF_FIELDS.\n     */\n    dTHX;\n    I32 i = DBIc_NUM_FIELDS(imp_sth);\n    AV *av = DBIc_FIELDS_AV(imp_sth);\n\n    if (i < 0)\n        i = 0;\n\n    if (av) {\n        if (av_len(av)+1 == i)  /* is existing array the right size? */\n            return av;\n        /* we need to adjust the size of the array */\n        if (DBIc_TRACE_LEVEL(imp_sth) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_sth),\"    dbih_setup_fbav realloc from %ld to %ld fields\\n\", (long)(av_len(av)+1), (long)i);\n        SvREADONLY_off(av);\n        if (i < av_len(av)+1) /* trim to size if too big */\n            av_fill(av, i-1);\n    }\n    else {\n        if (DBIc_TRACE_LEVEL(imp_sth) >= 5)\n            PerlIO_printf(DBIc_LOGPIO(imp_sth),\"    dbih_setup_fbav alloc for %ld fields\\n\", (long)i);\n        av = newAV();\n        DBIc_FIELDS_AV(imp_sth) = av;\n\n        /* row_count will need to be manually reset by the driver if the        */\n        /* sth is re-executed (since this code won't get rerun)         */\n        DBIc_ROW_COUNT(imp_sth) = 0;\n    }\n\n    /* load array with writeable SV's. Do this backwards so     */\n    /* the array only gets extended once.                       */\n    while(i--)                  /* field 1 stored at index 0    */\n        av_store(av, i, newSV(0));\n    if (DBIc_TRACE_LEVEL(imp_sth) >= 6)\n        PerlIO_printf(DBIc_LOGPIO(imp_sth),\"    dbih_setup_fbav now %ld fields\\n\", (long)(av_len(av)+1));\n    SvREADONLY_on(av);          /* protect against shift @$row etc */\n    return av;\n}\n\n\nstatic AV *\ndbih_get_fbav(imp_sth_t *imp_sth)\n{\n    AV *av;\n\n    if ( (av = DBIc_FIELDS_AV(imp_sth)) == Nullav) {\n        av = dbih_setup_fbav(imp_sth);\n    }\n    else {\n        dTHX;\n        int i = av_len(av) + 1;\n        if (i != DBIc_NUM_FIELDS(imp_sth)) {\n            /*SV *sth = dbih_inner(aTHX_ (SV*)DBIc_MY_H(imp_sth), \"_get_fbav\");*/\n            /* warn via PrintWarn */\n            set_err_char(SvRV(DBIc_MY_H(imp_sth)), (imp_xxh_t*)imp_sth,\n                    \"0\", 0, \"Number of row fields inconsistent with NUM_OF_FIELDS (driver bug)\", \"\", \"_get_fbav\");\n            /*\n            DBIc_NUM_FIELDS(imp_sth) = i;\n            hv_delete((HV*)SvRV(sth), \"NUM_OF_FIELDS\", 13, G_DISCARD);\n            */\n        }\n        /* don't let SvUTF8 flag persist from one row to the next   */\n        /* (only affects drivers that use sv_setpv, but most XS do) */\n        /* XXX turn into option later (force on/force off/ignore) */\n        while(i--)                  /* field 1 stored at index 0    */\n            SvUTF8_off(AvARRAY(av)[i]);\n    }\n\n    if (DBIc_is(imp_sth, DBIcf_TaintOut)) {\n        dTHX;\n        dTHR;\n        TAINT;  /* affects sv_setsv()'s called within same perl statement */\n    }\n\n    /* XXX fancy stuff to happen here later (re scrolling etc)  */\n    ++DBIc_ROW_COUNT(imp_sth);\n    return av;\n}\n\n\nstatic int\ndbih_sth_bind_col(SV *sth, SV *col, SV *ref, SV *attribs)\n{\n    dTHX;\n    D_imp_sth(sth);\n    AV *av;\n    int idx = SvIV(col);\n    int fields = DBIc_NUM_FIELDS(imp_sth);\n\n    if (fields <= 0) {\n        PERL_UNUSED_VAR(attribs);\n        croak(\"Statement has no result columns to bind%s\",\n            DBIc_ACTIVE(imp_sth)\n                ? \"\" : \" (perhaps you need to successfully call execute first, or again)\");\n    }\n\n    if ( (av = DBIc_FIELDS_AV(imp_sth)) == Nullav)\n        av = dbih_setup_fbav(imp_sth);\n\n    if (DBIc_TRACE_LEVEL(imp_sth) >= 5)\n        PerlIO_printf(DBIc_LOGPIO(imp_sth),\"    dbih_sth_bind_col %s => %s %s\\n\",\n                neatsvpv(col,0), neatsvpv(ref,0), neatsvpv(attribs,0));\n\n    if (idx < 1 || idx > fields)\n        croak(\"bind_col: column %d is not a valid column (1..%d)\",\n                        idx, fields);\n\n    if (!SvOK(ref) && SvREADONLY(ref)) {   /* binding to literal undef */\n        /* presumably the call is just setting the TYPE or other atribs */\n        /* but this default method ignores attribs, so we just return   */\n        return 1;\n    }\n\n    /* Write this as > SVt_PVMG because in 5.8.x the next type */\n    /* is SVt_PVBM, whereas in 5.9.x it's SVt_PVGV.            */\n    if (!SvROK(ref) || SvTYPE(SvRV(ref)) > SVt_PVMG) /* XXX LV */\n        croak(\"Can't %s->bind_col(%s, %s,...), need a reference to a scalar\",\n                neatsvpv(sth,0), neatsvpv(col,0), neatsvpv(ref,0));\n\n    /* use supplied scalar as storage for this column */\n    SvREADONLY_off(av);\n    av_store(av, idx-1, SvREFCNT_inc(SvRV(ref)) );\n    SvREADONLY_on(av);\n    return 1;\n}\n\n\nstatic int\nquote_type(int sql_type, int p, int s, int *t, void *v)\n{\n    /* Returns true if type should be bound as a number else    */\n    /* false implying that binding as a string should be okay.  */\n    /* The true value is either SQL_INTEGER or SQL_DOUBLE which */\n    /* can be used as a hint if desired.                        */\n    (void)p;\n    (void)s;\n    (void)t;\n    (void)v;\n    /* looks like it's never been used, and doesn't make much sense anyway */\n    warn(\"Use of DBI internal bind_as_num/quote_type function is deprecated\");\n    switch(sql_type) {\n    case SQL_INTEGER:\n    case SQL_SMALLINT:\n    case SQL_TINYINT:\n    case SQL_BIGINT:\n        return 0;\n    case SQL_FLOAT:\n    case SQL_REAL:\n    case SQL_DOUBLE:\n        return 0;\n    case SQL_NUMERIC:\n    case SQL_DECIMAL:\n        return 0;       /* bind as string to attempt to retain precision */\n    }\n    return 1;\n}\n\n\n/* Convert a simple string representation of a value into a more specific\n * perl type based on an sql_type value.\n * The semantics of SQL standard TYPE values are interpreted _very_ loosely\n * on the basis of \"be liberal in what you accept and let's throw in some\n * extra semantics while we're here\" :)\n * Returns:\n *  -2: sql_type isn't handled, value unchanged\n *  -1: sv is undef, value unchanged\n *   0: sv couldn't be cast cleanly and DBIstcf_STRICT was used\n *   1: sv couldn't be cast cleanly and DBIstcf_STRICT was not used\n *   2: sv was cast ok\n */\n\nint\nsql_type_cast_svpv(pTHX_ SV *sv, int sql_type, U32 flags, void *v)\n{\n    int cast_ok = 0;\n    int grok_flags;\n    UV uv;\n\n    /* do nothing for undef (NULL) or non-string values */\n    if (!sv || !SvOK(sv))\n        return -1;\n\n    switch(sql_type) {\n\n    default:\n        return -2;   /* not a recognised SQL TYPE, value unchanged */\n\n    case SQL_INTEGER:\n        /* sv_2iv is liberal, may return SvIV, SvUV, or SvNV */\n        sv_2iv(sv);\n        /* SvNOK will be set if value is out of range for IV/UV.\n         * SvIOK should be set but won't if sv is not numeric (in which\n         * case perl would have warn'd already if -w or warnings are in effect)\n         */\n        cast_ok = (SvIOK(sv) && !SvNOK(sv));\n        break;\n\n    case SQL_DOUBLE:\n        sv_2nv(sv);\n        /* SvNOK should be set but won't if sv is not numeric (in which\n         * case perl would have warn'd already if -w or warnings are in effect)\n         */\n        cast_ok = SvNOK(sv);\n        break;\n\n    /* caller would like IV else UV else NV */\n    /* else no error and sv is untouched */\n    case SQL_NUMERIC:\n        /* based on the code in perl's toke.c */\n        uv = 0;\n        grok_flags = grok_number(SvPVX(sv), SvCUR(sv), &uv);\n        cast_ok = 1;\n        if (grok_flags == IS_NUMBER_IN_UV) { /* +ve int */\n            if (uv <= IV_MAX)   /* prefer IV over UV */\n                 sv_2iv(sv);\n            else sv_2uv(sv);\n        }\n        else if (grok_flags == (IS_NUMBER_IN_UV | IS_NUMBER_NEG)\n            && uv <= IV_MAX\n        ) {\n            sv_2iv(sv);\n        }\n        else if (grok_flags) { /* is numeric */\n            sv_2nv(sv);\n        }\n        else\n            cast_ok = 0;\n        break;\n\n#if 0 /* XXX future possibilities */\n    case SQL_BIGINT:    /* use Math::BigInt if too large for IV/UV */\n#endif\n    }\n\n    if (cast_ok) {\n\n        if (flags & DBIstcf_DISCARD_STRING\n        && SvNIOK(sv)  /* we set a numeric value */\n        && SvPVX(sv)   /* we have a buffer to discard */\n        ) {\n            SvOOK_off(sv);\n            sv_force_normal(sv);\n            if (SvLEN(sv))\n                Safefree(SvPVX(sv));\n            SvPOK_off(sv);\n            SvPV_set(sv, NULL);\n            SvLEN_set(sv, 0);\n            SvCUR_set(sv, 0);\n        }\n    }\n\n    if (cast_ok)\n        return 2;\n    else if (flags & DBIstcf_STRICT)\n        return 0;\n    else return 1;\n}\n\n\n\n/* --- Generic Handle Attributes (for all handle types) ---     */\n\nstatic int\ndbih_set_attr_k(SV *h, SV *keysv, int dbikey, SV *valuesv)\n{\n    dTHX;\n    dTHR;\n    D_imp_xxh(h);\n    STRLEN keylen;\n    const char  *key = SvPV(keysv, keylen);\n    const int    htype = DBIc_TYPE(imp_xxh);\n    int    on = (SvTRUE(valuesv));\n    int    internal = 1; /* DBIh_IN_PERL_DBD(imp_xxh); -- for DBD's in perl */\n    int    cacheit = 0;\n    (void)dbikey;\n\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 3)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"    STORE %s %s => %s\\n\",\n                neatsvpv(h,0), neatsvpv(keysv,0), neatsvpv(valuesv,0));\n\n    if (internal && strEQ(key, \"Active\")) {\n        if (on) {\n            D_imp_sth(h);\n            DBIc_ACTIVE_on(imp_xxh);\n            /* for pure-perl drivers on second and subsequent   */\n            /* execute()'s, else row count keeps rising.        */\n            if (htype==DBIt_ST && DBIc_FIELDS_AV(imp_sth))\n                DBIc_ROW_COUNT(imp_sth) = 0;\n        }\n        else {\n            DBIc_ACTIVE_off(imp_xxh);\n        }\n    }\n    else if (strEQ(key, \"FetchHashKeyName\")) {\n        if (htype >= DBIt_ST)\n            croak(\"Can't set FetchHashKeyName for a statement handle, set in parent before prepare()\");\n        cacheit = 1;    /* just save it */\n    }\n    else if (strEQ(key, \"CompatMode\")) {\n        (on) ? DBIc_COMPAT_on(imp_xxh) : DBIc_COMPAT_off(imp_xxh);\n    }\n    else if (strEQ(key, \"Warn\")) {\n        (on) ? DBIc_WARN_on(imp_xxh) : DBIc_WARN_off(imp_xxh);\n    }\n    else if (strEQ(key, \"AutoInactiveDestroy\")) {\n        (on) ? DBIc_AIADESTROY_on(imp_xxh) : DBIc_AIADESTROY_off(imp_xxh);\n    }\n    else if (strEQ(key, \"InactiveDestroy\")) {\n        (on) ? DBIc_IADESTROY_on(imp_xxh) : DBIc_IADESTROY_off(imp_xxh);\n    }\n    else if (strEQ(key, \"RootClass\")) {\n        cacheit = 1;    /* just save it */\n    }\n    else if (strEQ(key, \"RowCacheSize\")) {\n        cacheit = 0;    /* ignore it */\n    }\n    else if (strEQ(key, \"Executed\")) {\n        DBIc_set(imp_xxh, DBIcf_Executed, on);\n    }\n    else if (strEQ(key, \"ChopBlanks\")) {\n        DBIc_set(imp_xxh, DBIcf_ChopBlanks, on);\n    }\n    else if (strEQ(key, \"ErrCount\")) {\n        DBIc_ErrCount(imp_xxh) = SvUV(valuesv);\n    }\n    else if (strEQ(key, \"LongReadLen\")) {\n        if (SvNV(valuesv) < 0 || SvNV(valuesv) > MAX_LongReadLen)\n            croak(\"Can't set LongReadLen < 0 or > %ld\",MAX_LongReadLen);\n        DBIc_LongReadLen(imp_xxh) = SvIV(valuesv);\n        cacheit = 1;    /* save it for clone */\n    }\n    else if (strEQ(key, \"LongTruncOk\")) {\n        DBIc_set(imp_xxh,DBIcf_LongTruncOk, on);\n    }\n    else if (strEQ(key, \"RaiseError\")) {\n        DBIc_set(imp_xxh,DBIcf_RaiseError, on);\n    }\n    else if (strEQ(key, \"PrintError\")) {\n        DBIc_set(imp_xxh,DBIcf_PrintError, on);\n    }\n    else if (strEQ(key, \"PrintWarn\")) {\n        DBIc_set(imp_xxh,DBIcf_PrintWarn, on);\n    }\n    else if (strEQ(key, \"HandleError\")) {\n        if ( on && (!SvROK(valuesv) || (SvTYPE(SvRV(valuesv)) != SVt_PVCV)) ) {\n            croak(\"Can't set %s to '%s'\", \"HandleError\", neatsvpv(valuesv,0));\n        }\n        DBIc_set(imp_xxh,DBIcf_HandleError, on);\n        cacheit = 1; /* child copy setup by dbih_setup_handle() */\n    }\n    else if (strEQ(key, \"HandleSetErr\")) {\n        if ( on && (!SvROK(valuesv) || (SvTYPE(SvRV(valuesv)) != SVt_PVCV)) ) {\n            croak(\"Can't set %s to '%s'\",\"HandleSetErr\",neatsvpv(valuesv,0));\n        }\n        DBIc_set(imp_xxh,DBIcf_HandleSetErr, on);\n        cacheit = 1; /* child copy setup by dbih_setup_handle() */\n    }\n    else if (strEQ(key, \"ChildHandles\")) {\n        if ( on && (!SvROK(valuesv) || (SvTYPE(SvRV(valuesv)) != SVt_PVAV)) ) {\n            croak(\"Can't set %s to '%s'\", \"ChildHandles\", neatsvpv(valuesv,0));\n        }\n        cacheit = 1; /* just save it in the hash */\n    }\n    else if (strEQ(key, \"Profile\")) {\n        static const char profile_class[] = \"DBI::Profile\";\n        if (on && (!SvROK(valuesv) || (SvTYPE(SvRV(valuesv)) != SVt_PVHV)) ) {\n            /* not a hash ref so use DBI::Profile to work out what to do */\n            dTHR;\n            dSP;\n            I32 returns;\n            TAINT_NOT; /* the require is presumed innocent till proven guilty */\n            perl_require_pv(\"DBI/Profile.pm\");\n            if (SvTRUE(ERRSV)) {\n                warn(\"Can't load %s: %s\", profile_class, SvPV_nolen(ERRSV));\n                valuesv = &PL_sv_undef;\n            }\n            else {\n                PUSHMARK(SP);\n                XPUSHs(sv_2mortal(newSVpv(profile_class,0)));\n                XPUSHs(valuesv);\n                PUTBACK;\n                returns = call_method(\"_auto_new\", G_SCALAR);\n                if (returns != 1)\n                    croak(\"%s _auto_new\", profile_class);\n                SPAGAIN;\n                valuesv = POPs;\n                PUTBACK;\n            }\n            on = SvTRUE(valuesv); /* in case it returns undef */\n        }\n        if (on && !sv_isobject(valuesv)) {\n            /* not blessed already - so default to DBI::Profile */\n            HV *stash;\n            perl_require_pv(profile_class);\n            stash = gv_stashpv(profile_class, GV_ADDWARN);\n            sv_bless(valuesv, stash);\n        }\n        DBIc_set(imp_xxh,DBIcf_Profile, on);\n        cacheit = 1; /* child copy setup by dbih_setup_handle() */\n    }\n    else if (strEQ(key, \"ShowErrorStatement\")) {\n        DBIc_set(imp_xxh,DBIcf_ShowErrorStatement, on);\n    }\n    else if (strEQ(key, \"MultiThread\") && internal) {\n        /* here to allow pure-perl drivers to set MultiThread */\n        DBIc_set(imp_xxh,DBIcf_MultiThread, on);\n        if (on && DBIc_WARN(imp_xxh)) {\n            warn(\"MultiThread support not yet implemented in DBI\");\n        }\n    }\n    else if (strEQ(key, \"Taint\")) {\n        /* 'Taint' is a shortcut for both in and out mode */\n        DBIc_set(imp_xxh,DBIcf_TaintIn|DBIcf_TaintOut, on);\n    }\n    else if (strEQ(key, \"TaintIn\")) {\n        DBIc_set(imp_xxh,DBIcf_TaintIn, on);\n    }\n    else if (strEQ(key, \"TaintOut\")) {\n        DBIc_set(imp_xxh,DBIcf_TaintOut, on);\n    }\n    else if (htype<=DBIt_DB && keylen==10 && strEQ(key, \"CachedKids\")\n        /* only allow hash refs */\n        && SvROK(valuesv) && SvTYPE(SvRV(valuesv))==SVt_PVHV\n    ) {\n        cacheit = 1;\n    }\n    else if (keylen==9 && strEQ(key, \"Callbacks\")) {\n        if ( on && (!SvROK(valuesv) || (SvTYPE(SvRV(valuesv)) != SVt_PVHV)) )\n            croak(\"Can't set Callbacks to '%s'\",neatsvpv(valuesv,0));\n        /* see also dbih_setup_handle for ChildCallbacks handling */\n        DBIc_set(imp_xxh, DBIcf_Callbacks, on);\n        cacheit = 1;\n    }\n    else if (htype<=DBIt_DB && keylen==10 && strEQ(key, \"AutoCommit\")) {\n        /* driver should have intercepted this and either handled it    */\n        /* or set valuesv to either the 'magic' on or off value.        */\n        if (SvIV(valuesv) != -900 && SvIV(valuesv) != -901)\n            croak(\"DBD driver has not implemented the AutoCommit attribute\");\n        DBIc_set(imp_xxh,DBIcf_AutoCommit, (SvIV(valuesv)==-901));\n    }\n    else if (htype==DBIt_DB && keylen==9 && strEQ(key, \"BegunWork\")) {\n        DBIc_set(imp_xxh,DBIcf_BegunWork, on);\n    }\n    else if (keylen==10  && strEQ(key, \"TraceLevel\")) {\n        set_trace(h, valuesv, Nullsv);\n    }\n    else if (keylen==9  && strEQ(key, \"TraceFile\")) { /* XXX undocumented and readonly */\n        set_trace_file(valuesv);\n    }\n    else if (htype==DBIt_ST && strEQ(key, \"NUM_OF_FIELDS\")) {\n        D_imp_sth(h);\n        int new_num_fields = (SvOK(valuesv)) ? SvIV(valuesv) : -1;\n        DBIc_NUM_FIELDS(imp_sth) = new_num_fields;\n        if (DBIc_FIELDS_AV(imp_sth)) { /* modify existing fbav */\n            dbih_setup_fbav(imp_sth);\n        }\n        cacheit = 1;\n    }\n    else if (htype==DBIt_ST && strEQ(key, \"NUM_OF_PARAMS\")) {\n        D_imp_sth(h);\n        DBIc_NUM_PARAMS(imp_sth) = SvIV(valuesv);\n        cacheit = 1;\n    }\n    /* these are here due to clone() needing to set attribs through a public api */\n    else if (htype<=DBIt_DB && (strEQ(key, \"Name\")\n                            || strEQ(key,\"ImplementorClass\")\n                            || strEQ(key,\"ReadOnly\")\n                            || strEQ(key,\"Statement\")\n                            || strEQ(key,\"Username\")\n        /* these are here for backwards histerical raisons */\n        || strEQ(key,\"USER\") || strEQ(key,\"CURRENT_USER\")\n    ) ) {\n        cacheit = 1;\n    }\n    else {      /* XXX should really be an event ? */\n        if (isUPPER(*key)) {\n            char *msg = \"Can't set %s->{%s}: unrecognised attribute name or invalid value%s\";\n            char *hint = \"\";\n            if (strEQ(key, \"NUM_FIELDS\"))\n                hint = \", perhaps you meant NUM_OF_FIELDS\";\n            warn(msg, neatsvpv(h,0), key, hint);\n            return FALSE;       /* don't store it */\n        }\n        /* Allow private_* attributes to be stored in the cache.        */\n        /* This is designed to make life easier for people subclassing  */\n        /* the DBI classes and may be of use to simple perl DBD's.      */\n        if (strnNE(key,\"private_\",8) && strnNE(key,\"dbd_\",4) && strnNE(key,\"dbi_\",4)) {\n            if (DBIc_TRACE_LEVEL(imp_xxh)) { /* change to DBIc_WARN(imp_xxh) once we can validate prefix against registry */\n                PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"$h->{%s}=%s ignored for invalid driver-specific attribute\\n\",\n                        neatsvpv(keysv,0), neatsvpv(valuesv,0));\n            }\n            return FALSE;\n        }\n        cacheit = 1;\n    }\n    if (cacheit) {\n        (void)hv_store((HV*)SvRV(h), key, keylen, newSVsv(valuesv), 0);\n    }\n    return TRUE;\n}\n\n\nstatic SV *\ndbih_get_attr_k(SV *h, SV *keysv, int dbikey)\n{\n    dTHX;\n    dTHR;\n    D_imp_xxh(h);\n    STRLEN keylen;\n    char  *key = SvPV(keysv, keylen);\n    int    htype = DBIc_TYPE(imp_xxh);\n    SV  *valuesv = Nullsv;\n    int    cacheit = FALSE;\n    char *p;\n    int i;\n    SV  *sv;\n    SV  **svp;\n    (void)dbikey;\n\n    /* DBI quick_FETCH will service some requests (e.g., cached values) */\n\n    if (htype == DBIt_ST) {\n        switch (*key) {\n\n          case 'D':\n            if (keylen==8 && strEQ(key, \"Database\")) {\n                D_imp_from_child(imp_dbh, imp_dbh_t, imp_xxh);\n                valuesv = newRV_inc((SV*)DBIc_MY_H(imp_dbh));\n                cacheit = FALSE;  /* else creates ref loop */\n            }\n            break;\n\n          case 'N':\n            if (keylen==8 && strEQ(key, \"NULLABLE\")) {\n                valuesv = &PL_sv_undef;\n                break;\n            }\n\n            if (keylen==4 && strEQ(key, \"NAME\")) {\n                valuesv = &PL_sv_undef;\n                break;\n            }\n\n            /* deal with: NAME_(uc|lc), NAME_hash, NAME_(uc|lc)_hash */\n            if ((keylen==7 || keylen==9 || keylen==12)\n                && strnEQ(key, \"NAME_\", 5)\n                && (    (keylen==9 && strEQ(key, \"NAME_hash\"))\n                      ||        ((key[5]=='u' || key[5]=='l') && key[6] == 'c'\n                               && (!key[7] || strnEQ(&key[7], \"_hash\", 5)))\n                    )\n                ) {\n                D_imp_sth(h);\n                valuesv = &PL_sv_undef;\n\n                /* fetch from tied outer handle to trigger FETCH magic */\n                svp = hv_fetch((HV*)DBIc_MY_H(imp_sth), \"NAME\",4, FALSE);\n                sv = (svp) ? *svp : &PL_sv_undef;\n                if (SvGMAGICAL(sv))     /* call FETCH via magic */\n                    mg_get(sv);\n\n                if (SvROK(sv)) {\n                    AV *name_av = (AV*)SvRV(sv);\n                    char *name;\n                    int upcase = (key[5] == 'u');\n                    AV *av = Nullav;\n                    HV *hv = Nullhv;\n                    int num_fields_mismatch = 0;\n\n                    if (strEQ(&key[strlen(key)-5], \"_hash\"))\n                        hv = newHV();\n                    else av = newAV();\n                    i = DBIc_NUM_FIELDS(imp_sth);\n\n                    /* catch invalid NUM_FIELDS */\n                    if (i != AvFILL(name_av)+1) {\n                        /* flag as mismatch, except for \"-1 and empty\" case */\n                        if ( ! (i == -1 && 0 == AvFILL(name_av)+1) )\n                            num_fields_mismatch = 1;\n                        i = AvFILL(name_av)+1; /* limit for safe iteration over array */\n                    }\n\n\t\t    if (DBIc_TRACE_LEVEL(imp_sth) >= 10 || (num_fields_mismatch && DBIc_WARN(imp_xxh))) {\n\t\t\tPerlIO_printf(DBIc_LOGPIO(imp_sth),\"       FETCH $h->{%s} from $h->{NAME} with $h->{NUM_OF_FIELDS} = %d\"\n\t\t\t                       \" and %ld entries in $h->{NAME}%s\\n\",\n\t\t\t\tneatsvpv(keysv,0), DBIc_NUM_FIELDS(imp_sth), AvFILL(name_av)+1,\n                                (num_fields_mismatch) ? \" (possible bug in driver)\" : \"\");\n                    }\n\n                    while (--i >= 0) {\n                        sv = newSVsv(AvARRAY(name_av)[i]);\n                        name = SvPV_nolen(sv);\n                        if (key[5] != 'h') {    /* \"NAME_hash\" */\n                            for (p = name; p && *p; ++p) {\n#ifdef toUPPER_LC\n                                *p = (upcase) ? toUPPER_LC(*p) : toLOWER_LC(*p);\n#else\n                                *p = (upcase) ? toUPPER(*p) : toLOWER(*p);\n#endif\n                            }\n                        }\n                        if (av)\n                            av_store(av, i, sv);\n                        else {\n                            (void)hv_store(hv, name, SvCUR(sv), newSViv(i), 0);\n                            sv_free(sv);\n                        }\n                    }\n                    valuesv = newRV_noinc( (av ? (SV*)av : (SV*)hv) );\n                    cacheit = TRUE;     /* can't change */\n                }\n            }\n            else if (keylen==13 && strEQ(key, \"NUM_OF_FIELDS\")) {\n                D_imp_sth(h);\n                IV num_fields = DBIc_NUM_FIELDS(imp_sth);\n                valuesv = (num_fields < 0) ? &PL_sv_undef : newSViv(num_fields);\n                if (num_fields > 0)\n                    cacheit = TRUE;     /* can't change once set (XXX except for multiple result sets) */\n            }\n            else if (keylen==13 && strEQ(key, \"NUM_OF_PARAMS\")) {\n                D_imp_sth(h);\n                valuesv = newSViv(DBIc_NUM_PARAMS(imp_sth));\n                cacheit = TRUE; /* can't change */\n            }\n            break;\n\n          case 'P':\n            if (strEQ(key, \"PRECISION\"))\n                valuesv = &PL_sv_undef;\n            else if (strEQ(key, \"ParamValues\"))\n                valuesv = &PL_sv_undef;\n            else if (strEQ(key, \"ParamTypes\"))\n                valuesv = &PL_sv_undef;\n            break;\n\n          case 'R':\n            if (strEQ(key, \"RowsInCache\"))\n                valuesv = &PL_sv_undef;\n            break;\n\n          case 'S':\n            if (strEQ(key, \"SCALE\"))\n                valuesv = &PL_sv_undef;\n            break;\n\n          case 'T':\n            if (strEQ(key, \"TYPE\"))\n                valuesv = &PL_sv_undef;\n            break;\n        }\n\n    }\n    else\n    if (htype == DBIt_DB) {\n        /* this is here but is, sadly, not called because\n         * not-preloading them into the handle attrib cache caused\n         * wierdness in t/proxy.t that I never got to the bottom\n         * of. One day maybe.  */\n        if (keylen==6 && strEQ(key, \"Driver\")) {\n            D_imp_from_child(imp_dbh, imp_dbh_t, imp_xxh);\n            valuesv = newRV_inc((SV*)DBIc_MY_H(imp_dbh));\n            cacheit = FALSE;  /* else creates ref loop */\n        }\n    }\n\n    if (valuesv == Nullsv && htype <= DBIt_DB) {\n        if (keylen==10 && strEQ(key, \"AutoCommit\")) {\n            valuesv = boolSV(DBIc_has(imp_xxh,DBIcf_AutoCommit));\n        }\n    }\n\n    if (valuesv == Nullsv) {\n        switch (*key) {\n          case 'A':\n            if (keylen==6 && strEQ(key, \"Active\")) {\n                valuesv = boolSV(DBIc_ACTIVE(imp_xxh));\n            }\n            else if (keylen==10 && strEQ(key, \"ActiveKids\")) {\n                valuesv = newSViv(DBIc_ACTIVE_KIDS(imp_xxh));\n            }\n            else if (strEQ(key, \"AutoInactiveDestroy\")) {\n                valuesv = boolSV(DBIc_AIADESTROY(imp_xxh));\n            }\n            break;\n\n          case 'B':\n            if (keylen==9 && strEQ(key, \"BegunWork\")) {\n                valuesv = boolSV(DBIc_has(imp_xxh,DBIcf_BegunWork));\n            }\n            break;\n\n          case 'C':\n            if (strEQ(key, \"ChildHandles\")) {\n                svp = hv_fetch((HV*)SvRV(h), key, keylen, FALSE);\n                /* if something has been stored then return it.\n                 * otherwise return a dummy empty array if weakrefs are\n                 * available, else an undef to indicate that they're not */\n                if (svp) {\n                    valuesv = newSVsv(*svp);\n                } else {\n#ifdef sv_rvweaken\n                    valuesv = newRV_noinc((SV*)newAV());\n#else\n                    valuesv = &PL_sv_undef;\n#endif\n                }\n            }\n            else if (strEQ(key, \"ChopBlanks\")) {\n                valuesv = boolSV(DBIc_has(imp_xxh,DBIcf_ChopBlanks));\n            }\n            else if (strEQ(key, \"CachedKids\")) {\n                valuesv = &PL_sv_undef;\n            }\n            else if (strEQ(key, \"CompatMode\")) {\n                valuesv = boolSV(DBIc_COMPAT(imp_xxh));\n            }\n            break;\n\n          case 'E':\n            if (strEQ(key, \"Executed\")) {\n                valuesv = boolSV(DBIc_is(imp_xxh, DBIcf_Executed));\n            }\n            else if (strEQ(key, \"ErrCount\")) {\n                valuesv = newSVuv(DBIc_ErrCount(imp_xxh));\n            }\n            break;\n\n          case 'I':\n            if (strEQ(key, \"InactiveDestroy\")) {\n                valuesv = boolSV(DBIc_IADESTROY(imp_xxh));\n            }\n            break;\n\n          case 'K':\n            if (keylen==4 && strEQ(key, \"Kids\")) {\n                valuesv = newSViv(DBIc_KIDS(imp_xxh));\n            }\n            break;\n\n          case 'L':\n            if (keylen==11 && strEQ(key, \"LongReadLen\")) {\n                valuesv = newSVnv((NV)DBIc_LongReadLen(imp_xxh));\n            }\n            else if (keylen==11 && strEQ(key, \"LongTruncOk\")) {\n                valuesv = boolSV(DBIc_has(imp_xxh,DBIcf_LongTruncOk));\n            }\n            break;\n\n          case 'M':\n            if (keylen==10 && strEQ(key, \"MultiThread\")) {\n                valuesv = boolSV(DBIc_has(imp_xxh,DBIcf_MultiThread));\n            }\n            break;\n\n          case 'P':\n            if (keylen==10 && strEQ(key, \"PrintError\")) {\n                valuesv = boolSV(DBIc_has(imp_xxh,DBIcf_PrintError));\n            }\n            else if (keylen==9 && strEQ(key, \"PrintWarn\")) {\n                valuesv = boolSV(DBIc_has(imp_xxh,DBIcf_PrintWarn));\n            }\n            break;\n\n          case 'R':\n            if (keylen==10 && strEQ(key, \"RaiseError\")) {\n                valuesv = boolSV(DBIc_has(imp_xxh,DBIcf_RaiseError));\n            }\n            else if (keylen==12 && strEQ(key, \"RowCacheSize\")) {\n                valuesv = &PL_sv_undef;\n            }\n            break;\n\n          case 'S':\n            if (keylen==18 && strEQ(key, \"ShowErrorStatement\")) {\n                valuesv = boolSV(DBIc_has(imp_xxh,DBIcf_ShowErrorStatement));\n            }\n            break;\n\n          case 'T':\n            if (keylen==4 && strEQ(key, \"Type\")) {\n                char *type = dbih_htype_name(htype);\n                valuesv = newSVpv(type,0);\n                cacheit = TRUE; /* can't change */\n            }\n            else if (keylen==10  && strEQ(key, \"TraceLevel\")) {\n                valuesv = newSViv( DBIc_DEBUGIV(imp_xxh) );\n            }\n            else if (keylen==5  && strEQ(key, \"Taint\")) {\n                valuesv = boolSV(DBIc_has(imp_xxh,DBIcf_TaintIn) &&\n                                 DBIc_has(imp_xxh,DBIcf_TaintOut));\n            }\n            else if (keylen==7  && strEQ(key, \"TaintIn\")) {\n                valuesv = boolSV(DBIc_has(imp_xxh,DBIcf_TaintIn));\n            }\n            else if (keylen==8  && strEQ(key, \"TaintOut\")) {\n                valuesv = boolSV(DBIc_has(imp_xxh,DBIcf_TaintOut));\n            }\n            break;\n\n          case 'W':\n            if (keylen==4 && strEQ(key, \"Warn\")) {\n                valuesv = boolSV(DBIc_WARN(imp_xxh));\n            }\n            break;\n        }\n    }\n\n    /* finally check the actual hash */\n    if (valuesv == Nullsv) {\n        valuesv = &PL_sv_undef;\n        cacheit = 0;\n        svp = hv_fetch((HV*)SvRV(h), key, keylen, FALSE);\n        if (svp)\n            valuesv = newSVsv(*svp);    /* take copy to mortalize */\n        else /* warn unless it's known attribute name */\n        if ( !(         (*key=='H' && strEQ(key, \"HandleError\"))\n                ||      (*key=='H' && strEQ(key, \"HandleSetErr\"))\n                ||      (*key=='S' && strEQ(key, \"Statement\"))\n                ||      (*key=='P' && strEQ(key, \"ParamArrays\"))\n                ||      (*key=='P' && strEQ(key, \"ParamValues\"))\n                ||      (*key=='P' && strEQ(key, \"Profile\"))\n                ||      (*key=='R' && strEQ(key, \"ReadOnly\"))\n                ||      (*key=='C' && strEQ(key, \"CursorName\"))\n                ||      (*key=='C' && strEQ(key, \"Callbacks\"))\n                ||      (*key=='U' && strEQ(key, \"Username\"))\n                ||      !isUPPER(*key)  /* dbd_*, private_* etc */\n        ))\n            warn(\"Can't get %s->{%s}: unrecognised attribute name\",neatsvpv(h,0),key);\n    }\n\n    if (cacheit) {\n        (void)hv_store((HV*)SvRV(h), key, keylen, newSVsv(valuesv), 0);\n    }\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 3)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"    .. FETCH %s %s = %s%s\\n\", neatsvpv(h,0),\n            neatsvpv(keysv,0), neatsvpv(valuesv,0), cacheit?\" (cached)\":\"\");\n    if (valuesv == &PL_sv_yes || valuesv == &PL_sv_no || valuesv == &PL_sv_undef)\n        return valuesv; /* no need to mortalize yes or no */\n    return sv_2mortal(valuesv);\n}\n\n\n\n/* -------------------------------------------------------------------- */\n/* Functions implementing Error and Event Handling.                     */\n\n\nstatic SV *\ndbih_event(SV *hrv, const char *evtype, SV *a1, SV *a2)\n{\n    dTHX;\n    /* We arrive here via DBIh_EVENT* macros (see DBIXS.h) called from  */\n    /* DBD driver C code OR $h->event() method (in DBD::_::common)      */\n    /* XXX VERY OLD INTERFACE/CONCEPT MAY GO SOON */\n    /* OR MAY EVOLVE INTO A WAY TO HANDLE 'SUCCESS_WITH_INFO'/'WARNINGS' from db */\n    (void)hrv;\n    (void)evtype;\n    (void)a1;\n    (void)a2;\n    return &PL_sv_undef;\n}\n\n\n/* ----------------------------------------------------------------- */\n\n\nSTATIC I32\ndbi_dopoptosub_at(PERL_CONTEXT *cxstk, I32 startingblock)\n{\n    dTHX;\n    I32 i;\n    register PERL_CONTEXT *cx;\n    for (i = startingblock; i >= 0; i--) {\n        cx = &cxstk[i];\n        switch (CxTYPE(cx)) {\n        default:\n            continue;\n        case CXt_EVAL:\n        case CXt_SUB:\n#ifdef CXt_FORMAT\n        case CXt_FORMAT:\n#endif\n            DEBUG_l( Perl_deb(aTHX_ \"(Found sub #%ld)\\n\", (long)i));\n            return i;\n        }\n    }\n    return i;\n}\n\n\nstatic COP *\ndbi_caller_cop()\n{\n    dTHX;\n    register I32 cxix;\n    register PERL_CONTEXT *cx;\n    register PERL_CONTEXT *ccstack = cxstack;\n    PERL_SI *top_si = PL_curstackinfo;\n    char *stashname;\n\n    for ( cxix = dbi_dopoptosub_at(ccstack, cxstack_ix) ;; cxix = dbi_dopoptosub_at(ccstack, cxix - 1)) {\n        /* we may be in a higher stacklevel, so dig down deeper */\n        while (cxix < 0 && top_si->si_type != PERLSI_MAIN) {\n            top_si = top_si->si_prev;\n            ccstack = top_si->si_cxstack;\n            cxix = dbi_dopoptosub_at(ccstack, top_si->si_cxix);\n        }\n        if (cxix < 0) {\n            break;\n        }\n        if (PL_DBsub && cxix >= 0 && ccstack[cxix].blk_sub.cv == GvCV(PL_DBsub))\n            continue;\n        cx = &ccstack[cxix];\n        stashname = CopSTASHPV(cx->blk_oldcop);\n        if (!stashname)\n            continue;\n        if (!(stashname[0] == 'D' && stashname[1] == 'B'\n                && strchr(\"DI\", stashname[2])\n                    && (!stashname[3] || (stashname[3] == ':' && stashname[4] == ':'))))\n        {\n            return cx->blk_oldcop;\n        }\n        cxix = dbi_dopoptosub_at(ccstack, cxix - 1);\n    }\n    return NULL;\n}\n\nstatic void\ndbi_caller_string(SV *buf, COP *cop, char *prefix, int show_line, int show_path)\n{\n    dTHX;\n    STRLEN len;\n    long  line = CopLINE(cop);\n    char *file = SvPV(GvSV(CopFILEGV(cop)), len);\n    if (!show_path) {\n        char *sep;\n        if ( (sep=strrchr(file,'/')) || (sep=strrchr(file,'\\\\')))\n            file = sep+1;\n    }\n    if (show_line) {\n        sv_catpvf(buf, \"%s%s line %ld\", (prefix) ? prefix : \"\", file, line);\n    }\n    else {\n        sv_catpvf(buf, \"%s%s\",          (prefix) ? prefix : \"\", file);\n    }\n}\n\nstatic char *\nlog_where(SV *buf, int append, char *prefix, char *suffix, int show_line, int show_caller, int show_path)\n{\n    dTHX;\n    dTHR;\n    if (!buf)\n        buf = sv_2mortal(newSVpv(\"\",0));\n    else if (!append)\n        sv_setpv(buf,\"\");\n    if (CopLINE(PL_curcop)) {\n        COP *cop;\n        dbi_caller_string(buf, PL_curcop, prefix, show_line, show_path);\n        if (show_caller && (cop = dbi_caller_cop())) {\n            SV *via = sv_2mortal(newSVpv(\"\",0));\n            dbi_caller_string(via, cop, prefix, show_line, show_path);\n            sv_catpvf(buf, \" via %s\", SvPV_nolen(via));\n        }\n    }\n    if (PL_dirty)\n        sv_catpvf(buf, \" during global destruction\");\n    if (suffix)\n        sv_catpv(buf, suffix);\n    return SvPVX(buf);\n}\n\n\nstatic void\nclear_cached_kids(pTHX_ SV *h, imp_xxh_t *imp_xxh, const char *meth_name, int trace_level)\n{\n    if (DBIc_TYPE(imp_xxh) <= DBIt_DB) {\n        SV **svp = hv_fetch((HV*)SvRV(h), \"CachedKids\", 10, 0);\n        if (svp && SvROK(*svp) && SvTYPE(SvRV(*svp)) == SVt_PVHV) {\n            HV *hv = (HV*)SvRV(*svp);\n            if (HvKEYS(hv)) {\n                if (DBIc_TRACE_LEVEL(imp_xxh) > trace_level)\n                    trace_level = DBIc_TRACE_LEVEL(imp_xxh);\n                if (trace_level >= 2) {\n                    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"    >> %s %s clearing %d CachedKids\\n\",\n                        meth_name, neatsvpv(h,0), (int)HvKEYS(hv));\n                    PerlIO_flush(DBIc_LOGPIO(imp_xxh));\n                }\n                /* This will probably recurse through dispatch to DESTROY the kids */\n                /* For drh we should probably explicitly do dbh disconnects */\n                hv_clear(hv);\n            }\n        }\n    }\n}\n\n\nstatic NV\ndbi_time() {\n# ifdef HAS_GETTIMEOFDAY\n#   ifdef PERL_IMPLICIT_SYS\n    dTHX;\n#   endif\n    struct timeval when;\n    gettimeofday(&when, (struct timezone *) 0);\n    return when.tv_sec + (when.tv_usec / 1000000.0);\n# else  /* per-second is almost useless */\n# ifdef _WIN32 /* use _ftime() on Win32 (MS Visual C++ 6.0) */\n#  if defined(__BORLANDC__)\n#   define _timeb timeb\n#   define _ftime ftime\n#  endif\n    struct _timeb when;\n    _ftime( &when );\n    return when.time + (when.millitm / 1000.0);\n# else\n    return time(NULL);\n# endif\n# endif\n}\n\n\nstatic SV *\n_profile_next_node(SV *node, const char *name)\n{\n    /* step one level down profile Data tree and auto-vivify if required */\n    dTHX;\n    SV *orig_node = node;\n    if (SvROK(node))\n        node = SvRV(node);\n    if (SvTYPE(node) != SVt_PVHV) {\n        HV *hv = newHV();\n        if (SvOK(node)) {\n            char *key = \"(demoted)\";\n            warn(\"Profile data element %s replaced with new hash ref (for %s) and original value stored with key '%s'\",\n                neatsvpv(orig_node,0), name, key);\n            (void)hv_store(hv, key, strlen(key), SvREFCNT_inc(orig_node), 0);\n        }\n        sv_setsv(node, newRV_noinc((SV*)hv));\n        node = (SV*)hv;\n    }\n    node = *hv_fetch((HV*)node, name, strlen(name), 1);\n    return node;\n}\n\n\nstatic SV*\ndbi_profile(SV *h, imp_xxh_t *imp_xxh, SV *statement_sv, SV *method, NV t1, NV t2)\n{\n#define DBIprof_MAX_PATH_ELEM   100\n#define DBIprof_COUNT           0\n#define DBIprof_TOTAL_TIME      1\n#define DBIprof_FIRST_TIME      2\n#define DBIprof_MIN_TIME        3\n#define DBIprof_MAX_TIME        4\n#define DBIprof_FIRST_CALLED    5\n#define DBIprof_LAST_CALLED     6\n#define DBIprof_max_index       6\n    dTHX;\n    NV ti = t2 - t1;\n    int src_idx = 0;\n    HV *dbh_outer_hv = NULL;\n    HV *dbh_inner_hv = NULL;\n    char *statement_pv;\n    char *method_pv;\n    SV *profile;\n    SV *tmp;\n    SV *dest_node;\n    AV *av;\n    HV *h_hv;\n\n    const int call_depth = DBIc_CALL_DEPTH(imp_xxh);\n    const int parent_call_depth = DBIc_PARENT_COM(imp_xxh) ? DBIc_CALL_DEPTH(DBIc_PARENT_COM(imp_xxh)) : 0;\n    /* Only count calls originating from the application code   */\n    if (call_depth > 1 || parent_call_depth > 0)\n        return &PL_sv_undef;\n\n    if (!DBIc_has(imp_xxh, DBIcf_Profile))\n        return &PL_sv_undef;\n\n    method_pv = (SvTYPE(method)==SVt_PVCV) ? GvNAME(CvGV(method))\n                : isGV(method) ? GvNAME(method)\n                : SvOK(method) ? SvPV_nolen(method)\n                : \"\";\n\n    /* we don't profile DESTROY during global destruction */\n    if (PL_dirty && instr(method_pv, \"DESTROY\"))\n        return &PL_sv_undef;\n\n    h_hv = (HV*)SvRV(dbih_inner(aTHX_ h, \"dbi_profile\"));\n\n    profile = *hv_fetch(h_hv, \"Profile\", 7, 1);\n    if (profile && SvMAGICAL(profile))\n        mg_get(profile); /* FETCH */\n    if (!profile || !SvROK(profile)) {\n        DBIc_set(imp_xxh, DBIcf_Profile, 0); /* disable */\n        if (SvOK(profile) && !PL_dirty)\n            warn(\"Profile attribute isn't a hash ref (%s,%ld)\", neatsvpv(profile,0), (long)SvTYPE(profile));\n        return &PL_sv_undef;\n    }\n\n    /* statement_sv: undef = use $h->{Statement}, \"\" (&sv_no) = use empty string */\n\n    if (!SvOK(statement_sv)) {\n        SV **psv = hv_fetch(h_hv, \"Statement\", 9, 0);\n        statement_sv = (psv && SvOK(*psv)) ? *psv : &PL_sv_no;\n    }\n    statement_pv = SvPV_nolen(statement_sv);\n\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 4)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"       dbi_profile +%\" NVff \"s %s %s\\n\",\n            ti, method_pv, neatsvpv(statement_sv,0));\n\n    dest_node = _profile_next_node(profile, \"Data\");\n\n    tmp = *hv_fetch((HV*)SvRV(profile), \"Path\", 4, 1);\n    if (SvROK(tmp) && SvTYPE(SvRV(tmp))==SVt_PVAV) {\n        int len;\n        av = (AV*)SvRV(tmp);\n        len = av_len(av); /* -1=empty, 0=one element */\n\n        while ( src_idx <= len ) {\n            SV *pathsv = AvARRAY(av)[src_idx++];\n\n            if (SvROK(pathsv) && SvTYPE(SvRV(pathsv))==SVt_PVCV) {\n                /* call sub, use returned list of values as path */\n                /* returning a ref to undef vetos this profile data */\n                dSP;\n                I32 ax;\n                SV *code_sv = SvRV(pathsv);\n                I32 items;\n                I32 item_idx;\n                EXTEND(SP, 4);\n                PUSHMARK(SP);\n                PUSHs(h);   /* push inner handle, then others params */\n                PUSHs( sv_2mortal(newSVpv(method_pv,0)));\n                PUTBACK;\n                SAVE_DEFSV; /* local($_) = $statement */\n                DEFSV = statement_sv;\n                items = call_sv(code_sv, G_ARRAY);\n                SPAGAIN;\n                SP -= items ;\n                ax = (SP - PL_stack_base) + 1 ;\n                for (item_idx=0; item_idx < items; ++item_idx) {\n                    SV *item_sv = ST(item_idx);\n                    if (SvROK(item_sv)) {\n                        if (!SvOK(SvRV(item_sv)))\n                            items = -2; /* flag that we're rejecting this profile data */\n                        else /* other refs reserved */\n                            warn(\"Ignored ref returned by code ref in Profile Path\");\n                        break;\n                    }\n                    dest_node = _profile_next_node(dest_node, SvPV_nolen(item_sv));\n                }\n                PUTBACK;\n                if (items == -2) /* this profile data was vetoed */\n                    return &PL_sv_undef;\n            }\n            else if (SvROK(pathsv)) {\n                /* only meant for refs to scalars currently */\n                const char *p = SvPV_nolen(SvRV(pathsv));\n                dest_node = _profile_next_node(dest_node, p);\n            }\n            else if (SvOK(pathsv)) {\n                STRLEN len;\n                const char *p = SvPV(pathsv,len);\n                if (p[0] == '!') { /* special cases */\n                    if (p[1] == 'S' && strEQ(p, \"!Statement\")) {\n                        dest_node = _profile_next_node(dest_node, statement_pv);\n                    }\n                    else if (p[1] == 'M' && strEQ(p, \"!MethodName\")) {\n                        dest_node = _profile_next_node(dest_node, method_pv);\n                    }\n                    else if (p[1] == 'M' && strEQ(p, \"!MethodClass\")) {\n                        if (SvTYPE(method) == SVt_PVCV) {\n                            p = SvPV_nolen((SV*)CvGV(method));\n                        }\n                        else if (isGV(method)) {\n                            /* just using SvPV_nolen(method) sometimes causes an error: */\n                            /* \"Can't coerce GLOB to string\" so we use gv_efullname()   */\n                            SV *tmpsv = sv_2mortal(newSVpv(\"\",0));\n#if (PERL_VERSION < 6)\n                            gv_efullname(tmpsv, (GV*)method);\n#else\n                            gv_efullname4(tmpsv, (GV*)method, \"\", TRUE);\n#endif\n                            p = SvPV_nolen(tmpsv);\n                            if (*p == '*') ++p; /* skip past leading '*' glob sigil */\n                        }\n                        else {\n                            p = method_pv;\n                        }\n                        dest_node = _profile_next_node(dest_node, p);\n                    }\n                    else if (p[1] == 'F' && strEQ(p, \"!File\")) {\n                        dest_node = _profile_next_node(dest_node, log_where(0, 0, \"\", \"\", 0, 0, 0));\n                    }\n                    else if (p[1] == 'F' && strEQ(p, \"!File2\")) {\n                        dest_node = _profile_next_node(dest_node, log_where(0, 0, \"\", \"\", 0, 1, 0));\n                    }\n                    else if (p[1] == 'C' && strEQ(p, \"!Caller\")) {\n                        dest_node = _profile_next_node(dest_node, log_where(0, 0, \"\", \"\", 1, 0, 0));\n                    }\n                    else if (p[1] == 'C' && strEQ(p, \"!Caller2\")) {\n                        dest_node = _profile_next_node(dest_node, log_where(0, 0, \"\", \"\", 1, 1, 0));\n                    }\n                    else if (p[1] == 'T' && (strEQ(p, \"!Time\") || strnEQ(p, \"!Time~\", 6))) {\n                        char timebuf[20];\n                        int factor = 1;\n                        if (p[5] == '~') {\n                            factor = atoi(&p[6]);\n                            if (factor == 0) /* sanity check to avoid div by zero error */\n                                factor = 3600;\n                        }\n                        sprintf(timebuf, \"%ld\", ((long)(dbi_time()/factor))*factor);\n                        dest_node = _profile_next_node(dest_node, timebuf);\n                    }\n                    else {\n                        warn(\"Unknown ! element in DBI::Profile Path: %s\", p);\n                        dest_node = _profile_next_node(dest_node, p);\n                    }\n                }\n                else if (p[0] == '{' && p[len-1] == '}') { /* treat as name of dbh attribute to use */\n                    SV **attr_svp;\n                    if (!dbh_inner_hv) {        /* cache dbh handles the first time we need them */\n                        imp_dbh_t *imp_dbh = (DBIc_TYPE(imp_xxh) <= DBIt_DB) ? (imp_dbh_t*)imp_xxh : (imp_dbh_t*)DBIc_PARENT_COM(imp_xxh);\n                        dbh_outer_hv = DBIc_MY_H(imp_dbh);\n                        if (SvTYPE(dbh_outer_hv) != SVt_PVHV)\n                            return &PL_sv_undef;        /* presumably global destruction - bail */\n                        dbh_inner_hv = (HV*)SvRV(dbih_inner(aTHX_ (SV*)dbh_outer_hv, \"profile\"));\n                        if (SvTYPE(dbh_inner_hv) != SVt_PVHV)\n                            return &PL_sv_undef;        /* presumably global destruction - bail */\n                    }\n                    /* fetch from inner first, then outer if key doesn't exist */\n                    /* (yes, this is an evil premature optimization) */\n                    p += 1; len -= 2; /* ignore the braces */\n                    if ((attr_svp = hv_fetch(dbh_inner_hv, p, len, 0)) == NULL) {\n                        /* try outer (tied) hash - for things like AutoCommit   */\n                        /* (will always return something even for unknowns)     */\n                        if ((attr_svp = hv_fetch(dbh_outer_hv, p, len, 0))) {\n                            if (SvGMAGICAL(*attr_svp))\n                                mg_get(*attr_svp); /* FETCH */\n                        }\n                    }\n                    if (!attr_svp)\n                        p -= 1; /* unignore the braces */\n                    else if (!SvOK(*attr_svp))\n                        p = \"\";\n                    else if (!SvTRUE(*attr_svp) && SvPOK(*attr_svp) && SvNIOK(*attr_svp))\n                        p = \"0\"; /* catch &sv_no style special case */\n                    else\n                        p = SvPV_nolen(*attr_svp);\n                    dest_node = _profile_next_node(dest_node, p);\n                }\n                else {\n                    dest_node = _profile_next_node(dest_node, p);\n                }\n            }\n            /* else undef, so ignore */\n        }\n    }\n    else { /* a bad Path value is treated as a Path of just Statement */\n        dest_node = _profile_next_node(dest_node, statement_pv);\n    }\n\n\n    if (!SvOK(dest_node)) {\n        av = newAV();\n        sv_setsv(dest_node, newRV_noinc((SV*)av));\n        av_store(av, DBIprof_COUNT,             newSViv(1));\n        av_store(av, DBIprof_TOTAL_TIME,        newSVnv(ti));\n        av_store(av, DBIprof_FIRST_TIME,        newSVnv(ti));\n        av_store(av, DBIprof_MIN_TIME,          newSVnv(ti));\n        av_store(av, DBIprof_MAX_TIME,          newSVnv(ti));\n        av_store(av, DBIprof_FIRST_CALLED,      newSVnv(t1));\n        av_store(av, DBIprof_LAST_CALLED,       newSVnv(t1));\n    }\n    else {\n        tmp = dest_node;\n        if (SvROK(tmp))\n            tmp = SvRV(tmp);\n        if (SvTYPE(tmp) != SVt_PVAV)\n            croak(\"Invalid Profile data leaf element: %s (type %ld)\",\n                    neatsvpv(tmp,0), (long)SvTYPE(tmp));\n        av = (AV*)tmp;\n        sv_inc( *av_fetch(av, DBIprof_COUNT, 1));\n        tmp = *av_fetch(av, DBIprof_TOTAL_TIME, 1);\n        sv_setnv(tmp, SvNV(tmp) + ti);\n        tmp = *av_fetch(av, DBIprof_MIN_TIME, 1);\n        if (ti < SvNV(tmp)) sv_setnv(tmp, ti);\n        tmp = *av_fetch(av, DBIprof_MAX_TIME, 1);\n        if (ti > SvNV(tmp)) sv_setnv(tmp, ti);\n        sv_setnv( *av_fetch(av, DBIprof_LAST_CALLED, 1), t1);\n    }\n    return dest_node; /* use with caution - copy first, ie sv_mortalcopy() */\n}\n\n\nstatic void\ndbi_profile_merge_nodes(SV *dest, SV *increment)\n{\n    dTHX;\n    AV *d_av, *i_av;\n    SV *tmp;\n    SV *tmp2;\n    NV i_nv;\n    int i_is_earlier;\n\n    if (!SvROK(dest) || SvTYPE(SvRV(dest)) != SVt_PVAV)\n        croak(\"dbi_profile_merge_nodes(%s, ...) requires array ref\", neatsvpv(dest,0));\n    d_av = (AV*)SvRV(dest);\n\n    if (av_len(d_av) < DBIprof_max_index) {\n        int idx;\n        av_extend(d_av, DBIprof_max_index);\n        for(idx=0; idx<=DBIprof_max_index; ++idx) {\n            tmp = *av_fetch(d_av, idx, 1);\n            if (!SvOK(tmp) && idx != DBIprof_MIN_TIME && idx != DBIprof_FIRST_CALLED)\n                sv_setnv(tmp, 0.0); /* leave 'min' values as undef */\n        }\n    }\n\n    if (!SvOK(increment))\n        return;\n\n    if (SvROK(increment) && SvTYPE(SvRV(increment)) == SVt_PVHV) {\n        HV *hv = (HV*)SvRV(increment);\n        char *key;\n        I32 keylen = 0;\n        hv_iterinit(hv);\n        while ( (tmp = hv_iternextsv(hv, &key, &keylen)) != NULL ) {\n            dbi_profile_merge_nodes(dest, tmp);\n        };\n        return;\n    }\n\n    if (!SvROK(increment) || SvTYPE(SvRV(increment)) != SVt_PVAV)\n        croak(\"dbi_profile_merge_nodes: increment %s not an array or hash ref\", neatsvpv(increment,0));\n    i_av = (AV*)SvRV(increment);\n\n    tmp  = *av_fetch(d_av, DBIprof_COUNT, 1);\n    tmp2 = *av_fetch(i_av, DBIprof_COUNT, 1);\n    if (SvIOK(tmp) && SvIOK(tmp2))\n        sv_setiv( tmp, SvIV(tmp) + SvIV(tmp2) );\n    else\n        sv_setnv( tmp, SvNV(tmp) + SvNV(tmp2) );\n\n    tmp = *av_fetch(d_av, DBIprof_TOTAL_TIME, 1);\n    sv_setnv( tmp, SvNV(tmp) + SvNV( *av_fetch(i_av, DBIprof_TOTAL_TIME, 1)) );\n\n    i_nv = SvNV(*av_fetch(i_av, DBIprof_MIN_TIME, 1));\n    tmp  =      *av_fetch(d_av, DBIprof_MIN_TIME, 1);\n    if (!SvOK(tmp) || i_nv < SvNV(tmp)) sv_setnv(tmp, i_nv);\n\n    i_nv = SvNV(*av_fetch(i_av, DBIprof_MAX_TIME, 1));\n    tmp  =      *av_fetch(d_av, DBIprof_MAX_TIME, 1);\n    if (i_nv > SvNV(tmp)) sv_setnv(tmp, i_nv);\n\n    i_nv = SvNV(*av_fetch(i_av, DBIprof_FIRST_CALLED, 1));\n    tmp  =      *av_fetch(d_av, DBIprof_FIRST_CALLED, 1);\n    i_is_earlier = (!SvOK(tmp) || i_nv < SvNV(tmp));\n    if (i_is_earlier)\n        sv_setnv(tmp, i_nv);\n\n    i_nv = SvNV(*av_fetch(i_av, DBIprof_FIRST_TIME, 1));\n    tmp  =      *av_fetch(d_av, DBIprof_FIRST_TIME, 1);\n    if (i_is_earlier || !SvOK(tmp)) {\n        /* If the increment has an earlier DBIprof_FIRST_CALLED\n        then we set the DBIprof_FIRST_TIME from the increment */\n        sv_setnv(tmp, i_nv);\n    }\n\n    i_nv = SvNV(*av_fetch(i_av, DBIprof_LAST_CALLED, 1));\n    tmp  =      *av_fetch(d_av, DBIprof_LAST_CALLED, 1);\n    if (i_nv > SvNV(tmp)) sv_setnv(tmp, i_nv);\n}\n\n\n/* ----------------------------------------------------------------- */\n/* ---   The DBI dispatcher. The heart of the perl DBI.          --- */\n\nXS(XS_DBI_dispatch);            /* prototype to pass -Wmissing-prototypes */\nXS(XS_DBI_dispatch)\n{\n    dXSARGS;\n    dMY_CXT;\n\n    SV *h   = ST(0);            /* the DBI handle we are working with   */\n    SV *st1 = ST(1);            /* used in debugging */\n    SV *st2 = ST(2);            /* used in debugging */\n    SV *orig_h = h;\n    SV *err_sv;\n    SV **tmp_svp;\n    SV **hook_svp = 0;\n    MAGIC *mg;\n    int gimme = GIMME;\n    I32 trace_flags = DBIS->debug;      /* local copy may change during dispatch */\n    I32 trace_level = (trace_flags & DBIc_TRACE_LEVEL_MASK);\n    int is_DESTROY;\n    meth_types meth_type;\n    int is_unrelated_to_Statement = 0;\n    U32 keep_error = FALSE;\n    UV  ErrCount = UV_MAX;\n    int i, outitems;\n    int call_depth;\n    int is_nested_call;\n    NV profile_t1 = 0.0;\n    int is_orig_method_name = 1;\n\n    const char  *meth_name = GvNAME(CvGV(cv));\n    dbi_ima_t *ima = (dbi_ima_t*)CvXSUBANY(cv).any_ptr;\n    U32   ima_flags;\n    imp_xxh_t   *imp_xxh   = NULL;\n    SV          *imp_msv   = Nullsv;\n    SV          *qsv       = Nullsv; /* quick result from a shortcut method   */\n\n\n#ifdef BROKEN_DUP_ANY_PTR\n    if (ima->my_perl != my_perl) {\n        /* we couldn't dup the ima struct at clone time, so do it now */\n        dbi_ima_t *nima;\n        Newx(nima, 1, dbi_ima_t);\n        *nima = *ima; /* structure copy */\n        CvXSUBANY(cv).any_ptr = nima;\n        nima->stash = NULL;\n        nima->gv    = NULL;\n        nima->my_perl = my_perl;\n        ima = nima;\n    }\n#endif\n\n    ima_flags  = ima->flags;\n    meth_type = ima->meth_type;\n    if (trace_level >= 9) {\n        PerlIO *logfp = DBILOGFP;\n        PerlIO_printf(logfp,\"%c   >> %-11s DISPATCH (%s rc%ld/%ld @%ld g%x ima%lx pid#%ld)\",\n            (PL_dirty?'!':' '), meth_name, neatsvpv(h,0),\n            (long)SvREFCNT(h), (SvROK(h) ? (long)SvREFCNT(SvRV(h)) : (long)-1),\n            (long)items, (int)gimme, (long)ima_flags, (long)PerlProc_getpid());\n        PerlIO_puts(logfp, log_where(0, 0, \" at \",\"\\n\", 1, (trace_level >= 3), (trace_level >= 4)));\n        PerlIO_flush(logfp);\n    }\n\n    if ( ( (is_DESTROY=(meth_type == methtype_DESTROY))) ) {\n        /* note that croak()'s won't propagate, only append to $@ */\n        keep_error = TRUE;\n    }\n\n    /* If h is a tied hash ref, switch to the inner ref 'behind' the tie.\n       This means *all* DBI methods work with the inner (non-tied) ref.\n       This makes it much easier for methods to access the real hash\n       data (without having to go through FETCH and STORE methods) and\n       for tie and non-tie methods to call each other.\n    */\n    if (SvROK(h)\n        && SvRMAGICAL(SvRV(h))\n        && (\n               ((mg=SvMAGIC(SvRV(h)))->mg_type == 'P')\n            || ((mg=mg_find(SvRV(h),'P')) != NULL)\n           )\n    ) {\n        if (mg->mg_obj==NULL || !SvOK(mg->mg_obj) || SvRV(mg->mg_obj)==NULL) {  /* maybe global destruction */\n            if (trace_level >= 3)\n                PerlIO_printf(DBILOGFP,\n                    \"%c   <> %s for %s ignored (inner handle gone)\\n\",\n                    (PL_dirty?'!':' '), meth_name, neatsvpv(h,0));\n            XSRETURN(0);\n        }\n        /* Distinguish DESTROY of tie (outer) from DESTROY of inner ref */\n        /* This may one day be used to manually destroy extra internal  */\n        /* refs if the application ceases to use the handle.            */\n        if (is_DESTROY) {\n            imp_xxh = DBIh_COM(mg->mg_obj);\n#ifdef DBI_USE_THREADS\n            if (imp_xxh && DBIc_THR_USER(imp_xxh) != my_perl) {\n                goto is_DESTROY_wrong_thread;\n            }\n#endif\n            if (imp_xxh && DBIc_TYPE(imp_xxh) <= DBIt_DB)\n                clear_cached_kids(aTHX_ mg->mg_obj, imp_xxh, meth_name, trace_level);\n            /* XXX might be better to move this down to after call_depth has been\n             * incremented and then also SvREFCNT_dec(mg->mg_obj) to force an immediate\n             * DESTROY of the inner handle if there are no other refs to it.\n             * That way the inner DESTROY is properly flagged as a nested call,\n             * and the outer DESTROY gets profiled more accurately, and callbacks work.\n             */\n            if (trace_level >= 3) {\n                PerlIO_printf(DBILOGFP,\n                    \"%c   <> DESTROY(%s) ignored for outer handle (inner %s has ref cnt %ld)\\n\",\n                    (PL_dirty?'!':' '), neatsvpv(h,0), neatsvpv(mg->mg_obj,0),\n                    (long)SvREFCNT(SvRV(mg->mg_obj))\n                );\n            }\n            /* for now we ignore it since it'll be followed soon by     */\n            /* a destroy of the inner hash and that'll do the real work */\n\n            /* However, we must at least modify DBIc_MY_H() as that is  */\n            /* pointing (without a refcnt inc) to the scalar that is    */\n            /* being destroyed, so it'll contain random values later.   */\n            if (imp_xxh)\n                DBIc_MY_H(imp_xxh) = (HV*)SvRV(mg->mg_obj); /* inner (untied) HV */\n\n            XSRETURN(0);\n        }\n        h = mg->mg_obj; /* switch h to inner ref                        */\n        ST(0) = h;      /* switch handle on stack to inner ref          */\n    }\n\n    imp_xxh = dbih_getcom2(aTHX_ h, 0); /* get common Internal Handle Attributes        */\n    if (!imp_xxh) {\n        if (meth_type == methtype_can) {  /* ref($h)->can(\"foo\")        */\n            const char *can_meth = SvPV_nolen(st1);\n            SV *rv = &PL_sv_undef;\n            GV *gv = gv_fetchmethod_autoload(gv_stashsv(orig_h,FALSE), can_meth, FALSE);\n            if (gv && isGV(gv))\n                rv = sv_2mortal(newRV_inc((SV*)GvCV(gv)));\n            if (trace_level >= 1) {\n                PerlIO_printf(DBILOGFP,\"    <- %s(%s) = %p\\n\", meth_name, can_meth, neatsvpv(rv,0));\n            }\n            ST(0) = rv;\n            XSRETURN(1);\n        }\n        if (trace_level)\n            PerlIO_printf(DBILOGFP, \"%c   <> %s for %s ignored (no imp_data)\\n\",\n                (PL_dirty?'!':' '), meth_name, neatsvpv(h,0));\n        if (!is_DESTROY)\n            warn(\"Can't call %s method on handle %s%s\", meth_name, neatsvpv(h,0),\n                SvROK(h) ? \" after take_imp_data()\" : \" (not a reference)\");\n        XSRETURN(0);\n    }\n\n    if (DBIc_has(imp_xxh,DBIcf_Profile)) {\n        profile_t1 = dbi_time(); /* just get start time here */\n    }\n\n#ifdef DBI_USE_THREADS\n{\n    PerlInterpreter * h_perl;\n    is_DESTROY_wrong_thread:\n    h_perl = DBIc_THR_USER(imp_xxh) ;\n    if (h_perl != my_perl) {\n        /* XXX could call a 'handle clone' method here?, for dbh's at least */\n        if (is_DESTROY) {\n            if (trace_level >= 3) {\n                PerlIO_printf(DBILOGFP,\"    DESTROY ignored because DBI %sh handle (%s) is owned by thread %p not current thread %p\\n\",\n                      dbih_htype_name(DBIc_TYPE(imp_xxh)), HvNAME(DBIc_IMP_STASH(imp_xxh)),\n                      (void*)DBIc_THR_USER(imp_xxh), (void*)my_perl) ;\n                PerlIO_flush(DBILOGFP);\n            }\n            XSRETURN(0); /* don't DESTROY handle, if it is not our's !*/\n        }\n        croak(\"%s %s failed: handle %d is owned by thread %lx not current thread %lx (%s)\",\n            HvNAME(DBIc_IMP_STASH(imp_xxh)), meth_name, DBIc_TYPE(imp_xxh),\n            (unsigned long)h_perl, (unsigned long)my_perl,\n            \"handles can't be shared between threads and your driver may need a CLONE method added\");\n    }\n}\n#endif\n\n    if ((i = DBIc_DEBUGIV(imp_xxh))) { /* merge handle into global */\n        I32 h_trace_level = (i & DBIc_TRACE_LEVEL_MASK);\n        if ( h_trace_level > trace_level )\n            trace_level = h_trace_level;\n        trace_flags = (trace_flags & ~DBIc_TRACE_LEVEL_MASK)\n                    | (          i & ~DBIc_TRACE_LEVEL_MASK)\n                    | trace_level;\n    }\n\n    /* Check method call against Internal Method Attributes */\n    if (ima_flags) {\n\n        if (ima_flags & (IMA_STUB|IMA_FUNC_REDIRECT|IMA_KEEP_ERR|IMA_KEEP_ERR_SUB|IMA_CLEAR_STMT)) {\n\n            if (ima_flags & IMA_STUB) {\n                if (meth_type == methtype_can) {\n                    const char *can_meth = SvPV_nolen(st1);\n                    SV *dbi_msv = Nullsv;\n                    /* find handle implementors method (GV or CV) */\n                    if ( (imp_msv = (SV*)gv_fetchmethod_autoload(DBIc_IMP_STASH(imp_xxh), can_meth, FALSE)) ) {\n                        /* return DBI's CV, not the implementors CV (else we'd bypass dispatch) */\n                        /* and anyway, we may have hit a private method not part of the DBI     */\n                        GV *gv = gv_fetchmethod_autoload(SvSTASH(SvRV(orig_h)), can_meth, FALSE);\n                        if (gv && isGV(gv))\n                            dbi_msv = (SV*)GvCV(gv);\n                    }\n                    if (trace_level >= 1) {\n                        PerlIO *logfp = DBILOGFP;\n                        PerlIO_printf(logfp,\"    <- %s(%s) = %p (%s %p)\\n\", meth_name, can_meth, (void*)dbi_msv,\n                                (imp_msv && isGV(imp_msv)) ? HvNAME(GvSTASH(imp_msv)) : \"?\", (void*)imp_msv);\n                    }\n                    ST(0) = (dbi_msv) ? sv_2mortal(newRV_inc(dbi_msv)) : &PL_sv_undef;\n                    XSRETURN(1);\n                }\n                XSRETURN(0);\n            }\n            if (ima_flags & IMA_FUNC_REDIRECT) {\n                /* XXX this doesn't redispatch, nor consider the IMA of the new method */\n                SV *meth_name_sv = POPs;\n                PUTBACK;\n                --items;\n                if (!SvPOK(meth_name_sv) || SvNIOK(meth_name_sv))\n                    croak(\"%s->%s() invalid redirect method name %s\",\n                            neatsvpv(h,0), meth_name, neatsvpv(meth_name_sv,0));\n                meth_name = SvPV_nolen(meth_name_sv);\n                meth_type = get_meth_type(meth_name);\n                is_orig_method_name = 0;\n            }\n            if (ima_flags & IMA_KEEP_ERR)\n                keep_error = TRUE;\n            if ((ima_flags & IMA_KEEP_ERR_SUB)\n                && !PL_dirty\n                && DBIc_PARENT_COM(imp_xxh) && DBIc_CALL_DEPTH(DBIc_PARENT_COM(imp_xxh)) > 0)\n                keep_error = TRUE;\n            if (ima_flags & IMA_CLEAR_STMT) {\n                /* don't use SvOK_off: dbh's Statement may be ref to sth's */\n                (void)hv_store((HV*)SvRV(h), \"Statement\", 9, &PL_sv_undef, 0);\n            }\n            if (ima_flags & IMA_CLEAR_CACHED_KIDS)\n                clear_cached_kids(aTHX_ h, imp_xxh, meth_name, trace_flags);\n\n        }\n\n        if (ima_flags & IMA_HAS_USAGE) {\n            const char *err = NULL;\n            char msg[200];\n\n            if (ima->minargs && (items < ima->minargs\n                                || (ima->maxargs>0 && items > ima->maxargs))) {\n                sprintf(msg,\n                    \"DBI %s: invalid number of arguments: got handle + %ld, expected handle + between %d and %d\\n\",\n                    meth_name, (long)items-1, (int)ima->minargs-1, (int)ima->maxargs-1);\n                err = msg;\n            }\n            /* arg type checking could be added here later */\n            if (err) {\n                croak(\"%sUsage: %s->%s(%s)\", err, \"$h\", meth_name,\n                    (ima->usage_msg) ? ima->usage_msg : \"...?\");\n            }\n        }\n    }\n\n    is_unrelated_to_Statement = ( (DBIc_TYPE(imp_xxh) == DBIt_ST) ? 0\n                                : (DBIc_TYPE(imp_xxh) == DBIt_DR) ? 1\n                                : (ima_flags & IMA_UNRELATED_TO_STMT) );\n\n    if (PL_tainting && items > 1              /* method call has args   */\n        && DBIc_is(imp_xxh, DBIcf_TaintIn)    /* taint checks requested */\n        && !(ima_flags & IMA_NO_TAINT_IN)\n    ) {\n        for(i=1; i < items; ++i) {\n            if (SvTAINTED(ST(i))) {\n                char buf[100];\n                sprintf(buf,\"parameter %d of %s->%s method call\",\n                        i, SvPV_nolen(h), meth_name);\n                PL_tainted = 1; /* needed for TAINT_PROPER to work      */\n                TAINT_PROPER(buf);      /* die's */\n            }\n        }\n    }\n\n    /* record this inner handle for use by DBI::var::FETCH      */\n    if (is_DESTROY) {\n\n        /* force destruction of any outstanding children */\n        if ((tmp_svp = hv_fetch((HV*)SvRV(h), \"ChildHandles\", 12, FALSE)) && SvROK(*tmp_svp)) {\n            AV *av = (AV*)SvRV(*tmp_svp);\n            I32 kidslots;\n            PerlIO *logfp = DBILOGFP;\n\n            for (kidslots = AvFILL(av); kidslots >= 0; --kidslots) {\n                SV **hp = av_fetch(av, kidslots, FALSE);\n                if (!hp || !SvROK(*hp) || SvTYPE(SvRV(*hp))!=SVt_PVHV)\n                    break;\n\n                if (trace_level >= 1) {\n                    PerlIO_printf(logfp, \"on DESTROY handle %s still has child %s (refcnt %ld, obj %d, dirty=%d)\\n\",\n                        neatsvpv(h,0), neatsvpv(*hp, 0), (long)SvREFCNT(*hp), !!sv_isobject(*hp), PL_dirty);\n                    if (trace_level >= 9)\n                        sv_dump(SvRV(*hp));\n                }\n                if (sv_isobject(*hp)) { /* call DESTROY on the handle */\n                    PUSHMARK(SP);\n                    XPUSHs(*hp);\n                    PUTBACK;\n                    call_method(\"DESTROY\", G_DISCARD|G_EVAL|G_KEEPERR);\n                }\n                else {\n                    imp_xxh_t *imp_xxh = dbih_getcom2(aTHX_ *hp, 0);\n                    if (imp_xxh && DBIc_COMSET(imp_xxh)) {\n                        dbih_clearcom(imp_xxh);\n                        sv_setsv(*hp, &PL_sv_undef);\n                    }\n                }\n            }\n        }\n\n        if (DBIc_TYPE(imp_xxh) <= DBIt_DB ) {   /* is dbh or drh */\n            imp_xxh_t *parent_imp;\n\n            if (SvOK(DBIc_ERR(imp_xxh)) && (parent_imp = DBIc_PARENT_COM(imp_xxh))\n                && !PL_dirty /* XXX - remove? */\n            ) {\n                /* copy err/errstr/state values to $DBI::err etc still work */\n                sv_setsv(DBIc_ERR(parent_imp),    DBIc_ERR(imp_xxh));\n                sv_setsv(DBIc_ERRSTR(parent_imp), DBIc_ERRSTR(imp_xxh));\n                sv_setsv(DBIc_STATE(parent_imp),  DBIc_STATE(imp_xxh));\n            }\n        }\n\n        if (DBIc_AIADESTROY(imp_xxh)) { /* wants ineffective destroy after fork */\n            if ((U32)PerlProc_getpid() != _imp2com(imp_xxh, std.pid))\n                DBIc_set(imp_xxh, DBIcf_IADESTROY, 1);\n        }\n        if (DBIc_IADESTROY(imp_xxh)) {  /* wants ineffective destroy    */\n            DBIc_ACTIVE_off(imp_xxh);\n        }\n        call_depth = 0;\n        is_nested_call = 0;\n    }\n    else {\n        DBI_SET_LAST_HANDLE(h);\n        SAVEINT(DBIc_CALL_DEPTH(imp_xxh));\n        call_depth = ++DBIc_CALL_DEPTH(imp_xxh);\n\n        if (ima_flags & IMA_COPY_UP_STMT) { /* execute() */\n            SV *parent = DBIc_PARENT_H(imp_xxh);\n            SV *tmp_sv = *hv_fetch((HV*)SvRV(h), \"Statement\", 9, 1);\n            /* XXX sv_copy() if Profiling? */\n            (void)hv_store((HV*)SvRV(parent), \"Statement\", 9, SvREFCNT_inc(tmp_sv), 0);\n        }\n        is_nested_call =\n            (call_depth > 1\n                || (!PL_dirty /* not in global destruction [CPAN #75614] */\n                    && DBIc_PARENT_COM(imp_xxh)\n                    && DBIc_CALL_DEPTH(DBIc_PARENT_COM(imp_xxh))) >= 1);\n\n    }\n\n\n    /* --- dispatch --- */\n\n    if (!keep_error && meth_type != methtype_set_err) {\n        SV *err_sv;\n        if (trace_level && SvOK(err_sv=DBIc_ERR(imp_xxh))) {\n            PerlIO *logfp = DBILOGFP;\n            PerlIO_printf(logfp, \"    !! The %s '%s' was CLEARED by call to %s method\\n\",\n                SvTRUE(err_sv) ? \"ERROR\" : strlen(SvPV_nolen(err_sv)) ? \"warn\" : \"info\",\n                neatsvpv(DBIc_ERR(imp_xxh),0), meth_name);\n        }\n        DBIh_CLEAR_ERROR(imp_xxh);\n    }\n    else {      /* we check for change in ErrCount/err_hash during call */\n        ErrCount = DBIc_ErrCount(imp_xxh);\n        if (keep_error)\n            keep_error = err_hash(aTHX_ imp_xxh);\n    }\n\n    if (DBIc_has(imp_xxh,DBIcf_Callbacks)\n        && (tmp_svp = hv_fetch((HV*)SvRV(h), \"Callbacks\", 9, 0))\n        && (   (hook_svp = hv_fetch((HV*)SvRV(*tmp_svp), meth_name, strlen(meth_name), 0))\n              /* the \"*\" fallback callback only applies to non-nested calls\n               * and also doesn't apply to the 'set_err' or DESTROY methods.\n               * Nor during global destruction.\n               * Other restrictions may be added over time.\n               * It's an undocumented hack.\n               */\n          || (!is_nested_call && !PL_dirty && meth_type != methtype_set_err &&\n               meth_type != methtype_DESTROY &&\n               (hook_svp = hv_fetch((HV*)SvRV(*tmp_svp), \"*\", 1, 0))\n             )\n        )\n        && SvROK(*hook_svp)\n    ) {\n        SV *orig_defsv;\n        SV *code = SvRV(*hook_svp);\n        I32 skip_dispatch = 0;\n        if (trace_level)\n            PerlIO_printf(DBILOGFP, \"%c   {{ %s callback %s being invoked\\n\",\n                (PL_dirty?'!':' '), meth_name, neatsvpv(*hook_svp,0));\n\n        /* we don't use ENTER,SAVETMPS & FREETMPS,LEAVE because we may need mortal\n         * results to live long enough to be returned to our caller\n         */\n        /* we want to localize $_ for the callback but can't just do that alone\n         * because we're not using SAVETMPS & FREETMPS, so we have to get sneaky.\n         * We still localize, so we're safe from the callback die-ing,\n         * but after the callback we manually restore the original $_.\n         */\n        orig_defsv = DEFSV; /* remember the current $_ */\n        SAVE_DEFSV;         /* local($_) = $method_name */\n        DEFSV = sv_2mortal(newSVpv(meth_name,0));\n\n        EXTEND(SP, items+1);\n        PUSHMARK(SP);\n        PUSHs(orig_h);                  /* push outer handle, then others params */\n        for (i=1; i < items; ++i) {     /* start at 1 to skip handle */\n            PUSHs( ST(i) );\n        }\n        PUTBACK;\n        outitems = call_sv(code, G_ARRAY); /* call the callback code */\n        SPAGAIN;\n\n        /* The callback code can undef $_ to indicate to skip dispatch */\n        skip_dispatch = !SvOK(DEFSV);\n        /* put $_ back now, but with an incremented ref count to compensate\n         * for the ref count decrement that will happen when we exit the scope.\n         */\n        DEFSV = SvREFCNT_inc(orig_defsv);\n\n        if (trace_level)\n            PerlIO_printf(DBILOGFP, \"%c   }} %s callback %s returned%s\\n\",\n                (PL_dirty?'!':' '), meth_name, neatsvpv(*hook_svp,0),\n                skip_dispatch ? \", actual method will not be called\" : \"\"\n            );\n        if (skip_dispatch) {    /* XXX experimental */\n            int ix = outitems;\n            /* copy the new items down to the destination list */\n            while (ix-- > 0) {\n                if(0)warn(\"\\tcopy down %d: %s overwriting %s\\n\", ix, SvPV_nolen(TOPs), SvPV_nolen(ST(ix)) );\n                ST(ix) = POPs;\n            }\n            imp_msv = *hook_svp; /* for trace and profile */\n            goto post_dispatch;\n        }\n        else {\n            if (outitems != 0)\n                die(\"Callback for %s returned %d values but must not return any (temporary restriction in current version)\",\n                        meth_name, (int)outitems);\n            /* POP's and PUTBACK? to clear stack */\n        }\n    }\n\n    /* set Executed after Callbacks so it's not set if callback elects to skip the method */\n    if (ima_flags & IMA_EXECUTE) {\n        imp_xxh_t *parent = DBIc_PARENT_COM(imp_xxh);\n        DBIc_on(imp_xxh, DBIcf_Executed);\n        if (parent)\n            DBIc_on(parent, DBIcf_Executed);\n    }\n\n    /* The \"quick_FETCH\" logic...                                       */\n    /* Shortcut for fetching attributes to bypass method call overheads */\n    if (meth_type == methtype_FETCH && !DBIc_COMPAT(imp_xxh)) {\n        STRLEN kl;\n        const char *key = SvPV(st1, kl);\n        SV **attr_svp;\n        if (*key != '_' && (attr_svp=hv_fetch((HV*)SvRV(h), key, kl, 0))) {\n            qsv = *attr_svp;\n            /* disable FETCH from cache for special attributes */\n            if (SvROK(qsv) && SvTYPE(SvRV(qsv))==SVt_PVHV && *key=='D' &&\n                (  (kl==6 && DBIc_TYPE(imp_xxh)==DBIt_DB && strEQ(key,\"Driver\"))\n                || (kl==8 && DBIc_TYPE(imp_xxh)==DBIt_ST && strEQ(key,\"Database\")) )\n            ) {\n                qsv = Nullsv;\n            }\n            /* disable profiling of FETCH of Profile data */\n            if (*key == 'P' && strEQ(key, \"Profile\"))\n                profile_t1 = 0.0;\n        }\n        if (qsv) { /* skip real method call if we already have a 'quick' value */\n            ST(0) = sv_mortalcopy(qsv);\n            outitems = 1;\n            goto post_dispatch;\n        }\n    }\n\n    {\n        CV *meth_cv;\n#ifdef DBI_save_hv_fetch_ent\n        HE save_mh;\n        if (meth_type == methtype_FETCH)\n            save_mh = PL_hv_fetch_ent_mh; /* XXX nested tied FETCH bug17575 workaround */\n#endif\n\n        if (trace_flags) {\n            SAVEI32(DBIS->debug);       /* fall back to orig value later */\n            DBIS->debug = trace_flags;  /* make new value global (for now) */\n            if (ima) {\n                /* enabling trace via flags takes precedence over disabling due to min level */\n                if ((trace_flags & DBIc_TRACE_FLAGS_MASK) & (ima->method_trace & DBIc_TRACE_FLAGS_MASK))\n                    trace_level = (trace_level < 2) ? 2 : trace_level; /* min */\n                else\n                if (trace_level < (DBIc_TRACE_LEVEL_MASK & ima->method_trace))\n                    trace_level = 0;        /* silence dispatch log for this method */\n            }\n        }\n\n        if (is_orig_method_name\n            && ima->stash == DBIc_IMP_STASH(imp_xxh)\n            && ima->generation == PL_sub_generation +\n                                        MY_cache_gen(DBIc_IMP_STASH(imp_xxh))\n        )\n            imp_msv = (SV*)ima->gv;\n        else {\n            imp_msv = (SV*)gv_fetchmethod_autoload(DBIc_IMP_STASH(imp_xxh),\n                                            meth_name, FALSE);\n            if (is_orig_method_name) {\n                /* clear stale entry, if any */\n                SvREFCNT_dec(ima->stash);\n                SvREFCNT_dec(ima->gv);\n                if (!imp_msv) {\n                    ima->stash = NULL;\n                    ima->gv    = NULL;\n                }\n                else {\n                    ima->stash = (HV*)SvREFCNT_inc(DBIc_IMP_STASH(imp_xxh));\n                    ima->gv    = (GV*)SvREFCNT_inc(imp_msv);\n                    ima->generation = PL_sub_generation +\n                                        MY_cache_gen(DBIc_IMP_STASH(imp_xxh));\n                }\n            }\n        }\n\n        /* if method was a 'func' then try falling back to real 'func' method */\n        if (!imp_msv && (ima_flags & IMA_FUNC_REDIRECT)) {\n            imp_msv = (SV*)gv_fetchmethod_autoload(DBIc_IMP_STASH(imp_xxh), \"func\", FALSE);\n            if (imp_msv) {\n                /* driver does have func method so undo the earlier 'func' stack changes */\n                PUSHs(sv_2mortal(newSVpv(meth_name,0)));\n                PUTBACK;\n                ++items;\n                meth_name = \"func\";\n                meth_type = methtype_ordinary;\n            }\n        }\n\n        if (trace_level >= (is_nested_call ? 4 : 2)) {\n            PerlIO *logfp = DBILOGFP;\n            /* Full pkg method name (or just meth_name for ANON CODE)   */\n            const char *imp_meth_name = (imp_msv && isGV(imp_msv)) ? GvNAME(imp_msv) : meth_name;\n            HV *imp_stash = DBIc_IMP_STASH(imp_xxh);\n            PerlIO_printf(logfp, \"%c   -> %s \",\n                    call_depth>1 ? '0'+call_depth-1 : (PL_dirty?'!':' '), imp_meth_name);\n            if (imp_meth_name[0] == 'A' && strEQ(imp_meth_name,\"AUTOLOAD\"))\n                    PerlIO_printf(logfp, \"\\\"%s\\\" \", meth_name);\n            if (imp_msv && isGV(imp_msv) && GvSTASH(imp_msv) != imp_stash)\n                PerlIO_printf(logfp, \"in %s \", HvNAME(GvSTASH(imp_msv)));\n            PerlIO_printf(logfp, \"for %s (%s\", HvNAME(imp_stash),\n                        SvPV_nolen(orig_h));\n            if (h != orig_h)    /* show inner handle to aid tracing */\n                 PerlIO_printf(logfp, \"~0x%lx\", (long)SvRV(h));\n            else PerlIO_printf(logfp, \"~INNER\");\n            for(i=1; i<items; ++i) {\n                PerlIO_printf(logfp,\" %s\",\n                    (ima && i==ima->hidearg) ? \"****\" : neatsvpv(ST(i),0));\n            }\n#ifdef DBI_USE_THREADS\n            PerlIO_printf(logfp, \") thr#%p\\n\", (void*)DBIc_THR_USER(imp_xxh));\n#else\n            PerlIO_printf(logfp, \")\\n\");\n#endif\n            PerlIO_flush(logfp);\n        }\n\n        if (!imp_msv || ! ((meth_cv = GvCV(imp_msv))) ) {\n            if (PL_dirty || is_DESTROY) {\n                outitems = 0;\n                goto post_dispatch;\n            }\n            if (ima_flags & IMA_NOT_FOUND_OKAY) {\n                outitems = 0;\n                goto post_dispatch;\n            }\n            croak(\"Can't locate DBI object method \\\"%s\\\" via package \\\"%s\\\"\",\n                meth_name, HvNAME(DBIc_IMP_STASH(imp_xxh)));\n        }\n\n        PUSHMARK(mark);  /* mark arguments again so we can pass them on */\n\n        /* Note: the handle on the stack is still an object blessed into a\n         * DBI::* class and not the DBD::*::* class whose method is being\n         * invoked. This is correct and should be largely transparent.\n         */\n\n        /* SHORT-CUT ALERT! */\n        if (use_xsbypass && CvISXSUB(meth_cv) && CvXSUB(meth_cv)) {\n\n            /* If we are calling an XSUB we jump directly to its C code and\n             * bypass perl_call_sv(), pp_entersub() etc. This is fast.\n             * This code is based on a small section of pp_entersub().\n             */\n            (void)(*CvXSUB(meth_cv))(aTHXo_ meth_cv); /* Call the C code directly */\n\n            if (gimme == G_SCALAR) {    /* Enforce sanity in scalar context */\n                if (ax != PL_stack_sp - PL_stack_base ) { /* outitems != 1 */\n                    ST(0) =\n                        (ax > PL_stack_sp - PL_stack_base)\n                            ? &PL_sv_undef  /* outitems == 0 */\n                            : *PL_stack_sp; /* outitems > 1 */\n                    PL_stack_sp = PL_stack_base + ax;\n                }\n                outitems = 1;\n            }\n            else {\n                outitems = PL_stack_sp - (PL_stack_base + ax - 1);\n            }\n\n        }\n        else {\n            /* sv_dump(imp_msv); */\n            outitems = call_sv((SV*)meth_cv,\n                (is_DESTROY ? gimme | G_EVAL | G_KEEPERR : gimme) );\n        }\n\n        XSprePUSH; /* reset SP to base of stack frame */\n\n#ifdef DBI_save_hv_fetch_ent\n        if (meth_type == methtype_FETCH)\n            PL_hv_fetch_ent_mh = save_mh;       /* see start of block */\n#endif\n    }\n\n    post_dispatch:\n\n    if (is_DESTROY && DBI_IS_LAST_HANDLE(h)) { /* if destroying _this_ handle */\n        SV *lhp = DBIc_PARENT_H(imp_xxh);\n        if (lhp && SvROK(lhp)) {\n            DBI_SET_LAST_HANDLE(lhp);\n        }\n        else {\n            DBI_UNSET_LAST_HANDLE;\n        }\n    }\n\n    if (keep_error) {\n        /* if we didn't clear err before the call, check to see if a new error\n         * or warning has been recorded. If so, turn off keep_error so it gets acted on\n         */\n        if (DBIc_ErrCount(imp_xxh) > ErrCount || err_hash(aTHX_ imp_xxh) != keep_error) {\n            keep_error = 0;\n        }\n    }\n\n    err_sv = DBIc_ERR(imp_xxh);\n\n    if (trace_level >= (is_nested_call ? 3 : 1)) {\n        PerlIO *logfp = DBILOGFP;\n        const int is_fetch  = (meth_type == methtype_fetch_star && DBIc_TYPE(imp_xxh)==DBIt_ST);\n        const int row_count = (is_fetch) ? DBIc_ROW_COUNT((imp_sth_t*)imp_xxh) : 0;\n        if (is_fetch && row_count>=2 && trace_level<=4 && SvOK(ST(0))) {\n            /* skip the 'middle' rows to reduce output */\n            goto skip_meth_return_trace;\n        }\n        if (SvOK(err_sv)) {\n            PerlIO_printf(logfp, \"    %s %s %s %s (err#%ld)\\n\", (keep_error) ? \"  \" : \"!!\",\n                SvTRUE(err_sv) ? \"ERROR:\" : strlen(SvPV_nolen(err_sv)) ? \"warn:\" : \"info:\",\n                neatsvpv(err_sv,0), neatsvpv(DBIc_ERRSTR(imp_xxh),0), (long)DBIc_ErrCount(imp_xxh));\n        }\n        PerlIO_printf(logfp,\"%c%c  <%c %s\",\n                    (call_depth > 1)  ? '0'+call_depth-1 : (PL_dirty?'!':' '),\n                    (DBIc_is(imp_xxh, DBIcf_TaintIn|DBIcf_TaintOut)) ? 'T' : ' ',\n                    (qsv) ? '>' : '-',\n                    meth_name);\n        if (trace_level==1 && (items>=2||is_DESTROY)) { /* make level 1 more useful */\n            /* we only have the first two parameters available here */\n            if (is_DESTROY) /* show handle as first arg to DESTROY */\n                /* want to show outer handle so trace makes sense       */\n                /* but outer handle has been destroyed so we fake it    */\n                PerlIO_printf(logfp,\"(%s=HASH(0x%p)\", HvNAME(SvSTASH(SvRV(orig_h))), (void*)DBIc_MY_H(imp_xxh));\n            else\n                PerlIO_printf(logfp,\"(%s\", neatsvpv(st1,0));\n            if (items >= 3)\n                PerlIO_printf(logfp,\", %s\", neatsvpv(st2,0));\n            PerlIO_printf(logfp,\"%s)\", (items > 3) ? \", ...\" : \"\");\n        }\n\n        if (gimme & G_ARRAY)\n             PerlIO_printf(logfp,\"= (\");\n        else PerlIO_printf(logfp,\"=\");\n        for(i=0; i < outitems; ++i) {\n            SV *s = ST(i);\n            if ( SvROK(s) && SvTYPE(SvRV(s))==SVt_PVAV) {\n                AV *av = (AV*)SvRV(s);\n                int avi;\n                int avi_last = SvIV(DBIS->neatsvpvlen) / 10;\n                if (avi_last < 39)\n                    avi_last = 39;\n                PerlIO_printf(logfp, \" [\");\n                for (avi=0; avi <= AvFILL(av); ++avi) {\n                    PerlIO_printf(logfp, \" %s\",  neatsvpv(AvARRAY(av)[avi],0));\n                    if (avi >= avi_last && AvFILL(av) - avi > 1) {\n                        PerlIO_printf(logfp, \" ... %ld others skipped\", AvFILL(av) - avi);\n                        break;\n                    }\n                }\n                PerlIO_printf(logfp, \" ]\");\n            }\n            else {\n                PerlIO_printf(logfp, \" %s\",  neatsvpv(s,0));\n                if ( SvROK(s) && SvTYPE(SvRV(s))==SVt_PVHV && !SvOBJECT(SvRV(s)) )\n                    PerlIO_printf(logfp, \"%ldkeys\", (long)HvKEYS(SvRV(s)));\n            }\n        }\n        if (gimme & G_ARRAY) {\n            PerlIO_printf(logfp,\" ) [%d items]\", outitems);\n        }\n        if (is_fetch && row_count) {\n            PerlIO_printf(logfp,\" row%d\", row_count);\n        }\n        if (qsv) /* flag as quick and peek at the first arg (still on the stack) */\n            PerlIO_printf(logfp,\" (%s from cache)\", neatsvpv(st1,0));\n        else if (!imp_msv)\n            PerlIO_printf(logfp,\" (not implemented)\");\n        /* XXX add flag to show pid here? */\n        /* add file and line number information */\n        PerlIO_puts(logfp, log_where(0, 0, \" at \", \"\\n\", 1, (trace_level >= 3), (trace_level >= 4)));\n    skip_meth_return_trace:\n        PerlIO_flush(logfp);\n    }\n\n    if (ima_flags & IMA_END_WORK) { /* commit() or rollback() */\n        /* XXX does not consider if the method call actually worked or not */\n        DBIc_off(imp_xxh, DBIcf_Executed);\n\n        if (DBIc_has(imp_xxh, DBIcf_BegunWork)) {\n            DBIc_off(imp_xxh, DBIcf_BegunWork);\n            if (!DBIc_has(imp_xxh, DBIcf_AutoCommit)) {\n                /* We only get here if the driver hasn't implemented their own code     */\n                /* for begin_work, or has but hasn't correctly turned AutoCommit        */\n                /* back on in their commit or rollback code. So we have to do it.       */\n                /* This is bad because it'll probably trigger a spurious commit()       */\n                /* and may mess up the error handling below for the commit/rollback     */\n                PUSHMARK(SP);\n                XPUSHs(h);\n                XPUSHs(sv_2mortal(newSVpv(\"AutoCommit\",0)));\n                XPUSHs(&PL_sv_yes);\n                PUTBACK;\n                call_method(\"STORE\", G_DISCARD);\n                SPAGAIN;\n            }\n        }\n    }\n\n    if (PL_tainting\n        && DBIc_is(imp_xxh, DBIcf_TaintOut)   /* taint checks requested */\n        /* XXX this would taint *everything* being returned from *any*  */\n        /* method that doesn't have IMA_NO_TAINT_OUT set.               */\n        /* DISABLED: just tainting fetched data in get_fbav seems ok    */\n        && 0/* XXX disabled*/ /* !(ima_flags & IMA_NO_TAINT_OUT) */\n    ) {\n        dTHR;\n        TAINT; /* affects sv_setsv()'s within same perl statement */\n        for(i=0; i < outitems; ++i) {\n            I32 avi;\n            char *p;\n            SV *s;\n            SV *agg = ST(i);\n            if ( !SvROK(agg) )\n                continue;\n            agg = SvRV(agg);\n#define DBI_OUT_TAINTABLE(s) (!SvREADONLY(s) && !SvTAINTED(s))\n            switch (SvTYPE(agg)) {\n            case SVt_PVAV:\n                for(avi=0; avi <= AvFILL((AV*)agg); ++avi) {\n                    s = AvARRAY((AV*)agg)[avi];\n                    if (DBI_OUT_TAINTABLE(s))\n                        SvTAINTED_on(s);\n                }\n                break;\n            case SVt_PVHV:\n                hv_iterinit((HV*)agg);\n                while( (s = hv_iternextsv((HV*)agg, &p, &avi)) ) {\n                    if (DBI_OUT_TAINTABLE(s))\n                        SvTAINTED_on(s);\n                }\n                break;\n            default:\n                if (DBIc_WARN(imp_xxh)) {\n                    PerlIO_printf(DBILOGFP,\"Don't know how to taint contents of returned %s (type %d)\\n\",\n                        neatsvpv(agg,0), (int)SvTYPE(agg));\n                }\n            }\n        }\n    }\n\n    /* if method returned a new handle, and that handle has an error on it\n     * then copy the error up into the parent handle\n     */\n    if (ima_flags & IMA_IS_FACTORY && SvROK(ST(0))) {\n        SV *h_new = ST(0);\n        D_impdata(imp_xxh_new, imp_xxh_t, h_new);\n        if (SvOK(DBIc_ERR(imp_xxh_new))) {\n            set_err_sv(h, imp_xxh, DBIc_ERR(imp_xxh_new), DBIc_ERRSTR(imp_xxh_new), DBIc_STATE(imp_xxh_new), &PL_sv_no);\n        }\n    }\n\n    if (   !keep_error                  /* is a new err/warn/info               */\n        && !is_nested_call              /* skip nested (internal) calls         */\n        && (\n               /* is an error and has RaiseError|PrintError|HandleError set     */\n           (SvTRUE(err_sv) && DBIc_has(imp_xxh, DBIcf_RaiseError|DBIcf_PrintError|DBIcf_HandleError))\n               /* is a warn (not info) and has PrintWarn set            */\n        || (  SvOK(err_sv) && strlen(SvPV_nolen(err_sv)) && DBIc_has(imp_xxh, DBIcf_PrintWarn))\n        )\n    ) {\n        SV *msg;\n        SV **statement_svp = NULL;\n        const int is_warning = (!SvTRUE(err_sv) && strlen(SvPV_nolen(err_sv))==1);\n        const char *err_meth_name = meth_name;\n        char intro[200];\n\n        if (meth_type == methtype_set_err) {\n            SV **sem_svp = hv_fetch((HV*)SvRV(h), \"dbi_set_err_method\", 18, GV_ADDWARN);\n            if (SvOK(*sem_svp))\n                err_meth_name = SvPV_nolen(*sem_svp);\n        }\n\n        /* XXX change to vsprintf into sv directly */\n        sprintf(intro,\"%s %s %s: \", HvNAME(DBIc_IMP_STASH(imp_xxh)), err_meth_name,\n            SvTRUE(err_sv) ? \"failed\" : is_warning ? \"warning\" : \"information\");\n        msg = sv_2mortal(newSVpv(intro,0));\n        if (SvOK(DBIc_ERRSTR(imp_xxh)))\n            sv_catsv(msg, DBIc_ERRSTR(imp_xxh));\n        else\n            sv_catpvf(msg, \"(err=%s, errstr=undef, state=%s)\",\n                neatsvpv(DBIc_ERR(imp_xxh),0), neatsvpv(DBIc_STATE(imp_xxh),0) );\n\n        if (    DBIc_has(imp_xxh, DBIcf_ShowErrorStatement)\n            && !is_unrelated_to_Statement\n            && (DBIc_TYPE(imp_xxh) == DBIt_ST || ima_flags & IMA_SHOW_ERR_STMT)\n            && (statement_svp = hv_fetch((HV*)SvRV(h), \"Statement\", 9, 0))\n            &&  statement_svp && SvOK(*statement_svp)\n        ) {\n            SV **svp = 0;\n            sv_catpv(msg, \" [for Statement \\\"\");\n            sv_catsv(msg, *statement_svp);\n\n            /* fetch from tied outer handle to trigger FETCH magic  */\n            /* could add DBIcf_ShowErrorParams (default to on?)         */\n            if (!(ima_flags & IMA_HIDE_ERR_PARAMVALUES)) {\n                svp = hv_fetch((HV*)DBIc_MY_H(imp_xxh),\"ParamValues\",11,FALSE);\n                if (svp && SvMAGICAL(*svp))\n                    mg_get(*svp); /* XXX may recurse, may croak. could use eval */\n            }\n            if (svp && SvRV(*svp) && SvTYPE(SvRV(*svp)) == SVt_PVHV && HvKEYS(SvRV(*svp))>0 ) {\n                SV *param_values_sv = sv_2mortal(_join_hash_sorted((HV*)SvRV(*svp), \"=\",1, \", \",2, 1, -1));\n                sv_catpv(msg, \"\\\" with ParamValues: \");\n                sv_catsv(msg, param_values_sv);\n                sv_catpvn(msg, \"]\", 1);\n            }\n            else {\n                sv_catpv(msg, \"\\\"]\");\n            }\n        }\n\n        if (0) {\n            COP *cop = dbi_caller_cop();\n            if (cop && (CopLINE(cop) != CopLINE(PL_curcop) || CopFILEGV(cop) != CopFILEGV(PL_curcop))) {\n                dbi_caller_string(msg, cop, \" called via \", 1, 0);\n            }\n        }\n\n        hook_svp = NULL;\n        if (    SvTRUE(err_sv)\n            &&  DBIc_has(imp_xxh, DBIcf_HandleError)\n            && (hook_svp = hv_fetch((HV*)SvRV(h),\"HandleError\",11,0))\n            &&  hook_svp && SvOK(*hook_svp)\n        ) {\n            dSP;\n            PerlIO *logfp = DBILOGFP;\n            IV items;\n            SV *status;\n            SV *result; /* point to result SV that's pointed to by the stack */\n            if (outitems) {\n                result = *(sp-outitems+1);\n                if (SvREADONLY(result)) {\n                    *(sp-outitems+1) = result = sv_2mortal(newSVsv(result));\n                }\n            }\n            else {\n                result = sv_newmortal();\n            }\n            if (trace_level)\n                PerlIO_printf(logfp,\"    -> HandleError on %s via %s%s%s%s\\n\",\n                    neatsvpv(h,0), neatsvpv(*hook_svp,0),\n                    (!outitems ? \"\" : \" (\"),\n                    (!outitems ? \"\" : neatsvpv(result ,0)),\n                    (!outitems ? \"\" : \")\")\n                );\n            PUSHMARK(SP);\n            XPUSHs(msg);\n            XPUSHs(sv_2mortal(newRV_inc((SV*)DBIc_MY_H(imp_xxh))));\n            XPUSHs( result );\n            PUTBACK;\n            items = call_sv(*hook_svp, G_SCALAR);\n            SPAGAIN;\n            status = (items) ? POPs : &PL_sv_undef;\n            PUTBACK;\n            if (trace_level)\n                PerlIO_printf(logfp,\"    <- HandleError= %s%s%s%s\\n\",\n                    neatsvpv(status,0),\n                    (!outitems ? \"\" : \" (\"),\n                    (!outitems ? \"\" : neatsvpv(result,0)),\n                    (!outitems ? \"\" : \")\")\n                );\n            if (!SvTRUE(status)) /* handler says it didn't handle it, so... */\n                hook_svp = 0;  /* pretend we didn't have a handler...     */\n        }\n\n        if (profile_t1) { /* see also dbi_profile() call a few lines below */\n            SV *statement_sv = (is_unrelated_to_Statement) ? &PL_sv_no : &PL_sv_undef;\n            dbi_profile(h, imp_xxh, statement_sv, imp_msv ? imp_msv : (SV*)cv,\n                profile_t1, dbi_time());\n        }\n        if (is_warning) {\n            if (DBIc_has(imp_xxh, DBIcf_PrintWarn))\n                warn(\"%s\", SvPV_nolen(msg));\n        }\n        else if (!hook_svp && SvTRUE(err_sv)) {\n            if (DBIc_has(imp_xxh, DBIcf_PrintError))\n                warn(\"%s\", SvPV_nolen(msg));\n            if (DBIc_has(imp_xxh, DBIcf_RaiseError))\n                croak(\"%s\", SvPV_nolen(msg));\n        }\n    }\n    else if (profile_t1) { /* see also dbi_profile() call a few lines above */\n        SV *statement_sv = (is_unrelated_to_Statement) ? &PL_sv_no : &PL_sv_undef;\n        dbi_profile(h, imp_xxh, statement_sv, imp_msv ? imp_msv : (SV*)cv,\n                profile_t1, dbi_time());\n    }\n    XSRETURN(outitems);\n}\n\n\n\n/* -------------------------------------------------------------------- */\n\n/* comment and placeholder styles to accept and return */\n\n#define DBIpp_cm_cs 0x000001   /* C style */\n#define DBIpp_cm_hs 0x000002   /* #       */\n#define DBIpp_cm_dd 0x000004   /* --      */\n#define DBIpp_cm_br 0x000008   /* {}      */\n#define DBIpp_cm_dw 0x000010   /* '-- ' dash dash whitespace */\n#define DBIpp_cm_XX 0x00001F   /* any of the above */\n\n#define DBIpp_ph_qm 0x000100   /* ?       */\n#define DBIpp_ph_cn 0x000200   /* :1      */\n#define DBIpp_ph_cs 0x000400   /* :name   */\n#define DBIpp_ph_sp 0x000800   /* %s (as return only, not accept)    */\n#define DBIpp_ph_XX 0x000F00   /* any of the above */\n\n#define DBIpp_st_qq 0x010000   /* '' char escape */\n#define DBIpp_st_bs 0x020000   /* \\  char escape */\n#define DBIpp_st_XX 0x030000   /* any of the above */\n\n#define DBIpp_L_BRACE '{'\n#define DBIpp_R_BRACE '}'\n#define PS_accept(flag)  DBIbf_has(ps_accept,(flag))\n#define PS_return(flag)  DBIbf_has(ps_return,(flag))\n\nSV *\npreparse(SV *dbh, const char *statement, IV ps_return, IV ps_accept, void *foo)\n{\n    dTHX;\n    D_imp_xxh(dbh);\n/*\n        The idea here is that ps_accept defines which constructs to\n        recognize (accept) as valid in the source string (other\n        constructs are ignored), and ps_return defines which\n        constructs are valid to return in the result string.\n\n        If a construct that is valid in the input is also valid in the\n        output then it's simply copied. If it's not valid in the output\n        then it's editied into one of the valid forms (ideally the most\n        'standard' and/or information preserving one).\n\n        For example, if ps_accept includes '--' style comments but\n        ps_return doesn't, but ps_return does include '#' style\n        comments then any '--' style comments would be rewritten as '#'\n        style comments.\n\n        Similarly for placeholders. DBD::Oracle, for example, would say\n        '?', ':1' and ':name' are all acceptable input, but only\n        ':name' should be returned.\n\n        (There's a tricky issue with the '--' comment style because it can\n        clash with valid syntax, i.e., \"... set foo=foo--1 ...\" so it\n        would be *bad* to misinterpret that as the start of a comment.\n        Perhaps we need a DBIpp_cm_dw (for dash-dash-whitespace) style\n        to allow for that.)\n\n        Also, we'll only support DBIpp_cm_br as an input style. And\n        even then, only with reluctance. We may (need to) drop it when\n        we add support for odbc escape sequences.\n*/\n    int idx = 1;\n\n    char in_quote = '\\0';\n    char in_comment = '\\0';\n    char rt_comment = '\\0';\n    char *dest, *start;\n    const char *src;\n    const char *style = \"\", *laststyle = '\\0';\n    SV *new_stmt_sv;\n\n    (void)foo;\n\n    if (!(ps_return | DBIpp_ph_XX)) { /* no return ph type specified */\n        ps_return |= ps_accept | DBIpp_ph_XX;   /* so copy from ps_accept */\n    }\n\n    /* XXX this allocation strategy won't work when we get to more advanced stuff */\n    new_stmt_sv = newSV(strlen(statement) * 3);\n    sv_setpv(new_stmt_sv,\"\");\n    src  = statement;\n    dest = SvPVX(new_stmt_sv);\n\n    while( *src )\n    {\n        if (*src == '%' && PS_return(DBIpp_ph_sp))\n            *dest++ = '%';\n\n        if (in_comment)\n        {\n             if (       (in_comment == '-' && (*src == '\\n' || *(src+1) == '\\0'))\n                ||      (in_comment == '#' && (*src == '\\n' || *(src+1) == '\\0'))\n                ||      (in_comment == DBIpp_L_BRACE && *src == DBIpp_R_BRACE) /* XXX nesting? */\n                ||      (in_comment == '/' && *src == '*' && *(src+1) == '/')\n             ) {\n                switch (rt_comment) {\n                case '/':       *dest++ = '*'; *dest++ = '/';   break;\n                case '-':       *dest++ = '\\n';                 break;\n                case '#':       *dest++ = '\\n';                 break;\n                case DBIpp_L_BRACE: *dest++ = DBIpp_R_BRACE;    break;\n                case '\\0':      /* ensure deleting a comment doesn't join two tokens */\n                        if (in_comment=='/' || in_comment==DBIpp_L_BRACE)\n                            *dest++ = ' '; /* ('-' and '#' styles use the newline) */\n                        break;\n                }\n                if (in_comment == '/')\n                    src++;\n                src += (*src != '\\n' || *(dest-1)=='\\n') ? 1 : 0;\n                in_comment = '\\0';\n                rt_comment = '\\0';\n             }\n             else\n             if (rt_comment)\n                *dest++ = *src++;\n             else\n                src++;  /* delete (don't copy) the comment */\n             continue;\n        }\n\n        if (in_quote)\n        {\n            if (*src == in_quote) {\n                in_quote = 0;\n            }\n            *dest++ = *src++;\n            continue;\n        }\n\n        /* Look for comments */\n        if (*src == '-' && *(src+1) == '-' &&\n                (PS_accept(DBIpp_cm_dd) || (*(src+2) == ' ' && PS_accept(DBIpp_cm_dw)))\n        )\n        {\n            in_comment = *src;\n            src += 2;   /* skip past 2nd char of double char delimiters */\n            if (PS_return(DBIpp_cm_dd) || PS_return(DBIpp_cm_dw)) {\n                *dest++ = rt_comment = '-';\n                *dest++ = '-';\n                if (PS_return(DBIpp_cm_dw) && *src!=' ')\n                    *dest++ = ' '; /* insert needed white space */\n            }\n            else if (PS_return(DBIpp_cm_cs)) {\n                *dest++ = rt_comment = '/';\n                *dest++ = '*';\n            }\n            else if (PS_return(DBIpp_cm_hs)) {\n                *dest++ = rt_comment = '#';\n            }\n            else if (PS_return(DBIpp_cm_br)) {\n                *dest++ = rt_comment = DBIpp_L_BRACE;\n            }\n            continue;\n        }\n        else if (*src == '/' && *(src+1) == '*' && PS_accept(DBIpp_cm_cs))\n        {\n            in_comment = *src;\n            src += 2;   /* skip past 2nd char of double char delimiters */\n            if (PS_return(DBIpp_cm_cs)) {\n                *dest++ = rt_comment = '/';\n                *dest++ = '*';\n            }\n            else if (PS_return(DBIpp_cm_dd) || PS_return(DBIpp_cm_dw)) {\n                *dest++ = rt_comment = '-';\n                *dest++ = '-';\n                if (PS_return(DBIpp_cm_dw)) *dest++ = ' ';\n            }\n            else if (PS_return(DBIpp_cm_hs)) {\n                *dest++ = rt_comment = '#';\n            }\n            else if (PS_return(DBIpp_cm_br)) {\n                *dest++ = rt_comment = DBIpp_L_BRACE;\n            }\n            continue;\n        }\n        else if (*src == '#' && PS_accept(DBIpp_cm_hs))\n        {\n            in_comment = *src;\n            src++;\n            if (PS_return(DBIpp_cm_hs)) {\n                *dest++ = rt_comment = '#';\n            }\n            else if (PS_return(DBIpp_cm_dd) || PS_return(DBIpp_cm_dw)) {\n                *dest++ = rt_comment = '-';\n                *dest++ = '-';\n                if (PS_return(DBIpp_cm_dw)) *dest++ = ' ';\n            }\n            else if (PS_return(DBIpp_cm_cs)) {\n                *dest++ = rt_comment = '/';\n                *dest++ = '*';\n            }\n            else if (PS_return(DBIpp_cm_br)) {\n                *dest++ = rt_comment = DBIpp_L_BRACE;\n            }\n            continue;\n        }\n        else if (*src == DBIpp_L_BRACE && PS_accept(DBIpp_cm_br))\n        {\n            in_comment = *src;\n            src++;\n            if (PS_return(DBIpp_cm_br)) {\n                *dest++ = rt_comment = DBIpp_L_BRACE;\n            }\n            else if (PS_return(DBIpp_cm_dd) || PS_return(DBIpp_cm_dw)) {\n                *dest++ = rt_comment = '-';\n                *dest++ = '-';\n                if (PS_return(DBIpp_cm_dw)) *dest++ = ' ';\n            }\n            else if (PS_return(DBIpp_cm_cs)) {\n                *dest++ = rt_comment = '/';\n                *dest++ = '*';\n            }\n            else if (PS_return(DBIpp_cm_hs)) {\n                *dest++ = rt_comment = '#';\n            }\n            continue;\n        }\n\n       if (    !(*src==':' && (PS_accept(DBIpp_ph_cn) || PS_accept(DBIpp_ph_cs)))\n           &&  !(*src=='?' &&  PS_accept(DBIpp_ph_qm))\n       ){\n            if (*src == '\\'' || *src == '\"')\n                in_quote = *src;\n            *dest++ = *src++;\n            continue;\n        }\n\n        /* only here for : or ? outside of a comment or literal */\n\n        start = dest;                   /* save name inc colon  */\n        *dest++ = *src++;               /* copy and move past first char */\n\n        if (*start == '?')              /* X/Open Standard */\n        {\n            style = \"?\";\n\n            if (PS_return(DBIpp_ph_qm))\n                ;\n            else if (PS_return(DBIpp_ph_cn)) { /* '?' -> ':p1' (etc) */\n                sprintf(start,\":p%d\", idx++);\n                dest = start+strlen(start);\n            }\n            else if (PS_return(DBIpp_ph_sp)) { /* '?' -> '%s' */\n                   *start  = '%';\n                   *dest++ = 's';\n            }\n        }\n        else if (isDIGIT(*src)) {   /* :1 */\n            const int pln = atoi(src);\n            style = \":1\";\n\n            if (PS_return(DBIpp_ph_cn)) { /* ':1'->':p1'  */\n                   idx = pln;\n                   *dest++ = 'p';\n                   while(isDIGIT(*src))\n                       *dest++ = *src++;\n            }\n            else if (PS_return(DBIpp_ph_qm) /* ':1' -> '?'  */\n                 ||  PS_return(DBIpp_ph_sp) /* ':1' -> '%s' */\n            ) {\n                   PS_return(DBIpp_ph_qm) ? sprintf(start,\"?\") : sprintf(start,\"%%s\");\n                   dest = start + strlen(start);\n                   if (pln != idx) {\n                        char buf[99];\n                        sprintf(buf, \"preparse found placeholder :%d out of sequence, expected :%d\", pln, idx);\n                        set_err_char(dbh, imp_xxh, \"1\", 1, buf, 0, \"preparse\");\n                        return &PL_sv_undef;\n                   }\n                   while(isDIGIT(*src)) src++;\n                   idx++;\n            }\n        }\n        else if (isALNUM(*src))         /* :name */\n        {\n            style = \":name\";\n\n            if (PS_return(DBIpp_ph_cs)) {\n                ;\n            }\n            else if (PS_return(DBIpp_ph_qm) /* ':name' -> '?'  */\n                 ||  PS_return(DBIpp_ph_sp) /* ':name' -> '%s' */\n            ) {\n                PS_return(DBIpp_ph_qm) ? sprintf(start,\"?\") : sprintf(start,\"%%s\");\n                dest = start + strlen(start);\n                while (isALNUM(*src))   /* consume name, includes '_'   */\n                    src++;\n            }\n        }\n        /* perhaps ':=' PL/SQL construct */\n        else { continue; }\n\n        *dest = '\\0';                   /* handy for debugging  */\n\n        if (laststyle && style != laststyle) {\n            char buf[99];\n            sprintf(buf, \"preparse found mixed placeholder styles (%s / %s)\", style, laststyle);\n            set_err_char(dbh, imp_xxh, \"1\", 1, buf, 0, \"preparse\");\n            return &PL_sv_undef;\n        }\n        laststyle = style;\n    }\n    *dest = '\\0';\n\n    /* warn about probable parsing errors, but continue anyway (returning processed string) */\n    switch (in_quote)\n    {\n    case '\\'':\n            set_err_char(dbh, imp_xxh, \"1\", 1, \"preparse found unterminated single-quoted string\", 0, \"preparse\");\n            break;\n    case '\\\"':\n            set_err_char(dbh, imp_xxh, \"1\", 1, \"preparse found unterminated double-quoted string\", 0, \"preparse\");\n            break;\n    }\n    switch (in_comment)\n    {\n    case DBIpp_L_BRACE:\n            set_err_char(dbh, imp_xxh, \"1\", 1, \"preparse found unterminated bracketed {...} comment\", 0, \"preparse\");\n            break;\n    case '/':\n            set_err_char(dbh, imp_xxh, \"1\", 1, \"preparse found unterminated bracketed C-style comment\", 0, \"preparse\");\n            break;\n    }\n\n    SvCUR_set(new_stmt_sv, strlen(SvPVX(new_stmt_sv)));\n    *SvEND(new_stmt_sv) = '\\0';\n    return new_stmt_sv;\n}\n\n\n/* -------------------------------------------------------------------- */\n/* The DBI Perl interface (via XS) starts here. Currently these are     */\n/* all internal support functions. Note install_method and see DBI.pm   */\n\nMODULE = DBI   PACKAGE = DBI\n\nREQUIRE:    1.929\nPROTOTYPES: DISABLE\n\n\nBOOT:\n    {\n        MY_CXT_INIT;\n        PERL_UNUSED_VAR(MY_CXT);\n    }\n    PERL_UNUSED_VAR(cv);\n    PERL_UNUSED_VAR(items);\n    dbi_bootinit(NULL);\n    /* make this sub into a fake XS so it can bee seen by DBD::* modules;\n     * never actually call it as an XS sub, or it will crash and burn! */\n    (void) newXS(\"DBI::_dbi_state_lval\", (XSUBADDR_t)_dbi_state_lval, __FILE__);\n\n\nI32\nconstant()\n        PROTOTYPE:\n    ALIAS:\n        SQL_ALL_TYPES                    = SQL_ALL_TYPES\n        SQL_ARRAY                        = SQL_ARRAY\n        SQL_ARRAY_LOCATOR                = SQL_ARRAY_LOCATOR\n        SQL_BIGINT                       = SQL_BIGINT\n        SQL_BINARY                       = SQL_BINARY\n        SQL_BIT                          = SQL_BIT\n        SQL_BLOB                         = SQL_BLOB\n        SQL_BLOB_LOCATOR                 = SQL_BLOB_LOCATOR\n        SQL_BOOLEAN                      = SQL_BOOLEAN\n        SQL_CHAR                         = SQL_CHAR\n        SQL_CLOB                         = SQL_CLOB\n        SQL_CLOB_LOCATOR                 = SQL_CLOB_LOCATOR\n        SQL_DATE                         = SQL_DATE\n        SQL_DATETIME                     = SQL_DATETIME\n        SQL_DECIMAL                      = SQL_DECIMAL\n        SQL_DOUBLE                       = SQL_DOUBLE\n        SQL_FLOAT                        = SQL_FLOAT\n        SQL_GUID                         = SQL_GUID\n        SQL_INTEGER                      = SQL_INTEGER\n        SQL_INTERVAL                     = SQL_INTERVAL\n        SQL_INTERVAL_DAY                 = SQL_INTERVAL_DAY\n        SQL_INTERVAL_DAY_TO_HOUR         = SQL_INTERVAL_DAY_TO_HOUR\n        SQL_INTERVAL_DAY_TO_MINUTE       = SQL_INTERVAL_DAY_TO_MINUTE\n        SQL_INTERVAL_DAY_TO_SECOND       = SQL_INTERVAL_DAY_TO_SECOND\n        SQL_INTERVAL_HOUR                = SQL_INTERVAL_HOUR\n        SQL_INTERVAL_HOUR_TO_MINUTE      = SQL_INTERVAL_HOUR_TO_MINUTE\n        SQL_INTERVAL_HOUR_TO_SECOND      = SQL_INTERVAL_HOUR_TO_SECOND\n        SQL_INTERVAL_MINUTE              = SQL_INTERVAL_MINUTE\n        SQL_INTERVAL_MINUTE_TO_SECOND    = SQL_INTERVAL_MINUTE_TO_SECOND\n        SQL_INTERVAL_MONTH               = SQL_INTERVAL_MONTH\n        SQL_INTERVAL_SECOND              = SQL_INTERVAL_SECOND\n        SQL_INTERVAL_YEAR                = SQL_INTERVAL_YEAR\n        SQL_INTERVAL_YEAR_TO_MONTH       = SQL_INTERVAL_YEAR_TO_MONTH\n        SQL_LONGVARBINARY                = SQL_LONGVARBINARY\n        SQL_LONGVARCHAR                  = SQL_LONGVARCHAR\n        SQL_MULTISET                     = SQL_MULTISET\n        SQL_MULTISET_LOCATOR             = SQL_MULTISET_LOCATOR\n        SQL_NUMERIC                      = SQL_NUMERIC\n        SQL_REAL                         = SQL_REAL\n        SQL_REF                          = SQL_REF\n        SQL_ROW                          = SQL_ROW\n        SQL_SMALLINT                     = SQL_SMALLINT\n        SQL_TIME                         = SQL_TIME\n        SQL_TIMESTAMP                    = SQL_TIMESTAMP\n        SQL_TINYINT                      = SQL_TINYINT\n        SQL_TYPE_DATE                    = SQL_TYPE_DATE\n        SQL_TYPE_TIME                    = SQL_TYPE_TIME\n        SQL_TYPE_TIMESTAMP               = SQL_TYPE_TIMESTAMP\n        SQL_TYPE_TIMESTAMP_WITH_TIMEZONE = SQL_TYPE_TIMESTAMP_WITH_TIMEZONE\n        SQL_TYPE_TIME_WITH_TIMEZONE      = SQL_TYPE_TIME_WITH_TIMEZONE\n        SQL_UDT                          = SQL_UDT\n        SQL_UDT_LOCATOR                  = SQL_UDT_LOCATOR\n        SQL_UNKNOWN_TYPE                 = SQL_UNKNOWN_TYPE\n        SQL_VARBINARY                    = SQL_VARBINARY\n        SQL_VARCHAR                      = SQL_VARCHAR\n        SQL_WCHAR                        = SQL_WCHAR\n        SQL_WLONGVARCHAR                 = SQL_WLONGVARCHAR\n        SQL_WVARCHAR                     = SQL_WVARCHAR\n        SQL_CURSOR_FORWARD_ONLY          = SQL_CURSOR_FORWARD_ONLY\n        SQL_CURSOR_KEYSET_DRIVEN         = SQL_CURSOR_KEYSET_DRIVEN\n        SQL_CURSOR_DYNAMIC               = SQL_CURSOR_DYNAMIC\n        SQL_CURSOR_STATIC                = SQL_CURSOR_STATIC\n        SQL_CURSOR_TYPE_DEFAULT          = SQL_CURSOR_TYPE_DEFAULT\n        DBIpp_cm_cs     = DBIpp_cm_cs\n        DBIpp_cm_hs     = DBIpp_cm_hs\n        DBIpp_cm_dd     = DBIpp_cm_dd\n        DBIpp_cm_dw     = DBIpp_cm_dw\n        DBIpp_cm_br     = DBIpp_cm_br\n        DBIpp_cm_XX     = DBIpp_cm_XX\n        DBIpp_ph_qm     = DBIpp_ph_qm\n        DBIpp_ph_cn     = DBIpp_ph_cn\n        DBIpp_ph_cs     = DBIpp_ph_cs\n        DBIpp_ph_sp     = DBIpp_ph_sp\n        DBIpp_ph_XX     = DBIpp_ph_XX\n        DBIpp_st_qq     = DBIpp_st_qq\n        DBIpp_st_bs     = DBIpp_st_bs\n        DBIpp_st_XX     = DBIpp_st_XX\n        DBIstcf_DISCARD_STRING  = DBIstcf_DISCARD_STRING\n        DBIstcf_STRICT          = DBIstcf_STRICT\n        DBIf_TRACE_SQL  = DBIf_TRACE_SQL\n        DBIf_TRACE_CON  = DBIf_TRACE_CON\n        DBIf_TRACE_ENC  = DBIf_TRACE_ENC\n        DBIf_TRACE_DBD  = DBIf_TRACE_DBD\n        DBIf_TRACE_TXN  = DBIf_TRACE_TXN\n    CODE:\n    RETVAL = ix;\n    OUTPUT:\n    RETVAL\n\n\nvoid\n_clone_dbis()\n    CODE:\n    dMY_CXT;\n    dbistate_t * parent_dbis = DBIS;\n\n    (void)cv;\n    {\n        MY_CXT_CLONE;\n    }\n    dbi_bootinit(parent_dbis);\n\n\nvoid\n_new_handle(class, parent, attr_ref, imp_datasv, imp_class)\n    SV *        class\n    SV *        parent\n    SV *        attr_ref\n    SV *        imp_datasv\n    SV *        imp_class\n    PPCODE:\n    dMY_CXT;\n    HV *outer;\n    SV *outer_ref;\n    HV *class_stash = gv_stashsv(class, GV_ADDWARN);\n\n    if (DBIS_TRACE_LEVEL >= 5) {\n        PerlIO_printf(DBILOGFP, \"    New %s (for %s, parent=%s, id=%s)\\n\",\n            neatsvpv(class,0), SvPV_nolen(imp_class), neatsvpv(parent,0), neatsvpv(imp_datasv,0));\n        PERL_UNUSED_VAR(cv);\n    }\n\n    (void)hv_store((HV*)SvRV(attr_ref), \"ImplementorClass\", 16, SvREFCNT_inc(imp_class), 0);\n\n    /* make attr into inner handle by blessing it into class */\n    sv_bless(attr_ref, class_stash);\n    /* tie new outer hash to inner handle */\n    outer = newHV(); /* create new hash to be outer handle */\n    outer_ref = newRV_noinc((SV*)outer);\n    /* make outer hash into a handle by blessing it into class */\n    sv_bless(outer_ref, class_stash);\n    /* tie outer handle to inner handle */\n    sv_magic((SV*)outer, attr_ref, PERL_MAGIC_tied, Nullch, 0);\n\n    dbih_setup_handle(aTHX_ outer_ref, SvPV_nolen(imp_class), parent, SvOK(imp_datasv) ? imp_datasv : Nullsv);\n\n    /* return outer handle, plus inner handle if not in scalar context */\n    sv_2mortal(outer_ref);\n    EXTEND(SP, 2);\n    PUSHs(outer_ref);\n    if (GIMME != G_SCALAR) {\n        PUSHs(attr_ref);\n    }\n\n\nvoid\n_setup_handle(sv, imp_class, parent, imp_datasv)\n    SV *        sv\n    char *      imp_class\n    SV *        parent\n    SV *        imp_datasv\n    CODE:\n    (void)cv;\n    dbih_setup_handle(aTHX_ sv, imp_class, parent, SvOK(imp_datasv) ? imp_datasv : Nullsv);\n    ST(0) = &PL_sv_undef;\n\n\nvoid\n_get_imp_data(sv)\n    SV *        sv\n    CODE:\n    D_imp_xxh(sv);\n    (void)cv;\n    ST(0) = sv_mortalcopy(DBIc_IMP_DATA(imp_xxh)); /* okay if NULL      */\n\n\nvoid\n_handles(sv)\n    SV *        sv\n    PPCODE:\n    /* return the outer and inner handle for any given handle */\n    D_imp_xxh(sv);\n    SV *ih = sv_mortalcopy( dbih_inner(aTHX_ sv, \"_handles\") );\n    SV *oh = sv_2mortal(newRV_inc((SV*)DBIc_MY_H(imp_xxh))); /* XXX dangerous */\n    (void)cv;\n    EXTEND(SP, 2);\n    PUSHs(oh);  /* returns outer handle then inner */\n    if (GIMME != G_SCALAR) {\n        PUSHs(ih);\n    }\n\n\nvoid\nneat(sv, maxlen=0)\n    SV *        sv\n    U32 maxlen\n    CODE:\n    ST(0) = sv_2mortal(newSVpv(neatsvpv(sv, maxlen), 0));\n    (void)cv;\n\n\nI32\nhash(key, type=0)\n    const char *key\n    long type\n    CODE:\n    (void)cv;\n    RETVAL = dbi_hash(key, type);\n    OUTPUT:\n    RETVAL\n\nvoid\nlooks_like_number(...)\n    PPCODE:\n    int i;\n    EXTEND(SP, items);\n    (void)cv;\n    for(i=0; i < items ; ++i) {\n        SV *sv = ST(i);\n        if (!SvOK(sv) || (SvPOK(sv) && SvCUR(sv)==0))\n            PUSHs(&PL_sv_undef);\n        else if ( looks_like_number(sv) )\n            PUSHs(&PL_sv_yes);\n        else\n            PUSHs(&PL_sv_no);\n    }\n\n\nvoid\n_install_method(dbi_class, meth_name, file, attribs=Nullsv)\n    const char *        dbi_class\n    char *      meth_name\n    char *      file\n    SV *        attribs\n    CODE:\n    {\n    dMY_CXT;\n    /* install another method name/interface for the DBI dispatcher     */\n    SV *trace_msg = (DBIS_TRACE_LEVEL >= 10) ? sv_2mortal(newSVpv(\"\",0)) : Nullsv;\n    CV *cv;\n    SV **svp;\n    dbi_ima_t *ima;\n    MAGIC *mg;\n    (void)dbi_class;\n\n    if (strnNE(meth_name, \"DBI::\", 5))  /* XXX m/^DBI::\\w+::\\w+$/       */\n        croak(\"install_method %s: invalid class\", meth_name);\n\n    if (trace_msg)\n        sv_catpvf(trace_msg, \"install_method %-21s\", meth_name);\n\n    Newxz(ima, 1, dbi_ima_t);\n\n    if (attribs && SvOK(attribs)) {\n        /* convert and store method attributes in a fast access form    */\n        if (SvTYPE(SvRV(attribs)) != SVt_PVHV)\n            croak(\"install_method %s: bad attribs\", meth_name);\n\n        DBD_ATTRIB_GET_IV(attribs, \"O\",1, svp, ima->flags);\n        DBD_ATTRIB_GET_UV(attribs, \"T\",1, svp, ima->method_trace);\n        DBD_ATTRIB_GET_IV(attribs, \"H\",1, svp, ima->hidearg);\n\n        if (trace_msg) {\n            if (ima->flags)       sv_catpvf(trace_msg, \", flags 0x%04x\", (unsigned)ima->flags);\n            if (ima->method_trace)sv_catpvf(trace_msg, \", T 0x%08lx\", (unsigned long)ima->method_trace);\n            if (ima->hidearg)     sv_catpvf(trace_msg, \", H %u\", (unsigned)ima->hidearg);\n        }\n        if ( (svp=DBD_ATTRIB_GET_SVP(attribs, \"U\",1)) != NULL) {\n            AV *av = (AV*)SvRV(*svp);\n            ima->minargs = (U8)SvIV(*av_fetch(av, 0, 1));\n            ima->maxargs = (U8)SvIV(*av_fetch(av, 1, 1));\n            svp = av_fetch(av, 2, 0);\n            ima->usage_msg = (svp) ? savepv_using_sv(SvPV_nolen(*svp)) : \"\";\n            ima->flags |= IMA_HAS_USAGE;\n            if (trace_msg && DBIS_TRACE_LEVEL >= 11)\n                sv_catpvf(trace_msg, \",\\n    usage: min %d, max %d, '%s'\",\n                        ima->minargs, ima->maxargs, ima->usage_msg);\n        }\n    }\n    if (trace_msg)\n        PerlIO_printf(DBILOGFP,\"%s\\n\", SvPV_nolen(trace_msg));\n    file = savepv(file);\n    cv = newXS(meth_name, XS_DBI_dispatch, file);\n    SvPVX((SV *)cv) = file;\n    SvLEN((SV *)cv) = 1;\n    CvXSUBANY(cv).any_ptr = ima;\n    ima->meth_type = get_meth_type(GvNAME(CvGV(cv)));\n\n    /* Attach magic to handle duping and freeing of the dbi_ima_t struct.\n     * Due to the poor interface of the mg dup function, sneak a pointer\n     * to the original CV in the mg_ptr field (we get called with a\n     * pointer to the mg, but not the SV) */\n    mg = sv_magicext((SV*)cv, NULL, DBI_MAGIC, &dbi_ima_vtbl,\n                        (char *)cv, 0);\n#ifdef BROKEN_DUP_ANY_PTR\n    ima->my_perl = my_perl; /* who owns this struct */\n#else\n    mg->mg_flags |= MGf_DUP;\n#endif\n    ST(0) = &PL_sv_yes;\n    }\n\n\nint\ntrace(class, level_sv=&PL_sv_undef, file=Nullsv)\n    SV *        class\n    SV *        level_sv\n    SV *        file\n    ALIAS:\n    _debug_dispatch = 1\n    CODE:\n    {\n    dMY_CXT;\n    IV level;\n    if (!DBIS) {\n        PERL_UNUSED_VAR(ix);\n        croak(\"DBI not initialised\");\n    }\n    /* Return old/current value. No change if new value not given.      */\n    RETVAL = (DBIS) ? DBIS->debug : 0;\n    level = parse_trace_flags(class, level_sv, RETVAL);\n    if (level)          /* call before or after altering DBI trace level */\n        set_trace_file(file);\n    if (level != RETVAL) {\n        if ((level & DBIc_TRACE_LEVEL_MASK) > 0) {\n            PerlIO_printf(DBILOGFP,\"    DBI %s%s default trace level set to 0x%lx/%ld (pid %d pi %p) at %s\\n\",\n                XS_VERSION, dbi_build_opt,\n                (long)(level & DBIc_TRACE_FLAGS_MASK),\n                (long)(level & DBIc_TRACE_LEVEL_MASK),\n                (int)PerlProc_getpid(),\n#ifdef MULTIPLICITY\n                (void *)my_perl,\n#else\n                (void*)NULL,\n#endif\n                log_where(Nullsv, 0, \"\", \"\", 1, 1, 0)\n            );\n            if (!PL_dowarn)\n                PerlIO_printf(DBILOGFP,\"    Note: perl is running without the recommended perl -w option\\n\");\n            PerlIO_flush(DBILOGFP);\n        }\n        DBIS->debug = level;\n        sv_setiv(get_sv(\"DBI::dbi_debug\",0x5), level);\n    }\n    if (!level)         /* call before or after altering DBI trace level */\n        set_trace_file(file);\n    }\n    OUTPUT:\n    RETVAL\n\n\n\nvoid\ndump_handle(sv, msg=\"DBI::dump_handle\", level=0)\n    SV *        sv\n    const char *msg\n    int         level\n    CODE:\n    (void)cv;\n    dbih_dumphandle(aTHX_ sv, msg, level);\n\n\n\nvoid\n_svdump(sv)\n    SV *        sv\n    CODE:\n    {\n    dMY_CXT;\n    (void)cv;\n    PerlIO_printf(DBILOGFP, \"DBI::_svdump(%s)\", neatsvpv(sv,0));\n#ifdef DEBUGGING\n    sv_dump(sv);\n#endif\n    }\n\n\nNV\ndbi_time()\n\n\nvoid\ndbi_profile(h, statement, method, t1, t2)\n    SV *h\n    SV *statement\n    SV *method\n    NV t1\n    NV t2\n    CODE:\n    SV *leaf = &PL_sv_undef;\n    PERL_UNUSED_VAR(cv);\n    if (SvROK(method))\n        method = SvRV(method);\n    if (dbih_inner(aTHX_ h, NULL)) {    /* is a DBI handle */\n        D_imp_xxh(h);\n        leaf = dbi_profile(h, imp_xxh, statement, method, t1, t2);\n    }\n    else if (SvROK(h) && SvTYPE(SvRV(h)) == SVt_PVHV) {\n        /* iterate over values %$h */\n        HV *hv = (HV*)SvRV(h);\n        SV *tmp;\n        char *key;\n        I32 keylen = 0;\n        hv_iterinit(hv);\n        while ( (tmp = hv_iternextsv(hv, &key, &keylen)) != NULL ) {\n            if (SvOK(tmp)) {\n                D_imp_xxh(tmp);\n                leaf = dbi_profile(tmp, imp_xxh, statement, method, t1, t2);\n            }\n        };\n    }\n    else {\n        croak(\"dbi_profile(%s,...) invalid handle argument\", neatsvpv(h,0));\n    }\n    if (GIMME_V == G_VOID)\n        ST(0) = &PL_sv_undef;  /* skip sv_mortalcopy if not needed */\n    else\n        ST(0) = sv_mortalcopy(leaf);\n\n\n\nSV *\ndbi_profile_merge_nodes(dest, ...)\n    SV * dest\n    ALIAS:\n    dbi_profile_merge = 1\n    CODE:\n    {\n        if (!SvROK(dest) || SvTYPE(SvRV(dest)) != SVt_PVAV)\n            croak(\"dbi_profile_merge_nodes(%s,...) destination is not an array reference\", neatsvpv(dest,0));\n        if (items <= 1) {\n            PERL_UNUSED_VAR(cv);\n            PERL_UNUSED_VAR(ix);\n            RETVAL = 0;\n        }\n        else {\n            /* items==2 for dest + 1 arg, ST(0) is dest, ST(1) is first arg */\n            while (--items >= 1) {\n                SV *thingy = ST(items);\n                dbi_profile_merge_nodes(dest, thingy);\n            }\n            RETVAL = newSVsv(*av_fetch((AV*)SvRV(dest), DBIprof_TOTAL_TIME, 1));\n        }\n    }\n    OUTPUT:\n    RETVAL\n\n\nSV *\n_concat_hash_sorted(hash_sv, kv_sep_sv, pair_sep_sv, use_neat_sv, num_sort_sv)\n    SV *hash_sv\n    SV *kv_sep_sv\n    SV *pair_sep_sv\n    SV *use_neat_sv\n    SV *num_sort_sv\n    PREINIT:\n    char *kv_sep, *pair_sep;\n    STRLEN kv_sep_len, pair_sep_len;\n    CODE:\n        if (!SvOK(hash_sv))\n            XSRETURN_UNDEF;\n        if (!SvROK(hash_sv) || SvTYPE(SvRV(hash_sv))!=SVt_PVHV)\n            croak(\"hash is not a hash reference\");\n\n        kv_sep   = SvPV(kv_sep_sv,   kv_sep_len);\n        pair_sep = SvPV(pair_sep_sv, pair_sep_len);\n\n        RETVAL = _join_hash_sorted( (HV*)SvRV(hash_sv),\n            kv_sep,   kv_sep_len,\n            pair_sep, pair_sep_len,\n            /* use_neat should be undef, 0 or 1, may allow sprintf format strings later */\n            (SvOK(use_neat_sv)) ? SvIV(use_neat_sv) :  0,\n            (SvOK(num_sort_sv)) ? SvIV(num_sort_sv) : -1\n        );\n    OUTPUT:\n        RETVAL\n\n\nint\nsql_type_cast(sv, sql_type, flags=0)\n    SV *        sv\n    int         sql_type\n    U32         flags\n    CODE:\n    RETVAL = sql_type_cast_svpv(aTHX_ sv, sql_type, flags, 0);\n    OUTPUT:\n        RETVAL\n\n\n\nMODULE = DBI   PACKAGE = DBI::var\n\nvoid\nFETCH(sv)\n    SV *        sv\n    CODE:\n    dMY_CXT;\n    /* Note that we do not come through the dispatcher to get here.     */\n    char *meth = SvPV_nolen(SvRV(sv));  /* what should this tie do ?    */\n    char type = *meth++;                /* is this a $ or & style       */\n    imp_xxh_t *imp_xxh = (DBI_LAST_HANDLE_OK) ? DBIh_COM(DBI_LAST_HANDLE) : NULL;\n    int trace_level = (imp_xxh ? DBIc_TRACE_LEVEL(imp_xxh) : DBIS_TRACE_LEVEL);\n    NV profile_t1 = 0.0;\n\n    if (imp_xxh && DBIc_has(imp_xxh,DBIcf_Profile))\n        profile_t1 = dbi_time();\n\n    if (trace_level >= 2) {\n        PerlIO_printf(DBILOGFP,\"    -> $DBI::%s (%c) FETCH from lasth=%s\\n\", meth, type,\n                (imp_xxh) ? neatsvpv(DBI_LAST_HANDLE,0): \"none\");\n    }\n\n    if (type == '!') {  /* special case for $DBI::lasth */\n        /* Currently we can only return the INNER handle.       */\n        /* This handle should only be used for true/false tests */\n        ST(0) = (imp_xxh) ? sv_2mortal(newRV_inc(DBI_LAST_HANDLE)) : &PL_sv_undef;\n    }\n    else if ( !imp_xxh ) {\n        if (trace_level)\n            warn(\"Can't read $DBI::%s, last handle unknown or destroyed\", meth);\n        ST(0) = &PL_sv_undef;\n    }\n    else if (type == '*') {     /* special case for $DBI::err, see also err method      */\n        SV *errsv = DBIc_ERR(imp_xxh);\n        ST(0) = sv_mortalcopy(errsv);\n    }\n    else if (type == '\"') {     /* special case for $DBI::state */\n        SV *state = DBIc_STATE(imp_xxh);\n        ST(0) = DBIc_STATE_adjust(imp_xxh, state);\n    }\n    else if (type == '$') { /* lookup scalar variable in implementors stash */\n        const char *vname = mkvname(aTHX_ DBIc_IMP_STASH(imp_xxh), meth, 0);\n        SV *vsv = get_sv(vname, 1);\n        ST(0) = sv_mortalcopy(vsv);\n    }\n    else {\n        /* default to method call via stash of implementor of DBI_LAST_HANDLE */\n        GV *imp_gv;\n        HV *imp_stash = DBIc_IMP_STASH(imp_xxh);\n#ifdef DBI_save_hv_fetch_ent\n        HE save_mh = PL_hv_fetch_ent_mh; /* XXX nested tied FETCH bug17575 workaround */\n#endif\n        profile_t1 = 0.0; /* profile this via dispatch only (else we'll double count) */\n        if (trace_level >= 3)\n            PerlIO_printf(DBILOGFP,\"    >> %s::%s\\n\", HvNAME(imp_stash), meth);\n        ST(0) = sv_2mortal(newRV_inc(DBI_LAST_HANDLE));\n        if ((imp_gv = gv_fetchmethod(imp_stash,meth)) == NULL) {\n            croak(\"Can't locate $DBI::%s object method \\\"%s\\\" via package \\\"%s\\\"\",\n                meth, meth, HvNAME(imp_stash));\n        }\n        PUSHMARK(mark);  /* reset mark (implies one arg as we were called with one arg?) */\n        call_sv((SV*)GvCV(imp_gv), GIMME);\n        SPAGAIN;\n#ifdef DBI_save_hv_fetch_ent\n        PL_hv_fetch_ent_mh = save_mh;\n#endif\n    }\n    if (trace_level)\n        PerlIO_printf(DBILOGFP,\"    <- $DBI::%s= %s\\n\", meth, neatsvpv(ST(0),0));\n    if (profile_t1) {\n        SV *h = sv_2mortal(newRV_inc(DBI_LAST_HANDLE));\n        dbi_profile(h, imp_xxh, &PL_sv_undef, (SV*)cv, profile_t1, dbi_time());\n    }\n\n\nMODULE = DBI   PACKAGE = DBD::_::dr\n\nvoid\ndbixs_revision(h)\n    SV *    h\n    CODE:\n    PERL_UNUSED_VAR(h);\n    ST(0) = sv_2mortal(newSViv(DBIXS_REVISION));\n\n\nMODULE = DBI   PACKAGE = DBD::_::db\n\nvoid\nconnected(...)\n    CODE:\n    /* defined here just to avoid AUTOLOAD */\n    (void)cv;\n    (void)items;\n    ST(0) = &PL_sv_undef;\n\n\nSV *\npreparse(dbh, statement, ps_accept, ps_return, foo=Nullch)\n    SV *        dbh\n    char *      statement\n    IV          ps_accept\n    IV          ps_return\n    void        *foo\n\n\nvoid\ntake_imp_data(h)\n    SV *        h\n    PREINIT:\n    /* take_imp_data currently in DBD::_::db not DBD::_::common, so for dbh's only */\n    D_imp_xxh(h);\n    MAGIC *mg;\n    SV *imp_xxh_sv;\n    SV **tmp_svp;\n    CODE:\n    PERL_UNUSED_VAR(cv);\n    /*\n     * Remove and return the imp_xxh_t structure that's attached to the inner\n     * hash of the handle. Effectively this removes the 'brain' of the handle\n     * leaving it as an empty shell - brain dead. All method calls on it fail.\n     *\n     * The imp_xxh_t structure that's removed and returned is a plain scalar\n     * (containing binary data). It can be passed to a new DBI->connect call\n     * in order to have the new $dbh use the same 'connection' as the original\n     * handle. In this way a multi-threaded connection pool can be implemented.\n     *\n     * If the drivers imp_xxh_t structure contains SV*'s, or other interpreter\n     * specific items, they should be freed by the drivers own take_imp_data()\n     * method before it then calls SUPER::take_imp_data() to finalize removal\n     * of the imp_xxh_t structure.\n     *\n     * The driver needs to view the take_imp_data method as being nearly the\n     * same as disconnect+DESTROY only not actually calling the database API to\n     * disconnect.  All that needs to remain valid in the imp_xxh_t structure\n     * is the underlying database API connection data.  Everything else should\n     * in a 'clean' state such that if the drivers own DESTROY method was\n     * called it would be able to properly handle the contents of the\n     * structure. This is important in case a new handle created using this\n     * imp_data, possibly in a new thread, might end up being DESTROY'd before\n     * the driver has had a chance to 're-setup' the data. See dbih_setup_handle()\n     *\n     * All the above relates to the 'typical use case' for a compiled driver.\n     * For a pure-perl driver using a socket pair, for example, the drivers\n     * take_imp_data method might just return a string containing the fileno()\n     * values of the sockets (without calling this SUPER::take_imp_data() code).\n     * The key point is that the take_imp_data() method returns an opaque buffer\n     * containing whatever the driver would need to reuse the same underlying\n     * 'connection to the database' in a new handle.\n     *\n     * In all cases, care should be taken that driver attributes (such as\n     * AutoCommit) match the state of the underlying connection.\n     */\n\n    if (!DBIc_ACTIVE(imp_xxh)) {/* sanity check, may be relaxed later */\n        set_err_char(h, imp_xxh, \"1\", 1, \"Can't take_imp_data from handle that's not Active\", 0, \"take_imp_data\");\n        XSRETURN(0);\n    }\n\n    /* Ideally there should be no child statement handles existing when\n     * take_imp_data is called because when those statement handles are\n     * destroyed they may need to interact with the 'zombie' parent dbh.\n     * So we do our best to neautralize them (finish & rebless)\n     */\n    if ((tmp_svp = hv_fetch((HV*)SvRV(h), \"ChildHandles\", 12, FALSE)) && SvROK(*tmp_svp)) {\n        AV *av = (AV*)SvRV(*tmp_svp);\n        HV *zombie_stash = gv_stashpv(\"DBI::zombie\", GV_ADDWARN);\n        I32 kidslots;\n        for (kidslots = AvFILL(av); kidslots >= 0; --kidslots) {\n            SV **hp = av_fetch(av, kidslots, FALSE);\n            if (hp && SvROK(*hp) && SvMAGICAL(SvRV(*hp))) {\n                PUSHMARK(sp);\n                XPUSHs(*hp);\n                PUTBACK;\n                call_method(\"finish\", G_SCALAR|G_DISCARD);\n                SPAGAIN;\n                PUTBACK;\n                sv_unmagic(SvRV(*hp), 'P'); /* untie */\n                sv_bless(*hp, zombie_stash); /* neutralise */\n            }\n        }\n    }\n    /* The above measures may not be sufficient if weakrefs aren't available\n     * or something has a reference to the inner-handle of an sth.\n     * We'll require no Active kids, but just warn about others.\n     */\n    if (DBIc_ACTIVE_KIDS(imp_xxh)) {\n        set_err_char(h, imp_xxh, \"1\", 1, \"Can't take_imp_data from handle while it still has Active kids\", 0, \"take_imp_data\");\n        XSRETURN(0);\n    }\n    if (DBIc_KIDS(imp_xxh))\n        warn(\"take_imp_data from handle while it still has kids\");\n\n    /* it may be better here to return a copy and poison the original\n     * rather than detatching and returning the original\n     */\n\n    /* --- perform the surgery */\n    dbih_getcom2(aTHX_ h, &mg); /* get the MAGIC so we can change it    */\n    imp_xxh_sv = mg->mg_obj;    /* take local copy of the imp_data pointer */\n    mg->mg_obj = Nullsv;        /* sever the link from handle to imp_xxh */\n    mg->mg_ptr = NULL;          /* and sever the shortcut too */\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 9)\n        sv_dump(imp_xxh_sv);\n    /* --- housekeeping */\n    DBIc_ACTIVE_off(imp_xxh);   /* silence warning from dbih_clearcom */\n    DBIc_IMPSET_off(imp_xxh);   /* silence warning from dbih_clearcom */\n    dbih_clearcom(imp_xxh);     /* free SVs like DBD::_mem::common::DESTROY */\n    SvOBJECT_off(imp_xxh_sv);   /* no longer needs DESTROY via dbih_clearcom */\n    /* restore flags to mark fact imp data holds active connection      */\n    /* (don't use magical DBIc_ACTIVE_on here)                          */\n    DBIc_FLAGS(imp_xxh) |=  DBIcf_IMPSET | DBIcf_ACTIVE;\n    /* --- tidy up the raw PV for life as a more normal string */\n    SvPOK_on(imp_xxh_sv);       /* SvCUR & SvEND were set at creation   */\n    /* --- return the actual imp_xxh_sv on the stack */\n    ST(0) = imp_xxh_sv;\n\n\n\nMODULE = DBI   PACKAGE = DBD::_::st\n\nvoid\n_get_fbav(sth)\n    SV *        sth\n    CODE:\n    D_imp_sth(sth);\n    AV *av = dbih_get_fbav(imp_sth);\n    (void)cv;\n    ST(0) = sv_2mortal(newRV_inc((SV*)av));\n\nvoid\n_set_fbav(sth, src_rv)\n    SV *        sth\n    SV *        src_rv\n    CODE:\n    D_imp_sth(sth);\n    int i;\n    AV *src_av;\n    AV *dst_av = dbih_get_fbav(imp_sth);\n    int dst_fields = AvFILL(dst_av)+1;\n    int src_fields;\n    (void)cv;\n\n    if (!SvROK(src_rv) || SvTYPE(SvRV(src_rv)) != SVt_PVAV)\n        croak(\"_set_fbav(%s): not an array ref\", neatsvpv(src_rv,0));\n    src_av = (AV*)SvRV(src_rv);\n    src_fields = AvFILL(src_av)+1;\n    if (src_fields != dst_fields) {\n        warn(\"_set_fbav(%s): array has %d elements, the statement handle row buffer has %d (and NUM_OF_FIELDS is %d)\",\n                neatsvpv(src_rv,0), src_fields, dst_fields, DBIc_NUM_FIELDS(imp_sth));\n        SvREADONLY_off(dst_av);\n        if (src_fields < dst_fields) {\n            /* shrink the array - sadly this looses column bindings for the lost columns */\n            av_fill(dst_av, src_fields-1);\n            dst_fields = src_fields;\n        }\n        else {\n            av_fill(dst_av, src_fields-1);\n            /* av_fill pads with immutable undefs which we need to change */\n            for(i=dst_fields-1; i < src_fields; ++i) {\n                sv_setsv(AvARRAY(dst_av)[i], newSV(0));\n            }\n        }\n        SvREADONLY_on(dst_av);\n    }\n    for(i=0; i < dst_fields; ++i) {     /* copy over the row    */\n        /* If we're given the values, then taint them if required */\n        if (DBIc_is(imp_sth, DBIcf_TaintOut))\n            SvTAINT(AvARRAY(src_av)[i]);\n        sv_setsv(AvARRAY(dst_av)[i], AvARRAY(src_av)[i]);\n    }\n    ST(0) = sv_2mortal(newRV_inc((SV*)dst_av));\n\n\nvoid\nbind_col(sth, col, ref, attribs=Nullsv)\n    SV *        sth\n    SV *        col\n    SV *        ref\n    SV *        attribs\n    CODE:\n    DBD_ATTRIBS_CHECK(\"bind_col\", sth, attribs);\n    ST(0) = boolSV(dbih_sth_bind_col(sth, col, ref, attribs));\n    (void)cv;\n\n\nvoid\nfetchrow_array(sth)\n    SV *        sth\n    ALIAS:\n    fetchrow = 1\n    PPCODE:\n    SV *retsv;\n    if (CvDEPTH(cv) == 99) {\n        PERL_UNUSED_VAR(ix);\n        croak(\"Deep recursion, probably fetchrow-fetch-fetchrow loop\");\n    }\n    PUSHMARK(sp);\n    XPUSHs(sth);\n    PUTBACK;\n    if (call_method(\"fetch\", G_SCALAR) != 1)\n        croak(\"panic: DBI fetch\");      /* should never happen */\n    SPAGAIN;\n    retsv = POPs;\n    PUTBACK;\n    if (SvROK(retsv) && SvTYPE(SvRV(retsv)) == SVt_PVAV) {\n        D_imp_sth(sth);\n        int num_fields, i;\n        AV *bound_av;\n        AV *av = (AV*)SvRV(retsv);\n        num_fields = AvFILL(av)+1;\n        EXTEND(sp, num_fields+1);\n\n        /* We now check for bind_col() having been called but fetch     */\n        /* not returning the fields_svav array. Probably because the    */\n        /* driver is implemented in perl. XXX This logic may change later.      */\n        bound_av = DBIc_FIELDS_AV(imp_sth); /* bind_col() called ?      */\n        if (bound_av && av != bound_av) {\n            /* let dbih_get_fbav know what's going on   */\n            bound_av = dbih_get_fbav(imp_sth);\n            if (DBIc_TRACE_LEVEL(imp_sth) >= 3) {\n                PerlIO_printf(DBIc_LOGPIO(imp_sth),\n                    \"fetchrow: updating fbav 0x%lx from 0x%lx\\n\",\n                    (long)bound_av, (long)av);\n            }\n            for(i=0; i < num_fields; ++i) {     /* copy over the row    */\n                sv_setsv(AvARRAY(bound_av)[i], AvARRAY(av)[i]);\n            }\n        }\n        for(i=0; i < num_fields; ++i) {\n            PUSHs(AvARRAY(av)[i]);\n        }\n    }\n\n\nSV *\nfetchrow_hashref(sth, keyattrib=Nullch)\n    SV *        sth\n    const char *keyattrib\n    PREINIT:\n    SV *rowavr;\n    SV *ka_rv;\n    D_imp_sth(sth);\n    CODE:\n    (void)cv;\n    PUSHMARK(sp);\n    XPUSHs(sth);\n    PUTBACK;\n    if (!keyattrib || !*keyattrib) {\n        SV *kn = DBIc_FetchHashKeyName(imp_sth);\n        if (kn && SvOK(kn))\n            keyattrib = SvPVX(kn);\n        else\n            keyattrib = \"NAME\";\n    }\n    ka_rv = *hv_fetch((HV*)DBIc_MY_H(imp_sth), keyattrib,strlen(keyattrib), TRUE);\n    /* we copy to invoke FETCH magic, and we do that before fetch() so if tainting */\n    /* then the taint triggered by the fetch won't then apply to the fetched name */\n    ka_rv = newSVsv(ka_rv);\n    if (call_method(\"fetch\", G_SCALAR) != 1)\n        croak(\"panic: DBI fetch\");      /* should never happen */\n    SPAGAIN;\n    rowavr = POPs;\n    PUTBACK;\n    /* have we got an array ref in rowavr */\n    if (SvROK(rowavr) && SvTYPE(SvRV(rowavr)) == SVt_PVAV) {\n        int i;\n        AV *rowav = (AV*)SvRV(rowavr);\n        const int num_fields = AvFILL(rowav)+1;\n        HV *hv;\n        AV *ka_av;\n        if (!(SvROK(ka_rv) && SvTYPE(SvRV(ka_rv))==SVt_PVAV)) {\n            sv_setiv(DBIc_ERR(imp_sth), 1);\n            sv_setpvf(DBIc_ERRSTR(imp_sth),\n                \"Can't use attribute '%s' because it doesn't contain a reference to an array (%s)\",\n                keyattrib, neatsvpv(ka_rv,0));\n            XSRETURN_UNDEF;\n        }\n        ka_av = (AV*)SvRV(ka_rv);\n        hv    = newHV();\n        for (i=0; i < num_fields; ++i) {        /* honor the original order as sent by the database */\n            SV  **field_name_svp = av_fetch(ka_av, i, 1);\n            (void)hv_store_ent(hv, *field_name_svp, newSVsv((SV*)(AvARRAY(rowav)[i])), 0);\n        }\n        RETVAL = newRV_inc((SV*)hv);\n        SvREFCNT_dec(hv);       /* since newRV incremented it   */\n    }\n    else {\n        RETVAL = &PL_sv_undef;\n#if (PERL_VERSION < 4) || ((PERL_VERSION == 4) && (PERL_SUBVERSION <= 4))\n        RETVAL = newSV(0); /* mutable undef for 5.004_04 */\n#endif\n    }\n    SvREFCNT_dec(ka_rv);        /* since we created it          */\n    OUTPUT:\n    RETVAL\n\n\nvoid\nfetch(sth)\n    SV *        sth\n    ALIAS:\n    fetchrow_arrayref = 1\n    CODE:\n    int num_fields;\n    if (CvDEPTH(cv) == 99) {\n        PERL_UNUSED_VAR(ix);\n        croak(\"Deep recursion. Probably fetch-fetchrow-fetch loop.\");\n    }\n    PUSHMARK(sp);\n    XPUSHs(sth);\n    PUTBACK;\n    num_fields = call_method(\"fetchrow\", G_ARRAY);      /* XXX change the name later */\n    SPAGAIN;\n    if (num_fields == 0) {\n        ST(0) = &PL_sv_undef;\n    } else {\n        D_imp_sth(sth);\n        AV *av = dbih_get_fbav(imp_sth);\n        if (num_fields != AvFILL(av)+1)\n            croak(\"fetchrow returned %d fields, expected %d\",\n                    num_fields, (int)AvFILL(av)+1);\n        SPAGAIN;\n        while(--num_fields >= 0)\n            sv_setsv(AvARRAY(av)[num_fields], POPs);\n        PUTBACK;\n        ST(0) = sv_2mortal(newRV_inc((SV*)av));\n    }\n\n\nvoid\nrows(sth)\n    SV *        sth\n    CODE:\n    D_imp_sth(sth);\n    const IV rows = DBIc_ROW_COUNT(imp_sth);\n    ST(0) = sv_2mortal(newSViv(rows));\n    (void)cv;\n\n\nvoid\nfinish(sth)\n    SV *        sth\n    CODE:\n    D_imp_sth(sth);\n    DBIc_ACTIVE_off(imp_sth);\n    ST(0) = &PL_sv_yes;\n    (void)cv;\n\n\nvoid\nDESTROY(sth)\n    SV *        sth\n    PPCODE:\n    /* keep in sync with DESTROY in Driver.xst */\n    D_imp_sth(sth);\n    ST(0) = &PL_sv_yes;\n    /* we don't test IMPSET here because this code applies to pure-perl drivers */\n    if (DBIc_IADESTROY(imp_sth)) { /* want's ineffective destroy    */\n        DBIc_ACTIVE_off(imp_sth);\n        if (DBIc_TRACE_LEVEL(imp_sth))\n                PerlIO_printf(DBIc_LOGPIO(imp_sth), \"         DESTROY %s skipped due to InactiveDestroy\\n\", SvPV_nolen(sth));\n    }\n    if (DBIc_ACTIVE(imp_sth)) {\n        D_imp_dbh_from_sth;\n        if (!PL_dirty && DBIc_ACTIVE(imp_dbh)) {\n            dSP;\n            PUSHMARK(sp);\n            XPUSHs(sth);\n            PUTBACK;\n            call_method(\"finish\", G_SCALAR);\n            SPAGAIN;\n            PUTBACK;\n        }\n        else {\n            DBIc_ACTIVE_off(imp_sth);\n        }\n    }\n\n\nMODULE = DBI   PACKAGE = DBI::st\n\nvoid\nTIEHASH(class, inner_ref)\n    SV * class\n    SV * inner_ref\n    CODE:\n    HV *stash = gv_stashsv(class, GV_ADDWARN); /* a new hash is supplied to us, we just need to bless and apply tie magic */\n    sv_bless(inner_ref, stash);\n    ST(0) = inner_ref;\n\nMODULE = DBI   PACKAGE = DBD::_::common\n\n\nvoid\nDESTROY(h)\n    SV * h\n    CODE:\n    /* DESTROY defined here just to avoid AUTOLOAD */\n    (void)cv;\n    (void)h;\n    ST(0) = &PL_sv_undef;\n\n\nvoid\nSTORE(h, keysv, valuesv)\n    SV *        h\n    SV *        keysv\n    SV *        valuesv\n    CODE:\n    ST(0) = &PL_sv_yes;\n    if (!dbih_set_attr_k(h, keysv, 0, valuesv))\n            ST(0) = &PL_sv_no;\n    (void)cv;\n\n\nvoid\nFETCH(h, keysv)\n    SV *        h\n    SV *        keysv\n    CODE:\n    ST(0) = dbih_get_attr_k(h, keysv, 0);\n    (void)cv;\n\nvoid\nDELETE(h, keysv)\n    SV *        h\n    SV *        keysv\n    CODE:\n    /* only private_* keys can be deleted, for others DELETE acts like FETCH */\n    /* because the DBI internals rely on certain handle attributes existing  */\n    if (strnEQ(SvPV_nolen(keysv),\"private_\",8))\n        ST(0) = hv_delete_ent((HV*)SvRV(h), keysv, 0, 0);\n    else\n        ST(0) = dbih_get_attr_k(h, keysv, 0);\n    (void)cv;\n\n\nvoid\nprivate_data(h)\n    SV *        h\n    CODE:\n    D_imp_xxh(h);\n    (void)cv;\n    ST(0) = sv_mortalcopy(DBIc_IMP_DATA(imp_xxh));\n\n\nvoid\nerr(h)\n    SV * h\n    CODE:\n    D_imp_xxh(h);\n    SV *errsv = DBIc_ERR(imp_xxh);\n    (void)cv;\n    ST(0) = sv_mortalcopy(errsv);\n\nvoid\nstate(h)\n    SV * h\n    CODE:\n    D_imp_xxh(h);\n    SV *state = DBIc_STATE(imp_xxh);\n    (void)cv;\n    ST(0) = DBIc_STATE_adjust(imp_xxh, state);\n\nvoid\nerrstr(h)\n    SV *    h\n    CODE:\n    D_imp_xxh(h);\n    SV *errstr = DBIc_ERRSTR(imp_xxh);\n    SV *err;\n    /* If there's no errstr but there is an err then use err */\n    (void)cv;\n    if (!SvTRUE(errstr) && (err=DBIc_ERR(imp_xxh)) && SvTRUE(err))\n            errstr = err;\n    ST(0) = sv_mortalcopy(errstr);\n\n\nvoid\nset_err(h, err, errstr=&PL_sv_no, state=&PL_sv_undef, method=&PL_sv_undef, result=Nullsv)\n    SV *        h\n    SV *        err\n    SV *        errstr\n    SV *        state\n    SV *        method\n    SV *        result\n    PPCODE:\n    {\n    D_imp_xxh(h);\n    SV **sem_svp;\n    (void)cv;\n\n    if (DBIc_has(imp_xxh, DBIcf_HandleSetErr) && SvREADONLY(method))\n        method = sv_mortalcopy(method); /* HandleSetErr may want to change it */\n\n    if (!set_err_sv(h, imp_xxh, err, errstr, state, method)) {\n        /* set_err was canceled by HandleSetErr,                */\n        /* don't set \"dbi_set_err_method\", return an empty list */\n    }\n    else {\n        /* store provided method name so handler code can find it */\n        sem_svp = hv_fetch((HV*)SvRV(h), \"dbi_set_err_method\", 18, 1);\n        if (SvOK(method)) {\n            sv_setpv(*sem_svp, SvPV_nolen(method));\n        }\n        else\n            (void)SvOK_off(*sem_svp);\n        EXTEND(SP, 1);\n        PUSHs( result ? result : &PL_sv_undef );\n    }\n    /* We don't check RaiseError and call die here because that must be */\n    /* done by returning through dispatch and letting the DBI handle it */\n    }\n\n\nint\ntrace(h, level=&PL_sv_undef, file=Nullsv)\n    SV *h\n    SV *level\n    SV *file\n    ALIAS:\n    debug = 1\n    CODE:\n    RETVAL = set_trace(h, level, file);\n    (void)cv; /* Unused variables */\n    (void)ix;\n    OUTPUT:\n    RETVAL\n\n\nvoid\ntrace_msg(sv, msg, this_trace=1)\n    SV *sv\n    const char *msg\n    int this_trace\n    PREINIT:\n    int current_trace;\n    PerlIO *pio;\n    CODE:\n    {\n    dMY_CXT;\n    (void)cv;\n    if (SvROK(sv)) {\n        D_imp_xxh(sv);\n        current_trace = DBIc_TRACE_LEVEL(imp_xxh);\n        pio = DBIc_LOGPIO(imp_xxh);\n    }\n    else {      /* called as a static method */\n        current_trace = DBIS_TRACE_FLAGS;\n        pio = DBILOGFP;\n    }\n    if (DBIc_TRACE_MATCHES(this_trace, current_trace)) {\n        PerlIO_puts(pio, msg);\n        ST(0) = &PL_sv_yes;\n    }\n    else {\n        ST(0) = &PL_sv_no;\n    }\n    }\n\n\nvoid\nrows(h)\n    SV *        h\n    CODE:\n    /* fallback esp for $DBI::rows after $drh was last used */\n    ST(0) = sv_2mortal(newSViv(-1));\n    (void)h;\n    (void)cv;\n\n\nvoid\nswap_inner_handle(rh1, rh2, allow_reparent=0)\n    SV *        rh1\n    SV *        rh2\n    IV  allow_reparent\n    CODE:\n    {\n    D_impdata(imp_xxh1, imp_xxh_t, rh1);\n    D_impdata(imp_xxh2, imp_xxh_t, rh2);\n    SV *h1i = dbih_inner(aTHX_ rh1, \"swap_inner_handle\");\n    SV *h2i = dbih_inner(aTHX_ rh2, \"swap_inner_handle\");\n    SV *h1  = (rh1 == h1i) ? (SV*)DBIc_MY_H(imp_xxh1) : SvRV(rh1);\n    SV *h2  = (rh2 == h2i) ? (SV*)DBIc_MY_H(imp_xxh2) : SvRV(rh2);\n    (void)cv;\n\n    if (DBIc_TYPE(imp_xxh1) != DBIc_TYPE(imp_xxh2)) {\n        char buf[99];\n        sprintf(buf, \"Can't swap_inner_handle between %sh and %sh\",\n            dbih_htype_name(DBIc_TYPE(imp_xxh1)), dbih_htype_name(DBIc_TYPE(imp_xxh2)));\n        DBIh_SET_ERR_CHAR(rh1, imp_xxh1, \"1\", 1, buf, Nullch, Nullch);\n        XSRETURN_NO;\n    }\n    if (!allow_reparent && DBIc_PARENT_COM(imp_xxh1) != DBIc_PARENT_COM(imp_xxh2)) {\n        DBIh_SET_ERR_CHAR(rh1, imp_xxh1, \"1\", 1,\n            \"Can't swap_inner_handle with handle from different parent\",\n            Nullch, Nullch);\n        XSRETURN_NO;\n    }\n\n    (void)SvREFCNT_inc(h1i);\n    (void)SvREFCNT_inc(h2i);\n\n    sv_unmagic(h1, 'P');                /* untie(%$h1)          */\n    sv_unmagic(h2, 'P');                /* untie(%$h2)          */\n\n    sv_magic(h1, h2i, 'P', Nullch, 0);  /* tie %$h1, $h2i       */\n    DBIc_MY_H(imp_xxh2) = (HV*)h1;\n\n    sv_magic(h2, h1i, 'P', Nullch, 0);  /* tie %$h2, $h1i       */\n    DBIc_MY_H(imp_xxh1) = (HV*)h2;\n\n    SvREFCNT_dec(h1i);\n    SvREFCNT_dec(h2i);\n\n    ST(0) = &PL_sv_yes;\n    }\n\n\nMODULE = DBI   PACKAGE = DBD::_mem::common\n\nvoid\nDESTROY(imp_xxh_rv)\n    SV *        imp_xxh_rv\n    CODE:\n    /* ignore 'cast increases required alignment' warning       */\n    imp_xxh_t *imp_xxh = (imp_xxh_t*)SvPVX(SvRV(imp_xxh_rv));\n    DBIc_DBISTATE(imp_xxh)->clearcom(imp_xxh);\n    (void)cv;\n\n# end\n", "#!perl -w\n# vim:ts=8:sw=4\n\nuse strict;\n\nuse Test::More;\nuse DBI;\n\nBEGIN {\n        plan skip_all => '$h->{Callbacks} attribute not supported for DBI::PurePerl'\n                if $DBI::PurePerl && $DBI::PurePerl; # doubled to avoid typo warning\n}\n\n$| = 1;\nmy $dsn = \"dbi:ExampleP:drv_foo=drv_bar\";\nmy %called;\n\nok my $dbh = DBI->connect($dsn, '', ''), \"Create dbh\";\n\nis $dbh->{Callbacks}, undef, \"Callbacks initially undef\";\nok $dbh->{Callbacks} = my $cb = { };\nis ref $dbh->{Callbacks}, 'HASH', \"Callbacks can be set to a hash ref\";\nis $dbh->{Callbacks}, $cb, \"Callbacks set to same hash ref\";\n\n$dbh->{Callbacks} = undef;\nis $dbh->{Callbacks}, undef, \"Callbacks set to undef again\";\n\nok $dbh->{Callbacks} = {\n    ping => sub {\n\tis $_, 'ping', '$_ holds method name';\n\tis @_, 1, '@_ holds 1 values';\n\tis ref $_[0], 'DBI::db', 'first is $dbh';\n        ok tied(%{$_[0]}), '$dbh is tied (outer) handle'\n            or DBI::dump_handle($_[0], 'tied?', 10);\n\t$called{$_}++;\n\treturn;\n    },\n    quote_identifier => sub {\n\tis @_, 4, '@_ holds 4 values';\n\tmy $dbh = shift;\n\tis ref $dbh, 'DBI::db', 'first is $dbh';\n\tis $_[0], 'foo';\n\tis $_[1], 'bar';\n\tis $_[2], undef;\n\t$_[2] = { baz => 1 };\n\t$called{$_}++;\n\treturn (1,2,3);\t# return something - which is not allowed\n    },\n    disconnect => sub { # test die from within a callback\n\tdie \"You can't disconnect that easily!\\n\";\n    },\n    \"*\" => sub {\n\t$called{$_}++;\n        return;\n    }\n};\nis keys %{ $dbh->{Callbacks} }, 4;\n\nis ref $dbh->{Callbacks}->{ping}, 'CODE';\n\n$_ = 42;\nok $dbh->ping;\nis $called{ping}, 1;\nis $_, 42, '$_ not altered by callback';\n\nok $dbh->ping;\nis $called{ping}, 2;\n\nok $dbh->type_info_all;\nis $called{type_info_all}, 1, 'fallback callback';\n\nmy $attr;\neval { $dbh->quote_identifier('foo','bar', $attr) };\nis $called{quote_identifier}, 1;\nok $@, 'quote_identifier callback caused fatal error';\nis ref $attr, 'HASH', 'param modified by callback - not recommended!';\n\nok !eval { $dbh->disconnect };\nok $@, \"You can't disconnect that easily!\\n\";\n\n$dbh->{Callbacks} = undef;\nok $dbh->ping;\nis $called{ping}, 2; # no change\n\n\n# --- test skipping dispatch and fallback callbacks\n\n$dbh->{Callbacks} = {\n    ping => sub {\n        undef $_;   # tell dispatch to not call the method\n        return \"42 bells\";\n    },\n    data_sources => sub {\n        my ($h, $values_to_return) = @_;\n        undef $_;   # tell dispatch to not call the method\n        my @ret = 11..10+($values_to_return||0);\n        return @ret;\n    },\n    commit => sub {     # test using set_err within a callback\n        my $h = shift;\n        undef $_;   # tell dispatch to not call the method\n\treturn $h->set_err(42, \"faked commit failure\");\n    },\n};\n\n# these tests are slightly convoluted because messing with the stack is bad for\n# your mental health\nmy $rv = $dbh->ping;\nis $rv, \"42 bells\";\nmy @rv = $dbh->ping;\nis scalar @rv, 1, 'should return a single value in list context';\nis \"@rv\", \"42 bells\";\n# test returning lists with different number of args to test\n# the stack handling in the dispatch code\nis join(\":\", $dbh->data_sources()),  \"\";\nis join(\":\", $dbh->data_sources(0)), \"\";\nis join(\":\", $dbh->data_sources(1)), \"11\";\nis join(\":\", $dbh->data_sources(2)), \"11:12\";\n\n{\nlocal $dbh->{RaiseError} = 1;\nlocal $dbh->{PrintError} = 0;\nis eval { $dbh->commit }, undef, 'intercepted commit should return undef';\nlike $@, '/DBD::\\w+::db commit failed: faked commit failure/';\nis $DBI::err, 42;\nis $DBI::errstr, \"faked commit failure\";\n}\n\n# --- test connect_cached.*\n\n=for comment XXX\n\nThe big problem here is that conceptually the Callbacks attribute\nis applied to the $dbh _during_ the $drh->connect() call, so you can't\nset a callback on \"connect\" on the $dbh because connect isn't called\non the dbh, but on the $drh.\n\nSo a \"connect\" callback would have to be defined on the $drh, but that's\ncumbersome for the user and then it would apply to all future connects\nusing that driver.\n\nThe best thing to do is probably to special-case \"connect\", \"connect_cached\"\nand (the already special-case) \"connect_cached.reused\".\n\n=cut\n\nmy $driver_dsn = (DBI->parse_dsn($dsn))[4] or die 'panic';\n\nmy @args = (\n    $dsn, 'u', 'p', {\n        Callbacks => {\n            \"connect_cached.new\"       => sub {\n                my ($dbh, $cb_dsn, $user, $auth, $attr) = @_;\n                ok tied(%$dbh), 'connect_cached.new $h is tied (outer) handle'\n                    if $dbh; # $dbh is typically undef or a dead/disconnected $dbh\n                like $cb_dsn, qr/\\Q$driver_dsn/, 'dsn';\n                is $user, 'u', 'user';\n                is $auth, 'p', 'pass';\n                $called{new}++;\n                return;\n            },\n            \"connect_cached.reused\"    => sub {\n                my ($dbh, $cb_dsn, $user, $auth, $attr) = @_;\n                ok tied(%$dbh), 'connect_cached.reused $h is tied (outer) handle';\n                like $cb_dsn, qr/\\Q$driver_dsn/, 'dsn';\n                is $user, 'u', 'user';\n                is $auth, 'p', 'pass';\n                $called{cached}++;\n                return;\n            },\n            \"connect_cached.connected\" => sub {\n                my ($dbh, $cb_dsn, $user, $auth, $attr) = @_;\n                ok tied(%$dbh), 'connect_cached.connected $h is tied (outer) handle';\n                like $cb_dsn, qr/\\Q$driver_dsn/, 'dsn';\n                is $user, 'u', 'user';\n                is $auth, 'p', 'pass';\n                $called{connected}++;\n                return;\n            },\n        }\n    }\n);\n\n%called = ();\n\nok $dbh = DBI->connect(@args), \"Create handle with callbacks\";\nis keys %called, 0, 'no callback for plain connect';\n\nok $dbh = DBI->connect_cached(@args), \"Create handle with callbacks\";\nis $called{new}, 1, \"connect_cached.new called\";\nis $called{cached}, undef, \"connect_cached.reused not yet called\";\nis $called{connected}, 1, \"connect_cached.connected called\";\n\nok $dbh = DBI->connect_cached(@args), \"Create handle with callbacks\";\nis $called{cached}, 1, \"connect_cached.reused called\";\nis $called{new}, 1, \"connect_cached.new not called again\";\nis $called{connected}, 1, \"connect_cached.connected not called called\";\n\n\n# --- test ChildCallbacks.\n%called = ();\n$args[-1] = {\n    Callbacks => my $dbh_callbacks = {\n        ping => sub { $called{ping}++; return; },\n        ChildCallbacks => my $sth_callbacks = {\n            execute => sub { $called{execute}++; return; },\n            fetch   => sub { $called{fetch}++; return; },\n        }\n    }\n};\n\nok $dbh = DBI->connect(@args), \"Create handle with ChildCallbacks\";\nok $dbh->ping, 'Ping';\nis $called{ping}, 1, 'Ping callback should have been called';\nok my $sth = $dbh->prepare('SELECT name from t'), 'Prepare a statement handle (child)';\nok $sth->{Callbacks}, 'child should have Callbacks';\nis $sth->{Callbacks}, $sth_callbacks, \"child Callbacks should be ChildCallbacks of parent\"\n    or diag \"(dbh Callbacks is $dbh_callbacks)\";\nok $sth->execute, 'Execute';\nis $called{execute}, 1, 'Execute callback should have been called';\nok $sth->fetch, 'Fetch';\nis $called{fetch}, 1, 'Fetch callback should have been called';\n\ndone_testing();\n\n__END__\n\nA generic 'transparent' callback looks like this:\n(this assumes only scalar context will be used)\n\n    sub {\n        my $h = shift;\n        return if our $avoid_deep_recursion->{\"$h $_\"}++;\n        my $this = $h->$_(@_);\n        undef $_;    # tell DBI not to call original method\n        return $this; # tell DBI to return this instead\n    };\n\nXXX should add a test for this\nXXX even better would be to run chunks of the test suite with that as a '*' callback. In theory everything should pass (except this test file, naturally)..\n"], "fixing_code": ["=head1 NAME\n\nDBI::Changes - List of significant changes to the DBI\n\n=encoding ISO8859-1\n\n=cut\n\n=head2 Changes in DBI 1.632\n\n    Fixed risk of memory corruption with many arguments to methods\n        originally reported by OSCHWALD for Callbacks but may apply\n        to other functionality in DBI method dispatch RT#86744.\n    Fixed DBD::PurePerl to not set $sth->{Active} true by default\n        drivers are expected to set it true as needed.\n    Fixed DBI::DBD::SqlEngine to complain loudly when prerequite\n        driver_prefix is not fulfilled (RT#93204) [Jens Rehsack]\n    Fixed redundant sprintf argument warning RT#97062 [Reini Urban]\n\n    Changed delete $h->{$key} to work for keys with 'private_' prefix\n        per request in RT#83156. local $h->{$key} works as before.\n\n    Added security notice to DBD::Proxy and DBI::ProxyServer because they\n        use Storable which is insecure. Thanks to ppisar@redhat.com RT#90475\n\n=head2 Changes in DBI 1.631 - 20th Jan 2014\n\nNOTE: This release changes the handle passed to Callbacks from being an 'inner'\nhandle to being an 'outer' handle. If you have code that makes use of Callbacks,\nensure that you understand what this change means and review your callback code.\n\n    Fixed err_hash handling of integer err RT#92172 [Dagfinn Ilmari]\n    Fixed use of \\Q vs \\E in t/70callbacks.t\n\n    Changed the handle passed to Callbacks from being an 'inner'\n        handle to being an 'outer' handle.\n\n    Improved reliability of concurrent testing\n        PR#8 [Peter Rabbitson]\n    Changed optional dependencies to \"suggest\"\n        PR#9 [Karen Etheridge]\n    Changed to avoid mg_get in neatsvpv during global destruction\n        PR#10 [Matt Phillips]\n\n=head2 Changes in DBI 1.630 - 28th Oct 2013\n\nNOTE: This release enables PrintWarn by default regardless of $^W.\nYour applications may generate more log messages than before.\n\n    Fixed err for new drh to be undef not to 0 [Martin J. Evans]\n    Fixed RT#83132 - moved DBIstcf* constants to util\n        export tag [Martin J. Evans]\n    PrintWarn is now triggered by warnings recorded in methods like STORE\n        that don't clear err RT#89015 [Tim Bunce]\n\n    Changed tracing to no longer show quote and quote_identifier calls\n        at trace level 1.\n    Changed DBD::Gofer ping while disconnected set_err from warn to info.\n    Clarified wording of log message when err is cleared.\n    Changed bootstrap to use $XS_VERSION RT#89618 [Andreas Koenig]\n\n    Added connect_cached.connected Callback PR#3 [David E. Wheeler]\n\n    Clarified effect of refs in connect_cached attributes [David E. Wheeler]\n    Extended ReadOnly attribute docs for when the driver cannot\n      ensure read only [Martin J. Evans]\n    Corrected SQL_BIGINT docs to say ODBC value is used PR#5 [ilmari]\n\nThere was no DBI 1.629 release.\n\n=head2 Changes in DBI 1.628 - 22nd July 2013\n\n    Fixed missing fields on partial insert via DBI::DBD::SqlEngine\n        engines (DBD::CSV, DBD::DBM etc.) [H.Merijn Brand, Jens Rehsack]\n    Fixed stack corruption on callbacks RT#85562 RT#84974 [Aaron Schweiger]\n    Fixed DBI::SQL::Nano_::Statement handling of \"0\" [Jens Rehsack]\n    Fixed exit op precedence in test RT#87029 [Reni Urban]\n\n    Added support for finding tables in multiple directories\n        via new DBD::File f_dir_search attribute [H.Merijn Brand]\n    Enable compiling by C++ RT#84285 [Kurt Jaeger]\n\n    Typo fixes in pod and comment [David Steinbrunner]\n    Change DBI's docs to refer to git not svn [H.Merijn Brand]\n    Clarify bind_col TYPE attribute is sticky [Martin J. Evans]\n    Fixed reference to $sth in selectall_arrayref docs RT#84873\n    Spelling fixes [Ville Skytt\u00e4]\n    Changed $VERSIONs to hardcoded strings [H.Merijn Brand]\n\n=head2 Changes in DBI 1.627 - 16th May 2013\n\n    Fixed VERSION regression in DBI::SQL::Nano [Tim Bunce]\n\n=head2 Changes in DBI 1.626 - 15th May 2013\n\n    Fixed pod text/link was reversed in a few cases RT#85168\n        [H.Merijn Brand]\n\n    Handle aliasing of STORE'd attributes in DBI::DBD::SqlEngine\n        [Jens Rehsack]\n\n    Updated repository URI to git [Jens Rehsack]\n\n    Fixed skip() count arg in t/48dbi_dbd_sqlengine.t [Tim Bunce]\n\n=head2 Changes in DBI 1.625 (svn r15595) 28th March 2013\n\n  Fixed heap-use-after-free during global destruction RT#75614\n    thanks to Reini Urban.\n  Fixed ignoring RootClass attribute during connect() by\n    DBI::DBD::SqlEngine reported in RT#84260 by Michael Schout\n\n=head2 Changes in DBI 1.624 (svn r15576) 22nd March 2013\n\n  Fixed Gofer for hash randomization in perl 5.17.10+ RT#84146\n\n  Clarify docs for can() re RT#83207\n\n=head2 Changes in DBI 1.623 (svn r15547) 2nd Jan 2013\n\n  Fixed RT#64330 - ping wipes out errstr (Martin J. Evans).\n  Fixed RT#75868 - DBD::Proxy shouldn't call connected() on the server.\n  Fixed RT#80474 - segfault in DESTROY with threads.\n  Fixed RT#81516 - Test failures due to hash randomisation in perl 5.17.6\n    thanks to Jens Rehsack and H.Merijn Brand and feedback on IRC\n  Fixed RT#81724 - Handle copy-on-write scalars (sprout)\n  Fixed unused variable / self-assignment compiler warnings.\n  Fixed default table_info in DBI::DBD::SqlEngine which passed NAMES\n    attribute instead of NAME to DBD::Sponge RT72343 (Martin J. Evans)\n\n  Corrected a spelling error thanks to Chris Sanders.\n  Corrected typo in DBI->installed_versions docs RT#78825\n    thanks to Jan Dubois.\n\n  Refactored table meta information management from DBD::File into\n    DBI::DBD::SqlEngine (H.Merijn Brand, Jens Rehsack)\n  Prevent undefined f_dir being used in opendir (H.Merijn Brand)\n\n  Added logic to force destruction of children before parents\n    during global destruction. See RT#75614.\n  Added DBD::File Plugin-Support for table names and data sources\n    (Jens Rehsack, #dbi Team)\n  Added new tests to 08keeperr for RT#64330\n    thanks to Kenichi Ishigaki.\n  Added extra internal handle type check, RT#79952\n    thanks to Reini Urban.\n  Added cubrid_ registered prefix for DBD::cubrid, RT#78453\n\n  Removed internal _not_impl method (Martin J. Evans).\n\n  NOTE: The \"old-style\" DBD::DBM attributes 'dbm_ext' and 'dbm_lockfile'\n    have been deprecated for several years and their use will now generate\n    a warning.\n\n=head2 Changes in DBI 1.622 (svn r15327) 6th June 2012\n\n  Fixed lack of =encoding in non-ASCII pod docs. RT#77588\n\n  Corrected typo in DBI::ProfileDumper thanks to Finn Hakansson.\n\n=head2 Changes in DBI 1.621 (svn r15315) 21st May 2012\n\n  Fixed segmentation fault when a thread is created from\n    within another thread RT#77137, thanks to Dave Mitchell.\n  Updated previous Changes to credit Booking.com for sponsoring\n    Dave Mitchell's recent DBI optimization work.\n\n=head2 Changes in DBI 1.620 (svn r15300) 25th April 2012\n\n  Modified column renaming in fetchall_arrayref, added in 1.619,\n    to work on column index numbers not names (an incompatible change).\n  Reworked the fetchall_arrayref documentation.\n  Hash slices in fetchall_arrayref now detect invalid column names.\n\n=head2 Changes in DBI 1.619 (svn r15294) 23rd April 2012\n\n  Fixed the connected method to stop showing the password in\n    trace file (Martin J. Evans).\n  Fixed _install_method to set CvFILE correctly\n    thanks to sprout RT#76296\n  Fixed SqlEngine \"list_tables\" thanks to David McMath\n    and Norbert Gruener. RT#67223 RT#69260\n\n  Optimized DBI method dispatch thanks to Dave Mitchell.\n  Optimized driver access to DBI internal state thanks to Dave Mitchell.\n  Optimized driver access to handle data thanks to Dave Mitchell.\n    Dave's work on these optimizations was sponsored by Booking.com.\n  Optimized fetchall_arrayref with hash slice thanks\n    to Dagfinn Ilmari Manns\u00e5ker. RT#76520\n  Allow renaming columns in fetchall_arrayref hash slices\n    thanks to Dagfinn Ilmari Manns\u00e5ker. RT#76572\n  Reserved snmp_ and tree_ for DBD::SNMP and DBD::TreeData\n\n=head2 Changes in DBI 1.618 (svn r15170) 25rd February 2012\n\n  Fixed compiler warnings in Driver_xst.h (Martin J. Evans)\n  Fixed compiler warning in DBI.xs (H.Merijn Brand)\n  Fixed Gofer tests failing on Windows RT74975 (Manoj Kumar)\n  Fixed my_ctx compile errors on Windows (Dave Mitchell)\n\n  Significantly optimized method dispatch via cache (Dave Mitchell)\n  Significantly optimized DBI internals for threads (Dave Mitchell)\n    Dave's work on these optimizations was sponsored by Booking.com.\n  Xsub to xsub calling optimization now enabled for threaded perls.\n  Corrected typo in example in docs (David Precious)\n  Added note that calling clone() without an arg may warn in future.\n  Minor changes to the install_method() docs in DBI::DBD.\n  Updated dbipport.h from Devel::PPPort 3.20\n\n=head2 Changes in DBI 1.617 (svn r15107) 30th January 2012\n\n  NOTE: The officially supported minimum perl version will change\n  from perl 5.8.1 (2003) to perl 5.8.3 (2004) in a future release.\n  (The last change, from perl 5.6 to 5.8.1, was announced\n  in July 2008 and implemented in DBI 1.611 in April 2010.)\n\n  Fixed ParamTypes example in the pod (Martin J. Evans)\n  Fixed the definition of ArrayTupleStatus and remove confusion over\n    rows affected in list context of execute_array (Martin J. Evans)\n  Fixed sql_type_cast example and typo in errors (Martin J. Evans)\n  Fixed Gofer error handling for keeperr methods like ping (Tim Bunce)\n  Fixed $dbh->clone({}) RT73250 (Tim Bunce)\n  Fixed is_nested_call logic error RT73118 (Reini Urban)\n\n  Enhanced performance for threaded perls (Dave Mitchell, Tim Bunce)\n    Dave's work on this optimization was sponsored by Booking.com.\n  Enhanced and standardized driver trace level mechanism (Tim Bunce)\n  Removed old code that was an inneffective attempt to detect\n    people doing DBI->{Attrib}.\n  Clear ParamValues on bind_param param count error RT66127 (Tim Bunce)\n  Changed DBI::ProxyServer to require DBI at compile-time RT62672 (Tim Bunce)\n\n  Added pod for default_user to DBI::DBD (Martin J. Evans)\n  Added CON, ENC and DBD trace flags and extended 09trace.t (Martin J. Evans)\n  Added TXN trace flags and applied CON and TXN to relevant methods (Tim Bunce)\n  Added some more fetchall_arrayref(..., $maxrows) tests (Tim Bunce)\n  Clarified docs for fetchall_arrayref called on an inactive handle.\n  Clarified docs for clone method (Tim Bunce)\n  Added note to DBI::Profile about async queries (Marcel Gr\u00fcnauer).\n  Reserved spatialite_ as a driver prefix for DBD::Spatialite\n  Reserved mo_ as a driver prefix for DBD::MO\n  Updated link to the SQL Reunion 95 docs, RT69577 (Ash Daminato)\n  Changed links for DBI recipes. RT73286 (Martin J. Evans)\n\n=head2 Changes in DBI 1.616 (svn r14616) 30th December 2010\n\n  Fixed spurious dbi_profile lines written to the log when\n    profiling is enabled and a trace flag, like SQL, is used.\n  Fixed to recognize SQL::Statement errors even if instantiated\n    with RaiseError=0 (Jens Rehsack)\n  Fixed RT#61513 by catching attribute assignment to tied table access\n    interface (Jens Rehsack)\n  Fixing some misbehavior of DBD::File when running within the Gofer\n    server.\n  Fixed compiler warnings RT#62640\n\n  Optimized connect() to remove redundant FETCH of \\%attrib values.\n  Improved initialization phases in DBI::DBD::SqlEngine (Jens Rehsack)\n\n  Added DBD::Gofer::Transport::corostream. An experimental proof-of-concept\n    transport that enables asynchronous database calls with few code changes.\n    It enables asynchronous use of DBI frameworks like DBIx::Class.\n\n  Added additional notes on DBDs which avoid creating a statement in\n    the do() method and the effects on error handlers (Martin J. Evans)\n  Adding new attribute \"sql_dialect\" to DBI::DBD::SqlEngine to allow\n    users control used SQL dialect (ANSI, CSV or AnyData), defaults to\n    CSV (Jens Rehsack)\n  Add documentation for DBI::DBD::SqlEngine attributes (Jens Rehsack)\n  Documented dbd_st_execute return (Martin J. Evans)\n  Fixed typo in InactiveDestroy thanks to Emmanuel Rodriguez.\n\n=head2 Changes in DBI 1.615 (svn r14438) 21st September 2010\n\n  Fixed t/51dbm_file for file/directory names with whitespaces in them\n    RT#61445 (Jens Rehsack)\n  Fixed compiler warnings from ignored hv_store result (Martin J. Evans)\n  Fixed portability to VMS (Craig A. Berry)\n\n=head2 Changes in DBI 1.614 (svn r14408) 17th September 2010\n\n  Fixed bind_param () in DBI::DBD::SqlEngine (rt#61281)\n  Fixed internals to not refer to old perl symbols that\n    will no longer be visible in perl >5.13.3 (Andreas Koenig)\n    Many compiled drivers are likely to need updating.\n  Fixed issue in DBD::File when absolute filename is used as table name\n    (Jens Rehsack)\n  Croak manually when file after tie doesn't exists in DBD::DBM\n    when it have to exists (Jens Rehsack)\n  Fixed issue in DBD::File when users set individual file name for tables\n    via f_meta compatibility interface - reported by H.Merijn Brand while\n    working on RT#61168 (Jens Rehsack)\n\n  Changed 50dbm_simple to simplify and fix problems (Martin J. Evans)\n  Changed 50dbm_simple to skip aggregation tests when not using\n    SQL::Statement (Jens Rehsack)\n  Minor speed improvements in DBD::File (Jens Rehsack)\n\n  Added $h->{AutoInactiveDestroy} as simpler safer form of\n    $h->{InactiveDestroy} (David E. Wheeler)\n  Added ability for parallel testing \"prove -j4 ...\" (Jens Rehsack)\n  Added tests for delete in DBM (H.Merijn Brand)\n  Added test for absolute filename as table to 51dbm_file (Jens Rehsack)\n  Added two initialization phases to DBI::DBD::SqlEngine (Jens Rehsack)\n  Added improved developers documentation for DBI::DBD::SqlEngine\n    (Jens Rehsack)\n  Added guides how to write DBI drivers using DBI::DBD::SqlEngine\n    or DBD::File (Jens Rehsack)\n  Added register_compat_map() and table_meta_attr_changed() to\n    DBD::File::Table to support clean fix of RT#61168 (Jens Rehsack)\n\n=head2 Changes in DBI 1.613 (svn r14271) 22nd July 2010\n\n  Fixed Win32 prerequisite module from PathTools to File::Spec.\n\n  Changed attribute headings and fixed references in DBI pod (Martin J. Evans)\n  Corrected typos in DBI::FAQ and DBI::ProxyServer (Ansgar Burchardt)\n\n=head2 Changes in DBI 1.612 (svn r14254) 16th July 2010\n\nNOTE: This is a minor release for the DBI core but a major release for\nDBD::File and drivers that depend on it, like DBD::DBM and DBD::CSV.\n\nThis is also the first release where the bulk of the development work\nhas been done by other people. I'd like to thank (in no particular order)\nJens Rehsack, Martin J. Evans, and H.Merijn Brand for all their contributions.\n\n  Fixed DBD::File's {ChopBlank} handling (it stripped \\s instead of space\n    only as documented in DBI) (H.Merijn Brand)\n  Fixed DBD::DBM breakage with SQL::Statement (Jens Rehsack, fixes RT#56561)\n  Fixed DBD::File file handle leak (Jens Rehsack)\n  Fixed problems in 50dbm.t when running tests with multiple\n    dbms (Martin J. Evans)\n  Fixed DBD::DBM bugs found during tests (Jens Rehsack)\n  Fixed DBD::File doesn't find files without extensions under some\n    circumstances (Jens Rehsack, H.Merijn Brand, fixes RT#59038)\n\n  Changed Makefile.PL to modernize with CONFLICTS, recommended dependencies\n    and resources (Jens Rehsack)\n  Changed DBI::ProfileDumper to rename any existing profile file by\n    appending .prev, instead of overwriting it.\n  Changed DBI::ProfileDumper::Apache to work in more configurations\n    including vhosts using PerlOptions +Parent.\n  Add driver_prefix method to DBI (Jens Rehsack)\n\n  Added more tests to 50dbm_simple.t to prove optimizations in\n    DBI::SQL::Nano and SQL::Statement (Jens Rehsack)\n  Updated tests to cover optional installed SQL::Statement (Jens Rehsack)\n  Synchronize API between SQL::Statement and DBI::SQL::Nano (Jens Rehsack)\n  Merged some optimizations from SQL::Statement into DBI::SQL::Nano\n    (Jens Rehsack)\n  Added basic test for DBD::File (H.Merijn Brand, Jens Rehsack)\n  Extract dealing with Perl SQL engines from DBD::File into\n    DBI::DBD::SqlEngine for better subclassing of 3rd party non-db DBDs\n    (Jens Rehsack)\n\n  Updated and clarified documentation for finish method (Tim Bunce).\n  Changes to DBD::File for better English and hopefully better\n    explanation (Martin J. Evans)\n  Update documentation of DBD::DBM to cover current implementation,\n    tried to explain some things better and changes most examples to\n    preferred style of Merijn and myself (Jens Rehsack)\n  Added developer documentation (including a roadmap of future plans)\n    for DBD::File\n\n=head2 Changes in DBI 1.611 (svn r13935) 29th April 2010\n\n  NOTE: minimum perl version is now 5.8.1 (as announced in DBI 1.607)\n\n  Fixed selectcol_arrayref MaxRows attribute to count rows not values\n    thanks to Vernon Lyon.\n  Fixed DBI->trace(0, *STDERR); (H.Merijn Brand)\n    which tried to open a file named \"*main::STDERR\" in perl-5.10.x\n  Fixes in DBD::DBM for use under threads (Jens Rehsack)\n\n  Changed \"Issuing rollback() due to DESTROY without explicit disconnect\"\n    warning to not be issued if ReadOnly set for that dbh.\n\n  Added f_lock and f_encoding support to DBD::File (H.Merijn Brand)\n  Added ChildCallbacks => { ... } to Callbacks as a way to\n    specify Callbacks for child handles.\n    With tests added by David E. Wheeler.\n  Added DBI::sql_type_cast($value, $type, $flags) to cast a string value\n    to an SQL type. e.g. SQL_INTEGER effectively does $value += 0;\n    Has other options plus an internal interface for drivers.\n\n  Documentation changes:\n  Small fixes in the documentation of DBD::DBM (H.Merijn Brand)\n  Documented specification of type casting behaviour for bind_col()\n    based on DBI::sql_type_cast() and two new bind_col attributes\n    StrictlyTyped and DiscardString. Thanks to Martin Evans.\n  Document fetchrow_hashref() behaviour for functions,\n    aliases and duplicate names (H.Merijn Brand)\n  Updated DBI::Profile and DBD::File docs to fix pod nits\n    thanks to Frank Wiegand.\n  Corrected typos in Gopher documentation reported by Jan Krynicky.\n  Documented the Callbacks attribute thanks to David E. Wheeler.\n  Corrected the Timeout examples as per rt 50621 (Martin J. Evans).\n  Removed some internal broken links in the pod (Martin J. Evans)\n  Added Note to column_info for drivers which do not\n    support it (Martin J. Evans)\n  Updated dbipport.h to Devel::PPPort 3.19 (H.Merijn Brand)\n\n=head2 Changes in DBI 1.609 (svn r12816) 8th June 2009\n\n  Fixes to DBD::File (H.Merijn Brand)\n    added f_schema attribute\n    table names case sensitive when quoted, insensitive when unquoted\n    workaround a bug in SQL::Statement (temporary fix) related\n      to the \"You passed x parameters where y required\" error\n\n  Added ImplementorClass and Name info to the \"Issuing rollback() due to\n    DESTROY without explicit disconnect\" warning to identify the handle.\n    Applies to compiled drivers when they are recompiled.\n  Added DBI->visit_handles($coderef) method.\n  Added $h->visit_child_handles($coderef) method.\n  Added docs for column_info()'s COLUMN_DEF value.\n  Clarified docs on stickyness of data type via bind_param().\n  Clarified docs on stickyness of data type via bind_col().\n\n=head2 Changes in DBI 1.608 (svn r12742) 5th May 2009\n\n  Fixes to DBD::File (H.Merijn Brand)\n    bind_param () now honors the attribute argument\n    added f_ext attribute\n    File::Spec is always required. (CORE since 5.00405)\n    Fail and set errstr on parameter count mismatch in execute ()\n  Fixed two small memory leaks when running in mod_perl\n    one in DBI->connect and one in DBI::Gofer::Execute.\n    Both due to \"local $ENV{...};\" leaking memory.\n  Fixed DBD_ATTRIB_DELETE macro for driver authors\n    and updated DBI::DBD docs thanks to Martin J. Evans.\n  Fixed 64bit issues in trace messages thanks to Charles Jardine.\n  Fixed FETCH_many() method to work with drivers that incorrectly return\n    an empty list from $h->FETCH. Affected gofer.\n\n  Added 'sqlite_' as registered prefix for DBD::SQLite.\n  Corrected many typos in DBI docs thanks to Martin J. Evans.\n  Improved DBI::DBD docs thanks to H.Merijn Brand.\n\n=head2 Changes in DBI 1.607 (svn r11571) 22nd July 2008\n\n  NOTE: Perl 5.8.1 is now the minimum supported version.\n  If you need support for earlier versions send me a patch.\n\n  Fixed missing import of carp in DBI::Gofer::Execute.\n\n  Added note to docs about effect of execute(@empty_array).\n  Clarified docs for ReadOnly thanks to Martin Evans.\n\n=head2 Changes in DBI 1.605 (svn r11434) 16th June 2008\n\n  Fixed broken DBIS macro with threads on big-endian machines\n    with 64bit ints but 32bit pointers. Ticket #32309.\n  Fixed the selectall_arrayref, selectrow_arrayref, and selectrow_array\n    methods that get embedded into compiled drivers to use the\n    inner sth handle when passed a $sth instead of an sql string.\n    Drivers will need to be recompiled to pick up this change.\n  Fixed leak in neat() for some kinds of values thanks to Rudolf Lippan.\n  Fixed DBI::PurePerl neat() to behave more like XS neat().\n\n  Increased default $DBI::neat_maxlen from 400 to 1000.\n  Increased timeout on tests to accommodate very slow systems.\n  Changed behaviour of trace levels 1..4 to show less information\n    at lower levels.\n  Changed the format of the key used for $h->{CachedKids}\n    (which is undocumented so you shouldn't depend on it anyway)\n  Changed gofer error handling to avoid duplicate error text in errstr.\n  Clarified docs re \":N\" style placeholders.\n  Improved gofer retry-on-error logic and refactored to aid subclassing.\n  Improved gofer trace output in assorted ways.\n\n  Removed the beeps \"\\a\" from Makefile.PL warnings.\n  Removed check for PlRPC-modules from Makefile.PL\n\n  Added sorting of ParamValues reported by ShowErrorStatement\n    thanks to to Rudolf Lippan.\n  Added cache miss trace message to DBD::Gofer transport class.\n  Added $drh->dbixs_revision method.\n  Added explicit LICENSE specification (perl) to META.yaml\n\n=head2 Changes in DBI 1.604 (svn rev 10994) 24th March 2008\n\n  Fixed fetchall_arrayref with $max_rows argument broken in 1.603,\n    thanks to Greg Sabino Mullane.\n  Fixed a few harmless compiler warnings on cygwin.\n\n=head2 Changes in DBI 1.603\n\n  Fixed pure-perl fetchall_arrayref with $max_rows argument\n    to not error when fetching after all rows already fetched.\n    (Was fixed for compiled drivers back in DBI 1.31.)\n    Thanks to Mark Overmeer.\n  Fixed C sprintf formats and casts, fixing compiler warnings.\n\n  Changed dbi_profile() to accept a hash of profiles and apply to all.\n  Changed gofer stream transport to improve error reporting.\n  Changed gofer test timeout to avoid spurious failures on slow systems.\n\n  Added options to t/85gofer.t so it's more useful for manual testing.\n\n=head2 Changes in DBI 1.602 (svn rev 10706)  8th February 2008\n\n  Fixed potential coredump if stack reallocated while calling back\n    into perl from XS code. Thanks to John Gardiner Myers.\n  Fixed DBI::Util::CacheMemory->new to not clear the cache.\n  Fixed avg in DBI::Profile as_text() thanks to Abe Ingersoll.\n  Fixed DBD::DBM bug in push_names thanks to J M Davitt.\n  Fixed take_imp_data for some platforms thanks to Jeffrey Klein.\n  Fixed docs tie'ing CacheKids (ie LRU cache) thanks to Peter John Edwards.\n\n  Expanded DBI::DBD docs for driver authors thanks to Martin Evans.\n  Enhanced t/80proxy.t test script.\n  Enhanced t/85gofer.t test script thanks to Stig.\n  Enhanced t/10examp.t test script thanks to David Cantrell.\n  Documented $DBI::stderr as the default value of err for internal errors.\n\n  Gofer changes:\n    track_recent now also keeps track of N most recent errors.\n    The connect method is now also counted in stats.\n\n=head2 Changes in DBI 1.601 (svn rev 10103),  21st October 2007\n\n  Fixed t/05thrclone.t to work with Test::More >= 0.71\n    thanks to Jerry D. Hedden and Michael G Schwern.\n  Fixed DBI for VMS thanks to Peter (Stig) Edwards.\n\n  Added client-side caching to DBD::Gofer. Can use any cache with\n    get($k)/set($k,$v) methods, including all the Cache and Cache::Cache\n    distribution modules plus Cache::Memcached, Cache::FastMmap etc.\n    Works for all transports. Overridable per handle.\n\n  Added DBI::Util::CacheMemory for use with DBD::Gofer caching.\n    It's a very fast and small strict subset of Cache::Memory.\n\n=head2 Changes in DBI 1.59 (svn rev 9874),  23rd August 2007\n\n  Fixed DBI::ProfileData to unescape headers lines read from data file.\n  Fixed DBI::ProfileData to not clobber $_, thanks to Alexey Tourbin.\n  Fixed DBI::SQL::Nano to not clobber $_, thanks to Alexey Tourbin.\n  Fixed DBI::PurePerl to return undef for ChildHandles if weaken not available.\n  Fixed DBD::Proxy disconnect error thanks to Philip Dye.\n  Fixed DBD::Gofer::Transport::Base bug (typo) in timeout code.\n  Fixed DBD::Proxy rows method thanks to Philip Dye.\n  Fixed dbiprof compile errors, thanks to Alexey Tourbin.\n  Fixed t/03handle.t to skip some tests if ChildHandles not available.\n\n  Added check_response_sub to DBI::Gofer::Execute\n\n=head2 Changes in DBI 1.58 (svn rev 9678),  25th June 2007\n\n  Fixed code triggering fatal error in bleadperl, thanks to Steve Hay.\n  Fixed compiler warning thanks to Jerry D. Hedden.\n  Fixed t/40profile.t to use int(dbi_time()) for systems like Cygwin where\n    time() seems to be rounded not truncated from the high resolution time.\n  Removed dump_results() test from t/80proxy.t.\n\n=head2 Changes in DBI 1.57 (svn rev 9639),  13th June 2007\n\n  Note: this release includes a change to the DBI::hash() function which will\n  now produce different values than before *if* your perl was built with 64-bit\n  'int' type (i.e. \"perl -V:intsize\" says intsize='8').  It's relatively rare\n  for perl to be configured that way, even on 64-bit systems.\n\n  Fixed XS versions of select*_*() methods to call execute()\n    fetch() etc., with inner handle instead of outer.\n  Fixed execute_for_fetch() to not cache errstr values\n    thanks to Bart Degryse.\n  Fixed unused var compiler warning thanks to JDHEDDEN.\n  Fixed t/86gofer_fail tests to be less likely to fail falsely.\n\n  Changed DBI::hash to return 'I32' type instead of 'int' so results are\n    portable/consistent regardless of size of the int type.\n  Corrected timeout example in docs thanks to Egmont Koblinger.\n  Changed t/01basic.t to warn instead of failing when it detects\n    a problem with Math::BigInt (some recent versions had problems).\n\n  Added support for !Time and !Time~N to DBI::Profile Path. See docs.\n  Added extra trace info to connect_cached thanks to Walery Studennikov.\n  Added non-random (deterministic) mode to DBI_GOFER_RANDOM mechanism.\n  Added DBIXS_REVISION macro that drivers can use.\n  Added more docs for private_attribute_info() method.\n\n  DBI::Profile changes:\n    dbi_profile() now returns ref to relevant leaf node.\n    Don't profile DESTROY during global destruction.\n    Added as_node_path_list() and as_text() methods.\n  DBI::ProfileDumper changes:\n    Don't write file if there's no profile data.\n    Uses full natural precision when saving data (was using %.6f)\n    Optimized flush_to_disk().\n    Locks the data file while writing.\n    Enabled filename to be a code ref for dynamic names.\n  DBI::ProfileDumper::Apache changes:\n    Added Quiet=>1 to avoid write to STDERR in flush_to_disk().\n    Added Dir=>... to specify a writable destination directory.\n    Enabled DBI_PROFILE_APACHE_LOG_DIR for mod_perl 1 as well as 2.\n    Added parent pid to default data file name.\n  DBI::ProfileData changes:\n    Added DeleteFiles option to rename & delete files once read.\n    Locks the data files while reading.\n    Added ability to sort by Path elements.\n  dbiprof changes:\n    Added --dumpnodes and --delete options.\n  Added/updated docs for both DBI::ProfileDumper && ::Apache.\n\n=head2 Changes in DBI 1.56 (svn rev 9660),  18th June 2007\n\n  Fixed printf arg warnings thanks to JDHEDDEN.\n  Fixed returning driver-private sth attributes via gofer.\n\n  Changed pod docs docs to use =head3 instead of =item\n    so now in html you get links to individual methods etc.\n  Changed default gofer retry_limit from 2 to 0.\n  Changed tests to workaround Math::BigInt broken versions.\n  Changed dbi_profile_merge() to dbi_profile_merge_nodes()\n    old name still works as an alias for the new one.\n  Removed old DBI internal sanity check that's no longer valid\n    causing \"panic: DESTROY (dbih_clearcom)\" when tracing enabled\n\n  Added DBI_GOFER_RANDOM env var that can be use to trigger random\n    failures and delays when executing gofer requests. Designed to help\n    test automatic retry on failures and timeout handling.\n  Added lots more docs to all the DBD::Gofer and DBI::Gofer classes.\n\n=head2 Changes in DBI 1.55 (svn rev 9504),  4th May 2007\n\n  Fixed set_err() so HandleSetErr hook is executed reliably, if set.\n  Fixed accuracy of profiling when perl configured to use long doubles.\n  Fixed 42prof_data.t on fast systems with poor timers thanks to Malcolm Nooning.\n  Fixed potential corruption in selectall_arrayref and selectrow_arrayref\n    for compiled drivers, thanks to Rob Davies.\n    Rebuild your compiled drivers after installing DBI.\n\n  Changed some handle creation code from perl to C code,\n    to reduce handle creation cost by ~20%.\n  Changed internal implementation of the CachedKids attribute\n    so it's a normal handle attribute (and initially undef).\n  Changed connect_cached and prepare_cached to avoid a FETCH method call,\n    and thereby reduced cost by ~5% and ~30% respectively.\n  Changed _set_fbav to not croak when given a wrongly sized array,\n    it now warns and adjusts the row buffer to match.\n  Changed some internals to improve performance with threaded perls.\n  Changed DBD::NullP to be slightly more useful for testing.\n  Changed File::Spec prerequisite to not require a minimum version.\n  Changed tests to work with other DBMs thanks to ZMAN.\n  Changed ex/perl_dbi_nulls_test.pl to be more descriptive.\n\n  Added more functionality to the (undocumented) Callback mechanism.\n    Callbacks can now elect to provide a value to be returned, in which case\n    the method won't be called. A callback for \"*\" is applied to all methods\n    that don't have their own callback.\n  Added $h->{ReadOnly} attribute.\n  Added support for DBI Profile Path to contain refs to scalars\n    which will be de-ref'd for each profile sample.\n  Added dbilogstrip utility to edit DBI logs for diff'ing (gets installed)\n  Added details for SQLite 3.3 to NULL handling docs thanks to Alex Teslik.\n  Added take_imp_data() to DBI::PurePerl.\n\n  Gofer related changes:\n    Fixed gofer pipeone & stream transports to avoid risk of hanging.\n    Improved error handling and tracing significantly.\n    Added way to generate random 1-in-N failures for methods.\n    Added automatic retry-on-error mechanism to gofer transport base class.\n    Added tests to show automatic retry mechanism works a treat!\n    Added go_retry_hook callback hook so apps can fine-tune retry behaviour.\n    Added header to request and response packets for sanity checking\n      and to enable version skew between client and server.\n    Added forced_single_resultset, max_cached_sth_per_dbh and max_cached_dbh_per_drh\n      to gofer executor config.\n    Driver-private methods installed with install_method are now proxied.\n    No longer does a round-trip to the server for methods it knows\n      have not been overridden by the remote driver.\n    Most significant aspects of gofer behaviour are controlled by policy mechanism.\n    Added policy-controlled caching of results for some methods, such as schema metadata.\n    The connect_cached and prepare_cached methods cache on client and server.\n    The bind_param_array and execute_array methods are now supported.\n    Worked around a DBD::Sybase bind_param bug (which is fixed in DBD::Sybase 1.07)\n    Added goferperf.pl utility (doesn't get installed).\n    Many other assorted Gofer related bug fixes, enhancements and docs.\n    The http and mod_perl transports have been remove to their own distribution.\n    Client and server will need upgrading together for this release.\n\n=head2 Changes in DBI 1.54 (svn rev 9157),  23rd February 2007\n\n  NOTE: This release includes the 'next big thing': DBD::Gofer.\n  Take a look!\n\n  WARNING: This version has some subtle changes in DBI internals.\n  It's possible, though doubtful, that some may affect your code.\n  I recommend some extra testing before using this release.\n  Or perhaps I'm just being over cautious...\n\n  Fixed type_info when called for multiple dbh thanks to Cosimo Streppone.\n  Fixed compile warnings in bleadperl on freebsd-6.1-release\n    and solaris 10g thanks to Philip M. Gollucci.\n  Fixed to compile for perl built with -DNO_MATHOMS thanks to Jerry D. Hedden.\n  Fixed to work for bleadperl (r29544) thanks to Nicholas Clark.\n    Users of Perl >= 5.9.5 will require DBI >= 1.54.\n  Fixed rare error when profiling access to $DBI::err etc tied variables.\n  Fixed DBI::ProfileDumper to not be affected by changes to $/ and $,\n    thanks to Michael Schwern.\n\n  Changed t/40profile.t to skip tests for perl < 5.8.0.\n  Changed setting trace file to no longer write \"Trace file set\" to new file.\n  Changed 'handle cleared whilst still active' warning for dbh\n    to only be given for dbh that have active sth or are not AutoCommit.\n  Changed take_imp_data to call finish on all Active child sth.\n  Changed DBI::PurePerl trace() method to be more consistent.\n  Changed set_err method to effectively not append to errstr if the new errstr\n    is the same as the current one.\n  Changed handle factory methods, like connect, prepare, and table_info,\n    to copy any error/warn/info state of the handle being returned\n    up into the handle the method was called on.\n  Changed row buffer handling to not alter NUM_OF_FIELDS if it's\n    inconsistent with number of elements in row buffer array.\n  Updated DBI::DBD docs re handling multiple result sets.\n  Updated DBI::DBD docs for driver authors thanks to Ammon Riley\n    and Dean Arnold.\n  Updated column_info docs to note that if a table doesn't exist\n    you get an sth for an empty result set and not an error.\n\n  Added new DBD::Gofer 'stateless proxy' driver and framework,\n    and the DBI test suite is now also executed via DBD::Gofer,\n    and DBD::Gofer+DBI::PurePerl, in addition to DBI::PurePerl.\n  Added ability for trace() to support filehandle argument,\n    including tracing into a string, thanks to Dean Arnold.\n  Added ability for drivers to implement func() method\n    so proxy drivers can proxy the func method itself.\n  Added SQL_BIGINT type code (resolved to the ODBC/JDBC value (-5))\n  Added $h->private_attribute_info method.\n\n=head2 Changes in DBI 1.53 (svn rev 7995),   31st October 2006\n\n  Fixed checks for weaken to work with early 5.8.x versions\n  Fixed DBD::Proxy handling of some methods, including commit and rollback.\n  Fixed t/40profile.t to be more insensitive to long double precision.\n  Fixed t/40profile.t to be insensitive to small negative shifts in time\n    thanks to Jamie McCarthy.\n  Fixed t/40profile.t to skip tests for perl < 5.8.0.\n  Fixed to work with current 'bleadperl' (~5.9.5) thanks to Steve Peters.\n    Users of Perl >= 5.9.5 will require DBI >= 1.53.\n  Fixed to be more robust against drivers not handling multiple result\n    sets properly, thanks to Gisle Aas.\n\n  Added array context support to execute_array and execute_for_fetch\n    methods which returns executed tuples and rows affected.\n  Added Tie::Cache::LRU example to docs thanks to Brandon Black.\n\n=head2 Changes in DBI 1.52 (svn rev 6840),   30th July 2006\n\n  Fixed memory leak (per handle) thanks to Nicholas Clark and Ephraim Dan.\n  Fixed memory leak (16 bytes per sth) thanks to Doru Theodor Petrescu.\n  Fixed execute_for_fetch/execute_array to RaiseError thanks to Martin J. Evans.\n  Fixed for perl 5.9.4. Users of Perl >= 5.9.4 will require DBI >= 1.52.\n\n  Updated DBD::File to 0.35 to match the latest release on CPAN.\n\n  Added $dbh->statistics_info specification thanks to Brandon Black.\n\n  Many changes and additions to profiling:\n    Profile Path can now uses sane strings instead of obscure numbers,\n    can refer to attributes, assorted magical values, and even code refs!\n    Parsing of non-numeric DBI_PROFILE env var values has changed.\n    Changed DBI::Profile docs extensively - many new features.\n    See DBI::Profile docs for more information.\n\n=head2 Changes in DBI 1.51 (svn rev 6475),   6th June 2006\n\n  Fixed $dbh->clone method 'signature' thanks to Jeffrey Klein.\n  Fixed default ping() method to return false if !$dbh->{Active}.\n  Fixed t/40profile.t to be insensitive to long double precision.\n  Fixed for perl 5.8.0's more limited weaken() function.\n  Fixed DBD::Proxy to not alter $@ in disconnect or AUTOLOADd methods.\n  Fixed bind_columns() to use return set_err(...) instead of die()\n    to report incorrect number of parameters, thanks to Ben Thul.\n  Fixed bind_col() to ignore undef as bind location, thanks to David Wheeler.\n  Fixed for perl 5.9.x for non-threaded builds thanks to Nicholas Clark.\n    Users of Perl >= 5.9.x will require DBI >= 1.51.\n  Fixed fetching of rows as hash refs to preserve utf8 on field names\n    from $sth->{NAME} thanks to Alexey Gaidukov.\n  Fixed build on Win32 (dbd_postamble) thanks to David Golden.\n\n  Improved performance for thread-enabled perls thanks to Gisle Aas.\n  Drivers can now use PERL_NO_GET_CONTEXT thanks to Gisle Aas.\n    Driver authors please read the notes in the DBI::DBD docs.\n  Changed DBI::Profile format to always include a percentage,\n    if not exiting then uses time between the first and last DBI call.\n  Changed DBI::ProfileData to be more forgiving of systems with\n    unstable clocks (where time may go backwards occasionally).\n  Clarified the 'Subclassing the DBI' docs.\n  Assorted minor changes to docs from comments on annocpan.org.\n  Changed Makefile.PL to avoid incompatible options for old gcc.\n\n  Added 'fetch array of hash refs' example to selectall_arrayref\n    docs thanks to Tom Schindl.\n  Added docs for $sth->{ParamArrays} thanks to Martin J. Evans.\n  Added reference to $DBI::neat_maxlen in TRACING section of docs.\n  Added ability for DBI::Profile Path to include attributes\n    and a summary of where the code was called from.\n\n=head2 Changes in DBI 1.50 (svn rev 2307),   13 December 2005\n\n  Fixed Makefile.PL options for gcc bug introduced in 1.49.\n  Fixed handle magic order to keep DBD::Oracle happy.\n  Fixed selectrow_array to return empty list on error.\n\n  Changed dbi_profile_merge() to be able to recurse and merge\n    sub-trees of profile data.\n\n  Added documentation for dbi_profile_merge(), including how to\n    measure the time spent inside the DBI for an http request.\n\n=head2 Changes in DBI 1.49 (svn rev 2287),   29th November 2005\n\n  Fixed assorted attribute handling bugs in DBD::Proxy.\n  Fixed croak() in DBD::NullP thanks to Sergey Skvortsov.\n  Fixed handling of take_imp_data() and dbi_imp_data attribute.\n  Fixed bugs in DBD::DBM thanks to Jeff Zucker.\n  Fixed bug in DBI::ProfileDumper thanks to Sam Tregar.\n  Fixed ping in DBD::Proxy thanks to George Campbell.\n  Fixed dangling ref in $sth after parent $dbh destroyed\n    with thanks to il@rol.ru for the bug report #13151\n  Fixed prerequisites to include Storable thanks to Michael Schwern.\n  Fixed take_imp_data to be more practical.\n\n  Change to require perl 5.6.1 (as advertised in 2003) not 5.6.0.\n  Changed internals to be more strictly coded thanks to Andy Lester.\n  Changed warning about multiple copies of Driver.xst found in @INC\n    to ignore duplicated directories thanks to Ed Avis.\n  Changed Driver.xst to enable drivers to define an dbd_st_prepare_sv\n    function where the statement parameter is an SV. That enables\n    compiled drivers to support SQL strings that are UTF-8.\n  Changed \"use DBI\" to only set $DBI::connect_via if not already set.\n  Changed docs to clarify pre-method clearing of err values.\n\n  Added ability for DBI::ProfileData to edit profile path on loading.\n    This enables aggregation of different SQL statements into the same\n    profile node - very handy when not using placeholders or when working\n    multiple separate tables for the same thing (ie logtable_2005_11_28)\n  Added $sth->{ParamTypes} specification thanks to Dean Arnold.\n  Added $h->{Callbacks} attribute to enable code hooks to be invoked\n    when certain methods are called. For example:\n    $dbh->{Callbacks}->{prepare} = sub { ... };\n    With thanks to David Wheeler for the kick start.\n  Added $h->{ChildHandles} (using weakrefs) thanks to Sam Tregar\n    I've recoded it in C so there's no significant performance impact.\n  Added $h->{Type} docs (returns 'dr', 'db', or 'st')\n  Adding trace message in DESTROY if InactiveDestroy enabled.\n  Added %drhs = DBI->installed_drivers();\n\n  Ported DBI::ProfileDumper::Apache to mod_perl2 RC5+\n    thanks to Philip M. Golluci\n\n=head2 Changes in DBI 1.48 (svn rev 928),    14th March 2005\n\n  Fixed DBI::DBD::Metadata generation of type_info_all thanks to Steffen Goeldner\n    (driver authors who have used it should rerun it).\n\n  Updated docs for NULL Value placeholders thanks to Brian Campbell.\n\n  Added multi-keyfield nested hash fetching to fetchall_hashref()\n    thanks to Zhuang (John) Li for polishing up my draft.\n  Added registered driver prefixes: amzn_ for DBD::Amazon and yaswi_ for DBD::Yaswi.\n\n\n=head2 Changes in DBI 1.47 (svn rev 854),    2nd February 2005\n\n  Fixed DBI::ProxyServer to not create pid files by default.\n    References: Ubuntu Security Notice USN-70-1, CAN-2005-0077\n    Thanks to Javier Fern\u00e1ndez-Sanguino Pe\u00f1a from the\n    Debian Security Audit Project, and Jonathan Leffler.\n  Fixed some tests to work with older Test::More versions.\n  Fixed setting $DBI::err/errstr in DBI::PurePerl.\n  Fixed potential undef warning from connect_cached().\n  Fixed $DBI::lasth handling for DESTROY so lasth points to\n    parent even if DESTROY called other methods.\n  Fixed DBD::Proxy method calls to not alter $@.\n  Fixed DBD::File problem with encoding pragma thanks to Erik Rijkers.\n\n  Changed error handling so undef errstr doesn't cause warning.\n  Changed DBI::DBD docs to use =head3/=head4 pod thanks to\n    Jonathan Leffler. This may generate warnings for perl 5.6.\n  Changed DBI::PurePerl to set autoflush on trace filehandle.\n  Changed DBD::Proxy to treat Username as a local attribute\n    so recent DBI version can be used with old DBI::ProxyServer.\n  Changed driver handle caching in DBD::File.\n  Added $GetInfoType{SQL_DATABASE_NAME} thanks to Steffen Goeldner.\n\n  Updated docs to recommend some common DSN string attributes.\n  Updated connect_cached() docs with issues and suggestions.\n  Updated docs for NULL Value placeholders thanks to Brian Campbell.\n  Updated docs for primary_key_info and primary_keys.\n  Updated docs to clarify that the default fetchrow_hashref behaviour,\n    of returning a ref to a new hash for each row, will not change.\n  Updated err/errstr/state docs for DBD authors thanks to Steffen Goeldner.\n  Updated handle/attribute docs for DBD authors thanks to Steffen Goeldner.\n  Corrected and updated LongReadLen docs thanks to Bart Lateur.\n  Added DBD::JDBC as a registered driver.\n\n=head2 Changes in DBI 1.46 (svn rev 584),    16th November 2004\n\n  Fixed parsing bugs in DBI::SQL::Nano thanks to Jeff Zucker.\n  Fixed a couple of bad links in docs thanks to Graham Barr.\n  Fixed test.pl Win32 undef warning thanks to H.Merijn Brand & David Repko.\n  Fixed minor issues in DBI::DBD::Metadata thanks to Steffen Goeldner.\n  Fixed DBI::PurePerl neat() to use double quotes for utf8.\n\n  Changed execute_array() definition, and default implementation,\n    to not consider scalar values for execute tuple count. See docs.\n  Changed DBD::File to enable ShowErrorStatement by default,\n    which affects DBD::File subclasses such as DBD::CSV and DBD::DBM.\n  Changed use DBI qw(:utils) tag to include $neat_maxlen.\n  Updated Roadmap and ToDo.\n\n  Added data_string_diff() data_string_desc() and data_diff()\n    utility functions to help diagnose Unicode issues.\n    All can be imported via the use DBI qw(:utils) tag.\n\n=head2 Changes in DBI 1.45 (svn rev 480),    6th October 2004\n\n  Fixed DBI::DBD code for drivers broken in 1.44.\n  Fixed \"Free to wrong pool\"/\"Attempt to free unreferenced scalar\" in FETCH.\n\n=head2 Changes in DBI 1.44 (svn rev 478),    5th October 2004\n\n  Fixed build issues on VMS thanks to Jakob Snoer.\n  Fixed DBD::File finish() method to return 1 thanks to Jan Dubois.\n  Fixed rare core dump during global destruction thanks to Mark Jason Dominus.\n  Fixed risk of utf8 flag persisting from one row to the next.\n\n  Changed bind_param_array() so it doesn't require all bind arrays\n    to have the same number of elements.\n  Changed bind_param_array() to error if placeholder number <= 0.\n  Changed execute_array() definition, and default implementation,\n    to effectively NULL-pad shorter bind arrays.\n  Changed execute_array() to return \"0E0\" for 0 as per the docs.\n  Changed execute_for_fetch() definition, and default implementation,\n    to return \"0E0\" for 0 like execute() and execute_array().\n  Changed Test::More prerequisite to Test::Simple (which is also the name\n    of the distribution both are packaged in) to work around ppm behaviour.\n\n  Corrected docs to say that get/set of unknown attribute generates\n    a warning and is no longer fatal. Thanks to Vadim.\n  Corrected fetchall_arrayref() docs example thanks to Drew Broadley.\n\n  Added $h1->swap_inner_handle($h2) sponsored by BizRate.com\n\n\n=head2 Changes in DBI 1.43 (svn rev 377),    2nd July 2004\n\n  Fixed connect() and connect_cached() RaiseError/PrintError\n    which would sometimes show \"(no error string)\" as the error.\n  Fixed compiler warning thanks to Paul Marquess.\n  Fixed \"trace level set to\" trace message thanks to H.Merijn Brand.\n  Fixed DBD::DBM $dbh->{dbm_tables}->{...} to be keyed by the\n    table name not the file name thanks to Jeff Zucker.\n  Fixed last_insert_id(...) thanks to Rudy Lippan.\n  Fixed propagation of scalar/list context into proxied methods.\n  Fixed DBI::Profile::DESTROY to not alter $@.\n  Fixed DBI::ProfileDumper new() docs thanks to Michael Schwern.\n  Fixed _load_class to propagate $@ thanks to Drew Taylor.\n  Fixed compile warnings on Win32 thanks to Robert Baron.\n  Fixed problem building with recent versions of MakeMaker.\n  Fixed DBD::Sponge not to generate warning with threads.\n  Fixed DBI_AUTOPROXY to work more than once thanks to Steven Hirsch.\n\n  Changed TraceLevel 1 to not show recursive/nested calls.\n  Changed getting or setting an invalid attribute to no longer be\n    a fatal error but generate a warning instead.\n  Changed selectall_arrayref() to call finish() if\n    $attr->{MaxRows} is defined.\n  Changed all tests to use Test::More and enhanced the tests thanks\n    to Stevan Little and Andy Lester. See http://qa.perl.org/phalanx/\n  Changed Test::More minimum prerequisite version to 0.40 (2001).\n  Changed DBI::Profile header to include the date and time.\n\n  Added DBI->parse_dsn($dsn) method.\n  Added warning if build directory path contains white space.\n  Added docs for parse_trace_flags() and parse_trace_flag().\n  Removed \"may change\" warnings from the docs for table_info(),\n    primary_key_info(), and foreign_key_info() methods.\n\n=head2 Changes in DBI 1.42 (svn rev 222),    12th March 2004\n\n  Fixed $sth->{NUM_OF_FIELDS} of non-executed statement handle\n    to be undef as per the docs (it was 0).\n  Fixed t/41prof_dump.t to work with perl5.9.1.\n  Fixed DBD_ATTRIB_DELETE macro thanks to Marco Paskamp.\n  Fixed DBI::PurePerl looks_like_number() and $DBI::rows.\n  Fixed ref($h)->can(\"foo\") to not croak.\n\n  Changed attributes (NAME, TYPE etc) of non-executed statement\n    handle to be undef instead of triggering an error.\n  Changed ShowErrorStatement to apply to more $dbh methods.\n  Changed DBI_TRACE env var so just does this at load time:\n    DBI->trace(split '=', $ENV{DBI_TRACE}, 2);\n  Improved \"invalid number of parameters\" error message.\n  Added DBI::common as base class for DBI::db, DBD::st etc.\n  Moved methods common to all handles into DBI::common.\n\n  Major tracing enhancement:\n\n  Added $h->parse_trace_flags(\"foo|SQL|7\") to map a group of\n    trace flags into the corresponding trace flag bits.\n  Added automatic calling of parse_trace_flags() if\n    setting the trace level to a non-numeric value:\n    $h->{TraceLevel}=\"foo|SQL|7\"; $h->trace(\"foo|SQL|7\");\n    DBI->connect(\"dbi:Driver(TraceLevel=SQL|foo):...\", ...);\n    Currently no trace flags have been defined.\n  Added to, and reworked, the trace documentation.\n  Added dbivport.h for driver authors to use.\n\n  Major driver additions that Jeff Zucker and I have been working on:\n\n  Added DBI::SQL::Nano a 'smaller than micro' SQL parser\n    with an SQL::Statement compatible API. If SQL::Statement\n    is installed then DBI::SQL::Nano becomes an empty subclass\n    of SQL::Statement, unless the DBI_SQL_NANO env var is true.\n  Added DBD::File, modified to use DBI::SQL::Nano.\n  Added DBD::DBM, an SQL interface to DBM files using DBD::File.\n\n  Documentation changes:\n\n  Corrected typos in docs thanks to Steffen Goeldner.\n  Corrected execute_for_fetch example thanks to Dean Arnold.\n\n=head2 Changes in DBI 1.41 (svn rev 130),    22nd February 2004\n\n  Fixed execute_for_array() so tuple_status parameter is optional\n    as per docs, thanks to Ed Avis.\n  Fixed execute_for_array() docs to say that it returns undef if\n    any of the execute() calls fail.\n  Fixed take_imp_data() test on m68k reported by Christian Hammers.\n  Fixed write_typeinfo_pm inconsistencies in DBI::DBD::Metadata\n    thanks to Andy Hassall.\n  Fixed $h->{TraceLevel} to not return DBI->trace trace level\n    which it used to if DBI->trace trace level was higher.\n\n  Changed set_err() to append to errstr, with a leading \"\\n\" if it's\n    not empty, so that multiple error/warning messages are recorded.\n  Changed trace to limit elements dumped when an array reference is\n    returned from a method to the max(40, $DBI::neat_maxlen/10)\n    so that fetchall_arrayref(), for example, doesn't flood the trace.\n  Changed trace level to be a four bit integer (levels 0 thru 15)\n    and a set of topic flags (no topics have been assigned yet).\n  Changed column_info() to check argument count.\n  Extended bind_param() TYPE attribute specification to imply\n    standard formating of value, eg SQL_DATE implies 'YYYY-MM-DD'.\n\n  Added way for drivers to indicate 'success with info' or 'warning'\n    by setting err to \"0\" for warning and \"\" for information.\n    Both values are false and so don't trigger RaiseError etc.\n    Thanks to Steffen Goeldner for the original idea.\n  Added $h->{HandleSetErr} = sub { ... } to be called at the\n    point that an error, warn, or info state is recorded.\n    The code can alter the err, errstr, and state values\n    (e.g., to promote an error to a warning, or the reverse).\n  Added $h->{PrintWarn} attribute to enable printing of warnings\n    recorded by the driver. Defaults to same value as $^W (perl -w).\n  Added $h->{ErrCount} attribute, incremented whenever an error is\n    recorded by the driver via set_err().\n  Added $h->{Executed} attribute, set if do()/execute() called.\n  Added \\%attr parameter to foreign_key_info() method.\n  Added ref count of inner handle to \"DESTROY ignored for outer\" msg.\n  Added Win32 build config checks to DBI::DBD thanks to Andy Hassall.\n  Added bind_col to Driver.xst so drivers can define their own.\n  Added TYPE attribute to bind_col and specified the expected\n    driver behaviour.\n\n  Major update to signal handling docs thanks to Lincoln Baxter.\n  Corrected dbiproxy usage doc thanks to Christian Hammers.\n  Corrected type_info_all index hash docs thanks to Steffen Goeldner.\n  Corrected type_info COLUMN_SIZE to chars not bytes thanks to Dean Arnold.\n  Corrected get_info() docs to include details of DBI::Const::GetInfoType.\n  Clarified that $sth->{PRECISION} is OCTET_LENGTH for char types.\n\n=head2 Changes in DBI 1.40,    7th January 2004\n\n  Fixed handling of CachedKids when DESTROYing threaded handles.\n  Fixed sql_user_name() in DBI::DBD::Metadata (used by write_getinfo_pm)\n    to use $dbh->{Username}. Driver authors please update your code.\n\n  Changed connect_cached() when running under Apache::DBI\n    to route calls to Apache::DBI::connect().\n\n  Added CLONE() to DBD::Sponge and DBD::ExampleP.\n  Added warning when starting a new thread about any loaded driver\n    which does not have a CLONE() function.\n  Added new prepare_cache($sql, \\%attr, 3) option to manage Active handles.\n  Added SCALE and NULLABLE support to DBD::Sponge.\n  Added missing execute() in fetchall_hashref docs thanks to Iain Truskett.\n  Added a CONTRIBUTING section to the docs with notes on creating patches.\n\n=head2 Changes in DBI 1.39,    27th November 2003\n\n  Fixed STORE to not clear error during nested DBI call, again/better,\n    thanks to Tony Bowden for the report and helpful test case.\n  Fixed DBI dispatch to not try to use AUTOLOAD for driver methods unless\n    the method has been declared (as methods should be when using AUTOLOAD).\n    This fixes a problem when the Attribute::Handlers module is loaded.\n  Fixed cwd check code to use $Config{path_sep} thanks to Steve Hay.\n  Fixed unqualified croak() calls thanks to Steffen Goeldner.\n  Fixed DBD::ExampleP TYPE and PRECISION attributes thanks to Tom Lowery.\n  Fixed tracing of methods that only get traced at high trace levels.\n\n  The level 1 trace no longer includes nested method calls so it generally\n    just shows the methods the application explicitly calls.\n  Added line to trace log (level>=4) when err/errstr is cleared.\n  Updated docs for InactiveDestroy and point out where and when the\n    trace includes the process id.\n  Update DBI::DBD docs thanks to Steffen Goeldner.\n  Removed docs saying that the DBI->data_sources method could be\n    passed a $dbh. The $dbh->data_sources method should be used instead.\n  Added link to 'DBI recipes' thanks to Giuseppe Maxia:\n    http://gmax.oltrelinux.com/dbirecipes.html (note that this\n    is not an endorsement that the recipies are 'optimal')\n\n  Note: There is a bug in perl 5.8.2 when configured with threads\n  and debugging enabled (bug #24463) which causes a DBI test to fail.\n\n=head2 Changes in DBI 1.38,    21th August 2003\n\n  NOTE: The DBI now requires perl version 5.6.0 or later.\n  (As per notice in DBI 1.33 released 27th February 2003)\n\n  Fixed spurious t/03handles failure on 64bit perls reported by H.Merijn Brand.\n  Fixed spurious t/15array failure on some perl versions thanks to Ed Avis.\n  Fixed build using dmake on windows thanks to Steffen Goeldner.\n  Fixed build on using some shells thanks to Gurusamy Sarathy.\n  Fixed ParamValues to only be appended to ShowErrorStatement if not empty.\n  Fixed $dbh->{Statement} not being writable by drivers in some cases.\n  Fixed occasional undef warnings on connect failures thanks to Ed Avis.\n  Fixed small memory leak when using $sth->{NAME..._hash}.\n  Fixed 64bit warnings thanks to Marian Jancar.\n  Fixed DBD::Proxy::db::DESTROY to not alter $@ thanks to Keith Chapman.\n  Fixed Makefile.PL status from WriteMakefile() thanks to Leon Brocard.\n\n  Changed \"Can't set ...->{Foo}: unrecognised attribute\" from an error to a\n    warning when running with DBI::ProxyServer to simplify upgrades.\n  Changed execute_array() to no longer require ArrayTupleStatus attribute.\n  Changed DBI->available_drivers to not hide DBD::Sponge.\n  Updated/moved placeholder docs to a better place thanks to Johan Vromans.\n  Changed dbd_db_do4 api in Driver.xst to match dbd_st_execute (return int,\n    not bool), relevant only to driver authors.\n  Changed neat(), and thus trace(), so strings marked as utf8 are presented\n    in double quotes instead of single quotes and are not sanitized.\n\n  Added $dbh->data_sources method.\n  Added $dbh->last_insert_id method.\n  Added $sth->execute_for_fetch($fetch_tuple_sub, \\@tuple_status) method.\n  Added DBI->installed_versions thanks to Jeff Zucker.\n  Added $DBI::Profile::ON_DESTROY_DUMP variable.\n  Added docs for DBD::Sponge thanks to Mark Stosberg.\n\n=head2 Changes in DBI 1.37,    15th May 2003\n\n  Fixed \"Can't get dbh->{Statement}: unrecognised attribute\" error in test\n    caused by change to perl internals in 5.8.0\n  Fixed to build with latest development perl (5.8.1@19525).\n  Fixed C code to use all ANSI declarations thanks to Steven Lembark.\n\n=head2 Changes in DBI 1.36,    11th May 2003\n\n  Fixed DBI->connect to carp instead of croak on 'old-style' usage.\n  Fixed connect(,,, { RootClass => $foo }) to not croak if module not found.\n  Fixed code generated by DBI::DBD::Metadata thanks to DARREN@cpan.org (#2270)\n  Fixed DBI::PurePerl to not reset $@ during method dispatch.\n  Fixed VMS build thanks to Michael Schwern.\n  Fixed Proxy disconnect thanks to Steven Hirsch.\n  Fixed error in DBI::DBD docs thanks to Andy Hassall.\n\n  Changed t/40profile.t to not require Time::HiRes.\n  Changed DBI::ProxyServer to load DBI only on first request, which\n    helps threaded server mode, thanks to Bob Showalter.\n  Changed execute_array() return value from row count to executed\n    tuple count, and now the ArrayTupleStatus attribute is mandatory.\n    NOTE: That is an API definition change that may affect your code.\n  Changed CompatMode attribute to also disable attribute 'quick FETCH'.\n  Changed attribute FETCH to be slightly faster thanks to Stas Bekman.\n\n  Added workaround for perl bug #17575 tied hash nested FETCH\n    thanks to Silvio Wanka.\n  Added Username and Password attributes to connect(..., \\%attr) and so\n    also embedded in DSN like \"dbi:Driver(Username=user,Password=pass):...\"\n    Username and Password can't contain \")\", \",\", or \"=\" characters.\n    The predence is DSN first, then \\%attr, then $user & $pass parameters,\n    and finally the DBI_USER & DBI_PASS environment variables.\n    The Username attribute is stored in the $dbh but the Password is not.\n  Added ProxyServer HOWTO configure restrictions docs thanks to Jochen Wiedmann.\n  Added MaxRows attribute to selectcol_arrayref prompted by Wojciech Pietron.\n  Added dump_handle as a method not just a DBI:: utility function.\n  Added on-demand by-row data feed into execute_array() using code ref,\n    or statement handle. For example, to insert from a select:\n    $insert_sth->execute_array( { ArrayTupleFetch => $select_sth, ... } )\n  Added warning to trace log when $h->{foo}=... is ignored due to\n    invalid prefix (e.g., not 'private_').\n\n=head2 Changes in DBI 1.35,    7th March 2003\n\n  Fixed memory leak in fetchrow_hashref introduced in DBI 1.33.\n  Fixed various DBD::Proxy errors introduced in DBI 1.33.\n  Fixed to ANSI C in dbd_dr_data_sources thanks to Jonathan Leffler.\n  Fixed $h->can($method_name) to return correct code ref.\n  Removed DBI::Format from distribution as it's now part of the\n    separate DBI::Shell distribution by Tom Lowery.\n  Updated DBI::DBD docs with a note about the CLONE method.\n  Updated DBI::DBD docs thanks to Jonathan Leffler.\n  Updated DBI::DBD::Metadata for perl 5.5.3 thanks to Jonathan Leffler.\n  Added note to install_method docs about setup_driver() method.\n\n=head2 Changes in DBI 1.34,    28th February 2003\n\n  Fixed DBI::DBD docs to refer to DBI::DBD::Metadata thanks to Jonathan Leffler.\n  Fixed dbi_time() compile using BorlandC on Windows thanks to Steffen Goeldner.\n  Fixed profile tests to do enough work to measure on Windows.\n  Fixed disconnect_all() to not be required by drivers.\n\n  Added $okay = $h->can($method_name) to check if a method exists.\n  Added DBD::*::*->install_method($method_name, \\%attr) so driver private\n    methods can be 'installed' into the DBI dispatcher and no longer\n    need to be called using $h->func(..., $method_name).\n\n  Enhanced $dbh->clone() and documentation.\n  Enhanced docs to note that dbi_time(), and thus profiling, is limited\n    to only millisecond (seconds/1000) resolution on Windows.\n  Removed old DBI::Shell from distribution and added Tom Lowery's improved\n    version to the Bundle::DBI file.\n  Updated minimum version numbers for modules in Bundle::DBI.\n\n=head2 Changes in DBI 1.33,    27th February 2003\n\n  NOTE: Future versions of the DBI *will not* support perl 5.6.0 or earlier.\n  : Perl 5.6.1 will be the minimum supported version.\n\n  NOTE: The \"old-style\" connect: DBI->connect($database, $user, $pass, $driver);\n  : has been deprecated for several years and will now generate a warning.\n  : It will be removed in a later release. Please change any old connect() calls.\n\n  Added $dbh2 = $dbh1->clone to make a new connection to the database\n    that is identical to the original one. clone() can be called even after\n    the original handle has been disconnected. See the docs for more details.\n\n  Fixed merging of profile data to not sum DBIprof_FIRST_TIME values.\n  Fixed unescaping of newlines in DBI::ProfileData thanks to Sam Tregar.\n  Fixed Taint bug with fetchrow_hashref with help from Bradley Baetz.\n  Fixed $dbh->{Active} for DBD::Proxy, reported by Bob Showalter.\n  Fixed STORE to not clear error during nested DBI call,\n    thanks to Tony Bowden for the report and helpful test case.\n  Fixed DBI::PurePerl error clearing behaviour.\n  Fixed dbi_time() and thus DBI::Profile on Windows thanks to Smejkal Petr.\n  Fixed problem that meant ShowErrorStatement could show wrong statement,\n   thanks to Ron Savage for the report and test case.\n  Changed Apache::DBI hook to check for $ENV{MOD_PERL} instead of\n    $ENV{GATEWAY_INTERFACE} thanks to Ask Bjoern Hansen.\n  No longer tries to dup trace logfp when an interpreter is being cloned.\n  Database handles no longer inherit shared $h->err/errstr/state storage\n    from their drivers, so each $dbh has it's own $h->err etc. values\n    and is no longer affected by calls made on other dbh's.\n    Now when a dbh is destroyed it's err/errstr/state values are copied\n    up to the driver so checking $DBI::errstr still works as expected.\n\n  Build / portability fixes:\n    Fixed t/40profile.t to not use Time::HiRes.\n    Fixed t/06attrs.t to not be locale sensitive, reported by Christian Hammers.\n    Fixed sgi compiler warnings, reported by Paul Blake.\n    Fixed build using make -j4, reported by Jonathan Leffler.\n    Fixed build and tests under VMS thanks to Craig A. Berry.\n\n  Documentation changes:\n    Documented $high_resolution_time = dbi_time() function.\n    Documented that bind_col() can take an attribute hash.\n    Clarified documentation for ParamValues attribute hash keys.\n    Many good DBI documentation tweaks from Jonathan Leffler,\n      including a major update to the DBI::DBD driver author guide.\n    Clarified that execute() should itself call finish() if it's\n      called on a statement handle that's still active.\n    Clarified $sth->{ParamValues}. Driver authors please note.\n    Removed \"NEW\" markers on some methods and attributes and\n      added text to each giving the DBI version it was added in,\n      if it was added after DBI 1.21 (Feb 2002).\n\n  Changes of note for authors of all drivers:\n    Added SQL_DATA_TYPE, SQL_DATETIME_SUB, NUM_PREC_RADIX, and\n      INTERVAL_PRECISION fields to docs for type_info_all. There were\n      already in type_info(), but type_info_all() didn't specify the\n      index values.  Please check and update your type_info_all() code.\n    Added DBI::DBD::Metadata module that auto-generates your drivers\n      get_info and type_info_all data and code, thanks mainly to\n      Jonathan Leffler and Steffen Goeldner. If you've not implemented\n      get_info and type_info_all methods and your database has an ODBC\n      driver available then this will do all the hard work for you!\n    Drivers should no longer pass Err, Errstr, or State to _new_drh\n      or _new_dbh functions.\n    Please check that you support the slightly modified behaviour of\n      $sth->{ParamValues}, e.g., always return hash with keys if possible.\n\n  Changes of note for authors of compiled drivers:\n    Added dbd_db_login6 & dbd_st_finish3 prototypes thanks to Jonathan Leffler.\n    All dbd_*_*() functions implemented by drivers must have a\n      corresponding #define dbd_*_* <driver_prefix>_*_* otherwise\n      the driver may not work with a future release of the DBI.\n\n  Changes of note for authors of drivers which use Driver.xst:\n    Some new method hooks have been added are are enabled by\n      defining corresponding macros:\n          $drh->data_sources()      - dbd_dr_data_sources\n          $dbh->do()                - dbd_db_do4\n    The following methods won't be compiled into the driver unless\n      the corresponding macro has been #defined:\n          $drh->disconnect_all()    - dbd_discon_all\n\n\n=head2 Changes in DBI 1.32,    1st December 2002\n\n  Fixed to work with 5.005_03 thanks to Tatsuhiko Miyagawa (I've not tested it).\n  Reenabled taint tests (accidentally left disabled) spotted by Bradley Baetz.\n  Improved docs for FetchHashKeyName attribute thanks to Ian Barwick.\n  Fixed core dump if fetchrow_hashref given bad argument (name of attribute\n    with a value that wasn't an array reference), spotted by Ian Barwick.\n  Fixed some compiler warnings thanks to David Wheeler.\n  Updated Steven Hirsch's enhanced proxy work (seems I left out a bit).\n  Made t/40profile.t tests more reliable, reported by Randy, who is part of\n    the excellent CPAN testers team: http://testers.cpan.org/\n    (Please visit, see the valuable work they do and, ideally, join in!)\n\n=head2 Changes in DBI 1.31,    29th November 2002\n\n  The fetchall_arrayref method, when called with a $maxrows parameter,\n    no longer gives an error if called again after all rows have been\n    fetched. This simplifies application logic when fetching in batches.\n    Also added batch-fetch while() loop example to the docs.\n  The proxy now supports non-lazy (synchronous) prepare, positioned\n    updates (for selects containing 'for update'), PlRPC config set\n    via attributes, and accurate propagation of errors, all thanks\n    to Steven Hirsch (plus a minor fix from Sean McMurray and doc\n    tweaks from Michael A Chase).\n  The DBI_AUTOPROXY env var can now hold the full dsn of the proxy driver\n    plus attributes, like \"dbi:Proxy(proxy_foo=>1):host=...\".\n  Added TaintIn & TaintOut attributes to give finer control over\n    tainting thanks to Bradley Baetz.\n  The RootClass attribute no longer ignores failure to load a module,\n    but also doesn't try to load a module if the class already exists,\n    with thanks to James FitzGibbon.\n  HandleError attribute works for connect failures thanks to David Wheeler.\n  The connect() RaiseError/PrintError message now includes the username.\n  Changed \"last handle unknown or destroyed\" warning to be a trace message.\n  Removed undocumented $h->event() method.\n  Further enhancements to DBD::PurePerl accuracy.\n  The CursorName attribute now defaults to undef and not an error.\n\n  DBI::Profile changes:\n    New DBI::ProfileDumper, DBI::ProfileDumper::Apache, and\n    DBI::ProfileData modules (to manage the storage and processing\n    of profile data), plus dbiprof program for analyzing profile\n    data - with many thanks to Sam Tregar.\n    Added $DBI::err (etc) tied variable lookup time to profile.\n    Added time for DESTROY method into parent handles profile (used to be ignored).\n\n  Documentation changes:\n    Documented $dbh = $sth->{Database} attribute.\n    Documented $dbh->connected(...) post-connection call when subclassing.\n    Updated some minor doc issues thanks to H.Merijn Brand.\n    Updated Makefile.PL example in DBI::DBD thanks to KAWAI,Takanori.\n    Fixed execute_array() example thanks to Peter van Hardenberg.\n\n  Changes for driver authors, not required but strongly recommended:\n    Change DBIS to DBIc_DBISTATE(imp_xxh)   [or imp_dbh, imp_sth etc]\n    Change DBILOGFP to DBIc_LOGPIO(imp_xxh) [or imp_dbh, imp_sth etc]\n    Any function from which all instances of DBIS and DBILOGFP are\n    removed can also have dPERLINTERP removed (a good thing).\n    All use of the DBIh_EVENT* macros should be removed.\n    Major update to DBI::DBD docs thanks largely to Jonathan Leffler.\n    Add these key values: 'Err' => \\my $err, 'Errstr' => \\my $errstr,\n    to the hash passed to DBI::_new_dbh() in your driver source code.\n    That will make each $dbh have it's own $h->err and $h->errstr\n    values separate from other $dbh belonging to the same driver.\n    If you have a ::db or ::st DESTROY methods that do nothing\n    you can now remove them - which speeds up handle destruction.\n\n\n=head2 Changes in DBI 1.30,    18th July 2002\n\n  Fixed problems with selectrow_array, selectrow_arrayref, and\n    selectall_arrayref introduced in DBI 1.29.\n  Fixed FETCHing a handle attribute to not clear $DBI::err etc (broken in 1.29).\n  Fixed core dump at trace level 9 or above.\n  Fixed compilation with perl 5.6.1 + ithreads (i.e. Windows).\n  Changed definition of behaviour of selectrow_array when called in a scalar\n    context to match fetchrow_array.\n  Corrected selectrow_arrayref docs which showed selectrow_array thanks to Paul DuBois.\n\n=head2 Changes in DBI 1.29,    15th July 2002\n\n  NOTE: This release changes the specified behaviour for the\n  : fetchrow_array method when called in a scalar context:\n  : The DBI spec used to say that it would return the FIRST field.\n  : Which field it returns (i.e., the first or the last) is now undefined.\n  : This does not affect statements that only select one column, which is\n  : usually the case when fetchrow_array is called in a scalar context.\n  : FYI, this change was triggered by discovering that the fetchrow_array\n  : implementation in Driver.xst (used by most compiled drivers)\n  : didn't match the DBI specification. Rather than change the code\n  : to match, and risk breaking existing applications, I've changed the\n  : specification (that part was always of dubious value anyway).\n\n  NOTE: Future versions of the DBI may not support for perl 5.5 much longer.\n  : If you are still using perl 5.005_03 you should be making plans to\n  : upgrade to at least perl 5.6.1, or 5.8.0. Perl 5.8.0 is due to be\n  : released in the next week or so.  (Although it's a \"point 0\" release,\n  : it is the most thoroughly tested release ever.)\n\n  Added XS/C implementations of selectrow_array, selectrow_arrayref, and\n    selectall_arrayref to Driver.xst. See DBI 1.26 Changes for more info.\n  Removed support for the old (fatally flawed) \"5005\" threading model.\n  Added support for new perl 5.8 iThreads thanks to Gerald Richter.\n    (Threading support and safety should still be regarded as beta\n    quality until further notice. But it's much better than it was.)\n  Updated the \"Threads and Thread Safety\" section of the docs.\n  The trace output can be sent to STDOUT instead of STDERR by using\n    \"STDOUT\" as the name of the file, i.e., $h->trace(..., \"STDOUT\")\n  Added pointer to perlreftut, perldsc, perllol, and perlboot manuals\n    into the intro section of the docs, suggested by Brian McCain.\n  Fixed DBI::Const::GetInfo::* pod docs thanks to Zack Weinberg.\n  Some changes to how $dbh method calls are treated by DBI::Profile:\n    Meta-data methods now clear $dbh->{Statement} on entry.\n    Some $dbh methods are now profiled as if $dbh->{Statement} was empty\n    (because thet're unlikely to actually relate to its contents).\n  Updated dbiport.h to ppport.h from perl 5.8.0.\n  Tested with perl 5.5.3 (vanilla, Solaris), 5.6.1 (vanilla, Solaris), and\n    perl 5.8.0 (RC3@17527 with iThreads & Multiplicity on Solaris and FreeBSD).\n\n=head2 Changes in DBI 1.28,    14th June 2002\n\n  Added $sth->{ParamValues} to return a hash of the most recent\n    values bound to placeholders via bind_param() or execute().\n    Individual drivers need to be updated to support it.\n  Enhanced ShowErrorStatement to include ParamValues if available:\n    \"DBD::foo::st execute failed: errstr [for statement ``...'' with params: 1='foo']\"\n  Further enhancements to DBD::PurePerl accuracy.\n\n=head2 Changes in DBI 1.27,    13th June 2002\n\n  Fixed missing column in C implementation of fetchall_arrayref()\n    thanks to Philip Molter for the prompt reporting of the problem.\n\n=head2 Changes in DBI 1.26,    13th June 2002\n\n  Fixed t/40profile.t to work on Windows thanks to Smejkal Petr.\n  Fixed $h->{Profile} to return undef, not error, if not set.\n  Fixed DBI->available_drivers in scalar context thanks to Michael Schwern.\n\n  Added C implementations of selectrow_arrayref() and fetchall_arrayref()\n    in Driver.xst.  All compiled drivers using Driver.xst will now be\n    faster making those calls. Most noticeable with fetchall_arrayref for\n    many rows or selectrow_arrayref with a fast query. For example, using\n    DBD::mysql a selectrow_arrayref for a single row using a primary key\n    is ~20% faster, and fetchall_arrayref for 20000 rows is twice as fast!\n    Drivers just need to be recompiled and reinstalled to enable it.\n    The fetchall_arrayref speed up only applies if $slice parameter is not used.\n  Added $max_rows parameter to fetchall_arrayref() to optionally limit\n    the number of rows returned. Can now fetch batches of rows.\n  Added MaxRows attribute to selectall_arrayref()\n    which then passes it to fetchall_arrayref().\n  Changed selectrow_array to make use of selectrow_arrayref.\n  Trace level 1 now shows first two parameters of all methods\n    (used to only for that for some, like prepare,execute,do etc)\n  Trace indicator for recursive calls (first char on trace lines)\n    now starts at 1 not 2.\n\n  Documented that $h->func() does not trigger RaiseError etc\n    so applications must explicitly check for errors.\n  DBI::Profile with DBI_PROFILE now shows percentage time inside DBI.\n  HandleError docs updated to show that handler can edit error message.\n  HandleError subroutine interface is now regarded as stable.\n\n=head2 Changes in DBI 1.25,    5th June 2002\n\n  Fixed build problem on Windows and some compiler warnings.\n  Fixed $dbh->{Driver} and $sth->{Statement} for driver internals\n    These are 'inner' handles as per behaviour prior to DBI 1.16.\n  Further minor improvements to DBI::PurePerl accuracy.\n\n=head2 Changes in DBI 1.24,    4th June 2002\n\n  Fixed reference loop causing a handle/memory leak\n    that was introduced in DBI 1.16.\n  Fixed DBI::Format to work with 'filehandles' from IO::Scalar\n    and similar modules thanks to report by Jeff Boes.\n  Fixed $h->func for DBI::PurePerl thanks to Jeff Zucker.\n  Fixed $dbh->{Name} for DBI::PurePerl thanks to Dean Arnold.\n\n  Added DBI method call profiling and benchmarking.\n    This is a major new addition to the DBI.\n    See $h->{Profile} attribute and DBI::Profile module.\n    For a quick trial, set the DBI_PROFILE environment variable and\n    run your favourite DBI script. Try it with DBI_PROFILE set to 1,\n    then try 2, 4, 8, 10, and -10. Have fun!\n\n  Added execute_array() and bind_param_array() documentation\n    with thanks to Dean Arnold.\n  Added notes about the DBI having not yet been tested with iThreads\n    (testing and patches for SvLOCK etc welcome).\n  Removed undocumented Handlers attribute (replaced by HandleError).\n  Tested with 5.5.3 and 5.8.0 RC1.\n\n=head2 Changes in DBI 1.23,    25th May 2002\n\n  Greatly improved DBI::PurePerl in performance and accuracy.\n  Added more detail to DBI::PurePerl docs about what's not supported.\n  Fixed undef warnings from t/15array.t and DBD::Sponge.\n\n=head2 Changes in DBI 1.22,    22nd May 2002\n\n  Added execute_array() and bind_param_array() with special thanks\n    to Dean Arnold. Not yet documented. See t/15array.t for examples.\n    All drivers now automatically support these methods.\n  Added DBI::PurePerl, a transparent DBI emulation for pure-perl drivers\n    with special thanks to Jeff Zucker. Perldoc DBI::PurePerl for details.\n  Added DBI::Const::GetInfo* modules thanks to Steffen Goeldner.\n  Added write_getinfo_pm utility to DBI::DBD thanks to Steffen Goeldner.\n  Added $allow_active==2 mode for prepare_cached() thanks to Stephen Clouse.\n\n  Updated DBI::Format to Revision 11.4 thanks to Tom Lowery.\n  Use File::Spec in Makefile.PL (helps VMS etc) thanks to Craig Berry.\n  Extend $h->{Warn} to commit/rollback ineffective warning thanks to Jeff Baker.\n  Extended t/preparse.t and removed \"use Devel::Peek\" thanks to Scott Hildreth.\n  Only copy Changes to blib/lib/Changes.pm once thanks to Jonathan Leffler.\n  Updated internals for modern perls thanks to Jonathan Leffler and Jeff Urlwin.\n  Tested with perl 5.7.3 (just using default perl config).\n\n  Documentation changes:\n\n  Added 'Catalog Methods' section to docs thanks to Steffen Goeldner.\n  Updated README thanks to Michael Schwern.\n  Clarified that driver may choose not to start new transaction until\n    next use of $dbh after commit/rollback.\n  Clarified docs for finish method.\n  Clarified potentials problems with prepare_cached() thanks to Stephen Clouse.\n\n\n=head2 Changes in DBI 1.21,    7th February 2002\n\n  The minimum supported perl version is now 5.005_03.\n\n  Fixed DBD::Proxy support for AutoCommit thanks to Jochen Wiedmann.\n  Fixed DBI::ProxyServer bind_param(_inout) handing thanks to Oleg Mechtcheriakov.\n  Fixed DBI::ProxyServer fetch loop thanks to nobull@mail.com.\n  Fixed install_driver do-the-right-thing with $@ on error. It, and connect(),\n    will leave $@ empty on success and holding the error message on error.\n    Thanks to Jay Lawrence, Gavin Sherlock and others for the bug report.\n  Fixed fetchrow_hashref to assign columns to the hash left-to-right\n    so later fields with the same name overwrite earlier ones\n    as per DBI < 1.15, thanks to Kay Roepke.\n\n  Changed tables() to use quote_indentifier() if the driver returns a\n    true value for $dbh->get_info(29) # SQL_IDENTIFIER_QUOTE_CHAR\n  Changed ping() so it no longer triggers RaiseError/PrintError.\n  Changed connect() to not call $class->install_driver unless needed.\n  Changed DESTROY to catch fatal exceptions and append to $@.\n\n  Added ISO SQL/CLI & ODBCv3 data type definitions thanks to Steffen Goeldner.\n  Removed the definition of SQL_BIGINT data type constant as the value is\n    inconsistent between standards (ODBC=-5, SQL/CLI=25).\n  Added $dbh->column_info(...) thanks to Steffen Goeldner.\n  Added $dbh->foreign_key_info(...) thanks to Steffen Goeldner.\n  Added $dbh->quote_identifier(...) insipred by Simon Oliver.\n  Added $dbh->set_err(...) for DBD authors and DBI subclasses\n    (actually been there for a while, now expanded and documented).\n  Added $h->{HandleError} = sub { ... } addition and/or alternative\n    to RaiseError/PrintError. See the docs for more info.\n  Added $h->{TraceLevel} = N attribute to set/get trace level of handle\n    thus can set trace level via an (eg externally specified) DSN\n    using the embedded attribute syntax:\n      $dsn = 'dbi:DB2(PrintError=1,TraceLevel=2):dbname';\n    Plus, you can also now do: local($h->{TraceLevel}) = N;\n    (but that leaks a little memory in some versions of perl).\n  Added some call tree information to trace output if trace level >= 3\n    With thanks to Graham Barr for the stack walking code.\n  Added experimental undocumented $dbh->preparse(), see t/preparse.t\n    With thanks to Scott T. Hildreth for much of the work.\n  Added Fowler/Noll/Vo hash type as an option to DBI::hash().\n\n  Documentation changes:\n\n  Added DBI::Changes so now you can \"perldoc DBI::Changes\", yeah!\n  Added selectrow_arrayref & selectrow_hashref docs thanks to Doug Wilson.\n  Added 'Standards Reference Information' section to docs to gather\n    together all references to relevant on-line standards.\n  Added link to poop.sourceforge.net into the docs thanks to Dave Rolsky.\n  Added link to hyperlinked BNF for SQL92 thanks to Jeff Zucker.\n  Added 'Subclassing the DBI' docs thanks to Stephen Clouse, and\n    then changed some of them to reflect the new approach to subclassing.\n  Added stronger wording to description of $h->{private_*} attributes.\n  Added docs for DBI::hash.\n\n  Driver API changes:\n\n  Now a COPY of the DBI->connect() attributes is passed to the driver\n    connect() method, so it can process and delete any elements it wants.\n    Deleting elements reduces/avoids the explicit\n      $dbh->{$_} = $attr->{$_} foreach keys %$attr;\n    that DBI->connect does after the driver connect() method returns.\n\n\n=head2 Changes in DBI 1.20,    24th August 2001\n\n  WARNING: This release contains two changes that may affect your code.\n  : Any code using selectall_hashref(), which was added in March 2001, WILL\n  : need to be changed. Any code using fetchall_arrayref() with a non-empty\n  : hash slice parameter may, in a few rare cases, need to be changed.\n  : See the change list below for more information about the changes.\n  : See the DBI documentation for a description of current behaviour.\n\n  Fixed memory leak thanks to Toni Andjelkovic.\n  Changed fetchall_arrayref({ foo=>1, ...}) specification again (sorry):\n    The key names of the returned hashes is identical to the letter case of\n    the names in the parameter hash, regardless of the L</FetchHashKeyName>\n    attribute. The letter case is ignored for matching.\n  Changed fetchall_arrayref([...]) array slice syntax specification to\n    clarify that the numbers in the array slice are perl index numbers\n    (which start at 0) and not column numbers (which start at 1).\n  Added { Columns=>... } and { Slice =>... } attributes to selectall_arrayref()\n    which is passed to fetchall_arrayref() so it can fetch hashes now.\n  Added a { Columns => [...] } attribute to selectcol_arrayref() so that\n    the list it returns can be built from more than one column per row.\n    Why? Consider my %hash = @{$dbh->selectcol_arrayref($sql,{ Columns=>[1,2]})}\n    to return id-value pairs which can be used directly to build a hash.\n  Added $hash_ref = $sth->fetchall_hashref( $key_field )\n    which returns a ref to a hash with, typically, one element per row.\n    $key_field is the name of the field to get the key for each row from.\n    The value of the hash for each row is a hash returned by fetchrow_hashref.\n  Changed selectall_hashref to return a hash ref (from fetchall_hashref)\n    and not an array of hashes as it has since DBI 1.15 (end March 2001).\n    WARNING: THIS CHANGE WILL BREAK ANY CODE USING selectall_hashref()!\n    Sorry, but I think this is an important regularization of the API.\n    To get previous selectall_hashref() behaviour (an array of hash refs)\n    change $ary_ref = $dbh->selectall_hashref( $statement, undef, @bind);\n\tto $ary_ref = $dbh->selectall_arrayref($statement, { Columns=>{} }, @bind);\n  Added NAME_lc_hash, NAME_uc_hash, NAME_hash statement handle attributes.\n    which return a ref to a hash of field_name => field_index (0..n-1) pairs.\n  Fixed select_hash() example thanks to Doug Wilson.\n  Removed (unbundled) DBD::ADO and DBD::Multiplex from the DBI distribution.\n    The latest versions of those modules are available from CPAN sites.\n  Added $dbh->begin_work. This method causes AutoCommit to be turned\n    off just until the next commit() or rollback().\n    Driver authors: if the DBIcf_BegunWork flag is set when your commit or\n    rollback method is called then please turn AutoCommit on and clear the\n    DBIcf_BegunWork flag. If you don't then the DBI will but it'll be much\n    less efficient and won't handle error conditions very cleanly.\n  Retested on perl 5.4.4, but the DBI won't support 5.4.x much longer.\n  Added text to SUPPORT section of the docs:\n    For direct DBI and DBD::Oracle support, enhancement, and related work\n    I am available for consultancy on standard commercial terms.\n  Added text to ACKNOWLEDGEMENTS section of the docs:\n    Much of the DBI and DBD::Oracle was developed while I was Technical\n    Director (CTO) of the Paul Ingram Group (www.ig.co.uk).  So I'd\n    especially like to thank Paul for his generosity and vision in\n    supporting this work for many years.\n\n=head2 Changes in DBI 1.19,    20th July 2001\n\n  Made fetchall_arrayref({ foo=>1, ...}) be more strict to the specification\n    in relation to wanting hash slice keys to be lowercase names.\n    WARNING: If you've used fetchall_arrayref({...}) with a hash slice\n    that contains keys with uppercase letters then your code will break.\n    (As far as I recall the spec has always said don't do that.)\n  Fixed $sth->execute() to update $dbh->{Statement} to $sth->{Statement}.\n  Added row number to trace output for fetch method calls.\n  Trace level 1 no longer shows fetches with row>1 (to reduce output volume).\n  Added $h->{FetchHashKeyName} = 'NAME_lc' or 'NAME_uc' to alter\n    behaviour of fetchrow_hashref() method. See docs.\n  Added type_info quote caching to quote() method thanks to Dean Kopesky.\n    Makes using quote() with second data type param much much faster.\n  Added type_into_all() caching to type_info(), spotted by Dean Kopesky.\n  Added new API definition for table_info() and tables(),\n    driver authors please note!\n  Added primary_key_info() to DBI API thanks to Steffen Goeldner.\n  Added primary_key() to DBI API as simpler interface to primary_key_info().\n  Indent and other fixes for DBI::DBD doc thanks to H.Merijn Brand.\n  Added prepare_cached() insert_hash() example thanks to Doug Wilson.\n  Removed false docs for fetchall_hashref(), use fetchall_arrayref({}).\n\n=head2 Changes in DBI 1.18,    4th June 2001\n\n  Fixed that altering ShowErrorStatement also altered AutoCommit!\n    Thanks to Jeff Boes for spotting that clanger.\n  Fixed DBD::Proxy to handle commit() and rollback(). Long overdue, sorry.\n  Fixed incompatibility with perl 5.004 (but no one's using that right? :)\n  Fixed connect_cached and prepare_cached to not be affected by the order\n    of elements in the attribute hash. Spotted by Mitch Helle-Morrissey.\n  Fixed version number of DBI::Shell\n    reported by Stuhlpfarrer Gerhard and others.\n  Defined and documented table_info() attribute semantics (ODBC compatible)\n    thanks to Olga Voronova, who also implemented then in DBD::Oracle.\n  Updated Win32::DBIODBC (Win32::ODBC emulation) thanks to Roy Lee.\n\n=head2 Changes in DBI 1.16,    30th May 2001\n\n  Reimplemented fetchrow_hashref in C, now fetches about 25% faster!\n  Changed behaviour if both PrintError and RaiseError are enabled\n    to simply do both (in that order, obviously :)\n  Slight reduction in DBI handle creation overhead.\n  Fixed $dbh->{Driver} & $sth->{Database} to return 'outer' handles.\n  Fixed execute param count check to honour RaiseError spotted by Belinda Giardie.\n  Fixed build for perl5.6.1 with PERLIO thanks to H.Merijn Brand.\n  Fixed client sql restrictions in ProxyServer.pm thanks to Jochen Wiedmann.\n  Fixed batch mode command parsing in Shell thanks to Christian Lemburg.\n  Fixed typo in selectcol_arrayref docs thanks to Jonathan Leffler.\n  Fixed selectrow_hashref to be available to callers thanks to T.J.Mather.\n  Fixed core dump if statement handle didn't define Statement attribute.\n  Added bind_param_inout docs to DBI::DBD thanks to Jonathan Leffler.\n  Added note to data_sources() method docs that some drivers may\n    require a connected database handle to be supplied as an attribute.\n  Trace of install_driver method now shows path of driver file loaded.\n  Changed many '||' to 'or' in the docs thanks to H.Merijn Brand.\n  Updated DBD::ADO again (improvements in error handling) from Tom Lowery.\n  Updated Win32::DBIODBC (Win32::ODBC emulation) thanks to Roy Lee.\n  Updated email and web addresses in DBI::FAQ thanks to Michael A Chase.\n\n=head2 Changes in DBI 1.15,    28th March 2001\n\n  Added selectrow_arrayref\n  Added selectrow_hashref\n  Added selectall_hashref thanks to Leon Brocard.\n  Added DBI->connect(..., { dbi_connect_method => 'method' })\n  Added $dbh->{Statement} aliased to most recent child $sth->{Statement}.\n  Added $h->{ShowErrorStatement}=1 to cause the appending of the\n    relevant Statement text to the RaiseError/PrintError text.\n  Modified type_info to always return hash keys in uppercase and\n    to not require uppercase 'DATA_TYPE' key from type_info_all.\n    Thanks to Jennifer Tong and Rob Douglas.\n  Added \\%attr param to tables() and table_info() methods.\n  Trace method uses warn() if it can't open the new file.\n  Trace shows source line and filename during global destruction.\n  Updated packages:\n    Updated Win32::DBIODBC (Win32::ODBC emulation) thanks to Roy Lee.\n    Updated DBD::ADO to much improved version 0.4 from Tom Lowery.\n    Updated DBD::Sponge to include $sth->{PRECISION} thanks to Tom Lowery.\n    Changed DBD::ExampleP to use lstat() instead of stat().\n  Documentation:\n    Documented $DBI::lasth (which has been there since day 1).\n    Documented SQL_* names.\n    Clarified and extended docs for $h->state thanks to Masaaki Hirose.\n    Clarified fetchall_arrayref({}) docs (thanks to, er, someone!).\n    Clarified type_info_all re lettercase and index values.\n    Updated DBI::FAQ to 0.38 thanks to Alligator Descartes.\n    Added cute bind_columns example thanks to H.Merijn Brand.\n    Extended docs on \\%attr arg to data_sources method.\n  Makefile.PL\n    Removed obscure potential 'rm -rf /' (thanks to Ulrich Pfeifer).\n    Removed use of glob and find (thanks to Michael A. Chase).\n  Proxy:\n    Removed debug messages from DBD::Proxy AUTOLOAD thanks to Brian McCauley.\n    Added fix for problem using table_info thanks to Tom Lowery.\n    Added better determination of where to put the pid file, and...\n    Added KNOWN ISSUES section to DBD::Proxy docs thanks to Jochen Wiedmann.\n  Shell:\n    Updated DBI::Format to include DBI::Format::String thanks to Tom Lowery.\n    Added describe command thanks to Tom Lowery.\n    Added columnseparator option thanks to Tom Lowery (I think).\n    Added 'raw' format thanks to, er, someone, maybe Tom again.\n  Known issues:\n    Perl 5.005 and 5.006 both leak memory doing local($handle->{Foo}).\n    Perl 5.004 doesn't. The leak is not a DBI or driver bug.\n\n=head2 Changes in DBI 1.14,\t14th June 2000\n\n  NOTE: This version is the one the DBI book is based on.\n  NOTE: This version requires at least Perl 5.004.\n  Perl 5.6 ithreads changes with thanks to Doug MacEachern.\n  Changed trace output to use PerlIO thanks to Paul Moore.\n  Fixed bug in RaiseError/PrintError handling.\n    (% chars in the error string could cause a core dump.)\n  Fixed Win32 PerlEx IIS concurrency bugs thanks to Murray Nesbitt.\n  Major documentation polishing thanks to Linda Mui at O'Reilly.\n  Password parameter now shown as **** in trace output.\n  Added two fields to type_info and type_info_all.\n  Added $dsn to PrintError/RaiseError message from DBI->connect().\n  Changed prepare_cached() croak to carp if sth still Active.\n  Added prepare_cached() example to the docs.\n  Added further DBD::ADO enhancements from Thomas Lowery.\n\n=head2 Changes in DBI 1.13,\t11th July 1999\n\n  Fixed Win32 PerlEx IIS concurrency bugs thanks to Murray Nesbitt.\n  Fixed problems with DBD::ExampleP long_list test mode.\n  Added SQL_WCHAR SQL_WVARCHAR SQL_WLONGVARCHAR and SQL_BIT\n    to list of known and exportable SQL types.\n  Improved data fetch performance of DBD::ADO.\n  Added GetTypeInfo to DBD::ADO thanks to Thomas Lowery.\n  Actually documented connect_cached thanks to Michael Schwern.\n  Fixed user/key/cipher bug in ProxyServer thanks to Joshua Pincus.\n\n=head2 Changes in DBI 1.12,\t29th June 1999\n\n  Fixed significant DBD::ADO bug (fetch skipped first row).\n  Fixed ProxyServer bug handling non-select statements.\n  Fixed VMS problem with t/examp.t thanks to Craig Berry.\n  Trace only shows calls to trace_msg and _set_fbav at high levels.\n  Modified t/examp.t to workaround Cygwin buffering bug.\n\n=head2 Changes in DBI 1.11,\t17th June 1999\n\n  Fixed bind_columns argument checking to allow a single arg.\n  Fixed problems with internal default_user method.\n  Fixed broken DBD::ADO.\n  Made default $DBI::rows more robust for some obscure cases.\n\n=head2 Changes in DBI 1.10,\t14th June 1999\n\n  Fixed trace_msg.al error when using Apache.\n  Fixed dbd_st_finish enhancement in Driver.xst (internals).\n  Enable drivers to define default username and password\n    and temporarily disabled warning added in 1.09.\n  Thread safety optimised for single thread case.\n\n=head2 Changes in DBI 1.09,\t9th June 1999\n\n  Added optional minimum trace level parameter to trace_msg().\n  Added warning in Makefile.PL that DBI will require 5.004 soon.\n  Added $dbh->selectcol_arrayref($statement) method.\n  Fixed fetchall_arrayref hash-slice mode undef NAME problem.\n  Fixed problem with tainted parameter checking and t/examp.t.\n  Fixed problem with thread safety code, including 64 bit machines.\n  Thread safety now enabled by default for threaded perls.\n  Enhanced code for MULTIPLICITY/PERL_OBJECT from ActiveState.\n  Enhanced prepare_cached() method.\n  Minor changes to trace levels (less internal info at level 2).\n  Trace log now shows \"!! ERROR...\" before the \"<- method\" line.\n  DBI->connect() now warn's if user / password is undefined and\n    DBI_USER / DBI_PASS environment variables are not defined.\n  The t/proxy.t test now ignores any /etc/dbiproxy.conf file.\n  Added portability fixes for MacOS from Chris Nandor.\n  Updated mailing list address from fugue.com to isc.org.\n\n=head2 Changes in DBI 1.08,\t12th May 1999\n\n  Much improved DBD::ADO driver thanks to Phlip Plumlee and others.\n  Connect now allows you to specify attribute settings within the DSN\n    E.g., \"dbi:Driver(RaiseError=>1,Taint=>1,AutoCommit=>0):dbname\"\n  The $h->{Taint} attribute now also enables taint checking of\n    arguments to almost all DBI methods.\n  Improved trace output in various ways.\n  Fixed bug where $sth->{NAME_xx} was undef in some situations.\n  Fixed code for MULTIPLICITY/PERL_OBJECT thanks to Alex Smishlajev.\n  Fixed and documented DBI->connect_cached.\n  Workaround for Cygwin32 build problem with help from Jong-Pork Park.\n  bind_columns no longer needs undef or hash ref as first parameter.\n\n=head2 Changes in DBI 1.07,\t6th May 1999\n\n  Trace output now shows contents of array refs returned by DBI.\n  Changed names of some result columns from type_info, type_info_all,\n    tables and table_info to match ODBC 3.5 / ISO/IEC standards.\n  Many fixes for DBD::Proxy and ProxyServer.\n  Fixed error reporting in install_driver.\n  Major enhancement to DBI::W32ODBC from Patrick Hollins.\n  Added $h->{Taint} to taint fetched data if tainting (perl -T).\n  Added code for MULTIPLICITY/PERL_OBJECT contributed by ActiveState.\n  Added $sth->more_results (undocumented for now).\n\n=head2 Changes in DBI 1.06,\t6th January 1999\n\n  Fixed Win32 Makefile.PL problem in 1.04 and 1.05.\n  Significant DBD::Proxy enhancements and fixes\n    including support for bind_param_inout (Jochen and I)\n  Added experimental DBI->connect_cached method.\n  Added $sth->{NAME_uc} and $sth->{NAME_lc} attributes.\n  Enhanced fetchrow_hashref to take an attribute name arg.\n\n=head2 Changes in DBI 1.05,\t4th January 1999\n\n  Improved DBD::ADO connect (thanks to Phlip Plumlee).\n  Improved thread safety (thanks to Jochen Wiedmann).\n  [Quick release prompted by truncation of copies on CPAN]\n\n=head2 Changes in DBI 1.04,\t3rd January 1999\n\n  Fixed error in Driver.xst. DBI build now tests Driver.xst.\n  Removed unused variable compiler warnings in Driver.xst.\n  DBI::DBD module now tested during DBI build.\n  Further clarification in the DBI::DBD driver writers manual.\n  Added optional name parameter to $sth->fetchrow_hashref.\n\n=head2 Changes in DBI 1.03,\t1st January 1999\n\n  Now builds with Perl>=5.005_54 (PERL_POLLUTE in DBIXS.h)\n  DBI trace trims path from \"at yourfile.pl line nnn\".\n  Trace level 1 now shows statement passed to prepare.\n  Assorted improvements to the DBI manual.\n  Assorted improvements to the DBI::DBD driver writers manual.\n  Fixed $dbh->quote prototype to include optional $data_type.\n  Fixed $dbh->prepare_cached problems.\n  $dbh->selectrow_array behaves better in scalar context.\n  Added a (very) experimental DBD::ADO driver for Win32 ADO.\n  Added experimental thread support (perl Makefile.PL -thread).\n  Updated the DBI::FAQ - thanks to Alligator Descartes.\n  The following changes were implemented and/or packaged\n    by Jochen Wiedmann - thanks Jochen:\n  Added a Bundle for CPAN installation of DBI, the DBI proxy\n    server and prerequisites (lib/Bundle/DBI.pm).\n  DBI->available_drivers uses File::Spec, if available.\n    This makes it work on MacOS. (DBI.pm)\n  Modified type_info to work with read-only values returned\n    by type_info_all. (DBI.pm)\n  Added handling of magic values in $sth->execute,\n    $sth->bind_param and other methods (Driver.xst)\n  Added Perl's CORE directory to the linkers path on Win32,\n    required by recent versions of ActiveState Perl.\n  Fixed DBD::Sponge to work with empty result sets.\n  Complete rewrite of DBI::ProxyServer and DBD::Proxy.\n\n=head2 Changes in DBI 1.02,\t2nd September 1998\n\n  Fixed DBI::Shell including @ARGV and /current.\n  Added basic DBI::Shell test.\n  Renamed DBI::Shell /display to /format.\n\n=head2 Changes in DBI 1.01,\t2nd September 1998\n\n  Many enhancements to Shell (with many contributions from\n  Jochen Wiedmann, Tom Lowery and Adam Marks).\n  Assorted fixes to DBD::Proxy and DBI::ProxyServer.\n  Tidied up trace messages - trace(2) much cleaner now.\n  Added $dbh->{RowCacheSize} and $sth->{RowsInCache}.\n  Added experimental DBI::Format (mainly for DBI::Shell).\n  Fixed fetchall_arrayref($slice_hash).\n  DBI->connect now honours PrintError=1 if connect fails.\n  Assorted clarifications to the docs.\n\n=head2 Changes in DBI 1.00,\t14th August 1998\n\n  The DBI is no longer 'alpha' software!\n  Added $dbh->tables and $dbh->table_info.\n  Documented \\%attr arg to data_sources method.\n  Added $sth->{TYPE}, $sth->{PRECISION} and $sth->{SCALE}.\n  Added $sth->{Statement}.\n  DBI::Shell now uses neat_list to print results\n  It also escapes \"'\" chars and converts newlines to spaces.\n\n=head2 Changes in DBI 0.95,\t10th August 1998\n\n  WARNING: THIS IS AN EXPERIMENTAL RELEASE!\n\n  Fixed 0.94 slip so it will build on pre-5.005 again.\n  Added DBI_AUTOPROXY environment variable.\n  Array ref returned from fetch/fetchrow_arrayref now readonly.\n  Improved connect error reporting by DBD::Proxy.\n  All trace/debug messages from DBI now go to trace file.\n\n=head2 Changes in DBI 0.94,\t9th August 1998\n\n  WARNING: THIS IS AN EXPERIMENTAL RELEASE!\n\n  Added DBD::Shell and dbish interactive DBI shell. Try it!\n  Any database attribs can be set via DBI->connect(,,, \\%attr).\n  Added _get_fbav and _set_fbav methods for Perl driver developers\n    (see ExampleP driver for perl usage). Drivers which don't use\n    one of these methods (either via XS or Perl) are not compliant.\n  DBI trace now shows adds \" at yourfile.pl line nnn\"!\n  PrintError and RaiseError now prepend driver and method name.\n  The available_drivers method no longer returns NullP or Sponge.\n  Added $dbh->{Name}.\n  Added $dbh->quote($value, $data_type).\n  Added more hints to install_driver failure message.\n  Added DBD::Proxy and DBI::ProxyServer (from Jochen Wiedmann).\n  Added $DBI::neat_maxlen to control truncation of trace output.\n  Added $dbh->selectall_arrayref and $dbh->selectrow_array methods.\n  Added $dbh->tables.\n  Added $dbh->type_info and $dbh->type_info_all.\n  Added $h->trace_msg($msg) to write to trace log.\n  Added @bool = DBI::looks_like_number(@ary).\n  Many assorted improvements to the DBI docs.\n\n=head2 Changes in DBI 0.93,\t13th February 1998\n\n  Fixed DBI::DBD::dbd_postamble bug causing 'Driver.xsi not found' errors.\n  Changes to handling of 'magic' values in neatsvpv (used by trace).\n  execute (in Driver.xst) stops binding after first bind error.\n  This release requires drivers to be rebuilt.\n\n=head2 Changes in DBI 0.92,\t3rd February 1998\n\n  Fixed per-handle memory leak (with many thanks to Irving Reid).\n  Added $dbh->prepare_cached() caching variant of $dbh->prepare.\n  Added some attributes:\n    $h->{Active}       is the handle 'Active' (vague concept) (boolean)\n    $h->{Kids}         e.g. number of sth's associated with a dbh\n    $h->{ActiveKids}   number of the above which are 'Active'\n    $dbh->{CachedKids} ref to prepare_cached sth cache\n  Added support for general-purpose 'private_' attributes.\n  Added experimental support for subclassing the DBI: see t/subclass.t\n  Added SQL_ALL_TYPES to exported :sql_types.\n  Added dbd_dbi_dir() and dbd_dbi_arch_dir() to DBI::DBD module so that\n  DBD Makefile.PLs can work with the DBI installed in non-standard locations.\n  Fixed 'Undefined value' warning and &sv_no output from neatsvpv/trace.\n  Fixed small 'once per interpreter' leak.\n  Assorted minor documentation fixes.\n\n=head2 Changes in DBI 0.91,\t10th December 1997\n\n  NOTE: This fix may break some existing scripts:\n  DBI->connect(\"dbi:...\",$user,$pass) was not setting AutoCommit and PrintError!\n  DBI->connect(..., { ... }) no longer sets AutoCommit or PrintError twice.\n  DBI->connect(..., { RaiseError=>1 }) now croaks if connect fails.\n  Fixed $fh parameter of $sth->dump_results;\n  Added default statement DESTROY method which carps.\n  Added default driver DESTROY method to silence AUTOLOAD/__DIE__/CGI::Carp\n  Added more SQL_* types to %EXPORT_TAGS and @EXPORT_OK.\n  Assorted documentation updates (mainly clarifications).\n  Added workaround for perl's 'sticky lvalue' bug.\n  Added better warning for bind_col(umns) where fields==0.\n  Fixed to build okay with 5.004_54 with or without USE_THREADS.\n  Note that the DBI has not been tested for thread safety yet.\n\n=head2 Changes in DBI 0.90,\t6th September 1997\n\n  Can once again be built with Perl 5.003.\n  The DBI class can be subclassed more easily now.\n  InactiveDestroy fixed for drivers using the *.xst template.\n  Slightly faster handle creation.\n  Changed prototype for dbd_*_*_attrib() to add extra param.\n  Note: 0.90, 0.89 and possibly some other recent versions have\n  a small memory leak. This will be fixed in the next release.\n\n=head2 Changes in DBI 0.89,\t25th July 1997\n\n  Minor fix to neatsvpv (mainly used for debug trace) to workaround\n  bug in perl where SvPV removes IOK flag from an SV.\n  Minor updates to the docs.\n\n=head2 Changes in DBI 0.88,\t22nd July 1997\n\n  Fixed build for perl5.003 and Win32 with Borland.\n  Fixed documentation formatting.\n  Fixed DBI_DSN ignored for old-style connect (with explicit driver).\n  Fixed AutoCommit in DBD::ExampleP\n  Fixed $h->trace.\n  The DBI can now export SQL type values: use DBI ':sql_types';\n  Modified Driver.xst and renamed DBDI.h to dbd_xsh.h\n\n=head2 Changes in DBI 0.87,\t18th July 1997\n\n  Fixed minor type clashes.\n  Added more docs about placeholders and bind values.\n\n=head2 Changes in DBI 0.86,\t16th July 1997\n\n  Fixed failed connect causing 'unblessed ref' and other errors.\n  Drivers must handle AutoCommit FETCH and STORE else DBI croaks.\n  Added $h->{LongReadLen} and $h->{LongTruncOk} attributes for BLOBS.\n  Added DBI_USER and DBI_PASS env vars. See connect docs for usage.\n  Added DBI->trace() to set global trace level (like per-handle $h->trace).\n  PERL_DBI_DEBUG env var renamed DBI_DEBUG (old name still works for now).\n  Updated docs, including commit, rollback, AutoCommit and Transactions sections.\n  Added bind_param method and execute(@bind_values) to docs.\n  Fixed fetchall_arrayref.\n\n  Since the DBIS structure has change the internal version numbers have also\n  changed (DBIXS_VERSION == 9 and DBISTATE_VERSION == 9) so drivers will have\n  to be recompiled. The test is also now more sensitive and the version\n  mismatch error message now more clear about what to do. Old drivers are\n  likely to core dump (this time) until recompiled for this DBI. In future\n  DBI/DBD version mismatch will always produce a clear error message.\n\n  Note that this DBI release contains and documents many new features\n  that won't appear in drivers for some time. Driver writers might like\n  to read perldoc DBI::DBD and comment on or apply the information given.\n\n=head2 Changes in DBI 0.85,\t25th June 1997\n\n  NOTE: New-style connect now defaults to AutoCommit mode unless\n  { AutoCommit => 0 } specified in connect attributes. See the docs.\n  AutoCommit attribute now defined and tracked by DBI core.\n  Drivers should use/honour this and not implement their own.\n  Added pod doc changes from Andreas and Jonathan.\n  New DBI_DSN env var default for connect method. See docs.\n  Documented the func method.\n  Fixed \"Usage: DBD::_::common::DESTROY\" error.\n  Fixed bug which set some attributes true when there value was fetched.\n  Added new internal DBIc_set() macro for drivers to use.\n\n=head2 Changes in DBI 0.84,\t20th June 1997\n\n  Added $h->{PrintError} attribute which, if set true, causes all errors to\n  trigger a warn().\n  New-style DBI->connect call now automatically sets PrintError=1 unless\n  { PrintError => 0 } specified in the connect attributes. See the docs.\n  The old-style connect with a separate driver parameter is deprecated.\n  Fixed fetchrow_hashref.\n  Renamed $h->debug to $h->trace() and added a trace filename arg.\n  Assorted other minor tidy-ups.\n\n=head2 Changes in DBI 0.83,\t11th June 1997\n\n  Added driver specification syntax to DBI->connect data_source\n  parameter: DBI->connect('dbi:driver:...', $user, $passwd);\n  The DBI->data_sources method should return data_source\n  names with the appropriate 'dbi:driver:' prefix.\n  DBI->connect will warn if \\%attr is true but not a hash ref.\n  Added the new fetchrow methods:\n    @row_ary  = $sth->fetchrow_array;\n    $ary_ref  = $sth->fetchrow_arrayref;\n    $hash_ref = $sth->fetchrow_hashref;\n  The old fetch and fetchrow methods still work.\n  Driver implementors should implement the new names for\n  fetchrow_array and fetchrow_arrayref ASAP (use the xs ALIAS:\n  directive to define aliases for fetch and fetchrow).\n  Fixed occasional problems with t/examp.t test.\n  Added automatic errstr reporting to the debug trace output.\n  Added the DBI FAQ from Alligator Descartes in module form for\n  easy reading via \"perldoc DBI::FAQ\". Needs reformatting.\n  Unknown driver specific attribute names no longer croak.\n  Fixed problem with internal neatsvpv macro.\n\n=head2 Changes in DBI 0.82,\t23rd May 1997\n\n  Added $h->{RaiseError} attribute which, if set true, causes all errors to\n  trigger a die(). This makes it much easier to implement robust applications\n  in terms of higher level eval { ... } blocks and rollbacks.\n  Added DBI->data_sources($driver) method for implementation by drivers.\n  The quote method now returns the string NULL (without quotes) for undef.\n  Added VMS support thanks to Dan Sugalski.\n  Added a 'quick start guide' to the README.\n  Added neatsvpv function pointer to DBIS structure to make it available for\n  use by drivers. A macro defines neatsvpv(sv,len) as (DBIS->neatsvpv(sv,len)).\n  Old XS macro SV_YES_NO changes to standard boolSV.\n  Since the DBIS structure has change the internal version numbers have also\n  changed (DBIXS_VERSION == 8 and DBISTATE_VERSION == 8) so drivers will have\n  to be recompiled.\n\n=head2 Changes in DBI 0.81,\t7th May 1997\n\n  Minor fix to let DBI build using less modern perls.\n  Fixed a suprious typo warning.\n\n=head2 Changes in DBI 0.80,\t6th May 1997\n\n  Builds with no changes on NT using perl5.003_99 (with thanks to Jeffrey Urlwin).\n  Automatically supports Apache::DBI (with thanks to Edmund Mergl).\n    DBI scripts no longer need to be modified to make use of Apache::DBI.\n  Added a ping method and an experimental connect_test_perf method.\n  Added a fetchhash and fetch_all methods.\n  The func method no longer pre-clears err and errstr.\n  Added ChopBlanks attribute (currently defaults to off, that may change).\n    Support for the attribute needs to be implemented by individual drivers.\n  Reworked tests into standard t/*.t form.\n  Added more pod text.  Fixed assorted bugs.\n\n\n=head2 Changes in DBI 0.79,\t7th Apr 1997\n\n  Minor release. Tidied up pod text and added some more descriptions\n  (especially disconnect). Minor changes to DBI.xs to remove compiler\n  warnings.\n\n=head2 Changes in DBI 0.78,\t28th Mar 1997\n\n  Greatly extended the pod documentation in DBI.pm, including the under\n  used bind_columns method. Use 'perldoc DBI' to read after installing.\n  Fixed $h->err. Fetching an attribute value no longer resets err.\n  Added $h->{InactiveDestroy}, see documentation for details.\n  Improved debugging of cached ('quick') attribute fetches.\n  errstr will return err code value if there is no string value.\n  Added DBI/W32ODBC to the distribution. This is a pure-perl experimental\n  DBI emulation layer for Win32::ODBC. Note that it's unsupported, your\n  mileage will vary, and bug reports without fixes will probably be ignored.\n\n=head2 Changes in DBI 0.77,\t21st Feb 1997\n\n  Removed erroneous $h->errstate and $h->errmsg methods from DBI.pm.\n  Added $h->err, $h->errstr and $h->state default methods in DBI.xs.\n  Updated informal DBI API notes in DBI.pm. Updated README slightly.\n  DBIXS.h now correctly installed into INST_ARCHAUTODIR.\n  (DBD authors will need to edit their Makefile.PL's to use\n  -I$(INSTALLSITEARCH)/auto/DBI -I$(INSTALLSITEARCH)/DBI)\n\n\n=head2 Changes in DBI 0.76,\t3rd Feb 1997\n\n  Fixed a compiler type warnings (pedantic IRIX again).\n\n=head2 Changes in DBI 0.75,\t27th Jan 1997\n\n  Fix problem introduced by a change in Perl5.003_XX.\n  Updated README and DBI.pm docs.\n\n=head2 Changes in DBI 0.74,\t14th Jan 1997\n\n  Dispatch now sets dbi_debug to the level of the current handle\n  (this makes tracing/debugging individual handles much easier).\n  The '>> DISPATCH' log line now only logged at debug >= 3 (was 2).\n  The $csr->NUM_OF_FIELDS attribute can be set if not >0 already.\n  You can log to a file using the env var PERL_DBI_DEBUG=/tmp/dbi.log.\n  Added a type cast needed by IRIX.\n  No longer sets perl_destruct_level unless debug set >= 4.\n  Make compatible with PerlIO and sfio.\n\n=head2 Changes in DBI 0.73,\t10th Oct 1996\n\n  Fixed some compiler type warnings (IRIX).\n  Fixed DBI->internal->{DebugLog} = $filename.\n  Made debug log file unbuffered.\n  Added experimental bind_param_inout method to interface.\n  Usage: $dbh->bind_param_inout($param, \\$value, $maxlen [, \\%attribs ])\n  (only currently used by DBD::Oracle at this time.)\n\n=head2 Changes in DBI 0.72,\t23 Sep 1996\n\n  Using an undefined value as a handle now gives a better\n  error message (mainly useful for emulators like Oraperl).\n  $dbh->do($sql, @params) now works for binding placeholders.\n\n=head2 Changes in DBI 0.71,\t10 July 1996\n\n  Removed spurious abort() from invalid handle check.\n  Added quote method to DBI interface and added test.\n\n=head2 Changes in DBI 0.70,\t16 June 1996\n\n  Added extra invalid handle check (dbih_getcom)\n  Fixed broken $dbh->quote method.\n  Added check for old GCC in Makefile.PL\n\n=head2 Changes in DBI 0.69\n\n  Fixed small memory leak.\n  Clarified the behaviour of DBI->connect.\n  $dbh->do now returns '0E0' instead of 'OK'.\n  Fixed \"Can't read $DBI::errstr, lost last handle\" problem.\n\n\n=head2 Changes in DBI 0.68,\t2 Mar 1996\n\n  Changes to suit perl5.002 and site_lib directories.\n  Detects old versions ahead of new in @INC.\n\n\n=head2 Changes in DBI 0.67,\t15 Feb 1996\n\n  Trivial change to test suite to fix a problem shown up by the\n  Perl5.002gamma release Test::Harness.\n\n\n=head2 Changes in DBI 0.66,\t29 Jan 1996\n\n  Minor changes to bring the DBI into line with 5.002 mechanisms,\n  specifically the xs/pm VERSION checking mechanism.\n  No functionality changes. One no-last-handle bug fix (rare problem).\n  Requires 5.002 (beta2 or later).\n\n\n=head2 Changes in DBI 0.65,\t23 Oct 1995\n\n  Added $DBI::state to hold SQL CLI / ODBC SQLSTATE value.\n  SQLSTATE \"00000\" (success) is returned as \"\" (false), all else is true.\n  If a driver does not explicitly initialise it (via $h->{State} or\n  DBIc_STATE(imp_xxh) then $DBI::state will automatically return \"\" if\n  $DBI::err is false otherwise \"S1000\" (general error).\n  As always, this is a new feature and liable to change.\n\n  The is *no longer* a default error handler!\n  You can add your own using push(@{$h->{Handlers}}, sub { ... })\n  but be aware that this interface may change (or go away).\n\n  The DBI now automatically clears $DBI::err, errstr and state before\n  calling most DBI methods. Previously error conditions would persist.\n  Added DBIh_CLEAR_ERROR(imp_xxh) macro.\n\n  DBI now EXPORT_OK's some utility functions, neat($value),\n  neat_list(@values) and dump_results($sth).\n\n  Slightly enhanced t/min.t minimal test script in an effort to help\n  narrow down the few stray core dumps that some porters still report.\n\n  Renamed readblob to blob_read (old name still works but warns).\n  Added default blob_copy_to_file method.\n\n  Added $sth = $dbh->tables method. This returns an $sth for a query\n  which has these columns: TABLE_CATALOGUE, TABLE_OWNER, TABLE_NAME,\n  TABLE_TYPE, REMARKS in that order. The TABLE_CATALOGUE column\n  should be ignored for now.\n\n\n=head2 Changes in DBI 0.64,\t23 Oct 1995\n\n  Fixed 'disconnect invalidates 1 associated cursor(s)' problem.\n  Drivers using DBIc_ACTIVE_on/off() macros should not need any changes\n  other than to test for DBIc_ACTIVE_KIDS() instead of DBIc_KIDS().\n  Fixed possible core dump in dbih_clearcom during global destruction.\n\n\n=head2 Changes in DBI 0.63,\t1 Sep 1995\n\n  Minor update. Fixed uninitialised memory bug in method\n  attribute handling and streamlined processing and debugging.\n  Revised usage definitions for bind_* methods and readblob.\n\n\n=head2 Changes in DBI 0.62,\t26 Aug 1995\n\n  Added method redirection method $h->func(..., $method_name).\n  This is now the official way to call private driver methods\n  that are not part of the DBI standard.  E.g.:\n      @ary = $sth->func('ora_types');\n  It can also be used to call existing methods. Has very low cost.\n\n  $sth->bind_col columns now start from 1 (not 0) to match SQL.\n  $sth->bind_columns now takes a leading attribute parameter (or undef),\n  e.g., $sth->bind_columns($attribs, \\$col1 [, \\$col2 , ...]);\n\n  Added handy DBD_ATTRIBS_CHECK macro to vet attribs in XS.\n  Added handy DBD_ATTRIB_GET_SVP, DBD_ATTRIB_GET_BOOL and\n  DBD_ATTRIB_GET_IV macros for handling attributes.\n\n  Fixed STORE for NUM_OF_FIELDS and NUM_OF_PARAMS.\n  Added FETCH for NUM_OF_FIELDS and NUM_OF_PARAMS.\n\n  Dispatch no longer bothers to call _untie().\n  Faster startup via install_method/_add_dispatch changes.\n\n\n=head2 Changes in DBI 0.61,\t22 Aug 1995\n\n  Added $sth->bind_col($column, \\$var [, \\%attribs ]);\n\n  This method enables perl variable to be directly and automatically\n  updated when a row is fetched. It requires no driver support\n  (if the driver has been written to use DBIS->get_fbav).\n  Currently \\%attribs is unused.\n\n  Added $sth->bind_columns(\\$var [, \\$var , ...]);\n\n  This method is a short-cut for bind_col which binds all the\n  columns of a query in one go (with no attributes). It also\n  requires no driver support.\n\n  Added $sth->bind_param($parameter, $var [, \\%attribs ]);\n\n  This method enables attributes to be specified when values are\n  bound to placeholders. It also enables binding to occur away\n  from the execute method to improve execute efficiency.\n  The DBI does not provide a default implementation of this.\n  See the DBD::Oracle module for a detailed example.\n\n  The DBI now provides default implementations of both fetch and\n  fetchrow.  Each is written in terms of the other. A driver is\n  expected to implement at least one of them.\n\n  More macro and assorted structure changes in DBDXS.h. Sorry!\n  The old dbihcom definitions have gone. All fields have macros.\n  The imp_xxh_t type is now used within the DBI as well as drivers.\n  Drivers must set DBIc_NUM_FIELDS(imp_sth) and DBIc_NUM_PARAMS(imp_sth).\n\n  test.pl includes a trivial test of bind_param and bind_columns.\n\n\n=head2 Changes in DBI 0.60,\t17 Aug 1995\n\n  This release has significant code changes but much less\n  dramatic than the previous release. The new implementors data\n  handling mechanism has matured significantly (don't be put off\n  by all the struct typedefs in DBIXS.h, there's just to make it\n  easier for drivers while keeping things type-safe).\n\n  The DBI now includes two new methods:\n\n  do\t\t$dbh->do($statement)\n\n  This method prepares, executes and finishes a statement. It is\n  designed to be used for executing one-off non-select statements\n  where there is no benefit in reusing a prepared statement handle.\n\n  fetch\t\t$array_ref = $sth->fetch;\n\n  This method is the new 'lowest-level' row fetching method. The\n  previous @row = $sth->fetchrow method now defaults to calling\n  the fetch method and expanding the returned array reference.\n\n  The DBI now provides fallback attribute FETCH and STORE functions\n  which drivers should call if they don't recognise an attribute.\n\n  THIS RELEASE IS A GOOD STARTING POINT FOR DRIVER DEVELOPERS!\n  Study DBIXS.h from the DBI and Oracle.xs etc from DBD::Oracle.\n  There will be further changes in the interface but nothing\n  as dramatic as these last two releases! (I hope :-)\n\n\n=head2 Changes in DBI 0.59\t15 Aug 1995\n\n  NOTE: THIS IS AN UNSTABLE RELEASE!\n\n  Major reworking of internal data management!\n  Performance improvements and memory leaks fixed.\n  Added a new NullP (empty) driver and a -m flag\n  to test.pl to help check for memory leaks.\n  Study DBD::Oracle version 0.21 for more details.\n  (Comparing parts of v0.21 with v0.20 may be useful.)\n\n\n=head2 Changes in DBI 0.58\t21 June 1995\n\n  Added DBI->internal->{DebugLog} = $filename;\n  Reworked internal logging.\n  Added $VERSION.\n  Made disconnect_all a compulsory method for drivers.\n\n\n=head1 ANCIENT HISTORY\n\n12th Oct 1994: First public release of the DBI module.\n               (for Perl 5.000-beta-3h)\n\n19th Sep 1994: DBperl project renamed to DBI.\n\n29th Sep 1992: DBperl project started.\n\n=cut\n", "/* vim: ts=8:sw=4:expandtab\n *\n * $Id$\n *\n * Copyright (c) 1994-2012  Tim Bunce  Ireland.\n *\n * See COPYRIGHT section in DBI.pm for usage and distribution rights.\n */\n#define NEED_grok_number\n#define NEED_grok_numeric_radix\n#define NEED_newRV_noinc\n#define NEED_sv_2pv_flags\n\n#define IN_DBI_XS 1     /* see DBIXS.h */\n#define PERL_NO_GET_CONTEXT\n\n#include \"DBIXS.h\"      /* DBI public interface for DBD's written in C  */\n\n# if (defined(_WIN32) && (! defined(HAS_GETTIMEOFDAY)))\n#include <sys/timeb.h>\n# endif\n\n/* The XS dispatcher code can optimize calls to XS driver methods,\n * bypassing the usual call_sv() and argument handling overheads.\n * Just-in-case it causes problems there's an (undocumented) way\n * to disable it by setting an env var.\n */\nstatic int use_xsbypass = 1; /* set in dbi_bootinit() */\n\n#ifndef CvISXSUB\n#define CvISXSUB(sv) CvXSUB(sv)\n#endif\n\n#define DBI_MAGIC '~'\n\n/* HvMROMETA introduced in 5.9.5, but mro_meta_init not exported in 5.10.0 */\n#if (PERL_VERSION < 10)\n#  define MY_cache_gen(stash) 0\n#else\n#  if ((PERL_VERSION == 10) && (PERL_SUBVERSION == 0))\n#    define MY_cache_gen(stash) \\\n        (HvAUX(stash)->xhv_mro_meta \\\n        ? HvAUX(stash)->xhv_mro_meta->cache_gen \\\n        : 0)\n#  else\n#    define MY_cache_gen(stash) HvMROMETA(stash)->cache_gen\n#  endif\n#endif\n\n/* If the tests fail with errors about 'setlinebuf' then try    */\n/* deleting the lines in the block below except the setvbuf one */\n#ifndef PerlIO_setlinebuf\n#ifdef HAS_SETLINEBUF\n#define PerlIO_setlinebuf(f)        setlinebuf(f)\n#else\n#ifndef USE_PERLIO\n#define PerlIO_setlinebuf(f)        setvbuf(f, Nullch, _IOLBF, 0)\n#endif\n#endif\n#endif\n\n#ifndef CopFILEGV\n#  define CopFILEGV(cop) cop->cop_filegv\n#  define CopLINE(cop)   cop->cop_line\n#  define CopSTASH(cop)           cop->cop_stash\n#  define CopSTASHPV(cop)           (CopSTASH(cop) ? HvNAME(CopSTASH(cop)) : Nullch)\n#endif\n#ifndef PERL_GET_THX\n#define PERL_GET_THX ((void*)0)\n#endif\n#ifndef PerlProc_getpid\n#define PerlProc_getpid() getpid()\nextern Pid_t getpid (void);\n#endif\n#ifndef aTHXo_\n#define aTHXo_\n#endif\n\n#if (PERL_VERSION < 8) || ((PERL_VERSION == 8) && (PERL_SUBVERSION == 0))\n#define DBI_save_hv_fetch_ent\n#endif\n\n/* prior to 5.8.9: when a CV is duped, the mg dup method is called,\n * then *afterwards*, any_ptr is copied from the old CV to the new CV.\n * This wipes out anything which the dup method did to any_ptr.\n * This needs working around */\n#if defined(USE_ITHREADS) && (PERL_VERSION == 8) && (PERL_SUBVERSION < 9)\n#  define BROKEN_DUP_ANY_PTR\n#endif\n\n/* types of method name */\n\ntypedef enum {\n    methtype_ordinary, /* nothing special about this method name */\n    methtype_DESTROY,\n    methtype_FETCH,\n    methtype_can,\n    methtype_fetch_star, /* fetch*, i.e. fetch() or fetch_...() */\n    methtype_set_err\n} meth_types;\n\n\nstatic imp_xxh_t *dbih_getcom      _((SV *h));\nstatic imp_xxh_t *dbih_getcom2     _((pTHX_ SV *h, MAGIC **mgp));\nstatic void       dbih_clearcom    _((imp_xxh_t *imp_xxh));\nstatic int        dbih_logmsg      _((imp_xxh_t *imp_xxh, const char *fmt, ...));\nstatic SV        *dbih_make_com    _((SV *parent_h, imp_xxh_t *p_imp_xxh, const char *imp_class, STRLEN imp_size, STRLEN extra, SV *copy));\nstatic SV        *dbih_make_fdsv   _((SV *sth, const char *imp_class, STRLEN imp_size, const char *col_name));\nstatic AV        *dbih_get_fbav    _((imp_sth_t *imp_sth));\nstatic SV        *dbih_event       _((SV *h, const char *name, SV*, SV*));\nstatic int        dbih_set_attr_k  _((SV *h, SV *keysv, int dbikey, SV *valuesv));\nstatic SV        *dbih_get_attr_k  _((SV *h, SV *keysv, int dbikey));\nstatic int       dbih_sth_bind_col _((SV *sth, SV *col, SV *ref, SV *attribs));\n\nstatic int      set_err_char _((SV *h, imp_xxh_t *imp_xxh, const char *err_c, IV err_i, const char *errstr, const char *state, const char *method));\nstatic int      set_err_sv   _((SV *h, imp_xxh_t *imp_xxh, SV *err, SV *errstr, SV *state, SV *method));\nstatic int      quote_type _((int sql_type, int p, int s, int *base_type, void *v));\nstatic int      sql_type_cast_svpv _((pTHX_ SV *sv, int sql_type, U32 flags, void *v));\nstatic I32      dbi_hash _((const char *string, long i));\nstatic void     dbih_dumphandle _((pTHX_ SV *h, const char *msg, int level));\nstatic int      dbih_dumpcom _((pTHX_ imp_xxh_t *imp_xxh, const char *msg, int level));\nstatic int      dbi_ima_free(pTHX_ SV* sv, MAGIC* mg);\n#if defined(USE_ITHREADS) && !defined(BROKEN_DUP_ANY_PTR)\nstatic int      dbi_ima_dup(pTHX_ MAGIC* mg, CLONE_PARAMS *param);\n#endif\nchar *neatsvpv _((SV *sv, STRLEN maxlen));\nSV * preparse(SV *dbh, const char *statement, IV ps_return, IV ps_accept, void *foo);\nstatic meth_types get_meth_type(const char * const name);\n\nstruct imp_drh_st { dbih_drc_t com; };\nstruct imp_dbh_st { dbih_dbc_t com; };\nstruct imp_sth_st { dbih_stc_t com; };\nstruct imp_fdh_st { dbih_fdc_t com; };\n\n/* identify the type of a method name for dispatch behaviour */\n/* (should probably be folded into the IMA flags mechanism)  */\n\nstatic meth_types\nget_meth_type(const char * const name)\n{\n    switch (name[0]) {\n    case 'D':\n        if strEQ(name,\"DESTROY\")\n            return methtype_DESTROY;\n        break;\n    case 'F':\n        if strEQ(name,\"FETCH\")\n            return methtype_FETCH;\n        break;\n    case 'c':\n        if strEQ(name,\"can\")\n            return methtype_can;\n        break;\n    case 'f':\n        if strnEQ(name,\"fetch\", 5) /* fetch* */\n            return methtype_fetch_star;\n        break;\n    case 's':\n        if strEQ(name,\"set_err\")\n            return methtype_set_err;\n        break;\n    }\n    return methtype_ordinary;\n}\n\n\n/* Internal Method Attributes (attached to dispatch methods when installed) */\n/* NOTE: when adding SVs to dbi_ima_t, update dbi_ima_dup() dbi_ima_free()\n * to ensure that they are duped and correctly ref-counted */\n\ntypedef struct dbi_ima_st {\n    U8 minargs;\n    U8 maxargs;\n    IV hidearg;\n    /* method_trace controls tracing of method calls in the dispatcher:\n    - if the current trace flags include a trace flag in method_trace\n    then set trace_level to min(2,trace_level) for duration of the call.\n    - else, if trace_level < (method_trace & DBIc_TRACE_LEVEL_MASK)\n    then don't trace the call\n    */\n    U32 method_trace;\n    const char *usage_msg;\n    U32 flags;\n    meth_types meth_type;\n\n    /* cached outer to inner method mapping */\n    HV *stash;          /* the stash we found the GV in */\n    GV *gv;             /* the GV containing the inner sub */\n    U32 generation;     /* cache invalidation */\n#ifdef BROKEN_DUP_ANY_PTR\n    PerlInterpreter *my_perl; /* who owns this struct */\n#endif\n\n} dbi_ima_t;\n\n/* These values are embedded in the data passed to install_method       */\n#define IMA_HAS_USAGE             0x00000001  /* check parameter usage        */\n#define IMA_FUNC_REDIRECT         0x00000002  /* is $h->func(..., \"method\")   */\n#define IMA_KEEP_ERR              0x00000004  /* don't reset err & errstr     */\n#define IMA_KEEP_ERR_SUB          0x00000008  /*  '' if in a nested call      */\n#define IMA_NO_TAINT_IN           0x00000010  /* don't check for tainted args */\n#define IMA_NO_TAINT_OUT          0x00000020  /* don't taint results          */\n#define IMA_COPY_UP_STMT          0x00000040  /* copy sth Statement to dbh    */\n#define IMA_END_WORK              0x00000080  /* method is commit or rollback */\n#define IMA_STUB                  0x00000100  /* donothing eg $dbh->connected */\n#define IMA_CLEAR_STMT            0x00000200  /* clear Statement before call  */\n#define IMA_UNRELATED_TO_STMT     0x00000400  /* profile as empty Statement   */\n#define IMA_NOT_FOUND_OKAY        0x00000800  /* no error if not found        */\n#define IMA_EXECUTE               0x00001000  /* do/execute: DBIcf_Executed   */\n#define IMA_SHOW_ERR_STMT         0x00002000  /* dbh meth relates to Statement*/\n#define IMA_HIDE_ERR_PARAMVALUES  0x00004000  /* ParamValues are not relevant */\n#define IMA_IS_FACTORY            0x00008000  /* new h ie connect and prepare */\n#define IMA_CLEAR_CACHED_KIDS     0x00010000  /* clear CachedKids before call */\n\n#define DBIc_STATE_adjust(imp_xxh, state)                                \\\n    (SvOK(state)        /* SQLSTATE is implemented by driver   */        \\\n        ? (strEQ(SvPV_nolen(state),\"00000\") ? &PL_sv_no : sv_mortalcopy(state))\\\n        : (SvTRUE(DBIc_ERR(imp_xxh))                                     \\\n            ? sv_2mortal(newSVpv(\"S1000\",5)) /* General error   */       \\\n            : &PL_sv_no)                /* Success (\"00000\")    */       \\\n    )\n\n#define DBI_LAST_HANDLE         g_dbi_last_h /* special fake inner handle */\n#define DBI_IS_LAST_HANDLE(h)   ((DBI_LAST_HANDLE) == SvRV(h))\n#define DBI_SET_LAST_HANDLE(h)  ((DBI_LAST_HANDLE) =  SvRV(h))\n#define DBI_UNSET_LAST_HANDLE   ((DBI_LAST_HANDLE) =  &PL_sv_undef)\n#define DBI_LAST_HANDLE_OK      ((DBI_LAST_HANDLE) != &PL_sv_undef)\n\n#define DBIS_TRACE_LEVEL        (DBIS->debug & DBIc_TRACE_LEVEL_MASK)\n#define DBIS_TRACE_FLAGS        (DBIS->debug)   /* includes level */\n\n#ifdef PERL_LONG_MAX\n#define MAX_LongReadLen PERL_LONG_MAX\n#else\n#define MAX_LongReadLen 2147483647L\n#endif\n\n#ifdef DBI_USE_THREADS\nstatic char *dbi_build_opt = \"-ithread\";\n#else\nstatic char *dbi_build_opt = \"-nothread\";\n#endif\n\n/* 32 bit magic FNV-0 and FNV-1 prime */\n#define FNV_32_PRIME ((UV)0x01000193)\n\n\n/* perl doesn't know anything about the dbi_ima_t struct attached to the\n * CvXSUBANY(cv).any_ptr slot, so add some magic to the CV to handle\n * duping and freeing.\n */\n\nstatic MGVTBL dbi_ima_vtbl = { 0, 0, 0, 0, dbi_ima_free,\n                                    0,\n#if defined(USE_ITHREADS) && !defined(BROKEN_DUP_ANY_PTR)\n                                    dbi_ima_dup\n#else\n                                    0\n#endif\n#if (PERL_VERSION > 8) || ((PERL_VERSION == 8) && (PERL_SUBVERSION >= 9))\n                                    , 0\n#endif\n                                    };\n\nstatic int dbi_ima_free(pTHX_ SV* sv, MAGIC* mg)\n{\n    dbi_ima_t *ima = (dbi_ima_t *)(CvXSUBANY((CV*)sv).any_ptr);\n#ifdef BROKEN_DUP_ANY_PTR\n    if (ima->my_perl != my_perl)\n        return 0;\n#endif\n    SvREFCNT_dec(ima->stash);\n    SvREFCNT_dec(ima->gv);\n    Safefree(ima);\n    return 0;\n}\n\n#if defined(USE_ITHREADS) && !defined(BROKEN_DUP_ANY_PTR)\nstatic int dbi_ima_dup(pTHX_ MAGIC* mg, CLONE_PARAMS *param)\n{\n    dbi_ima_t *ima, *nima;\n    CV *cv  = (CV*) mg->mg_ptr;\n    CV *ncv = (CV*)ptr_table_fetch(PL_ptr_table, (cv));\n\n    PERL_UNUSED_VAR(param);\n    mg->mg_ptr = (char *)ncv;\n    ima = (dbi_ima_t*) CvXSUBANY(cv).any_ptr;\n    Newx(nima, 1, dbi_ima_t);\n    *nima = *ima; /* structure copy */\n    CvXSUBANY(ncv).any_ptr = nima;\n    nima->stash = NULL;\n    nima->gv    = NULL;\n    return 0;\n}\n#endif\n\n\n\n/* --- make DBI safe for multiple perl interpreters --- */\n/*     Originally contributed by Murray Nesbitt of ActiveState, */\n/*     but later updated to use MY_CTX */\n\n#define MY_CXT_KEY \"DBI::_guts\" XS_VERSION\n\ntypedef struct {\n    SV   *dbi_last_h;  /* maybe better moved into dbistate_t? */\n    dbistate_t* dbi_state;\n} my_cxt_t;\n\nSTART_MY_CXT\n\n#undef DBIS\n#define DBIS                   (MY_CXT.dbi_state)\n\n#define g_dbi_last_h            (MY_CXT.dbi_last_h)\n\n/* allow the 'static' dbi_state struct to be accessed from other files */\ndbistate_t**\n_dbi_state_lval(pTHX)\n{\n    dMY_CXT;\n    return &(MY_CXT.dbi_state);\n}\n\n\n/* --- */\n\nstatic void *\nmalloc_using_sv(STRLEN len)\n{\n    dTHX;\n    SV *sv = newSV(len);\n    void *p = SvPVX(sv);\n    memzero(p, len);\n    return p;\n}\n\nstatic char *\nsavepv_using_sv(char *str)\n{\n    char *buf = malloc_using_sv(strlen(str));\n    strcpy(buf, str);\n    return buf;\n}\n\n\n/* --- support functions for concat_hash_sorted --- */\n\ntypedef struct str_uv_sort_pair_st {\n    char *key;\n    UV numeric;\n} str_uv_sort_pair_t;\n\nstatic int\n_cmp_number(const void *val1, const void *val2)\n{\n    UV first  = ((str_uv_sort_pair_t *)val1)->numeric;\n    UV second = ((str_uv_sort_pair_t *)val2)->numeric;\n\n    if (first > second)\n        return 1;\n    if (first < second)\n        return -1;\n    /* only likely to reach here if numeric sort forced for non-numeric keys */\n    /* fallback to comparing the key strings */\n    return strcmp(\n        ((str_uv_sort_pair_t *)val1)->key,\n        ((str_uv_sort_pair_t *)val2)->key\n    );\n}\n\nstatic int \n_cmp_str (const void *val1, const void *val2)\n{\n    return strcmp( *(char **)val1, *(char **)val2);\n}\n\nstatic char **\n_sort_hash_keys (HV *hash, int num_sort, STRLEN *total_length)\n{\n    dTHX;\n    I32 hv_len, key_len;\n    HE *entry;\n    char **keys;\n    unsigned int idx = 0;\n    STRLEN tot_len = 0;\n    bool has_non_numerics = 0;\n    str_uv_sort_pair_t *numbers;\n\n    hv_len = hv_iterinit(hash);\n    if (!hv_len)\n        return 0;\n\n    Newz(0, keys,    hv_len, char *);\n    Newz(0, numbers, hv_len, str_uv_sort_pair_t);\n\n    while ((entry = hv_iternext(hash))) {\n        *(keys+idx) = hv_iterkey(entry, &key_len);\n        tot_len += key_len;\n        \n        if (grok_number(*(keys+idx), key_len, &(numbers+idx)->numeric) != IS_NUMBER_IN_UV) {\n            has_non_numerics = 1;\n            (numbers+idx)->numeric = 0;\n        }\n\n        (numbers+idx)->key = *(keys+idx);\n        ++idx;\n    }\n\n    if (total_length)\n        *total_length = tot_len;\n\n    if (num_sort < 0)\n        num_sort = (has_non_numerics) ? 0 : 1;\n\n    if (!num_sort) {\n        qsort(keys, hv_len, sizeof(char*), _cmp_str);\n    }\n    else {\n        qsort(numbers, hv_len, sizeof(str_uv_sort_pair_t), _cmp_number);\n        for (idx = 0; idx < hv_len; ++idx)\n            *(keys+idx) = (numbers+idx)->key;\n    }\n\n    Safefree(numbers);\n    return keys;\n}\n\n\nstatic SV *\n_join_hash_sorted(HV *hash, char *kv_sep, STRLEN kv_sep_len, char *pair_sep, STRLEN pair_sep_len, int use_neat, int num_sort)\n{\n        dTHX;\n        I32 hv_len;\n        STRLEN total_len = 0;\n        char **keys;\n        unsigned int i = 0;\n        SV *return_sv;\n\n        keys = _sort_hash_keys(hash, num_sort, &total_len);\n        if (!keys)\n            return newSVpv(\"\", 0);\n\n        if (!kv_sep_len)\n            kv_sep_len = strlen(kv_sep);\n        if (!pair_sep_len)\n            pair_sep_len = strlen(pair_sep);\n\n        hv_len = hv_iterinit(hash);\n        /* total_len += Separators + quotes + term null */\n        total_len += kv_sep_len*hv_len + pair_sep_len*hv_len+2*hv_len+1;\n        return_sv = newSV(total_len);\n        sv_setpv(return_sv, \"\"); /* quell undef warnings */\n\n        for (i=0; i<hv_len; ++i) {\n            SV **hash_svp = hv_fetch(hash, keys[i], strlen(keys[i]), 0);\n\n            sv_catpv(return_sv, keys[i]); /* XXX keys can't contain nul chars */\n            sv_catpvn(return_sv, kv_sep, kv_sep_len);\n\n            if (!hash_svp) {    /* should never happen */\n                warn(\"No hash entry with key '%s'\", keys[i]);\n                sv_catpvn(return_sv, \"???\", 3);\n                continue;\n            }\n\n            if (use_neat) {\n                sv_catpv(return_sv, neatsvpv(*hash_svp,0));\n            }\n            else {\n                if (SvOK(*hash_svp)) {\n                     STRLEN hv_val_len;\n                     char *hv_val = SvPV(*hash_svp, hv_val_len);\n                     sv_catpvn(return_sv, \"'\", 1);\n                     sv_catpvn(return_sv, hv_val, hv_val_len);\n                     sv_catpvn(return_sv, \"'\", 1);\n                }\n                else sv_catpvn(return_sv, \"undef\", 5);\n            }\n\n            if (i < hv_len-1)\n                sv_catpvn(return_sv, pair_sep, pair_sep_len);\n        }\n\n        Safefree(keys);\n\n        return return_sv;\n}\n\n\n\n/* handy for embedding into condition expression for debugging */\n/*\nstatic int warn1(char *s) { warn(s); return 1; }\nstatic int dump1(SV *sv)  { dTHX; sv_dump(sv); return 1; }\n*/\n\n\n/* --- */\n\nstatic void\ncheck_version(const char *name, int dbis_cv, int dbis_cs, int need_dbixs_cv, int drc_s,\n        int dbc_s, int stc_s, int fdc_s)\n{\n    dTHX;\n    dMY_CXT;\n    static const char msg[] = \"you probably need to rebuild the DBD driver (or possibly the DBI)\";\n    (void)need_dbixs_cv;\n    if (dbis_cv != DBISTATE_VERSION || dbis_cs != sizeof(*DBIS))\n        croak(\"DBI/DBD internal version mismatch (DBI is v%d/s%lu, DBD %s expected v%d/s%d) %s.\\n\",\n            DBISTATE_VERSION, (long unsigned int)sizeof(*DBIS), name, dbis_cv, dbis_cs, msg);\n    /* Catch structure size changes - We should probably force a recompile if the DBI   */\n    /* runtime version is different from the build time. That would be harsh but safe.  */\n    if (drc_s != sizeof(dbih_drc_t) || dbc_s != sizeof(dbih_dbc_t) ||\n        stc_s != sizeof(dbih_stc_t) || fdc_s != sizeof(dbih_fdc_t) )\n            croak(\"%s (dr:%d/%ld, db:%d/%ld, st:%d/%ld, fd:%d/%ld), %s.\\n\",\n                \"DBI/DBD internal structure mismatch\",\n                drc_s, (long)sizeof(dbih_drc_t), dbc_s, (long)sizeof(dbih_dbc_t),\n                stc_s, (long)sizeof(dbih_stc_t), fdc_s, (long)sizeof(dbih_fdc_t), msg);\n}\n\nstatic void\ndbi_bootinit(dbistate_t * parent_dbis)\n{\n    dTHX;\n    dMY_CXT;\n    dbistate_t* DBISx;\n\n    DBISx = (struct dbistate_st*)malloc_using_sv(sizeof(struct dbistate_st));\n    DBIS = DBISx;\n\n    /* make DBIS available to DBD modules the \"old\" (<= 1.618) way,\n     * so that unrecompiled DBD's will still work against a newer DBI */\n    sv_setiv(get_sv(\"DBI::_dbistate\", GV_ADDMULTI),\n            PTR2IV(MY_CXT.dbi_state));\n\n    /* store version and size so we can spot DBI/DBD version mismatch   */\n    DBIS->check_version = check_version;\n    DBIS->version = DBISTATE_VERSION;\n    DBIS->size    = sizeof(*DBIS);\n    DBIS->xs_version = DBIXS_VERSION;\n\n    DBIS->logmsg      = dbih_logmsg;\n    DBIS->logfp       = PerlIO_stderr();\n    DBIS->debug       = (parent_dbis) ? parent_dbis->debug\n                            : SvIV(get_sv(\"DBI::dbi_debug\",0x5));\n    DBIS->neatsvpvlen = (parent_dbis) ? parent_dbis->neatsvpvlen\n                                      : get_sv(\"DBI::neat_maxlen\", GV_ADDMULTI);\n#ifdef DBI_USE_THREADS\n    DBIS->thr_owner   = PERL_GET_THX;\n#endif\n\n    /* store some function pointers so DBD's can call our functions     */\n    DBIS->getcom      = dbih_getcom;\n    DBIS->clearcom    = dbih_clearcom;\n    DBIS->event       = dbih_event;\n    DBIS->set_attr_k  = dbih_set_attr_k;\n    DBIS->get_attr_k  = dbih_get_attr_k;\n    DBIS->get_fbav    = dbih_get_fbav;\n    DBIS->make_fdsv   = dbih_make_fdsv;\n    DBIS->neat_svpv   = neatsvpv;\n    DBIS->bind_as_num = quote_type; /* XXX deprecated */\n    DBIS->hash        = dbi_hash;\n    DBIS->set_err_sv  = set_err_sv;\n    DBIS->set_err_char= set_err_char;\n    DBIS->bind_col    = dbih_sth_bind_col;\n    DBIS->sql_type_cast_svpv = sql_type_cast_svpv;\n\n\n    /* Remember the last handle used. BEWARE! Sneaky stuff here!        */\n    /* We want a handle reference but we don't want to increment        */\n    /* the handle's reference count and we don't want perl to try       */\n    /* to destroy it during global destruction. Take care!              */\n    DBI_UNSET_LAST_HANDLE;      /* ensure setup the correct way         */\n\n    /* trick to avoid 'possible typo' warnings  */\n    gv_fetchpv(\"DBI::state\",  GV_ADDMULTI, SVt_PV);\n    gv_fetchpv(\"DBI::err\",    GV_ADDMULTI, SVt_PV);\n    gv_fetchpv(\"DBI::errstr\", GV_ADDMULTI, SVt_PV);\n    gv_fetchpv(\"DBI::lasth\",  GV_ADDMULTI, SVt_PV);\n    gv_fetchpv(\"DBI::rows\",   GV_ADDMULTI, SVt_PV);\n\n    /* we only need to check the env var on the initial boot\n     * which is handy because it can core dump during CLONE on windows\n     */\n    if (!parent_dbis && getenv(\"PERL_DBI_XSBYPASS\"))\n        use_xsbypass = atoi(getenv(\"PERL_DBI_XSBYPASS\"));\n}\n\n\n/* ----------------------------------------------------------------- */\n/* Utility functions                                                 */\n\n\nstatic char *\ndbih_htype_name(int htype)\n{\n    switch(htype) {\n    case DBIt_DR: return \"dr\";\n    case DBIt_DB: return \"db\";\n    case DBIt_ST: return \"st\";\n    case DBIt_FD: return \"fd\";\n    default:      return \"??\";\n    }\n}\n\n\nchar *\nneatsvpv(SV *sv, STRLEN maxlen) /* return a tidy ascii value, for debugging only */\n{\n    dTHX;\n    dMY_CXT;\n    STRLEN len;\n    SV *nsv = Nullsv;\n    SV *infosv = Nullsv;\n    char *v, *quote;\n\n    /* We take care not to alter the supplied sv in any way at all.      */\n    /* (but if it is SvGMAGICAL we have to call mg_get and that can      */\n    /* have side effects, especially as it may be called twice overall.) */\n\n    if (!sv)\n        return \"Null!\";                         /* should never happen  */\n\n    /* try to do the right thing with magical values                    */\n    if (SvMAGICAL(sv)) {\n        if (DBIS_TRACE_LEVEL >= 5) {    /* add magic details to help debugging  */\n            MAGIC* mg;\n            infosv = sv_2mortal(newSVpv(\" (magic-\",0));\n            if (SvSMAGICAL(sv)) sv_catpvn(infosv,\"s\",1);\n            if (SvGMAGICAL(sv)) sv_catpvn(infosv,\"g\",1);\n            if (SvRMAGICAL(sv)) sv_catpvn(infosv,\"r\",1);\n            sv_catpvn(infosv,\":\",1);\n            for (mg = SvMAGIC(sv); mg; mg = mg->mg_moremagic)\n                sv_catpvn(infosv, &mg->mg_type, 1);\n            sv_catpvn(infosv, \")\", 1);\n        }\n        if (SvGMAGICAL(sv) && !PL_dirty)\n            mg_get(sv);         /* trigger magic to FETCH the value     */\n    }\n\n    if (!SvOK(sv)) {\n        if (SvTYPE(sv) >= SVt_PVAV)\n            return (char *)sv_reftype(sv,0);    /* raw AV/HV etc, not via a ref */\n        if (!infosv)\n            return \"undef\";\n        sv_insert(infosv, 0,0, \"undef\",5);\n        return SvPVX(infosv);\n    }\n\n    if (SvNIOK(sv)) {     /* is a numeric value - so no surrounding quotes      */\n        if (SvPOK(sv)) {  /* already has string version of the value, so use it */\n            v = SvPV(sv,len);\n            if (len == 0) { v=\"''\"; len=2; } /* catch &sv_no style special case */\n            if (!infosv)\n                return v;\n            sv_insert(infosv, 0,0, v, len);\n            return SvPVX(infosv);\n        }\n        /* we don't use SvPV here since we don't want to alter sv in _any_ way  */\n        if (SvUOK(sv))\n             nsv = newSVpvf(\"%\"UVuf, SvUVX(sv));\n        else if (SvIOK(sv))\n             nsv = newSVpvf(\"%\"IVdf, SvIVX(sv));\n        else nsv = newSVpvf(\"%\"NVgf, SvNVX(sv));\n        if (infosv)\n            sv_catsv(nsv, infosv);\n        return SvPVX(sv_2mortal(nsv));\n    }\n\n    nsv = sv_newmortal();\n    sv_upgrade(nsv, SVt_PV);\n\n    if (SvROK(sv)) {\n        if (!SvAMAGIC(sv))      /* (un-amagic'd) refs get no special treatment  */\n            v = SvPV(sv,len);\n        else {\n            /* handle Overload magic refs */\n            (void)SvAMAGIC_off(sv);   /* should really be done via local scoping */\n            v = SvPV(sv,len);   /* XXX how does this relate to SvGMAGIC?   */\n            SvAMAGIC_on(sv);\n        }\n        sv_setpvn(nsv, v, len);\n        if (infosv)\n            sv_catsv(nsv, infosv);\n        return SvPV(nsv, len);\n    }\n\n    if (SvPOK(sv))              /* usual simple string case                */\n        v = SvPV(sv,len);\n    else                        /* handles all else via sv_2pv()           */\n        v = SvPV(sv,len);       /* XXX how does this relate to SvGMAGIC?   */\n\n    /* for strings we limit the length and translate codes      */\n    if (maxlen == 0)\n        maxlen = SvIV(DBIS->neatsvpvlen);\n    if (maxlen < 6)                     /* handle daft values   */\n        maxlen = 6;\n    maxlen -= 2;                        /* account for quotes   */\n\n    quote = (SvUTF8(sv)) ? \"\\\"\" : \"'\";\n    if (len > maxlen) {\n        SvGROW(nsv, (1+maxlen+1+1));\n        sv_setpvn(nsv, quote, 1);\n        sv_catpvn(nsv, v, maxlen-3);    /* account for three dots */\n        sv_catpvn(nsv, \"...\", 3);\n    } else {\n        SvGROW(nsv, (1+len+1+1));\n        sv_setpvn(nsv, quote, 1);\n        sv_catpvn(nsv, v, len);\n    }\n    sv_catpvn(nsv, quote, 1);\n    if (infosv)\n        sv_catsv(nsv, infosv);\n    v = SvPV(nsv, len);\n    if (!SvUTF8(sv)) {\n        while(len-- > 0) { /* cleanup string (map control chars to ascii etc) */\n            const char c = v[len] & 0x7F;       /* ignore top bit for multinational chars */\n            if (!isPRINT(c) && !isSPACE(c))\n                v[len] = '.';\n        }\n    }\n    return v;\n}\n\n\nstatic int\nset_err_char(SV *h, imp_xxh_t *imp_xxh, const char *err_c, IV err_i, const char *errstr, const char *state, const char *method)\n{\n    dTHX;\n    char err_buf[28];\n    SV *err_sv, *errstr_sv, *state_sv, *method_sv;\n    if (!err_c) {\n        sprintf(err_buf, \"%ld\", (long)err_i);\n        err_c = &err_buf[0];\n    }\n    err_sv    = (strEQ(err_c,\"1\")) ? &PL_sv_yes : sv_2mortal(newSVpvn(err_c, strlen(err_c)));\n    errstr_sv = sv_2mortal(newSVpvn(errstr, strlen(errstr)));\n    state_sv  = (state  && *state)  ? sv_2mortal(newSVpvn(state,  strlen(state)))  : &PL_sv_undef;\n    method_sv = (method && *method) ? sv_2mortal(newSVpvn(method, strlen(method))) : &PL_sv_undef;\n    return set_err_sv(h, imp_xxh, err_sv, errstr_sv, state_sv, method_sv);\n}\n\nstatic int\nset_err_sv(SV *h, imp_xxh_t *imp_xxh, SV *err, SV *errstr, SV *state, SV *method)\n{\n    dTHX;\n    SV *h_err;\n    SV *h_errstr;\n    SV *h_state;\n    SV **hook_svp;\n    int err_changed = 0;\n\n    if (    DBIc_has(imp_xxh, DBIcf_HandleSetErr)\n        && (hook_svp = hv_fetch((HV*)SvRV(h),\"HandleSetErr\",12,0))\n        &&  hook_svp\n        &&  ((void)(SvGMAGICAL(*hook_svp) && mg_get(*hook_svp)), SvOK(*hook_svp))\n    ) {\n        dSP;\n        IV items;\n        SV *response_sv;\n        if (SvREADONLY(err))    err    = sv_mortalcopy(err);\n        if (SvREADONLY(errstr)) errstr = sv_mortalcopy(errstr);\n        if (SvREADONLY(state))  state  = sv_mortalcopy(state);\n        if (SvREADONLY(method)) method = sv_mortalcopy(method);\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"    -> HandleSetErr(%s, err=%s, errstr=%s, state=%s, %s)\\n\",\n                neatsvpv(h,0), neatsvpv(err,0), neatsvpv(errstr,0), neatsvpv(state,0),\n                neatsvpv(method,0)\n            );\n        PUSHMARK(SP);\n        XPUSHs(sv_2mortal(newRV_inc((SV*)DBIc_MY_H(imp_xxh))));\n        XPUSHs(err);\n        XPUSHs(errstr);\n        XPUSHs(state);\n        XPUSHs(method);\n        PUTBACK;\n        items = call_sv(*hook_svp, G_SCALAR);\n        SPAGAIN;\n        response_sv = (items) ? POPs : &PL_sv_undef;\n        PUTBACK;\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 1)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"    <- HandleSetErr= %s (err=%s, errstr=%s, state=%s, %s)\\n\",\n                neatsvpv(response_sv,0), neatsvpv(err,0), neatsvpv(errstr,0), neatsvpv(state,0),\n                neatsvpv(method,0)\n            );\n        if (SvTRUE(response_sv))        /* handler says it has handled it, so... */\n            return 0;\n    }\n\n    if (!SvOK(err)) {   /* clear err / errstr / state */\n        DBIh_CLEAR_ERROR(imp_xxh);\n        return 1;\n    }\n\n    /* fetch these after calling HandleSetErr */\n    h_err    = DBIc_ERR(imp_xxh);\n    h_errstr = DBIc_ERRSTR(imp_xxh);\n    h_state  = DBIc_STATE(imp_xxh);\n\n    if (SvTRUE(h_errstr)) {\n        /* append current err, if any, to errstr if it's going to change */\n        if (SvTRUE(h_err) && SvTRUE(err) && strNE(SvPV_nolen(h_err), SvPV_nolen(err)))\n            sv_catpvf(h_errstr, \" [err was %s now %s]\", SvPV_nolen(h_err), SvPV_nolen(err));\n        if (SvTRUE(h_state) && SvTRUE(state) && strNE(SvPV_nolen(h_state), SvPV_nolen(state)))\n            sv_catpvf(h_errstr, \" [state was %s now %s]\", SvPV_nolen(h_state), SvPV_nolen(state));\n        if (strNE(SvPV_nolen(h_errstr), SvPV_nolen(errstr))) {\n            sv_catpvn(h_errstr, \"\\n\", 1);\n            sv_catsv(h_errstr, errstr);\n        }\n    }\n    else\n        sv_setsv(h_errstr, errstr);\n\n    /* SvTRUE(err) > \"0\" > \"\" > undef */\n    if (SvTRUE(err)             /* new error: so assign                 */\n        || !SvOK(h_err) /* no existing warn/info: so assign     */\n           /* new warn (\"0\" len 1) > info (\"\" len 0): so assign         */\n        || (SvOK(err) && strlen(SvPV_nolen(err)) > strlen(SvPV_nolen(h_err)))\n    ) {\n        sv_setsv(h_err, err);\n        err_changed = 1;\n        if (SvTRUE(h_err))      /* new error */\n            ++DBIc_ErrCount(imp_xxh);\n    }\n\n    if (err_changed) {\n        if (SvTRUE(state)) {\n            if (strlen(SvPV_nolen(state)) != 5) {\n                warn(\"set_err: state (%s) is not a 5 character string, using 'S1000' instead\", neatsvpv(state,0));\n                sv_setpv(h_state, \"S1000\");\n            }\n            else\n                sv_setsv(h_state, state);\n        }\n        else\n            (void)SvOK_off(h_state);    /* see DBIc_STATE_adjust */\n    }\n\n    return 1;\n}\n\n\n/* err_hash returns a U32 'hash' value representing the current err 'level'\n * (err/warn/info) and errstr. It's used by the dispatcher as a way to detect\n * a new or changed warning during a 'keep err' method like STORE. Always returns >0.\n * The value is 1 for no err/warn/info and guarantees that err > warn > info.\n * (It's a bit of a hack but the original approach in 70fe6bd76 using a new\n * ErrChangeCount attribute would break binary compatibility with drivers.)\n * The chance that two realistic errstr values would hash the same, even with\n * only 30 bits, is deemed to small to even bother documenting.\n */\nstatic U32\nerr_hash(pTHX_ imp_xxh_t *imp_xxh)\n{\n    SV *err_sv = DBIc_ERR(imp_xxh);\n    SV *errstr_sv;\n    I32 hash = 1;\n    if (SvOK(err_sv)) {\n        errstr_sv = DBIc_ERRSTR(imp_xxh);\n        if (SvOK(errstr_sv))\n             hash = -dbi_hash(SvPV_nolen(errstr_sv), 0); /* make positive */\n        else hash = 0;\n        hash >>= 1; /* free up extra bit (top bit is already free) */\n        hash |= (SvTRUE(err_sv))                  ? 0x80000000 /* err */\n              : (SvPOK(err_sv) && !SvCUR(err_sv)) ? 0x20000000 /* '' = info */\n                                                  : 0x40000000;/* 0 or '0' = warn */\n    }\n    return hash;\n}\n\n\nstatic char *\nmkvname(pTHX_ HV *stash, const char *item, int uplevel) /* construct a variable name    */\n{\n    SV *sv = sv_newmortal();\n    sv_setpv(sv, HvNAME(stash));\n    if(uplevel) {\n        while(SvCUR(sv) && *SvEND(sv)!=':')\n            --SvCUR(sv);\n        if (SvCUR(sv))\n            --SvCUR(sv);\n    }\n    sv_catpv(sv, \"::\");\n    sv_catpv(sv, item);\n    return SvPV_nolen(sv);\n}\n\n/* 32 bit magic FNV-0 and FNV-1 prime */\n#define FNV_32_PRIME ((UV)0x01000193)\n\nstatic I32\ndbi_hash(const char *key, long type)\n{\n    if (type == 0) {\n        STRLEN klen = strlen(key);\n        U32 hash = 0;\n        while (klen--)\n            hash = hash * 33 + *key++;\n        hash &= 0x7FFFFFFF;     /* limit to 31 bits             */\n        hash |= 0x40000000;     /* set bit 31                   */\n        return -(I32)hash;      /* return negative int  */\n    }\n    else if (type == 1) {       /* Fowler/Noll/Vo hash  */\n        /* see http://www.isthe.com/chongo/tech/comp/fnv/ */\n        U32 hash = 0x811c9dc5;\n        const unsigned char *s = (unsigned char *)key;    /* unsigned string */\n        while (*s) {\n            /* multiply by the 32 bit FNV magic prime mod 2^32 */\n            hash *= FNV_32_PRIME;\n            /* xor the bottom with the current octet */\n            hash ^= (U32)*s++;\n        }\n        return hash;\n    }\n    croak(\"DBI::hash(%ld): invalid type\", type);\n    return 0; /* NOT REACHED */\n}\n\n\nstatic int\ndbih_logmsg(imp_xxh_t *imp_xxh, const char *fmt, ...)\n{\n    dTHX;\n    va_list args;\n#ifdef I_STDARG\n    va_start(args, fmt);\n#else\n    va_start(args);\n#endif\n    (void) PerlIO_vprintf(DBIc_DBISTATE(imp_xxh)->logfp, fmt, args);\n    va_end(args);\n    (void)imp_xxh;\n    return 1;\n}\n\nstatic void\nclose_trace_file(pTHX)\n{\n    dMY_CXT;\n    if (DBILOGFP == PerlIO_stderr() || DBILOGFP == PerlIO_stdout())\n        return;\n\n    if (DBIS->logfp_ref == NULL)\n        PerlIO_close(DBILOGFP);\n    else {\n    /* DAA dec refcount and discard */\n        SvREFCNT_dec(DBIS->logfp_ref);\n        DBIS->logfp_ref = NULL;\n    }\n}\n\nstatic int\nset_trace_file(SV *file)\n{\n    dTHX;\n    dMY_CXT;\n    const char *filename;\n    PerlIO *fp = Nullfp;\n    IO *io;\n\n    if (!file)          /* no arg == no change */\n        return 0;\n\n    /* DAA check for a filehandle */\n    if (SvROK(file)) {\n        io = sv_2io(file);\n        if (!io || !(fp = IoOFP(io))) {\n            warn(\"DBI trace filehandle is not valid\");\n            return 0;\n        }\n        close_trace_file(aTHX);\n        (void)SvREFCNT_inc(io);\n        DBIS->logfp_ref = io;\n    }\n    else if (isGV_with_GP(file)) {\n        io = GvIO(file);\n        if (!io || !(fp = IoOFP(io))) {\n            warn(\"DBI trace filehandle from GLOB is not valid\");\n            return 0;\n        }\n        close_trace_file(aTHX);\n        (void)SvREFCNT_inc(io);\n        DBIS->logfp_ref = io;\n    }\n    else {\n        filename = (SvOK(file)) ? SvPV_nolen(file) : Nullch;\n        /* undef arg == reset back to stderr */\n        if (!filename || strEQ(filename,\"STDERR\")\n                      || strEQ(filename,\"*main::STDERR\")) {\n            close_trace_file(aTHX);\n            DBILOGFP = PerlIO_stderr();\n            return 1;\n        }\n        if (strEQ(filename,\"STDOUT\")) {\n            close_trace_file(aTHX);\n            DBILOGFP = PerlIO_stdout();\n            return 1;\n        }\n        fp = PerlIO_open(filename, \"a+\");\n        if (fp == Nullfp) {\n            warn(\"Can't open trace file %s: %s\", filename, Strerror(errno));\n            return 0;\n        }\n        close_trace_file(aTHX);\n    }\n    DBILOGFP = fp;\n    /* if this line causes your compiler or linker to choke     */\n    /* then just comment it out, it's not essential.    */\n    PerlIO_setlinebuf(fp);      /* force line buffered output */\n    return 1;\n}\n\nstatic IV\nparse_trace_flags(SV *h, SV *level_sv, IV old_level)\n{\n    dTHX;\n    IV level;\n    if (!level_sv || !SvOK(level_sv))\n        level = old_level;              /* undef: no change     */\n    else\n    if (SvTRUE(level_sv)) {\n        if (looks_like_number(level_sv))\n            level = SvIV(level_sv);     /* number: number       */\n        else {                          /* string: parse it     */\n            dSP;\n            PUSHMARK(sp);\n            XPUSHs(h);\n            XPUSHs(level_sv);\n            PUTBACK;\n            if (call_method(\"parse_trace_flags\", G_SCALAR) != 1)\n                croak(\"panic: parse_trace_flags\");/* should never happen */\n            SPAGAIN;\n            level = POPi;\n            PUTBACK;\n        }\n    }\n    else                                /* defined but false: 0 */\n        level = 0;\n    return level;\n}\n\n\nstatic int\nset_trace(SV *h, SV *level_sv, SV *file)\n{\n    dTHX;\n    D_imp_xxh(h);\n    int RETVAL = DBIc_DBISTATE(imp_xxh)->debug; /* Return trace level in effect now */\n    IV level = parse_trace_flags(h, level_sv, RETVAL);\n    set_trace_file(file);\n    if (level != RETVAL) { /* set value */\n        if ((level & DBIc_TRACE_LEVEL_MASK) > 0) {\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                \"    %s trace level set to 0x%lx/%ld (DBI @ 0x%lx/%ld) in DBI %s%s (pid %d)\\n\",\n                neatsvpv(h,0),\n                (long)(level & DBIc_TRACE_FLAGS_MASK),\n                (long)(level & DBIc_TRACE_LEVEL_MASK),\n                (long)DBIc_TRACE_FLAGS(imp_xxh), (long)DBIc_TRACE_LEVEL(imp_xxh),\n                XS_VERSION, dbi_build_opt, (int)PerlProc_getpid());\n            if (!PL_dowarn)\n                PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"    Note: perl is running without the recommended perl -w option\\n\");\n            PerlIO_flush(DBIc_LOGPIO(imp_xxh));\n        }\n        sv_setiv(DBIc_DEBUG(imp_xxh), level);\n    }\n    return RETVAL;\n}\n\n\nstatic SV *\ndbih_inner(pTHX_ SV *orv, const char *what)\n{   /* convert outer to inner handle else croak(what) if what is not NULL */\n    /* if what is NULL then return NULL for invalid handles */\n    MAGIC *mg;\n    SV *ohv;            /* outer HV after derefing the RV       */\n    SV *hrv;            /* dbi inner handle RV-to-HV            */\n\n    /* enable a raw HV (not ref-to-HV) to be passed in, eg DBIc_MY_H */\n    ohv = SvROK(orv) ? SvRV(orv) : orv;\n\n    if (!ohv || SvTYPE(ohv) != SVt_PVHV) {\n        if (!what)\n            return NULL;\n        if (1) {\n            dMY_CXT;\n            if (DBIS_TRACE_LEVEL)\n                sv_dump(orv);\n        }\n        if (!SvOK(orv))\n            croak(\"%s given an undefined handle %s\",\n                what, \"(perhaps returned from a previous call which failed)\");\n        croak(\"%s handle %s is not a DBI handle\", what, neatsvpv(orv,0));\n    }\n    if (!SvMAGICAL(ohv)) {\n        if (!what)\n            return NULL;\n        sv_dump(orv);\n        croak(\"%s handle %s is not a DBI handle (has no magic)\",\n                what, neatsvpv(orv,0));\n    }\n\n    if ( (mg=mg_find(ohv,'P')) == NULL) {       /* hash tie magic       */\n        /* not tied, maybe it's already an inner handle... */\n        if (mg_find(ohv, DBI_MAGIC) == NULL) {\n            if (!what)\n                return NULL;\n            sv_dump(orv);\n            croak(\"%s handle %s is not a valid DBI handle\",\n                what, neatsvpv(orv,0));\n        }\n        hrv = orv; /* was already a DBI handle inner hash */\n    }\n    else {\n        hrv = mg->mg_obj;  /* inner hash of tie */\n    }\n\n    return hrv;\n}\n\n\n\n/* -------------------------------------------------------------------- */\n/* Functions to manage a DBI handle (magic and attributes etc).         */\n\nstatic imp_xxh_t *\ndbih_getcom(SV *hrv) /* used by drivers via DBIS func ptr */\n{\n    MAGIC *mg;\n    SV *sv;\n\n    /* short-cut common case */\n    if (   SvROK(hrv)\n        && (sv = SvRV(hrv))\n        && SvRMAGICAL(sv)\n        && (mg = SvMAGIC(sv))\n        && mg->mg_type == DBI_MAGIC\n        && mg->mg_ptr\n    )\n        return (imp_xxh_t *) mg->mg_ptr;\n\n    {\n        dTHX;\n        imp_xxh_t *imp_xxh = dbih_getcom2(aTHX_ hrv, 0);\n        if (!imp_xxh)       /* eg after take_imp_data */\n            croak(\"Invalid DBI handle %s, has no dbi_imp_data\", neatsvpv(hrv,0));\n        return imp_xxh;\n    }\n}\n\nstatic imp_xxh_t *\ndbih_getcom2(pTHX_ SV *hrv, MAGIC **mgp) /* Get com struct for handle. Must be fast.    */\n{\n    MAGIC *mg;\n    SV *sv;\n\n    /* important and quick sanity check (esp non-'safe' Oraperl)        */\n    if (SvROK(hrv))                     /* must at least be a ref */\n        sv = SvRV(hrv);\n    else {\n        dMY_CXT;\n        if (hrv == DBI_LAST_HANDLE)    /* special for var::FETCH */\n            sv = DBI_LAST_HANDLE;\n        else if (sv_derived_from(hrv, \"DBI::common\")) {\n            /* probably a class name, if ref($h)->foo() */\n            return 0;\n        }\n        else {\n            sv_dump(hrv);\n            croak(\"Invalid DBI handle %s\", neatsvpv(hrv,0));\n            sv = &PL_sv_undef; /* avoid \"might be used uninitialized\" warning       */\n        }\n    }\n\n    /* Short cut for common case. We assume that a magic var always     */\n    /* has magic and that DBI_MAGIC, if present, will be the first.     */\n    if (SvRMAGICAL(sv) && (mg=SvMAGIC(sv))->mg_type == DBI_MAGIC) {\n        /* nothing to do here */\n    }\n    else {\n        /* Validate handle (convert outer to inner if required) */\n        hrv = dbih_inner(aTHX_ hrv, \"dbih_getcom\");\n        mg  = mg_find(SvRV(hrv), DBI_MAGIC);\n    }\n    if (mgp)    /* let caller pickup magic struct for this handle */\n        *mgp = mg;\n\n    if (!mg)    /* may happen during global destruction */\n        return (imp_xxh_t *) 0;\n\n    return (imp_xxh_t *) mg->mg_ptr;\n}\n\n\nstatic SV *\ndbih_setup_attrib(pTHX_ SV *h, imp_xxh_t *imp_xxh, char *attrib, SV *parent, int read_only, int optional)\n{\n    STRLEN len = strlen(attrib);\n    SV **asvp;\n\n    asvp = hv_fetch((HV*)SvRV(h), attrib, len, !optional);\n    /* we assume that we won't have any existing 'undef' attributes here */\n    /* (or, alternately, we take undef to mean 'copy from parent')       */\n    if (!(asvp && SvOK(*asvp))) { /* attribute doesn't already exists (the common case) */\n        SV **psvp;\n        if ((!parent || !SvROK(parent)) && !optional) {\n            croak(\"dbih_setup_attrib(%s): %s not set and no parent supplied\",\n                    neatsvpv(h,0), attrib);\n        }\n        psvp = hv_fetch((HV*)SvRV(parent), attrib, len, 0);\n        if (psvp) {\n            if (!asvp)\n                asvp = hv_fetch((HV*)SvRV(h), attrib, len, 1);\n            sv_setsv(*asvp, *psvp); /* copy attribute from parent to handle */\n        }\n        else {\n            if (!optional)\n                croak(\"dbih_setup_attrib(%s): %s not set and not in parent\",\n                    neatsvpv(h,0), attrib);\n        }\n    }\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 5) {\n        PerlIO *logfp = DBIc_LOGPIO(imp_xxh);\n        PerlIO_printf(logfp,\"    dbih_setup_attrib(%s, %s, %s)\",\n            neatsvpv(h,0), attrib, neatsvpv(parent,0));\n        if (!asvp)\n             PerlIO_printf(logfp,\" undef (not defined)\\n\");\n        else\n        if (SvOK(*asvp))\n             PerlIO_printf(logfp,\" %s (already defined)\\n\", neatsvpv(*asvp,0));\n        else PerlIO_printf(logfp,\" %s (copied from parent)\\n\", neatsvpv(*asvp,0));\n    }\n    if (read_only && asvp)\n        SvREADONLY_on(*asvp);\n    return asvp ? *asvp : &PL_sv_undef;\n}\n\n\nstatic SV *\ndbih_make_fdsv(SV *sth, const char *imp_class, STRLEN imp_size, const char *col_name)\n{\n    dTHX;\n    D_imp_sth(sth);\n    const STRLEN cn_len = strlen(col_name);\n    imp_fdh_t *imp_fdh;\n    SV *fdsv;\n    if (imp_size < sizeof(imp_fdh_t) || cn_len<10 || strNE(\"::fd\",&col_name[cn_len-4]))\n        croak(\"panic: dbih_makefdsv %s '%s' imp_size %ld invalid\",\n                imp_class, col_name, (long)imp_size);\n    if (DBIc_TRACE_LEVEL(imp_sth) >= 5)\n        PerlIO_printf(DBIc_LOGPIO(imp_sth),\"    dbih_make_fdsv(%s, %s, %ld, '%s')\\n\",\n                neatsvpv(sth,0), imp_class, (long)imp_size, col_name);\n    fdsv = dbih_make_com(sth, (imp_xxh_t*)imp_sth, imp_class, imp_size, cn_len+2, 0);\n    imp_fdh = (imp_fdh_t*)(void*)SvPVX(fdsv);\n    imp_fdh->com.col_name = ((char*)imp_fdh) + imp_size;\n    strcpy(imp_fdh->com.col_name, col_name);\n    return fdsv;\n}\n\n\nstatic SV *\ndbih_make_com(SV *p_h, imp_xxh_t *p_imp_xxh, const char *imp_class, STRLEN imp_size, STRLEN extra, SV* imp_templ)\n{\n    dTHX;\n    static const char *errmsg = \"Can't make DBI com handle for %s: %s\";\n    HV *imp_stash;\n    SV *dbih_imp_sv;\n    imp_xxh_t *imp;\n    int trace_level;\n    PERL_UNUSED_VAR(extra);\n\n    if ( (imp_stash = gv_stashpv(imp_class, FALSE)) == NULL)\n        croak(errmsg, imp_class, \"unknown package\");\n\n    if (imp_size == 0) {\n        /* get size of structure to allocate for common and imp specific data   */\n        const char *imp_size_name = mkvname(aTHX_ imp_stash, \"imp_data_size\", 0);\n        imp_size = SvIV(get_sv(imp_size_name, 0x05));\n        if (imp_size == 0) {\n            imp_size = sizeof(imp_sth_t);\n            if (sizeof(imp_dbh_t) > imp_size)\n                imp_size = sizeof(imp_dbh_t);\n            if (sizeof(imp_drh_t) > imp_size)\n                imp_size = sizeof(imp_drh_t);\n            imp_size += 4;\n        }\n    }\n\n    if (p_imp_xxh) {\n        trace_level = DBIc_TRACE_LEVEL(p_imp_xxh);\n    }\n    else {\n        dMY_CXT;\n        trace_level = DBIS_TRACE_LEVEL;\n    }\n    if (trace_level >= 5) {\n        dMY_CXT;\n        PerlIO_printf(DBILOGFP,\"    dbih_make_com(%s, %p, %s, %ld, %p) thr#%p\\n\",\n            neatsvpv(p_h,0), (void*)p_imp_xxh, imp_class, (long)imp_size, (void*)imp_templ, (void*)PERL_GET_THX);\n    }\n\n    if (imp_templ && SvOK(imp_templ)) {\n        U32  imp_templ_flags;\n        /* validate the supplied dbi_imp_data looks reasonable, */\n        if (SvCUR(imp_templ) != imp_size)\n            croak(\"Can't use dbi_imp_data of wrong size (%ld not %ld)\",\n                (long)SvCUR(imp_templ), (long)imp_size);\n\n        /* copy the whole template */\n        dbih_imp_sv = newSVsv(imp_templ);\n        imp = (imp_xxh_t*)(void*)SvPVX(dbih_imp_sv);\n\n        /* sanity checks on the supplied imp_data */\n        if (DBIc_TYPE(imp) != ((p_imp_xxh) ? DBIc_TYPE(p_imp_xxh)+1 :1) )\n            croak(\"Can't use dbi_imp_data from different type of handle\");\n        if (!DBIc_has(imp, DBIcf_IMPSET))\n            croak(\"Can't use dbi_imp_data that not from a setup handle\");\n\n        /* copy flags, zero out our imp_xxh struct, restore some flags */\n        imp_templ_flags = DBIc_FLAGS(imp);\n        switch ( (p_imp_xxh) ? DBIc_TYPE(p_imp_xxh)+1 : DBIt_DR ) {\n        case DBIt_DR: memzero((char*)imp, sizeof(imp_drh_t)); break;\n        case DBIt_DB: memzero((char*)imp, sizeof(imp_dbh_t)); break;\n        case DBIt_ST: memzero((char*)imp, sizeof(imp_sth_t)); break;\n        default:      croak(\"dbih_make_com dbi_imp_data bad h type\");\n        }\n        /* Only pass on DBIcf_IMPSET to indicate to driver that the imp */\n        /* structure has been copied and it doesn't need to reconnect.  */\n        /* Similarly DBIcf_ACTIVE is also passed along but isn't key.   */\n        DBIc_FLAGS(imp) = imp_templ_flags & (DBIcf_IMPSET|DBIcf_ACTIVE);\n    }\n    else {\n        dbih_imp_sv = newSV(imp_size); /* is grown to at least imp_size+1 */\n        imp = (imp_xxh_t*)(void*)SvPVX(dbih_imp_sv);\n        memzero((char*)imp, imp_size);\n        /* set up SV with SvCUR set ready for take_imp_data */\n        SvCUR_set(dbih_imp_sv, imp_size);\n        *SvEND(dbih_imp_sv) = '\\0';\n    }\n\n    if (p_imp_xxh) {\n        DBIc_DBISTATE(imp)  = DBIc_DBISTATE(p_imp_xxh);\n    }\n    else {\n        dMY_CXT;\n        DBIc_DBISTATE(imp)  = DBIS;\n    }\n    DBIc_IMP_STASH(imp) = imp_stash;\n\n    if (!p_h) {         /* only a driver (drh) has no parent    */\n        DBIc_PARENT_H(imp)    = &PL_sv_undef;\n        DBIc_PARENT_COM(imp)  = NULL;\n        DBIc_TYPE(imp)        = DBIt_DR;\n        DBIc_on(imp,DBIcf_WARN          /* set only here, children inherit      */\n                   |DBIcf_ACTIVE        /* drivers are 'Active' by default      */\n                   |DBIcf_AutoCommit    /* advisory, driver must manage this    */\n        );\n        DBIc_set(imp, DBIcf_PrintWarn, 1);\n    }\n    else {\n        DBIc_PARENT_H(imp)    = (SV*)SvREFCNT_inc(p_h); /* ensure it lives      */\n        DBIc_PARENT_COM(imp)  = p_imp_xxh;              /* shortcut for speed   */\n        DBIc_TYPE(imp)        = DBIc_TYPE(p_imp_xxh) + 1;\n        /* inherit some flags from parent and carry forward some from template  */\n        DBIc_FLAGS(imp)       = (DBIc_FLAGS(p_imp_xxh) & ~DBIcf_INHERITMASK)\n                              | (DBIc_FLAGS(imp) & (DBIcf_IMPSET|DBIcf_ACTIVE));\n        ++DBIc_KIDS(p_imp_xxh);\n    }\n#ifdef DBI_USE_THREADS\n    DBIc_THR_USER(imp) = PERL_GET_THX ;\n#endif\n\n    if (DBIc_TYPE(imp) == DBIt_ST) {\n        imp_sth_t *imp_sth = (imp_sth_t*)imp;\n        DBIc_ROW_COUNT(imp_sth)  = -1;\n    }\n\n    DBIc_COMSET_on(imp);        /* common data now set up               */\n\n    /* The implementor should DBIc_IMPSET_on(imp) when setting up       */\n    /* any private data which will need clearing/freeing later.         */\n\n    return dbih_imp_sv;\n}\n\n\nstatic void\ndbih_setup_handle(pTHX_ SV *orv, char *imp_class, SV *parent, SV *imp_datasv)\n{\n    SV *h;\n    char *errmsg = \"Can't setup DBI handle of %s to %s: %s\";\n    SV *dbih_imp_sv;\n    SV *dbih_imp_rv;\n    SV *dbi_imp_data = Nullsv;\n    SV **svp;\n    char imp_mem_name[300];\n    HV  *imp_mem_stash;\n    imp_xxh_t *imp;\n    imp_xxh_t *parent_imp;\n    int trace_level;\n\n    h      = dbih_inner(aTHX_ orv, \"dbih_setup_handle\");\n    parent = dbih_inner(aTHX_ parent, NULL);    /* check parent valid (& inner) */\n    if (parent) {\n        parent_imp = DBIh_COM(parent);\n        trace_level = DBIc_TRACE_LEVEL(parent_imp);\n    }\n    else {\n        dMY_CXT;\n        parent_imp = NULL;\n        trace_level = DBIS_TRACE_LEVEL;\n    }\n\n    if (trace_level >= 5) {\n        dMY_CXT;\n        PerlIO_printf(DBILOGFP,\"    dbih_setup_handle(%s=>%s, %s, %lx, %s)\\n\",\n            neatsvpv(orv,0), neatsvpv(h,0), imp_class, (long)parent, neatsvpv(imp_datasv,0));\n    }\n\n    if (mg_find(SvRV(h), DBI_MAGIC) != NULL)\n        croak(errmsg, neatsvpv(orv,0), imp_class, \"already a DBI (or ~magic) handle\");\n\n    strcpy(imp_mem_name, imp_class);\n    strcat(imp_mem_name, \"_mem\");\n    if ( (imp_mem_stash = gv_stashpv(imp_mem_name, FALSE)) == NULL)\n        croak(errmsg, neatsvpv(orv,0), imp_mem_name, \"unknown _mem package\");\n\n    if ((svp = hv_fetch((HV*)SvRV(h), \"dbi_imp_data\", 12, 0))) {\n        dbi_imp_data = *svp;\n        if (SvGMAGICAL(dbi_imp_data))  /* call FETCH via magic */\n            mg_get(dbi_imp_data);\n    }\n\n    DBI_LOCK;\n\n    dbih_imp_sv = dbih_make_com(parent, parent_imp, imp_class, 0, 0, dbi_imp_data);\n    imp = (imp_xxh_t*)(void*)SvPVX(dbih_imp_sv);\n\n    dbih_imp_rv = newRV_inc(dbih_imp_sv);       /* just needed for sv_bless */\n    sv_bless(dbih_imp_rv, imp_mem_stash);\n    sv_free(dbih_imp_rv);\n\n    DBIc_MY_H(imp) = (HV*)SvRV(orv);    /* take _copy_ of pointer, not new ref  */\n    DBIc_IMP_DATA(imp) = (imp_datasv) ? newSVsv(imp_datasv) : &PL_sv_undef;\n    _imp2com(imp, std.pid) = (U32)PerlProc_getpid();\n\n    if (DBIc_TYPE(imp) <= DBIt_ST) {\n        SV **tmp_svp;\n        /* Copy some attributes from parent if not defined locally and  */\n        /* also take address of attributes for speed of direct access.  */\n        /* parent is null for drh, in which case h must hold the values */\n#define COPY_PARENT(name,ro,opt) SvREFCNT_inc(dbih_setup_attrib(aTHX_ h,imp,(name),parent,ro,opt))\n#define DBIc_ATTR(imp, f) _imp2com(imp, attr.f)\n        /* XXX we should validate that these are the right type (refs etc)      */\n        DBIc_ATTR(imp, Err)      = COPY_PARENT(\"Err\",1,0);      /* scalar ref   */\n        DBIc_ATTR(imp, State)    = COPY_PARENT(\"State\",1,0);    /* scalar ref   */\n        DBIc_ATTR(imp, Errstr)   = COPY_PARENT(\"Errstr\",1,0);   /* scalar ref   */\n        DBIc_ATTR(imp, TraceLevel)=COPY_PARENT(\"TraceLevel\",0,0);/* scalar (int)*/\n        DBIc_ATTR(imp, FetchHashKeyName) = COPY_PARENT(\"FetchHashKeyName\",0,0); /* scalar ref */\n\n        if (parent) {\n            dbih_setup_attrib(aTHX_ h,imp,\"HandleSetErr\",parent,0,1);\n            dbih_setup_attrib(aTHX_ h,imp,\"HandleError\",parent,0,1);\n            dbih_setup_attrib(aTHX_ h,imp,\"ReadOnly\",parent,0,1);\n            dbih_setup_attrib(aTHX_ h,imp,\"Profile\",parent,0,1);\n\n            /* setup Callbacks from parents' ChildCallbacks */\n            if (DBIc_has(parent_imp, DBIcf_Callbacks)\n            && (tmp_svp = hv_fetch((HV*)SvRV(parent), \"Callbacks\", 9, 0))\n            && SvROK(*tmp_svp) && SvTYPE(SvRV(*tmp_svp)) == SVt_PVHV\n            && (tmp_svp = hv_fetch((HV*)SvRV(*tmp_svp), \"ChildCallbacks\", 14, 0))\n            && SvROK(*tmp_svp) && SvTYPE(SvRV(*tmp_svp)) == SVt_PVHV\n            ) {\n                /* XXX mirrors behaviour of dbih_set_attr_k() of Callbacks */\n                (void)hv_store((HV*)SvRV(h), \"Callbacks\", 9, newRV_inc(SvRV(*tmp_svp)), 0);\n                DBIc_set(imp, DBIcf_Callbacks, 1);\n            }\n\n            DBIc_LongReadLen(imp) = DBIc_LongReadLen(parent_imp);\n#ifdef sv_rvweaken\n            if (1) {\n                AV *av;\n                /* add weakref to new (outer) handle into parents ChildHandles array */\n                tmp_svp = hv_fetch((HV*)SvRV(parent), \"ChildHandles\", 12, 1);\n                if (!SvROK(*tmp_svp)) {\n                    SV *ChildHandles_rvav = newRV_noinc((SV*)newAV());\n                    sv_setsv(*tmp_svp, ChildHandles_rvav);\n                    sv_free(ChildHandles_rvav);\n                }\n                av = (AV*)SvRV(*tmp_svp);\n                av_push(av, (SV*)sv_rvweaken(newRV_inc((SV*)SvRV(orv))));\n                if (av_len(av) % 120 == 0) {\n                    /* time to do some housekeeping to remove dead handles */\n                    I32 i = av_len(av); /* 0 = 1 element */\n                    while (i-- >= 0) {\n                        SV *sv = av_shift(av);\n                        if (SvOK(sv))\n                            av_push(av, sv);\n                        else\n                           sv_free(sv);         /* keep it leak-free by Doru Petrescu pdoru.dbi@from.ro */\n                    }\n                }\n            }\n#endif\n        }\n        else {\n            DBIc_LongReadLen(imp) = DBIc_LongReadLen_init;\n        }\n\n        switch (DBIc_TYPE(imp)) {\n        case DBIt_DB:\n            /* cache _inner_ handle, but also see quick_FETCH */\n            (void)hv_store((HV*)SvRV(h), \"Driver\", 6, newRV_inc(SvRV(parent)), 0);\n            (void)hv_fetch((HV*)SvRV(h), \"Statement\", 9, 1); /* store writable undef */\n            break;\n        case DBIt_ST:\n            DBIc_NUM_FIELDS((imp_sth_t*)imp) = -1;\n            /* cache _inner_ handle, but also see quick_FETCH */\n            (void)hv_store((HV*)SvRV(h), \"Database\", 8, newRV_inc(SvRV(parent)), 0);\n            /* copy (alias) Statement from the sth up into the dbh      */\n            tmp_svp = hv_fetch((HV*)SvRV(h), \"Statement\", 9, 1);\n            (void)hv_store((HV*)SvRV(parent), \"Statement\", 9, SvREFCNT_inc(*tmp_svp), 0);\n            break;\n        }\n    }\n    else \n        die(\"panic: invalid DBIc_TYPE\");\n\n    /* Use DBI magic on inner handle to carry handle attributes         */\n    /* Note that we store the imp_sv in mg_obj, but as a shortcut,      */\n    /* also store a direct pointer to imp, aka PVX(dbih_imp_sv),        */\n    /* in mg_ptr (with mg_len set to null, so it wont be freed)         */\n    sv_magic(SvRV(h), dbih_imp_sv, DBI_MAGIC, (char*)imp, 0);\n    SvREFCNT_dec(dbih_imp_sv);  /* since sv_magic() incremented it      */\n    SvRMAGICAL_on(SvRV(h));     /* so DBI magic gets sv_clear'd ok      */\n\n    {\n    dMY_CXT; /* XXX would be nice to get rid of this */\n    DBI_SET_LAST_HANDLE(h);\n    }\n\n    if (1) {\n        /* This is a hack to work-around the fast but poor way old versions of\n         * DBD::Oracle (and possibly other drivers) check for a valid handle\n         * using (SvMAGIC(SvRV(h)))->mg_type == 'P'). That doesn't work now\n         * because the weakref magic is inserted ahead of the tie magic.\n         * So here we swap the tie and weakref magic so the tie comes first.\n         */\n        MAGIC *tie_mg = mg_find(SvRV(orv),'P');\n        MAGIC *first  = SvMAGIC(SvRV(orv));\n        if (tie_mg && first->mg_moremagic == tie_mg && !tie_mg->mg_moremagic) {\n            MAGIC *next = tie_mg->mg_moremagic;\n            SvMAGIC(SvRV(orv)) = tie_mg;\n            tie_mg->mg_moremagic = first;\n            first->mg_moremagic = next;\n        }\n    }\n\n    DBI_UNLOCK;\n}\n\n\nstatic void\ndbih_dumphandle(pTHX_ SV *h, const char *msg, int level)\n{\n    D_imp_xxh(h);\n    if (level >= 9) {\n        sv_dump(h);\n    }\n    dbih_dumpcom(aTHX_ imp_xxh, msg, level);\n}\n\nstatic int\ndbih_dumpcom(pTHX_ imp_xxh_t *imp_xxh, const char *msg, int level)\n{\n    dMY_CXT;\n    SV *flags = sv_2mortal(newSVpv(\"\",0));\n    SV *inner;\n    static const char pad[] = \"      \";\n    if (!msg)\n        msg = \"dbih_dumpcom\";\n    PerlIO_printf(DBILOGFP,\"    %s (%sh 0x%lx, com 0x%lx, imp %s):\\n\",\n        msg, dbih_htype_name(DBIc_TYPE(imp_xxh)),\n        (long)DBIc_MY_H(imp_xxh), (long)imp_xxh,\n        (PL_dirty) ? \"global destruction\" : HvNAME(DBIc_IMP_STASH(imp_xxh)));\n    if (DBIc_COMSET(imp_xxh))                   sv_catpv(flags,\"COMSET \");\n    if (DBIc_IMPSET(imp_xxh))                   sv_catpv(flags,\"IMPSET \");\n    if (DBIc_ACTIVE(imp_xxh))                   sv_catpv(flags,\"Active \");\n    if (DBIc_WARN(imp_xxh))                     sv_catpv(flags,\"Warn \");\n    if (DBIc_COMPAT(imp_xxh))                   sv_catpv(flags,\"CompatMode \");\n    if (DBIc_is(imp_xxh, DBIcf_ChopBlanks))     sv_catpv(flags,\"ChopBlanks \");\n    if (DBIc_is(imp_xxh, DBIcf_HandleSetErr))   sv_catpv(flags,\"HandleSetErr \");\n    if (DBIc_is(imp_xxh, DBIcf_HandleError))    sv_catpv(flags,\"HandleError \");\n    if (DBIc_is(imp_xxh, DBIcf_RaiseError))     sv_catpv(flags,\"RaiseError \");\n    if (DBIc_is(imp_xxh, DBIcf_PrintError))     sv_catpv(flags,\"PrintError \");\n    if (DBIc_is(imp_xxh, DBIcf_PrintWarn))      sv_catpv(flags,\"PrintWarn \");\n    if (DBIc_is(imp_xxh, DBIcf_ShowErrorStatement))     sv_catpv(flags,\"ShowErrorStatement \");\n    if (DBIc_is(imp_xxh, DBIcf_AutoCommit))     sv_catpv(flags,\"AutoCommit \");\n    if (DBIc_is(imp_xxh, DBIcf_BegunWork))      sv_catpv(flags,\"BegunWork \");\n    if (DBIc_is(imp_xxh, DBIcf_LongTruncOk))    sv_catpv(flags,\"LongTruncOk \");\n    if (DBIc_is(imp_xxh, DBIcf_MultiThread))    sv_catpv(flags,\"MultiThread \");\n    if (DBIc_is(imp_xxh, DBIcf_TaintIn))        sv_catpv(flags,\"TaintIn \");\n    if (DBIc_is(imp_xxh, DBIcf_TaintOut))       sv_catpv(flags,\"TaintOut \");\n    if (DBIc_is(imp_xxh, DBIcf_Profile))        sv_catpv(flags,\"Profile \");\n    if (DBIc_is(imp_xxh, DBIcf_Callbacks))      sv_catpv(flags,\"Callbacks \");\n    PerlIO_printf(DBILOGFP,\"%s FLAGS 0x%lx: %s\\n\", pad, (long)DBIc_FLAGS(imp_xxh), SvPV_nolen(flags));\n    if (SvOK(DBIc_ERR(imp_xxh)))\n        PerlIO_printf(DBILOGFP,\"%s ERR %s\\n\",   pad, neatsvpv((SV*)DBIc_ERR(imp_xxh),0));\n    if (SvOK(DBIc_ERR(imp_xxh)))\n        PerlIO_printf(DBILOGFP,\"%s ERRSTR %s\\n\",        pad, neatsvpv((SV*)DBIc_ERRSTR(imp_xxh),0));\n    PerlIO_printf(DBILOGFP,\"%s PARENT %s\\n\",    pad, neatsvpv((SV*)DBIc_PARENT_H(imp_xxh),0));\n    PerlIO_printf(DBILOGFP,\"%s KIDS %ld (%ld Active)\\n\", pad,\n                    (long)DBIc_KIDS(imp_xxh), (long)DBIc_ACTIVE_KIDS(imp_xxh));\n    if (DBIc_IMP_DATA(imp_xxh) && SvOK(DBIc_IMP_DATA(imp_xxh)))\n        PerlIO_printf(DBILOGFP,\"%s IMP_DATA %s\\n\", pad, neatsvpv(DBIc_IMP_DATA(imp_xxh),0));\n    if (DBIc_LongReadLen(imp_xxh) != DBIc_LongReadLen_init)\n        PerlIO_printf(DBILOGFP,\"%s LongReadLen %ld\\n\", pad, (long)DBIc_LongReadLen(imp_xxh));\n\n    if (DBIc_TYPE(imp_xxh) == DBIt_ST) {\n        const imp_sth_t *imp_sth = (imp_sth_t*)imp_xxh;\n        PerlIO_printf(DBILOGFP,\"%s NUM_OF_FIELDS %d\\n\", pad, DBIc_NUM_FIELDS(imp_sth));\n        PerlIO_printf(DBILOGFP,\"%s NUM_OF_PARAMS %d\\n\", pad, DBIc_NUM_PARAMS(imp_sth));\n    }\n    inner = dbih_inner(aTHX_ (SV*)DBIc_MY_H(imp_xxh), msg);\n    if (!inner || !SvROK(inner))\n        return 1;\n    if (DBIc_TYPE(imp_xxh) <= DBIt_DB) {\n        SV **svp = hv_fetch((HV*)SvRV(inner), \"CachedKids\", 10, 0);\n        if (svp && SvROK(*svp) && SvTYPE(SvRV(*svp)) == SVt_PVHV) {\n            HV *hv = (HV*)SvRV(*svp);\n            PerlIO_printf(DBILOGFP,\"%s CachedKids %d\\n\", pad, (int)HvKEYS(hv));\n        }\n    }\n    if (level > 0) {\n        SV* value;\n        char *key;\n        I32   keylen;\n        PerlIO_printf(DBILOGFP,\"%s cached attributes:\\n\", pad);\n        while ( (value = hv_iternextsv((HV*)SvRV(inner), &key, &keylen)) ) {\n            PerlIO_printf(DBILOGFP,\"%s   '%s' => %s\\n\", pad, key, neatsvpv(value,0));\n        }\n    }\n    else if (DBIc_TYPE(imp_xxh) == DBIt_DB) {\n        SV **svp = hv_fetch((HV*)SvRV(inner), \"Name\", 4, 0);\n        if (svp && SvOK(*svp))\n            PerlIO_printf(DBILOGFP,\"%s Name %s\\n\", pad, neatsvpv(*svp,0));\n    }\n    else if (DBIc_TYPE(imp_xxh) == DBIt_ST) {\n        SV **svp = hv_fetch((HV*)SvRV(inner), \"Statement\", 9, 0);\n        if (svp && SvOK(*svp))\n            PerlIO_printf(DBILOGFP,\"%s Statement %s\\n\", pad, neatsvpv(*svp,0));\n    }\n    return 1;\n}\n\n\nstatic void\ndbih_clearcom(imp_xxh_t *imp_xxh)\n{\n    dTHX;\n    dTHR;\n    int dump = FALSE;\n    int debug = DBIc_TRACE_LEVEL(imp_xxh);\n    int auto_dump = (debug >= 6);\n    imp_xxh_t * const parent_xxh = DBIc_PARENT_COM(imp_xxh);\n    /* Note that we're very much on our own here. DBIc_MY_H(imp_xxh) almost     */\n    /* certainly points to memory which has been freed. Don't use it!           */\n\n    /* --- pre-clearing sanity checks --- */\n\n#ifdef DBI_USE_THREADS\n    if (DBIc_THR_USER(imp_xxh) != my_perl) { /* don't clear handle that belongs to another thread */\n        if (debug >= 3) {\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"    skipped dbih_clearcom: DBI handle (type=%d, %s) is owned by thread %p not current thread %p\\n\",\n                  DBIc_TYPE(imp_xxh), HvNAME(DBIc_IMP_STASH(imp_xxh)), (void*)DBIc_THR_USER(imp_xxh), (void*)my_perl) ;\n            PerlIO_flush(DBIc_LOGPIO(imp_xxh));\n        }\n        return;\n    }\n#endif\n\n    if (!DBIc_COMSET(imp_xxh)) {        /* should never happen  */\n        dbih_dumpcom(aTHX_ imp_xxh, \"dbih_clearcom: DBI handle already cleared\", 0);\n        return;\n    }\n\n    if (auto_dump)\n        dbih_dumpcom(aTHX_ imp_xxh,\"DESTROY (dbih_clearcom)\", 0);\n\n    if (!PL_dirty) {\n\n        if (DBIc_ACTIVE(imp_xxh)) {     /* bad news, potentially        */\n            /* warn for sth, warn for dbh only if it has active sth or isn't AutoCommit */\n            if (DBIc_TYPE(imp_xxh) >= DBIt_ST\n            || (DBIc_ACTIVE_KIDS(imp_xxh) || !DBIc_has(imp_xxh, DBIcf_AutoCommit))\n            ) {\n                warn(\"DBI %s handle 0x%lx cleared whilst still active\",\n                        dbih_htype_name(DBIc_TYPE(imp_xxh)), (unsigned long)DBIc_MY_H(imp_xxh));\n                dump = TRUE;\n            }\n        }\n\n        /* check that the implementor has done its own housekeeping     */\n        if (DBIc_IMPSET(imp_xxh)) {\n            warn(\"DBI %s handle 0x%lx has uncleared implementors data\",\n                    dbih_htype_name(DBIc_TYPE(imp_xxh)), (unsigned long)DBIc_MY_H(imp_xxh));\n            dump = TRUE;\n        }\n\n        if (DBIc_KIDS(imp_xxh)) {\n            warn(\"DBI %s handle 0x%lx has %d uncleared child handles\",\n                    dbih_htype_name(DBIc_TYPE(imp_xxh)),\n                    (unsigned long)DBIc_MY_H(imp_xxh), (int)DBIc_KIDS(imp_xxh));\n            dump = TRUE;\n        }\n    }\n\n    if (dump && !auto_dump) /* else was already dumped above */\n        dbih_dumpcom(aTHX_ imp_xxh, \"dbih_clearcom\", 0);\n\n    /* --- pre-clearing adjustments --- */\n\n    if (!PL_dirty) {\n        if (parent_xxh) {\n            if (DBIc_ACTIVE(imp_xxh)) /* see also DBIc_ACTIVE_off */\n                --DBIc_ACTIVE_KIDS(parent_xxh);\n            --DBIc_KIDS(parent_xxh);\n        }\n    }\n\n    /* --- clear fields (may invoke object destructors) ---     */\n\n    if (DBIc_TYPE(imp_xxh) == DBIt_ST) {\n        imp_sth_t *imp_sth = (imp_sth_t*)imp_xxh;\n        sv_free((SV*)DBIc_FIELDS_AV(imp_sth));\n    }\n\n    sv_free(DBIc_IMP_DATA(imp_xxh));    /* do this first        */\n    if (DBIc_TYPE(imp_xxh) <= DBIt_ST) {        /* DBIt_FD doesn't have attr */\n        sv_free(_imp2com(imp_xxh, attr.TraceLevel));\n        sv_free(_imp2com(imp_xxh, attr.State));\n        sv_free(_imp2com(imp_xxh, attr.Err));\n        sv_free(_imp2com(imp_xxh, attr.Errstr));\n        sv_free(_imp2com(imp_xxh, attr.FetchHashKeyName));\n    }\n\n\n    sv_free((SV*)DBIc_PARENT_H(imp_xxh));       /* do this last         */\n\n    DBIc_COMSET_off(imp_xxh);\n\n    if (debug >= 4)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"    dbih_clearcom 0x%lx (com 0x%lx, type %d) done.\\n\\n\",\n                (long)DBIc_MY_H(imp_xxh), (long)imp_xxh, DBIc_TYPE(imp_xxh));\n}\n\n\n/* --- Functions for handling field buffer arrays ---           */\n\nstatic AV *\ndbih_setup_fbav(imp_sth_t *imp_sth)\n{\n    /*  Usually called to setup the row buffer for new sth.\n     *  Also called if the value of NUM_OF_FIELDS is altered,\n     *  in which case it adjusts the row buffer to match NUM_OF_FIELDS.\n     */\n    dTHX;\n    I32 i = DBIc_NUM_FIELDS(imp_sth);\n    AV *av = DBIc_FIELDS_AV(imp_sth);\n\n    if (i < 0)\n        i = 0;\n\n    if (av) {\n        if (av_len(av)+1 == i)  /* is existing array the right size? */\n            return av;\n        /* we need to adjust the size of the array */\n        if (DBIc_TRACE_LEVEL(imp_sth) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_sth),\"    dbih_setup_fbav realloc from %ld to %ld fields\\n\", (long)(av_len(av)+1), (long)i);\n        SvREADONLY_off(av);\n        if (i < av_len(av)+1) /* trim to size if too big */\n            av_fill(av, i-1);\n    }\n    else {\n        if (DBIc_TRACE_LEVEL(imp_sth) >= 5)\n            PerlIO_printf(DBIc_LOGPIO(imp_sth),\"    dbih_setup_fbav alloc for %ld fields\\n\", (long)i);\n        av = newAV();\n        DBIc_FIELDS_AV(imp_sth) = av;\n\n        /* row_count will need to be manually reset by the driver if the        */\n        /* sth is re-executed (since this code won't get rerun)         */\n        DBIc_ROW_COUNT(imp_sth) = 0;\n    }\n\n    /* load array with writeable SV's. Do this backwards so     */\n    /* the array only gets extended once.                       */\n    while(i--)                  /* field 1 stored at index 0    */\n        av_store(av, i, newSV(0));\n    if (DBIc_TRACE_LEVEL(imp_sth) >= 6)\n        PerlIO_printf(DBIc_LOGPIO(imp_sth),\"    dbih_setup_fbav now %ld fields\\n\", (long)(av_len(av)+1));\n    SvREADONLY_on(av);          /* protect against shift @$row etc */\n    return av;\n}\n\n\nstatic AV *\ndbih_get_fbav(imp_sth_t *imp_sth)\n{\n    AV *av;\n\n    if ( (av = DBIc_FIELDS_AV(imp_sth)) == Nullav) {\n        av = dbih_setup_fbav(imp_sth);\n    }\n    else {\n        dTHX;\n        int i = av_len(av) + 1;\n        if (i != DBIc_NUM_FIELDS(imp_sth)) {\n            /*SV *sth = dbih_inner(aTHX_ (SV*)DBIc_MY_H(imp_sth), \"_get_fbav\");*/\n            /* warn via PrintWarn */\n            set_err_char(SvRV(DBIc_MY_H(imp_sth)), (imp_xxh_t*)imp_sth,\n                    \"0\", 0, \"Number of row fields inconsistent with NUM_OF_FIELDS (driver bug)\", \"\", \"_get_fbav\");\n            /*\n            DBIc_NUM_FIELDS(imp_sth) = i;\n            hv_delete((HV*)SvRV(sth), \"NUM_OF_FIELDS\", 13, G_DISCARD);\n            */\n        }\n        /* don't let SvUTF8 flag persist from one row to the next   */\n        /* (only affects drivers that use sv_setpv, but most XS do) */\n        /* XXX turn into option later (force on/force off/ignore) */\n        while(i--)                  /* field 1 stored at index 0    */\n            SvUTF8_off(AvARRAY(av)[i]);\n    }\n\n    if (DBIc_is(imp_sth, DBIcf_TaintOut)) {\n        dTHX;\n        dTHR;\n        TAINT;  /* affects sv_setsv()'s called within same perl statement */\n    }\n\n    /* XXX fancy stuff to happen here later (re scrolling etc)  */\n    ++DBIc_ROW_COUNT(imp_sth);\n    return av;\n}\n\n\nstatic int\ndbih_sth_bind_col(SV *sth, SV *col, SV *ref, SV *attribs)\n{\n    dTHX;\n    D_imp_sth(sth);\n    AV *av;\n    int idx = SvIV(col);\n    int fields = DBIc_NUM_FIELDS(imp_sth);\n\n    if (fields <= 0) {\n        PERL_UNUSED_VAR(attribs);\n        croak(\"Statement has no result columns to bind%s\",\n            DBIc_ACTIVE(imp_sth)\n                ? \"\" : \" (perhaps you need to successfully call execute first, or again)\");\n    }\n\n    if ( (av = DBIc_FIELDS_AV(imp_sth)) == Nullav)\n        av = dbih_setup_fbav(imp_sth);\n\n    if (DBIc_TRACE_LEVEL(imp_sth) >= 5)\n        PerlIO_printf(DBIc_LOGPIO(imp_sth),\"    dbih_sth_bind_col %s => %s %s\\n\",\n                neatsvpv(col,0), neatsvpv(ref,0), neatsvpv(attribs,0));\n\n    if (idx < 1 || idx > fields)\n        croak(\"bind_col: column %d is not a valid column (1..%d)\",\n                        idx, fields);\n\n    if (!SvOK(ref) && SvREADONLY(ref)) {   /* binding to literal undef */\n        /* presumably the call is just setting the TYPE or other atribs */\n        /* but this default method ignores attribs, so we just return   */\n        return 1;\n    }\n\n    /* Write this as > SVt_PVMG because in 5.8.x the next type */\n    /* is SVt_PVBM, whereas in 5.9.x it's SVt_PVGV.            */\n    if (!SvROK(ref) || SvTYPE(SvRV(ref)) > SVt_PVMG) /* XXX LV */\n        croak(\"Can't %s->bind_col(%s, %s,...), need a reference to a scalar\",\n                neatsvpv(sth,0), neatsvpv(col,0), neatsvpv(ref,0));\n\n    /* use supplied scalar as storage for this column */\n    SvREADONLY_off(av);\n    av_store(av, idx-1, SvREFCNT_inc(SvRV(ref)) );\n    SvREADONLY_on(av);\n    return 1;\n}\n\n\nstatic int\nquote_type(int sql_type, int p, int s, int *t, void *v)\n{\n    /* Returns true if type should be bound as a number else    */\n    /* false implying that binding as a string should be okay.  */\n    /* The true value is either SQL_INTEGER or SQL_DOUBLE which */\n    /* can be used as a hint if desired.                        */\n    (void)p;\n    (void)s;\n    (void)t;\n    (void)v;\n    /* looks like it's never been used, and doesn't make much sense anyway */\n    warn(\"Use of DBI internal bind_as_num/quote_type function is deprecated\");\n    switch(sql_type) {\n    case SQL_INTEGER:\n    case SQL_SMALLINT:\n    case SQL_TINYINT:\n    case SQL_BIGINT:\n        return 0;\n    case SQL_FLOAT:\n    case SQL_REAL:\n    case SQL_DOUBLE:\n        return 0;\n    case SQL_NUMERIC:\n    case SQL_DECIMAL:\n        return 0;       /* bind as string to attempt to retain precision */\n    }\n    return 1;\n}\n\n\n/* Convert a simple string representation of a value into a more specific\n * perl type based on an sql_type value.\n * The semantics of SQL standard TYPE values are interpreted _very_ loosely\n * on the basis of \"be liberal in what you accept and let's throw in some\n * extra semantics while we're here\" :)\n * Returns:\n *  -2: sql_type isn't handled, value unchanged\n *  -1: sv is undef, value unchanged\n *   0: sv couldn't be cast cleanly and DBIstcf_STRICT was used\n *   1: sv couldn't be cast cleanly and DBIstcf_STRICT was not used\n *   2: sv was cast ok\n */\n\nint\nsql_type_cast_svpv(pTHX_ SV *sv, int sql_type, U32 flags, void *v)\n{\n    int cast_ok = 0;\n    int grok_flags;\n    UV uv;\n\n    /* do nothing for undef (NULL) or non-string values */\n    if (!sv || !SvOK(sv))\n        return -1;\n\n    switch(sql_type) {\n\n    default:\n        return -2;   /* not a recognised SQL TYPE, value unchanged */\n\n    case SQL_INTEGER:\n        /* sv_2iv is liberal, may return SvIV, SvUV, or SvNV */\n        sv_2iv(sv);\n        /* SvNOK will be set if value is out of range for IV/UV.\n         * SvIOK should be set but won't if sv is not numeric (in which\n         * case perl would have warn'd already if -w or warnings are in effect)\n         */\n        cast_ok = (SvIOK(sv) && !SvNOK(sv));\n        break;\n\n    case SQL_DOUBLE:\n        sv_2nv(sv);\n        /* SvNOK should be set but won't if sv is not numeric (in which\n         * case perl would have warn'd already if -w or warnings are in effect)\n         */\n        cast_ok = SvNOK(sv);\n        break;\n\n    /* caller would like IV else UV else NV */\n    /* else no error and sv is untouched */\n    case SQL_NUMERIC:\n        /* based on the code in perl's toke.c */\n        uv = 0;\n        grok_flags = grok_number(SvPVX(sv), SvCUR(sv), &uv);\n        cast_ok = 1;\n        if (grok_flags == IS_NUMBER_IN_UV) { /* +ve int */\n            if (uv <= IV_MAX)   /* prefer IV over UV */\n                 sv_2iv(sv);\n            else sv_2uv(sv);\n        }\n        else if (grok_flags == (IS_NUMBER_IN_UV | IS_NUMBER_NEG)\n            && uv <= IV_MAX\n        ) {\n            sv_2iv(sv);\n        }\n        else if (grok_flags) { /* is numeric */\n            sv_2nv(sv);\n        }\n        else\n            cast_ok = 0;\n        break;\n\n#if 0 /* XXX future possibilities */\n    case SQL_BIGINT:    /* use Math::BigInt if too large for IV/UV */\n#endif\n    }\n\n    if (cast_ok) {\n\n        if (flags & DBIstcf_DISCARD_STRING\n        && SvNIOK(sv)  /* we set a numeric value */\n        && SvPVX(sv)   /* we have a buffer to discard */\n        ) {\n            SvOOK_off(sv);\n            sv_force_normal(sv);\n            if (SvLEN(sv))\n                Safefree(SvPVX(sv));\n            SvPOK_off(sv);\n            SvPV_set(sv, NULL);\n            SvLEN_set(sv, 0);\n            SvCUR_set(sv, 0);\n        }\n    }\n\n    if (cast_ok)\n        return 2;\n    else if (flags & DBIstcf_STRICT)\n        return 0;\n    else return 1;\n}\n\n\n\n/* --- Generic Handle Attributes (for all handle types) ---     */\n\nstatic int\ndbih_set_attr_k(SV *h, SV *keysv, int dbikey, SV *valuesv)\n{\n    dTHX;\n    dTHR;\n    D_imp_xxh(h);\n    STRLEN keylen;\n    const char  *key = SvPV(keysv, keylen);\n    const int    htype = DBIc_TYPE(imp_xxh);\n    int    on = (SvTRUE(valuesv));\n    int    internal = 1; /* DBIh_IN_PERL_DBD(imp_xxh); -- for DBD's in perl */\n    int    cacheit = 0;\n    (void)dbikey;\n\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 3)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"    STORE %s %s => %s\\n\",\n                neatsvpv(h,0), neatsvpv(keysv,0), neatsvpv(valuesv,0));\n\n    if (internal && strEQ(key, \"Active\")) {\n        if (on) {\n            D_imp_sth(h);\n            DBIc_ACTIVE_on(imp_xxh);\n            /* for pure-perl drivers on second and subsequent   */\n            /* execute()'s, else row count keeps rising.        */\n            if (htype==DBIt_ST && DBIc_FIELDS_AV(imp_sth))\n                DBIc_ROW_COUNT(imp_sth) = 0;\n        }\n        else {\n            DBIc_ACTIVE_off(imp_xxh);\n        }\n    }\n    else if (strEQ(key, \"FetchHashKeyName\")) {\n        if (htype >= DBIt_ST)\n            croak(\"Can't set FetchHashKeyName for a statement handle, set in parent before prepare()\");\n        cacheit = 1;    /* just save it */\n    }\n    else if (strEQ(key, \"CompatMode\")) {\n        (on) ? DBIc_COMPAT_on(imp_xxh) : DBIc_COMPAT_off(imp_xxh);\n    }\n    else if (strEQ(key, \"Warn\")) {\n        (on) ? DBIc_WARN_on(imp_xxh) : DBIc_WARN_off(imp_xxh);\n    }\n    else if (strEQ(key, \"AutoInactiveDestroy\")) {\n        (on) ? DBIc_AIADESTROY_on(imp_xxh) : DBIc_AIADESTROY_off(imp_xxh);\n    }\n    else if (strEQ(key, \"InactiveDestroy\")) {\n        (on) ? DBIc_IADESTROY_on(imp_xxh) : DBIc_IADESTROY_off(imp_xxh);\n    }\n    else if (strEQ(key, \"RootClass\")) {\n        cacheit = 1;    /* just save it */\n    }\n    else if (strEQ(key, \"RowCacheSize\")) {\n        cacheit = 0;    /* ignore it */\n    }\n    else if (strEQ(key, \"Executed\")) {\n        DBIc_set(imp_xxh, DBIcf_Executed, on);\n    }\n    else if (strEQ(key, \"ChopBlanks\")) {\n        DBIc_set(imp_xxh, DBIcf_ChopBlanks, on);\n    }\n    else if (strEQ(key, \"ErrCount\")) {\n        DBIc_ErrCount(imp_xxh) = SvUV(valuesv);\n    }\n    else if (strEQ(key, \"LongReadLen\")) {\n        if (SvNV(valuesv) < 0 || SvNV(valuesv) > MAX_LongReadLen)\n            croak(\"Can't set LongReadLen < 0 or > %ld\",MAX_LongReadLen);\n        DBIc_LongReadLen(imp_xxh) = SvIV(valuesv);\n        cacheit = 1;    /* save it for clone */\n    }\n    else if (strEQ(key, \"LongTruncOk\")) {\n        DBIc_set(imp_xxh,DBIcf_LongTruncOk, on);\n    }\n    else if (strEQ(key, \"RaiseError\")) {\n        DBIc_set(imp_xxh,DBIcf_RaiseError, on);\n    }\n    else if (strEQ(key, \"PrintError\")) {\n        DBIc_set(imp_xxh,DBIcf_PrintError, on);\n    }\n    else if (strEQ(key, \"PrintWarn\")) {\n        DBIc_set(imp_xxh,DBIcf_PrintWarn, on);\n    }\n    else if (strEQ(key, \"HandleError\")) {\n        if ( on && (!SvROK(valuesv) || (SvTYPE(SvRV(valuesv)) != SVt_PVCV)) ) {\n            croak(\"Can't set %s to '%s'\", \"HandleError\", neatsvpv(valuesv,0));\n        }\n        DBIc_set(imp_xxh,DBIcf_HandleError, on);\n        cacheit = 1; /* child copy setup by dbih_setup_handle() */\n    }\n    else if (strEQ(key, \"HandleSetErr\")) {\n        if ( on && (!SvROK(valuesv) || (SvTYPE(SvRV(valuesv)) != SVt_PVCV)) ) {\n            croak(\"Can't set %s to '%s'\",\"HandleSetErr\",neatsvpv(valuesv,0));\n        }\n        DBIc_set(imp_xxh,DBIcf_HandleSetErr, on);\n        cacheit = 1; /* child copy setup by dbih_setup_handle() */\n    }\n    else if (strEQ(key, \"ChildHandles\")) {\n        if ( on && (!SvROK(valuesv) || (SvTYPE(SvRV(valuesv)) != SVt_PVAV)) ) {\n            croak(\"Can't set %s to '%s'\", \"ChildHandles\", neatsvpv(valuesv,0));\n        }\n        cacheit = 1; /* just save it in the hash */\n    }\n    else if (strEQ(key, \"Profile\")) {\n        static const char profile_class[] = \"DBI::Profile\";\n        if (on && (!SvROK(valuesv) || (SvTYPE(SvRV(valuesv)) != SVt_PVHV)) ) {\n            /* not a hash ref so use DBI::Profile to work out what to do */\n            dTHR;\n            dSP;\n            I32 returns;\n            TAINT_NOT; /* the require is presumed innocent till proven guilty */\n            perl_require_pv(\"DBI/Profile.pm\");\n            if (SvTRUE(ERRSV)) {\n                warn(\"Can't load %s: %s\", profile_class, SvPV_nolen(ERRSV));\n                valuesv = &PL_sv_undef;\n            }\n            else {\n                PUSHMARK(SP);\n                XPUSHs(sv_2mortal(newSVpv(profile_class,0)));\n                XPUSHs(valuesv);\n                PUTBACK;\n                returns = call_method(\"_auto_new\", G_SCALAR);\n                if (returns != 1)\n                    croak(\"%s _auto_new\", profile_class);\n                SPAGAIN;\n                valuesv = POPs;\n                PUTBACK;\n            }\n            on = SvTRUE(valuesv); /* in case it returns undef */\n        }\n        if (on && !sv_isobject(valuesv)) {\n            /* not blessed already - so default to DBI::Profile */\n            HV *stash;\n            perl_require_pv(profile_class);\n            stash = gv_stashpv(profile_class, GV_ADDWARN);\n            sv_bless(valuesv, stash);\n        }\n        DBIc_set(imp_xxh,DBIcf_Profile, on);\n        cacheit = 1; /* child copy setup by dbih_setup_handle() */\n    }\n    else if (strEQ(key, \"ShowErrorStatement\")) {\n        DBIc_set(imp_xxh,DBIcf_ShowErrorStatement, on);\n    }\n    else if (strEQ(key, \"MultiThread\") && internal) {\n        /* here to allow pure-perl drivers to set MultiThread */\n        DBIc_set(imp_xxh,DBIcf_MultiThread, on);\n        if (on && DBIc_WARN(imp_xxh)) {\n            warn(\"MultiThread support not yet implemented in DBI\");\n        }\n    }\n    else if (strEQ(key, \"Taint\")) {\n        /* 'Taint' is a shortcut for both in and out mode */\n        DBIc_set(imp_xxh,DBIcf_TaintIn|DBIcf_TaintOut, on);\n    }\n    else if (strEQ(key, \"TaintIn\")) {\n        DBIc_set(imp_xxh,DBIcf_TaintIn, on);\n    }\n    else if (strEQ(key, \"TaintOut\")) {\n        DBIc_set(imp_xxh,DBIcf_TaintOut, on);\n    }\n    else if (htype<=DBIt_DB && keylen==10 && strEQ(key, \"CachedKids\")\n        /* only allow hash refs */\n        && SvROK(valuesv) && SvTYPE(SvRV(valuesv))==SVt_PVHV\n    ) {\n        cacheit = 1;\n    }\n    else if (keylen==9 && strEQ(key, \"Callbacks\")) {\n        if ( on && (!SvROK(valuesv) || (SvTYPE(SvRV(valuesv)) != SVt_PVHV)) )\n            croak(\"Can't set Callbacks to '%s'\",neatsvpv(valuesv,0));\n        /* see also dbih_setup_handle for ChildCallbacks handling */\n        DBIc_set(imp_xxh, DBIcf_Callbacks, on);\n        cacheit = 1;\n    }\n    else if (htype<=DBIt_DB && keylen==10 && strEQ(key, \"AutoCommit\")) {\n        /* driver should have intercepted this and either handled it    */\n        /* or set valuesv to either the 'magic' on or off value.        */\n        if (SvIV(valuesv) != -900 && SvIV(valuesv) != -901)\n            croak(\"DBD driver has not implemented the AutoCommit attribute\");\n        DBIc_set(imp_xxh,DBIcf_AutoCommit, (SvIV(valuesv)==-901));\n    }\n    else if (htype==DBIt_DB && keylen==9 && strEQ(key, \"BegunWork\")) {\n        DBIc_set(imp_xxh,DBIcf_BegunWork, on);\n    }\n    else if (keylen==10  && strEQ(key, \"TraceLevel\")) {\n        set_trace(h, valuesv, Nullsv);\n    }\n    else if (keylen==9  && strEQ(key, \"TraceFile\")) { /* XXX undocumented and readonly */\n        set_trace_file(valuesv);\n    }\n    else if (htype==DBIt_ST && strEQ(key, \"NUM_OF_FIELDS\")) {\n        D_imp_sth(h);\n        int new_num_fields = (SvOK(valuesv)) ? SvIV(valuesv) : -1;\n        DBIc_NUM_FIELDS(imp_sth) = new_num_fields;\n        if (DBIc_FIELDS_AV(imp_sth)) { /* modify existing fbav */\n            dbih_setup_fbav(imp_sth);\n        }\n        cacheit = 1;\n    }\n    else if (htype==DBIt_ST && strEQ(key, \"NUM_OF_PARAMS\")) {\n        D_imp_sth(h);\n        DBIc_NUM_PARAMS(imp_sth) = SvIV(valuesv);\n        cacheit = 1;\n    }\n    /* these are here due to clone() needing to set attribs through a public api */\n    else if (htype<=DBIt_DB && (strEQ(key, \"Name\")\n                            || strEQ(key,\"ImplementorClass\")\n                            || strEQ(key,\"ReadOnly\")\n                            || strEQ(key,\"Statement\")\n                            || strEQ(key,\"Username\")\n        /* these are here for backwards histerical raisons */\n        || strEQ(key,\"USER\") || strEQ(key,\"CURRENT_USER\")\n    ) ) {\n        cacheit = 1;\n    }\n    else {      /* XXX should really be an event ? */\n        if (isUPPER(*key)) {\n            char *msg = \"Can't set %s->{%s}: unrecognised attribute name or invalid value%s\";\n            char *hint = \"\";\n            if (strEQ(key, \"NUM_FIELDS\"))\n                hint = \", perhaps you meant NUM_OF_FIELDS\";\n            warn(msg, neatsvpv(h,0), key, hint);\n            return FALSE;       /* don't store it */\n        }\n        /* Allow private_* attributes to be stored in the cache.        */\n        /* This is designed to make life easier for people subclassing  */\n        /* the DBI classes and may be of use to simple perl DBD's.      */\n        if (strnNE(key,\"private_\",8) && strnNE(key,\"dbd_\",4) && strnNE(key,\"dbi_\",4)) {\n            if (DBIc_TRACE_LEVEL(imp_xxh)) { /* change to DBIc_WARN(imp_xxh) once we can validate prefix against registry */\n                PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"$h->{%s}=%s ignored for invalid driver-specific attribute\\n\",\n                        neatsvpv(keysv,0), neatsvpv(valuesv,0));\n            }\n            return FALSE;\n        }\n        cacheit = 1;\n    }\n    if (cacheit) {\n        (void)hv_store((HV*)SvRV(h), key, keylen, newSVsv(valuesv), 0);\n    }\n    return TRUE;\n}\n\n\nstatic SV *\ndbih_get_attr_k(SV *h, SV *keysv, int dbikey)\n{\n    dTHX;\n    dTHR;\n    D_imp_xxh(h);\n    STRLEN keylen;\n    char  *key = SvPV(keysv, keylen);\n    int    htype = DBIc_TYPE(imp_xxh);\n    SV  *valuesv = Nullsv;\n    int    cacheit = FALSE;\n    char *p;\n    int i;\n    SV  *sv;\n    SV  **svp;\n    (void)dbikey;\n\n    /* DBI quick_FETCH will service some requests (e.g., cached values) */\n\n    if (htype == DBIt_ST) {\n        switch (*key) {\n\n          case 'D':\n            if (keylen==8 && strEQ(key, \"Database\")) {\n                D_imp_from_child(imp_dbh, imp_dbh_t, imp_xxh);\n                valuesv = newRV_inc((SV*)DBIc_MY_H(imp_dbh));\n                cacheit = FALSE;  /* else creates ref loop */\n            }\n            break;\n\n          case 'N':\n            if (keylen==8 && strEQ(key, \"NULLABLE\")) {\n                valuesv = &PL_sv_undef;\n                break;\n            }\n\n            if (keylen==4 && strEQ(key, \"NAME\")) {\n                valuesv = &PL_sv_undef;\n                break;\n            }\n\n            /* deal with: NAME_(uc|lc), NAME_hash, NAME_(uc|lc)_hash */\n            if ((keylen==7 || keylen==9 || keylen==12)\n                && strnEQ(key, \"NAME_\", 5)\n                && (    (keylen==9 && strEQ(key, \"NAME_hash\"))\n                      ||        ((key[5]=='u' || key[5]=='l') && key[6] == 'c'\n                               && (!key[7] || strnEQ(&key[7], \"_hash\", 5)))\n                    )\n                ) {\n                D_imp_sth(h);\n                valuesv = &PL_sv_undef;\n\n                /* fetch from tied outer handle to trigger FETCH magic */\n                svp = hv_fetch((HV*)DBIc_MY_H(imp_sth), \"NAME\",4, FALSE);\n                sv = (svp) ? *svp : &PL_sv_undef;\n                if (SvGMAGICAL(sv))     /* call FETCH via magic */\n                    mg_get(sv);\n\n                if (SvROK(sv)) {\n                    AV *name_av = (AV*)SvRV(sv);\n                    char *name;\n                    int upcase = (key[5] == 'u');\n                    AV *av = Nullav;\n                    HV *hv = Nullhv;\n                    int num_fields_mismatch = 0;\n\n                    if (strEQ(&key[strlen(key)-5], \"_hash\"))\n                        hv = newHV();\n                    else av = newAV();\n                    i = DBIc_NUM_FIELDS(imp_sth);\n\n                    /* catch invalid NUM_FIELDS */\n                    if (i != AvFILL(name_av)+1) {\n                        /* flag as mismatch, except for \"-1 and empty\" case */\n                        if ( ! (i == -1 && 0 == AvFILL(name_av)+1) )\n                            num_fields_mismatch = 1;\n                        i = AvFILL(name_av)+1; /* limit for safe iteration over array */\n                    }\n\n\t\t    if (DBIc_TRACE_LEVEL(imp_sth) >= 10 || (num_fields_mismatch && DBIc_WARN(imp_xxh))) {\n\t\t\tPerlIO_printf(DBIc_LOGPIO(imp_sth),\"       FETCH $h->{%s} from $h->{NAME} with $h->{NUM_OF_FIELDS} = %d\"\n\t\t\t                       \" and %ld entries in $h->{NAME}%s\\n\",\n\t\t\t\tneatsvpv(keysv,0), DBIc_NUM_FIELDS(imp_sth), AvFILL(name_av)+1,\n                                (num_fields_mismatch) ? \" (possible bug in driver)\" : \"\");\n                    }\n\n                    while (--i >= 0) {\n                        sv = newSVsv(AvARRAY(name_av)[i]);\n                        name = SvPV_nolen(sv);\n                        if (key[5] != 'h') {    /* \"NAME_hash\" */\n                            for (p = name; p && *p; ++p) {\n#ifdef toUPPER_LC\n                                *p = (upcase) ? toUPPER_LC(*p) : toLOWER_LC(*p);\n#else\n                                *p = (upcase) ? toUPPER(*p) : toLOWER(*p);\n#endif\n                            }\n                        }\n                        if (av)\n                            av_store(av, i, sv);\n                        else {\n                            (void)hv_store(hv, name, SvCUR(sv), newSViv(i), 0);\n                            sv_free(sv);\n                        }\n                    }\n                    valuesv = newRV_noinc( (av ? (SV*)av : (SV*)hv) );\n                    cacheit = TRUE;     /* can't change */\n                }\n            }\n            else if (keylen==13 && strEQ(key, \"NUM_OF_FIELDS\")) {\n                D_imp_sth(h);\n                IV num_fields = DBIc_NUM_FIELDS(imp_sth);\n                valuesv = (num_fields < 0) ? &PL_sv_undef : newSViv(num_fields);\n                if (num_fields > 0)\n                    cacheit = TRUE;     /* can't change once set (XXX except for multiple result sets) */\n            }\n            else if (keylen==13 && strEQ(key, \"NUM_OF_PARAMS\")) {\n                D_imp_sth(h);\n                valuesv = newSViv(DBIc_NUM_PARAMS(imp_sth));\n                cacheit = TRUE; /* can't change */\n            }\n            break;\n\n          case 'P':\n            if (strEQ(key, \"PRECISION\"))\n                valuesv = &PL_sv_undef;\n            else if (strEQ(key, \"ParamValues\"))\n                valuesv = &PL_sv_undef;\n            else if (strEQ(key, \"ParamTypes\"))\n                valuesv = &PL_sv_undef;\n            break;\n\n          case 'R':\n            if (strEQ(key, \"RowsInCache\"))\n                valuesv = &PL_sv_undef;\n            break;\n\n          case 'S':\n            if (strEQ(key, \"SCALE\"))\n                valuesv = &PL_sv_undef;\n            break;\n\n          case 'T':\n            if (strEQ(key, \"TYPE\"))\n                valuesv = &PL_sv_undef;\n            break;\n        }\n\n    }\n    else\n    if (htype == DBIt_DB) {\n        /* this is here but is, sadly, not called because\n         * not-preloading them into the handle attrib cache caused\n         * wierdness in t/proxy.t that I never got to the bottom\n         * of. One day maybe.  */\n        if (keylen==6 && strEQ(key, \"Driver\")) {\n            D_imp_from_child(imp_dbh, imp_dbh_t, imp_xxh);\n            valuesv = newRV_inc((SV*)DBIc_MY_H(imp_dbh));\n            cacheit = FALSE;  /* else creates ref loop */\n        }\n    }\n\n    if (valuesv == Nullsv && htype <= DBIt_DB) {\n        if (keylen==10 && strEQ(key, \"AutoCommit\")) {\n            valuesv = boolSV(DBIc_has(imp_xxh,DBIcf_AutoCommit));\n        }\n    }\n\n    if (valuesv == Nullsv) {\n        switch (*key) {\n          case 'A':\n            if (keylen==6 && strEQ(key, \"Active\")) {\n                valuesv = boolSV(DBIc_ACTIVE(imp_xxh));\n            }\n            else if (keylen==10 && strEQ(key, \"ActiveKids\")) {\n                valuesv = newSViv(DBIc_ACTIVE_KIDS(imp_xxh));\n            }\n            else if (strEQ(key, \"AutoInactiveDestroy\")) {\n                valuesv = boolSV(DBIc_AIADESTROY(imp_xxh));\n            }\n            break;\n\n          case 'B':\n            if (keylen==9 && strEQ(key, \"BegunWork\")) {\n                valuesv = boolSV(DBIc_has(imp_xxh,DBIcf_BegunWork));\n            }\n            break;\n\n          case 'C':\n            if (strEQ(key, \"ChildHandles\")) {\n                svp = hv_fetch((HV*)SvRV(h), key, keylen, FALSE);\n                /* if something has been stored then return it.\n                 * otherwise return a dummy empty array if weakrefs are\n                 * available, else an undef to indicate that they're not */\n                if (svp) {\n                    valuesv = newSVsv(*svp);\n                } else {\n#ifdef sv_rvweaken\n                    valuesv = newRV_noinc((SV*)newAV());\n#else\n                    valuesv = &PL_sv_undef;\n#endif\n                }\n            }\n            else if (strEQ(key, \"ChopBlanks\")) {\n                valuesv = boolSV(DBIc_has(imp_xxh,DBIcf_ChopBlanks));\n            }\n            else if (strEQ(key, \"CachedKids\")) {\n                valuesv = &PL_sv_undef;\n            }\n            else if (strEQ(key, \"CompatMode\")) {\n                valuesv = boolSV(DBIc_COMPAT(imp_xxh));\n            }\n            break;\n\n          case 'E':\n            if (strEQ(key, \"Executed\")) {\n                valuesv = boolSV(DBIc_is(imp_xxh, DBIcf_Executed));\n            }\n            else if (strEQ(key, \"ErrCount\")) {\n                valuesv = newSVuv(DBIc_ErrCount(imp_xxh));\n            }\n            break;\n\n          case 'I':\n            if (strEQ(key, \"InactiveDestroy\")) {\n                valuesv = boolSV(DBIc_IADESTROY(imp_xxh));\n            }\n            break;\n\n          case 'K':\n            if (keylen==4 && strEQ(key, \"Kids\")) {\n                valuesv = newSViv(DBIc_KIDS(imp_xxh));\n            }\n            break;\n\n          case 'L':\n            if (keylen==11 && strEQ(key, \"LongReadLen\")) {\n                valuesv = newSVnv((NV)DBIc_LongReadLen(imp_xxh));\n            }\n            else if (keylen==11 && strEQ(key, \"LongTruncOk\")) {\n                valuesv = boolSV(DBIc_has(imp_xxh,DBIcf_LongTruncOk));\n            }\n            break;\n\n          case 'M':\n            if (keylen==10 && strEQ(key, \"MultiThread\")) {\n                valuesv = boolSV(DBIc_has(imp_xxh,DBIcf_MultiThread));\n            }\n            break;\n\n          case 'P':\n            if (keylen==10 && strEQ(key, \"PrintError\")) {\n                valuesv = boolSV(DBIc_has(imp_xxh,DBIcf_PrintError));\n            }\n            else if (keylen==9 && strEQ(key, \"PrintWarn\")) {\n                valuesv = boolSV(DBIc_has(imp_xxh,DBIcf_PrintWarn));\n            }\n            break;\n\n          case 'R':\n            if (keylen==10 && strEQ(key, \"RaiseError\")) {\n                valuesv = boolSV(DBIc_has(imp_xxh,DBIcf_RaiseError));\n            }\n            else if (keylen==12 && strEQ(key, \"RowCacheSize\")) {\n                valuesv = &PL_sv_undef;\n            }\n            break;\n\n          case 'S':\n            if (keylen==18 && strEQ(key, \"ShowErrorStatement\")) {\n                valuesv = boolSV(DBIc_has(imp_xxh,DBIcf_ShowErrorStatement));\n            }\n            break;\n\n          case 'T':\n            if (keylen==4 && strEQ(key, \"Type\")) {\n                char *type = dbih_htype_name(htype);\n                valuesv = newSVpv(type,0);\n                cacheit = TRUE; /* can't change */\n            }\n            else if (keylen==10  && strEQ(key, \"TraceLevel\")) {\n                valuesv = newSViv( DBIc_DEBUGIV(imp_xxh) );\n            }\n            else if (keylen==5  && strEQ(key, \"Taint\")) {\n                valuesv = boolSV(DBIc_has(imp_xxh,DBIcf_TaintIn) &&\n                                 DBIc_has(imp_xxh,DBIcf_TaintOut));\n            }\n            else if (keylen==7  && strEQ(key, \"TaintIn\")) {\n                valuesv = boolSV(DBIc_has(imp_xxh,DBIcf_TaintIn));\n            }\n            else if (keylen==8  && strEQ(key, \"TaintOut\")) {\n                valuesv = boolSV(DBIc_has(imp_xxh,DBIcf_TaintOut));\n            }\n            break;\n\n          case 'W':\n            if (keylen==4 && strEQ(key, \"Warn\")) {\n                valuesv = boolSV(DBIc_WARN(imp_xxh));\n            }\n            break;\n        }\n    }\n\n    /* finally check the actual hash */\n    if (valuesv == Nullsv) {\n        valuesv = &PL_sv_undef;\n        cacheit = 0;\n        svp = hv_fetch((HV*)SvRV(h), key, keylen, FALSE);\n        if (svp)\n            valuesv = newSVsv(*svp);    /* take copy to mortalize */\n        else /* warn unless it's known attribute name */\n        if ( !(         (*key=='H' && strEQ(key, \"HandleError\"))\n                ||      (*key=='H' && strEQ(key, \"HandleSetErr\"))\n                ||      (*key=='S' && strEQ(key, \"Statement\"))\n                ||      (*key=='P' && strEQ(key, \"ParamArrays\"))\n                ||      (*key=='P' && strEQ(key, \"ParamValues\"))\n                ||      (*key=='P' && strEQ(key, \"Profile\"))\n                ||      (*key=='R' && strEQ(key, \"ReadOnly\"))\n                ||      (*key=='C' && strEQ(key, \"CursorName\"))\n                ||      (*key=='C' && strEQ(key, \"Callbacks\"))\n                ||      (*key=='U' && strEQ(key, \"Username\"))\n                ||      !isUPPER(*key)  /* dbd_*, private_* etc */\n        ))\n            warn(\"Can't get %s->{%s}: unrecognised attribute name\",neatsvpv(h,0),key);\n    }\n\n    if (cacheit) {\n        (void)hv_store((HV*)SvRV(h), key, keylen, newSVsv(valuesv), 0);\n    }\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 3)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"    .. FETCH %s %s = %s%s\\n\", neatsvpv(h,0),\n            neatsvpv(keysv,0), neatsvpv(valuesv,0), cacheit?\" (cached)\":\"\");\n    if (valuesv == &PL_sv_yes || valuesv == &PL_sv_no || valuesv == &PL_sv_undef)\n        return valuesv; /* no need to mortalize yes or no */\n    return sv_2mortal(valuesv);\n}\n\n\n\n/* -------------------------------------------------------------------- */\n/* Functions implementing Error and Event Handling.                     */\n\n\nstatic SV *\ndbih_event(SV *hrv, const char *evtype, SV *a1, SV *a2)\n{\n    dTHX;\n    /* We arrive here via DBIh_EVENT* macros (see DBIXS.h) called from  */\n    /* DBD driver C code OR $h->event() method (in DBD::_::common)      */\n    /* XXX VERY OLD INTERFACE/CONCEPT MAY GO SOON */\n    /* OR MAY EVOLVE INTO A WAY TO HANDLE 'SUCCESS_WITH_INFO'/'WARNINGS' from db */\n    (void)hrv;\n    (void)evtype;\n    (void)a1;\n    (void)a2;\n    return &PL_sv_undef;\n}\n\n\n/* ----------------------------------------------------------------- */\n\n\nSTATIC I32\ndbi_dopoptosub_at(PERL_CONTEXT *cxstk, I32 startingblock)\n{\n    dTHX;\n    I32 i;\n    register PERL_CONTEXT *cx;\n    for (i = startingblock; i >= 0; i--) {\n        cx = &cxstk[i];\n        switch (CxTYPE(cx)) {\n        default:\n            continue;\n        case CXt_EVAL:\n        case CXt_SUB:\n#ifdef CXt_FORMAT\n        case CXt_FORMAT:\n#endif\n            DEBUG_l( Perl_deb(aTHX_ \"(Found sub #%ld)\\n\", (long)i));\n            return i;\n        }\n    }\n    return i;\n}\n\n\nstatic COP *\ndbi_caller_cop()\n{\n    dTHX;\n    register I32 cxix;\n    register PERL_CONTEXT *cx;\n    register PERL_CONTEXT *ccstack = cxstack;\n    PERL_SI *top_si = PL_curstackinfo;\n    char *stashname;\n\n    for ( cxix = dbi_dopoptosub_at(ccstack, cxstack_ix) ;; cxix = dbi_dopoptosub_at(ccstack, cxix - 1)) {\n        /* we may be in a higher stacklevel, so dig down deeper */\n        while (cxix < 0 && top_si->si_type != PERLSI_MAIN) {\n            top_si = top_si->si_prev;\n            ccstack = top_si->si_cxstack;\n            cxix = dbi_dopoptosub_at(ccstack, top_si->si_cxix);\n        }\n        if (cxix < 0) {\n            break;\n        }\n        if (PL_DBsub && cxix >= 0 && ccstack[cxix].blk_sub.cv == GvCV(PL_DBsub))\n            continue;\n        cx = &ccstack[cxix];\n        stashname = CopSTASHPV(cx->blk_oldcop);\n        if (!stashname)\n            continue;\n        if (!(stashname[0] == 'D' && stashname[1] == 'B'\n                && strchr(\"DI\", stashname[2])\n                    && (!stashname[3] || (stashname[3] == ':' && stashname[4] == ':'))))\n        {\n            return cx->blk_oldcop;\n        }\n        cxix = dbi_dopoptosub_at(ccstack, cxix - 1);\n    }\n    return NULL;\n}\n\nstatic void\ndbi_caller_string(SV *buf, COP *cop, char *prefix, int show_line, int show_path)\n{\n    dTHX;\n    STRLEN len;\n    long  line = CopLINE(cop);\n    char *file = SvPV(GvSV(CopFILEGV(cop)), len);\n    if (!show_path) {\n        char *sep;\n        if ( (sep=strrchr(file,'/')) || (sep=strrchr(file,'\\\\')))\n            file = sep+1;\n    }\n    if (show_line) {\n        sv_catpvf(buf, \"%s%s line %ld\", (prefix) ? prefix : \"\", file, line);\n    }\n    else {\n        sv_catpvf(buf, \"%s%s\",          (prefix) ? prefix : \"\", file);\n    }\n}\n\nstatic char *\nlog_where(SV *buf, int append, char *prefix, char *suffix, int show_line, int show_caller, int show_path)\n{\n    dTHX;\n    dTHR;\n    if (!buf)\n        buf = sv_2mortal(newSVpv(\"\",0));\n    else if (!append)\n        sv_setpv(buf,\"\");\n    if (CopLINE(PL_curcop)) {\n        COP *cop;\n        dbi_caller_string(buf, PL_curcop, prefix, show_line, show_path);\n        if (show_caller && (cop = dbi_caller_cop())) {\n            SV *via = sv_2mortal(newSVpv(\"\",0));\n            dbi_caller_string(via, cop, prefix, show_line, show_path);\n            sv_catpvf(buf, \" via %s\", SvPV_nolen(via));\n        }\n    }\n    if (PL_dirty)\n        sv_catpvf(buf, \" during global destruction\");\n    if (suffix)\n        sv_catpv(buf, suffix);\n    return SvPVX(buf);\n}\n\n\nstatic void\nclear_cached_kids(pTHX_ SV *h, imp_xxh_t *imp_xxh, const char *meth_name, int trace_level)\n{\n    if (DBIc_TYPE(imp_xxh) <= DBIt_DB) {\n        SV **svp = hv_fetch((HV*)SvRV(h), \"CachedKids\", 10, 0);\n        if (svp && SvROK(*svp) && SvTYPE(SvRV(*svp)) == SVt_PVHV) {\n            HV *hv = (HV*)SvRV(*svp);\n            if (HvKEYS(hv)) {\n                if (DBIc_TRACE_LEVEL(imp_xxh) > trace_level)\n                    trace_level = DBIc_TRACE_LEVEL(imp_xxh);\n                if (trace_level >= 2) {\n                    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\"    >> %s %s clearing %d CachedKids\\n\",\n                        meth_name, neatsvpv(h,0), (int)HvKEYS(hv));\n                    PerlIO_flush(DBIc_LOGPIO(imp_xxh));\n                }\n                /* This will probably recurse through dispatch to DESTROY the kids */\n                /* For drh we should probably explicitly do dbh disconnects */\n                hv_clear(hv);\n            }\n        }\n    }\n}\n\n\nstatic NV\ndbi_time() {\n# ifdef HAS_GETTIMEOFDAY\n#   ifdef PERL_IMPLICIT_SYS\n    dTHX;\n#   endif\n    struct timeval when;\n    gettimeofday(&when, (struct timezone *) 0);\n    return when.tv_sec + (when.tv_usec / 1000000.0);\n# else  /* per-second is almost useless */\n# ifdef _WIN32 /* use _ftime() on Win32 (MS Visual C++ 6.0) */\n#  if defined(__BORLANDC__)\n#   define _timeb timeb\n#   define _ftime ftime\n#  endif\n    struct _timeb when;\n    _ftime( &when );\n    return when.time + (when.millitm / 1000.0);\n# else\n    return time(NULL);\n# endif\n# endif\n}\n\n\nstatic SV *\n_profile_next_node(SV *node, const char *name)\n{\n    /* step one level down profile Data tree and auto-vivify if required */\n    dTHX;\n    SV *orig_node = node;\n    if (SvROK(node))\n        node = SvRV(node);\n    if (SvTYPE(node) != SVt_PVHV) {\n        HV *hv = newHV();\n        if (SvOK(node)) {\n            char *key = \"(demoted)\";\n            warn(\"Profile data element %s replaced with new hash ref (for %s) and original value stored with key '%s'\",\n                neatsvpv(orig_node,0), name, key);\n            (void)hv_store(hv, key, strlen(key), SvREFCNT_inc(orig_node), 0);\n        }\n        sv_setsv(node, newRV_noinc((SV*)hv));\n        node = (SV*)hv;\n    }\n    node = *hv_fetch((HV*)node, name, strlen(name), 1);\n    return node;\n}\n\n\nstatic SV*\ndbi_profile(SV *h, imp_xxh_t *imp_xxh, SV *statement_sv, SV *method, NV t1, NV t2)\n{\n#define DBIprof_MAX_PATH_ELEM   100\n#define DBIprof_COUNT           0\n#define DBIprof_TOTAL_TIME      1\n#define DBIprof_FIRST_TIME      2\n#define DBIprof_MIN_TIME        3\n#define DBIprof_MAX_TIME        4\n#define DBIprof_FIRST_CALLED    5\n#define DBIprof_LAST_CALLED     6\n#define DBIprof_max_index       6\n    dTHX;\n    NV ti = t2 - t1;\n    int src_idx = 0;\n    HV *dbh_outer_hv = NULL;\n    HV *dbh_inner_hv = NULL;\n    char *statement_pv;\n    char *method_pv;\n    SV *profile;\n    SV *tmp;\n    SV *dest_node;\n    AV *av;\n    HV *h_hv;\n\n    const int call_depth = DBIc_CALL_DEPTH(imp_xxh);\n    const int parent_call_depth = DBIc_PARENT_COM(imp_xxh) ? DBIc_CALL_DEPTH(DBIc_PARENT_COM(imp_xxh)) : 0;\n    /* Only count calls originating from the application code   */\n    if (call_depth > 1 || parent_call_depth > 0)\n        return &PL_sv_undef;\n\n    if (!DBIc_has(imp_xxh, DBIcf_Profile))\n        return &PL_sv_undef;\n\n    method_pv = (SvTYPE(method)==SVt_PVCV) ? GvNAME(CvGV(method))\n                : isGV(method) ? GvNAME(method)\n                : SvOK(method) ? SvPV_nolen(method)\n                : \"\";\n\n    /* we don't profile DESTROY during global destruction */\n    if (PL_dirty && instr(method_pv, \"DESTROY\"))\n        return &PL_sv_undef;\n\n    h_hv = (HV*)SvRV(dbih_inner(aTHX_ h, \"dbi_profile\"));\n\n    profile = *hv_fetch(h_hv, \"Profile\", 7, 1);\n    if (profile && SvMAGICAL(profile))\n        mg_get(profile); /* FETCH */\n    if (!profile || !SvROK(profile)) {\n        DBIc_set(imp_xxh, DBIcf_Profile, 0); /* disable */\n        if (SvOK(profile) && !PL_dirty)\n            warn(\"Profile attribute isn't a hash ref (%s,%ld)\", neatsvpv(profile,0), (long)SvTYPE(profile));\n        return &PL_sv_undef;\n    }\n\n    /* statement_sv: undef = use $h->{Statement}, \"\" (&sv_no) = use empty string */\n\n    if (!SvOK(statement_sv)) {\n        SV **psv = hv_fetch(h_hv, \"Statement\", 9, 0);\n        statement_sv = (psv && SvOK(*psv)) ? *psv : &PL_sv_no;\n    }\n    statement_pv = SvPV_nolen(statement_sv);\n\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 4)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"       dbi_profile +%\" NVff \"s %s %s\\n\",\n            ti, method_pv, neatsvpv(statement_sv,0));\n\n    dest_node = _profile_next_node(profile, \"Data\");\n\n    tmp = *hv_fetch((HV*)SvRV(profile), \"Path\", 4, 1);\n    if (SvROK(tmp) && SvTYPE(SvRV(tmp))==SVt_PVAV) {\n        int len;\n        av = (AV*)SvRV(tmp);\n        len = av_len(av); /* -1=empty, 0=one element */\n\n        while ( src_idx <= len ) {\n            SV *pathsv = AvARRAY(av)[src_idx++];\n\n            if (SvROK(pathsv) && SvTYPE(SvRV(pathsv))==SVt_PVCV) {\n                /* call sub, use returned list of values as path */\n                /* returning a ref to undef vetos this profile data */\n                dSP;\n                I32 ax;\n                SV *code_sv = SvRV(pathsv);\n                I32 items;\n                I32 item_idx;\n                EXTEND(SP, 4);\n                PUSHMARK(SP);\n                PUSHs(h);   /* push inner handle, then others params */\n                PUSHs( sv_2mortal(newSVpv(method_pv,0)));\n                PUTBACK;\n                SAVE_DEFSV; /* local($_) = $statement */\n                DEFSV = statement_sv;\n                items = call_sv(code_sv, G_ARRAY);\n                SPAGAIN;\n                SP -= items ;\n                ax = (SP - PL_stack_base) + 1 ;\n                for (item_idx=0; item_idx < items; ++item_idx) {\n                    SV *item_sv = ST(item_idx);\n                    if (SvROK(item_sv)) {\n                        if (!SvOK(SvRV(item_sv)))\n                            items = -2; /* flag that we're rejecting this profile data */\n                        else /* other refs reserved */\n                            warn(\"Ignored ref returned by code ref in Profile Path\");\n                        break;\n                    }\n                    dest_node = _profile_next_node(dest_node, SvPV_nolen(item_sv));\n                }\n                PUTBACK;\n                if (items == -2) /* this profile data was vetoed */\n                    return &PL_sv_undef;\n            }\n            else if (SvROK(pathsv)) {\n                /* only meant for refs to scalars currently */\n                const char *p = SvPV_nolen(SvRV(pathsv));\n                dest_node = _profile_next_node(dest_node, p);\n            }\n            else if (SvOK(pathsv)) {\n                STRLEN len;\n                const char *p = SvPV(pathsv,len);\n                if (p[0] == '!') { /* special cases */\n                    if (p[1] == 'S' && strEQ(p, \"!Statement\")) {\n                        dest_node = _profile_next_node(dest_node, statement_pv);\n                    }\n                    else if (p[1] == 'M' && strEQ(p, \"!MethodName\")) {\n                        dest_node = _profile_next_node(dest_node, method_pv);\n                    }\n                    else if (p[1] == 'M' && strEQ(p, \"!MethodClass\")) {\n                        if (SvTYPE(method) == SVt_PVCV) {\n                            p = SvPV_nolen((SV*)CvGV(method));\n                        }\n                        else if (isGV(method)) {\n                            /* just using SvPV_nolen(method) sometimes causes an error: */\n                            /* \"Can't coerce GLOB to string\" so we use gv_efullname()   */\n                            SV *tmpsv = sv_2mortal(newSVpv(\"\",0));\n#if (PERL_VERSION < 6)\n                            gv_efullname(tmpsv, (GV*)method);\n#else\n                            gv_efullname4(tmpsv, (GV*)method, \"\", TRUE);\n#endif\n                            p = SvPV_nolen(tmpsv);\n                            if (*p == '*') ++p; /* skip past leading '*' glob sigil */\n                        }\n                        else {\n                            p = method_pv;\n                        }\n                        dest_node = _profile_next_node(dest_node, p);\n                    }\n                    else if (p[1] == 'F' && strEQ(p, \"!File\")) {\n                        dest_node = _profile_next_node(dest_node, log_where(0, 0, \"\", \"\", 0, 0, 0));\n                    }\n                    else if (p[1] == 'F' && strEQ(p, \"!File2\")) {\n                        dest_node = _profile_next_node(dest_node, log_where(0, 0, \"\", \"\", 0, 1, 0));\n                    }\n                    else if (p[1] == 'C' && strEQ(p, \"!Caller\")) {\n                        dest_node = _profile_next_node(dest_node, log_where(0, 0, \"\", \"\", 1, 0, 0));\n                    }\n                    else if (p[1] == 'C' && strEQ(p, \"!Caller2\")) {\n                        dest_node = _profile_next_node(dest_node, log_where(0, 0, \"\", \"\", 1, 1, 0));\n                    }\n                    else if (p[1] == 'T' && (strEQ(p, \"!Time\") || strnEQ(p, \"!Time~\", 6))) {\n                        char timebuf[20];\n                        int factor = 1;\n                        if (p[5] == '~') {\n                            factor = atoi(&p[6]);\n                            if (factor == 0) /* sanity check to avoid div by zero error */\n                                factor = 3600;\n                        }\n                        sprintf(timebuf, \"%ld\", ((long)(dbi_time()/factor))*factor);\n                        dest_node = _profile_next_node(dest_node, timebuf);\n                    }\n                    else {\n                        warn(\"Unknown ! element in DBI::Profile Path: %s\", p);\n                        dest_node = _profile_next_node(dest_node, p);\n                    }\n                }\n                else if (p[0] == '{' && p[len-1] == '}') { /* treat as name of dbh attribute to use */\n                    SV **attr_svp;\n                    if (!dbh_inner_hv) {        /* cache dbh handles the first time we need them */\n                        imp_dbh_t *imp_dbh = (DBIc_TYPE(imp_xxh) <= DBIt_DB) ? (imp_dbh_t*)imp_xxh : (imp_dbh_t*)DBIc_PARENT_COM(imp_xxh);\n                        dbh_outer_hv = DBIc_MY_H(imp_dbh);\n                        if (SvTYPE(dbh_outer_hv) != SVt_PVHV)\n                            return &PL_sv_undef;        /* presumably global destruction - bail */\n                        dbh_inner_hv = (HV*)SvRV(dbih_inner(aTHX_ (SV*)dbh_outer_hv, \"profile\"));\n                        if (SvTYPE(dbh_inner_hv) != SVt_PVHV)\n                            return &PL_sv_undef;        /* presumably global destruction - bail */\n                    }\n                    /* fetch from inner first, then outer if key doesn't exist */\n                    /* (yes, this is an evil premature optimization) */\n                    p += 1; len -= 2; /* ignore the braces */\n                    if ((attr_svp = hv_fetch(dbh_inner_hv, p, len, 0)) == NULL) {\n                        /* try outer (tied) hash - for things like AutoCommit   */\n                        /* (will always return something even for unknowns)     */\n                        if ((attr_svp = hv_fetch(dbh_outer_hv, p, len, 0))) {\n                            if (SvGMAGICAL(*attr_svp))\n                                mg_get(*attr_svp); /* FETCH */\n                        }\n                    }\n                    if (!attr_svp)\n                        p -= 1; /* unignore the braces */\n                    else if (!SvOK(*attr_svp))\n                        p = \"\";\n                    else if (!SvTRUE(*attr_svp) && SvPOK(*attr_svp) && SvNIOK(*attr_svp))\n                        p = \"0\"; /* catch &sv_no style special case */\n                    else\n                        p = SvPV_nolen(*attr_svp);\n                    dest_node = _profile_next_node(dest_node, p);\n                }\n                else {\n                    dest_node = _profile_next_node(dest_node, p);\n                }\n            }\n            /* else undef, so ignore */\n        }\n    }\n    else { /* a bad Path value is treated as a Path of just Statement */\n        dest_node = _profile_next_node(dest_node, statement_pv);\n    }\n\n\n    if (!SvOK(dest_node)) {\n        av = newAV();\n        sv_setsv(dest_node, newRV_noinc((SV*)av));\n        av_store(av, DBIprof_COUNT,             newSViv(1));\n        av_store(av, DBIprof_TOTAL_TIME,        newSVnv(ti));\n        av_store(av, DBIprof_FIRST_TIME,        newSVnv(ti));\n        av_store(av, DBIprof_MIN_TIME,          newSVnv(ti));\n        av_store(av, DBIprof_MAX_TIME,          newSVnv(ti));\n        av_store(av, DBIprof_FIRST_CALLED,      newSVnv(t1));\n        av_store(av, DBIprof_LAST_CALLED,       newSVnv(t1));\n    }\n    else {\n        tmp = dest_node;\n        if (SvROK(tmp))\n            tmp = SvRV(tmp);\n        if (SvTYPE(tmp) != SVt_PVAV)\n            croak(\"Invalid Profile data leaf element: %s (type %ld)\",\n                    neatsvpv(tmp,0), (long)SvTYPE(tmp));\n        av = (AV*)tmp;\n        sv_inc( *av_fetch(av, DBIprof_COUNT, 1));\n        tmp = *av_fetch(av, DBIprof_TOTAL_TIME, 1);\n        sv_setnv(tmp, SvNV(tmp) + ti);\n        tmp = *av_fetch(av, DBIprof_MIN_TIME, 1);\n        if (ti < SvNV(tmp)) sv_setnv(tmp, ti);\n        tmp = *av_fetch(av, DBIprof_MAX_TIME, 1);\n        if (ti > SvNV(tmp)) sv_setnv(tmp, ti);\n        sv_setnv( *av_fetch(av, DBIprof_LAST_CALLED, 1), t1);\n    }\n    return dest_node; /* use with caution - copy first, ie sv_mortalcopy() */\n}\n\n\nstatic void\ndbi_profile_merge_nodes(SV *dest, SV *increment)\n{\n    dTHX;\n    AV *d_av, *i_av;\n    SV *tmp;\n    SV *tmp2;\n    NV i_nv;\n    int i_is_earlier;\n\n    if (!SvROK(dest) || SvTYPE(SvRV(dest)) != SVt_PVAV)\n        croak(\"dbi_profile_merge_nodes(%s, ...) requires array ref\", neatsvpv(dest,0));\n    d_av = (AV*)SvRV(dest);\n\n    if (av_len(d_av) < DBIprof_max_index) {\n        int idx;\n        av_extend(d_av, DBIprof_max_index);\n        for(idx=0; idx<=DBIprof_max_index; ++idx) {\n            tmp = *av_fetch(d_av, idx, 1);\n            if (!SvOK(tmp) && idx != DBIprof_MIN_TIME && idx != DBIprof_FIRST_CALLED)\n                sv_setnv(tmp, 0.0); /* leave 'min' values as undef */\n        }\n    }\n\n    if (!SvOK(increment))\n        return;\n\n    if (SvROK(increment) && SvTYPE(SvRV(increment)) == SVt_PVHV) {\n        HV *hv = (HV*)SvRV(increment);\n        char *key;\n        I32 keylen = 0;\n        hv_iterinit(hv);\n        while ( (tmp = hv_iternextsv(hv, &key, &keylen)) != NULL ) {\n            dbi_profile_merge_nodes(dest, tmp);\n        };\n        return;\n    }\n\n    if (!SvROK(increment) || SvTYPE(SvRV(increment)) != SVt_PVAV)\n        croak(\"dbi_profile_merge_nodes: increment %s not an array or hash ref\", neatsvpv(increment,0));\n    i_av = (AV*)SvRV(increment);\n\n    tmp  = *av_fetch(d_av, DBIprof_COUNT, 1);\n    tmp2 = *av_fetch(i_av, DBIprof_COUNT, 1);\n    if (SvIOK(tmp) && SvIOK(tmp2))\n        sv_setiv( tmp, SvIV(tmp) + SvIV(tmp2) );\n    else\n        sv_setnv( tmp, SvNV(tmp) + SvNV(tmp2) );\n\n    tmp = *av_fetch(d_av, DBIprof_TOTAL_TIME, 1);\n    sv_setnv( tmp, SvNV(tmp) + SvNV( *av_fetch(i_av, DBIprof_TOTAL_TIME, 1)) );\n\n    i_nv = SvNV(*av_fetch(i_av, DBIprof_MIN_TIME, 1));\n    tmp  =      *av_fetch(d_av, DBIprof_MIN_TIME, 1);\n    if (!SvOK(tmp) || i_nv < SvNV(tmp)) sv_setnv(tmp, i_nv);\n\n    i_nv = SvNV(*av_fetch(i_av, DBIprof_MAX_TIME, 1));\n    tmp  =      *av_fetch(d_av, DBIprof_MAX_TIME, 1);\n    if (i_nv > SvNV(tmp)) sv_setnv(tmp, i_nv);\n\n    i_nv = SvNV(*av_fetch(i_av, DBIprof_FIRST_CALLED, 1));\n    tmp  =      *av_fetch(d_av, DBIprof_FIRST_CALLED, 1);\n    i_is_earlier = (!SvOK(tmp) || i_nv < SvNV(tmp));\n    if (i_is_earlier)\n        sv_setnv(tmp, i_nv);\n\n    i_nv = SvNV(*av_fetch(i_av, DBIprof_FIRST_TIME, 1));\n    tmp  =      *av_fetch(d_av, DBIprof_FIRST_TIME, 1);\n    if (i_is_earlier || !SvOK(tmp)) {\n        /* If the increment has an earlier DBIprof_FIRST_CALLED\n        then we set the DBIprof_FIRST_TIME from the increment */\n        sv_setnv(tmp, i_nv);\n    }\n\n    i_nv = SvNV(*av_fetch(i_av, DBIprof_LAST_CALLED, 1));\n    tmp  =      *av_fetch(d_av, DBIprof_LAST_CALLED, 1);\n    if (i_nv > SvNV(tmp)) sv_setnv(tmp, i_nv);\n}\n\n\n/* ----------------------------------------------------------------- */\n/* ---   The DBI dispatcher. The heart of the perl DBI.          --- */\n\nXS(XS_DBI_dispatch);            /* prototype to pass -Wmissing-prototypes */\nXS(XS_DBI_dispatch)\n{\n    dXSARGS;\n    dORIGMARK;\n    dMY_CXT;\n\n    SV *h   = ST(0);            /* the DBI handle we are working with   */\n    SV *st1 = ST(1);            /* used in debugging */\n    SV *st2 = ST(2);            /* used in debugging */\n    SV *orig_h = h;\n    SV *err_sv;\n    SV **tmp_svp;\n    SV **hook_svp = 0;\n    MAGIC *mg;\n    int gimme = GIMME;\n    I32 trace_flags = DBIS->debug;      /* local copy may change during dispatch */\n    I32 trace_level = (trace_flags & DBIc_TRACE_LEVEL_MASK);\n    int is_DESTROY;\n    meth_types meth_type;\n    int is_unrelated_to_Statement = 0;\n    U32 keep_error = FALSE;\n    UV  ErrCount = UV_MAX;\n    int i, outitems;\n    int call_depth;\n    int is_nested_call;\n    NV profile_t1 = 0.0;\n    int is_orig_method_name = 1;\n\n    const char  *meth_name = GvNAME(CvGV(cv));\n    dbi_ima_t *ima = (dbi_ima_t*)CvXSUBANY(cv).any_ptr;\n    U32   ima_flags;\n    imp_xxh_t   *imp_xxh   = NULL;\n    SV          *imp_msv   = Nullsv;\n    SV          *qsv       = Nullsv; /* quick result from a shortcut method   */\n\n\n#ifdef BROKEN_DUP_ANY_PTR\n    if (ima->my_perl != my_perl) {\n        /* we couldn't dup the ima struct at clone time, so do it now */\n        dbi_ima_t *nima;\n        Newx(nima, 1, dbi_ima_t);\n        *nima = *ima; /* structure copy */\n        CvXSUBANY(cv).any_ptr = nima;\n        nima->stash = NULL;\n        nima->gv    = NULL;\n        nima->my_perl = my_perl;\n        ima = nima;\n    }\n#endif\n\n    ima_flags  = ima->flags;\n    meth_type = ima->meth_type;\n    if (trace_level >= 9) {\n        PerlIO *logfp = DBILOGFP;\n        PerlIO_printf(logfp,\"%c   >> %-11s DISPATCH (%s rc%ld/%ld @%ld g%x ima%lx pid#%ld)\",\n            (PL_dirty?'!':' '), meth_name, neatsvpv(h,0),\n            (long)SvREFCNT(h), (SvROK(h) ? (long)SvREFCNT(SvRV(h)) : (long)-1),\n            (long)items, (int)gimme, (long)ima_flags, (long)PerlProc_getpid());\n        PerlIO_puts(logfp, log_where(0, 0, \" at \",\"\\n\", 1, (trace_level >= 3), (trace_level >= 4)));\n        PerlIO_flush(logfp);\n    }\n\n    if ( ( (is_DESTROY=(meth_type == methtype_DESTROY))) ) {\n        /* note that croak()'s won't propagate, only append to $@ */\n        keep_error = TRUE;\n    }\n\n    /* If h is a tied hash ref, switch to the inner ref 'behind' the tie.\n       This means *all* DBI methods work with the inner (non-tied) ref.\n       This makes it much easier for methods to access the real hash\n       data (without having to go through FETCH and STORE methods) and\n       for tie and non-tie methods to call each other.\n    */\n    if (SvROK(h)\n        && SvRMAGICAL(SvRV(h))\n        && (\n               ((mg=SvMAGIC(SvRV(h)))->mg_type == 'P')\n            || ((mg=mg_find(SvRV(h),'P')) != NULL)\n           )\n    ) {\n        if (mg->mg_obj==NULL || !SvOK(mg->mg_obj) || SvRV(mg->mg_obj)==NULL) {  /* maybe global destruction */\n            if (trace_level >= 3)\n                PerlIO_printf(DBILOGFP,\n                    \"%c   <> %s for %s ignored (inner handle gone)\\n\",\n                    (PL_dirty?'!':' '), meth_name, neatsvpv(h,0));\n            XSRETURN(0);\n        }\n        /* Distinguish DESTROY of tie (outer) from DESTROY of inner ref */\n        /* This may one day be used to manually destroy extra internal  */\n        /* refs if the application ceases to use the handle.            */\n        if (is_DESTROY) {\n            imp_xxh = DBIh_COM(mg->mg_obj);\n#ifdef DBI_USE_THREADS\n            if (imp_xxh && DBIc_THR_USER(imp_xxh) != my_perl) {\n                goto is_DESTROY_wrong_thread;\n            }\n#endif\n            if (imp_xxh && DBIc_TYPE(imp_xxh) <= DBIt_DB)\n                clear_cached_kids(aTHX_ mg->mg_obj, imp_xxh, meth_name, trace_level);\n            /* XXX might be better to move this down to after call_depth has been\n             * incremented and then also SvREFCNT_dec(mg->mg_obj) to force an immediate\n             * DESTROY of the inner handle if there are no other refs to it.\n             * That way the inner DESTROY is properly flagged as a nested call,\n             * and the outer DESTROY gets profiled more accurately, and callbacks work.\n             */\n            if (trace_level >= 3) {\n                PerlIO_printf(DBILOGFP,\n                    \"%c   <> DESTROY(%s) ignored for outer handle (inner %s has ref cnt %ld)\\n\",\n                    (PL_dirty?'!':' '), neatsvpv(h,0), neatsvpv(mg->mg_obj,0),\n                    (long)SvREFCNT(SvRV(mg->mg_obj))\n                );\n            }\n            /* for now we ignore it since it'll be followed soon by     */\n            /* a destroy of the inner hash and that'll do the real work */\n\n            /* However, we must at least modify DBIc_MY_H() as that is  */\n            /* pointing (without a refcnt inc) to the scalar that is    */\n            /* being destroyed, so it'll contain random values later.   */\n            if (imp_xxh)\n                DBIc_MY_H(imp_xxh) = (HV*)SvRV(mg->mg_obj); /* inner (untied) HV */\n\n            XSRETURN(0);\n        }\n        h = mg->mg_obj; /* switch h to inner ref                        */\n        ST(0) = h;      /* switch handle on stack to inner ref          */\n    }\n\n    imp_xxh = dbih_getcom2(aTHX_ h, 0); /* get common Internal Handle Attributes        */\n    if (!imp_xxh) {\n        if (meth_type == methtype_can) {  /* ref($h)->can(\"foo\")        */\n            const char *can_meth = SvPV_nolen(st1);\n            SV *rv = &PL_sv_undef;\n            GV *gv = gv_fetchmethod_autoload(gv_stashsv(orig_h,FALSE), can_meth, FALSE);\n            if (gv && isGV(gv))\n                rv = sv_2mortal(newRV_inc((SV*)GvCV(gv)));\n            if (trace_level >= 1) {\n                PerlIO_printf(DBILOGFP,\"    <- %s(%s) = %p\\n\", meth_name, can_meth, neatsvpv(rv,0));\n            }\n            ST(0) = rv;\n            XSRETURN(1);\n        }\n        if (trace_level)\n            PerlIO_printf(DBILOGFP, \"%c   <> %s for %s ignored (no imp_data)\\n\",\n                (PL_dirty?'!':' '), meth_name, neatsvpv(h,0));\n        if (!is_DESTROY)\n            warn(\"Can't call %s method on handle %s%s\", meth_name, neatsvpv(h,0),\n                SvROK(h) ? \" after take_imp_data()\" : \" (not a reference)\");\n        XSRETURN(0);\n    }\n\n    if (DBIc_has(imp_xxh,DBIcf_Profile)) {\n        profile_t1 = dbi_time(); /* just get start time here */\n    }\n\n#ifdef DBI_USE_THREADS\n{\n    PerlInterpreter * h_perl;\n    is_DESTROY_wrong_thread:\n    h_perl = DBIc_THR_USER(imp_xxh) ;\n    if (h_perl != my_perl) {\n        /* XXX could call a 'handle clone' method here?, for dbh's at least */\n        if (is_DESTROY) {\n            if (trace_level >= 3) {\n                PerlIO_printf(DBILOGFP,\"    DESTROY ignored because DBI %sh handle (%s) is owned by thread %p not current thread %p\\n\",\n                      dbih_htype_name(DBIc_TYPE(imp_xxh)), HvNAME(DBIc_IMP_STASH(imp_xxh)),\n                      (void*)DBIc_THR_USER(imp_xxh), (void*)my_perl) ;\n                PerlIO_flush(DBILOGFP);\n            }\n            XSRETURN(0); /* don't DESTROY handle, if it is not our's !*/\n        }\n        croak(\"%s %s failed: handle %d is owned by thread %lx not current thread %lx (%s)\",\n            HvNAME(DBIc_IMP_STASH(imp_xxh)), meth_name, DBIc_TYPE(imp_xxh),\n            (unsigned long)h_perl, (unsigned long)my_perl,\n            \"handles can't be shared between threads and your driver may need a CLONE method added\");\n    }\n}\n#endif\n\n    if ((i = DBIc_DEBUGIV(imp_xxh))) { /* merge handle into global */\n        I32 h_trace_level = (i & DBIc_TRACE_LEVEL_MASK);\n        if ( h_trace_level > trace_level )\n            trace_level = h_trace_level;\n        trace_flags = (trace_flags & ~DBIc_TRACE_LEVEL_MASK)\n                    | (          i & ~DBIc_TRACE_LEVEL_MASK)\n                    | trace_level;\n    }\n\n    /* Check method call against Internal Method Attributes */\n    if (ima_flags) {\n\n        if (ima_flags & (IMA_STUB|IMA_FUNC_REDIRECT|IMA_KEEP_ERR|IMA_KEEP_ERR_SUB|IMA_CLEAR_STMT)) {\n\n            if (ima_flags & IMA_STUB) {\n                if (meth_type == methtype_can) {\n                    const char *can_meth = SvPV_nolen(st1);\n                    SV *dbi_msv = Nullsv;\n                    /* find handle implementors method (GV or CV) */\n                    if ( (imp_msv = (SV*)gv_fetchmethod_autoload(DBIc_IMP_STASH(imp_xxh), can_meth, FALSE)) ) {\n                        /* return DBI's CV, not the implementors CV (else we'd bypass dispatch) */\n                        /* and anyway, we may have hit a private method not part of the DBI     */\n                        GV *gv = gv_fetchmethod_autoload(SvSTASH(SvRV(orig_h)), can_meth, FALSE);\n                        if (gv && isGV(gv))\n                            dbi_msv = (SV*)GvCV(gv);\n                    }\n                    if (trace_level >= 1) {\n                        PerlIO *logfp = DBILOGFP;\n                        PerlIO_printf(logfp,\"    <- %s(%s) = %p (%s %p)\\n\", meth_name, can_meth, (void*)dbi_msv,\n                                (imp_msv && isGV(imp_msv)) ? HvNAME(GvSTASH(imp_msv)) : \"?\", (void*)imp_msv);\n                    }\n                    ST(0) = (dbi_msv) ? sv_2mortal(newRV_inc(dbi_msv)) : &PL_sv_undef;\n                    XSRETURN(1);\n                }\n                XSRETURN(0);\n            }\n            if (ima_flags & IMA_FUNC_REDIRECT) {\n                /* XXX this doesn't redispatch, nor consider the IMA of the new method */\n                SV *meth_name_sv = POPs;\n                PUTBACK;\n                --items;\n                if (!SvPOK(meth_name_sv) || SvNIOK(meth_name_sv))\n                    croak(\"%s->%s() invalid redirect method name %s\",\n                            neatsvpv(h,0), meth_name, neatsvpv(meth_name_sv,0));\n                meth_name = SvPV_nolen(meth_name_sv);\n                meth_type = get_meth_type(meth_name);\n                is_orig_method_name = 0;\n            }\n            if (ima_flags & IMA_KEEP_ERR)\n                keep_error = TRUE;\n            if ((ima_flags & IMA_KEEP_ERR_SUB)\n                && !PL_dirty\n                && DBIc_PARENT_COM(imp_xxh) && DBIc_CALL_DEPTH(DBIc_PARENT_COM(imp_xxh)) > 0)\n                keep_error = TRUE;\n            if (ima_flags & IMA_CLEAR_STMT) {\n                /* don't use SvOK_off: dbh's Statement may be ref to sth's */\n                (void)hv_store((HV*)SvRV(h), \"Statement\", 9, &PL_sv_undef, 0);\n            }\n            if (ima_flags & IMA_CLEAR_CACHED_KIDS)\n                clear_cached_kids(aTHX_ h, imp_xxh, meth_name, trace_flags);\n\n        }\n\n        if (ima_flags & IMA_HAS_USAGE) {\n            const char *err = NULL;\n            char msg[200];\n\n            if (ima->minargs && (items < ima->minargs\n                                || (ima->maxargs>0 && items > ima->maxargs))) {\n                sprintf(msg,\n                    \"DBI %s: invalid number of arguments: got handle + %ld, expected handle + between %d and %d\\n\",\n                    meth_name, (long)items-1, (int)ima->minargs-1, (int)ima->maxargs-1);\n                err = msg;\n            }\n            /* arg type checking could be added here later */\n            if (err) {\n                croak(\"%sUsage: %s->%s(%s)\", err, \"$h\", meth_name,\n                    (ima->usage_msg) ? ima->usage_msg : \"...?\");\n            }\n        }\n    }\n\n    is_unrelated_to_Statement = ( (DBIc_TYPE(imp_xxh) == DBIt_ST) ? 0\n                                : (DBIc_TYPE(imp_xxh) == DBIt_DR) ? 1\n                                : (ima_flags & IMA_UNRELATED_TO_STMT) );\n\n    if (PL_tainting && items > 1              /* method call has args   */\n        && DBIc_is(imp_xxh, DBIcf_TaintIn)    /* taint checks requested */\n        && !(ima_flags & IMA_NO_TAINT_IN)\n    ) {\n        for(i=1; i < items; ++i) {\n            if (SvTAINTED(ST(i))) {\n                char buf[100];\n                sprintf(buf,\"parameter %d of %s->%s method call\",\n                        i, SvPV_nolen(h), meth_name);\n                PL_tainted = 1; /* needed for TAINT_PROPER to work      */\n                TAINT_PROPER(buf);      /* die's */\n            }\n        }\n    }\n\n    /* record this inner handle for use by DBI::var::FETCH      */\n    if (is_DESTROY) {\n\n        /* force destruction of any outstanding children */\n        if ((tmp_svp = hv_fetch((HV*)SvRV(h), \"ChildHandles\", 12, FALSE)) && SvROK(*tmp_svp)) {\n            AV *av = (AV*)SvRV(*tmp_svp);\n            I32 kidslots;\n            PerlIO *logfp = DBILOGFP;\n\n            for (kidslots = AvFILL(av); kidslots >= 0; --kidslots) {\n                SV **hp = av_fetch(av, kidslots, FALSE);\n                if (!hp || !SvROK(*hp) || SvTYPE(SvRV(*hp))!=SVt_PVHV)\n                    break;\n\n                if (trace_level >= 1) {\n                    PerlIO_printf(logfp, \"on DESTROY handle %s still has child %s (refcnt %ld, obj %d, dirty=%d)\\n\",\n                        neatsvpv(h,0), neatsvpv(*hp, 0), (long)SvREFCNT(*hp), !!sv_isobject(*hp), PL_dirty);\n                    if (trace_level >= 9)\n                        sv_dump(SvRV(*hp));\n                }\n                if (sv_isobject(*hp)) { /* call DESTROY on the handle */\n                    PUSHMARK(SP);\n                    XPUSHs(*hp);\n                    PUTBACK;\n                    call_method(\"DESTROY\", G_DISCARD|G_EVAL|G_KEEPERR);\n                    MSPAGAIN;\n                }\n                else {\n                    imp_xxh_t *imp_xxh = dbih_getcom2(aTHX_ *hp, 0);\n                    if (imp_xxh && DBIc_COMSET(imp_xxh)) {\n                        dbih_clearcom(imp_xxh);\n                        sv_setsv(*hp, &PL_sv_undef);\n                    }\n                }\n            }\n        }\n\n        if (DBIc_TYPE(imp_xxh) <= DBIt_DB ) {   /* is dbh or drh */\n            imp_xxh_t *parent_imp;\n\n            if (SvOK(DBIc_ERR(imp_xxh)) && (parent_imp = DBIc_PARENT_COM(imp_xxh))\n                && !PL_dirty /* XXX - remove? */\n            ) {\n                /* copy err/errstr/state values to $DBI::err etc still work */\n                sv_setsv(DBIc_ERR(parent_imp),    DBIc_ERR(imp_xxh));\n                sv_setsv(DBIc_ERRSTR(parent_imp), DBIc_ERRSTR(imp_xxh));\n                sv_setsv(DBIc_STATE(parent_imp),  DBIc_STATE(imp_xxh));\n            }\n        }\n\n        if (DBIc_AIADESTROY(imp_xxh)) { /* wants ineffective destroy after fork */\n            if ((U32)PerlProc_getpid() != _imp2com(imp_xxh, std.pid))\n                DBIc_set(imp_xxh, DBIcf_IADESTROY, 1);\n        }\n        if (DBIc_IADESTROY(imp_xxh)) {  /* wants ineffective destroy    */\n            DBIc_ACTIVE_off(imp_xxh);\n        }\n        call_depth = 0;\n        is_nested_call = 0;\n    }\n    else {\n        DBI_SET_LAST_HANDLE(h);\n        SAVEINT(DBIc_CALL_DEPTH(imp_xxh));\n        call_depth = ++DBIc_CALL_DEPTH(imp_xxh);\n\n        if (ima_flags & IMA_COPY_UP_STMT) { /* execute() */\n            SV *parent = DBIc_PARENT_H(imp_xxh);\n            SV *tmp_sv = *hv_fetch((HV*)SvRV(h), \"Statement\", 9, 1);\n            /* XXX sv_copy() if Profiling? */\n            (void)hv_store((HV*)SvRV(parent), \"Statement\", 9, SvREFCNT_inc(tmp_sv), 0);\n        }\n        is_nested_call =\n            (call_depth > 1\n                || (!PL_dirty /* not in global destruction [CPAN #75614] */\n                    && DBIc_PARENT_COM(imp_xxh)\n                    && DBIc_CALL_DEPTH(DBIc_PARENT_COM(imp_xxh))) >= 1);\n\n    }\n\n\n    /* --- dispatch --- */\n\n    if (!keep_error && meth_type != methtype_set_err) {\n        SV *err_sv;\n        if (trace_level && SvOK(err_sv=DBIc_ERR(imp_xxh))) {\n            PerlIO *logfp = DBILOGFP;\n            PerlIO_printf(logfp, \"    !! The %s '%s' was CLEARED by call to %s method\\n\",\n                SvTRUE(err_sv) ? \"ERROR\" : strlen(SvPV_nolen(err_sv)) ? \"warn\" : \"info\",\n                neatsvpv(DBIc_ERR(imp_xxh),0), meth_name);\n        }\n        DBIh_CLEAR_ERROR(imp_xxh);\n    }\n    else {      /* we check for change in ErrCount/err_hash during call */\n        ErrCount = DBIc_ErrCount(imp_xxh);\n        if (keep_error)\n            keep_error = err_hash(aTHX_ imp_xxh);\n    }\n\n    if (DBIc_has(imp_xxh,DBIcf_Callbacks)\n        && (tmp_svp = hv_fetch((HV*)SvRV(h), \"Callbacks\", 9, 0))\n        && (   (hook_svp = hv_fetch((HV*)SvRV(*tmp_svp), meth_name, strlen(meth_name), 0))\n              /* the \"*\" fallback callback only applies to non-nested calls\n               * and also doesn't apply to the 'set_err' or DESTROY methods.\n               * Nor during global destruction.\n               * Other restrictions may be added over time.\n               * It's an undocumented hack.\n               */\n          || (!is_nested_call && !PL_dirty && meth_type != methtype_set_err &&\n               meth_type != methtype_DESTROY &&\n               (hook_svp = hv_fetch((HV*)SvRV(*tmp_svp), \"*\", 1, 0))\n             )\n        )\n        && SvROK(*hook_svp)\n    ) {\n        SV *orig_defsv;\n        SV *code = SvRV(*hook_svp);\n        I32 skip_dispatch = 0;\n        if (trace_level)\n            PerlIO_printf(DBILOGFP, \"%c   {{ %s callback %s being invoked with %ld args\\n\",\n                (PL_dirty?'!':' '), meth_name, neatsvpv(*hook_svp,0), (long)items);\n\n        /* we don't use ENTER,SAVETMPS & FREETMPS,LEAVE because we may need mortal\n         * results to live long enough to be returned to our caller\n         */\n        /* we want to localize $_ for the callback but can't just do that alone\n         * because we're not using SAVETMPS & FREETMPS, so we have to get sneaky.\n         * We still localize, so we're safe from the callback die-ing,\n         * but after the callback we manually restore the original $_.\n         */\n        orig_defsv = DEFSV; /* remember the current $_ */\n        SAVE_DEFSV;         /* local($_) = $method_name */\n        DEFSV = sv_2mortal(newSVpv(meth_name,0));\n\n        EXTEND(SP, items+1);\n        PUSHMARK(SP);\n        PUSHs(orig_h);                  /* push outer handle, then others params */\n        for (i=1; i < items; ++i) {     /* start at 1 to skip handle */\n            PUSHs( ST(i) );\n        }\n        PUTBACK;\n        outitems = call_sv(code, G_ARRAY); /* call the callback code */\n        MSPAGAIN;\n\n        /* The callback code can undef $_ to indicate to skip dispatch */\n        skip_dispatch = !SvOK(DEFSV);\n        /* put $_ back now, but with an incremented ref count to compensate\n         * for the ref count decrement that will happen when we exit the scope.\n         */\n        DEFSV = SvREFCNT_inc(orig_defsv);\n\n        if (trace_level)\n            PerlIO_printf(DBILOGFP, \"%c   }} %s callback %s returned%s\\n\",\n                (PL_dirty?'!':' '), meth_name, neatsvpv(*hook_svp,0),\n                skip_dispatch ? \", actual method will not be called\" : \"\"\n            );\n        if (skip_dispatch) {    /* XXX experimental */\n            int ix = outitems;\n            /* copy the new items down to the destination list */\n            while (ix-- > 0) {\n                if(0)warn(\"\\tcopy down %d: %s overwriting %s\\n\", ix, SvPV_nolen(TOPs), SvPV_nolen(ST(ix)) );\n                ST(ix) = POPs;\n            }\n            imp_msv = *hook_svp; /* for trace and profile */\n            goto post_dispatch;\n        }\n        else {\n            if (outitems != 0)\n                die(\"Callback for %s returned %d values but must not return any (temporary restriction in current version)\",\n                        meth_name, (int)outitems);\n            /* POP's and PUTBACK? to clear stack */\n        }\n    }\n\n    /* set Executed after Callbacks so it's not set if callback elects to skip the method */\n    if (ima_flags & IMA_EXECUTE) {\n        imp_xxh_t *parent = DBIc_PARENT_COM(imp_xxh);\n        DBIc_on(imp_xxh, DBIcf_Executed);\n        if (parent)\n            DBIc_on(parent, DBIcf_Executed);\n    }\n\n    /* The \"quick_FETCH\" logic...                                       */\n    /* Shortcut for fetching attributes to bypass method call overheads */\n    if (meth_type == methtype_FETCH && !DBIc_COMPAT(imp_xxh)) {\n        STRLEN kl;\n        const char *key = SvPV(st1, kl);\n        SV **attr_svp;\n        if (*key != '_' && (attr_svp=hv_fetch((HV*)SvRV(h), key, kl, 0))) {\n            qsv = *attr_svp;\n            /* disable FETCH from cache for special attributes */\n            if (SvROK(qsv) && SvTYPE(SvRV(qsv))==SVt_PVHV && *key=='D' &&\n                (  (kl==6 && DBIc_TYPE(imp_xxh)==DBIt_DB && strEQ(key,\"Driver\"))\n                || (kl==8 && DBIc_TYPE(imp_xxh)==DBIt_ST && strEQ(key,\"Database\")) )\n            ) {\n                qsv = Nullsv;\n            }\n            /* disable profiling of FETCH of Profile data */\n            if (*key == 'P' && strEQ(key, \"Profile\"))\n                profile_t1 = 0.0;\n        }\n        if (qsv) { /* skip real method call if we already have a 'quick' value */\n            ST(0) = sv_mortalcopy(qsv);\n            outitems = 1;\n            goto post_dispatch;\n        }\n    }\n\n    {\n        CV *meth_cv;\n#ifdef DBI_save_hv_fetch_ent\n        HE save_mh;\n        if (meth_type == methtype_FETCH)\n            save_mh = PL_hv_fetch_ent_mh; /* XXX nested tied FETCH bug17575 workaround */\n#endif\n\n        if (trace_flags) {\n            SAVEI32(DBIS->debug);       /* fall back to orig value later */\n            DBIS->debug = trace_flags;  /* make new value global (for now) */\n            if (ima) {\n                /* enabling trace via flags takes precedence over disabling due to min level */\n                if ((trace_flags & DBIc_TRACE_FLAGS_MASK) & (ima->method_trace & DBIc_TRACE_FLAGS_MASK))\n                    trace_level = (trace_level < 2) ? 2 : trace_level; /* min */\n                else\n                if (trace_level < (DBIc_TRACE_LEVEL_MASK & ima->method_trace))\n                    trace_level = 0;        /* silence dispatch log for this method */\n            }\n        }\n\n        if (is_orig_method_name\n            && ima->stash == DBIc_IMP_STASH(imp_xxh)\n            && ima->generation == PL_sub_generation +\n                                        MY_cache_gen(DBIc_IMP_STASH(imp_xxh))\n        )\n            imp_msv = (SV*)ima->gv;\n        else {\n            imp_msv = (SV*)gv_fetchmethod_autoload(DBIc_IMP_STASH(imp_xxh),\n                                            meth_name, FALSE);\n            if (is_orig_method_name) {\n                /* clear stale entry, if any */\n                SvREFCNT_dec(ima->stash);\n                SvREFCNT_dec(ima->gv);\n                if (!imp_msv) {\n                    ima->stash = NULL;\n                    ima->gv    = NULL;\n                }\n                else {\n                    ima->stash = (HV*)SvREFCNT_inc(DBIc_IMP_STASH(imp_xxh));\n                    ima->gv    = (GV*)SvREFCNT_inc(imp_msv);\n                    ima->generation = PL_sub_generation +\n                                        MY_cache_gen(DBIc_IMP_STASH(imp_xxh));\n                }\n            }\n        }\n\n        /* if method was a 'func' then try falling back to real 'func' method */\n        if (!imp_msv && (ima_flags & IMA_FUNC_REDIRECT)) {\n            imp_msv = (SV*)gv_fetchmethod_autoload(DBIc_IMP_STASH(imp_xxh), \"func\", FALSE);\n            if (imp_msv) {\n                /* driver does have func method so undo the earlier 'func' stack changes */\n                PUSHs(sv_2mortal(newSVpv(meth_name,0)));\n                PUTBACK;\n                ++items;\n                meth_name = \"func\";\n                meth_type = methtype_ordinary;\n            }\n        }\n\n        if (trace_level >= (is_nested_call ? 4 : 2)) {\n            PerlIO *logfp = DBILOGFP;\n            /* Full pkg method name (or just meth_name for ANON CODE)   */\n            const char *imp_meth_name = (imp_msv && isGV(imp_msv)) ? GvNAME(imp_msv) : meth_name;\n            HV *imp_stash = DBIc_IMP_STASH(imp_xxh);\n            PerlIO_printf(logfp, \"%c   -> %s \",\n                    call_depth>1 ? '0'+call_depth-1 : (PL_dirty?'!':' '), imp_meth_name);\n            if (imp_meth_name[0] == 'A' && strEQ(imp_meth_name,\"AUTOLOAD\"))\n                    PerlIO_printf(logfp, \"\\\"%s\\\" \", meth_name);\n            if (imp_msv && isGV(imp_msv) && GvSTASH(imp_msv) != imp_stash)\n                PerlIO_printf(logfp, \"in %s \", HvNAME(GvSTASH(imp_msv)));\n            PerlIO_printf(logfp, \"for %s (%s\", HvNAME(imp_stash),\n                        SvPV_nolen(orig_h));\n            if (h != orig_h)    /* show inner handle to aid tracing */\n                 PerlIO_printf(logfp, \"~0x%lx\", (long)SvRV(h));\n            else PerlIO_printf(logfp, \"~INNER\");\n            for(i=1; i<items; ++i) {\n                PerlIO_printf(logfp,\" %s\",\n                    (ima && i==ima->hidearg) ? \"****\" : neatsvpv(ST(i),0));\n            }\n#ifdef DBI_USE_THREADS\n            PerlIO_printf(logfp, \") thr#%p\\n\", (void*)DBIc_THR_USER(imp_xxh));\n#else\n            PerlIO_printf(logfp, \")\\n\");\n#endif\n            PerlIO_flush(logfp);\n        }\n\n        if (!imp_msv || ! ((meth_cv = GvCV(imp_msv))) ) {\n            if (PL_dirty || is_DESTROY) {\n                outitems = 0;\n                goto post_dispatch;\n            }\n            if (ima_flags & IMA_NOT_FOUND_OKAY) {\n                outitems = 0;\n                goto post_dispatch;\n            }\n            croak(\"Can't locate DBI object method \\\"%s\\\" via package \\\"%s\\\"\",\n                meth_name, HvNAME(DBIc_IMP_STASH(imp_xxh)));\n        }\n\n        PUSHMARK(mark);  /* mark arguments again so we can pass them on */\n\n        /* Note: the handle on the stack is still an object blessed into a\n         * DBI::* class and not the DBD::*::* class whose method is being\n         * invoked. This is correct and should be largely transparent.\n         */\n\n        /* SHORT-CUT ALERT! */\n        if (use_xsbypass && CvISXSUB(meth_cv) && CvXSUB(meth_cv)) {\n\n            /* If we are calling an XSUB we jump directly to its C code and\n             * bypass perl_call_sv(), pp_entersub() etc. This is fast.\n             * This code is based on a small section of pp_entersub().\n             */\n            (void)(*CvXSUB(meth_cv))(aTHXo_ meth_cv); /* Call the C code directly */\n\n            if (gimme == G_SCALAR) {    /* Enforce sanity in scalar context */\n                if (ax != PL_stack_sp - PL_stack_base ) { /* outitems != 1 */\n                    ST(0) =\n                        (ax > PL_stack_sp - PL_stack_base)\n                            ? &PL_sv_undef  /* outitems == 0 */\n                            : *PL_stack_sp; /* outitems > 1 */\n                    PL_stack_sp = PL_stack_base + ax;\n                }\n                outitems = 1;\n            }\n            else {\n                outitems = PL_stack_sp - (PL_stack_base + ax - 1);\n            }\n\n        }\n        else {\n            /* sv_dump(imp_msv); */\n            outitems = call_sv((SV*)meth_cv,\n                (is_DESTROY ? gimme | G_EVAL | G_KEEPERR : gimme) );\n        }\n\n        XSprePUSH; /* reset SP to base of stack frame */\n\n#ifdef DBI_save_hv_fetch_ent\n        if (meth_type == methtype_FETCH)\n            PL_hv_fetch_ent_mh = save_mh;       /* see start of block */\n#endif\n    }\n\n    post_dispatch:\n\n    if (is_DESTROY && DBI_IS_LAST_HANDLE(h)) { /* if destroying _this_ handle */\n        SV *lhp = DBIc_PARENT_H(imp_xxh);\n        if (lhp && SvROK(lhp)) {\n            DBI_SET_LAST_HANDLE(lhp);\n        }\n        else {\n            DBI_UNSET_LAST_HANDLE;\n        }\n    }\n\n    if (keep_error) {\n        /* if we didn't clear err before the call, check to see if a new error\n         * or warning has been recorded. If so, turn off keep_error so it gets acted on\n         */\n        if (DBIc_ErrCount(imp_xxh) > ErrCount || err_hash(aTHX_ imp_xxh) != keep_error) {\n            keep_error = 0;\n        }\n    }\n\n    err_sv = DBIc_ERR(imp_xxh);\n\n    if (trace_level >= (is_nested_call ? 3 : 1)) {\n        PerlIO *logfp = DBILOGFP;\n        const int is_fetch  = (meth_type == methtype_fetch_star && DBIc_TYPE(imp_xxh)==DBIt_ST);\n        const int row_count = (is_fetch) ? DBIc_ROW_COUNT((imp_sth_t*)imp_xxh) : 0;\n        if (is_fetch && row_count>=2 && trace_level<=4 && SvOK(ST(0))) {\n            /* skip the 'middle' rows to reduce output */\n            goto skip_meth_return_trace;\n        }\n        if (SvOK(err_sv)) {\n            PerlIO_printf(logfp, \"    %s %s %s %s (err#%ld)\\n\", (keep_error) ? \"  \" : \"!!\",\n                SvTRUE(err_sv) ? \"ERROR:\" : strlen(SvPV_nolen(err_sv)) ? \"warn:\" : \"info:\",\n                neatsvpv(err_sv,0), neatsvpv(DBIc_ERRSTR(imp_xxh),0), (long)DBIc_ErrCount(imp_xxh));\n        }\n        PerlIO_printf(logfp,\"%c%c  <%c %s\",\n                    (call_depth > 1)  ? '0'+call_depth-1 : (PL_dirty?'!':' '),\n                    (DBIc_is(imp_xxh, DBIcf_TaintIn|DBIcf_TaintOut)) ? 'T' : ' ',\n                    (qsv) ? '>' : '-',\n                    meth_name);\n        if (trace_level==1 && (items>=2||is_DESTROY)) { /* make level 1 more useful */\n            /* we only have the first two parameters available here */\n            if (is_DESTROY) /* show handle as first arg to DESTROY */\n                /* want to show outer handle so trace makes sense       */\n                /* but outer handle has been destroyed so we fake it    */\n                PerlIO_printf(logfp,\"(%s=HASH(0x%p)\", HvNAME(SvSTASH(SvRV(orig_h))), (void*)DBIc_MY_H(imp_xxh));\n            else\n                PerlIO_printf(logfp,\"(%s\", neatsvpv(st1,0));\n            if (items >= 3)\n                PerlIO_printf(logfp,\", %s\", neatsvpv(st2,0));\n            PerlIO_printf(logfp,\"%s)\", (items > 3) ? \", ...\" : \"\");\n        }\n\n        if (gimme & G_ARRAY)\n             PerlIO_printf(logfp,\"= (\");\n        else PerlIO_printf(logfp,\"=\");\n        for(i=0; i < outitems; ++i) {\n            SV *s = ST(i);\n            if ( SvROK(s) && SvTYPE(SvRV(s))==SVt_PVAV) {\n                AV *av = (AV*)SvRV(s);\n                int avi;\n                int avi_last = SvIV(DBIS->neatsvpvlen) / 10;\n                if (avi_last < 39)\n                    avi_last = 39;\n                PerlIO_printf(logfp, \" [\");\n                for (avi=0; avi <= AvFILL(av); ++avi) {\n                    PerlIO_printf(logfp, \" %s\",  neatsvpv(AvARRAY(av)[avi],0));\n                    if (avi >= avi_last && AvFILL(av) - avi > 1) {\n                        PerlIO_printf(logfp, \" ... %ld others skipped\", AvFILL(av) - avi);\n                        break;\n                    }\n                }\n                PerlIO_printf(logfp, \" ]\");\n            }\n            else {\n                PerlIO_printf(logfp, \" %s\",  neatsvpv(s,0));\n                if ( SvROK(s) && SvTYPE(SvRV(s))==SVt_PVHV && !SvOBJECT(SvRV(s)) )\n                    PerlIO_printf(logfp, \"%ldkeys\", (long)HvKEYS(SvRV(s)));\n            }\n        }\n        if (gimme & G_ARRAY) {\n            PerlIO_printf(logfp,\" ) [%d items]\", outitems);\n        }\n        if (is_fetch && row_count) {\n            PerlIO_printf(logfp,\" row%d\", row_count);\n        }\n        if (qsv) /* flag as quick and peek at the first arg (still on the stack) */\n            PerlIO_printf(logfp,\" (%s from cache)\", neatsvpv(st1,0));\n        else if (!imp_msv)\n            PerlIO_printf(logfp,\" (not implemented)\");\n        /* XXX add flag to show pid here? */\n        /* add file and line number information */\n        PerlIO_puts(logfp, log_where(0, 0, \" at \", \"\\n\", 1, (trace_level >= 3), (trace_level >= 4)));\n    skip_meth_return_trace:\n        PerlIO_flush(logfp);\n    }\n\n    if (ima_flags & IMA_END_WORK) { /* commit() or rollback() */\n        /* XXX does not consider if the method call actually worked or not */\n        DBIc_off(imp_xxh, DBIcf_Executed);\n\n        if (DBIc_has(imp_xxh, DBIcf_BegunWork)) {\n            DBIc_off(imp_xxh, DBIcf_BegunWork);\n            if (!DBIc_has(imp_xxh, DBIcf_AutoCommit)) {\n                /* We only get here if the driver hasn't implemented their own code     */\n                /* for begin_work, or has but hasn't correctly turned AutoCommit        */\n                /* back on in their commit or rollback code. So we have to do it.       */\n                /* This is bad because it'll probably trigger a spurious commit()       */\n                /* and may mess up the error handling below for the commit/rollback     */\n                PUSHMARK(SP);\n                XPUSHs(h);\n                XPUSHs(sv_2mortal(newSVpv(\"AutoCommit\",0)));\n                XPUSHs(&PL_sv_yes);\n                PUTBACK;\n                call_method(\"STORE\", G_DISCARD);\n                MSPAGAIN;\n            }\n        }\n    }\n\n    if (PL_tainting\n        && DBIc_is(imp_xxh, DBIcf_TaintOut)   /* taint checks requested */\n        /* XXX this would taint *everything* being returned from *any*  */\n        /* method that doesn't have IMA_NO_TAINT_OUT set.               */\n        /* DISABLED: just tainting fetched data in get_fbav seems ok    */\n        && 0/* XXX disabled*/ /* !(ima_flags & IMA_NO_TAINT_OUT) */\n    ) {\n        dTHR;\n        TAINT; /* affects sv_setsv()'s within same perl statement */\n        for(i=0; i < outitems; ++i) {\n            I32 avi;\n            char *p;\n            SV *s;\n            SV *agg = ST(i);\n            if ( !SvROK(agg) )\n                continue;\n            agg = SvRV(agg);\n#define DBI_OUT_TAINTABLE(s) (!SvREADONLY(s) && !SvTAINTED(s))\n            switch (SvTYPE(agg)) {\n            case SVt_PVAV:\n                for(avi=0; avi <= AvFILL((AV*)agg); ++avi) {\n                    s = AvARRAY((AV*)agg)[avi];\n                    if (DBI_OUT_TAINTABLE(s))\n                        SvTAINTED_on(s);\n                }\n                break;\n            case SVt_PVHV:\n                hv_iterinit((HV*)agg);\n                while( (s = hv_iternextsv((HV*)agg, &p, &avi)) ) {\n                    if (DBI_OUT_TAINTABLE(s))\n                        SvTAINTED_on(s);\n                }\n                break;\n            default:\n                if (DBIc_WARN(imp_xxh)) {\n                    PerlIO_printf(DBILOGFP,\"Don't know how to taint contents of returned %s (type %d)\\n\",\n                        neatsvpv(agg,0), (int)SvTYPE(agg));\n                }\n            }\n        }\n    }\n\n    /* if method returned a new handle, and that handle has an error on it\n     * then copy the error up into the parent handle\n     */\n    if (ima_flags & IMA_IS_FACTORY && SvROK(ST(0))) {\n        SV *h_new = ST(0);\n        D_impdata(imp_xxh_new, imp_xxh_t, h_new);\n        if (SvOK(DBIc_ERR(imp_xxh_new))) {\n            set_err_sv(h, imp_xxh, DBIc_ERR(imp_xxh_new), DBIc_ERRSTR(imp_xxh_new), DBIc_STATE(imp_xxh_new), &PL_sv_no);\n        }\n    }\n\n    if (   !keep_error                  /* is a new err/warn/info               */\n        && !is_nested_call              /* skip nested (internal) calls         */\n        && (\n               /* is an error and has RaiseError|PrintError|HandleError set     */\n           (SvTRUE(err_sv) && DBIc_has(imp_xxh, DBIcf_RaiseError|DBIcf_PrintError|DBIcf_HandleError))\n               /* is a warn (not info) and has PrintWarn set            */\n        || (  SvOK(err_sv) && strlen(SvPV_nolen(err_sv)) && DBIc_has(imp_xxh, DBIcf_PrintWarn))\n        )\n    ) {\n        SV *msg;\n        SV **statement_svp = NULL;\n        const int is_warning = (!SvTRUE(err_sv) && strlen(SvPV_nolen(err_sv))==1);\n        const char *err_meth_name = meth_name;\n        char intro[200];\n\n        if (meth_type == methtype_set_err) {\n            SV **sem_svp = hv_fetch((HV*)SvRV(h), \"dbi_set_err_method\", 18, GV_ADDWARN);\n            if (SvOK(*sem_svp))\n                err_meth_name = SvPV_nolen(*sem_svp);\n        }\n\n        /* XXX change to vsprintf into sv directly */\n        sprintf(intro,\"%s %s %s: \", HvNAME(DBIc_IMP_STASH(imp_xxh)), err_meth_name,\n            SvTRUE(err_sv) ? \"failed\" : is_warning ? \"warning\" : \"information\");\n        msg = sv_2mortal(newSVpv(intro,0));\n        if (SvOK(DBIc_ERRSTR(imp_xxh)))\n            sv_catsv(msg, DBIc_ERRSTR(imp_xxh));\n        else\n            sv_catpvf(msg, \"(err=%s, errstr=undef, state=%s)\",\n                neatsvpv(DBIc_ERR(imp_xxh),0), neatsvpv(DBIc_STATE(imp_xxh),0) );\n\n        if (    DBIc_has(imp_xxh, DBIcf_ShowErrorStatement)\n            && !is_unrelated_to_Statement\n            && (DBIc_TYPE(imp_xxh) == DBIt_ST || ima_flags & IMA_SHOW_ERR_STMT)\n            && (statement_svp = hv_fetch((HV*)SvRV(h), \"Statement\", 9, 0))\n            &&  statement_svp && SvOK(*statement_svp)\n        ) {\n            SV **svp = 0;\n            sv_catpv(msg, \" [for Statement \\\"\");\n            sv_catsv(msg, *statement_svp);\n\n            /* fetch from tied outer handle to trigger FETCH magic  */\n            /* could add DBIcf_ShowErrorParams (default to on?)         */\n            if (!(ima_flags & IMA_HIDE_ERR_PARAMVALUES)) {\n                svp = hv_fetch((HV*)DBIc_MY_H(imp_xxh),\"ParamValues\",11,FALSE);\n                if (svp && SvMAGICAL(*svp))\n                    mg_get(*svp); /* XXX may recurse, may croak. could use eval */\n            }\n            if (svp && SvRV(*svp) && SvTYPE(SvRV(*svp)) == SVt_PVHV && HvKEYS(SvRV(*svp))>0 ) {\n                SV *param_values_sv = sv_2mortal(_join_hash_sorted((HV*)SvRV(*svp), \"=\",1, \", \",2, 1, -1));\n                sv_catpv(msg, \"\\\" with ParamValues: \");\n                sv_catsv(msg, param_values_sv);\n                sv_catpvn(msg, \"]\", 1);\n            }\n            else {\n                sv_catpv(msg, \"\\\"]\");\n            }\n        }\n\n        if (0) {\n            COP *cop = dbi_caller_cop();\n            if (cop && (CopLINE(cop) != CopLINE(PL_curcop) || CopFILEGV(cop) != CopFILEGV(PL_curcop))) {\n                dbi_caller_string(msg, cop, \" called via \", 1, 0);\n            }\n        }\n\n        hook_svp = NULL;\n        if (    SvTRUE(err_sv)\n            &&  DBIc_has(imp_xxh, DBIcf_HandleError)\n            && (hook_svp = hv_fetch((HV*)SvRV(h),\"HandleError\",11,0))\n            &&  hook_svp && SvOK(*hook_svp)\n        ) {\n            dSP;\n            PerlIO *logfp = DBILOGFP;\n            IV items;\n            SV *status;\n            SV *result; /* point to result SV that's pointed to by the stack */\n            if (outitems) {\n                result = *(sp-outitems+1);\n                if (SvREADONLY(result)) {\n                    *(sp-outitems+1) = result = sv_2mortal(newSVsv(result));\n                }\n            }\n            else {\n                result = sv_newmortal();\n            }\n            if (trace_level)\n                PerlIO_printf(logfp,\"    -> HandleError on %s via %s%s%s%s\\n\",\n                    neatsvpv(h,0), neatsvpv(*hook_svp,0),\n                    (!outitems ? \"\" : \" (\"),\n                    (!outitems ? \"\" : neatsvpv(result ,0)),\n                    (!outitems ? \"\" : \")\")\n                );\n            PUSHMARK(SP);\n            XPUSHs(msg);\n            XPUSHs(sv_2mortal(newRV_inc((SV*)DBIc_MY_H(imp_xxh))));\n            XPUSHs( result );\n            PUTBACK;\n            items = call_sv(*hook_svp, G_SCALAR);\n            MSPAGAIN;\n            status = (items) ? POPs : &PL_sv_undef;\n            PUTBACK;\n            if (trace_level)\n                PerlIO_printf(logfp,\"    <- HandleError= %s%s%s%s\\n\",\n                    neatsvpv(status,0),\n                    (!outitems ? \"\" : \" (\"),\n                    (!outitems ? \"\" : neatsvpv(result,0)),\n                    (!outitems ? \"\" : \")\")\n                );\n            if (!SvTRUE(status)) /* handler says it didn't handle it, so... */\n                hook_svp = 0;  /* pretend we didn't have a handler...     */\n        }\n\n        if (profile_t1) { /* see also dbi_profile() call a few lines below */\n            SV *statement_sv = (is_unrelated_to_Statement) ? &PL_sv_no : &PL_sv_undef;\n            dbi_profile(h, imp_xxh, statement_sv, imp_msv ? imp_msv : (SV*)cv,\n                profile_t1, dbi_time());\n        }\n        if (is_warning) {\n            if (DBIc_has(imp_xxh, DBIcf_PrintWarn))\n                warn(\"%s\", SvPV_nolen(msg));\n        }\n        else if (!hook_svp && SvTRUE(err_sv)) {\n            if (DBIc_has(imp_xxh, DBIcf_PrintError))\n                warn(\"%s\", SvPV_nolen(msg));\n            if (DBIc_has(imp_xxh, DBIcf_RaiseError))\n                croak(\"%s\", SvPV_nolen(msg));\n        }\n    }\n    else if (profile_t1) { /* see also dbi_profile() call a few lines above */\n        SV *statement_sv = (is_unrelated_to_Statement) ? &PL_sv_no : &PL_sv_undef;\n        dbi_profile(h, imp_xxh, statement_sv, imp_msv ? imp_msv : (SV*)cv,\n                profile_t1, dbi_time());\n    }\n    XSRETURN(outitems);\n}\n\n\n\n/* -------------------------------------------------------------------- */\n\n/* comment and placeholder styles to accept and return */\n\n#define DBIpp_cm_cs 0x000001   /* C style */\n#define DBIpp_cm_hs 0x000002   /* #       */\n#define DBIpp_cm_dd 0x000004   /* --      */\n#define DBIpp_cm_br 0x000008   /* {}      */\n#define DBIpp_cm_dw 0x000010   /* '-- ' dash dash whitespace */\n#define DBIpp_cm_XX 0x00001F   /* any of the above */\n\n#define DBIpp_ph_qm 0x000100   /* ?       */\n#define DBIpp_ph_cn 0x000200   /* :1      */\n#define DBIpp_ph_cs 0x000400   /* :name   */\n#define DBIpp_ph_sp 0x000800   /* %s (as return only, not accept)    */\n#define DBIpp_ph_XX 0x000F00   /* any of the above */\n\n#define DBIpp_st_qq 0x010000   /* '' char escape */\n#define DBIpp_st_bs 0x020000   /* \\  char escape */\n#define DBIpp_st_XX 0x030000   /* any of the above */\n\n#define DBIpp_L_BRACE '{'\n#define DBIpp_R_BRACE '}'\n#define PS_accept(flag)  DBIbf_has(ps_accept,(flag))\n#define PS_return(flag)  DBIbf_has(ps_return,(flag))\n\nSV *\npreparse(SV *dbh, const char *statement, IV ps_return, IV ps_accept, void *foo)\n{\n    dTHX;\n    D_imp_xxh(dbh);\n/*\n        The idea here is that ps_accept defines which constructs to\n        recognize (accept) as valid in the source string (other\n        constructs are ignored), and ps_return defines which\n        constructs are valid to return in the result string.\n\n        If a construct that is valid in the input is also valid in the\n        output then it's simply copied. If it's not valid in the output\n        then it's editied into one of the valid forms (ideally the most\n        'standard' and/or information preserving one).\n\n        For example, if ps_accept includes '--' style comments but\n        ps_return doesn't, but ps_return does include '#' style\n        comments then any '--' style comments would be rewritten as '#'\n        style comments.\n\n        Similarly for placeholders. DBD::Oracle, for example, would say\n        '?', ':1' and ':name' are all acceptable input, but only\n        ':name' should be returned.\n\n        (There's a tricky issue with the '--' comment style because it can\n        clash with valid syntax, i.e., \"... set foo=foo--1 ...\" so it\n        would be *bad* to misinterpret that as the start of a comment.\n        Perhaps we need a DBIpp_cm_dw (for dash-dash-whitespace) style\n        to allow for that.)\n\n        Also, we'll only support DBIpp_cm_br as an input style. And\n        even then, only with reluctance. We may (need to) drop it when\n        we add support for odbc escape sequences.\n*/\n    int idx = 1;\n\n    char in_quote = '\\0';\n    char in_comment = '\\0';\n    char rt_comment = '\\0';\n    char *dest, *start;\n    const char *src;\n    const char *style = \"\", *laststyle = '\\0';\n    SV *new_stmt_sv;\n\n    (void)foo;\n\n    if (!(ps_return | DBIpp_ph_XX)) { /* no return ph type specified */\n        ps_return |= ps_accept | DBIpp_ph_XX;   /* so copy from ps_accept */\n    }\n\n    /* XXX this allocation strategy won't work when we get to more advanced stuff */\n    new_stmt_sv = newSV(strlen(statement) * 3);\n    sv_setpv(new_stmt_sv,\"\");\n    src  = statement;\n    dest = SvPVX(new_stmt_sv);\n\n    while( *src )\n    {\n        if (*src == '%' && PS_return(DBIpp_ph_sp))\n            *dest++ = '%';\n\n        if (in_comment)\n        {\n             if (       (in_comment == '-' && (*src == '\\n' || *(src+1) == '\\0'))\n                ||      (in_comment == '#' && (*src == '\\n' || *(src+1) == '\\0'))\n                ||      (in_comment == DBIpp_L_BRACE && *src == DBIpp_R_BRACE) /* XXX nesting? */\n                ||      (in_comment == '/' && *src == '*' && *(src+1) == '/')\n             ) {\n                switch (rt_comment) {\n                case '/':       *dest++ = '*'; *dest++ = '/';   break;\n                case '-':       *dest++ = '\\n';                 break;\n                case '#':       *dest++ = '\\n';                 break;\n                case DBIpp_L_BRACE: *dest++ = DBIpp_R_BRACE;    break;\n                case '\\0':      /* ensure deleting a comment doesn't join two tokens */\n                        if (in_comment=='/' || in_comment==DBIpp_L_BRACE)\n                            *dest++ = ' '; /* ('-' and '#' styles use the newline) */\n                        break;\n                }\n                if (in_comment == '/')\n                    src++;\n                src += (*src != '\\n' || *(dest-1)=='\\n') ? 1 : 0;\n                in_comment = '\\0';\n                rt_comment = '\\0';\n             }\n             else\n             if (rt_comment)\n                *dest++ = *src++;\n             else\n                src++;  /* delete (don't copy) the comment */\n             continue;\n        }\n\n        if (in_quote)\n        {\n            if (*src == in_quote) {\n                in_quote = 0;\n            }\n            *dest++ = *src++;\n            continue;\n        }\n\n        /* Look for comments */\n        if (*src == '-' && *(src+1) == '-' &&\n                (PS_accept(DBIpp_cm_dd) || (*(src+2) == ' ' && PS_accept(DBIpp_cm_dw)))\n        )\n        {\n            in_comment = *src;\n            src += 2;   /* skip past 2nd char of double char delimiters */\n            if (PS_return(DBIpp_cm_dd) || PS_return(DBIpp_cm_dw)) {\n                *dest++ = rt_comment = '-';\n                *dest++ = '-';\n                if (PS_return(DBIpp_cm_dw) && *src!=' ')\n                    *dest++ = ' '; /* insert needed white space */\n            }\n            else if (PS_return(DBIpp_cm_cs)) {\n                *dest++ = rt_comment = '/';\n                *dest++ = '*';\n            }\n            else if (PS_return(DBIpp_cm_hs)) {\n                *dest++ = rt_comment = '#';\n            }\n            else if (PS_return(DBIpp_cm_br)) {\n                *dest++ = rt_comment = DBIpp_L_BRACE;\n            }\n            continue;\n        }\n        else if (*src == '/' && *(src+1) == '*' && PS_accept(DBIpp_cm_cs))\n        {\n            in_comment = *src;\n            src += 2;   /* skip past 2nd char of double char delimiters */\n            if (PS_return(DBIpp_cm_cs)) {\n                *dest++ = rt_comment = '/';\n                *dest++ = '*';\n            }\n            else if (PS_return(DBIpp_cm_dd) || PS_return(DBIpp_cm_dw)) {\n                *dest++ = rt_comment = '-';\n                *dest++ = '-';\n                if (PS_return(DBIpp_cm_dw)) *dest++ = ' ';\n            }\n            else if (PS_return(DBIpp_cm_hs)) {\n                *dest++ = rt_comment = '#';\n            }\n            else if (PS_return(DBIpp_cm_br)) {\n                *dest++ = rt_comment = DBIpp_L_BRACE;\n            }\n            continue;\n        }\n        else if (*src == '#' && PS_accept(DBIpp_cm_hs))\n        {\n            in_comment = *src;\n            src++;\n            if (PS_return(DBIpp_cm_hs)) {\n                *dest++ = rt_comment = '#';\n            }\n            else if (PS_return(DBIpp_cm_dd) || PS_return(DBIpp_cm_dw)) {\n                *dest++ = rt_comment = '-';\n                *dest++ = '-';\n                if (PS_return(DBIpp_cm_dw)) *dest++ = ' ';\n            }\n            else if (PS_return(DBIpp_cm_cs)) {\n                *dest++ = rt_comment = '/';\n                *dest++ = '*';\n            }\n            else if (PS_return(DBIpp_cm_br)) {\n                *dest++ = rt_comment = DBIpp_L_BRACE;\n            }\n            continue;\n        }\n        else if (*src == DBIpp_L_BRACE && PS_accept(DBIpp_cm_br))\n        {\n            in_comment = *src;\n            src++;\n            if (PS_return(DBIpp_cm_br)) {\n                *dest++ = rt_comment = DBIpp_L_BRACE;\n            }\n            else if (PS_return(DBIpp_cm_dd) || PS_return(DBIpp_cm_dw)) {\n                *dest++ = rt_comment = '-';\n                *dest++ = '-';\n                if (PS_return(DBIpp_cm_dw)) *dest++ = ' ';\n            }\n            else if (PS_return(DBIpp_cm_cs)) {\n                *dest++ = rt_comment = '/';\n                *dest++ = '*';\n            }\n            else if (PS_return(DBIpp_cm_hs)) {\n                *dest++ = rt_comment = '#';\n            }\n            continue;\n        }\n\n       if (    !(*src==':' && (PS_accept(DBIpp_ph_cn) || PS_accept(DBIpp_ph_cs)))\n           &&  !(*src=='?' &&  PS_accept(DBIpp_ph_qm))\n       ){\n            if (*src == '\\'' || *src == '\"')\n                in_quote = *src;\n            *dest++ = *src++;\n            continue;\n        }\n\n        /* only here for : or ? outside of a comment or literal */\n\n        start = dest;                   /* save name inc colon  */\n        *dest++ = *src++;               /* copy and move past first char */\n\n        if (*start == '?')              /* X/Open Standard */\n        {\n            style = \"?\";\n\n            if (PS_return(DBIpp_ph_qm))\n                ;\n            else if (PS_return(DBIpp_ph_cn)) { /* '?' -> ':p1' (etc) */\n                sprintf(start,\":p%d\", idx++);\n                dest = start+strlen(start);\n            }\n            else if (PS_return(DBIpp_ph_sp)) { /* '?' -> '%s' */\n                   *start  = '%';\n                   *dest++ = 's';\n            }\n        }\n        else if (isDIGIT(*src)) {   /* :1 */\n            const int pln = atoi(src);\n            style = \":1\";\n\n            if (PS_return(DBIpp_ph_cn)) { /* ':1'->':p1'  */\n                   idx = pln;\n                   *dest++ = 'p';\n                   while(isDIGIT(*src))\n                       *dest++ = *src++;\n            }\n            else if (PS_return(DBIpp_ph_qm) /* ':1' -> '?'  */\n                 ||  PS_return(DBIpp_ph_sp) /* ':1' -> '%s' */\n            ) {\n                   PS_return(DBIpp_ph_qm) ? sprintf(start,\"?\") : sprintf(start,\"%%s\");\n                   dest = start + strlen(start);\n                   if (pln != idx) {\n                        char buf[99];\n                        sprintf(buf, \"preparse found placeholder :%d out of sequence, expected :%d\", pln, idx);\n                        set_err_char(dbh, imp_xxh, \"1\", 1, buf, 0, \"preparse\");\n                        return &PL_sv_undef;\n                   }\n                   while(isDIGIT(*src)) src++;\n                   idx++;\n            }\n        }\n        else if (isALNUM(*src))         /* :name */\n        {\n            style = \":name\";\n\n            if (PS_return(DBIpp_ph_cs)) {\n                ;\n            }\n            else if (PS_return(DBIpp_ph_qm) /* ':name' -> '?'  */\n                 ||  PS_return(DBIpp_ph_sp) /* ':name' -> '%s' */\n            ) {\n                PS_return(DBIpp_ph_qm) ? sprintf(start,\"?\") : sprintf(start,\"%%s\");\n                dest = start + strlen(start);\n                while (isALNUM(*src))   /* consume name, includes '_'   */\n                    src++;\n            }\n        }\n        /* perhaps ':=' PL/SQL construct */\n        else { continue; }\n\n        *dest = '\\0';                   /* handy for debugging  */\n\n        if (laststyle && style != laststyle) {\n            char buf[99];\n            sprintf(buf, \"preparse found mixed placeholder styles (%s / %s)\", style, laststyle);\n            set_err_char(dbh, imp_xxh, \"1\", 1, buf, 0, \"preparse\");\n            return &PL_sv_undef;\n        }\n        laststyle = style;\n    }\n    *dest = '\\0';\n\n    /* warn about probable parsing errors, but continue anyway (returning processed string) */\n    switch (in_quote)\n    {\n    case '\\'':\n            set_err_char(dbh, imp_xxh, \"1\", 1, \"preparse found unterminated single-quoted string\", 0, \"preparse\");\n            break;\n    case '\\\"':\n            set_err_char(dbh, imp_xxh, \"1\", 1, \"preparse found unterminated double-quoted string\", 0, \"preparse\");\n            break;\n    }\n    switch (in_comment)\n    {\n    case DBIpp_L_BRACE:\n            set_err_char(dbh, imp_xxh, \"1\", 1, \"preparse found unterminated bracketed {...} comment\", 0, \"preparse\");\n            break;\n    case '/':\n            set_err_char(dbh, imp_xxh, \"1\", 1, \"preparse found unterminated bracketed C-style comment\", 0, \"preparse\");\n            break;\n    }\n\n    SvCUR_set(new_stmt_sv, strlen(SvPVX(new_stmt_sv)));\n    *SvEND(new_stmt_sv) = '\\0';\n    return new_stmt_sv;\n}\n\n\n/* -------------------------------------------------------------------- */\n/* The DBI Perl interface (via XS) starts here. Currently these are     */\n/* all internal support functions. Note install_method and see DBI.pm   */\n\nMODULE = DBI   PACKAGE = DBI\n\nREQUIRE:    1.929\nPROTOTYPES: DISABLE\n\n\nBOOT:\n    {\n        MY_CXT_INIT;\n        PERL_UNUSED_VAR(MY_CXT);\n    }\n    PERL_UNUSED_VAR(cv);\n    PERL_UNUSED_VAR(items);\n    dbi_bootinit(NULL);\n    /* make this sub into a fake XS so it can bee seen by DBD::* modules;\n     * never actually call it as an XS sub, or it will crash and burn! */\n    (void) newXS(\"DBI::_dbi_state_lval\", (XSUBADDR_t)_dbi_state_lval, __FILE__);\n\n\nI32\nconstant()\n        PROTOTYPE:\n    ALIAS:\n        SQL_ALL_TYPES                    = SQL_ALL_TYPES\n        SQL_ARRAY                        = SQL_ARRAY\n        SQL_ARRAY_LOCATOR                = SQL_ARRAY_LOCATOR\n        SQL_BIGINT                       = SQL_BIGINT\n        SQL_BINARY                       = SQL_BINARY\n        SQL_BIT                          = SQL_BIT\n        SQL_BLOB                         = SQL_BLOB\n        SQL_BLOB_LOCATOR                 = SQL_BLOB_LOCATOR\n        SQL_BOOLEAN                      = SQL_BOOLEAN\n        SQL_CHAR                         = SQL_CHAR\n        SQL_CLOB                         = SQL_CLOB\n        SQL_CLOB_LOCATOR                 = SQL_CLOB_LOCATOR\n        SQL_DATE                         = SQL_DATE\n        SQL_DATETIME                     = SQL_DATETIME\n        SQL_DECIMAL                      = SQL_DECIMAL\n        SQL_DOUBLE                       = SQL_DOUBLE\n        SQL_FLOAT                        = SQL_FLOAT\n        SQL_GUID                         = SQL_GUID\n        SQL_INTEGER                      = SQL_INTEGER\n        SQL_INTERVAL                     = SQL_INTERVAL\n        SQL_INTERVAL_DAY                 = SQL_INTERVAL_DAY\n        SQL_INTERVAL_DAY_TO_HOUR         = SQL_INTERVAL_DAY_TO_HOUR\n        SQL_INTERVAL_DAY_TO_MINUTE       = SQL_INTERVAL_DAY_TO_MINUTE\n        SQL_INTERVAL_DAY_TO_SECOND       = SQL_INTERVAL_DAY_TO_SECOND\n        SQL_INTERVAL_HOUR                = SQL_INTERVAL_HOUR\n        SQL_INTERVAL_HOUR_TO_MINUTE      = SQL_INTERVAL_HOUR_TO_MINUTE\n        SQL_INTERVAL_HOUR_TO_SECOND      = SQL_INTERVAL_HOUR_TO_SECOND\n        SQL_INTERVAL_MINUTE              = SQL_INTERVAL_MINUTE\n        SQL_INTERVAL_MINUTE_TO_SECOND    = SQL_INTERVAL_MINUTE_TO_SECOND\n        SQL_INTERVAL_MONTH               = SQL_INTERVAL_MONTH\n        SQL_INTERVAL_SECOND              = SQL_INTERVAL_SECOND\n        SQL_INTERVAL_YEAR                = SQL_INTERVAL_YEAR\n        SQL_INTERVAL_YEAR_TO_MONTH       = SQL_INTERVAL_YEAR_TO_MONTH\n        SQL_LONGVARBINARY                = SQL_LONGVARBINARY\n        SQL_LONGVARCHAR                  = SQL_LONGVARCHAR\n        SQL_MULTISET                     = SQL_MULTISET\n        SQL_MULTISET_LOCATOR             = SQL_MULTISET_LOCATOR\n        SQL_NUMERIC                      = SQL_NUMERIC\n        SQL_REAL                         = SQL_REAL\n        SQL_REF                          = SQL_REF\n        SQL_ROW                          = SQL_ROW\n        SQL_SMALLINT                     = SQL_SMALLINT\n        SQL_TIME                         = SQL_TIME\n        SQL_TIMESTAMP                    = SQL_TIMESTAMP\n        SQL_TINYINT                      = SQL_TINYINT\n        SQL_TYPE_DATE                    = SQL_TYPE_DATE\n        SQL_TYPE_TIME                    = SQL_TYPE_TIME\n        SQL_TYPE_TIMESTAMP               = SQL_TYPE_TIMESTAMP\n        SQL_TYPE_TIMESTAMP_WITH_TIMEZONE = SQL_TYPE_TIMESTAMP_WITH_TIMEZONE\n        SQL_TYPE_TIME_WITH_TIMEZONE      = SQL_TYPE_TIME_WITH_TIMEZONE\n        SQL_UDT                          = SQL_UDT\n        SQL_UDT_LOCATOR                  = SQL_UDT_LOCATOR\n        SQL_UNKNOWN_TYPE                 = SQL_UNKNOWN_TYPE\n        SQL_VARBINARY                    = SQL_VARBINARY\n        SQL_VARCHAR                      = SQL_VARCHAR\n        SQL_WCHAR                        = SQL_WCHAR\n        SQL_WLONGVARCHAR                 = SQL_WLONGVARCHAR\n        SQL_WVARCHAR                     = SQL_WVARCHAR\n        SQL_CURSOR_FORWARD_ONLY          = SQL_CURSOR_FORWARD_ONLY\n        SQL_CURSOR_KEYSET_DRIVEN         = SQL_CURSOR_KEYSET_DRIVEN\n        SQL_CURSOR_DYNAMIC               = SQL_CURSOR_DYNAMIC\n        SQL_CURSOR_STATIC                = SQL_CURSOR_STATIC\n        SQL_CURSOR_TYPE_DEFAULT          = SQL_CURSOR_TYPE_DEFAULT\n        DBIpp_cm_cs     = DBIpp_cm_cs\n        DBIpp_cm_hs     = DBIpp_cm_hs\n        DBIpp_cm_dd     = DBIpp_cm_dd\n        DBIpp_cm_dw     = DBIpp_cm_dw\n        DBIpp_cm_br     = DBIpp_cm_br\n        DBIpp_cm_XX     = DBIpp_cm_XX\n        DBIpp_ph_qm     = DBIpp_ph_qm\n        DBIpp_ph_cn     = DBIpp_ph_cn\n        DBIpp_ph_cs     = DBIpp_ph_cs\n        DBIpp_ph_sp     = DBIpp_ph_sp\n        DBIpp_ph_XX     = DBIpp_ph_XX\n        DBIpp_st_qq     = DBIpp_st_qq\n        DBIpp_st_bs     = DBIpp_st_bs\n        DBIpp_st_XX     = DBIpp_st_XX\n        DBIstcf_DISCARD_STRING  = DBIstcf_DISCARD_STRING\n        DBIstcf_STRICT          = DBIstcf_STRICT\n        DBIf_TRACE_SQL  = DBIf_TRACE_SQL\n        DBIf_TRACE_CON  = DBIf_TRACE_CON\n        DBIf_TRACE_ENC  = DBIf_TRACE_ENC\n        DBIf_TRACE_DBD  = DBIf_TRACE_DBD\n        DBIf_TRACE_TXN  = DBIf_TRACE_TXN\n    CODE:\n    RETVAL = ix;\n    OUTPUT:\n    RETVAL\n\n\nvoid\n_clone_dbis()\n    CODE:\n    dMY_CXT;\n    dbistate_t * parent_dbis = DBIS;\n\n    (void)cv;\n    {\n        MY_CXT_CLONE;\n    }\n    dbi_bootinit(parent_dbis);\n\n\nvoid\n_new_handle(class, parent, attr_ref, imp_datasv, imp_class)\n    SV *        class\n    SV *        parent\n    SV *        attr_ref\n    SV *        imp_datasv\n    SV *        imp_class\n    PPCODE:\n    dMY_CXT;\n    HV *outer;\n    SV *outer_ref;\n    HV *class_stash = gv_stashsv(class, GV_ADDWARN);\n\n    if (DBIS_TRACE_LEVEL >= 5) {\n        PerlIO_printf(DBILOGFP, \"    New %s (for %s, parent=%s, id=%s)\\n\",\n            neatsvpv(class,0), SvPV_nolen(imp_class), neatsvpv(parent,0), neatsvpv(imp_datasv,0));\n        PERL_UNUSED_VAR(cv);\n    }\n\n    (void)hv_store((HV*)SvRV(attr_ref), \"ImplementorClass\", 16, SvREFCNT_inc(imp_class), 0);\n\n    /* make attr into inner handle by blessing it into class */\n    sv_bless(attr_ref, class_stash);\n    /* tie new outer hash to inner handle */\n    outer = newHV(); /* create new hash to be outer handle */\n    outer_ref = newRV_noinc((SV*)outer);\n    /* make outer hash into a handle by blessing it into class */\n    sv_bless(outer_ref, class_stash);\n    /* tie outer handle to inner handle */\n    sv_magic((SV*)outer, attr_ref, PERL_MAGIC_tied, Nullch, 0);\n\n    dbih_setup_handle(aTHX_ outer_ref, SvPV_nolen(imp_class), parent, SvOK(imp_datasv) ? imp_datasv : Nullsv);\n\n    /* return outer handle, plus inner handle if not in scalar context */\n    sv_2mortal(outer_ref);\n    EXTEND(SP, 2);\n    PUSHs(outer_ref);\n    if (GIMME != G_SCALAR) {\n        PUSHs(attr_ref);\n    }\n\n\nvoid\n_setup_handle(sv, imp_class, parent, imp_datasv)\n    SV *        sv\n    char *      imp_class\n    SV *        parent\n    SV *        imp_datasv\n    CODE:\n    (void)cv;\n    dbih_setup_handle(aTHX_ sv, imp_class, parent, SvOK(imp_datasv) ? imp_datasv : Nullsv);\n    ST(0) = &PL_sv_undef;\n\n\nvoid\n_get_imp_data(sv)\n    SV *        sv\n    CODE:\n    D_imp_xxh(sv);\n    (void)cv;\n    ST(0) = sv_mortalcopy(DBIc_IMP_DATA(imp_xxh)); /* okay if NULL      */\n\n\nvoid\n_handles(sv)\n    SV *        sv\n    PPCODE:\n    /* return the outer and inner handle for any given handle */\n    D_imp_xxh(sv);\n    SV *ih = sv_mortalcopy( dbih_inner(aTHX_ sv, \"_handles\") );\n    SV *oh = sv_2mortal(newRV_inc((SV*)DBIc_MY_H(imp_xxh))); /* XXX dangerous */\n    (void)cv;\n    EXTEND(SP, 2);\n    PUSHs(oh);  /* returns outer handle then inner */\n    if (GIMME != G_SCALAR) {\n        PUSHs(ih);\n    }\n\n\nvoid\nneat(sv, maxlen=0)\n    SV *        sv\n    U32 maxlen\n    CODE:\n    ST(0) = sv_2mortal(newSVpv(neatsvpv(sv, maxlen), 0));\n    (void)cv;\n\n\nI32\nhash(key, type=0)\n    const char *key\n    long type\n    CODE:\n    (void)cv;\n    RETVAL = dbi_hash(key, type);\n    OUTPUT:\n    RETVAL\n\nvoid\nlooks_like_number(...)\n    PPCODE:\n    int i;\n    EXTEND(SP, items);\n    (void)cv;\n    for(i=0; i < items ; ++i) {\n        SV *sv = ST(i);\n        if (!SvOK(sv) || (SvPOK(sv) && SvCUR(sv)==0))\n            PUSHs(&PL_sv_undef);\n        else if ( looks_like_number(sv) )\n            PUSHs(&PL_sv_yes);\n        else\n            PUSHs(&PL_sv_no);\n    }\n\n\nvoid\n_install_method(dbi_class, meth_name, file, attribs=Nullsv)\n    const char *        dbi_class\n    char *      meth_name\n    char *      file\n    SV *        attribs\n    CODE:\n    {\n    dMY_CXT;\n    /* install another method name/interface for the DBI dispatcher     */\n    SV *trace_msg = (DBIS_TRACE_LEVEL >= 10) ? sv_2mortal(newSVpv(\"\",0)) : Nullsv;\n    CV *cv;\n    SV **svp;\n    dbi_ima_t *ima;\n    MAGIC *mg;\n    (void)dbi_class;\n\n    if (strnNE(meth_name, \"DBI::\", 5))  /* XXX m/^DBI::\\w+::\\w+$/       */\n        croak(\"install_method %s: invalid class\", meth_name);\n\n    if (trace_msg)\n        sv_catpvf(trace_msg, \"install_method %-21s\", meth_name);\n\n    Newxz(ima, 1, dbi_ima_t);\n\n    if (attribs && SvOK(attribs)) {\n        /* convert and store method attributes in a fast access form    */\n        if (SvTYPE(SvRV(attribs)) != SVt_PVHV)\n            croak(\"install_method %s: bad attribs\", meth_name);\n\n        DBD_ATTRIB_GET_IV(attribs, \"O\",1, svp, ima->flags);\n        DBD_ATTRIB_GET_UV(attribs, \"T\",1, svp, ima->method_trace);\n        DBD_ATTRIB_GET_IV(attribs, \"H\",1, svp, ima->hidearg);\n\n        if (trace_msg) {\n            if (ima->flags)       sv_catpvf(trace_msg, \", flags 0x%04x\", (unsigned)ima->flags);\n            if (ima->method_trace)sv_catpvf(trace_msg, \", T 0x%08lx\", (unsigned long)ima->method_trace);\n            if (ima->hidearg)     sv_catpvf(trace_msg, \", H %u\", (unsigned)ima->hidearg);\n        }\n        if ( (svp=DBD_ATTRIB_GET_SVP(attribs, \"U\",1)) != NULL) {\n            AV *av = (AV*)SvRV(*svp);\n            ima->minargs = (U8)SvIV(*av_fetch(av, 0, 1));\n            ima->maxargs = (U8)SvIV(*av_fetch(av, 1, 1));\n            svp = av_fetch(av, 2, 0);\n            ima->usage_msg = (svp) ? savepv_using_sv(SvPV_nolen(*svp)) : \"\";\n            ima->flags |= IMA_HAS_USAGE;\n            if (trace_msg && DBIS_TRACE_LEVEL >= 11)\n                sv_catpvf(trace_msg, \",\\n    usage: min %d, max %d, '%s'\",\n                        ima->minargs, ima->maxargs, ima->usage_msg);\n        }\n    }\n    if (trace_msg)\n        PerlIO_printf(DBILOGFP,\"%s\\n\", SvPV_nolen(trace_msg));\n    file = savepv(file);\n    cv = newXS(meth_name, XS_DBI_dispatch, file);\n    SvPVX((SV *)cv) = file;\n    SvLEN((SV *)cv) = 1;\n    CvXSUBANY(cv).any_ptr = ima;\n    ima->meth_type = get_meth_type(GvNAME(CvGV(cv)));\n\n    /* Attach magic to handle duping and freeing of the dbi_ima_t struct.\n     * Due to the poor interface of the mg dup function, sneak a pointer\n     * to the original CV in the mg_ptr field (we get called with a\n     * pointer to the mg, but not the SV) */\n    mg = sv_magicext((SV*)cv, NULL, DBI_MAGIC, &dbi_ima_vtbl,\n                        (char *)cv, 0);\n#ifdef BROKEN_DUP_ANY_PTR\n    ima->my_perl = my_perl; /* who owns this struct */\n#else\n    mg->mg_flags |= MGf_DUP;\n#endif\n    ST(0) = &PL_sv_yes;\n    }\n\n\nint\ntrace(class, level_sv=&PL_sv_undef, file=Nullsv)\n    SV *        class\n    SV *        level_sv\n    SV *        file\n    ALIAS:\n    _debug_dispatch = 1\n    CODE:\n    {\n    dMY_CXT;\n    IV level;\n    if (!DBIS) {\n        PERL_UNUSED_VAR(ix);\n        croak(\"DBI not initialised\");\n    }\n    /* Return old/current value. No change if new value not given.      */\n    RETVAL = (DBIS) ? DBIS->debug : 0;\n    level = parse_trace_flags(class, level_sv, RETVAL);\n    if (level)          /* call before or after altering DBI trace level */\n        set_trace_file(file);\n    if (level != RETVAL) {\n        if ((level & DBIc_TRACE_LEVEL_MASK) > 0) {\n            PerlIO_printf(DBILOGFP,\"    DBI %s%s default trace level set to 0x%lx/%ld (pid %d pi %p) at %s\\n\",\n                XS_VERSION, dbi_build_opt,\n                (long)(level & DBIc_TRACE_FLAGS_MASK),\n                (long)(level & DBIc_TRACE_LEVEL_MASK),\n                (int)PerlProc_getpid(),\n#ifdef MULTIPLICITY\n                (void *)my_perl,\n#else\n                (void*)NULL,\n#endif\n                log_where(Nullsv, 0, \"\", \"\", 1, 1, 0)\n            );\n            if (!PL_dowarn)\n                PerlIO_printf(DBILOGFP,\"    Note: perl is running without the recommended perl -w option\\n\");\n            PerlIO_flush(DBILOGFP);\n        }\n        DBIS->debug = level;\n        sv_setiv(get_sv(\"DBI::dbi_debug\",0x5), level);\n    }\n    if (!level)         /* call before or after altering DBI trace level */\n        set_trace_file(file);\n    }\n    OUTPUT:\n    RETVAL\n\n\n\nvoid\ndump_handle(sv, msg=\"DBI::dump_handle\", level=0)\n    SV *        sv\n    const char *msg\n    int         level\n    CODE:\n    (void)cv;\n    dbih_dumphandle(aTHX_ sv, msg, level);\n\n\n\nvoid\n_svdump(sv)\n    SV *        sv\n    CODE:\n    {\n    dMY_CXT;\n    (void)cv;\n    PerlIO_printf(DBILOGFP, \"DBI::_svdump(%s)\", neatsvpv(sv,0));\n#ifdef DEBUGGING\n    sv_dump(sv);\n#endif\n    }\n\n\nNV\ndbi_time()\n\n\nvoid\ndbi_profile(h, statement, method, t1, t2)\n    SV *h\n    SV *statement\n    SV *method\n    NV t1\n    NV t2\n    CODE:\n    SV *leaf = &PL_sv_undef;\n    PERL_UNUSED_VAR(cv);\n    if (SvROK(method))\n        method = SvRV(method);\n    if (dbih_inner(aTHX_ h, NULL)) {    /* is a DBI handle */\n        D_imp_xxh(h);\n        leaf = dbi_profile(h, imp_xxh, statement, method, t1, t2);\n    }\n    else if (SvROK(h) && SvTYPE(SvRV(h)) == SVt_PVHV) {\n        /* iterate over values %$h */\n        HV *hv = (HV*)SvRV(h);\n        SV *tmp;\n        char *key;\n        I32 keylen = 0;\n        hv_iterinit(hv);\n        while ( (tmp = hv_iternextsv(hv, &key, &keylen)) != NULL ) {\n            if (SvOK(tmp)) {\n                D_imp_xxh(tmp);\n                leaf = dbi_profile(tmp, imp_xxh, statement, method, t1, t2);\n            }\n        };\n    }\n    else {\n        croak(\"dbi_profile(%s,...) invalid handle argument\", neatsvpv(h,0));\n    }\n    if (GIMME_V == G_VOID)\n        ST(0) = &PL_sv_undef;  /* skip sv_mortalcopy if not needed */\n    else\n        ST(0) = sv_mortalcopy(leaf);\n\n\n\nSV *\ndbi_profile_merge_nodes(dest, ...)\n    SV * dest\n    ALIAS:\n    dbi_profile_merge = 1\n    CODE:\n    {\n        if (!SvROK(dest) || SvTYPE(SvRV(dest)) != SVt_PVAV)\n            croak(\"dbi_profile_merge_nodes(%s,...) destination is not an array reference\", neatsvpv(dest,0));\n        if (items <= 1) {\n            PERL_UNUSED_VAR(cv);\n            PERL_UNUSED_VAR(ix);\n            RETVAL = 0;\n        }\n        else {\n            /* items==2 for dest + 1 arg, ST(0) is dest, ST(1) is first arg */\n            while (--items >= 1) {\n                SV *thingy = ST(items);\n                dbi_profile_merge_nodes(dest, thingy);\n            }\n            RETVAL = newSVsv(*av_fetch((AV*)SvRV(dest), DBIprof_TOTAL_TIME, 1));\n        }\n    }\n    OUTPUT:\n    RETVAL\n\n\nSV *\n_concat_hash_sorted(hash_sv, kv_sep_sv, pair_sep_sv, use_neat_sv, num_sort_sv)\n    SV *hash_sv\n    SV *kv_sep_sv\n    SV *pair_sep_sv\n    SV *use_neat_sv\n    SV *num_sort_sv\n    PREINIT:\n    char *kv_sep, *pair_sep;\n    STRLEN kv_sep_len, pair_sep_len;\n    CODE:\n        if (!SvOK(hash_sv))\n            XSRETURN_UNDEF;\n        if (!SvROK(hash_sv) || SvTYPE(SvRV(hash_sv))!=SVt_PVHV)\n            croak(\"hash is not a hash reference\");\n\n        kv_sep   = SvPV(kv_sep_sv,   kv_sep_len);\n        pair_sep = SvPV(pair_sep_sv, pair_sep_len);\n\n        RETVAL = _join_hash_sorted( (HV*)SvRV(hash_sv),\n            kv_sep,   kv_sep_len,\n            pair_sep, pair_sep_len,\n            /* use_neat should be undef, 0 or 1, may allow sprintf format strings later */\n            (SvOK(use_neat_sv)) ? SvIV(use_neat_sv) :  0,\n            (SvOK(num_sort_sv)) ? SvIV(num_sort_sv) : -1\n        );\n    OUTPUT:\n        RETVAL\n\n\nint\nsql_type_cast(sv, sql_type, flags=0)\n    SV *        sv\n    int         sql_type\n    U32         flags\n    CODE:\n    RETVAL = sql_type_cast_svpv(aTHX_ sv, sql_type, flags, 0);\n    OUTPUT:\n        RETVAL\n\n\n\nMODULE = DBI   PACKAGE = DBI::var\n\nvoid\nFETCH(sv)\n    SV *        sv\n    CODE:\n    dMY_CXT;\n    /* Note that we do not come through the dispatcher to get here.     */\n    char *meth = SvPV_nolen(SvRV(sv));  /* what should this tie do ?    */\n    char type = *meth++;                /* is this a $ or & style       */\n    imp_xxh_t *imp_xxh = (DBI_LAST_HANDLE_OK) ? DBIh_COM(DBI_LAST_HANDLE) : NULL;\n    int trace_level = (imp_xxh ? DBIc_TRACE_LEVEL(imp_xxh) : DBIS_TRACE_LEVEL);\n    NV profile_t1 = 0.0;\n\n    if (imp_xxh && DBIc_has(imp_xxh,DBIcf_Profile))\n        profile_t1 = dbi_time();\n\n    if (trace_level >= 2) {\n        PerlIO_printf(DBILOGFP,\"    -> $DBI::%s (%c) FETCH from lasth=%s\\n\", meth, type,\n                (imp_xxh) ? neatsvpv(DBI_LAST_HANDLE,0): \"none\");\n    }\n\n    if (type == '!') {  /* special case for $DBI::lasth */\n        /* Currently we can only return the INNER handle.       */\n        /* This handle should only be used for true/false tests */\n        ST(0) = (imp_xxh) ? sv_2mortal(newRV_inc(DBI_LAST_HANDLE)) : &PL_sv_undef;\n    }\n    else if ( !imp_xxh ) {\n        if (trace_level)\n            warn(\"Can't read $DBI::%s, last handle unknown or destroyed\", meth);\n        ST(0) = &PL_sv_undef;\n    }\n    else if (type == '*') {     /* special case for $DBI::err, see also err method      */\n        SV *errsv = DBIc_ERR(imp_xxh);\n        ST(0) = sv_mortalcopy(errsv);\n    }\n    else if (type == '\"') {     /* special case for $DBI::state */\n        SV *state = DBIc_STATE(imp_xxh);\n        ST(0) = DBIc_STATE_adjust(imp_xxh, state);\n    }\n    else if (type == '$') { /* lookup scalar variable in implementors stash */\n        const char *vname = mkvname(aTHX_ DBIc_IMP_STASH(imp_xxh), meth, 0);\n        SV *vsv = get_sv(vname, 1);\n        ST(0) = sv_mortalcopy(vsv);\n    }\n    else {\n        /* default to method call via stash of implementor of DBI_LAST_HANDLE */\n        GV *imp_gv;\n        HV *imp_stash = DBIc_IMP_STASH(imp_xxh);\n#ifdef DBI_save_hv_fetch_ent\n        HE save_mh = PL_hv_fetch_ent_mh; /* XXX nested tied FETCH bug17575 workaround */\n#endif\n        profile_t1 = 0.0; /* profile this via dispatch only (else we'll double count) */\n        if (trace_level >= 3)\n            PerlIO_printf(DBILOGFP,\"    >> %s::%s\\n\", HvNAME(imp_stash), meth);\n        ST(0) = sv_2mortal(newRV_inc(DBI_LAST_HANDLE));\n        if ((imp_gv = gv_fetchmethod(imp_stash,meth)) == NULL) {\n            croak(\"Can't locate $DBI::%s object method \\\"%s\\\" via package \\\"%s\\\"\",\n                meth, meth, HvNAME(imp_stash));\n        }\n        PUSHMARK(mark);  /* reset mark (implies one arg as we were called with one arg?) */\n        call_sv((SV*)GvCV(imp_gv), GIMME);\n        SPAGAIN;\n#ifdef DBI_save_hv_fetch_ent\n        PL_hv_fetch_ent_mh = save_mh;\n#endif\n    }\n    if (trace_level)\n        PerlIO_printf(DBILOGFP,\"    <- $DBI::%s= %s\\n\", meth, neatsvpv(ST(0),0));\n    if (profile_t1) {\n        SV *h = sv_2mortal(newRV_inc(DBI_LAST_HANDLE));\n        dbi_profile(h, imp_xxh, &PL_sv_undef, (SV*)cv, profile_t1, dbi_time());\n    }\n\n\nMODULE = DBI   PACKAGE = DBD::_::dr\n\nvoid\ndbixs_revision(h)\n    SV *    h\n    CODE:\n    PERL_UNUSED_VAR(h);\n    ST(0) = sv_2mortal(newSViv(DBIXS_REVISION));\n\n\nMODULE = DBI   PACKAGE = DBD::_::db\n\nvoid\nconnected(...)\n    CODE:\n    /* defined here just to avoid AUTOLOAD */\n    (void)cv;\n    (void)items;\n    ST(0) = &PL_sv_undef;\n\n\nSV *\npreparse(dbh, statement, ps_accept, ps_return, foo=Nullch)\n    SV *        dbh\n    char *      statement\n    IV          ps_accept\n    IV          ps_return\n    void        *foo\n\n\nvoid\ntake_imp_data(h)\n    SV *        h\n    PREINIT:\n    /* take_imp_data currently in DBD::_::db not DBD::_::common, so for dbh's only */\n    D_imp_xxh(h);\n    MAGIC *mg;\n    SV *imp_xxh_sv;\n    SV **tmp_svp;\n    CODE:\n    PERL_UNUSED_VAR(cv);\n    /*\n     * Remove and return the imp_xxh_t structure that's attached to the inner\n     * hash of the handle. Effectively this removes the 'brain' of the handle\n     * leaving it as an empty shell - brain dead. All method calls on it fail.\n     *\n     * The imp_xxh_t structure that's removed and returned is a plain scalar\n     * (containing binary data). It can be passed to a new DBI->connect call\n     * in order to have the new $dbh use the same 'connection' as the original\n     * handle. In this way a multi-threaded connection pool can be implemented.\n     *\n     * If the drivers imp_xxh_t structure contains SV*'s, or other interpreter\n     * specific items, they should be freed by the drivers own take_imp_data()\n     * method before it then calls SUPER::take_imp_data() to finalize removal\n     * of the imp_xxh_t structure.\n     *\n     * The driver needs to view the take_imp_data method as being nearly the\n     * same as disconnect+DESTROY only not actually calling the database API to\n     * disconnect.  All that needs to remain valid in the imp_xxh_t structure\n     * is the underlying database API connection data.  Everything else should\n     * in a 'clean' state such that if the drivers own DESTROY method was\n     * called it would be able to properly handle the contents of the\n     * structure. This is important in case a new handle created using this\n     * imp_data, possibly in a new thread, might end up being DESTROY'd before\n     * the driver has had a chance to 're-setup' the data. See dbih_setup_handle()\n     *\n     * All the above relates to the 'typical use case' for a compiled driver.\n     * For a pure-perl driver using a socket pair, for example, the drivers\n     * take_imp_data method might just return a string containing the fileno()\n     * values of the sockets (without calling this SUPER::take_imp_data() code).\n     * The key point is that the take_imp_data() method returns an opaque buffer\n     * containing whatever the driver would need to reuse the same underlying\n     * 'connection to the database' in a new handle.\n     *\n     * In all cases, care should be taken that driver attributes (such as\n     * AutoCommit) match the state of the underlying connection.\n     */\n\n    if (!DBIc_ACTIVE(imp_xxh)) {/* sanity check, may be relaxed later */\n        set_err_char(h, imp_xxh, \"1\", 1, \"Can't take_imp_data from handle that's not Active\", 0, \"take_imp_data\");\n        XSRETURN(0);\n    }\n\n    /* Ideally there should be no child statement handles existing when\n     * take_imp_data is called because when those statement handles are\n     * destroyed they may need to interact with the 'zombie' parent dbh.\n     * So we do our best to neautralize them (finish & rebless)\n     */\n    if ((tmp_svp = hv_fetch((HV*)SvRV(h), \"ChildHandles\", 12, FALSE)) && SvROK(*tmp_svp)) {\n        AV *av = (AV*)SvRV(*tmp_svp);\n        HV *zombie_stash = gv_stashpv(\"DBI::zombie\", GV_ADDWARN);\n        I32 kidslots;\n        for (kidslots = AvFILL(av); kidslots >= 0; --kidslots) {\n            SV **hp = av_fetch(av, kidslots, FALSE);\n            if (hp && SvROK(*hp) && SvMAGICAL(SvRV(*hp))) {\n                PUSHMARK(sp);\n                XPUSHs(*hp);\n                PUTBACK;\n                call_method(\"finish\", G_SCALAR|G_DISCARD);\n                SPAGAIN;\n                PUTBACK;\n                sv_unmagic(SvRV(*hp), 'P'); /* untie */\n                sv_bless(*hp, zombie_stash); /* neutralise */\n            }\n        }\n    }\n    /* The above measures may not be sufficient if weakrefs aren't available\n     * or something has a reference to the inner-handle of an sth.\n     * We'll require no Active kids, but just warn about others.\n     */\n    if (DBIc_ACTIVE_KIDS(imp_xxh)) {\n        set_err_char(h, imp_xxh, \"1\", 1, \"Can't take_imp_data from handle while it still has Active kids\", 0, \"take_imp_data\");\n        XSRETURN(0);\n    }\n    if (DBIc_KIDS(imp_xxh))\n        warn(\"take_imp_data from handle while it still has kids\");\n\n    /* it may be better here to return a copy and poison the original\n     * rather than detatching and returning the original\n     */\n\n    /* --- perform the surgery */\n    dbih_getcom2(aTHX_ h, &mg); /* get the MAGIC so we can change it    */\n    imp_xxh_sv = mg->mg_obj;    /* take local copy of the imp_data pointer */\n    mg->mg_obj = Nullsv;        /* sever the link from handle to imp_xxh */\n    mg->mg_ptr = NULL;          /* and sever the shortcut too */\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 9)\n        sv_dump(imp_xxh_sv);\n    /* --- housekeeping */\n    DBIc_ACTIVE_off(imp_xxh);   /* silence warning from dbih_clearcom */\n    DBIc_IMPSET_off(imp_xxh);   /* silence warning from dbih_clearcom */\n    dbih_clearcom(imp_xxh);     /* free SVs like DBD::_mem::common::DESTROY */\n    SvOBJECT_off(imp_xxh_sv);   /* no longer needs DESTROY via dbih_clearcom */\n    /* restore flags to mark fact imp data holds active connection      */\n    /* (don't use magical DBIc_ACTIVE_on here)                          */\n    DBIc_FLAGS(imp_xxh) |=  DBIcf_IMPSET | DBIcf_ACTIVE;\n    /* --- tidy up the raw PV for life as a more normal string */\n    SvPOK_on(imp_xxh_sv);       /* SvCUR & SvEND were set at creation   */\n    /* --- return the actual imp_xxh_sv on the stack */\n    ST(0) = imp_xxh_sv;\n\n\n\nMODULE = DBI   PACKAGE = DBD::_::st\n\nvoid\n_get_fbav(sth)\n    SV *        sth\n    CODE:\n    D_imp_sth(sth);\n    AV *av = dbih_get_fbav(imp_sth);\n    (void)cv;\n    ST(0) = sv_2mortal(newRV_inc((SV*)av));\n\nvoid\n_set_fbav(sth, src_rv)\n    SV *        sth\n    SV *        src_rv\n    CODE:\n    D_imp_sth(sth);\n    int i;\n    AV *src_av;\n    AV *dst_av = dbih_get_fbav(imp_sth);\n    int dst_fields = AvFILL(dst_av)+1;\n    int src_fields;\n    (void)cv;\n\n    if (!SvROK(src_rv) || SvTYPE(SvRV(src_rv)) != SVt_PVAV)\n        croak(\"_set_fbav(%s): not an array ref\", neatsvpv(src_rv,0));\n    src_av = (AV*)SvRV(src_rv);\n    src_fields = AvFILL(src_av)+1;\n    if (src_fields != dst_fields) {\n        warn(\"_set_fbav(%s): array has %d elements, the statement handle row buffer has %d (and NUM_OF_FIELDS is %d)\",\n                neatsvpv(src_rv,0), src_fields, dst_fields, DBIc_NUM_FIELDS(imp_sth));\n        SvREADONLY_off(dst_av);\n        if (src_fields < dst_fields) {\n            /* shrink the array - sadly this looses column bindings for the lost columns */\n            av_fill(dst_av, src_fields-1);\n            dst_fields = src_fields;\n        }\n        else {\n            av_fill(dst_av, src_fields-1);\n            /* av_fill pads with immutable undefs which we need to change */\n            for(i=dst_fields-1; i < src_fields; ++i) {\n                sv_setsv(AvARRAY(dst_av)[i], newSV(0));\n            }\n        }\n        SvREADONLY_on(dst_av);\n    }\n    for(i=0; i < dst_fields; ++i) {     /* copy over the row    */\n        /* If we're given the values, then taint them if required */\n        if (DBIc_is(imp_sth, DBIcf_TaintOut))\n            SvTAINT(AvARRAY(src_av)[i]);\n        sv_setsv(AvARRAY(dst_av)[i], AvARRAY(src_av)[i]);\n    }\n    ST(0) = sv_2mortal(newRV_inc((SV*)dst_av));\n\n\nvoid\nbind_col(sth, col, ref, attribs=Nullsv)\n    SV *        sth\n    SV *        col\n    SV *        ref\n    SV *        attribs\n    CODE:\n    DBD_ATTRIBS_CHECK(\"bind_col\", sth, attribs);\n    ST(0) = boolSV(dbih_sth_bind_col(sth, col, ref, attribs));\n    (void)cv;\n\n\nvoid\nfetchrow_array(sth)\n    SV *        sth\n    ALIAS:\n    fetchrow = 1\n    PPCODE:\n    SV *retsv;\n    if (CvDEPTH(cv) == 99) {\n        PERL_UNUSED_VAR(ix);\n        croak(\"Deep recursion, probably fetchrow-fetch-fetchrow loop\");\n    }\n    PUSHMARK(sp);\n    XPUSHs(sth);\n    PUTBACK;\n    if (call_method(\"fetch\", G_SCALAR) != 1)\n        croak(\"panic: DBI fetch\");      /* should never happen */\n    SPAGAIN;\n    retsv = POPs;\n    PUTBACK;\n    if (SvROK(retsv) && SvTYPE(SvRV(retsv)) == SVt_PVAV) {\n        D_imp_sth(sth);\n        int num_fields, i;\n        AV *bound_av;\n        AV *av = (AV*)SvRV(retsv);\n        num_fields = AvFILL(av)+1;\n        EXTEND(sp, num_fields+1);\n\n        /* We now check for bind_col() having been called but fetch     */\n        /* not returning the fields_svav array. Probably because the    */\n        /* driver is implemented in perl. XXX This logic may change later.      */\n        bound_av = DBIc_FIELDS_AV(imp_sth); /* bind_col() called ?      */\n        if (bound_av && av != bound_av) {\n            /* let dbih_get_fbav know what's going on   */\n            bound_av = dbih_get_fbav(imp_sth);\n            if (DBIc_TRACE_LEVEL(imp_sth) >= 3) {\n                PerlIO_printf(DBIc_LOGPIO(imp_sth),\n                    \"fetchrow: updating fbav 0x%lx from 0x%lx\\n\",\n                    (long)bound_av, (long)av);\n            }\n            for(i=0; i < num_fields; ++i) {     /* copy over the row    */\n                sv_setsv(AvARRAY(bound_av)[i], AvARRAY(av)[i]);\n            }\n        }\n        for(i=0; i < num_fields; ++i) {\n            PUSHs(AvARRAY(av)[i]);\n        }\n    }\n\n\nSV *\nfetchrow_hashref(sth, keyattrib=Nullch)\n    SV *        sth\n    const char *keyattrib\n    PREINIT:\n    SV *rowavr;\n    SV *ka_rv;\n    D_imp_sth(sth);\n    CODE:\n    (void)cv;\n    PUSHMARK(sp);\n    XPUSHs(sth);\n    PUTBACK;\n    if (!keyattrib || !*keyattrib) {\n        SV *kn = DBIc_FetchHashKeyName(imp_sth);\n        if (kn && SvOK(kn))\n            keyattrib = SvPVX(kn);\n        else\n            keyattrib = \"NAME\";\n    }\n    ka_rv = *hv_fetch((HV*)DBIc_MY_H(imp_sth), keyattrib,strlen(keyattrib), TRUE);\n    /* we copy to invoke FETCH magic, and we do that before fetch() so if tainting */\n    /* then the taint triggered by the fetch won't then apply to the fetched name */\n    ka_rv = newSVsv(ka_rv);\n    if (call_method(\"fetch\", G_SCALAR) != 1)\n        croak(\"panic: DBI fetch\");      /* should never happen */\n    SPAGAIN;\n    rowavr = POPs;\n    PUTBACK;\n    /* have we got an array ref in rowavr */\n    if (SvROK(rowavr) && SvTYPE(SvRV(rowavr)) == SVt_PVAV) {\n        int i;\n        AV *rowav = (AV*)SvRV(rowavr);\n        const int num_fields = AvFILL(rowav)+1;\n        HV *hv;\n        AV *ka_av;\n        if (!(SvROK(ka_rv) && SvTYPE(SvRV(ka_rv))==SVt_PVAV)) {\n            sv_setiv(DBIc_ERR(imp_sth), 1);\n            sv_setpvf(DBIc_ERRSTR(imp_sth),\n                \"Can't use attribute '%s' because it doesn't contain a reference to an array (%s)\",\n                keyattrib, neatsvpv(ka_rv,0));\n            XSRETURN_UNDEF;\n        }\n        ka_av = (AV*)SvRV(ka_rv);\n        hv    = newHV();\n        for (i=0; i < num_fields; ++i) {        /* honor the original order as sent by the database */\n            SV  **field_name_svp = av_fetch(ka_av, i, 1);\n            (void)hv_store_ent(hv, *field_name_svp, newSVsv((SV*)(AvARRAY(rowav)[i])), 0);\n        }\n        RETVAL = newRV_inc((SV*)hv);\n        SvREFCNT_dec(hv);       /* since newRV incremented it   */\n    }\n    else {\n        RETVAL = &PL_sv_undef;\n#if (PERL_VERSION < 4) || ((PERL_VERSION == 4) && (PERL_SUBVERSION <= 4))\n        RETVAL = newSV(0); /* mutable undef for 5.004_04 */\n#endif\n    }\n    SvREFCNT_dec(ka_rv);        /* since we created it          */\n    OUTPUT:\n    RETVAL\n\n\nvoid\nfetch(sth)\n    SV *        sth\n    ALIAS:\n    fetchrow_arrayref = 1\n    CODE:\n    int num_fields;\n    if (CvDEPTH(cv) == 99) {\n        PERL_UNUSED_VAR(ix);\n        croak(\"Deep recursion. Probably fetch-fetchrow-fetch loop.\");\n    }\n    PUSHMARK(sp);\n    XPUSHs(sth);\n    PUTBACK;\n    num_fields = call_method(\"fetchrow\", G_ARRAY);      /* XXX change the name later */\n    SPAGAIN;\n    if (num_fields == 0) {\n        ST(0) = &PL_sv_undef;\n    } else {\n        D_imp_sth(sth);\n        AV *av = dbih_get_fbav(imp_sth);\n        if (num_fields != AvFILL(av)+1)\n            croak(\"fetchrow returned %d fields, expected %d\",\n                    num_fields, (int)AvFILL(av)+1);\n        SPAGAIN;\n        while(--num_fields >= 0)\n            sv_setsv(AvARRAY(av)[num_fields], POPs);\n        PUTBACK;\n        ST(0) = sv_2mortal(newRV_inc((SV*)av));\n    }\n\n\nvoid\nrows(sth)\n    SV *        sth\n    CODE:\n    D_imp_sth(sth);\n    const IV rows = DBIc_ROW_COUNT(imp_sth);\n    ST(0) = sv_2mortal(newSViv(rows));\n    (void)cv;\n\n\nvoid\nfinish(sth)\n    SV *        sth\n    CODE:\n    D_imp_sth(sth);\n    DBIc_ACTIVE_off(imp_sth);\n    ST(0) = &PL_sv_yes;\n    (void)cv;\n\n\nvoid\nDESTROY(sth)\n    SV *        sth\n    PPCODE:\n    /* keep in sync with DESTROY in Driver.xst */\n    D_imp_sth(sth);\n    ST(0) = &PL_sv_yes;\n    /* we don't test IMPSET here because this code applies to pure-perl drivers */\n    if (DBIc_IADESTROY(imp_sth)) { /* want's ineffective destroy    */\n        DBIc_ACTIVE_off(imp_sth);\n        if (DBIc_TRACE_LEVEL(imp_sth))\n                PerlIO_printf(DBIc_LOGPIO(imp_sth), \"         DESTROY %s skipped due to InactiveDestroy\\n\", SvPV_nolen(sth));\n    }\n    if (DBIc_ACTIVE(imp_sth)) {\n        D_imp_dbh_from_sth;\n        if (!PL_dirty && DBIc_ACTIVE(imp_dbh)) {\n            dSP;\n            PUSHMARK(sp);\n            XPUSHs(sth);\n            PUTBACK;\n            call_method(\"finish\", G_SCALAR);\n            SPAGAIN;\n            PUTBACK;\n        }\n        else {\n            DBIc_ACTIVE_off(imp_sth);\n        }\n    }\n\n\nMODULE = DBI   PACKAGE = DBI::st\n\nvoid\nTIEHASH(class, inner_ref)\n    SV * class\n    SV * inner_ref\n    CODE:\n    HV *stash = gv_stashsv(class, GV_ADDWARN); /* a new hash is supplied to us, we just need to bless and apply tie magic */\n    sv_bless(inner_ref, stash);\n    ST(0) = inner_ref;\n\nMODULE = DBI   PACKAGE = DBD::_::common\n\n\nvoid\nDESTROY(h)\n    SV * h\n    CODE:\n    /* DESTROY defined here just to avoid AUTOLOAD */\n    (void)cv;\n    (void)h;\n    ST(0) = &PL_sv_undef;\n\n\nvoid\nSTORE(h, keysv, valuesv)\n    SV *        h\n    SV *        keysv\n    SV *        valuesv\n    CODE:\n    ST(0) = &PL_sv_yes;\n    if (!dbih_set_attr_k(h, keysv, 0, valuesv))\n            ST(0) = &PL_sv_no;\n    (void)cv;\n\n\nvoid\nFETCH(h, keysv)\n    SV *        h\n    SV *        keysv\n    CODE:\n    ST(0) = dbih_get_attr_k(h, keysv, 0);\n    (void)cv;\n\nvoid\nDELETE(h, keysv)\n    SV *        h\n    SV *        keysv\n    CODE:\n    /* only private_* keys can be deleted, for others DELETE acts like FETCH */\n    /* because the DBI internals rely on certain handle attributes existing  */\n    if (strnEQ(SvPV_nolen(keysv),\"private_\",8))\n        ST(0) = hv_delete_ent((HV*)SvRV(h), keysv, 0, 0);\n    else\n        ST(0) = dbih_get_attr_k(h, keysv, 0);\n    (void)cv;\n\n\nvoid\nprivate_data(h)\n    SV *        h\n    CODE:\n    D_imp_xxh(h);\n    (void)cv;\n    ST(0) = sv_mortalcopy(DBIc_IMP_DATA(imp_xxh));\n\n\nvoid\nerr(h)\n    SV * h\n    CODE:\n    D_imp_xxh(h);\n    SV *errsv = DBIc_ERR(imp_xxh);\n    (void)cv;\n    ST(0) = sv_mortalcopy(errsv);\n\nvoid\nstate(h)\n    SV * h\n    CODE:\n    D_imp_xxh(h);\n    SV *state = DBIc_STATE(imp_xxh);\n    (void)cv;\n    ST(0) = DBIc_STATE_adjust(imp_xxh, state);\n\nvoid\nerrstr(h)\n    SV *    h\n    CODE:\n    D_imp_xxh(h);\n    SV *errstr = DBIc_ERRSTR(imp_xxh);\n    SV *err;\n    /* If there's no errstr but there is an err then use err */\n    (void)cv;\n    if (!SvTRUE(errstr) && (err=DBIc_ERR(imp_xxh)) && SvTRUE(err))\n            errstr = err;\n    ST(0) = sv_mortalcopy(errstr);\n\n\nvoid\nset_err(h, err, errstr=&PL_sv_no, state=&PL_sv_undef, method=&PL_sv_undef, result=Nullsv)\n    SV *        h\n    SV *        err\n    SV *        errstr\n    SV *        state\n    SV *        method\n    SV *        result\n    PPCODE:\n    {\n    D_imp_xxh(h);\n    SV **sem_svp;\n    (void)cv;\n\n    if (DBIc_has(imp_xxh, DBIcf_HandleSetErr) && SvREADONLY(method))\n        method = sv_mortalcopy(method); /* HandleSetErr may want to change it */\n\n    if (!set_err_sv(h, imp_xxh, err, errstr, state, method)) {\n        /* set_err was canceled by HandleSetErr,                */\n        /* don't set \"dbi_set_err_method\", return an empty list */\n    }\n    else {\n        /* store provided method name so handler code can find it */\n        sem_svp = hv_fetch((HV*)SvRV(h), \"dbi_set_err_method\", 18, 1);\n        if (SvOK(method)) {\n            sv_setpv(*sem_svp, SvPV_nolen(method));\n        }\n        else\n            (void)SvOK_off(*sem_svp);\n        EXTEND(SP, 1);\n        PUSHs( result ? result : &PL_sv_undef );\n    }\n    /* We don't check RaiseError and call die here because that must be */\n    /* done by returning through dispatch and letting the DBI handle it */\n    }\n\n\nint\ntrace(h, level=&PL_sv_undef, file=Nullsv)\n    SV *h\n    SV *level\n    SV *file\n    ALIAS:\n    debug = 1\n    CODE:\n    RETVAL = set_trace(h, level, file);\n    (void)cv; /* Unused variables */\n    (void)ix;\n    OUTPUT:\n    RETVAL\n\n\nvoid\ntrace_msg(sv, msg, this_trace=1)\n    SV *sv\n    const char *msg\n    int this_trace\n    PREINIT:\n    int current_trace;\n    PerlIO *pio;\n    CODE:\n    {\n    dMY_CXT;\n    (void)cv;\n    if (SvROK(sv)) {\n        D_imp_xxh(sv);\n        current_trace = DBIc_TRACE_LEVEL(imp_xxh);\n        pio = DBIc_LOGPIO(imp_xxh);\n    }\n    else {      /* called as a static method */\n        current_trace = DBIS_TRACE_FLAGS;\n        pio = DBILOGFP;\n    }\n    if (DBIc_TRACE_MATCHES(this_trace, current_trace)) {\n        PerlIO_puts(pio, msg);\n        ST(0) = &PL_sv_yes;\n    }\n    else {\n        ST(0) = &PL_sv_no;\n    }\n    }\n\n\nvoid\nrows(h)\n    SV *        h\n    CODE:\n    /* fallback esp for $DBI::rows after $drh was last used */\n    ST(0) = sv_2mortal(newSViv(-1));\n    (void)h;\n    (void)cv;\n\n\nvoid\nswap_inner_handle(rh1, rh2, allow_reparent=0)\n    SV *        rh1\n    SV *        rh2\n    IV  allow_reparent\n    CODE:\n    {\n    D_impdata(imp_xxh1, imp_xxh_t, rh1);\n    D_impdata(imp_xxh2, imp_xxh_t, rh2);\n    SV *h1i = dbih_inner(aTHX_ rh1, \"swap_inner_handle\");\n    SV *h2i = dbih_inner(aTHX_ rh2, \"swap_inner_handle\");\n    SV *h1  = (rh1 == h1i) ? (SV*)DBIc_MY_H(imp_xxh1) : SvRV(rh1);\n    SV *h2  = (rh2 == h2i) ? (SV*)DBIc_MY_H(imp_xxh2) : SvRV(rh2);\n    (void)cv;\n\n    if (DBIc_TYPE(imp_xxh1) != DBIc_TYPE(imp_xxh2)) {\n        char buf[99];\n        sprintf(buf, \"Can't swap_inner_handle between %sh and %sh\",\n            dbih_htype_name(DBIc_TYPE(imp_xxh1)), dbih_htype_name(DBIc_TYPE(imp_xxh2)));\n        DBIh_SET_ERR_CHAR(rh1, imp_xxh1, \"1\", 1, buf, Nullch, Nullch);\n        XSRETURN_NO;\n    }\n    if (!allow_reparent && DBIc_PARENT_COM(imp_xxh1) != DBIc_PARENT_COM(imp_xxh2)) {\n        DBIh_SET_ERR_CHAR(rh1, imp_xxh1, \"1\", 1,\n            \"Can't swap_inner_handle with handle from different parent\",\n            Nullch, Nullch);\n        XSRETURN_NO;\n    }\n\n    (void)SvREFCNT_inc(h1i);\n    (void)SvREFCNT_inc(h2i);\n\n    sv_unmagic(h1, 'P');                /* untie(%$h1)          */\n    sv_unmagic(h2, 'P');                /* untie(%$h2)          */\n\n    sv_magic(h1, h2i, 'P', Nullch, 0);  /* tie %$h1, $h2i       */\n    DBIc_MY_H(imp_xxh2) = (HV*)h1;\n\n    sv_magic(h2, h1i, 'P', Nullch, 0);  /* tie %$h2, $h1i       */\n    DBIc_MY_H(imp_xxh1) = (HV*)h2;\n\n    SvREFCNT_dec(h1i);\n    SvREFCNT_dec(h2i);\n\n    ST(0) = &PL_sv_yes;\n    }\n\n\nMODULE = DBI   PACKAGE = DBD::_mem::common\n\nvoid\nDESTROY(imp_xxh_rv)\n    SV *        imp_xxh_rv\n    CODE:\n    /* ignore 'cast increases required alignment' warning       */\n    imp_xxh_t *imp_xxh = (imp_xxh_t*)SvPVX(SvRV(imp_xxh_rv));\n    DBIc_DBISTATE(imp_xxh)->clearcom(imp_xxh);\n    (void)cv;\n\n# end\n", "#!perl -w\n# vim:ts=8:sw=4\n\nuse strict;\n\nuse Test::More;\nuse DBI;\n\nBEGIN {\n        plan skip_all => '$h->{Callbacks} attribute not supported for DBI::PurePerl'\n                if $DBI::PurePerl && $DBI::PurePerl; # doubled to avoid typo warning\n}\n\n$| = 1;\nmy $dsn = \"dbi:ExampleP:drv_foo=drv_bar\";\nmy %called;\n\nok my $dbh = DBI->connect($dsn, '', ''), \"Create dbh\";\n\nis $dbh->{Callbacks}, undef, \"Callbacks initially undef\";\nok $dbh->{Callbacks} = my $cb = { };\nis ref $dbh->{Callbacks}, 'HASH', \"Callbacks can be set to a hash ref\";\nis $dbh->{Callbacks}, $cb, \"Callbacks set to same hash ref\";\n\n$dbh->{Callbacks} = undef;\nis $dbh->{Callbacks}, undef, \"Callbacks set to undef again\";\n\nok $dbh->{Callbacks} = {\n    ping => sub {\n\tis $_, 'ping', '$_ holds method name';\n\tis @_, 1, '@_ holds 1 values';\n\tis ref $_[0], 'DBI::db', 'first is $dbh';\n        ok tied(%{$_[0]}), '$dbh is tied (outer) handle'\n            or DBI::dump_handle($_[0], 'tied?', 10);\n\t$called{$_}++;\n\treturn;\n    },\n    quote_identifier => sub {\n\tis @_, 4, '@_ holds 4 values';\n\tmy $dbh = shift;\n\tis ref $dbh, 'DBI::db', 'first is $dbh';\n\tis $_[0], 'foo';\n\tis $_[1], 'bar';\n\tis $_[2], undef;\n\t$_[2] = { baz => 1 };\n\t$called{$_}++;\n\treturn (1,2,3);\t# return something - which is not allowed\n    },\n    disconnect => sub { # test die from within a callback\n\tdie \"You can't disconnect that easily!\\n\";\n    },\n    \"*\" => sub {\n\t$called{$_}++;\n        return;\n    }\n};\nis keys %{ $dbh->{Callbacks} }, 4;\n\nis ref $dbh->{Callbacks}->{ping}, 'CODE';\n\n$_ = 42;\nok $dbh->ping;\nis $called{ping}, 1;\nis $_, 42, '$_ not altered by callback';\n\nok $dbh->ping;\nis $called{ping}, 2;\n\nok $dbh->type_info_all;\nis $called{type_info_all}, 1, 'fallback callback';\n\nmy $attr;\neval { $dbh->quote_identifier('foo','bar', $attr) };\nis $called{quote_identifier}, 1;\nok $@, 'quote_identifier callback caused fatal error';\nis ref $attr, 'HASH', 'param modified by callback - not recommended!';\n\nok !eval { $dbh->disconnect };\nok $@, \"You can't disconnect that easily!\\n\";\n\n$dbh->{Callbacks} = undef;\nok $dbh->ping;\nis $called{ping}, 2; # no change\n\n\n# --- test skipping dispatch and fallback callbacks\n\n$dbh->{Callbacks} = {\n    ping => sub {\n        undef $_;   # tell dispatch to not call the method\n        return \"42 bells\";\n    },\n    data_sources => sub {\n        my ($h, $values_to_return) = @_;\n        undef $_;   # tell dispatch to not call the method\n        my @ret = 11..10+($values_to_return||0);\n        return @ret;\n    },\n    commit => sub {     # test using set_err within a callback\n        my $h = shift;\n        undef $_;   # tell dispatch to not call the method\n\treturn $h->set_err(42, \"faked commit failure\");\n    },\n};\n\n# these tests are slightly convoluted because messing with the stack is bad for\n# your mental health\nmy $rv = $dbh->ping;\nis $rv, \"42 bells\";\nmy @rv = $dbh->ping;\nis scalar @rv, 1, 'should return a single value in list context';\nis \"@rv\", \"42 bells\";\n# test returning lists with different number of args to test\n# the stack handling in the dispatch code\nis join(\":\", $dbh->data_sources()),  \"\";\nis join(\":\", $dbh->data_sources(0)), \"\";\nis join(\":\", $dbh->data_sources(1)), \"11\";\nis join(\":\", $dbh->data_sources(2)), \"11:12\";\n\n{\nlocal $dbh->{RaiseError} = 1;\nlocal $dbh->{PrintError} = 0;\nis eval { $dbh->commit }, undef, 'intercepted commit should return undef';\nlike $@, '/DBD::\\w+::db commit failed: faked commit failure/';\nis $DBI::err, 42;\nis $DBI::errstr, \"faked commit failure\";\n}\n\n# --- test connect_cached.*\n\n=for comment XXX\n\nThe big problem here is that conceptually the Callbacks attribute\nis applied to the $dbh _during_ the $drh->connect() call, so you can't\nset a callback on \"connect\" on the $dbh because connect isn't called\non the dbh, but on the $drh.\n\nSo a \"connect\" callback would have to be defined on the $drh, but that's\ncumbersome for the user and then it would apply to all future connects\nusing that driver.\n\nThe best thing to do is probably to special-case \"connect\", \"connect_cached\"\nand (the already special-case) \"connect_cached.reused\".\n\n=cut\n\nmy $driver_dsn = (DBI->parse_dsn($dsn))[4] or die 'panic';\n\nmy @args = (\n    $dsn, 'u', 'p', {\n        Callbacks => {\n            \"connect_cached.new\"       => sub {\n                my ($dbh, $cb_dsn, $user, $auth, $attr) = @_;\n                ok tied(%$dbh), 'connect_cached.new $h is tied (outer) handle'\n                    if $dbh; # $dbh is typically undef or a dead/disconnected $dbh\n                like $cb_dsn, qr/\\Q$driver_dsn/, 'dsn';\n                is $user, 'u', 'user';\n                is $auth, 'p', 'pass';\n                $called{new}++;\n                return;\n            },\n            \"connect_cached.reused\"    => sub {\n                my ($dbh, $cb_dsn, $user, $auth, $attr) = @_;\n                ok tied(%$dbh), 'connect_cached.reused $h is tied (outer) handle';\n                like $cb_dsn, qr/\\Q$driver_dsn/, 'dsn';\n                is $user, 'u', 'user';\n                is $auth, 'p', 'pass';\n                $called{cached}++;\n                return;\n            },\n            \"connect_cached.connected\" => sub {\n                my ($dbh, $cb_dsn, $user, $auth, $attr) = @_;\n                ok tied(%$dbh), 'connect_cached.connected $h is tied (outer) handle';\n                like $cb_dsn, qr/\\Q$driver_dsn/, 'dsn';\n                is $user, 'u', 'user';\n                is $auth, 'p', 'pass';\n                $called{connected}++;\n                return;\n            },\n        }\n    }\n);\n\n%called = ();\n\nok $dbh = DBI->connect(@args), \"Create handle with callbacks\";\nis keys %called, 0, 'no callback for plain connect';\n\nok $dbh = DBI->connect_cached(@args), \"Create handle with callbacks\";\nis $called{new}, 1, \"connect_cached.new called\";\nis $called{cached}, undef, \"connect_cached.reused not yet called\";\nis $called{connected}, 1, \"connect_cached.connected called\";\n\nok $dbh = DBI->connect_cached(@args), \"Create handle with callbacks\";\nis $called{cached}, 1, \"connect_cached.reused called\";\nis $called{new}, 1, \"connect_cached.new not called again\";\nis $called{connected}, 1, \"connect_cached.connected not called called\";\n\n\n# --- test ChildCallbacks.\n%called = ();\n$args[-1] = {\n    Callbacks => my $dbh_callbacks = {\n        ping => sub { $called{ping}++; return; },\n        ChildCallbacks => my $sth_callbacks = {\n            execute => sub { $called{execute}++; return; },\n            fetch   => sub { $called{fetch}++; return; },\n        }\n    }\n};\n\nok $dbh = DBI->connect(@args), \"Create handle with ChildCallbacks\";\nok $dbh->ping, 'Ping';\nis $called{ping}, 1, 'Ping callback should have been called';\nok my $sth = $dbh->prepare('SELECT name from t'), 'Prepare a statement handle (child)';\nok $sth->{Callbacks}, 'child should have Callbacks';\nis $sth->{Callbacks}, $sth_callbacks, \"child Callbacks should be ChildCallbacks of parent\"\n    or diag \"(dbh Callbacks is $dbh_callbacks)\";\nok $sth->execute, 'Execute';\nis $called{execute}, 1, 'Execute callback should have been called';\nok $sth->fetch, 'Fetch';\nis $called{fetch}, 1, 'Fetch callback should have been called';\n\n# stress test for stack reallocation and mark handling -- RT#86744\nmy $stress_count = 3000;\nmy $place_holders = join(',', ('?') x $stress_count);\nmy @params = ('t') x $stress_count;\nmy $stress_dbh = DBI->connect( 'DBI:NullP:test');\nmy $stress_sth = $stress_dbh->prepare(\"select 1\");\n$stress_sth->{Callbacks}{execute} = sub { return; };\n$stress_sth->execute(@params);\n\n\ndone_testing();\n\n__END__\n\nA generic 'transparent' callback looks like this:\n(this assumes only scalar context will be used)\n\n    sub {\n        my $h = shift;\n        return if our $avoid_deep_recursion->{\"$h $_\"}++;\n        my $this = $h->$_(@_);\n        undef $_;    # tell DBI not to call original method\n        return $this; # tell DBI to return this instead\n    };\n\nXXX should add a test for this\nXXX even better would be to run chunks of the test suite with that as a '*' callback. In theory everything should pass (except this test file, naturally)..\n"], "filenames": ["Changes", "DBI.xs", "t/70callbacks.t"], "buggy_code_start_loc": [10, 3149, 223], "buggy_code_end_loc": [10, 4051, 223], "fixing_code_start_loc": [11, 3150, 224], "fixing_code_end_loc": [14, 4053, 234], "type": "CWE-119", "message": "An issue was discovered in the DBI module before 1.632 for Perl. Using many arguments to methods for Callbacks may lead to memory corruption.", "other": {"cve": {"id": "CVE-2013-7490", "sourceIdentifier": "cve@mitre.org", "published": "2020-09-11T19:15:11.737", "lastModified": "2023-01-24T02:06:03.753", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in the DBI module before 1.632 for Perl. Using many arguments to methods for Callbacks may lead to memory corruption."}, {"lang": "es", "value": "Se detect\u00f3 un problema en el m\u00f3dulo DBI versiones anteriores a 1.632 para Perl. El uso de muchos argumentos en m\u00e9todos para las devoluciones de llamada puede conllevar a una corrupci\u00f3n de la memoria"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:perl:dbi:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.632", "matchCriteriaId": "F1DE579C-C25F-43FA-A02E-0E3CF88E91B4"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}]}]}], "references": [{"url": "https://github.com/perl5-dbi/dbi/commit/a8b98e988d6ea2946f5f56691d6d5ead53f65766", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://metacpan.org/pod/distribution/DBI/Changes#Changes-in-DBI-1.632-9th-Nov-2014", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://rt.cpan.org/Public/Bug/Display.html?id=86744#txn-1880941", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4509-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/perl5-dbi/dbi/commit/a8b98e988d6ea2946f5f56691d6d5ead53f65766"}}