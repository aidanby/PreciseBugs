{"buggy_code": ["/*\n * 8253/8254 interval timer emulation\n *\n * Copyright (c) 2003-2004 Fabrice Bellard\n * Copyright (c) 2006 Intel Corporation\n * Copyright (c) 2007 Keir Fraser, XenSource Inc\n * Copyright (c) 2008 Intel Corporation\n * Copyright 2009 Red Hat, Inc. and/or its affiliates.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * Authors:\n *   Sheng Yang <sheng.yang@intel.com>\n *   Based on QEMU and Xen.\n */\n\n#define pr_fmt(fmt) \"pit: \" fmt\n\n#include <linux/kvm_host.h>\n#include <linux/slab.h>\n\n#include \"irq.h\"\n#include \"i8254.h\"\n#include \"x86.h\"\n\n#ifndef CONFIG_X86_64\n#define mod_64(x, y) ((x) - (y) * div64_u64(x, y))\n#else\n#define mod_64(x, y) ((x) % (y))\n#endif\n\n#define RW_STATE_LSB 1\n#define RW_STATE_MSB 2\n#define RW_STATE_WORD0 3\n#define RW_STATE_WORD1 4\n\n/* Compute with 96 bit intermediate result: (a*b)/c */\nstatic u64 muldiv64(u64 a, u32 b, u32 c)\n{\n\tunion {\n\t\tu64 ll;\n\t\tstruct {\n\t\t\tu32 low, high;\n\t\t} l;\n\t} u, res;\n\tu64 rl, rh;\n\n\tu.ll = a;\n\trl = (u64)u.l.low * (u64)b;\n\trh = (u64)u.l.high * (u64)b;\n\trh += (rl >> 32);\n\tres.l.high = div64_u64(rh, c);\n\tres.l.low = div64_u64(((mod_64(rh, c) << 32) + (rl & 0xffffffff)), c);\n\treturn res.ll;\n}\n\nstatic void pit_set_gate(struct kvm *kvm, int channel, u32 val)\n{\n\tstruct kvm_kpit_channel_state *c =\n\t\t&kvm->arch.vpit->pit_state.channels[channel];\n\n\tWARN_ON(!mutex_is_locked(&kvm->arch.vpit->pit_state.lock));\n\n\tswitch (c->mode) {\n\tdefault:\n\tcase 0:\n\tcase 4:\n\t\t/* XXX: just disable/enable counting */\n\t\tbreak;\n\tcase 1:\n\tcase 2:\n\tcase 3:\n\tcase 5:\n\t\t/* Restart counting on rising edge. */\n\t\tif (c->gate < val)\n\t\t\tc->count_load_time = ktime_get();\n\t\tbreak;\n\t}\n\n\tc->gate = val;\n}\n\nstatic int pit_get_gate(struct kvm *kvm, int channel)\n{\n\tWARN_ON(!mutex_is_locked(&kvm->arch.vpit->pit_state.lock));\n\n\treturn kvm->arch.vpit->pit_state.channels[channel].gate;\n}\n\nstatic s64 __kpit_elapsed(struct kvm *kvm)\n{\n\ts64 elapsed;\n\tktime_t remaining;\n\tstruct kvm_kpit_state *ps = &kvm->arch.vpit->pit_state;\n\n\tif (!ps->period)\n\t\treturn 0;\n\n\t/*\n\t * The Counter does not stop when it reaches zero. In\n\t * Modes 0, 1, 4, and 5 the Counter ``wraps around'' to\n\t * the highest count, either FFFF hex for binary counting\n\t * or 9999 for BCD counting, and continues counting.\n\t * Modes 2 and 3 are periodic; the Counter reloads\n\t * itself with the initial count and continues counting\n\t * from there.\n\t */\n\tremaining = hrtimer_get_remaining(&ps->timer);\n\telapsed = ps->period - ktime_to_ns(remaining);\n\n\treturn elapsed;\n}\n\nstatic s64 kpit_elapsed(struct kvm *kvm, struct kvm_kpit_channel_state *c,\n\t\t\tint channel)\n{\n\tif (channel == 0)\n\t\treturn __kpit_elapsed(kvm);\n\n\treturn ktime_to_ns(ktime_sub(ktime_get(), c->count_load_time));\n}\n\nstatic int pit_get_count(struct kvm *kvm, int channel)\n{\n\tstruct kvm_kpit_channel_state *c =\n\t\t&kvm->arch.vpit->pit_state.channels[channel];\n\ts64 d, t;\n\tint counter;\n\n\tWARN_ON(!mutex_is_locked(&kvm->arch.vpit->pit_state.lock));\n\n\tt = kpit_elapsed(kvm, c, channel);\n\td = muldiv64(t, KVM_PIT_FREQ, NSEC_PER_SEC);\n\n\tswitch (c->mode) {\n\tcase 0:\n\tcase 1:\n\tcase 4:\n\tcase 5:\n\t\tcounter = (c->count - d) & 0xffff;\n\t\tbreak;\n\tcase 3:\n\t\t/* XXX: may be incorrect for odd counts */\n\t\tcounter = c->count - (mod_64((2 * d), c->count));\n\t\tbreak;\n\tdefault:\n\t\tcounter = c->count - mod_64(d, c->count);\n\t\tbreak;\n\t}\n\treturn counter;\n}\n\nstatic int pit_get_out(struct kvm *kvm, int channel)\n{\n\tstruct kvm_kpit_channel_state *c =\n\t\t&kvm->arch.vpit->pit_state.channels[channel];\n\ts64 d, t;\n\tint out;\n\n\tWARN_ON(!mutex_is_locked(&kvm->arch.vpit->pit_state.lock));\n\n\tt = kpit_elapsed(kvm, c, channel);\n\td = muldiv64(t, KVM_PIT_FREQ, NSEC_PER_SEC);\n\n\tswitch (c->mode) {\n\tdefault:\n\tcase 0:\n\t\tout = (d >= c->count);\n\t\tbreak;\n\tcase 1:\n\t\tout = (d < c->count);\n\t\tbreak;\n\tcase 2:\n\t\tout = ((mod_64(d, c->count) == 0) && (d != 0));\n\t\tbreak;\n\tcase 3:\n\t\tout = (mod_64(d, c->count) < ((c->count + 1) >> 1));\n\t\tbreak;\n\tcase 4:\n\tcase 5:\n\t\tout = (d == c->count);\n\t\tbreak;\n\t}\n\n\treturn out;\n}\n\nstatic void pit_latch_count(struct kvm *kvm, int channel)\n{\n\tstruct kvm_kpit_channel_state *c =\n\t\t&kvm->arch.vpit->pit_state.channels[channel];\n\n\tWARN_ON(!mutex_is_locked(&kvm->arch.vpit->pit_state.lock));\n\n\tif (!c->count_latched) {\n\t\tc->latched_count = pit_get_count(kvm, channel);\n\t\tc->count_latched = c->rw_mode;\n\t}\n}\n\nstatic void pit_latch_status(struct kvm *kvm, int channel)\n{\n\tstruct kvm_kpit_channel_state *c =\n\t\t&kvm->arch.vpit->pit_state.channels[channel];\n\n\tWARN_ON(!mutex_is_locked(&kvm->arch.vpit->pit_state.lock));\n\n\tif (!c->status_latched) {\n\t\t/* TODO: Return NULL COUNT (bit 6). */\n\t\tc->status = ((pit_get_out(kvm, channel) << 7) |\n\t\t\t\t(c->rw_mode << 4) |\n\t\t\t\t(c->mode << 1) |\n\t\t\t\tc->bcd);\n\t\tc->status_latched = 1;\n\t}\n}\n\nstatic void kvm_pit_ack_irq(struct kvm_irq_ack_notifier *kian)\n{\n\tstruct kvm_kpit_state *ps = container_of(kian, struct kvm_kpit_state,\n\t\t\t\t\t\t irq_ack_notifier);\n\tint value;\n\n\tspin_lock(&ps->inject_lock);\n\tvalue = atomic_dec_return(&ps->pending);\n\tif (value < 0)\n\t\t/* spurious acks can be generated if, for example, the\n\t\t * PIC is being reset.  Handle it gracefully here\n\t\t */\n\t\tatomic_inc(&ps->pending);\n\telse if (value > 0)\n\t\t/* in this case, we had multiple outstanding pit interrupts\n\t\t * that we needed to inject.  Reinject\n\t\t */\n\t\tqueue_kthread_work(&ps->pit->worker, &ps->pit->expired);\n\tps->irq_ack = 1;\n\tspin_unlock(&ps->inject_lock);\n}\n\nvoid __kvm_migrate_pit_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pit *pit = vcpu->kvm->arch.vpit;\n\tstruct hrtimer *timer;\n\n\tif (!kvm_vcpu_is_bsp(vcpu) || !pit)\n\t\treturn;\n\n\ttimer = &pit->pit_state.timer;\n\tif (hrtimer_cancel(timer))\n\t\thrtimer_start_expires(timer, HRTIMER_MODE_ABS);\n}\n\nstatic void destroy_pit_timer(struct kvm_pit *pit)\n{\n\thrtimer_cancel(&pit->pit_state.timer);\n\tflush_kthread_work(&pit->expired);\n}\n\nstatic void pit_do_work(struct kthread_work *work)\n{\n\tstruct kvm_pit *pit = container_of(work, struct kvm_pit, expired);\n\tstruct kvm *kvm = pit->kvm;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\tstruct kvm_kpit_state *ps = &pit->pit_state;\n\tint inject = 0;\n\n\t/* Try to inject pending interrupts when\n\t * last one has been acked.\n\t */\n\tspin_lock(&ps->inject_lock);\n\tif (ps->irq_ack) {\n\t\tps->irq_ack = 0;\n\t\tinject = 1;\n\t}\n\tspin_unlock(&ps->inject_lock);\n\tif (inject) {\n\t\tkvm_set_irq(kvm, kvm->arch.vpit->irq_source_id, 0, 1, false);\n\t\tkvm_set_irq(kvm, kvm->arch.vpit->irq_source_id, 0, 0, false);\n\n\t\t/*\n\t\t * Provides NMI watchdog support via Virtual Wire mode.\n\t\t * The route is: PIT -> PIC -> LVT0 in NMI mode.\n\t\t *\n\t\t * Note: Our Virtual Wire implementation is simplified, only\n\t\t * propagating PIT interrupts to all VCPUs when they have set\n\t\t * LVT0 to NMI delivery. Other PIC interrupts are just sent to\n\t\t * VCPU0, and only if its LVT0 is in EXTINT mode.\n\t\t */\n\t\tif (kvm->arch.vapics_in_nmi_mode > 0)\n\t\t\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\t\t\tkvm_apic_nmi_wd_deliver(vcpu);\n\t}\n}\n\nstatic enum hrtimer_restart pit_timer_fn(struct hrtimer *data)\n{\n\tstruct kvm_kpit_state *ps = container_of(data, struct kvm_kpit_state, timer);\n\tstruct kvm_pit *pt = ps->kvm->arch.vpit;\n\n\tif (ps->reinject || !atomic_read(&ps->pending)) {\n\t\tatomic_inc(&ps->pending);\n\t\tqueue_kthread_work(&pt->worker, &pt->expired);\n\t}\n\n\tif (ps->is_periodic) {\n\t\thrtimer_add_expires_ns(&ps->timer, ps->period);\n\t\treturn HRTIMER_RESTART;\n\t} else\n\t\treturn HRTIMER_NORESTART;\n}\n\nstatic void create_pit_timer(struct kvm *kvm, u32 val, int is_period)\n{\n\tstruct kvm_kpit_state *ps = &kvm->arch.vpit->pit_state;\n\ts64 interval;\n\n\tif (!irqchip_in_kernel(kvm) || ps->flags & KVM_PIT_FLAGS_HPET_LEGACY)\n\t\treturn;\n\n\tinterval = muldiv64(val, NSEC_PER_SEC, KVM_PIT_FREQ);\n\n\tpr_debug(\"create pit timer, interval is %llu nsec\\n\", interval);\n\n\t/* TODO The new value only affected after the retriggered */\n\thrtimer_cancel(&ps->timer);\n\tflush_kthread_work(&ps->pit->expired);\n\tps->period = interval;\n\tps->is_periodic = is_period;\n\n\tps->timer.function = pit_timer_fn;\n\tps->kvm = ps->pit->kvm;\n\n\tatomic_set(&ps->pending, 0);\n\tps->irq_ack = 1;\n\n\t/*\n\t * Do not allow the guest to program periodic timers with small\n\t * interval, since the hrtimers are not throttled by the host\n\t * scheduler.\n\t */\n\tif (ps->is_periodic) {\n\t\ts64 min_period = min_timer_period_us * 1000LL;\n\n\t\tif (ps->period < min_period) {\n\t\t\tpr_info_ratelimited(\n\t\t\t    \"kvm: requested %lld ns \"\n\t\t\t    \"i8254 timer period limited to %lld ns\\n\",\n\t\t\t    ps->period, min_period);\n\t\t\tps->period = min_period;\n\t\t}\n\t}\n\n\thrtimer_start(&ps->timer, ktime_add_ns(ktime_get(), interval),\n\t\t      HRTIMER_MODE_ABS);\n}\n\nstatic void pit_load_count(struct kvm *kvm, int channel, u32 val)\n{\n\tstruct kvm_kpit_state *ps = &kvm->arch.vpit->pit_state;\n\n\tWARN_ON(!mutex_is_locked(&ps->lock));\n\n\tpr_debug(\"load_count val is %d, channel is %d\\n\", val, channel);\n\n\t/*\n\t * The largest possible initial count is 0; this is equivalent\n\t * to 216 for binary counting and 104 for BCD counting.\n\t */\n\tif (val == 0)\n\t\tval = 0x10000;\n\n\tps->channels[channel].count = val;\n\n\tif (channel != 0) {\n\t\tps->channels[channel].count_load_time = ktime_get();\n\t\treturn;\n\t}\n\n\t/* Two types of timer\n\t * mode 1 is one shot, mode 2 is period, otherwise del timer */\n\tswitch (ps->channels[0].mode) {\n\tcase 0:\n\tcase 1:\n        /* FIXME: enhance mode 4 precision */\n\tcase 4:\n\t\tcreate_pit_timer(kvm, val, 0);\n\t\tbreak;\n\tcase 2:\n\tcase 3:\n\t\tcreate_pit_timer(kvm, val, 1);\n\t\tbreak;\n\tdefault:\n\t\tdestroy_pit_timer(kvm->arch.vpit);\n\t}\n}\n\nvoid kvm_pit_load_count(struct kvm *kvm, int channel, u32 val, int hpet_legacy_start)\n{\n\tu8 saved_mode;\n\tif (hpet_legacy_start) {\n\t\t/* save existing mode for later reenablement */\n\t\tsaved_mode = kvm->arch.vpit->pit_state.channels[0].mode;\n\t\tkvm->arch.vpit->pit_state.channels[0].mode = 0xff; /* disable timer */\n\t\tpit_load_count(kvm, channel, val);\n\t\tkvm->arch.vpit->pit_state.channels[0].mode = saved_mode;\n\t} else {\n\t\tpit_load_count(kvm, channel, val);\n\t}\n}\n\nstatic inline struct kvm_pit *dev_to_pit(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_pit, dev);\n}\n\nstatic inline struct kvm_pit *speaker_to_pit(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_pit, speaker_dev);\n}\n\nstatic inline int pit_in_range(gpa_t addr)\n{\n\treturn ((addr >= KVM_PIT_BASE_ADDRESS) &&\n\t\t(addr < KVM_PIT_BASE_ADDRESS + KVM_PIT_MEM_LENGTH));\n}\n\nstatic int pit_ioport_write(struct kvm_io_device *this,\n\t\t\t    gpa_t addr, int len, const void *data)\n{\n\tstruct kvm_pit *pit = dev_to_pit(this);\n\tstruct kvm_kpit_state *pit_state = &pit->pit_state;\n\tstruct kvm *kvm = pit->kvm;\n\tint channel, access;\n\tstruct kvm_kpit_channel_state *s;\n\tu32 val = *(u32 *) data;\n\tif (!pit_in_range(addr))\n\t\treturn -EOPNOTSUPP;\n\n\tval  &= 0xff;\n\taddr &= KVM_PIT_CHANNEL_MASK;\n\n\tmutex_lock(&pit_state->lock);\n\n\tif (val != 0)\n\t\tpr_debug(\"write addr is 0x%x, len is %d, val is 0x%x\\n\",\n\t\t\t (unsigned int)addr, len, val);\n\n\tif (addr == 3) {\n\t\tchannel = val >> 6;\n\t\tif (channel == 3) {\n\t\t\t/* Read-Back Command. */\n\t\t\tfor (channel = 0; channel < 3; channel++) {\n\t\t\t\ts = &pit_state->channels[channel];\n\t\t\t\tif (val & (2 << channel)) {\n\t\t\t\t\tif (!(val & 0x20))\n\t\t\t\t\t\tpit_latch_count(kvm, channel);\n\t\t\t\t\tif (!(val & 0x10))\n\t\t\t\t\t\tpit_latch_status(kvm, channel);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t/* Select Counter <channel>. */\n\t\t\ts = &pit_state->channels[channel];\n\t\t\taccess = (val >> 4) & KVM_PIT_CHANNEL_MASK;\n\t\t\tif (access == 0) {\n\t\t\t\tpit_latch_count(kvm, channel);\n\t\t\t} else {\n\t\t\t\ts->rw_mode = access;\n\t\t\t\ts->read_state = access;\n\t\t\t\ts->write_state = access;\n\t\t\t\ts->mode = (val >> 1) & 7;\n\t\t\t\tif (s->mode > 5)\n\t\t\t\t\ts->mode -= 4;\n\t\t\t\ts->bcd = val & 1;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* Write Count. */\n\t\ts = &pit_state->channels[addr];\n\t\tswitch (s->write_state) {\n\t\tdefault:\n\t\tcase RW_STATE_LSB:\n\t\t\tpit_load_count(kvm, addr, val);\n\t\t\tbreak;\n\t\tcase RW_STATE_MSB:\n\t\t\tpit_load_count(kvm, addr, val << 8);\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD0:\n\t\t\ts->write_latch = val;\n\t\t\ts->write_state = RW_STATE_WORD1;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD1:\n\t\t\tpit_load_count(kvm, addr, s->write_latch | (val << 8));\n\t\t\ts->write_state = RW_STATE_WORD0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&pit_state->lock);\n\treturn 0;\n}\n\nstatic int pit_ioport_read(struct kvm_io_device *this,\n\t\t\t   gpa_t addr, int len, void *data)\n{\n\tstruct kvm_pit *pit = dev_to_pit(this);\n\tstruct kvm_kpit_state *pit_state = &pit->pit_state;\n\tstruct kvm *kvm = pit->kvm;\n\tint ret, count;\n\tstruct kvm_kpit_channel_state *s;\n\tif (!pit_in_range(addr))\n\t\treturn -EOPNOTSUPP;\n\n\taddr &= KVM_PIT_CHANNEL_MASK;\n\tif (addr == 3)\n\t\treturn 0;\n\n\ts = &pit_state->channels[addr];\n\n\tmutex_lock(&pit_state->lock);\n\n\tif (s->status_latched) {\n\t\ts->status_latched = 0;\n\t\tret = s->status;\n\t} else if (s->count_latched) {\n\t\tswitch (s->count_latched) {\n\t\tdefault:\n\t\tcase RW_STATE_LSB:\n\t\t\tret = s->latched_count & 0xff;\n\t\t\ts->count_latched = 0;\n\t\t\tbreak;\n\t\tcase RW_STATE_MSB:\n\t\t\tret = s->latched_count >> 8;\n\t\t\ts->count_latched = 0;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD0:\n\t\t\tret = s->latched_count & 0xff;\n\t\t\ts->count_latched = RW_STATE_MSB;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (s->read_state) {\n\t\tdefault:\n\t\tcase RW_STATE_LSB:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = count & 0xff;\n\t\t\tbreak;\n\t\tcase RW_STATE_MSB:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = (count >> 8) & 0xff;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD0:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = count & 0xff;\n\t\t\ts->read_state = RW_STATE_WORD1;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD1:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = (count >> 8) & 0xff;\n\t\t\ts->read_state = RW_STATE_WORD0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (len > sizeof(ret))\n\t\tlen = sizeof(ret);\n\tmemcpy(data, (char *)&ret, len);\n\n\tmutex_unlock(&pit_state->lock);\n\treturn 0;\n}\n\nstatic int speaker_ioport_write(struct kvm_io_device *this,\n\t\t\t\tgpa_t addr, int len, const void *data)\n{\n\tstruct kvm_pit *pit = speaker_to_pit(this);\n\tstruct kvm_kpit_state *pit_state = &pit->pit_state;\n\tstruct kvm *kvm = pit->kvm;\n\tu32 val = *(u32 *) data;\n\tif (addr != KVM_SPEAKER_BASE_ADDRESS)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&pit_state->lock);\n\tpit_state->speaker_data_on = (val >> 1) & 1;\n\tpit_set_gate(kvm, 2, val & 1);\n\tmutex_unlock(&pit_state->lock);\n\treturn 0;\n}\n\nstatic int speaker_ioport_read(struct kvm_io_device *this,\n\t\t\t       gpa_t addr, int len, void *data)\n{\n\tstruct kvm_pit *pit = speaker_to_pit(this);\n\tstruct kvm_kpit_state *pit_state = &pit->pit_state;\n\tstruct kvm *kvm = pit->kvm;\n\tunsigned int refresh_clock;\n\tint ret;\n\tif (addr != KVM_SPEAKER_BASE_ADDRESS)\n\t\treturn -EOPNOTSUPP;\n\n\t/* Refresh clock toggles at about 15us. We approximate as 2^14ns. */\n\trefresh_clock = ((unsigned int)ktime_to_ns(ktime_get()) >> 14) & 1;\n\n\tmutex_lock(&pit_state->lock);\n\tret = ((pit_state->speaker_data_on << 1) | pit_get_gate(kvm, 2) |\n\t\t(pit_get_out(kvm, 2) << 5) | (refresh_clock << 4));\n\tif (len > sizeof(ret))\n\t\tlen = sizeof(ret);\n\tmemcpy(data, (char *)&ret, len);\n\tmutex_unlock(&pit_state->lock);\n\treturn 0;\n}\n\nvoid kvm_pit_reset(struct kvm_pit *pit)\n{\n\tint i;\n\tstruct kvm_kpit_channel_state *c;\n\n\tmutex_lock(&pit->pit_state.lock);\n\tpit->pit_state.flags = 0;\n\tfor (i = 0; i < 3; i++) {\n\t\tc = &pit->pit_state.channels[i];\n\t\tc->mode = 0xff;\n\t\tc->gate = (i != 2);\n\t\tpit_load_count(pit->kvm, i, 0);\n\t}\n\tmutex_unlock(&pit->pit_state.lock);\n\n\tatomic_set(&pit->pit_state.pending, 0);\n\tpit->pit_state.irq_ack = 1;\n}\n\nstatic void pit_mask_notifer(struct kvm_irq_mask_notifier *kimn, bool mask)\n{\n\tstruct kvm_pit *pit = container_of(kimn, struct kvm_pit, mask_notifier);\n\n\tif (!mask) {\n\t\tatomic_set(&pit->pit_state.pending, 0);\n\t\tpit->pit_state.irq_ack = 1;\n\t}\n}\n\nstatic const struct kvm_io_device_ops pit_dev_ops = {\n\t.read     = pit_ioport_read,\n\t.write    = pit_ioport_write,\n};\n\nstatic const struct kvm_io_device_ops speaker_dev_ops = {\n\t.read     = speaker_ioport_read,\n\t.write    = speaker_ioport_write,\n};\n\n/* Caller must hold slots_lock */\nstruct kvm_pit *kvm_create_pit(struct kvm *kvm, u32 flags)\n{\n\tstruct kvm_pit *pit;\n\tstruct kvm_kpit_state *pit_state;\n\tstruct pid *pid;\n\tpid_t pid_nr;\n\tint ret;\n\n\tpit = kzalloc(sizeof(struct kvm_pit), GFP_KERNEL);\n\tif (!pit)\n\t\treturn NULL;\n\n\tpit->irq_source_id = kvm_request_irq_source_id(kvm);\n\tif (pit->irq_source_id < 0) {\n\t\tkfree(pit);\n\t\treturn NULL;\n\t}\n\n\tmutex_init(&pit->pit_state.lock);\n\tmutex_lock(&pit->pit_state.lock);\n\tspin_lock_init(&pit->pit_state.inject_lock);\n\n\tpid = get_pid(task_tgid(current));\n\tpid_nr = pid_vnr(pid);\n\tput_pid(pid);\n\n\tinit_kthread_worker(&pit->worker);\n\tpit->worker_task = kthread_run(kthread_worker_fn, &pit->worker,\n\t\t\t\t       \"kvm-pit/%d\", pid_nr);\n\tif (IS_ERR(pit->worker_task)) {\n\t\tmutex_unlock(&pit->pit_state.lock);\n\t\tkvm_free_irq_source_id(kvm, pit->irq_source_id);\n\t\tkfree(pit);\n\t\treturn NULL;\n\t}\n\tinit_kthread_work(&pit->expired, pit_do_work);\n\n\tkvm->arch.vpit = pit;\n\tpit->kvm = kvm;\n\n\tpit_state = &pit->pit_state;\n\tpit_state->pit = pit;\n\thrtimer_init(&pit_state->timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\tpit_state->irq_ack_notifier.gsi = 0;\n\tpit_state->irq_ack_notifier.irq_acked = kvm_pit_ack_irq;\n\tkvm_register_irq_ack_notifier(kvm, &pit_state->irq_ack_notifier);\n\tpit_state->reinject = true;\n\tmutex_unlock(&pit->pit_state.lock);\n\n\tkvm_pit_reset(pit);\n\n\tpit->mask_notifier.func = pit_mask_notifer;\n\tkvm_register_irq_mask_notifier(kvm, 0, &pit->mask_notifier);\n\n\tkvm_iodevice_init(&pit->dev, &pit_dev_ops);\n\tret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, KVM_PIT_BASE_ADDRESS,\n\t\t\t\t      KVM_PIT_MEM_LENGTH, &pit->dev);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tif (flags & KVM_PIT_SPEAKER_DUMMY) {\n\t\tkvm_iodevice_init(&pit->speaker_dev, &speaker_dev_ops);\n\t\tret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS,\n\t\t\t\t\t      KVM_SPEAKER_BASE_ADDRESS, 4,\n\t\t\t\t\t      &pit->speaker_dev);\n\t\tif (ret < 0)\n\t\t\tgoto fail_unregister;\n\t}\n\n\treturn pit;\n\nfail_unregister:\n\tkvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS, &pit->dev);\n\nfail:\n\tkvm_unregister_irq_mask_notifier(kvm, 0, &pit->mask_notifier);\n\tkvm_unregister_irq_ack_notifier(kvm, &pit_state->irq_ack_notifier);\n\tkvm_free_irq_source_id(kvm, pit->irq_source_id);\n\tkthread_stop(pit->worker_task);\n\tkfree(pit);\n\treturn NULL;\n}\n\nvoid kvm_free_pit(struct kvm *kvm)\n{\n\tstruct hrtimer *timer;\n\n\tif (kvm->arch.vpit) {\n\t\tkvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS, &kvm->arch.vpit->dev);\n\t\tkvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS,\n\t\t\t\t\t      &kvm->arch.vpit->speaker_dev);\n\t\tkvm_unregister_irq_mask_notifier(kvm, 0,\n\t\t\t\t\t       &kvm->arch.vpit->mask_notifier);\n\t\tkvm_unregister_irq_ack_notifier(kvm,\n\t\t\t\t&kvm->arch.vpit->pit_state.irq_ack_notifier);\n\t\tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n\t\ttimer = &kvm->arch.vpit->pit_state.timer;\n\t\thrtimer_cancel(timer);\n\t\tflush_kthread_work(&kvm->arch.vpit->expired);\n\t\tkthread_stop(kvm->arch.vpit->worker_task);\n\t\tkvm_free_irq_source_id(kvm, kvm->arch.vpit->irq_source_id);\n\t\tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n\t\tkfree(kvm->arch.vpit);\n\t}\n}\n"], "fixing_code": ["/*\n * 8253/8254 interval timer emulation\n *\n * Copyright (c) 2003-2004 Fabrice Bellard\n * Copyright (c) 2006 Intel Corporation\n * Copyright (c) 2007 Keir Fraser, XenSource Inc\n * Copyright (c) 2008 Intel Corporation\n * Copyright 2009 Red Hat, Inc. and/or its affiliates.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * Authors:\n *   Sheng Yang <sheng.yang@intel.com>\n *   Based on QEMU and Xen.\n */\n\n#define pr_fmt(fmt) \"pit: \" fmt\n\n#include <linux/kvm_host.h>\n#include <linux/slab.h>\n\n#include \"irq.h\"\n#include \"i8254.h\"\n#include \"x86.h\"\n\n#ifndef CONFIG_X86_64\n#define mod_64(x, y) ((x) - (y) * div64_u64(x, y))\n#else\n#define mod_64(x, y) ((x) % (y))\n#endif\n\n#define RW_STATE_LSB 1\n#define RW_STATE_MSB 2\n#define RW_STATE_WORD0 3\n#define RW_STATE_WORD1 4\n\n/* Compute with 96 bit intermediate result: (a*b)/c */\nstatic u64 muldiv64(u64 a, u32 b, u32 c)\n{\n\tunion {\n\t\tu64 ll;\n\t\tstruct {\n\t\t\tu32 low, high;\n\t\t} l;\n\t} u, res;\n\tu64 rl, rh;\n\n\tu.ll = a;\n\trl = (u64)u.l.low * (u64)b;\n\trh = (u64)u.l.high * (u64)b;\n\trh += (rl >> 32);\n\tres.l.high = div64_u64(rh, c);\n\tres.l.low = div64_u64(((mod_64(rh, c) << 32) + (rl & 0xffffffff)), c);\n\treturn res.ll;\n}\n\nstatic void pit_set_gate(struct kvm *kvm, int channel, u32 val)\n{\n\tstruct kvm_kpit_channel_state *c =\n\t\t&kvm->arch.vpit->pit_state.channels[channel];\n\n\tWARN_ON(!mutex_is_locked(&kvm->arch.vpit->pit_state.lock));\n\n\tswitch (c->mode) {\n\tdefault:\n\tcase 0:\n\tcase 4:\n\t\t/* XXX: just disable/enable counting */\n\t\tbreak;\n\tcase 1:\n\tcase 2:\n\tcase 3:\n\tcase 5:\n\t\t/* Restart counting on rising edge. */\n\t\tif (c->gate < val)\n\t\t\tc->count_load_time = ktime_get();\n\t\tbreak;\n\t}\n\n\tc->gate = val;\n}\n\nstatic int pit_get_gate(struct kvm *kvm, int channel)\n{\n\tWARN_ON(!mutex_is_locked(&kvm->arch.vpit->pit_state.lock));\n\n\treturn kvm->arch.vpit->pit_state.channels[channel].gate;\n}\n\nstatic s64 __kpit_elapsed(struct kvm *kvm)\n{\n\ts64 elapsed;\n\tktime_t remaining;\n\tstruct kvm_kpit_state *ps = &kvm->arch.vpit->pit_state;\n\n\tif (!ps->period)\n\t\treturn 0;\n\n\t/*\n\t * The Counter does not stop when it reaches zero. In\n\t * Modes 0, 1, 4, and 5 the Counter ``wraps around'' to\n\t * the highest count, either FFFF hex for binary counting\n\t * or 9999 for BCD counting, and continues counting.\n\t * Modes 2 and 3 are periodic; the Counter reloads\n\t * itself with the initial count and continues counting\n\t * from there.\n\t */\n\tremaining = hrtimer_get_remaining(&ps->timer);\n\telapsed = ps->period - ktime_to_ns(remaining);\n\n\treturn elapsed;\n}\n\nstatic s64 kpit_elapsed(struct kvm *kvm, struct kvm_kpit_channel_state *c,\n\t\t\tint channel)\n{\n\tif (channel == 0)\n\t\treturn __kpit_elapsed(kvm);\n\n\treturn ktime_to_ns(ktime_sub(ktime_get(), c->count_load_time));\n}\n\nstatic int pit_get_count(struct kvm *kvm, int channel)\n{\n\tstruct kvm_kpit_channel_state *c =\n\t\t&kvm->arch.vpit->pit_state.channels[channel];\n\ts64 d, t;\n\tint counter;\n\n\tWARN_ON(!mutex_is_locked(&kvm->arch.vpit->pit_state.lock));\n\n\tt = kpit_elapsed(kvm, c, channel);\n\td = muldiv64(t, KVM_PIT_FREQ, NSEC_PER_SEC);\n\n\tswitch (c->mode) {\n\tcase 0:\n\tcase 1:\n\tcase 4:\n\tcase 5:\n\t\tcounter = (c->count - d) & 0xffff;\n\t\tbreak;\n\tcase 3:\n\t\t/* XXX: may be incorrect for odd counts */\n\t\tcounter = c->count - (mod_64((2 * d), c->count));\n\t\tbreak;\n\tdefault:\n\t\tcounter = c->count - mod_64(d, c->count);\n\t\tbreak;\n\t}\n\treturn counter;\n}\n\nstatic int pit_get_out(struct kvm *kvm, int channel)\n{\n\tstruct kvm_kpit_channel_state *c =\n\t\t&kvm->arch.vpit->pit_state.channels[channel];\n\ts64 d, t;\n\tint out;\n\n\tWARN_ON(!mutex_is_locked(&kvm->arch.vpit->pit_state.lock));\n\n\tt = kpit_elapsed(kvm, c, channel);\n\td = muldiv64(t, KVM_PIT_FREQ, NSEC_PER_SEC);\n\n\tswitch (c->mode) {\n\tdefault:\n\tcase 0:\n\t\tout = (d >= c->count);\n\t\tbreak;\n\tcase 1:\n\t\tout = (d < c->count);\n\t\tbreak;\n\tcase 2:\n\t\tout = ((mod_64(d, c->count) == 0) && (d != 0));\n\t\tbreak;\n\tcase 3:\n\t\tout = (mod_64(d, c->count) < ((c->count + 1) >> 1));\n\t\tbreak;\n\tcase 4:\n\tcase 5:\n\t\tout = (d == c->count);\n\t\tbreak;\n\t}\n\n\treturn out;\n}\n\nstatic void pit_latch_count(struct kvm *kvm, int channel)\n{\n\tstruct kvm_kpit_channel_state *c =\n\t\t&kvm->arch.vpit->pit_state.channels[channel];\n\n\tWARN_ON(!mutex_is_locked(&kvm->arch.vpit->pit_state.lock));\n\n\tif (!c->count_latched) {\n\t\tc->latched_count = pit_get_count(kvm, channel);\n\t\tc->count_latched = c->rw_mode;\n\t}\n}\n\nstatic void pit_latch_status(struct kvm *kvm, int channel)\n{\n\tstruct kvm_kpit_channel_state *c =\n\t\t&kvm->arch.vpit->pit_state.channels[channel];\n\n\tWARN_ON(!mutex_is_locked(&kvm->arch.vpit->pit_state.lock));\n\n\tif (!c->status_latched) {\n\t\t/* TODO: Return NULL COUNT (bit 6). */\n\t\tc->status = ((pit_get_out(kvm, channel) << 7) |\n\t\t\t\t(c->rw_mode << 4) |\n\t\t\t\t(c->mode << 1) |\n\t\t\t\tc->bcd);\n\t\tc->status_latched = 1;\n\t}\n}\n\nstatic void kvm_pit_ack_irq(struct kvm_irq_ack_notifier *kian)\n{\n\tstruct kvm_kpit_state *ps = container_of(kian, struct kvm_kpit_state,\n\t\t\t\t\t\t irq_ack_notifier);\n\tint value;\n\n\tspin_lock(&ps->inject_lock);\n\tvalue = atomic_dec_return(&ps->pending);\n\tif (value < 0)\n\t\t/* spurious acks can be generated if, for example, the\n\t\t * PIC is being reset.  Handle it gracefully here\n\t\t */\n\t\tatomic_inc(&ps->pending);\n\telse if (value > 0)\n\t\t/* in this case, we had multiple outstanding pit interrupts\n\t\t * that we needed to inject.  Reinject\n\t\t */\n\t\tqueue_kthread_work(&ps->pit->worker, &ps->pit->expired);\n\tps->irq_ack = 1;\n\tspin_unlock(&ps->inject_lock);\n}\n\nvoid __kvm_migrate_pit_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pit *pit = vcpu->kvm->arch.vpit;\n\tstruct hrtimer *timer;\n\n\tif (!kvm_vcpu_is_bsp(vcpu) || !pit)\n\t\treturn;\n\n\ttimer = &pit->pit_state.timer;\n\tmutex_lock(&pit->pit_state.lock);\n\tif (hrtimer_cancel(timer))\n\t\thrtimer_start_expires(timer, HRTIMER_MODE_ABS);\n\tmutex_unlock(&pit->pit_state.lock);\n}\n\nstatic void destroy_pit_timer(struct kvm_pit *pit)\n{\n\thrtimer_cancel(&pit->pit_state.timer);\n\tflush_kthread_work(&pit->expired);\n}\n\nstatic void pit_do_work(struct kthread_work *work)\n{\n\tstruct kvm_pit *pit = container_of(work, struct kvm_pit, expired);\n\tstruct kvm *kvm = pit->kvm;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\tstruct kvm_kpit_state *ps = &pit->pit_state;\n\tint inject = 0;\n\n\t/* Try to inject pending interrupts when\n\t * last one has been acked.\n\t */\n\tspin_lock(&ps->inject_lock);\n\tif (ps->irq_ack) {\n\t\tps->irq_ack = 0;\n\t\tinject = 1;\n\t}\n\tspin_unlock(&ps->inject_lock);\n\tif (inject) {\n\t\tkvm_set_irq(kvm, kvm->arch.vpit->irq_source_id, 0, 1, false);\n\t\tkvm_set_irq(kvm, kvm->arch.vpit->irq_source_id, 0, 0, false);\n\n\t\t/*\n\t\t * Provides NMI watchdog support via Virtual Wire mode.\n\t\t * The route is: PIT -> PIC -> LVT0 in NMI mode.\n\t\t *\n\t\t * Note: Our Virtual Wire implementation is simplified, only\n\t\t * propagating PIT interrupts to all VCPUs when they have set\n\t\t * LVT0 to NMI delivery. Other PIC interrupts are just sent to\n\t\t * VCPU0, and only if its LVT0 is in EXTINT mode.\n\t\t */\n\t\tif (kvm->arch.vapics_in_nmi_mode > 0)\n\t\t\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\t\t\tkvm_apic_nmi_wd_deliver(vcpu);\n\t}\n}\n\nstatic enum hrtimer_restart pit_timer_fn(struct hrtimer *data)\n{\n\tstruct kvm_kpit_state *ps = container_of(data, struct kvm_kpit_state, timer);\n\tstruct kvm_pit *pt = ps->kvm->arch.vpit;\n\n\tif (ps->reinject || !atomic_read(&ps->pending)) {\n\t\tatomic_inc(&ps->pending);\n\t\tqueue_kthread_work(&pt->worker, &pt->expired);\n\t}\n\n\tif (ps->is_periodic) {\n\t\thrtimer_add_expires_ns(&ps->timer, ps->period);\n\t\treturn HRTIMER_RESTART;\n\t} else\n\t\treturn HRTIMER_NORESTART;\n}\n\nstatic void create_pit_timer(struct kvm *kvm, u32 val, int is_period)\n{\n\tstruct kvm_kpit_state *ps = &kvm->arch.vpit->pit_state;\n\ts64 interval;\n\n\tif (!irqchip_in_kernel(kvm) || ps->flags & KVM_PIT_FLAGS_HPET_LEGACY)\n\t\treturn;\n\n\tinterval = muldiv64(val, NSEC_PER_SEC, KVM_PIT_FREQ);\n\n\tpr_debug(\"create pit timer, interval is %llu nsec\\n\", interval);\n\n\t/* TODO The new value only affected after the retriggered */\n\thrtimer_cancel(&ps->timer);\n\tflush_kthread_work(&ps->pit->expired);\n\tps->period = interval;\n\tps->is_periodic = is_period;\n\n\tps->timer.function = pit_timer_fn;\n\tps->kvm = ps->pit->kvm;\n\n\tatomic_set(&ps->pending, 0);\n\tps->irq_ack = 1;\n\n\t/*\n\t * Do not allow the guest to program periodic timers with small\n\t * interval, since the hrtimers are not throttled by the host\n\t * scheduler.\n\t */\n\tif (ps->is_periodic) {\n\t\ts64 min_period = min_timer_period_us * 1000LL;\n\n\t\tif (ps->period < min_period) {\n\t\t\tpr_info_ratelimited(\n\t\t\t    \"kvm: requested %lld ns \"\n\t\t\t    \"i8254 timer period limited to %lld ns\\n\",\n\t\t\t    ps->period, min_period);\n\t\t\tps->period = min_period;\n\t\t}\n\t}\n\n\thrtimer_start(&ps->timer, ktime_add_ns(ktime_get(), interval),\n\t\t      HRTIMER_MODE_ABS);\n}\n\nstatic void pit_load_count(struct kvm *kvm, int channel, u32 val)\n{\n\tstruct kvm_kpit_state *ps = &kvm->arch.vpit->pit_state;\n\n\tWARN_ON(!mutex_is_locked(&ps->lock));\n\n\tpr_debug(\"load_count val is %d, channel is %d\\n\", val, channel);\n\n\t/*\n\t * The largest possible initial count is 0; this is equivalent\n\t * to 216 for binary counting and 104 for BCD counting.\n\t */\n\tif (val == 0)\n\t\tval = 0x10000;\n\n\tps->channels[channel].count = val;\n\n\tif (channel != 0) {\n\t\tps->channels[channel].count_load_time = ktime_get();\n\t\treturn;\n\t}\n\n\t/* Two types of timer\n\t * mode 1 is one shot, mode 2 is period, otherwise del timer */\n\tswitch (ps->channels[0].mode) {\n\tcase 0:\n\tcase 1:\n        /* FIXME: enhance mode 4 precision */\n\tcase 4:\n\t\tcreate_pit_timer(kvm, val, 0);\n\t\tbreak;\n\tcase 2:\n\tcase 3:\n\t\tcreate_pit_timer(kvm, val, 1);\n\t\tbreak;\n\tdefault:\n\t\tdestroy_pit_timer(kvm->arch.vpit);\n\t}\n}\n\nvoid kvm_pit_load_count(struct kvm *kvm, int channel, u32 val, int hpet_legacy_start)\n{\n\tu8 saved_mode;\n\tif (hpet_legacy_start) {\n\t\t/* save existing mode for later reenablement */\n\t\tsaved_mode = kvm->arch.vpit->pit_state.channels[0].mode;\n\t\tkvm->arch.vpit->pit_state.channels[0].mode = 0xff; /* disable timer */\n\t\tpit_load_count(kvm, channel, val);\n\t\tkvm->arch.vpit->pit_state.channels[0].mode = saved_mode;\n\t} else {\n\t\tpit_load_count(kvm, channel, val);\n\t}\n}\n\nstatic inline struct kvm_pit *dev_to_pit(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_pit, dev);\n}\n\nstatic inline struct kvm_pit *speaker_to_pit(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_pit, speaker_dev);\n}\n\nstatic inline int pit_in_range(gpa_t addr)\n{\n\treturn ((addr >= KVM_PIT_BASE_ADDRESS) &&\n\t\t(addr < KVM_PIT_BASE_ADDRESS + KVM_PIT_MEM_LENGTH));\n}\n\nstatic int pit_ioport_write(struct kvm_io_device *this,\n\t\t\t    gpa_t addr, int len, const void *data)\n{\n\tstruct kvm_pit *pit = dev_to_pit(this);\n\tstruct kvm_kpit_state *pit_state = &pit->pit_state;\n\tstruct kvm *kvm = pit->kvm;\n\tint channel, access;\n\tstruct kvm_kpit_channel_state *s;\n\tu32 val = *(u32 *) data;\n\tif (!pit_in_range(addr))\n\t\treturn -EOPNOTSUPP;\n\n\tval  &= 0xff;\n\taddr &= KVM_PIT_CHANNEL_MASK;\n\n\tmutex_lock(&pit_state->lock);\n\n\tif (val != 0)\n\t\tpr_debug(\"write addr is 0x%x, len is %d, val is 0x%x\\n\",\n\t\t\t (unsigned int)addr, len, val);\n\n\tif (addr == 3) {\n\t\tchannel = val >> 6;\n\t\tif (channel == 3) {\n\t\t\t/* Read-Back Command. */\n\t\t\tfor (channel = 0; channel < 3; channel++) {\n\t\t\t\ts = &pit_state->channels[channel];\n\t\t\t\tif (val & (2 << channel)) {\n\t\t\t\t\tif (!(val & 0x20))\n\t\t\t\t\t\tpit_latch_count(kvm, channel);\n\t\t\t\t\tif (!(val & 0x10))\n\t\t\t\t\t\tpit_latch_status(kvm, channel);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t/* Select Counter <channel>. */\n\t\t\ts = &pit_state->channels[channel];\n\t\t\taccess = (val >> 4) & KVM_PIT_CHANNEL_MASK;\n\t\t\tif (access == 0) {\n\t\t\t\tpit_latch_count(kvm, channel);\n\t\t\t} else {\n\t\t\t\ts->rw_mode = access;\n\t\t\t\ts->read_state = access;\n\t\t\t\ts->write_state = access;\n\t\t\t\ts->mode = (val >> 1) & 7;\n\t\t\t\tif (s->mode > 5)\n\t\t\t\t\ts->mode -= 4;\n\t\t\t\ts->bcd = val & 1;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* Write Count. */\n\t\ts = &pit_state->channels[addr];\n\t\tswitch (s->write_state) {\n\t\tdefault:\n\t\tcase RW_STATE_LSB:\n\t\t\tpit_load_count(kvm, addr, val);\n\t\t\tbreak;\n\t\tcase RW_STATE_MSB:\n\t\t\tpit_load_count(kvm, addr, val << 8);\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD0:\n\t\t\ts->write_latch = val;\n\t\t\ts->write_state = RW_STATE_WORD1;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD1:\n\t\t\tpit_load_count(kvm, addr, s->write_latch | (val << 8));\n\t\t\ts->write_state = RW_STATE_WORD0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&pit_state->lock);\n\treturn 0;\n}\n\nstatic int pit_ioport_read(struct kvm_io_device *this,\n\t\t\t   gpa_t addr, int len, void *data)\n{\n\tstruct kvm_pit *pit = dev_to_pit(this);\n\tstruct kvm_kpit_state *pit_state = &pit->pit_state;\n\tstruct kvm *kvm = pit->kvm;\n\tint ret, count;\n\tstruct kvm_kpit_channel_state *s;\n\tif (!pit_in_range(addr))\n\t\treturn -EOPNOTSUPP;\n\n\taddr &= KVM_PIT_CHANNEL_MASK;\n\tif (addr == 3)\n\t\treturn 0;\n\n\ts = &pit_state->channels[addr];\n\n\tmutex_lock(&pit_state->lock);\n\n\tif (s->status_latched) {\n\t\ts->status_latched = 0;\n\t\tret = s->status;\n\t} else if (s->count_latched) {\n\t\tswitch (s->count_latched) {\n\t\tdefault:\n\t\tcase RW_STATE_LSB:\n\t\t\tret = s->latched_count & 0xff;\n\t\t\ts->count_latched = 0;\n\t\t\tbreak;\n\t\tcase RW_STATE_MSB:\n\t\t\tret = s->latched_count >> 8;\n\t\t\ts->count_latched = 0;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD0:\n\t\t\tret = s->latched_count & 0xff;\n\t\t\ts->count_latched = RW_STATE_MSB;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (s->read_state) {\n\t\tdefault:\n\t\tcase RW_STATE_LSB:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = count & 0xff;\n\t\t\tbreak;\n\t\tcase RW_STATE_MSB:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = (count >> 8) & 0xff;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD0:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = count & 0xff;\n\t\t\ts->read_state = RW_STATE_WORD1;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD1:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = (count >> 8) & 0xff;\n\t\t\ts->read_state = RW_STATE_WORD0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (len > sizeof(ret))\n\t\tlen = sizeof(ret);\n\tmemcpy(data, (char *)&ret, len);\n\n\tmutex_unlock(&pit_state->lock);\n\treturn 0;\n}\n\nstatic int speaker_ioport_write(struct kvm_io_device *this,\n\t\t\t\tgpa_t addr, int len, const void *data)\n{\n\tstruct kvm_pit *pit = speaker_to_pit(this);\n\tstruct kvm_kpit_state *pit_state = &pit->pit_state;\n\tstruct kvm *kvm = pit->kvm;\n\tu32 val = *(u32 *) data;\n\tif (addr != KVM_SPEAKER_BASE_ADDRESS)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&pit_state->lock);\n\tpit_state->speaker_data_on = (val >> 1) & 1;\n\tpit_set_gate(kvm, 2, val & 1);\n\tmutex_unlock(&pit_state->lock);\n\treturn 0;\n}\n\nstatic int speaker_ioport_read(struct kvm_io_device *this,\n\t\t\t       gpa_t addr, int len, void *data)\n{\n\tstruct kvm_pit *pit = speaker_to_pit(this);\n\tstruct kvm_kpit_state *pit_state = &pit->pit_state;\n\tstruct kvm *kvm = pit->kvm;\n\tunsigned int refresh_clock;\n\tint ret;\n\tif (addr != KVM_SPEAKER_BASE_ADDRESS)\n\t\treturn -EOPNOTSUPP;\n\n\t/* Refresh clock toggles at about 15us. We approximate as 2^14ns. */\n\trefresh_clock = ((unsigned int)ktime_to_ns(ktime_get()) >> 14) & 1;\n\n\tmutex_lock(&pit_state->lock);\n\tret = ((pit_state->speaker_data_on << 1) | pit_get_gate(kvm, 2) |\n\t\t(pit_get_out(kvm, 2) << 5) | (refresh_clock << 4));\n\tif (len > sizeof(ret))\n\t\tlen = sizeof(ret);\n\tmemcpy(data, (char *)&ret, len);\n\tmutex_unlock(&pit_state->lock);\n\treturn 0;\n}\n\nvoid kvm_pit_reset(struct kvm_pit *pit)\n{\n\tint i;\n\tstruct kvm_kpit_channel_state *c;\n\n\tmutex_lock(&pit->pit_state.lock);\n\tpit->pit_state.flags = 0;\n\tfor (i = 0; i < 3; i++) {\n\t\tc = &pit->pit_state.channels[i];\n\t\tc->mode = 0xff;\n\t\tc->gate = (i != 2);\n\t\tpit_load_count(pit->kvm, i, 0);\n\t}\n\tmutex_unlock(&pit->pit_state.lock);\n\n\tatomic_set(&pit->pit_state.pending, 0);\n\tpit->pit_state.irq_ack = 1;\n}\n\nstatic void pit_mask_notifer(struct kvm_irq_mask_notifier *kimn, bool mask)\n{\n\tstruct kvm_pit *pit = container_of(kimn, struct kvm_pit, mask_notifier);\n\n\tif (!mask) {\n\t\tatomic_set(&pit->pit_state.pending, 0);\n\t\tpit->pit_state.irq_ack = 1;\n\t}\n}\n\nstatic const struct kvm_io_device_ops pit_dev_ops = {\n\t.read     = pit_ioport_read,\n\t.write    = pit_ioport_write,\n};\n\nstatic const struct kvm_io_device_ops speaker_dev_ops = {\n\t.read     = speaker_ioport_read,\n\t.write    = speaker_ioport_write,\n};\n\n/* Caller must hold slots_lock */\nstruct kvm_pit *kvm_create_pit(struct kvm *kvm, u32 flags)\n{\n\tstruct kvm_pit *pit;\n\tstruct kvm_kpit_state *pit_state;\n\tstruct pid *pid;\n\tpid_t pid_nr;\n\tint ret;\n\n\tpit = kzalloc(sizeof(struct kvm_pit), GFP_KERNEL);\n\tif (!pit)\n\t\treturn NULL;\n\n\tpit->irq_source_id = kvm_request_irq_source_id(kvm);\n\tif (pit->irq_source_id < 0) {\n\t\tkfree(pit);\n\t\treturn NULL;\n\t}\n\n\tmutex_init(&pit->pit_state.lock);\n\tmutex_lock(&pit->pit_state.lock);\n\tspin_lock_init(&pit->pit_state.inject_lock);\n\n\tpid = get_pid(task_tgid(current));\n\tpid_nr = pid_vnr(pid);\n\tput_pid(pid);\n\n\tinit_kthread_worker(&pit->worker);\n\tpit->worker_task = kthread_run(kthread_worker_fn, &pit->worker,\n\t\t\t\t       \"kvm-pit/%d\", pid_nr);\n\tif (IS_ERR(pit->worker_task)) {\n\t\tmutex_unlock(&pit->pit_state.lock);\n\t\tkvm_free_irq_source_id(kvm, pit->irq_source_id);\n\t\tkfree(pit);\n\t\treturn NULL;\n\t}\n\tinit_kthread_work(&pit->expired, pit_do_work);\n\n\tkvm->arch.vpit = pit;\n\tpit->kvm = kvm;\n\n\tpit_state = &pit->pit_state;\n\tpit_state->pit = pit;\n\thrtimer_init(&pit_state->timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\tpit_state->irq_ack_notifier.gsi = 0;\n\tpit_state->irq_ack_notifier.irq_acked = kvm_pit_ack_irq;\n\tkvm_register_irq_ack_notifier(kvm, &pit_state->irq_ack_notifier);\n\tpit_state->reinject = true;\n\tmutex_unlock(&pit->pit_state.lock);\n\n\tkvm_pit_reset(pit);\n\n\tpit->mask_notifier.func = pit_mask_notifer;\n\tkvm_register_irq_mask_notifier(kvm, 0, &pit->mask_notifier);\n\n\tkvm_iodevice_init(&pit->dev, &pit_dev_ops);\n\tret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, KVM_PIT_BASE_ADDRESS,\n\t\t\t\t      KVM_PIT_MEM_LENGTH, &pit->dev);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tif (flags & KVM_PIT_SPEAKER_DUMMY) {\n\t\tkvm_iodevice_init(&pit->speaker_dev, &speaker_dev_ops);\n\t\tret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS,\n\t\t\t\t\t      KVM_SPEAKER_BASE_ADDRESS, 4,\n\t\t\t\t\t      &pit->speaker_dev);\n\t\tif (ret < 0)\n\t\t\tgoto fail_unregister;\n\t}\n\n\treturn pit;\n\nfail_unregister:\n\tkvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS, &pit->dev);\n\nfail:\n\tkvm_unregister_irq_mask_notifier(kvm, 0, &pit->mask_notifier);\n\tkvm_unregister_irq_ack_notifier(kvm, &pit_state->irq_ack_notifier);\n\tkvm_free_irq_source_id(kvm, pit->irq_source_id);\n\tkthread_stop(pit->worker_task);\n\tkfree(pit);\n\treturn NULL;\n}\n\nvoid kvm_free_pit(struct kvm *kvm)\n{\n\tstruct hrtimer *timer;\n\n\tif (kvm->arch.vpit) {\n\t\tkvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS, &kvm->arch.vpit->dev);\n\t\tkvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS,\n\t\t\t\t\t      &kvm->arch.vpit->speaker_dev);\n\t\tkvm_unregister_irq_mask_notifier(kvm, 0,\n\t\t\t\t\t       &kvm->arch.vpit->mask_notifier);\n\t\tkvm_unregister_irq_ack_notifier(kvm,\n\t\t\t\t&kvm->arch.vpit->pit_state.irq_ack_notifier);\n\t\tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n\t\ttimer = &kvm->arch.vpit->pit_state.timer;\n\t\thrtimer_cancel(timer);\n\t\tflush_kthread_work(&kvm->arch.vpit->expired);\n\t\tkthread_stop(kvm->arch.vpit->worker_task);\n\t\tkvm_free_irq_source_id(kvm, kvm->arch.vpit->irq_source_id);\n\t\tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n\t\tkfree(kvm->arch.vpit);\n\t}\n}\n"], "filenames": ["arch/x86/kvm/i8254.c"], "buggy_code_start_loc": [264], "buggy_code_end_loc": [266], "fixing_code_start_loc": [265], "fixing_code_end_loc": [269], "type": "CWE-362", "message": "Race condition in the __kvm_migrate_pit_timer function in arch/x86/kvm/i8254.c in the KVM subsystem in the Linux kernel through 3.17.2 allows guest OS users to cause a denial of service (host OS crash) by leveraging incorrect PIT emulation.", "other": {"cve": {"id": "CVE-2014-3611", "sourceIdentifier": "secalert@redhat.com", "published": "2014-11-10T11:55:06.393", "lastModified": "2023-02-13T00:41:05.093", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Race condition in the __kvm_migrate_pit_timer function in arch/x86/kvm/i8254.c in the KVM subsystem in the Linux kernel through 3.17.2 allows guest OS users to cause a denial of service (host OS crash) by leveraging incorrect PIT emulation."}, {"lang": "es", "value": "Condici\u00f3n de carrera en la funci\u00f3n __kvm_migrate_pit_timer en arch/x86/kvm/i8254.c en el subsistema KVM en el kernel de Linux hasta 3.17.2 permite a usuarios del sistema operativo invitado causar una denegaci\u00f3n de servicio (ca\u00edda del sistema operativo anfitri\u00f3n) mediante el aprovechamiento de la emulaci\u00f3n PIT incorrecta."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 4.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.0, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.7}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.17.2", "matchCriteriaId": "D5362594-2AE6-4AFD-A1FB-FCB55482F71E"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:5.0:*:*:*:*:*:*:*", "matchCriteriaId": "1D8B549B-E57B-4DFE-8A13-CAB06B5356B3"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:10.04:*:*:*:-:*:*:*", "matchCriteriaId": "01EDA41C-6B2E-49AF-B503-EB3882265C11"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:esm:*:*:*", "matchCriteriaId": "8D305F7A-D159-4716-AB26-5E38BB5CD991"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "16F59A04-14CF-49E2-9973-645477EA09DA"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=2febc839133280d5a5e8e1179c94ea674489dae2", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2015-0126.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2015-0284.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2015-0869.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.debian.org/security/2014/dsa-3060", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2014/10/24/9", "source": "secalert@redhat.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2394-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2417-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2418-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2491-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1144878", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/2febc839133280d5a5e8e1179c94ea674489dae2", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/2febc839133280d5a5e8e1179c94ea674489dae2"}}