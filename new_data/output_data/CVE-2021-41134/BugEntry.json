{"buggy_code": ["\n\nimport * as nbformat from '@jupyterlab/nbformat';\n\nimport {\n  IRenderMimeRegistry\n} from '@jupyterlab/rendermime';\n\nimport {\n  ServerConnection\n} from '@jupyterlab/services';\n\nimport {\n  JSONObject\n} from '@lumino/coreutils';\n\nimport {\n  Message\n} from '@lumino/messaging';\n\nimport {\n  Widget, Panel\n} from '@lumino/widgets';\n\nimport {\n  IDiffEntry\n} from 'nbdime/lib/diff/diffentries';\n\nimport {\n  NotebookDiffModel\n} from 'nbdime/lib/diff/model';\n\nimport {\n  NotebookDiffWidget, CELLDIFF_CLASS\n} from 'nbdime/lib/diff/widget';\n\nimport {\n  UNCHANGED_DIFF_CLASS, CHUNK_PANEL_CLASS\n} from 'nbdime/lib/diff/widget/common';\n\nimport {\n  requestApiJson\n} from 'nbdime/lib/request';\n\n\n\n/**\n * Class of the outermost widget, the draggable tab\n */\nconst NBDIME_CLASS = 'nbdime-Widget'\n\n/**\n * Class of the root of the actual diff, the scroller element\n */\nconst ROOT_CLASS = 'nbdime-root'\n\n/**\n * DOM class for whether or not to hide unchanged cells\n */\nconst HIDE_UNCHANGED_CLASS = 'jp-mod-hideUnchanged';\n\n\nexport\nclass NbdimeWidget extends Panel {\n  /**\n   *\n   */\n  constructor(options: NbdimeWidget.IOptions) {\n    super();\n\n    this.addClass(NBDIME_CLASS);\n\n    this.base = options.base;\n    this.remote = options.remote;\n    this.rendermime = options.rendermime;\n\n    let header = Private.diffHeader(options);\n    this.addWidget(header);\n\n    this.scroller = new Panel();\n    this.scroller.addClass(ROOT_CLASS);\n    this.scroller.node.tabIndex = -1;\n    this.addWidget(this.scroller);\n\n    let hideUnchangedChk = header.node.getElementsByClassName('nbdime-hide-unchanged')[0] as HTMLInputElement;\n    hideUnchangedChk.checked = options.hideUnchanged === undefined\n      ? true : options.hideUnchanged;\n    hideUnchangedChk.onchange = () => {\n      Private.toggleShowUnchanged(this.scroller, !hideUnchangedChk.checked);\n    };\n    if (options.hideUnchanged) {\n      Private.toggleShowUnchanged(this.scroller, false);\n    }\n\n    let args: JSONObject;\n    if (this.remote) {\n      args = {base: this.base, remote: this.remote};\n    } else if (options.baseLabel === 'Checkpoint') {\n      args = {base: `checkpoint:${this.base}`}\n    } else {\n      args = {base: `git:${this.base}`}\n    }\n\n    requestApiJson(\n      ServerConnection.makeSettings().baseUrl,\n      'nbdime/api/diff',\n      args,\n      this.onData.bind(this),\n      this.onError.bind(this));\n    this.id = `nbdime-${JSON.stringify(args)}`;\n    this.title.closable = true;\n    return this;\n  }\n\n  dispose(): void {\n    super.dispose();\n    this.rendermime = null!;\n    this.header = null!;\n    this.scroller = null!;\n  }\n\n  /**\n   * Handle `'activate-request'` messages.\n   */\n  protected onActivateRequest(msg: Message): void {\n    this.scroller.node.focus();\n  }\n\n\n  protected onData(data: JSONObject) {\n    if (this.isDisposed) {\n      return;\n    }\n    let base = data['base'] as nbformat.INotebookContent;\n    let diff = data['diff'] as any as IDiffEntry[];\n    let nbdModel = new NotebookDiffModel(base, diff);\n    let nbdWidget = new NotebookDiffWidget(nbdModel, this.rendermime);\n\n    this.scroller.addWidget(nbdWidget);\n    let work = nbdWidget.init();\n    work.then(() => {\n      Private.markUnchangedRanges(this.scroller.node);\n    })\n    return work;\n  }\n\n  protected onError(error: ServerConnection.NetworkError | ServerConnection.ResponseError): void {\n    if (this.isDisposed) {\n      return;\n    }\n    let widget = new Widget();\n    widget.node.innerHTML = `Failed to fetch diff: ${error.message}`;\n    this.scroller.addWidget(widget);\n  }\n\n  readonly base: string;\n  readonly remote: string | undefined;\n\n  protected rendermime: IRenderMimeRegistry;\n\n  protected header: Widget;\n  protected scroller: Panel;\n}\n\n\nexport\nnamespace NbdimeWidget {\n\n  export\n  interface IOptions {\n    /**\n     * The base notebook path.\n     */\n    base: string,\n\n    /**\n     * The remote notebook path. If undefined, base will be diffed against git HEAD.\n     */\n    remote?: string,\n\n    /**\n     * A rendermime instance to use to render markdown/outputs.\n     */\n    rendermime: IRenderMimeRegistry,\n\n    /**\n     * If specified this will be use to represent the base file in the view.\n     *\n     * Defaults to the value of `base`.\n     *\n     * Note: The labels will be ignored for git diffs.\n     */\n    baseLabel?: string,\n\n    /**\n     * If specified this will be use to represent the remote file in the view.\n     *\n     * Defaults to the value of `remote`.\n     *\n     * Note: The labels will be ignored for git diffs.\n     */\n    remoteLabel?: string,\n\n    /**\n     * Whether to hide unchanged cells by default.\n     */\n    hideUnchanged?: boolean,\n  }\n}\n\n\nnamespace Private {\n\n  /**\n   * Create a header widget for the diff view.\n   */\n  export\n  function diffHeader(options: NbdimeWidget.IOptions): Widget {\n    let {base, remote, baseLabel, remoteLabel} = options;\n    if (remote) {\n      if (baseLabel === undefined) {\n        baseLabel = base;\n      }\n      if (remoteLabel === undefined) {\n        remoteLabel = remote;\n      }\n    } else {\n      if (!baseLabel) {\n        baseLabel = 'git HEAD';\n      }\n      remoteLabel = base;\n    }\n\n    let node = document.createElement('div');\n    node.className = 'nbdime-Diff';\n    node.innerHTML = `\n      <div class=\"nbdime-header-buttonrow\">\n        <label><input class=\"nbdime-hide-unchanged\" type=\"checkbox\">Hide unchanged cells</label>\n        <button class=\"nbdime-export\" style=\"display: none\">Export diff</button>\n      </div>\n      <div class=nbdime-header-banner>\n        <span class=\"nbdime-header-base\">${baseLabel}</span>\n        <span class=\"nbdime-header-remote\">${remoteLabel}</span>\n      </div>`;\n\n    return new Widget({node});\n  }\n\n  /**\n   * Toggle whether to show or hide unchanged cells.\n   *\n   * This simply marks with a class, real work is done by CSS.\n   */\n  export\n  function toggleShowUnchanged(root: Widget, show?: boolean) {\n    let hiding = root.hasClass(HIDE_UNCHANGED_CLASS);\n    if (show === undefined) {\n      show = hiding;\n    } else if (hiding !== show) {\n      // Nothing to do\n      return;\n    }\n    if (show) {\n      root.removeClass(HIDE_UNCHANGED_CLASS);\n    } else {\n      markUnchangedRanges(root.node);\n      root.addClass(HIDE_UNCHANGED_CLASS);\n    }\n    root.update();\n  }\n\n\n  /**\n   * Gets the chunk element of an added/removed cell, or the cell element for others\n   * @param cellElement\n   */\n  function getChunkElement(cellElement: Element): Element {\n    if (!cellElement.parentElement || !cellElement.parentElement.parentElement) {\n      return cellElement;\n    }\n    let chunkCandidate = cellElement.parentElement.parentElement;\n    if (chunkCandidate.classList.contains(CHUNK_PANEL_CLASS)) {\n      return chunkCandidate;\n    }\n    return cellElement;\n  }\n\n\n  /**\n   * Marks certain cells with\n   */\n  export\n  function markUnchangedRanges(root: HTMLElement) {\n    let children = root.querySelectorAll(`.${CELLDIFF_CLASS}`);\n    let rangeStart = -1;\n    for (let i=0; i < children.length; ++i) {\n      let child = children[i];\n      if (!child.classList.contains(UNCHANGED_DIFF_CLASS)) {\n        // Visible\n        if (rangeStart !== -1) {\n          // Previous was hidden\n          let N = i - rangeStart;\n          getChunkElement(child).setAttribute('data-nbdime-NCellsHiddenBefore', N.toString());\n          rangeStart = -1;\n        }\n      } else if (rangeStart === -1) {\n        rangeStart = i;\n      }\n    }\n    if (rangeStart !== -1) {\n      // Last element was part of a hidden range, need to mark\n      // the last cell that will be visible.\n      let N = children.length - rangeStart;\n      if (rangeStart === 0) {\n        // All elements were hidden, nothing to mark\n        // Add info on root instead\n        let tag = root.querySelector('.jp-Notebook-diff') || root;\n        tag.setAttribute('data-nbdime-AllCellsHidden', N.toString());\n        return;\n      }\n      let lastVisible = children[rangeStart - 1];\n      getChunkElement(lastVisible).setAttribute('data-nbdime-NCellsHiddenAfter', N.toString());\n    }\n  }\n}\n", "// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n'use strict';\n\nexport\ninterface DeepCopyableObject {\n  [key: string]: any | undefined;\n  prototype?: DeepCopyableObject;\n}\n\nexport\ntype DeepCopyableValue = DeepCopyableObject | DeepCopyableObject[] | string | number | boolean | null;\n\n/**\n * Check whether a value is in an array.\n */\nexport\nfunction valueIn(value: any, array: Array<any>) {\n  return array.indexOf(value) >= 0;\n}\n\n\n/**\n * Check whether array is null or empty, and type guards agains null\n */\nexport\nfunction hasEntries<T>(array: T[] | null): array is T[] {\n  return array !== null && array.length !== 0;\n}\n\n\n/**\n * Splits a multinline string into an array of lines\n *\n * @export\n * @param {string} multiline\n * @returns {string[]}\n */\nexport\nfunction splitLines(multiline: string): string[] {\n  // Split lines (retaining newlines)\n  // We use !postfix, as we also match empty string,\n  // so we are guaranteed to get at elast one match\n  return multiline.match(/^.*(\\r\\n|\\r|\\n|$)/gm)!;\n}\n\n/**\n * Deepcopy routine for JSON-able data types\n */\nexport function deepCopy(obj: null): null;\nexport function deepCopy<T extends DeepCopyableValue>(obj: T): T;\nexport function deepCopy<T extends DeepCopyableValue>(obj: T | null): T | null;\nexport function deepCopy<T extends DeepCopyableValue>(obj: T | null): T | null {\n  if (typeof obj !== 'object') {\n    if (valueIn(typeof obj, ['string', 'number', 'boolean'])) {\n      return obj;\n    }\n    throw new TypeError('Cannot deepcopy non-object');\n  }\n  if (obj === null) {\n    return null;\n  } else if (Array.isArray(obj)) {\n    let l = obj.length;\n    let o = new Array(l);\n    for (let i = 0; i < l; i++) {\n      o[i] = deepCopy(obj[i]);\n    }\n    return o as T;\n  } else {\n    let a = obj as DeepCopyableObject;\n    let r: DeepCopyableObject = {};\n    if (a.prototype !== undefined) {\n      r.prototype = a.prototype;\n    }\n    for (let k in obj) {\n      r[k] = deepCopy(a[k]);\n    }\n    return r as T;\n  }\n}\n\n/**\n * Shallow copy routine for objects\n */\nexport\nfunction shallowCopy< T extends { [key: string]: any } >(original: T): T {\n  // First create an empty object with\n  // same prototype of our original source\n  let clone = Object.create(Object.getPrototypeOf(original));\n\n  for (let k in original) {\n    // Don't copy function\n    let ok = original[k];\n    if (ok !== null && ok !== undefined &&\n        ok.hasOwnProperty('constructor') &&\n        ok.constructor === Function) {\n      continue;\n    }\n    let pDesc = Object.getOwnPropertyDescriptor(original, k);\n    // Don't copy properties with getter\n    if (!pDesc || pDesc.get) {\n      continue;\n    }\n    // copy each property into the clone\n    Object.defineProperty(clone, k, pDesc);\n  }\n  return clone;\n}\n\n/**\n * Do a shallow, element-wise equality comparison on two arrays.\n */\nexport\nfunction arraysEqual(a: any[] | null, b: any[] | null) {\n  if (a === b) {\n    return true;\n  }\n  if (a === null || b === null) {\n    return false;\n  }\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; ++i) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n\n/**\n * Find the shared common starting sequence in two arrays\n */\nexport\nfunction findSharedPrefix(a: any[] | null, b: any[] | null): any[] | null {\n  if (a === null || b === null) {\n    return null;\n  }\n  if (a === b) {  // Only checking for instance equality\n    return a.slice();\n  }\n  let i = 0;\n  for (; i < Math.min(a.length, b.length); ++i) {\n    if (a[i] !== b[i]) {\n      break;\n    }\n  }\n  return a.slice(0, i);\n}\n\n/**\n * Check whether `parent` is contained within the start of `child`\n *\n * Note on terminology: Parent is here the shortest array, as it will\n * be the parent in a tree-view of values, e.g. a path. In other words, parent\n * is a subsequence of child.\n */\nexport\nfunction isPrefixArray(parent: any[] | null, child: any[] | null): boolean {\n  if (parent === child) {\n    return true;\n  }\n  if (parent === null || parent.length === 0) {\n    return true;\n  }\n  if (child === null || parent.length > child.length) {\n    return false;\n  }\n  for (let i = 0; i < parent.length; ++i) {\n    if (parent[i] !== child[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Sort array by attribute `key` (i.e. compare by array[0][key] < array[1][key]). Stable.\n */\nexport\nfunction sortByKey<T extends {[key: string]: any}>(array: T[], key: string): T[] {\n    return stableSort(array, function(a, b) {\n        let x = a[key]; let y = b[key];\n        return ((x < y) ? -1 : ((x > y) ? 1 : 0));\n    });\n}\n\n\n/**\n * Utility function to repeat a string\n */\nexport\nfunction repeatString(str: string, count: number): string {\n  if (count < 1) {\n    return '';\n  }\n  let result = '';\n  let pattern = str.valueOf();\n  while (count > 1) {\n    if (count & 1) {\n      result += pattern;\n    }\n    count >>= 1, pattern += pattern;\n  }\n  return result + pattern;\n}\n\n/**\n * Calculate the cumulative sum of string lengths for an array of strings\n *\n * Example:\n *   For the arary ['ab', '123', 'y', '\\t\\nfoo'], the output would be\n *   [2, 5, 6, 11]\n */\nexport\nfunction accumulateLengths(arr: string[]) {\n  let ret: number[] = [];\n  arr.reduce<number>(function(a: number, b: string, i: number): number {\n    return ret[i] = a + b.length;\n  }, 0);\n  return ret;\n}\n\n/**\n * Filter for Array.filter to only have unique values\n */\nexport\nfunction unique<T>(value: T, index: number, self: T[]): boolean {\n  return self.indexOf(value) === index;\n}\n\n/**\n * Return the intersection of two arrays (with no duplicates)\n */\nexport\nfunction intersection<T>(a: T[], b: T[]): T[] {\n  let ret: T[] = [];\n  // Loop over longest, so that indexOf works on shortest\n  [a, b] = a.length > b.length ? [a, b] : [b, a];\n  for (let ia of a) {\n    if (b.indexOf(ia) !== -1) {\n      ret.push(ia);\n    }\n  }\n  return ret;\n}\n\n\n/**\n * Similar to Array.sort, but guaranteed to keep order stable\n * when compare function returns 0\n */\nexport\nfunction stableSort<T>(arr: T[], compare: (a: T, b: T) => number): T[] {\n  let sorters: {index: number, key: T}[] = [];\n  for (let i=0; i < arr.length; ++i) {\n    sorters.push({index: i, key: arr[i]});\n  }\n  sorters = sorters.sort((a: {index: number, key: T}, b: {index: number, key: T}): number => {\n    return compare(a.key, b.key) || a.index - b.index;\n  });\n  let out: T[] = new Array<T>(arr.length);\n  for (let i=0; i < arr.length; ++i) {\n    out[i] = arr[sorters[i].index];\n  }\n  return out;\n}\n\n\n/**\n * Copy an object, possibly extending it in the process\n */\nexport function copyObj<T extends {[key: string]: any}>(obj: T): T;\nexport function copyObj<T extends {[key: string]: any}, U extends {[key: string]: any}>\n(obj: T, target?: U): T & U;\nexport function copyObj(obj: {[key: string]: any}, target?: {[key: string]: any}): any {\n  if (!target) {\n    target = {};\n  }\n  for (let prop in obj) {\n    if (obj.hasOwnProperty(prop)) {\n      target[prop] = obj[prop];\n    }\n  }\n  return target;\n}\n\n\n/**\n * Create or populate a select element with string options\n */\nexport\nfunction buildSelect(options: string[], select?: HTMLSelectElement): HTMLSelectElement {\n  if (select === undefined) {\n    select = document.createElement('select');\n  }\n  for (let option of options) {\n    let opt = document.createElement('option');\n    opt.value = opt.innerHTML = option;\n    select.appendChild(opt);\n  }\n  return select;\n}\n", "// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport * as util from '../../../src/common/util';\n\ndescribe('common', () => {\n\n  describe('util', () => {\n\n    describe('arraysEqual', () => {\n\n      it('should return true for instance equality', () => {\n        let a = [1, 2, 3];\n        let value = util.arraysEqual(a, a);\n        expect(value).toBe(true);\n      });\n\n      it('should return true for shallow equality', () => {\n        let arrays = [[1, 2, 3],\n                      ['a', 'b', 'c'],\n                      [123, 'text', true]];\n        for (let a of arrays) {\n          let value = util.arraysEqual(a, a.slice());\n          expect(value).toBe(true);\n        }\n      });\n\n      it('should return true for both null', () => {\n        let value = util.arraysEqual(null, null);\n        expect(value).toBe(true);\n      });\n\n      it('should return false for one null input', () => {\n        let a = [1, 2, 3];\n        let value = util.arraysEqual(null, a);\n        expect(value).toBe(false);\n\n        value = util.arraysEqual(a, null);\n        expect(value).toBe(false);\n      });\n\n      it('should return false for different length arrays', () => {\n        let value = util.arraysEqual([1, 2, 3], [1, 2]);\n        expect(value).toBe(false);\n\n        value = util.arraysEqual([1, 2], [1, 2, 3]);\n        expect(value).toBe(false);\n      });\n\n      it('should return false for deep comparison', () => {\n        let value = util.arraysEqual([{a: 1, b: 2}], [{a: 1, b: 2}]);\n        expect(value).toBe(false);\n      });\n\n    });\n\n    describe('findSharedPrefix', () => {\n\n      it('should return a copy on identical input', () => {\n        let a = [1, 2, 3];\n        let value = util.findSharedPrefix(a, a);\n        expect(value).toEqual(a);\n        expect(value).not.toBe(a);  // Checking for instance equality\n      });\n\n      it('should return null for null inputs', () => {\n        let value = util.findSharedPrefix(null, null);\n        expect(value).toBe(null);\n\n        value = util.findSharedPrefix(null, [1, 2]);\n        expect(value).toBe(null);\n\n        value = util.findSharedPrefix([1, 2], null);\n        expect(value).toBe(null);\n      });\n\n      it('should return empty array for one or more empy inputs', () => {\n        let value = util.findSharedPrefix([], []);\n        expect(value).toEqual([]);\n\n        value = util.findSharedPrefix([], [1, 2]);\n        expect(value).toEqual([]);\n\n        value = util.findSharedPrefix([1, 2], []);\n        expect(value).toEqual([]);\n      });\n\n      it('should return empty array for disjoint inputs', () => {\n        let value = util.findSharedPrefix([1, 2, 3], ['a', 'b', 'c']);\n        expect(value).toEqual([]);\n      });\n\n      it('should return empty array for inputs that overlap after start', () => {\n        let value = util.findSharedPrefix([1, 2, 3, 4], [5, 2, 3, 4]);\n        expect(value).toEqual([]);\n      });\n\n      it('should find prefix of single element arrays', () => {\n        let value = util.findSharedPrefix([1], [1]);\n        expect(value).toEqual([1]);\n\n        value = util.findSharedPrefix(['text'], ['text']);\n        expect(value).toEqual(['text']);\n      });\n\n      it('should find prefix of muliple element arrays that are equal', () => {\n        let value = util.findSharedPrefix([1, 2, 3], [1, 2, 3]);\n        expect(value).toEqual([1, 2, 3]);\n\n        value = util.findSharedPrefix(['text', 'abc'], ['text', 'abc']);\n        expect(value).toEqual(['text', 'abc']);\n      });\n\n      it('should find prefix of muliple element arrays that are not equal', () => {\n        let value = util.findSharedPrefix([1, 2, 3, 4, 5], [1, 2, 3, 6, 7]);\n        expect(value).toEqual([1, 2, 3]);\n\n        value = util.findSharedPrefix(['text', 'abc', 'foo'], ['text', 'abc', 'bar']);\n        expect(value).toEqual(['text', 'abc']);\n      });\n\n    });\n\n    describe('isPrefixArray', () => {\n\n      it('should return true for object equality', () => {\n        let a = [1, 2, 3];\n        let value = util.isPrefixArray(a, a);\n        expect(value).toBe(true);\n      });\n\n      it('should return true for null parent', () => {\n        let a = [1, 2, 3];\n        let value = util.isPrefixArray(a, a);\n        expect(value).toBe(true);\n      });\n\n      it('should return true for null parent', () => {\n        let value = util.isPrefixArray(null, null);\n        expect(value).toBe(true);\n\n        value = util.isPrefixArray(null, [1, 2, 3]);\n        expect(value).toBe(true);\n      });\n\n      it('should return true for empty parent', () => {\n        let value = util.isPrefixArray([], null);\n        expect(value).toBe(true);\n\n        value = util.isPrefixArray([], []);\n        expect(value).toBe(true);\n\n        value = util.isPrefixArray([], [1, 2, 3]);\n        expect(value).toBe(true);\n      });\n\n      it('should return false for null child, with non null/empty parent', () => {\n        let value = util.isPrefixArray([1], null);\n        expect(value).toBe(false);\n      });\n\n      it('should return false if child is shorter than parent', () => {\n        let value = util.isPrefixArray([1], []);\n        expect(value).toBe(false);\n\n        value = util.isPrefixArray([1, 2, 3, 4], [1, 2, 3]);\n        expect(value).toBe(false);\n      });\n\n      it('should return true if child is equal to parent', () => {\n        let value = util.isPrefixArray([1], [1]);\n        expect(value).toBe(true);\n\n        value = util.isPrefixArray([1, 2, 3, 4], [1, 2, 3, 4]);\n        expect(value).toBe(true);\n\n        value = util.isPrefixArray(['abc', 'def', 0], ['abc', 'def', 0]);\n        expect(value).toBe(true);\n      });\n\n      it('should return true if entire parent matches start of child', () => {\n        let value = util.isPrefixArray([1], [1, 2]);\n        expect(value).toBe(true);\n\n        value = util.isPrefixArray([1, 2, 3], [1, 2, 3, 4]);\n        expect(value).toBe(true);\n\n        value = util.isPrefixArray(['abc', 'def'], ['abc', 'def', 0]);\n        expect(value).toBe(true);\n      });\n\n      it('should return false if entire parent matches non-start of child', () => {\n        let value = util.isPrefixArray([2], [1, 2]);\n        expect(value).toBe(false);\n\n        value = util.isPrefixArray([2, 3, 4], [1, 2, 3, 4]);\n        expect(value).toBe(false);\n\n        value = util.isPrefixArray(['def'], ['abc', 'def', 0]);\n        expect(value).toBe(false);\n      });\n\n    });\n\n    describe('accumulateLengths', () => {\n\n      it('should handle an empty array', () => {\n        let value = util.accumulateLengths([]);\n        expect(value).toEqual([]);\n      });\n\n      it('should handle an single item array', () => {\n        let value = util.accumulateLengths(['abc']);\n        expect(value).toEqual([3]);\n      });\n\n      it('should handle multiple strings', () => {\n        let value = util.accumulateLengths(['abc', 'foo', '0xdead']);\n        expect(value).toEqual([3, 6, 12]);\n      });\n\n      it('should handle multiple strings with newlines at end', () => {\n        let value = util.accumulateLengths(['abc\\n', 'foo\\n', '0xdead\\n']);\n        expect(value).toEqual([4, 8, 15]);\n      });\n\n      it('should handle multiple strings with newlines randomly placed', () => {\n        let value = util.accumulateLengths(['\\nabc', 'foo\\n', '0xde\\nad']);\n        expect(value).toEqual([4, 8, 15]);\n      });\n\n    });\n\n    describe('hasEntries', () => {\n\n      it('should return false for null', () => {\n        let value = util.hasEntries(null);\n        expect(value).toBe(false);\n      });\n\n      it('should return false for empty array', () => {\n        let value = util.hasEntries([]);\n        expect(value).toBe(false);\n      });\n\n      it('should return true for array with falsy entry', () => {\n        let value = util.hasEntries([0]);\n        expect(value).toBe(true);\n      });\n\n      it('should return true for array with truthy entry', () => {\n        let value = util.hasEntries([4]);\n        expect(value).toBe(true);\n      });\n\n    });\n\n  });\n\n});\n", "// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n'use strict';\n\n\nimport * as nbformat from '@jupyterlab/nbformat';\n\nimport {\n  Panel, Widget\n} from '@lumino/widgets';\n\nimport {\n  RenderMimeRegistry\n} from '@jupyterlab/rendermime';\n\nimport {\n  defaultSanitizer\n} from '@jupyterlab/apputils';\n\nimport {\n  PageConfig\n} from '@jupyterlab/coreutils';\n\nimport {\n  MathJaxTypesetter\n} from '@jupyterlab/mathjax2';\n\nimport {\n  IDiffEntry\n} from 'nbdime/lib/diff/diffentries';\n\nimport {\n  NotebookDiffModel\n} from 'nbdime/lib/diff/model';\n\nimport {\n  NotebookDiffWidget\n} from 'nbdime/lib/diff/widget';\n\nimport {\n  requestDiff\n} from 'nbdime/lib/request';\n\nimport {\n  getBaseUrl, getConfigOption, toggleSpinner, toggleShowUnchanged,\n  markUnchangedRanges\n} from './common';\n\nimport {\n  exportDiff\n} from './staticdiff';\n\nimport {\n  rendererFactories\n} from './rendermime';\n\nlet diffWidget: NotebookDiffWidget | null = null;\n\nconst prefixes = ['git:', 'checkpoint:'];\n\nfunction hasPrefix(candidate: string): boolean {\n  for (let p of prefixes) {\n    if (candidate.slice(0, p.length) === p) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction stripPrefix(s: string): string {\n  for (let p of prefixes) {\n    if (s.slice(0, p.length) === p) {\n      return s.slice(p.length);\n    }\n  }\n  return s;\n}\n\n\n/**\n * Show the diff as represented by the base notebook and a list of diff entries\n */\nfunction showDiff(data: {base: nbformat.INotebookContent, diff: IDiffEntry[]}): Promise<void> {\n\n\n  let rendermime = new RenderMimeRegistry({\n    initialFactories: rendererFactories,\n    sanitizer: defaultSanitizer,\n    latexTypesetter: new MathJaxTypesetter({\n      url: getConfigOption('mathjaxUrl'),\n      config: getConfigOption('mathjaxConfig'),\n    }),\n  });\n\n  let nbdModel = new NotebookDiffModel(data.base, data.diff);\n  let nbdWidget = new NotebookDiffWidget(nbdModel, rendermime);\n\n  let root = document.getElementById('nbdime-root');\n  if (!root) {\n    throw new Error('Missing root element \"nbidme-root\"');\n  }\n  root.innerHTML = '';\n  // Hide unchanged cells by default:\n  toggleShowUnchanged(!getConfigOption('hideUnchanged', true));\n\n  let panel = new Panel();\n  panel.id = 'main';\n  Widget.attach(panel, root);\n  panel.addWidget(nbdWidget);\n  let work = nbdWidget.init();\n  work.then(() => {\n    window.onresize = () => { panel.update(); };\n  });\n  diffWidget = nbdWidget;\n  return work;\n}\n\n/**\n * Diff form submission callback. Sends a request for a diff to the server based\n * on the content of the form.\n */\nfunction onDiff(e: Event) {\n  e.preventDefault();\n  let b = (document.getElementById('diff-base') as HTMLInputElement).value;\n  let r = (document.getElementById('diff-remote') as HTMLInputElement).value;\n  compare(b, r, true);\n  return false;\n};\n\n\nfunction compare(base: string, remote: string | undefined, pushHistory: boolean | 'replace') {\n  toggleSpinner(true);\n  getDiff(base, remote);\n  if (pushHistory) {\n    let uri = window.location.pathname;\n    base = stripPrefix(base);\n    uri = '?base=' + encodeURIComponent(base);\n    if (remote) {\n      uri += '&remote=' + encodeURIComponent(remote);\n    }\n    editHistory(pushHistory, {base, remote},\n      'Diff: \"' + base + '\" vs \"' + remote + '\"', uri);\n  }\n}\n\nfunction editHistory(pushHistory: boolean | 'replace', statedata: any, title: string, url?: string): void {\n  if (pushHistory === true) {\n    history.pushState(statedata, title, url);\n  } else if (pushHistory === 'replace') {\n    history.replaceState(statedata, title, url);\n  }\n}\n\n\n/**\n * Calls `requestDiff` with our response handlers\n */\nexport\nfunction getDiff(base: string, remote: string | undefined) {\n  let baseUrl = getBaseUrl();\n  requestDiff(base, remote, baseUrl, onDiffRequestCompleted, onDiffRequestFailed);\n}\n\n/**\n * Callback for a successfull diff request\n */\nfunction onDiffRequestCompleted(data: any) {\n  let layoutWork = showDiff(data);\n\n  layoutWork.then(() => {\n    let exportBtn = document.getElementById('nbdime-export') as HTMLButtonElement;\n    exportBtn.style.display = 'initial';\n    toggleSpinner(false);\n    markUnchangedRanges();\n  });\n}\n\n/**\n * Callback for a failed diff request\n */\nfunction onDiffRequestFailed(response: string) {\n  console.log('Diff request failed.');\n  let root = document.getElementById('nbdime-root');\n  if (!root) {\n    throw new Error('Missing root element \"nbidme-root\"');\n  }\n  root.innerHTML = '<pre>' + response + '</pre>';\n  diffWidget = null;\n  toggleSpinner(false);\n}\n\n\n/**\n * Called when a 'back' is requested\n */\nfunction onPopState(e: PopStateEvent) {\n  if (e.state) {\n    let eb = (document.getElementById('diff-base') as HTMLInputElement);\n    let er = (document.getElementById('diff-remote') as HTMLInputElement);\n    eb.value = e.state.base;\n    er.value = e.state.remote;\n    compare(e.state.base, e.state.remote, false);\n  }\n}\n\n/**\n * Trust all outputs in diff\n */\nfunction trustOutputs() {\n  let trust = true;\n  if (!diffWidget) {\n    return;\n  }\n  let model = diffWidget.model;\n  for (let cell of model.cells) {\n    if (!cell.outputs) {\n      continue;\n    }\n    for (let output of cell.outputs) {\n      output.trusted = trust;\n    }\n  }\n}\n\n\n/**\n * Wire up callbacks.\n */\nfunction attachToForm() {\n  let frm = document.getElementById('nbdime-diff-form') as HTMLFormElement;\n  if (frm) {\n    frm.onsubmit = onDiff;\n    // It only makes sense to listen to pop state events when the form is\n    // availalbe (i.e. when we are not a diff/mergetool):\n    window.onpopstate = onPopState;\n  }\n}\n\n\n/**\n *\n */\nexport\nfunction initializeDiff() {\n  attachToForm();\n  // If arguments supplied in config, run diff directly:\n  let base = getConfigOption('base');\n  let remote = getConfigOption('remote');\n  if (base && (remote || hasPrefix(base))) {\n    compare(base, remote, 'replace');\n  }\n\n  let exportBtn = document.getElementById('nbdime-export') as HTMLButtonElement;\n  exportBtn.onclick = exportDiff;\n\n  let hideUnchangedChk = document.getElementById('nbdime-hide-unchanged') as HTMLInputElement;\n  hideUnchangedChk.checked = getConfigOption('hideUnchanged', true);\n  hideUnchangedChk.onchange = () => {\n    toggleShowUnchanged(!hideUnchangedChk.checked, diffWidget);\n  };\n\n  let trustBtn = document.getElementById('nbdime-trust') as HTMLButtonElement;\n  trustBtn.onclick = trustOutputs;\n  trustBtn.style.display = 'initial';\n}\n", "// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n'use strict';\n\n\nimport * as alertify from 'alertify.js';\n\nimport * as nbformat from '@jupyterlab/nbformat';\n\nimport {\n  JSONExt, JSONObject\n} from '@lumino/coreutils';\n\nimport {\n  Panel, Widget\n} from '@lumino/widgets';\n\nimport {\n  RenderMimeRegistry\n} from '@jupyterlab/rendermime';\n\nimport {\n  defaultSanitizer\n} from '@jupyterlab/apputils';\n\nimport {\n  NotebookMergeModel\n} from 'nbdime/lib/merge/model';\n\nimport {\n  IMergeDecision\n} from 'nbdime/lib/merge/decisions';\n\nimport {\n  NotebookMergeWidget\n} from 'nbdime/lib/merge/widget';\n\nimport {\n  stringify\n} from 'nbdime/lib/patch';\n\nimport {\n  requestMerge, requestApi\n} from 'nbdime/lib/request';\n\nimport {\n  getBaseUrl, getConfigOption, closeTool, toggleSpinner,\n  toggleShowUnchanged, markUnchangedRanges\n} from './common';\n\nimport {\n  rendererFactories\n} from './rendermime';\n\nimport {\n  extractMergedNotebook\n} from './save';\n\n\nlet mergeWidget: NotebookMergeWidget | null = null;\n\n/**\n * Show the merge as represented by the base notebook and a\n * list of merge decisions\n */\nfunction showMerge(data: {\n    base: nbformat.INotebookContent,\n    merge_decisions: IMergeDecision[]\n    }): Promise<void> {\n\n  let rendermime = new RenderMimeRegistry({\n    initialFactories: rendererFactories,\n    sanitizer: defaultSanitizer,\n  });\n\n  let nbmModel = new NotebookMergeModel(data.base,\n      data.merge_decisions);\n  let nbmWidget = new NotebookMergeWidget(nbmModel, rendermime);\n\n  let root = document.getElementById('nbdime-root');\n  if (!root) {\n    throw new Error('Missing root element \"nbidme-root\"');\n  }\n  root.innerHTML = '';\n  // Hide unchanged cells by default:\n  toggleShowUnchanged(!getConfigOption('hideUnchanged', true));\n\n  let panel = new Panel();\n  panel.id = 'main';\n  Widget.attach(panel, root);\n  panel.addWidget(nbmWidget);\n  let work = nbmWidget.init();\n  work.then(() => {\n    window.onresize = () => { panel.update(); };\n  });\n  mergeWidget = nbmWidget;\n  return work;\n}\n\n/**\n * Calls `requestMerge` with our response handlers\n */\nexport\nfunction getMerge(base: string, local: string, remote: string) {\n  let baseUrl = getBaseUrl();\n  requestMerge(base, local, remote, baseUrl, onMergeRequestCompleted, onMergeRequestFailed);\n}\n\n/**\n * Merge form submission callback. Sends a request for a merge to the server\n * based on the content of the form.\n *\n * Also pushes state to history for navigation history wo/reload\n */\nfunction onMerge(e: Event) {\n  e.preventDefault();\n  let b = (document.getElementById('merge-base') as HTMLInputElement).value;\n  let c = (document.getElementById('merge-local') as HTMLInputElement).value;\n  let r = (document.getElementById('merge-remote') as HTMLInputElement).value;\n  compare(b, c, r, true);\n  return false;\n};\n\nfunction compare(b: string, c: string, r: string, pushHistory: boolean | 'replace') {\n  // All values present, do merge\n  toggleSpinner(true);\n  getMerge(b, c, r);\n  if (pushHistory) {\n    let uri = window.location.pathname;\n    uri += '?base=' + encodeURIComponent(b) +\n      '&local=' + encodeURIComponent(c) +\n      '&remote=' + encodeURIComponent(r);\n    editHistory(pushHistory, {base: b, local: c, remote: r},\n      'Merge: \"' + c + '\" - \"' + b + '\" - \"' + r + '\"', uri);\n  }\n}\n\nfunction editHistory(pushHistory: boolean | 'replace', statedata: any, title: string, url?: string): void {\n  if (pushHistory === true) {\n    history.pushState(statedata, title, url);\n  } else if (pushHistory === 'replace') {\n    history.replaceState(statedata, title, url);\n  }\n}\n\n/**\n * Called when a 'back' is requested\n */\nfunction onPopState(e: PopStateEvent) {\n  if (e.state) {\n    let eb = (document.getElementById('merge-base') as HTMLInputElement);\n    let el = (document.getElementById('merge-local') as HTMLInputElement);\n    let er = (document.getElementById('merge-remote') as HTMLInputElement);\n\n    eb.value = e.state.base;\n    el.value = e.state.local;\n    er.value = e.state.remote;\n    compare(e.state.base, e.state.local, e.state.remote, false);\n  }\n}\n\n/**\n * Callback for a successfull merge request\n */\nfunction onMergeRequestCompleted(data: any) {\n  let layoutWork = showMerge(data);\n  layoutWork.then(() => {\n    toggleSpinner(false);\n    markUnchangedRanges();\n  });\n}\n\n/**\n * Callback for a failed merge request\n */\nfunction onMergeRequestFailed(response: string) {\n  console.log('Merge request failed.');\n  let root = document.getElementById('nbdime-root');\n  if (!root) {\n    throw new Error('Missing root element \"nbidme-root\"');\n  }\n  root.innerHTML = '<pre>' + response + '</pre>';\n  mergeWidget = null;\n  toggleSpinner(false);\n}\n\n\n/**\n * Extract the merged notebook from the model, as well as any remaining\n * conflicts, and send them to the server for storage / further processing.\n */\nexport\nfunction saveMerged() {\n  if (!mergeWidget) {\n    return;\n  }\n  let nb = extractMergedNotebook(mergeWidget);\n  let conflicts: IMergeDecision[] = [];\n  for (let md of mergeWidget.model.conflicts) {\n    conflicts.push(md.serialize());\n  }\n  submitMerge(nb, conflicts);\n}\n\n\nfunction downloadNotebook(notebook: nbformat.INotebookContent, filename: string) {\n  let element = document.createElement('a');\n  const nbCopy = JSONExt.deepCopy(notebook) as JSONObject;\n  element.setAttribute(\n    'href', 'data:text/plain;charset=utf-8,' +\n    encodeURIComponent(stringify(nbCopy)));\n  element.setAttribute('download', filename);\n\n  element.style.display = 'none';\n  document.body.appendChild(element);\n  try {\n    element.click();\n  } finally {\n    document.body.removeChild(element);\n  }\n}\n\n\nfunction getMergeFilename() {\n  // If present use 'outputfilename'\n  let filename = getConfigOption('outputfilename');\n  // Otherwise use base name as suggestion\n  if (!filename) {\n    filename = getConfigOption('base');\n  }\n  // Fallback:\n  if (!filename) {\n    filename = 'merged.ipynb';\n  }\n  return filename;\n}\n\n/**\n *\n */\nexport\nfunction downloadMerged() {\n  if (!mergeWidget) {\n    return;\n  }\n  function download() {\n    let filename = getMergeFilename();\n    let nb = extractMergedNotebook(mergeWidget!);\n    downloadNotebook(nb, filename);\n  }\n  let conflicted = mergeWidget.model.conflicts.length > 0;\n  if (conflicted) {\n    alertify.confirm('There are conflicts remaining. ' +\n      'Do you still want to download the merge output?', () => {\n        download();\n      });\n  } else {\n    download();\n  }\n}\n\n/**\n * Submit a merged notebook\n */\nfunction submitMerge(mergedNotebook: nbformat.INotebookContent,\n                     conflicts: IMergeDecision[]) {\n  requestApi(\n    getBaseUrl(),\n    '/api/store',\n    {\n      merged: mergedNotebook,\n      conflicts: conflicts\n    },\n    onSubmissionCompleted,\n    onSubmissionFailed);\n}\n\n/**\n * Callback for a successful store of the submitted merged notebook\n */\nfunction onSubmissionCompleted() {\n  alertify.success('Merged notebook saved successfully');\n  mergeWidget!.model.unsavedChanges = false;\n}\n\n/**\n * Callback for a failed store of the submitted merged notebook\n */\nfunction onSubmissionFailed(response: string) {\n  alertify.error('Was not able to save the notebook! See console and/or server log for details.');\n}\n\n\n/**\n * Called when the merge tool is closing, but it can be prevented.\n */\nexport\nfunction closeMerge(ev: Event, unloading=false): string | void | null {\n  if (!mergeWidget) {\n    return closeTool(1);\n  }\n  let savable = getConfigOption('savable');\n  for (let md of mergeWidget.model.conflicts) {\n    if (md.conflict) {\n      if (mergeWidget.model.unsavedChanges && savable) {\n        let prompt = 'There are remaining conflicts, and you have unsaved changes. Do you want to close anyway?';\n        if (unloading) {\n          ev.returnValue = true;\n          return prompt;\n        }\n        alertify.confirm(prompt,\n          () => {\n            window.onbeforeunload = null!;\n            closeTool(1);\n          },\n          () => {\n            ev.preventDefault();\n          });\n        return null;\n      } else {\n        let prompt = 'There are remaining conflicts. Do you want to close anyway?';\n        if (unloading) {\n          ev.returnValue = true;\n          return prompt;\n        }\n        alertify.confirm(prompt,\n          () => {\n            window.onbeforeunload = null!;\n            closeTool(1);\n          },\n          () => {\n            ev.preventDefault();\n          });\n        return null;\n      }\n    }\n  }\n  if (mergeWidget.model.unsavedChanges && savable) {\n    let prompt = 'There are unsaved changes. Do you want to close anyway?';\n    if (unloading) {\n      ev.returnValue = true;\n      return prompt;\n    }\n    alertify.confirm(prompt,\n      () => {\n        window.onbeforeunload = null!;\n        closeTool(0);\n      },\n      () => {\n        ev.preventDefault();\n      });\n    return null;\n  }\n  closeTool(0);\n  return null;\n}\n\n\n/**\n * Called when merge tool is closing, and it shouldn't be prevented.\n *\n * Will only try to set the correct exit code for the tool.\n */\nexport\nfunction forceCloseMerge(): void {\n  if (!mergeWidget) {\n    return closeTool(1);\n  }\n  for (let md of mergeWidget.model.conflicts) {\n    if (md.conflict) {\n      closeTool(1);\n    }\n  }\n  closeTool(0);\n}\n\n\n/**\n * Wire up callbacks.\n */\nfunction attachToForm() {\n  let frm = document.getElementById('nbdime-merge-form') as HTMLFormElement;\n  if (frm) {\n    frm.onsubmit = onMerge;\n    // It only makes sense to listen to pop state events when the form is\n    // availalbe (i.e. when we are not a diff/mergetool):\n    window.onpopstate = onPopState;\n  }\n}\n\n/** */\nexport\nfunction initializeMerge() {\n  attachToForm();\n  // If arguments supplied in config, run merge directly:\n  let base = getConfigOption('base');\n  let local = getConfigOption('local');  // Only available for merge\n  let remote = getConfigOption('remote');\n  if (base && local && remote) {\n    compare(base, local, remote, 'replace');\n  }\n\n  let savable = getConfigOption('savable');\n  let saveBtn = document.getElementById('nbdime-save') as HTMLButtonElement;\n  if (savable) {\n    saveBtn.onclick = saveMerged;\n    saveBtn.style.display = 'initial';\n  }\n  let downloadBtn = document.getElementById('nbdime-download') as HTMLButtonElement;\n  downloadBtn.onclick = downloadMerged;\n  downloadBtn.style.display = 'initial';\n\n  let hideUnchangedChk = document.getElementById('nbdime-hide-unchanged') as HTMLInputElement;\n  hideUnchangedChk.checked = getConfigOption('hideUnchanged', true);\n  hideUnchangedChk.onchange = () => {\n    toggleShowUnchanged(!hideUnchangedChk.checked, mergeWidget);\n  };\n}\n"], "fixing_code": ["\n\nimport * as nbformat from '@jupyterlab/nbformat';\n\nimport {\n  IRenderMimeRegistry\n} from '@jupyterlab/rendermime';\n\nimport {\n  ServerConnection\n} from '@jupyterlab/services';\n\nimport {\n  JSONObject\n} from '@lumino/coreutils';\n\nimport {\n  Message\n} from '@lumino/messaging';\n\nimport {\n  Widget, Panel\n} from '@lumino/widgets';\n\nimport {\n  IDiffEntry\n} from 'nbdime/lib/diff/diffentries';\n\nimport {\n  NotebookDiffModel\n} from 'nbdime/lib/diff/model';\n\nimport {\n  NotebookDiffWidget, CELLDIFF_CLASS\n} from 'nbdime/lib/diff/widget';\n\nimport {\n  UNCHANGED_DIFF_CLASS, CHUNK_PANEL_CLASS\n} from 'nbdime/lib/diff/widget/common';\n\nimport {\n  requestApiJson\n} from 'nbdime/lib/request';\n\n\n\n/**\n * Class of the outermost widget, the draggable tab\n */\nconst NBDIME_CLASS = 'nbdime-Widget'\n\n/**\n * Class of the root of the actual diff, the scroller element\n */\nconst ROOT_CLASS = 'nbdime-root'\n\n/**\n * DOM class for whether or not to hide unchanged cells\n */\nconst HIDE_UNCHANGED_CLASS = 'jp-mod-hideUnchanged';\n\n\nexport\nclass NbdimeWidget extends Panel {\n  /**\n   *\n   */\n  constructor(options: NbdimeWidget.IOptions) {\n    super();\n\n    this.addClass(NBDIME_CLASS);\n\n    this.base = options.base;\n    this.remote = options.remote;\n    this.rendermime = options.rendermime;\n\n    let header = Private.diffHeader(options);\n    this.addWidget(header);\n\n    this.scroller = new Panel();\n    this.scroller.addClass(ROOT_CLASS);\n    this.scroller.node.tabIndex = -1;\n    this.addWidget(this.scroller);\n\n    let hideUnchangedChk = header.node.getElementsByClassName('nbdime-hide-unchanged')[0] as HTMLInputElement;\n    hideUnchangedChk.checked = options.hideUnchanged === undefined\n      ? true : options.hideUnchanged;\n    hideUnchangedChk.onchange = () => {\n      Private.toggleShowUnchanged(this.scroller, !hideUnchangedChk.checked);\n    };\n    if (options.hideUnchanged) {\n      Private.toggleShowUnchanged(this.scroller, false);\n    }\n\n    let args: JSONObject;\n    if (this.remote) {\n      args = {base: this.base, remote: this.remote};\n    } else if (options.baseLabel === 'Checkpoint') {\n      args = {base: `checkpoint:${this.base}`}\n    } else {\n      args = {base: `git:${this.base}`}\n    }\n\n    requestApiJson(\n      ServerConnection.makeSettings().baseUrl,\n      'nbdime/api/diff',\n      args,\n      this.onData.bind(this),\n      this.onError.bind(this));\n    this.id = `nbdime-${JSON.stringify(args)}`;\n    this.title.closable = true;\n    return this;\n  }\n\n  dispose(): void {\n    super.dispose();\n    this.rendermime = null!;\n    this.header = null!;\n    this.scroller = null!;\n  }\n\n  /**\n   * Handle `'activate-request'` messages.\n   */\n  protected onActivateRequest(msg: Message): void {\n    this.scroller.node.focus();\n  }\n\n\n  protected onData(data: JSONObject) {\n    if (this.isDisposed) {\n      return;\n    }\n    let base = data['base'] as nbformat.INotebookContent;\n    let diff = data['diff'] as any as IDiffEntry[];\n    let nbdModel = new NotebookDiffModel(base, diff);\n    let nbdWidget = new NotebookDiffWidget(nbdModel, this.rendermime);\n\n    this.scroller.addWidget(nbdWidget);\n    let work = nbdWidget.init();\n    work.then(() => {\n      Private.markUnchangedRanges(this.scroller.node);\n    })\n    return work;\n  }\n\n  protected onError(error: ServerConnection.NetworkError | ServerConnection.ResponseError): void {\n    if (this.isDisposed) {\n      return;\n    }\n    let widget = new Widget();\n    widget.node.innerHTML = `Failed to fetch diff: ${error.message}`;\n    this.scroller.addWidget(widget);\n  }\n\n  readonly base: string;\n  readonly remote: string | undefined;\n\n  protected rendermime: IRenderMimeRegistry;\n\n  protected header: Widget;\n  protected scroller: Panel;\n}\n\n\nexport\nnamespace NbdimeWidget {\n\n  export\n  interface IOptions {\n    /**\n     * The base notebook path.\n     */\n    base: string,\n\n    /**\n     * The remote notebook path. If undefined, base will be diffed against git HEAD.\n     */\n    remote?: string,\n\n    /**\n     * A rendermime instance to use to render markdown/outputs.\n     */\n    rendermime: IRenderMimeRegistry,\n\n    /**\n     * If specified this will be use to represent the base file in the view.\n     *\n     * Defaults to the value of `base`.\n     *\n     * Note: The labels will be ignored for git diffs.\n     */\n    baseLabel?: string,\n\n    /**\n     * If specified this will be use to represent the remote file in the view.\n     *\n     * Defaults to the value of `remote`.\n     *\n     * Note: The labels will be ignored for git diffs.\n     */\n    remoteLabel?: string,\n\n    /**\n     * Whether to hide unchanged cells by default.\n     */\n    hideUnchanged?: boolean,\n  }\n}\n\n\nnamespace Private {\n\n  /**\n   * Create a header widget for the diff view.\n   */\n  export\n  function diffHeader(options: NbdimeWidget.IOptions): Widget {\n    let {base, remote, baseLabel, remoteLabel} = options;\n    if (remote) {\n      if (baseLabel === undefined) {\n        baseLabel = base;\n      }\n      if (remoteLabel === undefined) {\n        remoteLabel = remote;\n      }\n    } else {\n      if (!baseLabel) {\n        baseLabel = 'git HEAD';\n      }\n      remoteLabel = base;\n    }\n\n    let node = document.createElement('div');\n    node.className = 'nbdime-Diff';\n    node.innerHTML = `\n      <div class=\"nbdime-header-buttonrow\">\n        <label><input class=\"nbdime-hide-unchanged\" type=\"checkbox\">Hide unchanged cells</label>\n        <button class=\"nbdime-export\" style=\"display: none\">Export diff</button>\n      </div>\n      <div class=nbdime-header-banner>\n        <span class=\"nbdime-header-base\"></span>\n        <span class=\"nbdime-header-remote\"></span>\n      </div>`;\n    (node.getElementsByClassName(\"nbdime-header-base\")[0] as HTMLSpanElement).innerText = baseLabel;\n    (node.getElementsByClassName(\"nbdime-header-remote\")[0] as HTMLSpanElement).innerText = remoteLabel;\n\n    return new Widget({node});\n  }\n\n  /**\n   * Toggle whether to show or hide unchanged cells.\n   *\n   * This simply marks with a class, real work is done by CSS.\n   */\n  export\n  function toggleShowUnchanged(root: Widget, show?: boolean) {\n    let hiding = root.hasClass(HIDE_UNCHANGED_CLASS);\n    if (show === undefined) {\n      show = hiding;\n    } else if (hiding !== show) {\n      // Nothing to do\n      return;\n    }\n    if (show) {\n      root.removeClass(HIDE_UNCHANGED_CLASS);\n    } else {\n      markUnchangedRanges(root.node);\n      root.addClass(HIDE_UNCHANGED_CLASS);\n    }\n    root.update();\n  }\n\n\n  /**\n   * Gets the chunk element of an added/removed cell, or the cell element for others\n   * @param cellElement\n   */\n  function getChunkElement(cellElement: Element): Element {\n    if (!cellElement.parentElement || !cellElement.parentElement.parentElement) {\n      return cellElement;\n    }\n    let chunkCandidate = cellElement.parentElement.parentElement;\n    if (chunkCandidate.classList.contains(CHUNK_PANEL_CLASS)) {\n      return chunkCandidate;\n    }\n    return cellElement;\n  }\n\n\n  /**\n   * Marks certain cells with\n   */\n  export\n  function markUnchangedRanges(root: HTMLElement) {\n    let children = root.querySelectorAll(`.${CELLDIFF_CLASS}`);\n    let rangeStart = -1;\n    for (let i=0; i < children.length; ++i) {\n      let child = children[i];\n      if (!child.classList.contains(UNCHANGED_DIFF_CLASS)) {\n        // Visible\n        if (rangeStart !== -1) {\n          // Previous was hidden\n          let N = i - rangeStart;\n          getChunkElement(child).setAttribute('data-nbdime-NCellsHiddenBefore', N.toString());\n          rangeStart = -1;\n        }\n      } else if (rangeStart === -1) {\n        rangeStart = i;\n      }\n    }\n    if (rangeStart !== -1) {\n      // Last element was part of a hidden range, need to mark\n      // the last cell that will be visible.\n      let N = children.length - rangeStart;\n      if (rangeStart === 0) {\n        // All elements were hidden, nothing to mark\n        // Add info on root instead\n        let tag = root.querySelector('.jp-Notebook-diff') || root;\n        tag.setAttribute('data-nbdime-AllCellsHidden', N.toString());\n        return;\n      }\n      let lastVisible = children[rangeStart - 1];\n      getChunkElement(lastVisible).setAttribute('data-nbdime-NCellsHiddenAfter', N.toString());\n    }\n  }\n}\n", "// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n'use strict';\n\nexport\ninterface DeepCopyableObject {\n  [key: string]: any | undefined;\n  prototype?: DeepCopyableObject;\n}\n\nexport\ntype DeepCopyableValue = DeepCopyableObject | DeepCopyableObject[] | string | number | boolean | null;\n\n/**\n * Check whether a value is in an array.\n */\nexport\nfunction valueIn(value: any, array: Array<any>) {\n  return array.indexOf(value) >= 0;\n}\n\n\n/**\n * Check whether array is null or empty, and type guards agains null\n */\nexport\nfunction hasEntries<T>(array: T[] | null): array is T[] {\n  return array !== null && array.length !== 0;\n}\n\n\n/**\n * Splits a multinline string into an array of lines\n *\n * @export\n * @param {string} multiline\n * @returns {string[]}\n */\nexport\nfunction splitLines(multiline: string): string[] {\n  // Split lines (retaining newlines)\n  // We use !postfix, as we also match empty string,\n  // so we are guaranteed to get at elast one match\n  return multiline.match(/^.*(\\r\\n|\\r|\\n|$)/gm)!;\n}\n\n/**\n * Deepcopy routine for JSON-able data types\n */\nexport function deepCopy(obj: null): null;\nexport function deepCopy<T extends DeepCopyableValue>(obj: T): T;\nexport function deepCopy<T extends DeepCopyableValue>(obj: T | null): T | null;\nexport function deepCopy<T extends DeepCopyableValue>(obj: T | null): T | null {\n  if (typeof obj !== 'object') {\n    if (valueIn(typeof obj, ['string', 'number', 'boolean'])) {\n      return obj;\n    }\n    throw new TypeError('Cannot deepcopy non-object');\n  }\n  if (obj === null) {\n    return null;\n  } else if (Array.isArray(obj)) {\n    let l = obj.length;\n    let o = new Array(l);\n    for (let i = 0; i < l; i++) {\n      o[i] = deepCopy(obj[i]);\n    }\n    return o as T;\n  } else {\n    let a = obj as DeepCopyableObject;\n    let r: DeepCopyableObject = {};\n    if (a.prototype !== undefined) {\n      r.prototype = a.prototype;\n    }\n    for (let k in obj) {\n      r[k] = deepCopy(a[k]);\n    }\n    return r as T;\n  }\n}\n\n/**\n * Shallow copy routine for objects\n */\nexport\nfunction shallowCopy< T extends { [key: string]: any } >(original: T): T {\n  // First create an empty object with\n  // same prototype of our original source\n  let clone = Object.create(Object.getPrototypeOf(original));\n\n  for (let k in original) {\n    // Don't copy function\n    let ok = original[k];\n    if (ok !== null && ok !== undefined &&\n        ok.hasOwnProperty('constructor') &&\n        ok.constructor === Function) {\n      continue;\n    }\n    let pDesc = Object.getOwnPropertyDescriptor(original, k);\n    // Don't copy properties with getter\n    if (!pDesc || pDesc.get) {\n      continue;\n    }\n    // copy each property into the clone\n    Object.defineProperty(clone, k, pDesc);\n  }\n  return clone;\n}\n\n/**\n * Do a shallow, element-wise equality comparison on two arrays.\n */\nexport\nfunction arraysEqual(a: any[] | null, b: any[] | null) {\n  if (a === b) {\n    return true;\n  }\n  if (a === null || b === null) {\n    return false;\n  }\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; ++i) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n\n/**\n * Find the shared common starting sequence in two arrays\n */\nexport\nfunction findSharedPrefix(a: any[] | null, b: any[] | null): any[] | null {\n  if (a === null || b === null) {\n    return null;\n  }\n  if (a === b) {  // Only checking for instance equality\n    return a.slice();\n  }\n  let i = 0;\n  for (; i < Math.min(a.length, b.length); ++i) {\n    if (a[i] !== b[i]) {\n      break;\n    }\n  }\n  return a.slice(0, i);\n}\n\n/**\n * Check whether `parent` is contained within the start of `child`\n *\n * Note on terminology: Parent is here the shortest array, as it will\n * be the parent in a tree-view of values, e.g. a path. In other words, parent\n * is a subsequence of child.\n */\nexport\nfunction isPrefixArray(parent: any[] | null, child: any[] | null): boolean {\n  if (parent === child) {\n    return true;\n  }\n  if (parent === null || parent.length === 0) {\n    return true;\n  }\n  if (child === null || parent.length > child.length) {\n    return false;\n  }\n  for (let i = 0; i < parent.length; ++i) {\n    if (parent[i] !== child[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Sort array by attribute `key` (i.e. compare by array[0][key] < array[1][key]). Stable.\n */\nexport\nfunction sortByKey<T extends {[key: string]: any}>(array: T[], key: string): T[] {\n    return stableSort(array, function(a, b) {\n        let x = a[key]; let y = b[key];\n        return ((x < y) ? -1 : ((x > y) ? 1 : 0));\n    });\n}\n\n\n/**\n * Utility function to repeat a string\n */\nexport\nfunction repeatString(str: string, count: number): string {\n  if (count < 1) {\n    return '';\n  }\n  let result = '';\n  let pattern = str.valueOf();\n  while (count > 1) {\n    if (count & 1) {\n      result += pattern;\n    }\n    count >>= 1, pattern += pattern;\n  }\n  return result + pattern;\n}\n\n/**\n * Calculate the cumulative sum of string lengths for an array of strings\n *\n * Example:\n *   For the arary ['ab', '123', 'y', '\\t\\nfoo'], the output would be\n *   [2, 5, 6, 11]\n */\nexport\nfunction accumulateLengths(arr: string[]) {\n  let ret: number[] = [];\n  arr.reduce<number>(function(a: number, b: string, i: number): number {\n    return ret[i] = a + b.length;\n  }, 0);\n  return ret;\n}\n\n/**\n * Filter for Array.filter to only have unique values\n */\nexport\nfunction unique<T>(value: T, index: number, self: T[]): boolean {\n  return self.indexOf(value) === index;\n}\n\n/**\n * Return the intersection of two arrays (with no duplicates)\n */\nexport\nfunction intersection<T>(a: T[], b: T[]): T[] {\n  let ret: T[] = [];\n  // Loop over longest, so that indexOf works on shortest\n  [a, b] = a.length > b.length ? [a, b] : [b, a];\n  for (let ia of a) {\n    if (b.indexOf(ia) !== -1) {\n      ret.push(ia);\n    }\n  }\n  return ret;\n}\n\n\n/**\n * Similar to Array.sort, but guaranteed to keep order stable\n * when compare function returns 0\n */\nexport\nfunction stableSort<T>(arr: T[], compare: (a: T, b: T) => number): T[] {\n  let sorters: {index: number, key: T}[] = [];\n  for (let i=0; i < arr.length; ++i) {\n    sorters.push({index: i, key: arr[i]});\n  }\n  sorters = sorters.sort((a: {index: number, key: T}, b: {index: number, key: T}): number => {\n    return compare(a.key, b.key) || a.index - b.index;\n  });\n  let out: T[] = new Array<T>(arr.length);\n  for (let i=0; i < arr.length; ++i) {\n    out[i] = arr[sorters[i].index];\n  }\n  return out;\n}\n\n\n/**\n * Copy an object, possibly extending it in the process\n */\nexport function copyObj<T extends {[key: string]: any}>(obj: T): T;\nexport function copyObj<T extends {[key: string]: any}, U extends {[key: string]: any}>\n(obj: T, target?: U): T & U;\nexport function copyObj(obj: {[key: string]: any}, target?: {[key: string]: any}): any {\n  if (!target) {\n    target = {};\n  }\n  for (let prop in obj) {\n    if (obj.hasOwnProperty(prop)) {\n      target[prop] = obj[prop];\n    }\n  }\n  return target;\n}\n\n\n/**\n * Create or populate a select element with string options\n */\nexport\nfunction buildSelect(options: string[], select?: HTMLSelectElement): HTMLSelectElement {\n  if (select === undefined) {\n    select = document.createElement('select');\n  }\n  for (let option of options) {\n    let opt = document.createElement('option');\n    opt.text = option;\n    select.appendChild(opt);\n  }\n  return select;\n}\n", "// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport * as util from '../../../src/common/util';\n\ndescribe('common', () => {\n\n  describe('util', () => {\n\n    describe('arraysEqual', () => {\n\n      it('should return true for instance equality', () => {\n        let a = [1, 2, 3];\n        let value = util.arraysEqual(a, a);\n        expect(value).toBe(true);\n      });\n\n      it('should return true for shallow equality', () => {\n        let arrays = [[1, 2, 3],\n                      ['a', 'b', 'c'],\n                      [123, 'text', true]];\n        for (let a of arrays) {\n          let value = util.arraysEqual(a, a.slice());\n          expect(value).toBe(true);\n        }\n      });\n\n      it('should return true for both null', () => {\n        let value = util.arraysEqual(null, null);\n        expect(value).toBe(true);\n      });\n\n      it('should return false for one null input', () => {\n        let a = [1, 2, 3];\n        let value = util.arraysEqual(null, a);\n        expect(value).toBe(false);\n\n        value = util.arraysEqual(a, null);\n        expect(value).toBe(false);\n      });\n\n      it('should return false for different length arrays', () => {\n        let value = util.arraysEqual([1, 2, 3], [1, 2]);\n        expect(value).toBe(false);\n\n        value = util.arraysEqual([1, 2], [1, 2, 3]);\n        expect(value).toBe(false);\n      });\n\n      it('should return false for deep comparison', () => {\n        let value = util.arraysEqual([{a: 1, b: 2}], [{a: 1, b: 2}]);\n        expect(value).toBe(false);\n      });\n\n    });\n\n    describe('findSharedPrefix', () => {\n\n      it('should return a copy on identical input', () => {\n        let a = [1, 2, 3];\n        let value = util.findSharedPrefix(a, a);\n        expect(value).toEqual(a);\n        expect(value).not.toBe(a);  // Checking for instance equality\n      });\n\n      it('should return null for null inputs', () => {\n        let value = util.findSharedPrefix(null, null);\n        expect(value).toBe(null);\n\n        value = util.findSharedPrefix(null, [1, 2]);\n        expect(value).toBe(null);\n\n        value = util.findSharedPrefix([1, 2], null);\n        expect(value).toBe(null);\n      });\n\n      it('should return empty array for one or more empy inputs', () => {\n        let value = util.findSharedPrefix([], []);\n        expect(value).toEqual([]);\n\n        value = util.findSharedPrefix([], [1, 2]);\n        expect(value).toEqual([]);\n\n        value = util.findSharedPrefix([1, 2], []);\n        expect(value).toEqual([]);\n      });\n\n      it('should return empty array for disjoint inputs', () => {\n        let value = util.findSharedPrefix([1, 2, 3], ['a', 'b', 'c']);\n        expect(value).toEqual([]);\n      });\n\n      it('should return empty array for inputs that overlap after start', () => {\n        let value = util.findSharedPrefix([1, 2, 3, 4], [5, 2, 3, 4]);\n        expect(value).toEqual([]);\n      });\n\n      it('should find prefix of single element arrays', () => {\n        let value = util.findSharedPrefix([1], [1]);\n        expect(value).toEqual([1]);\n\n        value = util.findSharedPrefix(['text'], ['text']);\n        expect(value).toEqual(['text']);\n      });\n\n      it('should find prefix of muliple element arrays that are equal', () => {\n        let value = util.findSharedPrefix([1, 2, 3], [1, 2, 3]);\n        expect(value).toEqual([1, 2, 3]);\n\n        value = util.findSharedPrefix(['text', 'abc'], ['text', 'abc']);\n        expect(value).toEqual(['text', 'abc']);\n      });\n\n      it('should find prefix of muliple element arrays that are not equal', () => {\n        let value = util.findSharedPrefix([1, 2, 3, 4, 5], [1, 2, 3, 6, 7]);\n        expect(value).toEqual([1, 2, 3]);\n\n        value = util.findSharedPrefix(['text', 'abc', 'foo'], ['text', 'abc', 'bar']);\n        expect(value).toEqual(['text', 'abc']);\n      });\n\n    });\n\n    describe('isPrefixArray', () => {\n\n      it('should return true for object equality', () => {\n        let a = [1, 2, 3];\n        let value = util.isPrefixArray(a, a);\n        expect(value).toBe(true);\n      });\n\n      it('should return true for null parent', () => {\n        let a = [1, 2, 3];\n        let value = util.isPrefixArray(a, a);\n        expect(value).toBe(true);\n      });\n\n      it('should return true for null parent', () => {\n        let value = util.isPrefixArray(null, null);\n        expect(value).toBe(true);\n\n        value = util.isPrefixArray(null, [1, 2, 3]);\n        expect(value).toBe(true);\n      });\n\n      it('should return true for empty parent', () => {\n        let value = util.isPrefixArray([], null);\n        expect(value).toBe(true);\n\n        value = util.isPrefixArray([], []);\n        expect(value).toBe(true);\n\n        value = util.isPrefixArray([], [1, 2, 3]);\n        expect(value).toBe(true);\n      });\n\n      it('should return false for null child, with non null/empty parent', () => {\n        let value = util.isPrefixArray([1], null);\n        expect(value).toBe(false);\n      });\n\n      it('should return false if child is shorter than parent', () => {\n        let value = util.isPrefixArray([1], []);\n        expect(value).toBe(false);\n\n        value = util.isPrefixArray([1, 2, 3, 4], [1, 2, 3]);\n        expect(value).toBe(false);\n      });\n\n      it('should return true if child is equal to parent', () => {\n        let value = util.isPrefixArray([1], [1]);\n        expect(value).toBe(true);\n\n        value = util.isPrefixArray([1, 2, 3, 4], [1, 2, 3, 4]);\n        expect(value).toBe(true);\n\n        value = util.isPrefixArray(['abc', 'def', 0], ['abc', 'def', 0]);\n        expect(value).toBe(true);\n      });\n\n      it('should return true if entire parent matches start of child', () => {\n        let value = util.isPrefixArray([1], [1, 2]);\n        expect(value).toBe(true);\n\n        value = util.isPrefixArray([1, 2, 3], [1, 2, 3, 4]);\n        expect(value).toBe(true);\n\n        value = util.isPrefixArray(['abc', 'def'], ['abc', 'def', 0]);\n        expect(value).toBe(true);\n      });\n\n      it('should return false if entire parent matches non-start of child', () => {\n        let value = util.isPrefixArray([2], [1, 2]);\n        expect(value).toBe(false);\n\n        value = util.isPrefixArray([2, 3, 4], [1, 2, 3, 4]);\n        expect(value).toBe(false);\n\n        value = util.isPrefixArray(['def'], ['abc', 'def', 0]);\n        expect(value).toBe(false);\n      });\n\n    });\n\n    describe('accumulateLengths', () => {\n\n      it('should handle an empty array', () => {\n        let value = util.accumulateLengths([]);\n        expect(value).toEqual([]);\n      });\n\n      it('should handle an single item array', () => {\n        let value = util.accumulateLengths(['abc']);\n        expect(value).toEqual([3]);\n      });\n\n      it('should handle multiple strings', () => {\n        let value = util.accumulateLengths(['abc', 'foo', '0xdead']);\n        expect(value).toEqual([3, 6, 12]);\n      });\n\n      it('should handle multiple strings with newlines at end', () => {\n        let value = util.accumulateLengths(['abc\\n', 'foo\\n', '0xdead\\n']);\n        expect(value).toEqual([4, 8, 15]);\n      });\n\n      it('should handle multiple strings with newlines randomly placed', () => {\n        let value = util.accumulateLengths(['\\nabc', 'foo\\n', '0xde\\nad']);\n        expect(value).toEqual([4, 8, 15]);\n      });\n\n    });\n\n    describe('hasEntries', () => {\n\n      it('should return false for null', () => {\n        let value = util.hasEntries(null);\n        expect(value).toBe(false);\n      });\n\n      it('should return false for empty array', () => {\n        let value = util.hasEntries([]);\n        expect(value).toBe(false);\n      });\n\n      it('should return true for array with falsy entry', () => {\n        let value = util.hasEntries([0]);\n        expect(value).toBe(true);\n      });\n\n      it('should return true for array with truthy entry', () => {\n        let value = util.hasEntries([4]);\n        expect(value).toBe(true);\n      });\n\n    });\n\n    describe('buildSelect', () => {\n\n      it('should create an empty select', () => {\n        let value = util.buildSelect([]);\n        expect(value.outerHTML).toEqual(\"<select></select>\");\n      });\n\n      it('should reuse a given select', () => {\n        const select = document.createElement('select');\n        let value = util.buildSelect([], select);\n        expect(value).toBe(select);\n      });\n\n      it('should create a select with options', () => {\n        let value = util.buildSelect([\n          'foo',\n          'bar',\n          '<div>boo</div>'\n        ]);\n        expect(value.outerHTML).toEqual(\n          '<select>' +\n            '<option>foo</option>' +\n            '<option>bar</option>' +\n            '<option>&lt;div&gt;boo&lt;/div&gt;</option>' +\n          '</select>'\n        );\n      });\n\n    });\n\n  });\n\n});\n", "// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n'use strict';\n\n\nimport * as nbformat from '@jupyterlab/nbformat';\n\nimport {\n  Panel, Widget\n} from '@lumino/widgets';\n\nimport {\n  RenderMimeRegistry\n} from '@jupyterlab/rendermime';\n\nimport {\n  defaultSanitizer\n} from '@jupyterlab/apputils';\n\nimport {\n  PageConfig\n} from '@jupyterlab/coreutils';\n\nimport {\n  MathJaxTypesetter\n} from '@jupyterlab/mathjax2';\n\nimport {\n  IDiffEntry\n} from 'nbdime/lib/diff/diffentries';\n\nimport {\n  NotebookDiffModel\n} from 'nbdime/lib/diff/model';\n\nimport {\n  NotebookDiffWidget\n} from 'nbdime/lib/diff/widget';\n\nimport {\n  requestDiff\n} from 'nbdime/lib/request';\n\nimport {\n  getBaseUrl, getConfigOption, toggleSpinner, toggleShowUnchanged,\n  markUnchangedRanges\n} from './common';\n\nimport {\n  exportDiff\n} from './staticdiff';\n\nimport {\n  rendererFactories\n} from './rendermime';\n\nlet diffWidget: NotebookDiffWidget | null = null;\n\nconst prefixes = ['git:', 'checkpoint:'];\n\nfunction hasPrefix(candidate: string): boolean {\n  for (let p of prefixes) {\n    if (candidate.slice(0, p.length) === p) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction stripPrefix(s: string): string {\n  for (let p of prefixes) {\n    if (s.slice(0, p.length) === p) {\n      return s.slice(p.length);\n    }\n  }\n  return s;\n}\n\n\n/**\n * Show the diff as represented by the base notebook and a list of diff entries\n */\nfunction showDiff(data: {base: nbformat.INotebookContent, diff: IDiffEntry[]}): Promise<void> {\n\n\n  let rendermime = new RenderMimeRegistry({\n    initialFactories: rendererFactories,\n    sanitizer: defaultSanitizer,\n    latexTypesetter: new MathJaxTypesetter({\n      url: getConfigOption('mathjaxUrl'),\n      config: getConfigOption('mathjaxConfig'),\n    }),\n  });\n\n  let nbdModel = new NotebookDiffModel(data.base, data.diff);\n  let nbdWidget = new NotebookDiffWidget(nbdModel, rendermime);\n\n  let root = document.getElementById('nbdime-root');\n  if (!root) {\n    throw new Error('Missing root element \"nbidme-root\"');\n  }\n  root.innerHTML = '';\n  // Hide unchanged cells by default:\n  toggleShowUnchanged(!getConfigOption('hideUnchanged', true));\n\n  let panel = new Panel();\n  panel.id = 'main';\n  Widget.attach(panel, root);\n  panel.addWidget(nbdWidget);\n  let work = nbdWidget.init();\n  work.then(() => {\n    window.onresize = () => { panel.update(); };\n  });\n  diffWidget = nbdWidget;\n  return work;\n}\n\n/**\n * Diff form submission callback. Sends a request for a diff to the server based\n * on the content of the form.\n */\nfunction onDiff(e: Event) {\n  e.preventDefault();\n  let b = (document.getElementById('diff-base') as HTMLInputElement).value;\n  let r = (document.getElementById('diff-remote') as HTMLInputElement).value;\n  compare(b, r, true);\n  return false;\n};\n\n\nfunction compare(base: string, remote: string | undefined, pushHistory: boolean | 'replace') {\n  toggleSpinner(true);\n  getDiff(base, remote);\n  if (pushHistory) {\n    let uri = window.location.pathname;\n    base = stripPrefix(base);\n    uri = '?base=' + encodeURIComponent(base);\n    if (remote) {\n      uri += '&remote=' + encodeURIComponent(remote);\n    }\n    editHistory(pushHistory, {base, remote},\n      'Diff: \"' + base + '\" vs \"' + remote + '\"', uri);\n  }\n}\n\nfunction editHistory(pushHistory: boolean | 'replace', statedata: any, title: string, url?: string): void {\n  if (pushHistory === true) {\n    history.pushState(statedata, title, url);\n  } else if (pushHistory === 'replace') {\n    history.replaceState(statedata, title, url);\n  }\n}\n\n\n/**\n * Calls `requestDiff` with our response handlers\n */\nexport\nfunction getDiff(base: string, remote: string | undefined) {\n  let baseUrl = getBaseUrl();\n  requestDiff(base, remote, baseUrl, onDiffRequestCompleted, onDiffRequestFailed);\n}\n\n/**\n * Callback for a successfull diff request\n */\nfunction onDiffRequestCompleted(data: any) {\n  let layoutWork = showDiff(data);\n\n  layoutWork.then(() => {\n    let exportBtn = document.getElementById('nbdime-export') as HTMLButtonElement;\n    exportBtn.style.display = 'initial';\n    toggleSpinner(false);\n    markUnchangedRanges();\n  });\n}\n\n/**\n * Callback for a failed diff request\n */\nfunction onDiffRequestFailed(response: string) {\n  console.log('Diff request failed.');\n  const root = document.getElementById('nbdime-root');\n  if (!root) {\n    throw new Error('Missing root element \"nbidme-root\"');\n  }\n  const pre = document.createElement('pre');\n  pre.innerText = response;\n  root.innerHTML = '';\n  root.appendChild(pre);\n  diffWidget = null;\n  toggleSpinner(false);\n}\n\n\n/**\n * Called when a 'back' is requested\n */\nfunction onPopState(e: PopStateEvent) {\n  if (e.state) {\n    let eb = (document.getElementById('diff-base') as HTMLInputElement);\n    let er = (document.getElementById('diff-remote') as HTMLInputElement);\n    eb.value = e.state.base;\n    er.value = e.state.remote;\n    compare(e.state.base, e.state.remote, false);\n  }\n}\n\n/**\n * Trust all outputs in diff\n */\nfunction trustOutputs() {\n  let trust = true;\n  if (!diffWidget) {\n    return;\n  }\n  let model = diffWidget.model;\n  for (let cell of model.cells) {\n    if (!cell.outputs) {\n      continue;\n    }\n    for (let output of cell.outputs) {\n      output.trusted = trust;\n    }\n  }\n}\n\n\n/**\n * Wire up callbacks.\n */\nfunction attachToForm() {\n  let frm = document.getElementById('nbdime-diff-form') as HTMLFormElement;\n  if (frm) {\n    frm.onsubmit = onDiff;\n    // It only makes sense to listen to pop state events when the form is\n    // availalbe (i.e. when we are not a diff/mergetool):\n    window.onpopstate = onPopState;\n  }\n}\n\n\n/**\n *\n */\nexport\nfunction initializeDiff() {\n  attachToForm();\n  // If arguments supplied in config, run diff directly:\n  let base = getConfigOption('base');\n  let remote = getConfigOption('remote');\n  if (base && (remote || hasPrefix(base))) {\n    compare(base, remote, 'replace');\n  }\n\n  let exportBtn = document.getElementById('nbdime-export') as HTMLButtonElement;\n  exportBtn.onclick = exportDiff;\n\n  let hideUnchangedChk = document.getElementById('nbdime-hide-unchanged') as HTMLInputElement;\n  hideUnchangedChk.checked = getConfigOption('hideUnchanged', true);\n  hideUnchangedChk.onchange = () => {\n    toggleShowUnchanged(!hideUnchangedChk.checked, diffWidget);\n  };\n\n  let trustBtn = document.getElementById('nbdime-trust') as HTMLButtonElement;\n  trustBtn.onclick = trustOutputs;\n  trustBtn.style.display = 'initial';\n}\n", "// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n'use strict';\n\n\nimport * as alertify from 'alertify.js';\n\nimport * as nbformat from '@jupyterlab/nbformat';\n\nimport {\n  JSONExt, JSONObject\n} from '@lumino/coreutils';\n\nimport {\n  Panel, Widget\n} from '@lumino/widgets';\n\nimport {\n  RenderMimeRegistry\n} from '@jupyterlab/rendermime';\n\nimport {\n  defaultSanitizer\n} from '@jupyterlab/apputils';\n\nimport {\n  NotebookMergeModel\n} from 'nbdime/lib/merge/model';\n\nimport {\n  IMergeDecision\n} from 'nbdime/lib/merge/decisions';\n\nimport {\n  NotebookMergeWidget\n} from 'nbdime/lib/merge/widget';\n\nimport {\n  stringify\n} from 'nbdime/lib/patch';\n\nimport {\n  requestMerge, requestApi\n} from 'nbdime/lib/request';\n\nimport {\n  getBaseUrl, getConfigOption, closeTool, toggleSpinner,\n  toggleShowUnchanged, markUnchangedRanges\n} from './common';\n\nimport {\n  rendererFactories\n} from './rendermime';\n\nimport {\n  extractMergedNotebook\n} from './save';\n\n\nlet mergeWidget: NotebookMergeWidget | null = null;\n\n/**\n * Show the merge as represented by the base notebook and a\n * list of merge decisions\n */\nfunction showMerge(data: {\n    base: nbformat.INotebookContent,\n    merge_decisions: IMergeDecision[]\n    }): Promise<void> {\n\n  let rendermime = new RenderMimeRegistry({\n    initialFactories: rendererFactories,\n    sanitizer: defaultSanitizer,\n  });\n\n  let nbmModel = new NotebookMergeModel(data.base,\n      data.merge_decisions);\n  let nbmWidget = new NotebookMergeWidget(nbmModel, rendermime);\n\n  let root = document.getElementById('nbdime-root');\n  if (!root) {\n    throw new Error('Missing root element \"nbidme-root\"');\n  }\n  root.innerHTML = '';\n  // Hide unchanged cells by default:\n  toggleShowUnchanged(!getConfigOption('hideUnchanged', true));\n\n  let panel = new Panel();\n  panel.id = 'main';\n  Widget.attach(panel, root);\n  panel.addWidget(nbmWidget);\n  let work = nbmWidget.init();\n  work.then(() => {\n    window.onresize = () => { panel.update(); };\n  });\n  mergeWidget = nbmWidget;\n  return work;\n}\n\n/**\n * Calls `requestMerge` with our response handlers\n */\nexport\nfunction getMerge(base: string, local: string, remote: string) {\n  let baseUrl = getBaseUrl();\n  requestMerge(base, local, remote, baseUrl, onMergeRequestCompleted, onMergeRequestFailed);\n}\n\n/**\n * Merge form submission callback. Sends a request for a merge to the server\n * based on the content of the form.\n *\n * Also pushes state to history for navigation history wo/reload\n */\nfunction onMerge(e: Event) {\n  e.preventDefault();\n  let b = (document.getElementById('merge-base') as HTMLInputElement).value;\n  let c = (document.getElementById('merge-local') as HTMLInputElement).value;\n  let r = (document.getElementById('merge-remote') as HTMLInputElement).value;\n  compare(b, c, r, true);\n  return false;\n};\n\nfunction compare(b: string, c: string, r: string, pushHistory: boolean | 'replace') {\n  // All values present, do merge\n  toggleSpinner(true);\n  getMerge(b, c, r);\n  if (pushHistory) {\n    let uri = window.location.pathname;\n    uri += '?base=' + encodeURIComponent(b) +\n      '&local=' + encodeURIComponent(c) +\n      '&remote=' + encodeURIComponent(r);\n    editHistory(pushHistory, {base: b, local: c, remote: r},\n      'Merge: \"' + c + '\" - \"' + b + '\" - \"' + r + '\"', uri);\n  }\n}\n\nfunction editHistory(pushHistory: boolean | 'replace', statedata: any, title: string, url?: string): void {\n  if (pushHistory === true) {\n    history.pushState(statedata, title, url);\n  } else if (pushHistory === 'replace') {\n    history.replaceState(statedata, title, url);\n  }\n}\n\n/**\n * Called when a 'back' is requested\n */\nfunction onPopState(e: PopStateEvent) {\n  if (e.state) {\n    let eb = (document.getElementById('merge-base') as HTMLInputElement);\n    let el = (document.getElementById('merge-local') as HTMLInputElement);\n    let er = (document.getElementById('merge-remote') as HTMLInputElement);\n\n    eb.value = e.state.base;\n    el.value = e.state.local;\n    er.value = e.state.remote;\n    compare(e.state.base, e.state.local, e.state.remote, false);\n  }\n}\n\n/**\n * Callback for a successfull merge request\n */\nfunction onMergeRequestCompleted(data: any) {\n  let layoutWork = showMerge(data);\n  layoutWork.then(() => {\n    toggleSpinner(false);\n    markUnchangedRanges();\n  });\n}\n\n/**\n * Callback for a failed merge request\n */\nfunction onMergeRequestFailed(response: string) {\n  console.log('Merge request failed.');\n  let root = document.getElementById('nbdime-root');\n  if (!root) {\n    throw new Error('Missing root element \"nbidme-root\"');\n  }\n  const pre = document.createElement('pre');\n  pre.innerText = response;\n  root.innerHTML = '';\n  root.appendChild(pre);\n  mergeWidget = null;\n  toggleSpinner(false);\n}\n\n\n/**\n * Extract the merged notebook from the model, as well as any remaining\n * conflicts, and send them to the server for storage / further processing.\n */\nexport\nfunction saveMerged() {\n  if (!mergeWidget) {\n    return;\n  }\n  let nb = extractMergedNotebook(mergeWidget);\n  let conflicts: IMergeDecision[] = [];\n  for (let md of mergeWidget.model.conflicts) {\n    conflicts.push(md.serialize());\n  }\n  submitMerge(nb, conflicts);\n}\n\n\nfunction downloadNotebook(notebook: nbformat.INotebookContent, filename: string) {\n  let element = document.createElement('a');\n  const nbCopy = JSONExt.deepCopy(notebook) as JSONObject;\n  element.setAttribute(\n    'href', 'data:text/plain;charset=utf-8,' +\n    encodeURIComponent(stringify(nbCopy)));\n  element.setAttribute('download', filename);\n\n  element.style.display = 'none';\n  document.body.appendChild(element);\n  try {\n    element.click();\n  } finally {\n    document.body.removeChild(element);\n  }\n}\n\n\nfunction getMergeFilename() {\n  // If present use 'outputfilename'\n  let filename = getConfigOption('outputfilename');\n  // Otherwise use base name as suggestion\n  if (!filename) {\n    filename = getConfigOption('base');\n  }\n  // Fallback:\n  if (!filename) {\n    filename = 'merged.ipynb';\n  }\n  return filename;\n}\n\n/**\n *\n */\nexport\nfunction downloadMerged() {\n  if (!mergeWidget) {\n    return;\n  }\n  function download() {\n    let filename = getMergeFilename();\n    let nb = extractMergedNotebook(mergeWidget!);\n    downloadNotebook(nb, filename);\n  }\n  let conflicted = mergeWidget.model.conflicts.length > 0;\n  if (conflicted) {\n    alertify.confirm('There are conflicts remaining. ' +\n      'Do you still want to download the merge output?', () => {\n        download();\n      });\n  } else {\n    download();\n  }\n}\n\n/**\n * Submit a merged notebook\n */\nfunction submitMerge(mergedNotebook: nbformat.INotebookContent,\n                     conflicts: IMergeDecision[]) {\n  requestApi(\n    getBaseUrl(),\n    '/api/store',\n    {\n      merged: mergedNotebook,\n      conflicts: conflicts\n    },\n    onSubmissionCompleted,\n    onSubmissionFailed);\n}\n\n/**\n * Callback for a successful store of the submitted merged notebook\n */\nfunction onSubmissionCompleted() {\n  alertify.success('Merged notebook saved successfully');\n  mergeWidget!.model.unsavedChanges = false;\n}\n\n/**\n * Callback for a failed store of the submitted merged notebook\n */\nfunction onSubmissionFailed(response: string) {\n  alertify.error('Was not able to save the notebook! See console and/or server log for details.');\n}\n\n\n/**\n * Called when the merge tool is closing, but it can be prevented.\n */\nexport\nfunction closeMerge(ev: Event, unloading=false): string | void | null {\n  if (!mergeWidget) {\n    return closeTool(1);\n  }\n  let savable = getConfigOption('savable');\n  for (let md of mergeWidget.model.conflicts) {\n    if (md.conflict) {\n      if (mergeWidget.model.unsavedChanges && savable) {\n        let prompt = 'There are remaining conflicts, and you have unsaved changes. Do you want to close anyway?';\n        if (unloading) {\n          ev.returnValue = true;\n          return prompt;\n        }\n        alertify.confirm(prompt,\n          () => {\n            window.onbeforeunload = null!;\n            closeTool(1);\n          },\n          () => {\n            ev.preventDefault();\n          });\n        return null;\n      } else {\n        let prompt = 'There are remaining conflicts. Do you want to close anyway?';\n        if (unloading) {\n          ev.returnValue = true;\n          return prompt;\n        }\n        alertify.confirm(prompt,\n          () => {\n            window.onbeforeunload = null!;\n            closeTool(1);\n          },\n          () => {\n            ev.preventDefault();\n          });\n        return null;\n      }\n    }\n  }\n  if (mergeWidget.model.unsavedChanges && savable) {\n    let prompt = 'There are unsaved changes. Do you want to close anyway?';\n    if (unloading) {\n      ev.returnValue = true;\n      return prompt;\n    }\n    alertify.confirm(prompt,\n      () => {\n        window.onbeforeunload = null!;\n        closeTool(0);\n      },\n      () => {\n        ev.preventDefault();\n      });\n    return null;\n  }\n  closeTool(0);\n  return null;\n}\n\n\n/**\n * Called when merge tool is closing, and it shouldn't be prevented.\n *\n * Will only try to set the correct exit code for the tool.\n */\nexport\nfunction forceCloseMerge(): void {\n  if (!mergeWidget) {\n    return closeTool(1);\n  }\n  for (let md of mergeWidget.model.conflicts) {\n    if (md.conflict) {\n      closeTool(1);\n    }\n  }\n  closeTool(0);\n}\n\n\n/**\n * Wire up callbacks.\n */\nfunction attachToForm() {\n  let frm = document.getElementById('nbdime-merge-form') as HTMLFormElement;\n  if (frm) {\n    frm.onsubmit = onMerge;\n    // It only makes sense to listen to pop state events when the form is\n    // availalbe (i.e. when we are not a diff/mergetool):\n    window.onpopstate = onPopState;\n  }\n}\n\n/** */\nexport\nfunction initializeMerge() {\n  attachToForm();\n  // If arguments supplied in config, run merge directly:\n  let base = getConfigOption('base');\n  let local = getConfigOption('local');  // Only available for merge\n  let remote = getConfigOption('remote');\n  if (base && local && remote) {\n    compare(base, local, remote, 'replace');\n  }\n\n  let savable = getConfigOption('savable');\n  let saveBtn = document.getElementById('nbdime-save') as HTMLButtonElement;\n  if (savable) {\n    saveBtn.onclick = saveMerged;\n    saveBtn.style.display = 'initial';\n  }\n  let downloadBtn = document.getElementById('nbdime-download') as HTMLButtonElement;\n  downloadBtn.onclick = downloadMerged;\n  downloadBtn.style.display = 'initial';\n\n  let hideUnchangedChk = document.getElementById('nbdime-hide-unchanged') as HTMLInputElement;\n  hideUnchangedChk.checked = getConfigOption('hideUnchanged', true);\n  hideUnchangedChk.onchange = () => {\n    toggleShowUnchanged(!hideUnchangedChk.checked, mergeWidget);\n  };\n}\n"], "filenames": ["packages/labextension/src/widget.ts", "packages/nbdime/src/common/util.ts", "packages/nbdime/test/src/common/util.spec.ts", "packages/webapp/src/app/diff.ts", "packages/webapp/src/app/merge.ts"], "buggy_code_start_loc": [242, 301, 257, 183, 182], "buggy_code_end_loc": [244, 302, 257, 188, 183], "fixing_code_start_loc": [242, 301, 258, 183, 182], "fixing_code_end_loc": [247, 302, 288, 191, 186], "type": "CWE-79", "message": "nbdime provides tools for diffing and merging of Jupyter Notebooks. In affected versions a stored cross-site scripting (XSS) issue exists within the Jupyter-owned nbdime project. It appears that when reading the file name and path from disk, the extension does not sanitize the string it constructs before returning it to be displayed. The diffNotebookCheckpoint function within nbdime causes this issue. When attempting to display the name of the local notebook (diffNotebookCheckpoint), nbdime appears to simply append .ipynb to the name of the input file. The NbdimeWidget is then created, and the base string is passed through to the request API function. From there, the frontend simply renders the HTML tag and anything along with it. Users are advised to patch to the most recent version of the affected product.", "other": {"cve": {"id": "CVE-2021-41134", "sourceIdentifier": "security-advisories@github.com", "published": "2021-11-03T18:15:08.350", "lastModified": "2021-11-05T17:24:13.647", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "nbdime provides tools for diffing and merging of Jupyter Notebooks. In affected versions a stored cross-site scripting (XSS) issue exists within the Jupyter-owned nbdime project. It appears that when reading the file name and path from disk, the extension does not sanitize the string it constructs before returning it to be displayed. The diffNotebookCheckpoint function within nbdime causes this issue. When attempting to display the name of the local notebook (diffNotebookCheckpoint), nbdime appears to simply append .ipynb to the name of the input file. The NbdimeWidget is then created, and the base string is passed through to the request API function. From there, the frontend simply renders the HTML tag and anything along with it. Users are advised to patch to the most recent version of the affected product."}, {"lang": "es", "value": "nbdime proporciona herramientas para diferenciar y fusionar cuadernos Jupyter. En las versiones afectadas se presenta un problema de tipo cross-site scripting (XSS) almacenado en el proyecto nbdime, propiedad de Jupyter. Parece que cuando se lee el nombre del archivo y la ruta desde el disco, la extensi\u00f3n no sanea la cadena que construye antes de devolverla para que se muestre. La funci\u00f3n diffNotebookCheckpoint dentro de nbdime causa este problema. Cuando es intentado mostrar el nombre del cuaderno local (diffNotebookCheckpoint), nbdime parece a\u00f1adir simplemente .ipynb al nombre del archivo de entrada. El NbdimeWidget es creado entonces, y la cadena base es pasada mediante la funci\u00f3n API de petici\u00f3n. A partir de ah\u00ed, el frontend simplemente renderiza la etiqueta HTML y todo lo que la acompa\u00f1a. Es recomendado a usuarios aplicar el parche a la versi\u00f3n m\u00e1s reciente del producto afectado"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.7, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.3, "impactScore": 5.8}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jupyter:nbdime:*:*:*:*:*:python:*:*", "versionStartIncluding": "1.0.0", "versionEndExcluding": "1.1.1", "matchCriteriaId": "DBCA217C-F72D-4F41-BF33-33BB74D47E09"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jupyter:nbdime:*:*:*:*:*:python:*:*", "versionStartIncluding": "2.0.0", "versionEndExcluding": "2.1.1", "matchCriteriaId": "8B65C129-8C5D-487A-AA5F-265753528C3D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jupyter:nbdime:*:*:*:*:*:python:*:*", "versionStartIncluding": "3.0.0", "versionEndIncluding": "3.1.1", "matchCriteriaId": "E52B1E1D-7D02-450D-A6C2-80C311D445BC"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jupyter:nbdime:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "5.0.0", "versionEndExcluding": "5.0.2", "matchCriteriaId": "8D73293E-65C1-467A-9EF9-FD2B2357EC82"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jupyter:nbdime:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "6.0.0", "versionEndExcluding": "6.1.2", "matchCriteriaId": "5F0BD8FE-D4AF-4213-85A6-CF01890A523D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jupyter:nbdime-jupyterlab:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "1.0.0", "versionEndExcluding": "1.0.1", "matchCriteriaId": "F7B26B18-E440-4E73-B79F-0AD6959663B9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jupyter:nbdime-jupyterlab:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "2.0.0", "versionEndExcluding": "2.1.1", "matchCriteriaId": "A51E3DDE-50ED-4841-B7DE-DE9674FD883D"}]}]}], "references": [{"url": "https://github.com/jupyter/nbdime/commit/e44a5cc7677f24b45ebafc756db49058c2f750ea", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/jupyter/nbdime/security/advisories/GHSA-p6rw-44q7-3fw4", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/jupyter/nbdime/commit/e44a5cc7677f24b45ebafc756db49058c2f750ea"}}