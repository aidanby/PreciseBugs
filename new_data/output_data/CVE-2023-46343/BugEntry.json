{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * Copyright (C) 2013  Intel Corporation. All rights reserved.\n */\n\n#define pr_fmt(fmt) \"nci_spi: %s: \" fmt, __func__\n\n#include <linux/module.h>\n\n#include <linux/export.h>\n#include <linux/spi/spi.h>\n#include <linux/crc-ccitt.h>\n#include <net/nfc/nci_core.h>\n\n#define NCI_SPI_ACK_SHIFT\t\t6\n#define NCI_SPI_MSB_PAYLOAD_MASK\t0x3F\n\n#define NCI_SPI_SEND_TIMEOUT\t(NCI_CMD_TIMEOUT > NCI_DATA_TIMEOUT ? \\\n\t\t\t\t\tNCI_CMD_TIMEOUT : NCI_DATA_TIMEOUT)\n\n#define NCI_SPI_DIRECT_WRITE\t0x01\n#define NCI_SPI_DIRECT_READ\t0x02\n\n#define ACKNOWLEDGE_NONE\t0\n#define ACKNOWLEDGE_ACK\t\t1\n#define ACKNOWLEDGE_NACK\t2\n\n#define CRC_INIT\t\t0xFFFF\n\nstatic int __nci_spi_send(struct nci_spi *nspi, const struct sk_buff *skb,\n\t\t\t  int cs_change)\n{\n\tstruct spi_message m;\n\tstruct spi_transfer t;\n\n\tmemset(&t, 0, sizeof(struct spi_transfer));\n\t/* a NULL skb means we just want the SPI chip select line to raise */\n\tif (skb) {\n\t\tt.tx_buf = skb->data;\n\t\tt.len = skb->len;\n\t} else {\n\t\t/* still set tx_buf non NULL to make the driver happy */\n\t\tt.tx_buf = &t;\n\t\tt.len = 0;\n\t}\n\tt.cs_change = cs_change;\n\tt.delay.value = nspi->xfer_udelay;\n\tt.delay.unit = SPI_DELAY_UNIT_USECS;\n\tt.speed_hz = nspi->xfer_speed_hz;\n\n\tspi_message_init(&m);\n\tspi_message_add_tail(&t, &m);\n\n\treturn spi_sync(nspi->spi, &m);\n}\n\nint nci_spi_send(struct nci_spi *nspi,\n\t\t struct completion *write_handshake_completion,\n\t\t struct sk_buff *skb)\n{\n\tunsigned int payload_len = skb->len;\n\tunsigned char *hdr;\n\tint ret;\n\tlong completion_rc;\n\n\t/* add the NCI SPI header to the start of the buffer */\n\thdr = skb_push(skb, NCI_SPI_HDR_LEN);\n\thdr[0] = NCI_SPI_DIRECT_WRITE;\n\thdr[1] = nspi->acknowledge_mode;\n\thdr[2] = payload_len >> 8;\n\thdr[3] = payload_len & 0xFF;\n\n\tif (nspi->acknowledge_mode == NCI_SPI_CRC_ENABLED) {\n\t\tu16 crc;\n\n\t\tcrc = crc_ccitt(CRC_INIT, skb->data, skb->len);\n\t\tskb_put_u8(skb, crc >> 8);\n\t\tskb_put_u8(skb, crc & 0xFF);\n\t}\n\n\tif (write_handshake_completion)\t{\n\t\t/* Trick SPI driver to raise chip select */\n\t\tret = __nci_spi_send(nspi, NULL, 1);\n\t\tif (ret)\n\t\t\tgoto done;\n\n\t\t/* wait for NFC chip hardware handshake to complete */\n\t\tif (wait_for_completion_timeout(write_handshake_completion,\n\t\t\t\t\t\tmsecs_to_jiffies(1000)) == 0) {\n\t\t\tret = -ETIME;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tret = __nci_spi_send(nspi, skb, 0);\n\tif (ret != 0 || nspi->acknowledge_mode == NCI_SPI_CRC_DISABLED)\n\t\tgoto done;\n\n\treinit_completion(&nspi->req_completion);\n\tcompletion_rc =\twait_for_completion_interruptible_timeout(\n\t\t\t\t\t\t\t&nspi->req_completion,\n\t\t\t\t\t\t\tNCI_SPI_SEND_TIMEOUT);\n\n\tif (completion_rc <= 0 || nspi->req_result == ACKNOWLEDGE_NACK)\n\t\tret = -EIO;\n\ndone:\n\tkfree_skb(skb);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(nci_spi_send);\n\n/* ---- Interface to NCI SPI drivers ---- */\n\n/**\n * nci_spi_allocate_spi - allocate a new nci spi\n *\n * @spi: SPI device\n * @acknowledge_mode: Acknowledge mode used by the NFC device\n * @delay: delay between transactions in us\n * @ndev: nci dev to send incoming nci frames to\n */\nstruct nci_spi *nci_spi_allocate_spi(struct spi_device *spi,\n\t\t\t\t     u8 acknowledge_mode, unsigned int delay,\n\t\t\t\t     struct nci_dev *ndev)\n{\n\tstruct nci_spi *nspi;\n\n\tnspi = devm_kzalloc(&spi->dev, sizeof(struct nci_spi), GFP_KERNEL);\n\tif (!nspi)\n\t\treturn NULL;\n\n\tnspi->acknowledge_mode = acknowledge_mode;\n\tnspi->xfer_udelay = delay;\n\t/* Use controller max SPI speed by default */\n\tnspi->xfer_speed_hz = 0;\n\tnspi->spi = spi;\n\tnspi->ndev = ndev;\n\tinit_completion(&nspi->req_completion);\n\n\treturn nspi;\n}\nEXPORT_SYMBOL_GPL(nci_spi_allocate_spi);\n\nstatic int send_acknowledge(struct nci_spi *nspi, u8 acknowledge)\n{\n\tstruct sk_buff *skb;\n\tunsigned char *hdr;\n\tu16 crc;\n\tint ret;\n\n\tskb = nci_skb_alloc(nspi->ndev, 0, GFP_KERNEL);\n\n\t/* add the NCI SPI header to the start of the buffer */\n\thdr = skb_push(skb, NCI_SPI_HDR_LEN);\n\thdr[0] = NCI_SPI_DIRECT_WRITE;\n\thdr[1] = NCI_SPI_CRC_ENABLED;\n\thdr[2] = acknowledge << NCI_SPI_ACK_SHIFT;\n\thdr[3] = 0;\n\n\tcrc = crc_ccitt(CRC_INIT, skb->data, skb->len);\n\tskb_put_u8(skb, crc >> 8);\n\tskb_put_u8(skb, crc & 0xFF);\n\n\tret = __nci_spi_send(nspi, skb, 0);\n\n\tkfree_skb(skb);\n\n\treturn ret;\n}\n\nstatic struct sk_buff *__nci_spi_read(struct nci_spi *nspi)\n{\n\tstruct sk_buff *skb;\n\tstruct spi_message m;\n\tunsigned char req[2], resp_hdr[2];\n\tstruct spi_transfer tx, rx;\n\tunsigned short rx_len = 0;\n\tint ret;\n\n\tspi_message_init(&m);\n\n\tmemset(&tx, 0, sizeof(struct spi_transfer));\n\treq[0] = NCI_SPI_DIRECT_READ;\n\treq[1] = nspi->acknowledge_mode;\n\ttx.tx_buf = req;\n\ttx.len = 2;\n\ttx.cs_change = 0;\n\ttx.speed_hz = nspi->xfer_speed_hz;\n\tspi_message_add_tail(&tx, &m);\n\n\tmemset(&rx, 0, sizeof(struct spi_transfer));\n\trx.rx_buf = resp_hdr;\n\trx.len = 2;\n\trx.cs_change = 1;\n\trx.speed_hz = nspi->xfer_speed_hz;\n\tspi_message_add_tail(&rx, &m);\n\n\tret = spi_sync(nspi->spi, &m);\n\tif (ret)\n\t\treturn NULL;\n\n\tif (nspi->acknowledge_mode == NCI_SPI_CRC_ENABLED)\n\t\trx_len = ((resp_hdr[0] & NCI_SPI_MSB_PAYLOAD_MASK) << 8) +\n\t\t\t\tresp_hdr[1] + NCI_SPI_CRC_LEN;\n\telse\n\t\trx_len = (resp_hdr[0] << 8) | resp_hdr[1];\n\n\tskb = nci_skb_alloc(nspi->ndev, rx_len, GFP_KERNEL);\n\tif (!skb)\n\t\treturn NULL;\n\n\tspi_message_init(&m);\n\n\tmemset(&rx, 0, sizeof(struct spi_transfer));\n\trx.rx_buf = skb_put(skb, rx_len);\n\trx.len = rx_len;\n\trx.cs_change = 0;\n\trx.delay.value = nspi->xfer_udelay;\n\trx.delay.unit = SPI_DELAY_UNIT_USECS;\n\trx.speed_hz = nspi->xfer_speed_hz;\n\tspi_message_add_tail(&rx, &m);\n\n\tret = spi_sync(nspi->spi, &m);\n\tif (ret)\n\t\tgoto receive_error;\n\n\tif (nspi->acknowledge_mode == NCI_SPI_CRC_ENABLED) {\n\t\t*(u8 *)skb_push(skb, 1) = resp_hdr[1];\n\t\t*(u8 *)skb_push(skb, 1) = resp_hdr[0];\n\t}\n\n\treturn skb;\n\nreceive_error:\n\tkfree_skb(skb);\n\n\treturn NULL;\n}\n\nstatic int nci_spi_check_crc(struct sk_buff *skb)\n{\n\tu16 crc_data = (skb->data[skb->len - 2] << 8) |\n\t\t\tskb->data[skb->len - 1];\n\tint ret;\n\n\tret = (crc_ccitt(CRC_INIT, skb->data, skb->len - NCI_SPI_CRC_LEN)\n\t\t\t== crc_data);\n\n\tskb_trim(skb, skb->len - NCI_SPI_CRC_LEN);\n\n\treturn ret;\n}\n\nstatic u8 nci_spi_get_ack(struct sk_buff *skb)\n{\n\tu8 ret;\n\n\tret = skb->data[0] >> NCI_SPI_ACK_SHIFT;\n\n\t/* Remove NFCC part of the header: ACK, NACK and MSB payload len */\n\tskb_pull(skb, 2);\n\n\treturn ret;\n}\n\n/**\n * nci_spi_read - read frame from NCI SPI drivers\n *\n * @nspi: The nci spi\n * Context: can sleep\n *\n * This call may only be used from a context that may sleep.  The sleep\n * is non-interruptible, and has no timeout.\n *\n * It returns an allocated skb containing the frame on success, or NULL.\n */\nstruct sk_buff *nci_spi_read(struct nci_spi *nspi)\n{\n\tstruct sk_buff *skb;\n\n\t/* Retrieve frame from SPI */\n\tskb = __nci_spi_read(nspi);\n\tif (!skb)\n\t\tgoto done;\n\n\tif (nspi->acknowledge_mode == NCI_SPI_CRC_ENABLED) {\n\t\tif (!nci_spi_check_crc(skb)) {\n\t\t\tsend_acknowledge(nspi, ACKNOWLEDGE_NACK);\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* In case of acknowledged mode: if ACK or NACK received,\n\t\t * unblock completion of latest frame sent.\n\t\t */\n\t\tnspi->req_result = nci_spi_get_ack(skb);\n\t\tif (nspi->req_result)\n\t\t\tcomplete(&nspi->req_completion);\n\t}\n\n\t/* If there is no payload (ACK/NACK only frame),\n\t * free the socket buffer\n\t */\n\tif (!skb->len) {\n\t\tkfree_skb(skb);\n\t\tskb = NULL;\n\t\tgoto done;\n\t}\n\n\tif (nspi->acknowledge_mode == NCI_SPI_CRC_ENABLED)\n\t\tsend_acknowledge(nspi, ACKNOWLEDGE_ACK);\n\ndone:\n\n\treturn skb;\n}\nEXPORT_SYMBOL_GPL(nci_spi_read);\n\nMODULE_LICENSE(\"GPL\");\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * Copyright (C) 2013  Intel Corporation. All rights reserved.\n */\n\n#define pr_fmt(fmt) \"nci_spi: %s: \" fmt, __func__\n\n#include <linux/module.h>\n\n#include <linux/export.h>\n#include <linux/spi/spi.h>\n#include <linux/crc-ccitt.h>\n#include <net/nfc/nci_core.h>\n\n#define NCI_SPI_ACK_SHIFT\t\t6\n#define NCI_SPI_MSB_PAYLOAD_MASK\t0x3F\n\n#define NCI_SPI_SEND_TIMEOUT\t(NCI_CMD_TIMEOUT > NCI_DATA_TIMEOUT ? \\\n\t\t\t\t\tNCI_CMD_TIMEOUT : NCI_DATA_TIMEOUT)\n\n#define NCI_SPI_DIRECT_WRITE\t0x01\n#define NCI_SPI_DIRECT_READ\t0x02\n\n#define ACKNOWLEDGE_NONE\t0\n#define ACKNOWLEDGE_ACK\t\t1\n#define ACKNOWLEDGE_NACK\t2\n\n#define CRC_INIT\t\t0xFFFF\n\nstatic int __nci_spi_send(struct nci_spi *nspi, const struct sk_buff *skb,\n\t\t\t  int cs_change)\n{\n\tstruct spi_message m;\n\tstruct spi_transfer t;\n\n\tmemset(&t, 0, sizeof(struct spi_transfer));\n\t/* a NULL skb means we just want the SPI chip select line to raise */\n\tif (skb) {\n\t\tt.tx_buf = skb->data;\n\t\tt.len = skb->len;\n\t} else {\n\t\t/* still set tx_buf non NULL to make the driver happy */\n\t\tt.tx_buf = &t;\n\t\tt.len = 0;\n\t}\n\tt.cs_change = cs_change;\n\tt.delay.value = nspi->xfer_udelay;\n\tt.delay.unit = SPI_DELAY_UNIT_USECS;\n\tt.speed_hz = nspi->xfer_speed_hz;\n\n\tspi_message_init(&m);\n\tspi_message_add_tail(&t, &m);\n\n\treturn spi_sync(nspi->spi, &m);\n}\n\nint nci_spi_send(struct nci_spi *nspi,\n\t\t struct completion *write_handshake_completion,\n\t\t struct sk_buff *skb)\n{\n\tunsigned int payload_len = skb->len;\n\tunsigned char *hdr;\n\tint ret;\n\tlong completion_rc;\n\n\t/* add the NCI SPI header to the start of the buffer */\n\thdr = skb_push(skb, NCI_SPI_HDR_LEN);\n\thdr[0] = NCI_SPI_DIRECT_WRITE;\n\thdr[1] = nspi->acknowledge_mode;\n\thdr[2] = payload_len >> 8;\n\thdr[3] = payload_len & 0xFF;\n\n\tif (nspi->acknowledge_mode == NCI_SPI_CRC_ENABLED) {\n\t\tu16 crc;\n\n\t\tcrc = crc_ccitt(CRC_INIT, skb->data, skb->len);\n\t\tskb_put_u8(skb, crc >> 8);\n\t\tskb_put_u8(skb, crc & 0xFF);\n\t}\n\n\tif (write_handshake_completion)\t{\n\t\t/* Trick SPI driver to raise chip select */\n\t\tret = __nci_spi_send(nspi, NULL, 1);\n\t\tif (ret)\n\t\t\tgoto done;\n\n\t\t/* wait for NFC chip hardware handshake to complete */\n\t\tif (wait_for_completion_timeout(write_handshake_completion,\n\t\t\t\t\t\tmsecs_to_jiffies(1000)) == 0) {\n\t\t\tret = -ETIME;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tret = __nci_spi_send(nspi, skb, 0);\n\tif (ret != 0 || nspi->acknowledge_mode == NCI_SPI_CRC_DISABLED)\n\t\tgoto done;\n\n\treinit_completion(&nspi->req_completion);\n\tcompletion_rc =\twait_for_completion_interruptible_timeout(\n\t\t\t\t\t\t\t&nspi->req_completion,\n\t\t\t\t\t\t\tNCI_SPI_SEND_TIMEOUT);\n\n\tif (completion_rc <= 0 || nspi->req_result == ACKNOWLEDGE_NACK)\n\t\tret = -EIO;\n\ndone:\n\tkfree_skb(skb);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(nci_spi_send);\n\n/* ---- Interface to NCI SPI drivers ---- */\n\n/**\n * nci_spi_allocate_spi - allocate a new nci spi\n *\n * @spi: SPI device\n * @acknowledge_mode: Acknowledge mode used by the NFC device\n * @delay: delay between transactions in us\n * @ndev: nci dev to send incoming nci frames to\n */\nstruct nci_spi *nci_spi_allocate_spi(struct spi_device *spi,\n\t\t\t\t     u8 acknowledge_mode, unsigned int delay,\n\t\t\t\t     struct nci_dev *ndev)\n{\n\tstruct nci_spi *nspi;\n\n\tnspi = devm_kzalloc(&spi->dev, sizeof(struct nci_spi), GFP_KERNEL);\n\tif (!nspi)\n\t\treturn NULL;\n\n\tnspi->acknowledge_mode = acknowledge_mode;\n\tnspi->xfer_udelay = delay;\n\t/* Use controller max SPI speed by default */\n\tnspi->xfer_speed_hz = 0;\n\tnspi->spi = spi;\n\tnspi->ndev = ndev;\n\tinit_completion(&nspi->req_completion);\n\n\treturn nspi;\n}\nEXPORT_SYMBOL_GPL(nci_spi_allocate_spi);\n\nstatic int send_acknowledge(struct nci_spi *nspi, u8 acknowledge)\n{\n\tstruct sk_buff *skb;\n\tunsigned char *hdr;\n\tu16 crc;\n\tint ret;\n\n\tskb = nci_skb_alloc(nspi->ndev, 0, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\t/* add the NCI SPI header to the start of the buffer */\n\thdr = skb_push(skb, NCI_SPI_HDR_LEN);\n\thdr[0] = NCI_SPI_DIRECT_WRITE;\n\thdr[1] = NCI_SPI_CRC_ENABLED;\n\thdr[2] = acknowledge << NCI_SPI_ACK_SHIFT;\n\thdr[3] = 0;\n\n\tcrc = crc_ccitt(CRC_INIT, skb->data, skb->len);\n\tskb_put_u8(skb, crc >> 8);\n\tskb_put_u8(skb, crc & 0xFF);\n\n\tret = __nci_spi_send(nspi, skb, 0);\n\n\tkfree_skb(skb);\n\n\treturn ret;\n}\n\nstatic struct sk_buff *__nci_spi_read(struct nci_spi *nspi)\n{\n\tstruct sk_buff *skb;\n\tstruct spi_message m;\n\tunsigned char req[2], resp_hdr[2];\n\tstruct spi_transfer tx, rx;\n\tunsigned short rx_len = 0;\n\tint ret;\n\n\tspi_message_init(&m);\n\n\tmemset(&tx, 0, sizeof(struct spi_transfer));\n\treq[0] = NCI_SPI_DIRECT_READ;\n\treq[1] = nspi->acknowledge_mode;\n\ttx.tx_buf = req;\n\ttx.len = 2;\n\ttx.cs_change = 0;\n\ttx.speed_hz = nspi->xfer_speed_hz;\n\tspi_message_add_tail(&tx, &m);\n\n\tmemset(&rx, 0, sizeof(struct spi_transfer));\n\trx.rx_buf = resp_hdr;\n\trx.len = 2;\n\trx.cs_change = 1;\n\trx.speed_hz = nspi->xfer_speed_hz;\n\tspi_message_add_tail(&rx, &m);\n\n\tret = spi_sync(nspi->spi, &m);\n\tif (ret)\n\t\treturn NULL;\n\n\tif (nspi->acknowledge_mode == NCI_SPI_CRC_ENABLED)\n\t\trx_len = ((resp_hdr[0] & NCI_SPI_MSB_PAYLOAD_MASK) << 8) +\n\t\t\t\tresp_hdr[1] + NCI_SPI_CRC_LEN;\n\telse\n\t\trx_len = (resp_hdr[0] << 8) | resp_hdr[1];\n\n\tskb = nci_skb_alloc(nspi->ndev, rx_len, GFP_KERNEL);\n\tif (!skb)\n\t\treturn NULL;\n\n\tspi_message_init(&m);\n\n\tmemset(&rx, 0, sizeof(struct spi_transfer));\n\trx.rx_buf = skb_put(skb, rx_len);\n\trx.len = rx_len;\n\trx.cs_change = 0;\n\trx.delay.value = nspi->xfer_udelay;\n\trx.delay.unit = SPI_DELAY_UNIT_USECS;\n\trx.speed_hz = nspi->xfer_speed_hz;\n\tspi_message_add_tail(&rx, &m);\n\n\tret = spi_sync(nspi->spi, &m);\n\tif (ret)\n\t\tgoto receive_error;\n\n\tif (nspi->acknowledge_mode == NCI_SPI_CRC_ENABLED) {\n\t\t*(u8 *)skb_push(skb, 1) = resp_hdr[1];\n\t\t*(u8 *)skb_push(skb, 1) = resp_hdr[0];\n\t}\n\n\treturn skb;\n\nreceive_error:\n\tkfree_skb(skb);\n\n\treturn NULL;\n}\n\nstatic int nci_spi_check_crc(struct sk_buff *skb)\n{\n\tu16 crc_data = (skb->data[skb->len - 2] << 8) |\n\t\t\tskb->data[skb->len - 1];\n\tint ret;\n\n\tret = (crc_ccitt(CRC_INIT, skb->data, skb->len - NCI_SPI_CRC_LEN)\n\t\t\t== crc_data);\n\n\tskb_trim(skb, skb->len - NCI_SPI_CRC_LEN);\n\n\treturn ret;\n}\n\nstatic u8 nci_spi_get_ack(struct sk_buff *skb)\n{\n\tu8 ret;\n\n\tret = skb->data[0] >> NCI_SPI_ACK_SHIFT;\n\n\t/* Remove NFCC part of the header: ACK, NACK and MSB payload len */\n\tskb_pull(skb, 2);\n\n\treturn ret;\n}\n\n/**\n * nci_spi_read - read frame from NCI SPI drivers\n *\n * @nspi: The nci spi\n * Context: can sleep\n *\n * This call may only be used from a context that may sleep.  The sleep\n * is non-interruptible, and has no timeout.\n *\n * It returns an allocated skb containing the frame on success, or NULL.\n */\nstruct sk_buff *nci_spi_read(struct nci_spi *nspi)\n{\n\tstruct sk_buff *skb;\n\n\t/* Retrieve frame from SPI */\n\tskb = __nci_spi_read(nspi);\n\tif (!skb)\n\t\tgoto done;\n\n\tif (nspi->acknowledge_mode == NCI_SPI_CRC_ENABLED) {\n\t\tif (!nci_spi_check_crc(skb)) {\n\t\t\tsend_acknowledge(nspi, ACKNOWLEDGE_NACK);\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* In case of acknowledged mode: if ACK or NACK received,\n\t\t * unblock completion of latest frame sent.\n\t\t */\n\t\tnspi->req_result = nci_spi_get_ack(skb);\n\t\tif (nspi->req_result)\n\t\t\tcomplete(&nspi->req_completion);\n\t}\n\n\t/* If there is no payload (ACK/NACK only frame),\n\t * free the socket buffer\n\t */\n\tif (!skb->len) {\n\t\tkfree_skb(skb);\n\t\tskb = NULL;\n\t\tgoto done;\n\t}\n\n\tif (nspi->acknowledge_mode == NCI_SPI_CRC_ENABLED)\n\t\tsend_acknowledge(nspi, ACKNOWLEDGE_ACK);\n\ndone:\n\n\treturn skb;\n}\nEXPORT_SYMBOL_GPL(nci_spi_read);\n\nMODULE_LICENSE(\"GPL\");\n"], "filenames": ["net/nfc/nci/spi.c"], "buggy_code_start_loc": [153], "buggy_code_end_loc": [153], "fixing_code_start_loc": [154], "fixing_code_end_loc": [156], "type": "CWE-476", "message": "In the Linux kernel before 6.5.9, there is a NULL pointer dereference in send_acknowledge in net/nfc/nci/spi.c.", "other": {"cve": {"id": "CVE-2023-46343", "sourceIdentifier": "cve@mitre.org", "published": "2024-01-23T10:15:10.383", "lastModified": "2024-01-29T22:51:18.303", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In the Linux kernel before 6.5.9, there is a NULL pointer dereference in send_acknowledge in net/nfc/nci/spi.c."}, {"lang": "es", "value": "En el kernel de Linux anterior a 6.5.9, hay una desreferencia de puntero NULL en send_acknowledge en net/nfc/nci/spi.c."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.5.9", "matchCriteriaId": "3163B50F-90CD-4C59-B542-BD1C9AE7CCE8"}]}]}], "references": [{"url": "https://cdn.kernel.org/pub/linux/kernel/v6.x/ChangeLog-6.5.9", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=7937609cd387246aed994e81aa4fa951358fba41", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/torvalds/linux/commit/7937609cd387246aed994e81aa4fa951358fba41", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://lore.kernel.org/netdev/20231013184129.18738-1-krzysztof.kozlowski%40linaro.org/T/#r38bdbaf8ae15305b77f6c5bc8e15d38f405623c7", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/7937609cd387246aed994e81aa4fa951358fba41"}}