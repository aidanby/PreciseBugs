{"buggy_code": ["// SPDX-License-Identifier: BSD-2-Clause\n/*\n * Copyright (c) 2014, STMicroelectronics International N.V.\n */\n#include <util.h>\n#include <kernel/tee_common_otp.h>\n#include <kernel/tee_common.h>\n#include <tee_api_types.h>\n#include <kernel/tee_ta_manager.h>\n#include <utee_types.h>\n#include <tee/tee_svc.h>\n#include <tee/tee_cryp_utl.h>\n#include <mm/tee_mmu.h>\n#include <mm/tee_mm.h>\n#include <mm/core_memprot.h>\n#include <kernel/tee_time.h>\n\n#include <user_ta_header.h>\n#include <trace.h>\n#include <kernel/trace_ta.h>\n#include <kernel/chip_services.h>\n#include <kernel/pseudo_ta.h>\n#include <mm/mobj.h>\n\nvaddr_t tee_svc_uref_base;\n\nvoid syscall_log(const void *buf __maybe_unused, size_t len __maybe_unused)\n{\n#ifdef CFG_TEE_CORE_TA_TRACE\n\tchar *kbuf;\n\n\tif (len == 0)\n\t\treturn;\n\n\tkbuf = malloc(len + 1);\n\tif (kbuf == NULL)\n\t\treturn;\n\n\tif (tee_svc_copy_from_user(kbuf, buf, len) == TEE_SUCCESS) {\n\t\tkbuf[len] = '\\0';\n\t\ttrace_ext_puts(kbuf);\n\t}\n\n\tfree(kbuf);\n#endif\n}\n\nTEE_Result syscall_not_supported(void)\n{\n\treturn TEE_ERROR_NOT_SUPPORTED;\n}\n\n/* Configuration properties */\n/* API implementation version */\nstatic const char api_vers[] = TO_STR(CFG_TEE_API_VERSION);\n\n/* Implementation description (implementation-dependent) */\nstatic const char descr[] = TO_STR(CFG_TEE_IMPL_DESCR);\n\n/*\n * TA persistent time protection level\n * 100: Persistent time based on an REE-controlled real-time clock\n * and on the TEE Trusted Storage for the storage of origins (default).\n * 1000: Persistent time based on a TEE-controlled real-time clock\n * and the TEE Trusted Storage.\n * The real-time clock MUST be out of reach of software attacks\n * from the REE.\n */\nstatic const uint32_t ta_time_prot_lvl = 100;\n\n/* Elliptic Curve Cryptographic support */\n#ifdef CFG_CRYPTO_ECC\nstatic const bool crypto_ecc_en = 1;\n#else\nstatic const bool crypto_ecc_en;\n#endif\n\n/*\n * Trusted storage anti rollback protection level\n * 0 (or missing): No antirollback protection (default)\n * 100: Antirollback enforced at REE level\n * 1000: Antirollback TEE-controlled hardware\n */\n#ifdef CFG_RPMB_FS\nstatic const uint32_t ts_antiroll_prot_lvl = 1000;\n#else\nstatic const uint32_t ts_antiroll_prot_lvl;\n#endif\n\n/* Trusted OS implementation version */\nstatic const char trustedos_impl_version[] = TO_STR(TEE_IMPL_VERSION);\n\n/* Trusted OS implementation version (binary value) */\nstatic const uint32_t trustedos_impl_bin_version; /* 0 by default */\n\n/* Trusted OS implementation manufacturer name */\nstatic const char trustedos_manufacturer[] = TO_STR(CFG_TEE_MANUFACTURER);\n\n/* Trusted firmware version */\nstatic const char fw_impl_version[] = TO_STR(CFG_TEE_FW_IMPL_VERSION);\n\n/* Trusted firmware version (binary value) */\nstatic const uint32_t fw_impl_bin_version; /* 0 by default */\n\n/* Trusted firmware manufacturer name */\nstatic const char fw_manufacturer[] = TO_STR(CFG_TEE_FW_MANUFACTURER);\n\nstatic TEE_Result get_prop_tee_dev_id(struct tee_ta_session *sess __unused,\n\t\t\t\t      void *buf, size_t *blen)\n{\n\tTEE_Result res;\n\tTEE_UUID uuid;\n\tconst size_t nslen = 5;\n\tuint8_t data[5 + FVR_DIE_ID_NUM_REGS * sizeof(uint32_t)] = {\n\t    'O', 'P', 'T', 'E', 'E' };\n\n\tif (*blen < sizeof(uuid)) {\n\t\t*blen = sizeof(uuid);\n\t\treturn TEE_ERROR_SHORT_BUFFER;\n\t}\n\t*blen = sizeof(uuid);\n\n\tif (tee_otp_get_die_id(data + nslen, sizeof(data) - nslen))\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tres = tee_hash_createdigest(TEE_ALG_SHA256, data, sizeof(data),\n\t\t\t\t    (uint8_t *)&uuid, sizeof(uuid));\n\tif (res != TEE_SUCCESS)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t/*\n\t * Changes the random value into and UUID as specifiec\n\t * in RFC 4122. The magic values are from the example\n\t * code in the RFC.\n\t *\n\t * TEE_UUID is defined slightly different from the RFC,\n\t * but close enough for our purpose.\n\t */\n\n\tuuid.timeHiAndVersion &= 0x0fff;\n\tuuid.timeHiAndVersion |= 5 << 12;\n\n\t/* uuid.clock_seq_hi_and_reserved in the RFC */\n\tuuid.clockSeqAndNode[0] &= 0x3f;\n\tuuid.clockSeqAndNode[0] |= 0x80;\n\n\treturn tee_svc_copy_to_user(buf, &uuid, sizeof(TEE_UUID));\n}\n\nstatic TEE_Result get_prop_tee_sys_time_prot_level(\n\t\t\tstruct tee_ta_session *sess __unused,\n\t\t\tvoid *buf, size_t *blen)\n{\n\tuint32_t prot;\n\n\tif (*blen < sizeof(prot)) {\n\t\t*blen = sizeof(prot);\n\t\treturn TEE_ERROR_SHORT_BUFFER;\n\t}\n\t*blen = sizeof(prot);\n\tprot = tee_time_get_sys_time_protection_level();\n\treturn tee_svc_copy_to_user(buf, &prot, sizeof(prot));\n}\n\nstatic TEE_Result get_prop_client_id(struct tee_ta_session *sess __unused,\n\t\t\t\t     void *buf, size_t *blen)\n{\n\tif (*blen < sizeof(TEE_Identity)) {\n\t\t*blen = sizeof(TEE_Identity);\n\t\treturn TEE_ERROR_SHORT_BUFFER;\n\t}\n\t*blen = sizeof(TEE_Identity);\n\treturn tee_svc_copy_to_user(buf, &sess->clnt_id, sizeof(TEE_Identity));\n}\n\nstatic TEE_Result get_prop_ta_app_id(struct tee_ta_session *sess,\n\t\t\t\t     void *buf, size_t *blen)\n{\n\tif (*blen < sizeof(TEE_UUID)) {\n\t\t*blen = sizeof(TEE_UUID);\n\t\treturn TEE_ERROR_SHORT_BUFFER;\n\t}\n\t*blen = sizeof(TEE_UUID);\n\treturn tee_svc_copy_to_user(buf, &sess->ctx->uuid, sizeof(TEE_UUID));\n}\n\n/* Properties of the set TEE_PROPSET_CURRENT_CLIENT */\nconst struct tee_props tee_propset_client[] = {\n\t{\n\t\t.name = \"gpd.client.identity\",\n\t\t.prop_type = USER_TA_PROP_TYPE_IDENTITY,\n\t\t.get_prop_func = get_prop_client_id\n\t},\n};\n\n/* Properties of the set TEE_PROPSET_CURRENT_TA */\nconst struct tee_props tee_propset_ta[] = {\n\t{\n\t\t.name = \"gpd.ta.appID\",\n\t\t.prop_type = USER_TA_PROP_TYPE_UUID,\n\t\t.get_prop_func = get_prop_ta_app_id\n\t},\n\n\t/*\n\t * Following properties are processed directly in libutee:\n\t *\tTA_PROP_STR_SINGLE_INSTANCE\n\t *\tTA_PROP_STR_MULTI_SESSION\n\t *\tTA_PROP_STR_KEEP_ALIVE\n\t *\tTA_PROP_STR_DATA_SIZE\n\t *\tTA_PROP_STR_STACK_SIZE\n\t *\tTA_PROP_STR_VERSION\n\t *\tTA_PROP_STR_DESCRIPTION\n\t *\tUSER_TA_PROP_TYPE_STRING,\n\t *\tTA_DESCRIPTION\n\t */\n};\n\n/* Properties of the set TEE_PROPSET_TEE_IMPLEMENTATION */\nconst struct tee_props tee_propset_tee[] = {\n\t{\n\t\t.name = \"gpd.tee.apiversion\",\n\t\t.prop_type = USER_TA_PROP_TYPE_STRING,\n\t\t.data = api_vers,\n\t\t.len = sizeof(api_vers),\n\t},\n\t{\n\t\t.name = \"gpd.tee.description\",\n\t\t.prop_type = USER_TA_PROP_TYPE_STRING,\n\t\t.data = descr, .len = sizeof(descr)\n\t},\n\t{\n\t\t.name = \"gpd.tee.deviceID\",\n\t\t.prop_type = USER_TA_PROP_TYPE_UUID,\n\t\t.get_prop_func = get_prop_tee_dev_id\n\t},\n\t{\n\t\t.name = \"gpd.tee.systemTime.protectionLevel\",\n\t\t.prop_type = USER_TA_PROP_TYPE_U32,\n\t\t.get_prop_func = get_prop_tee_sys_time_prot_level\n\t},\n\t{\n\t\t.name = \"gpd.tee.TAPersistentTime.protectionLevel\",\n\t\t.prop_type = USER_TA_PROP_TYPE_U32,\n\t\t.data = &ta_time_prot_lvl,\n\t\t.len = sizeof(ta_time_prot_lvl)\n\t},\n\t{\n\t\t.name = \"gpd.tee.cryptography.ecc\",\n\t\t.prop_type = USER_TA_PROP_TYPE_BOOL,\n\t\t.data = &crypto_ecc_en,\n\t\t.len = sizeof(crypto_ecc_en)\n\t},\n\t{\n\t\t.name = \"gpd.tee.trustedStorage.antiRollback.protectionLevel\",\n\t\t.prop_type = USER_TA_PROP_TYPE_U32,\n\t\t.data = &ts_antiroll_prot_lvl,\n\t\t.len = sizeof(ts_antiroll_prot_lvl)\n\t},\n\t{\n\t\t.name = \"gpd.tee.trustedos.implementation.version\",\n\t\t.prop_type = USER_TA_PROP_TYPE_STRING,\n\t\t.data = trustedos_impl_version,\n\t\t.len = sizeof(trustedos_impl_version)\n\t},\n\t{\n\t\t.name = \"gpd.tee.trustedos.implementation.binaryversion\",\n\t\t.prop_type = USER_TA_PROP_TYPE_U32,\n\t\t.data = &trustedos_impl_bin_version,\n\t\t.len = sizeof(trustedos_impl_bin_version)\n\t},\n\t{\n\t\t.name = \"gpd.tee.trustedos.manufacturer\",\n\t\t.prop_type = USER_TA_PROP_TYPE_STRING,\n\t\t.data = trustedos_manufacturer,\n\t\t.len = sizeof(trustedos_manufacturer)\n\t},\n\t{\n\t\t.name = \"gpd.tee.firmware.implementation.version\",\n\t\t.prop_type = USER_TA_PROP_TYPE_STRING,\n\t\t.data = fw_impl_version,\n\t\t.len = sizeof(fw_impl_version)\n\t},\n\t{\n\t\t.name = \"gpd.tee.firmware.implementation.binaryversion\",\n\t\t.prop_type = USER_TA_PROP_TYPE_U32,\n\t\t.data = &fw_impl_bin_version,\n\t\t.len = sizeof(fw_impl_bin_version)\n\t},\n\t{\n\t\t.name = \"gpd.tee.firmware.manufacturer\",\n\t\t.prop_type = USER_TA_PROP_TYPE_STRING,\n\t\t.data = fw_manufacturer,\n\t\t.len = sizeof(fw_manufacturer)\n\t},\n\n\t/*\n\t * Following properties are processed directly in libutee:\n\t *\tgpd.tee.arith.maxBigIntSize\n\t */\n};\n\n__weak const struct tee_vendor_props vendor_props_client;\n__weak const struct tee_vendor_props vendor_props_ta;\n__weak const struct tee_vendor_props vendor_props_tee;\n\nstatic void get_prop_set(unsigned long prop_set,\n\t\t\t const struct tee_props **props,\n\t\t\t size_t *size,\n\t\t\t const struct tee_props **vendor_props,\n\t\t\t size_t *vendor_size)\n{\n\tif ((TEE_PropSetHandle)prop_set == TEE_PROPSET_CURRENT_CLIENT) {\n\t\t*props = tee_propset_client;\n\t\t*size = ARRAY_SIZE(tee_propset_client);\n\t\t*vendor_props = vendor_props_client.props;\n\t\t*vendor_size = vendor_props_client.len;\n\t} else if ((TEE_PropSetHandle)prop_set == TEE_PROPSET_CURRENT_TA) {\n\t\t*props = tee_propset_ta;\n\t\t*size = ARRAY_SIZE(tee_propset_ta);\n\t\t*vendor_props = vendor_props_ta.props;\n\t\t*vendor_size = vendor_props_ta.len;\n\t} else if ((TEE_PropSetHandle)prop_set ==\n\t\t   TEE_PROPSET_TEE_IMPLEMENTATION) {\n\t\t*props = tee_propset_tee;\n\t\t*size = ARRAY_SIZE(tee_propset_tee);\n\t\t*vendor_props = vendor_props_tee.props;\n\t\t*vendor_size = vendor_props_tee.len;\n\t} else {\n\t\t*props = NULL;\n\t\t*size = 0;\n\t\t*vendor_props = NULL;\n\t\t*vendor_size = 0;\n\t}\n}\n\nstatic const struct tee_props *get_prop_struct(unsigned long prop_set,\n\t\t\t\t\t       unsigned long index)\n{\n\tconst struct tee_props *props;\n\tconst struct tee_props *vendor_props;\n\tsize_t size;\n\tsize_t vendor_size;\n\n\tget_prop_set(prop_set, &props, &size, &vendor_props, &vendor_size);\n\n\tif (index < size)\n\t\treturn &(props[index]);\n\tindex -= size;\n\n\tif (index < vendor_size)\n\t\treturn &(vendor_props[index]);\n\n\treturn NULL;\n}\n\n/*\n * prop_set is part of TEE_PROPSET_xxx\n * index is the index in the Property Set to retrieve\n * if name is not NULL, the name of \"index\" property is returned\n * if buf is not NULL, the property is returned\n */\nTEE_Result syscall_get_property(unsigned long prop_set,\n\t\t\t\tunsigned long index,\n\t\t\t\tvoid *name, uint32_t *name_len,\n\t\t\t\tvoid *buf, uint32_t *blen,\n\t\t\t\tuint32_t *prop_type)\n{\n\tstruct tee_ta_session *sess;\n\tTEE_Result res;\n\tTEE_Result res2;\n\tconst struct tee_props *prop;\n\tuint32_t klen;\n\tsize_t klen_size;\n\tuint32_t elen;\n\n\tprop = get_prop_struct(prop_set, index);\n\tif (!prop)\n\t\treturn TEE_ERROR_ITEM_NOT_FOUND;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/* Get the property type */\n\tif (prop_type) {\n\t\tres = tee_svc_copy_to_user(prop_type, &prop->prop_type,\n\t\t\t\t\t   sizeof(*prop_type));\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\n\t/* Get the property */\n\tif (buf && blen) {\n\t\tres = tee_svc_copy_from_user(&klen, blen, sizeof(klen));\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\n\t\tif (prop->get_prop_func) {\n\t\t\tklen_size = klen;\n\t\t\tres = prop->get_prop_func(sess, buf, &klen_size);\n\t\t\tklen = klen_size;\n\t\t\tres2 = tee_svc_copy_to_user(blen, &klen, sizeof(*blen));\n\t\t} else {\n\t\t\tif (klen < prop->len)\n\t\t\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\t\telse\n\t\t\t\tres = tee_svc_copy_to_user(buf, prop->data,\n\t\t\t\t\t\t\t   prop->len);\n\t\t\tres2 = tee_svc_copy_to_user(blen, &prop->len,\n\t\t\t\t\t\t    sizeof(*blen));\n\t\t}\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\treturn res2;\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\n\t/* Get the property name */\n\tif (name && name_len) {\n\t\tres = tee_svc_copy_from_user(&klen, name_len, sizeof(klen));\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\n\t\telen = strlen(prop->name) + 1;\n\n\t\tif (klen < elen)\n\t\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\telse\n\t\t\tres = tee_svc_copy_to_user(name, prop->name, elen);\n\t\tres2 = tee_svc_copy_to_user(name_len, &elen, sizeof(*name_len));\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\treturn res2;\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\n\treturn res;\n}\n\n/*\n * prop_set is part of TEE_PROPSET_xxx\n */\nTEE_Result syscall_get_property_name_to_index(unsigned long prop_set,\n\t\t\t\t\t      void *name,\n\t\t\t\t\t      unsigned long name_len,\n\t\t\t\t\t      uint32_t *index)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\tconst struct tee_props *props;\n\tsize_t size;\n\tconst struct tee_props *vendor_props;\n\tsize_t vendor_size;\n\tchar *kname = 0;\n\tuint32_t i;\n\n\tget_prop_set(prop_set, &props, &size, &vendor_props, &vendor_size);\n\tif (!props)\n\t\treturn TEE_ERROR_ITEM_NOT_FOUND;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tif (!name || !name_len) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto out;\n\t}\n\n\tkname = malloc(name_len);\n\tif (!kname)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tres = tee_svc_copy_from_user(kname, name, name_len);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\tkname[name_len - 1] = 0;\n\n\tres = TEE_ERROR_ITEM_NOT_FOUND;\n\tfor (i = 0; i < size; i++) {\n\t\tif (!strcmp(kname, props[i].name)) {\n\t\t\tres = tee_svc_copy_to_user(index, &i, sizeof(*index));\n\t\t\tgoto out;\n\t\t}\n\t}\n\tfor (i = size; i < size + vendor_size; i++) {\n\t\tif (!strcmp(kname, vendor_props[i - size].name)) {\n\t\t\tres = tee_svc_copy_to_user(index, &i, sizeof(*index));\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tfree(kname);\n\treturn res;\n}\n\nstatic void utee_param_to_param(struct tee_ta_param *p, struct utee_params *up)\n{\n\tsize_t n;\n\tuint32_t types = up->types;\n\n\tp->types = types;\n\tfor (n = 0; n < TEE_NUM_PARAMS; n++) {\n\t\tuintptr_t a = up->vals[n * 2];\n\t\tsize_t b = up->vals[n * 2 + 1];\n\n\t\tswitch (TEE_PARAM_TYPE_GET(types, n)) {\n\t\tcase TEE_PARAM_TYPE_MEMREF_INPUT:\n\t\tcase TEE_PARAM_TYPE_MEMREF_OUTPUT:\n\t\tcase TEE_PARAM_TYPE_MEMREF_INOUT:\n\t\t\tp->u[n].mem.mobj = &mobj_virt;\n\t\t\tp->u[n].mem.offs = a;\n\t\t\tp->u[n].mem.size = b;\n\t\t\tbreak;\n\t\tcase TEE_PARAM_TYPE_VALUE_INPUT:\n\t\tcase TEE_PARAM_TYPE_VALUE_INOUT:\n\t\t\tp->u[n].val.a = a;\n\t\t\tp->u[n].val.b = b;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmemset(&p->u[n], 0, sizeof(p->u[n]));\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic TEE_Result alloc_temp_sec_mem(size_t size, struct mobj **mobj,\n\t\t\t\t     uint8_t **va)\n{\n\t/* Allocate section in secure DDR */\n#ifdef CFG_PAGED_USER_TA\n\t*mobj = mobj_seccpy_shm_alloc(size);\n#else\n\t*mobj = mobj_mm_alloc(mobj_sec_ddr, size, &tee_mm_sec_ddr);\n#endif\n\tif (!*mobj)\n\t\treturn TEE_ERROR_GENERIC;\n\n\t*va = mobj_get_va(*mobj, 0);\n\treturn TEE_SUCCESS;\n}\n\n/*\n * TA invokes some TA with parameter.\n * If some parameters are memory references:\n * - either the memref is inside TA private RAM: TA is not allowed to expose\n *   its private RAM: use a temporary memory buffer and copy the data.\n * - or the memref is not in the TA private RAM:\n *   - if the memref was mapped to the TA, TA is allowed to expose it.\n *   - if so, converts memref virtual address into a physical address.\n */\nstatic TEE_Result tee_svc_copy_param(struct tee_ta_session *sess,\n\t\t\t\t     struct tee_ta_session *called_sess,\n\t\t\t\t     struct utee_params *callee_params,\n\t\t\t\t     struct tee_ta_param *param,\n\t\t\t\t     void *tmp_buf_va[TEE_NUM_PARAMS],\n\t\t\t\t     struct mobj **mobj_tmp)\n{\n\tsize_t n;\n\tTEE_Result res;\n\tsize_t req_mem = 0;\n\tsize_t s;\n\tuint8_t *dst = 0;\n\tbool ta_private_memref[TEE_NUM_PARAMS];\n\tstruct user_ta_ctx *utc = to_user_ta_ctx(sess->ctx);\n\tvoid *va;\n\tsize_t dst_offs;\n\n\t/* fill 'param' input struct with caller params description buffer */\n\tif (!callee_params) {\n\t\tmemset(param, 0, sizeof(*param));\n\t} else {\n\t\tres = tee_mmu_check_access_rights(utc,\n\t\t\tTEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t(uaddr_t)callee_params, sizeof(struct utee_params));\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tutee_param_to_param(param, callee_params);\n\t}\n\n\tif (called_sess && is_pseudo_ta_ctx(called_sess->ctx)) {\n\t\t/* pseudo TA borrows the mapping of the calling TA */\n\t\treturn TEE_SUCCESS;\n\t}\n\n\t/* All mobj in param are of type MOJB_TYPE_VIRT */\n\n\tfor (n = 0; n < TEE_NUM_PARAMS; n++) {\n\n\t\tta_private_memref[n] = false;\n\n\t\tswitch (TEE_PARAM_TYPE_GET(param->types, n)) {\n\t\tcase TEE_PARAM_TYPE_MEMREF_INPUT:\n\t\tcase TEE_PARAM_TYPE_MEMREF_OUTPUT:\n\t\tcase TEE_PARAM_TYPE_MEMREF_INOUT:\n\t\t\tva = (void *)param->u[n].mem.offs;\n\t\t\ts = param->u[n].mem.size;\n\t\t\tif (!va) {\n\t\t\t\tif (s)\n\t\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* uTA cannot expose its private memory */\n\t\t\tif (tee_mmu_is_vbuf_inside_ta_private(utc, va, s)) {\n\n\t\t\t\ts = ROUNDUP(s, sizeof(uint32_t));\n\t\t\t\tif (ADD_OVERFLOW(req_mem, s, &req_mem))\n\t\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t\t\tta_private_memref[n] = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tres = tee_mmu_vbuf_to_mobj_offs(utc, va, s,\n\t\t\t\t\t\t\t&param->u[n].mem.mobj,\n\t\t\t\t\t\t\t&param->u[n].mem.offs);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (req_mem == 0)\n\t\treturn TEE_SUCCESS;\n\n\tres = alloc_temp_sec_mem(req_mem, mobj_tmp, &dst);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tdst_offs = 0;\n\n\tfor (n = 0; n < TEE_NUM_PARAMS; n++) {\n\n\t\tif (!ta_private_memref[n])\n\t\t\tcontinue;\n\n\t\ts = ROUNDUP(param->u[n].mem.size, sizeof(uint32_t));\n\n\t\tswitch (TEE_PARAM_TYPE_GET(param->types, n)) {\n\t\tcase TEE_PARAM_TYPE_MEMREF_INPUT:\n\t\tcase TEE_PARAM_TYPE_MEMREF_INOUT:\n\t\t\tva = (void *)param->u[n].mem.offs;\n\t\t\tif (va) {\n\t\t\t\tres = tee_svc_copy_from_user(dst, va,\n\t\t\t\t\t\tparam->u[n].mem.size);\n\t\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\t\treturn res;\n\t\t\t\tparam->u[n].mem.offs = dst_offs;\n\t\t\t\tparam->u[n].mem.mobj = *mobj_tmp;\n\t\t\t\ttmp_buf_va[n] = dst;\n\t\t\t\tdst += s;\n\t\t\t\tdst_offs += s;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TEE_PARAM_TYPE_MEMREF_OUTPUT:\n\t\t\tva = (void *)param->u[n].mem.offs;\n\t\t\tif (va) {\n\t\t\t\tparam->u[n].mem.offs = dst_offs;\n\t\t\t\tparam->u[n].mem.mobj = *mobj_tmp;\n\t\t\t\ttmp_buf_va[n] = dst;\n\t\t\t\tdst += s;\n\t\t\t\tdst_offs += s;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\treturn TEE_SUCCESS;\n}\n\n/*\n * Back from execution of service: update parameters passed from TA:\n * If some parameters were memory references:\n * - either the memref was temporary: copy back data and update size\n * - or it was the original TA memref: update only the size value.\n */\nstatic TEE_Result tee_svc_update_out_param(\n\t\tstruct tee_ta_param *param,\n\t\tvoid *tmp_buf_va[TEE_NUM_PARAMS],\n\t\tstruct utee_params *usr_param)\n{\n\tsize_t n;\n\tuint64_t *vals = usr_param->vals;\n\n\tfor (n = 0; n < TEE_NUM_PARAMS; n++) {\n\t\tswitch (TEE_PARAM_TYPE_GET(param->types, n)) {\n\t\tcase TEE_PARAM_TYPE_MEMREF_OUTPUT:\n\t\tcase TEE_PARAM_TYPE_MEMREF_INOUT:\n\t\t\t/*\n\t\t\t * Memory copy is only needed if there's a temporary\n\t\t\t * buffer involved, tmp_buf_va[n] is only update if\n\t\t\t * a temporary buffer is used. Otherwise only the\n\t\t\t * size needs to be updated.\n\t\t\t */\n\t\t\tif (tmp_buf_va[n] &&\n\t\t\t    param->u[n].mem.size <= vals[n * 2 + 1]) {\n\t\t\t\tvoid *src = tmp_buf_va[n];\n\t\t\t\tvoid *dst = (void *)(uintptr_t)vals[n * 2];\n\t\t\t\tTEE_Result res;\n\n\t\t\t\tres = tee_svc_copy_to_user(dst, src,\n\t\t\t\t\t\t param->u[n].mem.size);\n\t\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\t\treturn res;\n\n\t\t\t}\n\t\t\tusr_param->vals[n * 2 + 1] = param->u[n].mem.size;\n\t\t\tbreak;\n\n\t\tcase TEE_PARAM_TYPE_VALUE_OUTPUT:\n\t\tcase TEE_PARAM_TYPE_VALUE_INOUT:\n\t\t\tvals[n * 2] = param->u[n].val.a;\n\t\t\tvals[n * 2 + 1] = param->u[n].val.b;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\treturn TEE_SUCCESS;\n}\n\n/* Called when a TA calls an OpenSession on another TA */\nTEE_Result syscall_open_ta_session(const TEE_UUID *dest,\n\t\t\tunsigned long cancel_req_to,\n\t\t\tstruct utee_params *usr_param, uint32_t *ta_sess,\n\t\t\tuint32_t *ret_orig)\n{\n\tTEE_Result res;\n\tuint32_t ret_o = TEE_ORIGIN_TEE;\n\tstruct tee_ta_session *s = NULL;\n\tstruct tee_ta_session *sess;\n\tstruct mobj *mobj_param = NULL;\n\tTEE_UUID *uuid = malloc(sizeof(TEE_UUID));\n\tstruct tee_ta_param *param = malloc(sizeof(struct tee_ta_param));\n\tTEE_Identity *clnt_id = malloc(sizeof(TEE_Identity));\n\tvoid *tmp_buf_va[TEE_NUM_PARAMS] = { NULL };\n\tstruct user_ta_ctx *utc;\n\n\tif (uuid == NULL || param == NULL || clnt_id == NULL) {\n\t\tres = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto out_free_only;\n\t}\n\n\tmemset(param, 0, sizeof(struct tee_ta_param));\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out_free_only;\n\tutc = to_user_ta_ctx(sess->ctx);\n\n\tres = tee_svc_copy_from_user(uuid, dest, sizeof(TEE_UUID));\n\tif (res != TEE_SUCCESS)\n\t\tgoto function_exit;\n\n\tclnt_id->login = TEE_LOGIN_TRUSTED_APP;\n\tmemcpy(&clnt_id->uuid, &sess->ctx->uuid, sizeof(TEE_UUID));\n\n\tres = tee_svc_copy_param(sess, NULL, usr_param, param, tmp_buf_va,\n\t\t\t\t &mobj_param);\n\tif (res != TEE_SUCCESS)\n\t\tgoto function_exit;\n\n\tres = tee_ta_open_session(&ret_o, &s, &utc->open_sessions, uuid,\n\t\t\t\t  clnt_id, cancel_req_to, param);\n\ttee_mmu_set_ctx(&utc->ctx);\n\tif (res != TEE_SUCCESS)\n\t\tgoto function_exit;\n\n\tres = tee_svc_update_out_param(param, tmp_buf_va, usr_param);\n\nfunction_exit:\n\tmobj_free(mobj_param);\n\tif (res == TEE_SUCCESS)\n\t\ttee_svc_copy_kaddr_to_uref(ta_sess, s);\n\ttee_svc_copy_to_user(ret_orig, &ret_o, sizeof(ret_o));\n\nout_free_only:\n\tfree(param);\n\tfree(uuid);\n\tfree(clnt_id);\n\treturn res;\n}\n\nTEE_Result syscall_close_ta_session(unsigned long ta_sess)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\tTEE_Identity clnt_id;\n\tstruct tee_ta_session *s = tee_svc_uref_to_kaddr(ta_sess);\n\tstruct user_ta_ctx *utc;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tutc = to_user_ta_ctx(sess->ctx);\n\n\tclnt_id.login = TEE_LOGIN_TRUSTED_APP;\n\tmemcpy(&clnt_id.uuid, &sess->ctx->uuid, sizeof(TEE_UUID));\n\n\treturn tee_ta_close_session(s, &utc->open_sessions, &clnt_id);\n}\n\nTEE_Result syscall_invoke_ta_command(unsigned long ta_sess,\n\t\t\tunsigned long cancel_req_to, unsigned long cmd_id,\n\t\t\tstruct utee_params *usr_param, uint32_t *ret_orig)\n{\n\tTEE_Result res;\n\tTEE_Result res2;\n\tuint32_t ret_o = TEE_ORIGIN_TEE;\n\tstruct tee_ta_param param = { 0 };\n\tTEE_Identity clnt_id;\n\tstruct tee_ta_session *sess;\n\tstruct tee_ta_session *called_sess;\n\tstruct mobj *mobj_param = NULL;\n\tvoid *tmp_buf_va[TEE_NUM_PARAMS] = { NULL };\n\tstruct user_ta_ctx *utc;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tutc = to_user_ta_ctx(sess->ctx);\n\n\tcalled_sess = tee_ta_get_session(\n\t\t\t\t(vaddr_t)tee_svc_uref_to_kaddr(ta_sess), true,\n\t\t\t\t&utc->open_sessions);\n\tif (!called_sess)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tclnt_id.login = TEE_LOGIN_TRUSTED_APP;\n\tmemcpy(&clnt_id.uuid, &sess->ctx->uuid, sizeof(TEE_UUID));\n\n\tres = tee_svc_copy_param(sess, called_sess, usr_param, &param,\n\t\t\t\t tmp_buf_va, &mobj_param);\n\tif (res != TEE_SUCCESS)\n\t\tgoto function_exit;\n\n\tres = tee_ta_invoke_command(&ret_o, called_sess, &clnt_id,\n\t\t\t\t    cancel_req_to, cmd_id, &param);\n\n\tres2 = tee_svc_update_out_param(&param, tmp_buf_va, usr_param);\n\tif (res2 != TEE_SUCCESS) {\n\t\t/*\n\t\t * Spec for TEE_InvokeTACommand() says:\n\t\t * \"If the return origin is different from\n\t\t * TEE_ORIGIN_TRUSTED_APP, then the function has failed\n\t\t * before it could reach the destination Trusted\n\t\t * Application.\"\n\t\t *\n\t\t * But if we can't update params to the caller we have no\n\t\t * choice we need to return some error to indicate that\n\t\t * parameters aren't updated as expected.\n\t\t */\n\t\tret_o = TEE_ORIGIN_TEE;\n\t\tres = res2;\n\t}\n\nfunction_exit:\n\ttee_ta_put_session(called_sess);\n\tmobj_free(mobj_param);\n\tif (ret_orig)\n\t\ttee_svc_copy_to_user(ret_orig, &ret_o, sizeof(ret_o));\n\treturn res;\n}\n\nTEE_Result syscall_check_access_rights(unsigned long flags, const void *buf,\n\t\t\t\t       size_t len)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *s;\n\n\tres = tee_ta_get_current_session(&s);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\treturn tee_mmu_check_access_rights(to_user_ta_ctx(s->ctx), flags,\n\t\t\t\t\t   (uaddr_t)buf, len);\n}\n\nTEE_Result tee_svc_copy_from_user(void *kaddr, const void *uaddr, size_t len)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *s;\n\n\tres = tee_ta_get_current_session(&s);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(s->ctx),\n\t\t\t\t\tTEE_MEMORY_ACCESS_READ |\n\t\t\t\t\tTEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t(uaddr_t)uaddr, len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tmemcpy(kaddr, uaddr, len);\n\treturn TEE_SUCCESS;\n}\n\nTEE_Result tee_svc_copy_to_user(void *uaddr, const void *kaddr, size_t len)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *s;\n\n\tres = tee_ta_get_current_session(&s);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(s->ctx),\n\t\t\t\t\tTEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\tTEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t(uaddr_t)uaddr, len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tmemcpy(uaddr, kaddr, len);\n\treturn TEE_SUCCESS;\n}\n\nTEE_Result tee_svc_copy_kaddr_to_uref(uint32_t *uref, void *kaddr)\n{\n\tuint32_t ref = tee_svc_kaddr_to_uref(kaddr);\n\n\treturn tee_svc_copy_to_user(uref, &ref, sizeof(ref));\n}\n\nTEE_Result syscall_get_cancellation_flag(uint32_t *cancel)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *s = NULL;\n\tuint32_t c;\n\n\tres = tee_ta_get_current_session(&s);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tc = tee_ta_session_is_cancelled(s, NULL);\n\n\treturn tee_svc_copy_to_user(cancel, &c, sizeof(c));\n}\n\nTEE_Result syscall_unmask_cancellation(uint32_t *old_mask)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *s = NULL;\n\tuint32_t m;\n\n\tres = tee_ta_get_current_session(&s);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tm = s->cancel_mask;\n\ts->cancel_mask = false;\n\treturn tee_svc_copy_to_user(old_mask, &m, sizeof(m));\n}\n\nTEE_Result syscall_mask_cancellation(uint32_t *old_mask)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *s = NULL;\n\tuint32_t m;\n\n\tres = tee_ta_get_current_session(&s);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tm = s->cancel_mask;\n\ts->cancel_mask = true;\n\treturn tee_svc_copy_to_user(old_mask, &m, sizeof(m));\n}\n\nTEE_Result syscall_wait(unsigned long timeout)\n{\n\tTEE_Result res = TEE_SUCCESS;\n\tuint32_t mytime = 0;\n\tstruct tee_ta_session *s;\n\tTEE_Time base_time;\n\tTEE_Time current_time;\n\n\tres = tee_ta_get_current_session(&s);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_time_get_sys_time(&base_time);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\twhile (true) {\n\t\tres = tee_time_get_sys_time(&current_time);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\n\t\tif (tee_ta_session_is_cancelled(s, &current_time))\n\t\t\treturn TEE_ERROR_CANCEL;\n\n\t\tmytime = (current_time.seconds - base_time.seconds) * 1000 +\n\t\t    (int)current_time.millis - (int)base_time.millis;\n\t\tif (mytime >= timeout)\n\t\t\treturn TEE_SUCCESS;\n\n\t\ttee_time_wait(timeout - mytime);\n\t}\n\n\treturn res;\n}\n\nTEE_Result syscall_get_time(unsigned long cat, TEE_Time *mytime)\n{\n\tTEE_Result res, res2;\n\tstruct tee_ta_session *s = NULL;\n\tTEE_Time t;\n\n\tres = tee_ta_get_current_session(&s);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tswitch (cat) {\n\tcase UTEE_TIME_CAT_SYSTEM:\n\t\tres = tee_time_get_sys_time(&t);\n\t\tbreak;\n\tcase UTEE_TIME_CAT_TA_PERSISTENT:\n\t\tres = tee_time_get_ta_time((const void *)&s->ctx->uuid, &t);\n\t\tbreak;\n\tcase UTEE_TIME_CAT_REE:\n\t\tres = tee_time_get_ree_time(&t);\n\t\tbreak;\n\tdefault:\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tbreak;\n\t}\n\n\tif (res == TEE_SUCCESS || res == TEE_ERROR_OVERFLOW) {\n\t\tres2 = tee_svc_copy_to_user(mytime, &t, sizeof(t));\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\tres = res2;\n\t}\n\n\treturn res;\n}\n\nTEE_Result syscall_set_ta_time(const TEE_Time *mytime)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *s = NULL;\n\tTEE_Time t;\n\n\tres = tee_ta_get_current_session(&s);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_copy_from_user(&t, mytime, sizeof(t));\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\treturn tee_time_set_ta_time((const void *)&s->ctx->uuid, &t);\n}\n"], "fixing_code": ["// SPDX-License-Identifier: BSD-2-Clause\n/*\n * Copyright (c) 2014, STMicroelectronics International N.V.\n */\n#include <util.h>\n#include <kernel/tee_common_otp.h>\n#include <kernel/tee_common.h>\n#include <tee_api_types.h>\n#include <kernel/tee_ta_manager.h>\n#include <utee_types.h>\n#include <tee/tee_svc.h>\n#include <tee/tee_cryp_utl.h>\n#include <mm/tee_mmu.h>\n#include <mm/tee_mm.h>\n#include <mm/core_memprot.h>\n#include <kernel/tee_time.h>\n\n#include <user_ta_header.h>\n#include <trace.h>\n#include <kernel/trace_ta.h>\n#include <kernel/chip_services.h>\n#include <kernel/pseudo_ta.h>\n#include <mm/mobj.h>\n\nvaddr_t tee_svc_uref_base;\n\nvoid syscall_log(const void *buf __maybe_unused, size_t len __maybe_unused)\n{\n#ifdef CFG_TEE_CORE_TA_TRACE\n\tchar *kbuf;\n\n\tif (len == 0)\n\t\treturn;\n\n\tkbuf = malloc(len + 1);\n\tif (kbuf == NULL)\n\t\treturn;\n\n\tif (tee_svc_copy_from_user(kbuf, buf, len) == TEE_SUCCESS) {\n\t\tkbuf[len] = '\\0';\n\t\ttrace_ext_puts(kbuf);\n\t}\n\n\tfree(kbuf);\n#endif\n}\n\nTEE_Result syscall_not_supported(void)\n{\n\treturn TEE_ERROR_NOT_SUPPORTED;\n}\n\n/* Configuration properties */\n/* API implementation version */\nstatic const char api_vers[] = TO_STR(CFG_TEE_API_VERSION);\n\n/* Implementation description (implementation-dependent) */\nstatic const char descr[] = TO_STR(CFG_TEE_IMPL_DESCR);\n\n/*\n * TA persistent time protection level\n * 100: Persistent time based on an REE-controlled real-time clock\n * and on the TEE Trusted Storage for the storage of origins (default).\n * 1000: Persistent time based on a TEE-controlled real-time clock\n * and the TEE Trusted Storage.\n * The real-time clock MUST be out of reach of software attacks\n * from the REE.\n */\nstatic const uint32_t ta_time_prot_lvl = 100;\n\n/* Elliptic Curve Cryptographic support */\n#ifdef CFG_CRYPTO_ECC\nstatic const bool crypto_ecc_en = 1;\n#else\nstatic const bool crypto_ecc_en;\n#endif\n\n/*\n * Trusted storage anti rollback protection level\n * 0 (or missing): No antirollback protection (default)\n * 100: Antirollback enforced at REE level\n * 1000: Antirollback TEE-controlled hardware\n */\n#ifdef CFG_RPMB_FS\nstatic const uint32_t ts_antiroll_prot_lvl = 1000;\n#else\nstatic const uint32_t ts_antiroll_prot_lvl;\n#endif\n\n/* Trusted OS implementation version */\nstatic const char trustedos_impl_version[] = TO_STR(TEE_IMPL_VERSION);\n\n/* Trusted OS implementation version (binary value) */\nstatic const uint32_t trustedos_impl_bin_version; /* 0 by default */\n\n/* Trusted OS implementation manufacturer name */\nstatic const char trustedos_manufacturer[] = TO_STR(CFG_TEE_MANUFACTURER);\n\n/* Trusted firmware version */\nstatic const char fw_impl_version[] = TO_STR(CFG_TEE_FW_IMPL_VERSION);\n\n/* Trusted firmware version (binary value) */\nstatic const uint32_t fw_impl_bin_version; /* 0 by default */\n\n/* Trusted firmware manufacturer name */\nstatic const char fw_manufacturer[] = TO_STR(CFG_TEE_FW_MANUFACTURER);\n\nstatic TEE_Result get_prop_tee_dev_id(struct tee_ta_session *sess __unused,\n\t\t\t\t      void *buf, size_t *blen)\n{\n\tTEE_Result res;\n\tTEE_UUID uuid;\n\tconst size_t nslen = 5;\n\tuint8_t data[5 + FVR_DIE_ID_NUM_REGS * sizeof(uint32_t)] = {\n\t    'O', 'P', 'T', 'E', 'E' };\n\n\tif (*blen < sizeof(uuid)) {\n\t\t*blen = sizeof(uuid);\n\t\treturn TEE_ERROR_SHORT_BUFFER;\n\t}\n\t*blen = sizeof(uuid);\n\n\tif (tee_otp_get_die_id(data + nslen, sizeof(data) - nslen))\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tres = tee_hash_createdigest(TEE_ALG_SHA256, data, sizeof(data),\n\t\t\t\t    (uint8_t *)&uuid, sizeof(uuid));\n\tif (res != TEE_SUCCESS)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t/*\n\t * Changes the random value into and UUID as specifiec\n\t * in RFC 4122. The magic values are from the example\n\t * code in the RFC.\n\t *\n\t * TEE_UUID is defined slightly different from the RFC,\n\t * but close enough for our purpose.\n\t */\n\n\tuuid.timeHiAndVersion &= 0x0fff;\n\tuuid.timeHiAndVersion |= 5 << 12;\n\n\t/* uuid.clock_seq_hi_and_reserved in the RFC */\n\tuuid.clockSeqAndNode[0] &= 0x3f;\n\tuuid.clockSeqAndNode[0] |= 0x80;\n\n\treturn tee_svc_copy_to_user(buf, &uuid, sizeof(TEE_UUID));\n}\n\nstatic TEE_Result get_prop_tee_sys_time_prot_level(\n\t\t\tstruct tee_ta_session *sess __unused,\n\t\t\tvoid *buf, size_t *blen)\n{\n\tuint32_t prot;\n\n\tif (*blen < sizeof(prot)) {\n\t\t*blen = sizeof(prot);\n\t\treturn TEE_ERROR_SHORT_BUFFER;\n\t}\n\t*blen = sizeof(prot);\n\tprot = tee_time_get_sys_time_protection_level();\n\treturn tee_svc_copy_to_user(buf, &prot, sizeof(prot));\n}\n\nstatic TEE_Result get_prop_client_id(struct tee_ta_session *sess __unused,\n\t\t\t\t     void *buf, size_t *blen)\n{\n\tif (*blen < sizeof(TEE_Identity)) {\n\t\t*blen = sizeof(TEE_Identity);\n\t\treturn TEE_ERROR_SHORT_BUFFER;\n\t}\n\t*blen = sizeof(TEE_Identity);\n\treturn tee_svc_copy_to_user(buf, &sess->clnt_id, sizeof(TEE_Identity));\n}\n\nstatic TEE_Result get_prop_ta_app_id(struct tee_ta_session *sess,\n\t\t\t\t     void *buf, size_t *blen)\n{\n\tif (*blen < sizeof(TEE_UUID)) {\n\t\t*blen = sizeof(TEE_UUID);\n\t\treturn TEE_ERROR_SHORT_BUFFER;\n\t}\n\t*blen = sizeof(TEE_UUID);\n\treturn tee_svc_copy_to_user(buf, &sess->ctx->uuid, sizeof(TEE_UUID));\n}\n\n/* Properties of the set TEE_PROPSET_CURRENT_CLIENT */\nconst struct tee_props tee_propset_client[] = {\n\t{\n\t\t.name = \"gpd.client.identity\",\n\t\t.prop_type = USER_TA_PROP_TYPE_IDENTITY,\n\t\t.get_prop_func = get_prop_client_id\n\t},\n};\n\n/* Properties of the set TEE_PROPSET_CURRENT_TA */\nconst struct tee_props tee_propset_ta[] = {\n\t{\n\t\t.name = \"gpd.ta.appID\",\n\t\t.prop_type = USER_TA_PROP_TYPE_UUID,\n\t\t.get_prop_func = get_prop_ta_app_id\n\t},\n\n\t/*\n\t * Following properties are processed directly in libutee:\n\t *\tTA_PROP_STR_SINGLE_INSTANCE\n\t *\tTA_PROP_STR_MULTI_SESSION\n\t *\tTA_PROP_STR_KEEP_ALIVE\n\t *\tTA_PROP_STR_DATA_SIZE\n\t *\tTA_PROP_STR_STACK_SIZE\n\t *\tTA_PROP_STR_VERSION\n\t *\tTA_PROP_STR_DESCRIPTION\n\t *\tUSER_TA_PROP_TYPE_STRING,\n\t *\tTA_DESCRIPTION\n\t */\n};\n\n/* Properties of the set TEE_PROPSET_TEE_IMPLEMENTATION */\nconst struct tee_props tee_propset_tee[] = {\n\t{\n\t\t.name = \"gpd.tee.apiversion\",\n\t\t.prop_type = USER_TA_PROP_TYPE_STRING,\n\t\t.data = api_vers,\n\t\t.len = sizeof(api_vers),\n\t},\n\t{\n\t\t.name = \"gpd.tee.description\",\n\t\t.prop_type = USER_TA_PROP_TYPE_STRING,\n\t\t.data = descr, .len = sizeof(descr)\n\t},\n\t{\n\t\t.name = \"gpd.tee.deviceID\",\n\t\t.prop_type = USER_TA_PROP_TYPE_UUID,\n\t\t.get_prop_func = get_prop_tee_dev_id\n\t},\n\t{\n\t\t.name = \"gpd.tee.systemTime.protectionLevel\",\n\t\t.prop_type = USER_TA_PROP_TYPE_U32,\n\t\t.get_prop_func = get_prop_tee_sys_time_prot_level\n\t},\n\t{\n\t\t.name = \"gpd.tee.TAPersistentTime.protectionLevel\",\n\t\t.prop_type = USER_TA_PROP_TYPE_U32,\n\t\t.data = &ta_time_prot_lvl,\n\t\t.len = sizeof(ta_time_prot_lvl)\n\t},\n\t{\n\t\t.name = \"gpd.tee.cryptography.ecc\",\n\t\t.prop_type = USER_TA_PROP_TYPE_BOOL,\n\t\t.data = &crypto_ecc_en,\n\t\t.len = sizeof(crypto_ecc_en)\n\t},\n\t{\n\t\t.name = \"gpd.tee.trustedStorage.antiRollback.protectionLevel\",\n\t\t.prop_type = USER_TA_PROP_TYPE_U32,\n\t\t.data = &ts_antiroll_prot_lvl,\n\t\t.len = sizeof(ts_antiroll_prot_lvl)\n\t},\n\t{\n\t\t.name = \"gpd.tee.trustedos.implementation.version\",\n\t\t.prop_type = USER_TA_PROP_TYPE_STRING,\n\t\t.data = trustedos_impl_version,\n\t\t.len = sizeof(trustedos_impl_version)\n\t},\n\t{\n\t\t.name = \"gpd.tee.trustedos.implementation.binaryversion\",\n\t\t.prop_type = USER_TA_PROP_TYPE_U32,\n\t\t.data = &trustedos_impl_bin_version,\n\t\t.len = sizeof(trustedos_impl_bin_version)\n\t},\n\t{\n\t\t.name = \"gpd.tee.trustedos.manufacturer\",\n\t\t.prop_type = USER_TA_PROP_TYPE_STRING,\n\t\t.data = trustedos_manufacturer,\n\t\t.len = sizeof(trustedos_manufacturer)\n\t},\n\t{\n\t\t.name = \"gpd.tee.firmware.implementation.version\",\n\t\t.prop_type = USER_TA_PROP_TYPE_STRING,\n\t\t.data = fw_impl_version,\n\t\t.len = sizeof(fw_impl_version)\n\t},\n\t{\n\t\t.name = \"gpd.tee.firmware.implementation.binaryversion\",\n\t\t.prop_type = USER_TA_PROP_TYPE_U32,\n\t\t.data = &fw_impl_bin_version,\n\t\t.len = sizeof(fw_impl_bin_version)\n\t},\n\t{\n\t\t.name = \"gpd.tee.firmware.manufacturer\",\n\t\t.prop_type = USER_TA_PROP_TYPE_STRING,\n\t\t.data = fw_manufacturer,\n\t\t.len = sizeof(fw_manufacturer)\n\t},\n\n\t/*\n\t * Following properties are processed directly in libutee:\n\t *\tgpd.tee.arith.maxBigIntSize\n\t */\n};\n\n__weak const struct tee_vendor_props vendor_props_client;\n__weak const struct tee_vendor_props vendor_props_ta;\n__weak const struct tee_vendor_props vendor_props_tee;\n\nstatic void get_prop_set(unsigned long prop_set,\n\t\t\t const struct tee_props **props,\n\t\t\t size_t *size,\n\t\t\t const struct tee_props **vendor_props,\n\t\t\t size_t *vendor_size)\n{\n\tif ((TEE_PropSetHandle)prop_set == TEE_PROPSET_CURRENT_CLIENT) {\n\t\t*props = tee_propset_client;\n\t\t*size = ARRAY_SIZE(tee_propset_client);\n\t\t*vendor_props = vendor_props_client.props;\n\t\t*vendor_size = vendor_props_client.len;\n\t} else if ((TEE_PropSetHandle)prop_set == TEE_PROPSET_CURRENT_TA) {\n\t\t*props = tee_propset_ta;\n\t\t*size = ARRAY_SIZE(tee_propset_ta);\n\t\t*vendor_props = vendor_props_ta.props;\n\t\t*vendor_size = vendor_props_ta.len;\n\t} else if ((TEE_PropSetHandle)prop_set ==\n\t\t   TEE_PROPSET_TEE_IMPLEMENTATION) {\n\t\t*props = tee_propset_tee;\n\t\t*size = ARRAY_SIZE(tee_propset_tee);\n\t\t*vendor_props = vendor_props_tee.props;\n\t\t*vendor_size = vendor_props_tee.len;\n\t} else {\n\t\t*props = NULL;\n\t\t*size = 0;\n\t\t*vendor_props = NULL;\n\t\t*vendor_size = 0;\n\t}\n}\n\nstatic const struct tee_props *get_prop_struct(unsigned long prop_set,\n\t\t\t\t\t       unsigned long index)\n{\n\tconst struct tee_props *props;\n\tconst struct tee_props *vendor_props;\n\tsize_t size;\n\tsize_t vendor_size;\n\n\tget_prop_set(prop_set, &props, &size, &vendor_props, &vendor_size);\n\n\tif (index < size)\n\t\treturn &(props[index]);\n\tindex -= size;\n\n\tif (index < vendor_size)\n\t\treturn &(vendor_props[index]);\n\n\treturn NULL;\n}\n\n/*\n * prop_set is part of TEE_PROPSET_xxx\n * index is the index in the Property Set to retrieve\n * if name is not NULL, the name of \"index\" property is returned\n * if buf is not NULL, the property is returned\n */\nTEE_Result syscall_get_property(unsigned long prop_set,\n\t\t\t\tunsigned long index,\n\t\t\t\tvoid *name, uint32_t *name_len,\n\t\t\t\tvoid *buf, uint32_t *blen,\n\t\t\t\tuint32_t *prop_type)\n{\n\tstruct tee_ta_session *sess;\n\tTEE_Result res;\n\tTEE_Result res2;\n\tconst struct tee_props *prop;\n\tuint32_t klen;\n\tsize_t klen_size;\n\tuint32_t elen;\n\n\tprop = get_prop_struct(prop_set, index);\n\tif (!prop)\n\t\treturn TEE_ERROR_ITEM_NOT_FOUND;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/* Get the property type */\n\tif (prop_type) {\n\t\tres = tee_svc_copy_to_user(prop_type, &prop->prop_type,\n\t\t\t\t\t   sizeof(*prop_type));\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\n\t/* Get the property */\n\tif (buf && blen) {\n\t\tres = tee_svc_copy_from_user(&klen, blen, sizeof(klen));\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\n\t\tif (prop->get_prop_func) {\n\t\t\tklen_size = klen;\n\t\t\tres = prop->get_prop_func(sess, buf, &klen_size);\n\t\t\tklen = klen_size;\n\t\t\tres2 = tee_svc_copy_to_user(blen, &klen, sizeof(*blen));\n\t\t} else {\n\t\t\tif (klen < prop->len)\n\t\t\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\t\telse\n\t\t\t\tres = tee_svc_copy_to_user(buf, prop->data,\n\t\t\t\t\t\t\t   prop->len);\n\t\t\tres2 = tee_svc_copy_to_user(blen, &prop->len,\n\t\t\t\t\t\t    sizeof(*blen));\n\t\t}\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\treturn res2;\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\n\t/* Get the property name */\n\tif (name && name_len) {\n\t\tres = tee_svc_copy_from_user(&klen, name_len, sizeof(klen));\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\n\t\telen = strlen(prop->name) + 1;\n\n\t\tif (klen < elen)\n\t\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\telse\n\t\t\tres = tee_svc_copy_to_user(name, prop->name, elen);\n\t\tres2 = tee_svc_copy_to_user(name_len, &elen, sizeof(*name_len));\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\treturn res2;\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\n\treturn res;\n}\n\n/*\n * prop_set is part of TEE_PROPSET_xxx\n */\nTEE_Result syscall_get_property_name_to_index(unsigned long prop_set,\n\t\t\t\t\t      void *name,\n\t\t\t\t\t      unsigned long name_len,\n\t\t\t\t\t      uint32_t *index)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\tconst struct tee_props *props;\n\tsize_t size;\n\tconst struct tee_props *vendor_props;\n\tsize_t vendor_size;\n\tchar *kname = 0;\n\tuint32_t i;\n\n\tget_prop_set(prop_set, &props, &size, &vendor_props, &vendor_size);\n\tif (!props)\n\t\treturn TEE_ERROR_ITEM_NOT_FOUND;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tif (!name || !name_len) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto out;\n\t}\n\n\tkname = malloc(name_len);\n\tif (!kname)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tres = tee_svc_copy_from_user(kname, name, name_len);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\tkname[name_len - 1] = 0;\n\n\tres = TEE_ERROR_ITEM_NOT_FOUND;\n\tfor (i = 0; i < size; i++) {\n\t\tif (!strcmp(kname, props[i].name)) {\n\t\t\tres = tee_svc_copy_to_user(index, &i, sizeof(*index));\n\t\t\tgoto out;\n\t\t}\n\t}\n\tfor (i = size; i < size + vendor_size; i++) {\n\t\tif (!strcmp(kname, vendor_props[i - size].name)) {\n\t\t\tres = tee_svc_copy_to_user(index, &i, sizeof(*index));\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tfree(kname);\n\treturn res;\n}\n\nstatic TEE_Result utee_param_to_param(struct user_ta_ctx *utc,\n\t\t\t\t      struct tee_ta_param *p,\n\t\t\t\t      struct utee_params *up)\n{\n\tsize_t n;\n\tuint32_t types = up->types;\n\n\tp->types = types;\n\tfor (n = 0; n < TEE_NUM_PARAMS; n++) {\n\t\tuintptr_t a = up->vals[n * 2];\n\t\tsize_t b = up->vals[n * 2 + 1];\n\t\tuint32_t flags = TEE_MEMORY_ACCESS_READ |\n\t\t\t\t TEE_MEMORY_ACCESS_ANY_OWNER;\n\n\t\tswitch (TEE_PARAM_TYPE_GET(types, n)) {\n\t\tcase TEE_PARAM_TYPE_MEMREF_OUTPUT:\n\t\tcase TEE_PARAM_TYPE_MEMREF_INOUT:\n\t\t\tflags |= TEE_MEMORY_ACCESS_WRITE;\n\t\t\t/*FALLTHROUGH*/\n\t\tcase TEE_PARAM_TYPE_MEMREF_INPUT:\n\t\t\tp->u[n].mem.mobj = &mobj_virt;\n\t\t\tp->u[n].mem.offs = a;\n\t\t\tp->u[n].mem.size = b;\n\t\t\tif (tee_mmu_check_access_rights(utc, flags, a, b))\n\t\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t\t\tbreak;\n\t\tcase TEE_PARAM_TYPE_VALUE_INPUT:\n\t\tcase TEE_PARAM_TYPE_VALUE_INOUT:\n\t\t\tp->u[n].val.a = a;\n\t\t\tp->u[n].val.b = b;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmemset(&p->u[n], 0, sizeof(p->u[n]));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result alloc_temp_sec_mem(size_t size, struct mobj **mobj,\n\t\t\t\t     uint8_t **va)\n{\n\t/* Allocate section in secure DDR */\n#ifdef CFG_PAGED_USER_TA\n\t*mobj = mobj_seccpy_shm_alloc(size);\n#else\n\t*mobj = mobj_mm_alloc(mobj_sec_ddr, size, &tee_mm_sec_ddr);\n#endif\n\tif (!*mobj)\n\t\treturn TEE_ERROR_GENERIC;\n\n\t*va = mobj_get_va(*mobj, 0);\n\treturn TEE_SUCCESS;\n}\n\n/*\n * TA invokes some TA with parameter.\n * If some parameters are memory references:\n * - either the memref is inside TA private RAM: TA is not allowed to expose\n *   its private RAM: use a temporary memory buffer and copy the data.\n * - or the memref is not in the TA private RAM:\n *   - if the memref was mapped to the TA, TA is allowed to expose it.\n *   - if so, converts memref virtual address into a physical address.\n */\nstatic TEE_Result tee_svc_copy_param(struct tee_ta_session *sess,\n\t\t\t\t     struct tee_ta_session *called_sess,\n\t\t\t\t     struct utee_params *callee_params,\n\t\t\t\t     struct tee_ta_param *param,\n\t\t\t\t     void *tmp_buf_va[TEE_NUM_PARAMS],\n\t\t\t\t     struct mobj **mobj_tmp)\n{\n\tsize_t n;\n\tTEE_Result res;\n\tsize_t req_mem = 0;\n\tsize_t s;\n\tuint8_t *dst = 0;\n\tbool ta_private_memref[TEE_NUM_PARAMS];\n\tstruct user_ta_ctx *utc = to_user_ta_ctx(sess->ctx);\n\tvoid *va;\n\tsize_t dst_offs;\n\n\t/* fill 'param' input struct with caller params description buffer */\n\tif (!callee_params) {\n\t\tmemset(param, 0, sizeof(*param));\n\t} else {\n\t\tres = tee_mmu_check_access_rights(utc,\n\t\t\tTEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t(uaddr_t)callee_params, sizeof(struct utee_params));\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tres = utee_param_to_param(utc, param, callee_params);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\n\tif (called_sess && is_pseudo_ta_ctx(called_sess->ctx)) {\n\t\t/* pseudo TA borrows the mapping of the calling TA */\n\t\treturn TEE_SUCCESS;\n\t}\n\n\t/* All mobj in param are of type MOJB_TYPE_VIRT */\n\n\tfor (n = 0; n < TEE_NUM_PARAMS; n++) {\n\n\t\tta_private_memref[n] = false;\n\n\t\tswitch (TEE_PARAM_TYPE_GET(param->types, n)) {\n\t\tcase TEE_PARAM_TYPE_MEMREF_INPUT:\n\t\tcase TEE_PARAM_TYPE_MEMREF_OUTPUT:\n\t\tcase TEE_PARAM_TYPE_MEMREF_INOUT:\n\t\t\tva = (void *)param->u[n].mem.offs;\n\t\t\ts = param->u[n].mem.size;\n\t\t\tif (!va) {\n\t\t\t\tif (s)\n\t\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* uTA cannot expose its private memory */\n\t\t\tif (tee_mmu_is_vbuf_inside_ta_private(utc, va, s)) {\n\n\t\t\t\ts = ROUNDUP(s, sizeof(uint32_t));\n\t\t\t\tif (ADD_OVERFLOW(req_mem, s, &req_mem))\n\t\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t\t\tta_private_memref[n] = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tres = tee_mmu_vbuf_to_mobj_offs(utc, va, s,\n\t\t\t\t\t\t\t&param->u[n].mem.mobj,\n\t\t\t\t\t\t\t&param->u[n].mem.offs);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (req_mem == 0)\n\t\treturn TEE_SUCCESS;\n\n\tres = alloc_temp_sec_mem(req_mem, mobj_tmp, &dst);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tdst_offs = 0;\n\n\tfor (n = 0; n < TEE_NUM_PARAMS; n++) {\n\n\t\tif (!ta_private_memref[n])\n\t\t\tcontinue;\n\n\t\ts = ROUNDUP(param->u[n].mem.size, sizeof(uint32_t));\n\n\t\tswitch (TEE_PARAM_TYPE_GET(param->types, n)) {\n\t\tcase TEE_PARAM_TYPE_MEMREF_INPUT:\n\t\tcase TEE_PARAM_TYPE_MEMREF_INOUT:\n\t\t\tva = (void *)param->u[n].mem.offs;\n\t\t\tif (va) {\n\t\t\t\tres = tee_svc_copy_from_user(dst, va,\n\t\t\t\t\t\tparam->u[n].mem.size);\n\t\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\t\treturn res;\n\t\t\t\tparam->u[n].mem.offs = dst_offs;\n\t\t\t\tparam->u[n].mem.mobj = *mobj_tmp;\n\t\t\t\ttmp_buf_va[n] = dst;\n\t\t\t\tdst += s;\n\t\t\t\tdst_offs += s;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TEE_PARAM_TYPE_MEMREF_OUTPUT:\n\t\t\tva = (void *)param->u[n].mem.offs;\n\t\t\tif (va) {\n\t\t\t\tparam->u[n].mem.offs = dst_offs;\n\t\t\t\tparam->u[n].mem.mobj = *mobj_tmp;\n\t\t\t\ttmp_buf_va[n] = dst;\n\t\t\t\tdst += s;\n\t\t\t\tdst_offs += s;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\treturn TEE_SUCCESS;\n}\n\n/*\n * Back from execution of service: update parameters passed from TA:\n * If some parameters were memory references:\n * - either the memref was temporary: copy back data and update size\n * - or it was the original TA memref: update only the size value.\n */\nstatic TEE_Result tee_svc_update_out_param(\n\t\tstruct tee_ta_param *param,\n\t\tvoid *tmp_buf_va[TEE_NUM_PARAMS],\n\t\tstruct utee_params *usr_param)\n{\n\tsize_t n;\n\tuint64_t *vals = usr_param->vals;\n\n\tfor (n = 0; n < TEE_NUM_PARAMS; n++) {\n\t\tswitch (TEE_PARAM_TYPE_GET(param->types, n)) {\n\t\tcase TEE_PARAM_TYPE_MEMREF_OUTPUT:\n\t\tcase TEE_PARAM_TYPE_MEMREF_INOUT:\n\t\t\t/*\n\t\t\t * Memory copy is only needed if there's a temporary\n\t\t\t * buffer involved, tmp_buf_va[n] is only update if\n\t\t\t * a temporary buffer is used. Otherwise only the\n\t\t\t * size needs to be updated.\n\t\t\t */\n\t\t\tif (tmp_buf_va[n] &&\n\t\t\t    param->u[n].mem.size <= vals[n * 2 + 1]) {\n\t\t\t\tvoid *src = tmp_buf_va[n];\n\t\t\t\tvoid *dst = (void *)(uintptr_t)vals[n * 2];\n\t\t\t\tTEE_Result res;\n\n\t\t\t\tres = tee_svc_copy_to_user(dst, src,\n\t\t\t\t\t\t param->u[n].mem.size);\n\t\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\t\treturn res;\n\n\t\t\t}\n\t\t\tusr_param->vals[n * 2 + 1] = param->u[n].mem.size;\n\t\t\tbreak;\n\n\t\tcase TEE_PARAM_TYPE_VALUE_OUTPUT:\n\t\tcase TEE_PARAM_TYPE_VALUE_INOUT:\n\t\t\tvals[n * 2] = param->u[n].val.a;\n\t\t\tvals[n * 2 + 1] = param->u[n].val.b;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\treturn TEE_SUCCESS;\n}\n\n/* Called when a TA calls an OpenSession on another TA */\nTEE_Result syscall_open_ta_session(const TEE_UUID *dest,\n\t\t\tunsigned long cancel_req_to,\n\t\t\tstruct utee_params *usr_param, uint32_t *ta_sess,\n\t\t\tuint32_t *ret_orig)\n{\n\tTEE_Result res;\n\tuint32_t ret_o = TEE_ORIGIN_TEE;\n\tstruct tee_ta_session *s = NULL;\n\tstruct tee_ta_session *sess;\n\tstruct mobj *mobj_param = NULL;\n\tTEE_UUID *uuid = malloc(sizeof(TEE_UUID));\n\tstruct tee_ta_param *param = malloc(sizeof(struct tee_ta_param));\n\tTEE_Identity *clnt_id = malloc(sizeof(TEE_Identity));\n\tvoid *tmp_buf_va[TEE_NUM_PARAMS] = { NULL };\n\tstruct user_ta_ctx *utc;\n\n\tif (uuid == NULL || param == NULL || clnt_id == NULL) {\n\t\tres = TEE_ERROR_OUT_OF_MEMORY;\n\t\tgoto out_free_only;\n\t}\n\n\tmemset(param, 0, sizeof(struct tee_ta_param));\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out_free_only;\n\tutc = to_user_ta_ctx(sess->ctx);\n\n\tres = tee_svc_copy_from_user(uuid, dest, sizeof(TEE_UUID));\n\tif (res != TEE_SUCCESS)\n\t\tgoto function_exit;\n\n\tclnt_id->login = TEE_LOGIN_TRUSTED_APP;\n\tmemcpy(&clnt_id->uuid, &sess->ctx->uuid, sizeof(TEE_UUID));\n\n\tres = tee_svc_copy_param(sess, NULL, usr_param, param, tmp_buf_va,\n\t\t\t\t &mobj_param);\n\tif (res != TEE_SUCCESS)\n\t\tgoto function_exit;\n\n\tres = tee_ta_open_session(&ret_o, &s, &utc->open_sessions, uuid,\n\t\t\t\t  clnt_id, cancel_req_to, param);\n\ttee_mmu_set_ctx(&utc->ctx);\n\tif (res != TEE_SUCCESS)\n\t\tgoto function_exit;\n\n\tres = tee_svc_update_out_param(param, tmp_buf_va, usr_param);\n\nfunction_exit:\n\tmobj_free(mobj_param);\n\tif (res == TEE_SUCCESS)\n\t\ttee_svc_copy_kaddr_to_uref(ta_sess, s);\n\ttee_svc_copy_to_user(ret_orig, &ret_o, sizeof(ret_o));\n\nout_free_only:\n\tfree(param);\n\tfree(uuid);\n\tfree(clnt_id);\n\treturn res;\n}\n\nTEE_Result syscall_close_ta_session(unsigned long ta_sess)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\tTEE_Identity clnt_id;\n\tstruct tee_ta_session *s = tee_svc_uref_to_kaddr(ta_sess);\n\tstruct user_ta_ctx *utc;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tutc = to_user_ta_ctx(sess->ctx);\n\n\tclnt_id.login = TEE_LOGIN_TRUSTED_APP;\n\tmemcpy(&clnt_id.uuid, &sess->ctx->uuid, sizeof(TEE_UUID));\n\n\treturn tee_ta_close_session(s, &utc->open_sessions, &clnt_id);\n}\n\nTEE_Result syscall_invoke_ta_command(unsigned long ta_sess,\n\t\t\tunsigned long cancel_req_to, unsigned long cmd_id,\n\t\t\tstruct utee_params *usr_param, uint32_t *ret_orig)\n{\n\tTEE_Result res;\n\tTEE_Result res2;\n\tuint32_t ret_o = TEE_ORIGIN_TEE;\n\tstruct tee_ta_param param = { 0 };\n\tTEE_Identity clnt_id;\n\tstruct tee_ta_session *sess;\n\tstruct tee_ta_session *called_sess;\n\tstruct mobj *mobj_param = NULL;\n\tvoid *tmp_buf_va[TEE_NUM_PARAMS] = { NULL };\n\tstruct user_ta_ctx *utc;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tutc = to_user_ta_ctx(sess->ctx);\n\n\tcalled_sess = tee_ta_get_session(\n\t\t\t\t(vaddr_t)tee_svc_uref_to_kaddr(ta_sess), true,\n\t\t\t\t&utc->open_sessions);\n\tif (!called_sess)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tclnt_id.login = TEE_LOGIN_TRUSTED_APP;\n\tmemcpy(&clnt_id.uuid, &sess->ctx->uuid, sizeof(TEE_UUID));\n\n\tres = tee_svc_copy_param(sess, called_sess, usr_param, &param,\n\t\t\t\t tmp_buf_va, &mobj_param);\n\tif (res != TEE_SUCCESS)\n\t\tgoto function_exit;\n\n\tres = tee_ta_invoke_command(&ret_o, called_sess, &clnt_id,\n\t\t\t\t    cancel_req_to, cmd_id, &param);\n\n\tres2 = tee_svc_update_out_param(&param, tmp_buf_va, usr_param);\n\tif (res2 != TEE_SUCCESS) {\n\t\t/*\n\t\t * Spec for TEE_InvokeTACommand() says:\n\t\t * \"If the return origin is different from\n\t\t * TEE_ORIGIN_TRUSTED_APP, then the function has failed\n\t\t * before it could reach the destination Trusted\n\t\t * Application.\"\n\t\t *\n\t\t * But if we can't update params to the caller we have no\n\t\t * choice we need to return some error to indicate that\n\t\t * parameters aren't updated as expected.\n\t\t */\n\t\tret_o = TEE_ORIGIN_TEE;\n\t\tres = res2;\n\t}\n\nfunction_exit:\n\ttee_ta_put_session(called_sess);\n\tmobj_free(mobj_param);\n\tif (ret_orig)\n\t\ttee_svc_copy_to_user(ret_orig, &ret_o, sizeof(ret_o));\n\treturn res;\n}\n\nTEE_Result syscall_check_access_rights(unsigned long flags, const void *buf,\n\t\t\t\t       size_t len)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *s;\n\n\tres = tee_ta_get_current_session(&s);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\treturn tee_mmu_check_access_rights(to_user_ta_ctx(s->ctx), flags,\n\t\t\t\t\t   (uaddr_t)buf, len);\n}\n\nTEE_Result tee_svc_copy_from_user(void *kaddr, const void *uaddr, size_t len)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *s;\n\n\tres = tee_ta_get_current_session(&s);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(s->ctx),\n\t\t\t\t\tTEE_MEMORY_ACCESS_READ |\n\t\t\t\t\tTEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t(uaddr_t)uaddr, len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tmemcpy(kaddr, uaddr, len);\n\treturn TEE_SUCCESS;\n}\n\nTEE_Result tee_svc_copy_to_user(void *uaddr, const void *kaddr, size_t len)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *s;\n\n\tres = tee_ta_get_current_session(&s);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(s->ctx),\n\t\t\t\t\tTEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\tTEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t(uaddr_t)uaddr, len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tmemcpy(uaddr, kaddr, len);\n\treturn TEE_SUCCESS;\n}\n\nTEE_Result tee_svc_copy_kaddr_to_uref(uint32_t *uref, void *kaddr)\n{\n\tuint32_t ref = tee_svc_kaddr_to_uref(kaddr);\n\n\treturn tee_svc_copy_to_user(uref, &ref, sizeof(ref));\n}\n\nTEE_Result syscall_get_cancellation_flag(uint32_t *cancel)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *s = NULL;\n\tuint32_t c;\n\n\tres = tee_ta_get_current_session(&s);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tc = tee_ta_session_is_cancelled(s, NULL);\n\n\treturn tee_svc_copy_to_user(cancel, &c, sizeof(c));\n}\n\nTEE_Result syscall_unmask_cancellation(uint32_t *old_mask)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *s = NULL;\n\tuint32_t m;\n\n\tres = tee_ta_get_current_session(&s);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tm = s->cancel_mask;\n\ts->cancel_mask = false;\n\treturn tee_svc_copy_to_user(old_mask, &m, sizeof(m));\n}\n\nTEE_Result syscall_mask_cancellation(uint32_t *old_mask)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *s = NULL;\n\tuint32_t m;\n\n\tres = tee_ta_get_current_session(&s);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tm = s->cancel_mask;\n\ts->cancel_mask = true;\n\treturn tee_svc_copy_to_user(old_mask, &m, sizeof(m));\n}\n\nTEE_Result syscall_wait(unsigned long timeout)\n{\n\tTEE_Result res = TEE_SUCCESS;\n\tuint32_t mytime = 0;\n\tstruct tee_ta_session *s;\n\tTEE_Time base_time;\n\tTEE_Time current_time;\n\n\tres = tee_ta_get_current_session(&s);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_time_get_sys_time(&base_time);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\twhile (true) {\n\t\tres = tee_time_get_sys_time(&current_time);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\n\t\tif (tee_ta_session_is_cancelled(s, &current_time))\n\t\t\treturn TEE_ERROR_CANCEL;\n\n\t\tmytime = (current_time.seconds - base_time.seconds) * 1000 +\n\t\t    (int)current_time.millis - (int)base_time.millis;\n\t\tif (mytime >= timeout)\n\t\t\treturn TEE_SUCCESS;\n\n\t\ttee_time_wait(timeout - mytime);\n\t}\n\n\treturn res;\n}\n\nTEE_Result syscall_get_time(unsigned long cat, TEE_Time *mytime)\n{\n\tTEE_Result res, res2;\n\tstruct tee_ta_session *s = NULL;\n\tTEE_Time t;\n\n\tres = tee_ta_get_current_session(&s);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tswitch (cat) {\n\tcase UTEE_TIME_CAT_SYSTEM:\n\t\tres = tee_time_get_sys_time(&t);\n\t\tbreak;\n\tcase UTEE_TIME_CAT_TA_PERSISTENT:\n\t\tres = tee_time_get_ta_time((const void *)&s->ctx->uuid, &t);\n\t\tbreak;\n\tcase UTEE_TIME_CAT_REE:\n\t\tres = tee_time_get_ree_time(&t);\n\t\tbreak;\n\tdefault:\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tbreak;\n\t}\n\n\tif (res == TEE_SUCCESS || res == TEE_ERROR_OVERFLOW) {\n\t\tres2 = tee_svc_copy_to_user(mytime, &t, sizeof(t));\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\tres = res2;\n\t}\n\n\treturn res;\n}\n\nTEE_Result syscall_set_ta_time(const TEE_Time *mytime)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *s = NULL;\n\tTEE_Time t;\n\n\tres = tee_ta_get_current_session(&s);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_copy_from_user(&t, mytime, sizeof(t));\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\treturn tee_time_set_ta_time((const void *)&s->ctx->uuid, &t);\n}\n"], "filenames": ["core/tee/tee_svc.c"], "buggy_code_start_loc": [497], "buggy_code_end_loc": [579], "fixing_code_start_loc": [497], "fixing_code_end_loc": [591], "type": "CWE-125", "message": "Linaro/OP-TEE OP-TEE 3.3.0 and earlier is affected by: Buffer Overflow. The impact is: Memory corruption and disclosure of memory content. The component is: optee_os. The fixed version is: 3.4.0 and later.", "other": {"cve": {"id": "CVE-2019-1010295", "sourceIdentifier": "josh@bress.net", "published": "2019-07-15T18:15:11.443", "lastModified": "2021-07-21T11:39:23.747", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Linaro/OP-TEE OP-TEE 3.3.0 and earlier is affected by: Buffer Overflow. The impact is: Memory corruption and disclosure of memory content. The component is: optee_os. The fixed version is: 3.4.0 and later."}, {"lang": "es", "value": "OP-TEE versi\u00f3n 3.3.0 y anteriores de Linaro/OP-TEE, est\u00e1 afectado por: Desbordamiento de b\u00fafer. El impacto es: Corrupci\u00f3n de memoria y divulgaci\u00f3n del contenido de la memoria. El componente es: optee_os. La versi\u00f3n corregida es: 3.4.0 y posteriores."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}, {"lang": "en", "value": "CWE-20"}, {"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linaro:op-tee:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.3.0", "matchCriteriaId": "BE2AA919-55C6-4AE4-B611-EBEB412B2370"}]}]}], "references": [{"url": "https://github.com/OP-TEE/optee_os/commit/d5c5b0b77b2b589666024d219a8007b3f5b6faeb", "source": "josh@bress.net", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/OP-TEE/optee_os/commit/d5c5b0b77b2b589666024d219a8007b3f5b6faeb"}}