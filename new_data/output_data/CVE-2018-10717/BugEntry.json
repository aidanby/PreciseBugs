{"buggy_code": ["#ifndef NGIFLIB_NO_FILE\n#include <stdio.h>\n#endif /* NGIFLIB_NO_FILE */\n\n#include \"ngiflib.h\"\n\n/* decodeur GIF en C portable (pas de pb big/little endian)\n * Thomas BERNARD. janvier 2004.\n * (c) 2004-2017 Thomas Bernard. All rights reserved\n */\n\n/* Fonction de debug */\n#ifdef DEBUG\nvoid fprintf_ngiflib_img(FILE * f, struct ngiflib_img * i) {\n\tfprintf(f, \"  * ngiflib_img @ %p\\n\", i);\n\tfprintf(f, \"    next = %p\\n\", i->next);\n\tfprintf(f, \"    parent = %p\\n\", i->parent);\n\tfprintf(f, \"    palette = %p\\n\", i->palette);\n\tfprintf(f, \"    %3d couleurs\", i->ncolors);\n\tif(i->interlaced) fprintf(f, \" interlaced\");\n\tfprintf(f, \"\\n    taille : %dx%d, pos (%d,%d)\\n\", i->width, i->height, i->posX, i->posY);\n\tfprintf(f, \"    sort_flag=%x localpalbits=%d\\n\", i->sort_flag, i->localpalbits);\n}\n#endif /* DEBUG */\n\nvoid GifImgDestroy(struct ngiflib_img * i) {\n\tif(i==NULL) return;\n\tif(i->next) GifImgDestroy(i->next);\n\tif(i->palette && (i->palette != i->parent->palette))\n\t  ngiflib_free(i->palette);\n\tngiflib_free(i);\n}\n\n/* Fonction de debug */\n#ifdef DEBUG\nvoid fprintf_ngiflib_gif(FILE * f, struct ngiflib_gif * g) {\n\tstruct ngiflib_img * i;\n\tfprintf(f, \"* ngiflib_gif @ %p %s\\n\", g, g->signature);\n\tfprintf(f, \"  %dx%d, %d bits, %d couleurs\\n\", g->width, g->height, g->imgbits, g->ncolors);\n\tfprintf(f, \"  palette = %p, backgroundcolorindex %d\\n\", g->palette, g->backgroundindex);\n\tfprintf(f, \"  pixelaspectratio = %d\\n\", g->pixaspectratio);\n\tfprintf(f, \"  frbuff = %p\\n\", g->frbuff.p8);\n\t\n\tfprintf(f, \"  cur_img = %p\\n\", g->cur_img);\n\tfprintf(f, \"  %d images :\\n\", g->nimg);\n\ti = g->first_img;\n\twhile(i) {\n\t\tfprintf_ngiflib_img(f, i);\n\t\ti = i->next;\n\t}\n}\n#endif /* DEBUG */\n\nvoid GifDestroy(struct ngiflib_gif * g) {\n\tif(g==NULL) return;\n\tif(g->palette) ngiflib_free(g->palette);\n\tif(g->frbuff.p8) ngiflib_free(g->frbuff.p8);\n\tGifImgDestroy(g->first_img);\n\tngiflib_free(g);\n}\n\n/* u8 GetByte(struct ngiflib_gif * g);\n * fonction qui renvoie un octet du fichier .gif\n * on pourait optimiser en faisant 2 fonctions.\n */\nstatic u8 GetByte(struct ngiflib_gif * g) {\n#ifndef NGIFLIB_NO_FILE\n\tif(g->mode & NGIFLIB_MODE_FROM_MEM) {\n#endif /* NGIFLIB_NO_FILE */\n\t\treturn *(g->input.bytes++);\n#ifndef NGIFLIB_NO_FILE\n\t} else {\n\t\treturn (u8)(getc(g->input.file));\n\t}\n#endif /* NGIFLIB_NO_FILE */\n}\n\n/* u16 GetWord()\n * Renvoie un mot de 16bits\n * N'est pas influencee par l'endianess du CPU !\n */\nstatic u16 GetWord(struct ngiflib_gif * g) {\n\tu16 r = (u16)GetByte(g);\n\tr |= ((u16)GetByte(g) << 8);\n\treturn r;\n}\n\n/* int GetByteStr(struct ngiflib_gif * g, u8 * p, int n);\n * prend en argument un pointeur sur la destination\n * et le nombre d'octet a lire.\n * Renvoie 0 si l'operation a reussi, -1 sinon.\n */\nstatic int GetByteStr(struct ngiflib_gif * g, u8 * p, int n) {\n\tif(!p) return -1;\n#ifndef NGIFLIB_NO_FILE\n\tif(g->mode & NGIFLIB_MODE_FROM_MEM) {\n#endif /* NGIFLIB_NO_FILE */\n\t\tngiflib_memcpy(p, g->input.bytes, n);\n\t\tg->input.bytes += n;\n\t\treturn 0;\n#ifndef NGIFLIB_NO_FILE\n\t} else {\n\t\tsize_t read;\n\t\tread = fread(p, 1, n, g->input.file);\n\t\treturn ((int)read == n) ? 0 : -1;\n\t}\n#endif /* NGIFLIB_NO_FILE */\n}\n\n/* void WritePixel(struct ngiflib_img * i, u8 v);\n * ecrit le pixel de valeur v dans le frame buffer\n */\nstatic void WritePixel(struct ngiflib_img * i, struct ngiflib_decode_context * context, u8 v) {\n\tstruct ngiflib_gif * p = i->parent;\n\n\tif(v!=i->gce.transparent_color || !i->gce.transparent_flag) {\n#ifndef NGIFLIB_INDEXED_ONLY\n\t\tif(p->mode & NGIFLIB_MODE_INDEXED) {\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\t\t*context->frbuff_p.p8 = v;\n#ifndef NGIFLIB_INDEXED_ONLY\n\t\t} else\n\t\t\t*context->frbuff_p.p32 =\n\t\t\t   GifIndexToTrueColor(i->palette, v);\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t}\n\tif(--(context->Xtogo) <= 0) {\n\t\t#ifdef NGIFLIB_ENABLE_CALLBACKS\n\t\tif(p->line_cb) p->line_cb(p, context->line_p, context->curY);\n\t\t#endif /* NGIFLIB_ENABLE_CALLBACKS */\n\t\tcontext->Xtogo = i->width;\n\t\tswitch(context->pass) {\n\t\tcase 0:\n\t\t\tcontext->curY++;\n\t\t\tbreak;\n\t\tcase 1:\t/* 1st pass : every eighth row starting from 0 */\n\t\t\tcontext->curY += 8;\n\t\t\tif(context->curY >= p->height) {\n\t\t\t\tcontext->pass++;\n\t\t\t\tcontext->curY = i->posY + 4;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\t/* 2nd pass : every eighth row starting from 4 */\n\t\t\tcontext->curY += 8;\n\t\t\tif(context->curY >= p->height) {\n\t\t\t\tcontext->pass++;\n\t\t\t\tcontext->curY = i->posY + 2;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3:\t/* 3rd pass : every fourth row starting from 2 */\n\t\t\tcontext->curY += 4;\n\t\t\tif(context->curY >= p->height) {\n\t\t\t\tcontext->pass++;\n\t\t\t\tcontext->curY = i->posY + 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 4:\t/* 4th pass : every odd row */\n\t\t\tcontext->curY += 2;\n\t\t\tbreak;\n\t\t}\n#ifndef NGIFLIB_INDEXED_ONLY\n\t\tif(p->mode & NGIFLIB_MODE_INDEXED) {\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\t\t#ifdef NGIFLIB_ENABLE_CALLBACKS\n\t\t\tcontext->line_p.p8 = p->frbuff.p8 + (u32)context->curY*p->width;\n\t\t\tcontext->frbuff_p.p8 = context->line_p.p8 + i->posX;\n\t\t\t#else\n\t\t\tcontext->frbuff_p.p8 = p->frbuff.p8 + (u32)context->curY*p->width + i->posX;\n\t\t\t#endif /* NGIFLIB_ENABLE_CALLBACKS */\n#ifndef NGIFLIB_INDEXED_ONLY\n\t\t} else {\n\t\t\t#ifdef NGIFLIB_ENABLE_CALLBACKS\n\t\t\tcontext->line_p.p32 = p->frbuff.p32 + (u32)context->curY*p->width;\n\t\t\tcontext->frbuff_p.p32 = context->line_p.p32 + i->posX;\n\t\t\t#else\n\t\t\tcontext->frbuff_p.p32 = p->frbuff.p32 + (u32)context->curY*p->width + i->posX;\n\t\t\t#endif /* NGIFLIB_ENABLE_CALLBACKS */\n\t\t}\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t} else {\n#ifndef NGIFLIB_INDEXED_ONLY\n\t\tif(p->mode & NGIFLIB_MODE_INDEXED) {\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\t\tcontext->frbuff_p.p8++;\n#ifndef NGIFLIB_INDEXED_ONLY\n\t\t} else {\n\t\t\tcontext->frbuff_p.p32++;\n\t\t}\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t}\n}\n\n/* void WritePixels(struct ngiflib_img * i, const u8 * pixels, u16 n);\n * ecrit les pixels dans le frame buffer\n */\nstatic void WritePixels(struct ngiflib_img * i, struct ngiflib_decode_context * context, const u8 * pixels, u16 n) {\n\tu16 tocopy;\t\n\tstruct ngiflib_gif * p = i->parent;\n\n\twhile(n > 0) {\n\t\ttocopy = (context->Xtogo < n) ? context->Xtogo : n;\n\t\tif(!i->gce.transparent_flag) {\n#ifndef NGIFLIB_INDEXED_ONLY\n\t\t\tif(p->mode & NGIFLIB_MODE_INDEXED) {\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\t\t\tngiflib_memcpy(context->frbuff_p.p8, pixels, tocopy);\n\t\t\t\tpixels += tocopy;\n\t\t\t\tcontext->frbuff_p.p8 += tocopy;\n#ifndef NGIFLIB_INDEXED_ONLY\n\t\t\t} else {\n\t\t\t\tint j;\n\t\t\t\tfor(j = (int)tocopy; j > 0; j--) {\n\t\t\t\t\t*(context->frbuff_p.p32++) =\n\t\t\t\t\t   GifIndexToTrueColor(i->palette, *pixels++);\n\t\t\t\t}\n\t\t\t}\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\t} else {\n\t\t\tint j;\n#ifndef NGIFLIB_INDEXED_ONLY\n\t\t\tif(p->mode & NGIFLIB_MODE_INDEXED) {\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\t\t\tfor(j = (int)tocopy; j > 0; j--) {\n\t\t\t\t\tif(*pixels != i->gce.transparent_color) *context->frbuff_p.p8 = *pixels;\n\t\t\t\t\tpixels++;\n\t\t\t\t\tcontext->frbuff_p.p8++;\n\t\t\t\t}\n#ifndef NGIFLIB_INDEXED_ONLY\n\t\t\t} else {\n\t\t\t\tfor(j = (int)tocopy; j > 0; j--) {\n\t\t\t\t\tif(*pixels != i->gce.transparent_color) {\n\t\t\t\t\t\t*context->frbuff_p.p32 = GifIndexToTrueColor(i->palette, *pixels);\n\t\t\t\t\t}\n\t\t\t\t\tpixels++;\n\t\t\t\t\tcontext->frbuff_p.p32++;\n\t\t\t\t}\n\t\t\t}\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\t}\n\t\tcontext->Xtogo -= tocopy;\n\t\tif(context->Xtogo == 0) {\n\t\t\t#ifdef NGIFLIB_ENABLE_CALLBACKS\n\t\t\tif(p->line_cb) p->line_cb(p, context->line_p, context->curY);\n\t\t\t#endif /* NGIFLIB_ENABLE_CALLBACKS */\n\t\t\tcontext->Xtogo = i->width;\n\t\t\tswitch(context->pass) {\n\t\t\tcase 0:\n\t\t\t\tcontext->curY++;\n\t\t\t\tbreak;\n\t\t\tcase 1:\t/* 1st pass : every eighth row starting from 0 */\n\t\t\t\tcontext->curY += 8;\n\t\t\t\tif(context->curY >= p->height) {\n\t\t\t\t\tcontext->pass++;\n\t\t\t\t\tcontext->curY = i->posY + 4;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\t/* 2nd pass : every eighth row starting from 4 */\n\t\t\t\tcontext->curY += 8;\n\t\t\t\tif(context->curY >= p->height) {\n\t\t\t\t\tcontext->pass++;\n\t\t\t\t\tcontext->curY = i->posY + 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 3:\t/* 3rd pass : every fourth row starting from 2 */\n\t\t\t\tcontext->curY += 4;\n\t\t\t\tif(context->curY >= p->height) {\n\t\t\t\t\tcontext->pass++;\n\t\t\t\t\tcontext->curY = i->posY + 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 4:\t/* 4th pass : every odd row */\n\t\t\t\tcontext->curY += 2;\n\t\t\t\tbreak;\n\t\t\t}\n#ifndef NGIFLIB_INDEXED_ONLY\n\t\t\tif(p->mode & NGIFLIB_MODE_INDEXED) {\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\t\t\t#ifdef NGIFLIB_ENABLE_CALLBACKS\n\t\t\t\tcontext->line_p.p8 = p->frbuff.p8 + (u32)context->curY*p->width;\n\t\t\t\tcontext->frbuff_p.p8 = context->line_p.p8 + i->posX;\n\t\t\t\t#else\n\t\t\t\tcontext->frbuff_p.p8 = p->frbuff.p8 + (u32)context->curY*p->width + i->posX;\n\t\t\t\t#endif /* NGIFLIB_ENABLE_CALLBACKS */\n#ifndef NGIFLIB_INDEXED_ONLY\n\t\t\t} else {\n\t\t\t\t#ifdef NGIFLIB_ENABLE_CALLBACKS\n\t\t\t\tcontext->line_p.p32 = p->frbuff.p32 + (u32)context->curY*p->width;\n\t\t\t\tcontext->frbuff_p.p32 = context->line_p.p32 + i->posX;\n\t\t\t\t#else\n\t\t\t\tcontext->frbuff_p.p32 = p->frbuff.p32 + (u32)context->curY*p->width + i->posX;\n\t\t\t\t#endif /* NGIFLIB_ENABLE_CALLBACKS */\n\t\t\t}\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\t}\n\t\tn -= tocopy;\n\t}\n}\n\n/*\n * u16 GetGifWord(struct ngiflib_img * i);\n * Renvoie un code LZW (taille variable)\n */\nstatic u16 GetGifWord(struct ngiflib_img * i, struct ngiflib_decode_context * context) {\n\tu16 r;\n\tint bits_todo;\n\tu16 newbyte;\n\n\tbits_todo = (int)context->nbbit - (int)context->restbits;\n\tif( bits_todo <= 0) {\t/* nbbit <= restbits */\n\t\tr = context->lbyte;\n\t\tcontext->restbits -= context->nbbit;\n\t\tcontext->lbyte >>= context->nbbit;\n\t} else if( bits_todo > 8 ) {\t/* nbbit > restbits + 8 */\n\t\tif(context->restbyte >= 2) {\n\t\t\tcontext->restbyte -= 2;\n\t\t\tr = *context->srcbyte++;\n\t\t} else {\n\t\t\tif(context->restbyte == 0) {\n\t\t\t\tcontext->restbyte = GetByte(i->parent);\n#if defined(DEBUG) && !defined(NGIFLIB_NO_FILE)\n\t\t\t\tif(i->parent->log) fprintf(i->parent->log, \"restbyte = %02X\\n\", context->restbyte);\n#endif /* defined(DEBUG) && !defined(NGIFLIB_NO_FILE) */\n\t\t\t\tGetByteStr(i->parent, context->byte_buffer, context->restbyte);\n\t\t\t\tcontext->srcbyte = context->byte_buffer;\n\t\t\t}\n\t\t\tr = *context->srcbyte++;\n\t\t\tif(--context->restbyte == 0) {\n\t\t\t\tcontext->restbyte = GetByte(i->parent);\n#if defined(DEBUG) && !defined(NGIFLIB_NO_FILE)\n\t\t\t\tif(i->parent->log) fprintf(i->parent->log, \"restbyte = %02X\\n\", context->restbyte);\n#endif /* defined(DEBUG) && !defined(NGIFLIB_NO_FILE) */\n\t\t\t\tGetByteStr(i->parent, context->byte_buffer, context->restbyte);\n\t\t\t\tcontext->srcbyte = context->byte_buffer;\n\t\t\t}\n\t\t\tcontext->restbyte--;\n\t\t}\n\t\tnewbyte = *context->srcbyte++;\n\t\tr |= newbyte << 8;\n\t\tr = (r << context->restbits) | context->lbyte;\n\t\tcontext->restbits = 16 - bits_todo;\n\t\tcontext->lbyte = newbyte >> (bits_todo - 8);\n\t} else /*if( bits_todo > 0 )*/ { /* nbbit > restbits */\n\t\tif(context->restbyte == 0) {\n\t\t\tcontext->restbyte = GetByte(i->parent);\n#if defined(DEBUG) && !defined(NGIFLIB_NO_FILE)\n\t\t\tif(i->parent->log) fprintf(i->parent->log, \"restbyte = %02X\\n\", context->restbyte);\n#endif /* defined(DEBUG) && !defined(NGIFLIB_NO_FILE) */\n\t\t\tGetByteStr(i->parent, context->byte_buffer, context->restbyte);\n\t\t\tcontext->srcbyte = context->byte_buffer;\n\t\t}\n\t\tnewbyte = *context->srcbyte++;\n\t\tcontext->restbyte--;\n\t\tr = (newbyte << context->restbits) | context->lbyte;\n\t\tcontext->restbits = 8 - bits_todo;\n\t\tcontext->lbyte = newbyte >> bits_todo;\n\t}\n\treturn (r & context->max);\t/* applique le bon masque pour eliminer les bits en trop */\n}\n\n/* ------------------------------------------------ */\nstatic void FillGifBackGround(struct ngiflib_gif * g) {\n\tlong n = (long)g->width*g->height;\n#ifndef NGIFLIB_INDEXED_ONLY\n\tu32 bg_truecolor;\n#endif /* NGIFLIB_INDEXED_ONLY */\n\n\tif((g->frbuff.p8==NULL)||(g->palette==NULL)) return;\n#ifndef NGIFLIB_INDEXED_ONLY\n\tif(g->mode & NGIFLIB_MODE_INDEXED) {\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\tngiflib_memset(g->frbuff.p8, g->backgroundindex, n);\n#ifndef NGIFLIB_INDEXED_ONLY\n\t} else {\n\t\tu32 * p = g->frbuff.p32;\n\t\tbg_truecolor = GifIndexToTrueColor(g->palette, g->backgroundindex);\n\t\twhile(n-->0) *p++ = bg_truecolor;\n\t}\n#endif /* NGIFLIB_INDEXED_ONLY */\n}\n\n/* ------------------------------------------------ */\nint CheckGif(u8 * b) {\n\treturn (b[0]=='G')&&(b[1]=='I')&&(b[2]=='F')&&(b[3]=='8');\n}\n\n/* ------------------------------------------------ */\nstatic int DecodeGifImg(struct ngiflib_img * i) {\n\tstruct ngiflib_decode_context context;\n\tlong npix;\n\tu8 * stackp;\n\tu8 * stack_top;\n\tu16 clr;\n\tu16 eof;\n\tu16 free;\n\tu16 act_code = 0;\n\tu16 old_code = 0;\n\tu16 read_byt;\n\tu16 ab_prfx[4096];\n\tu8 ab_suffx[4096];\n\tu8 ab_stack[4096];\n\tu8 flags;\n\tu8 casspecial = 0;\n\n\tif(!i) return -1;\n\n\ti->posX = GetWord(i->parent);\t/* offsetX */\n\ti->posY = GetWord(i->parent);\t/* offsetY */\n\ti->width = GetWord(i->parent);\t/* SizeX   */\n\ti->height = GetWord(i->parent);\t/* SizeY   */\n\n\tif((i->width > i->parent->width) || (i->height > i->parent->height)) {\n#if !defined(NGIFLIB_NO_FILE)\n\t\tif(i->parent->log) fprintf(i->parent->log, \"*** ERROR *** Image bigger than global GIF canvas !\\n\");\n#endif\n\t\treturn -1;\n\t}\n\tif((i->posX + i->width) > i->parent->width) {\n#if !defined(NGIFLIB_NO_FILE)\n\t\tif(i->parent->log) fprintf(i->parent->log, \"*** WARNING *** Adjusting X position\\n\");\n#endif\n\t\ti->posX = i->parent->width - i->width;\n\t}\n\tif((i->posY + i->height) > i->parent->height) {\n#if !defined(NGIFLIB_NO_FILE)\n\t\tif(i->parent->log) fprintf(i->parent->log, \"*** WARNING *** Adjusting Y position\\n\");\n#endif\n\t\ti->posY = i->parent->height - i->height;\n\t}\n\tcontext.Xtogo = i->width;\n\tcontext.curY = i->posY;\n#ifdef NGIFLIB_INDEXED_ONLY\n\t#ifdef NGIFLIB_ENABLE_CALLBACKS\n\tcontext.line_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width;\n\tcontext.frbuff_p.p8 = context.line_p.p8 + i->posX;\n\t#else\n\tcontext.frbuff_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width + i->posX;\n\t#endif /* NGIFLIB_ENABLE_CALLBACKS */\n#else\n\tif(i->parent->mode & NGIFLIB_MODE_INDEXED) {\n\t\t#ifdef NGIFLIB_ENABLE_CALLBACKS\n\t\tcontext.line_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width;\n\t\tcontext.frbuff_p.p8 = context.line_p.p8 + i->posX;\n\t\t#else\n\t\tcontext.frbuff_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width + i->posX;\n\t\t#endif /* NGIFLIB_ENABLE_CALLBACKS */\n\t} else {\n\t\t#ifdef NGIFLIB_ENABLE_CALLBACKS\n\t\tcontext.line_p.p32 = i->parent->frbuff.p32 + (u32)i->posY*i->parent->width;\n\t\tcontext.frbuff_p.p32 = context.line_p.p32 + i->posX;\n\t\t#else\n\t\tcontext.frbuff_p.p32 = i->parent->frbuff.p32 + (u32)i->posY*i->parent->width + i->posX;\n\t\t#endif /* NGIFLIB_ENABLE_CALLBACKS */\n\t}\n#endif /* NGIFLIB_INDEXED_ONLY */\n\n\tnpix = (long)i->width * i->height;\n\tflags = GetByte(i->parent);\n\ti->interlaced = (flags & 64) >> 6;\n\tcontext.pass = i->interlaced ? 1 : 0;\n\ti->sort_flag = (flags & 32) >> 5;\t/* is local palette sorted by color frequency ? */\n\ti->localpalbits = (flags & 7) + 1;\n\tif(flags&128) { /* palette locale */\n\t\tint k;\n\t\tint localpalsize = 1 << i->localpalbits;\n#if !defined(NGIFLIB_NO_FILE)\n\t\tif(i->parent && i->parent->log) fprintf(i->parent->log, \"Local palette\\n\");\n#endif /* !defined(NGIFLIB_NO_FILE) */\n\t\ti->palette = (struct ngiflib_rgb *)ngiflib_malloc(sizeof(struct ngiflib_rgb)*localpalsize);\n\t\tfor(k=0; k<localpalsize; k++) {\n\t\t\ti->palette[k].r = GetByte(i->parent);\n\t\t\ti->palette[k].g = GetByte(i->parent);\n\t\t\ti->palette[k].b = GetByte(i->parent);\n\t\t}\n#ifdef NGIFLIB_ENABLE_CALLBACKS\n\t\tif(i->parent->palette_cb) i->parent->palette_cb(i->parent, i->palette, localpalsize);\n#endif /* NGIFLIB_ENABLE_CALLBACKS */\n\t} else {\n\t\ti->palette = i->parent->palette;\n\t\ti->localpalbits = i->parent->imgbits;\n\t}\n\ti->ncolors = 1 << i->localpalbits;\n\t\n\ti->imgbits = GetByte(i->parent);\t/* LZW Minimum Code Size */\n\n#if !defined(NGIFLIB_NO_FILE)\n\tif(i->parent && i->parent->log) {\n\t\tif(i->interlaced) fprintf(i->parent->log, \"interlaced \");\n\t\tfprintf(i->parent->log, \"img pos(%hu,%hu) size %hux%hu palbits=%hhu imgbits=%hhu ncolors=%hu\\n\",\n\t       i->posX, i->posY, i->width, i->height, i->localpalbits, i->imgbits, i->ncolors);\n\t}\n#endif /* !defined(NGIFLIB_NO_FILE) */\n\n\tif(i->imgbits==1) {\t/* fix for 1bit images ? */\n\t\ti->imgbits = 2;\n\t}\n\tclr = 1 << i->imgbits;\n\teof = clr + 1;\n\tfree = clr + 2;\n\tcontext.nbbit = i->imgbits + 1;\n\tcontext.max = clr + clr - 1; /* (1 << context.nbbit) - 1 */\n\tstackp = stack_top = ab_stack + 4096;\n\t\n\tcontext.restbits = 0;\t/* initialise le \"buffer\" de lecture */\n\tcontext.restbyte = 0;\t/* des codes LZW */\n\tcontext.lbyte = 0;\n\tfor(;;) {\n\t\tact_code = GetGifWord(i, &context);\n\t\tif(act_code==eof) {\n#if !defined(NGIFLIB_NO_FILE)\n\t\t\tif(i->parent && i->parent->log) fprintf(i->parent->log, \"End of image code\\n\");\n#endif /* !defined(NGIFLIB_NO_FILE) */\n\t\t\treturn 0;\n\t\t}\n\t\tif(npix==0) {\n#if !defined(NGIFLIB_NO_FILE)\n\t\t\tif(i->parent && i->parent->log) fprintf(i->parent->log, \"assez de pixels, On se casse !\\n\");\n#endif /* !defined(NGIFLIB_NO_FILE) */\n\t\t\treturn 1;\n\t\t}\t\n\t\tif(act_code==clr) {\n#if !defined(NGIFLIB_NO_FILE)\n\t\t\tif(i->parent && i->parent->log) fprintf(i->parent->log, \"Code clear (free=%hu) npix=%ld\\n\", free, npix);\n#endif /* !defined(NGIFLIB_NO_FILE) */\n\t\t\t/* clear */\n\t\t\tfree = clr + 2;\n\t\t\tcontext.nbbit = i->imgbits + 1;\n\t\t\tcontext.max = clr + clr - 1; /* (1 << context.nbbit) - 1 */\n\t\t\tact_code = GetGifWord(i, &context);\n\t\t\tcasspecial = (u8)act_code;\n\t\t\told_code = act_code;\n\t\t\tWritePixel(i, &context, casspecial); npix--;\n\t\t} else {\n\t\t\tread_byt = act_code;\n\t\t\tif(act_code >= free) {\t/* code pas encore dans alphabet */\n/*\t\t\t\tprintf(\"Code pas dans alphabet : %d>=%d push %d\\n\", act_code, free, casspecial); */\n\t\t\t\t*(--stackp) = casspecial; /* dernier debut de chaine ! */\n\t\t\t\tact_code = old_code;\n\t\t\t}\n/*\t\t\tprintf(\"actcode=%d\\n\", act_code); */\n\t\t\twhile(act_code > clr) { /* code non concret */\n\t\t\t\t/* fillstackloop empile les suffixes ! */\n\t\t\t\t*(--stackp) = ab_suffx[act_code];\n\t\t\t\tact_code = ab_prfx[act_code];\t/* prefixe */\n\t\t\t}\n\t\t\t/* act_code est concret */\n\t\t\tcasspecial = (u8)act_code;\t/* dernier debut de chaine ! */\n\t\t\t*(--stackp) = casspecial;\t/* push on stack */\n\t\t\tWritePixels(i, &context, stackp, stack_top - stackp);\t/* unstack all pixels at once */\n\t\t\tnpix -= (stack_top - stackp);\n\t\t\tstackp = stack_top;\n/*\t\t\tputchar('\\n'); */\n\t\t\tif(free < 4096) { /* la taille du dico est 4096 max ! */\n\t\t\t\tab_prfx[free] = old_code;\n\t\t\t\tab_suffx[free] = (u8)act_code;\n\t\t\t\tfree++;\n\t\t\t\tif((free > context.max) && (context.nbbit < 12)) {\n\t\t\t\t\tcontext.nbbit++;\t/* 1 bit de plus pour les codes LZW */\n\t\t\t\t\tcontext.max += context.max + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\told_code = read_byt;\n\t\t}\n\t\t\t\n\t}\n\treturn 0;\n}\n\n/* ------------------------------------------------ \n * int LoadGif(struct ngiflib_gif *);\n * s'assurer que nimg=0 au depart !\n * retourne : \n *    0 si GIF termin\ufffd\n *    un nombre negatif si ERREUR\n *    1 si image Decod\ufffde\n * rappeler pour decoder les images suivantes\n * ------------------------------------------------ */\nint LoadGif(struct ngiflib_gif * g) {\n\tstruct ngiflib_gce gce;\n\tu8 sign;\n\tu8 tmp;\n\tint i;\n\n\tif(!g) return -1;\n\tgce.gce_present = 0;\n\t\n\tif(g->nimg==0) {\n\t\tGetByteStr(g, g->signature, 6);\n\t\tg->signature[6] = '\\0';\n\t\tif(   g->signature[0] != 'G'\n\t\t   || g->signature[1] != 'I'\n\t\t   || g->signature[2] != 'F'\n\t\t   || g->signature[3] != '8') {\n\t\t\treturn -1;\n\t\t}\n#if !defined(NGIFLIB_NO_FILE)\n\t\tif(g->log) fprintf(g->log, \"%s\\n\", g->signature);\n#endif /* !defined(NGIFLIB_NO_FILE) */\n\n\t\tg->width = GetWord(g);\n\t\tg->height = GetWord(g);\n\t\t/* allocate frame buffer */\n#ifndef NGIFLIB_INDEXED_ONLY\n\t\tif((g->mode & NGIFLIB_MODE_INDEXED)==0)\n\t\t\tg->frbuff.p32 = ngiflib_malloc(4*(long)g->height*(long)g->width);\n\t\telse\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\t\tg->frbuff.p8 = ngiflib_malloc((long)g->height*(long)g->width);\n\n\t\ttmp = GetByte(g);/* <Packed Fields> = Global Color Table Flag       1 Bit\n\t\t                                      Color Resolution              3 Bits\n\t\t                                      Sort Flag                     1 Bit\n\t\t                                      Size of Global Color Table    3 Bits */\n\t\tg->colorresolution = ((tmp & 0x70) >> 4) + 1;\n\t\tg->sort_flag = (tmp & 8) >> 3;\n\t\tg->imgbits = (tmp & 7) + 1;\t/* Global Palette color resolution */\n\t\tg->ncolors = 1 << g->imgbits;\n\n\t\tg->backgroundindex = GetByte(g);\n\n#if !defined(NGIFLIB_NO_FILE)\n\t\tif(g->log) fprintf(g->log, \"%hux%hu %hhubits %hu couleurs  bg=%hhu\\n\",\n\t\t                   g->width, g->height, g->imgbits, g->ncolors, g->backgroundindex);\n#endif /* NGIFLIB_INDEXED_ONLY */\n\n\t\tg->pixaspectratio = GetByte(g);\t/* pixel aspect ratio (0 : unspecified) */\n\n\t\tif(tmp&0x80) {\n\t\t\t/* la palette globale suit. */\n\t\t\tg->palette = (struct ngiflib_rgb *)ngiflib_malloc(sizeof(struct ngiflib_rgb)*g->ncolors);\n\t\t\tfor(i=0; i<g->ncolors; i++) {\n\t\t\t\tg->palette[i].r = GetByte(g);\n\t\t\t\tg->palette[i].g = GetByte(g);\n\t\t\t\tg->palette[i].b = GetByte(g);\n#if defined(DEBUG) && !defined(NGIFLIB_NO_FILE)\n\t\t\t\tif(g->log) fprintf(g->log, \"%3d %02X %02X %02X\\n\", i, g->palette[i].r,g->palette[i].g,g->palette[i].b);\n#endif /* defined(DEBUG) && !defined(NGIFLIB_NO_FILE) */\n\t\t\t}\n#ifdef NGIFLIB_ENABLE_CALLBACKS\n\t\t\tif(g->palette_cb) g->palette_cb(g, g->palette, g->ncolors);\n#endif /* NGIFLIB_ENABLE_CALLBACKS */\n\t\t} else {\n\t\t\tg->palette = NULL;\n\t\t}\n\t\tg->netscape_loop_count = -1;\n\t}\n\n\tfor(;;) {\n\t\tchar appid_auth[11];\n\t\tu8 id,size;\n\t\tint blockindex;\n\n\t\tsign = GetByte(g);\t/* signature du prochain bloc */\n#if !defined(NGIFLIB_NO_FILE)\n\t\tif(g->log) fprintf(g->log, \"BLOCK SIGNATURE 0x%02X '%c'\\n\", sign, (sign >= 32) ? sign : '.');\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\tswitch(sign) {\n\t\tcase 0x3B:\t/* END OF GIF */\n\t\t\treturn 0;\n\t\tcase '!':\t/* Extension introducer 0x21 */\n\t\t\tid = GetByte(g);\n\t\t\tblockindex = 0;\n#if !defined(NGIFLIB_NO_FILE)\n\t\t\tif(g->log) fprintf(g->log, \"extension (id=0x%02hhx)\\n\", id);\n#endif /* NGIFLIB_NO_FILE */\n\t\t\twhile( (size = GetByte(g)) ) {\n\t\t\t\tu8 ext[256];\n\n\t\t\t\tGetByteStr(g, ext, size);\n\n\t\t\t\tswitch(id) {\n\t\t\t\tcase 0xF9:\t/* Graphic Control Extension */\n\t\t\t\t\t/* The scope of this extension is the first graphic\n\t\t\t\t\t * rendering block to follow. */\n\t\t\t\t\tgce.gce_present = 1;\n\t\t\t\t\tgce.disposal_method = (ext[0] >> 2) & 7;\n\t\t\t\t\tgce.transparent_flag = ext[0] & 1;\n\t\t\t\t\tgce.user_input_flag = (ext[0] >> 1) & 1;\n\t\t\t\t\tgce.delay_time = ext[1] | (ext[2]<<8);\n\t\t\t\t\tgce.transparent_color = ext[3];\n#if !defined(NGIFLIB_NO_FILE)\n\t\t\t\t\tif(g->log) fprintf(g->log, \"disposal_method=%hhu delay_time=%hu (transp=%hhu)transparent_color=0x%02hhX\\n\",\n\t\t\t\t\t       gce.disposal_method, gce.delay_time, gce.transparent_flag, gce.transparent_color);\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\t\t\t\t/* this propably should be adjusted depending on the disposal_method\n\t\t\t\t\t * of the _previous_ image. */\n\t\t\t\t\tif(gce.transparent_flag && ((g->nimg == 0) || gce.disposal_method == 2)) {\n\t\t\t\t\t\tFillGifBackGround(g);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xFE:\t/* Comment Extension. */\n#if !defined(NGIFLIB_NO_FILE)\n\t\t\t\t\tif(g->log) {\n\t\t\t\t\t\tif(blockindex==0) fprintf(g->log, \"-------------------- Comment extension --------------------\\n\");\n\t\t\t\t\t\text[size] = '\\0';\n\t\t\t\t\t\tfputs((char *)ext, g->log);\n\t\t\t\t\t}\n#endif /* NGIFLIB_NO_FILE */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xFF:\t/* application extension */\n\t\t\t\t\t/* NETSCAPE2.0 extension :\n\t\t\t\t\t * http://www.vurdalakov.net/misc/gif/netscape-looping-application-extension */\n\t\t\t\t\tif(blockindex==0) {\n\t\t\t\t\t\tngiflib_memcpy(appid_auth, ext, 11);\n#if !defined(NGIFLIB_NO_FILE)\n\t\t\t\t\t\tif(g->log) {\n\t\t\t\t\t\t\tfprintf(g->log, \"---------------- Application extension ---------------\\n\");\n\t\t\t\t\t\t\tfprintf(g->log, \"Application identifier : '%.8s', auth code : %02X %02X %02X (\",\n\t\t\t\t\t\t\t        appid_auth, ext[8], ext[9], ext[10]);\n\t\t\t\t\t\t\tfputc((ext[8]<32)?' ':ext[8], g->log);\n\t\t\t\t\t\t\tfputc((ext[9]<32)?' ':ext[9], g->log);\n\t\t\t\t\t\t\tfputc((ext[10]<32)?' ':ext[10], g->log);\n\t\t\t\t\t\t\tfprintf(g->log, \")\\n\");\n\t\t\t\t\t\t}\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\t\t\t\t} else {\n#if !defined(NGIFLIB_NO_FILE)\n\t\t\t\t\t\tif(g->log) {\n\t\t\t\t\t\t\tfprintf(g->log, \"Datas (as hex) : \");\n\t\t\t\t\t\t\tfor(i=0; i<size; i++) {\n\t\t\t\t\t\t\t\tfprintf(g->log, \"%02x \", ext[i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfprintf(g->log, \"\\nDatas (as text) : '\");\n\t\t\t\t\t\t\tfor(i=0; i<size; i++) {\n\t\t\t\t\t\t\t\tputc((ext[i]<32)?' ':ext[i], g->log);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfprintf(g->log, \"'\\n\");\n\t\t\t\t\t\t}\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\t\t\t\t\tif(0 == ngiflib_memcmp(appid_auth, \"NETSCAPE2.0\", 11)) {\n\t\t\t\t\t\t\t/* ext[0] : Sub-block ID */\n\t\t\t\t\t\t\tif(ext[0] == 1) {\n\t\t\t\t\t\t\t\t/* 1 : Netscape Looping Extension. */\n\t\t\t\t\t\t\t\tg->netscape_loop_count = (int)ext[1] | ((int)ext[2] << 8);\n#if !defined(NGIFLIB_NO_FILE)\n\t\t\t\t\t\t\t\tif(g->log) {\n\t\t\t\t\t\t\t\t\tfprintf(g->log, \"NETSCAPE loop_count = %d\\n\", g->netscape_loop_count);\n\t\t\t\t\t\t\t\t}\n#endif /* NGIFLIB_NO_FILE */\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x01:\t/* plain text extension */\n#if !defined(NGIFLIB_NO_FILE)\n\t\t\t\t\tif(g->log) {\n\t\t\t\t\t\tfprintf(g->log, \"Plain text extension   blockindex=%d\\n\", blockindex);\n\t\t\t\t\t\tfor(i=0; i<size; i++) {\n\t\t\t\t\t\t\tputc((ext[i]<32)?' ':ext[i], g->log);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tputc('\\n', g->log);\n\t\t\t\t\t}\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tblockindex++;\n\t\t\t}\n\t\t\tswitch(id) {\n\t\t\tcase 0x01:\t/* plain text extension */\n\t\t\tcase 0xFE:\t/* Comment Extension. */\n\t\t\tcase 0xFF:\t/* application extension */\n#if !defined(NGIFLIB_NO_FILE)\n\t\t\t\tif(g->log) {\n\t\t\t\t\tfprintf(g->log, \"-----------------------------------------------------------\\n\");\n\t\t\t\t}\n#endif /* NGIFLIB_NO_FILE */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x2C:\t/* Image separator */\n\t\t\tif(g->nimg==0) {\n\t\t\t\tg->cur_img = ngiflib_malloc(sizeof(struct ngiflib_img));\n\t\t\t\tg->first_img = g->cur_img;\n\t\t\t} else {\n\t\t\t\tg->cur_img->next = ngiflib_malloc(sizeof(struct ngiflib_img));\n\t\t\t\tg->cur_img = g->cur_img->next;\n\t\t\t}\n\t\t\tg->cur_img->next = NULL;\n\t\t\tg->cur_img->parent = g;\n\t\t\tif(gce.gce_present) {\n\t\t\t\tngiflib_memcpy(&g->cur_img->gce, &gce, sizeof(struct ngiflib_gce));\n\t\t\t} else {\n\t\t\t\tngiflib_memset(&g->cur_img->gce, 0,  sizeof(struct ngiflib_gce));\n\t\t\t}\n\t\t\tDecodeGifImg(g->cur_img);\n\t\t\tg->nimg++;\n\n\t\t\ttmp = GetByte(g);/* 0 final */\n#if !defined(NGIFLIB_NO_FILE)\n\t\t\tif(g->log) fprintf(g->log, \"ZERO TERMINATOR 0x%02X\\n\", tmp);\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\t\treturn 1;\t/* image decod\ufffde */\n\t\tdefault:\n\t\t\t/* unexpected byte */\n#if !defined(NGIFLIB_NO_FILE)\n\t\t\tif(g->log) fprintf(g->log, \"unexpected signature 0x%02X\\n\", sign);\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\t\treturn -1;\n\t\t}\n\t}\n}\n\nu32 GifIndexToTrueColor(struct ngiflib_rgb * palette, u8 v) {\n\treturn palette[v].b | (palette[v].g << 8) | (palette[v].r << 16);\n}\n"], "fixing_code": ["#ifndef NGIFLIB_NO_FILE\n#include <stdio.h>\n#endif /* NGIFLIB_NO_FILE */\n\n#include \"ngiflib.h\"\n\n/* decodeur GIF en C portable (pas de pb big/little endian)\n * Thomas BERNARD. janvier 2004.\n * (c) 2004-2017 Thomas Bernard. All rights reserved\n */\n\n/* Fonction de debug */\n#ifdef DEBUG\nvoid fprintf_ngiflib_img(FILE * f, struct ngiflib_img * i) {\n\tfprintf(f, \"  * ngiflib_img @ %p\\n\", i);\n\tfprintf(f, \"    next = %p\\n\", i->next);\n\tfprintf(f, \"    parent = %p\\n\", i->parent);\n\tfprintf(f, \"    palette = %p\\n\", i->palette);\n\tfprintf(f, \"    %3d couleurs\", i->ncolors);\n\tif(i->interlaced) fprintf(f, \" interlaced\");\n\tfprintf(f, \"\\n    taille : %dx%d, pos (%d,%d)\\n\", i->width, i->height, i->posX, i->posY);\n\tfprintf(f, \"    sort_flag=%x localpalbits=%d\\n\", i->sort_flag, i->localpalbits);\n}\n#endif /* DEBUG */\n\nvoid GifImgDestroy(struct ngiflib_img * i) {\n\tif(i==NULL) return;\n\tif(i->next) GifImgDestroy(i->next);\n\tif(i->palette && (i->palette != i->parent->palette))\n\t  ngiflib_free(i->palette);\n\tngiflib_free(i);\n}\n\n/* Fonction de debug */\n#ifdef DEBUG\nvoid fprintf_ngiflib_gif(FILE * f, struct ngiflib_gif * g) {\n\tstruct ngiflib_img * i;\n\tfprintf(f, \"* ngiflib_gif @ %p %s\\n\", g, g->signature);\n\tfprintf(f, \"  %dx%d, %d bits, %d couleurs\\n\", g->width, g->height, g->imgbits, g->ncolors);\n\tfprintf(f, \"  palette = %p, backgroundcolorindex %d\\n\", g->palette, g->backgroundindex);\n\tfprintf(f, \"  pixelaspectratio = %d\\n\", g->pixaspectratio);\n\tfprintf(f, \"  frbuff = %p\\n\", g->frbuff.p8);\n\t\n\tfprintf(f, \"  cur_img = %p\\n\", g->cur_img);\n\tfprintf(f, \"  %d images :\\n\", g->nimg);\n\ti = g->first_img;\n\twhile(i) {\n\t\tfprintf_ngiflib_img(f, i);\n\t\ti = i->next;\n\t}\n}\n#endif /* DEBUG */\n\nvoid GifDestroy(struct ngiflib_gif * g) {\n\tif(g==NULL) return;\n\tif(g->palette) ngiflib_free(g->palette);\n\tif(g->frbuff.p8) ngiflib_free(g->frbuff.p8);\n\tGifImgDestroy(g->first_img);\n\tngiflib_free(g);\n}\n\n/* u8 GetByte(struct ngiflib_gif * g);\n * fonction qui renvoie un octet du fichier .gif\n * on pourait optimiser en faisant 2 fonctions.\n */\nstatic u8 GetByte(struct ngiflib_gif * g) {\n#ifndef NGIFLIB_NO_FILE\n\tif(g->mode & NGIFLIB_MODE_FROM_MEM) {\n#endif /* NGIFLIB_NO_FILE */\n\t\treturn *(g->input.bytes++);\n#ifndef NGIFLIB_NO_FILE\n\t} else {\n\t\treturn (u8)(getc(g->input.file));\n\t}\n#endif /* NGIFLIB_NO_FILE */\n}\n\n/* u16 GetWord()\n * Renvoie un mot de 16bits\n * N'est pas influencee par l'endianess du CPU !\n */\nstatic u16 GetWord(struct ngiflib_gif * g) {\n\tu16 r = (u16)GetByte(g);\n\tr |= ((u16)GetByte(g) << 8);\n\treturn r;\n}\n\n/* int GetByteStr(struct ngiflib_gif * g, u8 * p, int n);\n * prend en argument un pointeur sur la destination\n * et le nombre d'octet a lire.\n * Renvoie 0 si l'operation a reussi, -1 sinon.\n */\nstatic int GetByteStr(struct ngiflib_gif * g, u8 * p, int n) {\n\tif(!p) return -1;\n#ifndef NGIFLIB_NO_FILE\n\tif(g->mode & NGIFLIB_MODE_FROM_MEM) {\n#endif /* NGIFLIB_NO_FILE */\n\t\tngiflib_memcpy(p, g->input.bytes, n);\n\t\tg->input.bytes += n;\n\t\treturn 0;\n#ifndef NGIFLIB_NO_FILE\n\t} else {\n\t\tsize_t read;\n\t\tread = fread(p, 1, n, g->input.file);\n\t\treturn ((int)read == n) ? 0 : -1;\n\t}\n#endif /* NGIFLIB_NO_FILE */\n}\n\n/* void WritePixel(struct ngiflib_img * i, u8 v);\n * ecrit le pixel de valeur v dans le frame buffer\n */\nstatic void WritePixel(struct ngiflib_img * i, struct ngiflib_decode_context * context, u8 v) {\n\tstruct ngiflib_gif * p = i->parent;\n\n\tif(v!=i->gce.transparent_color || !i->gce.transparent_flag) {\n#ifndef NGIFLIB_INDEXED_ONLY\n\t\tif(p->mode & NGIFLIB_MODE_INDEXED) {\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\t\t*context->frbuff_p.p8 = v;\n#ifndef NGIFLIB_INDEXED_ONLY\n\t\t} else\n\t\t\t*context->frbuff_p.p32 =\n\t\t\t   GifIndexToTrueColor(i->palette, v);\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t}\n\tif(--(context->Xtogo) <= 0) {\n\t\t#ifdef NGIFLIB_ENABLE_CALLBACKS\n\t\tif(p->line_cb) p->line_cb(p, context->line_p, context->curY);\n\t\t#endif /* NGIFLIB_ENABLE_CALLBACKS */\n\t\tcontext->Xtogo = i->width;\n\t\tswitch(context->pass) {\n\t\tcase 0:\n\t\t\tcontext->curY++;\n\t\t\tbreak;\n\t\tcase 1:\t/* 1st pass : every eighth row starting from 0 */\n\t\t\tcontext->curY += 8;\n\t\t\tif(context->curY >= p->height) {\n\t\t\t\tcontext->pass++;\n\t\t\t\tcontext->curY = i->posY + 4;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\t/* 2nd pass : every eighth row starting from 4 */\n\t\t\tcontext->curY += 8;\n\t\t\tif(context->curY >= p->height) {\n\t\t\t\tcontext->pass++;\n\t\t\t\tcontext->curY = i->posY + 2;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3:\t/* 3rd pass : every fourth row starting from 2 */\n\t\t\tcontext->curY += 4;\n\t\t\tif(context->curY >= p->height) {\n\t\t\t\tcontext->pass++;\n\t\t\t\tcontext->curY = i->posY + 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 4:\t/* 4th pass : every odd row */\n\t\t\tcontext->curY += 2;\n\t\t\tbreak;\n\t\t}\n#ifndef NGIFLIB_INDEXED_ONLY\n\t\tif(p->mode & NGIFLIB_MODE_INDEXED) {\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\t\t#ifdef NGIFLIB_ENABLE_CALLBACKS\n\t\t\tcontext->line_p.p8 = p->frbuff.p8 + (u32)context->curY*p->width;\n\t\t\tcontext->frbuff_p.p8 = context->line_p.p8 + i->posX;\n\t\t\t#else\n\t\t\tcontext->frbuff_p.p8 = p->frbuff.p8 + (u32)context->curY*p->width + i->posX;\n\t\t\t#endif /* NGIFLIB_ENABLE_CALLBACKS */\n#ifndef NGIFLIB_INDEXED_ONLY\n\t\t} else {\n\t\t\t#ifdef NGIFLIB_ENABLE_CALLBACKS\n\t\t\tcontext->line_p.p32 = p->frbuff.p32 + (u32)context->curY*p->width;\n\t\t\tcontext->frbuff_p.p32 = context->line_p.p32 + i->posX;\n\t\t\t#else\n\t\t\tcontext->frbuff_p.p32 = p->frbuff.p32 + (u32)context->curY*p->width + i->posX;\n\t\t\t#endif /* NGIFLIB_ENABLE_CALLBACKS */\n\t\t}\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t} else {\n#ifndef NGIFLIB_INDEXED_ONLY\n\t\tif(p->mode & NGIFLIB_MODE_INDEXED) {\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\t\tcontext->frbuff_p.p8++;\n#ifndef NGIFLIB_INDEXED_ONLY\n\t\t} else {\n\t\t\tcontext->frbuff_p.p32++;\n\t\t}\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t}\n}\n\n/* void WritePixels(struct ngiflib_img * i, const u8 * pixels, u16 n);\n * ecrit les pixels dans le frame buffer\n */\nstatic void WritePixels(struct ngiflib_img * i, struct ngiflib_decode_context * context, const u8 * pixels, u16 n) {\n\tu16 tocopy;\t\n\tstruct ngiflib_gif * p = i->parent;\n\n\twhile(n > 0) {\n\t\ttocopy = (context->Xtogo < n) ? context->Xtogo : n;\n\t\tif(!i->gce.transparent_flag) {\n#ifndef NGIFLIB_INDEXED_ONLY\n\t\t\tif(p->mode & NGIFLIB_MODE_INDEXED) {\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\t\t\tngiflib_memcpy(context->frbuff_p.p8, pixels, tocopy);\n\t\t\t\tpixels += tocopy;\n\t\t\t\tcontext->frbuff_p.p8 += tocopy;\n#ifndef NGIFLIB_INDEXED_ONLY\n\t\t\t} else {\n\t\t\t\tint j;\n\t\t\t\tfor(j = (int)tocopy; j > 0; j--) {\n\t\t\t\t\t*(context->frbuff_p.p32++) =\n\t\t\t\t\t   GifIndexToTrueColor(i->palette, *pixels++);\n\t\t\t\t}\n\t\t\t}\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\t} else {\n\t\t\tint j;\n#ifndef NGIFLIB_INDEXED_ONLY\n\t\t\tif(p->mode & NGIFLIB_MODE_INDEXED) {\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\t\t\tfor(j = (int)tocopy; j > 0; j--) {\n\t\t\t\t\tif(*pixels != i->gce.transparent_color) *context->frbuff_p.p8 = *pixels;\n\t\t\t\t\tpixels++;\n\t\t\t\t\tcontext->frbuff_p.p8++;\n\t\t\t\t}\n#ifndef NGIFLIB_INDEXED_ONLY\n\t\t\t} else {\n\t\t\t\tfor(j = (int)tocopy; j > 0; j--) {\n\t\t\t\t\tif(*pixels != i->gce.transparent_color) {\n\t\t\t\t\t\t*context->frbuff_p.p32 = GifIndexToTrueColor(i->palette, *pixels);\n\t\t\t\t\t}\n\t\t\t\t\tpixels++;\n\t\t\t\t\tcontext->frbuff_p.p32++;\n\t\t\t\t}\n\t\t\t}\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\t}\n\t\tcontext->Xtogo -= tocopy;\n\t\tif(context->Xtogo == 0) {\n\t\t\t#ifdef NGIFLIB_ENABLE_CALLBACKS\n\t\t\tif(p->line_cb) p->line_cb(p, context->line_p, context->curY);\n\t\t\t#endif /* NGIFLIB_ENABLE_CALLBACKS */\n\t\t\tcontext->Xtogo = i->width;\n\t\t\tswitch(context->pass) {\n\t\t\tcase 0:\n\t\t\t\tcontext->curY++;\n\t\t\t\tbreak;\n\t\t\tcase 1:\t/* 1st pass : every eighth row starting from 0 */\n\t\t\t\tcontext->curY += 8;\n\t\t\t\tif(context->curY >= p->height) {\n\t\t\t\t\tcontext->pass++;\n\t\t\t\t\tcontext->curY = i->posY + 4;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\t/* 2nd pass : every eighth row starting from 4 */\n\t\t\t\tcontext->curY += 8;\n\t\t\t\tif(context->curY >= p->height) {\n\t\t\t\t\tcontext->pass++;\n\t\t\t\t\tcontext->curY = i->posY + 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 3:\t/* 3rd pass : every fourth row starting from 2 */\n\t\t\t\tcontext->curY += 4;\n\t\t\t\tif(context->curY >= p->height) {\n\t\t\t\t\tcontext->pass++;\n\t\t\t\t\tcontext->curY = i->posY + 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 4:\t/* 4th pass : every odd row */\n\t\t\t\tcontext->curY += 2;\n\t\t\t\tbreak;\n\t\t\t}\n#ifndef NGIFLIB_INDEXED_ONLY\n\t\t\tif(p->mode & NGIFLIB_MODE_INDEXED) {\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\t\t\t#ifdef NGIFLIB_ENABLE_CALLBACKS\n\t\t\t\tcontext->line_p.p8 = p->frbuff.p8 + (u32)context->curY*p->width;\n\t\t\t\tcontext->frbuff_p.p8 = context->line_p.p8 + i->posX;\n\t\t\t\t#else\n\t\t\t\tcontext->frbuff_p.p8 = p->frbuff.p8 + (u32)context->curY*p->width + i->posX;\n\t\t\t\t#endif /* NGIFLIB_ENABLE_CALLBACKS */\n#ifndef NGIFLIB_INDEXED_ONLY\n\t\t\t} else {\n\t\t\t\t#ifdef NGIFLIB_ENABLE_CALLBACKS\n\t\t\t\tcontext->line_p.p32 = p->frbuff.p32 + (u32)context->curY*p->width;\n\t\t\t\tcontext->frbuff_p.p32 = context->line_p.p32 + i->posX;\n\t\t\t\t#else\n\t\t\t\tcontext->frbuff_p.p32 = p->frbuff.p32 + (u32)context->curY*p->width + i->posX;\n\t\t\t\t#endif /* NGIFLIB_ENABLE_CALLBACKS */\n\t\t\t}\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\t}\n\t\tn -= tocopy;\n\t}\n}\n\n/*\n * u16 GetGifWord(struct ngiflib_img * i);\n * Renvoie un code LZW (taille variable)\n */\nstatic u16 GetGifWord(struct ngiflib_img * i, struct ngiflib_decode_context * context) {\n\tu16 r;\n\tint bits_todo;\n\tu16 newbyte;\n\n\tbits_todo = (int)context->nbbit - (int)context->restbits;\n\tif( bits_todo <= 0) {\t/* nbbit <= restbits */\n\t\tr = context->lbyte;\n\t\tcontext->restbits -= context->nbbit;\n\t\tcontext->lbyte >>= context->nbbit;\n\t} else if( bits_todo > 8 ) {\t/* nbbit > restbits + 8 */\n\t\tif(context->restbyte >= 2) {\n\t\t\tcontext->restbyte -= 2;\n\t\t\tr = *context->srcbyte++;\n\t\t} else {\n\t\t\tif(context->restbyte == 0) {\n\t\t\t\tcontext->restbyte = GetByte(i->parent);\n#if defined(DEBUG) && !defined(NGIFLIB_NO_FILE)\n\t\t\t\tif(i->parent->log) fprintf(i->parent->log, \"restbyte = %02X\\n\", context->restbyte);\n#endif /* defined(DEBUG) && !defined(NGIFLIB_NO_FILE) */\n\t\t\t\tGetByteStr(i->parent, context->byte_buffer, context->restbyte);\n\t\t\t\tcontext->srcbyte = context->byte_buffer;\n\t\t\t}\n\t\t\tr = *context->srcbyte++;\n\t\t\tif(--context->restbyte == 0) {\n\t\t\t\tcontext->restbyte = GetByte(i->parent);\n#if defined(DEBUG) && !defined(NGIFLIB_NO_FILE)\n\t\t\t\tif(i->parent->log) fprintf(i->parent->log, \"restbyte = %02X\\n\", context->restbyte);\n#endif /* defined(DEBUG) && !defined(NGIFLIB_NO_FILE) */\n\t\t\t\tGetByteStr(i->parent, context->byte_buffer, context->restbyte);\n\t\t\t\tcontext->srcbyte = context->byte_buffer;\n\t\t\t}\n\t\t\tcontext->restbyte--;\n\t\t}\n\t\tnewbyte = *context->srcbyte++;\n\t\tr |= newbyte << 8;\n\t\tr = (r << context->restbits) | context->lbyte;\n\t\tcontext->restbits = 16 - bits_todo;\n\t\tcontext->lbyte = newbyte >> (bits_todo - 8);\n\t} else /*if( bits_todo > 0 )*/ { /* nbbit > restbits */\n\t\tif(context->restbyte == 0) {\n\t\t\tcontext->restbyte = GetByte(i->parent);\n#if defined(DEBUG) && !defined(NGIFLIB_NO_FILE)\n\t\t\tif(i->parent->log) fprintf(i->parent->log, \"restbyte = %02X\\n\", context->restbyte);\n#endif /* defined(DEBUG) && !defined(NGIFLIB_NO_FILE) */\n\t\t\tGetByteStr(i->parent, context->byte_buffer, context->restbyte);\n\t\t\tcontext->srcbyte = context->byte_buffer;\n\t\t}\n\t\tnewbyte = *context->srcbyte++;\n\t\tcontext->restbyte--;\n\t\tr = (newbyte << context->restbits) | context->lbyte;\n\t\tcontext->restbits = 8 - bits_todo;\n\t\tcontext->lbyte = newbyte >> bits_todo;\n\t}\n\treturn (r & context->max);\t/* applique le bon masque pour eliminer les bits en trop */\n}\n\n/* ------------------------------------------------ */\nstatic void FillGifBackGround(struct ngiflib_gif * g) {\n\tlong n = (long)g->width*g->height;\n#ifndef NGIFLIB_INDEXED_ONLY\n\tu32 bg_truecolor;\n#endif /* NGIFLIB_INDEXED_ONLY */\n\n\tif((g->frbuff.p8==NULL)||(g->palette==NULL)) return;\n#ifndef NGIFLIB_INDEXED_ONLY\n\tif(g->mode & NGIFLIB_MODE_INDEXED) {\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\tngiflib_memset(g->frbuff.p8, g->backgroundindex, n);\n#ifndef NGIFLIB_INDEXED_ONLY\n\t} else {\n\t\tu32 * p = g->frbuff.p32;\n\t\tbg_truecolor = GifIndexToTrueColor(g->palette, g->backgroundindex);\n\t\twhile(n-->0) *p++ = bg_truecolor;\n\t}\n#endif /* NGIFLIB_INDEXED_ONLY */\n}\n\n/* ------------------------------------------------ */\nint CheckGif(u8 * b) {\n\treturn (b[0]=='G')&&(b[1]=='I')&&(b[2]=='F')&&(b[3]=='8');\n}\n\n/* ------------------------------------------------ */\nstatic int DecodeGifImg(struct ngiflib_img * i) {\n\tstruct ngiflib_decode_context context;\n\tlong npix;\n\tu8 * stackp;\n\tu8 * stack_top;\n\tu16 clr;\n\tu16 eof;\n\tu16 free;\n\tu16 act_code = 0;\n\tu16 old_code = 0;\n\tu16 read_byt;\n\tu16 ab_prfx[4096];\n\tu8 ab_suffx[4096];\n\tu8 ab_stack[4096];\n\tu8 flags;\n\tu8 casspecial = 0;\n\n\tif(!i) return -1;\n\n\ti->posX = GetWord(i->parent);\t/* offsetX */\n\ti->posY = GetWord(i->parent);\t/* offsetY */\n\ti->width = GetWord(i->parent);\t/* SizeX   */\n\ti->height = GetWord(i->parent);\t/* SizeY   */\n\n\tif((i->width > i->parent->width) || (i->height > i->parent->height)) {\n#if !defined(NGIFLIB_NO_FILE)\n\t\tif(i->parent->log) fprintf(i->parent->log, \"*** ERROR *** Image bigger than global GIF canvas !\\n\");\n#endif\n\t\treturn -1;\n\t}\n\tif((i->posX + i->width) > i->parent->width) {\n#if !defined(NGIFLIB_NO_FILE)\n\t\tif(i->parent->log) fprintf(i->parent->log, \"*** WARNING *** Adjusting X position\\n\");\n#endif\n\t\ti->posX = i->parent->width - i->width;\n\t}\n\tif((i->posY + i->height) > i->parent->height) {\n#if !defined(NGIFLIB_NO_FILE)\n\t\tif(i->parent->log) fprintf(i->parent->log, \"*** WARNING *** Adjusting Y position\\n\");\n#endif\n\t\ti->posY = i->parent->height - i->height;\n\t}\n\tcontext.Xtogo = i->width;\n\tcontext.curY = i->posY;\n#ifdef NGIFLIB_INDEXED_ONLY\n\t#ifdef NGIFLIB_ENABLE_CALLBACKS\n\tcontext.line_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width;\n\tcontext.frbuff_p.p8 = context.line_p.p8 + i->posX;\n\t#else\n\tcontext.frbuff_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width + i->posX;\n\t#endif /* NGIFLIB_ENABLE_CALLBACKS */\n#else\n\tif(i->parent->mode & NGIFLIB_MODE_INDEXED) {\n\t\t#ifdef NGIFLIB_ENABLE_CALLBACKS\n\t\tcontext.line_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width;\n\t\tcontext.frbuff_p.p8 = context.line_p.p8 + i->posX;\n\t\t#else\n\t\tcontext.frbuff_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width + i->posX;\n\t\t#endif /* NGIFLIB_ENABLE_CALLBACKS */\n\t} else {\n\t\t#ifdef NGIFLIB_ENABLE_CALLBACKS\n\t\tcontext.line_p.p32 = i->parent->frbuff.p32 + (u32)i->posY*i->parent->width;\n\t\tcontext.frbuff_p.p32 = context.line_p.p32 + i->posX;\n\t\t#else\n\t\tcontext.frbuff_p.p32 = i->parent->frbuff.p32 + (u32)i->posY*i->parent->width + i->posX;\n\t\t#endif /* NGIFLIB_ENABLE_CALLBACKS */\n\t}\n#endif /* NGIFLIB_INDEXED_ONLY */\n\n\tnpix = (long)i->width * i->height;\n\tflags = GetByte(i->parent);\n\ti->interlaced = (flags & 64) >> 6;\n\tcontext.pass = i->interlaced ? 1 : 0;\n\ti->sort_flag = (flags & 32) >> 5;\t/* is local palette sorted by color frequency ? */\n\ti->localpalbits = (flags & 7) + 1;\n\tif(flags&128) { /* palette locale */\n\t\tint k;\n\t\tint localpalsize = 1 << i->localpalbits;\n#if !defined(NGIFLIB_NO_FILE)\n\t\tif(i->parent && i->parent->log) fprintf(i->parent->log, \"Local palette\\n\");\n#endif /* !defined(NGIFLIB_NO_FILE) */\n\t\ti->palette = (struct ngiflib_rgb *)ngiflib_malloc(sizeof(struct ngiflib_rgb)*localpalsize);\n\t\tfor(k=0; k<localpalsize; k++) {\n\t\t\ti->palette[k].r = GetByte(i->parent);\n\t\t\ti->palette[k].g = GetByte(i->parent);\n\t\t\ti->palette[k].b = GetByte(i->parent);\n\t\t}\n#ifdef NGIFLIB_ENABLE_CALLBACKS\n\t\tif(i->parent->palette_cb) i->parent->palette_cb(i->parent, i->palette, localpalsize);\n#endif /* NGIFLIB_ENABLE_CALLBACKS */\n\t} else {\n\t\ti->palette = i->parent->palette;\n\t\ti->localpalbits = i->parent->imgbits;\n\t}\n\ti->ncolors = 1 << i->localpalbits;\n\t\n\ti->imgbits = GetByte(i->parent);\t/* LZW Minimum Code Size */\n\n#if !defined(NGIFLIB_NO_FILE)\n\tif(i->parent && i->parent->log) {\n\t\tif(i->interlaced) fprintf(i->parent->log, \"interlaced \");\n\t\tfprintf(i->parent->log, \"img pos(%hu,%hu) size %hux%hu palbits=%hhu imgbits=%hhu ncolors=%hu\\n\",\n\t       i->posX, i->posY, i->width, i->height, i->localpalbits, i->imgbits, i->ncolors);\n\t}\n#endif /* !defined(NGIFLIB_NO_FILE) */\n\n\tif(i->imgbits==1) {\t/* fix for 1bit images ? */\n\t\ti->imgbits = 2;\n\t}\n\tclr = 1 << i->imgbits;\n\teof = clr + 1;\n\tfree = clr + 2;\n\tcontext.nbbit = i->imgbits + 1;\n\tcontext.max = clr + clr - 1; /* (1 << context.nbbit) - 1 */\n\tstackp = stack_top = ab_stack + 4096;\n\t\n\tcontext.restbits = 0;\t/* initialise le \"buffer\" de lecture */\n\tcontext.restbyte = 0;\t/* des codes LZW */\n\tcontext.lbyte = 0;\n\tfor(;;) {\n\t\tact_code = GetGifWord(i, &context);\n\t\tif(act_code==eof) {\n#if !defined(NGIFLIB_NO_FILE)\n\t\t\tif(i->parent && i->parent->log) fprintf(i->parent->log, \"End of image code\\n\");\n#endif /* !defined(NGIFLIB_NO_FILE) */\n\t\t\treturn 0;\n\t\t}\n\t\tif(npix==0) {\n#if !defined(NGIFLIB_NO_FILE)\n\t\t\tif(i->parent && i->parent->log) fprintf(i->parent->log, \"assez de pixels, On se casse !\\n\");\n#endif /* !defined(NGIFLIB_NO_FILE) */\n\t\t\treturn 1;\n\t\t}\t\n\t\tif(act_code==clr) {\n#if !defined(NGIFLIB_NO_FILE)\n\t\t\tif(i->parent && i->parent->log) fprintf(i->parent->log, \"Code clear (free=%hu) npix=%ld\\n\", free, npix);\n#endif /* !defined(NGIFLIB_NO_FILE) */\n\t\t\t/* clear */\n\t\t\tfree = clr + 2;\n\t\t\tcontext.nbbit = i->imgbits + 1;\n\t\t\tcontext.max = clr + clr - 1; /* (1 << context.nbbit) - 1 */\n\t\t\tact_code = GetGifWord(i, &context);\n\t\t\tcasspecial = (u8)act_code;\n\t\t\told_code = act_code;\n\t\t\tif(npix > 0) WritePixel(i, &context, casspecial);\n\t\t\tnpix--;\n\t\t} else {\n\t\t\tread_byt = act_code;\n\t\t\tif(act_code >= free) {\t/* code pas encore dans alphabet */\n/*\t\t\t\tprintf(\"Code pas dans alphabet : %d>=%d push %d\\n\", act_code, free, casspecial); */\n\t\t\t\t*(--stackp) = casspecial; /* dernier debut de chaine ! */\n\t\t\t\tact_code = old_code;\n\t\t\t}\n/*\t\t\tprintf(\"actcode=%d\\n\", act_code); */\n\t\t\twhile(act_code > clr) { /* code non concret */\n\t\t\t\t/* fillstackloop empile les suffixes ! */\n\t\t\t\t*(--stackp) = ab_suffx[act_code];\n\t\t\t\tact_code = ab_prfx[act_code];\t/* prefixe */\n\t\t\t}\n\t\t\t/* act_code est concret */\n\t\t\tcasspecial = (u8)act_code;\t/* dernier debut de chaine ! */\n\t\t\t*(--stackp) = casspecial;\t/* push on stack */\n\t\t\tif(npix >= (stack_top - stackp)) {\n\t\t\t\tWritePixels(i, &context, stackp, stack_top - stackp);\t/* unstack all pixels at once */\n\t\t\t} else if(npix > 0) {\t/* \"pixel overflow\" */\n\t\t\t\tWritePixels(i, &context, stackp, npix);\n\t\t\t}\n\t\t\tnpix -= (stack_top - stackp);\n\t\t\tstackp = stack_top;\n/*\t\t\tputchar('\\n'); */\n\t\t\tif(free < 4096) { /* la taille du dico est 4096 max ! */\n\t\t\t\tab_prfx[free] = old_code;\n\t\t\t\tab_suffx[free] = (u8)act_code;\n\t\t\t\tfree++;\n\t\t\t\tif((free > context.max) && (context.nbbit < 12)) {\n\t\t\t\t\tcontext.nbbit++;\t/* 1 bit de plus pour les codes LZW */\n\t\t\t\t\tcontext.max += context.max + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\told_code = read_byt;\n\t\t}\n\t\t\t\n\t}\n\treturn 0;\n}\n\n/* ------------------------------------------------ \n * int LoadGif(struct ngiflib_gif *);\n * s'assurer que nimg=0 au depart !\n * retourne : \n *    0 si GIF termin\ufffd\n *    un nombre negatif si ERREUR\n *    1 si image Decod\ufffde\n * rappeler pour decoder les images suivantes\n * ------------------------------------------------ */\nint LoadGif(struct ngiflib_gif * g) {\n\tstruct ngiflib_gce gce;\n\tu8 sign;\n\tu8 tmp;\n\tint i;\n\n\tif(!g) return -1;\n\tgce.gce_present = 0;\n\t\n\tif(g->nimg==0) {\n\t\tGetByteStr(g, g->signature, 6);\n\t\tg->signature[6] = '\\0';\n\t\tif(   g->signature[0] != 'G'\n\t\t   || g->signature[1] != 'I'\n\t\t   || g->signature[2] != 'F'\n\t\t   || g->signature[3] != '8') {\n\t\t\treturn -1;\n\t\t}\n#if !defined(NGIFLIB_NO_FILE)\n\t\tif(g->log) fprintf(g->log, \"%s\\n\", g->signature);\n#endif /* !defined(NGIFLIB_NO_FILE) */\n\n\t\tg->width = GetWord(g);\n\t\tg->height = GetWord(g);\n\t\t/* allocate frame buffer */\n#ifndef NGIFLIB_INDEXED_ONLY\n\t\tif((g->mode & NGIFLIB_MODE_INDEXED)==0)\n\t\t\tg->frbuff.p32 = ngiflib_malloc(4*(long)g->height*(long)g->width);\n\t\telse\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\t\tg->frbuff.p8 = ngiflib_malloc((long)g->height*(long)g->width);\n\n\t\ttmp = GetByte(g);/* <Packed Fields> = Global Color Table Flag       1 Bit\n\t\t                                      Color Resolution              3 Bits\n\t\t                                      Sort Flag                     1 Bit\n\t\t                                      Size of Global Color Table    3 Bits */\n\t\tg->colorresolution = ((tmp & 0x70) >> 4) + 1;\n\t\tg->sort_flag = (tmp & 8) >> 3;\n\t\tg->imgbits = (tmp & 7) + 1;\t/* Global Palette color resolution */\n\t\tg->ncolors = 1 << g->imgbits;\n\n\t\tg->backgroundindex = GetByte(g);\n\n#if !defined(NGIFLIB_NO_FILE)\n\t\tif(g->log) fprintf(g->log, \"%hux%hu %hhubits %hu couleurs  bg=%hhu\\n\",\n\t\t                   g->width, g->height, g->imgbits, g->ncolors, g->backgroundindex);\n#endif /* NGIFLIB_INDEXED_ONLY */\n\n\t\tg->pixaspectratio = GetByte(g);\t/* pixel aspect ratio (0 : unspecified) */\n\n\t\tif(tmp&0x80) {\n\t\t\t/* la palette globale suit. */\n\t\t\tg->palette = (struct ngiflib_rgb *)ngiflib_malloc(sizeof(struct ngiflib_rgb)*g->ncolors);\n\t\t\tfor(i=0; i<g->ncolors; i++) {\n\t\t\t\tg->palette[i].r = GetByte(g);\n\t\t\t\tg->palette[i].g = GetByte(g);\n\t\t\t\tg->palette[i].b = GetByte(g);\n#if defined(DEBUG) && !defined(NGIFLIB_NO_FILE)\n\t\t\t\tif(g->log) fprintf(g->log, \"%3d %02X %02X %02X\\n\", i, g->palette[i].r,g->palette[i].g,g->palette[i].b);\n#endif /* defined(DEBUG) && !defined(NGIFLIB_NO_FILE) */\n\t\t\t}\n#ifdef NGIFLIB_ENABLE_CALLBACKS\n\t\t\tif(g->palette_cb) g->palette_cb(g, g->palette, g->ncolors);\n#endif /* NGIFLIB_ENABLE_CALLBACKS */\n\t\t} else {\n\t\t\tg->palette = NULL;\n\t\t}\n\t\tg->netscape_loop_count = -1;\n\t}\n\n\tfor(;;) {\n\t\tchar appid_auth[11];\n\t\tu8 id,size;\n\t\tint blockindex;\n\n\t\tsign = GetByte(g);\t/* signature du prochain bloc */\n#if !defined(NGIFLIB_NO_FILE)\n\t\tif(g->log) fprintf(g->log, \"BLOCK SIGNATURE 0x%02X '%c'\\n\", sign, (sign >= 32) ? sign : '.');\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\tswitch(sign) {\n\t\tcase 0x3B:\t/* END OF GIF */\n\t\t\treturn 0;\n\t\tcase '!':\t/* Extension introducer 0x21 */\n\t\t\tid = GetByte(g);\n\t\t\tblockindex = 0;\n#if !defined(NGIFLIB_NO_FILE)\n\t\t\tif(g->log) fprintf(g->log, \"extension (id=0x%02hhx)\\n\", id);\n#endif /* NGIFLIB_NO_FILE */\n\t\t\twhile( (size = GetByte(g)) ) {\n\t\t\t\tu8 ext[256];\n\n\t\t\t\tGetByteStr(g, ext, size);\n\n\t\t\t\tswitch(id) {\n\t\t\t\tcase 0xF9:\t/* Graphic Control Extension */\n\t\t\t\t\t/* The scope of this extension is the first graphic\n\t\t\t\t\t * rendering block to follow. */\n\t\t\t\t\tgce.gce_present = 1;\n\t\t\t\t\tgce.disposal_method = (ext[0] >> 2) & 7;\n\t\t\t\t\tgce.transparent_flag = ext[0] & 1;\n\t\t\t\t\tgce.user_input_flag = (ext[0] >> 1) & 1;\n\t\t\t\t\tgce.delay_time = ext[1] | (ext[2]<<8);\n\t\t\t\t\tgce.transparent_color = ext[3];\n#if !defined(NGIFLIB_NO_FILE)\n\t\t\t\t\tif(g->log) fprintf(g->log, \"disposal_method=%hhu delay_time=%hu (transp=%hhu)transparent_color=0x%02hhX\\n\",\n\t\t\t\t\t       gce.disposal_method, gce.delay_time, gce.transparent_flag, gce.transparent_color);\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\t\t\t\t/* this propably should be adjusted depending on the disposal_method\n\t\t\t\t\t * of the _previous_ image. */\n\t\t\t\t\tif(gce.transparent_flag && ((g->nimg == 0) || gce.disposal_method == 2)) {\n\t\t\t\t\t\tFillGifBackGround(g);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xFE:\t/* Comment Extension. */\n#if !defined(NGIFLIB_NO_FILE)\n\t\t\t\t\tif(g->log) {\n\t\t\t\t\t\tif(blockindex==0) fprintf(g->log, \"-------------------- Comment extension --------------------\\n\");\n\t\t\t\t\t\text[size] = '\\0';\n\t\t\t\t\t\tfputs((char *)ext, g->log);\n\t\t\t\t\t}\n#endif /* NGIFLIB_NO_FILE */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xFF:\t/* application extension */\n\t\t\t\t\t/* NETSCAPE2.0 extension :\n\t\t\t\t\t * http://www.vurdalakov.net/misc/gif/netscape-looping-application-extension */\n\t\t\t\t\tif(blockindex==0) {\n\t\t\t\t\t\tngiflib_memcpy(appid_auth, ext, 11);\n#if !defined(NGIFLIB_NO_FILE)\n\t\t\t\t\t\tif(g->log) {\n\t\t\t\t\t\t\tfprintf(g->log, \"---------------- Application extension ---------------\\n\");\n\t\t\t\t\t\t\tfprintf(g->log, \"Application identifier : '%.8s', auth code : %02X %02X %02X (\",\n\t\t\t\t\t\t\t        appid_auth, ext[8], ext[9], ext[10]);\n\t\t\t\t\t\t\tfputc((ext[8]<32)?' ':ext[8], g->log);\n\t\t\t\t\t\t\tfputc((ext[9]<32)?' ':ext[9], g->log);\n\t\t\t\t\t\t\tfputc((ext[10]<32)?' ':ext[10], g->log);\n\t\t\t\t\t\t\tfprintf(g->log, \")\\n\");\n\t\t\t\t\t\t}\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\t\t\t\t} else {\n#if !defined(NGIFLIB_NO_FILE)\n\t\t\t\t\t\tif(g->log) {\n\t\t\t\t\t\t\tfprintf(g->log, \"Datas (as hex) : \");\n\t\t\t\t\t\t\tfor(i=0; i<size; i++) {\n\t\t\t\t\t\t\t\tfprintf(g->log, \"%02x \", ext[i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfprintf(g->log, \"\\nDatas (as text) : '\");\n\t\t\t\t\t\t\tfor(i=0; i<size; i++) {\n\t\t\t\t\t\t\t\tputc((ext[i]<32)?' ':ext[i], g->log);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfprintf(g->log, \"'\\n\");\n\t\t\t\t\t\t}\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\t\t\t\t\tif(0 == ngiflib_memcmp(appid_auth, \"NETSCAPE2.0\", 11)) {\n\t\t\t\t\t\t\t/* ext[0] : Sub-block ID */\n\t\t\t\t\t\t\tif(ext[0] == 1) {\n\t\t\t\t\t\t\t\t/* 1 : Netscape Looping Extension. */\n\t\t\t\t\t\t\t\tg->netscape_loop_count = (int)ext[1] | ((int)ext[2] << 8);\n#if !defined(NGIFLIB_NO_FILE)\n\t\t\t\t\t\t\t\tif(g->log) {\n\t\t\t\t\t\t\t\t\tfprintf(g->log, \"NETSCAPE loop_count = %d\\n\", g->netscape_loop_count);\n\t\t\t\t\t\t\t\t}\n#endif /* NGIFLIB_NO_FILE */\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x01:\t/* plain text extension */\n#if !defined(NGIFLIB_NO_FILE)\n\t\t\t\t\tif(g->log) {\n\t\t\t\t\t\tfprintf(g->log, \"Plain text extension   blockindex=%d\\n\", blockindex);\n\t\t\t\t\t\tfor(i=0; i<size; i++) {\n\t\t\t\t\t\t\tputc((ext[i]<32)?' ':ext[i], g->log);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tputc('\\n', g->log);\n\t\t\t\t\t}\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tblockindex++;\n\t\t\t}\n\t\t\tswitch(id) {\n\t\t\tcase 0x01:\t/* plain text extension */\n\t\t\tcase 0xFE:\t/* Comment Extension. */\n\t\t\tcase 0xFF:\t/* application extension */\n#if !defined(NGIFLIB_NO_FILE)\n\t\t\t\tif(g->log) {\n\t\t\t\t\tfprintf(g->log, \"-----------------------------------------------------------\\n\");\n\t\t\t\t}\n#endif /* NGIFLIB_NO_FILE */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x2C:\t/* Image separator */\n\t\t\tif(g->nimg==0) {\n\t\t\t\tg->cur_img = ngiflib_malloc(sizeof(struct ngiflib_img));\n\t\t\t\tg->first_img = g->cur_img;\n\t\t\t} else {\n\t\t\t\tg->cur_img->next = ngiflib_malloc(sizeof(struct ngiflib_img));\n\t\t\t\tg->cur_img = g->cur_img->next;\n\t\t\t}\n\t\t\tg->cur_img->next = NULL;\n\t\t\tg->cur_img->parent = g;\n\t\t\tif(gce.gce_present) {\n\t\t\t\tngiflib_memcpy(&g->cur_img->gce, &gce, sizeof(struct ngiflib_gce));\n\t\t\t} else {\n\t\t\t\tngiflib_memset(&g->cur_img->gce, 0,  sizeof(struct ngiflib_gce));\n\t\t\t}\n\t\t\tDecodeGifImg(g->cur_img);\n\t\t\tg->nimg++;\n\n\t\t\ttmp = GetByte(g);/* 0 final */\n#if !defined(NGIFLIB_NO_FILE)\n\t\t\tif(g->log) fprintf(g->log, \"ZERO TERMINATOR 0x%02X\\n\", tmp);\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\t\treturn 1;\t/* image decod\ufffde */\n\t\tdefault:\n\t\t\t/* unexpected byte */\n#if !defined(NGIFLIB_NO_FILE)\n\t\t\tif(g->log) fprintf(g->log, \"unexpected signature 0x%02X\\n\", sign);\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\t\treturn -1;\n\t\t}\n\t}\n}\n\nu32 GifIndexToTrueColor(struct ngiflib_rgb * palette, u8 v) {\n\treturn palette[v].b | (palette[v].g << 8) | (palette[v].r << 16);\n}\n"], "filenames": ["ngiflib.c"], "buggy_code_start_loc": [531], "buggy_code_end_loc": [549], "fixing_code_start_loc": [531], "fixing_code_end_loc": [554], "type": "CWE-787", "message": "The DecodeGifImg function in ngiflib.c in MiniUPnP ngiflib 0.4 does not consider the bounds of the pixels data structure, which allows remote attackers to cause a denial of service (WritePixels heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted GIF file, a different vulnerability than CVE-2018-10677.", "other": {"cve": {"id": "CVE-2018-10717", "sourceIdentifier": "cve@mitre.org", "published": "2018-05-03T17:29:00.337", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The DecodeGifImg function in ngiflib.c in MiniUPnP ngiflib 0.4 does not consider the bounds of the pixels data structure, which allows remote attackers to cause a denial of service (WritePixels heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted GIF file, a different vulnerability than CVE-2018-10677."}, {"lang": "es", "value": "En MiniUPnP ngiflib 0.4, la funci\u00f3n DecodeGifImg en ngiflib.c cno considera los l\u00edmites de la estructura de datos de p\u00edxeles, lo que permite a los atacantes remotos provocar una denegaci\u00f3n de servicio (desbordamiento de b\u00fafer basado en memoria din\u00e1mica o heap de WritePixels y cierre inesperado de la aplicaci\u00f3n) o, posiblemente, otro impacto no especificado mediante un archivo GIF manipulado. Esta vulnerabilidad es diferente de CVE-2018-10677."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:miniupnp_project:ngiflib:0.4:*:*:*:*:*:*:*", "matchCriteriaId": "5BE2BAA9-5D76-4039-A655-3F478ED5D601"}]}]}], "references": [{"url": "https://github.com/miniupnp/ngiflib/commit/cf429e0a2fe26b5f01ce0c8e9b79432e94509b6e", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/miniupnp/ngiflib/issues/3", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/miniupnp/ngiflib/commit/cf429e0a2fe26b5f01ce0c8e9b79432e94509b6e"}}