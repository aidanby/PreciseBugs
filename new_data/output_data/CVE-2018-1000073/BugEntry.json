{"buggy_code": ["# -*- coding: utf-8 -*-\n# frozen_string_literal: true\n#--\n# Copyright (C) 2004 Mauricio Julio Fern\u00e1ndez Pradier\n# See LICENSE.txt for additional licensing information.\n#++\n#\n# Example using a Gem::Package\n#\n# Builds a .gem file given a Gem::Specification. A .gem file is a tarball\n# which contains a data.tar.gz and metadata.gz, and possibly signatures.\n#\n#   require 'rubygems'\n#   require 'rubygems/package'\n#\n#   spec = Gem::Specification.new do |s|\n#     s.summary = \"Ruby based make-like utility.\"\n#     s.name = 'rake'\n#     s.version = PKG_VERSION\n#     s.requirements << 'none'\n#     s.files = PKG_FILES\n#     s.description = <<-EOF\n#   Rake is a Make-like program implemented in Ruby. Tasks\n#   and dependencies are specified in standard Ruby syntax.\n#     EOF\n#   end\n#\n#   Gem::Package.build spec\n#\n# Reads a .gem file.\n#\n#   require 'rubygems'\n#   require 'rubygems/package'\n#\n#   the_gem = Gem::Package.new(path_to_dot_gem)\n#   the_gem.contents # get the files in the gem\n#   the_gem.extract_files destination_directory # extract the gem into a directory\n#   the_gem.spec # get the spec out of the gem\n#   the_gem.verify # check the gem is OK (contains valid gem specification, contains a not corrupt contents archive)\n#\n# #files are the files in the .gem tar file, not the Ruby files in the gem\n# #extract_files and #contents automatically call #verify\n\nrequire 'rubygems/security'\nrequire 'rubygems/specification'\nrequire 'rubygems/user_interaction'\nrequire 'zlib'\n\nclass Gem::Package\n\n  include Gem::UserInteraction\n\n  class Error < Gem::Exception; end\n\n  class FormatError < Error\n    attr_reader :path\n\n    def initialize message, source = nil\n      if source\n        @path = source.path\n\n        message = message + \" in #{path}\" if path\n      end\n\n      super message\n    end\n\n  end\n\n  class PathError < Error\n    def initialize destination, destination_dir\n      super \"installing into parent path %s of %s is not allowed\" %\n              [destination, destination_dir]\n    end\n  end\n\n  class NonSeekableIO < Error; end\n\n  class TooLongFileName < Error; end\n\n  ##\n  # Raised when a tar file is corrupt\n\n  class TarInvalidError < Error; end\n\n\n  attr_accessor :build_time # :nodoc:\n\n  ##\n  # Checksums for the contents of the package\n\n  attr_reader :checksums\n\n  ##\n  # The files in this package.  This is not the contents of the gem, just the\n  # files in the top-level container.\n\n  attr_reader :files\n\n  ##\n  # The security policy used for verifying the contents of this package.\n\n  attr_accessor :security_policy\n\n  ##\n  # Sets the Gem::Specification to use to build this package.\n\n  attr_writer :spec\n\n  def self.build spec, skip_validation=false\n    gem_file = spec.file_name\n\n    package = new gem_file\n    package.spec = spec\n    package.build skip_validation\n\n    gem_file\n  end\n\n  ##\n  # Creates a new Gem::Package for the file at +gem+. +gem+ can also be\n  # provided as an IO object.\n  #\n  # If +gem+ is an existing file in the old format a Gem::Package::Old will be\n  # returned.\n\n  def self.new gem, security_policy = nil\n    gem = if gem.is_a?(Gem::Package::Source)\n            gem\n          elsif gem.respond_to? :read\n            Gem::Package::IOSource.new gem\n          else\n            Gem::Package::FileSource.new gem\n          end\n\n    return super unless Gem::Package == self\n    return super unless gem.present?\n\n    return super unless gem.start\n    return super unless gem.start.include? 'MD5SUM ='\n\n    Gem::Package::Old.new gem\n  end\n\n  ##\n  # Creates a new package that will read or write to the file +gem+.\n\n  def initialize gem, security_policy # :notnew:\n    @gem = gem\n\n    @build_time      = Time.now\n    @checksums       = {}\n    @contents        = nil\n    @digests         = Hash.new { |h, algorithm| h[algorithm] = {} }\n    @files           = nil\n    @security_policy = security_policy\n    @signatures      = {}\n    @signer          = nil\n    @spec            = nil\n  end\n\n  ##\n  # Copies this package to +path+ (if possible)\n\n  def copy_to path\n    FileUtils.cp @gem.path, path unless File.exist? path\n  end\n\n  ##\n  # Adds a checksum for each entry in the gem to checksums.yaml.gz.\n\n  def add_checksums tar\n    Gem.load_yaml\n\n    checksums_by_algorithm = Hash.new { |h, algorithm| h[algorithm] = {} }\n\n    @checksums.each do |name, digests|\n      digests.each do |algorithm, digest|\n        checksums_by_algorithm[algorithm][name] = digest.hexdigest\n      end\n    end\n\n    tar.add_file_signed 'checksums.yaml.gz', 0444, @signer do |io|\n      gzip_to io do |gz_io|\n        YAML.dump checksums_by_algorithm, gz_io\n      end\n    end\n  end\n\n  ##\n  # Adds the files listed in the packages's Gem::Specification to data.tar.gz\n  # and adds this file to the +tar+.\n\n  def add_contents tar # :nodoc:\n    digests = tar.add_file_signed 'data.tar.gz', 0444, @signer do |io|\n      gzip_to io do |gz_io|\n        Gem::Package::TarWriter.new gz_io do |data_tar|\n          add_files data_tar\n        end\n      end\n    end\n\n    @checksums['data.tar.gz'] = digests\n  end\n\n  ##\n  # Adds files included the package's Gem::Specification to the +tar+ file\n\n  def add_files tar # :nodoc:\n    @spec.files.each do |file|\n      stat = File.lstat file\n\n      if stat.symlink?\n        relative_dir = File.dirname(file).sub(\"#{Dir.pwd}/\", '')\n        target_path = File.join(relative_dir, File.readlink(file))\n        tar.add_symlink file, target_path, stat.mode\n      end\n\n      next unless stat.file?\n\n      tar.add_file_simple file, stat.mode, stat.size do |dst_io|\n        File.open file, 'rb' do |src_io|\n          dst_io.write src_io.read 16384 until src_io.eof?\n        end\n      end\n    end\n  end\n\n  ##\n  # Adds the package's Gem::Specification to the +tar+ file\n\n  def add_metadata tar # :nodoc:\n    digests = tar.add_file_signed 'metadata.gz', 0444, @signer do |io|\n      gzip_to io do |gz_io|\n        gz_io.write @spec.to_yaml\n      end\n    end\n\n    @checksums['metadata.gz'] = digests\n  end\n\n  ##\n  # Builds this package based on the specification set by #spec=\n\n  def build skip_validation = false\n    Gem.load_yaml\n    require 'rubygems/security'\n\n    @spec.mark_version\n    @spec.validate unless skip_validation\n\n    setup_signer\n\n    @gem.with_write_io do |gem_io|\n      Gem::Package::TarWriter.new gem_io do |gem|\n        add_metadata gem\n        add_contents gem\n        add_checksums gem\n      end\n    end\n\n    say <<-EOM\n  Successfully built RubyGem\n  Name: #{@spec.name}\n  Version: #{@spec.version}\n  File: #{File.basename @spec.cache_file}\nEOM\n  ensure\n    @signer = nil\n  end\n\n  ##\n  # A list of file names contained in this gem\n\n  def contents\n    return @contents if @contents\n\n    verify unless @spec\n\n    @contents = []\n\n    @gem.with_read_io do |io|\n      gem_tar = Gem::Package::TarReader.new io\n\n      gem_tar.each do |entry|\n        next unless entry.full_name == 'data.tar.gz'\n\n        open_tar_gz entry do |pkg_tar|\n          pkg_tar.each do |contents_entry|\n            @contents << contents_entry.full_name\n          end\n        end\n\n        return @contents\n      end\n    end\n  end\n\n  ##\n  # Creates a digest of the TarEntry +entry+ from the digest algorithm set by\n  # the security policy.\n\n  def digest entry # :nodoc:\n    algorithms = if @checksums then\n                   @checksums.keys\n                 else\n                   [Gem::Security::DIGEST_NAME].compact\n                 end\n\n    algorithms.each do |algorithm|\n      digester =\n        if defined?(OpenSSL::Digest) then\n          OpenSSL::Digest.new algorithm\n        else\n          Digest.const_get(algorithm).new\n        end\n\n      digester << entry.read(16384) until entry.eof?\n\n      entry.rewind\n\n      @digests[algorithm][entry.full_name] = digester\n    end\n\n    @digests\n  end\n\n  ##\n  # Extracts the files in this package into +destination_dir+\n  #\n  # If +pattern+ is specified, only entries matching that glob will be\n  # extracted.\n\n  def extract_files destination_dir, pattern = \"*\"\n    verify unless @spec\n\n    FileUtils.mkdir_p destination_dir\n\n    @gem.with_read_io do |io|\n      reader = Gem::Package::TarReader.new io\n\n      reader.each do |entry|\n        next unless entry.full_name == 'data.tar.gz'\n\n        extract_tar_gz entry, destination_dir, pattern\n\n        return # ignore further entries\n      end\n    end\n  end\n\n  ##\n  # Extracts all the files in the gzipped tar archive +io+ into\n  # +destination_dir+.\n  #\n  # If an entry in the archive contains a relative path above\n  # +destination_dir+ or an absolute path is encountered an exception is\n  # raised.\n  #\n  # If +pattern+ is specified, only entries matching that glob will be\n  # extracted.\n\n  def extract_tar_gz io, destination_dir, pattern = \"*\" # :nodoc:\n    open_tar_gz io do |tar|\n      tar.each do |entry|\n        next unless File.fnmatch pattern, entry.full_name, File::FNM_DOTMATCH\n\n        destination = install_location entry.full_name, destination_dir\n\n        FileUtils.rm_rf destination\n\n        mkdir_options = {}\n        mkdir_options[:mode] = entry.header.mode if entry.directory?\n        mkdir =\n          if entry.directory? then\n            destination\n          else\n            File.dirname destination\n          end\n\n        FileUtils.mkdir_p mkdir, mkdir_options\n\n        File.open destination, 'wb' do |out|\n          out.write entry.read\n          FileUtils.chmod entry.header.mode, destination\n        end if entry.file?\n\n        File.symlink(entry.header.linkname, destination) if entry.symlink?\n\n        verbose destination\n      end\n    end\n  end\n\n  ##\n  # Gzips content written to +gz_io+ to +io+.\n  #--\n  # Also sets the gzip modification time to the package build time to ease\n  # testing.\n\n  def gzip_to io # :yields: gz_io\n    gz_io = Zlib::GzipWriter.new io, Zlib::BEST_COMPRESSION\n    gz_io.mtime = @build_time\n\n    yield gz_io\n  ensure\n    gz_io.close\n  end\n\n  ##\n  # Returns the full path for installing +filename+.\n  #\n  # If +filename+ is not inside +destination_dir+ an exception is raised.\n\n  def install_location filename, destination_dir # :nodoc:\n    raise Gem::Package::PathError.new(filename, destination_dir) if\n      filename.start_with? '/'\n\n    destination_dir = File.realpath destination_dir if\n      File.respond_to? :realpath\n    destination_dir = File.expand_path destination_dir\n\n    destination = File.join destination_dir, filename\n    destination = File.expand_path destination\n\n    raise Gem::Package::PathError.new(destination, destination_dir) unless\n      destination.start_with? destination_dir + '/'\n\n    destination.untaint\n    destination\n  end\n\n  ##\n  # Loads a Gem::Specification from the TarEntry +entry+\n\n  def load_spec entry # :nodoc:\n    case entry.full_name\n    when 'metadata' then\n      @spec = Gem::Specification.from_yaml entry.read\n    when 'metadata.gz' then\n      args = [entry]\n      args << { :external_encoding => Encoding::UTF_8 } if\n        Object.const_defined?(:Encoding) &&\n          Zlib::GzipReader.method(:wrap).arity != 1\n\n      Zlib::GzipReader.wrap(*args) do |gzio|\n        @spec = Gem::Specification.from_yaml gzio.read\n      end\n    end\n  end\n\n  ##\n  # Opens +io+ as a gzipped tar archive\n\n  def open_tar_gz io # :nodoc:\n    Zlib::GzipReader.wrap io do |gzio|\n      tar = Gem::Package::TarReader.new gzio\n\n      yield tar\n    end\n  end\n\n  ##\n  # Reads and loads checksums.yaml.gz from the tar file +gem+\n\n  def read_checksums gem\n    Gem.load_yaml\n\n    @checksums = gem.seek 'checksums.yaml.gz' do |entry|\n      Zlib::GzipReader.wrap entry do |gz_io|\n        Gem::SafeYAML.safe_load gz_io.read\n      end\n    end\n  end\n\n  ##\n  # Prepares the gem for signing and checksum generation.  If a signing\n  # certificate and key are not present only checksum generation is set up.\n\n  def setup_signer\n    passphrase = ENV['GEM_PRIVATE_KEY_PASSPHRASE']\n    if @spec.signing_key then\n      @signer = Gem::Security::Signer.new @spec.signing_key, @spec.cert_chain, passphrase\n      @spec.signing_key = nil\n      @spec.cert_chain = @signer.cert_chain.map { |cert| cert.to_s }\n    else\n      @signer = Gem::Security::Signer.new nil, nil, passphrase\n      @spec.cert_chain = @signer.cert_chain.map { |cert| cert.to_pem } if\n        @signer.cert_chain\n    end\n  end\n\n  ##\n  # The spec for this gem.\n  #\n  # If this is a package for a built gem the spec is loaded from the\n  # gem and returned.  If this is a package for a gem being built the provided\n  # spec is returned.\n\n  def spec\n    verify unless @spec\n\n    @spec\n  end\n\n  ##\n  # Verifies that this gem:\n  #\n  # * Contains a valid gem specification\n  # * Contains a contents archive\n  # * The contents archive is not corrupt\n  #\n  # After verification the gem specification from the gem is available from\n  # #spec\n\n  def verify\n    @files     = []\n    @spec      = nil\n\n    @gem.with_read_io do |io|\n      Gem::Package::TarReader.new io do |reader|\n        read_checksums reader\n\n        verify_files reader\n      end\n    end\n\n    verify_checksums @digests, @checksums\n\n    @security_policy.verify_signatures @spec, @digests, @signatures if\n      @security_policy\n\n    true\n  rescue Gem::Security::Exception\n    @spec = nil\n    @files = []\n    raise\n  rescue Errno::ENOENT => e\n    raise Gem::Package::FormatError.new e.message\n  rescue Gem::Package::TarInvalidError => e\n    raise Gem::Package::FormatError.new e.message, @gem\n  end\n\n  ##\n  # Verifies the +checksums+ against the +digests+.  This check is not\n  # cryptographically secure.  Missing checksums are ignored.\n\n  def verify_checksums digests, checksums # :nodoc:\n    return unless checksums\n\n    checksums.sort.each do |algorithm, gem_digests|\n      gem_digests.sort.each do |file_name, gem_hexdigest|\n        computed_digest = digests[algorithm][file_name]\n\n        unless computed_digest.hexdigest == gem_hexdigest then\n          raise Gem::Package::FormatError.new \\\n            \"#{algorithm} checksum mismatch for #{file_name}\", @gem\n        end\n      end\n    end\n  end\n\n  ##\n  # Verifies +entry+ in a .gem file.\n\n  def verify_entry entry\n    file_name = entry.full_name\n    @files << file_name\n\n    case file_name\n    when /\\.sig$/ then\n      @signatures[$`] = entry.read if @security_policy\n      return\n    else\n      digest entry\n    end\n\n    case file_name\n    when /^metadata(.gz)?$/ then\n      load_spec entry\n    when 'data.tar.gz' then\n      verify_gz entry\n    end\n  rescue => e\n    message = \"package is corrupt, exception while verifying: \" +\n              \"#{e.message} (#{e.class})\"\n    raise Gem::Package::FormatError.new message, @gem\n  end\n\n  ##\n  # Verifies the files of the +gem+\n\n  def verify_files gem\n    gem.each do |entry|\n      verify_entry entry\n    end\n\n    unless @spec then\n      raise Gem::Package::FormatError.new 'package metadata is missing', @gem\n    end\n\n    unless @files.include? 'data.tar.gz' then\n      raise Gem::Package::FormatError.new \\\n              'package content (data.tar.gz) is missing', @gem\n    end\n\n    if duplicates = @files.group_by {|f| f }.select {|k,v| v.size > 1 }.map(&:first) and duplicates.any?\n      raise Gem::Security::Exception, \"duplicate files in the package: (#{duplicates.map(&:inspect).join(', ')})\"\n    end\n  end\n\n  ##\n  # Verifies that +entry+ is a valid gzipped file.\n\n  def verify_gz entry # :nodoc:\n    Zlib::GzipReader.wrap entry do |gzio|\n      gzio.read 16384 until gzio.eof? # gzip checksum verification\n    end\n  rescue Zlib::GzipFile::Error => e\n    raise Gem::Package::FormatError.new(e.message, entry.full_name)\n  end\n\nend\n\nrequire 'rubygems/package/digest_io'\nrequire 'rubygems/package/source'\nrequire 'rubygems/package/file_source'\nrequire 'rubygems/package/io_source'\nrequire 'rubygems/package/old'\nrequire 'rubygems/package/tar_header'\nrequire 'rubygems/package/tar_reader'\nrequire 'rubygems/package/tar_reader/entry'\nrequire 'rubygems/package/tar_writer'\n"], "fixing_code": ["# -*- coding: utf-8 -*-\n# frozen_string_literal: true\n#--\n# Copyright (C) 2004 Mauricio Julio Fern\u00e1ndez Pradier\n# See LICENSE.txt for additional licensing information.\n#++\n#\n# Example using a Gem::Package\n#\n# Builds a .gem file given a Gem::Specification. A .gem file is a tarball\n# which contains a data.tar.gz and metadata.gz, and possibly signatures.\n#\n#   require 'rubygems'\n#   require 'rubygems/package'\n#\n#   spec = Gem::Specification.new do |s|\n#     s.summary = \"Ruby based make-like utility.\"\n#     s.name = 'rake'\n#     s.version = PKG_VERSION\n#     s.requirements << 'none'\n#     s.files = PKG_FILES\n#     s.description = <<-EOF\n#   Rake is a Make-like program implemented in Ruby. Tasks\n#   and dependencies are specified in standard Ruby syntax.\n#     EOF\n#   end\n#\n#   Gem::Package.build spec\n#\n# Reads a .gem file.\n#\n#   require 'rubygems'\n#   require 'rubygems/package'\n#\n#   the_gem = Gem::Package.new(path_to_dot_gem)\n#   the_gem.contents # get the files in the gem\n#   the_gem.extract_files destination_directory # extract the gem into a directory\n#   the_gem.spec # get the spec out of the gem\n#   the_gem.verify # check the gem is OK (contains valid gem specification, contains a not corrupt contents archive)\n#\n# #files are the files in the .gem tar file, not the Ruby files in the gem\n# #extract_files and #contents automatically call #verify\n\nrequire 'rubygems/security'\nrequire 'rubygems/specification'\nrequire 'rubygems/user_interaction'\nrequire 'zlib'\n\nclass Gem::Package\n\n  include Gem::UserInteraction\n\n  class Error < Gem::Exception; end\n\n  class FormatError < Error\n    attr_reader :path\n\n    def initialize message, source = nil\n      if source\n        @path = source.path\n\n        message = message + \" in #{path}\" if path\n      end\n\n      super message\n    end\n\n  end\n\n  class PathError < Error\n    def initialize destination, destination_dir\n      super \"installing into parent path %s of %s is not allowed\" %\n              [destination, destination_dir]\n    end\n  end\n\n  class NonSeekableIO < Error; end\n\n  class TooLongFileName < Error; end\n\n  ##\n  # Raised when a tar file is corrupt\n\n  class TarInvalidError < Error; end\n\n\n  attr_accessor :build_time # :nodoc:\n\n  ##\n  # Checksums for the contents of the package\n\n  attr_reader :checksums\n\n  ##\n  # The files in this package.  This is not the contents of the gem, just the\n  # files in the top-level container.\n\n  attr_reader :files\n\n  ##\n  # The security policy used for verifying the contents of this package.\n\n  attr_accessor :security_policy\n\n  ##\n  # Sets the Gem::Specification to use to build this package.\n\n  attr_writer :spec\n\n  def self.build spec, skip_validation=false\n    gem_file = spec.file_name\n\n    package = new gem_file\n    package.spec = spec\n    package.build skip_validation\n\n    gem_file\n  end\n\n  ##\n  # Creates a new Gem::Package for the file at +gem+. +gem+ can also be\n  # provided as an IO object.\n  #\n  # If +gem+ is an existing file in the old format a Gem::Package::Old will be\n  # returned.\n\n  def self.new gem, security_policy = nil\n    gem = if gem.is_a?(Gem::Package::Source)\n            gem\n          elsif gem.respond_to? :read\n            Gem::Package::IOSource.new gem\n          else\n            Gem::Package::FileSource.new gem\n          end\n\n    return super unless Gem::Package == self\n    return super unless gem.present?\n\n    return super unless gem.start\n    return super unless gem.start.include? 'MD5SUM ='\n\n    Gem::Package::Old.new gem\n  end\n\n  ##\n  # Creates a new package that will read or write to the file +gem+.\n\n  def initialize gem, security_policy # :notnew:\n    @gem = gem\n\n    @build_time      = Time.now\n    @checksums       = {}\n    @contents        = nil\n    @digests         = Hash.new { |h, algorithm| h[algorithm] = {} }\n    @files           = nil\n    @security_policy = security_policy\n    @signatures      = {}\n    @signer          = nil\n    @spec            = nil\n  end\n\n  ##\n  # Copies this package to +path+ (if possible)\n\n  def copy_to path\n    FileUtils.cp @gem.path, path unless File.exist? path\n  end\n\n  ##\n  # Adds a checksum for each entry in the gem to checksums.yaml.gz.\n\n  def add_checksums tar\n    Gem.load_yaml\n\n    checksums_by_algorithm = Hash.new { |h, algorithm| h[algorithm] = {} }\n\n    @checksums.each do |name, digests|\n      digests.each do |algorithm, digest|\n        checksums_by_algorithm[algorithm][name] = digest.hexdigest\n      end\n    end\n\n    tar.add_file_signed 'checksums.yaml.gz', 0444, @signer do |io|\n      gzip_to io do |gz_io|\n        YAML.dump checksums_by_algorithm, gz_io\n      end\n    end\n  end\n\n  ##\n  # Adds the files listed in the packages's Gem::Specification to data.tar.gz\n  # and adds this file to the +tar+.\n\n  def add_contents tar # :nodoc:\n    digests = tar.add_file_signed 'data.tar.gz', 0444, @signer do |io|\n      gzip_to io do |gz_io|\n        Gem::Package::TarWriter.new gz_io do |data_tar|\n          add_files data_tar\n        end\n      end\n    end\n\n    @checksums['data.tar.gz'] = digests\n  end\n\n  ##\n  # Adds files included the package's Gem::Specification to the +tar+ file\n\n  def add_files tar # :nodoc:\n    @spec.files.each do |file|\n      stat = File.lstat file\n\n      if stat.symlink?\n        relative_dir = File.dirname(file).sub(\"#{Dir.pwd}/\", '')\n        target_path = File.join(relative_dir, File.readlink(file))\n        tar.add_symlink file, target_path, stat.mode\n      end\n\n      next unless stat.file?\n\n      tar.add_file_simple file, stat.mode, stat.size do |dst_io|\n        File.open file, 'rb' do |src_io|\n          dst_io.write src_io.read 16384 until src_io.eof?\n        end\n      end\n    end\n  end\n\n  ##\n  # Adds the package's Gem::Specification to the +tar+ file\n\n  def add_metadata tar # :nodoc:\n    digests = tar.add_file_signed 'metadata.gz', 0444, @signer do |io|\n      gzip_to io do |gz_io|\n        gz_io.write @spec.to_yaml\n      end\n    end\n\n    @checksums['metadata.gz'] = digests\n  end\n\n  ##\n  # Builds this package based on the specification set by #spec=\n\n  def build skip_validation = false\n    Gem.load_yaml\n    require 'rubygems/security'\n\n    @spec.mark_version\n    @spec.validate unless skip_validation\n\n    setup_signer\n\n    @gem.with_write_io do |gem_io|\n      Gem::Package::TarWriter.new gem_io do |gem|\n        add_metadata gem\n        add_contents gem\n        add_checksums gem\n      end\n    end\n\n    say <<-EOM\n  Successfully built RubyGem\n  Name: #{@spec.name}\n  Version: #{@spec.version}\n  File: #{File.basename @spec.cache_file}\nEOM\n  ensure\n    @signer = nil\n  end\n\n  ##\n  # A list of file names contained in this gem\n\n  def contents\n    return @contents if @contents\n\n    verify unless @spec\n\n    @contents = []\n\n    @gem.with_read_io do |io|\n      gem_tar = Gem::Package::TarReader.new io\n\n      gem_tar.each do |entry|\n        next unless entry.full_name == 'data.tar.gz'\n\n        open_tar_gz entry do |pkg_tar|\n          pkg_tar.each do |contents_entry|\n            @contents << contents_entry.full_name\n          end\n        end\n\n        return @contents\n      end\n    end\n  end\n\n  ##\n  # Creates a digest of the TarEntry +entry+ from the digest algorithm set by\n  # the security policy.\n\n  def digest entry # :nodoc:\n    algorithms = if @checksums then\n                   @checksums.keys\n                 else\n                   [Gem::Security::DIGEST_NAME].compact\n                 end\n\n    algorithms.each do |algorithm|\n      digester =\n        if defined?(OpenSSL::Digest) then\n          OpenSSL::Digest.new algorithm\n        else\n          Digest.const_get(algorithm).new\n        end\n\n      digester << entry.read(16384) until entry.eof?\n\n      entry.rewind\n\n      @digests[algorithm][entry.full_name] = digester\n    end\n\n    @digests\n  end\n\n  ##\n  # Extracts the files in this package into +destination_dir+\n  #\n  # If +pattern+ is specified, only entries matching that glob will be\n  # extracted.\n\n  def extract_files destination_dir, pattern = \"*\"\n    verify unless @spec\n\n    FileUtils.mkdir_p destination_dir\n\n    @gem.with_read_io do |io|\n      reader = Gem::Package::TarReader.new io\n\n      reader.each do |entry|\n        next unless entry.full_name == 'data.tar.gz'\n\n        extract_tar_gz entry, destination_dir, pattern\n\n        return # ignore further entries\n      end\n    end\n  end\n\n  ##\n  # Extracts all the files in the gzipped tar archive +io+ into\n  # +destination_dir+.\n  #\n  # If an entry in the archive contains a relative path above\n  # +destination_dir+ or an absolute path is encountered an exception is\n  # raised.\n  #\n  # If +pattern+ is specified, only entries matching that glob will be\n  # extracted.\n\n  def extract_tar_gz io, destination_dir, pattern = \"*\" # :nodoc:\n    open_tar_gz io do |tar|\n      tar.each do |entry|\n        next unless File.fnmatch pattern, entry.full_name, File::FNM_DOTMATCH\n\n        destination = install_location entry.full_name, destination_dir\n\n        FileUtils.rm_rf destination\n\n        mkdir_options = {}\n        mkdir_options[:mode] = entry.header.mode if entry.directory?\n        mkdir =\n          if entry.directory? then\n            destination\n          else\n            File.dirname destination\n          end\n\n        FileUtils.mkdir_p mkdir, mkdir_options\n\n        File.open destination, 'wb' do |out|\n          out.write entry.read\n          FileUtils.chmod entry.header.mode, destination\n        end if entry.file?\n\n        File.symlink(entry.header.linkname, destination) if entry.symlink?\n\n        verbose destination\n      end\n    end\n  end\n\n  ##\n  # Gzips content written to +gz_io+ to +io+.\n  #--\n  # Also sets the gzip modification time to the package build time to ease\n  # testing.\n\n  def gzip_to io # :yields: gz_io\n    gz_io = Zlib::GzipWriter.new io, Zlib::BEST_COMPRESSION\n    gz_io.mtime = @build_time\n\n    yield gz_io\n  ensure\n    gz_io.close\n  end\n\n  ##\n  # Returns the full path for installing +filename+.\n  #\n  # If +filename+ is not inside +destination_dir+ an exception is raised.\n\n  def install_location filename, destination_dir # :nodoc:\n    raise Gem::Package::PathError.new(filename, destination_dir) if\n      filename.start_with? '/'\n\n    destination_dir = File.realpath destination_dir if\n      File.respond_to? :realpath\n    destination_dir = File.expand_path destination_dir\n\n    destination = File.join destination_dir, filename\n    destination = File.realpath destination if\n      File.respond_to? :realpath\n    destination = File.expand_path destination\n\n    raise Gem::Package::PathError.new(destination, destination_dir) unless\n      destination.start_with? destination_dir + '/'\n\n    destination.untaint\n    destination\n  end\n\n  ##\n  # Loads a Gem::Specification from the TarEntry +entry+\n\n  def load_spec entry # :nodoc:\n    case entry.full_name\n    when 'metadata' then\n      @spec = Gem::Specification.from_yaml entry.read\n    when 'metadata.gz' then\n      args = [entry]\n      args << { :external_encoding => Encoding::UTF_8 } if\n        Object.const_defined?(:Encoding) &&\n          Zlib::GzipReader.method(:wrap).arity != 1\n\n      Zlib::GzipReader.wrap(*args) do |gzio|\n        @spec = Gem::Specification.from_yaml gzio.read\n      end\n    end\n  end\n\n  ##\n  # Opens +io+ as a gzipped tar archive\n\n  def open_tar_gz io # :nodoc:\n    Zlib::GzipReader.wrap io do |gzio|\n      tar = Gem::Package::TarReader.new gzio\n\n      yield tar\n    end\n  end\n\n  ##\n  # Reads and loads checksums.yaml.gz from the tar file +gem+\n\n  def read_checksums gem\n    Gem.load_yaml\n\n    @checksums = gem.seek 'checksums.yaml.gz' do |entry|\n      Zlib::GzipReader.wrap entry do |gz_io|\n        Gem::SafeYAML.safe_load gz_io.read\n      end\n    end\n  end\n\n  ##\n  # Prepares the gem for signing and checksum generation.  If a signing\n  # certificate and key are not present only checksum generation is set up.\n\n  def setup_signer\n    passphrase = ENV['GEM_PRIVATE_KEY_PASSPHRASE']\n    if @spec.signing_key then\n      @signer = Gem::Security::Signer.new @spec.signing_key, @spec.cert_chain, passphrase\n      @spec.signing_key = nil\n      @spec.cert_chain = @signer.cert_chain.map { |cert| cert.to_s }\n    else\n      @signer = Gem::Security::Signer.new nil, nil, passphrase\n      @spec.cert_chain = @signer.cert_chain.map { |cert| cert.to_pem } if\n        @signer.cert_chain\n    end\n  end\n\n  ##\n  # The spec for this gem.\n  #\n  # If this is a package for a built gem the spec is loaded from the\n  # gem and returned.  If this is a package for a gem being built the provided\n  # spec is returned.\n\n  def spec\n    verify unless @spec\n\n    @spec\n  end\n\n  ##\n  # Verifies that this gem:\n  #\n  # * Contains a valid gem specification\n  # * Contains a contents archive\n  # * The contents archive is not corrupt\n  #\n  # After verification the gem specification from the gem is available from\n  # #spec\n\n  def verify\n    @files     = []\n    @spec      = nil\n\n    @gem.with_read_io do |io|\n      Gem::Package::TarReader.new io do |reader|\n        read_checksums reader\n\n        verify_files reader\n      end\n    end\n\n    verify_checksums @digests, @checksums\n\n    @security_policy.verify_signatures @spec, @digests, @signatures if\n      @security_policy\n\n    true\n  rescue Gem::Security::Exception\n    @spec = nil\n    @files = []\n    raise\n  rescue Errno::ENOENT => e\n    raise Gem::Package::FormatError.new e.message\n  rescue Gem::Package::TarInvalidError => e\n    raise Gem::Package::FormatError.new e.message, @gem\n  end\n\n  ##\n  # Verifies the +checksums+ against the +digests+.  This check is not\n  # cryptographically secure.  Missing checksums are ignored.\n\n  def verify_checksums digests, checksums # :nodoc:\n    return unless checksums\n\n    checksums.sort.each do |algorithm, gem_digests|\n      gem_digests.sort.each do |file_name, gem_hexdigest|\n        computed_digest = digests[algorithm][file_name]\n\n        unless computed_digest.hexdigest == gem_hexdigest then\n          raise Gem::Package::FormatError.new \\\n            \"#{algorithm} checksum mismatch for #{file_name}\", @gem\n        end\n      end\n    end\n  end\n\n  ##\n  # Verifies +entry+ in a .gem file.\n\n  def verify_entry entry\n    file_name = entry.full_name\n    @files << file_name\n\n    case file_name\n    when /\\.sig$/ then\n      @signatures[$`] = entry.read if @security_policy\n      return\n    else\n      digest entry\n    end\n\n    case file_name\n    when /^metadata(.gz)?$/ then\n      load_spec entry\n    when 'data.tar.gz' then\n      verify_gz entry\n    end\n  rescue => e\n    message = \"package is corrupt, exception while verifying: \" +\n              \"#{e.message} (#{e.class})\"\n    raise Gem::Package::FormatError.new message, @gem\n  end\n\n  ##\n  # Verifies the files of the +gem+\n\n  def verify_files gem\n    gem.each do |entry|\n      verify_entry entry\n    end\n\n    unless @spec then\n      raise Gem::Package::FormatError.new 'package metadata is missing', @gem\n    end\n\n    unless @files.include? 'data.tar.gz' then\n      raise Gem::Package::FormatError.new \\\n              'package content (data.tar.gz) is missing', @gem\n    end\n\n    if duplicates = @files.group_by {|f| f }.select {|k,v| v.size > 1 }.map(&:first) and duplicates.any?\n      raise Gem::Security::Exception, \"duplicate files in the package: (#{duplicates.map(&:inspect).join(', ')})\"\n    end\n  end\n\n  ##\n  # Verifies that +entry+ is a valid gzipped file.\n\n  def verify_gz entry # :nodoc:\n    Zlib::GzipReader.wrap entry do |gzio|\n      gzio.read 16384 until gzio.eof? # gzip checksum verification\n    end\n  rescue Zlib::GzipFile::Error => e\n    raise Gem::Package::FormatError.new(e.message, entry.full_name)\n  end\n\nend\n\nrequire 'rubygems/package/digest_io'\nrequire 'rubygems/package/source'\nrequire 'rubygems/package/file_source'\nrequire 'rubygems/package/io_source'\nrequire 'rubygems/package/old'\nrequire 'rubygems/package/tar_header'\nrequire 'rubygems/package/tar_reader'\nrequire 'rubygems/package/tar_reader/entry'\nrequire 'rubygems/package/tar_writer'\n"], "filenames": ["lib/rubygems/package.rb"], "buggy_code_start_loc": [423], "buggy_code_end_loc": [423], "fixing_code_start_loc": [424], "fixing_code_end_loc": [426], "type": "CWE-59", "message": "RubyGems version Ruby 2.2 series: 2.2.9 and earlier, Ruby 2.3 series: 2.3.6 and earlier, Ruby 2.4 series: 2.4.3 and earlier, Ruby 2.5 series: 2.5.0 and earlier, prior to trunk revision 62422 contains a Directory Traversal vulnerability in install_location function of package.rb that can result in path traversal when writing to a symlinked basedir outside of the root. This vulnerability appears to have been fixed in 2.7.6.", "other": {"cve": {"id": "CVE-2018-1000073", "sourceIdentifier": "cve@mitre.org", "published": "2018-03-13T15:29:00.427", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "RubyGems version Ruby 2.2 series: 2.2.9 and earlier, Ruby 2.3 series: 2.3.6 and earlier, Ruby 2.4 series: 2.4.3 and earlier, Ruby 2.5 series: 2.5.0 and earlier, prior to trunk revision 62422 contains a Directory Traversal vulnerability in install_location function of package.rb that can result in path traversal when writing to a symlinked basedir outside of the root. This vulnerability appears to have been fixed in 2.7.6."}, {"lang": "es", "value": "Las versiones de RubyGems de la serie Ruby 2.2: 2.2.9 y anteriores, de la serie Ruby 2.3: 2.3.6 y anteriores, de la serie Ruby 2.4: 2.4.3 y anteriores, y de la serie Ruby 2.5: 2.5.0 y anteriores, anteriores a la revisi\u00f3n del trunk 62422 contiene una vulnerabilidad de salto de directorio en la funci\u00f3n install_location de package.rb que puede resultar en un salto de directorio al escribir en un basedir vinculado simb\u00f3licamente fuera del root. La vulnerabilidad parece haber sido solucionada en la versi\u00f3n 2.7.6."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-59"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rubygems:rubygems:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.2.9", "matchCriteriaId": "BEE89FF0-0079-4DF5-ACFC-E1B5415E54F4"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rubygems:rubygems:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.3.6", "matchCriteriaId": "8080FB82-5445-4A17-9ECB-806991906E80"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rubygems:rubygems:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.4.3", "matchCriteriaId": "CCBC38C5-781E-4998-877D-42265F1DBD05"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rubygems:rubygems:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.5.0", "matchCriteriaId": "6ACE6376-2E27-4F56-9315-03367963DB09"}]}]}], "references": [{"url": "http://blog.rubygems.org/2018/02/15/2.7.6-released.html", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-07/msg00036.html", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2018:3729", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2018:3730", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2018:3731", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:2028", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2020:0542", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2020:0591", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2020:0663", "source": "cve@mitre.org"}, {"url": "https://github.com/rubygems/rubygems/commit/1b931fc03b819b9a0214be3eaca844ef534175e2", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/08/msg00028.html", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3621-1/", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2018/dsa-4219", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2018/dsa-4259", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/rubygems/rubygems/commit/1b931fc03b819b9a0214be3eaca844ef534175e2"}}