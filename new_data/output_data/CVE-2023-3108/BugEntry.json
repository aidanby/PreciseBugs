{"buggy_code": ["/*\n * af_alg: User-space algorithm interface\n *\n * This file provides the user-space API for algorithms.\n *\n * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 2 of the License, or (at your option)\n * any later version.\n *\n */\n\n#include <linux/atomic.h>\n#include <crypto/if_alg.h>\n#include <linux/crypto.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/net.h>\n#include <linux/rwsem.h>\n#include <linux/security.h>\n\nstruct alg_type_list {\n\tconst struct af_alg_type *type;\n\tstruct list_head list;\n};\n\nstatic atomic_long_t alg_memory_allocated;\n\nstatic struct proto alg_proto = {\n\t.name\t\t\t= \"ALG\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.memory_allocated\t= &alg_memory_allocated,\n\t.obj_size\t\t= sizeof(struct alg_sock),\n};\n\nstatic LIST_HEAD(alg_types);\nstatic DECLARE_RWSEM(alg_types_sem);\n\nstatic const struct af_alg_type *alg_get_type(const char *name)\n{\n\tconst struct af_alg_type *type = ERR_PTR(-ENOENT);\n\tstruct alg_type_list *node;\n\n\tdown_read(&alg_types_sem);\n\tlist_for_each_entry(node, &alg_types, list) {\n\t\tif (strcmp(node->type->name, name))\n\t\t\tcontinue;\n\n\t\tif (try_module_get(node->type->owner))\n\t\t\ttype = node->type;\n\t\tbreak;\n\t}\n\tup_read(&alg_types_sem);\n\n\treturn type;\n}\n\nint af_alg_register_type(const struct af_alg_type *type)\n{\n\tstruct alg_type_list *node;\n\tint err = -EEXIST;\n\n\tdown_write(&alg_types_sem);\n\tlist_for_each_entry(node, &alg_types, list) {\n\t\tif (!strcmp(node->type->name, type->name))\n\t\t\tgoto unlock;\n\t}\n\n\tnode = kmalloc(sizeof(*node), GFP_KERNEL);\n\terr = -ENOMEM;\n\tif (!node)\n\t\tgoto unlock;\n\n\ttype->ops->owner = THIS_MODULE;\n\tnode->type = type;\n\tlist_add(&node->list, &alg_types);\n\terr = 0;\n\nunlock:\n\tup_write(&alg_types_sem);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(af_alg_register_type);\n\nint af_alg_unregister_type(const struct af_alg_type *type)\n{\n\tstruct alg_type_list *node;\n\tint err = -ENOENT;\n\n\tdown_write(&alg_types_sem);\n\tlist_for_each_entry(node, &alg_types, list) {\n\t\tif (strcmp(node->type->name, type->name))\n\t\t\tcontinue;\n\n\t\tlist_del(&node->list);\n\t\tkfree(node);\n\t\terr = 0;\n\t\tbreak;\n\t}\n\tup_write(&alg_types_sem);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(af_alg_unregister_type);\n\nstatic void alg_do_release(const struct af_alg_type *type, void *private)\n{\n\tif (!type)\n\t\treturn;\n\n\ttype->release(private);\n\tmodule_put(type->owner);\n}\n\nint af_alg_release(struct socket *sock)\n{\n\tif (sock->sk)\n\t\tsock_put(sock->sk);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(af_alg_release);\n\nstatic int alg_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct sockaddr_alg *sa = (void *)uaddr;\n\tconst struct af_alg_type *type;\n\tvoid *private;\n\n\tif (sock->state == SS_CONNECTED)\n\t\treturn -EINVAL;\n\n\tif (addr_len != sizeof(*sa))\n\t\treturn -EINVAL;\n\n\tsa->salg_type[sizeof(sa->salg_type) - 1] = 0;\n\tsa->salg_name[sizeof(sa->salg_name) - 1] = 0;\n\n\ttype = alg_get_type(sa->salg_type);\n\tif (IS_ERR(type) && PTR_ERR(type) == -ENOENT) {\n\t\trequest_module(\"algif-%s\", sa->salg_type);\n\t\ttype = alg_get_type(sa->salg_type);\n\t}\n\n\tif (IS_ERR(type))\n\t\treturn PTR_ERR(type);\n\n\tprivate = type->bind(sa->salg_name, sa->salg_feat, sa->salg_mask);\n\tif (IS_ERR(private)) {\n\t\tmodule_put(type->owner);\n\t\treturn PTR_ERR(private);\n\t}\n\n\tlock_sock(sk);\n\n\tswap(ask->type, type);\n\tswap(ask->private, private);\n\n\trelease_sock(sk);\n\n\talg_do_release(type, private);\n\n\treturn 0;\n}\n\nstatic int alg_setkey(struct sock *sk, char __user *ukey,\n\t\t      unsigned int keylen)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tconst struct af_alg_type *type = ask->type;\n\tu8 *key;\n\tint err;\n\n\tkey = sock_kmalloc(sk, keylen, GFP_KERNEL);\n\tif (!key)\n\t\treturn -ENOMEM;\n\n\terr = -EFAULT;\n\tif (copy_from_user(key, ukey, keylen))\n\t\tgoto out;\n\n\terr = type->setkey(ask->private, key, keylen);\n\nout:\n\tsock_kfree_s(sk, key, keylen);\n\n\treturn err;\n}\n\nstatic int alg_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t  char __user *optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tconst struct af_alg_type *type;\n\tint err = -ENOPROTOOPT;\n\n\tlock_sock(sk);\n\ttype = ask->type;\n\n\tif (level != SOL_ALG || !type)\n\t\tgoto unlock;\n\n\tswitch (optname) {\n\tcase ALG_SET_KEY:\n\t\tif (sock->state == SS_CONNECTED)\n\t\t\tgoto unlock;\n\t\tif (!type->setkey)\n\t\t\tgoto unlock;\n\n\t\terr = alg_setkey(sk, optval, optlen);\n\t}\n\nunlock:\n\trelease_sock(sk);\n\n\treturn err;\n}\n\nint af_alg_accept(struct sock *sk, struct socket *newsock)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tconst struct af_alg_type *type;\n\tstruct sock *sk2;\n\tint err;\n\n\tlock_sock(sk);\n\ttype = ask->type;\n\n\terr = -EINVAL;\n\tif (!type)\n\t\tgoto unlock;\n\n\tsk2 = sk_alloc(sock_net(sk), PF_ALG, GFP_KERNEL, &alg_proto);\n\terr = -ENOMEM;\n\tif (!sk2)\n\t\tgoto unlock;\n\n\tsock_init_data(newsock, sk2);\n\tsock_graft(sk2, newsock);\n\tsecurity_sk_clone(sk, sk2);\n\n\terr = type->accept(ask->private, sk2);\n\tif (err) {\n\t\tsk_free(sk2);\n\t\tgoto unlock;\n\t}\n\n\tsk2->sk_family = PF_ALG;\n\n\tsock_hold(sk);\n\talg_sk(sk2)->parent = sk;\n\talg_sk(sk2)->type = type;\n\n\tnewsock->ops = type->ops;\n\tnewsock->state = SS_CONNECTED;\n\n\terr = 0;\n\nunlock:\n\trelease_sock(sk);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(af_alg_accept);\n\nstatic int alg_accept(struct socket *sock, struct socket *newsock, int flags)\n{\n\treturn af_alg_accept(sock->sk, newsock);\n}\n\nstatic const struct proto_ops alg_proto_ops = {\n\t.family\t\t=\tPF_ALG,\n\t.owner\t\t=\tTHIS_MODULE,\n\n\t.connect\t=\tsock_no_connect,\n\t.socketpair\t=\tsock_no_socketpair,\n\t.getname\t=\tsock_no_getname,\n\t.ioctl\t\t=\tsock_no_ioctl,\n\t.listen\t\t=\tsock_no_listen,\n\t.shutdown\t=\tsock_no_shutdown,\n\t.getsockopt\t=\tsock_no_getsockopt,\n\t.mmap\t\t=\tsock_no_mmap,\n\t.sendpage\t=\tsock_no_sendpage,\n\t.sendmsg\t=\tsock_no_sendmsg,\n\t.recvmsg\t=\tsock_no_recvmsg,\n\t.poll\t\t=\tsock_no_poll,\n\n\t.bind\t\t=\talg_bind,\n\t.release\t=\taf_alg_release,\n\t.setsockopt\t=\talg_setsockopt,\n\t.accept\t\t=\talg_accept,\n};\n\nstatic void alg_sock_destruct(struct sock *sk)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\n\talg_do_release(ask->type, ask->private);\n}\n\nstatic int alg_create(struct net *net, struct socket *sock, int protocol,\n\t\t      int kern)\n{\n\tstruct sock *sk;\n\tint err;\n\n\tif (sock->type != SOCK_SEQPACKET)\n\t\treturn -ESOCKTNOSUPPORT;\n\tif (protocol != 0)\n\t\treturn -EPROTONOSUPPORT;\n\n\terr = -ENOMEM;\n\tsk = sk_alloc(net, PF_ALG, GFP_KERNEL, &alg_proto);\n\tif (!sk)\n\t\tgoto out;\n\n\tsock->ops = &alg_proto_ops;\n\tsock_init_data(sock, sk);\n\n\tsk->sk_family = PF_ALG;\n\tsk->sk_destruct = alg_sock_destruct;\n\n\treturn 0;\nout:\n\treturn err;\n}\n\nstatic const struct net_proto_family alg_family = {\n\t.family\t=\tPF_ALG,\n\t.create\t=\talg_create,\n\t.owner\t=\tTHIS_MODULE,\n};\n\nint af_alg_make_sg(struct af_alg_sgl *sgl, struct iov_iter *iter, int len)\n{\n\tsize_t off;\n\tssize_t n;\n\tint npages, i;\n\n\tn = iov_iter_get_pages(iter, sgl->pages, len, ALG_MAX_PAGES, &off);\n\tif (n < 0)\n\t\treturn n;\n\n\tnpages = PAGE_ALIGN(off + n);\n\tif (WARN_ON(npages == 0))\n\t\treturn -EINVAL;\n\n\tsg_init_table(sgl->sg, npages);\n\n\tfor (i = 0, len = n; i < npages; i++) {\n\t\tint plen = min_t(int, len, PAGE_SIZE - off);\n\n\t\tsg_set_page(sgl->sg + i, sgl->pages[i], plen, off);\n\n\t\toff = 0;\n\t\tlen -= plen;\n\t}\n\treturn n;\n}\nEXPORT_SYMBOL_GPL(af_alg_make_sg);\n\nvoid af_alg_free_sg(struct af_alg_sgl *sgl)\n{\n\tint i;\n\n\ti = 0;\n\tdo {\n\t\tput_page(sgl->pages[i]);\n\t} while (!sg_is_last(sgl->sg + (i++)));\n}\nEXPORT_SYMBOL_GPL(af_alg_free_sg);\n\nint af_alg_cmsg_send(struct msghdr *msg, struct af_alg_control *con)\n{\n\tstruct cmsghdr *cmsg;\n\n\tfor_each_cmsghdr(cmsg, msg) {\n\t\tif (!CMSG_OK(msg, cmsg))\n\t\t\treturn -EINVAL;\n\t\tif (cmsg->cmsg_level != SOL_ALG)\n\t\t\tcontinue;\n\n\t\tswitch(cmsg->cmsg_type) {\n\t\tcase ALG_SET_IV:\n\t\t\tif (cmsg->cmsg_len < CMSG_LEN(sizeof(*con->iv)))\n\t\t\t\treturn -EINVAL;\n\t\t\tcon->iv = (void *)CMSG_DATA(cmsg);\n\t\t\tif (cmsg->cmsg_len < CMSG_LEN(con->iv->ivlen +\n\t\t\t\t\t\t      sizeof(*con->iv)))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\n\t\tcase ALG_SET_OP:\n\t\t\tif (cmsg->cmsg_len < CMSG_LEN(sizeof(u32)))\n\t\t\t\treturn -EINVAL;\n\t\t\tcon->op = *(u32 *)CMSG_DATA(cmsg);\n\t\t\tbreak;\n\n\t\tcase ALG_SET_AEAD_ASSOCLEN:\n\t\t\tif (cmsg->cmsg_len < CMSG_LEN(sizeof(u32)))\n\t\t\t\treturn -EINVAL;\n\t\t\tcon->aead_assoclen = *(u32 *)CMSG_DATA(cmsg);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(af_alg_cmsg_send);\n\nint af_alg_wait_for_completion(int err, struct af_alg_completion *completion)\n{\n\tswitch (err) {\n\tcase -EINPROGRESS:\n\tcase -EBUSY:\n\t\twait_for_completion(&completion->completion);\n\t\treinit_completion(&completion->completion);\n\t\terr = completion->err;\n\t\tbreak;\n\t};\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(af_alg_wait_for_completion);\n\nvoid af_alg_complete(struct crypto_async_request *req, int err)\n{\n\tstruct af_alg_completion *completion = req->data;\n\n\tif (err == -EINPROGRESS)\n\t\treturn;\n\n\tcompletion->err = err;\n\tcomplete(&completion->completion);\n}\nEXPORT_SYMBOL_GPL(af_alg_complete);\n\nstatic int __init af_alg_init(void)\n{\n\tint err = proto_register(&alg_proto, 0);\n\n\tif (err)\n\t\tgoto out;\n\n\terr = sock_register(&alg_family);\n\tif (err != 0)\n\t\tgoto out_unregister_proto;\n\nout:\n\treturn err;\n\nout_unregister_proto:\n\tproto_unregister(&alg_proto);\n\tgoto out;\n}\n\nstatic void __exit af_alg_exit(void)\n{\n\tsock_unregister(PF_ALG);\n\tproto_unregister(&alg_proto);\n}\n\nmodule_init(af_alg_init);\nmodule_exit(af_alg_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_NETPROTO(AF_ALG);\n", "/*\n * algif_skcipher: User-space interface for skcipher algorithms\n *\n * This file provides the user-space API for symmetric key ciphers.\n *\n * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 2 of the License, or (at your option)\n * any later version.\n *\n */\n\n#include <crypto/scatterwalk.h>\n#include <crypto/skcipher.h>\n#include <crypto/if_alg.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/net.h>\n#include <net/sock.h>\n\nstruct skcipher_sg_list {\n\tstruct list_head list;\n\n\tint cur;\n\n\tstruct scatterlist sg[0];\n};\n\nstruct skcipher_ctx {\n\tstruct list_head tsgl;\n\tstruct af_alg_sgl rsgl;\n\n\tvoid *iv;\n\n\tstruct af_alg_completion completion;\n\n\tunsigned used;\n\n\tunsigned int len;\n\tbool more;\n\tbool merge;\n\tbool enc;\n\n\tstruct ablkcipher_request req;\n};\n\n#define MAX_SGL_ENTS ((4096 - sizeof(struct skcipher_sg_list)) / \\\n\t\t      sizeof(struct scatterlist) - 1)\n\nstatic inline int skcipher_sndbuf(struct sock *sk)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\n\treturn max_t(int, max_t(int, sk->sk_sndbuf & PAGE_MASK, PAGE_SIZE) -\n\t\t\t  ctx->used, 0);\n}\n\nstatic inline bool skcipher_writable(struct sock *sk)\n{\n\treturn PAGE_SIZE <= skcipher_sndbuf(sk);\n}\n\nstatic int skcipher_alloc_sgl(struct sock *sk)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tstruct skcipher_sg_list *sgl;\n\tstruct scatterlist *sg = NULL;\n\n\tsgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);\n\tif (!list_empty(&ctx->tsgl))\n\t\tsg = sgl->sg;\n\n\tif (!sg || sgl->cur >= MAX_SGL_ENTS) {\n\t\tsgl = sock_kmalloc(sk, sizeof(*sgl) +\n\t\t\t\t       sizeof(sgl->sg[0]) * (MAX_SGL_ENTS + 1),\n\t\t\t\t   GFP_KERNEL);\n\t\tif (!sgl)\n\t\t\treturn -ENOMEM;\n\n\t\tsg_init_table(sgl->sg, MAX_SGL_ENTS + 1);\n\t\tsgl->cur = 0;\n\n\t\tif (sg)\n\t\t\tscatterwalk_sg_chain(sg, MAX_SGL_ENTS + 1, sgl->sg);\n\n\t\tlist_add_tail(&sgl->list, &ctx->tsgl);\n\t}\n\n\treturn 0;\n}\n\nstatic void skcipher_pull_sgl(struct sock *sk, int used)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tstruct skcipher_sg_list *sgl;\n\tstruct scatterlist *sg;\n\tint i;\n\n\twhile (!list_empty(&ctx->tsgl)) {\n\t\tsgl = list_first_entry(&ctx->tsgl, struct skcipher_sg_list,\n\t\t\t\t       list);\n\t\tsg = sgl->sg;\n\n\t\tfor (i = 0; i < sgl->cur; i++) {\n\t\t\tint plen = min_t(int, used, sg[i].length);\n\n\t\t\tif (!sg_page(sg + i))\n\t\t\t\tcontinue;\n\n\t\t\tsg[i].length -= plen;\n\t\t\tsg[i].offset += plen;\n\n\t\t\tused -= plen;\n\t\t\tctx->used -= plen;\n\n\t\t\tif (sg[i].length)\n\t\t\t\treturn;\n\n\t\t\tput_page(sg_page(sg + i));\n\t\t\tsg_assign_page(sg + i, NULL);\n\t\t}\n\n\t\tlist_del(&sgl->list);\n\t\tsock_kfree_s(sk, sgl,\n\t\t\t     sizeof(*sgl) + sizeof(sgl->sg[0]) *\n\t\t\t\t\t    (MAX_SGL_ENTS + 1));\n\t}\n\n\tif (!ctx->used)\n\t\tctx->merge = 0;\n}\n\nstatic void skcipher_free_sgl(struct sock *sk)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\n\tskcipher_pull_sgl(sk, ctx->used);\n}\n\nstatic int skcipher_wait_for_wmem(struct sock *sk, unsigned flags)\n{\n\tlong timeout;\n\tDEFINE_WAIT(wait);\n\tint err = -ERESTARTSYS;\n\n\tif (flags & MSG_DONTWAIT)\n\t\treturn -EAGAIN;\n\n\tset_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags);\n\n\tfor (;;) {\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\tprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\n\t\ttimeout = MAX_SCHEDULE_TIMEOUT;\n\t\tif (sk_wait_event(sk, &timeout, skcipher_writable(sk))) {\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfinish_wait(sk_sleep(sk), &wait);\n\n\treturn err;\n}\n\nstatic void skcipher_wmem_wakeup(struct sock *sk)\n{\n\tstruct socket_wq *wq;\n\n\tif (!skcipher_writable(sk))\n\t\treturn;\n\n\trcu_read_lock();\n\twq = rcu_dereference(sk->sk_wq);\n\tif (wq_has_sleeper(wq))\n\t\twake_up_interruptible_sync_poll(&wq->wait, POLLIN |\n\t\t\t\t\t\t\t   POLLRDNORM |\n\t\t\t\t\t\t\t   POLLRDBAND);\n\tsk_wake_async(sk, SOCK_WAKE_WAITD, POLL_IN);\n\trcu_read_unlock();\n}\n\nstatic int skcipher_wait_for_data(struct sock *sk, unsigned flags)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tlong timeout;\n\tDEFINE_WAIT(wait);\n\tint err = -ERESTARTSYS;\n\n\tif (flags & MSG_DONTWAIT) {\n\t\treturn -EAGAIN;\n\t}\n\n\tset_bit(SOCK_ASYNC_WAITDATA, &sk->sk_socket->flags);\n\n\tfor (;;) {\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\tprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\n\t\ttimeout = MAX_SCHEDULE_TIMEOUT;\n\t\tif (sk_wait_event(sk, &timeout, ctx->used)) {\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfinish_wait(sk_sleep(sk), &wait);\n\n\tclear_bit(SOCK_ASYNC_WAITDATA, &sk->sk_socket->flags);\n\n\treturn err;\n}\n\nstatic void skcipher_data_wakeup(struct sock *sk)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tstruct socket_wq *wq;\n\n\tif (!ctx->used)\n\t\treturn;\n\n\trcu_read_lock();\n\twq = rcu_dereference(sk->sk_wq);\n\tif (wq_has_sleeper(wq))\n\t\twake_up_interruptible_sync_poll(&wq->wait, POLLOUT |\n\t\t\t\t\t\t\t   POLLRDNORM |\n\t\t\t\t\t\t\t   POLLRDBAND);\n\tsk_wake_async(sk, SOCK_WAKE_SPACE, POLL_OUT);\n\trcu_read_unlock();\n}\n\nstatic int skcipher_sendmsg(struct kiocb *unused, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t size)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tstruct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(&ctx->req);\n\tunsigned ivsize = crypto_ablkcipher_ivsize(tfm);\n\tstruct skcipher_sg_list *sgl;\n\tstruct af_alg_control con = {};\n\tlong copied = 0;\n\tbool enc = 0;\n\tbool init = 0;\n\tint err;\n\tint i;\n\n\tif (msg->msg_controllen) {\n\t\terr = af_alg_cmsg_send(msg, &con);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tinit = 1;\n\t\tswitch (con.op) {\n\t\tcase ALG_OP_ENCRYPT:\n\t\t\tenc = 1;\n\t\t\tbreak;\n\t\tcase ALG_OP_DECRYPT:\n\t\t\tenc = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (con.iv && con.iv->ivlen != ivsize)\n\t\t\treturn -EINVAL;\n\t}\n\n\terr = -EINVAL;\n\n\tlock_sock(sk);\n\tif (!ctx->more && ctx->used)\n\t\tgoto unlock;\n\n\tif (init) {\n\t\tctx->enc = enc;\n\t\tif (con.iv)\n\t\t\tmemcpy(ctx->iv, con.iv->iv, ivsize);\n\t}\n\n\twhile (size) {\n\t\tstruct scatterlist *sg;\n\t\tunsigned long len = size;\n\t\tint plen;\n\n\t\tif (ctx->merge) {\n\t\t\tsgl = list_entry(ctx->tsgl.prev,\n\t\t\t\t\t struct skcipher_sg_list, list);\n\t\t\tsg = sgl->sg + sgl->cur - 1;\n\t\t\tlen = min_t(unsigned long, len,\n\t\t\t\t    PAGE_SIZE - sg->offset - sg->length);\n\n\t\t\terr = memcpy_from_msg(page_address(sg_page(sg)) +\n\t\t\t\t\t      sg->offset + sg->length,\n\t\t\t\t\t      msg, len);\n\t\t\tif (err)\n\t\t\t\tgoto unlock;\n\n\t\t\tsg->length += len;\n\t\t\tctx->merge = (sg->offset + sg->length) &\n\t\t\t\t     (PAGE_SIZE - 1);\n\n\t\t\tctx->used += len;\n\t\t\tcopied += len;\n\t\t\tsize -= len;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!skcipher_writable(sk)) {\n\t\t\terr = skcipher_wait_for_wmem(sk, msg->msg_flags);\n\t\t\tif (err)\n\t\t\t\tgoto unlock;\n\t\t}\n\n\t\tlen = min_t(unsigned long, len, skcipher_sndbuf(sk));\n\n\t\terr = skcipher_alloc_sgl(sk);\n\t\tif (err)\n\t\t\tgoto unlock;\n\n\t\tsgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);\n\t\tsg = sgl->sg;\n\t\tdo {\n\t\t\ti = sgl->cur;\n\t\t\tplen = min_t(int, len, PAGE_SIZE);\n\n\t\t\tsg_assign_page(sg + i, alloc_page(GFP_KERNEL));\n\t\t\terr = -ENOMEM;\n\t\t\tif (!sg_page(sg + i))\n\t\t\t\tgoto unlock;\n\n\t\t\terr = memcpy_from_msg(page_address(sg_page(sg + i)),\n\t\t\t\t\t      msg, plen);\n\t\t\tif (err) {\n\t\t\t\t__free_page(sg_page(sg + i));\n\t\t\t\tsg_assign_page(sg + i, NULL);\n\t\t\t\tgoto unlock;\n\t\t\t}\n\n\t\t\tsg[i].length = plen;\n\t\t\tlen -= plen;\n\t\t\tctx->used += plen;\n\t\t\tcopied += plen;\n\t\t\tsize -= plen;\n\t\t\tsgl->cur++;\n\t\t} while (len && sgl->cur < MAX_SGL_ENTS);\n\n\t\tctx->merge = plen & (PAGE_SIZE - 1);\n\t}\n\n\terr = 0;\n\n\tctx->more = msg->msg_flags & MSG_MORE;\n\nunlock:\n\tskcipher_data_wakeup(sk);\n\trelease_sock(sk);\n\n\treturn copied ?: err;\n}\n\nstatic ssize_t skcipher_sendpage(struct socket *sock, struct page *page,\n\t\t\t\t int offset, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tstruct skcipher_sg_list *sgl;\n\tint err = -EINVAL;\n\n\tif (flags & MSG_SENDPAGE_NOTLAST)\n\t\tflags |= MSG_MORE;\n\n\tlock_sock(sk);\n\tif (!ctx->more && ctx->used)\n\t\tgoto unlock;\n\n\tif (!size)\n\t\tgoto done;\n\n\tif (!skcipher_writable(sk)) {\n\t\terr = skcipher_wait_for_wmem(sk, flags);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t}\n\n\terr = skcipher_alloc_sgl(sk);\n\tif (err)\n\t\tgoto unlock;\n\n\tctx->merge = 0;\n\tsgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);\n\n\tget_page(page);\n\tsg_set_page(sgl->sg + sgl->cur, page, size, offset);\n\tsgl->cur++;\n\tctx->used += size;\n\ndone:\n\tctx->more = flags & MSG_MORE;\n\nunlock:\n\tskcipher_data_wakeup(sk);\n\trelease_sock(sk);\n\n\treturn err ?: size;\n}\n\nstatic int skcipher_recvmsg(struct kiocb *unused, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t ignored, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tunsigned bs = crypto_ablkcipher_blocksize(crypto_ablkcipher_reqtfm(\n\t\t&ctx->req));\n\tstruct skcipher_sg_list *sgl;\n\tstruct scatterlist *sg;\n\tint err = -EAGAIN;\n\tint used;\n\tlong copied = 0;\n\n\tlock_sock(sk);\n\twhile (iov_iter_count(&msg->msg_iter)) {\n\t\tsgl = list_first_entry(&ctx->tsgl,\n\t\t\t\t       struct skcipher_sg_list, list);\n\t\tsg = sgl->sg;\n\n\t\twhile (!sg->length)\n\t\t\tsg++;\n\n\t\tused = ctx->used;\n\t\tif (!used) {\n\t\t\terr = skcipher_wait_for_data(sk, flags);\n\t\t\tif (err)\n\t\t\t\tgoto unlock;\n\t\t}\n\n\t\tused = min_t(unsigned long, used, iov_iter_count(&msg->msg_iter));\n\n\t\tused = af_alg_make_sg(&ctx->rsgl, &msg->msg_iter, used);\n\t\terr = used;\n\t\tif (err < 0)\n\t\t\tgoto unlock;\n\n\t\tif (ctx->more || used < ctx->used)\n\t\t\tused -= used % bs;\n\n\t\terr = -EINVAL;\n\t\tif (!used)\n\t\t\tgoto free;\n\n\t\tablkcipher_request_set_crypt(&ctx->req, sg,\n\t\t\t\t\t     ctx->rsgl.sg, used,\n\t\t\t\t\t     ctx->iv);\n\n\t\terr = af_alg_wait_for_completion(\n\t\t\t\tctx->enc ?\n\t\t\t\t\tcrypto_ablkcipher_encrypt(&ctx->req) :\n\t\t\t\t\tcrypto_ablkcipher_decrypt(&ctx->req),\n\t\t\t\t&ctx->completion);\n\nfree:\n\t\taf_alg_free_sg(&ctx->rsgl);\n\n\t\tif (err)\n\t\t\tgoto unlock;\n\n\t\tcopied += used;\n\t\tskcipher_pull_sgl(sk, used);\n\t\tiov_iter_advance(&msg->msg_iter, used);\n\t}\n\n\terr = 0;\n\nunlock:\n\tskcipher_wmem_wakeup(sk);\n\trelease_sock(sk);\n\n\treturn copied ?: err;\n}\n\n\nstatic unsigned int skcipher_poll(struct file *file, struct socket *sock,\n\t\t\t\t  poll_table *wait)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tunsigned int mask;\n\n\tsock_poll_wait(file, sk_sleep(sk), wait);\n\tmask = 0;\n\n\tif (ctx->used)\n\t\tmask |= POLLIN | POLLRDNORM;\n\n\tif (skcipher_writable(sk))\n\t\tmask |= POLLOUT | POLLWRNORM | POLLWRBAND;\n\n\treturn mask;\n}\n\nstatic struct proto_ops algif_skcipher_ops = {\n\t.family\t\t=\tPF_ALG,\n\n\t.connect\t=\tsock_no_connect,\n\t.socketpair\t=\tsock_no_socketpair,\n\t.getname\t=\tsock_no_getname,\n\t.ioctl\t\t=\tsock_no_ioctl,\n\t.listen\t\t=\tsock_no_listen,\n\t.shutdown\t=\tsock_no_shutdown,\n\t.getsockopt\t=\tsock_no_getsockopt,\n\t.mmap\t\t=\tsock_no_mmap,\n\t.bind\t\t=\tsock_no_bind,\n\t.accept\t\t=\tsock_no_accept,\n\t.setsockopt\t=\tsock_no_setsockopt,\n\n\t.release\t=\taf_alg_release,\n\t.sendmsg\t=\tskcipher_sendmsg,\n\t.sendpage\t=\tskcipher_sendpage,\n\t.recvmsg\t=\tskcipher_recvmsg,\n\t.poll\t\t=\tskcipher_poll,\n};\n\nstatic void *skcipher_bind(const char *name, u32 type, u32 mask)\n{\n\treturn crypto_alloc_ablkcipher(name, type, mask);\n}\n\nstatic void skcipher_release(void *private)\n{\n\tcrypto_free_ablkcipher(private);\n}\n\nstatic int skcipher_setkey(void *private, const u8 *key, unsigned int keylen)\n{\n\treturn crypto_ablkcipher_setkey(private, key, keylen);\n}\n\nstatic void skcipher_sock_destruct(struct sock *sk)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tstruct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(&ctx->req);\n\n\tskcipher_free_sgl(sk);\n\tsock_kzfree_s(sk, ctx->iv, crypto_ablkcipher_ivsize(tfm));\n\tsock_kfree_s(sk, ctx, ctx->len);\n\taf_alg_release_parent(sk);\n}\n\nstatic int skcipher_accept_parent(void *private, struct sock *sk)\n{\n\tstruct skcipher_ctx *ctx;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tunsigned int len = sizeof(*ctx) + crypto_ablkcipher_reqsize(private);\n\n\tctx = sock_kmalloc(sk, len, GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->iv = sock_kmalloc(sk, crypto_ablkcipher_ivsize(private),\n\t\t\t       GFP_KERNEL);\n\tif (!ctx->iv) {\n\t\tsock_kfree_s(sk, ctx, len);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(ctx->iv, 0, crypto_ablkcipher_ivsize(private));\n\n\tINIT_LIST_HEAD(&ctx->tsgl);\n\tctx->len = len;\n\tctx->used = 0;\n\tctx->more = 0;\n\tctx->merge = 0;\n\tctx->enc = 0;\n\taf_alg_init_completion(&ctx->completion);\n\n\task->private = ctx;\n\n\tablkcipher_request_set_tfm(&ctx->req, private);\n\tablkcipher_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t\taf_alg_complete, &ctx->completion);\n\n\tsk->sk_destruct = skcipher_sock_destruct;\n\n\treturn 0;\n}\n\nstatic const struct af_alg_type algif_type_skcipher = {\n\t.bind\t\t=\tskcipher_bind,\n\t.release\t=\tskcipher_release,\n\t.setkey\t\t=\tskcipher_setkey,\n\t.accept\t\t=\tskcipher_accept_parent,\n\t.ops\t\t=\t&algif_skcipher_ops,\n\t.name\t\t=\t\"skcipher\",\n\t.owner\t\t=\tTHIS_MODULE\n};\n\nstatic int __init algif_skcipher_init(void)\n{\n\treturn af_alg_register_type(&algif_type_skcipher);\n}\n\nstatic void __exit algif_skcipher_exit(void)\n{\n\tint err = af_alg_unregister_type(&algif_type_skcipher);\n\tBUG_ON(err);\n}\n\nmodule_init(algif_skcipher_init);\nmodule_exit(algif_skcipher_exit);\nMODULE_LICENSE(\"GPL\");\n"], "fixing_code": ["/*\n * af_alg: User-space algorithm interface\n *\n * This file provides the user-space API for algorithms.\n *\n * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 2 of the License, or (at your option)\n * any later version.\n *\n */\n\n#include <linux/atomic.h>\n#include <crypto/if_alg.h>\n#include <linux/crypto.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/net.h>\n#include <linux/rwsem.h>\n#include <linux/security.h>\n\nstruct alg_type_list {\n\tconst struct af_alg_type *type;\n\tstruct list_head list;\n};\n\nstatic atomic_long_t alg_memory_allocated;\n\nstatic struct proto alg_proto = {\n\t.name\t\t\t= \"ALG\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.memory_allocated\t= &alg_memory_allocated,\n\t.obj_size\t\t= sizeof(struct alg_sock),\n};\n\nstatic LIST_HEAD(alg_types);\nstatic DECLARE_RWSEM(alg_types_sem);\n\nstatic const struct af_alg_type *alg_get_type(const char *name)\n{\n\tconst struct af_alg_type *type = ERR_PTR(-ENOENT);\n\tstruct alg_type_list *node;\n\n\tdown_read(&alg_types_sem);\n\tlist_for_each_entry(node, &alg_types, list) {\n\t\tif (strcmp(node->type->name, name))\n\t\t\tcontinue;\n\n\t\tif (try_module_get(node->type->owner))\n\t\t\ttype = node->type;\n\t\tbreak;\n\t}\n\tup_read(&alg_types_sem);\n\n\treturn type;\n}\n\nint af_alg_register_type(const struct af_alg_type *type)\n{\n\tstruct alg_type_list *node;\n\tint err = -EEXIST;\n\n\tdown_write(&alg_types_sem);\n\tlist_for_each_entry(node, &alg_types, list) {\n\t\tif (!strcmp(node->type->name, type->name))\n\t\t\tgoto unlock;\n\t}\n\n\tnode = kmalloc(sizeof(*node), GFP_KERNEL);\n\terr = -ENOMEM;\n\tif (!node)\n\t\tgoto unlock;\n\n\ttype->ops->owner = THIS_MODULE;\n\tnode->type = type;\n\tlist_add(&node->list, &alg_types);\n\terr = 0;\n\nunlock:\n\tup_write(&alg_types_sem);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(af_alg_register_type);\n\nint af_alg_unregister_type(const struct af_alg_type *type)\n{\n\tstruct alg_type_list *node;\n\tint err = -ENOENT;\n\n\tdown_write(&alg_types_sem);\n\tlist_for_each_entry(node, &alg_types, list) {\n\t\tif (strcmp(node->type->name, type->name))\n\t\t\tcontinue;\n\n\t\tlist_del(&node->list);\n\t\tkfree(node);\n\t\terr = 0;\n\t\tbreak;\n\t}\n\tup_write(&alg_types_sem);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(af_alg_unregister_type);\n\nstatic void alg_do_release(const struct af_alg_type *type, void *private)\n{\n\tif (!type)\n\t\treturn;\n\n\ttype->release(private);\n\tmodule_put(type->owner);\n}\n\nint af_alg_release(struct socket *sock)\n{\n\tif (sock->sk)\n\t\tsock_put(sock->sk);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(af_alg_release);\n\nstatic int alg_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct sockaddr_alg *sa = (void *)uaddr;\n\tconst struct af_alg_type *type;\n\tvoid *private;\n\n\tif (sock->state == SS_CONNECTED)\n\t\treturn -EINVAL;\n\n\tif (addr_len != sizeof(*sa))\n\t\treturn -EINVAL;\n\n\tsa->salg_type[sizeof(sa->salg_type) - 1] = 0;\n\tsa->salg_name[sizeof(sa->salg_name) - 1] = 0;\n\n\ttype = alg_get_type(sa->salg_type);\n\tif (IS_ERR(type) && PTR_ERR(type) == -ENOENT) {\n\t\trequest_module(\"algif-%s\", sa->salg_type);\n\t\ttype = alg_get_type(sa->salg_type);\n\t}\n\n\tif (IS_ERR(type))\n\t\treturn PTR_ERR(type);\n\n\tprivate = type->bind(sa->salg_name, sa->salg_feat, sa->salg_mask);\n\tif (IS_ERR(private)) {\n\t\tmodule_put(type->owner);\n\t\treturn PTR_ERR(private);\n\t}\n\n\tlock_sock(sk);\n\n\tswap(ask->type, type);\n\tswap(ask->private, private);\n\n\trelease_sock(sk);\n\n\talg_do_release(type, private);\n\n\treturn 0;\n}\n\nstatic int alg_setkey(struct sock *sk, char __user *ukey,\n\t\t      unsigned int keylen)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tconst struct af_alg_type *type = ask->type;\n\tu8 *key;\n\tint err;\n\n\tkey = sock_kmalloc(sk, keylen, GFP_KERNEL);\n\tif (!key)\n\t\treturn -ENOMEM;\n\n\terr = -EFAULT;\n\tif (copy_from_user(key, ukey, keylen))\n\t\tgoto out;\n\n\terr = type->setkey(ask->private, key, keylen);\n\nout:\n\tsock_kfree_s(sk, key, keylen);\n\n\treturn err;\n}\n\nstatic int alg_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t  char __user *optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tconst struct af_alg_type *type;\n\tint err = -ENOPROTOOPT;\n\n\tlock_sock(sk);\n\ttype = ask->type;\n\n\tif (level != SOL_ALG || !type)\n\t\tgoto unlock;\n\n\tswitch (optname) {\n\tcase ALG_SET_KEY:\n\t\tif (sock->state == SS_CONNECTED)\n\t\t\tgoto unlock;\n\t\tif (!type->setkey)\n\t\t\tgoto unlock;\n\n\t\terr = alg_setkey(sk, optval, optlen);\n\t}\n\nunlock:\n\trelease_sock(sk);\n\n\treturn err;\n}\n\nint af_alg_accept(struct sock *sk, struct socket *newsock)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tconst struct af_alg_type *type;\n\tstruct sock *sk2;\n\tint err;\n\n\tlock_sock(sk);\n\ttype = ask->type;\n\n\terr = -EINVAL;\n\tif (!type)\n\t\tgoto unlock;\n\n\tsk2 = sk_alloc(sock_net(sk), PF_ALG, GFP_KERNEL, &alg_proto);\n\terr = -ENOMEM;\n\tif (!sk2)\n\t\tgoto unlock;\n\n\tsock_init_data(newsock, sk2);\n\tsock_graft(sk2, newsock);\n\tsecurity_sk_clone(sk, sk2);\n\n\terr = type->accept(ask->private, sk2);\n\tif (err) {\n\t\tsk_free(sk2);\n\t\tgoto unlock;\n\t}\n\n\tsk2->sk_family = PF_ALG;\n\n\tsock_hold(sk);\n\talg_sk(sk2)->parent = sk;\n\talg_sk(sk2)->type = type;\n\n\tnewsock->ops = type->ops;\n\tnewsock->state = SS_CONNECTED;\n\n\terr = 0;\n\nunlock:\n\trelease_sock(sk);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(af_alg_accept);\n\nstatic int alg_accept(struct socket *sock, struct socket *newsock, int flags)\n{\n\treturn af_alg_accept(sock->sk, newsock);\n}\n\nstatic const struct proto_ops alg_proto_ops = {\n\t.family\t\t=\tPF_ALG,\n\t.owner\t\t=\tTHIS_MODULE,\n\n\t.connect\t=\tsock_no_connect,\n\t.socketpair\t=\tsock_no_socketpair,\n\t.getname\t=\tsock_no_getname,\n\t.ioctl\t\t=\tsock_no_ioctl,\n\t.listen\t\t=\tsock_no_listen,\n\t.shutdown\t=\tsock_no_shutdown,\n\t.getsockopt\t=\tsock_no_getsockopt,\n\t.mmap\t\t=\tsock_no_mmap,\n\t.sendpage\t=\tsock_no_sendpage,\n\t.sendmsg\t=\tsock_no_sendmsg,\n\t.recvmsg\t=\tsock_no_recvmsg,\n\t.poll\t\t=\tsock_no_poll,\n\n\t.bind\t\t=\talg_bind,\n\t.release\t=\taf_alg_release,\n\t.setsockopt\t=\talg_setsockopt,\n\t.accept\t\t=\talg_accept,\n};\n\nstatic void alg_sock_destruct(struct sock *sk)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\n\talg_do_release(ask->type, ask->private);\n}\n\nstatic int alg_create(struct net *net, struct socket *sock, int protocol,\n\t\t      int kern)\n{\n\tstruct sock *sk;\n\tint err;\n\n\tif (sock->type != SOCK_SEQPACKET)\n\t\treturn -ESOCKTNOSUPPORT;\n\tif (protocol != 0)\n\t\treturn -EPROTONOSUPPORT;\n\n\terr = -ENOMEM;\n\tsk = sk_alloc(net, PF_ALG, GFP_KERNEL, &alg_proto);\n\tif (!sk)\n\t\tgoto out;\n\n\tsock->ops = &alg_proto_ops;\n\tsock_init_data(sock, sk);\n\n\tsk->sk_family = PF_ALG;\n\tsk->sk_destruct = alg_sock_destruct;\n\n\treturn 0;\nout:\n\treturn err;\n}\n\nstatic const struct net_proto_family alg_family = {\n\t.family\t=\tPF_ALG,\n\t.create\t=\talg_create,\n\t.owner\t=\tTHIS_MODULE,\n};\n\nint af_alg_make_sg(struct af_alg_sgl *sgl, struct iov_iter *iter, int len)\n{\n\tsize_t off;\n\tssize_t n;\n\tint npages, i;\n\n\tn = iov_iter_get_pages(iter, sgl->pages, len, ALG_MAX_PAGES, &off);\n\tif (n < 0)\n\t\treturn n;\n\n\tnpages = (off + n + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tif (WARN_ON(npages == 0))\n\t\treturn -EINVAL;\n\n\tsg_init_table(sgl->sg, npages);\n\n\tfor (i = 0, len = n; i < npages; i++) {\n\t\tint plen = min_t(int, len, PAGE_SIZE - off);\n\n\t\tsg_set_page(sgl->sg + i, sgl->pages[i], plen, off);\n\n\t\toff = 0;\n\t\tlen -= plen;\n\t}\n\treturn n;\n}\nEXPORT_SYMBOL_GPL(af_alg_make_sg);\n\nvoid af_alg_free_sg(struct af_alg_sgl *sgl)\n{\n\tint i;\n\n\ti = 0;\n\tdo {\n\t\tput_page(sgl->pages[i]);\n\t} while (!sg_is_last(sgl->sg + (i++)));\n}\nEXPORT_SYMBOL_GPL(af_alg_free_sg);\n\nint af_alg_cmsg_send(struct msghdr *msg, struct af_alg_control *con)\n{\n\tstruct cmsghdr *cmsg;\n\n\tfor_each_cmsghdr(cmsg, msg) {\n\t\tif (!CMSG_OK(msg, cmsg))\n\t\t\treturn -EINVAL;\n\t\tif (cmsg->cmsg_level != SOL_ALG)\n\t\t\tcontinue;\n\n\t\tswitch(cmsg->cmsg_type) {\n\t\tcase ALG_SET_IV:\n\t\t\tif (cmsg->cmsg_len < CMSG_LEN(sizeof(*con->iv)))\n\t\t\t\treturn -EINVAL;\n\t\t\tcon->iv = (void *)CMSG_DATA(cmsg);\n\t\t\tif (cmsg->cmsg_len < CMSG_LEN(con->iv->ivlen +\n\t\t\t\t\t\t      sizeof(*con->iv)))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\n\t\tcase ALG_SET_OP:\n\t\t\tif (cmsg->cmsg_len < CMSG_LEN(sizeof(u32)))\n\t\t\t\treturn -EINVAL;\n\t\t\tcon->op = *(u32 *)CMSG_DATA(cmsg);\n\t\t\tbreak;\n\n\t\tcase ALG_SET_AEAD_ASSOCLEN:\n\t\t\tif (cmsg->cmsg_len < CMSG_LEN(sizeof(u32)))\n\t\t\t\treturn -EINVAL;\n\t\t\tcon->aead_assoclen = *(u32 *)CMSG_DATA(cmsg);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(af_alg_cmsg_send);\n\nint af_alg_wait_for_completion(int err, struct af_alg_completion *completion)\n{\n\tswitch (err) {\n\tcase -EINPROGRESS:\n\tcase -EBUSY:\n\t\twait_for_completion(&completion->completion);\n\t\treinit_completion(&completion->completion);\n\t\terr = completion->err;\n\t\tbreak;\n\t};\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(af_alg_wait_for_completion);\n\nvoid af_alg_complete(struct crypto_async_request *req, int err)\n{\n\tstruct af_alg_completion *completion = req->data;\n\n\tif (err == -EINPROGRESS)\n\t\treturn;\n\n\tcompletion->err = err;\n\tcomplete(&completion->completion);\n}\nEXPORT_SYMBOL_GPL(af_alg_complete);\n\nstatic int __init af_alg_init(void)\n{\n\tint err = proto_register(&alg_proto, 0);\n\n\tif (err)\n\t\tgoto out;\n\n\terr = sock_register(&alg_family);\n\tif (err != 0)\n\t\tgoto out_unregister_proto;\n\nout:\n\treturn err;\n\nout_unregister_proto:\n\tproto_unregister(&alg_proto);\n\tgoto out;\n}\n\nstatic void __exit af_alg_exit(void)\n{\n\tsock_unregister(PF_ALG);\n\tproto_unregister(&alg_proto);\n}\n\nmodule_init(af_alg_init);\nmodule_exit(af_alg_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_NETPROTO(AF_ALG);\n", "/*\n * algif_skcipher: User-space interface for skcipher algorithms\n *\n * This file provides the user-space API for symmetric key ciphers.\n *\n * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 2 of the License, or (at your option)\n * any later version.\n *\n */\n\n#include <crypto/scatterwalk.h>\n#include <crypto/skcipher.h>\n#include <crypto/if_alg.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/net.h>\n#include <net/sock.h>\n\nstruct skcipher_sg_list {\n\tstruct list_head list;\n\n\tint cur;\n\n\tstruct scatterlist sg[0];\n};\n\nstruct skcipher_ctx {\n\tstruct list_head tsgl;\n\tstruct af_alg_sgl rsgl;\n\n\tvoid *iv;\n\n\tstruct af_alg_completion completion;\n\n\tunsigned used;\n\n\tunsigned int len;\n\tbool more;\n\tbool merge;\n\tbool enc;\n\n\tstruct ablkcipher_request req;\n};\n\n#define MAX_SGL_ENTS ((4096 - sizeof(struct skcipher_sg_list)) / \\\n\t\t      sizeof(struct scatterlist) - 1)\n\nstatic inline int skcipher_sndbuf(struct sock *sk)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\n\treturn max_t(int, max_t(int, sk->sk_sndbuf & PAGE_MASK, PAGE_SIZE) -\n\t\t\t  ctx->used, 0);\n}\n\nstatic inline bool skcipher_writable(struct sock *sk)\n{\n\treturn PAGE_SIZE <= skcipher_sndbuf(sk);\n}\n\nstatic int skcipher_alloc_sgl(struct sock *sk)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tstruct skcipher_sg_list *sgl;\n\tstruct scatterlist *sg = NULL;\n\n\tsgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);\n\tif (!list_empty(&ctx->tsgl))\n\t\tsg = sgl->sg;\n\n\tif (!sg || sgl->cur >= MAX_SGL_ENTS) {\n\t\tsgl = sock_kmalloc(sk, sizeof(*sgl) +\n\t\t\t\t       sizeof(sgl->sg[0]) * (MAX_SGL_ENTS + 1),\n\t\t\t\t   GFP_KERNEL);\n\t\tif (!sgl)\n\t\t\treturn -ENOMEM;\n\n\t\tsg_init_table(sgl->sg, MAX_SGL_ENTS + 1);\n\t\tsgl->cur = 0;\n\n\t\tif (sg)\n\t\t\tscatterwalk_sg_chain(sg, MAX_SGL_ENTS + 1, sgl->sg);\n\n\t\tlist_add_tail(&sgl->list, &ctx->tsgl);\n\t}\n\n\treturn 0;\n}\n\nstatic void skcipher_pull_sgl(struct sock *sk, int used)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tstruct skcipher_sg_list *sgl;\n\tstruct scatterlist *sg;\n\tint i;\n\n\twhile (!list_empty(&ctx->tsgl)) {\n\t\tsgl = list_first_entry(&ctx->tsgl, struct skcipher_sg_list,\n\t\t\t\t       list);\n\t\tsg = sgl->sg;\n\n\t\tfor (i = 0; i < sgl->cur; i++) {\n\t\t\tint plen = min_t(int, used, sg[i].length);\n\n\t\t\tif (!sg_page(sg + i))\n\t\t\t\tcontinue;\n\n\t\t\tsg[i].length -= plen;\n\t\t\tsg[i].offset += plen;\n\n\t\t\tused -= plen;\n\t\t\tctx->used -= plen;\n\n\t\t\tif (sg[i].length)\n\t\t\t\treturn;\n\n\t\t\tput_page(sg_page(sg + i));\n\t\t\tsg_assign_page(sg + i, NULL);\n\t\t}\n\n\t\tlist_del(&sgl->list);\n\t\tsock_kfree_s(sk, sgl,\n\t\t\t     sizeof(*sgl) + sizeof(sgl->sg[0]) *\n\t\t\t\t\t    (MAX_SGL_ENTS + 1));\n\t}\n\n\tif (!ctx->used)\n\t\tctx->merge = 0;\n}\n\nstatic void skcipher_free_sgl(struct sock *sk)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\n\tskcipher_pull_sgl(sk, ctx->used);\n}\n\nstatic int skcipher_wait_for_wmem(struct sock *sk, unsigned flags)\n{\n\tlong timeout;\n\tDEFINE_WAIT(wait);\n\tint err = -ERESTARTSYS;\n\n\tif (flags & MSG_DONTWAIT)\n\t\treturn -EAGAIN;\n\n\tset_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags);\n\n\tfor (;;) {\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\tprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\n\t\ttimeout = MAX_SCHEDULE_TIMEOUT;\n\t\tif (sk_wait_event(sk, &timeout, skcipher_writable(sk))) {\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfinish_wait(sk_sleep(sk), &wait);\n\n\treturn err;\n}\n\nstatic void skcipher_wmem_wakeup(struct sock *sk)\n{\n\tstruct socket_wq *wq;\n\n\tif (!skcipher_writable(sk))\n\t\treturn;\n\n\trcu_read_lock();\n\twq = rcu_dereference(sk->sk_wq);\n\tif (wq_has_sleeper(wq))\n\t\twake_up_interruptible_sync_poll(&wq->wait, POLLIN |\n\t\t\t\t\t\t\t   POLLRDNORM |\n\t\t\t\t\t\t\t   POLLRDBAND);\n\tsk_wake_async(sk, SOCK_WAKE_WAITD, POLL_IN);\n\trcu_read_unlock();\n}\n\nstatic int skcipher_wait_for_data(struct sock *sk, unsigned flags)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tlong timeout;\n\tDEFINE_WAIT(wait);\n\tint err = -ERESTARTSYS;\n\n\tif (flags & MSG_DONTWAIT) {\n\t\treturn -EAGAIN;\n\t}\n\n\tset_bit(SOCK_ASYNC_WAITDATA, &sk->sk_socket->flags);\n\n\tfor (;;) {\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\tprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\n\t\ttimeout = MAX_SCHEDULE_TIMEOUT;\n\t\tif (sk_wait_event(sk, &timeout, ctx->used)) {\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfinish_wait(sk_sleep(sk), &wait);\n\n\tclear_bit(SOCK_ASYNC_WAITDATA, &sk->sk_socket->flags);\n\n\treturn err;\n}\n\nstatic void skcipher_data_wakeup(struct sock *sk)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tstruct socket_wq *wq;\n\n\tif (!ctx->used)\n\t\treturn;\n\n\trcu_read_lock();\n\twq = rcu_dereference(sk->sk_wq);\n\tif (wq_has_sleeper(wq))\n\t\twake_up_interruptible_sync_poll(&wq->wait, POLLOUT |\n\t\t\t\t\t\t\t   POLLRDNORM |\n\t\t\t\t\t\t\t   POLLRDBAND);\n\tsk_wake_async(sk, SOCK_WAKE_SPACE, POLL_OUT);\n\trcu_read_unlock();\n}\n\nstatic int skcipher_sendmsg(struct kiocb *unused, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t size)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tstruct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(&ctx->req);\n\tunsigned ivsize = crypto_ablkcipher_ivsize(tfm);\n\tstruct skcipher_sg_list *sgl;\n\tstruct af_alg_control con = {};\n\tlong copied = 0;\n\tbool enc = 0;\n\tbool init = 0;\n\tint err;\n\tint i;\n\n\tif (msg->msg_controllen) {\n\t\terr = af_alg_cmsg_send(msg, &con);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tinit = 1;\n\t\tswitch (con.op) {\n\t\tcase ALG_OP_ENCRYPT:\n\t\t\tenc = 1;\n\t\t\tbreak;\n\t\tcase ALG_OP_DECRYPT:\n\t\t\tenc = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (con.iv && con.iv->ivlen != ivsize)\n\t\t\treturn -EINVAL;\n\t}\n\n\terr = -EINVAL;\n\n\tlock_sock(sk);\n\tif (!ctx->more && ctx->used)\n\t\tgoto unlock;\n\n\tif (init) {\n\t\tctx->enc = enc;\n\t\tif (con.iv)\n\t\t\tmemcpy(ctx->iv, con.iv->iv, ivsize);\n\t}\n\n\twhile (size) {\n\t\tstruct scatterlist *sg;\n\t\tunsigned long len = size;\n\t\tint plen;\n\n\t\tif (ctx->merge) {\n\t\t\tsgl = list_entry(ctx->tsgl.prev,\n\t\t\t\t\t struct skcipher_sg_list, list);\n\t\t\tsg = sgl->sg + sgl->cur - 1;\n\t\t\tlen = min_t(unsigned long, len,\n\t\t\t\t    PAGE_SIZE - sg->offset - sg->length);\n\n\t\t\terr = memcpy_from_msg(page_address(sg_page(sg)) +\n\t\t\t\t\t      sg->offset + sg->length,\n\t\t\t\t\t      msg, len);\n\t\t\tif (err)\n\t\t\t\tgoto unlock;\n\n\t\t\tsg->length += len;\n\t\t\tctx->merge = (sg->offset + sg->length) &\n\t\t\t\t     (PAGE_SIZE - 1);\n\n\t\t\tctx->used += len;\n\t\t\tcopied += len;\n\t\t\tsize -= len;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!skcipher_writable(sk)) {\n\t\t\terr = skcipher_wait_for_wmem(sk, msg->msg_flags);\n\t\t\tif (err)\n\t\t\t\tgoto unlock;\n\t\t}\n\n\t\tlen = min_t(unsigned long, len, skcipher_sndbuf(sk));\n\n\t\terr = skcipher_alloc_sgl(sk);\n\t\tif (err)\n\t\t\tgoto unlock;\n\n\t\tsgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);\n\t\tsg = sgl->sg;\n\t\tdo {\n\t\t\ti = sgl->cur;\n\t\t\tplen = min_t(int, len, PAGE_SIZE);\n\n\t\t\tsg_assign_page(sg + i, alloc_page(GFP_KERNEL));\n\t\t\terr = -ENOMEM;\n\t\t\tif (!sg_page(sg + i))\n\t\t\t\tgoto unlock;\n\n\t\t\terr = memcpy_from_msg(page_address(sg_page(sg + i)),\n\t\t\t\t\t      msg, plen);\n\t\t\tif (err) {\n\t\t\t\t__free_page(sg_page(sg + i));\n\t\t\t\tsg_assign_page(sg + i, NULL);\n\t\t\t\tgoto unlock;\n\t\t\t}\n\n\t\t\tsg[i].length = plen;\n\t\t\tlen -= plen;\n\t\t\tctx->used += plen;\n\t\t\tcopied += plen;\n\t\t\tsize -= plen;\n\t\t\tsgl->cur++;\n\t\t} while (len && sgl->cur < MAX_SGL_ENTS);\n\n\t\tctx->merge = plen & (PAGE_SIZE - 1);\n\t}\n\n\terr = 0;\n\n\tctx->more = msg->msg_flags & MSG_MORE;\n\nunlock:\n\tskcipher_data_wakeup(sk);\n\trelease_sock(sk);\n\n\treturn copied ?: err;\n}\n\nstatic ssize_t skcipher_sendpage(struct socket *sock, struct page *page,\n\t\t\t\t int offset, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tstruct skcipher_sg_list *sgl;\n\tint err = -EINVAL;\n\n\tif (flags & MSG_SENDPAGE_NOTLAST)\n\t\tflags |= MSG_MORE;\n\n\tlock_sock(sk);\n\tif (!ctx->more && ctx->used)\n\t\tgoto unlock;\n\n\tif (!size)\n\t\tgoto done;\n\n\tif (!skcipher_writable(sk)) {\n\t\terr = skcipher_wait_for_wmem(sk, flags);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t}\n\n\terr = skcipher_alloc_sgl(sk);\n\tif (err)\n\t\tgoto unlock;\n\n\tctx->merge = 0;\n\tsgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);\n\n\tget_page(page);\n\tsg_set_page(sgl->sg + sgl->cur, page, size, offset);\n\tsgl->cur++;\n\tctx->used += size;\n\ndone:\n\tctx->more = flags & MSG_MORE;\n\nunlock:\n\tskcipher_data_wakeup(sk);\n\trelease_sock(sk);\n\n\treturn err ?: size;\n}\n\nstatic int skcipher_recvmsg(struct kiocb *unused, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t ignored, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tunsigned bs = crypto_ablkcipher_blocksize(crypto_ablkcipher_reqtfm(\n\t\t&ctx->req));\n\tstruct skcipher_sg_list *sgl;\n\tstruct scatterlist *sg;\n\tint err = -EAGAIN;\n\tint used;\n\tlong copied = 0;\n\n\tlock_sock(sk);\n\twhile (iov_iter_count(&msg->msg_iter)) {\n\t\tsgl = list_first_entry(&ctx->tsgl,\n\t\t\t\t       struct skcipher_sg_list, list);\n\t\tsg = sgl->sg;\n\n\t\twhile (!sg->length)\n\t\t\tsg++;\n\n\t\tif (!ctx->used) {\n\t\t\terr = skcipher_wait_for_data(sk, flags);\n\t\t\tif (err)\n\t\t\t\tgoto unlock;\n\t\t}\n\n\t\tused = min_t(unsigned long, ctx->used, iov_iter_count(&msg->msg_iter));\n\n\t\tused = af_alg_make_sg(&ctx->rsgl, &msg->msg_iter, used);\n\t\terr = used;\n\t\tif (err < 0)\n\t\t\tgoto unlock;\n\n\t\tif (ctx->more || used < ctx->used)\n\t\t\tused -= used % bs;\n\n\t\terr = -EINVAL;\n\t\tif (!used)\n\t\t\tgoto free;\n\n\t\tablkcipher_request_set_crypt(&ctx->req, sg,\n\t\t\t\t\t     ctx->rsgl.sg, used,\n\t\t\t\t\t     ctx->iv);\n\n\t\terr = af_alg_wait_for_completion(\n\t\t\t\tctx->enc ?\n\t\t\t\t\tcrypto_ablkcipher_encrypt(&ctx->req) :\n\t\t\t\t\tcrypto_ablkcipher_decrypt(&ctx->req),\n\t\t\t\t&ctx->completion);\n\nfree:\n\t\taf_alg_free_sg(&ctx->rsgl);\n\n\t\tif (err)\n\t\t\tgoto unlock;\n\n\t\tcopied += used;\n\t\tskcipher_pull_sgl(sk, used);\n\t\tiov_iter_advance(&msg->msg_iter, used);\n\t}\n\n\terr = 0;\n\nunlock:\n\tskcipher_wmem_wakeup(sk);\n\trelease_sock(sk);\n\n\treturn copied ?: err;\n}\n\n\nstatic unsigned int skcipher_poll(struct file *file, struct socket *sock,\n\t\t\t\t  poll_table *wait)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tunsigned int mask;\n\n\tsock_poll_wait(file, sk_sleep(sk), wait);\n\tmask = 0;\n\n\tif (ctx->used)\n\t\tmask |= POLLIN | POLLRDNORM;\n\n\tif (skcipher_writable(sk))\n\t\tmask |= POLLOUT | POLLWRNORM | POLLWRBAND;\n\n\treturn mask;\n}\n\nstatic struct proto_ops algif_skcipher_ops = {\n\t.family\t\t=\tPF_ALG,\n\n\t.connect\t=\tsock_no_connect,\n\t.socketpair\t=\tsock_no_socketpair,\n\t.getname\t=\tsock_no_getname,\n\t.ioctl\t\t=\tsock_no_ioctl,\n\t.listen\t\t=\tsock_no_listen,\n\t.shutdown\t=\tsock_no_shutdown,\n\t.getsockopt\t=\tsock_no_getsockopt,\n\t.mmap\t\t=\tsock_no_mmap,\n\t.bind\t\t=\tsock_no_bind,\n\t.accept\t\t=\tsock_no_accept,\n\t.setsockopt\t=\tsock_no_setsockopt,\n\n\t.release\t=\taf_alg_release,\n\t.sendmsg\t=\tskcipher_sendmsg,\n\t.sendpage\t=\tskcipher_sendpage,\n\t.recvmsg\t=\tskcipher_recvmsg,\n\t.poll\t\t=\tskcipher_poll,\n};\n\nstatic void *skcipher_bind(const char *name, u32 type, u32 mask)\n{\n\treturn crypto_alloc_ablkcipher(name, type, mask);\n}\n\nstatic void skcipher_release(void *private)\n{\n\tcrypto_free_ablkcipher(private);\n}\n\nstatic int skcipher_setkey(void *private, const u8 *key, unsigned int keylen)\n{\n\treturn crypto_ablkcipher_setkey(private, key, keylen);\n}\n\nstatic void skcipher_sock_destruct(struct sock *sk)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tstruct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(&ctx->req);\n\n\tskcipher_free_sgl(sk);\n\tsock_kzfree_s(sk, ctx->iv, crypto_ablkcipher_ivsize(tfm));\n\tsock_kfree_s(sk, ctx, ctx->len);\n\taf_alg_release_parent(sk);\n}\n\nstatic int skcipher_accept_parent(void *private, struct sock *sk)\n{\n\tstruct skcipher_ctx *ctx;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tunsigned int len = sizeof(*ctx) + crypto_ablkcipher_reqsize(private);\n\n\tctx = sock_kmalloc(sk, len, GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->iv = sock_kmalloc(sk, crypto_ablkcipher_ivsize(private),\n\t\t\t       GFP_KERNEL);\n\tif (!ctx->iv) {\n\t\tsock_kfree_s(sk, ctx, len);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(ctx->iv, 0, crypto_ablkcipher_ivsize(private));\n\n\tINIT_LIST_HEAD(&ctx->tsgl);\n\tctx->len = len;\n\tctx->used = 0;\n\tctx->more = 0;\n\tctx->merge = 0;\n\tctx->enc = 0;\n\taf_alg_init_completion(&ctx->completion);\n\n\task->private = ctx;\n\n\tablkcipher_request_set_tfm(&ctx->req, private);\n\tablkcipher_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t\taf_alg_complete, &ctx->completion);\n\n\tsk->sk_destruct = skcipher_sock_destruct;\n\n\treturn 0;\n}\n\nstatic const struct af_alg_type algif_type_skcipher = {\n\t.bind\t\t=\tskcipher_bind,\n\t.release\t=\tskcipher_release,\n\t.setkey\t\t=\tskcipher_setkey,\n\t.accept\t\t=\tskcipher_accept_parent,\n\t.ops\t\t=\t&algif_skcipher_ops,\n\t.name\t\t=\t\"skcipher\",\n\t.owner\t\t=\tTHIS_MODULE\n};\n\nstatic int __init algif_skcipher_init(void)\n{\n\treturn af_alg_register_type(&algif_type_skcipher);\n}\n\nstatic void __exit algif_skcipher_exit(void)\n{\n\tint err = af_alg_unregister_type(&algif_type_skcipher);\n\tBUG_ON(err);\n}\n\nmodule_init(algif_skcipher_init);\nmodule_exit(algif_skcipher_exit);\nMODULE_LICENSE(\"GPL\");\n"], "filenames": ["crypto/af_alg.c", "crypto/algif_skcipher.c"], "buggy_code_start_loc": [351, 442], "buggy_code_end_loc": [352, 450], "fixing_code_start_loc": [351, 442], "fixing_code_end_loc": [352, 449], "type": "CWE-362", "message": "A flaw was found in the subsequent get_user_pages_fast in the Linux kernel\u2019s interface for symmetric key cipher algorithms in the skcipher_recvmsg of crypto/algif_skcipher.c function. This flaw allows a local user to crash the system.", "other": {"cve": {"id": "CVE-2023-3108", "sourceIdentifier": "secalert@redhat.com", "published": "2023-07-11T16:15:12.083", "lastModified": "2023-07-20T01:56:37.593", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A flaw was found in the subsequent get_user_pages_fast in the Linux kernel\u2019s interface for symmetric key cipher algorithms in the skcipher_recvmsg of crypto/algif_skcipher.c function. This flaw allows a local user to crash the system."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 4.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.0, "impactScore": 3.6}, {"source": "secalert@redhat.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.2, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.5, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.0", "matchCriteriaId": "DC9EC537-FFAB-44B8-BED0-01722C0D9A01"}]}]}], "references": [{"url": "https://access.redhat.com/security/cve/CVE-2023-3108", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2221472", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/9399f0c51489ae8c16d6559b82a452fdc1895e91", "source": "secalert@redhat.com", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/9399f0c51489ae8c16d6559b82a452fdc1895e91"}}