{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\t\t\t\tGUI/Motif support by Robert Webb\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n/*\n * Code for the Motif GUI.\n * Not used for GTK.\n */\n\n#include \"vim.h\"\n\n#include <X11/keysym.h>\n#include <X11/Xatom.h>\n#include <X11/StringDefs.h>\n#include <X11/Intrinsic.h>\n#include <X11/Shell.h>\n#include <X11/cursorfont.h>\n\n/*\n * XpmP.h is preferred, because it makes the signs drawn with a transparent\n * background instead of black.\n */\n#if defined(HAVE_XM_XPMP_H) && defined(FEAT_GUI_MOTIF) \\\n\t&& !defined(HAVE_X11_XPM_H)\n# include <Xm/XpmP.h>\n#else\n# ifdef HAVE_X11_XPM_H\n#  ifdef VMS\n#   include <xpm.h>\n#  else\n#   include <X11/xpm.h>\n#  endif\n# endif\n#endif\n\n#ifdef FEAT_XFONTSET\n# ifdef X_LOCALE\n#  include <X11/Xlocale.h>\n# else\n#  include <locale.h>\n# endif\n#endif\n\n#ifdef HAVE_X11_SUNKEYSYM_H\n# include <X11/Sunkeysym.h>\n#endif\n\n#ifdef HAVE_X11_XMU_EDITRES_H\n# include <X11/Xmu/Editres.h>\n#endif\n\n#define VIM_NAME\t\"vim\"\n#define VIM_CLASS\t\"Vim\"\n\n// Default resource values\n#define DFLT_FONT\t\t\"7x13\"\n#ifdef FONTSET_ALWAYS\n# define DFLT_MENU_FONT\t\tXtDefaultFontSet\n#else\n# define DFLT_MENU_FONT\t\tXtDefaultFont\n#endif\n#define DFLT_TOOLTIP_FONT\tXtDefaultFontSet\n\n// use the default (CDE) colors\n#define DFLT_MENU_BG_COLOR\t\"\"\n#define DFLT_MENU_FG_COLOR\t\"\"\n#define DFLT_SCROLL_BG_COLOR\t\"\"\n#define DFLT_SCROLL_FG_COLOR\t\"\"\n#define DFLT_TOOLTIP_BG_COLOR\t\"#ffff91\"\n#define DFLT_TOOLTIP_FG_COLOR\t\"#000000\"\n\nWidget vimShell = (Widget)0;\n\nstatic Atom   wm_atoms[2];\t// Window Manager Atoms\n#define DELETE_WINDOW_IDX 0\t// index in wm_atoms[] for WM_DELETE_WINDOW\n#define SAVE_YOURSELF_IDX 1\t// index in wm_atoms[] for WM_SAVE_YOURSELF\n\n#ifdef FEAT_XFONTSET\n/*\n * We either draw with a fontset (when current_fontset != NULL) or with a\n * normal font (current_fontset == NULL, use gui.text_gc and gui.back_gc).\n */\nstatic XFontSet current_fontset = NULL;\n# if !defined(XDrawString)\n#  define XDrawString(dpy, win, gc, x, y, str, n) \\\n\tdo \\\n\t{ \\\n\t    if (current_fontset != NULL) \\\n\t\tXmbDrawString(dpy, win, current_fontset, gc, x, y, str, n); \\\n\t    else \\\n\t\tXDrawString(dpy, win, gc, x, y, str, n); \\\n\t} while (0)\n# endif\n# if !defined(XDrawString16)\n#  define XDrawString16(dpy, win, gc, x, y, str, n) \\\n\tdo \\\n\t{ \\\n\t    if (current_fontset != NULL) \\\n\t\tXwcDrawString(dpy, win, current_fontset, gc, x, y, (wchar_t *)str, n); \\\n\t    else \\\n\t\tXDrawString16(dpy, win, gc, x, y, (XChar2b *)str, n); \\\n\t} while (0)\n# endif\n# if !defined(XDrawImageString16)\n#  define XDrawImageString16(dpy, win, gc, x, y, str, n) \\\n\tdo \\\n\t{ \\\n\t    if (current_fontset != NULL) \\\n\t\tXwcDrawImageString(dpy, win, current_fontset, gc, x, y, (wchar_t *)str, n); \\\n\t    else \\\n\t\tXDrawImageString16(dpy, win, gc, x, y, (XChar2b *)str, n); \\\n\t} while (0)\n# endif\nstatic int check_fontset_sanity(XFontSet fs);\nstatic int fontset_width(XFontSet fs);\nstatic int fontset_ascent(XFontSet fs);\n#endif\n\nstatic guicolor_T\tprev_fg_color = INVALCOLOR;\nstatic guicolor_T\tprev_bg_color = INVALCOLOR;\nstatic guicolor_T\tprev_sp_color = INVALCOLOR;\n\n#if defined(FEAT_GUI_MOTIF) && defined(FEAT_MENU)\nstatic XButtonPressedEvent last_mouse_event;\n#endif\n\nstatic void gui_x11_check_copy_area(void);\n#ifdef FEAT_CLIENTSERVER\nstatic void gui_x11_send_event_handler(Widget, XtPointer, XEvent *, Boolean *);\n#endif\nstatic void gui_x11_wm_protocol_handler(Widget, XtPointer, XEvent *, Boolean *);\nstatic Cursor gui_x11_create_blank_mouse(void);\n\n\n/*\n * Keycodes recognized by vim.\n * NOTE: when changing this, the table in gui_gtk_x11.c probably needs the\n * same change!\n */\nstatic struct specialkey\n{\n    KeySym  key_sym;\n    char_u  vim_code0;\n    char_u  vim_code1;\n} special_keys[] =\n{\n    {XK_Up,\t\t'k', 'u'},\n    {XK_Down,\t\t'k', 'd'},\n    {XK_Left,\t\t'k', 'l'},\n    {XK_Right,\t\t'k', 'r'},\n\n    {XK_F1,\t\t'k', '1'},\n    {XK_F2,\t\t'k', '2'},\n    {XK_F3,\t\t'k', '3'},\n    {XK_F4,\t\t'k', '4'},\n    {XK_F5,\t\t'k', '5'},\n    {XK_F6,\t\t'k', '6'},\n    {XK_F7,\t\t'k', '7'},\n    {XK_F8,\t\t'k', '8'},\n    {XK_F9,\t\t'k', '9'},\n    {XK_F10,\t\t'k', ';'},\n\n    {XK_F11,\t\t'F', '1'},\n    {XK_F12,\t\t'F', '2'},\n    {XK_F13,\t\t'F', '3'},\n    {XK_F14,\t\t'F', '4'},\n    {XK_F15,\t\t'F', '5'},\n    {XK_F16,\t\t'F', '6'},\n    {XK_F17,\t\t'F', '7'},\n    {XK_F18,\t\t'F', '8'},\n    {XK_F19,\t\t'F', '9'},\n    {XK_F20,\t\t'F', 'A'},\n\n    {XK_F21,\t\t'F', 'B'},\n    {XK_F22,\t\t'F', 'C'},\n    {XK_F23,\t\t'F', 'D'},\n    {XK_F24,\t\t'F', 'E'},\n    {XK_F25,\t\t'F', 'F'},\n    {XK_F26,\t\t'F', 'G'},\n    {XK_F27,\t\t'F', 'H'},\n    {XK_F28,\t\t'F', 'I'},\n    {XK_F29,\t\t'F', 'J'},\n    {XK_F30,\t\t'F', 'K'},\n\n    {XK_F31,\t\t'F', 'L'},\n    {XK_F32,\t\t'F', 'M'},\n    {XK_F33,\t\t'F', 'N'},\n    {XK_F34,\t\t'F', 'O'},\n    {XK_F35,\t\t'F', 'P'},\t// keysymdef.h defines up to F35\n#ifdef SunXK_F36\n    {SunXK_F36,\t\t'F', 'Q'},\n    {SunXK_F37,\t\t'F', 'R'},\n#endif\n\n    {XK_Help,\t\t'%', '1'},\n    {XK_Undo,\t\t'&', '8'},\n    {XK_BackSpace,\t'k', 'b'},\n    {XK_Insert,\t\t'k', 'I'},\n    {XK_Delete,\t\t'k', 'D'},\n    {XK_Home,\t\t'k', 'h'},\n    {XK_End,\t\t'@', '7'},\n    {XK_Prior,\t\t'k', 'P'},\n    {XK_Next,\t\t'k', 'N'},\n    {XK_Print,\t\t'%', '9'},\n\n    // Keypad keys:\n#ifdef XK_KP_Left\n    {XK_KP_Left,\t'k', 'l'},\n    {XK_KP_Right,\t'k', 'r'},\n    {XK_KP_Up,\t\t'k', 'u'},\n    {XK_KP_Down,\t'k', 'd'},\n    {XK_KP_Insert,\tKS_EXTRA, (char_u)KE_KINS},\n    {XK_KP_Delete,\tKS_EXTRA, (char_u)KE_KDEL},\n    {XK_KP_Home,\t'K', '1'},\n    {XK_KP_End,\t\t'K', '4'},\n    {XK_KP_Prior,\t'K', '3'},\n    {XK_KP_Next,\t'K', '5'},\n\n    {XK_KP_Add,\t\t'K', '6'},\n    {XK_KP_Subtract,\t'K', '7'},\n    {XK_KP_Divide,\t'K', '8'},\n    {XK_KP_Multiply,\t'K', '9'},\n    {XK_KP_Enter,\t'K', 'A'},\n    {XK_KP_Decimal,\t'K', 'B'},\n\n    {XK_KP_0,\t\t'K', 'C'},\n    {XK_KP_1,\t\t'K', 'D'},\n    {XK_KP_2,\t\t'K', 'E'},\n    {XK_KP_3,\t\t'K', 'F'},\n    {XK_KP_4,\t\t'K', 'G'},\n    {XK_KP_5,\t\t'K', 'H'},\n    {XK_KP_6,\t\t'K', 'I'},\n    {XK_KP_7,\t\t'K', 'J'},\n    {XK_KP_8,\t\t'K', 'K'},\n    {XK_KP_9,\t\t'K', 'L'},\n#endif\n\n    // End of list marker:\n    {(KeySym)0,\t    0, 0}\n};\n\n#define XtNboldFont\t\t\"boldFont\"\n#define XtCBoldFont\t\t\"BoldFont\"\n#define XtNitalicFont\t\t\"italicFont\"\n#define XtCItalicFont\t\t\"ItalicFont\"\n#define XtNboldItalicFont\t\"boldItalicFont\"\n#define XtCBoldItalicFont\t\"BoldItalicFont\"\n#define XtNscrollbarWidth\t\"scrollbarWidth\"\n#define XtCScrollbarWidth\t\"ScrollbarWidth\"\n#define XtNmenuHeight\t\t\"menuHeight\"\n#define XtCMenuHeight\t\t\"MenuHeight\"\n#define XtNmenuFont\t\t\"menuFont\"\n#define XtCMenuFont\t\t\"MenuFont\"\n#define XtNmenuFontSet\t\t\"menuFontSet\"\n#define XtCMenuFontSet\t\t\"MenuFontSet\"\n\n\n// Resources for setting the foreground and background colors of menus\n#define XtNmenuBackground\t\"menuBackground\"\n#define XtCMenuBackground\t\"MenuBackground\"\n#define XtNmenuForeground\t\"menuForeground\"\n#define XtCMenuForeground\t\"MenuForeground\"\n\n// Resources for setting the foreground and background colors of scrollbars\n#define XtNscrollBackground\t\"scrollBackground\"\n#define XtCScrollBackground\t\"ScrollBackground\"\n#define XtNscrollForeground\t\"scrollForeground\"\n#define XtCScrollForeground\t\"ScrollForeground\"\n\n// Resources for setting the foreground and background colors of tooltip\n#define XtNtooltipBackground\t\"tooltipBackground\"\n#define XtCTooltipBackground\t\"TooltipBackground\"\n#define XtNtooltipForeground\t\"tooltipForeground\"\n#define XtCTooltipForeground\t\"TooltipForeground\"\n#define XtNtooltipFont\t\t\"tooltipFont\"\n#define XtCTooltipFont\t\t\"TooltipFont\"\n\n/*\n * X Resources:\n */\nstatic XtResource vim_resources[] =\n{\n    {\n\tXtNforeground,\n\tXtCForeground,\n\tXtRPixel,\n\tsizeof(Pixel),\n\tXtOffsetOf(gui_T, def_norm_pixel),\n\tXtRString,\n\tXtDefaultForeground\n    },\n    {\n\tXtNbackground,\n\tXtCBackground,\n\tXtRPixel,\n\tsizeof(Pixel),\n\tXtOffsetOf(gui_T, def_back_pixel),\n\tXtRString,\n\tXtDefaultBackground\n    },\n    {\n\tXtNfont,\n\tXtCFont,\n\tXtRString,\n\tsizeof(String *),\n\tXtOffsetOf(gui_T, rsrc_font_name),\n\tXtRImmediate,\n\tXtDefaultFont\n    },\n    {\n\tXtNboldFont,\n\tXtCBoldFont,\n\tXtRString,\n\tsizeof(String *),\n\tXtOffsetOf(gui_T, rsrc_bold_font_name),\n\tXtRImmediate,\n\t\"\"\n    },\n    {\n\tXtNitalicFont,\n\tXtCItalicFont,\n\tXtRString,\n\tsizeof(String *),\n\tXtOffsetOf(gui_T, rsrc_ital_font_name),\n\tXtRImmediate,\n\t\"\"\n    },\n    {\n\tXtNboldItalicFont,\n\tXtCBoldItalicFont,\n\tXtRString,\n\tsizeof(String *),\n\tXtOffsetOf(gui_T, rsrc_boldital_font_name),\n\tXtRImmediate,\n\t\"\"\n    },\n    {\n\tXtNgeometry,\n\tXtCGeometry,\n\tXtRString,\n\tsizeof(String *),\n\tXtOffsetOf(gui_T, geom),\n\tXtRImmediate,\n\t\"\"\n    },\n    {\n\tXtNreverseVideo,\n\tXtCReverseVideo,\n\tXtRBool,\n\tsizeof(Bool),\n\tXtOffsetOf(gui_T, rsrc_rev_video),\n\tXtRImmediate,\n\t(XtPointer)False\n    },\n    {\n\tXtNborderWidth,\n\tXtCBorderWidth,\n\tXtRInt,\n\tsizeof(int),\n\tXtOffsetOf(gui_T, border_width),\n\tXtRImmediate,\n\t(XtPointer)2\n    },\n    {\n\tXtNscrollbarWidth,\n\tXtCScrollbarWidth,\n\tXtRInt,\n\tsizeof(int),\n\tXtOffsetOf(gui_T, scrollbar_width),\n\tXtRImmediate,\n\t(XtPointer)SB_DEFAULT_WIDTH\n    },\n#ifdef FEAT_MENU\n    {\n# ifdef FONTSET_ALWAYS\n\tXtNmenuFontSet,\n\tXtCMenuFontSet,\n#else\n\tXtNmenuFont,\n\tXtCMenuFont,\n#endif\n\tXtRString,\n\tsizeof(char *),\n\tXtOffsetOf(gui_T, rsrc_menu_font_name),\n\tXtRString,\n\tDFLT_MENU_FONT\n    },\n#endif\n    {\n\tXtNmenuForeground,\n\tXtCMenuForeground,\n\tXtRString,\n\tsizeof(char *),\n\tXtOffsetOf(gui_T, rsrc_menu_fg_name),\n\tXtRString,\n\tDFLT_MENU_FG_COLOR\n    },\n    {\n\tXtNmenuBackground,\n\tXtCMenuBackground,\n\tXtRString,\n\tsizeof(char *),\n\tXtOffsetOf(gui_T, rsrc_menu_bg_name),\n\tXtRString,\n\tDFLT_MENU_BG_COLOR\n    },\n    {\n\tXtNscrollForeground,\n\tXtCScrollForeground,\n\tXtRString,\n\tsizeof(char *),\n\tXtOffsetOf(gui_T, rsrc_scroll_fg_name),\n\tXtRString,\n\tDFLT_SCROLL_FG_COLOR\n    },\n    {\n\tXtNscrollBackground,\n\tXtCScrollBackground,\n\tXtRString,\n\tsizeof(char *),\n\tXtOffsetOf(gui_T, rsrc_scroll_bg_name),\n\tXtRString,\n\tDFLT_SCROLL_BG_COLOR\n    },\n#ifdef FEAT_BEVAL_GUI\n    {\n\tXtNtooltipForeground,\n\tXtCTooltipForeground,\n\tXtRString,\n\tsizeof(char *),\n\tXtOffsetOf(gui_T, rsrc_tooltip_fg_name),\n\tXtRString,\n\tDFLT_TOOLTIP_FG_COLOR\n    },\n    {\n\tXtNtooltipBackground,\n\tXtCTooltipBackground,\n\tXtRString,\n\tsizeof(char *),\n\tXtOffsetOf(gui_T, rsrc_tooltip_bg_name),\n\tXtRString,\n\tDFLT_TOOLTIP_BG_COLOR\n    },\n    {\n\tXtNtooltipFont,\n\tXtCTooltipFont,\n\tXtRString,\n\tsizeof(char *),\n\tXtOffsetOf(gui_T, rsrc_tooltip_font_name),\n\tXtRString,\n\tDFLT_TOOLTIP_FONT\n    },\n    // This one may not be really needed?\n    {\n\t\"balloonEvalFontSet\",\n\tXtCFontSet,\n\tXtRFontSet,\n\tsizeof(XFontSet),\n\tXtOffsetOf(gui_T, tooltip_fontset),\n\tXtRImmediate,\n\t(XtPointer)NOFONTSET\n    },\n#endif // FEAT_BEVAL_GUI\n#ifdef FEAT_XIM\n    {\n\t\"preeditType\",\n\t\"PreeditType\",\n\tXtRString,\n\tsizeof(char*),\n\tXtOffsetOf(gui_T, rsrc_preedit_type_name),\n\tXtRString,\n\t(XtPointer)\"OverTheSpot,OffTheSpot,Root\"\n    },\n    {\n\t\"inputMethod\",\n\t\"InputMethod\",\n\tXtRString,\n\tsizeof(char*),\n\tXtOffsetOf(gui_T, rsrc_input_method),\n\tXtRString,\n\tNULL\n    },\n#endif // FEAT_XIM\n};\n\n/*\n * This table holds all the X GUI command line options allowed.  This includes\n * the standard ones so that we can skip them when vim is started without the\n * GUI (but the GUI might start up later).\n * When changing this, also update doc/vim_gui.txt and the usage message!!!\n */\nstatic XrmOptionDescRec cmdline_options[] =\n{\n    // We handle these options ourselves\n    {\"-bg\",\t\t\".background\",\t    XrmoptionSepArg,\tNULL},\n    {\"-background\",\t\".background\",\t    XrmoptionSepArg,\tNULL},\n    {\"-fg\",\t\t\".foreground\",\t    XrmoptionSepArg,\tNULL},\n    {\"-foreground\",\t\".foreground\",\t    XrmoptionSepArg,\tNULL},\n    {\"-fn\",\t\t\".font\",\t    XrmoptionSepArg,\tNULL},\n    {\"-font\",\t\t\".font\",\t    XrmoptionSepArg,\tNULL},\n    {\"-boldfont\",\t\".boldFont\",\t    XrmoptionSepArg,\tNULL},\n    {\"-italicfont\",\t\".italicFont\",\t    XrmoptionSepArg,\tNULL},\n    {\"-geom\",\t\t\".geometry\",\t    XrmoptionSepArg,\tNULL},\n    {\"-geometry\",\t\".geometry\",\t    XrmoptionSepArg,\tNULL},\n    {\"-reverse\",\t\"*reverseVideo\",    XrmoptionNoArg,\t\"True\"},\n    {\"-rv\",\t\t\"*reverseVideo\",    XrmoptionNoArg,\t\"True\"},\n    {\"+reverse\",\t\"*reverseVideo\",    XrmoptionNoArg,\t\"False\"},\n    {\"+rv\",\t\t\"*reverseVideo\",    XrmoptionNoArg,\t\"False\"},\n    {\"-display\",\t\".display\",\t    XrmoptionSepArg,\tNULL},\n    {\"-iconic\",\t\t\".iconic\",\t    XrmoptionNoArg,\t\"True\"},\n    {\"-name\",\t\t\".name\",\t    XrmoptionSepArg,\tNULL},\n    {\"-bw\",\t\t\".borderWidth\",\t    XrmoptionSepArg,\tNULL},\n    {\"-borderwidth\",\t\".borderWidth\",\t    XrmoptionSepArg,\tNULL},\n    {\"-sw\",\t\t\".scrollbarWidth\",  XrmoptionSepArg,\tNULL},\n    {\"-scrollbarwidth\",\t\".scrollbarWidth\",  XrmoptionSepArg,\tNULL},\n    {\"-mh\",\t\t\".menuHeight\",\t    XrmoptionSepArg,\tNULL},\n    {\"-menuheight\",\t\".menuHeight\",\t    XrmoptionSepArg,\tNULL},\n#ifdef FONTSET_ALWAYS\n    {\"-mf\",\t\t\".menuFontSet\",\t    XrmoptionSepArg,\tNULL},\n    {\"-menufont\",\t\".menuFontSet\",\t    XrmoptionSepArg,\tNULL},\n    {\"-menufontset\",\t\".menuFontSet\",\t    XrmoptionSepArg,\tNULL},\n#else\n    {\"-mf\",\t\t\".menuFont\",\t    XrmoptionSepArg,\tNULL},\n    {\"-menufont\",\t\".menuFont\",\t    XrmoptionSepArg,\tNULL},\n#endif\n    {\"-xrm\",\t\tNULL,\t\t    XrmoptionResArg,\tNULL}\n};\n\nstatic int gui_argc = 0;\nstatic char **gui_argv = NULL;\n\n/*\n * Call-back routines.\n */\n\n    static void\ngui_x11_timer_cb(\n    XtPointer\t    timed_out,\n    XtIntervalId    *interval_id UNUSED)\n{\n    *((int *)timed_out) = TRUE;\n}\n\n#ifdef FEAT_JOB_CHANNEL\n    static void\nchannel_poll_cb(\n    XtPointer\t    client_data,\n    XtIntervalId    *interval_id UNUSED)\n{\n    XtIntervalId    *channel_timer = (XtIntervalId *)client_data;\n\n    // Using an event handler for a channel that may be disconnected does\n    // not work, it hangs.  Instead poll for messages.\n    channel_handle_events(TRUE);\n    parse_queued_messages();\n\n    // repeat\n    *channel_timer = XtAppAddTimeOut(app_context, (long_u)20,\n\t\t\t\t\t\t channel_poll_cb, client_data);\n}\n#endif\n\n    static void\ngui_x11_visibility_cb(\n    Widget\tw UNUSED,\n    XtPointer\tdud UNUSED,\n    XEvent\t*event,\n    Boolean\t*dum UNUSED)\n{\n    if (event->type != VisibilityNotify)\n\treturn;\n\n    gui.visibility = event->xvisibility.state;\n\n    /*\n     * When we do an XCopyArea(), and the window is partially obscured, we want\n     * to receive an event to tell us whether it worked or not.\n     */\n    XSetGraphicsExposures(gui.dpy, gui.text_gc,\n\t    gui.visibility != VisibilityUnobscured);\n\n    // This is needed for when redrawing is slow.\n    gui_mch_update();\n}\n\n    static void\ngui_x11_expose_cb(\n    Widget\tw UNUSED,\n    XtPointer\tdud UNUSED,\n    XEvent\t*event,\n    Boolean\t*dum UNUSED)\n{\n    XExposeEvent\t*gevent;\n    int\t\t\tnew_x;\n\n    if (event->type != Expose)\n\treturn;\n\n    out_flush();\t    // make sure all output has been processed\n\n    gevent = (XExposeEvent *)event;\n    gui_redraw(gevent->x, gevent->y, gevent->width, gevent->height);\n\n    new_x = FILL_X(0);\n\n    // Clear the border areas if needed\n    if (gevent->x < new_x)\n\tXClearArea(gui.dpy, gui.wid, 0, 0, new_x, 0, False);\n    if (gevent->y < FILL_Y(0))\n\tXClearArea(gui.dpy, gui.wid, 0, 0, 0, FILL_Y(0), False);\n    if (gevent->x > FILL_X(Columns))\n\tXClearArea(gui.dpy, gui.wid, FILL_X((int)Columns), 0, 0, 0, False);\n    if (gevent->y > FILL_Y(Rows))\n\tXClearArea(gui.dpy, gui.wid, 0, FILL_Y((int)Rows), 0, 0, False);\n\n    // This is needed for when redrawing is slow.\n    gui_mch_update();\n}\n\n#if (defined(FEAT_NETBEANS_INTG) && defined(FEAT_GUI_MOTIF)) || defined(PROTO)\n/*\n * This function fills in the XRectangle object with the current x,y\n * coordinates and height, width so that an XtVaSetValues to the same shell of\n * those resources will restore the window to its former position and\n * dimensions.\n *\n * Note: This function may fail, in which case the XRectangle will be\n * unchanged.  Be sure to have the XRectangle set with the proper values for a\n * failed condition prior to calling this function.\n */\n    static void\nshellRectangle(Widget shell, XRectangle *r)\n{\n    Window\t\trootw, shellw, child, parentw;\n    int\t\t\tabsx, absy;\n    XWindowAttributes\ta;\n    Window\t\t*children;\n    unsigned int\tchildrenCount;\n\n    shellw = XtWindow(shell);\n    if (shellw == 0)\n\treturn;\n    for (;;)\n    {\n\tXQueryTree(XtDisplay(shell), shellw, &rootw, &parentw,\n\t\t\t\t\t\t   &children, &childrenCount);\n\tXFree(children);\n\tif (parentw == rootw)\n\t    break;\n\tshellw = parentw;\n    }\n    XGetWindowAttributes(XtDisplay(shell), shellw, &a);\n    XTranslateCoordinates(XtDisplay(shell), shellw, a.root, 0, 0,\n\t\t\t\t\t\t\t&absx, &absy, &child);\n    r->x = absx;\n    r->y = absy;\n    XtVaGetValues(shell, XmNheight, &r->height, XmNwidth, &r->width, NULL);\n}\n#endif\n\n    static void\ngui_x11_resize_window_cb(\n    Widget\tw UNUSED,\n    XtPointer\tdud UNUSED,\n    XEvent\t*event,\n    Boolean\t*dum UNUSED)\n{\n    static int lastWidth, lastHeight;\n\n    if (event->type != ConfigureNotify)\n\treturn;\n\n    if (event->xconfigure.width != lastWidth\n\t    || event->xconfigure.height != lastHeight)\n    {\n\tlastWidth = event->xconfigure.width;\n\tlastHeight = event->xconfigure.height;\n\tgui_resize_shell(event->xconfigure.width, event->xconfigure.height\n#ifdef FEAT_XIM\n\t\t\t\t\t\t- xim_get_status_area_height()\n#endif\n\t\t     );\n    }\n#if defined(FEAT_NETBEANS_INTG) && defined(FEAT_GUI_MOTIF)\n    if (netbeans_active())\n    {\n\tXRectangle  rec;\n\n\tshellRectangle(w, &rec);\n\tnetbeans_frame_moved(rec.x, rec.y);\n    }\n#endif\n#ifdef FEAT_XIM\n    xim_set_preedit();\n#endif\n}\n\n    static void\ngui_x11_focus_change_cb(\n    Widget\tw UNUSED,\n    XtPointer\tdata UNUSED,\n    XEvent\t*event,\n    Boolean\t*dum UNUSED)\n{\n    gui_focus_change(event->type == FocusIn);\n}\n\n    static void\ngui_x11_enter_cb(\n    Widget\tw UNUSED,\n    XtPointer\tdata UNUSED,\n    XEvent\t*event UNUSED,\n    Boolean\t*dum UNUSED)\n{\n    gui_focus_change(TRUE);\n}\n\n    static void\ngui_x11_leave_cb(\n    Widget\tw UNUSED,\n    XtPointer\tdata UNUSED,\n    XEvent\t*event UNUSED,\n    Boolean\t*dum UNUSED)\n{\n    gui_focus_change(FALSE);\n}\n\n#if defined(X_HAVE_UTF8_STRING)\n# if X_HAVE_UTF8_STRING\n#  define USE_UTF8LOOKUP\n# endif\n#endif\n\n    void\ngui_x11_key_hit_cb(\n    Widget\tw UNUSED,\n    XtPointer\tdud UNUSED,\n    XEvent\t*event,\n    Boolean\t*dum UNUSED)\n{\n    XKeyPressedEvent\t*ev_press;\n#ifdef FEAT_XIM\n    char_u\t\tstring2[256];\n    char_u\t\tstring_shortbuf[256];\n    char_u\t\t*string = string_shortbuf;\n    Boolean\t\tstring_alloced = False;\n    Status\t\tstatus;\n#else\n    char_u\t\tstring[4], string2[3];\n#endif\n    KeySym\t\tkey_sym;\n    int\t\t\tlen;\n    int\t\t\ti;\n    int\t\t\tmodifiers;\n    int\t\t\tkey;\n\n    ev_press = (XKeyPressedEvent *)event;\n\n#ifdef FEAT_XIM\n    if (xic)\n    {\n# ifdef USE_UTF8LOOKUP\n\t// XFree86 4.0.2 or newer: Be able to get UTF-8 characters even when\n\t// the locale isn't utf-8.\n\tif (enc_utf8)\n\t    len = Xutf8LookupString(xic, ev_press, (char *)string,\n\t\t\t\t  sizeof(string_shortbuf), &key_sym, &status);\n\telse\n# endif\n\t    len = XmbLookupString(xic, ev_press, (char *)string,\n\t\t\t\t  sizeof(string_shortbuf), &key_sym, &status);\n\tif (status == XBufferOverflow)\n\t{\n\t    string = (char_u *)XtMalloc(len + 1);\n\t    string_alloced = True;\n# ifdef USE_UTF8LOOKUP\n\t    // XFree86 4.0.2 or newer: Be able to get UTF-8 characters even\n\t    // when the locale isn't utf-8.\n\t    if (enc_utf8)\n\t\tlen = Xutf8LookupString(xic, ev_press, (char *)string,\n\t\t\t\t\t\t      len, &key_sym, &status);\n\t    else\n# endif\n\t\tlen = XmbLookupString(xic, ev_press, (char *)string,\n\t\t\t\t\t\t      len, &key_sym, &status);\n\t}\n\tif (status == XLookupNone || status == XLookupChars)\n\t    key_sym = XK_VoidSymbol;\n\n\t// Do conversion from 'termencoding' to 'encoding'.  When using\n\t// Xutf8LookupString() it has already been done.\n\tif (len > 0 && input_conv.vc_type != CONV_NONE\n# ifdef USE_UTF8LOOKUP\n\t\t&& !enc_utf8\n# endif\n\t\t)\n\t{\n\t    int\t\tmaxlen = len * 4 + 40;\t// guessed\n\t    char_u\t*p = (char_u *)XtMalloc(maxlen);\n\n\t    mch_memmove(p, string, len);\n\t    if (string_alloced)\n\t\tXtFree((char *)string);\n\t    string = p;\n\t    string_alloced = True;\n\t    len = convert_input(p, len, maxlen);\n\t}\n\n\t// Translate CSI to K_CSI, otherwise it could be recognized as the\n\t// start of a special key.\n\tfor (i = 0; i < len; ++i)\n\t    if (string[i] == CSI)\n\t    {\n\t\tchar_u\t*p = (char_u *)XtMalloc(len + 3);\n\n\t\tmch_memmove(p, string, i + 1);\n\t\tp[i + 1] = KS_EXTRA;\n\t\tp[i + 2] = (int)KE_CSI;\n\t\tmch_memmove(p + i + 3, string + i + 1, len - i);\n\t\tif (string_alloced)\n\t\t    XtFree((char *)string);\n\t\tstring = p;\n\t\tstring_alloced = True;\n\t\ti += 2;\n\t\tlen += 2;\n\t    }\n    }\n    else\n#endif\n\tlen = XLookupString(ev_press, (char *)string, sizeof(string),\n\t\t&key_sym, NULL);\n\n#ifdef SunXK_F36\n    /*\n    * These keys have bogus lookup strings, and trapping them here is\n    * easier than trying to XRebindKeysym() on them with every possible\n    * combination of modifiers.\n    */\n    if (key_sym == SunXK_F36 || key_sym == SunXK_F37)\n\tlen = 0;\n#endif\n\n    if (key_sym == XK_space)\n\tstring[0] = ' ';\t// Otherwise Ctrl-Space doesn't work\n\n    /*\n     * Only on some machines ^_ requires Ctrl+Shift+minus.  For consistency,\n     * allow just Ctrl+minus too.\n     */\n    if (key_sym == XK_minus && (ev_press->state & ControlMask))\n\tstring[0] = Ctrl__;\n\n#ifdef XK_ISO_Left_Tab\n    // why do we get XK_ISO_Left_Tab instead of XK_Tab for shift-tab?\n    if (key_sym == XK_ISO_Left_Tab)\n    {\n\tkey_sym = XK_Tab;\n\tstring[0] = TAB;\n\tlen = 1;\n    }\n#endif\n\n    // We used to apply Alt/Meta to the key here (Mod1Mask), but that is now\n    // done later, the same as it happens for the terminal.  Hopefully that\n    // works for everybody...\n\n    if (len == 1 && string[0] == CSI)\n    {\n\tstring[1] = KS_EXTRA;\n\tstring[2] = (int)KE_CSI;\n\tlen = -3;\n    }\n\n    // Check for special keys.  Also do this when len == 1 (key has an ASCII\n    // value) to detect backspace, delete and keypad keys.\n    if (len == 0 || len == 1)\n    {\n\tfor (i = 0; special_keys[i].key_sym != (KeySym)0; i++)\n\t{\n\t    if (special_keys[i].key_sym == key_sym)\n\t    {\n\t\tstring[0] = CSI;\n\t\tstring[1] = special_keys[i].vim_code0;\n\t\tstring[2] = special_keys[i].vim_code1;\n\t\tlen = -3;\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    // Unrecognised key is ignored.\n    if (len == 0)\n\tgoto theend;\n\n    // Handle modifiers.\n    modifiers = 0;\n    if (ev_press->state & ShiftMask)\n\tmodifiers |= MOD_MASK_SHIFT;\n    if (ev_press->state & ControlMask)\n    {\n\tmodifiers |= MOD_MASK_CTRL;\n\tif (len == 1 && string[0] < 0x20)\n\t    // Use the character before applyng CTRL.\n\t    string[0] += 0x40;\n    }\n    if (ev_press->state & Mod1Mask)\n\tmodifiers |= MOD_MASK_ALT;\n    if (ev_press->state & Mod4Mask)\n\tmodifiers |= MOD_MASK_META;\n\n    /*\n     * For some keys a shift modifier is translated into another key\n     * code.\n     */\n    if (len == -3)\n\tkey = TO_SPECIAL(string[1], string[2]);\n    else\n    {\n\tstring[len] = NUL;\n\tkey = mb_ptr2char(string);\n    }\n    key = simplify_key(key, &modifiers);\n    if (key == CSI)\n\tkey = K_CSI;\n    if (IS_SPECIAL(key))\n    {\n\tstring[0] = CSI;\n\tstring[1] = K_SECOND(key);\n\tstring[2] = K_THIRD(key);\n\tlen = 3;\n    }\n    else\n    {\n\tlen = mb_char2bytes(key, string);\n\n\t// Some keys need adjustment when the Ctrl modifier is used.\n\tkey = may_adjust_key_for_ctrl(modifiers, key);\n\n\t// Remove the SHIFT modifier for keys where it's already included,\n\t// e.g., '(', '!' and '*'.\n\tmodifiers = may_remove_shift_modifier(modifiers, key);\n    }\n\n    if (modifiers != 0)\n    {\n\tstring2[0] = CSI;\n\tstring2[1] = KS_MODIFIER;\n\tstring2[2] = modifiers;\n\tadd_to_input_buf(string2, 3);\n    }\n\n    // Check if the key interrupts.\n    {\n\tint int_ch = check_for_interrupt(key, modifiers);\n\n\tif (int_ch != NUL)\n\t{\n\t    trash_input_buf();\n\t    string[0] = int_ch;\n\t    len = 1;\n\t}\n    }\n\n    add_to_input_buf(string, len);\n\n    /*\n     * blank out the pointer if necessary\n     */\n    if (p_mh)\n\tgui_mch_mousehide(TRUE);\n\n#if defined(FEAT_BEVAL_TIP)\n    {\n\tBalloonEval *be;\n\n\tif ((be = gui_mch_currently_showing_beval()) != NULL)\n\t    gui_mch_unpost_balloon(be);\n    }\n#endif\ntheend:\n    {}\t    // some compilers need a statement here\n#ifdef FEAT_XIM\n    if (string_alloced)\n\tXtFree((char *)string);\n#endif\n}\n\n    static void\ngui_x11_mouse_cb(\n    Widget\tw UNUSED,\n    XtPointer\tdud UNUSED,\n    XEvent\t*event,\n    Boolean\t*dum UNUSED)\n{\n    static XtIntervalId timer = (XtIntervalId)0;\n    static int\ttimed_out = TRUE;\n\n    int\t\tbutton;\n    int\t\trepeated_click = FALSE;\n    int\t\tx, y;\n    int_u\tx_modifiers;\n    int_u\tvim_modifiers;\n\n    if (event->type == MotionNotify)\n    {\n\t// Get the latest position, avoids lagging behind on a drag.\n\tx = event->xmotion.x;\n\ty = event->xmotion.y;\n\tx_modifiers = event->xmotion.state;\n\tbutton = (x_modifiers & (Button1Mask | Button2Mask | Button3Mask))\n\t\t? MOUSE_DRAG : ' ';\n\n\t/*\n\t * if our pointer is currently hidden, then we should show it.\n\t */\n\tgui_mch_mousehide(FALSE);\n\n\tif (button != MOUSE_DRAG)\t// just moving the rodent\n\t{\n#ifdef FEAT_MENU\n\t    if (dud)\t\t\t// moved in vimForm\n\t\ty -= gui.menu_height;\n#endif\n\t    gui_mouse_moved(x, y);\n\t    return;\n\t}\n    }\n    else\n    {\n\tx = event->xbutton.x;\n\ty = event->xbutton.y;\n\tif (event->type == ButtonPress)\n\t{\n\t    // Handle multiple clicks\n\t    if (!timed_out)\n\t    {\n\t\tXtRemoveTimeOut(timer);\n\t\trepeated_click = TRUE;\n\t    }\n\t    timed_out = FALSE;\n\t    timer = XtAppAddTimeOut(app_context, (long_u)p_mouset,\n\t\t\tgui_x11_timer_cb, &timed_out);\n\t    switch (event->xbutton.button)\n\t    {\n\t\t// keep in sync with gui_gtk_x11.c\n\t\tcase Button1:\tbutton = MOUSE_LEFT;\tbreak;\n\t\tcase Button2:\tbutton = MOUSE_MIDDLE;\tbreak;\n\t\tcase Button3:\tbutton = MOUSE_RIGHT;\tbreak;\n\t\tcase Button4:\tbutton = MOUSE_4;\tbreak;\n\t\tcase Button5:\tbutton = MOUSE_5;\tbreak;\n\t\tcase 6:\t\tbutton = MOUSE_7;\tbreak;\n\t\tcase 7:\t\tbutton = MOUSE_6;\tbreak;\n\t\tcase 8:\t\tbutton = MOUSE_X1;\tbreak;\n\t\tcase 9:\t\tbutton = MOUSE_X2;\tbreak;\n\t\tdefault:\n\t\t    return;\t// Unknown button\n\t    }\n\t}\n\telse if (event->type == ButtonRelease)\n\t    button = MOUSE_RELEASE;\n\telse\n\t    return;\t// Unknown mouse event type\n\n\tx_modifiers = event->xbutton.state;\n#if defined(FEAT_GUI_MOTIF) && defined(FEAT_MENU)\n\tlast_mouse_event = event->xbutton;\n#endif\n    }\n\n    vim_modifiers = 0x0;\n    if (x_modifiers & ShiftMask)\n\tvim_modifiers |= MOUSE_SHIFT;\n    if (x_modifiers & ControlMask)\n\tvim_modifiers |= MOUSE_CTRL;\n    if (x_modifiers & Mod1Mask)\t    // Alt or Meta key\n\tvim_modifiers |= MOUSE_ALT;\n\n    gui_send_mouse_event(button, x, y, repeated_click, vim_modifiers);\n}\n\n/*\n * End of call-back routines\n */\n\n/*\n * Parse the GUI related command-line arguments.  Any arguments used are\n * deleted from argv, and *argc is decremented accordingly.  This is called\n * when vim is started, whether or not the GUI has been started.\n */\n    void\ngui_mch_prepare(int *argc, char **argv)\n{\n    int\t    arg;\n    int\t    i;\n\n    /*\n     * Move all the entries in argv which are relevant to X into gui_argv.\n     */\n    gui_argc = 0;\n    gui_argv = LALLOC_MULT(char *, *argc);\n    if (gui_argv == NULL)\n\treturn;\n    gui_argv[gui_argc++] = argv[0];\n    arg = 1;\n    while (arg < *argc)\n    {\n\t// Look for argv[arg] in cmdline_options[] table\n\tfor (i = 0; i < (int)XtNumber(cmdline_options); i++)\n\t    if (strcmp(argv[arg], cmdline_options[i].option) == 0)\n\t\tbreak;\n\n\tif (i < (int)XtNumber(cmdline_options))\n\t{\n\t    // Remember finding \"-rv\" or \"-reverse\"\n\t    if (strcmp(\"-rv\", argv[arg]) == 0\n\t\t    || strcmp(\"-reverse\", argv[arg]) == 0)\n\t\tfound_reverse_arg = TRUE;\n\t    else if ((strcmp(\"-fn\", argv[arg]) == 0\n\t\t\t|| strcmp(\"-font\", argv[arg]) == 0)\n\t\t    && arg + 1 < *argc)\n\t\tfont_argument = argv[arg + 1];\n\n\t    // Found match in table, so move it into gui_argv\n\t    gui_argv[gui_argc++] = argv[arg];\n\t    if (--*argc > arg)\n\t    {\n\t\tmch_memmove(&argv[arg], &argv[arg + 1], (*argc - arg)\n\t\t\t\t\t\t    * sizeof(char *));\n\t\tif (cmdline_options[i].argKind != XrmoptionNoArg)\n\t\t{\n\t\t    // Move the options argument as well\n\t\t    gui_argv[gui_argc++] = argv[arg];\n\t\t    if (--*argc > arg)\n\t\t\tmch_memmove(&argv[arg], &argv[arg + 1], (*argc - arg)\n\t\t\t\t\t\t\t    * sizeof(char *));\n\t\t}\n\t    }\n\t    argv[*argc] = NULL;\n\t}\n\telse\n#ifdef FEAT_NETBEANS_INTG\n\t    if (strncmp(\"-nb\", argv[arg], 3) == 0)\n\t{\n\t    gui.dofork = FALSE;\t// don't fork() when starting GUI\n\t    netbeansArg = argv[arg];\n\t    mch_memmove(&argv[arg], &argv[arg + 1],\n\t\t\t\t\t    (--*argc - arg) * sizeof(char *));\n\t    argv[*argc] = NULL;\n\t}\n\telse\n#endif\n\t    arg++;\n    }\n}\n\n#ifndef XtSpecificationRelease\n# define CARDINAL (Cardinal *)\n#else\n# if XtSpecificationRelease == 4\n# define CARDINAL (Cardinal *)\n# else\n# define CARDINAL (int *)\n# endif\n#endif\n\n/*\n * Check if the GUI can be started.  Called before gvimrc is sourced.\n * Return OK or FAIL.\n */\n    int\ngui_mch_init_check(void)\n{\n#ifdef FEAT_XIM\n    XtSetLanguageProc(NULL, NULL, NULL);\n#endif\n    open_app_context();\n    if (app_context != NULL)\n\tgui.dpy = XtOpenDisplay(app_context, 0, VIM_NAME, VIM_CLASS,\n\t\tcmdline_options, XtNumber(cmdline_options),\n\t\tCARDINAL &gui_argc, gui_argv);\n\n# if defined(FEAT_FLOAT) && defined(LC_NUMERIC)\n    {\n\t// The call to XtOpenDisplay() may have set the locale from the\n\t// environment. Set LC_NUMERIC to \"C\" to make sure that strtod() uses a\n\t// decimal point, not a comma.\n\tchar *p = setlocale(LC_NUMERIC, NULL);\n\n\tif (p == NULL || strcmp(p, \"C\") != 0)\n\t   setlocale(LC_NUMERIC, \"C\");\n    }\n# endif\n    if (app_context == NULL || gui.dpy == NULL)\n    {\n\tgui.dying = TRUE;\n\temsg(_(e_cannot_open_display));\n\treturn FAIL;\n    }\n    return OK;\n}\n\n\n#ifdef USE_XSMP\n/*\n * Handle XSMP processing, de-registering the attachment upon error\n */\nstatic XtInputId _xsmp_xtinputid;\n\n    static void\nlocal_xsmp_handle_requests(\n    XtPointer\tc UNUSED,\n    int\t\t*s UNUSED,\n    XtInputId\t*i UNUSED)\n{\n    if (xsmp_handle_requests() == FAIL)\n\tXtRemoveInput(_xsmp_xtinputid);\n}\n#endif\n\n\n/*\n * Initialise the X GUI.  Create all the windows, set up all the call-backs etc.\n * Returns OK for success, FAIL when the GUI can't be started.\n */\n    int\ngui_mch_init(void)\n{\n    XtGCMask\tgc_mask;\n    XGCValues\tgc_vals;\n    int\t\tx, y, mask;\n    unsigned\tw, h;\n\n#if 0\n    // Uncomment this to enable synchronous mode for debugging\n    XSynchronize(gui.dpy, True);\n#endif\n\n    vimShell = XtVaAppCreateShell(VIM_NAME, VIM_CLASS,\n\t    applicationShellWidgetClass, gui.dpy, NULL);\n\n    /*\n     * Get the application resources\n     */\n    XtVaGetApplicationResources(vimShell, (XtPointer)&gui,\n\tvim_resources, XtNumber(vim_resources), NULL);\n\n    gui.scrollbar_height = gui.scrollbar_width;\n\n    /*\n     * Get the colors ourselves.  Using the automatic conversion doesn't\n     * handle looking for approximate colors.\n     */\n    gui.menu_fg_pixel = gui_get_color((char_u *)gui.rsrc_menu_fg_name);\n    gui.menu_bg_pixel = gui_get_color((char_u *)gui.rsrc_menu_bg_name);\n    gui.scroll_fg_pixel = gui_get_color((char_u *)gui.rsrc_scroll_fg_name);\n    gui.scroll_bg_pixel = gui_get_color((char_u *)gui.rsrc_scroll_bg_name);\n#ifdef FEAT_BEVAL_GUI\n    gui.tooltip_fg_pixel = gui_get_color((char_u *)gui.rsrc_tooltip_fg_name);\n    gui.tooltip_bg_pixel = gui_get_color((char_u *)gui.rsrc_tooltip_bg_name);\n#endif\n\n    // Set default foreground and background colours\n    gui.norm_pixel = gui.def_norm_pixel;\n    gui.back_pixel = gui.def_back_pixel;\n\n    // Check if reverse video needs to be applied (on Sun it's done by X)\n    if (gui.rsrc_rev_video && gui_get_lightness(gui.back_pixel)\n\t\t\t\t\t  > gui_get_lightness(gui.norm_pixel))\n    {\n\tgui.norm_pixel = gui.def_back_pixel;\n\tgui.back_pixel = gui.def_norm_pixel;\n\tgui.def_norm_pixel = gui.norm_pixel;\n\tgui.def_back_pixel = gui.back_pixel;\n    }\n\n    // Get the colors from the \"Normal\", \"Tooltip\", \"Scrollbar\" and \"Menu\"\n    // group (set in syntax.c or in a vimrc file)\n    set_normal_colors();\n\n    /*\n     * Check that none of the colors are the same as the background color\n     */\n    gui_check_colors();\n\n    /*\n     * Set up the GCs.\tThe font attributes will be set in gui_init_font().\n     */\n    gc_mask = GCForeground | GCBackground;\n    gc_vals.foreground = gui.norm_pixel;\n    gc_vals.background = gui.back_pixel;\n    gui.text_gc = XtGetGC(vimShell, gc_mask, &gc_vals);\n\n    gc_vals.foreground = gui.back_pixel;\n    gc_vals.background = gui.norm_pixel;\n    gui.back_gc = XtGetGC(vimShell, gc_mask, &gc_vals);\n\n    gc_mask |= GCFunction;\n    gc_vals.foreground = gui.norm_pixel ^ gui.back_pixel;\n    gc_vals.background = gui.norm_pixel ^ gui.back_pixel;\n    gc_vals.function   = GXxor;\n    gui.invert_gc = XtGetGC(vimShell, gc_mask, &gc_vals);\n\n    gui.visibility = VisibilityUnobscured;\n    x11_setup_atoms(gui.dpy);\n\n    if (gui_win_x != -1 && gui_win_y != -1)\n\tgui_mch_set_winpos(gui_win_x, gui_win_y);\n\n    // Now adapt the supplied(?) geometry-settings\n    // Added by Kjetil Jacobsen <kjetilja@stud.cs.uit.no>\n    if (gui.geom != NULL && *gui.geom != NUL)\n    {\n\tmask = XParseGeometry((char *)gui.geom, &x, &y, &w, &h);\n\tif (mask & WidthValue)\n\t    Columns = w;\n\tif (mask & HeightValue)\n\t{\n\t    if (p_window > (long)h - 1 || !option_was_set((char_u *)\"window\"))\n\t\tp_window = h - 1;\n\t    Rows = h;\n\t}\n\tlimit_screen_size();\n\t/*\n\t * Set the (x,y) position of the main window only if specified in the\n\t * users geometry, so we get good defaults when they don't. This needs\n\t * to be done before the shell is popped up.\n\t */\n\tif (mask & (XValue|YValue))\n\t    XtVaSetValues(vimShell, XtNgeometry, gui.geom, NULL);\n    }\n\n    gui_x11_create_widgets();\n\n   /*\n    * Add an icon to Vim (Marcel Douben: 11 May 1998).\n    */\n    if (vim_strchr(p_go, GO_ICON) != NULL)\n    {\n#ifndef HAVE_XPM\n# include \"vim_icon.xbm\"\n# include \"vim_mask.xbm\"\n\n\tArg\targ[2];\n\n\tXtSetArg(arg[0], XtNiconPixmap,\n\t\tXCreateBitmapFromData(gui.dpy,\n\t\t    DefaultRootWindow(gui.dpy),\n\t\t    (char *)vim_icon_bits,\n\t\t    vim_icon_width,\n\t\t    vim_icon_height));\n\tXtSetArg(arg[1], XtNiconMask,\n\t\tXCreateBitmapFromData(gui.dpy,\n\t\t    DefaultRootWindow(gui.dpy),\n\t\t    (char *)vim_mask_icon_bits,\n\t\t    vim_mask_icon_width,\n\t\t    vim_mask_icon_height));\n\tXtSetValues(vimShell, arg, (Cardinal)2);\n#else\n// Use Pixmaps, looking much nicer.\n\n// If you get an error message here, you still need to unpack the runtime\n// archive!\n# ifdef magick\n#  undef magick\n# endif\n# define magick vim32x32\n# include \"../runtime/vim32x32.xpm\"\n# undef magick\n# define magick vim16x16\n# include \"../runtime/vim16x16.xpm\"\n# undef magick\n# define magick vim48x48\n# include \"../runtime/vim48x48.xpm\"\n# undef magick\n\n    static Pixmap\ticon = 0;\n    static Pixmap\ticon_mask = 0;\n    static char\t\t**magick = vim32x32;\n    Window\t\troot_window;\n    XIconSize\t\t*size;\n    int\t\t\tnumber_sizes;\n    Display\t\t*dsp;\n    Screen\t\t*scr;\n    XpmAttributes\tattr;\n    Colormap\t\tcmap;\n\n    /*\n     * Adjust the icon to the preferences of the actual window manager.\n     */\n    root_window = XRootWindowOfScreen(XtScreen(vimShell));\n    if (XGetIconSizes(XtDisplay(vimShell), root_window,\n\t\t\t\t\t\t   &size, &number_sizes) != 0)\n    {\n\tif (number_sizes > 0)\n\t{\n\t    if (size->max_height >= 48 && size->max_width >= 48)\n\t\tmagick = vim48x48;\n\t    else if (size->max_height >= 32 && size->max_width >= 32)\n\t\tmagick = vim32x32;\n\t    else if (size->max_height >= 16 && size->max_width >= 16)\n\t\tmagick = vim16x16;\n\t}\n    }\n\n    dsp = XtDisplay(vimShell);\n    scr = XtScreen(vimShell);\n\n    cmap = DefaultColormap(dsp, DefaultScreen(dsp));\n    XtVaSetValues(vimShell, XtNcolormap, cmap, NULL);\n\n    attr.valuemask = 0L;\n    attr.valuemask = XpmCloseness | XpmReturnPixels | XpmColormap | XpmDepth;\n    attr.closeness = 65535;\t// accuracy isn't crucial\n    attr.colormap = cmap;\n    attr.depth = DefaultDepthOfScreen(scr);\n\n    if (!icon)\n    {\n\tXpmCreatePixmapFromData(dsp, root_window, magick, &icon,\n\t\t\t\t\t\t\t   &icon_mask, &attr);\n\tXpmFreeAttributes(&attr);\n    }\n\n    XtVaSetValues(vimShell, XmNiconPixmap, icon, XmNiconMask, icon_mask, NULL);\n#endif\n    }\n\n    if (gui.color_approx)\n\temsg(_(e_cannot_allocate_colormap_entry_some_colors_may_be_incorrect));\n\n#ifdef FEAT_BEVAL_GUI\n    gui_init_tooltip_font();\n#endif\n#ifdef FEAT_MENU\n    gui_init_menu_font();\n#endif\n\n#ifdef USE_XSMP\n    // Attach listener on ICE connection\n    if (-1 != xsmp_icefd)\n\t_xsmp_xtinputid = XtAppAddInput(app_context, xsmp_icefd,\n\t\t(XtPointer)XtInputReadMask, local_xsmp_handle_requests, NULL);\n#endif\n\n    return OK;\n}\n\n/*\n * Called when starting the GUI fails after calling gui_mch_init().\n */\n    void\ngui_mch_uninit(void)\n{\n    gui_x11_destroy_widgets();\n    XtCloseDisplay(gui.dpy);\n    gui.dpy = NULL;\n    vimShell = (Widget)0;\n    VIM_CLEAR(gui_argv);\n}\n\n/*\n * Called when the foreground or background color has been changed.\n */\n    void\ngui_mch_new_colors(void)\n{\n    long_u\tgc_mask;\n    XGCValues\tgc_vals;\n\n    gc_mask = GCForeground | GCBackground;\n    gc_vals.foreground = gui.norm_pixel;\n    gc_vals.background = gui.back_pixel;\n    if (gui.text_gc != NULL)\n\tXChangeGC(gui.dpy, gui.text_gc, gc_mask, &gc_vals);\n\n    gc_vals.foreground = gui.back_pixel;\n    gc_vals.background = gui.norm_pixel;\n    if (gui.back_gc != NULL)\n\tXChangeGC(gui.dpy, gui.back_gc, gc_mask, &gc_vals);\n\n    gc_mask |= GCFunction;\n    gc_vals.foreground = gui.norm_pixel ^ gui.back_pixel;\n    gc_vals.background = gui.norm_pixel ^ gui.back_pixel;\n    gc_vals.function   = GXxor;\n    if (gui.invert_gc != NULL)\n\tXChangeGC(gui.dpy, gui.invert_gc, gc_mask, &gc_vals);\n\n    gui_x11_set_back_color();\n}\n\n/*\n * Open the GUI window which was created by a call to gui_mch_init().\n */\n    int\ngui_mch_open(void)\n{\n    // Actually open the window\n    XtRealizeWidget(vimShell);\n    XtManageChild(XtNameToWidget(vimShell, \"*vimForm\"));\n\n    gui.wid = gui_x11_get_wid();\n    gui.blank_pointer = gui_x11_create_blank_mouse();\n\n    /*\n     * Add a callback for the Close item on the window managers menu, and the\n     * save-yourself event.\n     */\n    wm_atoms[SAVE_YOURSELF_IDX] =\n\t\t\t      XInternAtom(gui.dpy, \"WM_SAVE_YOURSELF\", False);\n    wm_atoms[DELETE_WINDOW_IDX] =\n\t\t\t      XInternAtom(gui.dpy, \"WM_DELETE_WINDOW\", False);\n    XSetWMProtocols(gui.dpy, XtWindow(vimShell), wm_atoms, 2);\n    XtAddEventHandler(vimShell, NoEventMask, True, gui_x11_wm_protocol_handler,\n\t\t\t\t\t\t\t     NULL);\n#ifdef HAVE_X11_XMU_EDITRES_H\n    /*\n     * Enable editres protocol (see \"man editres\").\n     * Usually will need to add -lXmu to the linker line as well.\n     */\n    XtAddEventHandler(vimShell, (EventMask)0, True, _XEditResCheckMessages,\n\t    (XtPointer)NULL);\n#endif\n\n#ifdef FEAT_CLIENTSERVER\n    if (serverName == NULL && serverDelayedStartName != NULL)\n    {\n\t// This is a :gui command in a plain vim with no previous server\n\tcommWindow = XtWindow(vimShell);\n\t(void)serverRegisterName(gui.dpy, serverDelayedStartName);\n    }\n    else\n    {\n\t/*\n\t * Cannot handle \"widget-less\" windows with XtProcessEvent() we'll\n\t * have to change the \"server\" registration to that of the main window\n\t * If we have not registered a name yet, remember the window\n\t */\n\tserverChangeRegisteredWindow(gui.dpy, XtWindow(vimShell));\n    }\n    XtAddEventHandler(vimShell, PropertyChangeMask, False,\n\t\t      gui_x11_send_event_handler, NULL);\n#endif\n\n    // Get the colors for the highlight groups (gui_check_colors() might have\n    // changed them)\n    highlight_gui_started();\t\t// re-init colors and fonts\n\n#ifdef FEAT_XIM\n    xim_init();\n#endif\n\n    return OK;\n}\n\n#if defined(FEAT_BEVAL_GUI) || defined(PROTO)\n/*\n * Convert the tooltip fontset name to an XFontSet.\n */\n    void\ngui_init_tooltip_font(void)\n{\n    XrmValue from, to;\n\n    from.addr = (char *)gui.rsrc_tooltip_font_name;\n    from.size = strlen(from.addr);\n    to.addr = (XtPointer)&gui.tooltip_fontset;\n    to.size = sizeof(XFontSet);\n\n    if (XtConvertAndStore(vimShell, XtRString, &from, XtRFontSet, &to) == False)\n    {\n\t// Failed. What to do?\n    }\n}\n#endif\n\n#if defined(FEAT_MENU) || defined(PROTO)\n// Convert the menu font/fontset name to an XFontStruct/XFontset\n    void\ngui_init_menu_font(void)\n{\n    XrmValue from, to;\n\n#ifdef FONTSET_ALWAYS\n    from.addr = (char *)gui.rsrc_menu_font_name;\n    from.size = strlen(from.addr);\n    to.addr = (XtPointer)&gui.menu_fontset;\n    to.size = sizeof(GuiFontset);\n\n    if (XtConvertAndStore(vimShell, XtRString, &from, XtRFontSet, &to) == False)\n    {\n\t// Failed. What to do?\n    }\n#else\n    from.addr = (char *)gui.rsrc_menu_font_name;\n    from.size = strlen(from.addr);\n    to.addr = (XtPointer)&gui.menu_font;\n    to.size = sizeof(GuiFont);\n\n    if (XtConvertAndStore(vimShell, XtRString, &from, XtRFontStruct, &to) == False)\n    {\n\t// Failed. What to do?\n    }\n#endif\n}\n#endif\n\n    void\ngui_mch_exit(int rc UNUSED)\n{\n#if 0\n    // Lesstif gives an error message here, and so does Solaris.  The man page\n    // says that this isn't needed when exiting, so just skip it.\n    XtCloseDisplay(gui.dpy);\n#endif\n    VIM_CLEAR(gui_argv);\n}\n\n/*\n * Get the position of the top left corner of the window.\n */\n    int\ngui_mch_get_winpos(int *x, int *y)\n{\n    Dimension\txpos, ypos;\n\n    XtVaGetValues(vimShell,\n\tXtNx,\t&xpos,\n\tXtNy,\t&ypos,\n\tNULL);\n    *x = xpos;\n    *y = ypos;\n    return OK;\n}\n\n/*\n * Set the position of the top left corner of the window to the given\n * coordinates.\n */\n    void\ngui_mch_set_winpos(int x, int y)\n{\n    XtVaSetValues(vimShell,\n\tXtNx,\tx,\n\tXtNy,\ty,\n\tNULL);\n}\n\n    void\ngui_mch_set_shellsize(\n    int\t\twidth,\n    int\t\theight,\n    int\t\tmin_width,\n    int\t\tmin_height,\n    int\t\tbase_width,\n    int\t\tbase_height,\n    int\t\tdirection UNUSED)\n{\n#ifdef FEAT_XIM\n    height += xim_get_status_area_height(),\n#endif\n    XtVaSetValues(vimShell,\n\tXtNwidthInc,\tgui.char_width,\n\tXtNheightInc,\tgui.char_height,\n#if defined(XtSpecificationRelease) && XtSpecificationRelease >= 4\n\tXtNbaseWidth,\tbase_width,\n\tXtNbaseHeight,\tbase_height,\n#endif\n\tXtNminWidth,\tmin_width,\n\tXtNminHeight,\tmin_height,\n\tXtNwidth,\twidth,\n\tXtNheight,\theight,\n\tNULL);\n}\n\n/*\n * Allow 10 pixels for horizontal borders, 'guiheadroom' for vertical borders.\n * Is there no way in X to find out how wide the borders really are?\n */\n    void\ngui_mch_get_screen_dimensions(\n    int\t    *screen_w,\n    int\t    *screen_h)\n{\n    *screen_w = DisplayWidth(gui.dpy, DefaultScreen(gui.dpy)) - 10;\n    *screen_h = DisplayHeight(gui.dpy, DefaultScreen(gui.dpy)) - p_ghr;\n}\n\n/*\n * Initialise vim to use the font \"font_name\".  If it's NULL, pick a default\n * font.\n * If \"fontset\" is TRUE, load the \"font_name\" as a fontset.\n * Return FAIL if the font could not be loaded, OK otherwise.\n */\n    int\ngui_mch_init_font(\n    char_u\t*font_name,\n    int\t\tdo_fontset UNUSED)\n{\n    XFontStruct\t*font = NULL;\n\n#ifdef FEAT_XFONTSET\n    XFontSet\tfontset = NULL;\n#endif\n\n#ifdef FEAT_GUI_MOTIF\n    // A font name equal \"*\" is indicating, that we should activate the font\n    // selection dialogue to get a new font name. So let us do it here.\n    if (font_name != NULL && STRCMP(font_name, \"*\") == 0)\n    {\n\tfont_name = gui_xm_select_font(hl_get_font_name());\n\n\t// Do not reset to default font except on GUI startup.\n\tif (font_name == NULL && !gui.starting)\n\t    return OK;\n    }\n#endif\n\n#ifdef FEAT_XFONTSET\n    if (do_fontset)\n    {\n\t// If 'guifontset' is set, VIM treats all font specifications as if\n\t// they were fontsets, and 'guifontset' becomes the default.\n\tif (font_name != NULL)\n\t{\n\t    fontset = (XFontSet)gui_mch_get_fontset(font_name, FALSE, TRUE);\n\t    if (fontset == NULL)\n\t\treturn FAIL;\n\t}\n    }\n    else\n#endif\n    {\n\tif (font_name == NULL)\n\t{\n\t    /*\n\t     * If none of the fonts in 'font' could be loaded, try the one set\n\t     * in the X resource, and finally just try using DFLT_FONT, which\n\t     * will hopefully always be there.\n\t     */\n\t    font_name = gui.rsrc_font_name;\n\t    font = (XFontStruct *)gui_mch_get_font(font_name, FALSE);\n\t    if (font == NULL)\n\t\tfont_name = (char_u *)DFLT_FONT;\n\t}\n\tif (font == NULL)\n\t    font = (XFontStruct *)gui_mch_get_font(font_name, FALSE);\n\tif (font == NULL)\n\t    return FAIL;\n    }\n\n    gui_mch_free_font(gui.norm_font);\n#ifdef FEAT_XFONTSET\n    gui_mch_free_fontset(gui.fontset);\n\n    if (fontset != NULL)\n    {\n\tgui.norm_font = NOFONT;\n\tgui.fontset = (GuiFontset)fontset;\n\tgui.char_width = fontset_width(fontset);\n\tgui.char_height = fontset_height(fontset) + p_linespace;\n\tgui.char_ascent = fontset_ascent(fontset) + p_linespace / 2;\n    }\n    else\n#endif\n    {\n\tgui.norm_font = (GuiFont)font;\n#ifdef FEAT_XFONTSET\n\tgui.fontset = NOFONTSET;\n#endif\n\tgui.char_width = font->max_bounds.width;\n\tgui.char_height = font->ascent + font->descent + p_linespace;\n\tgui.char_ascent = font->ascent + p_linespace / 2;\n    }\n\n    hl_set_font_name(font_name);\n\n    /*\n     * Try to load other fonts for bold, italic, and bold-italic.\n     * We should also try to work out what font to use for these when they are\n     * not specified by X resources, but we don't yet.\n     */\n    if (font_name == gui.rsrc_font_name)\n    {\n\tif (gui.bold_font == NOFONT\n\t\t&& gui.rsrc_bold_font_name != NULL\n\t\t&& *gui.rsrc_bold_font_name != NUL)\n\t    gui.bold_font = gui_mch_get_font(gui.rsrc_bold_font_name, FALSE);\n\tif (gui.ital_font == NOFONT\n\t\t&& gui.rsrc_ital_font_name != NULL\n\t\t&& *gui.rsrc_ital_font_name != NUL)\n\t    gui.ital_font = gui_mch_get_font(gui.rsrc_ital_font_name, FALSE);\n\tif (gui.boldital_font == NOFONT\n\t\t&& gui.rsrc_boldital_font_name != NULL\n\t\t&& *gui.rsrc_boldital_font_name != NUL)\n\t    gui.boldital_font = gui_mch_get_font(gui.rsrc_boldital_font_name,\n\t\t\t\t\t\t\t\t       FALSE);\n    }\n    else\n    {\n\t// When not using the font specified by the resources, also don't use\n\t// the bold/italic fonts, otherwise setting 'guifont' will look very\n\t// strange.\n\tif (gui.bold_font != NOFONT)\n\t{\n\t    XFreeFont(gui.dpy, (XFontStruct *)gui.bold_font);\n\t    gui.bold_font = NOFONT;\n\t}\n\tif (gui.ital_font != NOFONT)\n\t{\n\t    XFreeFont(gui.dpy, (XFontStruct *)gui.ital_font);\n\t    gui.ital_font = NOFONT;\n\t}\n\tif (gui.boldital_font != NOFONT)\n\t{\n\t    XFreeFont(gui.dpy, (XFontStruct *)gui.boldital_font);\n\t    gui.boldital_font = NOFONT;\n\t}\n    }\n\n#ifdef FEAT_GUI_MOTIF\n    gui_motif_synch_fonts();\n#endif\n\n    return OK;\n}\n\n/*\n * Get a font structure for highlighting.\n */\n    GuiFont\ngui_mch_get_font(char_u *name, int giveErrorIfMissing)\n{\n    XFontStruct\t*font;\n\n    if (!gui.in_use || name == NULL)\t// can't do this when GUI not running\n\treturn NOFONT;\n\n    font = XLoadQueryFont(gui.dpy, (char *)name);\n\n    if (font == NULL)\n    {\n\tif (giveErrorIfMissing)\n\t    semsg(_(e_unknown_font_str), name);\n\treturn NOFONT;\n    }\n\n#ifdef DEBUG\n    printf(\"Font Information for '%s':\\n\", name);\n    printf(\"  w = %d, h = %d, ascent = %d, descent = %d\\n\",\n\t   font->max_bounds.width, font->ascent + font->descent,\n\t   font->ascent, font->descent);\n    printf(\"  max ascent = %d, max descent = %d, max h = %d\\n\",\n\t   font->max_bounds.ascent, font->max_bounds.descent,\n\t   font->max_bounds.ascent + font->max_bounds.descent);\n    printf(\"  min lbearing = %d, min rbearing = %d\\n\",\n\t   font->min_bounds.lbearing, font->min_bounds.rbearing);\n    printf(\"  max lbearing = %d, max rbearing = %d\\n\",\n\t   font->max_bounds.lbearing, font->max_bounds.rbearing);\n    printf(\"  leftink = %d, rightink = %d\\n\",\n\t   (font->min_bounds.lbearing < 0),\n\t   (font->max_bounds.rbearing > font->max_bounds.width));\n    printf(\"\\n\");\n#endif\n\n    if (font->max_bounds.width != font->min_bounds.width)\n    {\n\tsemsg(_(e_font_str_is_not_fixed_width), name);\n\tXFreeFont(gui.dpy, font);\n\treturn NOFONT;\n    }\n    return (GuiFont)font;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return the name of font \"font\" in allocated memory.\n */\n    char_u *\ngui_mch_get_fontname(GuiFont font, char_u *name)\n{\n    char_u *ret = NULL;\n\n    if (name != NULL && font == NULL)\n    {\n\t// In this case, there's no way other than doing this.\n\tret = vim_strsave(name);\n    }\n    else if (font != NULL)\n    {\n\t// In this case, try to retrieve the XLFD corresponding to 'font'->fid;\n\t// if failed, use 'name' unless it's NULL.\n\tunsigned long value = 0L;\n\n\tif (XGetFontProperty(font, XA_FONT, &value))\n\t{\n\t    char *xa_font_name = NULL;\n\n\t    xa_font_name = XGetAtomName(gui.dpy, value);\n\t    if (xa_font_name != NULL)\n\t    {\n\t\tret = vim_strsave((char_u *)xa_font_name);\n\t\tXFree(xa_font_name);\n\t    }\n\t    else if (name != NULL)\n\t\tret = vim_strsave(name);\n\t}\n\telse if (name != NULL)\n\t    ret = vim_strsave(name);\n    }\n    return ret;\n}\n#endif\n\n/*\n * Adjust gui.char_height (after 'linespace' was changed).\n */\n    int\ngui_mch_adjust_charheight(void)\n{\n#ifdef FEAT_XFONTSET\n    if (gui.fontset != NOFONTSET)\n    {\n\tgui.char_height = fontset_height((XFontSet)gui.fontset) + p_linespace;\n\tgui.char_ascent = fontset_ascent((XFontSet)gui.fontset)\n\t\t\t\t\t\t\t    + p_linespace / 2;\n    }\n    else\n#endif\n    {\n\tXFontStruct *font = (XFontStruct *)gui.norm_font;\n\n\tgui.char_height = font->ascent + font->descent + p_linespace;\n\tgui.char_ascent = font->ascent + p_linespace / 2;\n    }\n    return OK;\n}\n\n/*\n * Set the current text font.\n */\n    void\ngui_mch_set_font(GuiFont font)\n{\n    static Font\tprev_font = (Font)-1;\n    Font\tfid = ((XFontStruct *)font)->fid;\n\n    if (fid != prev_font)\n    {\n\tXSetFont(gui.dpy, gui.text_gc, fid);\n\tXSetFont(gui.dpy, gui.back_gc, fid);\n\tprev_font = fid;\n\tgui.char_ascent = ((XFontStruct *)font)->ascent + p_linespace / 2;\n    }\n#ifdef FEAT_XFONTSET\n    current_fontset = (XFontSet)NULL;\n#endif\n}\n\n#if defined(FEAT_XFONTSET) || defined(PROTO)\n/*\n * Set the current text fontset.\n * Adjust the ascent, in case it's different.\n */\n    void\ngui_mch_set_fontset(GuiFontset fontset)\n{\n    current_fontset = (XFontSet)fontset;\n    gui.char_ascent = fontset_ascent(current_fontset) + p_linespace / 2;\n}\n#endif\n\n/*\n * If a font is not going to be used, free its structure.\n */\n    void\ngui_mch_free_font(GuiFont font)\n{\n    if (font != NOFONT)\n\tXFreeFont(gui.dpy, (XFontStruct *)font);\n}\n\n#if defined(FEAT_XFONTSET) || defined(PROTO)\n/*\n * If a fontset is not going to be used, free its structure.\n */\n    void\ngui_mch_free_fontset(GuiFontset fontset)\n{\n    if (fontset != NOFONTSET)\n\tXFreeFontSet(gui.dpy, (XFontSet)fontset);\n}\n\n/*\n * Load the fontset \"name\".\n * Return a reference to the fontset, or NOFONTSET when failing.\n */\n    GuiFontset\ngui_mch_get_fontset(\n    char_u\t*name,\n    int\t\tgiveErrorIfMissing,\n    int\t\tfixed_width)\n{\n    XFontSet\tfontset;\n    char\t**missing, *def_str;\n    int\t\tnum_missing;\n\n    if (!gui.in_use || name == NULL)\n\treturn NOFONTSET;\n\n    fontset = XCreateFontSet(gui.dpy, (char *)name, &missing, &num_missing,\n\t\t\t     &def_str);\n    if (num_missing > 0)\n    {\n\tint i;\n\n\tif (giveErrorIfMissing)\n\t{\n\t    semsg(_(e_fonts_for_the_following_charsets_are_missing_in_fontset), name);\n\t    for (i = 0; i < num_missing; i++)\n\t\tsemsg(\"%s\", missing[i]);\n\t}\n\tXFreeStringList(missing);\n    }\n\n    if (fontset == NULL)\n    {\n\tif (giveErrorIfMissing)\n\t    semsg(_(e_unknown_fontset_str), name);\n\treturn NOFONTSET;\n    }\n\n    if (fixed_width && check_fontset_sanity(fontset) == FAIL)\n    {\n\tXFreeFontSet(gui.dpy, fontset);\n\treturn NOFONTSET;\n    }\n    return (GuiFontset)fontset;\n}\n\n/*\n * Check if fontset \"fs\" is fixed width.\n */\n    static int\ncheck_fontset_sanity(XFontSet fs)\n{\n    XFontStruct\t**xfs;\n    char\t**font_name;\n    int\t\tfn;\n    char\t*base_name;\n    int\t\ti;\n    int\t\tmin_width;\n    int\t\tmin_font_idx = 0;\n\n    base_name = XBaseFontNameListOfFontSet(fs);\n    fn = XFontsOfFontSet(fs, &xfs, &font_name);\n    for (i = 0; i < fn; i++)\n    {\n\tif (xfs[i]->max_bounds.width != xfs[i]->min_bounds.width)\n\t{\n\t    semsg(_(e_fontsent_name_str_font_str_is_not_fixed_width),\n\t\t    base_name, font_name[i]);\n\t    return FAIL;\n\t}\n    }\n    // scan base font width\n    min_width = 32767;\n    for (i = 0; i < fn; i++)\n    {\n\tif (xfs[i]->max_bounds.width<min_width)\n\t{\n\t    min_width = xfs[i]->max_bounds.width;\n\t    min_font_idx = i;\n\t}\n    }\n    for (i = 0; i < fn; i++)\n    {\n\tif (\t   xfs[i]->max_bounds.width != 2 * min_width\n\t\t&& xfs[i]->max_bounds.width != min_width)\n\t{\n\t    semsg(_(e_fontset_name_str), base_name);\n\t    semsg(_(\"Font0: %s\"), font_name[min_font_idx]);\n\t    semsg(_(\"Font%d: %s\"), i, font_name[i]);\n\t    semsg(_(\"Font%d width is not twice that of font0\"), i);\n\t    semsg(_(\"Font0 width: %d\"),\n\t\t\t\t     (int)xfs[min_font_idx]->max_bounds.width);\n\t    semsg(_(\"Font%d width: %d\"), i, (int)xfs[i]->max_bounds.width);\n\t    return FAIL;\n\t}\n    }\n    // it seems ok. Good Luck!!\n    return OK;\n}\n\n    static int\nfontset_width(XFontSet fs)\n{\n return XmbTextEscapement(fs, \"Vim\", 3) / 3;\n}\n\n    int\nfontset_height(\n    XFontSet fs)\n{\n    XFontSetExtents *extents;\n\n    extents = XExtentsOfFontSet(fs);\n    return extents->max_logical_extent.height;\n}\n\n#if 0\n// NOT USED YET\n    static int\nfontset_descent(XFontSet fs)\n{\n    XFontSetExtents *extents;\n\n    extents = XExtentsOfFontSet (fs);\n    return extents->max_logical_extent.height + extents->max_logical_extent.y;\n}\n#endif\n\n    static int\nfontset_ascent(XFontSet fs)\n{\n    XFontSetExtents *extents;\n\n    extents = XExtentsOfFontSet(fs);\n    return -extents->max_logical_extent.y;\n}\n\n#endif // FEAT_XFONTSET\n\n/*\n * Return the Pixel value (color) for the given color name.\n * Return INVALCOLOR for error.\n */\n    guicolor_T\ngui_mch_get_color(char_u *name)\n{\n    guicolor_T\trequested;\n\n    // can't do this when GUI not running\n    if (!gui.in_use || name == NULL || *name == NUL)\n\treturn INVALCOLOR;\n\n    requested = gui_get_color_cmn(name);\n    if (requested == INVALCOLOR)\n\treturn INVALCOLOR;\n\n    return gui_mch_get_rgb_color(\n\t    (requested & 0xff0000) >> 16,\n\t    (requested & 0xff00) >> 8,\n\t    requested & 0xff);\n}\n\n/*\n * Return the Pixel value (color) for the given RGB values.\n * Return INVALCOLOR for error.\n */\n    guicolor_T\ngui_mch_get_rgb_color(int r, int g, int b)\n{\n    XColor\tavailable;\n    Colormap\tcolormap;\n\n#if 0\n// Using XParseColor() is very slow, put rgb in XColor directly.\n\n    char\tspec[8]; // space enough to hold \"#RRGGBB\"\n    vim_snprintf(spec, sizeof(spec), \"#%.2x%.2x%.2x\", r, g, b);\n    if (XParseColor(gui.dpy, colormap, (char *)spec, &available) != 0\n\t    && XAllocColor(gui.dpy, colormap, &available) != 0)\n\treturn (guicolor_T)available.pixel;\n#endif\n    colormap = DefaultColormap(gui.dpy, DefaultScreen(gui.dpy));\n    CLEAR_FIELD(available);\n    available.red = r << 8;\n    available.green = g << 8;\n    available.blue = b << 8;\n    if (XAllocColor(gui.dpy, colormap, &available) != 0)\n\treturn (guicolor_T)available.pixel;\n\n    return INVALCOLOR;\n}\n\n/*\n * Set the current text foreground color.\n */\n    void\ngui_mch_set_fg_color(guicolor_T color)\n{\n    if (color != prev_fg_color)\n    {\n\tXSetForeground(gui.dpy, gui.text_gc, (Pixel)color);\n\tprev_fg_color = color;\n    }\n}\n\n/*\n * Set the current text background color.\n */\n    void\ngui_mch_set_bg_color(guicolor_T color)\n{\n    if (color != prev_bg_color)\n    {\n\tXSetBackground(gui.dpy, gui.text_gc, (Pixel)color);\n\tprev_bg_color = color;\n    }\n}\n\n/*\n * Set the current text special color.\n */\n    void\ngui_mch_set_sp_color(guicolor_T color)\n{\n    prev_sp_color = color;\n}\n\n/*\n * create a mouse pointer that is blank\n */\n    static Cursor\ngui_x11_create_blank_mouse(void)\n{\n    Pixmap blank_pixmap = XCreatePixmap(gui.dpy, gui.wid, 1, 1, 1);\n    GC gc = XCreateGC(gui.dpy, blank_pixmap, (unsigned long)0, (XGCValues*)0);\n    XDrawPoint(gui.dpy, blank_pixmap, gc, 0, 0);\n    XFreeGC(gui.dpy, gc);\n    return XCreatePixmapCursor(gui.dpy, blank_pixmap, blank_pixmap,\n\t    (XColor*)&gui.norm_pixel, (XColor*)&gui.norm_pixel, 0, 0);\n}\n\n/*\n * Draw a curled line at the bottom of the character cell.\n */\n    static void\ndraw_curl(int row, int col, int cells)\n{\n    int\t\t\ti;\n    int\t\t\toffset;\n    static const int\tval[8] = {1, 0, 0, 0, 1, 2, 2, 2 };\n\n    XSetForeground(gui.dpy, gui.text_gc, prev_sp_color);\n    for (i = FILL_X(col); i < FILL_X(col + cells); ++i)\n    {\n\toffset = val[i % 8];\n\tXDrawPoint(gui.dpy, gui.wid, gui.text_gc, i,\n\t\t\t\t\t\tFILL_Y(row + 1) - 1 - offset);\n    }\n    XSetForeground(gui.dpy, gui.text_gc, prev_fg_color);\n}\n\n    void\ngui_mch_draw_string(\n    int\t\trow,\n    int\t\tcol,\n    char_u\t*s,\n    int\t\tlen,\n    int\t\tflags)\n{\n    int\t\t\tcells = len;\n    static void\t\t*buf = NULL;\n    static int\t\tbuflen = 0;\n    char_u\t\t*p;\n    int\t\t\twlen = 0;\n    int\t\t\tc;\n\n    if (enc_utf8)\n    {\n\t// Convert UTF-8 byte sequence to 16 bit characters for the X\n\t// functions.  Need a buffer for the 16 bit characters.  Keep it\n\t// between calls, because allocating it each time is slow.\n\tif (buflen < len)\n\t{\n\t    XtFree((char *)buf);\n\t    buf = (void *)XtMalloc(len * (sizeof(XChar2b) < sizeof(wchar_t)\n\t\t\t\t\t? sizeof(wchar_t) : sizeof(XChar2b)));\n\t    buflen = len;\n\t}\n\tp = s;\n\tcells = 0;\n\twhile (p < s + len)\n\t{\n\t    c = utf_ptr2char(p);\n#ifdef FEAT_XFONTSET\n\t    if (current_fontset != NULL)\n\t    {\n# ifdef SMALL_WCHAR_T\n\t\tif (c >= 0x10000)\n\t\t    c = 0xbf;\t\t// show chars > 0xffff as ?\n# endif\n\t\t((wchar_t *)buf)[wlen] = c;\n\t    }\n\t    else\n#endif\n\t    {\n\t\tif (c >= 0x10000)\n\t\t    c = 0xbf;\t\t// show chars > 0xffff as ?\n\t\t((XChar2b *)buf)[wlen].byte1 = (unsigned)c >> 8;\n\t\t((XChar2b *)buf)[wlen].byte2 = c;\n\t    }\n\t    ++wlen;\n\t    cells += utf_char2cells(c);\n\t    p += utf_ptr2len(p);\n\t}\n    }\n    else if (has_mbyte)\n    {\n\tcells = 0;\n\tfor (p = s; p < s + len; )\n\t{\n\t    cells += ptr2cells(p);\n\t    p += (*mb_ptr2len)(p);\n\t}\n    }\n\n#ifdef FEAT_XFONTSET\n    if (current_fontset != NULL)\n    {\n\t// Setup a clip rectangle to avoid spilling over in the next or\n\t// previous line.  This is apparently needed for some fonts which are\n\t// used in a fontset.\n\tXRectangle\tclip;\n\n\tclip.x = 0;\n\tclip.y = 0;\n\tclip.height = gui.char_height;\n\tclip.width = gui.char_width * cells + 1;\n\tXSetClipRectangles(gui.dpy, gui.text_gc, FILL_X(col), FILL_Y(row),\n\t\t&clip, 1, Unsorted);\n    }\n#endif\n\n    if (flags & DRAW_TRANSP)\n    {\n\tif (enc_utf8)\n\t    XDrawString16(gui.dpy, gui.wid, gui.text_gc, TEXT_X(col),\n\t\t    TEXT_Y(row), buf, wlen);\n\telse\n\t    XDrawString(gui.dpy, gui.wid, gui.text_gc, TEXT_X(col),\n\t\t    TEXT_Y(row), (char *)s, len);\n    }\n    else if (p_linespace != 0\n#ifdef FEAT_XFONTSET\n\t    || current_fontset != NULL\n#endif\n\t    )\n    {\n\tXSetForeground(gui.dpy, gui.text_gc, prev_bg_color);\n\tXFillRectangle(gui.dpy, gui.wid, gui.text_gc, FILL_X(col),\n\t\tFILL_Y(row), gui.char_width * cells, gui.char_height);\n\tXSetForeground(gui.dpy, gui.text_gc, prev_fg_color);\n\n\tif (enc_utf8)\n\t    XDrawString16(gui.dpy, gui.wid, gui.text_gc, TEXT_X(col),\n\t\t    TEXT_Y(row), buf, wlen);\n\telse\n\t    XDrawString(gui.dpy, gui.wid, gui.text_gc, TEXT_X(col),\n\t\t    TEXT_Y(row), (char *)s, len);\n    }\n    else\n    {\n\t// XmbDrawImageString has bug, don't use it for fontset.\n\tif (enc_utf8)\n\t    XDrawImageString16(gui.dpy, gui.wid, gui.text_gc, TEXT_X(col),\n\t\t    TEXT_Y(row), buf, wlen);\n\telse\n\t    XDrawImageString(gui.dpy, gui.wid, gui.text_gc, TEXT_X(col),\n\t\t    TEXT_Y(row), (char *)s, len);\n    }\n\n    // Bold trick: draw the text again with a one-pixel offset.\n    if (flags & DRAW_BOLD)\n    {\n\tif (enc_utf8)\n\t    XDrawString16(gui.dpy, gui.wid, gui.text_gc, TEXT_X(col) + 1,\n\t\t    TEXT_Y(row), buf, wlen);\n\telse\n\t    XDrawString(gui.dpy, gui.wid, gui.text_gc, TEXT_X(col) + 1,\n\t\t    TEXT_Y(row), (char *)s, len);\n    }\n\n    // Undercurl: draw curl at the bottom of the character cell.\n    if (flags & DRAW_UNDERC)\n\tdraw_curl(row, col, cells);\n\n    // Underline: draw a line at the bottom of the character cell.\n    if (flags & DRAW_UNDERL)\n    {\n\tint\ty = FILL_Y(row + 1) - 1;\n\n\t// When p_linespace is 0, overwrite the bottom row of pixels.\n\t// Otherwise put the line just below the character.\n\tif (p_linespace > 1)\n\t    y -= p_linespace - 1;\n\tXDrawLine(gui.dpy, gui.wid, gui.text_gc, FILL_X(col),\n\t\ty, FILL_X(col + cells) - 1, y);\n    }\n\n    if (flags & DRAW_STRIKE)\n    {\n\tint\ty = FILL_Y(row + 1) - gui.char_height/2;\n\n\tXSetForeground(gui.dpy, gui.text_gc, prev_sp_color);\n\tXDrawLine(gui.dpy, gui.wid, gui.text_gc, FILL_X(col),\n\t\ty, FILL_X(col + cells) - 1, y);\n\tXSetForeground(gui.dpy, gui.text_gc, prev_fg_color);\n    }\n\n#ifdef FEAT_XFONTSET\n    if (current_fontset != NULL)\n\tXSetClipMask(gui.dpy, gui.text_gc, None);\n#endif\n}\n\n/*\n * Return OK if the key with the termcap name \"name\" is supported.\n */\n    int\ngui_mch_haskey(char_u *name)\n{\n    int i;\n\n    for (i = 0; special_keys[i].key_sym != (KeySym)0; i++)\n\tif (name[0] == special_keys[i].vim_code0 &&\n\t\t\t\t\t name[1] == special_keys[i].vim_code1)\n\t    return OK;\n    return FAIL;\n}\n\n/*\n * Return the text window-id and display.  Only required for X-based GUI's\n */\n    int\ngui_get_x11_windis(Window *win, Display **dis)\n{\n    *win = XtWindow(vimShell);\n    *dis = gui.dpy;\n    return OK;\n}\n\n    void\ngui_mch_beep(void)\n{\n    XBell(gui.dpy, 0);\n}\n\n    void\ngui_mch_flash(int msec)\n{\n    // Do a visual beep by reversing the foreground and background colors\n    XFillRectangle(gui.dpy, gui.wid, gui.invert_gc, 0, 0,\n\t    FILL_X((int)Columns) + gui.border_offset,\n\t    FILL_Y((int)Rows) + gui.border_offset);\n    XSync(gui.dpy, False);\n    ui_delay((long)msec, TRUE);\t// wait for a few msec\n    XFillRectangle(gui.dpy, gui.wid, gui.invert_gc, 0, 0,\n\t    FILL_X((int)Columns) + gui.border_offset,\n\t    FILL_Y((int)Rows) + gui.border_offset);\n}\n\n/*\n * Invert a rectangle from row r, column c, for nr rows and nc columns.\n */\n    void\ngui_mch_invert_rectangle(\n    int\t    r,\n    int\t    c,\n    int\t    nr,\n    int\t    nc)\n{\n    XFillRectangle(gui.dpy, gui.wid, gui.invert_gc,\n\tFILL_X(c), FILL_Y(r), (nc) * gui.char_width, (nr) * gui.char_height);\n}\n\n/*\n * Iconify the GUI window.\n */\n    void\ngui_mch_iconify(void)\n{\n    XIconifyWindow(gui.dpy, XtWindow(vimShell), DefaultScreen(gui.dpy));\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Bring the Vim window to the foreground.\n */\n    void\ngui_mch_set_foreground(void)\n{\n    XMapRaised(gui.dpy, XtWindow(vimShell));\n}\n#endif\n\n/*\n * Draw a cursor without focus.\n */\n    void\ngui_mch_draw_hollow_cursor(guicolor_T color)\n{\n    int\t\tw = 1;\n\n    if (mb_lefthalve(gui.row, gui.col))\n\tw = 2;\n    gui_mch_set_fg_color(color);\n    XDrawRectangle(gui.dpy, gui.wid, gui.text_gc, FILL_X(gui.col),\n\t    FILL_Y(gui.row), w * gui.char_width - 1, gui.char_height - 1);\n}\n\n/*\n * Draw part of a cursor, \"w\" pixels wide, and \"h\" pixels high, using\n * color \"color\".\n */\n    void\ngui_mch_draw_part_cursor(int w, int h, guicolor_T color)\n{\n    gui_mch_set_fg_color(color);\n\n    XFillRectangle(gui.dpy, gui.wid, gui.text_gc,\n#ifdef FEAT_RIGHTLEFT\n\t    // vertical line should be on the right of current point\n\t    CURSOR_BAR_RIGHT ? FILL_X(gui.col + 1) - w :\n#endif\n\t\tFILL_X(gui.col),\n\t    FILL_Y(gui.row) + gui.char_height - h,\n\t    w, h);\n}\n\n/*\n * Catch up with any queued X events.  This may put keyboard input into the\n * input buffer, call resize call-backs, trigger timers etc.  If there is\n * nothing in the X event queue (& no timers pending), then we return\n * immediately.\n */\n    void\ngui_mch_update(void)\n{\n    XtInputMask mask, desired;\n\n#ifdef ALT_X_INPUT\n    if (suppress_alternate_input)\n\tdesired = (XtIMXEvent | XtIMTimer);\n    else\n#endif\n\tdesired = (XtIMAll);\n    while ((mask = XtAppPending(app_context)) && (mask & desired)\n\t    && !vim_is_input_buf_full())\n\tXtAppProcessEvent(app_context, desired);\n}\n\n/*\n * GUI input routine called by gui_wait_for_chars().  Waits for a character\n * from the keyboard.\n *  wtime == -1\t    Wait forever.\n *  wtime == 0\t    This should never happen.\n *  wtime > 0\t    Wait wtime milliseconds for a character.\n * Returns OK if a character was found to be available within the given time,\n * or FAIL otherwise.\n */\n    int\ngui_mch_wait_for_chars(long wtime)\n{\n    int\t    focus;\n    int\t    retval = FAIL;\n\n    /*\n     * Make this static, in case gui_x11_timer_cb is called after leaving\n     * this function (otherwise a random value on the stack may be changed).\n     */\n    static int\t    timed_out;\n    XtIntervalId    timer = (XtIntervalId)0;\n    XtInputMask\t    desired;\n#ifdef FEAT_JOB_CHANNEL\n    XtIntervalId    channel_timer = (XtIntervalId)0;\n#endif\n\n    timed_out = FALSE;\n\n    if (wtime >= 0)\n\ttimer = XtAppAddTimeOut(app_context,\n\t\t\t\t(long_u)(wtime == 0 ? 1L : wtime),\n\t\t\t\t\t\t gui_x11_timer_cb, &timed_out);\n#ifdef FEAT_JOB_CHANNEL\n    // If there is a channel with the keep_open flag we need to poll for input\n    // on them.\n    if (channel_any_keep_open())\n\tchannel_timer = XtAppAddTimeOut(app_context, (long_u)20,\n\t\t\t\t   channel_poll_cb, (XtPointer)&channel_timer);\n#endif\n\n    focus = gui.in_focus;\n    desired = (XtIMAll);\n    while (!timed_out)\n    {\n\t// Stop or start blinking when focus changes\n\tif (gui.in_focus != focus)\n\t{\n\t    if (gui.in_focus)\n\t\tgui_mch_start_blink();\n\t    else\n\t\tgui_mch_stop_blink(TRUE);\n\t    focus = gui.in_focus;\n\t}\n\n#ifdef MESSAGE_QUEUE\n# ifdef FEAT_TIMERS\n\tdid_add_timer = FALSE;\n# endif\n\tparse_queued_messages();\n# ifdef FEAT_TIMERS\n\tif (did_add_timer)\n\t    // Need to recompute the waiting time.\n\t    break;\n# endif\n#endif\n\n\t/*\n\t * Don't use gui_mch_update() because then we will spin-lock until a\n\t * char arrives, instead we use XtAppProcessEvent() to hang until an\n\t * event arrives.  No need to check for input_buf_full because we are\n\t * returning as soon as it contains a single char.  Note that\n\t * XtAppNextEvent() may not be used because it will not return after a\n\t * timer event has arrived -- webb\n\t */\n\tXtAppProcessEvent(app_context, desired);\n\n\tif (input_available())\n\t{\n\t    retval = OK;\n\t    break;\n\t}\n    }\n\n    if (timer != (XtIntervalId)0 && !timed_out)\n\tXtRemoveTimeOut(timer);\n#ifdef FEAT_JOB_CHANNEL\n    if (channel_timer != (XtIntervalId)0)\n\tXtRemoveTimeOut(channel_timer);\n#endif\n\n    return retval;\n}\n\n/*\n * Output routines.\n */\n\n/*\n * Flush any output to the screen\n */\n    void\ngui_mch_flush(void)\n{\n    XFlush(gui.dpy);\n}\n\n/*\n * Clear a rectangular region of the screen from text pos (row1, col1) to\n * (row2, col2) inclusive.\n */\n    void\ngui_mch_clear_block(\n    int\t\trow1,\n    int\t\tcol1,\n    int\t\trow2,\n    int\t\tcol2)\n{\n    int\t\tx;\n\n    x = FILL_X(col1);\n\n    // Clear one extra pixel at the far right, for when bold characters have\n    // spilled over to the next column.\n    XFillRectangle(gui.dpy, gui.wid, gui.back_gc, x, FILL_Y(row1),\n\t    (col2 - col1 + 1) * gui.char_width + (col2 == Columns - 1),\n\t    (row2 - row1 + 1) * gui.char_height);\n}\n\n    void\ngui_mch_clear_all(void)\n{\n    XClearArea(gui.dpy, gui.wid, 0, 0, 0, 0, False);\n}\n\n/*\n * Delete the given number of lines from the given row, scrolling up any\n * text further down within the scroll region.\n */\n    void\ngui_mch_delete_lines(int row, int num_lines)\n{\n    if (gui.visibility == VisibilityFullyObscured)\n\treturn;\t    // Can't see the window\n\n    // copy one extra pixel at the far right, for when bold has spilled\n    // over\n    XCopyArea(gui.dpy, gui.wid, gui.wid, gui.text_gc,\n\tFILL_X(gui.scroll_region_left), FILL_Y(row + num_lines),\n\tgui.char_width * (gui.scroll_region_right - gui.scroll_region_left + 1)\n\t\t\t       + (gui.scroll_region_right == Columns - 1),\n\tgui.char_height * (gui.scroll_region_bot - row - num_lines + 1),\n\tFILL_X(gui.scroll_region_left), FILL_Y(row));\n\n    gui_clear_block(gui.scroll_region_bot - num_lines + 1,\n\t\t\t\t\t\t       gui.scroll_region_left,\n\t\t\t  gui.scroll_region_bot, gui.scroll_region_right);\n    gui_x11_check_copy_area();\n}\n\n/*\n * Insert the given number of lines before the given row, scrolling down any\n * following text within the scroll region.\n */\n    void\ngui_mch_insert_lines(int row, int num_lines)\n{\n    if (gui.visibility == VisibilityFullyObscured)\n\treturn;\t    // Can't see the window\n\n    // copy one extra pixel at the far right, for when bold has spilled\n    // over\n    XCopyArea(gui.dpy, gui.wid, gui.wid, gui.text_gc,\n\tFILL_X(gui.scroll_region_left), FILL_Y(row),\n\tgui.char_width * (gui.scroll_region_right - gui.scroll_region_left + 1)\n\t\t\t       + (gui.scroll_region_right == Columns - 1),\n\tgui.char_height * (gui.scroll_region_bot - row - num_lines + 1),\n\tFILL_X(gui.scroll_region_left), FILL_Y(row + num_lines));\n\n    gui_clear_block(row, gui.scroll_region_left,\n\t\t\t\trow + num_lines - 1, gui.scroll_region_right);\n    gui_x11_check_copy_area();\n}\n\n/*\n * Update the region revealed by scrolling up/down.\n */\n    static void\ngui_x11_check_copy_area(void)\n{\n    XEvent\t\t    event;\n    XGraphicsExposeEvent    *gevent;\n\n    if (gui.visibility != VisibilityPartiallyObscured)\n\treturn;\n\n    XFlush(gui.dpy);\n\n    // Wait to check whether the scroll worked or not\n    for (;;)\n    {\n\tif (XCheckTypedEvent(gui.dpy, NoExpose, &event))\n\t    return;\t// The scroll worked.\n\n\tif (XCheckTypedEvent(gui.dpy, GraphicsExpose, &event))\n\t{\n\t    gevent = (XGraphicsExposeEvent *)&event;\n\t    gui_redraw(gevent->x, gevent->y, gevent->width, gevent->height);\n\t    if (gevent->count == 0)\n\t\treturn;\t\t// This was the last expose event\n\t}\n\tXSync(gui.dpy, False);\n    }\n}\n\n/*\n * X Selection stuff, for cutting and pasting text to other windows.\n */\n\n    void\nclip_mch_lose_selection(Clipboard_T *cbd)\n{\n    clip_x11_lose_selection(vimShell, cbd);\n}\n\n    int\nclip_mch_own_selection(Clipboard_T *cbd)\n{\n    return clip_x11_own_selection(vimShell, cbd);\n}\n\n    void\nclip_mch_request_selection(Clipboard_T *cbd)\n{\n clip_x11_request_selection(vimShell, gui.dpy, cbd);\n}\n\n    void\nclip_mch_set_selection(\n    Clipboard_T\t*cbd)\n{\n    clip_x11_set_selection(cbd);\n}\n\n#if defined(FEAT_MENU) || defined(PROTO)\n/*\n * Menu stuff.\n */\n\n/*\n * Make a menu either grey or not grey.\n */\n    void\ngui_mch_menu_grey(vimmenu_T *menu, int grey)\n{\n    if (menu->id != (Widget)0)\n    {\n\tgui_mch_menu_hidden(menu, False);\n\tif (grey\n#ifdef FEAT_GUI_MOTIF\n\t\t|| !menu->sensitive\n#endif\n\t\t)\n\t    XtSetSensitive(menu->id, False);\n\telse\n\t    XtSetSensitive(menu->id, True);\n    }\n}\n\n/*\n * Make menu item hidden or not hidden\n */\n    void\ngui_mch_menu_hidden(vimmenu_T *menu, int hidden)\n{\n    if (menu->id != (Widget)0)\n    {\n\tif (hidden)\n\t    XtUnmanageChild(menu->id);\n\telse\n\t    XtManageChild(menu->id);\n    }\n}\n\n/*\n * This is called after setting all the menus to grey/hidden or not.\n */\n    void\ngui_mch_draw_menubar(void)\n{\n    // Nothing to do in X\n}\n\n    void\ngui_x11_menu_cb(\n    Widget\tw UNUSED,\n    XtPointer\tclient_data,\n    XtPointer\tcall_data UNUSED)\n{\n    gui_menu_cb((vimmenu_T *)client_data);\n}\n\n#endif // FEAT_MENU\n\n\n\n/*\n * Function called when window closed.\tWorks like \":qa\".\n * Should put up a requester!\n */\n    static void\ngui_x11_wm_protocol_handler(\n    Widget\tw UNUSED,\n    XtPointer\tclient_data UNUSED,\n    XEvent\t*event,\n    Boolean\t*dum UNUSED)\n{\n    /*\n     * Only deal with Client messages.\n     */\n    if (event->type != ClientMessage)\n\treturn;\n\n    /*\n     * The WM_SAVE_YOURSELF event arrives when the window manager wants to\n     * exit.  That can be cancelled though, thus Vim shouldn't exit here.\n     * Just sync our swap files.\n     */\n    if ((Atom)((XClientMessageEvent *)event)->data.l[0] ==\n\t\t\t\t\t\t  wm_atoms[SAVE_YOURSELF_IDX])\n    {\n\tout_flush();\n\tml_sync_all(FALSE, FALSE);\t// preserve all swap files\n\n\t// Set the window's WM_COMMAND property, to let the window manager\n\t// know we are done saving ourselves.  We don't want to be restarted,\n\t// thus set argv to NULL.\n\tXSetCommand(gui.dpy, XtWindow(vimShell), NULL, 0);\n\treturn;\n    }\n\n    if ((Atom)((XClientMessageEvent *)event)->data.l[0] !=\n\t\t\t\t\t\t  wm_atoms[DELETE_WINDOW_IDX])\n\treturn;\n\n    gui_shell_closed();\n}\n\n#ifdef FEAT_CLIENTSERVER\n/*\n * Function called when property changed. Check for incoming commands\n */\n    static void\ngui_x11_send_event_handler(\n    Widget\tw UNUSED,\n    XtPointer\tclient_data UNUSED,\n    XEvent\t*event,\n    Boolean\t*dum UNUSED)\n{\n    XPropertyEvent *e = (XPropertyEvent *) event;\n\n    if (e->type == PropertyNotify && e->window == commWindow\n\t    && e->atom == commProperty &&  e->state == PropertyNewValue)\n\tserverEventProc(gui.dpy, event, 0);\n}\n#endif\n\n/*\n * Cursor blink functions.\n *\n * This is a simple state machine:\n * BLINK_NONE\tnot blinking at all\n * BLINK_OFF\tblinking, cursor is not shown\n * BLINK_ON\tblinking, cursor is shown\n */\n\n#define BLINK_NONE  0\n#define BLINK_OFF   1\n#define BLINK_ON    2\n\nstatic int\t\tblink_state = BLINK_NONE;\nstatic long_u\t\tblink_waittime = 700;\nstatic long_u\t\tblink_ontime = 400;\nstatic long_u\t\tblink_offtime = 250;\nstatic XtIntervalId\tblink_timer = (XtIntervalId)0;\n\n    int\ngui_mch_is_blinking(void)\n{\n    return blink_state != BLINK_NONE;\n}\n\n    int\ngui_mch_is_blink_off(void)\n{\n    return blink_state == BLINK_OFF;\n}\n\n    void\ngui_mch_set_blinking(long waittime, long on, long off)\n{\n    blink_waittime = waittime;\n    blink_ontime = on;\n    blink_offtime = off;\n}\n\n/*\n * Stop the cursor blinking.  Show the cursor if it wasn't shown.\n */\n    void\ngui_mch_stop_blink(int may_call_gui_update_cursor)\n{\n    if (blink_timer != (XtIntervalId)0)\n    {\n\tXtRemoveTimeOut(blink_timer);\n\tblink_timer = (XtIntervalId)0;\n    }\n    if (blink_state == BLINK_OFF && may_call_gui_update_cursor)\n\tgui_update_cursor(TRUE, FALSE);\n    blink_state = BLINK_NONE;\n}\n\n    static void\ngui_x11_blink_cb(\n    XtPointer\t    timed_out UNUSED,\n    XtIntervalId    *interval_id UNUSED)\n{\n    if (blink_state == BLINK_ON)\n    {\n\tgui_undraw_cursor();\n\tblink_state = BLINK_OFF;\n\tblink_timer = XtAppAddTimeOut(app_context, blink_offtime,\n\t\t\t\t\t\t      gui_x11_blink_cb, NULL);\n    }\n    else\n    {\n\tgui_update_cursor(TRUE, FALSE);\n\tblink_state = BLINK_ON;\n\tblink_timer = XtAppAddTimeOut(app_context, blink_ontime,\n\t\t\t\t\t\t      gui_x11_blink_cb, NULL);\n    }\n}\n\n/*\n * Start the cursor blinking.  If it was already blinking, this restarts the\n * waiting time and shows the cursor.\n */\n    void\ngui_mch_start_blink(void)\n{\n    if (blink_timer != (XtIntervalId)0)\n\tXtRemoveTimeOut(blink_timer);\n    // Only switch blinking on if none of the times is zero\n    if (blink_waittime && blink_ontime && blink_offtime && gui.in_focus)\n    {\n\tblink_timer = XtAppAddTimeOut(app_context, blink_waittime,\n\t\t\t\t\t\t      gui_x11_blink_cb, NULL);\n\tblink_state = BLINK_ON;\n\tgui_update_cursor(TRUE, FALSE);\n    }\n}\n\n/*\n * Return the RGB value of a pixel as a long.\n */\n    guicolor_T\ngui_mch_get_rgb(guicolor_T pixel)\n{\n    XColor\txc;\n    Colormap\tcolormap;\n\n    colormap = DefaultColormap(gui.dpy, XDefaultScreen(gui.dpy));\n    xc.pixel = pixel;\n    XQueryColor(gui.dpy, colormap, &xc);\n\n    return (guicolor_T)(((xc.red & 0xff00) << 8) + (xc.green & 0xff00)\n\t\t\t\t\t\t   + ((unsigned)xc.blue >> 8));\n}\n\n/*\n * Add the callback functions.\n */\n    void\ngui_x11_callbacks(Widget textArea, Widget vimForm)\n{\n    XtAddEventHandler(textArea, VisibilityChangeMask, FALSE,\n\tgui_x11_visibility_cb, (XtPointer)0);\n\n    XtAddEventHandler(textArea, ExposureMask, FALSE, gui_x11_expose_cb,\n\t(XtPointer)0);\n\n    XtAddEventHandler(vimShell, StructureNotifyMask, FALSE,\n\tgui_x11_resize_window_cb, (XtPointer)0);\n\n    XtAddEventHandler(vimShell, FocusChangeMask, FALSE, gui_x11_focus_change_cb,\n\t(XtPointer)0);\n    /*\n     * Only install these enter/leave callbacks when 'p' in 'guioptions'.\n     * Only needed for some window managers.\n     */\n    if (vim_strchr(p_go, GO_POINTER) != NULL)\n    {\n\tXtAddEventHandler(vimShell, LeaveWindowMask, FALSE, gui_x11_leave_cb,\n\t    (XtPointer)0);\n\tXtAddEventHandler(textArea, LeaveWindowMask, FALSE, gui_x11_leave_cb,\n\t    (XtPointer)0);\n\tXtAddEventHandler(textArea, EnterWindowMask, FALSE, gui_x11_enter_cb,\n\t    (XtPointer)0);\n\tXtAddEventHandler(vimShell, EnterWindowMask, FALSE, gui_x11_enter_cb,\n\t    (XtPointer)0);\n    }\n\n    XtAddEventHandler(vimForm, KeyPressMask, FALSE, gui_x11_key_hit_cb,\n\t(XtPointer)0);\n    XtAddEventHandler(textArea, KeyPressMask, FALSE, gui_x11_key_hit_cb,\n\t(XtPointer)0);\n\n    // get pointer moved events from scrollbar, needed for 'mousefocus'\n    XtAddEventHandler(vimForm, PointerMotionMask,\n\tFALSE, gui_x11_mouse_cb, (XtPointer)1);\n    XtAddEventHandler(textArea, ButtonPressMask | ButtonReleaseMask |\n\t\t\t\t\t ButtonMotionMask | PointerMotionMask,\n\tFALSE, gui_x11_mouse_cb, (XtPointer)0);\n}\n\n/*\n * Get current mouse coordinates in text window.\n */\n    void\ngui_mch_getmouse(int *x, int *y)\n{\n    int\t\trootx, rooty, winx, winy;\n    Window\troot, child;\n    unsigned int mask;\n\n    if (gui.wid && XQueryPointer(gui.dpy, gui.wid, &root, &child,\n\t\t\t\t\t &rootx, &rooty, &winx, &winy, &mask)) {\n\t*x = winx;\n\t*y = winy;\n    } else {\n\t*x = -1;\n\t*y = -1;\n    }\n}\n\n    void\ngui_mch_setmouse(int x, int y)\n{\n    if (gui.wid)\n\tXWarpPointer(gui.dpy, (Window)0, gui.wid, 0, 0, 0, 0, x, y);\n}\n\n#if (defined(FEAT_GUI_MOTIF) && defined(FEAT_MENU)) || defined(PROTO)\n    XButtonPressedEvent *\ngui_x11_get_last_mouse_event(void)\n{\n    return &last_mouse_event;\n}\n#endif\n\n#if defined(FEAT_SIGN_ICONS) || defined(PROTO)\n\n// Signs are currently always 2 chars wide.  Hopefully the font is big enough\n// to provide room for the bitmap!\n# define SIGN_WIDTH (gui.char_width * 2)\n\n    void\ngui_mch_drawsign(int row, int col, int typenr)\n{\n    XImage\t*sign;\n\n    if (gui.in_use && (sign = (XImage *)sign_get_image(typenr)) != NULL)\n    {\n\tXClearArea(gui.dpy, gui.wid, TEXT_X(col), TEXT_Y(row) - sign->height,\n\t\tSIGN_WIDTH, gui.char_height, FALSE);\n\tXPutImage(gui.dpy, gui.wid, gui.text_gc, sign, 0, 0,\n\t\tTEXT_X(col) + (SIGN_WIDTH - sign->width) / 2,\n\t\tTEXT_Y(row) - sign->height,\n\t\tsign->width, sign->height);\n    }\n}\n\n    void *\ngui_mch_register_sign(char_u *signfile)\n{\n    XpmAttributes   attrs;\n    XImage\t    *sign = NULL;\n    int\t\t    status;\n\n    /*\n     * Setup the color substitution table.\n     */\n    if (signfile[0] != NUL && signfile[0] != '-')\n    {\n\tXpmColorSymbol color[5] =\n\t{\n\t    {\"none\", NULL, 0},\n\t    {\"iconColor1\", NULL, 0},\n\t    {\"bottomShadowColor\", NULL, 0},\n\t    {\"topShadowColor\", NULL, 0},\n\t    {\"selectColor\", NULL, 0}\n\t};\n\tattrs.valuemask = XpmColorSymbols;\n\tattrs.numsymbols = 2;\n\tattrs.colorsymbols = color;\n\tattrs.colorsymbols[0].pixel = gui.back_pixel;\n\tattrs.colorsymbols[1].pixel = gui.norm_pixel;\n\tstatus = XpmReadFileToImage(gui.dpy, (char *)signfile,\n\t\t\t\t\t\t\t &sign, NULL, &attrs);\n\tif (status == 0)\n\t{\n\t    // Sign width is fixed at two columns now.\n\t    // if (sign->width > gui.sign_width)\n\t    //     gui.sign_width = sign->width + 8;\n\t}\n\telse\n\t    emsg(_(e_couldnt_read_in_sign_data));\n    }\n\n    return (void *)sign;\n}\n\n    void\ngui_mch_destroy_sign(void *sign)\n{\n    XDestroyImage((XImage*)sign);\n}\n#endif\n\n\n#ifdef FEAT_MOUSESHAPE\n// The last set mouse pointer shape is remembered, to be used when it goes\n// from hidden to not hidden.\nstatic int last_shape = 0;\n#endif\n\n/*\n * Use the blank mouse pointer or not.\n */\n    void\ngui_mch_mousehide(\n    int\t\thide)\t// TRUE = use blank ptr, FALSE = use parent ptr\n{\n    if (gui.pointer_hidden != hide)\n    {\n\tgui.pointer_hidden = hide;\n\tif (hide)\n\t    XDefineCursor(gui.dpy, gui.wid, gui.blank_pointer);\n\telse\n#ifdef FEAT_MOUSESHAPE\n\t    mch_set_mouse_shape(last_shape);\n#else\n\t    XUndefineCursor(gui.dpy, gui.wid);\n#endif\n    }\n}\n\n#if defined(FEAT_MOUSESHAPE) || defined(PROTO)\n\n// Table for shape IDs.  Keep in sync with the mshape_names[] table in\n// misc2.c!\nstatic int mshape_ids[] =\n{\n    XC_left_ptr,\t\t// arrow\n    0,\t\t\t\t// blank\n    XC_xterm,\t\t\t// beam\n    XC_sb_v_double_arrow,\t// updown\n    XC_sizing,\t\t\t// udsizing\n    XC_sb_h_double_arrow,\t// leftright\n    XC_sizing,\t\t\t// lrsizing\n    XC_watch,\t\t\t// busy\n    XC_X_cursor,\t\t// no\n    XC_crosshair,\t\t// crosshair\n    XC_hand1,\t\t\t// hand1\n    XC_hand2,\t\t\t// hand2\n    XC_pencil,\t\t\t// pencil\n    XC_question_arrow,\t\t// question\n    XC_right_ptr,\t\t// right-arrow\n    XC_center_ptr,\t\t// up-arrow\n    XC_left_ptr\t\t\t// last one\n};\n\n    void\nmch_set_mouse_shape(int shape)\n{\n    int\t    id;\n\n    if (!gui.in_use)\n\treturn;\n\n    if (shape == MSHAPE_HIDE || gui.pointer_hidden)\n\tXDefineCursor(gui.dpy, gui.wid, gui.blank_pointer);\n    else\n    {\n\tif (shape >= MSHAPE_NUMBERED)\n\t{\n\t    id = shape - MSHAPE_NUMBERED;\n\t    if (id >= XC_num_glyphs)\n\t\tid = XC_left_ptr;\n\t    else\n\t\tid &= ~1;\t// they are always even (why?)\n\t}\n\telse\n\t    id = mshape_ids[shape];\n\n\tXDefineCursor(gui.dpy, gui.wid, XCreateFontCursor(gui.dpy, id));\n    }\n    if (shape != MSHAPE_HIDE)\n\tlast_shape = shape;\n}\n#endif\n\n#if (defined(FEAT_TOOLBAR) && defined(FEAT_BEVAL_GUI)) || defined(PROTO)\n/*\n * Set the balloon-eval used for the tooltip of a toolbar menu item.\n * The check for a non-toolbar item was added, because there is a crash when\n * passing a normal menu item here.  Can't explain that, but better avoid it.\n */\n    void\ngui_mch_menu_set_tip(vimmenu_T *menu)\n{\n    if (menu->id != NULL && menu->parent != NULL\n\t\t\t\t       && menu_is_toolbar(menu->parent->name))\n    {\n\t// Always destroy and create the balloon, in case the string was\n\t// changed.\n\tif (menu->tip != NULL)\n\t{\n\t    gui_mch_destroy_beval_area(menu->tip);\n\t    menu->tip = NULL;\n\t}\n\tif (menu->strings[MENU_INDEX_TIP] != NULL)\n\t    menu->tip = gui_mch_create_beval_area(\n\t\t    menu->id,\n\t\t    menu->strings[MENU_INDEX_TIP],\n\t\t    NULL,\n\t\t    NULL);\n    }\n}\n#endif\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\t\t\t\tGUI/Motif support by Robert Webb\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n/*\n * Code for the Motif GUI.\n * Not used for GTK.\n */\n\n#include \"vim.h\"\n\n#include <X11/keysym.h>\n#include <X11/Xatom.h>\n#include <X11/StringDefs.h>\n#include <X11/Intrinsic.h>\n#include <X11/Shell.h>\n#include <X11/cursorfont.h>\n\n/*\n * XpmP.h is preferred, because it makes the signs drawn with a transparent\n * background instead of black.\n */\n#if defined(HAVE_XM_XPMP_H) && defined(FEAT_GUI_MOTIF) \\\n\t&& !defined(HAVE_X11_XPM_H)\n# include <Xm/XpmP.h>\n#else\n# ifdef HAVE_X11_XPM_H\n#  ifdef VMS\n#   include <xpm.h>\n#  else\n#   include <X11/xpm.h>\n#  endif\n# endif\n#endif\n\n#ifdef FEAT_XFONTSET\n# ifdef X_LOCALE\n#  include <X11/Xlocale.h>\n# else\n#  include <locale.h>\n# endif\n#endif\n\n#ifdef HAVE_X11_SUNKEYSYM_H\n# include <X11/Sunkeysym.h>\n#endif\n\n#ifdef HAVE_X11_XMU_EDITRES_H\n# include <X11/Xmu/Editres.h>\n#endif\n\n#define VIM_NAME\t\"vim\"\n#define VIM_CLASS\t\"Vim\"\n\n// Default resource values\n#define DFLT_FONT\t\t\"7x13\"\n#ifdef FONTSET_ALWAYS\n# define DFLT_MENU_FONT\t\tXtDefaultFontSet\n#else\n# define DFLT_MENU_FONT\t\tXtDefaultFont\n#endif\n#define DFLT_TOOLTIP_FONT\tXtDefaultFontSet\n\n// use the default (CDE) colors\n#define DFLT_MENU_BG_COLOR\t\"\"\n#define DFLT_MENU_FG_COLOR\t\"\"\n#define DFLT_SCROLL_BG_COLOR\t\"\"\n#define DFLT_SCROLL_FG_COLOR\t\"\"\n#define DFLT_TOOLTIP_BG_COLOR\t\"#ffff91\"\n#define DFLT_TOOLTIP_FG_COLOR\t\"#000000\"\n\nWidget vimShell = (Widget)0;\n\nstatic Atom   wm_atoms[2];\t// Window Manager Atoms\n#define DELETE_WINDOW_IDX 0\t// index in wm_atoms[] for WM_DELETE_WINDOW\n#define SAVE_YOURSELF_IDX 1\t// index in wm_atoms[] for WM_SAVE_YOURSELF\n\n#ifdef FEAT_XFONTSET\n/*\n * We either draw with a fontset (when current_fontset != NULL) or with a\n * normal font (current_fontset == NULL, use gui.text_gc and gui.back_gc).\n */\nstatic XFontSet current_fontset = NULL;\n# if !defined(XDrawString)\n#  define XDrawString(dpy, win, gc, x, y, str, n) \\\n\tdo \\\n\t{ \\\n\t    if (current_fontset != NULL) \\\n\t\tXmbDrawString(dpy, win, current_fontset, gc, x, y, str, n); \\\n\t    else \\\n\t\tXDrawString(dpy, win, gc, x, y, str, n); \\\n\t} while (0)\n# endif\n# if !defined(XDrawString16)\n#  define XDrawString16(dpy, win, gc, x, y, str, n) \\\n\tdo \\\n\t{ \\\n\t    if (current_fontset != NULL) \\\n\t\tXwcDrawString(dpy, win, current_fontset, gc, x, y, (wchar_t *)str, n); \\\n\t    else \\\n\t\tXDrawString16(dpy, win, gc, x, y, (XChar2b *)str, n); \\\n\t} while (0)\n# endif\n# if !defined(XDrawImageString16)\n#  define XDrawImageString16(dpy, win, gc, x, y, str, n) \\\n\tdo \\\n\t{ \\\n\t    if (current_fontset != NULL) \\\n\t\tXwcDrawImageString(dpy, win, current_fontset, gc, x, y, (wchar_t *)str, n); \\\n\t    else \\\n\t\tXDrawImageString16(dpy, win, gc, x, y, (XChar2b *)str, n); \\\n\t} while (0)\n# endif\nstatic int check_fontset_sanity(XFontSet fs);\nstatic int fontset_width(XFontSet fs);\nstatic int fontset_ascent(XFontSet fs);\n#endif\n\nstatic guicolor_T\tprev_fg_color = INVALCOLOR;\nstatic guicolor_T\tprev_bg_color = INVALCOLOR;\nstatic guicolor_T\tprev_sp_color = INVALCOLOR;\n\n#if defined(FEAT_GUI_MOTIF) && defined(FEAT_MENU)\nstatic XButtonPressedEvent last_mouse_event;\n#endif\n\nstatic void gui_x11_check_copy_area(void);\n#ifdef FEAT_CLIENTSERVER\nstatic void gui_x11_send_event_handler(Widget, XtPointer, XEvent *, Boolean *);\n#endif\nstatic void gui_x11_wm_protocol_handler(Widget, XtPointer, XEvent *, Boolean *);\nstatic Cursor gui_x11_create_blank_mouse(void);\n\n\n/*\n * Keycodes recognized by vim.\n * NOTE: when changing this, the table in gui_gtk_x11.c probably needs the\n * same change!\n */\nstatic struct specialkey\n{\n    KeySym  key_sym;\n    char_u  vim_code0;\n    char_u  vim_code1;\n} special_keys[] =\n{\n    {XK_Up,\t\t'k', 'u'},\n    {XK_Down,\t\t'k', 'd'},\n    {XK_Left,\t\t'k', 'l'},\n    {XK_Right,\t\t'k', 'r'},\n\n    {XK_F1,\t\t'k', '1'},\n    {XK_F2,\t\t'k', '2'},\n    {XK_F3,\t\t'k', '3'},\n    {XK_F4,\t\t'k', '4'},\n    {XK_F5,\t\t'k', '5'},\n    {XK_F6,\t\t'k', '6'},\n    {XK_F7,\t\t'k', '7'},\n    {XK_F8,\t\t'k', '8'},\n    {XK_F9,\t\t'k', '9'},\n    {XK_F10,\t\t'k', ';'},\n\n    {XK_F11,\t\t'F', '1'},\n    {XK_F12,\t\t'F', '2'},\n    {XK_F13,\t\t'F', '3'},\n    {XK_F14,\t\t'F', '4'},\n    {XK_F15,\t\t'F', '5'},\n    {XK_F16,\t\t'F', '6'},\n    {XK_F17,\t\t'F', '7'},\n    {XK_F18,\t\t'F', '8'},\n    {XK_F19,\t\t'F', '9'},\n    {XK_F20,\t\t'F', 'A'},\n\n    {XK_F21,\t\t'F', 'B'},\n    {XK_F22,\t\t'F', 'C'},\n    {XK_F23,\t\t'F', 'D'},\n    {XK_F24,\t\t'F', 'E'},\n    {XK_F25,\t\t'F', 'F'},\n    {XK_F26,\t\t'F', 'G'},\n    {XK_F27,\t\t'F', 'H'},\n    {XK_F28,\t\t'F', 'I'},\n    {XK_F29,\t\t'F', 'J'},\n    {XK_F30,\t\t'F', 'K'},\n\n    {XK_F31,\t\t'F', 'L'},\n    {XK_F32,\t\t'F', 'M'},\n    {XK_F33,\t\t'F', 'N'},\n    {XK_F34,\t\t'F', 'O'},\n    {XK_F35,\t\t'F', 'P'},\t// keysymdef.h defines up to F35\n#ifdef SunXK_F36\n    {SunXK_F36,\t\t'F', 'Q'},\n    {SunXK_F37,\t\t'F', 'R'},\n#endif\n\n    {XK_Help,\t\t'%', '1'},\n    {XK_Undo,\t\t'&', '8'},\n    {XK_BackSpace,\t'k', 'b'},\n    {XK_Insert,\t\t'k', 'I'},\n    {XK_Delete,\t\t'k', 'D'},\n    {XK_Home,\t\t'k', 'h'},\n    {XK_End,\t\t'@', '7'},\n    {XK_Prior,\t\t'k', 'P'},\n    {XK_Next,\t\t'k', 'N'},\n    {XK_Print,\t\t'%', '9'},\n\n    // Keypad keys:\n#ifdef XK_KP_Left\n    {XK_KP_Left,\t'k', 'l'},\n    {XK_KP_Right,\t'k', 'r'},\n    {XK_KP_Up,\t\t'k', 'u'},\n    {XK_KP_Down,\t'k', 'd'},\n    {XK_KP_Insert,\tKS_EXTRA, (char_u)KE_KINS},\n    {XK_KP_Delete,\tKS_EXTRA, (char_u)KE_KDEL},\n    {XK_KP_Home,\t'K', '1'},\n    {XK_KP_End,\t\t'K', '4'},\n    {XK_KP_Prior,\t'K', '3'},\n    {XK_KP_Next,\t'K', '5'},\n\n    {XK_KP_Add,\t\t'K', '6'},\n    {XK_KP_Subtract,\t'K', '7'},\n    {XK_KP_Divide,\t'K', '8'},\n    {XK_KP_Multiply,\t'K', '9'},\n    {XK_KP_Enter,\t'K', 'A'},\n    {XK_KP_Decimal,\t'K', 'B'},\n\n    {XK_KP_0,\t\t'K', 'C'},\n    {XK_KP_1,\t\t'K', 'D'},\n    {XK_KP_2,\t\t'K', 'E'},\n    {XK_KP_3,\t\t'K', 'F'},\n    {XK_KP_4,\t\t'K', 'G'},\n    {XK_KP_5,\t\t'K', 'H'},\n    {XK_KP_6,\t\t'K', 'I'},\n    {XK_KP_7,\t\t'K', 'J'},\n    {XK_KP_8,\t\t'K', 'K'},\n    {XK_KP_9,\t\t'K', 'L'},\n#endif\n\n    // End of list marker:\n    {(KeySym)0,\t    0, 0}\n};\n\n#define XtNboldFont\t\t\"boldFont\"\n#define XtCBoldFont\t\t\"BoldFont\"\n#define XtNitalicFont\t\t\"italicFont\"\n#define XtCItalicFont\t\t\"ItalicFont\"\n#define XtNboldItalicFont\t\"boldItalicFont\"\n#define XtCBoldItalicFont\t\"BoldItalicFont\"\n#define XtNscrollbarWidth\t\"scrollbarWidth\"\n#define XtCScrollbarWidth\t\"ScrollbarWidth\"\n#define XtNmenuHeight\t\t\"menuHeight\"\n#define XtCMenuHeight\t\t\"MenuHeight\"\n#define XtNmenuFont\t\t\"menuFont\"\n#define XtCMenuFont\t\t\"MenuFont\"\n#define XtNmenuFontSet\t\t\"menuFontSet\"\n#define XtCMenuFontSet\t\t\"MenuFontSet\"\n\n\n// Resources for setting the foreground and background colors of menus\n#define XtNmenuBackground\t\"menuBackground\"\n#define XtCMenuBackground\t\"MenuBackground\"\n#define XtNmenuForeground\t\"menuForeground\"\n#define XtCMenuForeground\t\"MenuForeground\"\n\n// Resources for setting the foreground and background colors of scrollbars\n#define XtNscrollBackground\t\"scrollBackground\"\n#define XtCScrollBackground\t\"ScrollBackground\"\n#define XtNscrollForeground\t\"scrollForeground\"\n#define XtCScrollForeground\t\"ScrollForeground\"\n\n// Resources for setting the foreground and background colors of tooltip\n#define XtNtooltipBackground\t\"tooltipBackground\"\n#define XtCTooltipBackground\t\"TooltipBackground\"\n#define XtNtooltipForeground\t\"tooltipForeground\"\n#define XtCTooltipForeground\t\"TooltipForeground\"\n#define XtNtooltipFont\t\t\"tooltipFont\"\n#define XtCTooltipFont\t\t\"TooltipFont\"\n\n/*\n * X Resources:\n */\nstatic XtResource vim_resources[] =\n{\n    {\n\tXtNforeground,\n\tXtCForeground,\n\tXtRPixel,\n\tsizeof(Pixel),\n\tXtOffsetOf(gui_T, def_norm_pixel),\n\tXtRString,\n\tXtDefaultForeground\n    },\n    {\n\tXtNbackground,\n\tXtCBackground,\n\tXtRPixel,\n\tsizeof(Pixel),\n\tXtOffsetOf(gui_T, def_back_pixel),\n\tXtRString,\n\tXtDefaultBackground\n    },\n    {\n\tXtNfont,\n\tXtCFont,\n\tXtRString,\n\tsizeof(String *),\n\tXtOffsetOf(gui_T, rsrc_font_name),\n\tXtRImmediate,\n\tXtDefaultFont\n    },\n    {\n\tXtNboldFont,\n\tXtCBoldFont,\n\tXtRString,\n\tsizeof(String *),\n\tXtOffsetOf(gui_T, rsrc_bold_font_name),\n\tXtRImmediate,\n\t\"\"\n    },\n    {\n\tXtNitalicFont,\n\tXtCItalicFont,\n\tXtRString,\n\tsizeof(String *),\n\tXtOffsetOf(gui_T, rsrc_ital_font_name),\n\tXtRImmediate,\n\t\"\"\n    },\n    {\n\tXtNboldItalicFont,\n\tXtCBoldItalicFont,\n\tXtRString,\n\tsizeof(String *),\n\tXtOffsetOf(gui_T, rsrc_boldital_font_name),\n\tXtRImmediate,\n\t\"\"\n    },\n    {\n\tXtNgeometry,\n\tXtCGeometry,\n\tXtRString,\n\tsizeof(String *),\n\tXtOffsetOf(gui_T, geom),\n\tXtRImmediate,\n\t\"\"\n    },\n    {\n\tXtNreverseVideo,\n\tXtCReverseVideo,\n\tXtRBool,\n\tsizeof(Bool),\n\tXtOffsetOf(gui_T, rsrc_rev_video),\n\tXtRImmediate,\n\t(XtPointer)False\n    },\n    {\n\tXtNborderWidth,\n\tXtCBorderWidth,\n\tXtRInt,\n\tsizeof(int),\n\tXtOffsetOf(gui_T, border_width),\n\tXtRImmediate,\n\t(XtPointer)2\n    },\n    {\n\tXtNscrollbarWidth,\n\tXtCScrollbarWidth,\n\tXtRInt,\n\tsizeof(int),\n\tXtOffsetOf(gui_T, scrollbar_width),\n\tXtRImmediate,\n\t(XtPointer)SB_DEFAULT_WIDTH\n    },\n#ifdef FEAT_MENU\n    {\n# ifdef FONTSET_ALWAYS\n\tXtNmenuFontSet,\n\tXtCMenuFontSet,\n#else\n\tXtNmenuFont,\n\tXtCMenuFont,\n#endif\n\tXtRString,\n\tsizeof(char *),\n\tXtOffsetOf(gui_T, rsrc_menu_font_name),\n\tXtRString,\n\tDFLT_MENU_FONT\n    },\n#endif\n    {\n\tXtNmenuForeground,\n\tXtCMenuForeground,\n\tXtRString,\n\tsizeof(char *),\n\tXtOffsetOf(gui_T, rsrc_menu_fg_name),\n\tXtRString,\n\tDFLT_MENU_FG_COLOR\n    },\n    {\n\tXtNmenuBackground,\n\tXtCMenuBackground,\n\tXtRString,\n\tsizeof(char *),\n\tXtOffsetOf(gui_T, rsrc_menu_bg_name),\n\tXtRString,\n\tDFLT_MENU_BG_COLOR\n    },\n    {\n\tXtNscrollForeground,\n\tXtCScrollForeground,\n\tXtRString,\n\tsizeof(char *),\n\tXtOffsetOf(gui_T, rsrc_scroll_fg_name),\n\tXtRString,\n\tDFLT_SCROLL_FG_COLOR\n    },\n    {\n\tXtNscrollBackground,\n\tXtCScrollBackground,\n\tXtRString,\n\tsizeof(char *),\n\tXtOffsetOf(gui_T, rsrc_scroll_bg_name),\n\tXtRString,\n\tDFLT_SCROLL_BG_COLOR\n    },\n#ifdef FEAT_BEVAL_GUI\n    {\n\tXtNtooltipForeground,\n\tXtCTooltipForeground,\n\tXtRString,\n\tsizeof(char *),\n\tXtOffsetOf(gui_T, rsrc_tooltip_fg_name),\n\tXtRString,\n\tDFLT_TOOLTIP_FG_COLOR\n    },\n    {\n\tXtNtooltipBackground,\n\tXtCTooltipBackground,\n\tXtRString,\n\tsizeof(char *),\n\tXtOffsetOf(gui_T, rsrc_tooltip_bg_name),\n\tXtRString,\n\tDFLT_TOOLTIP_BG_COLOR\n    },\n    {\n\tXtNtooltipFont,\n\tXtCTooltipFont,\n\tXtRString,\n\tsizeof(char *),\n\tXtOffsetOf(gui_T, rsrc_tooltip_font_name),\n\tXtRString,\n\tDFLT_TOOLTIP_FONT\n    },\n    // This one may not be really needed?\n    {\n\t\"balloonEvalFontSet\",\n\tXtCFontSet,\n\tXtRFontSet,\n\tsizeof(XFontSet),\n\tXtOffsetOf(gui_T, tooltip_fontset),\n\tXtRImmediate,\n\t(XtPointer)NOFONTSET\n    },\n#endif // FEAT_BEVAL_GUI\n#ifdef FEAT_XIM\n    {\n\t\"preeditType\",\n\t\"PreeditType\",\n\tXtRString,\n\tsizeof(char*),\n\tXtOffsetOf(gui_T, rsrc_preedit_type_name),\n\tXtRString,\n\t(XtPointer)\"OverTheSpot,OffTheSpot,Root\"\n    },\n    {\n\t\"inputMethod\",\n\t\"InputMethod\",\n\tXtRString,\n\tsizeof(char*),\n\tXtOffsetOf(gui_T, rsrc_input_method),\n\tXtRString,\n\tNULL\n    },\n#endif // FEAT_XIM\n};\n\n/*\n * This table holds all the X GUI command line options allowed.  This includes\n * the standard ones so that we can skip them when vim is started without the\n * GUI (but the GUI might start up later).\n * When changing this, also update doc/vim_gui.txt and the usage message!!!\n */\nstatic XrmOptionDescRec cmdline_options[] =\n{\n    // We handle these options ourselves\n    {\"-bg\",\t\t\".background\",\t    XrmoptionSepArg,\tNULL},\n    {\"-background\",\t\".background\",\t    XrmoptionSepArg,\tNULL},\n    {\"-fg\",\t\t\".foreground\",\t    XrmoptionSepArg,\tNULL},\n    {\"-foreground\",\t\".foreground\",\t    XrmoptionSepArg,\tNULL},\n    {\"-fn\",\t\t\".font\",\t    XrmoptionSepArg,\tNULL},\n    {\"-font\",\t\t\".font\",\t    XrmoptionSepArg,\tNULL},\n    {\"-boldfont\",\t\".boldFont\",\t    XrmoptionSepArg,\tNULL},\n    {\"-italicfont\",\t\".italicFont\",\t    XrmoptionSepArg,\tNULL},\n    {\"-geom\",\t\t\".geometry\",\t    XrmoptionSepArg,\tNULL},\n    {\"-geometry\",\t\".geometry\",\t    XrmoptionSepArg,\tNULL},\n    {\"-reverse\",\t\"*reverseVideo\",    XrmoptionNoArg,\t\"True\"},\n    {\"-rv\",\t\t\"*reverseVideo\",    XrmoptionNoArg,\t\"True\"},\n    {\"+reverse\",\t\"*reverseVideo\",    XrmoptionNoArg,\t\"False\"},\n    {\"+rv\",\t\t\"*reverseVideo\",    XrmoptionNoArg,\t\"False\"},\n    {\"-display\",\t\".display\",\t    XrmoptionSepArg,\tNULL},\n    {\"-iconic\",\t\t\".iconic\",\t    XrmoptionNoArg,\t\"True\"},\n    {\"-name\",\t\t\".name\",\t    XrmoptionSepArg,\tNULL},\n    {\"-bw\",\t\t\".borderWidth\",\t    XrmoptionSepArg,\tNULL},\n    {\"-borderwidth\",\t\".borderWidth\",\t    XrmoptionSepArg,\tNULL},\n    {\"-sw\",\t\t\".scrollbarWidth\",  XrmoptionSepArg,\tNULL},\n    {\"-scrollbarwidth\",\t\".scrollbarWidth\",  XrmoptionSepArg,\tNULL},\n    {\"-mh\",\t\t\".menuHeight\",\t    XrmoptionSepArg,\tNULL},\n    {\"-menuheight\",\t\".menuHeight\",\t    XrmoptionSepArg,\tNULL},\n#ifdef FONTSET_ALWAYS\n    {\"-mf\",\t\t\".menuFontSet\",\t    XrmoptionSepArg,\tNULL},\n    {\"-menufont\",\t\".menuFontSet\",\t    XrmoptionSepArg,\tNULL},\n    {\"-menufontset\",\t\".menuFontSet\",\t    XrmoptionSepArg,\tNULL},\n#else\n    {\"-mf\",\t\t\".menuFont\",\t    XrmoptionSepArg,\tNULL},\n    {\"-menufont\",\t\".menuFont\",\t    XrmoptionSepArg,\tNULL},\n#endif\n    {\"-xrm\",\t\tNULL,\t\t    XrmoptionResArg,\tNULL}\n};\n\nstatic int gui_argc = 0;\nstatic char **gui_argv = NULL;\n\n/*\n * Call-back routines.\n */\n\n    static void\ngui_x11_timer_cb(\n    XtPointer\t    timed_out,\n    XtIntervalId    *interval_id UNUSED)\n{\n    *((int *)timed_out) = TRUE;\n}\n\n#ifdef FEAT_JOB_CHANNEL\n    static void\nchannel_poll_cb(\n    XtPointer\t    client_data,\n    XtIntervalId    *interval_id UNUSED)\n{\n    XtIntervalId    *channel_timer = (XtIntervalId *)client_data;\n\n    // Using an event handler for a channel that may be disconnected does\n    // not work, it hangs.  Instead poll for messages.\n    channel_handle_events(TRUE);\n    parse_queued_messages();\n\n    // repeat\n    *channel_timer = XtAppAddTimeOut(app_context, (long_u)20,\n\t\t\t\t\t\t channel_poll_cb, client_data);\n}\n#endif\n\n    static void\ngui_x11_visibility_cb(\n    Widget\tw UNUSED,\n    XtPointer\tdud UNUSED,\n    XEvent\t*event,\n    Boolean\t*dum UNUSED)\n{\n    if (event->type != VisibilityNotify)\n\treturn;\n\n    gui.visibility = event->xvisibility.state;\n\n    /*\n     * When we do an XCopyArea(), and the window is partially obscured, we want\n     * to receive an event to tell us whether it worked or not.\n     */\n    XSetGraphicsExposures(gui.dpy, gui.text_gc,\n\t    gui.visibility != VisibilityUnobscured);\n\n    // This is needed for when redrawing is slow.\n    gui_mch_update();\n}\n\n    static void\ngui_x11_expose_cb(\n    Widget\tw UNUSED,\n    XtPointer\tdud UNUSED,\n    XEvent\t*event,\n    Boolean\t*dum UNUSED)\n{\n    XExposeEvent\t*gevent;\n    int\t\t\tnew_x;\n\n    if (event->type != Expose)\n\treturn;\n\n    out_flush();\t    // make sure all output has been processed\n\n    gevent = (XExposeEvent *)event;\n    gui_redraw(gevent->x, gevent->y, gevent->width, gevent->height);\n\n    new_x = FILL_X(0);\n\n    // Clear the border areas if needed\n    if (gevent->x < new_x)\n\tXClearArea(gui.dpy, gui.wid, 0, 0, new_x, 0, False);\n    if (gevent->y < FILL_Y(0))\n\tXClearArea(gui.dpy, gui.wid, 0, 0, 0, FILL_Y(0), False);\n    if (gevent->x > FILL_X(Columns))\n\tXClearArea(gui.dpy, gui.wid, FILL_X((int)Columns), 0, 0, 0, False);\n    if (gevent->y > FILL_Y(Rows))\n\tXClearArea(gui.dpy, gui.wid, 0, FILL_Y((int)Rows), 0, 0, False);\n\n    // This is needed for when redrawing is slow.\n    gui_mch_update();\n}\n\n#if (defined(FEAT_NETBEANS_INTG) && defined(FEAT_GUI_MOTIF)) || defined(PROTO)\n/*\n * This function fills in the XRectangle object with the current x,y\n * coordinates and height, width so that an XtVaSetValues to the same shell of\n * those resources will restore the window to its former position and\n * dimensions.\n *\n * Note: This function may fail, in which case the XRectangle will be\n * unchanged.  Be sure to have the XRectangle set with the proper values for a\n * failed condition prior to calling this function.\n */\n    static void\nshellRectangle(Widget shell, XRectangle *r)\n{\n    Window\t\trootw, shellw, child, parentw;\n    int\t\t\tabsx, absy;\n    XWindowAttributes\ta;\n    Window\t\t*children;\n    unsigned int\tchildrenCount;\n\n    shellw = XtWindow(shell);\n    if (shellw == 0)\n\treturn;\n    for (;;)\n    {\n\tXQueryTree(XtDisplay(shell), shellw, &rootw, &parentw,\n\t\t\t\t\t\t   &children, &childrenCount);\n\tXFree(children);\n\tif (parentw == rootw)\n\t    break;\n\tshellw = parentw;\n    }\n    XGetWindowAttributes(XtDisplay(shell), shellw, &a);\n    XTranslateCoordinates(XtDisplay(shell), shellw, a.root, 0, 0,\n\t\t\t\t\t\t\t&absx, &absy, &child);\n    r->x = absx;\n    r->y = absy;\n    XtVaGetValues(shell, XmNheight, &r->height, XmNwidth, &r->width, NULL);\n}\n#endif\n\n    static void\ngui_x11_resize_window_cb(\n    Widget\tw UNUSED,\n    XtPointer\tdud UNUSED,\n    XEvent\t*event,\n    Boolean\t*dum UNUSED)\n{\n    static int lastWidth, lastHeight;\n\n    if (event->type != ConfigureNotify)\n\treturn;\n\n    if (event->xconfigure.width != lastWidth\n\t    || event->xconfigure.height != lastHeight)\n    {\n\tlastWidth = event->xconfigure.width;\n\tlastHeight = event->xconfigure.height;\n\tgui_resize_shell(event->xconfigure.width, event->xconfigure.height\n#ifdef FEAT_XIM\n\t\t\t\t\t\t- xim_get_status_area_height()\n#endif\n\t\t     );\n    }\n#if defined(FEAT_NETBEANS_INTG) && defined(FEAT_GUI_MOTIF)\n    if (netbeans_active())\n    {\n\tXRectangle  rec;\n\n\tshellRectangle(w, &rec);\n\tnetbeans_frame_moved(rec.x, rec.y);\n    }\n#endif\n#ifdef FEAT_XIM\n    xim_set_preedit();\n#endif\n}\n\n    static void\ngui_x11_focus_change_cb(\n    Widget\tw UNUSED,\n    XtPointer\tdata UNUSED,\n    XEvent\t*event,\n    Boolean\t*dum UNUSED)\n{\n    gui_focus_change(event->type == FocusIn);\n}\n\n    static void\ngui_x11_enter_cb(\n    Widget\tw UNUSED,\n    XtPointer\tdata UNUSED,\n    XEvent\t*event UNUSED,\n    Boolean\t*dum UNUSED)\n{\n    gui_focus_change(TRUE);\n}\n\n    static void\ngui_x11_leave_cb(\n    Widget\tw UNUSED,\n    XtPointer\tdata UNUSED,\n    XEvent\t*event UNUSED,\n    Boolean\t*dum UNUSED)\n{\n    gui_focus_change(FALSE);\n}\n\n#if defined(X_HAVE_UTF8_STRING)\n# if X_HAVE_UTF8_STRING\n#  define USE_UTF8LOOKUP\n# endif\n#endif\n\n    void\ngui_x11_key_hit_cb(\n    Widget\tw UNUSED,\n    XtPointer\tdud UNUSED,\n    XEvent\t*event,\n    Boolean\t*dum UNUSED)\n{\n    XKeyPressedEvent\t*ev_press;\n#ifdef FEAT_XIM\n    char_u\t\tstring2[256];\n    char_u\t\tstring_shortbuf[256];\n    char_u\t\t*string = string_shortbuf;\n    Boolean\t\tstring_alloced = False;\n    Status\t\tstatus;\n#else\n    char_u\t\tstring[4], string2[3];\n#endif\n    KeySym\t\tkey_sym;\n    int\t\t\tlen;\n    int\t\t\ti;\n    int\t\t\tmodifiers;\n    int\t\t\tkey;\n\n    ev_press = (XKeyPressedEvent *)event;\n\n#ifdef FEAT_XIM\n    if (xic)\n    {\n# ifdef USE_UTF8LOOKUP\n\t// XFree86 4.0.2 or newer: Be able to get UTF-8 characters even when\n\t// the locale isn't utf-8.\n\tif (enc_utf8)\n\t    len = Xutf8LookupString(xic, ev_press, (char *)string,\n\t\t\t\t  sizeof(string_shortbuf), &key_sym, &status);\n\telse\n# endif\n\t    len = XmbLookupString(xic, ev_press, (char *)string,\n\t\t\t\t  sizeof(string_shortbuf), &key_sym, &status);\n\tif (status == XBufferOverflow)\n\t{\n\t    string = (char_u *)XtMalloc(len + 1);\n\t    string_alloced = True;\n# ifdef USE_UTF8LOOKUP\n\t    // XFree86 4.0.2 or newer: Be able to get UTF-8 characters even\n\t    // when the locale isn't utf-8.\n\t    if (enc_utf8)\n\t\tlen = Xutf8LookupString(xic, ev_press, (char *)string,\n\t\t\t\t\t\t      len, &key_sym, &status);\n\t    else\n# endif\n\t\tlen = XmbLookupString(xic, ev_press, (char *)string,\n\t\t\t\t\t\t      len, &key_sym, &status);\n\t}\n\tif (status == XLookupNone || status == XLookupChars)\n\t    key_sym = XK_VoidSymbol;\n\n\t// Do conversion from 'termencoding' to 'encoding'.  When using\n\t// Xutf8LookupString() it has already been done.\n\tif (len > 0 && input_conv.vc_type != CONV_NONE\n# ifdef USE_UTF8LOOKUP\n\t\t&& !enc_utf8\n# endif\n\t\t)\n\t{\n\t    int\t\tmaxlen = len * 4 + 40;\t// guessed\n\t    char_u\t*p = (char_u *)XtMalloc(maxlen);\n\n\t    mch_memmove(p, string, len);\n\t    if (string_alloced)\n\t\tXtFree((char *)string);\n\t    string = p;\n\t    string_alloced = True;\n\t    len = convert_input(p, len, maxlen);\n\t}\n\n\t// Translate CSI to K_CSI, otherwise it could be recognized as the\n\t// start of a special key.\n\tfor (i = 0; i < len; ++i)\n\t    if (string[i] == CSI)\n\t    {\n\t\tchar_u\t*p = (char_u *)XtMalloc(len + 3);\n\n\t\tmch_memmove(p, string, i + 1);\n\t\tp[i + 1] = KS_EXTRA;\n\t\tp[i + 2] = (int)KE_CSI;\n\t\tmch_memmove(p + i + 3, string + i + 1, len - i);\n\t\tif (string_alloced)\n\t\t    XtFree((char *)string);\n\t\tstring = p;\n\t\tstring_alloced = True;\n\t\ti += 2;\n\t\tlen += 2;\n\t    }\n    }\n    else\n#endif\n\tlen = XLookupString(ev_press, (char *)string, sizeof(string),\n\t\t&key_sym, NULL);\n\n#ifdef SunXK_F36\n    /*\n    * These keys have bogus lookup strings, and trapping them here is\n    * easier than trying to XRebindKeysym() on them with every possible\n    * combination of modifiers.\n    */\n    if (key_sym == SunXK_F36 || key_sym == SunXK_F37)\n\tlen = 0;\n#endif\n\n    if (key_sym == XK_space)\n\tstring[0] = ' ';\t// Otherwise Ctrl-Space doesn't work\n\n    /*\n     * Only on some machines ^_ requires Ctrl+Shift+minus.  For consistency,\n     * allow just Ctrl+minus too.\n     */\n    if (key_sym == XK_minus && (ev_press->state & ControlMask))\n\tstring[0] = Ctrl__;\n\n#ifdef XK_ISO_Left_Tab\n    // why do we get XK_ISO_Left_Tab instead of XK_Tab for shift-tab?\n    if (key_sym == XK_ISO_Left_Tab)\n    {\n\tkey_sym = XK_Tab;\n\tstring[0] = TAB;\n\tlen = 1;\n    }\n#endif\n\n    // We used to apply Alt/Meta to the key here (Mod1Mask), but that is now\n    // done later, the same as it happens for the terminal.  Hopefully that\n    // works for everybody...\n\n    if (len == 1 && string[0] == CSI)\n    {\n\tstring[1] = KS_EXTRA;\n\tstring[2] = (int)KE_CSI;\n\tlen = -3;\n    }\n\n    // Check for special keys.  Also do this when len == 1 (key has an ASCII\n    // value) to detect backspace, delete and keypad keys.\n    if (len == 0 || len == 1)\n    {\n\tfor (i = 0; special_keys[i].key_sym != (KeySym)0; i++)\n\t{\n\t    if (special_keys[i].key_sym == key_sym)\n\t    {\n\t\tstring[0] = CSI;\n\t\tstring[1] = special_keys[i].vim_code0;\n\t\tstring[2] = special_keys[i].vim_code1;\n\t\tlen = -3;\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    // Unrecognised key is ignored.\n    if (len == 0)\n\tgoto theend;\n\n    // Handle modifiers.\n    modifiers = 0;\n    if (ev_press->state & ShiftMask)\n\tmodifiers |= MOD_MASK_SHIFT;\n    if (ev_press->state & ControlMask)\n    {\n\tmodifiers |= MOD_MASK_CTRL;\n\tif (len == 1 && string[0] < 0x20)\n\t    // Use the character before applyng CTRL.\n\t    string[0] += 0x40;\n    }\n    if (ev_press->state & Mod1Mask)\n\tmodifiers |= MOD_MASK_ALT;\n    if (ev_press->state & Mod4Mask)\n\tmodifiers |= MOD_MASK_META;\n\n    /*\n     * For some keys a shift modifier is translated into another key\n     * code.\n     */\n    if (len == -3)\n\tkey = TO_SPECIAL(string[1], string[2]);\n    else\n    {\n\tstring[len] = NUL;\n\tkey = mb_ptr2char(string);\n    }\n    key = simplify_key(key, &modifiers);\n    if (key == CSI)\n\tkey = K_CSI;\n    if (IS_SPECIAL(key))\n    {\n\tstring[0] = CSI;\n\tstring[1] = K_SECOND(key);\n\tstring[2] = K_THIRD(key);\n\tlen = 3;\n    }\n    else\n    {\n\tlen = mb_char2bytes(key, string);\n\n\t// Some keys need adjustment when the Ctrl modifier is used.\n\tkey = may_adjust_key_for_ctrl(modifiers, key);\n\n\t// Remove the SHIFT modifier for keys where it's already included,\n\t// e.g., '(', '!' and '*'.\n\tmodifiers = may_remove_shift_modifier(modifiers, key);\n    }\n\n    if (modifiers != 0)\n    {\n\tstring2[0] = CSI;\n\tstring2[1] = KS_MODIFIER;\n\tstring2[2] = modifiers;\n\tadd_to_input_buf(string2, 3);\n    }\n\n    // Check if the key interrupts.\n    {\n\tint int_ch = check_for_interrupt(key, modifiers);\n\n\tif (int_ch != NUL)\n\t{\n\t    trash_input_buf();\n\t    string[0] = int_ch;\n\t    len = 1;\n\t}\n    }\n\n    add_to_input_buf(string, len);\n\n    /*\n     * blank out the pointer if necessary\n     */\n    if (p_mh)\n\tgui_mch_mousehide(TRUE);\n\n#if defined(FEAT_BEVAL_TIP)\n    {\n\tBalloonEval *be;\n\n\tif ((be = gui_mch_currently_showing_beval()) != NULL)\n\t    gui_mch_unpost_balloon(be);\n    }\n#endif\ntheend:\n    {}\t    // some compilers need a statement here\n#ifdef FEAT_XIM\n    if (string_alloced)\n\tXtFree((char *)string);\n#endif\n}\n\n    static void\ngui_x11_mouse_cb(\n    Widget\tw UNUSED,\n    XtPointer\tdud UNUSED,\n    XEvent\t*event,\n    Boolean\t*dum UNUSED)\n{\n    static XtIntervalId timer = (XtIntervalId)0;\n    static int\ttimed_out = TRUE;\n\n    int\t\tbutton;\n    int\t\trepeated_click = FALSE;\n    int\t\tx, y;\n    int_u\tx_modifiers;\n    int_u\tvim_modifiers;\n\n    if (event->type == MotionNotify)\n    {\n\t// Get the latest position, avoids lagging behind on a drag.\n\tx = event->xmotion.x;\n\ty = event->xmotion.y;\n\tx_modifiers = event->xmotion.state;\n\tbutton = (x_modifiers & (Button1Mask | Button2Mask | Button3Mask))\n\t\t? MOUSE_DRAG : ' ';\n\n\t/*\n\t * if our pointer is currently hidden, then we should show it.\n\t */\n\tgui_mch_mousehide(FALSE);\n\n\tif (button != MOUSE_DRAG)\t// just moving the rodent\n\t{\n#ifdef FEAT_MENU\n\t    if (dud)\t\t\t// moved in vimForm\n\t\ty -= gui.menu_height;\n#endif\n\t    gui_mouse_moved(x, y);\n\t    return;\n\t}\n    }\n    else\n    {\n\tx = event->xbutton.x;\n\ty = event->xbutton.y;\n\tif (event->type == ButtonPress)\n\t{\n\t    // Handle multiple clicks\n\t    if (!timed_out)\n\t    {\n\t\tXtRemoveTimeOut(timer);\n\t\trepeated_click = TRUE;\n\t    }\n\t    timed_out = FALSE;\n\t    timer = XtAppAddTimeOut(app_context, (long_u)p_mouset,\n\t\t\tgui_x11_timer_cb, &timed_out);\n\t    switch (event->xbutton.button)\n\t    {\n\t\t// keep in sync with gui_gtk_x11.c\n\t\tcase Button1:\tbutton = MOUSE_LEFT;\tbreak;\n\t\tcase Button2:\tbutton = MOUSE_MIDDLE;\tbreak;\n\t\tcase Button3:\tbutton = MOUSE_RIGHT;\tbreak;\n\t\tcase Button4:\tbutton = MOUSE_4;\tbreak;\n\t\tcase Button5:\tbutton = MOUSE_5;\tbreak;\n\t\tcase 6:\t\tbutton = MOUSE_7;\tbreak;\n\t\tcase 7:\t\tbutton = MOUSE_6;\tbreak;\n\t\tcase 8:\t\tbutton = MOUSE_X1;\tbreak;\n\t\tcase 9:\t\tbutton = MOUSE_X2;\tbreak;\n\t\tdefault:\n\t\t    return;\t// Unknown button\n\t    }\n\t}\n\telse if (event->type == ButtonRelease)\n\t    button = MOUSE_RELEASE;\n\telse\n\t    return;\t// Unknown mouse event type\n\n\tx_modifiers = event->xbutton.state;\n#if defined(FEAT_GUI_MOTIF) && defined(FEAT_MENU)\n\tlast_mouse_event = event->xbutton;\n#endif\n    }\n\n    vim_modifiers = 0x0;\n    if (x_modifiers & ShiftMask)\n\tvim_modifiers |= MOUSE_SHIFT;\n    if (x_modifiers & ControlMask)\n\tvim_modifiers |= MOUSE_CTRL;\n    if (x_modifiers & Mod1Mask)\t    // Alt or Meta key\n\tvim_modifiers |= MOUSE_ALT;\n\n    gui_send_mouse_event(button, x, y, repeated_click, vim_modifiers);\n}\n\n/*\n * End of call-back routines\n */\n\n/*\n * Parse the GUI related command-line arguments.  Any arguments used are\n * deleted from argv, and *argc is decremented accordingly.  This is called\n * when vim is started, whether or not the GUI has been started.\n */\n    void\ngui_mch_prepare(int *argc, char **argv)\n{\n    int\t    arg;\n    int\t    i;\n\n    /*\n     * Move all the entries in argv which are relevant to X into gui_argv.\n     */\n    gui_argc = 0;\n    gui_argv = LALLOC_MULT(char *, *argc);\n    if (gui_argv == NULL)\n\treturn;\n    gui_argv[gui_argc++] = argv[0];\n    arg = 1;\n    while (arg < *argc)\n    {\n\t// Look for argv[arg] in cmdline_options[] table\n\tfor (i = 0; i < (int)XtNumber(cmdline_options); i++)\n\t    if (strcmp(argv[arg], cmdline_options[i].option) == 0)\n\t\tbreak;\n\n\tif (i < (int)XtNumber(cmdline_options))\n\t{\n\t    // Remember finding \"-rv\" or \"-reverse\"\n\t    if (strcmp(\"-rv\", argv[arg]) == 0\n\t\t    || strcmp(\"-reverse\", argv[arg]) == 0)\n\t\tfound_reverse_arg = TRUE;\n\t    else if ((strcmp(\"-fn\", argv[arg]) == 0\n\t\t\t|| strcmp(\"-font\", argv[arg]) == 0)\n\t\t    && arg + 1 < *argc)\n\t\tfont_argument = argv[arg + 1];\n\n\t    // Found match in table, so move it into gui_argv\n\t    gui_argv[gui_argc++] = argv[arg];\n\t    if (--*argc > arg)\n\t    {\n\t\tmch_memmove(&argv[arg], &argv[arg + 1], (*argc - arg)\n\t\t\t\t\t\t    * sizeof(char *));\n\t\tif (cmdline_options[i].argKind != XrmoptionNoArg)\n\t\t{\n\t\t    // Move the options argument as well\n\t\t    gui_argv[gui_argc++] = argv[arg];\n\t\t    if (--*argc > arg)\n\t\t\tmch_memmove(&argv[arg], &argv[arg + 1], (*argc - arg)\n\t\t\t\t\t\t\t    * sizeof(char *));\n\t\t}\n\t    }\n\t    argv[*argc] = NULL;\n\t}\n\telse\n#ifdef FEAT_NETBEANS_INTG\n\t    if (strncmp(\"-nb\", argv[arg], 3) == 0)\n\t{\n\t    gui.dofork = FALSE;\t// don't fork() when starting GUI\n\t    netbeansArg = argv[arg];\n\t    mch_memmove(&argv[arg], &argv[arg + 1],\n\t\t\t\t\t    (--*argc - arg) * sizeof(char *));\n\t    argv[*argc] = NULL;\n\t}\n\telse\n#endif\n\t    arg++;\n    }\n}\n\n#ifndef XtSpecificationRelease\n# define CARDINAL (Cardinal *)\n#else\n# if XtSpecificationRelease == 4\n# define CARDINAL (Cardinal *)\n# else\n# define CARDINAL (int *)\n# endif\n#endif\n\n/*\n * Check if the GUI can be started.  Called before gvimrc is sourced.\n * Return OK or FAIL.\n */\n    int\ngui_mch_init_check(void)\n{\n#ifdef FEAT_XIM\n    XtSetLanguageProc(NULL, NULL, NULL);\n#endif\n    open_app_context();\n    if (app_context != NULL)\n\tgui.dpy = XtOpenDisplay(app_context, 0, VIM_NAME, VIM_CLASS,\n\t\tcmdline_options, XtNumber(cmdline_options),\n\t\tCARDINAL &gui_argc, gui_argv);\n\n# if defined(FEAT_FLOAT) && defined(LC_NUMERIC)\n    {\n\t// The call to XtOpenDisplay() may have set the locale from the\n\t// environment. Set LC_NUMERIC to \"C\" to make sure that strtod() uses a\n\t// decimal point, not a comma.\n\tchar *p = setlocale(LC_NUMERIC, NULL);\n\n\tif (p == NULL || strcmp(p, \"C\") != 0)\n\t   setlocale(LC_NUMERIC, \"C\");\n    }\n# endif\n    if (app_context == NULL || gui.dpy == NULL)\n    {\n\tgui.dying = TRUE;\n\temsg(_(e_cannot_open_display));\n\treturn FAIL;\n    }\n    return OK;\n}\n\n\n#ifdef USE_XSMP\n/*\n * Handle XSMP processing, de-registering the attachment upon error\n */\nstatic XtInputId _xsmp_xtinputid;\n\n    static void\nlocal_xsmp_handle_requests(\n    XtPointer\tc UNUSED,\n    int\t\t*s UNUSED,\n    XtInputId\t*i UNUSED)\n{\n    if (xsmp_handle_requests() == FAIL)\n\tXtRemoveInput(_xsmp_xtinputid);\n}\n#endif\n\n\n/*\n * Initialise the X GUI.  Create all the windows, set up all the call-backs etc.\n * Returns OK for success, FAIL when the GUI can't be started.\n */\n    int\ngui_mch_init(void)\n{\n    XtGCMask\tgc_mask;\n    XGCValues\tgc_vals;\n    int\t\tx, y, mask;\n    unsigned\tw, h;\n\n#if 0\n    // Uncomment this to enable synchronous mode for debugging\n    XSynchronize(gui.dpy, True);\n#endif\n\n    vimShell = XtVaAppCreateShell(VIM_NAME, VIM_CLASS,\n\t    applicationShellWidgetClass, gui.dpy, NULL);\n\n    /*\n     * Get the application resources\n     */\n    XtVaGetApplicationResources(vimShell, (XtPointer)&gui,\n\tvim_resources, XtNumber(vim_resources), NULL);\n\n    gui.scrollbar_height = gui.scrollbar_width;\n\n    /*\n     * Get the colors ourselves.  Using the automatic conversion doesn't\n     * handle looking for approximate colors.\n     */\n    gui.menu_fg_pixel = gui_get_color((char_u *)gui.rsrc_menu_fg_name);\n    gui.menu_bg_pixel = gui_get_color((char_u *)gui.rsrc_menu_bg_name);\n    gui.scroll_fg_pixel = gui_get_color((char_u *)gui.rsrc_scroll_fg_name);\n    gui.scroll_bg_pixel = gui_get_color((char_u *)gui.rsrc_scroll_bg_name);\n#ifdef FEAT_BEVAL_GUI\n    gui.tooltip_fg_pixel = gui_get_color((char_u *)gui.rsrc_tooltip_fg_name);\n    gui.tooltip_bg_pixel = gui_get_color((char_u *)gui.rsrc_tooltip_bg_name);\n#endif\n\n    // Set default foreground and background colours\n    gui.norm_pixel = gui.def_norm_pixel;\n    gui.back_pixel = gui.def_back_pixel;\n\n    // Check if reverse video needs to be applied (on Sun it's done by X)\n    if (gui.rsrc_rev_video && gui_get_lightness(gui.back_pixel)\n\t\t\t\t\t  > gui_get_lightness(gui.norm_pixel))\n    {\n\tgui.norm_pixel = gui.def_back_pixel;\n\tgui.back_pixel = gui.def_norm_pixel;\n\tgui.def_norm_pixel = gui.norm_pixel;\n\tgui.def_back_pixel = gui.back_pixel;\n    }\n\n    // Get the colors from the \"Normal\", \"Tooltip\", \"Scrollbar\" and \"Menu\"\n    // group (set in syntax.c or in a vimrc file)\n    set_normal_colors();\n\n    /*\n     * Check that none of the colors are the same as the background color\n     */\n    gui_check_colors();\n\n    /*\n     * Set up the GCs.\tThe font attributes will be set in gui_init_font().\n     */\n    gc_mask = GCForeground | GCBackground;\n    gc_vals.foreground = gui.norm_pixel;\n    gc_vals.background = gui.back_pixel;\n    gui.text_gc = XtGetGC(vimShell, gc_mask, &gc_vals);\n\n    gc_vals.foreground = gui.back_pixel;\n    gc_vals.background = gui.norm_pixel;\n    gui.back_gc = XtGetGC(vimShell, gc_mask, &gc_vals);\n\n    gc_mask |= GCFunction;\n    gc_vals.foreground = gui.norm_pixel ^ gui.back_pixel;\n    gc_vals.background = gui.norm_pixel ^ gui.back_pixel;\n    gc_vals.function   = GXxor;\n    gui.invert_gc = XtGetGC(vimShell, gc_mask, &gc_vals);\n\n    gui.visibility = VisibilityUnobscured;\n    x11_setup_atoms(gui.dpy);\n\n    if (gui_win_x != -1 && gui_win_y != -1)\n\tgui_mch_set_winpos(gui_win_x, gui_win_y);\n\n    // Now adapt the supplied(?) geometry-settings\n    // Added by Kjetil Jacobsen <kjetilja@stud.cs.uit.no>\n    if (gui.geom != NULL && *gui.geom != NUL)\n    {\n\tmask = XParseGeometry((char *)gui.geom, &x, &y, &w, &h);\n\tif (mask & WidthValue)\n\t    Columns = w;\n\tif (mask & HeightValue)\n\t{\n\t    if (p_window > (long)h - 1 || !option_was_set((char_u *)\"window\"))\n\t\tp_window = h - 1;\n\t    Rows = h;\n\t}\n\tlimit_screen_size();\n\t/*\n\t * Set the (x,y) position of the main window only if specified in the\n\t * users geometry, so we get good defaults when they don't. This needs\n\t * to be done before the shell is popped up.\n\t */\n\tif (mask & (XValue|YValue))\n\t    XtVaSetValues(vimShell, XtNgeometry, gui.geom, NULL);\n    }\n\n    gui_x11_create_widgets();\n\n   /*\n    * Add an icon to Vim (Marcel Douben: 11 May 1998).\n    */\n    if (vim_strchr(p_go, GO_ICON) != NULL)\n    {\n#ifndef HAVE_XPM\n# include \"vim_icon.xbm\"\n# include \"vim_mask.xbm\"\n\n\tArg\targ[2];\n\n\tXtSetArg(arg[0], XtNiconPixmap,\n\t\tXCreateBitmapFromData(gui.dpy,\n\t\t    DefaultRootWindow(gui.dpy),\n\t\t    (char *)vim_icon_bits,\n\t\t    vim_icon_width,\n\t\t    vim_icon_height));\n\tXtSetArg(arg[1], XtNiconMask,\n\t\tXCreateBitmapFromData(gui.dpy,\n\t\t    DefaultRootWindow(gui.dpy),\n\t\t    (char *)vim_mask_icon_bits,\n\t\t    vim_mask_icon_width,\n\t\t    vim_mask_icon_height));\n\tXtSetValues(vimShell, arg, (Cardinal)2);\n#else\n// Use Pixmaps, looking much nicer.\n\n// If you get an error message here, you still need to unpack the runtime\n// archive!\n# ifdef magick\n#  undef magick\n# endif\n# define magick vim32x32\n# include \"../runtime/vim32x32.xpm\"\n# undef magick\n# define magick vim16x16\n# include \"../runtime/vim16x16.xpm\"\n# undef magick\n# define magick vim48x48\n# include \"../runtime/vim48x48.xpm\"\n# undef magick\n\n    static Pixmap\ticon = 0;\n    static Pixmap\ticon_mask = 0;\n    static char\t\t**magick = vim32x32;\n    Window\t\troot_window;\n    XIconSize\t\t*size;\n    int\t\t\tnumber_sizes;\n    Display\t\t*dsp;\n    Screen\t\t*scr;\n    XpmAttributes\tattr;\n    Colormap\t\tcmap;\n\n    /*\n     * Adjust the icon to the preferences of the actual window manager.\n     */\n    root_window = XRootWindowOfScreen(XtScreen(vimShell));\n    if (XGetIconSizes(XtDisplay(vimShell), root_window,\n\t\t\t\t\t\t   &size, &number_sizes) != 0)\n    {\n\tif (number_sizes > 0)\n\t{\n\t    if (size->max_height >= 48 && size->max_width >= 48)\n\t\tmagick = vim48x48;\n\t    else if (size->max_height >= 32 && size->max_width >= 32)\n\t\tmagick = vim32x32;\n\t    else if (size->max_height >= 16 && size->max_width >= 16)\n\t\tmagick = vim16x16;\n\t}\n    }\n\n    dsp = XtDisplay(vimShell);\n    scr = XtScreen(vimShell);\n\n    cmap = DefaultColormap(dsp, DefaultScreen(dsp));\n    XtVaSetValues(vimShell, XtNcolormap, cmap, NULL);\n\n    attr.valuemask = 0L;\n    attr.valuemask = XpmCloseness | XpmReturnPixels | XpmColormap | XpmDepth;\n    attr.closeness = 65535;\t// accuracy isn't crucial\n    attr.colormap = cmap;\n    attr.depth = DefaultDepthOfScreen(scr);\n\n    if (!icon)\n    {\n\tXpmCreatePixmapFromData(dsp, root_window, magick, &icon,\n\t\t\t\t\t\t\t   &icon_mask, &attr);\n\tXpmFreeAttributes(&attr);\n    }\n\n    XtVaSetValues(vimShell, XmNiconPixmap, icon, XmNiconMask, icon_mask, NULL);\n#endif\n    }\n\n    if (gui.color_approx)\n\temsg(_(e_cannot_allocate_colormap_entry_some_colors_may_be_incorrect));\n\n#ifdef FEAT_BEVAL_GUI\n    gui_init_tooltip_font();\n#endif\n#ifdef FEAT_MENU\n    gui_init_menu_font();\n#endif\n\n#ifdef USE_XSMP\n    // Attach listener on ICE connection\n    if (-1 != xsmp_icefd)\n\t_xsmp_xtinputid = XtAppAddInput(app_context, xsmp_icefd,\n\t\t(XtPointer)XtInputReadMask, local_xsmp_handle_requests, NULL);\n#endif\n\n    return OK;\n}\n\n/*\n * Called when starting the GUI fails after calling gui_mch_init().\n */\n    void\ngui_mch_uninit(void)\n{\n    gui_x11_destroy_widgets();\n    XtCloseDisplay(gui.dpy);\n    gui.dpy = NULL;\n    vimShell = (Widget)0;\n    VIM_CLEAR(gui_argv);\n}\n\n/*\n * Called when the foreground or background color has been changed.\n */\n    void\ngui_mch_new_colors(void)\n{\n    long_u\tgc_mask;\n    XGCValues\tgc_vals;\n\n    gc_mask = GCForeground | GCBackground;\n    gc_vals.foreground = gui.norm_pixel;\n    gc_vals.background = gui.back_pixel;\n    if (gui.text_gc != NULL)\n\tXChangeGC(gui.dpy, gui.text_gc, gc_mask, &gc_vals);\n\n    gc_vals.foreground = gui.back_pixel;\n    gc_vals.background = gui.norm_pixel;\n    if (gui.back_gc != NULL)\n\tXChangeGC(gui.dpy, gui.back_gc, gc_mask, &gc_vals);\n\n    gc_mask |= GCFunction;\n    gc_vals.foreground = gui.norm_pixel ^ gui.back_pixel;\n    gc_vals.background = gui.norm_pixel ^ gui.back_pixel;\n    gc_vals.function   = GXxor;\n    if (gui.invert_gc != NULL)\n\tXChangeGC(gui.dpy, gui.invert_gc, gc_mask, &gc_vals);\n\n    gui_x11_set_back_color();\n}\n\n/*\n * Open the GUI window which was created by a call to gui_mch_init().\n */\n    int\ngui_mch_open(void)\n{\n    // Actually open the window\n    XtRealizeWidget(vimShell);\n    XtManageChild(XtNameToWidget(vimShell, \"*vimForm\"));\n\n    gui.wid = gui_x11_get_wid();\n    gui.blank_pointer = gui_x11_create_blank_mouse();\n\n    /*\n     * Add a callback for the Close item on the window managers menu, and the\n     * save-yourself event.\n     */\n    wm_atoms[SAVE_YOURSELF_IDX] =\n\t\t\t      XInternAtom(gui.dpy, \"WM_SAVE_YOURSELF\", False);\n    wm_atoms[DELETE_WINDOW_IDX] =\n\t\t\t      XInternAtom(gui.dpy, \"WM_DELETE_WINDOW\", False);\n    XSetWMProtocols(gui.dpy, XtWindow(vimShell), wm_atoms, 2);\n    XtAddEventHandler(vimShell, NoEventMask, True, gui_x11_wm_protocol_handler,\n\t\t\t\t\t\t\t     NULL);\n#ifdef HAVE_X11_XMU_EDITRES_H\n    /*\n     * Enable editres protocol (see \"man editres\").\n     * Usually will need to add -lXmu to the linker line as well.\n     */\n    XtAddEventHandler(vimShell, (EventMask)0, True, _XEditResCheckMessages,\n\t    (XtPointer)NULL);\n#endif\n\n#ifdef FEAT_CLIENTSERVER\n    if (serverName == NULL && serverDelayedStartName != NULL)\n    {\n\t// This is a :gui command in a plain vim with no previous server\n\tcommWindow = XtWindow(vimShell);\n\t(void)serverRegisterName(gui.dpy, serverDelayedStartName);\n    }\n    else\n    {\n\t/*\n\t * Cannot handle \"widget-less\" windows with XtProcessEvent() we'll\n\t * have to change the \"server\" registration to that of the main window\n\t * If we have not registered a name yet, remember the window\n\t */\n\tserverChangeRegisteredWindow(gui.dpy, XtWindow(vimShell));\n    }\n    XtAddEventHandler(vimShell, PropertyChangeMask, False,\n\t\t      gui_x11_send_event_handler, NULL);\n#endif\n\n    // Get the colors for the highlight groups (gui_check_colors() might have\n    // changed them)\n    highlight_gui_started();\t\t// re-init colors and fonts\n\n#ifdef FEAT_XIM\n    xim_init();\n#endif\n\n    return OK;\n}\n\n#if defined(FEAT_BEVAL_GUI) || defined(PROTO)\n/*\n * Convert the tooltip fontset name to an XFontSet.\n */\n    void\ngui_init_tooltip_font(void)\n{\n    XrmValue from, to;\n\n    from.addr = (char *)gui.rsrc_tooltip_font_name;\n    from.size = strlen(from.addr);\n    to.addr = (XtPointer)&gui.tooltip_fontset;\n    to.size = sizeof(XFontSet);\n\n    if (XtConvertAndStore(vimShell, XtRString, &from, XtRFontSet, &to) == False)\n    {\n\t// Failed. What to do?\n    }\n}\n#endif\n\n#if defined(FEAT_MENU) || defined(PROTO)\n// Convert the menu font/fontset name to an XFontStruct/XFontset\n    void\ngui_init_menu_font(void)\n{\n    XrmValue from, to;\n\n#ifdef FONTSET_ALWAYS\n    from.addr = (char *)gui.rsrc_menu_font_name;\n    from.size = strlen(from.addr);\n    to.addr = (XtPointer)&gui.menu_fontset;\n    to.size = sizeof(GuiFontset);\n\n    if (XtConvertAndStore(vimShell, XtRString, &from, XtRFontSet, &to) == False)\n    {\n\t// Failed. What to do?\n    }\n#else\n    from.addr = (char *)gui.rsrc_menu_font_name;\n    from.size = strlen(from.addr);\n    to.addr = (XtPointer)&gui.menu_font;\n    to.size = sizeof(GuiFont);\n\n    if (XtConvertAndStore(vimShell, XtRString, &from, XtRFontStruct, &to) == False)\n    {\n\t// Failed. What to do?\n    }\n#endif\n}\n#endif\n\n    void\ngui_mch_exit(int rc UNUSED)\n{\n#if 0\n    // Lesstif gives an error message here, and so does Solaris.  The man page\n    // says that this isn't needed when exiting, so just skip it.\n    XtCloseDisplay(gui.dpy);\n#endif\n    VIM_CLEAR(gui_argv);\n}\n\n/*\n * Get the position of the top left corner of the window.\n */\n    int\ngui_mch_get_winpos(int *x, int *y)\n{\n    Dimension\txpos, ypos;\n\n    XtVaGetValues(vimShell,\n\tXtNx,\t&xpos,\n\tXtNy,\t&ypos,\n\tNULL);\n    *x = xpos;\n    *y = ypos;\n    return OK;\n}\n\n/*\n * Set the position of the top left corner of the window to the given\n * coordinates.\n */\n    void\ngui_mch_set_winpos(int x, int y)\n{\n    XtVaSetValues(vimShell,\n\tXtNx,\tx,\n\tXtNy,\ty,\n\tNULL);\n}\n\n    void\ngui_mch_set_shellsize(\n    int\t\twidth,\n    int\t\theight,\n    int\t\tmin_width,\n    int\t\tmin_height,\n    int\t\tbase_width,\n    int\t\tbase_height,\n    int\t\tdirection UNUSED)\n{\n#ifdef FEAT_XIM\n    height += xim_get_status_area_height(),\n#endif\n    XtVaSetValues(vimShell,\n\tXtNwidthInc,\tgui.char_width,\n\tXtNheightInc,\tgui.char_height,\n#if defined(XtSpecificationRelease) && XtSpecificationRelease >= 4\n\tXtNbaseWidth,\tbase_width,\n\tXtNbaseHeight,\tbase_height,\n#endif\n\tXtNminWidth,\tmin_width,\n\tXtNminHeight,\tmin_height,\n\tXtNwidth,\twidth,\n\tXtNheight,\theight,\n\tNULL);\n}\n\n/*\n * Allow 10 pixels for horizontal borders, 'guiheadroom' for vertical borders.\n * Is there no way in X to find out how wide the borders really are?\n */\n    void\ngui_mch_get_screen_dimensions(\n    int\t    *screen_w,\n    int\t    *screen_h)\n{\n    *screen_w = DisplayWidth(gui.dpy, DefaultScreen(gui.dpy)) - 10;\n    *screen_h = DisplayHeight(gui.dpy, DefaultScreen(gui.dpy)) - p_ghr;\n}\n\n/*\n * Initialise vim to use the font \"font_name\".  If it's NULL, pick a default\n * font.\n * If \"fontset\" is TRUE, load the \"font_name\" as a fontset.\n * Return FAIL if the font could not be loaded, OK otherwise.\n */\n    int\ngui_mch_init_font(\n    char_u\t*font_name,\n    int\t\tdo_fontset UNUSED)\n{\n    XFontStruct\t*font = NULL;\n\n#ifdef FEAT_XFONTSET\n    XFontSet\tfontset = NULL;\n#endif\n\n#ifdef FEAT_GUI_MOTIF\n    // A font name equal \"*\" is indicating, that we should activate the font\n    // selection dialogue to get a new font name. So let us do it here.\n    if (font_name != NULL && STRCMP(font_name, \"*\") == 0)\n    {\n\tfont_name = gui_xm_select_font(hl_get_font_name());\n\n\t// Do not reset to default font except on GUI startup.\n\tif (font_name == NULL && !gui.starting)\n\t    return OK;\n    }\n#endif\n\n#ifdef FEAT_XFONTSET\n    if (do_fontset)\n    {\n\t// If 'guifontset' is set, VIM treats all font specifications as if\n\t// they were fontsets, and 'guifontset' becomes the default.\n\tif (font_name != NULL)\n\t{\n\t    fontset = (XFontSet)gui_mch_get_fontset(font_name, FALSE, TRUE);\n\t    if (fontset == NULL)\n\t\treturn FAIL;\n\t}\n    }\n    else\n#endif\n    {\n\tif (font_name == NULL)\n\t{\n\t    /*\n\t     * If none of the fonts in 'font' could be loaded, try the one set\n\t     * in the X resource, and finally just try using DFLT_FONT, which\n\t     * will hopefully always be there.\n\t     */\n\t    font_name = gui.rsrc_font_name;\n\t    font = (XFontStruct *)gui_mch_get_font(font_name, FALSE);\n\t    if (font == NULL)\n\t\tfont_name = (char_u *)DFLT_FONT;\n\t}\n\tif (font == NULL)\n\t    font = (XFontStruct *)gui_mch_get_font(font_name, FALSE);\n\tif (font == NULL)\n\t    return FAIL;\n    }\n\n    gui_mch_free_font(gui.norm_font);\n#ifdef FEAT_XFONTSET\n    gui_mch_free_fontset(gui.fontset);\n\n    if (fontset != NULL)\n    {\n\tgui.norm_font = NOFONT;\n\tgui.fontset = (GuiFontset)fontset;\n\tgui.char_width = fontset_width(fontset);\n\tgui.char_height = fontset_height(fontset) + p_linespace;\n\tgui.char_ascent = fontset_ascent(fontset) + p_linespace / 2;\n    }\n    else\n#endif\n    {\n\tgui.norm_font = (GuiFont)font;\n#ifdef FEAT_XFONTSET\n\tgui.fontset = NOFONTSET;\n#endif\n\tgui.char_width = font->max_bounds.width;\n\tgui.char_height = font->ascent + font->descent + p_linespace;\n\tgui.char_ascent = font->ascent + p_linespace / 2;\n    }\n\n    hl_set_font_name(font_name);\n\n    /*\n     * Try to load other fonts for bold, italic, and bold-italic.\n     * We should also try to work out what font to use for these when they are\n     * not specified by X resources, but we don't yet.\n     */\n    if (font_name == gui.rsrc_font_name)\n    {\n\tif (gui.bold_font == NOFONT\n\t\t&& gui.rsrc_bold_font_name != NULL\n\t\t&& *gui.rsrc_bold_font_name != NUL)\n\t    gui.bold_font = gui_mch_get_font(gui.rsrc_bold_font_name, FALSE);\n\tif (gui.ital_font == NOFONT\n\t\t&& gui.rsrc_ital_font_name != NULL\n\t\t&& *gui.rsrc_ital_font_name != NUL)\n\t    gui.ital_font = gui_mch_get_font(gui.rsrc_ital_font_name, FALSE);\n\tif (gui.boldital_font == NOFONT\n\t\t&& gui.rsrc_boldital_font_name != NULL\n\t\t&& *gui.rsrc_boldital_font_name != NUL)\n\t    gui.boldital_font = gui_mch_get_font(gui.rsrc_boldital_font_name,\n\t\t\t\t\t\t\t\t       FALSE);\n    }\n    else\n    {\n\t// When not using the font specified by the resources, also don't use\n\t// the bold/italic fonts, otherwise setting 'guifont' will look very\n\t// strange.\n\tif (gui.bold_font != NOFONT)\n\t{\n\t    XFreeFont(gui.dpy, (XFontStruct *)gui.bold_font);\n\t    gui.bold_font = NOFONT;\n\t}\n\tif (gui.ital_font != NOFONT)\n\t{\n\t    XFreeFont(gui.dpy, (XFontStruct *)gui.ital_font);\n\t    gui.ital_font = NOFONT;\n\t}\n\tif (gui.boldital_font != NOFONT)\n\t{\n\t    XFreeFont(gui.dpy, (XFontStruct *)gui.boldital_font);\n\t    gui.boldital_font = NOFONT;\n\t}\n    }\n\n#ifdef FEAT_GUI_MOTIF\n    gui_motif_synch_fonts();\n#endif\n\n    return OK;\n}\n\n/*\n * Get a font structure for highlighting.\n */\n    GuiFont\ngui_mch_get_font(char_u *name, int giveErrorIfMissing)\n{\n    XFontStruct\t*font;\n\n    if (!gui.in_use || name == NULL)\t// can't do this when GUI not running\n\treturn NOFONT;\n\n    font = XLoadQueryFont(gui.dpy, (char *)name);\n\n    if (font == NULL)\n    {\n\tif (giveErrorIfMissing)\n\t    semsg(_(e_unknown_font_str), name);\n\treturn NOFONT;\n    }\n\n#ifdef DEBUG\n    printf(\"Font Information for '%s':\\n\", name);\n    printf(\"  w = %d, h = %d, ascent = %d, descent = %d\\n\",\n\t   font->max_bounds.width, font->ascent + font->descent,\n\t   font->ascent, font->descent);\n    printf(\"  max ascent = %d, max descent = %d, max h = %d\\n\",\n\t   font->max_bounds.ascent, font->max_bounds.descent,\n\t   font->max_bounds.ascent + font->max_bounds.descent);\n    printf(\"  min lbearing = %d, min rbearing = %d\\n\",\n\t   font->min_bounds.lbearing, font->min_bounds.rbearing);\n    printf(\"  max lbearing = %d, max rbearing = %d\\n\",\n\t   font->max_bounds.lbearing, font->max_bounds.rbearing);\n    printf(\"  leftink = %d, rightink = %d\\n\",\n\t   (font->min_bounds.lbearing < 0),\n\t   (font->max_bounds.rbearing > font->max_bounds.width));\n    printf(\"\\n\");\n#endif\n\n    if (font->max_bounds.width != font->min_bounds.width)\n    {\n\tsemsg(_(e_font_str_is_not_fixed_width), name);\n\tXFreeFont(gui.dpy, font);\n\treturn NOFONT;\n    }\n    return (GuiFont)font;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return the name of font \"font\" in allocated memory.\n */\n    char_u *\ngui_mch_get_fontname(GuiFont font, char_u *name)\n{\n    char_u *ret = NULL;\n\n    if (name != NULL && font == NULL)\n    {\n\t// In this case, there's no way other than doing this.\n\tret = vim_strsave(name);\n    }\n    else if (font != NULL)\n    {\n\t// In this case, try to retrieve the XLFD corresponding to 'font'->fid;\n\t// if failed, use 'name' unless it's NULL.\n\tunsigned long value = 0L;\n\n\tif (XGetFontProperty(font, XA_FONT, &value))\n\t{\n\t    char *xa_font_name = NULL;\n\n\t    xa_font_name = XGetAtomName(gui.dpy, value);\n\t    if (xa_font_name != NULL)\n\t    {\n\t\tret = vim_strsave((char_u *)xa_font_name);\n\t\tXFree(xa_font_name);\n\t    }\n\t    else if (name != NULL)\n\t\tret = vim_strsave(name);\n\t}\n\telse if (name != NULL)\n\t    ret = vim_strsave(name);\n    }\n    return ret;\n}\n#endif\n\n/*\n * Adjust gui.char_height (after 'linespace' was changed).\n */\n    int\ngui_mch_adjust_charheight(void)\n{\n#ifdef FEAT_XFONTSET\n    if (gui.fontset != NOFONTSET)\n    {\n\tgui.char_height = fontset_height((XFontSet)gui.fontset) + p_linespace;\n\tgui.char_ascent = fontset_ascent((XFontSet)gui.fontset)\n\t\t\t\t\t\t\t    + p_linespace / 2;\n    }\n    else\n#endif\n    {\n\tXFontStruct *font = (XFontStruct *)gui.norm_font;\n\n\tgui.char_height = font->ascent + font->descent + p_linespace;\n\tgui.char_ascent = font->ascent + p_linespace / 2;\n    }\n    return OK;\n}\n\n/*\n * Set the current text font.\n */\n    void\ngui_mch_set_font(GuiFont font)\n{\n    static Font\tprev_font = (Font)-1;\n    Font\tfid = ((XFontStruct *)font)->fid;\n\n    if (fid != prev_font)\n    {\n\tXSetFont(gui.dpy, gui.text_gc, fid);\n\tXSetFont(gui.dpy, gui.back_gc, fid);\n\tprev_font = fid;\n\tgui.char_ascent = ((XFontStruct *)font)->ascent + p_linespace / 2;\n    }\n#ifdef FEAT_XFONTSET\n    current_fontset = (XFontSet)NULL;\n#endif\n}\n\n#if defined(FEAT_XFONTSET) || defined(PROTO)\n/*\n * Set the current text fontset.\n * Adjust the ascent, in case it's different.\n */\n    void\ngui_mch_set_fontset(GuiFontset fontset)\n{\n    current_fontset = (XFontSet)fontset;\n    gui.char_ascent = fontset_ascent(current_fontset) + p_linespace / 2;\n}\n#endif\n\n/*\n * If a font is not going to be used, free its structure.\n */\n    void\ngui_mch_free_font(GuiFont font)\n{\n    if (font != NOFONT)\n\tXFreeFont(gui.dpy, (XFontStruct *)font);\n}\n\n#if defined(FEAT_XFONTSET) || defined(PROTO)\n/*\n * If a fontset is not going to be used, free its structure.\n */\n    void\ngui_mch_free_fontset(GuiFontset fontset)\n{\n    if (fontset != NOFONTSET)\n\tXFreeFontSet(gui.dpy, (XFontSet)fontset);\n}\n\n/*\n * Load the fontset \"name\".\n * Return a reference to the fontset, or NOFONTSET when failing.\n */\n    GuiFontset\ngui_mch_get_fontset(\n    char_u\t*name,\n    int\t\tgiveErrorIfMissing,\n    int\t\tfixed_width)\n{\n    XFontSet\tfontset;\n    char\t**missing, *def_str;\n    int\t\tnum_missing;\n\n    if (!gui.in_use || name == NULL)\n\treturn NOFONTSET;\n\n    fontset = XCreateFontSet(gui.dpy, (char *)name, &missing, &num_missing,\n\t\t\t     &def_str);\n    if (num_missing > 0)\n    {\n\tint i;\n\n\tif (giveErrorIfMissing)\n\t{\n\t    semsg(_(e_fonts_for_the_following_charsets_are_missing_in_fontset), name);\n\t    for (i = 0; i < num_missing; i++)\n\t\tsemsg(\"%s\", missing[i]);\n\t}\n\tXFreeStringList(missing);\n    }\n\n    if (fontset == NULL)\n    {\n\tif (giveErrorIfMissing)\n\t    semsg(_(e_unknown_fontset_str), name);\n\treturn NOFONTSET;\n    }\n\n    if (fixed_width && check_fontset_sanity(fontset) == FAIL)\n    {\n\tXFreeFontSet(gui.dpy, fontset);\n\treturn NOFONTSET;\n    }\n    return (GuiFontset)fontset;\n}\n\n/*\n * Check if fontset \"fs\" is fixed width.\n */\n    static int\ncheck_fontset_sanity(XFontSet fs)\n{\n    XFontStruct\t**xfs;\n    char\t**font_name;\n    int\t\tfn;\n    char\t*base_name;\n    int\t\ti;\n    int\t\tmin_width;\n    int\t\tmin_font_idx = 0;\n\n    base_name = XBaseFontNameListOfFontSet(fs);\n    fn = XFontsOfFontSet(fs, &xfs, &font_name);\n    for (i = 0; i < fn; i++)\n    {\n\tif (xfs[i]->max_bounds.width != xfs[i]->min_bounds.width)\n\t{\n\t    semsg(_(e_fontsent_name_str_font_str_is_not_fixed_width),\n\t\t    base_name, font_name[i]);\n\t    return FAIL;\n\t}\n    }\n    // scan base font width\n    min_width = 32767;\n    for (i = 0; i < fn; i++)\n    {\n\tif (xfs[i]->max_bounds.width<min_width)\n\t{\n\t    min_width = xfs[i]->max_bounds.width;\n\t    min_font_idx = i;\n\t}\n    }\n    for (i = 0; i < fn; i++)\n    {\n\tif (\t   xfs[i]->max_bounds.width != 2 * min_width\n\t\t&& xfs[i]->max_bounds.width != min_width)\n\t{\n\t    semsg(_(e_fontset_name_str), base_name);\n\t    semsg(_(\"Font0: %s\"), font_name[min_font_idx]);\n\t    semsg(_(\"Font%d: %s\"), i, font_name[i]);\n\t    semsg(_(\"Font%d width is not twice that of font0\"), i);\n\t    semsg(_(\"Font0 width: %d\"),\n\t\t\t\t     (int)xfs[min_font_idx]->max_bounds.width);\n\t    semsg(_(\"Font%d width: %d\"), i, (int)xfs[i]->max_bounds.width);\n\t    return FAIL;\n\t}\n    }\n    // it seems ok. Good Luck!!\n    return OK;\n}\n\n    static int\nfontset_width(XFontSet fs)\n{\n return XmbTextEscapement(fs, \"Vim\", 3) / 3;\n}\n\n    int\nfontset_height(\n    XFontSet fs)\n{\n    XFontSetExtents *extents;\n\n    extents = XExtentsOfFontSet(fs);\n    return extents->max_logical_extent.height;\n}\n\n#if 0\n// NOT USED YET\n    static int\nfontset_descent(XFontSet fs)\n{\n    XFontSetExtents *extents;\n\n    extents = XExtentsOfFontSet (fs);\n    return extents->max_logical_extent.height + extents->max_logical_extent.y;\n}\n#endif\n\n    static int\nfontset_ascent(XFontSet fs)\n{\n    XFontSetExtents *extents;\n\n    extents = XExtentsOfFontSet(fs);\n    return -extents->max_logical_extent.y;\n}\n\n#endif // FEAT_XFONTSET\n\n/*\n * Return the Pixel value (color) for the given color name.\n * Return INVALCOLOR for error.\n */\n    guicolor_T\ngui_mch_get_color(char_u *name)\n{\n    guicolor_T\trequested;\n\n    // can't do this when GUI not running\n    if (!gui.in_use || name == NULL || *name == NUL)\n\treturn INVALCOLOR;\n\n    requested = gui_get_color_cmn(name);\n    if (requested == INVALCOLOR)\n\treturn INVALCOLOR;\n\n    return gui_mch_get_rgb_color(\n\t    (requested & 0xff0000) >> 16,\n\t    (requested & 0xff00) >> 8,\n\t    requested & 0xff);\n}\n\n/*\n * Return the Pixel value (color) for the given RGB values.\n * Return INVALCOLOR for error.\n */\n    guicolor_T\ngui_mch_get_rgb_color(int r, int g, int b)\n{\n    XColor\tavailable;\n    Colormap\tcolormap;\n\n#if 0\n// Using XParseColor() is very slow, put rgb in XColor directly.\n\n    char\tspec[8]; // space enough to hold \"#RRGGBB\"\n    vim_snprintf(spec, sizeof(spec), \"#%.2x%.2x%.2x\", r, g, b);\n    if (XParseColor(gui.dpy, colormap, (char *)spec, &available) != 0\n\t    && XAllocColor(gui.dpy, colormap, &available) != 0)\n\treturn (guicolor_T)available.pixel;\n#endif\n    colormap = DefaultColormap(gui.dpy, DefaultScreen(gui.dpy));\n    CLEAR_FIELD(available);\n    available.red = r << 8;\n    available.green = g << 8;\n    available.blue = b << 8;\n    if (XAllocColor(gui.dpy, colormap, &available) != 0)\n\treturn (guicolor_T)available.pixel;\n\n    return INVALCOLOR;\n}\n\n/*\n * Set the current text foreground color.\n */\n    void\ngui_mch_set_fg_color(guicolor_T color)\n{\n    if (color != prev_fg_color)\n    {\n\tXSetForeground(gui.dpy, gui.text_gc, (Pixel)color);\n\tprev_fg_color = color;\n    }\n}\n\n/*\n * Set the current text background color.\n */\n    void\ngui_mch_set_bg_color(guicolor_T color)\n{\n    if (color != prev_bg_color)\n    {\n\tXSetBackground(gui.dpy, gui.text_gc, (Pixel)color);\n\tprev_bg_color = color;\n    }\n}\n\n/*\n * Set the current text special color.\n */\n    void\ngui_mch_set_sp_color(guicolor_T color)\n{\n    prev_sp_color = color;\n}\n\n/*\n * create a mouse pointer that is blank\n */\n    static Cursor\ngui_x11_create_blank_mouse(void)\n{\n    Pixmap blank_pixmap = XCreatePixmap(gui.dpy, gui.wid, 1, 1, 1);\n    GC gc = XCreateGC(gui.dpy, blank_pixmap, (unsigned long)0, (XGCValues*)0);\n\n    if (gc != NULL)\n    {\n\tXDrawPoint(gui.dpy, blank_pixmap, gc, 0, 0);\n\tXFreeGC(gui.dpy, gc);\n    }\n    return XCreatePixmapCursor(gui.dpy, blank_pixmap, blank_pixmap,\n\t\t     (XColor*)&gui.norm_pixel, (XColor*)&gui.norm_pixel, 0, 0);\n}\n\n/*\n * Draw a curled line at the bottom of the character cell.\n */\n    static void\ndraw_curl(int row, int col, int cells)\n{\n    int\t\t\ti;\n    int\t\t\toffset;\n    static const int\tval[8] = {1, 0, 0, 0, 1, 2, 2, 2 };\n\n    XSetForeground(gui.dpy, gui.text_gc, prev_sp_color);\n    for (i = FILL_X(col); i < FILL_X(col + cells); ++i)\n    {\n\toffset = val[i % 8];\n\tXDrawPoint(gui.dpy, gui.wid, gui.text_gc, i,\n\t\t\t\t\t\tFILL_Y(row + 1) - 1 - offset);\n    }\n    XSetForeground(gui.dpy, gui.text_gc, prev_fg_color);\n}\n\n    void\ngui_mch_draw_string(\n    int\t\trow,\n    int\t\tcol,\n    char_u\t*s,\n    int\t\tlen,\n    int\t\tflags)\n{\n    int\t\t\tcells = len;\n    static void\t\t*buf = NULL;\n    static int\t\tbuflen = 0;\n    char_u\t\t*p;\n    int\t\t\twlen = 0;\n    int\t\t\tc;\n\n    if (enc_utf8)\n    {\n\t// Convert UTF-8 byte sequence to 16 bit characters for the X\n\t// functions.  Need a buffer for the 16 bit characters.  Keep it\n\t// between calls, because allocating it each time is slow.\n\tif (buflen < len)\n\t{\n\t    XtFree((char *)buf);\n\t    buf = (void *)XtMalloc(len * (sizeof(XChar2b) < sizeof(wchar_t)\n\t\t\t\t\t? sizeof(wchar_t) : sizeof(XChar2b)));\n\t    buflen = len;\n\t}\n\tp = s;\n\tcells = 0;\n\twhile (p < s + len)\n\t{\n\t    c = utf_ptr2char(p);\n#ifdef FEAT_XFONTSET\n\t    if (current_fontset != NULL)\n\t    {\n# ifdef SMALL_WCHAR_T\n\t\tif (c >= 0x10000)\n\t\t    c = 0xbf;\t\t// show chars > 0xffff as ?\n# endif\n\t\t((wchar_t *)buf)[wlen] = c;\n\t    }\n\t    else\n#endif\n\t    {\n\t\tif (c >= 0x10000)\n\t\t    c = 0xbf;\t\t// show chars > 0xffff as ?\n\t\t((XChar2b *)buf)[wlen].byte1 = (unsigned)c >> 8;\n\t\t((XChar2b *)buf)[wlen].byte2 = c;\n\t    }\n\t    ++wlen;\n\t    cells += utf_char2cells(c);\n\t    p += utf_ptr2len(p);\n\t}\n    }\n    else if (has_mbyte)\n    {\n\tcells = 0;\n\tfor (p = s; p < s + len; )\n\t{\n\t    cells += ptr2cells(p);\n\t    p += (*mb_ptr2len)(p);\n\t}\n    }\n\n#ifdef FEAT_XFONTSET\n    if (current_fontset != NULL)\n    {\n\t// Setup a clip rectangle to avoid spilling over in the next or\n\t// previous line.  This is apparently needed for some fonts which are\n\t// used in a fontset.\n\tXRectangle\tclip;\n\n\tclip.x = 0;\n\tclip.y = 0;\n\tclip.height = gui.char_height;\n\tclip.width = gui.char_width * cells + 1;\n\tXSetClipRectangles(gui.dpy, gui.text_gc, FILL_X(col), FILL_Y(row),\n\t\t&clip, 1, Unsorted);\n    }\n#endif\n\n    if (flags & DRAW_TRANSP)\n    {\n\tif (enc_utf8)\n\t    XDrawString16(gui.dpy, gui.wid, gui.text_gc, TEXT_X(col),\n\t\t    TEXT_Y(row), buf, wlen);\n\telse\n\t    XDrawString(gui.dpy, gui.wid, gui.text_gc, TEXT_X(col),\n\t\t    TEXT_Y(row), (char *)s, len);\n    }\n    else if (p_linespace != 0\n#ifdef FEAT_XFONTSET\n\t    || current_fontset != NULL\n#endif\n\t    )\n    {\n\tXSetForeground(gui.dpy, gui.text_gc, prev_bg_color);\n\tXFillRectangle(gui.dpy, gui.wid, gui.text_gc, FILL_X(col),\n\t\tFILL_Y(row), gui.char_width * cells, gui.char_height);\n\tXSetForeground(gui.dpy, gui.text_gc, prev_fg_color);\n\n\tif (enc_utf8)\n\t    XDrawString16(gui.dpy, gui.wid, gui.text_gc, TEXT_X(col),\n\t\t    TEXT_Y(row), buf, wlen);\n\telse\n\t    XDrawString(gui.dpy, gui.wid, gui.text_gc, TEXT_X(col),\n\t\t    TEXT_Y(row), (char *)s, len);\n    }\n    else\n    {\n\t// XmbDrawImageString has bug, don't use it for fontset.\n\tif (enc_utf8)\n\t    XDrawImageString16(gui.dpy, gui.wid, gui.text_gc, TEXT_X(col),\n\t\t    TEXT_Y(row), buf, wlen);\n\telse\n\t    XDrawImageString(gui.dpy, gui.wid, gui.text_gc, TEXT_X(col),\n\t\t    TEXT_Y(row), (char *)s, len);\n    }\n\n    // Bold trick: draw the text again with a one-pixel offset.\n    if (flags & DRAW_BOLD)\n    {\n\tif (enc_utf8)\n\t    XDrawString16(gui.dpy, gui.wid, gui.text_gc, TEXT_X(col) + 1,\n\t\t    TEXT_Y(row), buf, wlen);\n\telse\n\t    XDrawString(gui.dpy, gui.wid, gui.text_gc, TEXT_X(col) + 1,\n\t\t    TEXT_Y(row), (char *)s, len);\n    }\n\n    // Undercurl: draw curl at the bottom of the character cell.\n    if (flags & DRAW_UNDERC)\n\tdraw_curl(row, col, cells);\n\n    // Underline: draw a line at the bottom of the character cell.\n    if (flags & DRAW_UNDERL)\n    {\n\tint\ty = FILL_Y(row + 1) - 1;\n\n\t// When p_linespace is 0, overwrite the bottom row of pixels.\n\t// Otherwise put the line just below the character.\n\tif (p_linespace > 1)\n\t    y -= p_linespace - 1;\n\tXDrawLine(gui.dpy, gui.wid, gui.text_gc, FILL_X(col),\n\t\ty, FILL_X(col + cells) - 1, y);\n    }\n\n    if (flags & DRAW_STRIKE)\n    {\n\tint\ty = FILL_Y(row + 1) - gui.char_height/2;\n\n\tXSetForeground(gui.dpy, gui.text_gc, prev_sp_color);\n\tXDrawLine(gui.dpy, gui.wid, gui.text_gc, FILL_X(col),\n\t\ty, FILL_X(col + cells) - 1, y);\n\tXSetForeground(gui.dpy, gui.text_gc, prev_fg_color);\n    }\n\n#ifdef FEAT_XFONTSET\n    if (current_fontset != NULL)\n\tXSetClipMask(gui.dpy, gui.text_gc, None);\n#endif\n}\n\n/*\n * Return OK if the key with the termcap name \"name\" is supported.\n */\n    int\ngui_mch_haskey(char_u *name)\n{\n    int i;\n\n    for (i = 0; special_keys[i].key_sym != (KeySym)0; i++)\n\tif (name[0] == special_keys[i].vim_code0 &&\n\t\t\t\t\t name[1] == special_keys[i].vim_code1)\n\t    return OK;\n    return FAIL;\n}\n\n/*\n * Return the text window-id and display.  Only required for X-based GUI's\n */\n    int\ngui_get_x11_windis(Window *win, Display **dis)\n{\n    *win = XtWindow(vimShell);\n    *dis = gui.dpy;\n    return OK;\n}\n\n    void\ngui_mch_beep(void)\n{\n    XBell(gui.dpy, 0);\n}\n\n    void\ngui_mch_flash(int msec)\n{\n    // Do a visual beep by reversing the foreground and background colors\n    XFillRectangle(gui.dpy, gui.wid, gui.invert_gc, 0, 0,\n\t    FILL_X((int)Columns) + gui.border_offset,\n\t    FILL_Y((int)Rows) + gui.border_offset);\n    XSync(gui.dpy, False);\n    ui_delay((long)msec, TRUE);\t// wait for a few msec\n    XFillRectangle(gui.dpy, gui.wid, gui.invert_gc, 0, 0,\n\t    FILL_X((int)Columns) + gui.border_offset,\n\t    FILL_Y((int)Rows) + gui.border_offset);\n}\n\n/*\n * Invert a rectangle from row r, column c, for nr rows and nc columns.\n */\n    void\ngui_mch_invert_rectangle(\n    int\t    r,\n    int\t    c,\n    int\t    nr,\n    int\t    nc)\n{\n    XFillRectangle(gui.dpy, gui.wid, gui.invert_gc,\n\tFILL_X(c), FILL_Y(r), (nc) * gui.char_width, (nr) * gui.char_height);\n}\n\n/*\n * Iconify the GUI window.\n */\n    void\ngui_mch_iconify(void)\n{\n    XIconifyWindow(gui.dpy, XtWindow(vimShell), DefaultScreen(gui.dpy));\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Bring the Vim window to the foreground.\n */\n    void\ngui_mch_set_foreground(void)\n{\n    XMapRaised(gui.dpy, XtWindow(vimShell));\n}\n#endif\n\n/*\n * Draw a cursor without focus.\n */\n    void\ngui_mch_draw_hollow_cursor(guicolor_T color)\n{\n    int\t\tw = 1;\n\n    if (mb_lefthalve(gui.row, gui.col))\n\tw = 2;\n    gui_mch_set_fg_color(color);\n    XDrawRectangle(gui.dpy, gui.wid, gui.text_gc, FILL_X(gui.col),\n\t    FILL_Y(gui.row), w * gui.char_width - 1, gui.char_height - 1);\n}\n\n/*\n * Draw part of a cursor, \"w\" pixels wide, and \"h\" pixels high, using\n * color \"color\".\n */\n    void\ngui_mch_draw_part_cursor(int w, int h, guicolor_T color)\n{\n    gui_mch_set_fg_color(color);\n\n    XFillRectangle(gui.dpy, gui.wid, gui.text_gc,\n#ifdef FEAT_RIGHTLEFT\n\t    // vertical line should be on the right of current point\n\t    CURSOR_BAR_RIGHT ? FILL_X(gui.col + 1) - w :\n#endif\n\t\tFILL_X(gui.col),\n\t    FILL_Y(gui.row) + gui.char_height - h,\n\t    w, h);\n}\n\n/*\n * Catch up with any queued X events.  This may put keyboard input into the\n * input buffer, call resize call-backs, trigger timers etc.  If there is\n * nothing in the X event queue (& no timers pending), then we return\n * immediately.\n */\n    void\ngui_mch_update(void)\n{\n    XtInputMask mask, desired;\n\n#ifdef ALT_X_INPUT\n    if (suppress_alternate_input)\n\tdesired = (XtIMXEvent | XtIMTimer);\n    else\n#endif\n\tdesired = (XtIMAll);\n    while ((mask = XtAppPending(app_context)) && (mask & desired)\n\t    && !vim_is_input_buf_full())\n\tXtAppProcessEvent(app_context, desired);\n}\n\n/*\n * GUI input routine called by gui_wait_for_chars().  Waits for a character\n * from the keyboard.\n *  wtime == -1\t    Wait forever.\n *  wtime == 0\t    This should never happen.\n *  wtime > 0\t    Wait wtime milliseconds for a character.\n * Returns OK if a character was found to be available within the given time,\n * or FAIL otherwise.\n */\n    int\ngui_mch_wait_for_chars(long wtime)\n{\n    int\t    focus;\n    int\t    retval = FAIL;\n\n    /*\n     * Make this static, in case gui_x11_timer_cb is called after leaving\n     * this function (otherwise a random value on the stack may be changed).\n     */\n    static int\t    timed_out;\n    XtIntervalId    timer = (XtIntervalId)0;\n    XtInputMask\t    desired;\n#ifdef FEAT_JOB_CHANNEL\n    XtIntervalId    channel_timer = (XtIntervalId)0;\n#endif\n\n    timed_out = FALSE;\n\n    if (wtime >= 0)\n\ttimer = XtAppAddTimeOut(app_context,\n\t\t\t\t(long_u)(wtime == 0 ? 1L : wtime),\n\t\t\t\t\t\t gui_x11_timer_cb, &timed_out);\n#ifdef FEAT_JOB_CHANNEL\n    // If there is a channel with the keep_open flag we need to poll for input\n    // on them.\n    if (channel_any_keep_open())\n\tchannel_timer = XtAppAddTimeOut(app_context, (long_u)20,\n\t\t\t\t   channel_poll_cb, (XtPointer)&channel_timer);\n#endif\n\n    focus = gui.in_focus;\n    desired = (XtIMAll);\n    while (!timed_out)\n    {\n\t// Stop or start blinking when focus changes\n\tif (gui.in_focus != focus)\n\t{\n\t    if (gui.in_focus)\n\t\tgui_mch_start_blink();\n\t    else\n\t\tgui_mch_stop_blink(TRUE);\n\t    focus = gui.in_focus;\n\t}\n\n#ifdef MESSAGE_QUEUE\n# ifdef FEAT_TIMERS\n\tdid_add_timer = FALSE;\n# endif\n\tparse_queued_messages();\n# ifdef FEAT_TIMERS\n\tif (did_add_timer)\n\t    // Need to recompute the waiting time.\n\t    break;\n# endif\n#endif\n\n\t/*\n\t * Don't use gui_mch_update() because then we will spin-lock until a\n\t * char arrives, instead we use XtAppProcessEvent() to hang until an\n\t * event arrives.  No need to check for input_buf_full because we are\n\t * returning as soon as it contains a single char.  Note that\n\t * XtAppNextEvent() may not be used because it will not return after a\n\t * timer event has arrived -- webb\n\t */\n\tXtAppProcessEvent(app_context, desired);\n\n\tif (input_available())\n\t{\n\t    retval = OK;\n\t    break;\n\t}\n    }\n\n    if (timer != (XtIntervalId)0 && !timed_out)\n\tXtRemoveTimeOut(timer);\n#ifdef FEAT_JOB_CHANNEL\n    if (channel_timer != (XtIntervalId)0)\n\tXtRemoveTimeOut(channel_timer);\n#endif\n\n    return retval;\n}\n\n/*\n * Output routines.\n */\n\n/*\n * Flush any output to the screen\n */\n    void\ngui_mch_flush(void)\n{\n    XFlush(gui.dpy);\n}\n\n/*\n * Clear a rectangular region of the screen from text pos (row1, col1) to\n * (row2, col2) inclusive.\n */\n    void\ngui_mch_clear_block(\n    int\t\trow1,\n    int\t\tcol1,\n    int\t\trow2,\n    int\t\tcol2)\n{\n    int\t\tx;\n\n    x = FILL_X(col1);\n\n    // Clear one extra pixel at the far right, for when bold characters have\n    // spilled over to the next column.\n    XFillRectangle(gui.dpy, gui.wid, gui.back_gc, x, FILL_Y(row1),\n\t    (col2 - col1 + 1) * gui.char_width + (col2 == Columns - 1),\n\t    (row2 - row1 + 1) * gui.char_height);\n}\n\n    void\ngui_mch_clear_all(void)\n{\n    XClearArea(gui.dpy, gui.wid, 0, 0, 0, 0, False);\n}\n\n/*\n * Delete the given number of lines from the given row, scrolling up any\n * text further down within the scroll region.\n */\n    void\ngui_mch_delete_lines(int row, int num_lines)\n{\n    if (gui.visibility == VisibilityFullyObscured)\n\treturn;\t    // Can't see the window\n\n    // copy one extra pixel at the far right, for when bold has spilled\n    // over\n    XCopyArea(gui.dpy, gui.wid, gui.wid, gui.text_gc,\n\tFILL_X(gui.scroll_region_left), FILL_Y(row + num_lines),\n\tgui.char_width * (gui.scroll_region_right - gui.scroll_region_left + 1)\n\t\t\t       + (gui.scroll_region_right == Columns - 1),\n\tgui.char_height * (gui.scroll_region_bot - row - num_lines + 1),\n\tFILL_X(gui.scroll_region_left), FILL_Y(row));\n\n    gui_clear_block(gui.scroll_region_bot - num_lines + 1,\n\t\t\t\t\t\t       gui.scroll_region_left,\n\t\t\t  gui.scroll_region_bot, gui.scroll_region_right);\n    gui_x11_check_copy_area();\n}\n\n/*\n * Insert the given number of lines before the given row, scrolling down any\n * following text within the scroll region.\n */\n    void\ngui_mch_insert_lines(int row, int num_lines)\n{\n    if (gui.visibility == VisibilityFullyObscured)\n\treturn;\t    // Can't see the window\n\n    // copy one extra pixel at the far right, for when bold has spilled\n    // over\n    XCopyArea(gui.dpy, gui.wid, gui.wid, gui.text_gc,\n\tFILL_X(gui.scroll_region_left), FILL_Y(row),\n\tgui.char_width * (gui.scroll_region_right - gui.scroll_region_left + 1)\n\t\t\t       + (gui.scroll_region_right == Columns - 1),\n\tgui.char_height * (gui.scroll_region_bot - row - num_lines + 1),\n\tFILL_X(gui.scroll_region_left), FILL_Y(row + num_lines));\n\n    gui_clear_block(row, gui.scroll_region_left,\n\t\t\t\trow + num_lines - 1, gui.scroll_region_right);\n    gui_x11_check_copy_area();\n}\n\n/*\n * Update the region revealed by scrolling up/down.\n */\n    static void\ngui_x11_check_copy_area(void)\n{\n    XEvent\t\t    event;\n    XGraphicsExposeEvent    *gevent;\n\n    if (gui.visibility != VisibilityPartiallyObscured)\n\treturn;\n\n    XFlush(gui.dpy);\n\n    // Wait to check whether the scroll worked or not\n    for (;;)\n    {\n\tif (XCheckTypedEvent(gui.dpy, NoExpose, &event))\n\t    return;\t// The scroll worked.\n\n\tif (XCheckTypedEvent(gui.dpy, GraphicsExpose, &event))\n\t{\n\t    gevent = (XGraphicsExposeEvent *)&event;\n\t    gui_redraw(gevent->x, gevent->y, gevent->width, gevent->height);\n\t    if (gevent->count == 0)\n\t\treturn;\t\t// This was the last expose event\n\t}\n\tXSync(gui.dpy, False);\n    }\n}\n\n/*\n * X Selection stuff, for cutting and pasting text to other windows.\n */\n\n    void\nclip_mch_lose_selection(Clipboard_T *cbd)\n{\n    clip_x11_lose_selection(vimShell, cbd);\n}\n\n    int\nclip_mch_own_selection(Clipboard_T *cbd)\n{\n    return clip_x11_own_selection(vimShell, cbd);\n}\n\n    void\nclip_mch_request_selection(Clipboard_T *cbd)\n{\n clip_x11_request_selection(vimShell, gui.dpy, cbd);\n}\n\n    void\nclip_mch_set_selection(\n    Clipboard_T\t*cbd)\n{\n    clip_x11_set_selection(cbd);\n}\n\n#if defined(FEAT_MENU) || defined(PROTO)\n/*\n * Menu stuff.\n */\n\n/*\n * Make a menu either grey or not grey.\n */\n    void\ngui_mch_menu_grey(vimmenu_T *menu, int grey)\n{\n    if (menu->id != (Widget)0)\n    {\n\tgui_mch_menu_hidden(menu, False);\n\tif (grey\n#ifdef FEAT_GUI_MOTIF\n\t\t|| !menu->sensitive\n#endif\n\t\t)\n\t    XtSetSensitive(menu->id, False);\n\telse\n\t    XtSetSensitive(menu->id, True);\n    }\n}\n\n/*\n * Make menu item hidden or not hidden\n */\n    void\ngui_mch_menu_hidden(vimmenu_T *menu, int hidden)\n{\n    if (menu->id != (Widget)0)\n    {\n\tif (hidden)\n\t    XtUnmanageChild(menu->id);\n\telse\n\t    XtManageChild(menu->id);\n    }\n}\n\n/*\n * This is called after setting all the menus to grey/hidden or not.\n */\n    void\ngui_mch_draw_menubar(void)\n{\n    // Nothing to do in X\n}\n\n    void\ngui_x11_menu_cb(\n    Widget\tw UNUSED,\n    XtPointer\tclient_data,\n    XtPointer\tcall_data UNUSED)\n{\n    gui_menu_cb((vimmenu_T *)client_data);\n}\n\n#endif // FEAT_MENU\n\n\n\n/*\n * Function called when window closed.\tWorks like \":qa\".\n * Should put up a requester!\n */\n    static void\ngui_x11_wm_protocol_handler(\n    Widget\tw UNUSED,\n    XtPointer\tclient_data UNUSED,\n    XEvent\t*event,\n    Boolean\t*dum UNUSED)\n{\n    /*\n     * Only deal with Client messages.\n     */\n    if (event->type != ClientMessage)\n\treturn;\n\n    /*\n     * The WM_SAVE_YOURSELF event arrives when the window manager wants to\n     * exit.  That can be cancelled though, thus Vim shouldn't exit here.\n     * Just sync our swap files.\n     */\n    if ((Atom)((XClientMessageEvent *)event)->data.l[0] ==\n\t\t\t\t\t\t  wm_atoms[SAVE_YOURSELF_IDX])\n    {\n\tout_flush();\n\tml_sync_all(FALSE, FALSE);\t// preserve all swap files\n\n\t// Set the window's WM_COMMAND property, to let the window manager\n\t// know we are done saving ourselves.  We don't want to be restarted,\n\t// thus set argv to NULL.\n\tXSetCommand(gui.dpy, XtWindow(vimShell), NULL, 0);\n\treturn;\n    }\n\n    if ((Atom)((XClientMessageEvent *)event)->data.l[0] !=\n\t\t\t\t\t\t  wm_atoms[DELETE_WINDOW_IDX])\n\treturn;\n\n    gui_shell_closed();\n}\n\n#ifdef FEAT_CLIENTSERVER\n/*\n * Function called when property changed. Check for incoming commands\n */\n    static void\ngui_x11_send_event_handler(\n    Widget\tw UNUSED,\n    XtPointer\tclient_data UNUSED,\n    XEvent\t*event,\n    Boolean\t*dum UNUSED)\n{\n    XPropertyEvent *e = (XPropertyEvent *) event;\n\n    if (e->type == PropertyNotify && e->window == commWindow\n\t    && e->atom == commProperty &&  e->state == PropertyNewValue)\n\tserverEventProc(gui.dpy, event, 0);\n}\n#endif\n\n/*\n * Cursor blink functions.\n *\n * This is a simple state machine:\n * BLINK_NONE\tnot blinking at all\n * BLINK_OFF\tblinking, cursor is not shown\n * BLINK_ON\tblinking, cursor is shown\n */\n\n#define BLINK_NONE  0\n#define BLINK_OFF   1\n#define BLINK_ON    2\n\nstatic int\t\tblink_state = BLINK_NONE;\nstatic long_u\t\tblink_waittime = 700;\nstatic long_u\t\tblink_ontime = 400;\nstatic long_u\t\tblink_offtime = 250;\nstatic XtIntervalId\tblink_timer = (XtIntervalId)0;\n\n    int\ngui_mch_is_blinking(void)\n{\n    return blink_state != BLINK_NONE;\n}\n\n    int\ngui_mch_is_blink_off(void)\n{\n    return blink_state == BLINK_OFF;\n}\n\n    void\ngui_mch_set_blinking(long waittime, long on, long off)\n{\n    blink_waittime = waittime;\n    blink_ontime = on;\n    blink_offtime = off;\n}\n\n/*\n * Stop the cursor blinking.  Show the cursor if it wasn't shown.\n */\n    void\ngui_mch_stop_blink(int may_call_gui_update_cursor)\n{\n    if (blink_timer != (XtIntervalId)0)\n    {\n\tXtRemoveTimeOut(blink_timer);\n\tblink_timer = (XtIntervalId)0;\n    }\n    if (blink_state == BLINK_OFF && may_call_gui_update_cursor)\n\tgui_update_cursor(TRUE, FALSE);\n    blink_state = BLINK_NONE;\n}\n\n    static void\ngui_x11_blink_cb(\n    XtPointer\t    timed_out UNUSED,\n    XtIntervalId    *interval_id UNUSED)\n{\n    if (blink_state == BLINK_ON)\n    {\n\tgui_undraw_cursor();\n\tblink_state = BLINK_OFF;\n\tblink_timer = XtAppAddTimeOut(app_context, blink_offtime,\n\t\t\t\t\t\t      gui_x11_blink_cb, NULL);\n    }\n    else\n    {\n\tgui_update_cursor(TRUE, FALSE);\n\tblink_state = BLINK_ON;\n\tblink_timer = XtAppAddTimeOut(app_context, blink_ontime,\n\t\t\t\t\t\t      gui_x11_blink_cb, NULL);\n    }\n}\n\n/*\n * Start the cursor blinking.  If it was already blinking, this restarts the\n * waiting time and shows the cursor.\n */\n    void\ngui_mch_start_blink(void)\n{\n    if (blink_timer != (XtIntervalId)0)\n\tXtRemoveTimeOut(blink_timer);\n    // Only switch blinking on if none of the times is zero\n    if (blink_waittime && blink_ontime && blink_offtime && gui.in_focus)\n    {\n\tblink_timer = XtAppAddTimeOut(app_context, blink_waittime,\n\t\t\t\t\t\t      gui_x11_blink_cb, NULL);\n\tblink_state = BLINK_ON;\n\tgui_update_cursor(TRUE, FALSE);\n    }\n}\n\n/*\n * Return the RGB value of a pixel as a long.\n */\n    guicolor_T\ngui_mch_get_rgb(guicolor_T pixel)\n{\n    XColor\txc;\n    Colormap\tcolormap;\n\n    colormap = DefaultColormap(gui.dpy, XDefaultScreen(gui.dpy));\n    xc.pixel = pixel;\n    XQueryColor(gui.dpy, colormap, &xc);\n\n    return (guicolor_T)(((xc.red & 0xff00) << 8) + (xc.green & 0xff00)\n\t\t\t\t\t\t   + ((unsigned)xc.blue >> 8));\n}\n\n/*\n * Add the callback functions.\n */\n    void\ngui_x11_callbacks(Widget textArea, Widget vimForm)\n{\n    XtAddEventHandler(textArea, VisibilityChangeMask, FALSE,\n\tgui_x11_visibility_cb, (XtPointer)0);\n\n    XtAddEventHandler(textArea, ExposureMask, FALSE, gui_x11_expose_cb,\n\t(XtPointer)0);\n\n    XtAddEventHandler(vimShell, StructureNotifyMask, FALSE,\n\tgui_x11_resize_window_cb, (XtPointer)0);\n\n    XtAddEventHandler(vimShell, FocusChangeMask, FALSE, gui_x11_focus_change_cb,\n\t(XtPointer)0);\n    /*\n     * Only install these enter/leave callbacks when 'p' in 'guioptions'.\n     * Only needed for some window managers.\n     */\n    if (vim_strchr(p_go, GO_POINTER) != NULL)\n    {\n\tXtAddEventHandler(vimShell, LeaveWindowMask, FALSE, gui_x11_leave_cb,\n\t    (XtPointer)0);\n\tXtAddEventHandler(textArea, LeaveWindowMask, FALSE, gui_x11_leave_cb,\n\t    (XtPointer)0);\n\tXtAddEventHandler(textArea, EnterWindowMask, FALSE, gui_x11_enter_cb,\n\t    (XtPointer)0);\n\tXtAddEventHandler(vimShell, EnterWindowMask, FALSE, gui_x11_enter_cb,\n\t    (XtPointer)0);\n    }\n\n    XtAddEventHandler(vimForm, KeyPressMask, FALSE, gui_x11_key_hit_cb,\n\t(XtPointer)0);\n    XtAddEventHandler(textArea, KeyPressMask, FALSE, gui_x11_key_hit_cb,\n\t(XtPointer)0);\n\n    // get pointer moved events from scrollbar, needed for 'mousefocus'\n    XtAddEventHandler(vimForm, PointerMotionMask,\n\tFALSE, gui_x11_mouse_cb, (XtPointer)1);\n    XtAddEventHandler(textArea, ButtonPressMask | ButtonReleaseMask |\n\t\t\t\t\t ButtonMotionMask | PointerMotionMask,\n\tFALSE, gui_x11_mouse_cb, (XtPointer)0);\n}\n\n/*\n * Get current mouse coordinates in text window.\n */\n    void\ngui_mch_getmouse(int *x, int *y)\n{\n    int\t\trootx, rooty, winx, winy;\n    Window\troot, child;\n    unsigned int mask;\n\n    if (gui.wid && XQueryPointer(gui.dpy, gui.wid, &root, &child,\n\t\t\t\t\t &rootx, &rooty, &winx, &winy, &mask)) {\n\t*x = winx;\n\t*y = winy;\n    } else {\n\t*x = -1;\n\t*y = -1;\n    }\n}\n\n    void\ngui_mch_setmouse(int x, int y)\n{\n    if (gui.wid)\n\tXWarpPointer(gui.dpy, (Window)0, gui.wid, 0, 0, 0, 0, x, y);\n}\n\n#if (defined(FEAT_GUI_MOTIF) && defined(FEAT_MENU)) || defined(PROTO)\n    XButtonPressedEvent *\ngui_x11_get_last_mouse_event(void)\n{\n    return &last_mouse_event;\n}\n#endif\n\n#if defined(FEAT_SIGN_ICONS) || defined(PROTO)\n\n// Signs are currently always 2 chars wide.  Hopefully the font is big enough\n// to provide room for the bitmap!\n# define SIGN_WIDTH (gui.char_width * 2)\n\n    void\ngui_mch_drawsign(int row, int col, int typenr)\n{\n    XImage\t*sign;\n\n    if (gui.in_use && (sign = (XImage *)sign_get_image(typenr)) != NULL)\n    {\n\tXClearArea(gui.dpy, gui.wid, TEXT_X(col), TEXT_Y(row) - sign->height,\n\t\tSIGN_WIDTH, gui.char_height, FALSE);\n\tXPutImage(gui.dpy, gui.wid, gui.text_gc, sign, 0, 0,\n\t\tTEXT_X(col) + (SIGN_WIDTH - sign->width) / 2,\n\t\tTEXT_Y(row) - sign->height,\n\t\tsign->width, sign->height);\n    }\n}\n\n    void *\ngui_mch_register_sign(char_u *signfile)\n{\n    XpmAttributes   attrs;\n    XImage\t    *sign = NULL;\n    int\t\t    status;\n\n    /*\n     * Setup the color substitution table.\n     */\n    if (signfile[0] != NUL && signfile[0] != '-')\n    {\n\tXpmColorSymbol color[5] =\n\t{\n\t    {\"none\", NULL, 0},\n\t    {\"iconColor1\", NULL, 0},\n\t    {\"bottomShadowColor\", NULL, 0},\n\t    {\"topShadowColor\", NULL, 0},\n\t    {\"selectColor\", NULL, 0}\n\t};\n\tattrs.valuemask = XpmColorSymbols;\n\tattrs.numsymbols = 2;\n\tattrs.colorsymbols = color;\n\tattrs.colorsymbols[0].pixel = gui.back_pixel;\n\tattrs.colorsymbols[1].pixel = gui.norm_pixel;\n\tstatus = XpmReadFileToImage(gui.dpy, (char *)signfile,\n\t\t\t\t\t\t\t &sign, NULL, &attrs);\n\tif (status == 0)\n\t{\n\t    // Sign width is fixed at two columns now.\n\t    // if (sign->width > gui.sign_width)\n\t    //     gui.sign_width = sign->width + 8;\n\t}\n\telse\n\t    emsg(_(e_couldnt_read_in_sign_data));\n    }\n\n    return (void *)sign;\n}\n\n    void\ngui_mch_destroy_sign(void *sign)\n{\n    XDestroyImage((XImage*)sign);\n}\n#endif\n\n\n#ifdef FEAT_MOUSESHAPE\n// The last set mouse pointer shape is remembered, to be used when it goes\n// from hidden to not hidden.\nstatic int last_shape = 0;\n#endif\n\n/*\n * Use the blank mouse pointer or not.\n */\n    void\ngui_mch_mousehide(\n    int\t\thide)\t// TRUE = use blank ptr, FALSE = use parent ptr\n{\n    if (gui.pointer_hidden != hide)\n    {\n\tgui.pointer_hidden = hide;\n\tif (hide)\n\t    XDefineCursor(gui.dpy, gui.wid, gui.blank_pointer);\n\telse\n#ifdef FEAT_MOUSESHAPE\n\t    mch_set_mouse_shape(last_shape);\n#else\n\t    XUndefineCursor(gui.dpy, gui.wid);\n#endif\n    }\n}\n\n#if defined(FEAT_MOUSESHAPE) || defined(PROTO)\n\n// Table for shape IDs.  Keep in sync with the mshape_names[] table in\n// misc2.c!\nstatic int mshape_ids[] =\n{\n    XC_left_ptr,\t\t// arrow\n    0,\t\t\t\t// blank\n    XC_xterm,\t\t\t// beam\n    XC_sb_v_double_arrow,\t// updown\n    XC_sizing,\t\t\t// udsizing\n    XC_sb_h_double_arrow,\t// leftright\n    XC_sizing,\t\t\t// lrsizing\n    XC_watch,\t\t\t// busy\n    XC_X_cursor,\t\t// no\n    XC_crosshair,\t\t// crosshair\n    XC_hand1,\t\t\t// hand1\n    XC_hand2,\t\t\t// hand2\n    XC_pencil,\t\t\t// pencil\n    XC_question_arrow,\t\t// question\n    XC_right_ptr,\t\t// right-arrow\n    XC_center_ptr,\t\t// up-arrow\n    XC_left_ptr\t\t\t// last one\n};\n\n    void\nmch_set_mouse_shape(int shape)\n{\n    int\t    id;\n\n    if (!gui.in_use)\n\treturn;\n\n    if (shape == MSHAPE_HIDE || gui.pointer_hidden)\n\tXDefineCursor(gui.dpy, gui.wid, gui.blank_pointer);\n    else\n    {\n\tif (shape >= MSHAPE_NUMBERED)\n\t{\n\t    id = shape - MSHAPE_NUMBERED;\n\t    if (id >= XC_num_glyphs)\n\t\tid = XC_left_ptr;\n\t    else\n\t\tid &= ~1;\t// they are always even (why?)\n\t}\n\telse\n\t    id = mshape_ids[shape];\n\n\tXDefineCursor(gui.dpy, gui.wid, XCreateFontCursor(gui.dpy, id));\n    }\n    if (shape != MSHAPE_HIDE)\n\tlast_shape = shape;\n}\n#endif\n\n#if (defined(FEAT_TOOLBAR) && defined(FEAT_BEVAL_GUI)) || defined(PROTO)\n/*\n * Set the balloon-eval used for the tooltip of a toolbar menu item.\n * The check for a non-toolbar item was added, because there is a crash when\n * passing a normal menu item here.  Can't explain that, but better avoid it.\n */\n    void\ngui_mch_menu_set_tip(vimmenu_T *menu)\n{\n    if (menu->id != NULL && menu->parent != NULL\n\t\t\t\t       && menu_is_toolbar(menu->parent->name))\n    {\n\t// Always destroy and create the balloon, in case the string was\n\t// changed.\n\tif (menu->tip != NULL)\n\t{\n\t    gui_mch_destroy_beval_area(menu->tip);\n\t    menu->tip = NULL;\n\t}\n\tif (menu->strings[MENU_INDEX_TIP] != NULL)\n\t    menu->tip = gui_mch_create_beval_area(\n\t\t    menu->id,\n\t\t    menu->strings[MENU_INDEX_TIP],\n\t\t    NULL,\n\t\t    NULL);\n    }\n}\n#endif\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/gui_x11.c", "src/version.c"], "buggy_code_start_loc": [2234, 709], "buggy_code_end_loc": [2238, 709], "fixing_code_start_loc": [2234, 710], "fixing_code_end_loc": [2242, 712], "type": "CWE-476", "message": "A null pointer dereference issue was discovered in function gui_x11_create_blank_mouse in gui_x11.c in vim 8.1.2269 thru 9.0.0339 allows attackers to cause denial of service or other unspecified impacts.", "other": {"cve": {"id": "CVE-2022-47024", "sourceIdentifier": "cve@mitre.org", "published": "2023-01-20T19:15:17.607", "lastModified": "2023-05-03T12:16:39.380", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A null pointer dereference issue was discovered in function gui_x11_create_blank_mouse in gui_x11.c in vim 8.1.2269 thru 9.0.0339 allows attackers to cause denial of service or other unspecified impacts."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionStartIncluding": "8.1.2269", "versionEndIncluding": "9.0.0339", "matchCriteriaId": "839BE453-A540-4FB5-A4CD-E78E6AC83CEA"}]}]}], "references": [{"url": "https://github.com/vim/vim/commit/a63ad78ed31e36dbdf3a9cd28071dcdbefce7d19", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/4EX6N2DB75A73MQGVW3CS4VTNPAYVM2M/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PZWIJBSQX53P7DHV77KRXJIXA4GH7XHC/", "source": "cve@mitre.org"}, {"url": "https://security.gentoo.org/glsa/202305-16", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/vim/vim/commit/a63ad78ed31e36dbdf3a9cd28071dcdbefce7d19"}}