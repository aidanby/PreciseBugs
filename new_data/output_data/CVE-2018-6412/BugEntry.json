{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0\n/* sbuslib.c: Helper library for SBUS framebuffer drivers.\n *\n * Copyright (C) 2003 David S. Miller (davem@redhat.com)\n */\n\n#include <linux/compat.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/fb.h>\n#include <linux/mm.h>\n#include <linux/uaccess.h>\n#include <linux/of_device.h>\n\n#include <asm/fbio.h>\n\n#include \"sbuslib.h\"\n\nvoid sbusfb_fill_var(struct fb_var_screeninfo *var, struct device_node *dp,\n\t\t     int bpp)\n{\n\tmemset(var, 0, sizeof(*var));\n\n\tvar->xres = of_getintprop_default(dp, \"width\", 1152);\n\tvar->yres = of_getintprop_default(dp, \"height\", 900);\n\tvar->xres_virtual = var->xres;\n\tvar->yres_virtual = var->yres;\n\tvar->bits_per_pixel = bpp;\n}\n\nEXPORT_SYMBOL(sbusfb_fill_var);\n\nstatic unsigned long sbusfb_mmapsize(long size, unsigned long fbsize)\n{\n\tif (size == SBUS_MMAP_EMPTY) return 0;\n\tif (size >= 0) return size;\n\treturn fbsize * (-size);\n}\n\nint sbusfb_mmap_helper(struct sbus_mmap_map *map,\n\t\t       unsigned long physbase,\n\t\t       unsigned long fbsize,\n\t\t       unsigned long iospace,\n\t\t       struct vm_area_struct *vma)\n{\n\tunsigned int size, page, r, map_size;\n\tunsigned long map_offset = 0;\n\tunsigned long off;\n\tint i;\n                                        \n\tif (!(vma->vm_flags & (VM_SHARED | VM_MAYSHARE)))\n\t\treturn -EINVAL;\n\n\tsize = vma->vm_end - vma->vm_start;\n\tif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT))\n\t\treturn -EINVAL;\n\n\toff = vma->vm_pgoff << PAGE_SHIFT;\n\n\t/* VM_IO | VM_DONTEXPAND | VM_DONTDUMP are set by remap_pfn_range() */\n\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\n\t/* Each page, see which map applies */\n\tfor (page = 0; page < size; ){\n\t\tmap_size = 0;\n\t\tfor (i = 0; map[i].size; i++)\n\t\t\tif (map[i].voff == off+page) {\n\t\t\t\tmap_size = sbusfb_mmapsize(map[i].size, fbsize);\n#ifdef __sparc_v9__\n#define POFF_MASK\t(PAGE_MASK|0x1UL)\n#else\n#define POFF_MASK\t(PAGE_MASK)\n#endif\t\t\t\t\n\t\t\t\tmap_offset = (physbase + map[i].poff) & POFF_MASK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (!map_size) {\n\t\t\tpage += PAGE_SIZE;\n\t\t\tcontinue;\n\t\t}\n\t\tif (page + map_size > size)\n\t\t\tmap_size = size - page;\n\t\tr = io_remap_pfn_range(vma,\n\t\t\t\t\tvma->vm_start + page,\n\t\t\t\t\tMK_IOSPACE_PFN(iospace,\n\t\t\t\t\t\tmap_offset >> PAGE_SHIFT),\n\t\t\t\t\tmap_size,\n\t\t\t\t\tvma->vm_page_prot);\n\t\tif (r)\n\t\t\treturn -EAGAIN;\n\t\tpage += map_size;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(sbusfb_mmap_helper);\n\nint sbusfb_ioctl_helper(unsigned long cmd, unsigned long arg,\n\t\t\tstruct fb_info *info,\n\t\t\tint type, int fb_depth, unsigned long fb_size)\n{\n\tswitch(cmd) {\n\tcase FBIOGTYPE: {\n\t\tstruct fbtype __user *f = (struct fbtype __user *) arg;\n\n\t\tif (put_user(type, &f->fb_type) ||\n\t\t    __put_user(info->var.yres, &f->fb_height) ||\n\t\t    __put_user(info->var.xres, &f->fb_width) ||\n\t\t    __put_user(fb_depth, &f->fb_depth) ||\n\t\t    __put_user(0, &f->fb_cmsize) ||\n\t\t    __put_user(fb_size, &f->fb_cmsize))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\tcase FBIOPUTCMAP_SPARC: {\n\t\tstruct fbcmap __user *c = (struct fbcmap __user *) arg;\n\t\tstruct fb_cmap cmap;\n\t\tu16 red, green, blue;\n\t\tu8 red8, green8, blue8;\n\t\tunsigned char __user *ured;\n\t\tunsigned char __user *ugreen;\n\t\tunsigned char __user *ublue;\n\t\tint index, count, i;\n\n\t\tif (get_user(index, &c->index) ||\n\t\t    __get_user(count, &c->count) ||\n\t\t    __get_user(ured, &c->red) ||\n\t\t    __get_user(ugreen, &c->green) ||\n\t\t    __get_user(ublue, &c->blue))\n\t\t\treturn -EFAULT;\n\n\t\tcmap.len = 1;\n\t\tcmap.red = &red;\n\t\tcmap.green = &green;\n\t\tcmap.blue = &blue;\n\t\tcmap.transp = NULL;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tint err;\n\n\t\t\tif (get_user(red8, &ured[i]) ||\n\t\t\t    get_user(green8, &ugreen[i]) ||\n\t\t\t    get_user(blue8, &ublue[i]))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tred = red8 << 8;\n\t\t\tgreen = green8 << 8;\n\t\t\tblue = blue8 << 8;\n\n\t\t\tcmap.start = index + i;\n\t\t\terr = fb_set_cmap(&cmap, info);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\treturn 0;\n\t}\n\tcase FBIOGETCMAP_SPARC: {\n\t\tstruct fbcmap __user *c = (struct fbcmap __user *) arg;\n\t\tunsigned char __user *ured;\n\t\tunsigned char __user *ugreen;\n\t\tunsigned char __user *ublue;\n\t\tstruct fb_cmap *cmap = &info->cmap;\n\t\tint index, count, i;\n\t\tu8 red, green, blue;\n\n\t\tif (get_user(index, &c->index) ||\n\t\t    __get_user(count, &c->count) ||\n\t\t    __get_user(ured, &c->red) ||\n\t\t    __get_user(ugreen, &c->green) ||\n\t\t    __get_user(ublue, &c->blue))\n\t\t\treturn -EFAULT;\n\n\t\tif (index + count > cmap->len)\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tred = cmap->red[index + i] >> 8;\n\t\t\tgreen = cmap->green[index + i] >> 8;\n\t\t\tblue = cmap->blue[index + i] >> 8;\n\t\t\tif (put_user(red, &ured[i]) ||\n\t\t\t    put_user(green, &ugreen[i]) ||\n\t\t\t    put_user(blue, &ublue[i]))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t\treturn 0;\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\nEXPORT_SYMBOL(sbusfb_ioctl_helper);\n\n#ifdef CONFIG_COMPAT\nstatic int fbiogetputcmap(struct fb_info *info, unsigned int cmd, unsigned long arg)\n{\n\tstruct fbcmap32 __user *argp = (void __user *)arg;\n\tstruct fbcmap __user *p = compat_alloc_user_space(sizeof(*p));\n\tu32 addr;\n\tint ret;\n\n\tret = copy_in_user(p, argp, 2 * sizeof(int));\n\tret |= get_user(addr, &argp->red);\n\tret |= put_user(compat_ptr(addr), &p->red);\n\tret |= get_user(addr, &argp->green);\n\tret |= put_user(compat_ptr(addr), &p->green);\n\tret |= get_user(addr, &argp->blue);\n\tret |= put_user(compat_ptr(addr), &p->blue);\n\tif (ret)\n\t\treturn -EFAULT;\n\treturn info->fbops->fb_ioctl(info,\n\t\t\t(cmd == FBIOPUTCMAP32) ?\n\t\t\tFBIOPUTCMAP_SPARC : FBIOGETCMAP_SPARC,\n\t\t\t(unsigned long)p);\n}\n\nstatic int fbiogscursor(struct fb_info *info, unsigned long arg)\n{\n\tstruct fbcursor __user *p = compat_alloc_user_space(sizeof(*p));\n\tstruct fbcursor32 __user *argp =  (void __user *)arg;\n\tcompat_uptr_t addr;\n\tint ret;\n\n\tret = copy_in_user(p, argp,\n\t\t\t      2 * sizeof (short) + 2 * sizeof(struct fbcurpos));\n\tret |= copy_in_user(&p->size, &argp->size, sizeof(struct fbcurpos));\n\tret |= copy_in_user(&p->cmap, &argp->cmap, 2 * sizeof(int));\n\tret |= get_user(addr, &argp->cmap.red);\n\tret |= put_user(compat_ptr(addr), &p->cmap.red);\n\tret |= get_user(addr, &argp->cmap.green);\n\tret |= put_user(compat_ptr(addr), &p->cmap.green);\n\tret |= get_user(addr, &argp->cmap.blue);\n\tret |= put_user(compat_ptr(addr), &p->cmap.blue);\n\tret |= get_user(addr, &argp->mask);\n\tret |= put_user(compat_ptr(addr), &p->mask);\n\tret |= get_user(addr, &argp->image);\n\tret |= put_user(compat_ptr(addr), &p->image);\n\tif (ret)\n\t\treturn -EFAULT;\n\treturn info->fbops->fb_ioctl(info, FBIOSCURSOR, (unsigned long)p);\n}\n\nint sbusfb_compat_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase FBIOGTYPE:\n\tcase FBIOSATTR:\n\tcase FBIOGATTR:\n\tcase FBIOSVIDEO:\n\tcase FBIOGVIDEO:\n\tcase FBIOGCURSOR32:\t/* This is not implemented yet.\n\t\t\t\t   Later it should be converted... */\n\tcase FBIOSCURPOS:\n\tcase FBIOGCURPOS:\n\tcase FBIOGCURMAX:\n\t\treturn info->fbops->fb_ioctl(info, cmd, arg);\n\tcase FBIOPUTCMAP32:\n\t\treturn fbiogetputcmap(info, cmd, arg);\n\tcase FBIOGETCMAP32:\n\t\treturn fbiogetputcmap(info, cmd, arg);\n\tcase FBIOSCURSOR32:\n\t\treturn fbiogscursor(info, arg);\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n}\nEXPORT_SYMBOL(sbusfb_compat_ioctl);\n#endif\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0\n/* sbuslib.c: Helper library for SBUS framebuffer drivers.\n *\n * Copyright (C) 2003 David S. Miller (davem@redhat.com)\n */\n\n#include <linux/compat.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/fb.h>\n#include <linux/mm.h>\n#include <linux/uaccess.h>\n#include <linux/of_device.h>\n\n#include <asm/fbio.h>\n\n#include \"sbuslib.h\"\n\nvoid sbusfb_fill_var(struct fb_var_screeninfo *var, struct device_node *dp,\n\t\t     int bpp)\n{\n\tmemset(var, 0, sizeof(*var));\n\n\tvar->xres = of_getintprop_default(dp, \"width\", 1152);\n\tvar->yres = of_getintprop_default(dp, \"height\", 900);\n\tvar->xres_virtual = var->xres;\n\tvar->yres_virtual = var->yres;\n\tvar->bits_per_pixel = bpp;\n}\n\nEXPORT_SYMBOL(sbusfb_fill_var);\n\nstatic unsigned long sbusfb_mmapsize(long size, unsigned long fbsize)\n{\n\tif (size == SBUS_MMAP_EMPTY) return 0;\n\tif (size >= 0) return size;\n\treturn fbsize * (-size);\n}\n\nint sbusfb_mmap_helper(struct sbus_mmap_map *map,\n\t\t       unsigned long physbase,\n\t\t       unsigned long fbsize,\n\t\t       unsigned long iospace,\n\t\t       struct vm_area_struct *vma)\n{\n\tunsigned int size, page, r, map_size;\n\tunsigned long map_offset = 0;\n\tunsigned long off;\n\tint i;\n                                        \n\tif (!(vma->vm_flags & (VM_SHARED | VM_MAYSHARE)))\n\t\treturn -EINVAL;\n\n\tsize = vma->vm_end - vma->vm_start;\n\tif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT))\n\t\treturn -EINVAL;\n\n\toff = vma->vm_pgoff << PAGE_SHIFT;\n\n\t/* VM_IO | VM_DONTEXPAND | VM_DONTDUMP are set by remap_pfn_range() */\n\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\n\t/* Each page, see which map applies */\n\tfor (page = 0; page < size; ){\n\t\tmap_size = 0;\n\t\tfor (i = 0; map[i].size; i++)\n\t\t\tif (map[i].voff == off+page) {\n\t\t\t\tmap_size = sbusfb_mmapsize(map[i].size, fbsize);\n#ifdef __sparc_v9__\n#define POFF_MASK\t(PAGE_MASK|0x1UL)\n#else\n#define POFF_MASK\t(PAGE_MASK)\n#endif\t\t\t\t\n\t\t\t\tmap_offset = (physbase + map[i].poff) & POFF_MASK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (!map_size) {\n\t\t\tpage += PAGE_SIZE;\n\t\t\tcontinue;\n\t\t}\n\t\tif (page + map_size > size)\n\t\t\tmap_size = size - page;\n\t\tr = io_remap_pfn_range(vma,\n\t\t\t\t\tvma->vm_start + page,\n\t\t\t\t\tMK_IOSPACE_PFN(iospace,\n\t\t\t\t\t\tmap_offset >> PAGE_SHIFT),\n\t\t\t\t\tmap_size,\n\t\t\t\t\tvma->vm_page_prot);\n\t\tif (r)\n\t\t\treturn -EAGAIN;\n\t\tpage += map_size;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(sbusfb_mmap_helper);\n\nint sbusfb_ioctl_helper(unsigned long cmd, unsigned long arg,\n\t\t\tstruct fb_info *info,\n\t\t\tint type, int fb_depth, unsigned long fb_size)\n{\n\tswitch(cmd) {\n\tcase FBIOGTYPE: {\n\t\tstruct fbtype __user *f = (struct fbtype __user *) arg;\n\n\t\tif (put_user(type, &f->fb_type) ||\n\t\t    __put_user(info->var.yres, &f->fb_height) ||\n\t\t    __put_user(info->var.xres, &f->fb_width) ||\n\t\t    __put_user(fb_depth, &f->fb_depth) ||\n\t\t    __put_user(0, &f->fb_cmsize) ||\n\t\t    __put_user(fb_size, &f->fb_cmsize))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\tcase FBIOPUTCMAP_SPARC: {\n\t\tstruct fbcmap __user *c = (struct fbcmap __user *) arg;\n\t\tstruct fb_cmap cmap;\n\t\tu16 red, green, blue;\n\t\tu8 red8, green8, blue8;\n\t\tunsigned char __user *ured;\n\t\tunsigned char __user *ugreen;\n\t\tunsigned char __user *ublue;\n\t\tunsigned int index, count, i;\n\n\t\tif (get_user(index, &c->index) ||\n\t\t    __get_user(count, &c->count) ||\n\t\t    __get_user(ured, &c->red) ||\n\t\t    __get_user(ugreen, &c->green) ||\n\t\t    __get_user(ublue, &c->blue))\n\t\t\treturn -EFAULT;\n\n\t\tcmap.len = 1;\n\t\tcmap.red = &red;\n\t\tcmap.green = &green;\n\t\tcmap.blue = &blue;\n\t\tcmap.transp = NULL;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tint err;\n\n\t\t\tif (get_user(red8, &ured[i]) ||\n\t\t\t    get_user(green8, &ugreen[i]) ||\n\t\t\t    get_user(blue8, &ublue[i]))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tred = red8 << 8;\n\t\t\tgreen = green8 << 8;\n\t\t\tblue = blue8 << 8;\n\n\t\t\tcmap.start = index + i;\n\t\t\terr = fb_set_cmap(&cmap, info);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\treturn 0;\n\t}\n\tcase FBIOGETCMAP_SPARC: {\n\t\tstruct fbcmap __user *c = (struct fbcmap __user *) arg;\n\t\tunsigned char __user *ured;\n\t\tunsigned char __user *ugreen;\n\t\tunsigned char __user *ublue;\n\t\tstruct fb_cmap *cmap = &info->cmap;\n\t\tunsigned int index, count, i;\n\t\tu8 red, green, blue;\n\n\t\tif (get_user(index, &c->index) ||\n\t\t    __get_user(count, &c->count) ||\n\t\t    __get_user(ured, &c->red) ||\n\t\t    __get_user(ugreen, &c->green) ||\n\t\t    __get_user(ublue, &c->blue))\n\t\t\treturn -EFAULT;\n\n\t\tif (index + count > cmap->len)\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tred = cmap->red[index + i] >> 8;\n\t\t\tgreen = cmap->green[index + i] >> 8;\n\t\t\tblue = cmap->blue[index + i] >> 8;\n\t\t\tif (put_user(red, &ured[i]) ||\n\t\t\t    put_user(green, &ugreen[i]) ||\n\t\t\t    put_user(blue, &ublue[i]))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t\treturn 0;\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\nEXPORT_SYMBOL(sbusfb_ioctl_helper);\n\n#ifdef CONFIG_COMPAT\nstatic int fbiogetputcmap(struct fb_info *info, unsigned int cmd, unsigned long arg)\n{\n\tstruct fbcmap32 __user *argp = (void __user *)arg;\n\tstruct fbcmap __user *p = compat_alloc_user_space(sizeof(*p));\n\tu32 addr;\n\tint ret;\n\n\tret = copy_in_user(p, argp, 2 * sizeof(int));\n\tret |= get_user(addr, &argp->red);\n\tret |= put_user(compat_ptr(addr), &p->red);\n\tret |= get_user(addr, &argp->green);\n\tret |= put_user(compat_ptr(addr), &p->green);\n\tret |= get_user(addr, &argp->blue);\n\tret |= put_user(compat_ptr(addr), &p->blue);\n\tif (ret)\n\t\treturn -EFAULT;\n\treturn info->fbops->fb_ioctl(info,\n\t\t\t(cmd == FBIOPUTCMAP32) ?\n\t\t\tFBIOPUTCMAP_SPARC : FBIOGETCMAP_SPARC,\n\t\t\t(unsigned long)p);\n}\n\nstatic int fbiogscursor(struct fb_info *info, unsigned long arg)\n{\n\tstruct fbcursor __user *p = compat_alloc_user_space(sizeof(*p));\n\tstruct fbcursor32 __user *argp =  (void __user *)arg;\n\tcompat_uptr_t addr;\n\tint ret;\n\n\tret = copy_in_user(p, argp,\n\t\t\t      2 * sizeof (short) + 2 * sizeof(struct fbcurpos));\n\tret |= copy_in_user(&p->size, &argp->size, sizeof(struct fbcurpos));\n\tret |= copy_in_user(&p->cmap, &argp->cmap, 2 * sizeof(int));\n\tret |= get_user(addr, &argp->cmap.red);\n\tret |= put_user(compat_ptr(addr), &p->cmap.red);\n\tret |= get_user(addr, &argp->cmap.green);\n\tret |= put_user(compat_ptr(addr), &p->cmap.green);\n\tret |= get_user(addr, &argp->cmap.blue);\n\tret |= put_user(compat_ptr(addr), &p->cmap.blue);\n\tret |= get_user(addr, &argp->mask);\n\tret |= put_user(compat_ptr(addr), &p->mask);\n\tret |= get_user(addr, &argp->image);\n\tret |= put_user(compat_ptr(addr), &p->image);\n\tif (ret)\n\t\treturn -EFAULT;\n\treturn info->fbops->fb_ioctl(info, FBIOSCURSOR, (unsigned long)p);\n}\n\nint sbusfb_compat_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase FBIOGTYPE:\n\tcase FBIOSATTR:\n\tcase FBIOGATTR:\n\tcase FBIOSVIDEO:\n\tcase FBIOGVIDEO:\n\tcase FBIOGCURSOR32:\t/* This is not implemented yet.\n\t\t\t\t   Later it should be converted... */\n\tcase FBIOSCURPOS:\n\tcase FBIOGCURPOS:\n\tcase FBIOGCURMAX:\n\t\treturn info->fbops->fb_ioctl(info, cmd, arg);\n\tcase FBIOPUTCMAP32:\n\t\treturn fbiogetputcmap(info, cmd, arg);\n\tcase FBIOGETCMAP32:\n\t\treturn fbiogetputcmap(info, cmd, arg);\n\tcase FBIOSCURSOR32:\n\t\treturn fbiogscursor(info, arg);\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n}\nEXPORT_SYMBOL(sbusfb_compat_ioctl);\n#endif\n"], "filenames": ["drivers/video/fbdev/sbuslib.c"], "buggy_code_start_loc": [125], "buggy_code_end_loc": [165], "fixing_code_start_loc": [125], "fixing_code_end_loc": [165], "type": "CWE-200", "message": "In the function sbusfb_ioctl_helper() in drivers/video/fbdev/sbuslib.c in the Linux kernel through 4.15, an integer signedness error allows arbitrary information leakage for the FBIOPUTCMAP_SPARC and FBIOGETCMAP_SPARC commands.", "other": {"cve": {"id": "CVE-2018-6412", "sourceIdentifier": "cve@mitre.org", "published": "2018-01-31T07:29:00.223", "lastModified": "2019-03-20T19:04:40.517", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In the function sbusfb_ioctl_helper() in drivers/video/fbdev/sbuslib.c in the Linux kernel through 4.15, an integer signedness error allows arbitrary information leakage for the FBIOPUTCMAP_SPARC and FBIOGETCMAP_SPARC commands."}, {"lang": "es", "value": "En la funci\u00f3n sbusfb_ioctl_helper() en drivers/video/fbdev/sbuslib.c en el kernel de Linux hasta la versi\u00f3n 4.15, un error en la propiedad signedness de un n\u00famero entero permite la fuga de informaci\u00f3n arbitraria para los comandos FBIOPUTCMAP_SPARC y FBIOGETCMAP_SPARC."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.15", "matchCriteriaId": "EF0EDA1F-A5F9-4FB0-BE14-900054FAB86C"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=250c6c49e3b68756b14983c076183568636e2bde", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/250c6c49e3b68756b14983c076183568636e2bde", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://marc.info/?l=linux-fbdev&m=151734425901499&w=2", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/250c6c49e3b68756b14983c076183568636e2bde"}}