{"buggy_code": ["<?php\n/**\n * @author Bj\u00f6rn Schie\u00dfle <schiessle@owncloud.com>\n * @author Joas Schilling <nickvergessen@owncloud.com>\n * @author Morris Jobke <hey@morrisjobke.de>\n * @author Robin Appelman <icewind@owncloud.com>\n * @author Thomas M\u00fcller <thomas.mueller@tmit.eu>\n * @author Vincent Petry <pvince81@owncloud.com>\n *\n * @copyright Copyright (c) 2016, ownCloud, Inc.\n * @license AGPL-3.0\n *\n * This code is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License, version 3,\n * as published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License, version 3,\n * along with this program.  If not, see <http://www.gnu.org/licenses/>\n *\n */\n\nnamespace OCA\\DAV\\Connector\\Sabre;\n\nuse OCA\\DAV\\Connector\\Sabre\\Exception\\Forbidden;\nuse OCA\\DAV\\Connector\\Sabre\\Exception\\InvalidPath;\nuse OCA\\DAV\\Connector\\Sabre\\Exception\\FileLocked;\nuse OC\\Files\\FileInfo;\nuse OC\\Files\\Mount\\MoveableMount;\nuse OCP\\Files\\ForbiddenException;\nuse OCP\\Files\\StorageInvalidException;\nuse OCP\\Files\\StorageNotAvailableException;\nuse OCP\\Lock\\LockedException;\n\nclass ObjectTree extends \\Sabre\\DAV\\Tree {\n\n\t/**\n\t * @var \\OC\\Files\\View\n\t */\n\tprotected $fileView;\n\n\t/**\n\t * @var  \\OCP\\Files\\Mount\\IMountManager\n\t */\n\tprotected $mountManager;\n\n\t/**\n\t * Creates the object\n\t */\n\tpublic function __construct() {\n\t}\n\n\t/**\n\t * @param \\Sabre\\DAV\\INode $rootNode\n\t * @param \\OC\\Files\\View $view\n\t * @param  \\OCP\\Files\\Mount\\IMountManager $mountManager\n\t */\n\tpublic function init(\\Sabre\\DAV\\INode $rootNode, \\OC\\Files\\View $view, \\OCP\\Files\\Mount\\IMountManager $mountManager) {\n\t\t$this->rootNode = $rootNode;\n\t\t$this->fileView = $view;\n\t\t$this->mountManager = $mountManager;\n\t}\n\n\t/**\n\t * If the given path is a chunked file name, converts it\n\t * to the real file name. Only applies if the OC-CHUNKED header\n\t * is present.\n\t *\n\t * @param string $path chunk file path to convert\n\t * \n\t * @return string path to real file\n\t */\n\tprivate function resolveChunkFile($path) {\n\t\tif (isset($_SERVER['HTTP_OC_CHUNKED'])) {\n\t\t\t// resolve to real file name to find the proper node\n\t\t\tlist($dir, $name) = \\Sabre\\HTTP\\URLUtil::splitPath($path);\n\t\t\tif ($dir == '/' || $dir == '.') {\n\t\t\t\t$dir = '';\n\t\t\t}\n\n\t\t\t$info = \\OC_FileChunking::decodeName($name);\n\t\t\t// only replace path if it was really the chunked file\n\t\t\tif (isset($info['transferid'])) {\n\t\t\t\t// getNodePath is called for multiple nodes within a chunk\n\t\t\t\t// upload call\n\t\t\t\t$path = $dir . '/' . $info['name'];\n\t\t\t\t$path = ltrim($path, '/');\n\t\t\t}\n\t\t}\n\t\treturn $path;\n\t}\n\n\tpublic function cacheNode(Node $node) {\n\t\t$this->cache[trim($node->getPath(), '/')] = $node;\n\t}\n\n\t/**\n\t * Returns the INode object for the requested path\n\t *\n\t * @param string $path\n\t * @return \\Sabre\\DAV\\INode\n\t * @throws InvalidPath\n\t * @throws \\Sabre\\DAV\\Exception\\Locked\n\t * @throws \\Sabre\\DAV\\Exception\\NotFound\n\t * @throws \\Sabre\\DAV\\Exception\\ServiceUnavailable\n\t */\n\tpublic function getNodeForPath($path) {\n\t\tif (!$this->fileView) {\n\t\t\tthrow new \\Sabre\\DAV\\Exception\\ServiceUnavailable('filesystem not setup');\n\t\t}\n\n\t\t$path = trim($path, '/');\n\n\t\tif (isset($this->cache[$path])) {\n\t\t\treturn $this->cache[$path];\n\t\t}\n\n\t\tif ($path) {\n\t\t\ttry {\n\t\t\t\t$this->fileView->verifyPath($path, basename($path));\n\t\t\t} catch (\\OCP\\Files\\InvalidPathException $ex) {\n\t\t\t\tthrow new InvalidPath($ex->getMessage());\n\t\t\t}\n\t\t}\n\n\t\t// Is it the root node?\n\t\tif (!strlen($path)) {\n\t\t\treturn $this->rootNode;\n\t\t}\n\n\t\tif (pathinfo($path, PATHINFO_EXTENSION) === 'part') {\n\t\t\t// read from storage\n\t\t\t$absPath = $this->fileView->getAbsolutePath($path);\n\t\t\t$mount = $this->fileView->getMount($path);\n\t\t\t$storage = $mount->getStorage();\n\t\t\t$internalPath = $mount->getInternalPath($absPath);\n\t\t\tif ($storage && $storage->file_exists($internalPath)) {\n\t\t\t\t/**\n\t\t\t\t * @var \\OC\\Files\\Storage\\Storage $storage\n\t\t\t\t */\n\t\t\t\t// get data directly\n\t\t\t\t$data = $storage->getMetaData($internalPath);\n\t\t\t\t$info = new FileInfo($absPath, $storage, $internalPath, $data, $mount);\n\t\t\t} else {\n\t\t\t\t$info = null;\n\t\t\t}\n\t\t} else {\n\t\t\t// resolve chunk file name to real name, if applicable\n\t\t\t$path = $this->resolveChunkFile($path);\n\n\t\t\t// read from cache\n\t\t\ttry {\n\t\t\t\t$info = $this->fileView->getFileInfo($path);\n\t\t\t} catch (StorageNotAvailableException $e) {\n\t\t\t\tthrow new \\Sabre\\DAV\\Exception\\ServiceUnavailable('Storage not available');\n\t\t\t} catch (StorageInvalidException $e) {\n\t\t\t\tthrow new \\Sabre\\DAV\\Exception\\NotFound('Storage ' . $path . ' is invalid');\n\t\t\t} catch (LockedException $e) {\n\t\t\t\tthrow new \\Sabre\\DAV\\Exception\\Locked();\n\t\t\t}\n\t\t}\n\n\t\tif (!$info) {\n\t\t\tthrow new \\Sabre\\DAV\\Exception\\NotFound('File with name ' . $path . ' could not be located');\n\t\t}\n\n\t\tif ($info->getType() === 'dir') {\n\t\t\t$node = new \\OCA\\DAV\\Connector\\Sabre\\Directory($this->fileView, $info, $this);\n\t\t} else {\n\t\t\t$node = new \\OCA\\DAV\\Connector\\Sabre\\File($this->fileView, $info);\n\t\t}\n\n\t\t$this->cache[$path] = $node;\n\t\treturn $node;\n\n\t}\n\n\t/**\n\t * Moves a file from one location to another\n\t *\n\t * @param string $sourcePath The path to the file which should be moved\n\t * @param string $destinationPath The full destination path, so not just the destination parent node\n\t * @throws \\Sabre\\DAV\\Exception\\BadRequest\n\t * @throws \\Sabre\\DAV\\Exception\\ServiceUnavailable\n\t * @throws \\Sabre\\DAV\\Exception\\Forbidden\n\t * @return int\n\t */\n\tpublic function move($sourcePath, $destinationPath) {\n\t\tif (!$this->fileView) {\n\t\t\tthrow new \\Sabre\\DAV\\Exception\\ServiceUnavailable('filesystem not setup');\n\t\t}\n\n\t\t$targetNodeExists = $this->nodeExists($destinationPath);\n\t\t$sourceNode = $this->getNodeForPath($sourcePath);\n\t\tif ($sourceNode instanceof \\Sabre\\DAV\\ICollection && $targetNodeExists) {\n\t\t\tthrow new \\Sabre\\DAV\\Exception\\Forbidden('Could not copy directory ' . $sourceNode->getName() . ', target exists');\n\t\t}\n\t\tlist($sourceDir,) = \\Sabre\\HTTP\\URLUtil::splitPath($sourcePath);\n\t\tlist($destinationDir,) = \\Sabre\\HTTP\\URLUtil::splitPath($destinationPath);\n\n\t\t$isMovableMount = false;\n\t\t$sourceMount = $this->mountManager->find($this->fileView->getAbsolutePath($sourcePath));\n\t\t$internalPath = $sourceMount->getInternalPath($this->fileView->getAbsolutePath($sourcePath));\n\t\tif ($sourceMount instanceof MoveableMount && $internalPath === '') {\n\t\t\t$isMovableMount = true;\n\t\t}\n\n\t\ttry {\n\t\t\t$sameFolder = ($sourceDir === $destinationDir);\n\t\t\t// if we're overwriting or same folder\n\t\t\tif ($targetNodeExists || $sameFolder) {\n\t\t\t\t// note that renaming a share mount point is always allowed\n\t\t\t\tif (!$this->fileView->isUpdatable($destinationDir) && !$isMovableMount) {\n\t\t\t\t\tthrow new \\Sabre\\DAV\\Exception\\Forbidden();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!$this->fileView->isCreatable($destinationDir)) {\n\t\t\t\t\tthrow new \\Sabre\\DAV\\Exception\\Forbidden();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!$sameFolder) {\n\t\t\t\t// moving to a different folder, source will be gone, like a deletion\n\t\t\t\t// note that moving a share mount point is always allowed\n\t\t\t\tif (!$this->fileView->isDeletable($sourcePath) && !$isMovableMount) {\n\t\t\t\t\tthrow new \\Sabre\\DAV\\Exception\\Forbidden();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$fileName = basename($destinationPath);\n\t\t\ttry {\n\t\t\t\t$this->fileView->verifyPath($destinationDir, $fileName);\n\t\t\t} catch (\\OCP\\Files\\InvalidPathException $ex) {\n\t\t\t\tthrow new InvalidPath($ex->getMessage());\n\t\t\t}\n\n\t\t\t$renameOkay = $this->fileView->rename($sourcePath, $destinationPath);\n\t\t\tif (!$renameOkay) {\n\t\t\t\tthrow new \\Sabre\\DAV\\Exception\\Forbidden('');\n\t\t\t}\n\t\t} catch (StorageNotAvailableException $e) {\n\t\t\tthrow new \\Sabre\\DAV\\Exception\\ServiceUnavailable($e->getMessage());\n\t\t} catch (ForbiddenException $ex) {\n\t\t\tthrow new Forbidden($ex->getMessage(), $ex->getRetry());\n\t\t} catch (LockedException $e) {\n\t\t\tthrow new FileLocked($e->getMessage(), $e->getCode(), $e);\n\t\t}\n\n\t\t$this->markDirty($sourceDir);\n\t\t$this->markDirty($destinationDir);\n\n\t}\n\n\t/**\n\t * Copies a file or directory.\n\t *\n\t * This method must work recursively and delete the destination\n\t * if it exists\n\t *\n\t * @param string $source\n\t * @param string $destination\n\t * @throws \\Sabre\\DAV\\Exception\\ServiceUnavailable\n\t * @return void\n\t */\n\tpublic function copy($source, $destination) {\n\t\tif (!$this->fileView) {\n\t\t\tthrow new \\Sabre\\DAV\\Exception\\ServiceUnavailable('filesystem not setup');\n\t\t}\n\n\t\t// this will trigger existence check\n\t\t$this->getNodeForPath($source);\n\n\t\tlist($destinationDir, $destinationName) = \\Sabre\\HTTP\\URLUtil::splitPath($destination);\n\t\ttry {\n\t\t\t$this->fileView->verifyPath($destinationDir, $destinationName);\n\t\t} catch (\\OCP\\Files\\InvalidPathException $ex) {\n\t\t\tthrow new InvalidPath($ex->getMessage());\n\t\t}\n\n\t\ttry {\n\t\t\t$this->fileView->copy($source, $destination);\n\t\t} catch (StorageNotAvailableException $e) {\n\t\t\tthrow new \\Sabre\\DAV\\Exception\\ServiceUnavailable($e->getMessage());\n\t\t} catch (ForbiddenException $ex) {\n\t\t\tthrow new Forbidden($ex->getMessage(), $ex->getRetry());\n\t\t} catch (LockedException $e) {\n\t\t\tthrow new FileLocked($e->getMessage(), $e->getCode(), $e);\n\t\t}\n\n\t\tlist($destinationDir,) = \\Sabre\\HTTP\\URLUtil::splitPath($destination);\n\t\t$this->markDirty($destinationDir);\n\t}\n}\n", "<?php\n/**\n * @author Joas Schilling <nickvergessen@owncloud.com>\n * @author Morris Jobke <hey@morrisjobke.de>\n * @author Robin Appelman <icewind@owncloud.com>\n * @author Thomas M\u00fcller <thomas.mueller@tmit.eu>\n * @author Vincent Petry <pvince81@owncloud.com>\n *\n * @copyright Copyright (c) 2016, ownCloud, Inc.\n * @license AGPL-3.0\n *\n * This code is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License, version 3,\n * as published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License, version 3,\n * along with this program.  If not, see <http://www.gnu.org/licenses/>\n *\n */\n\nnamespace OCA\\DAV\\Tests\\Unit\\Connector\\Sabre;\n\n\nuse OC\\Files\\FileInfo;\nuse OC\\Files\\Storage\\Temporary;\n\nclass TestDoubleFileView extends \\OC\\Files\\View {\n\n\tpublic function __construct($updatables, $deletables, $canRename = true) {\n\t\t$this->updatables = $updatables;\n\t\t$this->deletables = $deletables;\n\t\t$this->canRename = $canRename;\n\t}\n\n\tpublic function isUpdatable($path) {\n\t\treturn $this->updatables[$path];\n\t}\n\n\tpublic function isCreatable($path) {\n\t\treturn $this->updatables[$path];\n\t}\n\n\tpublic function isDeletable($path) {\n\t\treturn $this->deletables[$path];\n\t}\n\n\tpublic function rename($path1, $path2) {\n\t\treturn $this->canRename;\n\t}\n\n\tpublic function getRelativePath($path) {\n\t\treturn $path;\n\t}\n}\n\n/**\n * Class ObjectTree\n *\n * @group DB\n *\n * @package OCA\\DAV\\Tests\\Unit\\Connector\\Sabre\n */\nclass ObjectTree extends \\Test\\TestCase {\n\n\t/**\n\t * @dataProvider moveFailedProvider\n\t * @expectedException \\Sabre\\DAV\\Exception\\Forbidden\n\t */\n\tpublic function testMoveFailed($source, $destination, $updatables, $deletables) {\n\t\t$this->moveTest($source, $destination, $updatables, $deletables);\n\t}\n\n\t/**\n\t * @dataProvider moveSuccessProvider\n\t */\n\tpublic function testMoveSuccess($source, $destination, $updatables, $deletables) {\n\t\t$this->moveTest($source, $destination, $updatables, $deletables);\n\t\t$this->assertTrue(true);\n\t}\n\n\t/**\n\t * @dataProvider moveFailedInvalidCharsProvider\n\t * @expectedException \\OCA\\DAV\\Connector\\Sabre\\Exception\\InvalidPath\n\t */\n\tpublic function testMoveFailedInvalidChars($source, $destination, $updatables, $deletables) {\n\t\t$this->moveTest($source, $destination, $updatables, $deletables);\n\t}\n\n\tfunction moveFailedInvalidCharsProvider() {\n\t\treturn array(\n\t\t\tarray('a/b', 'a/*', array('a' => true, 'a/b' => true, 'a/c*' => false), array()),\n\t\t);\n\t}\n\n\tfunction moveFailedProvider() {\n\t\treturn array(\n\t\t\tarray('a/b', 'a/c', array('a' => false, 'a/b' => false, 'a/c' => false), array()),\n\t\t\tarray('a/b', 'b/b', array('a' => false, 'a/b' => false, 'b' => false, 'b/b' => false), array()),\n\t\t\tarray('a/b', 'b/b', array('a' => false, 'a/b' => true, 'b' => false, 'b/b' => false), array()),\n\t\t\tarray('a/b', 'b/b', array('a' => true, 'a/b' => true, 'b' => false, 'b/b' => false), array()),\n\t\t\tarray('a/b', 'b/b', array('a' => true, 'a/b' => true, 'b' => true, 'b/b' => false), array('a/b' => false)),\n\t\t\tarray('a/b', 'a/c', array('a' => false, 'a/b' => true, 'a/c' => false), array()),\n\t\t);\n\t}\n\n\tfunction moveSuccessProvider() {\n\t\treturn array(\n\t\t\tarray('a/b', 'b/b', array('a' => true, 'a/b' => true, 'b' => true, 'b/b' => false), array('a/b' => true)),\n\t\t\t// older files with special chars can still be renamed to valid names\n\t\t\tarray('a/b*', 'b/b', array('a' => true, 'a/b*' => true, 'b' => true, 'b/b' => false), array('a/b*' => true)),\n\t\t);\n\t}\n\n\t/**\n\t * @param $source\n\t * @param $destination\n\t * @param $updatables\n\t */\n\tprivate function moveTest($source, $destination, $updatables, $deletables) {\n\t\t$view = new TestDoubleFileView($updatables, $deletables);\n\n\t\t$info = new FileInfo('', null, null, array(), null);\n\n\t\t$rootDir = new \\OCA\\DAV\\Connector\\Sabre\\Directory($view, $info);\n\t\t$objectTree = $this->getMock('\\OCA\\DAV\\Connector\\Sabre\\ObjectTree',\n\t\t\tarray('nodeExists', 'getNodeForPath'),\n\t\t\tarray($rootDir, $view));\n\n\t\t$objectTree->expects($this->once())\n\t\t\t->method('getNodeForPath')\n\t\t\t->with($this->identicalTo($source))\n\t\t\t->will($this->returnValue(false));\n\n\t\t/** @var $objectTree \\OCA\\DAV\\Connector\\Sabre\\ObjectTree */\n\t\t$mountManager = \\OC\\Files\\Filesystem::getMountManager();\n\t\t$objectTree->init($rootDir, $view, $mountManager);\n\t\t$objectTree->move($source, $destination);\n\t}\n\n\t/**\n\t * @dataProvider nodeForPathProvider\n\t */\n\tpublic function testGetNodeForPath(\n\t\t$inputFileName,\n\t\t$fileInfoQueryPath,\n\t\t$outputFileName,\n\t\t$type,\n\t\t$enableChunkingHeader\n\t) {\n\n\t\tif ($enableChunkingHeader) {\n\t\t\t$_SERVER['HTTP_OC_CHUNKED'] = true;\n\t\t}\n\n\t\t$rootNode = $this->getMockBuilder('\\OCA\\DAV\\Connector\\Sabre\\Directory')\n\t\t\t->disableOriginalConstructor()\n\t\t\t->getMock();\n\t\t$mountManager = $this->getMock('\\OC\\Files\\Mount\\Manager');\n\t\t$view = $this->getMock('\\OC\\Files\\View');\n\t\t$fileInfo = $this->getMock('\\OCP\\Files\\FileInfo');\n\t\t$fileInfo->expects($this->once())\n\t\t\t->method('getType')\n\t\t\t->will($this->returnValue($type));\n\t\t$fileInfo->expects($this->once())\n\t\t\t->method('getName')\n\t\t\t->will($this->returnValue($outputFileName));\n\n\t\t$view->expects($this->once())\n\t\t\t->method('getFileInfo')\n\t\t\t->with($fileInfoQueryPath)\n\t\t\t->will($this->returnValue($fileInfo));\n\n\t\t$tree = new \\OCA\\DAV\\Connector\\Sabre\\ObjectTree();\n\t\t$tree->init($rootNode, $view, $mountManager);\n\n\t\t$node = $tree->getNodeForPath($inputFileName);\n\n\t\t$this->assertNotNull($node);\n\t\t$this->assertEquals($outputFileName, $node->getName());\n\n\t\tif ($type === 'file') {\n\t\t\t$this->assertTrue($node instanceof \\OCA\\DAV\\Connector\\Sabre\\File);\n\t\t} else {\n\t\t\t$this->assertTrue($node instanceof \\OCA\\DAV\\Connector\\Sabre\\Directory);\n\t\t}\n\n\t\tunset($_SERVER['HTTP_OC_CHUNKED']);\n\t}\n\n\tfunction nodeForPathProvider() {\n\t\treturn array(\n\t\t\t// regular file\n\t\t\tarray(\n\t\t\t\t'regularfile.txt',\n\t\t\t\t'regularfile.txt',\n\t\t\t\t'regularfile.txt',\n\t\t\t\t'file',\n\t\t\t\tfalse\n\t\t\t),\n\t\t\t// regular directory\n\t\t\tarray(\n\t\t\t\t'regulardir',\n\t\t\t\t'regulardir',\n\t\t\t\t'regulardir',\n\t\t\t\t'dir',\n\t\t\t\tfalse\n\t\t\t),\n\t\t\t// regular file with chunking\n\t\t\tarray(\n\t\t\t\t'regularfile.txt',\n\t\t\t\t'regularfile.txt',\n\t\t\t\t'regularfile.txt',\n\t\t\t\t'file',\n\t\t\t\ttrue\n\t\t\t),\n\t\t\t// regular directory with chunking\n\t\t\tarray(\n\t\t\t\t'regulardir',\n\t\t\t\t'regulardir',\n\t\t\t\t'regulardir',\n\t\t\t\t'dir',\n\t\t\t\ttrue\n\t\t\t),\n\t\t\t// file with chunky file name\n\t\t\tarray(\n\t\t\t\t'regularfile.txt-chunking-123566789-10-1',\n\t\t\t\t'regularfile.txt',\n\t\t\t\t'regularfile.txt',\n\t\t\t\t'file',\n\t\t\t\ttrue\n\t\t\t),\n\t\t\t// regular file in subdir\n\t\t\tarray(\n\t\t\t\t'subdir/regularfile.txt',\n\t\t\t\t'subdir/regularfile.txt',\n\t\t\t\t'regularfile.txt',\n\t\t\t\t'file',\n\t\t\t\tfalse\n\t\t\t),\n\t\t\t// regular directory in subdir\n\t\t\tarray(\n\t\t\t\t'subdir/regulardir',\n\t\t\t\t'subdir/regulardir',\n\t\t\t\t'regulardir',\n\t\t\t\t'dir',\n\t\t\t\tfalse\n\t\t\t),\n\t\t\t// file with chunky file name in subdir\n\t\t\tarray(\n\t\t\t\t'subdir/regularfile.txt-chunking-123566789-10-1',\n\t\t\t\t'subdir/regularfile.txt',\n\t\t\t\t'regularfile.txt',\n\t\t\t\t'file',\n\t\t\t\ttrue\n\t\t\t),\n\t\t);\n\t}\n\n\t/**\n\t * @expectedException \\OCA\\DAV\\Connector\\Sabre\\Exception\\InvalidPath\n\t */\n\tpublic function testGetNodeForPathInvalidPath() {\n\t\t$path = '/foo\\bar';\n\n\n\t\t$storage = new Temporary([]);\n\n\t\t$view = $this->getMock('\\OC\\Files\\View', ['resolvePath']);\n\t\t$view->expects($this->once())\n\t\t\t->method('resolvePath')\n\t\t\t->will($this->returnCallback(function($path) use ($storage){\n\t\t\treturn [$storage, ltrim($path, '/')];\n\t\t}));\n\n\t\t$rootNode = $this->getMockBuilder('\\OCA\\DAV\\Connector\\Sabre\\Directory')\n\t\t\t->disableOriginalConstructor()\n\t\t\t->getMock();\n\t\t$mountManager = $this->getMock('\\OC\\Files\\Mount\\Manager');\n\n\t\t$tree = new \\OCA\\DAV\\Connector\\Sabre\\ObjectTree();\n\t\t$tree->init($rootNode, $view, $mountManager);\n\n\t\t$tree->getNodeForPath($path);\n\t}\n\n\tpublic function testGetNodeForPathRoot() {\n\t\t$path = '/';\n\n\n\t\t$storage = new Temporary([]);\n\n\t\t$view = $this->getMock('\\OC\\Files\\View', ['resolvePath']);\n\t\t$view->expects($this->any())\n\t\t\t->method('resolvePath')\n\t\t\t->will($this->returnCallback(function ($path) use ($storage) {\n\t\t\t\treturn [$storage, ltrim($path, '/')];\n\t\t\t}));\n\n\t\t$rootNode = $this->getMockBuilder('\\OCA\\DAV\\Connector\\Sabre\\Directory')\n\t\t\t->disableOriginalConstructor()\n\t\t\t->getMock();\n\t\t$mountManager = $this->getMock('\\OC\\Files\\Mount\\Manager');\n\n\t\t$tree = new \\OCA\\DAV\\Connector\\Sabre\\ObjectTree();\n\t\t$tree->init($rootNode, $view, $mountManager);\n\n\t\t$this->assertInstanceOf('\\Sabre\\DAV\\INode', $tree->getNodeForPath($path));\n\t}\n\n\t/**\n\t * @expectedException \\Sabre\\DAV\\Exception\\Forbidden\n\t * @expectedExceptionMessage Could not copy directory nameOfSourceNode, target exists\n\t */\n\tpublic function testFailingMove() {\n\t\t$source = 'a/b';\n\t\t$destination = 'b/b';\n\t\t$updatables = array('a' => true, 'a/b' => true, 'b' => true, 'b/b' => false);\n\t\t$deletables = array('a/b' => true);\n\n\t\t$view = new TestDoubleFileView($updatables, $deletables);\n\n\t\t$info = new FileInfo('', null, null, array(), null);\n\n\t\t$rootDir = new \\OCA\\DAV\\Connector\\Sabre\\Directory($view, $info);\n\t\t$objectTree = $this->getMock('\\OCA\\DAV\\Connector\\Sabre\\ObjectTree',\n\t\t\tarray('nodeExists', 'getNodeForPath'),\n\t\t\tarray($rootDir, $view));\n\n\t\t$sourceNode = $this->getMockBuilder('\\Sabre\\DAV\\ICollection')\n\t\t\t->disableOriginalConstructor()\n\t\t\t->getMock();\n\t\t$sourceNode->expects($this->once())\n\t\t\t->method('getName')\n\t\t\t->will($this->returnValue('nameOfSourceNode'));\n\n\t\t$objectTree->expects($this->once())\n\t\t\t->method('nodeExists')\n\t\t\t->with($this->identicalTo($destination))\n\t\t\t->will($this->returnValue(true));\n\t\t$objectTree->expects($this->once())\n\t\t\t->method('getNodeForPath')\n\t\t\t->with($this->identicalTo($source))\n\t\t\t->will($this->returnValue($sourceNode));\n\n\t\t/** @var $objectTree \\OCA\\DAV\\Connector\\Sabre\\ObjectTree */\n\t\t$mountManager = \\OC\\Files\\Filesystem::getMountManager();\n\t\t$objectTree->init($rootDir, $view, $mountManager);\n\t\t$objectTree->move($source, $destination);\n\t}\n}\n", "<?php\n\nuse Behat\\Behat\\Context\\Context;\nuse Behat\\Behat\\Context\\SnippetAcceptingContext;\nuse GuzzleHttp\\Client as GClient;\nuse GuzzleHttp\\Message\\ResponseInterface;\nuse Sabre\\DAV\\Client as SClient;\n\nrequire __DIR__ . '/../../vendor/autoload.php';\n\n\ntrait WebDav {\n\t/** @var string*/\n\tprivate $davPath = \"remote.php/webdav\";\n\t/** @var ResponseInterface */\n\tprivate $response;\n\n\t/**\n\t * @Given /^using dav path \"([^\"]*)\"$/\n\t */\n\tpublic function usingDavPath($davPath) {\n\t\t$this->davPath = $davPath;\n\t}\n\n\tpublic function makeDavRequest($user, $method, $path, $headers, $body = null){\n\t\t$fullUrl = substr($this->baseUrl, 0, -4) . $this->davPath . \"$path\";\n\t\t$client = new GClient();\n\t\t$options = [];\n\t\tif ($user === 'admin') {\n\t\t\t$options['auth'] = $this->adminUser;\n\t\t} else {\n\t\t\t$options['auth'] = [$user, $this->regularUser];\n\t\t}\n\t\t$request = $client->createRequest($method, $fullUrl, $options);\n\t\tif (!is_null($headers)){\n\t\t\tforeach ($headers as $key => $value) {\n\t\t\t\t$request->addHeader($key, $value);\n\t\t\t}\n\t\t}\n\n\t\tif (!is_null($body)) {\n\t\t\t$request->setBody($body);\n\t\t}\n\n\t\treturn $client->send($request);\n\t}\n\n\t/**\n\t * @Given /^User \"([^\"]*)\" moved file \"([^\"]*)\" to \"([^\"]*)\"$/\n\t */\n\tpublic function userMovedFile($user, $fileSource, $fileDestination){\n\t\t$fullUrl = substr($this->baseUrl, 0, -4) . $this->davPath;\n\t\t$headers['Destination'] = $fullUrl . $fileDestination;\n\t\t$this->response = $this->makeDavRequest($user, \"MOVE\", $fileSource, $headers);\n\t\tPHPUnit_Framework_Assert::assertEquals(201, $this->response->getStatusCode());\n\t}\n\n\t/**\n\t * @When /^User \"([^\"]*)\" moves file \"([^\"]*)\" to \"([^\"]*)\"$/\n\t */\n\tpublic function userMovesFile($user, $fileSource, $fileDestination){\n\t\t$fullUrl = substr($this->baseUrl, 0, -4) . $this->davPath;\n\t\t$headers['Destination'] = $fullUrl . $fileDestination;\n\t\t$this->response = $this->makeDavRequest($user, \"MOVE\", $fileSource, $headers);\n\t}\n\n\t/**\n\t * @When /^Downloading file \"([^\"]*)\" with range \"([^\"]*)\"$/\n\t */\n\tpublic function downloadFileWithRange($fileSource, $range){\n\t\t$fullUrl = substr($this->baseUrl, 0, -4) . $this->davPath;\n\t\t$headers['Range'] = $range;\n\t\t$this->response = $this->makeDavRequest($this->currentUser, \"GET\", $fileSource, $headers);\n\t}\n\n\t/**\n\t * @When /^Downloading last public shared file with range \"([^\"]*)\"$/\n\t */\n\tpublic function downloadPublicFileWithRange($range){\n\t\t$token = $this->lastShareData->data->token;\n\t\t$fullUrl = substr($this->baseUrl, 0, -4) . \"public.php/webdav\";\n\t\t$headers['Range'] = $range;\n\n\t\t$client = new GClient();\n\t\t$options = [];\n\t\t$options['auth'] = [$token, \"\"];\n\n\t\t$request = $client->createRequest(\"GET\", $fullUrl, $options);\n\t\t$request->addHeader('Range', $range);\n\n\t\t$this->response = $client->send($request);\n\t}\n\n\t/**\n\t * @Then /^Downloaded content should be \"([^\"]*)\"$/\n\t */\n\tpublic function downloadedContentShouldBe($content){\n\t\tPHPUnit_Framework_Assert::assertEquals($content, (string)$this->response->getBody());\n\t}\n\n\t/**\n\t * @Then /^Downloaded content when downloading file \"([^\"]*)\" with range \"([^\"]*)\" should be \"([^\"]*)\"$/\n\t */\n\tpublic function downloadedContentWhenDownloadindShouldBe($fileSource, $range, $content){\n\t\t$this->downloadFileWithRange($fileSource, $range);\n\t\t$this->downloadedContentShouldBe($content);\n\t}\n\n\t/**\n\t * @When Downloading file :fileName\n\t */\n\tpublic function downloadingFile($fileName) {\n\t\t$this->response = $this->makeDavRequest($this->currentUser, 'GET', $fileName, []);\n\t}\n\n\t/**\n\t * @Then The following headers should be set\n\t */\n\tpublic function theFollowingHeadersShouldBeSet(\\Behat\\Gherkin\\Node\\TableNode $table) {\n\t\tforeach($table->getTable() as $header) {\n\t\t\t$headerName = $header[0];\n\t\t\t$expectedHeaderValue = $header[1];\n\t\t\t$returnedHeader = $this->response->getHeader($headerName);\n\t\t\tif($returnedHeader !== $expectedHeaderValue) {\n\t\t\t\tthrow new \\Exception(\n\t\t\t\t\tsprintf(\n\t\t\t\t\t\t\"Expected value '%s' for header '%s', got '%s'\",\n\t\t\t\t\t\t$expectedHeaderValue,\n\t\t\t\t\t\t$headerName,\n\t\t\t\t\t\t$returnedHeader\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @Then Downloaded content should start with :start\n\t */\n\tpublic function downloadedContentShouldStartWith($start) {\n\t\tif(strpos($this->response->getBody()->getContents(), $start) !== 0) {\n\t\t\tthrow new \\Exception(\n\t\t\t\tsprintf(\n\t\t\t\t\t\"Expected '%s', got '%s'\",\n\t\t\t\t\t$start,\n\t\t\t\t\t$this->response->getBody()->getContents()\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * @Then /^as \"([^\"]*)\" gets properties of folder \"([^\"]*)\" with$/\n\t * @param \\Behat\\Gherkin\\Node\\TableNode|null $propertiesTable\n\t */\n\tpublic function asGetsPropertiesOfFolderWith($user, $path, $propertiesTable) {\n\t\t$properties = null;\n\t\tif ($propertiesTable instanceof \\Behat\\Gherkin\\Node\\TableNode) {\n\t\t\tforeach ($propertiesTable->getRows() as $row) {\n\t\t\t\t$properties[] = $row[0];\n\t\t\t}\n\t\t}\n\t\t$this->response = $this->listFolder($user, $path, 0, $properties);\n\t}\n\n\t/**\n\t * @Then the single response should contain a property :key with value :value\n\t */\n\tpublic function theSingleResponseShouldContainAPropertyWithValue($key, $expectedValue) {\n\t\t$keys = $this->response;\n\t\tif (!array_key_exists($key, $keys)) {\n\t\t\tthrow new \\Exception(\"Cannot find property \\\"$key\\\" with \\\"$expectedValue\\\"\");\n\t\t}\n\n\t\t$value = $keys[$key];\n\t\tif ($value !== $expectedValue) {\n\t\t\tthrow new \\Exception(\"Property \\\"$key\\\" found with value \\\"$value\\\", expected \\\"$expectedValue\\\"\");\n\t\t}\n\t}\n\n\t/**\n\t * @Then the response should contain a share-types property with\n\t */\n\tpublic function theResponseShouldContainAShareTypesPropertyWith($table)\n\t{\n\t\t$keys = $this->response;\n\t\tif (!array_key_exists('{http://owncloud.org/ns}share-types', $keys)) {\n\t\t\tthrow new \\Exception(\"Cannot find property \\\"{http://owncloud.org/ns}share-types\\\"\");\n\t\t}\n\n\t\t$foundTypes = [];\n\t\t$data = $keys['{http://owncloud.org/ns}share-types'];\n\t\tforeach ($data as $item) {\n\t\t\tif ($item['name'] !== '{http://owncloud.org/ns}share-type') {\n\t\t\t\tthrow new \\Exception('Invalid property found: \"' . $item['name'] . '\"');\n\t\t\t}\n\n\t\t\t$foundTypes[] = $item['value'];\n\t\t}\n\n\t\tforeach ($table->getRows() as $row) {\n\t\t\t$key = array_search($row[0], $foundTypes);\n\t\t\tif ($key === false) {\n\t\t\t\tthrow new \\Exception('Expected type ' . $row[0] . ' not found');\n\t\t\t}\n\n\t\t\tunset($foundTypes[$key]);\n\t\t}\n\n\t\tif ($foundTypes !== []) {\n\t\t\tthrow new \\Exception('Found more share types then specified: ' . $foundTypes);\n\t\t}\n\t}\n\n\t/**\n\t * @Then the response should contain an empty property :property\n\t * @param string $property\n\t * @throws \\Exception\n\t */\n\tpublic function theResponseShouldContainAnEmptyProperty($property) {\n\t\t$properties = $this->response;\n\t\tif (!array_key_exists($property, $properties)) {\n\t\t\tthrow new \\Exception(\"Cannot find property \\\"$property\\\"\");\n\t\t}\n\n\t\tif ($properties[$property] !== null) {\n\t\t\tthrow new \\Exception(\"Property \\\"$property\\\" is not empty\");\n\t\t}\n\t}\n\n\n\t/*Returns the elements of a propfind, $folderDepth requires 1 to see elements without children*/\n\tpublic function listFolder($user, $path, $folderDepth, $properties = null){\n\t\t$fullUrl = substr($this->baseUrl, 0, -4);\n\n\t\t$settings = array(\n\t\t\t'baseUri' => $fullUrl,\n\t\t\t'userName' => $user,\n\t\t);\n\n\t\tif ($user === 'admin') {\n\t\t\t$settings['password'] = $this->adminUser[1];\n\t\t} else {\n\t\t\t$settings['password'] = $this->regularUser;\n\t\t}\n\n\t\t$client = new SClient($settings);\n\n\t\tif (!$properties) {\n\t\t\t$properties = [\n\t\t\t\t'{DAV:}getetag'\n\t\t\t];\n\t\t}\n\n\t\t$response = $client->propfind($this->davPath . '/' . ltrim($path, '/'), $properties, $folderDepth);\n\n\t\treturn $response;\n\t}\n\n\t/**\n\t * @Then /^user \"([^\"]*)\" should see following elements$/\n\t * @param \\Behat\\Gherkin\\Node\\TableNode|null $expectedElements\n\t */\n\tpublic function checkElementList($user, $expectedElements){\n\t\t$elementList = $this->listFolder($user, '/', 3);\n\t\tif ($expectedElements instanceof \\Behat\\Gherkin\\Node\\TableNode) {\n\t\t\t$elementRows = $expectedElements->getRows();\n\t\t\t$elementsSimplified = $this->simplifyArray($elementRows);\n\t\t\tforeach($elementsSimplified as $expectedElement) {\n\t\t\t\t$webdavPath = \"/\" . $this->davPath . $expectedElement;\n\t\t\t\tif (!array_key_exists($webdavPath,$elementList)){\n\t\t\t\t\tPHPUnit_Framework_Assert::fail(\"$webdavPath\" . \" is not in propfind answer\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @When User :user uploads file :source to :destination\n\t */\n\tpublic function userUploadsAFileTo($user, $source, $destination)\n\t{\n\t\t$file = \\GuzzleHttp\\Stream\\Stream::factory(fopen($source, 'r'));\n\t\ttry {\n\t\t\t$this->response = $this->makeDavRequest($user, \"PUT\", $destination, [], $file);\n\t\t} catch (\\GuzzleHttp\\Exception\\ServerException $e) {\n\t\t\t// 4xx and 5xx responses cause an exception\n\t\t\t$this->response = $e->getResponse();\n\t\t}\n\t}\n\n\t/**\n\t * @When User :user deletes file :file\n\t */\n\tpublic function userDeletesFile($user, $file)  {\n\t\ttry {\n\t\t\t$this->response = $this->makeDavRequest($user, 'DELETE', $file, []);\n\t\t} catch (\\GuzzleHttp\\Exception\\ServerException $e) {\n\t\t\t// 4xx and 5xx responses cause an exception\n\t\t\t$this->response = $e->getResponse();\n\t\t}\n\t}\n\n\t/**\n\t * @Given User :user created a folder :destination\n\t */\n\tpublic function userCreatedAFolder($user, $destination){\n\t\ttry {\n\t\t\t$this->response = $this->makeDavRequest($user, \"MKCOL\", $destination, []);\n\t\t} catch (\\GuzzleHttp\\Exception\\ServerException $e) {\n\t\t\t// 4xx and 5xx responses cause an exception\n\t\t\t$this->response = $e->getResponse();\n\t\t}\n\t}\n\n\t/**\n\t * @Given user :user uploads chunk file :num of :total with :data to :destination\n\t */\n\tpublic function userUploadsChunkFileOfWithToWithChecksum($user, $num, $total, $data, $destination)\n\t{\n\t\t$num -= 1;\n\t\t$data = \\GuzzleHttp\\Stream\\Stream::factory($data);\n\t\t$file = $destination . '-chunking-42-'.$total.'-'.$num;\n\t\t$this->makeDavRequest($user, 'PUT', $file, ['OC-Chunked' => '1'], $data);\n\t}\n\n}\n\n", "Feature: webdav-related\n\tBackground:\n\t\tGiven using api version \"1\"\n\n\tScenario: moving a file old way\n\t\tGiven using dav path \"remote.php/webdav\"\n\t\tAnd As an \"admin\"\n\t\tAnd user \"user0\" exists\n\t\tWhen User \"user0\" moves file \"/textfile0.txt\" to \"/FOLDER/textfile0.txt\"\n\t\tThen the HTTP status code should be \"201\"\n\n\tScenario: download a file with range\n\t\tGiven using dav path \"remote.php/webdav\"\n\t\tAnd As an \"admin\"\n\t\tWhen Downloading file \"/welcome.txt\" with range \"bytes=52-78\"\n\t\tThen Downloaded content should be \"example file for developers\"\n\n\tScenario: Upload forbidden if quota is 0\n\t\tGiven using dav path \"remote.php/webdav\"\n\t\tAnd As an \"admin\"\n\t\tAnd user \"user0\" exists\n\t\tAnd user \"user0\" has a quota of \"0\"\n\t\tWhen User \"user0\" uploads file \"data/textfile.txt\" to \"/asdf.txt\"\n\t\tThen the HTTP status code should be \"507\"\n\n\tScenario: Retrieving folder quota when no quota is set\n\t\tGiven using dav path \"remote.php/webdav\"\n\t\tAnd As an \"admin\"\n\t\tAnd user \"user0\" exists\n\t\tWhen user \"user0\" has unlimited quota\n\t\tThen as \"user0\" gets properties of folder \"/\" with\n\t\t  |{DAV:}quota-available-bytes|\n\t\tAnd the single response should contain a property \"{DAV:}quota-available-bytes\" with value \"-3\"\n\n\tScenario: Retrieving folder quota when quota is set\n\t\tGiven using dav path \"remote.php/webdav\"\n\t\tAnd As an \"admin\"\n\t\tAnd user \"user0\" exists\n\t\tWhen user \"user0\" has a quota of \"10 MB\"\n\t\tThen as \"user0\" gets properties of folder \"/\" with\n\t\t  |{DAV:}quota-available-bytes|\n\t\tAnd the single response should contain a property \"{DAV:}quota-available-bytes\" with value \"10485428\"\n\n\tScenario: Retrieving folder quota of shared folder with quota when no quota is set for recipient\n\t\tGiven using dav path \"remote.php/webdav\"\n\t\tAnd As an \"admin\"\n\t\tAnd user \"user0\" exists\n\t\tAnd user \"user1\" exists\n\t\tAnd user \"user0\" has unlimited quota\n\t\tAnd user \"user1\" has a quota of \"10 MB\"\n\t\tAnd As an \"user1\"\n\t\tAnd user \"user1\" created a folder \"/testquota\"\n\t\tAnd as \"user1\" creating a share with\n\t\t  | path | testquota |\n\t\t  | shareType | 0 |\n\t\t  | permissions | 31 |\n\t\t  | shareWith | user0 |\n\t\tThen as \"user0\" gets properties of folder \"/testquota\" with\n\t\t  |{DAV:}quota-available-bytes|\n\t\tAnd the single response should contain a property \"{DAV:}quota-available-bytes\" with value \"10485428\"\n\n\tScenario: download a public shared file with range\n\t\tGiven user \"user0\" exists\n\t\tAnd As an \"user0\"\n\t\tWhen creating a share with\n\t\t\t| path | welcome.txt |\n\t\t\t| shareType | 3 |\n\t\tAnd Downloading last public shared file with range \"bytes=52-78\"\n\t\tThen Downloaded content should be \"example file for developers\"\n\n\tScenario: Downloading a file on the old endpoint should serve security headers\n\t\tGiven using dav path \"remote.php/webdav\"\n\t\tAnd As an \"admin\"\n\t\tWhen Downloading file \"/welcome.txt\"\n\t\tThen The following headers should be set\n\t\t\t|Content-Disposition|attachment; filename*=UTF-8''welcome.txt; filename=\"welcome.txt\"|\n\t\t\t|Content-Security-Policy|default-src 'self'; script-src 'self' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; frame-src *; img-src * data: blob:; font-src 'self' data:; media-src *; connect-src *|\n\t\t\t|X-Content-Type-Options |nosniff|\n\t\t\t|X-Download-Options|noopen|\n\t\t\t|X-Frame-Options|Sameorigin|\n\t\t\t|X-Permitted-Cross-Domain-Policies|none|\n\t\t\t|X-Robots-Tag|none|\n\t\t\t|X-XSS-Protection|1; mode=block|\n\t\tAnd Downloaded content should start with \"Welcome to your Nextcloud account!\"\n\n\tScenario: Downloading a file on the new endpoint should serve security headers\n\t\tGiven using dav path \"remote.php/dav/files/admin/\"\n\t\tAnd As an \"admin\"\n\t\tWhen Downloading file \"/welcome.txt\"\n\t\tThen The following headers should be set\n\t\t\t|Content-Disposition|attachment; filename*=UTF-8''welcome.txt; filename=\"welcome.txt\"|\n\t\t\t|Content-Security-Policy|default-src 'self'; script-src 'self' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; frame-src *; img-src * data: blob:; font-src 'self' data:; media-src *; connect-src *|\n\t\t\t|X-Content-Type-Options |nosniff|\n\t\t\t|X-Download-Options|noopen|\n\t\t\t|X-Frame-Options|Sameorigin|\n\t\t\t|X-Permitted-Cross-Domain-Policies|none|\n\t\t\t|X-Robots-Tag|none|\n\t\t\t|X-XSS-Protection|1; mode=block|\n\t\tAnd Downloaded content should start with \"Welcome to your Nextcloud account!\"\n\n\tScenario: Doing a GET with a web login should work without CSRF token on the new backend\n\t\tGiven Logging in using web as \"admin\"\n\t\tWhen Sending a \"GET\" to \"/remote.php/dav/files/admin/welcome.txt\" without requesttoken\n\t\tThen Downloaded content should start with \"Welcome to your Nextcloud account!\"\n\t\tThen the HTTP status code should be \"200\"\n\n\tScenario: Doing a GET with a web login should work with CSRF token on the new backend\n\t\tGiven Logging in using web as \"admin\"\n\t\tWhen Sending a \"GET\" to \"/remote.php/dav/files/admin/welcome.txt\" with requesttoken\n\t\tThen Downloaded content should start with \"Welcome to your Nextcloud account!\"\n\t\tThen the HTTP status code should be \"200\"\n\n\tScenario: Doing a PROPFIND with a web login should not work without CSRF token on the new backend\n\t\tGiven Logging in using web as \"admin\"\n\t\tWhen Sending a \"PROPFIND\" to \"/remote.php/dav/files/admin/welcome.txt\" without requesttoken\n\t\tThen the HTTP status code should be \"401\"\n\n\tScenario: Doing a PROPFIND with a web login should work with CSRF token on the new backend\n\t\tGiven Logging in using web as \"admin\"\n\t\tWhen Sending a \"PROPFIND\" to \"/remote.php/dav/files/admin/welcome.txt\" with requesttoken\n\t\tThen the HTTP status code should be \"207\"\n\n\tScenario: Doing a GET with a web login should work without CSRF token on the old backend\n\t\tGiven Logging in using web as \"admin\"\n\t\tWhen Sending a \"GET\" to \"/remote.php/webdav/welcome.txt\" without requesttoken\n\t\tThen Downloaded content should start with \"Welcome to your Nextcloud account!\"\n\t\tThen the HTTP status code should be \"200\"\n\n\tScenario: Doing a GET with a web login should work with CSRF token on the old backend\n\t\tGiven Logging in using web as \"admin\"\n\t\tWhen Sending a \"GET\" to \"/remote.php/webdav/welcome.txt\" with requesttoken\n\t\tThen Downloaded content should start with \"Welcome to your Nextcloud account!\"\n\t\tThen the HTTP status code should be \"200\"\n\n\tScenario: Doing a PROPFIND with a web login should not work without CSRF token on the old backend\n\t\tGiven Logging in using web as \"admin\"\n\t\tWhen Sending a \"PROPFIND\" to \"/remote.php/webdav/welcome.txt\" without requesttoken\n\t\tThen the HTTP status code should be \"401\"\n\n\tScenario: Doing a PROPFIND with a web login should work with CSRF token on the old backend\n\t\tGiven Logging in using web as \"admin\"\n\t\tWhen Sending a \"PROPFIND\" to \"/remote.php/webdav/welcome.txt\" with requesttoken\n\t\tThen the HTTP status code should be \"207\"\n\n\tScenario: Upload chunked file asc\n\t\tGiven user \"user0\" exists\n\t\tAnd user \"user0\" uploads chunk file \"1\" of \"3\" with \"AAAAA\" to \"/myChunkedFile.txt\"\n\t\tAnd user \"user0\" uploads chunk file \"2\" of \"3\" with \"BBBBB\" to \"/myChunkedFile.txt\"\n\t\tAnd user \"user0\" uploads chunk file \"3\" of \"3\" with \"CCCCC\" to \"/myChunkedFile.txt\"\n\t\tWhen As an \"user0\"\n\t\tAnd Downloading file \"/myChunkedFile.txt\"\n\t\tThen Downloaded content should be \"AAAAABBBBBCCCCC\"\n\n\tScenario: Upload chunked file desc\n\t\tGiven user \"user0\" exists\n\t\tAnd user \"user0\" uploads chunk file \"3\" of \"3\" with \"CCCCC\" to \"/myChunkedFile.txt\"\n\t\tAnd user \"user0\" uploads chunk file \"2\" of \"3\" with \"BBBBB\" to \"/myChunkedFile.txt\"\n\t\tAnd user \"user0\" uploads chunk file \"1\" of \"3\" with \"AAAAA\" to \"/myChunkedFile.txt\"\n\t\tWhen As an \"user0\"\n\t\tAnd Downloading file \"/myChunkedFile.txt\"\n\t\tThen Downloaded content should be \"AAAAABBBBBCCCCC\"\n\n\tScenario: Upload chunked file random\n\t\tGiven user \"user0\" exists\n\t\tAnd user \"user0\" uploads chunk file \"2\" of \"3\" with \"BBBBB\" to \"/myChunkedFile.txt\"\n\t\tAnd user \"user0\" uploads chunk file \"3\" of \"3\" with \"CCCCC\" to \"/myChunkedFile.txt\"\n\t\tAnd user \"user0\" uploads chunk file \"1\" of \"3\" with \"AAAAA\" to \"/myChunkedFile.txt\"\n\t\tWhen As an \"user0\"\n\t\tAnd Downloading file \"/myChunkedFile.txt\"\n\t\tThen Downloaded content should be \"AAAAABBBBBCCCCC\"\n\n\tScenario: A file that is not shared does not have a share-types property\n\t\tGiven user \"user0\" exists\n\t\tAnd user \"user0\" created a folder \"/test\"\n\t\tWhen as \"user0\" gets properties of folder \"/test\" with\n\t\t\t|{http://owncloud.org/ns}share-types|\n\t\tThen the response should contain an empty property \"{http://owncloud.org/ns}share-types\"\n\n\tScenario: A file that is shared to a user has a share-types property\n\t\tGiven user \"user0\" exists\n\t\tAnd user \"user1\" exists\n\t\tAnd user \"user0\" created a folder \"/test\"\n\t\tAnd as \"user0\" creating a share with\n\t\t\t| path | test |\n\t\t\t| shareType | 0 |\n\t\t\t| permissions | 31 |\n\t\t\t| shareWith | user1 |\n\t\tWhen as \"user0\" gets properties of folder \"/test\" with\n\t\t\t|{http://owncloud.org/ns}share-types|\n\t\tThen the response should contain a share-types property with\n\t\t\t| 0 |\n\n\tScenario: A file that is shared to a group has a share-types property\n\t\tGiven user \"user0\" exists\n\t\tAnd group \"group1\" exists\n\t\tAnd user \"user0\" created a folder \"/test\"\n\t\tAnd as \"user0\" creating a share with\n\t\t\t| path | test |\n\t\t\t| shareType | 1 |\n\t\t\t| permissions | 31 |\n\t\t\t| shareWith | group1 |\n\t\tWhen as \"user0\" gets properties of folder \"/test\" with\n\t\t\t|{http://owncloud.org/ns}share-types|\n\t\tThen the response should contain a share-types property with\n\t\t\t| 1 |\n\n\tScenario: A file that is shared by link has a share-types property\n\t\tGiven user \"user0\" exists\n\t\tAnd user \"user0\" created a folder \"/test\"\n\t\tAnd as \"user0\" creating a share with\n\t\t\t| path | test |\n\t\t\t| shareType | 3 |\n\t\t\t| permissions | 31 |\n\t\tWhen as \"user0\" gets properties of folder \"/test\" with\n\t\t\t|{http://owncloud.org/ns}share-types|\n\t\tThen the response should contain a share-types property with\n\t\t\t| 3 |\n\n\tScenario: A file that is shared by user,group and link has a share-types property\n\t\tGiven user \"user0\" exists\n\t\tAnd user \"user1\" exists\n\t\tAnd group \"group2\" exists\n\t\tAnd user \"user0\" created a folder \"/test\"\n\t\tAnd as \"user0\" creating a share with\n\t\t\t| path        | test  |\n\t\t\t| shareType   | 0     |\n\t\t\t| permissions | 31    |\n\t\t\t| shareWith   | user1 |\n\t\tAnd as \"user0\" creating a share with\n\t\t\t| path        | test  |\n\t\t\t| shareType   | 1     |\n\t\t\t| permissions | 31    |\n\t\t\t| shareWith   | group2 |\n\t\tAnd as \"user0\" creating a share with\n\t\t\t| path        | test  |\n\t\t\t| shareType   | 3     |\n\t\t\t| permissions | 31    |\n\t\tWhen as \"user0\" gets properties of folder \"/test\" with\n\t\t\t|{http://owncloud.org/ns}share-types|\n\t\tThen the response should contain a share-types property with\n\t\t\t| 0 |\n\t\t\t| 1 |\n\t\t\t| 3 |\n"], "fixing_code": ["<?php\n/**\n * @author Bj\u00f6rn Schie\u00dfle <schiessle@owncloud.com>\n * @author Joas Schilling <nickvergessen@owncloud.com>\n * @author Morris Jobke <hey@morrisjobke.de>\n * @author Robin Appelman <icewind@owncloud.com>\n * @author Thomas M\u00fcller <thomas.mueller@tmit.eu>\n * @author Vincent Petry <pvince81@owncloud.com>\n *\n * @copyright Copyright (c) 2016, ownCloud, Inc.\n * @license AGPL-3.0\n *\n * This code is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License, version 3,\n * as published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License, version 3,\n * along with this program.  If not, see <http://www.gnu.org/licenses/>\n *\n */\n\nnamespace OCA\\DAV\\Connector\\Sabre;\n\nuse OCA\\DAV\\Connector\\Sabre\\Exception\\Forbidden;\nuse OCA\\DAV\\Connector\\Sabre\\Exception\\InvalidPath;\nuse OCA\\DAV\\Connector\\Sabre\\Exception\\FileLocked;\nuse OC\\Files\\FileInfo;\nuse OC\\Files\\Mount\\MoveableMount;\nuse OCP\\Files\\ForbiddenException;\nuse OCP\\Files\\StorageInvalidException;\nuse OCP\\Files\\StorageNotAvailableException;\nuse OCP\\Lock\\LockedException;\n\nclass ObjectTree extends \\Sabre\\DAV\\Tree {\n\n\t/**\n\t * @var \\OC\\Files\\View\n\t */\n\tprotected $fileView;\n\n\t/**\n\t * @var  \\OCP\\Files\\Mount\\IMountManager\n\t */\n\tprotected $mountManager;\n\n\t/**\n\t * Creates the object\n\t */\n\tpublic function __construct() {\n\t}\n\n\t/**\n\t * @param \\Sabre\\DAV\\INode $rootNode\n\t * @param \\OC\\Files\\View $view\n\t * @param  \\OCP\\Files\\Mount\\IMountManager $mountManager\n\t */\n\tpublic function init(\\Sabre\\DAV\\INode $rootNode, \\OC\\Files\\View $view, \\OCP\\Files\\Mount\\IMountManager $mountManager) {\n\t\t$this->rootNode = $rootNode;\n\t\t$this->fileView = $view;\n\t\t$this->mountManager = $mountManager;\n\t}\n\n\t/**\n\t * If the given path is a chunked file name, converts it\n\t * to the real file name. Only applies if the OC-CHUNKED header\n\t * is present.\n\t *\n\t * @param string $path chunk file path to convert\n\t *\n\t * @return string path to real file\n\t */\n\tprivate function resolveChunkFile($path) {\n\t\tif (isset($_SERVER['HTTP_OC_CHUNKED'])) {\n\t\t\t// resolve to real file name to find the proper node\n\t\t\tlist($dir, $name) = \\Sabre\\HTTP\\URLUtil::splitPath($path);\n\t\t\tif ($dir == '/' || $dir == '.') {\n\t\t\t\t$dir = '';\n\t\t\t}\n\n\t\t\t$info = \\OC_FileChunking::decodeName($name);\n\t\t\t// only replace path if it was really the chunked file\n\t\t\tif (isset($info['transferid'])) {\n\t\t\t\t// getNodePath is called for multiple nodes within a chunk\n\t\t\t\t// upload call\n\t\t\t\t$path = $dir . '/' . $info['name'];\n\t\t\t\t$path = ltrim($path, '/');\n\t\t\t}\n\t\t}\n\t\treturn $path;\n\t}\n\n\tpublic function cacheNode(Node $node) {\n\t\t$this->cache[trim($node->getPath(), '/')] = $node;\n\t}\n\n\t/**\n\t * Returns the INode object for the requested path\n\t *\n\t * @param string $path\n\t * @return \\Sabre\\DAV\\INode\n\t * @throws InvalidPath\n\t * @throws \\Sabre\\DAV\\Exception\\Locked\n\t * @throws \\Sabre\\DAV\\Exception\\NotFound\n\t * @throws \\Sabre\\DAV\\Exception\\ServiceUnavailable\n\t */\n\tpublic function getNodeForPath($path) {\n\t\tif (!$this->fileView) {\n\t\t\tthrow new \\Sabre\\DAV\\Exception\\ServiceUnavailable('filesystem not setup');\n\t\t}\n\n\t\t$path = trim($path, '/');\n\n\t\tif (isset($this->cache[$path])) {\n\t\t\treturn $this->cache[$path];\n\t\t}\n\n\t\tif ($path) {\n\t\t\ttry {\n\t\t\t\t$this->fileView->verifyPath($path, basename($path));\n\t\t\t} catch (\\OCP\\Files\\InvalidPathException $ex) {\n\t\t\t\tthrow new InvalidPath($ex->getMessage());\n\t\t\t}\n\t\t}\n\n\t\t// Is it the root node?\n\t\tif (!strlen($path)) {\n\t\t\treturn $this->rootNode;\n\t\t}\n\n\t\tif (pathinfo($path, PATHINFO_EXTENSION) === 'part') {\n\t\t\t// read from storage\n\t\t\t$absPath = $this->fileView->getAbsolutePath($path);\n\t\t\t$mount = $this->fileView->getMount($path);\n\t\t\t$storage = $mount->getStorage();\n\t\t\t$internalPath = $mount->getInternalPath($absPath);\n\t\t\tif ($storage && $storage->file_exists($internalPath)) {\n\t\t\t\t/**\n\t\t\t\t * @var \\OC\\Files\\Storage\\Storage $storage\n\t\t\t\t */\n\t\t\t\t// get data directly\n\t\t\t\t$data = $storage->getMetaData($internalPath);\n\t\t\t\t$info = new FileInfo($absPath, $storage, $internalPath, $data, $mount);\n\t\t\t} else {\n\t\t\t\t$info = null;\n\t\t\t}\n\t\t} else {\n\t\t\t// resolve chunk file name to real name, if applicable\n\t\t\t$path = $this->resolveChunkFile($path);\n\n\t\t\t// read from cache\n\t\t\ttry {\n\t\t\t\t$info = $this->fileView->getFileInfo($path);\n\t\t\t} catch (StorageNotAvailableException $e) {\n\t\t\t\tthrow new \\Sabre\\DAV\\Exception\\ServiceUnavailable('Storage not available');\n\t\t\t} catch (StorageInvalidException $e) {\n\t\t\t\tthrow new \\Sabre\\DAV\\Exception\\NotFound('Storage ' . $path . ' is invalid');\n\t\t\t} catch (LockedException $e) {\n\t\t\t\tthrow new \\Sabre\\DAV\\Exception\\Locked();\n\t\t\t}\n\t\t}\n\n\t\tif (!$info) {\n\t\t\tthrow new \\Sabre\\DAV\\Exception\\NotFound('File with name ' . $path . ' could not be located');\n\t\t}\n\n\t\tif ($info->getType() === 'dir') {\n\t\t\t$node = new \\OCA\\DAV\\Connector\\Sabre\\Directory($this->fileView, $info, $this);\n\t\t} else {\n\t\t\t$node = new \\OCA\\DAV\\Connector\\Sabre\\File($this->fileView, $info);\n\t\t}\n\n\t\t$this->cache[$path] = $node;\n\t\treturn $node;\n\n\t}\n\n\t/**\n\t * Moves a file from one location to another\n\t *\n\t * @param string $sourcePath The path to the file which should be moved\n\t * @param string $destinationPath The full destination path, so not just the destination parent node\n\t * @return int\n\t * @throws FileLocked\n\t * @throws Forbidden\n\t * @throws InvalidPath\n\t * @throws \\Sabre\\DAV\\Exception\\Forbidden\n\t * @throws \\Sabre\\DAV\\Exception\\Locked\n\t * @throws \\Sabre\\DAV\\Exception\\NotFound\n\t * @throws \\Sabre\\DAV\\Exception\\ServiceUnavailable\n\t */\n\tpublic function move($sourcePath, $destinationPath) {\n\t\tif (!$this->fileView) {\n\t\t\tthrow new \\Sabre\\DAV\\Exception\\ServiceUnavailable('filesystem not setup');\n\t\t}\n\n\t\t$infoDestination = $this->fileView->getFileInfo(dirname($destinationPath));\n\t\t$infoSource = $this->fileView->getFileInfo($sourcePath);\n\t\t$destinationPermission = $infoDestination && $infoDestination->isUpdateable();\n\t\t$sourcePermission =  $infoSource && $infoSource->isDeletable();\n\n\t\tif (!$destinationPermission || !$sourcePermission) {\n\t\t\tthrow new Forbidden('No permissions to move object.');\n\t\t}\n\n\t\t$targetNodeExists = $this->nodeExists($destinationPath);\n\t\t$sourceNode = $this->getNodeForPath($sourcePath);\n\t\tif ($sourceNode instanceof \\Sabre\\DAV\\ICollection && $targetNodeExists) {\n\t\t\tthrow new \\Sabre\\DAV\\Exception\\Forbidden('Could not copy directory ' . $sourceNode->getName() . ', target exists');\n\t\t}\n\t\tlist($sourceDir,) = \\Sabre\\HTTP\\URLUtil::splitPath($sourcePath);\n\t\tlist($destinationDir,) = \\Sabre\\HTTP\\URLUtil::splitPath($destinationPath);\n\n\t\t$isMovableMount = false;\n\t\t$sourceMount = $this->mountManager->find($this->fileView->getAbsolutePath($sourcePath));\n\t\t$internalPath = $sourceMount->getInternalPath($this->fileView->getAbsolutePath($sourcePath));\n\t\tif ($sourceMount instanceof MoveableMount && $internalPath === '') {\n\t\t\t$isMovableMount = true;\n\t\t}\n\n\t\ttry {\n\t\t\t$sameFolder = ($sourceDir === $destinationDir);\n\t\t\t// if we're overwriting or same folder\n\t\t\tif ($targetNodeExists || $sameFolder) {\n\t\t\t\t// note that renaming a share mount point is always allowed\n\t\t\t\tif (!$this->fileView->isUpdatable($destinationDir) && !$isMovableMount) {\n\t\t\t\t\tthrow new \\Sabre\\DAV\\Exception\\Forbidden();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!$this->fileView->isCreatable($destinationDir)) {\n\t\t\t\t\tthrow new \\Sabre\\DAV\\Exception\\Forbidden();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!$sameFolder) {\n\t\t\t\t// moving to a different folder, source will be gone, like a deletion\n\t\t\t\t// note that moving a share mount point is always allowed\n\t\t\t\tif (!$this->fileView->isDeletable($sourcePath) && !$isMovableMount) {\n\t\t\t\t\tthrow new \\Sabre\\DAV\\Exception\\Forbidden();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$fileName = basename($destinationPath);\n\t\t\ttry {\n\t\t\t\t$this->fileView->verifyPath($destinationDir, $fileName);\n\t\t\t} catch (\\OCP\\Files\\InvalidPathException $ex) {\n\t\t\t\tthrow new InvalidPath($ex->getMessage());\n\t\t\t}\n\n\t\t\t$renameOkay = $this->fileView->rename($sourcePath, $destinationPath);\n\t\t\tif (!$renameOkay) {\n\t\t\t\tthrow new \\Sabre\\DAV\\Exception\\Forbidden('');\n\t\t\t}\n\t\t} catch (StorageNotAvailableException $e) {\n\t\t\tthrow new \\Sabre\\DAV\\Exception\\ServiceUnavailable($e->getMessage());\n\t\t} catch (ForbiddenException $ex) {\n\t\t\tthrow new Forbidden($ex->getMessage(), $ex->getRetry());\n\t\t} catch (LockedException $e) {\n\t\t\tthrow new FileLocked($e->getMessage(), $e->getCode(), $e);\n\t\t}\n\n\t\t$this->markDirty($sourceDir);\n\t\t$this->markDirty($destinationDir);\n\n\t}\n\n\t/**\n\t * Copies a file or directory.\n\t *\n\t * This method must work recursively and delete the destination\n\t * if it exists\n\t *\n\t * @param string $source\n\t * @param string $destination\n\t * @throws FileLocked\n\t * @throws Forbidden\n\t * @throws InvalidPath\n\t * @throws \\Exception\n\t * @throws \\Sabre\\DAV\\Exception\\Locked\n\t * @throws \\Sabre\\DAV\\Exception\\NotFound\n\t * @throws \\Sabre\\DAV\\Exception\\ServiceUnavailable\n\t */\n\tpublic function copy($source, $destination) {\n\t\tif (!$this->fileView) {\n\t\t\tthrow new \\Sabre\\DAV\\Exception\\ServiceUnavailable('filesystem not setup');\n\t\t}\n\n\t\t$info = $this->fileView->getFileInfo(dirname($destination));\n\t\tif ($info && !$info->isUpdateable()) {\n\t\t\tthrow new Forbidden('No permissions to copy object.');\n\t\t}\n\t\t\n\t\t// this will trigger existence check\n\t\t$this->getNodeForPath($source);\n\n\t\tlist($destinationDir, $destinationName) = \\Sabre\\HTTP\\URLUtil::splitPath($destination);\n\t\ttry {\n\t\t\t$this->fileView->verifyPath($destinationDir, $destinationName);\n\t\t} catch (\\OCP\\Files\\InvalidPathException $ex) {\n\t\t\tthrow new InvalidPath($ex->getMessage());\n\t\t}\n\n\t\ttry {\n\t\t\t$this->fileView->copy($source, $destination);\n\t\t} catch (StorageNotAvailableException $e) {\n\t\t\tthrow new \\Sabre\\DAV\\Exception\\ServiceUnavailable($e->getMessage());\n\t\t} catch (ForbiddenException $ex) {\n\t\t\tthrow new Forbidden($ex->getMessage(), $ex->getRetry());\n\t\t} catch (LockedException $e) {\n\t\t\tthrow new FileLocked($e->getMessage(), $e->getCode(), $e);\n\t\t}\n\n\t\tlist($destinationDir,) = \\Sabre\\HTTP\\URLUtil::splitPath($destination);\n\t\t$this->markDirty($destinationDir);\n\t}\n}\n", "<?php\n/**\n * @author Joas Schilling <nickvergessen@owncloud.com>\n * @author Morris Jobke <hey@morrisjobke.de>\n * @author Robin Appelman <icewind@owncloud.com>\n * @author Thomas M\u00fcller <thomas.mueller@tmit.eu>\n * @author Vincent Petry <pvince81@owncloud.com>\n *\n * @copyright Copyright (c) 2016, ownCloud, Inc.\n * @license AGPL-3.0\n *\n * This code is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License, version 3,\n * as published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License, version 3,\n * along with this program.  If not, see <http://www.gnu.org/licenses/>\n *\n */\n\nnamespace OCA\\DAV\\Tests\\Unit\\Connector\\Sabre;\n\n\nuse OC\\Files\\FileInfo;\nuse OC\\Files\\Storage\\Temporary;\n\nclass TestDoubleFileView extends \\OC\\Files\\View {\n\n\tpublic function __construct($updatables, $deletables, $canRename = true) {\n\t\t$this->updatables = $updatables;\n\t\t$this->deletables = $deletables;\n\t\t$this->canRename = $canRename;\n\t}\n\n\tpublic function isUpdatable($path) {\n\t\treturn $this->updatables[$path];\n\t}\n\n\tpublic function isCreatable($path) {\n\t\treturn $this->updatables[$path];\n\t}\n\n\tpublic function isDeletable($path) {\n\t\treturn $this->deletables[$path];\n\t}\n\n\tpublic function rename($path1, $path2) {\n\t\treturn $this->canRename;\n\t}\n\n\tpublic function getRelativePath($path) {\n\t\treturn $path;\n\t}\n\n\tpublic function getFileInfo($path, $includeMountPoints = true) {\n\t\t$objectTreeTest = new ObjectTreeTest();\n\t\treturn $objectTreeTest->getFileInfoMock();\n\t}\n}\n\n/**\n * Class ObjectTree\n *\n * @group DB\n *\n * @package OCA\\DAV\\Tests\\Unit\\Connector\\Sabre\n */\nclass ObjectTree extends \\Test\\TestCase {\n\n\tpublic function getFileInfoMock() {\n\t\t$mock = $this->getMock('\\OCP\\Files\\FileInfo');\n\t\t$mock\n\t\t\t->expects($this->any())\n\t\t\t->method('isDeletable')\n\t\t\t->willReturn(true);\n\t\t$mock\n\t\t\t->expects($this->any())\n\t\t\t->method('isUpdateable')\n\t\t\t->willReturn(true);\n\n\t\treturn $mock;\n\t}\n\n\n\t/**\n\t * @dataProvider moveFailedProvider\n\t * @expectedException \\Sabre\\DAV\\Exception\\Forbidden\n\t */\n\tpublic function testMoveFailed($source, $destination, $updatables, $deletables) {\n\t\t$this->moveTest($source, $destination, $updatables, $deletables);\n\t}\n\n\t/**\n\t * @dataProvider moveSuccessProvider\n\t */\n\tpublic function testMoveSuccess($source, $destination, $updatables, $deletables) {\n\t\t$this->moveTest($source, $destination, $updatables, $deletables);\n\t\t$this->assertTrue(true);\n\t}\n\n\t/**\n\t * @dataProvider moveFailedInvalidCharsProvider\n\t * @expectedException \\OCA\\DAV\\Connector\\Sabre\\Exception\\InvalidPath\n\t */\n\tpublic function testMoveFailedInvalidChars($source, $destination, $updatables, $deletables) {\n\t\t$this->moveTest($source, $destination, $updatables, $deletables);\n\t}\n\n\tfunction moveFailedInvalidCharsProvider() {\n\t\treturn array(\n\t\t\tarray('a/b', 'a/*', array('a' => true, 'a/b' => true, 'a/c*' => false), array()),\n\t\t);\n\t}\n\n\tfunction moveFailedProvider() {\n\t\treturn array(\n\t\t\tarray('a/b', 'a/c', array('a' => false, 'a/b' => false, 'a/c' => false), array()),\n\t\t\tarray('a/b', 'b/b', array('a' => false, 'a/b' => false, 'b' => false, 'b/b' => false), array()),\n\t\t\tarray('a/b', 'b/b', array('a' => false, 'a/b' => true, 'b' => false, 'b/b' => false), array()),\n\t\t\tarray('a/b', 'b/b', array('a' => true, 'a/b' => true, 'b' => false, 'b/b' => false), array()),\n\t\t\tarray('a/b', 'b/b', array('a' => true, 'a/b' => true, 'b' => true, 'b/b' => false), array('a/b' => false)),\n\t\t\tarray('a/b', 'a/c', array('a' => false, 'a/b' => true, 'a/c' => false), array()),\n\t\t);\n\t}\n\n\tfunction moveSuccessProvider() {\n\t\treturn array(\n\t\t\tarray('a/b', 'b/b', array('a' => true, 'a/b' => true, 'b' => true, 'b/b' => false), array('a/b' => true)),\n\t\t\t// older files with special chars can still be renamed to valid names\n\t\t\tarray('a/b*', 'b/b', array('a' => true, 'a/b*' => true, 'b' => true, 'b/b' => false), array('a/b*' => true)),\n\t\t);\n\t}\n\n\t/**\n\t * @param $source\n\t * @param $destination\n\t * @param $updatables\n\t */\n\tprivate function moveTest($source, $destination, $updatables, $deletables) {\n\t\t$view = new TestDoubleFileView($updatables, $deletables);\n\n\t\t$info = new FileInfo('', null, null, array(), null);\n\n\t\t$rootDir = new \\OCA\\DAV\\Connector\\Sabre\\Directory($view, $info);\n\t\t$objectTree = $this->getMock('\\OCA\\DAV\\Connector\\Sabre\\ObjectTree',\n\t\t\tarray('nodeExists', 'getNodeForPath'),\n\t\t\tarray($rootDir, $view));\n\n\t\t$objectTree->expects($this->once())\n\t\t\t->method('getNodeForPath')\n\t\t\t->with($this->identicalTo($source))\n\t\t\t->will($this->returnValue(false));\n\n\t\t/** @var $objectTree \\OCA\\DAV\\Connector\\Sabre\\ObjectTree */\n\t\t$mountManager = \\OC\\Files\\Filesystem::getMountManager();\n\t\t$objectTree->init($rootDir, $view, $mountManager);\n\t\t$objectTree->move($source, $destination);\n\t}\n\n\t/**\n\t * @dataProvider nodeForPathProvider\n\t */\n\tpublic function testGetNodeForPath(\n\t\t$inputFileName,\n\t\t$fileInfoQueryPath,\n\t\t$outputFileName,\n\t\t$type,\n\t\t$enableChunkingHeader\n\t) {\n\n\t\tif ($enableChunkingHeader) {\n\t\t\t$_SERVER['HTTP_OC_CHUNKED'] = true;\n\t\t}\n\n\t\t$rootNode = $this->getMockBuilder('\\OCA\\DAV\\Connector\\Sabre\\Directory')\n\t\t\t->disableOriginalConstructor()\n\t\t\t->getMock();\n\t\t$mountManager = $this->getMock('\\OC\\Files\\Mount\\Manager');\n\t\t$view = $this->getMock('\\OC\\Files\\View');\n\t\t$fileInfo = $this->getMock('\\OCP\\Files\\FileInfo');\n\t\t$fileInfo->expects($this->once())\n\t\t\t->method('getType')\n\t\t\t->will($this->returnValue($type));\n\t\t$fileInfo->expects($this->once())\n\t\t\t->method('getName')\n\t\t\t->will($this->returnValue($outputFileName));\n\n\t\t$view->expects($this->once())\n\t\t\t->method('getFileInfo')\n\t\t\t->with($fileInfoQueryPath)\n\t\t\t->will($this->returnValue($fileInfo));\n\n\t\t$tree = new \\OCA\\DAV\\Connector\\Sabre\\ObjectTree();\n\t\t$tree->init($rootNode, $view, $mountManager);\n\n\t\t$node = $tree->getNodeForPath($inputFileName);\n\n\t\t$this->assertNotNull($node);\n\t\t$this->assertEquals($outputFileName, $node->getName());\n\n\t\tif ($type === 'file') {\n\t\t\t$this->assertTrue($node instanceof \\OCA\\DAV\\Connector\\Sabre\\File);\n\t\t} else {\n\t\t\t$this->assertTrue($node instanceof \\OCA\\DAV\\Connector\\Sabre\\Directory);\n\t\t}\n\n\t\tunset($_SERVER['HTTP_OC_CHUNKED']);\n\t}\n\n\tfunction nodeForPathProvider() {\n\t\treturn array(\n\t\t\t// regular file\n\t\t\tarray(\n\t\t\t\t'regularfile.txt',\n\t\t\t\t'regularfile.txt',\n\t\t\t\t'regularfile.txt',\n\t\t\t\t'file',\n\t\t\t\tfalse\n\t\t\t),\n\t\t\t// regular directory\n\t\t\tarray(\n\t\t\t\t'regulardir',\n\t\t\t\t'regulardir',\n\t\t\t\t'regulardir',\n\t\t\t\t'dir',\n\t\t\t\tfalse\n\t\t\t),\n\t\t\t// regular file with chunking\n\t\t\tarray(\n\t\t\t\t'regularfile.txt',\n\t\t\t\t'regularfile.txt',\n\t\t\t\t'regularfile.txt',\n\t\t\t\t'file',\n\t\t\t\ttrue\n\t\t\t),\n\t\t\t// regular directory with chunking\n\t\t\tarray(\n\t\t\t\t'regulardir',\n\t\t\t\t'regulardir',\n\t\t\t\t'regulardir',\n\t\t\t\t'dir',\n\t\t\t\ttrue\n\t\t\t),\n\t\t\t// file with chunky file name\n\t\t\tarray(\n\t\t\t\t'regularfile.txt-chunking-123566789-10-1',\n\t\t\t\t'regularfile.txt',\n\t\t\t\t'regularfile.txt',\n\t\t\t\t'file',\n\t\t\t\ttrue\n\t\t\t),\n\t\t\t// regular file in subdir\n\t\t\tarray(\n\t\t\t\t'subdir/regularfile.txt',\n\t\t\t\t'subdir/regularfile.txt',\n\t\t\t\t'regularfile.txt',\n\t\t\t\t'file',\n\t\t\t\tfalse\n\t\t\t),\n\t\t\t// regular directory in subdir\n\t\t\tarray(\n\t\t\t\t'subdir/regulardir',\n\t\t\t\t'subdir/regulardir',\n\t\t\t\t'regulardir',\n\t\t\t\t'dir',\n\t\t\t\tfalse\n\t\t\t),\n\t\t\t// file with chunky file name in subdir\n\t\t\tarray(\n\t\t\t\t'subdir/regularfile.txt-chunking-123566789-10-1',\n\t\t\t\t'subdir/regularfile.txt',\n\t\t\t\t'regularfile.txt',\n\t\t\t\t'file',\n\t\t\t\ttrue\n\t\t\t),\n\t\t);\n\t}\n\n\t/**\n\t * @expectedException \\OCA\\DAV\\Connector\\Sabre\\Exception\\InvalidPath\n\t */\n\tpublic function testGetNodeForPathInvalidPath() {\n\t\t$path = '/foo\\bar';\n\n\n\t\t$storage = new Temporary([]);\n\n\t\t$view = $this->getMock('\\OC\\Files\\View', ['resolvePath']);\n\t\t$view->expects($this->once())\n\t\t\t->method('resolvePath')\n\t\t\t->will($this->returnCallback(function($path) use ($storage){\n\t\t\treturn [$storage, ltrim($path, '/')];\n\t\t}));\n\n\t\t$rootNode = $this->getMockBuilder('\\OCA\\DAV\\Connector\\Sabre\\Directory')\n\t\t\t->disableOriginalConstructor()\n\t\t\t->getMock();\n\t\t$mountManager = $this->getMock('\\OC\\Files\\Mount\\Manager');\n\n\t\t$tree = new \\OCA\\DAV\\Connector\\Sabre\\ObjectTree();\n\t\t$tree->init($rootNode, $view, $mountManager);\n\n\t\t$tree->getNodeForPath($path);\n\t}\n\n\tpublic function testGetNodeForPathRoot() {\n\t\t$path = '/';\n\n\n\t\t$storage = new Temporary([]);\n\n\t\t$view = $this->getMock('\\OC\\Files\\View', ['resolvePath']);\n\t\t$view->expects($this->any())\n\t\t\t->method('resolvePath')\n\t\t\t->will($this->returnCallback(function ($path) use ($storage) {\n\t\t\t\treturn [$storage, ltrim($path, '/')];\n\t\t\t}));\n\n\t\t$rootNode = $this->getMockBuilder('\\OCA\\DAV\\Connector\\Sabre\\Directory')\n\t\t\t->disableOriginalConstructor()\n\t\t\t->getMock();\n\t\t$mountManager = $this->getMock('\\OC\\Files\\Mount\\Manager');\n\n\t\t$tree = new \\OCA\\DAV\\Connector\\Sabre\\ObjectTree();\n\t\t$tree->init($rootNode, $view, $mountManager);\n\n\t\t$this->assertInstanceOf('\\Sabre\\DAV\\INode', $tree->getNodeForPath($path));\n\t}\n\n\t/**\n\t * @expectedException \\Sabre\\DAV\\Exception\\Forbidden\n\t * @expectedExceptionMessage Could not copy directory nameOfSourceNode, target exists\n\t */\n\tpublic function testFailingMove() {\n\t\t$source = 'a/b';\n\t\t$destination = 'b/b';\n\t\t$updatables = array('a' => true, 'a/b' => true, 'b' => true, 'b/b' => false);\n\t\t$deletables = array('a/b' => true);\n\n\t\t$view = new TestDoubleFileView($updatables, $deletables);\n\n\t\t$info = new FileInfo('', null, null, array(), null);\n\n\t\t$rootDir = new \\OCA\\DAV\\Connector\\Sabre\\Directory($view, $info);\n\t\t$objectTree = $this->getMock('\\OCA\\DAV\\Connector\\Sabre\\ObjectTree',\n\t\t\tarray('nodeExists', 'getNodeForPath'),\n\t\t\tarray($rootDir, $view));\n\n\t\t$sourceNode = $this->getMockBuilder('\\Sabre\\DAV\\ICollection')\n\t\t\t->disableOriginalConstructor()\n\t\t\t->getMock();\n\t\t$sourceNode->expects($this->once())\n\t\t\t->method('getName')\n\t\t\t->will($this->returnValue('nameOfSourceNode'));\n\n\t\t$objectTree->expects($this->once())\n\t\t\t->method('nodeExists')\n\t\t\t->with($this->identicalTo($destination))\n\t\t\t->will($this->returnValue(true));\n\t\t$objectTree->expects($this->once())\n\t\t\t->method('getNodeForPath')\n\t\t\t->with($this->identicalTo($source))\n\t\t\t->will($this->returnValue($sourceNode));\n\n\t\t/** @var $objectTree \\OCA\\DAV\\Connector\\Sabre\\ObjectTree */\n\t\t$mountManager = \\OC\\Files\\Filesystem::getMountManager();\n\t\t$objectTree->init($rootDir, $view, $mountManager);\n\t\t$objectTree->move($source, $destination);\n\t}\n}\n", "<?php\n\nuse Behat\\Behat\\Context\\Context;\nuse Behat\\Behat\\Context\\SnippetAcceptingContext;\nuse GuzzleHttp\\Client as GClient;\nuse GuzzleHttp\\Message\\ResponseInterface;\nuse Sabre\\DAV\\Client as SClient;\n\nrequire __DIR__ . '/../../vendor/autoload.php';\n\n\ntrait WebDav {\n\t/** @var string*/\n\tprivate $davPath = \"remote.php/webdav\";\n\t/** @var ResponseInterface */\n\tprivate $response;\n\n\t/**\n\t * @Given /^using dav path \"([^\"]*)\"$/\n\t */\n\tpublic function usingDavPath($davPath) {\n\t\t$this->davPath = $davPath;\n\t}\n\n\tpublic function makeDavRequest($user, $method, $path, $headers, $body = null){\n\t\t$fullUrl = substr($this->baseUrl, 0, -4) . $this->davPath . \"$path\";\n\t\t$client = new GClient();\n\t\t$options = [];\n\t\tif ($user === 'admin') {\n\t\t\t$options['auth'] = $this->adminUser;\n\t\t} else {\n\t\t\t$options['auth'] = [$user, $this->regularUser];\n\t\t}\n\t\t$request = $client->createRequest($method, $fullUrl, $options);\n\t\tif (!is_null($headers)){\n\t\t\tforeach ($headers as $key => $value) {\n\t\t\t\t$request->addHeader($key, $value);\n\t\t\t}\n\t\t}\n\n\t\tif (!is_null($body)) {\n\t\t\t$request->setBody($body);\n\t\t}\n\n\t\treturn $client->send($request);\n\t}\n\n\t/**\n\t * @Given /^User \"([^\"]*)\" moved file \"([^\"]*)\" to \"([^\"]*)\"$/\n\t */\n\tpublic function userMovedFile($user, $fileSource, $fileDestination){\n\t\t$fullUrl = substr($this->baseUrl, 0, -4) . $this->davPath;\n\t\t$headers['Destination'] = $fullUrl . $fileDestination;\n\t\t$this->response = $this->makeDavRequest($user, \"MOVE\", $fileSource, $headers);\n\t\tPHPUnit_Framework_Assert::assertEquals(201, $this->response->getStatusCode());\n\t}\n\n\t/**\n\t * @When /^User \"([^\"]*)\" moves file \"([^\"]*)\" to \"([^\"]*)\"$/\n\t */\n\tpublic function userMovesFile($user, $fileSource, $fileDestination){\n\t\t$fullUrl = substr($this->baseUrl, 0, -4) . $this->davPath;\n\t\t$headers['Destination'] = $fullUrl . $fileDestination;\n\t\t$this->response = $this->makeDavRequest($user, \"MOVE\", $fileSource, $headers);\n\t}\n\n\n\n\t/**\n\t * @When /^User \"([^\"]*)\" copies file \"([^\"]*)\" to \"([^\"]*)\"$/\n\t * @param string $user\n\t * @param string $fileSource\n\t * @param string $fileDestination\n\t */\n\tpublic function userCopiesFileTo($user, $fileSource, $fileDestination) {\n\t\t$fullUrl = substr($this->baseUrl, 0, -4) . $this->davPath;\n\t\t$headers['Destination'] = $fullUrl . $fileDestination;\n\t\ttry {\n\t\t\t$this->response = $this->makeDavRequest($user, 'COPY', $fileSource, $headers);\n\t\t} catch (\\GuzzleHttp\\Exception\\ClientException $e) {\n\t\t\t// 4xx and 5xx responses cause an exception\n\t\t\t$this->response = $e->getResponse();\n\t\t}\n\t}\n\n\tpublic function downloadFileWithRange($fileSource, $range){\n\t\t$fullUrl = substr($this->baseUrl, 0, -4) . $this->davPath;\n\t\t$headers['Range'] = $range;\n\t\t$this->response = $this->makeDavRequest($this->currentUser, \"GET\", $fileSource, $headers);\n\t}\n\n\t/**\n\t * @When /^Downloading last public shared file with range \"([^\"]*)\"$/\n\t */\n\tpublic function downloadPublicFileWithRange($range){\n\t\t$token = $this->lastShareData->data->token;\n\t\t$fullUrl = substr($this->baseUrl, 0, -4) . \"public.php/webdav\";\n\t\t$headers['Range'] = $range;\n\n\t\t$client = new GClient();\n\t\t$options = [];\n\t\t$options['auth'] = [$token, \"\"];\n\n\t\t$request = $client->createRequest(\"GET\", $fullUrl, $options);\n\t\t$request->addHeader('Range', $range);\n\n\t\t$this->response = $client->send($request);\n\t}\n\n\t/**\n\t * @Then /^Downloaded content should be \"([^\"]*)\"$/\n\t */\n\tpublic function downloadedContentShouldBe($content){\n\t\tPHPUnit_Framework_Assert::assertEquals($content, (string)$this->response->getBody());\n\t}\n\n\t/**\n\t * @Then /^Downloaded content when downloading file \"([^\"]*)\" with range \"([^\"]*)\" should be \"([^\"]*)\"$/\n\t */\n\tpublic function downloadedContentWhenDownloadindShouldBe($fileSource, $range, $content){\n\t\t$this->downloadFileWithRange($fileSource, $range);\n\t\t$this->downloadedContentShouldBe($content);\n\t}\n\n\t/**\n\t * @When Downloading file :fileName\n\t */\n\tpublic function downloadingFile($fileName) {\n\t\t$this->response = $this->makeDavRequest($this->currentUser, 'GET', $fileName, []);\n\t}\n\n\t/**\n\t * @Then The following headers should be set\n\t */\n\tpublic function theFollowingHeadersShouldBeSet(\\Behat\\Gherkin\\Node\\TableNode $table) {\n\t\tforeach($table->getTable() as $header) {\n\t\t\t$headerName = $header[0];\n\t\t\t$expectedHeaderValue = $header[1];\n\t\t\t$returnedHeader = $this->response->getHeader($headerName);\n\t\t\tif($returnedHeader !== $expectedHeaderValue) {\n\t\t\t\tthrow new \\Exception(\n\t\t\t\t\tsprintf(\n\t\t\t\t\t\t\"Expected value '%s' for header '%s', got '%s'\",\n\t\t\t\t\t\t$expectedHeaderValue,\n\t\t\t\t\t\t$headerName,\n\t\t\t\t\t\t$returnedHeader\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @Then Downloaded content should start with :start\n\t */\n\tpublic function downloadedContentShouldStartWith($start) {\n\t\tif(strpos($this->response->getBody()->getContents(), $start) !== 0) {\n\t\t\tthrow new \\Exception(\n\t\t\t\tsprintf(\n\t\t\t\t\t\"Expected '%s', got '%s'\",\n\t\t\t\t\t$start,\n\t\t\t\t\t$this->response->getBody()->getContents()\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * @Then /^as \"([^\"]*)\" gets properties of folder \"([^\"]*)\" with$/\n\t * @param \\Behat\\Gherkin\\Node\\TableNode|null $propertiesTable\n\t */\n\tpublic function asGetsPropertiesOfFolderWith($user, $path, $propertiesTable) {\n\t\t$properties = null;\n\t\tif ($propertiesTable instanceof \\Behat\\Gherkin\\Node\\TableNode) {\n\t\t\tforeach ($propertiesTable->getRows() as $row) {\n\t\t\t\t$properties[] = $row[0];\n\t\t\t}\n\t\t}\n\t\t$this->response = $this->listFolder($user, $path, 0, $properties);\n\t}\n\n\t/**\n\t * @Then the single response should contain a property :key with value :value\n\t */\n\tpublic function theSingleResponseShouldContainAPropertyWithValue($key, $expectedValue) {\n\t\t$keys = $this->response;\n\t\tif (!array_key_exists($key, $keys)) {\n\t\t\tthrow new \\Exception(\"Cannot find property \\\"$key\\\" with \\\"$expectedValue\\\"\");\n\t\t}\n\n\t\t$value = $keys[$key];\n\t\tif ($value !== $expectedValue) {\n\t\t\tthrow new \\Exception(\"Property \\\"$key\\\" found with value \\\"$value\\\", expected \\\"$expectedValue\\\"\");\n\t\t}\n\t}\n\n\t/**\n\t * @Then the response should contain a share-types property with\n\t */\n\tpublic function theResponseShouldContainAShareTypesPropertyWith($table)\n\t{\n\t\t$keys = $this->response;\n\t\tif (!array_key_exists('{http://owncloud.org/ns}share-types', $keys)) {\n\t\t\tthrow new \\Exception(\"Cannot find property \\\"{http://owncloud.org/ns}share-types\\\"\");\n\t\t}\n\n\t\t$foundTypes = [];\n\t\t$data = $keys['{http://owncloud.org/ns}share-types'];\n\t\tforeach ($data as $item) {\n\t\t\tif ($item['name'] !== '{http://owncloud.org/ns}share-type') {\n\t\t\t\tthrow new \\Exception('Invalid property found: \"' . $item['name'] . '\"');\n\t\t\t}\n\n\t\t\t$foundTypes[] = $item['value'];\n\t\t}\n\n\t\tforeach ($table->getRows() as $row) {\n\t\t\t$key = array_search($row[0], $foundTypes);\n\t\t\tif ($key === false) {\n\t\t\t\tthrow new \\Exception('Expected type ' . $row[0] . ' not found');\n\t\t\t}\n\n\t\t\tunset($foundTypes[$key]);\n\t\t}\n\n\t\tif ($foundTypes !== []) {\n\t\t\tthrow new \\Exception('Found more share types then specified: ' . $foundTypes);\n\t\t}\n\t}\n\n\t/**\n\t * @Then the response should contain an empty property :property\n\t * @param string $property\n\t * @throws \\Exception\n\t */\n\tpublic function theResponseShouldContainAnEmptyProperty($property) {\n\t\t$properties = $this->response;\n\t\tif (!array_key_exists($property, $properties)) {\n\t\t\tthrow new \\Exception(\"Cannot find property \\\"$property\\\"\");\n\t\t}\n\n\t\tif ($properties[$property] !== null) {\n\t\t\tthrow new \\Exception(\"Property \\\"$property\\\" is not empty\");\n\t\t}\n\t}\n\n\n\t/*Returns the elements of a propfind, $folderDepth requires 1 to see elements without children*/\n\tpublic function listFolder($user, $path, $folderDepth, $properties = null){\n\t\t$fullUrl = substr($this->baseUrl, 0, -4);\n\n\t\t$settings = array(\n\t\t\t'baseUri' => $fullUrl,\n\t\t\t'userName' => $user,\n\t\t);\n\n\t\tif ($user === 'admin') {\n\t\t\t$settings['password'] = $this->adminUser[1];\n\t\t} else {\n\t\t\t$settings['password'] = $this->regularUser;\n\t\t}\n\n\t\t$client = new SClient($settings);\n\n\t\tif (!$properties) {\n\t\t\t$properties = [\n\t\t\t\t'{DAV:}getetag'\n\t\t\t];\n\t\t}\n\n\t\t$response = $client->propfind($this->davPath . '/' . ltrim($path, '/'), $properties, $folderDepth);\n\n\t\treturn $response;\n\t}\n\n\t/**\n\t * @Then /^user \"([^\"]*)\" should see following elements$/\n\t * @param \\Behat\\Gherkin\\Node\\TableNode|null $expectedElements\n\t */\n\tpublic function checkElementList($user, $expectedElements){\n\t\t$elementList = $this->listFolder($user, '/', 3);\n\t\tif ($expectedElements instanceof \\Behat\\Gherkin\\Node\\TableNode) {\n\t\t\t$elementRows = $expectedElements->getRows();\n\t\t\t$elementsSimplified = $this->simplifyArray($elementRows);\n\t\t\tforeach($elementsSimplified as $expectedElement) {\n\t\t\t\t$webdavPath = \"/\" . $this->davPath . $expectedElement;\n\t\t\t\tif (!array_key_exists($webdavPath,$elementList)){\n\t\t\t\t\tPHPUnit_Framework_Assert::fail(\"$webdavPath\" . \" is not in propfind answer\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @When User :user uploads file :source to :destination\n\t */\n\tpublic function userUploadsAFileTo($user, $source, $destination)\n\t{\n\t\t$file = \\GuzzleHttp\\Stream\\Stream::factory(fopen($source, 'r'));\n\t\ttry {\n\t\t\t$this->response = $this->makeDavRequest($user, \"PUT\", $destination, [], $file);\n\t\t} catch (\\GuzzleHttp\\Exception\\ServerException $e) {\n\t\t\t// 4xx and 5xx responses cause an exception\n\t\t\t$this->response = $e->getResponse();\n\t\t}\n\t}\n\n\t/**\n\t * @When User :user deletes file :file\n\t */\n\tpublic function userDeletesFile($user, $file)  {\n\t\ttry {\n\t\t\t$this->response = $this->makeDavRequest($user, 'DELETE', $file, []);\n\t\t} catch (\\GuzzleHttp\\Exception\\ServerException $e) {\n\t\t\t// 4xx and 5xx responses cause an exception\n\t\t\t$this->response = $e->getResponse();\n\t\t}\n\t}\n\n\t/**\n\t * @Given User :user created a folder :destination\n\t */\n\tpublic function userCreatedAFolder($user, $destination){\n\t\ttry {\n\t\t\t$this->response = $this->makeDavRequest($user, \"MKCOL\", $destination, []);\n\t\t} catch (\\GuzzleHttp\\Exception\\ServerException $e) {\n\t\t\t// 4xx and 5xx responses cause an exception\n\t\t\t$this->response = $e->getResponse();\n\t\t}\n\t}\n\n\t/**\n\t * @Given user :user uploads chunk file :num of :total with :data to :destination\n\t */\n\tpublic function userUploadsChunkFileOfWithToWithChecksum($user, $num, $total, $data, $destination)\n\t{\n\t\t$num -= 1;\n\t\t$data = \\GuzzleHttp\\Stream\\Stream::factory($data);\n\t\t$file = $destination . '-chunking-42-'.$total.'-'.$num;\n\t\t$this->makeDavRequest($user, 'PUT', $file, ['OC-Chunked' => '1'], $data);\n\t}\n\n}\n\n", "Feature: webdav-related\n\tBackground:\n\t\tGiven using api version \"1\"\n\n\tScenario: moving a file old way\n\t\tGiven using dav path \"remote.php/webdav\"\n\t\tAnd As an \"admin\"\n\t\tAnd user \"user0\" exists\n\t\tWhen User \"user0\" moves file \"/textfile0.txt\" to \"/FOLDER/textfile0.txt\"\n\t\tThen the HTTP status code should be \"201\"\n\n\tScenario: download a file with range\n\t\tGiven using dav path \"remote.php/webdav\"\n\t\tAnd As an \"admin\"\n\t\tWhen Downloading file \"/welcome.txt\" with range \"bytes=52-78\"\n\t\tThen Downloaded content should be \"example file for developers\"\n\n\tScenario: Upload forbidden if quota is 0\n\t\tGiven using dav path \"remote.php/webdav\"\n\t\tAnd As an \"admin\"\n\t\tAnd user \"user0\" exists\n\t\tAnd user \"user0\" has a quota of \"0\"\n\t\tWhen User \"user0\" uploads file \"data/textfile.txt\" to \"/asdf.txt\"\n\t\tThen the HTTP status code should be \"507\"\n\n\tScenario: Retrieving folder quota when no quota is set\n\t\tGiven using dav path \"remote.php/webdav\"\n\t\tAnd As an \"admin\"\n\t\tAnd user \"user0\" exists\n\t\tWhen user \"user0\" has unlimited quota\n\t\tThen as \"user0\" gets properties of folder \"/\" with\n\t\t  |{DAV:}quota-available-bytes|\n\t\tAnd the single response should contain a property \"{DAV:}quota-available-bytes\" with value \"-3\"\n\n\tScenario: Retrieving folder quota when quota is set\n\t\tGiven using dav path \"remote.php/webdav\"\n\t\tAnd As an \"admin\"\n\t\tAnd user \"user0\" exists\n\t\tWhen user \"user0\" has a quota of \"10 MB\"\n\t\tThen as \"user0\" gets properties of folder \"/\" with\n\t\t  |{DAV:}quota-available-bytes|\n\t\tAnd the single response should contain a property \"{DAV:}quota-available-bytes\" with value \"10485428\"\n\n\tScenario: Retrieving folder quota of shared folder with quota when no quota is set for recipient\n\t\tGiven using dav path \"remote.php/webdav\"\n\t\tAnd As an \"admin\"\n\t\tAnd user \"user0\" exists\n\t\tAnd user \"user1\" exists\n\t\tAnd user \"user0\" has unlimited quota\n\t\tAnd user \"user1\" has a quota of \"10 MB\"\n\t\tAnd As an \"user1\"\n\t\tAnd user \"user1\" created a folder \"/testquota\"\n\t\tAnd as \"user1\" creating a share with\n\t\t  | path | testquota |\n\t\t  | shareType | 0 |\n\t\t  | permissions | 31 |\n\t\t  | shareWith | user0 |\n\t\tThen as \"user0\" gets properties of folder \"/testquota\" with\n\t\t  |{DAV:}quota-available-bytes|\n\t\tAnd the single response should contain a property \"{DAV:}quota-available-bytes\" with value \"10485428\"\n\n\tScenario: download a public shared file with range\n\t\tGiven user \"user0\" exists\n\t\tAnd As an \"user0\"\n\t\tWhen creating a share with\n\t\t\t| path | welcome.txt |\n\t\t\t| shareType | 3 |\n\t\tAnd Downloading last public shared file with range \"bytes=52-78\"\n\t\tThen Downloaded content should be \"example file for developers\"\n\n\tScenario: Downloading a file on the old endpoint should serve security headers\n\t\tGiven using dav path \"remote.php/webdav\"\n\t\tAnd As an \"admin\"\n\t\tWhen Downloading file \"/welcome.txt\"\n\t\tThen The following headers should be set\n\t\t\t|Content-Disposition|attachment; filename*=UTF-8''welcome.txt; filename=\"welcome.txt\"|\n\t\t\t|Content-Security-Policy|default-src 'self'; script-src 'self' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; frame-src *; img-src * data: blob:; font-src 'self' data:; media-src *; connect-src *|\n\t\t\t|X-Content-Type-Options |nosniff|\n\t\t\t|X-Download-Options|noopen|\n\t\t\t|X-Frame-Options|Sameorigin|\n\t\t\t|X-Permitted-Cross-Domain-Policies|none|\n\t\t\t|X-Robots-Tag|none|\n\t\t\t|X-XSS-Protection|1; mode=block|\n\t\tAnd Downloaded content should start with \"Welcome to your Nextcloud account!\"\n\n\tScenario: Downloading a file on the new endpoint should serve security headers\n\t\tGiven using dav path \"remote.php/dav/files/admin/\"\n\t\tAnd As an \"admin\"\n\t\tWhen Downloading file \"/welcome.txt\"\n\t\tThen The following headers should be set\n\t\t\t|Content-Disposition|attachment; filename*=UTF-8''welcome.txt; filename=\"welcome.txt\"|\n\t\t\t|Content-Security-Policy|default-src 'self'; script-src 'self' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; frame-src *; img-src * data: blob:; font-src 'self' data:; media-src *; connect-src *|\n\t\t\t|X-Content-Type-Options |nosniff|\n\t\t\t|X-Download-Options|noopen|\n\t\t\t|X-Frame-Options|Sameorigin|\n\t\t\t|X-Permitted-Cross-Domain-Policies|none|\n\t\t\t|X-Robots-Tag|none|\n\t\t\t|X-XSS-Protection|1; mode=block|\n\t\tAnd Downloaded content should start with \"Welcome to your Nextcloud account!\"\n\n\tScenario: Doing a GET with a web login should work without CSRF token on the new backend\n\t\tGiven Logging in using web as \"admin\"\n\t\tWhen Sending a \"GET\" to \"/remote.php/dav/files/admin/welcome.txt\" without requesttoken\n\t\tThen Downloaded content should start with \"Welcome to your Nextcloud account!\"\n\t\tThen the HTTP status code should be \"200\"\n\n\tScenario: Doing a GET with a web login should work with CSRF token on the new backend\n\t\tGiven Logging in using web as \"admin\"\n\t\tWhen Sending a \"GET\" to \"/remote.php/dav/files/admin/welcome.txt\" with requesttoken\n\t\tThen Downloaded content should start with \"Welcome to your Nextcloud account!\"\n\t\tThen the HTTP status code should be \"200\"\n\n\tScenario: Doing a PROPFIND with a web login should not work without CSRF token on the new backend\n\t\tGiven Logging in using web as \"admin\"\n\t\tWhen Sending a \"PROPFIND\" to \"/remote.php/dav/files/admin/welcome.txt\" without requesttoken\n\t\tThen the HTTP status code should be \"401\"\n\n\tScenario: Doing a PROPFIND with a web login should work with CSRF token on the new backend\n\t\tGiven Logging in using web as \"admin\"\n\t\tWhen Sending a \"PROPFIND\" to \"/remote.php/dav/files/admin/welcome.txt\" with requesttoken\n\t\tThen the HTTP status code should be \"207\"\n\n\tScenario: Doing a GET with a web login should work without CSRF token on the old backend\n\t\tGiven Logging in using web as \"admin\"\n\t\tWhen Sending a \"GET\" to \"/remote.php/webdav/welcome.txt\" without requesttoken\n\t\tThen Downloaded content should start with \"Welcome to your Nextcloud account!\"\n\t\tThen the HTTP status code should be \"200\"\n\n\tScenario: Doing a GET with a web login should work with CSRF token on the old backend\n\t\tGiven Logging in using web as \"admin\"\n\t\tWhen Sending a \"GET\" to \"/remote.php/webdav/welcome.txt\" with requesttoken\n\t\tThen Downloaded content should start with \"Welcome to your Nextcloud account!\"\n\t\tThen the HTTP status code should be \"200\"\n\n\tScenario: Doing a PROPFIND with a web login should not work without CSRF token on the old backend\n\t\tGiven Logging in using web as \"admin\"\n\t\tWhen Sending a \"PROPFIND\" to \"/remote.php/webdav/welcome.txt\" without requesttoken\n\t\tThen the HTTP status code should be \"401\"\n\n\tScenario: Doing a PROPFIND with a web login should work with CSRF token on the old backend\n\t\tGiven Logging in using web as \"admin\"\n\t\tWhen Sending a \"PROPFIND\" to \"/remote.php/webdav/welcome.txt\" with requesttoken\n\t\tThen the HTTP status code should be \"207\"\n\n\tScenario: Upload chunked file asc\n\t\tGiven user \"user0\" exists\n\t\tAnd user \"user0\" uploads chunk file \"1\" of \"3\" with \"AAAAA\" to \"/myChunkedFile.txt\"\n\t\tAnd user \"user0\" uploads chunk file \"2\" of \"3\" with \"BBBBB\" to \"/myChunkedFile.txt\"\n\t\tAnd user \"user0\" uploads chunk file \"3\" of \"3\" with \"CCCCC\" to \"/myChunkedFile.txt\"\n\t\tWhen As an \"user0\"\n\t\tAnd Downloading file \"/myChunkedFile.txt\"\n\t\tThen Downloaded content should be \"AAAAABBBBBCCCCC\"\n\n\tScenario: Upload chunked file desc\n\t\tGiven user \"user0\" exists\n\t\tAnd user \"user0\" uploads chunk file \"3\" of \"3\" with \"CCCCC\" to \"/myChunkedFile.txt\"\n\t\tAnd user \"user0\" uploads chunk file \"2\" of \"3\" with \"BBBBB\" to \"/myChunkedFile.txt\"\n\t\tAnd user \"user0\" uploads chunk file \"1\" of \"3\" with \"AAAAA\" to \"/myChunkedFile.txt\"\n\t\tWhen As an \"user0\"\n\t\tAnd Downloading file \"/myChunkedFile.txt\"\n\t\tThen Downloaded content should be \"AAAAABBBBBCCCCC\"\n\n\tScenario: Upload chunked file random\n\t\tGiven user \"user0\" exists\n\t\tAnd user \"user0\" uploads chunk file \"2\" of \"3\" with \"BBBBB\" to \"/myChunkedFile.txt\"\n\t\tAnd user \"user0\" uploads chunk file \"3\" of \"3\" with \"CCCCC\" to \"/myChunkedFile.txt\"\n\t\tAnd user \"user0\" uploads chunk file \"1\" of \"3\" with \"AAAAA\" to \"/myChunkedFile.txt\"\n\t\tWhen As an \"user0\"\n\t\tAnd Downloading file \"/myChunkedFile.txt\"\n\t\tThen Downloaded content should be \"AAAAABBBBBCCCCC\"\n\n\tScenario: A file that is not shared does not have a share-types property\n\t\tGiven user \"user0\" exists\n\t\tAnd user \"user0\" created a folder \"/test\"\n\t\tWhen as \"user0\" gets properties of folder \"/test\" with\n\t\t\t|{http://owncloud.org/ns}share-types|\n\t\tThen the response should contain an empty property \"{http://owncloud.org/ns}share-types\"\n\n\tScenario: A file that is shared to a user has a share-types property\n\t\tGiven user \"user0\" exists\n\t\tAnd user \"user1\" exists\n\t\tAnd user \"user0\" created a folder \"/test\"\n\t\tAnd as \"user0\" creating a share with\n\t\t\t| path | test |\n\t\t\t| shareType | 0 |\n\t\t\t| permissions | 31 |\n\t\t\t| shareWith | user1 |\n\t\tWhen as \"user0\" gets properties of folder \"/test\" with\n\t\t\t|{http://owncloud.org/ns}share-types|\n\t\tThen the response should contain a share-types property with\n\t\t\t| 0 |\n\n\tScenario: A file that is shared to a group has a share-types property\n\t\tGiven user \"user0\" exists\n\t\tAnd group \"group1\" exists\n\t\tAnd user \"user0\" created a folder \"/test\"\n\t\tAnd as \"user0\" creating a share with\n\t\t\t| path | test |\n\t\t\t| shareType | 1 |\n\t\t\t| permissions | 31 |\n\t\t\t| shareWith | group1 |\n\t\tWhen as \"user0\" gets properties of folder \"/test\" with\n\t\t\t|{http://owncloud.org/ns}share-types|\n\t\tThen the response should contain a share-types property with\n\t\t\t| 1 |\n\n\tScenario: A file that is shared by link has a share-types property\n\t\tGiven user \"user0\" exists\n\t\tAnd user \"user0\" created a folder \"/test\"\n\t\tAnd as \"user0\" creating a share with\n\t\t\t| path | test |\n\t\t\t| shareType | 3 |\n\t\t\t| permissions | 31 |\n\t\tWhen as \"user0\" gets properties of folder \"/test\" with\n\t\t\t|{http://owncloud.org/ns}share-types|\n\t\tThen the response should contain a share-types property with\n\t\t\t| 3 |\n\n\tScenario: A file that is shared by user,group and link has a share-types property\n\t\tGiven user \"user0\" exists\n\t\tAnd user \"user1\" exists\n\t\tAnd group \"group2\" exists\n\t\tAnd user \"user0\" created a folder \"/test\"\n\t\tAnd as \"user0\" creating a share with\n\t\t\t| path        | test  |\n\t\t\t| shareType   | 0     |\n\t\t\t| permissions | 31    |\n\t\t\t| shareWith   | user1 |\n\t\tAnd as \"user0\" creating a share with\n\t\t\t| path        | test  |\n\t\t\t| shareType   | 1     |\n\t\t\t| permissions | 31    |\n\t\t\t| shareWith   | group2 |\n\t\tAnd as \"user0\" creating a share with\n\t\t\t| path        | test  |\n\t\t\t| shareType   | 3     |\n\t\t\t| permissions | 31    |\n\t\tWhen as \"user0\" gets properties of folder \"/test\" with\n\t\t\t|{http://owncloud.org/ns}share-types|\n\t\tThen the response should contain a share-types property with\n\t\t\t| 0 |\n\t\t\t| 1 |\n\t\t\t| 3 |\n\n\n\tScenario: Copying files into a folder with edit permissions\n\t\tGiven using dav path \"remote.php/webdav\"\n\t\tAnd user \"user0\" exists\n\t\tAnd user \"user1\" exists\n\t\tAnd As an \"user1\"\n\t\tAnd user \"user1\" created a folder \"/testcopypermissionsAllowed\"\n\t\tAnd as \"user1\" creating a share with\n\t\t\t| path | testcopypermissionsAllowed |\n\t\t\t| shareType | 0 |\n\t\t\t| permissions | 31 |\n\t\t\t| shareWith | user0 |\n\t\tAnd User \"user0\" uploads file with content \"copytest\" to \"/copytest.txt\"\n\t\tWhen User \"user0\" copies file \"/copytest.txt\" to \"/testcopypermissionsAllowed/copytest.txt\"\n\t\tThen the HTTP status code should be \"201\"\n\n\n\tScenario: Copying files into a folder without edit permissions\n\t\tGiven using dav path \"remote.php/webdav\"\n\t\tAnd user \"user0\" exists\n\t\tAnd user \"user1\" exists\n\t\tAnd As an \"user1\"\n\t\tAnd user \"user1\" created a folder \"/testcopypermissionsNotAllowed\"\n\t\tAnd as \"user1\" creating a share with\n\t\t\t| path | testcopypermissionsNotAllowed |\n\t\t\t| shareType | 0 |\n\t\t\t| permissions | 1 |\n\t\t\t| shareWith | user0 |\n\t\tAnd User \"user0\" uploads file with content \"copytest\" to \"/copytest.txt\"\n\t\tWhen User \"user0\" copies file \"/copytest.txt\" to \"/testcopypermissionsNotAllowed/copytest.txt\"\n\t\tThen the HTTP status code should be \"403\"\n"], "filenames": ["apps/dav/lib/connector/sabre/objecttree.php", "apps/dav/tests/unit/connector/sabre/objecttree.php", "build/integration/features/bootstrap/WebDav.php", "build/integration/features/webdav-related.feature"], "buggy_code_start_loc": [74, 58, 67, 243], "buggy_code_end_loc": [273, 68, 70, 243], "fixing_code_start_loc": [74, 59, 67, 244], "fixing_code_end_loc": [297, 89, 86, 276], "type": "CWE-284", "message": "Nextcloud Server before 9.0.52 & ownCloud Server before 9.0.4 are not properly verifying edit check permissions on WebDAV copy actions. The WebDAV endpoint was not properly checking the permission on a WebDAV COPY action. This allowed an authenticated attacker with access to a read-only share to put new files in there. It was not possible to modify existing files.", "other": {"cve": {"id": "CVE-2016-9461", "sourceIdentifier": "support@hackerone.com", "published": "2017-03-28T02:59:00.840", "lastModified": "2019-10-09T23:20:28.727", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Nextcloud Server before 9.0.52 & ownCloud Server before 9.0.4 are not properly verifying edit check permissions on WebDAV copy actions. The WebDAV endpoint was not properly checking the permission on a WebDAV COPY action. This allowed an authenticated attacker with access to a read-only share to put new files in there. It was not possible to modify existing files."}, {"lang": "es", "value": "Nextcloud Server en versiones anteriores a 9.0.52 & ownCloud Server en versiones anteriores a 9.0.4 no est\u00e1n verificando correctamente los permisos de comprobaci\u00f3n de edici\u00f3n en las acciones de copia de WebDAV. El punto final WebDAV no comprueba correctamente el permiso en una acci\u00f3n WebDAV COPY. Esto permiti\u00f3 a un atacante autenticado con acceso a un recurso compartido de solo lectura para poner all\u00ed nuevos archivos. No fue posible modificar los archivos existentes."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-284"}]}, {"source": "support@hackerone.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-275"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nextcloud:nextcloud_server:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.0.52", "matchCriteriaId": "DC479D9A-DAEB-42B6-98D7-0A417B34359D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:owncloud:owncloud:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.0.4", "matchCriteriaId": "3FAD2663-CE0E-4AB0-90C5-D47124458AAC"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/97276", "source": "support@hackerone.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/nextcloud/server/commit/3491400261c1454a9a30d3ec96969573330120cc", "source": "support@hackerone.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/owncloud/core/commit/0622e635d97cb17c5e1363e370bb8268cc3d2547", "source": "support@hackerone.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/owncloud/core/commit/121a3304a0c37ccda0e1b63ddc528cba9121a36e", "source": "support@hackerone.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/owncloud/core/commit/acbbadb71ceee7f01da347f7dcd519beda78cc47", "source": "support@hackerone.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/owncloud/core/commit/c0a4b7b3f38ad2eaf506484b3b92ec678cb021c9", "source": "support@hackerone.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://hackerone.com/reports/145950", "source": "support@hackerone.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://nextcloud.com/security/advisory/?id=nc-sa-2016-004", "source": "support@hackerone.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://owncloud.org/security/advisory/?id=oc-sa-2016-014", "source": "support@hackerone.com", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/nextcloud/server/commit/3491400261c1454a9a30d3ec96969573330120cc"}}