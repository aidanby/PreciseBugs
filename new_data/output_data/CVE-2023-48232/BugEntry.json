{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n/*\n * move.c: Functions for moving the cursor and scrolling text.\n *\n * There are two ways to move the cursor:\n * 1. Move the cursor directly, the text is scrolled to keep the cursor in the\n *    window.\n * 2. Scroll the text, the cursor is moved into the text visible in the\n *    window.\n * The 'scrolloff' option makes this a bit complicated.\n */\n\n#include \"vim.h\"\n\nstatic int scrolljump_value(void);\nstatic int check_top_offset(void);\nstatic void curs_rows(win_T *wp);\n\ntypedef struct\n{\n    linenr_T\t    lnum;\t// line number\n#ifdef FEAT_DIFF\n    int\t\t    fill;\t// filler lines\n#endif\n    int\t\t    height;\t// height of added line\n} lineoff_T;\n\nstatic void topline_back(lineoff_T *lp);\nstatic void botline_forw(lineoff_T *lp);\n\n/*\n * Get the number of screen lines skipped with \"wp->w_skipcol\".\n */\n    int\nadjust_plines_for_skipcol(win_T *wp)\n{\n    if (wp->w_skipcol == 0)\n\treturn 0;\n\n    int width = wp->w_width - win_col_off(wp);\n    if (wp->w_skipcol >= width)\n\treturn (wp->w_skipcol - width) / (width + win_col_off2(wp)) + 1;\n\n    return 0;\n}\n\n/*\n * Return how many lines \"lnum\" will take on the screen, taking into account\n * whether it is the first line, whether w_skipcol is non-zero and limiting to\n * the window height.\n */\n    static int\nplines_correct_topline(win_T *wp, linenr_T lnum)\n{\n    int n;\n#ifdef FEAT_DIFF\n    if (lnum == wp->w_topline)\n\tn = plines_win_nofill(wp, lnum, FALSE) + wp->w_topfill;\n    else\n#endif\n\tn = plines_win(wp, lnum, FALSE);\n    if (lnum == wp->w_topline)\n\tn -= adjust_plines_for_skipcol(wp);\n    if (n > wp->w_height)\n\tn = wp->w_height;\n    return n;\n}\n\n/*\n * Compute wp->w_botline for the current wp->w_topline.  Can be called after\n * wp->w_topline changed.\n */\n    static void\ncomp_botline(win_T *wp)\n{\n    int\t\tn;\n    linenr_T\tlnum;\n    int\t\tdone;\n#ifdef FEAT_FOLDING\n    linenr_T    last;\n    int\t\tfolded;\n#endif\n\n    /*\n     * If w_cline_row is valid, start there.\n     * Otherwise have to start at w_topline.\n     */\n    check_cursor_moved(wp);\n    if (wp->w_valid & VALID_CROW)\n    {\n\tlnum = wp->w_cursor.lnum;\n\tdone = wp->w_cline_row;\n    }\n    else\n    {\n\tlnum = wp->w_topline;\n\tdone = 0;\n    }\n\n    for ( ; lnum <= wp->w_buffer->b_ml.ml_line_count; ++lnum)\n    {\n#ifdef FEAT_FOLDING\n\tlast = lnum;\n\tfolded = FALSE;\n\tif (hasFoldingWin(wp, lnum, NULL, &last, TRUE, NULL))\n\t{\n\t    n = 1;\n\t    folded = TRUE;\n\t}\n\telse\n#endif\n\t{\n\t    n = plines_correct_topline(wp, lnum);\n\t}\n\tif (\n#ifdef FEAT_FOLDING\n\t\tlnum <= wp->w_cursor.lnum && last >= wp->w_cursor.lnum\n#else\n\t\tlnum == wp->w_cursor.lnum\n#endif\n\t   )\n\t{\n\t    wp->w_cline_row = done;\n\t    wp->w_cline_height = n;\n#ifdef FEAT_FOLDING\n\t    wp->w_cline_folded = folded;\n#endif\n\t    redraw_for_cursorline(wp);\n\t    wp->w_valid |= (VALID_CROW|VALID_CHEIGHT);\n\t}\n\tif (done + n > wp->w_height)\n\t    break;\n\tdone += n;\n#ifdef FEAT_FOLDING\n\tlnum = last;\n#endif\n    }\n\n    // wp->w_botline is the line that is just below the window\n    wp->w_botline = lnum;\n    wp->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;\n\n    set_empty_rows(wp, done);\n}\n\n/*\n * Redraw when w_cline_row changes and 'relativenumber' or 'cursorline' is\n * set.\n */\n    void\nredraw_for_cursorline(win_T *wp)\n{\n    if ((wp->w_p_rnu\n#ifdef FEAT_SYN_HL\n\t\t|| wp->w_p_cul\n#endif\n\t\t)\n\t    && (wp->w_valid & VALID_CROW) == 0\n\t    && !pum_visible())\n    {\n\t// win_line() will redraw the number column and cursorline only.\n\tredraw_win_later(wp, UPD_VALID);\n    }\n}\n\n#ifdef FEAT_SYN_HL\n/*\n * Redraw when w_virtcol changes and 'cursorcolumn' is set or 'cursorlineopt'\n * contains \"screenline\".\n */\n    static void\nredraw_for_cursorcolumn(win_T *wp)\n{\n    if ((wp->w_valid & VALID_VIRTCOL) == 0 && !pum_visible())\n    {\n\t// When 'cursorcolumn' is set need to redraw with UPD_SOME_VALID.\n\tif (wp->w_p_cuc)\n\t    redraw_win_later(wp, UPD_SOME_VALID);\n\t// When 'cursorlineopt' contains \"screenline\" need to redraw with\n\t// UPD_VALID.\n\telse if (wp->w_p_cul && (wp->w_p_culopt_flags & CULOPT_SCRLINE))\n\t    redraw_win_later(wp, UPD_VALID);\n    }\n}\n#endif\n\n/*\n * Calculates how much the 'listchars' \"precedes\" or 'smoothscroll' \"<<<\"\n * marker overlaps with buffer text for window \"wp\".\n * Parameter \"extra2\" should be the padding on the 2nd line, not the first\n * line.\n * Returns the number of columns of overlap with buffer text, excluding the\n * extra padding on the ledge.\n */\n     int\nsms_marker_overlap(win_T *wp, int extra2)\n{\n#if defined(FEAT_LINEBREAK)\n    // There is no marker overlap when in showbreak mode, thus no need to\n    // account for it.  See wlv_screen_line().\n    if (*get_showbreak_value(wp) != NUL)\n\treturn 0;\n#endif\n    // Overlap when 'list' and 'listchars' \"precedes\" are set is 1.\n    if (wp->w_p_list && wp->w_lcs_chars.prec)\n\treturn 1;\n\n    return extra2 > 3 ? 0 : 3 - extra2;\n}\n\n/*\n * Calculates the skipcol offset for window \"wp\" given how many\n * physical lines we want to scroll down.\n */\n    static int\nskipcol_from_plines(win_T *wp, int plines_off)\n{\n    int width1 = wp->w_width - win_col_off(wp);\n\n    int skipcol = 0;\n    if (plines_off > 0)\n\tskipcol += width1;\n    if (plines_off > 1)\n\tskipcol += (width1 + win_col_off2(wp)) * (plines_off - 1);\n    return skipcol;\n}\n\n/*\n * Set curwin->w_skipcol to zero and redraw later if needed.\n */\n    static void\nreset_skipcol(void)\n{\n    if (curwin->w_skipcol == 0)\n\treturn;\n\n    curwin->w_skipcol = 0;\n\n    // Should use the least expensive way that displays all that changed.\n    // UPD_NOT_VALID is too expensive, UPD_REDRAW_TOP does not redraw\n    // enough when the top line gets another screen line.\n    redraw_later(UPD_SOME_VALID);\n}\n\n/*\n * Update curwin->w_topline and redraw if necessary.\n * Used to update the screen before printing a message.\n */\n    void\nupdate_topline_redraw(void)\n{\n    update_topline();\n    if (must_redraw)\n\tupdate_screen(0);\n}\n\n/*\n * Update curwin->w_topline to move the cursor onto the screen.\n */\n    void\nupdate_topline(void)\n{\n    long\tline_count;\n    int\t\thalfheight;\n    int\t\tn;\n#ifdef FEAT_FOLDING\n    linenr_T\tlnum;\n#endif\n    int\t\tcheck_topline = FALSE;\n    int\t\tcheck_botline = FALSE;\n    long\t*so_ptr = curwin->w_p_so >= 0 ? &curwin->w_p_so : &p_so;\n    int\t\tsave_so = *so_ptr;\n\n    // Cursor is updated instead when this is TRUE for 'splitkeep'.\n    if (skip_update_topline)\n\treturn;\n\n    // If there is no valid screen and when the window height is zero just use\n    // the cursor line.\n    if (!screen_valid(TRUE) || curwin->w_height == 0)\n    {\n\tcheck_cursor_lnum();\n\tcurwin->w_topline = curwin->w_cursor.lnum;\n\tcurwin->w_botline = curwin->w_topline;\n\tcurwin->w_scbind_pos = 1;\n\treturn;\n    }\n\n    check_cursor_moved(curwin);\n    if (curwin->w_valid & VALID_TOPLINE)\n\treturn;\n\n    // When dragging with the mouse, don't scroll that quickly\n    if (mouse_dragging > 0)\n\t*so_ptr = mouse_dragging - 1;\n\n    linenr_T old_topline = curwin->w_topline;\n#ifdef FEAT_DIFF\n    int old_topfill = curwin->w_topfill;\n#endif\n\n    /*\n     * If the buffer is empty, always set topline to 1.\n     */\n    if (BUFEMPTY())\t\t// special case - file is empty\n    {\n\tif (curwin->w_topline != 1)\n\t    redraw_later(UPD_NOT_VALID);\n\tcurwin->w_topline = 1;\n\tcurwin->w_botline = 2;\n\tcurwin->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;\n\tcurwin->w_scbind_pos = 1;\n    }\n\n    /*\n     * If the cursor is above or near the top of the window, scroll the window\n     * to show the line the cursor is in, with 'scrolloff' context.\n     */\n    else\n    {\n\tif (curwin->w_topline > 1 || curwin->w_skipcol > 0)\n\t{\n\t    // If the cursor is above topline, scrolling is always needed.\n\t    // If the cursor is far below topline and there is no folding,\n\t    // scrolling down is never needed.\n\t    if (curwin->w_cursor.lnum < curwin->w_topline)\n\t\tcheck_topline = TRUE;\n\t    else if (check_top_offset())\n\t\tcheck_topline = TRUE;\n\t    else if (curwin->w_skipcol > 0\n\t\t\t\t && curwin->w_cursor.lnum == curwin->w_topline)\n\t    {\n\t\tcolnr_T vcol;\n\n\t\t// Check that the cursor position is visible.  Add columns for\n\t\t// the marker displayed in the top-left if needed.\n\t\tgetvvcol(curwin, &curwin->w_cursor, &vcol, NULL, NULL);\n\t\tint overlap = sms_marker_overlap(curwin, curwin_col_off()\n\t\t\t\t\t\t\t- curwin_col_off2());\n\t\tif (curwin->w_skipcol + overlap > vcol)\n\t\t    check_topline = TRUE;\n\t    }\n\t}\n#ifdef FEAT_DIFF\n\t    // Check if there are more filler lines than allowed.\n\tif (!check_topline && curwin->w_topfill > diff_check_fill(curwin,\n\t\t\t\t\t\t\t   curwin->w_topline))\n\t    check_topline = TRUE;\n#endif\n\n\tif (check_topline)\n\t{\n\t    halfheight = curwin->w_height / 2 - 1;\n\t    if (halfheight < 2)\n\t\thalfheight = 2;\n\n#ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\t// Count the number of logical lines between the cursor and\n\t\t// topline + scrolloff (approximation of how much will be\n\t\t// scrolled).\n\t\tn = 0;\n\t\tfor (lnum = curwin->w_cursor.lnum;\n\t\t\t\t    lnum < curwin->w_topline + *so_ptr; ++lnum)\n\t\t{\n\t\t    ++n;\n\t\t    // stop at end of file or when we know we are far off\n\t\t    if (lnum >= curbuf->b_ml.ml_line_count || n >= halfheight)\n\t\t\tbreak;\n\t\t    (void)hasFolding(lnum, NULL, &lnum);\n\t\t}\n\t    }\n\t    else\n#endif\n\t\tn = curwin->w_topline + *so_ptr - curwin->w_cursor.lnum;\n\n\t    // If we weren't very close to begin with, we scroll to put the\n\t    // cursor in the middle of the window.  Otherwise put the cursor\n\t    // near the top of the window.\n\t    if (n >= halfheight)\n\t\tscroll_cursor_halfway(FALSE, FALSE);\n\t    else\n\t    {\n\t\tscroll_cursor_top(scrolljump_value(), FALSE);\n\t\tcheck_botline = TRUE;\n\t    }\n\t}\n\n\telse\n\t{\n#ifdef FEAT_FOLDING\n\t    // Make sure topline is the first line of a fold.\n\t    (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n\t    check_botline = TRUE;\n\t}\n    }\n\n    /*\n     * If the cursor is below the bottom of the window, scroll the window\n     * to put the cursor on the window.\n     * When w_botline is invalid, recompute it first, to avoid a redraw later.\n     * If w_botline was approximated, we might need a redraw later in a few\n     * cases, but we don't want to spend (a lot of) time recomputing w_botline\n     * for every small change.\n     */\n    if (check_botline)\n    {\n\tif (!(curwin->w_valid & VALID_BOTLINE_AP))\n\t    validate_botline();\n\n\tif (curwin->w_botline <= curbuf->b_ml.ml_line_count)\n\t{\n\t    if (curwin->w_cursor.lnum < curwin->w_botline)\n\t    {\n\t      if (((long)curwin->w_cursor.lnum\n\t\t\t\t\t   >= (long)curwin->w_botline - *so_ptr\n#ifdef FEAT_FOLDING\n\t\t\t|| hasAnyFolding(curwin)\n#endif\n\t\t\t))\n\t      {\n\t\tlineoff_T\tloff;\n\n\t\t// Cursor is (a few lines) above botline, check if there are\n\t\t// 'scrolloff' window lines below the cursor.  If not, need to\n\t\t// scroll.\n\t\tn = curwin->w_empty_rows;\n\t\tloff.lnum = curwin->w_cursor.lnum;\n#ifdef FEAT_FOLDING\n\t\t// In a fold go to its last line.\n\t\t(void)hasFolding(loff.lnum, NULL, &loff.lnum);\n#endif\n#ifdef FEAT_DIFF\n\t\tloff.fill = 0;\n\t\tn += curwin->w_filler_rows;\n#endif\n\t\tloff.height = 0;\n\t\twhile (loff.lnum < curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t\t&& (loff.lnum + 1 < curwin->w_botline || loff.fill == 0)\n#endif\n\t\t\t)\n\t\t{\n\t\t    n += loff.height;\n\t\t    if (n >= *so_ptr)\n\t\t\tbreak;\n\t\t    botline_forw(&loff);\n\t\t}\n\t\tif (n >= *so_ptr)\n\t\t    // sufficient context, no need to scroll\n\t\t    check_botline = FALSE;\n\t      }\n\t      else\n\t\t  // sufficient context, no need to scroll\n\t\t  check_botline = FALSE;\n\t    }\n\t    if (check_botline)\n\t    {\n#ifdef FEAT_FOLDING\n\t\tif (hasAnyFolding(curwin))\n\t\t{\n\t\t    // Count the number of logical lines between the cursor and\n\t\t    // botline - scrolloff (approximation of how much will be\n\t\t    // scrolled).\n\t\t    line_count = 0;\n\t\t    for (lnum = curwin->w_cursor.lnum;\n\t\t\t\t   lnum >= curwin->w_botline - *so_ptr; --lnum)\n\t\t    {\n\t\t\t++line_count;\n\t\t\t// stop at end of file or when we know we are far off\n\t\t\tif (lnum <= 0 || line_count > curwin->w_height + 1)\n\t\t\t    break;\n\t\t\t(void)hasFolding(lnum, &lnum, NULL);\n\t\t    }\n\t\t}\n\t\telse\n#endif\n\t\t    line_count = curwin->w_cursor.lnum - curwin->w_botline\n\t\t\t\t\t\t\t\t + 1 + *so_ptr;\n\t\tif (line_count <= curwin->w_height + 1)\n\t\t    scroll_cursor_bot(scrolljump_value(), FALSE);\n\t\telse\n\t\t    scroll_cursor_halfway(FALSE, FALSE);\n\t    }\n\t}\n    }\n    curwin->w_valid |= VALID_TOPLINE;\n\n    /*\n     * Need to redraw when topline changed.\n     */\n    if (curwin->w_topline != old_topline\n#ifdef FEAT_DIFF\n\t    || curwin->w_topfill != old_topfill\n#endif\n\t    )\n    {\n\tdollar_vcol = -1;\n\tredraw_later(UPD_VALID);\n\n\t// When 'smoothscroll' is not set, should reset w_skipcol.\n\tif (!curwin->w_p_sms)\n\t    reset_skipcol();\n\telse if (curwin->w_skipcol != 0)\n\t    redraw_later(UPD_SOME_VALID);\n\n\t// May need to set w_skipcol when cursor in w_topline.\n\tif (curwin->w_cursor.lnum == curwin->w_topline)\n\t    validate_cursor();\n    }\n\n    *so_ptr = save_so;\n}\n\n/*\n * Return the scrolljump value to use for the current window.\n * When 'scrolljump' is positive use it as-is.\n * When 'scrolljump' is negative use it as a percentage of the window height.\n */\n    static int\nscrolljump_value(void)\n{\n    if (p_sj >= 0)\n\treturn (int)p_sj;\n    return (curwin->w_height * -p_sj) / 100;\n}\n\n/*\n * Return TRUE when there are not 'scrolloff' lines above the cursor for the\n * current window.\n */\n    static int\ncheck_top_offset(void)\n{\n    lineoff_T\tloff;\n    int\t\tn;\n    long\tso = get_scrolloff_value();\n\n    if (curwin->w_cursor.lnum < curwin->w_topline + so\n#ifdef FEAT_FOLDING\n\t\t    || hasAnyFolding(curwin)\n#endif\n\t    )\n    {\n\tloff.lnum = curwin->w_cursor.lnum;\n#ifdef FEAT_DIFF\n\tloff.fill = 0;\n\tn = curwin->w_topfill;\t    // always have this context\n#else\n\tn = 0;\n#endif\n\t// Count the visible screen lines above the cursor line.\n\twhile (n < so)\n\t{\n\t    topline_back(&loff);\n\t    // Stop when included a line above the window.\n\t    if (loff.lnum < curwin->w_topline\n#ifdef FEAT_DIFF\n\t\t    || (loff.lnum == curwin->w_topline && loff.fill > 0)\n#endif\n\t\t    )\n\t\tbreak;\n\t    n += loff.height;\n\t}\n\tif (n < so)\n\t    return TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Update w_curswant.\n */\n    void\nupdate_curswant_force(void)\n{\n    validate_virtcol();\n    curwin->w_curswant = curwin->w_virtcol\n#ifdef FEAT_PROP_POPUP\n\t- curwin->w_virtcol_first_char\n#endif\n\t;\n    curwin->w_set_curswant = FALSE;\n}\n\n/*\n * Update w_curswant if w_set_curswant is set.\n */\n    void\nupdate_curswant(void)\n{\n    if (curwin->w_set_curswant)\n\tupdate_curswant_force();\n}\n\n/*\n * Check if the cursor has moved.  Set the w_valid flag accordingly.\n */\n    void\ncheck_cursor_moved(win_T *wp)\n{\n    if (wp->w_cursor.lnum != wp->w_valid_cursor.lnum)\n    {\n\twp->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL\n\t\t\t\t      |VALID_CHEIGHT|VALID_CROW|VALID_TOPLINE\n\t\t\t\t      |VALID_BOTLINE|VALID_BOTLINE_AP);\n\twp->w_valid_cursor = wp->w_cursor;\n\twp->w_valid_leftcol = wp->w_leftcol;\n\twp->w_valid_skipcol = wp->w_skipcol;\n    }\n    else if (wp->w_skipcol != wp->w_valid_skipcol)\n    {\n\twp->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL\n\t\t\t\t      |VALID_CHEIGHT|VALID_CROW\n\t\t\t\t      |VALID_BOTLINE|VALID_BOTLINE_AP);\n\twp->w_valid_cursor = wp->w_cursor;\n\twp->w_valid_leftcol = wp->w_leftcol;\n\twp->w_valid_skipcol = wp->w_skipcol;\n    }\n    else if (wp->w_cursor.col != wp->w_valid_cursor.col\n\t     || wp->w_leftcol != wp->w_valid_leftcol\n\t     || wp->w_cursor.coladd != wp->w_valid_cursor.coladd)\n    {\n\twp->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL);\n\twp->w_valid_cursor.col = wp->w_cursor.col;\n\twp->w_valid_leftcol = wp->w_leftcol;\n\twp->w_valid_cursor.coladd = wp->w_cursor.coladd;\n    }\n}\n\n/*\n * Call this function when some window settings have changed, which require\n * the cursor position, botline and topline to be recomputed and the window to\n * be redrawn.  E.g, when changing the 'wrap' option or folding.\n */\n    void\nchanged_window_setting(void)\n{\n    changed_window_setting_win(curwin);\n}\n\n    void\nchanged_window_setting_win(win_T *wp)\n{\n    wp->w_lines_valid = 0;\n    changed_line_abv_curs_win(wp);\n    wp->w_valid &= ~(VALID_BOTLINE|VALID_BOTLINE_AP|VALID_TOPLINE);\n    redraw_win_later(wp, UPD_NOT_VALID);\n}\n\n#if defined(FEAT_PROP_POPUP) || defined(PROTO)\n/*\n * Call changed_window_setting_win() for every window containing \"buf\".\n */\n    void\nchanged_window_setting_buf(buf_T *buf)\n{\n    tabpage_T\t*tp;\n    win_T\t*wp;\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\tif (wp->w_buffer == buf)\n\t    changed_window_setting_win(wp);\n}\n#endif\n\n/*\n * Set wp->w_topline to a certain number.\n */\n    void\nset_topline(win_T *wp, linenr_T lnum)\n{\n#ifdef FEAT_DIFF\n    linenr_T prev_topline = wp->w_topline;\n#endif\n\n#ifdef FEAT_FOLDING\n    // go to first of folded lines\n    (void)hasFoldingWin(wp, lnum, &lnum, NULL, TRUE, NULL);\n#endif\n    // Approximate the value of w_botline\n    wp->w_botline += lnum - wp->w_topline;\n    if (wp->w_botline > wp->w_buffer->b_ml.ml_line_count + 1)\n\twp->w_botline = wp->w_buffer->b_ml.ml_line_count + 1;\n    wp->w_topline = lnum;\n    wp->w_topline_was_set = TRUE;\n#ifdef FEAT_DIFF\n    if (lnum != prev_topline)\n\t// Keep the filler lines when the topline didn't change.\n\twp->w_topfill = 0;\n#endif\n    wp->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE|VALID_TOPLINE);\n    // Don't set VALID_TOPLINE here, 'scrolloff' needs to be checked.\n    redraw_later(UPD_VALID);\n}\n\n/*\n * Call this function when the length of the cursor line (in screen\n * characters) has changed, and the change is before the cursor.\n * If the line length changed the number of screen lines might change,\n * requiring updating w_topline.  That may also invalidate w_crow.\n * Need to take care of w_botline separately!\n */\n    void\nchanged_cline_bef_curs(void)\n{\n    curwin->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL|VALID_CROW\n\t\t\t\t\t\t|VALID_CHEIGHT|VALID_TOPLINE);\n}\n\n    void\nchanged_cline_bef_curs_win(win_T *wp)\n{\n    wp->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL|VALID_CROW\n\t\t\t\t\t\t|VALID_CHEIGHT|VALID_TOPLINE);\n}\n\n/*\n * Call this function when the length of a line (in screen characters) above\n * the cursor have changed.\n * Need to take care of w_botline separately!\n */\n    void\nchanged_line_abv_curs(void)\n{\n    curwin->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL|VALID_CROW\n\t\t\t\t\t\t|VALID_CHEIGHT|VALID_TOPLINE);\n}\n\n    void\nchanged_line_abv_curs_win(win_T *wp)\n{\n    wp->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL|VALID_CROW\n\t\t\t\t\t\t|VALID_CHEIGHT|VALID_TOPLINE);\n}\n\n#if defined(FEAT_PROP_POPUP) || defined(PROTO)\n/*\n * Display of line has changed for \"buf\", invalidate cursor position and\n * w_botline.\n */\n    void\nchanged_line_display_buf(buf_T *buf)\n{\n    win_T *wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (wp->w_buffer == buf)\n\t    wp->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL\n\t\t\t\t|VALID_CROW|VALID_CHEIGHT\n\t\t\t\t|VALID_TOPLINE|VALID_BOTLINE|VALID_BOTLINE_AP);\n}\n#endif\n\n/*\n * Make sure the value of curwin->w_botline is valid.\n */\n    void\nvalidate_botline(void)\n{\n    validate_botline_win(curwin);\n}\n\n/*\n * Make sure the value of wp->w_botline is valid.\n */\n    void\nvalidate_botline_win(win_T *wp)\n{\n    if (!(wp->w_valid & VALID_BOTLINE))\n\tcomp_botline(wp);\n}\n\n/*\n * Mark curwin->w_botline as invalid (because of some change in the buffer).\n */\n    void\ninvalidate_botline(void)\n{\n    curwin->w_valid &= ~(VALID_BOTLINE|VALID_BOTLINE_AP);\n}\n\n    void\ninvalidate_botline_win(win_T *wp)\n{\n    wp->w_valid &= ~(VALID_BOTLINE|VALID_BOTLINE_AP);\n}\n\n    void\napproximate_botline_win(\n    win_T\t*wp)\n{\n    wp->w_valid &= ~VALID_BOTLINE;\n}\n\n/*\n * Return TRUE if curwin->w_wrow and curwin->w_wcol are valid.\n */\n    int\ncursor_valid(void)\n{\n    check_cursor_moved(curwin);\n    return ((curwin->w_valid & (VALID_WROW|VALID_WCOL)) ==\n\t\t\t\t\t\t      (VALID_WROW|VALID_WCOL));\n}\n\n/*\n * Validate cursor position.  Makes sure w_wrow and w_wcol are valid.\n * w_topline must be valid, you may need to call update_topline() first!\n */\n    void\nvalidate_cursor(void)\n{\n    check_cursor_lnum();\n    check_cursor_moved(curwin);\n    if ((curwin->w_valid & (VALID_WCOL|VALID_WROW)) != (VALID_WCOL|VALID_WROW))\n\tcurs_columns(TRUE);\n}\n\n#if defined(FEAT_GUI) || defined(PROTO)\n/*\n * validate w_cline_row.\n */\n    void\nvalidate_cline_row(void)\n{\n    /*\n     * First make sure that w_topline is valid (after moving the cursor).\n     */\n    update_topline();\n    check_cursor_moved(curwin);\n    if (!(curwin->w_valid & VALID_CROW))\n\tcurs_rows(curwin);\n}\n#endif\n\n/*\n * Compute wp->w_cline_row and wp->w_cline_height, based on the current value\n * of wp->w_topline.\n */\n    static void\ncurs_rows(win_T *wp)\n{\n    linenr_T\tlnum;\n    int\t\ti;\n    int\t\tall_invalid;\n    int\t\tvalid;\n#ifdef FEAT_FOLDING\n    long\tfold_count;\n#endif\n\n    // Check if wp->w_lines[].wl_size is invalid\n    all_invalid = (!redrawing()\n\t\t\t|| wp->w_lines_valid == 0\n\t\t\t|| wp->w_lines[0].wl_lnum > wp->w_topline);\n    i = 0;\n    wp->w_cline_row = 0;\n    for (lnum = wp->w_topline; lnum < wp->w_cursor.lnum; ++i)\n    {\n\tvalid = FALSE;\n\tif (!all_invalid && i < wp->w_lines_valid)\n\t{\n\t    if (wp->w_lines[i].wl_lnum < lnum || !wp->w_lines[i].wl_valid)\n\t\tcontinue;\t\t// skip changed or deleted lines\n\t    if (wp->w_lines[i].wl_lnum == lnum)\n\t    {\n#ifdef FEAT_FOLDING\n\t\t// Check for newly inserted lines below this row, in which\n\t\t// case we need to check for folded lines.\n\t\tif (!wp->w_buffer->b_mod_set\n\t\t\t|| wp->w_lines[i].wl_lastlnum < wp->w_cursor.lnum\n\t\t\t|| wp->w_buffer->b_mod_top\n\t\t\t\t\t     > wp->w_lines[i].wl_lastlnum + 1)\n#endif\n\t\tvalid = TRUE;\n\t    }\n\t    else if (wp->w_lines[i].wl_lnum > lnum)\n\t\t--i;\t\t\t// hold at inserted lines\n\t}\n\tif (valid\n\t       && (lnum != wp->w_topline || (wp->w_skipcol == 0\n#ifdef FEAT_DIFF\n\t\t\t\t\t    && !wp->w_p_diff\n#endif\n\t       )))\n\t{\n#ifdef FEAT_FOLDING\n\t    lnum = wp->w_lines[i].wl_lastlnum + 1;\n\t    // Cursor inside folded lines, don't count this row\n\t    if (lnum > wp->w_cursor.lnum)\n\t\tbreak;\n#else\n\t    ++lnum;\n#endif\n\t    wp->w_cline_row += wp->w_lines[i].wl_size;\n\t}\n\telse\n\t{\n#ifdef FEAT_FOLDING\n\t    fold_count = foldedCount(wp, lnum, NULL);\n\t    if (fold_count)\n\t    {\n\t\tlnum += fold_count;\n\t\tif (lnum > wp->w_cursor.lnum)\n\t\t    break;\n\t\t++wp->w_cline_row;\n\t    }\n\t    else\n#endif\n\t    {\n\t\twp->w_cline_row += plines_correct_topline(wp, lnum);\n\t\t++lnum;\n\t    }\n\t}\n    }\n\n    check_cursor_moved(wp);\n    if (!(wp->w_valid & VALID_CHEIGHT))\n    {\n\tif (all_invalid\n\t\t|| i == wp->w_lines_valid\n\t\t|| (i < wp->w_lines_valid\n\t\t    && (!wp->w_lines[i].wl_valid\n\t\t\t|| wp->w_lines[i].wl_lnum != wp->w_cursor.lnum)))\n\t{\n#ifdef FEAT_DIFF\n\t    if (wp->w_cursor.lnum == wp->w_topline)\n\t\twp->w_cline_height = plines_win_nofill(wp, wp->w_cursor.lnum,\n\t\t\t\t\t\t\tTRUE) + wp->w_topfill;\n\t    else\n#endif\n\t\twp->w_cline_height = plines_win(wp, wp->w_cursor.lnum, TRUE);\n#ifdef FEAT_FOLDING\n\t    wp->w_cline_folded = hasFoldingWin(wp, wp->w_cursor.lnum,\n\t\t\t\t\t\t      NULL, NULL, TRUE, NULL);\n#endif\n\t}\n\telse if (i > wp->w_lines_valid)\n\t{\n\t    // a line that is too long to fit on the last screen line\n\t    wp->w_cline_height = 0;\n#ifdef FEAT_FOLDING\n\t    wp->w_cline_folded = hasFoldingWin(wp, wp->w_cursor.lnum,\n\t\t\t\t\t\t      NULL, NULL, TRUE, NULL);\n#endif\n\t}\n\telse\n\t{\n\t    wp->w_cline_height = wp->w_lines[i].wl_size;\n#ifdef FEAT_FOLDING\n\t    wp->w_cline_folded = wp->w_lines[i].wl_folded;\n#endif\n\t}\n    }\n\n    redraw_for_cursorline(curwin);\n    wp->w_valid |= VALID_CROW|VALID_CHEIGHT;\n}\n\n/*\n * Validate curwin->w_virtcol only.\n */\n    void\nvalidate_virtcol(void)\n{\n    validate_virtcol_win(curwin);\n}\n\n/*\n * Validate wp->w_virtcol only.\n */\n    void\nvalidate_virtcol_win(win_T *wp)\n{\n    check_cursor_moved(wp);\n\n    if (wp->w_valid & VALID_VIRTCOL)\n\treturn;\n\n#ifdef FEAT_PROP_POPUP\n    wp->w_virtcol_first_char = 0;\n#endif\n    getvvcol(wp, &wp->w_cursor, NULL, &(wp->w_virtcol), NULL);\n#ifdef FEAT_SYN_HL\n    redraw_for_cursorcolumn(wp);\n#endif\n    wp->w_valid |= VALID_VIRTCOL;\n}\n\n/*\n * Validate curwin->w_cline_height only.\n */\n    void\nvalidate_cheight(void)\n{\n    check_cursor_moved(curwin);\n\n    if (curwin->w_valid & VALID_CHEIGHT)\n\treturn;\n\n#ifdef FEAT_DIFF\n    if (curwin->w_cursor.lnum == curwin->w_topline)\n\tcurwin->w_cline_height = plines_nofill(curwin->w_cursor.lnum)\n\t    + curwin->w_topfill;\n    else\n#endif\n\tcurwin->w_cline_height = plines(curwin->w_cursor.lnum);\n#ifdef FEAT_FOLDING\n    curwin->w_cline_folded = hasFolding(curwin->w_cursor.lnum, NULL, NULL);\n#endif\n    curwin->w_valid |= VALID_CHEIGHT;\n}\n\n/*\n * Validate w_wcol and w_virtcol only.\n */\n    void\nvalidate_cursor_col(void)\n{\n    colnr_T off;\n    colnr_T col;\n    int     width;\n\n    validate_virtcol();\n\n    if (curwin->w_valid & VALID_WCOL)\n\treturn;\n\n    col = curwin->w_virtcol;\n    off = curwin_col_off();\n    col += off;\n    width = curwin->w_width - off + curwin_col_off2();\n\n    // long line wrapping, adjust curwin->w_wrow\n    if (curwin->w_p_wrap\n\t    && col >= (colnr_T)curwin->w_width\n\t    && width > 0)\n\t// use same formula as what is used in curs_columns()\n\tcol -= ((col - curwin->w_width) / width + 1) * width;\n    if (col > (int)curwin->w_leftcol)\n\tcol -= curwin->w_leftcol;\n    else\n\tcol = 0;\n    curwin->w_wcol = col;\n\n    curwin->w_valid |= VALID_WCOL;\n#ifdef FEAT_PROP_POPUP\n    curwin->w_flags &= ~WFLAG_WCOL_OFF_ADDED;\n#endif\n}\n\n/*\n * Compute offset of a window, occupied by absolute or relative line number,\n * fold column and sign column (these don't move when scrolling horizontally).\n */\n    int\nwin_col_off(win_T *wp)\n{\n    return (((wp->w_p_nu || wp->w_p_rnu) ? number_width(wp) + 1 : 0)\n\t    + (cmdwin_type == 0 || wp != curwin ? 0 : 1)\n#ifdef FEAT_FOLDING\n\t    + wp->w_p_fdc\n#endif\n#ifdef FEAT_SIGNS\n\t    + (signcolumn_on(wp) ? 2 : 0)\n#endif\n\t   );\n}\n\n    int\ncurwin_col_off(void)\n{\n    return win_col_off(curwin);\n}\n\n/*\n * Return the difference in column offset for the second screen line of a\n * wrapped line.  It's positive if 'number' or 'relativenumber' is on and 'n'\n * is in 'cpoptions'.\n */\n    int\nwin_col_off2(win_T *wp)\n{\n    if ((wp->w_p_nu || wp->w_p_rnu) && vim_strchr(p_cpo, CPO_NUMCOL) != NULL)\n\treturn number_width(wp) + 1;\n    return 0;\n}\n\n    int\ncurwin_col_off2(void)\n{\n    return win_col_off2(curwin);\n}\n\n/*\n * Compute curwin->w_wcol and curwin->w_virtcol.\n * Also updates curwin->w_wrow and curwin->w_cline_row.\n * Also updates curwin->w_leftcol.\n */\n    void\ncurs_columns(\n    int\t\tmay_scroll)\t// when TRUE, may scroll horizontally\n{\n    int\t\tdiff;\n    int\t\textra;\t\t// offset for first screen line\n    int\t\toff_left, off_right;\n    int\t\tn;\n    int\t\tp_lines;\n    int\t\twidth1;\t\t// text width for first screen line\n    int\t\twidth2 = 0;\t// text width for second and later screen line\n    int\t\tnew_leftcol;\n    colnr_T\tstartcol;\n    colnr_T\tendcol;\n    colnr_T\tprev_skipcol;\n    long\tso = get_scrolloff_value();\n    long\tsiso = get_sidescrolloff_value();\n    int\t\tdid_sub_skipcol = FALSE;\n\n    /*\n     * First make sure that w_topline is valid (after moving the cursor).\n     */\n    update_topline();\n\n    /*\n     * Next make sure that w_cline_row is valid.\n     */\n    if (!(curwin->w_valid & VALID_CROW))\n\tcurs_rows(curwin);\n\n#ifdef FEAT_PROP_POPUP\n    // will be set by getvvcol() but not reset\n    curwin->w_virtcol_first_char = 0;\n#endif\n\n    /*\n     * Compute the number of virtual columns.\n     */\n#ifdef FEAT_FOLDING\n    if (curwin->w_cline_folded)\n\t// In a folded line the cursor is always in the first column\n\tstartcol = curwin->w_virtcol = endcol = curwin->w_leftcol;\n    else\n#endif\n\tgetvvcol(curwin, &curwin->w_cursor,\n\t\t\t\t&startcol, &(curwin->w_virtcol), &endcol);\n\n    // remove '$' from change command when cursor moves onto it\n    if (startcol > dollar_vcol)\n\tdollar_vcol = -1;\n\n    extra = curwin_col_off();\n    curwin->w_wcol = curwin->w_virtcol + extra;\n    endcol += extra;\n\n    /*\n     * Now compute w_wrow, counting screen lines from w_cline_row.\n     */\n    curwin->w_wrow = curwin->w_cline_row;\n\n    width1 = curwin->w_width - extra;\n    if (width1 <= 0)\n    {\n\t// No room for text, put cursor in last char of window.\n\t// If not wrapping, the last non-empty line.\n\tcurwin->w_wcol = curwin->w_width - 1;\n\tif (curwin->w_p_wrap)\n\t    curwin->w_wrow = curwin->w_height - 1;\n\telse\n\t    curwin->w_wrow = curwin->w_height - 1 - curwin->w_empty_rows;\n    }\n    else if (curwin->w_p_wrap && curwin->w_width != 0)\n    {\n\twidth2 = width1 + curwin_col_off2();\n\n\t// skip columns that are not visible\n\tif (curwin->w_cursor.lnum == curwin->w_topline\n\t\t&& curwin->w_skipcol > 0\n\t\t&& curwin->w_wcol >= curwin->w_skipcol)\n\t{\n\t    // Deduct by multiples of width2.  This allows the long line\n\t    // wrapping formula below to correctly calculate the w_wcol value\n\t    // when wrapping.\n\t    if (curwin->w_skipcol <= width1)\n\t\tcurwin->w_wcol -= width2;\n\t    else\n\t\tcurwin->w_wcol -= width2\n\t\t\t       * (((curwin->w_skipcol - width1) / width2) + 1);\n\n\t    did_sub_skipcol = TRUE;\n\t}\n\n\t// long line wrapping, adjust curwin->w_wrow\n\tif (curwin->w_wcol >= curwin->w_width)\n\t{\n\t    // this same formula is used in validate_cursor_col()\n\t    n = (curwin->w_wcol - curwin->w_width) / width2 + 1;\n\t    curwin->w_wcol -= n * width2;\n\t    curwin->w_wrow += n;\n\t}\n    }\n\n    // No line wrapping: compute curwin->w_leftcol if scrolling is on and line\n    // is not folded.\n    // If scrolling is off, curwin->w_leftcol is assumed to be 0\n    else if (may_scroll\n#ifdef FEAT_FOLDING\n\t    && !curwin->w_cline_folded\n#endif\n\t    )\n    {\n#ifdef FEAT_PROP_POPUP\n\tif (curwin->w_virtcol_first_char > 0)\n\t{\n\t    int cols = (curwin->w_width - extra);\n\t    int rows = cols > 0 ? curwin->w_virtcol_first_char / cols : 1;\n\n\t    // each \"above\" text prop shifts the text one row down\n\t    curwin->w_wrow += rows;\n\t    curwin->w_wcol -= rows * cols;\n\t    endcol -= rows * cols;\n\t    curwin->w_cline_height = rows + 1;\n\t}\n#endif\n\t/*\n\t * If Cursor is left of the screen, scroll rightwards.\n\t * If Cursor is right of the screen, scroll leftwards\n\t * If we get closer to the edge than 'sidescrolloff', scroll a little\n\t * extra\n\t */\n\toff_left = (int)startcol - (int)curwin->w_leftcol - siso;\n\toff_right = (int)endcol - (int)(curwin->w_leftcol + curwin->w_width\n\t\t\t\t\t\t\t\t- siso) + 1;\n\tif (off_left < 0 || off_right > 0)\n\t{\n\t    if (off_left < 0)\n\t\tdiff = -off_left;\n\t    else\n\t\tdiff = off_right;\n\n\t    // When far off or not enough room on either side, put cursor in\n\t    // middle of window.\n\t    if (p_ss == 0 || diff >= width1 / 2 || off_right >= off_left)\n\t\tnew_leftcol = curwin->w_wcol - extra - width1 / 2;\n\t    else\n\t    {\n\t\tif (diff < p_ss)\n\t\t    diff = p_ss;\n\t\tif (off_left < 0)\n\t\t    new_leftcol = curwin->w_leftcol - diff;\n\t\telse\n\t\t    new_leftcol = curwin->w_leftcol + diff;\n\t    }\n\t    if (new_leftcol < 0)\n\t\tnew_leftcol = 0;\n\t    if (new_leftcol != (int)curwin->w_leftcol)\n\t    {\n\t\tcurwin->w_leftcol = new_leftcol;\n\t\t// screen has to be redrawn with new curwin->w_leftcol\n\t\tredraw_later(UPD_NOT_VALID);\n\t    }\n\t}\n\tcurwin->w_wcol -= curwin->w_leftcol;\n    }\n    else if (curwin->w_wcol > (int)curwin->w_leftcol)\n\tcurwin->w_wcol -= curwin->w_leftcol;\n    else\n\tcurwin->w_wcol = 0;\n\n#ifdef FEAT_DIFF\n    // Skip over filler lines.  At the top use w_topfill, there\n    // may be some filler lines above the window.\n    if (curwin->w_cursor.lnum == curwin->w_topline)\n\tcurwin->w_wrow += curwin->w_topfill;\n    else\n\tcurwin->w_wrow += diff_check_fill(curwin, curwin->w_cursor.lnum);\n#endif\n\n    prev_skipcol = curwin->w_skipcol;\n\n    p_lines = 0;\n\n    if ((curwin->w_wrow >= curwin->w_height\n\t\t|| ((prev_skipcol > 0\n\t\t\t|| curwin->w_wrow + so >= curwin->w_height)\n\t\t    && (p_lines =\n#ifdef FEAT_DIFF\n\t\t\tplines_win_nofill\n#else\n\t\t\tplines_win\n#endif\n\t\t\t(curwin, curwin->w_cursor.lnum, FALSE))\n\t\t\t\t\t\t    - 1 >= curwin->w_height))\n\t    && curwin->w_height != 0\n\t    && curwin->w_cursor.lnum == curwin->w_topline\n\t    && width2 > 0\n\t    && curwin->w_width != 0)\n    {\n\t// Cursor past end of screen.  Happens with a single line that does\n\t// not fit on screen.  Find a skipcol to show the text around the\n\t// cursor.  Avoid scrolling all the time. compute value of \"extra\":\n\t// 1: Less than 'scrolloff' lines above\n\t// 2: Less than 'scrolloff' lines below\n\t// 3: both of them\n\textra = 0;\n\tif (curwin->w_skipcol + so * width2 > curwin->w_virtcol)\n\t    extra = 1;\n\t// Compute last display line of the buffer line that we want at the\n\t// bottom of the window.\n\tif (p_lines == 0)\n\t    p_lines = plines_win(curwin, curwin->w_cursor.lnum, FALSE);\n\t--p_lines;\n\tif (p_lines > curwin->w_wrow + so)\n\t    n = curwin->w_wrow + so;\n\telse\n\t    n = p_lines;\n\tif ((colnr_T)n >= curwin->w_height + curwin->w_skipcol / width2 - so)\n\t    extra += 2;\n\n\tif (extra == 3 || curwin->w_height <= so * 2)\n\t{\n\t    // not enough room for 'scrolloff', put cursor in the middle\n\t    n = curwin->w_virtcol / width2;\n\t    if (n > curwin->w_height / 2)\n\t\tn -= curwin->w_height / 2;\n\t    else\n\t\tn = 0;\n\t    // don't skip more than necessary\n\t    if (n > p_lines - curwin->w_height + 1)\n\t\tn = p_lines - curwin->w_height + 1;\n\t    if (n > 0)\n\t\tcurwin->w_skipcol = width1 + (n - 1) * width2;\n\t    else\n\t\tcurwin->w_skipcol = 0;\n\t}\n\telse if (extra == 1)\n\t{\n\t    // less than 'scrolloff' lines above, decrease skipcol\n\t    extra = (curwin->w_skipcol + so * width2 - curwin->w_virtcol\n\t\t\t\t     + width2 - 1) / width2;\n\t    if (extra > 0)\n\t    {\n\t\tif ((colnr_T)(extra * width2) > curwin->w_skipcol)\n\t\t    extra = curwin->w_skipcol / width2;\n\t\tcurwin->w_skipcol -= extra * width2;\n\t    }\n\t}\n\telse if (extra == 2)\n\t{\n\t    // less than 'scrolloff' lines below, increase skipcol\n\t    endcol = (n - curwin->w_height + 1) * width2;\n\t    while (endcol > curwin->w_virtcol)\n\t\tendcol -= width2;\n\t    if (endcol > curwin->w_skipcol)\n\t\tcurwin->w_skipcol = endcol;\n\t}\n\n\t// adjust w_wrow for the changed w_skipcol\n\tif (did_sub_skipcol)\n\t    curwin->w_wrow -= (curwin->w_skipcol - prev_skipcol) / width2;\n\telse\n\t    curwin->w_wrow -= curwin->w_skipcol / width2;\n\n\tif (curwin->w_wrow >= curwin->w_height)\n\t{\n\t    // small window, make sure cursor is in it\n\t    extra = curwin->w_wrow - curwin->w_height + 1;\n\t    curwin->w_skipcol += extra * width2;\n\t    curwin->w_wrow -= extra;\n\t}\n\n\textra = ((int)prev_skipcol - (int)curwin->w_skipcol) / width2;\n\tif (extra > 0)\n\t    win_ins_lines(curwin, 0, extra, FALSE, FALSE);\n\telse if (extra < 0)\n\t    win_del_lines(curwin, 0, -extra, FALSE, FALSE, 0);\n    }\n    else if (!curwin->w_p_sms)\n\tcurwin->w_skipcol = 0;\n    if (prev_skipcol != curwin->w_skipcol)\n\tredraw_later(UPD_SOME_VALID);\n\n#ifdef FEAT_SYN_HL\n    redraw_for_cursorcolumn(curwin);\n#endif\n#if defined(FEAT_PROP_POPUP) && defined(FEAT_TERMINAL)\n    if (popup_is_popup(curwin) && curbuf->b_term != NULL)\n    {\n\tcurwin->w_wrow += popup_top_extra(curwin);\n\tcurwin->w_wcol += popup_left_extra(curwin);\n\tcurwin->w_flags |= WFLAG_WCOL_OFF_ADDED + WFLAG_WROW_OFF_ADDED;\n    }\n    else\n\tcurwin->w_flags &= ~(WFLAG_WCOL_OFF_ADDED + WFLAG_WROW_OFF_ADDED);\n#endif\n\n    // now w_leftcol and w_skipcol are valid, avoid check_cursor_moved()\n    // thinking otherwise\n    curwin->w_valid_leftcol = curwin->w_leftcol;\n    curwin->w_valid_skipcol = curwin->w_skipcol;\n\n    curwin->w_valid |= VALID_WCOL|VALID_WROW|VALID_VIRTCOL;\n}\n\n#if (defined(FEAT_EVAL) || defined(FEAT_PROP_POPUP)) || defined(PROTO)\n/*\n * Compute the screen position of text character at \"pos\" in window \"wp\"\n * The resulting values are one-based, zero when character is not visible.\n */\n    void\ntextpos2screenpos(\n\twin_T\t*wp,\n\tpos_T\t*pos,\n\tint\t*rowp,\t// screen row\n\tint\t*scolp,\t// start screen column\n\tint\t*ccolp,\t// cursor screen column\n\tint\t*ecolp)\t// end screen column\n{\n    colnr_T\tscol = 0, ccol = 0, ecol = 0;\n    int\t\trow = 0;\n    colnr_T\tcoloff = 0;\n\n    if (pos->lnum >= wp->w_topline && pos->lnum <= wp->w_botline)\n    {\n\tcolnr_T\t    col;\n\tint\t    width;\n\tlinenr_T    lnum = pos->lnum;\n#ifdef FEAT_FOLDING\n\tint\t    is_folded;\n\n\tis_folded = hasFoldingWin(wp, lnum, &lnum, NULL, TRUE, NULL);\n#endif\n\trow = plines_m_win(wp, wp->w_topline, lnum - 1, FALSE);\n\t// \"row\" should be the screen line where line \"lnum\" begins, which can\n\t// be negative if \"lnum\" is \"w_topline\" and \"w_skipcol\" is non-zero.\n\trow -= adjust_plines_for_skipcol(wp);\n\n#ifdef FEAT_DIFF\n\t// Add filler lines above this buffer line.\n\trow += lnum == wp->w_topline ? wp->w_topfill\n\t\t\t\t     : diff_check_fill(wp, lnum);\n#endif\n\n\tcolnr_T\toff = win_col_off(wp);\n#ifdef FEAT_FOLDING\n\tif (is_folded)\n\t{\n\t    row += W_WINROW(wp) + 1;\n\t    coloff = wp->w_wincol + 1 + off;\n\t}\n\telse\n#endif\n\t{\n\t    getvcol(wp, pos, &scol, &ccol, &ecol);\n\n\t    // similar to what is done in validate_cursor_col()\n\t    col = scol;\n\t    col += off;\n\t    width = wp->w_width - off + win_col_off2(wp);\n\n\t    // long line wrapping, adjust row\n\t    if (wp->w_p_wrap\n\t\t    && col >= (colnr_T)wp->w_width\n\t\t    && width > 0)\n\t    {\n\t\t// use same formula as what is used in curs_columns()\n\t\tint rowoff = ((col - wp->w_width) / width + 1);\n\t\tcol -= rowoff * width;\n\t\trow += rowoff;\n\t    }\n\t    col -= wp->w_leftcol;\n\t    if (col >= wp->w_width)\n\t\tcol = -1;\n\t    if (col >= 0 && row >= 0 && row < wp->w_height)\n\t    {\n\t\tcoloff = col - scol + wp->w_wincol + 1;\n\t\trow += W_WINROW(wp) + 1;\n\t    }\n\t    else\n\t\t// character is out of the window\n\t\trow = scol = ccol = ecol = 0;\n\t}\n    }\n    *rowp = row;\n    *scolp = scol + coloff;\n    *ccolp = ccol + coloff;\n    *ecolp = ecol + coloff;\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * \"screenpos({winid}, {lnum}, {col})\" function\n */\n    void\nf_screenpos(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    dict_T\t*dict;\n    win_T\t*wp;\n    pos_T\tpos;\n    int\t\trow = 0;\n    int\t\tscol = 0, ccol = 0, ecol = 0;\n\n    if (rettv_dict_alloc(rettv) == FAIL)\n\treturn;\n    dict = rettv->vval.v_dict;\n\n    if (in_vim9script()\n\t    && (check_for_number_arg(argvars, 0) == FAIL\n\t\t|| check_for_number_arg(argvars, 1) == FAIL\n\t\t|| check_for_number_arg(argvars, 2) == FAIL))\n\treturn;\n\n    wp = find_win_by_nr_or_id(&argvars[0]);\n    if (wp == NULL)\n\treturn;\n\n    pos.lnum = tv_get_number(&argvars[1]);\n    if (pos.lnum > wp->w_buffer->b_ml.ml_line_count)\n    {\n\tsemsg(_(e_invalid_line_number_nr), pos.lnum);\n\treturn;\n    }\n    pos.col = tv_get_number(&argvars[2]) - 1;\n    pos.coladd = 0;\n    textpos2screenpos(wp, &pos, &row, &scol, &ccol, &ecol);\n\n    dict_add_number(dict, \"row\", row);\n    dict_add_number(dict, \"col\", scol);\n    dict_add_number(dict, \"curscol\", ccol);\n    dict_add_number(dict, \"endcol\", ecol);\n}\n\n/*\n * Convert a virtual (screen) column to a character column.  The first column\n * is one.  For a multibyte character, the column number of the first byte is\n * returned.\n */\n    static int\nvirtcol2col(win_T *wp, linenr_T lnum, int vcol)\n{\n    int\t\toffset = vcol2col(wp, lnum, vcol - 1, NULL);\n    char_u\t*line = ml_get_buf(wp->w_buffer, lnum, FALSE);\n    char_u\t*p = line + offset;\n\n    if (*p == NUL)\n    {\n\tif (p == line)  // empty line\n\t    return 0;\n\t// Move to the first byte of the last char.\n\tMB_PTR_BACK(line, p);\n    }\n    return (int)(p - line + 1);\n}\n\n/*\n * \"virtcol2col({winid}, {lnum}, {col})\" function\n */\n    void\nf_virtcol2col(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    win_T\t*wp;\n    linenr_T\tlnum;\n    int\t\tscreencol;\n    int\t\terror = FALSE;\n\n    rettv->vval.v_number = -1;\n\n    if (check_for_number_arg(argvars, 0) == FAIL\n\t    || check_for_number_arg(argvars, 1) == FAIL\n\t    || check_for_number_arg(argvars, 2) == FAIL)\n\treturn;\n\n    wp = find_win_by_nr_or_id(&argvars[0]);\n    if (wp == NULL)\n\treturn;\n\n    lnum = tv_get_number_chk(&argvars[1], &error);\n    if (error || lnum < 0 || lnum > wp->w_buffer->b_ml.ml_line_count)\n\treturn;\n\n    screencol = tv_get_number_chk(&argvars[2], &error);\n    if (error || screencol < 0)\n\treturn;\n\n    rettv->vval.v_number = virtcol2col(wp, lnum, screencol);\n}\n#endif\n\n/*\n * Scroll the current window down by \"line_count\" logical lines.  \"CTRL-Y\"\n */\n    void\nscrolldown(\n    long\tline_count,\n    int\t\tbyfold UNUSED)\t// TRUE: count a closed fold as one line\n{\n    long\tdone = 0;\t// total # of physical lines done\n    int\t\twrow;\n    int\t\tmoved = FALSE;\n    int\t\tdo_sms = curwin->w_p_wrap && curwin->w_p_sms;\n    int\t\twidth1 = 0;\n    int\t\twidth2 = 0;\n\n    if (do_sms)\n    {\n\twidth1 = curwin->w_width - curwin_col_off();\n\twidth2 = width1 + curwin_col_off2();\n    }\n\n#ifdef FEAT_FOLDING\n    linenr_T\tfirst;\n\n    // Make sure w_topline is at the first of a sequence of folded lines.\n    (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n    validate_cursor();\t\t// w_wrow needs to be valid\n    for (int todo = line_count; todo > 0; --todo)\n    {\n#ifdef FEAT_DIFF\n\tif (curwin->w_topfill < diff_check(curwin, curwin->w_topline)\n\t\t&& curwin->w_topfill < curwin->w_height - 1)\n\t{\n\t    ++curwin->w_topfill;\n\t    ++done;\n\t}\n\telse\n#endif\n\t{\n\t    // break when at the very top\n\t    if (curwin->w_topline == 1\n\t\t\t\t   && (!do_sms || curwin->w_skipcol < width1))\n\t\tbreak;\n\t    if (do_sms && curwin->w_skipcol >= width1)\n\t    {\n\t\t// scroll a screen line down\n\t\tif (curwin->w_skipcol >= width1 + width2)\n\t\t    curwin->w_skipcol -= width2;\n\t\telse\n\t\t    curwin->w_skipcol -= width1;\n\t\tredraw_later(UPD_NOT_VALID);\n\t\t++done;\n\t    }\n\t    else\n\t    {\n\t\t// scroll a text line down\n\t\t--curwin->w_topline;\n\t\tcurwin->w_skipcol = 0;\n#ifdef FEAT_DIFF\n\t\tcurwin->w_topfill = 0;\n#endif\n#ifdef FEAT_FOLDING\n\t\t// A sequence of folded lines only counts for one logical line\n\t\tif (hasFolding(curwin->w_topline, &first, NULL))\n\t\t{\n\t\t    ++done;\n\t\t    if (!byfold)\n\t\t\ttodo -= curwin->w_topline - first - 1;\n\t\t    curwin->w_botline -= curwin->w_topline - first;\n\t\t    curwin->w_topline = first;\n\t\t}\n\t\telse\n#endif\n\t\tif (do_sms)\n\t\t{\n\t\t    int size = win_linetabsize(curwin, curwin->w_topline,\n\t\t\t\t   ml_get(curwin->w_topline), (colnr_T)MAXCOL);\n\t\t    if (size > width1)\n\t\t    {\n\t\t\tcurwin->w_skipcol = width1;\n\t\t\tsize -= width1;\n\t\t\tredraw_later(UPD_NOT_VALID);\n\t\t    }\n\t\t    while (size > width2)\n\t\t    {\n\t\t\tcurwin->w_skipcol += width2;\n\t\t\tsize -= width2;\n\t\t    }\n\t\t    ++done;\n\t\t}\n\t\telse\n\t\t    done += PLINES_NOFILL(curwin->w_topline);\n\t    }\n\t}\n\t--curwin->w_botline;\t\t// approximate w_botline\n\tinvalidate_botline();\n    }\n    curwin->w_wrow += done;\t\t// keep w_wrow updated\n    curwin->w_cline_row += done;\t// keep w_cline_row updated\n\n#ifdef FEAT_DIFF\n    if (curwin->w_cursor.lnum == curwin->w_topline)\n\tcurwin->w_cline_row = 0;\n    check_topfill(curwin, TRUE);\n#endif\n\n    /*\n     * Compute the row number of the last row of the cursor line\n     * and move the cursor onto the displayed part of the window.\n     */\n    wrow = curwin->w_wrow;\n    if (curwin->w_p_wrap && curwin->w_width != 0)\n    {\n\tvalidate_virtcol();\n\tvalidate_cheight();\n\twrow += curwin->w_cline_height - 1 -\n\t    curwin->w_virtcol / curwin->w_width;\n    }\n    while (wrow >= curwin->w_height && curwin->w_cursor.lnum > 1)\n    {\n#ifdef FEAT_FOLDING\n\tif (hasFolding(curwin->w_cursor.lnum, &first, NULL))\n\t{\n\t    --wrow;\n\t    if (first == 1)\n\t\tcurwin->w_cursor.lnum = 1;\n\t    else\n\t\tcurwin->w_cursor.lnum = first - 1;\n\t}\n\telse\n#endif\n\t    wrow -= plines(curwin->w_cursor.lnum--);\n\tcurwin->w_valid &=\n\t      ~(VALID_WROW|VALID_WCOL|VALID_CHEIGHT|VALID_CROW|VALID_VIRTCOL);\n\tmoved = TRUE;\n    }\n    if (moved)\n    {\n#ifdef FEAT_FOLDING\n\t// Move cursor to first line of closed fold.\n\tfoldAdjustCursor();\n#endif\n\tcoladvance(curwin->w_curswant);\n    }\n\n    if (curwin->w_cursor.lnum == curwin->w_topline && do_sms)\n    {\n\tlong\tso = get_scrolloff_value();\n\tint\tscrolloff_cols = so == 0 ? 0 : width1 + (so - 1) * width2;\n\n\t// make sure the cursor is in the visible text\n\tvalidate_virtcol();\n\tint col = curwin->w_virtcol - curwin->w_skipcol + scrolloff_cols;\n\tint row = 0;\n\tif (col >= width1)\n\t{\n\t    col -= width1;\n\t    ++row;\n\t}\n\tif (col > width2 && width2 > 0)\n\t{\n\t    row += col / width2;\n\t    // even so col is not used anymore,\n\t    // make sure it is correct, just in case\n\t    col = col % width2;\n\t}\n\tif (row >= curwin->w_height)\n\t{\n\t    curwin->w_curswant = curwin->w_virtcol\n\t\t\t\t       - (row - curwin->w_height + 1) * width2;\n\t    coladvance(curwin->w_curswant);\n\t}\n    }\n}\n\n/*\n * Scroll the current window up by \"line_count\" logical lines.  \"CTRL-E\"\n */\n    void\nscrollup(\n    long\tline_count,\n    int\t\tbyfold UNUSED)\t// TRUE: count a closed fold as one line\n{\n    int\t\tdo_sms = curwin->w_p_wrap && curwin->w_p_sms;\n\n    if (do_sms\n# ifdef FEAT_FOLDING\n\t    || (byfold && hasAnyFolding(curwin))\n# endif\n# ifdef FEAT_DIFF\n\t    || (curwin->w_p_diff && !curwin->w_p_wrap)\n# endif\n       )\n    {\n\tint\t    width1 = curwin->w_width - curwin_col_off();\n\tint\t    width2 = width1 + curwin_col_off2();\n\tint\t    size = 0;\n\tcolnr_T\t    prev_skipcol = curwin->w_skipcol;\n\n\tif (do_sms)\n\t    size = linetabsize(curwin, curwin->w_topline);\n\n\t// diff mode: first consume \"topfill\"\n\t// 'smoothscroll': increase \"w_skipcol\" until it goes over the end of\n\t// the line, then advance to the next line.\n\t// folding: count each sequence of folded lines as one logical line.\n\tfor (int todo = line_count; todo > 0; --todo)\n\t{\n# ifdef FEAT_DIFF\n\t    if (curwin->w_topfill > 0)\n\t\t--curwin->w_topfill;\n\t    else\n# endif\n\t    {\n\t\tlinenr_T lnum = curwin->w_topline;\n\n# ifdef FEAT_FOLDING\n\t\tif (byfold)\n\t\t    // for a closed fold: go to the last line in the fold\n\t\t    (void)hasFolding(lnum, NULL, &lnum);\n# endif\n\t\tif (lnum == curwin->w_topline && do_sms)\n\t\t{\n\t\t    // 'smoothscroll': increase \"w_skipcol\" until it goes over\n\t\t    // the end of the line, then advance to the next line.\n\t\t    int add = curwin->w_skipcol > 0 ? width2 : width1;\n\t\t    curwin->w_skipcol += add;\n\t\t    if (curwin->w_skipcol >= size)\n\t\t    {\n\t\t\tif (lnum == curbuf->b_ml.ml_line_count)\n\t\t\t{\n\t\t\t    // at the last screen line, can't scroll further\n\t\t\t    curwin->w_skipcol -= add;\n\t\t\t    break;\n\t\t\t}\n\t\t\t++lnum;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (lnum >= curbuf->b_ml.ml_line_count)\n\t\t\tbreak;\n\t\t    ++lnum;\n\t\t}\n\n\t\tif (lnum > curwin->w_topline)\n\t\t{\n\t\t    // approximate w_botline\n\t\t    curwin->w_botline += lnum - curwin->w_topline;\n\t\t    curwin->w_topline = lnum;\n# ifdef FEAT_DIFF\n\t\t    curwin->w_topfill = diff_check_fill(curwin, lnum);\n# endif\n\t\t    curwin->w_skipcol = 0;\n\t\t    if (todo > 1 && do_sms)\n\t\t\tsize = linetabsize(curwin, curwin->w_topline);\n\t\t}\n\t    }\n\t}\n\n\tif (prev_skipcol > 0 || curwin->w_skipcol > 0)\n\t    // need to redraw more, because wl_size of the (new) topline may\n\t    // now be invalid\n\t    redraw_later(UPD_NOT_VALID);\n    }\n    else\n    {\n\tcurwin->w_topline += line_count;\n\tcurwin->w_botline += line_count;\t// approximate w_botline\n    }\n\n    if (curwin->w_topline > curbuf->b_ml.ml_line_count)\n\tcurwin->w_topline = curbuf->b_ml.ml_line_count;\n    if (curwin->w_botline > curbuf->b_ml.ml_line_count + 1)\n\tcurwin->w_botline = curbuf->b_ml.ml_line_count + 1;\n\n#ifdef FEAT_DIFF\n    check_topfill(curwin, FALSE);\n#endif\n\n#ifdef FEAT_FOLDING\n    if (hasAnyFolding(curwin))\n\t// Make sure w_topline is at the first of a sequence of folded lines.\n\t(void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n\n    curwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);\n    if (curwin->w_cursor.lnum < curwin->w_topline)\n    {\n\tcurwin->w_cursor.lnum = curwin->w_topline;\n\tcurwin->w_valid &=\n\t      ~(VALID_WROW|VALID_WCOL|VALID_CHEIGHT|VALID_CROW|VALID_VIRTCOL);\n\tcoladvance(curwin->w_curswant);\n    }\n    if (curwin->w_cursor.lnum == curwin->w_topline\n\t\t\t\t\t    && do_sms && curwin->w_skipcol > 0)\n    {\n\tint\tcol_off = curwin_col_off();\n\tint\tcol_off2 = curwin_col_off2();\n\n\tint\twidth1 = curwin->w_width - col_off;\n\tint\twidth2 = width1 + col_off2;\n\tint\textra2 = col_off - col_off2;\n\tlong\tso = get_scrolloff_value();\n\tint\tscrolloff_cols = so == 0 ? 0 : width1 + (so - 1) * width2;\n\tint\tspace_cols = (curwin->w_height - 1) * width2;\n\n\t// If we have non-zero scrolloff, just ignore the marker as we are\n\t// going past it anyway.\n\tint overlap = scrolloff_cols != 0 ? 0\n\t\t\t\t\t  : sms_marker_overlap(curwin, extra2);\n\n\t// Make sure the cursor is in a visible part of the line, taking\n\t// 'scrolloff' into account, but using screen lines.\n\t// If there are not enough screen lines put the cursor in the middle.\n\tif (scrolloff_cols > space_cols / 2)\n\t    scrolloff_cols = space_cols / 2;\n\tvalidate_virtcol();\n\tif (curwin->w_virtcol < curwin->w_skipcol + overlap + scrolloff_cols)\n\t{\n\t    colnr_T col = curwin->w_virtcol;\n\n\t    if (col < width1)\n\t\tcol += width1;\n\t    while (col < curwin->w_skipcol + overlap + scrolloff_cols)\n\t\tcol += width2;\n\t    curwin->w_curswant = col;\n\t    coladvance(curwin->w_curswant);\n\n\t    // validate_virtcol() marked various things as valid, but after\n\t    // moving the cursor they need to be recomputed\n\t    curwin->w_valid &=\n\t       ~(VALID_WROW|VALID_WCOL|VALID_CHEIGHT|VALID_CROW|VALID_VIRTCOL);\n\t}\n    }\n}\n\n/*\n * Called after changing the cursor column: make sure that curwin->w_skipcol is\n * valid for 'smoothscroll'.\n */\n    void\nadjust_skipcol(void)\n{\n    if (!curwin->w_p_wrap\n\t    || !curwin->w_p_sms\n\t    || curwin->w_cursor.lnum != curwin->w_topline)\n\treturn;\n\n    int\t    width1 = curwin->w_width - curwin_col_off();\n    if (width1 <= 0)\n\treturn;  // no text will be displayed\n\n    int\t    width2 = width1 + curwin_col_off2();\n    long    so = get_scrolloff_value();\n    int\t    scrolloff_cols = so == 0 ? 0 : width1 + (so - 1) * width2;\n    int\t    scrolled = FALSE;\n\n    validate_cheight();\n    if (curwin->w_cline_height == curwin->w_height\n\t    // w_cline_height may be capped at w_height, check there aren't\n\t    // actually more lines.\n\t    && plines_win(curwin, curwin->w_cursor.lnum, FALSE)\n\t\t\t\t\t\t\t   <= curwin->w_height)\n    {\n\t// the line just fits in the window, don't scroll\n\treset_skipcol();\n\treturn;\n    }\n\n    validate_virtcol();\n    int overlap = sms_marker_overlap(curwin,\n\t\t\t\t\t curwin_col_off() - curwin_col_off2());\n    while (curwin->w_skipcol > 0\n\t    && curwin->w_virtcol < curwin->w_skipcol + overlap + scrolloff_cols)\n    {\n\t// scroll a screen line down\n\tif (curwin->w_skipcol >= width1 + width2)\n\t    curwin->w_skipcol -= width2;\n\telse\n\t    curwin->w_skipcol -= width1;\n\tscrolled = TRUE;\n    }\n    if (scrolled)\n    {\n\tvalidate_virtcol();\n\tredraw_later(UPD_NOT_VALID);\n\treturn;  // don't scroll in the other direction now\n    }\n\n    int col = curwin->w_virtcol - curwin->w_skipcol + scrolloff_cols;\n    int row = 0;\n    if (col >= width1)\n    {\n\tcol -= width1;\n\t++row;\n    }\n    if (col > width2)\n    {\n\trow += col / width2;\n\t// col may no longer be used, but make\n\t// sure it is correct anyhow, just in case\n\tcol = col % width2;\n    }\n    if (row >= curwin->w_height)\n    {\n\tif (curwin->w_skipcol == 0)\n\t{\n\t    curwin->w_skipcol += width1;\n\t    --row;\n\t}\n\tif (row >= curwin->w_height)\n\t    curwin->w_skipcol += (row - curwin->w_height) * width2;\n\tredraw_later(UPD_NOT_VALID);\n    }\n}\n\n#ifdef FEAT_DIFF\n/*\n * Don't end up with too many filler lines in the window.\n */\n    void\ncheck_topfill(\n    win_T\t*wp,\n    int\t\tdown)\t// when TRUE scroll down when not enough space\n{\n    int\t\tn;\n\n    if (wp->w_topfill <= 0)\n\treturn;\n\n    n = plines_win_nofill(wp, wp->w_topline, TRUE);\n    if (wp->w_topfill + n > wp->w_height)\n    {\n\tif (down && wp->w_topline > 1)\n\t{\n\t    --wp->w_topline;\n\t    wp->w_topfill = 0;\n\t}\n\telse\n\t{\n\t    wp->w_topfill = wp->w_height - n;\n\t    if (wp->w_topfill < 0)\n\t\twp->w_topfill = 0;\n\t}\n    }\n}\n\n/*\n * Use as many filler lines as possible for w_topline.  Make sure w_topline\n * is still visible.\n */\n    static void\nmax_topfill(void)\n{\n    int\t\tn;\n\n    n = plines_nofill(curwin->w_topline);\n    if (n >= curwin->w_height)\n\tcurwin->w_topfill = 0;\n    else\n    {\n\tcurwin->w_topfill = diff_check_fill(curwin, curwin->w_topline);\n\tif (curwin->w_topfill + n > curwin->w_height)\n\t    curwin->w_topfill = curwin->w_height - n;\n    }\n}\n#endif\n\n/*\n * Scroll the screen one line down, but don't do it if it would move the\n * cursor off the screen.\n */\n    void\nscrolldown_clamp(void)\n{\n    int\t\tend_row;\n#ifdef FEAT_DIFF\n    int\t\tcan_fill = (curwin->w_topfill\n\t\t\t\t< diff_check_fill(curwin, curwin->w_topline));\n#endif\n\n    if (curwin->w_topline <= 1\n#ifdef FEAT_DIFF\n\t    && !can_fill\n#endif\n\t    )\n\treturn;\n\n    validate_cursor();\t    // w_wrow needs to be valid\n\n    /*\n     * Compute the row number of the last row of the cursor line\n     * and make sure it doesn't go off the screen. Make sure the cursor\n     * doesn't go past 'scrolloff' lines from the screen end.\n     */\n    end_row = curwin->w_wrow;\n#ifdef FEAT_DIFF\n    if (can_fill)\n\t++end_row;\n    else\n\tend_row += plines_nofill(curwin->w_topline - 1);\n#else\n    end_row += plines(curwin->w_topline - 1);\n#endif\n    if (curwin->w_p_wrap && curwin->w_width != 0)\n    {\n\tvalidate_cheight();\n\tvalidate_virtcol();\n\tend_row += curwin->w_cline_height - 1 -\n\t    curwin->w_virtcol / curwin->w_width;\n    }\n    if (end_row < curwin->w_height - get_scrolloff_value())\n    {\n#ifdef FEAT_DIFF\n\tif (can_fill)\n\t{\n\t    ++curwin->w_topfill;\n\t    check_topfill(curwin, TRUE);\n\t}\n\telse\n\t{\n\t    --curwin->w_topline;\n\t    curwin->w_topfill = 0;\n\t}\n#else\n\t--curwin->w_topline;\n#endif\n#ifdef FEAT_FOLDING\n\t(void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n\t--curwin->w_botline;\t    // approximate w_botline\n\tcurwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);\n    }\n}\n\n/*\n * Scroll the screen one line up, but don't do it if it would move the cursor\n * off the screen.\n */\n    void\nscrollup_clamp(void)\n{\n    int\t    start_row;\n\n    if (curwin->w_topline == curbuf->b_ml.ml_line_count\n#ifdef FEAT_DIFF\n\t    && curwin->w_topfill == 0\n#endif\n\t    )\n\treturn;\n\n    validate_cursor();\t    // w_wrow needs to be valid\n\n    /*\n     * Compute the row number of the first row of the cursor line\n     * and make sure it doesn't go off the screen. Make sure the cursor\n     * doesn't go before 'scrolloff' lines from the screen start.\n     */\n#ifdef FEAT_DIFF\n    start_row = curwin->w_wrow - plines_nofill(curwin->w_topline)\n\t\t\t\t\t\t\t  - curwin->w_topfill;\n#else\n    start_row = curwin->w_wrow - plines(curwin->w_topline);\n#endif\n    if (curwin->w_p_wrap && curwin->w_width != 0)\n    {\n\tvalidate_virtcol();\n\tstart_row -= curwin->w_virtcol / curwin->w_width;\n    }\n    if (start_row >= get_scrolloff_value())\n    {\n#ifdef FEAT_DIFF\n\tif (curwin->w_topfill > 0)\n\t    --curwin->w_topfill;\n\telse\n#endif\n\t{\n#ifdef FEAT_FOLDING\n\t    (void)hasFolding(curwin->w_topline, NULL, &curwin->w_topline);\n#endif\n\t    ++curwin->w_topline;\n\t}\n\t++curwin->w_botline;\t\t// approximate w_botline\n\tcurwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);\n    }\n}\n\n/*\n * Add one line above \"lp->lnum\".  This can be a filler line, a closed fold or\n * a (wrapped) text line.  Uses and sets \"lp->fill\".\n * Returns the height of the added line in \"lp->height\".\n * Lines above the first one are incredibly high: MAXCOL.\n */\n    static void\ntopline_back_winheight(\n    lineoff_T\t*lp,\n    int\t\twinheight)\t// when TRUE limit to window height\n{\n#ifdef FEAT_DIFF\n    if (lp->fill < diff_check_fill(curwin, lp->lnum))\n    {\n\t// Add a filler line.\n\t++lp->fill;\n\tlp->height = 1;\n    }\n    else\n#endif\n    {\n\t--lp->lnum;\n#ifdef FEAT_DIFF\n\tlp->fill = 0;\n#endif\n\tif (lp->lnum < 1)\n\t    lp->height = MAXCOL;\n\telse\n#ifdef FEAT_FOLDING\n\t    if (hasFolding(lp->lnum, &lp->lnum, NULL))\n\t    // Add a closed fold\n\t    lp->height = 1;\n\telse\n#endif\n\t    lp->height = PLINES_WIN_NOFILL(curwin, lp->lnum, winheight);\n    }\n}\n\n    static void\ntopline_back(lineoff_T *lp)\n{\n    topline_back_winheight(lp, TRUE);\n}\n\n\n/*\n * Add one line below \"lp->lnum\".  This can be a filler line, a closed fold or\n * a (wrapped) text line.  Uses and sets \"lp->fill\".\n * Returns the height of the added line in \"lp->height\".\n * Lines below the last one are incredibly high.\n */\n    static void\nbotline_forw(lineoff_T *lp)\n{\n#ifdef FEAT_DIFF\n    if (lp->fill < diff_check_fill(curwin, lp->lnum + 1))\n    {\n\t// Add a filler line.\n\t++lp->fill;\n\tlp->height = 1;\n    }\n    else\n#endif\n    {\n\t++lp->lnum;\n#ifdef FEAT_DIFF\n\tlp->fill = 0;\n#endif\n\tif (lp->lnum > curbuf->b_ml.ml_line_count)\n\t    lp->height = MAXCOL;\n\telse\n#ifdef FEAT_FOLDING\n\t    if (hasFolding(lp->lnum, NULL, &lp->lnum))\n\t    // Add a closed fold\n\t    lp->height = 1;\n\telse\n#endif\n\t    lp->height = PLINES_NOFILL(lp->lnum);\n    }\n}\n\n#ifdef FEAT_DIFF\n/*\n * Switch from including filler lines below lp->lnum to including filler\n * lines above loff.lnum + 1.  This keeps pointing to the same line.\n * When there are no filler lines nothing changes.\n */\n    static void\nbotline_topline(lineoff_T *lp)\n{\n    if (lp->fill > 0)\n    {\n\t++lp->lnum;\n\tlp->fill = diff_check_fill(curwin, lp->lnum) - lp->fill + 1;\n    }\n}\n\n/*\n * Switch from including filler lines above lp->lnum to including filler\n * lines below loff.lnum - 1.  This keeps pointing to the same line.\n * When there are no filler lines nothing changes.\n */\n    static void\ntopline_botline(lineoff_T *lp)\n{\n    if (lp->fill > 0)\n    {\n\tlp->fill = diff_check_fill(curwin, lp->lnum) - lp->fill + 1;\n\t--lp->lnum;\n    }\n}\n#endif\n\n/*\n * Recompute topline to put the cursor at the top of the window.\n * Scroll at least \"min_scroll\" lines.\n * If \"always\" is TRUE, always set topline (for \"zt\").\n */\n    void\nscroll_cursor_top(int min_scroll, int always)\n{\n    int\t\tscrolled = 0;\n    int\t\textra = 0;\n    int\t\tused;\n    int\t\ti;\n    linenr_T\ttop;\t\t// just above displayed lines\n    linenr_T\tbot;\t\t// just below displayed lines\n    linenr_T\told_topline = curwin->w_topline;\n    int\t\told_skipcol = curwin->w_skipcol;\n#ifdef FEAT_DIFF\n    linenr_T\told_topfill = curwin->w_topfill;\n#endif\n    linenr_T\tnew_topline;\n    int\t\toff = get_scrolloff_value();\n\n    if (mouse_dragging > 0)\n\toff = mouse_dragging - 1;\n\n    /*\n     * Decrease topline until:\n     * - it has become 1\n     * - (part of) the cursor line is moved off the screen or\n     * - moved at least 'scrolljump' lines and\n     * - at least 'scrolloff' lines above and below the cursor\n     */\n    validate_cheight();\n    used = curwin->w_cline_height; // includes filler lines above\n    if (curwin->w_cursor.lnum < curwin->w_topline)\n\tscrolled = used;\n\n#ifdef FEAT_FOLDING\n    if (hasFolding(curwin->w_cursor.lnum, &top, &bot))\n    {\n\t--top;\n\t++bot;\n    }\n    else\n#endif\n    {\n\ttop = curwin->w_cursor.lnum - 1;\n\tbot = curwin->w_cursor.lnum + 1;\n    }\n    new_topline = top + 1;\n\n#ifdef FEAT_DIFF\n    // \"used\" already contains the number of filler lines above, don't add it\n    // again.\n    // Hide filler lines above cursor line by adding them to \"extra\".\n    extra += diff_check_fill(curwin, curwin->w_cursor.lnum);\n#endif\n\n    /*\n     * Check if the lines from \"top\" to \"bot\" fit in the window.  If they do,\n     * set new_topline and advance \"top\" and \"bot\" to include more lines.\n     */\n    while (top > 0)\n    {\n#ifdef FEAT_FOLDING\n\tif (hasFolding(top, &top, NULL))\n\t    // count one logical line for a sequence of folded lines\n\t    i = 1;\n\telse\n#endif\n\t    i = PLINES_NOFILL(top);\n\tif (top < curwin->w_topline)\n\t    scrolled += i;\n\n\t// If scrolling is needed, scroll at least 'sj' lines.\n\tif ((new_topline >= curwin->w_topline || scrolled > min_scroll)\n\t\t&& extra >= off)\n\t    break;\n\n\tused += i;\n\tif (extra + i <= off && bot < curbuf->b_ml.ml_line_count)\n\t{\n#ifdef FEAT_FOLDING\n\t    if (hasFolding(bot, NULL, &bot))\n\t\t// count one logical line for a sequence of folded lines\n\t\t++used;\n\t    else\n#endif\n\t\tused += plines(bot);\n\t}\n\tif (used > curwin->w_height)\n\t    break;\n\n\textra += i;\n\tnew_topline = top;\n\t--top;\n\t++bot;\n    }\n\n    /*\n     * If we don't have enough space, put cursor in the middle.\n     * This makes sure we get the same position when using \"k\" and \"j\"\n     * in a small window.\n     */\n    if (used > curwin->w_height)\n\tscroll_cursor_halfway(FALSE, FALSE);\n    else\n    {\n\t/*\n\t * If \"always\" is FALSE, only adjust topline to a lower value, higher\n\t * value may happen with wrapping lines.\n\t */\n\tif (new_topline < curwin->w_topline || always)\n\t    curwin->w_topline = new_topline;\n\tif (curwin->w_topline > curwin->w_cursor.lnum)\n\t    curwin->w_topline = curwin->w_cursor.lnum;\n#ifdef FEAT_DIFF\n\tcurwin->w_topfill = diff_check_fill(curwin, curwin->w_topline);\n\tif (curwin->w_topfill > 0 && extra > off)\n\t{\n\t    curwin->w_topfill -= extra - off;\n\t    if (curwin->w_topfill < 0)\n\t\tcurwin->w_topfill = 0;\n\t}\n\tcheck_topfill(curwin, FALSE);\n#endif\n\tif (curwin->w_topline != old_topline)\n\t    reset_skipcol();\n\telse if (curwin->w_topline == curwin->w_cursor.lnum)\n\t{\n\t    validate_virtcol();\n\t    if (curwin->w_skipcol >= curwin->w_virtcol)\n\t\t// TODO: if the line doesn't fit may optimize w_skipcol instead\n\t\t// of making it zero\n\t\treset_skipcol();\n\t}\n\tif (curwin->w_topline != old_topline\n\t\t|| curwin->w_skipcol != old_skipcol\n#ifdef FEAT_DIFF\n\t\t|| curwin->w_topfill != old_topfill\n#endif\n\t\t)\n\t    curwin->w_valid &=\n\t\t      ~(VALID_WROW|VALID_CROW|VALID_BOTLINE|VALID_BOTLINE_AP);\n\tcurwin->w_valid |= VALID_TOPLINE;\n    }\n}\n\n/*\n * Set w_empty_rows and w_filler_rows for window \"wp\", having used up \"used\"\n * screen lines for text lines.\n */\n    void\nset_empty_rows(win_T *wp, int used)\n{\n#ifdef FEAT_DIFF\n    wp->w_filler_rows = 0;\n#endif\n    if (used == 0)\n\twp->w_empty_rows = 0;\t// single line that doesn't fit\n    else\n    {\n\twp->w_empty_rows = wp->w_height - used;\n#ifdef FEAT_DIFF\n\tif (wp->w_botline <= wp->w_buffer->b_ml.ml_line_count)\n\t{\n\t    wp->w_filler_rows = diff_check_fill(wp, wp->w_botline);\n\t    if (wp->w_empty_rows > wp->w_filler_rows)\n\t\twp->w_empty_rows -= wp->w_filler_rows;\n\t    else\n\t    {\n\t\twp->w_filler_rows = wp->w_empty_rows;\n\t\twp->w_empty_rows = 0;\n\t    }\n\t}\n#endif\n    }\n}\n\n/*\n * Recompute topline to put the cursor at the bottom of the window.\n * When scrolling scroll at least \"min_scroll\" lines.\n * If \"set_topbot\" is TRUE, set topline and botline first (for \"zb\").\n * This is messy stuff!!!\n */\n    void\nscroll_cursor_bot(int min_scroll, int set_topbot)\n{\n    int\t\tused;\n    int\t\tscrolled = 0;\n    int\t\textra = 0;\n    int\t\ti;\n    linenr_T\tline_count;\n    linenr_T\told_topline = curwin->w_topline;\n    int\t\told_skipcol = curwin->w_skipcol;\n    lineoff_T\tloff;\n    lineoff_T\tboff;\n#ifdef FEAT_DIFF\n    int\t\told_topfill = curwin->w_topfill;\n    int\t\tfill_below_window;\n#endif\n    linenr_T\told_botline = curwin->w_botline;\n    linenr_T\told_valid = curwin->w_valid;\n    int\t\told_empty_rows = curwin->w_empty_rows;\n    linenr_T\tcln;\t\t    // Cursor Line Number\n    long\tso = get_scrolloff_value();\n    int\t\tdo_sms = curwin->w_p_wrap && curwin->w_p_sms;\n\n    cln = curwin->w_cursor.lnum;\n    if (set_topbot)\n    {\n\tint set_skipcol = FALSE;\n\n\tused = 0;\n\tcurwin->w_botline = cln + 1;\n#ifdef FEAT_DIFF\n\tloff.fill = 0;\n#endif\n\tfor (curwin->w_topline = curwin->w_botline;\n\t\tcurwin->w_topline > 1;\n\t\tcurwin->w_topline = loff.lnum)\n\t{\n\t    loff.lnum = curwin->w_topline;\n\t    topline_back_winheight(&loff, FALSE);\n\t    if (loff.height == MAXCOL)\n\t\tbreak;\n\t    if (used + loff.height > curwin->w_height)\n\t    {\n\t\tif (do_sms)\n\t\t{\n\t\t    // 'smoothscroll' and 'wrap' are set.  The above line is\n\t\t    // too long to show in its entirety, so we show just a part\n\t\t    // of it.\n\t\t    if (used < curwin->w_height)\n\t\t    {\n\t\t\tint plines_offset = used + loff.height\n\t\t\t\t\t\t\t    - curwin->w_height;\n\t\t\tused = curwin->w_height;\n#ifdef FEAT_DIFF\n\t\t\tcurwin->w_topfill = loff.fill;\n#endif\n\t\t\tcurwin->w_topline = loff.lnum;\n\t\t\tcurwin->w_skipcol = skipcol_from_plines(\n\t\t\t\t\t\t\tcurwin, plines_offset);\n\t\t\tset_skipcol = TRUE;\n\t\t    }\n\t\t}\n\t\tbreak;\n\t    }\n\t    used += loff.height;\n#ifdef FEAT_DIFF\n\t    curwin->w_topfill = loff.fill;\n#endif\n\t}\n\tset_empty_rows(curwin, used);\n\tcurwin->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;\n\tif (curwin->w_topline != old_topline\n#ifdef FEAT_DIFF\n\t\t|| curwin->w_topfill != old_topfill\n#endif\n\t\t|| set_skipcol\n\t\t|| curwin->w_skipcol != 0)\n\t{\n\t    curwin->w_valid &= ~(VALID_WROW|VALID_CROW);\n\t    if (set_skipcol)\n\t\tredraw_later(UPD_NOT_VALID);\n\t    else\n\t\treset_skipcol();\n\t}\n    }\n    else\n\tvalidate_botline();\n\n    // The lines of the cursor line itself are always used.\n#ifdef FEAT_DIFF\n    used = plines_nofill(cln);\n#else\n    validate_cheight();\n    used = curwin->w_cline_height;\n#endif\n\n    // If the cursor is on or below botline, we will at least scroll by the\n    // height of the cursor line, which is \"used\".  Correct for empty lines,\n    // which are really part of botline.\n    if (cln >= curwin->w_botline)\n    {\n\tscrolled = used;\n\tif (cln == curwin->w_botline)\n\t    scrolled -= curwin->w_empty_rows;\n\tif (do_sms)\n\t{\n\t    // 'smoothscroll' and 'wrap' are set.\n\t    // Calculate how many screen lines the current top line of window\n\t    // occupies. If it is occupying more than the entire window, we\n\t    // need to scroll the additional clipped lines to scroll past the\n\t    // top line before we can move on to the other lines.\n\t    int top_plines =\n#ifdef FEAT_DIFF\n\t\t\t    plines_win_nofill\n#else\n\t\t\t    plines_win\n#endif\n\t\t\t\t\t(curwin, curwin->w_topline, FALSE);\n\t    int skip_lines = 0;\n\t    int width1 = curwin->w_width - curwin_col_off();\n\t    if (width1 > 0)\n\t    {\n\t\tint width2 = width1 + curwin_col_off2();\n\t\t// similar formula is used in curs_columns()\n\t\tif (curwin->w_skipcol > width1)\n\t\t    skip_lines += (curwin->w_skipcol - width1) / width2 + 1;\n\t\telse if (curwin->w_skipcol > 0)\n\t\t    skip_lines = 1;\n\n\t\ttop_plines -= skip_lines;\n\t\tif (top_plines > curwin->w_height)\n\t\t{\n\t\t    scrolled += (top_plines - curwin->w_height);\n\t\t}\n\t    }\n\t}\n    }\n\n    /*\n     * Stop counting lines to scroll when\n     * - hitting start of the file\n     * - scrolled nothing or at least 'sj' lines\n     * - at least 'scrolloff' lines below the cursor\n     * - lines between botline and cursor have been counted\n     */\n#ifdef FEAT_FOLDING\n    if (!hasFolding(curwin->w_cursor.lnum, &loff.lnum, &boff.lnum))\n#endif\n    {\n\tloff.lnum = cln;\n\tboff.lnum = cln;\n    }\n#ifdef FEAT_DIFF\n    loff.fill = 0;\n    boff.fill = 0;\n    fill_below_window = diff_check_fill(curwin, curwin->w_botline)\n\t\t\t\t\t\t      - curwin->w_filler_rows;\n#endif\n\n    while (loff.lnum > 1)\n    {\n\t// Stop when scrolled nothing or at least \"min_scroll\", found \"extra\"\n\t// context for 'scrolloff' and counted all lines below the window.\n\tif ((((scrolled <= 0 || scrolled >= min_scroll)\n\t\t    && extra >= (mouse_dragging > 0 ? mouse_dragging - 1 : so))\n\t\t    || boff.lnum + 1 > curbuf->b_ml.ml_line_count)\n\t\t&& loff.lnum <= curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t&& (loff.lnum < curwin->w_botline\n\t\t    || loff.fill >= fill_below_window)\n#endif\n\t\t)\n\t    break;\n\n\t// Add one line above\n\ttopline_back(&loff);\n\tif (loff.height == MAXCOL)\n\t    used = MAXCOL;\n\telse\n\t    used += loff.height;\n\tif (used > curwin->w_height)\n\t    break;\n\tif (loff.lnum >= curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t&& (loff.lnum > curwin->w_botline\n\t\t    || loff.fill <= fill_below_window)\n#endif\n\t\t)\n\t{\n\t    // Count screen lines that are below the window.\n\t    scrolled += loff.height;\n\t    if (loff.lnum == curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t\t    && loff.fill == 0\n#endif\n\t\t    )\n\t\tscrolled -= curwin->w_empty_rows;\n\t}\n\n\tif (boff.lnum < curbuf->b_ml.ml_line_count)\n\t{\n\t    // Add one line below\n\t    botline_forw(&boff);\n\t    used += boff.height;\n\t    if (used > curwin->w_height)\n\t\tbreak;\n\t    if (extra < ( mouse_dragging > 0 ? mouse_dragging - 1 : so)\n\t\t    || scrolled < min_scroll)\n\t    {\n\t\textra += boff.height;\n\t\tif (boff.lnum >= curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t\t|| (boff.lnum + 1 == curwin->w_botline\n\t\t\t    && boff.fill > curwin->w_filler_rows)\n#endif\n\t\t   )\n\t\t{\n\t\t    // Count screen lines that are below the window.\n\t\t    scrolled += boff.height;\n\t\t    if (boff.lnum == curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t\t    && boff.fill == 0\n#endif\n\t\t\t    )\n\t\t\tscrolled -= curwin->w_empty_rows;\n\t\t}\n\t    }\n\t}\n    }\n\n    // curwin->w_empty_rows is larger, no need to scroll\n    if (scrolled <= 0)\n\tline_count = 0;\n    // more than a screenfull, don't scroll but redraw\n    else if (used > curwin->w_height)\n\tline_count = used;\n    // scroll minimal number of lines\n    else\n    {\n\tline_count = 0;\n#ifdef FEAT_DIFF\n\tboff.fill = curwin->w_topfill;\n#endif\n\tboff.lnum = curwin->w_topline - 1;\n\tfor (i = 0; i < scrolled && boff.lnum < curwin->w_botline; )\n\t{\n\t    botline_forw(&boff);\n\t    i += boff.height;\n\t    ++line_count;\n\t}\n\tif (i < scrolled)\t// below curwin->w_botline, don't scroll\n\t    line_count = 9999;\n    }\n\n    /*\n     * Scroll up if the cursor is off the bottom of the screen a bit.\n     * Otherwise put it at 1/2 of the screen.\n     */\n    if (line_count >= curwin->w_height && line_count > min_scroll)\n\tscroll_cursor_halfway(FALSE, TRUE);\n    else if (line_count > 0)\n    {\n\tif (do_sms)\n\t    scrollup(scrolled, TRUE);  // TODO\n\telse\n\t    scrollup(line_count, TRUE);\n    }\n\n    /*\n     * If topline didn't change we need to restore w_botline and w_empty_rows\n     * (we changed them).\n     * If topline did change, update_screen() will set botline.\n     */\n    if (curwin->w_topline == old_topline\n\t    && curwin->w_skipcol == old_skipcol\n\t    && set_topbot)\n    {\n\tcurwin->w_botline = old_botline;\n\tcurwin->w_empty_rows = old_empty_rows;\n\tcurwin->w_valid = old_valid;\n    }\n    curwin->w_valid |= VALID_TOPLINE;\n}\n\n/*\n * Recompute topline to put the cursor halfway the window\n * If \"atend\" is TRUE, also put it halfway at the end of the file.\n */\n    void\nscroll_cursor_halfway(int atend, int prefer_above)\n{\n    int\t\tabove = 0;\n    linenr_T\ttopline;\n    colnr_T\tskipcol = 0;\n#ifdef FEAT_DIFF\n    int\t\ttopfill = 0;\n#endif\n    int\t\tbelow = 0;\n    int\t\tused;\n    lineoff_T\tloff;\n    lineoff_T\tboff;\n#ifdef FEAT_DIFF\n    linenr_T\told_topline = curwin->w_topline;\n#endif\n\n#ifdef FEAT_PROP_POPUP\n    // if the width changed this needs to be updated first\n    may_update_popup_position();\n#endif\n    loff.lnum = boff.lnum = curwin->w_cursor.lnum;\n#ifdef FEAT_FOLDING\n    (void)hasFolding(loff.lnum, &loff.lnum, &boff.lnum);\n#endif\n#ifdef FEAT_DIFF\n    used = plines_nofill(loff.lnum);\n    loff.fill = 0;\n    boff.fill = 0;\n#else\n    used = plines(loff.lnum);\n#endif\n    topline = loff.lnum;\n\n    int want_height;\n    int do_sms = curwin->w_p_wrap && curwin->w_p_sms;\n    if (do_sms)\n    {\n\t// 'smoothscroll' and 'wrap' are set\n\tif (atend)\n\t{\n\t    want_height = (curwin->w_height - used) / 2;\n\t    used = 0;\n\t}\n\telse\n\t    want_height = curwin->w_height;\n    }\n\n    while (topline > 1)\n    {\n\t// If using smoothscroll, we can precisely scroll to the\n\t// exact point where the cursor is halfway down the screen.\n\tif (do_sms)\n\t{\n\t    topline_back_winheight(&loff, FALSE);\n\t    if (loff.height == MAXCOL)\n\t\tbreak;\n\t    used += loff.height;\n\t    if (!atend && boff.lnum < curbuf->b_ml.ml_line_count)\n\t    {\n\t\tbotline_forw(&boff);\n\t\tused += boff.height;\n\t    }\n\t    if (used > want_height)\n\t    {\n\t\tif (used - loff.height < want_height)\n\t\t{\n\t\t    topline = loff.lnum;\n#ifdef FEAT_DIFF\n\t\t    topfill = loff.fill;\n#endif\n\t\t    skipcol = skipcol_from_plines(curwin, used - want_height);\n\t\t}\n\t\tbreak;\n\t    }\n\t    topline = loff.lnum;\n#ifdef FEAT_DIFF\n\t    topfill = loff.fill;\n#endif\n\t    continue;\n\t}\n\n\t// If not using smoothscroll, we have to iteratively find how many\n\t// lines to scroll down to roughly fit the cursor.\n\t// This may not be right in the middle if the lines'\n\t// physical height > 1 (e.g. 'wrap' is on).\n\n\t// Depending on \"prefer_above\" we add a line above or below first.\n\t// Loop twice to avoid duplicating code.\n\tint done = FALSE;\n\tfor (int round = 1; round <= 2; ++round)\n\t{\n\t    if (prefer_above ? (round == 2 && below < above)\n\t\t\t     : (round == 1 && below <= above))\n\t    {\n\t\t// add a line below the cursor\n\t\tif (boff.lnum < curbuf->b_ml.ml_line_count)\n\t\t{\n\t\t    botline_forw(&boff);\n\t\t    used += boff.height;\n\t\t    if (used > curwin->w_height)\n\t\t    {\n\t\t\tdone = TRUE;\n\t\t\tbreak;\n\t\t    }\n\t\t    below += boff.height;\n\t\t}\n\t\telse\n\t\t{\n\t\t    ++below;\t    // count a \"~\" line\n\t\t    if (atend)\n\t\t\t++used;\n\t\t}\n\t    }\n\n\t    if (prefer_above ? (round == 1 && below >= above)\n\t\t\t     : (round == 1 && below > above))\n\t    {\n\t\t// add a line above the cursor\n\t\ttopline_back(&loff);\n\t\tif (loff.height == MAXCOL)\n\t\t    used = MAXCOL;\n\t\telse\n\t\t    used += loff.height;\n\t\tif (used > curwin->w_height)\n\t\t{\n\t\t    done = TRUE;\n\t\t    break;\n\t\t}\n\t\tabove += loff.height;\n\t\ttopline = loff.lnum;\n#ifdef FEAT_DIFF\n\t\ttopfill = loff.fill;\n#endif\n\t    }\n\t}\n\tif (done)\n\t    break;\n    }\n\n#ifdef FEAT_FOLDING\n    if (!hasFolding(topline, &curwin->w_topline, NULL))\n#endif\n    {\n\tif (curwin->w_topline != topline\n\t\t|| skipcol != 0\n\t\t|| curwin->w_skipcol != 0)\n\t{\n\t    curwin->w_topline = topline;\n\t    if (skipcol != 0)\n\t    {\n\t\tcurwin->w_skipcol = skipcol;\n\t\tredraw_later(UPD_NOT_VALID);\n\t    }\n\t    else if (do_sms)\n\t\treset_skipcol();\n\t}\n    }\n#ifdef FEAT_DIFF\n    curwin->w_topfill = topfill;\n    if (old_topline > curwin->w_topline + curwin->w_height)\n\tcurwin->w_botfill = FALSE;\n    check_topfill(curwin, FALSE);\n#endif\n    curwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE|VALID_BOTLINE_AP);\n    curwin->w_valid |= VALID_TOPLINE;\n}\n\n/*\n * Correct the cursor position so that it is in a part of the screen at least\n * 'scrolloff' lines from the top and bottom, if possible.\n * If not possible, put it at the same position as scroll_cursor_halfway().\n * When called topline must be valid!\n */\n    void\ncursor_correct(void)\n{\n    int\t\tabove = 0;\t    // screen lines above topline\n    linenr_T\ttopline;\n    int\t\tbelow = 0;\t    // screen lines below botline\n    linenr_T\tbotline;\n    int\t\tabove_wanted, below_wanted;\n    linenr_T\tcln;\t\t    // Cursor Line Number\n    int\t\tmax_off;\n    long\tso = get_scrolloff_value();\n\n    /*\n     * How many lines we would like to have above/below the cursor depends on\n     * whether the first/last line of the file is on screen.\n     */\n    above_wanted = so;\n    below_wanted = so;\n    if (mouse_dragging > 0)\n    {\n\tabove_wanted = mouse_dragging - 1;\n\tbelow_wanted = mouse_dragging - 1;\n    }\n    if (curwin->w_topline == 1)\n    {\n\tabove_wanted = 0;\n\tmax_off = curwin->w_height / 2;\n\tif (below_wanted > max_off)\n\t    below_wanted = max_off;\n    }\n    validate_botline();\n    if (curwin->w_botline == curbuf->b_ml.ml_line_count + 1\n\t    && mouse_dragging == 0)\n    {\n\tbelow_wanted = 0;\n\tmax_off = (curwin->w_height - 1) / 2;\n\tif (above_wanted > max_off)\n\t    above_wanted = max_off;\n    }\n\n    /*\n     * If there are sufficient file-lines above and below the cursor, we can\n     * return now.\n     */\n    cln = curwin->w_cursor.lnum;\n    if (cln >= curwin->w_topline + above_wanted\n\t    && cln < curwin->w_botline - below_wanted\n#ifdef FEAT_FOLDING\n\t    && !hasAnyFolding(curwin)\n#endif\n\t    )\n\treturn;\n\n    if (curwin->w_p_sms && !curwin->w_p_wrap)\n    {\n\t// 'smoothscroll' is active\n\tif (curwin->w_cline_height == curwin->w_height)\n\t{\n\t    // The cursor line just fits in the window, don't scroll.\n\t    reset_skipcol();\n\t    return;\n\t}\n\t// TODO: If the cursor line doesn't fit in the window then only adjust\n\t// w_skipcol.\n    }\n\n    /*\n     * Narrow down the area where the cursor can be put by taking lines from\n     * the top and the bottom until:\n     * - the desired context lines are found\n     * - the lines from the top is past the lines from the bottom\n     */\n    topline = curwin->w_topline;\n    botline = curwin->w_botline - 1;\n#ifdef FEAT_DIFF\n    // count filler lines as context\n    above = curwin->w_topfill;\n    below = curwin->w_filler_rows;\n#endif\n    while ((above < above_wanted || below < below_wanted) && topline < botline)\n    {\n\tif (below < below_wanted && (below <= above || above >= above_wanted))\n\t{\n#ifdef FEAT_FOLDING\n\t    if (hasFolding(botline, &botline, NULL))\n\t\t++below;\n\t    else\n#endif\n\t\tbelow += plines(botline);\n\t    --botline;\n\t}\n\tif (above < above_wanted && (above < below || below >= below_wanted))\n\t{\n#ifdef FEAT_FOLDING\n\t    if (hasFolding(topline, NULL, &topline))\n\t\t++above;\n\t    else\n#endif\n\t\tabove += PLINES_NOFILL(topline);\n#ifdef FEAT_DIFF\n\t    // Count filler lines below this line as context.\n\t    if (topline < botline)\n\t\tabove += diff_check_fill(curwin, topline + 1);\n#endif\n\t    ++topline;\n\t}\n    }\n    if (topline == botline || botline == 0)\n\tcurwin->w_cursor.lnum = topline;\n    else if (topline > botline)\n\tcurwin->w_cursor.lnum = botline;\n    else\n    {\n\tif (cln < topline && curwin->w_topline > 1)\n\t{\n\t    curwin->w_cursor.lnum = topline;\n\t    curwin->w_valid &=\n\t\t\t    ~(VALID_WROW|VALID_WCOL|VALID_CHEIGHT|VALID_CROW);\n\t}\n\tif (cln > botline && curwin->w_botline <= curbuf->b_ml.ml_line_count)\n\t{\n\t    curwin->w_cursor.lnum = botline;\n\t    curwin->w_valid &=\n\t\t\t    ~(VALID_WROW|VALID_WCOL|VALID_CHEIGHT|VALID_CROW);\n\t}\n    }\n    curwin->w_valid |= VALID_TOPLINE;\n}\n\nstatic void get_scroll_overlap(lineoff_T *lp, int dir);\n\n/*\n * Move screen \"count\" pages up (\"dir\" is BACKWARD) or down (\"dir\" is FORWARD)\n * and update the screen.\n *\n * Return FAIL for failure, OK otherwise.\n */\n    int\nonepage(int dir, long count)\n{\n    long\tn;\n    int\t\tretval = OK;\n    lineoff_T\tloff;\n    linenr_T\told_topline = curwin->w_topline;\n    long\tso = get_scrolloff_value();\n\n    if (curbuf->b_ml.ml_line_count == 1)    // nothing to do\n    {\n\tbeep_flush();\n\treturn FAIL;\n    }\n\n    for ( ; count > 0; --count)\n    {\n\tvalidate_botline();\n\t/*\n\t * It's an error to move a page up when the first line is already on\n\t * the screen.\tIt's an error to move a page down when the last line\n\t * is on the screen and the topline is 'scrolloff' lines from the\n\t * last line.\n\t */\n\tif (dir == FORWARD\n\t\t? ((curwin->w_topline >= curbuf->b_ml.ml_line_count - so)\n\t\t    && curwin->w_botline > curbuf->b_ml.ml_line_count)\n\t\t: (curwin->w_topline == 1\n#ifdef FEAT_DIFF\n\t\t    && curwin->w_topfill ==\n\t\t\t\t    diff_check_fill(curwin, curwin->w_topline)\n#endif\n\t\t    ))\n\t{\n\t    beep_flush();\n\t    retval = FAIL;\n\t    break;\n\t}\n\n#ifdef FEAT_DIFF\n\tloff.fill = 0;\n#endif\n\tif (dir == FORWARD)\n\t{\n\t    if (ONE_WINDOW && p_window > 0 && p_window < Rows - 1)\n\t    {\n\t\t// Vi compatible scrolling\n\t\tif (p_window <= 2)\n\t\t    ++curwin->w_topline;\n\t\telse\n\t\t    curwin->w_topline += p_window - 2;\n\t\tif (curwin->w_topline > curbuf->b_ml.ml_line_count)\n\t\t    curwin->w_topline = curbuf->b_ml.ml_line_count;\n\t\tcurwin->w_cursor.lnum = curwin->w_topline;\n\t    }\n\t    else if (curwin->w_botline > curbuf->b_ml.ml_line_count)\n\t    {\n\t\t// at end of file\n\t\tcurwin->w_topline = curbuf->b_ml.ml_line_count;\n#ifdef FEAT_DIFF\n\t\tcurwin->w_topfill = 0;\n#endif\n\t\tcurwin->w_valid &= ~(VALID_WROW|VALID_CROW);\n\t    }\n\t    else\n\t    {\n\t\t// For the overlap, start with the line just below the window\n\t\t// and go upwards.\n\t\tloff.lnum = curwin->w_botline;\n#ifdef FEAT_DIFF\n\t\tloff.fill = diff_check_fill(curwin, loff.lnum)\n\t\t\t\t\t\t      - curwin->w_filler_rows;\n#endif\n\t\tget_scroll_overlap(&loff, -1);\n\t\tcurwin->w_topline = loff.lnum;\n#ifdef FEAT_DIFF\n\t\tcurwin->w_topfill = loff.fill;\n\t\tcheck_topfill(curwin, FALSE);\n#endif\n\t\tcurwin->w_cursor.lnum = curwin->w_topline;\n\t\tcurwin->w_valid &= ~(VALID_WCOL|VALID_CHEIGHT|VALID_WROW|\n\t\t\t\t   VALID_CROW|VALID_BOTLINE|VALID_BOTLINE_AP);\n\t    }\n\t}\n\telse\t// dir == BACKWARDS\n\t{\n#ifdef FEAT_DIFF\n\t    if (curwin->w_topline == 1)\n\t    {\n\t\t// Include max number of filler lines\n\t\tmax_topfill();\n\t\tcontinue;\n\t    }\n#endif\n\t    if (ONE_WINDOW && p_window > 0 && p_window < Rows - 1)\n\t    {\n\t\t// Vi compatible scrolling (sort of)\n\t\tif (p_window <= 2)\n\t\t    --curwin->w_topline;\n\t\telse\n\t\t    curwin->w_topline -= p_window - 2;\n\t\tif (curwin->w_topline < 1)\n\t\t    curwin->w_topline = 1;\n\t\tcurwin->w_cursor.lnum = curwin->w_topline + p_window - 1;\n\t\tif (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t\t    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t\tcontinue;\n\t    }\n\n\t    // Find the line at the top of the window that is going to be the\n\t    // line at the bottom of the window.  Make sure this results in\n\t    // the same line as before doing CTRL-F.\n\t    loff.lnum = curwin->w_topline - 1;\n#ifdef FEAT_DIFF\n\t    loff.fill = diff_check_fill(curwin, loff.lnum + 1)\n\t\t\t\t\t\t\t  - curwin->w_topfill;\n#endif\n\t    get_scroll_overlap(&loff, 1);\n\n\t    if (loff.lnum >= curbuf->b_ml.ml_line_count)\n\t    {\n\t\tloff.lnum = curbuf->b_ml.ml_line_count;\n#ifdef FEAT_DIFF\n\t\tloff.fill = 0;\n\t    }\n\t    else\n\t    {\n\t\tbotline_topline(&loff);\n#endif\n\t    }\n\t    curwin->w_cursor.lnum = loff.lnum;\n\n\t    // Find the line just above the new topline to get the right line\n\t    // at the bottom of the window.\n\t    n = 0;\n\t    while (n <= curwin->w_height && loff.lnum >= 1)\n\t    {\n\t\ttopline_back(&loff);\n\t\tif (loff.height == MAXCOL)\n\t\t    n = MAXCOL;\n\t\telse\n\t\t    n += loff.height;\n\t    }\n\t    if (loff.lnum < 1)\t\t\t// at begin of file\n\t    {\n\t\tcurwin->w_topline = 1;\n#ifdef FEAT_DIFF\n\t\tmax_topfill();\n#endif\n\t\tcurwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);\n\t    }\n\t    else\n\t    {\n\t\t// Go two lines forward again.\n#ifdef FEAT_DIFF\n\t\ttopline_botline(&loff);\n#endif\n\t\tbotline_forw(&loff);\n\t\tbotline_forw(&loff);\n#ifdef FEAT_DIFF\n\t\tbotline_topline(&loff);\n#endif\n#ifdef FEAT_FOLDING\n\t\t// We're at the wrong end of a fold now.\n\t\t(void)hasFolding(loff.lnum, &loff.lnum, NULL);\n#endif\n\n\t\t// Always scroll at least one line.  Avoid getting stuck on\n\t\t// very long lines.\n\t\tif (loff.lnum >= curwin->w_topline\n#ifdef FEAT_DIFF\n\t\t\t&& (loff.lnum > curwin->w_topline\n\t\t\t    || loff.fill >= curwin->w_topfill)\n#endif\n\t\t\t)\n\t\t{\n#ifdef FEAT_DIFF\n\t\t    // First try using the maximum number of filler lines.  If\n\t\t    // that's not enough, backup one line.\n\t\t    loff.fill = curwin->w_topfill;\n\t\t    if (curwin->w_topfill < diff_check_fill(curwin,\n\t\t\t\t\t\t\t   curwin->w_topline))\n\t\t\tmax_topfill();\n\t\t    if (curwin->w_topfill == loff.fill)\n#endif\n\t\t    {\n\t\t\t--curwin->w_topline;\n#ifdef FEAT_DIFF\n\t\t\tcurwin->w_topfill = 0;\n#endif\n\t\t\tcurwin->w_valid &= ~(VALID_WROW|VALID_CROW);\n\t\t    }\n\t\t    comp_botline(curwin);\n\t\t    curwin->w_cursor.lnum = curwin->w_botline - 1;\n\t\t    curwin->w_valid &=\n\t\t\t    ~(VALID_WCOL|VALID_CHEIGHT|VALID_WROW|VALID_CROW);\n\t\t}\n\t\telse\n\t\t{\n\t\t    curwin->w_topline = loff.lnum;\n#ifdef FEAT_DIFF\n\t\t    curwin->w_topfill = loff.fill;\n\t\t    check_topfill(curwin, FALSE);\n#endif\n\t\t    curwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);\n\t\t}\n\t    }\n\t}\n    }\n#ifdef FEAT_FOLDING\n    foldAdjustCursor();\n#endif\n    cursor_correct();\n    check_cursor_col();\n    if (retval == OK)\n\tbeginline(BL_SOL | BL_FIX);\n    curwin->w_valid &= ~(VALID_WCOL|VALID_WROW|VALID_VIRTCOL);\n\n    if (retval == OK && dir == FORWARD)\n    {\n\t// Avoid the screen jumping up and down when 'scrolloff' is non-zero.\n\t// But make sure we scroll at least one line (happens with mix of long\n\t// wrapping lines and non-wrapping line).\n\tif (check_top_offset())\n\t{\n\t    scroll_cursor_top(1, FALSE);\n\t    if (curwin->w_topline <= old_topline\n\t\t\t\t  && old_topline < curbuf->b_ml.ml_line_count)\n\t    {\n\t\tcurwin->w_topline = old_topline + 1;\n#ifdef FEAT_FOLDING\n\t\t(void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n\t    }\n\t}\n#ifdef FEAT_FOLDING\n\telse if (curwin->w_botline > curbuf->b_ml.ml_line_count)\n\t    (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n    }\n\n    redraw_later(UPD_VALID);\n    return retval;\n}\n\n/*\n * Decide how much overlap to use for page-up or page-down scrolling.\n * This is symmetric, so that doing both keeps the same lines displayed.\n * Three lines are examined:\n *\n *  before CTRL-F\t    after CTRL-F / before CTRL-B\n *     etc.\t\t\tl1\n *  l1 last but one line\t------------\n *  l2 last text line\t\tl2 top text line\n *  -------------\t\tl3 second text line\n *  l3\t\t\t\t   etc.\n */\n    static void\nget_scroll_overlap(lineoff_T *lp, int dir)\n{\n    int\t\th1, h2, h3, h4;\n    int\t\tmin_height = curwin->w_height - 2;\n    lineoff_T\tloff0, loff1, loff2;\n\n#ifdef FEAT_DIFF\n    if (lp->fill > 0)\n\tlp->height = 1;\n    else\n\tlp->height = plines_nofill(lp->lnum);\n#else\n    lp->height = plines(lp->lnum);\n#endif\n    h1 = lp->height;\n    if (h1 > min_height)\n\treturn;\t\t// no overlap\n\n    loff0 = *lp;\n    if (dir > 0)\n\tbotline_forw(lp);\n    else\n\ttopline_back(lp);\n    h2 = lp->height;\n    if (h2 == MAXCOL || h2 + h1 > min_height)\n    {\n\t*lp = loff0;\t// no overlap\n\treturn;\n    }\n\n    loff1 = *lp;\n    if (dir > 0)\n\tbotline_forw(lp);\n    else\n\ttopline_back(lp);\n    h3 = lp->height;\n    if (h3 == MAXCOL || h3 + h2 > min_height)\n    {\n\t*lp = loff0;\t// no overlap\n\treturn;\n    }\n\n    loff2 = *lp;\n    if (dir > 0)\n\tbotline_forw(lp);\n    else\n\ttopline_back(lp);\n    h4 = lp->height;\n    if (h4 == MAXCOL || h4 + h3 + h2 > min_height || h3 + h2 + h1 > min_height)\n\t*lp = loff1;\t// 1 line overlap\n    else\n\t*lp = loff2;\t// 2 lines overlap\n}\n\n/*\n * Scroll 'scroll' lines up or down.\n */\n    void\nhalfpage(int flag, linenr_T Prenum)\n{\n    long\tscrolled = 0;\n    int\t\ti;\n    int\t\tn;\n    int\t\troom;\n\n    if (Prenum)\n\tcurwin->w_p_scr = (Prenum > curwin->w_height) ?\n\t\t\t\t\t\tcurwin->w_height : Prenum;\n    n = (curwin->w_p_scr <= curwin->w_height) ?\n\t\t\t\t    curwin->w_p_scr : curwin->w_height;\n\n    update_topline();\n    validate_botline();\n    room = curwin->w_empty_rows;\n#ifdef FEAT_DIFF\n    room += curwin->w_filler_rows;\n#endif\n    if (flag)\n    {\n\t/*\n\t * scroll the text up\n\t */\n\twhile (n > 0 && curwin->w_botline <= curbuf->b_ml.ml_line_count)\n\t{\n#ifdef FEAT_DIFF\n\t    if (curwin->w_topfill > 0)\n\t    {\n\t\ti = 1;\n\t\t--n;\n\t\t--curwin->w_topfill;\n\t    }\n\t    else\n#endif\n\t    {\n\t\ti = PLINES_NOFILL(curwin->w_topline);\n\t\tn -= i;\n\t\tif (n < 0 && scrolled > 0)\n\t\t    break;\n#ifdef FEAT_FOLDING\n\t\t(void)hasFolding(curwin->w_topline, NULL, &curwin->w_topline);\n#endif\n\t\t++curwin->w_topline;\n#ifdef FEAT_DIFF\n\t\tcurwin->w_topfill = diff_check_fill(curwin, curwin->w_topline);\n#endif\n\n\t\tif (curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t\t{\n\t\t    ++curwin->w_cursor.lnum;\n\t\t    curwin->w_valid &=\n\t\t\t\t    ~(VALID_VIRTCOL|VALID_CHEIGHT|VALID_WCOL);\n\t\t}\n\t    }\n\t    curwin->w_valid &= ~(VALID_CROW|VALID_WROW);\n\t    scrolled += i;\n\n\t    /*\n\t     * Correct w_botline for changed w_topline.\n\t     * Won't work when there are filler lines.\n\t     */\n#ifdef FEAT_DIFF\n\t    if (curwin->w_p_diff)\n\t\tcurwin->w_valid &= ~(VALID_BOTLINE|VALID_BOTLINE_AP);\n\t    else\n#endif\n\t    {\n\t\troom += i;\n\t\tdo\n\t\t{\n\t\t    i = plines(curwin->w_botline);\n\t\t    if (i > room)\n\t\t\tbreak;\n#ifdef FEAT_FOLDING\n\t\t    (void)hasFolding(curwin->w_botline, NULL,\n\t\t\t\t\t\t\t  &curwin->w_botline);\n#endif\n\t\t    ++curwin->w_botline;\n\t\t    room -= i;\n\t\t} while (curwin->w_botline <= curbuf->b_ml.ml_line_count);\n\t    }\n\t}\n\n\t/*\n\t * When hit bottom of the file: move cursor down.\n\t */\n\tif (n > 0)\n\t{\n# ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\twhile (--n >= 0\n\t\t\t&& curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t\t{\n\t\t    (void)hasFolding(curwin->w_cursor.lnum, NULL,\n\t\t\t\t\t\t      &curwin->w_cursor.lnum);\n\t\t    ++curwin->w_cursor.lnum;\n\t\t}\n\t    }\n\t    else\n# endif\n\t\tcurwin->w_cursor.lnum += n;\n\t    check_cursor_lnum();\n\t}\n    }\n    else\n    {\n\t/*\n\t * scroll the text down\n\t */\n\twhile (n > 0 && curwin->w_topline > 1)\n\t{\n#ifdef FEAT_DIFF\n\t    if (curwin->w_topfill < diff_check_fill(curwin, curwin->w_topline))\n\t    {\n\t\ti = 1;\n\t\t--n;\n\t\t++curwin->w_topfill;\n\t    }\n\t    else\n#endif\n\t    {\n\t\ti = PLINES_NOFILL(curwin->w_topline - 1);\n\t\tn -= i;\n\t\tif (n < 0 && scrolled > 0)\n\t\t    break;\n\t\t--curwin->w_topline;\n#ifdef FEAT_FOLDING\n\t\t(void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n#ifdef FEAT_DIFF\n\t\tcurwin->w_topfill = 0;\n#endif\n\t    }\n\t    curwin->w_valid &= ~(VALID_CROW|VALID_WROW|\n\t\t\t\t\t      VALID_BOTLINE|VALID_BOTLINE_AP);\n\t    scrolled += i;\n\t    if (curwin->w_cursor.lnum > 1)\n\t    {\n\t\t--curwin->w_cursor.lnum;\n\t\tcurwin->w_valid &= ~(VALID_VIRTCOL|VALID_CHEIGHT|VALID_WCOL);\n\t    }\n\t}\n\n\t/*\n\t * When hit top of the file: move cursor up.\n\t */\n\tif (n > 0)\n\t{\n\t    if (curwin->w_cursor.lnum <= (linenr_T)n)\n\t\tcurwin->w_cursor.lnum = 1;\n\t    else\n# ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\twhile (--n >= 0 && curwin->w_cursor.lnum > 1)\n\t\t{\n\t\t    --curwin->w_cursor.lnum;\n\t\t    (void)hasFolding(curwin->w_cursor.lnum,\n\t\t\t\t\t\t&curwin->w_cursor.lnum, NULL);\n\t\t}\n\t    }\n\t    else\n# endif\n\t\tcurwin->w_cursor.lnum -= n;\n\t}\n    }\n# ifdef FEAT_FOLDING\n    // Move cursor to first line of closed fold.\n    foldAdjustCursor();\n# endif\n#ifdef FEAT_DIFF\n    check_topfill(curwin, !flag);\n#endif\n    cursor_correct();\n    beginline(BL_SOL | BL_FIX);\n    redraw_later(UPD_VALID);\n}\n\n    void\ndo_check_cursorbind(void)\n{\n    static win_T\t*prev_curwin = NULL;\n    static pos_T\tprev_cursor = {0, 0, 0};\n\n    if (curwin == prev_curwin && EQUAL_POS(curwin->w_cursor, prev_cursor))\n\treturn;\n    prev_curwin = curwin;\n    prev_cursor = curwin->w_cursor;\n\n    linenr_T\tline = curwin->w_cursor.lnum;\n    colnr_T\tcol = curwin->w_cursor.col;\n    colnr_T\tcoladd = curwin->w_cursor.coladd;\n    colnr_T\tcurswant = curwin->w_curswant;\n    int\t\tset_curswant = curwin->w_set_curswant;\n    win_T\t*old_curwin = curwin;\n    buf_T\t*old_curbuf = curbuf;\n    int\t\told_VIsual_select = VIsual_select;\n    int\t\told_VIsual_active = VIsual_active;\n\n    /*\n     * loop through the cursorbound windows\n     */\n    VIsual_select = VIsual_active = 0;\n    FOR_ALL_WINDOWS(curwin)\n    {\n\tcurbuf = curwin->w_buffer;\n\t// skip original window and windows with 'nocursorbind'\n\tif (curwin != old_curwin && curwin->w_p_crb)\n\t{\n# ifdef FEAT_DIFF\n\t    if (curwin->w_p_diff)\n\t\tcurwin->w_cursor.lnum =\n\t\t\t\t diff_get_corresponding_line(old_curbuf, line);\n\t    else\n# endif\n\t\tcurwin->w_cursor.lnum = line;\n\t    curwin->w_cursor.col = col;\n\t    curwin->w_cursor.coladd = coladd;\n\t    curwin->w_curswant = curswant;\n\t    curwin->w_set_curswant = set_curswant;\n\n\t    // Make sure the cursor is in a valid position.  Temporarily set\n\t    // \"restart_edit\" to allow the cursor to be beyond the EOL.\n\t    int restart_edit_save = restart_edit;\n\t    restart_edit = 'a';\n\t    check_cursor();\n\n\t    // Avoid a scroll here for the cursor position, 'scrollbind' is\n\t    // more important.\n\t    if (!curwin->w_p_scb)\n\t\tvalidate_cursor();\n\n\t    restart_edit = restart_edit_save;\n\t    // Correct cursor for multi-byte character.\n\t    if (has_mbyte)\n\t\tmb_adjust_cursor();\n\t    redraw_later(UPD_VALID);\n\n\t    // Only scroll when 'scrollbind' hasn't done this.\n\t    if (!curwin->w_p_scb)\n\t\tupdate_topline();\n\t    curwin->w_redr_status = TRUE;\n\t}\n    }\n\n    /*\n     * reset current-window\n     */\n    VIsual_select = old_VIsual_select;\n    VIsual_active = old_VIsual_active;\n    curwin = old_curwin;\n    curbuf = old_curbuf;\n}\n", "\" Test for 'scroll', 'scrolloff', 'smoothscroll', etc.\n\nsource check.vim\nsource screendump.vim\nsource mouse.vim\n\nfunc Test_reset_scroll()\n  let scr = &l:scroll\n\n  setlocal scroll=1\n  setlocal scroll&\n  call assert_equal(scr, &l:scroll)\n\n  setlocal scroll=1\n  setlocal scroll=0\n  call assert_equal(scr, &l:scroll)\n\n  try\n    execute 'setlocal scroll=' . (winheight(0) + 1)\n    \" not reached\n    call assert_false(1)\n  catch\n    call assert_exception('E49:')\n  endtry\n\n  split\n\n  let scr = &l:scroll\n\n  setlocal scroll=1\n  setlocal scroll&\n  call assert_equal(scr, &l:scroll)\n\n  setlocal scroll=1\n  setlocal scroll=0\n  call assert_equal(scr, &l:scroll)\n\n  quit!\nendfunc\n\nfunc Test_scolloff_even_line_count()\n  new\n  resize 6\n  setlocal scrolloff=3\n  call setline(1, range(20))\n  normal 2j\n  call assert_equal(1, getwininfo(win_getid())[0].topline)\n  normal j\n  call assert_equal(1, getwininfo(win_getid())[0].topline)\n  normal j\n  call assert_equal(2, getwininfo(win_getid())[0].topline)\n  normal j\n  call assert_equal(3, getwininfo(win_getid())[0].topline)\n\n  bwipe!\nendfunc\n\nfunc Test_mouse_scroll_inactive_with_cursorbind()\n  for scb in [0, 1]\n    for so in [0, 1, 2]\n      let msg = $'scb={scb} so={so}'\n\n      new | only\n      let w1 = win_getid()\n      setlocal cursorbind\n      let &l:scb = scb\n      let &l:so = so\n      call setline(1, range(101, 109))\n      rightbelow vnew\n      let w2 = win_getid()\n      setlocal cursorbind\n      let &l:scb = scb\n      let &l:so = so\n      call setline(1, range(101, 109))\n\n      normal! $\n      call assert_equal(3, col('.', w1), msg)\n      call assert_equal(3, col('.', w2), msg)\n      call test_setmouse(1, 1)\n      call feedkeys(\"\\<ScrollWheelDown>\", 'xt')\n      call assert_equal(4, line('w0', w1), msg)\n      call assert_equal(4 + so, line('.', w1), msg)\n      call assert_equal(1, line('w0', w2), msg)\n      call assert_equal(1, line('.', w2), msg)\n      call feedkeys(\"\\<ScrollWheelDown>\", 'xt')\n      call assert_equal(7, line('w0', w1), msg)\n      call assert_equal(7 + so, line('.', w1), msg)\n      call assert_equal(1, line('w0', w2), msg)\n      call assert_equal(1, line('.', w2), msg)\n      call feedkeys(\"\\<ScrollWheelUp>\", 'xt')\n      call assert_equal(4, line('w0', w1), msg)\n      call assert_equal(7 + so, line('.', w1), msg)\n      call assert_equal(1, line('w0', w2), msg)\n      call assert_equal(1, line('.', w2), msg)\n      call feedkeys(\"\\<ScrollWheelUp>\", 'xt')\n      call assert_equal(1, line('w0', w1), msg)\n      call assert_equal(7 + so, line('.', w1), msg)\n      call assert_equal(1, line('w0', w2), msg)\n      call assert_equal(1, line('.', w2), msg)\n      normal! 0\n      call assert_equal(1, line('.', w1), msg)\n      call assert_equal(1, col('.', w1), msg)\n      call assert_equal(1, line('.', w2), msg)\n      call assert_equal(1, col('.', w2), msg)\n\n      bwipe!\n      bwipe!\n    endfor\n  endfor\nendfunc\n\nfunc Test_CtrlE_CtrlY_stop_at_end()\n  enew\n  call setline(1, ['one', 'two'])\n  set number\n  exe \"normal \\<C-Y>\"\n  call assert_equal([\"  1 one   \"], ScreenLines(1, 10))\n  exe \"normal \\<C-E>\\<C-E>\\<C-E>\"\n  call assert_equal([\"  2 two   \"], ScreenLines(1, 10))\n\n  bwipe!\n  set nonumber\nendfunc\n\nfunc Test_smoothscroll_CtrlE_CtrlY()\n  CheckScreendump\n\n  let lines =<< trim END\n      vim9script\n      setline(1, [\n        'line one',\n        'word '->repeat(20),\n        'line three',\n        'long word '->repeat(7),\n        'line',\n        'line',\n        'line',\n      ])\n      set smoothscroll\n      :5\n  END\n  call writefile(lines, 'XSmoothScroll', 'D')\n  let buf = RunVimInTerminal('-S XSmoothScroll', #{rows: 12, cols: 40})\n\n  call term_sendkeys(buf, \"\\<C-E>\")\n  call VerifyScreenDump(buf, 'Test_smoothscroll_1', {})\n  call term_sendkeys(buf, \"\\<C-E>\")\n  call VerifyScreenDump(buf, 'Test_smoothscroll_2', {})\n  call term_sendkeys(buf, \"\\<C-E>\")\n  call VerifyScreenDump(buf, 'Test_smoothscroll_3', {})\n  call term_sendkeys(buf, \"\\<C-E>\")\n  call VerifyScreenDump(buf, 'Test_smoothscroll_4', {})\n\n  call term_sendkeys(buf, \"\\<C-Y>\")\n  call VerifyScreenDump(buf, 'Test_smoothscroll_5', {})\n  call term_sendkeys(buf, \"\\<C-Y>\")\n  call VerifyScreenDump(buf, 'Test_smoothscroll_6', {})\n  call term_sendkeys(buf, \"\\<C-Y>\")\n  call VerifyScreenDump(buf, 'Test_smoothscroll_7', {})\n  call term_sendkeys(buf, \"\\<C-Y>\")\n  call VerifyScreenDump(buf, 'Test_smoothscroll_8', {})\n\n  if has('folding')\n    call term_sendkeys(buf, \":set foldmethod=indent\\<CR>\")\n    \" move the cursor so we can reuse the same dumps\n    call term_sendkeys(buf, \"5G\")\n    call term_sendkeys(buf, \"\\<C-E>\")\n    call VerifyScreenDump(buf, 'Test_smoothscroll_1', {})\n    call term_sendkeys(buf, \"\\<C-E>\")\n    call VerifyScreenDump(buf, 'Test_smoothscroll_2', {})\n    call term_sendkeys(buf, \"7G\")\n    call term_sendkeys(buf, \"\\<C-Y>\")\n    call VerifyScreenDump(buf, 'Test_smoothscroll_7', {})\n    call term_sendkeys(buf, \"\\<C-Y>\")\n    call VerifyScreenDump(buf, 'Test_smoothscroll_8', {})\n  endif\n\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_smoothscroll_multibyte()\n  CheckScreendump\n\n  let lines =<< trim END\n      set scrolloff=0 smoothscroll\n      call setline(1, [repeat('\u03db', 45), repeat('2', 36)])\n      exe \"normal G35l\\<C-E>k\"\n  END\n  call writefile(lines, 'XSmoothMultibyte', 'D')\n  let buf = RunVimInTerminal('-S XSmoothMultibyte', #{rows: 6, cols: 40})\n  call VerifyScreenDump(buf, 'Test_smoothscroll_multi_1', {})\n\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_smoothscroll_number()\n  CheckScreendump\n\n  let lines =<< trim END\n      vim9script\n      setline(1, [\n        'one ' .. 'word '->repeat(20),\n        'two ' .. 'long word '->repeat(7),\n        'line',\n        'line',\n        'line',\n      ])\n      set smoothscroll\n      set splitkeep=topline\n      set number cpo+=n\n      :3\n\n      def g:DoRel()\n        set number relativenumber scrolloff=0\n        :%del\n        setline(1, [\n          'one',\n          'very long text '->repeat(12),\n          'three',\n        ])\n        exe \"normal 2Gzt\\<C-E>\"\n      enddef\n  END\n  call writefile(lines, 'XSmoothNumber', 'D')\n  let buf = RunVimInTerminal('-S XSmoothNumber', #{rows: 12, cols: 40})\n\n  call VerifyScreenDump(buf, 'Test_smooth_number_1', {})\n  call term_sendkeys(buf, \"\\<C-E>\")\n  call VerifyScreenDump(buf, 'Test_smooth_number_2', {})\n  call term_sendkeys(buf, \"\\<C-E>\")\n  call VerifyScreenDump(buf, 'Test_smooth_number_3', {})\n\n  call term_sendkeys(buf, \":set cpo-=n\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_smooth_number_4', {})\n  call term_sendkeys(buf, \"\\<C-Y>\")\n  call VerifyScreenDump(buf, 'Test_smooth_number_5', {})\n  call term_sendkeys(buf, \"\\<C-Y>\")\n  call VerifyScreenDump(buf, 'Test_smooth_number_6', {})\n\n  call term_sendkeys(buf, \":botright split\\<CR>gg\")\n  call VerifyScreenDump(buf, 'Test_smooth_number_7', {})\n  call term_sendkeys(buf, \"\\<C-E>\")\n  call VerifyScreenDump(buf, 'Test_smooth_number_8', {})\n  call term_sendkeys(buf, \"\\<C-E>\")\n  call VerifyScreenDump(buf, 'Test_smooth_number_9', {})\n  call term_sendkeys(buf, \":close\\<CR>\")\n\n  call term_sendkeys(buf, \":call DoRel()\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_smooth_number_10', {})\n\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_smoothscroll_list()\n  CheckScreendump\n\n  let lines =<< trim END\n      vim9script\n      set smoothscroll scrolloff=0\n      set list\n      setline(1, [\n        'one',\n        'very long text '->repeat(12),\n        'three',\n      ])\n      exe \"normal 2Gzt\\<C-E>\"\n  END\n  call writefile(lines, 'XSmoothList', 'D')\n  let buf = RunVimInTerminal('-S XSmoothList', #{rows: 8, cols: 40})\n\n  call VerifyScreenDump(buf, 'Test_smooth_list_1', {})\n\n  call term_sendkeys(buf, \":set listchars+=precedes:#\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_smooth_list_2', {})\n\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_smoothscroll_diff_mode()\n  CheckScreendump\n\n  let lines =<< trim END\n      vim9script\n      var text = 'just some text here'\n      setline(1, text)\n      set smoothscroll\n      diffthis\n      new\n      setline(1, text)\n      set smoothscroll\n      diffthis\n  END\n  call writefile(lines, 'XSmoothDiff', 'D')\n  let buf = RunVimInTerminal('-S XSmoothDiff', #{rows: 8})\n\n  call VerifyScreenDump(buf, 'Test_smooth_diff_1', {})\n  call term_sendkeys(buf, \"\\<C-Y>\")\n  call VerifyScreenDump(buf, 'Test_smooth_diff_1', {})\n  call term_sendkeys(buf, \"\\<C-E>\")\n  call VerifyScreenDump(buf, 'Test_smooth_diff_1', {})\n\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_smoothscroll_wrap_scrolloff_zero()\n  CheckScreendump\n\n  let lines =<< trim END\n      vim9script\n      setline(1, ['Line' .. (' with some text'->repeat(7))]->repeat(7))\n      set smoothscroll scrolloff=0\n      :3\n  END\n  call writefile(lines, 'XSmoothWrap', 'D')\n  let buf = RunVimInTerminal('-S XSmoothWrap', #{rows: 8, cols: 40})\n\n  call VerifyScreenDump(buf, 'Test_smooth_wrap_1', {})\n\n  \" moving cursor down - whole bottom line shows\n  call term_sendkeys(buf, \"j\")\n  call VerifyScreenDump(buf, 'Test_smooth_wrap_2', {})\n\n  call term_sendkeys(buf, \"\\<C-E>j\")\n  call VerifyScreenDump(buf, 'Test_smooth_wrap_3', {})\n\n  call term_sendkeys(buf, \"G\")\n  call VerifyScreenDump(buf, 'Test_smooth_wrap_4', {})\n\n  call term_sendkeys(buf, \"4\\<C-Y>G\")\n  call VerifyScreenDump(buf, 'Test_smooth_wrap_4', {})\n\n  \" moving cursor up right after the <<< marker - no need to show whole line\n  call term_sendkeys(buf, \"2gj3l2k\")\n  call VerifyScreenDump(buf, 'Test_smooth_wrap_5', {})\n\n  \" moving cursor up where the <<< marker is - whole top line shows\n  call term_sendkeys(buf, \"2j02k\")\n  call VerifyScreenDump(buf, 'Test_smooth_wrap_6', {})\n\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_smoothscroll_wrap_long_line()\n  CheckScreendump\n\n  let lines =<< trim END\n      vim9script\n      setline(1, ['one', 'two', 'Line' .. (' with lots of text'->repeat(30)) .. ' end', 'four'])\n      set smoothscroll scrolloff=0\n      normal 3G10|zt\n  END\n  call writefile(lines, 'XSmoothWrap', 'D')\n  let buf = RunVimInTerminal('-S XSmoothWrap', #{rows: 6, cols: 40})\n  call VerifyScreenDump(buf, 'Test_smooth_long_1', {})\n\n  \" scrolling up, cursor moves screen line down\n  call term_sendkeys(buf, \"\\<C-E>\")\n  call VerifyScreenDump(buf, 'Test_smooth_long_2', {})\n  call term_sendkeys(buf, \"5\\<C-E>\")\n  call VerifyScreenDump(buf, 'Test_smooth_long_3', {})\n\n  \" scrolling down, cursor moves screen line up\n  call term_sendkeys(buf, \"5\\<C-Y>\")\n  call VerifyScreenDump(buf, 'Test_smooth_long_4', {})\n  call term_sendkeys(buf, \"\\<C-Y>\")\n  call VerifyScreenDump(buf, 'Test_smooth_long_5', {})\n\n  \" 'scrolloff' set to 1, scrolling up, cursor moves screen line down\n  call term_sendkeys(buf, \":set scrolloff=1\\<CR>\")\n  call term_sendkeys(buf, \"10|\\<C-E>\")\n  call VerifyScreenDump(buf, 'Test_smooth_long_6', {})\n\n  \" 'scrolloff' set to 1, scrolling down, cursor moves screen line up\n  call term_sendkeys(buf, \"\\<C-E>\")\n  call term_sendkeys(buf, \"gjgj\")\n  call term_sendkeys(buf, \"\\<C-Y>\")\n  call VerifyScreenDump(buf, 'Test_smooth_long_7', {})\n\n  \" 'scrolloff' set to 2, scrolling up, cursor moves screen line down\n  call term_sendkeys(buf, \":set scrolloff=2\\<CR>\")\n  call term_sendkeys(buf, \"10|\\<C-E>\")\n  call VerifyScreenDump(buf, 'Test_smooth_long_8', {})\n\n  \" 'scrolloff' set to 2, scrolling down, cursor moves screen line up\n  call term_sendkeys(buf, \"\\<C-E>\")\n  call term_sendkeys(buf, \"gj\")\n  call term_sendkeys(buf, \"\\<C-Y>\")\n  call VerifyScreenDump(buf, 'Test_smooth_long_9', {})\n\n  \" 'scrolloff' set to 0, move cursor down one line.\n  \" Cursor should move properly, and since this is a really long line, it will\n  \" be put on top of the screen.\n  call term_sendkeys(buf, \":set scrolloff=0\\<CR>\")\n  call term_sendkeys(buf, \"0j\")\n  call VerifyScreenDump(buf, 'Test_smooth_long_10', {})\n\n  \" Test zt/zz/zb that they work properly when a long line is above it\n  call term_sendkeys(buf, \"zt\")\n  call VerifyScreenDump(buf, 'Test_smooth_long_11', {})\n  call term_sendkeys(buf, \"zz\")\n  call VerifyScreenDump(buf, 'Test_smooth_long_12', {})\n  call term_sendkeys(buf, \"zb\")\n  call VerifyScreenDump(buf, 'Test_smooth_long_13', {})\n\n  \" Repeat the step and move the cursor down again.\n  \" This time, use a shorter long line that is barely long enough to span more\n  \" than one window. Note that the cursor is at the bottom this time because\n  \" Vim prefers to do so if we are scrolling a few lines only.\n  call term_sendkeys(buf, \":call setline(1, ['one', 'two', 'Line' .. (' with lots of text'->repeat(10)) .. ' end', 'four'])\\<CR>\")\n  \" Currently visible lines were replaced, test that the lines and cursor\n  \" are correctly displayed.\n  call VerifyScreenDump(buf, 'Test_smooth_long_14', {})\n  call term_sendkeys(buf, \"3Gzt\")\n  call term_sendkeys(buf, \"j\")\n  call VerifyScreenDump(buf, 'Test_smooth_long_15', {})\n\n  \" Repeat the step but this time start it when the line is smooth-scrolled by\n  \" one line. This tests that the offset calculation is still correct and\n  \" still end up scrolling down to the next line with cursor at bottom of\n  \" screen.\n  call term_sendkeys(buf, \"3Gzt\")\n  call term_sendkeys(buf, \"\\<C-E>j\")\n  call VerifyScreenDump(buf, 'Test_smooth_long_16', {})\n\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_smoothscroll_one_long_line()\n  CheckScreendump\n\n  let lines =<< trim END\n      vim9script\n      setline(1, 'with lots of text '->repeat(7))\n      set smoothscroll scrolloff=0\n  END\n  call writefile(lines, 'XSmoothOneLong', 'D')\n  let buf = RunVimInTerminal('-S XSmoothOneLong', #{rows: 6, cols: 40})\n  call VerifyScreenDump(buf, 'Test_smooth_one_long_1', {})\n\n  call term_sendkeys(buf, \"\\<C-E>\")\n  call VerifyScreenDump(buf, 'Test_smooth_one_long_2', {})\n\n  call term_sendkeys(buf, \"0\")\n  call VerifyScreenDump(buf, 'Test_smooth_one_long_1', {})\n\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_smoothscroll_long_line_showbreak()\n  CheckScreendump\n\n  let lines =<< trim END\n      vim9script\n      # a line that spans four screen lines\n      setline(1, 'with lots of text in one line '->repeat(6))\n      set smoothscroll scrolloff=0 showbreak=+++\\ \n  END\n  call writefile(lines, 'XSmoothLongShowbreak', 'D')\n  let buf = RunVimInTerminal('-S XSmoothLongShowbreak', #{rows: 6, cols: 40})\n  call VerifyScreenDump(buf, 'Test_smooth_long_showbreak_1', {})\n\n  call term_sendkeys(buf, \"\\<C-E>\")\n  call VerifyScreenDump(buf, 'Test_smooth_long_showbreak_2', {})\n\n  call term_sendkeys(buf, \"0\")\n  call VerifyScreenDump(buf, 'Test_smooth_long_showbreak_1', {})\n\n  call StopVimInTerminal(buf)\nendfunc\n\n\" Check that 'smoothscroll' marker is drawn over double-width char correctly.\n\" Run with multiple encodings.\nfunc Test_smoothscroll_marker_over_double_width()\n  \" Run this in a separate Vim instance to avoid messing up.\n  let after =<< trim [CODE]\n    scriptencoding utf-8\n    call setline(1, 'a'->repeat(&columns) .. '\u53e3'->repeat(10))\n    setlocal smoothscroll\n    redraw\n    exe \"norm \\<C-E>\"\n    redraw\n    \" Check the chars one by one. Don't check the whole line concatenated.\n    call assert_equal('<', screenstring(1, 1))\n    call assert_equal('<', screenstring(1, 2))\n    call assert_equal('<', screenstring(1, 3))\n    call assert_equal(' ', screenstring(1, 4))\n    call assert_equal('\u53e3', screenstring(1, 5))\n    call assert_equal('\u53e3', screenstring(1, 7))\n    call assert_equal('\u53e3', screenstring(1, 9))\n    call assert_equal('\u53e3', screenstring(1, 11))\n    call assert_equal('\u53e3', screenstring(1, 13))\n    call assert_equal('\u53e3', screenstring(1, 15))\n    call writefile(v:errors, 'Xresult')\n    qall!\n  [CODE]\n\n  let encodings = ['utf-8', 'cp932', 'cp936', 'cp949', 'cp950']\n  if !has('win32')\n    let encodings += ['euc-jp']\n  endif\n  for enc in encodings\n    let msg = 'enc=' .. enc\n    if RunVim([], after, $'--clean --cmd \"set encoding={enc}\"')\n      call assert_equal([], readfile('Xresult'), msg)\n    endif\n    call delete('Xresult')\n  endfor\nendfunc\n\n\" Same as the test above, but check the text actually shown on screen.\n\" Only run with UTF-8 encoding.\nfunc Test_smoothscroll_marker_over_double_width_dump()\n  CheckScreendump\n\n  let lines =<< trim END\n    call setline(1, 'a'->repeat(&columns) .. '\u53e3'->repeat(10))\n    setlocal smoothscroll\n  END\n  call writefile(lines, 'XSmoothMarkerOverDoubleWidth', 'D')\n  let buf = RunVimInTerminal('-S XSmoothMarkerOverDoubleWidth', #{rows: 6, cols: 40})\n  call VerifyScreenDump(buf, 'Test_smooth_marker_over_double_width_1', {})\n\n  call term_sendkeys(buf, \"\\<C-E>\")\n  call VerifyScreenDump(buf, 'Test_smooth_marker_over_double_width_2', {})\n\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc s:check_col_calc(win_col, win_line, buf_col)\n  call assert_equal(a:win_col, wincol())\n  call assert_equal(a:win_line, winline())\n  call assert_equal(a:buf_col, col('.'))\nendfunc\n\n\" Test that if the current cursor is on a smooth scrolled line, we correctly\n\" reposition it. Also check that we don't miscalculate the values by checking\n\" the consistency between wincol() and col('.') as they are calculated\n\" separately in code.\nfunc Test_smoothscroll_cursor_position()\n  call NewWindow(10, 20)\n  setl smoothscroll wrap\n  call setline(1, \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n\n  call s:check_col_calc(1, 1, 1)\n  exe \"normal \\<C-E>\"\n\n  \" Move down another line to avoid blocking the <<< display\n  call s:check_col_calc(1, 2, 41)\n  exe \"normal \\<C-Y>\"\n  call s:check_col_calc(1, 3, 41)\n\n  \" Test \"g0/g<Home>\"\n  exe \"normal gg\\<C-E>\"\n  norm $gkg0\n  call s:check_col_calc(1, 2, 21)\n\n  \" Test moving the cursor behind the <<< display with 'virtualedit'\n  set virtualedit=all\n  exe \"normal \\<C-E>3lgkh\"\n  call s:check_col_calc(3, 2, 23)\n  set virtualedit&\n\n  normal gg3l\n  exe \"normal \\<C-E>\"\n\n  \" Move down only 1 line when we are out of the range of the <<< display\n  call s:check_col_calc(4, 1, 24)\n  exe \"normal \\<C-Y>\"\n  call s:check_col_calc(4, 2, 24)\n  normal ggg$\n  exe \"normal \\<C-E>\"\n  call s:check_col_calc(20, 1, 40)\n  exe \"normal \\<C-Y>\"\n  call s:check_col_calc(20, 2, 40)\n  normal gg\n\n  \" Test number, where we have indented lines\n  setl number\n  call s:check_col_calc(5, 1, 1)\n  exe \"normal \\<C-E>\"\n\n  \" Move down only 1 line when the <<< display is on the number column\n  call s:check_col_calc(5, 1, 17)\n  exe \"normal \\<C-Y>\"\n  call s:check_col_calc(5, 2, 17)\n  normal ggg$\n  exe \"normal \\<C-E>\"\n  call s:check_col_calc(20, 1, 32)\n  exe \"normal \\<C-Y>\"\n  call s:check_col_calc(20, 2, 32)\n  normal gg\n\n  setl numberwidth=1\n\n  \" Move down another line when numberwidth is too short to cover the whole\n  \" <<< display\n  call s:check_col_calc(3, 1, 1)\n  exe \"normal \\<C-E>\"\n  call s:check_col_calc(3, 2, 37)\n  exe \"normal \\<C-Y>\"\n  call s:check_col_calc(3, 3, 37)\n  normal ggl\n\n  \" Only move 1 line down when we are just past the <<< display\n  call s:check_col_calc(4, 1, 2)\n  exe \"normal \\<C-E>\"\n  call s:check_col_calc(4, 1, 20)\n  exe \"normal \\<C-Y>\"\n  call s:check_col_calc(4, 2, 20)\n  normal gg\n  setl numberwidth&\n\n  \" Test number + showbreak, so test that the additional indentation works\n  setl number showbreak=+++\n  call s:check_col_calc(5, 1, 1)\n  exe \"normal \\<C-E>\"\n  call s:check_col_calc(8, 1, 17)\n  exe \"normal \\<C-Y>\"\n  call s:check_col_calc(8, 2, 17)\n  normal gg\n\n  \" Test number + cpo+=n mode, where wrapped lines aren't indented\n  setl number cpo+=n showbreak=\n  call s:check_col_calc(5, 1, 1)\n  exe \"normal \\<C-E>\"\n  call s:check_col_calc(1, 2, 37)\n  exe \"normal \\<C-Y>\"\n  call s:check_col_calc(1, 3, 37)\n  normal gg\n\n  \" Test list + listchars \"precedes\", where there is always 1 overlap\n  \" regardless of number and cpo-=n.\n  setl number list listchars=precedes:< cpo-=n\n  call s:check_col_calc(5, 1, 1)\n  exe \"normal 3|\\<C-E>h\"\n  call s:check_col_calc(6, 1, 18)\n  norm h\n  call s:check_col_calc(5, 2, 17)\n  normal gg\n\n  bwipe!\nendfunc\n\nfunc Test_smoothscroll_cursor_scrolloff()\n  call NewWindow(10, 20)\n  setl smoothscroll wrap\n  setl scrolloff=3\n\n  \" 120 chars are 6 screen lines\n  call setline(1, \"abcdefghijklmnopqrstABCDEFGHIJKLMNOPQRSTabcdefghijklmnopqrstABCDEFGHIJKLMNOPQRSTabcdefghijklmnopqrstABCDEFGHIJKLMNOPQRST\")\n  call setline(2, \"below\")\n\n  call s:check_col_calc(1, 1, 1)\n\n  \" CTRL-E shows \"<<<DEFG...\", cursor move four lines down\n  exe \"normal \\<C-E>\"\n  call s:check_col_calc(1, 4, 81)\n\n  \" cursor on start of second line, \"gk\" moves into first line, skipcol doesn't\n  \" change\n  exe \"normal G0gk\"\n  call s:check_col_calc(1, 5, 101)\n\n  \" move cursor left one window width worth, scrolls one screen line\n  exe \"normal 20h\"\n  call s:check_col_calc(1, 5, 81)\n\n  \" move cursor left one window width worth, scrolls one screen line\n  exe \"normal 20h\"\n  call s:check_col_calc(1, 4, 61)\n\n  \" cursor on last line, \"gk\" should not cause a scroll\n  set scrolloff=0\n  normal G0\n  call s:check_col_calc(1, 7, 1)\n  normal gk\n  call s:check_col_calc(1, 6, 101)\n\n  bwipe!\nendfunc\n\n\n\" Test that mouse picking is still accurate when we have smooth scrolled lines\nfunc Test_smoothscroll_mouse_pos()\n  CheckNotGui\n  CheckUnix\n\n  let save_mouse = &mouse\n  let save_term = &term\n  let save_ttymouse = &ttymouse\n  set mouse=a term=xterm ttymouse=xterm2\n\n  call NewWindow(10, 20)\n  setl smoothscroll wrap\n  \" First line will wrap to 3 physical lines. 2nd/3rd lines are short lines.\n  call setline(1, [\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\", \"line 2\", \"line 3\"])\n\n  func s:check_mouse_click(row, col, buf_row, buf_col)\n    call MouseLeftClick(a:row, a:col)\n\n    call assert_equal(a:col, wincol())\n    call assert_equal(a:row, winline())\n    call assert_equal(a:buf_row, line('.'))\n    call assert_equal(a:buf_col, col('.'))\n  endfunc\n\n  \" Check that clicking without scroll works first.\n  call s:check_mouse_click(3, 5, 1, 45)\n  call s:check_mouse_click(4, 1, 2, 1)\n  call s:check_mouse_click(4, 6, 2, 6)\n  call s:check_mouse_click(5, 1, 3, 1)\n  call s:check_mouse_click(5, 6, 3, 6)\n\n  \" Smooth scroll, and checks that this didn't mess up mouse clicking\n  exe \"normal \\<C-E>\"\n  call s:check_mouse_click(2, 5, 1, 45)\n  call s:check_mouse_click(3, 1, 2, 1)\n  call s:check_mouse_click(3, 6, 2, 6)\n  call s:check_mouse_click(4, 1, 3, 1)\n  call s:check_mouse_click(4, 6, 3, 6)\n\n  exe \"normal \\<C-E>\"\n  call s:check_mouse_click(1, 5, 1, 45)\n  call s:check_mouse_click(2, 1, 2, 1)\n  call s:check_mouse_click(2, 6, 2, 6)\n  call s:check_mouse_click(3, 1, 3, 1)\n  call s:check_mouse_click(3, 6, 3, 6)\n\n  \" Make a new first line 11 physical lines tall so it's taller than window\n  \" height, to test overflow calculations with really long lines wrapping.\n  normal gg\n  call setline(1, \"12345678901234567890\"->repeat(11))\n  exe \"normal 6\\<C-E>\"\n  call s:check_mouse_click(5, 1, 1, 201)\n  call s:check_mouse_click(6, 1, 2, 1)\n  call s:check_mouse_click(7, 1, 3, 1)\n\n  let &mouse = save_mouse\n  let &term = save_term\n  let &ttymouse = save_ttymouse\nendfunc\n\n\" this was dividing by zero\nfunc Test_smoothscroll_zero_width()\n  CheckScreendump\n\n  let lines =<< trim END\n      winsize 0 0\n      vsplit\n      vsplit\n      vsplit\n      vsplit\n      vsplit\n      sil norm \u0017\u000e\u0017H\n      set wrap\n      set smoothscroll\n      set number\n  END\n  call writefile(lines, 'XSmoothScrollZero', 'D')\n  let buf = RunVimInTerminal('-u NONE -i NONE -n -m -X -Z -e -s -S XSmoothScrollZero', #{rows: 6, cols: 60, wait_for_ruler: 0})\n  call VerifyScreenDump(buf, 'Test_smoothscroll_zero_1', {})\n\n  call term_sendkeys(buf, \":sil norm \\<C-V>\\<C-W>\\<C-V>\\<C-N>\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_smoothscroll_zero_2', {})\n\n  call StopVimInTerminal(buf)\nendfunc\n\n\" this was unnecessarily inserting lines\nfunc Test_smoothscroll_ins_lines()\n  CheckScreendump\n\n  let lines =<< trim END\n      set wrap\n      set smoothscroll\n      set scrolloff=0\n      set conceallevel=2\n      call setline(1, [\n        \\'line one' .. 'with lots of text in one line '->repeat(2),\n        \\'line two',\n        \\'line three',\n        \\'line four',\n        \\'line five'\n      \\])\n  END\n  call writefile(lines, 'XSmoothScrollInsLines', 'D')\n  let buf = RunVimInTerminal('-S XSmoothScrollInsLines', #{rows: 6, cols: 40})\n\n  call term_sendkeys(buf, \"\\<C-E>gjgk\")\n  call VerifyScreenDump(buf, 'Test_smooth_ins_lines', {})\n\n  call StopVimInTerminal(buf)\nendfunc\n\n\" this placed the cursor in the command line\nfunc Test_smoothscroll_cursormoved_line()\n  CheckScreendump\n\n  let lines =<< trim END\n      set smoothscroll\n      call setline(1, [\n        \\'',\n        \\'_'->repeat(&lines * &columns),\n        \\(('_')->repeat(&columns - 2) .. 'xxx')->repeat(2)\n      \\])\n      autocmd CursorMoved * eval [line('w0'), line('w$')]\n      call search('xxx')\n  END\n  call writefile(lines, 'XSmoothCursorMovedLine', 'D')\n  let buf = RunVimInTerminal('-S XSmoothCursorMovedLine', #{rows: 6})\n\n  call VerifyScreenDump(buf, 'Test_smooth_cursormoved_line', {})\n\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_smoothscroll_eob()\n  CheckScreendump\n\n  let lines =<< trim END\n      set smoothscroll\n      call setline(1, ['']->repeat(100))\n      norm G\n  END\n  call writefile(lines, 'XSmoothEob', 'D')\n  let buf = RunVimInTerminal('-S XSmoothEob', #{rows: 10})\n\n  \" does not scroll halfway when scrolling to end of buffer\n  call VerifyScreenDump(buf, 'Test_smooth_eob_1', {})\n\n  \" cursor is not placed below window\n  call term_sendkeys(buf, \":call setline(92, 'a'->repeat(100))\\<CR>\\<C-B>G\")\n  call VerifyScreenDump(buf, 'Test_smooth_eob_2', {})\n\n  call StopVimInTerminal(buf)\nendfunc\n\n\" skipcol should not reset when doing incremental search on the same word\nfunc Test_smoothscroll_incsearch()\n  CheckScreendump\n\n  let lines =<< trim END\n      set smoothscroll number scrolloff=0 incsearch\n      call setline(1, repeat([''], 20))\n      call setline(11, repeat('a', 100))\n      call setline(14, 'bbbb')\n  END\n  call writefile(lines, 'XSmoothIncsearch', 'D')\n  let buf = RunVimInTerminal('-S XSmoothIncsearch', #{rows: 8, cols: 40})\n\n  call term_sendkeys(buf, \"/b\")\n  call VerifyScreenDump(buf, 'Test_smooth_incsearch_1', {})\n  call term_sendkeys(buf, \"b\")\n  call VerifyScreenDump(buf, 'Test_smooth_incsearch_2', {})\n  call term_sendkeys(buf, \"b\")\n  call VerifyScreenDump(buf, 'Test_smooth_incsearch_3', {})\n  call term_sendkeys(buf, \"b\")\n  call VerifyScreenDump(buf, 'Test_smooth_incsearch_4', {})\n  call term_sendkeys(buf, \"\\<CR>\")\n\n  call StopVimInTerminal(buf)\nendfunc\n\n\" Test scrolling multiple lines and stopping at non-zero skipcol.\nfunc Test_smoothscroll_multi_skipcol()\n  CheckScreendump\n\n  let lines =<< trim END\n      setlocal cursorline scrolloff=0 smoothscroll\n      call setline(1, repeat([''], 8))\n      call setline(3, repeat('a', 50))\n      call setline(4, repeat('a', 50))\n      call setline(7, 'bbb')\n      call setline(8, 'ccc')\n      redraw\n  END\n  call writefile(lines, 'XSmoothMultiSkipcol', 'D')\n  let buf = RunVimInTerminal('-S XSmoothMultiSkipcol', #{rows: 10, cols: 40})\n  call VerifyScreenDump(buf, 'Test_smooth_multi_skipcol_1', {})\n\n  call term_sendkeys(buf, \"3\\<C-E>\")\n  call VerifyScreenDump(buf, 'Test_smooth_multi_skipcol_2', {})\n\n  call term_sendkeys(buf, \"2\\<C-E>\")\n  call VerifyScreenDump(buf, 'Test_smooth_multi_skipcol_3', {})\n\n  call StopVimInTerminal(buf)\nendfunc\n\n\" this was dividing by zero bug in scroll_cursor_bot\nfunc Test_smoothscroll_zero_width_scroll_cursor_bot()\n  CheckScreendump\n\n  let lines =<< trim END\n      silent normal yy\n      silent normal 19p\n      set cpoptions+=n\n      vsplit\n      vertical resize 0\n      set foldcolumn=1\n      set number\n      set smoothscroll\n      silent normal 20G\n  END\n  call writefile(lines, 'XSmoothScrollZeroBot', 'D')\n  let buf = RunVimInTerminal('-u NONE -S XSmoothScrollZeroBot', #{rows: 19})\n  call VerifyScreenDump(buf, 'Test_smoothscroll_zero_bot', {})\n\n  call StopVimInTerminal(buf)\nendfunc\n\n\" scroll_cursor_top() should reset skipcol when it changes topline\nfunc Test_smoothscroll_cursor_top()\n  CheckScreendump\n\n  let lines =<< trim END\n      set smoothscroll scrolloff=2\n      new | 11resize | wincmd j\n      call setline(1, ['line1', 'line2', 'line3'->repeat(20), 'line4'])\n      exe \"norm G3\\<C-E>k\"\n  END\n  call writefile(lines, 'XSmoothScrollCursorTop', 'D')\n  let buf = RunVimInTerminal('-u NONE -S XSmoothScrollCursorTop', #{rows: 12, cols:40})\n  call VerifyScreenDump(buf, 'Test_smoothscroll_cursor_top', {})\n\n  call StopVimInTerminal(buf)\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion != NULL)\n\treturn;\n\n#ifdef BUILD_DATE\n    char *date_time = BUILD_DATE;\n#else\n    char *date_time = __DATE__ \" \" __TIME__;\n#endif\n    char *msg = _(\"%s (%s, compiled %s)\");\n    size_t len = strlen(msg)\n\t+ strlen(VIM_VERSION_LONG_ONLY)\n\t+ strlen(VIM_VERSION_DATE_ONLY)\n\t+ strlen(date_time);\n\n    longVersion = alloc(len);\n    if (longVersion == NULL)\n\tlongVersion = VIM_VERSION_LONG;\n    else\n\tvim_snprintf(longVersion, len, msg,\n\t\tVIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n\t\"+cmdline_info\",\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n\t\"+float\",\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n#  ifdef DYNAMIC_PYTHON3_STABLE_ABI\n\t\"+python3/dyn-stable\",\n#  else\n\t\"+python3/dyn\",\n#  endif\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n# ifdef FEAT_XATTR\n\t\"+xattr\",\n# else\n\t\"-xattr\",\n# endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n/*\n * move.c: Functions for moving the cursor and scrolling text.\n *\n * There are two ways to move the cursor:\n * 1. Move the cursor directly, the text is scrolled to keep the cursor in the\n *    window.\n * 2. Scroll the text, the cursor is moved into the text visible in the\n *    window.\n * The 'scrolloff' option makes this a bit complicated.\n */\n\n#include \"vim.h\"\n\nstatic int scrolljump_value(void);\nstatic int check_top_offset(void);\nstatic void curs_rows(win_T *wp);\n\ntypedef struct\n{\n    linenr_T\t    lnum;\t// line number\n#ifdef FEAT_DIFF\n    int\t\t    fill;\t// filler lines\n#endif\n    int\t\t    height;\t// height of added line\n} lineoff_T;\n\nstatic void topline_back(lineoff_T *lp);\nstatic void botline_forw(lineoff_T *lp);\n\n/*\n * Get the number of screen lines skipped with \"wp->w_skipcol\".\n */\n    int\nadjust_plines_for_skipcol(win_T *wp)\n{\n    if (wp->w_skipcol == 0)\n\treturn 0;\n\n    int width = wp->w_width - win_col_off(wp);\n    int w2 = width + win_col_off2(wp);\n    if (wp->w_skipcol >= width && w2 > 0)\n\treturn (wp->w_skipcol - width) / w2 + 1;\n\n    return 0;\n}\n\n/*\n * Return how many lines \"lnum\" will take on the screen, taking into account\n * whether it is the first line, whether w_skipcol is non-zero and limiting to\n * the window height.\n */\n    static int\nplines_correct_topline(win_T *wp, linenr_T lnum)\n{\n    int n;\n#ifdef FEAT_DIFF\n    if (lnum == wp->w_topline)\n\tn = plines_win_nofill(wp, lnum, FALSE) + wp->w_topfill;\n    else\n#endif\n\tn = plines_win(wp, lnum, FALSE);\n    if (lnum == wp->w_topline)\n\tn -= adjust_plines_for_skipcol(wp);\n    if (n > wp->w_height)\n\tn = wp->w_height;\n    return n;\n}\n\n/*\n * Compute wp->w_botline for the current wp->w_topline.  Can be called after\n * wp->w_topline changed.\n */\n    static void\ncomp_botline(win_T *wp)\n{\n    int\t\tn;\n    linenr_T\tlnum;\n    int\t\tdone;\n#ifdef FEAT_FOLDING\n    linenr_T    last;\n    int\t\tfolded;\n#endif\n\n    /*\n     * If w_cline_row is valid, start there.\n     * Otherwise have to start at w_topline.\n     */\n    check_cursor_moved(wp);\n    if (wp->w_valid & VALID_CROW)\n    {\n\tlnum = wp->w_cursor.lnum;\n\tdone = wp->w_cline_row;\n    }\n    else\n    {\n\tlnum = wp->w_topline;\n\tdone = 0;\n    }\n\n    for ( ; lnum <= wp->w_buffer->b_ml.ml_line_count; ++lnum)\n    {\n#ifdef FEAT_FOLDING\n\tlast = lnum;\n\tfolded = FALSE;\n\tif (hasFoldingWin(wp, lnum, NULL, &last, TRUE, NULL))\n\t{\n\t    n = 1;\n\t    folded = TRUE;\n\t}\n\telse\n#endif\n\t{\n\t    n = plines_correct_topline(wp, lnum);\n\t}\n\tif (\n#ifdef FEAT_FOLDING\n\t\tlnum <= wp->w_cursor.lnum && last >= wp->w_cursor.lnum\n#else\n\t\tlnum == wp->w_cursor.lnum\n#endif\n\t   )\n\t{\n\t    wp->w_cline_row = done;\n\t    wp->w_cline_height = n;\n#ifdef FEAT_FOLDING\n\t    wp->w_cline_folded = folded;\n#endif\n\t    redraw_for_cursorline(wp);\n\t    wp->w_valid |= (VALID_CROW|VALID_CHEIGHT);\n\t}\n\tif (done + n > wp->w_height)\n\t    break;\n\tdone += n;\n#ifdef FEAT_FOLDING\n\tlnum = last;\n#endif\n    }\n\n    // wp->w_botline is the line that is just below the window\n    wp->w_botline = lnum;\n    wp->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;\n\n    set_empty_rows(wp, done);\n}\n\n/*\n * Redraw when w_cline_row changes and 'relativenumber' or 'cursorline' is\n * set.\n */\n    void\nredraw_for_cursorline(win_T *wp)\n{\n    if ((wp->w_p_rnu\n#ifdef FEAT_SYN_HL\n\t\t|| wp->w_p_cul\n#endif\n\t\t)\n\t    && (wp->w_valid & VALID_CROW) == 0\n\t    && !pum_visible())\n    {\n\t// win_line() will redraw the number column and cursorline only.\n\tredraw_win_later(wp, UPD_VALID);\n    }\n}\n\n#ifdef FEAT_SYN_HL\n/*\n * Redraw when w_virtcol changes and 'cursorcolumn' is set or 'cursorlineopt'\n * contains \"screenline\".\n */\n    static void\nredraw_for_cursorcolumn(win_T *wp)\n{\n    if ((wp->w_valid & VALID_VIRTCOL) == 0 && !pum_visible())\n    {\n\t// When 'cursorcolumn' is set need to redraw with UPD_SOME_VALID.\n\tif (wp->w_p_cuc)\n\t    redraw_win_later(wp, UPD_SOME_VALID);\n\t// When 'cursorlineopt' contains \"screenline\" need to redraw with\n\t// UPD_VALID.\n\telse if (wp->w_p_cul && (wp->w_p_culopt_flags & CULOPT_SCRLINE))\n\t    redraw_win_later(wp, UPD_VALID);\n    }\n}\n#endif\n\n/*\n * Calculates how much the 'listchars' \"precedes\" or 'smoothscroll' \"<<<\"\n * marker overlaps with buffer text for window \"wp\".\n * Parameter \"extra2\" should be the padding on the 2nd line, not the first\n * line.\n * Returns the number of columns of overlap with buffer text, excluding the\n * extra padding on the ledge.\n */\n     int\nsms_marker_overlap(win_T *wp, int extra2)\n{\n#if defined(FEAT_LINEBREAK)\n    // There is no marker overlap when in showbreak mode, thus no need to\n    // account for it.  See wlv_screen_line().\n    if (*get_showbreak_value(wp) != NUL)\n\treturn 0;\n#endif\n    // Overlap when 'list' and 'listchars' \"precedes\" are set is 1.\n    if (wp->w_p_list && wp->w_lcs_chars.prec)\n\treturn 1;\n\n    return extra2 > 3 ? 0 : 3 - extra2;\n}\n\n/*\n * Calculates the skipcol offset for window \"wp\" given how many\n * physical lines we want to scroll down.\n */\n    static int\nskipcol_from_plines(win_T *wp, int plines_off)\n{\n    int width1 = wp->w_width - win_col_off(wp);\n\n    int skipcol = 0;\n    if (plines_off > 0)\n\tskipcol += width1;\n    if (plines_off > 1)\n\tskipcol += (width1 + win_col_off2(wp)) * (plines_off - 1);\n    return skipcol;\n}\n\n/*\n * Set curwin->w_skipcol to zero and redraw later if needed.\n */\n    static void\nreset_skipcol(void)\n{\n    if (curwin->w_skipcol == 0)\n\treturn;\n\n    curwin->w_skipcol = 0;\n\n    // Should use the least expensive way that displays all that changed.\n    // UPD_NOT_VALID is too expensive, UPD_REDRAW_TOP does not redraw\n    // enough when the top line gets another screen line.\n    redraw_later(UPD_SOME_VALID);\n}\n\n/*\n * Update curwin->w_topline and redraw if necessary.\n * Used to update the screen before printing a message.\n */\n    void\nupdate_topline_redraw(void)\n{\n    update_topline();\n    if (must_redraw)\n\tupdate_screen(0);\n}\n\n/*\n * Update curwin->w_topline to move the cursor onto the screen.\n */\n    void\nupdate_topline(void)\n{\n    long\tline_count;\n    int\t\thalfheight;\n    int\t\tn;\n#ifdef FEAT_FOLDING\n    linenr_T\tlnum;\n#endif\n    int\t\tcheck_topline = FALSE;\n    int\t\tcheck_botline = FALSE;\n    long\t*so_ptr = curwin->w_p_so >= 0 ? &curwin->w_p_so : &p_so;\n    int\t\tsave_so = *so_ptr;\n\n    // Cursor is updated instead when this is TRUE for 'splitkeep'.\n    if (skip_update_topline)\n\treturn;\n\n    // If there is no valid screen and when the window height is zero just use\n    // the cursor line.\n    if (!screen_valid(TRUE) || curwin->w_height == 0)\n    {\n\tcheck_cursor_lnum();\n\tcurwin->w_topline = curwin->w_cursor.lnum;\n\tcurwin->w_botline = curwin->w_topline;\n\tcurwin->w_scbind_pos = 1;\n\treturn;\n    }\n\n    check_cursor_moved(curwin);\n    if (curwin->w_valid & VALID_TOPLINE)\n\treturn;\n\n    // When dragging with the mouse, don't scroll that quickly\n    if (mouse_dragging > 0)\n\t*so_ptr = mouse_dragging - 1;\n\n    linenr_T old_topline = curwin->w_topline;\n#ifdef FEAT_DIFF\n    int old_topfill = curwin->w_topfill;\n#endif\n\n    /*\n     * If the buffer is empty, always set topline to 1.\n     */\n    if (BUFEMPTY())\t\t// special case - file is empty\n    {\n\tif (curwin->w_topline != 1)\n\t    redraw_later(UPD_NOT_VALID);\n\tcurwin->w_topline = 1;\n\tcurwin->w_botline = 2;\n\tcurwin->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;\n\tcurwin->w_scbind_pos = 1;\n    }\n\n    /*\n     * If the cursor is above or near the top of the window, scroll the window\n     * to show the line the cursor is in, with 'scrolloff' context.\n     */\n    else\n    {\n\tif (curwin->w_topline > 1 || curwin->w_skipcol > 0)\n\t{\n\t    // If the cursor is above topline, scrolling is always needed.\n\t    // If the cursor is far below topline and there is no folding,\n\t    // scrolling down is never needed.\n\t    if (curwin->w_cursor.lnum < curwin->w_topline)\n\t\tcheck_topline = TRUE;\n\t    else if (check_top_offset())\n\t\tcheck_topline = TRUE;\n\t    else if (curwin->w_skipcol > 0\n\t\t\t\t && curwin->w_cursor.lnum == curwin->w_topline)\n\t    {\n\t\tcolnr_T vcol;\n\n\t\t// Check that the cursor position is visible.  Add columns for\n\t\t// the marker displayed in the top-left if needed.\n\t\tgetvvcol(curwin, &curwin->w_cursor, &vcol, NULL, NULL);\n\t\tint overlap = sms_marker_overlap(curwin, curwin_col_off()\n\t\t\t\t\t\t\t- curwin_col_off2());\n\t\tif (curwin->w_skipcol + overlap > vcol)\n\t\t    check_topline = TRUE;\n\t    }\n\t}\n#ifdef FEAT_DIFF\n\t    // Check if there are more filler lines than allowed.\n\tif (!check_topline && curwin->w_topfill > diff_check_fill(curwin,\n\t\t\t\t\t\t\t   curwin->w_topline))\n\t    check_topline = TRUE;\n#endif\n\n\tif (check_topline)\n\t{\n\t    halfheight = curwin->w_height / 2 - 1;\n\t    if (halfheight < 2)\n\t\thalfheight = 2;\n\n#ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\t// Count the number of logical lines between the cursor and\n\t\t// topline + scrolloff (approximation of how much will be\n\t\t// scrolled).\n\t\tn = 0;\n\t\tfor (lnum = curwin->w_cursor.lnum;\n\t\t\t\t    lnum < curwin->w_topline + *so_ptr; ++lnum)\n\t\t{\n\t\t    ++n;\n\t\t    // stop at end of file or when we know we are far off\n\t\t    if (lnum >= curbuf->b_ml.ml_line_count || n >= halfheight)\n\t\t\tbreak;\n\t\t    (void)hasFolding(lnum, NULL, &lnum);\n\t\t}\n\t    }\n\t    else\n#endif\n\t\tn = curwin->w_topline + *so_ptr - curwin->w_cursor.lnum;\n\n\t    // If we weren't very close to begin with, we scroll to put the\n\t    // cursor in the middle of the window.  Otherwise put the cursor\n\t    // near the top of the window.\n\t    if (n >= halfheight)\n\t\tscroll_cursor_halfway(FALSE, FALSE);\n\t    else\n\t    {\n\t\tscroll_cursor_top(scrolljump_value(), FALSE);\n\t\tcheck_botline = TRUE;\n\t    }\n\t}\n\n\telse\n\t{\n#ifdef FEAT_FOLDING\n\t    // Make sure topline is the first line of a fold.\n\t    (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n\t    check_botline = TRUE;\n\t}\n    }\n\n    /*\n     * If the cursor is below the bottom of the window, scroll the window\n     * to put the cursor on the window.\n     * When w_botline is invalid, recompute it first, to avoid a redraw later.\n     * If w_botline was approximated, we might need a redraw later in a few\n     * cases, but we don't want to spend (a lot of) time recomputing w_botline\n     * for every small change.\n     */\n    if (check_botline)\n    {\n\tif (!(curwin->w_valid & VALID_BOTLINE_AP))\n\t    validate_botline();\n\n\tif (curwin->w_botline <= curbuf->b_ml.ml_line_count)\n\t{\n\t    if (curwin->w_cursor.lnum < curwin->w_botline)\n\t    {\n\t      if (((long)curwin->w_cursor.lnum\n\t\t\t\t\t   >= (long)curwin->w_botline - *so_ptr\n#ifdef FEAT_FOLDING\n\t\t\t|| hasAnyFolding(curwin)\n#endif\n\t\t\t))\n\t      {\n\t\tlineoff_T\tloff;\n\n\t\t// Cursor is (a few lines) above botline, check if there are\n\t\t// 'scrolloff' window lines below the cursor.  If not, need to\n\t\t// scroll.\n\t\tn = curwin->w_empty_rows;\n\t\tloff.lnum = curwin->w_cursor.lnum;\n#ifdef FEAT_FOLDING\n\t\t// In a fold go to its last line.\n\t\t(void)hasFolding(loff.lnum, NULL, &loff.lnum);\n#endif\n#ifdef FEAT_DIFF\n\t\tloff.fill = 0;\n\t\tn += curwin->w_filler_rows;\n#endif\n\t\tloff.height = 0;\n\t\twhile (loff.lnum < curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t\t&& (loff.lnum + 1 < curwin->w_botline || loff.fill == 0)\n#endif\n\t\t\t)\n\t\t{\n\t\t    n += loff.height;\n\t\t    if (n >= *so_ptr)\n\t\t\tbreak;\n\t\t    botline_forw(&loff);\n\t\t}\n\t\tif (n >= *so_ptr)\n\t\t    // sufficient context, no need to scroll\n\t\t    check_botline = FALSE;\n\t      }\n\t      else\n\t\t  // sufficient context, no need to scroll\n\t\t  check_botline = FALSE;\n\t    }\n\t    if (check_botline)\n\t    {\n#ifdef FEAT_FOLDING\n\t\tif (hasAnyFolding(curwin))\n\t\t{\n\t\t    // Count the number of logical lines between the cursor and\n\t\t    // botline - scrolloff (approximation of how much will be\n\t\t    // scrolled).\n\t\t    line_count = 0;\n\t\t    for (lnum = curwin->w_cursor.lnum;\n\t\t\t\t   lnum >= curwin->w_botline - *so_ptr; --lnum)\n\t\t    {\n\t\t\t++line_count;\n\t\t\t// stop at end of file or when we know we are far off\n\t\t\tif (lnum <= 0 || line_count > curwin->w_height + 1)\n\t\t\t    break;\n\t\t\t(void)hasFolding(lnum, &lnum, NULL);\n\t\t    }\n\t\t}\n\t\telse\n#endif\n\t\t    line_count = curwin->w_cursor.lnum - curwin->w_botline\n\t\t\t\t\t\t\t\t + 1 + *so_ptr;\n\t\tif (line_count <= curwin->w_height + 1)\n\t\t    scroll_cursor_bot(scrolljump_value(), FALSE);\n\t\telse\n\t\t    scroll_cursor_halfway(FALSE, FALSE);\n\t    }\n\t}\n    }\n    curwin->w_valid |= VALID_TOPLINE;\n\n    /*\n     * Need to redraw when topline changed.\n     */\n    if (curwin->w_topline != old_topline\n#ifdef FEAT_DIFF\n\t    || curwin->w_topfill != old_topfill\n#endif\n\t    )\n    {\n\tdollar_vcol = -1;\n\tredraw_later(UPD_VALID);\n\n\t// When 'smoothscroll' is not set, should reset w_skipcol.\n\tif (!curwin->w_p_sms)\n\t    reset_skipcol();\n\telse if (curwin->w_skipcol != 0)\n\t    redraw_later(UPD_SOME_VALID);\n\n\t// May need to set w_skipcol when cursor in w_topline.\n\tif (curwin->w_cursor.lnum == curwin->w_topline)\n\t    validate_cursor();\n    }\n\n    *so_ptr = save_so;\n}\n\n/*\n * Return the scrolljump value to use for the current window.\n * When 'scrolljump' is positive use it as-is.\n * When 'scrolljump' is negative use it as a percentage of the window height.\n */\n    static int\nscrolljump_value(void)\n{\n    if (p_sj >= 0)\n\treturn (int)p_sj;\n    return (curwin->w_height * -p_sj) / 100;\n}\n\n/*\n * Return TRUE when there are not 'scrolloff' lines above the cursor for the\n * current window.\n */\n    static int\ncheck_top_offset(void)\n{\n    lineoff_T\tloff;\n    int\t\tn;\n    long\tso = get_scrolloff_value();\n\n    if (curwin->w_cursor.lnum < curwin->w_topline + so\n#ifdef FEAT_FOLDING\n\t\t    || hasAnyFolding(curwin)\n#endif\n\t    )\n    {\n\tloff.lnum = curwin->w_cursor.lnum;\n#ifdef FEAT_DIFF\n\tloff.fill = 0;\n\tn = curwin->w_topfill;\t    // always have this context\n#else\n\tn = 0;\n#endif\n\t// Count the visible screen lines above the cursor line.\n\twhile (n < so)\n\t{\n\t    topline_back(&loff);\n\t    // Stop when included a line above the window.\n\t    if (loff.lnum < curwin->w_topline\n#ifdef FEAT_DIFF\n\t\t    || (loff.lnum == curwin->w_topline && loff.fill > 0)\n#endif\n\t\t    )\n\t\tbreak;\n\t    n += loff.height;\n\t}\n\tif (n < so)\n\t    return TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Update w_curswant.\n */\n    void\nupdate_curswant_force(void)\n{\n    validate_virtcol();\n    curwin->w_curswant = curwin->w_virtcol\n#ifdef FEAT_PROP_POPUP\n\t- curwin->w_virtcol_first_char\n#endif\n\t;\n    curwin->w_set_curswant = FALSE;\n}\n\n/*\n * Update w_curswant if w_set_curswant is set.\n */\n    void\nupdate_curswant(void)\n{\n    if (curwin->w_set_curswant)\n\tupdate_curswant_force();\n}\n\n/*\n * Check if the cursor has moved.  Set the w_valid flag accordingly.\n */\n    void\ncheck_cursor_moved(win_T *wp)\n{\n    if (wp->w_cursor.lnum != wp->w_valid_cursor.lnum)\n    {\n\twp->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL\n\t\t\t\t      |VALID_CHEIGHT|VALID_CROW|VALID_TOPLINE\n\t\t\t\t      |VALID_BOTLINE|VALID_BOTLINE_AP);\n\twp->w_valid_cursor = wp->w_cursor;\n\twp->w_valid_leftcol = wp->w_leftcol;\n\twp->w_valid_skipcol = wp->w_skipcol;\n    }\n    else if (wp->w_skipcol != wp->w_valid_skipcol)\n    {\n\twp->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL\n\t\t\t\t      |VALID_CHEIGHT|VALID_CROW\n\t\t\t\t      |VALID_BOTLINE|VALID_BOTLINE_AP);\n\twp->w_valid_cursor = wp->w_cursor;\n\twp->w_valid_leftcol = wp->w_leftcol;\n\twp->w_valid_skipcol = wp->w_skipcol;\n    }\n    else if (wp->w_cursor.col != wp->w_valid_cursor.col\n\t     || wp->w_leftcol != wp->w_valid_leftcol\n\t     || wp->w_cursor.coladd != wp->w_valid_cursor.coladd)\n    {\n\twp->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL);\n\twp->w_valid_cursor.col = wp->w_cursor.col;\n\twp->w_valid_leftcol = wp->w_leftcol;\n\twp->w_valid_cursor.coladd = wp->w_cursor.coladd;\n    }\n}\n\n/*\n * Call this function when some window settings have changed, which require\n * the cursor position, botline and topline to be recomputed and the window to\n * be redrawn.  E.g, when changing the 'wrap' option or folding.\n */\n    void\nchanged_window_setting(void)\n{\n    changed_window_setting_win(curwin);\n}\n\n    void\nchanged_window_setting_win(win_T *wp)\n{\n    wp->w_lines_valid = 0;\n    changed_line_abv_curs_win(wp);\n    wp->w_valid &= ~(VALID_BOTLINE|VALID_BOTLINE_AP|VALID_TOPLINE);\n    redraw_win_later(wp, UPD_NOT_VALID);\n}\n\n#if defined(FEAT_PROP_POPUP) || defined(PROTO)\n/*\n * Call changed_window_setting_win() for every window containing \"buf\".\n */\n    void\nchanged_window_setting_buf(buf_T *buf)\n{\n    tabpage_T\t*tp;\n    win_T\t*wp;\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\tif (wp->w_buffer == buf)\n\t    changed_window_setting_win(wp);\n}\n#endif\n\n/*\n * Set wp->w_topline to a certain number.\n */\n    void\nset_topline(win_T *wp, linenr_T lnum)\n{\n#ifdef FEAT_DIFF\n    linenr_T prev_topline = wp->w_topline;\n#endif\n\n#ifdef FEAT_FOLDING\n    // go to first of folded lines\n    (void)hasFoldingWin(wp, lnum, &lnum, NULL, TRUE, NULL);\n#endif\n    // Approximate the value of w_botline\n    wp->w_botline += lnum - wp->w_topline;\n    if (wp->w_botline > wp->w_buffer->b_ml.ml_line_count + 1)\n\twp->w_botline = wp->w_buffer->b_ml.ml_line_count + 1;\n    wp->w_topline = lnum;\n    wp->w_topline_was_set = TRUE;\n#ifdef FEAT_DIFF\n    if (lnum != prev_topline)\n\t// Keep the filler lines when the topline didn't change.\n\twp->w_topfill = 0;\n#endif\n    wp->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE|VALID_TOPLINE);\n    // Don't set VALID_TOPLINE here, 'scrolloff' needs to be checked.\n    redraw_later(UPD_VALID);\n}\n\n/*\n * Call this function when the length of the cursor line (in screen\n * characters) has changed, and the change is before the cursor.\n * If the line length changed the number of screen lines might change,\n * requiring updating w_topline.  That may also invalidate w_crow.\n * Need to take care of w_botline separately!\n */\n    void\nchanged_cline_bef_curs(void)\n{\n    curwin->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL|VALID_CROW\n\t\t\t\t\t\t|VALID_CHEIGHT|VALID_TOPLINE);\n}\n\n    void\nchanged_cline_bef_curs_win(win_T *wp)\n{\n    wp->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL|VALID_CROW\n\t\t\t\t\t\t|VALID_CHEIGHT|VALID_TOPLINE);\n}\n\n/*\n * Call this function when the length of a line (in screen characters) above\n * the cursor have changed.\n * Need to take care of w_botline separately!\n */\n    void\nchanged_line_abv_curs(void)\n{\n    curwin->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL|VALID_CROW\n\t\t\t\t\t\t|VALID_CHEIGHT|VALID_TOPLINE);\n}\n\n    void\nchanged_line_abv_curs_win(win_T *wp)\n{\n    wp->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL|VALID_CROW\n\t\t\t\t\t\t|VALID_CHEIGHT|VALID_TOPLINE);\n}\n\n#if defined(FEAT_PROP_POPUP) || defined(PROTO)\n/*\n * Display of line has changed for \"buf\", invalidate cursor position and\n * w_botline.\n */\n    void\nchanged_line_display_buf(buf_T *buf)\n{\n    win_T *wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (wp->w_buffer == buf)\n\t    wp->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL\n\t\t\t\t|VALID_CROW|VALID_CHEIGHT\n\t\t\t\t|VALID_TOPLINE|VALID_BOTLINE|VALID_BOTLINE_AP);\n}\n#endif\n\n/*\n * Make sure the value of curwin->w_botline is valid.\n */\n    void\nvalidate_botline(void)\n{\n    validate_botline_win(curwin);\n}\n\n/*\n * Make sure the value of wp->w_botline is valid.\n */\n    void\nvalidate_botline_win(win_T *wp)\n{\n    if (!(wp->w_valid & VALID_BOTLINE))\n\tcomp_botline(wp);\n}\n\n/*\n * Mark curwin->w_botline as invalid (because of some change in the buffer).\n */\n    void\ninvalidate_botline(void)\n{\n    curwin->w_valid &= ~(VALID_BOTLINE|VALID_BOTLINE_AP);\n}\n\n    void\ninvalidate_botline_win(win_T *wp)\n{\n    wp->w_valid &= ~(VALID_BOTLINE|VALID_BOTLINE_AP);\n}\n\n    void\napproximate_botline_win(\n    win_T\t*wp)\n{\n    wp->w_valid &= ~VALID_BOTLINE;\n}\n\n/*\n * Return TRUE if curwin->w_wrow and curwin->w_wcol are valid.\n */\n    int\ncursor_valid(void)\n{\n    check_cursor_moved(curwin);\n    return ((curwin->w_valid & (VALID_WROW|VALID_WCOL)) ==\n\t\t\t\t\t\t      (VALID_WROW|VALID_WCOL));\n}\n\n/*\n * Validate cursor position.  Makes sure w_wrow and w_wcol are valid.\n * w_topline must be valid, you may need to call update_topline() first!\n */\n    void\nvalidate_cursor(void)\n{\n    check_cursor_lnum();\n    check_cursor_moved(curwin);\n    if ((curwin->w_valid & (VALID_WCOL|VALID_WROW)) != (VALID_WCOL|VALID_WROW))\n\tcurs_columns(TRUE);\n}\n\n#if defined(FEAT_GUI) || defined(PROTO)\n/*\n * validate w_cline_row.\n */\n    void\nvalidate_cline_row(void)\n{\n    /*\n     * First make sure that w_topline is valid (after moving the cursor).\n     */\n    update_topline();\n    check_cursor_moved(curwin);\n    if (!(curwin->w_valid & VALID_CROW))\n\tcurs_rows(curwin);\n}\n#endif\n\n/*\n * Compute wp->w_cline_row and wp->w_cline_height, based on the current value\n * of wp->w_topline.\n */\n    static void\ncurs_rows(win_T *wp)\n{\n    linenr_T\tlnum;\n    int\t\ti;\n    int\t\tall_invalid;\n    int\t\tvalid;\n#ifdef FEAT_FOLDING\n    long\tfold_count;\n#endif\n\n    // Check if wp->w_lines[].wl_size is invalid\n    all_invalid = (!redrawing()\n\t\t\t|| wp->w_lines_valid == 0\n\t\t\t|| wp->w_lines[0].wl_lnum > wp->w_topline);\n    i = 0;\n    wp->w_cline_row = 0;\n    for (lnum = wp->w_topline; lnum < wp->w_cursor.lnum; ++i)\n    {\n\tvalid = FALSE;\n\tif (!all_invalid && i < wp->w_lines_valid)\n\t{\n\t    if (wp->w_lines[i].wl_lnum < lnum || !wp->w_lines[i].wl_valid)\n\t\tcontinue;\t\t// skip changed or deleted lines\n\t    if (wp->w_lines[i].wl_lnum == lnum)\n\t    {\n#ifdef FEAT_FOLDING\n\t\t// Check for newly inserted lines below this row, in which\n\t\t// case we need to check for folded lines.\n\t\tif (!wp->w_buffer->b_mod_set\n\t\t\t|| wp->w_lines[i].wl_lastlnum < wp->w_cursor.lnum\n\t\t\t|| wp->w_buffer->b_mod_top\n\t\t\t\t\t     > wp->w_lines[i].wl_lastlnum + 1)\n#endif\n\t\tvalid = TRUE;\n\t    }\n\t    else if (wp->w_lines[i].wl_lnum > lnum)\n\t\t--i;\t\t\t// hold at inserted lines\n\t}\n\tif (valid\n\t       && (lnum != wp->w_topline || (wp->w_skipcol == 0\n#ifdef FEAT_DIFF\n\t\t\t\t\t    && !wp->w_p_diff\n#endif\n\t       )))\n\t{\n#ifdef FEAT_FOLDING\n\t    lnum = wp->w_lines[i].wl_lastlnum + 1;\n\t    // Cursor inside folded lines, don't count this row\n\t    if (lnum > wp->w_cursor.lnum)\n\t\tbreak;\n#else\n\t    ++lnum;\n#endif\n\t    wp->w_cline_row += wp->w_lines[i].wl_size;\n\t}\n\telse\n\t{\n#ifdef FEAT_FOLDING\n\t    fold_count = foldedCount(wp, lnum, NULL);\n\t    if (fold_count)\n\t    {\n\t\tlnum += fold_count;\n\t\tif (lnum > wp->w_cursor.lnum)\n\t\t    break;\n\t\t++wp->w_cline_row;\n\t    }\n\t    else\n#endif\n\t    {\n\t\twp->w_cline_row += plines_correct_topline(wp, lnum);\n\t\t++lnum;\n\t    }\n\t}\n    }\n\n    check_cursor_moved(wp);\n    if (!(wp->w_valid & VALID_CHEIGHT))\n    {\n\tif (all_invalid\n\t\t|| i == wp->w_lines_valid\n\t\t|| (i < wp->w_lines_valid\n\t\t    && (!wp->w_lines[i].wl_valid\n\t\t\t|| wp->w_lines[i].wl_lnum != wp->w_cursor.lnum)))\n\t{\n#ifdef FEAT_DIFF\n\t    if (wp->w_cursor.lnum == wp->w_topline)\n\t\twp->w_cline_height = plines_win_nofill(wp, wp->w_cursor.lnum,\n\t\t\t\t\t\t\tTRUE) + wp->w_topfill;\n\t    else\n#endif\n\t\twp->w_cline_height = plines_win(wp, wp->w_cursor.lnum, TRUE);\n#ifdef FEAT_FOLDING\n\t    wp->w_cline_folded = hasFoldingWin(wp, wp->w_cursor.lnum,\n\t\t\t\t\t\t      NULL, NULL, TRUE, NULL);\n#endif\n\t}\n\telse if (i > wp->w_lines_valid)\n\t{\n\t    // a line that is too long to fit on the last screen line\n\t    wp->w_cline_height = 0;\n#ifdef FEAT_FOLDING\n\t    wp->w_cline_folded = hasFoldingWin(wp, wp->w_cursor.lnum,\n\t\t\t\t\t\t      NULL, NULL, TRUE, NULL);\n#endif\n\t}\n\telse\n\t{\n\t    wp->w_cline_height = wp->w_lines[i].wl_size;\n#ifdef FEAT_FOLDING\n\t    wp->w_cline_folded = wp->w_lines[i].wl_folded;\n#endif\n\t}\n    }\n\n    redraw_for_cursorline(curwin);\n    wp->w_valid |= VALID_CROW|VALID_CHEIGHT;\n}\n\n/*\n * Validate curwin->w_virtcol only.\n */\n    void\nvalidate_virtcol(void)\n{\n    validate_virtcol_win(curwin);\n}\n\n/*\n * Validate wp->w_virtcol only.\n */\n    void\nvalidate_virtcol_win(win_T *wp)\n{\n    check_cursor_moved(wp);\n\n    if (wp->w_valid & VALID_VIRTCOL)\n\treturn;\n\n#ifdef FEAT_PROP_POPUP\n    wp->w_virtcol_first_char = 0;\n#endif\n    getvvcol(wp, &wp->w_cursor, NULL, &(wp->w_virtcol), NULL);\n#ifdef FEAT_SYN_HL\n    redraw_for_cursorcolumn(wp);\n#endif\n    wp->w_valid |= VALID_VIRTCOL;\n}\n\n/*\n * Validate curwin->w_cline_height only.\n */\n    void\nvalidate_cheight(void)\n{\n    check_cursor_moved(curwin);\n\n    if (curwin->w_valid & VALID_CHEIGHT)\n\treturn;\n\n#ifdef FEAT_DIFF\n    if (curwin->w_cursor.lnum == curwin->w_topline)\n\tcurwin->w_cline_height = plines_nofill(curwin->w_cursor.lnum)\n\t    + curwin->w_topfill;\n    else\n#endif\n\tcurwin->w_cline_height = plines(curwin->w_cursor.lnum);\n#ifdef FEAT_FOLDING\n    curwin->w_cline_folded = hasFolding(curwin->w_cursor.lnum, NULL, NULL);\n#endif\n    curwin->w_valid |= VALID_CHEIGHT;\n}\n\n/*\n * Validate w_wcol and w_virtcol only.\n */\n    void\nvalidate_cursor_col(void)\n{\n    colnr_T off;\n    colnr_T col;\n    int     width;\n\n    validate_virtcol();\n\n    if (curwin->w_valid & VALID_WCOL)\n\treturn;\n\n    col = curwin->w_virtcol;\n    off = curwin_col_off();\n    col += off;\n    width = curwin->w_width - off + curwin_col_off2();\n\n    // long line wrapping, adjust curwin->w_wrow\n    if (curwin->w_p_wrap\n\t    && col >= (colnr_T)curwin->w_width\n\t    && width > 0)\n\t// use same formula as what is used in curs_columns()\n\tcol -= ((col - curwin->w_width) / width + 1) * width;\n    if (col > (int)curwin->w_leftcol)\n\tcol -= curwin->w_leftcol;\n    else\n\tcol = 0;\n    curwin->w_wcol = col;\n\n    curwin->w_valid |= VALID_WCOL;\n#ifdef FEAT_PROP_POPUP\n    curwin->w_flags &= ~WFLAG_WCOL_OFF_ADDED;\n#endif\n}\n\n/*\n * Compute offset of a window, occupied by absolute or relative line number,\n * fold column and sign column (these don't move when scrolling horizontally).\n */\n    int\nwin_col_off(win_T *wp)\n{\n    return (((wp->w_p_nu || wp->w_p_rnu) ? number_width(wp) + 1 : 0)\n\t    + (cmdwin_type == 0 || wp != curwin ? 0 : 1)\n#ifdef FEAT_FOLDING\n\t    + wp->w_p_fdc\n#endif\n#ifdef FEAT_SIGNS\n\t    + (signcolumn_on(wp) ? 2 : 0)\n#endif\n\t   );\n}\n\n    int\ncurwin_col_off(void)\n{\n    return win_col_off(curwin);\n}\n\n/*\n * Return the difference in column offset for the second screen line of a\n * wrapped line.  It's positive if 'number' or 'relativenumber' is on and 'n'\n * is in 'cpoptions'.\n */\n    int\nwin_col_off2(win_T *wp)\n{\n    if ((wp->w_p_nu || wp->w_p_rnu) && vim_strchr(p_cpo, CPO_NUMCOL) != NULL)\n\treturn number_width(wp) + 1;\n    return 0;\n}\n\n    int\ncurwin_col_off2(void)\n{\n    return win_col_off2(curwin);\n}\n\n/*\n * Compute curwin->w_wcol and curwin->w_virtcol.\n * Also updates curwin->w_wrow and curwin->w_cline_row.\n * Also updates curwin->w_leftcol.\n */\n    void\ncurs_columns(\n    int\t\tmay_scroll)\t// when TRUE, may scroll horizontally\n{\n    int\t\tdiff;\n    int\t\textra;\t\t// offset for first screen line\n    int\t\toff_left, off_right;\n    int\t\tn;\n    int\t\tp_lines;\n    int\t\twidth1;\t\t// text width for first screen line\n    int\t\twidth2 = 0;\t// text width for second and later screen line\n    int\t\tnew_leftcol;\n    colnr_T\tstartcol;\n    colnr_T\tendcol;\n    colnr_T\tprev_skipcol;\n    long\tso = get_scrolloff_value();\n    long\tsiso = get_sidescrolloff_value();\n    int\t\tdid_sub_skipcol = FALSE;\n\n    /*\n     * First make sure that w_topline is valid (after moving the cursor).\n     */\n    update_topline();\n\n    /*\n     * Next make sure that w_cline_row is valid.\n     */\n    if (!(curwin->w_valid & VALID_CROW))\n\tcurs_rows(curwin);\n\n#ifdef FEAT_PROP_POPUP\n    // will be set by getvvcol() but not reset\n    curwin->w_virtcol_first_char = 0;\n#endif\n\n    /*\n     * Compute the number of virtual columns.\n     */\n#ifdef FEAT_FOLDING\n    if (curwin->w_cline_folded)\n\t// In a folded line the cursor is always in the first column\n\tstartcol = curwin->w_virtcol = endcol = curwin->w_leftcol;\n    else\n#endif\n\tgetvvcol(curwin, &curwin->w_cursor,\n\t\t\t\t&startcol, &(curwin->w_virtcol), &endcol);\n\n    // remove '$' from change command when cursor moves onto it\n    if (startcol > dollar_vcol)\n\tdollar_vcol = -1;\n\n    extra = curwin_col_off();\n    curwin->w_wcol = curwin->w_virtcol + extra;\n    endcol += extra;\n\n    /*\n     * Now compute w_wrow, counting screen lines from w_cline_row.\n     */\n    curwin->w_wrow = curwin->w_cline_row;\n\n    width1 = curwin->w_width - extra;\n    if (width1 <= 0)\n    {\n\t// No room for text, put cursor in last char of window.\n\t// If not wrapping, the last non-empty line.\n\tcurwin->w_wcol = curwin->w_width - 1;\n\tif (curwin->w_p_wrap)\n\t    curwin->w_wrow = curwin->w_height - 1;\n\telse\n\t    curwin->w_wrow = curwin->w_height - 1 - curwin->w_empty_rows;\n    }\n    else if (curwin->w_p_wrap && curwin->w_width != 0)\n    {\n\twidth2 = width1 + curwin_col_off2();\n\n\t// skip columns that are not visible\n\tif (curwin->w_cursor.lnum == curwin->w_topline\n\t\t&& curwin->w_skipcol > 0\n\t\t&& curwin->w_wcol >= curwin->w_skipcol)\n\t{\n\t    // Deduct by multiples of width2.  This allows the long line\n\t    // wrapping formula below to correctly calculate the w_wcol value\n\t    // when wrapping.\n\t    if (curwin->w_skipcol <= width1)\n\t\tcurwin->w_wcol -= width2;\n\t    else\n\t\tcurwin->w_wcol -= width2\n\t\t\t       * (((curwin->w_skipcol - width1) / width2) + 1);\n\n\t    did_sub_skipcol = TRUE;\n\t}\n\n\t// long line wrapping, adjust curwin->w_wrow\n\tif (curwin->w_wcol >= curwin->w_width)\n\t{\n\t    // this same formula is used in validate_cursor_col()\n\t    n = (curwin->w_wcol - curwin->w_width) / width2 + 1;\n\t    curwin->w_wcol -= n * width2;\n\t    curwin->w_wrow += n;\n\t}\n    }\n\n    // No line wrapping: compute curwin->w_leftcol if scrolling is on and line\n    // is not folded.\n    // If scrolling is off, curwin->w_leftcol is assumed to be 0\n    else if (may_scroll\n#ifdef FEAT_FOLDING\n\t    && !curwin->w_cline_folded\n#endif\n\t    )\n    {\n#ifdef FEAT_PROP_POPUP\n\tif (curwin->w_virtcol_first_char > 0)\n\t{\n\t    int cols = (curwin->w_width - extra);\n\t    int rows = cols > 0 ? curwin->w_virtcol_first_char / cols : 1;\n\n\t    // each \"above\" text prop shifts the text one row down\n\t    curwin->w_wrow += rows;\n\t    curwin->w_wcol -= rows * cols;\n\t    endcol -= rows * cols;\n\t    curwin->w_cline_height = rows + 1;\n\t}\n#endif\n\t/*\n\t * If Cursor is left of the screen, scroll rightwards.\n\t * If Cursor is right of the screen, scroll leftwards\n\t * If we get closer to the edge than 'sidescrolloff', scroll a little\n\t * extra\n\t */\n\toff_left = (int)startcol - (int)curwin->w_leftcol - siso;\n\toff_right = (int)endcol - (int)(curwin->w_leftcol + curwin->w_width\n\t\t\t\t\t\t\t\t- siso) + 1;\n\tif (off_left < 0 || off_right > 0)\n\t{\n\t    if (off_left < 0)\n\t\tdiff = -off_left;\n\t    else\n\t\tdiff = off_right;\n\n\t    // When far off or not enough room on either side, put cursor in\n\t    // middle of window.\n\t    if (p_ss == 0 || diff >= width1 / 2 || off_right >= off_left)\n\t\tnew_leftcol = curwin->w_wcol - extra - width1 / 2;\n\t    else\n\t    {\n\t\tif (diff < p_ss)\n\t\t    diff = p_ss;\n\t\tif (off_left < 0)\n\t\t    new_leftcol = curwin->w_leftcol - diff;\n\t\telse\n\t\t    new_leftcol = curwin->w_leftcol + diff;\n\t    }\n\t    if (new_leftcol < 0)\n\t\tnew_leftcol = 0;\n\t    if (new_leftcol != (int)curwin->w_leftcol)\n\t    {\n\t\tcurwin->w_leftcol = new_leftcol;\n\t\t// screen has to be redrawn with new curwin->w_leftcol\n\t\tredraw_later(UPD_NOT_VALID);\n\t    }\n\t}\n\tcurwin->w_wcol -= curwin->w_leftcol;\n    }\n    else if (curwin->w_wcol > (int)curwin->w_leftcol)\n\tcurwin->w_wcol -= curwin->w_leftcol;\n    else\n\tcurwin->w_wcol = 0;\n\n#ifdef FEAT_DIFF\n    // Skip over filler lines.  At the top use w_topfill, there\n    // may be some filler lines above the window.\n    if (curwin->w_cursor.lnum == curwin->w_topline)\n\tcurwin->w_wrow += curwin->w_topfill;\n    else\n\tcurwin->w_wrow += diff_check_fill(curwin, curwin->w_cursor.lnum);\n#endif\n\n    prev_skipcol = curwin->w_skipcol;\n\n    p_lines = 0;\n\n    if ((curwin->w_wrow >= curwin->w_height\n\t\t|| ((prev_skipcol > 0\n\t\t\t|| curwin->w_wrow + so >= curwin->w_height)\n\t\t    && (p_lines =\n#ifdef FEAT_DIFF\n\t\t\tplines_win_nofill\n#else\n\t\t\tplines_win\n#endif\n\t\t\t(curwin, curwin->w_cursor.lnum, FALSE))\n\t\t\t\t\t\t    - 1 >= curwin->w_height))\n\t    && curwin->w_height != 0\n\t    && curwin->w_cursor.lnum == curwin->w_topline\n\t    && width2 > 0\n\t    && curwin->w_width != 0)\n    {\n\t// Cursor past end of screen.  Happens with a single line that does\n\t// not fit on screen.  Find a skipcol to show the text around the\n\t// cursor.  Avoid scrolling all the time. compute value of \"extra\":\n\t// 1: Less than 'scrolloff' lines above\n\t// 2: Less than 'scrolloff' lines below\n\t// 3: both of them\n\textra = 0;\n\tif (curwin->w_skipcol + so * width2 > curwin->w_virtcol)\n\t    extra = 1;\n\t// Compute last display line of the buffer line that we want at the\n\t// bottom of the window.\n\tif (p_lines == 0)\n\t    p_lines = plines_win(curwin, curwin->w_cursor.lnum, FALSE);\n\t--p_lines;\n\tif (p_lines > curwin->w_wrow + so)\n\t    n = curwin->w_wrow + so;\n\telse\n\t    n = p_lines;\n\tif ((colnr_T)n >= curwin->w_height + curwin->w_skipcol / width2 - so)\n\t    extra += 2;\n\n\tif (extra == 3 || curwin->w_height <= so * 2)\n\t{\n\t    // not enough room for 'scrolloff', put cursor in the middle\n\t    n = curwin->w_virtcol / width2;\n\t    if (n > curwin->w_height / 2)\n\t\tn -= curwin->w_height / 2;\n\t    else\n\t\tn = 0;\n\t    // don't skip more than necessary\n\t    if (n > p_lines - curwin->w_height + 1)\n\t\tn = p_lines - curwin->w_height + 1;\n\t    if (n > 0)\n\t\tcurwin->w_skipcol = width1 + (n - 1) * width2;\n\t    else\n\t\tcurwin->w_skipcol = 0;\n\t}\n\telse if (extra == 1)\n\t{\n\t    // less than 'scrolloff' lines above, decrease skipcol\n\t    extra = (curwin->w_skipcol + so * width2 - curwin->w_virtcol\n\t\t\t\t     + width2 - 1) / width2;\n\t    if (extra > 0)\n\t    {\n\t\tif ((colnr_T)(extra * width2) > curwin->w_skipcol)\n\t\t    extra = curwin->w_skipcol / width2;\n\t\tcurwin->w_skipcol -= extra * width2;\n\t    }\n\t}\n\telse if (extra == 2)\n\t{\n\t    // less than 'scrolloff' lines below, increase skipcol\n\t    endcol = (n - curwin->w_height + 1) * width2;\n\t    while (endcol > curwin->w_virtcol)\n\t\tendcol -= width2;\n\t    if (endcol > curwin->w_skipcol)\n\t\tcurwin->w_skipcol = endcol;\n\t}\n\n\t// adjust w_wrow for the changed w_skipcol\n\tif (did_sub_skipcol)\n\t    curwin->w_wrow -= (curwin->w_skipcol - prev_skipcol) / width2;\n\telse\n\t    curwin->w_wrow -= curwin->w_skipcol / width2;\n\n\tif (curwin->w_wrow >= curwin->w_height)\n\t{\n\t    // small window, make sure cursor is in it\n\t    extra = curwin->w_wrow - curwin->w_height + 1;\n\t    curwin->w_skipcol += extra * width2;\n\t    curwin->w_wrow -= extra;\n\t}\n\n\textra = ((int)prev_skipcol - (int)curwin->w_skipcol) / width2;\n\tif (extra > 0)\n\t    win_ins_lines(curwin, 0, extra, FALSE, FALSE);\n\telse if (extra < 0)\n\t    win_del_lines(curwin, 0, -extra, FALSE, FALSE, 0);\n    }\n    else if (!curwin->w_p_sms)\n\tcurwin->w_skipcol = 0;\n    if (prev_skipcol != curwin->w_skipcol)\n\tredraw_later(UPD_SOME_VALID);\n\n#ifdef FEAT_SYN_HL\n    redraw_for_cursorcolumn(curwin);\n#endif\n#if defined(FEAT_PROP_POPUP) && defined(FEAT_TERMINAL)\n    if (popup_is_popup(curwin) && curbuf->b_term != NULL)\n    {\n\tcurwin->w_wrow += popup_top_extra(curwin);\n\tcurwin->w_wcol += popup_left_extra(curwin);\n\tcurwin->w_flags |= WFLAG_WCOL_OFF_ADDED + WFLAG_WROW_OFF_ADDED;\n    }\n    else\n\tcurwin->w_flags &= ~(WFLAG_WCOL_OFF_ADDED + WFLAG_WROW_OFF_ADDED);\n#endif\n\n    // now w_leftcol and w_skipcol are valid, avoid check_cursor_moved()\n    // thinking otherwise\n    curwin->w_valid_leftcol = curwin->w_leftcol;\n    curwin->w_valid_skipcol = curwin->w_skipcol;\n\n    curwin->w_valid |= VALID_WCOL|VALID_WROW|VALID_VIRTCOL;\n}\n\n#if (defined(FEAT_EVAL) || defined(FEAT_PROP_POPUP)) || defined(PROTO)\n/*\n * Compute the screen position of text character at \"pos\" in window \"wp\"\n * The resulting values are one-based, zero when character is not visible.\n */\n    void\ntextpos2screenpos(\n\twin_T\t*wp,\n\tpos_T\t*pos,\n\tint\t*rowp,\t// screen row\n\tint\t*scolp,\t// start screen column\n\tint\t*ccolp,\t// cursor screen column\n\tint\t*ecolp)\t// end screen column\n{\n    colnr_T\tscol = 0, ccol = 0, ecol = 0;\n    int\t\trow = 0;\n    colnr_T\tcoloff = 0;\n\n    if (pos->lnum >= wp->w_topline && pos->lnum <= wp->w_botline)\n    {\n\tcolnr_T\t    col;\n\tint\t    width;\n\tlinenr_T    lnum = pos->lnum;\n#ifdef FEAT_FOLDING\n\tint\t    is_folded;\n\n\tis_folded = hasFoldingWin(wp, lnum, &lnum, NULL, TRUE, NULL);\n#endif\n\trow = plines_m_win(wp, wp->w_topline, lnum - 1, FALSE);\n\t// \"row\" should be the screen line where line \"lnum\" begins, which can\n\t// be negative if \"lnum\" is \"w_topline\" and \"w_skipcol\" is non-zero.\n\trow -= adjust_plines_for_skipcol(wp);\n\n#ifdef FEAT_DIFF\n\t// Add filler lines above this buffer line.\n\trow += lnum == wp->w_topline ? wp->w_topfill\n\t\t\t\t     : diff_check_fill(wp, lnum);\n#endif\n\n\tcolnr_T\toff = win_col_off(wp);\n#ifdef FEAT_FOLDING\n\tif (is_folded)\n\t{\n\t    row += W_WINROW(wp) + 1;\n\t    coloff = wp->w_wincol + 1 + off;\n\t}\n\telse\n#endif\n\t{\n\t    getvcol(wp, pos, &scol, &ccol, &ecol);\n\n\t    // similar to what is done in validate_cursor_col()\n\t    col = scol;\n\t    col += off;\n\t    width = wp->w_width - off + win_col_off2(wp);\n\n\t    // long line wrapping, adjust row\n\t    if (wp->w_p_wrap\n\t\t    && col >= (colnr_T)wp->w_width\n\t\t    && width > 0)\n\t    {\n\t\t// use same formula as what is used in curs_columns()\n\t\tint rowoff = ((col - wp->w_width) / width + 1);\n\t\tcol -= rowoff * width;\n\t\trow += rowoff;\n\t    }\n\t    col -= wp->w_leftcol;\n\t    if (col >= wp->w_width)\n\t\tcol = -1;\n\t    if (col >= 0 && row >= 0 && row < wp->w_height)\n\t    {\n\t\tcoloff = col - scol + wp->w_wincol + 1;\n\t\trow += W_WINROW(wp) + 1;\n\t    }\n\t    else\n\t\t// character is out of the window\n\t\trow = scol = ccol = ecol = 0;\n\t}\n    }\n    *rowp = row;\n    *scolp = scol + coloff;\n    *ccolp = ccol + coloff;\n    *ecolp = ecol + coloff;\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * \"screenpos({winid}, {lnum}, {col})\" function\n */\n    void\nf_screenpos(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    dict_T\t*dict;\n    win_T\t*wp;\n    pos_T\tpos;\n    int\t\trow = 0;\n    int\t\tscol = 0, ccol = 0, ecol = 0;\n\n    if (rettv_dict_alloc(rettv) == FAIL)\n\treturn;\n    dict = rettv->vval.v_dict;\n\n    if (in_vim9script()\n\t    && (check_for_number_arg(argvars, 0) == FAIL\n\t\t|| check_for_number_arg(argvars, 1) == FAIL\n\t\t|| check_for_number_arg(argvars, 2) == FAIL))\n\treturn;\n\n    wp = find_win_by_nr_or_id(&argvars[0]);\n    if (wp == NULL)\n\treturn;\n\n    pos.lnum = tv_get_number(&argvars[1]);\n    if (pos.lnum > wp->w_buffer->b_ml.ml_line_count)\n    {\n\tsemsg(_(e_invalid_line_number_nr), pos.lnum);\n\treturn;\n    }\n    pos.col = tv_get_number(&argvars[2]) - 1;\n    pos.coladd = 0;\n    textpos2screenpos(wp, &pos, &row, &scol, &ccol, &ecol);\n\n    dict_add_number(dict, \"row\", row);\n    dict_add_number(dict, \"col\", scol);\n    dict_add_number(dict, \"curscol\", ccol);\n    dict_add_number(dict, \"endcol\", ecol);\n}\n\n/*\n * Convert a virtual (screen) column to a character column.  The first column\n * is one.  For a multibyte character, the column number of the first byte is\n * returned.\n */\n    static int\nvirtcol2col(win_T *wp, linenr_T lnum, int vcol)\n{\n    int\t\toffset = vcol2col(wp, lnum, vcol - 1, NULL);\n    char_u\t*line = ml_get_buf(wp->w_buffer, lnum, FALSE);\n    char_u\t*p = line + offset;\n\n    if (*p == NUL)\n    {\n\tif (p == line)  // empty line\n\t    return 0;\n\t// Move to the first byte of the last char.\n\tMB_PTR_BACK(line, p);\n    }\n    return (int)(p - line + 1);\n}\n\n/*\n * \"virtcol2col({winid}, {lnum}, {col})\" function\n */\n    void\nf_virtcol2col(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    win_T\t*wp;\n    linenr_T\tlnum;\n    int\t\tscreencol;\n    int\t\terror = FALSE;\n\n    rettv->vval.v_number = -1;\n\n    if (check_for_number_arg(argvars, 0) == FAIL\n\t    || check_for_number_arg(argvars, 1) == FAIL\n\t    || check_for_number_arg(argvars, 2) == FAIL)\n\treturn;\n\n    wp = find_win_by_nr_or_id(&argvars[0]);\n    if (wp == NULL)\n\treturn;\n\n    lnum = tv_get_number_chk(&argvars[1], &error);\n    if (error || lnum < 0 || lnum > wp->w_buffer->b_ml.ml_line_count)\n\treturn;\n\n    screencol = tv_get_number_chk(&argvars[2], &error);\n    if (error || screencol < 0)\n\treturn;\n\n    rettv->vval.v_number = virtcol2col(wp, lnum, screencol);\n}\n#endif\n\n/*\n * Scroll the current window down by \"line_count\" logical lines.  \"CTRL-Y\"\n */\n    void\nscrolldown(\n    long\tline_count,\n    int\t\tbyfold UNUSED)\t// TRUE: count a closed fold as one line\n{\n    long\tdone = 0;\t// total # of physical lines done\n    int\t\twrow;\n    int\t\tmoved = FALSE;\n    int\t\tdo_sms = curwin->w_p_wrap && curwin->w_p_sms;\n    int\t\twidth1 = 0;\n    int\t\twidth2 = 0;\n\n    if (do_sms)\n    {\n\twidth1 = curwin->w_width - curwin_col_off();\n\twidth2 = width1 + curwin_col_off2();\n    }\n\n#ifdef FEAT_FOLDING\n    linenr_T\tfirst;\n\n    // Make sure w_topline is at the first of a sequence of folded lines.\n    (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n    validate_cursor();\t\t// w_wrow needs to be valid\n    for (int todo = line_count; todo > 0; --todo)\n    {\n#ifdef FEAT_DIFF\n\tif (curwin->w_topfill < diff_check(curwin, curwin->w_topline)\n\t\t&& curwin->w_topfill < curwin->w_height - 1)\n\t{\n\t    ++curwin->w_topfill;\n\t    ++done;\n\t}\n\telse\n#endif\n\t{\n\t    // break when at the very top\n\t    if (curwin->w_topline == 1\n\t\t\t\t   && (!do_sms || curwin->w_skipcol < width1))\n\t\tbreak;\n\t    if (do_sms && curwin->w_skipcol >= width1)\n\t    {\n\t\t// scroll a screen line down\n\t\tif (curwin->w_skipcol >= width1 + width2)\n\t\t    curwin->w_skipcol -= width2;\n\t\telse\n\t\t    curwin->w_skipcol -= width1;\n\t\tredraw_later(UPD_NOT_VALID);\n\t\t++done;\n\t    }\n\t    else\n\t    {\n\t\t// scroll a text line down\n\t\t--curwin->w_topline;\n\t\tcurwin->w_skipcol = 0;\n#ifdef FEAT_DIFF\n\t\tcurwin->w_topfill = 0;\n#endif\n#ifdef FEAT_FOLDING\n\t\t// A sequence of folded lines only counts for one logical line\n\t\tif (hasFolding(curwin->w_topline, &first, NULL))\n\t\t{\n\t\t    ++done;\n\t\t    if (!byfold)\n\t\t\ttodo -= curwin->w_topline - first - 1;\n\t\t    curwin->w_botline -= curwin->w_topline - first;\n\t\t    curwin->w_topline = first;\n\t\t}\n\t\telse\n#endif\n\t\tif (do_sms)\n\t\t{\n\t\t    int size = win_linetabsize(curwin, curwin->w_topline,\n\t\t\t\t   ml_get(curwin->w_topline), (colnr_T)MAXCOL);\n\t\t    if (size > width1)\n\t\t    {\n\t\t\tcurwin->w_skipcol = width1;\n\t\t\tsize -= width1;\n\t\t\tredraw_later(UPD_NOT_VALID);\n\t\t    }\n\t\t    while (size > width2)\n\t\t    {\n\t\t\tcurwin->w_skipcol += width2;\n\t\t\tsize -= width2;\n\t\t    }\n\t\t    ++done;\n\t\t}\n\t\telse\n\t\t    done += PLINES_NOFILL(curwin->w_topline);\n\t    }\n\t}\n\t--curwin->w_botline;\t\t// approximate w_botline\n\tinvalidate_botline();\n    }\n    curwin->w_wrow += done;\t\t// keep w_wrow updated\n    curwin->w_cline_row += done;\t// keep w_cline_row updated\n\n#ifdef FEAT_DIFF\n    if (curwin->w_cursor.lnum == curwin->w_topline)\n\tcurwin->w_cline_row = 0;\n    check_topfill(curwin, TRUE);\n#endif\n\n    /*\n     * Compute the row number of the last row of the cursor line\n     * and move the cursor onto the displayed part of the window.\n     */\n    wrow = curwin->w_wrow;\n    if (curwin->w_p_wrap && curwin->w_width != 0)\n    {\n\tvalidate_virtcol();\n\tvalidate_cheight();\n\twrow += curwin->w_cline_height - 1 -\n\t    curwin->w_virtcol / curwin->w_width;\n    }\n    while (wrow >= curwin->w_height && curwin->w_cursor.lnum > 1)\n    {\n#ifdef FEAT_FOLDING\n\tif (hasFolding(curwin->w_cursor.lnum, &first, NULL))\n\t{\n\t    --wrow;\n\t    if (first == 1)\n\t\tcurwin->w_cursor.lnum = 1;\n\t    else\n\t\tcurwin->w_cursor.lnum = first - 1;\n\t}\n\telse\n#endif\n\t    wrow -= plines(curwin->w_cursor.lnum--);\n\tcurwin->w_valid &=\n\t      ~(VALID_WROW|VALID_WCOL|VALID_CHEIGHT|VALID_CROW|VALID_VIRTCOL);\n\tmoved = TRUE;\n    }\n    if (moved)\n    {\n#ifdef FEAT_FOLDING\n\t// Move cursor to first line of closed fold.\n\tfoldAdjustCursor();\n#endif\n\tcoladvance(curwin->w_curswant);\n    }\n\n    if (curwin->w_cursor.lnum == curwin->w_topline && do_sms)\n    {\n\tlong\tso = get_scrolloff_value();\n\tint\tscrolloff_cols = so == 0 ? 0 : width1 + (so - 1) * width2;\n\n\t// make sure the cursor is in the visible text\n\tvalidate_virtcol();\n\tint col = curwin->w_virtcol - curwin->w_skipcol + scrolloff_cols;\n\tint row = 0;\n\tif (col >= width1)\n\t{\n\t    col -= width1;\n\t    ++row;\n\t}\n\tif (col > width2 && width2 > 0)\n\t{\n\t    row += col / width2;\n\t    // even so col is not used anymore,\n\t    // make sure it is correct, just in case\n\t    col = col % width2;\n\t}\n\tif (row >= curwin->w_height)\n\t{\n\t    curwin->w_curswant = curwin->w_virtcol\n\t\t\t\t       - (row - curwin->w_height + 1) * width2;\n\t    coladvance(curwin->w_curswant);\n\t}\n    }\n}\n\n/*\n * Scroll the current window up by \"line_count\" logical lines.  \"CTRL-E\"\n */\n    void\nscrollup(\n    long\tline_count,\n    int\t\tbyfold UNUSED)\t// TRUE: count a closed fold as one line\n{\n    int\t\tdo_sms = curwin->w_p_wrap && curwin->w_p_sms;\n\n    if (do_sms\n# ifdef FEAT_FOLDING\n\t    || (byfold && hasAnyFolding(curwin))\n# endif\n# ifdef FEAT_DIFF\n\t    || (curwin->w_p_diff && !curwin->w_p_wrap)\n# endif\n       )\n    {\n\tint\t    width1 = curwin->w_width - curwin_col_off();\n\tint\t    width2 = width1 + curwin_col_off2();\n\tint\t    size = 0;\n\tcolnr_T\t    prev_skipcol = curwin->w_skipcol;\n\n\tif (do_sms)\n\t    size = linetabsize(curwin, curwin->w_topline);\n\n\t// diff mode: first consume \"topfill\"\n\t// 'smoothscroll': increase \"w_skipcol\" until it goes over the end of\n\t// the line, then advance to the next line.\n\t// folding: count each sequence of folded lines as one logical line.\n\tfor (int todo = line_count; todo > 0; --todo)\n\t{\n# ifdef FEAT_DIFF\n\t    if (curwin->w_topfill > 0)\n\t\t--curwin->w_topfill;\n\t    else\n# endif\n\t    {\n\t\tlinenr_T lnum = curwin->w_topline;\n\n# ifdef FEAT_FOLDING\n\t\tif (byfold)\n\t\t    // for a closed fold: go to the last line in the fold\n\t\t    (void)hasFolding(lnum, NULL, &lnum);\n# endif\n\t\tif (lnum == curwin->w_topline && do_sms)\n\t\t{\n\t\t    // 'smoothscroll': increase \"w_skipcol\" until it goes over\n\t\t    // the end of the line, then advance to the next line.\n\t\t    int add = curwin->w_skipcol > 0 ? width2 : width1;\n\t\t    curwin->w_skipcol += add;\n\t\t    if (curwin->w_skipcol >= size)\n\t\t    {\n\t\t\tif (lnum == curbuf->b_ml.ml_line_count)\n\t\t\t{\n\t\t\t    // at the last screen line, can't scroll further\n\t\t\t    curwin->w_skipcol -= add;\n\t\t\t    break;\n\t\t\t}\n\t\t\t++lnum;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (lnum >= curbuf->b_ml.ml_line_count)\n\t\t\tbreak;\n\t\t    ++lnum;\n\t\t}\n\n\t\tif (lnum > curwin->w_topline)\n\t\t{\n\t\t    // approximate w_botline\n\t\t    curwin->w_botline += lnum - curwin->w_topline;\n\t\t    curwin->w_topline = lnum;\n# ifdef FEAT_DIFF\n\t\t    curwin->w_topfill = diff_check_fill(curwin, lnum);\n# endif\n\t\t    curwin->w_skipcol = 0;\n\t\t    if (todo > 1 && do_sms)\n\t\t\tsize = linetabsize(curwin, curwin->w_topline);\n\t\t}\n\t    }\n\t}\n\n\tif (prev_skipcol > 0 || curwin->w_skipcol > 0)\n\t    // need to redraw more, because wl_size of the (new) topline may\n\t    // now be invalid\n\t    redraw_later(UPD_NOT_VALID);\n    }\n    else\n    {\n\tcurwin->w_topline += line_count;\n\tcurwin->w_botline += line_count;\t// approximate w_botline\n    }\n\n    if (curwin->w_topline > curbuf->b_ml.ml_line_count)\n\tcurwin->w_topline = curbuf->b_ml.ml_line_count;\n    if (curwin->w_botline > curbuf->b_ml.ml_line_count + 1)\n\tcurwin->w_botline = curbuf->b_ml.ml_line_count + 1;\n\n#ifdef FEAT_DIFF\n    check_topfill(curwin, FALSE);\n#endif\n\n#ifdef FEAT_FOLDING\n    if (hasAnyFolding(curwin))\n\t// Make sure w_topline is at the first of a sequence of folded lines.\n\t(void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n\n    curwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);\n    if (curwin->w_cursor.lnum < curwin->w_topline)\n    {\n\tcurwin->w_cursor.lnum = curwin->w_topline;\n\tcurwin->w_valid &=\n\t      ~(VALID_WROW|VALID_WCOL|VALID_CHEIGHT|VALID_CROW|VALID_VIRTCOL);\n\tcoladvance(curwin->w_curswant);\n    }\n    if (curwin->w_cursor.lnum == curwin->w_topline\n\t\t\t\t\t    && do_sms && curwin->w_skipcol > 0)\n    {\n\tint\tcol_off = curwin_col_off();\n\tint\tcol_off2 = curwin_col_off2();\n\n\tint\twidth1 = curwin->w_width - col_off;\n\tint\twidth2 = width1 + col_off2;\n\tint\textra2 = col_off - col_off2;\n\tlong\tso = get_scrolloff_value();\n\tint\tscrolloff_cols = so == 0 ? 0 : width1 + (so - 1) * width2;\n\tint\tspace_cols = (curwin->w_height - 1) * width2;\n\n\t// If we have non-zero scrolloff, just ignore the marker as we are\n\t// going past it anyway.\n\tint overlap = scrolloff_cols != 0 ? 0\n\t\t\t\t\t  : sms_marker_overlap(curwin, extra2);\n\n\t// Make sure the cursor is in a visible part of the line, taking\n\t// 'scrolloff' into account, but using screen lines.\n\t// If there are not enough screen lines put the cursor in the middle.\n\tif (scrolloff_cols > space_cols / 2)\n\t    scrolloff_cols = space_cols / 2;\n\tvalidate_virtcol();\n\tif (curwin->w_virtcol < curwin->w_skipcol + overlap + scrolloff_cols)\n\t{\n\t    colnr_T col = curwin->w_virtcol;\n\n\t    if (col < width1)\n\t\tcol += width1;\n\t    while (col < curwin->w_skipcol + overlap + scrolloff_cols)\n\t\tcol += width2;\n\t    curwin->w_curswant = col;\n\t    coladvance(curwin->w_curswant);\n\n\t    // validate_virtcol() marked various things as valid, but after\n\t    // moving the cursor they need to be recomputed\n\t    curwin->w_valid &=\n\t       ~(VALID_WROW|VALID_WCOL|VALID_CHEIGHT|VALID_CROW|VALID_VIRTCOL);\n\t}\n    }\n}\n\n/*\n * Called after changing the cursor column: make sure that curwin->w_skipcol is\n * valid for 'smoothscroll'.\n */\n    void\nadjust_skipcol(void)\n{\n    if (!curwin->w_p_wrap\n\t    || !curwin->w_p_sms\n\t    || curwin->w_cursor.lnum != curwin->w_topline)\n\treturn;\n\n    int\t    width1 = curwin->w_width - curwin_col_off();\n    if (width1 <= 0)\n\treturn;  // no text will be displayed\n\n    int\t    width2 = width1 + curwin_col_off2();\n    long    so = get_scrolloff_value();\n    int\t    scrolloff_cols = so == 0 ? 0 : width1 + (so - 1) * width2;\n    int\t    scrolled = FALSE;\n\n    validate_cheight();\n    if (curwin->w_cline_height == curwin->w_height\n\t    // w_cline_height may be capped at w_height, check there aren't\n\t    // actually more lines.\n\t    && plines_win(curwin, curwin->w_cursor.lnum, FALSE)\n\t\t\t\t\t\t\t   <= curwin->w_height)\n    {\n\t// the line just fits in the window, don't scroll\n\treset_skipcol();\n\treturn;\n    }\n\n    validate_virtcol();\n    int overlap = sms_marker_overlap(curwin,\n\t\t\t\t\t curwin_col_off() - curwin_col_off2());\n    while (curwin->w_skipcol > 0\n\t    && curwin->w_virtcol < curwin->w_skipcol + overlap + scrolloff_cols)\n    {\n\t// scroll a screen line down\n\tif (curwin->w_skipcol >= width1 + width2)\n\t    curwin->w_skipcol -= width2;\n\telse\n\t    curwin->w_skipcol -= width1;\n\tscrolled = TRUE;\n    }\n    if (scrolled)\n    {\n\tvalidate_virtcol();\n\tredraw_later(UPD_NOT_VALID);\n\treturn;  // don't scroll in the other direction now\n    }\n\n    int col = curwin->w_virtcol - curwin->w_skipcol + scrolloff_cols;\n    int row = 0;\n    if (col >= width1)\n    {\n\tcol -= width1;\n\t++row;\n    }\n    if (col > width2)\n    {\n\trow += col / width2;\n\t// col may no longer be used, but make\n\t// sure it is correct anyhow, just in case\n\tcol = col % width2;\n    }\n    if (row >= curwin->w_height)\n    {\n\tif (curwin->w_skipcol == 0)\n\t{\n\t    curwin->w_skipcol += width1;\n\t    --row;\n\t}\n\tif (row >= curwin->w_height)\n\t    curwin->w_skipcol += (row - curwin->w_height) * width2;\n\tredraw_later(UPD_NOT_VALID);\n    }\n}\n\n#ifdef FEAT_DIFF\n/*\n * Don't end up with too many filler lines in the window.\n */\n    void\ncheck_topfill(\n    win_T\t*wp,\n    int\t\tdown)\t// when TRUE scroll down when not enough space\n{\n    int\t\tn;\n\n    if (wp->w_topfill <= 0)\n\treturn;\n\n    n = plines_win_nofill(wp, wp->w_topline, TRUE);\n    if (wp->w_topfill + n > wp->w_height)\n    {\n\tif (down && wp->w_topline > 1)\n\t{\n\t    --wp->w_topline;\n\t    wp->w_topfill = 0;\n\t}\n\telse\n\t{\n\t    wp->w_topfill = wp->w_height - n;\n\t    if (wp->w_topfill < 0)\n\t\twp->w_topfill = 0;\n\t}\n    }\n}\n\n/*\n * Use as many filler lines as possible for w_topline.  Make sure w_topline\n * is still visible.\n */\n    static void\nmax_topfill(void)\n{\n    int\t\tn;\n\n    n = plines_nofill(curwin->w_topline);\n    if (n >= curwin->w_height)\n\tcurwin->w_topfill = 0;\n    else\n    {\n\tcurwin->w_topfill = diff_check_fill(curwin, curwin->w_topline);\n\tif (curwin->w_topfill + n > curwin->w_height)\n\t    curwin->w_topfill = curwin->w_height - n;\n    }\n}\n#endif\n\n/*\n * Scroll the screen one line down, but don't do it if it would move the\n * cursor off the screen.\n */\n    void\nscrolldown_clamp(void)\n{\n    int\t\tend_row;\n#ifdef FEAT_DIFF\n    int\t\tcan_fill = (curwin->w_topfill\n\t\t\t\t< diff_check_fill(curwin, curwin->w_topline));\n#endif\n\n    if (curwin->w_topline <= 1\n#ifdef FEAT_DIFF\n\t    && !can_fill\n#endif\n\t    )\n\treturn;\n\n    validate_cursor();\t    // w_wrow needs to be valid\n\n    /*\n     * Compute the row number of the last row of the cursor line\n     * and make sure it doesn't go off the screen. Make sure the cursor\n     * doesn't go past 'scrolloff' lines from the screen end.\n     */\n    end_row = curwin->w_wrow;\n#ifdef FEAT_DIFF\n    if (can_fill)\n\t++end_row;\n    else\n\tend_row += plines_nofill(curwin->w_topline - 1);\n#else\n    end_row += plines(curwin->w_topline - 1);\n#endif\n    if (curwin->w_p_wrap && curwin->w_width != 0)\n    {\n\tvalidate_cheight();\n\tvalidate_virtcol();\n\tend_row += curwin->w_cline_height - 1 -\n\t    curwin->w_virtcol / curwin->w_width;\n    }\n    if (end_row < curwin->w_height - get_scrolloff_value())\n    {\n#ifdef FEAT_DIFF\n\tif (can_fill)\n\t{\n\t    ++curwin->w_topfill;\n\t    check_topfill(curwin, TRUE);\n\t}\n\telse\n\t{\n\t    --curwin->w_topline;\n\t    curwin->w_topfill = 0;\n\t}\n#else\n\t--curwin->w_topline;\n#endif\n#ifdef FEAT_FOLDING\n\t(void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n\t--curwin->w_botline;\t    // approximate w_botline\n\tcurwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);\n    }\n}\n\n/*\n * Scroll the screen one line up, but don't do it if it would move the cursor\n * off the screen.\n */\n    void\nscrollup_clamp(void)\n{\n    int\t    start_row;\n\n    if (curwin->w_topline == curbuf->b_ml.ml_line_count\n#ifdef FEAT_DIFF\n\t    && curwin->w_topfill == 0\n#endif\n\t    )\n\treturn;\n\n    validate_cursor();\t    // w_wrow needs to be valid\n\n    /*\n     * Compute the row number of the first row of the cursor line\n     * and make sure it doesn't go off the screen. Make sure the cursor\n     * doesn't go before 'scrolloff' lines from the screen start.\n     */\n#ifdef FEAT_DIFF\n    start_row = curwin->w_wrow - plines_nofill(curwin->w_topline)\n\t\t\t\t\t\t\t  - curwin->w_topfill;\n#else\n    start_row = curwin->w_wrow - plines(curwin->w_topline);\n#endif\n    if (curwin->w_p_wrap && curwin->w_width != 0)\n    {\n\tvalidate_virtcol();\n\tstart_row -= curwin->w_virtcol / curwin->w_width;\n    }\n    if (start_row >= get_scrolloff_value())\n    {\n#ifdef FEAT_DIFF\n\tif (curwin->w_topfill > 0)\n\t    --curwin->w_topfill;\n\telse\n#endif\n\t{\n#ifdef FEAT_FOLDING\n\t    (void)hasFolding(curwin->w_topline, NULL, &curwin->w_topline);\n#endif\n\t    ++curwin->w_topline;\n\t}\n\t++curwin->w_botline;\t\t// approximate w_botline\n\tcurwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);\n    }\n}\n\n/*\n * Add one line above \"lp->lnum\".  This can be a filler line, a closed fold or\n * a (wrapped) text line.  Uses and sets \"lp->fill\".\n * Returns the height of the added line in \"lp->height\".\n * Lines above the first one are incredibly high: MAXCOL.\n */\n    static void\ntopline_back_winheight(\n    lineoff_T\t*lp,\n    int\t\twinheight)\t// when TRUE limit to window height\n{\n#ifdef FEAT_DIFF\n    if (lp->fill < diff_check_fill(curwin, lp->lnum))\n    {\n\t// Add a filler line.\n\t++lp->fill;\n\tlp->height = 1;\n    }\n    else\n#endif\n    {\n\t--lp->lnum;\n#ifdef FEAT_DIFF\n\tlp->fill = 0;\n#endif\n\tif (lp->lnum < 1)\n\t    lp->height = MAXCOL;\n\telse\n#ifdef FEAT_FOLDING\n\t    if (hasFolding(lp->lnum, &lp->lnum, NULL))\n\t    // Add a closed fold\n\t    lp->height = 1;\n\telse\n#endif\n\t    lp->height = PLINES_WIN_NOFILL(curwin, lp->lnum, winheight);\n    }\n}\n\n    static void\ntopline_back(lineoff_T *lp)\n{\n    topline_back_winheight(lp, TRUE);\n}\n\n\n/*\n * Add one line below \"lp->lnum\".  This can be a filler line, a closed fold or\n * a (wrapped) text line.  Uses and sets \"lp->fill\".\n * Returns the height of the added line in \"lp->height\".\n * Lines below the last one are incredibly high.\n */\n    static void\nbotline_forw(lineoff_T *lp)\n{\n#ifdef FEAT_DIFF\n    if (lp->fill < diff_check_fill(curwin, lp->lnum + 1))\n    {\n\t// Add a filler line.\n\t++lp->fill;\n\tlp->height = 1;\n    }\n    else\n#endif\n    {\n\t++lp->lnum;\n#ifdef FEAT_DIFF\n\tlp->fill = 0;\n#endif\n\tif (lp->lnum > curbuf->b_ml.ml_line_count)\n\t    lp->height = MAXCOL;\n\telse\n#ifdef FEAT_FOLDING\n\t    if (hasFolding(lp->lnum, NULL, &lp->lnum))\n\t    // Add a closed fold\n\t    lp->height = 1;\n\telse\n#endif\n\t    lp->height = PLINES_NOFILL(lp->lnum);\n    }\n}\n\n#ifdef FEAT_DIFF\n/*\n * Switch from including filler lines below lp->lnum to including filler\n * lines above loff.lnum + 1.  This keeps pointing to the same line.\n * When there are no filler lines nothing changes.\n */\n    static void\nbotline_topline(lineoff_T *lp)\n{\n    if (lp->fill > 0)\n    {\n\t++lp->lnum;\n\tlp->fill = diff_check_fill(curwin, lp->lnum) - lp->fill + 1;\n    }\n}\n\n/*\n * Switch from including filler lines above lp->lnum to including filler\n * lines below loff.lnum - 1.  This keeps pointing to the same line.\n * When there are no filler lines nothing changes.\n */\n    static void\ntopline_botline(lineoff_T *lp)\n{\n    if (lp->fill > 0)\n    {\n\tlp->fill = diff_check_fill(curwin, lp->lnum) - lp->fill + 1;\n\t--lp->lnum;\n    }\n}\n#endif\n\n/*\n * Recompute topline to put the cursor at the top of the window.\n * Scroll at least \"min_scroll\" lines.\n * If \"always\" is TRUE, always set topline (for \"zt\").\n */\n    void\nscroll_cursor_top(int min_scroll, int always)\n{\n    int\t\tscrolled = 0;\n    int\t\textra = 0;\n    int\t\tused;\n    int\t\ti;\n    linenr_T\ttop;\t\t// just above displayed lines\n    linenr_T\tbot;\t\t// just below displayed lines\n    linenr_T\told_topline = curwin->w_topline;\n    int\t\told_skipcol = curwin->w_skipcol;\n#ifdef FEAT_DIFF\n    linenr_T\told_topfill = curwin->w_topfill;\n#endif\n    linenr_T\tnew_topline;\n    int\t\toff = get_scrolloff_value();\n\n    if (mouse_dragging > 0)\n\toff = mouse_dragging - 1;\n\n    /*\n     * Decrease topline until:\n     * - it has become 1\n     * - (part of) the cursor line is moved off the screen or\n     * - moved at least 'scrolljump' lines and\n     * - at least 'scrolloff' lines above and below the cursor\n     */\n    validate_cheight();\n    used = curwin->w_cline_height; // includes filler lines above\n    if (curwin->w_cursor.lnum < curwin->w_topline)\n\tscrolled = used;\n\n#ifdef FEAT_FOLDING\n    if (hasFolding(curwin->w_cursor.lnum, &top, &bot))\n    {\n\t--top;\n\t++bot;\n    }\n    else\n#endif\n    {\n\ttop = curwin->w_cursor.lnum - 1;\n\tbot = curwin->w_cursor.lnum + 1;\n    }\n    new_topline = top + 1;\n\n#ifdef FEAT_DIFF\n    // \"used\" already contains the number of filler lines above, don't add it\n    // again.\n    // Hide filler lines above cursor line by adding them to \"extra\".\n    extra += diff_check_fill(curwin, curwin->w_cursor.lnum);\n#endif\n\n    /*\n     * Check if the lines from \"top\" to \"bot\" fit in the window.  If they do,\n     * set new_topline and advance \"top\" and \"bot\" to include more lines.\n     */\n    while (top > 0)\n    {\n#ifdef FEAT_FOLDING\n\tif (hasFolding(top, &top, NULL))\n\t    // count one logical line for a sequence of folded lines\n\t    i = 1;\n\telse\n#endif\n\t    i = PLINES_NOFILL(top);\n\tif (top < curwin->w_topline)\n\t    scrolled += i;\n\n\t// If scrolling is needed, scroll at least 'sj' lines.\n\tif ((new_topline >= curwin->w_topline || scrolled > min_scroll)\n\t\t&& extra >= off)\n\t    break;\n\n\tused += i;\n\tif (extra + i <= off && bot < curbuf->b_ml.ml_line_count)\n\t{\n#ifdef FEAT_FOLDING\n\t    if (hasFolding(bot, NULL, &bot))\n\t\t// count one logical line for a sequence of folded lines\n\t\t++used;\n\t    else\n#endif\n\t\tused += plines(bot);\n\t}\n\tif (used > curwin->w_height)\n\t    break;\n\n\textra += i;\n\tnew_topline = top;\n\t--top;\n\t++bot;\n    }\n\n    /*\n     * If we don't have enough space, put cursor in the middle.\n     * This makes sure we get the same position when using \"k\" and \"j\"\n     * in a small window.\n     */\n    if (used > curwin->w_height)\n\tscroll_cursor_halfway(FALSE, FALSE);\n    else\n    {\n\t/*\n\t * If \"always\" is FALSE, only adjust topline to a lower value, higher\n\t * value may happen with wrapping lines.\n\t */\n\tif (new_topline < curwin->w_topline || always)\n\t    curwin->w_topline = new_topline;\n\tif (curwin->w_topline > curwin->w_cursor.lnum)\n\t    curwin->w_topline = curwin->w_cursor.lnum;\n#ifdef FEAT_DIFF\n\tcurwin->w_topfill = diff_check_fill(curwin, curwin->w_topline);\n\tif (curwin->w_topfill > 0 && extra > off)\n\t{\n\t    curwin->w_topfill -= extra - off;\n\t    if (curwin->w_topfill < 0)\n\t\tcurwin->w_topfill = 0;\n\t}\n\tcheck_topfill(curwin, FALSE);\n#endif\n\tif (curwin->w_topline != old_topline)\n\t    reset_skipcol();\n\telse if (curwin->w_topline == curwin->w_cursor.lnum)\n\t{\n\t    validate_virtcol();\n\t    if (curwin->w_skipcol >= curwin->w_virtcol)\n\t\t// TODO: if the line doesn't fit may optimize w_skipcol instead\n\t\t// of making it zero\n\t\treset_skipcol();\n\t}\n\tif (curwin->w_topline != old_topline\n\t\t|| curwin->w_skipcol != old_skipcol\n#ifdef FEAT_DIFF\n\t\t|| curwin->w_topfill != old_topfill\n#endif\n\t\t)\n\t    curwin->w_valid &=\n\t\t      ~(VALID_WROW|VALID_CROW|VALID_BOTLINE|VALID_BOTLINE_AP);\n\tcurwin->w_valid |= VALID_TOPLINE;\n    }\n}\n\n/*\n * Set w_empty_rows and w_filler_rows for window \"wp\", having used up \"used\"\n * screen lines for text lines.\n */\n    void\nset_empty_rows(win_T *wp, int used)\n{\n#ifdef FEAT_DIFF\n    wp->w_filler_rows = 0;\n#endif\n    if (used == 0)\n\twp->w_empty_rows = 0;\t// single line that doesn't fit\n    else\n    {\n\twp->w_empty_rows = wp->w_height - used;\n#ifdef FEAT_DIFF\n\tif (wp->w_botline <= wp->w_buffer->b_ml.ml_line_count)\n\t{\n\t    wp->w_filler_rows = diff_check_fill(wp, wp->w_botline);\n\t    if (wp->w_empty_rows > wp->w_filler_rows)\n\t\twp->w_empty_rows -= wp->w_filler_rows;\n\t    else\n\t    {\n\t\twp->w_filler_rows = wp->w_empty_rows;\n\t\twp->w_empty_rows = 0;\n\t    }\n\t}\n#endif\n    }\n}\n\n/*\n * Recompute topline to put the cursor at the bottom of the window.\n * When scrolling scroll at least \"min_scroll\" lines.\n * If \"set_topbot\" is TRUE, set topline and botline first (for \"zb\").\n * This is messy stuff!!!\n */\n    void\nscroll_cursor_bot(int min_scroll, int set_topbot)\n{\n    int\t\tused;\n    int\t\tscrolled = 0;\n    int\t\textra = 0;\n    int\t\ti;\n    linenr_T\tline_count;\n    linenr_T\told_topline = curwin->w_topline;\n    int\t\told_skipcol = curwin->w_skipcol;\n    lineoff_T\tloff;\n    lineoff_T\tboff;\n#ifdef FEAT_DIFF\n    int\t\told_topfill = curwin->w_topfill;\n    int\t\tfill_below_window;\n#endif\n    linenr_T\told_botline = curwin->w_botline;\n    linenr_T\told_valid = curwin->w_valid;\n    int\t\told_empty_rows = curwin->w_empty_rows;\n    linenr_T\tcln;\t\t    // Cursor Line Number\n    long\tso = get_scrolloff_value();\n    int\t\tdo_sms = curwin->w_p_wrap && curwin->w_p_sms;\n\n    cln = curwin->w_cursor.lnum;\n    if (set_topbot)\n    {\n\tint set_skipcol = FALSE;\n\n\tused = 0;\n\tcurwin->w_botline = cln + 1;\n#ifdef FEAT_DIFF\n\tloff.fill = 0;\n#endif\n\tfor (curwin->w_topline = curwin->w_botline;\n\t\tcurwin->w_topline > 1;\n\t\tcurwin->w_topline = loff.lnum)\n\t{\n\t    loff.lnum = curwin->w_topline;\n\t    topline_back_winheight(&loff, FALSE);\n\t    if (loff.height == MAXCOL)\n\t\tbreak;\n\t    if (used + loff.height > curwin->w_height)\n\t    {\n\t\tif (do_sms)\n\t\t{\n\t\t    // 'smoothscroll' and 'wrap' are set.  The above line is\n\t\t    // too long to show in its entirety, so we show just a part\n\t\t    // of it.\n\t\t    if (used < curwin->w_height)\n\t\t    {\n\t\t\tint plines_offset = used + loff.height\n\t\t\t\t\t\t\t    - curwin->w_height;\n\t\t\tused = curwin->w_height;\n#ifdef FEAT_DIFF\n\t\t\tcurwin->w_topfill = loff.fill;\n#endif\n\t\t\tcurwin->w_topline = loff.lnum;\n\t\t\tcurwin->w_skipcol = skipcol_from_plines(\n\t\t\t\t\t\t\tcurwin, plines_offset);\n\t\t\tset_skipcol = TRUE;\n\t\t    }\n\t\t}\n\t\tbreak;\n\t    }\n\t    used += loff.height;\n#ifdef FEAT_DIFF\n\t    curwin->w_topfill = loff.fill;\n#endif\n\t}\n\tset_empty_rows(curwin, used);\n\tcurwin->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;\n\tif (curwin->w_topline != old_topline\n#ifdef FEAT_DIFF\n\t\t|| curwin->w_topfill != old_topfill\n#endif\n\t\t|| set_skipcol\n\t\t|| curwin->w_skipcol != 0)\n\t{\n\t    curwin->w_valid &= ~(VALID_WROW|VALID_CROW);\n\t    if (set_skipcol)\n\t\tredraw_later(UPD_NOT_VALID);\n\t    else\n\t\treset_skipcol();\n\t}\n    }\n    else\n\tvalidate_botline();\n\n    // The lines of the cursor line itself are always used.\n#ifdef FEAT_DIFF\n    used = plines_nofill(cln);\n#else\n    validate_cheight();\n    used = curwin->w_cline_height;\n#endif\n\n    // If the cursor is on or below botline, we will at least scroll by the\n    // height of the cursor line, which is \"used\".  Correct for empty lines,\n    // which are really part of botline.\n    if (cln >= curwin->w_botline)\n    {\n\tscrolled = used;\n\tif (cln == curwin->w_botline)\n\t    scrolled -= curwin->w_empty_rows;\n\tif (do_sms)\n\t{\n\t    // 'smoothscroll' and 'wrap' are set.\n\t    // Calculate how many screen lines the current top line of window\n\t    // occupies. If it is occupying more than the entire window, we\n\t    // need to scroll the additional clipped lines to scroll past the\n\t    // top line before we can move on to the other lines.\n\t    int top_plines =\n#ifdef FEAT_DIFF\n\t\t\t    plines_win_nofill\n#else\n\t\t\t    plines_win\n#endif\n\t\t\t\t\t(curwin, curwin->w_topline, FALSE);\n\t    int skip_lines = 0;\n\t    int width1 = curwin->w_width - curwin_col_off();\n\t    if (width1 > 0)\n\t    {\n\t\tint width2 = width1 + curwin_col_off2();\n\t\t// similar formula is used in curs_columns()\n\t\tif (curwin->w_skipcol > width1)\n\t\t    skip_lines += (curwin->w_skipcol - width1) / width2 + 1;\n\t\telse if (curwin->w_skipcol > 0)\n\t\t    skip_lines = 1;\n\n\t\ttop_plines -= skip_lines;\n\t\tif (top_plines > curwin->w_height)\n\t\t{\n\t\t    scrolled += (top_plines - curwin->w_height);\n\t\t}\n\t    }\n\t}\n    }\n\n    /*\n     * Stop counting lines to scroll when\n     * - hitting start of the file\n     * - scrolled nothing or at least 'sj' lines\n     * - at least 'scrolloff' lines below the cursor\n     * - lines between botline and cursor have been counted\n     */\n#ifdef FEAT_FOLDING\n    if (!hasFolding(curwin->w_cursor.lnum, &loff.lnum, &boff.lnum))\n#endif\n    {\n\tloff.lnum = cln;\n\tboff.lnum = cln;\n    }\n#ifdef FEAT_DIFF\n    loff.fill = 0;\n    boff.fill = 0;\n    fill_below_window = diff_check_fill(curwin, curwin->w_botline)\n\t\t\t\t\t\t      - curwin->w_filler_rows;\n#endif\n\n    while (loff.lnum > 1)\n    {\n\t// Stop when scrolled nothing or at least \"min_scroll\", found \"extra\"\n\t// context for 'scrolloff' and counted all lines below the window.\n\tif ((((scrolled <= 0 || scrolled >= min_scroll)\n\t\t    && extra >= (mouse_dragging > 0 ? mouse_dragging - 1 : so))\n\t\t    || boff.lnum + 1 > curbuf->b_ml.ml_line_count)\n\t\t&& loff.lnum <= curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t&& (loff.lnum < curwin->w_botline\n\t\t    || loff.fill >= fill_below_window)\n#endif\n\t\t)\n\t    break;\n\n\t// Add one line above\n\ttopline_back(&loff);\n\tif (loff.height == MAXCOL)\n\t    used = MAXCOL;\n\telse\n\t    used += loff.height;\n\tif (used > curwin->w_height)\n\t    break;\n\tif (loff.lnum >= curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t&& (loff.lnum > curwin->w_botline\n\t\t    || loff.fill <= fill_below_window)\n#endif\n\t\t)\n\t{\n\t    // Count screen lines that are below the window.\n\t    scrolled += loff.height;\n\t    if (loff.lnum == curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t\t    && loff.fill == 0\n#endif\n\t\t    )\n\t\tscrolled -= curwin->w_empty_rows;\n\t}\n\n\tif (boff.lnum < curbuf->b_ml.ml_line_count)\n\t{\n\t    // Add one line below\n\t    botline_forw(&boff);\n\t    used += boff.height;\n\t    if (used > curwin->w_height)\n\t\tbreak;\n\t    if (extra < ( mouse_dragging > 0 ? mouse_dragging - 1 : so)\n\t\t    || scrolled < min_scroll)\n\t    {\n\t\textra += boff.height;\n\t\tif (boff.lnum >= curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t\t|| (boff.lnum + 1 == curwin->w_botline\n\t\t\t    && boff.fill > curwin->w_filler_rows)\n#endif\n\t\t   )\n\t\t{\n\t\t    // Count screen lines that are below the window.\n\t\t    scrolled += boff.height;\n\t\t    if (boff.lnum == curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t\t    && boff.fill == 0\n#endif\n\t\t\t    )\n\t\t\tscrolled -= curwin->w_empty_rows;\n\t\t}\n\t    }\n\t}\n    }\n\n    // curwin->w_empty_rows is larger, no need to scroll\n    if (scrolled <= 0)\n\tline_count = 0;\n    // more than a screenfull, don't scroll but redraw\n    else if (used > curwin->w_height)\n\tline_count = used;\n    // scroll minimal number of lines\n    else\n    {\n\tline_count = 0;\n#ifdef FEAT_DIFF\n\tboff.fill = curwin->w_topfill;\n#endif\n\tboff.lnum = curwin->w_topline - 1;\n\tfor (i = 0; i < scrolled && boff.lnum < curwin->w_botline; )\n\t{\n\t    botline_forw(&boff);\n\t    i += boff.height;\n\t    ++line_count;\n\t}\n\tif (i < scrolled)\t// below curwin->w_botline, don't scroll\n\t    line_count = 9999;\n    }\n\n    /*\n     * Scroll up if the cursor is off the bottom of the screen a bit.\n     * Otherwise put it at 1/2 of the screen.\n     */\n    if (line_count >= curwin->w_height && line_count > min_scroll)\n\tscroll_cursor_halfway(FALSE, TRUE);\n    else if (line_count > 0)\n    {\n\tif (do_sms)\n\t    scrollup(scrolled, TRUE);  // TODO\n\telse\n\t    scrollup(line_count, TRUE);\n    }\n\n    /*\n     * If topline didn't change we need to restore w_botline and w_empty_rows\n     * (we changed them).\n     * If topline did change, update_screen() will set botline.\n     */\n    if (curwin->w_topline == old_topline\n\t    && curwin->w_skipcol == old_skipcol\n\t    && set_topbot)\n    {\n\tcurwin->w_botline = old_botline;\n\tcurwin->w_empty_rows = old_empty_rows;\n\tcurwin->w_valid = old_valid;\n    }\n    curwin->w_valid |= VALID_TOPLINE;\n}\n\n/*\n * Recompute topline to put the cursor halfway the window\n * If \"atend\" is TRUE, also put it halfway at the end of the file.\n */\n    void\nscroll_cursor_halfway(int atend, int prefer_above)\n{\n    int\t\tabove = 0;\n    linenr_T\ttopline;\n    colnr_T\tskipcol = 0;\n#ifdef FEAT_DIFF\n    int\t\ttopfill = 0;\n#endif\n    int\t\tbelow = 0;\n    int\t\tused;\n    lineoff_T\tloff;\n    lineoff_T\tboff;\n#ifdef FEAT_DIFF\n    linenr_T\told_topline = curwin->w_topline;\n#endif\n\n#ifdef FEAT_PROP_POPUP\n    // if the width changed this needs to be updated first\n    may_update_popup_position();\n#endif\n    loff.lnum = boff.lnum = curwin->w_cursor.lnum;\n#ifdef FEAT_FOLDING\n    (void)hasFolding(loff.lnum, &loff.lnum, &boff.lnum);\n#endif\n#ifdef FEAT_DIFF\n    used = plines_nofill(loff.lnum);\n    loff.fill = 0;\n    boff.fill = 0;\n#else\n    used = plines(loff.lnum);\n#endif\n    topline = loff.lnum;\n\n    int want_height;\n    int do_sms = curwin->w_p_wrap && curwin->w_p_sms;\n    if (do_sms)\n    {\n\t// 'smoothscroll' and 'wrap' are set\n\tif (atend)\n\t{\n\t    want_height = (curwin->w_height - used) / 2;\n\t    used = 0;\n\t}\n\telse\n\t    want_height = curwin->w_height;\n    }\n\n    while (topline > 1)\n    {\n\t// If using smoothscroll, we can precisely scroll to the\n\t// exact point where the cursor is halfway down the screen.\n\tif (do_sms)\n\t{\n\t    topline_back_winheight(&loff, FALSE);\n\t    if (loff.height == MAXCOL)\n\t\tbreak;\n\t    used += loff.height;\n\t    if (!atend && boff.lnum < curbuf->b_ml.ml_line_count)\n\t    {\n\t\tbotline_forw(&boff);\n\t\tused += boff.height;\n\t    }\n\t    if (used > want_height)\n\t    {\n\t\tif (used - loff.height < want_height)\n\t\t{\n\t\t    topline = loff.lnum;\n#ifdef FEAT_DIFF\n\t\t    topfill = loff.fill;\n#endif\n\t\t    skipcol = skipcol_from_plines(curwin, used - want_height);\n\t\t}\n\t\tbreak;\n\t    }\n\t    topline = loff.lnum;\n#ifdef FEAT_DIFF\n\t    topfill = loff.fill;\n#endif\n\t    continue;\n\t}\n\n\t// If not using smoothscroll, we have to iteratively find how many\n\t// lines to scroll down to roughly fit the cursor.\n\t// This may not be right in the middle if the lines'\n\t// physical height > 1 (e.g. 'wrap' is on).\n\n\t// Depending on \"prefer_above\" we add a line above or below first.\n\t// Loop twice to avoid duplicating code.\n\tint done = FALSE;\n\tfor (int round = 1; round <= 2; ++round)\n\t{\n\t    if (prefer_above ? (round == 2 && below < above)\n\t\t\t     : (round == 1 && below <= above))\n\t    {\n\t\t// add a line below the cursor\n\t\tif (boff.lnum < curbuf->b_ml.ml_line_count)\n\t\t{\n\t\t    botline_forw(&boff);\n\t\t    used += boff.height;\n\t\t    if (used > curwin->w_height)\n\t\t    {\n\t\t\tdone = TRUE;\n\t\t\tbreak;\n\t\t    }\n\t\t    below += boff.height;\n\t\t}\n\t\telse\n\t\t{\n\t\t    ++below;\t    // count a \"~\" line\n\t\t    if (atend)\n\t\t\t++used;\n\t\t}\n\t    }\n\n\t    if (prefer_above ? (round == 1 && below >= above)\n\t\t\t     : (round == 1 && below > above))\n\t    {\n\t\t// add a line above the cursor\n\t\ttopline_back(&loff);\n\t\tif (loff.height == MAXCOL)\n\t\t    used = MAXCOL;\n\t\telse\n\t\t    used += loff.height;\n\t\tif (used > curwin->w_height)\n\t\t{\n\t\t    done = TRUE;\n\t\t    break;\n\t\t}\n\t\tabove += loff.height;\n\t\ttopline = loff.lnum;\n#ifdef FEAT_DIFF\n\t\ttopfill = loff.fill;\n#endif\n\t    }\n\t}\n\tif (done)\n\t    break;\n    }\n\n#ifdef FEAT_FOLDING\n    if (!hasFolding(topline, &curwin->w_topline, NULL))\n#endif\n    {\n\tif (curwin->w_topline != topline\n\t\t|| skipcol != 0\n\t\t|| curwin->w_skipcol != 0)\n\t{\n\t    curwin->w_topline = topline;\n\t    if (skipcol != 0)\n\t    {\n\t\tcurwin->w_skipcol = skipcol;\n\t\tredraw_later(UPD_NOT_VALID);\n\t    }\n\t    else if (do_sms)\n\t\treset_skipcol();\n\t}\n    }\n#ifdef FEAT_DIFF\n    curwin->w_topfill = topfill;\n    if (old_topline > curwin->w_topline + curwin->w_height)\n\tcurwin->w_botfill = FALSE;\n    check_topfill(curwin, FALSE);\n#endif\n    curwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE|VALID_BOTLINE_AP);\n    curwin->w_valid |= VALID_TOPLINE;\n}\n\n/*\n * Correct the cursor position so that it is in a part of the screen at least\n * 'scrolloff' lines from the top and bottom, if possible.\n * If not possible, put it at the same position as scroll_cursor_halfway().\n * When called topline must be valid!\n */\n    void\ncursor_correct(void)\n{\n    int\t\tabove = 0;\t    // screen lines above topline\n    linenr_T\ttopline;\n    int\t\tbelow = 0;\t    // screen lines below botline\n    linenr_T\tbotline;\n    int\t\tabove_wanted, below_wanted;\n    linenr_T\tcln;\t\t    // Cursor Line Number\n    int\t\tmax_off;\n    long\tso = get_scrolloff_value();\n\n    /*\n     * How many lines we would like to have above/below the cursor depends on\n     * whether the first/last line of the file is on screen.\n     */\n    above_wanted = so;\n    below_wanted = so;\n    if (mouse_dragging > 0)\n    {\n\tabove_wanted = mouse_dragging - 1;\n\tbelow_wanted = mouse_dragging - 1;\n    }\n    if (curwin->w_topline == 1)\n    {\n\tabove_wanted = 0;\n\tmax_off = curwin->w_height / 2;\n\tif (below_wanted > max_off)\n\t    below_wanted = max_off;\n    }\n    validate_botline();\n    if (curwin->w_botline == curbuf->b_ml.ml_line_count + 1\n\t    && mouse_dragging == 0)\n    {\n\tbelow_wanted = 0;\n\tmax_off = (curwin->w_height - 1) / 2;\n\tif (above_wanted > max_off)\n\t    above_wanted = max_off;\n    }\n\n    /*\n     * If there are sufficient file-lines above and below the cursor, we can\n     * return now.\n     */\n    cln = curwin->w_cursor.lnum;\n    if (cln >= curwin->w_topline + above_wanted\n\t    && cln < curwin->w_botline - below_wanted\n#ifdef FEAT_FOLDING\n\t    && !hasAnyFolding(curwin)\n#endif\n\t    )\n\treturn;\n\n    if (curwin->w_p_sms && !curwin->w_p_wrap)\n    {\n\t// 'smoothscroll' is active\n\tif (curwin->w_cline_height == curwin->w_height)\n\t{\n\t    // The cursor line just fits in the window, don't scroll.\n\t    reset_skipcol();\n\t    return;\n\t}\n\t// TODO: If the cursor line doesn't fit in the window then only adjust\n\t// w_skipcol.\n    }\n\n    /*\n     * Narrow down the area where the cursor can be put by taking lines from\n     * the top and the bottom until:\n     * - the desired context lines are found\n     * - the lines from the top is past the lines from the bottom\n     */\n    topline = curwin->w_topline;\n    botline = curwin->w_botline - 1;\n#ifdef FEAT_DIFF\n    // count filler lines as context\n    above = curwin->w_topfill;\n    below = curwin->w_filler_rows;\n#endif\n    while ((above < above_wanted || below < below_wanted) && topline < botline)\n    {\n\tif (below < below_wanted && (below <= above || above >= above_wanted))\n\t{\n#ifdef FEAT_FOLDING\n\t    if (hasFolding(botline, &botline, NULL))\n\t\t++below;\n\t    else\n#endif\n\t\tbelow += plines(botline);\n\t    --botline;\n\t}\n\tif (above < above_wanted && (above < below || below >= below_wanted))\n\t{\n#ifdef FEAT_FOLDING\n\t    if (hasFolding(topline, NULL, &topline))\n\t\t++above;\n\t    else\n#endif\n\t\tabove += PLINES_NOFILL(topline);\n#ifdef FEAT_DIFF\n\t    // Count filler lines below this line as context.\n\t    if (topline < botline)\n\t\tabove += diff_check_fill(curwin, topline + 1);\n#endif\n\t    ++topline;\n\t}\n    }\n    if (topline == botline || botline == 0)\n\tcurwin->w_cursor.lnum = topline;\n    else if (topline > botline)\n\tcurwin->w_cursor.lnum = botline;\n    else\n    {\n\tif (cln < topline && curwin->w_topline > 1)\n\t{\n\t    curwin->w_cursor.lnum = topline;\n\t    curwin->w_valid &=\n\t\t\t    ~(VALID_WROW|VALID_WCOL|VALID_CHEIGHT|VALID_CROW);\n\t}\n\tif (cln > botline && curwin->w_botline <= curbuf->b_ml.ml_line_count)\n\t{\n\t    curwin->w_cursor.lnum = botline;\n\t    curwin->w_valid &=\n\t\t\t    ~(VALID_WROW|VALID_WCOL|VALID_CHEIGHT|VALID_CROW);\n\t}\n    }\n    curwin->w_valid |= VALID_TOPLINE;\n}\n\nstatic void get_scroll_overlap(lineoff_T *lp, int dir);\n\n/*\n * Move screen \"count\" pages up (\"dir\" is BACKWARD) or down (\"dir\" is FORWARD)\n * and update the screen.\n *\n * Return FAIL for failure, OK otherwise.\n */\n    int\nonepage(int dir, long count)\n{\n    long\tn;\n    int\t\tretval = OK;\n    lineoff_T\tloff;\n    linenr_T\told_topline = curwin->w_topline;\n    long\tso = get_scrolloff_value();\n\n    if (curbuf->b_ml.ml_line_count == 1)    // nothing to do\n    {\n\tbeep_flush();\n\treturn FAIL;\n    }\n\n    for ( ; count > 0; --count)\n    {\n\tvalidate_botline();\n\t/*\n\t * It's an error to move a page up when the first line is already on\n\t * the screen.\tIt's an error to move a page down when the last line\n\t * is on the screen and the topline is 'scrolloff' lines from the\n\t * last line.\n\t */\n\tif (dir == FORWARD\n\t\t? ((curwin->w_topline >= curbuf->b_ml.ml_line_count - so)\n\t\t    && curwin->w_botline > curbuf->b_ml.ml_line_count)\n\t\t: (curwin->w_topline == 1\n#ifdef FEAT_DIFF\n\t\t    && curwin->w_topfill ==\n\t\t\t\t    diff_check_fill(curwin, curwin->w_topline)\n#endif\n\t\t    ))\n\t{\n\t    beep_flush();\n\t    retval = FAIL;\n\t    break;\n\t}\n\n#ifdef FEAT_DIFF\n\tloff.fill = 0;\n#endif\n\tif (dir == FORWARD)\n\t{\n\t    if (ONE_WINDOW && p_window > 0 && p_window < Rows - 1)\n\t    {\n\t\t// Vi compatible scrolling\n\t\tif (p_window <= 2)\n\t\t    ++curwin->w_topline;\n\t\telse\n\t\t    curwin->w_topline += p_window - 2;\n\t\tif (curwin->w_topline > curbuf->b_ml.ml_line_count)\n\t\t    curwin->w_topline = curbuf->b_ml.ml_line_count;\n\t\tcurwin->w_cursor.lnum = curwin->w_topline;\n\t    }\n\t    else if (curwin->w_botline > curbuf->b_ml.ml_line_count)\n\t    {\n\t\t// at end of file\n\t\tcurwin->w_topline = curbuf->b_ml.ml_line_count;\n#ifdef FEAT_DIFF\n\t\tcurwin->w_topfill = 0;\n#endif\n\t\tcurwin->w_valid &= ~(VALID_WROW|VALID_CROW);\n\t    }\n\t    else\n\t    {\n\t\t// For the overlap, start with the line just below the window\n\t\t// and go upwards.\n\t\tloff.lnum = curwin->w_botline;\n#ifdef FEAT_DIFF\n\t\tloff.fill = diff_check_fill(curwin, loff.lnum)\n\t\t\t\t\t\t      - curwin->w_filler_rows;\n#endif\n\t\tget_scroll_overlap(&loff, -1);\n\t\tcurwin->w_topline = loff.lnum;\n#ifdef FEAT_DIFF\n\t\tcurwin->w_topfill = loff.fill;\n\t\tcheck_topfill(curwin, FALSE);\n#endif\n\t\tcurwin->w_cursor.lnum = curwin->w_topline;\n\t\tcurwin->w_valid &= ~(VALID_WCOL|VALID_CHEIGHT|VALID_WROW|\n\t\t\t\t   VALID_CROW|VALID_BOTLINE|VALID_BOTLINE_AP);\n\t    }\n\t}\n\telse\t// dir == BACKWARDS\n\t{\n#ifdef FEAT_DIFF\n\t    if (curwin->w_topline == 1)\n\t    {\n\t\t// Include max number of filler lines\n\t\tmax_topfill();\n\t\tcontinue;\n\t    }\n#endif\n\t    if (ONE_WINDOW && p_window > 0 && p_window < Rows - 1)\n\t    {\n\t\t// Vi compatible scrolling (sort of)\n\t\tif (p_window <= 2)\n\t\t    --curwin->w_topline;\n\t\telse\n\t\t    curwin->w_topline -= p_window - 2;\n\t\tif (curwin->w_topline < 1)\n\t\t    curwin->w_topline = 1;\n\t\tcurwin->w_cursor.lnum = curwin->w_topline + p_window - 1;\n\t\tif (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t\t    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t\tcontinue;\n\t    }\n\n\t    // Find the line at the top of the window that is going to be the\n\t    // line at the bottom of the window.  Make sure this results in\n\t    // the same line as before doing CTRL-F.\n\t    loff.lnum = curwin->w_topline - 1;\n#ifdef FEAT_DIFF\n\t    loff.fill = diff_check_fill(curwin, loff.lnum + 1)\n\t\t\t\t\t\t\t  - curwin->w_topfill;\n#endif\n\t    get_scroll_overlap(&loff, 1);\n\n\t    if (loff.lnum >= curbuf->b_ml.ml_line_count)\n\t    {\n\t\tloff.lnum = curbuf->b_ml.ml_line_count;\n#ifdef FEAT_DIFF\n\t\tloff.fill = 0;\n\t    }\n\t    else\n\t    {\n\t\tbotline_topline(&loff);\n#endif\n\t    }\n\t    curwin->w_cursor.lnum = loff.lnum;\n\n\t    // Find the line just above the new topline to get the right line\n\t    // at the bottom of the window.\n\t    n = 0;\n\t    while (n <= curwin->w_height && loff.lnum >= 1)\n\t    {\n\t\ttopline_back(&loff);\n\t\tif (loff.height == MAXCOL)\n\t\t    n = MAXCOL;\n\t\telse\n\t\t    n += loff.height;\n\t    }\n\t    if (loff.lnum < 1)\t\t\t// at begin of file\n\t    {\n\t\tcurwin->w_topline = 1;\n#ifdef FEAT_DIFF\n\t\tmax_topfill();\n#endif\n\t\tcurwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);\n\t    }\n\t    else\n\t    {\n\t\t// Go two lines forward again.\n#ifdef FEAT_DIFF\n\t\ttopline_botline(&loff);\n#endif\n\t\tbotline_forw(&loff);\n\t\tbotline_forw(&loff);\n#ifdef FEAT_DIFF\n\t\tbotline_topline(&loff);\n#endif\n#ifdef FEAT_FOLDING\n\t\t// We're at the wrong end of a fold now.\n\t\t(void)hasFolding(loff.lnum, &loff.lnum, NULL);\n#endif\n\n\t\t// Always scroll at least one line.  Avoid getting stuck on\n\t\t// very long lines.\n\t\tif (loff.lnum >= curwin->w_topline\n#ifdef FEAT_DIFF\n\t\t\t&& (loff.lnum > curwin->w_topline\n\t\t\t    || loff.fill >= curwin->w_topfill)\n#endif\n\t\t\t)\n\t\t{\n#ifdef FEAT_DIFF\n\t\t    // First try using the maximum number of filler lines.  If\n\t\t    // that's not enough, backup one line.\n\t\t    loff.fill = curwin->w_topfill;\n\t\t    if (curwin->w_topfill < diff_check_fill(curwin,\n\t\t\t\t\t\t\t   curwin->w_topline))\n\t\t\tmax_topfill();\n\t\t    if (curwin->w_topfill == loff.fill)\n#endif\n\t\t    {\n\t\t\t--curwin->w_topline;\n#ifdef FEAT_DIFF\n\t\t\tcurwin->w_topfill = 0;\n#endif\n\t\t\tcurwin->w_valid &= ~(VALID_WROW|VALID_CROW);\n\t\t    }\n\t\t    comp_botline(curwin);\n\t\t    curwin->w_cursor.lnum = curwin->w_botline - 1;\n\t\t    curwin->w_valid &=\n\t\t\t    ~(VALID_WCOL|VALID_CHEIGHT|VALID_WROW|VALID_CROW);\n\t\t}\n\t\telse\n\t\t{\n\t\t    curwin->w_topline = loff.lnum;\n#ifdef FEAT_DIFF\n\t\t    curwin->w_topfill = loff.fill;\n\t\t    check_topfill(curwin, FALSE);\n#endif\n\t\t    curwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);\n\t\t}\n\t    }\n\t}\n    }\n#ifdef FEAT_FOLDING\n    foldAdjustCursor();\n#endif\n    cursor_correct();\n    check_cursor_col();\n    if (retval == OK)\n\tbeginline(BL_SOL | BL_FIX);\n    curwin->w_valid &= ~(VALID_WCOL|VALID_WROW|VALID_VIRTCOL);\n\n    if (retval == OK && dir == FORWARD)\n    {\n\t// Avoid the screen jumping up and down when 'scrolloff' is non-zero.\n\t// But make sure we scroll at least one line (happens with mix of long\n\t// wrapping lines and non-wrapping line).\n\tif (check_top_offset())\n\t{\n\t    scroll_cursor_top(1, FALSE);\n\t    if (curwin->w_topline <= old_topline\n\t\t\t\t  && old_topline < curbuf->b_ml.ml_line_count)\n\t    {\n\t\tcurwin->w_topline = old_topline + 1;\n#ifdef FEAT_FOLDING\n\t\t(void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n\t    }\n\t}\n#ifdef FEAT_FOLDING\n\telse if (curwin->w_botline > curbuf->b_ml.ml_line_count)\n\t    (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n    }\n\n    redraw_later(UPD_VALID);\n    return retval;\n}\n\n/*\n * Decide how much overlap to use for page-up or page-down scrolling.\n * This is symmetric, so that doing both keeps the same lines displayed.\n * Three lines are examined:\n *\n *  before CTRL-F\t    after CTRL-F / before CTRL-B\n *     etc.\t\t\tl1\n *  l1 last but one line\t------------\n *  l2 last text line\t\tl2 top text line\n *  -------------\t\tl3 second text line\n *  l3\t\t\t\t   etc.\n */\n    static void\nget_scroll_overlap(lineoff_T *lp, int dir)\n{\n    int\t\th1, h2, h3, h4;\n    int\t\tmin_height = curwin->w_height - 2;\n    lineoff_T\tloff0, loff1, loff2;\n\n#ifdef FEAT_DIFF\n    if (lp->fill > 0)\n\tlp->height = 1;\n    else\n\tlp->height = plines_nofill(lp->lnum);\n#else\n    lp->height = plines(lp->lnum);\n#endif\n    h1 = lp->height;\n    if (h1 > min_height)\n\treturn;\t\t// no overlap\n\n    loff0 = *lp;\n    if (dir > 0)\n\tbotline_forw(lp);\n    else\n\ttopline_back(lp);\n    h2 = lp->height;\n    if (h2 == MAXCOL || h2 + h1 > min_height)\n    {\n\t*lp = loff0;\t// no overlap\n\treturn;\n    }\n\n    loff1 = *lp;\n    if (dir > 0)\n\tbotline_forw(lp);\n    else\n\ttopline_back(lp);\n    h3 = lp->height;\n    if (h3 == MAXCOL || h3 + h2 > min_height)\n    {\n\t*lp = loff0;\t// no overlap\n\treturn;\n    }\n\n    loff2 = *lp;\n    if (dir > 0)\n\tbotline_forw(lp);\n    else\n\ttopline_back(lp);\n    h4 = lp->height;\n    if (h4 == MAXCOL || h4 + h3 + h2 > min_height || h3 + h2 + h1 > min_height)\n\t*lp = loff1;\t// 1 line overlap\n    else\n\t*lp = loff2;\t// 2 lines overlap\n}\n\n/*\n * Scroll 'scroll' lines up or down.\n */\n    void\nhalfpage(int flag, linenr_T Prenum)\n{\n    long\tscrolled = 0;\n    int\t\ti;\n    int\t\tn;\n    int\t\troom;\n\n    if (Prenum)\n\tcurwin->w_p_scr = (Prenum > curwin->w_height) ?\n\t\t\t\t\t\tcurwin->w_height : Prenum;\n    n = (curwin->w_p_scr <= curwin->w_height) ?\n\t\t\t\t    curwin->w_p_scr : curwin->w_height;\n\n    update_topline();\n    validate_botline();\n    room = curwin->w_empty_rows;\n#ifdef FEAT_DIFF\n    room += curwin->w_filler_rows;\n#endif\n    if (flag)\n    {\n\t/*\n\t * scroll the text up\n\t */\n\twhile (n > 0 && curwin->w_botline <= curbuf->b_ml.ml_line_count)\n\t{\n#ifdef FEAT_DIFF\n\t    if (curwin->w_topfill > 0)\n\t    {\n\t\ti = 1;\n\t\t--n;\n\t\t--curwin->w_topfill;\n\t    }\n\t    else\n#endif\n\t    {\n\t\ti = PLINES_NOFILL(curwin->w_topline);\n\t\tn -= i;\n\t\tif (n < 0 && scrolled > 0)\n\t\t    break;\n#ifdef FEAT_FOLDING\n\t\t(void)hasFolding(curwin->w_topline, NULL, &curwin->w_topline);\n#endif\n\t\t++curwin->w_topline;\n#ifdef FEAT_DIFF\n\t\tcurwin->w_topfill = diff_check_fill(curwin, curwin->w_topline);\n#endif\n\n\t\tif (curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t\t{\n\t\t    ++curwin->w_cursor.lnum;\n\t\t    curwin->w_valid &=\n\t\t\t\t    ~(VALID_VIRTCOL|VALID_CHEIGHT|VALID_WCOL);\n\t\t}\n\t    }\n\t    curwin->w_valid &= ~(VALID_CROW|VALID_WROW);\n\t    scrolled += i;\n\n\t    /*\n\t     * Correct w_botline for changed w_topline.\n\t     * Won't work when there are filler lines.\n\t     */\n#ifdef FEAT_DIFF\n\t    if (curwin->w_p_diff)\n\t\tcurwin->w_valid &= ~(VALID_BOTLINE|VALID_BOTLINE_AP);\n\t    else\n#endif\n\t    {\n\t\troom += i;\n\t\tdo\n\t\t{\n\t\t    i = plines(curwin->w_botline);\n\t\t    if (i > room)\n\t\t\tbreak;\n#ifdef FEAT_FOLDING\n\t\t    (void)hasFolding(curwin->w_botline, NULL,\n\t\t\t\t\t\t\t  &curwin->w_botline);\n#endif\n\t\t    ++curwin->w_botline;\n\t\t    room -= i;\n\t\t} while (curwin->w_botline <= curbuf->b_ml.ml_line_count);\n\t    }\n\t}\n\n\t/*\n\t * When hit bottom of the file: move cursor down.\n\t */\n\tif (n > 0)\n\t{\n# ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\twhile (--n >= 0\n\t\t\t&& curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t\t{\n\t\t    (void)hasFolding(curwin->w_cursor.lnum, NULL,\n\t\t\t\t\t\t      &curwin->w_cursor.lnum);\n\t\t    ++curwin->w_cursor.lnum;\n\t\t}\n\t    }\n\t    else\n# endif\n\t\tcurwin->w_cursor.lnum += n;\n\t    check_cursor_lnum();\n\t}\n    }\n    else\n    {\n\t/*\n\t * scroll the text down\n\t */\n\twhile (n > 0 && curwin->w_topline > 1)\n\t{\n#ifdef FEAT_DIFF\n\t    if (curwin->w_topfill < diff_check_fill(curwin, curwin->w_topline))\n\t    {\n\t\ti = 1;\n\t\t--n;\n\t\t++curwin->w_topfill;\n\t    }\n\t    else\n#endif\n\t    {\n\t\ti = PLINES_NOFILL(curwin->w_topline - 1);\n\t\tn -= i;\n\t\tif (n < 0 && scrolled > 0)\n\t\t    break;\n\t\t--curwin->w_topline;\n#ifdef FEAT_FOLDING\n\t\t(void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n#ifdef FEAT_DIFF\n\t\tcurwin->w_topfill = 0;\n#endif\n\t    }\n\t    curwin->w_valid &= ~(VALID_CROW|VALID_WROW|\n\t\t\t\t\t      VALID_BOTLINE|VALID_BOTLINE_AP);\n\t    scrolled += i;\n\t    if (curwin->w_cursor.lnum > 1)\n\t    {\n\t\t--curwin->w_cursor.lnum;\n\t\tcurwin->w_valid &= ~(VALID_VIRTCOL|VALID_CHEIGHT|VALID_WCOL);\n\t    }\n\t}\n\n\t/*\n\t * When hit top of the file: move cursor up.\n\t */\n\tif (n > 0)\n\t{\n\t    if (curwin->w_cursor.lnum <= (linenr_T)n)\n\t\tcurwin->w_cursor.lnum = 1;\n\t    else\n# ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\twhile (--n >= 0 && curwin->w_cursor.lnum > 1)\n\t\t{\n\t\t    --curwin->w_cursor.lnum;\n\t\t    (void)hasFolding(curwin->w_cursor.lnum,\n\t\t\t\t\t\t&curwin->w_cursor.lnum, NULL);\n\t\t}\n\t    }\n\t    else\n# endif\n\t\tcurwin->w_cursor.lnum -= n;\n\t}\n    }\n# ifdef FEAT_FOLDING\n    // Move cursor to first line of closed fold.\n    foldAdjustCursor();\n# endif\n#ifdef FEAT_DIFF\n    check_topfill(curwin, !flag);\n#endif\n    cursor_correct();\n    beginline(BL_SOL | BL_FIX);\n    redraw_later(UPD_VALID);\n}\n\n    void\ndo_check_cursorbind(void)\n{\n    static win_T\t*prev_curwin = NULL;\n    static pos_T\tprev_cursor = {0, 0, 0};\n\n    if (curwin == prev_curwin && EQUAL_POS(curwin->w_cursor, prev_cursor))\n\treturn;\n    prev_curwin = curwin;\n    prev_cursor = curwin->w_cursor;\n\n    linenr_T\tline = curwin->w_cursor.lnum;\n    colnr_T\tcol = curwin->w_cursor.col;\n    colnr_T\tcoladd = curwin->w_cursor.coladd;\n    colnr_T\tcurswant = curwin->w_curswant;\n    int\t\tset_curswant = curwin->w_set_curswant;\n    win_T\t*old_curwin = curwin;\n    buf_T\t*old_curbuf = curbuf;\n    int\t\told_VIsual_select = VIsual_select;\n    int\t\told_VIsual_active = VIsual_active;\n\n    /*\n     * loop through the cursorbound windows\n     */\n    VIsual_select = VIsual_active = 0;\n    FOR_ALL_WINDOWS(curwin)\n    {\n\tcurbuf = curwin->w_buffer;\n\t// skip original window and windows with 'nocursorbind'\n\tif (curwin != old_curwin && curwin->w_p_crb)\n\t{\n# ifdef FEAT_DIFF\n\t    if (curwin->w_p_diff)\n\t\tcurwin->w_cursor.lnum =\n\t\t\t\t diff_get_corresponding_line(old_curbuf, line);\n\t    else\n# endif\n\t\tcurwin->w_cursor.lnum = line;\n\t    curwin->w_cursor.col = col;\n\t    curwin->w_cursor.coladd = coladd;\n\t    curwin->w_curswant = curswant;\n\t    curwin->w_set_curswant = set_curswant;\n\n\t    // Make sure the cursor is in a valid position.  Temporarily set\n\t    // \"restart_edit\" to allow the cursor to be beyond the EOL.\n\t    int restart_edit_save = restart_edit;\n\t    restart_edit = 'a';\n\t    check_cursor();\n\n\t    // Avoid a scroll here for the cursor position, 'scrollbind' is\n\t    // more important.\n\t    if (!curwin->w_p_scb)\n\t\tvalidate_cursor();\n\n\t    restart_edit = restart_edit_save;\n\t    // Correct cursor for multi-byte character.\n\t    if (has_mbyte)\n\t\tmb_adjust_cursor();\n\t    redraw_later(UPD_VALID);\n\n\t    // Only scroll when 'scrollbind' hasn't done this.\n\t    if (!curwin->w_p_scb)\n\t\tupdate_topline();\n\t    curwin->w_redr_status = TRUE;\n\t}\n    }\n\n    /*\n     * reset current-window\n     */\n    VIsual_select = old_VIsual_select;\n    VIsual_active = old_VIsual_active;\n    curwin = old_curwin;\n    curbuf = old_curbuf;\n}\n", "\" Test for 'scroll', 'scrolloff', 'smoothscroll', etc.\n\nsource check.vim\nsource screendump.vim\nsource mouse.vim\n\nfunc Test_reset_scroll()\n  let scr = &l:scroll\n\n  setlocal scroll=1\n  setlocal scroll&\n  call assert_equal(scr, &l:scroll)\n\n  setlocal scroll=1\n  setlocal scroll=0\n  call assert_equal(scr, &l:scroll)\n\n  try\n    execute 'setlocal scroll=' . (winheight(0) + 1)\n    \" not reached\n    call assert_false(1)\n  catch\n    call assert_exception('E49:')\n  endtry\n\n  split\n\n  let scr = &l:scroll\n\n  setlocal scroll=1\n  setlocal scroll&\n  call assert_equal(scr, &l:scroll)\n\n  setlocal scroll=1\n  setlocal scroll=0\n  call assert_equal(scr, &l:scroll)\n\n  quit!\nendfunc\n\nfunc Test_scolloff_even_line_count()\n  new\n  resize 6\n  setlocal scrolloff=3\n  call setline(1, range(20))\n  normal 2j\n  call assert_equal(1, getwininfo(win_getid())[0].topline)\n  normal j\n  call assert_equal(1, getwininfo(win_getid())[0].topline)\n  normal j\n  call assert_equal(2, getwininfo(win_getid())[0].topline)\n  normal j\n  call assert_equal(3, getwininfo(win_getid())[0].topline)\n\n  bwipe!\nendfunc\n\nfunc Test_mouse_scroll_inactive_with_cursorbind()\n  for scb in [0, 1]\n    for so in [0, 1, 2]\n      let msg = $'scb={scb} so={so}'\n\n      new | only\n      let w1 = win_getid()\n      setlocal cursorbind\n      let &l:scb = scb\n      let &l:so = so\n      call setline(1, range(101, 109))\n      rightbelow vnew\n      let w2 = win_getid()\n      setlocal cursorbind\n      let &l:scb = scb\n      let &l:so = so\n      call setline(1, range(101, 109))\n\n      normal! $\n      call assert_equal(3, col('.', w1), msg)\n      call assert_equal(3, col('.', w2), msg)\n      call test_setmouse(1, 1)\n      call feedkeys(\"\\<ScrollWheelDown>\", 'xt')\n      call assert_equal(4, line('w0', w1), msg)\n      call assert_equal(4 + so, line('.', w1), msg)\n      call assert_equal(1, line('w0', w2), msg)\n      call assert_equal(1, line('.', w2), msg)\n      call feedkeys(\"\\<ScrollWheelDown>\", 'xt')\n      call assert_equal(7, line('w0', w1), msg)\n      call assert_equal(7 + so, line('.', w1), msg)\n      call assert_equal(1, line('w0', w2), msg)\n      call assert_equal(1, line('.', w2), msg)\n      call feedkeys(\"\\<ScrollWheelUp>\", 'xt')\n      call assert_equal(4, line('w0', w1), msg)\n      call assert_equal(7 + so, line('.', w1), msg)\n      call assert_equal(1, line('w0', w2), msg)\n      call assert_equal(1, line('.', w2), msg)\n      call feedkeys(\"\\<ScrollWheelUp>\", 'xt')\n      call assert_equal(1, line('w0', w1), msg)\n      call assert_equal(7 + so, line('.', w1), msg)\n      call assert_equal(1, line('w0', w2), msg)\n      call assert_equal(1, line('.', w2), msg)\n      normal! 0\n      call assert_equal(1, line('.', w1), msg)\n      call assert_equal(1, col('.', w1), msg)\n      call assert_equal(1, line('.', w2), msg)\n      call assert_equal(1, col('.', w2), msg)\n\n      bwipe!\n      bwipe!\n    endfor\n  endfor\nendfunc\n\nfunc Test_CtrlE_CtrlY_stop_at_end()\n  enew\n  call setline(1, ['one', 'two'])\n  set number\n  exe \"normal \\<C-Y>\"\n  call assert_equal([\"  1 one   \"], ScreenLines(1, 10))\n  exe \"normal \\<C-E>\\<C-E>\\<C-E>\"\n  call assert_equal([\"  2 two   \"], ScreenLines(1, 10))\n\n  bwipe!\n  set nonumber\nendfunc\n\nfunc Test_smoothscroll_CtrlE_CtrlY()\n  CheckScreendump\n\n  let lines =<< trim END\n      vim9script\n      setline(1, [\n        'line one',\n        'word '->repeat(20),\n        'line three',\n        'long word '->repeat(7),\n        'line',\n        'line',\n        'line',\n      ])\n      set smoothscroll\n      :5\n  END\n  call writefile(lines, 'XSmoothScroll', 'D')\n  let buf = RunVimInTerminal('-S XSmoothScroll', #{rows: 12, cols: 40})\n\n  call term_sendkeys(buf, \"\\<C-E>\")\n  call VerifyScreenDump(buf, 'Test_smoothscroll_1', {})\n  call term_sendkeys(buf, \"\\<C-E>\")\n  call VerifyScreenDump(buf, 'Test_smoothscroll_2', {})\n  call term_sendkeys(buf, \"\\<C-E>\")\n  call VerifyScreenDump(buf, 'Test_smoothscroll_3', {})\n  call term_sendkeys(buf, \"\\<C-E>\")\n  call VerifyScreenDump(buf, 'Test_smoothscroll_4', {})\n\n  call term_sendkeys(buf, \"\\<C-Y>\")\n  call VerifyScreenDump(buf, 'Test_smoothscroll_5', {})\n  call term_sendkeys(buf, \"\\<C-Y>\")\n  call VerifyScreenDump(buf, 'Test_smoothscroll_6', {})\n  call term_sendkeys(buf, \"\\<C-Y>\")\n  call VerifyScreenDump(buf, 'Test_smoothscroll_7', {})\n  call term_sendkeys(buf, \"\\<C-Y>\")\n  call VerifyScreenDump(buf, 'Test_smoothscroll_8', {})\n\n  if has('folding')\n    call term_sendkeys(buf, \":set foldmethod=indent\\<CR>\")\n    \" move the cursor so we can reuse the same dumps\n    call term_sendkeys(buf, \"5G\")\n    call term_sendkeys(buf, \"\\<C-E>\")\n    call VerifyScreenDump(buf, 'Test_smoothscroll_1', {})\n    call term_sendkeys(buf, \"\\<C-E>\")\n    call VerifyScreenDump(buf, 'Test_smoothscroll_2', {})\n    call term_sendkeys(buf, \"7G\")\n    call term_sendkeys(buf, \"\\<C-Y>\")\n    call VerifyScreenDump(buf, 'Test_smoothscroll_7', {})\n    call term_sendkeys(buf, \"\\<C-Y>\")\n    call VerifyScreenDump(buf, 'Test_smoothscroll_8', {})\n  endif\n\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_smoothscroll_multibyte()\n  CheckScreendump\n\n  let lines =<< trim END\n      set scrolloff=0 smoothscroll\n      call setline(1, [repeat('\u03db', 45), repeat('2', 36)])\n      exe \"normal G35l\\<C-E>k\"\n  END\n  call writefile(lines, 'XSmoothMultibyte', 'D')\n  let buf = RunVimInTerminal('-S XSmoothMultibyte', #{rows: 6, cols: 40})\n  call VerifyScreenDump(buf, 'Test_smoothscroll_multi_1', {})\n\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_smoothscroll_number()\n  CheckScreendump\n\n  let lines =<< trim END\n      vim9script\n      setline(1, [\n        'one ' .. 'word '->repeat(20),\n        'two ' .. 'long word '->repeat(7),\n        'line',\n        'line',\n        'line',\n      ])\n      set smoothscroll\n      set splitkeep=topline\n      set number cpo+=n\n      :3\n\n      def g:DoRel()\n        set number relativenumber scrolloff=0\n        :%del\n        setline(1, [\n          'one',\n          'very long text '->repeat(12),\n          'three',\n        ])\n        exe \"normal 2Gzt\\<C-E>\"\n      enddef\n  END\n  call writefile(lines, 'XSmoothNumber', 'D')\n  let buf = RunVimInTerminal('-S XSmoothNumber', #{rows: 12, cols: 40})\n\n  call VerifyScreenDump(buf, 'Test_smooth_number_1', {})\n  call term_sendkeys(buf, \"\\<C-E>\")\n  call VerifyScreenDump(buf, 'Test_smooth_number_2', {})\n  call term_sendkeys(buf, \"\\<C-E>\")\n  call VerifyScreenDump(buf, 'Test_smooth_number_3', {})\n\n  call term_sendkeys(buf, \":set cpo-=n\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_smooth_number_4', {})\n  call term_sendkeys(buf, \"\\<C-Y>\")\n  call VerifyScreenDump(buf, 'Test_smooth_number_5', {})\n  call term_sendkeys(buf, \"\\<C-Y>\")\n  call VerifyScreenDump(buf, 'Test_smooth_number_6', {})\n\n  call term_sendkeys(buf, \":botright split\\<CR>gg\")\n  call VerifyScreenDump(buf, 'Test_smooth_number_7', {})\n  call term_sendkeys(buf, \"\\<C-E>\")\n  call VerifyScreenDump(buf, 'Test_smooth_number_8', {})\n  call term_sendkeys(buf, \"\\<C-E>\")\n  call VerifyScreenDump(buf, 'Test_smooth_number_9', {})\n  call term_sendkeys(buf, \":close\\<CR>\")\n\n  call term_sendkeys(buf, \":call DoRel()\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_smooth_number_10', {})\n\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_smoothscroll_list()\n  CheckScreendump\n\n  let lines =<< trim END\n      vim9script\n      set smoothscroll scrolloff=0\n      set list\n      setline(1, [\n        'one',\n        'very long text '->repeat(12),\n        'three',\n      ])\n      exe \"normal 2Gzt\\<C-E>\"\n  END\n  call writefile(lines, 'XSmoothList', 'D')\n  let buf = RunVimInTerminal('-S XSmoothList', #{rows: 8, cols: 40})\n\n  call VerifyScreenDump(buf, 'Test_smooth_list_1', {})\n\n  call term_sendkeys(buf, \":set listchars+=precedes:#\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_smooth_list_2', {})\n\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_smoothscroll_diff_mode()\n  CheckScreendump\n\n  let lines =<< trim END\n      vim9script\n      var text = 'just some text here'\n      setline(1, text)\n      set smoothscroll\n      diffthis\n      new\n      setline(1, text)\n      set smoothscroll\n      diffthis\n  END\n  call writefile(lines, 'XSmoothDiff', 'D')\n  let buf = RunVimInTerminal('-S XSmoothDiff', #{rows: 8})\n\n  call VerifyScreenDump(buf, 'Test_smooth_diff_1', {})\n  call term_sendkeys(buf, \"\\<C-Y>\")\n  call VerifyScreenDump(buf, 'Test_smooth_diff_1', {})\n  call term_sendkeys(buf, \"\\<C-E>\")\n  call VerifyScreenDump(buf, 'Test_smooth_diff_1', {})\n\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_smoothscroll_wrap_scrolloff_zero()\n  CheckScreendump\n\n  let lines =<< trim END\n      vim9script\n      setline(1, ['Line' .. (' with some text'->repeat(7))]->repeat(7))\n      set smoothscroll scrolloff=0\n      :3\n  END\n  call writefile(lines, 'XSmoothWrap', 'D')\n  let buf = RunVimInTerminal('-S XSmoothWrap', #{rows: 8, cols: 40})\n\n  call VerifyScreenDump(buf, 'Test_smooth_wrap_1', {})\n\n  \" moving cursor down - whole bottom line shows\n  call term_sendkeys(buf, \"j\")\n  call VerifyScreenDump(buf, 'Test_smooth_wrap_2', {})\n\n  call term_sendkeys(buf, \"\\<C-E>j\")\n  call VerifyScreenDump(buf, 'Test_smooth_wrap_3', {})\n\n  call term_sendkeys(buf, \"G\")\n  call VerifyScreenDump(buf, 'Test_smooth_wrap_4', {})\n\n  call term_sendkeys(buf, \"4\\<C-Y>G\")\n  call VerifyScreenDump(buf, 'Test_smooth_wrap_4', {})\n\n  \" moving cursor up right after the <<< marker - no need to show whole line\n  call term_sendkeys(buf, \"2gj3l2k\")\n  call VerifyScreenDump(buf, 'Test_smooth_wrap_5', {})\n\n  \" moving cursor up where the <<< marker is - whole top line shows\n  call term_sendkeys(buf, \"2j02k\")\n  call VerifyScreenDump(buf, 'Test_smooth_wrap_6', {})\n\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_smoothscroll_wrap_long_line()\n  CheckScreendump\n\n  let lines =<< trim END\n      vim9script\n      setline(1, ['one', 'two', 'Line' .. (' with lots of text'->repeat(30)) .. ' end', 'four'])\n      set smoothscroll scrolloff=0\n      normal 3G10|zt\n  END\n  call writefile(lines, 'XSmoothWrap', 'D')\n  let buf = RunVimInTerminal('-S XSmoothWrap', #{rows: 6, cols: 40})\n  call VerifyScreenDump(buf, 'Test_smooth_long_1', {})\n\n  \" scrolling up, cursor moves screen line down\n  call term_sendkeys(buf, \"\\<C-E>\")\n  call VerifyScreenDump(buf, 'Test_smooth_long_2', {})\n  call term_sendkeys(buf, \"5\\<C-E>\")\n  call VerifyScreenDump(buf, 'Test_smooth_long_3', {})\n\n  \" scrolling down, cursor moves screen line up\n  call term_sendkeys(buf, \"5\\<C-Y>\")\n  call VerifyScreenDump(buf, 'Test_smooth_long_4', {})\n  call term_sendkeys(buf, \"\\<C-Y>\")\n  call VerifyScreenDump(buf, 'Test_smooth_long_5', {})\n\n  \" 'scrolloff' set to 1, scrolling up, cursor moves screen line down\n  call term_sendkeys(buf, \":set scrolloff=1\\<CR>\")\n  call term_sendkeys(buf, \"10|\\<C-E>\")\n  call VerifyScreenDump(buf, 'Test_smooth_long_6', {})\n\n  \" 'scrolloff' set to 1, scrolling down, cursor moves screen line up\n  call term_sendkeys(buf, \"\\<C-E>\")\n  call term_sendkeys(buf, \"gjgj\")\n  call term_sendkeys(buf, \"\\<C-Y>\")\n  call VerifyScreenDump(buf, 'Test_smooth_long_7', {})\n\n  \" 'scrolloff' set to 2, scrolling up, cursor moves screen line down\n  call term_sendkeys(buf, \":set scrolloff=2\\<CR>\")\n  call term_sendkeys(buf, \"10|\\<C-E>\")\n  call VerifyScreenDump(buf, 'Test_smooth_long_8', {})\n\n  \" 'scrolloff' set to 2, scrolling down, cursor moves screen line up\n  call term_sendkeys(buf, \"\\<C-E>\")\n  call term_sendkeys(buf, \"gj\")\n  call term_sendkeys(buf, \"\\<C-Y>\")\n  call VerifyScreenDump(buf, 'Test_smooth_long_9', {})\n\n  \" 'scrolloff' set to 0, move cursor down one line.\n  \" Cursor should move properly, and since this is a really long line, it will\n  \" be put on top of the screen.\n  call term_sendkeys(buf, \":set scrolloff=0\\<CR>\")\n  call term_sendkeys(buf, \"0j\")\n  call VerifyScreenDump(buf, 'Test_smooth_long_10', {})\n\n  \" Test zt/zz/zb that they work properly when a long line is above it\n  call term_sendkeys(buf, \"zt\")\n  call VerifyScreenDump(buf, 'Test_smooth_long_11', {})\n  call term_sendkeys(buf, \"zz\")\n  call VerifyScreenDump(buf, 'Test_smooth_long_12', {})\n  call term_sendkeys(buf, \"zb\")\n  call VerifyScreenDump(buf, 'Test_smooth_long_13', {})\n\n  \" Repeat the step and move the cursor down again.\n  \" This time, use a shorter long line that is barely long enough to span more\n  \" than one window. Note that the cursor is at the bottom this time because\n  \" Vim prefers to do so if we are scrolling a few lines only.\n  call term_sendkeys(buf, \":call setline(1, ['one', 'two', 'Line' .. (' with lots of text'->repeat(10)) .. ' end', 'four'])\\<CR>\")\n  \" Currently visible lines were replaced, test that the lines and cursor\n  \" are correctly displayed.\n  call VerifyScreenDump(buf, 'Test_smooth_long_14', {})\n  call term_sendkeys(buf, \"3Gzt\")\n  call term_sendkeys(buf, \"j\")\n  call VerifyScreenDump(buf, 'Test_smooth_long_15', {})\n\n  \" Repeat the step but this time start it when the line is smooth-scrolled by\n  \" one line. This tests that the offset calculation is still correct and\n  \" still end up scrolling down to the next line with cursor at bottom of\n  \" screen.\n  call term_sendkeys(buf, \"3Gzt\")\n  call term_sendkeys(buf, \"\\<C-E>j\")\n  call VerifyScreenDump(buf, 'Test_smooth_long_16', {})\n\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_smoothscroll_one_long_line()\n  CheckScreendump\n\n  let lines =<< trim END\n      vim9script\n      setline(1, 'with lots of text '->repeat(7))\n      set smoothscroll scrolloff=0\n  END\n  call writefile(lines, 'XSmoothOneLong', 'D')\n  let buf = RunVimInTerminal('-S XSmoothOneLong', #{rows: 6, cols: 40})\n  call VerifyScreenDump(buf, 'Test_smooth_one_long_1', {})\n\n  call term_sendkeys(buf, \"\\<C-E>\")\n  call VerifyScreenDump(buf, 'Test_smooth_one_long_2', {})\n\n  call term_sendkeys(buf, \"0\")\n  call VerifyScreenDump(buf, 'Test_smooth_one_long_1', {})\n\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_smoothscroll_long_line_showbreak()\n  CheckScreendump\n\n  let lines =<< trim END\n      vim9script\n      # a line that spans four screen lines\n      setline(1, 'with lots of text in one line '->repeat(6))\n      set smoothscroll scrolloff=0 showbreak=+++\\ \n  END\n  call writefile(lines, 'XSmoothLongShowbreak', 'D')\n  let buf = RunVimInTerminal('-S XSmoothLongShowbreak', #{rows: 6, cols: 40})\n  call VerifyScreenDump(buf, 'Test_smooth_long_showbreak_1', {})\n\n  call term_sendkeys(buf, \"\\<C-E>\")\n  call VerifyScreenDump(buf, 'Test_smooth_long_showbreak_2', {})\n\n  call term_sendkeys(buf, \"0\")\n  call VerifyScreenDump(buf, 'Test_smooth_long_showbreak_1', {})\n\n  call StopVimInTerminal(buf)\nendfunc\n\n\" Check that 'smoothscroll' marker is drawn over double-width char correctly.\n\" Run with multiple encodings.\nfunc Test_smoothscroll_marker_over_double_width()\n  \" Run this in a separate Vim instance to avoid messing up.\n  let after =<< trim [CODE]\n    scriptencoding utf-8\n    call setline(1, 'a'->repeat(&columns) .. '\u53e3'->repeat(10))\n    setlocal smoothscroll\n    redraw\n    exe \"norm \\<C-E>\"\n    redraw\n    \" Check the chars one by one. Don't check the whole line concatenated.\n    call assert_equal('<', screenstring(1, 1))\n    call assert_equal('<', screenstring(1, 2))\n    call assert_equal('<', screenstring(1, 3))\n    call assert_equal(' ', screenstring(1, 4))\n    call assert_equal('\u53e3', screenstring(1, 5))\n    call assert_equal('\u53e3', screenstring(1, 7))\n    call assert_equal('\u53e3', screenstring(1, 9))\n    call assert_equal('\u53e3', screenstring(1, 11))\n    call assert_equal('\u53e3', screenstring(1, 13))\n    call assert_equal('\u53e3', screenstring(1, 15))\n    call writefile(v:errors, 'Xresult')\n    qall!\n  [CODE]\n\n  let encodings = ['utf-8', 'cp932', 'cp936', 'cp949', 'cp950']\n  if !has('win32')\n    let encodings += ['euc-jp']\n  endif\n  for enc in encodings\n    let msg = 'enc=' .. enc\n    if RunVim([], after, $'--clean --cmd \"set encoding={enc}\"')\n      call assert_equal([], readfile('Xresult'), msg)\n    endif\n    call delete('Xresult')\n  endfor\nendfunc\n\n\" Same as the test above, but check the text actually shown on screen.\n\" Only run with UTF-8 encoding.\nfunc Test_smoothscroll_marker_over_double_width_dump()\n  CheckScreendump\n\n  let lines =<< trim END\n    call setline(1, 'a'->repeat(&columns) .. '\u53e3'->repeat(10))\n    setlocal smoothscroll\n  END\n  call writefile(lines, 'XSmoothMarkerOverDoubleWidth', 'D')\n  let buf = RunVimInTerminal('-S XSmoothMarkerOverDoubleWidth', #{rows: 6, cols: 40})\n  call VerifyScreenDump(buf, 'Test_smooth_marker_over_double_width_1', {})\n\n  call term_sendkeys(buf, \"\\<C-E>\")\n  call VerifyScreenDump(buf, 'Test_smooth_marker_over_double_width_2', {})\n\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc s:check_col_calc(win_col, win_line, buf_col)\n  call assert_equal(a:win_col, wincol())\n  call assert_equal(a:win_line, winline())\n  call assert_equal(a:buf_col, col('.'))\nendfunc\n\n\" Test that if the current cursor is on a smooth scrolled line, we correctly\n\" reposition it. Also check that we don't miscalculate the values by checking\n\" the consistency between wincol() and col('.') as they are calculated\n\" separately in code.\nfunc Test_smoothscroll_cursor_position()\n  call NewWindow(10, 20)\n  setl smoothscroll wrap\n  call setline(1, \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n\n  call s:check_col_calc(1, 1, 1)\n  exe \"normal \\<C-E>\"\n\n  \" Move down another line to avoid blocking the <<< display\n  call s:check_col_calc(1, 2, 41)\n  exe \"normal \\<C-Y>\"\n  call s:check_col_calc(1, 3, 41)\n\n  \" Test \"g0/g<Home>\"\n  exe \"normal gg\\<C-E>\"\n  norm $gkg0\n  call s:check_col_calc(1, 2, 21)\n\n  \" Test moving the cursor behind the <<< display with 'virtualedit'\n  set virtualedit=all\n  exe \"normal \\<C-E>3lgkh\"\n  call s:check_col_calc(3, 2, 23)\n  set virtualedit&\n\n  normal gg3l\n  exe \"normal \\<C-E>\"\n\n  \" Move down only 1 line when we are out of the range of the <<< display\n  call s:check_col_calc(4, 1, 24)\n  exe \"normal \\<C-Y>\"\n  call s:check_col_calc(4, 2, 24)\n  normal ggg$\n  exe \"normal \\<C-E>\"\n  call s:check_col_calc(20, 1, 40)\n  exe \"normal \\<C-Y>\"\n  call s:check_col_calc(20, 2, 40)\n  normal gg\n\n  \" Test number, where we have indented lines\n  setl number\n  call s:check_col_calc(5, 1, 1)\n  exe \"normal \\<C-E>\"\n\n  \" Move down only 1 line when the <<< display is on the number column\n  call s:check_col_calc(5, 1, 17)\n  exe \"normal \\<C-Y>\"\n  call s:check_col_calc(5, 2, 17)\n  normal ggg$\n  exe \"normal \\<C-E>\"\n  call s:check_col_calc(20, 1, 32)\n  exe \"normal \\<C-Y>\"\n  call s:check_col_calc(20, 2, 32)\n  normal gg\n\n  setl numberwidth=1\n\n  \" Move down another line when numberwidth is too short to cover the whole\n  \" <<< display\n  call s:check_col_calc(3, 1, 1)\n  exe \"normal \\<C-E>\"\n  call s:check_col_calc(3, 2, 37)\n  exe \"normal \\<C-Y>\"\n  call s:check_col_calc(3, 3, 37)\n  normal ggl\n\n  \" Only move 1 line down when we are just past the <<< display\n  call s:check_col_calc(4, 1, 2)\n  exe \"normal \\<C-E>\"\n  call s:check_col_calc(4, 1, 20)\n  exe \"normal \\<C-Y>\"\n  call s:check_col_calc(4, 2, 20)\n  normal gg\n  setl numberwidth&\n\n  \" Test number + showbreak, so test that the additional indentation works\n  setl number showbreak=+++\n  call s:check_col_calc(5, 1, 1)\n  exe \"normal \\<C-E>\"\n  call s:check_col_calc(8, 1, 17)\n  exe \"normal \\<C-Y>\"\n  call s:check_col_calc(8, 2, 17)\n  normal gg\n\n  \" Test number + cpo+=n mode, where wrapped lines aren't indented\n  setl number cpo+=n showbreak=\n  call s:check_col_calc(5, 1, 1)\n  exe \"normal \\<C-E>\"\n  call s:check_col_calc(1, 2, 37)\n  exe \"normal \\<C-Y>\"\n  call s:check_col_calc(1, 3, 37)\n  normal gg\n\n  \" Test list + listchars \"precedes\", where there is always 1 overlap\n  \" regardless of number and cpo-=n.\n  setl number list listchars=precedes:< cpo-=n\n  call s:check_col_calc(5, 1, 1)\n  exe \"normal 3|\\<C-E>h\"\n  call s:check_col_calc(6, 1, 18)\n  norm h\n  call s:check_col_calc(5, 2, 17)\n  normal gg\n\n  bwipe!\nendfunc\n\nfunc Test_smoothscroll_cursor_scrolloff()\n  call NewWindow(10, 20)\n  setl smoothscroll wrap\n  setl scrolloff=3\n\n  \" 120 chars are 6 screen lines\n  call setline(1, \"abcdefghijklmnopqrstABCDEFGHIJKLMNOPQRSTabcdefghijklmnopqrstABCDEFGHIJKLMNOPQRSTabcdefghijklmnopqrstABCDEFGHIJKLMNOPQRST\")\n  call setline(2, \"below\")\n\n  call s:check_col_calc(1, 1, 1)\n\n  \" CTRL-E shows \"<<<DEFG...\", cursor move four lines down\n  exe \"normal \\<C-E>\"\n  call s:check_col_calc(1, 4, 81)\n\n  \" cursor on start of second line, \"gk\" moves into first line, skipcol doesn't\n  \" change\n  exe \"normal G0gk\"\n  call s:check_col_calc(1, 5, 101)\n\n  \" move cursor left one window width worth, scrolls one screen line\n  exe \"normal 20h\"\n  call s:check_col_calc(1, 5, 81)\n\n  \" move cursor left one window width worth, scrolls one screen line\n  exe \"normal 20h\"\n  call s:check_col_calc(1, 4, 61)\n\n  \" cursor on last line, \"gk\" should not cause a scroll\n  set scrolloff=0\n  normal G0\n  call s:check_col_calc(1, 7, 1)\n  normal gk\n  call s:check_col_calc(1, 6, 101)\n\n  bwipe!\nendfunc\n\n\n\" Test that mouse picking is still accurate when we have smooth scrolled lines\nfunc Test_smoothscroll_mouse_pos()\n  CheckNotGui\n  CheckUnix\n\n  let save_mouse = &mouse\n  let save_term = &term\n  let save_ttymouse = &ttymouse\n  set mouse=a term=xterm ttymouse=xterm2\n\n  call NewWindow(10, 20)\n  setl smoothscroll wrap\n  \" First line will wrap to 3 physical lines. 2nd/3rd lines are short lines.\n  call setline(1, [\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\", \"line 2\", \"line 3\"])\n\n  func s:check_mouse_click(row, col, buf_row, buf_col)\n    call MouseLeftClick(a:row, a:col)\n\n    call assert_equal(a:col, wincol())\n    call assert_equal(a:row, winline())\n    call assert_equal(a:buf_row, line('.'))\n    call assert_equal(a:buf_col, col('.'))\n  endfunc\n\n  \" Check that clicking without scroll works first.\n  call s:check_mouse_click(3, 5, 1, 45)\n  call s:check_mouse_click(4, 1, 2, 1)\n  call s:check_mouse_click(4, 6, 2, 6)\n  call s:check_mouse_click(5, 1, 3, 1)\n  call s:check_mouse_click(5, 6, 3, 6)\n\n  \" Smooth scroll, and checks that this didn't mess up mouse clicking\n  exe \"normal \\<C-E>\"\n  call s:check_mouse_click(2, 5, 1, 45)\n  call s:check_mouse_click(3, 1, 2, 1)\n  call s:check_mouse_click(3, 6, 2, 6)\n  call s:check_mouse_click(4, 1, 3, 1)\n  call s:check_mouse_click(4, 6, 3, 6)\n\n  exe \"normal \\<C-E>\"\n  call s:check_mouse_click(1, 5, 1, 45)\n  call s:check_mouse_click(2, 1, 2, 1)\n  call s:check_mouse_click(2, 6, 2, 6)\n  call s:check_mouse_click(3, 1, 3, 1)\n  call s:check_mouse_click(3, 6, 3, 6)\n\n  \" Make a new first line 11 physical lines tall so it's taller than window\n  \" height, to test overflow calculations with really long lines wrapping.\n  normal gg\n  call setline(1, \"12345678901234567890\"->repeat(11))\n  exe \"normal 6\\<C-E>\"\n  call s:check_mouse_click(5, 1, 1, 201)\n  call s:check_mouse_click(6, 1, 2, 1)\n  call s:check_mouse_click(7, 1, 3, 1)\n\n  let &mouse = save_mouse\n  let &term = save_term\n  let &ttymouse = save_ttymouse\nendfunc\n\n\" this was dividing by zero\nfunc Test_smoothscroll_zero_width()\n  CheckScreendump\n\n  let lines =<< trim END\n      winsize 0 0\n      vsplit\n      vsplit\n      vsplit\n      vsplit\n      vsplit\n      sil norm \u0017\u000e\u0017H\n      set wrap\n      set smoothscroll\n      set number\n  END\n  call writefile(lines, 'XSmoothScrollZero', 'D')\n  let buf = RunVimInTerminal('-u NONE -i NONE -n -m -X -Z -e -s -S XSmoothScrollZero', #{rows: 6, cols: 60, wait_for_ruler: 0})\n  call VerifyScreenDump(buf, 'Test_smoothscroll_zero_1', {})\n\n  call term_sendkeys(buf, \":sil norm \\<C-V>\\<C-W>\\<C-V>\\<C-N>\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_smoothscroll_zero_2', {})\n\n  call StopVimInTerminal(buf)\nendfunc\n\n\" this was unnecessarily inserting lines\nfunc Test_smoothscroll_ins_lines()\n  CheckScreendump\n\n  let lines =<< trim END\n      set wrap\n      set smoothscroll\n      set scrolloff=0\n      set conceallevel=2\n      call setline(1, [\n        \\'line one' .. 'with lots of text in one line '->repeat(2),\n        \\'line two',\n        \\'line three',\n        \\'line four',\n        \\'line five'\n      \\])\n  END\n  call writefile(lines, 'XSmoothScrollInsLines', 'D')\n  let buf = RunVimInTerminal('-S XSmoothScrollInsLines', #{rows: 6, cols: 40})\n\n  call term_sendkeys(buf, \"\\<C-E>gjgk\")\n  call VerifyScreenDump(buf, 'Test_smooth_ins_lines', {})\n\n  call StopVimInTerminal(buf)\nendfunc\n\n\" this placed the cursor in the command line\nfunc Test_smoothscroll_cursormoved_line()\n  CheckScreendump\n\n  let lines =<< trim END\n      set smoothscroll\n      call setline(1, [\n        \\'',\n        \\'_'->repeat(&lines * &columns),\n        \\(('_')->repeat(&columns - 2) .. 'xxx')->repeat(2)\n      \\])\n      autocmd CursorMoved * eval [line('w0'), line('w$')]\n      call search('xxx')\n  END\n  call writefile(lines, 'XSmoothCursorMovedLine', 'D')\n  let buf = RunVimInTerminal('-S XSmoothCursorMovedLine', #{rows: 6})\n\n  call VerifyScreenDump(buf, 'Test_smooth_cursormoved_line', {})\n\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_smoothscroll_eob()\n  CheckScreendump\n\n  let lines =<< trim END\n      set smoothscroll\n      call setline(1, ['']->repeat(100))\n      norm G\n  END\n  call writefile(lines, 'XSmoothEob', 'D')\n  let buf = RunVimInTerminal('-S XSmoothEob', #{rows: 10})\n\n  \" does not scroll halfway when scrolling to end of buffer\n  call VerifyScreenDump(buf, 'Test_smooth_eob_1', {})\n\n  \" cursor is not placed below window\n  call term_sendkeys(buf, \":call setline(92, 'a'->repeat(100))\\<CR>\\<C-B>G\")\n  call VerifyScreenDump(buf, 'Test_smooth_eob_2', {})\n\n  call StopVimInTerminal(buf)\nendfunc\n\n\" skipcol should not reset when doing incremental search on the same word\nfunc Test_smoothscroll_incsearch()\n  CheckScreendump\n\n  let lines =<< trim END\n      set smoothscroll number scrolloff=0 incsearch\n      call setline(1, repeat([''], 20))\n      call setline(11, repeat('a', 100))\n      call setline(14, 'bbbb')\n  END\n  call writefile(lines, 'XSmoothIncsearch', 'D')\n  let buf = RunVimInTerminal('-S XSmoothIncsearch', #{rows: 8, cols: 40})\n\n  call term_sendkeys(buf, \"/b\")\n  call VerifyScreenDump(buf, 'Test_smooth_incsearch_1', {})\n  call term_sendkeys(buf, \"b\")\n  call VerifyScreenDump(buf, 'Test_smooth_incsearch_2', {})\n  call term_sendkeys(buf, \"b\")\n  call VerifyScreenDump(buf, 'Test_smooth_incsearch_3', {})\n  call term_sendkeys(buf, \"b\")\n  call VerifyScreenDump(buf, 'Test_smooth_incsearch_4', {})\n  call term_sendkeys(buf, \"\\<CR>\")\n\n  call StopVimInTerminal(buf)\nendfunc\n\n\" Test scrolling multiple lines and stopping at non-zero skipcol.\nfunc Test_smoothscroll_multi_skipcol()\n  CheckScreendump\n\n  let lines =<< trim END\n      setlocal cursorline scrolloff=0 smoothscroll\n      call setline(1, repeat([''], 8))\n      call setline(3, repeat('a', 50))\n      call setline(4, repeat('a', 50))\n      call setline(7, 'bbb')\n      call setline(8, 'ccc')\n      redraw\n  END\n  call writefile(lines, 'XSmoothMultiSkipcol', 'D')\n  let buf = RunVimInTerminal('-S XSmoothMultiSkipcol', #{rows: 10, cols: 40})\n  call VerifyScreenDump(buf, 'Test_smooth_multi_skipcol_1', {})\n\n  call term_sendkeys(buf, \"3\\<C-E>\")\n  call VerifyScreenDump(buf, 'Test_smooth_multi_skipcol_2', {})\n\n  call term_sendkeys(buf, \"2\\<C-E>\")\n  call VerifyScreenDump(buf, 'Test_smooth_multi_skipcol_3', {})\n\n  call StopVimInTerminal(buf)\nendfunc\n\n\" this was dividing by zero bug in scroll_cursor_bot\nfunc Test_smoothscroll_zero_width_scroll_cursor_bot()\n  CheckScreendump\n\n  let lines =<< trim END\n      silent normal yy\n      silent normal 19p\n      set cpoptions+=n\n      vsplit\n      vertical resize 0\n      set foldcolumn=1\n      set number\n      set smoothscroll\n      silent normal 20G\n  END\n  call writefile(lines, 'XSmoothScrollZeroBot', 'D')\n  let buf = RunVimInTerminal('-u NONE -S XSmoothScrollZeroBot', #{rows: 19})\n  call VerifyScreenDump(buf, 'Test_smoothscroll_zero_bot', {})\n\n  call StopVimInTerminal(buf)\nendfunc\n\n\" scroll_cursor_top() should reset skipcol when it changes topline\nfunc Test_smoothscroll_cursor_top()\n  CheckScreendump\n\n  let lines =<< trim END\n      set smoothscroll scrolloff=2\n      new | 11resize | wincmd j\n      call setline(1, ['line1', 'line2', 'line3'->repeat(20), 'line4'])\n      exe \"norm G3\\<C-E>k\"\n  END\n  call writefile(lines, 'XSmoothScrollCursorTop', 'D')\n  let buf = RunVimInTerminal('-u NONE -S XSmoothScrollCursorTop', #{rows: 12, cols:40})\n  call VerifyScreenDump(buf, 'Test_smoothscroll_cursor_top', {})\n\n  call StopVimInTerminal(buf)\nendfunc\n\n\" Division by zero, shouldn't crash\nfunc Test_smoothscroll_crash()\n  CheckScreendump\n\n  let lines =<< trim END\n      20 new\n      vsp\n      put =repeat('aaaa', 20)\n      set nu fdc=1  smoothscroll cpo+=n\n      vert resize 0\n      exe \"norm! 0\\<c-e>\"\n  END\n  call writefile(lines, 'XSmoothScrollCrash', 'D')\n  let buf = RunVimInTerminal('-u NONE -S XSmoothScrollCrash', #{rows: 12, cols:40})\n  call term_sendkeys(buf, \"2\\<C-E>\\<C-L>\")\n\n  call StopVimInTerminal(buf)\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion != NULL)\n\treturn;\n\n#ifdef BUILD_DATE\n    char *date_time = BUILD_DATE;\n#else\n    char *date_time = __DATE__ \" \" __TIME__;\n#endif\n    char *msg = _(\"%s (%s, compiled %s)\");\n    size_t len = strlen(msg)\n\t+ strlen(VIM_VERSION_LONG_ONLY)\n\t+ strlen(VIM_VERSION_DATE_ONLY)\n\t+ strlen(date_time);\n\n    longVersion = alloc(len);\n    if (longVersion == NULL)\n\tlongVersion = VIM_VERSION_LONG;\n    else\n\tvim_snprintf(longVersion, len, msg,\n\t\tVIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n\t\"+cmdline_info\",\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n\t\"+float\",\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n#  ifdef DYNAMIC_PYTHON3_STABLE_ABI\n\t\"+python3/dyn-stable\",\n#  else\n\t\"+python3/dyn\",\n#  endif\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n# ifdef FEAT_XATTR\n\t\"+xattr\",\n# else\n\t\"-xattr\",\n# endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/move.c", "src/testdir/test_scroll_opt.vim", "src/version.c"], "buggy_code_start_loc": [48, 928, 706], "buggy_code_end_loc": [50, 928, 706], "fixing_code_start_loc": [48, 929, 707], "fixing_code_end_loc": [51, 948, 709], "type": "CWE-755", "message": "Vim is an open source command line text editor. A floating point exception may occur when calculating the line offset for overlong lines and smooth scrolling is enabled and the cpo-settings include the 'n' flag. This may happen when a window border is present and when the wrapped line continues on the next physical line directly in the window border because the 'cpo' setting includes the 'n' flag. Only users with non-default settings are affected and the exception should only result in a crash. This issue has been addressed in commit `cb0b99f0` which has been included in release version 9.0.2107. Users are advised to upgrade. There are no known workarounds for this vulnerability.", "other": {"cve": {"id": "CVE-2023-48232", "sourceIdentifier": "security-advisories@github.com", "published": "2023-11-16T23:15:08.793", "lastModified": "2024-01-25T21:37:57.007", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Vim is an open source command line text editor. A floating point exception may occur when calculating the line offset for overlong lines and smooth scrolling is enabled and the cpo-settings include the 'n' flag. This may happen when a window border is present and when the wrapped line continues on the next physical line directly in the window border because the 'cpo' setting includes the 'n' flag. Only users with non-default settings are affected and the exception should only result in a crash. This issue has been addressed in commit `cb0b99f0` which has been included in release version 9.0.2107. Users are advised to upgrade. There are no known workarounds for this vulnerability."}, {"lang": "es", "value": "Vim es un editor de texto de l\u00ednea de comandos de c\u00f3digo abierto. Puede ocurrir una excepci\u00f3n de punto flotante al calcular el desplazamiento de l\u00ednea para l\u00edneas demasiado largas y el desplazamiento suave est\u00e1 habilitado y la configuraci\u00f3n de cpo incluye el indicador 'n'. Esto puede suceder cuando hay un borde de ventana presente y cuando la l\u00ednea ajustada contin\u00faa en la siguiente l\u00ednea f\u00edsica directamente en el borde de la ventana porque la configuraci\u00f3n 'cpo' incluye la bandera 'n'. S\u00f3lo los usuarios con configuraciones no predeterminadas se ven afectados y la excepci\u00f3n s\u00f3lo deber\u00eda provocar un bloqueo. Este problema se solucion\u00f3 en el commit `cb0b99f0` que se incluy\u00f3 en la versi\u00f3n 9.0.2107. Se recomienda a los usuarios que actualicen. No se conocen workarounds para esta vulnerabilidad."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:R/S:U/C:N/I:L/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 3.9, "baseSeverity": "LOW"}, "exploitabilityScore": 1.3, "impactScore": 2.5}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-755"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.0.2107", "matchCriteriaId": "386DCEA7-3DFA-472B-9131-2587EE61DD9C"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:38:*:*:*:*:*:*:*", "matchCriteriaId": "CC559B26-5DFC-4B7A-A27C-B77DE755DFF9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:39:*:*:*:*:*:*:*", "matchCriteriaId": "B8EDB836-4E6A-4B71-B9B2-AA3E03E0F646"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2023/11/16/1", "source": "security-advisories@github.com", "tags": ["Mailing List"]}, {"url": "https://github.com/vim/vim/commit/cb0b99f0672d8446585d26e998343dceca17d1ce", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/vim/vim/security/advisories/GHSA-f6cx-x634-hqpw", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/4UJAK2W5S7G75ETDAEM3BDUCVSXCEGRD/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/M3VQF7CL3V6FGSEW37WNDFBRRILR65AK/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/VNRNYLWXZOGTYWE5HMFNQ5FVE3HBUHF6/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20231227-0006/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/vim/vim/commit/cb0b99f0672d8446585d26e998343dceca17d1ce"}}