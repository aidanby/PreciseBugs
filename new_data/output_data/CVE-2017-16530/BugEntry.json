{"buggy_code": ["#include <linux/usb.h>\n#include <linux/usb/hcd.h>\n#include \"usb.h\"\n\nstatic int uas_is_interface(struct usb_host_interface *intf)\n{\n\treturn (intf->desc.bInterfaceClass == USB_CLASS_MASS_STORAGE &&\n\t\tintf->desc.bInterfaceSubClass == USB_SC_SCSI &&\n\t\tintf->desc.bInterfaceProtocol == USB_PR_UAS);\n}\n\nstatic int uas_find_uas_alt_setting(struct usb_interface *intf)\n{\n\tint i;\n\n\tfor (i = 0; i < intf->num_altsetting; i++) {\n\t\tstruct usb_host_interface *alt = &intf->altsetting[i];\n\n\t\tif (uas_is_interface(alt))\n\t\t\treturn alt->desc.bAlternateSetting;\n\t}\n\n\treturn -ENODEV;\n}\n\nstatic int uas_find_endpoints(struct usb_host_interface *alt,\n\t\t\t      struct usb_host_endpoint *eps[])\n{\n\tstruct usb_host_endpoint *endpoint = alt->endpoint;\n\tunsigned i, n_endpoints = alt->desc.bNumEndpoints;\n\n\tfor (i = 0; i < n_endpoints; i++) {\n\t\tunsigned char *extra = endpoint[i].extra;\n\t\tint len = endpoint[i].extralen;\n\t\twhile (len >= 3) {\n\t\t\tif (extra[1] == USB_DT_PIPE_USAGE) {\n\t\t\t\tunsigned pipe_id = extra[2];\n\t\t\t\tif (pipe_id > 0 && pipe_id < 5)\n\t\t\t\t\teps[pipe_id - 1] = &endpoint[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlen -= extra[0];\n\t\t\textra += extra[0];\n\t\t}\n\t}\n\n\tif (!eps[0] || !eps[1] || !eps[2] || !eps[3])\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic int uas_use_uas_driver(struct usb_interface *intf,\n\t\t\t      const struct usb_device_id *id,\n\t\t\t      unsigned long *flags_ret)\n{\n\tstruct usb_host_endpoint *eps[4] = { };\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\tunsigned long flags = id->driver_info;\n\tint r, alt;\n\n\n\talt = uas_find_uas_alt_setting(intf);\n\tif (alt < 0)\n\t\treturn 0;\n\n\tr = uas_find_endpoints(&intf->altsetting[alt], eps);\n\tif (r < 0)\n\t\treturn 0;\n\n\t/*\n\t * ASMedia has a number of usb3 to sata bridge chips, at the time of\n\t * this writing the following versions exist:\n\t * ASM1051 - no uas support version\n\t * ASM1051 - with broken (*) uas support\n\t * ASM1053 - with working uas support, but problems with large xfers\n\t * ASM1153 - with working uas support\n\t *\n\t * Devices with these chips re-use a number of device-ids over the\n\t * entire line, so the device-id is useless to determine if we're\n\t * dealing with an ASM1051 (which we want to avoid).\n\t *\n\t * The ASM1153 can be identified by config.MaxPower == 0,\n\t * where as the ASM105x models have config.MaxPower == 36.\n\t *\n\t * Differentiating between the ASM1053 and ASM1051 is trickier, when\n\t * connected over USB-3 we can look at the number of streams supported,\n\t * ASM1051 supports 32 streams, where as early ASM1053 versions support\n\t * 16 streams, newer ASM1053-s also support 32 streams, but have a\n\t * different prod-id.\n\t *\n\t * (*) ASM1051 chips do work with UAS with some disks (with the\n\t *     US_FL_NO_REPORT_OPCODES quirk), but are broken with other disks\n\t */\n\tif (le16_to_cpu(udev->descriptor.idVendor) == 0x174c &&\n\t\t\t(le16_to_cpu(udev->descriptor.idProduct) == 0x5106 ||\n\t\t\t le16_to_cpu(udev->descriptor.idProduct) == 0x55aa)) {\n\t\tif (udev->actconfig->desc.bMaxPower == 0) {\n\t\t\t/* ASM1153, do nothing */\n\t\t} else if (udev->speed < USB_SPEED_SUPER) {\n\t\t\t/* No streams info, assume ASM1051 */\n\t\t\tflags |= US_FL_IGNORE_UAS;\n\t\t} else if (usb_ss_max_streams(&eps[1]->ss_ep_comp) == 32) {\n\t\t\t/* Possibly an ASM1051, disable uas */\n\t\t\tflags |= US_FL_IGNORE_UAS;\n\t\t} else {\n\t\t\t/* ASM1053, these have issues with large transfers */\n\t\t\tflags |= US_FL_MAX_SECTORS_240;\n\t\t}\n\t}\n\n\tusb_stor_adjust_quirks(udev, &flags);\n\n\tif (flags & US_FL_IGNORE_UAS) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\"UAS is blacklisted for this device, using usb-storage instead\\n\");\n\t\treturn 0;\n\t}\n\n\tif (udev->bus->sg_tablesize == 0) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\"The driver for the USB controller %s does not support scatter-gather which is\\n\",\n\t\t\thcd->driver->description);\n\t\tdev_warn(&udev->dev,\n\t\t\t\"required by the UAS driver. Please try an other USB controller if you wish to use UAS.\\n\");\n\t\treturn 0;\n\t}\n\n\tif (udev->speed >= USB_SPEED_SUPER && !hcd->can_do_streams) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\"USB controller %s does not support streams, which are required by the UAS driver.\\n\",\n\t\t\thcd_to_bus(hcd)->bus_name);\n\t\tdev_warn(&udev->dev,\n\t\t\t\"Please try an other USB controller if you wish to use UAS.\\n\");\n\t\treturn 0;\n\t}\n\n\tif (flags_ret)\n\t\t*flags_ret = flags;\n\n\treturn 1;\n}\n", "/*\n * USB Attached SCSI\n * Note that this is not the same as the USB Mass Storage driver\n *\n * Copyright Hans de Goede <hdegoede@redhat.com> for Red Hat, Inc. 2013 - 2016\n * Copyright Matthew Wilcox for Intel Corp, 2010\n * Copyright Sarah Sharp for Intel Corp, 2010\n *\n * Distributed under the terms of the GNU GPL, version two.\n */\n\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/usb.h>\n#include <linux/usb_usual.h>\n#include <linux/usb/hcd.h>\n#include <linux/usb/storage.h>\n#include <linux/usb/uas.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_dbg.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_tcq.h>\n\n#include \"uas-detect.h\"\n#include \"scsiglue.h\"\n\n#define MAX_CMNDS 256\n\nstruct uas_dev_info {\n\tstruct usb_interface *intf;\n\tstruct usb_device *udev;\n\tstruct usb_anchor cmd_urbs;\n\tstruct usb_anchor sense_urbs;\n\tstruct usb_anchor data_urbs;\n\tunsigned long flags;\n\tint qdepth, resetting;\n\tunsigned cmd_pipe, status_pipe, data_in_pipe, data_out_pipe;\n\tunsigned use_streams:1;\n\tunsigned shutdown:1;\n\tstruct scsi_cmnd *cmnd[MAX_CMNDS];\n\tspinlock_t lock;\n\tstruct work_struct work;\n};\n\nenum {\n\tSUBMIT_STATUS_URB\t= BIT(1),\n\tALLOC_DATA_IN_URB\t= BIT(2),\n\tSUBMIT_DATA_IN_URB\t= BIT(3),\n\tALLOC_DATA_OUT_URB\t= BIT(4),\n\tSUBMIT_DATA_OUT_URB\t= BIT(5),\n\tALLOC_CMD_URB\t\t= BIT(6),\n\tSUBMIT_CMD_URB\t\t= BIT(7),\n\tCOMMAND_INFLIGHT        = BIT(8),\n\tDATA_IN_URB_INFLIGHT    = BIT(9),\n\tDATA_OUT_URB_INFLIGHT   = BIT(10),\n\tCOMMAND_ABORTED         = BIT(11),\n\tIS_IN_WORK_LIST         = BIT(12),\n};\n\n/* Overrides scsi_pointer */\nstruct uas_cmd_info {\n\tunsigned int state;\n\tunsigned int uas_tag;\n\tstruct urb *cmd_urb;\n\tstruct urb *data_in_urb;\n\tstruct urb *data_out_urb;\n};\n\n/* I hate forward declarations, but I actually have a loop */\nstatic int uas_submit_urbs(struct scsi_cmnd *cmnd,\n\t\t\t\tstruct uas_dev_info *devinfo);\nstatic void uas_do_work(struct work_struct *work);\nstatic int uas_try_complete(struct scsi_cmnd *cmnd, const char *caller);\nstatic void uas_free_streams(struct uas_dev_info *devinfo);\nstatic void uas_log_cmd_state(struct scsi_cmnd *cmnd, const char *prefix,\n\t\t\t\tint status);\n\nstatic void uas_do_work(struct work_struct *work)\n{\n\tstruct uas_dev_info *devinfo =\n\t\tcontainer_of(work, struct uas_dev_info, work);\n\tstruct uas_cmd_info *cmdinfo;\n\tstruct scsi_cmnd *cmnd;\n\tunsigned long flags;\n\tint i, err;\n\n\tspin_lock_irqsave(&devinfo->lock, flags);\n\n\tif (devinfo->resetting)\n\t\tgoto out;\n\n\tfor (i = 0; i < devinfo->qdepth; i++) {\n\t\tif (!devinfo->cmnd[i])\n\t\t\tcontinue;\n\n\t\tcmnd = devinfo->cmnd[i];\n\t\tcmdinfo = (void *)&cmnd->SCp;\n\n\t\tif (!(cmdinfo->state & IS_IN_WORK_LIST))\n\t\t\tcontinue;\n\n\t\terr = uas_submit_urbs(cmnd, cmnd->device->hostdata);\n\t\tif (!err)\n\t\t\tcmdinfo->state &= ~IS_IN_WORK_LIST;\n\t\telse\n\t\t\tschedule_work(&devinfo->work);\n\t}\nout:\n\tspin_unlock_irqrestore(&devinfo->lock, flags);\n}\n\nstatic void uas_add_work(struct uas_cmd_info *cmdinfo)\n{\n\tstruct scsi_pointer *scp = (void *)cmdinfo;\n\tstruct scsi_cmnd *cmnd = container_of(scp, struct scsi_cmnd, SCp);\n\tstruct uas_dev_info *devinfo = cmnd->device->hostdata;\n\n\tlockdep_assert_held(&devinfo->lock);\n\tcmdinfo->state |= IS_IN_WORK_LIST;\n\tschedule_work(&devinfo->work);\n}\n\nstatic void uas_zap_pending(struct uas_dev_info *devinfo, int result)\n{\n\tstruct uas_cmd_info *cmdinfo;\n\tstruct scsi_cmnd *cmnd;\n\tunsigned long flags;\n\tint i, err;\n\n\tspin_lock_irqsave(&devinfo->lock, flags);\n\tfor (i = 0; i < devinfo->qdepth; i++) {\n\t\tif (!devinfo->cmnd[i])\n\t\t\tcontinue;\n\n\t\tcmnd = devinfo->cmnd[i];\n\t\tcmdinfo = (void *)&cmnd->SCp;\n\t\tuas_log_cmd_state(cmnd, __func__, 0);\n\t\t/* Sense urbs were killed, clear COMMAND_INFLIGHT manually */\n\t\tcmdinfo->state &= ~COMMAND_INFLIGHT;\n\t\tcmnd->result = result << 16;\n\t\terr = uas_try_complete(cmnd, __func__);\n\t\tWARN_ON(err != 0);\n\t}\n\tspin_unlock_irqrestore(&devinfo->lock, flags);\n}\n\nstatic void uas_sense(struct urb *urb, struct scsi_cmnd *cmnd)\n{\n\tstruct sense_iu *sense_iu = urb->transfer_buffer;\n\tstruct scsi_device *sdev = cmnd->device;\n\n\tif (urb->actual_length > 16) {\n\t\tunsigned len = be16_to_cpup(&sense_iu->len);\n\t\tif (len + 16 != urb->actual_length) {\n\t\t\tint newlen = min(len + 16, urb->actual_length) - 16;\n\t\t\tif (newlen < 0)\n\t\t\t\tnewlen = 0;\n\t\t\tsdev_printk(KERN_INFO, sdev, \"%s: urb length %d \"\n\t\t\t\t\"disagrees with IU sense data length %d, \"\n\t\t\t\t\"using %d bytes of sense data\\n\", __func__,\n\t\t\t\t\turb->actual_length, len, newlen);\n\t\t\tlen = newlen;\n\t\t}\n\t\tmemcpy(cmnd->sense_buffer, sense_iu->sense, len);\n\t}\n\n\tcmnd->result = sense_iu->status;\n}\n\nstatic void uas_log_cmd_state(struct scsi_cmnd *cmnd, const char *prefix,\n\t\t\t      int status)\n{\n\tstruct uas_cmd_info *ci = (void *)&cmnd->SCp;\n\tstruct uas_cmd_info *cmdinfo = (void *)&cmnd->SCp;\n\n\tscmd_printk(KERN_INFO, cmnd,\n\t\t    \"%s %d uas-tag %d inflight:%s%s%s%s%s%s%s%s%s%s%s%s \",\n\t\t    prefix, status, cmdinfo->uas_tag,\n\t\t    (ci->state & SUBMIT_STATUS_URB)     ? \" s-st\"  : \"\",\n\t\t    (ci->state & ALLOC_DATA_IN_URB)     ? \" a-in\"  : \"\",\n\t\t    (ci->state & SUBMIT_DATA_IN_URB)    ? \" s-in\"  : \"\",\n\t\t    (ci->state & ALLOC_DATA_OUT_URB)    ? \" a-out\" : \"\",\n\t\t    (ci->state & SUBMIT_DATA_OUT_URB)   ? \" s-out\" : \"\",\n\t\t    (ci->state & ALLOC_CMD_URB)         ? \" a-cmd\" : \"\",\n\t\t    (ci->state & SUBMIT_CMD_URB)        ? \" s-cmd\" : \"\",\n\t\t    (ci->state & COMMAND_INFLIGHT)      ? \" CMD\"   : \"\",\n\t\t    (ci->state & DATA_IN_URB_INFLIGHT)  ? \" IN\"    : \"\",\n\t\t    (ci->state & DATA_OUT_URB_INFLIGHT) ? \" OUT\"   : \"\",\n\t\t    (ci->state & COMMAND_ABORTED)       ? \" abort\" : \"\",\n\t\t    (ci->state & IS_IN_WORK_LIST)       ? \" work\"  : \"\");\n\tscsi_print_command(cmnd);\n}\n\nstatic void uas_free_unsubmitted_urbs(struct scsi_cmnd *cmnd)\n{\n\tstruct uas_cmd_info *cmdinfo;\n\n\tif (!cmnd)\n\t\treturn;\n\n\tcmdinfo = (void *)&cmnd->SCp;\n\n\tif (cmdinfo->state & SUBMIT_CMD_URB)\n\t\tusb_free_urb(cmdinfo->cmd_urb);\n\n\t/* data urbs may have never gotten their submit flag set */\n\tif (!(cmdinfo->state & DATA_IN_URB_INFLIGHT))\n\t\tusb_free_urb(cmdinfo->data_in_urb);\n\tif (!(cmdinfo->state & DATA_OUT_URB_INFLIGHT))\n\t\tusb_free_urb(cmdinfo->data_out_urb);\n}\n\nstatic int uas_try_complete(struct scsi_cmnd *cmnd, const char *caller)\n{\n\tstruct uas_cmd_info *cmdinfo = (void *)&cmnd->SCp;\n\tstruct uas_dev_info *devinfo = (void *)cmnd->device->hostdata;\n\n\tlockdep_assert_held(&devinfo->lock);\n\tif (cmdinfo->state & (COMMAND_INFLIGHT |\n\t\t\t      DATA_IN_URB_INFLIGHT |\n\t\t\t      DATA_OUT_URB_INFLIGHT |\n\t\t\t      COMMAND_ABORTED))\n\t\treturn -EBUSY;\n\tdevinfo->cmnd[cmdinfo->uas_tag - 1] = NULL;\n\tuas_free_unsubmitted_urbs(cmnd);\n\tcmnd->scsi_done(cmnd);\n\treturn 0;\n}\n\nstatic void uas_xfer_data(struct urb *urb, struct scsi_cmnd *cmnd,\n\t\t\t  unsigned direction)\n{\n\tstruct uas_cmd_info *cmdinfo = (void *)&cmnd->SCp;\n\tint err;\n\n\tcmdinfo->state |= direction | SUBMIT_STATUS_URB;\n\terr = uas_submit_urbs(cmnd, cmnd->device->hostdata);\n\tif (err) {\n\t\tuas_add_work(cmdinfo);\n\t}\n}\n\nstatic bool uas_evaluate_response_iu(struct response_iu *riu, struct scsi_cmnd *cmnd)\n{\n\tu8 response_code = riu->response_code;\n\n\tswitch (response_code) {\n\tcase RC_INCORRECT_LUN:\n\t\tcmnd->result = DID_BAD_TARGET << 16;\n\t\tbreak;\n\tcase RC_TMF_SUCCEEDED:\n\t\tcmnd->result = DID_OK << 16;\n\t\tbreak;\n\tcase RC_TMF_NOT_SUPPORTED:\n\t\tcmnd->result = DID_TARGET_FAILURE << 16;\n\t\tbreak;\n\tdefault:\n\t\tuas_log_cmd_state(cmnd, \"response iu\", response_code);\n\t\tcmnd->result = DID_ERROR << 16;\n\t\tbreak;\n\t}\n\n\treturn response_code == RC_TMF_SUCCEEDED;\n}\n\nstatic void uas_stat_cmplt(struct urb *urb)\n{\n\tstruct iu *iu = urb->transfer_buffer;\n\tstruct Scsi_Host *shost = urb->context;\n\tstruct uas_dev_info *devinfo = (struct uas_dev_info *)shost->hostdata;\n\tstruct urb *data_in_urb = NULL;\n\tstruct urb *data_out_urb = NULL;\n\tstruct scsi_cmnd *cmnd;\n\tstruct uas_cmd_info *cmdinfo;\n\tunsigned long flags;\n\tunsigned int idx;\n\tint status = urb->status;\n\tbool success;\n\n\tspin_lock_irqsave(&devinfo->lock, flags);\n\n\tif (devinfo->resetting)\n\t\tgoto out;\n\n\tif (status) {\n\t\tif (status != -ENOENT && status != -ECONNRESET && status != -ESHUTDOWN)\n\t\t\tdev_err(&urb->dev->dev, \"stat urb: status %d\\n\", status);\n\t\tgoto out;\n\t}\n\n\tidx = be16_to_cpup(&iu->tag) - 1;\n\tif (idx >= MAX_CMNDS || !devinfo->cmnd[idx]) {\n\t\tdev_err(&urb->dev->dev,\n\t\t\t\"stat urb: no pending cmd for uas-tag %d\\n\", idx + 1);\n\t\tgoto out;\n\t}\n\n\tcmnd = devinfo->cmnd[idx];\n\tcmdinfo = (void *)&cmnd->SCp;\n\n\tif (!(cmdinfo->state & COMMAND_INFLIGHT)) {\n\t\tuas_log_cmd_state(cmnd, \"unexpected status cmplt\", 0);\n\t\tgoto out;\n\t}\n\n\tswitch (iu->iu_id) {\n\tcase IU_ID_STATUS:\n\t\tuas_sense(urb, cmnd);\n\t\tif (cmnd->result != 0) {\n\t\t\t/* cancel data transfers on error */\n\t\t\tdata_in_urb = usb_get_urb(cmdinfo->data_in_urb);\n\t\t\tdata_out_urb = usb_get_urb(cmdinfo->data_out_urb);\n\t\t}\n\t\tcmdinfo->state &= ~COMMAND_INFLIGHT;\n\t\tuas_try_complete(cmnd, __func__);\n\t\tbreak;\n\tcase IU_ID_READ_READY:\n\t\tif (!cmdinfo->data_in_urb ||\n\t\t\t\t(cmdinfo->state & DATA_IN_URB_INFLIGHT)) {\n\t\t\tuas_log_cmd_state(cmnd, \"unexpected read rdy\", 0);\n\t\t\tbreak;\n\t\t}\n\t\tuas_xfer_data(urb, cmnd, SUBMIT_DATA_IN_URB);\n\t\tbreak;\n\tcase IU_ID_WRITE_READY:\n\t\tif (!cmdinfo->data_out_urb ||\n\t\t\t\t(cmdinfo->state & DATA_OUT_URB_INFLIGHT)) {\n\t\t\tuas_log_cmd_state(cmnd, \"unexpected write rdy\", 0);\n\t\t\tbreak;\n\t\t}\n\t\tuas_xfer_data(urb, cmnd, SUBMIT_DATA_OUT_URB);\n\t\tbreak;\n\tcase IU_ID_RESPONSE:\n\t\tcmdinfo->state &= ~COMMAND_INFLIGHT;\n\t\tsuccess = uas_evaluate_response_iu((struct response_iu *)iu, cmnd);\n\t\tif (!success) {\n\t\t\t/* Error, cancel data transfers */\n\t\t\tdata_in_urb = usb_get_urb(cmdinfo->data_in_urb);\n\t\t\tdata_out_urb = usb_get_urb(cmdinfo->data_out_urb);\n\t\t}\n\t\tuas_try_complete(cmnd, __func__);\n\t\tbreak;\n\tdefault:\n\t\tuas_log_cmd_state(cmnd, \"bogus IU\", iu->iu_id);\n\t}\nout:\n\tusb_free_urb(urb);\n\tspin_unlock_irqrestore(&devinfo->lock, flags);\n\n\t/* Unlinking of data urbs must be done without holding the lock */\n\tif (data_in_urb) {\n\t\tusb_unlink_urb(data_in_urb);\n\t\tusb_put_urb(data_in_urb);\n\t}\n\tif (data_out_urb) {\n\t\tusb_unlink_urb(data_out_urb);\n\t\tusb_put_urb(data_out_urb);\n\t}\n}\n\nstatic void uas_data_cmplt(struct urb *urb)\n{\n\tstruct scsi_cmnd *cmnd = urb->context;\n\tstruct uas_cmd_info *cmdinfo = (void *)&cmnd->SCp;\n\tstruct uas_dev_info *devinfo = (void *)cmnd->device->hostdata;\n\tstruct scsi_data_buffer *sdb = NULL;\n\tunsigned long flags;\n\tint status = urb->status;\n\n\tspin_lock_irqsave(&devinfo->lock, flags);\n\n\tif (cmdinfo->data_in_urb == urb) {\n\t\tsdb = scsi_in(cmnd);\n\t\tcmdinfo->state &= ~DATA_IN_URB_INFLIGHT;\n\t\tcmdinfo->data_in_urb = NULL;\n\t} else if (cmdinfo->data_out_urb == urb) {\n\t\tsdb = scsi_out(cmnd);\n\t\tcmdinfo->state &= ~DATA_OUT_URB_INFLIGHT;\n\t\tcmdinfo->data_out_urb = NULL;\n\t}\n\tif (sdb == NULL) {\n\t\tWARN_ON_ONCE(1);\n\t\tgoto out;\n\t}\n\n\tif (devinfo->resetting)\n\t\tgoto out;\n\n\t/* Data urbs should not complete before the cmd urb is submitted */\n\tif (cmdinfo->state & SUBMIT_CMD_URB) {\n\t\tuas_log_cmd_state(cmnd, \"unexpected data cmplt\", 0);\n\t\tgoto out;\n\t}\n\n\tif (status) {\n\t\tif (status != -ENOENT && status != -ECONNRESET && status != -ESHUTDOWN)\n\t\t\tuas_log_cmd_state(cmnd, \"data cmplt err\", status);\n\t\t/* error: no data transfered */\n\t\tsdb->resid = sdb->length;\n\t} else {\n\t\tsdb->resid = sdb->length - urb->actual_length;\n\t}\n\tuas_try_complete(cmnd, __func__);\nout:\n\tusb_free_urb(urb);\n\tspin_unlock_irqrestore(&devinfo->lock, flags);\n}\n\nstatic void uas_cmd_cmplt(struct urb *urb)\n{\n\tif (urb->status)\n\t\tdev_err(&urb->dev->dev, \"cmd cmplt err %d\\n\", urb->status);\n\n\tusb_free_urb(urb);\n}\n\nstatic struct urb *uas_alloc_data_urb(struct uas_dev_info *devinfo, gfp_t gfp,\n\t\t\t\t      struct scsi_cmnd *cmnd,\n\t\t\t\t      enum dma_data_direction dir)\n{\n\tstruct usb_device *udev = devinfo->udev;\n\tstruct uas_cmd_info *cmdinfo = (void *)&cmnd->SCp;\n\tstruct urb *urb = usb_alloc_urb(0, gfp);\n\tstruct scsi_data_buffer *sdb = (dir == DMA_FROM_DEVICE)\n\t\t? scsi_in(cmnd) : scsi_out(cmnd);\n\tunsigned int pipe = (dir == DMA_FROM_DEVICE)\n\t\t? devinfo->data_in_pipe : devinfo->data_out_pipe;\n\n\tif (!urb)\n\t\tgoto out;\n\tusb_fill_bulk_urb(urb, udev, pipe, NULL, sdb->length,\n\t\t\t  uas_data_cmplt, cmnd);\n\tif (devinfo->use_streams)\n\t\turb->stream_id = cmdinfo->uas_tag;\n\turb->num_sgs = udev->bus->sg_tablesize ? sdb->table.nents : 0;\n\turb->sg = sdb->table.sgl;\n out:\n\treturn urb;\n}\n\nstatic struct urb *uas_alloc_sense_urb(struct uas_dev_info *devinfo, gfp_t gfp,\n\t\t\t\t       struct scsi_cmnd *cmnd)\n{\n\tstruct usb_device *udev = devinfo->udev;\n\tstruct uas_cmd_info *cmdinfo = (void *)&cmnd->SCp;\n\tstruct urb *urb = usb_alloc_urb(0, gfp);\n\tstruct sense_iu *iu;\n\n\tif (!urb)\n\t\tgoto out;\n\n\tiu = kzalloc(sizeof(*iu), gfp);\n\tif (!iu)\n\t\tgoto free;\n\n\tusb_fill_bulk_urb(urb, udev, devinfo->status_pipe, iu, sizeof(*iu),\n\t\t\t  uas_stat_cmplt, cmnd->device->host);\n\tif (devinfo->use_streams)\n\t\turb->stream_id = cmdinfo->uas_tag;\n\turb->transfer_flags |= URB_FREE_BUFFER;\n out:\n\treturn urb;\n free:\n\tusb_free_urb(urb);\n\treturn NULL;\n}\n\nstatic struct urb *uas_alloc_cmd_urb(struct uas_dev_info *devinfo, gfp_t gfp,\n\t\t\t\t\tstruct scsi_cmnd *cmnd)\n{\n\tstruct usb_device *udev = devinfo->udev;\n\tstruct scsi_device *sdev = cmnd->device;\n\tstruct uas_cmd_info *cmdinfo = (void *)&cmnd->SCp;\n\tstruct urb *urb = usb_alloc_urb(0, gfp);\n\tstruct command_iu *iu;\n\tint len;\n\n\tif (!urb)\n\t\tgoto out;\n\n\tlen = cmnd->cmd_len - 16;\n\tif (len < 0)\n\t\tlen = 0;\n\tlen = ALIGN(len, 4);\n\tiu = kzalloc(sizeof(*iu) + len, gfp);\n\tif (!iu)\n\t\tgoto free;\n\n\tiu->iu_id = IU_ID_COMMAND;\n\tiu->tag = cpu_to_be16(cmdinfo->uas_tag);\n\tiu->prio_attr = UAS_SIMPLE_TAG;\n\tiu->len = len;\n\tint_to_scsilun(sdev->lun, &iu->lun);\n\tmemcpy(iu->cdb, cmnd->cmnd, cmnd->cmd_len);\n\n\tusb_fill_bulk_urb(urb, udev, devinfo->cmd_pipe, iu, sizeof(*iu) + len,\n\t\t\t\t\t\t\tuas_cmd_cmplt, NULL);\n\turb->transfer_flags |= URB_FREE_BUFFER;\n out:\n\treturn urb;\n free:\n\tusb_free_urb(urb);\n\treturn NULL;\n}\n\n/*\n * Why should I request the Status IU before sending the Command IU?  Spec\n * says to, but also says the device may receive them in any order.  Seems\n * daft to me.\n */\n\nstatic struct urb *uas_submit_sense_urb(struct scsi_cmnd *cmnd, gfp_t gfp)\n{\n\tstruct uas_dev_info *devinfo = cmnd->device->hostdata;\n\tstruct urb *urb;\n\tint err;\n\n\turb = uas_alloc_sense_urb(devinfo, gfp, cmnd);\n\tif (!urb)\n\t\treturn NULL;\n\tusb_anchor_urb(urb, &devinfo->sense_urbs);\n\terr = usb_submit_urb(urb, gfp);\n\tif (err) {\n\t\tusb_unanchor_urb(urb);\n\t\tuas_log_cmd_state(cmnd, \"sense submit err\", err);\n\t\tusb_free_urb(urb);\n\t\treturn NULL;\n\t}\n\treturn urb;\n}\n\nstatic int uas_submit_urbs(struct scsi_cmnd *cmnd,\n\t\t\t   struct uas_dev_info *devinfo)\n{\n\tstruct uas_cmd_info *cmdinfo = (void *)&cmnd->SCp;\n\tstruct urb *urb;\n\tint err;\n\n\tlockdep_assert_held(&devinfo->lock);\n\tif (cmdinfo->state & SUBMIT_STATUS_URB) {\n\t\turb = uas_submit_sense_urb(cmnd, GFP_ATOMIC);\n\t\tif (!urb)\n\t\t\treturn SCSI_MLQUEUE_DEVICE_BUSY;\n\t\tcmdinfo->state &= ~SUBMIT_STATUS_URB;\n\t}\n\n\tif (cmdinfo->state & ALLOC_DATA_IN_URB) {\n\t\tcmdinfo->data_in_urb = uas_alloc_data_urb(devinfo, GFP_ATOMIC,\n\t\t\t\t\t\t\tcmnd, DMA_FROM_DEVICE);\n\t\tif (!cmdinfo->data_in_urb)\n\t\t\treturn SCSI_MLQUEUE_DEVICE_BUSY;\n\t\tcmdinfo->state &= ~ALLOC_DATA_IN_URB;\n\t}\n\n\tif (cmdinfo->state & SUBMIT_DATA_IN_URB) {\n\t\tusb_anchor_urb(cmdinfo->data_in_urb, &devinfo->data_urbs);\n\t\terr = usb_submit_urb(cmdinfo->data_in_urb, GFP_ATOMIC);\n\t\tif (err) {\n\t\t\tusb_unanchor_urb(cmdinfo->data_in_urb);\n\t\t\tuas_log_cmd_state(cmnd, \"data in submit err\", err);\n\t\t\treturn SCSI_MLQUEUE_DEVICE_BUSY;\n\t\t}\n\t\tcmdinfo->state &= ~SUBMIT_DATA_IN_URB;\n\t\tcmdinfo->state |= DATA_IN_URB_INFLIGHT;\n\t}\n\n\tif (cmdinfo->state & ALLOC_DATA_OUT_URB) {\n\t\tcmdinfo->data_out_urb = uas_alloc_data_urb(devinfo, GFP_ATOMIC,\n\t\t\t\t\t\t\tcmnd, DMA_TO_DEVICE);\n\t\tif (!cmdinfo->data_out_urb)\n\t\t\treturn SCSI_MLQUEUE_DEVICE_BUSY;\n\t\tcmdinfo->state &= ~ALLOC_DATA_OUT_URB;\n\t}\n\n\tif (cmdinfo->state & SUBMIT_DATA_OUT_URB) {\n\t\tusb_anchor_urb(cmdinfo->data_out_urb, &devinfo->data_urbs);\n\t\terr = usb_submit_urb(cmdinfo->data_out_urb, GFP_ATOMIC);\n\t\tif (err) {\n\t\t\tusb_unanchor_urb(cmdinfo->data_out_urb);\n\t\t\tuas_log_cmd_state(cmnd, \"data out submit err\", err);\n\t\t\treturn SCSI_MLQUEUE_DEVICE_BUSY;\n\t\t}\n\t\tcmdinfo->state &= ~SUBMIT_DATA_OUT_URB;\n\t\tcmdinfo->state |= DATA_OUT_URB_INFLIGHT;\n\t}\n\n\tif (cmdinfo->state & ALLOC_CMD_URB) {\n\t\tcmdinfo->cmd_urb = uas_alloc_cmd_urb(devinfo, GFP_ATOMIC, cmnd);\n\t\tif (!cmdinfo->cmd_urb)\n\t\t\treturn SCSI_MLQUEUE_DEVICE_BUSY;\n\t\tcmdinfo->state &= ~ALLOC_CMD_URB;\n\t}\n\n\tif (cmdinfo->state & SUBMIT_CMD_URB) {\n\t\tusb_anchor_urb(cmdinfo->cmd_urb, &devinfo->cmd_urbs);\n\t\terr = usb_submit_urb(cmdinfo->cmd_urb, GFP_ATOMIC);\n\t\tif (err) {\n\t\t\tusb_unanchor_urb(cmdinfo->cmd_urb);\n\t\t\tuas_log_cmd_state(cmnd, \"cmd submit err\", err);\n\t\t\treturn SCSI_MLQUEUE_DEVICE_BUSY;\n\t\t}\n\t\tcmdinfo->cmd_urb = NULL;\n\t\tcmdinfo->state &= ~SUBMIT_CMD_URB;\n\t\tcmdinfo->state |= COMMAND_INFLIGHT;\n\t}\n\n\treturn 0;\n}\n\nstatic int uas_queuecommand_lck(struct scsi_cmnd *cmnd,\n\t\t\t\t\tvoid (*done)(struct scsi_cmnd *))\n{\n\tstruct scsi_device *sdev = cmnd->device;\n\tstruct uas_dev_info *devinfo = sdev->hostdata;\n\tstruct uas_cmd_info *cmdinfo = (void *)&cmnd->SCp;\n\tunsigned long flags;\n\tint idx, err;\n\n\tBUILD_BUG_ON(sizeof(struct uas_cmd_info) > sizeof(struct scsi_pointer));\n\n\t/* Re-check scsi_block_requests now that we've the host-lock */\n\tif (cmnd->device->host->host_self_blocked)\n\t\treturn SCSI_MLQUEUE_DEVICE_BUSY;\n\n\tif ((devinfo->flags & US_FL_NO_ATA_1X) &&\n\t\t\t(cmnd->cmnd[0] == ATA_12 || cmnd->cmnd[0] == ATA_16)) {\n\t\tmemcpy(cmnd->sense_buffer, usb_stor_sense_invalidCDB,\n\t\t       sizeof(usb_stor_sense_invalidCDB));\n\t\tcmnd->result = SAM_STAT_CHECK_CONDITION;\n\t\tcmnd->scsi_done(cmnd);\n\t\treturn 0;\n\t}\n\n\tspin_lock_irqsave(&devinfo->lock, flags);\n\n\tif (devinfo->resetting) {\n\t\tcmnd->result = DID_ERROR << 16;\n\t\tcmnd->scsi_done(cmnd);\n\t\tspin_unlock_irqrestore(&devinfo->lock, flags);\n\t\treturn 0;\n\t}\n\n\t/* Find a free uas-tag */\n\tfor (idx = 0; idx < devinfo->qdepth; idx++) {\n\t\tif (!devinfo->cmnd[idx])\n\t\t\tbreak;\n\t}\n\tif (idx == devinfo->qdepth) {\n\t\tspin_unlock_irqrestore(&devinfo->lock, flags);\n\t\treturn SCSI_MLQUEUE_DEVICE_BUSY;\n\t}\n\n\tcmnd->scsi_done = done;\n\n\tmemset(cmdinfo, 0, sizeof(*cmdinfo));\n\tcmdinfo->uas_tag = idx + 1; /* uas-tag == usb-stream-id, so 1 based */\n\tcmdinfo->state = SUBMIT_STATUS_URB | ALLOC_CMD_URB | SUBMIT_CMD_URB;\n\n\tswitch (cmnd->sc_data_direction) {\n\tcase DMA_FROM_DEVICE:\n\t\tcmdinfo->state |= ALLOC_DATA_IN_URB | SUBMIT_DATA_IN_URB;\n\t\tbreak;\n\tcase DMA_BIDIRECTIONAL:\n\t\tcmdinfo->state |= ALLOC_DATA_IN_URB | SUBMIT_DATA_IN_URB;\n\tcase DMA_TO_DEVICE:\n\t\tcmdinfo->state |= ALLOC_DATA_OUT_URB | SUBMIT_DATA_OUT_URB;\n\tcase DMA_NONE:\n\t\tbreak;\n\t}\n\n\tif (!devinfo->use_streams)\n\t\tcmdinfo->state &= ~(SUBMIT_DATA_IN_URB | SUBMIT_DATA_OUT_URB);\n\n\terr = uas_submit_urbs(cmnd, devinfo);\n\tif (err) {\n\t\t/* If we did nothing, give up now */\n\t\tif (cmdinfo->state & SUBMIT_STATUS_URB) {\n\t\t\tspin_unlock_irqrestore(&devinfo->lock, flags);\n\t\t\treturn SCSI_MLQUEUE_DEVICE_BUSY;\n\t\t}\n\t\tuas_add_work(cmdinfo);\n\t}\n\n\tdevinfo->cmnd[idx] = cmnd;\n\tspin_unlock_irqrestore(&devinfo->lock, flags);\n\treturn 0;\n}\n\nstatic DEF_SCSI_QCMD(uas_queuecommand)\n\n/*\n * For now we do not support actually sending an abort to the device, so\n * this eh always fails. Still we must define it to make sure that we've\n * dropped all references to the cmnd in question once this function exits.\n */\nstatic int uas_eh_abort_handler(struct scsi_cmnd *cmnd)\n{\n\tstruct uas_cmd_info *cmdinfo = (void *)&cmnd->SCp;\n\tstruct uas_dev_info *devinfo = (void *)cmnd->device->hostdata;\n\tstruct urb *data_in_urb = NULL;\n\tstruct urb *data_out_urb = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&devinfo->lock, flags);\n\n\tuas_log_cmd_state(cmnd, __func__, 0);\n\n\t/* Ensure that try_complete does not call scsi_done */\n\tcmdinfo->state |= COMMAND_ABORTED;\n\n\t/* Drop all refs to this cmnd, kill data urbs to break their ref */\n\tdevinfo->cmnd[cmdinfo->uas_tag - 1] = NULL;\n\tif (cmdinfo->state & DATA_IN_URB_INFLIGHT)\n\t\tdata_in_urb = usb_get_urb(cmdinfo->data_in_urb);\n\tif (cmdinfo->state & DATA_OUT_URB_INFLIGHT)\n\t\tdata_out_urb = usb_get_urb(cmdinfo->data_out_urb);\n\n\tuas_free_unsubmitted_urbs(cmnd);\n\n\tspin_unlock_irqrestore(&devinfo->lock, flags);\n\n\tif (data_in_urb) {\n\t\tusb_kill_urb(data_in_urb);\n\t\tusb_put_urb(data_in_urb);\n\t}\n\tif (data_out_urb) {\n\t\tusb_kill_urb(data_out_urb);\n\t\tusb_put_urb(data_out_urb);\n\t}\n\n\treturn FAILED;\n}\n\nstatic int uas_eh_device_reset_handler(struct scsi_cmnd *cmnd)\n{\n\tstruct scsi_device *sdev = cmnd->device;\n\tstruct uas_dev_info *devinfo = sdev->hostdata;\n\tstruct usb_device *udev = devinfo->udev;\n\tunsigned long flags;\n\tint err;\n\n\terr = usb_lock_device_for_reset(udev, devinfo->intf);\n\tif (err) {\n\t\tshost_printk(KERN_ERR, sdev->host,\n\t\t\t     \"%s FAILED to get lock err %d\\n\", __func__, err);\n\t\treturn FAILED;\n\t}\n\n\tshost_printk(KERN_INFO, sdev->host, \"%s start\\n\", __func__);\n\n\tspin_lock_irqsave(&devinfo->lock, flags);\n\tdevinfo->resetting = 1;\n\tspin_unlock_irqrestore(&devinfo->lock, flags);\n\n\tusb_kill_anchored_urbs(&devinfo->cmd_urbs);\n\tusb_kill_anchored_urbs(&devinfo->sense_urbs);\n\tusb_kill_anchored_urbs(&devinfo->data_urbs);\n\tuas_zap_pending(devinfo, DID_RESET);\n\n\terr = usb_reset_device(udev);\n\n\tspin_lock_irqsave(&devinfo->lock, flags);\n\tdevinfo->resetting = 0;\n\tspin_unlock_irqrestore(&devinfo->lock, flags);\n\n\tusb_unlock_device(udev);\n\n\tif (err) {\n\t\tshost_printk(KERN_INFO, sdev->host, \"%s FAILED err %d\\n\",\n\t\t\t     __func__, err);\n\t\treturn FAILED;\n\t}\n\n\tshost_printk(KERN_INFO, sdev->host, \"%s success\\n\", __func__);\n\treturn SUCCESS;\n}\n\nstatic int uas_target_alloc(struct scsi_target *starget)\n{\n\tstruct uas_dev_info *devinfo = (struct uas_dev_info *)\n\t\t\tdev_to_shost(starget->dev.parent)->hostdata;\n\n\tif (devinfo->flags & US_FL_NO_REPORT_LUNS)\n\t\tstarget->no_report_luns = 1;\n\n\treturn 0;\n}\n\nstatic int uas_slave_alloc(struct scsi_device *sdev)\n{\n\tstruct uas_dev_info *devinfo =\n\t\t(struct uas_dev_info *)sdev->host->hostdata;\n\n\tsdev->hostdata = devinfo;\n\n\t/*\n\t * USB has unusual DMA-alignment requirements: Although the\n\t * starting address of each scatter-gather element doesn't matter,\n\t * the length of each element except the last must be divisible\n\t * by the Bulk maxpacket value.  There's currently no way to\n\t * express this by block-layer constraints, so we'll cop out\n\t * and simply require addresses to be aligned at 512-byte\n\t * boundaries.  This is okay since most block I/O involves\n\t * hardware sectors that are multiples of 512 bytes in length,\n\t * and since host controllers up through USB 2.0 have maxpacket\n\t * values no larger than 512.\n\t *\n\t * But it doesn't suffice for Wireless USB, where Bulk maxpacket\n\t * values can be as large as 2048.  To make that work properly\n\t * will require changes to the block layer.\n\t */\n\tblk_queue_update_dma_alignment(sdev->request_queue, (512 - 1));\n\n\tif (devinfo->flags & US_FL_MAX_SECTORS_64)\n\t\tblk_queue_max_hw_sectors(sdev->request_queue, 64);\n\telse if (devinfo->flags & US_FL_MAX_SECTORS_240)\n\t\tblk_queue_max_hw_sectors(sdev->request_queue, 240);\n\n\treturn 0;\n}\n\nstatic int uas_slave_configure(struct scsi_device *sdev)\n{\n\tstruct uas_dev_info *devinfo = sdev->hostdata;\n\n\tif (devinfo->flags & US_FL_NO_REPORT_OPCODES)\n\t\tsdev->no_report_opcodes = 1;\n\n\t/* A few buggy USB-ATA bridges don't understand FUA */\n\tif (devinfo->flags & US_FL_BROKEN_FUA)\n\t\tsdev->broken_fua = 1;\n\n\tscsi_change_queue_depth(sdev, devinfo->qdepth - 2);\n\treturn 0;\n}\n\nstatic struct scsi_host_template uas_host_template = {\n\t.module = THIS_MODULE,\n\t.name = \"uas\",\n\t.queuecommand = uas_queuecommand,\n\t.target_alloc = uas_target_alloc,\n\t.slave_alloc = uas_slave_alloc,\n\t.slave_configure = uas_slave_configure,\n\t.eh_abort_handler = uas_eh_abort_handler,\n\t.eh_device_reset_handler = uas_eh_device_reset_handler,\n\t.this_id = -1,\n\t.sg_tablesize = SG_NONE,\n\t.skip_settle_delay = 1,\n};\n\n#define UNUSUAL_DEV(id_vendor, id_product, bcdDeviceMin, bcdDeviceMax, \\\n\t\t    vendorName, productName, useProtocol, useTransport, \\\n\t\t    initFunction, flags) \\\n{ USB_DEVICE_VER(id_vendor, id_product, bcdDeviceMin, bcdDeviceMax), \\\n\t.driver_info = (flags) }\n\nstatic struct usb_device_id uas_usb_ids[] = {\n#\tinclude \"unusual_uas.h\"\n\t{ USB_INTERFACE_INFO(USB_CLASS_MASS_STORAGE, USB_SC_SCSI, USB_PR_BULK) },\n\t{ USB_INTERFACE_INFO(USB_CLASS_MASS_STORAGE, USB_SC_SCSI, USB_PR_UAS) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(usb, uas_usb_ids);\n\n#undef UNUSUAL_DEV\n\nstatic int uas_switch_interface(struct usb_device *udev,\n\t\t\t\tstruct usb_interface *intf)\n{\n\tint alt;\n\n\talt = uas_find_uas_alt_setting(intf);\n\tif (alt < 0)\n\t\treturn alt;\n\n\treturn usb_set_interface(udev,\n\t\t\tintf->altsetting[0].desc.bInterfaceNumber, alt);\n}\n\nstatic int uas_configure_endpoints(struct uas_dev_info *devinfo)\n{\n\tstruct usb_host_endpoint *eps[4] = { };\n\tstruct usb_device *udev = devinfo->udev;\n\tint r;\n\n\tr = uas_find_endpoints(devinfo->intf->cur_altsetting, eps);\n\tif (r)\n\t\treturn r;\n\n\tdevinfo->cmd_pipe = usb_sndbulkpipe(udev,\n\t\t\t\t\t    usb_endpoint_num(&eps[0]->desc));\n\tdevinfo->status_pipe = usb_rcvbulkpipe(udev,\n\t\t\t\t\t    usb_endpoint_num(&eps[1]->desc));\n\tdevinfo->data_in_pipe = usb_rcvbulkpipe(udev,\n\t\t\t\t\t    usb_endpoint_num(&eps[2]->desc));\n\tdevinfo->data_out_pipe = usb_sndbulkpipe(udev,\n\t\t\t\t\t    usb_endpoint_num(&eps[3]->desc));\n\n\tif (udev->speed < USB_SPEED_SUPER) {\n\t\tdevinfo->qdepth = 32;\n\t\tdevinfo->use_streams = 0;\n\t} else {\n\t\tdevinfo->qdepth = usb_alloc_streams(devinfo->intf, eps + 1,\n\t\t\t\t\t\t    3, MAX_CMNDS, GFP_NOIO);\n\t\tif (devinfo->qdepth < 0)\n\t\t\treturn devinfo->qdepth;\n\t\tdevinfo->use_streams = 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void uas_free_streams(struct uas_dev_info *devinfo)\n{\n\tstruct usb_device *udev = devinfo->udev;\n\tstruct usb_host_endpoint *eps[3];\n\n\teps[0] = usb_pipe_endpoint(udev, devinfo->status_pipe);\n\teps[1] = usb_pipe_endpoint(udev, devinfo->data_in_pipe);\n\teps[2] = usb_pipe_endpoint(udev, devinfo->data_out_pipe);\n\tusb_free_streams(devinfo->intf, eps, 3, GFP_NOIO);\n}\n\nstatic int uas_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tint result = -ENOMEM;\n\tstruct Scsi_Host *shost = NULL;\n\tstruct uas_dev_info *devinfo;\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tunsigned long dev_flags;\n\n\tif (!uas_use_uas_driver(intf, id, &dev_flags))\n\t\treturn -ENODEV;\n\n\tif (uas_switch_interface(udev, intf))\n\t\treturn -ENODEV;\n\n\tshost = scsi_host_alloc(&uas_host_template,\n\t\t\t\tsizeof(struct uas_dev_info));\n\tif (!shost)\n\t\tgoto set_alt0;\n\n\tshost->max_cmd_len = 16 + 252;\n\tshost->max_id = 1;\n\tshost->max_lun = 256;\n\tshost->max_channel = 0;\n\tshost->sg_tablesize = udev->bus->sg_tablesize;\n\n\tdevinfo = (struct uas_dev_info *)shost->hostdata;\n\tdevinfo->intf = intf;\n\tdevinfo->udev = udev;\n\tdevinfo->resetting = 0;\n\tdevinfo->shutdown = 0;\n\tdevinfo->flags = dev_flags;\n\tinit_usb_anchor(&devinfo->cmd_urbs);\n\tinit_usb_anchor(&devinfo->sense_urbs);\n\tinit_usb_anchor(&devinfo->data_urbs);\n\tspin_lock_init(&devinfo->lock);\n\tINIT_WORK(&devinfo->work, uas_do_work);\n\n\tresult = uas_configure_endpoints(devinfo);\n\tif (result)\n\t\tgoto set_alt0;\n\n\t/*\n\t * 1 tag is reserved for untagged commands +\n\t * 1 tag to avoid off by one errors in some bridge firmwares\n\t */\n\tshost->can_queue = devinfo->qdepth - 2;\n\n\tusb_set_intfdata(intf, shost);\n\tresult = scsi_add_host(shost, &intf->dev);\n\tif (result)\n\t\tgoto free_streams;\n\n\tscsi_scan_host(shost);\n\treturn result;\n\nfree_streams:\n\tuas_free_streams(devinfo);\n\tusb_set_intfdata(intf, NULL);\nset_alt0:\n\tusb_set_interface(udev, intf->altsetting[0].desc.bInterfaceNumber, 0);\n\tif (shost)\n\t\tscsi_host_put(shost);\n\treturn result;\n}\n\nstatic int uas_cmnd_list_empty(struct uas_dev_info *devinfo)\n{\n\tunsigned long flags;\n\tint i, r = 1;\n\n\tspin_lock_irqsave(&devinfo->lock, flags);\n\n\tfor (i = 0; i < devinfo->qdepth; i++) {\n\t\tif (devinfo->cmnd[i]) {\n\t\t\tr = 0; /* Not empty */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&devinfo->lock, flags);\n\n\treturn r;\n}\n\n/*\n * Wait for any pending cmnds to complete, on usb-2 sense_urbs may temporarily\n * get empty while there still is more work to do due to sense-urbs completing\n * with a READ/WRITE_READY iu code, so keep waiting until the list gets empty.\n */\nstatic int uas_wait_for_pending_cmnds(struct uas_dev_info *devinfo)\n{\n\tunsigned long start_time;\n\tint r;\n\n\tstart_time = jiffies;\n\tdo {\n\t\tflush_work(&devinfo->work);\n\n\t\tr = usb_wait_anchor_empty_timeout(&devinfo->sense_urbs, 5000);\n\t\tif (r == 0)\n\t\t\treturn -ETIME;\n\n\t\tr = usb_wait_anchor_empty_timeout(&devinfo->data_urbs, 500);\n\t\tif (r == 0)\n\t\t\treturn -ETIME;\n\n\t\tif (time_after(jiffies, start_time + 5 * HZ))\n\t\t\treturn -ETIME;\n\t} while (!uas_cmnd_list_empty(devinfo));\n\n\treturn 0;\n}\n\nstatic int uas_pre_reset(struct usb_interface *intf)\n{\n\tstruct Scsi_Host *shost = usb_get_intfdata(intf);\n\tstruct uas_dev_info *devinfo = (struct uas_dev_info *)shost->hostdata;\n\tunsigned long flags;\n\n\tif (devinfo->shutdown)\n\t\treturn 0;\n\n\t/* Block new requests */\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tscsi_block_requests(shost);\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\n\tif (uas_wait_for_pending_cmnds(devinfo) != 0) {\n\t\tshost_printk(KERN_ERR, shost, \"%s: timed out\\n\", __func__);\n\t\tscsi_unblock_requests(shost);\n\t\treturn 1;\n\t}\n\n\tuas_free_streams(devinfo);\n\n\treturn 0;\n}\n\nstatic int uas_post_reset(struct usb_interface *intf)\n{\n\tstruct Scsi_Host *shost = usb_get_intfdata(intf);\n\tstruct uas_dev_info *devinfo = (struct uas_dev_info *)shost->hostdata;\n\tunsigned long flags;\n\tint err;\n\n\tif (devinfo->shutdown)\n\t\treturn 0;\n\n\terr = uas_configure_endpoints(devinfo);\n\tif (err) {\n\t\tshost_printk(KERN_ERR, shost,\n\t\t\t     \"%s: alloc streams error %d after reset\",\n\t\t\t     __func__, err);\n\t\treturn 1;\n\t}\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tscsi_report_bus_reset(shost, 0);\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\n\tscsi_unblock_requests(shost);\n\n\treturn 0;\n}\n\nstatic int uas_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct Scsi_Host *shost = usb_get_intfdata(intf);\n\tstruct uas_dev_info *devinfo = (struct uas_dev_info *)shost->hostdata;\n\n\tif (uas_wait_for_pending_cmnds(devinfo) != 0) {\n\t\tshost_printk(KERN_ERR, shost, \"%s: timed out\\n\", __func__);\n\t\treturn -ETIME;\n\t}\n\n\treturn 0;\n}\n\nstatic int uas_resume(struct usb_interface *intf)\n{\n\treturn 0;\n}\n\nstatic int uas_reset_resume(struct usb_interface *intf)\n{\n\tstruct Scsi_Host *shost = usb_get_intfdata(intf);\n\tstruct uas_dev_info *devinfo = (struct uas_dev_info *)shost->hostdata;\n\tunsigned long flags;\n\tint err;\n\n\terr = uas_configure_endpoints(devinfo);\n\tif (err) {\n\t\tshost_printk(KERN_ERR, shost,\n\t\t\t     \"%s: alloc streams error %d after reset\",\n\t\t\t     __func__, err);\n\t\treturn -EIO;\n\t}\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tscsi_report_bus_reset(shost, 0);\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\n\treturn 0;\n}\n\nstatic void uas_disconnect(struct usb_interface *intf)\n{\n\tstruct Scsi_Host *shost = usb_get_intfdata(intf);\n\tstruct uas_dev_info *devinfo = (struct uas_dev_info *)shost->hostdata;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&devinfo->lock, flags);\n\tdevinfo->resetting = 1;\n\tspin_unlock_irqrestore(&devinfo->lock, flags);\n\n\tcancel_work_sync(&devinfo->work);\n\tusb_kill_anchored_urbs(&devinfo->cmd_urbs);\n\tusb_kill_anchored_urbs(&devinfo->sense_urbs);\n\tusb_kill_anchored_urbs(&devinfo->data_urbs);\n\tuas_zap_pending(devinfo, DID_NO_CONNECT);\n\n\tscsi_remove_host(shost);\n\tuas_free_streams(devinfo);\n\tscsi_host_put(shost);\n}\n\n/*\n * Put the device back in usb-storage mode on shutdown, as some BIOS-es\n * hang on reboot when the device is still in uas mode. Note the reset is\n * necessary as some devices won't revert to usb-storage mode without it.\n */\nstatic void uas_shutdown(struct device *dev)\n{\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct Scsi_Host *shost = usb_get_intfdata(intf);\n\tstruct uas_dev_info *devinfo = (struct uas_dev_info *)shost->hostdata;\n\n\tif (system_state != SYSTEM_RESTART)\n\t\treturn;\n\n\tdevinfo->shutdown = 1;\n\tuas_free_streams(devinfo);\n\tusb_set_interface(udev, intf->altsetting[0].desc.bInterfaceNumber, 0);\n\tusb_reset_device(udev);\n}\n\nstatic struct usb_driver uas_driver = {\n\t.name = \"uas\",\n\t.probe = uas_probe,\n\t.disconnect = uas_disconnect,\n\t.pre_reset = uas_pre_reset,\n\t.post_reset = uas_post_reset,\n\t.suspend = uas_suspend,\n\t.resume = uas_resume,\n\t.reset_resume = uas_reset_resume,\n\t.drvwrap.driver.shutdown = uas_shutdown,\n\t.id_table = uas_usb_ids,\n};\n\nmodule_usb_driver(uas_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\n\t\"Hans de Goede <hdegoede@redhat.com>, Matthew Wilcox and Sarah Sharp\");\n"], "fixing_code": ["#include <linux/usb.h>\n#include <linux/usb/hcd.h>\n#include \"usb.h\"\n\nstatic int uas_is_interface(struct usb_host_interface *intf)\n{\n\treturn (intf->desc.bInterfaceClass == USB_CLASS_MASS_STORAGE &&\n\t\tintf->desc.bInterfaceSubClass == USB_SC_SCSI &&\n\t\tintf->desc.bInterfaceProtocol == USB_PR_UAS);\n}\n\nstatic struct usb_host_interface *uas_find_uas_alt_setting(\n\t\tstruct usb_interface *intf)\n{\n\tint i;\n\n\tfor (i = 0; i < intf->num_altsetting; i++) {\n\t\tstruct usb_host_interface *alt = &intf->altsetting[i];\n\n\t\tif (uas_is_interface(alt))\n\t\t\treturn alt;\n\t}\n\n\treturn NULL;\n}\n\nstatic int uas_find_endpoints(struct usb_host_interface *alt,\n\t\t\t      struct usb_host_endpoint *eps[])\n{\n\tstruct usb_host_endpoint *endpoint = alt->endpoint;\n\tunsigned i, n_endpoints = alt->desc.bNumEndpoints;\n\n\tfor (i = 0; i < n_endpoints; i++) {\n\t\tunsigned char *extra = endpoint[i].extra;\n\t\tint len = endpoint[i].extralen;\n\t\twhile (len >= 3) {\n\t\t\tif (extra[1] == USB_DT_PIPE_USAGE) {\n\t\t\t\tunsigned pipe_id = extra[2];\n\t\t\t\tif (pipe_id > 0 && pipe_id < 5)\n\t\t\t\t\teps[pipe_id - 1] = &endpoint[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlen -= extra[0];\n\t\t\textra += extra[0];\n\t\t}\n\t}\n\n\tif (!eps[0] || !eps[1] || !eps[2] || !eps[3])\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic int uas_use_uas_driver(struct usb_interface *intf,\n\t\t\t      const struct usb_device_id *id,\n\t\t\t      unsigned long *flags_ret)\n{\n\tstruct usb_host_endpoint *eps[4] = { };\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\tunsigned long flags = id->driver_info;\n\tstruct usb_host_interface *alt;\n\tint r;\n\n\talt = uas_find_uas_alt_setting(intf);\n\tif (!alt)\n\t\treturn 0;\n\n\tr = uas_find_endpoints(alt, eps);\n\tif (r < 0)\n\t\treturn 0;\n\n\t/*\n\t * ASMedia has a number of usb3 to sata bridge chips, at the time of\n\t * this writing the following versions exist:\n\t * ASM1051 - no uas support version\n\t * ASM1051 - with broken (*) uas support\n\t * ASM1053 - with working uas support, but problems with large xfers\n\t * ASM1153 - with working uas support\n\t *\n\t * Devices with these chips re-use a number of device-ids over the\n\t * entire line, so the device-id is useless to determine if we're\n\t * dealing with an ASM1051 (which we want to avoid).\n\t *\n\t * The ASM1153 can be identified by config.MaxPower == 0,\n\t * where as the ASM105x models have config.MaxPower == 36.\n\t *\n\t * Differentiating between the ASM1053 and ASM1051 is trickier, when\n\t * connected over USB-3 we can look at the number of streams supported,\n\t * ASM1051 supports 32 streams, where as early ASM1053 versions support\n\t * 16 streams, newer ASM1053-s also support 32 streams, but have a\n\t * different prod-id.\n\t *\n\t * (*) ASM1051 chips do work with UAS with some disks (with the\n\t *     US_FL_NO_REPORT_OPCODES quirk), but are broken with other disks\n\t */\n\tif (le16_to_cpu(udev->descriptor.idVendor) == 0x174c &&\n\t\t\t(le16_to_cpu(udev->descriptor.idProduct) == 0x5106 ||\n\t\t\t le16_to_cpu(udev->descriptor.idProduct) == 0x55aa)) {\n\t\tif (udev->actconfig->desc.bMaxPower == 0) {\n\t\t\t/* ASM1153, do nothing */\n\t\t} else if (udev->speed < USB_SPEED_SUPER) {\n\t\t\t/* No streams info, assume ASM1051 */\n\t\t\tflags |= US_FL_IGNORE_UAS;\n\t\t} else if (usb_ss_max_streams(&eps[1]->ss_ep_comp) == 32) {\n\t\t\t/* Possibly an ASM1051, disable uas */\n\t\t\tflags |= US_FL_IGNORE_UAS;\n\t\t} else {\n\t\t\t/* ASM1053, these have issues with large transfers */\n\t\t\tflags |= US_FL_MAX_SECTORS_240;\n\t\t}\n\t}\n\n\tusb_stor_adjust_quirks(udev, &flags);\n\n\tif (flags & US_FL_IGNORE_UAS) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\"UAS is blacklisted for this device, using usb-storage instead\\n\");\n\t\treturn 0;\n\t}\n\n\tif (udev->bus->sg_tablesize == 0) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\"The driver for the USB controller %s does not support scatter-gather which is\\n\",\n\t\t\thcd->driver->description);\n\t\tdev_warn(&udev->dev,\n\t\t\t\"required by the UAS driver. Please try an other USB controller if you wish to use UAS.\\n\");\n\t\treturn 0;\n\t}\n\n\tif (udev->speed >= USB_SPEED_SUPER && !hcd->can_do_streams) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\"USB controller %s does not support streams, which are required by the UAS driver.\\n\",\n\t\t\thcd_to_bus(hcd)->bus_name);\n\t\tdev_warn(&udev->dev,\n\t\t\t\"Please try an other USB controller if you wish to use UAS.\\n\");\n\t\treturn 0;\n\t}\n\n\tif (flags_ret)\n\t\t*flags_ret = flags;\n\n\treturn 1;\n}\n", "/*\n * USB Attached SCSI\n * Note that this is not the same as the USB Mass Storage driver\n *\n * Copyright Hans de Goede <hdegoede@redhat.com> for Red Hat, Inc. 2013 - 2016\n * Copyright Matthew Wilcox for Intel Corp, 2010\n * Copyright Sarah Sharp for Intel Corp, 2010\n *\n * Distributed under the terms of the GNU GPL, version two.\n */\n\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/usb.h>\n#include <linux/usb_usual.h>\n#include <linux/usb/hcd.h>\n#include <linux/usb/storage.h>\n#include <linux/usb/uas.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_dbg.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_tcq.h>\n\n#include \"uas-detect.h\"\n#include \"scsiglue.h\"\n\n#define MAX_CMNDS 256\n\nstruct uas_dev_info {\n\tstruct usb_interface *intf;\n\tstruct usb_device *udev;\n\tstruct usb_anchor cmd_urbs;\n\tstruct usb_anchor sense_urbs;\n\tstruct usb_anchor data_urbs;\n\tunsigned long flags;\n\tint qdepth, resetting;\n\tunsigned cmd_pipe, status_pipe, data_in_pipe, data_out_pipe;\n\tunsigned use_streams:1;\n\tunsigned shutdown:1;\n\tstruct scsi_cmnd *cmnd[MAX_CMNDS];\n\tspinlock_t lock;\n\tstruct work_struct work;\n};\n\nenum {\n\tSUBMIT_STATUS_URB\t= BIT(1),\n\tALLOC_DATA_IN_URB\t= BIT(2),\n\tSUBMIT_DATA_IN_URB\t= BIT(3),\n\tALLOC_DATA_OUT_URB\t= BIT(4),\n\tSUBMIT_DATA_OUT_URB\t= BIT(5),\n\tALLOC_CMD_URB\t\t= BIT(6),\n\tSUBMIT_CMD_URB\t\t= BIT(7),\n\tCOMMAND_INFLIGHT        = BIT(8),\n\tDATA_IN_URB_INFLIGHT    = BIT(9),\n\tDATA_OUT_URB_INFLIGHT   = BIT(10),\n\tCOMMAND_ABORTED         = BIT(11),\n\tIS_IN_WORK_LIST         = BIT(12),\n};\n\n/* Overrides scsi_pointer */\nstruct uas_cmd_info {\n\tunsigned int state;\n\tunsigned int uas_tag;\n\tstruct urb *cmd_urb;\n\tstruct urb *data_in_urb;\n\tstruct urb *data_out_urb;\n};\n\n/* I hate forward declarations, but I actually have a loop */\nstatic int uas_submit_urbs(struct scsi_cmnd *cmnd,\n\t\t\t\tstruct uas_dev_info *devinfo);\nstatic void uas_do_work(struct work_struct *work);\nstatic int uas_try_complete(struct scsi_cmnd *cmnd, const char *caller);\nstatic void uas_free_streams(struct uas_dev_info *devinfo);\nstatic void uas_log_cmd_state(struct scsi_cmnd *cmnd, const char *prefix,\n\t\t\t\tint status);\n\nstatic void uas_do_work(struct work_struct *work)\n{\n\tstruct uas_dev_info *devinfo =\n\t\tcontainer_of(work, struct uas_dev_info, work);\n\tstruct uas_cmd_info *cmdinfo;\n\tstruct scsi_cmnd *cmnd;\n\tunsigned long flags;\n\tint i, err;\n\n\tspin_lock_irqsave(&devinfo->lock, flags);\n\n\tif (devinfo->resetting)\n\t\tgoto out;\n\n\tfor (i = 0; i < devinfo->qdepth; i++) {\n\t\tif (!devinfo->cmnd[i])\n\t\t\tcontinue;\n\n\t\tcmnd = devinfo->cmnd[i];\n\t\tcmdinfo = (void *)&cmnd->SCp;\n\n\t\tif (!(cmdinfo->state & IS_IN_WORK_LIST))\n\t\t\tcontinue;\n\n\t\terr = uas_submit_urbs(cmnd, cmnd->device->hostdata);\n\t\tif (!err)\n\t\t\tcmdinfo->state &= ~IS_IN_WORK_LIST;\n\t\telse\n\t\t\tschedule_work(&devinfo->work);\n\t}\nout:\n\tspin_unlock_irqrestore(&devinfo->lock, flags);\n}\n\nstatic void uas_add_work(struct uas_cmd_info *cmdinfo)\n{\n\tstruct scsi_pointer *scp = (void *)cmdinfo;\n\tstruct scsi_cmnd *cmnd = container_of(scp, struct scsi_cmnd, SCp);\n\tstruct uas_dev_info *devinfo = cmnd->device->hostdata;\n\n\tlockdep_assert_held(&devinfo->lock);\n\tcmdinfo->state |= IS_IN_WORK_LIST;\n\tschedule_work(&devinfo->work);\n}\n\nstatic void uas_zap_pending(struct uas_dev_info *devinfo, int result)\n{\n\tstruct uas_cmd_info *cmdinfo;\n\tstruct scsi_cmnd *cmnd;\n\tunsigned long flags;\n\tint i, err;\n\n\tspin_lock_irqsave(&devinfo->lock, flags);\n\tfor (i = 0; i < devinfo->qdepth; i++) {\n\t\tif (!devinfo->cmnd[i])\n\t\t\tcontinue;\n\n\t\tcmnd = devinfo->cmnd[i];\n\t\tcmdinfo = (void *)&cmnd->SCp;\n\t\tuas_log_cmd_state(cmnd, __func__, 0);\n\t\t/* Sense urbs were killed, clear COMMAND_INFLIGHT manually */\n\t\tcmdinfo->state &= ~COMMAND_INFLIGHT;\n\t\tcmnd->result = result << 16;\n\t\terr = uas_try_complete(cmnd, __func__);\n\t\tWARN_ON(err != 0);\n\t}\n\tspin_unlock_irqrestore(&devinfo->lock, flags);\n}\n\nstatic void uas_sense(struct urb *urb, struct scsi_cmnd *cmnd)\n{\n\tstruct sense_iu *sense_iu = urb->transfer_buffer;\n\tstruct scsi_device *sdev = cmnd->device;\n\n\tif (urb->actual_length > 16) {\n\t\tunsigned len = be16_to_cpup(&sense_iu->len);\n\t\tif (len + 16 != urb->actual_length) {\n\t\t\tint newlen = min(len + 16, urb->actual_length) - 16;\n\t\t\tif (newlen < 0)\n\t\t\t\tnewlen = 0;\n\t\t\tsdev_printk(KERN_INFO, sdev, \"%s: urb length %d \"\n\t\t\t\t\"disagrees with IU sense data length %d, \"\n\t\t\t\t\"using %d bytes of sense data\\n\", __func__,\n\t\t\t\t\turb->actual_length, len, newlen);\n\t\t\tlen = newlen;\n\t\t}\n\t\tmemcpy(cmnd->sense_buffer, sense_iu->sense, len);\n\t}\n\n\tcmnd->result = sense_iu->status;\n}\n\nstatic void uas_log_cmd_state(struct scsi_cmnd *cmnd, const char *prefix,\n\t\t\t      int status)\n{\n\tstruct uas_cmd_info *ci = (void *)&cmnd->SCp;\n\tstruct uas_cmd_info *cmdinfo = (void *)&cmnd->SCp;\n\n\tscmd_printk(KERN_INFO, cmnd,\n\t\t    \"%s %d uas-tag %d inflight:%s%s%s%s%s%s%s%s%s%s%s%s \",\n\t\t    prefix, status, cmdinfo->uas_tag,\n\t\t    (ci->state & SUBMIT_STATUS_URB)     ? \" s-st\"  : \"\",\n\t\t    (ci->state & ALLOC_DATA_IN_URB)     ? \" a-in\"  : \"\",\n\t\t    (ci->state & SUBMIT_DATA_IN_URB)    ? \" s-in\"  : \"\",\n\t\t    (ci->state & ALLOC_DATA_OUT_URB)    ? \" a-out\" : \"\",\n\t\t    (ci->state & SUBMIT_DATA_OUT_URB)   ? \" s-out\" : \"\",\n\t\t    (ci->state & ALLOC_CMD_URB)         ? \" a-cmd\" : \"\",\n\t\t    (ci->state & SUBMIT_CMD_URB)        ? \" s-cmd\" : \"\",\n\t\t    (ci->state & COMMAND_INFLIGHT)      ? \" CMD\"   : \"\",\n\t\t    (ci->state & DATA_IN_URB_INFLIGHT)  ? \" IN\"    : \"\",\n\t\t    (ci->state & DATA_OUT_URB_INFLIGHT) ? \" OUT\"   : \"\",\n\t\t    (ci->state & COMMAND_ABORTED)       ? \" abort\" : \"\",\n\t\t    (ci->state & IS_IN_WORK_LIST)       ? \" work\"  : \"\");\n\tscsi_print_command(cmnd);\n}\n\nstatic void uas_free_unsubmitted_urbs(struct scsi_cmnd *cmnd)\n{\n\tstruct uas_cmd_info *cmdinfo;\n\n\tif (!cmnd)\n\t\treturn;\n\n\tcmdinfo = (void *)&cmnd->SCp;\n\n\tif (cmdinfo->state & SUBMIT_CMD_URB)\n\t\tusb_free_urb(cmdinfo->cmd_urb);\n\n\t/* data urbs may have never gotten their submit flag set */\n\tif (!(cmdinfo->state & DATA_IN_URB_INFLIGHT))\n\t\tusb_free_urb(cmdinfo->data_in_urb);\n\tif (!(cmdinfo->state & DATA_OUT_URB_INFLIGHT))\n\t\tusb_free_urb(cmdinfo->data_out_urb);\n}\n\nstatic int uas_try_complete(struct scsi_cmnd *cmnd, const char *caller)\n{\n\tstruct uas_cmd_info *cmdinfo = (void *)&cmnd->SCp;\n\tstruct uas_dev_info *devinfo = (void *)cmnd->device->hostdata;\n\n\tlockdep_assert_held(&devinfo->lock);\n\tif (cmdinfo->state & (COMMAND_INFLIGHT |\n\t\t\t      DATA_IN_URB_INFLIGHT |\n\t\t\t      DATA_OUT_URB_INFLIGHT |\n\t\t\t      COMMAND_ABORTED))\n\t\treturn -EBUSY;\n\tdevinfo->cmnd[cmdinfo->uas_tag - 1] = NULL;\n\tuas_free_unsubmitted_urbs(cmnd);\n\tcmnd->scsi_done(cmnd);\n\treturn 0;\n}\n\nstatic void uas_xfer_data(struct urb *urb, struct scsi_cmnd *cmnd,\n\t\t\t  unsigned direction)\n{\n\tstruct uas_cmd_info *cmdinfo = (void *)&cmnd->SCp;\n\tint err;\n\n\tcmdinfo->state |= direction | SUBMIT_STATUS_URB;\n\terr = uas_submit_urbs(cmnd, cmnd->device->hostdata);\n\tif (err) {\n\t\tuas_add_work(cmdinfo);\n\t}\n}\n\nstatic bool uas_evaluate_response_iu(struct response_iu *riu, struct scsi_cmnd *cmnd)\n{\n\tu8 response_code = riu->response_code;\n\n\tswitch (response_code) {\n\tcase RC_INCORRECT_LUN:\n\t\tcmnd->result = DID_BAD_TARGET << 16;\n\t\tbreak;\n\tcase RC_TMF_SUCCEEDED:\n\t\tcmnd->result = DID_OK << 16;\n\t\tbreak;\n\tcase RC_TMF_NOT_SUPPORTED:\n\t\tcmnd->result = DID_TARGET_FAILURE << 16;\n\t\tbreak;\n\tdefault:\n\t\tuas_log_cmd_state(cmnd, \"response iu\", response_code);\n\t\tcmnd->result = DID_ERROR << 16;\n\t\tbreak;\n\t}\n\n\treturn response_code == RC_TMF_SUCCEEDED;\n}\n\nstatic void uas_stat_cmplt(struct urb *urb)\n{\n\tstruct iu *iu = urb->transfer_buffer;\n\tstruct Scsi_Host *shost = urb->context;\n\tstruct uas_dev_info *devinfo = (struct uas_dev_info *)shost->hostdata;\n\tstruct urb *data_in_urb = NULL;\n\tstruct urb *data_out_urb = NULL;\n\tstruct scsi_cmnd *cmnd;\n\tstruct uas_cmd_info *cmdinfo;\n\tunsigned long flags;\n\tunsigned int idx;\n\tint status = urb->status;\n\tbool success;\n\n\tspin_lock_irqsave(&devinfo->lock, flags);\n\n\tif (devinfo->resetting)\n\t\tgoto out;\n\n\tif (status) {\n\t\tif (status != -ENOENT && status != -ECONNRESET && status != -ESHUTDOWN)\n\t\t\tdev_err(&urb->dev->dev, \"stat urb: status %d\\n\", status);\n\t\tgoto out;\n\t}\n\n\tidx = be16_to_cpup(&iu->tag) - 1;\n\tif (idx >= MAX_CMNDS || !devinfo->cmnd[idx]) {\n\t\tdev_err(&urb->dev->dev,\n\t\t\t\"stat urb: no pending cmd for uas-tag %d\\n\", idx + 1);\n\t\tgoto out;\n\t}\n\n\tcmnd = devinfo->cmnd[idx];\n\tcmdinfo = (void *)&cmnd->SCp;\n\n\tif (!(cmdinfo->state & COMMAND_INFLIGHT)) {\n\t\tuas_log_cmd_state(cmnd, \"unexpected status cmplt\", 0);\n\t\tgoto out;\n\t}\n\n\tswitch (iu->iu_id) {\n\tcase IU_ID_STATUS:\n\t\tuas_sense(urb, cmnd);\n\t\tif (cmnd->result != 0) {\n\t\t\t/* cancel data transfers on error */\n\t\t\tdata_in_urb = usb_get_urb(cmdinfo->data_in_urb);\n\t\t\tdata_out_urb = usb_get_urb(cmdinfo->data_out_urb);\n\t\t}\n\t\tcmdinfo->state &= ~COMMAND_INFLIGHT;\n\t\tuas_try_complete(cmnd, __func__);\n\t\tbreak;\n\tcase IU_ID_READ_READY:\n\t\tif (!cmdinfo->data_in_urb ||\n\t\t\t\t(cmdinfo->state & DATA_IN_URB_INFLIGHT)) {\n\t\t\tuas_log_cmd_state(cmnd, \"unexpected read rdy\", 0);\n\t\t\tbreak;\n\t\t}\n\t\tuas_xfer_data(urb, cmnd, SUBMIT_DATA_IN_URB);\n\t\tbreak;\n\tcase IU_ID_WRITE_READY:\n\t\tif (!cmdinfo->data_out_urb ||\n\t\t\t\t(cmdinfo->state & DATA_OUT_URB_INFLIGHT)) {\n\t\t\tuas_log_cmd_state(cmnd, \"unexpected write rdy\", 0);\n\t\t\tbreak;\n\t\t}\n\t\tuas_xfer_data(urb, cmnd, SUBMIT_DATA_OUT_URB);\n\t\tbreak;\n\tcase IU_ID_RESPONSE:\n\t\tcmdinfo->state &= ~COMMAND_INFLIGHT;\n\t\tsuccess = uas_evaluate_response_iu((struct response_iu *)iu, cmnd);\n\t\tif (!success) {\n\t\t\t/* Error, cancel data transfers */\n\t\t\tdata_in_urb = usb_get_urb(cmdinfo->data_in_urb);\n\t\t\tdata_out_urb = usb_get_urb(cmdinfo->data_out_urb);\n\t\t}\n\t\tuas_try_complete(cmnd, __func__);\n\t\tbreak;\n\tdefault:\n\t\tuas_log_cmd_state(cmnd, \"bogus IU\", iu->iu_id);\n\t}\nout:\n\tusb_free_urb(urb);\n\tspin_unlock_irqrestore(&devinfo->lock, flags);\n\n\t/* Unlinking of data urbs must be done without holding the lock */\n\tif (data_in_urb) {\n\t\tusb_unlink_urb(data_in_urb);\n\t\tusb_put_urb(data_in_urb);\n\t}\n\tif (data_out_urb) {\n\t\tusb_unlink_urb(data_out_urb);\n\t\tusb_put_urb(data_out_urb);\n\t}\n}\n\nstatic void uas_data_cmplt(struct urb *urb)\n{\n\tstruct scsi_cmnd *cmnd = urb->context;\n\tstruct uas_cmd_info *cmdinfo = (void *)&cmnd->SCp;\n\tstruct uas_dev_info *devinfo = (void *)cmnd->device->hostdata;\n\tstruct scsi_data_buffer *sdb = NULL;\n\tunsigned long flags;\n\tint status = urb->status;\n\n\tspin_lock_irqsave(&devinfo->lock, flags);\n\n\tif (cmdinfo->data_in_urb == urb) {\n\t\tsdb = scsi_in(cmnd);\n\t\tcmdinfo->state &= ~DATA_IN_URB_INFLIGHT;\n\t\tcmdinfo->data_in_urb = NULL;\n\t} else if (cmdinfo->data_out_urb == urb) {\n\t\tsdb = scsi_out(cmnd);\n\t\tcmdinfo->state &= ~DATA_OUT_URB_INFLIGHT;\n\t\tcmdinfo->data_out_urb = NULL;\n\t}\n\tif (sdb == NULL) {\n\t\tWARN_ON_ONCE(1);\n\t\tgoto out;\n\t}\n\n\tif (devinfo->resetting)\n\t\tgoto out;\n\n\t/* Data urbs should not complete before the cmd urb is submitted */\n\tif (cmdinfo->state & SUBMIT_CMD_URB) {\n\t\tuas_log_cmd_state(cmnd, \"unexpected data cmplt\", 0);\n\t\tgoto out;\n\t}\n\n\tif (status) {\n\t\tif (status != -ENOENT && status != -ECONNRESET && status != -ESHUTDOWN)\n\t\t\tuas_log_cmd_state(cmnd, \"data cmplt err\", status);\n\t\t/* error: no data transfered */\n\t\tsdb->resid = sdb->length;\n\t} else {\n\t\tsdb->resid = sdb->length - urb->actual_length;\n\t}\n\tuas_try_complete(cmnd, __func__);\nout:\n\tusb_free_urb(urb);\n\tspin_unlock_irqrestore(&devinfo->lock, flags);\n}\n\nstatic void uas_cmd_cmplt(struct urb *urb)\n{\n\tif (urb->status)\n\t\tdev_err(&urb->dev->dev, \"cmd cmplt err %d\\n\", urb->status);\n\n\tusb_free_urb(urb);\n}\n\nstatic struct urb *uas_alloc_data_urb(struct uas_dev_info *devinfo, gfp_t gfp,\n\t\t\t\t      struct scsi_cmnd *cmnd,\n\t\t\t\t      enum dma_data_direction dir)\n{\n\tstruct usb_device *udev = devinfo->udev;\n\tstruct uas_cmd_info *cmdinfo = (void *)&cmnd->SCp;\n\tstruct urb *urb = usb_alloc_urb(0, gfp);\n\tstruct scsi_data_buffer *sdb = (dir == DMA_FROM_DEVICE)\n\t\t? scsi_in(cmnd) : scsi_out(cmnd);\n\tunsigned int pipe = (dir == DMA_FROM_DEVICE)\n\t\t? devinfo->data_in_pipe : devinfo->data_out_pipe;\n\n\tif (!urb)\n\t\tgoto out;\n\tusb_fill_bulk_urb(urb, udev, pipe, NULL, sdb->length,\n\t\t\t  uas_data_cmplt, cmnd);\n\tif (devinfo->use_streams)\n\t\turb->stream_id = cmdinfo->uas_tag;\n\turb->num_sgs = udev->bus->sg_tablesize ? sdb->table.nents : 0;\n\turb->sg = sdb->table.sgl;\n out:\n\treturn urb;\n}\n\nstatic struct urb *uas_alloc_sense_urb(struct uas_dev_info *devinfo, gfp_t gfp,\n\t\t\t\t       struct scsi_cmnd *cmnd)\n{\n\tstruct usb_device *udev = devinfo->udev;\n\tstruct uas_cmd_info *cmdinfo = (void *)&cmnd->SCp;\n\tstruct urb *urb = usb_alloc_urb(0, gfp);\n\tstruct sense_iu *iu;\n\n\tif (!urb)\n\t\tgoto out;\n\n\tiu = kzalloc(sizeof(*iu), gfp);\n\tif (!iu)\n\t\tgoto free;\n\n\tusb_fill_bulk_urb(urb, udev, devinfo->status_pipe, iu, sizeof(*iu),\n\t\t\t  uas_stat_cmplt, cmnd->device->host);\n\tif (devinfo->use_streams)\n\t\turb->stream_id = cmdinfo->uas_tag;\n\turb->transfer_flags |= URB_FREE_BUFFER;\n out:\n\treturn urb;\n free:\n\tusb_free_urb(urb);\n\treturn NULL;\n}\n\nstatic struct urb *uas_alloc_cmd_urb(struct uas_dev_info *devinfo, gfp_t gfp,\n\t\t\t\t\tstruct scsi_cmnd *cmnd)\n{\n\tstruct usb_device *udev = devinfo->udev;\n\tstruct scsi_device *sdev = cmnd->device;\n\tstruct uas_cmd_info *cmdinfo = (void *)&cmnd->SCp;\n\tstruct urb *urb = usb_alloc_urb(0, gfp);\n\tstruct command_iu *iu;\n\tint len;\n\n\tif (!urb)\n\t\tgoto out;\n\n\tlen = cmnd->cmd_len - 16;\n\tif (len < 0)\n\t\tlen = 0;\n\tlen = ALIGN(len, 4);\n\tiu = kzalloc(sizeof(*iu) + len, gfp);\n\tif (!iu)\n\t\tgoto free;\n\n\tiu->iu_id = IU_ID_COMMAND;\n\tiu->tag = cpu_to_be16(cmdinfo->uas_tag);\n\tiu->prio_attr = UAS_SIMPLE_TAG;\n\tiu->len = len;\n\tint_to_scsilun(sdev->lun, &iu->lun);\n\tmemcpy(iu->cdb, cmnd->cmnd, cmnd->cmd_len);\n\n\tusb_fill_bulk_urb(urb, udev, devinfo->cmd_pipe, iu, sizeof(*iu) + len,\n\t\t\t\t\t\t\tuas_cmd_cmplt, NULL);\n\turb->transfer_flags |= URB_FREE_BUFFER;\n out:\n\treturn urb;\n free:\n\tusb_free_urb(urb);\n\treturn NULL;\n}\n\n/*\n * Why should I request the Status IU before sending the Command IU?  Spec\n * says to, but also says the device may receive them in any order.  Seems\n * daft to me.\n */\n\nstatic struct urb *uas_submit_sense_urb(struct scsi_cmnd *cmnd, gfp_t gfp)\n{\n\tstruct uas_dev_info *devinfo = cmnd->device->hostdata;\n\tstruct urb *urb;\n\tint err;\n\n\turb = uas_alloc_sense_urb(devinfo, gfp, cmnd);\n\tif (!urb)\n\t\treturn NULL;\n\tusb_anchor_urb(urb, &devinfo->sense_urbs);\n\terr = usb_submit_urb(urb, gfp);\n\tif (err) {\n\t\tusb_unanchor_urb(urb);\n\t\tuas_log_cmd_state(cmnd, \"sense submit err\", err);\n\t\tusb_free_urb(urb);\n\t\treturn NULL;\n\t}\n\treturn urb;\n}\n\nstatic int uas_submit_urbs(struct scsi_cmnd *cmnd,\n\t\t\t   struct uas_dev_info *devinfo)\n{\n\tstruct uas_cmd_info *cmdinfo = (void *)&cmnd->SCp;\n\tstruct urb *urb;\n\tint err;\n\n\tlockdep_assert_held(&devinfo->lock);\n\tif (cmdinfo->state & SUBMIT_STATUS_URB) {\n\t\turb = uas_submit_sense_urb(cmnd, GFP_ATOMIC);\n\t\tif (!urb)\n\t\t\treturn SCSI_MLQUEUE_DEVICE_BUSY;\n\t\tcmdinfo->state &= ~SUBMIT_STATUS_URB;\n\t}\n\n\tif (cmdinfo->state & ALLOC_DATA_IN_URB) {\n\t\tcmdinfo->data_in_urb = uas_alloc_data_urb(devinfo, GFP_ATOMIC,\n\t\t\t\t\t\t\tcmnd, DMA_FROM_DEVICE);\n\t\tif (!cmdinfo->data_in_urb)\n\t\t\treturn SCSI_MLQUEUE_DEVICE_BUSY;\n\t\tcmdinfo->state &= ~ALLOC_DATA_IN_URB;\n\t}\n\n\tif (cmdinfo->state & SUBMIT_DATA_IN_URB) {\n\t\tusb_anchor_urb(cmdinfo->data_in_urb, &devinfo->data_urbs);\n\t\terr = usb_submit_urb(cmdinfo->data_in_urb, GFP_ATOMIC);\n\t\tif (err) {\n\t\t\tusb_unanchor_urb(cmdinfo->data_in_urb);\n\t\t\tuas_log_cmd_state(cmnd, \"data in submit err\", err);\n\t\t\treturn SCSI_MLQUEUE_DEVICE_BUSY;\n\t\t}\n\t\tcmdinfo->state &= ~SUBMIT_DATA_IN_URB;\n\t\tcmdinfo->state |= DATA_IN_URB_INFLIGHT;\n\t}\n\n\tif (cmdinfo->state & ALLOC_DATA_OUT_URB) {\n\t\tcmdinfo->data_out_urb = uas_alloc_data_urb(devinfo, GFP_ATOMIC,\n\t\t\t\t\t\t\tcmnd, DMA_TO_DEVICE);\n\t\tif (!cmdinfo->data_out_urb)\n\t\t\treturn SCSI_MLQUEUE_DEVICE_BUSY;\n\t\tcmdinfo->state &= ~ALLOC_DATA_OUT_URB;\n\t}\n\n\tif (cmdinfo->state & SUBMIT_DATA_OUT_URB) {\n\t\tusb_anchor_urb(cmdinfo->data_out_urb, &devinfo->data_urbs);\n\t\terr = usb_submit_urb(cmdinfo->data_out_urb, GFP_ATOMIC);\n\t\tif (err) {\n\t\t\tusb_unanchor_urb(cmdinfo->data_out_urb);\n\t\t\tuas_log_cmd_state(cmnd, \"data out submit err\", err);\n\t\t\treturn SCSI_MLQUEUE_DEVICE_BUSY;\n\t\t}\n\t\tcmdinfo->state &= ~SUBMIT_DATA_OUT_URB;\n\t\tcmdinfo->state |= DATA_OUT_URB_INFLIGHT;\n\t}\n\n\tif (cmdinfo->state & ALLOC_CMD_URB) {\n\t\tcmdinfo->cmd_urb = uas_alloc_cmd_urb(devinfo, GFP_ATOMIC, cmnd);\n\t\tif (!cmdinfo->cmd_urb)\n\t\t\treturn SCSI_MLQUEUE_DEVICE_BUSY;\n\t\tcmdinfo->state &= ~ALLOC_CMD_URB;\n\t}\n\n\tif (cmdinfo->state & SUBMIT_CMD_URB) {\n\t\tusb_anchor_urb(cmdinfo->cmd_urb, &devinfo->cmd_urbs);\n\t\terr = usb_submit_urb(cmdinfo->cmd_urb, GFP_ATOMIC);\n\t\tif (err) {\n\t\t\tusb_unanchor_urb(cmdinfo->cmd_urb);\n\t\t\tuas_log_cmd_state(cmnd, \"cmd submit err\", err);\n\t\t\treturn SCSI_MLQUEUE_DEVICE_BUSY;\n\t\t}\n\t\tcmdinfo->cmd_urb = NULL;\n\t\tcmdinfo->state &= ~SUBMIT_CMD_URB;\n\t\tcmdinfo->state |= COMMAND_INFLIGHT;\n\t}\n\n\treturn 0;\n}\n\nstatic int uas_queuecommand_lck(struct scsi_cmnd *cmnd,\n\t\t\t\t\tvoid (*done)(struct scsi_cmnd *))\n{\n\tstruct scsi_device *sdev = cmnd->device;\n\tstruct uas_dev_info *devinfo = sdev->hostdata;\n\tstruct uas_cmd_info *cmdinfo = (void *)&cmnd->SCp;\n\tunsigned long flags;\n\tint idx, err;\n\n\tBUILD_BUG_ON(sizeof(struct uas_cmd_info) > sizeof(struct scsi_pointer));\n\n\t/* Re-check scsi_block_requests now that we've the host-lock */\n\tif (cmnd->device->host->host_self_blocked)\n\t\treturn SCSI_MLQUEUE_DEVICE_BUSY;\n\n\tif ((devinfo->flags & US_FL_NO_ATA_1X) &&\n\t\t\t(cmnd->cmnd[0] == ATA_12 || cmnd->cmnd[0] == ATA_16)) {\n\t\tmemcpy(cmnd->sense_buffer, usb_stor_sense_invalidCDB,\n\t\t       sizeof(usb_stor_sense_invalidCDB));\n\t\tcmnd->result = SAM_STAT_CHECK_CONDITION;\n\t\tcmnd->scsi_done(cmnd);\n\t\treturn 0;\n\t}\n\n\tspin_lock_irqsave(&devinfo->lock, flags);\n\n\tif (devinfo->resetting) {\n\t\tcmnd->result = DID_ERROR << 16;\n\t\tcmnd->scsi_done(cmnd);\n\t\tspin_unlock_irqrestore(&devinfo->lock, flags);\n\t\treturn 0;\n\t}\n\n\t/* Find a free uas-tag */\n\tfor (idx = 0; idx < devinfo->qdepth; idx++) {\n\t\tif (!devinfo->cmnd[idx])\n\t\t\tbreak;\n\t}\n\tif (idx == devinfo->qdepth) {\n\t\tspin_unlock_irqrestore(&devinfo->lock, flags);\n\t\treturn SCSI_MLQUEUE_DEVICE_BUSY;\n\t}\n\n\tcmnd->scsi_done = done;\n\n\tmemset(cmdinfo, 0, sizeof(*cmdinfo));\n\tcmdinfo->uas_tag = idx + 1; /* uas-tag == usb-stream-id, so 1 based */\n\tcmdinfo->state = SUBMIT_STATUS_URB | ALLOC_CMD_URB | SUBMIT_CMD_URB;\n\n\tswitch (cmnd->sc_data_direction) {\n\tcase DMA_FROM_DEVICE:\n\t\tcmdinfo->state |= ALLOC_DATA_IN_URB | SUBMIT_DATA_IN_URB;\n\t\tbreak;\n\tcase DMA_BIDIRECTIONAL:\n\t\tcmdinfo->state |= ALLOC_DATA_IN_URB | SUBMIT_DATA_IN_URB;\n\tcase DMA_TO_DEVICE:\n\t\tcmdinfo->state |= ALLOC_DATA_OUT_URB | SUBMIT_DATA_OUT_URB;\n\tcase DMA_NONE:\n\t\tbreak;\n\t}\n\n\tif (!devinfo->use_streams)\n\t\tcmdinfo->state &= ~(SUBMIT_DATA_IN_URB | SUBMIT_DATA_OUT_URB);\n\n\terr = uas_submit_urbs(cmnd, devinfo);\n\tif (err) {\n\t\t/* If we did nothing, give up now */\n\t\tif (cmdinfo->state & SUBMIT_STATUS_URB) {\n\t\t\tspin_unlock_irqrestore(&devinfo->lock, flags);\n\t\t\treturn SCSI_MLQUEUE_DEVICE_BUSY;\n\t\t}\n\t\tuas_add_work(cmdinfo);\n\t}\n\n\tdevinfo->cmnd[idx] = cmnd;\n\tspin_unlock_irqrestore(&devinfo->lock, flags);\n\treturn 0;\n}\n\nstatic DEF_SCSI_QCMD(uas_queuecommand)\n\n/*\n * For now we do not support actually sending an abort to the device, so\n * this eh always fails. Still we must define it to make sure that we've\n * dropped all references to the cmnd in question once this function exits.\n */\nstatic int uas_eh_abort_handler(struct scsi_cmnd *cmnd)\n{\n\tstruct uas_cmd_info *cmdinfo = (void *)&cmnd->SCp;\n\tstruct uas_dev_info *devinfo = (void *)cmnd->device->hostdata;\n\tstruct urb *data_in_urb = NULL;\n\tstruct urb *data_out_urb = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&devinfo->lock, flags);\n\n\tuas_log_cmd_state(cmnd, __func__, 0);\n\n\t/* Ensure that try_complete does not call scsi_done */\n\tcmdinfo->state |= COMMAND_ABORTED;\n\n\t/* Drop all refs to this cmnd, kill data urbs to break their ref */\n\tdevinfo->cmnd[cmdinfo->uas_tag - 1] = NULL;\n\tif (cmdinfo->state & DATA_IN_URB_INFLIGHT)\n\t\tdata_in_urb = usb_get_urb(cmdinfo->data_in_urb);\n\tif (cmdinfo->state & DATA_OUT_URB_INFLIGHT)\n\t\tdata_out_urb = usb_get_urb(cmdinfo->data_out_urb);\n\n\tuas_free_unsubmitted_urbs(cmnd);\n\n\tspin_unlock_irqrestore(&devinfo->lock, flags);\n\n\tif (data_in_urb) {\n\t\tusb_kill_urb(data_in_urb);\n\t\tusb_put_urb(data_in_urb);\n\t}\n\tif (data_out_urb) {\n\t\tusb_kill_urb(data_out_urb);\n\t\tusb_put_urb(data_out_urb);\n\t}\n\n\treturn FAILED;\n}\n\nstatic int uas_eh_device_reset_handler(struct scsi_cmnd *cmnd)\n{\n\tstruct scsi_device *sdev = cmnd->device;\n\tstruct uas_dev_info *devinfo = sdev->hostdata;\n\tstruct usb_device *udev = devinfo->udev;\n\tunsigned long flags;\n\tint err;\n\n\terr = usb_lock_device_for_reset(udev, devinfo->intf);\n\tif (err) {\n\t\tshost_printk(KERN_ERR, sdev->host,\n\t\t\t     \"%s FAILED to get lock err %d\\n\", __func__, err);\n\t\treturn FAILED;\n\t}\n\n\tshost_printk(KERN_INFO, sdev->host, \"%s start\\n\", __func__);\n\n\tspin_lock_irqsave(&devinfo->lock, flags);\n\tdevinfo->resetting = 1;\n\tspin_unlock_irqrestore(&devinfo->lock, flags);\n\n\tusb_kill_anchored_urbs(&devinfo->cmd_urbs);\n\tusb_kill_anchored_urbs(&devinfo->sense_urbs);\n\tusb_kill_anchored_urbs(&devinfo->data_urbs);\n\tuas_zap_pending(devinfo, DID_RESET);\n\n\terr = usb_reset_device(udev);\n\n\tspin_lock_irqsave(&devinfo->lock, flags);\n\tdevinfo->resetting = 0;\n\tspin_unlock_irqrestore(&devinfo->lock, flags);\n\n\tusb_unlock_device(udev);\n\n\tif (err) {\n\t\tshost_printk(KERN_INFO, sdev->host, \"%s FAILED err %d\\n\",\n\t\t\t     __func__, err);\n\t\treturn FAILED;\n\t}\n\n\tshost_printk(KERN_INFO, sdev->host, \"%s success\\n\", __func__);\n\treturn SUCCESS;\n}\n\nstatic int uas_target_alloc(struct scsi_target *starget)\n{\n\tstruct uas_dev_info *devinfo = (struct uas_dev_info *)\n\t\t\tdev_to_shost(starget->dev.parent)->hostdata;\n\n\tif (devinfo->flags & US_FL_NO_REPORT_LUNS)\n\t\tstarget->no_report_luns = 1;\n\n\treturn 0;\n}\n\nstatic int uas_slave_alloc(struct scsi_device *sdev)\n{\n\tstruct uas_dev_info *devinfo =\n\t\t(struct uas_dev_info *)sdev->host->hostdata;\n\n\tsdev->hostdata = devinfo;\n\n\t/*\n\t * USB has unusual DMA-alignment requirements: Although the\n\t * starting address of each scatter-gather element doesn't matter,\n\t * the length of each element except the last must be divisible\n\t * by the Bulk maxpacket value.  There's currently no way to\n\t * express this by block-layer constraints, so we'll cop out\n\t * and simply require addresses to be aligned at 512-byte\n\t * boundaries.  This is okay since most block I/O involves\n\t * hardware sectors that are multiples of 512 bytes in length,\n\t * and since host controllers up through USB 2.0 have maxpacket\n\t * values no larger than 512.\n\t *\n\t * But it doesn't suffice for Wireless USB, where Bulk maxpacket\n\t * values can be as large as 2048.  To make that work properly\n\t * will require changes to the block layer.\n\t */\n\tblk_queue_update_dma_alignment(sdev->request_queue, (512 - 1));\n\n\tif (devinfo->flags & US_FL_MAX_SECTORS_64)\n\t\tblk_queue_max_hw_sectors(sdev->request_queue, 64);\n\telse if (devinfo->flags & US_FL_MAX_SECTORS_240)\n\t\tblk_queue_max_hw_sectors(sdev->request_queue, 240);\n\n\treturn 0;\n}\n\nstatic int uas_slave_configure(struct scsi_device *sdev)\n{\n\tstruct uas_dev_info *devinfo = sdev->hostdata;\n\n\tif (devinfo->flags & US_FL_NO_REPORT_OPCODES)\n\t\tsdev->no_report_opcodes = 1;\n\n\t/* A few buggy USB-ATA bridges don't understand FUA */\n\tif (devinfo->flags & US_FL_BROKEN_FUA)\n\t\tsdev->broken_fua = 1;\n\n\tscsi_change_queue_depth(sdev, devinfo->qdepth - 2);\n\treturn 0;\n}\n\nstatic struct scsi_host_template uas_host_template = {\n\t.module = THIS_MODULE,\n\t.name = \"uas\",\n\t.queuecommand = uas_queuecommand,\n\t.target_alloc = uas_target_alloc,\n\t.slave_alloc = uas_slave_alloc,\n\t.slave_configure = uas_slave_configure,\n\t.eh_abort_handler = uas_eh_abort_handler,\n\t.eh_device_reset_handler = uas_eh_device_reset_handler,\n\t.this_id = -1,\n\t.sg_tablesize = SG_NONE,\n\t.skip_settle_delay = 1,\n};\n\n#define UNUSUAL_DEV(id_vendor, id_product, bcdDeviceMin, bcdDeviceMax, \\\n\t\t    vendorName, productName, useProtocol, useTransport, \\\n\t\t    initFunction, flags) \\\n{ USB_DEVICE_VER(id_vendor, id_product, bcdDeviceMin, bcdDeviceMax), \\\n\t.driver_info = (flags) }\n\nstatic struct usb_device_id uas_usb_ids[] = {\n#\tinclude \"unusual_uas.h\"\n\t{ USB_INTERFACE_INFO(USB_CLASS_MASS_STORAGE, USB_SC_SCSI, USB_PR_BULK) },\n\t{ USB_INTERFACE_INFO(USB_CLASS_MASS_STORAGE, USB_SC_SCSI, USB_PR_UAS) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(usb, uas_usb_ids);\n\n#undef UNUSUAL_DEV\n\nstatic int uas_switch_interface(struct usb_device *udev,\n\t\t\t\tstruct usb_interface *intf)\n{\n\tstruct usb_host_interface *alt;\n\n\talt = uas_find_uas_alt_setting(intf);\n\tif (!alt)\n\t\treturn -ENODEV;\n\n\treturn usb_set_interface(udev, alt->desc.bInterfaceNumber,\n\t\t\talt->desc.bAlternateSetting);\n}\n\nstatic int uas_configure_endpoints(struct uas_dev_info *devinfo)\n{\n\tstruct usb_host_endpoint *eps[4] = { };\n\tstruct usb_device *udev = devinfo->udev;\n\tint r;\n\n\tr = uas_find_endpoints(devinfo->intf->cur_altsetting, eps);\n\tif (r)\n\t\treturn r;\n\n\tdevinfo->cmd_pipe = usb_sndbulkpipe(udev,\n\t\t\t\t\t    usb_endpoint_num(&eps[0]->desc));\n\tdevinfo->status_pipe = usb_rcvbulkpipe(udev,\n\t\t\t\t\t    usb_endpoint_num(&eps[1]->desc));\n\tdevinfo->data_in_pipe = usb_rcvbulkpipe(udev,\n\t\t\t\t\t    usb_endpoint_num(&eps[2]->desc));\n\tdevinfo->data_out_pipe = usb_sndbulkpipe(udev,\n\t\t\t\t\t    usb_endpoint_num(&eps[3]->desc));\n\n\tif (udev->speed < USB_SPEED_SUPER) {\n\t\tdevinfo->qdepth = 32;\n\t\tdevinfo->use_streams = 0;\n\t} else {\n\t\tdevinfo->qdepth = usb_alloc_streams(devinfo->intf, eps + 1,\n\t\t\t\t\t\t    3, MAX_CMNDS, GFP_NOIO);\n\t\tif (devinfo->qdepth < 0)\n\t\t\treturn devinfo->qdepth;\n\t\tdevinfo->use_streams = 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void uas_free_streams(struct uas_dev_info *devinfo)\n{\n\tstruct usb_device *udev = devinfo->udev;\n\tstruct usb_host_endpoint *eps[3];\n\n\teps[0] = usb_pipe_endpoint(udev, devinfo->status_pipe);\n\teps[1] = usb_pipe_endpoint(udev, devinfo->data_in_pipe);\n\teps[2] = usb_pipe_endpoint(udev, devinfo->data_out_pipe);\n\tusb_free_streams(devinfo->intf, eps, 3, GFP_NOIO);\n}\n\nstatic int uas_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tint result = -ENOMEM;\n\tstruct Scsi_Host *shost = NULL;\n\tstruct uas_dev_info *devinfo;\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tunsigned long dev_flags;\n\n\tif (!uas_use_uas_driver(intf, id, &dev_flags))\n\t\treturn -ENODEV;\n\n\tif (uas_switch_interface(udev, intf))\n\t\treturn -ENODEV;\n\n\tshost = scsi_host_alloc(&uas_host_template,\n\t\t\t\tsizeof(struct uas_dev_info));\n\tif (!shost)\n\t\tgoto set_alt0;\n\n\tshost->max_cmd_len = 16 + 252;\n\tshost->max_id = 1;\n\tshost->max_lun = 256;\n\tshost->max_channel = 0;\n\tshost->sg_tablesize = udev->bus->sg_tablesize;\n\n\tdevinfo = (struct uas_dev_info *)shost->hostdata;\n\tdevinfo->intf = intf;\n\tdevinfo->udev = udev;\n\tdevinfo->resetting = 0;\n\tdevinfo->shutdown = 0;\n\tdevinfo->flags = dev_flags;\n\tinit_usb_anchor(&devinfo->cmd_urbs);\n\tinit_usb_anchor(&devinfo->sense_urbs);\n\tinit_usb_anchor(&devinfo->data_urbs);\n\tspin_lock_init(&devinfo->lock);\n\tINIT_WORK(&devinfo->work, uas_do_work);\n\n\tresult = uas_configure_endpoints(devinfo);\n\tif (result)\n\t\tgoto set_alt0;\n\n\t/*\n\t * 1 tag is reserved for untagged commands +\n\t * 1 tag to avoid off by one errors in some bridge firmwares\n\t */\n\tshost->can_queue = devinfo->qdepth - 2;\n\n\tusb_set_intfdata(intf, shost);\n\tresult = scsi_add_host(shost, &intf->dev);\n\tif (result)\n\t\tgoto free_streams;\n\n\tscsi_scan_host(shost);\n\treturn result;\n\nfree_streams:\n\tuas_free_streams(devinfo);\n\tusb_set_intfdata(intf, NULL);\nset_alt0:\n\tusb_set_interface(udev, intf->altsetting[0].desc.bInterfaceNumber, 0);\n\tif (shost)\n\t\tscsi_host_put(shost);\n\treturn result;\n}\n\nstatic int uas_cmnd_list_empty(struct uas_dev_info *devinfo)\n{\n\tunsigned long flags;\n\tint i, r = 1;\n\n\tspin_lock_irqsave(&devinfo->lock, flags);\n\n\tfor (i = 0; i < devinfo->qdepth; i++) {\n\t\tif (devinfo->cmnd[i]) {\n\t\t\tr = 0; /* Not empty */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&devinfo->lock, flags);\n\n\treturn r;\n}\n\n/*\n * Wait for any pending cmnds to complete, on usb-2 sense_urbs may temporarily\n * get empty while there still is more work to do due to sense-urbs completing\n * with a READ/WRITE_READY iu code, so keep waiting until the list gets empty.\n */\nstatic int uas_wait_for_pending_cmnds(struct uas_dev_info *devinfo)\n{\n\tunsigned long start_time;\n\tint r;\n\n\tstart_time = jiffies;\n\tdo {\n\t\tflush_work(&devinfo->work);\n\n\t\tr = usb_wait_anchor_empty_timeout(&devinfo->sense_urbs, 5000);\n\t\tif (r == 0)\n\t\t\treturn -ETIME;\n\n\t\tr = usb_wait_anchor_empty_timeout(&devinfo->data_urbs, 500);\n\t\tif (r == 0)\n\t\t\treturn -ETIME;\n\n\t\tif (time_after(jiffies, start_time + 5 * HZ))\n\t\t\treturn -ETIME;\n\t} while (!uas_cmnd_list_empty(devinfo));\n\n\treturn 0;\n}\n\nstatic int uas_pre_reset(struct usb_interface *intf)\n{\n\tstruct Scsi_Host *shost = usb_get_intfdata(intf);\n\tstruct uas_dev_info *devinfo = (struct uas_dev_info *)shost->hostdata;\n\tunsigned long flags;\n\n\tif (devinfo->shutdown)\n\t\treturn 0;\n\n\t/* Block new requests */\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tscsi_block_requests(shost);\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\n\tif (uas_wait_for_pending_cmnds(devinfo) != 0) {\n\t\tshost_printk(KERN_ERR, shost, \"%s: timed out\\n\", __func__);\n\t\tscsi_unblock_requests(shost);\n\t\treturn 1;\n\t}\n\n\tuas_free_streams(devinfo);\n\n\treturn 0;\n}\n\nstatic int uas_post_reset(struct usb_interface *intf)\n{\n\tstruct Scsi_Host *shost = usb_get_intfdata(intf);\n\tstruct uas_dev_info *devinfo = (struct uas_dev_info *)shost->hostdata;\n\tunsigned long flags;\n\tint err;\n\n\tif (devinfo->shutdown)\n\t\treturn 0;\n\n\terr = uas_configure_endpoints(devinfo);\n\tif (err) {\n\t\tshost_printk(KERN_ERR, shost,\n\t\t\t     \"%s: alloc streams error %d after reset\",\n\t\t\t     __func__, err);\n\t\treturn 1;\n\t}\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tscsi_report_bus_reset(shost, 0);\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\n\tscsi_unblock_requests(shost);\n\n\treturn 0;\n}\n\nstatic int uas_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct Scsi_Host *shost = usb_get_intfdata(intf);\n\tstruct uas_dev_info *devinfo = (struct uas_dev_info *)shost->hostdata;\n\n\tif (uas_wait_for_pending_cmnds(devinfo) != 0) {\n\t\tshost_printk(KERN_ERR, shost, \"%s: timed out\\n\", __func__);\n\t\treturn -ETIME;\n\t}\n\n\treturn 0;\n}\n\nstatic int uas_resume(struct usb_interface *intf)\n{\n\treturn 0;\n}\n\nstatic int uas_reset_resume(struct usb_interface *intf)\n{\n\tstruct Scsi_Host *shost = usb_get_intfdata(intf);\n\tstruct uas_dev_info *devinfo = (struct uas_dev_info *)shost->hostdata;\n\tunsigned long flags;\n\tint err;\n\n\terr = uas_configure_endpoints(devinfo);\n\tif (err) {\n\t\tshost_printk(KERN_ERR, shost,\n\t\t\t     \"%s: alloc streams error %d after reset\",\n\t\t\t     __func__, err);\n\t\treturn -EIO;\n\t}\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tscsi_report_bus_reset(shost, 0);\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\n\treturn 0;\n}\n\nstatic void uas_disconnect(struct usb_interface *intf)\n{\n\tstruct Scsi_Host *shost = usb_get_intfdata(intf);\n\tstruct uas_dev_info *devinfo = (struct uas_dev_info *)shost->hostdata;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&devinfo->lock, flags);\n\tdevinfo->resetting = 1;\n\tspin_unlock_irqrestore(&devinfo->lock, flags);\n\n\tcancel_work_sync(&devinfo->work);\n\tusb_kill_anchored_urbs(&devinfo->cmd_urbs);\n\tusb_kill_anchored_urbs(&devinfo->sense_urbs);\n\tusb_kill_anchored_urbs(&devinfo->data_urbs);\n\tuas_zap_pending(devinfo, DID_NO_CONNECT);\n\n\tscsi_remove_host(shost);\n\tuas_free_streams(devinfo);\n\tscsi_host_put(shost);\n}\n\n/*\n * Put the device back in usb-storage mode on shutdown, as some BIOS-es\n * hang on reboot when the device is still in uas mode. Note the reset is\n * necessary as some devices won't revert to usb-storage mode without it.\n */\nstatic void uas_shutdown(struct device *dev)\n{\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct Scsi_Host *shost = usb_get_intfdata(intf);\n\tstruct uas_dev_info *devinfo = (struct uas_dev_info *)shost->hostdata;\n\n\tif (system_state != SYSTEM_RESTART)\n\t\treturn;\n\n\tdevinfo->shutdown = 1;\n\tuas_free_streams(devinfo);\n\tusb_set_interface(udev, intf->altsetting[0].desc.bInterfaceNumber, 0);\n\tusb_reset_device(udev);\n}\n\nstatic struct usb_driver uas_driver = {\n\t.name = \"uas\",\n\t.probe = uas_probe,\n\t.disconnect = uas_disconnect,\n\t.pre_reset = uas_pre_reset,\n\t.post_reset = uas_post_reset,\n\t.suspend = uas_suspend,\n\t.resume = uas_resume,\n\t.reset_resume = uas_reset_resume,\n\t.drvwrap.driver.shutdown = uas_shutdown,\n\t.id_table = uas_usb_ids,\n};\n\nmodule_usb_driver(uas_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\n\t\"Hans de Goede <hdegoede@redhat.com>, Matthew Wilcox and Sarah Sharp\");\n"], "filenames": ["drivers/usb/storage/uas-detect.h", "drivers/usb/storage/uas.c"], "buggy_code_start_loc": [12, 876], "buggy_code_end_loc": [69, 884], "fixing_code_start_loc": [12, 876], "fixing_code_end_loc": [70, 884], "type": "CWE-125", "message": "The uas driver in the Linux kernel before 4.13.6 allows local users to cause a denial of service (out-of-bounds read and system crash) or possibly have unspecified other impact via a crafted USB device, related to drivers/usb/storage/uas-detect.h and drivers/usb/storage/uas.c.", "other": {"cve": {"id": "CVE-2017-16530", "sourceIdentifier": "cve@mitre.org", "published": "2017-11-04T01:29:36.913", "lastModified": "2017-11-17T13:52:21.493", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The uas driver in the Linux kernel before 4.13.6 allows local users to cause a denial of service (out-of-bounds read and system crash) or possibly have unspecified other impact via a crafted USB device, related to drivers/usb/storage/uas-detect.h and drivers/usb/storage/uas.c."}, {"lang": "es", "value": "El controlador uas en el kernel de Linux, en versiones anteriores a la 4.13.6, permite que los usuarios locales provoquen una denegaci\u00f3n de servicio (lectura fuera de l\u00edmites y cierre inesperado del sistema) o, posiblemente, causen otros impactos no especificados mediante llamadas del sistema manipuladas. Esto est\u00e1 relacionado con drivers/usb/storage/uas-detect.h y drivers/usb/storage/uas.c."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:P/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "PHYSICAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.7, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.13.5", "matchCriteriaId": "8CBA5FF4-3406-4A63-9242-E6597219C011"}]}]}], "references": [{"url": "https://github.com/torvalds/linux/commit/786de92b3cb26012d3d0f00ee37adf14527f35c4", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://groups.google.com/d/msg/syzkaller/pCswO77gRlM/VHuPOftgAwAJ", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/786de92b3cb26012d3d0f00ee37adf14527f35c4"}}