{"buggy_code": ["/*\n * Copyright (C) 2021-2023 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,\n * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.\n *\n * This file is part of Amaze File Utilities.\n *\n * Amaze File Utilities is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\npackage com.amaze.fileutilities.home_page\n\nimport android.Manifest\nimport android.content.Context\nimport android.content.Intent\nimport android.content.pm.PackageManager\nimport android.location.LocationManager\nimport android.net.ConnectivityManager\nimport android.net.Uri\nimport android.os.Build\nimport android.os.Bundle\nimport android.os.Environment\nimport android.provider.Settings\nimport android.widget.Toast\nimport androidx.appcompat.app.AlertDialog\nimport androidx.core.app.ActivityCompat\nimport com.amaze.fileutilities.R\nimport com.amaze.fileutilities.utilis.showToastInCenter\nimport com.stephentuso.welcome.WelcomeActivity\nimport org.slf4j.Logger\nimport org.slf4j.LoggerFactory\n\n/**\n * Remove duplication of this class with PermissionActivity\n */\nabstract class WelcomePermissionScreen :\n    WelcomeActivity(),\n    ActivityCompat.OnRequestPermissionsResultCallback {\n\n    private var log: Logger = LoggerFactory.getLogger(WelcomePermissionScreen::class.java)\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n    }\n\n    fun haveStoragePermissions(): Boolean {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\n            if (!checkStoragePermission()) {\n                return false\n            }\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R &&\n                !Environment.isExternalStorageManager()\n            ) {\n                return false\n            }\n        }\n        return true\n    }\n\n    companion object {\n        private const val PERMISSION_LENGTH = 3\n        private const val STORAGE_PERMISSION = 0\n        private const val ALL_FILES_PERMISSION = 1\n        private const val LOCATION_PERMISSION = 2\n    }\n\n    private val permissionCallbacks = arrayOfNulls<OnPermissionGranted>(PERMISSION_LENGTH)\n\n    val onPermissionGranted = object : OnPermissionGranted {\n        override fun onPermissionGranted(isGranted: Boolean) {\n            if (isGranted) {\n//                Utils.enableScreenRotation(this@PermissionsActivity)\n                /*val action = Intent(this@WelcomePermissionScreen, MainActivity::class.java)\n                action.addCategory(Intent.CATEGORY_LAUNCHER)\n                startActivity(action)\n                finish()*/\n            } else {\n                Toast.makeText(\n                    this@WelcomePermissionScreen, R.string.grantfailed,\n                    Toast.LENGTH_SHORT\n                ).show()\n                requestStoragePermission(\n                    permissionCallbacks[STORAGE_PERMISSION]!!,\n                    false\n                )\n            }\n            permissionCallbacks[STORAGE_PERMISSION] = null\n        }\n    }\n\n    override fun onRequestPermissionsResult(\n        requestCode: Int,\n        permissions: Array<String?>,\n        grantResults: IntArray\n    ) {\n        super.onRequestPermissionsResult(requestCode, permissions, grantResults)\n        if (requestCode == STORAGE_PERMISSION) {\n            permissionCallbacks[STORAGE_PERMISSION]?.onPermissionGranted(isGranted(grantResults))\n        } else if (requestCode == LOCATION_PERMISSION) {\n            if (isGranted(grantResults)) {\n//                Utils.enableScreenRotation(this)\n                permissionCallbacks[LOCATION_PERMISSION]!!.onPermissionGranted(true)\n                permissionCallbacks[LOCATION_PERMISSION] = null\n            } else {\n                Toast.makeText(this, R.string.grant_location_failed, Toast.LENGTH_SHORT).show()\n                requestStoragePermission(\n                    permissionCallbacks[LOCATION_PERMISSION]!!,\n                    false\n                )\n                permissionCallbacks[LOCATION_PERMISSION]!!.onPermissionGranted(false)\n                permissionCallbacks[LOCATION_PERMISSION] = null\n            }\n        }\n    }\n\n    fun isNetworkAvailable(): Boolean {\n        val connectivityManager = getSystemService(CONNECTIVITY_SERVICE) as ConnectivityManager\n        val activeNetworkInfo = connectivityManager.activeNetworkInfo\n        return activeNetworkInfo != null && activeNetworkInfo.isConnected\n    }\n\n    fun checkStoragePermission(): Boolean {\n        // Verify that all required contact permissions have been granted.\n        return (\n            ActivityCompat.checkSelfPermission(\n                this,\n                Manifest.permission.WRITE_EXTERNAL_STORAGE\n            )\n                == PackageManager.PERMISSION_GRANTED\n            )\n    }\n\n    fun isLocationEnabled(onPermissionGranted: OnPermissionGranted) {\n        val manager = getSystemService(Context.LOCATION_SERVICE) as LocationManager\n        if (!manager.isProviderEnabled(LocationManager.GPS_PROVIDER)) {\n            buildAlertMessageNoGps(onPermissionGranted)\n            onPermissionGranted.onPermissionGranted(false)\n        } else {\n            onPermissionGranted.onPermissionGranted(true)\n        }\n    }\n\n    private fun buildAlertMessageNoGps(onPermissionGranted: OnPermissionGranted) {\n        val builder = AlertDialog.Builder(this, R.style.Custom_Dialog_Dark)\n        builder.setMessage(resources.getString(R.string.gps_disabled))\n            .setCancelable(false)\n            .setPositiveButton(\n                resources.getString(R.string.yes)\n            ) { dialog, _ ->\n                startActivity(Intent(Settings.ACTION_LOCATION_SOURCE_SETTINGS))\n                dialog.cancel()\n            }\n            .setNegativeButton(\n                resources.getString(R.string.no)\n            ) { dialog, _ ->\n                onPermissionGranted.onPermissionGranted(false)\n                dialog.cancel()\n            }\n        val alert = builder.create()\n        alert.show()\n    }\n\n    fun initLocationResources(onPermissionGranted: OnPermissionGranted) {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M && !checkLocationPermission()) {\n            val builder: AlertDialog.Builder = this.let {\n                AlertDialog.Builder(this, R.style.Custom_Dialog_Dark)\n            }\n            builder.setMessage(R.string.grant_location_permission)\n                .setTitle(R.string.grant_permission)\n                .setNegativeButton(R.string.cancel) { dialog, _ ->\n                }.setCancelable(false)\n            requestPermission(\n                Manifest.permission.ACCESS_FINE_LOCATION,\n                LOCATION_PERMISSION,\n                builder,\n                onPermissionGranted,\n                true\n            )\n            onPermissionGranted.onPermissionGranted(false)\n        } else {\n            onPermissionGranted.onPermissionGranted(true)\n        }\n    }\n\n    private fun checkLocationPermission(): Boolean {\n        // Verify that all required contact permissions have been granted.\n        return (\n            ActivityCompat.checkSelfPermission(\n                this,\n                Manifest.permission.ACCESS_FINE_LOCATION\n            )\n                == PackageManager.PERMISSION_GRANTED\n            )/* && (\n                ActivityCompat.checkSelfPermission(\n                    this,\n                    Manifest.permission.ACCESS_COARSE_LOCATION\n                )\n                        == PackageManager.PERMISSION_GRANTED\n                )*/\n    }\n\n    fun requestStoragePermission(\n        onPermissionGranted: OnPermissionGranted,\n        isInitialStart: Boolean\n    ) {\n//        Utils.disableScreenRotation(this)\n        val builder: AlertDialog.Builder = this.let {\n            AlertDialog.Builder(it, R.style.Custom_Dialog_Dark)\n        }\n        builder.setMessage(R.string.grant_storage_read_permission)\n            .setTitle(R.string.grant_permission)\n            .setNegativeButton(R.string.cancel) { dialog, _ ->\n                finish()\n            }.setCancelable(false)\n        requestPermission(\n            Manifest.permission.WRITE_EXTERNAL_STORAGE,\n            STORAGE_PERMISSION,\n            builder,\n            onPermissionGranted,\n            isInitialStart\n        )\n    }\n\n    /**\n     * Requests permission, overrides {@param rationale}'s POSITIVE button dialog action.\n     *\n     * @param permission The permission to ask for\n     * @param code [.STORAGE_PERMISSION] or [.INSTALL_APK_PERMISSION]\n     * @param rationale MaterialLayout to provide an additional rationale to the user if the\n     * permission was not granted and the user would benefit from additional context for the use\n     * of the permission. For example, if the request has been denied previously.\n     * @param isInitialStart is the permission being requested for the first time in the application\n     * lifecycle\n     */\n    private fun requestPermission(\n        permission: String,\n        code: Int,\n        rationale: AlertDialog.Builder,\n        onPermissionGranted: OnPermissionGranted,\n        isInitialStart: Boolean\n    ) {\n        permissionCallbacks[code] = onPermissionGranted\n        if (ActivityCompat.shouldShowRequestPermissionRationale(this, permission)) {\n            rationale\n                .setPositiveButton(R.string.grant) { dialog, _ ->\n                    run {\n                        ActivityCompat.requestPermissions(\n                            this@WelcomePermissionScreen, arrayOf(permission), code\n                        )\n                        dialog.cancel()\n                    }\n                }\n            rationale.show()\n        } else if (isInitialStart) {\n            ActivityCompat.requestPermissions(this, arrayOf(permission), code)\n        } else {\n            /*Snackbar.make(\n                findViewById(R.id.frameLayout),\n                R.string.grantfailed,\n                BaseTransientBottomBar.LENGTH_INDEFINITE\n            )\n                .setAction(\n                    R.string.grant\n                ) { v ->\n                    startActivity(\n                        Intent(\n                            Settings.ACTION_APPLICATION_DETAILS_SETTINGS,\n                            Uri.parse(java.lang.String.format(\"package:%s\", packageName))\n                        )\n                    )\n                }\n                .show()*/\n            applicationContext.showToastInCenter(getString(R.string.grantfailed))\n            finish()\n        }\n    }\n\n    /**\n     * Request all files access on android 11+\n     *\n     * @param onPermissionGranted permission granted callback\n     */\n    fun requestAllFilesAccess(onPermissionGranted: OnPermissionGranted) {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R &&\n            !Environment.isExternalStorageManager()\n        ) {\n            val builder: AlertDialog.Builder = this.let {\n                AlertDialog.Builder(it, R.style.Custom_Dialog_Dark)\n            }\n            builder.setMessage(R.string.grant_all_files_permission)\n                .setTitle(R.string.grant_permission)\n                .setNegativeButton(R.string.cancel) { dialog, _ ->\n                    run {\n                        dialog.dismiss()\n                    }\n                }\n                .setPositiveButton(R.string.grant) { dialog, _ ->\n                    run {\n//                        Utils.disableScreenRotation(this)\n                        permissionCallbacks[ALL_FILES_PERMISSION] = onPermissionGranted\n                        try {\n                            val intent =\n                                Intent(Settings.ACTION_MANAGE_APP_ALL_FILES_ACCESS_PERMISSION)\n                                    .setData(Uri.parse(\"package:$packageName\"))\n                            startActivity(intent)\n                        } catch (e: Exception) {\n                            log.error(\"Failed to initial activity to grant all files access\", e)\n                            applicationContext.showToastInCenter(getString(R.string.grantfailed))\n                        }\n                        dialog.cancel()\n                    }\n                }.setCancelable(false).show()\n        }\n    }\n\n    private fun isGranted(grantResults: IntArray): Boolean {\n        return grantResults.size == 1 && grantResults[0] == PackageManager.PERMISSION_GRANTED\n    }\n\n    interface OnPermissionGranted {\n        fun onPermissionGranted(isGranted: Boolean)\n    }\n}\n"], "fixing_code": ["/*\n * Copyright (C) 2021-2023 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,\n * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.\n *\n * This file is part of Amaze File Utilities.\n *\n * Amaze File Utilities is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\npackage com.amaze.fileutilities.home_page\n\nimport android.Manifest\nimport android.content.Context\nimport android.content.Intent\nimport android.content.pm.PackageManager\nimport android.location.LocationManager\nimport android.net.ConnectivityManager\nimport android.net.Uri\nimport android.os.Build\nimport android.os.Bundle\nimport android.os.Environment\nimport android.provider.Settings\nimport android.widget.Toast\nimport androidx.appcompat.app.AlertDialog\nimport androidx.core.app.ActivityCompat\nimport com.amaze.fileutilities.R\nimport com.amaze.fileutilities.utilis.showToastInCenter\nimport com.stephentuso.welcome.WelcomeActivity\nimport com.stephentuso.welcome.WelcomeUtils\nimport org.slf4j.Logger\nimport org.slf4j.LoggerFactory\n\n/**\n * Remove duplication of this class with PermissionActivity\n */\nabstract class WelcomePermissionScreen :\n    WelcomeActivity(),\n    ActivityCompat.OnRequestPermissionsResultCallback {\n\n    private var log: Logger = LoggerFactory.getLogger(WelcomePermissionScreen::class.java)\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n    }\n\n    fun haveStoragePermissions(): Boolean {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\n            if (!checkStoragePermission()) {\n                return false\n            }\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R &&\n                !Environment.isExternalStorageManager()\n            ) {\n                return false\n            }\n        }\n        return true\n    }\n\n    companion object {\n        private const val PERMISSION_LENGTH = 3\n        private const val STORAGE_PERMISSION = 0\n        private const val ALL_FILES_PERMISSION = 1\n        private const val LOCATION_PERMISSION = 2\n    }\n\n    private val permissionCallbacks = arrayOfNulls<OnPermissionGranted>(PERMISSION_LENGTH)\n\n    val onPermissionGranted = object : OnPermissionGranted {\n        override fun onPermissionGranted(isGranted: Boolean) {\n            if (isGranted) {\n//                Utils.enableScreenRotation(this@PermissionsActivity)\n                /*val action = Intent(this@WelcomePermissionScreen, MainActivity::class.java)\n                action.addCategory(Intent.CATEGORY_LAUNCHER)\n                startActivity(action)\n                finish()*/\n            } else {\n                Toast.makeText(\n                    this@WelcomePermissionScreen, R.string.grantfailed,\n                    Toast.LENGTH_SHORT\n                ).show()\n                requestStoragePermission(\n                    permissionCallbacks[STORAGE_PERMISSION]!!,\n                    false\n                )\n            }\n            permissionCallbacks[STORAGE_PERMISSION] = null\n        }\n    }\n\n    override fun onRequestPermissionsResult(\n        requestCode: Int,\n        permissions: Array<String?>,\n        grantResults: IntArray\n    ) {\n        super.onRequestPermissionsResult(requestCode, permissions, grantResults)\n        if (requestCode == STORAGE_PERMISSION) {\n            permissionCallbacks[STORAGE_PERMISSION]?.onPermissionGranted(isGranted(grantResults))\n        } else if (requestCode == LOCATION_PERMISSION) {\n            if (isGranted(grantResults)) {\n//                Utils.enableScreenRotation(this)\n                permissionCallbacks[LOCATION_PERMISSION]!!.onPermissionGranted(true)\n                permissionCallbacks[LOCATION_PERMISSION] = null\n            } else {\n                Toast.makeText(this, R.string.grant_location_failed, Toast.LENGTH_SHORT).show()\n                requestStoragePermission(\n                    permissionCallbacks[LOCATION_PERMISSION]!!,\n                    false\n                )\n                permissionCallbacks[LOCATION_PERMISSION]!!.onPermissionGranted(false)\n                permissionCallbacks[LOCATION_PERMISSION] = null\n            }\n        }\n    }\n\n    fun isNetworkAvailable(): Boolean {\n        val connectivityManager = getSystemService(CONNECTIVITY_SERVICE) as ConnectivityManager\n        val activeNetworkInfo = connectivityManager.activeNetworkInfo\n        return activeNetworkInfo != null && activeNetworkInfo.isConnected\n    }\n\n    fun checkStoragePermission(): Boolean {\n        // Verify that all required contact permissions have been granted.\n        return (\n            ActivityCompat.checkSelfPermission(\n                this,\n                Manifest.permission.WRITE_EXTERNAL_STORAGE\n            )\n                == PackageManager.PERMISSION_GRANTED\n            )\n    }\n\n    fun isLocationEnabled(onPermissionGranted: OnPermissionGranted) {\n        val manager = getSystemService(Context.LOCATION_SERVICE) as LocationManager\n        if (!manager.isProviderEnabled(LocationManager.GPS_PROVIDER)) {\n            buildAlertMessageNoGps(onPermissionGranted)\n            onPermissionGranted.onPermissionGranted(false)\n        } else {\n            onPermissionGranted.onPermissionGranted(true)\n        }\n    }\n\n    private fun buildAlertMessageNoGps(onPermissionGranted: OnPermissionGranted) {\n        val builder = AlertDialog.Builder(this, R.style.Custom_Dialog_Dark)\n        builder.setMessage(resources.getString(R.string.gps_disabled))\n            .setCancelable(false)\n            .setPositiveButton(\n                resources.getString(R.string.yes)\n            ) { dialog, _ ->\n                startActivity(Intent(Settings.ACTION_LOCATION_SOURCE_SETTINGS))\n                dialog.cancel()\n            }\n            .setNegativeButton(\n                resources.getString(R.string.no)\n            ) { dialog, _ ->\n                onPermissionGranted.onPermissionGranted(false)\n                dialog.cancel()\n            }\n        val alert = builder.create()\n        alert.show()\n    }\n\n    fun initLocationResources(onPermissionGranted: OnPermissionGranted) {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M && !checkLocationPermission()) {\n            val builder: AlertDialog.Builder = this.let {\n                AlertDialog.Builder(this, R.style.Custom_Dialog_Dark)\n            }\n            builder.setMessage(R.string.grant_location_permission)\n                .setTitle(R.string.grant_permission)\n                .setNegativeButton(R.string.cancel) { dialog, _ ->\n                }.setCancelable(false)\n            requestPermission(\n                Manifest.permission.ACCESS_FINE_LOCATION,\n                LOCATION_PERMISSION,\n                builder,\n                onPermissionGranted,\n                true\n            )\n            onPermissionGranted.onPermissionGranted(false)\n        } else {\n            onPermissionGranted.onPermissionGranted(true)\n        }\n    }\n\n    private fun checkLocationPermission(): Boolean {\n        // Verify that all required contact permissions have been granted.\n        return (\n            ActivityCompat.checkSelfPermission(\n                this,\n                Manifest.permission.ACCESS_FINE_LOCATION\n            )\n                == PackageManager.PERMISSION_GRANTED\n            )/* && (\n                ActivityCompat.checkSelfPermission(\n                    this,\n                    Manifest.permission.ACCESS_COARSE_LOCATION\n                )\n                        == PackageManager.PERMISSION_GRANTED\n                )*/\n    }\n\n    fun requestStoragePermission(\n        onPermissionGranted: OnPermissionGranted,\n        isInitialStart: Boolean\n    ) {\n//        Utils.disableScreenRotation(this)\n        val builder: AlertDialog.Builder = this.let {\n            AlertDialog.Builder(it, R.style.Custom_Dialog_Dark)\n        }\n        builder.setMessage(R.string.grant_storage_read_permission)\n            .setTitle(R.string.grant_permission)\n            .setNegativeButton(R.string.cancel) { dialog, _ ->\n                finish()\n            }.setCancelable(false)\n        requestPermission(\n            Manifest.permission.WRITE_EXTERNAL_STORAGE,\n            STORAGE_PERMISSION,\n            builder,\n            onPermissionGranted,\n            isInitialStart\n        )\n    }\n\n    /**\n     * Requests permission, overrides {@param rationale}'s POSITIVE button dialog action.\n     *\n     * @param permission The permission to ask for\n     * @param code [.STORAGE_PERMISSION] or [.INSTALL_APK_PERMISSION]\n     * @param rationale MaterialLayout to provide an additional rationale to the user if the\n     * permission was not granted and the user would benefit from additional context for the use\n     * of the permission. For example, if the request has been denied previously.\n     * @param isInitialStart is the permission being requested for the first time in the application\n     * lifecycle\n     */\n    private fun requestPermission(\n        permission: String,\n        code: Int,\n        rationale: AlertDialog.Builder,\n        onPermissionGranted: OnPermissionGranted,\n        isInitialStart: Boolean\n    ) {\n        permissionCallbacks[code] = onPermissionGranted\n        if (ActivityCompat.shouldShowRequestPermissionRationale(this, permission)) {\n            rationale\n                .setPositiveButton(R.string.grant) { dialog, _ ->\n                    run {\n                        ActivityCompat.requestPermissions(\n                            this@WelcomePermissionScreen, arrayOf(permission), code\n                        )\n                        dialog.cancel()\n                    }\n                }\n            rationale.show()\n        } else if (isInitialStart) {\n            ActivityCompat.requestPermissions(this, arrayOf(permission), code)\n        } else {\n            /*Snackbar.make(\n                findViewById(R.id.frameLayout),\n                R.string.grantfailed,\n                BaseTransientBottomBar.LENGTH_INDEFINITE\n            )\n                .setAction(\n                    R.string.grant\n                ) { v ->\n                    startActivity(\n                        Intent(\n                            Settings.ACTION_APPLICATION_DETAILS_SETTINGS,\n                            Uri.parse(java.lang.String.format(\"package:%s\", packageName))\n                        )\n                    )\n                }\n                .show()*/\n            applicationContext.showToastInCenter(getString(R.string.grantfailed))\n            finish()\n        }\n    }\n\n    /**\n     * Request all files access on android 11+\n     *\n     * @param onPermissionGranted permission granted callback\n     */\n    fun requestAllFilesAccess(onPermissionGranted: OnPermissionGranted) {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R &&\n            !Environment.isExternalStorageManager()\n        ) {\n            val builder: AlertDialog.Builder = this.let {\n                AlertDialog.Builder(it, R.style.Custom_Dialog_Dark)\n            }\n            builder.setMessage(R.string.grant_all_files_permission)\n                .setTitle(R.string.grant_permission)\n                .setNegativeButton(R.string.cancel) { dialog, _ ->\n                    run {\n                        dialog.dismiss()\n                    }\n                }\n                .setPositiveButton(R.string.grant) { dialog, _ ->\n                    run {\n//                        Utils.disableScreenRotation(this)\n                        permissionCallbacks[ALL_FILES_PERMISSION] = onPermissionGranted\n                        try {\n                            val intent =\n                                Intent(Settings.ACTION_MANAGE_APP_ALL_FILES_ACCESS_PERMISSION)\n                                    .setData(Uri.parse(\"package:$packageName\"))\n                            startActivity(intent)\n                        } catch (e: Exception) {\n                            log.error(\"Failed to initial activity to grant all files access\", e)\n                            applicationContext.showToastInCenter(getString(R.string.grantfailed))\n                        }\n                        dialog.cancel()\n                    }\n                }.setCancelable(false).show()\n        }\n    }\n\n    private fun isGranted(grantResults: IntArray): Boolean {\n        return grantResults.size == 1 && grantResults[0] == PackageManager.PERMISSION_GRANTED\n    }\n\n    /**\n     *  Remove all flags and URI that put into the Intent.\n     *  We are finishing the app here, so any URI provided will not be useful anyway.\n     */\n    override fun cancelWelcomeScreen() {\n        val intent = this.intent\n        intent.flags = -1\n        intent.data = null\n        intent.putExtra(WELCOME_SCREEN_KEY, WelcomeUtils.getKey(this.javaClass))\n        this.setResult(RESULT_CANCELED, intent)\n        finish()\n    }\n\n    interface OnPermissionGranted {\n        fun onPermissionGranted(isGranted: Boolean)\n    }\n}\n"], "filenames": ["app/src/main/java/com/amaze/fileutilities/home_page/WelcomePermissionScreen.kt"], "buggy_code_start_loc": [39], "buggy_code_end_loc": [329], "fixing_code_start_loc": [40], "fixing_code_end_loc": [344], "type": "CWE-285", "message": "Improper Authorization in GitHub repository teamamaze/amazefileutilities prior to 1.91.", "other": {"cve": {"id": "CVE-2023-5948", "sourceIdentifier": "security@huntr.dev", "published": "2023-11-03T07:15:14.723", "lastModified": "2023-11-13T19:55:35.617", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Improper Authorization in GitHub repository teamamaze/amazefileutilities prior to 1.91."}, {"lang": "es", "value": "Autorizaci\u00f3n incorrecta en el repositorio de GitHub teamamaze/amazefileutilities antes de la versi\u00f3n 1.91."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.8}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-285"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:teamamaze:amaze_file_utilities:*:*:*:*:*:android:*:*", "versionEndExcluding": "1.90", "matchCriteriaId": "33284830-CF90-4B0D-BF5C-9953F44AC738"}]}]}], "references": [{"url": "https://github.com/teamamaze/amazefileutilities/commit/62d02204d452603ab85c50d43c7c680e4256c7d7", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.com/bounties/ac1363b5-207b-40d9-aac5-e66d6213f692", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/teamamaze/amazefileutilities/commit/62d02204d452603ab85c50d43c7c680e4256c7d7"}}