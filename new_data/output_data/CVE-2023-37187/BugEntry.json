{"buggy_code": ["/*\n  Copyright (c) 2021  The Blosc Development Team <blosc@blosc.org>\n  https://blosc.org\n  License: BSD 3-Clause (see LICENSE.txt)\n*/\n\n#include \"blosc-private.h\"\n#include \"zfp.h\"\n#include \"blosc2-zfp.h\"\n#include \"../plugins/codecs/zfp/zfp-private.h\"\n#include \"../plugins/plugin_utils.h\"\n#include \"context.h\"\n#include \"frame.h\"\n#include \"blosc2/codecs-registry.h\"\n#include \"blosc2.h\"\n\n#include <assert.h>\n#include <math.h>\n#include <stdlib.h>\n#include <string.h>\n\n\nint zfp_acc_compress(const uint8_t *input, int32_t input_len, uint8_t *output,\n                     int32_t output_len, uint8_t meta, blosc2_cparams *cparams, const void *chunk) {\n  BLOSC_UNUSED_PARAM(chunk);\n  ZFP_ERROR_NULL(input);\n  ZFP_ERROR_NULL(output);\n  ZFP_ERROR_NULL(cparams);\n\n  double tol = (int8_t) meta;\n  int8_t ndim;\n  int64_t *shape = malloc(8 * sizeof(int64_t));\n  int32_t *chunkshape = malloc(8 * sizeof(int32_t));\n  int32_t *blockshape = malloc(8 * sizeof(int32_t));\n  uint8_t *smeta;\n  int32_t smeta_len;\n  if (blosc2_meta_get(cparams->schunk, \"b2nd\", &smeta, &smeta_len) < 0) {\n    free(shape);\n    free(chunkshape);\n    free(blockshape);\n    BLOSC_TRACE_ERROR(\"b2nd layer not found!\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n  deserialize_meta(smeta, smeta_len, &ndim, shape, chunkshape, blockshape);\n  free(smeta);\n\n  for(int i = 0; i < ndim; i++) {\n    if (blockshape[i] < 4) {\n      BLOSC_TRACE_ERROR(\"ZFP does not support blocks smaller than cells (4x...x4\");\n      return BLOSC2_ERROR_FAILURE;\n    }\n  }\n\n  zfp_type type;     /* array scalar type */\n  zfp_field *field;  /* array meta data */\n  zfp_stream *zfp;   /* stream containing the real output buffer */\n  zfp_stream *zfp_aux;   /* auxiliary compressed stream */\n  bitstream *stream; /* bit stream to write to or read from */\n  bitstream *stream_aux; /* auxiliary bit stream to write to or read from */\n  size_t zfpsize;    /* byte size of compressed stream */\n  double tolerance = pow(10, tol);\n\n  int32_t typesize = cparams->typesize;\n\n  switch (typesize) {\n    case sizeof(float):\n      type = zfp_type_float;\n      break;\n    case sizeof(double):\n      type = zfp_type_double;\n      break;\n    default:\n      free(shape);\n      free(chunkshape);\n      free(blockshape);\n      BLOSC_TRACE_ERROR(\"ZFP is not available for typesize: %d\", typesize);\n      return BLOSC2_ERROR_FAILURE;\n  }\n\n  zfp = zfp_stream_open(NULL);\n  zfp_stream_set_accuracy(zfp, tolerance);\n  stream = stream_open(output, output_len);\n  zfp_stream_set_bit_stream(zfp, stream);\n  zfp_stream_rewind(zfp);\n\n  switch (ndim) {\n    case 1:\n      field = zfp_field_1d((void *) input, type, blockshape[0]);\n      break;\n    case 2:\n      field = zfp_field_2d((void *) input, type, blockshape[1], blockshape[0]);\n      break;\n    case 3:\n      field = zfp_field_3d((void *) input, type, blockshape[2], blockshape[1], blockshape[0]);\n      break;\n    case 4:\n      field = zfp_field_4d((void *) input, type, blockshape[3], blockshape[2], blockshape[1], blockshape[0]);\n      break;\n    default:\n      free(shape);\n      free(chunkshape);\n      free(blockshape);\n      BLOSC_TRACE_ERROR(\"ZFP is not available for ndims: %d\", ndim);\n      return BLOSC2_ERROR_FAILURE;\n  }\n\n  int zfp_maxout = (int) zfp_stream_maximum_size(zfp, field);\n  zfp_stream_close(zfp);\n  stream_close(stream);\n  uint8_t *aux_out = malloc(zfp_maxout);\n  zfp_aux = zfp_stream_open(NULL);\n  zfp_stream_set_accuracy(zfp_aux, tolerance);\n  stream_aux = stream_open(aux_out, zfp_maxout);\n  zfp_stream_set_bit_stream(zfp_aux, stream_aux);\n  zfp_stream_rewind(zfp_aux);\n\n  zfpsize = zfp_compress(zfp_aux, field);\n\n  /* clean up */\n  zfp_field_free(field);\n  zfp_stream_close(zfp_aux);\n  stream_close(stream_aux);\n  free(shape);\n  free(chunkshape);\n  free(blockshape);\n\n  if (zfpsize == 0) {\n    BLOSC_TRACE_ERROR(\"\\n ZFP: Compression failed\\n\");\n    free(aux_out);\n    return (int) zfpsize;\n  }\n  if ((int32_t) zfpsize >= input_len) {\n    BLOSC_TRACE_ERROR(\"\\n ZFP: Compressed data is bigger than input! \\n\");\n    free(aux_out);\n    return 0;\n  }\n\n  memcpy(output, aux_out, zfpsize);\n  free(aux_out);\n\n  return (int) zfpsize;\n}\n\nint zfp_acc_decompress(const uint8_t *input, int32_t input_len, uint8_t *output,\n                       int32_t output_len, uint8_t meta, blosc2_dparams *dparams, const void *chunk) {\n  ZFP_ERROR_NULL(input);\n  ZFP_ERROR_NULL(output);\n  ZFP_ERROR_NULL(dparams);\n  BLOSC_UNUSED_PARAM(chunk);\n\n  blosc2_schunk *sc = dparams->schunk;\n  int32_t typesize = sc->typesize;\n\n  double tol = (int8_t) meta;\n  int8_t ndim;\n  int64_t *shape = malloc(8 * sizeof(int64_t));\n  int32_t *chunkshape = malloc(8 * sizeof(int32_t));\n  int32_t *blockshape = malloc(8 * sizeof(int32_t));\n  uint8_t *smeta;\n  int32_t smeta_len;\n  if (blosc2_meta_get(sc, \"b2nd\", &smeta, &smeta_len) < 0) {\n    BLOSC_TRACE_ERROR(\"Cannot access b2nd meta info\");\n    free(shape);\n    free(chunkshape);\n    free(blockshape);\n    return BLOSC2_ERROR_FAILURE;\n  }\n  deserialize_meta(smeta, smeta_len, &ndim, shape, chunkshape, blockshape);\n  free(smeta);\n\n  zfp_type type;     /* array scalar type */\n  zfp_field *field;  /* array meta data */\n  zfp_stream *zfp;   /* compressed stream */\n  bitstream *stream; /* bit stream to write to or read from */\n  size_t zfpsize;    /* byte size of compressed stream */\n  double tolerance = pow(10, tol);\n\n  switch (typesize) {\n    case sizeof(float):\n      type = zfp_type_float;\n      break;\n    case sizeof(double):\n      type = zfp_type_double;\n      break;\n    default:\n      free(shape);\n      free(chunkshape);\n      free(blockshape);\n      BLOSC_TRACE_ERROR(\"ZFP is not available for typesize: %d\", typesize);\n      return BLOSC2_ERROR_FAILURE;\n  }\n\n  zfp = zfp_stream_open(NULL);\n  zfp_stream_set_accuracy(zfp, tolerance);\n  stream = stream_open((void *) input, input_len);\n  zfp_stream_set_bit_stream(zfp, stream);\n  zfp_stream_rewind(zfp);\n\n  switch (ndim) {\n    case 1:\n      field = zfp_field_1d((void *) output, type, blockshape[0]);\n      break;\n    case 2:\n      field = zfp_field_2d((void *) output, type, blockshape[1], blockshape[0]);\n      break;\n    case 3:\n      field = zfp_field_3d((void *) output, type, blockshape[2], blockshape[1], blockshape[0]);\n      break;\n    case 4:\n      field = zfp_field_4d((void *) output, type, blockshape[3], blockshape[2], blockshape[1], blockshape[0]);\n      break;\n    default:\n      free(shape);\n      free(chunkshape);\n      free(blockshape);\n      BLOSC_TRACE_ERROR(\"ZFP is not available for ndims: %d\", ndim);\n      return BLOSC2_ERROR_FAILURE;\n  }\n\n  zfpsize = zfp_decompress(zfp, field);\n\n  /* clean up */\n  zfp_field_free(field);\n  zfp_stream_close(zfp);\n  stream_close(stream);\n  free(shape);\n  free(chunkshape);\n  free(blockshape);\n\n  if (zfpsize == 0) {\n    BLOSC_TRACE_ERROR(\"\\n ZFP: Decompression failed\\n\");\n    return (int) zfpsize;\n  }\n\n  return (int) output_len;\n}\n\nint zfp_prec_compress(const uint8_t *input, int32_t input_len, uint8_t *output,\n                      int32_t output_len, uint8_t meta, blosc2_cparams *cparams, const void *chunk) {\n  BLOSC_UNUSED_PARAM(chunk);\n  ZFP_ERROR_NULL(input);\n  ZFP_ERROR_NULL(output);\n  ZFP_ERROR_NULL(cparams);\n\n  int8_t ndim;\n  int64_t *shape = malloc(8 * sizeof(int64_t));\n  int32_t *chunkshape = malloc(8 * sizeof(int32_t));\n  int32_t *blockshape = malloc(8 * sizeof(int32_t));\n  uint8_t *smeta;\n  int32_t smeta_len;\n  if (blosc2_meta_get(cparams->schunk, \"b2nd\", &smeta, &smeta_len) < 0) {\n    free(shape);\n    free(chunkshape);\n    free(blockshape);\n    BLOSC_TRACE_ERROR(\"b2nd layer not found!\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n  deserialize_meta(smeta, smeta_len, &ndim, shape, chunkshape, blockshape);\n  free(smeta);\n\n  for(int i = 0; i < ndim; i++) {\n    if (blockshape[i] < 4) {\n      BLOSC_TRACE_ERROR(\"ZFP does not support blocks smaller than cells (4x...x4\");\n      return BLOSC2_ERROR_FAILURE;\n    }\n  }\n\n  zfp_type type;     /* array scalar type */\n  zfp_field *field;  /* array meta data */\n  zfp_stream *zfp;   /* stream containing the real output buffer */\n  zfp_stream *zfp_aux;   /* auxiliary compressed stream */\n  bitstream *stream; /* bit stream to write to or read from */\n  bitstream *stream_aux; /* auxiliary bit stream to write to or read from */\n  size_t zfpsize;    /* byte size of compressed stream */\n\n  uint prec;\n  switch (ndim) {\n    case 1:\n      prec = meta + 5;\n      break;\n    case 2:\n      prec = meta + 7;\n      break;\n    case 3:\n      prec = meta + 9;\n      break;\n    case 4:\n      prec = meta + 11;\n      break;\n    default:\n      free(shape);\n      free(chunkshape);\n      free(blockshape);\n      BLOSC_TRACE_ERROR(\"ZFP is not available for ndims: %d\", ndim);\n      return BLOSC2_ERROR_FAILURE;\n  }\n\n  if (prec > ZFP_MAX_PREC) {\n    BLOSC_TRACE_ERROR(\"Max precision for this codecs is %d\", ZFP_MAX_PREC);\n    prec = ZFP_MAX_PREC;\n  }\n\n  int32_t typesize = cparams->typesize;\n  switch (typesize) {\n    case sizeof(float):\n      type = zfp_type_float;\n      break;\n    case sizeof(double):\n      type = zfp_type_double;\n      break;\n    default:\n      free(shape);\n      free(chunkshape);\n      free(blockshape);\n      BLOSC_TRACE_ERROR(\"ZFP is not available for typesize: %d\", typesize);\n      return BLOSC2_ERROR_FAILURE;\n  }\n\n  zfp = zfp_stream_open(NULL);\n  zfp_stream_set_precision(zfp, prec);\n  stream = stream_open(output, output_len);\n  zfp_stream_set_bit_stream(zfp, stream);\n  zfp_stream_rewind(zfp);\n\n  switch (ndim) {\n    case 1:\n      field = zfp_field_1d((void *) input, type, blockshape[0]);\n      break;\n    case 2:\n      field = zfp_field_2d((void *) input, type, blockshape[1], blockshape[0]);\n      break;\n    case 3:\n      field = zfp_field_3d((void *) input, type, blockshape[2], blockshape[1], blockshape[0]);\n      break;\n    case 4:\n      field = zfp_field_4d((void *) input, type, blockshape[3], blockshape[2], blockshape[1], blockshape[0]);\n      break;\n    default:\n      free(shape);\n      free(chunkshape);\n      free(blockshape);\n      BLOSC_TRACE_ERROR(\"ZFP is not available for ndims: %d\", ndim);\n      return BLOSC2_ERROR_FAILURE;\n  }\n\n  int zfp_maxout = (int) zfp_stream_maximum_size(zfp, field);\n  zfp_stream_close(zfp);\n  stream_close(stream);\n  uint8_t *aux_out = malloc(zfp_maxout);\n  zfp_aux = zfp_stream_open(NULL);\n  zfp_stream_set_precision(zfp_aux, prec);\n  stream_aux = stream_open(aux_out, zfp_maxout);\n  zfp_stream_set_bit_stream(zfp_aux, stream_aux);\n  zfp_stream_rewind(zfp_aux);\n\n  zfpsize = zfp_compress(zfp_aux, field);\n\n  /* clean up */\n  zfp_field_free(field);\n  zfp_stream_close(zfp_aux);\n  stream_close(stream_aux);\n  free(shape);\n  free(chunkshape);\n  free(blockshape);\n\n  if (zfpsize == 0) {\n    BLOSC_TRACE_ERROR(\"\\n ZFP: Compression failed\\n\");\n    free(aux_out);\n    return (int) zfpsize;\n  }\n  if ((int32_t) zfpsize >= input_len) {\n    BLOSC_TRACE_ERROR(\"\\n ZFP: Compressed data is bigger than input! \\n\");\n    free(aux_out);\n    return 0;\n  }\n\n  memcpy(output, aux_out, zfpsize);\n  free(aux_out);\n\n  return (int) zfpsize;\n}\n\nint zfp_prec_decompress(const uint8_t *input, int32_t input_len, uint8_t *output,\n                        int32_t output_len, uint8_t meta, blosc2_dparams *dparams, const void *chunk) {\n  ZFP_ERROR_NULL(input);\n  ZFP_ERROR_NULL(output);\n  ZFP_ERROR_NULL(dparams);\n  BLOSC_UNUSED_PARAM(chunk);\n\n  blosc2_schunk *sc = dparams->schunk;\n  int32_t typesize = sc->typesize;\n  int8_t ndim;\n  int64_t *shape = malloc(8 * sizeof(int64_t));\n  int32_t *chunkshape = malloc(8 * sizeof(int32_t));\n  int32_t *blockshape = malloc(8 * sizeof(int32_t));\n  uint8_t *smeta;\n  int32_t smeta_len;\n  if (blosc2_meta_get(sc, \"b2nd\", &smeta, &smeta_len) < 0) {\n    BLOSC_TRACE_ERROR(\"Cannot access b2nd meta info\");\n    free(shape);\n    free(chunkshape);\n    free(blockshape);\n    return BLOSC2_ERROR_FAILURE;\n  }\n  deserialize_meta(smeta, smeta_len, &ndim, shape, chunkshape, blockshape);\n  free(smeta);\n\n  zfp_type type;     /* array scalar type */\n  zfp_field *field;  /* array meta data */\n  zfp_stream *zfp;   /* compressed stream */\n  bitstream *stream; /* bit stream to write to or read from */\n  size_t zfpsize;    /* byte size of compressed stream */\n\n  uint prec;\n  switch (ndim) {\n    case 1:\n      prec = meta + 5;\n      break;\n    case 2:\n      prec = meta + 7;\n      break;\n    case 3:\n      prec = meta + 9;\n      break;\n    case 4:\n      prec = meta + 11;\n      break;\n    default:\n      free(shape);\n      free(chunkshape);\n      free(blockshape);\n      BLOSC_TRACE_ERROR(\"ZFP is not available for ndims: %d\", ndim);\n      return BLOSC2_ERROR_FAILURE;\n  }\n\n  if (prec > ZFP_MAX_PREC) {\n    BLOSC_TRACE_ERROR(\"Max precision for this codecs is %d\", ZFP_MAX_PREC);\n    prec = ZFP_MAX_PREC;\n  }\n\n  switch (typesize) {\n    case sizeof(float):\n      type = zfp_type_float;\n      break;\n    case sizeof(double):\n      type = zfp_type_double;\n      break;\n    default:\n      free(shape);\n      free(chunkshape);\n      free(blockshape);\n      BLOSC_TRACE_ERROR(\"ZFP is not available for typesize: %d\", typesize);\n      return BLOSC2_ERROR_FAILURE;\n  }\n\n  zfp = zfp_stream_open(NULL);\n  zfp_stream_set_precision(zfp, prec);\n  stream = stream_open((void *) input, input_len);\n  zfp_stream_set_bit_stream(zfp, stream);\n  zfp_stream_rewind(zfp);\n\n  switch (ndim) {\n    case 1:\n      field = zfp_field_1d((void *) output, type, blockshape[0]);\n      break;\n    case 2:\n      field = zfp_field_2d((void *) output, type, blockshape[1], blockshape[0]);\n      break;\n    case 3:\n      field = zfp_field_3d((void *) output, type, blockshape[2], blockshape[1], blockshape[0]);\n      break;\n    case 4:\n      field = zfp_field_4d((void *) output, type, blockshape[3], blockshape[2], blockshape[1], blockshape[0]);\n      break;\n    default:\n      free(shape);\n      free(chunkshape);\n      free(blockshape);\n      BLOSC_TRACE_ERROR(\"ZFP is not available for ndims: %d\", ndim);\n      return BLOSC2_ERROR_FAILURE;\n  }\n\n  zfpsize = zfp_decompress(zfp, field);\n\n  /* clean up */\n  zfp_field_free(field);\n  zfp_stream_close(zfp);\n  stream_close(stream);\n  free(shape);\n  free(chunkshape);\n  free(blockshape);\n\n  if (zfpsize == 0) {\n    BLOSC_TRACE_ERROR(\"\\n ZFP: Decompression failed\\n\");\n    return (int) zfpsize;\n  }\n\n  return (int) output_len;\n}\n\nint zfp_rate_compress(const uint8_t *input, int32_t input_len, uint8_t *output,\n                      int32_t output_len, uint8_t meta, blosc2_cparams *cparams, const void *chunk) {\n  BLOSC_UNUSED_PARAM(chunk);\n  ZFP_ERROR_NULL(input);\n  ZFP_ERROR_NULL(output);\n  ZFP_ERROR_NULL(cparams);\n\n  double ratio = (double) meta / 100.0;\n  int8_t ndim;\n  int64_t *shape = malloc(8 * sizeof(int64_t));\n  int32_t *chunkshape = malloc(8 * sizeof(int32_t));\n  int32_t *blockshape = malloc(8 * sizeof(int32_t));\n  uint8_t *smeta;\n  int32_t smeta_len;\n  if (blosc2_meta_get(cparams->schunk, \"b2nd\", &smeta, &smeta_len) < 0) {\n    free(shape);\n    free(chunkshape);\n    free(blockshape);\n    BLOSC_TRACE_ERROR(\"b2nd layer not found!\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n  deserialize_meta(smeta, smeta_len, &ndim, shape, chunkshape, blockshape);\n  free(smeta);\n\n  for(int i = 0; i < ndim; i++) {\n    if (blockshape[i] < 4) {\n      BLOSC_TRACE_ERROR(\"ZFP does not support blocks smaller than cells (4x...x4\");\n      return BLOSC2_ERROR_FAILURE;\n    }\n  }\n\n  zfp_type type;     /* array scalar type */\n  zfp_field *field;  /* array meta data */\n  zfp_stream *zfp;   /* stream containing the real output buffer */\n  zfp_stream *zfp_aux;   /* auxiliary compressed stream */\n  bitstream *stream; /* bit stream to write to or read from */\n  bitstream *stream_aux; /* auxiliary bit stream to write to or read from */\n  size_t zfpsize;    /* byte size of compressed stream */\n\n  int32_t typesize = cparams->typesize;\n\n  switch (typesize) {\n    case sizeof(float):\n      type = zfp_type_float;\n      break;\n    case sizeof(double):\n      type = zfp_type_double;\n      break;\n    default:\n      BLOSC_TRACE_ERROR(\"ZFP is not available for typesize: %d\", typesize);\n      return BLOSC2_ERROR_FAILURE;\n  }\n  double rate = ratio * typesize * 8;     // convert from output size / input size to output bits per input value\n  uint cellsize = 1u << (2 * ndim);\n  double min_rate;\n  if (type == zfp_type_float) {\n    min_rate = (double) (1 + 8u) / cellsize;\n    if (rate < min_rate) {\n      BLOSC_TRACE_ERROR(\"ZFP minimum rate for this item type is %f. Compression will be done using this one.\\n\",\n                        min_rate);\n    }\n  }\n  else {\n    min_rate = (double) (1 + 11u) / cellsize;\n    if (rate < min_rate) {\n      BLOSC_TRACE_ERROR(\"ZFP minimum rate for this item type is %f. Compression will be done using this one.\\n\",\n                        min_rate);\n    }\n  }\n  zfp = zfp_stream_open(NULL);\n  stream = stream_open(output, output_len);\n  zfp_stream_set_bit_stream(zfp, stream);\n  zfp_stream_rewind(zfp);\n\n  switch (ndim) {\n    case 1:\n      field = zfp_field_1d((void *) input, type, blockshape[0]);\n      break;\n    case 2:\n      field = zfp_field_2d((void *) input, type, blockshape[1], blockshape[0]);\n      break;\n    case 3:\n      field = zfp_field_3d((void *) input, type, blockshape[2], blockshape[1], blockshape[0]);\n      break;\n    case 4:\n      field = zfp_field_4d((void *) input, type, blockshape[3], blockshape[2], blockshape[1], blockshape[0]);\n      break;\n    default:\n      free(shape);\n      free(chunkshape);\n      free(blockshape);\n      BLOSC_TRACE_ERROR(\"ZFP is not available for ndims: %d\", ndim);\n      return BLOSC2_ERROR_FAILURE;\n  }\n\n  int zfp_maxout = (int) zfp_stream_maximum_size(zfp, field);\n  zfp_stream_close(zfp);\n  stream_close(stream);\n  uint8_t *aux_out = malloc(zfp_maxout);\n  zfp_aux = zfp_stream_open(NULL);\n  stream_aux = stream_open(aux_out, zfp_maxout);\n  zfp_stream_set_bit_stream(zfp_aux, stream_aux);\n  zfp_stream_rewind(zfp_aux);\n  zfp_stream_set_rate(zfp_aux, rate, type, ndim, zfp_false);\n\n  zfpsize = zfp_compress(zfp_aux, field);\n\n  /* clean up */\n  zfp_field_free(field);\n  zfp_stream_close(zfp_aux);\n  stream_close(stream_aux);\n  free(shape);\n  free(chunkshape);\n  free(blockshape);\n\n  if (zfpsize == 0) {\n    BLOSC_TRACE_ERROR(\"\\n ZFP: Compression failed\\n\");\n    free(aux_out);\n    return (int) zfpsize;\n  }\n  if ((int32_t) zfpsize >= input_len) {\n    BLOSC_TRACE_ERROR(\"\\n ZFP: Compressed data is bigger than input! \\n\");\n    free(aux_out);\n    return 0;\n  }\n\n  memcpy(output, aux_out, zfpsize);\n  free(aux_out);\n\n  return (int) zfpsize;\n}\n\nint zfp_rate_decompress(const uint8_t *input, int32_t input_len, uint8_t *output,\n                        int32_t output_len, uint8_t meta, blosc2_dparams *dparams, const void *chunk) {\n  ZFP_ERROR_NULL(input);\n  ZFP_ERROR_NULL(output);\n  ZFP_ERROR_NULL(dparams);\n  BLOSC_UNUSED_PARAM(chunk);\n\n  blosc2_schunk *sc = dparams->schunk;\n  int32_t typesize = sc->typesize;\n\n  double ratio = (double) meta / 100.0;\n  int8_t ndim;\n  int64_t *shape = malloc(8 * sizeof(int64_t));\n  int32_t *chunkshape = malloc(8 * sizeof(int32_t));\n  int32_t *blockshape = malloc(8 * sizeof(int32_t));\n  uint8_t *smeta;\n  int32_t smeta_len;\n  if (blosc2_meta_get(sc, \"b2nd\", &smeta, &smeta_len) < 0) {\n    BLOSC_TRACE_ERROR(\"Cannot access b2nd meta info\");\n    free(shape);\n    free(chunkshape);\n    free(blockshape);\n    return BLOSC2_ERROR_FAILURE;\n  }\n  deserialize_meta(smeta, smeta_len, &ndim, shape, chunkshape, blockshape);\n  free(smeta);\n\n  zfp_type type;     /* array scalar type */\n  zfp_field *field;  /* array meta data */\n  zfp_stream *zfp;   /* compressed stream */\n  bitstream *stream; /* bit stream to write to or read from */\n  size_t zfpsize;    /* byte size of compressed stream */\n\n  switch (typesize) {\n    case sizeof(float):\n      type = zfp_type_float;\n      break;\n    case sizeof(double):\n      type = zfp_type_double;\n      break;\n    default:\n      free(shape);\n      free(chunkshape);\n      free(blockshape);\n      BLOSC_TRACE_ERROR(\"ZFP is not available for typesize: %d\", typesize);\n      return BLOSC2_ERROR_FAILURE;\n  }\n  double rate =\n      ratio * (double) typesize * 8;     // convert from output size / input size to output bits per input value\n  zfp = zfp_stream_open(NULL);\n  zfp_stream_set_rate(zfp, rate, type, ndim, zfp_false);\n\n  stream = stream_open((void *) input, input_len);\n  zfp_stream_set_bit_stream(zfp, stream);\n  zfp_stream_rewind(zfp);\n\n  switch (ndim) {\n    case 1:\n      field = zfp_field_1d((void *) output, type, blockshape[0]);\n      break;\n    case 2:\n      field = zfp_field_2d((void *) output, type, blockshape[1], blockshape[0]);\n      break;\n    case 3:\n      field = zfp_field_3d((void *) output, type, blockshape[2], blockshape[1], blockshape[0]);\n      break;\n    case 4:\n      field = zfp_field_4d((void *) output, type, blockshape[3], blockshape[2], blockshape[1], blockshape[0]);\n      break;\n    default:\n      free(shape);\n      free(chunkshape);\n      free(blockshape);\n      BLOSC_TRACE_ERROR(\"ZFP is not available for ndims: %d\", ndim);\n      return BLOSC2_ERROR_FAILURE;\n  }\n\n  zfpsize = zfp_decompress(zfp, field);\n\n  /* clean up */\n  zfp_field_free(field);\n  zfp_stream_close(zfp);\n  stream_close(stream);\n  free(shape);\n  free(chunkshape);\n  free(blockshape);\n\n  if (zfpsize == 0) {\n    BLOSC_TRACE_ERROR(\"\\n ZFP: Decompression failed\\n\");\n    return (int) zfpsize;\n  }\n\n  return (int) output_len;\n}\n\nint zfp_getcell(void *thread_context, const uint8_t *block, int32_t cbytes, uint8_t *dest, int32_t destsize) {\n  struct thread_context *thread_ctx = thread_context;\n  blosc2_context *context = thread_ctx->parent_context;\n  bool meta = false;\n  int8_t ndim = ZFP_MAX_DIM + 1;\n  int32_t blockmeta[ZFP_MAX_DIM];\n  if (context->schunk->blockshape == NULL) {\n    // blockshape is not filled yet.  Use the Blosc2 NDim layer to populate it.\n    for (int nmetalayer = 0; nmetalayer < context->schunk->nmetalayers; nmetalayer++) {\n      if (strcmp(\"b2nd\", context->schunk->metalayers[nmetalayer]->name) == 0) {\n        meta = true;\n        uint8_t *pmeta = context->schunk->metalayers[nmetalayer]->content;\n        ndim = (int8_t) pmeta[2];\n        assert(ndim <= ZFP_MAX_DIM);\n        pmeta += (6 + ndim * 9 + ndim * 5);\n        for (int8_t i = 0; (uint8_t) i < ndim; i++) {\n          pmeta += 1;\n          swap_store(blockmeta + i, pmeta, sizeof(int32_t));\n          pmeta += sizeof(int32_t);\n        }\n      }\n    }\n    if (!meta) {\n      return -1;\n    }\n    context->schunk->ndim = ndim;\n    context->schunk->blockshape = malloc(sizeof(int64_t) * ndim);\n    for (int i = 0; i < ndim; ++i) {\n      context->schunk->blockshape[i] = (int64_t) blockmeta[i];\n    }\n  }\n  ndim = context->schunk->ndim;\n  int64_t *blockshape = context->schunk->blockshape;\n\n  // Compute the coordinates of the cell\n  int64_t cell_start_ndim[ZFP_MAX_DIM];\n  int64_t cell_ind_ndim[ZFP_MAX_DIM];\n  int64_t ncell_ndim[ZFP_MAX_DIM];\n  int64_t ind_strides[ZFP_MAX_DIM];\n  int64_t cell_strides[ZFP_MAX_DIM];\n  int64_t cell_ind, ncell;\n  blosc2_unidim_to_multidim(ndim, blockshape, thread_ctx->zfp_cell_start, cell_start_ndim);\n  for (int i = 0; i < ndim; ++i) {\n    cell_ind_ndim[i] = cell_start_ndim[i] % ZFP_MAX_DIM;\n    ncell_ndim[i] = cell_start_ndim[i] / ZFP_MAX_DIM;\n  }\n  ind_strides[ndim - 1] = cell_strides[ndim - 1] = 1;\n  for (int i = ndim - 2; i >= 0; --i) {\n    ind_strides[i] = ZFP_MAX_DIM * ind_strides[i + 1];\n    cell_strides[i] = ((blockshape[i + 1] - 1) / ZFP_MAX_DIM + 1) * cell_strides[i + 1];\n  }\n  blosc2_multidim_to_unidim(cell_ind_ndim, (int8_t) ndim, ind_strides, &cell_ind);\n  blosc2_multidim_to_unidim(ncell_ndim, (int8_t) ndim, cell_strides, &ncell);\n  int cell_nitems = (int) (1u << (2 * ndim));\n  if ((thread_ctx->zfp_cell_nitems > cell_nitems) ||\n      ((cell_ind + thread_ctx->zfp_cell_nitems) > cell_nitems)) {\n    return 0;\n  }\n\n  // Get the ZFP stream\n  zfp_type type;     /* array scalar type */\n  zfp_stream *zfp;   /* compressed stream */\n  bitstream *stream; /* bit stream to write to or read from */\n  int32_t typesize = context->typesize;\n  zfp = zfp_stream_open(NULL);\n\n  switch (typesize) {\n    case sizeof(float):\n      type = zfp_type_float;\n      break;\n    case sizeof(double):\n      type = zfp_type_double;\n      break;\n    default:\n      BLOSC_TRACE_ERROR(\"ZFP is not available for typesize: %d\", typesize);\n      return BLOSC2_ERROR_FAILURE;\n  }\n  uint8_t compmeta = context->compcode_meta;   // access to compressed chunk header\n  double rate = (double) (compmeta * typesize * 8) /\n                100.0;     // convert from output size / input size to output bits per input value\n  zfp_stream_set_rate(zfp, rate, type, ndim, zfp_false);\n\n  stream = stream_open((void *) block, cbytes);\n  zfp_stream_set_bit_stream(zfp, stream);\n  zfp_stream_rewind(zfp);\n\n  // Check that ncell is a valid index\n  int ncells = (int) ((cbytes * 8) / zfp->maxbits);\n  if (ncell >= ncells) {\n    BLOSC_TRACE_ERROR(\"Invalid cell index\");\n    return -1;\n  }\n\n  // Position the stream at the ncell bit offset for reading\n  stream_rseek(zfp->stream, (size_t) (ncell * zfp->maxbits));\n\n  // Get the cell\n  size_t zfpsize;\n  uint8_t *cell = malloc(cell_nitems * typesize);\n  switch (ndim) {\n    case 1:\n      if (type == zfp_type_float) {\n        zfpsize = zfp_decode_block_float_1(zfp, (float *) cell);\n      }\n      else {\n        zfpsize = zfp_decode_block_double_1(zfp, (double *) cell);\n      }\n      break;\n    case 2:\n      if (type == zfp_type_float) {\n        zfpsize = zfp_decode_block_float_2(zfp, (float *) cell);\n      }\n      else {\n        zfpsize = zfp_decode_block_double_2(zfp, (double *) cell);\n      }\n      break;\n    case 3:\n      if (type == zfp_type_float) {\n        zfpsize = zfp_decode_block_float_3(zfp, (float *) cell);\n      }\n      else {\n        zfpsize = zfp_decode_block_double_3(zfp, (double *) cell);\n      }\n      break;\n    case 4:\n      if (type == zfp_type_float) {\n        zfpsize = zfp_decode_block_float_4(zfp, (float *) cell);\n      }\n      else {\n        zfpsize = zfp_decode_block_double_4(zfp, (double *) cell);\n      }\n      break;\n    default:\n      BLOSC_TRACE_ERROR(\"ZFP is not available for ndims: %d\", ndim);\n      return BLOSC2_ERROR_FAILURE;\n  }\n  memcpy(dest, &cell[cell_ind * typesize], thread_ctx->zfp_cell_nitems * typesize);\n  zfp_stream_close(zfp);\n  stream_close(stream);\n  free(cell);\n\n  if ((zfpsize == 0) || ((int32_t) zfpsize > (destsize * 8)) ||\n      ((int32_t) zfpsize > (cell_nitems * typesize * 8)) ||\n      ((thread_ctx->zfp_cell_nitems * typesize * 8) > (int32_t) zfpsize)) {\n    BLOSC_TRACE_ERROR(\"ZFP error or small destsize\");\n    return -1;\n  }\n\n  return (int) (thread_ctx->zfp_cell_nitems * typesize);\n}\n"], "fixing_code": ["/*\n  Copyright (c) 2021  The Blosc Development Team <blosc@blosc.org>\n  https://blosc.org\n  License: BSD 3-Clause (see LICENSE.txt)\n*/\n\n#include \"blosc-private.h\"\n#include \"zfp.h\"\n#include \"blosc2-zfp.h\"\n#include \"../plugins/codecs/zfp/zfp-private.h\"\n#include \"../plugins/plugin_utils.h\"\n#include \"context.h\"\n#include \"frame.h\"\n#include \"blosc2/codecs-registry.h\"\n#include \"blosc2.h\"\n\n#include <assert.h>\n#include <math.h>\n#include <stdlib.h>\n#include <string.h>\n\n\nint zfp_acc_compress(const uint8_t *input, int32_t input_len, uint8_t *output,\n                     int32_t output_len, uint8_t meta, blosc2_cparams *cparams, const void *chunk) {\n  BLOSC_UNUSED_PARAM(chunk);\n  ZFP_ERROR_NULL(input);\n  ZFP_ERROR_NULL(output);\n  ZFP_ERROR_NULL(cparams);\n  ZFP_ERROR_NULL(cparams->schunk);\n\n  double tol = (int8_t) meta;\n  int8_t ndim;\n  int64_t *shape = malloc(8 * sizeof(int64_t));\n  int32_t *chunkshape = malloc(8 * sizeof(int32_t));\n  int32_t *blockshape = malloc(8 * sizeof(int32_t));\n  uint8_t *smeta;\n  int32_t smeta_len;\n  if (blosc2_meta_get(cparams->schunk, \"b2nd\", &smeta, &smeta_len) < 0) {\n    free(shape);\n    free(chunkshape);\n    free(blockshape);\n    BLOSC_TRACE_ERROR(\"b2nd layer not found!\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n  deserialize_meta(smeta, smeta_len, &ndim, shape, chunkshape, blockshape);\n  free(smeta);\n\n  for(int i = 0; i < ndim; i++) {\n    if (blockshape[i] < 4) {\n      BLOSC_TRACE_ERROR(\"ZFP does not support blocks smaller than cells (4x...x4\");\n      return BLOSC2_ERROR_FAILURE;\n    }\n  }\n\n  zfp_type type;     /* array scalar type */\n  zfp_field *field;  /* array meta data */\n  zfp_stream *zfp;   /* stream containing the real output buffer */\n  zfp_stream *zfp_aux;   /* auxiliary compressed stream */\n  bitstream *stream; /* bit stream to write to or read from */\n  bitstream *stream_aux; /* auxiliary bit stream to write to or read from */\n  size_t zfpsize;    /* byte size of compressed stream */\n  double tolerance = pow(10, tol);\n\n  int32_t typesize = cparams->typesize;\n\n  switch (typesize) {\n    case sizeof(float):\n      type = zfp_type_float;\n      break;\n    case sizeof(double):\n      type = zfp_type_double;\n      break;\n    default:\n      free(shape);\n      free(chunkshape);\n      free(blockshape);\n      BLOSC_TRACE_ERROR(\"ZFP is not available for typesize: %d\", typesize);\n      return BLOSC2_ERROR_FAILURE;\n  }\n\n  zfp = zfp_stream_open(NULL);\n  zfp_stream_set_accuracy(zfp, tolerance);\n  stream = stream_open(output, output_len);\n  zfp_stream_set_bit_stream(zfp, stream);\n  zfp_stream_rewind(zfp);\n\n  switch (ndim) {\n    case 1:\n      field = zfp_field_1d((void *) input, type, blockshape[0]);\n      break;\n    case 2:\n      field = zfp_field_2d((void *) input, type, blockshape[1], blockshape[0]);\n      break;\n    case 3:\n      field = zfp_field_3d((void *) input, type, blockshape[2], blockshape[1], blockshape[0]);\n      break;\n    case 4:\n      field = zfp_field_4d((void *) input, type, blockshape[3], blockshape[2], blockshape[1], blockshape[0]);\n      break;\n    default:\n      free(shape);\n      free(chunkshape);\n      free(blockshape);\n      BLOSC_TRACE_ERROR(\"ZFP is not available for ndims: %d\", ndim);\n      return BLOSC2_ERROR_FAILURE;\n  }\n\n  int zfp_maxout = (int) zfp_stream_maximum_size(zfp, field);\n  zfp_stream_close(zfp);\n  stream_close(stream);\n  uint8_t *aux_out = malloc(zfp_maxout);\n  zfp_aux = zfp_stream_open(NULL);\n  zfp_stream_set_accuracy(zfp_aux, tolerance);\n  stream_aux = stream_open(aux_out, zfp_maxout);\n  zfp_stream_set_bit_stream(zfp_aux, stream_aux);\n  zfp_stream_rewind(zfp_aux);\n\n  zfpsize = zfp_compress(zfp_aux, field);\n\n  /* clean up */\n  zfp_field_free(field);\n  zfp_stream_close(zfp_aux);\n  stream_close(stream_aux);\n  free(shape);\n  free(chunkshape);\n  free(blockshape);\n\n  if (zfpsize == 0) {\n    BLOSC_TRACE_ERROR(\"\\n ZFP: Compression failed\\n\");\n    free(aux_out);\n    return (int) zfpsize;\n  }\n  if ((int32_t) zfpsize >= input_len) {\n    BLOSC_TRACE_ERROR(\"\\n ZFP: Compressed data is bigger than input! \\n\");\n    free(aux_out);\n    return 0;\n  }\n\n  memcpy(output, aux_out, zfpsize);\n  free(aux_out);\n\n  return (int) zfpsize;\n}\n\nint zfp_acc_decompress(const uint8_t *input, int32_t input_len, uint8_t *output,\n                       int32_t output_len, uint8_t meta, blosc2_dparams *dparams, const void *chunk) {\n  ZFP_ERROR_NULL(input);\n  ZFP_ERROR_NULL(output);\n  ZFP_ERROR_NULL(dparams);\n  ZFP_ERROR_NULL(dparams->schunk);\n  BLOSC_UNUSED_PARAM(chunk);\n\n  blosc2_schunk *sc = dparams->schunk;\n  int32_t typesize = sc->typesize;\n\n  double tol = (int8_t) meta;\n  int8_t ndim;\n  int64_t *shape = malloc(8 * sizeof(int64_t));\n  int32_t *chunkshape = malloc(8 * sizeof(int32_t));\n  int32_t *blockshape = malloc(8 * sizeof(int32_t));\n  uint8_t *smeta;\n  int32_t smeta_len;\n  if (blosc2_meta_get(sc, \"b2nd\", &smeta, &smeta_len) < 0) {\n    BLOSC_TRACE_ERROR(\"Cannot access b2nd meta info\");\n    free(shape);\n    free(chunkshape);\n    free(blockshape);\n    return BLOSC2_ERROR_FAILURE;\n  }\n  deserialize_meta(smeta, smeta_len, &ndim, shape, chunkshape, blockshape);\n  free(smeta);\n\n  zfp_type type;     /* array scalar type */\n  zfp_field *field;  /* array meta data */\n  zfp_stream *zfp;   /* compressed stream */\n  bitstream *stream; /* bit stream to write to or read from */\n  size_t zfpsize;    /* byte size of compressed stream */\n  double tolerance = pow(10, tol);\n\n  switch (typesize) {\n    case sizeof(float):\n      type = zfp_type_float;\n      break;\n    case sizeof(double):\n      type = zfp_type_double;\n      break;\n    default:\n      free(shape);\n      free(chunkshape);\n      free(blockshape);\n      BLOSC_TRACE_ERROR(\"ZFP is not available for typesize: %d\", typesize);\n      return BLOSC2_ERROR_FAILURE;\n  }\n\n  zfp = zfp_stream_open(NULL);\n  zfp_stream_set_accuracy(zfp, tolerance);\n  stream = stream_open((void *) input, input_len);\n  zfp_stream_set_bit_stream(zfp, stream);\n  zfp_stream_rewind(zfp);\n\n  switch (ndim) {\n    case 1:\n      field = zfp_field_1d((void *) output, type, blockshape[0]);\n      break;\n    case 2:\n      field = zfp_field_2d((void *) output, type, blockshape[1], blockshape[0]);\n      break;\n    case 3:\n      field = zfp_field_3d((void *) output, type, blockshape[2], blockshape[1], blockshape[0]);\n      break;\n    case 4:\n      field = zfp_field_4d((void *) output, type, blockshape[3], blockshape[2], blockshape[1], blockshape[0]);\n      break;\n    default:\n      free(shape);\n      free(chunkshape);\n      free(blockshape);\n      BLOSC_TRACE_ERROR(\"ZFP is not available for ndims: %d\", ndim);\n      return BLOSC2_ERROR_FAILURE;\n  }\n\n  zfpsize = zfp_decompress(zfp, field);\n\n  /* clean up */\n  zfp_field_free(field);\n  zfp_stream_close(zfp);\n  stream_close(stream);\n  free(shape);\n  free(chunkshape);\n  free(blockshape);\n\n  if (zfpsize == 0) {\n    BLOSC_TRACE_ERROR(\"\\n ZFP: Decompression failed\\n\");\n    return (int) zfpsize;\n  }\n\n  return (int) output_len;\n}\n\nint zfp_prec_compress(const uint8_t *input, int32_t input_len, uint8_t *output,\n                      int32_t output_len, uint8_t meta, blosc2_cparams *cparams, const void *chunk) {\n  BLOSC_UNUSED_PARAM(chunk);\n  ZFP_ERROR_NULL(input);\n  ZFP_ERROR_NULL(output);\n  ZFP_ERROR_NULL(cparams);\n  ZFP_ERROR_NULL(cparams->schunk);\n\n  int8_t ndim;\n  int64_t *shape = malloc(8 * sizeof(int64_t));\n  int32_t *chunkshape = malloc(8 * sizeof(int32_t));\n  int32_t *blockshape = malloc(8 * sizeof(int32_t));\n  uint8_t *smeta;\n  int32_t smeta_len;\n  if (blosc2_meta_get(cparams->schunk, \"b2nd\", &smeta, &smeta_len) < 0) {\n    free(shape);\n    free(chunkshape);\n    free(blockshape);\n    BLOSC_TRACE_ERROR(\"b2nd layer not found!\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n  deserialize_meta(smeta, smeta_len, &ndim, shape, chunkshape, blockshape);\n  free(smeta);\n\n  for(int i = 0; i < ndim; i++) {\n    if (blockshape[i] < 4) {\n      BLOSC_TRACE_ERROR(\"ZFP does not support blocks smaller than cells (4x...x4\");\n      return BLOSC2_ERROR_FAILURE;\n    }\n  }\n\n  zfp_type type;     /* array scalar type */\n  zfp_field *field;  /* array meta data */\n  zfp_stream *zfp;   /* stream containing the real output buffer */\n  zfp_stream *zfp_aux;   /* auxiliary compressed stream */\n  bitstream *stream; /* bit stream to write to or read from */\n  bitstream *stream_aux; /* auxiliary bit stream to write to or read from */\n  size_t zfpsize;    /* byte size of compressed stream */\n\n  uint prec;\n  switch (ndim) {\n    case 1:\n      prec = meta + 5;\n      break;\n    case 2:\n      prec = meta + 7;\n      break;\n    case 3:\n      prec = meta + 9;\n      break;\n    case 4:\n      prec = meta + 11;\n      break;\n    default:\n      free(shape);\n      free(chunkshape);\n      free(blockshape);\n      BLOSC_TRACE_ERROR(\"ZFP is not available for ndims: %d\", ndim);\n      return BLOSC2_ERROR_FAILURE;\n  }\n\n  if (prec > ZFP_MAX_PREC) {\n    BLOSC_TRACE_ERROR(\"Max precision for this codecs is %d\", ZFP_MAX_PREC);\n    prec = ZFP_MAX_PREC;\n  }\n\n  int32_t typesize = cparams->typesize;\n  switch (typesize) {\n    case sizeof(float):\n      type = zfp_type_float;\n      break;\n    case sizeof(double):\n      type = zfp_type_double;\n      break;\n    default:\n      free(shape);\n      free(chunkshape);\n      free(blockshape);\n      BLOSC_TRACE_ERROR(\"ZFP is not available for typesize: %d\", typesize);\n      return BLOSC2_ERROR_FAILURE;\n  }\n\n  zfp = zfp_stream_open(NULL);\n  zfp_stream_set_precision(zfp, prec);\n  stream = stream_open(output, output_len);\n  zfp_stream_set_bit_stream(zfp, stream);\n  zfp_stream_rewind(zfp);\n\n  switch (ndim) {\n    case 1:\n      field = zfp_field_1d((void *) input, type, blockshape[0]);\n      break;\n    case 2:\n      field = zfp_field_2d((void *) input, type, blockshape[1], blockshape[0]);\n      break;\n    case 3:\n      field = zfp_field_3d((void *) input, type, blockshape[2], blockshape[1], blockshape[0]);\n      break;\n    case 4:\n      field = zfp_field_4d((void *) input, type, blockshape[3], blockshape[2], blockshape[1], blockshape[0]);\n      break;\n    default:\n      free(shape);\n      free(chunkshape);\n      free(blockshape);\n      BLOSC_TRACE_ERROR(\"ZFP is not available for ndims: %d\", ndim);\n      return BLOSC2_ERROR_FAILURE;\n  }\n\n  int zfp_maxout = (int) zfp_stream_maximum_size(zfp, field);\n  zfp_stream_close(zfp);\n  stream_close(stream);\n  uint8_t *aux_out = malloc(zfp_maxout);\n  zfp_aux = zfp_stream_open(NULL);\n  zfp_stream_set_precision(zfp_aux, prec);\n  stream_aux = stream_open(aux_out, zfp_maxout);\n  zfp_stream_set_bit_stream(zfp_aux, stream_aux);\n  zfp_stream_rewind(zfp_aux);\n\n  zfpsize = zfp_compress(zfp_aux, field);\n\n  /* clean up */\n  zfp_field_free(field);\n  zfp_stream_close(zfp_aux);\n  stream_close(stream_aux);\n  free(shape);\n  free(chunkshape);\n  free(blockshape);\n\n  if (zfpsize == 0) {\n    BLOSC_TRACE_ERROR(\"\\n ZFP: Compression failed\\n\");\n    free(aux_out);\n    return (int) zfpsize;\n  }\n  if ((int32_t) zfpsize >= input_len) {\n    BLOSC_TRACE_ERROR(\"\\n ZFP: Compressed data is bigger than input! \\n\");\n    free(aux_out);\n    return 0;\n  }\n\n  memcpy(output, aux_out, zfpsize);\n  free(aux_out);\n\n  return (int) zfpsize;\n}\n\nint zfp_prec_decompress(const uint8_t *input, int32_t input_len, uint8_t *output,\n                        int32_t output_len, uint8_t meta, blosc2_dparams *dparams, const void *chunk) {\n  ZFP_ERROR_NULL(input);\n  ZFP_ERROR_NULL(output);\n  ZFP_ERROR_NULL(dparams);\n  ZFP_ERROR_NULL(dparams->schunk);\n  BLOSC_UNUSED_PARAM(chunk);\n\n  blosc2_schunk *sc = dparams->schunk;\n  int32_t typesize = sc->typesize;\n  int8_t ndim;\n  int64_t *shape = malloc(8 * sizeof(int64_t));\n  int32_t *chunkshape = malloc(8 * sizeof(int32_t));\n  int32_t *blockshape = malloc(8 * sizeof(int32_t));\n  uint8_t *smeta;\n  int32_t smeta_len;\n  if (blosc2_meta_get(sc, \"b2nd\", &smeta, &smeta_len) < 0) {\n    BLOSC_TRACE_ERROR(\"Cannot access b2nd meta info\");\n    free(shape);\n    free(chunkshape);\n    free(blockshape);\n    return BLOSC2_ERROR_FAILURE;\n  }\n  deserialize_meta(smeta, smeta_len, &ndim, shape, chunkshape, blockshape);\n  free(smeta);\n\n  zfp_type type;     /* array scalar type */\n  zfp_field *field;  /* array meta data */\n  zfp_stream *zfp;   /* compressed stream */\n  bitstream *stream; /* bit stream to write to or read from */\n  size_t zfpsize;    /* byte size of compressed stream */\n\n  uint prec;\n  switch (ndim) {\n    case 1:\n      prec = meta + 5;\n      break;\n    case 2:\n      prec = meta + 7;\n      break;\n    case 3:\n      prec = meta + 9;\n      break;\n    case 4:\n      prec = meta + 11;\n      break;\n    default:\n      free(shape);\n      free(chunkshape);\n      free(blockshape);\n      BLOSC_TRACE_ERROR(\"ZFP is not available for ndims: %d\", ndim);\n      return BLOSC2_ERROR_FAILURE;\n  }\n\n  if (prec > ZFP_MAX_PREC) {\n    BLOSC_TRACE_ERROR(\"Max precision for this codecs is %d\", ZFP_MAX_PREC);\n    prec = ZFP_MAX_PREC;\n  }\n\n  switch (typesize) {\n    case sizeof(float):\n      type = zfp_type_float;\n      break;\n    case sizeof(double):\n      type = zfp_type_double;\n      break;\n    default:\n      free(shape);\n      free(chunkshape);\n      free(blockshape);\n      BLOSC_TRACE_ERROR(\"ZFP is not available for typesize: %d\", typesize);\n      return BLOSC2_ERROR_FAILURE;\n  }\n\n  zfp = zfp_stream_open(NULL);\n  zfp_stream_set_precision(zfp, prec);\n  stream = stream_open((void *) input, input_len);\n  zfp_stream_set_bit_stream(zfp, stream);\n  zfp_stream_rewind(zfp);\n\n  switch (ndim) {\n    case 1:\n      field = zfp_field_1d((void *) output, type, blockshape[0]);\n      break;\n    case 2:\n      field = zfp_field_2d((void *) output, type, blockshape[1], blockshape[0]);\n      break;\n    case 3:\n      field = zfp_field_3d((void *) output, type, blockshape[2], blockshape[1], blockshape[0]);\n      break;\n    case 4:\n      field = zfp_field_4d((void *) output, type, blockshape[3], blockshape[2], blockshape[1], blockshape[0]);\n      break;\n    default:\n      free(shape);\n      free(chunkshape);\n      free(blockshape);\n      BLOSC_TRACE_ERROR(\"ZFP is not available for ndims: %d\", ndim);\n      return BLOSC2_ERROR_FAILURE;\n  }\n\n  zfpsize = zfp_decompress(zfp, field);\n\n  /* clean up */\n  zfp_field_free(field);\n  zfp_stream_close(zfp);\n  stream_close(stream);\n  free(shape);\n  free(chunkshape);\n  free(blockshape);\n\n  if (zfpsize == 0) {\n    BLOSC_TRACE_ERROR(\"\\n ZFP: Decompression failed\\n\");\n    return (int) zfpsize;\n  }\n\n  return (int) output_len;\n}\n\nint zfp_rate_compress(const uint8_t *input, int32_t input_len, uint8_t *output,\n                      int32_t output_len, uint8_t meta, blosc2_cparams *cparams, const void *chunk) {\n  BLOSC_UNUSED_PARAM(chunk);\n  ZFP_ERROR_NULL(input);\n  ZFP_ERROR_NULL(output);\n  ZFP_ERROR_NULL(cparams);\n  ZFP_ERROR_NULL(cparams->schunk);\n\n  double ratio = (double) meta / 100.0;\n  int8_t ndim;\n  int64_t *shape = malloc(8 * sizeof(int64_t));\n  int32_t *chunkshape = malloc(8 * sizeof(int32_t));\n  int32_t *blockshape = malloc(8 * sizeof(int32_t));\n  uint8_t *smeta;\n  int32_t smeta_len;\n  if (blosc2_meta_get(cparams->schunk, \"b2nd\", &smeta, &smeta_len) < 0) {\n    free(shape);\n    free(chunkshape);\n    free(blockshape);\n    BLOSC_TRACE_ERROR(\"b2nd layer not found!\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n  deserialize_meta(smeta, smeta_len, &ndim, shape, chunkshape, blockshape);\n  free(smeta);\n\n  for(int i = 0; i < ndim; i++) {\n    if (blockshape[i] < 4) {\n      BLOSC_TRACE_ERROR(\"ZFP does not support blocks smaller than cells (4x...x4\");\n      return BLOSC2_ERROR_FAILURE;\n    }\n  }\n\n  zfp_type type;     /* array scalar type */\n  zfp_field *field;  /* array meta data */\n  zfp_stream *zfp;   /* stream containing the real output buffer */\n  zfp_stream *zfp_aux;   /* auxiliary compressed stream */\n  bitstream *stream; /* bit stream to write to or read from */\n  bitstream *stream_aux; /* auxiliary bit stream to write to or read from */\n  size_t zfpsize;    /* byte size of compressed stream */\n\n  int32_t typesize = cparams->typesize;\n\n  switch (typesize) {\n    case sizeof(float):\n      type = zfp_type_float;\n      break;\n    case sizeof(double):\n      type = zfp_type_double;\n      break;\n    default:\n      BLOSC_TRACE_ERROR(\"ZFP is not available for typesize: %d\", typesize);\n      return BLOSC2_ERROR_FAILURE;\n  }\n  double rate = ratio * typesize * 8;     // convert from output size / input size to output bits per input value\n  uint cellsize = 1u << (2 * ndim);\n  double min_rate;\n  if (type == zfp_type_float) {\n    min_rate = (double) (1 + 8u) / cellsize;\n    if (rate < min_rate) {\n      BLOSC_TRACE_ERROR(\"ZFP minimum rate for this item type is %f. Compression will be done using this one.\\n\",\n                        min_rate);\n    }\n  }\n  else {\n    min_rate = (double) (1 + 11u) / cellsize;\n    if (rate < min_rate) {\n      BLOSC_TRACE_ERROR(\"ZFP minimum rate for this item type is %f. Compression will be done using this one.\\n\",\n                        min_rate);\n    }\n  }\n  zfp = zfp_stream_open(NULL);\n  stream = stream_open(output, output_len);\n  zfp_stream_set_bit_stream(zfp, stream);\n  zfp_stream_rewind(zfp);\n\n  switch (ndim) {\n    case 1:\n      field = zfp_field_1d((void *) input, type, blockshape[0]);\n      break;\n    case 2:\n      field = zfp_field_2d((void *) input, type, blockshape[1], blockshape[0]);\n      break;\n    case 3:\n      field = zfp_field_3d((void *) input, type, blockshape[2], blockshape[1], blockshape[0]);\n      break;\n    case 4:\n      field = zfp_field_4d((void *) input, type, blockshape[3], blockshape[2], blockshape[1], blockshape[0]);\n      break;\n    default:\n      free(shape);\n      free(chunkshape);\n      free(blockshape);\n      BLOSC_TRACE_ERROR(\"ZFP is not available for ndims: %d\", ndim);\n      return BLOSC2_ERROR_FAILURE;\n  }\n\n  int zfp_maxout = (int) zfp_stream_maximum_size(zfp, field);\n  zfp_stream_close(zfp);\n  stream_close(stream);\n  uint8_t *aux_out = malloc(zfp_maxout);\n  zfp_aux = zfp_stream_open(NULL);\n  stream_aux = stream_open(aux_out, zfp_maxout);\n  zfp_stream_set_bit_stream(zfp_aux, stream_aux);\n  zfp_stream_rewind(zfp_aux);\n  zfp_stream_set_rate(zfp_aux, rate, type, ndim, zfp_false);\n\n  zfpsize = zfp_compress(zfp_aux, field);\n\n  /* clean up */\n  zfp_field_free(field);\n  zfp_stream_close(zfp_aux);\n  stream_close(stream_aux);\n  free(shape);\n  free(chunkshape);\n  free(blockshape);\n\n  if (zfpsize == 0) {\n    BLOSC_TRACE_ERROR(\"\\n ZFP: Compression failed\\n\");\n    free(aux_out);\n    return (int) zfpsize;\n  }\n  if ((int32_t) zfpsize >= input_len) {\n    BLOSC_TRACE_ERROR(\"\\n ZFP: Compressed data is bigger than input! \\n\");\n    free(aux_out);\n    return 0;\n  }\n\n  memcpy(output, aux_out, zfpsize);\n  free(aux_out);\n\n  return (int) zfpsize;\n}\n\nint zfp_rate_decompress(const uint8_t *input, int32_t input_len, uint8_t *output,\n                        int32_t output_len, uint8_t meta, blosc2_dparams *dparams, const void *chunk) {\n  ZFP_ERROR_NULL(input);\n  ZFP_ERROR_NULL(output);\n  ZFP_ERROR_NULL(dparams);\n  ZFP_ERROR_NULL(dparams->schunk);\n  BLOSC_UNUSED_PARAM(chunk);\n\n  blosc2_schunk *sc = dparams->schunk;\n  int32_t typesize = sc->typesize;\n\n  double ratio = (double) meta / 100.0;\n  int8_t ndim;\n  int64_t *shape = malloc(8 * sizeof(int64_t));\n  int32_t *chunkshape = malloc(8 * sizeof(int32_t));\n  int32_t *blockshape = malloc(8 * sizeof(int32_t));\n  uint8_t *smeta;\n  int32_t smeta_len;\n  if (blosc2_meta_get(sc, \"b2nd\", &smeta, &smeta_len) < 0) {\n    BLOSC_TRACE_ERROR(\"Cannot access b2nd meta info\");\n    free(shape);\n    free(chunkshape);\n    free(blockshape);\n    return BLOSC2_ERROR_FAILURE;\n  }\n  deserialize_meta(smeta, smeta_len, &ndim, shape, chunkshape, blockshape);\n  free(smeta);\n\n  zfp_type type;     /* array scalar type */\n  zfp_field *field;  /* array meta data */\n  zfp_stream *zfp;   /* compressed stream */\n  bitstream *stream; /* bit stream to write to or read from */\n  size_t zfpsize;    /* byte size of compressed stream */\n\n  switch (typesize) {\n    case sizeof(float):\n      type = zfp_type_float;\n      break;\n    case sizeof(double):\n      type = zfp_type_double;\n      break;\n    default:\n      free(shape);\n      free(chunkshape);\n      free(blockshape);\n      BLOSC_TRACE_ERROR(\"ZFP is not available for typesize: %d\", typesize);\n      return BLOSC2_ERROR_FAILURE;\n  }\n  double rate =\n      ratio * (double) typesize * 8;     // convert from output size / input size to output bits per input value\n  zfp = zfp_stream_open(NULL);\n  zfp_stream_set_rate(zfp, rate, type, ndim, zfp_false);\n\n  stream = stream_open((void *) input, input_len);\n  zfp_stream_set_bit_stream(zfp, stream);\n  zfp_stream_rewind(zfp);\n\n  switch (ndim) {\n    case 1:\n      field = zfp_field_1d((void *) output, type, blockshape[0]);\n      break;\n    case 2:\n      field = zfp_field_2d((void *) output, type, blockshape[1], blockshape[0]);\n      break;\n    case 3:\n      field = zfp_field_3d((void *) output, type, blockshape[2], blockshape[1], blockshape[0]);\n      break;\n    case 4:\n      field = zfp_field_4d((void *) output, type, blockshape[3], blockshape[2], blockshape[1], blockshape[0]);\n      break;\n    default:\n      free(shape);\n      free(chunkshape);\n      free(blockshape);\n      BLOSC_TRACE_ERROR(\"ZFP is not available for ndims: %d\", ndim);\n      return BLOSC2_ERROR_FAILURE;\n  }\n\n  zfpsize = zfp_decompress(zfp, field);\n\n  /* clean up */\n  zfp_field_free(field);\n  zfp_stream_close(zfp);\n  stream_close(stream);\n  free(shape);\n  free(chunkshape);\n  free(blockshape);\n\n  if (zfpsize == 0) {\n    BLOSC_TRACE_ERROR(\"\\n ZFP: Decompression failed\\n\");\n    return (int) zfpsize;\n  }\n\n  return (int) output_len;\n}\n\nint zfp_getcell(void *thread_context, const uint8_t *block, int32_t cbytes, uint8_t *dest, int32_t destsize) {\n  struct thread_context *thread_ctx = thread_context;\n  blosc2_context *context = thread_ctx->parent_context;\n  bool meta = false;\n  int8_t ndim = ZFP_MAX_DIM + 1;\n  int32_t blockmeta[ZFP_MAX_DIM];\n  if (context->schunk->blockshape == NULL) {\n    // blockshape is not filled yet.  Use the Blosc2 NDim layer to populate it.\n    for (int nmetalayer = 0; nmetalayer < context->schunk->nmetalayers; nmetalayer++) {\n      if (strcmp(\"b2nd\", context->schunk->metalayers[nmetalayer]->name) == 0) {\n        meta = true;\n        uint8_t *pmeta = context->schunk->metalayers[nmetalayer]->content;\n        ndim = (int8_t) pmeta[2];\n        assert(ndim <= ZFP_MAX_DIM);\n        pmeta += (6 + ndim * 9 + ndim * 5);\n        for (int8_t i = 0; (uint8_t) i < ndim; i++) {\n          pmeta += 1;\n          swap_store(blockmeta + i, pmeta, sizeof(int32_t));\n          pmeta += sizeof(int32_t);\n        }\n      }\n    }\n    if (!meta) {\n      return -1;\n    }\n    context->schunk->ndim = ndim;\n    context->schunk->blockshape = malloc(sizeof(int64_t) * ndim);\n    for (int i = 0; i < ndim; ++i) {\n      context->schunk->blockshape[i] = (int64_t) blockmeta[i];\n    }\n  }\n  ndim = context->schunk->ndim;\n  int64_t *blockshape = context->schunk->blockshape;\n\n  // Compute the coordinates of the cell\n  int64_t cell_start_ndim[ZFP_MAX_DIM];\n  int64_t cell_ind_ndim[ZFP_MAX_DIM];\n  int64_t ncell_ndim[ZFP_MAX_DIM];\n  int64_t ind_strides[ZFP_MAX_DIM];\n  int64_t cell_strides[ZFP_MAX_DIM];\n  int64_t cell_ind, ncell;\n  blosc2_unidim_to_multidim(ndim, blockshape, thread_ctx->zfp_cell_start, cell_start_ndim);\n  for (int i = 0; i < ndim; ++i) {\n    cell_ind_ndim[i] = cell_start_ndim[i] % ZFP_MAX_DIM;\n    ncell_ndim[i] = cell_start_ndim[i] / ZFP_MAX_DIM;\n  }\n  ind_strides[ndim - 1] = cell_strides[ndim - 1] = 1;\n  for (int i = ndim - 2; i >= 0; --i) {\n    ind_strides[i] = ZFP_MAX_DIM * ind_strides[i + 1];\n    cell_strides[i] = ((blockshape[i + 1] - 1) / ZFP_MAX_DIM + 1) * cell_strides[i + 1];\n  }\n  blosc2_multidim_to_unidim(cell_ind_ndim, (int8_t) ndim, ind_strides, &cell_ind);\n  blosc2_multidim_to_unidim(ncell_ndim, (int8_t) ndim, cell_strides, &ncell);\n  int cell_nitems = (int) (1u << (2 * ndim));\n  if ((thread_ctx->zfp_cell_nitems > cell_nitems) ||\n      ((cell_ind + thread_ctx->zfp_cell_nitems) > cell_nitems)) {\n    return 0;\n  }\n\n  // Get the ZFP stream\n  zfp_type type;     /* array scalar type */\n  zfp_stream *zfp;   /* compressed stream */\n  bitstream *stream; /* bit stream to write to or read from */\n  int32_t typesize = context->typesize;\n  zfp = zfp_stream_open(NULL);\n\n  switch (typesize) {\n    case sizeof(float):\n      type = zfp_type_float;\n      break;\n    case sizeof(double):\n      type = zfp_type_double;\n      break;\n    default:\n      BLOSC_TRACE_ERROR(\"ZFP is not available for typesize: %d\", typesize);\n      return BLOSC2_ERROR_FAILURE;\n  }\n  uint8_t compmeta = context->compcode_meta;   // access to compressed chunk header\n  double rate = (double) (compmeta * typesize * 8) /\n                100.0;     // convert from output size / input size to output bits per input value\n  zfp_stream_set_rate(zfp, rate, type, ndim, zfp_false);\n\n  stream = stream_open((void *) block, cbytes);\n  zfp_stream_set_bit_stream(zfp, stream);\n  zfp_stream_rewind(zfp);\n\n  // Check that ncell is a valid index\n  int ncells = (int) ((cbytes * 8) / zfp->maxbits);\n  if (ncell >= ncells) {\n    BLOSC_TRACE_ERROR(\"Invalid cell index\");\n    return -1;\n  }\n\n  // Position the stream at the ncell bit offset for reading\n  stream_rseek(zfp->stream, (size_t) (ncell * zfp->maxbits));\n\n  // Get the cell\n  size_t zfpsize;\n  uint8_t *cell = malloc(cell_nitems * typesize);\n  switch (ndim) {\n    case 1:\n      if (type == zfp_type_float) {\n        zfpsize = zfp_decode_block_float_1(zfp, (float *) cell);\n      }\n      else {\n        zfpsize = zfp_decode_block_double_1(zfp, (double *) cell);\n      }\n      break;\n    case 2:\n      if (type == zfp_type_float) {\n        zfpsize = zfp_decode_block_float_2(zfp, (float *) cell);\n      }\n      else {\n        zfpsize = zfp_decode_block_double_2(zfp, (double *) cell);\n      }\n      break;\n    case 3:\n      if (type == zfp_type_float) {\n        zfpsize = zfp_decode_block_float_3(zfp, (float *) cell);\n      }\n      else {\n        zfpsize = zfp_decode_block_double_3(zfp, (double *) cell);\n      }\n      break;\n    case 4:\n      if (type == zfp_type_float) {\n        zfpsize = zfp_decode_block_float_4(zfp, (float *) cell);\n      }\n      else {\n        zfpsize = zfp_decode_block_double_4(zfp, (double *) cell);\n      }\n      break;\n    default:\n      BLOSC_TRACE_ERROR(\"ZFP is not available for ndims: %d\", ndim);\n      return BLOSC2_ERROR_FAILURE;\n  }\n  memcpy(dest, &cell[cell_ind * typesize], thread_ctx->zfp_cell_nitems * typesize);\n  zfp_stream_close(zfp);\n  stream_close(stream);\n  free(cell);\n\n  if ((zfpsize == 0) || ((int32_t) zfpsize > (destsize * 8)) ||\n      ((int32_t) zfpsize > (cell_nitems * typesize * 8)) ||\n      ((thread_ctx->zfp_cell_nitems * typesize * 8) > (int32_t) zfpsize)) {\n    BLOSC_TRACE_ERROR(\"ZFP error or small destsize\");\n    return -1;\n  }\n\n  return (int) (thread_ctx->zfp_cell_nitems * typesize);\n}\n"], "filenames": ["plugins/codecs/zfp/blosc2-zfp.c"], "buggy_code_start_loc": [28], "buggy_code_end_loc": [637], "fixing_code_start_loc": [29], "fixing_code_end_loc": [644], "type": "CWE-476", "message": "C-blosc2 before 2.9.3 was discovered to contain a NULL pointer dereference via the zfp/blosc2-zfp.c zfp_acc_decompress. function.", "other": {"cve": {"id": "CVE-2023-37187", "sourceIdentifier": "cve@mitre.org", "published": "2023-12-25T07:15:09.183", "lastModified": "2023-12-29T18:38:45.770", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "C-blosc2 before 2.9.3 was discovered to contain a NULL pointer dereference via the zfp/blosc2-zfp.c zfp_acc_decompress. function."}, {"lang": "es", "value": "Se descubri\u00f3 que C-blosc2 anterior a 2.9.3 conten\u00eda una desreferencia de puntero NULL mediante la funci\u00f3n zfp/blosc2-zfp.c zfp_acc_decompress."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:c-blosc2_project:c-blosc2:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.9.3", "matchCriteriaId": "075116F3-2BB5-414B-82A9-D132E60D4769"}]}]}], "references": [{"url": "https://github.com/Blosc/c-blosc2/commit/425e8a9a59d49378d57e2116b6c9b0190a5986f5", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/Blosc/c-blosc2/compare/v2.9.2...v2.9.3", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://github.com/Blosc/c-blosc2/issues/520", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/Blosc/c-blosc2/commit/425e8a9a59d49378d57e2116b6c9b0190a5986f5"}}