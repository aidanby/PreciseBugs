{"buggy_code": ["/* Copyright (C) 2011 the GSS-PROXY contributors, see COPYING for license */\n\n#include \"config.h\"\n#include <pthread.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"gp_proxy.h\"\n\n#define DEFAULT_WORKER_THREADS_NUM 5\n\n#define GP_QUERY_IN 0\n#define GP_QUERY_OUT 1\n#define GP_QUERY_ERR 2\n\nstruct gp_query {\n    struct gp_query *next;\n\n    struct gp_conn *conn;\n    uint8_t *buffer;\n    size_t buflen;\n\n    int status;\n};\n\nstruct gp_thread {\n    struct gp_thread *prev;\n    struct gp_thread *next;\n    struct gp_workers *pool;\n    pthread_t tid;\n\n    struct gp_query *query;\n    pthread_mutex_t cond_mutex;\n    pthread_cond_t cond_wakeup;\n};\n\nstruct gp_workers {\n    pthread_mutex_t lock;\n    struct gssproxy_ctx *gpctx;\n    bool shutdown;\n    struct gp_query *wait_list;\n    struct gp_query *reply_list;\n    struct gp_thread *free_list;\n    struct gp_thread *busy_list;\n    int num_threads;\n    int sig_pipe[2];\n};\n\nstatic void *gp_worker_main(void *pvt);\nstatic void gp_handle_query(struct gp_workers *w, struct gp_query *q);\nstatic void gp_handle_reply(verto_ctx *vctx, verto_ev *ev);\n\n/** DISPATCHER FUNCTIONS **/\n\nint gp_workers_init(struct gssproxy_ctx *gpctx)\n{\n    struct gp_workers *w;\n    struct gp_thread *t;\n    pthread_attr_t attr;\n    verto_ev *ev;\n    int vflags;\n    int ret;\n    int i;\n\n    w = calloc(1, sizeof(struct gp_workers));\n    if (!w) {\n        return ENOMEM;\n    }\n    w->gpctx = gpctx;\n\n    /* init global queue mutex */\n    ret = pthread_mutex_init(&w->lock, NULL);\n    if (ret) {\n        free(w);\n        return ENOMEM;\n    }\n\n    if (gpctx->config->num_workers > 0) {\n        w->num_threads = gpctx->config->num_workers;\n    } else {\n        w->num_threads = DEFAULT_WORKER_THREADS_NUM;\n    }\n\n    /* make thread joinable (portability) */\n    pthread_attr_init(&attr);\n    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);\n\n    /* init all workers */\n    for (i = 0; i < w->num_threads; i++) {\n        t = calloc(1, sizeof(struct gp_thread));\n        if (!t) {\n            ret = -1;\n            goto done;\n        }\n        t->pool = w;\n        ret = pthread_cond_init(&t->cond_wakeup, NULL);\n        if (ret) {\n            free(t);\n            goto done;\n        }\n        ret = pthread_mutex_init(&t->cond_mutex, NULL);\n        if (ret) {\n            free(t);\n            goto done;\n        }\n        ret = pthread_create(&t->tid, &attr, gp_worker_main, t);\n        if (ret) {\n            free(t);\n            goto done;\n        }\n        LIST_ADD(w->free_list, t);\n    }\n\n    /* add wakeup pipe, so that threads can hand back replies to the\n     * dispatcher */\n    ret = pipe2(w->sig_pipe, O_NONBLOCK | O_CLOEXEC);\n    if (ret == -1) {\n        goto done;\n    }\n\n    vflags = VERTO_EV_FLAG_PERSIST | VERTO_EV_FLAG_IO_READ;\n    ev = verto_add_io(gpctx->vctx, vflags, gp_handle_reply, w->sig_pipe[0]);\n    if (!ev) {\n        ret = -1;\n        goto done;\n    }\n    verto_set_private(ev, w, NULL);\n\n    gpctx->workers = w;\n    ret = 0;\n\ndone:\n    if (ret) {\n        gp_workers_free(w);\n    }\n    return ret;\n}\n\nvoid gp_workers_free(struct gp_workers *w)\n{\n    struct gp_thread *t;\n    void *retval;\n\n    /* ======> POOL LOCK */\n    pthread_mutex_lock(&w->lock);\n\n    w->shutdown = true;\n\n    /* <====== POOL LOCK */\n    pthread_mutex_unlock(&w->lock);\n\n    /* we do not run the following operations within\n     * the lock, or deadlocks may arise for threads\n     * that are just finishing doing some work */\n\n    /* we guarantee nobody is touching these lists by\n     * preventing workers from touching the free/busy\n     * lists when a 'shutdown' is in progress */\n\n    while (w->free_list) {\n        /* pick threads one by one */\n        t = w->free_list;\n        LIST_DEL(w->free_list, t);\n\n        /* wake up threads, then join them */\n        /* ======> COND_MUTEX */\n        pthread_mutex_lock(&t->cond_mutex);\n        pthread_cond_signal(&t->cond_wakeup);\n        /* <====== COND_MUTEX */\n        pthread_mutex_unlock(&t->cond_mutex);\n\n        pthread_join(t->tid, &retval);\n\n        pthread_mutex_destroy(&t->cond_mutex);\n        pthread_cond_destroy(&t->cond_wakeup);\n        free(t);\n    }\n\n    /* do the same with the busy list */\n    while (w->busy_list) {\n        /* pick threads one by one */\n        t = w->busy_list;\n        LIST_DEL(w->free_list, t);\n\n        /* wake up threads, then join them */\n        /* ======> COND_MUTEX */\n        pthread_mutex_lock(&t->cond_mutex);\n        pthread_cond_signal(&t->cond_wakeup);\n        /* <====== COND_MUTEX */\n        pthread_mutex_unlock(&t->cond_mutex);\n\n        pthread_join(t->tid, &retval);\n\n        pthread_mutex_destroy(&t->cond_mutex);\n        pthread_cond_destroy(&t->cond_wakeup);\n        free(t);\n    }\n\n    close(w->sig_pipe[0]);\n    close(w->sig_pipe[1]);\n\n    pthread_mutex_destroy(&w->lock);\n\n    free(w);\n}\n\nstatic void gp_query_assign(struct gp_workers *w, struct gp_query *q)\n{\n    struct gp_thread *t = NULL;\n\n    /* then either find a free thread or queue in the wait list */\n\n    /* ======> POOL LOCK */\n    pthread_mutex_lock(&w->lock);\n    if (w->free_list) {\n        t = w->free_list;\n        LIST_DEL(w->free_list, t);\n        LIST_ADD(w->busy_list, t);\n    }\n    /* <====== POOL LOCK */\n    pthread_mutex_unlock(&w->lock);\n\n    if (t) {\n        /* found free thread, assign work */\n\n        /* ======> COND_MUTEX */\n        pthread_mutex_lock(&t->cond_mutex);\n\n        /* hand over the query */\n        t->query = q;\n        pthread_cond_signal(&t->cond_wakeup);\n\n        /* <====== COND_MUTEX */\n        pthread_mutex_unlock(&t->cond_mutex);\n\n    } else {\n\n        /* all threads are busy, store in wait list */\n\n        /* only the dispatcher handles wait_list\n        *  so we do not need to lock around it */\n        q->next = w->wait_list;\n        w->wait_list = q;\n    }\n}\n\nstatic void gp_query_free(struct gp_query *q, bool free_buffer)\n{\n    if (!q) {\n        return;\n    }\n\n    if (free_buffer) {\n        free(q->buffer);\n    }\n\n    free(q);\n}\n\nint gp_query_new(struct gp_workers *w, struct gp_conn *conn,\n                 uint8_t *buffer, size_t buflen)\n{\n    struct gp_query *q;\n\n    /* create query struct */\n    q = calloc(1, sizeof(struct gp_query));\n    if (!q) {\n        return ENOMEM;\n    }\n\n    q->conn = conn;\n    q->buffer = buffer;\n    q->buflen = buflen;\n\n    gp_query_assign(w, q);\n\n    return 0;\n}\n\nstatic void gp_handle_reply(verto_ctx *vctx, verto_ev *ev)\n{\n    struct gp_workers *w;\n    struct gp_query *q = NULL;\n    char dummy;\n    int ret;\n\n    w = verto_get_private(ev);\n\n    /* first read out the dummy so the pipe doesn't get clogged */\n    ret = read(w->sig_pipe[0], &dummy, 1);\n    if (ret) {\n        /* ignore errors */\n    }\n\n    /* grab a query reply if any */\n    if (w->reply_list) {\n        /* ======> POOL LOCK */\n        pthread_mutex_lock(&w->lock);\n\n        if (w->reply_list != NULL) {\n            q = w->reply_list;\n            w->reply_list = q->next;\n        }\n\n        /* <====== POOL LOCK */\n        pthread_mutex_unlock(&w->lock);\n    }\n\n    if (q) {\n        switch (q->status) {\n        case GP_QUERY_IN:\n            /* ?! fallback and kill client conn */\n        case GP_QUERY_ERR:\n            GPDEBUGN(3, \"[status] Handling query error, terminating CID %d.\\n\",\n                     gp_conn_get_cid(q->conn));\n            gp_conn_free(q->conn);\n            gp_query_free(q, true);\n            break;\n\n        case GP_QUERY_OUT:\n            GPDEBUGN(3, \"[status] Handling query reply: %p (%zu)\\n\", q->buffer, q->buflen);\n            gp_socket_send_data(vctx, q->conn, q->buffer, q->buflen);\n            gp_query_free(q, false);\n            break;\n        }\n    }\n\n    /* while we are at it, check if there is anything in the wait list\n     * we need to process, as one thread just got free :-) */\n\n    q = NULL;\n\n    if (w->wait_list) {\n        /* only the dispatcher handles wait_list\n        *  so we do not need to lock around it */\n        if (w->wait_list) {\n            q = w->wait_list;\n            w->wait_list = q->next;\n            q->next = NULL;\n        }\n    }\n\n    if (q) {\n        gp_query_assign(w, q);\n    }\n}\n\n\n/** WORKER THREADS **/\n\nstatic void *gp_worker_main(void *pvt)\n{\n    struct gp_thread *t = (struct gp_thread *)pvt;\n    struct gp_query *q = NULL;\n    char dummy = 0;\n    int ret;\n\n    while (!t->pool->shutdown) {\n\n        /* initialize debug client id to 0 until work is scheduled */\n        gp_debug_set_conn_id(0);\n\n        /* ======> COND_MUTEX */\n        pthread_mutex_lock(&t->cond_mutex);\n        while (t->query == NULL) {\n            /* wait for next query */\n            pthread_cond_wait(&t->cond_wakeup, &t->cond_mutex);\n            if (t->pool->shutdown) {\n                pthread_exit(NULL);\n            }\n        }\n\n        /* grab the query off the shared pointer */\n        q = t->query;\n        t->query = NULL;\n\n        /* <====== COND_MUTEX */\n        pthread_mutex_unlock(&t->cond_mutex);\n\n        /* set client id before hndling requests */\n        gp_debug_set_conn_id(gp_conn_get_cid(q->conn));\n\n        /* handle the client request */\n        GPDEBUGN(3, \"[status] Handling query input: %p (%zu)\\n\", q->buffer,\n                 q->buflen);\n        gp_handle_query(t->pool, q);\n        GPDEBUGN(3 ,\"[status] Handling query output: %p (%zu)\\n\", q->buffer,\n                 q->buflen);\n\n        /* now get lock on main queue, to play with the reply list */\n        /* ======> POOL LOCK */\n        pthread_mutex_lock(&t->pool->lock);\n\n        /* put back query so that dispatcher can send reply */\n        q->next = t->pool->reply_list;\n        t->pool->reply_list = q;\n\n        /* add us back to the free list but only if we are not\n         * shutting down */\n        if (!t->pool->shutdown) {\n            LIST_DEL(t->pool->busy_list, t);\n            LIST_ADD(t->pool->free_list, t);\n        }\n\n        /* <====== POOL LOCK */\n        pthread_mutex_unlock(&t->pool->lock);\n\n        /* and wake up dispatcher so it will handle it */\n        ret = write(t->pool->sig_pipe[1], &dummy, 1);\n        if (ret == -1) {\n            GPERROR(\"Failed to signal dispatcher!\");\n        }\n    }\n\n    pthread_exit(NULL);\n}\n\nstatic void gp_handle_query(struct gp_workers *w, struct gp_query *q)\n{\n    struct gp_call_ctx gpcall = { 0 };\n    uint8_t *buffer;\n    size_t buflen;\n    int ret;\n\n    /* find service */\n    gpcall.gpctx = w->gpctx;\n    gpcall.service = gp_creds_match_conn(w->gpctx, q->conn);\n    if (!gpcall.service) {\n        q->status = GP_QUERY_ERR;\n        return;\n    }\n    gpcall.connection = q->conn;\n\n    ret = gp_rpc_process_call(&gpcall,\n                              q->buffer, q->buflen,\n                              &buffer, &buflen);\n    if (ret) {\n        q->status = GP_QUERY_ERR;\n    } else {\n        q->status = GP_QUERY_OUT;\n        free(q->buffer);\n        q->buffer = buffer;\n        q->buflen = buflen;\n    }\n\n    if (gpcall.destroy_callback) {\n        gpcall.destroy_callback(gpcall.destroy_callback_data);\n    }\n}\n\n"], "fixing_code": ["/* Copyright (C) 2011 the GSS-PROXY contributors, see COPYING for license */\n\n#include \"config.h\"\n#include <pthread.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"gp_proxy.h\"\n\n#define DEFAULT_WORKER_THREADS_NUM 5\n\n#define GP_QUERY_IN 0\n#define GP_QUERY_OUT 1\n#define GP_QUERY_ERR 2\n\nstruct gp_query {\n    struct gp_query *next;\n\n    struct gp_conn *conn;\n    uint8_t *buffer;\n    size_t buflen;\n\n    int status;\n};\n\nstruct gp_thread {\n    struct gp_thread *prev;\n    struct gp_thread *next;\n    struct gp_workers *pool;\n    pthread_t tid;\n\n    struct gp_query *query;\n    pthread_mutex_t cond_mutex;\n    pthread_cond_t cond_wakeup;\n};\n\nstruct gp_workers {\n    pthread_mutex_t lock;\n    struct gssproxy_ctx *gpctx;\n    bool shutdown;\n    struct gp_query *wait_list;\n    struct gp_query *reply_list;\n    struct gp_thread *free_list;\n    struct gp_thread *busy_list;\n    int num_threads;\n    int sig_pipe[2];\n};\n\nstatic void *gp_worker_main(void *pvt);\nstatic void gp_handle_query(struct gp_workers *w, struct gp_query *q);\nstatic void gp_handle_reply(verto_ctx *vctx, verto_ev *ev);\n\n/** DISPATCHER FUNCTIONS **/\n\nint gp_workers_init(struct gssproxy_ctx *gpctx)\n{\n    struct gp_workers *w;\n    struct gp_thread *t;\n    pthread_attr_t attr;\n    verto_ev *ev;\n    int vflags;\n    int ret;\n    int i;\n\n    w = calloc(1, sizeof(struct gp_workers));\n    if (!w) {\n        return ENOMEM;\n    }\n    w->gpctx = gpctx;\n\n    /* init global queue mutex */\n    ret = pthread_mutex_init(&w->lock, NULL);\n    if (ret) {\n        free(w);\n        return ENOMEM;\n    }\n\n    if (gpctx->config->num_workers > 0) {\n        w->num_threads = gpctx->config->num_workers;\n    } else {\n        w->num_threads = DEFAULT_WORKER_THREADS_NUM;\n    }\n\n    /* make thread joinable (portability) */\n    pthread_attr_init(&attr);\n    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);\n\n    /* init all workers */\n    for (i = 0; i < w->num_threads; i++) {\n        t = calloc(1, sizeof(struct gp_thread));\n        if (!t) {\n            ret = -1;\n            goto done;\n        }\n        t->pool = w;\n        ret = pthread_cond_init(&t->cond_wakeup, NULL);\n        if (ret) {\n            free(t);\n            goto done;\n        }\n        ret = pthread_mutex_init(&t->cond_mutex, NULL);\n        if (ret) {\n            free(t);\n            goto done;\n        }\n        ret = pthread_create(&t->tid, &attr, gp_worker_main, t);\n        if (ret) {\n            free(t);\n            goto done;\n        }\n        LIST_ADD(w->free_list, t);\n    }\n\n    /* add wakeup pipe, so that threads can hand back replies to the\n     * dispatcher */\n    ret = pipe2(w->sig_pipe, O_NONBLOCK | O_CLOEXEC);\n    if (ret == -1) {\n        goto done;\n    }\n\n    vflags = VERTO_EV_FLAG_PERSIST | VERTO_EV_FLAG_IO_READ;\n    ev = verto_add_io(gpctx->vctx, vflags, gp_handle_reply, w->sig_pipe[0]);\n    if (!ev) {\n        ret = -1;\n        goto done;\n    }\n    verto_set_private(ev, w, NULL);\n\n    gpctx->workers = w;\n    ret = 0;\n\ndone:\n    if (ret) {\n        gp_workers_free(w);\n    }\n    return ret;\n}\n\nvoid gp_workers_free(struct gp_workers *w)\n{\n    struct gp_thread *t;\n    void *retval;\n\n    /* ======> POOL LOCK */\n    pthread_mutex_lock(&w->lock);\n\n    w->shutdown = true;\n\n    /* <====== POOL LOCK */\n    pthread_mutex_unlock(&w->lock);\n\n    /* we do not run the following operations within\n     * the lock, or deadlocks may arise for threads\n     * that are just finishing doing some work */\n\n    /* we guarantee nobody is touching these lists by\n     * preventing workers from touching the free/busy\n     * lists when a 'shutdown' is in progress */\n\n    while (w->free_list) {\n        /* pick threads one by one */\n        t = w->free_list;\n        LIST_DEL(w->free_list, t);\n\n        /* wake up threads, then join them */\n        /* ======> COND_MUTEX */\n        pthread_mutex_lock(&t->cond_mutex);\n        pthread_cond_signal(&t->cond_wakeup);\n        /* <====== COND_MUTEX */\n        pthread_mutex_unlock(&t->cond_mutex);\n\n        pthread_join(t->tid, &retval);\n\n        pthread_mutex_destroy(&t->cond_mutex);\n        pthread_cond_destroy(&t->cond_wakeup);\n        free(t);\n    }\n\n    /* do the same with the busy list */\n    while (w->busy_list) {\n        /* pick threads one by one */\n        t = w->busy_list;\n        LIST_DEL(w->free_list, t);\n\n        /* wake up threads, then join them */\n        /* ======> COND_MUTEX */\n        pthread_mutex_lock(&t->cond_mutex);\n        pthread_cond_signal(&t->cond_wakeup);\n        /* <====== COND_MUTEX */\n        pthread_mutex_unlock(&t->cond_mutex);\n\n        pthread_join(t->tid, &retval);\n\n        pthread_mutex_destroy(&t->cond_mutex);\n        pthread_cond_destroy(&t->cond_wakeup);\n        free(t);\n    }\n\n    close(w->sig_pipe[0]);\n    close(w->sig_pipe[1]);\n\n    pthread_mutex_destroy(&w->lock);\n\n    free(w);\n}\n\nstatic void gp_query_assign(struct gp_workers *w, struct gp_query *q)\n{\n    struct gp_thread *t = NULL;\n\n    /* then either find a free thread or queue in the wait list */\n\n    /* ======> POOL LOCK */\n    pthread_mutex_lock(&w->lock);\n    if (w->free_list) {\n        t = w->free_list;\n        LIST_DEL(w->free_list, t);\n        LIST_ADD(w->busy_list, t);\n    }\n    /* <====== POOL LOCK */\n    pthread_mutex_unlock(&w->lock);\n\n    if (t) {\n        /* found free thread, assign work */\n\n        /* ======> COND_MUTEX */\n        pthread_mutex_lock(&t->cond_mutex);\n\n        /* hand over the query */\n        t->query = q;\n        pthread_cond_signal(&t->cond_wakeup);\n\n        /* <====== COND_MUTEX */\n        pthread_mutex_unlock(&t->cond_mutex);\n\n    } else {\n\n        /* all threads are busy, store in wait list */\n\n        /* only the dispatcher handles wait_list\n        *  so we do not need to lock around it */\n        q->next = w->wait_list;\n        w->wait_list = q;\n    }\n}\n\nstatic void gp_query_free(struct gp_query *q, bool free_buffer)\n{\n    if (!q) {\n        return;\n    }\n\n    if (free_buffer) {\n        free(q->buffer);\n    }\n\n    free(q);\n}\n\nint gp_query_new(struct gp_workers *w, struct gp_conn *conn,\n                 uint8_t *buffer, size_t buflen)\n{\n    struct gp_query *q;\n\n    /* create query struct */\n    q = calloc(1, sizeof(struct gp_query));\n    if (!q) {\n        return ENOMEM;\n    }\n\n    q->conn = conn;\n    q->buffer = buffer;\n    q->buflen = buflen;\n\n    gp_query_assign(w, q);\n\n    return 0;\n}\n\nstatic void gp_handle_reply(verto_ctx *vctx, verto_ev *ev)\n{\n    struct gp_workers *w;\n    struct gp_query *q = NULL;\n    char dummy;\n    int ret;\n\n    w = verto_get_private(ev);\n\n    /* first read out the dummy so the pipe doesn't get clogged */\n    ret = read(w->sig_pipe[0], &dummy, 1);\n    if (ret) {\n        /* ignore errors */\n    }\n\n    /* grab a query reply if any */\n    if (w->reply_list) {\n        /* ======> POOL LOCK */\n        pthread_mutex_lock(&w->lock);\n\n        if (w->reply_list != NULL) {\n            q = w->reply_list;\n            w->reply_list = q->next;\n        }\n\n        /* <====== POOL LOCK */\n        pthread_mutex_unlock(&w->lock);\n    }\n\n    if (q) {\n        switch (q->status) {\n        case GP_QUERY_IN:\n            /* ?! fallback and kill client conn */\n        case GP_QUERY_ERR:\n            GPDEBUGN(3, \"[status] Handling query error, terminating CID %d.\\n\",\n                     gp_conn_get_cid(q->conn));\n            gp_conn_free(q->conn);\n            gp_query_free(q, true);\n            break;\n\n        case GP_QUERY_OUT:\n            GPDEBUGN(3, \"[status] Handling query reply: %p (%zu)\\n\", q->buffer, q->buflen);\n            gp_socket_send_data(vctx, q->conn, q->buffer, q->buflen);\n            gp_query_free(q, false);\n            break;\n        }\n    }\n\n    /* while we are at it, check if there is anything in the wait list\n     * we need to process, as one thread just got free :-) */\n\n    q = NULL;\n\n    if (w->wait_list) {\n        /* only the dispatcher handles wait_list\n        *  so we do not need to lock around it */\n        if (w->wait_list) {\n            q = w->wait_list;\n            w->wait_list = q->next;\n            q->next = NULL;\n        }\n    }\n\n    if (q) {\n        gp_query_assign(w, q);\n    }\n}\n\n\n/** WORKER THREADS **/\n\nstatic void *gp_worker_main(void *pvt)\n{\n    struct gp_thread *t = (struct gp_thread *)pvt;\n    struct gp_query *q = NULL;\n    char dummy = 0;\n    int ret;\n\n    while (!t->pool->shutdown) {\n\n        /* initialize debug client id to 0 until work is scheduled */\n        gp_debug_set_conn_id(0);\n\n        /* ======> COND_MUTEX */\n        pthread_mutex_lock(&t->cond_mutex);\n        while (t->query == NULL) {\n            /* wait for next query */\n            pthread_cond_wait(&t->cond_wakeup, &t->cond_mutex);\n            if (t->pool->shutdown) {\n                pthread_mutex_unlock(&t->cond_mutex);\n                pthread_exit(NULL);\n            }\n        }\n\n        /* grab the query off the shared pointer */\n        q = t->query;\n        t->query = NULL;\n\n        /* <====== COND_MUTEX */\n        pthread_mutex_unlock(&t->cond_mutex);\n\n        /* set client id before hndling requests */\n        gp_debug_set_conn_id(gp_conn_get_cid(q->conn));\n\n        /* handle the client request */\n        GPDEBUGN(3, \"[status] Handling query input: %p (%zu)\\n\", q->buffer,\n                 q->buflen);\n        gp_handle_query(t->pool, q);\n        GPDEBUGN(3 ,\"[status] Handling query output: %p (%zu)\\n\", q->buffer,\n                 q->buflen);\n\n        /* now get lock on main queue, to play with the reply list */\n        /* ======> POOL LOCK */\n        pthread_mutex_lock(&t->pool->lock);\n\n        /* put back query so that dispatcher can send reply */\n        q->next = t->pool->reply_list;\n        t->pool->reply_list = q;\n\n        /* add us back to the free list but only if we are not\n         * shutting down */\n        if (!t->pool->shutdown) {\n            LIST_DEL(t->pool->busy_list, t);\n            LIST_ADD(t->pool->free_list, t);\n        }\n\n        /* <====== POOL LOCK */\n        pthread_mutex_unlock(&t->pool->lock);\n\n        /* and wake up dispatcher so it will handle it */\n        ret = write(t->pool->sig_pipe[1], &dummy, 1);\n        if (ret == -1) {\n            GPERROR(\"Failed to signal dispatcher!\");\n        }\n    }\n\n    pthread_exit(NULL);\n}\n\nstatic void gp_handle_query(struct gp_workers *w, struct gp_query *q)\n{\n    struct gp_call_ctx gpcall = { 0 };\n    uint8_t *buffer;\n    size_t buflen;\n    int ret;\n\n    /* find service */\n    gpcall.gpctx = w->gpctx;\n    gpcall.service = gp_creds_match_conn(w->gpctx, q->conn);\n    if (!gpcall.service) {\n        q->status = GP_QUERY_ERR;\n        return;\n    }\n    gpcall.connection = q->conn;\n\n    ret = gp_rpc_process_call(&gpcall,\n                              q->buffer, q->buflen,\n                              &buffer, &buflen);\n    if (ret) {\n        q->status = GP_QUERY_ERR;\n    } else {\n        q->status = GP_QUERY_OUT;\n        free(q->buffer);\n        q->buffer = buffer;\n        q->buflen = buflen;\n    }\n\n    if (gpcall.destroy_callback) {\n        gpcall.destroy_callback(gpcall.destroy_callback_data);\n    }\n}\n\n"], "filenames": ["src/gp_workers.c"], "buggy_code_start_loc": [371], "buggy_code_end_loc": [371], "fixing_code_start_loc": [372], "fixing_code_end_loc": [373], "type": "CWE-667", "message": "** DISPUTED ** gssproxy (aka gss-proxy) before 0.8.3 does not unlock cond_mutex before pthread exit in gp_worker_main() in gp_workers.c. NOTE: An upstream comment states \"We are already on a shutdown path when running the code in question, so a DoS there doesn't make any sense, and there has been no additional information provided us (as upstream) to indicate why this would be a problem.\"", "other": {"cve": {"id": "CVE-2020-12658", "sourceIdentifier": "cve@mitre.org", "published": "2020-12-31T01:15:12.553", "lastModified": "2021-02-08T13:46:16.590", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "** DISPUTED ** gssproxy (aka gss-proxy) before 0.8.3 does not unlock cond_mutex before pthread exit in gp_worker_main() in gp_workers.c. NOTE: An upstream comment states \"We are already on a shutdown path when running the code in question, so a DoS there doesn't make any sense, and there has been no additional information provided us (as upstream) to indicate why this would be a problem.\""}, {"lang": "es", "value": "** EN DISPUTA ** gssproxy (tambi\u00e9n se conoce como gss-proxy) versiones anteriores a 0.8.3 no desbloquea cond_mutex antes de la salida de pthread en la funci\u00f3n gp_worker_main() en el archivo gp_workers.c. NOTA: Un comentario de la corriente ascendente dice: \"Ya estamos en una ruta de apagado al ejecutar el c\u00f3digo en cuesti\u00f3n, por lo que un DoS all\u00ed no tiene ning\u00fan sentido, y no se nos ha proporcionado informaci\u00f3n adicional (como corriente ascendente) para indicar por qu\u00e9 esto ser\u00eda un problema\"."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-667"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gssproxy_project:gssproxy:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.8.3", "matchCriteriaId": "49B6C938-D1D0-4618-B7DD-BFF581135BE5"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://github.com/gssapi/gssproxy/commit/cb761412e299ef907f22cd7c4146d50c8a792003", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gssapi/gssproxy/compare/v0.8.2...v0.8.3", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/01/msg00004.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://pagure.io/gssproxy/c/cb761412e299ef907f22cd7c4146d50c8a792003?branch=master", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gssapi/gssproxy/commit/cb761412e299ef907f22cd7c4146d50c8a792003"}}